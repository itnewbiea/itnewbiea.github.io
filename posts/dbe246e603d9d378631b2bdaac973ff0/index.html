<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法对比、总结(Python代码) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序算法对比、总结(Python代码)" />
<meta property="og:description" content="上海站 | 高性能计算之GPU CUDA培训 4月13-15日 三天密集式学习 快速带你晋级 阅读全文 &gt; 正文共6126个字，27张图，预计阅读时间16分钟。
排序大的分类可以分为两种：内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。下面讲的排序都是属于内排序。
内排序有可以分为以下几类：
1、插入排序：直接插入排序、二分法插入排序、希尔排序。
2、选择排序：直接选择排序、堆排序。
3、交换排序：冒泡排序、快速排序。
4、归并排序
5、基数排序
对比 61520931627_.pi
冒泡排序 1.基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。
2.过程：
比较相邻的两个数据，如果第二个数小，就交换位置。
从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。
继续重复上述过程，依次将第2.3...n-1个最小数排好位置。
image
3.平均时间复杂度：O(n2)
4.优化：
针对问题：
数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。
方案：
设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。
这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。
5.Python代码实现：
@staticmethoddef bubble_sort(arr): for i in range(len(arr)): not_change = True for j in range(len(arr) - 1, i - 1, -1): if arr[j] &lt; arr[j - 1]: tmp = arr[j] arr[j] = arr[j - 1] arr[j - 1] = tmp not_change = False if not_change: break" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/dbe246e603d9d378631b2bdaac973ff0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-22T00:00:00+08:00" />
<meta property="article:modified_time" content="2018-03-22T00:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法对比、总结(Python代码)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="rich_media_content " id="js_content"> 
 <section class="xmteditor" style="display:none;"></section> 
 <section style="font-size: 16px;white-space: normal;"> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="padding: 10px;box-sizing: border-box;"> 
    <section style="padding: 15px;box-shadow: rgb(204, 204, 204) 0px 0px 5px 0px;box-sizing: border-box;"> 
     <section style="width: 719.333px;font-size: 18px;"> 
      <strong><h3 class="rich_media_title">上海站 | 高性能计算之GPU CUDA培训</h3></strong> 
     </section> 
     <section style="margin-top: 10px;width: 719.333px;font-size: 14px;color: rgb(140, 140, 140);">
       4月13-15日 
     </section> 
     <section style="margin-top: 10px;width: 719.333px;"> 
      <img class=" " style="height: auto !important; width: 558px !important; display: block; visibility: visible !important;" src="https://images2.imgbox.com/34/58/hlhkPrQC_o.png"> 
     </section> 
     <section style="margin-top: 10px;width: 719.333px;font-size: 14px;color: rgb(140, 140, 140);">
       三天密集式学习  快速带你晋级 
     </section> 
     <section style="margin-top: 10px;width: 719.333px;border-bottom: 1px solid rgb(89, 195, 249);box-sizing: border-box;"></section> 
     <section style="margin-top: 10px;width: 719.333px;display: -webkit-flex;justify-content: space-between;"> 
      <section style="line-height: 30px;"> 
       <a href="https://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247485739&amp;idx=3&amp;sn=5810844f654969e9a6e7f7c6bac9d958&amp;chksm=eadba0f6ddac29e073ee94e6577f5cf32959b9e8ea781f98c5800e08a5f8e5857ba951c8e33a&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank"><span style="color: rgb(0, 82, 255);">阅读全文</span></a> 
      </section> 
      <section style="color: rgb(89, 195, 249);font-size: 30px;line-height: 30px;"> 
       <strong>&gt;</strong> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="font-size: 14px;color: rgb(38, 38, 38);">正文共6126个字，27张图，预计阅读时间16分钟。</span></p> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">排序大的分类可以分为两种：内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。下面讲的排序都是属于内排序。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">内排序有可以分为以下几类：</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">1、插入排序：直接插入排序、二分法插入排序、希尔排序。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">2、选择排序：直接选择排序、堆排序。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">3、交换排序：冒泡排序、快速排序。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">4、归并排序</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">5、基数排序</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       对比 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><img class=" img_loading" style="width: 670px !important; height: 280.4428571428572px !important;" src="https://images2.imgbox.com/d4/a1/nqMtxS8c_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">61520931627_.pi</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       冒泡排序 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">1.基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br>2.过程：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">比较相邻的两个数据，如果第二个数小，就交换位置。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">继续重复上述过程，依次将第2.3...n-1个最小数排好位置。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 312.0285714285714px !important;" src="https://images2.imgbox.com/5a/3e/39es9Tct_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">3.平均时间复杂度：O(n2)</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br>4.优化：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">针对问题：</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">方案：</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">这样当一轮比较结</span><span style="color: rgb(38, 38, 38);font-size: 14px;">束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。</span></p> 
  <p><span style="color: rgb(38, 38, 38);font-size: 14px;"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">5.Python代码实现：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">@staticmethoddef bubble_sort(arr):    for i in range(len(arr)):        not_change = True        for j in range(len(arr) - 1, i - 1, -1):           </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"> if arr[j] &lt; arr[j - 1]:                tmp = arr[j]                arr[j] = arr[j - 1]                arr[j - 1] = tmp                not_change = False        if not_change:            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">break</span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">return arr</span></p> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       选择排序 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">1.基本思想：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">第二次遍历n-2个数，找到最小的数值与第二个元素交换；</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br>第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">2.过程：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 320.64285714285717px !important;" src="https://images2.imgbox.com/47/7f/s0AbejUZ_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">3.平均时间复杂度：O(n2)</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br>4.python代码实现：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">@staticmethoddef select_sort(arr):    for index in range(len(arr)):        min_index = index        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">for j in range(index + 1, len(arr)):            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">if arr[j] &lt; arr[min_index]:                min_index = j        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">if min_index != index:            tmp = arr[index]            arr[index] = arr[min_index]            arr[min_index] = tmp    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">return arr</span></p> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       插入排序 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">1.基本思想：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">2.过程：</span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 320.64285714285717px !important;" src="https://images2.imgbox.com/56/56/VgVYFoEV_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 14px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><img class=" img_loading" style="width: 257px !important; height: 226px !important;" src="https://images2.imgbox.com/7c/f3/GTv5IGzd_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">3.平均时间复杂度：O(n2)</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">4.python代码实现：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">@staticmethoddef insert_sort(arr):    for index in range(len(arr) - 1):        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">f</span><span style="color: rgb(38, 38, 38);font-size: 12px;">or j in range(index + 1, 0, -1):          </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;"> if arr[j] &lt; arr[j - 1]:</span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">                tmp = arr[j]                arr[j] = arr[j - 1]                arr[j - 1] = tmp            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">else:                </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">break    return arr</span></p> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       希尔排序 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">1.基本思想：</span></p> 
  <p><span style="font-size: 14px;"><span style="color: rgb(0, 176, 240);"><br></span><span style="color: rgb(38, 38, 38);">希尔排序是把记</span></span><span style="color: rgb(38, 38, 38);font-size: 14px;">录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</span></p> 
  <p><span style="color: rgb(38, 38, 38);font-size: 14px;"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">2.过程：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 698.7142857142858px !important;" src="https://images2.imgbox.com/c3/45/mFG4Oplr_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">3.平均时间复杂度：O（n*logn）</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">4.python代码实现：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">def shell_sort(arr):    gap = len(arr)    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">while True:        gap = int(gap / 2)        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">for arr_index in range(gap):            print('arr_index:', arr_index)            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">for element in range(arr_index, len(arr) - 1, gap):                print('element:', element)                </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">for j in range(element, arr_index, -gap):                    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"># print('j', j)                    if arr[j] &lt; arr[element - gap]:                        tmp = arr[element - gap]                        arr[element - gap] = arr[j]                        arr[j] = tmp                    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">else:                        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">break        if gap == 1:            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">break    return arr</span></p> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       快速排序 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">1.基本思想：（分治）</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">先从数列中取出一个数作为key值；</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">对左右两个小数列重复第二步，直至各区间只有1个数。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">2.过程</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">1）初始时 i = 0; j = 9; key=72<br>由于已经将a[0]中的数保存到key中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br>从j开始向前找一个比key小的数。当j=8，符合条件，a[0] = a[8] ; i++ ; 将a[8]挖出再填到上一个坑a[0]中。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br>这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br>这次从i开始向后找一个大于key的数，当i=3，符合条件，a[8] = a[3] ; j-- ; 将a[3]挖出再填到上一个坑中。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p style="text-align: center;"><img class=" img_loading" style="width: 447px !important; height: 68px !important;" src="https://images2.imgbox.com/c0/f7/p7OOzbBz_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">2）此时 i = 3; j = 7; key=72<br>再重复上面的步骤，先从后向前找，再从前向后找。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br>从i开始向后找，当i=5时，由于i==j退出。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将key填入a[5]。</span></p> 
  <p><br></p> 
  <p style="text-align: center;"><img class=" img_loading" style="width: 480px !important; height: 69px !important;" src="https://images2.imgbox.com/6f/41/SPiX08yZ_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">3）可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p style="text-align: center;"><img class=" img_loading" style="width: 451px !important; height: 69px !important;" src="https://images2.imgbox.com/ce/de/BSytQyoZ_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">3.平均时间复杂度：O(N*logN)</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);">4.Python代码实现：</span></p> 
  <p><span style="font-size: 14px;color: rgb(0, 176, 240);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">def quick_sort(self, arr, left, right):    if left &gt;= right:        return    key = arr[left]    i = left    j = right    while i &lt; j:        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">while i &lt; j and arr[j] &gt;= key:            j -= 1        if i &lt; j:            arr[i] = arr[j]            i += 1        while i &lt; j and arr[i] &lt; key:            i += 1        if i &lt; j:            arr[j] = arr[i]            j -= 1    arr[i] = key    self.quick_sort(arr, left, i - 1)    self.quick_sort(arr, i + 1, right)    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">return arr</span></p> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       堆排序 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <h4 style="font-weight: bold;line-height: 1.6em;"><span style="font-size: 14px;color: rgb(38, 38, 38);">堆</span></h4> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 290.01428571428573px !important;" src="https://images2.imgbox.com/95/47/9ZM4OlF8_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 121.55714285714286px !important;" src="https://images2.imgbox.com/23/1f/p9RJdDuD_o.png"></p> 
  <p style="text-align: center;"><span style="color: rgb(38, 38, 38);font-size: 12px;">image</span></p> 
  <p style="text-align: center;"><span style="color: rgb(38, 38, 38);font-size: 12px;"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       堆排序基本思想及步骤 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <h5 style="font-weight: bold;line-height: 1.6em;"><span style="font-size: 14px;color: rgb(38, 38, 38);">步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</span></h5> 
  <p style="text-align: center;"><img class=" img_loading" style="width: 670px !important; height: 624.0571428571428px !important;" src="https://images2.imgbox.com/fe/57/eBWScNKd_o.png"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p><br></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">假设给定无序序列结构如下</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">1、此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 268px !important;" src="https://images2.imgbox.com/b3/ab/VDDRRJor_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">2、找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 278.5285714285714px !important;" src="https://images2.imgbox.com/7a/20/KHZWh1ut_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 256.5142857142857px !important;" src="https://images2.imgbox.com/42/b6/Sx0w47uZ_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <h5 style="font-weight: bold;line-height: 1.6em;"><span style="font-size: 14px;color: rgb(38, 38, 38);">步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</span></h5> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">3、将堆顶元素9和末尾元素4进行交换</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 243.11428571428573px !important;" src="https://images2.imgbox.com/33/ab/opsMCpCF_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">4、重新调整结构，使其继续满足堆定义</span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 249.8142857142857px !important;" src="https://images2.imgbox.com/ff/57/Qgqt8QHu_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">5、再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 254.6px !important;" src="https://images2.imgbox.com/21/a7/n0MYyRD5_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</span></p> 
  <p><img class=" img_loading" style="width: 426px !important; height: 390px !important;" src="https://images2.imgbox.com/32/6b/8kCLPeW4_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">501521032602_.pi</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">再简单总结下堆排序的基本思路：</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">代码实现：</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">@staticmethoddef heap_sort(arr):    # 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）    def adjuct_heap(array, index, length):        # 先取出当前元素i        temp = array[index]        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"># 从i结点的左子结点开始，也就是2i + 1处开始        k = index * 2 + 1        while k &lt; length:            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"># 如果左子结点小于右子结点，k指向右子结点            if k + 1 &lt; length and array[k] &lt; array[k + 1]:                k += 1            # 如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）            if array[k] &gt; temp:                array[index] = array[k]                index = k            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">else:               </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"> break            k = 2 * k + 1        # 将temp值放到最终的位置        array[index] = temp    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"># 构建最大堆    for i in range(int(len(arr) / 2 - 1), -1, -1):        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"># 从第一个非叶子节点从下至上，从右至左调整结构        adjuct_heap(arr, i, len(arr))    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">for j in range(len(arr) - 1, -1, -1):        tmp = arr[j]        arr[j] = arr[0]        arr[0] = tmp        adjuct_heap(arr, 0, j)    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">return arr</span></p> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       归并排序 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 513.0285714285714px !important;" src="https://images2.imgbox.com/62/7e/IEAmHXQw_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 13px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 13px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       合并相邻有序子序列 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 592.4714285714285px !important;" src="https://images2.imgbox.com/d0/21/PZhhBS2x_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 320.64285714285717px !important;" src="https://images2.imgbox.com/ba/28/Q62dOSoJ_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <h4 style="font-weight: bold;line-height: 1.6em;"><span style="font-size: 14px;color: rgb(38, 38, 38);">Python代码：</span></h4> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">def merge_sort(self, lists):    def merge(left, right):        i, j = 0, 0        result = []        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">while i &lt; len(left) and j &lt; len(right):            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">if left[i] &lt;= right[j]:                result.append(left[I])                i += 1            else:                result.append(right[j])                j += 1        result += left[I:]        result += right[j:]        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">return result   </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"> # 归并排序    if len(lists) &lt;= 1:        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">return lists    num = int(len(lists) / 2)    left = self.merge_sort(lists[:num])    right = self.merge_sort(lists[num:])    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">return merge(left, right)</span></p> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="margin: 10px auto;width: 769.333px;background-color: rgb(251, 251, 251);border-bottom: 1px solid rgb(246, 246, 246);overflow: hidden;box-sizing: border-box;"> 
    <section style="margin-right: 60px;margin-left: -30px;padding-left: 30px;display: inline-block;width: auto;background-color: rgb(89, 195, 249);border-radius: 0px 0px 10px;color: rgb(255, 255, 255);transform: skew(-30deg);"> 
     <section class="135brush" style="padding: 8px 30px 8px 20px;transform: skew(30deg);">
       基数排序 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">不需要直接对元素进行相互比较，也不需要将元素相互交换，你需要做的就是对元素进行“分类”。这也是基数排序的魅力所在，基数排序可以理解成是建立在“计数排序”的基础之上的一种排序算法。在实际项目中，如果对效率有所要求，而不太关心空间的使用时，我会选择用计数排序（当然还有一些其他的条件），或是一些计数排序的变形。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">如果我们的无序是 T = [ 2314, 5428, 373, 2222, 17 ]，那么其排序的过程就如下两幅所示。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 540px !important; height: 566px !important;" src="https://images2.imgbox.com/a1/ef/C7yBhlPY_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">上面这幅图，或许你已经在其他的博客里见到过。这是一个很好的引导跟说明。在基数排序里，我们需要一个很大的二维数组，二维数组的大小是 （10 * n）。10 代表的是我们每个元素的每一位都有 10 种可能，也就是 10 进制数。在上图中，我们是以每个数的个位来代表这个数，于是，5428 就被填充到了第 8 个桶中了。下次再进行填充的时候，就是以十位进行填充，比如 5428 在此时，就会选择以 2 来代表它。</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 357.0142857142857px !important;" src="https://images2.imgbox.com/85/e3/TUiHJsSf_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">基数排序过程图-1</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 296.7142857142857px !important;" src="https://images2.imgbox.com/18/d4/XaCF5baA_o.png"></p> 
  <p style="text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 12px;">image</span></p> 
  <p style="text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 12px;"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">基数排序过程图-2</span></p> 
  <p><img class=" img_loading" style="width: 670px !important; height: 309.15714285714284px !important;" src="https://images2.imgbox.com/ae/7e/QEdGlZGn_o.png"></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);">image</span></p> 
  <p style="text-align: center;"><span style="font-size: 12px;color: rgb(127, 127, 127);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">python代码：</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <section class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section style="display: inline-block;width: 769.333px;vertical-align: top;border-width: 4px 1px 1px 4px;box-sizing: border-box;border-radius: 0px;border-style: solid;border-color: rgb(89, 195, 249);"> 
    <section class="135brush" style="margin: 15px;"> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">@staticmethoddef radix_sort(lists, radix=10):    # k = int(math.ceil(math.log(max(lists), radix)))    k = radix    bucket = [[] for i in range(radix)]    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">for i in range(k):        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">for j in lists:            bucket[int(j / (radix ** (i - 1)) % (radix))].append(j)            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;"># bucket[int(j % (radix))].append(j)        del lists[:]        </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">for z in bucket:            lists += z            </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">del z[:]        print(lists)    </span></p> 
     <p><span style="color: rgb(38, 38, 38);font-size: 12px;white-space: pre-wrap;">return lists</span></p> 
    </section> 
   </section> 
  </section> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);">参考链接：<br>http://python.jobbole.com/82270/<br>https://www.jianshu.com/p/ae97c3ceea8d<br>https://www.cnblogs.com/chengxiao/p/6194356.html</span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"><br></span></p> 
  <p><span style="font-size: 14px;color: rgb(38, 38, 38);"></span></p> 
  <section class="" style="max-width: 100%;color: rgb(62, 62, 62);"> 
   <p class="" style="margin: 10px auto;padding: 10px;max-width: 100%;min-height: 1em;width: 670px;border-top: 2px solid rgb(89, 195, 249);border-left-width: 0px;border-bottom: 2px solid rgb(89, 195, 249);line-height: 25px;color: rgb(89, 195, 249);font-weight: bold;text-align: center;border-right-color: rgb(89, 195, 249);border-left-color: rgb(89, 195, 249);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">原文链接：https://www.jianshu.com/p/8e269451795d</span></p> 
  </section> 
  <p style="max-width: 100%;min-height: 1em;color: rgb(62, 62, 62);"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
  <section class="" style="max-width: 100%;color: rgb(62, 62, 62);"> 
   <blockquote style="margin-top: 10px;margin-bottom: 10px;padding-top: 10px;padding-right: 10px;padding-bottom: 10px;border-width: 1px 1px 1px 5px;border-top-style: solid;border-right-style: solid;border-bottom-style: solid;border-color: rgb(238, 238, 238) rgb(238, 238, 238) rgb(238, 238, 238) rgb(89, 195, 249);max-width: 100%;border-radius: 3px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
    <p class="" style="margin-top: 5px;margin-bottom: 5px;max-width: 100%;min-height: 1em;color: rgb(89, 195, 249);font-weight: bold;font-size: 18px;border-color: rgb(89, 195, 249);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">查阅更为简洁方便的分类文章以及最新的课程、产品信息，请移步至全新呈现的“LeadAI学院官网”：</span></p> 
    <p class="" style="margin-top: 5px;margin-bottom: 5px;max-width: 100%;min-height: 1em;color: rgb(89, 195, 249);font-weight: bold;font-size: 18px;border-color: rgb(89, 195, 249);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;box-sizing: border-box !important;word-wrap: break-word !important;">www.leadai.org</span></p> 
   </blockquote> 
  </section> 
  <p style="max-width: 100%;min-height: 1em;color: rgb(62, 62, 62);"><span style="max-width: 100%;color: rgb(0, 128, 255);font-family: 微软雅黑;font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></span></p> 
  <p style="max-width: 100%;min-height: 1em;color: rgb(62, 62, 62);text-align: center;"><span style="max-width: 100%;color: rgb(0, 128, 255);font-family: 微软雅黑;font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">请关注人工智能LeadAI公众号，查看更多专业文章</span></p> 
  <section style="max-width: 100%;color: rgb(62, 62, 62);"> 
   <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
    <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
     <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
      <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
       <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
        <section class="" style="max-width: 100%;box-sizing: border-box;border-width: 0px;border-style: none;border-color: initial;word-wrap: break-word !important;"> 
         <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
          <section class="" style="max-width: 100%;box-sizing: border-box;border-width: 0px;border-style: none;border-color: initial;word-wrap: break-word !important;"> 
           <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
            <section class="" style="max-width: 100%;box-sizing: border-box;border-width: 0px;border-style: none;border-color: initial;word-wrap: break-word !important;"> 
             <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
              <section class="" style="max-width: 100%;box-sizing: border-box;border-width: 0px;border-style: none;border-color: initial;word-wrap: break-word !important;"> 
               <section style="max-width: 100%;font-family: 微软雅黑;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                 <p style="max-width: 100%;min-height: 1em;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;"><img class=" img_loading" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 106px !important; height: 106px !important;" width="106px" src="https://images2.imgbox.com/6d/cc/eLj0zTK2_o.png"></p> 
                 <p style="max-width: 100%;min-height: 1em;font-size: 20px;width: 670px;color: rgb(114, 114, 114);text-align: center;font-weight: bold;box-sizing: border-box !important;word-wrap: break-word !important;">大家都在看</p> 
                 <section style="max-width: 100%;line-height: 25.6px;width: 670px;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <section style="padding-right: 10px;padding-left: 10px;display: inline-block;max-width: 100%;box-sizing: border-box;overflow: hidden;background-color: rgb(254, 254, 254);word-wrap: break-word !important;"> 
                   <img class="" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 16px !important; height: 15px !important;" width="auto" src="https://images2.imgbox.com/d5/c6/vRD8Q9iE_o.png"> 
                  </section> 
                 </section> 
                 <section style="margin-top: -20px;max-width: 100%;box-sizing: border-box;line-height: 25.6px;width: 670px;border-bottom: 1px solid rgb(114, 114, 114);word-wrap: break-word !important;"></section> 
                 <section class="" style="margin-top: 15px;max-width: 100%;font-size: 14px;width: 670px;color: rgb(101, 170, 206);text-decoration: underline;text-align: center;line-height: 25px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <p style="max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247483755&amp;idx=2&amp;sn=a162898c963c3475c06165b0bdc0f38b&amp;chksm=eadba8b6ddac21a0c9f0d26dcab47abc7ef2516bf5a349aae6cd7941c479b46e4036ac511557&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank" style="color: rgb(69, 154, 233);outline: 0px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></a></p> 
                  <p style="max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247484578&amp;idx=3&amp;sn=38654576f40c7c086fbe32d2b12c9862&amp;chksm=eadbad7fddac246979cf49802a01c3136b1b0f79e6bfb3e9ace2172cfff4ed63be89f23b0f64&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank" style="color: rgb(0, 128, 255);outline: 0px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">LSTM模型在问答系统中的应用</a></p> 
                  <p style="max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247484570&amp;idx=4&amp;sn=d22e41ff43460c040aae136b78f5c807&amp;chksm=eadbad47ddac2451057b1c6975191f1044988fe9612e1fc248852fe2490052dd791c42770d96&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank" style="color: rgb(0, 128, 255);outline: 0px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">基于TensorFlow的神经网络解决用户流失概览问题</a></p> 
                  <p style="max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247484530&amp;idx=1&amp;sn=462931eb9fd0dd1ac41f2e3f987fa51c&amp;chksm=eadbadafddac24b91389d1bcea23be2668a0efbd425150e836d1ee5ba6d182b0a2f3cf6000dc&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank" style="color: rgb(0, 128, 255);outline: 0px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">最全常见算法工程师面试题目整理（一）</a></p> 
                  <p style="max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247484551&amp;idx=3&amp;sn=a481218ee3f5f4d766a48dca5f8c4c61&amp;chksm=eadbad5addac244c9a9516376add6168ff1a415ba26994ede28c1613dfcc54222959c56a365f&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank" style="color: rgb(0, 128, 255);outline: 0px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">最全常见算法工程师面试题目整理（二）</a></p> 
                  <p style="max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247484516&amp;idx=1&amp;sn=40e8928353dbc29f17c8e22cd27944f4&amp;chksm=eadbadb9ddac24af5943085537922db2f982f088f34ce20262eea314dbf5741dcefbc4a74404&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank" style="color: rgb(0, 128, 255);outline: 0px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">TensorFlow从1到2 | 第三章 深度学习革命的开端：卷积神经网络</a><span style="max-width: 100%;color: rgb(0, 128, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></span></p> 
                  <p style="max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247484476&amp;idx=1&amp;sn=503166979eeff5c974de3e3ce0d4b12e&amp;chksm=eadbade1ddac24f70b22b22cb81a070fdab2e4dafc02c596eb3aa5acba83a9d1051e122258e2&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank" style="color: rgb(0, 128, 255);outline: 0px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">装饰器 | Python高级编程</a><span style="max-width: 100%;color: rgb(0, 128, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></span></p> 
                  <p style="max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTc5NTUwNg==&amp;mid=2247484452&amp;idx=1&amp;sn=c1cf5f55330a5ef89f0bce7faeda4c98&amp;chksm=eadbadf9ddac24ef6e87ee35cc017d42a9ade6e47522b8a041a4b01227161bb17ce6102eafe0&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank" style="color: rgb(0, 128, 255);outline: 0px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">今天不如来复习下Python基础</a></p> 
                 </section> 
                </section> 
               </section> 
              </section> 
             </section> 
            </section> 
           </section> 
          </section> 
         </section> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aef000d09e1fb4b3a6ffbe2843b9563d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">thinkpad开机引导方式变成PCI LAN选项解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/721624710439726f3b72ad7f4d30810a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">判断一个变量是数组还是对象</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>