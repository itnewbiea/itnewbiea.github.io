<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SQL：数据去重的三种方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SQL：数据去重的三种方法" />
<meta property="og:description" content="1、使用distinct去重 distinct用来查询不重复记录的条数，用count(distinct id)来返回不重复字段的条数。用法注意：
distinct【查询字段】，必须放在要查询字段的开头，即放在第一个参数；只能在SELECT 语句中使用，不能在 INSERT, DELETE, UPDATE 中使用；DISTINCT 表示对后面的所有参数的拼接取不重复的记录，即查出的参数拼接每行记录都是唯一的不能与all同时使用，默认情况下，查询时返回的就是所有的结果。 distinct支持单列、多列的去重方式。
作用于单列
单列去重的方式简明易懂，即相同值只保留1个。select distinct name from A //对A表的name去重然后显示 作用于多列
多列的去重则是根据指定的去重的列信息来进行，即只有所有指定的列信息都相同，才会被认为是重复的信息。注意，distinct作用于多列的时候只在开头加上即可，并不用每个字段都加上。distinct必须在开头，在中间是不可以的，会报错，`select id,distinct name from A //错误select distinct id,name from A //对A表的id和name去重然后显示 配合count使用
select count(distinct name) from A //对A表的不同的name进行计数 按顺序去重时，order by 的列必须出现在 distinct 中
出错代码
改正后的代码
讨论：若不使用Distinct关键字，则order by后面的字段不一定要放在seletc中
MySQL中使用去重distinct方法的示例详解
【Hive】数据去重
2、使用group by GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数，形式为select 重复的字段名 from 表名 group by 重复的字段名;
group by 对age查询结果进行了分组，自动将重复的项归结为一组。
还可以使用count函数，统计重复的数据有多少个
3、使用ROW_NUMBER() OVER 或 GROUP BY 和 COLLECT_SET/COLLECT_LIST 说到要去重，自然会想到 DISTINCT，但是在 Hive SQL 里，它有两个问题：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b8f1efec6fc2b176c0a607a5e90bc09e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-12T07:00:00+08:00" />
<meta property="article:modified_time" content="2022-11-12T07:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SQL：数据去重的三种方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1distinct_1"></a>1、使用distinct去重</h2> 
<p>distinct用来查询不重复记录的条数，用<code>count(distinct id)</code>来返回不重复字段的条数。用法注意：</p> 
<ul><li>distinct【查询字段】，必须放在要查询字段的开头，即放在第一个参数；</li><li>只能在SELECT 语句中使用，不能在 INSERT, DELETE, UPDATE 中使用；</li><li>DISTINCT 表示对<code>后面的所有参数的拼接</code>取不重复的记录，即查出的参数拼接每行记录都是唯一的</li><li>不能与all同时使用，默认情况下，查询时返回的就是所有的结果。</li></ul> 
<p>distinct支持单列、多列的去重方式。</p> 
<ul><li> <p>作用于单列</p> 
  <ul><li>单列去重的方式简明易懂，即相同值只保留1个。<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> name <span class="token keyword">from</span> A    <span class="token comment">//对A表的name去重然后显示</span>
</code></pre> </li></ul> </li><li> <p>作用于多列</p> 
  <ul><li>多列的去重则是根据指定的去重的列信息来进行，即只有所有指定的列信息都相同，才会被认为是重复的信息。</li><li>注意，distinct作用于多列的时候只在开头加上即可，并不用每个字段都加上。distinct必须在开头，在中间是不可以的，会报错，`select id,distinct name from A //错误<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> id<span class="token punctuation">,</span>name <span class="token keyword">from</span> A   <span class="token comment">//对A表的id和name去重然后显示</span>
</code></pre> </li></ul> </li><li> <p>配合count使用</p> <pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> name<span class="token punctuation">)</span> <span class="token keyword">from</span> A  <span class="token comment">//对A表的不同的name进行计数</span>
</code></pre> </li><li> <p>按顺序去重时，<code>order by 的列必须出现在 distinct 中</code></p> 
  <ul><li> <p>出错代码<br> <img src="https://images2.imgbox.com/e5/9e/x3ZYc03n_o.png" alt="在这里插入图片描述"></p> </li><li> <p>改正后的代码<br> <img src="https://images2.imgbox.com/62/27/TvVTXeyr_o.png" alt="在这里插入图片描述"></p> </li><li> <p>讨论：若不使用Distinct关键字，则order by后面的字段不一定要放在seletc中<br> <img src="https://images2.imgbox.com/93/22/v9T3Sm2k_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> 
<blockquote> 
 <p><a href="https://www.jb51.net/article/190874.htm" rel="nofollow">MySQL中使用去重distinct方法的示例详解</a><br> <a href="https://www.cnblogs.com/zzhangyuhang/p/8778952.html" rel="nofollow">【Hive】数据去重</a></p> 
</blockquote> 
<hr> 
<h2><a id="2group_by_42"></a>2、使用group by</h2> 
<p>GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数，形式为<code>select 重复的字段名 from 表名 group by 重复的字段名;</code></p> 
<ul><li>group by 对age查询结果进行了分组，自动将重复的项归结为一组。<br> <img src="https://images2.imgbox.com/ac/92/rc6VOYRc_o.png" alt="在这里插入图片描述"></li><li>还可以使用count函数，统计重复的数据有多少个<br> <img src="https://images2.imgbox.com/aa/44/kaRVObyw_o.png" alt="在这里插入图片描述"></li></ul> 
<hr> 
<h2><a id="3ROW_NUMBER_OVER__GROUP_BY__COLLECT_SETCOLLECT_LIST_51"></a>3、使用<code>ROW_NUMBER() OVER</code> 或 <code>GROUP BY 和 COLLECT_SET/COLLECT_LIST</code></h2> 
<p>说到要去重，自然会想到 DISTINCT，但是在 Hive SQL 里，它有两个问题：</p> 
<ul><li>DISTINCT 会以 SELECT 出的全部列作为 key 进行去重。也就是说，只要有一列的数据不同，DISTINCT 就认为是不同数据而保留。</li><li>DISTINCT 会将全部数据打到一个 reducer 上执行，造成严重的数据倾斜，耗时巨大。</li></ul> 
<h3><a id="21_ROW_NUMBER_OVER_56"></a>2.1 ROW_NUMBER() OVER</h3> 
<p>DISTINCT 的两个问题，用 ROW_NUMBER() OVER 可解。比如，如果我们要按 key1 和 key2 两列为 key 去重，就会写出这样的代码：</p> 
<pre><code class="prism language-sql"><span class="token keyword">WITH</span> temp_table <span class="token keyword">AS</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span>
    key1<span class="token punctuation">,</span>
    key2<span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token keyword">columns</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>
    ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span>
      <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> key1<span class="token punctuation">,</span> key2
      <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">column</span> <span class="token keyword">ASC</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> rn
  <span class="token keyword">FROM</span>
    <span class="token keyword">table</span>
<span class="token punctuation">)</span>

<span class="token keyword">SELECT</span>
  key1<span class="token punctuation">,</span>
  key2<span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token keyword">columns</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span>
  temp_table
<span class="token keyword">WHERE</span>
  rn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样，<code>Hive 会按 key1 和 key2 为 key，将数据打到不同的 mapper 上，然后对 key1 和 key2 都相同的一组数据，按 column 升序排列，并最终在每组中保留排列后的第一条数据。借此就完成了按 key1 和 key2 两列为 key 的去重任务</code>。注意 PARTITION BY 在此起到的作用：</p> 
<ul><li>一是按 key1 和 key2 打散数据，解决上述问题 (2)；</li><li>二是与 ORDER BY 和 rn = 1 的条件结合，按 key1 和 key2 对数据进行分组去重，解决上述问题 (1)。</li></ul> 
<p>但显然，这样做十分不优雅（not-elegant），并且不难想见其效率比较低。</p> 
<blockquote> 
 <p>row_number() OVER (PARTITION BY <code>COL1</code> ORDER BY <code>COL2</code>) as num 表示根据 <code>COL1</code>分组，在分组内部根据 <code>COL2</code>排序，此函数计算的值num就表示每组内部排序后的顺序编号（组内连续的唯一的)</p> 
</blockquote> 
<h3><a id="22_GROUP_BY__COLLECT_SETCOLLECT_LIST_90"></a>2.2 GROUP BY 和 COLLECT_SET/COLLECT_LIST</h3> 
<p>ROW_NUMBER() OVER 解法的一个核心是利用 PARTITION BY 对数据按 key 分组，同样的功能用 GROUP BY 也可以实现。但是，GROUP BY 需要与聚合函数搭配使用。我们需要考虑，什么样的聚合函数能实现或者间接实现这样的功能呢？不难想到有 COLLECT_SET 和 COLLECT_LIST。</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span>
  key1<span class="token punctuation">,</span>
  key2<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>COLLECT_LIST<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token keyword">column</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span>
  temp_table
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>
  key1<span class="token punctuation">,</span> key2
</code></pre> 
<p><code>对于 key1 和 key2 以外的列，我们用 COLLECT_LIST 将他们收集起来，然后输出第一个收集进来的结果</code>。这里使用 COLLECT_LIST 而非 COLLECT_SET 的原因在于 SET 内是无序的，因此你无法保证输出的 columns 都来自同一条数据。若对于此没有要求或限制，则可以使用 COLLECT_SET，它会更节省资源。</p> 
<p>相比前一种办法，由于省略了排序和（可能的）落盘动作，所以效率会高不少。但是因为（可能）不落盘，所以 COLLECT_LIST 中的数据都会缓存在内存当中。如果重复数量特别大，这种方法可能会触发 OOM。此时应考虑将数据进一步打散，然后再合并；或者干脆换用前一种办法。</p> 
<blockquote> 
 <p><a href="https://liam.page/2020/05/14/remove-duplicate-entries-in-Hive-SQL/" rel="nofollow">删除 Hive SQL 查询结果中的重复内容</a></p> 
</blockquote> 
<hr> 
<p><a href="https://blog.csdn.net/qq_32393893/article/details/126850270">数据库之MySQL查询去重数据</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b90b3380d69d8e4008bf904f68732b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysqli_real_connect(): (HY000/1045): Access denied for user ‘root‘@‘localhost‘ (using password: YES</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f98c4f87c786e59074dcca8cb855ce4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL进阶-单列索引与联合索引</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>