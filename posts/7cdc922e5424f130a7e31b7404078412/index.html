<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GAMES101：作业4记录 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GAMES101：作业4记录" />
<meta property="og:description" content="文章目录 总览算法编写代码：recursive_bezier()的实现Bezier()函数的实现提高部分：反走样 总览 Bézier 曲线是一种用于计算机图形学的参数曲线。在本次作业中,你需要实现 de Casteljau 算法来绘制由 4 个控制点表示的 Bézier 曲线 (当你正确实现该算法时,你可以支持绘制由更多点来控制的 Bézier 曲线)。
你需要修改的函数在提供的 main.cpp 文件中。
• bezier:该函数实现绘制 Bézier 曲线的功能。它使用一个控制点序列和一个OpenCV::Mat 对象作为输入,没有返回值。它会使 t 在 0 到 1 的范围内进行迭代,并在每次迭代中使 t 增加一个微小值。对于每个需要计算的 t,将调用另一个函数 recursive_bezier,然后该函数将返回在 Bézier 曲线上 t处的点。最后,将返回的点绘制在 OpenCV ::Mat 对象上。
• recursive_bezier:该函数使用一个控制点序列和一个浮点数 t 作为输入,实现 de Casteljau 算法来返回 Bézier 曲线上对应点的坐标。
算法 De Casteljau 算法说明如下：
考虑一个 p0, p1, … pn 为控制点序列的 Bézier 曲线。首先，将相邻的点连接起来以形成线段。用 t : (1 − t) 的比例细分每个线段，并找到该分割点。得到的分割点作为新的控制点序列，新序列的长度会减少一。如果序列只包含一个点，则返回该点并终止。否则，使用新的控制点序列并转到步骤 1。 使用[0,1] 中的多个不同的 t 来执行上述算法，你就能得到相应的 Bézier 曲线。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7cdc922e5424f130a7e31b7404078412/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-31T16:45:10+08:00" />
<meta property="article:modified_time" content="2023-12-31T16:45:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GAMES101：作业4记录</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">总览</a></li><li><a href="#_13" rel="nofollow">算法</a></li><li><a href="#_24" rel="nofollow">编写代码：</a></li><li><ul><li><a href="#recursive_bezier_38" rel="nofollow">recursive_bezier()的实现</a></li><li><a href="#Bezier_66" rel="nofollow">Bezier()函数的实现</a></li><li><a href="#_99" rel="nofollow">提高部分：反走样</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>总览</h2> 
<p>Bézier 曲线是一种用于计算机图形学的参数曲线。在本次作业中,你需要实现 <strong>de Casteljau</strong> 算法来绘制由 4 个控制点表示的 Bézier 曲线 (当你正确实现该算法时,你可以支持绘制由更多点来控制的 Bézier 曲线)。</p> 
<p>你需要修改的函数在提供的 main.cpp 文件中。</p> 
<p>• <code>bezier</code>:该函数实现绘制 Bézier 曲线的功能。它使用一个控制点序列和一个<code>OpenCV::Mat</code> 对象作为输入,没有返回值。它会使 t 在 0 到 1 的范围内进行迭代,并在每次迭代中使 t 增加一个微小值。对于每个需要计算的 t,将调用另一个函数 <code>recursive_bezier</code>,然后该函数将返回在 Bézier 曲线上 t处的点。最后,将返回的点绘制在 OpenCV ::Mat 对象上。</p> 
<p>• <code>recursive_bezier</code>:该函数使用一个控制点序列和一个浮点数 t 作为输入,实现 <strong>de Casteljau</strong> 算法来返回 Bézier 曲线上对应点的坐标。</p> 
<h2><a id="_13"></a>算法</h2> 
<p><strong>De Casteljau</strong> 算法说明如下：</p> 
<ol><li>考虑一个 p0, p1, … pn 为控制点序列的 Bézier 曲线。首先，将相邻的点连接起来以形成线段。</li><li>用 t : (1 − t) 的比例细分每个线段，并找到该分割点。</li><li>得到的分割点作为新的控制点序列，新序列的长度会减少一。</li><li>如果序列只包含一个点，则返回该点并终止。否则，使用新的控制点序列并转到步骤 1。</li></ol> 
<p>使用[0,1] 中的多个不同的 t 来执行上述算法，你就能得到相应的 Bézier 曲线。</p> 
<h2><a id="_24"></a>编写代码：</h2> 
<p>我们先把源代码的naive_bezier画Bezier曲线的程序跑通</p> 
<pre><code class="prism language-cpp">mkdir build
cd build
cmake <span class="token punctuation">.</span><span class="token punctuation">.</span>
make
<span class="token punctuation">.</span><span class="token operator">/</span>BezierCurve
</code></pre> 
<p><img src="https://images2.imgbox.com/78/f1/6N7Yltrt_o.png" alt="在这里插入图片描述"><br> 然后我们注释掉main函数里的<code>naive_bezier(control_points, window);</code>，实现自己的Bezier曲线绘制。</p> 
<h3><a id="recursive_bezier_38"></a>recursive_bezier()的实现</h3> 
<p>我们在<code>recursive_bezier()</code>函数中获得根据t获得贝塞尔曲线的点，这里不同于直接使用多项式（naive_bezier使用的是多项式的方法），使用递归算法，递归的返回条件是最终递归数组的长度为1（下图对应的是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          b 
         
        
          0 
         
        
          3 
         
        
       
      
        \mathbf{b}_0^3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0622em; vertical-align: -0.2481em;"></span><span class="mord"><span class="mord mathbf">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.4519em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2481em;"><span class=""></span></span></span></span></span></span></span></span></span></span>），这时候返回结果。如果没有达到返回条件，就进入下一次递归，传进递归计算后的数组（数组的长度减1）：<br> <img src="https://images2.imgbox.com/bc/34/Ln24VHc9_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c">cv<span class="token operator">::</span>Point2f <span class="token function">recursive_bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>cv<span class="token operator">::</span>Point2f<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> <span class="token keyword">float</span> t<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// TODO: Implement de Casteljau's algorithm</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> control_points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> control_points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>cv<span class="token operator">::</span>Point2f<span class="token operator">&gt;</span> <span class="token function">lerp_control_points</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> cv<span class="token operator">::</span><span class="token function">Point2f</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        lerp_control_points<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t <span class="token operator">*</span> control_points<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> control_points<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>lerp_control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Bezier_66"></a>Bezier()函数的实现</h3> 
<p>我们在<code>bezier()</code>函数里从0到1遍历所有的t，然后使用前面写的<code>recursive_bezier()</code>获得Bezier曲线点的坐标，然后在图上该点的位置涂上颜色即可。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span>Mat <span class="token operator">&amp;</span>window<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's </span>
    <span class="token comment">// recursive Bezier algorithm.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> t <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> t <span class="token operator">+=</span> <span class="token number">0.001</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">auto</span> point <span class="token operator">=</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token punctuation">;</span>

        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y<span class="token punctuation">,</span> point<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span> <span class="token comment">//显示是绿色       </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>绿色的曲线通过同样的make命令可以得到：</p> 
<p><img src="https://images2.imgbox.com/8d/b7/sSOjqi6p_o.png" alt="在这里插入图片描述"></p> 
<p>把<code>naive_bezier(control_points, window);</code>取消注释可以看到黄色的Bezier曲线</p> 
<p><img src="https://images2.imgbox.com/03/36/TXz2rep3_o.png" alt="在这里插入图片描述"></p> 
<p>但可以看到锯齿比较明显</p> 
<p><img src="https://images2.imgbox.com/b7/9a/CnvvhcQy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_99"></a>提高部分：反走样</h3> 
<p>提高部分要求使用反走样，题目提示说：</p> 
<blockquote> 
 <p>对于一个曲线上的点,不只把它对应于一个像素,你需要根据到像素中心的距离来考虑与它相邻的像素的颜色。</p> 
</blockquote> 
<p>也就是说离像素越近颜色越深，离像素越远颜色越浅。</p> 
<p>这里参考的是<a href="https://games-cn.org/forums/topic/%E4%BD%9C%E4%B8%9A%E5%9B%9B%E5%BE%97%E5%88%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E8%A6%81%E6%B1%82%EF%BC%9F/" rel="nofollow">作业四得到这样的结果是否满足要求？</a>里xuyonglai的思路，我们首先要找到和Bezier曲线点(point.x,point,y)最临近的四个像素，曲线点所在的像素很好找，其他三个像素该怎么找呢？这里类似采用四舍五入的方法，判断(point.x,point,y)靠近它所在像素的哪一侧，以此来确定其他三个像素的方向，然后我们就可以确定四个像素的坐标了，其中代码中的p0是最临近的像素，其他的p1,p2,p3依次是其他三个像素。然后定义一个pvec存放这三个临近的像素，依次给这其他三个近邻像素着色，这里取了最大值是因为如果这次计算的像素的颜色是偏暗的绿色，但是这个像素上次有重复计算（靠近曲线绿色的比重更大），替换为暗色可能会让反走样的效果变差。这种方法也有一定的缺点，就是只能对黑色的背景（RGB三个分量都是0）起作用，但是其他背景颜色直接取max最大值就不太行了。</p> 
<p><img src="https://images2.imgbox.com/d3/45/Ro5VTDGD_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span>Mat <span class="token operator">&amp;</span>window<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's </span>
    <span class="token comment">// recursive Bezier algorithm.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> t <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> t <span class="token operator">+=</span> <span class="token number">0.001</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">auto</span> point <span class="token operator">=</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token punctuation">;</span>

        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y<span class="token punctuation">,</span> point<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span> <span class="token comment">//显示是绿色</span>

        <span class="token keyword">float</span> xDelta <span class="token operator">=</span> point<span class="token punctuation">.</span>x <span class="token operator">-</span> std<span class="token double-colon punctuation">::</span> <span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> yDelta <span class="token operator">=</span> point<span class="token punctuation">.</span>y <span class="token operator">-</span> std<span class="token double-colon punctuation">::</span> <span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> xDir <span class="token operator">=</span> xDelta <span class="token operator">&lt;</span> <span class="token number">0.5f</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> yDir <span class="token operator">=</span> yDelta <span class="token operator">&lt;</span> <span class="token number">0.5f</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>

        cv<span class="token double-colon punctuation">::</span>Point2f p0 <span class="token operator">=</span> cv<span class="token double-colon punctuation">::</span><span class="token function">Point2f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cv<span class="token double-colon punctuation">::</span>Point2f p1 <span class="token operator">=</span> cv<span class="token double-colon punctuation">::</span><span class="token function">Point2f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>x <span class="token operator">+</span> xDir <span class="token operator">*</span> <span class="token number">1.0f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cv<span class="token double-colon punctuation">::</span>Point2f p2 <span class="token operator">=</span> cv<span class="token double-colon punctuation">::</span><span class="token function">Point2f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y <span class="token operator">+</span> yDir <span class="token operator">*</span> <span class="token number">1.0f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cv<span class="token double-colon punctuation">::</span>Point2f p3 <span class="token operator">=</span> cv<span class="token double-colon punctuation">::</span><span class="token function">Point2f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>x <span class="token operator">+</span> xDir <span class="token operator">*</span> <span class="token number">1.0f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y <span class="token operator">+</span> yDir <span class="token operator">*</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">&gt;</span> pvec<span class="token punctuation">;</span>
        pvec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pvec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pvec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">float</span> d1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span>p0<span class="token punctuation">.</span>x <span class="token operator">-</span> point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span>p0<span class="token punctuation">.</span>y <span class="token operator">-</span> point<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> p<span class="token operator">:</span> pvec<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">float</span> dp <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>x <span class="token operator">-</span> point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>y <span class="token operator">-</span> point<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> weight <span class="token operator">=</span> d1 <span class="token operator">/</span> dp<span class="token punctuation">;</span>
            <span class="token keyword">float</span> colorG <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>y<span class="token punctuation">,</span> p<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            colorG <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">fmax</span><span class="token punctuation">(</span>colorG<span class="token punctuation">,</span> weight <span class="token operator">*</span> <span class="token number">255.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>y<span class="token punctuation">,</span> p<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>colorG<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b2/70/8tRq9Elc_o.png" alt="在这里插入图片描述"><br> 可以看到反走样有了较好的效果。</p> 
<p>其他反走样的方法也可以看这篇文章：<a href="https://zhuanlan.zhihu.com/p/464122963?utm_id=0" rel="nofollow">Games 101 | 作业4 + Bezier Curve + 反走样 + 双线性插值</a>，距离和颜色的值（RGB分量的值越接近1越饱和）成反比，所以用最大距离减去像素中心和曲线点的距离也可以构造反比的函数，权重需要在0到1之间，还是一样我们使用所有的最大距离减像素中心和曲线点的距离的值的和作为分母，使用大距离减去特定像素中心和曲线点的距离作为分子计算特定像素的权重，这里就不写代码了，思路是差不多的。</p> 
<p>其他参考：</p> 
<p><a href="https://zingl.github.io/bresenham.html" rel="nofollow">The Beauty of Bresenham’s Algorithm</a>【介绍了Bresenham’s 算法来实现反走样】<br> <a href="https://zingl.github.io/Bresenham.pdf" rel="nofollow">A Rasterizing Algorithm for Drawing Curves</a>【上面网站的pdf的说明】</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc89d556c11309b12dc0792e3f0ab3e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Visual Studio 2015 中 OpenGL 开发环境的搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e1b4e646b8f27684f47de1514009448b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python观察图像的幅度谱和相位谱——冈萨雷斯数字图像处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>