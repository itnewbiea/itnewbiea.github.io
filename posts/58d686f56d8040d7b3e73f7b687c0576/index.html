<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>web集群--lvs负载均衡 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="web集群--lvs负载均衡" />
<meta property="og:description" content="1. 对比 LVS 负载均衡群集的 NAT 模式和 DR 模式，比较其各自的优势 LVS-DR是client向目标lvs发出请求，lvs接收用户的请求，然后根据负载均衡算法选取一台
realserver，将包转发过去，最后由realserver直接回复给用户。realserver必须拥有lvs的ip，因为
数据包发给lvs后，并未处理而是直接转发给realserver，目标ip必须是realserver拥有的ip才会去处
理数据包。处理完后，源ip封装lvs的ip，目标ip是client的ip，直接发给客户端，而不经过lvs。
优势：从real-server直接到客户端，不需要经过负载调度器。
LVS-NAT是client发送请求到lvs上，lvs选择一个realserver,然后修改client的请求的目的IP地址为
realserver的地址，将请求发给realserver，realserver收到request包后，发现目的IP是自己的IP，
于是处理请求，然后发送reply给lvs，lvs收到reply包后，修改reply包的的源地址为lvsip，发送给
client。
优势：不需要要arp抑制
2. 基于 CentOS 7 构建 LVS-DR 群集 1&gt; 配置两台real-server
node1主机上操作： yum install -y httpd echo &#34;the web hostname ip is `hostname -I`.&#34; &gt; /var/www/html/index.html systemctl disable firewalld.service setenforce 0 systemctl start httpd curl 192.168.139.135:80 node2主机上操作： yum install -y httpd echo &#34;the web hostname ip is `hostname -I`.&#34; &gt; /var/www/html/index.html systemctl disable firewalld." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/58d686f56d8040d7b3e73f7b687c0576/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-12T21:01:34+08:00" />
<meta property="article:modified_time" content="2023-05-12T21:01:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">web集群--lvs负载均衡</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1. 对比 LVS 负载均衡群集的 NAT 模式和 DR 模式，比较其各自的优势</h4> 
<p><strong>LVS-DR</strong>是client向目标lvs发出请求，lvs接收用户的请求，然后根据负载均衡算法选取一台</p> 
<p>realserver，将包转发过去，最后由realserver直接回复给用户。realserver必须拥有lvs的ip，因为</p> 
<p>数据包发给lvs后，并未处理而是直接转发给realserver，目标ip必须是realserver拥有的ip才会去处</p> 
<p>理数据包。处理完后，源ip封装lvs的ip，目标ip是client的ip，直接发给客户端，而不经过lvs。</p> 
<p><strong>优势</strong>：从real-server直接到客户端，不需要经过负载调度器。</p> 
<p><strong> LVS-NAT</strong>是client发送请求到lvs上，lvs选择一个realserver,然后修改client的请求的目的IP地址为</p> 
<p>realserver的地址，将请求发给realserver，realserver收到request包后，发现目的IP是自己的IP，</p> 
<p>于是处理请求，然后发送reply给lvs，lvs收到reply包后，修改reply包的的源地址为lvsip，发送给</p> 
<p>client。</p> 
<p><strong>优势</strong>：不需要要arp抑制</p> 
<h4>2. 基于 CentOS 7 构建 LVS-DR 群集</h4> 
<p>1&gt; 配置两台real-server</p> 
<pre><code class="hljs">node1主机上操作：
yum install -y httpd
echo "the web hostname ip is `hostname -I`." &gt; /var/www/html/index.html
systemctl disable firewalld.service 
setenforce 0
systemctl start httpd
curl 192.168.139.135:80
node2主机上操作：
yum install -y httpd
echo "the web hostname ip is `hostname -I`." &gt; /var/www/html/index.html
systemctl disable firewalld.service 
setenforce 0
systemctl start httpd
curl 192.168.139.136:80</code></pre> 
<p>2&gt; 在LVS（进行负载均衡主机上安装ipvsadm）</p> 
<pre><code class="hljs">1.[root@manage ~]# yum install -y ipvsadm
如果想使用域名进行访问的话
配置LVS负载均衡服务
（1）手动添加LVS转发
1）用户访问：www.uolookking.com--&gt;vip 192.168.79.110 ##==&gt;这个是在DNS配置hzitedu域的DNS记录设置
www IN A 192.168.79.110
没有配置DNS可以使用hosts文件配置方式来实现域名解析。192.168.79.110 www.hzitedu.com</code></pre> 
<p> 3&gt; 在LVS上增加一个VIP地址</p> 
<pre><code class="hljs">[root@manager ~]# nmcli connection modify ens33 +ipv4.addresses 192.168.139.134/24
[root@nmanager ~]# nmcli connection up ens33
在客户端进行测试：
看是否可以ping通VIP</code></pre> 
<p>4&gt; 手工配置LVS服务（在LVS服务上）</p> 
<pre><code class="hljs">1.配置前需要清空lvs列表
[root@manager ~]# ipvsadm -C
2.查看lvs的配置
[root@manager ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
3.添加虚拟VIP地址
[root@manager ~]# ipvsadm -A -t 192.168.139.134:80 -s rr
-A：增加虚拟服务
-t：指定虚拟vip地址：端口
-s：指定lvs是什么算法
rr：轮询算法
wrr：加权算法
4.添加真实服务器ipvs
[root@manager ~]# ipvsadm -a -t 192.168.139.134:80(vip) -r 192.168.139.135:80(真实服务器ip) -g 
[root@manager ~]# ipvsadm -a -t 192.168.139.134:80(vip) -r 192.168.139.136:80(真实服务器ip) -g 
-a：添加真实服务器
-t：指定虚拟vip
-r：指定真实服务器ip地址
-g：lvs的模式，-g:DR模式  -i：TUN模式  -m：NAT模式
-w：指定权重（-w 2）
5.查看是否配置上了两台real-server
[root@manager ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.139.134:80 rr
  -&gt; 192.168.139.135:80            Route   1      0          0         
  -&gt; 192.168.139.136:80            Route   1      0          0     </code></pre> 
<p> 5&gt; 在real-server上进行配置（绑定VIP）</p> 
<p>在real-server上绑定VIP要求在lo接口绑定，nmcli实现不了，需要使用ifconfig进行绑定</p> 
<pre><code class="hljs">1.绑定vip的lo接口（所有的real-server都需要操作）
[root@node1 ~]# ifconfig lo:127 192.168.139.134(虚拟VIP的ip地址) netmask 255.255.255.255 up
[root@node2 ~]# ifconfig lo:127 192.168.139.134 netmask 255.255.255.255 up
2.添加本机访问VIP的路由
[root@node1 ~]# route add -host 192.168.139.134 dev lo
[root@node2 ~]# route add -host 192.168.139.134 dev lo</code></pre> 
<p> 6&gt; 做ARP抑制</p> 
<p>6.1&gt; 使用修改内核参数抑制ARP</p> 
<pre><code class="hljs">所有的real-server都需要修改
[root@node1 ~]# echo "1" &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
[root@node1 ~]# echo "2" &gt; /proc/sys/net/ipv4/conf/lo/arp_announce
[root@node1 ~]# echo "1" &gt; /proc/sys/net/ipv4/conf/ens33/arp_ignore
[root@node1 ~]# echo "2" &gt; /proc/sys/net/ipv4/conf/ens33/arp_announce^C
[root@node2 ~]# echo "1" &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
[root@node2 ~]# echo "2" &gt; /proc/sys/net/ipv4/conf/lo/arp_announce
[root@node2 ~]# echo "1" &gt; /proc/sys/net/ipv4/conf/ens33/arp_ignore
[root@node2 ~]# echo "2" &gt; /proc/sys/net/ipv4/conf/ens33/arp_announce^C
​
永久修改内核参数：
net.ipv4.lo.arp_ignore=1 写入到/etc/sysctl.conf 文件中</code></pre> 
<p>6.2&gt; 使用arptables实现抑制ARP</p> 
<pre><code class="hljs">1.安装arptables工具
yum install -y arptables
2.清空之前配的arptables
[root@node3 ~]# arptables -F
3.配置arptables
[root@node2 ~]# arptables -A INPUT -d 192.168.139.134 -j DROP
-A：增加链
-d：指定为目的地址
-j：指定是什么动作。允许还是删除
[root@node2 ~]# arptables -A OUTPUT -s 192.168.139.134 -j mangle --mangle-ip-s 
                                           vip地址
192.168.139.134 (当前主机地址ip)
-s：指定源地址
​
arptables -A INPUT -d $VIP -j DROP
arptables -A OUTPUT -s $VIP -j mangle --mangle-ip-s $RIP
​
4.查看arptables规则
[root@node2 ~]# arptables -L -n
Chain INPUT (policy ACCEPT)
-j DROP -d 192.168.139.134 
​
Chain OUTPUT (policy ACCEPT)
-j mangle -s 192.168.139.134 --mangle-ip-s 192.168.139.136 
​
Chain FORWARD (policy ACCEPT)
5.保存配置的arptables规则
arptables-save &gt; /etc/sysconfig/arptables</code></pre> 
<p>7&gt; 测试</p> 
<pre><code class="hljs">watch ipvsadm -Ln   实时监控客户端测试情况
客户端：
[root@node3 ~]# for ((i=1;i&lt;8;i++)); do curl 192.168.27.127; done
the web hoatname ip is 192.168.139.136 . 
the web hostname ip is 192.168.139.135 .
the web hoatname ip is 192.168.139.136 . 
the web hostname ip is 192.168.139.135 .
the web hoatname ip is 192.168.139.136 . 
the web hostname ip is 192.168.139.135 .
the web hoatname ip is 192.168.139.136 . 
lvs：
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.139.134:80 rr
  -&gt; 192.168.139.135:80            Route   1  0          3
  -&gt; 192.168.139.136:80            Route   1  0          4</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/732db754b5a882769251606a55a94f17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js常用密码正则校检</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6eebf4a2cf3dd9758c190ae68e07e5d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">apisdk-starter自动装配的思路与应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>