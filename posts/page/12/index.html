<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1c389382598c602423975823e2bd9d4/" rel="bookmark">
			Mybatis-Plus乐观锁配置使用流程【OptimisticLockerInnerInterceptor】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家:人工智能学习网站
1.乐观锁实现 1.配置插件 1.XML方式 &lt;bean class="com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor" id="optimisticLockerInnerInterceptor"/&gt; &lt;bean id="mybatisPlusInterceptor" class="com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor"&gt; &lt;property name="interceptors"&gt; &lt;list&gt; &lt;ref bean="optimisticLockerInnerInterceptor"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 2.Springboot注解方式 下方为博主使用时场景 单独写config带@Bean注解
private MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor mpi = new MybatisPlusInterceptor(); //添加乐观锁拦截器 mpi.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mpi; } 单独写config文件如下：
// Spring Boot 方式 @Configuration @MapperScan("按需修改") public class MybatisPlusConfig { /** * 旧版 */ @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() { return new OptimisticLockerInterceptor(); } /** * 新版 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1c389382598c602423975823e2bd9d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73ea4d76abef64d09f42c4af0f67190/" rel="bookmark">
			大模型应用实践：AIGC探索之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着OpenAI推出ChatGPT，AIGC迎来了前所未有的发展机遇。大模型技术已经不仅仅是技术趋势，而是深刻地塑造着我们交流、工作和思考的方式。本文介绍了笔者理解的大模型和AIGC的密切联系，从历史沿革到实际应用案例，再到面临的技术挑战和伦理监管问题，探讨这一技术浪潮如何引领我们进入一个智能化的未来。
前言
▐ 引言：AI时代，未来已来 2022.11月30号OpenAI推出ChatGPT后随即爆火，五天注册用户数过百万，2个月用户破1亿，成为史上增长最快的消费者应用。随后各大厂也纷纷卷入AIGC领域，迎来国产GPT大模型发布潮（百度"文新一言"、阿里"通义千问"、商汤"商量 SenseChat"等）及AI创业公司成立潮（王小川、李开复等）。
大模型代表一个新的技术AI时代的来临，大模型展现出的强大的语义理解，内容生成以及泛化能力正在逐渐改变我们的工作与生活方式（AI+）、工作方式和思维方式。正如《陆奇的大模型观》所讲当前我们正迎来新范式的新拐点，从信息系统到模型系统过渡，"模型"知识无处不在。人工智能的浪潮正在引领新的技术革命，或许可称为第五次工业革命。
（【注】推荐大家去阅读《陆奇的大模型观》。强烈建议直接看陆奇演讲视频 奇绩创坛| 陆奇最新演讲完整视频｜大模型带来的新范式：演讲涵盖陆奇对大模型时代的宏观思考，包括拐点的内在动因、技术演进、创业公司结构性机会点以及给创业者的建议。）
在人工智能的新时代，大模型技术正成为推动AIGC（人工智能生成内容）前沿的关键力量。本文将通过介绍我们的AIGC项目，来深入探讨这一技术的开发、实施与应用。因个人能力限制，文章中可能存在一些理解或表述错误的地方，希望各位大佬能及时批评和指正。
▐ AIGC简介与发展历程 在与业务等交谈过程中，经常会听大家提到AIGC、ChatGPT、大模型、XX等许多概念，但也发现部分内容混淆。首先来解决下当下最火概念AIGC、ChatGPT、大模型到底是什么？
ChatGPT "Chat Generative Pre-trained Transformer”的缩写，ChatGPT是一种基于人工智能技术的聊天机器人，能用于问答、文本摘要生成、机器翻译、分类、代码生成和对话AI，是一款由OpenAI开发的基于Transformer架构的的自然语言处理工具。
AIGC，全名“AI generated content”，又称生成式AI，意为人工智能生成内容。狭义概念是利用AI自动生成内容的生产方式（UGC-&gt;PGC-&gt;AIGC）；广义的AIGC可以看作像人类一样具备生成创造能力的AI技术，包括但不限于文本生成、音频生成、图像生成、视频生成及图像、视频、文本间的跨模态生成等等。
大模型：大模型通常是指参数量非常大的深度学习模型，如Transformer架构的GPT-3、BERT、T5等模型。这些模型通过在海量数据上进行训练，能够学习到丰富的语言和知识表示，并展现出强大的自然语言处理能力。
AIGC是一个更广泛的概念，包括多种类型的内容生成；ChatGPT则是一个具体的产品。简单可以这么理解：AIGC是平台，ChatGPT是平台上的某个软件。
结合人工智能的演进历程，AIGC发展大致分三个阶段[人工智能行业生成内容（AIGC）白皮书（2022年）（地址：https://www.vzkoo.com/document/20220907cc987d2511ffc7c895ed6dd4.html?spm=ata.21736010.0.0.56075d51YB56mA）]：
早期萌芽阶段（1950s－1990s） 早期萌芽阶段（1950s－1990s），受限于当时的科技水平，AIGC仅限于小范围实验。
1957 年，莱杰伦·希勒和伦纳德·艾萨克森完成历史第一支由计算机创作的弦乐四重奏《伊利亚克组曲》。
1966年，约瑟夫·魏岑鲍姆和肯尼斯·科尔比开发了世界第一款可人机对话的机器人Eliza。
80年代中期，IBM基于(Hidden Markov Model，HMM)创造了语音控制打字机Tangora。
80年度末-90年度中，由于高昂系统成本无法带来可观的商业化变现，AIGC未取得重大突破。
沉淀积累阶段（1990s－2010s） 沉淀积累阶段（1990s－2010s），AIGC从实验性向实用性逐渐转变。
2006年，深度学习算法取得重大突破，及图形处理器(GPU)、张量处理器(TPU)等算力设备性能不断提升，互联网规模膨胀提供海量训练数据，但AIGC仍受限算法效率，应用及效果有待提升。
2007年，世界第一部完全由人工智能创作的小说《1 The Road》问世，虽其可读性不强，但象征意义远大于实际意义。
2012年，微软公开展示了一个全自动同声传译系统，基于深层神经网络(Deep Neural Network,DNN)可以自动将英文演讲者的内容通过语音识别、语言翻译、语音合成等技术生成中文语音。
快速发展阶段（2010s至今）
快速发展阶段（2010s至今），深度学习模型不断迭代，AIGC突破性发展。
2014年，随着以生成式对抗网络(Generative Adversarial Network,GAN)为代表深度学习算法的提出和迭代更新，AIGC迎来了新时代，生成内容百花齐放，效果逐渐逼真直至人类难以分辨。
2017年，微软人工智能少女“小冰”推出了世界首部100%由人工智能创作的诗集《阳光失了玻璃窗》。
2018年英伟达发布了StyleGAN模型可以自动生成图片，目前已经发展到了第四代模型StyleGAN-XL，其生成的高分辨率图片让人难以分辨真假。
2019 年，DeepMind 发布了 DVD-GAN 模型用以生成连续视频，在草地、广场等明确场景下表现突出。
2021 年，OpenAI 推出了 DALL-E 并于一年后推出了升级版本 DALL-E-2，主要应用于文本与图像的交互生成内容，用户只需输入简短的描述性文字，DALL-E-2 即可创作 出相应极高质量的卡通、写实、抽象等风格的绘画作品。
2022年，12月OpenAI的ChatGPT在推出，两个月后用户数量就突破1亿了。在文本生成、代码生成与修改、多轮对话等领域，已经展现了大幅超越过去AI 问答系统的能力。
随后各大厂也纷纷卷入AIGC领域（百度“文新一言”、阿里“通义千问”、商汤“商量”SenseChat等），涌现运用AI于写作、编曲、绘画和视频制作等创意领域。目前 AIGC 技术可以自动生成文字、图片、音频、视频，甚至 3D模型和代码，在搜索引擎、艺术创作、影音游戏，以及金融、教育、医疗、工业等领域的应用前景十分广阔。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73ea4d76abef64d09f42c4af0f67190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a19040e465fa514ceaaa9c83e3f4c8/" rel="bookmark">
			Java项目:餐厅点餐系统(java&#43;SpringBoot&#43;HTML&#43;layui&#43;Echarts&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码获取：俺的博客首页 "资源" 里下载！ 项目介绍
Springboot餐厅点餐系统分为前后台，前台顾客可以进行点餐，后台可以由经理、收银员、厨师、服务员等角色登录；
前台主要功能如下：
桌位选择、菜品选择、提交菜单等功能；
后台主要功能如下：
主页控制台
员工列表：员工查询、新增、编辑、删除；
会员管理：会员列表、会员类型列表；
菜谱管理：菜品列表、种类列表；
订单管理：订单列表；
销售管理：销售统计、销量统计、交易记录；
制菜上菜管理：制菜任务列表、上菜任务列表、桌位上菜情况列表；
桌位管理：桌位列表；
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
4.数据库：MySql 5.7/8.0版本均可；
5.是否Maven项目：是；
技术栈
后端：SpringBoot+Mybaits
前端：HTML+css+js+layui+Echarts
使用说明
项目运行：
1. 使用Navicat或者其它工具，在mysql中创建对应sql文件名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，导入成功后请执行maven clean;maven install命令，然后运行；
3. 将项目中application.yml配置文件中的数据库配置改为自己的配置;
4. 控制台提示运行成功后再运行前端项目；
5. 运行项目,在浏览器中输入地址
后台登录地址：http://localhost:8181/restaurant/sysuser/login.html 前台点餐登录地址：http://localhost:8181/restaurant/guest/desklist.html 经理测试号 账号 18384623911 密码123456 收银员测试号 账号 18384623912 密码 123456 厨师测试号 账号 18384623913 密码 123456 服务员 账号 18384623914 密码 123456 注意事项:
为防止项目运行后图片找不到，请将“images”文件夹中的“restaurant”文件夹放到D盘根目录。如果想放到其他盘，请修改application.yml配置文件中对应路径 角色介绍： 功能介绍： 前后台展示图例： 订桌页面： 菜品管理： 点餐管理： 提交菜单列表： 后台统计展示： 后台销售统计展示： 后台登陆管理控制层： /** * 后台登陆 */ @Controller @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a19040e465fa514ceaaa9c83e3f4c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4652b316826ea2b7b2f31bf7be0f3b1/" rel="bookmark">
			多继承与虚继承内存布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class a {int data_a;}; class va : virtual public a {int data_va;}; class va2 : virtual public a {int data_va2;}; class b : public a {int data_b;}; class b2 : public a{int data_b2;}; class child : virtual public va, virtual public b, public va2, public b2 {int data_child;}; 内存布局：
１、布局中先实继承类，再子类成员，再虚继承类
２、虚继承的类只实例化一个内存
３、实继承的类，分别实例化一个内存
４、虚继承的类会深度遍历添加虚爷类的内存，且只添加一次，后面用到这个虚爷类时可直接复用
５、子类的虚表与第一个实基类合并，如果没有实基类，则加一个子类的虚表
６、实例化顺序与内存布局不同，是按写的顺序来的，本例中顺序为：va::a() -&gt; va() -&gt; b()::a() -&gt; b() -&gt; va2() -&gt; b2::a() -&gt; b2() 其中va2的构造不需要再调一次a的构造，因为虚类只有一个。
/** 实继承虚基类 */ *vtbl_va2 data_va2 // 这里没有va２::a 的　data_a　因为是虚继承的a类 // 虚类a只有一个，它会在深度遍历virtual继承类va时添加在va后面。 /** 实继承实基类 */ *vtbl_b2　b2::a::data_a // b2实继承的a，所以先有a的成员再有b2的成员 data_b2 // 子类成员 data_child /** 虚继承虚基类 */ *vtbl_va data_va // 虚继承深度遍历找到虚基基类a，放在这后面 *vtbl_a data_a /** 虚继承实基类 */ *vtbl_b b::a::data_a data_b 虚表的特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4652b316826ea2b7b2f31bf7be0f3b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cff4d5ca5d80f0e8efb012fef9cb4a/" rel="bookmark">
			卡巴斯基曝光苹果处理器“神秘后门”，复杂程度堪称史诗级！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个未记录的硬件特性之所以包含在最终供消费者使用的iPhone版本中，可能是出于错误，或者是为了方便苹果工程师进行调试和测试。
近日，卡巴斯基安全研究人员Boris Larin披露了iPhone历史上最复杂的间谍软件攻击——三角测量（Triangulation）的技术细节。
自2019年以来，“三角定位行动”（Operation Triangulation）间谍软件持续对iPhone设备进行攻击。该软件利用苹果芯片中未记录的特性绕过基于硬件的安全保护措施。
卡巴斯基分析师在2023年6月首次发现了上述攻击活动。随后，他们对这条复杂的攻击链进行了逆向工程。他们发现了一些预留用于调试和出厂测试的隐蔽硬件特性，可以利用它们对iPhone用户发动间谍软件攻击。
这不仅说明发动攻击的威胁行为者水平相当高。同时，也证明依赖于隐蔽和保密的硬件设计或测试，并不能确保安全性。
三角测量操作 Operation Triangulation 是一个针对 Apple iPhone 设备的间谍软件活动，同时利用了四个零日漏洞。这些漏洞链接在一起，形成零点击攻击，允许攻击者提升权限并执行远程代码执行。
构成高度复杂的漏洞利用链的四个漏洞适用于iOS 16.2之前的所有iOS版本：
CVE-2023-41990：ADJUST TrueType 字体指令中存在一个漏洞，允许通过恶意 iMessage 附件远程执行代码。CVE-2023-32434：XNU 内存映射系统调用中存在整数溢出问题，允许攻击者对设备物理内存进行广泛的读/写访问。CVE-2023-32435：在 Safari 漏洞中用于执行 shellcode，作为多阶段攻击的一部分。CVE-2023-38606：使用硬件 MMIO 寄存器绕过页面保护层 （PPL） 的漏洞，覆盖基于硬件的安全保护。 除了影响iPhone之外，这些秘密硬件功能及其高危零日漏洞还存在于Mac、iPod、iPad、Apple TV和Apple Watch中。更重要的是，卡巴斯基发现，这些漏洞并非“失误”，而是有意开发用于这些设备。
三角定位行动攻击链，来源：卡巴斯基
史上最复杂的iPhone间谍软件 在上述漏洞中，CVE-2023-38606是最令卡巴斯基分析师感兴趣的。
通过利用CVE-2023-38606漏洞，攻击者可以绕过 Apple 芯片上的硬件保护，防止攻击者在获得对内核内存的读写访问权限时获得对设备的完全控制权。不过这个漏洞已经在今年7月24日发布的iOS/iPadOS 16.6 中得到了修补。
卡巴斯基研究人员称，CVE-2023-38606 针对的是 Apple A12-A16 仿生处理器中未知的 MMIO（内存映射 I/O）寄存器，这些寄存器可能与芯片的 GPU 协处理器相关联，这些协处理器未在 DeviceTree 中列出。
三角测量攻击中针对的 MIMO 范围，来源：卡巴斯基
相较于这些年卡巴斯基发现的其他攻击软件，研究人员认为这绝对是他们见过的最复杂的攻击链。目前并不知道攻击者是如何学会使用这种未知的硬件功能的，也不知道该软件的最初目的是什么。同时也不清楚该软件是由苹果公司开发的，还是第三方组件。
卡巴斯基研究人员推测，这个未记录的硬件特性之所以包含在最终供消费者使用的iPhone版本中，可能是出于错误，或者是为了方便苹果工程师进行调试和测试。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89bf0f0deed5952c950d6d57e32ed2b7/" rel="bookmark">
			K8Spod组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个pod能包含几个容器
一个pause容器(基础容器/父容器/根容器）
一个或者多个应用容器(业务容器)
通常一个Pod最好只包含一个应用容器，一个应用容器最好也只运行一个业务进程。
同一个Pod里的容器都是运行在同一个node节点上的，并且共享 net、mnt、uts、 pid、 ipc 命名空间。
pod的定义 1 Pod是k8s中最小的资源管理组件
2 Pod也是最小化运行容器化的应用的资源管理对象
3 Pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合
4 最常见的是在一个pod当中运行一个容器，也是最常用的方式
5 在一个pod当中同时运行多个容器，在一个pod当中可以同时封装及格需要耦合的互相协作的容器，这些多个容器共享资源，也可以互相协作组成一个service单位
6 不论运行一个容器还是多个容器，k8s管理的都是pod而不是容器
一个pod内的容器，必须都运行在同一个节点，基于现代容器技术的要求，就是一个pod运行一个容器，一个容器只运行一个进程，横向扩展(核心是方便扩缩容，还有就是解耦，一个pod内运行多个容器，耦合度太高，一旦一个进程失败，整个pod将全部失败)实现解耦，基于pod可以创建多个副本，实现高可用和负载均衡。管理方便，简单直观。
Pod内的容器共享资源，共享机制:pause底层基础容器来提供共享资源的机制。
Pause容器是基础容器，也可以成为父容器，它的作用就是管理pod内容器的共享操作
Pause还可以管理容器的生命周期
k8s提供了pause容器两大核心功能
1 为pod内的所有容器提供一个统一的命名空间
2 启动容器的pid命名空间，每个pod中都作为pid都为1的进程(init进程) ，回收僵尸进程（pod里面是容器，容器运行的进程pid，pause父进程1在pod内部管理容器进程）
3 创建pod时，先创建pause容器，然后拉取镜像，生成容器，形成pod
Pause容器共享两种资源
1 网络：每个pod都会被分配一个集群内部的唯一ip地址，pod内的容器共享网络，pod在集群内部的ip地址和端口，pod内部的容器可以使用localhost互相通信，pod的中容器与外部通信时，从共享的资源当中进行分配，宿主机的端口映射
2 存储pod可以指定多个共享volume，pod内的容器共享这些vloume
Vloume可以是实现数据持久化，可以防止pod重新构建之后数据文件丢失
每个pod都有一个基础容器pause容器
Pause容器对应的惊险属于k8s集群的一部分，创建集群就会有pause这个基础镜像
Pod里面包含了一个或者多个相关的容器（也就是应用）
由kube-controller-manager 提供网络ip
Pod外再设置一个基础镜像
1 pod内部有一组容器，挂了一个，就算整个pod失效了吗？，引入了pause禁止，代表整个容器的组的状态
可以解决对pod内部容器整体状态的判断
2 pod内的容器共享ip，共享volume挂载卷，解决了容器网络通信的问题，解决了容器内部文件共享的问题
pod的分类
1 自主式pod：
这种pod不会自我修复，pod内容器的进程终止或者删除，或者缺少资源被驱逐，这个pod没有办法自愈
由scheduler进行调度，不被控制器管理，没有自愈能力，一旦pod挂掉，不会被重新拉起，没有副本管理，滚动更新功能
2 控制器管理pod：
可以滚动升级，可以自愈(自动重启)，可以提供管理pod的数量，以及扩缩容
由scheduler进行调度，被控制器管理，有自愈能力(一旦pod挂了，会被控制器重新拉起)，由副本管理，滚动更新等功能
3 静态pod
不由schedule调度，是由kubelet自行管理，始终和kubelet运行在同一个node节点上，不能直接删除，静态pod的yaml配置文件目录默认存放于/etc/kubenetes/manifests目录，在这个目录下创建或者删除yaml文件，kubelet会自动的创建或删除静态pod
#创建命令 kubectl create deployment/statefulset/daemonset .... pod的生命周期与常见的状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89bf0f0deed5952c950d6d57e32ed2b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2f54962a746b6cfbeb5f9bb137227c/" rel="bookmark">
			技术探索的激情与匠心：获取IP信息的神秘世界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你是一个热爱互联网技术的癌煤,无论从哪个角度,你都可能被一项名为"获取IP信息"的工具深深吸引。在这个日新月异、高速发展的信息时代,每一项技术产品都竭力提升体验,优化性能,才能在竞赛中保持领先。今天,通过对这款“获取IP信息”的工具进行详细测评,我们将探索其隐藏的功能精髓,品味难得的技术匠心,同时附上改进建议,愿让它更趋完美。
用户体验:普通人也能轻松上手
作为一个技术工具,"获取IP信息"旨在简洁而不失深入,易用而又专业,让每一个用户都能顺利使用。在逐步测试过程中,注重细节,一方面欣赏着它的专业性,另一方面注意它的易用性。各项功能业已设置得恰到好处,诸如查询IP地理位置、ISP服务商等信息无不迅速准确。设计者明显下了大功夫,把复杂的技术用简单易承的方式去呈现。
功能性:既实用又专业
“获取IP信息”的核心功能就是在你的浏览器上快速、准确的提供IP相关信息。对于初级用户,这款工具有基本功能,如查询IP地理位置、ISP服务商等;对于专业用户,它还能提供更深入的数据分析。总的来说,无论你是哪一种用户,都能在此找到自己需要的信息。
性能评估: 精确快捷
作为一个技术力量密集型的产品,在使用网页版进行测试后,“获取IP信息”表现出良好的稳定性和高效响应时间。在各项性能测试中,该工具都显示出了极强的稳定性和精确性,无论是数据处理速度,还是输出结果的精确程度,都可见一斑。
改进建议
虽然“获取IP信息”的易用性、权威性以及稳定性都十分突出,但我还是想给予一些改进的建议:首先,产品的界面设计可以再优化一下,比如添加编辑功能,允许用户根据需求个性化显示数据;其次,可以考虑增添多语言版本,以满足全球用户的需求。
结语
总的来说,“获取IP信息”工具的功能强大,性能稳定,用户体验良好。无论你是技术迷,还是日常生活中需要用到这款工具的用户,都能在这里找到它的价值。而且,相信在未来,经过不断改进,这款工具将会变得更加完美,也期待更多的技术爱好者们能够参与到这个神奇的旅程当中来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60272ed35b913cd507aa40fd7cc2f72/" rel="bookmark">
			分布式（6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
26.雪花算法如何实现的？
27.雪花算法有什么问题？有哪些解决思路？
28.有哪些方案实现分布式锁？
29.基于数据库如何实现分布式锁？有什么缺陷？
30.基于Redis如何实现分布式锁？有什么缺陷？
26.雪花算法如何实现的？ Snowflake,雪花算法是由Twitter开源的分布式ID生成算法，以划分命名空间的方式将64位分隔成多个部分，每个部分代表不同的涵义。而Java中64位的整数是Long类型，所以在Java中SnowFlake算法生成的ID就是Long来存储的。
第1位占用1bit,其值始终是0，可看做事符号位不使用。
第2位开始的41位是时间戳，41bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是69年的时间。
中间的10bit位可以表示机器数，即2^10=1024台机器，但是一般情况下我们不会部署这么多台机器。如果我们对IDC（互联网数据中心）有需求，还可以将10bit分5bit给IDC，分5bit给工作机器。这样子就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义。
最后12bit位是自增序列，可表示2^1=4096个数。
这样的划分之后相当于在一毫秒一个数据中心的一台机器上课产生4096个有序的不重复的ID。但是我们IDC和机器数肯定不止一个，所以毫秒内能生成的有序ID数是翻倍的。
27.雪花算法有什么问题？有哪些解决思路？ 有哪些问题？
时钟回拨问题；
趋势递增，而不是绝对递增；
不能在一台服务器上部署多个分布式ID服务；
如何解决时钟回拨？
以百度的UidGenerator为例，CachedUidGenerator方式主要采取如下一些措施和方案规避了时钟回拨问题和增强唯一性：
自增列：UidGenerator的workerId在实例每次重启时初始化，且就是数据库的自增ID，从而完美的实现每个实例获取到的workId不会有任何冲突。
RingBuffer：UidGenerator不再在每次取ID时都实时计算分布式ID,而是利用RingBuffer数据结构预先生成若干个分布式ID并保存。
时间递增：传统的雪花算法实现都是通过System.currentTimeMills()来获取时间并与上一次时间进行比较，这样的实现严重依赖服务器的时间。而UidGenerator的时间类型是AtomicLong，且通过incrementAndGet()方法获取下一次的时间，从而脱离了对服务器时间的依赖，也就不会有时钟回拨问题
（这种做法也有一个小问题，即分布式ID中的时间信息可能并不是这个ID真正产生的时间点，例如：获取的某分布式ID的值为3200169789968523265,他的反解析结果为{"timestamp":"2019 05 02 23:26:39";"workId":"21";"sequenece":"1"},但是这个ID可能并不是在“2019 05 02 23:26:39：这个时间产生的）。
28.有哪些方案实现分布式锁？ 使用场景
需要保证一个方法在同一时间内只能被同一个线程执行
实现方式：
加锁和解锁
方案，考虑因素（性能，稳定，实现难度，死锁）
基于数据库做分布式锁 乐观锁（基于版本号）和悲观锁（基于排他锁）
基于Redis做分布式锁：setnx(key,当前时间+过期时间）和redlock机制；
基于zookeeper做分布式锁：临时有序节点来实现的分布式锁，Curator
基于Consul做分布式锁
29.基于数据库如何实现分布式锁？有什么缺陷？ 基于数据库表（锁表，很少使用）
最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们想要获得锁的时候，就可以在该表中增加一条记录，想要释放锁的时候就删除这条记录。为了更好的延时，我们先创建一张数据库表，参考如下：
当我们想要获得锁时，可以插入一条数据：
当需要释放锁时，可以删除这条数据：
基于悲观锁
悲观锁实现思路？
在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking)。
如果加锁失败，说明该记录正在被修改，那么当前查询可能等待或者抛出异常。具体响应方式由开发者根据实际需要决定。
如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
其间如果有其他对该记录做修改或者加排他锁的操作，就会等待我们解锁或者直接抛出异常。
以MySQL InnoDB中使用悲观锁为例？
要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交，set autocommit=0；
上面的查询语句中，我们使用了select ... for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t goods表中，id为1的那条数据被我们锁定了，其他的事务必须等本次事务提交后才能执行。这样我们就可以保证当前的数据不会被其他事务修改。
上面我们提到，使用select ... for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL Innodb默认行级锁。行级锁是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。
基于乐观锁
乐观并发控制（又名：乐观锁，缩写OCC）是一种并发控制的方法。他假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务辉县检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e60272ed35b913cd507aa40fd7cc2f72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6923dc891fc0f54655ff571ecc6cc14/" rel="bookmark">
			客户端、服务端在一个c&#43;&#43;程序里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个项目，同时包含客户端、服务端的设计模式称为双工/双端模式。
这种设计模式下，程序具有同时作为客户端和服务端的功能，可以与其他程序通信，并作为服务端接收其他程序的请求。
若开发双工模式的系统，需具备以下内容： 网络通信模块：负责网络连接、收发数据；
客户端功能：
1、与其他程序建立连接、发送请求、解析响应；
2、提供与用户交互界面，以便用户输入请求；
服务端功能：
1、 监听来自其他程序的连接请求、接收请求、处理请求、发送响应。
2、 处理请求；
3、和存储系统交互；
请求响应流程：
1、客户端发送请求给到服务端；
2、服务端接收请求、并解析请求；
3、服务端根据请求内容，执行处理逻辑，生成响应；
4、响应通过网络通信模块发送给客户端，客户端接收响应并解析、显示
并行：
1、程序可以接受多个客户端连接，同时处理请求，并发送响应；
2、程序同时处理多个并发请求；
3、设计和实现双工程序时，需要考虑到线程安全性、并发控制、异常处理等因素，以确保程序的正确运行和稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83768af01c70fae3873dc7aefe8db050/" rel="bookmark">
			水利遥测终端机：提升水利管理效率的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，随着科技的不断发展和水利工作的日益复杂化，水利遥测终端机作为一种重要的工具逐渐受到大家的关注和认可。它不仅可以准确无误地对水利信息进行采集和传输，还能够提供实时监测和预警功能，为水利管理工作带来了极大的便利和效益。
水利遥测终端机可以广泛应用于各种水利工程中，例如水库、水电站、灌溉系统等。它通过采集各种关键数据，如水位、流量、水温等，将这些数据传输到监测中心或相关管理部门，实现对水利工程的全面监测和管理。同时，遥测终端机还可以通过远程控制功能，实现对水利设备的远程操控，从而提高了水利工作的效率和精确性。
水利遥测终端机连接各类水利传感器、控制器等设备终端，实施数据采集工作，最终形成可供监测和分析的数据。传感器的选择和部署是遥测终端机性能的关键因素之一。要根据不同的工程需求和环境条件，选择合适的传感器，并合理布设在关键位置，以获得准确可靠的数据。
计讯物联水利遥测终端机支持5G/3G/北斗等多方式数据远传上云，对接管理平台，数据在线监控。
另外，水利遥测终端机还具备自动报警和远程控制的功能，这对水利工程的安全和管理都起到了重要作用。当监测数据异常情况时，可以通过遥测终端机发送报警信息，及时通知相关人员，并采取相应的措施。同时，通过遥测终端机的远程控制功能，可以实现对水利设备的远程监控和操作，从而提高了工作效率，减少了人力资源的浪费。
除了监测和控制功能外，水利遥测终端机还具备数据存储和分析功能，可以将采集到的数据保存在内部存储器中，并通过网络传输到服务器或云平台进行进一步的处理和分析。通过对数据的长期积累和分析，可以为水利工程的决策提供科学依据，帮助优化水利资源配置，提高水利工作的效益。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef6448727d3880203ce2fd870a12fb5/" rel="bookmark">
			性能测试之（九）：JMeter关联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关联：当请求之间有依赖关系，比如下一个请求的入参是上一个请求返回的数据，这需要进行关联处理；
关联场景1：登录之后返回token，后续的请求需要带token;
常用的关联方法：（在后置处理器中） 正则表达式提取器； Xpath提取器； JSON提取器； 一、正则表达式提取器 1、正则表达式介绍 .:是通配符，可以代表任意字符（除回车换行）；
*:代表前边的字符出现0次或多次；
?:代表非贪婪匹配，找到左边界后，往右查找匹配右边界，只要有匹配的右边界就停止继续查找右边界；
2、正则表达式提取器 2.1 正则表达式提取器参数介绍
2.2 正则表达式提取器使用示例
（1）场景：提取https://www.taobao.com的title中的数据，作为http://www.baidu.com 的参数
（2）操作步骤:
首先新建线程组-新建http（https://www.taobao.com）请求1–&gt;在请求1 下添加 正则表达式提取器–&gt;填写正则表达式提取器内容–&gt;添加http请求2–&gt;http请求2调用http请求1的响应结果作为参数
（3）结果如下：
若正则表达式提取器的结果有多个，可以用Debug Sampler(调试取样器)，查看列表中每个值对应的参数名
二、XPath提取器 使用场景：返回的数据是页面的元素时（返回的还是html格式）；
XPath提取器参数介绍
三、JSON提取器 使用场景：适用于返回的数据类型为JSON格式的情况;
参数介绍：
小tips:如果某个数据包含在上一层的目录下的[]中，则无法提取该数据，只能整个层级一起提取；
四、跨线程组关联（多个线程组执行时，根据情况选择测试计划是否需要串行） 当有依赖关系的2个请求，放入到不同的线程组中时，就不能使用 提取器 保存的变量来传递参数，而是要使用JMeter属性来传递参数
1、JMeter属性的配置方法 函数实现：
1._setProperty函数：将值保存成JMeter属性
2._property函数：在其他线程组中使用property读取属性
2、操作步骤 （1）创建第一个线程，并添加第一个http请求，在第一个http请求中添加JSON提取器
（2）在线程一 中添加BeanShell取样器 ，并用_setProperty函数生成一个函数，并将函数复制到BeanShell取样器中。
3、创建线程2 ，并添加取样器二，使用函数助手的property生成一个函数
4、查看返回结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06a4c1feef7eeb9833db096ed279aa82/" rel="bookmark">
			R语言【base】——rm/remove()：从指定环境中删除对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Package base version 4.2.0
Parameters remove(..., list = character(), pos = -1, envir = as.environment(pos), inherits = FALSE) rm (..., list = character(), pos = -1, envir = as.environment(pos), inherits = FALSE) 参数【...】：要删除的对象，如名称（不带引号）或字符串（带引号）。
参数【list】：命名要删除的对象的字符向量。
参数【pos】：在哪里进行删除。默认情况下，使用当前环境。
参数【envir】：要使用的环境。
参数【inherits】：是否应该检查环境的封闭框架？
Detail 参数【pos】可以通过以下几种方式之一指定从中删除对象的环境：
作为整数（搜索列表中的位置）作为搜索列表中元素的字符串名称作为环境（包括使用 sys.frame 访问当前处于活动状态的函数调用） 参数【envir】是指定环境的另一种方式，但主要是为了向后兼容。
不允许从基本环境和基本命名空间中删除变量，也不允许从任何锁定的环境中删除变量。
Example tmp &lt;- 1:4 ## work with tmp and cleanup rm(tmp) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547cc26edbee8f70c726d74a0c5c60a1/" rel="bookmark">
			如何设计企业级业务流程？学习华为的流程六级分类经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务流程管理（BPM）是一种系统化的方法，用于分析、设计、执行、监控和优化组织的业务流程，以实现预期的目标和价值。业务流程管理中，流程的分级方法有多种，常见的有以下几种：
APQC的流程分级方法：将流程分为五级，分别是类或域、流程组、流程、活动和任务。（资料详见：流程参考模型之APQC PCF中文PPT，25页PDF）
三级分解法：将流程分为三级，分别是公司级、部门级和岗位级。
四级分解法：将流程分为四级，分别是组织结构、岗位、事务工作和活动。
华为的流程分级方法：将流程分为六级，分别是流程分类、流程组、流程、子流程、流程活动和任务。
华为流程分级方法是华为公司在建设流程体系时采用的一种流程分层和分解的方法。华为流程分级方法的特点是：
以客户为中心，以业务为导向，以流程为核心，以制度和机制为保障，构建了一个完整的流程管理体系。
以战略为导向，以目标为驱动，以流程为纽带，实现了战略目标的有效传导和执行。
以流程为主线，以团队为载体，以角色为分工，实现了跨职能部门的协同和高效。
以流程为基础，以数据为支撑，以指标为导向，实现了流程的监控和改进。
华为流程分级方法的目的是为了实现流程的标准化、规范化和可执行化，以提高公司的管理效率和竞争力。
华为流程分级分别是：
L1：流程分类。流程分类是从价值链的角度对流程进行的大类划分，如运营流程、管理支持流程等。流程分类反映了公司的业务模式和战略目标，覆盖了公司的全部业务。
L2：流程组。流程组是对流程分类下的流程进行的进一步细化，如运营流程下的战略管理流程、集成产品开发流程、客户关系管理流程、集成供应链流程等。流程组反映了公司的业务领域和范围，是流程管理的基本单元。
L3：流程。流程是流程组下的具体业务流程，如集成产品开发流程下的需求管理流程、战略规划流程、产品规划流程等。流程是跨职能部门的端到端的业务流程，反映了公司的业务逻辑和流程。
L4：子流程。子流程是流程下的职能部门内的业务流程，如需求管理流程下的需求收集子流程、需求分析子流程、需求分发子流程等。子流程是职能域的管理，确保职能域的交付能满足主流程的需要。
L5：流程活动。流程活动是子流程下的具体业务活动，如需求收集子流程下的收集客户需求活动、收集市场需求活动、收集竞争对手需求活动等。流程活动是完成流程目标所需要的具体活动，反映了业务的多样化和灵活性。
L6：任务。任务是流程活动下的具体工作任务，如收集客户需求活动下的访问客户任务、收集客户反馈任务、整理客户需求任务等。任务是流程活动的具体执行，反映了流程的可执行性和操作性。
接下来，分享完整版《华为流程L1-L6》培训教材，欢迎收藏学习！
参考：EA之家整理：详解华为六级业务流程，31页PPTX文件-EA之家
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b708d31bd322e5fa97d7322900cbb789/" rel="bookmark">
			npm发布js工具包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建项目 1、在github上创建一个项目，然后拉取至本地，进入项目目录2、执行 npm init 生成json文件3、创建 src/index.ts 入口文件和 src/isObject.ts 工具方法 · src/index.ts export { default as isObject } from './isObject' · src/isObject.ts /** * @description 判断是否为对象 * @param {*} variable * @returns {Boolean} */ function isObject(variable: any): boolean { return Object.prototype.toString.call(variable) === '[object Object]' } export default isObject 二、配置Rollup打包 1、安装rollup和typescript npm install rollup typescript -D2、创建 tsconfig.json 配置文件： { "compilerOptions": { "target": "es5" /* 编译目标 */, "module": "commonjs" /* 项目模块类型 */, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b708d31bd322e5fa97d7322900cbb789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd897b2cb6f5b35ec2da2d4e2704c8f/" rel="bookmark">
			springboot整合websocket实现聊天室对话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要实现Spring Boot整合WebSocket实现聊天室对话，你需要遵循以下步骤：
1. 添加依赖 在你的pom.xml文件中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2. 配置WebSocket 创建一个配置类，继承AbstractWebSocketMessageBrokerConfigurer，并重写相关方法：
import org.springframework.context.annotation.Configuration; import org.springframework.messaging.simp.config.MessageBrokerRegistry; import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer; import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker; import org.springframework.web.socket.config.annotation.StompEndpointRegistry; @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { config.enableSimpleBroker("/topic"); config.setApplicationDestinationPrefixes("/app"); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint("/chat").withSockJS(); } } 3. 创建消息控制器 创建一个控制器类，用于处理客户端发送的消息：
import org.springframework.messaging.handler.annotation.MessageMapping; import org.springframework.messaging.handler.annotation.SendTo; import org.springframework.stereotype.Controller; @Controller public class ChatController { @MessageMapping("/send") @SendTo("/topic/messages") public String handleMessage(String message) { return message; } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd897b2cb6f5b35ec2da2d4e2704c8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/733508a292658076401305c95ff0f3d2/" rel="bookmark">
			如何制作可预约的上门维修服务小程序？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上门维修服务已经成为人们日常生活中不可或缺的一部分。为了满足这一需求，我们学习如何无经验自己制作上门维修服务小程序。
首先，打开乔拓云-门店系统的后台，可以看到有很多各行各业的模版。这些模版涵盖了各种行业，包括家电维修、电脑维修、管道疏通等等。你可以根据自己的行业选择一个适合的模版，点击预览，觉得符合就可以点击替换。
进入编辑页面后，这里的图片和文字都可以双击进行拖拽修改。你可以自由地编辑和设计你的小程序界面，添加或删除功能，设置价格和服务流程等等。同时，你还可以通过点击左侧的导航栏进行添加新的功能，例如添加一个新的服务项目或者一个新的服务流程。
编辑完成之后，点击马上发布，就可以将小程序发到自己喜欢的平台。让更多的用户可以预约你的上门维修服务。
当顾客预约时，后台会实时显示预约时间与订单。你可以通过后台随时查看顾客的预约信息和订单详情，以便更好地安排维修人员和服务流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f0aa8665660db995f910940e2840d8/" rel="bookmark">
			Canvas保姆级教程----深入解析HTML5 Canvas工作原理和常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢 鸿蒙专栏：想学鸿蒙的，冲
📢 C语言专栏：想学C语言的，冲
📢 VUE专栏：想学VUE的，冲这里
📢 CSS专栏：想学CSS的，冲这里
📢 Krpano专栏：想学VUE的，冲这里
🔔 上述专栏，都在不定期持续更新中！！！！！！！！！！！！！
目录
✨ 前言
一、Canvas工作原理
1、获取Canvas元素
2、获取渲染上下文
3、绘图方法
4、渲染动画
二、坐标系统
三、常用绘图方法
1、绘制矩形
2、绘制路径
3、绘制圆弧 arc()
4、绘制图像 drawImage()
5、变形
6、样式设置
7、渐变和图片填充
四、Canvas案例:
1、复杂路径绘制
2、保存和恢复状态
3、剪切区域 clip()
4、图像像素操作
5、动画效果
✨ 结语
✨ 前言 HTML5 Canvas让网页具备了强大的绘图能力,我们可以通过JavaScript动态生成各种图表、动画等复杂的可视化效果。要合理利用Canvas开发丰富的组件和页面,理解它的工作原理是必要的。本文将详细解析Canvas的实现过程,并给出各种常用绘图方法的代码示例,希望可以帮助开发者全面掌握Canvas。
一、Canvas工作原理 1、获取Canvas元素 使用document.getElementById()获取HTML页面中的&lt;canvas&gt;元素,例如:
const canvas = document.getElementById('myCanvas') 2、获取渲染上下文 通过canvas.getContext()获取绘图上下文,通常我们使用2d上下文:
const ctx = canvas.getContext('2d') 3、绘图方法 通过上下文提供的API绘制图形,诸如rect、arc等。
ctx.rect(20, 20, 150, 100) 4、渲染动画 Canvas会记录绘图命令,并在需要时重绘整个scen来实现动画效果。
二、坐标系统 Canvas使用一个笛卡尔坐标系统,原点在左上角,x轴向右为正,y轴向下为正,单位默认为px。
三、常用绘图方法 1、绘制矩形 fillRect(x, y, width, height) 填充矩形strokeRect(x, y, width, height) 绘制矩形边框 // 绘制一个蓝色矩形 ctx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f0aa8665660db995f910940e2840d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f5a92e0749e11ab4781d26632ea7d92/" rel="bookmark">
			Power Automate删除SharePoint Online或OneDrive for Business文件版本历史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SharePoint Online和OneDrive for Business支持版本控制，可以保留文件的版本历史，方便用户随时查看和恢复以前的版本。但该功能也会占用大量SharePoint Online或OneDrive for Business存储空间。官方删除版本历史的方法无法批量操作，故今天提供一种使用Power Automate来删除SharePoint Online或OneDrive for Business文件版本历史。
第一步：添加“Get files(properties only)”操作，以获取列表中的文件。
第二步：添加“Send an HTTP request to SharePoint”操作：
Method: GET Uri: _api/web/GetFolderByServerRelativeUrl('Dynamic content of Folder Path')/Files('Dynamic content of File name with extension')/Versions 第三步：“Parse JSON”，将上一个动作的正文放入解析 JSON 动作的内容中，然后点击“使用示例负载”按钮生成 schema 粘贴如下 schema：
{ "type": "object", "properties": { "d": { "type": "object", "properties": { "results": { "type": "array", "items": { "type": "object", "properties": { "__metadata": { "type": "object", "properties": { "id": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f5a92e0749e11ab4781d26632ea7d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/338357d1a2ad87bf530a7c24241af59f/" rel="bookmark">
			k8s---pod的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pod的相关知识 pod是k8s中最小的资源管理组件
pod也是最小化运行容器化的应用的资源管理对象
pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合。
k8s中pod的两种使用方式 （1）一个pod中运行一个容器。"每个po中一个容器"的模式是最常见的用法:在这种使用方式中，你可以把pod想象成是单个容器的封装，kterentes管理的是Pod而不是直接管理容器。
（2）在一个Pod中同时运行多个容器。一个Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器可以互相协作成为一个servie单位。
这些多个容器共享资源，也可以互相协作组成一个service单位。
不论运行一个容器还是多个容器，k8s管理的都是pod不是容器。
一个pod内的多个容器，必须都运行在一个节点上。基于现在容器技术的要求，一个pod运行一个容器，一个容器只运行一个进程。这样做是为了：横向扩展，方便扩缩容。解耦。一个pod内会运行多个容器，耦合度太高，导致整个集群全部失败。实现解耦，基于pod可以创建多个副本，实现高可用和负载均衡。
管理方便，简单直观。
pod内的容器共享资源，共享机制：pause pause容器是基础容器，也可以称为父容器。管理pod内容器的共享操作。
pause还可以管理容器的生命周期。
k8s提供了pause容器
pause作用 1.为pod内的所有容器提供一个命名空间
2.启动容器的pid命名空间，每个pod中都作为pid为1的进程（init进程），回收僵尸进程。
3.创建pod时，先创建pause容器，然后再拉取镜像，生成容器，形成pod
pid为1，是所有进程的父进程。
每创建好一个pod就会自动生成一个pause。
k8s创建pod的工作流程 第一步：master节点发出指令，pod使用的镜像nginx，pod的副本数。第二步：kube-scheduler来分配执行的node节点。第三步：node节点的kubelet收到master，拉pause，拉nginx：1.22 pod1第四步：pause容器先启动，提供命名空间，进程管理管理pid1，来为pod内的容器提供共享服务以及容器的进程管理 pause容器共享两种资源 1.网络资源： 每个pod都会分配一个集群内部的唯一IP地址，pod内的容器共享。pod在集群内部的IP地址和端口。
pod内部的容器可以使用localhost互相通信。pod的中容器与外部同学时，从共享的资源当中进行分配。宿主机的端口映射。
2.存储资源 pod可以指定多个共享的volume，pod内的容器共享这些volume。
volume可以实现数据的持久化。
防止pod重新构建之后文件消失。
pause总结： 每个pod都有一个基础容器--pause。
pause对应的镜像属于k8s集群的一部分。创建集群就会有pause基础镜像。
pod里面包含了一个或者多个相关的容器（应用）
pod外再设置一个初始镜像：
1.pod内部都有一组容器，挂了一个，就算pod失效了吗？引入pause机制，代表整个容器组的状态。
可以解决pod内部容器整体的状态判断。
2.pod内的容器共享IP 共享volume挂载卷。解决了容器内网络通信的问题，解决了容器内部文件共享的问题。
举个不太恰当的例子：kubelect相当于市长，pause相当于区长。kubelect发布指令创建pod，创建pod的具体操作通过pause来完成。pause管理pod内部一系列组件
pod的分类： 自主式pod： 不会自我修复，pod内容器的进程终止，被删除，缺少资源被驱逐，这个pod没有办法自愈。
deployment daemanset
控制器管理pod： 可以滚动升级，可以自愈（自动重启），可以管理pod的数量以及pod的扩缩容。
pod的生命周期 1.pending 挂起 pod已被创建，但是尚未被分配到运行的node节点。
原因：节点的资源不够，需要等待其他pod的调度。
2.running 运行中 pod已经被分配到了node节点，pod内部的所有容器都已经启动，运行状态正常，稳定。
3.complete / successded 表示容器内部的进程运行完毕，正常退出，没有发生错误。
4.failed： pod中的容器非正常退出。发生了错误，需要通过查看详情和日志来定位问题。
5.UNknow： 因为某些原因，k8s集群无法获取pod的状态。APIserver出了问题。
6.terminating ： 终止中，pod正在被删除，里面的容器正在终止。种植过程中，资源回收，垃圾清理，以及终止过程中需要执行的命令。
创建pod的容器分类 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/338357d1a2ad87bf530a7c24241af59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b5c37b2b52aea174ba09ede144471c5/" rel="bookmark">
			Jvm之垃圾收集器（个人见解仅供参考）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问：什么是垃圾收集算法中的分代收集理论？
答：分代收集理论是垃圾收集算法的一种思想，根据对象存活周期的不同将内存分为几块，一般将java堆分为新生代和老年代。这种理论使得我们可以根据各个年代的特点选择合适的垃圾收集算法。 问：在新生代中，通常选择哪种垃圾收集算法？
答：在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法。 问：标记-清除算法会带来什么问题？
答：标记-清除算法会带来两个明显的问题：1. 效率问题 (如果需要标记的对象太多，效率不高)2. 空间问题（标记清除后会产生大量不连续的碎片） 问：垃圾收集器的作用是什么？
答：垃圾收集器是内存回收的具体实现，根据具体应用场景选择适合自己的垃圾收集器。 问： Serial收集器是什么？有什么特点？
答：Serial收集器是最基本、历史最悠久的垃圾收集器，是一个单线程收集器。它的特点是简单高效，对于CPU资源有限、内存空间较小、单核CPU环境下的应用场景较为适用。 问：复制算法的优点是什么？
答：复制算法的优点在于它只需要付出少量对象的复制成本就可以完成每次垃圾收集，适用于新生代中每次收集都有大量对象死去的情况。 问：标记-清除算法的缺点是什么？
答：标记-清除算法会带来两个明显的问题：效率问题和空间问题。如果需要标记的对象太多，效率不高；标记清除后会产生大量不连续的碎片，导致空间浪费。 问：标记-整理算法的特点是什么？
答：标记-整理算法是针对老年代的特点特出的一种标记算法。它与“标记-清除”算法的标记过程相同，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 问：为什么没有最好的垃圾收集器？
答：因为不同的应用场景对垃圾收集的需求不同，所以没有一种垃圾收集器能够适用于所有场景。此外，不同的垃圾收集器在性能、吞吐量、延迟等方面也有所差异，因此需要根据具体需求选择适合的垃圾收集器。 问：什么是垃圾收集器？
答：垃圾收集器是用于自动管理内存的程序，它会自动回收不再使用的对象所占用的内存，以防止内存泄漏。垃圾收集器是内存回收的具体实现。 问：Serial收集器有什么特点？
答：Serial收集器是一个单线程收集器，它在进行垃圾收集时会暂停所有的用户线程，直到收集完成。因此，它的暂停时间是可以预测的，但是在大内存、多核处理器环境下，它的性能可能不够理想。 问：什么是吞吐量？
答：吞吐量是指程序执行的总时间与程序执行的时间加上垃圾收集的时间之和的比值。高吞吐量意味着垃圾收集的开销较小，程序执行效率较高。 问：为什么我们需要选择适合的垃圾收集器？
答：不同的应用场景对垃圾收集的需求不同，例如实时应用需要低延迟的垃圾收集器，而批处理应用则更注重吞吐量。此外，不同的垃圾收集器在性能、吞吐量、延迟等方面也有所差异，因此需要根据具体需求选择适合的垃圾收集器。 问：什么是内存泄漏？
答：内存泄漏是指程序在申请内存后，无法释放不再使用的内存空间，导致内存占用不断增加，最终可能导致程序崩溃或性能下降。垃圾收集器的主要作用就是自动回收不再使用的对象的内存，以防止内存泄漏。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36e81d5ec105be0722ecd07fe0a0cc8/" rel="bookmark">
			Jvm垃圾收集器系列之Parallel Scavenge收集器（个人见解仅供参考）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问：什么是Parallel Scavenge？
答：Parallel Scavenge是Java HotSpot虚拟机中的一种垃圾收集器，它主要用于提高应用程序的吞吐量。 问：Parallel Scavenge的主要目标是什么？
答：Parallel Scavenge的主要目标是最大化应用程序的吞吐量，即应用程序运行时间与总运行时间（包括垃圾回收时间）的比值。 问：Parallel Scavenge如何实现并行垃圾回收？
答：Parallel Scavenge通过多线程的方式实现并行垃圾回收，可以在多个CPU核心上同时进行垃圾回收操作，从而提高垃圾回收的效率。 问：Parallel Scavenge与Serial收集器有何不同？
答：Parallel Scavenge与Serial收集器的主要区别在于并行处理和单线程处理。Parallel Scavenge采用多线程处理垃圾回收，而Serial收集器则采用单线程处理。 问：使用Parallel Scavenge需要注意哪些问题？
答：使用Parallel Scavenge需要注意的问题包括内存分配、垃圾回收的频率和暂停时间等。此外，还需要根据应用程序的性能需求和硬件环境选择合适的垃圾收集器。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d81ddb6773aac8929ff5b37f60efe4b/" rel="bookmark">
			FreeRTOS任务通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FreeRTOS 内核 V8.2.0 版本发布的时候，FreeRTOS 新增了任务通知这个功能，任务通知也
是用于任务间进行同步和通讯的一种机制，但是相对于前面章节介绍的队列、事件标志组和信
号量等而言，任务通知在内存占用和效率方面都有很大的优势。
一、 FreeRTOS 任务通知简介 在 FreeRTOS 中，每一个任务都有两个用于任务通知功能的数组，分别为任务通知数组和
任务通知状态数组。其中任务通知数组中的每一个元素都是一个 32 位无符号类型的通知值；而
任务通知状态数组中的元素则表示与之对应的任务通知的状态。任务通知数组中的 32 位无符号通知值，用于任务到任务或中断到任务发送通知的“媒介”。当通知值为 0 时，表示没有任务通知；当通知值不为 0 时，表示有任务通知，并且通知值就是通知的内容。
任务通知状态数组中的元素，用于标记任务通知数组中通知的状态，任务通知有三种状态，分别为未等待通知状态、等待通知状态和等待接收通知状态。其中未等待通知状态为任务通知
的复位状态；当任务在没有通知的时候接收通知时，在任务阻塞等待任务通知的这段时间内，
任务所等待的任务通知就处于等待通知状态；当有其他任务向任务发送通知，但任务还未接收
这一通知的这段期间内，任务通知就处于等待接收通知状态。任务通知功能所使用到的任务通知数组和任务通知状态数组为任务控制块中的成员变量，因此任务通知的传输是直接传出到任务中的，不同通过任务的通讯对象（队列、事件标志组和信号量就属于通讯对象）这个间接的方式。
二、任务通知的优势 使用任务通知向任务发送事件或数据比使用队列、事件标志组或信号量快得多；并且使用
任务通知代替队列、事件标志组或信号量，可以节省大量的内存，这是因为每个通讯对象在使
用之前都需要被创建，而任务通知功能中的每个通知只需要在每个任务中占用固定的 5 字节内
存。
三、任务通知的缺点 虽然任务通知功能相比通讯对象，有着更快、占用内存少的优点，但是任务通知功能并不
能适用于所有情况，例如以下列出的几种情况：
1. 发送事件或数据到中断
通讯对象可以发送事件或数据从中断到任务，或从任务到中断，但是由于任务通知依赖于
任务控制块中的两个成员变量，并且中断不是任务，因此任务通知功能并不适用于从任务往中
断发送事件或数据的这种情况，但是任务通知功能可以在任务之间或从中断到任务发送事件或
数据。
2. 存在多个接收任务
通讯对象可以被已知通讯对象句柄的任意多个任务或中断访问（发送或接收），但任务通知
是直接发送事件或数据到指定接收任务的，因传输的事件或数据只能由接收任务处理。然而在
实际中很少受到这种情况的限制，因为，虽然多个任务和中断发送事件或数据到一个通讯对象
是很常见的，但很少出现多个任务或中断接收同一个通讯对象的情况。
3. 缓冲多个 数据项
通讯对象中的队列是可以一次性保存多个已经被发送到队列，但还未被接收的事件或数据
的，也就是说，通讯对象有着一定的缓冲多个数据的能力，但是任务通知是通过更新任务通知
值来发送事件或数据的，一个任务通知值只能保存一次。
4. 广播到多个任务
通讯对象中的事件标志组是可以将一个事件同时发送到多个任务中的，但任务通知只能是
被指定的一个接收任务接收并处理。
5. 阻塞等待接收任务
当通讯对象处于暂时无法写入的状态（例如队列已满，此时无法再向队列写入消息）时，
发送任务是可以选择阻塞等待接收任务接收，但是任务因尝试发送任务通知到已有任务通知但
还未处理的任务而进行阻塞等待的。但是任务通知也很少在实际情况中收到这种情况的限制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd5c7ecedfba15d12f8379d6586754c/" rel="bookmark">
			[Java]判断一个矩阵是另一个矩阵的子矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
从标准输入中输入一个N（N&lt;=9）阶矩阵和一个M（M&lt;=N）阶矩阵，判断矩阵M是否是N的子矩阵，若是则输出M在N中的起始位置，若不是则输出-1。若矩阵M能与N中某一区域完全相等，则称M是N的子矩阵。
【输入形式】
从标准输入读取矩阵。
第一行只有一个整数N，代表第一个矩阵的阶数。后续有N行输入，每行有N个以若干空格分隔的整数，代表该矩阵在该行上的所有元素。
输入完N阶矩阵后，再在下一行输入一个整数M，代表第二个矩阵的阶数。后续有M行输入，每行有M个以若干空格分隔的整数，代表该矩阵在该行上的所有元素。
【输出形式】
输出M在N中的起始位置，即N中的第几行第几列，两个数字用逗号&amp;ldquo;,&amp;rdquo;分隔（从第1行第1列开始计数，即：矩阵第一个元素的位置为：1,1。
若N有多个子矩阵与M矩阵完全相同，则输出首先找到的起始位置，即行最小的位置，若行相同，则为列最小的位置。
若M不是N的子矩阵，则输出-1。
【样例输入】
6
3 9 15 25 -9 0
36 102 2 5 67 89
8 12 58 6 53 456
67 7 895 -12 65 -83
-56 812 25 0 72 61
4 71 69 -4 341 970
3
6 53 456
-12 65 -83
0 72 61
【样例输出】
3,4
【样例说明】
第一个矩阵为6阶矩阵，第二个矩阵为3阶矩阵，第二个矩阵与第一个矩阵的某个子矩阵（起始位置为第3行第4列的3阶矩阵）完全相同，故输出3,4，行列数用逗号隔开。
参考代码：
import java.util.Scanner; public class text10 { public static void main(String[] args) { Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dd5c7ecedfba15d12f8379d6586754c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba92b202c8a7933d1334c894cb8e6ae5/" rel="bookmark">
			如何在 Ubuntu 20.04 上设置 SSH 密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个人工智能学习网站，通俗易懂，风趣幽默，最重要的屌图甚多，忍不住分享一下给大家。点击跳转到网站。
如何在 Ubuntu 20.04 上设置 SSH 密钥 介绍 SSH（即安全外壳）是一种加密协议，用于管理服务器并与服务器通信。使用 Ubuntu 服务器时，我们将大部分时间花在通过 SSH 连接到服务器的终端会话上。
下来将重点关注为 Ubuntu 20.04 安装设置 SSH 密钥，SSH 密钥提供了一种安全的登录服务器的方式。
第 1 步 — 创建密钥对 第一步是在客户端计算机（通常是个人计算机）上创建密钥对：
ssh-keygen 默认情况下，最新版本ssh-keygen将创建一个 3072 位 RSA 密钥对，这对于大多数用例来说足够安全（也可以选择传入标志-b 4096来创建更大的 4096 位密钥）。
输入命令后，应该看到以下输出：
OutputGenerating public/private rsa key pair. Enter file in which to save the key (/your_home/.ssh/id_rsa): 按 Enter 键将密钥对保存到.ssh/主目录的子目录中，或指定备用路径。
如果之前已经生成了 SSH 密钥对，可能会看到以下提示：
Output/home/your_home/.ssh/id_rsa already exists. Overwrite (y/n)? 如果选择覆盖磁盘上的密钥，将无法再使用以前的密钥进行身份验证。选择“是”时要非常小心，因为这是一个无法逆转的破坏性过程。
然后应该看到以下提示：
OutputEnter passphrase (empty for no passphrase): 可以选择在此处输入安全密码，强烈建议这样做。密码增加了额外的安全层，以防止未经授权的用户登录。要了解有关安全性的更多信息，请参阅：如何在 Linux 服务器上配置基于 SSH 密钥的身份验证。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba92b202c8a7933d1334c894cb8e6ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3bd4bf6b2f52df10c0b1452b3c56a9a/" rel="bookmark">
			IRS通信仿真第一篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年通信仿真第一篇论文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15596c251c76910438d0329349ac6dd6/" rel="bookmark">
			Invalid options in vue.config.js: “plugins“ is not allowed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 安装并配置elementPlus报错。
问题描述 "plugins" is not allowed. plugins不被允许。参考官网修改配置文件vue.config.js。 解决方案： const AutoImport = require('unplugin-auto-import/webpack') const Components = require('unplugin-vue-components/webpack') const { ElementPlusResolver } = require('unplugin-vue-components/resolvers') module.exports = { configureWebpack: (config) =&gt; { config.plugins.push( AutoImport({ resolvers: [ElementPlusResolver()] }) ) config.plugins.push( Components({ resolvers: [ElementPlusResolver()] }) ) } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec88904230b9e1c00644c68388b52f6d/" rel="bookmark">
			zsh&#43;oh-my-zsh&#43;powerlevel10k终端配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 安装zsh 1：检查 1、首先，查看一下你系统里所有的shell
cat /etc/shells 这里我是已经装了zsh,所以有zsh
2、安装zsh apt install zsh #安装zsh 然后将zsh设置成默认shell，但好像没什么用，还是要输入zsh命令才会进zsh，回到bash就输入直接在终端输入bash
chsh -s /bin/zsh 2 安装oh-my-zsh zsh是shell脚本，oh-my-zsh是zsh的配置，我们要是自己配置zsh的配置的话会比较麻烦，好在github上有大佬制作了一个配置文件，“oh-my-zsh”，这是目前zsh中最流行的一个配置了。
（如果没装git请 ：apt install git）
一键式安装方法
wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 也可以去zsh的github看一下
如果安装成功出现如下：
并且会在~目录出现一个.zshrc文件，类似.bashrc文件
如果下载不成功，试试执行这个命令
然后再~目录会出现一个.zshrc文件
该文件开始只有以下几行，其他都是注释，.zshrc文件内容如下
export ZSH="$HOME/.oh-my-zsh" # 主题 ZSH_THEME="robbyrussell" # 插件 plugins=(git) source $ZSH/oh-my-zsh.sh 只需注意主题和插件两行即可
主题：可以更改终端样式
默认的robbyrussell主题如下：
可以去~/.oh-my-zsh/thems目录查看已有的主题，可以替换成你想要的主题
比如换成cloud主题，就把.zshrc文件修改成：
export ZSH="$HOME/.oh-my-zsh" # 主题 ZSH_THEME="cloud" # 插件 plugins=(git) source $ZSH/oh-my-zsh.sh 然后执行
source ~/.zshrc 可以看到主题已经更改
zsh插件 一般安装语法高亮zsh-syntax-highlighting 和历史命令建议zsh-autosuggestions两个插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec88904230b9e1c00644c68388b52f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af5272ec4e89caf64afb7636dd7cb117/" rel="bookmark">
			Zabbix“专家坐诊”第222期问答汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一
Q：Zabbix6.4能讲下维护区间吗？启动区间和期间是什么不同？
TiuySPzJ6567d4304f4b9.png
A：启动区间是这条维护规则的有效时间；期间则是维护的周期，比如什么时候维护，维护多久。
问题二
Q：Zabbix版本是6.4，请问如何在邮件告警里面调用特定监控项的值调用格式是？如何调用？
A：能调用触发器表达式中引用到的值,{ITEM.VALUE1}、{ITEM.VALUE2}分别对应表达式中监控项的第一个、第二个值。
问题三
Q：请问一下，我这为什么不对呢？
1qJNLIpq6567d44233782.png
A：宏里引用不了宏，宏可以嵌套，不过值不行。
问题四
Q：Zabbix5.3版本怎么升级6.0有文档吗？
A：可参考这个，https://forum.lwops.cn/article/401
Q：建集群是不是要升级到6.0版本才可以建集群？建集群的文档有吗？
A：是的，参考：https://www.zabbix.com/documentation/6.4/zh/manual/concepts/server/ha?hl=HA
问题五
Q：请问我升级版本数据库那些不用升级到高版本吗？
A：数据库版本可以看看官网说明，https://forum.lwops.cn/article/382，这一篇是zabbix+mysql的升级。
问题六
Q：Zabbix6服务端日志里面报的这个错误，请问有没有什么解决办法呀？Heartbeat我看官方文档是说It is used to monitor the availability of active checks，我用的是被动模式，是不是和这个有关？然后这个消息在日志里面大量出现。
jwzxeHPD6567d58f644b7.png
rt1DYRLV6567d466d1e6c.png
这个问题我在配置文件里面有找到一个相关的参数，但是按照注释里面的设置成0以后，不仅不会关闭，反而是0.01秒发送一个请求，不知道有没有什么解决办法呀【zabbix版本：6.4，客户端：zabbix-agent26.4.8】
A：看起来是主动模式的请求，可以看看这个，https://blog.csdn.net/startinging/article/details/5836587
问题七
Q：Zabbix6.0监控rabbitMQ3.7.0集群，模板选用RabbitMQ cluster by HTTP，第一天可以收集到数据，第二天数据没了。因为没有数据，我就删除了，刚又添加了一下，还是没有。
gTX8wSun6567d47b7ee47.png vDjceo996567d4859b6db.png
A：测试请求有返回吗？
Q：
Cy2zl6QU6567d48f7d135.png
A：url能正常访问吗？
SIVJKaFz6567d495a25e3.png
Q：可以
FvwbMdsp6567d49c907b5.png
vgg1oK9Z6567d4a333312.png
A：
{KaTeX parse error: Expected 'EOF', got '}' at position 20: …ITMQ.API.SCHEME}̲://{HOST.CONN}:…RABBITMQ.API.PORT}/api/overview 把宏都换上能访问吗？
Q：
XHCkELwE6567d4ad3e3c0.pngQmRfXtqY6567d4b336007.png
A：这个只保留http。
JyIUYKa46567d4b9c3020.png
Q：有数了。
问题八
Q：我手动在客户端关闭了zabbix_agent，然后平台有时候有告警有时候没有，而且告警时间特别慢什么原因？数据库历史数据我删了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af5272ec4e89caf64afb7636dd7cb117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/123e4fe05abf7aa1a9168c8edb1b5b27/" rel="bookmark">
			软件工程专业毕业设计题目怎么选？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 简介1 如何选题2 最新软件工程毕设选题3 最后 0 简介 学长搜集分享最新的软件工程业专业毕设选题，难度适中，适合作为毕业设计，大家参考。
学长整理的题目标准：
相对容易工作量达标题目新颖 1 如何选题 最近非常多的学弟学妹问学长关于选题的问题，所以今天学长来教大家如何进行毕业设计选题！
毕业设计的选题尤为重要，选好题目是最终完成毕业设计的第一步。
因为题目的选择跟之后的设计实现密不可分，如果你所选择的题目是你无法实现的，而且定题以后就不能修改了，这无疑会给你带来很大的困扰。
先介绍一下自己, 本人HIT研究生在读, 接触许多大三大四的实习生，我都会帮他们分析选题的难度，根据他自己对知识掌握的情况来帮他们选题。
一般来说，一套网站系统，像一些基于ssm框架的管理系统比较容易一点，更为容易一些。但今年来，这种前后端系统(统称XXX管理系统)很难通过毕设答辩，因为基本做被烂了，更多的学校要求设计题目内必须包含算法。
2 最新软件工程毕设选题 基于SSM的热点推荐个性化新闻系统的设计与实现
基于卷积神经网络的共享单车识别系统的设计与实现
基于深度学习的图片自动分类系统的设计与实现
基于VUE框架的实时新闻推送平台的设计与实现
基于卷积神经网络的垃圾短信识别系统的设计与实现
基于卷积神经网络的垃圾短信识别系统的设计与实现
基于遗传算法的股票预测系统设计与实现
基于SSM开发的微博舆情系统的设计与实现
基于SSM的人力资源管理系统的设计与实现
基于卷积神经网络的人体行为识别系统的开发与设计
基于协同过滤算法的图书管理系统的设计与实现
基于BP神经网络的停车场管理系统的设计与实现
基于YOLOV5的火灾快速识别系统的设计与实现
基于CNN算法的图像艺术风格迁移系统的设计与实现
基于React框架开发企业教育平台后台管理系统的设计与实现
基于机器学习的歌曲自动生成系统的设计与实现
基于线性回归的毕业生招聘信息及租房数据系统的设计与实现
基于卷积神经网络的在线作业检测与存档管理系统的设计与实现
基于神经网络模型的文本纠错系统的设计与实现
基于深度学习的驾驶行为识别管理系统的设计与实现
基于卷积神经网络模型的垃圾分类系统的设计与实现
基于CNN的多标签新闻分类系统的设计与实现
基于卷积神将网络的识别图片数字自动打码系统设计与实现
基于BP神经网络的畜牧业养殖场管理系统的设计与实现
基于BP神经网络的人脸朝向系统的设计与实现
基于卷积神经网络的人体关键点识别系统的研究与实现
基于深度学习的相似图片识别系统的设计与实现
基于卷积神经网络的邮件管理系统的设计与实现
基于卷积神经网络模型水果识别分类的设计与实现
基于机器学习的餐饮服务管理系统的设计与实现
基于卷积神经网络算法的车牌识别停车管理系统的设计与实现
基于Bp神经网络的停车场车牌识别系统
基于内容关联的饮食推荐系统在青岛工学院的应用
基于SSM框架的校园帮系统的设计与实现
基于K-means算法的校园美食推荐系统
基于Java的疫苗预约网站的设计与实现
基于协同过滤算法的医院病人健康饮食定制系统的设计与实现
基于深度学习的图片审核系统在微博的应用
基于协同过滤的个性化书籍推荐系统的设计与实现
基于SSM框架的学生实习管理系统的设计与实现
基于DBSCAN算法的可视化数据分析平台的设计与实现
基于Web的农场租赁及农产品销售管理系统
基于卷积神经网络RL人机对弈的应用设计
基于蚁群算法的北京市旅游景点线路优化系统的研究与实现
基于Web的电子产品销售系统的设计与实现
基于SSM+LayUI的租房信息共享系统的设计与实现
基于历史行为的微博热门话题推荐系统设计及实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/123e4fe05abf7aa1a9168c8edb1b5b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc21a9701203cdbfb98ef7d550aeb57/" rel="bookmark">
			96 双指针解旋转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一个链表，旋转链表，将链表每个节点向右移动k个位置，其中k是复数。
示例1：输入1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null;k=2
输出： 5-&gt;6-&gt;1-&gt;2-&gt;3-&gt;4
双指针求解：定义快慢两个指针，开始均指向起始节点，快指针先移动k次，随后快慢指针同时向前移动，直到快指针到达最后一个元素停止移动，并使得最后一个元素的指针指向头节点，并断开慢指针位null。
public TreeNode swirlList(ListNode head,int k) { ListNode slow=head; Listnode fast=head; for(int i=0;i&lt;k;i++) { fast=fast.next; } while(fast.next==null) { slow=slow.next; fast=fast.next; } fast.next=head; slow.next=null; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591956b1a2a333559b7ab579cd385ba0/" rel="bookmark">
			【小程序开发】解决 HBuilder X “[error] IDE service port disabled“无法运行问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发微信小程序时，在HBuilder X上方菜单点击”运行“-&gt;”运行到小程序模拟器“-&gt;”微信开发者工具“后，控制台输出了”[error] IDE service port disabled. To use CLI Call, please enter y to confirm enabling CLI capability, or manually open IDE -&gt; Settings -&gt; Security Settings, and set Service Port On.“ ... ? Enable IDE Service (y/N) ESC[27DESC[27C，如下图：
说明微信开发者工具的服务端口是关闭状态，根据提示，第一种在控制台直接输入”Y“的方式好像行不通，那么就使用第二种手动打开工具 -&gt; 设置 -&gt; 安全设置，将服务端口开启。注意：这个设置是在微信开发者工具中的，而不是HBuilder X，如下图：
亲测有效！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdbf61cb11bea02851cc491767fc0a4/" rel="bookmark">
			uniapp 微信小程序 对返回的数值保留小数点后两位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意toFixed()只能用在数值部分
//尾数四舍五入 numFilter (value) { // 截取当前数据到小数点后两位 let realVal = parseFloat(value).toFixed(2) return realVal } //不四舍五入 numFilter (value) { // 截取当前数据到小数点后三位 let tempVal = parseFloat(value).toFixed(3) let realVal = tempVal.substring(0, tempVal.length - 1) return realVal } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f010ee2b75a502a532e614c375397bac/" rel="bookmark">
			编程笔记 html5&amp;css&amp;js 016 HTML表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程笔记 html5&amp;css&amp;js 016 HTML表格 一、HTML 表格二、HTML 表格标签三、边框属性四、单元格合并五、操作小结 表格是一种常用的文档格式。学习或办公过程中也常常使用表格。有专用的电子表格软件，如EXCEL、WPS表格等。表格也经常与文字混合在文章中使用。网页中也是一样，需要表格这种形式。 一、HTML 表格 是一种用于展示和组织数据的标记语言。表格由行和列组成，每个单元格可以包含文本、图像或其他 HTML 元素。下面是一个简单的 HTML 表格示例：
&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;25&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 在这个例子中，&lt;table&gt; 元素表示一个表格。&lt;tr&gt; 元素表示表格中的一行。&lt;th&gt; 元素表示表头单元格，用于显示列的标题。&lt;td&gt; 元素表示数据单元格，用于显示实际的数据。
这个表格有三个列：姓名、年龄和性别，以及两行数据。可以使用 CSS 来设置表格的样式，例如调整边框、背景颜色和字体样式等：
&lt;style&gt; table { border-collapse: collapse; width: 100%; } th, td { border: 1px solid black; padding: 8px; text-align: left; } th { background-color: #f2f2f2; } &lt;/style&gt; 通过在 &lt;style&gt; 标签中添加 CSS 样式，可以实现表格的自定义样式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f010ee2b75a502a532e614c375397bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95b2e1216e4209035e0cc631be5dd046/" rel="bookmark">
			haproxy笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 场景haproxy配置文档地址 场景 还得先从场景说起。
生产环境redis检查，发现配置的redis地址不对。 redis有3个节点。
192.168.0.1
192.168.0.2
192.168.0.3
但是配置的是 192.168.0.9 端口是16379。
好奇怪有没有，是不是配错了?
问了下部署大神，才确认部署的没问题。 说是走的haproxy。
那么问题来了，haproxy是什么?
还是那句话，做程序员即使不会用，也必须听说过。
google了下，才发现haproxy是redis负载均衡。 那么走起，一探究竟吧。
haproxy配置 如果只是使用的话，不需要深入了解(学习成本太高)。
好在主配置就是最后几行，大概明白什么意思就行。
当然，haproxy实际是很复杂的，我们只简单使用。
global log 127.0.0.1 local0 notice maxconn 10240 daemon defaults mode http log global option tcplog option dontlognull option http-server-close option redispatch retries 3 maxconn 10240 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s listen stats bind 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95b2e1216e4209035e0cc631be5dd046/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6af1ef8b370869af266ee303d86e0cc/" rel="bookmark">
			机器学习在缺陷检测中的突破与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习在缺陷检测中的突破与实践主要体现在以下几个方面：
自动化检测：机器学习技术能够自动化地处理大量的数据，并通过学习和识别各种缺陷的模式和特征，实现自动化检测。这大大提高了缺陷检测的效率和准确性，减少了人工干预和误差。
高精度识别：传统的缺陷检测方法往往受到光照、角度、遮挡等因素的影响，导致检测精度不高。而机器学习技术可以通过对大量数据进行学习和训练，提取出更加鲁棒和准确的特征，从而实现高精度的缺陷识别。
实时性：机器学习算法的优化和硬件设备的提升使得实时缺陷检测成为可能。这意味着在生产线上可以实时监测产品是否存在缺陷，并及时反馈和处理问题，大大提高了生产效率和产品质量。
预测性维护：通过对设备运行数据的分析和学习，机器学习技术可以预测设备可能出现的缺陷和故障，提前进行维护和修复，减少设备停机时间和维护成本。
在实践中，机器学习技术在许多领域都得到了广泛应用。例如，在制造业中，机器学习被用于自动化检测生产线上的产品缺陷；在医疗领域，机器学习被用于辅助医生诊断疾病和检测医疗影像中的异常；在交通领域，机器学习被用于检测交通设施中的缺陷和故障，保障交通安全和畅通。
需要注意的是，虽然机器学习在缺陷检测中取得了显著的突破和实践成果，但仍存在一些挑战和问题。例如，如何获取足够数量和质量的训练数据、如何选择合适的算法和模型、如何处理不平衡样本等问题都需要进一步研究和解决。此外，随着技术的不断发展和应用场景的不断扩展，还需要不断探索和创新机器学习在缺陷检测中的应用方式和方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a966104e3073848763c874d5d1b8331a/" rel="bookmark">
			[运维] 银河麒麟V10安装turnserver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [参考文献]
Linux 部署turnserver
安装turnserver
部署 安装编译工具 yum install -y make gcc gcc-c++ wget openssl-devel libevent libevent-devel 下载源码 wget https://coturn.net/turnserver/v4.5.0.8/turnserver-4.5.0.8.tar.gz 解压源码包 tar -zxvf turnserver-4.5.0.8.tar.gz cd turnserver-4.5.0.8/ 编译安装 ./configure --prefix=/usr/local/turnserver make -j8 &amp;&amp; make install 配置turnserver.conf vim /usr/local/turnserver/share/examples/turnserver/etc/turnserver.conf 在末尾新增以下内容
# 监听端口，不配置的话，默认是3478 listening-port=3478 # 公网地址 external-ip=服务器公网ip # 设置用户名及密码，可设置多个 user=mengxing:123456 设置环境变量
编辑~/.bashrc vim ~/.bashrc 插入内容
export turnserver_home=/usr/local/turnserver export PATH=$PATH:$turnserver_home/bin 刷新环境变量
source ~/.bashrc 启动 turn server turnserver -v -r 服务器公网ip -a -o -c /usr/local/turnserver/share/examples/turnserver/etc/turnserver.conf 停止turn服务 ps -ef|grep turnserver|grep -v grep kill 对应进程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2db72b5be4e40d176f5f6f5b328eba/" rel="bookmark">
			我的JavaScript学习之旅：从新手到熟练的转变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#CSDN 年度征文｜回顾 2023，赢专属铭牌等定制奖品#
转眼又一年~~我们的年度征文如约而至！诚挚邀请你参与本次活动，与我们一起回顾过去这一年。
2023年，对我来说，是技术成长的一年。在这一年里，我选择挑战自我，踏上了学习JavaScript的旅程。这篇文章，将带您了解我学习JavaScript的心路历程。
在开始学习JavaScript之前，我曾多次听到关于JavaScript的种种赞誉和挑战。有人说它是前端开发的基石，也有人说它复杂且难以掌握。但我一直坚信，只要用心去学，任何困难都不是问题。
学习JavaScript的过程并不平坦。初期，我就被JavaScript的异步特性和回调函数搞得晕头转向。每当遇到问题，我会深入挖掘、阅读大量资料，并与有经验的开发者交流，尝试去理解其中的奥妙。慢慢地，我开始明白异步编程的意义和重要性，并逐渐掌握了Promise、async/await等异步处理技巧。
随着学习的深入，我逐渐感受到了JavaScript的魅力。它的函数式编程特性让我在处理数据和逻辑时更加得心应手。同时，JavaScript的生态系统也令我惊叹不已。从Node.js到前端框架，如React、Vue等，JavaScript的影响力无处不在。
当然，学习的过程中也充满了挫折和困惑。有时我会对某个概念感到困惑，有时我会在项目中遇到难以解决的问题。但正是这些挑战，让我更加坚定了学习的决心。我明白了学习新技术不是一蹴而就的，它需要耐心、毅力和不断地实践。
回首这一年，我为我的坚持和努力感到骄傲。通过学习JavaScript，我不仅提升了自己的技术能力，还开拓了视野，对前端开发有了更深入的理解。我相信，随着时间的推移，我会在JavaScript的世界里走得更远。
在这个过程中，我深刻地体会到学习新技术的意义不仅在于掌握一项技能，更在于培养自己的思维方式和学习习惯。在遇到困难时，我学会了不轻言放弃，而是通过查找资料、请教他人等方式寻找解决方案。这种积极的态度和持续学习的精神也让我在工作中更加自信和从容。
此外，学习JavaScript还让我认识到技术是相通的。以前我认为前端开发和后端开发是两个截然不同的领域，但通过学习JavaScript，我逐渐领悟到前后端之间的紧密联系。只有了解整个技术栈的工作原理和应用场景，才能更好地为项目提供技术支持和解决方案。
未来，我计划继续深入研究JavaScript及其相关技术。我希望能够熟练掌握React、Vue等前端框架，并探索更多关于前端性能优化和用户体验优化的技巧。同时，我也期待与更多的前端开发者交流和分享经验，共同成长。
最后，我想感谢那些在我学习过程中给予帮助和支持的人。你们的鼓励和建议是我前进的动力。在未来的日子里，我将继续保持学习的热情和探索的精神，迎接每一个挑战和机遇。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/137ec7e14dfb275d4c1cc62938c62514/" rel="bookmark">
			计算机专业 最新 毕业设计 选题推荐 毕设指导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 计算机毕设选题推荐2 开题指导3 最后 0 前言 大家好！大四的同学们毕业设计即将开始了，你们做好准备了吗？
学长给大家精心整理了最新的计算机毕业设计选题，希望能为你们提供帮助。如果在选题过程中有任何疑问，都可以随时问我，我会尽力帮助大家。
在选择毕业设计选题时，有几个要点需要考虑。首先，选题应与计算机专业密切相关，并且符合当前行业的发展趋势。选择与专业紧密结合的选题，可以使你们更好地运用所学知识，并为未来的职业发展奠定基础。
要考虑选题的实际可行性和创新性。选题应具备一定的实践意义和应用前景，能够解决实际问题或改善现有技术。同时，可以尝试一些有创新思维和研究价值的选题，以展示你们的独立思考和解决问题的能力。
此外要根据自身的兴趣和专长选择题目。选择一个你们感兴趣且擅长的选题，可以提高你们的研究热情和积极性，使得整个毕业设计过程更加愉快和有成就感。
最后不要忘记与导师和同学们进行充分的交流和讨论，他们可以提供宝贵的指导意见和建议。同时，与同学们分享选题的想法和讨论，可以获得更多的观点和启发。
总之我希望这些毕设选题整理对大家有所帮助。如果在选题或其他方面需要任何帮助，可以随时向我提问。祝愿大家顺利开始毕业设计，取得优秀的成果！
1 计算机毕设选题推荐 人物头像的卡通化算法设计与实现人脸表情分类算法设计与实现人脸属性分类算法设计与实现人脸特征提取算法研究与实现基于深度学习的视频中物体快速搜索算法基于深度学习的图像检索算法研究基于深度学习的图像分割算法研究基于深度学习的网络游戏流失玩家预测算法研究基于机器学习的短时交通流预测算法的研究与实现基于机器学习的问答评价算法设计基于机器学习的问答推荐算法设计基于增强学习的物流优化算法研究基于深度网络的年龄预测算法研究基于深度网络的RGBD图像分割算法研究基于对抗神经网络的图像超分辨率算法研究基于记忆网络的视觉逻辑推理算法的研究与实现基于贝叶斯网络的因果关系研究及算法包实现基于端到端神经网络模型的词义消歧算法研究基于社交网络结构的社会推荐算法研究多层社交网络的链路预测算法研究社交网络中的位置推荐算法研究社会网络下算法博弈的研究与实现基于反向推荐的个性化推荐算法研究基于推荐算法的商品流行性预测算法研究基于轨迹数据的最优路径推荐算法设计与实现基于泊松分解的推荐算法研究与应用基于图像的人群聚集检测算法研究与实现图像去雾算法的研究与实现移动平台图像分类算法的研究与实现基于哈希的图像分类算法研究基于CNN的图像去噪算法的实现图像的艺术风格渲染算法设计与实现基于视频图像的目标跟踪算法研究与C++实现基于视频行为分析的暴力事件检测算法研究与C++实现基于文本的网络用户分析算法设计与实现基于关键词与同义词的主观题评分技术研究基于流量特征的主机安全状态评估研究与实现基于深度学习的公共场所客流运动模式分割算法研究假期高速公路交通流量预测算法的设计与实现基于Android平台的心律异常检测的算法实现基于Matlab的ECG心律不齐分类算法的程序实现基于用户评论属性的隐私保护算法研究与分析基于硬件加速的室外场景光照估计与渲染算法研究与实现基于隐私保护的数据挖掘算法研究基于Matlab的全景图片生成算法实现基于数据主权区块链的共识算法的研究智能+教育：知识点多标签分类算法设计和实现黑白字体彩色艺术化算法设计与实现基于XGBoost的网络游戏流失玩家预测算法研究基于rank-order的脉冲神经网络学习算法研究基于虚拟现实技术和强化学习的机器人控制算法人群行为建模与仿真基于手机信令的旅游人口建模与分析基于RGBD相机的多视角人体姿态重建基于RFID标签的行为识别技术及实现基于神经网络的弱监督物体检测神经网络模型基于数据内在结构特征的哈希检索方法一种深度神经网络的FPGA加速引擎基于弱监督深度学习图像识别研究物体检测算法研究轻量级JavaWeb开发框架的设计与实现多源数据的图结构学习研究科学家合作网络结构演化研究0-1背包算法的实现与应用多视角聚类算法研究自步多任务多视图聚类算法研究群智计算算法的研究相容图(pcg)构造算法研究三维模型的网格简化算法研究图像去镜面高光算法研究与C++实现图像去雨算法的研究与实现平面图上cyclepacking问题的核心化算法研究基于平衡树的RFID系统密钥更新算法基于生成树的复杂网络抽样算法研究针对网络评论的分类算法研究机器阅读算法的可解释研究边缘计算任务调度算法研究并行计算若干经典算法的设计与实现属性增强的概念图匹配算法研究与应用FP-tree关联规则算法的实现与应用面向M2M网内存储控制算法研究与仿真面向网络丢包环境的视频编码优化控制算法生成式对抗网络算法及应用研究基于FPGA的快速矩阵运算实现自重多核学习研究初等数学知识库的研究与构建图像中积分的识别与求解一种嵌入式深度卷积神经网络推理引擎选址问题的防策略机制设计信息骨架研究与应用基于共享结构的简单-复杂活动协同识别贝叶斯张量分解信息安全知识图谱的设计与实现基于矩阵分解的子空间聚类研究 学长的作品示例：
基于python的邮件分类系统文本情感理解技术研究干细胞分裂与生长跟踪研究行为活动理解中的弱监督学习研究气候环境因素对老年COPD患者的影响分析研究基于深度学习的车牌识别系统设计与实现深度卷积神经网络及其在人脸识别中的应用深度增强学习理论研究及其在视频游戏上的应用基于深度学习的机器人室内场景识别基于深度学习的哈希方法在多粒度图像检索中的研究与实现基于深度学习的网站验证码识别系统设计与实现张量分解在生物信息学的应用基于点过程的产品流行性预测基于循环神经网络的静态代码分析社交网络用户关系研究在线社交网络中用户兴趣演化分析与建模研究社交网络上信息传播行为分析与计算机模拟研究心电图数据研究轨迹数据的语义表征与学习基于深度强化学习的NPC自主训练模型构建的实现基于LSTM完成对英文词性标注的设计与实现基于机器学习的中文情感识别研究基于深度神经网络的高质量词向量生成方法研究基于地图数据的新加坡出租车接送乘客轨迹可视化及需求预测医疗健康档案信息可视化系统设计与实现活动轨迹的语义表达与搜索技术研究基于电信大数据的自我中心网络可视化研究基于DCGAN的cifar10数据集生成设计与实现城市自行车的出行行为分析商场中精确定位用户所在店铺基于出租车轨迹数据的可视化研究学生行为习惯“画像”可视分析平台基于地图API的高铁运行地图的设计与实现基于大数据技术的职业岗位画像设计与实现基于协同过滤的用户移动轨迹信息预测研究可视化展示数据处理中心的设计和实现基于新浪微博的分布式爬虫以及对数据的可视化处理基于公共自行车数据的城市居民职住地分析动态网络上的表征学习基于社交网络交换的物品分配问题基于复杂网络的QQ社交网络的用户关系研究基于复杂网络的城市地铁交通网络研究Internet自治层网络的重要结构特征研究基于深度学习的心律失常的自动分类基于深度学习的糖尿病视网膜疾病诊断研究与实现基于深度学习的人物头部着装分类研究与实现基于深度学习的人脸检测与识别系统设计与实现基于深度学习的情感分类基于深度学习的场景分类研究基于深度神经网络的标题分类研究基于DeepLearning的图片分类基于深度学习的图像检索基于深度学习提取图像视频特征基于深度学习的图片风格转化基于深度学习的多模态检索基于深度学习的医学图像分割基于深度学习的辅助药物设计基于深度学习的异常检测基于深度学习的声纹识别基于深度学习的推荐系统设计与实现基于深度学习的车辆特征识别研究与实现基于深度学习的入侵检测系统设计与实现基于深度学习的呼吸监测基于深度学习的零样本和少样本学习基于深度学习的大数据预测方法基于深度学习的字体风格转换方法基于深度学习的肺癌检测方法研究基于元胞自动机的复杂系统涌现现象分类方法研究机器学习在MCI疾病分类中的实现基于卷积神经网络的图像语义分割算法研究基于深度学习的图像超分辨率重建算法设计基于深度学习的图像去噪算法研究与实现基于深度学习的图像风格迁移算法设计与实现基于深度学习的图像生成对抗网络（GAN）研究与应用基于深度学习的人体姿态估计算法研究与实现基于深度学习的行人重识别算法设计与实现基于深度学习的交通标志识别与分类系统设计基于深度学习的医学图像分析与诊断系统设计基于深度学习的手势识别与控制系统设计基于深度学习的无人机视觉导航与避障算法研究基于深度学习的自动驾驶车辆视觉感知与决策系统设计基于深度学习的人机交互界面设计与实现基于深度学习的视频内容分析与标注系统设计基于深度学习的虚拟现实与增强现实应用研究基于深度学习的文本图像检索与关联算法研究基于深度学习的自然语言处理与图像理解的结合研究基于深度学习的人脸检测算法的设计与实现基于深度学习的车辆检测算法的设计与实现基于深度学习的行人检测算法的设计与实现基于深度学习的动物检测算法的设计与实现基于深度学习的水果检测算法的设计与实现基于深度学习的建筑物检测算法的设计与实现基于深度学习的飞机检测算法的设计与实现基于深度学习的火车检测算法的设计与实现基于深度学习的船只检测算法的设计与实现基于深度学习的自行车检测算法的设计与实现基于深度学习的交通标志检测算法的设计与实现基于深度学习的道路标线检测算法的设计与实现基于深度学习的行人姿态检测算法的设计与实现基于深度学习的手势识别算法的设计与实现基于深度学习的目标跟踪算法的设计与实现基于深度学习的人体关键点检测算法的设计与实现基于深度学习的物体分割算法的设计与实现基于深度学习的医学图像检测算法的设计与实现基于深度学习的无人机目标检测算法的设计与实现基于深度学习的农作物病害检测算法的设计与实现基于深度学习的人体行为识别算法的设计与实现基于深度学习的宠物识别算法的设计与实现基于深度学习的文本检测算法的设计与实现基于深度学习的图像质量评估算法的设计与实现基于深度学习的人脸表情识别算法的设计与实现基于深度学习的手写数字识别算法的设计与实现基于深度学习的车牌识别算法的设计与实现基于深度学习的人群计数算法的设计与实现基于深度学习的目标分类与检测算法的设计与实现基于深度学习的多目标跟踪算法的设计与实现基于深度学习的人体姿态估计算法的设计与实现基于深度学习的人脸识别与检测算法的设计与实现基于深度学习的手势控制算法的设计与实现基于深度学习的目标实例分割算法的设计与实现基于深度学习的人体关键点跟踪算法的设计与实现基于深度学习的人体姿态跟踪算法的设计与实现基于深度学习的图像超分辨率与目标检测算法的设计与实现基于深度学习的视频目标检测算法的设计与实现基于深度学习的遥感图像目标检测算法的设计与实现基于深度学习的工业缺陷检测算法的设计与实现基于深度学习的人群密度估计与目标检测算法的设计与实现基于深度学习的无人驾驶车辆目标检测算法的设计与实现基于深度学习的医学图像分割与目标检测算法的设计与实现基于深度学习的无人机图像目标检测与跟踪算法的设计与实现基于深度学习的人体姿态估计与目标检测算法的设计与实现基于深度学习的无人机目标跟踪与避障算法的设计与实现基于深度学习的视频行为识别与目标检测算法的设计与实现 学长的作品示例：
基于hadoop的工作流调度的研究基于Hadoop的公共自行车数据分布式存储和计算基于HHT的大规模网络流量数据处理方法研究金融大数据背景下定量化研究风险投资机构对企业发展的影响基于目标时空轨迹的大数据分析与挖掘方法研究基于Hadoop的图书推荐系统的设计与实现基于大数据的健康美食推荐系统设计与实现基于Spark的高考志愿推荐系统设计与实现基于大数据的拼团购物数据分析系统的设计与实现基于大数据的投保数据的分析系统的设计与实现基于大数据的亚健康人群的分析系统的设计与实现基于大数据的电子产品需求数据分析系统的设计与实现基于大数据的二线城市租房数据分析系统的设计与实现基于hive的共享单车用户特征分析系统的设计与实现基于大数据的美团外卖的数据分析系统的设计与实现中国降雨量数据展示与分析系统的设计与实现基于Hive的网络电视剧收视率分析的设计与实现基于大数据的健康产品分析系统的设计与实现基于大数据的亚健康人群分析系统的设计与实现基于Hadoop的一线城市租房需求的数据分析系统设计与实现基于Hadoop的扶贫的数据分析系统设计与实现某物流公司物流数据分析系统的设计与实现基于Hive的高校考试分析系统设计与实现基于大数据的滴滴出行的数据分析系统的设计与实现基于大数据的餐饮行业食材管理系统的设计与实现基于大数据的小区车辆监控系统的设计与实现基于大数据的饿了么外卖推荐系统的设计与实现基于大数据的租房推荐系统的设计与实现基于大数据的网络视频的用户画像的分析的设计与实现基于大数据的购物用户画像分析系统的设计与实现基于大数据的快手的用户画像分析系统的设计与实现基于大数据的旅游的用户画像分析系统的设计与实现基于Spark的公益活动平台的设计与实现基于大数据的收藏平台的设计与实现基于大数据的时尚推荐平台的设计与实现基于大数据的科技平台的设计与实现基于Hadoop的故事会平台的设计与实现基于大数据的国内展会平台的设计与实现基于大数据的在线购物商场设计与实现基于大数据的天津生活网平台的设计与实现基于大数据的个人出行推荐系统的设计与实现基于人工智能的邮件分发系统设计与实现基于智能识别的垃圾回收系统的设计与实现基于大数据的某电影院的电影票房预测系统的设计与实现基于大数据的云存储系统的设计与实现基于大数据的网盘应用的设计与实现基于大数据的在线音乐网站的设计与实现基于大数据的在线视频网站的设计与实现基于Mapreduce的好友推荐系统的设计与实现基于Hadoop的游戏统计网站的设计与实现基于hadoop的交通信息分析系统的的设计与实现基于hadoop的气象信息分析系统的设计与实现基于hadoop的webKPI分析系统的设计与实现基于hadoop的网站流量分析系统的设计与实现基于hadoop的手机流量分析系统的设计与实现基于hadoop的电商日志分析系统的设计与实现基于hadoop的购物商场系统的设计与实现基于大数据华客论坛的设计与实现基于大数据技术的bilibili网站数据分析的设计与实现基于大数据的自营商品平台分析系统的设计与实现基于大数据的新闻分析系统的设计与实现基于大数据技术的点餐系统的设计与实现针对大规模数据流的实时处理研究分布式消息队列的设计与实现分布式文件系统设计与实现小文件优化访问技术云PaaS中可定制的自动化部署方法研究与实现三维地形绘制系统设计与实现区块链交易信息的获取与可视化分析 学长的作品示例：
基于口令认证协议的云存储加密数据去重数字图像加密关键技术研究与实现基于动态时间规整算法的签名认证网络安全评估工具的设计与实现RSA实现中弱密钥漏洞分析Web服务统一身份认证协议设计与实现以太坊拒绝服务攻击检测基于信息隐藏技术的安全电子邮件设计与开发一种隐私保护的BP神经网络的设计信息安全领域中语义搜索引擎的设计与实现针对空间数据范围搜索的加密技术研究智能手机主动安全防护系统设计与实现数据库加密系统设计与实现的设计与开发Android终端安全审计软件模块开发Android应用程序代码保护与反保护大数据环境下的隐私安全的图像特征提取及应用云计算环境下加密数据查询的关键技术研究基于数据主权区块链的个人数据账户系统设计与实现基于主权数据区块链的身份共享应用技术一个基于区块链技术的应用系统原型设计与实现基于数据主权区块链的系统架构设计基于区块链技术的域名系统设计与实现基于区块链的分布式认证系统设计与实现基于Hadoop的区块链海量数据存储的设计与实现基于数据主权区块链的共享价值代币设计与流通方法区块链上智能合约的部署与应用研究构建基于区块链的时间承诺合同构建基于区块链的多人博弈合约 学长的作品示例：
2 开题指导 (1) 起因
近期越来越多同学开始写论文开题报告，但许多同学不指导如何选择合适的题目，不清楚老师分配的题目应该如何做，指导老师提供的信息也不够充分，导致无从下手。
(2) 如何避坑(重中之重)
毕设选题实际上对许多学生来说是一个巨大的陷阱，每年都有无数人自己挖坑然后跳进去。选择一个好的题目会使后续的答辩和论文写作变得轻松许多，而选择不当则会导致无尽的痛苦和折磨。。。。
(3) 为什么这么说呢？
实际上，这主要是因为大部分同学对特定场景所需技术的了解不清晰，导致在确定课题时他们会错误地认为某些功能很容易实现，而实际情况往往并非如此。
因此，建议对于对课题实现技术不清晰的同学，最好是寻求自己的研究生学长或老师的帮助，详细了解技术和实现流程。当然，你也可以来问我，学长会根据你的情况提供帮助。
(4) 难度把控
对于那些只追求顺利毕业的同学来说，选择毕业课题时需要注意不能选择过于困难或过于简单的题目。选择过于困难的题目可能导致自己难以完成，而选择过于简单的题目则可能导致工作量不足，无法撰写完整的论文，甚至无法通过答辩阶段。因此，需要在适度的难度范围内选择合适的课题。
(5) 题目名称
另外，最近有很多同学向学长反映，定的课题总是被老师退回，其实这还真不怪老师，我看到你们定的课题也是哭笑不得。。。。
学长在这里给你们分享一个定题标准，跟着这个标准定题准没错：
“使用了什么算法(技术) + 在什么场景下 + 解决了哪一类问题”
3 最后 如果你有任何对于开题选题的疑问，或者对相关技术缺乏了解，不知道如何开始进行毕业设计，都可以向学长咨询寻求帮助。学长会根据你的具体情况提供指导和支持。不论是你对选题还是对技术方面存在的问题，学长都愿意提供帮助。学长根据你的需求和能力，为你提供一些指导和建议，无论你遇到什么问题，都可以向学长请教，学长将竭尽全力协助你顺利完成毕业设计。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23af31ab3529aeebfbbf44b5f597b30a/" rel="bookmark">
			网络安全—IPSec安全策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络拓扑添加策略ESP添加筛选器添加筛选器的操作另一台主机设置 AH 使用Windows Server 2003系统
网络拓扑 client1
IP = 192.168.17.105client2
IP = 192.168.17.106 只要保证两个主机在同一网段接口，即互相ping通即可完成策略的实现
下面的所有通讯都只是互相ping地址观察数据包是否实现了安全策略。
添加策略 ESP 添加筛选器 点击本地安全策略
双击安全服务器
添加
点击下一步来到这里，依旧是默认第一个，然后点击下一步
下一步
点击添加IP筛选器
写好名称和描述方便辨认（然后点击添加）
下一步即可
由于上面说过我使用client2来ping另一部，所以我这里目的IP地址就是对方的105
下一步，选择ICMP，因为我们是通过ping的方式进行传输数据包。
完成
点击确定
选中我们添加好的新的IP筛选
添加筛选器的操作 依旧选择添加新的筛选器操作
继续下一步，写上名称和描述信息方便辨认
下一步
选择完整性和加密，加密的就是ESP协议，AH是仅保证完整性
一直下一步完成即可，然后勾选上我刚刚添加的筛选器操作即可下一步
这里选择共享密码，设置一个双方都知道的密码，也就是说我们待会设置另一个主机的时候，来到这里的密码要设置一样的
记得将其他默认勾选的都去掉，只剩下我们自己的就行，点击应用即可
然后指派安全服务器策略
另一台主机设置 一样的设置，一定要一样，名称和描述可以不同，还有密码一定要设置一样的。不同的就是写目的IP地址是不同的。
另一台主机设置完成后，回到client主机，打开抓包软件，然后ping通client1，发现全是ESP协议包，分析可知道ESP协议号是50，完美！
AH 添加过程同理
下面将会介绍一些不同的细节，在ESP部分也讲过。
选择仅数据完整性，因为AH不提供加密服务
完成后，双方仅仅指派AH协议的筛选器
排错：假设你没有ping通，那么很可能就是你没有选AH的仅仅保证完整性而是选择了加密。
选择你刚刚添加的AH，点击编辑选项
选择筛选器操作，然后选择你的AH操作，然后编辑
点击AH然后编辑
为了保险起见，我们自己定义AH，取消ESP，记住现在是选择了MD5算法，待会另一台设置的时候也是要这样设置回来MD5，然后其他就没问题了，直接指派即可。
如果还错误就是密码不一样，来到身份验证，然后选择编辑即可
全部搞定后记得选择AH，然后应用，最后指派任务。 成功ping通，找到数据包的协议号为51，就是AH协议号，完美！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d2500b21f7b8bd3abc6b180d32dfa8e/" rel="bookmark">
			全解析阿里云Alibaba Cloud Linux镜像操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Alibaba Cloud Linux是基于龙蜥社区OpenAnolis龙蜥操作系统Anolis OS的阿里云发行版，针对阿里云服务器ECS做了大量深度优化，Alibaba Cloud Linux由阿里云官方免费提供长期支持和维护LTS，Alibaba Cloud Linux完全兼容CentOS/RHEL生态和操作方式，阿里云百科aliyunbaike.com来详细说下阿里云服务器镜像系统Alibaba Cloud Linux官方详解：
Alibaba Cloud Linux
Alibaba Cloud Linux介绍 什么是Alibaba Cloud Linux？Alibaba Cloud Linux是阿里云推出的Linux发行版，Alibaba Cloud Linux是基于龙蜥社区OpenAnolis龙蜥操作系统Anolis OS。Alibaba Cloud Linux针对云服务器ECS进行了深度优化，CentOS停止维护完全可以使用Alibaba Cloud Linux代替，Alibaba Cloud Linux兼容CentOS/RHEL生态，CentOS/RHEL中的大多数软件无需或仅需少量改造即可在Alibaba Cloud Linux中运行。
详细参考：https://t.aliyun.com/U/OaD80G
目前Alibaba Cloud Linux已经更新到版本3
版本停止支持日期Alibaba Cloud Linux 32031-04-30Alibaba Cloud Linux 22024-03-31 关于Alibaba Cloud Linux2和3镜像版本详细说明参考：
Alibaba Cloud Linux性能特点 安全合规：Alibaba Cloud Linux是一个100%开源的Linux服务器操作系统发行版，用户可以自由下载、检视所有源代码，阿里云对系统漏洞提供及时修复，并持续提升系统的安全标准；性能优势：阿里云上启动最快的Linux服务器操作系统发行版，针对阿里云基础设施进行了深度优化的Linux服务器操作系统，并针对云服务器ECS虚拟机、裸金属服务器性能深度优化；免费的支持服务：与其它免费Linux操作系统发行版不同，Alibaba Cloud Linux服务器操作系统在提供最新Linux内核版本的同时，免费给用户提供技术支持与服务；开源生态：Alibaba Cloud Linux服务器操作系统采用开源社区成果；开箱即用、无需复杂配置：通过默认搭载阿里云常用的开源软件包，例如Aliyun CLI和cloud-init，在主流使用场景中减少用户的管理开销；新版开源软件包的持续集成：积极引入新版开源软件，例如Linux 5.10内核，并承诺持续丰富开源软件包生态的不断完善；多架构支持：支持Intel、AMD、ARM等平台最新功能特性，能够充分发挥平台优势，并结合阿里云基础设置持续深入进行优化；丰富的解决方案：提供多种镜像和解决方案，如可信镜像、等保镜像等，帮助客户在不同场景下获得最佳实践；热补丁支持：为内核的高危CVE漏洞和重要Bugfix提供热补丁支持，客户无须重启实例即可获得内核稳定性和安全保障。Alibaba Cloud Linux 3选择Linux kernel 5.10 LTS，同时默认搭载GCC 10.2、binutils 2.35、glibc 2.32等基础软件；Alibaba Cloud Linux 2选择Linux kernel 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d2500b21f7b8bd3abc6b180d32dfa8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b858ec8d78ee8dc393547b77db1fb25/" rel="bookmark">
			rime中州韵小狼毫 help lua Translator 帮助消息翻译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lua 是 Rime中州韵/小狼毫输入法强大的武器，掌握如何在Rime中州韵/小狼毫中使用lua，你将体验到什么叫 随心所欲。
先看效果 在 rime中州韵 输入效果一览 中的 👇 help效果 一节中， 我们看到了在Rime中州韵/小狼毫输入法中输入 help 时，输入法会展示出如下👇的候选项效果：
这个效果是如何出来的呢？ 我们在 rime中州韵小狼毫 自定义词典 一文中介绍过 自定义词典，所以最直观的解决方案是，我们在用户词典中加入对应的自定义词条，然后 重新部署 即可。
这个想法是正确的，如果在我们的自定义词典 （此处以 Custom_phrase.txt 为例）加入以下👇自定义词条，亦可现实同样的效果：
lua version: Lua 5.4	help 特殊符号--&gt;/help	help latexLetters--&gt;uzalph	help 但是，本文并不打算对比在实现同样效果时，自定义词典和lua脚本两种方案孰优孰劣，仅为讲解如何通过lua脚本的方案在Rime中州韵/小狼毫输入法中如何实现这个help的效果。
Translator 在Rime输入法中，有两个概念非常重要，一个是Translator， 一个是Filter。
在👆上图中，展示了Rime输入法中的Translator和Filter的大致工作流程：Rime引擎捕捉到用户的键盘输入字符 ddfb，然后经过一些重要的前端处理（前端处理部分上图没有画出）后，进入Translator中处理，Translator将字符 ddfb 翻译成词条 大地。然后把Translator生成的候选词送入Filter中处理，Filter对Translator生成的候选词逐一进行处理，丰富了候选词的信息（在上图的例子中，为候选词大地进行了注音），同时增加了一个新的候选词母亲。经Filter处理完成后的候选词，以及Filter生成的新的候选词，做为最终的候选词选项提供给用户进行选择使用。
本文中，我们将重点讲解如何定义一个Translator处理器。
help.lua 一般来说，根据你需要实现的功能，我们为我们的lua脚本拟定一个名字，今天我们所要实现的功能是实现 help 候选项，所以我们把我们的lua脚本命名为 help.lua。
👇如下，我们的help.lua脚本，应该放置于 用户文件夹 下的 lua 子文件夹内，所以如果你的 用户文件夹 内没有 lua 文件夹，请创建 lua 文件夹，然后将你的 help.lua 文档放在此 lua 文件夹内。
在help.lua脚本内，以下的脚本结构中，我们定义了一个函数/方法，这个方法名为 translator（名称不限，也可以是其它的名字），这个 translator 方法内部定义了具体的 translator 逻辑。在脚本的最后一行，我们通过 return 关键字抛出了translator方法。这样我们就可以在rime引擎中调用该translator方法实现具体的处理逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b858ec8d78ee8dc393547b77db1fb25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02ab7d46cfed1365caf47ca73dd58a0/" rel="bookmark">
			[足式机器人]Part2 Dr. CAN学习笔记-动态系统建模与分析 Ch02-1&#43;2课程介绍&#43;电路系统建模、基尔霍夫定律
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文参考：
B站：DR_CAN
Dr. CAN学习笔记-动态系统建模与分析 Ch02-1+2课程介绍+电路系统建模、基尔霍夫定律 1. 课程介绍2. 电路系统建模、基尔霍夫定律 1. 课程介绍 2. 电路系统建模、基尔霍夫定律 基本元件：
电量 库伦（ C C C） q q q
电流 安培（ A A A） i i i —— i = d e d t i=\frac{\mathrm{d}e}{\mathrm{d}t} i=dtde​ 流速
电压 伏特（ V V V） e e e
电阻 欧姆（ Ω \varOmega Ω） R R R —— e R = i R e_{\mathrm{R}}=iR eR​=iR
电容 法拉（ F F F） C C C —— q = C e C , e C = 1 C q = 1 C ∫ 0 t i d t q=Ce_{\mathrm{C}},e_{\mathrm{C}}=\frac{1}{C}q=\frac{1}{C}\int_0^t{i}\mathrm{d}t q=CeC​,eC​=C1​q=C1​∫0t​idt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a02ab7d46cfed1365caf47ca73dd58a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ae897791cde5fdc30fa025c9b487ec/" rel="bookmark">
			2024阿里云Alibaba Cloud Linux 3镜像版本大全说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Alibaba Cloud Linux阿里云打造的Linux服务器操作系统发行版，Alibaba Cloud Linux完全兼容完全兼容CentOS/RHEL生态和操作方式，目前已经推出Alibaba Cloud Linux 3，阿里云百科aliyunbaike.com分享Alibaba Cloud Linux 3版本特性说明：
Alibaba Cloud Linux 3镜像版本大全 目前Alibaba Cloud Linux 2版本停止支持日期到2024-03-31，所以阿里云百科建议选择Alibaba Cloud Linux 3。
Alibaba Cloud Linux 3.2104 64位 快速启动版 1、只对实例的初次启动加速，后续启动实例的速度会保持正常水准。
2、优化加速内存初始化的过程，模块化了启动耗时的鼠标等设备，加速内核引导速度。
3、使用最新的AliyunInit服务替代了CloudInit服务，降低了操作系统的初始化耗时。
4、该镜像的内核不支持修改。
5、不支持的实例规格族：GPU计算型、GPU虚拟化型、FPGA计算型、NPU计算型、异构服务型、超级计算集群（SCC）、安全增强型等。
Alibaba Cloud Linux 3.2104 LTS 64位 等保2.0三级版 基于x86架构默认标准镜像进行等保加固的镜像版本，该镜像符合等保2.0三级安全保护的基本要求。
Alibaba Cloud Linux 3.2104 64位 UEFI版 基于x86架构默认标准镜像开发，仅支持UEFI启动模式。
Alibaba Cloud Linux 3.2104 64位 ARM版 支持ARM架构的默认标准镜像。
Alibaba Cloud Linux 3.2104 64位 SCC版 基于x86架构默认标准镜像开发，支持阿里云SCC实例的镜像版本，仅支持UEFI启动模式。
更多请参考 Alibaba Cloud Linux 3镜像发布记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b7cd896846937488d3bed8aaae62e8/" rel="bookmark">
			刷算法-- leetcode 96. 不同的二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路 观察树的组成，可以发现n=3时的二叉搜索树可以由，头节点分别为1、2、3时的所有结果组成！定义dp[i]为由i个节点组成的二叉搜索树的个数。确定递推公式，dp[i] = 由1为头节点组成的二叉搜索树个数+由2为头组成的个数+…+由i为头节点组成的个数。
所以，进一步分析： 由1为头节点组成的二叉搜索树个数=左子树个数为0时搜索树个数*右子树节点数为2时的搜索树个数.由2为头节点时组成的搜索树个数=左子树包含1个节点是的搜索树个数*右子树包含1个节点数时的搜索树个数由3为头节点时组成的搜索树个数=左子树包含2个节点是的搜索树个数*右子树包含0个节点数时的搜索树个数
节点数量为2时的搜索树个数=dp[2]
节点数量为1时的搜索树个数=dp[1] 所以，dp[3] = dp[0]*dp[2] + dp[1]*dp[1] + dp[2]*dp[0];可以看出上述公式是一种交错的关系。使用双重循环去递推。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78be963273cd540d905d247d9bacb659/" rel="bookmark">
			python股票分析挖掘预测技术指标知识大全之量价指标详解(5)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人股市多年的老韭菜，各种股票分析书籍，技术指标书籍阅历无数，萌发想法，何不自己开发个股票预测分析软件，选择python因为够强大，它提供了很多高效便捷的数据分析工具包。
我们已经初步的接触与学习其中数据分析中常见的3大利器---Numpy,Pandas，Matplotlib库。
也简单介绍一下数据获取的二种方法，通过金融数据接口和爬虫获取。
介绍了指标之王MACD，随机指标KDJ和BOLL指标线的详细用法
这一章我们学习一下量价指标，如果有人问我所有指标哪个最值得学习，我首推的就是这个量价指标，股市上所有的都可能骗人，除了成交量，通过成交量的突然放大等异常走势，我们最有可能判断主力的下一步动作。
量价指标详解 (1)量价指标解释 量价关系，是股票里所有指标中最重要、最核心，最为有用的指标。股票软件上的指标，大部分就是通过统计学的方法，由量价关系演变而来。很多炒股多年的股友会告诉你，学炒股其实只要学量价关系就够了。
那么，量价关系到底是什么呢？接下来，会将其中的逻辑关系详细分析，只要你懂了其中的逻辑，再回到股票K线本身上，基本就可以做到完美的技术面分析了。
量价关系中，量就是指成交量，价就是指股票的价格（大盘量价，量一般指成交额）。经济学里面讲过，商品的价格大部分是由供给与需求决定的，股票本身有买卖，也可以作为一种特殊的商品。卖方便是供给方，卖方则是需求方，当供大于求的时候，价格将是下跌的，股票自然也是下跌；当供不应求的时候，因为买方需求意愿比较大，商品不足时，为了能获得商品，买方愿意支付更高的价格购买商品，也就推动了商品的价格上涨，所以此时的股价也是上涨的。
(2)量价指标计算 在Python中，你可以使用pandas库来处理数据并计算量价指标。以下是计算量价指标的一些常见公式：
成交量：成交量 = V平均每笔成交金额：平均每笔成交金额 = V / P量比：量比 = V / V(-1)均量线：均量线 = (V + V(-1)) / 2量升价跌：量升价跌 = V - P量缩价跌：量缩价跌 = V / P量缩价升：量缩价升 = V / P量增价跌：量增价跌 = V - P量增价升：量增价升 = V / P量减价跌：量减价跌 = V - P 其中，V表示成交量，P表示收盘价，V(-1)表示前一交易日的成交量。
以下是一个使用pandas计算量价指标的示例代码：
import pandas as pd # 读取数据 data = pd.read_csv('000271.csv') # 获取成交量数据和收盘价数据 volume = data['Volume'] close = data['Close'] # 计算量比指标 volume_ratio = volume / volume.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78be963273cd540d905d247d9bacb659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad4f250376283fcd563019dd02fbefd/" rel="bookmark">
			阿里云Alibaba Cloud Linux 2镜像操作系统版本大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Alibaba Cloud Linux阿里云打造的Linux服务器操作系统发行版，Alibaba Cloud Linux完全兼容完全兼容CentOS/RHEL生态和操作方式，目前已经推出Alibaba Cloud Linux 3，阿里云百科aliyunbaike.com分享Alibaba Cloud Linux 2版本特性说明：
Alibaba Cloud Linux 2 Alibaba Cloud Linux 2停止支持日期到2024-03-31，建议选择Alibaba Cloud Linux 3。
Alibaba Cloud Linux 2.1903 LTS 64位 支持x86架构的默认标准镜像。
Alibaba Cloud Linux 2.1903 LTS 64位 快速启动版 该镜像支持Qboot（quick boot）快速启动，基于Alibaba Cloud Kernel，并直接从内核引导虚拟机启动的定制化镜像。使用该镜像创建的ECS实例相比其他镜像创建的ECS实例，启动速度得到了极大的提升，并且默认运行时与标准镜像完全一致。快速启动版镜像的相关说明如下：
1、只对实例的初次启动加速，后续启动实例的速度会保持正常水准。
2、优化加速内存初始化的过程，模块化了启动耗时的鼠标等设备，加速内核引导速度。
3、使用最新的AliyunInit服务替代了CloudInit服务，降低了操作系统的初始化耗时。
4、该镜像的内核不支持修改。
5、不支持的实例规格族：GPU计算型、GPU虚拟化型、FPGA计算型、NPU计算型、异构服务型、超级计算集群（SCC）、安全增强型等。
Alibaba Cloud Linux 2.1903 LTS 64位 等保2.0三级版 基于x86架构默认标准镜像进行等保加固的镜像版本，该镜像符合等保2.0三级安全保护的基本要求。
Alibaba Cloud Linux 2.1903 LTS 64位 UEFI版 基于x86架构默认标准镜像开发，仅支持UEFI启动模式。
Alibaba Cloud Linux 2.1903 64位 可信版 基于x86架构默认标准镜像开发，支持阿里云可信实例的镜像版本。
Alibaba Cloud Linux 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad4f250376283fcd563019dd02fbefd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90fc003db952aa1cc7dcc411216d26d8/" rel="bookmark">
			阿里云Alibaba Cloud Linux 3镜像版本清单2024更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Alibaba Cloud Linux阿里云打造的Linux服务器操作系统发行版，Alibaba Cloud Linux完全兼容完全兼容CentOS/RHEL生态和操作方式，目前已经推出Alibaba Cloud Linux 3，阿里云百科aliyunbaike.com分享Alibaba Cloud Linux 3版本特性说明：
Alibaba Cloud Linux 3镜像版本大全 目前Alibaba Cloud Linux 2版本停止支持日期到2024-03-31，所以阿里云百科建议选择Alibaba Cloud Linux 3。
Alibaba Cloud Linux 3.2104 64位 快速启动版 1、只对实例的初次启动加速，后续启动实例的速度会保持正常水准。
2、优化加速内存初始化的过程，模块化了启动耗时的鼠标等设备，加速内核引导速度。
3、使用最新的AliyunInit服务替代了CloudInit服务，降低了操作系统的初始化耗时。
4、该镜像的内核不支持修改。
5、不支持的实例规格族：GPU计算型、GPU虚拟化型、FPGA计算型、NPU计算型、异构服务型、超级计算集群（SCC）、安全增强型等。
Alibaba Cloud Linux 3.2104 LTS 64位 等保2.0三级版 基于x86架构默认标准镜像进行等保加固的镜像版本，该镜像符合等保2.0三级安全保护的基本要求。
Alibaba Cloud Linux 3.2104 64位 UEFI版 基于x86架构默认标准镜像开发，仅支持UEFI启动模式。
Alibaba Cloud Linux 3.2104 64位 ARM版 支持ARM架构的默认标准镜像。
Alibaba Cloud Linux 3.2104 64位 SCC版 基于x86架构默认标准镜像开发，支持阿里云SCC实例的镜像版本，仅支持UEFI启动模式。
更多请参考 Alibaba Cloud Linux 3镜像发布记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9b4834505e68fc2bcbcfc38b90c1e0/" rel="bookmark">
			【LeetCode】1047. 删除字符串中的所有相邻重复项(StringBuffer简单用法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日学习的文章链接和视频链接 leetcode题目地址：1047. 删除字符串中的所有相邻重复项
代码随想录题解地址：代码随想录
题目简介 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
在 S 上反复执行重复项删除操作，直到无法继续删除。
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
看到题目的第一想法(可以贴代码） 1. 利用Stack栈类，push每个元素之前先判定它和前一个元素（此时栈里的peek元素）是否一致，若一致则一起删除，否在push入栈。
public String removeDuplicates(String s) { Stack&lt;Character&gt; q = new Stack&lt;&gt;(); for (char i : s.toCharArray()){ if (q.empty() || q.peek() != i){ q.push(i); }else { q.pop(); } } String res = ""; for (Character i : q){ res += i; } return res; } 实现过程中遇到哪些困难 无，就是时间复杂度和空间复杂度较大。
看完代码随想录之后的想法 【解题思路】直接用一个字符串去模拟栈的行为，可以省略一个栈到字符串类型的转换步骤。
看完视频自己写的ACC： public String removeDuplicates(String s) { String q = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9b4834505e68fc2bcbcfc38b90c1e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f61c57177f42cbe2f8ac1f90d9e9fd/" rel="bookmark">
			如何在群晖7.2中运行WPS Office镜像容器并使用固定地址公网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 拉取WPS Office镜像2. 运行WPS Office镜像容器3. 本地访问WPS Office4. 群晖安装Cpolar5. 配置WPS Office远程地址6. 远程访问WPS Office小结 7. 固定公网地址 wps-office是一个在Linux服务器上部署WPS Office的镜像。它基于WPS Office的Linux版本，通过Docker容器化的方式提供了一个完整的WPS Office环境，使得用户可以在Linux服务器上轻松地使用WPS Office进行文档处理、表格制作和幻灯片演示等操作。 Cpolar内网穿透是一种安全的内网穿透云服务，可以将内网下的本地服务器通过安全隧道暴露至公网，使得公网用户可以正常访问内网服务。它支持HTTP、HTTPS、TCP协议端口映射。
下面介绍群晖7.2版本中使用Docker部署WPS Office并结合Cpolar内网穿透实现远程访,更方便使用本地WPS Office进行文档处理、表格制作和幻灯片演示等操作.
1. 拉取WPS Office镜像 本例群晖版本由于无法直接在群晖控制面板界面搜索容器,所以采用命令行方式进行容器下载,首先开启群晖ssh连接,然后使用工具通过ssh连接上群晖,执行下面docker 拉取镜像容器:linuxserver/wps-office
sudo docker pull linuxserver/wps-office 拉取后我们在群晖容器管理界面可以看到拉取的wps镜像,获取wps镜像就完成了,下面进行运行启动
2. 运行WPS Office镜像容器 选择镜像,点击运行,然后进入设置界面,开始进行设置
设置一个名称,然后选择下一步,如需要自启动,勾选自动重新启动按钮即可.
然后设置挂载的端口,默认和容器内部端口即可,然后点击下一步
然后点击完成即可
打开容器列表,可以看到运行的wps容器,下面进行本地访问
3. 本地访问WPS Office 容器运行后,在浏览器输入群晖局域网IP加3000端口,即可看到wps office 界面啦,本地部署,运行,访问就完成了,下面我们安装cpolar内网穿透工具,实现无公网IP也可以实现远程访问!
4. 群晖安装Cpolar 点击下面Cpolar群晖套件下载地址,下载相应版本的群晖Cpolar套件
https://www.cpolar.com/synology-cpolar-suite,
打开套件中心，点击右上角的手动安装按钮。
选择我们本地下载好的cpolar安装包。
点击下一步按钮
点击同意按钮,然后点击下一步
最后点击完成即可。
安装完成后,在外部浏览器,我们通过群晖的局域网ip地址加9200端口访问Cpolar的Web管理界面,然后输入Cpolar邮箱账号与密码进行登录
5. 配置WPS Office远程地址 点击左侧仪表盘的隧道管理——创建隧道，创建一个wps office的公网地址隧道!
隧道名称：可自定义命名，注意不要与已有的隧道名称重复协议：选择http本地地址：3000(运行容器时设置的端口)域名类型：免费选择随机域名地区：选择China 点击创建
隧道创建成功后，点击左侧的状态——在线隧道列表,查看所生成的公网访问地址，有两种访问方式,一种是http 和https,因为我们设置的是3000端口,该端口是http访问端口,所以我们只需要关注http公网地址即可.
6. 远程访问WPS Office 使用上面的Cpolar http公网地址,在任意设备的浏览器进行访问,即可成功看到wps office界面,这样一个公网地址且可以远程访问就创建好了,使用了cpolar的公网域名,无需自己购买云服务器,即可发布到公网进行远程访问 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15f61c57177f42cbe2f8ac1f90d9e9fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc97c9e660996dc783379661c1efba06/" rel="bookmark">
			MySQL中的NULL值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NULL值的含义 在MySQL中，NULL是一个特殊值，表示字段没有数据。当一列被定义为可包含NULL时（即没有设置NOT NULL约束），确切的存储需求取决于使用的存储引擎和行格式。
对于大多数存储引擎（例如InnoDB），NULL值通常不会存储任何实际的数据，但每个可为NULL的列都需要一些额外的空间来记录其NULL状态。这通常是通过NULL位图来完成的，即在表的每一行内部都有一个位图，每个可为NULL的列由该位图中的一个位来表示。如果列的值为NULL，则相应的位被置为1（或者根据具体实现可能是0）；如果列有值，则置为另一个值。
InnoDB存储引擎：在InnoDB里，与NULL相关的开销主要是行记录中的NULL位图。例如，如果您有8个可为NULL的列，那么至少需要1个字节来存储这些列的NULL标志位，不管这些列是否实际包含NULL值。MyISAM存储引擎：MyISAM使用不同的数据组织方式，但也同样会有用于存储NULL状态的位图。 NULL值的查询和比较 在SQL中，NULL值在与任何其他值进行比较时永远不会返回真值，即使是与NULL本身比较也如此。包含NULL的表达式总会得出NULL值，除非特定操作符和函数的文档中有其他说明。例如，在下面的查询中所有列都会返回NULL：
mysql&gt; SELECT NULL, 1+NULL, CONCAT('Invisible',NULL); 搜索列值中的NULL，不能使用expr = NULL的方式查询。以下语句不会返回任何行，因为expr = NULL对于任何表达式来说都不会为真；
mysql&gt; SELECT * FROM my_table WHERE phone = NULL; 要查询NULL值，必须使用IS NULL。下面的语句展示了如何找到NULL的电话号码和空的电话号码：
mysql&gt; SELECT * FROM my_table WHERE phone IS NULL; mysql&gt; SELECT * FROM my_table WHERE phone = ''; 在进行数学比较时，不能使用=, &lt;, 或 &lt;&gt;等算术比较运算符来和NULL值比较。比较结果均是null值，例如：
mysql&gt; SELECT 1 = NULL, 1 &lt;&gt; NULL, 1 &lt; NULL, 1 &gt; NULL; +----------+-----------+----------+----------+ | 1 = NULL | 1 &lt;&gt; NULL | 1 &lt; NULL | 1 &gt; NULL | +----------+-----------+----------+----------+ | NULL | NULL | NULL | NULL | +----------+-----------+----------+----------+ 在SQL中，NULL永远不会在比较中返回true，即使与NULL自身比较也不例外。所有包含NULL的表达式都将产生NULL值，除非文档中对涉及的操作符和函数有特别说明。例如，聚合函数（如COUNT()、MIN()和SUM()）在计算时会忽略NULL值，只有COUNT(*)则会统计包括那些具有NULL值的行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc97c9e660996dc783379661c1efba06/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/11/">«</a>
	<span class="pagination__item pagination__item--current">12/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/13/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>