<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e341a3b6a6387d09451abd4e626f1e4c/" rel="bookmark">
			FPGA积沙成塔（目录篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：为了让您快速找到对您感兴趣的文章，可以通过目录快速查找，节省时间，加油！
1 FPGA积沙成塔目录
1）基于FPGA实现USB2.0接口方案设计
2）基于FPGA实现ADC7768数据采集系统设计（8路）
3）基于Xilinx FPGA实现PCIE2.0接口
4）关于FPGA核心bug解决
5）基于FPGA实现DDS正弦波发生器
6）基于xilinx FPGA实现LZW压缩算法
7）待更新。。。
2 结束语
希望对你有帮助，如果遇到问题，可以一起沟通讨论，邮箱：jhqwy888@163.com。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298d0787b6c9964991eadd04cb79a6e4/" rel="bookmark">
			脑机接口基础学习08----读取.edf文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EDF，全称是Eurpean Data Format，是一种标准文件格式，用于交换和存储医疗时间序列，该格式文件能够存储多通道的数据，允许每个信号拥有不同的采样频率，在内部，它包括标题和一个或多个数据记录。标题包含一些一般信息（患者标识，开始时间…等等），以及每个信号的技术规格（校准，采样率，过滤，…等等），编码为ASCII字符。数据记录包含小端16位整数的样本。因此，EDF也是多导睡眠图（PSG）录音的流行格式
在Python中读取edf文件，可以通过mne来实现
#方法原型： ''' mne.io.read_raw_edf(input_fname, montage='deprecated', eog=None, misc=None, stim_channel='auto', exclude=(), preload=False, verbose=None) 参数解读： input_fname:edf文件存放地址 montage=‘deprecated’:已弃用 eog：通道名称或应指定为EOG通道的索引列表。值对应于文件中的电极。默认为无 misc：通道名称或应指定为MISC通道的索引列表。值对应于文件中的电极。默认为无。 stim_channel：默认为'auto'，这意味着将名为‘status’或‘trigger’（不区分大小写）的通道设置为STIM 如果为str（或str列表），则所有与名称匹配的通道均设置为STIM 如果为int（或int列表），则将对应于索引的通道设置为STIM exclude：要排除的通道名称。这在读取具有不同采样率的数据时会有所帮助，以避免不必要的重采样。 preload：如果为True，则数据将被预加载到内存中（这样可以加快数据的索引） 如果preload是字符串，则该字符串为数据存放在硬盘中的路径地址（速度较慢，需要较少的内存） 来看一个实例
###1.导入工具包 from mne.io import concatenate_raws,read_raw_edf import matplotlib.pyplot as plt import mne ###2.加载本地edf文件 raw=read_raw_edf("Affaf Ikram 20121020 1839.L1.edf",preload=False) ###3.获取原始数据中事件 #查看原始edf文件中保存的event id以及events events_from_annot,event_dict=mne.events_from_annotations(raw) print(event_dict) print(events_from_annot) 由上图可以发现，事件ID有1，2，3，4，5，6
每个ID对应着注释：[‘TRSP’,‘bgin’,‘fix+’,‘resp’,‘stm+’,‘stm-’]
共有517个事件
###4.根据事件ID获取对应事件 #下面只选取事件ID为5和6的所对应的事件 custom_mapping={'stm+':5,'stm-':6} (events_from_annot, event_dict)=mne.events_from_annotations(raw,event_id=custom_mapping) print(event_id) print(events_from_annot) ###5.绘制事件图 fig=mne.viz.plot_events(events_from_annot,sfreq=raw.info['sfreq'], first_samp=raw.first_samp,event_id=event_dict) subplots_adjust(right=0.7) epochs=mne.Epochs(raw,events=events_from_annot, event_id=event_dict) epochs.plot_image() ''' 获取采样频率sfreq 知识点： 采样频率，也称为采样速度或采样率，定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。 采样频率的倒数是采样周期或者叫作采样时间，它是采样之间的时间间隔。 通俗的讲采样频率是指计算机每秒钟采集多少个信号样本。 ''' #sfreq=raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/298d0787b6c9964991eadd04cb79a6e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d62c71b81156ee5c0cf5c9fd4ea67a/" rel="bookmark">
			可以轻松将手机投屏到Mac电脑的工具：Reflector 3 mac版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reflector 3 for Mac是一款可以将您的iOS设备AirPlay连接到Mac的工具，轻松在Mac上iOS应用程序和游戏，另外reflector for mac还能进行屏幕录制哦！有兴趣的朋友赶紧来试试吧！
Reflector 3 for Mac软件介绍
Reflector将Mac，Windows和Android设备转换为AirPlay，Google Cast或Miracast接收器。使用Reflector在更大的屏幕上无线显示和录制iPhone，iPad，Chromebook，Android设备和Windows平板电脑。
Reflector for mac功能特点
- 屏幕镜像
将任何类型的一个或多个设备无线镜像到您的计算机。
- 记录
记录任何镜像设备。添加配音音频并在需要时自定义录制。
- 设备控制
强调，隐藏或显示设备，并从一个中心位置选择设备帧。
- 安全
防止不必要的连接，并限制只有那些应该镜像的用户。
- 流
将家庭视频或电影流到Reflector 3，或在更大的屏幕上共享照片。
- AirPlay
Reflector可以接收来自Mac，iPad，iPhone和iPod touch的镜像连接。
- Miracast
将带有内置Miracast的Windows设备连接到Reflector3.仅与Windows兼容Reflector 3。
- Google Cast
Reflector轻松接收Chromebook和Android屏幕镜像和流媒体连接。
- 仅音频流式传输
反射器可以充当纯音频接收器。将您最喜爱的音乐流到连接到较大扬声器的电脑上。
- 连接多个设备
内置AirPlay，Google Cast或Miracast的设备可以同时连接到Reflector 3。
- 设备框架
选择设备框架可使镜像屏幕看起来像您的真实设备，或选择其他框架来测试新外观。
- 全屏模式
消除来自其他应用程序或桌面项目的干扰，并选择背景颜色或图像以配合镜像屏幕。
- 与AirParrot兼容
将AirParrot添加到您的设备并连接到Reflector 3以获得更高级的屏幕镜像选项。
- 连接提示
在屏幕上显示之前选择允许或拒绝设备连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54bbaa3e029c9d582d510d178a82c8a/" rel="bookmark">
			c# .net core 开源库整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.NET Core源码 https://github.com/dotnet/aspnetcore
NET Core源码必须首荐！
1.Masuit.Tools https://github.com/XiLife-OSPC/Masuit.Tools
包含一些常用的操作类，大都是静态类，加密解密，反射操作，硬件信息，字符串扩展方法，日期时间扩展操作，大文件拷贝，图像裁剪，验证码等常用封装。
包含一些常用的操作类，大都是静态类，加密解密，反射操作，动态编译，权重随机筛选算法，简繁转换，分布式短id，表达式树，linq扩展，文件压缩，多线程下载和FTP客户端，硬件信息，字符串扩展方法，日期时间扩展操作，中国农历，大文件拷贝，图像裁剪，验证码，断点续传，实体映射、集合扩展等常用封装
2.OrchardCore https://github.com/OrchardCMS/OrchardCore/tree/dev/src
Orchard Core Framework：一个用于在http://ASP.NET Core上构建模块化，多租户应用程序的应用程序框架。Orchard Core CMS：基于Orchard Core框架构建的Web内容管理系统（CMS） 3.Fur https://github.com/monksoul/Fur
https://gitee.com/monksoul/Fur
4.awesome-dotnet-core https://github.com/jasonhua95/awesome-dotnet-core
库、工具、框架、模板引擎、身份认证、数据库、ORM框架、图片处理、文本处理、机器学习、日志、代码分析、教程等。归纳的门类比较齐全.
5. ZKEACMS https://github.com/SeriaWei/ZKEACMS
纸壳CMS（ZKEACMS）是ZKEASOFT自主研发的，开源的免费的建站系统，您可以直接使用它来做为您的企业网站，门户网站或者个人网站，博客，或用它做二次定制开发以满足您特定的需求。
6.YiShaAdmin https://github.com/liukuo362573/YiShaAdmin
采用Bootstrap + http://ASP.NET Core + Entity Framework Core基础架构。
开发文档相对比较健全 https://yishasoft.com/doc/
项目演示地址 https://yishasoft.com/admin/
7.Util应用框架 常用公共操作类(工具类)、分层架构基类、Ui组件，第三方组件封装，第三方业务接口封装，配套代码生成模板，权限等组成。
https://github.com/dotnetcore/Util
8.eShopOnContainer 基于.NET Core+微服务+Docker,电商平台.
https://github.com/dotnet-architecture/eShopOnContainers 9.SharpCompress 用于.NET Standard 2.0、2.1和NET 4.6的纯C＃文件压缩操作库，支持unrar, un7zip, unzip, untar unbzip2, ungzip, unlzip，并且具有只读读取和文件随机访问API。 实现了对zip / tar / bzip2 / gzip / lzip的写支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54bbaa3e029c9d582d510d178a82c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59fe834f11e6bc8f5a4c63d159fd1919/" rel="bookmark">
			switch手柄可以连电脑吗_一款手柄能让手机玩 switch游戏？你敢想象吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一个喜欢玩游戏的人来说，手柄是必不可少的，一个手柄的好坏直接影响到游戏体验质量，而今天我就来评测一下最近比较热门的一款手柄，为什么说它热门呢？因为这款手柄可以通过蛋蛋模拟器，让手机秒变switch！看到这想必大家都知道是什么了，没错，它就是盖世小鸡X2电竞手柄，接下来让我们来看看这款手柄整体体验到底如何吧。
—开箱— 小鸡X2的外包装采用红灰撞色的包装设计，包装正面红色烫金的GAMESIR的logo，拥有相当浓厚的游戏竞技外设的感觉。
而右下角的OTG标志，表明了这是一款直连零延迟手柄。
包装的侧面则用中日英三语标注了该手柄的一些设计美学。
背面同样是用中日英三语，标注了手柄的详细信息。
打开盒子之后，首先看到的是一个夹层，上面有一句话： “即将进入游戏世界...”
颇具仪式感，还是能看到设计用心的。
将这个夹层拿掉之后，就可以看到手柄本体了。
随机还赠送了一张酷炫的贴纸，其他配件还有感谢卡、说明书保修卡，没有配备type-c数据线。
—手柄外观— 手柄的外观相对于直连拉伸手柄来说还算是好看的，笔者手上的这款是黑白配色的，整体给人的感觉比较素雅，键位和switch保持一致。摇杆采用了红蓝配色，switch那味就更重了。
并且配备了一键截屏功能，游戏过程中可以一键保存精彩瞬间，如果后期能添加譬如长按录屏的话，会更完美！
按键方面，官方宣称采用了电竞级微动按键，从笔者实际使用的感受来说，确实比普通的塑料软胶按键要手感要好些。
特别是L1、L2、R1、R2这些按键，手感比较像鼠标，哒哒的声音 非常好听。
缺点就是牺牲了多阶线性压感，玩赛车游戏的时候差点意思。
而摇杆方面采用的是PS4同级竞技摇杆，旋转起来也是很顺滑的，力度适中，没有磨边感，体验感比较出色。
手柄背面采用的是双色注塑工艺，黑色部分是软胶材质的，比较亲肤，握持感不错。
手柄采用的是二段拉伸，最大支持168mm长的手机。
笔者使用的是小米10，屏幕为6.67英寸，完美使用。
拉伸部分，刚好为突出的摄像头留出了位置。这种镂空的设计，在一定程度上也利于散热。
并且预留了type-c接口，给手机充电，此接口支持PD快充 ，让手机迅速回血。
比较有意思的就是这个type-c活动插口了，据说这个是盖世小鸡的独家专利，就插拔体验来说还是蛮好的，有一定的摆动幅度，也不会担心弄坏插口。
—手柄体验— 不得不说，盖世小鸡X2手柄配上小鸡模拟器自动匹配按键，对于笔者喜欢玩怀旧和街机游戏的来说，免去了不少设置按钮的步骤。
由于是零延迟 ，操作上非常贴手，而且手机供电，不必担心手柄断电，比蓝牙手柄的体验要好很多。特别是玩一些打斗类游戏，拳拳到肉的感觉非常爽。
值得一提的是这款手柄还支持云游戏，在手机上串流玩PC 版电脑游戏大作！或者下载客户端如格来云等，来玩云端游戏都是原生支持的。
同时还支持G-touch功能，不过需要下载小鸡游戏世界，升级固件进行开启，通过小鸡游戏世界可以通过手柄愉快地玩耍农药、吃鸡、原神等手游了。
笔者实测原神，感觉还是不错的，只是玩射手的时候没办法对准射击，只能用回触屏，玩其他角色还是OK的。
同理在玩吃鸡游戏和农药游戏也是如此。
但是玩火影忍者之类的游戏就比较爽了，可以说是完美！
最后来说说EGG NS Emulator(蛋蛋模拟器)，据悉该模拟器是由美国工作室制作潜心2年研发，而这款蛋蛋模拟器的兼容手柄只有一款，就是我手上拿的这个X2。笔者是支持正版游戏的，但也好奇这款模拟器能不能流畅跑起switch游戏，我决定尝试下。
不过在测试的过程中，笔者发现，由于这款模拟器还在研发阶段，运行游戏的时候非常吃内存。笔者手上的设备是8+256G的小米10，可用运行内存约4G，所以体验上并不是特别好，可能换上大内存的手机或者原生安卓的手机体验可能会更好一些。
实测，在测试《失落的骑士》的时候，由于画面简单，除了部分过场动画无法显示之外，基本全程60帧，完美运行。
而在测试一些大型游戏的时候，如《暗黑破坏神3》，也能始终保持30~40帧，玩起来还是非常流畅的。可以说能完美模拟switch进行游玩了。
不过笔者测试其他游戏的时候，发现还是会出现一些掉帧的现象，如笔者在玩《超级马力欧 奥德赛》的时候，由于场景比较复杂，平均只有20帧左右，似乎蛋蛋模拟器对此款游戏没有做到很好的优化。
同样的，笔者在测试《宝可梦剑盾》的时候也是会感觉掉帧 ，大部分场景都能保持20帧左右，遇到复杂的对战场面，会掉帧到10~15帧。
而据官网介绍，模拟器仍在优化中，相信后续会有可能会解决占用内存过大和掉帧的问题，目前该蛋蛋模拟器已支持100多款Switch游戏，不过笔者还是要说，有条件的请支持正版。
—总结— 就实际体验了一周之后，能明显得感觉到，比起手机游戏搓屏操控体验来说，盖世小鸡X2的游玩体验确实会更好一些，而且各方面都表现还不错，按键响应速度快，摇杆顺滑，握持手感舒适。而且还可以配合蛋蛋模拟器，体验一下Switch游戏，对于喜欢玩游戏的人来说确实是一个不错的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8ab83a022f345584a01478cffbcd4c/" rel="bookmark">
			路由器重温——WAN接入/互联-DCC配置管理1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由器主要用于WAN接入与互联，必须学习和掌握路由器的WAN接入与互联配置方法。
在路由器的WAN接入与互联中主要包括两大类：一是专线方式的接入或互联，一种是按需拨号方式，这种方式不是永久连接的。专线接入方式只需配置好链路两端的对应物理接口即可，按需拨号方式还需要配置拨号接口属性和相应的链路层协议（包括协议封装、认证和协议参数等）。
广域网接入/互联概述
广域网接入/互联指通过接入广域网线路（主要指Internet线路）如Modem、ISDN、ADSL、VDSL、G.SHDSL等有线拨号或者专线线路（如E1\T1线路），以及像3G无线接入线路，或者通过专门的广域网络（如SONET/SDH传输网、EPON/GPON传输网等），实现远程设备或者网络间的广域网接入和互联。
专线接入型：E1、T1、光纤专线接入的CE1/PRI、E1-F、CT1/PRI、T1-F、POS、CPOS、PON等接口。
按需拨号型：除了配置好对应的WAN接口，还需要配置拨号接口和账户属性。
华为AR G3系列路由器中，各种拨号服务采用的是DCC（Dial Control Center，拨号控制中心）集中管理方式。
各种按需拨号方式的总体配置任务包括如下两个方面：
1）配置各种拨号服务所对应的WAN接口，就是前面介绍的各WAN接口配置。
2）（可选）配置DCC
DCC的作用就是配置各种拨号服务所需的拨号接口及其账户和链路属性。拨号属性和拨号接口也可在特定的拨号接入方式下配置，只不过此时他没有DCC中的一些特定功能，如轮询拨号、多物理线路共享拨号属性、动态线路备份等
3）（可选）配置各种WAN接口链路所封装的链路层协议
在广域网接入/互联中，各种WAN拨号接口所封装的链路层协议主要有PPP、MP（多PPP）和PPPoE这三种点对点协议。因为串行链路都有缺省的链路协议封装和参数配置，所以仅需根据实际需要选择配置。
DCC基础
DCC（拨号控制中心）是指路由器之间通过ISDN网络、xDSL网络、3G网络、PSTN网络等进行互联，或者路由器作为PPPoE/PPPoEoA/PPPoA客户端与PPPoE/PPPoEoA/PPPoA服务器之间互联时采用的技术，主要提供按需拨号服务。
DCC概述
采用仅在有数据传送时才建立连接并通信的方式是最经济的一种接入方式，称为“按需拨号”。所谓按需拨号是指跨ISDN网络、3G网络、PSTN网络等相连的路由器之间，或者路由器作为PPPoE/PPPoEoA/PPPoA客户端与PPPoE/PPPoEoA/PPPoA服务器（通常位于局端）之间不预先建立连接，当有数据需传送时才启动拨号流程，以拨号方式建立连接并传送信息。链路空闲时自动断开。DCC正是这样一种控制按需拨号的技术。
AR G3系列路由器支持两种DCC，即“轮询DCC”（Circular DCC，C-DCC）和“共享DCC”（Resource-Shared DCC，RS-DCC）。
轮询的意思是在本端多个接口需要向多个目的地址发起呼叫时，依据为各物理接口配置的优先级从高到低选择由哪个接口建立呼叫；而共享是指去往同一个目的网络的所有拨号呼叫使用同一个拨号属性集，无需为每个拨号的物理接口单独配置拨号参数。
DCC配置术语：
1）物理接口：实际存在的物理接口，如ISDN BRI、ISDN PRI、ADSL接口、VDSL接口、Cellular接口等
2）Dialer接口：是为了配置DCC参数而设置的逻辑接口，物理接口可通过绑定到Dialer接口而继承DCC配置信息。
3）拨号接口：是对拨号连接接口的泛称，可以是Dialer接口，也可以是捆绑到Dialer接口的物理接口，或者是直接配置DCC参数的物理接口。
两种DCC的拨号控制原理
1、轮询DCC
在轮询DCC和共享DCC中，物理接口与Dialer接口的对应关系是不一样的。轮询DCC中物理接口与Dialer接口的对应关系图：
1）一个Dialer接口中可以捆绑多个物理接口（如Dialer2），所有物理接口都继承同一个Dialer接口的属性；任意一个物理接口只能属于一个Dialer接口，即一个物理接口只能服务于一种拨号服务，或是说一个物理接口只提供一种拨号服务。物理接口可以不属于任何Dialer接口（如Serial2/0/1:15），而直接通过拨号路由（通过dialer route命令）方式映射到一个或多个目的地址。
2）一个Dialer接口可以通过配置多个拨号路由dialer route命令对应多个呼叫目的地址，也可以配置dialer number命令对应单个呼叫目的地址。
3）如果仅访问一个目的地址，则可直接在物理接口上配置DCC参数，但如果访问多个目的地址，必须要借助于拨号循环组（Dialer Circular Group）把对应物理接口绑定到Dialer接口来继承DCC参数。当然，仅访问一个目的地址时，也可通过拨号循环组把对应物理接口绑定到Dialer接口来继承DCC参数。
总结：如使用Dialer接口（单一目的地址时可不使用Dialer接口），同一物理接口仅能属于一个Dialer接口；每个Dialer接口可以包含多个物理接口，每个Dialer接口可以对应一个或多个目的地址。即轮询DCC中的物理接口与Dialer接口可以是一对一，或多对一关系，且一个Dialer接口可以配置一个或多个目的地址的拨号参数。适用于物理链路较多、连接情况复杂的大中型站点。
2、共享DCC
共享DCC中不同的Dialer接口可以实现共享同一个物理拨号链路，实现在不同的拨号中，同一个物理拨号链路使用不同的工作参数。物理链路工作参数的切换自动根据连接来决定。共享DCC主要适用可用物理链路较少，但连接需求较多的中小型站点。
共享DCC中的物理接口、Dialer bundle（拨号捆绑）与Dialer接口，由于实现了逻辑配置和物理配置的互相分离，共享DCC比轮询DCC简单灵活。
1）将物理接口的配置与呼叫的逻辑配置分开进行，再将两者动态的捆绑起来，从而可以实现相同物理接口为多种不同拨号应用服务的目的。
2）一个Dialer接口可以捆绑多个物理接口，同时任意一个物理接口也可属于多个Dialer接口，即一个物理接口可以提供多种拨号服务。使用共享属性值（RS-DCC set，包括Dialer接口、Dialer bundle和物理接口等参数）来描述拨号属性，去往同一个目的网络的所有拨号呼叫使用同一个共享属性集。
3）一个Dialer接口只能对应一个呼叫目的地址，因为是直接使用dialer number命令配置对应的单个呼叫目的地址，而不能使用拨号路由dialer route命令配置对应的多个呼叫目的地址。
4）在物理接口上不能直接配置共享DCC参数，物理接口必须通过绑定到dialer接口才能实现共享DCC拨号功能。
总结：在共享DCC方式下，同一物理接口可以属于多个Dialer捆绑，并进而服务于多个Dialer接口。每个Dialer接口只能使用一个Dialer捆绑，同时也只能设置一个目的地址。但同一个Dialer捆绑中的物理接口可以有不同的优先级，Dialer捆绑对应的Dialer接口可以根据优先级选择呼叫时使用的物理接口，相同的物理接口在不同的Dialer捆绑中可以有不同的优先级。
总体来说，向同一个目的地址进行拨号的物理接口可以形成一个捆绑，然后与唯一的一个Dialer接口对应；如果一个物理接口需要向多个目的地址进行拨号，则需要加入多个捆绑，并且要对应不同的Dialer接口，因为此时每个Dialer接口只能对应一个目的地址。
DCC的主要应用场景
两种场景：
1）以备份形式为主干线路通信提供保障：主干线路出现故障，提供替代辅助通路。一般是通过与现有网络不同的网络进行备份。支持通过接口备份实现和通过动态路由备份实现。
2）当路由器作为PPPoE/PPPoEoA/PPPoA客户端时，DCC通过按需拨号的功能为用户节省费用。
通过接口备份实现主干线路通信备份
Dialer1接口是拨号网络，用来备份物理接口GE1/0/0的主干线路，当GE1/0/0故障，接口上的所有流量会切换到与Dialer1接口绑定的PRI2/0/0:15接口上，此时流量会触发DCC拨号，实现使用ISDN网络备份主干线路目的。
通过动态路由备份实现主干线路通信备份
当RouterA到RouterB的10.10.10.1/24网段没有有效路由时，RouterA的Dialer1拨号接口会启动DCC拨号，从而实现用ISDN备份主干线路。
路由器作为PPPoE客户端时的按需拨号
在拨号连接已经建立的情况下，当PPPoE客户端到PPPoE服务器之间没有流量时，PPPoE客户端启用空闲时断开功能将连接断开，一旦客户端与服务器再有流量，会触发DCC拨号并建立连接。
如果路由器作为PPPoE/PPPoEoA/PPPoA客户端，组网时还需要通过DSLAM设备接入PPPoEoA/PPPoA服务器。用于此场景的DCC必须是共享DCC。
配置DCC前的准备
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8ab83a022f345584a01478cffbcd4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1704a575514c66d07c6700b9eacf0a/" rel="bookmark">
			秀米复制到公众号格式变了_微信制作案例课基础篇  登录秀米是用个人的微信登录？还是用新闻平台的订阅号同步登录？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方 蓝字关注我们
每堂3分钟，帮你解决1个新媒体问题。
今天，我为你梳理出了微信制作中的1个常见小问题，这个小问题我被(记者同事们)追问过至少5遍以上，没准这个不起眼的小操作就是你快速完成优质项目中的绊脚石哦~
真实场景
杜杜：我登录秀米编辑器，无法直接复制到公众号上，应该怎么操作？
亚亚：我一般用自己的手机号登录，操作很方便。
当我走进杜杜的桌前，按照平时的操作，无法直接复制。仔细一看，杜杜用的是其它同事的微信号，并且这个微信号绑定了一个新闻平台的订阅号，同时关联了秀米软件的同步功能(这一功能容易让刚接触秀米的小姐姐感到头晕眼花)。
当我选中秀米编辑器中的内容时，并没有出现直接复制粘贴的提示，如下图：
抛开其它复杂的流程，我们此次的目的是实现秀米中内容的复制，具体步骤如下：
第一步：登录秀米
我用的是自己手机号登录的秀米 【注】如果不登录也能操作，区别是排版样式会少很多。 第二步：输入内容后，点击“复制到微信公众号”即可
往期推荐
微信制作案例课•基础篇 ⑭ 图片太大无法插入，用美图秀秀“一键解决”
微信制作案例课•基础篇 ⑬ 秀米的“一键转载”怎么弄？
微信制作案例课•基础篇 ⑫ 请帮我开个白名单；白名单怎么开？
微信制作案例课•基础篇 ⑪ “视频号”的视频可以一键转发到公众号上吗？如果非要，怎么办？
微信制作案例课•基础篇 ⑩ 微信已发布文章到底能修改什么？
微信制作案例课•基础篇 ⑨ 长图中间的白断怎么消除？看起像一张整图
微信制作案例课•基础篇 ⑧ 把专家照片变“圆形框”，一键生成！
微信制作案例课•基础篇 ⑦ 微信的用户数量、阅读量怎么查？
微信制作案例课•基础篇 ⑥ 秀米圆形样式里的人头，太偏左啦！怎么调？
微信制作案例课•基础篇 ⑤ 连“壹伴”生成永久链接都不好使了，弄啥嘞？
微信制作案例课•基础篇④这个网址为什么无法加入超级链接？
微信制作案例课•基础篇③用秀米编辑完内容，怎么复制到公众号上？
微信制作案例课•基础篇②如何用“壹伴”小程序将一篇WORD“一键导入”微信？
微信制作案例课•基础篇①急死我了，永久链接
扫二维码
获取更多精彩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/363c548dc4e866d28918f0a366290cb5/" rel="bookmark">
			SSL和SSH有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多人对SSL和SSH感到困惑，这是可以理解的。两者都是安全协议，可以帮助保护从一个端点到另一端点的数据。此外，他们的名字有两个相似的字母，增加了歧义。但是SSH和SSL是两回事。如果您感到困惑，或者对选择哪种安全协议犹豫不决，本文将为您提供更好的理解并消除您的疑问。
SSL：Web安全的基础
SSL是一种在线安全协议，提供数据加密，从而确保访问者的连接是安全的。SSL的主要功能是：
1）数据加密
它的核心功能是维护服务器与客户端之间的通信。因此，它加密信息或数据的每一位，这些信息或数据只能由预期的接收者解锁。如果您的网站保存了敏感数据，例如ID，密码，付款信息等，则此SSL功能非常有用。
2）认证方式
SSL证书通过要求您进行身份验证过程来向您的网站提供身份验证。除非您完成彻底的验证过程，否则证书颁发机构将不会颁发SSL。因此，人们会信任您的网站。
SSH：一种确保远程通信安全的方法
SSH协议（安全外壳）是一种确保从一台计算机到另一台计算机的远程通信安全的方法。它提供强大的身份验证，同时通过加密确保通信和完整性。
此安全协议通常用于访问类Unix的操作系统。但是，您也可以在Microsoft Windows上使用它。SSH的主要功能是：
1）加密（SSH提供三种加密类型来保护通信安全）
对称加密：以这种加密形式，客户端和主机都在对消息进行加密和解密时使用秘密密钥。
非对称加密：在非对称加密中，使用两个单独的密钥进行加密和解密，称为公钥和私钥。这些密钥形成一个公共-私有密钥对。
散列：SSH还使用单向散列，这种形式的加密无法解密。每个输入都会生成一个固定长度的唯一值，该值没有明显的趋势，因此几乎不可能反转。
2）认证方式
SSH的另一个功能是提供身份验证。这些协议由三个不同的协议（即传输层，身份验证层和连接层）组成，它们对连接中的另一方进行身份验证。它会加密数据并在检查数据完整性时提供机密性。
SSH与SSL主要区别如下：
1）SSH实现端口22，而SSL实现端口443。
2）SSH可以帮助您安全地在Internet上执行命令，而SSL可以安全地传输关键信息。
3）SSH在建立安全连接时需要密码验证系统。SSL不需要它。
4）SSH主要处理网络隧道，而SSL处理证书。
对于各种网站来说，可以使用SSL保护客户端和服务器之间的Internet连接。它非常适合在进行在线业务交易时为客户提供安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37cf9af9db9fc8b71dc47320445f0d7a/" rel="bookmark">
			AbortController 终止请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AbortController
//AbortController()构造函数创建一个控制器 const controller = new AbortController(); //AbortController.signal属性获取其关联 AbortSignal对象的引用。 let signal = controller.signal; const downloadBtn = document.querySelector('.download'); const abortBtn = document.querySelector('.abort'); //发起请求 downloadBtn.addEventListener('click', fetchVideo); //abort()方法在完成AbortControllerDOM请求（例如Fetch请求）之前将其中止。 //终止请求 abortBtn.addEventListener('click', function() { controller.abort(); console.log('Download aborted'); }); function fetchVideo() { //... fetch(url, {signal}).then(function(response) { //... }).catch(function(e) { reports.textContent = 'Download error: ' + e.message; }) } 封装成hooks
import { useState, useEffect } from 'react' export default useFetch = (param,deps) =&gt; { const abortController = new AbortController() const [ loading, setLoading ] = useState(false) const [ data, setData ] = useState() useEffect(()=&gt;{ setLoading(true) fetch(param,{signal:abortController.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37cf9af9db9fc8b71dc47320445f0d7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d83f50939c19025cddd608e6161995/" rel="bookmark">
			阅读笔记-分子图benchmark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读笔记-图benchmark 1、ogbn-proteins: Protein-Protein Association Network2、ogbl-ddi: Drug-Drug Interaction Network3、ogbl-biokg: Biomedical Knowledge Graph3、ogbg-ppa: Protein-Protein Association Network4、GDB5、QM7/QM7b6、QM87、QM9ESOLFreeSolvLipophilicityPCBAMUV 新分子设计的模型：(1)分子生成，(2)分子评分方法，(3)针对评分函数优化或搜索更好分子的方法
1、ogbn-proteins: Protein-Protein Association Network ogbn-proteins：无向，带权重，多种边类型的图结构。节点代表着蛋白质分子，边表示蛋白质之间不同类型的有生物学意义的联系，例如物理相互作用、共表达或同源性。所有的边都有8维特征，每个维度代表一个关联类型的强度，取值范围在0到1之间（值越大，关联越强）。蛋白质来源于8种物种。其任务是在一个多标签二元分类系统中预测蛋白质功能的存在，该系统中总共有112种标签需要预测。这一表现是根据这112项任务中ROC-AUC的平均分来衡量的。
2、ogbl-ddi: Drug-Drug Interaction Network ogbl-ddi：是无权重无向的同质图，代表药物-药物相互作用网络。每个节点都代表着一个专业的药物。边表示药物之间的相互作用。这个作用可以解释为一种现象，当这两种药物同时使用时所产生的联合效应与这两种药物单独使用时所产生的的预期效应有很大的不同。
其任务是在已知的药物-药物相互作用信息的基础上预测药物-药物的相互作用。评估指标与ogbl-collab相似，该模型将真实药物相互作用的排名高于非相互作用药物对。
3、ogbl-biokg: Biomedical Knowledge Graph ogbl-biokg：ogbl-biokg数据集是一个知识图谱(KG)，它是使用来自大量生物医学数据存储库的数据创建的。它包含五种实体：疾病（10687个节点），蛋白质（17499个节点），药物（10533个节点），副作用（9969个节点），蛋白质功能（45085个节点）。有51种类型的有向关系将两种类型的实体联系起来，包括39种药物相互作用，8种蛋白质相互作用，以及药物，药物副作用，药物，功能，功能关系 。 所有关系均建模为有向边，其中连接相同实体类型（例如蛋白质-蛋白质，药物-药物，功能-功能）的关系始终是对称的，即，边是双向的。
这个数据集与生物医学和基础医学研究相关。在生物医学方面，该数据集使我们能够更好地了解人类生物学，并产生预测，从而指导下游的生物医学研究。在基本的ML方面，数据集显示了在处理噪声、不完整的KG时可能存在矛盾的挑战。这是因为ogbl biokg数据集涉及从分子尺度（例如，细胞内的蛋白质-蛋白质相互作用）到整个人群的异质相互作用（例如，某个国家的患者所经历的有害副作用的报告）。此外，KG中的三元组来自具有各种置信水平的来源，包括实验性的读数、人工编制的注释和自动提取的元数据。
任务是根据给定的训练三元组来预测新的三元组。
3、ogbg-ppa: Protein-Protein Association Network ogbg-ppa: ogbg-ppa数据集是从1581个不同物种的蛋白质-蛋白质关联网络中提取的一组无方向的蛋白质关联邻域，这些蛋白质关联网络覆盖了37个广泛的分类类群(如哺乳动物、细菌科、古生菌)，并横跨生命之树。为了构建邻域，我们从每种物种中随机选择了100种蛋白质，并以每个选定的蛋白质为中心构建了2跳蛋白关联邻域.然后，我们从每个邻域中移除中心节点，并对邻域进行下采样，以确保最终的蛋白关联图足够小(小于300个节点)。每个蛋白质关联图中的节点表示蛋白质，边表示蛋白质之间有生物学意义的关联。边缘与7维特征相关联，其中每个元素取0到1之间的值，表示特定类型蛋白质的强度蛋白质关联，如基因共现、基因融合事件和共表达。
给定一个蛋白质关联邻域图，该任务是一个37向多分类方法，以预测该图源自哪个分类学组。 成功解决该问题的能力对于理解跨物种的蛋白质复合物的进化，随着时间的推移重新建立蛋白质相互作用，发现基因之间的功能性关联（甚至对于其他方面未被研究的生物）也具有意义，并且将使我们对关键的生物信息学有深刻的认识 诸如生物网络对齐之类的任务
4、GDB GDB
GDB-11：遵循简单的化学稳定性和合成可行性规则，列举了最多11个C，N，O和F原子的有机小分子。
GDB-13：遵循简单的化学稳定性和合成可行性规则，列举了最多13个C，N，O，S和Cl原子的有机小分子。 GDB-13具有977468314种结构，是迄今为止最大的可公开获得的小型有机分子数据库。
GDB-17：药物分子由几十个通过共价键连接的原子组成。 这些分子总共可能有多少个，它们的结构是什么？ 这个问题在药物化学中引起了人们的紧迫兴趣，以帮助解决药物效价，选择性和毒性的问题，并通过指出新的分子系列来降低损耗率。 为了更好地定义未知的化学空间，我们列举了1664亿个碳原子，碳原子，氮原子，氧原子，硫原子和卤素原子的17个原子组成的分子，形成了化学宇宙数据库GDB-17，涵盖的范围涵盖了许多药物和典型的铅 化合物。 GDB-17包含数百万种已知药物的异构体，包括与母体药物具有高度形状相似性的类似物。 与PubChem中的已知分子相比，GDB-17分子在非芳族杂环，季中心和立体异构体中含量更高，在形状空间的第三维中密集分布，并代表了更多的支架类型
5、QM7/QM7b QM7/QM7b数据集是GDB-13数据库的子集:使用二元密度泛函理论（PBE0 / tier2基集）确定每个分子的最稳定构象和电子特性（原子化能，HOMO / LUMO特征值等）的3D直角坐标。在稳定的构象坐标下，以QM7 / QM7b为基准的学习方法负责预测这些电子特性。
QM7b该数据集是用于多任务学习的QM7数据集的扩展，其中必须在不同的理论水平（ZINDO，SCS，PBE0，GW）下预测13个其他属性（例如极化率，HOMO和LUMO特征值，激发能）。 还包括其他含氯原子的分子，总计7211个分子。
6、QM8 QM8数据集来自最近对电子光谱的量子力学计算和小分子激发态能量建模的研究，是GDB-17的子集。在2.2万个样本上，用三种不同的方法计算了四种激发态性质。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d83f50939c19025cddd608e6161995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c509dd7364ce3374b35feb26275096c/" rel="bookmark">
			20201021 plecs提高波特图精度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		改变这个number of points
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/119f63ebf2ef02661f05f657be3aefee/" rel="bookmark">
			英特尔与Lightbits Labs展开战略性合作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国上海，2020年10月 – 英特尔公司(Intel)和Lightbits Labs日前宣布达成一项协议，以推动解耦合(disaggregated)存储解决方案的开发，从而解决当今数据中心运营商的诸多挑战，帮助他们在闪存盘容量和性能提升出现停滞时实现总拥有成本(TCO)的改善。这一战略合作伙伴关系包括技术上的联合工程化、产品上市协作和英特尔资本(Intel Capital)向Lightbits Labs投资。Lightbits的LightOS™产品可跨服务器提供高性能的共享存储，同时提供高可用性和读写管理功能，从而实现最大限度地提高闪存类存储的价值这一设计目标。LightOS在针对英特尔®硬件进行全面优化的同时，也为客户提供了大大提高的存储效率，提升了利用率，并保持了与现有基础设施的兼容，同时不影响性能和便捷性。
Lightbits Labs将针对英特尔®的技术增强其LightOS可组合的解耦合软件定义存储解决方案，从而创建一个经优化的软件和硬件解决方案。该系统将利用英特尔® Optane™持久内存、基于英特尔® QLC 3D NAND技术的固态硬盘、具有独特内置人工智能(AI)加速功能的英特尔®至强系列可扩展处理器、以及带具有应用设备队列(ADQ)技术的英特尔® Ethernet 800系列以太网网络适配器。英特尔专为新一代性能、灵活性和可编程性打造的领先 FPGA也将为该解决方案提供补充。
Lightbits Labs演示了LightOS NVMe over Fabric TCP(NVMe-oF/TCP)存储技术，当使用带有ADQ技术的英特尔Ethernet 800系列网络适配器来进行加速时，该存储方案可实现远程直接内存访问(RDMA)级性能(来源：Lightbits Labs)
除了两家公司之间的技术合作外，Lightbits和英特尔正携手为客户提供完整的解决方案，并建设相关生态系统，从而推动这些创新被广泛采用。作为此项协作将产生的潜在性能优势的第一个示例，Lightbits Labs演示了LightOS NVMe over Fabric TCP(NVMe-oF/TCP)存储技术，当使用带有ADQ技术的英特尔®Ethernet 800系列网络适配器来进行加速时，该存储可实现远程直接内存访问(RDMA)级性能。ADQ可使NVMe-oF/TCP能够实现与基于RDMA协议相同的分布式存储性能;同时，由于NVMe-oF/TCP易于部署和具有可扩展性，因而可被广泛采用。IOPS测量结果显示，使用ADQ与不使用ADQ情况相比，响应时间的可预测性提高了30%，平均延迟减少了50%，吞吐量提高了70%。这种Lightbits和Intel集成解决方案可为云上的本机应用提供持久存储，提高了性价比、实现方便性、可用性和可扩展性。
Lightbits Labs首席执行官兼联合创始人Eran Kirzner表示：“英特尔是一位行业领导者，在数据中心技术方面拥有深厚的专业知识，并拥有尖端的产品、全球销售体系和一个令人印象深刻的生态系统。我们很高兴能与英特尔公司合作，我们的联合解决方案将为企业和云客户设定新的ROI指标标准。”
英特尔副总裁兼数据平台集团首席战略和业务拓展官Remi EL-Ouazzane表示：“数据中心正在实现转型，为应对数据爆炸式增长，资源的解耦合和可组合性对于满足所需的效率要求至关重要。我们与众不同的硬件功能与Lightbits创新的NVMe over Fabrics软件相结合，可为我们共同的客户提供了卓越的高经济性解决方案，以应对这一战略拐点。”
英特尔资本(Intel Capital)对Lightbits的投资将有助于加快公司的发展以及产品广泛进入市场运营。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d71ef54db1f924efdf4f9850962edc/" rel="bookmark">
			FTPS的正确使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于FTP、FTPS 与 SFTP 简介见另外一篇转载的文章,讲的比较详细,此文不在另外描述.
https://blog.csdn.net/ericwuhk/article/details/109120158
FTPS在微软官网寥寥数笔,看完也一头雾水,无奈找了一通,找了到了一份开源代码,研究了一通发觉可用,至此记录.
https://docs.microsoft.com/en-us/archive/blogs/adarshk/using-ftpwebrequest-to-do-ftp-over-ssl
一句未改得原始代码上传至CSDN,以便哪天找不到国外网站资源.
https://download.csdn.net/download/ericwuhk/12984869
第一步:打开源码,VS报弹框不用理,直接确定即可.在原始代码中直接rebuild编译FTPSClient,生成"AlexPilotti.FTPS.Client.dll"和“AlexPilotti.FTPS.Client.XML" 这两个文件导入至所需得项目路径下,直接引用就可.
第二步:编译FTPSClientCmdApp,生成ftps.exe,打开cmd命令窗口查看工具是否可正常使用
ftps -h 10.131.128.6 -U user -P password -ssl CredentialsRequired -g /Modules/ZW01TLAA.IMZ C:\Users\XXX\Desktop\mytest 第三步:在自己的项目中,导入"AlexPilotti.FTPS.Client.dll"和“AlexPilotti.FTPS.Client.XML"后,需要修改代码才能正确使用.核心代码修改如下:
using System; using System.Data; using System.IO; using BaseLibrary.ExecutionResults; using System.Text; using System.Net; using System.Net.Security; using System.Security.Cryptography.X509Certificates; using BaseLibrary.Config; using AlexPilotti.FTPS.Client; public class readfile { public string strServerPath; public FTPSClient client; public void initFTPS() { CCfg ccfg = new CCfg(); strServerPath = ccfg.GetValue("serverPath");//modules string user = ccfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21d71ef54db1f924efdf4f9850962edc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b14bf1f860f242a4ef6af4760ba9366/" rel="bookmark">
			正则表达式校验YYYYMMDD日期格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 正则表达式校验YYYYMMDD日期格式 首先，我们先了解2个概念：
1、合法的日期范围：
DateTime 值类型表示值范围在公元（基督纪元）0001 年 1 月 1 日午夜 12:00:00 到公元 (C.E.) 9999 年 12 月 31 日晚上 11:59:59 之间的日期和时间。
2、平年和闰年
地球绕太阳公转一周叫做一回归年，一回归年长365日5时48分 46秒。因此，公历规定有平年和闰年，平年一年有365日，比回归年短0.2422日，四年共短0.9688日，故每四年增加一日，这一年有366日，就 是闰年。但四年增加一日比四个回归年又多0.0312日,400年后将多3.12日,故在400年中少设3个闰年,也就是在400年中只设97个闰年，这样公历年的平均长度与回归年就相近似了。由此规定：年份是整百数的必须是400的倍数才是闰年，例如1900年、2100年就不是闰年。
验证YYYY年份：
\d{3}[1-9]|\d{2}[1-9]\d|\d[1-9]\d{2}|[1-9]\d{3} 验证MMDD月日：
大月（1、3、5、7、8、10、12月，有31天）
(0[13578]|1[02])(0[1-9]|[12]\d|3[01]) 小月（4、6、9、11月，有30天）
(0[469]|11)(0[1-9]|[12]\d|30) 平年2月（有28天）
02(0[1-9]|[1]\d|2[0-8]) 闰年：
能被4整除但不能被100整除的年份
(\d{2})(0[48]|[2468][048]|[13579][26]) 能被400整除的年份
((0[48]|[2468][048]|[3579][26])00) 闰年2月（有29天）
((\d{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))0229 最终，验证YYYYMMDD的正则表达式为
((\d{3}[1-9]|\d{2}[1-9]\d|\d[1-9]\d{2}|[1-9]\d{3})(((0[13578]|1[02])(0[1-9]|[12]\d|3[01]))|((0[469]|11)(0[1-9]|[12]\d|30))|(02(0[1-9]|[1]\d|2[0-8]))))|(((\d{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))0229) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/560941ca4be27bf0ecd00df408a8adf1/" rel="bookmark">
			uni-app消息推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先登录注册：https://dev.dcloud.net.cn/app/index?type=0
2.接下来这一步很重要，哎，找了好久，对后面的cid的获取很有用。记住有这些东西。
3.创建一个uni-app项目，配置manifest.json,这里就用到上面的东西了哈
4.CID的获取，注意是让cid在客户端里显示，然后将获取的值保存下来哈，后面有用
代码展示：
&lt;script&gt;
export default {
data() {
return {
title: 'Hello'
}
},
onLoad() {
this.getcid()
},
methods: { getcid(){
setInterval(function(){
uni.showToast({
icon:"success",
position:"center",
title:plus.push.getClientInfo().clientid
})
},2000)
}
}
}
&lt;/script&gt;
5。
6. 7，云打包，选第一个，原生app云打包，里面的包名和在后台配置的保持一致，可以选用dcloud公用证书。
8，打包成功后，注意控制台，等会就有可以下载apk的地址，安装到手机上，因为客户端代码已经写了cid的获取，所以在手机上可以查看到cid了，注意哈，是在手机上获取，当然模拟器也可以，浏览器就不行了哈，把这个cid记下来哈，在发送消息预览时会用到
9可以发送消息了，手机通知栏可以看到了，哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/336b524c213a09cdb50244fffac25b01/" rel="bookmark">
			CocosCreator中的那些坑之组件属性修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改CocosCreator中组件属性貌似很容易，一个等号直接赋值就行了，比如下面修改刚体的速度：
let rb = t.getComponent(cc.RigidBody); rb.angularVelocity = 0; rb.linearVelocity = cc.v2(0, 0); 然而，如果写成下面这样，你会发现完全没有效果：
let rb = t.getComponent(cc.RigidBody); rb.linearVelocity.x = 0; rb.linearVelocity.y = 0; 原因其实都在源码中了，如下：
* !#zh * 刚体在世界坐标下的线性速度 * @property {Vec2} linearVelocity * @default cc.v2(0,0) */ linearVelocity: { tooltip: CC_DEV &amp;&amp; 'i18n:COMPONENT.physics.rigidbody.linearVelocity', type: cc.Vec2, get: function () { var lv = this._linearVelocity; if (this._b2Body) { var velocity = this._b2Body.GetLinearVelocity(); lv.x = velocity.x*PTM_RATIO; lv.y = velocity.y*PTM_RATIO; } return lv; }, set: function (value) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/336b524c213a09cdb50244fffac25b01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838aa8df7100592049a3b772ba782556/" rel="bookmark">
			【个人总结】2020计算机保研经历（北大信科、上交、浙大、南大、中科院）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在推免系统上确认录取已经过去一周了，心里的一块大石头也终于落下。几个月的跌宕起伏到现在还有些后劲，经历过迷茫与抑郁最终还是走了过来，也算是人生的一个转折点。想了想还是写点东西记录一下，调整好状态迎接新的生活，也希望对后来的同学有所帮助吧。
个人情况介绍 本科学校：某末流C9
本科专业：计算机科学与技术
专业排名：夏令营25%，预推免8%
英语六级：560+
科研情况：在实验室搬过几个月的砖，尝试做过一个CV的task，代码都已经完成但是各种原因没发出文章，深度学习、机器学习、图像处理、数值分析等课程都有学过，有一定科研基础
获奖经历：两项全国人工智能水赛特等奖、两项全国二等奖、几个“挑战杯”“互联网+”省奖、校内金奖、国家级大创一等奖等
项目经历：大学三年每年一个项目，都是AI方向，经历还算比较丰富
其他：两项计算机软件著作权，一些小奖学金和校内荣誉
申报情况 夏令营 申报：清深、北大信科（直博）、北大信工、计算所、自动化所、软件所、上交（直博）、复旦、浙大（直博）、南大、中科大、人大、北航、哈深
入营：上交（直博）、浙大（直博）
offer：入营的均通过面试，由于没有合适的老师最终放弃
预推免 申报：北大信科（直博）、复旦、浙大、南大、中科院某所
入营：北大信科（直博）、南大、中科院某所
offer：入营的最终均拿到offer
最终去向 经历 夏令营 2020年真是保研历史上最艰难的一年，尤其是对于我这种排名不怎么靠前的同学，对心理素质有着巨大的考验。本来以为七月份就能结束一切，还早早的为八月找了份实习，结果最终在十月十二号才为一切画上句号。
其实在我刚进大学不久就在为保研计划，当时给自己每年定了一个目标，比如大一从软工转到计算机、大二分到自己想去的方向然后就是大三保研到想去的学校，期间参加各种竞赛与项目都可以说是有意的准备。
终于大三下了，结果突然起来的疫情让保研夏令营的安排难以琢磨。由于在家学习效率低下，想准备也一直没怎么准备，无论是联系导师还是准备机试面试，制定了很多计划但是执行的很差，这样昏昏碌碌直到六月份逐渐有了各种推免的通知。结果发现虽然今年夏令营时间没有太大的推迟，但所有夏令营都改成了线上进行，这也导致了很多很多同学包括我在内都采取了海投方案，加上各种研究所一共投了十几个地方，花了很大力气准备材料，结果收到的却是一封又一封拒信，自信心也逐渐掉入低谷，被否定了十几次从而觉得自己一无是处，那段时间真的挺难熬的，可能也是对自己的预期过高吧，加上今年保研形势变化比较大。而且很尴尬的一点是我们的考试安排在了七月份，导致很多我校的同学都没有太多时间准备夏令营。
线上考核比较大的一个问题就是大家都可以海投，不会因为时间地点错不开而把坑位让给真正想来的同学，结果就是大佬们收获一批offer，而排名差一点的同学可能没有任何offer，入营的很多都是同一批人。从某种意义上来说今年的入营门槛提升了不是一点。
除了北大、上交和浙大我申请的都是硕士，结果全军覆没，只有上交浙大直博入营了。本以为各方面经历很重要，而后来发现先有好的rank，才会有人了解你的经历，无论是夏令营还是预推免，靠前的成绩排名都是入场券，然后才是考察各方面专业知识与项目经历。大多数同学都想读完硕士直接工作，加上直博本来就存在一定的风险，所以申请硕士入营的竞争比直博大很多很多。另外本科学校层次只是一方面，对于很多学校在选择入营同学时，211前几名同学的入营机会比985的一般同学入营概率大的多。
由于夏令营参加的很有限，这里就介绍下上交和浙大直博的情况。
上交直博 如果选择了直博，关键点在于联系老师与自身的科研经历。毕竟直博是跟着导师读五年起步，学校只是一方面，最重要的还是找到人品和学术尚可的导师，而这样的老师往往需要提前联系，老师同意要你学校的就只是走流程，很多学校的直博都是这样，所以如果rank一般，但是竞赛、项目和科研经历丰富，直博还是很有机会的。不过清华要求5%，所以我作为菜鸡就没机会申请了。直博确实存在风险，需要谨慎考虑，但我个人觉得如何方向和导师合适还是可以思考一下的，毕竟很多学校硕士发文章的还是少数，对有志于科研的同学直博能够节约一点时间。
上交这边985的前30%直博入营的概率貌似都是有的，但rank一般硕士就很难了，尤其是今年的夏令营，上交对于一部分学校据说只要第一，虽然最后填系统貌似被鸽穿了。在上交教师主页和导师评价网联合筛选了很久，找了一个方向和人品都尚可的老师。发了很多邮件，但是最后只有一个老师回我了，大概是在六月底的时候。其他老师应该要么早就有确定的学生了，要么邮箱邮件太多懒得看了，而且牛导大多都会被本校同学提前预定。收到老师的回信自然是很兴奋，虽然老师在邮件里提出的毕业标准很高，但我还是愿意试一试。跟老师电话交流了一番，老师对我的各方面经历进行了肯定，并给我发了两道考核题目，给我自己介绍了硕博的区别以及学校考核的流程并让我再次考虑了一下，我个人是不排斥读博的，加上硕士凭我的rank也没有机会还是毅然报名了这个老师的直博。
考核题目是两篇论文复现，虽然踩了很多坑但花了一段时间还是达到了论文中但效果，随后就进入了下一阶段。老师又给了我三篇论文让我阅读，读完后跟他交流。这期间得知入营了，后来跟老师交流有的他考核的同学没入营，感觉自己也是很幸运。上交的直博面试感觉比较轻松，专业知识机会没问。英文自我介绍后有针对你介绍的英文问答，然后会从你的简历里问一些问题，问问你有没有联系好老师之类的，大多数人应该都过了吧，基本就是走个流程，所以说关键还是有没有老师愿意收你，大多数老师直博的名额都只有一个。
随后我继续看老师给的三篇论文，结果七月还有我们学校的期末考试，进度慢了很多。最后跟老师交流了一下，老师觉得总体还可以，说等他的名额出了会联系我，当时我就应该意识到我只是鱼塘里的一条小鱼，如果要我的话会直接把我作为首选给口头offer，等名额其实是说明如果今年有俩会考虑收我，老师当时也让我继续尝试浙大，会在浙大出结果前给我答复。
由于报了实习，而且天真的以为稳了后来就没继续准备。结果等到上交需要上报联系的老师时这个老师也一直没有联系我，第一次问说还没出名额，后面也许是忘了，我追问下才说已经确定了另外一个同学。而那个时候浙大我已经放弃了，结果就很尴尬了。毕竟保研这个事情，双方都是在不断找备胎的过程，也能理解老师吧。
后来我感觉联系去给其他老师发邮件，很幸运又有一个老师给了回复，而且这个老师CV方面还特别强，经过组里博士的面试后感觉不错，科研方面的基本也都回答上来了。老师下午很快电话联系了我，考察了一些非专业的东西，并告诉我决定在我和另一个同学之间选一个，然我第二天上午等他消息。我期待了很久，忐忑了一上午，老师最后说决定选择了一位同学，我的心瞬间凉了，到现在也是感觉挺遗憾的。但老师表示还是愿意我能加入团队，看看能不能挂名在其他老师那边，但最终还是失败了，其他也没有合适的老师，我就只能等待九月教育部确定名额后这两位老师有没有新的名额，上交至此就告一段落了。
另外上交今年如果夏令营过来面试没有联系到合适的老师，预推免可以继续联系，所以其实也相当于继续参加了上交直博的预推免。
浙大直博 浙大的夏令营只有直博，官网的入营标准比上交要高一些，原则上需要前10%，不过最后没有卡我。另外需要先联系课题组然后才会有入营，由于今年疫情以前需要去浙大科研实习一个月，然后答辩后老师选择心仪的同学直博，有点类似于企业实习转正，不过今年这个也改成线上了。联系的老师派了一个师兄来电话面试我，问了一些经历以及通过在线文档手撕了三段代码，记得是写一个矩阵相乘、找最大外矩形以及写一个梯度下降，其实难度不是很大，最后很幸运通过了，也顺利入营了。
入营后的考核就根据各个课题组，我联系的老师让报名他的同学选一个题目，偏工程复现一些，有师兄来带，师兄们人都很好，解答问题也很认真，不过最后由于地理位置和实验室方向的一些考虑还是放弃了，还是很感谢能给我入营的机会。
不过鸽子貌似挺多的，毕竟很多同学对直博还是抵触的，所以如果真心想来浙大直博联系好老师跟着把考核项目做下来，等到八月底答辩的时候基本是等额选拔了。浙大的CV还是很强的，而且老师数量比上交还是要多一些。
总的来说直博入营难度不大，关键还是能不能找到合适的老师愿意要你，有志于此的同学可以多刷刷自己的项目科研经历，本科阶段如果能发篇好的文章我觉得大多数老师都愿意要吧。
预推免 夏令营最后没有任何收获，不得已预推免放手一搏。不过事实上夏令营上岸的也只是一部分，很多同学都是在预推免上岸的，甚至还有同学在系统开放后拿到offer，所以希望一直都是有的。夏令营被北航拒了的时候心几乎凉了，难受了好久，因为北航因为地理位置一直是我很想去的学校，感觉自己想去北京读研的梦想破灭了。不过有趣的是，经过预推免最终还是来到了北京。
中科院某所 上交失败后联系了中科院的一个老师，他团队的年轻老师联系了我进行面试。面试结束后的第二天老师给了我口头offer，让我在九月走个研究所的流程就好。大老板已经不带学生了，这个年轻老师人非常好，对学生很热情，组里科研成果也十分丰富，但是方向后来发现我不是特别喜欢。由于一直对北京的计算机氛围有着向往，加上也确实是学术活跃的研究组，中科院各方面实力也都很强，决定接受了offer。
后来预推免我又报名了几个学校，包括某所，但这次数量就少了很多，主要报名的都是真正考虑来的或者想要尝试一下的。不过听说预推免很多大佬还是继续海投了，毕竟仍然是线上考核。可以预见最后填系统必定是一片鸽子。
南大CS 浙大和复旦都没给我预推免入营的机会，说来也很奇怪，这个时候我的综排rank已经是8%，上一届学长20%浙大预推免都入营了，而且南大夏令营也入营了，可能今年确实是太卷了吧。不过南大cs预推免还是给了我入营了机会，不过后来感觉还是更向往某所，就没太认真准备。因为疫情的原因，今年南大也没有机试（浙大、北大、上交等也都取消了，有机试的学校不多），往年据说机试对最终录取决定性很大。预推免面试总体难度较低，问的问题也比较简单，由于保密协议的原因就不透露具体问题了。
南大预推免据说全都进了waiting list？也可能是我没答好进了waiting list，由于有别的offer也没在意，当然如果想了解自己的排名可以打电话询问招办。在waiting list里呆了几天后有老师打电话给我说候补到了专硕，出于今年专硕没有宿舍的原因果断放弃了。
不过南大确实也挺棒的，综合类院校男女比均衡，而且底蕴很丰富，快乐地读两三年硕士然后工作想想也不差，就是今年和复旦一样，专硕没宿舍让很多同学放弃，这可能也是我候补到的原因。有志于南大的同学可以早早联系lamda的老师，在夏令营之前会有额外的面试，不过预推免好像没有额外的面试，但好老师估计也不多了。南大几乎是所有学校中夏令营开始最早的，因此各层次的大佬们也都报名，所以夏令营入营时rank门槛还是很高的。
其实看到这里可以发现，大多数学校夏令营门槛会很高，为了选拔优质生源，尽管鸽子会很多，据我了解除了特别满意的offer，很多同学预推免还是会继续冲击更理想的地方，而预推免的各方面要求就会有降低，老师此时也开始赶紧招满学生，但是仍然会有鸽子，所以很多学校都有waiting list，最后到系统开放和关闭之间的时间段，基本就是补满名额的时候了，也是捡漏的机会，听说有的学校被鸽穿了，只投过简历没过入营初筛的同学都有了录取的机会，但捡漏风险非常大。
信科直博 被上交两位老师拒了以后为了抓住预推免的机会我便开始疯狂投简历，信科只是抱着试一试的心态，投了四个老师最终只有一个老师回复我了，并且约了电话聊一聊，确实也是很惊喜。跟老师聊了几十分钟，老师也简单的考核了一下我，感觉老师比较满意，并让我报名的时候填他。经过和老师交流了到解信科硕士名额很少，很大比例都是直博。直博这个有老师要就希望很大了，我兴高采烈地在系统上填写了这个老师，并且找校内比较熟的老师要了推荐信，然后就是等结果了。
发现自己入营的时候真的很意外，在想是不是这位老师捞了我一下，还是非常感激，毕竟我的rank还是没有5%。然而入营后再联系这位老师老师却不回我邮件了，让我十分意外，逐渐发现我又只是鱼塘中的一只小鱼。在后来和同学交流的过程中，这个老师也向别人发出了填写他的邀请，但是这位同学没有入营，所以我觉得能入营可能不是老师捞的，只是我运气好了一点吧。当然也理解老师，保研的过程似乎就是互为备胎的过程，大家也都有权利争取更理想的，只是有的老师是小范围养鱼，有的则是广撒网。
没有老师要我感觉自己要凉了，面试的时候感觉表现也一般，毕竟是P大，有点心灰意冷，还是安心去我的某所吧，好好干在哪里都一样。然而很意外的是，面试结束后有老师联系我单独考核，我又看到了希望。经过考核，老师说会在候选的同学中选择一下再告诉我结果。等了一天没有任何消息，感觉自己真的凉了，几乎放弃了。然而老师在突然告诉我决定给我offer，看到消息的瞬间感觉走上了人生巅峰。
当然后续也又跟师兄了解了一下组里的情况，直博还是得慎重一点，考虑了一下还是决定要来。某所那边正好在走流程，加上今年系统开放推迟了两周，为了不影响老师招生及时跟老师说了一下并帮老师找了一些候选的同学，最终老师对我的选择也表示尊重，也很感谢老师。当然也听说有同学填系统前突然说不去了，这个确实会让老师很生气，很影响老师的招生。在没找老师的情况下，鸽学校一般问题不大，大多数学校都有waiting list，但是找了老师如果决定不去一定要及时告知，否则有的老师特别生气可能还会去你在的学校举报你的鸽子行为，甚至今年还看到中科院另外某所老师说要在今后的学术界制裁你并减少在你本科学校的指标。
拿到信科offer后我长舒了一口气，保研也终于告一段落了。最终可能也有一些妥协，但是对我而言已经算比较理想的结果，希望自己能够沉住气把博士五年读下来，顺利拿到毕业证吧。
十推 填系统的时候总体还比较顺利，学校为了保证录取工作以及防止鸽子，基本都需要凌晨走流程和确认。部分学校不担心被鸽比如T大，时间略晚两天。而有的学校因为鸽子太多没招满系统开放后还会继续面试，这个时候录取的难度也大大降低，自然是捡漏的好机会。不过之前有合适的offer还是不要考虑捡漏，一方面合适的老师不多了，另一方面捡漏也有很大的风险，万一没学上了就得不偿失，不过之前上交那边毕竟合适的老师系统开放前两天貌似也有新的名额了，但由于已经确定了信科这边就不再考虑了。系统确认录取的一瞬间，不出什么意外一切都结束了。
另外，直博自然是学术型的，跟导师直接挂钩，而硕士有学硕和专硕，计算机的专硕一般都叫电子信息，听说外校的拿学硕还是有难度的，我了解到很多同学保外都被调剂为了专硕。至于学硕和专硕的区别，一般来说专硕学费贵一点，有的学校比如复旦可能会很贵，不过也有奖学金可以弥补一下，另一方面专硕毕业一般没有论文要求，以及专硕升博士可能比学硕麻烦点。但从找工作角度来说感觉没有实质性区别，学校牌子是一样的。
经验总结 写了很多经历还是总结一下经验，希望对以后的同学有帮助。
需要的能力 在我看来，保研的考察点主要有专业课能力、代码能力和各种经历三点，当然英语也是其中一项，直博和硕士的考察点又有不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/838aa8df7100592049a3b772ba782556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301c7a941b5d75358ca1f80bc710a9f7/" rel="bookmark">
			Python写入Excel文件-多种实现方式（测试成功，附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
xlsxwriter库储存数据到excel
简介
示例：写入excel
更多
添加工作表样式：
写入单元格数据
插入图片
写入超链接
插入图表
pandas库储存数据到excel
简介
示例：写入excel
openpyxl库储存数据到excel
示例：写入excel
更多
打开已有文件
根据数字得到字母，根据字母得到数字
删除工作表
查看表名和选择表（sheet）
设置单元格风格
xlsxwriter库储存数据到excel 简介 功能比较强： 支持字体设置、前景色背景色、border设置、视图缩放（zoom）、单元格合并、autofilter、freeze panes、公式、data validation、单元格注释、行高和列宽设置
支持大文件写入不支持读取、修改、XLS文件、透视表（Pivot Table 示例：写入excel # -*- coding: utf-8 -*- import xlsxwriter as xw def xw_toExcel(data, fileName): # xlsxwriter库储存数据到excel workbook = xw.Workbook(fileName) # 创建工作簿 worksheet1 = workbook.add_worksheet("sheet1") # 创建子表 worksheet1.activate() # 激活表 title = ['序号', '酒店', '价格'] # 设置表头 worksheet1.write_row('A1', title) # 从A1单元格开始写入表头 i = 2 # 从第二行开始写入数据 for j in range(len(data)): insertData = [data[j]["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/301c7a941b5d75358ca1f80bc710a9f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f730a5bdf30e6fde610a020d6099d49/" rel="bookmark">
			在Ubuntu 20.04上使用Systemback（亲测可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu 20.04上使用Systemback 原文 Systemback 是一个优秀的Linux系统备份还原软件。这个软件不仅能够备份还原系统，还能够把系统做成启动盘和ISO镜像，用于在其他机器上分发系统。但是作者已经放弃维护这个软件。软件也无法继续在Ubuntu 20.04运行。我就花了点时间对Systemback进行了开发使其支持在Ubuntu 20.04上工作。同时添加了软件对大文件的支持。现在软件生成的系统镜像ISO不再受限于4G大小。 更新后的Systemback
软件安装:
sudo sh -c ‘echo “deb [arch=amd64] http://mirrors.bwbot.org/ stable main” &gt; /etc/apt/sources.list.d/systemback.list’
sudo apt-key adv --keyserver ‘hkp://keyserver.ubuntu.com:80’ --recv-key 7D9C279F
sudo apt-get update
sudo apt-get install systemback
启动：
maya@califunia:~$ sudo systemback
如果我们需要创建系统备份，点击Create new 就可以了。
下面介绍一下自定义系统的iso文件如何制作:
点击右侧的Live system create按钮，出现界面如下图所示
勾选左侧的include the user data files，这样自己主文件夹内的文件都会被包含在系统镜像中。很多相关的程序的配置文件都是保存在主文件夹内的。Working Directory是设置工作目录，程序运行时产生的临时文件都会被保存在这里。所以一定要保证这里有足够的存储空间。
点击Create New按钮就开始创建了，等待创建完成。
完成后界面如下图所示
右侧的列表中就是已经创建的备份。我已经创建了两个相关的备份，所以有两个在右侧显示。此时文件没有转换成iso格式，选中你要转换的备份，点击convert to ISO 就可以开始转换了。转换完成后，在你的工作目录下就能找到生成的iso文件。
这个文件就可以用来安装系统了。同时还可以作为live系统来使用。
在备份过程中可能提示
The restore point creation is aborted!
There has been critical changes in the file system during this operation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f730a5bdf30e6fde610a020d6099d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83823dce65e62a13e85222bba9f5bf49/" rel="bookmark">
			addEvent完美封装（addEventListener兼容性封装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		addEventListener兼容各大浏览器封装 封装：addEvent.js
/** * element 要绑定事件的对象，及HTML节点。 * type 事件名称，attachEvent监听的事件前边的加上“on”，比如“onclick”和“onmouseover”，addEventListener与之相反。 * listener 要绑定的事件监听函数 */ const addEvent = function({element, type, callback}) { if (element.addEventListener) { // 支持使用 addEventListener() if (type.slice(0,2) === "on") // 以 "on" 开头，不需要，则去掉 type = type.slice(2); element.addEventListener(type, callback); } else if (element.attachEvent) { // 支持使用 attachEvent() if (type.slice(0, 2) !== "on") // 没有以 "on" 开头，需要，则加上 type = "on" + type; element.attachEvent(type, callback); }else{ type.slice(0, 2) !== "on" ? element['on'+ type] = callback : element[type] = callback; } } export default addEvent; 其他js引入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83823dce65e62a13e85222bba9f5bf49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766d0601965089715aa93652fcc8620c/" rel="bookmark">
			斗鱼自动刷屏脚本-javaScript斗鱼刷屏脚本-js刷屏脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(function(){ var msgTarea=document.getElementsByClassName("ChatSend-txt ")[0]; var btn=document.getElementsByClassName("ChatSend-button")[0]; function mySend(msg){ msgTarea.value= "求封号,谢谢!"; btn.click(); } setInterval(mySend,100); }()); 需要定制发弹幕内容—请在下面留下评论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fa9cc9d224d6c61beab9b444b7cb699/" rel="bookmark">
			JS中的forEach,for in,for of和for的遍历优缺点及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 forEach：可以三个参数，第一个是value，第二个是index，第三个是数组体 1.定义：
用于调用数组的每个元素，并将元素传递给回调函数
2.缺点：
不能同时遍历多个集合，在遍历的时候无法修改和删除集合数据，方法不能使用break，continue语句跳出循环，或者使用return从函数体返回，对于空数组不会执行回调函数。forEach不可以遍历对象，这也是它和for in的一个区别 3.优点：
便利的时候更加简洁，效率和for循环相同，不用关心集合下标的问题，减少了出错的效率 for in: 大部分用于遍历对象 1.定义：
用于循环遍历数组或对象属性，fot in循环里面的index是string类型的，代码每执行一次，就会对数组的元素或者对象的属性进行一次操作 2.缺点：
某些情况下，会出现随机顺序的遍历，因为里面的值是string类型，所以增加了转换过程，因此开销较大 3.优点：
可以遍历数组的键名，遍历对象简洁方便 for of:可遍历map，object,array,set string等 1.定义：
用来遍历数据，比如组中的值 2.优点：
避免了for in的所有缺点，可以使用break,continue和return，不仅支持数组的遍历，还可以遍历类似数组的对象，支持字符串的遍历最简洁，最直接的遍历数组的语法支持map和Set对象遍历 3.缺点：
不适用于处理原有的原生对象（原生对象是一个子集，包含一些在运动过程中动态创建的对象） for： 1.优点：
程序简洁，结构清晰，循环初始化，循环变量化，循环体和循环条件位置突出 2.缺点：
结构比while循环复杂，容易出编码错误不可以遍历对象 forEach,forof,for不能遍历对象的解决方法 把对象先转化为数组类型
//有一个对象： let obj={a:1,b:2,c:3} //用Object.keys属性转化 let obj2=Object.keys(obj) //最后就可以用来遍历了 for (let i=0;i&lt;obj2.length;i++){ console.log(obj2[i]) } //输出结果就能出来了，forEach，for of同理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46acec52423ee44627bd5dc2fe77abb1/" rel="bookmark">
			GWAS全基因组关联分析流程（BWA&#43;samtools&#43;gatk&#43;Plink&#43;Admixture&#43;Tassel）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我梳理了GWAS全基因组关联分析的整个流程，并提供了基本的命令，用到的软件包括BWA、samtools、gatk、Plink、Admixture、Tassel等，在此分享出来给大家提供参考。
一、BWA比对 1.构建索引
bwa index -a is example.fasta #构建索引 -a is算法 （BWT构造算法：bwtsw、is或rb2） 2.进行比对
bwa mem -t 6 -R '@RG\tID:foo\tPL:Illumina\tSM:example' example.fasta example_1.fq.gz example_2.fq.gz &gt; example.sam # 进行对比 mem算法 -t 运行的核数目 # -R添加头部 ID：这是Read Group的分组ID，一般设置为测序的lane ID（不同lane之间的测序过程认为是独立的），下机数据中我们都能看到这个信息的，一般都是包含在fastq的文件名中； PL：指的是所用的测序平台，这个信息不要随便写，在GATK中，PL只允许被设置为：ILLUMINA，SLX，SOLEXA，SOLID，454，LS454，COMPLETE，PACBIO，IONTORRENT，CAPILLARY，HELICOS或UNKNOWN这几个信息。如果不知道，那么必须设置为UNKNOWN。 SM：样本ID。 LB：测序文库的名字，如果上面的lane ID足够用于区分的话，也可以不用设置LB； （用GATK检测变异 其中ID,PL和SM信息是必须的）
二、samtools格式转换 1.sam格式转换为bam格式
samtools view -bS example.sam -o example.bam # -b 输出bam格式文件 -S 输入sam格式文件 2.质控
samtools view -h -b -q30 example.bam &gt; example.q30.bam # -q 比对的最低质量值 -h 输出的文件包含头部信息 -b 输出bam格式文件 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46acec52423ee44627bd5dc2fe77abb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47df484be5fc0df2f2d1f90db8e8c8be/" rel="bookmark">
			463. 判断回文链表的3种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想了解更多数据结构以及算法题，可以关注微信公众号“数据结构和算法”，每天一题为你精彩解答。也可以扫描下面的二维码关注
问题描述
请判断一个链表是否为回文链表。链表为单向无环链表
示例 1:
输入: 1-&gt;2
输出: false
示例 2:
输入: 1-&gt;2-&gt;2-&gt;1
输出: true
反转后半部分链表
这题是让判断链表是否是回文链表，所谓的回文链表就是以链表中间为中心点两边对称。我们常见的有判断一个字符串是否是回文字符串，这个比较简单，可以使用两个指针，一个最左边一个最右边，两个指针同时往中间靠，判断所指的字符是否相等。
但这题判断的是链表，因为这里是单向链表，只能从前往后访问，不能从后往前访问，所以使用判断字符串的那种方式是行不通的。但我们可以通过找到链表的中间节点然后把链表后半部分反转（关于链表的反转可以看下432，剑指 Offer-反转链表的3种方式），最后再用后半部分反转的链表和前半部分一个个比较即可。这里以示例2为例画个图看一下。
最后再来看下代码
public boolean isPalindrome(ListNode head) { ListNode fast = head, slow = head; //通过快慢指针找到中点 while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } //如果fast不为空，说明链表的长度是奇数个 if (fast != null) { slow = slow.next; } //反转后半部分链表 slow = reverse(slow); fast = head; while (slow != null) { //然后比较，判断节点值是否相等 if (fast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47df484be5fc0df2f2d1f90db8e8c8be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b2d48347d56c574210b9adc46a3f92/" rel="bookmark">
			简单对接抖音小店的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司需要对接抖音小店的接口。然后其实对接起来还是蛮简单的，不过自己阅读文档的能力还有点问题，所以这里记录一下开发遇到的问题。
文档地址：https://op.jinritemai.com/docs/guide-docs/6/14
首先是需要准备的配置。
抖音小店的整个流程分两步，第一步先获取他们的access_token，因为调用接口的时候需要附带这个token作为url的参数去调用的，不然会报错。然后第二步就是上面说的再去正式调参。
所以我的做法是写了一个定时每隔10分钟去调用一次token。官方文档找不到了，所以我就贴下自己的方法，下图。
拿到了token保存到缓存就可以写接下来的代码了。
https://op.jinritemai.com/docs/guide-docs/10/23
官方文档说他们接口get，post都能调用。我也试了确实可以。调用接口的时候主要碰到的问题是拼参数的问题。因为我开始为了偷懒，就直接用字符串拼接了，但是他们的param格式是Map&lt;String, String&gt; 的字符串 {"id": "0"}，所以在拼的时候就很容易出错。因为你要拼成这种格式需要这样写string param = "{\"id\": \"0\"}";。参数一个还行，多了就很容易出错，所以推荐用map然后转jsonObject再转字符串。这样就不会出错了。
然后我也推荐用treeMap去做为容器去装。因为treeMap再插入值的时候会对key进行排序。因为官方文档说明了param需要key从小到大排序，而treeMap也满足了这点要求。
然后抖店接口还有个sign值的参数。他是由很多参数加到一起然后加密的一个字符串，然后这个sign值在调用接口的时候是需要一同带过去的。
然后这个requestStr在拼接的时候也是需要将他的key值从大到小去排序。下面是加密方式，这个官方文档也是有的。
然后得到上述这些就可以去调用抖店的接口了。下面贴个简单的订单列表接口实例（其实确实蛮简单的，但是坑还是有的）
流程就是先拿到token，再拿到当前时间（其实好像不是当前时间也可以），然后根据他的method, param, date去获取sign（/order/list就是这个接口的api，然后order.list就是接口的method，文档都有：https://op.jinritemai.com/docs/api-docs/15/55）
然后我这里json和date做了下转换是因为参数怕会有什么特殊字符，所以要转义一下。
然后就可以拼好url了（url + param）然后用http请求就行。
全部代码：
package com.xxx.mall.core.utils; import com.alibaba.fastjson.JSONObject; import com.xxx.mall.common.DoudianConstant; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import java.io.UnsupportedEncodingException; import java.math.BigInteger; import java.net.URLEncoder; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.TreeMap; public class DouDianUtils { /** * 抖店接口域名 */ private static final String DOUDIAN_URL = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99b2d48347d56c574210b9adc46a3f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ccbb86c1791838b1e191bf521bb4b0/" rel="bookmark">
			java计算字符串形式的百分数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java计算字符串形式的百分数 使用到了NumberFormat和DecimalFormat类
public static void main(String[] args) throws ParseException { String a = "5%"; String b = "6%"; String c = sumprecent(a,b); System.out.println(c); } private static String sumprecent(String num1,String num2) throws ParseException { //接受字符串类型的百分数 NumberFormat nf=NumberFormat.getPercentInstance(); //将double类型的量转化为字符串输出 DecimalFormat df = new DecimalFormat("0%"); //用NumberFormat的parse方法和doubleValue方法将字符串百分数转换为double类型的可计算数值 double sum = nf.parse(num1).doubleValue()+nf.parse(num2).doubleValue(); //再将double转为String输出 String result = df.format(sum); return result; } 结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b831f05c174723228daa91f040e651f0/" rel="bookmark">
			Android Studio 4.1 有些插件报错无法使用 Plugin “*“ is incompatible (supported only in IntelliJ IDEA).
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 Plugin “Smalidea” is incompatible (supported only in IntelliJ IDEA).
Plugin “FindViewByMe” is incompatible (supported only in IntelliJ IDEA).
插件尚未更新，无法使用。但是在 Plugins 里也看不到这两个插件，无法卸载。
解决办法 在 C:\Users\Administrator\AppData\Roaming\Google\AndroidStudio4.1\plugins 下找到对应插件。删除即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5dfb74151d9da822dd259148e11167b/" rel="bookmark">
			十分钟搞懂Pytorch如何读取MNIST数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文用于记录使用pytorch读取minist数据集的过程，以及一些思考和疑惑吧…
正文 在阅读教程书籍《深度学习入门之Pytorch》时，文中是如此加载MNIST手写数字训练集的：
train_dataset = datasets.MNIST(root='./MNIST',train=True,transform=data_tf,download=True) 解释一下参数
datasets.MNIST是Pytorch的内置函数torchvision.datasets.MNIST，通过这个可以导入数据集。
train=True 代表我们读入的数据作为训练集（如果为true则从training.pt创建数据集，否则从test.pt创建数据集）
transform则是读入我们自己定义的数据预处理操作
download=True则是当我们的根目录（root）下没有数据集时，便自动下载。
如果这时候我们通过联网自动下载方式download我们的数据后，它的文件路径是以下形式：
其中我们所需要的文件主要在raw文件夹下
train-images-idx3-ubyte.gz: training set images (9912422 bytes) train-labels-idx1-ubyte.gz: training set labels (28881 bytes) t10k-images-idx3-ubyte.gz: test set images (1648877 bytes) t10k-labels-idx1-ubyte.gz: test set labels (4542 bytes) 接下来，书中是如此加载数据集的
train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=5, shuffle=True) 由于DataLoader为Pytorch内部封装好的函数，所以对于它的调用方法需要自行去查阅。
我在最开始疑惑的点：传入的根目录在下载好数据集后，为MNIST下两个文件夹，而processed和raw文件夹下还有诸多文件，所以到底是如何读入数据的呢？所以我决定将数据集下载后，通过读取本地的MINIST数据集并进行装载。
首先，自定义数据类来继承和重写Dataset抽象类
class DealDataset(Dataset): """ 读取数据、初始化数据 """ def __init__(self, folder, data_name, label_name,transform=None): (train_set, train_labels) = self.load_data(folder, data_name, label_name) # 其实也可以直接使用torch.load(),读取之后的结果为torch.Tensor形式 self.train_set = train_set self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5dfb74151d9da822dd259148e11167b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9774eafbd5a8bee89ebff5fa9ec6e4ea/" rel="bookmark">
			Vue数据驱动之(三)render方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue数据驱动之render方法 这个课程必须是在 Vue数据驱动之mount方法 方法之后 render是什么 mount方法里面我们知道 核心的地方
let updateComponent = () =&gt; { vm._update(vm._render(), hydrating) } 在initMixin() 里面有 initRender(vm) 方法 在这里对render进行了定义，render是绑定在Vue原型上的一个方法
render 源码分析 Vue.prototype._render = function (): VNode { const vm: Component = this const { render, _parentVnode } = vm.$options if (_parentVnode) { vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ) } // set parent vnode. this allows render functions to have access // to the data on the placeholder node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9774eafbd5a8bee89ebff5fa9ec6e4ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dcbb7720db2067cd7e5c52a1eb53503/" rel="bookmark">
			Vue数据驱动之(二)mount方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 是通过 $mount 实现挂载的 那么这个 $mount 都做了什么呢？ mount的定义是在 platform 里面web 文件下的 ,
Vue 本身的东西会在core里面 但是一旦和环境相关的 会在platform里面生成各种版本的 Vue文件 比如 weex环境下的 或者web 环境下的 ， 在weex下就没有这个mount的方法 所以 会在 platform下面 查看这个mount 的方法
这里的mount是将 原来公共的mount 赋值给const mount 然后重新定义了一个mount
类似代码
function Vue () { this._init() } // 公共的mount方法 Vue.prototype.$mount = function () { return mountComponent(this, el, hydrating) } // 在环境中 const newMount = Vue.prototype.$mount Vue.prototype.$mount = function () { // todo some thing // 执行自己特殊的mount配置，之后执行公共的mount return newMount.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dcbb7720db2067cd7e5c52a1eb53503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0d4c51ef9f5cb45cd4c31f5121ea60/" rel="bookmark">
			IBM支持网站（WAS８.５.５）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.ibm.com/support/knowledgecenter/SSEQTP_8.5.5/com.ibm.websphere.base.doc/ae/rprs_custom_properties.html#CookieSameSite
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d27c2a55609010d8d29626f805ffb808/" rel="bookmark">
			Html中的video标签视频在浏览器中不能自动播放问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：video标签上添加 muted=“muted”属性
示例代码：
&lt;video controls="controls" autoplay="autoplay" muted="muted"&gt; &lt;source src="movie.mp4" type="video/mp4" /&gt; &lt;/video&gt; 原因：浏览器限制有声音的视频即使添加自动播放属性autoplay也不能直接播放，添加muted意为静音播放即可实现自动播放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7e886c39ac2a684de9d441576e79d9/" rel="bookmark">
			IIS反向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IIS反向代理 1. 安装插件
a.http://www.iis.net/downloads/microsoft/application-request-routing#additionalDownloads
b.http://www.iis.net/downloads/microsoft/url-rewrite#additionalDownloads
2.关闭重新打开IIS
3.添加网站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fd7f2728ae97a33523bc6e6a504e3f/" rel="bookmark">
			教你怎样将RS422转成RS485接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RS232接口是一种用于近距离(最大30-60米)、慢速度、点对点通讯的通讯协议，在RS232中一个信号只用到一条信号线，采取与地电压参考的方式，因而在长距离传输后，发送端和接收端地电压有出入，容易造成通讯出错或速度降低。
RS485/422接口采用不同的方式：每个信号都采用双绞线(两根信号线)传送，两条线间的电压差用于表示数字信号。例如把双绞线中的一根标为 A(正)，另一根标为B(负)，当A为正电压(通常为+5V)，B为负电压时(通常为0)，表示信号“1”;反之，A为负电压，B为正电压时表示信号 “0”。RS485/422允许通讯距离可达到1200米，采用合适的电路可达到2.5MB/s的传输速率。
RS422与RS485采用相同的通讯协议，但有所不同：RS422通常作为RS232通讯的扩展，它采用两根双绞线，数据可以同时双向传递(全双工)。 RS485则采用一根双绞线，输入输出信号不能同时进行(半双工)，RS485可用于多点通讯，一条信号线上可连接多个设备，它通常采用主/从结构。
在DM系列的转换器中，仅用到COM端口的3根线：TXD，RXD，GND(它们分别是D型接口的3脚，2脚和5脚)，TXD为信号输入线，RXD为信号输出线，GND为地。
在RS485(半双工)通信中，发送信号时，由TXD输出的RS232信号经发送器(A和B)输出，转换为RS485信号;接收信号时，RS485信号经接收器(A和B)接收并转换为RS232信号，传给RXD。
在RS422(全双工)通信中，因信号的输入和输出分开，所以需要两根双绞线来分别传送输入和输出信号，标为A、B、Y、Z(A为输入信号的正极(RX+)，B为输入信 号的负极(RX-)； Y为输出信号的正极(TX+)，Z为输出信号的负极(TX-))。发送信号时，由TXD输出的RS232信号经发送器(A和B)输出，转换为RS485/RS422 信号;接收信号时，RS485/RS422信号经接收器(Y和Z)接收后传给串口的RXD。 特别说明：RS422转RS485，将A和Y短接(接收+和发送+)，将B和Z短接(接收-和发送-)；
图1：DM系列RS232/RS485/RS422接口转换器原理图(半双工)
图2：DM系列RS232/RS485/RS422接口转换器原理图(全双工)
二、典型接法
DM485的输出端最多可以连接256个RS485接口，其典型接法如图3(半双工)和图4(全双工)所示。在最远的两个终端上，输入和输出端之间各需接 上一个120欧姆的电阻。在RS485/RS422的接口连接时，甲接口的输出端接乙接口的输入端，双绞线的正极接正极，负极接负极;甲接口的输入端接乙 接口的输出端，双绞线的正极接正极，负极接负极。
图3：DM485H(半双工)的典型接法
图4：DM485F(全双工)的典型接法
三、具体应用
DM485系列转换器的一端为9芯D型接口，可直接与RS232标准接口连接;另一端为接线端子，即RS485/RS422接口。在RS485接口(半双 工)中接线端子上用了2组引脚：两组输入(B，A，两组内部短接，系统扩展用)。转换器通过D型接口与RS232标准串口相连，通过接线端子与RS485 接口相连。在RS422接口(全双工)中接线端子上用了三组引脚：一组输出(Y，Z)，两组输入(B，A，两组内部短接，扩展用)。转换器通过D型接口与 RS232标准串口相连，通过接线端子与RS485/RS422接口相连。
图5：DM485H的具体应用接线图
图6：DM485F具体应用接线图
四、注意事项
1、在长距离传输中，一定要使用用双绞线
2、多终端传输时，距离最远的两个终端上，输入和输出端之间一定连接120欧姆的电阻。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f1e0baf4db28ad558481bf0397eefd/" rel="bookmark">
			反编译OD工具OllyDBG 2.0.1下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ollydbg是一款专业的反汇编调试工具，主要用于一些应用程序的编译操作，软件最擅长分析函数过程、循环语句、API调用、函数中参数的数目和import表等等，非常容易上手，现在己代替SoftICE成为当今最为流行的调试解密工具了.
只要解压运行OllyDbg.exe即可。
http://kk04.cn/f-6913.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd80f5fcf3820fbfa7ba8aea1b288221/" rel="bookmark">
			IDEA tomcat中deployment点击&#43;号没有出现artifcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始做publiccms的项目，导入项目时发现
IDEA tomcat中deployment点击+号没有出现artifcat
解决办法如下：
1.进入Project Structure--Project Settings 2.点击Modules然后点击+号，然后选择publiccms项目即可。
如果以上的办法不行，可以试试如下的办法
1.进入Project Structure--Project Settings 2.点击Artifacts然后点击+号，选择Web Application exploded 然后选择from Modules即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9219cb699fc06e2d06c7ff98df9e1d8/" rel="bookmark">
			基于Tensorflow 三层神经网络拟合二次函数（附代码与解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、隐藏层函数二、生成二次函数与损失函数 1.二次函数与画图2.损失函数三、训练数据总结 前言 刚入手深度学习，结合这几天看的视频与内容，将其整合成文章
提示：以下是本篇文章正文内容，下面案例可供参考
一、隐藏层函数 生成隐藏层函数 1.权重W，2.偏执b 3.激活函数。隐藏层输出为activate_function(wx+b) def add_layer(inputs,in_size,out_size,activation_function=None): Weights = tf.Variable(tf.random_normal(shape=[in_size,out_size])) biases = tf.Variable(tf.zeros([1,out_size])+0.1) Wx_b = tf.matmul(tf.cast(inputs,tf.float32),Weights)+biases if activation_function==None: outputs=Wx_b else: outputs = activation_function(Wx_b) return outputs 二、生成二次函数与交叉损失函数 1.二次函数 代码如下（示例）：
x_data = np.linspace(-1,1,300)[:,np.newaxis] #在（-1，1）之间生成300个数据点，[300,1] noise = np.random.normal(0,0.02,x_data.shape) #利用np库 均值为0，方差为0.05 与x_data的大小相同 y_data = np.square(x_data)-0.5+noise 2.交叉损失函数 代码如下（示例）
在此过程中，如果你使用的是Tensorflow2.0需要将函数进行相应的变换
#定义占位符，更好的进行训练 定义shape 与 dtype xs = tf.placeholder(shape=[None,1],dtype=tf.float32) ys = tf.placeholder(shape=[None,1],dtype=tf.float32) #添加隐藏层 和输出层 #l1 = add_layer(xs,1,10,activation_function=tf.nn.relu) l1 = add_layer(xs,1,10,activation_function=tf.nn.sigmoid) #print('l1:',l1) prediction = add_layer(l1,10,1,activation_function=None) #定义损失函数 按列求和 利用梯度下降算法使得loss最小 loss = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9219cb699fc06e2d06c7ff98df9e1d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a48eba7350176b8dd05c0ca7fe11c291/" rel="bookmark">
			登录模块 用户认证 SpringSecurity &#43;Oauth2&#43;Jwt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringSecurity Oauth2 jwt SpringSecurity Oauth2 jwt1 用户认证分析1.1 单点登录1.2 第三方账号登录 2 认证解决方案2.1 单点登录技术方案2.2 第三方登录技术方案2.2.1 Oauth2认证流程2.2.2 Oauth2在项目的应用 2.3 Spring security Oauth2认证解决方案 3 Jwt令牌回顾3.1 令牌结构3.2 生成私钥公钥3.3 基于私钥生成jwt令牌3.3.1导入认证服务3.3.2 认证服务中创建测试类 3.4 基于公钥解析jwt令牌 4 Oauth2.0入门4.1 准备工作4.2 Oauth2授权模式介绍4.2.1 授权码模式4.2.1.1 授权码授权流程4.2.1.2 申请授权码4.2.1.3 申请令牌4.2.1.4 令牌校验4.2.1.5 刷新令牌 4.2.2 密码模式4.2.2.1 申请令牌 4.3 资源服务授权4.3.1 用户服务对接Oauth24.3.2 资源服务授权测试 5 认证开发5.1 需求分析5.2 Redis配置5.3 认证服务5.3.1 认证需求分析5.3.2 授权参数配置5.3.3 申请令牌测试5.3.4 业务层5.3.5 控制层5.3.6 登录请求放行5.3.7 测试认证接口5.3.8 动态获取用户信息5.3.8.1 定义被访问接口5.3.8.2 放行该接口，修改ResourceServerConfig类5.3.8.3定义feign接口5.3.8.4 认证服务添加依赖5.3.8.5 修改认证服务启动类5.3.8.6 修改用户认证类 6 认证服务对接网关6.1 新建网关工程changgou_gateway_web6.2 网关全局过滤器 7 自定义登录页面7.1 认证服务添加依赖7.2 资源\成品页面\登录页面7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a48eba7350176b8dd05c0ca7fe11c291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc9cff36d546fbb63e8efcb2b74c029/" rel="bookmark">
			如何理解图像处理领域的不适定/病态问题（ill-posed problem）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ill-posed problem，我们可以理解为病态问题或者不适定问题。在本文中，统一成为不适定问题。
在讨论不适定问题（ill-posed problem）之前，我们先来看一下什么叫适定性问题（well-posed problem）。
适定性问题这是在数学领域里提出的一个概念。我们先来看下Wikipedia的解释：
数学术语适定性问题来自于数学家阿达马（英文: Jacques Solomon Hadamard）所给出的定义。他认为物理现象中的数学模型应该具备下述性质：
存在解解是唯一的解随着起始条件连续的改变 再来看一下百度百科的解释：
经典的数学物理方程定解问题中，人们只研究适定问题。适定问题是指定解满足下面三个要求的问题：
解是存在的；解是唯一的；解连续依赖于定解条件，即解是稳定的。 因此我们可以发现这三个要求中，只要有一个不满足，则称之为不适定问题。特别，如果条件3不满足，那么就称为阿达马意义下的不适定问题。一般地说不适定问题，常常是指阿达马意义下的不适定问题。在经典的数学物理中，人们只研究适定问题。
在图像处理领域，我们经常看到论文中提到某个问题是ill-posed，即无法同时满足上述三个条件，一般来说不满足第二条或者第三条。比如以图像超分辨为例（示图见文章末尾，来自SRCNN），对于输入的低分辨率图像，输出高分辨率的图像，这并没有一个标准的答案，有很多个解，且这些解并不稳定。
再举一个例子说明，比如我们希望通过低动态范围（LDR）图像生成高动态范围（LDR）图像，在这个过程中，由于图像中的过曝区域和欠曝区域存在大量的信息缺失，因此要通过算法预测出其中缺失的信息，这个问题即为ill-posed problem。
Jaeyoung Yoo在CVPR2018的论文中这样描述图像恢复的不适定问题：
In most cases, there are several possible output images corresponding to a given input image and the problem can be seen as a task of selecting the most proper one from all the possible outputs.That is, the image restoration problem can be formulated as the problem of estimating the distribution conditioned on the input image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc9cff36d546fbb63e8efcb2b74c029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc5fc2b671c0fc6e2d65e59be027a84/" rel="bookmark">
			element修改el-table 表头的背景颜色横向渐变色 &#43;  修改表头背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue + element-ui 修改el-table 表头的背景颜色横向渐变色 + 修改表头背景颜色 表头背景颜色横向渐变效果图：
修改表头背景颜色和字体颜色效果图：
直接上代码：
修改表头的背景颜色横向渐变色的代码
html：
&lt;template&gt; &lt;div&gt; &lt;el-table :data="tableData" border&gt; &lt;el-table-column prop="date" label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; js：
&lt;script&gt; export default { data () { return { tableData: [{ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' }] } } } &lt;/script&gt; css：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bc5fc2b671c0fc6e2d65e59be027a84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d47bbc6f2a852db3b582b8f9bce3bab/" rel="bookmark">
			生产服务内存泄露排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、排查过程 前言 生产环境，我们使用rancher k8s部署我们的服务，有个服务（具体我这里就不说了），在晚上8点左右，因为这个服务的内存溢出导致了其他服务出现了异常，在8点的时候，客户频繁投诉，后面排查发现是有个服务内存泄露。通过grafana图形观察，可以明显看到其实这个服务在早市11点左右其实已经内存泄露，只是当时客户并没有发现。
一、排查过程 因为生产已经挂了，当时我们进入服务的pod中简单执行如下命令。不要问为什么这么做，其实这个内存泄露问题已经出现过几次了，但是不知道问题点在哪，刚好这次复现，就赶紧找到罪魁祸首
jps -lm jmap -histo 6| head -20 先找到占用内存最大的实体类
有
还好，当时这个服务用到的FineBiEquipmentFeign比较集中，这个是提供数据给报表服务用的。
找到代码如下
/*** * type:1.设备历史参数查询报表 2.设备历史参数查询趋势图 * @return */ @RequestMapping(value = "/selectItem", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity selectItem(@RequestBody FineBiEquipmentQuery fineBiQuery) { try { log.info("getEndTime========={}" + fineBiQuery.getEndTime()); log.info("getBeginTime========={}" + fineBiQuery.getBeginTime()); long period = (Long.parseLong(fineBiQuery.getEndTime()) - Long.parseLong(fineBiQuery.getBeginTime())) / 1000; log.info("period========={}" + period); Map&lt;String, Object&gt; maps = new HashMap&lt;&gt;(16); SimpleDateFormat sf = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d47bbc6f2a852db3b582b8f9bce3bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e09d5e1641e958ef5f9ae1c28858866/" rel="bookmark">
			【conda】解决 An HTTP error occurred when trying to retrieve this URL.问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 conda安装第三方包，出现网络报错信息如下 Collecting package metadata (current_repodata.json): failed An HTTP error occurred when trying to retrieve this URL. HTTP errors are often intermittent, and a simple retry will get you on your way. 原因是conda源加入了不知名的URL，现在不能使用了（或者废弃）
解决方法 #重置源配置 conda config --remove-key channels #重新添加清华源 &gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --set show_channel_urls yes 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa47993bdce2145f98ee743370e3d5a6/" rel="bookmark">
			FFmpeg工具（三） --- ffplay常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在FFmpeg中通常使用ffplay作为播放器，其实ffplay同样也可作为很多音视频的图形化分析工具，通过ffplay可以看到视频图像的运动估计方向、音频数据的波形等，以下将介绍更多参数并举例说明。
可回顾FFmpeg中ffmpeg，ffprobe见以下链接。
FFmpeg工具（一） — ffmpeg视频处理命令行大全
FFmpeg工具（二） — ffprobe常用命令
FFmpeg工具（三） — ffplay常用命令
ffplay常用命令行参数 ffplay不仅仅是播放器，同时也是测试ffmpeg的codec引擎、format引擎，以及filter引擎的工具，并且还可以进行可视化的媒体参数分析。
1、查看详细的帮助信息
ffplay -help 以下展示ffplay基础帮助信息
参数说明x强制设置视频显示窗口的宽度y强制设置视频显示窗口的高度s设置视频显示的宽高fs强制全屏显示an屏蔽音频vn屏蔽视频sn屏蔽字幕ss根据设置的秒进行定位拖动t设置播放视频/音频的长度bytes设置定位拖动的策略，0为不可拖动，1为可拖动，-1为自动nodisp关闭图形化显示窗口f强制使用设置的格式进行解析window_title设置显示窗口的标题af设置音频的滤镜codec强制使用设置的codec进行解码autorotate自动旋转视频 2、从视频的30s开始播放，播放10s的文件，则用如下命令：
ffplay -ss 30 -t 10 input.mp4 3、自定义播放器窗口显示标题
ffplay -window_title "hello world" input.mp4 4、打开网络直播流
ffplay -window_title "网络直播流" rtmp://.... ffplay高级参数 ffplay高级参数如下表：
参数说明ast设置将要播放的音频流vst设置将要播放的视频流sst设置将要播放的字幕流stats输出多媒体播放状态fast非标准化规范的多媒体兼容优化sync音视频同步设置可根据音频时间、视频时间或者外部扩展时间进行参考autoexit多媒体播放完毕之后自动退出ffplay,ffplay默认完毕之后不退出播放器exitonkeydown当有按钮按下事件产生时退出ffplayexitonmousedown当有鼠标按下事件产生时退出ffplayloop设置多媒体文件循环播放的次数framedrop当cpu资源占用过高时，自动丢帧infbuf设置无极限的播放器buffer，这个选项常见于实时流媒体播放场景vf视频滤镜设置acodec强制使用设置的音频解码器vcodec强制使用设置的视频解码器scodec强制使用设置的字幕解码器 5、从20s播放一个视频，时长10s，播放完成自动退出ffplay，可以使用系统命令time查看命令运行时长：
time ffplay -winow_title "hello" -ss 20 -t 10 -autoexit input.mp4 6、播放视频时加载字幕文件，可以通过加载ASS或者SRT字幕文件来解决，下面列举一个加载SRT字幕的例子，首先编辑srt字幕文件，内容如下：
1 00:00:01.000 --&gt; 00:00:10.000 这是我 我是谁 2 00:00:10.001 --&gt; 00:00:20.000 我爱中国 3 00:00:20.001 --&gt; 00:00:30.000 为人民服务 然后通过filter将字幕文件加载到播放数据中，使用命令如下：
ffplay -window_title "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa47993bdce2145f98ee743370e3d5a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf918adeb73ec8afb04f01d06b31dba/" rel="bookmark">
			iphone屏幕上的圆圈怎么设置_iphone怎么投屏到mac上 iphone投屏到mac方法【详解】...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iphone如何投屏到mac上?相信小伙伴们一定很好奇，下面小编为大家带来了iphone投屏到mac方法教程说明，感兴趣的小伙伴赶紧跟着小编一起来看看吧。
iphone投屏到mac教程：
iphone和mac的使用人群越来越多,其中投屏功能却难倒了大部分新手用户,许多使用iPhone以及Mac的用户朋友都还不知道iPhone怎么投屏到mac,其实很简单,好奇的用户朋友马上点击查看iphone投屏到mac教程来实现这个具有科技革新感的功能吧。
官方推荐
方法1：用数据线
- 1.使用lightning线缆将iPhone和Mac连接;
- 2.在Mac上打开 QuickTime;
- 3.里面选择视频来源为iPhone 就可以看到实时画面;
方法2：用airplay
- 1.Mac上必须安装 Air play server服务端才可以实现;
- 2.安装好之后启用服务;
- 3.在iPhone的控制中心 选择airplay 就可以看到Mac了;
- 4.要求两台设备必须在同一个WiFi下;
网友方法
方法1：
- 1.打开QuickTime player;
- 2.点文件—新建影片录制;
- 3.出现你的脸后，按录制按钮旁边的选项，选iphone名字;
- 4.前提是数据线连上，而且OS X 10.10以上。
方法2：
- 1.首先确保你的iPhone和Mac连接到同一个局域网中，并且在你的Mac上安装AirServer这款软件;
- 2.Mac安装完成以后。查看你的iPhone，会看到一个AirPlay的选项;
- 3.点击打开后，选择你要投射的mac电脑，就可以在Mac上面显示你的手机屏幕了。
更多精彩资讯关注IT百科。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edb25751ea926d1543ef5976cc314b6/" rel="bookmark">
			双指针的应用   求两个有序数组（从小到大）的第k小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前有一篇文章写到了。两个有序数组求中位数。现在若是求两个有序数组（从小到大）的第k小了
vector nums1{1,5,9,10,21};
vector nums2{2,3,6,7};
第四小应该是5
其实我们用i,j双指针指向两个不同的数组就可以了，然后比较指针指向的数组中元素的大小，取小的就行了。注意我们先取第k-1小的，再取k小的。方便代码抒写。
#include &lt;iostream&gt; #include&lt;vector&gt; using namespace std; //求两个排序数组（从小到大）的第k的小的数 class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2,int k) { int len1 = nums1.size(); int len2 = nums2.size(); if (k&lt;0||k&gt;len1+len2) { return -1; } int i, j; i = j = 0; int count = 0; while (count&lt;k-1)//退出循环条件就是 count=k-1 这就是第k个元素 { if (i&lt;len1&amp;&amp;j&lt;len2&amp;&amp;nums1[i]&gt;nums2[j]) { j++; count++; } else if(i &lt; len1&amp;&amp;j&lt;len2&amp;&amp;nums1[i]&lt;nums2[j]) { i++; count++; } else if(i &lt; len1)//证明nums2已经全部遍历完了 { i++; count++; } else// if(j&lt;len2) //证明nums1已经遍历完了 { j++; count++; } } if (i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9edb25751ea926d1543ef5976cc314b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7b5aa86e47cf3b728d2e555ee7afa7/" rel="bookmark">
			手机卡开机界面，无法进入rec，但可以进入fastboot，解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想直接看解决方法见总结即可
2020.10.13：记一件小事。今晚官改miui日常升级呢，电脑上玩着玩着，手机还没开机继续打一会csgo人机，打完还没开机，一看一直卡在redmi界面，不对劲！一般开机redmi界面完后，应该会展示开机动画的，我这个都进不去开机动画。开始测试
特征 无法进入recovery模式：长按电源键与音量加键，手机震动一下，亮屏又是这个redmi界面，有时候放着也会自动这样重启，就是循环卡在了这个开机界面。此时如果插上电源，指示灯会变成红色，应该表示在充电。因为也没有开启usb调试所以无法测试是否可调试。本还想着是不是magisk模块导致的问题，后面验证了也不是。毕竟我并没有添加什么新的“优化”模块。然后网上搜了一下，并没有啥有意义的答案，都是套话。 后面突然想起来好像没试过fastboot模式（Bootloader模式）。于是试了一下：长按电源键与音量减键，出现了可爱的小兔子。能进，这就好办了。
再刷一下recovery分区，重新引导进recovery。
成功刷入，并且成功引导到recovery模式，出现了TWRP的开始界面这下不就又可以愉快搞机嘛。
不料进了recovery后又自动按照openrecoveryscript脚本刷入原来的刷机包（刷机包已经确认过md5是正确的，一般md5错误的包经常会错误代码7），但是一想，为何不再试一次？ 22:24刷完，开始重启；22:30，系统正式亮屏。。。。真有你的，真是玄学 总结 所以循环卡开机界面，无法进入recovery模式，但是能进fastboot的话，可以使用fastboot再次刷一次recovery并重新进入即可，进入了recovery模式，又是可以随意搞机的小机子了。如果是官方原系统的话，大同小异，提取出官方recovery，在fastboot重新刷一下即可。（请注意下面的注意事项） 什么，然后呢？然后在recovery分区刷入你的可用的刷机包，没有的话传进去一个（官方rec可以传东西吗，不知道，或许吧）
当然，如果不是第三方rec的话（官方系统，没解过BL锁），直接在fastboot模式下，在电脑上用相应软件刷机就好了（即线刷）
除非真的是自己的什么大物理操作（比如掉水里）导致的，千万不要轻信换主板的鬼话（太贵了！），先自己试一试
注意事项：以上建立在已解锁BootLoader的情况下（只有这样才能动recovery分区或者线刷）较新的机器一般都会有BootLoader锁，旧的一般还没有。
如果有BootLoader而未解锁的高通机器也可以尝试9008端口强刷recovery。其他的无能为力（具体自行百度，我没试过）
怎么知道有没有BootLoader锁：可以在网上搜，也可以在官方社区里看，比如小米的https://www.xiaomi.cn/，可以在MIUI下载里，随便点一个机型进去，在下载按钮右边有刷机教程，在左边的线刷方式可以看到所有机型有无BL锁信息。–&gt; 所有小米手机BootLoader锁信息
BootLoader延伸 引用知乎问答 刷recovery需要解锁bootloader吗：
作者：Paul Yang
bootloader如果锁了，fastboot、recovery情境下都不能擦写启动分区，但是可以绕过这两个途径去刷，高通用9008端口刷第三方rec可以启动第三方rec，因为有的手机bootloader不校验rec分区的签名。
如果BL锁了，即使你强行刷了非官方boot，因为BL会校验boot分区的数字签名，所以无法加载Android内核到RAM，也就无法启动system。
bootloader是不是加锁，完全取决于厂家的策略，加锁的原理是修改某个指定分区指定位置的数值，BL在启动时检测这个数值来判断锁定状态，这个值通常有四个：锁locked、不锁unlocked、重新锁relocked、完全不锁critical unlocked。
bootloader到底在哪，bootloader是好几个启动阶段的统称，bootloader与电脑的启动管理器相似，负责启动手机的用户层面操作系统，对于高通手机来说，负责启动Linux内核的是aboot，fastboot程序在aboot分区里，recovery则是加载rec分区的Linux内核之后启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681ab57d50f3c0cd844c287f6526b3e9/" rel="bookmark">
			FFmpeg工具（二） --- ffprobe常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 FFmpeg套件中，除了ffmpeg作为多媒体处理工具之外，还有ffprobe多媒体信息查看工具，ffprobe主要用来查看多媒体文件的信息，下面是ffprobe中常见的基本命令。
FFmpeg工具（一） — ffmpeg视频处理命令行大全
FFmpeg工具（二） — ffprobe常用命令
FFmpeg工具（三） — ffplay常用命令
ffprobe常用命令行参数 1、查看详细的帮助信息
ffprobe -help 2、查看多媒体数据包信息 show_packets
ffprobe -show_packets input.mp4 通过show_packets查看的多媒体数据包信息使用标签括起来，其中包含的信息主要为：
字段说明codec_type多媒体类型，如视频包、音频包等stream_index多媒体的stream索引pts多媒体的显示时间值pts_time根据不同格式计算过后的多媒体的显示时间dts多媒体的解码时间值dts_time根据不同格式计算过后的多媒体解码时间duration多媒体占用的时间值duration_time根据不同格式计算过后的多媒体所占用的时间值size多媒体包的大小pos多媒体所在的文件偏移位置flags多媒体包标记，如关键包与非关键包的标记 除了以上字段和信息之外，还可以通过以下组合参数来查看包中的具体数据：
ffprobe -show_data -show_packets input.mp4 3、查看多媒体的封装格式 show_format
ffprobe -show_format input.mp4 通过show_format查看的多媒体数据包信息使用标签括起来，其中包含的信息主要为：
字段说明filename文件名nb_streams媒体中包含的流的个数nb_programs节目数format_name使用的封装模块的名称format_long_name封装的完整名称start_time媒体文件的起始时间duration媒体文件的的总时间长度size媒体文件的大小bit_rate媒体文件的码率 4、查看视频文件中的帧信息 show_frames
ffprobe -show_frames input.mp4 通过show_frames查看的视频文件中的帧信息使用标签括起来，其中包含的信息主要为：
属性说明值media_type帧的类型（视频、音频、字幕等）videostream_index帧所在的索引区域0key_frame是否为关键帧1pkt_ptsFrame包的pts23100pkt_pts_timeFrame包的pts的时间显示38.500000pkt_dtsFrame包的dts80pkt_dts_timeFrame包的dts的时间显示0.080000pkt_durationFrame包的时长20pkt_duration_timeFrame包的时长时间显示0.03333pkt_posFrame包所在文件的偏移位置344width帧显示的宽度544height帧显示的高度960pix_fmt帧的图像色彩格式yuv420ppict_type帧类型I 帧/ P帧 / B帧pkt_size每帧的大小 5、查看多媒体文件中的流信息 show_streams
ffprobe -show_streams input.mp4 通过show_streams查看的视频文件中的帧信息使用标签括起来，其中包含的信息主要为：
属性说明值index流所在的索引区域）0codec_name编码名h264codec_long_name编码全名MPEG-4 part 1profile编码的profileHighlevel编码的level31has_b_frames包含B帧信息1codec_type编码类型videocodec_time_base编码的时间戳计算基础单位1/60codec_tag_string编码的标签数据avc1pix_fmt图像显示的色彩格式yuv420pcoded_width图像的宽度544coded_height图像的高度960r_frame_rate实际帧率30/1avg_frame_rate平均帧率30/1time_base时间基数（用来进行timestamp）1/600bit_rate码率1197127max_bit_rate最大码率N/Anb_frames帧数1156 6、以上显示方式是键值对的方式显示，ffprobe支持多种显示格式显示，包括xml,json,flat等等。下面列举常见的格式输出的例子：
ffprobe -of json -show_streams input.mp4 // 以json显示方式 ffprobe -of xml -show_streams input.mp4 // 以xml显示方式 7、使用select_streams可以只查看音频(a)、视频(v)、字幕(s)的信息，例如配合show_frames查看视频的frames的信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681ab57d50f3c0cd844c287f6526b3e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a9ef5748294c82ef783cdca113fe2b/" rel="bookmark">
			CSS-事件 -单击双击、失去or获得焦点、加载事件、鼠标事件、键盘事件、选择与改变、表单事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CSS事件 1.点击事件 1.1 onclick:单击事件 1.2 ondblclick:双击事件 2.焦点事件 2.1 onblur: 失去焦点 2.2 onfocus: 元素获得焦点 3.加载事件 onload: 一张页面或一幅图像完成加载。
4.鼠标事件 4.1 onmousedown 鼠标按钮被按下 4.2 onmouseup 鼠标按钮被松开 4.3 onmousemove 鼠标被移动 4.4 onmouseover 鼠标被移动到某个元素上 4.5 onmouseout 鼠标从某元素移开 5.键盘事件 5.1 onkeydown 某个键盘按键被按下 5.2 onkeyup 某个键盘按键被松开 5.3 onkeypress 某个键盘按键被按下并松开。 6.选择和改变 6.1 onchange 域的内容被改变 6.2 onselect 文本被选中 7. 表单事件 7.1 onsubmit 确认按钮被点击 7.2 onreset 重置按钮被点击 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5639b441832aaa58c6c98c410d427652/" rel="bookmark">
			设计模式之桥接模式（Bridge模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模式动机 设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：
• 第一种设计方案是为每一种形状都提供一套各种颜色的版本。
• 第二种设计方案是根据实际需要对形状和颜色进行组合。
对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。
当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。
二、桥接模式的定义 桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。通过上面的讲解，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。
结构如下：
桥接模式包含如下角色：
• Abstraction：抽象类
• RefinedAbstraction：扩充抽象类
• Implementor：实现类接口
• ConcreteImplementor：具体实现类
三、具体实例 实例一：模拟毛笔
• 现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。
/// &lt;summary&gt; /// 定义颜色类接口 /// &lt;/summary&gt; public interface Color { void bepaint(String penType, String name); } /// &lt;summary&gt; /// 定义笔抽象类 /// &lt;/summary&gt; public abstract class Pen { protected Color color; public void setColor(Color color) { this.color = color; } public abstract void draw(String name); } //扩充抽象类 public class SmallPen : Pen { public override void draw(String name) { String penType = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5639b441832aaa58c6c98c410d427652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ea80b7967d79776160966ac13ae2e2/" rel="bookmark">
			uiscrollview  取消顶部默认间距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UIScrollView* scollView = [UIScrollView new];
scollView.contentInset = UIEdgeInsetsZero;
if (@available(iOS 11.0, *)) {
scollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
} else {
// Fallback on earlier versions
}
if (@available(iOS 13.0, *)) {
scollView.automaticallyAdjustsScrollIndicatorInsets = YES;
} else {
// Fallback on earlier versions
}
self.automaticallyAdjustsScrollViewInsets = NO;
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/204/">«</a>
	<span class="pagination__item pagination__item--current">205/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/206/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>