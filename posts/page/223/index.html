<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f25bf6e2680f385bb2b543dfc711331/" rel="bookmark">
			安装mathtype到word2013遇到错误提示“The MathType Dll cannot be found.”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我遇到的问题是word提示“The MathType Dll cannot be found.”
网上有三种方法，一是删除C:\Users\AppData\Roaming\Microsoft\Word\STARTUP文件夹，我试过没用；
二是复制MathPage.wll文件到“D:\Program Files\Microsoft Office\Office16”中粘贴，替换，也不行；
三是，直接默认路径安装即可，可以！不要尝试改变路径安装，我就是这样，然后出现以上错误，谨记。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b43843c914cd5e5df8476ef87708cbb/" rel="bookmark">
			机器人抓取领域相关数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“3D视觉工坊”，选择“星标”
干货第一时间送达
前言
针对机器人抓取中的检测、分割、姿态识别、抓取点检测、路径规划等任务，总结了对应的数据集，在这里分享下，数据格式为类别+数量。
一、检测任务
PASCAL VOC：20类，11540
SUN：908类，131,072
MS COCO：91类，328,000
Places：434类，10 millions
Open Images：6000类，9 millions 二、分割任务 PASCAL VOC 2012 Segmentation：21类，2913
PASCAL-Context：540类，19,740
PASCAL-Part：20类，19,740
SBD：21类，11,355
MS COCO：80类，204,721
DAVIS：4类，8422
三、姿态识别任务 LineMod：15类，1100+ frame video sequences
T-LESS：30类，49K images
PU-APC：24类，10000 images
YCB-Video：21类，92 RGB-D videos
四、抓取点检测 Standford Grasping：10 object，13747 RGB Images，13747 Depth Images
Cornell Grasping：240 object，885 RGB Images，885 Depth Images
YCB Benchmarks：77 object，46200 RGB Images，46200 Depth Images
CMU dataset：150+object，50567 RGB Images
Google dataset：800000 RGB Images
Dex-Net 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b43843c914cd5e5df8476ef87708cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45c5b71b7849d988fa2ff7878ffd2e8/" rel="bookmark">
			切换Git账号-用户名/密码/邮箱-git基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
切换Git账号-用户名/密码/邮箱
方法1-更改用户名
方法2-更改用户名和密码
git基本命令
切换Git账号-用户名/密码/邮箱 方法1-更改用户名 查看用户名
git config user.name 查看用户名
git config user.email 修改用户名和邮箱的命令
git config --global user.name "userName" git config --global user.email "userEmail" 方法2-更改用户名和密码 在控制面板里找到凭据管理器-编辑-重新输入账号密码
git基本命令 # 添加文件 git add readme.txt # 提交当前仓库所有文件到暂存区 git add . git commit -m "注释" # 查看历史提交记录 git log # 回退到上一个版本 git reset --hard HEAD^ # 根据版本id git reset --hard id前几位 git reflog 用来记录你的每一次命令 # 查看远程仓库地址 git remote -v 查看git 安装目录: 打开cmd,输入where git 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae63073152969aa158b07c2d7fb421f/" rel="bookmark">
			Java 用函数的模块化思想来设计程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习Java中的函数之前，大家是否了解了点函数了呢？无论有没有了解过函数，接下来就看看我一个Java小白对函数的理解吧
为什么要有函数呢？ 软件工程的中心目标之一是程序的模块化和可重用性，Java中提供的了一些有助于完成这目标的有效结构，这种结构就叫做函数或方法。
当然Java中也有自带的常用函数（点击~~&gt;常用函数，即可查看）以下主要介绍的是程序员自定义的函数：
下面介绍函数在Java中的结构(即语法)： public static void main(String[] args){ 函数体; } 这是Java初学者遇到的第一个函数，我们称它为main函数（主函数）；
让我们看看这个函数是由什么构成的：
函数的权限 public主函数是公开权限（最大权限）
函数的状态类型 static主函数是静态函数
函数的返回值类型 void该函数没有返回值
函数名 main主函数的名称
括号内的是参数（可以是一个，也可以是多个） String[] 表示的是一个字符串数组(数据类型)
args 就是这个数据类型的变量名称
函数体{}内 是函数具体执行的部分执行到最后会由return；来结束函数，也称函数的弹栈（这是函数栈性执行的特点，在下文中会详细介绍）。如果后面跟着一个返回值（若没有返回值，return可以省略），那么函数弹栈时会有返回值返回到调用的函数中（函数之间的调用在下文详细介绍）
所以函数的结构组成就是：
权限 状态类型 返回值类型 函数名(参数){
函数体;
return 返回值;
}
了解了函数结构后那我们就来敲代码吧！！（体现一下函数的作用） 来编写一个能算的值的程序，其中a为任意实数，x为任意整数，代码可以算出任意个值。
在没学函数之前我们会将代码都写在main函数中,代码如下：
如果我们要在程序结束前算多个值，就需要重复写多次相似的代码，程序看上去就会比较繁杂
class Demo{ public void main(String[] args){ //算2^4 double a = 2; int x = 4; double sum = 1; if(x==0 &amp;&amp; a!=0){ System.out.println(1); return; } for(int i = 1;i&lt;=x;i++){ sum = sum*a; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae63073152969aa158b07c2d7fb421f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73f24d835ef74c631dd225157b8e796/" rel="bookmark">
			什么是幻读？以及如何解决幻读问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号ITwords，了解更多的java，大数据的相关知识，大家一起学习，一起进步。 为了便于说明问题，这一篇文章，我们就先使用一个小一点儿的表。
CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE=InnoDB; ​ insert into t values(0,0,0),(5,5,5), (10,10,10),(15,15,15),(20,20,20),(25,25,25); 这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。
下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？
begin; select * from t where d=5 for update; commit; 比较好理解的是，这个语句会命中d=5的这一行，对应的主键id=5，因此在select 语句执行完成后，id=5这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。
由于字段d上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的5行记录上，会不会被加锁呢？
我们知道，InnoDB的默认事务隔离级别是可重复读，所以本文接下来没有特殊说明的部分，都是设定在可重复读隔离级别下。
幻读是什么？
现在，我们就来分析一下，如果只在id=5这一行加锁，而其他行的不加锁的话，会怎么样。
下面先来看一下这个场景（注意：这是我假设的一个场景）：
可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3。它们的SQL语句相同，都是select * from t where d=5 for update。这个语句的意思你应该很清楚了，查所有d=5的行，而且使用的是当前读，并且加上写锁。现在，我们来看一下这三条SQL语句，分别会返回什么结果。
Q1只返回id=5这一行；
在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行；
在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行。
其中，Q3读到id=1这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。
这里，我需要对“幻读”做一个说明：
在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。
上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d73f24d835ef74c631dd225157b8e796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a3fac065f927b28972b2e3aba2033e/" rel="bookmark">
			gazebo中仿真双目相机(stereo camera)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：在gazebo中为px4添加相机，可以参考这篇 博客
1、仿真环境 仿真环境为 ROS-Academy-for-Beginners
环境搭建过程参考：https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/chapter1/1.5.html
2、双目相机 sdf文件 &lt;!-- stereo camera --&gt; &lt;gazebo reference="camera_link"&gt; &lt;sensor type="multicamera" name="stereocamera"&gt; &lt;always_on&gt;true&lt;/always_on&gt; &lt;update_rate&gt;10&lt;/update_rate&gt; &lt;visualize&gt;false&lt;/visualize&gt; &lt;camera name="left"&gt; &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt; &lt;horizontal_fov&gt;1.047&lt;/horizontal_fov&gt; &lt;image&gt; &lt;width&gt;320&lt;/width&gt; &lt;height&gt;240&lt;/height&gt; &lt;/image&gt; &lt;clip&gt; &lt;near&gt;0.1&lt;/near&gt; &lt;far&gt;100&lt;/far&gt; &lt;/clip&gt; &lt;/camera&gt; &lt;camera name="right"&gt; &lt;pose&gt;0 -0.07 0 0 0 0&lt;/pose&gt; &lt;horizontal_fov&gt;1.047&lt;/horizontal_fov&gt; &lt;image&gt; &lt;width&gt;320&lt;/width&gt; &lt;height&gt;240&lt;/height&gt; &lt;/image&gt; &lt;clip&gt; &lt;near&gt;0.1&lt;/near&gt; &lt;far&gt;100&lt;/far&gt; &lt;/clip&gt; &lt;/camera&gt; &lt;plugin name="stereo_camera_controller" filename="libgazebo_ros_multicamera.so"&gt; &lt;cameraName&gt;stereocamera&lt;/cameraName&gt; &lt;alwaysOn&gt;true&lt;/alwaysOn&gt; &lt;updateRate&gt;10&lt;/updateRate&gt; &lt;cameraName&gt;stereocamera&lt;/cameraName&gt; &lt;imageTopicName&gt;image_raw&lt;/imageTopicName&gt; &lt;cameraInfoTopicName&gt;camera_info&lt;/cameraInfoTopicName&gt; &lt;frameName&gt;camera_link_optical&lt;/frameName&gt; &lt;baseline&gt;0.07&lt;/baseline&gt; &lt;distortion_k1&gt;0.0&lt;/distortion_k1&gt; &lt;distortion_k2&gt;0.0&lt;/distortion_k2&gt; &lt;distortion_k3&gt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74a3fac065f927b28972b2e3aba2033e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/207379843f22ec53a8c81428bce4a04b/" rel="bookmark">
			Visual Studio 2015软件安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio 2015软件安装教程 Visual Studio 2015下载：安装步骤： Visual Studio 2015下载： Visual Studio2015/64位下载地址：
链接：https://pan.baidu.com/s/1azil2LxX9OcF5byaaKpaAg
提取码：05o1
安装步骤： 1.安装前注意一下自己电脑的IE浏览器是不是10 版本及以上的，如果不是要先升级到10才能安装 Visual Studio2015。打开IE浏览器，点击【设置】接着点击【关于】即可查看。
2.鼠标右击软件压缩包，选择解压到【Visual Studio2015】。
3.双击打开【Visual Studio2015】文件夹。
4.双击打开【安装包】。
5.选中【vs_professional】后，鼠标右击选择【以管理员身份运行】。
6.安装程序初始化（大概需要3分钟）。
7.更改软件安装路径：建议安装到除C盘以外的磁盘，可在D盘或其它盘里面新建一个文件夹【VS2015】,安装类型默认，点击【安装】。
8.安装中（大约需要30分钟）
9.安装完成，点击【启动】。
10.点击【以后再说】。
11.点击【启动Visual Studio】。
12.软件成功启动。
13.点击菜单栏中的【帮助】按钮，点击【注册产品】。
14.选择【使用产品密钥解锁】。
15.在解压出的文件夹中找到并打开【激活码】。
16．按照对应的版本Ctrl+C复制后，Ctrl+V粘贴至【产品密钥】处，然后点击【应用】。
17.激活成功，点击【关闭】。
18.关闭并重启软件，点击左下角的菜单栏，在菜单栏中找到并打开【Visual Studio2015】用鼠标按住【Visual Studio2015】不放往桌面上拖动即可创建快捷方式。
19.安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c99081c0d2ee065bb72e4abe9817e5b/" rel="bookmark">
			【Git学习】3步将GitHub上的项目clone到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：Windows
下载安装Git 下载包可以从官网下载，嫌速度慢可以在软件管家下载。下载后安装，一直点击next就可以了，选择editor的时候我选择的是visual studio code，如果想知道每一步操作意义的，可以参考Git安装教程（详细）。
配置Git 需要在本地配置用户名和邮箱，参数–global意思是全局都使用这个配置，配置命令如下
git config --global user.name "你的用户名"//配置用户名 git config --global user.email "你的email"//配置email 将项目clone到本地 接下来我将项目clone到本地c盘Git目录下。
首先在C盘新建一个叫Git文件夹（名字自己随意取）,然后进入到该目录下，最后将项目克隆到本地，命令如下
cd c: \\打开c盘 cd Git \\打开Git目录 git clone https://github.com/...... \\将项目克隆到本地 其中https的地址获取方式如下图
最终结果，克隆成功，并且可以在指定目录下看到项目文件夹
欢迎关注，一起学习。有用点个赞吧！
公众号：一个甜甜的大橙子
知识星球：知识的朋友（免费）
知乎：一个甜甜的大橙子
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a777c2ca6c8b98c4024d5046c79b71/" rel="bookmark">
			vs2017黑窗口闪退（空项目）——可能是项目建错了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见方法 在工程上右键—&gt;属性—&gt;配置属性—&gt;连接器—&gt;系统—&gt;子系统（在窗口右边）—&gt;下拉框选择控制台(/SUBSYSTEM:CONSOLE)
由于建立的是空项目 每次新建一个空项目就需要重新设置属性
如何彻底解决 ：直接建立控制台应用程序（空项目） 具体步骤如下
点击确定即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e976617e5b1945778a27e9221b92e9b4/" rel="bookmark">
			《Python编程：从入门到实践》第十五章：生成数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成数据 关于matplotlib的更多信息可以访问： https://matplotlib.org/gallery/index.html
一、安装matplotlib 在OS X系统中安装matplotlib 使用Homebrew安装：
pip3 install --user matplotlib 测试matplotlib 首先使用命令python3启动终端绘画，再尝试导入matplotlib：
$ python3 &gt;&gt;&gt; import matplotlib &gt;&gt;&gt; 如果没有出现任何错误信息，就说明你的系统安装了matplotlib。
二、绘制简单的折线图 只需向matplotlib提供如下数字，matplotlib就能完成其他的工作：
import matplotlib.pyplot as plt squares = [1, 4, 9, 16, 25] plt.plot(squares) plt.show() 模块pyplot包含很多用于生成图表的函数
plt.show()打开matplotlib查看器，并显示绘制的图形。
查看器能够缩放和导航图形，单击磁盘图标可将图形保存起来。
修改标签文字和线条粗细 参数linewidth决定了plot()绘制的线条的粗细。
函数title()给图标指定标题。
参数fontsize指定了图表中文字的大小。
函数xlabel()和ylabel()为每条轴设置标题。
import matplotlib.pyplot as plt squares = [1, 4, 9, 16, 25] plt.plot(squares, linewidth=5) #设置图标标题，并给坐标轴加上标签 plt.title("Squares Numbers", fontsize=24) plt.xlabel("Value", fontsize=14) plt.ylabel("Square of Value", fontsize=14) #设置刻度标记的大小 plt.tick_params(axis='both', labelsize=14) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e976617e5b1945778a27e9221b92e9b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc8720e9b8aef44123867fac11c6f61/" rel="bookmark">
			idea的jrebel插件激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/flyrock/archive/2019/09/23/11574617.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b53bb718a2fd6a454a6f8bdf6b3d73d/" rel="bookmark">
			如何批量生成包含图片路径为txt文件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，运行C++的目标跟踪算法时，需要生成一个包含图片集所有图片路径的txt文件，看了网上许多方法，发现一个非常便捷的方法，来自百度经验，原文如下：https://jingyan.baidu.com/article/84b4f5655f4f4e60f6da32e8.html
自己动手尝试后，在这里介绍一下，方便大家一起学习，如有侵权，请告知，将立即删除。
1、为什么需要生成所有图片路径的txt文件？ 刚接触C++的目标跟踪代码时，我也是相当疑惑，但这是一种非常无奈的方法，电脑似乎无法实现一张一张图片的读取，要实现整个文件夹下所有图片集的读取，只能将所有路径都写在同一个txt文件中。
如果不想用txt来记录图片的路径，也可以利用字符串的拼接，就是给每个图片数字编号，然后将图片对应的数字与对应的路径合并成一个字符串，再进行读取，也是可以的。
2、生成包含图片路径的txt文件的方法 2.1将所有图片放在同一文件夹下，并在该文件夹下新建一个txt文本，随便起个名字。
2.2打开txt文本，输入“dir/s/b *.jpg&gt;图片路径.txt”，图片路径是生成的txt文本的名字，可以改成自己需要的名字。我这里输入的如下
2.3修改image.txt的后缀，改成image.bat.出现警告，点击“是”。
2.4双击image.bat文件，自动生成一个新的txt文件，里面即包含文件夹下所有图片的路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a083931d399e4a1cab95d9cc953554/" rel="bookmark">
			疫情下的大数据力量：多地政府借力大数据技术，多家企业上马大数据产品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当心！
几十万“3M口罩”全是假货！可能会携带病毒细菌！（点击这里查看详情）“世上有两样东西不能直视，一是太阳，二是人心。”生死之间，利益之前，最不可低估的就是人性的恶。
大数据产业创新服务媒体
——聚焦数据 · 改变商业
目录精要
①武汉火神山医院利用天翼云大数据检测疫情
②潍坊市大数据局积极做好疫情防控保障工作
③银川借助大数据实时监测疫情高风险人群
④广西运用大数据信息化技术辅助防控疫情
⑤福建龙岩市利用神州数码控股推出的大数据平台抗“疫”
⑥四川乐山利用德生科技“大数据服务”大力防控疫情
⑦广州黄埔区萝岗街道，用大数据让社区疫情防控“耳聪目明”
⑧浙江嘉兴以“大数据+网格化”抗击疫情
⑨陇南武都创新线上疫情防控 大数据平台连接你我他
⑩南昌运用大数据识别重点防控区域及高危人群
⑪海口市利用“大数据”技术，服务管理返工高峰期旅客
⑫江西省抚州市临川区政府利用大数据分析系统 加强社区精细化防控
⑬上海、成都、资阳等21个城市，利用国寿与万达信息的 “大数据”能力开启防疫攻坚战
⑭北京西罗园防控疫情，民情图大数据成为好帮手
⑮人民网研究院与百度APP联合发布《新型冠状病毒肺炎搜索大数据报告》
⑯方便用户获取疫情信息 百度依托“搜索+大数据”设多个栏目
⑰同程艺龙大数据助力疫情防控，小程序、APP均上线新型肺炎确诊同行程查询服务
⑱马蜂窝发布春运返程大数据，疫情之下客流高峰下降明显
⑲荣之联利用大数据、基因科技助力国家疫情防控
⑳大数据助力疫情狙击，艾媒数据中心全国免费开放
1、武汉火神山医院利用天翼云大数据检测疫情
在严峻的形势下，天翼云基于自身积累的大数据服务能力，积极响应疫情相关部门的需求，发挥全国数据集约优势，紧急在全国范围内部署大数据应用解决方案，利用大数据分析能力，为相关部门提供疫情防控所需的监测数据，力保数据支撑的准确性和有效性。
除了大数据，大带宽、低时延的5G网络也在新型冠状病毒感染肺炎远程会诊中发挥作用。1月26日，基于中国电信四川公司5G双千兆网络，四川省卫生健康委组织四川大学华西医院与成都市公共卫生临床医疗中心成功完成了两例新型冠状病毒感染肺炎急重症患者的远程会诊，这也是全国首次针对该疾病的5G远程会诊。四川医疗救治专家组组长、四川大学华西医院院长李为民等专家参与会诊，并为病患治疗提出指导意见。全省27家定点医院，通过会诊系统在线进行观摩学习。中国电信相关负责人告诉新京报记者，此举充分利用5G高带宽、低时延特性，实现5G助推新型冠状病毒感染肺炎的远程会诊，在目前疫情防控形势下，让诊疗更加高效便捷。
天翼云表示，公司的云服务系统还将在武汉“小汤山”火神山医院落地。近日，武汉火神山医院正在紧急筹备建设中，为了保障新建医院业务系统能够快速、稳定上线使用，武汉市卫健委采用了中国电信天翼云资源部署业务系统。如今，该项目正在顺利推进中，天翼云也已通过绿色通道提前将武汉火神山医院升级为VIP，第一时间响应相关需求，推动系统快速上线，为防疫工作争取更多时间。早在1月21日，中国电信武汉分公司已经将新型冠状病毒疫情抗击指挥中心——武汉市卫健委官方网站迁移至中国电信天翼云，确保抗击新型冠状病毒疫情指挥信息畅通。
2、潍坊市大数据局积极做好疫情防控保障工作
新型冠状病毒感染的肺炎疫情爆发以来，潍坊市大数据局严格按照市委、市政府要求，迅速展开行动、主动担当作为，积极做好疫情防控各项保障工作。
成立工作组，统一领导疫情保障工作。抽调工作骨干，第一时间成立了应对新型冠状病毒肺炎疫情保障工作组，确保全市各级电子政务网络畅通、政务云平台安全运行、协同办公系统稳定可靠和“中国潍坊”门户网站舆情引导及时等，推进决策命令、疫情信息、公文传输等畅通传达，保证全市各级各部门防控工作的顺利进行。保障网络畅通，确保疫情防控工作指令的高效传达。
办公网络保障。自1月23日以来，按照市疫情防控指挥部的要求，紧急为其办公区域连通了电子政务网的公共服务域和行政服务域，并逐一对办公电脑、打印机等办公设备进行安装调试，及时保证了指挥部办公软、硬件的正常运转。安排专人，随叫随到，第一时间处理网络、打印设备等故障，全时做好网络保障，确保了疫情防控指挥中枢工作的顺利开展。
视频会议保障。1月27日晚，调整测试阳光大厦至市级机关办公大楼直达光纤网络并连接卫生应急专线网络，安装设备、寻线、接线和测试等。凌晨1点，圆满完成专网调通任务，确保了第二天国家、省至市卫健委专网视频会议正常使用。30日下午，全市疫情防控工作领导小组视频会议召开，该局安排网络运维人员提前赴会场检查保障，并驻会场随时待命，应对突发情况，确保会议的顺利召开。
立足政务新媒体，多点进行防疫知识宣传引导。政府门户网站。在市政府门户网站开设“全力做好新型冠状病毒疫情防控工作”潍坊专题，设立防控动态、通知公告、防控知识、视频报道等栏目，及时报道我市疫情发展和防控动态，发布政府有关通知公告，转发医学防控知识，发挥市政府网站政务公开、关切热点和舆论引导的职能作用，提醒和号召广大市民共同做好防疫相关工作。
“潍事通”APP。在“潍事通”上线抗击新型肺炎疫情专题，提供在线实时数据、防护问答、科普知识等服务，还结合人工智能技术，聚合疫情智能分析、新型肺炎智能筛查、疫情智能问答、用药智能问答等功能，广大居民可以足不出户，了解疫情发展动态，做好防护工作，根据自己的症状，智能筛查是否感染新型肺炎，是否需要进行自我隔离或尽早就医。
筑牢疫情防控后防线，确保协同办公高效运转。成立运维服务保障团队，制定了应急保障预案，建立平台双机运行机制，加强服务器巡检，提前预判处置，全力保障平台服务器正常运行和移动办公畅通，及时接听并答复各类办公应用咨询，每日下午5:00点前形成办公平台运行情况报告，做好平台日常运转监测、确保系统稳定运行。在应对疫情关键时期，协同办公平台稳定运行为各单位内部公文流转提供了有力平台支撑，移动办公系统为省市各级文件及时传达，确保各级政令畅通提供了基础保障。
面对当前疫情防控形势的复杂严峻情况，潍坊市大数据局将进一步提高政治站位，强化责任担当，立足自身职能，继续做好疫情防控保障工作，以实际行动助力全市打赢疫情防控阻击战。
3、银川借助大数据实时监测疫情高风险人群
宁夏银川市借助大数据建立了新型冠状病毒感染的肺炎疫情可视化模型和高风险人群数据分析模型。2月1日，《银川市肺炎疫情及高风险人群数据可视化分析报告》（以下简称《分析报告》）正式发布。
根据银川市卫健委通报的宁夏新型冠状病毒感染的肺炎确诊数据及相关信息，银川市协调北京、上海相关临床医学和大数据专家，针对新型冠状病毒“人群普遍易感，有基础疾病的老年人病情较重”的客观情况，利用现有基层医疗卫生数据，对全市新型冠状病毒感染的肺炎疫情建立了疫情可视化模型和高风险人群数据分析模型。
银川市智慧城市运营管理指挥中心（银川市委宣传部供图）
该模型部署在银川市智慧城市运营管理指挥中心，以基层云HIS实时就诊信息为依据，以热力图的方式展示银川市不同区域高风险人群、呼吸系统疾病患病人群密集度分布情况，实时监测全市高风险人群健康状况，及时掌握第一手情况，划明重点监测区域，协助相关医疗部门对疫情进行及时防控。
《分析报告》提醒患有糖尿病、高血压、心血管疾病、终末期肾病、肺源性心脏病、自身免疫病、慢性阻塞性肺疾病、恶性肿瘤等疾病的高风险人群，每2-4周要去附近医疗机构就诊取药。这是增加新型冠状病毒肺炎感染的危险因素之一，建议基层单位加强防控措施的宣传和实施，防止疫情进一步扩大。
尤其提醒慢性阻塞性肺疾患、肺源性心脏病患者，慢性基础病就是肺部疾病，因此呼吸道的抵抗力更差，在呼吸道传染病方面风险更大。除了强调一般的防护措施，规范使用日常的呼吸疾病用药，有病情变化需要及时就诊，以免延误病情。
《分析报告》是银川市委网信办、市网信局、市大数据产业服务中心联合北京大数据研究院-北大医信健康医疗大数据实验室银川中心和汇天下（银川）大数据有限公司共同发布的。
4、广西运用大数据信息化技术辅助防控疫情
自治区大数据发展局高度重视12345政府服务热线在疫情防控中所发挥的“消息网”作用，服务热线平台工作人员与联络员一直坚守岗位。截至1月28日，全区12345热线接到关于新型冠状病毒感染的肺炎疫情相关咨询、报料、求助电话2484个。
其中，咨询类热线来电约占13.8%，市民主要咨询疫情最新情况、各类传言真实性、当地政府对疫情的相关举措、捐赠物资渠道等信息；举报类来电约占21.4%，主要是举报来路不明的武汉车牌车辆、武汉返邕人员出现疑似症状、武汉人员密集聚集等信息；投诉类来电居多，约占总数的42.5%，部分药店口罩价格上涨的投诉增长明显；求助类来电主要以湖北籍来邕人员无处入住的求助为主，约占4%。
自治区大数据发展局运用大数据等信息化技术手段，主动做好疫情防控大数据分析工作。除了12345政府服务热线外，第一时间组织技术专家赴自治区卫生健康委对接数据需求，归集自治区公安厅、教育厅、交通厅、住建厅等14个单位相关数据，运用大数据技术综合统计分析，基本掌握病源地进入广西的相关数据，为防止疫情扩散、有效网格化防控提供大数据支撑。同时通过广西政府门户网站“广西政府互联网+督查”平台向全社会征集疫情防控不力、缓报瞒报的线索和加强改进的建议；在广西政府门户网站开设“全力抗击新型冠状病毒感染的肺炎疫情”专题。
自治区大数据发展局相关负责人表示，将继续强化对疫情数据进行归集和分析，描绘疑似人群的迁徙布局和热力图，对风险人群流动做到最大限度监控，辅助做好疫情防控工作。
5、福建龙岩市利用神州数码控股推出的大数据平台抗“疫”
新型冠状病毒肺炎疫情发生后，神州数码控股有限公司（下称：神州数码控股）第一时间发起抗疫生态联盟，携手生态伙伴不断探索以创新技术助力打赢疫情防控攻坚战。日前，在福建省，神州数码控股旗下因特睿基于荣获2018年度国家技术发明奖一等奖技术成果转化的燕云DaaS打破信息孤岛，以共建共治共享模式助力打赢疫情防控攻坚战。
神州数码控股旗下公司建设运营的e龙岩平台紧急开发、上线了“新型冠状病毒肺炎防控信息服务平台”，目前已推出8项相关服务，可供市民了解、查询相关信息，享受在线义诊，并开通疫情线索申报渠道，便于市民发现疫情线索及时上报、有关部门及时处置。
如今，福建龙岩市民如果想咨询或反映有关疫情方面的问题，可通过e龙岩的“随手拍”或“疫情防控信息服务平台”等多个便捷渠道进行反映。这些问题将统一汇总到12345平台进行处置，平台能答复的立即给予答复，涉及专业问题无法答复的，将及时转给相关部门进行快速处置。
针对市民通过“随手拍”反馈的购买口罩的需求，政府部门快速响应民意，根据口罩资源到位情况，率先在武平县上线了口罩预约平台。从2月1日0点上线开始，第一期9018个可预约口罩在2小时内，全部预约完毕。当天上午，记者随有关部门一起回访定点口罩售卖点，现场秩序井然，未出现扎堆购买现象。
据悉，该模式于2月3日8：00在福建省三明市上线。相较于传统自上而下单向管理的政府治理模式，神州数码控股在这些城市将市民纳入城市治理的体系中，将以前分离的市民“上报”与政府“处置”连成一体，并增加了反馈机制保障服务质量和效率，形成了公共服务闭环。不仅仅是建立为民办事的大数据平台，而是利用大数据技术连接起市民、城市和政府，使得政府可以更好地了解市民的需求、城市的状态，市民也能够参与到城市建设治理的方方面面，成为城市真正的主人，从而构建起一种共建共治共享的治理格局。
6、四川乐山利用德生科技“大数据服务”大力防控疫情
近期以来，全民抗击新型冠状病毒感染的肺炎疫情迎来关键时刻，地区间的人口流动为疫情防控带来诸多挑战。近日，国内领先的社保卡综合运营服务商德生科技处，正在运用大数据技术加入到四川乐山等地的疫情防控工作当中。
据悉，四川作为对外输送劳动力大省，在武汉封城之前，从武汉返回四川的人口平均流入比率甚至要高于北上广深等大城市，防控疫情较为严峻。在四川省乐山市疫情防控应急指挥中心的指导下，乐山市数字经济发展局等相关政府部门48小时内不眠不休，两天建成乐山公共突发事件大数据分析系统，让大数据为疫情防控做好支撑。
据介绍，在上述大数据疫情防控工作中，德生科技组织核心开发力量及本地服务团队，与全资子公司四川德生数字科技有限公司一起，快速投入到系统建设中，发挥了重要的服务支持作用。
对此，德生科技相关负责人表示，公司主要是发挥在大数据汇总、清洗、筛查、分析等方面的能力，为政府提供有效的排查、疑似、确诊等数据跟踪结果，助力各相关部门精准疫情防控。
乐山市相关疫情防控工作人员表示，这次疫情隐蔽性强，能控制到现在的水平，除了各级政府的行政能力，大数据分析也起了很大的作用。比如，四川在没有确诊病例时就开始启动应急机制，就是依靠大数据分析的支撑。在病毒二代、三代传染期间，输入型感染者的活动圈要锁定、接触人群要锁定、感染者活动圈与接触人群同样要锁定，这些工作只有大数据分析才能做到。未来，在疫情结束后，还需要继续做好大数据的分析，除了对感染人群的后遗症追踪，还要考虑对社会生活影响的分析。比如，中小企业的生存状况、企业职工的生存状态、患病者的生存状态等等，为政府科学决策提供支撑，及时消弭疫情对社会的长期影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a083931d399e4a1cab95d9cc953554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fe014fff967e478d26ca6f9b39c71a/" rel="bookmark">
			@SuppressWarnings(&#34;resource&#34;)作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 实例
@SuppressWarnings(“resource”)
public static void main(String[] args){
Scanner input =new Scanner(System.in);
写代码时 input 警告加上这个就没了
2. 原因
@SuppressWarnings 批注允许选择性地取消特定代码段（即，类或方法）中的警告。其中的想法是看到警告时，将调查它，如果确定它不是问题，可以添加一个 @SuppressWarnings 批注，以使不会再看到警告。
有了suppresswarning这个批注，可以取消一些特定代码段中的警告，比如你看到警告，你查了一下，发现他不是问题，可是你为了好看又不想让他报警，就可以加这个批注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1028f3742ae6dea492908f23af196bfa/" rel="bookmark">
			error: &#39;cout&#39; does not name a type|
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我真傻，真的，我单知道c++输出时要头文件#include和using namespace std，我居然忘了还要加int main（）。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d085a893d401f132a205f5bae1e5f814/" rel="bookmark">
			电脑自启动项目关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行——misconfig——启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a3fc562674820f20928df0989ae7a0/" rel="bookmark">
			Linux Qt cannot find -lGL错误完美解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于很多 Linux 发行版本，Qt 安装完成后如果直接编译或者运行项目，会出现“cannot find -lGL”错误，如下图所示：
这是因为 Qt 找不到 OpenGL 的动态链接库（libGL.so）。在《Linux Qt安装》一节中我们说过，OpenGL 在大部分 Linux 发行版中都是默认安装的，包括 Ubuntu、CentOS 等，找不到该链接库一般都是路径不对。
Qt 默认在 /usr/lib/ 目录下查找动态链接库，但是很多 Linux 发行版将 OpenGL 链接库放在其它目录，例如我使用的是 CentOS 7，OpenGL 链接库位于 /usr/lib64/ 目录，而对于 Ubuntu，OpenGL 链接库位于 /usr/lib/i386-linux-gnu/mesa/ 目录。只要我们把 libGL.so 拷贝到 /usr/lib/ 目录，或者在 /usr/lib/ 目录下为 libGL.so 创建一个链接，就能解决问题。显然第二种办法更好。
另外，Linux 发行版自带的 OpenGL 链接库在后缀中添加了版本号，例如 libGL.so.1、libGL.so.1.2.0、libGL.so.1.3.1 等，但是 Qt 在链接阶段查找的 OpenGL 链接库是不带版本号的。
总起来说，我们需要在 /usr/lib/ 目录下为 OpenGL 链接库创建一个链接，并去掉版本号。
如果你不知道当前 Linux 系统中 libGL.so 的具体路径，可以使用locate libGL命令或find /usr -name libGL*命令查找，然后使用ln -s创建链接。请看下面的演示：
#查找 libGL 所在位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a3fc562674820f20928df0989ae7a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14aa3359cd39cf41be27a807e17c29ec/" rel="bookmark">
			leetcode算法题--二叉树中序遍历迭代法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原题链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
二叉树中序遍历迭代法，栈实现
vector&lt;int&gt; inorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; s; TreeNode *p = root; vector&lt;int&gt; result; TreeNode * tmp; while (!s.empty() || p != NULL){ while (p != NULL){ s.push(p); p = p-&gt;left; } tmp = s.top(); result.push_back(tmp-&gt;val); s.pop(); if (tmp-&gt;right != NULL){ p = tmp-&gt;right; } } return result; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e900fe22818d8157d14273107d55b2f/" rel="bookmark">
			Python学习：matplotlib模块——plt.tick_params参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matplotlib.pyplot.tick_params参数 axis——轴：{ ’ x ’ ，’ y ’ ，’ both ’ }
参数axis的值分别代表设置X轴、Y轴以及同时设置。默认值为 ’ both ’ 。reset——重置：布尔
如果为True，则在处理其他关键字参数之前将所有参数设置为默认值。默认值为False。which——其中：{ ‘ major ’ ，‘ minor ’ ，‘ both ’ }
参数which的值分别代表为“主要”，“次要”，“两者”。默认值为’ major '。direction / tickdir——方向： {‘in’，‘out’，‘inout’}
将刻度线置于轴内，轴外或两者皆有。size / length——长度：浮点
刻度线长度（以磅为单位）。width——宽度：浮动
刻度线宽度（以磅为单位）。color——颜色：颜色
刻度颜色；接受任何mpl颜色规格。pad——垫：浮球
刻度和标签之间的距离（以磅为单位）。labelsize——标签大小：float 或 str
刻度标签字体大小（以磅为单位）或字符串（例如，“大”）。labelcolor——标签颜色：颜色
刻度标签颜色；mpl颜色规格colors——颜色：颜色
将刻度颜色和标签颜色更改为相同的值：mpl color spec。zorder——zorder：浮动
勾选并标记zorder。bottom，top，left，right——底部，顶部，左侧，右侧：布尔
是否绘制各个刻度。labelbottom，labeltop，labelleft，labelright——标签底部，标签顶部，标签左侧，标签右侧：布尔
是否绘制各个刻度标签。labelrotation：浮动
刻度线标签逆时针旋转给定的度数gridOn——网格线：布尔
是否添加网格线grid_color——网格线颜色：颜色
将网格线颜色更改为给定的mpl颜色规格。grid_alpha——网格线透明度：浮点数
网格线的透明度：0（透明）至1（不透明）。grid_linewidth——网格线宽度：浮点数
网格线的宽度（以磅为单位）。grid_linestyle——网格线型：字符串
任何有效的Line2D线型规范。 all param： [‘size’, ‘width’, ‘color’, ‘tickdir’, ‘pad’, ‘labelsize’, ‘labelcolor’, ‘zorder’, ‘gridOn’, ‘tick1On’, ‘tick2On’,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e900fe22818d8157d14273107d55b2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5dffba9bbd0203d7e26ed99794644ec/" rel="bookmark">
			计量经济学笔记1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、经济理论模型的目的？
一个模型的目的不是接近现实。
一个模型的目的在于为理解这个世界的特定特征提供见解。
如果这种简化并未使得该模型对所探讨的问题给出不正确的答案，那么缺乏现实性是一个优点：通过更为清楚地隔离所关注的效应，这种简化使得问题更易于理解。
2、理论模型中的前提假设如何构建？
（1）假设是一种“抽象的近似真实”
例如：
无限次重复博弈模型
假设：无限次
假定捕捉到的事实：博弈方都觉得博弈在未来还要进行很多次，参与人都不知道哪一期是最后一期
（2）假设的真实性与数学上易于处理性
例如：
拉姆齐模型（基于数量固定的长生不老的家庭）
假设：人类寿命无限
虽是虚假的假设，是为了数学上易于处理，但与所研究的核心问题不冲突，反而增加洞察力。
3、假设的类型和功能
硬核假设：对理论起关键作用的假设，在形式上是理论组成的一部分，应该获得本质特征。
保护带假设：即辅助性假设，它不构成理论的一部分，但它可以通过消除实际的干扰和混乱来帮助发现事物的本质。有助于从次要原因中分离出主要原因，从次相关因素中分离出根本的关系消除和抵消次要因素而更好地关注主要因素，剥离出事物的主要原因。
4、四类样本数据
截面数据（Cross-sectional Data）
时间序列数据（Time-series Data）
平行数据（Panel Data，面板数据、综列数据）
虚拟变量数据
5、什么叫总体模型的设定？
总体设定是指从观察到的样本出发，提出关于总体假设的过程并用计量经济学模型的形式加以表述，有两种基本总体模型：
一是静态的总体模型。主要是描述经济因素之间不随时间演变的静态平衡结构，力图揭示经济系统的平衡关系法则，对应的总体是不随时间变化的静态随机分布，通常利用截面数据来估计总体模型参数。
二是动态的总体模型。主要是描述持续演变的经济因素之间的动态平衡结构，力图揭示经济系统的演变法则，对应的总体是在时间维度上持续发生的随机过程，通常利用时间序列数据来估计总体模型参数。
6、模型总体设定的依据有以下几种
（1）实际应用研究中的“研究目的导向”
（2）经典模型的“先验理论导向”
（3）时间序列模型的“数据关系导向”
（4）正在发展的“关系论导向”
7、模型总体设定的“唯一性”原则
正确的总体模型只能是一个。
对于同一个作为研究对象的被解释变量，它和所有影响因素之间只能存在一种客观的正确的关系。或者说，对于一组被解释变量样本观测值，只能由一种客观的数据生成过程生成。
不同的研究者、不同的研究目的、不同的数据选择方法、不同的数据集，会对模型的约化和简化过程产生影响，会使得最终的应用模型有所不同。但建模起点应该相同。
是对实际应用研究中的“研究目的导向”的批评。
任何应用研究都有特定的研究目的，例如分析某两个经济变量之间的关系，或者评价某项经济政策的效果。
按照特定的研究目的进行计量经济学模型总体模型的设定，成为计量经济学应用研究的普遍现象和最严重的问题。
例如：
研究制度变迁对我国经济增长影响的论文中，直接将制度变迁作为唯一解释变量进行建模。
实际上，我们应该尝试设定一个正确的总体回归模型，以达到研究制度对我国经济增长影响的目的，从中来判断出制度变迁对经济增长的影响。
8、模型总体设定的“一般性”原则
（1）作为建模起点的总体模型必须能够包容所有经过约化得到的“简洁”的模型。
它应该包含所有对被解释变量产生影响的变量，尽管其中的某些变量会因为显著性不高或者不满足正交性条件等原因在后来的约化过程中被排除。
（2）一旦总体模型被设定，利用样本数据进行的经验检验只能发现已经包含其中的哪些变量是不显著的，而不能发现没有包含其中的显著变量；只能发现已经被采用的函数关系是不恰当的，而不能发现没有被采用的正确的函数关系。
（3）如果只将一部分变量引入模型，只有在其它变量不变的条件下，模型所揭示的它们与被解释变量之间的结构关系才是正确的。“其它变量不变”的条件在现实中是无法得到满足的，所以必须将所有变量同时引入模型，因为被解释变量的变化是它们共同作用的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fc83847e74dd302fbd71a84c41caaf/" rel="bookmark">
			Qt stylesheet border-color属性，QFontMetrics Class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、border-color
border-color 属性设置四条边框的颜色。此属性可设置 1 到 4 种颜色。
border-color 属性是一个简写属性，可设置一个元素的所有边框中可见部分的颜色，或者为 4 个边分别设置不同的颜色。请看下面的例子：
border-color:red green blue pink; 上边框是红色右边框是绿色下边框是蓝色左边框是粉色 border-color:red green blue; 上边框是红色右边框和左边框是绿色下边框是蓝色 border-color:dotted red green; 上边框和下边框是红色右边框和左边框是绿色 border-color:red; 都为红色边框 二、QTextEdit文字修改行距
QTextDocument *doc = ui-&gt;textEdit_label-&gt;document(); QTextCursor textcursor = ui-&gt;textEdit_label-&gt;textCursor(); for(QTextBlock it = doc-&gt;begin(); it !=doc-&gt;end();it = it.next()) { QTextBlockFormat tbf = it.blockFormat(); tbf.setLineHeight(lineSpacing,QTextBlockFormat::LineDistanceHeight); textcursor.setPosition(it.position()); textcursor.setBlockFormat(tbf); ui-&gt;textEdit_label-&gt;setTextCursor(textcursor); } 三、想要根据文字字数，适配控件背景长度，所以需要计算字符串个数，以及单个字符宽度
如果程序不支持中文，需要设置编码
QTextCodec *codec = QTextCodec::codecForName("System"); //获取系统编码 QTextCodec::setCodecForLocale(codec); QTextCodec::setCodecForCStrings(codec); QTextCodec::setCodecForTr(codec); int tlength = msg.toLocal8Bit().length();//计算英文字符数
msg="中" tlength = 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13fc83847e74dd302fbd71a84c41caaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72d8a4ca7a7e4637cefc70e4ba0b248/" rel="bookmark">
			工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具类特征：
构造器必须是私有的，工具类一般不需要初始化，可以直接使用；工具类的方法必须是被static final方法修饰，保证方法不可变；不要在工具类方法中对共享变量有修改的操作，如果一定要有，必须加锁保证线程安全；工具类的所有方法都没有线程安全问题； 一、Arrays Arrays主要提供了对数组的高效操作，包括排序、查找、填充、拷贝、相等判断等操作；
1、sort(int[] a) 1.1、JDK1.6 1.1.1、源码 // int类型数组排序 public static void sort(int[] a) { sort1(a, 0, a.length); } private static void sort1(int x[], int off, int len) { // Insertion sort on smallest arrays if (len &lt; 7) { for (int i = off; i &lt; len + off; i++) for (int j = i; j &gt; off &amp;&amp; x[j - 1] &gt; x[j]; j--) swap(x, j, j - 1); return; } // Choose a partition element, v int m = off + (len &gt;&gt; 1); // Small arrays, middle element if (len &gt; 7) { int l = off; int n = off + len - 1; if (len &gt; 40) { // Big arrays, pseudomedian of 9 int s = len / 8; l = med3(x, l, l + s, l + 2 * s); m = med3(x, m - s, m, m + s); n = med3(x, n - 2 * s, n - s, n); } m = med3(x, l, m, n); // Mid-size, med of 3 } int v = x[m]; // Establish Invariant: v* (&lt;v)* (&gt;v)* v* int a = off, b = a, c = off + len - 1, d = c; while (true) { while (b &lt;= c &amp;&amp; x[b] &lt;= v) { if (x[b] == v) swap(x, a++, b); b++; } while (c &gt;= b &amp;&amp; x[c] &gt;= v) { if (x[c] == v) swap(x, c, d--); c--; } if (b &gt; c) break; swap(x, b++, c--); } // Swap partition elements back to middle int s, n = off + len; s = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a72d8a4ca7a7e4637cefc70e4ba0b248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f8f9a3b8960fc241ce8de842535b5b/" rel="bookmark">
			Vue基础03_v-for循环排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-for指令解决模板循环问题
v-for指令是循环渲染一组data中的数组，v-for 指令需要以 item in items 形式的特殊语法，items 是源数据数组并且item是数组元素迭代的别名。
基本用法
js写法
数组及对象排序
vue中的排序需要用到computed属性
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;v-for 实例&lt;/title&gt; &lt;script src="../assets/js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-for实例&lt;/h1&gt; &lt;hr&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;!-- 需要哪个标签循v-for环就写在哪个标签里我们把 items里的每一个变量赋予item --&gt; &lt;li v-for="item in items"&gt; {{item}} &lt;/li&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for="student in sortStudent"&gt; {{student.name}} - {{student.age}} &lt;/li&gt; &lt;/ul&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script typt="text/javascript"&gt; var app = new Vue({ el:"#app", data:{ item:[53,23,79,14,54,18], students:[ {name:'jspang',age:33}, {name:'panpan',age:28}, {name:'pande',age:25}, {name:'js',age:18}, ] }, computed:{ // computed items:function(){ return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f8f9a3b8960fc241ce8de842535b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc186f0b26fe82e1a4183f90c6dda8cc/" rel="bookmark">
			win10 你没有足够的权限执行此操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 你没有足够的权限执行此操作 在使用Windows时会有这样的提示：“你没有足够的权限执行此操作”
比如要打开一个文件或应用程序，怎么办呢？
一种是🔍命令行，打开，把文件拖进去，回车
或者：
右键，选带有“管理员”的操作选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bcd2aa7af9f370e7520957a0161ba8c/" rel="bookmark">
			vue项目中实现汉字转拼音缩写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间接到了这样一个需求，注册页面中有多个输入框，要求第一个输入框输入汉字后，第二个输入框自动填充对应的拼音开头缩写。实现思路是这样的，第一步完成拼音转汉字缩写功能，第二步为第一个输入框添加失焦事件，失焦时计算当前对应拼音缩写，如第一个输入框对应内容为空，则清空第二个输入框，具体代码如下：
完成拼音转汉字缩写功能
新建util.js并添加以下代码
export default { ConvertPinyin(l1){ //汉字库 const PinYin = { "a": "\u554a\u963f\u9515", "ai": "\u57c3\u6328\u54ce\u5509\u54c0\u7691\u764c\u853c\u77ee\u827e\u788d\u7231\u9698\u8bf6\u6371\u55f3\u55cc\u5ad2\u7477\u66a7\u7839\u953f\u972d", "an": "\u978d\u6c28\u5b89\u4ffa\u6309\u6697\u5cb8\u80fa\u6848\u8c19\u57ef\u63de\u72b4\u5eb5\u6849\u94f5\u9e4c\u9878\u9eef", "ang": "\u80ae\u6602\u76ce", "ao": "\u51f9\u6556\u71ac\u7ff1\u8884\u50b2\u5965\u61ca\u6fb3\u5773\u62d7\u55f7\u5662\u5c99\u5ed2\u9068\u5aaa\u9a9c\u8071\u87af\u93ca\u9ccc\u93d6", "ba": "\u82ad\u634c\u6252\u53ed\u5427\u7b06\u516b\u75a4\u5df4\u62d4\u8dcb\u9776\u628a\u8019\u575d\u9738\u7f62\u7238\u8307\u83dd\u8406\u636d\u5c9c\u705e\u6777\u94af\u7c91\u9c85\u9b43", "bai": "\u767d\u67cf\u767e\u6446\u4f70\u8d25\u62dc\u7a17\u859c\u63b0\u97b4", "ban": "\u6591\u73ed\u642c\u6273\u822c\u9881\u677f\u7248\u626e\u62cc\u4f34\u74e3\u534a\u529e\u7eca\u962a\u5742\u8c73\u94a3\u7622\u764d\u8228", "bang": "\u90a6\u5e2e\u6886\u699c\u8180\u7ed1\u68d2\u78c5\u868c\u9551\u508d\u8c24\u84a1\u8783", "bao": "\u82de\u80de\u5305\u8912\u96f9\u4fdd\u5821\u9971\u5b9d\u62b1\u62a5\u66b4\u8c79\u9c8d\u7206\u52f9\u8446\u5b80\u5b62\u7172\u9e28\u8913\u8db5\u9f85", "bo": "\u5265\u8584\u73bb\u83e0\u64ad\u62e8\u94b5\u6ce2\u535a\u52c3\u640f\u94c2\u7b94\u4f2f\u5e1b\u8236\u8116\u818a\u6e24\u6cca\u9a73\u4eb3\u8543\u5575\u997d\u6a97\u64d8\u7934\u94b9\u9e41\u7c38\u8ddb", "bei": "\u676f\u7891\u60b2\u5351\u5317\u8f88\u80cc\u8d1d\u94a1\u500d\u72c8\u5907\u60eb\u7119\u88ab\u5b5b\u9642\u90b6\u57e4\u84d3\u5457\u602b\u6096\u789a\u9e4e\u8919\u943e", "ben": "\u5954\u82ef\u672c\u7b28\u755a\u574c\u951b", "beng": "\u5d29\u7ef7\u752d\u6cf5\u8e66\u8ff8\u552a\u5623\u750f", "bi": "\u903c\u9f3b\u6bd4\u9119\u7b14\u5f7c\u78a7\u84d6\u853d\u6bd5\u6bd9\u6bd6\u5e01\u5e87\u75f9\u95ed\u655d\u5f0a\u5fc5\u8f9f\u58c1\u81c2\u907f\u965b\u5315\u4ef3\u4ffe\u8298\u835c\u8378\u5421\u54d4\u72f4\u5eb3\u610e\u6ed7\u6fde\u5f3c\u59a3\u5a62\u5b16\u74a7\u8d32\u7540\u94cb\u79d5\u88e8\u7b5a\u7b85\u7be6\u822d\u895e\u8df8\u9ac0", "bian": "\u97ad\u8fb9\u7f16\u8d2c\u6241\u4fbf\u53d8\u535e\u8fa8\u8fa9\u8fab\u904d\u533e\u5f01\u82c4\u5fed\u6c74\u7f0f\u7178\u782d\u78a5\u7a39\u7a86\u8759\u7b3e\u9cca", "biao": "\u6807\u5f6a\u8198\u8868\u5a4a\u9aa0\u98d1\u98d9\u98da\u706c\u9556\u9573\u762d\u88f1\u9cd4", "bie": "\u9cd6\u618b\u522b\u762a\u8e69\u9cd8", "bin": "\u5f6c\u658c\u6fd2\u6ee8\u5bbe\u6448\u50a7\u6d5c\u7f24\u73a2\u6ba1\u8191\u9554\u9acc\u9b13", "bing": "\u5175\u51b0\u67c4\u4e19\u79c9\u997c\u70b3\u75c5\u5e76\u7980\u90b4\u6452\u7ee0\u678b\u69df\u71f9", "bu": "\u6355\u535c\u54fa\u8865\u57e0\u4e0d\u5e03\u6b65\u7c3f\u90e8\u6016\u62ca\u535f\u900b\u74ff\u6661\u949a\u91ad", "ca": "\u64e6\u5693\u7924", "cai": "\u731c\u88c1\u6750\u624d\u8d22\u776c\u8e29\u91c7\u5f69\u83dc\u8521", "can": "\u9910\u53c2\u8695\u6b8b\u60ed\u60e8\u707f\u9a96\u74a8\u7cb2\u9eea", "cang": "\u82cd\u8231\u4ed3\u6ca7\u85cf\u4f27", "cao": "\u64cd\u7cd9\u69fd\u66f9\u8349\u8279\u5608\u6f15\u87ac\u825a", "ce": "\u5395\u7b56\u4fa7\u518c\u6d4b\u5202\u5e3b\u607b", "ceng": "\u5c42\u8e6d\u564c", "cha": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bcd2aa7af9f370e7520957a0161ba8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40d72219420f35ff95e0a291746f995/" rel="bookmark">
			HiveQL函数7—数据脱敏函数（Data Masking）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.mask(string str[, string upper[, string lower[, string number]]])2.mask_first_n(string str[, int n])3.mask_last_n(string str[, int n])4.mask_show_first_n(string str[, int n])5.mask_show_last_n(string str[, int n])6.mask_hash(string|char|varchar str)参考 1.mask(string str[, string upper[, string lower[, string number]]]) 返回值：string
功能：返回str的masked版本（从Hive 2.1.0开始）。默认，大写字母转换为“X”，小写字母转换为“x”，数字转换为“n”。例如，mask(“abcd-EFGH-8765-4321”)将生成xxxx-XXXX-nnnn-nnnn 。可以通过提供其他参数来重写掩码中使用的字符：第二个参数控制大写字母的掩码字符、第三个参数控制小写字母的掩码字符，第四个参数控制数字的掩码字符。
示例：
&gt; select mask("abcd-EFGH-8765-4321") as f1; +----------------------+ | f1 | +----------------------+ | xxxx-XXXX-nnnn-nnnn | +----------------------+ &gt; select mask("abcd-EFGH-8765-4321", "U", "o", "#") as f1; +----------------------+ | f1 | +----------------------+ | oooo-UUUU-####-#### | +----------------------+ 2.mask_first_n(string str[, int n]) 返回值：string
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40d72219420f35ff95e0a291746f995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1105814993611473c793425c08eb1f4e/" rel="bookmark">
			【数值分析实验MATLAB】数值积分：梯形公式、辛普森公式、复化梯形公式、复化辛普森公式、龙贝格算法、自适应求积方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）Matlab代码:
f1:
if x==0 y=1; else %y=exp(-x^2); y=(sin(x))/x; end 梯形公式：
a=0; b=1; tx=(b-a)/2*(f1(a)+f1(b)); tx=vpa(tx,5); tx simpson公式：
a=0; b=1; xps=(b-a)/6*(f1(a)+4*f1((a+b)/2)+f1(b)); xps=vpa(xps,5); xps （2）Matlab代码：
复化梯形公式：
a=0; b=1; e=1e-6; m=1; h=b-a; T(1)=h/2*(f1(a)+f1(b)); while 1 h=h/2; sum=0; for j=1:2^(m-1) sum=sum+f1(a+(2*j-1)*h); end S(1)=T(1)/2+h*sum; for j=1:m S(j+1)=S(j)+(S(j)-T(j))/(4^j-1); end if(abs(S(m+1)-T(m))&lt;=e) fprintf('求得最终解为：%f\n',S(m+1)); fprintf('迭代次数为:%d\n',m); return end T=S; m=m+1; end 复化辛普森公式：
a=0; b=1; e=1e-6; N=20; n=0; h0=(b-a)/2; S0=h0/3*(f1(a)+f1(b)+4*f1((a+b)/2)); while n&lt;N n=n+1; h1=h0/2; sum1=0; sum2=0; for k=1:2^(n-1) sum1=sum1+f1(a+(4*k-2)*h1); end for k=1:2^n sum2=sum2+f1(a+(2*k-1)*h1); end S1=S0/2+h1/3*(-2*sum1+4*sum2); if(abs(S1-S0)&lt;e) fprintf('求得最终解为：%f\n',S1); fprintf('迭代次数为:%d\n',n); return end S0=S1; h0=h1; end 龙贝格算法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1105814993611473c793425c08eb1f4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c34828aa27e94bc48957b42a348ad85/" rel="bookmark">
			Android使用AspectJ实现AOP -- 上手实践篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 AOP概念理解 深入理解Android之AOP 如果对AOP没什么概念，建议阅读该篇文章
AOP Signature 格式说明 传送门
1、aspect配置 刚接触aspectj时在网上查阅了不少资料，参考了一些网友的经验分享，结果很少有成功的，最后还是找到一篇可以正常编译运行的经验分享，这里我也稍作整理供大家参考，自己也留个笔记，方便以后翻阅查找。
拿自己的demo为例，可能跟大家的工程结构不一样，各位可以酌情参考，我是新建了一个Android Project,有一个默认的app module，然后aspectj类直接在app里创建的，大家也可以创建单独的android lib module,把aspectj文件在这里新建，然后在app module中引用，需要配置的脚本内容如下：
1.1 project根目录下的build.gradle
首先需要在工程根目录下的build.gradle的buildscript中添加aspectj相关依赖，如下：
buildscript { repositories { google() jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.4.2' //☆☆☆ add for test AspectJ Begin classpath 'org.aspectj:aspectjtools:1.9.2' classpath 'org.aspectj:aspectjweaver:1.9.2' //☆☆☆ End } } 1.2 app module中的build.gradle 配置
这里需要配置两块内容，一个是依赖的sdk，另一个是aspectJ生效配置，具体如下：
//Part One dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) //aspectjrt的依赖 implementation group: 'org.aspectj', name: 'aspectjrt', version: '1.9.2' } //Part Two /*Aspectj配置*/ import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c34828aa27e94bc48957b42a348ad85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a017958da1cce3aeaa51a164b3a99a61/" rel="bookmark">
			Kafka协调器和有意思的三个参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Kafka的协调器 作用： 负责消费者的出入组工作组协调器，每个broker启动的时候，都会创建GroupCoordinator实例，管理部分消费组 在与之连接的消费者中选举出消费者leader 下发leader消费者返回的消费者分区分配结果给所有的消费者管理消费者的消费偏移量提交，保存在kafka的内部主题中和消费者心跳保持，知道哪些消费者已经死掉，组中存活的消费者是哪些 消费者协调器，每个consumer实例化时，同时实例化一个ConsumerCoordinator对象，负责同一个消费组下各个消费者和服务端组协调器之前的通信 向组协调器申请加入组或者离开组向组协调器提交偏移量通过心跳，保持组协调器的连接感知被组协调器选为leader的消费者的协调器，负责消费者分区分配。分配结果发送给组协调器非leader的消费者，通过消费者协调器和组协调器同步分配结果 选举GroupCoordinator流程： 首先对消费组的groupId进行hash，接着对consumer_offsets的分区数量取模，默认是50，可以通过offsets.topic.num.partitions来设置找到你的这个consumer group的offset要提交到consumer_offsets的哪个分区然后对这个分区找到对应的leader所在的broker，这个broker就是这个consumer group的coordinator了，consumer接着就会维护一个Socket连接跟这个Broker进行通信 选举消费者leader过程 确定了GroupCoordinator之后，所有的consumer都会发送一个join group请求注册GroupCoordinator就会默认把第一个注册上来的consumer选择成为leader consumer把整个Topic的情况（Kafka元数据）下发给leader consumerleader consumer就会根据负载均衡的思路制定消费方案，返回给GroupCoordinatorGroupCoordinator拿到方案之后再下发给所有的consumerconsumer都会向GroupCoordinator发送心跳，当有consumer长时间不再和GroupCoordinator保持联系，就会重新把分配给这个consumer的任务重新执行一遍 二、有意思的参数 1. heartbeat.interval.ms参数 每个consumer 都会根据 heartbeat.interval.ms 参数指定的时间周期性地向group coordinator发送 hearbeat，group coordinator会给各个consumer响应，若发生了 rebalance，各个consumer收到的响应中会包含 REBALANCE_IN_PROGRESS 标识，这样各个consumer就知道已经发生了rebalance，同时 group coordinator也知道了各个consumer的存活情况
2. session.timeout.ms参数 group coordinator检测consumer发生崩溃所需的时间。一个consumer group里面的某个consumer挂掉了，最长需要 session.timeout.ms 秒检测出来
3. max.poll.interval.ms参数 如果在两次poll操作之间，超过了这个时间，会进行重平衡
参数使用举例 session.timeout.ms=10， heartbeat.interval.ms=3 session.timeout.ms是个"逻辑"指标，它指定了一个阈值—10秒，在这个阈值内如果coordinator未收到consumer的任何消息，那coordinator就认为consumer挂了。而heartbeat.interval.ms是个"物理"指标，它告诉consumer要每3秒给coordinator发一个心跳包，heartbeat.interval.ms越小，发的心跳包越多
设计的原因： 如果group coordinator在一个heartbeat.interval.ms周期内未收到consumer的心跳，就把该consumer移出group，这样设计显得不合理，有可能网络延时，有可能consumer出现了一次长时间GC，影响了心跳包的到达，就会造成误判，导致频繁的rebalance
版本对比 在kafka0.10.1之前，发送心跳包和消息处理逻辑这2个过程是耦合在一起的，如果一条消息处理时长要5min，而session.timeout.ms=3000ms，那么等 kafka consumer处理完消息，group coordinator早就将consumer 移出group了，，因为只有一个线程，在消息处理过程中就无法向group coordinator发送心跳包，超过3000ms未发送心跳包，group coordinator就将该consumer移出group了
kafka0.10.1之后的版本中，new KafkaConsumer对象后，在while true循环中执行consumer.poll拉取消息这个过程中，存在两个线程：
heartbeat 线程，定时发送心跳processing线程，可理解为调用consumer.poll方法执行消息处理逻辑的线程 两个线程设计的优点
将二者分开，一个processing线程负责执行消息处理逻辑，一个heartbeat线程负责发送心跳包，那么：就算一条消息需要处理5min，只要底heartbeat线程在session.timeout.ms向group coordinator发送了心跳包，那consumer可以继续处理消息，而不用担心被移出group如果consumer出了问题，那么在 session.timeout.ms内就能检测出来，而不用等到 max.poll.interval.ms 时长后才能检测出来 实际问题分析 项目中经常碰到的 频繁consumer rebalance 错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a017958da1cce3aeaa51a164b3a99a61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24744219279391f356ed9e4141cb494b/" rel="bookmark">
			ElasticSearch学习笔记（九）——Elasticsearch查询原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 ES的查询分为两个阶段：
查询取回 首先，一个 index 的数据会被分为多片，所以一个 document ，只能存在于一个 shard 中，如何确定doc的位置呢？
数据路由算法：
shard = hash(routing) % number_of_primary_shards
routing 可以是_id（默认）或者由我们自定义传入。
手动指定
在发送请求的时候，手动指定一个 routing value，比如使用
put /index/type/id?routing=user_id
二、查询阶段 查询阶段流程分析：
客户端发送一个 search 请求到 Node 3 ， Node 3 会创建一个大小为 from + size 的空优先队列Node 3 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 from + size 的本地有序优先队列中每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 Node 3 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表 相关知识点：
当一个搜索请求被发送到某个节点时，这个节点就变成了协调节点查询请求可以被某个主分片或某个副本分片处理，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡每个分片在本地执行查询请求并且创建一个长度为 from + size 的优先队列—也就是说，每个分片创建的结果集足够大，均可以满足全局的搜索请求。分片返回一个轻量级的结果列表到协调节点，它仅包含文档 ID 集合以及任何排序需要用到的值，例如 _score 三、取回阶段 查询阶段标识哪些文档满足搜索请求，但是我们仍然需要取回这些文档。
协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { “from”: 90, “size”: 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24744219279391f356ed9e4141cb494b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ee23fd9daea25c92b52015fdb1b4c2/" rel="bookmark">
			【数值分析实验MATLAB】插值与拟合：拉格朗日插值、多项式插值、分段插值（三次样条插值）、最小二乘法及平方误差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab代码：
format long x=[11 12 13]; y=[0.190809 0.207912 0.224951]; x1=11.5; n=length(x)-1; m=length(x1); y1=zeros(1,m); for k=1:m z=x1(k); y1(k)=0; for i=1:n+1 l=1; for j=1:n+1 if j~=i l=l*(z-x(j))/(x(i)-x(j)); end end y1(k)=y1(k)+l*y(i); end end y1=vpa(y1,7); y1 输出：
y1 = 0.1993685 （1）Matlab代码：
n(1)=5; n(2)=10; n(3)=20; l=1; L=0; t=-5:0.5:5; h=1./(1+t.*t); plot(t,h,'*') hold on; syms x; for k=1:3 for j=1:n(k)+1 m(j)=-5+(j-1)*10/n(k); end for i=1:n(k)+1 for j=1:n(k)+1 if(i~=j) l=l*(x-m(j))/(m(i)-m(j)); end end L=L+f(m(i))*l; l=1; end a=-5:0.5:5; %a=-5:0.1:5; y=subs(L,x,a); plot(a,y); hold on; L=0; end （2）三次样条插值（三弯矩法）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ee23fd9daea25c92b52015fdb1b4c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37c2d26f94f4e64a818f05a602e4210/" rel="bookmark">
			MongoDB 日志切割三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 日志切割 ​ MongoDB 默认是不会进行切割日志的，除非我们配置了 logRotate = rename，并且重启 MongoDB 服务，才会进行切割日志的，那么为了避免实际中我们一个日志文件过大，我们需要对日志进行切割，有两个办法：
1. 通过 MongoDB 管理命令进行切割 使用该命令时需要在 MongoDB 运行时指定日志文件路径。--logpath [file] ，或者在配置文件中指定。
use admin db.runCommand({logRotate:1}) 2. 通过 Linux 系统自带的服务 logrotate 进行切割 首先我们需要配置 MongoDB 参数 logRotate = reopen， logappend = true，然后通过 Linux 系统自带的 logrotate。配置文件放置在 /etc/logrotate.d/, 切割配置文件示例：
/opt/mongodb/log/mongodb.log { rotate 180 daily size 100M olddir /opt/mongodb/log/oldlog copytruncate dateext compress notifempty missingok } 3. 通过向进程发送 SIGUSR1 信号来切割日志 如果我们的进程 id 是19555，那么我们可以通过以下命令来切割日志的。只要我们执行了该命令，日志就会立即进行切割。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0aefa6459933b24a0332851ef0f099/" rel="bookmark">
			存储异构，Elasticsearch如何充分利用存储空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：石文
时间：2018-07-23
前言 ES版本：5.6.4
ES集群可以通过配置文件将各节点的角色划分出来以便给予不同的机器配置，从而达到资源的合理利用。对于数据节点来说，使用SSD磁盘可以显著提高可以显著提高数据写入或者是查询性能。SSD磁盘相对于存储型磁盘的劣势：
往往SSD磁盘容量较小;不同品牌的磁盘的故障率不一致。对于第2个缺点可以通过raid来防止磁盘出现错误（为什么磁盘发生错误会严重影响到集群功能？参考如下资料：http://t.cn/Rg1ILik）。机器不同的磁盘数量和不同的raid方式都会导致节点上会出现不同磁盘容量的数据节点。 ES对于节点磁盘的监控有集群级别和机器级别两种，我们还可以通过自己的机器监控系统来对节点磁盘进行监控。
#集群级别的磁盘监控可以通过如下API获得 curl -XGET http://&lt;domain&gt;:&lt;port&gt;/_cluster/stats?pretty #机器级别的磁盘监控可以通过如下API获得 curl -XGET http://&lt;domain&gt;:&lt;port&gt;/_nodes/&lt;nodes1&gt;/stats?pretty 自己的机器监控系统可以选择性监控如下几个部分：
磁盘剩余可用容量百分数磁盘可用容量磁盘使用率 ES任一节点出现磁盘被写满的问题后都会引发集群级别的问题（当节点被写满时会引发集群问题可参考如下链接：http://t.cn/RgFXLAf）。ES在“防止节点数据被写满”这一方面也有一些配置参数和方法（节点磁盘分配决策器），但是这些参数和方法只是能缓解“节点被写满”并不能保证节点一定不被写满。
ES相关配置参数介绍 集群级别的磁盘控制参数有如下两种：
ES默认开启ES节点磁盘分配决策器。
“cluster.routing.allocation.disk.watermark.low”：此项设置是通过监控数据节点磁盘使用的水位来控制新索引分片是否可以分配到某节点。注意 ：这个设置将不影响新建索引的主分片的分配，即如果集群发现有些节点磁盘使用量到达了watermark.low的值，但是这个节点上总分片少于均值，那么新建索引的主分片将继续分配到此节点。索引这项设置将不会影响集群功能，只要集群磁盘有空间。
“cluster.routing.allocation.disk.watermark.high”：此项设置是通过监控数据节点磁盘使用的水位来控制是否将某些节点的分片迁移出此节点。当某个节点的磁盘使用超过这个阈值，集群将会随机（优先主分片，不再有索引更新的分片）选择分片迁移到其他节点。注意 ：当节点的磁盘容量达到这个阈值时，节点存在”磁盘被写满 ”的巨大风险。当某个节点的数据盘使用量达到”cluster.routing.allocation.disk.watermark.high”这个值后，集群将会迁移出这个节点的部分分片，直到节点磁盘使用量低于该值。但是在分片向外迁移的过程中，迁移分片并发数将不受如下连两个参数的限制：
"cluster.routing.allocation.node_concurrent_recoveries"：允许在节点上并发分片恢复的个数（写和读），只控制“恢复”过程的并发数，对集群“重平衡”和其他情况下的并发数没有限制。 "cluster.routing.allocation.cluster_concurrent_rebalance"：允许在集群上并发分片重平衡的个数，只控制“重平衡”过程的并发数，对集群“恢复”和其他情况下的并发数没有限制。 即集群可能出现大量的迁移的分片，造成集群某节点负载过重，出现长时间的“gc overhead”和“io_util”过高（IO利用率）。
集群中存在异构型数据节点时的潜在问题 正如上文所说的，”cluster.routing.allocation.disk.watermark.low”这个值并不能阻止集群向此节点分配分片，只是不再向此节点副本分片，换句话说，这个参数对新建索引的主分片的分配决策是透明的。
为什么”cluster.routing.allocation.disk.watermark.low”参数只能控制新建索引主分片副本分片分配的限制？
官方文档中对这个参数的应用场景做了限制：对于新创建的索引的主分片，这个参数不会起作用。即对于新创建的索引会限制副本分片在此节点的分配，对新创建的索引的主分片的分配不受影响。这个参数起作用的场景主要是：
集群节点挂掉或者用户更改了集群的复制片数量， 此时未分配的分片将不再向此节点分配分片集群rebalance不再向此节点分配分片新索引的副本分片不再向此节点分配 这样做的原因，本人认为是为了保持集群的平衡，ES“rebalance”是按照节点分片数来重平衡的，如果”cluster.routing.allocation.disk.watermark.low”这个值可以禁止所有分片的分配，将势必造成集群节点间分片数的不平等，从而造成持续的“重平衡”，而有些节点又禁止分配分片，这样的话，集群将处于不断启动重平衡的死循环。（个人见解，关于这个问题的讨论可参见：http://t.cn/RevxDy2）
以下为原因：
这么设计也是有道理的，low watermark表达的含义是磁盘空间较低，为了保护已有数据的进一步空间消耗（数据的持续写入， merge的临时空间消耗)，禁止有数据的shard向上面分配。 而新创建的索引，一开始是空的，分配上去也无所谓。 low watermark是不管磁盘数据结点是否快写满了的，有另外一个参数"cluster.routing.allocation.disk.watermark.high"来处理这种情况。这个阈值触发以后，ES会将该结点上的数据开始往其他结点迁移，该参数对所有shard有效。 两个watermark合理配置，可以减少数据迁移的频率，同时保障结点磁盘空间不会过低。 最后还有一道防线"cluster.routing.allocation.disk.watermark.flood_stage" ，万一应用写数据太猛，超过预期，磁盘空间降太快，来不及往外迁移，这个阈值触可能被触发。 触发时，ES会将结点上的索引设置为只读, 避免磁盘空间爆掉，影响结点的可用性。 上文中提到的”cluster.routing.allocation.disk.watermark.flood_stage”参数是在6.0以后版本 中才存在的，默认值是“95%”,这个参数是在某一个节点触发时，将集群中此节点上有的索引设为只读 。
异构型数据节点存在的问题
就想上文所说的，对于ES版本小于6.0时，如果部署了小磁盘的数据节点，风险提示如下：
磁盘比较小的数据节点磁盘有被写满的风险。触发大量的分片迁移，影响节点性能(gc overhead和io_util)，影响集群整体性能。 出现以上问题的运维预案 某个节点将要被写满时的预案处理
节点磁盘往往都有机器级别的磁盘监控，比如设置当机器的磁盘可用容量小于5%时，磁盘告警。此时，若磁盘本身较小，ES集群数据写入量较大，则会发生较大可能磁盘被写满。
此时，预案操作如下：
1.禁止集群分片分配
2.关闭此节点，观察集群状态是否为yellow，集群状态为“yellow”时说明索引主分片都存在，集群不会出现数据丢失。
3.清理磁盘无用信息（当ES的数据路径下挂载有磁盘时，这一步往往效果不佳，没有什么数据可以被清理的）
4.若磁盘有可用空间，重新启动节点加入集群
5.否则，直接清空一部分索引分片。
ES数据节点数据存储方式：
节点触发“cluster.routing.allocation.disk.watermark.high”节点出现大量的分片迁移
集群中某些节点一旦出现分片迁移，将不受“cluster.routing.allocation.node_concurrent_recoveries”和“ cluster.routing.allocation.cluster_concurrent_rebalance”这两个参数的控制，即这个触发了“cluster.routing.allocation.disk.watermark.high”这个参数，会造成大量的分片迁移。已经开始迁移的分片将直到迁移完毕，不会停止。预案操作如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc0aefa6459933b24a0332851ef0f099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59d5391e8caf9e97b9ff645e4826dee/" rel="bookmark">
			java 字符串公式及条件判断表达式，计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//头文件
import javax.script.Bindings; import javax.script.Compilable; import javax.script.CompiledScript; import javax.script.ScriptEngine; import javax.script.ScriptEngineManager; import javax.script.ScriptException; //公式计算 private float ExecutionStrFormula(Map&lt;String,Object&gt; thfuInfo,String formulaStr) { ScriptEngine engine = new ScriptEngineManager().getEngineByName("javascript"); Compilable compilable = (Compilable) engine; Bindings bindings = engine.createBindings(); //Local级别的Binding CompiledScript JSFunction = null; //解析编译脚本函数 try { JSFunction = compilable.compile(formulaStr); bindings.put("S", (float)thfuInfo.get("thfu_s")); bindings.put("A", (float)thfuInfo.get("thfu_a")); Object result = JSFunction.eval(bindings); return StringUtils.toFloat(result); } catch (ScriptException e) { e.printStackTrace(); return 0.0f; } } //条件表达式计算 private static boolean ExecutionStrConditional(String formulaStr,float thefGrade) { ScriptEngine engine = new ScriptEngineManager().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f59d5391e8caf9e97b9ff645e4826dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4278d2033c9d29056cb3c3e6859a09c/" rel="bookmark">
			git pre-commit 钩子禁止commit大文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入项目的hooks文件夹（.git/hooks）应该看到已经存在的文件列表。 创建一个要使用的确切提交类型的新文件（例如：“ commit-msg”，“ pre-rebase”，“ pre-commit”等）。不要有扩展名。打开新文件并粘贴代码(如下图所示Python代码)保存存档。 并将pre-commit文件设置为可执行！ 现在，git钩子将自动触发。 #!/usr/bin/python #-*- mode: python -*- """Git pre-commit hook: reject large files, save as 'pre-commit' (no .py) and place in .git/hooks""" #!/usr/bin/python3 import sys import os import re from subprocess import Popen, PIPE from io import StringIO def git_filesize_hook(megabytes_cutoff=5, verbose=False): """Git pre-commit hook: Return error if the maximum file size in the HEAD revision exceeds &lt;megabytes_cutoff&gt;, succes (0) otherwise. You can bypass this hook by specifying '--no-verify' as an option in 'git commit'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4278d2033c9d29056cb3c3e6859a09c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa6206260c1a5866be3d0ca9dbe7e0ad/" rel="bookmark">
			怎么实现无遮罩屏蔽某些按钮的点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给需要能点击的UI控件上绑定一个实现了ICanvasRaycastFilter接口的组件，在方法IsRaycastLocationValid中判断当前点击的位置是否符合响应事件的条件
应用场景：
1.引导挖洞
2.ui事件触发，并且不影响下面的其他控件的事件响应
附三段代码示例：
public class NewBehaviourScript : MonoBehaviour,ICanvasRaycastFilter { public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera) { var mousePos = eventCamera.WorldToScreenPoint(transform.position); if (Vector2.Distance(mousePos,sp)&lt;3) { return true; } return false; } } public class GuideMaskComponent : MonoBehaviour, ICanvasRaycastFilter { private RectTransform holeTf; public GameObject Text; public void ShowText(float delay) { StartCoroutine(StartShowText(delay)); } IEnumerator StartShowText(float delay) { yield return new WaitForSeconds(delay); Text.SetActive(true); } public void SetHoleTransform(Transform tf) { holeTf = tf as RectTransform; } public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera) { if (holeTf !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa6206260c1a5866be3d0ca9dbe7e0ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864c51f44ae4bf04a25fa1aef99a03d9/" rel="bookmark">
			本科发表6篇SCI论文，获多个荣誉，他刚入学就享受研究生待遇！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		他身着一身黑色运动服，留着清爽的寸头，带着腼腆的微笑……武汉大学基础医学院2016级基础医学专业本科生谢天，这样一个平易近人的大男孩，谁又能想到他大二时就以第一作者发表了两篇SCI论文，是一位负责国家级大创项目的真正学霸。
谢天(右)与导师张秋萍教授参加国际免疫学大会
谢天，武汉大学基础医学院2016级基础医学专业本科生，宝钢优秀学生特等奖获得者，曾获武汉大学优秀学生干部、武汉大学三好学生、武汉大学甲等奖学金。大一时加入基础医学院张秋萍教授的肿瘤免疫实验室，大二时发表两篇SCI论文(分别为第一作者和共同第一作者)，国家级大创项目负责人，2019年夏赴加拿大英属哥伦比亚大学交流学习。目前还有四篇SCI论文已被接收，其中第三作者一篇、第四作者两篇，还有一篇以共同第一作者身份完成的SCI论文正在审稿中。
结缘武大，本科享研究生待遇
谢天高考那年，武汉大学基础医学院开始招收基础医学专业的本科生。在查阅了相关资料后，谢天了解到这个专业是为培养既懂医学又具备生物学专业科研能力的多学科交叉人才而设立的。"我觉得，如果能在进行生命科学研究的同时，又能为人类健康事业做出贡献，会是一件非常有意义的事情。"
基础医学院在新生入校后不久便举办了导师见面会，为每位同学安排博士生导师"一对一"指导。也就是说，本科生一来就受到了研究生的培养待遇。
此外，学院还为同学们提供了很多交流学习的机会。大一暑假，谢天和同学们去北京可瑞生物科技有限公司参加实习，大二下学期赴中山医学院与该校同学开展为期两周的学习交流活动。谢天认为："这个活动丰富了我们的学习经历，平时在学校学不到的内容，通过这样的形式可以得到有效补充。"
2018学年，武汉大学开始实施"第三学期"制，作为"第三学期"的活动之一，2019年暑假，在学校全额资助下，谢天等19名基础医学专业的同学有机会前往加拿大英属哥伦比亚大学交流学习一个月，"和海外老师互动讨论，实实在在地拓宽了我们的国际视野。"谢天说。
此外，在3年多的学习生活中，谢天还跟随导师多次参加学术会议。就在上个月，他还跟随导师参加了第十七届国际免疫学大会，会上聆听三位诺奖得主的学术报告。
武汉大学基础医学院采用小班化、个性化、国际化和导师制的培养模式，这种精英化的教育和培养模式，让谢天和他的同学们很受益。对此，谢天也十分感激："我在科研上取得的小小成绩也得益于学院和导师为我提供的各种学习机会，我觉得我非常幸运!"
从零开始，艰难的学术之路
作为本科生就在论文上硕果累累、科研成果不断，谢天看起来"顺风顺水"的学术之路，其实隐藏着很多艰辛。
刚进校时，谢天对免疫学几乎一无所知，用他自己的话来说，完全就是"科研小白"。"我还记得军训没结束时，就被带去参加导师张秋萍教授的组会，会上大家说的专业词汇特别多，我什么都听不懂，完全是懵的。"那时，导师布置给谢天阅读一篇论文，"那是我们所在的实验室刚发的一篇综述，正文一共六页，国庆期间放了七天假，我在家没干别的，每天啃一页。其实非常非常艰难，那会儿到最后我也没有真正把它读透。"
彼时，很多专业课还没开始上，谢天在实验室碰到了很多不懂的知识，有时候他会选择与师长沟通，但大多数时候都靠自学。为此，每天他都在图书馆、实验室苦读文献，几乎没有休息。"过程很痛苦""压力很大"，谢天直言。第一次在组会上讲论文就让谢天记忆犹新。"虽说是一篇3、4分的论文，现在看来没什么，但对当时的我来说，光是了解专业词汇就费了很大劲。"
但随着深入阅读，谢天开始慢慢熟悉领域内的专业知识。医学研究殿堂的大门，也渐渐为谢天敞开。"一开始我只能分享3、4分的论文，后面慢慢7分、8分也不在话下。后面的课堂上，老师也会讲到之前自学的部分，我对这些知识也有了新的体会。"谢天说。
经过一年的不懈钻研，谢天读文献不再感到吃力，"读文献得心应手了，我就开始着手自己做科研。"从大二时，谢天开始写综述，经常一个晚上要泛读十几篇文章，由于专业知识和单词储备量的限制，其中的艰难不言而喻，但是谢天都慢慢坚持了下来。大二时，谢天还作为负责人申请到医学部大创项目一项，这个项目在今年9月以第一名的答辩成绩顺利结题。今年上半年，他又作为负责人以答辩成绩第一的成绩顺利申请到国家级大创项目一项。
劳逸结合，听歌打球看《Immunity》
冬日的早晨七点，谢天的闹钟准时响起，随即开启了一天的忙碌。"休息啊，我是基本没休息概念的。"这话对谢天来说一点都不假。无论严寒或是酷暑、工作日或是节假日，他雷打不动七点起床，保证八点以前能坐在实验室。因为大一大二时的谢天平时都有专业课，所以他的实验基本排在周末。"周末来实验室是常事，按优先级来说，有课的时候就上课，没课就待在实验室自习看文献，复习复习专业知识。"
实验室-宿舍-教室"三点一线"的学术生活，谢天的压力可想而知，但他也会见缝插针地调整自己，音乐就是谢天的解压好伴侣。"做实验的时候，有些环节需要时间等待，比如说提取RNA离心时需要十几分钟的时间，这期间我就会一边听歌一边等。"
除了音乐作调剂，谢天空闲时还喜欢打羽毛球。"我体育课选修了羽毛球，宿舍旁边就是羽毛球馆，同学在群里喊一声，有时间的话会去打一打。"
每天睡觉前，他还习惯翻阅一些学术期刊，"我喜欢泡脚的时候翻翻文献，比如Immunity《免疫》杂志，就像看闲书一样，对我来说就算是一种放松吧。"
谈到未来，谢天表示应该会留在国内继续读研，"我目前从事的是肿瘤免疫方面的研究，今后想从事炎症与慢性疾病的研究，让慢性疾病病人尽量少遭受痛苦。"
注：本文素材来自武汉大学新闻网，如有侵权请联系删除。
长按识别二维码，了解一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb34cc76c3422d812a60f2c0e6b7dc3/" rel="bookmark">
			html前端实现led样式数字的效果（数码管效果展示数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端实现led样式数字的效果 前言效果图实现代码使用方式html代码该工具类使用面向对象的思想来实现该功能；而我认为每一个数字是应该对象，即“123”是应该对象，“2323”也是一个对象，“-23.3234”也是一个对象； 示例 前言 由于最近有个需求是将数字展示为led样式，网上找了很多，很多都是时间倒计时，不能满足需求，而且文档很不齐全，使用方式也不明确。故自己写了此工具类（ps：接触前端不久，代码中可能存在很多的瑕疵，还望各位指正）希望能够帮助各位！！！谢谢
由于此片博客使用的方式是大量操作dom，未使用canvas，我已经重新使用canvas的方式写了一篇博客，两种方式各有优劣。此文使用的方式数字可以换行展示，且字体特别小的时候可能会出现线的粗细不一致，但是这种方式清晰度很高，并且放大缩小比较方便。我使用canvas的方式暂时不支持换行展示，但是代码简单，操作dom很少，效率高，但是清晰度偏低，放大缩小会模糊。
此方案暂时未做支持“ : ”符号。如有需要支持“ : ”请转至=&gt;使用canvas实现led效果数字字体的链接
效果图 以下是功能的效果图
调用方式比较简单，以下详细介绍
实现代码 由于该方法依赖了jquery的，所以请读者在使用前先引入jquery
该工具类或多或少的使用到了es6语法，浏览器兼容性问题并未做太多的测试
//显示led类型的数字的js代码工具类 class LedStyle { /* width:led容器的宽度，默认为50px height：led容器的高度，默认为100px（实际高度要大于100px,实际高度为height+lineWidth） lineWidth:led灯的宽度，默认为5px selector:需要展示led灯的选择器名称 color:led灯的颜色，默认为红色 italics:倾斜角度，默认为0（不倾斜） */ constructor(width, height, lineWidth,selector, color, italics) { this.width = width; this.height = height; this.lineWidth = lineWidth; this.color = color; this.italics = italics; //创建对象的时候生成一个随机的class编码 this.selector = selector; //如果在初始化的时候没有指定参数，都使用以下默认值进行初始化 this.setLedStyle(width?width:50, height?height:100, lineWidth?lineWidth:5, color?color:'red', italics?italics:'0') } setLedStyle(width = 50, height = 100, lineWidth = 5, color = 'red', italics = '0') { let style = ` &lt;style&gt; ${this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb34cc76c3422d812a60f2c0e6b7dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026d62b24af8e92ef1b95e34ce2398d9/" rel="bookmark">
			java8 orElse，orElseGet，orElseThrow的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这3个都是用来处理null的情况：
orElse 用的是括号内的对象
orElseGet 用的是Supplier接口返回的对象。 supplier接口就一个get方法。
无入参，出参要和Optional的对象同类型。
orElseThrow 用的是Supplier接口返回的对象，这个对象必须要实现Throwable。 supplier接口就一个get方法。 无入参，出参要实现Throwable.
orElse 代码 //orElse 有，就用自身值。 为null，就用orElse后面的值。 //有正品用正品，没正品用替代品 System.out.println(Optional.ofNullable("正品").orElse("替代品")); // orElse System.out.println(Optional.ofNullable(null).orElse("替代品")); orElseGet代码 // orElseGet 它可以传入一个supplier接口，里面可以花样实现逻辑 System.out.println(Optional.ofNullable("宝马").orElseGet(()-&gt;"走路")); // 有宝马就不用走路 System.out.println(Optional.ofNullable(null).orElseGet(()-&gt;"自行车")); // 没宝马，可以骑自行车 System.out.println(Optional.ofNullable(null).orElseGet(()-&gt;"电动车")); // 没宝马，也可以骑电动车 有人会说orElse和orElseGet没看出有什么区别啊。
区别是orElseGet可以传入一个接口，来定制逻辑。
orElseThrow代码 // 有钱就没异常 try { System.out.println(Optional.ofNullable("钱").orElseThrow(()-&gt;new Exception())); // 有钱不会抛异常 } catch (Throwable throwable) { throwable.printStackTrace(); } // 没钱就会抛异常 try { System.out.println(Optional.ofNullable(null).orElseThrow(()-&gt;new Exception())); // 没钱抛异常 } catch (Throwable throwable) { throwable.printStackTrace(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bce8775d180e91e83510c199ed41300/" rel="bookmark">
			导出电脑正在运行的进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开cmd命令窗口
2.数据导出进程的命令
tasklist /v /fo csv&gt;&gt;d:\程序进程.txt
3.查看D盘下会有一个"程序进程.txt"文件，里面包含电脑中正在运行的进程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d77da63980392f394cf1cc17463dcc1/" rel="bookmark">
			使用命令合并多个txt文件的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.把要合并的文本和合并的脚本放在同一个目录下
2.bat文件中
3.双击运行bat文件后在目录下生成zong.txt文本，这里面就是合并后的文本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f3e0da8afaaeb5e8e901ce643ffa64/" rel="bookmark">
			文件共享相关错误代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 错误代码:0x80070035或者发生系统错误 53，找不到网络路径的
解决：打开TCP/IP NetBIOS Helper服务
2. 错误代码: 发生系统错误 1219。不允许一个用户使用一个以上用户名与服务器或共享资源的多重连接。中断与此服务器或共享资源的所有连接，然后再试一次。
解决：net use 查看已建立的共享连接
net use \\ip\共享 /del 删除已建立的共享连接
3. 错误代码：发生系统错误 85。本地设备名已在使用中。
解决： net use z: \\IP\共享 "密码" /user:"用户名" 映射盘符换个
4. 文件共享需要开启的服务
Workstation 服务 （依赖Remote Desktop Configuration服务和Computer Browser服务）
Server服务 （依赖Computer Browser服务）
5. 防火墙开放端口
开放 tcp139和445端口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bce26392ca6dca78ad6cce4a9916414/" rel="bookmark">
			缓存中间件-缓存架构的实现（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存中间件-缓存架构的实现（上） 前言 一眨眼，2019年就过去了。我希望从按照中间件，分别阐述一些常见的架构问题，以及解决方案。一方面这些问题与解决方案具备一定通用性 。另一方面，也算是面试中常见的问题。
我希望根据自己待过各种规模公司的经验来谈一些看法。
如果是针对大部分小公司的工作或面试，这些问题都稍微留下个印象即可。因为小公司的技术对这些问题并不是很看重，或者说机会用不到（小型公司往往追求产品功能的实现，业务的推进等）。如果是针对大部分中型公司的工作或面试，希望可以完整地知道这些问题与解决方案。因为在中型公司中，这些问题都或多或少遇到，甚至是需要迫切解决的。如果是大型公司的话，那么不仅仅需要知道这些问题与解决方案。还需要从中理解为什么会有这样的问题，为什么这样解决，在现有的项目中应该如何应用，是否提升空间等。因为在大公司中，一方面其内部往往采用自研框架，其它框架能够借鉴的只有方案，思想等精髓；另一方面大公司不缺乏那些应用开源框架的人，缺的是把握方案通用思想的人。 如果上述无法理解的话，大家可以从功能性追求与非功能性追求两个方面去思考。就像写一个简单的方法一样，最基本的要求是实现其功能，紧接着就是不断追求其非功能性（如性能，扩展性，安全性等）。放大来看，对于公司的技术发展也是如此，或者说更为严格。
之后找个机会，专门写个博客，来谈谈我对公司技术与公司的看法。
话题收回来，接下来，让我开始有关中间件问题与解决方案的阐述吧。
概述 缓存的认识 既然提及缓存中间件相关的问题及方案，首先就要谈谈这个缓存。
原本我想通过高速缓存举例，但是想了想还是用内存举例子吧。
比如我们现在玩的单机游戏，往往都容量都非常大（几十G，乃至上百G），轻轻松松都超过了电脑内存（16G）。那么很明显电脑在运行游戏时，是不可能将整个游戏文件都放入内存的。但是如果文件都在硬盘里，需要的时候再读取，显然硬盘的读写速度时不够的（由于游戏文件类别很多，所以硬盘不可能一直顺序读写），那游戏也会经常卡顿，加载缓慢等。那么该如何解决这个问题呢？
其实这个问题和我们业务中遇到的一些问题是很类似的。一方面我们希望用户可以在保证用户体验的前提下查询数据（如设备列表，订单列表等），另一方面我们不可能将所有数据都放在内存（内存的读写速度比硬盘快，所以就不解释为什么用硬盘了）中。那么到底该怎么解决这个问题呢？
这里就需要说到局部性原理了。局部性原理指的是数据的访问往往趋向于聚集在较小的连续区域。这里的连续区域包含两个方面：
时间维度：一个被使用的数据，在接下来较短的时间内，往往会被再次使用。空间维度：一个被使用的数据，其关联的数据，往往也会被使用。 局部性原理是在内存，高速缓存部分，提出来用于解决问题的。
其实，我与朋友交流分布式的一些想法时，经常说：分布式系统和单机内部是非常相似的，很多理念都是相通的。当想通了这点后，就可以去思考两者的区别的。
缓存中间件其实就是利用了局部性原理，不过缓存中间件本身只实现了局部性原理的时间维度。这也是为什么很多人都说缓存中间件是用来保存热点数据，符合二八定律。不过我们可以在应用部分实现局部性原理的空间维度。
缓存的定位 五六年前，有人就提出一个有关缓存的问题，那就是缓存作为一个非持久化数据，我们该怎么划分它。是否需要保证它的可用性。其中就有一位阿里的前辈在他的书中提到，他更倾向于认为缓存并不是一种持久化数据，不该将缓存作为一种可靠数据源。但是这位前辈也表示现有的框架中对缓存依赖较重，应该在一定程度上保护它们，避免缓存雪崩等情况。
我的看法是，在现有的技术体系中，缓存中间件等已经不再只是一个缓存了。一方面我们已经将Session等重要数据放在了缓存中，并且目前没有一个更合适的对应存储（我认为暂时也不需要一个新的存储方式。但是如果需要的话，可以将缓存中间件实例等按照内容的生命周期等进行分组）。另一方面，我们会需要明确缓存在系统中职责，它只是用来作为缓存，以及一些分布式内存。但是诸如单机所有的内部调用，应该通过消息中间件或RPC等来实现。并且明确不同缓存的职责，如Session不该放在Cookie中等。
缓存的分类 缓存框架大致可以从客户端到数据源，分成以下分类。
浏览器缓存 CookieLocalStorageSessionStorage CDN缓存负载层缓存 Nginx缓存模块Squid缓存服务器Lua扩展 应用层缓存 EtagThreadLocalGuava 外部缓存 Redis 数据库缓存 MySql缓存 我特意查询了一下百度，首页上的有关缓存架构的博客，一半都只是在围绕着缓存中间件阐述缓存架构，剩下的一般也往往在大分类上有所遗漏（如浏览器缓存，数据库缓存）。当然也有一些博客在专门的领域阐述得较为深入，或者层次的划分比较不错。故本博客只是在阐述现阶段我对缓存架构的认识（也借鉴了一些书籍，课程的缓存体系）。
浏览器缓存 浏览器缓存，也是很多时候被后端所遗忘的部分。因为这已经不属于后端的工作了，但这一定属于架构师或者相关技术负责的职责。当然还有一个原因是我做过专门的前端开发。
说白了，就是在浏览器保存一部分数据，当然这需要前端进行开发。
这里直接上图，大家可以看一下Cookie，LocalStorage，SessionStorage：
PS：图片来自网络
优势 由于是浏览器缓存，位于整个web请求相应框架的client端，所以对业务提供方没有任何负载压力与影响。只是客户端的浏览器存在些许的存储占据与计算负载。
注意 Cookie等的存储容量是有限的，需要注意分配。Cookie等的存储是明文的，不可以存储敏感数据，否则会存在安全隐患。Cookie等需要注意存储时间时间的有效设置。Cookie等存在一定的学习成本，与相关特性（如Cookie的域名设置问题，父域名无法读子域名的Cookie数据）。Cookie等需要明确业务中有哪些数据适合放在这里，如域名等。 实际应用 在我之前负责的IOT项目中，页面往往存在大量的数据，如终端列表，传感器列表，监测点列表等。并且数据间存在一定数据关系，如需要通过现存的终端列表来获取对应传感器列表，又如通过传感器列表来获取对应报警列表等。
为了避免页面切换时，为了获取一个列表而需要多次请求（如为了获得已选定的终端列表的传感器列表，需要先请求终端列表），所以通过LocalStorage来存储终端列表。
CDN缓存 CDN，Content Delivery Network，即内容分发网络。
CDN是构建网络上的内容分发网络CDN可以使得用户就近获取所需内容，避免网络拥塞，提高用户访问速度CDN依靠部署在各地的服务器，通过镜像服务器实现内容同步，其包括负载均衡，内容分发，调度等模块。 优势 降低访问延迟。使得用户就近获取所需内容，避免过多路由造成用户访问延迟问题。降低服务器压力。毕竟放在CDN服务器的内容，就不用到应用服务器获取了。消除运营商差别。消除运营商之家互联的瓶颈造成的影响，使得所有用户获得同样的访问质量集群抗攻击。广泛分布的CDN节点，可有有效避免DDOS等攻击。 缺点 同步缓慢。由于CDN是大量且分层的节点分布，所以数据的下发与同步会比较缓慢。如果是使用收费服务，则需要一定支出。如果是自建CDN，则需要技术付出。个人推荐，不必要的话，还是直接采用CDN收费服务吧，性价比更高一些。自身Web体系需要进行相应的调整。如CDN文件更新与服务器文件更新（版本号等手段）等问题。 关键技术 该部分内容，引自网易云课堂。
缓存 缓存代理软件：Squid缓存算法决定命中率，源服务器压力，FTP节点存储能力 分发能力 分发能力取决于IDC（网络数据中西）能力和IDC策略性分布 负载均衡 负载均衡软件：Nginx负载均衡（智能调度）决定最佳路由，响应时间，可用性，服务质量 基于DNS DNS服务器软件：BIND基于DNS的负载均衡以CNAME实现域名中专，智取最优节点服务缓存点有客户端浏览器缓存，本地DNS服务器缓存缓存内哦让那个有DNS地址缓存，客户请求内容缓存，动态内容缓存 支持协议 静动态加速（图片加速，https带证书加速）下载加速流媒体加速企业应用加速手机应用加速 就当扩展一下见识吧（囧）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bce26392ca6dca78ad6cce4a9916414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c43fe7e49160a7aeaa278daab1643a5/" rel="bookmark">
			Word查找替换，批量删除文档中空格、空行、指定符号中的任意内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、批量删除空格
（1）点击【开始】-【编辑】-【替换】按钮或按【Ctrl+H】组合键，打开“查找与替换”对话框，将鼠标光标定位于“查找内容”文本框中，然后点击“更多”按钮。
（2）展开“替换”栏，点击“特殊格式”按钮，在弹出菜单中选择“空白区域”选项。
（3）点击“全部替换”按钮，在“全部完成”的提示框中单击“确定”按钮，所有空格即被删除。
2、批量删除空行
Word中，回车符又称为段落标记，一个回车符表示一行结束，所以删除空行就是删除多余的回车符（段落标记），简单来说，就是把多个连续的回车符（段落标记）换成一个回车符，方法如下：
（1）打开“查找与替换”对话框，将鼠标光标定位于“查找内容”文本框中，然后点击“更多”按钮。
（2）展开“替换”栏，点击“特殊格式”按钮，在弹出菜单中选择“段落标记”选项。此时，会发现“查找内容”文本框中自动添加了^p。（但这里需要注意，空行是由多个连续的回车符（段落标记）形成）。因此，我们需要在【查找内容】中输入两个^p^p，表示查找两个连续的段落标记；而在【替换为】文本框中输入1个^p，表示将查找到的内容替换为1个段落标记。
（3）点击“全部替换”按钮，在“全部完成”的提示框中单击“确定”按钮，所有空行即被删除。
3、指定符号中的任意内容
\&lt;\!\-\-*\-\-\&gt; 注：要查找已被定义为通配符的字符，该字符前键入反斜杠 \ 。上式中的*表示任意内容
查找？、*、（、）、[ 、] 等的代码分别是\？、\*、\(、\)、\[、\] &gt; 。 4、查找多个制表符
(^13){2,} 表示2到无穷个
参考资料：
https://www.sohu.com/a/164240405_225602
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3095df6d3529a2dfbf0245d522919b8f/" rel="bookmark">
			深度学习_CNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNN反向推导链式法则 链式法则求导示例
卷积神经网络也是这样一层一层从后到前传递梯度的，有了梯度后，就可以更新参数。上图中max模拟了池化过程，此时部分神经元失活。
CNN—卷积层 注意：原图片每个pixel可以看作神经网络的输入，权值则是对应的卷积层的每一个值。故最后需要训练的参数为卷积层的值和神经网络的阈值。
我们通常会使用多层卷积层来得到更深层次的特征图。卷积层主要进行的操作是对图片进行特征提取，随着卷积层的深入它提取到的特征就越高级。如下：
上图有6个5*5*3的卷积核，对应输出的激励特征图为28*28*6的。即对应输出的神经元有28*28*6个。对于任意一个神经元，它对应的连接为5*5*3；故每个神经元有75个权值。
神经元权值共享原则
卷积神经网络引入“权值”共享原则，即一个特征图上每个神经元对应的75个权值参数被每个神经元共享，这样6个核总共需要75*6个权值参数，而每个特征图的阈值也共享，即需要6个阈值，则总共需要75*6+6个参数。
注意若卷积层为3*3*3的则，上图卷积输出为30*30*1，因为边缘不作为卷积核中心计算。n个卷积核产生n个输出（n个激励特征图）（如下图）。
卷积核基本概念：
同输入数据进行计算的二维（一维，三维）算子大小（size）用户定义，深度输入数据定义
大小一般为奇数，深度与原始数据深度相同卷积核“矩阵”值：卷积神经网络的参数卷积核初值随机生成，通过反向传播更新 卷积核参数
步长卷积核大小边界扩充（确保卷积后特征图尺度一致）（扩充方法：卷积核的宽度2i＋1，
添加pad宽度为i）卷积核数目（64、128、256 Why：GPU并行更高效） CNN正向传播，反向计算
CNN正向传播和反向传播的推导
CNN_功能层 Relu：卷积是线性运算，增加非线性描述能力
Pooling：降维，使特征图稀疏，减少数据运算量，保持精度
池化操作具体实现，以最大值池化为例。（将图片按卷积核大小均匀分块，对每一块区域选取最大值，以下图为例）
小小结
CNN=卷积层+Relu+池化+…+全连接层
归一化层：特征的scale保持一致
切分层：不同区域进行独立学习
融合层：对分开的区域合并，方便信息融合
增加图片生成或探测任务中空间信息
卷积神经网络与传统神经网络相比优点？
传统的全连接神经网络，下一层与上一层的所有神经元都有连接，训练参数多；二添加卷积层后，下一层只与卷积区域神经元相关。如下图
CNN优缺点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b1f3b5b9b37d4242bea454c661f769/" rel="bookmark">
			程序员成长之旅——文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员成长之旅——文件操作 什么是文件文件名文件类型文件缓冲区文件指针文件的打开与关闭文件的顺序读写文件的随机读写文件结束判定 什么是文件 磁盘上的文件就是文件。
但是在程序设计中，我们谈的文件一般有两种：程序文件 数据文件
程序文件
包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。
数据文件
文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。
这里和大家主要探讨一下数据文件。
文件名 文件名包含3部分：文件路径+文件名主干+文件后缀
例如：C：\windows\test.c
一个文件要有唯一的文件标识，文件标识也叫文件名。
文件类型 根据数据的组织形式，数据文件被称为文本文件或者二进制文件。
二进制文件：
数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。
文本文件：
如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。
一个数据在内存中是怎么存储的呢？
字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。
如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符一个字节），而二进制形式输出，则在磁盘上只占4个字节（VS2013测试）。
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; int main() { int a = 10000; FILE* pf = fopen("test.txt", "wb"); fwrite(&amp;a, 4, 1, pf); fclose(pf); pf = NULL; return 0; } 文件缓冲区 ANSIC 标准采用缓冲文件系统处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块文件缓冲区。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。
缓冲区大小根据C编译系统决定。
文件指针 缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。
每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名FILE.
例如,VS2008编译环境提供的 stdio.h 头文件中有以下的文件类型申明：
struct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname; }; typedef struct _iobuf FILE; 不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b1f3b5b9b37d4242bea454c661f769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17fa524358bce19f0a76e2814124b9b2/" rel="bookmark">
			Redis的事务及Spring Data Redis的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的事务及Spring Data Redis的实现 Redis的事务 简介 Redis的事务基于MULTI，EXEC，DISCARD和WATCH这四个命令实现。这四个命令组合允许在一步中同时执行多个命令。
Redis的事务主要保证了一下两个方面：
事务中的多个命令是按照添加到队列中的顺序执行的。并且在事务进行中，不会被另一个客户端的请求打断。也就是说，事务中的多个命令可以看作单个隔离的操作。事务可以保证原子性。事务的执行由EXEC命令触发，当客户端在发送EXEC命令前丢失了该事务的连接，该事务中的命令将不会被执行。如果在客户端在调用EXEC命令后丢失连接，事务的命令队列依然会被执行。Redis事务会写入磁盘文件。若Redis在事务中异常停止，在重启时会报错，可以使用redis-check-aof工具修复后再重新启动。从2.2版本开始，可以使用乐观锁对上述两种情况添加额外保证。类似与CAS操作。 事务的使用 通过MULTI进入一个事务。这个命令总是返回OK。客户端发起多个命令。Redis将这些命令依次放入队列，并不会执行。所有命令都会返回字符串QUEUED回复。当客户端执行EXEC命令后，开始执行事务。EXEC命令会返回多个结果的数组，每个元素对应事务中的一个命令，且顺序与命令顺序一致。当客户端调用DISCARD命令后，清空事务队列并退出当前事务。 事务对于错误的处理 事务中可能会碰到的错误如下：
命令排队失败。例如：命令的语法错误或者该命令可能导致一些危险，例如当设置Redis可以使用的最大内存时可能碰到内存不足的情况。调用EXEC后命令可能会执行失败。例如，因为我们对一个具有错误值的键执行了一个操作（比如对一个字符串值调用一个列表操作）。 对于第一种错误，客户端应该判断返回值是否返回字符串QUEUED来处理，例如中止并丢弃该事务。
从Redis 2.6.5开始，Redis服务器会记住在命令排队时的错误，并且拒绝执行事务，在EXEC期间返回错误，并自动丢弃事务。
在2.6.5之前，如果客户端不处理错误，继续执行EXEC，服务器将会仅执行命令队列中的正确命令。
对于第二种错误，Redis服务器不会做特殊处理，所有的命令都将会执行，即使某些命令执行错误。对于出错命令返回-ERR。
重要：在EXEC之后，事务开始执行队列中所有命令，即使碰到错误也不会中止！只会对发生执行错误的命令返回-ERR
重要：Redis事务不支持回滚！
check-and-set 乐观锁 乐观锁通过WATCH命令实现。WATCH可以用来监视一个key的变化。如果在EXEC执行前，至少一个被监视的key被修改，事务将会中止，EXEC命令返回Null来通知事务失败。
当返回事务失败时可以重复操作，直到成功。这种锁即为乐观锁。
Redis脚本和事务 Redis脚本是事务性的，因此可以使用脚本执行操作，通常脚本将更简单，更快速。
Spring Data Redis（2.1）对Redis事务的支持 RedisTemplate提供了对multi、exec和discard命令的支持。但是，RedisTemplat不会在一个连接上执行多个redis命令。Spring Data Redis提供了SessionCallback接口，支持一个连接执行多个redis命令。
因此，Spring Data Redis支持redis的事务需要依赖SessionCallback接口。
List&lt;Object&gt; txResults = redisTemplate.execute(new SessionCallback&lt;List&lt;Object&gt;&gt;() { public List&lt;Object&gt; execute(RedisOperations operations) throws DataAccessException { operations.multi(); operations.opsForSet().add("key", "value1"); // This will contain the results of all operations in the transaction return operations.exec(); } }); System.out.println("Number of items added to set: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17fa524358bce19f0a76e2814124b9b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c211050bf8f55fbf184f1ffceb3429ed/" rel="bookmark">
			Intel qsv &#43; ffmpeg 硬解h264
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quick Sync Video，简称qsv，是英特尔推出的集成加速接口，使用该接口可以硬解h264，提高解码效率的同时降低CPU占用率，ffmpeg 4.4.2中 doc\example中有一个qsvdec.c的demo，我在此基础上进行修改，实现了硬解h264。
环境准备 下载安装Intel Media Mdk，https://software.intel.com/en-us/media-sdk，选择window平台，安装后在安装目录下IntelSWTools\Intel(R) Media SDK 2019 R1\Software Development Kit 有include和lib 文件夹，拷贝lib、dll、头文件备用。
编码 创建一个VS c++ 控制台工程，将拷贝的include和lib 等复制到工程目录下，设置好库目录和包含目录以及连接库。新建一个cpp文件，qsvdev.c的代码拷贝到cpp文件，并对代码做出以下修改。
1、修改get_format返回值为AVPixelFormat
static AVPixelFormat get_format(AVCodecContext *avctx, const enum AVPixelFormat *pix_fmts) { while (*pix_fmts != AV_PIX_FMT_NONE) { if (*pix_fmts == AV_PIX_FMT_QSV) { DecodeContext *decode = (DecodeContext *)avctx-&gt;opaque; AVHWFramesContext *frames_ctx; AVQSVFramesContext *frames_hwctx; int ret; /* create a pool of surfaces to be used by the decoder */ avctx-&gt;hw_frames_ctx = av_hwframe_ctx_alloc(decode-&gt;hw_device_ref); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c211050bf8f55fbf184f1ffceb3429ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd339cfe3f64a38f5bb08a7bd778c63/" rel="bookmark">
			datetime时间格式化中间为什么有个T
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如时间为: 2020-01-12T15:17:21
国际标准化组织的国际标准ISO 8601是日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》
原文如下：
日期和时间的组合表示法编辑
合并表示时，要在时间前面加一大写字母T，如要表示北京时间2004年5月3日下午5点30分8秒，可以写成2004-05-03T17:30:08+08:00或20040503T173008+08。
所以这个T date和time合并表示时，中间加个T。
iso 8806的百度地址是：
https://baike.baidu.com/item/ISO%208601/3910715?fr=aladdin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bcade7895f7938ee869ed525264602/" rel="bookmark">
			STC89C51学习记录-利用串口传送数据控制LED的点亮。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先编写串口的初始化函数。
void UsartInit() { SM0=0; SM1=1;	//采用模式1 REN=1;	//让串口中断使能 TMOD|=0X20;	//设置计数器的工作方式 PCON|=0x80;	//最高位置1表示波特率加倍 TH1=0xf3; TL1=0xf3;	//设置波特率为4800 ES=1;	//接收串口中断 EA=1;	//开启总中断 TR1=1;	//开启计数器1的中断 } 关于LED的点亮函数，单独编写，根据发送的数值选择点亮的灯。
void LED(u8 num) { if(num == 0x01) { led1=0; } else if(num == 0x02) { led2=0; } else if(num == 0x03) { led3=0; } else if(num == 0x04) { led4=0; } else if(num == 0x05) { led5=0; } else if(num == 0x06) { led6=0; } else if(num == 0x07) { led7=0; } else if(num == 0x08) { led8=0; } else if(num == 0x00) { P2=0xff; } } 程序思路很简单，就看代码吧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75bcade7895f7938ee869ed525264602/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/222/">«</a>
	<span class="pagination__item pagination__item--current">223/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/224/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>