<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564ad50082ad85f7394134a7f8077514/" rel="bookmark">
			Qt使用msvc编译器情况下，如何进行内存泄漏检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 使用Qt5版本，编译器选择msvc2017，在测试基于tinyxml2的二次封装类接口是否存在内存泄漏问题时，寻找内存泄漏检测工具。
问题： 寻找适合Qt + msvc编程的内存泄漏检测工具
尝试： VLD Visual Leak Detector 是一款用于 C++ 的免费内存泄露检测工具，并且它在检测到内存泄露的同时还可以得到内存泄露时的调用堆栈以及所在文件和行号。
①下载：
下载地址：Visual Leak Detector | Enhanced Memory Leak Detection for Visual C++
②安装完成后，所在目录地址如下
③项目配置：
将vld头文件和库文件加到工程项目中。
我的程序代码是通过CMake的方式进行程序代码管理的，所以我在CMakeList.txt文件中加入了如下代码：
其中C:/Program Files (x86)/Visual Leak Detector 为vld的安装目录。
如果使用.pro文件的方式进行程序管理，则在pro文件中加入如下代码：
④编码实现，以及测试验证
在main.cpp文件中实现如下代码：
运行失败，程序直接崩溃（debug模式）。但是尝试使用release模式，运行正常，但是没有leak detect相关信息，没有leak相关信息属于正常现象，因为只有debug模式才会有leak信息输出。
猜测导致崩溃的原因是我的电脑上没有安装msvc的调试器。
在尝试1的基础上，进行安装msvc调试器，尝试解决问题 ①打开控制面板 的 程序与功能
②选择Windows Software Development Kit - Windows .......，右键弹出菜单，选择“更改”，如下图：
③选择“Change”，点击“next”。
④勾选“Debugging Tools for Windows”，点击“Change”进行调试器安装。
安装完成后，运行Qt程序，正确输出leak信息，如下：
修改main代码
运行，输出如下leak信息：其中红色标注部分显示了造成内存泄漏的代码所在文件及行号信息。
总结： 使用Qt + msvc方式进行程序开发时，可使用vld(Visual Leak Detector)工具实现程序内存泄漏的检测，和错误定位。需要注意的是vld依赖于debug调试器工具，如若不然，程序在添加了&lt;vld.h&gt;后在debug模式下，会出现运行崩溃。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b758358c01b5e06e6555b9e8b2599f/" rel="bookmark">
			Mysql 字段模糊查询，在页面中输入%查询全部的问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 测试小妹闲着无聊，针对某一个查询项进行“%”测试，正常查询效果应该是返回空数据，但是却查出所有的数据。
二、解决方案 1、在使用mybatis的模糊查询时，有两个特殊符号需要注意： %(百分号)：相当于任意多个字符；
_(下划线)：相当于任意的单个字符；
2、处理方法： 1：(查询条件参数，比如"xx%_x")param.replaceAll(“%”, “/%”).replaceAll(“-”, “/-”)
2：select * from table where column like concat(’%’,#{param},’%’) escape ‘/’;
处理之后百分号%、下划线_在mybatis执行该拼接的sql语句的时候就不会被转义处理了
escape ‘/’ 指用’/'说明后面的%或_就不作为通配符而是普通字符了，注意前面没有转义字符的%仍然起通配符作用
like concat(’%’,#{param},’%’) 、like ‘%${param}%’ 、 like ‘%’||#{param}||’%'是一个意思；
3、转译工具类 public class EscapeUtil { /** * mysql的模糊查询时特殊字符转义(条件查询%或者_查询所有问题) */ public static String escapeChar(String string){ if(StringUtils.isNotBlank(string)){ string = string.replaceAll("_", "/_"); string = string.replaceAll("%", "/%"); } return string.trim() ; } } 三、实战 1、实战一 假设User有一个name字段 此时在查询数据前需要做一次转译 user.setName(EscapeUtil.escapeChar(user.getName())); 在Mapper文件需要如下编码 &lt;!-- 姓名 --&gt; &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b758358c01b5e06e6555b9e8b2599f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424a2654585620b457f0f612a6ed3c9d/" rel="bookmark">
			CentOS 开机 GRUB 报错，进入救援模式修复根文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. CentOS 开机报错 从弹出的错误信息中可以看出是与 grub 相关的错误，导致系统引导异常，无法正常的进入操作系统。这类情况经常会遇到但很多时候都不知道是什么原因导致的，不过解决办法倒是有，具体见下文。
2. 使用启动盘做为引导系统 物理机可采用 U 盘利用与原系统相同的镜像制作系统启动盘，若是虚拟机的形式，则可以在虚拟机设置里设置 CD/DVD 项为使用与原系统相同的 ISO 格式镜像文件。
3. 设置并进入救援模式 (1) 随后开启机器进入 BIOS 设置，或者选择 UEFI Firmware Setting 进入设置。 (2) 设置 Boot 启动项为镜像文件； BIOS 使用 F10 保存并退出设置，与笔者相同的则可直接使用回车即可。
(3) 选择 Troubleshooting (4) 接着选择 Rescue a CentOS Stream system，回车并稍等片刻； (5) 进入以下界面提示 rescue 环境会找到已安装的 Linux 系统，并将其挂载到光盘 Linux 环境的 /mnt/sysroot 目录下，"continue" 表示挂载权限为读写，“Read_only" 为只读。因为要对系统进行修复，所以需要读写权限。一般选择第一项 "continue”，输入 1，并回车，即可进入救援模式。 4. 在救援模式中修复 Grub (1) 输入 chroot /mnt/sysroot，切换到原系统的根目录 (2) 恢复 grub
可以选择拷贝一份启动菜单到原系统目录中，或者重新生成一份。 # Option 1 拷贝 cp -rf /etc/grub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/424a2654585620b457f0f612a6ed3c9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f05b810078965c21b403c8e9bcd354b/" rel="bookmark">
			vue&#43;ElementUI（npm install）安装依赖报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误如下 npm ERR! Error while executing: npm ERR! C:\Program Files\Git\cmd\git.EXE ls-remote -h -t https://github.com/nhn/raphael.git npm ERR! npm ERR! fatal: unable to connect to github.com: npm ERR! github.com[0: 20.205.243.166]: errno=Unknown error npm ERR! npm ERR! npm ERR! exited with error code: 128 npm ERR! A complete log of this run can be found in: npm ERR! C:\Users\2209150234\AppData\Roaming\npm-cache\_logs\2023-03-29T02_02_20_678Z-debug.log 解决方法
1.应该由于npm install的网络的问题造成，建议将npm的源设置为国内的镜像，这样就可以大幅提升依赖安装速度。但是我使用淘宝镜像为：
//npm config set registry https://registry.npm.taobao.org 后 npm install // 如果此时无用，将阿里镜像换成 npm config set registry https://registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f05b810078965c21b403c8e9bcd354b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a9cb59ecd1ad1543048eec475ab245/" rel="bookmark">
			在ubuntu中，如何开机自启动一个有界面程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有多种方法可以开机自启动一个有界面程序，以下是其中两种常用的方法：
方法一：使用gnome-session-properties 打开终端，输入命令：gnome-session-properties，打开“启动应用程序首选项”窗口。
点击“添加”按钮，填写应用程序的名称、命令和注释，例如：
名称：My Program
命令：/usr/bin/myprogram
注释：启动My Program
点击“添加”按钮后，该应用程序会被添加到“启动应用程序”列表中。
关闭窗口，重启电脑后该应用程序会自动启动。
方法二：使用rc.local 打开终端，输入命令：sudo nano /etc/rc.local，编辑rc.local文件。
在文件末尾添加应用程序的启动命令，例如：
/usr/bin/myprogram &amp;
保存文件并退出。
重启电脑后，该应用程序会自动启动。
注意：使用rc.local方法需要注意以下几点：
rc.local文件必须有执行权限：sudo chmod +x /etc/rc.local。启动命令必须在文件末尾添加，且必须加上&amp;符号，使其在后台运行。启动命令必须在exit 0语句之前添加。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269c3343963511f0065abd3f44f712c5/" rel="bookmark">
			卡片翻转特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .wrapper{ width:291px; height:251px; /* border:3px solid red; */ /* 透视 */ perspective: 1000px; position: relative; } .second{ transform: rotateX(-180deg); } .wrapper img{ transition: all 1s; position: absolute; left: 0; right: 0; /* 背面不可见 */ backface-visibility: hidden; } .wrapper:hover .first{ transform: rotateX(180deg); } .wrapper:hover .second{ transform: rotateX(0deg); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="wrapper"&gt; &lt;img class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269c3343963511f0065abd3f44f712c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7a44ff6b8f64c12c8548f561060d7f/" rel="bookmark">
			Maven项目导入本地依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在打包一个javafx项目时，因为有一个jar包在mvn本地仓库和网上仓库都没有，所以打包后程序功能不完整，CSDN上看了一堆，都是介绍了一堆方法但每个方法都不太详细，唉...还是自己来吧
1. 在IDEA内执行mvn install语句将本地jar包依赖导入到仓库 mvn语法格式(我也是刚刚学会，会这一句就行，用的时候再学)
mvn install:install-file -Dfile=【我的jar包位置】 -DgroupId=【组id】 -DartifactId=【又一个id】 -Dversion=版本 -Dpackaging=【jar】 注意：【】内是需要自己填的，根据自己的情况来，别的地方原封不动抄就行了
下面解释一下：
mvn -- 就是maven的简写，调用maven的意思 install -- 代表安装本地依赖(jar包) :install-file -- 默认格式 -Dfile= --【本地jar包的位置】 -DgroupId= --【随便起也行】 -DartifactId= --【随便起也行】 -Dpackaging= --【是jar包就写jar】 比如我的，groupid那些网上找不到名字也可以自己起，我就起的dgroupId=1...老傻X了（主要是第一次不会用，以为要和网上的仓库jar包的maven依赖格式匹配，但网上又没有这个包）
注意：一定要记住我们上传的时候设置的dgroupid、dartifactId和dversion，后面还要用。
到这千万别以为完了，第1步只是把本地jar包导入到本地仓库，我们还没导入到项目中，不然你打包maven项目后发现还是确jar包。
了解一下，这是我新建项目忘记指定本地仓库了（我的maven仓库在D盘），系统默认的，这时候项目都写完再改就麻烦了，所以就这样吧，一般我们新建Maven项目一定要先指定好maven版本、仓库的位置和配置文件。
2. 在pom.xml中添加我们的依赖（把我起的这个傻X的依赖加进去） &lt;dependency&gt; &lt;groupId&gt;1&lt;/groupId&gt; &lt;artifactId&gt;1&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; 3. 更新（点一下就好） 4. 结果（这种包名也是第一次见，有良好的迷惑性） 5. 随便打包吧，没问题了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf3941c2a33c72562b34961ec4b044e/" rel="bookmark">
			实现图片随鼠标移动的动态视觉差特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如下
代码如下
&lt;script src="./jq/parallax.min.js"&gt;&lt;/script&gt;
需要使用一个js的文件
&lt;script&gt;
var scene = document.getElementById('scene');
var parallaxInstance = new Parallax(scene);
&lt;/script&gt;
HTML
&lt;div class="win"&gt; &lt;div class="win-bgc1"&gt; &lt;h2 class="win-zi1"&gt;LPL十年记录&lt;/h2&gt; &lt;span&gt;&lt;a class="win-zi2" href="#"&gt;LPL名人堂&lt;/a&gt; &lt;i class="win-bgc2"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="win-lpl" &gt; &lt;div id="scene"&gt; &lt;img class="layer" data-depth="0.2" src="./img/LPL十年历程.png" width="1300px" height="400px" alt="LPL十年记录"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS
.win { width: 100%; background-color: #ededed; padding-top: 40px; } .win-bgc1 { display: flex; width: 1340px; height: 160px; background-color: #ededed; background-image: url(../img/十年经历-title-背景.png); background-position: 30% 70%; background-repeat: no-repeat; background-size: 1920px 120px; position: relative; margin: 0 auto; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf3941c2a33c72562b34961ec4b044e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48e082aec5b161fd565bb88fe3206c3/" rel="bookmark">
			纯CSS用 :target选择器来实现点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果
代码如下
HTML
&lt;div class="maps-box"&gt; &lt;div class="kongzhi"&gt; &lt;a class="a1" href="#img1"&gt;&lt;span&gt;01.&lt;/span&gt;&lt;/a&gt; &lt;a class="a2" href="#img2"&gt;&lt;span&gt;02.&lt;/span&gt;&lt;/a&gt; &lt;a class="a3" href="#img3"&gt;&lt;span&gt;03.&lt;/span&gt;&lt;/a&gt; &lt;a class="a4" href="#img4"&gt;&lt;span&gt;04.&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="map"&gt; &lt;img class="cs-img" src="./img/无畏契约/map1.png" /&gt;&lt;span class="cs-span"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Ascent:亚海悬城&lt;/span&gt; &lt;p id="img1"&gt;&lt;img src="./img/无畏契约/map1.png" /&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Ascent: 亚海悬城&lt;/span&gt;&lt;/p&gt; &lt;p id="img2"&gt;&lt;img src="./img/无畏契约/map2.png" /&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Bind: 源工重镇&lt;/span&gt;&lt;/p&gt; &lt;p id="img3"&gt;&lt;img src="./img/无畏契约/map3.png" /&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Haven: 隐世修所&lt;/span&gt;&lt;/p&gt; &lt;p id="img4"&gt;&lt;img src="./img/无畏契约/map4.png" /&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Split: 霓虹町&lt;/span&gt;&lt;/p&gt; &lt;div class="m5-mask"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS
.mps-box { width: 1482px; margin: 0 auto 0; position: relative; } .kongzhi { position: absolute; height: 20px; top: 880px; z-index: 10; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c48e082aec5b161fd565bb88fe3206c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b23f11a0e89d9c384d430488e79bc69a/" rel="bookmark">
			如何用CSS做百叶窗特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天就教大家如何用css来实现百叶窗特效
基本原理就是
background-size: cover;
定位的使用
话不多说看代码
下面是HTML的代码
&lt;div class="cover"&gt; &lt;ul class="stacks"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 下面是CSS的代码
.cover { width: 440px; height: 440px; overflow: hidden; position: relative; } .cover .stacks{ margin: 0; padding: 0; display: flex; flex-direction: row; height: 440px; } .cover .stacks li{ background-color: #ccc; flex: 1; overflow: hidden; position: relative; transition: 1s transform ease-in-out; z-index: 20; } .cover .stacks li::after{ content: ''; display: block; width: 440px; height: 440px; background-image: url(自己的图片链接或路径); background-size: cover; background-repeat: no-repeat; position: absolute; left: 0; top: 0; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b23f11a0e89d9c384d430488e79bc69a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df952eb681cb92b541314c91c765dc8/" rel="bookmark">
			基于Jupyterlab的 csv 3D 2D 模型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{ "cells": [ { "cell_type": "code", "execution_count": 1, "id": "47dcf242-c704-40de-9e99-fdb55dd78681", "metadata": { "scrolled": true }, "outputs": [], "source": [ "import matplotlib.pyplot as plt\n", "import numpy as np\n", "%matplotlib widget" ] }, { "cell_type": "code", "execution_count": null, "id": "30c55ca9", "metadata": {}, "outputs": [], "source": [] }, { "cell_type": "markdown", "id": "fd172be9-2177-4b3e-8424-d5a564165120", "metadata": {}, "source": [ "## x轴画图范围" ] }, { "cell_type": "code", "execution_count": 2, "id": "7843b370-891d-4f19-9e9f-30b72677018b", "metadata": {}, "outputs": [], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df952eb681cb92b541314c91c765dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51919daab60c6da2c715c5fd9100c11/" rel="bookmark">
			AHP层次分析法分析流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AHP层次分析法分析流程：
一、案例背景 当前有一项研究，想要构建公司绩效评价指标体系，将一级指标分为4个，分别是：服务质量、管理水平、运行成本、安全生产，现在想要确定4个指标的权重。
AHP层次分析法是一种主观赋权法和客观赋权法相结合的方法，近年来，被广泛应用于指标权重的确定。该方法将定量分析和定性分析方法结合，先用专家经验判断指标相对重要程度，再计算权重，比较适合解决难以用定量方法应对的问题。因此本案例使用AHP层次分析法进行4个指标权重的确定。
二、专家打分 AHP层次分析法通过专家打分，确定各个指标之间的相对重要程度。此步骤包括两部分内容，分别是判断指标重要程度的标度确定，以及根据专家打分构造判断矩阵。
标度确定
多位专家将各个指标进行相互比较后，使用一个判断值来表示相对重要程度，常见的标度法有1-5分标度法（最低为1分，最高为5分），和1-9分标度法（最低为1分，最高为9分）.本案例使用1-9分标度法，取值说明如下表： 构造判断矩阵 当前共有20位专家对4个指标进行打分，采用1-9分标度法，将20位专家的打分进行计算平均分，得到最终判断矩阵表格，如下表：
上表格显示，管理水平相比于服务质量一般重要，为2分；相反服务质量相比于管理水平来讲，则为0.5分。运行成本相比于服务质量不太重要，为0.2分；相反，服务质量相比于运行成本比较重要，则为5分。其余指标相对重要程度解读也类似。
判断矩阵构造完成后，接下来就可以进行权重计算。
三、计算权重 计算权重需要依次计算特征根、最大特征根值、最后得到一致性指标CI值，用于下一步一致性检验使用。计算过程如下：
① 判断矩阵每一行元素的乘积：
上式中 aij第i个元素与第j个元素的关系比值。
② 计算Mi的n次方根：
③ 对向量进行归一化处理：
④ 计算判断矩阵的特征根：
⑤ 计算判断矩阵的最大特征根：
⑥ 计算一致性指标CI值：
在实际研究中，计算过程比较复杂，使用SPSSAU软件计算即可。在SPSSAU系统中，选择AHP层次分析法，将判断矩阵填写完成，如下图：
提示：SPSSAU只需要填写白色单元格，蓝色单元格会自动变化。
得到AHP层次分析结果如下表：
从上表可以得到，服务质量、管理水平、运行成本、安全生产4个指标使用AHP层次分析法计算权重(计算方法为：和积法)，分析得到特征向量为(1.332，2.102，0.374，0.193)；得到权重值分别为33.29%、52.54%、9.35%、4.82%；结合特征向量计算出最大特征根为4.139；接着利用最大特征根值计算得到CI值为0.046【CI=(最大特征根-n)/(n-1)】，CI值用于下述的一致性检验使用。
四、一致性检验 在构造判断矩阵时，有可能会出现逻辑错误，比如A比B重要，B比C重要，但是又出现C比A重要的情况，因此需要进行一致性检验。一致性检验使用一致性比率CR值进行分析。CR值小于0.1说明数据通过一致性检验，反之没有通过。
CR=CI/RI，CI值在上一步已经得到，为0.046，RI值直接通过查表得到，RI指标见下表：
本案例为4阶（4个指标），找到对应RI值为0.89，进行一致性检验，结果如下：
从上表可知，CR值=0.052&lt;0.1，所以本次研究案例通过一致性检验，计算所得权重具有一致性。如果未通过一致性检验，需要检查判断矩阵是否存在逻辑问题，如果存在，则重新录入判断矩阵后再次进行分析。
五、总结 AHP层次分析法为定量分析与定性分析相结合的权重计算方法，通过专家打分，构造判断矩阵后，使用AHP层次分析法计算得到服务质量、管理水平、运行成本、安全生产4个指标的权重分别为：33.29%、52.54%、9.35%、4.82%。同时AHP层次分析法需要进行一致性检验，检验判断矩阵是否存在逻辑问题。经过计算，CR值小于0.1，通过一致性检验，说明判断矩阵不存在逻辑问题，计算权重具有科学性。
参考文献：
城镇污水处理厂绩效评价研究_魏星星
整体托管煤矿安全管理水平评价研究_张建强
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73588cca8b3f5e9298040516a46b6ded/" rel="bookmark">
			LVS部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、LVS-DR
为方便进行原理分析，将Clinet与群集机器放在同一网络中
1、数据包流向分析
（1）客户端发送请求到 Director Server（负载均衡器），请求的数据报文（源IP是CIP,目标IP是VIP）到达内核空间。
（2）Director Server 和 Real Server（节点服务器）在同一网络中，数据通过二层数据链路层来传输
（3）内核空间判断数据包的目标IP是本机VIP，此时IPVS（IP虚拟服务器）比对数据包请求的服务是否为集群服务，是集群服务就重新封装数据包。修改源MAC地址为Director Server的MAC地址，修改目标MAC地址为Real Server的Mac地址，源IP地址与目标IP地址没有改变，然后将数据包发送给Real Server
（4）到达Real Server的请求报文的MAC地址是自身的MAC地址，就接受此报文。数据包重新封装报文（源IP地址为VIP，目标IP为CIP），将响应报文通过lo接口传送给物理网卡然后向外发出，Real Server事先绑定了VIP
（5）Real Server直接将响应报文传送到客户端
注：如果跨网段，则报文通过路由器经由Internet返回给用户
2、LVS-DR中的ARP问题
（1）问题1
在局域网中具有相同的IP地址，势必会造成各服务器ARP通信的紊乱
1）当ARP广播发送到LVS-DR集群时，因为负载均衡器和节点服务器都是连接到相同网络上，它们都会接收到ARP广播
2）只有前端的负载均衡器进行响应，其他节点服务器不应该响应ARP广播
解决方案
对节点服务器进行处理，使其不响应针对VIP的ARP请求
1）使用虚接口lo:0承载VIP地址
2）设置内核参数arp_ignore=1（系统只响应目的IP为本地 IP的ARP请求）
（2）问题二
RealServer返回报文(源IP是VIP)经路由器转发，重新封装报文时,需要先获取路由器的MAC地址。发送ARP请求时，Linux默认使用IP包的源IP地址(即VIP)作为ARP请求包中的源IP地址，而不使用发送接口的IP地址如：ens33
1）路由器收到ARP请求后，将更新ARP表项。原有的VIP对应Director的MAC地址会被更新为VIP对应RealServer的MAC地址
2）路由器根据ARP表项，会将新来的请求报文转发给Realserver，导致Director的VIP失效
解决方案
对节点服务器进行处理，设置内核参数 arp_announce=2（系统不使用IP包的源地址来设置ARP请求的源地址，而选择发送接口的IP地址）
3、DR模式的特点
（1）Director Server和Real Server必须在同一个物理网络中
（2）Real Server可以使用私有地址，也可以使用公网地址，如果使用公网地址，可以通过互联网对RIP进行直接访问
（3）Director Server作为集群的访问入口，但不作为网关使用
（4）所有的请求报文经由Director Server，但回复响应报文不能经过Director Server
（5）Real Server的网关不允许指向Director Server IP，即Real Server发送的数据包不允许经过Director Server
（6）Real Server上的lo接口配置VIP的IP地址
二、LVS-DR集群构建
1、案例环境
VIP:192.168.142.100
负载调度器：192.168.142.4
Web节点服务器1:192.168.142.5
Web节点服务器2:192.168.142.6
NFS服务器：192.168.142.10
客户端：192.168.142.3
2、配置负载调度器：192.168.142.4
（1）配置虚拟IP地址（VIP:192.168.80.100）
1
2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73588cca8b3f5e9298040516a46b6ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d7a15f43ca1b9bcb70109ee6db34a82/" rel="bookmark">
			毕业设计stm32选题100例(四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【单片机毕业设计项目分享系列】
🔥 这里是DD学长，单片机毕业设计及享100例系列的第一篇，目的是分享高质量的毕设作品给大家，包含全面内容：源码+原理图+PCB+实物演示+论文。
🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的单片机项目缺少创新和亮点，往往达不到毕业答辩的要求，为此学长准备了相对容易且工作量达标，并包含创新点的项目分享给大家。
🧿 整理的题目标准：
相对容易工作量达标题目新颖，含创新点 🧿 项目分享：
https://gitee.com/sinonfin/sharing
课题项目1 :STM32的FRID高速收费系统 主要功能: 一款基于STM32的FRID高速收费系统，可以实现小车和货车两种车型收费，当车辆超过了规定的重量后，出现声光报警提示，并且启动杆不会抬起，只有当车辆重量低于设置值时，启动杆才会自动抬起，当启动杆抬起后，开始计费，直到车辆驶离高速。
1、车辆称重，2个分区（小车：1kg以内、货车：2kg以内，利用按键选择），超重无法上高速，并声光报警。
2、刷卡之后杆子自动抬起落下（四相步进机），防追杆。功能，前车过去，闸门才自动落下（分离式红外对管）
3、刷卡后，开始时间计费（小车1元/分钟，货车2元/分钟）。
4、如果车辆长时间不出高速，会报警提示值班人员，对高速进行排查。
5、通过按键设置各阈值（超载值、计费单价、时长）
6、通过显示屏显示数据
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目2：STM32的wifi照明控制系统 主要功能: 此路灯系统使用STM32为主控制器，有两种工作模式，分别是手动模式和自动模式。
自动模式:使用光敏电阻模块采集环境亮度值和使用SR501检测人体，当环境亮度值较低且检测到人体的时候，灯会自动打开，且会根据环境亮度值的不同，灯光亮度会自动调节。
手动模式:通过按键控制灯的亮灭，使用按键调整灯光亮度，有三个档位可选择。
1.使用STM32F103C8T6单片机做主控制器。
2.使用OLED显示灯的状态、工作模式、环境亮度值、灯的档位。
3.使用WiFi模块（ESP-01）连接手机，可在手机端控制灯的状态、工作模式、工作档位。且采集的亮度值会上传至手机端。
4.使用光敏电阻模块采集当前环境的亮度值。
5.使用L298N驱动模块驱动路灯。
6.使用SR501传感器检测人体。
7.三个按键可控制灯的亮灭、工作模式、工作档位。
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目3：STM32的智能饮水机控制系统 主要功能: 使用STM32为主控制器，LCD1602显示当前信息:水温、模式、设置水温。DS18b20检测当前饮水机水温，水位传感器检测是否有水，无水情况下蜂鸣器发出声光报警，且所有功能停止（防干烧）并显示:Water！（提醒加水）。
1.使用STM32F103C8T6单片机做主控制器。2.使用LCD1602显示采集到的水温、模式、设置水温值。3.使用DS18b20检测当前饮水机水温值。4.使用水位传感器检测是否有水。5.使用继电器控制加热片加热和水泵出水。6.当无水的情况下，蜂鸣器进行声光报警提醒，并且停止所有的功能，直到检测到有水。7.四个按键分别对应:加热、出水，温度加、温度减的功能。Normal：常温模式Water:缺水警告Hot:加热模式open:水泵出水 资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目4：单片机恒温箱控制系统 主要功能:将温度控制在一个范围内，恒定温度的作用。使用DS18B20采集温度，当温度过高时，会自动降温，当温度过低时，会自动升温。让温度一直恒定在设置的范围内。
1.使用STC89C52RC单片机做主控制器。
2.使用LCD1602实时显示当前温度值、温度上限值、温度下限值。
3.使用DS18B20采集当前环境温度值。
4.使用三个按键可任意调整上下限阀值。
5.当温度超过了预设上下值时，蜂鸣器会自动报警，且会自动打开升温或降温的继电器，继电器会带动加热片加热或制冷片制冷。
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目5：单片机酒驾酒精检测系统 主要功能有：
1.使用MQ-3检测驾驶人员是否存在酒驾行为。
2.使用LCD1602实时显示驾驶人员体内酒精含量，当驾驶人员体内酒精含量超过了预设阈值，蜂鸣器会自动进行报警，伴随红色指示灯点亮，继电器吸合。
3.单片机:将采集到的酒精含量送至显示屏，并与阀值进行比较，超标报警，未超标绿色指示灯常亮，表示可以通行。
4.阀值设置按键:报警阀值可通过三个按键进行任意调整。
5.继电器:模拟自动熄火装置，当酒精含量超标时，继电器自动吸合，模拟汽车自动熄火。
6.蜂鸣器报警:当检测到酒精含量超标后，蜂鸣器自动报警（并且红色指示灯点亮，表示不可通行）。
本设计主要由酒精探测传感器电路、单片机、灯光报警电路、负载驱动电路、控制程序和编解码程序等组成。:
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 🧿 项目分享：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d7a15f43ca1b9bcb70109ee6db34a82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aadce0eefa5d31b685b50ead572a144/" rel="bookmark">
			毕业设计stm32选题100例(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【单片机毕业设计项目分享系列】
🔥 这里是DD学长，单片机毕业设计及享100例系列的第一篇，目的是分享高质量的毕设作品给大家，包含全面内容：源码+原理图+PCB+实物演示+论文。
🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的单片机项目缺少创新和亮点，往往达不到毕业答辩的要求，为此学长准备了相对容易且工作量达标，并包含创新点的项目分享给大家。
🧿 整理的题目标准：
相对容易工作量达标题目新颖，含创新点 🧿 项目分享：
https://gitee.com/sinonfin/sharing
课题项目1 : stm32的人体健康状态检测系统 主要功能
基于stm32的人体状态检测
1.利用max30100传感器测心率、血氧
2.利用体温传感器测量体温
3.利用mpu6050传感器检测自己身体倾斜状态（是否摔倒）
4.显示在oled
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目2：stm32智能语音垃圾分类系统 1：通过一级级口令进入识别模式，通过识别二级口令进行分类，对垃圾分为四大类：厨余垃圾、可回收垃圾、有害垃圾、其他垃圾。
2：将识别出来的垃圾种类播报出来。
3：根据垃圾种类驱动对应的舵机进行转动（模拟垃圾桶打开，并在十秒钟自动复位，模拟垃圾桶关闭）
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目3：stm32与GSM的远程无线智能报警系统 硬件由传感器网路、PT2262/2267无线收发模块、MCU控制器、GSM模块组成。
传感器部分主要是采集家中安全信息，如温度、门窗的移动情况。GSM模块主要是用于联系用户，现代在手机十分普及的背景下，采用GSM模块进行短息或语音通话直接通知户主家庭安全情况，会非常快捷，使得家中安全情况得到及时处理。
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
课题项目4：基于RFID门禁防盗报警系统 实现RFID家庭安防门禁效果
系统的主要电路包括： 读卡器数据采集电路、 串行 E 2 PROM 存储电路、 LCD1602 显示电路、 串口通讯电路、 报警电路、 门控电路、 键盘电路。
软件的设计主要包括： 数据采集模块、 存储模块、 显示模块、 门控模块、 报警模块、 键盘模块和上位机软件的设计几个方面
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目5：单片机与GSM的手机短信收发系统 单片机与GMS模块结合，实现消息收发
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：2分工作量：2分创新点：3分 🧿 项目分享：
https://gitee.com/sinonfin/sharing
未完待续，关注DD学长，持续更新 。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db45c2fde7d5c9b40236d9c637101c6c/" rel="bookmark">
			程序人生：初学者中最最最常问的问题都有哪些呢？？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		隔行如隔山，初学编程往往不知道从何入手，非常迷茫，以下几个问题是我经常被问到的，总结出来分享给读者。
1) 多久能学会编程？ 这是一个没有答案的问题。每个人投入的时间、学习效率和基础都不一样。如果你每天都拿出大把的时间来学习，那么两三个月就可以学会C/C++，不到半年时间就可以编写出一些软件。
但是有一点可以肯定，几个月从小白成长为大神是绝对不可能的。要想出类拔萃，没有几年功夫是不行的。学习编程不是看几本书就能搞定的，需要你不断的练习，编写代码，积累零散的知识点，代码量跟你的编程水平直接相关，没有几万行代码，没有拿得出手的作品，怎能称得上“大神”。
每个人程序员都是这样过来的，开始都是一头雾水，连输出九九乘法表都很吃力，只有通过不断练习才能熟悉，这是一个强化思维方式的过程。
知识点可以在短时间内了解，但是思维方式和编程经验需要不断实践才能强化，这就是为什么很多初学者已经了解了C语言的基本概念，但是仍然不会编写代码的原因。
程序员被戏称为”码农“，意思是写代码的农民，要想成为一个合格的农民，必须要脚踏实地辛苦耕耘。
也不要压力太大，一切编程语言都是纸老虎，一层窗户纸，只要开窍了，就容易了。
2) 学编程难吗？ 编程是一门技术，我也不知道它难不难，我只知道，只要你想学，肯定能学会。技术就是一层窗户纸，是有道理可以遵循的，在我看来，比搞抽象的艺术要容易。
在技术领域，编程的入门门槛很低，互联网的资料很多，只要你有一台计算机，一根网线，具备初中学历，就可以学习，投资在5K左右。
不管是技术还是非技术，要想有所造诣，都必须潜心钻研，没有几年功夫不会鹤立鸡群。所以请先问问你自己，你想学编程吗，你喜欢吗，如果你觉得自己对编程很感兴趣，想了解软件或网站是怎么做的，那么就不要再问这个问题了，尽管去学就好了。
3) 英语和数学基础不行，可以学会吗？初中毕业可以学会吗？ 首先说英语。编程需要你有英语基础，初中水平完全可以胜任。编程起源于美国，代码中会出现很多单词，有英语基础记忆起来会非常容易，如果你不认识也没关系，我推荐你安装有道词典，它的划词功能非常棒，选中什么就及时翻译什么，不管是句子还是单词。这样，相信你开发出常用的软件不成问题。
当然，如果你希望达到很高的造诣，希望被人称为大神，那么肯定要阅读英文的技术资料（不是所有资料都被翻译成了中文），初中水平就有点吃力了。不过，长期阅读英文会提高你的英文水平，只要你坚持一段时间，即使只有初中水平，我相信借助有道词典也会提高很快。
如果你没有学过英语，不知道 am、is、are，那我该怎么说呢，有志者事竟成，只要你想学，相信英语的障碍你也能克服。
至于数学，只要你不打算搞算法、机器学习/人工智能、大数据/数据分析，会加减乘除法，知道次方、开方、科学计数法等最基本的概念，就不要把数学当做学习的障碍了。
4) 需要什么配置的电脑？ 如果你囊中羞涩，3K以上的台式机，4K以上的笔记本也可以胜任，当然有时候会卡顿。
经济条件允许的话，最好5K以上的台式机，6K以上的笔记本。
如果想从事编程行业，你早晚要有一台高配的机器。它不但会让你工作更加流畅有效率，还会让你觉得工作是一种享受，所以很多程序员配备了MacBook。
5) 学习编程要用Linux吗？ 很多大神都轻视地说，我不用Windows，一直在用Linux，只有Linux才能让你看到C的本质，C就是为Linux而生的。
话虽没错，但是你想想当初你学习Windows花了多长时间，是不是一开始连切换输入法也不会，编辑Word文档也不会；如果你切换到Linux，你也会遇到同样的问题，你需要一段时间来熟悉Linux，加大了你的学习成本，会慢慢消磨掉你对编程的兴趣。
所以我建议，你可以在Windows下学习C语言，完全没问题，如果有一天Windows不能满足你的学习需求了，那你再切换到Linux，这个时候你对编程已经很了解了，切换的成本也低了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4897909b6c6ce5eb00732ac0c6df7ea/" rel="bookmark">
			C语言：求 1! &#43; 2! &#43; 3! &#43; ... &#43; n!（for循环）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决问题：C语言利用 for循环：求 1! + 2! + 3! + ... + n!
代码实现
# include &lt;stdio.h&gt; int main(void) { int n = 0; int i = 0; int m = 1; int sum=0; printf("请输入n的值:"); scanf("%d", &amp;n); for (i=1; i&lt;=n; ++i) { m = m * i; sum = sum +m; } printf ("sum = %d\n", sum); return 0; } 知识点剖析
这个程序虽然短，但逻辑性很强，算法很好，所以建议读者记住。因为逻辑性强，所以只看是很难明白的，自己在纸上试一下，将自己当成计算机一步步地计算就明白了。
假如 n=4：
当 i=1 时，m=1，sum=1。当 i=2 时，m=1×2，sum=1+1×2。当 i=3 时，m=1×2×3，sum=1+1×2+1×2×3。当 i=4 时，m=1×2×3×4，sum=1+1×2+1×2×3+1×2×3×4。 看出规律来了吗？m 的值是一直往下乘，乘以 i 之前 m 的值是（i–1）的阶乘，乘以 i 之后 m 的值就是 i 的阶乘了。这样 i 循环到多少，m*i 就立刻将这个数的阶乘计算出来，然后加到 sum 中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eeaddb6d1e7c28b6ed3a22bd8e17fa3/" rel="bookmark">
			输入框正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 只能是数字 onkeyup="this.value=this.value.replace(/[^\d]/g,'') " 输入法
oninput="value=value.replace(/[^\d]/g,'') " 不能输入空格 onkeyup="this.value=this.value.replace(/\s+/g,'')" 数字负数小数 onkeyup="this.value=this.value.replace(/[^-\d\.]/g,'')" 允许输入括号 &amp;&amp; || 数字 onkeyup="this.value=this.value.replace(/[^/(/\/)/\&amp;\d\|]/g,'')" 允许输入括号 &amp;&amp; || 数字和字母 onkeyup="this.value=this.value.replace(/[^/ /\/(/\/)/\&amp;\a-z\A-Z\d\ / /|]/g,'')" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b103c97e82201c244497c31b983dbd/" rel="bookmark">
			OpenApi接口的一次调用经历(附代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去弄一个api_key：https://platform.openai.com/account/api-keys 先看所有能用的模型：
​ import openai openai.api_key = 'sk-3MXseSpzjlPaPg0jKMPuT3BlbkFJ70WHA5twkr' # 列出所有GPT-3模型 models = openai.Model.list() for model in models["data"]: print(model["id"]) ​ 返回：
babbage davinci text-davinci-edit-001 babbage-code-search-code text-similarity-babbage-001 code-davinci-edit-001 text-davinci-001 ada curie-instruct-beta babbage-code-search-text babbage-similarity whisper-1 code-search-babbage-text-001 text-curie-001 code-search-babbage-code-001 text-ada-001 text-embedding-ada-002 text-similarity-ada-001 ada-code-search-code ada-similarity text-davinci-003 code-search-ada-text-001 text-search-ada-query-001 davinci-search-document ada-code-search-text text-search-ada-doc-001 davinci-instruct-beta text-similarity-curie-001 code-search-ada-code-001 ada-search-query text-search-davinci-query-001 curie-search-query gpt-3.5-turbo-0301 davinci-search-query babbage-search-document ada-search-document text-search-curie-query-001 text-search-babbage-doc-001 gpt-3.5-turbo curie-search-document text-search-curie-doc-001 babbage-search-query text-babbage-001 text-search-davinci-doc-001 text-search-babbage-query-001 curie-similarity curie text-similarity-davinci-001 text-davinci-002 davinci-similarity cushman:2020-05-03 ada:2020-05-03 babbage:2020-05-03 curie:2020-05-03 davinci:2020-05-03 if-davinci-v2 if-curie-v2 if-davinci:3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b103c97e82201c244497c31b983dbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf52165a9e3e164e3489fd85d24bcc83/" rel="bookmark">
			Linux-磁盘挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 说明 避免一头雾水，请先看完说明，再看最下面的挂载教程
1.1 挂载流程 START–&gt;查看要挂载的是哪块硬盘–&gt;将硬盘分区–&gt;格式化分区–&gt;设置开机自启（即永久挂载）–&gt;执行挂载命令–&gt;END
1.2 查看当前挂载的磁盘，磁盘剩余的空间 $ df -h 查看某个文件夹/文件大小可以用这个命令du -sh /usr
1.3 查看分区情况 $ fdisk -l 当前系统一共存在三块磁盘：sda，sdb，sdc；其中sda已经有两个分区sda1和sda2。也可以使用lsblk命令查看具体的磁盘分区情况
2 挂载磁盘正文 我们以挂载未分区的vdb到/data目录为例子
2.1 查看分区情况 $ fdisk -l
Disk /dev/vdb: 200 GiB, 214748364800 bytes, 419430400 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 2.2 设置分区 $ fdisk /dev/vdb
Changes will remain in memory only, until you decide to write them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf52165a9e3e164e3489fd85d24bcc83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bd9a25e51dd2652f8422e1bef5e46f/" rel="bookmark">
			[MySQL]如何选择合适的分布式主键方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 分布式主键是什么？什么情况下使用分布式主键？几种合适的分布式主键方案分布式主键的应用 分布式主键是什么？ 我们知道分布式，也知道主键，可将两个词组合起来“分布式主键”，又是什么呢？
分布式主键是一种用于在分布式系统中唯一标识数据的方案。在分布式系统中，数据通常被分散存储在不同的节点上，为了保证数据的唯一性和一致性，需要为每个数据分配一个唯一的标识符，即分布式主键。
分布式主键可以是任何可以唯一标识数据的值，比如UUID、数据库自增主键、分布式ID生成器等。分布式主键的选择需要考虑数据分布均匀性、唯一性、可排序性、易于生成和管理、性能和可扩展性等因素。使用分布式主键可以帮助分布式系统实现数据的唯一性和一致性，避免数据冲突和重复，同时也方便数据的查询和管理。
什么情况下使用分布式主键？ 选择合适的分布式主键方案需要考虑以下几个因素：
1. 数据分布均匀性： 分布式主键要能够让数据在不同节点之间均匀分布，避免数据倾斜问题。
2. 唯一性： 分布式主键要保证每个节点生成的主键都是唯一的，避免主键冲突问题。
3. 可排序性： 分布式主键要能够支持按照时间顺序进行排序，方便数据的查询和分析。
4. 易于生成和管理： 分布式主键的生成和管理应该是简单可靠的，不会给系统带来额外的负担。
5. 性能和可扩展性： 分布式主键的生成和查询应该具备高性能和可扩展性，能够满足系统的高并发和大规模数据存储需求。
几种合适的分布式主键方案 基于以上因素，可以选择以下几种分布式主键方案：
1. 数据库自增主键： 使用数据库自增主键可以保证唯一性和数据分布均匀性，且易于生成和管理，但是无法按时间排序，且在分布式环境下需要考虑主键生成的并发问题。
2. UUID： 使用UUID作为分布式主键可以保证唯一性和数据分布均匀性，但是无法按时间排序，且由于UUID长度较长，可能会影响性能和存储空间。
3. 雪花算法： 雪花算法可以生成唯一的、有序的分布式主键，适合按时间排序的场景，但是需要保证时钟的同步性，且在高并发场景下可能会出现冲突问题。
4. 分布式ID生成器： 使用分布式ID生成器（如Twitter的Snowflake）可以生成唯一的、有序的分布式主键，同时支持按时间排序，且具备高性能和可扩展性，但是需要保证时钟的同步性，且需要考虑分布式环境下的负载均衡和故障恢复等问题。
补充：雪花算法（了解）
雪花算法（Snowflake）是一种分布式唯一ID生成算法，由Twitter公司开发。它可以生成唯一的、有序的64位ID，其中包括一个41位的时间戳（精确到毫秒级）、10位的机器标识符和12位的序列号。
具体来说，雪花算法的64位ID格式：| 1位 | 41位时间戳（毫秒级） | 10位机器标识符 | 12位序列号 |
其中，1位为符号位，固定为0；41位时间戳可以支持69年的时间范围；10位机器标识符可以支持1024台机器；12位序列号可以支持每台机器每毫秒产生4096个ID。
雪花算法的核心思想是将64位ID按照时间戳、机器标识符和序列号进行拼接，保证每个ID都是唯一的、有序的。具体生成过程如下：1. 获取当前时间戳，精确到毫秒级。2. 将时间戳左移22位，将机器标识符左移12位。3. 生成一个序列号，如果当前毫秒内的序列号已经达到4096个，那么等待下一毫秒再生成序列号。4. 将时间戳、机器标识符和序列号进行拼接，得到一个64位的唯一ID。
雪花算法的优点是生成的ID有序、唯一、可排序，且可以满足高并发场景下的需求。但是需要注意的是，由于雪花算法依赖于机器标识符和时间戳，因此需要保证每台机器的时钟同步性，避免时钟回拨等问题；同时需要考虑分布式环境下的负载均衡和故障恢复等问题。
此外，还有两种也比较不错的方案：Redis生成ID和zookeeper生成唯一ID。
Redis生成ID：
Redis生成ID需要保证每个ID都是唯一的，否则会出现主键冲突问题。
Redis生成ID需要考虑并发问题，如果多个客户端同时请求生成ID，需要保证生成的ID是唯一的。
Redis生成ID需要考虑性能问题，如果Redis负载过高，可能会影响ID生成的性能。
Redis生成ID需要考虑可扩展性问题，如果需要支持更高的并发和更大规模的数据存储，需要考虑Redis集群化部署和数据分片等问题。
综上所述，Redis生成ID可以作为一种分布式主键的方案，但需要根据具体业务场景进行调整和优化。如果需要保证更高的性能和可扩展性，可以考虑使用分布式ID生成器（如雪花算法）等更专业的方案。
zookeeper生成唯一ID：
zookeeper生成唯一ID核心思想是利用zookeeper的节点顺序特性来生成唯一的ID。
具体来说，生成唯一ID的流程如下：
在zookeeper上创建一个持久节点，用于存储ID的基础值，比如初始值为0。
当需要生成唯一ID时，客户端在zookeeper上创建一个临时顺序节点，节点名称为“ID-”，并将持久节点的值加1，并将加1后的值作为节点的数据。
客户端可以通过监视zookeeper上的节点变化来获取生成的唯一ID。
由于zookeeper的节点顺序特性，每个客户端创建的临时顺序节点的名称是唯一的、有序的，因此可以通过节点名称来生成唯一ID。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7bd9a25e51dd2652f8422e1bef5e46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79c305a66a20caefc9a321d266b9c2b/" rel="bookmark">
			【学习记录】镭神32线激光雷达ROS下运行fromRosMsg()报错 Failed to find match for field “intensity“ 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日采用ROS的fromRosMsg()将ros下的点云数据转成PCL时，报错 “Failed to find match for field ‘intensity’”。调试半天，确定问题并解决。
1. RVIZ查看发布数据是否包含Intensity 首先采用rviz看了下镭神的ros下驱动发布的数据是否包含了intensity数据。
虽然是显然应该包括的，但调试了半天一直收不到数据我都怀疑它没有发出来。
打开rviz订阅点云数据，然后将颜色显示按照intensity进行显示，如果按照intensity字段能够显示出不同的的颜色，那么就是本身包含了intensity数据的。
2. 查看发布的 RosMsg 数据 网上一般解释，这个报错往往发生在自定义的点云数据类型。但我这里转化的是将 PointCloud2 转成标准的 pcl::PointXYZI，所以一开始完全没有往数据格式上考虑。
不会真的是数据格式不正确吧？于是我输出了此时的点云：
rostopic echo /lslidar_points_cloud 部分输出如下：
header: xxx height: 32 width: 2244 fields: - name: "x" offset: 0 datatype: 7 count: 1 - name: "intensity" offset: 16 datatype: 2 count: 1 is_bigendian: False point_step: 32 row_step: 71808 data: [0, 0, 0, 0, 0, 0, 0, ...] is_dense: False 由于这个信息是编码后的，所以无法直接从data中读取出来是否含有intensity。但注意到intensity下的datatype是2，这个含义是啥呢？进一步输出PointCloud2的message：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d79c305a66a20caefc9a321d266b9c2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f523ed6bb8c2f628d0cfd78e3bfdb37/" rel="bookmark">
			完了，CPU100%了，教你如何快速定位CPU100%问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天特地把我和同事，之前遇到过的Cpu使用率100%的问题，总结了一下，给有需要的朋友一个参数。
前言 cpu使用率100%问题，是一个让人非常头疼的问题。因为出现这类问题的原因千奇百怪，最关键的是它不是必现的，有可能是系统运行了一段时间之后，在突然的某个时间点出现问题。
今天特地把我和同事，之前遇到过的cpu使用率100%的问题，总结了一下，给有需要的朋友一个参数。
1、一次性获取的数据太多 我之前参与过餐饮相关的业务系统开发，当时我所在的团队是菜品的下游业务。
当时菜品系统有菜品的更新，会发kafka消息，我们系统订阅该topic，就能获取到最近更新的菜品数据。
同步菜品数据的功能，上线了一年多的时候，没有出现过什么问题。
但在某一天下午，我们收到了大量CPU100%的报警邮件。
追查原因之后发现，菜品系统出现了bug，我们每次获取到的都是全量的菜品数据，并非增量的数据。
一次性获取的数据太多。
菜品修改还是比较频繁的，也就是说我们系统，会频繁的读取和解析大量的数据，导致CPU不断飙升。
其根本原因是频繁的full gc。
2、kafka自动确认 之前我们的餐饮子系统中间，是通过消息中间件：kafka进行通信的。
上游系统中产生了数据，写入db之后，然后把相关业务单据的id，通过kafka消息发送到broker上。
下游系统订阅相关topic的消息，获取业务单据的id，然后调用上游系统的业务查询接口，获取相关业务数据。
刚开始为了方便，我们消费订单消息时，kafka的确认机制，使用的是自动确认（可以少写点代码）。
刚开始问题不大。
随着业务的发展，用户量越来越多，每天产生的kafka消息也越来越多。
终于开始爆出了cpu使用率100%的问题。
后来，我们把kafka的consumer，消费消息后改成手动确认，cpu使用率100%的问题就被解决了。
3、死循环 在实际工作中，可能每个开发都写过死循环的代码。
死循环有两种：
在while、for、forEach循环中的死循环。无限递归。 这两种情况，程序会不停的运行，使用寄存器保存循环次数或者递归深度，一直占用cpu，导致cpu使用率飙升。
在使用JDK1.7时，还有些死循环比如多线程的环境下，往HashMap中put数据，可能会导致链表出现死循环。
就会导致cpu不断飙高。
4、多线程导数据 之前我们组有位同事做了一个供应商excel数据导入功能。
该功能上线之后发现excel中数据只要稍微多一点，导入的耗时时间就会很长。
因为导入供应商相关的业务逻辑有些复杂，涉及了多张表，而且是单线程中一条条按顺序导入的。
那位同事为了提升导入数据的性能，将单线程导入，改成了使用线程池的多线程导入。
这样改造之后，excel数据导入的速度确实提升了很多。
但上线之后，却带来另外一个问题，即：CPU使用率一路飙升。
多线程导入数据，如果线程数量比较多，会存在大量线程上下文切换的过程，这个过程非常消耗CPU资源。
5、同步大量文件 我之前参与过游戏平台的开发。
游戏厂商的游戏接入我们平台，我们帮他们推广，赚了钱进行分成。
每一款游戏都有一个定制化的官网，域名、图片和样式都不一样。
当时出于性能考虑，我们当时使用了FreeMarker模板引擎，为每一款游戏都生成专门的html的静态官网。
当时提供了十几个不同的模板，可以给游戏的运营同学选择。
原本是没啥问题的。
但有一次节日活动，为了增加一些喜庆的元素，在每一个模板文件中都加了一些样式。
这就需要把所有游戏的官网，用新的模板重新生成一次了。
生成完毕之后，需要把所有的html文件，一次性同步到web服务器的指定目录下。
由于涉及到了大量文件的同步，导致存放文件的那台应用服务器CPU飙升的很高。
6、死锁 为了防止并发场景中，多个线程修改公共资源，导致的数据异常问题。
很多时候我们会在代码中使用synchronized或者Lock加锁。
这样多个线程进入临界方法或者代码段时，需要竞争某个对象或者类的锁，只有抢到相应的锁，才能访问临界资源。其他的线程，则需要等待，拥有锁的线程释放锁，下一次可以继续竞争那把锁。
有些业务场景中，某段代码需要线程获取多把锁，才能完成业务逻辑。
但由于代码的bug，或者释放锁的顺序不正确，可能会引起死锁的问题。
例如：
"pool-4-thread-1" prio=10 tid=0x00007f27bc11a000 nid=0x2ae9 waiting on condition [0x00007f2768ef9000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x0000000090e1d048&gt; (a java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f523ed6bb8c2f628d0cfd78e3bfdb37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0c462d6c2e1e0f52215902bc1e4d4f/" rel="bookmark">
			云服务器centos8搭建网站 apache&#43;php&#43;mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于对数据库容量要求比较大，年费用300左右的普通虚拟主机只能提供500M-1G的数据库，不能满足要求，故寻找到同样费用的云服务器单核、1G内存、系统盘50G，缺点是只提供基本系统centos，其他要自己搭建，经过一周摸索终于能正常运行。
全部安装完成后占用硬盘8G左右，包括2G的扩充虚拟内存。原机提供的1G内存很容易用完（mysql占用40%-60%内存），这样系统会杀死一些进程，使得网站可能不能正常使用。所以要扩充虚拟内存。
这里使用的是HK的云服务器，有些服务商安装初始系统时已经给配置了虚拟内存，用 free -h 查看swap情况。
这里系统软件选择的是centos8
*****************************每部分间隔*****************************************
0、前期准备
a、一般通过SSH协议终端模拟器软件远程操作服务器，所以要下载相关软件，这里用Xshell，软件下载、使用都很简单的，这里就不介绍了。
b、由于要经常使用vi编辑文件，vi默认没有显示行号，下面先增加行号显示
echo 'set nu' &gt;&gt; /etc/virc
//没有行号无所谓的可以略过
c、为了传文件方便，安装上传下载软件，可以不装
yum install lrzsz -y
d、暂时先关闭防火墙，如果没开就略过
systemctl stop firewalld
*****************************每部分间隔*****************************************
1、扩充虚拟内存
如果服务商已经扩充了虚拟内存，可跳到第2步。
使用dd命令创建名为swapfile 的swap交换文件（文件名和目录任意）1m*2048=2G ，内存大小根据需要来定。
dd if=/dev/zero of=/var/swapfile bs=1M count=2048 对交换文件格式化并转换为swap分区
mkswap /var/swapfile
挂载并激活分区
swapon /var/swapfile
//如果不能正常开通，就增加权限 chmod -R 0600 /var/swapfile
开机启动设置
echo "/var/swapfile swap swap defaults 0 0" &gt;&gt; /etc/fstab
vi /etc/sysctl.conf
//在最后一行加上“vm.swappiness=30” 一般是60，
或 echo "vm.swappiness = 30" &gt;&gt; /etc/sysctl.conf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb0c462d6c2e1e0f52215902bc1e4d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62348f515ee8af6947d4efdbdaeb1541/" rel="bookmark">
			P,NP,NPC,NPH的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 P问题： 这个问题存在一个多项式时间复杂度的解，多项式时间复杂度直白点就是幂函数，如： n 的2次幂，n的3次方，而n是 待处理数据个数，而O（n 的 a次方）就是一个 多项式时间复杂度，我们习惯上只取 多项式中的高次幂， n的2次方 + n + b，只说他是n 的 2次方 时间复杂度
NP问题：他不确定存在一个多项式时间复杂度的解，但是它在多项式时间复杂度内 得出一个正确的解， 俗称蒙对了NPC问题： 前提： 1. 他是一个np问题
2. 他是对所有问题复杂化后的的最终问题，什么意思？
意思是如果我们能学会高中的数学，那么小学的数学是不是看一眼就会了
等价于，如果我们能找到一个np问题复杂化的最终问题 的多项式时间复杂度的解，那么我们就能求出这个np的 解，也就是 由 npc ==》 np == 》 p
nph问题： 相对于npc 问题，nph 没有 npc的第一个前提，即NPH不是一个np问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424b8457326f0cd79fbbc73a216e236c/" rel="bookmark">
			prt文件用什么软件打开(免费手机prt文件浏览器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		prt格式文件是一种CAD文件的一种格式，对于机械设计小伙伴来说并不陌生，然而让很多机械设计小伙伴烦恼的是，很多人并不知道prt文件怎么打开，prt文件用什么软件打开。今天小编就来为大家推荐一款手机prt文件浏览器，不仅不用下载任何软件，还能在手机端随时随地查看prt文件，让机械设计师能够轻量办公，快捷看图。
1.prt文件用什么软件打开？ 小编今天推荐的这款软件叫——追光几何。追光几何是一款免费手机prt文件浏览器，使用时不需要收费，也不需要下载任何软件，不占用手机内存，只需要关注【追光几何】微信公众号即可解决prt文件怎么打开这一难题。追光几何是一款管理包括prt文件在内的CAD文件版本的图纸管理神器，还具备强大的在线看图功能，小编今天来教很多机械设计小伙伴最关心的问题：prt文件怎么打开？接下来，以手机端追光几何的使用为例，教大家如何查看prt文件。
2.上传prt文件 在使用追光几何打开prt文件时，首先需要将想要查看的prt文件上传至追光几何公众号。进入追光几何这款手机prt文件浏览器页面后，点击页面下方【我的项目】，创建一个项目，然后就能将prt文件上传至项目内。prt文件上传后记得点击下面的【创建】按钮才能成功将上传至项目中哦。那么上传成功后，prt文件怎么打开呢？很简单！
3.一键查看prt文件 在prt文件上传成功后，就可以直接查看prt文件啦，那么怎么查看prt文件呢？只需要一步，点击该prt文件即可，进入prt文件模型页面后，还可以控制左下角视图全方位查看prt文件。
4.在线看图相关功能介绍 使用追光几何这款免费手机prt文件浏览器查看prt文件时，不仅容量轻，不占用使用者手机内存。虽然这款prt文件浏览器非常轻便，但是麻雀虽小五脏俱全，追光几何不仅支持在线查看prt等文件，同时为了能够给机械设计师提供更好的在线看图体验，还开发了多种功能，包括图纸测量、爆炸图、剖切面等各项看图工具，此外为了解决机械设计师之间图纸沟通的问题，追光几何还能够对图纸进行2D标注和3D标注，快速定位图纸问题所在。
5.在线看图API推荐 在这里小编为大家分享一个3D模型渲染API接口——分形三维，能够嵌入到网页、程序、应用中，实现3D模型渲染，为软件解决3D文件渲染以及3D模型测量的问题，分形三维覆盖了cad文件的多种格式，拥有比追光几何更加强大和专业的在线看图渲染功能。
自动测量参数输出、3D标注参数交互、自动生成缩略图输出等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7746997ce69b59e7e678ed8f58b55fd3/" rel="bookmark">
			HCL模拟器中Server设备启动失败的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 方法一方法二方法三 最近使用新版HCL 5.4.0模拟器中的Server设备遇到了设备无法启动的问题，因此自己摸索了一番，并最终解决了，下面就附上我的解决方法。
附注：5.4.0版本的HCl模拟器搭配的virtual box要是v6以下的，可以使用5.2.44及以下的，这也可以使得其可以和最高支持5.2.44版本virtual box的华为模拟器共存。
方法一 查看电脑BIOS的VT-x和AMD-V虚拟化有没有开启，如果没有开启自己自行百度进到BIOS设置中修改一下。
理论上执行第一个方法后基本就能启动成功，但是有的电脑可能还要执行方法二。
方法二 如果在开启BIOS中的CPU虚拟化后还是不能启动设备，那么需要在virtual Box中设置一下虚拟机（这也是我遇到的问题）
步骤如下：
1、进入虚拟机，点击topom-devicen，这个m和n代表着第m个拓扑的第n台设备，如下就是topo1的device1，如果在多台设备的情况下分不清server到底是哪台设备可以直接选左上角有64的虚拟机进行操作。
2、点击左上角的设置
3、依次点击系统&lt;硬件加速&lt;Hyper-V&lt;OK，然后退出
4、回到HCL启动设备
方法三 此方法是我在用最新版的v5.7.1 HCL碰到的问题，同样是提示启动失败错误
由于Server是作为Linux主机在virtual Box启动的，因此我又找到了该server对应的linux主机直接在virtual Box点击启动，毫无疑问也是启动失败，但是从报错信息中我发现了是主机的网络设置有问题，他提示创建网络（仅主机模式）失败。
既然创建失败，索性就直接不用网络，直接禁用，把启用网络连接前面的“√”去掉，再点击OK
启动成功！！！
ping自己的网卡能通，故禁用网络并不会对设备eth1网卡的通信造成影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d607487e4229360a053697113381cc/" rel="bookmark">
			EDTER: Edge Detection with Transformer—边缘检测，效果远超之前的研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EDTER: Edge Detection with Transformer（EDTER: 基于 Transformer 的边缘检测） 期刊合集：最近五年，包含顶刊，顶会，学报&gt;&gt;网址
文章来源：CVPR 2022
研究背景 卷积神经网络通过逐步探索上下文和语义特征，在边缘检测方面取得了重大进展，然而，局部细节随着感受野的扩大而逐渐被抑制。基于 Transformer 在 长期依赖关系 方面出色的表现，文章提出一种基于 Transformer 的边缘检测器，通过利用完整的图像上下文信息和详细的局部线索来提取清晰的物体边界和有意义的边缘。
EDTER 分两阶段进行：在阶段 I 中，使用 global transformer encoder 捕获粗粒度图像补丁上的远距离全局上下文；第 II 阶段， local transformer encoder 在细粒度补丁上工作，以挖掘近距离局部线索，每个 Transformer 编码器后面都有一个 双向多级聚合解码器，用于提高分辨率。最后，通过特征融合模块将全局上下文和局部线索结合起来，并输入决策头（head）进行边缘预测。
问题引入 边缘检测是计算机视觉中最基本的问题之一，具有广泛的应用，如图像分割，物体检测，视频物体分割。对于给定的输入图像，边缘检测的目的是提取精确的物体边界和视觉显著的边缘，但由于复杂的背景、不一致的注释等因素，它具有挑战性。
首先，考虑到计算量的问题，Transformer 通常应用于尺寸相对较大的 patch，而粗粒度的 patch 不利于学习边缘的精确特征，在不增加计算负担的情况下对细粒度补丁执行自我关注是至关重要的。其次，如图 (d) 所示，从相交的薄物体（有多个物体的情况）中提取精确的边缘是具有挑战性的，因此，有必要设计一个有效的 decoder 用于生成边缘感知的高分辨率特征的编码器。
论文分析 文章贡献如下：
1）提出了边缘检测变压器( EDTER )，用于检测自然图像中的物体轮廓和有意义的边缘。
2）EDTER 设计用于有效地探索远程全局上下文( 阶段 I )和捕获细粒度局部线索( 阶段 II )。
4）提出了一种新的双向多级聚合( BiMLA ) decoder 来促进 Transformer 中的信息流。
3）为了有效地整合全局信息和局部信息，使用特征融合模块( FFM )来融合从阶段 I 和阶段 II 提取的线索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d607487e4229360a053697113381cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cfba4ee34f31cc2b7d63df394e7097/" rel="bookmark">
			pnpm : 无法加载文件 C:\Users\admin\AppData\Roaming\npm\pnpm.ps1，因为在此系 统上禁止运行脚本。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pnpm run dev pnpm : 无法加载文件 C:\Users\admin\AppData\Roaming\npm\pnpm.ps1，因为在此系 统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?Link ID=135170 中的 about_Execution_Policies。 所在位置 行:1 字符: 1 + pnpm run dev + ~~~~ + CategoryInfo : SecurityError: (:) []，PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess PS C:\code&gt; set-ExecutionPolicy RemoteSigned PS C:\code&gt; PS C:\code&gt; pnpm run dev 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b6b0fbd575f54d09541aed80a0d3fa/" rel="bookmark">
			超简单纯css固定表头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
&lt;title&gt;table fix thead&lt;/title&gt;
&lt;style type="text/css"&gt;
.data-table {
margin-top: 58px;
margin-left: 350px;
width: 1520px;
height: 710px;
background: #FFFFFF;
border-radius: 8px;
border: 1px solid #DFDFDF;
border-spacing: 0px;
}
.data-thead {
height: 60px;
background: rgba(51,102,255,0.1);
border-radius: 8px 8px 0px 0px;
border: 1px solid #DFDFDF;
display: table;
table-layout: fixed;
}
.data-thead-td {
text-align: center;
width: 135px;
font-size: 20px;
font-family: PingFangSC-Medium, PingFang SC;
font-weight: 500;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62b6b0fbd575f54d09541aed80a0d3fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a064d79817bd19853151f906f93744/" rel="bookmark">
			Tensorflow 2 踩坑问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题 1】 TypeError: call() got an unexpected keyword argument 'use_causal_mask' 【源代码】
class CausalSelfAttention(tf.keras.layers.Layer): def __init__(self, **kwargs): super().__init__() self.mha = tf.keras.layers.MultiHeadAttention(**kwargs) self.add = tf.keras.layers.Add() self.layer_norm = tf.keras.layers.LayerNormalization() def call(self, x): attn_output = self.mha(query=x, value=x, key=x, use_causal_mask=True) x = self.add([x, attn_output]) x = self.layer_norm(x) return x 【解决办法】
参考： TypeError: call() got an unexpected keyword argument \'use_causal_mask\' ---&gt; 在 flickr8k/flickr30k 数据集上出现这个错误
我刚开始配置的环境是 Tensorflow-gpu 2.6.0，但 tf.keras.layers.MultiHeadAttention 的参数 use_causal_mask 是在 Tensorflow 2.10.0 版本中才引入的......遂安装 Tensorflow-gpu 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a064d79817bd19853151f906f93744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e688cf866a3e6b0562505a76233f49/" rel="bookmark">
			搭建一个双系统个人服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建一个双系统个人服务器 0.前言一、双系统安装1.磁盘划分2.windows安装3.ubuntu安装 二、系统启动项美化：1. refind引导2. 美化 grub 界面 三、系统代理 0.前言 年后找了份工作，忙于适应新环境所以更新也减缓了，最近闲暇时间给个人电脑进行了整理和修缮，改造出了一台私人服务器，便于后续的学习和工作。
一、双系统安装 配置方面就无所谓了，主要是上层的系统和环境需要搭建。首先是双系统安装，硬盘方面是一个 1T m.2 固态用于安装 windows，一个 470G 固态用于安装ubuntu。
1.磁盘划分 将 1T 固态分成 EFI + GPT 磁盘，EFI 大小 300M，用于存放windows 和 ubuntu 引导，GPT 磁盘用于存放 windows 系统的文件。
将 470G 固态分成 70G + 400G 的GPT磁盘，不需要EFI引导分区。
2.windows安装 这部分没什么好说的，直接 windows 官方安装工具，安装到 1T 固态中即可。由于安装 win11 后的使用过程遇到些不知名的bug，所以最后安装的 win10 系统。
3.ubuntu安装 这部分安装的时候，搜索了一下相关示例，感觉教程都挺杂乱，所以就小记一下。目前很多教程都分出好多分区，什么 boot、swap、home、根分区 / 等等，这里就稍微解释一下。
从ubuntu下载镜像，使用 rufus 制作安装盘，安装步骤一搜一大把，这里就不赘述了。然后关于分区，首先是根分区 /，这个分区类似于 windows 下的系统盘，通常一些 Linux 内核文件及系统工具等存放在此。这里我分了 70G，建议最低不低于 30G，否则后续安装 pytorch、cuda 等大型工具以后很容易就满了，磁盘充足也可以相应扩大。
/home目录，这部分就相当于用户个人磁盘，将它单独分出来的目的是后续如果想重装ubuntu系统，直接安装在 / 目录即可，用户文件不会丢失。这里我将剩余的400G全部分配。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88e688cf866a3e6b0562505a76233f49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb094f26dd41fc1082656eb6db521ed9/" rel="bookmark">
			前端基础学习-vscode模拟acm模式（js）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近笔试遇到ACM模式，这里记录一下如何用vscode模拟acm模式，这里基于JavaScript
1、JavaScript-node 基于node的模式
要用require(‘readline’)来引入输入的值
直接用console.log就可以输出
1.1 输入代码 以下面的代码为例子
// 计算a+b // 输入包括两个正整数a,b(1 &lt;= a, b &lt;= 1000),输入数据包括多组。 let readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.on('line', function(line) { let lines = line.split(' ').map(Number); console.log(lines[0] + lines[1]); }); 1.2 运行代码 进入文件所在文件夹，在终端输入命令
node xxx.js 1.3 键入输入 也可以看到对应的输出。但是有的代码需要一个个读入输入再处理。
1.4 结束 命令为 ctrl + d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ef5800d43b6e57d34373d276932a0d/" rel="bookmark">
			DBeaver 下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载地址(我下载的 Windows版本，根据系统需要选择版本)
Releases · dbeaver/dbeaver · GitHubFree universal database tool and SQL client. Contribute to dbeaver/dbeaver development by creating an account on GitHub.https://github.com/dbeaver/dbeaver/releases
​
或
Download | DBeaver Communityhttps://dbeaver.io/download/
下载后的压缩包：
dbeaver-ce-23.0.0-win32.win32.x86_64.zip
2 解压后得到 dbeaver 文件夹，直接双击运行 dbeaver.exe。
​
​启动界面：
​ 添加驱动：
​
以MySQL为例：
​ 点击下载/更新：
驱动位置：
​
其他：
脚本位置：(假如有重要的脚本可以到这拷出来)(lenovo为自己电脑用户名)
C:\Users\lenovo\AppData\Roaming\DBeaverData\workspace6\General\Scripts
驱动位置：(复制下载好的驱动到不联网机器，可以离线驱动)(lenovo为自己电脑用户名)
C:\Users\lenovo\AppData\Roaming\DBeaverData\drivers
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d32415b5a389f9b21542e552c59ee51/" rel="bookmark">
			STM32 SPI&#43;DMA驱动WS2812
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【举报再看养成习惯，噢 不对，点赞再看养成习惯。感谢支持】
开头不多叨叨，直接进入主题：
WS2812的驱动原理：
首先明白高低电平的表示方法：
低电平（0 code）： 0.35us的高电平+0.8us的低电平
高电平（1 code）：0.7us的高电平+0.6us的低电平
之前有一期使用PWM+DMA 使用Dshot协议驱动电调的文章，里面表示高低电平也是这种方式。
==================================================================
然后看一下数据包怎么发送到每个灯珠：D1、D2、D3、D4
1、红框左侧是第一包数据，我们先看D1拿到了一包3*24的数据，然后自己留下first 24bit。
然后将剩下的2*24bit传给D2，D2留下second 24bit，将最后24bit传给D3。D4没有数据可拿，就不会亮。
2、然后中间间隔&gt;=50us后，认为是第二包数据。
3、所以原理类似于：从第一排往后传卷子，一人留一张。【来自上学时的恐惧】
==========================分割线========================
所以我们就需要将每颗灯珠需要的24bit，按照它要求的高低电平的表示方式传输即可。如果你看过我之前写的Dshot驱动电调的文章，那么可以利用PWM+DMA组成数据包发送。今天我选择使用另一种方式：SPI+DMA模拟灯珠需要的信号。
首先解决SPI发送要求的高低电平的问题：
我们只需要让SPI_MOSI发送引脚输出一个0xE0，就可以模拟0 code。
发送0xF8模拟 1 code。
举个例子：如果要发送R:0x80 G:0x08 B:0x11. 即发送
1000 0000 0000 1000 0001 0001
用0xE0代替0、0xF8代替1，那么实际输出：（低位往后放、高位往前放）
0xE0 0xE0 0xE0 0xE0 0xE0 0xE0 0xE0 0xF8 0xE0 0xE0 0xE0 0xF8 0xE0 0xE0 0xE0 0xE0
0xF8 0xE0 0xE0 0xE0 0xF8 0xE0 0xE0 0xE0
============================================================
再来解决发送频率的问题：
从上面我们可以知道： 最短需要0.85us发出一个 0 Code（低电平）。最长可以1.45us
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d32415b5a389f9b21542e552c59ee51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2398cd6da93cb27c941e980e4fde119/" rel="bookmark">
			Direct IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基本介绍
二、使用方法与Demo
三、O_DIRECT 与 O_SYNC 四、Direct IO 与 缓存 IO 写性能 对比
一、基本介绍 如上图所示，普通的 IO 读写，会先将内容保存在缓冲区中，文件落盘需要调用 fflush 、fsync 等方法。
而 DirectIO 是无缓冲 IO，，使用无缓冲 IO 对文件进行读写，不会经过 OS Cache，数据直接落盘。
大多数使用场景中，使用缓冲区可以达到预读取、批量刷盘等目的，可以提高一部分性能。但对于一些应用场景，例如数据库，他们内部设计了一套自己的缓存机制，如果不使用 Direct IO 会存在双重缓存机制，影响性能。而且，数据库的缓存机制更适用于数据库本身。
二、使用方法与Demo 下面介绍如何使用 Direct IO
/* 打开文件并返回文件句柄。 flags 必须包含 O_RDONLY（只读）, O_WRONLY（只写）, O_RDWR（读写） 中的一种。 除此之外还有如下 flag： O_APPEND : 追加写入，但在 NFS 场景下如果多进程写入文件，会造成文件损毁（NFS不支持追加写入，内核必须模拟）。 O_ASYNC、O_CLOEXEC、O_CREAT、O_DIRECTORY、O_EXCL、O_LARGEFILE、O_NOATIME、O_NOCTTY、O_NOFOLLOW、O_NONBLOCK、O_NDELAY、O_PATH、O_TRUNC O_DIRECT : 绕过系统缓冲区直接读写磁盘文件，大多数情况下会降低性能，但对于应用自身携带缓存机制的情况下很有用。但需要注意，O_DIRECT 不等同于 O_SYNC。 O_SYNC : 同步 IO，write 操作在物理落盘之前会一直阻塞。 */ int open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); 在使用 Direct IO 编码过程中，读写的 buff 需要进行内存对齐，所以不能使用 malloc 进行内存随机分配，需要使用 memalign 、aligned_alloc、 valloc 等函数指定分配的内存起始地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2398cd6da93cb27c941e980e4fde119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4774790dff9e6beffa9c63addc094bc5/" rel="bookmark">
			小程序 wx.miniProgram.navigateTo 跳转地址不能是tabbar地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用wx.miniProgram.navigateTo从web-view里面的网页返回打开小程序的一个页面/pages/index/index时没有响应。
原因：微信小程序限定wx.miniProgram.navigateTo 跳转地址不能是tabbar地址 想跳到是tabbar地址的解决方案:
this.$wechat.miniProgram.switchTab({ url:"../home/index", //若tabbar地址是 /page/home/index success:function(res){ console.log('成功') } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/836071b7993de8928165bfdc30cf7873/" rel="bookmark">
			【Google浏览器】〖问题〗谷歌浏览器光标放在搜索框时显示为白色，导致无法看清
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 〖问题〗谷歌浏览器光标放在搜索框时显示为白色，导致无法看清 问题 解决 谷歌浏览器设置中，关闭使用硬件加速模式（如果可用）后重启：
我寻见一片海 碧蓝且耀着光 大片船只航行其上 都向着远方
Shared by Foriver_江河 © 1997-2020 江河 All Rights Reserved 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c075cc37d5fe1479384030c13499da8f/" rel="bookmark">
			2023 年最佳 C&#43;&#43; IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. Visual Studio2. Code::Blocks3. CLion4. Eclipse CDT（C/C++ 开发工具）5. CodeLite6. Apache NetBeans7. Qt Creator8. Dev C++9. C++ Builder10. Xcode11. GNAT Programming Studio12. Kite总结 前言 要跟踪极佳 IDE（集成开发环境）和类 IDE 工具的全部动态，对开发人员来说很难。
IDE 不再局限于典型文本编辑器，而是将编译、自动代码完成、语法高亮显示、调试、分析、测试以及更多功能整合在一个综合用户界面上。
如果没有 IDE，用户必须在开发工作流程中单独使用所有相关组件。虽然有些开发人员可能更喜欢这样，但 IDE 可以大大加快编程速度，并提供更佳的整体体验。
IDE 选择颇丰，因此关注最佳 C++ IDE 更能从中百里挑一。最后，我收集了一些令人信服的 IDE，并对每种进行了分析。
以下是我精选出的 2023 年最佳 C++ IDE。
1. Visual Studio 如果 JetBrains 的报告能够准确代表全体开发人员，那么微软的商业 IDE — Visual Studio，很可能便是 Windows 主流 C++IDE。
Visual Studio 成为主流选择，理由充分：这一成熟工具可跨平台使用，支持众多编程语言，并包含了一系列令人难以置信的功能。Visual Studio 的代码编译技术（名为 IntelliSense）广受赞誉，是许多开发人员每日不可或缺的开发工具。
IntelliSense 可提供优秀的语法高亮显示，易于使用的 UI 设计器，支持 CMake，并搭载功能强大的调试器和分析器系统。此外，它拥有大型社区，因此不乏经验、样本或更多相关内容的传授与分享贴。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c075cc37d5fe1479384030c13499da8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39873012759ac6d22b9988e3e9806313/" rel="bookmark">
			[mars3d - popup] 如何将mars3d的popup组件化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用中，popup的innerHtml似乎只能使用原生dom绑定事件的方式去触发事件，不方便啊；
那么其实我们可以封装成vue组件去使用，就可以按照vue开发的方式绑定事件
创建组件模块： 导入页面 应用模块： 最后就可以按照vue的方式去开发了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101c9107bd11d26d7fff49926e9c2f58/" rel="bookmark">
			python opencv imread()中文路径返回为空None的解决办法 （imdecode函数的使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本质原因并非网上某些地方说的是中文编码UNICODE、UTF-8之类的问题，其实是python版opencv不接受NON-ASCII的中文路径，为了使用中文路径，可以借助一些其他的库。本文首先介绍一种通过numpy库（毕竟这个是python中几乎最常用库之一了）的方法。
借助Numpy库 读取图像时，借助numpy库的fromfile函数先把图像文件以数据的方式读入内存，然后在内存缓冲区内用opencv提供的imdecode函数将该数据解码成图像数据，核心代码如下：
path = r"D:\Learn4Python\中文路径\中文文件名.jpg" dat = np.fromfile(path,dtype=np.uint8) img = cv2.imdecode(dat,cv2.IMREAD_UNCHANGED) 写入（保存）图像时，用opencv提供的imencode函数将图像数据编码成numpy的数据，然后借助numpy的tofile函数把数据写入到路径文件，核心代码如下：
path_zh_write = r"D:\Learn4Python\中文路径\中文文件名写入图像.jpg" out = cv2.imencode(".jpg",img) out[1].tofile(path_zh_write) 为了方便学习和完整理解，写了一段实验代码供大家参考，完整代码如下：
import cv2 import numpy as np #试验四种情况：路径无中文、仅文件名中文、目录和文件名均有中文、仅目录有中文 path1 = r"D:\Learn4Python\EnglishFileName.jpg" path2 = r"D:\Learn4Python\中文文件名.jpg" path3 = r"D:\Learn4Python\中文路径\中文文件名.jpg" path4 = r"D:\Learn4Python\中文路径\EnglishFileName.jpg" path_zh_write = r"D:\Learn4Python\中文路径\中文文件名写入图像.jpg" path_en_write = r"D:\Learn4Python\EnglishFileName_writeImg.jpg" img1 = cv2.imread(r"D:\Learn4Python\EnglishFileName.jpg") img2 = cv2.imread(r"D:\Learn4Python\中文文件名.jpg") img3 = cv2.imread(r"D:\Learn4Python\中文路径\中文文件名.jpg") img4 = cv2.imread(r"D:\Learn4Python\中文路径\EnglishFileName.jpg") #检查读取情况，结果只有路径无中文的情况读取成功 if img1 is None: print("img1 imread failed.") else: print("img1 imread ok:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101c9107bd11d26d7fff49926e9c2f58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f87ffaf089807a5cb310ba770d072e4/" rel="bookmark">
			RN使用第三方库实现选择照片或打开摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：新版本可能会报错
使用5.0.0版本
2：检查和询问用户是否授予权限
给这个文件增加uses-permission的这三行
3：申请权限的代码，注意区别android的版本
import { View, Text, StyleSheet, StatusBar, Image, Alert, TextInput, Modal, Platform, PermissionsAndroid } from 'react-native'; // .................................... async function requestCameraPermission() { if (Platform.Version &gt;= 31) { // 如果运行的是 Android 12 或更高版本，选用新模型来请求相机权限 // const result = await requestPermissionAndroid12('android.permission.CAMERA'); // 请求本地存储权限 const result = await requestPermissionAndroid12('android.permission.READ_EXTERNAL_STORAGE') if (result === PermissionsAndroid.RESULTS.GRANTED) { console.log("加载权限") // launchCamera(options, (res)=&gt;{ // console.log("res",res) // }); // 申请到权限之后打开图库 launchImageLibrary(options, ({assets})=&gt;{ console.log("res",assets) if(assets &amp;&amp; assets[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f87ffaf089807a5cb310ba770d072e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b39a514cc78964f8d4975e620bda831/" rel="bookmark">
			React（三）：脚手架、组件化、生命周期、父子组件通信、插槽、Context
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React（三） 一、脚手架安装和创建1.安装脚手架2.创建脚手架3.看看脚手架目录4.运行脚手架 二、脚手架下从0开始写代码三、组件化1.类组件2.函数组件 四、React的生命周期1.认识生命周期2.图解生命周期（1）Constructor（2）componentDidMount（3）componentDidUpdate（4）componentWillUnmount 3.演示生命周期4.不常用的生命周期 五、父子组件通信1.父传子props接收2.props接收数据类型限制和默认值3.子传父用函数4.案例练习 六、React插槽效果1.通过props.children传递2.通过props直接传递3.作用域插槽 七、祖孙及更深层次的通信1.{...props}解构2.Context的使用（类组件）3.Context的使用（函数组件） 一、脚手架安装和创建 首先安装Node：保姆级别教程
1.安装脚手架 在git bash中输入： npm install create-react-app -g，然后输入create-react-app --version，如果能正常显示版本号，那么安装就成功了。
2.创建脚手架 目录下右键 =&gt; git bash =&gt; create-react-app 项目名 =&gt; 回车等几分钟就欧了。
注意项目名不能包含大写字母。
3.看看脚手架目录 4.运行脚手架 脚手架目录下 =&gt; npm run start，然后就可以看到非常帅气的大花。
二、脚手架下从0开始写代码 没啥用的先删了，我们自己搭建src中的文件：
好，那么接下来我们重新写一下src里面的文件：
index.js //重写react代码，并且通过react渲染出来对应的内容 import ReactDOM from 'react-dom/client'; import App from './App'; const root = ReactDOM.createRoot(document.querySelector('#root')); root.render(&lt;App/&gt;); App.jsx import React from 'react'; import HelloReact from './Components/HelloReact'; class App extends React.Component { constructor() { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b39a514cc78964f8d4975e620bda831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc684a2f7816f12b691e9104f0d073f0/" rel="bookmark">
			geometric源码阅读和分析：MessagePassin类详解和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面所有博客是个人对EEG脑电的探索，项目代码是早期版本不完整，需要完整项目代码和资料请私聊。
数据集
1、脑电项目探索和实现(EEG) (上)：研究数据集选取和介绍SEED
相关论文阅读分析：
1、EEG-SEED数据集作者的—基线论文阅读和分析
2、图神经网络EEG论文阅读和分析：《EEG-Based Emotion Recognition Using Regularized Graph Neural Networks》
3、EEG-GNN论文阅读和分析：《EEG Emotion Recognition Using Dynamical Graph Convolutional Neural Networks》
4、论文阅读和分析:Masked Label Prediction: Unified Message Passing Model for Semi-Supervised Classification
5、论文阅读和分析：《DeepGCNs: Can GCNs Go as Deep as CNNs?》
6、论文阅读和分析： “How Attentive are Graph Attention Networks?”
7、论文阅读和分析：Simplifying Graph Convolutional Networks
8、论文阅读和分析：LightGCN: Simplifying and Powering Graph Convolution Network for Recommendation
相关实验和代码实现：
1、用于图神经网络的脑电数据处理实现_图神经网络 脑电
2、使用GCN训练和测试EEG的公开SEED数据集
3、使用GAT训练和测试EEG公开的SEED数据集
4、使用SGC训练和测试SEED数据集
5、使用Transformer训练和测试EEG的公开SEED数据集_eeg transformer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc684a2f7816f12b691e9104f0d073f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9e4de3b287b65a2649bbb7617d0a3e/" rel="bookmark">
			Graph 聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面所有博客是个人对EEG脑电的探索，项目代码是早期版本不完整，需要完整项目代码和资料请私聊。
数据集
1、脑电项目探索和实现(EEG) (上)：研究数据集选取和介绍SEED
相关论文阅读分析：
1、EEG-SEED数据集作者的—基线论文阅读和分析
2、图神经网络EEG论文阅读和分析：《EEG-Based Emotion Recognition Using Regularized Graph Neural Networks》
3、EEG-GNN论文阅读和分析：《EEG Emotion Recognition Using Dynamical Graph Convolutional Neural Networks》
4、论文阅读和分析:Masked Label Prediction: Unified Message Passing Model for Semi-Supervised Classification
5、论文阅读和分析：《DeepGCNs: Can GCNs Go as Deep as CNNs?》
6、论文阅读和分析： “How Attentive are Graph Attention Networks?”
7、论文阅读和分析：Simplifying Graph Convolutional Networks
8、论文阅读和分析：LightGCN: Simplifying and Powering Graph Convolution Network for Recommendation
相关实验和代码实现：
1、用于图神经网络的脑电数据处理实现_图神经网络 脑电
2、使用GCN训练和测试EEG的公开SEED数据集
3、使用GAT训练和测试EEG公开的SEED数据集
4、使用SGC训练和测试SEED数据集
5、使用Transformer训练和测试EEG的公开SEED数据集_eeg transformer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9e4de3b287b65a2649bbb7617d0a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a710a3d1f75b44aaabf193ece85566c6/" rel="bookmark">
			ROS kinetic实现二维码识别与物体跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文进行二维码识别使用的摄像头为笔记本自带摄像头。
1.更改虚拟机配置
（1）虚拟机设置&gt;USB控制器
显示所有的USB设备处勾选时要关闭ubuntu。
（2）接下来在虚拟机的设备中就可以看到摄像头设备Camera，选择“连接”。
2. 安装必要的包
（1）安装摄像头驱动和图像显示包
sudo apt-get install ros-kinetic-usb-cam sudo apt-get install ros-kinetic-uvc-camera sudo apt-get install ros-kinetic-image-view 接下来运行launch文件就可以看到能够调用摄像头。
roslaunch usb_cam usb_cam-test.launch （2）安装二维码识别包
sudo apt-get install ros-kinetic-ar-track-alvar 然后还需要上gitee上下载一个robot_vision的包。这个包下载后的名称为robot_vision-master，（括号内步骤可省略，重命名为robot_vision。如果没有进行重命名，后续二维码识别的launch命令的功能包的名字就为robot_vision-master。）链接https://gitee.com/baseyao/robot_vision
将解压后的robot_vision包放到自己的工作空间下的代码空间下，如：catkin_ws/src。再进行编译。
3.创建二维码
使用下面命令创建两个二维码：二维码中分别包含数字0和1。创建的二维码图片会保存在终端的目录下。
rosrun ar_track_alvar createMarker -s 5 0 rosrun ar_track_alvar createMarker -s 5 1 然后将二维码图片打印出来。
（4）二维码识别
如果2（2）的重命名没有做，下面的功能包的名字就为robot_vision-master。
roslaunch robot_vision usb_cam_with_calibration.launch roslaunch robot_vision ar_track_camera.launch 运行rostopic echo命令，查看识别到的二维码信息：
rostopic echo ar_pose_marker （5）物体跟踪
再次打开新终端运行：
roslaunch robot_vision motion_detector.launch 然后打开rqt。
rqt_image_view 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2caa8dd55ca3a3c0e7b8c44bc6b9c2c3/" rel="bookmark">
			混合式App 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动端 分三类：
一、原生app: andriod(java) / ios(object-c) 开发的移动运用，性能好，很好的调用手机相机、日历等硬件功能 ----native App
二、web App：HTML5+js+css 不能调用相机、日历等硬件功能 ---web App
三、混合式App : web 页面嵌套在 原生容器webView一种方式，性能低于原生，能调用原生的相机和日历等原生相关功能
几种Hybrid App框架：Cordova 、 Phonegap （Cordova 商用版本）、 Ionic 、 // flutter 、react-native(RN)
开发准备：
1、IDE编辑器：vscode 或 webstorm
2、 Nodejs LTS 版本
3、一部ios手机或者Android手机
4、mac上需下载Xcode,windows上需下载Andriod Studio
5、发布：需要开发者身份（AppStore ；Android各大应用商店不一样）
混合式App 工作原理：
混合式App（Hybrid App）的工作原理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf01839434514c229c22e363389e493e/" rel="bookmark">
			通过js 获取最近3天、1周、1个月、3个月、半年、1年的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过js 获取最近3天、1周、1个月、3个月、半年、1年的时间 下载 npm i moment --save
引入 import moment from ‘moment’;
mounted this.init();
methods init() { // 近3天 this.getRecentDay(3); this.getRecentDay_Date(-3); //近一周 this.getRecentDay(7); this.getRecentDay_Date(-7); // 近一个月 this.getRecentMonth(1); this.getRecentMonth_Date(1); // 近三个月 this.getRecentMonth(3); this.getRecentMonth_Date(3); // 近半年 this.getRecentMonth(6); this.getRecentMonth_Date(6); // 近一年 this.getRecentMonth(12); this.getRecentMonth_Date(12); }, // 近N天 -Moment.js getRecentDay: function(n) { let day = moment(new Date()) .subtract(n, "days") .format("YYYY-MM-DD"); console.log(day); return day; }, // 近N月 - Moment.js getRecentMonth: function(n) { let month = moment(new Date()) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf01839434514c229c22e363389e493e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343291eaf1e1a3c34332a6c2796b032d/" rel="bookmark">
			python csv读取方法及常用的csv读取代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		csv文件是一种压缩文件格式，在网络上被广泛使用。csv文件在处理时会被转换成二进制文件，其中包含数据、文本和图像等。下面就是我们使用 python读取 csv文件的过程。 我们在进行 csv文件读取的时候，一般会有几种方法： 1、直接打开文件，然后通过 Python自带的第三方库 csvba进行读取； 2、将压缩后的数据进行解压，解压之后使用 python读取； 3、在 python中使用第三方库 csvba进行解压，然后使用 python读取。 以上三种方法都是在已有的压缩包内解压，对压缩包进行读取。
一、直接打开文件
在这种情况下，我们需要先打开 csv文件，然后再对它进行解压。 由于我们的目的是打开文件，因此在打开文件之前需要先对文件进行封装。在 Python中有两个常用的封装方法，分别是 seconds和 password。 seconds是一个文件的名称，而 password则是一个文件的密码。使用 python自带的第三方库 csvba对文件进行封装，使用下面的代码就可以很容易地打开一个 csv文件： 在输出结果中可以看到我们有两个结果： 其中一个结果是用来打开这个文件，另一个结果则是用来保存这个文件。我们在获取到这个结果之后，可以使用 python中的第三方库 csvba将其保存起来。 csvba能够对压缩包进行解压，因此它可以将压缩包内的所有文件解压出来。下面就来看看 csvba是如何做到这一点的： 我们可以看到，通过 csvba解压后，会得到一个压缩包的目录结构： 我们可以对这个目录结构进行修改来获取文件内的数据。这里使用了两个方法： 第一种方法是利用 pip命令来获取当前目录下所有文件的路径，并使用这个路径中的任意一个文件来进行解压。注意这里不能将文件本身也解压出来，而是要先对其进行解压缩。使用 pip命令能够获取到 csv文件的所有目录，然后可以通过上述步骤对其进行解压。 这里使用了一个简单的 python函数：
二、解压
使用第三方库 csvba进行解压，这个方法是最简单的方法，不过要注意解压的时候需要选择解压路径。 具体方法是：在 python中输入“csvba”，然后输入要解压的文件名称。最后回车，就会得到一个压缩包。 解压后的 csv文件包含了很多信息，包含了图片、文本和二进制文件。不过在 python中打开压缩包后，会看到一个黑色的文本框，表示该文件已经被解压。如果不想看到这个黑色文本框，可以用“csvba-&gt; print”命令来进行解压。 这个方法同样也有缺陷，就是解压的时候需要选择解压路径。python中有很多第三方库，在这些第三方库中还有专门的解压函数和解压脚本。我们只需要进行选择即可。 这里我们选择使用 python中的 csvba来进行解压，这个库可以将 csv文件解压缩包。但是需要注意的是，我们在使用第三方库进行解压的时候，要先选择解压包才行。 在 python中也有专门的解压包函数 csvba-&gt; extends settings （）来对解压包进行解压。这里我们先使用它来解压缩 csv文件。 如果我们想要将压缩包中的所有文件都解压成一个压缩包，我们可以使用 python中的 pycharm函数来进行解压。 这里我们首先使用 pycharm-&gt; rar来对 csv文件进行解压包选择，然后再使用 pycharm-&gt; extends settings （）来对解压包名进行切换。最后直接在 python中编写代码就行了。 注意在最后解压的时候不要用到命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/343291eaf1e1a3c34332a6c2796b032d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23035660353984d031b4d643d414e564/" rel="bookmark">
			Elasticsearch 索引备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快照备份 快照是增量的：索引的每个快照只存储不属于早期快照的数据。这使您能够以最少的开销拍摄频繁的快照
配置仓库地址 创建文件夹用作Elasticsearch备份仓库：
mkdir /usr/local/backup 赋权限
chmod 777 /usr/local/backup 在elasticsearch.yml文件中增加path.repo路径配置：
vim /usr/local/elasticsearch/config/elasticsearch.yml #加上这个配置 path.repo: ["/usr/local/backup"] 重启elasticsearch
创建仓库 PUT _snapshot/my_backup { "type": "fs", "settings": { "location": "/mount/backups/my_backup", "max_snapshot_bytes_per_sec" : "50mb",	"max_restore_bytes_per_sec" : "50mb"	} } my_backup：仓库名称
type：指定仓库的类型是一个共享文件系统
localhost：指定已挂载的设备作为仓库地址
max_snapshot_bytes_per_sec：当快照数据进入仓库时，这个参数控制这个过程的限流情况。默认每秒 20mb
max_restore_bytes_per_sec：当从仓库恢复数据时，这个参数控制什么时候恢复过程会被限流以保障你的网络不会被占满。默认每秒 20mb。
快照所有打开的索引 PUT _snapshot/my_backup/snapshot_1 快照所有打开的索引到my_backup仓库中，快照的名称为snapshot_1，这个调用会立刻返回，然后快照会在后台运行
PUT _snapshot/my_backup/snapshot_1?wait_for_completion=true 这个会阻塞调用直到快照完成。注意大型快照会花很长时间才返回
快照指定索引 PUT _snapshot/my_backup/snapshot_2 { "indices": "index_1,index_2" } 这个快照命令只会备份索引名称为index1 和 index2 了
查询快照信息 GET _snapshot/my_backup/snapshot_2 返回my_backup仓库下snapshot_2索引的详细信息
GET _snapshot/my_backup/_all 要获取一个仓库中所有快照的完整列表，使用 _all 占位符替换掉具体的快照名称：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23035660353984d031b4d643d414e564/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/92/">«</a>
	<span class="pagination__item pagination__item--current">93/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/94/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>