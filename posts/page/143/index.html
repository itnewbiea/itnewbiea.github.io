<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95deb40e05ef1d808893ed2c6b4bee27/" rel="bookmark">
			ROS环境下采用PCL点云库对PCD格式点云进行滤波、旋转和平移等处理，并用RVIZ实时显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境配置
操作系统: Ubuntu 18.04
ROS版本: ROS Melodic Morenia
说明: 我仅仅在上述环境下进行了验证调试，其它版本应该也是可以用的。
二、安装教程
1. 安装好ubuntu系统和ROS环境
2. 打开终端，并在终端命令行输入以下指令:
3. git clone https://gitee.com/wccworld/read_pcd.git
4. cd read_pcd/catkin_ws
5. catkin_make
6. source devel/setup.bash
7. roslaunch read_pcd read_pcd.launch
三、核心代码
1. 读取.pcd格式点云文件，并转化为ROS可发布点云格式PointCloud2
/********************************PCD点云获取**********************************************/ pcl::PointCloud&lt;PointType&gt;::Ptr pcd_cloud_in (new pcl::PointCloud&lt;PointType&gt;); if (pcl::io::loadPCDFile&lt;PointType&gt; (pcd_doc_path, *pcd_cloud_in) == -1) { PCL_ERROR ("Couldn't read file: %s \n", pcd_doc_path.c_str()); return (-1); } sensor_msgs::PointCloud2 input_cloud; pcl::toROSMsg(*pcd_cloud_in,input_cloud); input_cloud.header.frame_id = output_frame_id; // read_pcd_pub.publish(input_cloud); /****************************************************************************************/ 2. 直通滤波器对X轴进行滤波（ PCL点云滤波的主要内容、原理和详细使用说明可参考此篇文章 https://zhuanlan.zhihu.com/p/102748557 ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95deb40e05ef1d808893ed2c6b4bee27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44603e7166dbfad3894017e39a4f8721/" rel="bookmark">
			接口测试之Postman使用全指南(原来使用 Postman测试API接口如此简单)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件
一、Postman背景介绍 用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。今天给大家介绍的这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。
二、Postman的操作环境 postman适用于不同的操作系统，Postman Mac、Windows X32、Windows X64、Linux系统，还支持postman 浏览器扩展程序、postman chrome应用程序等。
三、Postman重要提示： 由于2018年初chrome停止对chrome应用程序的支持，你的postman插件可能无法正常使用了。目前chrome应用商店能使用的就是chrome扩展程序和主题背景。
四、什么是接口测试 接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。
由于如今的系统复杂度不断上升，传统的测试方法成本急剧增加且测试效率大幅下降，所以就要做接口测试。同时，接口测试相对容易实现自动化持续集成，且相对UI自动化也比较稳定，可以减少人工回归测试人力成本与时间，缩短测试周期，支持后端快速发版需求。接口持续集成是为什么能低成本高收益的根源。现在很多系统前后端架构是分离的，从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。
五、接口测试工具 postman+newman+jenkins+git/svn
jmeter+ant+jenkins+git/svn
postman简介：
postman一个款功能强大的接口测试工具。专为接口而生。
安装：
两个版本：
Postman Chome app(chorme浏览器，翻墙) 不推荐
Postman native app 客户端的安装方式：
下载地址： https://www.getpostman.com/apps
注册，登录。只有登录后才可以使用Postman的云服务的功能。
六、接口测试流程 1.拿到接口文档。（抓包：F12，fiddler，charles）,熟悉接口业务，接口地址，请求参数，请求头信息，请求方式，鉴权方式。
2.编写接口用例编写以及评审。
3.使用接口测试工具执行接口测试。
4.输出接口测试报告。
七、接口测试执行 鉴权码：鉴权你是否有访问此接口的权限的一个字符串码。
获取鉴权码的方式：
1.有一个专门的获取token鉴权码的接口。
2.登录之后自动生成token鉴权码。
get请求以?方式传参，多个参数之间用@分隔。
请求的功能页签：
Params：get请求传参 Authorization：是验证是否拥有从服务器访问所需数据的权限。
Headers：请求头。
Body：（post请求传参）
1.form-data：表单：键值对，还有文件上传。
2.x-www-form-urlenconded 表单：键值对。
3.raw:传各种其他类型的参数，比如：Text,Javascript,json，html，xml
4.binary：用于上传二进制文件。
pre-erquest script:接口请求之前的js脚本。
Tests:接口请求之后的断言（断言接口是否请求成功）
Settings：对请求的设置。
-------------
Cookie：是Postman用于自动管理iCookie关联。
响应的功能页签：
Body:响应内容。
Pretty:json格式，raw:文本格式，proview:网页格式。
Cookie:响应的Cookie信息。
Headers:响应头
TestResults：断言结果
响应状态码：200
响应信息：OK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44603e7166dbfad3894017e39a4f8721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/defb4ff0072770f77b2db8d6bc711006/" rel="bookmark">
			招商银行2022FinTech数据赛道总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		招商银行2022FinTech数据赛道总结 比赛链接：FinTech精英训练营官方网站。
第一次参加这种比赛，真的学到了不少东西，感谢其他大佬在交流群里的无私分享，小白又了解到了很多可以学习的东西。这次比赛排名还是很拉的，A榜只有0.952，B榜只有0.723，综合排名应该到了快400名吧。但不管怎么说，既然参加了这次比赛，还学习了很多东西，还是值得好好整理一下的。
文章目录 招商银行2022FinTech数据赛道总结1. 比赛简介2. 可提高的地方（1）探索性分析（2）数据预处理数据类型转换缺失值处理异常值处理数据规范化重采样 （3）特征工程特征过滤特征交叉特征选择 1. 比赛简介 数据是结构化的表格数据，一共49个属性（不含ID和标签），但没有具体的属性介绍，标签是二分类。
竞赛时间：4月29日9:00-5月12日17:00；
竞赛流程：4月29日9:00-5月9日24:00，赛题开放A榜数据（test_A榜），预测结果数据每天限提交3次；5月10日00:00-5月12日17:00，赛题开放B榜数据（test_B榜），预测结果数据每天限提交3次。重复提交或提交格式错误均扣除有效提交次数，请谨慎提交答案，结果提交后请务必点击“运行”按钮，方可查看当前个人排名。
排行榜依据“最终得分”计算排名，“最终得分”计算公式为：A榜最高分 * 0.3 + B榜最高分 * 0.7。“最终得分”越大，成绩排名越前。
注：AUC这个指标和准确率不一样，它受到样本不均衡的影响很小，对正负比例不敏感，因此。只要是AUC做评价指标的，基本都不需要考虑正负样本比例的问题。
2. 可提高的地方 每一列的含义可以参考往年的资料进行分析→招商银行2020FinTech精英训练营数据赛道参赛回顾。
（1）探索性分析 之前都是使用pandas-profiling，这次数据出问题就跳过了EDA的步骤，但赛后换了一个eda的包之后就能用了。所以也先mark在这：
通用：pandas-profiling、SweetViz；Notebook上：LUX、AutoViz。 EDA可以分析的内容：
样本数量、数据字段的异常值、缺失值；数据（含标签）字段的类型及其分布、字段和标签的分布关系；字段之间的相关性分析；有时间特征的可以按不同时间窗口划分观察；训练集和测试集的分布差异。 （2）数据预处理 数据类型转换 数值型变量：转为float
有序型分类变量：使用LabelEncoder()编码；
无序型分类变量：使用独热编码。
缺失值处理 将“？”字段统一替换为Nan缺失值；
可以考虑将所有数值特征统一减2，“2”应该是出题方为了脱敏进行的变换，个人之前没有减是觉得“2”已经代表了一种属性，没必要调整，但未来遇到这样的情况获取可以考虑进行类似的变换。
填充方法：
删除：当缺失值的个数只占整体很小一部分的时候，可直接删除缺失值（行）
填补：
前填充/后填充：method=‘ffill’—前填充；method=‘bfill’–后填充；
均值、中位数、众数填充：fillna(df[‘XX’].mean()) # .mean()或.median()或.mode()
插值法：计算的是缺失值前一个值和后一个值的平均数：df[‘XX’] = df[‘XX’].interpolate()；
拟合：
回归填补：利用线性回归对缺失值进行填补；随机森林填充：对于一个有n个特征的数据来说，其中特征T有缺失，我们就将特征T当作标签，其他n-1个特征和原来的标签组成新的特征矩阵。对于特征T来说，他没有缺失的部分就是我们的y_train，这部分对应的标签就是X_train，缺失部分就是我们需要预测的部分，也即是y_predict，这部分对应的标签就是X_test，对于数据中有多个特征缺失的情况，需要从缺失值最少的特征开始填补（填补缺失值越少的特征需要的准确信息越少）。当填补一个特征时，将其他特征的缺失值用0代替，依次填补直到所有特征填补完全。 此外，还可以考虑用随机森林进行填充。
异常值处理 采用3σ原则或者孤立森林方法进行异常值检测。
处理：可以考虑将过大、过小的值都限定到一个上限和下限。
数据规范化 可选：最大-最小归一化、标准化、中心化，其中min-max不改变数据分布，标准化改变数据分布（具体看所选取的算法要求）；
重采样 过采样/欠采样：目的是为了平衡类别。
目前没有实践，有看到采用imblearn库来做的。eg：from imblearn.over_sampling import RandomOverSampler
（3）特征工程 特征过滤 基础：去除共线性：将相互之间热力值高（相关性高于0.9）的特征列去掉，仅保留一列（根据结果决定）；
过滤法：方差过滤法+卡方检验法/F检验法/互信息法；
特征过滤主要是对冗余特征进行处理，常见处理方法有方差法、卡方检验法、F检验法、装代法、包裹法等，其中常用的组合为方差过滤法和F检验法，卡尔检验法常用来处理线性关系，F检验法即可以用来线性关系，还可以用来处理非线性关系。
找“毒特”（删除训练集与测试集分布不一致的特征）：
通过对抗验证的思路找到auc指标远大于0.5的特征进行删除；删除其他和“毒特”相关性较高的特征。 特征交叉 对于任何两列相关系数在指定范围（0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/defb4ff0072770f77b2db8d6bc711006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34e016832242e9d83d12c15e51bba97/" rel="bookmark">
			C#:Nullable object must have a value.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.错误
2.原因
分页查询时用了下面的EF.functions.like匹配,改为用contains
3.深究
没有做到,仅仅做到绕过去了
4.总结
还是属于初学者,做不到就绕过去,不丢人
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdee7394af966467c900021c6e60bbc0/" rel="bookmark">
			python在C&#43;&#43;工程中的嵌入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为题主本身是做视频编码方向的，所以需要运用到视频编码和机器学习等方面的内容。因此，就对这一方面进行了学习和总结归纳。
众所周知，对于大型的工程文件，不是C++就是java，而视频编码的标准测试软件平台就是以C语言为基础进行编写的。因此要想对视频编码有所研究的话，就必须对C语言有所了解。同时，另一方面，对于绝大多数计算机相关方向的研究生或者老师来说，机器学习、深度学习、强化学习、神经网络都是或轻或重的工具，而python作为神经网络的首选语言，我们也需要多加了解才行。
言归正传，我就简单描述一下python在C++工程项目中的嵌入，首先放置嵌入成功后的界面：
这就是嵌入成功后的主体表现，就和python一样，导入了一个库，然后按照规则使用即可，如果图中的函数不适用于你的使用情况，那就点击跳转到源代码处寻找自己想要的函数即可。
下面则是配置的具体情况，以VS2017作为示例：
1、找到你的项目文件，右键鼠标，打开属性这一界面。
2、点击左侧的V/C++目录，进行嵌入的配置。
点击包含目录，新增，然后将&lt;python安装目录&gt;+'\include'复制进去即可；
点击库目录，新增，将&lt;python安装目录&gt;+'\libs'复制进去即可。
基于以上操作，就可以实现python在C++工程中的应用了。
注意点：
1、你使用到哪一个项目就必须对哪一个项目进行配置，在大型工程文件中，不同项目文件有时候会跳转，需要注意。
2、在配置好后，可能会出现debug模式下的错误，那就需要将前面库目录里文件名为python38.lib（根据版本不同可能有所不同）复制并重命名为python_d.lib即可。
3、在导入模块时，有的时候会报内存占用的错误，可能是由于python文件本身存在错误，比如py文件导入了不存在的库，语法错误等等，需要检查你导入的模块能否正常运行（如果电脑里存在两种不同版本的python，要配置安装了对应库的python路径，否则会造成py文件能正常执行，但依旧报内存占用的问题）。
ps：在很多情况下，单单导入了python是不足以使用的，常见的还有opencv和numpy，配置方法和上面相同，就是配置的地方有所区别。
4、
Py_Initialize();//使用python之前，要调用Py_Initialize();这个函数进行初始化
Py_Finalize();//调用Py_Finalize，这个和Py_Initialize相对应。
这两个代码在整个过程中只需要各运行一次，请把它们放在程序的开始和结束处，不要重复调 Opencv：
配置包含目录： &lt;安装路径&gt;\opencv3\build\include
配置库目录： &lt;安装路径&gt;\opencv3\build\x64\vc15\lib
配置链接器输入：opencv_world341.lib（341为对应版本号）
Numpy：
配置附加包含目录：
&lt;安装路径&gt;\Python36\Lib\site-packages\numpy\core\include
numpy的配置注意点：
需要修改&lt;安装路径&gt;\python36\include\pyconfig.h，要不然会在Debug模式下报错。
将：
修改为
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f097e772e5db2e5997b3437fbb31381b/" rel="bookmark">
			超详细VWware安装cenOS7教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开VMware选择创建新的虚拟机
2.选择自定义安装然后下一步
3.选择虚拟机硬件兼容性（直接下一步）
4.选择Linux镜像文件
5.设置账号和密码
6.设置虚拟机名称以及虚拟机文件存储位置
7.虚拟机处理器配置（推荐都使用2）
8.设置虚拟机运行内存（推荐使用2GB）
10.设置虚拟机网络类型（推荐使用NET模式）
10.虚拟机I/O控制器类型（使用默认即可）
11.选择虚拟机磁盘类型（默认即可，如有其他需求可选其他）
12.创建虚拟磁盘
13.指定磁盘大小
14.指定虚拟磁盘的存放地址
15.完成虚拟机创建（如有其他需求，可选择自定义硬件）
16.创建完成后开启虚拟机
17.修改虚拟机语言
将中文添加到系统语言
18.修改虚拟机输入法，将中文输入法添加进系统输入法中
19.开始安装
20.创建登录账号
注：密码过短需要连点两次Done.
等待系统安装完成
21.设置虚拟机界面（默认即可）
22.使用刚才创建的账号登录
23.设置系统语言
选择汉语
设置完成后进行重新启动
24.重新启动后登录，选择更新名称
25.安装完成
注：按照此方法安装虚拟机的超级管理员root用户的密码为root
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef7f161dfa90cb166526b351624b159/" rel="bookmark">
			推荐系统基本流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## 推荐系统基本流程​
图1 最简单的推荐系统流程 ​ 主要元素
物品集合： 要推荐的物品或内容
用户： 用户的基本信息、用户的行为、用户的兴趣爱好等
场景： 用户所处的环境，例如：网络环境、什么时间正在做什么等
搜索引擎：根据用户对物品或者信息的偏好（包括用户对物品的评分、用户查看物品的记录、用户的购买记录等）与用户的画像数据进行拟合，学习得到什么样的用户会喜欢什么样的物品这样一个模型
推荐结果集： 是一个推荐结果或者一个推荐结果排序集合
主要模块
召回模块： 根据用户和场景特征，从物品列表（上百万个物品）中挑选用户可能感兴趣的物品，通过多种召回方法进行组合召回，最终得到用户的候选物品集（几百或者上千个物品）
排序模块： 针对召回模块的候选物品集进行精排，根据用户的所有标签特征、物品的特征以及交叉组合特征，通过排序模型计算，得到用户对候选物品集的评分。排序模块使用的特征比召回模块复杂，目的是计算用户精确的预测值。
后排模块：后排也就是后置排序，在得到用户对候选物品集的评分结果后，如果不进行后排，将会按照评分从高到低下发给用户进行展示。通常这里需要对排序列表进行调整，比如运营干预、优先级调权、指定下发规则等。
常用算法
召回模型的常见算法
推荐系统的排序算法，就是根据用户和物品的所有标签特征，通过排序模型计算，得到用户对候选物品集的评分。其中，在排序模块中使用的特征比召回模块中的复杂，目的是计算用户精确的预测值。
​ ​ 排序模型的常见算法
推荐系统的排序算法，就是根据用户和物品的所有标签特征，通过排序模型计算，得到用户对候选物品集的评分。其中，在排序模块中使用的特征比召回模块中的复杂，目的是计算用户精确的预测值。
​ ​ ​ ​ 参考文献
《推荐算法实战》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a875c39d583c519ce08c6174803f4a10/" rel="bookmark">
			dataloader卡住
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pin_memory - 知乎
dataloader卡住！！！_只会git clone的程序员的博客-CSDN博客_dataloader 卡死
PyTorch 训练时中遇到的卡住停住等问题_yyywxk的博客-CSDN博客_pytorch卡住
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69803287205b87995e8f69909d447b03/" rel="bookmark">
			超分算法ESRT：Transformer for Single Image Super-Resolution
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章网络结构ESRT（ Efficient Super-Resolution Transformer）还是蛮复杂的，是一个CNN和Transformer结合的结构。文章提出了一个高效SRTransformer结构，是一个轻量级的Transformer。作者考虑到图像超分中一张图像内相似的细节部分可以作为参考补充，（类似于基于参考图像Ref的超分），于是引入了Transformer，可以在图像中建模一种长期依赖关系。而ViT这些方法计算量太大，太占内存，于是提出了这个轻量版的Transformer结构（ET）ET只使用了transformer中的encoder，并且作者还使用了feature spilt将QKV划分为小组分别计算注意力最后拼接。文章还在CNN部分提出了一个高频滤波器模块HFM，保留高频信息进行特征提取。
文章主要重点在速度(高效)， 效果也是很好的，作者在实验部分提到把ET结构嫁接到RCAN中也能提高RCAN的效果，证明了ET的有效性。
原文链接：ESRT：Transformer for Single Image Super-Resolution
源码地址： https://github.com/luissen/ESRT.
ESRT：Transformer for Single Image Super-Resolution[CVPR 2022] Abstract1 Introduction2 Efficient Super-Resolution Transformer2.1 Lightweight CNN Backbone (LCB)2.3 Lightweight Transformer Backbone (LTB) 3 Experiments3.1 Comparisons with Advanced SISR Models3.2 Comparison on Computational Cost3.3 Ablation Study3.4 Real Image Super-Resolution3.5 Comparison with SwinIR 4 Conclusion Abstract 随着深度学习的发展，单幅图像超分辨率（SISR）技术取得了长足的进步。近来越来越多的研究人员开始探索Transformer在计算机视觉任务中的应用。然而，Vision Transformer巨大的计算成本和高GPU内存占用问题阻碍了其脚步。在本文中，提出了一种用于SISR的新型高效超分辨率Transformer（ESRT）。ESRT是一种混合模型，由轻型CNN主干网（LCB）和轻型Transformer主干网（LTB）组成。其中，LCB可以动态调整特征图的大小，以较低的计算成本提取深层特征。LTB由一系列高效Transformer（ET）组成，使用专门设计的高效多头注意（EMHA），它占用的GPU内存很小。大量实验表明，ESRT以较低的计算成本获得了有竞争力的结果。与原始Transformer占用16057M GPU内存相比，ESRT仅占用4191M GPU内存。
1 Introduction 因为在同一张图像中相似的图像patch可以用作彼此的参考图像，以便使用参考patch来恢复特定patch的纹理细节。受此启发，作者将Transformer引入到SISR任务中，因为Transformer具有很强的特征表达能力，可以在图像中建模这种长期依赖关系。目标是探索在轻量级SISR任务中使用Transformer的可行性。近来有一些Transformer已经被提出用于计算机视觉任务。然而，这些方法往往占用大量GPU内存，这极大地限制了它们的灵活性和应用场景。
为了解决上述问题，提出了一种高效的超分辨率Transformer（ESRT），以增强SISR网络捕获长距离上下文依赖的能力，同时显著降低GPU的内存成本。
ESRT是一种混合架构，使用“CNN+Transformer”模式来处理小型SR数据集。ESRT可分为两部分：轻型CNN主干网（LCB）和轻型Transformer主干网（LTB）。
对于LCB，更多地考虑减少中间层特征图的形状，并保持较深的网络深度，以确保较大的网络容量。受高通滤波器的启发，设计了一个高频滤波模块（HFM）来捕捉图像的纹理细节。在HFM的内，又提出了一种高保留块（HPB），通过大小变化有效地提取潜在特征。在特征提取方面，提出了一种功能强大的自适应残差特征块（ARFB）作为基本特征提取单元，能够自适应调整残差路径和路径的权重。在LTB中，提出了一种高效Transformer(ET)，它使用专门设计的高效多头注意（EMHA）机制来降低GPU内存消耗。且只考虑局部区域中图像块之间的关系，因为SR图像中的像素通常与其相邻像素相关。尽管它是一个局部区域，但它比常规卷积要宽得多，可以提取更多有用的上下文信息。因此，ESRT可以有效地学习相似局部块之间的关系，使超分辨区域具有更多的参考。 主要贡献如下：
提出了一种轻量级的CNN主干（LCB），它使用高保留块（HPB）来动态调整特征图的大小，以较低的计算成本提取深层特征提出了一种轻量级Transformer主干（LTB），利用专门设计的高效Transformer（ET）和高效多头注意（EMHA）机制，捕捉图像中类似patch之间的长期依赖关系提出了一种称为高效SR Transformer（ESRT）的新模型，以有效地增强图像中相似patch的特征表达能力和长期依赖性，以较低的计算成本获得更好的性能。 2 Efficient Super-Resolution Transformer 高效超分辨率Transformer（ESRT）主要由四部分组成：浅层特征提取、轻型CNN主干（LCB）、轻型Transformer主干（LTB）和图像重建。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69803287205b87995e8f69909d447b03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b3e6f79afc2f9033f5ae86ceefd258/" rel="bookmark">
			吹爆了这个可视化神器，上手后直接开大~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家推荐一个可视化神器 - Plotly_express ，上手非常的简单，基本所有的图都只要一行代码就能绘出一张非常酷炫的可视化图。
以下是这个神器的详细使用方法，文中附含大量的 GIF 动图示例图。
注：源代码（ .ipypnb 文件）的获取方式，私我“可视化图”即可~
1. 环境准备 本文的是在如下环境下测试完成的。
Python3.7
Jupyter notebook
Pandas1.1.3
Plotly_express0.4.1
其中 Plotly_express0.4.1 是本文的主角，安装它非常简单，只需要使用 pip install 就可以
$ python3 -m pip install plotly_express 2. 工具概述 在说 plotly_express之前，我们先了解下plotly。Plotly是新一代的可视化神器，由TopQ量化团队开源。虽然Ploltly功能非常之强大，但是一直没有得到重视，主要原因还是其设置过于繁琐。因此，Plotly推出了其简化接口：Plotly_express，下文中统一简称为px。
px是对Plotly.py的一种高级封装，其内置了很多实用且现代的绘图模板，用户只需要调用简单的API函数即可实用，从而快速绘制出漂亮且动态的可视化图表。
px是完全免费的，用户可以任意使用它。最重要的是，px和plotly生态系统的其他部分是完全兼容的。用户不仅可以在Dash中使用，还能通过Orca将数据导出为几乎任意文件格式。
官网的学习资料：https://plotly.com/
px的安装是非常简单的，只需要通过pip install plotly_express来安装即可。安装之后的使用：
import plotly_express as px 3. 开始绘图 接下来我们通过px中自带的数据集来绘制各种精美的图形。
gapminder
tips
wind
3.1 数据集 首先我们看下px中自带的数据集：
import pandas as pd import numpy as np import plotly_express as px # 现在这种方式也可行：import plotly.express as px # 数据集 gapminder = px.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b3e6f79afc2f9033f5ae86ceefd258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cde978e00ffd98915bf4fa6d1992ee8/" rel="bookmark">
			git 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git 命令 命令介绍Git global setupCreate a new repositoryExisting folderExisting Git repository 强制提交忽略的文件回退commit的版本命令详解commit注释修改 报错问题fatal: remote origin already exists. git 具体添加文件添加一个文件添加多个文件1、git add 添加多个文件，文件之间以空格隔开2、多次git add3、添加指定目录的文件4、添加文件夹 添加以.开始的文件单独提交.gitignore文件 命令介绍 Git global setup // 查看git配置 git config --list git config --global user.name "Administrator" git config --global user.email "admin@example.com" // 设置密码 git config --global user.password xxx Create a new repository git clone 项目地址 cd 项目目录 touch README.md git add README.md git commit -m "add README" git push -u origin master Existing folder cd existing_folder git init git remote add origin 项目git地址 git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cde978e00ffd98915bf4fa6d1992ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a69b224fbfdf2743f7253b380bec0dc/" rel="bookmark">
			Verilog 基础知识(一) Verilog 基础语法与注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础知识 0.1 模块(Module) Verilog中的module可以看成一个具有输入输出端口的黑盒子，该黑盒子有输入和输出接口(信号)，通过把输入在盒子中执行某些操作来实现某项功能。(类似于C语言中的函数)
图1 模块示意图
0.1.1 模块描述 图1 所示的顶层模块(top_module)结构用Verilog语言可描述为：
module top_module( input a, input b, output out ); ....... endmodule 模块以module 开始，endmodule结束top_module 为模块名input : 为输入端口output: 为输出端口所有代码必须处于module模块中！ 同理，图1 所示的次级模块(mod_a)结构用Verilog语言可描述为：
module top_module( input in1, input in2, output out ); ....... endmodule 注意事项：每个模应单独块处于一个.v文件中，模块名即为文件名(规范代码！)
0.1.2 模块输入输出信号 输出： output输入： input 模块的输入输出端口都可看出模块的信号，若不写信号类型则默认为wire类型信号！
// 以下这两个语句本质是一直的 input a; input wire a; 除了wire型信号，还有reg型信号，具体详见1.4节！
0.1.3 模块实例化 如图1所示，top_module的两个输入端口连接到次级模块(mod_a)的输入端口，那如何在top_module模块模块中使用mod_a模块的功能呢？这就需要通过模块实例化，可以把top_module看成C语言中的主函数，次级模块mod_a看成普通函数，这样就可以在主函数中调用其他函数来完成相应的功能！
在top_module中实例化mod_a的方式为：
模块实例化语法： 模块名 实例名(定义连接port的信号);
module top_module( input a, input b, output out ); mod_a instance2 (.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a69b224fbfdf2743f7253b380bec0dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37c55c4fcee9c4802af1e362708c67c/" rel="bookmark">
			Simulink基础作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.比例-积分-微分（PID）控制器是工业控制中常见的一种控制装置，它广泛用于化工、冶金、机械等工业过程控制系统中。PID有几个重要的功能：提供反馈控制；通过积分作用消除稳态误差；通过微分作用预测将来以减小动态偏差，PID控制器作为最常用的控制器。
对于一伺服系统的传递函数如下
用simulink进行仿真：
1、试观察该系统的阶跃相应曲线，分析其存在的问题。
2、增加一个PID控制器，让其阶跃响应的稳态误差控制在1%以内，超调量不超过4%。对比加入PID控制前后的响应效果。
答案：由上图所示，可知该传递函数的阶跃响应稳态误差比较大，同时超调量比较大，接近13.6%。增加一个PID控制器，使用PID控制器中的自动调节方法，使得该传递函数的超调量不超过4%，且稳态误差控制在1%范围内，得到PID控制器各参数如下图：加入PID后该传递函数的阶跃响应曲线如下图所示：由该图可知，超调量满足不超过4%，稳态误差控制在1%范围内。
2.求分段函数
在x=-5.0,-3.0,1.0,2.0,2.5,3.0,5.0时的y值
答案：
3.在matlab中完成输入100个同学的成绩按顺序保存在excel里边对应的输入顺序号后边，同时在对应分数后面标明等级，过程及转化规则如下：
（1）输入一个百分制成绩，要求成绩等级A、B、C、D、E。其中90分~100分为A，80分~89分为B，79分~79分为C，60分~69分为D，60分以下为E。
（2）如果输入的分数不符合百分制，给出提示，序号不变，并允许重新输入。
（3）当输入完100个成绩后，将序号、成绩、等级保存在一个excel文档里。
逻辑：1、建立一个数组，一列是序号，一列是分数，一列是等级；
2、用for循环进行100个数据的逐一输入，循环变量即为序号；
3、用条件语句判断是否符合百分制，不符合给出提示，修改循环变量，退出当次循环
4、满足百分制，对数组第二列当前序号变量赋分数，用switch语句输出等级保存到第三列
5、循环完成利用xlswrite(filename, data)完成数据的保存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bae95698bb89750e3216a648f861c172/" rel="bookmark">
			React配置代理（proxy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用axios进行请求，而配置代理过程
第一种 在package.json中，添加proxy配置项,之后所有的请求都会指向该地址
但这种方法只能配置一次，也只有一个
示例：
"proxy":"https://localhost:5000" 添加后，重启项目！！！让配置文件加载生效
然后就可以进行请求了
比如请求地址是 http://localhost:5000/api/index/index
那就可以写
axios.get("/api/index/index").then( response =&gt; {console.log('成功了',response.data);}, error =&gt; {console.log('失败了',error);} ) 第二种 在src中，新建setupProxy.js（必须是这个名字，react脚手架会识别），在文件中写以下配置内容（最近的项目要使用高版本这个，不然会导致项目无法启动）：
http-proxy-middleware高版本（2以上）：
const proxy = require('http-proxy-middleware')//引入http-proxy-middleware，react脚手架已经安装 module.exports = function(app){ app.use( proxy.createProxyMiddleware('/api',{ //遇见/api1前缀的请求，就会触发该代理配置 target:'http://localhost:5000', //请求转发给谁 changeOrigin:true,//控制服务器收到的请求头中Host的值 pathRewrite:{'^/api':''} //重写请求路径，下面有示例解释 }), proxy.createProxyMiddleware('/api2',{ target:'http://localhost:5001', changeOrigin:true, pathRewrite:{'^/api2':''} }), ) } http-proxy-middleware低版本（2以下）：
const proxy = require('http-proxy-middleware')//引入http-proxy-middleware，react脚手架已经安装 module.exports = function(app){ app.use( proxy('/api',{ //遇见/api1前缀的请求，就会触发该代理配置 target:'http://localhost:5000', //请求转发给谁 changeOrigin:true,//控制服务器收到的请求头中Host的值 pathRewrite:{'^/api':''} //重写请求路径，下面有示例解释 }), proxy('/api2',{ target:'http://localhost:5001', changeOrigin:true, pathRewrite:{'^/api2':''} }), ) } 写好以后，重启项目！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bae95698bb89750e3216a648f861c172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c2cb01f17c8ef79610b13652e20df22/" rel="bookmark">
			js保存数据为csv格式并导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 handleDownloadCSV() { const tHeader = "Id,标题,作者,读数,时间,"; const filterVal = [ "id", "title", "author", "pageviews", "display_time" ]; // this.list.unshift(Headers) const list = this.list; let csvString = tHeader; csvString += '\r\n' list.map(item =&gt; { filterVal.map(key =&gt; { let value = item[key]; csvString += value + ","; }); csvString += "\r\n"; }); console.log(csvString) csvString = "data:text/csv;charset=utf-8,\ufeff" + encodeURIComponent(csvString); let link = document.createElement('a'); link.href = csvString; //对下载的文件命名 link.download = "用户注册数据.csv"; document.body.appendChild(link); link.click(); document.body.removeChild(link); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb4ceea6a0497c2cdb65487bf4e294e/" rel="bookmark">
			Manifest merger failed : Apps targeting Android 12 and higher are required to specify an explicit v
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建项目运行出现以下异常
Manifest merger failed : Apps targeting Android 12 and higher are required to specify an explicit value for `android:exported` when the corresponding component has an intent filter defined. See https://developer.android.com/guide/topics/manifest/activity-element#exported for details.
按照提示要去AndroidManifest.xml文件中给activity添加android:exported属性：
运行之后发现问题已经解决
原因就是：android12以上manifest里所有activity都要加上android:exported描述
但是不想添加一个就添加这个属性，于是我把编译版本降低到30了，"一次性"解决：
1，File —&gt; Project Structure，把原本31的版本都改成30，如果有其他的modules也一并都改了
2，进入app的build.gradle中修改targetSdkVersion（如果有其他modules也一并修改）
重新编译直接运行就可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/896054e0729b05752963156328829253/" rel="bookmark">
			STIT：StyleGan的视频编辑之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		paper
STIT: Stitch it in Time - GAN-Based Facial Editing of Real Videos
2022 CVPRStyleGan 人脸编辑相关视频编辑 paper code page
Abstract 在人脸图像编辑领域，Gan在latent space内的丰富编码能力已经被广泛应用，然而事实证明，在视频领域仍具有一定困难。高质量的人脸面部视频很缺乏，同时在视频领域需要克服一个基本障碍–时间一致性，我们认为这个障碍大多是人为造成的。源视频是满足时间一致性的，而编辑视频时偏离这种状态的部分原因可能是对编辑pipeline中某些组件的关注度不足。我们使用StyleGan中的人脸对齐网络以及当前先进的神经网络来学习低频函数，并证明了它在提供高度一致性的方面处于领先地位。我们利用以上发现提出了一种框架，用于编辑视频中的人脸。
(左1：原始视频；右1：编辑年轻化后的生成视频) 本篇文章更像是工程上的创新，提出了一种视频编辑的pipeline。
Method (1) Alignment 作者在这里使用了crop + FFHQ对齐
(2)Inversion
作者做了很多的实验，最终决定：首先通过e4e来完成投影，得到图片的latent code。【这些latent vectors被作为PTI的 ‘pivots’（枢纽）。】接下来finetune训练生成器，训练的损失函数如下：
min ⁡ θ 1 N ∑ N ( L L P I P S ( c i , r i ) + λ L 2 P L L 2 ( c i , r i ) ) + λ R P L R .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/896054e0729b05752963156328829253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a52613c57e53f1b5d289a2079853e3/" rel="bookmark">
			Doris或StarRocks Jmeter压测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试介绍： 1. 配置化sql where条件 （5个线程，每个线程执行不同的where条件，通过csv文件实现）
2. 实现固定并发数执行几分钟（如果只是固定并发数执行一次，压测是不合格的，QPS是达不到你设置的并发数）
整个测试涉及到的大概这么多
1. Jmeter JDBC连接 Doris或StarRocks兼容mysql协议，通过jdbc方式连接
说是要加个mysql-connect的jar包
2. csv配置化 比如我3个线程 执行3个where条件 1. wehre name ='zs' 2. where age='18' 3. where sex='male'
csv里按行存就行（这里没做demo，直接拿自己测试的sql）
变量名对应前面的
3. QPS保持在某个固定值 需要设置两个地方，一个是持续时间，还有个常数吞吐量定时器
比如10QPS跑4分钟，那么一分钟大概600，所以要在常数吞吐量里写600，这样能保持稳定的QPS
4. 测试结果 建议使用聚合报告，里面会有90%，95%，99%这些很重要的指标
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f5bf5c2ef3932447d173a6105060ce8/" rel="bookmark">
			Fiddler抓包工具配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先下载Fiddler，点击下载
这个时候会下载一个FiddlerSetup.exe文件下来，双击进行安装。
安装完成时候，我们启动Fiddler
会弹出一个窗口：
Windows uses an isolation technology called 'AppContainer' that may interfere with traffic capture from Immersive Applications and the Edge browser. Use the WinConfig button in Progress Telerik Fiddler's toolbar to enable teaffic capture.
Would you like to learn more?
To disable this warning. click 'Cancel'.
大概意思是这样的：
Windows使用称为“AppContainer”的隔离技术，可能会干扰Immersive Applications和Edge浏览器的流量捕获。 使用Progress Telerik Fiddler工具栏中的WinConfig按钮启用茶叶捕获功能。
你想了解更多吗？
要禁用此警告。 点击“取消”。
点击取消之后
又会弹出一个窗口：
You can help shape the development of Progress Telerik Fiddler by allowing it to send anonymous usage and configuration information to Telerik.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f5bf5c2ef3932447d173a6105060ce8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7a001d3735e3b70ebe18a7f62f93d2/" rel="bookmark">
			Ubuntu20.04安装NVIDIA驱动相关问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu20.04安装NVIDIA驱动相关问题汇总 1. NVIDIA驱动失效简单解决方案：NVIDIA-SMI has failed because it couldn‘t communicate with the NVIDIA driver.参考链接 2.在Ubuntu 20.04上安装NVIDIA驱动程序的方法参考链接 3.安装nvidia驱动Perform MOK management 界面键盘失灵现象参考链接背景：ubuntu20.04安装nvidia驱动在Perform MOK management 界面，键盘失灵，导致安装驱动失败。原因：没有关闭 secure boot； 1. NVIDIA驱动失效简单解决方案：NVIDIA-SMI has failed because it couldn‘t communicate with the NVIDIA driver. 参考链接 使用nvidia-smi监视工具查看图形卡的状态出现如题的错误
nvidia-smi 检查驱动和cuda
nvcc -V 查看已安装驱动的版本信息
ls /usr/src | grep nvidia 比如我的驱动版本是：nvidia-450.57
依次输入以下命令
sudo apt-get install dkms sudo dkms install -m nvidia -v 450.57 等待安装完成后，再次输入nvidia-smi，查看GPU使用状态
2.在Ubuntu 20.04上安装NVIDIA驱动程序的方法 参考链接 获取可用驱动信息
ubuntu-drivers devices 前面找driver，后面找recommend发现了系统推荐安装的驱动程序nvidia-driver-470
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7a001d3735e3b70ebe18a7f62f93d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b93cc67e08d454cbcf3231e9e5ed55/" rel="bookmark">
			Ubuntu18.04：gnutls_handshake() failed: Error in the pull function.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04：gnutls_handshake() failed: Error in the pull function. 克隆GitHub仓库
git clone https://github.com/trekhleb/javascript-algorithms.git --depth=1 出现错误
fatal: unable to access 'https://github.com/trekhleb/javascript-algorithms.git/': gnutls_handshake() failed: Error in the pull function. 错误原因分析：
git使用了libcurl4-gnutls-dev，而在ubuntu18中该库作出了修改，导致git无法使用SSL进行连接。
解决方案1：安装依赖包
sudo apt-get -y install build-essential nghttp2 libnghttp2-dev libssl-dev 使用此方法暂时解决了问题，但不知道什么原因，重新与服务器建立连接后，又抛出了上面的错误。
解决方案2：重新编译并安装使用libcurl4–openssl–dev的git。
具体的脚本：
#安装需要的工具包 sudo apt-get update sudo apt-get install build-essential fakeroot dpkg-dev sudo apt-get build-dep git sudo apt-get install libcurl4-openssl-dev #应当在安装git构建依赖之后否则会报错无法查找到libcurl4-openssl-dev mkdir ~/git-openssl cd ~/git-openssl apt-get source git #git源码 cd git-2.17.1/ #根据你的git源码版本切换 sed -i 's/libcurl4-gnutls-dev/libcurl4-openssl-dev/g' debian/control #将debian/control文件中libcurl4-gnutls-dev全部替换为libcurl4-openssl-dev sed -i 's/TEST =test//g' debian/rules #删除debian/rules文件中TEST =test sudo dpkg-buildpackage -rfakeroot -b #生成安装包 cd .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b93cc67e08d454cbcf3231e9e5ed55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94307427f66c6de6d5f6d0cfaae8dfe2/" rel="bookmark">
			javaweb简单的图书购买系统，超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需求：
基于MVC模式制作一个购物程序，让学生可以在网页上订购教材。该系统由3个界面组成，运行系统，出现显示所有书本的界面。在这个界面中，标题为“欢迎选购图书”；界面上显示了所有的图书和价格，在每种图书后面有一个“购买”链接。单击“购买”链接，能够显示购买界面。单击图书后面的“购买”链接显示的界面，其中数量是手工输入的。在该界面中输入购买数量，提交，能够将该图书存入购物车。在存入之后可以显示购物车中的所有内容。在每种图书后面有一个“删除”链接，单击该链接，能够将相应内容从购物车中删除。另外，单击“继续买书”链接能够重新到达显示所有书本的页面。
1.首先在index.jsp界面设置，这样进入项目时，只输入项目名后便可以直接进入项目，省略了输入项目后再选择项目名下的子目录。
&lt;jsp:forward page="InitServlet"&gt;&lt;/jsp:forward&gt;
如下图所示，这样做的好处是可以固定进入项目的先后顺序。
2.index.jsp界面首先跳转到InitServlet.java界面。InitServlet.java界面实例化BookDao类中的对象，通过实例化的对象调用getAllBook()方法得到数据库中的全部数据。
package servlet; import java.io.IOException; import java.util.HashMap; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.mysql.fabric.Response; import dao.BookDao; @WebServlet("/InitServlet") public class InitServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BookDao bookDao=new BookDao(); HashMap allBook=null; try { allBook=bookDao.getAllBook(); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } req.getSession().setAttribute("allBook", allBook); resp.sendRedirect("showAllBook.jsp"); } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94307427f66c6de6d5f6d0cfaae8dfe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f9ddfa766a50e7be941792f1533395/" rel="bookmark">
			入门激光雷达点云的3D目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 虽然业界有很多的争论，但是LiDAR在目前的L3/L4级自动驾驶系统中依然是不可或缺的传感器，因为它可以提供稠密的3D点云，非常精确的测量物体在3D空间中的位置和形状，而这是摄像头和毫米波雷达很难做到的。那么相应的，基于LiDAR点云的感知算法也就成为了近年来自动驾驶研发的重点之一。与图像的感知算法类似，LiDAR点云的感知算法也分为物体检测（包括跟踪）和语义分割两大类。这篇文章主要关注基于LiDAR点云的物体检测算法，语义分割算法留待以后再做介绍。
很多综述性的文章把LiDAR点云的物体检测算法粗略分为四类：Multi-view方法，Voxel方法, Point方法，以及Point和Voxel结合的方法。这种基于分类的综述更像是一个算法图书馆，读者可以根据关键字（或者说关键技术）进行索引，方便于查询和归档，可能更适合于该领域内的工作者。但是我想并不是所有的读者都对这个方向有比较深入的了解，直接讲方法分类和技术细节可能会从一开始就让读者迷失在算法的森林里。
所以，与一般的综述不同，在这篇文章里我以时间为线索，将LiDAR点云物体检测的发展历程粗略地划分为了四个时期：萌芽期，起步期，发展期和成落地期。我会从技术发展的角度，结合自己在研究中的一些体会来介绍各种算法。这篇综述的目的不在于包罗这个方向所有的文章，我只会选一些在技术发展的道路上具有重要意义的工作。当然本人水平有限，其中肯定会有疏漏。但是，如果大家读完以后能够对该方向的发展脉络有一个基本的认识，那我想我的目的就达到了。
基本概念 在进入具体的介绍之前，还是有必要简单说一下一些基本的概念。LiDAR的输出数据是3D点云，每一个点除了包含X，Y，Z坐标，还包含一个反射强度R，类似与毫米波雷达里的RCS。3D物体检测的目标是要根据点云数据来找到场景中所有感兴趣的物体，比如自动驾驶场景中的车辆，行人，静态障碍物等等。下图以车辆为例，来说明输出结果的格式。简单来说，检测算法输出多个3D矩形框（术语称为3D BoundingBox，简称3D BBox），每个框对应一个场景中的物体。3D BBox可以有多种表示方法，一般最常用的就是用中心点3D坐标，长宽高，以及3D旋转角度来表示（简单一些的话可以只考虑平面内旋转，也就是下图中的θ）。
检测算法输出的3D BBox与人工标注的数据进行对比，一般采用3D IoU （Intersection over Unoin）来衡量两个BBox重合的程度，高于设定的阈值就被认为是一个成功的检测，反之则认为物体没有被检测到（False Negative）。如果在没有物体的区域出现了BBox输出，则被认为是一个误检（False Positive）。评测算法会同时考虑这两个指标，给出一个综合的分数，比如AP（Average Precision）以此为标准来评价算法的优劣。由于不是本文的重点，具体的细节这里就不做赘述了。
萌芽期 （2017年之前） 有了前面的铺垫，下面我们的算法之旅正式开始了。话说物体检测算法的兴起主要来自于计算机视觉领域，自从2012年深度学习出现以来，图像和视频中的物体检测算法在性能上有了大幅度的提高，各种经典算法也是层数不穷，比如最早的R-CNN，到后来的Faster RCNN，再到YOLO以及最新的CenterNet等等，可以说已经研究的非常透彻了。
那么，在做点云中的物体检测时，人们自然的就会想到要借鉴视觉领域的成功经验。VeloFCN[2]就是其中的代表性方法。它将3D点云转换到与图像相似的正视图（Front View），得到一个"点云伪图像"。这种数据在格式和性质上与图像非常类似，自然的也就可以照搬图像上的物体检测算法。但是这种表示的缺陷也很明显，首先多个点可能映射到图像坐标的同一个位置，这样会造成信息的丢失。更为重要的是，将3D的点映射到2D平面，丢掉了深度信息，而这个信息对3D物体检测来说是非常重要的。
因此，人们又想到可以把3D点云映射到俯视图（也称作鸟瞰视图，Bird’s Eye View, 简称BEV）。这种映射是非常直观的，你可以简单的认为把3D点的高度坐标忽略（将其看作点的特征），从而得到2D平面上的数据表示。MV3D[3]就是将3D点云同时映射到正视图和俯视图，并与2D图像数据进行融合。以上说的都是数据构建和特征提取，至于后端的检测算法，一般来说这个时期都是采用基于R-CNN或者类似的方法。这里就不做解释了，网上可以找到很多介绍性文章。
起步期（2017年） 时间进入2017年，在这个年份里出现了两个在点云物体检测领域堪称里程碑式的工作：
VoxelNet[4]和PointNet++[5]。这两个工作代表了点云处理的两个基本方向，VoxelNet将点云量化为网格数据，而PointNet++直接处理非结构化的数据点。下面我会稍微详细的介绍一下这两个方法，因为之后点云物体检测领域几乎所有的方法都离不开这两个工作里的概念。
VoxelNet 这个工作是2017年由苹果公司的两位研究人员提出的，并且发表在了CVPR 2018上（计算机视觉和模式识别领域的顶会）。
其思路并不复杂，首先将点云量化到一个均匀的3D网格中（下图中的grouping）。每个网格内部随机采样固定数量的点（不足的就重复），每个点用7维特征表示，包括该点的X，Y，Z坐标，反射强度R，以及该点相对网格质心（网格内所有点位置的均值）的位置差ΔX，ΔY和ΔZ。全连接层被用来提取点的特征，然后每个点的特征再与网格内所有点的特征均值进行拼接，得到新的点特征。这种特征的优点在于同时保留了单个点的特性和该点周围一个局部小区域（网格）的特性。这个点特征提取的过程可以重复多次，以增强特征的描述能力（下图中的Stacked Voxel Feature Encoding）。最终网格内的所有点进行最大池化操作（Max Pooling），以得到一个固定长度的特征向量。
以上这些步骤称为特征学习网络，其输出是一个4D的Tensor（对应X，Y，Z坐标和特征）。这与一般的图像数据不同（图像是3D Tensor，只有X，Y坐标和特征），因此还没法直接采用图像物体检测的方法。VoxelNet中采用3D卷积对Z维度进行压缩（比如stride=2）。假设4D Tensor的维度为HxWxDxC，经过若干次3D卷积后，Z维度的大小被压缩为2（也就是HxWx2xC’），然后直接将Z维度与特征维度合并，生成一个3D的Tensor（HxWx2C’）。这就和标准的图像数据格式相似了，因此可以接上图像物体检测网络（比如Region Proposal Network，RPN）来生成物体检测框，只不过这里生成的是3D的检测框。
从上面的介绍可以看出，VoxelNet的框架非常简洁，也是第一个可以真正进行端对端的学习的点云物体检测网络。实验结果表明，这种端对端的方式可以自动地从点云中学习到可用的信息，比手工设计特征的方式更为高效。
PointNet++ 该方法的前身是PointNet[6]，由斯坦福大学的研究者在2017年发表，这也是点云处理领域的开创性工作之一。PointNet处理的是点云分类任务，其主要思路是直接处理原始的点云。除了一些几何变换之外，PointNet主要有两个操作：MLP（多个全连接层）提取点特征，MaxPooling得到全局特征。物体分类网络采用全局特征作为输入，而分割网络则同时采用全局特征和点特征。
简单来说，你可以把PointNet分类网络看做一个分类器，比如可以理解为传统方法中的SVM。但是要进行物体检测的话，就还需要一个类似于Sliding Window的机制，也就是说在场景内的各个位置应用PointNet来区分物体和背景，以达到物体检测的效果。当然对于相对稀疏的点云数据来说，这种做法是非常低效的。因此，PointNet的作者同年就提出了升级版本，也就是PointNet++。
其主要思路是用聚类的方式来产生多个候选区域（每个区域是一个点集），在每个候选区域内采用PointNet来提取点的特征。这个过程以一种层级化的方式重复多次，每一次聚类算法输出的多个点集都被当做抽象后的点云再进行下一次处理（Set Abstraction，SA）。这样得到的点特征具有较大的感受野，包含了局部邻域内丰富的上下文信息。最后，在多层SA输出的点集上进行PointNet分类，以区分物体和背景。同样的，这个方法也可以做点云分割。
PointNet网络结构[6]
与VoxelNet相比，PointNet++的优点在于：1）没有量化带来的信息损失，也无需调节量化超参数；2）忽略空白区域，避免了无效的计算。但是缺点也显而易见：1）无法利用成熟的基于空间卷积的2D物体检测算法；2）虽然避免了无效计算，但是GPU对于点云的处理效率远低于网格数据，因此实际的运行速度甚至更慢。
发展期（2018年-2020年） 在VoxelNet和PointNet++相继提出后，3D物体检测领域迎来了一个快速发展期，很多算法被提出，用来改进这两个工作中的不足。
对Voxel方法的改进
VoxelNet的主要问题在于数据表示比较低效，中间层的3D卷积计算量太大，导致其运行速度只有大约2FPS（Frame Per Second），远低于实时性的要求，因此后续很多工作针对其运行效率的问题进行了改进。
**SECOND[7]**采用稀疏卷积策略，避免了空白区域的无效计算，将运行速度提升到了26FPS，同时也降低了显存的使用量。
**PIXOR[8]**提出通过手工设计的方式，将3D的Voxel压缩到2D的Pixel。这样做避免了3D卷积，但是损失了高度方向上的信息，导致检测准确度下降很多。
**PointPillar[9]**的思路也是3D转2D，也就是将点3D云量化到2D的XY平面网格。但是与PIXOR手工设计特征的方式不同，PointPillar把落到每个网格内的点直接叠放在一起，形象的称其为柱子(Pillar)，然后利用与PointNet相似的方式来学习特征，最后再把学到的特征向量映射回网格坐标上，得到与图像类似的数据。这样做一来避免了VoxelNet中的3D卷积和空白区域的无效计算(运行速度达到62FPS)，二来避免了手工设计特征导致信息丢失和网络适应性不强的问题，可以说是很巧妙的思路。不好的方面是，点特征的学习被限制在网格内，无法有效的提取邻域的上下文信息。
对Point方法的改进 PointNet++采用基于聚类的方法来层级化的提取邻域特征以及获得物体候选，这种做法效率比较低，而且也很难做并行加速。而这恰巧是传统的2D卷积网络的强项，因此后续的工作逐渐将2D物体检测算法中的一些思路拿过来，用来解决PointNet++中的问题。
Point-RCNN[10]首先在这个方向了进行了探索，可以称得上3D物体检测领域的又一个里程碑式的工作。从名字上就能看出，这个方法将点云处理和2D物体检测领域的开山之作Faster RCNN结合了起来。首先，PointNet++被用来提取点特征。点特征被用来进行前景分割，以区分物体上的点和背景点。同时，每个前景点也会输出一个3D候选BBox。接下来就是将候选BBox内的点再做进一步的特征提取，输出BBox所属的物体类别，并且对其位置，大小进行细化。
看到这里，熟悉2D物体检测的朋友肯定会说，这不就是一个典型的两阶段检测模型嘛。没错，但不同的是，Point-RCNN只在前景点上生成候选，这样避免了3D空间中生成稠密候选框所带来的巨大计算量。尽管如此，作为一个两阶段的检测器，加上PointNet++本身较大的计算量，Point-RCNN的运行效率依然不高，只有大约13FPS 。Point-RCNN后来被扩展为Part-A2[11]，速度和准确度都有一定的提升。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f9ddfa766a50e7be941792f1533395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc15dc25899a305c6d8a848ac5edda2d/" rel="bookmark">
			mysql事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、事务的特性：
1.原子性
保证一个事务中数据要么全部成功提交，要么全部失败回滚，不能只执行其中一部分操作。
2.一致性 事务的执行不能破坏数据库的完整性和一直性，在事务的执行前后数据库都必须处于一致性状态。
3.隔离性
未授权读取（未提交的数据读取），授权读取（已提交数据的读取），可重复读取和串行化
4.持久性
一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态
注：mysql的MyISAM引擎不支持事务
二、查看数据库引擎
#查看数据库引擎
show engines;
三、配合spring框架使用方法以及配置：
1.spring配置事务
编程式：通过编码的方式手动启用、提交或回滚事务，粒度更细，但更麻烦。
声明式：通过在方法或类或接口上添加注解进行包装，无侵入地实现事务，更方便，但粒度更大。
2.配置事务管理器
&lt;!-- 开启事务注解驱动，基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true" /&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; 四、简单测试使用编程式事务
1.数据库表中原数据：
2.对表进行添加和删除操作（使用100/0模拟引发错误）
@Override public void shiwu(Liuyan record) { // 开始事务 TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { Liuyan liuyan = new Liuyan(); liuyan.setLyid(utils.getUUID()); liuyanMapper.insertSelective(liuyan); liuyanMapper.deleteByPrimaryKey("7bebc14c-ba49-418f-b762-fb8a45e72502"); int ss=100/0;//模拟引发错误 transactionManager.commit(status);// 提交事务 } catch (Exception e) { // TODO: handle exception // 异常回滚，并不一定要在try.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc15dc25899a305c6d8a848ac5edda2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2203ae016ccd7d99f9e814b1f6a923a1/" rel="bookmark">
			[MIT]微积分重点 第十六课 关于增长的微分方程 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节课讲的是关于增长的微分方程。
1.最简单的增长微分方程 为：
d ⁡ y d ⁡ t = c y y ( 0 ) \frac{\operatorname{d}y}{\operatorname{d}t} = cy\quad y(0) dtdy​=cyy(0)
解为：
y ( t ) = y ( 0 ) e c t y(t) = y(0)\rm {e}^{ct} y(t)=y(0)ect
这里讲的比较抽象，可以用个例子帮助理解下。 y ( t ) y(t) y(t) 表示储蓄账户里的钱， c c c 为年利率， y ( 0 ) y(0) y(0) 为第 0 0 0 年存入的钱。如果年利率 c = 3 % c=3\% c=3% ， y ( 0 ) = 10000 y(0)=10000 y(0)=10000 ，那么解为： y ( t ) = 10000 e 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2203ae016ccd7d99f9e814b1f6a923a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180c35f2a236b8c6bf63e15a38634a52/" rel="bookmark">
			input上传图片，以及动态添加表单，img白边
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import './App.scss'; import { useState } from 'react'; function getBase64(img, callback) { const reader = new FileReader(); reader.addEventListener('load', () =&gt; callback(reader.result)); reader.readAsDataURL(img); } function App() { const [btn,setBtn]=useState([ { name: '', page: '', lik:'', imgUrl:'' } ]) const addbtn = ()=&gt;{//往btn这个数组里面，添加一个对象，对象里面是表单字段，动态添加了一项表单 const aa = [...btn] aa.push( { name: '', page: '', lik:'', imgUrl:'' } ) setBtn(aa) } const handleImageChange = (e,index) =&gt; {//图片上传函数 let aa = e.target.files[0] getBase64(aa, function(res){//图片解码base64 const a = [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180c35f2a236b8c6bf63e15a38634a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4881a551af04bc29f2f3c2f654ab68d6/" rel="bookmark">
			启发式搜索学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、启发式搜索是什么？二、启发式可接受的启发式一致性的启发式 三、贪婪搜索四、A*搜索ps： 前言 之前有听到老师说启发式搜索，百度那种，顿时感兴趣，搜索与学习，以下是笔记。
一、启发式搜索是什么？ 启发式搜索(Heuristically Search)又称为有信息搜索(Informed Search)，它是利用问题拥有的启发信息来引导搜索，达到减少搜索范围、降低问题复杂度的目的，这种利用启发信息的搜索过程称为启发式搜索。
二、启发式 启发式功能能够让我们估算我们与目标之间的距离
可接受的启发式 当一个启发式函数h满足：0&lt;=h(n)&lt;=h*(n)，我们就说它是可满足的h*(n)是去最近的目标的真实耗散当在A*搜索中，h(n)若等于0，则变为统一成本搜索 一致性的启发式 可接受性仅仅是针对目标和启发式的成本，一致性的主要思想是估计启发式成本，而不仅仅是目标的实际成本，每个地方都要具有代表性
一致性的后果：沿路径的f值从不减小，这意味着当我们扩大目标的时候，我们就知道已经完成了搜索，因为再往下搜索由于一致性的原因，f值会越来越大 三、贪婪搜索 机制：在边缘中搜索通过启发式功能预估距离目标最接近的一个结点
缺陷：贪婪搜索找到的很有可能只是局部最优解，而不是全局最优解，像上图中忽略了耗散一样
四、A*搜索 统一成本搜索：稳定，速度慢贪婪搜索：速度快但是很有可能找到的不是最优解A*搜索：将上述二者结合起来，f(n)=g(n)+h(n) g(n)为后向成本，h(n)为启发式前向成本A*搜索的扩展目标取决于其启发式
ps： 以上部分摘自https://zhuanlan.zhihu.com/p/114949954
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e4d65e0e2f52f76c194f081cee3e27/" rel="bookmark">
			@intlify/vite-plugin-vue-i18n 报错：[vite] Internal server error: Unexpected character ‘#‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @intlify/vite-plugin-vue-i18n 报错：[vite] Internal server error: Unexpected character '#' 1.报错截图2.原因（手欠）《目录：Java-JDBC学习》《幕》 1.报错截图 2.原因（手欠） 文件内容错误，改回来就好了
《目录：Java-JDBC学习》 点击跳转 《幕》 留白 —&lt;老吉&gt; ~ 今 ~ ❀ ~ ❀❀❀❀❀❀❀❀❀❀ ❀❀❀❀❀❀❀❀❀❀ ❀❀❀❀❀❀❀ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2faecff926c55a1e0d0f321e1bffcdc3/" rel="bookmark">
			本地仓库及常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
创建本地仓库示例。Git常用命令。 1.创建本地仓库示例
在桌面上新建一个文件夹重命名为MyTest&gt;&gt;进入文件夹后鼠标右键打开Git Bash Here&gt;&gt;输入git init回车。
此时，出现.git文件夹就说明MyTest文件夹初始化成了一个空的本地仓库（有可能.git文件夹是隐藏的，在我的电脑&gt;&gt;查看&gt;&gt;隐藏的项目）。
2.Git常用命令。
/* * 括号内是解释，不是命令操作。另外“代称”是远程仓库的别名，查看代称的方式是通过命令 * git remote -v。如果有关联的远程仓库则回显示 * 代称 远程仓库 (fetch) * 代称 远程仓库 (push) */ git config --global user.name “用户名” git config --global user.email “邮箱” #ssh-keygen -t rsa -C "xxxxx@xxxxx.com" (生成公钥私钥) echo "# MyGitHub" &gt;&gt; README.md（将注释写入Readme.md） git init（初始化本地仓库） git add README.md（将Readme.md添加到暂存区，添加指定的文件到暂存区） git commit -m "注释"（将暂存区的添加到本地仓库） git remote add 代称 远程仓库的SSH （将本地仓库关联到远程仓库，也就是本地仓库增加一个远程仓库） git remote -v （查看本地仓库关联的远程仓库是否成功） git remote remove 代称 (取消跟“代称(远程仓库)”的关联) git push -u origin master（首次推送到远程仓库中） 说明&lt;代称&gt;是你的远程仓库别名，比如：你可以写gitee(码云)、github，默认是origin等。 ///&lt;summary&gt; ///提交新文件和被修改文件，不包括被删除的文件。 ///&lt;/summary&gt; git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2faecff926c55a1e0d0f321e1bffcdc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d634f66ee5c9920b8b7cf0561b0a2993/" rel="bookmark">
			嵌入式常用的开源库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读目录 linux/嵌入式常用开源库列表其他资料参考资料 linux下/嵌入式常用的开源库名字及简介，使用文档和教程可以自己百度 (自己整理，不定时完善)
linux/嵌入式常用开源库列表 SQLite
SQLite是一款轻型的数据库。它的设计目标是嵌入式的，而且目前已经在很多嵌入式产品中使用了它，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。
源码地址：http://www.sqlite.org/
libjpeg
libjpeg是一个完全用C语言编写的库，包含了被广泛使用的JPEG解码、JPEG编码和其他的JPEG功能的实现。
源码地址：http://sourceforge.net/projects/libjpeg/files/
libevent
Libevent 是一个用C语言编写的、轻量级的开源高性能网络库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I/O 多路复用技术， epoll、 poll、 dev/poll、 select 和 kqueue 等；支持 I/O，定时器和信号等事件；注册事件优先级。
源码地址：https://github.com/nmathewson/Libevent
libcurl
libcurl主要功能就是用不同的协议连接和沟通不同的服务器。 libcurl当前支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传（当然你也可以使用PHP的ftp扩展）, HTTP基本表单上传，代理，cookies,和用户认证。
源码地址：http://curl.haxx.se/
libiconv
libiconv库为需要做转换的应用提供了一个iconv()的函数，以实现一个字符编码到另一个字符编码的转换。libiconv在系统缺少多种多样的字符编码支持时，提供这样方面的支持。
源码地址：http://www.gnu.org/software/libiconv/
mcrypt/libmcrypt
一个功能强大的加密算法扩展库，在保证应用的应用性时，通过该扩展库的加密算法保证安全性
源码地址：http://mcrypt.sourceforge.net/
libpng
libpng可用于读写png文件
源码地址：http://libmng.com/pub/png/libpng.html
freetype
FreeType库是一个完全免费(开源)的、高质量的且可移植的字体引擎，它提供统一的接口来访问多种字体格式文件，包括TrueType, OpenType, Type1, CID, CFF, Windows FON/FNT, X11 PCF等。支持单色位图、反走样位图的渲染。FreeType库是高度模块化的程序库，虽然它是使用ANSI C开发，但是采用面向对象的思想，因此，FreeType的用户可以灵活地对它进行裁剪。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d634f66ee5c9920b8b7cf0561b0a2993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f96cfa4e6e6935d63b7a9c19bacd810/" rel="bookmark">
			[手机Linux] 四，Linux修改yum源为阿里源，寻找systemctl的替代品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
我们直接用yum install 下载安装包，因为用的是国外的源，下载速度难免会受限，我们可以改为用阿里源，当然你不改也是没问题的。还有因为在手机安装的linux是安装在一个容器里的，当我们使用systemctl命令时，无法启用服务，提示：Running in chroot, ignoring request. 百度了很多，找到有可以替代的方法。
原料：
还是那部萌萌的小米6手机
一，禁用Yum插件 用vim编辑 /etc/yum.conf 文件，找到 plugins=1 这一行改为0即可
vim /etc/yum.conf 二，替换yum源为阿里源 先用cat /etc/redhat-release 命令查看自己的系统版本
cat /etc/redhat-release 用vim编辑文件：/etc/yum.repos.d/CentOS-Base.repo
编辑前先备份，用cp命令复制一份
cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bk_20220508 将下面的 7.9.2009 换成你自己当前系统的版本号
适用于aarch64构架的阿里云镜像源配置文件
用 vim /etc/yum.repos.d/CentOS-Base.repo 编辑文件
可以用命令ggdG 快速清空当前文件，在命令模式下,首先执行 gg 这里是跳至文件首行 再执行: dG 也就是直接按 ggdG 这样就清空了整个文件，然后用下面的内容粘贴替换，:wq保存退出。
# CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f96cfa4e6e6935d63b7a9c19bacd810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2a790a04774954e68776baf9b0aeb2/" rel="bookmark">
			关于Vue报错“Component name “School“ should always be multi-word”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Vue报错“Component name “School” should always be multi-word”的解决方法 大家在学习Vue单文件的时候是不是碰到了这个问题了呀，不要慌，问题不大。
首先咱来看一下这报错是啥意思
“Component name “School” should always be multi-word”
翻译成中文就是
“组件名称“School”应该总是由多个单词组成 ”
现在来看就简单很多啦，这是因为我们默认开启了语法检测，关于语法问题，每个人开发习惯和公司开发标准可能都不一样。所以如果大家觉得没必要非得遵守它的默认语法规则的话，大家直接的关闭语法检测即可。
解决方法： 在项目目录里面找到vue.config.js文件，在module.exports里面添加一行配置即可。
lintOnSave:false //关闭语法检查 完整代码附上
const { defineConfig } = require('@vue/cli-service') module.exports = defineConfig({ transpileDependencies: true, lintOnSave:false //关闭语法检查 }) 如果项目目录里面没有vue.config.js的话大家在目录里面创建一个这个文件就行。
目录附上：
最好，如果帮助到你的话，请留下你的小心心，谢谢谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5409f9792e992612cb61131dec2a2300/" rel="bookmark">
			关于hive on spark的distribute by和group by使用以及小文件合并问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注交流微信公众号：小满锅 问题导言 最近在使用hive时，发现一些任务的因为使用mapreduce的缘故，跑的太慢了，才几十个G的数据就经常跑一个多小时，于是有了切换spark的想法。
但是刚刚切换了spark，第二天发现跑出来的数据文件数大大增加，而且每个文件都非常小，导致下游spark任务为了每个小文件都启动一个task，申请资源对于spark来说是非常消耗资源的，任务又大大延迟了。
查了下关于spark合并小文件，目前有几个参数会提供参考。
输入端 set mapred.max.split.size=256000000; 设置：每个Map最大输入大小，这个值决定了合并后文件的数量； set mapred.min.split.size.per.node=100000000; 设置：一个节点上split的至少的大小，这个值决定了多个DataNode上的文件是否需要合并； set mapred.min.split.size.per.rack=100000000; 设置：一个交换机下split的至少的大小，这个值决定了多个交换机上的文件是否需要合并； set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat; 设置：输入端map合并小文件。 输出端 这个是hive on mapreduce的合并小文件参数： set hive.merge.mapfiles=true; 设置：启用小文件合并 - Map-Only作业，默认true； set hive.merge.mapredfiles=true; 设置：启用小文件合并 - Map-Reduce作业，默认false； hive.merge.size.per.task=268534456； 设置：合并后所需每个文件的大小，默认256MB;这个数值是个约数，合并后文件大小会有上下浮动。 set hive.merge.smallfiles.avgsize=16777216; 设置：小文件平均大小合并阈值，默认16MB; 上面是针对hive on mapreduce的调参，但是换了spark后，就需要调整这些了
set hive.merge.sparkfiles=true; 设置：启用小文件合并 - Spark 作业，默认false; 有教程是这个样子，但是呢，会有一些问题，目前社区对spark合并小文件支持还不够完善，有些版本，或者有些公司的hive on spark可能这个参数设置效果没用或者根本不明显
但是目前首有介绍其他办法，可以做到这个合并小文件
SET spark.sql.adaptive.enabled=true; SET spark.sql.adaptive.shuffle.targetPostShuffleInputSize = 512MB; 这两个参数能够自适应调整文件大小，但是呢仅仅靠这两个参数还不够用。因为它只能调整shuffle的分区，如果过于分区输出的文件数过小(比如只有十几M)，而分区数有非常多。比如shuffle分区有200个，每个分区Read512MB，Output 20M，那么就有200个20M的小文件了。
有人会想着，将spark.sql.adaptive.shuffle.targetPostShuffleInputSize参数调大，但是这个不可控，因为你不能确定每个任务的十几Output是多少，所以就会有问题，而且这样每个任务都要去调整这个参数，非常不友好，再说了，万一shuffle分区Output只有1M，你这个值得调到多大，那么分区Read和父分区存储得有多大压力。
distribute by去重新调整数据分布 在上面的基础上，我们可以使用distribute by多进行一次shuffle。
原理就是因为spark.sql.adaptive.shuffle.targetPostShuffleInputSize它只能控制每个分区的Read的大小，而随着数据量增加，每个分区的read又被固定限制，导致分区数增加不可控，从而每个分区可能输出数据量非常小的文件。那么这时候，我们只需要在原来分散零碎的数据基础上，再增加一次shuffle，也就是进行一次distribute by。在这个distribute by过程中，分区read是512M左右，而单纯的distribute by不会进行过滤之类的，所以每个分区相当于一定要读取512M的数据，然后再将它们写出512M，那么就可以将那些小文件合并了。
distribute by和Group by group by是根据字段去分组，做聚合计算，它的执行是在select之前。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5409f9792e992612cb61131dec2a2300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84f711e15e2e23ca96129c7657ace2a/" rel="bookmark">
			kvm虚拟机搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kvm虚拟机搭建
准备：
一台rhel八虚拟机(内存给4g最好，磁盘给40G)
1.基础配置
关闭防火墙
systemctl stop firewalld systemctl disable firewalld 关闭selinux
vim /etc/selinux/config setenforce 0 查看是否支持cpu虚拟化
lsmod | grep kvm 如果没有开就，打开虚拟机设置&gt;把虚拟化initel VT-x/EEPT 或者 AMD-V/RVI（V）打个✔
mkdir -p /data_kvm/iso #镜像存放地址
mkdir -p /data_kvm/node #虚拟机存储的目录
使用xftp把iso镜像上传到 /data_kvm/iso下
搭建仓库
本地仓库
vim /etc/yum.repos.d/file.repo
写入配置后保存并退出
挂载镜像
mount /dev/sr0 /mnt/ mount: /mnt: WARNING: device write-protected, mounted read-only.
1.装包
yum install -y qemu-kvm libvirt virt-manager virt-install Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b84f711e15e2e23ca96129c7657ace2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f64f5eb2dd38b42b9ea5d8928ce602/" rel="bookmark">
			（未解决）main.ts中引入scss报错 (vue3&#43;typescript&#43;@vue/cli5&#43;系列问题总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 安装sass、sass-loader，vue.config.js中配置对应的scss文件路径。可以正常使用。但是如果在main.ts中引入，则会报错。 当前问题目前还未找到原因..... 项目技术栈： 脚手架：@vue/cli 5.0.4 vue：vue 3.2.13 typescript：4.5.5 sass：1.32.7 sass-loader：12.0.0 1、vue/cli5+ vue3 + typescript：全局引入scss文件，main.ts中引入scss报错 参考： 按照官网配置( 向预处理器 Loader 传递选项) 参考对应版本博客( (博客)vue3cli5.0.4sass+sass-loader实现scss全局变量引入) vue.config.js main.ts中引入 控制台报错 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba20805510963a5bb885bcb2f858f6ed/" rel="bookmark">
			.vue文件引入子组件报错 (vue3&#43;typescript&#43;@vue/cli5&#43;系列问题总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目技术栈： 脚手架：@vue/cli 5.0.4 vue：vue 3.2.13 typescript：4.5.5 sass：1.32.7 sass-loader：12.0.0 背景： .vue文件组件中引入子组件报错(并不是所有的子组件都报错。编译不报错，不影响项目运行) 问题详情： 1、父组件中引入两个子组件，只有一个报错 错误信息： 文件“/Users/wangweizhang/client-h5-v2/src/components-pc/home/HomeBackground.vue.ts”不是模块。ts(2306) File '/Users/wangweizhang/client-h5-v2/src/components-pc/home/HomeBackground.vue' is not a module.Vetur(2306) HomeIndex.vue 2、于是我怀疑是d.ts文件中对ts中引入.vue结尾的配置出现了错误，排查了/src/shims-vue.d.ts类型声明文件。 并没有发现任何问题，百思不得其解。去社区看看相关人员是否有遇到此类情况，也没有查到。 3、产生了其他的思考： 那为什么只在个别组件引入的情况会报错呢？是否与子组件中编写的代码有关系呢？ 静下心来观察报错子组件中的代码，和报的错误信息。 HomeBackground.vue文件 HomeIndex.vue错误信息 为什么我引入的明明是.vue文件，报错信息是xxx.vue.ts不是模块呢？为什么下面的HomeContent.vue组件就能够正常引入不报错误呢？ 哎呀妈呀！观察发现HomeBackground.vue组件中，创建了一个空的script标签，并且告诉vuecli要是用ts语法解析和校验，那我此时 想，一定就是这个空带有ts声明的script标签的问题了。于是我带着足够的好奇心。 删除了script标签，错误真的消失了。 4、那么如果我的组件是有逻辑、有状态的组件呢，应该怎么解决这个问题呢？ 回答是：正常引入该有的api，至少实例化组件，并将其导出，这个问题则不复存在。 总结 对于这次报错，我的总结是： 如果被引入的组件是无逻辑的单文件组件(静态组件)不需要加上使用ts声明的script标签，直接编写静态模版和style就好如果需要写入逻辑，那么就应该初始化一个基础的组件，引入基础的api，并且导出一个vue实例 结尾 截止目前(2022-5-12)，typescript和vue3+@vue/cli5.0.4是我在项目中的第一次体验。在这个过程中一定会遇到特别多对于初次体验 这套技术栈的问题，本人会一一记录下来，当作学习笔记。 如果这系列文章能够帮助到您，请关注，以免丢失链接。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e5fd9002ec9f34995bd3f5e2dbbb48/" rel="bookmark">
			office2021官方正版镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文献给那些想装正版office2021的小伙伴，由于office贴吧严重存在各种广告！！！因此特意发此文！！！远离广告！！！
office2021索引 Office2021下载地址合集一、专业增强版（强烈推荐）：二、专业版：三、家庭学生版：四、家庭企业版：五、独立版（不推荐）： Office2021下载地址合集 说明：仅支持Win10/11系统，img镜像Win10/11下直接装载打开即可。
是官方镜像，因此需要密钥，密钥自行解决，只提供下载地址
一、专业增强版（强烈推荐）： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2021Retail.img
二、专业版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Professional2021Retail.img
三、家庭学生版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/HomeStudent2021Retail.img
四、家庭企业版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/HomeBusiness2021Retail.img
五、独立版（不推荐）： Word： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Word2021Retail.img
Excel： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Excel2021Retail.img
PowerPoint： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/PowerPoint2021Retail.img
Outlook： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Outlook2021Retail.img
Access：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Access2021Retail.img
Publisher： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Publisher2021Retail.img
Project标准版：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectStd2021Retail.img
Project专业版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectPro2021Retail.img
Visio标准版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioStd2021Retail.img
Visio专业版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2021Retail.img
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e49a9866a5dae9b92b279cf1e6edac/" rel="bookmark">
			do...while循环 *for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		while先判断后执行.do...while是先执行后判断
Do...while总是保证循环体会被至少执行一次，这是他们的主要差别
对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一句
do...while循环和while循环相似，不同的是，do....while循环至少会执行一次
while和do...while的区别
public class DoWhileDay01 { public static void main(String[] args) { int i =0; int sum =0; do { sum = sum+i; i++; }while (i&lt;=100); System.out.println(sum); //do while先执行后判断 //while 先判断在执行 //do while 能保证循环体至少被执行一次，这是他们的差别 } while先判断后执行.do...while是先执行后判断
public static void main(String[] args) { int a =0; //判断a&lt;0不会被执行了 while (a&lt;0){ System.out.println(a); a++; } System.out.println("================"); //do while 至少被执行一次 do { System.out.println(a); a++; }while (a&lt;0); } Do...while总是保证循环体会被至少执行一次，这是他们的主要差别
for循环
在java5中引入了一种主要用于数组的增强for循环
虽然所有循环结构都可以用while或do while表示但是，java提供俩人另一种语句 --for循环 使一些需循环节构变得更为简单
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e49a9866a5dae9b92b279cf1e6edac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb4cf75ea51b795c6d83fbd14fef010/" rel="bookmark">
			VMware安装Windows11专业版详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware16安装Windows11详细教程 0.准备内容1.下载安装VMware162.下载windows11镜像文件3.创建新的虚拟机4.安装Windows115.安装VMware Tools 0.准备内容 VMware 16Windows 11镜像 1.下载安装VMware16 进入官网下载地址：https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html
界面如下，点击下载 Workstation 16 Pro for Windows；
下载完成，打开文件按步骤进行安装；
我的电脑已经安装了VMware，这里是使用我的虚拟机进行安装演示，地址我就选择了默认地址，可以更改到其他的盘；
我选择了不加入VMware客户体验提升计划，可以随意；
等待安装完成；
使用VMware需要密钥，点击许可证，也可以选择完成，后续在软件界面输入许可证密钥；
输入密钥，自行搜索；
之后就可以愉快地使用了。
2.下载windows11镜像文件 镜像下载地址：Microsoft官网下载
我要安装的版本为Windows11专业版，所以选择了第一个，只想安装家庭版可以直接选择第二个，下载可能有点慢，耐心等待；
第一个下载项是多个系统版本的集成，具体包括了Windows 11 家庭版、家庭单语言版、教育版、专业版、专业教育版、专业工作站版；
3.创建新的虚拟机 打开VMware，选择创建新的虚拟机，没有主页选项卡的也可以选择左上角文件 —&gt; 新建虚拟机，或者使用快捷键Ctrl+N；
选择典型，下一步；
这里选择稍后安装操作系统，下一步；
选择客户机操作系统为Windows，选择版本为Windows 10 x64，下一步；
更改虚拟机名称为Windows11，更改位置为G:\Windows11，位置名称可以随便更改，这里我的G盘实际上是固态硬盘；
设置最大磁盘大小为60G，可以视情况而更改，将虚拟磁盘拆分成为多个文件，进行下一步；
选择完成；
在我的计算机列表里已经有了Windows11，先别着急开启计算机，选择编辑虚拟机设置；
选择选项；
选择访问控制，为虚拟机加密，不加密就添加不了可信平台模块，后续可能会安装不了Windows11；
加密完成再选择高级，启用安全引导；
选择硬件，点击下面的添加；
添加可信平台模块，点击完成；
选择CD/DVD，添加ISO镜像文件，文件地址为下载Windows11镜像的地址；
设置内存，为4G，处理器为4，最后点击确定，完成虚拟机设置。
4.安装Windows11 开启虚拟机，出现这个界面，一定要快速按回车键；
选择我没有产品密钥；
选择专业版，可以选择其他的版本；
这里选择仅安装；
下面就是正常设置windows了，这里就不多赘述了。
5.安装VMware Tools 只有在VMware虚拟机中安装好了VMware Tools，才能实现主机与虚拟机之间的文件共享，同时可支持自由拖拽的功能，鼠标也可在虚拟机与主机之间自由移动（不用再按ctrl+alt），且虚拟机屏幕也可实现全屏化；
安装完虚拟机下面会提示安装VMware Tools，单击安装Tools，或者在上面菜单栏找到 虚拟机—&gt;安装VMware Tools；
右下角会出现这个，点击，如果没来得及点击可以打开计算机，双击此驱动；
新安装成功的Windows11中，桌面没有显示计算机，设置方法：右键桌面—&gt;个性化—&gt;主题—&gt;桌面图标设置—&gt;选择计算机；
点击运行setup64.exe；
选择典型安装，然后点击安装，安装完成后重启。
结束啦！！！撒花 ~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af001cf2cbfe3e8758c6ceecb9eff1c/" rel="bookmark">
			CL210红帽OpenStack平台架构--介绍容器服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎹 个人简介：大家好，我是 金鱼哥，CSDN运维领域新星创作者，华为云·云享专家，阿里云社区·专家博主
📚个人资质：CCNA、HCNP、CSNA（网络分析师），软考初级、中级网络工程师、RHCSA、RHCE、RHCA、RHCI、ITIL😜
💬格言：努力不一定成功，但要想成功就必须努力🔥
🎈支持我：可点赞👍、可收藏⭐️、可留言📝
文章目录 📜容器服务介绍📜容器镜像和注册📑稳定📑安全📑生命周期管理📑服务位置📑可伸缩性 📜填充本地容器仓库📜容器的命令📑docker ps📑docker stats📑docker images📑docker inspect📑docker logs📑docker exec 📜日志文件和配置文件📑日志文件位置📑配置文件位置 📜课本练习 💡总结 📜容器服务介绍 与红帽OpenStack平台的早期版本不同，后期版本使用容器来运行服务。容器化的体系结构确保每个OpenStack服务与主机隔离。主要的OpenStack服务都使用容器。容器是使用从Red Hat客户门户中提取的镜像构建的。容器服务管理由docker命令处理，替换systemd命令。底层Linux系统继续使用systemd命令。容器通过拉取新镜像并替换现有镜像来更新，并且使用Kolla工具集构建这些容器。
📜容器镜像和注册 Red Hat OpenStack Platform 12是第一个实现了容器化控制平面的发行版。每个服务容器运行一个独立的堆栈，不依赖于其他容器。运行容器化OpenStack服务的一些主要好处如下所述：
使用容器化控制平面服务的好处
📑稳定 因为每个服务容器都是隔离的，不依赖于其他容器，所以它减少了单个服务失败时的级联失败。
📑安全 容器镜像在设计上是不可变的。通过从原始镜像重新部署，可以很容易地重新构建损坏或修改的容器。
📑生命周期管理 管理这些服务容器的生命周期很容易，因为它们是独立的单元。因为可以独立地对每个服务容器进行升级和回滚，所以您不必担心在升级或回滚时破坏依赖关系。
📑服务位置 管理员可以根据需要在主机之间移动服务容器。
📑可伸缩性 每个服务容器都可以快速而轻松地伸缩。目前，由于对主机文件系统和网络的潜在依赖关系，只能在单个节点上放置一个服务容器实例。
推荐使用在undercloud上确认的本地仓库方法。在安装undercloud时，镜像仓库在端口8787上被确认。该部署同步来自远程仓库的镜像，并将它们推到docker-distribution服务。
(undercloud) [stack@director ~]$ systemctl status docker-distribution.service ● docker-distribution.service - v2 Registry server for Docker Loaded: loaded (/usr/lib/systemd/system/docker-distribution.service; enabled; vendor preset: disabled) Active: active (running) since Mon 2020-10-12 16:12:56 UTC; 1 day 10h ago Main PID: 1418 (registry) Tasks: 7 CGroup: /system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8af001cf2cbfe3e8758c6ceecb9eff1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3674eccf77e3b0c2ea80e8248a5731f/" rel="bookmark">
			warn - Attempted to load @next/swc-darwin-x64, but it was not installed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 failed-loading-swc | Next.js
解决方式：
在命令行直接输入npm i --force
就不会报错了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c634137b7630f6283eebf9b14fe07bf2/" rel="bookmark">
			数据库里的DATETIME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 topicDate DATETIME这个值在mysql8.0以上对应着的pojo包里面的类的属性值不再是date而是localDate 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cb1ce4d5d7393f8580f3a4fd020fdb/" rel="bookmark">
			java多态性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象的特征之三：多态性
对象的多态性：父类的引用指向子类的对象
父类名 对象名=new 子类名（）；
多态的使用：当通过多态性创建的对象调用子类与父类同名同形参的方法时，实际执行的是子类重写父类的方法--------虚拟方法调用
多态性的使用前提：1、类的继承关系
2、方法的重写（经常在方法重写情况下用多态性）
对象的多态性只适用于方法不适用于属性（属性是谁的对象调用的就是谁的属性）
多态是运行时行为
public class duotai { public static void main(String[] args) { duotai c=new duotai(); c.fun(new dog()); c.fun(new cat()); } public void fun(Animal animal){ animal.eat(); animal.shout(); } } class Animal{ public void eat(){ System.out.println("动物叫"); } public void shout (){ System.out.println("动物吃东西"); } } class dog extends Animal{ public void eat(){ System.out.println("汪汪汪"); } public void shout(){ System.out.println("啃骨头"); } } class cat extends Animal{ public void eat(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65cb1ce4d5d7393f8580f3a4fd020fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71cc91a0ba4a2aca0c4720b0a740f529/" rel="bookmark">
			ubuntu18.04 安装annconda后 python版本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先完成安装anaconda 参考教程如下：Ubuntu18.04 安装 Anaconda3
2、完成anaconda 环境配置 终端输入：
echo 'export PATH="~./anaconda3/bin:$PATH"' &gt;&gt; ~/.bashrc source ~/.bashrc 终端输入：
python --version 显示如下：Python 3.6.5 :: Anaconda, Inc.
此时python 版本默认为annconda 的版本 Python 3.6.5
3、更改python版本 如何手动更改系统默认Python版本,比如想要切换到系统自带的python2.7 1. 首先关闭配置的默认Python 打开~/.bashrc
$ sudo gedit ~/.bashrc 将~/.bashrc 中的 export PATH=“~./anaconda3/bin:$PATH” 删除或者注释掉
export PATH="~./anaconda3/bin:$PATH"	删除或者注释掉默认python 环境配置 2. 添加python的版本链接 利用sudo update-alternatives添加Python版本链接
(user为自己的用户名)
$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1 $ sudo update-alternatives --install /usr/bin/python python /home/user/anaconda3/bin/python 2 将系统自带的python2.7设置优先级为1
将anaconda3 的pyhton 优先级设置为2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71cc91a0ba4a2aca0c4720b0a740f529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa23723ee3f72f0611d576f4dcecffb/" rel="bookmark">
			ARM调试(2):在keil利用指令跟踪宏单元(ITM)重定向printf，并完成scanf实现数据双向交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在keil利用指令跟踪宏单元(ITM)重定向printf，并完成scanf实现数据双向交互 文章目录 在keil利用指令跟踪宏单元(ITM)重定向printf，并完成scanf实现数据双向交互1. 开发环境2. ITM简介和硬件需求2.1 技术简介2.1 硬件支持2.1.1 首先我们知道，对于使用不一样的调试器或下载器，我们常用的ARM下载方式有三种接口：2.1.2 调试接口大概分为三种，如图：2.1.3 简化的下载接口引脚的说明2.1.3 ITM需要多接一根线 3. 用ST-LINK v2来实现ITM3.1 KEIL中配置3.2 mcu内部程序printf重定向-使用标准c库3.3 通过KEIL的Debug（printf）Viewer查看打印信息 4. 利用JLINK调试器配置ITM输出4.1 KEIL 配置4.2 mcu程序4.3 jlink不能像stlink那样调试成功的缘由4.4 用jlink来配置mcu寄存器`0xE0042004U `的bit5为14.5 解释为什么ST-LINK不需要设置寄存器`0xE0042004U ` 5. KEIL 实现scanf，完成双向通信6. 升级双向通信功能7. 针对JLINK和ST-LINK仿真器实现ITM的说明8 利用ITM调试实现逻辑分析仪功能其他：参考声明 声明：由于STM32有很好的配套软件，如cubeMX,因此软件替我们做了很多事，这将导致不能对ITM进行一个全面的了解，当我们需要移植到其它ARM上难以成功，因此本文选取了GD32来实现ITM，完整的展现配置的原理和过程，同时对JLINK和ST-LINK的不同配置方法进行叙述，由于能力有限，难免会有理解的错误，若发现错误请留言，让我在分享中得到收获，谢谢。 1. 开发环境 系统：win10IDE：keil5开发板：GD32F450调试器：J-LINK V10和st-link v2两种方案分别实现 2. ITM简介和硬件需求 平时调试代码的时候大家都喜欢用printf函数来输出一些打印信息，来提示自己代码的执行情况，而最常用的方法就是将printf映射到串口等外设资源上，可是当串口被占用的时候，就显得无能为例了，本文通过GD32来介绍通过调试口，只需多利用ARM芯片的一个引脚，借助仿真器，不使用其他任何芯片外设达到printf输出的一种方法-ITM。
2.1 技术简介 ITM：Instrumentation Trace Macrocell，指令跟踪宏单元。ITM 的一个主要用途，就是支持调试消息。
在《ARM Cortex-M3与Cortex-M4权威指南》的这本书的第18章2节有对ITM的介绍和实现的完整叙述，本节总结如下：
在Cortex-M3、Cortex-M4、Cortex-M7系列MCU中，内核的调试组件有一个仪器跟踪宏单元(ITM) 。ITM是处理器中非常有用的调试特性，ITM中存在32个激励端口寄存器，而对于这些寄存器的写操作会产生通过单针串行线(SWV)接口或多针跟踪接口输出的跟踪包。利用ITM这个特性，将printf重定向到ITM，就可以通过SWV接口输出。而SWV接口输出对应的引脚就是SWO引脚。
ITM 包含 32 个刺激(Stimulus)端口，允许不同的软件把数据输出到不同的端口，从而让调试主机可以把它们的消息分离开，这样的好处是可以将printf分组，通过上位机来监听不一样的端口来实现过滤。与基于 UART 的文字输出不同，使用 ITM 输出不会对应用程序造成很大的延迟，在 ITM 内部有一个 FIFO，它使写入的输出消息得到缓冲。
为了让更多人理解ITM模块，怎样输出调试信息，这里再深入说明一下(声明：下面这部分知识和图片取自别的文章1)：
TPIU：Trace Port Interface Unit，跟踪端口接口单元。ITM模块属于Cortex-M内核调试组件中的一部分内容，ITM输出的消息被送往 TPIU(跟踪端口接口单元),这里的TPIU，对应SWO串行线输出。这里TPIU要和上面说的【ITM 包含 32 个刺激(Stimulus)端口】区分开来。ITM的32个刺激(Stimulus)端口并不是要对应32个SWO引脚,32个刺激端口调试信息可通过一个SWO引脚输出，下面详细讲述。 注意：ITM是内核的功能，因此需要处理器带这个组件，比如你的芯片是 Cortex-M0或M0+的ARM内核，是无法不支持ITM，对于这种无法支持ITM的，我们有的可以采用半主机(semihosting)模式进行调试，后面有时间我会讲解半主机调试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa23723ee3f72f0611d576f4dcecffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691211a3ce88b18fe7d453481454ef77/" rel="bookmark">
			pinia快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pinia快速入门 pinia文章目录 pinia快速入门概念入门状态更改 actionsgetters解构保持响应式不同的模块调用60s倒计时示例 总结 概念 Pinia是一个用于Vue的状态管库, 类似于Vuex, 是Vue的另外一种状态管理方案;
Pinia优势
Vue2和Vue3都支持不需要嵌套模块, 符合Vue3的Composition api, 让代码更加扁平化, 没有命名空间的模块完整的TypeScript支持代码更加简洁, 可以实现很好的代码自动分割抛弃了Mutations的同步操作, 只有state, getters,和actions 入门 以Vue3为主
安装Pinia yarn add pinia # or with npm npm install pinia 创建一个pinia并使用 import { createPinia } from 'pinia' app.use(createPinia()) 创建一个默认的store 如: 「countDown.ts」 defineStore(param1, param2) param1 相当于为容器起一个名称，注意: 这个名字必须是唯一的, 不能重复param2 是一个对象, 对象中有几个参数 state: () =&gt; ({}),getters: {},actions: {} import { defineStore } from 'pinia'; interface todosModel { id: number; text: string; isFinished: boolean; } export const useCountDownStore = defineStore('countDown', { state: () =&gt; ({ num: 1, todos: [] as todosModel[], }), getters: {}, actions: { }, }); 新建CountDown.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691211a3ce88b18fe7d453481454ef77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad9628c4f693bd05b1d8cf7ef3a1aa2/" rel="bookmark">
			基于el-table的批量删除，点击一行，自动选择或取消当行复选框。报错415，增加‘Content-Type‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个需求是基于el-table的批量删除功能。其中有几个点记录一下 1、点击一行，自动选择或取消当行复选框。 只需要增加 @row-click="clickRow" ref="moviesTable" clickRow(row) { this.$refs.moviesTable.toggleRowSelection(row) }, 2、批量删除代码。总是报错415。写成axios.delete(url,{data:{param:xx}}) 格式。 增加'Content-Type': 'application/json' handleDel() { let row = this.currentRow console.log(row, 'row') if (!row) { this.$message({ message: '请选择要删除的一行数据！', type: 'error' }) return } const reqData = row.map((item) =&gt; item.Id) var par = { ids: `${reqData}` } console.log(reqData, 'reqData') this.$confirm(`确定删除选中的 ${row.length} 项吗？`, '提示', {}).then(() =&gt; { this.$api.DeleteSupplement(par).then((res) =&gt; { if (res.data.success) { this.$message({ message: '删除成功', type: 'success', duration: 5000 }) this.getData() } else { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aad9628c4f693bd05b1d8cf7ef3a1aa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cafce87d7452f6ae6afa84e73ff313/" rel="bookmark">
			android 混淆报错记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Attempt to invoke virtual method 'int java.lang.Integer.intValue()' on a null object reference
解决方案：fastjson混淆时， 对应的实体类中使用了Integer去接收int类型，所以报错。将实体类中的Integer改为int类型即可
2.混淆代码后Gson 解析为null
现象：网络请求返回的值通过gson转成对象后，所有字符串都未null
解决方案：将对象的混淆配置 -keep class xxx.xxx.**{*l;} 使用.**{*l;}进行混淆配置
解决方案2：将实体类都 implements Serializable， 统一使用下面的混淆方式
-keepnames class * implements java.io.Serializable #保持 Serializable 不被混淆 iermu -keepclassmembers class * implements java.io.Serializable { #保持 Serializable 不被混淆并且enum 类也不被混淆 iermu static final long serialVersionUID; #iermu private static final java.io.ObjectStreamField[] serialPersistentFields; #iermu !static !transient &lt;fields&gt;; #iermu !private &lt;fields&gt;; #iermu !private &lt;methods&gt;; #iermu private void writeObject(java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1cafce87d7452f6ae6afa84e73ff313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83f1a82066d25816be0cf8d47cf613c/" rel="bookmark">
			Docker本地镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker本地镜像 项目一 Docker镜像管理
任务一 Docker Registry本地私有仓库搭建
1、拉取Registry镜像：
2、启动Docker Registry
使用Docker官方提供的Registry镜像就可以搭建本地私有镜像仓库。
3、重命名镜像
推送到本地私有镜像仓库的镜像名必须符合“仓库IP:端口号/repository”的形式，因此需要按照要求修改镜像名称。
$ docker tag hellodocker:latest localhost:5000/myhellodocker 4、推送镜像
本地私有镜像仓库搭建并启动完成，同时要推送的镜像也已经准备就绪后，就可以将指定镜像推送到本地私有镜像仓库。
$ docker push localhost:5000/myhellodocker 在宿主机浏览器上输入http:/localhost:5000/v2/myhellodocker/tags/list查看:
在推送镜像的过程中，还将数据映射到了本地磁盘，因此可以在本地磁盘的/mnt/registry/docker/registry/v2/repositories目录（即-v参数指定的宿主机数据映射位置）进行查看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62a759bd3e367dc10634bb5615f16ab/" rel="bookmark">
			IP与MAC地址绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常有人换网络地址，给维护带来一些麻烦。
今天绑定IP与MAC，在H3C S3100上，后续再对其他的交换机的绑定。
在接入交换机上绑定，就近原则。
1、限制具体的计算机，但可以换IP
有些计算机是可以换IP地址的，比如需要变换IP地址进行系统测试、有的是接笔记本电脑的等等，但是要对MAC地址进行限制。
interface Ethernet1/0/19 description BiJiBenDianNao port access vlan 29 arp filter binding X.Y.Z1.M1 1234-5678-9abc arp filter binding X.Y.Z2.M2 1234-5678-9abc arp filter binding X.Y.Z3.M3 1234-5678-9abc arp filter binding X.Y.Z3.M3 XXXX-YYYY-ZZZZ 2、限制MAC地址
只能是指定MAC地址的计算机上网，可以换IP。
interface Ethernet1/0/39 description WebSerice1 port access vlan 9 ip verify source mac-address port-security max-mac-count 2 ip source binding mac-address 1111-2222-3333 ip source binding mac-address aaaa-bbbb-cccc 3、限定IP和MAC地址
只能是指定MAC地址的计算机上网，而且必须是对应的IP才可以正常上网
interface Ethernet1/0/29 description ShiPinHuiYi port access vlan 29 ip verify source ip-address mac-address port-security max-mac-count 2 ip source binding ip-address x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62a759bd3e367dc10634bb5615f16ab/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/142/">«</a>
	<span class="pagination__item pagination__item--current">143/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/144/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>