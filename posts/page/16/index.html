<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89fc80633bd71c83ff8f73147ff212c1/" rel="bookmark">
			实现async await
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要自己实现 async 和 await 函数，需要理解 async 和 await 的底层原理，以及如何使用 Promise 对象来管理异步操作。
下面是一个简化版的 async 和 await 的实现：
function myAsync(fn) { return function() { return new Promise((resolve, reject) =&gt; { const generator = fn.apply(this, arguments); function handleResult(result) { if (result.done) { resolve(result.value); } else { Promise.resolve(result.value) .then( res =&gt; handleResult(generator.next(res)), err =&gt; handleResult(generator.throw(err)) ); } } handleResult(generator.next()); }); }; } function myAwait(promise) { return promise.then(res =&gt; { return { value: res, done: false }; }, err =&gt; { return { value: err, done: true }; }); } 上述代码中，myAsync 函数是用来包装异步函数的，它返回一个新的函数。新的函数内部创建了一个 Promise 对象，并在异步函数中使用 generator 来管理执行流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89fc80633bd71c83ff8f73147ff212c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2093f11db42c49030381b1a7b7f2cda/" rel="bookmark">
			mysql关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下是MySQL中的所有关键字，以及它们的作用说明：
数据定义语句（DDL）：
ADD：用于向表中添加列、索引或约束。ALTER：用于修改数据库、表、列等的结构。ANALYZE：用于分析和收集表和索引的统计信息。CHANGE：用于修改表中的列的名称和数据类型。CHECK：用于定义表级约束。COLUMN：用于指定列的名称、数据类型和约束。CREATE：用于创建数据库、表、视图、索引等。DATABASE：用于创建数据库。DROP：用于删除数据库、表、视图、索引等。INDEX：用于创建索引。MODIFY：用于修改表中列的数据类型和约束。RENAME：用于重命名数据库、表、列等。TABLE：用于创建表。TRUNCATE：用于清空表数据。UNIQUE：用于创建唯一性约束。 数据操作语句（DML）：
DELETE：用于从表中删除数据。FROM：用于指定查询的数据源表。INSERT：用于向表中插入数据。SELECT：用于从表中检索数据。UPDATE：用于更新表中的数据。 数据控制语句（DCL）：
GRANT：用于授予用户权限。REVOKE：用于撤销用户权限。 事务控制语句（TCL）：
COMMIT：用于提交事务。ROLLBACK：用于回滚事务。SAVEPOINT：用于设置保存点。SET TRANSACTION：用于设置事务属性。 流程控制语句（Flow Control）：
CASE：用于在SELECT语句中实现条件逻辑。IF：用于实现条件判断。ELSE：用于在IF语句中定义其他条件。END：用于结束代码块。FOR：用于循环遍历查询结果集。LOOP：用于循环执行一段代码。REPEAT：用于重复执行一段代码直到满足条件。WHILE：用于在满足条件时重复执行一段代码。 查询优化器提示（Optimizer Hint）：
USE：用于指定要使用的索引。FORCE：用于强制查询优化器使用指定的执行计划。 其他常用关键字：
ALL：用于指定查询所有的列或行。AND：用于指定多个条件的逻辑与关系。AS：用于为列或表起别名。ASC：用于指定按升序排序。AUTO_INCREMENT：用于指定自动增长的列。BETWEEN：用于指定一个范围。BY：用于指定排序的列或表达式。CHARACTER：用于指定字符集。CONSTRAINT：用于定义表级约束。DISTINCT：用于去除重复的行。EXISTS：用于检查子查询的结果是否存在。FOREIGN KEY：用于定义外键约束。GROUP BY：用于按照指定的列对查询结果进行分组。HAVING：用于对分组进行过滤。IN：用于指定一个值的集合。INNER JOIN：用于根据条件连接两个或多个表。INTO：用于指定插入数据的目标表。IS：用于判断是否满足条件。JOIN：用于根据条件连接两个或多个表。LEFT JOIN：用于从左表中选择所有的记录，以及与右表匹配的记录。LIKE：用于模糊匹配。LIMIT：用于限制查询结果的数量。NOT：用于否定条件判断。NULL：用于表示空值。ON：用于指定连接条件。OR：用于指定多个条件的逻辑或关系。ORDER BY：用于对查询结果进行排序。OUTER JOIN：用于返回左表和右表中的所有记录。PRIMARY KEY：用于定义主键约束。REFERENCES：用于定义外键约束。RIGHT JOIN：用于从右表中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315c87e7b9c6adeedb7aa8957ddfd55d/" rel="bookmark">
			数据结构和算法-算法的基本概念和时间复杂度和空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 算法的基本概念总览什么是算法算法的特性好算法的特质小结 算法的时间复杂度如何评判算法时间开销计算算法时间复杂度忽略表达式的某些部分是否要一行一行数代码 小练习1小练习2最坏时间复杂度和平均时间复杂度小结 算法的空间复杂度程序运行时的内存需求函数递归的空间复杂度小结 算法的基本概念 总览 什么是算法 算法就是处理的步骤
算法的特性 程序可以一直运行，所以说是无穷的
不能出现两种不同的结果出来，必须对于相同输入只有相同输出
如下图中出现两个相等时可做一个处理使得结果唯一
注意输入和输出的个数
只要一个特性不满足，就不能称之为算法
好算法的特质 正确性即结果是正确的
可读性即有些注释啥的，让别人能看懂
小结 算法的时间复杂度 如何评判算法时间开销 如果让算法在机器上运行，然后在结束后再统计其时间，那么会由于机器不同，执行算法的语言不同 ，编译程序的效率会有不同的结果
并且由于某些算法是不能等运行后再去统计其运行时间的，所以由算法先运行再去统计运行时间是不合理的
计算算法时间复杂度 当统计每条语句执行的次数时，得到为3n+3的算法时间复杂度
当程序语句过多时，算法时间复杂度表达式过于复杂时，该如何处理
忽略表达式的某些部分 可以通过洛必达证明
递增大小，对应的图
记住口诀 常对幂指阶
注意如何计算的和大O的含义
计算规则
是否要一行一行数代码 顺序执行的代码只会影响常数项，所以不考虑
而循环里的多个操作也是影响n的系数，所以不考虑，只需考虑循环的一个操作执行次数即可
当有多层循环是，表层循环对于深层循环可忽略不计
所以考虑最深层循环的执行次数即可
小练习1 首先找到循环终止条件，在计算循环次数
小练习2 输入的查找的数不一样，此时对于的循环不一样，一般计算的时间复杂度都是平均时间复杂度
最坏时间复杂度和平均时间复杂度 小结 算法的性能问题只有在n很大才会暴露出来
算法的空间复杂度 程序运行时的内存需求 大小固定，与问题规模无关就是说所占空间大小不会随着输入变化而变化
原地工作即空间复杂度为常数
此时当n趋向很大时，可忽略常数级，占空间与问题规模相关变量有关
函数递归的空间复杂度 每层调用中要用到的参数和局部变量需要增加存储空间来存储
可参考函数调用栈存储保存恢复函数栈信息的内容和相关该函数的局部变量和参数等内容
每层递归进入函数后需要的空间是固定的（下图是固定的），作为系数可忽略
此时递归每层调用函数的所占空间与传入的参数有关，所以需要的空间不是固定的
小结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf30ed4c4da28a102df407706bdaf55/" rel="bookmark">
			数通基础知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基础概念 1.1. 通信基本原理 通信基本原理涉及信息的生成、编码、传输和解码的过程。在实际应用中，例如电话通信，信息通过话筒转换成模拟信号，经过传输线路传递到接收端，再由耳机解码还原为可理解的信息。
1.2. 信道和信号 信道类型应用： 单向通信如广播电视、双向通信如电话通话。噪声和干扰应用： 无线通信中，天气、建筑物和其他设备的干扰会影响信号质量，而纠错编码可提高信息传输的可靠性。 2. 数字通信基础 2.1. 数字信号和调制 数字信号应用： 数字音频、视频、数字通信等。调制技术应用： 调频调制在广播中的应用，调幅调制用于AM广播。数字通信中，二进制数字通过调制转换成模拟信号传输。 2.2. 信道编码与解码 奇偶校验应用： 用于检测和纠正数据传输中的错误，例如在计算机内存中的数据传输。汉明码应用： 在存储介质和通信中常用于错误检测和纠正，如在 CD、DVD 中。 2.3. 多路复用技术 时分复用应用： 电话系统中的时间分割多路复用，允许多个用户在同一信道上交替通信。频分复用应用： 无线通信中的频率分割多路复用，允许多个用户在不同频率上同时通信。 3. 网络基础 3.1. OSI 模型 物理层应用： 以太网、USB。网络层应用： IP 地址的分配与路由，负责数据包在网络中的传输。应用层应用： HTTP 协议用于网页传输，FTP 用于文件传输。 3.2. 网络协议 TCP/IP 协议族应用： 互联网通信的基础协议，确保数据在网络中的可靠传输。IP 地址和子网划分应用： 网络设备的唯一标识和网络管理，IPv6地址的逐渐推广。 3.3. 路由与交换 路由器和交换机应用： 在网络中转发数据包和建立通信路径，确保数据从源到目的地的有效传输。 4. 无线通信基础 4.1. 无线信道 无线传播方式应用： 无线电广播、移动通信。多径效应和多普勒效应应用： 在无线通信中影响信号传播的因素，例如在雷达系统中。 4.2. 无线网络和协议 无线局域网（WLAN）应用： Wi-Fi 技术，使设备无需物理连接即可互相通信。移动通信网络应用： 2G、3G、4G、5G 移动通信标准，提供不同速度和服务质量的通信。 5. 网络安全基础 5.1. 基本概念 机密性、完整性、可用性应用： 网络安全策略的基石，确保信息不被未经授权的访问、修改或破坏。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf30ed4c4da28a102df407706bdaf55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166b080926bbb02859292b005923af01/" rel="bookmark">
			C#设计模式之策略模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		策略模式简介 策略模式在设计模式中属于对象行为型模式，它的意图是定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。策略模式使得算法可独立于使用它的客户而变化。
策略模式的图解如下所示：
示例 本文通过一个简单的例子来向大家介绍C#如何使用策略模式。本文以出行这个行为举例，出行我们可以使用多种方式，比如自己开车、乘坐公交、骑自行车等。
1、定义策略接口 public interface ITravelStrategy { public void Print(); } 我们定义了一个出行策略接口，只定义了一个Print方法。
2、实现具体策略类 public class Car : ITravelStrategy { public void Print() { Console.WriteLine("乘坐汽车出行\r\n"); } } public class Bike : ITravelStrategy { public void Print() { Console.WriteLine("骑自行车出行\r\n"); } } public class Bus : ITravelStrategy { public void Print() { Console.WriteLine("乘坐公交出行\r\n"); } } 定义了三个具体策略类分别为Car、Bike与Bus，都实现了ITravelStrategy接口，它们的实现是不同的。
3、实现上下文类 public class TravelContext { private ITravelStrategy _strategy; public TravelContext(ITravelStrategy strategy) { _strategy = strategy; } public void SetStrategy(ITravelStrategy strategy) { _strategy = strategy; } public void ExecuteStrategy() { _strategy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166b080926bbb02859292b005923af01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b0ad99f53d41fca0123ab0c7dbe0fea/" rel="bookmark">
			计算机毕业设计选题推荐 毕设选题建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 计算机毕设选题推荐2 开题指导3 最后 0 前言 大家好！大四的同学们毕业设计即将开始了，你们做好准备了吗？
学长给大家精心整理了最新的计算机毕业设计选题，希望能为你们提供帮助。如果在选题过程中有任何疑问，都可以随时问我，我会尽力帮助大家。
在选择毕业设计选题时，有几个要点需要考虑。首先，选题应与计算机专业密切相关，并且符合当前行业的发展趋势。选择与专业紧密结合的选题，可以使你们更好地运用所学知识，并为未来的职业发展奠定基础。
要考虑选题的实际可行性和创新性。选题应具备一定的实践意义和应用前景，能够解决实际问题或改善现有技术。同时，可以尝试一些有创新思维和研究价值的选题，以展示你们的独立思考和解决问题的能力。
此外要根据自身的兴趣和专长选择题目。选择一个你们感兴趣且擅长的选题，可以提高你们的研究热情和积极性，使得整个毕业设计过程更加愉快和有成就感。
最后不要忘记与导师和同学们进行充分的交流和讨论，他们可以提供宝贵的指导意见和建议。同时，与同学们分享选题的想法和讨论，可以获得更多的观点和启发。
总之我希望这些毕设选题整理对大家有所帮助。如果在选题或其他方面需要任何帮助，可以随时向我提问。祝愿大家顺利开始毕业设计，取得优秀的成果！
1 计算机毕设选题推荐 人物头像的卡通化算法设计与实现人脸表情分类算法设计与实现人脸属性分类算法设计与实现人脸特征提取算法研究与实现基于深度学习的视频中物体快速搜索算法基于深度学习的图像检索算法研究基于深度学习的图像分割算法研究基于深度学习的网络游戏流失玩家预测算法研究基于机器学习的短时交通流预测算法的研究与实现基于机器学习的问答评价算法设计基于机器学习的问答推荐算法设计基于增强学习的物流优化算法研究基于深度网络的年龄预测算法研究基于深度网络的RGBD图像分割算法研究基于对抗神经网络的图像超分辨率算法研究基于记忆网络的视觉逻辑推理算法的研究与实现基于贝叶斯网络的因果关系研究及算法包实现基于端到端神经网络模型的词义消歧算法研究基于社交网络结构的社会推荐算法研究多层社交网络的链路预测算法研究社交网络中的位置推荐算法研究社会网络下算法博弈的研究与实现基于反向推荐的个性化推荐算法研究基于推荐算法的商品流行性预测算法研究基于轨迹数据的最优路径推荐算法设计与实现基于泊松分解的推荐算法研究与应用基于图像的人群聚集检测算法研究与实现图像去雾算法的研究与实现移动平台图像分类算法的研究与实现基于哈希的图像分类算法研究基于CNN的图像去噪算法的实现图像的艺术风格渲染算法设计与实现基于视频图像的目标跟踪算法研究与C++实现基于视频行为分析的暴力事件检测算法研究与C++实现基于文本的网络用户分析算法设计与实现基于关键词与同义词的主观题评分技术研究基于流量特征的主机安全状态评估研究与实现基于深度学习的公共场所客流运动模式分割算法研究假期高速公路交通流量预测算法的设计与实现基于Android平台的心律异常检测的算法实现基于Matlab的ECG心律不齐分类算法的程序实现基于用户评论属性的隐私保护算法研究与分析基于硬件加速的室外场景光照估计与渲染算法研究与实现基于隐私保护的数据挖掘算法研究基于Matlab的全景图片生成算法实现基于数据主权区块链的共识算法的研究智能+教育：知识点多标签分类算法设计和实现黑白字体彩色艺术化算法设计与实现基于XGBoost的网络游戏流失玩家预测算法研究基于rank-order的脉冲神经网络学习算法研究基于虚拟现实技术和强化学习的机器人控制算法人群行为建模与仿真基于手机信令的旅游人口建模与分析基于RGBD相机的多视角人体姿态重建基于RFID标签的行为识别技术及实现基于神经网络的弱监督物体检测神经网络模型基于数据内在结构特征的哈希检索方法一种深度神经网络的FPGA加速引擎基于弱监督深度学习图像识别研究物体检测算法研究轻量级JavaWeb开发框架的设计与实现多源数据的图结构学习研究科学家合作网络结构演化研究0-1背包算法的实现与应用多视角聚类算法研究自步多任务多视图聚类算法研究群智计算算法的研究相容图(pcg)构造算法研究三维模型的网格简化算法研究图像去镜面高光算法研究与C++实现图像去雨算法的研究与实现平面图上cyclepacking问题的核心化算法研究基于平衡树的RFID系统密钥更新算法基于生成树的复杂网络抽样算法研究针对网络评论的分类算法研究机器阅读算法的可解释研究边缘计算任务调度算法研究并行计算若干经典算法的设计与实现属性增强的概念图匹配算法研究与应用FP-tree关联规则算法的实现与应用面向M2M网内存储控制算法研究与仿真面向网络丢包环境的视频编码优化控制算法生成式对抗网络算法及应用研究基于FPGA的快速矩阵运算实现自重多核学习研究初等数学知识库的研究与构建图像中积分的识别与求解一种嵌入式深度卷积神经网络推理引擎选址问题的防策略机制设计信息骨架研究与应用基于共享结构的简单-复杂活动协同识别贝叶斯张量分解信息安全知识图谱的设计与实现基于矩阵分解的子空间聚类研究 学长的作品示例：
基于python的邮件分类系统文本情感理解技术研究干细胞分裂与生长跟踪研究行为活动理解中的弱监督学习研究气候环境因素对老年COPD患者的影响分析研究基于深度学习的车牌识别系统设计与实现深度卷积神经网络及其在人脸识别中的应用深度增强学习理论研究及其在视频游戏上的应用基于深度学习的机器人室内场景识别基于深度学习的哈希方法在多粒度图像检索中的研究与实现基于深度学习的网站验证码识别系统设计与实现张量分解在生物信息学的应用基于点过程的产品流行性预测基于循环神经网络的静态代码分析社交网络用户关系研究在线社交网络中用户兴趣演化分析与建模研究社交网络上信息传播行为分析与计算机模拟研究心电图数据研究轨迹数据的语义表征与学习基于深度强化学习的NPC自主训练模型构建的实现基于LSTM完成对英文词性标注的设计与实现基于机器学习的中文情感识别研究基于深度神经网络的高质量词向量生成方法研究基于地图数据的新加坡出租车接送乘客轨迹可视化及需求预测医疗健康档案信息可视化系统设计与实现活动轨迹的语义表达与搜索技术研究基于电信大数据的自我中心网络可视化研究基于DCGAN的cifar10数据集生成设计与实现城市自行车的出行行为分析商场中精确定位用户所在店铺基于出租车轨迹数据的可视化研究学生行为习惯“画像”可视分析平台基于地图API的高铁运行地图的设计与实现基于大数据技术的职业岗位画像设计与实现基于协同过滤的用户移动轨迹信息预测研究可视化展示数据处理中心的设计和实现基于新浪微博的分布式爬虫以及对数据的可视化处理基于公共自行车数据的城市居民职住地分析动态网络上的表征学习基于社交网络交换的物品分配问题基于复杂网络的QQ社交网络的用户关系研究基于复杂网络的城市地铁交通网络研究Internet自治层网络的重要结构特征研究基于深度学习的心律失常的自动分类基于深度学习的糖尿病视网膜疾病诊断研究与实现基于深度学习的人物头部着装分类研究与实现基于深度学习的人脸检测与识别系统设计与实现基于深度学习的情感分类基于深度学习的场景分类研究基于深度神经网络的标题分类研究基于DeepLearning的图片分类基于深度学习的图像检索基于深度学习提取图像视频特征基于深度学习的图片风格转化基于深度学习的多模态检索基于深度学习的医学图像分割基于深度学习的辅助药物设计基于深度学习的异常检测基于深度学习的声纹识别基于深度学习的推荐系统设计与实现基于深度学习的车辆特征识别研究与实现基于深度学习的入侵检测系统设计与实现基于深度学习的呼吸监测基于深度学习的零样本和少样本学习基于深度学习的大数据预测方法基于深度学习的字体风格转换方法基于深度学习的肺癌检测方法研究基于元胞自动机的复杂系统涌现现象分类方法研究机器学习在MCI疾病分类中的实现基于卷积神经网络的图像语义分割算法研究基于深度学习的图像超分辨率重建算法设计基于深度学习的图像去噪算法研究与实现基于深度学习的图像风格迁移算法设计与实现基于深度学习的图像生成对抗网络（GAN）研究与应用基于深度学习的人体姿态估计算法研究与实现基于深度学习的行人重识别算法设计与实现基于深度学习的交通标志识别与分类系统设计基于深度学习的医学图像分析与诊断系统设计基于深度学习的手势识别与控制系统设计基于深度学习的无人机视觉导航与避障算法研究基于深度学习的自动驾驶车辆视觉感知与决策系统设计基于深度学习的人机交互界面设计与实现基于深度学习的视频内容分析与标注系统设计基于深度学习的虚拟现实与增强现实应用研究基于深度学习的文本图像检索与关联算法研究基于深度学习的自然语言处理与图像理解的结合研究基于深度学习的人脸检测算法的设计与实现基于深度学习的车辆检测算法的设计与实现基于深度学习的行人检测算法的设计与实现基于深度学习的动物检测算法的设计与实现基于深度学习的水果检测算法的设计与实现基于深度学习的建筑物检测算法的设计与实现基于深度学习的飞机检测算法的设计与实现基于深度学习的火车检测算法的设计与实现基于深度学习的船只检测算法的设计与实现基于深度学习的自行车检测算法的设计与实现基于深度学习的交通标志检测算法的设计与实现基于深度学习的道路标线检测算法的设计与实现基于深度学习的行人姿态检测算法的设计与实现基于深度学习的手势识别算法的设计与实现基于深度学习的目标跟踪算法的设计与实现基于深度学习的人体关键点检测算法的设计与实现基于深度学习的物体分割算法的设计与实现基于深度学习的医学图像检测算法的设计与实现基于深度学习的无人机目标检测算法的设计与实现基于深度学习的农作物病害检测算法的设计与实现基于深度学习的人体行为识别算法的设计与实现基于深度学习的宠物识别算法的设计与实现基于深度学习的文本检测算法的设计与实现基于深度学习的图像质量评估算法的设计与实现基于深度学习的人脸表情识别算法的设计与实现基于深度学习的手写数字识别算法的设计与实现基于深度学习的车牌识别算法的设计与实现基于深度学习的人群计数算法的设计与实现基于深度学习的目标分类与检测算法的设计与实现基于深度学习的多目标跟踪算法的设计与实现基于深度学习的人体姿态估计算法的设计与实现基于深度学习的人脸识别与检测算法的设计与实现基于深度学习的手势控制算法的设计与实现基于深度学习的目标实例分割算法的设计与实现基于深度学习的人体关键点跟踪算法的设计与实现基于深度学习的人体姿态跟踪算法的设计与实现基于深度学习的图像超分辨率与目标检测算法的设计与实现基于深度学习的视频目标检测算法的设计与实现基于深度学习的遥感图像目标检测算法的设计与实现基于深度学习的工业缺陷检测算法的设计与实现基于深度学习的人群密度估计与目标检测算法的设计与实现基于深度学习的无人驾驶车辆目标检测算法的设计与实现基于深度学习的医学图像分割与目标检测算法的设计与实现基于深度学习的无人机图像目标检测与跟踪算法的设计与实现基于深度学习的人体姿态估计与目标检测算法的设计与实现基于深度学习的无人机目标跟踪与避障算法的设计与实现基于深度学习的视频行为识别与目标检测算法的设计与实现 学长的作品示例：
基于hadoop的工作流调度的研究基于Hadoop的公共自行车数据分布式存储和计算基于HHT的大规模网络流量数据处理方法研究金融大数据背景下定量化研究风险投资机构对企业发展的影响基于目标时空轨迹的大数据分析与挖掘方法研究基于Hadoop的图书推荐系统的设计与实现基于大数据的健康美食推荐系统设计与实现基于Spark的高考志愿推荐系统设计与实现基于大数据的拼团购物数据分析系统的设计与实现基于大数据的投保数据的分析系统的设计与实现基于大数据的亚健康人群的分析系统的设计与实现基于大数据的电子产品需求数据分析系统的设计与实现基于大数据的二线城市租房数据分析系统的设计与实现基于hive的共享单车用户特征分析系统的设计与实现基于大数据的美团外卖的数据分析系统的设计与实现中国降雨量数据展示与分析系统的设计与实现基于Hive的网络电视剧收视率分析的设计与实现基于大数据的健康产品分析系统的设计与实现基于大数据的亚健康人群分析系统的设计与实现基于Hadoop的一线城市租房需求的数据分析系统设计与实现基于Hadoop的扶贫的数据分析系统设计与实现某物流公司物流数据分析系统的设计与实现基于Hive的高校考试分析系统设计与实现基于大数据的滴滴出行的数据分析系统的设计与实现基于大数据的餐饮行业食材管理系统的设计与实现基于大数据的小区车辆监控系统的设计与实现基于大数据的饿了么外卖推荐系统的设计与实现基于大数据的租房推荐系统的设计与实现基于大数据的网络视频的用户画像的分析的设计与实现基于大数据的购物用户画像分析系统的设计与实现基于大数据的快手的用户画像分析系统的设计与实现基于大数据的旅游的用户画像分析系统的设计与实现基于Spark的公益活动平台的设计与实现基于大数据的收藏平台的设计与实现基于大数据的时尚推荐平台的设计与实现基于大数据的科技平台的设计与实现基于Hadoop的故事会平台的设计与实现基于大数据的国内展会平台的设计与实现基于大数据的在线购物商场设计与实现基于大数据的天津生活网平台的设计与实现基于大数据的个人出行推荐系统的设计与实现基于人工智能的邮件分发系统设计与实现基于智能识别的垃圾回收系统的设计与实现基于大数据的某电影院的电影票房预测系统的设计与实现基于大数据的云存储系统的设计与实现基于大数据的网盘应用的设计与实现基于大数据的在线音乐网站的设计与实现基于大数据的在线视频网站的设计与实现基于Mapreduce的好友推荐系统的设计与实现基于Hadoop的游戏统计网站的设计与实现基于hadoop的交通信息分析系统的的设计与实现基于hadoop的气象信息分析系统的设计与实现基于hadoop的webKPI分析系统的设计与实现基于hadoop的网站流量分析系统的设计与实现基于hadoop的手机流量分析系统的设计与实现基于hadoop的电商日志分析系统的设计与实现基于hadoop的购物商场系统的设计与实现基于大数据华客论坛的设计与实现基于大数据技术的bilibili网站数据分析的设计与实现基于大数据的自营商品平台分析系统的设计与实现基于大数据的新闻分析系统的设计与实现基于大数据技术的点餐系统的设计与实现针对大规模数据流的实时处理研究分布式消息队列的设计与实现分布式文件系统设计与实现小文件优化访问技术云PaaS中可定制的自动化部署方法研究与实现三维地形绘制系统设计与实现区块链交易信息的获取与可视化分析 学长的作品示例：
基于口令认证协议的云存储加密数据去重数字图像加密关键技术研究与实现基于动态时间规整算法的签名认证网络安全评估工具的设计与实现RSA实现中弱密钥漏洞分析Web服务统一身份认证协议设计与实现以太坊拒绝服务攻击检测基于信息隐藏技术的安全电子邮件设计与开发一种隐私保护的BP神经网络的设计信息安全领域中语义搜索引擎的设计与实现针对空间数据范围搜索的加密技术研究智能手机主动安全防护系统设计与实现数据库加密系统设计与实现的设计与开发Android终端安全审计软件模块开发Android应用程序代码保护与反保护大数据环境下的隐私安全的图像特征提取及应用云计算环境下加密数据查询的关键技术研究基于数据主权区块链的个人数据账户系统设计与实现基于主权数据区块链的身份共享应用技术一个基于区块链技术的应用系统原型设计与实现基于数据主权区块链的系统架构设计基于区块链技术的域名系统设计与实现基于区块链的分布式认证系统设计与实现基于Hadoop的区块链海量数据存储的设计与实现基于数据主权区块链的共享价值代币设计与流通方法区块链上智能合约的部署与应用研究构建基于区块链的时间承诺合同构建基于区块链的多人博弈合约 学长的作品示例：
2 开题指导 (1) 起因
近期越来越多同学开始写论文开题报告，但许多同学不指导如何选择合适的题目，不清楚老师分配的题目应该如何做，指导老师提供的信息也不够充分，导致无从下手。
(2) 如何避坑(重中之重)
毕设选题实际上对许多学生来说是一个巨大的陷阱，每年都有无数人自己挖坑然后跳进去。选择一个好的题目会使后续的答辩和论文写作变得轻松许多，而选择不当则会导致无尽的痛苦和折磨。。。。
(3) 为什么这么说呢？
实际上，这主要是因为大部分同学对特定场景所需技术的了解不清晰，导致在确定课题时他们会错误地认为某些功能很容易实现，而实际情况往往并非如此。
因此，建议对于对课题实现技术不清晰的同学，最好是寻求自己的研究生学长或老师的帮助，详细了解技术和实现流程。当然，你也可以来问我，学长会根据你的情况提供帮助。
(4) 难度把控
对于那些只追求顺利毕业的同学来说，选择毕业课题时需要注意不能选择过于困难或过于简单的题目。选择过于困难的题目可能导致自己难以完成，而选择过于简单的题目则可能导致工作量不足，无法撰写完整的论文，甚至无法通过答辩阶段。因此，需要在适度的难度范围内选择合适的课题。
(5) 题目名称
另外，最近有很多同学向学长反映，定的课题总是被老师退回，其实这还真不怪老师，我看到你们定的课题也是哭笑不得。。。。
学长在这里给你们分享一个定题标准，跟着这个标准定题准没错：
“使用了什么算法(技术) + 在什么场景下 + 解决了哪一类问题”
3 最后 如果你有任何对于开题选题的疑问，或者对相关技术缺乏了解，不知道如何开始进行毕业设计，都可以向学长咨询寻求帮助。学长会根据你的具体情况提供指导和支持。不论是你对选题还是对技术方面存在的问题，学长都愿意提供帮助。学长根据你的需求和能力，为你提供一些指导和建议，无论你遇到什么问题，都可以向学长请教，学长将竭尽全力协助你顺利完成毕业设计。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57d736128fc6cee14450eb3c81fa531/" rel="bookmark">
			HarmonyOS UI框架简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HarmonyOS UI框架介绍 HarmonyOSUI框架是一个用于构建跨设备应用的开发框架，它属于HarmonyOS系统架构的上层框架。该框架通过提供一系列的开发模型、声明式UI范式、系统API等，帮助开发者更高效地构建用户界面。
在HarmonyOSUI框架中，开发语言目前主要支持arkts/TS语言。该框架通过自研的声明式UI范式，使开发者能够描述用户界面的状态和变化，而无需关注具体的实现细节。这种范式降低了学习成本，提高了开发效率。
此外，HarmonyOSUI框架还提供了一系列的API供开发者使用，这些API可以用于设置UI组件的属性状态及状态改变、位移及缩放变换等，使开发者能够设计出高效、美观的界面效果。
该框架的性能体验体现在启动速度、帧率、响应时延、酷炫效果和资源占用等方面。它采用了代码精简的设计理念，使得代码量减少，同时提高了系统的运行效率。
在应用开发中，UI框架发挥着举足轻重的地位，其发展也在朝着跨平台、高性能、高复用性和强易用性的趋势发展。
HarmonyOSUI框架正是顺应了这一趋势，通过提供跨平台的开发能力，使得一套代码可以复用到不同的操作系统上，从而降低开发成本，提高开发效率。
HarmonyOS的特点 HarmonyOSUI框架的特点主要体现在以下几个方面：
跨平台性：HarmonyOSUI框架能够实现一套代码跨多个平台运行，这得益于其分布式技术。开发者可以使用JS/TS语言编写代码，并利用框架提供的API和组件库，构建出适用于不同平台的应用界面。高效渲染：该框架采用先进的渲染技术，确保应用的界面能够快速、流畅地呈现给用户。通过合理的组件布局和优化渲染过程，HarmonyOSUI框架能够提供出色的性能体验。声明式开发：该框架采用声明式开发范式，这意味着开发者可以专注于描述界面的状态和变化，而无需过多关注具体的实现细节。这种范式降低了开发难度，提高了开发效率。丰富的组件库：HarmonyOSUI框架提供了一套丰富的组件库，包括常见的UI组件、布局组件和业务组件等。这些组件经过优化和测试，确保了稳定性和性能。易于集成：该框架与HarmonyOS系统紧密集成，提供了与系统服务、硬件设备等交互的能力。这使得开发者能够方便地利用系统资源和能力，构建出功能强大的应用。生态支持：华为提供了全面的生态支持，包括开发工具、教程、社区等资源，帮助开发者快速上手并高效地开发应用。同时，HarmonyOS也在不断发展和完善中，为开发者提供了广阔的发展空间。 HarmonyOS 渲染流程 HarmonyOS的UI渲染流程主要包括以下几个步骤：
UI线程（UI Thread）输出LayerTree：在渲染管线中，UI线程相当于一个生产者，将生产的LayerTree添加到渲染队列中。LayerTree相当于一个生产者，它将应用的界面内容按照层级结构组织起来。GPU线程（GPU Thread）的合成器（Compositor）进行合成消费：对于需要缓存的Layer，还需要执行光栅化生成GPU纹理。光栅化就是将Layer里面记录的命令进行回放，生成每个实体的像素的过程。像素是存储在纹理的图形内存中。合成过程：在GPU线程中，合成器会将每个Layer生成的纹理进行合成，最终合成到当前Surface的图形内存（Graphic Buffer）中。这块内存中存储的就是当前帧的渲染结果内容。提交到系统合成器进行显示：最终，渲染结果需要提交到系统合成器中进行显示。系统合成器会将当前应用的内容和系统其它的显示内容，例如System UI的状态栏、导航栏，进行一次合成，最终写入到屏幕对应的帧缓冲区（Frame Buffer）中。屏幕刷新：液晶屏的驱动就会从缓冲区读取内容进行屏幕的刷新，最终将内容显示到屏幕上。 总之，HarmonyOSUI框架是一个高效、易用、跨平台的开发框架，它可以帮助开发者更快速地构建出性能卓越、界面美观的应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ced50825b80e07fed23912026e532c6/" rel="bookmark">
			js 控制页面滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用滚动方法 这种滚动是有过渡的
window.scrollTo(X,Y)
x就是距离页面左边的距离
y就是距离页面顶部的距离
滚动到顶部
window.scrollTo(0,0)
滚动到底部
window.scrollTo(0,document.body.scrollHeight)
还可以使用a标签 进行滚动不用计算滚动多少px
a标签锚链接到顶部加过度效果css_a标签锚点加过渡效果-CSDN博客 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/896ffc76efebbcb9299d047fbba542ac/" rel="bookmark">
			【力扣100】【好题】79.单词搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加链接描述
class Solution(object): # 定义上下左右四个行走方向 directs = [(0, 1), (0, -1), (1, 0), (-1, 0)] def exist(self, board, word): """ :type board: List[List[str]] :type word: str :rtype: bool """ m = len(board) if m == 0: return False n = len(board[0]) mark = [[0 for _ in range(n)] for _ in range(m)] for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0]: # 将该元素标记为已使用 mark[i][j] = 1 if self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/896ffc76efebbcb9299d047fbba542ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5eadc5e03b8a7f39acd3a22e869eed/" rel="bookmark">
			阿里员工：本月收入489325元，开心过年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击上方 "大数据肌肉猿"关注, 星标一起成长
点击下方链接，进入高质量学习交流群
今日更新| 1052个转型案例分享-大数据交流群
近日，一位阿里巴巴员工在社交媒体上炫耀自己的本月收入，竟然高达48.9万，真是让人目瞪口呆。
大家都在猜测这位员工到底是怎么赚到这么多钱的。结果一查，原来这钱不是工资，而是公司发的离职补偿金。网友大呼：卧槽！哇！离职补偿金这么高。快50万了！
原来，这位阿里员工已经在公司工作了10年以上，因为个人原因选择了离职，按照阿里的规定，他可以获得N+1的经济补偿，即工龄每满一年，补偿一个的工资，再加上一个月的工资。这样算下来，他的离职补偿金就是489325元。
作为一名互联网从业人员，哪怕知道了月收入49万的真相，依然会被这个真相震撼到了。阿里出手真霸气，离职补偿竟然高达49万！按互联网普通员工一个月到手8000块算，49万能让他们干上5年了！
这个数字虽然看起来很高，但其实也是在正常范围之内。阿里的福利待遇一直是业界的标杆，不仅有高额的工资和奖金，还有股权激励、年终奖节日福利等等。阿里的员工，无论是在职还是离职，都能享受到阿里的"福报”。但是，阿里的福利待遇，也并不是一成不变的，而是随着公司的发展和市场的变化而调整的。
事实上，阿里近几年发展确实不太顺，为了聚焦主航道，很多边缘的、不赚钱的业务都砍掉了，这也意味着裁员。2020年10月，阿里巴巴合并高鑫零售，当年末，阿里员工数量暴增一倍至25.21万人。2021年末，更是达到巅峰的25.93万人。随后，阿里员工数量呈现出了明显的下降趋势。到今年9月末，缩减至22.50万人。期间，减员最严重的是高鑫零售，从2022年3月末的12.20万人，直减至今年9月末的10.21万人。同期，阿里巴巴的员工数量，从25.49万人减至22.50万人。这就意味着，在高鑫零售之外，原阿里体系的员工，仍总体减员上万。所以，裁员对阿里和阿里员工来说真不是事儿，司空见惯、稀松平常。
最后，给大家普及一下阿里的职业发展体系：
一套体系是专家路线【P序列=技术岗】，程序员、工程师，某一个专业领域的人才，一共分为 14 级，从 P1 到 P14，目前校招最低从 P4 开始。
M路线即管理者路线【M序列=管理岗】，从M1到M10。
一般来说，应届毕业生刚入职到阿里为P5，工作1-3年之后升职到P6，阿里一般到P7 才给配股票。
目前阿里需求量最大的职级范围分布在P6-P8，这也是阿里集团占比最大的级别。P6 级别的程序员 title 是高级工程师，P7 便已经是专家级别，P8 则是高级专家。一般而言，江湖上行走小有名气的阿里程序员至少也是 P8 级别。P10 级别的存在就是传说中的大神级别，这个级别的程序员无一不是业界鼎鼎有名的存在。
岗位薪酬：
阿里薪资结构：一般是12+1+3=16薪。
年底的奖金为0-6个月薪资，90%人可拿到3个。
股票是工作满2年才能拿，第一次拿50%，4年能全部拿完。
从P7开始有股票，股票是工作满2年才能开始拿，满两年拿50％，第3年25%，第4年25%，4年拿完。据说目前P7的offer是400股票，以阿里16薪算，年薪总包大概是70-100w。
--end--
扫描下方二维码 添加好友，备注【交流】 可围观朋友圈，也可私信交流 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff83e09466c21058601dc2c892f28c6/" rel="bookmark">
			以 RoCE&#43;软件定义存储同时实现信创转型与架构升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前，不少企业数据中心使用 FC 交换机和集中式 SAN 存储（以下简称“FC-SAN 架构”），支持核心业务系统、数据库、AI/ML 等高性能业务场景。而在开展 IT 基础架构信创转型时，很多用户受限于国外交换机：FC 交换机市场几乎被 Broadcom 和 Cisco 等国外厂商垄断，很难找到成熟的国产替代方案。
而随着 RoCE（RDMA over Converged Ethernet） 这一高性能网络技术的日渐成熟，以太网交换机 + NVMe-oF 或成为破局关键：由于 RoCE 通过以太网使用 RDMA（Remote Direct Memory Access）网络协议，用户可以使用国产以太网交换机替代 FC 交换机；搭配支持 NVMe over RDMA（RoCE v2）和信创 CPU 架构的分布式存储，即可同步实现 IT 基础架构的信创转型与架构升级，满足核心业务应用“高性能、低延迟”的需求。
以下将结合权威机构趋势报告和行业用户实践，讨论这一转型方案的可行性。
替代可行性：技术成熟度与信创实践难度分析 技术成熟度：RoCE 成主流 RDMA 实现方案，NVMe-oF（RoCE）获多厂商与权威机构青睐 传统以太网采用 TCP/IP 作为网络传输协议。由于 TCP/IP 协议栈处理带来的延迟较长、服务器 CPU 消耗更高，本质上属于有损网络，其性能一直比不过 FC 网络，这也是为什么企业多采用 FC-SAN 架构支持高性能应用场景。而 RDMA 技术的出现，为解决 TCP/IP 的缺陷，提供了一种全新且高效的解决思路：通过直接内存访问技术，数据从一个系统快速移动到远程系统的内存中，无需经过内核网络协议栈，无需双方操作系统的介入，最终达到高带宽、低延迟和低 CPU 资源占用的效果。
RoCE 正在成为主流的 RDMA 实现方案。相比更早出现的 InfiniBand 技术，RoCE 支持无损以太网部署，无需使用专有网络（IB），成本也更低。虽然 RoCE 在诞生之初有诸多不足， 但经过 10 多年的发展，目前的 RoCE v2 技术已具备路由能力，且在性能表现上已经达到与 InfiniBand 相同甚至更高的水平。Mellanox 发布的《RoCE in the Data Center》白皮书明确表示，直到 RoCE 的出现与成熟，RDMA 才在基于以太网的数据中心得到大规模的应用，为数据中心业务带来低延迟、高性能的体验。中国移动发布的《以太无损网络测试技术白皮书》也指出，“在高性能计算和存储场景中，基于 RoCE 技术构建数据中心网络已成为主流解决方案之一，该方案融合了 RDMA 和以太网的优势”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eff83e09466c21058601dc2c892f28c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b21d296da5208af5fb3684373996cf/" rel="bookmark">
			Liunx（CentOS）安装Nacos(单机启动，绑定Mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Liunx安装Nacos(单机启动，绑定Mysql) 一，准备安装包 github下载点
二，在/usr/local/目录下创建一个文件夹用于上传和解压Nacos cd /usr/local/ #这里创建文件夹名字可随意，解压后会生成一个名为nacos的文件夹，后续会移动至/usr/local/ mkdir nacosall #解压之前cd进安装包根目录 cd /usr/local/nacosall/ #这边选择的Nacos版本为2.1.0 tar -zxxvf nacos-server-2.1.0.tar.gz #把该文件移动至/usr/local/目录下 mv nacos /usr/local/ 三，以单机模式运行Nacos #首先进入nacos的bin目录下 cd /usr/local/nacos/ #以单机模式启动 sh ./bin/startup.sh -m standalone which: no javac in (/opt/rh/devtoolset-9/root/usr/bin:/usr/local/sbin:/usr/local/bin: /usr/sbin:/usr/bin:/root/bin) readlink: 缺少操作数 yum install -y java-1.8.0-openjdk* #再次启动 sh ./bin/startup.sh -m standalone #根据提示查看log，看是否成功启动 cat /usr/local/nacos/logs/start.out 开放8848端口号，然后登录nacos，登陆方式，主机Ip:8848/nacos,默认账户密码都为nacos
四，配置Mysql数据库 安装数据库，版本要求：5.6.5+，安装教程为8.0.20初始化mysql数据库，数据库初始化文件：nacos-mysql.sql 数据库初始化文件一般在nacos的安装目录下：
打开DBeaver或者Navicat，先执行如下语句：
CREATE database if NOT EXISTS `nacos` default character set utf8mb4 collate utf8mb4_unicode_ci; use `nacos`; SET NAMES utf8mb4; 然后复制数据库初始化文件，nacos-mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b21d296da5208af5fb3684373996cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8237662fabe1d41f43075f0d5a4908/" rel="bookmark">
			Sonarqube安装（Docker）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，拉取相关镜像并运行 # 拉取sonarqube镜像 docker pull sonarqube:9.1.0-community 在运行之前要提前安装postgres并允许，新建数据库名为sonar的数据库
Docker安装postgres教程
docker run -d --name sonarqube --restart=always \ -p 19000:9000 \ -e sonar.jdbc.username=sonar \ -e sonar.jdbc.password=sonar \ -e sonar.jdbc.url=jdbc:postgresql://&lt;IP&gt;:15432/sonar \ -v /data/sonarqube/extensions:/opt/sonarqube/extensions \ -v /data/sonarqube/data:/opt/sonarqube/data \ sonarqube:9.1.0-community 二，检查是否运行成功 如果运行失败
#查看日志 docker logs -f sonarqube 如果报错信息如上
1、检查系统vm.max_map_count设置值
sysctl -a | grep vm.max_map_count #如果显示为vm.max_map_count = 65536 #修改 sysctl -w vm.max_map_count=262144 #再次查看是否为vm.max_map_count = 262144 sysctl -a | grep vm.max_map_count #重尝试启动启Sonarqube docker start sonarqube #docker ps 查看是否运行成功 docker ps 三，登录并安装中文插件 输入ip:19000进入主界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f8237662fabe1d41f43075f0d5a4908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c7f80eaccca4a1dc25971b3d38a1c9/" rel="bookmark">
			提高软件测试效率：Mock 测试实战教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件工程的套路中，虚拟化测试，又称 Mock 测试，扮演一个无可或缺的角色。Mock 测试允许工程师仿制和操控对象、服务或者系统组件等的行为，使得人们能在一个干净独立的环境里测试特定功能。这种方法能确保测试聚焦于代码逻辑，而非外围干扰因素。
Mock 测试的核心概念 Mock 测试 用虚拟对象取代实际对象，通过控制外部依赖，带来了测试的隔离性和准确性，从而确立了代码的稳定性及其长期维护性。
Mock 对象及其必要性 模拟对象，或简称 Mock 对象，是一个在测试场景下用以模仿真实对象功能的伪造体。利用这些对象，开发者能构建出一个控制度极高的测试环境，方便模拟各类场景，为单元测试等提供便利，这样做让测试团队能集中精力于当前的代码片段。
Mock 对象的典型应用 分离依赖：如同与数据库或外部服务解耦，减少测试的复杂性。仿制服务响应：模拟第三方服务响应，免于構建依赖真实外部服务的测试。定制测试场景：设计特有的错误或返回数据模式，校验程序逻辑。 使用广泛的 Mock 测试工具 各种 Mock 测试框架有不同的特点和用途。以下列举几个流行的选项：
JUnit 简介：在 Java 界内备受青睐的单元测试框架，提供 Mock 功能。优点：通过Mockito扩展，简化 Mock 对象的生成及验证操作。 Mockito 简介：专为 Java 设计的 Mock 框架，拥有简单明了的 Mock 语法。优点：提供了全面的 Mock 功能，支持易读的 API。 Sinon.js 简介：JavaScript 界的 Mock 工具，支持前后端开发。优点：能够创建多种模拟对象，并提供了细化的 API。 EasyMock 简介：Java 平台上的另一 Mock 框架，用于简化 Mock 过程。优点：直观的 API 设计，适合多种测试场境。 PowerMock 简介：结合 Mockito 和 EasyMock 优势的 Java 框架扩展。优点：擅长处理难以通常 Mock 的情况，如静态方法等。 在选择合适的 Mock 测试框架时，要考虑项目需求、团队技能和框架特性，从而确保框架匹配项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c7f80eaccca4a1dc25971b3d38a1c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83454c4167a97b1882c2343be5a25acb/" rel="bookmark">
			一文了解 CORS 跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个 Web 开发，一定不会对下面的跨域报错陌生。
当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。例如站点 http://www.aliyun.com 的某 HTML 页面请求 http://www.alibaba.com/image.jpg。
出于安全原因，浏览器限制从页面脚本内发起的跨域请求，有些浏览器不会限制跨域请求的发起，但是会将结果拦截。这意味着使用这些 API 的 Web 应用只能加载同一个域下的资源，除非使用 CORS 机制（Cross-Origin Resource Sharing 跨源资源共享）获取目标服务器的授权来解决这个问题。
这也是本文将要探讨的主要问题，需要额外强调的是，跨域问题产生的主体是“浏览器”，这也是为什么，当我们使用 curl、postman、各种语言的 HTTP 客户端等工具时，从来没有被跨域问题困扰过。
什么是跨域 http://www.aliyun.com 站点访问 http://www.alibaba.com/image.jpg 很容易被判断为一个跨域请求，因为域名不一样，同源策略详细描述如下：
协议相同
域名相同
端口相同
以下是跨域与同源的一些示例
站点资源访问跨域 or 同源http://www.aliyun.comhttp://www.aliyun.com/hello同源http://www.aliyun.comhttp://aliyun.com/hello跨域（域名不同，子域名和父域名也属于不同域名）http://www.aliyun.comhttps://www.aliyun.com/hello跨域（协议不同）http://www.aliyun.comhttps://www.aliyun.com:81/hello跨域（端口不同） 同源策略存在的原因是为了保护用户的安全和隐私，防止恶意网站对其他网站进行攻击或滥用。如果没有同源机制，以下一些常见的跨域攻击方式将会让网站维护者不堪其扰：
CSRF（Cross-Site Request Forgery）：攻击者在恶意网站中放置一个含有恶意请求的页面，并诱使用户访问该页面。当用户在其他网站登录时，恶意请求会自动发送给目标网站，以伪装成用户的操作。这样，攻击者可以利用用户已经登录的凭证进行恶意操作，如修改密码、发起交易等。
XSS（Cross-Site Scripting）：攻击者在合法网站的输入框或评论中注入恶意脚本代码。当用户访问包含恶意脚本的页面时，脚本会在用户的浏览器中执行。攻击者可以利用这种方式窃取用户的登录凭证、敏感信息或执行其他恶意操作。
Clickjacking：攻击者通过在一个网页上覆盖一个透明的、恶意的图层，来欺骗用户点击看似无害的内容，实际上是触发了恶意操作，如转账或进行其他敏感操作。
解决跨域问题，常见的方案有：
CORS（跨域资源共享）：在服务器端设置响应头部，允许指定的域名访问资源。
JSONP（JSON with Padding）：通过在页面中动态添加 &lt;script&gt; 元素，利用 script 标签的跨域特性来获取数据。
代理服务器：在服务器端设置一个代理服务器，将请求代理转发到目标服务器，绕过浏览器的同源策略。
本文将会主要介绍 CORS 跨域资源共享方案。
CORS 跨域资源共享介绍 CORS 被定义在 w3c 规范中：https://fetch.spec.whatwg.org/#http-cors-protocol，这里包含了最详细也最官方的描述。它并不是一个框架或者工具，而是一种机制、契约，当浏览器和后端服务同时遵守 CORS 规范时，跨域访问便成了可能。根据使用经验，我们将 CORS 的机制分成了两种模式：简单请求模式和预检请求模式。
同时符合以下条件，就属于简单请求模式：
使用以下 HTTP 方法之一：GET、POST、HEAD
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83454c4167a97b1882c2343be5a25acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b258d0c8e7d8ed7d817544b53d898e6/" rel="bookmark">
			【mysql】—— 深度理解“索引”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期，我将要给大家介绍的是关于 mysql 中的“索引”，这部分内容在mysql知识体系中可谓是相当重要的，接下来，让我带领大家进入本期的知识学习！！！
目录
（一）前言
（二）索引的理解
1、硬件角度理解索引
1.1、MySQL 与磁盘交互基本单位
1.2、简单小结
2、软件角度理解索引
2.1、案例演示
2.2、为何IO交互要是 Page？
2.3、单个page和多个page （三）聚簇索引 VS 非聚簇索引
（四）索引操作
1、主键索引
2、唯一索引
3、普通索引
4、全文索引
（五）总结与归纳
（一）前言 首先，我先给大家直观的展示一下在查询的时候，看看没有索引时有什么问题？
开始时 构建了一个8000000条记录的数据 海量表 。接下来，我将通过这张表给大家直观的演示： 💨 需求：查询员工编号为998877的员工 1️⃣ 首先，我先用传统的方式进行查询操作： select * from EMP where empno=998877; 输出展示： 解释说明： 可以看到耗时 4.93 秒，这还是在本机一个人来操作，在实际项目中，如果放在公网中，假如同时有 1000 个人并发查询，那很可能就死机。 2️⃣ 接下来我通过创建索引可以很好的解决这一问题： alter table EMP add index(empno); 输出展示： 为了防止事件的偶然性，接下来我换一个员工编号，在测试看看查询时间： 【小结】
通过以上直观的演示，我们可以发现有无索引在实际应用中的效率截然不同。因此，掌握好“索引”这个知识对我们学习mysql还是很重要的！！ （二）索引的理解 接下来，我分别从硬件和OS两个角度带大家认识索引的底层细节。
1、硬件角度理解索引 💨 首先带研究一下磁盘： 在看看磁盘中一个盘片：
扇区：
数据库文件，本质其实就是保存在磁盘的盘片当中。也就是上面的一个个小格子中，就是我们经常所说的扇区。当然，数据库文件很大，也很多，一定需要占据多个扇区。 我们在使用 Linux ，所看到的大部分目录或者文件，其实就是保存在硬盘当中的。 ( 当然，有一些内存文件系统，如： proc ， sys 之类，我们不考虑 ) 数据库文件，本质其实就是保存在磁盘的盘片当中，就是一个一个的文件 所以，最基本的，找到一个文件的全部，本质，就是在磁盘找到所有保存文件的扇区。 而我们能够定位任何一个扇区，那么便能找到所有扇区，因为查找方式是一样的。 定位扇区： 解释说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b258d0c8e7d8ed7d817544b53d898e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7582cbfbd07de3210b076421596781/" rel="bookmark">
			【LeetCode:69. x 的平方根 | 二分】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 算法题 🚀 🌲 算法刷题专栏 | 面试必备算法 | 面试高频算法 🍀
🌲 越难的东西,越要努力坚持，因为它具有很高的价值，算法就是这样✨
🌲 作者简介：硕风和炜，CSDN-Java领域新星创作者🏆，保研|国家奖学金|高中学习JAVA|大学完善JAVA开发技术栈|面试刷题|面经八股文|经验分享|好用的网站工具分享💎💎💎
🌲 恭喜你发现一枚宝藏博主,赶快收入囊中吧🌻
🌲 人生如棋，我愿为卒，行动虽慢，可谁曾见我后退一步？🎯🎯
🚀 算法题 🚀 🍔 目录 🚩 题目链接⛲ 题目描述🌟 求解思路&amp;实现代码&amp;运行结果⚡ 二分🥦 求解思路🥦 实现代码🥦 运行结果 💬 共勉 🚩 题目链接 69. x 的平方根 ⛲ 题目描述 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
示例 1：
输入：x = 4
输出：2
示例 2：
输入：x = 8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7582cbfbd07de3210b076421596781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138d1ffd2bf8a25b8177769d0e31889e/" rel="bookmark">
			网络工程专业毕设题目大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 0 简介1 如何选题2 最新网络工程选题2.1 Java web - SSM 系统2.2 大数据方向2.3 人工智能方向2.4 其他方向 4 最后 0 简介 学长搜集分享最新的网络工程专业毕设毕设选题，难度适中，适合作为毕业设计，大家参考。
学长整理的题目标准：
相对容易工作量达标题目新颖 1 如何选题 最近非常多的学弟学妹问学长关于选题的问题，所以今天学长来教大家如何进行毕业设计选题！
毕业设计的选题尤为重要，选好题目是最终完成毕业设计的第一步。
因为题目的选择跟之后的设计实现密不可分，如果你所选择的题目是你无法实现的，而且定题以后就不能修改了，这无疑会给你带来很大的困扰。
2 最新网络工程选题 2.1 Java web - SSM 系统 基于java ssm框架的学生周报管理系统基于微服务框架的电影院订票管理系统基于SSM的农产品商品信息管理系统基于SSM的家教网课学习平台基于SSM的租房信息管理系统基于SSM的教师评价考核管理系统基于SSM的婚纱摄影业务系统基于SSM的汽车租赁系统基于SSM的企业销售培训系统基于SSM的在线药品超市购物系统基于SSM的在线教学视频点播系统基于SSM的驾校预约培训管理系统基于SSM的小区车位出租管理系统基于SSM的健身运动平台管理系统基于SSM的员工/学生宿舍后勤管理系统SSM汽车故障报修管理系统基于SSM的留学生交流平台系统基于SSM的在线网课学习平台设计与实现基于SSM的网上购物商城系统基于SSM的在线医药商城购物系统基于SSM的共享充电宝管理系统基于SSM的在线电影售票系统基于SSM的勤工助学管理系统基于SSM的疫情校园师生登记备案系统基于SSM的疫情下医院门诊就医管理系统基于SSM的家庭美食食谱管理系统基于SSM的在线音乐网站设计与实现基于SSM的中医商城管理系统基于SSM的线上医院诊断管理系统基于ssm个人健康信息管理系统基于SSM的游戏攻略出售系统基于SSM的房屋租赁管理系统基于SSM与垃圾分类的信息管理系统基于SSM的旅游信息分享管理平台基于ssm的学生社团管理系统基于SSM的大学生就业企业推荐系统基于SSM的大学生兼职信息管理系统基于SSM的考研信息搜集分享管理系统大学生在线兼职发布与管理平台ssm在线医疗诊断跟踪系统基于ssm的毕设选题管理系统基于java的毕业设计选题题目推荐基于SSM与VUE的汉服销售论坛系统 2.2 大数据方向 数据挖掘相关算法的研究与平台实现数据挖掘中聚类方法的研究基于支持向量机的过程工业数据挖掘技术研究数据挖掘技术与分类算法研究基于数据挖掘的电站运行优化理论研究与应用数据挖掘算法优化研究与应用海量流数据挖掘相关问题研究半结构化数据挖掘若干问题研究海量数据挖掘技术研究数据库中数据挖掘理论方法及应用研究时间序列数据挖掘中的维数约简与预测方法研究基于数据挖掘技术的联网审计风险控制研究基于数据挖掘的道路交通事故分析研究基于数据挖掘的金融时间序列预测研究与应用基于数据挖掘技术的金融数据分析系统设计与实现基于数据挖掘的微博用户兴趣群体发现与分类基于数据挖掘的煤矿安全可视化管理研究基于数据挖掘技术的财务风险分析与预警研究可视化数据挖掘技术在城市地下空间GIS中的应用研究基于RFID的物流大数据资产管理及数据挖掘研究基于数据挖掘的战略管理会计若干问题研究数据挖掘在零售银行精准营销中的应用研究一种基于云计算的数据挖掘平台架构设计与实现面向服务的数据挖掘关键技术研究基于数据挖掘的基坑工程安全评估与变形预测研究基于消错理论的数据挖掘错误系统优化方法及应用研究基于数据挖掘的当代不孕症医案证治规律研究基于数据挖掘的网络入侵检测关键技术研究基于HADOOP的数据挖掘研究数据挖掘技术在P2P网络金融中的应用研究基于大数据的数据挖掘引擎基于YARN的数据挖掘系统的设计与实现基于数据挖掘从经验方和医案探析岭南名医治疗妇科疾病的诊疗和用药规律渐进式滑坡多场信息演化特征与数据挖掘研究基于深度学习的运动想象脑电信号分类研究 2.3 人工智能方向 基于指纹识别的门禁管理智能AI语音灯控智能AI在线答疑智能语音搜索人机在线五子棋游戏智能小车定位和路径规划系统智能蔬菜种植管理智能在线学习平台基于机器学习的智能农作物识别基于机器视觉的微生物样本识别系统研发基于图像识别的停车收费系统智能家庭种植系统基于深度学习的恶意代码可视化检测及分类研究基于文本相似度的在线答疑系统基于语音识别的智能日程管家 2.4 其他方向 智能农业大棚环境监测数据分析系统网页在线聊天系统的设计与实现智慧小区团购系统排课管理系统权限管理系统及数据可视化智能小区物业管理系统的设计实现治安综合管理信息系统的设计与实现车辆寄售系统的设计与实现爱心捐赠物资维护系统的设计与实现抽奖营销系统的设计与实现券商资讯平台的设计与实现疫苗监管平台的设计与实现知识产权申请服务平台的设计与实现X学校在线招生报名系统的设计与实现智慧育幼园管理系统的设计与实现社会志愿者服务管理平台的设计与实现美食菜谱在线分享平台家装在线平台的设计与开发中学生报考及学业规划咨询系统健康咨询及在线评估分析系统闲置物品置换平台垃圾分类知识管理及在线学习平台智能天气管家系统设计与实现智能学习计划规划服务个人健康管理服务系统智能办公室管理系统流浪动物领养系统的设计与实现 学长项目展示：
植物识别：
手势识别：
股票预测
自动驾驶，车道线检测：
项目较多，其他的不一 一展示了。。。。。。
4 最后 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf73546807078a95defe5ef8ce0e7721/" rel="bookmark">
			HarmonyOS调研分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过十多年的发展，传统移动互联网的增长红利已渐见顶。万物互联时代正在开启，应用的设备底座将从几十亿手机扩展到数百亿 IoT 设备。GSMA 预测到 2025 年，全球物联网终端连接数量将达 246 亿个，其中消费物联网终端连接数量将达 110 亿个（注：数据来自于全球移动通信系统协会发布的《2020 年移动经济》报告）。IDC 预计到 2025 年，中国物联网总连接量将达到 102.7 亿个（注：数据来自于 IDC 发布的《中国物联网连接规模预测，2020—2025》报告）。全新的全场景设备体验，正深入改变消费者的使用习惯。 同时应用开发者也面临设备底座从手机单设备到全场景多设备的转变，通过全场景多设备作为全新的底座，为消费者带来万物互联时代更为高效、便捷的体验。
当前移动应用开发中遇到的主要挑战包括：
针对不同设备上的不同操作系统，重复开发，维护多套版本。
多种语言栈，对人员技能要求高。
多种开发框架，不同的编程范式。
命令式编程，需关注细节，变更频繁，维护成本高。
什么是HarmonyOS HarmonyOS是一款面向万物互联时代的，全新的分布式操作系统；
HarmonyOS计划逐步覆盖1+8+N全场景终端设备，旨在为全场景智能化时代提供一个统一、便利、安全、高效的系统平台。（ONE AS ALL，ALL AS ONE！）
”1“：智能手机；
”8“：PC、平板、手表、智慧屏、AI音响、耳机、AR/VR眼镜、车机；
”N“：IoT生态设备；
版本历程 版本（大版本）
时间
介绍（更新）
-
2012-9
​
布局搭建系统
1.0
2019-8-9
​
首次发布，并开源操作系统代码，适用于华为智慧屏；
2.0
2020-9-10
​
在分布式软总线、分布式数据管理、分布式安全等分布式能力上进行了升级；
UI开发、性能等提升；
支持更多设备类型，包括华为智慧屏、智能穿戴、车机设备、智慧手机等；
3.0
2022-11-4
​
JS UI正式更名为ArkUI，并发布基于TS的全新开发范式；
超级终端支持更多设备类型，眼镜、显示器等；
引入Stage模型；
4.0
2023-8-4
​
全新方舟引擎，系统性能优化；
智能AI升级；
​
全新个性化设置；
NEXT
--
不再兼容Android应用？？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf73546807078a95defe5ef8ce0e7721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f55ee44148bf29c91c280c00d129e90/" rel="bookmark">
			深度生成模型之GAN基础 -＞（个人学习记录笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 深度生成模型之GAN基础生成对抗网络1. 生成对抗网络如何生成数据2. 生成对抗原理3. GAN的核心优化目标4. D的优化5. GAN的理想状态6. GAN的训练7. 梯度不稳定与模式崩塌(collapse mode)问题8. 梯度消失问题 深度生成模型之GAN基础 生成对抗网络 1. 生成对抗网络如何生成数据 生成对抗网络(Generative Adversarial Network,GAN),不显式地估计出数据分布的密度函数，但能生成符合数据分布P_data(x)的样本 2. 生成对抗原理 生成网络和判别网络相互对抗(adversarial),共同学习 3. GAN的核心优化目标 生成器损失与判别器损失 4. D的优化 判别器的优化目标 生成器优化目标 5. GAN的理想状态 约翰-纳什提出的纳什均衡(Nash equilibrium) 6. GAN的训练 SGD交替优化，先更新k次判别器，保证判别网络足够强，再更新生成网络 7. 梯度不稳定与模式崩塌(collapse mode)问题 矛盾与不对称的优化目标 8. 梯度消失问题 过大过小的激活值，梯度进入消失区 部分内容来自阿里云天池 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4172a5cfcb432e0f68ca1291b1245b6c/" rel="bookmark">
			初级前端算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目1 题目描述： 找出数组中的最大值
输入： [3, 9, 2, 5, 1]
输出： 9
JavaScript解答：
function findMaxValue(arr) { let max = arr[0]; for (let i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } return max; } const input = [3, 9, 2, 5, 1]; const output = findMaxValue(input); console.log(output); // 输出: 9 题目2 题目描述： 判断一个数是否为素数
输入： 13
输出： true
JavaScript解答：
function isPrimeNumber(num) { if (num &lt;= 1) { return false; } for (let i = 2; i &lt;= Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4172a5cfcb432e0f68ca1291b1245b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ce0034e9f885cd4876b725bcdbb8e3/" rel="bookmark">
			计算机软件考试试题——附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机软件考试试题 选择题 在面向对象编程中，继承的主要作用是：
A. 提高代码的可读性B. 隐藏对象的实现细节C. 实现多重继承D. 复用已有代码 数据库中，以下哪个操作用于删除表中的所有数据，但保留表的结构？
A. DELETEB. DROPC. TRUNCATED. REMOVE 在计算机网络中，HTTP状态码403表示：
A. 请求成功B. 未找到页面C. 服务器拒绝访问D. 请求重定向 在算法分析中，时间复杂度为O(nlogn)的排序算法是：
A. 冒泡排序B. 插入排序C. 快速排序D. 选择排序 操作系统中，进程和线程的区别是：
A. 进程有自己的地址空间，线程共享地址空间B. 进程只能有一个线程，线程可以有多个C. 进程不可以同时运行，线程可以同时运行D. 进程比线程更轻量级 在面向对象编程中，什么是多态性？
A. 一个类可以继承多个父类B. 不同类的对象可以共用相同的方法名C. 一个类可以包含多个子类D. 所有类都继承自同一个基类 OSI模型中，负责数据封装和解封的是哪一层？
A. 物理层B. 数据链路层C. 网络层D. 传输层 在数据库中，什么是事务？
A. 数据库表的集合B. 一组相关的SQL语句C. 用于操作数据的程序D. 一组原子性的操作 HTTP协议中，状态码500表示：
A. 请求成功B. 服务器内部错误C. 未找到页面D. 请求重定向 在编程语言中，动态类型语言和静态类型语言的主要区别是是否需要在编译时：
A. 编写代码B. 运行代码C. 分析代码D. 声明变量类型 数据库中，什么是SQL注入攻击？
A. 通过发送恶意代码，攻击者试图获得数据库的信息B. 在数据库中插入大量数据，导致性能下降C. 通过网络传输数据库文件D. 误删除数据库中的关键数据
12.在计算机网络中，UDP协议的主要特点是：A. 可靠传输B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ce0034e9f885cd4876b725bcdbb8e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477b4345eccc3abc25e23e16c411e093/" rel="bookmark">
			关于“Python”的核心知识点整理大全56
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
6. 链接到页面new_topic
topics.html
19.1.2 添加新条目
1. 用于添加新条目的表单
forms.py
2. URL模式new_entry
urls.py
3. 视图函数new_entry()
views.py
4. 模板new_entry
new_entry.html
5. 链接到页面new_entry
topic.html
19.1.3 编辑条目
1. URL模式edit_entry
urls.py
2. 视图函数edit_entry()
views.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
{% extends "learning_logs/base.html" %} {% block content %} &lt;p&gt;Add a new topic:&lt;/p&gt; 1 &lt;form action="{% url 'learning_logs:new_topic' %}" method='post'&gt; 2 {% csrf_token %} 3 {{ form.as_p }} 4 &lt;button name="submit"&gt;add topic&lt;/button&gt; &lt;/form&gt; {% endblock content %} 这个模板继承了base.html，因此其基本结构与项目“学习笔记”的其他页面相同。在1处， 我们定义了一个HTML表单。实参action告诉服务器将提交的表单数据发送到哪里，这里我们将 它发回给视图函数new_topic()。实参method让浏览器以POST请求的方式提交数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/477b4345eccc3abc25e23e16c411e093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298ee52bd7da041929f4286367c0b180/" rel="bookmark">
			尚硅谷web前端知识点补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档声明是一条语句告诉浏览器这是一个网页文件也可以写为&lt;!DOCTYPE HTML&gt;
二进制是计算机底层的进制
视口
VW表示的是视口的宽度，100vw=1个视口的宽度
但是vw的兼容性不是很好，新浏览器可以用，但是旧的浏览器不能用
不同的设备完美视口的大小是不一样的
iphone6 -- 375
iphone6plus -- 414
由于不同设备视口和像素比不同，所以同样的375个像素在不同的设备下意义是不一样比如在iphone6中 375就是全屏，而到了plus中375就会缺一块
所以在移动端开发时，就不能再使用px来进行布局了
表示的是视口的宽度 (viewport width)Vw
100vw = 一个视口的宽度
1vw = 1%视口宽度
vw这个单位永远相当于视口宽度进行计算
&lt;!--让一个视口是一个完美视口--&gt;
&lt;meta name="viewport" content="width=300px,initial-scale=1.0"&gt;
&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
雪碧图
雪碧图
&lt;/title&gt;
&lt;style&gt;
/*解决图片闪烁的问题:
可以将多个小图片统一保存到一个大图片里面，然后通过调整background-position来显示相应的图片
这样图片会同时加载到网页中，就可以避免出现闪烁的问题
这个技术在网页中应用十分广泛，被称为CSS-Sprite,这种图片被我们称为雪碧图。
雪碧图的使用步骤:
1.先确定要使用的图标
2.测量图标的大小
3.根据测量结果确定一个元素
4.将雪碧图设置为元素的背景图片
5.设置一个偏移量来显示正确的图片
在网页搜索一下雪碧图的介绍就明白了为什么要设置大小和偏移量*/
/*雪碧图的特点：
一次性将多个图片加载进页面，降低请求的次数，加快访问的速度，提升用户的体验。
负责图片是网页的外部元素，加载的时候需要缓存，所以可能会存在闪烁的问题*/
伪元素选择器
/* 选中的是div中的第一行文字 */div::first-line {
/* 选中的是div中被鼠标选择的文字 */div::selection (
/* 选中的是input元素中的提示文字 */input::placeholder/*
选中的是p元素最开始的位置，随后创建一个子元素 */p::before (content:"￥";
/* 选中的是p元素最后的位置，随后创建一个子元素 */p::after (
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/298ee52bd7da041929f4286367c0b180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc896d7c3b8faf5345cc400cf6c692d/" rel="bookmark">
			分布式【Zookeeper】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 ZooKeeper 是什么 ZooKeeper 是 Apache 的顶级项目。ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。在解决分布式数据一致性方面，ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议。
ZooKeeper 主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储。但是 ZooKeeper 并不是用来专门存储数据的，它的作用主要是用来维护和监控存储数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。
很多大名鼎鼎的框架都基于 ZooKeeper 来实现分布式高可用，如：Dubbo、Kafka 等。
1.2 ZooKeeper 的特性 ZooKeeper 具有以下特性：
**顺序一致性：**所有客户端看到的服务端数据模型都是一致的；从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 ZooKeeper 中。具体的实现可见下文：原子广播。**原子性：**所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。实现方式可见下文：事务。**单一视图：**无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。**高性能：**ZooKeeper 将数据全量存储在内存中，所以其性能很高。需要注意的是：由于 ZooKeeper 的所有更新和删除都是基于事务的，因此 ZooKeeper在读多写少的应用场景中有性能表现较好，如果写操作频繁，性能会大大下滑。**高可用：**ZooKeeper 的高可用是基于副本机制实现的，此外 ZooKeeper 支持故障恢复，可见下文：选举 Leader。 1.3 ZooKeeper 的设计目标 简单的数据模型可以构建集群顺序访问高性能 二、ZooKeeper 核心概念 2.1 数据模型 ZooKeeper 的数据模型是一个树形结构的文件系统。
树中的节点被称为 znode，其中根节点为 /，每个节点上都会保存自己的数据和节点信息。znode 可以用于存储数据，并且有一个与之相关联的 ACL（详情可见 ACL）。ZooKeeper 的设计目标是实现协调服务，而不是真的作为一个文件存储，因此 znode 存储数据的大小被限制在 1MB 以内。
**ZooKeeper 的数据访问具有原子性。**其读写操作都是要么全部成功，要么全部失败。
znode 通过路径被引用。znode 节点路径必须是绝对路径。
znode 有两种类型：
**临时的（ EPHEMERAL ）：**户端会话结束时，ZooKeeper 就会删除临时的 znode。**持久的（PERSISTENT ）：**除非客户端主动执行删除操作，否则 ZooKeeper 不会删除持久的 znode。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc896d7c3b8faf5345cc400cf6c692d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5aa0a44ea222c1f074601e10d281343/" rel="bookmark">
			web前端——clear可以清除浮动产生的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clear可以解决高度塌陷的问题，产生的副作用要小
未使用clear之前
&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt; 高度塌陷相关学习 &lt;/title&gt; &lt;style&gt; div{ font-size:50px; } .box1{ width:200px; height:200px; background-color: orange; float:left; } /**/ .box2{ width:400px; height:400px; background-color: skyblue; float:right; } .box3{ width:200px; height:200px; background-color: greenyellow; /*如果我们不希望某个元素因为其他元素浮动的影响而改变位置 可以通过clear属性来清除浮动元素对当前元素产生的影响 clear: 作用:清除浮动元素对当前元素所产生的影响 可选值: -left:清除左侧浮动元素对当前元素的影响 -right：清除右侧浮动元素对当前元素的影响 原理：设置清除浮动以后，浏览器会自动为元素添加一个上外边框，以使其位置不受其他元素位置的影响 both清除最大的影响，以px最大的为依据 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--输入.box1+.box2+.box3然后按回车就可以出现下面的效果--&gt; &lt;div class="box1"&gt;1&lt;/div&gt; &lt;div class="box2"&gt;2&lt;/div&gt; &lt;div class="box3"&gt;3&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 使用clear之后
&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt; 高度塌陷相关学习 &lt;/title&gt; &lt;style&gt; div{ font-size:50px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5aa0a44ea222c1f074601e10d281343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39d501b66a5210730b01dbe076f5dc2/" rel="bookmark">
			力扣labuladong一刷day50天单调栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣labuladong一刷day50天单调栈 文章目录 力扣labuladong一刷day50天单调栈总结一、496. 下一个更大元素 I二、739. 每日温度三、503. 下一个更大元素 II 总结 单调栈就这一类特殊题目，一个扳手对应一个螺丝，把模板给记牢了即可。
一、496. 下一个更大元素 I 题目链接：https://leetcode.cn/problems/next-greater-element-i/
思路：一般求下一个更大元素或者更小元素基本都是使用单调栈，而单调栈就是维护一个有序的栈，求下一个更大元素，栈内放的就是自栈底到栈顶单调递增，构造过程就是，只要新元素大于栈顶元素，那么就找到了离栈顶元素最近的一个大于他的元素，栈顶就可以出栈了，之后把新元素入栈。
class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2){ Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums2.length; i++) { while (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek()) { map.put(stack.peek(), nums2[i]); stack.pop(); } stack.push(nums2[i]); } int[] res = new int[nums1.length]; for (int i = 0; i &lt; nums1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39d501b66a5210730b01dbe076f5dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32d8d9f18af9135d27375a71bb5104a9/" rel="bookmark">
			分布式【Zookeeper ZAB协议】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Zookeeper ZAB协议 1.1 什么是Zab协议？ Zab协议的全称是 Zookeeper Atomic Broadcast （Zookeeper原子广播）。
Zookeeper 是通过 Zab 协议来保证分布式事务的最终一致性。
Zab协议是为分布式协调服务Zookeeper专门设计的一种 支持崩溃恢复 的 原子广播协议 ，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。它是特别为Zookeeper设计的支持崩溃恢复的原子广播协议。在Zookeeper中主要依赖Zab协议来实现数据一致性，基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。这里的主备系统架构模型，就是指只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader客户端将数据同步到其他Follower节点。 Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。
1.2 Zab 协议实现的作用 使用一个单一的主进程（Leader）来接收并处理客户端的事务请求（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以 事务proposal （事务提议）的形式广播到所有的副本（Follower）进程上去。保证一个全局的变更序列被顺序引用 Zookeeper是一个树形结构，很多操作都要先检查才能确定是否可以执行，比如P1的事务t1可能是创建节点"/a"，t2可能是创建节点"/a/bb"，只有先创建了父节点"/a"，才能创建子节点"/a/b"。
为了保证这一点，Zab要保证同一个Leader发起的事务要按顺序被apply，同时还要保证只有先前Leader的事务被apply之后，新选举出来的Leader才能再次发起事务。
当主进程出现异常的时候，整个zk集群依旧能正常工作。 1.3 Zab协议原理 Zab协议要求每个 Leader 都要经历三个阶段：发现，同步，广播。
发现：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表。将来客户端可以和这些 Follower节点进行通信。同步：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。这样也是体现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中。广播：Leader 可以接受客户端新的事务Proposal请求，将新的Proposal请求广播给所有的 Follower。 1.4 Zab协议核心 Zab协议的核心：定义了事务请求的处理方式
所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 Leader服务器。其他剩余的服务器则是 Follower服务器。Leader服务器 负责将一个客户端事务请求，转换成一个 事务Proposal，并将该 Proposal 分发给集群中所有的 Follower 服务器，也就是向所有 Follower 节点发送数据广播请求（或数据复制）分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈后（也就是收到半数以上的Follower的Ack请求），那么 Leader 就会再次向所有的 Follower服务器发送 Commit 消息，要求其将上一个 事务proposal 进行提交。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32d8d9f18af9135d27375a71bb5104a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e36fbbe47c8186f4f1b4db5bf1290b/" rel="bookmark">
			Weblogic安全漫谈(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 @frohoff在2015年初发现commons-collections的反序列化利用链并发布了ysoserial工具[1]。9个月后，@breenmachine对众多知名Java中间件的利用文章[2]使Java反序列化漏洞变得广为人知，Weblogic中首当其冲的就是大家多少都有点耳熟的T3协议反序列化。本篇从CVE-2015-4852入手了解T3协议的构造，作为后续T3反序列化漏洞学习和利用的基础。
环境搭建与补丁定位 Weblogic官网提供无补丁的初始版本下载[3]，为了方便后续调试分析可以先把几个大版本的安装包（Generic）、以及某些有较大安全特性变化的JDK准备好。
官方只为付费帐户提供安全补丁的下载权限，但普通账户在高级搜索页面[4]列出对应版本的补丁号与发布时间，结合官方安全公告页的CVE发布时间[5]，基本可以让CVE对应上Patch。
有了Patch号可以通过CSDN+某宝积分或者某鱼卖家等等方式下到补丁，Patch详情页里可以看到哈希，有官方原版zip洁癖的同学也可以对一下。
环境搭建时，用WeblogicEnvironment[6]构建不同JDK与Weblogic版本的docker镜像会比较方便，后续也能用容器区分不同的补丁版本。运行前需要参考issues/8改一下Dockerfile，另外就是根据个人需要做适当调整了，比如Weblogic开启的远程调试端口默认为8453（对应IDEA默认的5005）、调整JDK版本等等。
CVE-2015-4852 《攻击JavaRMI概述》[7]中说过JavaRMI机制基于JRMP协议通信，Weblogic有一个与JRMP同类的应用层协议就是T3。T3协议用在Weblogic的这类商用产品当中，协议实现并不开源且没有文档，小编主要靠连蒙带猜和逆向去管中窥豹。
/u01/app/oracle/Domains/ExampleSilentWTDomain/bin/stopWebLogic.sh用到了T3协议去停掉Weblogic，在执行前挂上tcpdump -i any -w t3-stop.pcap抓一下数据包。
Java原生序列化流通过十六进制为ac ed 00 05的字节作为开头的标识（黑话管它叫做魔术字节），ysoserial也正是通过原生序列化生成的payload，自然能简单粗暴地想到是不是直接替换就行了，那么要替换掉哪些部分呢？能看出先进行了第一次通信，请求和响应都是可读的ASCII字符，后续的的请求中似乎也没有用到响应的内容。
把第二次请求字节流扒下来反序列化并处理异常后可以发现存在五个Object，因为WebServer每个请求通常会起一个新的线程来处理，不用担心像内核Pwn一样没处理好异常整个系统蹦掉，那么从第一处魔术字节开始替换为payload，后续部分抛掉不管必然会报错，但问题不大，将原本第二次请求的A + Serial + B + Serial + ...改成A + Payload。
构造如下脚本用作发送payload的客户端，它好比航天发射场组装火箭后打出去，payload就是火箭里用于开展科学实验的载荷。
那么问题来了，首先是为什么要先经过第一次通信交互（t3Bootstrap）。我们大家都知道在黑盒打不通的时候通常都是打不通的，对此小编也感到很惊讶，将payload硬莽过去只会得不到响应。这就如同需要用火箭将实验载荷送到预定轨道一样。
第二个问题是payload前加上的那些字节数据是干嘛的，即火箭为什么要设计构建成这样？自然是为了让载荷顺利进入预定轨道。相信有的同学想喷我了，这里看似相互解释了实则什么都没解释，如果前面还能从没响应的现象下手企图蒙混过关，但这里不啃代码是圆不过去了。
我知道你很急，但你先别急。我们先来看看稍微简单一点的第三个问题，即payload用什么？要使用ysoserial生成的CC链就需要看目标环境有没有相应依赖，快速但不准确的方法是直接找有没有Jar包。
# find /u01/ -name "*commons*collections*.jar" /u01/app/oracle/middleware/modules/com.bea.core.apache.commons.collections_3.2.0.jar 为了更精确定位则可以采用META-INF等信息判断版本、运行时相应上下文能否调到关键类等等方法。
如此我们便能利用这个祖师爷漏洞，对着周朝出土的Weblogic一顿RCE了：
java -jar ysoserial.jar CommonsCollections6 "touch /tmp/pwned" &gt; /tmp/poc.ser python3 t3client.py 127.0.0.1 7001 /tmp/poc.ser # ls -al /tmp/ | grep 'pwned' -rw-r----- 1 root root 0 Feb 17 17:18 pwned 逆向T3协议头 猜测关键词暴力搜索后，找到第一次交互时响应数据的来源。下断点得到调用栈：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42e36fbbe47c8186f4f1b4db5bf1290b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c45734a97b948fbeb0c90ac96c293eb/" rel="bookmark">
			window.history.go(-1)回退未刷新问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 window.history 是浏览器提供的一个对象，用于处理浏览器的历史记录。通过这个对象，你可以执行前进、后退、刷新等操作。
window.history 对象包含以下方法：
back()：返回上一个历史记录，页面会刷新。
forward()：前进到下一个历史记录，页面会刷新。
go(num)：跳转到某一个历史记录，num为1表示前进，为-1表示后退。
pushState(stateData, title, url)：在历史记录中创建一个新的访问记录，不能跨域，且不造成页面刷新。
replaceState(stateData, title, url)：修改当前记录，不能跨域，且不造成页面刷新。
window.history 对象也包含以下属性：
length：返回浏览器历史堆栈的长度。
state：返回与指定的历史记录条目关联的状态对象。这通常与pushState或replaceState方法一起使用。
此外，window.history 对象还触发 popstate 事件，当调用go、back、forward方法时触发，pushState、replaceState不会触发。同时，window.onhashchange事件可以监听锚部分（以 ‘#’ 号为开始）发生改变的情况，例如通过设置Location对象的location.hash或location.href属性修改锚部分、使用不同history操作方法到带hash的页面、点击链接跳转到锚点等情况。
二、方法梳理 window.location.reload(); //刷新 window.history.go(1); //前进 window.history.go(-1); //返回+刷新 window.history.forward(); //前进 window.history.back(); //返回 采用window.history.go(-1)时，页面未刷新，使用以下方法解决
window.onload = function () { var isPageHide = false; // 页面加载（是没有刷新页面的，跟页面刷新有着本质的不同） window.addEventListener('pageshow', function () { if (isPageHide) { window.location.reload(); } }); window.addEventListener('pagehide', function () { isPageHide = true; }); }; 三、后记 JavaScript是一种面向对象的动态编程语言，用于为网页添加交互和动态效果。它可嵌入到HTML文档中，并通过浏览器解释执行。
以下是JavaScript的一些详细概念：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c45734a97b948fbeb0c90ac96c293eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2699afe79f44797fd223e72e57307ee/" rel="bookmark">
			GitHub Copilot 最佳免费平替：阿里通义灵码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前分享了不少关于 GitHub Copilot 的文章，不少粉丝都评论让我试试阿里的通义灵码，这让我对通义灵码有了不少的兴趣。
今天，阿七就带大家了解一下阿里的通义灵码，我们按照之前 GitHub Copilot 的顺序分享通义灵码在相同场景下的表现。
先贴一下通义灵码官网：https://tongyi.aliyun.com/lingma/download
我们开始
IDEA 上安装通义灵码 settings 选择 Plugins 输入 TONGYI Lingma，点击 install 即可，大概几分钟之后安装完成，点击重启 IDEA。
选择登陆进入通义灵码登录页，登陆阿里云账号，可以直接通过支付宝扫码即可。
可以看到，他支持云端大模型，也支持本地模型服务，调用自己已有的大模型服务，如果公司对安全性要求比较高的，使用这个还是不错的。
通义灵码代码实践 1、解释代码 1.1 解释代码 选中代码，选择通义灵码-解释代码，和 Copilot 的 Explain This 作用一致。
我们看到这个解释的结果会在通义灵码的 Chat 对话框内输出，但是它的功能更丰富，可以选择更精简、更详细的结果。
1.2 逐行解释 直接在上一步的 Chat 界面，输入「逐行解释」，之后通义灵码就会生成每行代码的注释了。
2、代码解释 2.1 单行注释 在代码上方输入单行注释符合 //，等一会模型就会生成下方代码注释了。
2.2 逐行注释 在 Chat 界面，直接输入「逐行注释」，就会生成针对所有选中代码的单行注释了。
3、生成文档/方法注释 右键选择通义灵码，然后选择生成代码注释，就能为方法生成接口级别注释。
我们看到这个例子中，生成的注释还参考了之前的模板，生成的注释也比较准确。
4、注释生成代码 我们直接输入注释 「bubble sort」换行，就能看到模型推荐的冒泡排序的完整代码了，还是非常快速和强大的。
5、生成单元测试 右键选择通义灵码，然后选择「生成单元测试」，就能为方法生成接口级别注释。
我们能看到通义灵码为选中的代码生成了简单的单元测试，我们 copy 到 test 对应的目录即可运行，我们也可以选择下方的按钮，使用不同的测试库重新生成单元测试。
总结时刻 本文的顺序基本上和之前的 GitHub Copilot 一致。我们能看到通义灵码和 GitHub Copilot 的操作基本类似。比较明显的区别就是，通义灵码暂时不收费！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2699afe79f44797fd223e72e57307ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dcc20891ce3b64a95fd70317d00ebef/" rel="bookmark">
			python股票分析挖掘预测技术指标知识大全之BOLL线详解(4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人股市多年的老韭菜，各种股票分析书籍，技术指标书籍阅历无数，萌发想法，何不自己开发个股票预测分析软件，选择python因为够强大，它提供了很多高效便捷的数据分析工具包。
我们已经初步的接触与学习其中数据分析中常见的3大利器---Numpy,Pandas，Matplotlib库。
也简单介绍一下数据获取的二种方法，通过金融数据接口和爬虫获取。
介绍了指标之王MACD，随机指标KDJ的详细用法，这一章我们介绍BOLL指标线
“不管黑猫白猫，能抓到耗子的就是好猫”,BOLL指标的名气没前二者大，其实这是很好的指标，我至少认识几个朋友就专用boll指标，效果不错。
BOLL指标详解 (1)BOLL指标简介 布林带（BOLL）指标是美国股市分析家约翰·布林根据统计学中的标准差原理设计出来的一种非常简单实用的技术分析指标。一般而言，股价的运动总是围绕某一价值中枢（如均线、成本线等）在一定的范围内变动，布林线指标正是在上述条件的基础上，引进了“股价通道”的概念，其认为股价通道的宽窄随着股价波动幅度的大小而变化，而且股价通道又具有变异性，它会随着股价的变化而自动调整。
(2)BOLL指标应用 Boll指标的应用主要体现在以下几个方面：
1. 判断趋势：当价格位于上轨线以上时，说明市场处于超买状态，趋势可能会逆转；当价格位于下轨线以下时，说明市场处于超卖状态，趋势可能会逆转。投资者可以根据价格在轨道线上下的位置来判断趋势的强度和变化。
2. 制定交易策略：当价格从下轨线向上突破中轨线时，为买入信号；当价格从上轨线向下突破中轨线时，为卖出信号。投资者可以根据这些信号来确定买卖点位，制定相应的交易策略。
3. 确定止损位：当价格突破上轨线时，说明市场处于超买状态，投资者可以设定止损位在上轨线以上一定的幅度，以避免亏损。同理，当价格突破下轨线时，也可以设定止损位在下轨线以下一定的幅度。
(3)BOLL指标计算方法 在相对所有的指标最复杂的计算中，BOLL指标的计算方法是其中之一，其中引进了统计学中的标准差概念，涉及到中轨线（MB）、上轨线（UP）和下轨线（DN）的计算。另外，和其他指标的计算一样，由于选用的计算周期的不同，BOLL指标也包括日BOLL指标、周BOLL指标、月BOLL指标年BOLL指标以及分钟BOLL指标等各种类型。经常被用于股市研判的是日BOLL指标和周BOLL指标。虽然它们的计算时的取值有所不同，但基本的计算方法一样。
日BOLL指标的计算公式
中轨线=N日的移动平均线
上轨线=中轨线+两倍的标准差
下轨线=中轨线-两倍的标准差
日BOLL指标的计算过程
计算MA：
MA=N日内的收盘价之和除以N
计算标准差MD：
MD=平方根N日的（C - MA）的两次方之和除以N
计算MB、UP、DN线：
MB=（N-1）日的MA
UP=MB + 2 × MD
DN=MB - 2 × MD
在股市分析软件中，BOLL指标一共由四条线组成，即上轨线UP 、中轨线MB、下轨线DN和价格线。其中上轨线UP是UP数值的连线，用黄色线表示；中轨线MB是MB数值的连线，用白色线表示；下轨线DN是DN数值的连线，用紫色线表示；价格线是以美国线表示，颜色为浅蓝色。
python代码：
# 导入及处理数据 import pandas as pd import numpy as np # 绘图 import matplotlib.pyplot as plt # 设置图像标签显示中文 plt.rcParams['font.family'] = 'Heiti TC' plt.rcParams['font.sans-serif'] = ['SimHei'] plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dcc20891ce3b64a95fd70317d00ebef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f6136bdadee138270e75cf0b792fa7/" rel="bookmark">
			流媒体学习之路(WebRTC)——GCC分析（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流媒体学习之路(WebRTC)——GCC分析（4） —— 我正在的github给大家开发一个用于做实验的项目 —— github.com/qw225967/Bifrost 目标：可以让大家熟悉各类Qos能力、带宽估计能力，提供每个环节关键参数调节接口并实现一个json全配置，提供全面的可视化算法观察能力。 欢迎大家使用 —— 文章目录 流媒体学习之路(WebRTC)——GCC分析（4）一、间隔计算（InterArrival）1.1 模块介绍1.2 代码 二、码率控制（AimdRateControl）2.1 背景2.2 代码 三、总结 在讲具体内容之前插一句嘴，从GCC分析（3）开始，我们将针对GCC的实现细节去分析它设计的原理，让我们理解这些类存在的意义，不再带大家去串具体的流程了。
一、间隔计算（InterArrival） 1.1 模块介绍 WebRTC 的 InterArrival 类是用于计算包之间的到达时间差(Inter-Arrival Time)的类。 如果观察WebRTC的提交记录你会发现，这个类随着卡尔曼滤波器、趋势线等等算法的变更也一直在调整。那么为什么要存在这个接收间隔的计算类呢？
细心的小伙伴在观察我们发送视频数据的时候会发现，数据的发送是一股一股的——常常是一次发送几个包。
这是因为我们采集的数据帧大小是实时变化的每次可发送的数据量都不一样，而pacer发送是依赖于定时器去触发发送事件的，这样的触发模式有两种：周期模式（kPeriodic）、动态模式（kDynamic）——后来好像动态模式的代码被移除了，但是我们今天不是关注pacer的问题，而是补充一些小知识。
周期模式中，定时5ms会触发一次发送；
动态模式中，每次都会计算下一次触发发送的时间;
可以直观的理解为，当数据在接收端产生接收间隔增大时，这个间隔不仅仅是网络导致的，还有可能是发送时就已经造成了间隔增大。那么我们想把这个间隔计算出来也就需要发送端记录自己的发送时间了，InterArrival这个类就做这些变化的校准。
1.2 代码 该部分最重要的代码是在延迟估计IncomingPacketFeedback调用的，下面展示一部分伪代码
void DelayBasedBwe::IncomingPacketFeedback(const PacketResult&amp; packet_feedback, Timestamp at_time) { ... uint32_t ts_delta = 0; int64_t t_delta = 0; int size_delta = 0; // 校准接收间隔 bool calculated_deltas = inter_arrival_-&gt;ComputeDeltas( timestamp, packet_feedback.receive_time.ms(), at_time.ms(), packet_feedback.sent_packet.size.bytes(), &amp;ts_delta, &amp;t_delta, &amp;size_delta); double ts_delta_ms = (1000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62f6136bdadee138270e75cf0b792fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73de43c3d4e7d7e2dc9d9135d23cd6a5/" rel="bookmark">
			优优嗨聚集团：冬季旅游市场，寒风中的暖流“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着季节的轮换，冬季的寒风已经开始轻轻掠过大地。对于很多人来说，这可能是一个蛰伏的季节，但对于旅游市场来说，冬季却是一个充满潜力和机遇的季节。今天，我们就来探讨一下冬季旅游市场的发展趋势，以及如何在这个季节中抓住机遇，迎接挑战。
冬季旅游市场在近年来呈现出稳步增长的趋势。根据数据，越来越多的人选择在冬季走出家门，感受不同的风景和文化。其中，冰雪旅游、温泉旅游、热带度假等成为热门选择。这不仅是因为冬季人们有更多的闲暇时间，更是因为人们对冬季旅游的需求和认知在逐渐提高。
然而，冬季旅游市场的崛起并非一帆风顺。由于气候的原因，很多旅游目的地在冬季可能会出现降雪、严寒等情况，这对旅游设施和服务提出了更高的要求。同时，由于旅游资源的有限性，如何在冬季吸引游客，保持旅游市场的热度，也是摆在各大旅游目的地面前的一大挑战。
那么，如何抓住冬季旅游市场的机遇呢？首先，要注重旅游产品的多元化。针对不同人群的需求，推出个性化的旅游产品，如家庭亲子游、情侣度假游、户外探险游等。其次，提升服务质量。在冬季，游客对旅游服务的需求更为迫切，因此，提供优质的服务是吸引游客的关键。此外，加强宣传推广也是必不可少的。通过各种渠道和平台，将冬季旅游的魅力传递给更多的人。
在自媒体时代，内容营销成为一种重要的推广手段。一篇有吸引力的文章、一段精彩的视频，都可能引发消费者的兴趣，促使他们做出旅行的决定。因此，各大自媒体平台也成为冬季旅游市场推广的重要战场。通过撰写有关冬季旅游的文章、拍摄精美的旅行照片和视频，可以有效地吸引目标受众，提升旅游目的地的知名度和美誉度。
总之，冬季旅游市场虽然面临诸多挑战，但同时也充满了无限的机遇。只要我们紧跟市场需求，不断提升服务品质和宣传效果，相信在寒冷的冬季中也能感受到旅游市场的温暖和活力。让我们一起期待一个充满惊喜的冬季旅游市场吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e8788a0d040cbe17389701cf18c08b/" rel="bookmark">
			wps将姓名处理格式为：姓**
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开wps，在要处理数据右侧一个单元格 输入公式：=LEFT(A1,1)&amp;"**"，然后回车
2.按住ctrl和处理好的数据的右下角小方框，往下拖动即可生成格式为：姓** 格式的数据
3.复制生成的数据，右键选择 “选择性粘贴”后点击确定，这样就不会把公式也复制过来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb442f2342ea4cb80e18023d6a3c1174/" rel="bookmark">
			内网穿透方案&amp;FRP内网穿透实战（基础版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言方案 方案1：公网方案2：第三方内网穿透软件 花生壳cpolar方案3：云服务器做反向代理FRP简介FRP资源FRP原理FRP配置教程之SSH 前期准备服务器配置 下载FRP配置FRP服务端启动FRP服务端验证是否启动成功可能遇到的一些问题客户端配置 下载FRP配置FRP服务端启动FRP客户端验证是否穿透成功 方案 方案1：公网 独立公网，IPv4的就不要想了。
动态公网：除了移动，电信和联通，和客服沟通下，都会很大方。
有了动态公网IP后，就用DDNS来绑定自己的域名就好了。DDNS服务商可以百度随便找个，因为我个人没有动态公网IP，就没有细究。
参考方案：DNSPOD
方案2：第三方内网穿透软件 花生壳 花生壳：贵，免费的不够用。
cpolar cpolar：目前在用，个人使用感觉，比花生壳要好。
先下载去官网免费版的cpolar，然后配置映射即可。免费的带宽1M，有4条映射（我试过，应该是每个客户端有4条映射可配置，而不是每个账号只有4条映射，这个算nice）
方案3：云服务器做反向代理 先购买有个带公网IP的云服务器，然后用云服务器反向代理，利用这个云服务器做流量转发，原理和方案2一样，只是要自己实现流量转发。
参考方案：云服务器+FRP+个人域名。
FRP简介 frp 是一个开源、简洁易用、高性能的内网穿透和反向代理软件，支持 tcp, udp, http, https等协议。
FRP资源 FRP源码&amp;教程：GitHub - fatedier/frp: A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.
更多穿透教程也可以参考官方demo，甚至源码。 FRP原理 服务端运行，监听一个主端口，等待客户端的连接；客户端连接到服务端的主端口，同时告诉服务端要监听的端口和转发类型；服务端fork新的进程监听客户端指定的端口；外网用户连接到客户端指定的端口，服务端通过和客户端的连接将数据转发到客户端；客户端进程再将数据转发到本地服务，从而实现内网对外暴露服务的能力。 就是利用拥有公网的服务器帮忙转发数据。
FRP配置教程之SSH 前期准备 需要一台具有公网IP的服务器。
需要被穿透的内网设备。
配置主要分两部分：
FRP服务端，布局在具有公网的IP的服务器。FRP客户端，布局在内网设备。 FRP穿透配置文件参考：frp*_full.ini。
服务器配置 下载FRP 下载release包：根据设备和frp版本下载：
wget https://github.com/fatedier/frp/releases/download/v0.45.0/frp_0.45.0_linux_amd64.tar.gz 解压：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb442f2342ea4cb80e18023d6a3c1174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118d9f9c28136755b636672e227e70d0/" rel="bookmark">
			VS2022 无法打开源文件“stdio.h”问题解决记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到的问题：VS2022 编译运行C/C++相关项目时，报错无法打开源文件“stdio.h”，以及一系列相关.h文件全都打不开。
查阅资料： VS2022 无法打开源文件“stdio.h”问题_vs2022无法打开源文件stdio.h怎么解决-CSDN博客
无法打开源文件 “stdio.h“ /“stdlib.h“/“string.h等_vs无法打开源文件stdlib.h-CSDN博客
有不少相关的问题帖子。
流行的解决方案： 1.安装Windows SDK
2.重装Windows SDK
3.在项目设置中，启用Windows运行时
尝试： 1和2感觉没有尝试的必要，尝试方法3后，报新的错误：VS2022报错：E1696 命令行错误: 无法打开 元数据 文件 “platform.winmd”_无法打开元数据 文件 platform.winmd-CSDN博客
最终决定重装VS2022。成功解决。
安装了SDK但仍然报错 “找不到Windows SDK 版本xxxxxxxx。”_vsinstaller安装了sdk了但是还是使用不了-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98dd678dfe8ea1295a005349e4e5dc8e/" rel="bookmark">
			目标检测-One Stage-SSD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、SSD的网络结构和流程二、SSD的创新点总结 前言 根据前文目标检测-One Stage-YOLOv1可以看出YOLOv1的主要缺点是：
每个格子针对目标框的回归是不加限制的，导致目标的定位并不是很精准和Faster RCNN等先进Two Stage算法相比，没有应用多尺度特征图的思想预训练时与实际训练时输入大小不一致，模型需要去适应这种分辨率的转换，会影响最终精度 SSD（Single Shot MultiBox Detector）针对上述缺点做了改进
提示：以下是本篇文章正文内容，下面内容可供参考
一、SSD的网络结构和流程 将影像输入VGG16，得到不同卷积层的多尺度特征图（38，19，10，5，3，1）引入了anchor机制，不同尺度特征图每个像素预设置不同数量的先验框 [4, 6, 6, 6, 4, 4] ps：产生共计 3 8 2 × 4 + 1 9 2 × 6 + 1 0 2 × 6 + 5 2 × 6 + 3 2 × 4 + 1 2 × 4 = 8732 38^2×4+19^2×6+10^2×6+5^2×6+3^2×4+1^2×4 = 8732 382×4+192×6+102×6+52×6+32×4+12×4=8732 个anchor
SSD中anchor的大小尺寸（scale）并不是按照特征图的大小统一缩放对应的，而是手动设置了一个线性插值变换，使浅层使用较小的scale，往深层逐渐增大scale。由于随着层次加深感受野逐渐增大，这意味着SSD使用感受野小的feature map检测小目标（较小的scale），使用感受野大的feature map检测更大目标（较大的scale）。
将不同尺度特征图的anchor输入不同的分类和边框回归器使用非极大值抑制NMS去除冗余窗口
二、SSD的创新点 引入了多尺度特征图和anchor机制，改进了YOLOv1边框不加限制的缺点为适应数据集的输入，采用了两种大小输入：300 × 300和512 × 512使用了一些数据增强手段 总结 SSD结合了YOLO中的回归思想和Faster R-CNN中的anchor机制，使用全图各个位置的多尺度区域特征进行回归，既保持了YOLO速度快的特性，也保证了窗口预测的跟Faster R-CNN一样比较精准。SSD在VOC2007上mAP可以达到72.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98dd678dfe8ea1295a005349e4e5dc8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1463b62b24f06c07b49309b52d32fd/" rel="bookmark">
			Oracle merge into 详解（有则更新，无则插入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 概述1.1 使用场景1.2 常规写法1.3 基础数据准备 2 示例2.1 语法2.2 实操 1 概述 1.1 使用场景 需求：源表 a 的数据 写入至 目标表 b 中规则： ① 若目标表 b 中 有 源表 a 的这条记录，则 更新② 若目标表 b 中 没有 源表 a 的这条记录，则 插入 优势：执行效率高、语法简洁 1.2 常规写法 -- 如果不知道 merge into 这个语法，咱可能会这么写 select count(1) into v_count from ...; if count(1) &gt;= 1 then update ...; -- 有则更新 else insert ...; -- 无则插入 1.3 基础数据准备 -- 源表：source_table create table source_table ( sno number(3), sname varchar2(30), sex varchar2(2) ); insert into source_table(sno, sname, sex) values(1, '瑶瑶', '女'); insert into source_table(sno, sname, sex) values(2, '优优', '男'); insert into source_table(sno, sname, sex) values(3, '倩倩', '女'); commit; -- 目标表：target_table（仅表结构） create table target_table as select * from source_table where 1 = 2; insert into target_table (sno, sname, sex) values(1, '瑶瑶', '男'); commit; 2 示例 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f1463b62b24f06c07b49309b52d32fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a73a1fe959e05c4e55052d95beec1f0/" rel="bookmark">
			【Java 21 新特性】顺序集合（Sequenced Collections）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 摘要 引入新的接口表示具有定义的遇到顺序的集合。每个这样的集合都有一个明确定义的第一个元素、第二个元素，依此类推，直到最后一个元素。提供统一的API来访问它的第一个和最后一个元素，并以相反的顺序处理它的元素。
"生活只能向后理解；但必须向前生活。"—基尔克高德
2 动机 Java集合框架缺乏表示具有定义的遇到顺序的元素序列的集合类型。它还缺乏适用于这些集合的统一操作集。这些差距一直是问题和抱怨的重要来源。
如List和Deque都定义了遇到顺序，但共同父类Collection却没有定义遇到顺序。同样，Set没有定义遇到顺序，而子类型HashSet也没定义，但子类型如SortedSet和LinkedHashSet却定义了。因此，对遇到顺序的支持在类型层次结构中分散，使得在API中表达某些有用概念很困难，即不能在Collection中描述具有遇到顺序的参数或返回值。Collection太一般了，将这些约束规定到散文规范中，可能导致难以调试的错误。List太具体了，排除了SortedSet和LinkedHashSet。
FAQ 视图集合通常被迫降级到较弱语义。用Collections::unmodifiableSet包装LinkedHashSet会产生一个Set，丢弃了顺序信息。
没有定义它们的接口，与遇到顺序相关的操作要么不一致，要么缺失。虽许多实现支持获取第一个或最后一个元素，但每个集合都定义了自己的方式，有些不明显或完全缺失：
First elementLast elementListlist.get(0)list.get(list.size() - 1)Dequedeque.getFirst()deque.getLast()SortedSetsortedSet.first()sortedSet.last()LinkedHashSetlinkedHashSet.iterator().next()// missing 一些是不必要的繁琐，如获取List的最后一个元素有些甚至没有英雄主义是不可能的：获取LinkedHashSet的最后一个元素的唯一方法是迭代整个集合！同样，从第一个元素到最后一个元素遍历通常需用迭代器或使用普通for循环，使代码冗长不直观 为解决这些问题，引入新接口SequencedCollection表示具有定义的遇到顺序的集合。每个SequencedCollection都有一个明确定义的第一个元素、第二个元素，依此类推，直到最后一个元素。它还提供统一的API访问它的第一个和最后一个元素，并以相反的顺序处理它的元素。
SequencedCollection还提供新reversed()方法，提供一个反向排序的视图。这视图可让集合以相反顺序处理元素，使用所有常见迭代机制，如增强for循环、显式的iterator()循环、forEach()、stream()、parallelStream()和toArray()。
如以前从LinkedHashSet获取反向排序的流困难，现只需linkedHashSet.reversed().stream()。
SequencedCollection还从Deque中提升一些方法，支持在两端添加、获取和删除元素：
void addFirst(E)void addLast(E)E getFirst()E getLast()E removeFirst()E removeLast() add(E)和remove()方法可选，主要是为支持不可修改的集合的情况。如集合为空，get()和remove()方法将抛出NoSuchElementException。
由于SequencedCollection的子接口具有冲突的定义，所以在SequencedCollection中没有定义equals()和hashCode()方法。
这些改动使得具有遇到顺序的集合更加易于使用和操作，并提供了一致的API来处理这些集合的元素。
Sequenced Sets Set接口的扩展，有序集合，不含重复元素：
// since 21 interface SequencedSet&lt;E&gt; extends Set&lt;E&gt;, SequencedCollection&lt;E&gt; { SequencedSet&lt;E&gt; reversed(); // 协变重写 } SequencedSet接口提供reversed()方法，用于返回一个反转顺序的SequencedSet。对于LinkedHashSet等集合，若元素已存在于集合中，则会将其移动到适当位置。这解决LinkedHashSet无法重新定位元素痛点。
SequencedMap Map接口的扩展，条目具有定义好的遍历顺序。
interface SequencedMap&lt;K,V&gt; extends Map&lt;K,V&gt; { // 新方法 SequencedMap&lt;K,V&gt; reversed(); SequencedSet&lt;K&gt; sequencedKeySet(); SequencedCollection&lt;V&gt; sequencedValues(); SequencedSet&lt;Entry&lt;K,V&gt;&gt; sequencedEntrySet(); V putFirst(K, V); V putLast(K, V); // 从NavigableMap中提升的方法 Entry&lt;K, V&gt; firstEntry(); Entry&lt;K, V&gt; lastEntry(); Entry&lt;K, V&gt; pollFirstEntry(); Entry&lt;K, V&gt; pollLastEntry(); } reversed()返回一个反转顺序的SequencedMapsequencedKeySet()返回一个有序的键集合sequencedValues()返回一个有序的值集合sequencedEntrySet()返回一个有序的条目集合 SequencedMap还提供了putFirst()和putLast()方法，用于在指定位置插入键值对。对于SortedMap等映射，这些方法会抛出UnsupportedOperationException。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a73a1fe959e05c4e55052d95beec1f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b4d8e7e74424590142ce6575e699168/" rel="bookmark">
			配置文件的创建和部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置描述文件（Configuration Profiles）的格式为xml，其提供了一个非常容易的方式去给电脑、移动设备或用户定义一些设置或限制，你可以使用Jamf Pro去创建这样的配置文件。
（配置文件的负载）
有关配置文件的配置和部署有一些要点与大家分享：
·配置文件的部署基于与APNs的通讯
·范围（scope）的设定一定不要忘记
·有些负载（payloads）支持多个设定
o 例如WiFi负载中可以添加多个 WiFi设定
·配置文件的更新是先移除旧的再安装新的
o 确保此过程中新配置文件安装时设备是有网络连接的
·配置文部署的故障诊断步骤
o 确认负载配置正确
o 通过配置文件logs查看部署状态
o 到指定设备的管理历史（management history）查看部署状态
·部署推荐
o 避免添加多个无关的负载到一个独立的配置文件中
2011年, SolutionKeys将Jamf (Casper Suite)首次引入了中国。 SolutionKeys是大中华地区优质Jamf授权经销商和Jamf的关键服务伙伴(Jamf授权集成商)。我们确保Jamf管理和部署的黄金标准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac60ad02a524fda553d87a710a2a99c/" rel="bookmark">
			halcon3D点云处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天天找，不如自己记一下：
走起，先写点，再补充
Chapter_10_:Matching-3D
affine_trans_object_model_3d
功能：把一个任意有限3D变换用于一个3D目标模型。
clear_all_object_model_3d
功能：释放所有3D目标模型的内存。
clear_all_shape_model_3d
功能：释放所有3D轮廓模型的内存。
clear_object_model_3d
功能：释放一个3D目标模型的内存。
clear_shape_model_3d_
功能：释放一个3D轮廓模型的内存。
convert_point_3d_cart_to_spher
功能：把直角坐标系中的一个3D点转变为极坐标。
convert_point_3d_spher_to_cart
功能：把极坐标中的一个3D点转变为直角坐标。
create_cam_pose_look_at_point
功能：从摄像机中心和观察方向创建一个3D摄像机位置。
create_shape_model_3d
功能：为匹配准备一个3D目标模型。
find_shape_model_3d
功能：在一个图像中找出一个3D模型的最佳匹配。
get_object_model_3d_params
功能：返回一个3D目标模型的参数。
get_shape_model_3d_contours
功能：返回一个3D轮廓模型视图的轮廓表示。
get_shape_model_3d_params
功能：返回一个3D轮廓模型的参数。
project_object_model_3d
功能：把一个3D目标模型的边缘投影到图像坐标中。
project_shape_model_3d
功能：把一个3D轮廓模型的边缘投影到图像坐标中。
read_object_model_3d_dxf
功能：从一个DXF文件中读取一个3D目标模型。
read_shape_model_3d
功能：从一个文件中读取一个3D轮廓模型。
trans_pose_shape_model_3d
功能：把一个3D目标模型的坐标系中的位置转变为一个3D轮廓模型的参考坐标系中的位置，反之亦然。
write_shape_model_3d
功能：向一个文件写入一个3D轮廓模型。
下面的难受有点大
17.2 3D-Transformations
affine_trans_point_3d
功能：对点运用一个随即仿射三维变换。
convert_pose_type
功能：改变一个三维模式的表示类型。
create_pose
功能：创建一个三维模式。
get_pose_type
功能：获取一个三维模式的表示类型。
hom_mat3d_compose
功能：将两个同质三维变换矩阵相乘。
hom_mat3d_identity
功能：构建三维变换同样的同质变换矩阵。
hom_mat3d_invert
功能：插入一个同质三维变换矩阵。
hom_mat3d_rotate
功能：为一个同质三维变换矩阵添加一个循环。
hom_mat3d_rotate_local
功能：为一个同质三维变换矩阵添加一个循环。
hom_mat3d_scale
功能：为一个同质三维变换矩阵添加一个缩放。
hom_mat3d_scale_local
功能：为一个同质三维变换矩阵添加一个缩放。
hom_mat3d_to_pose
功能：将一个同质变换矩阵转换为一个三维模式。
hom_mat3d_translate
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac60ad02a524fda553d87a710a2a99c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee5426893fb8df373ab256f57114e8c/" rel="bookmark">
			maven-plugin(idea)-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package jacco; import com.intellij.openapi.actionSystem.AnAction; import com.intellij.openapi.actionSystem.AnActionEvent; import com.intellij.openapi.project.Project; import com.intellij.openapi.ui.Messages; import com.intellij.openapi.util.SystemInfo; import com.intellij.openapi.util.text.StringUtil; import com.intellij.openapi.vfs.VirtualFile; import com.intellij.openapi.wm.ToolWindow; import com.intellij.openapi.wm.ToolWindowManager; import com.intellij.ui.content.Content; import org.jdom.Document; import org.jdom.Element; import org.jdom.input.SAXBuilder; import java.awt.*; import java.io.*; import java.util.ArrayList; import java.util.List; public class GenerateCoverageReportAction extends AnAction { @Override public void actionPerformed(AnActionEvent event) { Project project = event.getProject(); if (project == null) { return; } VirtualFile projectFile = project.getProjectFile(); if (projectFile == null) { return; } VirtualFile baseDir = project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee5426893fb8df373ab256f57114e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59f6b742a4484fdaac75ec3b9a68925/" rel="bookmark">
			机器视觉在食品安全检测领域的应用与展望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​随着人们生活水平的提高，对食品安全的要求也越来越高。在这种背景下，机器视觉技术作为一种高效、准确的自动化检测手段，在食品安全检测领域扮演着越来越重要的角色。机器视觉系统通过模拟人眼的视觉功能，借助相机和计算机视觉算法，对食品的外观、尺寸、颜色、标签等特征进行快速、无损的检测，保障食品的质量与安全。
​
机器视觉在食品安全检测领域的使用场景 外观缺陷检测 在食品生产过程中，外观缺陷如形状不规则、破损、变色等是常见的质量问题。机器视觉系统能够通过高分辨率的相机捕捉食品图像，并利用图像处理算法识别出不符合标准的产品。例如，在水果分选中，机器视觉系统可以识别出果实的大小、色泽和表面缺陷，从而实现自动分拣。
尺寸测量 对于某些要求形状规格严格的食品，如糖果、饼干等，机器视觉系统可以对其进行精确的尺寸测量，确保每一件产品的尺寸都符合生产标准。
颜色检测 食品的颜色直接影响消费者的购买欲望。机器视觉系统可以对食品的颜色进行检测，评估其是否达到了预设的颜色标准，如肉类产品的新鲜程度通常与其颜色密切相关。
标签与包装检测 正确的标签和完整的包装对于食品安全至关重要。机器视觉系统可以检查食品包装上的日期、批号、条形码等信息是否清晰、正确，同时检测包装是否完好无损。
异物检测 食品生产过程中可能会混入金属、塑料等异物。机器视觉结合X光检测技术能够有效识别和排除这些潜在的危害物质。
机器视觉的重要性
机器视觉系统相较于传统的人工检测具有以下优势： 1. 提高检测速度和效率：机器视觉系统可以连续不断地进行检测，大幅度提高生产线的检测速度和效率。
2. 提高检测准确性：人工检测容易受到主观因素和疲劳度的影响，而机器视觉系统可以在长时间内保持高准确率。
3. 降低成本：虽然初期投资较大，但机器视觉系统在运行过程中可以节省大量的人工成本，并减少因人工检测失误造成的浪费。
4. 提升食品安全水平：机器视觉系统能够及时发现食品生产过程中的安全隐患，有效预防不合格产品流入市场。
未来机器视觉的发展展望 随着技术的不断进步，未来的机器视觉系统将会在以下几个方面有所发展：
1. 智能化：通过深度学习等人工智能技术的应用，未来的机器视觉系统将能够实现更加智能的图像识别和分析能力，提高检测的准确性和适应性。
2. 集成化：机器视觉系统将与其他自动化设备和信息系统更紧密地集成，实现数据共享和决策支持，构建更加智能的生产环境。
3. 高分辨率与高速度：随着相机技术的提升，未来的机器视觉系统将拥有更高的分辨率和处理速度，能够应对更加复杂的检测任务。
4. 多维度检测：结合3D视觉技术、光谱成像技术等，未来的机器视觉系统将能够从多个维度对食品进行检测，如立体形状、成分分析等。
5. 用户友好性：随着技术的普及，机器视觉系统将更加易于操作和维护，降低对操作人员的技术要求。
​总结而言，机器视觉技术在食品安全检测领域的应用日益广泛，它通过提高检测速度、准确性和效率，显著提升了食品安全水平。展望未来，随着技术的不断进步，机器视觉将在智能化、集成化、高性能等方面迎来新的发展机遇，为食品安全保驾护航，为消费者带来更加安全、健康的食品选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59d90f682ee9b13e057b70068b77197/" rel="bookmark">
			(附源码)Sprignboot&#43;资阳农产品推广系统APP 毕业设计40177
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
在信息飞速发展的今天，网络已成为人们重要的信息交流平台。每天都有大量的农产品需要通过网络发布，为此，本人开发了一个基于Android模式的农产品推广系统。
对于本农产品推广系统的设计来说，它主要是采用后台采用java语言、springboot框架，它是应用mysql数据库、Android等技术动态编程以及数据库进行努力学习和大量实践，并运用到了APP的建设中在整个系统的设计当中，具体根据网上农产品推广系统的现状来进行开发的，具体根据用户需求实现网上农产品推广系统网络化的管理，各类信息有序地进行存储，进入农产品推广系统页面之后，方可开始操作主控界面，系统功能包括管理员服务端：后台首页、站点管理（轮播图、公告栏）用户管理（管理员、系统用户）内容管理（社区分享、分享分类）商城管理（商品信息、分类列表、订单列表）；用户客户端：首页、新闻资讯、我的（约车信息、制单信息、乘客订单、抢单信息）等功能。
本论文主要讲述了农产品推广系统开发背景，该系统它主要是对需求分析和功能需求做了介绍，并且对系统做了详细的测试和总结。具体从业务流程、数据库设计和系统结构等多方面的问题。望能利用先进的计算机技术和网络技术来改变目前的农产品推广系统管理状况，提高管理效率。
关键词 ：农产品推广系统；Android技术；Mysql数据库；Java语言 Abstract
With the rapid development of information, the network has become an important information exchange platform. A large number of agricultural products need to be released online every day. For this reason, I developed an agricultural product promotion system based on Android mode.
As for the design of this agricultural product promotion system, it mainly adopts java language and spring boot framework in the background.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c59d90f682ee9b13e057b70068b77197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e2086da6cba8f3f01edfab83fc357c/" rel="bookmark">
			一文讲透时序和序列数据的存储、搜索、分析及挖掘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在算法实践中，快速掌握时序数据的特征，估算出长期趋势、重复变化和循环变化的规律，将具有非常重要的意义。原因是它有助于选择合适的方法去做分析，并且有助于全面理解数据。通过对趋势、循环、季节和非规则成分的运动的系统分析，使人们可以在较合理的情况下，制定出长期或短期的预测（即预报时序）。
如何进行趋势分析
用于特化时序数据的四种主要变化成分：
01 长期或趋势变化 trend movement，它用于反映一般变化方向，其时序图是在较长时间间隔上的数据变化。这种变化反映为一种趋势曲线，或趋势线。确定趋势曲线或趋势线的典型方法包括加权移动平均方法和最小二乘法，详见下面的讨论。
02 循环运动或循环变化 cyclic movement or cyclic variations，主要指循环性，即趋势线或曲线在长期时间内呈摆动迹象，它可以是也可以不是周期性的。即在等时间间隔之间，循环不需要沿着同样的模式演进。
03 季节性运动或季节性变化 seasonal movements or seasonal variations，它反映的是每年都重复出现的事件，如情人节前巧克力和鲜花会的销量突然上升，或在圣诞节节前储藏商品的销售会突然增加。换句话说，季节性运动是指同一或近似同一的模式，在连续几年的有关月份期间重复出现。
04 非规则或随机变化 irregular or random movements，它反映的是随机或偶然事件零星时序变化，如劳工需求，洪水，或企业内发生的人事变动等。
以上有关趋势的，循环的，重复的，和非规则的运动，可以分别用变量 T，C，S，I 表示。时序分析也可以指将时序分解为以上四个基本运动的分析。时序变量 丫 可以表示为四个变量的积(即Y=T%C%S%I)，或四变量之和。其选择通常是凭经验的。“对Y给定一组值(即，1,2,3....，如何确定数据的趋势?”确定趋势的常见方法是按算术平均式序列，计算 n 阶的移动平均值 (a moving average of order n)。
趋势分析的方法 01 趋势分析常见方法：移动平均 采用适当的阶数的加权移动平均，可以消除数据中的循环，重复和非规则的模式，而只保留趋势变化。移动平均可以降低数据集中的变化总量。
因此用移动平均替代时序，可以减少不希望出现的波动，故它也称为平滑的时序(smoothing of time series)。移动平均会丢失系列中的头尾数据，由此有时会生成在原始数据中不会出现的循环或其它变化趋势，并且它可能受一些极端数据的影响。对极端数据的影响，可通过采用适当权重的加权移动平均的方法降低其负面影响。
02 其他计算趋势的方法 其中之一是所谓的徒手法(free-hand method),它是基于用户的判断画一根近似曲线或直线去吻合一组数据。这一方法代价很大，且只对大规模数据挖掘可靠。另一种是最小二乘法,其中以最吻合的曲线 C 作为最小二乘曲线,即曲线具有最小值，其中 d;的偏差或误差是指点 (x,y) 的值y: 与对应曲线 C 的值之间的差值。
03 对循环运动及季节性波动的调整方法 在许多商业交易中，存在预期的季节性波动，如圣诞节期间的旺销。因此，对趋势和循环数据分析，很重要的一点是识别此类重复性变化，并对数据“反季节化 (deseasonalize)”。
为此，引入季节指数 (seasonal index)的概念，用一组数字表示·年中某些月份某变量的相关值。例如，如十月，一一月，十二月的销售分别是全年平均月销量的80%，120%，140%，那么 80，120，140 就是本年度的季节指数。若原始的每月数据由对应的季节指数去除，其结果数据被称为是反季节化的，或者是对季节变量调整过的。反季节化数据可以针对趋势做进一步的调整，即按对应的趋势值去除这些数据。而且，合适的移动平均可以平滑掉的非规则的变化，而只剩下循环变化做进一步的分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e2086da6cba8f3f01edfab83fc357c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9493469dd80b406f1087d1f3f00362d/" rel="bookmark">
			国家电网工资待遇曝光，工会福利真高！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：民工哥技术之路
随着生活节奏的加快，大环境如此的不好，能有一份稳定的工作也越来越重要！因此薪资高福利好工作稳定的国家电网，也就成为了无数应届毕业生的就业首选。国家电网有限公司作为国内经营范围最大的电网企业，是解决电气工程专业毕业生就业的大户，国家电网公司的下属机构因为需求对口，每年会招聘大量该专业的毕业生。网上这张截图的爆光，真假不好判断，但是国网这几年确实火。
下面一起来看看，竞争激烈的国网到底有多香，以及各个省公司的薪资待遇具体情况~
基本薪资构成 国家电网薪资分为薪酬+福利，薪酬包括了基本薪酬和绩效薪酬，福利包含法定福利和补充性福利。
工资构成 基本工资+月度绩效工资+年度绩效工资+辅助工资+年终奖
工资构成中，补贴和奖金视工作能力而定，在工资的整体构成中占比较大。绩效薪酬根据每个岗位性质不同和所承担的工作强度不同而定。
主要福利 国家电网是按照当地最高标准，为员工缴纳社会保险和住房公积金其福利待遇相对而言比较完善。
法定福利+补充性福利：
影响待遇的主要因素 学历不同基本工资也不同
不同地区会有一定的差异
不同的岗位有差异
试用期与转正之间的差异
工龄之间的差异
所有新入职员工前期均从基层技术岗位做起，达到一定年限后可通过“竞聘制”进入管理层各学历层次基层的工作年限规定如下（仅供参考）：博士：2 年、硕士：3 年、本科：5 年、专科：8 年。
各地区的待遇差异 国网各地区的薪资水平分为三个档，如下。
一档：江苏、北京、冀北、浙江、上海、山东
二档：天津、四川、福建、河南、河北、西安、湖北
三档：安徽、宁夏、重庆、江西、辽宁、吉林、黑龙江、蒙东、甘肃、新疆、青海
以上的薪资水平档位（源于网络排名不分先后）一般都指基层岗位，同一档各省份之间还是有一点小差异的，因为每个地方经济水平不同，还有与当年的KPI考核有关。
薪资如何提升 影响因素 各地区的经济水平差异、用电量等因素要占一部分原因。
除了上述的地区差异会影响到薪资待遇外，其实学历、岗位、试用期与转正期、工龄长短等，也都会或多或少影响到具体的薪资水平。
晋升机制 对于新入职的员工来说，想要提高自己目前的薪资水平，就得通过内部的晋升考核机制，晋升至不同的岗位职称。
国家电网晋升方式一般分为个人职称与岗位晋升，个人职称有助理工程师、中级工程师、副高级工程师、高级工程师。
注：以上信息均整理自网络素材，信息可能与实际有所出入，仅供参考，欢迎留言指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1e663e8cba659005f86825e40aefc7/" rel="bookmark">
			数据分析系统有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网时代的到来，数据已经成为企业决策的重要基础。数据的高效处理和分析对于企业发展至关重要。那么，数据分析系统有哪些呢？下面数聚就从多角度一一解析，为企业提供详细的解决方案，助企业构建起一套完善的数据分析体系。
一、数据仓库系统
数据仓库系统作为数据分析的基石，扮演着收集、存储、整合和管理数据的重要角色。它能够集中存储来自多个数据源的原始数据，并进行数据清洗和转换，便于后续的分析工作。常见的数据仓库系统包括MySQL、Oracle和SQL Server等，可以根据实际需求选择合适的数据库。
二、数据可视化系统
数据可视化系统以图形化的方式展示数据，使得复杂的数据变得直观易懂，方便决策者从中获取洞察力。常见的数据可视化工具有Tableau、Power BI和Google数据工作室以及超融合的BI与数字化应用低代码开发平台聚宝等。这些工具提供丰富的图表类型和交互式操作，能够快速生成漂亮而富有信息量的可视化报表。
三、数据挖掘与分析系统
数据挖掘与分析系统能够深入挖掘数据中的潜在关系和模式，帮助企业发现规律和趋势。常见的数据挖掘与分析工具有R语言、Python和SAS等。这些工具提供了强大的算法库和统计分析功能，能够解决复杂的数据挖掘任务和预测建模问题。
四、数据治理与质量管理系统
数据治理与质量管理系统能够确保数据的准确性、完整性和一致性。它包括数据质量评估、数据清洗、数据集成和数据融合等功能。常见的数据治理与质量管理工具有Informatica、Talend和IBM InfoSphere等。这些工具提供了全面的数据管理功能，帮助企业建立数据标准和规范，提高数据质量。
五、业务智能系统
业务智能系统能够将数据分析应用于业务决策，帮助企业发现问题、洞察趋势并制定相应的战略。常见的业务智能工具有QlikView、MicroStrategy和SAP BusinessObjects以及数聚易视等。这些工具提供了灵活的报表和仪表盘设计，帮助企业快速生成有针对性的决策支持。
通过以上几个层次的数据分析系统，企业可以构建起一套完整的数据分析体系。数据仓库系统作为基础设施，提供了数据的存储和管理；数据可视化系统使得数据变得直观易懂；数据挖掘与分析系统深入挖掘数据的价值；数据治理与质量管理系统确保数据的准确性和一致性；业务智能系统将数据分析应用于业务决策。这些系统的协同工作有助于企业全面掌握数据，实现业务的持续发展。
为了适应企业的不断发展和创新，建议企业在建设数据分析系统时，根据自身业务需求和实际情况选择合适的系统和工具，并注重数据的质量和安全性。只有建立起一个完善的数据分析体系，企业才能更好地利用数据驱动业务发展，迎接挑战和机遇。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e5f68f2bddeeb857b1f04e531f623d/" rel="bookmark">
			如何去查看服务器的物理地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开控制面板，点击网络和共享中心
2.点击 以太网
3.点击详情信息
4.查看物理地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149bdce1213f36617e96fc405b1d811f/" rel="bookmark">
			c# Avalonia 绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Avalonia UI框架中，绘图主要通过使用DrawingContext类来实现。DrawingContext提供了一系列的绘图API，可以用来绘制线条、形状、图像以及文本等内容。以下是一个简单的示例，说明如何在Avalonia中进行基础的图形绘制
&lt;!-- MainWindow.axaml --&gt; &lt;Window xmlns="https://github.com/avaloniaui"&gt; &lt;Grid&gt; &lt;Canvas Background="White"&gt; &lt;DrawingPresenter Name="drawingPresenter" /&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/Window&gt; // MainWindow.xaml.cs using Avalonia; using Avalonia.Controls.Primitives; using Avalonia.Media; public class MainWindow : Window { private readonly DrawingPresenter drawingPresenter; public MainWindow() { InitializeComponent(); // 获取到XAML中的DrawingPresenter控件 drawingPresenter = this.FindControl&lt;DrawingPresenter&gt;("drawingPresenter"); // 创建一个DrawingGroup以容纳多个绘图操作 var drawingGroup = new DrawingGroup(); using (var dc = drawingGroup.Open()) { // 绘制一个红色矩形 dc.DrawRectangle(Brushes.Red, null, new Rect(10, 10, 100, 100)); // 绘制一条蓝色直线 dc.DrawLine(new Pen(Brushes.Blue, 2), new Point(50, 50), new Point(150, 150)); // 添加一些变换，如旋转或缩放 drawingGroup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149bdce1213f36617e96fc405b1d811f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/17/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>