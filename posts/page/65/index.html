<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e180edabe4be88591f632471191c19/" rel="bookmark">
			干货丨 用 Python 进行股票分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人们很容易被丰富的数据和各种免费开源工具所吸引。在研究了quandl financial library和prophet modeling library之后，我打算试着探究简单的股票数据。我花了几天的时间，前后写了1000多行Python代码，最终得出了一个完整的股票分析预测工具。虽然我没有自信用这个来投资某些个股，但在整个过程中我学到了很多Python的知识。秉承开源的精神，在这里我打算分享这些代码，让更多的人受益。
本文将展示如何使用Stocker，这是基于Python的股票分析预测工具。我看过一些对象导向的Python编程书籍，但就像大多数编程书籍一样，当我阅读这些书时，我并没有真正理解当中的内容。只有当我在深入一个项目，且遇到从未解决问题时，我才会终于理解那些概念，这也再次证明了实践比理论更重要。除了探索Stocker之外，我们还会涉及一些重要的内容，包括Python的基础知识和加性模型(additive model)。如果你想使用Stocker，可以在GitHub上找到完整的代码以及使用文档。Stocker很简单易用，即使是Python初学者也能学会，我建议每个人都试试。下面让我们一起看看Stocker的分析能力！
Stocker入门
在安装完需要的库之后，我们首先要将Stocker类导入到Python会话中。这里可以使用交互式Python会话或者在脚本目录中启动Jupyter Notebook。
from stocker import Stocker 现在，我们的Python会话中有了Stocker类，接着可以用它来创建类的实例。在Python中，类的实例称为对象，创建对象有时称为实例化或构造。为了创建一个Stocker对象，我们需要传递一个有效的股票代码。
microsoft = Stocker('MSFT') MSFT Stocker Initialized. Data covers 1986-03-13 to 2018-01-16. 现在，我们有了具有Stocker类属性的microsoft 对象。Stocker建立在quandl WIKI数据库上，因此我们可以访问3000多只美国股票，并且可以查看多年的每日价格数据。这里我建议使用微软的数据。尽管微软被认为是开源的对立面，但他们最近做了一些改变，因此我认为他们正在接受开源社区（包括Python）。
Python中的类由两个主要部分组成：属性和方法。没有太多的细节，属性是与类相关的值或数据，或者是类的特定实例（对象）。方法是类中可用于数据的函数。Stocker对象的一个属性是特定公司的股票数据，当我们进行构造时，属性与该对象相关联。我们可以访问该属性，并将其分配给另一变量进行检查：
# Stock is an attribute of the microsoft object stock_history = microsoft.stock stock_history.head() 微软股票数据
Python类的好处是方法（函数）和所操作的数据与同一个对象相关联。我们可以使用Stocker对象的方法来绘制股票的历史股价。
# A method (function) requires parentheses microsoft.plot_stock() Maximum Adj. Close = 89.58 on 2018-01-12. Minimum Adj. Close = 0.06 on 1986-03-24. Current Adj. Close = 88.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46e180edabe4be88591f632471191c19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1614c0fea8826958182c19d5e0b718fe/" rel="bookmark">
			Python进行股票分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python进行股票分析 1.准备工作
可以结合视频进行学习，视频链接：视频
2.工具以及所需库
jupyter notebook tushare、pandas、numpy、matplotlib 3.库的安装
打开anaconda prompt命令框输入以下命令： conda install pandas conda install numpy conda install matplotlib conda install tushare 4.项目介绍
需求：股票分析
使用tushare包获取某股票的历史行情数据
输出该股票所有收盘比开盘上涨3%以上的日期
输出该股票所有开盘比前日收盘跌幅超过2%的日期
问如果我从2010年1月1日开始，每月第一个交易日买入1手股票，每年最后一个交易日卖出所有股票，到今天为止，我的收益如何？
tushare官网：官网
5.项目步骤
5.1 导入模块
# 导入相关的模块 import tushare as ts import pandas as pd from pandas import DataFrame,Series import numpy as np 5.2 数据的获取写入以及读取
代码中所用到的数据集是从tushare官网上获取的，然后将其写入本地，再进行数据的读取。
# 获取某只股票的历史行情数据 df=ts.get_k_data(code='600519',start='2000-01-01') #ts.get_k_data(code=None,start='',end='',) # 将互联网上的股票数据写入到本地 df.to_csv('./gp.csv') #调用to_xxx方法将df中的数据写入到本地进行存储 本地会生成一个gupiao.csv的文件 # 将本地存储的数据读入到df df=pd.read_csv('./gp.csv') df.head() #显示前五行的数据 5.3 处理数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1614c0fea8826958182c19d5e0b718fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/039652ad830d6a85926adeaf1080b2b0/" rel="bookmark">
			Cilium data path analyse（VxLAN &amp; Host Routing with Legacy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备 Node root@node1:~# kubectl get nodes -owide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME node1 Ready control-plane 13d v1.24.6 192.168.64.8 &lt;none&gt; Ubuntu 22.04.2 LTS 5.15.0-75-generic containerd://1.6.8 node2 Ready control-plane 13d v1.24.6 192.168.64.9 &lt;none&gt; Ubuntu 22.04.2 LTS 5.15.0-75-generic containerd://1.6.8 node3 Ready &lt;none&gt; 13d v1.24.6 192.168.64.10 &lt;none&gt; Ubuntu 22.04.2 LTS 5.15.0-75-generic containerd://1.6.8 Host Routing Mode root@node2:/home/cilium# cilium status KVStore: Ok etcd: 3/3 connected, lease-ID=797e8963af868a82, lock lease-ID=3f888935026348b5, has-quorum=true: https://192.168.64.10:2379 - 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/039652ad830d6a85926adeaf1080b2b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/986b3362e88b406847223f0de5014b43/" rel="bookmark">
			Latex科研论文之符号篇（希腊字母&amp;拉丁词）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Latex科研论文之符号篇（希腊字母&amp;拉丁词） 前言一、希腊字母二、拉丁文缩写词 前言 在科研中论文阅读中一定会碰到各种各样的公式符号，了解这些希腊符号及其所在领域常见的表示都对科研有帮助。不同领域，这些希腊字母所代表的意思也不同。本文的内容涉及领域还是计算机、人工智能方面论文的一些释义。还有一些论文常见英文短语、拉丁简写词也能在本文看到，希望读者都能有所收获。
一、希腊字母 希腊字母（英文：Greek alphabet）是希腊语所使用的字母，也广泛使用于计算机、数学、物理、化学、天文等学科。就连alphabet（字母）这个词也是前两个希腊字母 α（Alpha）及 β（Beta）所合成的。
在Latex中想打出这些希腊字母也很容易，直接""+英文注音就可以了(英文注音见上图)。
二、拉丁文缩写词 缩写英文释义中文释义e.g.for example/instance例如i.e.that is， in other words即，换言之，也就是说et al.and others等人etc.and so on等东西viz.that is,namely, to wit也就是说，即vice versa–反之亦然vs.versus相对于（用于比较二者ca.circa大约de facto–（法律未承认但）实际上存在的a.k.a.also known as又名，亦称为cf.confer查阅cp.compare比较w.r.t.with respect to关于,在…方面s.t.subject to（such that）使得……满足……––– 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f60f3bfa3c1a2948cff600858a7315/" rel="bookmark">
			Linux环境下Elasticsearch相关软件安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux环境下Elasticsearch相关软件安装 本文将介绍在linux(Centos7)环境下安装Elasticsearch相关的软件。
1、安装Elasticsearch 1.1 Elasticsearch下载 首先去Elasticsearch官网下载相应版本的安装包，下载之后传输到linux服务器上。
官网地址：https://www.elastic.co/cn/downloads/past-releases
我这里下载的是elasticsearch-7.12.1-linux-x86_64.tar.gz
国内加速下载地址：https://www.newbe.pro/tags/Mirrors/
将下载好的tar包传到服务器上指定位置，解压。
解压后出现elasticsearch文件夹，一般来讲直接启动就行了，但就是有时候会有问题。
启动命令，直接使用bin下的命令：
./bin/elasticsearch 或者是
./bin/elasticsearch -d
-d代表的是后台运行
原因是Elasticsearch不能使用root启动，需要新建其它用户进行启动。
# 创建一个叫zsx242030的用户 useradd zsx242030 # 给zsx242030用户设置一个密码，输入两次密码 passwd ************* # 切换zsx242030用户 su zsx242030 切换用户登录重新启动：
发现存在上面问题，是因为elasticsearch用户没有该文件夹的权限，需要对新用户赋予对目录的操作权限：
# 切换到root用户 su root # zsx243040是当前登陆用户 chown -R zsx242030:zsx242030 /home/zhangshixing/elasticsearch/elasticsearch-7.12.1 # 或者 chown -R zsx242030 /home/zhangshixing/elasticsearch/elasticsearch-7.12.1 然后再尝试启动，发现没有报错：
# 查看进程 ps -ef|grep elasticsearch 我们测试一下：
curl localhost:9200 此时我们在浏览器试一下，把 localhost: 改成服务器 ip：
访问不了，因为 elasticsearch 默认只有 localhost 能访问，怎么办呢，修改配置文件：
vim config/elasticsearch.yml
1、打开network.host的注释， 改成 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f60f3bfa3c1a2948cff600858a7315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f84e43537a1818d1e38a6b204ebd95/" rel="bookmark">
			服务器内存满了解决之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：大清早，突然一通电话吵醒，说项目跑不了，还没洗漱赶紧跑过来，毕竟属于实时在用的系统。排查发现系统盘满了，数据写不进去了，导致报错。接手的项目，从来没考虑服务器问题，那么就解决吧，一通百度。
df -h 查看内存满了
那就du --max-depth=1 -h 查看哪个地方占用了太多，然后发现就是一通删文件，最后发现好像影响不是很大，最后就是lsof -n | grep deleted 查看是不是哪些文件删除了但是还是被占用了，然后确实找到了很多占用的文件，但是不是系统盘的，影响不是很大。
剩下的mysql相关的不敢删，因为删了其他的项目的部分项目停了，不知道为啥。
删了半天，没得删了，内存还是没有释放多少， 那就执行看看那就申请扩容吧。但是扩容又遇到了问题，内存太满，执行
yum install cloud-utils-growpart yum install xfsprogs 提示/var/cache/yum/内存不够。那就继续百度，看到 yum clean all 清除缓存，结果内存没有释放多少，yum 用不了了，没有可用的源
然后根据提示 yum-config-manager --enable base 解决yum 可以用了，成功安装了扩容工具。 但是再执行growpart /dev/vda 1，提示错误
根据指点修改服务器语言，LANG=en_US.UTF-8，再执行growpart /dev/vda 1就可以了
然后执行 resize2fs /dev/vda1 分区扩容文件系统
成功！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb235495507afaa91e6d788b41930778/" rel="bookmark">
			vue&#43;element-UI实现跟随滚动条加载表格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-table当数据量大的时候，实现滚动到底部后加载数据，直接上js代码，有其他需求请各自更改
第一步、在data中定义两个数组
data() { return { innerList:[], //新数组，用于存放全部数据 innerData:[], //el-table表格数组 dom:null, } } 第二步、在数据发生改变的方法中先循环存放一部分数据用于页面显示
watch: { data:{ this.innerData=[]; this.innerList=[]; //将接口中获取到的数据全部存放到数组 this.innerList = this.data.records || this.data.data || []; //先循环出100条数据用于显示 for(let i=0;i&lt;this.innerList.length;i++){ if(i&lt;100){ this.innerData.push(this.innerList[i]); } } } } 第三步、在mounted监听滚动事件
mounted() { // 设置滚动条监听时间加载数据 this.dom = this.$refs.elTable.bodyWrapper; this.dom.addEventListener('scroll', () =&gt; { let scrollTop = this.dom.scrollTop; //滚动距离 let scrollHeight = this.dom.scrollHeight; //滚动条的总高度 let clientHeight = this.dom.clientHeight; //可视区的高度 if (scrollTop + clientHeight === scrollHeight) { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb235495507afaa91e6d788b41930778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ced9a25269a441b8a587285ddbebde1/" rel="bookmark">
			a-tree 实现父级节点禁用，通过子级节点勾选状态控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a-tree 组件实现折叠选择；使其父级节点禁用，通过子级节点的勾选状态来控制是否勾选；如果子级节点勾选任一个，父级节点就勾选中，如果子级节点全部不勾选则父节点不勾选，否则勾选 ，效果如下：
代码实现如下所示：
1、封装组件 setTableToolbar
vue 部分
&lt;template&gt; &lt;div class="toolbar-meta"&gt; &lt;vxe-pulldown ref="vxePulldown" transfer @hide-panel="hidePanel"&gt; &lt;template #default&gt; &lt;a-button shape="circle" @click="open()" :size="16"&gt; &lt;vxe-icon style="font-size: 20px;" name="setting"&gt;&lt;/vxe-icon&gt; &lt;/a-button&gt; &lt;/template&gt; &lt;template #dropdown&gt; &lt;div class="downBox" &gt; &lt;!-- &lt;div class="checkTopAll"&gt; &lt;a-checkbox v-model="checkAll" @change="onCheckAllChange" &gt;全部 &lt;/a-checkbox&gt; &lt;/div&gt; --&gt; &lt;div class="checkItem"&gt; &lt;a-tree v-if="plainOptions.length&gt;0" checkable :checkStrictly="true" :tree-data="plainOptions" :expandedKeys="expandedKeys" :checkedKeys="checkedList" :replace-fields="{children: 'children', title: 'title', key: 'id'}" @expand="onExpand" @check="checkNode" /&gt; &lt;/div&gt; &lt;!-- 底部按钮 --&gt; &lt;div class="downBtn clearfix"&gt; &lt;a-button class="btnOk" @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ced9a25269a441b8a587285ddbebde1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f5bb92bd04204cb49b48015ef10e8b/" rel="bookmark">
			vue中如何让el-date-picker时间选择器组件结束时间不早于开始时间？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在视图中
&lt;el-date-picker v-model="searchForm.startTime" :picker-options="startPickerOptions" type="datetime" :editable="false" format="yyyy-MM-dd HH:mm:ss" value-format="yyyy-MM-dd HH:mm:ss" placeholder="选择开始时间" /&gt; &lt;el-date-picker v-model="searchForm.endTime" :picker-options="endPickerOptions" type="datetime" :editable="false" format="yyyy-MM-dd HH:mm:ss" value-format="yyyy-MM-dd HH:mm:ss" placeholder="选择结束时间" /&gt; 2.javascript
data() { return { searchForm: { startTime: '', endTime: '', }, startPickerOptions: { disabledDate: (time) =&gt; { let endTime = this.searchForm.endTime if (endTime) { return time.getTime() &gt; new Date(endTime).getTime() } } }, endPickerOptions: { disabledDate: (time) =&gt; { let startTime = this.searchForm.startTime if (startTime) { return time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18f5bb92bd04204cb49b48015ef10e8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6eaf2b7574ce3ab57107fb04f28ebb/" rel="bookmark">
			Python数据爬取超详细讲解（零基础入门，老年人都看的懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已收录至Github，推荐阅读 👉 Java随想录
转载于：https://www.bilibili.com/video/BV12E411A7ZQ?spm_id_from=333.337.search-card.all.click
本文是根据视频教程记录的学习笔记，建议结合视频观看。
先看后赞，养成习惯。
点赞收藏，人生辉煌。
讲解我们的爬虫之前，先概述关于爬虫的简单概念（毕竟是零基础教程）
爬虫 网络爬虫（又被称为网页蜘蛛，网络机器人）就是模拟浏览器发送网络请求，接收请求响应，一种按照一定的规则，自动地抓取互联网信息的程序。
原则上,只要是浏览器(客户端)能做的事情，爬虫都能够做。
为什么我们要使用爬虫 互联网大数据时代，给予我们的是生活的便利以及海量数据爆炸式的出现在网络中。
过去，我们通过书籍、报纸、电视、广播或许信息，这些信息数量有限，且是经过一定的筛选，信息相对而言比较有效，但是缺点则是信息面太过于狭窄了。不对称的信息传导，以致于我们视野受限，无法了解到更多的信息和知识。
互联网大数据时代，我们突然间，信息获取自由了，我们得到了海量的信息，但是大多数都是无效的垃圾信息。
例如新浪微博，一天产生数亿条的状态更新，而在百度搜索引擎中，随意搜一条——减肥100,000,000条信息。
在如此海量的信息碎片中，我们如何获取对自己有用的信息呢？
答案是筛选！
通过某项技术将相关的内容收集起来，在分析删选才能得到我们真正需要的信息。
这个信息收集分析整合的工作，可应用的范畴非常的广泛，无论是生活服务、出行旅行、金融投资、各类制造业的产品市场需求等等……都能够借助这个技术获取更精准有效的信息加以利用。
网络爬虫技术，虽说有个诡异的名字，让能第一反应是那种软软的蠕动的生物，但它却是一个可以在虚拟世界里，无往不前的利器。
爬虫准备工作 我们平时都说Python爬虫，其实这里可能有个误解，爬虫并不是Python独有的，可以做爬虫的语言有很多例如：PHP,JAVA,C#,C++,Python，选择Python做爬虫是因为Python相对来说比较简单，而且功能比较齐全。
首先我们需要下载python，我下载的是官方最新的版本 3.8.3
其次我们需要一个运行Python的环境，我用的是pychram
也可以从官方下载，
我们还需要一些库来支持爬虫的运行（有些库Python可能自带了）
差不多就是这几个库了，良心的我已经在后面写好注释了
（爬虫运行过程中，不一定就只需要上面几个库，看你爬虫的一个具体写法了，反正需要库的话我们可以直接在setting里面安装）
爬虫项目讲解 我们的爬取的内容是：电影详情链接，图片链接，影片中文名，影片外国名，评分，评价数，概况，相关信息。
代码分析 先把代码发放上来，然后我根据代码逐步解析
# -*- codeing = utf-8 -*- from bs4 import BeautifulSoup # 网页解析，获取数据 import re # 正则表达式，进行文字匹配` import urllib.request, urllib.error # 制定URL，获取网页数据 import xlwt # 进行excel操作 #import sqlite3 # 进行SQLite数据库操作 findLink = re.compile(r'&lt;a href="(.*?)"&gt;') # 创建正则表达式对象，标售规则 影片详情链接的规则 findImgSrc = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6eaf2b7574ce3ab57107fb04f28ebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00236eacccba70480d1b2255b7a4a48c/" rel="bookmark">
			Springboot实现微信公众号模板消息发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看了一个地推的公众号，每天都会给你推送好几条地推需要的模板消息，好一段时间没有做公众号开发了，最近刚申请了个服务号，刚好可以拿来开发。模板消息需要服务号才可以，申请服务号的话需要企业营业执照，个人的话是没有办法申请的。下面来分享一下我的开发过程。
开发步骤 1.微信公众号服务号 2.准备好 APPID 跟AppSecret 3.开通模板消息，申请一个模板，获取模板ID 4.获取ACCESS_TOKEN 5.获取关注公众号的用户列表 6.选择需要发送的用户，并推送消息 一、资料申请 1.1、获取 APPID 跟AppSecret 1.2、获取 模板消息ID 找不到的话，就在新功能上面去添加；
二、开发 2.1、编写yml配置文件 #公众号配置 wechat: appid: APPID appkey: APP密钥 messageId: 模板ID 2.2、编写配置类 import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component @Data public class WechatConfig { @Value("${wechat.appid}") private String appid; @Value("${wechat.appkey}") private String appkey; } 2.3、获取ACCESS_TOKEN 这里有点类似登录吧，就是用咱们的APPID跟APP密钥送到官方接口那边去验证身份，如果没问题人家就给你返回一个token，方便后面调用接口可以传，让官方接口知道是谁发过来的。token是临时的，有效期是2个小时.
2.3.1、导入工具类 （hutool）maven依赖 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;${hutool.version}&lt;/version&gt; &lt;/dependency&gt; 2.3.2、导入工具类 （hutool）maven依赖 @Component public class ConfigurationService { private String accessTokenUrl = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00236eacccba70480d1b2255b7a4a48c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89c490b2667b2a9ff06ee5dbef963e5/" rel="bookmark">
			OpenGL安装配置-全网最简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、OpenGL学习教程 OpenGL简介
中文学习教程
二、OpenGL第三方库介绍 OpenGL开发的第三方库
三、OpenGL开发环境配置 （1）VS STDIO安装配置 其实VS STDIO下载一个安装程序，然后点点点就行了。
VS STDIO安装 （2）GLEW配置 配置教程
（3）GLFW配置 下载地址
点击红色部分下载
剩下部分与GLEW同理：即挑出include文件和对应你VS版本的lib文件，将他们放在新建文件GLEW中2，然后包含目录添加include、库目录添加lib。 四、OpenGL学习参考 OpenGL：第一个三角形
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995efe1cf6656db3c3a31af96ade37c7/" rel="bookmark">
			ts轮询类函数方法及案例应用，可配置的时间和次数，开启，停止，重新启动等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将介绍如何使用 TypeScript编写一个轮询类。该轮询类支持可配置的轮询时间间隔和次数，并且可以通过 start、stop 和 restart 方法来控制轮询的开启、停止和重新启动。最后也会提供使用案例。
核心代码封装:
/** * 轮询类封装 @author xiexikang 2023.6.6 16:33:00 @param callback：一个回调函数，它会在每一次轮询时被调用。它接收一个数字参数 index，表示当前是第几次轮询。 @param options：一个可选的配置对象，包含两个属性： interval：轮询时间间隔，单位毫秒。 times：轮询次数，默认为无限次。 @desc 方法说明： start(onStart?)：开启轮询。如果已经在进行中，则不会有任何效果。可以传入一个回调函数 onStart，它会在开启轮询时被调用。 stop(onStop?)：停止轮询。如果当前没有进行中的轮询，则不会有任何效果。可以传入一个回调函数 onStop，它会在停止轮询时被调用。 restart(onRestart?)：重新启动轮询。如果当前没有进行中的轮询，则相当于开启新的一次轮询；否则相当于先停止当前的轮询再开启新的一次。可以传入一个回调函数 onRestart，它会在重新启动轮询时被调用。 */ interface PollingOptions { interval: number; // 轮询时间间隔，单位毫秒 times?: number; // 轮询次数，默认为无限次 } type PollingCallback = (index: number) =&gt; Promise&lt;boolean&gt;; export default class Polling { private timerId: ReturnType&lt;typeof setTimeout&gt; | null = null; private count: number = 0; constructor(private callback: PollingCallback, private options: PollingOptions) {} // 开启轮询 start(onStart?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995efe1cf6656db3c3a31af96ade37c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7261f3fdcaa2b1150d9da586fd7add/" rel="bookmark">
			解决删除文件后 WSL2 磁盘空间不释放的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在WSL中安装了许多软件，当不需要使用的时候，删除想释放空间，发现即使删除了软件，c盘空间并没有得到释放。
1 分析原因 不同于 WSL1，WSL2 本质上是虚拟机，所以 Windows 会自动创建 vhdx 后缀的虚拟磁盘文件作为存储。
这个 vhdx 后缀的虚拟磁盘文件特点是可以自动扩容，但是一般不会自动缩容。
一旦有很多文件把它“撑大”，即使把这些文件删除它也不会自动“缩小”。
所以删除文件后还需要我们手动进行压缩才能释放磁盘空间。
2 如何操作 2.1 找到并确定要压缩的虚拟磁盘文件 首先，获取 Linux 分发版的 .vhdx 文件和目录路径，请打开 PowerShell 并使用以下脚本，并将 &lt;distribution-name&gt; 替换为实际分发名称。
(Get-ChildItem -Path HKCU:\Software\Microsoft\Windows\CurrentVersion\Lxss | Where-Object { $_.GetValue("DistributionName") -eq '&lt;distribution-name&gt;' }).GetValue("BasePath") + "\ext4.vhdx" 2.3 压缩虚拟磁盘文件 在 PowerShell 中执行：
# 关闭 WSL2 中的 linux distributions wsl --shutdown # 运行管理计算机的驱动器的 DiskPart 命令 diskpart 在新打开的 DiskPart 命令窗口中执行：
将&lt;path&gt;替换为刚刚获取的.vhdx文件路径
# 选择虚拟磁盘文件 select vdisk file="&lt;path&gt;\ext4.vhdx" # 压缩文件 compact vdisk 大功告成，查看C盘容量，已经释放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4b934ea761bc22a3b6133b7bfdc24c/" rel="bookmark">
			python日记（三）之实现接口请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python+request串行 我们想用 python实现接口请求，requests是非常好用的一个三方库。但是requests发送请求是串行的，需要发送完一条请求后才能发送另一条请求。
安装方法： pip install requests
下面的示例用 requests.get()方法实现串行请求100条数据，参数a,b,c。b和c固定，把100条参数a放在excle中，通过pandas读excle。
Requests 允许使用 params 关键字参数，以一个字符串字典来提供这些参数。
&gt; import pandas as pd &gt; import requests &gt; &gt; #你的接口请求地址 &gt; g_request_url = "你的请求地址" &gt; &gt; #串行请求 &gt; def do_request(request_url,send_data): &gt; response = requests.get(request_url,params=send_data) &gt; return response &gt; &gt; if __name__ == '__main__': &gt; data = pd.read_excel('D:/a_test.xlsx', sheet_name='Sheet1', header=0) &gt; # pandas读excle是Dataform,我们将Dataform转list &gt; excel_list = data.values.tolist() &gt; error = 0 &gt; total = 0 &gt; for data1 in excel_list: &gt; a = data1[0] &gt; payload = {'a': a, 'b': {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b4b934ea761bc22a3b6133b7bfdc24c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c960dbf9477547ad58988eda7d65eb0/" rel="bookmark">
			安装Docker DeskTop之Window系统，WSL2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装说明 Windows系统，官网只提供了Docker Desktop版的安装说明。有两种方式，一种是基于WSL（Windows Subsystem for Linux）2，运行在Linux虚拟机中，使用Linux容器。还有一种是基于Hyper-V，使用Windows容器，直接运行在Windows操作系统中。
Docker Desktop版本包含的组件：
Docker EngineDocker CLI clientDocker BuildxExtensionsDocker ComposeDocker Content TrustKubernetesCredential Helper Docker Desktop版本的特性：
能够将应用程序容器化并部署到任何云平台，支持多种语言和框架。快速安装和设置完整的Docker开发环境。包含最新版本的Kubernetes。在Windows上构建应用程序，可以方便的切换Linux和Windows Server环境。通过本地Windows Hyper-V虚拟化技术，实现快速可靠的性能。在Windows机器上，也能通过WSL 2运行Linux系统。支持代码和数据的卷挂载，支持文件更改通知，可以通过本地主机网络访问运行中的容器。 先决条件 WSL版本1.1.3.0或更高版本。
Windows 11 64位：家庭版或专业版21H2或更高版本，或企业版或教育版21H2或更高版本。
Windows 10 64位：家庭版或专业版21H2（版本19044）或更高版本，或企业版或教育版21H2（版本19044）或更高版本。
在Windows上启用WSL 2功能。
要在Windows 10或Windows 11上成功运行WSL 2，需要以下硬件先决条件：
带有第二级地址转换（SLAT）的64位处理器
4GB系统内存
必须在BIOS设置中启用基于BIOS的硬件虚拟化支持。
安装Docker Desktop 安装包安装 下载并双击Docker Desktop Installer.exe。在出现提示时，确保在配置页面上选择“使用 WSL 2 而不是 Hyper-V”选项。按照安装向导上的说明授权安装程序并继续安装。安装成功后，单击“关闭”以完成安装过程。运行安装程序。如果不是管理员用户，则必须将用户添加到 docker-users 组中。首先以管理员身份运行计算机管理，找到本地用户和组-&gt;组-&gt;docker-users。右键单击以将用户添加到组中。注销并重新登录以使更改生效。 命令行安装 下载Docker Desktop Installer.exe。
执行命令
"Docker Desktop Installer.exe" install 执行命令
start /w "" "Docker Desktop Installer.exe" install 安装参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c960dbf9477547ad58988eda7d65eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f3a56909a1cbfd46396eac22360b9d6/" rel="bookmark">
			[mysql]tar安装mysql报错./mysqld: /lib64/libstdc&#43;&#43;.so.6: version `CXXABI_1.3.11‘ not found（废弃）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错 在执行下面命令的时候报错
./mysqld--user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data/ --initialize
二、解决 注：这个libstdc++.so.6包，新的肯定包含有旧版本，所以下载新的就行
1、看看是否没有对应版本
strings /usr/lib64/libstdc++.so.6 | grep CXXABI
雀食没有1.3.11
2、安装anaconda因为这里头有这个libstdc++.so的包可以直接用
centos安装Anaconda3
3、找到anaconda3中的libstdc++.so包、
可以看到里面有我们需要的版本
4、将anaconda中的该包复制到/lib64目录下
5、修改软连接 ，即让这个软连接指向最新版本即可
ln -sf（强制覆盖）
已经修改好了
三、再次报错 这次是libc.so.6这个包少东西。根据报错信息发现最多需要2.34版本， 因此我们需要下载2.34版本
查看一下咱们目前的版本 下载需要的版本，大版本必里含有小版本的包
wget https://mirror.bjtu.edu.cn/gnu/libc/glibc-2.35.tar.xz tar -xf glibc-2.35.tar.xz -C /usr/local mkdir build cd build/ ../configure --prefix=/usr/local/glibc-2.35/ 报错：make bison compiler太过老旧
centos 升级GCC编译器
yum -y install centos-release-scl yum -y install devtoolset-8-gcc devtoolset-8-gcc-c++ devtoolset-8-binutils scl enable devtoolset-8 bash echo "source /opt/rh/devtoolset-8/enable" &gt;&gt;/etc/profile 升级make
[root@host-10-121-1-105 /test1/knowledge_graph/software]# wget http://ftp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f3a56909a1cbfd46396eac22360b9d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da22e4963cfced0fc1e9bfcc848b2e1/" rel="bookmark">
			[CPU飙升排查]生产CPU飙升,YGC不断的事故
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近给上线还未使用的服务配置监控,监控系统电话将我呼醒 ,导致原本就不多的头发一阵掉落.
还好系统还没有流量进入,先免打扰,第二天再处理.
查看面板情况如下:
FGC正常 YGC不断 CPU飙升 思路确定 分析了下YGC不断,但是没有FGC,CPU飙升,可能出现的情况是哪里有活锁或者死循环了,
这种情况下垃圾是可以被回收的,但是会源源不断地在新生代产生垃圾.
接下来就是申请容器权限,进入查看
Jdk工具使用 Jmap查看下占用高的有没有认识的 1. 运行jcmd,查看java进程id 2. 运行 jmap -histo 22 | head -20 ,查看占用高的类 一般jmap运气好能看到到一个业务类,这种情况下基本能定位到代码在哪里,
但是无意外没看到熟悉的类.
查看线程CPU占用情况 1. 运行 Top -Hp 22 -n 3,查看占用线程 2. printf '%x' 56, 将56转成16进制 3. jstack 22 | grep -A 100 0x38 , 用0x38在java线程栈里搜索,看看什么情况 最麻烦的情况来了,根本没有业务类,框架的问题,接下来只能上arthas了
Arthas使用 1. 下载解压arthas,解压,attach进程 去官网下载arthas https://arthas.aliyun.com/doc/
并且解压 运行 java -jar arthas-boot.jar attach 输入1 进入命令行
2. thread -n 3 列出占用最高的几个线程 毫无意外 和top -Hp 的结果一样,但是方便一些
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da22e4963cfced0fc1e9bfcc848b2e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7542309d15b848f2663204ed67bce3c7/" rel="bookmark">
			docker部署nacos2.2.0&#43;数据持久化配置&#43;效果实测图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统一说明:linux服务器可以借助很多工具实行可视化编辑操作，本文使用finallshell
1.拉取nacos镜像 docker pull nacos/nacos-server:v2.2.0 2.启动镜像 docker run --name nacos \ -p 8848:8848 \ -p 7848:7848 \ -p 9848:9848 \ -p 9849:9849 \ --privileged \ --restart=always \ -e JVM_XMS=256m \ -e JVM_XMX=256m \ -e MODE=standalone \ -e PREFER_HOST_MODE=hostname \ -v nacos_logs:/home/nacos/logs \ -v nacos_conf:/home/nacos/conf \ -d nacos/nacos-server:v2.2.0 --name nacos容器名称 -p 8848:8848代表将当前实例的nacos容器中的8848端口映射到linux的8848端口 7848、9848和9849是nacos 2.2之后需要进行开放 --privileged 容器拥有真正的root权限 --restart=always 容器启动和nacos一起启动 -e JVM_XMS=256m JVM参数 -e JVM_XMX=256m JVM参数 -e MODE=standalone 单例运行 -e PREFER_HOST_MODE=hostname 是否支持hostname 采用默认即可 -v nacos_logs:/home/nacos/logs 将容器/home/nacos/logs目录文件夹映射到宿主机的/mydata/nacos/logs目录下 -v nacos_conf:/home/nacos/conf 外部挂载application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7542309d15b848f2663204ed67bce3c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a631c777d9c5f99d8fceb651e0859b4e/" rel="bookmark">
			搭建 Redis 哨兵模式（一主二从三哨兵）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因服务器资源限制，只是在一台服务器上操作的。Redis版本：redis-6.2.6
安装一个Redis应用，通过三份配置文件，启动三个Redis实例的方式来搭建哨兵模式（一主二从三哨兵）。
因我是在华为云上操作，需要开通以下6个端口：
● 7000（主节点），27000（哨兵通信）
● 8000（从节点），28000（哨兵通信）
● 9000（从节点），29000（哨兵通信）
1、将redis安装到指定路径下 cd /usr/local/soft/ mkdir redis-sentinel # 安装后，redis-sentinel目录下只有bin文件夹 make PREFIX=/usr/local/soft/redis-sentinel/ install 2、复制 redis.conf 与sentinel.conf 到不同的节点目录下 创建三个文件夹：7000（主节点）、8000（从节点）、9000（从节点）；分别在三个文件夹下放置 redis.conf 与 sentinel.conf 配置文件。
cd /usr/local/soft/redis-sentinel mkdir 7000 mkdir 8000 mkdir 9000 # 复制配置文件redis.conf cd /usr/local/soft/redis-6.2.6 cp redis.conf /usr/local/soft/redis-sentinel/7000/ cp redis.conf /usr/local/soft/redis-sentinel/8000/ cp redis.conf /usr/local/soft/redis-sentinel/9000/ # 复制配置文件sentinel.conf cp sentinel.conf /usr/local/soft/redis-sentinel/7000/ cp sentinel.conf /usr/local/soft/redis-sentinel/8000/ cp sentinel.conf /usr/local/soft/redis-sentinel/9000/ 3、修改 redis.conf 文件 3.1、修改基础配置（主从节点通用） 主要有以下几点：
修改监听 ip地址；修改端口；修改密码（主从节点的密码要一致）；日志文件位置 logfile；rdb持久化文件的保存路径；其他路径相关…。 bind 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a631c777d9c5f99d8fceb651e0859b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17c9141c269a2a4a60f949df8fc4f49/" rel="bookmark">
			记账小程序源码，可做毕设或期末作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记账小程序源码
本项目是基于WXML+WXSS+JS+wx-charts(图表插件)+微信云开发平台实现的一款记账小程序。主要的功能有用户登录，记账功能，消费报表，汇率计算等。
下载点这里
运行效果：
登录页面
首页
记一笔页面
消费明细页面
消费报表
各类支出统计
图表
个人中心
日志记录
汇率计算
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fbd48817ff5ff98a75a7d72c0af009/" rel="bookmark">
			TCP实现FTP功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
server
client
makefile
运行顺序
FTP（File Transfer Protocol）是一种用于在计算机网络上传输文件的标准协议。
它允许用户通过网络将文件从一个计算机（称为FTP服务器）传输到另一个计算机（称为FTP客户端）
以下是FTP的一般工作流程：
建立连接：客户端使用FTP客户端软件连接到FTP服务器；身份验证：客户端在连接建立后，提供登录凭据；导航文件系统：验证成功，客户端可以浏览FTP服务器上的文件系统，并选择要上传或下载的文件；上传文件：客户端可以选择要上传到FTP服务器的本地文件，并将其发送到服务器；下载文件：客户端可以选择要从FTP服务器下载的文件，并将其复制到本地计算机；其他操作：FTP还支持其他操作，例如重命名文件、删除文件、创建文件夹等； 项目功能介绍： 均有服务器和客户端代码，基于TCP写的。 在同一路径下，将客户端可执行代码复制到其他的路径下，接下来再不同的路径下运行服务器和客户端。 相当于另外一台电脑在访问服务器。 客户端和服务器链接成功后出现以下提示：四个功能 ***************list************** //列出服务器所在目录下的文件名(除目录不显示) ***********put filename********** //上传一个文件 ***********get filename********** //重服务器所在路径下载文件 **************quit*************** //退出(可只退出客户端，服务器等待下一个客户端链接) server #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;netinet/ip.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; void list_server(int acceptfd, char *buf, int size);	//list功能 void put_server(int acceptfd, char *buf, int size);	//put功能 void get_server(int acceptfd,char *buf, int size);	//get功能 int main(int argc, char const *argv[]) { if (argc !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fbd48817ff5ff98a75a7d72c0af009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4961b6104687db5172f0009e56a596/" rel="bookmark">
			Win10电脑怎么查看图片分辨率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴都想知道win10电脑怎么查看图片的分辨率，其实有一种很简单的办法可以查看，如果你也想知道具体的操作方法，今天就跟着教程一起学习吧。
www.caiwanghao.com
方法/步骤：
1.点击图片右上角的“查看”按键。
2、在出现的界面中点击“详细信息窗格”;如图所示：
3、此时在文件夹(文件资源管理器)的右边会多出一栏，点击图片，会显示出图片的详细信息;如图所示，我们就可以很清楚看到具体的信息了。
以上就是本次小编为大家带来的具体操作教程，希望可以帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60ab44d3918f3d276a746fc6d453478/" rel="bookmark">
			Long.getLong和parseLong的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目上有小伙伴在string转long的时候，看到有getLong方法没多思考就使用了。后面发现出问题，返回了null，继而导致后面一系列报错。引起了大家的重视，纷纷自查代码有没有使用getLong。
经过搜索发现网上也不少人遇到过。收集资料，简单做下整理：
Long.getLong(String s)方法是获取系统参数，并将系统参数转为Long类型。
换句话说，这方法不是进行字符串转换！！！只是获取一些Long类型的系统变量，如果不存在则返回null。比如说可以获取JDK的版本：
Long.getLong("sun.arch.data.model"); //输出32或者64 要实现字符串string转换成long，一般是用Long.parseLong(String s) ，大部分情况下性能最优。
System.out.println(Long.parseLong("jdk")); 这个故事提醒了我们2个点：
1、不能看到方法名很像就直接用，还是多点进去看看源码，或者自己main方法跑一遍。毕竟jdk也是人写的，总会有不规范的地方。
2、见贤思齐，见不贤而内自省。自己写方法的时候名字也尽可能规范点，比如说这个getLong()方法要是叫getSystemPropLong之类的，估计就没这么多人用错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef2a7494c8463380416904b6eacea2dd/" rel="bookmark">
			hadoop安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hadoop安装 零、hadoop启动命令 start-all.sh start-dfs start-yarn hadoop-deamons.sh yarn-deamons.sh hadoop-deamon.sh yarn-deamon.sh mr-jobhistoryserver.sh start historyserver yarn-deamon.sh start timelineserver 一、准备安装包 D:\yilng\bigdata\hadoop\安装包 hadoop-2.6.0.tar.gz
二、使用SCP工具上传到服务器 # 上传路径:/opt/install_bak # 解压路径:/opt/ tar -zxvf /opt/install_bak/hadoop-2.6.0.tar.gz -C ../ 三、修改配置文件 hadoop-env.sh vim hadoop-env.sh export JAVA_HOME=/opta/jdk1.8.0_161 core-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:8020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;4096&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop-2.6.0/tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; hdfs-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.block.size&lt;/name&gt; &lt;value&gt;134217728&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:///opt/hadoop-2.6.0/hadoopdata/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:///opt/hadoop-2.6.0/hadoopdata/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.checkpoint.dir&lt;/name&gt; &lt;value&gt;file:///opt/hadoop-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef2a7494c8463380416904b6eacea2dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf824f0fc1cc066078594d945cecd312/" rel="bookmark">
			IDEA &#43; AI，一天开发一个系统！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近，一直在和同事聊，关于程序员可以用大模型干点啥！
其中有两方面非常刷新我的认知，一个亮点就是AI编程，的确让我感受到了大模型的强大，它颠覆了传统产品研发的思路和实现，让我们的技术边界和开发速率都实现前所未有的改变。
第二个吸引我的就是让IDEA+ChatGPT插件来一个王炸组合，实现编程效率飞起，用自然语言来编程和管理项目。
无论你是初学者还是技术大牛，ChatGPT插件可以将你的代码思路转化为自然语言，只要你的Prompt足够优质，那你将会体验编程的新世界，话不多说，让我们一起揭晓这神奇的现象！
当下的IDEA插件越来越智能化，Bito-GPT4、GitHub Copilot 和 NexChatGPT ，这几个插件是最受程序员喜欢的；
Bito-GPT4插件是由Chat-GPT团队开发的AI编码插件，它通过将GPT-4和ChatGPT引入IDE或者CLI，帮助开发人员更高效地进行编码工作。
GitHub Copilot是一个基于人工智能的编程辅助工具，它可以在程序员输入代码时提供建议的行完成和整个函数体。
NexChatGPT是一款强大的自然语言处理插件，旨在帮助开发者构建更为出色的聊天机器人。
今天我主要来分享GitHub Copilot插件，我们一起来让代码飞起：
step1：打开IntelliJ IDEA编辑器，在菜单栏中选择"File" -&gt; "Settings"。
step2: 在"Settings"窗口中，选择"Plugins"选项卡，然后点击"Marketplace"按钮。
step3: 在搜索框中输入"GitHub Copilot"，然后点击"Search"按钮。完成这一步之后如果没有install你就需要install一下。
安装成功之后，能做哪些事情呢？
copilot 是可以理解上下文补全整个函数 按下tab ：选择当前的建议 按下Alt + ] ：下一条建议 按下Alt + [ ：上一条建议 它可以按方法名生成代码和注释、实现上下文代码推断、按注释生成代码，你也可以选出你项目中部分代码，让copilot给出建议
这样你的程序就能直接起飞了。当然你想更深度的应用大模型，发现自己的更多可能，我推荐「知乎知学堂」联合「AGI课堂」官方发布的：AI大模型公开课，两天时间，让你全面认识AI变革对程序员的真实影响，带你学AI前沿技能知识。
7月20日（本周四）晚20:00 🔥即将开播
立即扫码，即可免费预约
本期名额有限
高度起始于速度（手慢无！！）
如果你也遇到以下问题：
· 公司业绩下行，先裁程序员应景，每日战战兢兢
· 每天疲于会议撕X，只能加班写代码，好想早点儿回家
· 天天被业务指挥，被领导PUA，需要一次翻身机会
那这节课你一定要来听，因为，程序员才是能从AI浪潮中赚取红利的！
圈内大佬，联合主讲
本次公开课「主讲人」是：
前不久「GitHub全球第一的大模型相关开源项目ChatALL」的创作者——孙志岗老师；
曾设计出世界排名第一的算法，一直探索变化、掌握变化，站在技术革新浪潮最前沿的‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍——崔超老师。
本次公开课：不只分享前沿技术知识，更有人才需求、市场趋势分析，带你从自身情况出发，突破瓶颈！无论是职场晋升加薪，还是用技术赚钱，都将有超多收获！
直播答疑环节：还可直接和大佬对话，有任何疑惑，可在直播间提问。
7月20日（本周四）晚20:00 🔥 即将开播！
立即扫码，即可免费预约
高度起始于速度（手慢无！！）
进入直播还可获得🔥「AI大模型资料包」
戳「阅读原文」，还有更多惊喜福利！等你来发现~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f23645b96898df6770eb61146e3ec05/" rel="bookmark">
			安装Docker Engine之二：Linux系统-Debian、RHEL、SLES、Fedora
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debian 内核版本
Debian Bookworm 12 (stable)Debian Bullseye 11 (oldstable) 卸载老版本 for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd 配置apt仓库 sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f23645b96898df6770eb61146e3ec05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245ce28bb86bb3c363470e9c3fcd3e57/" rel="bookmark">
			js - CommonJs和ES6 module的使用和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1，先说区别2，CommonJS3，ES6 module 1，先说区别 阮一峰老师在 ES6 入门 中提到 ES6 模块与 CommonJS 模块有一些重大的差异：
它们有三个重大差异：
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。 2，CommonJS commonjs 规范应用于 nodejs 应用中，在 nodejs 应用中每个文件就是一个模块，拥有自己的作用域，文件中的变量、函数都是私有的，与其他文件相隔离。
CommonJS模块的特点如下：
所有代码都运行在模块作用域，不会污染全局作用域。模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。模块加载的顺序，按照其在代码中出现的顺序。同步的方式加载模块。 使用如下
通过require函数进行导入通过export或者module.exports导出 CommonJS块暴露的方式有三种:
1，第一种暴露方式： exports.方法 || 属性
let name = 'Eula'; let obj = { name:'Eula', age:18 } function say(){ console.log("我是尤菈"); } // 第一种暴露方式 exports.方法 || 属性 exports.name = name exports.obj = obj exports.say = say; require接收:
const receive = require('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/245ce28bb86bb3c363470e9c3fcd3e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12fc583c022f0c77e8ecc65e18129a30/" rel="bookmark">
			uni-app 小程序 uni.showToast字数超过两行自动省略显示不全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如图：
uni.showToast({ title: res.data.msg, icon: "none" }); uni.showToast() 显示消息提示框，显示图标时， title 文本最多显示 7 个汉字长度，在不显示图标的情况下，大于两行不显示。
可以选择更换为使用uni.showModal
uni.showModal({ title: "提示", content: res.data.msg, confirmText: "确定", showCancel: false, success: (res) =&gt; { } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc9f347e43fdba4071ff96de9771069/" rel="bookmark">
			文件IO 文件属性获取，目录操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件属性获取 int stat(const char *path, struct stat *buf); 功能：获取文件属性 参数： path：文件路径名 buf：保存文件属性信息的结构体 返回值： 成功：0 失败：-1 struct stat { ino_t st_ino; /* inode号 */ mode_t st_mode; /* 文件类型和权限 */ nlink_t st_nlink; /* 硬链接数 */ uid_t st_uid; /* 用户ID */ gid_t st_gid; /* 组ID */ off_t st_size; /* 大小 */ time_t st_atime; /* 最后访问时间 */ time_t st_mtime; /* 最后修改时间 */ time_t st_ctime; /* 最后状态改变时间 */ }; 目录操作 //围绕目录流进行操作，DIR* DIR *opendir(const char *name); 功能：获得目录流 参数：要打开的目录 返回值： 成功：目录流 失败：NULL struct dirent *readdir(DIR *dirp); 功能：读目录 参数：要读的目录流 返回值： 成功：读到的信息 败或读到目录结尾：NULL 返回值为结构体，该结构体成员为描述该目录下的文件信息 struct dirent { ino_t d_ino; /* 索引节点号*/ off_t d_off; /*在目录文件中的偏移*/ unsigned short d_reclen; /* 文件名长度*/ unsigned char d_type; /* 文件类型 */ char d_name[256]; /* 文件名 */ }; int closedir(DIR *dirp); 功能：关闭目录 参数：dirp：目录流 使用上面的函数，结合帮助手册
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dc9f347e43fdba4071ff96de9771069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84b7ce46ca7953b900b1a4e016e27da/" rel="bookmark">
			C# 常用控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C# 常用控件 FormbuttoncheckboxcomboBoxdateTimePickerlable\lablelinklistboxpaneltextBoxtoolTip菜单和工具栏menuStrip 菜单栏toolStrip 工具栏statusStrip 状态栏ContextMenuStrip 鼠标右键的菜单栏 容器TabControl 选项卡GroupBox 组 C#开发常用代码三级目录 C# 代码的运行逻辑是事件触发的。事件触发后，后台的代码才会执行。 Form 概念：窗体。
属性配置：属性配置大小，名称，启动位置。
事件配置：事件配置，load（加载），FormClosed(关闭窗体);在窗体加载和关闭的时候选择一些操作。
button 概念：按钮；
事件配置：click(点击);
checkbox 概念：复选框；
事件配置：;
comboBox 概念：下拉框；
事件配置：;
默认值；
slectedChange事件 ；查询应用中使用；
dateTimePicker 概念：时间筛选；
事件配置：;
ValueChange事件 ；查询应用中使用；
lable\lablelink 概念：标签；链接标签
listbox 概念：列表；
应用：歌单列表；更新列表；
panel 概念：容器；划定作用范围；
应用：为radioButton划定作用范围，两个一组；
textBox 概念：文本框；用户输入内容；
应用：用户可以输入内容，并且可以保密输入密码；可以多行输入；
toolTip 概念：提示信息；
应用：提示信息；
！！！用户输入的不需要事件，选择的需要事件。
Q： 常用的是函数，方法，工具啥的是什么图标？
菜单和工具栏 menuStrip 菜单栏 toolStrip 工具栏 statusStrip 状态栏 ContextMenuStrip 鼠标右键的菜单栏 容器 TabControl 选项卡 GroupBox 组 C#开发常用代码 三级目录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5a85eac6be1e017a3af7879b7013a4/" rel="bookmark">
			【尚硅谷云办公问题】Access to XMLHttpRequest at ‘http://localhost:8080/login‘ from origin ‘http://loc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 尚硅谷云尚办公P93跨域问题 1、我在后端关于审批的所有Controller都加了@CrossOrigin //跨域注解
2、写了工具类AccessControlAllowOriginFilter
//解决跨域问题的方法类 @Configuration public class AccessControlAllowOriginFilter implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry){ registry.addMapping("/*/**") .allowedHeaders("*") .allowedMethods("*") .maxAge(1800) .allowedOrigins("*"); } } 参考：(3条消息) SpringBoot解决跨域的5种方式_springboot 跨域_oh LAN的博客-CSDN博客 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cfb5005fc7596555af5b5f9afb1f762/" rel="bookmark">
			Qt 6.6的TextToSpeech改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TextToSpeech improvements for Qt 6.6 Qt 6.6的TextToSpeech改进 July 17, 2023 by Volker Hilsheimer | Comments
​2023年7月17日：Volker Hilsheimer |评论
When we announced the Qt 6 port of Qt Speech for Qt 6.4, one of the comments pointed out that the module would be more valuable if applications could access the generated speech audio data. Qt 6.6 introduces exactly that, plus a few more features and API improvements.
​当我们宣布Qt 6.4的Qt Speech的Qt 6移植时，其中一条评论指出，如果应用程序能够访问生成的语音音频数据，该模块将更有价值。Qt6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cfb5005fc7596555af5b5f9afb1f762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446eb7fbff46311642299b2c26657843/" rel="bookmark">
			C语言-ubuntu下的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
linux命令
【1】打开关闭终端
【2】终端
【3】ls命令
【4】cd 切换路径
【5】新建
【6】删除
【7】复制
【8】移动
【9】常用快捷键
【10】vi编辑器
【11】简单编程步骤
任务：
linux命令 【1】打开关闭终端 打开终端：
1. 直接点击
2. ctrl alt t: 在家目录下打开终端
3. ctrl shift n：在当前目录下打开终端
关闭终端：
1. 直接关闭
2.ctrl d
3. exit
【2】终端 ~：家目录(路径名) /home/hq
查看用户名 ：whoami
查看主机名 ：hostname
查看当前路径 ：pwd
【3】ls命令 功能：列出当前路径下所有文件
ls -a:查看当前路径下所有文件包括隐藏文件
ls -l:查看当前路径下所有文件的详细信息
bsp_lcd(7种文件类型)
b:块设备文件 存储设备（硬盘、sd卡） /dev/sd
s:套接字文件 网络套接字 《网络编程》
p:管道文件 进程间通信 《IO进程》
_:普通文件 .txt .c .h
l:软链接文件 类似于Windows的快捷方式 《linux高级》
c:字符设备文件 鼠标、键盘 /dev/input/mouse
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446eb7fbff46311642299b2c26657843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a7c2689ff40d3b89e804bbffa7ddeb5/" rel="bookmark">
			实战中如何搭建虚拟化KVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近好多公司为了节约成本，对技术硬件上面进行了压缩。借此机会，给同学们讲解一下，如何解决降本增效。让公司老板对你刮目相看。不给开除你的机会。
搭建kvm虚拟化环境，首先了解一下目前市场的虚拟化的产品；win10机器上好多用Vmware的虚拟机或者vmware esxi6.5，虚拟化。linux环境我们用kvm虚拟化环境。
对于大佬而言，必然是linux环境上玩，虚拟化 -请关注微信公众号 --java技术大佬
一。linux环境搭建kvm
建议linux环境-CentOS Stream 8
需要安装先决所需软件是 libvirt、cockpit 和 cockpit-machines
关闭防火墙 systemctl stop firewalld
关闭启动服务器关闭防火墙 systemctl disable firewalld
setenforce 0
vi /etc/selinux/config 修改 SELINUX=disabled
6.egrep -o 'vmx|svm' /proc/cpuinfo 检查是否安装yum
7. yum install -y virt-* libvirt qemu-img 安装libvirtd
8.systemctl enable libvirtd 开机自动启动
9.systemctl start libvirtd 10.virsh list --all 查看是否安装成功
11.yum install cockpit 安装可视化虚拟机管理
12.systemctl enable --now cockpit.socket 开启
13.yum install cockpit-machines 安装machines 使cockpit 支持管理web
14.Cockpit Web GUI 应该可通过 https://localhost:9090 或 https://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a7c2689ff40d3b89e804bbffa7ddeb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02270b940a9988a5d23a280821405bd2/" rel="bookmark">
			element-ui message消息提示组件 ①延长提示消息在页面停留时间②提示消息换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以实现下面的效果为示例
完整代码：
let msgList = ["数据1被引用", "数据2被引用"]; // 使用html的换行标签拼接信息，默认行距太小，此处用两个&lt;br/&gt;&lt;br/&gt; let message = `以下数据不能删除，原因是：&lt;br/&gt;&lt;br/&gt;${msgList.join( "&lt;br/&gt;&lt;br/&gt;" )}`; this.$message({ type: "warning", message: message, // 将 message 就会被当作 HTML 片段处理 dangerouslyUseHTMLString: true, duration:1200, }); 一、延长提示消息在页面停留时间，使用 duration:1200（1200是想延迟的时间，自己定义）
二、提示消息换行
核心代码为：
将 this.$message 的 dangerouslyUseHTMLString 属性设置为 true ，message 就会被当作 HTML 片段处理。消息的换行，通过 &lt;br/&gt; 实现，默认行距太小，推荐使用两个换行标签，即 &lt;br/&gt;&lt;br/&gt; 部分内容借鉴：element UI 中多行消息提示的实现（this.$message的换行）_el-message换行_朝阳39的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a43ec3343485752fa27e1f9518c0071/" rel="bookmark">
			第五章 搭建maven工程及测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建maven工程及测试 5.1 准备pom文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.flink&lt;/groupId&gt; &lt;artifactId&gt;flink&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-scala_2.11&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-streaming-scala --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-scala_2.11&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 该插件用于将Scala代码编译成class文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 声明绑定到maven的compile阶段 --&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;testCompile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a43ec3343485752fa27e1f9518c0071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35deb8a88045e5458568d88ef4fcb11a/" rel="bookmark">
			Hive分区/分桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分区 hive的分区的是针对于数据库的分区,将原来的数据(有规律的数据)分为多个区域,数据和表的信息是不会有变化的,但是会增加namenode的压力
分区的目的是提升查询效率,将原来的文件进行多层次的管理
分区有三种,静态分区,动态分区,混合分区
关键字:partitioned by(字段)
分桶 分桶是对一个表或者一个分区进行更加细粒度的划分
Hive会对分桶的那一列按照哈希值%桶的数量分发到各个桶文件中
在查询的时候就会直接去读取桶中的数据,大大提高效率,如果俩个表关联,并且按照关联字段进行分桶,那么这俩个表进行关联的时候就不会产生笛卡儿积,直接通过桶中的数据去关联
关键字:clustered by(字段)
分区是对字段(值)的分区,分桶是对值的hash值的分桶
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e907a27400b1e0396a25ce469056f8f2/" rel="bookmark">
			Antd ＜a-form＞表单校验：v-model、v-decorator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、表单验证 v-model： &lt;a-form-model ref="form" :model="form" :rules="rules" &gt; &lt;a-form-model-item label="身份证号" name="idCard" prop="idCard" :labelCol="{span: 5}" :wrapperCol="{span: 19}" &gt; &lt;a-input v-model="form.idCard"/&gt; &lt;/a-form-model-item&gt; &lt;/a-form-model&gt; data(){ return{ //验证规则 rules:{ password: [ { required: true, pattern: /^(?=.*[a-zA-Z])(?=.*\d)(?=.*[~!@#$%^&amp;*()_+`\-={}:";'&lt;&gt;?,.\/]).{8,}$/, message: '密码由8位数字、大小写字母和特殊符号组成!!' } ], idCard:[ { required: true, message: '密码不能为空!'}, { validator: this.validateidCard, trigger: 'change' } ], } } } //验证身份证号 validateidCard(rule, value, callback) { console.log(value) }, //表单提交 that.$refs['form'].validate(success =&gt; { if (success === true) { } }) 2、表单验证 v-decorator： &lt;a-form :form="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e907a27400b1e0396a25ce469056f8f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf4e3f5cd259e14d69e5b92f35cafaa/" rel="bookmark">
			如何用 Python 和 Selenium 构建一个股票分析器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文 在金融市场中，股票价格是一个重要的指标，它反映了公司的经营状况、市场需求和供应、投资者的预期和情绪等因素。股票价格的变化会影响投资者的决策和收益，因此，实时分析股票价格是一项有价值的技能。在本文中，我们将介绍如何使用 Python 语言和 Selenium 库来实时分析雅虎财经中的股票价格，并展示一个简单的示例代码。
概述 雅虎财经是一个提供全球金融信息和新闻的网站，它包含了各种股票、指数、基金、期货、期权、外汇等市场数据。Python 是一种通用的高级编程语言，它具有简洁、优雅、易读、易写、易学等特点，适合进行数据分析和可视化等任务。Selenium 是一个用于自动化 Web 浏览器操作的工具，它可以模拟真实用户的行为，如点击、输入、滚动等，并获取网页上的元素和内容。我们需要先安装 Python 和 Selenium 库，然后导入 selenium.webdriver 模块。我们可以使用 selenium.webdriver.Chrome() 方法来创建一个 Chrome 浏览器对象，并使用 get() 方法来打开一个网页。我们可以使用 find_element_by_id() 方法来根据元素的 id 属性来定位一个网页元素，并使用 send_keys() 方法来输入一个股票代码。我们可以使用 find_element_by_xpath() 方法来根据元素的 XPath 表达式来定位一个网页元素，并使用 text 属性来获取元素的文本内容。我们可以使用 time.sleep() 函数来暂停程序的执行，以便等待网页加载完成。我们可以使用 while 循环来不断地获取和打印股票价格，并使用 datetime.datetime.now() 函数来获取当前时间。 亮点 使用 Python 语言和 Selenium 库可以方便地实时分析雅虎财经中的股票价格。使用 Selenium 库可以模拟真实浏览器获取信息，避免被网站识别为爬虫。 案例 下面是一个简单的示例代码，用于实时分析雅虎财经中苹果公司（AAPL）的股票价格，并存入Excel文件：
# 导入 selenium.webdriver 模块 from selenium import webdriver # 导入 time 和 datetime 模块 import time import datetime # 导入 pandas 模块 import pandas as pd # 亿牛云 爬虫代理加强版 设置代理服务器信息 proxyHost = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf4e3f5cd259e14d69e5b92f35cafaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe655204e89459cddbefa5b4ec8bfb2/" rel="bookmark">
			java-logback记录日志到指定文件并且压缩保存日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yml配置文件中加入如下配置:
logging: config: classpath:logback-spring.xml #项目根目录下的xml配置文件 level: root: info 全局日志的级别 file: name: mes.log # 输出日志的名称 logback-spring.xml配置文件如下:
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--scan属性为true时表示配置文件如果发生变更，将会被重新加载；scanPeriod默认单位是毫秒--&gt; &lt;configuration debug="false" scan="true" scanPeriod="3 seconds"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!--输出文件地址--&gt; &lt;property name="log.path" value="logs/mes/"/&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH-mm-ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;info&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!--输出日志到文档--&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;${log.path}/mes.log&lt;/file&gt; &lt;!--日志记录器的滚动策略--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;${log.path}/mes.log.%d{yyyy-MM-dd}.%i.zip&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;10240KB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保存天数--&gt; &lt;!--&lt;maxHistory&gt;2&lt;/maxHistory&gt;--&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH-mm-ss.SSS} %level [%thread] %logger{36} [%file : %line] %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;filter class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fe655204e89459cddbefa5b4ec8bfb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf58f0dfc1daf209c418ff0a9fb21bc8/" rel="bookmark">
			计算机毕业设计springboot共享电单车管理系统3447i【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目包含程序+源码+数据库+LW+调试部署环境，文末可获取一份本项目的java源码和数据库参考。
系统的选题背景和意义 选题背景： 随着城市化进程的加快和人们对环境保护意识的提高，共享电单车作为一种绿色、便捷的交通工具逐渐受到人们的青睐。共享电单车管理系统的出现，为共享电单车的规范运营和管理提供了有效的解决方案。该系统通过利用先进的信息技术手段，实现对共享电单车的定位、租借、归还等功能的监控和管理，为用户提供更好的使用体验。
选题意义： 共享电单车管理系统的开发与应用具有重要的意义。首先，它可以提高共享电单车的使用效率和服务质量。通过实时监控电单车的位置和状态，系统可以及时调度电单车资源，确保用户能够方便地找到可用的车辆，并且减少因车辆故障或停放不当而造成的不便。
其次，共享电单车管理系统可以提升城市交通运输的智能化水平。通过数据分析和算法优化，系统可以预测用户需求和交通拥堵情况，从而合理安排电单车的分布和调度，减少交通压力，提高交通效率。
此外，共享电单车管理系统还可以提供有效的安全保障措施。系统可以实时监测电单车的使用情况，及时发现异常行为和违规操作，并采取相应的措施进行处理。这不仅可以减少盗窃和损坏的风险，还可以提高用户的安全感和信任度。
最后，共享电单车管理系统的开发与应用也有助于推动城市可持续发展。共享电单车作为一种低碳出行方式，可以减少汽车尾气排放，改善空气质量，降低能源消耗。通过合理利用和管理电单车资源，可以促进城市交通绿色化，推动可持续交通发展。
以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本作品的实际功能和技术以下列内容为准。
技术栈： 本项目的技术栈主要包括前端Vue、后端Java程序语言开发、SSM框架和MySQL5.7数据库。
Vue是一种轻量级的JavaScript框架，能够快速构建交互式的用户界面。Vue提供了易于使用的API，使得开发者可以非常容易地创建组件化、可复用的代码。
Java是一种跨平台的编程语言，拥有丰富的库和工具生态系统，广泛用于企业级应用开发。Java在后端服务开发方面拥有强大的性能和可伸缩性，并且能够很好地与其他技术栈集成，如Spring、Hibernate、MyBatis等。
SSM框架是Spring、SpringMVC和MyBatis三个框架的结合体，其整合了各自优势，形成了完整的Web开发框架。本系统客户端向服务器发送请求，SpringMVC拦截请求交给相应的控制器（Controller）处理，使用注解或配置文件定义URL和方法映射，控制器调用Service层中的业务逻辑处理方法，Service层处理完毕后将结果返回给控制器，控制器根据返回的结果选择适当的视图（View）进行展示，视图渲染完成后返回给客户端的过程。
MySQL5.7是一种开源的关系型数据库管理系统，在数据存储和管理方面表现优异。它能够轻松地集成到任何技术栈中，如Java、Python、Ruby等。除此之外，MySQL还具备高可靠性、高稳定性、易扩展性和强数据安全性等特点。
我们选择Vue、Java、SSM框架和MySQL5.7作为本作品的技术栈，具有语言间的无缝协作、代码复用性强、开发效率高、性能高等诸多优势。
3.4系统设计规则 本共享电单车管理系统采用Java技术，Mysql数据库开发，充分保证了系统稳定性、完整性。
共享电单车管理系统的设计与实现的设计思想如下：
操作简单方便、系统界面安全良好：简单明了的页面布局，方便查询共享电单车管理系统管理的相关信息。
2、即时可见：对共享电单车管理系统信息的处理将立马在对应地点可以查询到，从而实现“即时发布、即时见效”的系统功能。
3、功能的完善性：可以管理个人中心、用户管理、站点管理员管理、单车品牌管理、共享单车管理、单车租赁管理、骑行结算管理、单车报修管理、包月套餐管理、用户包月管理、留言板、系统管理模块的修改和维护操作。
3.5系统流程和逻辑 系统业务流程图，如图所示：
图3-1登录流程图
图3-2添加信息流程图
图3-3注册信息流程图
4系统概要设计 4.1 概述 共享电单车管理系统基于Web服务模式，是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在不受时间、地点的限制来使用这个系统。共享电单车管理系统工作原理图，如图4-1所示：
图4-1 系统工作原理图
4.2 系统结构 系统架构图属于系统设计阶段，系统架构图只是这个阶段一个产物，系统的总体架构决定了整个系统的模式，是系统的基础。共享电单车管理系统的整体结构设计如图4-2所示。
图4-2 系统结构图
4.3. 数据库设计 4.3.1 数据库实体 共享单车实体结构图，如图4-3所示：
图4-3共享单车实体结构图
单车租赁实体属性图，如图4-4所示：
图4-4单车租赁实体属性图
单车报修实体属性图如图4-5所示。
图4-5单车报修实体属性图
5.1系统功能实现 当人们打开系统的网址后，首先看到的就是首页界面。在这里，人们能够看到系统的导航条，通过导航条导航进入各功能展示页面进行操作。系统首页界面如图5-1所示：
图5-1 系统首页界面
用户注册：在用户注册页面通过填写用户账号、密码、确认密码、用户姓名、联系方式等信息完成用户注册，用户注册页面如图5-2所示：
图5-2用户注册页面
共享单车：在共享单车页面的输入栏中输入单车编号、所属区域进行搜索，可以查看到共享单车详细信息，并根据需要进行扫码骑行、报修或评论操作；共享单车页面如图5-3所示：
图5-3共享单车详细页面
留言板：在留言板页面的输入栏中输入留言内容并立即提交或重置操作；留言板页面如图5-4所示：
图5-4留言板页面
个人中心：在个人中心页面通过填写用户账号、密码、用户姓名、上传图片、性别、联系方式、包月会员等信息进行更新信息，还可对我的收藏进行详细操作；个人中心页面如图5-5所示：
图5-5个人中心页面
5.2后台模块实现 后台用户登录，在登录页面选择需要登录的角色，在正确输入用户名和密码后，进入操作系统进行操作；如图5-6所示。 图5-6后台登录界面
5.2.1管理员模块实现 管理员进入主页面，主要功能包括对个人中心、用户管理、站点管理员管理、单车品牌管理、共享单车管理、单车租赁管理、骑行结算管理、单车报修管理、包月套餐管理、用户包月管理、留言板、系统管理等进行操作。管理员主页面如图5-7所示：
图5-7管理员主界面
管理员点击用户管理。在用户页面输入管理账号、性别进行查询、新增或删除用户列表，并根据需要对用户详情信息进行详情、修改或删除操作；如图5-8所示：
图5-8用户管理界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf58f0dfc1daf209c418ff0a9fb21bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb8802e76e87861cb6d711863519544/" rel="bookmark">
			uniapp 微信小程序获取当前位置定位不准确问题 uniapp 微信小程序获取当前位置的坐标（经纬度），通过坐标去获取当前具体地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击获取定位-位置授权-显示地址信息
12、
3、
以下3处(！！！必需)必须满足
&lt;template&gt; &lt;view class="other-item"&gt; &lt;view class="min-left"&gt;当前地址&lt;/view&gt; &lt;view class="right-text"&gt; //如果已经获取了地址则显示地址信息 &lt;view v-if="address"&gt; {{address}} &lt;/view&gt; //如果没有获取地址则显示获取按钮（获取地址后获取按钮消失，显示地址信息） &lt;view class="get-location" @click="getCurrentLocation" v-else&gt; &lt;image src="../../static/img/get-location.png"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; manifest.json(！！！必需)
data() { return { longitude: '', // 经度(当前用户位置) latitude: '',// 纬度(当前用户位置) address : ''// 地址信息(当前用户位置的) } }, methods: { //通过微信自带的方法获取到当前的经纬度 getCurrentLocation() { let that = this //uni.getLocation比wx.getLocation精确一点 uni.getLocation({ type: 'gcj02',// (！！！必需)默认为 wgs84 返回 gps 坐标，gcj02（更准确） 返回可用于 wx.openLocation 的坐标 isHighAccuracy: true,//开启高精度定位(！！！必需) success: function(res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddb8802e76e87861cb6d711863519544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a5f2bf2867b4d5236509458373db61/" rel="bookmark">
			字符串加密C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密是一种保护数据安全的重要手段。在C语言中，我们可以使用一些常见的加密算法来保护字符串的安全性。本文将介绍如何使用C语言实现字符串加密。
字符串加密C语言实现
加密算法
常见的加密算法有很多种，比如DES、AES、MD5、SHA-1等。这些算法都具有一定的复杂性，需要一定的数学知识才能理解。在本文中，我们将使用一种简单的加密算法——替换算法。
替换算法是一种基于字母替换的加密算法，它的原理是将明文中的每一个字符替换成密文中对应的字符。比如，将明文中的字母A替换成密文中的字母D，将明文中的字母B替换成密文中的字母E，以此类推。在替换之后，我们就可以得到一个密文，只有知道替换规则的人才能够解密。
实现过程
在C语言中，我们可以使用char类型的数组来存储字符串。要实现字符串加密，我们需要先定义一个替换规则的数组，用来存储明文和密文的对应关系。下面是一个示例代码：
char replace_table[256]; replace_table['A'] = 'D'; replace_table['B'] = 'E'; replace_table['C'] = 'F'; 在这个示例代码中，我们定义了一个长度为256的替换规则数组replace_table，其中，数组的下标是明文中的字符ASCII码值，数组的值是密文中对应的字符ASCII码值。比如，replace_table[‘A’]的值为’D’，表示将’A’替换成’D’。
接下来，我们可以编写一个加密的函数，用来将明文字符串转换成对应的密文字符串。下面是一个示例代码：
void encrypt(char *str) { int i; for (i = 0; str[i] != '\\0'; i++) { if (replace_table[str[i]] != '\\0') { str[i] = replace_table[str[i]]; } } } 在这个示例代码中，我们定义了一个名为encrypt的函数，它的参数是一个指向字符数组的指针。函数内部使用for循环遍历明文字符串中的每一个字符，如果该字符在替换规则中存在对应的密文字符，则使用替换规则进行替换。最终，我们可以得到一个密文字符串。
下面是一个示例代码，用来测试加密函数的效果：
int main() { char str[] = \HELLO WORLD\ encrypt(str); printf(\encrypted string: %s\ \ str); return 0; } 在这个示例代码中，我们定义了一个名为main的函数，它调用了前面定义的encrypt函数，并将一个明文字符串作为参数传递给它。最终，程序输出加密后的密文字符串。
总结
字符串加密是一种保护数据安全的重要手段。在C语言中，我们可以使用简单的替换算法来实现字符串加密。本文介绍了如何使用C语言实现字符串加密，希望对读者有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6edaf6323e5c070a6d3f579da7e5ce/" rel="bookmark">
			第三章 Flink 集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink集群搭建 Flink 可以选择的部署方式有： Local、Standalone(资源利用率低)、Yarn、Mesos、Docker、Kubernetes、AWS。 我们主要对 Standalone 模式和 Yarn 模式下的 Flink 集群部署进行分析。 我们对standalone模式的Flink集群进行安装，准备三台虚拟机，其中一台作为JobManager(hadoop1)，另外两台作为 TaskManager(hadoop2、hadoop3)。 3.1 Standalone 模式安装 1、下载安装包(进入官网下载 flink.apache.org -- downloads) https://archive.apache.org/dist/flink/flink-1.7.2/ flink-1.7.2-bin-scala_2.11.tgz 2、解压安装包flink-1.7.2-bin-scala_2.11.tgz tar -zxvf flink-1.7.2-bin-scala_2.11.tgz 3、开始配置文件(flink-conf.yaml) cd /home/bigdata/flink-1.7.2/conf vim flink-conf.yaml # 主节点地址 33行：jobmanager.rpc.address: hadoop1 # job远程连接端口号 37行：jobmanager.rpc.port: 6123 # jobManager的内存大小 42行：jobmanager.heap.size: 1024m # taskmanager的内存大小 47行：taskmanager.heap.size: 1024m # slot的个数 52行：taskmanager.numberOfTaskSlots: 2 # 并行度 56行：parallelism.default: 4 4、配置slaves节点(同步到其他节点，hadoop2/hadoop3) cd /home/bigdata scp /etc/profile hadoop2:/etc/ scp -r ./flink-1.7.2 hadoop3`pwd` 5、启动flink(在master中启动) /home/bigdata/flink-1.7.2/bin/start-cluster.sh 6、通过jsp查看进程信息 7、查看网页UI 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be6edaf6323e5c070a6d3f579da7e5ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c4f01ceaa103b262af128b36f59270/" rel="bookmark">
			在vscode配置PHP环境及运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载vscode 首先去vscode官网下载Visual Studio Code - Code Editing. Redefined
以下是下载安装步骤：
先是点击我同意此协议
然后这里最好全选上，创建桌面快捷方式是为了后续使用的方便，注意最后一个“添加到PATH”一定要勾选上，这样安装时会自动帮你配置好vscode的系统环境变量，就不需要再手动进行添加了，全选完之后下一步。
点击安装。
到这里就表示已经成功安装了vscode。
双击打开vscode，如果为了后续操作的方便可以先右击以管理员方式打开vscode。打开后看到左边从上到下第四个点击，在输入框输入Chinese，然后选择第一个插件进行下载，不然刚开始打开vscode界面是全英文的。
二、下载PHP 这是PHP官网PHP: Hypertext Preprocessor，点击Download即可可以进行下载。
或者直接去PHP官网的下载地址PHP For Windows: Binaries and sources Releases，这里我们选择PHP8.2（8.2.8）64位线程下载，安全性更高些。
之后将下载好的PHP.zip文件解压缩到自己认为比较合适的地方，解压缩软件在我之前的文章有介绍，不知道的可以去看一下。我这里就将文件放到D盘位置。
三、PHP在WIndows的环境配置 如果在之前的安装过程中没有选择“添加到PATH”,可以进行下面的操作。复制你安装PHP的具体地址，在搜索中输入系统环境，开始编辑系统环境变量，点击环境变量，选择下面的系统环境，找到Path
双击编辑，点击新建，将之前复制的地址粘贴进去，然后连续点击三次确定就好。
验证是否已经成功安装了PHP。同时按住Win+R打开命令提示符，输入php -v就能查看到下载的PHP版本,出现如下就表示成功安装好PHP。
四、Xdebug下载 访问Xdebug官网下载Xdebug: Downloads，选择PHP 8.2 VS16 TS (64 bit)下载。
五、插件的安装及配置 把下载的 php_xdebug-3.2.2-8.2-vs16-x86_64.dll 文件，复制到 php 根目录下的 ext 目录中，然后在 php 根目录下找到 php.ini 文件，这里可能会出现如下两种情况。
(1)（有 php.ini 文件）直接在 php 目录的 php.ini 的文件末尾添加如下配置即可（记得修改路径）。
[xdebug] zend_extension="D:/server/php8/ext/php_xdebug-3.2.2-8.2-vs16-x86_64.dll" xdebug.remote_enable = 1 xdebug.remote_autostart = 1 (2)（没有 php.ini 文件）这里我们可以在 php 根目录下找到 php.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07c4f01ceaa103b262af128b36f59270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f27522fe293c7d3a245768b673525f2/" rel="bookmark">
			【信道容量】基于QPSK&#43;8PSK&#43;16PSK&#43;16QAM数字信号调制信道容量仿真附Matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ⛄ 内容介绍 信道容量是指在给定的信道条件下，能够传输的最大数据率。对于基于QPSK、8PSK、16PSK和16QAM数字信号调制的信道容量，可以通过香农公式计算。
首先，需要确定信道的带宽（B）和信噪比（SNR）。
对于QPSK调制，每个符号可以传输2个比特（2^2 = 4），所以有效比特率（R）为2倍信号速率（也即2倍带宽）。
对于8PSK调制，每个符号可以传输3个比特（2^3 = 8），所以有效比特率（R）为3倍信号速率（也即3倍带宽）。
对于16PSK调制，每个符号可以传输4个比特（2^4 = 16），所以有效比特率（R）为4倍信号速率（也即4倍带宽）。
对于16QAM调制，每个符号可以传输4个比特（2^4 = 16），所以有效比特率（R）为4倍信号速率（也即4倍带宽）。
然后，利用香农公式计算信道容量（C）： C = B * log2(1 + SNR)
其中，C为信道容量，B为信道带宽，SNR为信噪比。
需要注意的是，以上计算结果是理论值，实际的信道容量可能会受到信道衰落、噪声等因素的影响，实际传输速率可能会低于理论值。
⛄ 代码 clcclear allsnr=-10:1:35; %snr是信噪比PsPn=10.^(0.1*snr); %Ps/Pn是信号功率比噪声功率，也是信号和噪声的能量比Capacity=[]; %信道容量log2py=[]; %信道容量公式第一项signal_space=[]; %信号空间sample=66666; %样本个数%QPSK 8PSK 16PSK调制的信道容量曲线for k=2:4 M=2.^k; if k==2 %QPSK信号星座图 signal_space(1) = complex(1,1); signal_space(2) = complex(-1,1); signal_space(3) = complex(-1,-1); signal_space(4) = complex(1,-1); end if k==3 %8PSK信号星座图 signal_space(1) = complex(1,0); signal_space(2) = complex(cos(pi/4),sin(pi/4)); signal_space(3) = complex(0,1); signal_space(4) = complex(cos(3*pi/4),sin(3*pi/4)); signal_space(5) = complex(-1,0); signal_space(6) = complex(cos(5*pi/4),sin(5*pi/4)); signal_space(7) = complex(0,-1); signal_space(8) = complex(cos(-pi/4),sin(-pi/4)); end if k==4 %16PSK信号星座图​​EbNo=10*log10(PsPn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f27522fe293c7d3a245768b673525f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf350959f3e699923b6d61be838cdec/" rel="bookmark">
			深度学习应用篇-计算机视觉-图像分类[3]：ResNeXt、Res2Net、Swin Transformer、Vision Transformer等模型结构、实现、模型特点详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css"&gt; &lt;link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-25cebea3f9.css"&gt; &lt;div id="content_views" class="markdown_views prism-atom-one-dark"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" style="display: none;"&gt; &lt;path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;p&gt;&lt;img src="https://img-blog.csdnimg.cn/63a67cd7f8504a1d8411cc2f4a233385.png#pic_center" alt="在这里插入图片描述"&gt;&lt;br&gt; &lt;strong&gt;【深度学习入门到进阶】必看系列，含激活函数、优化策略、损失函数、模型调优、归一化算法、卷积模型、序列模型、预训练模型、对抗神经网络等&lt;/strong&gt;&lt;/p&gt; 专栏详细介绍：【深度学习入门到进阶】必看系列，含激活函数、优化策略、损失函数、模型调优、归一化算法、卷积模型、序列模型、预训练模型、对抗神经网络等
本专栏主要方便入门同学快速掌握相关知识。后续会持续把深度学习涉及知识原理分析给大家，让大家在项目实操的同时也能知识储备，知其然、知其所以然、知何由以知其所以然。
声明：部分项目为网络经典项目方便大家快速学习，后续会不断增添实战环节（比赛、论文、现实应用等）
专栏订阅：
深度学习入门到进阶专栏深度学习应用项目实战篇 深度学习应用篇-计算机视觉-图像分类[3]：ResNeXt、Res2Net、Swin Transformer、Vision Transformer等模型结构、实现、模型特点详细介绍 1.ResNet 相较于VGG的19层和GoogLeNet的22层，ResNet可以提供18、34、50、101、152甚至更多层的网络，同时获得更好的精度。但是为什么要使用更深层次的网络呢？同时，如果只是网络层数的堆叠，那么为什么前人没有获得ResNet一样的成功呢？
1.1. 更深层次的网络？ 从理论上来讲，加深深度学习网络可以提升性能。深度网络以端到端的多层方式集成了低/中/高层特征和分类器，且特征的层次可通过加深网络层次的方式来丰富。举一个例子，当深度学习网络只有一层时，要学习的特征会非常复杂，但如果有多层，就可以分层进行学习，如 图1 所示，网络的第一层学习到了边缘和颜色，第二层学习到了纹理，第三层学习到了局部的形状，而第五层已逐渐学习到全局特征。网络的加深，理论上可以提供更好的表达能力，使每一层可以学习到更细化的特征。
1.2. 为什么深度网络不仅仅是层数的堆叠？ 1.2.1 梯度消失 or 爆炸 但网络加深真的只有堆叠层数这么简单么？当然不是！首先，最显著的问题就是梯度消失/梯度爆炸。我们都知道神经网络的参数更新依靠梯度反向传播（Back Propagation），那么为什么会出现梯度的消失和爆炸呢？举一个例子解释。如 图2 所示，假设每层只有一个神经元，且激活函数使用Sigmoid函数，则有：
z i + 1 = w i a i + b i a i + 1 = σ ( z i + 1 ) z_{i+1} = w_ia_i+b_i\\ a_{i+1} = \sigma(z_{i+1}) &lt;/span&gt;&lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf350959f3e699923b6d61be838cdec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f421388617d2bf9ad35ef94e5728212b/" rel="bookmark">
			【BP分类】基于BP神经网络的数据分类预测附matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ⛄ 内容介绍 基于BP神经网络(Backpropagation Neural Network)的数据分类预测是一种利用BP神经网络模型来进行数据分类任务的预测和判别。以下是基于BP神经网络的数据分类预测的一般步骤：
数据准备：收集和整理用于分类预测的数据集，包括输入特征和对应的类别标签。确保数据集的质量和充分性。数据预处理：对数据进行预处理，如归一化、标准化、特征工程等，以提高模型的训练效果和泛化能力。BP神经网络模型设计：设计一个合适的BP神经网络模型，包括输入层、隐藏层、输出层等。根据具体问题的特点，选择合适的激活函数和网络结构。模型训练：使用准备好的数据集对BP神经网络模型进行训练。通过反向传播算法和优化器(如梯度下降)来最小化预测结果与实际类别标签之间的误差，以更新模型的权重和偏置。模型评估：使用测试数据集对训练好的BP神经网络模型进行评估，计算分类准确率、精确率、召回率等评估指标，以评估模型的性能和泛化能力。预测与分类：使用训练好的BP神经网络模型对新的输入数据进行预测和分类，得到分类结果。模型优化：根据评估结果和实际需求，对BP神经网络模型进行优化和调整，如调整网络结构、增加正则化手段、调整学习率等，以提高模型的性能和准确度。 基于BP神经网络的数据分类预测可以应用于各种领域，如图像分类、文本分类、语音识别等，以实现对复杂数据的准确分类和判别。
⛄ 代码 %% 清空环境变量 warning off % 关闭报警信息 close all % 关闭开启的图窗 clear % 清空变量 clc % 清空命令行 %% 导入数据 res = xlsread('数据集.xlsx'); %% 划分训练集和测试集 temp = randperm(357); P_train = res(temp(1: 240), 1: 12)'; T_train = res(temp(1: 240), 13)'; M = size(P_train, 2); P_test = res(temp(241: end), 1: 12)'; T_test = res(temp(241: end), 13)'; N = size(P_test, 2); %% 数据归一化 [p_train, ps_input] = mapminmax(P_train, 0, 1); p_test = mapminmax('apply', P_test, ps_input); t_train = ind2vec(T_train); t_test = ind2vec(T_test ); %% 建立模型 net = newff(p_train, t_train, 6); %% 设置训练参数 net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f421388617d2bf9ad35ef94e5728212b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0602f0adb0926aef12a656ecd9ed05e/" rel="bookmark">
			零拷贝技术（DMA、MMAP、sendfile）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零拷贝mmap、sendfile 定义 零拷贝技术主要是解决传统网络I/O操作中发送文件的性能问题：如下图表示一次read和write时传统I/O涉及到的CPU操作：
涉及到4次用户态↔内核态上下文切换，其中read切换两次、write切换两次；涉及到4次数据拷贝。其中DMA拷贝两次、CPU拷贝两次； 上述操作多次的上下文切换与拷贝会影响性能。
可以使用零拷贝技术mmap+write、sendfile和splice来优化。
DMA DMA（Direct Memory Access），即直接存储器存取，是一种快速传送数据的机制。利用它进行数据传送时不需要CPU的参与。
使用DMA拷贝数据会获取一部分系统数据总线资源，用来传输数据，而不需要CPU参数。IO读取也不会引发中断。CPU读取IO操作，系统调用时是会引发中断的。
mmap mmap（memory map）采用虚拟内存，地址映射来减少一次拷贝。可以减少将数据从内核态拷贝到用户态的性能消耗。
如上图所示，从数据并没有从内核态拷贝到用户态，而是直接通过内存映射的方式得到待传文件的虚拟内存地址，在发送的时候，可以通过共享的虚拟内存地址将待发送文件信息拷贝到socket缓存区，发送出去。
#include &lt;sys/mman.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;cstring&gt; int main() { // 打开文件并将其映射到内存中 int fd = open("file.txt", O_RDONLY); size_t size = lseek(fd, 0, SEEK_END); char* data = (char*) mmap(nullptr, size, PROT_READ, MAP_PRIVATE, fd, 0); // 创建套接字并连接到目标地址 int sock = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr("127.0.0.1"); addr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0602f0adb0926aef12a656ecd9ed05e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/64/">«</a>
	<span class="pagination__item pagination__item--current">65/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/66/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>