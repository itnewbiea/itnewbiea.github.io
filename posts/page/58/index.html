<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c080366108636c4c04db86a76d0c538/" rel="bookmark">
			组策略应用（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 3. 组策略应用规则
3.1 组策略的继承与阻止
3.2 组策略的累加与冲突
3.3 组策略的强制生效
3.4 筛选
3.5 软件分发
3.6 精细化密码策略
3. 组策略应用规则 组策略的影响范围非常广泛，域内所有的用户和计算机都可能受到约束，因此，应用组策略之前应明确组策略的各种应用规则，如组策略的继承与阻止，累加与冲突和强制生效等，以方便利用这些规则顺利地实现用户的需求。
3.1 组策略的继承与阻止 在默认情况下，下层容器会继承来自上层容器的GPO。如图4.15所示，OU“销售部”会继承域
“benet.com”的组策略;子OU“销售部_北京”和“销售部_上海”会继承其上级OU销售部”的组策略。
子容器也可以阻止继承上层容器的组策略。在图4.15中，若OU销售部_北京”不需要应用来自上级OU的组策略，可以右击“销售部_北京”，在弹出的快捷菜单中选择“阻止继承”命令，这样OU“销售部_北京”就不会应用任何组策略，如图所示。
3.2 组策略的累加与冲突 如果容器的多个组策略设置不冲突，则最终的有效策略是所有组策略设置的累加。
如图所示，域“benetcom”链接到组策略对象“Default Domain PolicyOU销售部”链接到组策略对象“wallpaper_sales”，则OU“销售部”会同时应用“Default Domain Policy”和“wallpaper_sales”这两个组策略对象。
例如，域“benet.com”的GPO规定用户禁止访问命令提示符，OU“销售部”的GPO规定用户必须使用统一桌面背景，则OU”销售部”下的用户既不能访问命令提示符，也无法更改桌面背景。
如果容器的多个组策略设置冲突(对相同项目进行了不同设置)，组策略则按以下顺序被应用:LSDOU，它表示本地(Local)站点(Site)、域(Domain)组织单位(OrganizationalUnit)。默认情况下，当策略设置发生冲突时，后应用的策略将覆盖前面的策略。
每台运行Windows版本系统的计算机都只有一个本地组策略对象，如果计算机在工作组环境下，将会应用本地组策略对象。如果计算机加入域，则除受到本地组策略的影响外，还可能受到站点，域和OU组策略对象的影响。如果策略之间发生冲突，则后应用的策略起作用。
案例某公司网络采用Windows Server 2016 域环境进行管理，销售部员工的用户账户都位于OU“销售部”，其他部门员工的用户账户分别位于各自部门的OU中。现在公司要求全体员工都不能访问命令提示符，除销售部员工使用销售部指定的桌面背景wallpaper_sales外，统一使用公司指
定的桌面背景wallpaper_company，个人不能随意更改成其他桌面背景。
按照以下步骤操作来实现上述要求。
(1)打开“组策略管理”控制台，编辑GPO“Default Domain Policy选择菜单“用户配置”→“策略”→“管理模板”→“桌面”→“ActiveDesktop”，启用ActiveDesktop，设置墙纸为wallpaper_company,
且不允许更改墙纸。
(2)继续编辑GPO“Default DomainPolicy”，选择菜单“用户配置”→“策略”→“管理模板”→“系
统”，设置“阻止访问命令提示符”为“已启用”。
(3)打开“组策略管理”控制台，右击OU“销售部”，在弹出的快捷菜单中选择“在这个域中创建GPO并在此处链接”命令，新建GPO“wallpaper_sales。
(4)编辑GPO“wallpaper_sales”，选择菜单“用户配置”→“策略”→“管理模板”→“桌面→“Active Desktop”，启用Active Desktop，设置墙纸为wallpaper_sales，且不允许更改墙纸。
(5)验证结果，使用OU“销售部”下的用户账户UserA或UserB登录域，都会应用公司统一的桌面背景wallpaper_sales，并且不能访问命令提示符;使用其他OU下的用户账户UserC或UserD登录域，都会应用销售部统一的桌面背景wallpaper_company，并且不能访问命令提示符。
总之，组策略按如下顺序应用。
(1)首先应用本地组策略对象。
(2)如果有站点组策略对象，则应用。 (3)然后应用域组策略对象。
(4)如果计算机或用户属于某个OU，则应用OU上的组策略对象。
(5)如果计算机或用户属于某个OU的子OU，则应用子OU上的组策略对象。
(6)如果同一个容器下链接了多个组策略对象，则链接顺序最低的组策略对象最后处理，因此它具有最高的优先级。
在图中,OU“销售部”下应用了GPO“wallpaper_sales”和“DefaultDomain Policy”，链接顺序分别为1和2，如果两条策略中某个设置有冲突，请问哪个GPO下的设置生效?
3.3 组策略的强制生效 根据上面的介绍，下级容器可以对上级容器的GPO采用阻止继承的操作，或者下级容器设置一个与上级容器相冲突的GPO，从而使上级容器的GPO不能生效。如何使上级容器的GPO强制效呢?
在图中，如果OU“销售部”的GPO要强制应用到“销售部_北京”和“销售部_上海”，可以通过以下步骤来实现。
右击OU“销售部”下的GPO“wallpaper_sales，在弹出的快捷菜单中选择“强制”命令，然后单击OU“销售部_北京”和“销售部_上海”，在“组策略继承”选项卡中可以看到“wallpapersales”为“强制的”，如图所示。
若该容器中其他GPO的设置与设置为强制的GPO抵触则一律无效。
“强制生效”会覆盖“阻止继承”设置，这也成为网络管理员对网
络进行统一管理的一种方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c080366108636c4c04db86a76d0c538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024764057e7de9cc7d6ac3d02db1d1f3/" rel="bookmark">
			【React 】react 中的路由鉴权与路由拦截
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react 中的路由鉴权与路由拦截 1 路由拦截2 路由鉴权3 路由拦截和路由鉴权结合使用 在 React 中， 路由拦截和 路由鉴权是两个相关但不完全相同的概念。 1 路由拦截 路由拦截（Route Interception）**是指在用户导航到某个路由之前，通过某种逻辑来拦截、检查或修改导航行为。**它可以用于实现权限控制、身份验证、页面加载前的准备工作等场景。在路由拦截中，你可以决定是否允许用户继续访问目标路由或进行其他操作。
实现路由拦截可以借助 React 路由库中提供的特性。下面以 React Router 作为示例，介绍如何实现路由拦截：
首先，确保你的 React 应用中已经安装并导入了 React Router 库。在你的应用中定义路由配置，包括需要拦截的路由以及对应的组件。例如： import { BrowserRouter as Router, Route, Redirect } from 'react-router-dom'; function App() { return ( &lt;Router&gt; &lt;Route path="/private" component={PrivateComponent} /&gt; &lt;Route path="/public" component={PublicComponent} /&gt; &lt;/Router&gt; ); } 在需要进行拦截的组件中，使用 Route 组件的 render 属性来定义拦截逻辑。例如，实现需要登录才能访问的私有页面 import { Route, Redirect } from 'react-router-dom'; // 私有页面（登录才能访问） function PrivateComponent() {、 // 检查用户是否已经登录 const isAuthenticated = checkUserAuthentication(); // 未登录则重定向到登录页面 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024764057e7de9cc7d6ac3d02db1d1f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce230b6dcc85c458923783a18df98d6/" rel="bookmark">
			js改变div大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body, html { width: 100%; height: 100%; margin: 0; } #container { width: 200px; height: 200px; padding: 15px; border: #00cdcd 2px solid; box-sizing: border-box; } .item { cursor: default; width: 100%; height: 100%; background: #757575; } &lt;/style&gt; &lt;/head&gt; &lt;body id="body"&gt; &lt;div id="container"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; //需要调整尺寸的div let c = document.getElementById('container') // body监听移动事件 document.getElementById('body').addEventListener('mousemove', move) // 鼠标按下事件 c.addEventListener('mousedown', down) // 鼠标松开事件 document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce230b6dcc85c458923783a18df98d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d03b345a1d60ed66154c5b892e87f209/" rel="bookmark">
			【JS】关于精度丢失，产生的原因以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		精度丢失案例 在前端开发中，精度丢失是一个常见的问题，特别是在涉及到浮点数计算时。
以下是一些常见的精度丢失案例：
1 简单的加法和减法
0.1 + 0.2 // 结果为 0.30000000000000004 0.3 - 0.1 // 结果为 0.19999999999999996 // 这是因为浮点数的二进制表示无法准确表示某些十进制小数，导致计算结果存在微小的误差。 2 乘法和除法
0.1 * 0.2 // 结果为 0.020000000000000004 0.3 / 0.1 // 结果为 2.9999999999999996 // 在进行乘法和除法时，浮点数计算结果的精度问题更为突出，可能会产生更大的误差。 3 比较运算
0.1 + 0.2 === 0.3 // 结果为 false // 直接比较浮点数可能会导致不准确的结果，因为计算结果的微小误差可能使它们不完全相等。 产生精度丢失的原因 主要原因是计算机内部使用二进制浮点数表示法，而不是十进制。这种二进制表示法在某些情况下无法准确地表示某些十进制小数，从而导致精度丢失。
以下是导致精度丢失的几个常见原因：
无法精确表示的十进制小数：某些十进制小数无法准确地表示为有限长度的二进制小数。例如，0.1 和 0.2 这样的十进制小数在二进制表示中是无限循环的小数，因此在计算机内部以有限的位数进行表示时，会存在舍入误差，导致精度丢失。舍入误差：由于浮点数的位数是有限的，对于无法精确表示的十进制小数，计算机进行舍入来逼近其值。这种舍入操作会引入误差，并导致计算结果与预期值之间的差异。算术运算的累积误差：在进行一系列浮点数算术运算时，舍入误差可能会累积并导致精度丢失。每一次运算都会引入一些误差，这些误差在多次运算中逐渐累积，导致最终结果的精度降低。比较运算的不精确性：由于浮点数的表示精度有限，直接比较浮点数可能会导致不准确的结果。微小的舍入误差可能使得两个看似相等的浮点数在比较时被认为是不等的。数值范围的限制：浮点数的表示范围是有限的，超出范围的数值可能会导致溢出或下溢，进而影响计算结果的精度。 解决精度丢失的方法 以下是一些常见的解决方法：
使用整数进行计算：尽可能地将浮点数转换为整数进行计算。例如，通过将小数位数乘以一个固定的倍数，将浮点数转换为整数，进行计算后再将结果转换回浮点数。这可以减少浮点数计算中的精度问题。使用专门的库或工具：在处理需要高精度计算的场景中，可以使用一些专门的库或工具。例如，JavaScript 中的 Decimal.js、Big.js 或 BigNumber.js 等库提供了高精度的数学计算功能，可以避免精度丢失的问题。避免直接比较浮点数：由于精度问题，直接比较浮点数可能会导致不准确的结果。在需要比较浮点数的情况下，可以使用误差范围进行比较，而不是使用精确的相等性判断。限制小数位数：对于一些特定的应用场景，可以限制浮点数的小数位数，以减少精度丢失的影响。例如，货币计算常常只保留到小数点后两位。使用适当的舍入策略：在需要进行舍入的情况下，选择适当的舍入策略以满足实际需求。常见的舍入策略包括四舍五入、向上取整、向下取整等。注意数值范围：在进行浮点数计算时，要注意数值的范围。超出浮点数表示范围的数值可能会导致精度丢失或溢出的问题。 总之，处理前端精度丢失问题需要谨慎处理浮点数的计算和比较，并考虑使用整数计算、专门的库或工具以及适当的舍入策略来解决问题。根据具体的应用场景，选择合适的方法可以有效地减少精度丢失带来的影响。
在一些简单的场景，可以通过一些技巧来解决浮点数计算精度丢失的问题。
例如：
// 使用这些方法，仍然需要注意数值范围、舍入策略和比较运算等方面的问题，根据具体的应用场景进行适当的调整和处理。 // 加法运算 function add(a, b) { const precision = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d03b345a1d60ed66154c5b892e87f209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23bcbb12a799c54428a184062c772be5/" rel="bookmark">
			【python】正则表达式匹配数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 使用正则表达式处理数据，可进行字符串匹配、提取和替换等操作。在python中，通过re库完成正则匹配的操作。
一、正则语法规则 1.常用匹配符 模式描述^匹配字符串开头$匹配字符串结尾.匹配任意字符*匹配前面的字符零次或多次+匹配前面的字符一次或多次?匹配前面的字符零次或一次[]匹配括号中列举的任意一个字符[^]匹配除了括号中列举的字符以外的任意一个字符 2.常用匹配函数 函数 描述re.match从开始位置开始匹配，如果开头没有则无，语法： re.match（pattern, string）re.search搜索整个字符语法： re.search（pattern, string）re.findall搜索整个字符串，返回一个list 语法： re.findall （pattern, string） 3.常用修饰符 修饰符描述re.I使匹配对大小写不敏感re.M多行匹配，影响 ^ 和 $re.S使 . 匹配包括换行在内的所有字符re.U根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.re.L做本地化识别（locale-aware）匹配re.X该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 二、正则表达式的应用 1.引入库 代码如下（示例）：
import re 2.提取数据 代码如下（示例）：
import re content = ''' &lt;div&gt; &lt;a href="https://baike.baidu.com/item/%E5%B9%BF%E4%B8%9C%E7%9C%81/132473" title="广东省"&gt;广东省介绍&lt;/a&gt; &lt;a href="https://baike.baidu.com/item/%E6%B1%9F%E8%A5%BF%E7%9C%81/19438118" title="江西省"&gt;江西省介绍&lt;/a&gt; &lt;/div&gt; ''' # 获取链接文本内容 part = r'&lt;a.*?&gt;(.*?)&lt;/a&gt;' topic = re.findall(part,content) print(topic ) # 获取完整链接内容 url_part = r'&lt;a.*?href=.*?&lt;/a&gt;' urls = re.findall(url_part,content,re.I|re.S|re.M) for i in urls: print(i) # 获取单个链接 res_url = r'href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23bcbb12a799c54428a184062c772be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f911766f489d38f56dcb6eb729426151/" rel="bookmark">
			芯科科技宣布推出下一代暨第三代无线开发平台，打造更智能、更高效的物联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三代平台中的人工智能/机器学习引擎可将性能提升100倍以上
Simplicity Studio 6软件开发工具包通过新的开发环境将开发人员带向第三代平台
中国，北京 - 2023年8月22日 – 致力于以安全、智能无线连接技术，建立更互联世界的全球领导厂商Silicon Labs（亦称“芯科科技”，NASDAQ：SLAB），今日在其一年一度的第四届Works With开发者大会上，宣布推出他们专为嵌入式物联网（IoT）设备打造的下一代暨第三代无线开发平台。随着向22纳米（nm）工艺节点迁移，新的芯科科技第三代平台将提供业界领先的计算能力、无线性能和能源效率，以及为芯片构建的最高级别物联网安全性。为了帮助开发人员与设备制造商简化和加速产品设计，芯科科技还宣布了其开发人员工具套件Simplicity Studio的下一个版本。Simplicity Studio 6支持芯科科技包括第三代平台在内的整个产品组合，允许开发人员利用市场上最受喜爱的一些集成开发环境（IDE），同时为开发人员提供最新的工具，以支持他们在第二代平台以及第三代平台上持续进行开发。
“我们的第三代无线开发平台是为实现更互联的世界而构建的，这个世界需要开发灵活性，并将更多的智能推向边缘侧。”芯科科技首席执行官Matt Johnson表示。“第三代平台不仅可以满足开发人员和设备制造商当前的需求，而且是为满足他们未来10年的需求而打造的。”
第三代无线开发平台将带来全新的性能、效率和多样化的供应链
最初的第一代平台和当前的第二代平台在帮助扩大物联网规模，连接越来越多的设备和开拓新的应用方面持续获得成功。在很大程度上，这是因为它们形成了一个平台，具备许多开发人员可以利用的共性功能，而第三代平台也遵循了同样的模式。
第三代平台将能够应对物联网持续加速带来的挑战：在重要领域的所有物联网应用中，远边缘（far-edge）设备对更强处理能力的需求，这些重要领域包括但不限于智慧城市和民用基础设施、商业建筑、零售和仓库、智能工厂和工业4.0、智能家居、个人和临床医疗保健；以及对愈发便携、安全的计算密集型应用的需求。第三代平台进一步提升了芯科科技业界领先的无线平台：
更安全、更节能：基于芯科科技业界领先的Secure Vault™技术——率先获得PSA 3级认证的安全套件，第三代平台将包括第二代平台中的所有安全功能，同时实现了新的增强，使其成为物联网市场中最安全的平台。通过对关键功率点进行专门的改进，第三代平台旨在将设备的电池续航时间延长数年。全新的计算水平：第三代平台将带来100倍以上的处理能力提升，包括集成人工智能/机器学习（AI/ML）加速器以用于边缘设备，这实现了将系统处理能力整合到无线片上系统（SoC）中。换句话说，在第三代平台中，随着可编程计算能力的提升，开发人员可以去除占用空间和增加系统成本的微控制器（MCU）。这将包括支持高性能系统的先进数字和模拟外围设备。更具扩展性：第三代平台将是唯一覆盖多种射频的物联网平台，具有通用代码库，可用于跨主要无线协议的30多种产品，这些无线协议包括但不限于低功耗蓝牙、Wi-Fi、Wi-SUN、15.4、多协议和专有协议。这将允许开发人员使用一套通用工具来构建应用并对无数设备进行编程。此外，第三代平台将支持可延伸、可扩展的存储架构，包括对外部闪存的支持。 迁移至22纳米也将为第三代平台带来重要的灵活性。过去几年发生的一些事件和趋势给整个行业的半导体供应链带来了压力，物联网领域也受到了影响。为了最大限度地减少因地域问题给客户造成的风险和中断，第三代平台将在多个地区的多家代工厂生产。
芯科科技Simplicity Studio 6通过对Visual Studio Code的支持强化开发人员工具
芯科科技持续针对客户的开发人员体验进行投资，包括文档，与外部工具供应商的合作，在现有软件开发工具包（SDK）中集成新的插件和扩展功能等方方面面。除了第三代硬件，芯科科技今日还宣布了Simplicity Studio 6，这是其屡获殊荣的应用开发和生产效率提升工具的最新版本。Simplicity Studio 6将为芯科科技的完整产品组合（包括第一代平台和第二代平台）带来最新的开发工具，并为开发人员搭建通往第三代平台的桥梁。
开发人员最常见的反馈之一是，他们不希望被锁定在供应商特定的工具中，而是越来越想利用开源社区和第三方应用程序来增强他们的开发能力。正因为如此，Simplicity Studio 6最大且最具影响力的变化就是将IDE与我们的生产效率提升工具解耦合。随着Simplicity Studio 6的推出，芯科科技将支持开发人员使用一些业界最需要的IDE，而不必被锁定在供应商特定的IDE中。
“我们意识到，开发并没有一种放之四海而皆准的方法。”Silicon Labs物联网开发高级产品经理Michael Norman说道。“这就是为什么我们希望为开发人员提供最完整的工具集，以及对广泛供应商的支持，然后让他们来进行选择。我们想提供一个伟大的平台、多种工具和支持，为他们扫清障碍。”
为了实现这一目标，芯科科技宣布针对微软Visual Studio Code进行扩展，这是当今世界最流行的软件开发工具。这一扩展将支持芯科科技新的或现有的应用程序在Visual Studio Code中进行开发。芯科科技扩展工具的公共测试版（Beta release）今日起可在Visual Studio Code Marketplace中下载，其可与最新版本的Simplicity Studio 5配合使用。
此外，作为开发过程中的支持性合作伙伴，芯科科技今日还发布了用于Amazon Sidewalk的扩展版开发人员之旅（Developer Journey）工具，以及全新的Matter开发之旅（Development Journey）工具。两者都依靠芯科科技的强大力量打造，提供利用这两种技术进行开发所需的工具、文档、硬件和专家支持。
芯科科技Works With开发者大会汇聚最优秀、最突出的机构和人士来讨论嵌入式物联网开发
上述平台和工具均是在芯科科技一年一度的第四届Works With开发者大会上宣布的。本次会议于美国中部时间8月22日至23日（北京时间8月22日至24日）以全程免费、在线的方式举行，所有会议将在首播后不久提供随选回放服务。今年，Works With大会涵盖了从蓝牙和Wi-Fi到Matter和低功耗广域网（LPWAN）的所有内容，并探索了安全和AI/ML方面的最新进展。有兴趣在8月22日和23日参加会议的人士，以及有兴趣在晚些时候观看会议随选回放的人士，都可以在这里注册参加2023年Works With开发者大会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ace68dff690a358efb1eed84e2f329/" rel="bookmark">
			卧槽！1000T 的网盘资源！搞来了....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云盘最近老火了，云盘空间够大、下载也不限速，但是资源这方面还是差点，所以今天来给大家分享一个站点，里面有很多网友分享的阿里云盘资源，这下啥都有了！
先给大家瞅瞅这个站点长啥样：
虽然卖相一般，光分享链接就有 290+，且个个是合集。
获取资源
点击下方卡片关注后回复【阿里云】
没有任何套路！
比如 ePUBee 小蜜蜂这个电子书资源站，这个里面就有把小蜜蜂全站扒下来的阿里云盘资源。
合计 432G 的电子书，点进去看你会发现全都是整理好的 epub 格式的电子书
比如超2000册的计算机图书，永久有效
比如各大企业面试笔试汇总
比如 10000+ 的 PPT 模板：
这个里面，还不乏大厂的内部培训资料、自媒体教程、理财课、心理学、面试汇总等等等等，想了解的小伙伴还是去亲自去看一下吧。
帖子的最前方，有 9 个资源大杂烩，套娃收录的是像这个帖子一样的资源文档。
点开可以看到持续更新177天的腾讯文档，资源内容包罗万象，影视音乐、全球各国电视剧、动漫漫画等等。
这里还有上千个阿里云盘分享链接，大多数也都是合集的那种，一共算下来有 2400T 的资源。
获取资源
关注后回复【阿里云】
没有任何套路！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5970ee202040e5f9f66d1862ebeee2f6/" rel="bookmark">
			Python快速检验数据分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设检验的前提是确定数据的分布，本文介绍Python检验数据样本是否服从一定分布。使用方法是柯尔莫可洛夫-斯米洛夫检验（Kolmogorov–Smirnov test，K-S test），K-S检验方法适用于探索连续型随机变量的分布，对于离散分布（二项分布和泊松分布）需要使用其他方法进行检验。
KS检验语法 K-S检验方法能够利用样本数据推断样本来自的总体是否服从某一理论分布，是一种拟合优度的检验方法，这里使用scipy.stats.kstest() 实现单样本检测， scipy.stats.ks_2samp() 实现双样本检测。下面通过两个示例进行说明。
单样本检测 首先生成测试样本数据：
from numpy.random import seed from numpy.random import poisson #set seed (e.g. make this example reproducible) seed(0) # generate dataset of 100 values that follow a Poisson distribution with mean=5 data = poisson(5, 100) 下面代码显示如何执行KS检验，检验data数据集是否符合正太分布。
from scipy.stats import kstest # perform Kolmogorov-Smirnov test kstest(data, 'norm') # 输出结果 # KstestResult(statistic=0.9072498680518208, pvalue=1.0908062873170218e-103) 从输出可以看到，检验统计量为0.9072，对应的p值为1.0908e-103，既然P值小于0.05，我们拒绝原假设，有足够证据说明样本不服从正太分布。因为我们使用poisson() 函数生成数据，样本数据应该服从泊松分布。
除了正太分布，还可以检测分布，如指数分布、伽马分布、韦伯分布、T分布、F分布等。
双样本KS检验 首先我们生成两个不同分布的样本数据：
from numpy.random import seed from numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5970ee202040e5f9f66d1862ebeee2f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b5991f246de7f1c3bbf050d3fcc377/" rel="bookmark">
			React项目build打包后，页面空白的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
React项目执行 build 命令后，在本地服务器打开页面 是空白的，而且控制台报错
如下图所示 解决方法
打开根目录下的 package.json 文件，添加如下代码
{ "name": "testproject", "version": "0.1.0", "homepage": "./", // 加上这行代码，然后重新 build 即可 "private": true, "dependencies": { "@ant-design/icons": "^5.2.5", ... } ... } 重新 build 之后，启用本地服务 打开 index.html 文件（本文中用 Live Server 插件启用本地服务，你也可以用其它的），如下图所示
打开后，页面可正常访问，如下图所示
注意：页面虽然可以正常访问，但如果在地址栏 直接输入URL 回车，就会变成404页面的。这种情况没关系，当你最后把项目 部署到正式服务器上时，在nginx中配置以下代码即可。
location / { try_files $uri /index.html; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb15a5133fad9666cdadfe712560a9e/" rel="bookmark">
			java使用线程时注入SpringBoot接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 编写多线程注入方法工具类
import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.context.annotation.Configuration; /** * 多线程注入方法,工具类 * @Author my.guo */ @Configuration public class SpringBeanUtil implements ApplicationContextAware { /** * 上下文对象实例 */ private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { SpringBeanUtil.applicationContext = applicationContext; } /** * 获取applicationContext * @return */ public static ApplicationContext getApplicationContext(){ return applicationContext; } /** * 通过name获取 Bean. * @return */ public static Object getBean(String name) { if (applicationContext == null){ throw new RuntimeException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beb15a5133fad9666cdadfe712560a9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae317cb5f445836ba264cdaaab0ab701/" rel="bookmark">
			微信小程序自定义封装picker实现直接显示年月日时分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如入下：
第一步，封装datepicker.js，可放在utils文件夹下。代码如下：
const formatNumber = n =&gt; { n = n.toString() return n[1] ? n : '0' + n } function getCurrentDate(){// 获取当前时间 let date = new Date(); let currentYears=date.getFullYear(); let currentMonths=date.getMonth()+1; let currentDay=date.getDate(); let currentHours=date.getHours(); let currentMinute=date.getMinutes(); var year=[currentYears].map(formatNumber) var mm=[currentMonths].map(formatNumber) var dd=[currentDay].map(formatNumber) var hh=[currentHours].map(formatNumber) var min=[currentMinute].map(formatNumber) // return year+'年'+mm+'月'+dd+'日'+hh+':'+min; return year+'-'+mm+'-'+dd+' '+hh+':'+min; //2023-08-23-09:43 } function GetMultiIndex(){ //一点开picker的选中设置 let arr=loadPickerData() console.log(arr); let date = new Date(); let currentYears=date.getFullYear(); let currentMonths=date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae317cb5f445836ba264cdaaab0ab701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9e98d57e124a10c59e2f2f669fbf12/" rel="bookmark">
			mapper接口与mapper.xml文件之间的字段映射异常解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter ‘accountNo’ not found
在mapper接口对应的方法中加入@Param("")注解，例如：
User select (@Param(“userId”) int userId);
原文链接：https://blog.csdn.net/qq_40910541/article/details/108420953
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5acb84032476bb200379aba0f2a23751/" rel="bookmark">
			python如何输出数字后三位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要输出数字的后三位，首先需要了解一些基础知识。在Python中，浮点数可以用round()函数来保留小数位数。这个函数有两个参数：要操作的数字和要保留的小数位数。例如：round(3.1415926, 3)将返回3.142，其中第二个参数3表示保留3位小数。
一、使用round()函数输出数字后三位 使用round()函数是最简单也是最基础的方法。例如，如果要将一个数字保留三位小数并输出，可以这样写：
num = 12345.6789 print(round(num, 3)) 这个例子会输出12345.679，也就是保留了小数点后三位。
二、将数字转换为字符串并手动处理 如果需要将三位小数对齐，可以使用string操作。例如：
num = 12345.6789 s_num = str(num) s_num += '0'*(s_num.count('.')+3-len(s_num.split('.')[1])) print(s_num) 这个例子输出的结果将是"12345.679"。
在这个例子中，我们首先将数字转换为字符串，然后使用count()函数计算小数点后面的位数，加上3之后就得到了我们需要的总位数。接着使用split()函数分离小数点前面和后面的部分，再使用字符串的乘法将0添加到后面，最后输出。
三、使用字符串格式化输出 另一种常用的方式是使用字符串格式化输出。例如：
num = 12345.6789 print("%.3f" % num) 这个例子将输出12345.679，与round()函数实现相同。
在这个例子中，我们使用了%.3f这个格式字符串，其中的%.3f表示输出一个保留三位小数的浮点数。
四、使用decimal模块输出数字后三位 如果需要更精确的小数运算，可以使用Python标准库中的decimal模块。例如：
from decimal import Decimal, ROUND_HALF_UP num = Decimal("12345.6789") num = num.quantize(Decimal('0.000'), rounding=ROUND_HALF_UP) print(num) 这个例子同样输出12345.679，但与前面的方法比较，结果更加精确。
在这个例子中，我们首先将数字转换为Decimal类型，并且指定保留三位小数，使用ROUND_HALF_UP进行四舍五入运算，然后输出。
五、使用numpy模块输出数字后三位 如果需要进行科学计算，可以使用Python常用的科学计算库numpy。例如：
import numpy as np num = 12345.6789 num = np.round(num, decimals=3) print(num) 这个例子同样输出12345.679，而且与前面的方法比较，代码更加简洁。
在这个例子中，我们使用numpy库中的round()函数进行小数保留，指定保留三位小数，并输出结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4ef4e3880e55ffd49bc3cd0f17a568/" rel="bookmark">
			Codeforces刷题题解（思维&#43;数构&#43;字符串）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem - B - CodeforcesCodeforces. Programming competitions and contests, programming communityhttps://codeforces.com/contest/1583/problem/B
1.B. Omkar and Heavenly Tree 题意： 建一个树有n个点,n-1条边,有m个限制,a直接连b,中间不能有c。
思路： 用set先把1~n连起来,然后把中间b删去,也就是把限制都删掉,找到一个根可以连到其它所有点,然后把set的头作为根,之后所有除根以外的点都直接连上根。
//gyeolhada...in bloom...dream...ricky //string s="ricky";s.insert(0,"hello ");--&gt;hello ricky //transform(s.begin(), s.end(), s.begin(), ::tolower); //2^30=1e9+73741824 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define sall(x) (x).begin(),(x).end() #define ball(x) (x).rbegin(),(x).rend() #define pii pair&lt;int,int&gt; #define pll pair&lt;ll,ll&gt; #define inf 0x3f3f3f3f3f3f3f3f #define Y cout&lt;&lt;"YES"&lt;&lt;endl #define N cout&lt;&lt;"NO"&lt;&lt;endl	void ZB1() { int n,m; cin&gt;&gt;n&gt;&gt;m; set&lt;int&gt;s; for(int i=1;i&lt;=n;i++) { s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4ef4e3880e55ffd49bc3cd0f17a568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8f45998fc34abee7fb5f943d41607a/" rel="bookmark">
			如何实现微信公众平台（本地测试号）功能，动态二维码、授权获取code、置换openId，操作全流程，带避坑，超详细~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
壹|微信平台操作流程
一、前置准备
二、流程梳理
三、具体实施（代码附录
1. 前端页面生成二维码（vue-elementui）
2. 授权页面
3. Java后端接收code参数，获取用户openId
贰|微信公众开发二维码
一、 解决 H5 跳转路径的 # 问题
二、二维码中传递信息，并在授权页面获取
叁|补充
壹|微信平台操作流程 一、前置准备 JS回调在用户信息获取等时需要使用，目前暂不使用。在测试时必须要扫码关注测试公众号才能测试扫描之后形成的动态二维码。（注：域名本身没有特定含义，可以随便定义，也可以通过内网穿透工具获取网络域名，可同后续的网络回调域名保持一致）
首先我们需要在微信公众平台注册一个测试账号。可跳转链接：微信公众平台登录成功页面，其中的 appID，appsecret 都需要后续用到（注意保护隐私）。这里因为是本地测试，所以不需要URL和Token信息。 在网络授权用户信息处点击“修改”，修改回调域名（这里要注意不加 http://)。
这里讲一下我当时写网络授权回调域名的心路和遇到的问题:
最开始的时候我在网上找了很多资料，然后发现全都是打码的，不知道该些啥，然后根据官方文档和网上资料，在这里写了一个自定义的域名 "www.hanying.com", 然后保持JS接口一致，接着我将生成二维码的text路径中的 redirect_uri=www.hanying.com，并在本地hosts文件中，将 ip地址跟这个域名进行映射，随后我调用nginx静态web服务器进行监听 80 端口，如果监听到访问这个路径就跳转到 nginx/html/bangding/xx.html页面。 这里还一切顺利，但是当我在html页面设置点击确认按钮发送 ajax 请求给后端传 code 值时，一直发送不了。后来归结起来有三个简单的问题：其一，我没有在html页面引入JS或JQuery，所以使用 $.ajax 没有效果；其二，我的手机用的是流量，我的电脑用的是公司wife，不在局域网下，而ajax发送请求的路径为本地（ip）路径，所以无法接受成功；其三，我的路径中scope=SCOPE，权限错误，所以在解决10003错误以后又爆了10005错误。 如果在这里扫描二维码出现 10003 错误，检查以下三个地方配置是否一致，回调域名是否加了http://,以及url路径是否进行了编码（需要编码url路径）。 如果出现了 10005 错误，是权限不足，检查scope属性，看看是否为 scope=snsapi_base。
二、流程梳理 可以参考官方开发文档：微信网页开发-网页授权
生成二维码（我这里是通过前端生成），用户访问跳转自定义授权页面用户跳转到授权页面，获取code后端获取 code后，通过code换取网页授权access_token和openId保存openId到数据库（有的需要别的操作，可根据官方文档具体操作） code： 微信授权码，就像一个临时的票据，用来访问微信服务器获取用户的 openId 和 token 令牌。
state： 状态码。
scope： 权限域，微信授权中有两种权限，一种是snsapi_base，一种是获取用户信息snsapi_userinfo。
appId：访问的微信公众号唯一ID。
redirect_uri：回调域名，可以链接到自定义的授权页面，用户访问时获取code信息（需进行url编码）。
三、具体实施（代码附录 参考了很多，最主要参考还是其他博客，虽然很想把链接附上，但是找了很久也没找到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc8f45998fc34abee7fb5f943d41607a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658986a4de4d138bdd7830abde3adc30/" rel="bookmark">
			C&#43;&#43;类模板的特化（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍类模板的特化、局部特化和缺省模板实参；
1.类模板的特化 类模板的特化（Class Template Specialization）是指为特定的模板参数提供自定义实现的过程。通过特化，我们可以针对某些特定的类型或条件提供不同的行为或实现；
如果需要特化一个类模板，需要特化该模板中的所有成员函数；
模板的特化注意事项：
需要将模板写成template &lt;&gt;，并且需要指明特定的类型，下面示例需要特化std::string的类型，成员函数按照正常的函数实现即可
template &lt;&gt; class Stack &lt;std::string&gt; {} 示例
/* * @brief: class complates * @complie: g++ -g *.cc -o d -std=c++11 * @autor: your name * @date: 2023/08/22 */ #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;stdexcept&gt; template &lt;class T&gt; class Stack { private: std::vector&lt;T&gt; elems; public: void push(T const&amp;); void pop(); T top() const; bool empty() const { return elems.empty(); } int32_t getElemsSize() const { std::cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658986a4de4d138bdd7830abde3adc30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4af645fe4097776194f54d46416e6d/" rel="bookmark">
			十二. Kubernetes Pod 与 探针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. PodPod 中的多容器协同Pod 的组成与paush (重要)Pod 的生命周期Pod状态与重启策略静态Pod 二. 探针1. livenessProbe存活探针2. readinessProbe就绪探针3. startupProbe启动探针4. 就绪、存活两种探针的区别5. 就绪、存活两种探针的使用方法与相关属性解释6. startupProbe启动探针与属性解释7. 探针总结 三. Pod的tolerations容忍策略相关k8s内置的污点与节点异常容忍时间示例 一. Pod 官方文档什么是Pod: 在docker中支持以containers容器的方式部署应用,但是一个容器只能部署一个软件应用,实际情况中如果想让一个软件正常运行通常需要部署多个应用配合运行才能对外提供功能,docker中针对这种情况会把这些应用部署为一组容器,比较繁琐Pod是k8s中最小的部署单元,一个pod中可以运行一个或多个容器,这些容器共享存储、网络、以及怎样运行这些容器的声明,一般不直接创建Pod，而是创建一些工作负载由工作负载来创建Pod(下方有工作负载的解释) Pod内的容器都是平等的关系，共享Network Namespace、共享文件直接创建Pod的缺点: 直接创建的pod,该pod中的容器如果宕机异常,有恢复功能, 但是这个pod如果宕机异常不会有恢复功能,所以创建一些工作负载由他们来创建Pod,实现pod的异常恢复功能在直接部署pod时,虽然可以通过podIP属性指定该pod的访问ip,但是集群网络是私有的,该地址只能在集群内部访问,如果想允许外部访问需要创建Service来公开Pod的网络终结点 通过yaml方式创建pod示例 执行"vi 文件名称.yaml" 创建pod需要的yaml文件执行"kubectl apply -f 文件名称.yaml" 设置生效,创建对应的pod kind: Pod apiVersion: v1 metadata: name: 自定义当前创建pod名称 namespace: 当前创建pod所在命名空间(默认default) labels: #当前pod上的标签 aa: bb cc: dd spec: #当前创建pod内部信息与期望状态值 containers: #设置容器 - image: nginx #使用镜像 name: 自定义容器名称	podIP: 192.168.0.100 #虽然可以指定ip但是集群的网络是私有的,该地址也只能在集群内部进行访问 Pod 中的多容器协同 什么是多容器协同: 在一个pod中部署多个Container应用容器,多个应用容器配合工作,多容器配合工作时,同一个pod下 网络：每个Pod都会被分配一个唯一的IP地址**,Pod中的所有容器共享网络空间**,包括IP地址和端口。Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）存储: 可以Pod指定多个共享的Volume。Pod中的所有容器共享volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失 多容器协同的好处: 举个不太恰当的例子,服务间相互调用现在有a,b,c,d四个服务,d是配合工作的附加服务,多个服务间是通过d服务进行通信的,这样在pod中就可以部署为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4af645fe4097776194f54d46416e6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a3a25da3cbbfabc972aeb34779e4bd1/" rel="bookmark">
			cilium host-routing模式流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文分析cilium host routing模式下的报文路径和涉及到的ebpf源码分析。
使能host routing 在满足下面条件下会自动使能，进程启动时会进行判断，如果不满足会自动降级为legacy模式，也就是native routing模式
Requirements: Kernel &gt;= 5.10 Direct-routing configuration or tunneling eBPF-based kube-proxy replacement eBPF-based masquerading 使能eBPF-based kube-proxy replacement 参考：https://docs.cilium.io/en/v1.12/gettingstarted/kubeproxy-free/
上面的链接是通过kubeadm从头开始创建k8s集群时替换kube-proxy的流程，如果已经有了k8s集群，并且使用cilium cni时，可按如下
步骤操作
在master节点上删除kube-proxy的daemonset和configmap kubectl -n kube-system delete ds kube-proxy kubectl -n kube-system delete cm kube-proxy 删除所有节点上的KUBE相关的iptables规则 # Run on each node with root permissions: iptables-save | grep -v KUBE | iptables-restore 修改cilium的配置文件，增加如下两项配置 kubectl -n kube-system edit configmap cilium-config kube-proxy-replacement: strict k8s-api-server: https://192.168.56.2:6443 配置说明如下： kube-proxy-replacement有如下三个可选值，默认为partial，可参考函数initKubeProxyReplacementOptions partial: 只使能部分功能，比如使能--enable-node-port，--enable-host-port等 strict: 使能所有功能，如果有不支持的会panic disabled: 关闭replacement k8s-api-server：用来指定k8s apiserver。cilium启动时默认会通过kubernetes svc(cluster ip 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a3a25da3cbbfabc972aeb34779e4bd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0538a7bf332aae25cdbfd4154198496b/" rel="bookmark">
			element 级联选择器同时获取label和value
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element 级联选择器同时获取label和value 首先给标签添加的ref
&lt;el-cascader
style=“width: 100%”
ref=“cascaderRef”
v-model=“treeSearch.directoryName”
@change=“handleChange”
:options=“options”
:props=“optionsProps”
:show-all-levels=“false”
&gt;
在handleChange事件中就可以直接获取到
handleChange() {
console.log(this.$refs.cascaderRef.getCheckedNodes()[0].pathLabels);
},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb60295b3cebe51b0782fe8f40ce0e1/" rel="bookmark">
			来个切面日志打印请求和响应信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了偷个懒，不用每次在请求接口和响应信息的时候都打印一下日志信息，索性就用切面来实现，这样爽歪歪。
一、依赖
我用的是jdk11，springboot是2.7.13的版本，对应引入的切面的依赖是：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 二、切面
import com.alibaba.fastjson2.JSON; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest; import java.util.Arrays; import java.util.Objects; @Aspect @Component public class InterfaceAspect { private final Logger logger = LoggerFactory.getLogger(InterfaceAspect.class); @Around("execution(public * com.demo.cn.controller..*.*(..))") public Object controllerLog(ProceedingJoinPoint pdj) throws Throwable{ HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest(); long startTime = System.currentTimeMillis();//开始时间 //获取参数数组 Object[] args = pdj.getArgs(); //执行原方法并获取返回结果 Object ret = pdj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb60295b3cebe51b0782fe8f40ce0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2655bb292d5e77cbeb7d6770602d0a18/" rel="bookmark">
			Mybatis的动态SQL及关键属性和标识的区别(对SQL更灵活的使用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（ 虽然文章中有大多文本内容，想了解更深需要耐心看完，必定大有受益 ）
目录
一、动态SQL
( 1 ) 是什么
( 2 ) 作用
( 3 ) 优点
( 4 ) 特殊标签
( 5 ) 演示
二、#和$的区别
2.1 #使用
( 1 ) #占位符语法
( 2 ) #优点
2.2 $使用
( 1 ) $占位符语法
( 2 ) $优点
2.3 综合
2.4 实例演示
三、resultType及resultMap的区别
3.1 讲述
3.2 演示
给我们带来的收获
一、动态SQL ( 1 ) 是什么 是一种在SQL语句中根据不同条件动态拼接SQL的方式。通过使用动态SQL，可以根据不同的条件生成不同的SQL语句，从而实现灵活的查询和更新操作。动态SQL可以使用if、choose、when、otherwise等标签来实现条件判断和循环操作，同时还可以使用foreach标签来实现对集合类型参数的遍历操作。这样可以避免在代码中使用大量的字符串拼接，提高代码的可读性和维护性。
( 2 ) 作用 Mybatis的动态SQL具有以下作用：
1&amp;. 灵活的条件查询：通过动态SQL，可以根据不同的条件生成不同的SQL语句，实现灵活的条件查询。可以根据用户输入的不同条件动态拼接SQL，从而实现动态的查询操作。2&amp;. 动态更新操作：通过动态SQL，可以根据不同的条件生成不同的更新SQL语句，实现动态的更新操作。可以根据不同的业务需求动态拼接更新语句，从而实现灵活的数据更新。3&amp;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2655bb292d5e77cbeb7d6770602d0a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a987352c071edf115ab54ce22a5fb3f/" rel="bookmark">
			办公网络布线（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 2. 办公室网络布线
2.1 需求分析与走线设计
1.网络管理员的布线任务
2.3 办公室布线实施
2. 办公室网络布线 网络中的布线并不是一步到位的。在实施布线之前需要根据建筑物设计好网络布线的设计图，再根据设计图估算出施工材料的使用量，最后才能进行布线施工。
2.1 需求分析与走线设计 在办公室网络的设计过程中，网络管理员应该注意以下两点。
&gt;根据办公室平面图设计出具体的走线图。
&gt;核算各种施工材料的使用量及工程预算。
施工前必须做好规划和预算，审批通过后才能开展后续工作。
1.网络管理员的布线任务 如图所示，办公室内共有八个工位，分别通过隔断隔开，每个工位上有一台计算机，现在将这八台计算机通过双绞线连接到配线间。
要求如下:
&gt;尽量节约成本，
&gt;注意办公环境的美观(网线不可直接暴露在外面)。
2.设计走线图
图为办公室的布线设计图，为了描述方便，将不同部分的双绞线缆用A.B.C三段线缆表示。 A段线缆的一端连接到隔断上的信息模块，另一端从隔断内部延伸到墙体。
B段线缆被安置于事先固定在墙上的塑料线槽内，并且沿着办公室的墙壁将所有线缆汇集到图中右下角的位置。
C段线缆在走廊中与来自其他办公室的线缆一起从吊顶上的走线架延伸到中心机房，线缆进入配线间后连接到相应机柜的配线架上。
B段线缆继续沿着塑料线槽从墙壁的底角垂直延仲到顶角，最终从墙孔穿出到外侧走廊。
2.2 估算施工材料的用量
虽然办公室内最初只有四名员工(也就是只有4台计算机)，但网络管理员必须将所有工位的线统布设好。于是就需要了解信息插座，水晶头、线槽及双绞线的使用量，并最终核算出需要花多少
钱可以完成这项任务，
1.信息模块及水晶头用量统计
信息插座的需求量与工位数相同(8个)但要估算水晶头的需求量就没这么简单了，需要考虑
如下两个问题。
通常情况下，一个信息点需要4个水晶头。
水晶头的使用量要留有一定的余量，因为在施工过程中难免出现一些意外损耗。这部分余
量一般为总使用量的10%-15%。
因此，水晶头的使用量=8*4x(1+15%)~40(个)。
2.线槽用量统计
线槽的需求要根据办公室的长、宽，高来具体计算。如图4.7所示，办公室内总共需要约37m
的线槽，包括环绕在办公室墙壁上的三段线槽，以及将线缆从底侧墙角引到顶角的一段线槽，可适
当多买一些作为备用。
由于办公室内需要的线缆较少，在走廊吊顶上的走线架中，如果有剩余空间可以布设线缆，则不需考虑走廊线槽的使用量:否则也需要将这一部分计算进去。
具体使用什么规格的线槽，主要看线槽内需要容纳多少线缆，除了八个工位的线缆外，通常情况下会预留出1~2根备用线缆，所以线槽中最多可容纳9~10根双绞线，选用40mmx20mm规格
的线槽比较合适。
另外，在槽与槽之间连接的地方还需要两个直转角，两个阴角。
3.线缆用量统计
办公室线缆使用量计算如下:
C-[0.55x(L+S)+6]xn
式中，
L--本楼层距管理间最远的信息点距离;
S-本楼层距管理间最近的信息点距离
n一-本楼层的信息点总数;
0.55--备用系数;
6--端接容差。
根据图中标识的距离参数，估算的办公室线缆使用量约为410m。对于本例而言，总共只需要9根线，可以计算得更加精确一些，对于整个楼层甚至整个楼宇的布线，如果老板或工程的甲方想立刻知道一个大致的预算时，就可以使用上述计算方法。
2.3 办公室布线实施 办公室的网络布线实施过程将分为六个步骤:墙壁打孔、线槽安装、布设线缆、打接线缆，设
备上架和连通性测试。
1.墙壁打孔
在墙上打孔时，应注意孔的直径不要超过线槽盒的宽度，以免墙孔暴露在外面，影响美观。
打孔的位置应在吊顶上方，否则会影响走廊内的环境美观。
2.线槽安装
按照走线图的设计，通过螺钉将线槽固定在办公室的墙壁上，固定点的间距约1m。
注意事项如下。
线槽水平度每米偏差应不超过2mm垂直线槽应与地面保持垂直垂直度偏差应不超过3mm。
两线槽拼接处偏差应不超过2mm线槽距地面应保持30cm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a987352c071edf115ab54ce22a5fb3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21394e5baff6b6b7a4f1e7ae71de5829/" rel="bookmark">
			Set集合详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.set简介
二.set集合的特点
1.Set不存储重复的元素
2.Set中的元素通常是无序的
三.set集合的遍历方式
1.foreach遍历
2.iterator迭代器遍历
四.HashSet哈希表存储，重复元素存储底层原理
五.LinkedHashSet保留元素插入顺序
六.TreeSet(自然排序，比较器排序)
1.默认排序：set集合中的默认的排序
2.自然排序：实现java.lang.Comparable接口
3.比较器排序：实现java.util.Comparator的匿名内部类
七.SortedSet 1.first()和last()方法分别获取了集合中的最小值和最大值。
2.subSet()方法获取了子集合
3.tailSet()方法尾部子集合
一.set简介 在Java中，Set是一个接口，用于存储一组不重复的元素。Set接口继承自Collection接口，因此它具有Collection接口定义的所有方法，例如添加、删除和迭代等。
二.set集合的特点 1.Set不存储重复的元素 2.Set中的元素通常是无序的 package com.ctb.set; import java.util.HashSet; import java.util.Set; /** * set集合的特点 * 1.无序-没有下标--所以无法修改 * 2.元素无重复 * * @author biao * */ public class Demo1 { public static void main(String[] args) { //定义set集合 Set set=new HashSet&lt;&gt;(); //增加 set.add("ha"); set.add("ds"); set.add("dh"); set.add("es"); set.add("di"); //删除 set.remove("di"); System.out.println(set.size()); //输出：4 //查询 System.out.println(set);//输出[dh, ha, es, ds] } } 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21394e5baff6b6b7a4f1e7ae71de5829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5539439a95f2ce724348795022f76159/" rel="bookmark">
			itext7 html转pdf 英文或数字不自动换行的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加依赖 pom.xml &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext7-core&lt;/artifactId&gt; &lt;version&gt;7.1.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;html2pdf&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; package cn.sh.ideal.utils; import java.io.ByteArrayOutputStream; import java.util.List; import com.itextpdf.html2pdf.ConverterProperties; import com.itextpdf.html2pdf.HtmlConverter; import com.itextpdf.html2pdf.resolver.font.DefaultFontProvider; import com.itextpdf.io.IOException; import com.itextpdf.io.font.otf.GlyphLine; import com.itextpdf.kernel.geom.PageSize; import com.itextpdf.kernel.pdf.PdfDocument; import com.itextpdf.kernel.pdf.PdfWriter; import com.itextpdf.layout.Document; import com.itextpdf.layout.element.IBlockElement; import com.itextpdf.layout.element.IElement; import com.itextpdf.layout.property.Property; import com.itextpdf.layout.splitting.DefaultSplitCharacters; import lombok.extern.slf4j.Slf4j; /** * @author Steven * @version 1.0 * @date 2023/8/22 9:42 * @description */ @Slf4j public class ItextPdfUtil { public static ByteArrayOutputStream htmlToPdf(String htmlStr){ Document document = null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try { PdfDocument pd = new PdfDocument(new PdfWriter(baos)); document = new Document(pd, PageSize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5539439a95f2ce724348795022f76159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80246e83eb60698ad8bce7a50ee6b2b4/" rel="bookmark">
			百万级Excel数据导入导出，就该这么玩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringForAll社区 2023-08-21 08:30 发表于上海
关注我
，回复关键字“spring”，
免费领取Spring学习资料。
SpringForAll社区
分享关于Spring的一切
286篇原创内容
公众号
在项目开发中往往需要使用到数据的导入和导出，导入就是从Excel中导入到DB中，而导出就是从DB中查询数据然后使用POI写到Excel上。
大数据的导入和导出，相信大家在日常的开发、面试中都会遇到。
很多问题只要这一次解决了，总给复盘记录，后期遇到同样的问题就好解决了。好啦，废话不多说开始正文！欢迎关注公众号：SpringForAll社区（spring4all.com），专注分享关于Spring的一切！回复“加群”还可加入Spring技术交流群！
1.传统POI的的版本优缺点比较 其实想到数据的导入导出，理所当然的会想到apache的poi技术，以及Excel的版本问题。
HSSFWorkbook
这个实现类是我们早期使用最多的对象，它可以操作Excel2003以前（包含2003）的所有Excel版本。在2003以前Excel的版本后缀还是.xls
XSSFWorkbook
这个实现类现在在很多公司都可以发现还在使用，它是操作的Excel2003–Excel2007之间的版本，Excel的扩展名是.xlsx
SXSSFWorkbook
这个实现类是POI3.8之后的版本才有的,它可以操作Excel2007以后的所有版本Excel,扩展名是.xlsx
HSSFWorkbook 它是POI版本中最常用的方式，不过:
它的缺点是 最多只能导出 65535行，也就是导出的数据函数超过这个数据就会报错;
它的优点是 不会报内存溢出。（因为数据量还不到7w所以内存一般都够用，首先你得明确知道这种方式是将数据先读取到内存中，然后再操作）
XSSFWorkbook 优点：这种形式的出现是为了突破HSSFWorkbook的65535行局限，是为了针对Excel2007版本的1048576行，16384列，最多可以导出104w条数据；
缺点：伴随的问题来了，虽然导出数据行数增加了好多倍，但是随之而来的内存溢出问题也成了噩梦。因为你所创建的book，Sheet，row，cell等在写入到Excel之前，都是存放在内存中的（这还没有算Excel的一些样式格式等等），可想而知，内存不溢出就有点不科学了！！！
SXSSFWorkbook 从POI 3.8版本开始，提供了一种基于XSSF的低内存占用的SXSSF方式：
优点：
这种方式不会一般不会出现内存溢出（它使用了硬盘来换取内存空间，
也就是当内存中数据达到一定程度这些数据会被持久化到硬盘中存储起来，而内存中存的都是最新的数据），
并且支持大型Excel文件的创建（存储百万条数据绰绰有余）。
缺点：
既然一部分数据持久化到了硬盘中，且不能被查看和访问那么就会导致，
在同一时间点我们只能访问一定数量的数据，也就是内存中存储的数据;
sheet.clone()方法将不再支持,还是因为持久化的原因;
不再支持对公式的求值，还是因为持久化的原因，在硬盘中的数据没法读取到内存中进行计算；
在使用模板方式下载数据的时候，不能改动表头，还是因为持久化的问题，写到了硬盘里就不能改变了；
这里顺便给大家推荐一款我们自己开发的Chrome插件：Youtube中文配音（http://youtube-dubbing.com/）。如果您跟我们一样，热爱看国外的视频学习前沿知识或者其他内容，该插件可以很好的帮助您讲外语视频一键转化为中文视频！
2.使用方式哪种看情况 经过了解也知道了这三种Workbook的优点和缺点，那么具体使用哪种方式还是需要看情况的：
我一般会根据这样几种情况做分析选择：
1、当我们经常导入导出的数据不超过7w的情况下，可以使用 HSSFWorkbook 或者 XSSFWorkbook都行；
2、当数据量查过7w并且导出的Excel中不牵扯对Excel的样式，公式，格式等操作的情况下，推荐使用SXSSFWorkbook;
3、当数据量查过7w，并且我们需要操做Excel中的表头，样式，公式等，这时候我们可以使用 XSSFWorkbook 配合进行分批查询，分批写入Excel的方式来做；
3.百万数据导入导出 想要解决问题我们首先要明白自己遇到的问题是什么？
1、 我遇到的数据量超级大，使用传统的POI方式来完成导入导出很明显会内存溢出，并且效率会非常低；
2、 数据量大直接使用select * from tableName肯定不行，一下子查出来300w条数据肯定会很慢；
3、 300w 数据导出到Excel时肯定不能都写在一个Sheet中，这样效率会非常低；估计打开都得几分钟；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80246e83eb60698ad8bce7a50ee6b2b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed7840a525f55873ad1f1c58330c2cc/" rel="bookmark">
			通俗易懂的C语言指针知识讲解(详细,深入) 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针 前言指针是什么？内存指针的说明 取地址操作符(&amp;)和解引用操作符(*)取地址操作符解引用操作符 指针变量的类型指针运算指针±整数指针- 指针 野指针野指针的成因如何避免野指针 前言 本篇文章就让我们一起揭开C语言指针的神秘面纱，指针是C语言中特别重要的一个知识点，也是C语言的灵魂所在。可以说C语言学没学好，首先就是要看指针学没学好。本篇的学习目的是从指针的底层讲起，一步一步的不断理解指针。
指针是什么？ 内存 讲指针之前让我们先了解一下内存的相关知识：
内存是计算机中非常重要的组成部分，当计算机运行程序时，它会将程序和数据加载到内存中，并在需要时从内存中获取信息。而计算机为了方便管理内存，将内存划分为一个字节大小的内存单元，并且为了方便找到这个内存单元，计算机中会给用到的内存单元，随机生成相应的编号(这个编号就相当于我们生活中的外卖地址)，有了这个编号就可以快速找到内存单元，对其进行读写操作，在计算机中这个编号又被称为地址。
注：
32位的机器中有32根地址线，即一共有32bit的二进制位（4字节）
64位的机器中有64根地址线，即一共有64bit的二进制位（8字节）
1字节=8位（二进制）
1KB=1024字节
指针的说明 C语言中又给地址起了一个新的称号叫指针
由此我们可以理解为：
内存单元的编号 = 地址 = 指针。
一段关于指针的代码及其解释：
其中int表示指针指向的数据类型为int类型，*说明p是指针变量，p是指针变量，里面存的是地址。
通过调试结果我们可以看到p变量存的就是i的地址。
取地址操作符(&amp;)和解引用操作符(*) 取地址操作符 &amp;有两种使用情况：
（1）作为位操作符，进行按位与运算，是双目操作符 如 1&amp;0。
（2）作为取地址操作符，取出变量名所在内存的地址，是单目操作符 如&amp;i ,可配合%p打印出地址。
知道了取地址操作符后我们就可以查看任意变量所在内存中的地址了。比如下面这段代码就是，将i变量的地址以16进制的形式打印出来。
示例：
#include &lt;stdio.h&gt; int main() { int i = 1; printf("%p\n",&amp;i); return 0; } 运行结果图：
这个时候我们就可以很轻松的给指针变量，进行初始化了。
示例：
int main() { int i = 1; int* p = &amp;i;//i在内存中的地址，赋值给指针变量p printf("%p\n",&amp;i); printf("%p\n", p); return 0; } 运行结果图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed7840a525f55873ad1f1c58330c2cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d37b1cffbdf6821e96b9ecd5068b293/" rel="bookmark">
			【STM32】串口通信乱码（认识系统时钟来源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 stm32f407 与电脑主机进行串口通信时，串口助手打印乱码，主要从以下方面进行排查：
检查传输协议设置是否一致（波特率、数据位、停止位、校验位）检查MCU外部晶振频率是否和库函数设置的一致 最终发现是外部晶振频率和库函数不一致的问题。
一、时钟分析 1、认识时钟源 我们要检查的是 APB2总线的时钟源是否设置正常，因为我们当前使用的串口 USART1 与 APB2 总线（高速总线）相连，从下图看，时钟源有三个：
HSI：高速内部时钟，RC振荡器，频率为16MHzHSE：高速外部时钟，接外部时钟源，频率范围为4MHz~26MHzPLL：锁相环倍频输出，其时钟输入源可选择为 HSI/M、HSE/M（本质还是 由HSE或HSI控制） 就结果而言，选择的时钟源是 PLLCLK。（若想了解，可以参考最后一部分）
2、计算系统时钟 现在已经知道了选择的是 PLLCLK 作为时钟源，那么我们就可以顺着这条路线计算系统时钟的值。正点原子 stm32f407 的外设时钟频率 HSE = 8 M
① 输入 HSE
② 经过 M 分频，得到的结果为 HSE / M = 8 / M
③ ④ ⑤ ⑥ 经过 N 倍频，VCO的输出为 (HSE / M ) * N
⑦ 再次 P 分频就得到 SYSCLK = (HSE / M ) * N / P
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d37b1cffbdf6821e96b9ecd5068b293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c61fa55ed8db0efd9dfb627bb6f9eb6/" rel="bookmark">
			Reactor 第十篇 定制一个生产的WebClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 为什么要用 WebClient 刚开始尝试使用 Spring WebFlux 的时候，很多人都会使用 Mono.fromFuture() 将异步请求转成 Mono 对象，或者 Mono.fromSupplier() 将请求转成 MOno 对象，这两种方式在响应式编程中都是不建议的，都会阻塞当前线程。
1.1 Mono.fromFuture() VS WebClient Mono.fromFuture()方法和使用 WebClient 调用第三方接口之间存在以下区别：
异步 vs. 非阻塞 Mono.fromFuture()方法适用于接收一个 java.util.concurrent.Future 对象，并将其转换为响应式的 Mono。这是一个阻塞操作，因为它会等待 Future 对象完成。而使用 WebClient 调用第三方接口是异步和非阻塞的，它不会直接阻塞应用程序的执行，而是使用事件驱动的方式处理响应。
可扩展性和灵活性：使用 WebClient 可以更灵活地进行配置和处理，例如设置超时时间、请求头、重试机制等。WebClient 还可以与许多其他 Spring WebFlux 组件集成，如 WebSockets、Server-Sent Events 等。而 Mono.fromFuture() 是适用于单个 Future 对象转化为 Mono 的情况，可扩展性较差。
错误处理 WebClient 提供了更丰富的错误处理机制，可以通过 onStatus、onError 等方法来处理不同的 HTTP 状态码或异常。同时，WebClient 还提供了更灵活的重试和回退策略。Mono.fromFuture() 方法只能将 Future 对象的结果包装在 Mono 中，不提供特定的错误处理机制。
阻塞操作 Mono.fromFuture() 会阻塞。当调用 Mono.fromFuture() 方法将 Future 转换为 Mono 时，它会等待 Future 对象的结果返回。在这个等待的过程中，Mono.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c61fa55ed8db0efd9dfb627bb6f9eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd43ebf8256ec229164ca5a331218f91/" rel="bookmark">
			【附源码】六个Python表白小代码，送给心爱的她，让她高兴一整天~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话说明天就是七夕了，买礼物了吗？
什么？居然还没买礼物，那这个代码正好送给你，六个Python爱心表白代码，让她高兴一整天！
话不多说，咱直接上代码！
1、紫色爱心 先看效果
代码
#1-1导入turtle模块进行设计 import turtle import time #1-2画心形圆弧 def hart_arc(): for i in range(200): turtle.right(1) turtle.forward(2) def move_pen_position(x, y): turtle.hideturtle() # 隐藏画笔（先） turtle.up() # 提笔 turtle.goto(x, y) # 移动画笔到指定起始坐标（窗口中心为0,0） turtle.down() # 下笔 turtle.showturtle() # 显示画笔 love = "听闻小姐治家有方，鄙人余生愿闻其详？" #input("请输入表白话语：") signature = "先生" #input("请签署你的名字:") date= "" #input("请写上日期：") if love == '': love = 'I Love You' #1-3初始化 turtle.setup(width=800, height=500) # 窗口（画布）大小 turtle.color('black', 'Pink') # 画笔颜色 turtle.pensize(5) # 画笔粗细 turtle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd43ebf8256ec229164ca5a331218f91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95bff96a1dc1a6917d1f2592472590b5/" rel="bookmark">
			Rancher使用cert-manager安装报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：
rancher-rke-01:~/rke/rancher-helm/rancher # helm install rancher rancher-stable/rancher --namespace cattle-system --set hostname=www.rancher.local
Error: INSTALLATION FAILED: Internal error occurred: failed calling webhook "webhook.cert-manager.io": failed to call webhook: Post "https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s": context deadline exceeded
解决办法：
cert-manager 🚀 - 发生内部错误：调用webhook“ webhook.cert-manager.io”失败：发布https：//cert-manager-webhook.cert-manager.svc：443 / mutate？timeout = 30s：net / http：TLS握手超时 | bleepcoder.com
$ helm install \ cert-manager jetstack/cert-manager \ --namespace cert-manager \ --version v0.16.0 \ --set installCRDs=true $ kubectl delete mutatingwebhookconfiguration.admissionregistration.k8s.io cert-manager-webhook $ kubectl delete validatingwebhookconfigurations.admissionregistration.k8s.io cert-manager-webhook 这里有思考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95bff96a1dc1a6917d1f2592472590b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8209f5663f1ca17900540f55bd86e88/" rel="bookmark">
			SQL根据当前日期获取相应的日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取上个月的第一天与最后一天日期
SELECT DATEADD(m, -1,DATEADD(mm,DATEDIFF(mm,0,getdate()),0)) 上月第一天
SELECT DATEADD(s, -1,DATEADD(mm,DATEDIFF(mm,0,getdate()),0)) 上月最后一天
2、获取本月第一天与最后一天日期
SELECT DATEADD(mm,DATEDIFF(mm,0,getdate()),0) 本月第一天
SELECT DATEADD(s, -1,DATEADD(mm,DATEDIFF(mm,-1,getdate()),0)) 本月最后天
3、获取本周的第一天与最后一天日期（周一为第一天）
SELECT DATEADD(wk, DATEDIFF(wk,0,getdate()), 0) 本周第一天
SELECT DATEADD(s, -1,DATEADD(wk, DATEDIFF(wk,0,getdate()), 7) ) 本周最后一天
4、获取去年上个月第一天与最后一天日期
SELECT DATEADD(YEAR,-1,DATEADD(m, -1,DATEADD(mm,DATEDIFF(mm,0,getdate()),0))) 去年上月第一天
SELECT DATEADD(YEAR,-1,DATEADD(s, -1,DATEADD(mm,DATEDIFF(mm,0,getdate()),0))) 去年上月最后一天
5、获取去年本月第一天与最后一天日期
SELECT DATEADD(YEAR,-1,DATEADD(mm,DATEDIFF(mm,0,getdate()),0)) 去年本月第一天
SELECT DATEADD(YEAR,-1,DATEADD(s, -1,DATEADD(mm,DATEDIFF(mm,-1,getdate()),0))) 去年本月最后天
6、获取去年本周的第一天和最后一天日期
SELECT DATEADD(wk, DATEDIFF(wk,0,DATEADD(YEAR,-1,getdate())), 0) 去年本周第一天
SELECT DATEADD(s, -1,DATEADD(wk, DATEDIFF(wk,0,DATEADD(YEAR,-1,getdate())), 7) ) 去年本周最后一天
7、获取今年的第一天和最后一天日期
SELECT dateadd(ms,0,DATEADD(yy, DATEDIFF(yy,0,getdate()), 0)) 当本年第一天
SELECT dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate())+1, 0)) 当本年最后一天
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8209f5663f1ca17900540f55bd86e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdaa36c3ff7f573f357d93d9ff804e2c/" rel="bookmark">
			vite&#43; vue3项目添加electron，并electron打包教程，以及electron代码热重载页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.安装electron,通过npm下载electron 需要全局安装
2.在根目录中新建一个electron文件夹，在文件夹中新建main.js
3.修改package.json文件
4.在electronx文件夹下的main.js中加入以下代码
5.配置加载代码热更新
6.打包成APP
前提条件，新建好vite+vue3项目。创建vite+vue3项目教程 1.安装electron,通过npm下载electron 需要全局安装 npm i -s electron -D 2.在根目录中新建一个electron文件夹，在文件夹中新建main.js 3.修改package.json文件 删除type字段，不然运行会报错然后添加"main": "electron/main.js","electron/main.js"为electron文件中main的路径在scripts字段中添加启动electron的命令，"electrone:dev": "electron ." 4.在electronx文件夹下的main.js中加入以下代码 // 控制应用生命周期和创建原生浏览器窗口的模组 const { app, BrowserWindow, Menu } = require('electron') const path = require('path') // process.env['ELECTRON_DISABLE_SECURITY_WARNINGS'] = true // 关闭控制台的警告 function createWindow() { // 创建浏览器窗口 const mainWindow = new BrowserWindow({ width: 1200, height: 800, webPreferences: { // 书写渲染进程中的配置 nodeIntegration: true, //开启true这一步很重要,目的是为了vue文件中可以引入node和electron相关的API contextIsolation: false, // 可以使用require方法 enableRemoteModule: true, // 可以使用remote方法 }, }) // 监听html mainWindow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdaa36c3ff7f573f357d93d9ff804e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43fccade9f50e0e83070fcd25d42539/" rel="bookmark">
			局域网基于linux麒麟v10搭建mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为是局域网 缺失很多工具，要先安装yum源 自行百度吧。
curl -o yum.sh http://169.254.169.253:10080/KylinOS/yum.sh
sh yum.sh
yum clean all
yum makecache
1、执行安装依赖
sudo yum install -y wget vim gcc gcc-c++ make cmake ncurses ncurses-devel bison openssl openssl-devel boost-devel libtirpc libtirpc-devel
或
yum install gcc gcc-c++ cmake ncurses-devel bison openssl-devel rpcgen
后续安装
安装前的环境准备工作和说明
1.系统版本
MySQL：mysql-boost-5.7.36.tar.gz
mysql下载路径：/opt/tools
mysql安装路径：/app/mysql
2.说明
源码编译安装 一、清理删除旧版本安装包残留
1.查找mysql相关安装
[root@localhost ~]# rpm -qa | grep -i mysql
[root@localhost ~]# yum list installed | grep mysql // 第二种方式yum，用这个方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d43fccade9f50e0e83070fcd25d42539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6766f9157f09841a4c558fadd86687de/" rel="bookmark">
			vue&#43;vite&#43;electron项目打包成Mac，Windows安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：创建对应项目
要将使用 Vite 构建的 Vue.js 项目打包为 Windows 和 macOS 平台的可执行文件，可以使用 electron-builder 进行打包。electron-builder 是一个基于 Electron 的构建工具，可以轻松地将应用程序打包成可执行文件和安装程序，支持 Windows、macOS 和 Linux 平台。
1.先安装electron-builder 和 electron 依赖 npm install electron-builder electron --save-dev 2.在 package.json 文件中添加以下脚本： "scripts": { "build": "vite build &amp;&amp; electron-builder", "build:win": "vite build &amp;&amp; electron-builder --win", "build:mac": "vite build &amp;&amp; electron-builder --mac" } 上述代码中，vite build 命令用于构建 Vue.js 应用程序，electron-builder 命令用于将应用程序打包成可执行文件。build 脚本将打包出支持所有平台的应用程序，build:win 脚本将打包出支持 Windows 平台的应用程序，build:mac 脚本将打包出支持 macOS 平台的应用程序。
3.在项目根目录下创建 electron-builder.json 文件，用于配置打包选项： { "productName": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6766f9157f09841a4c558fadd86687de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efe9d6273c6224541322c2759e5cbd6/" rel="bookmark">
			中产消费提升，美团外卖迎来新发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着中国经济的快速发展，中产阶级的规模也在不断扩大。据国家统计局数据显示，2019年我国中产阶级人数已达到3.85亿，占全国总人口的24.2%。这一群体的壮大也为消费市场带来了巨大的潜力。中产消费的提升，不仅拉动了经济增长，也促进了消费升级和产业转型。
中产消费提升的原因主要有以下几个方面。首先，随着收入水平的提高，中产阶级对于生活品质的要求也在不断提升。他们对于商品的品质、品牌、性价比等要求越来越高，更愿意为高品质的商品和服务买单。其次，随着互联网技术的快速发展，电商、在线支付等新型消费方式的普及，中产阶级的消费习惯也在逐渐改变。他们更倾向于线上购物，对于便捷、高效、智能的消费体验更加追求。此外，人口结构的变化也对于消费市场产生了影响。中国老龄化趋势加剧，家庭结构也在发生变化，这也促使消费需求和消费习惯的改变。
中产消费的提升对于国家经济和社会的贡献也日益显著。一方面，中产消费的提升拉动了经济增长，促进了消费升级和产业转型。另一方面，中产消费也带动了就业增长和财富积累。同时，中产消费的崛起也推动了企业创新和品牌建设。更多的企业开始注重品牌塑造、产品质量和服务提升，以满足中产阶级对于高品质生活的追求。
美团作为中国最大的本地生活服务平台之一，也迎来了大发展。美团以餐饮外卖起家，逐渐扩展到酒店、旅游、电影等多个领域。截至2020年，美团已拥有超过6亿活跃用户，成为国内最大的本地生活服务平台之一。美团的大发展离不开以下几个原因：首先，美团抓住了互联网技术和移动支付的机遇，迅速崛起成为行业领导者。其次，美团在拓展新业务领域时，注重用户体验和服务质量，不断满足用户对于便捷、高效、安全的服务需求。此外，美团还通过数据分析和精准营销等方式，提高了用户黏性和转化率。
美团的大发展对于中产消费的提升也起到了积极的推动作用。一方面，美团提供了多样化的消费选择和便捷的服务方式，满足了中产阶级对于高品质生活的追求。另一方面，美团通过技术创新和模式创新，推动了传统产业的升级和转型。例如，美团外卖通过智能配送系统和大数据分析等技术手段，提高了配送效率和服务质量，为用户带来更好的消费体验。此外，美团还通过整合产业链上下游资源，降低了商家成本，提高了经营效率，为消费者提供了更具竞争力的价格和更丰富的产品选择。
根据权威机构的数据显示，中产消费的提升和美团的大发展态势仍在持续。预计到2025年，中国中产阶级人数将达到5.5亿，占全国总人口的35.4%。同时，美团等互联网企业的市场份额也将继续扩大。这一趋势的背后是经济发展、技术创新和社会变革等多方面因素的共同作用。未来，随着中产消费的进一步提升和互联网企业的持续发展，中国消费市场将迎来更加繁荣和活跃的时代。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c46954e5c15ff992f1011a49b0481c4/" rel="bookmark">
			MySQL索引详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、什么是索引 官方介绍索引是帮助MySQL高效获取数据的数据结构。简单来讲，数据库索引就像是书前面的目录，能加快数据库的查询速度。
事实上，索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。
但对于海量数据来说，它的目录也是很大的，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。
二、索引的分类 一、单列索引
一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了
1、普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一 点。
2、唯一索引：索引列中的值必须是唯一的，但是允许为空值。
3、主键索引：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引）。
二、组合索引
在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。
三、全文索引
全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。
三、索引的数据结构 索引的数据结构使用的是B+树，那为什么使用B+树而不是二叉查找树、平衡二叉树或者B树呢，接下来，我们来讲讲B+树的由来。
二叉查找树 首先，我们来讲讲二叉查找树
二叉查找树有这样的特点：
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉查找树。 二叉查找树的特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这是我们不想见到的。
二叉平衡树 平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。
使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。查询id=6，只需要两次IO。
就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：
时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10=0.2s）
平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。
B树：改造二叉平衡树 对于二叉平衡树，我们更希望出现‘矮胖’树而不是‘瘦高’树，因为这样可以减少查询时的IO操作次数，增加查询效率。那么我们如何能够降低树的高度呢？
假如key为bigint=8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间16个字节（8+4*2=16）
因为在MySQL的InnoDB存储引擎一次IO会读取的一页（默认一页16K）的数据量，而二叉树一次IO有效数据量只有16字节，空间利用率极低。为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000=1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。
这种数据结构我们称为B树，B树是一种多叉平衡查找树，主要特点如下：
B树的节点中存储着多个元素，每个内节点有多个分叉。
节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
父节点当中的元素不会出现在子节点中。
所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。
到这里，B树已经是比较理想的了，但我们还有可以优化的地方：
B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。
B+树：改造B树 B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于非叶子节点是否存储数据的问题
B树：非叶子节点和叶子节点都会存储数据。B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。 B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟这增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点。
四、MySQL索引的优化 避免回表 在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？
使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）
如果在一个场景下，select id,name,sex from user where name ='zhangsan';这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。
这就是一个典型的使用覆盖索引的优化策略减少回表的情况。
联合索引的使用 联合索引，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。
联合索引的创建原则，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那建议这种情况下使用联合索引。
联合索引的使用：
考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bff7a02ab9e54c7e2d41e68355e1acf/" rel="bookmark">
			笔记本设置扩展屏幕时第二块屏幕的纵横比不对（字体变宽）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在设置中设置扩展，分辨率和缩放按照推荐设置
2.在扩展显示器的高级设置中将屏幕的刷新率设置的比主屏幕低一点即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af8bc6689b66ab02e8d838d88bae937/" rel="bookmark">
			Android开发环境搭建&#43;AS常用功能指导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AndroidStudio 已经迭代了好几个版本，功能已稳定，各种配置的方法在搜索引擎里基本都能找到，这里做一些简单汇总整理。
一、AndroidStudio 开发环境搭建 1.1 简单介绍AndroidStudio 它是 Google 推出的功能强大的 android 开发工具，支持 Java 和 Koltin 语言。
官网的介绍：
Android Studio provides the fastest tools for building apps on every type of Android device.
1.2 下载AndroidStudio 去官网 https://developer.android.google.cn/studio 下载最新版本。
1.3 官网说明的新功能简单介绍 快速预览：xml编写的UI页面在预览页快速看到效果、ConstraintLayout 的可视化操作等；apk 分析：检查清单文件、资源和DEX文件等；模拟器：快速的模拟器、小改动可以直接 Apply Changes ；代码编辑：智能代码编辑器，主要体现在代码提示；灵活构建系统：由Gradle提供支持，androidstudio的构建系统允许您定制构建，以便从单个项目为不同设备生成多个构建变体，主要体现在多渠道打包；实时分析器：实时分析app内存情况； 1.4 开始安装 安装的时候一直下一步即可，在选择 安装路径 和 SDK 的时候，默认放在C盘 ，建议放在D盘、E盘等，防止占用太多 C 盘空间，导致电脑卡顿。
详细步骤可参考 https://www.jianshu.com/p/492111393275
二、AS工程初步了解 2.1 新建一个 HelloWorld 工程 首次安装点击 Create a new Android studio Project ，非首次则执行 File – New – New Project
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3af8bc6689b66ab02e8d838d88bae937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8791f37beaea296b7d813dcb632e3f98/" rel="bookmark">
			【Docker】完整的搭建和发布过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Docker】完整的搭建和发布过程 【一】Mac版虚拟机CentOS搭建【1】shell和ftp工具选择【2】linux 命令 ip a / ip addr / ifconfig 不显示ip问题（1）如果没有 ifcfg-ens33文件 修改 ifcfg-eth0（2）重启网关服务器 【二】Docker安装【1】Docker的安装（1）查看系统的内核版本（2）yum更新到最新版本（3）安装Docker所需的依赖包（4）设置Docker的yum的源（5）更新yum软件包索引（6）查看仓库所有Docker版本（7）安装Docker（8）启动Docker并添加开机自启动（9）查看Docker版本（10）测试（11）卸载Docker（12）Docker常用命令（13）如何创建自启动的容器 【2】阿里云镜像加速（1）获取阿里云加速器地址（2）创建文件夹并执行脚本（3）重新加载配置文件（4）重新启动docker（5）查看 daemon.json 是否已经生效了 【三】环境容器的搭建【1】安装Portainer（1）拉取最新的Portainer镜像（2）运行镜像（9000）（3）访问Portainer可视化界面（4）一些问题的解决 【2】安装JDK8【3】安装redis（1）拉取redis镜像（2）在宿主机下新建目录/app/redis（3）启动redis（6379）（4）查看Portainer的页面（5）使用本地RDM链接redis（6）使用redis容器的终端链接redis（7）运维命令 【5】安装redis集群（1）面试题（2）搭建三主三从redis集群（3）主从容错切换迁移案例（4）主从扩容案例（5）主从缩容案例 【6】安装kafka（1）下载镜像（2）启动zookeeper（2181）（3）启动kafka（9092）（4）防火墙设置（5）kafka日志（6）Kafka 控制台操作（7）待补充 【7】安装mysql（3306）【8】安装mysql主从复制（1）新建主服务器容器实例3307（2）进入/mydata/mysql-master/conf目录下新建my.cnf（3）修改完配置后重启master实例（4）进入mysql-master容器（5）master容器实例内创建数据同步用户（6）新建从服务器容器实例3308（7）进入/mydata/mysql-master/conf目录下新建my.cnf（8）修改完配置后重启slave实例（9）在主数据库中查看主从同步状态（10）进入mysql-slave容器（11）在从数据库中配置主从复制（12）在从数据库中查看主从同步状态（13）在从数据库中开启主从同步（14）查看从数据库状态发现已经同步（15）主从复制测试 【9】安装xxl-job（1）导入sql（2）安装xxl-job（7397）（3）配置任务（4）工程配置xxl-job（5）测试验证（待补充） 【10】安装nacos（8848）【11】安装Elasticsearch（9200）【12】安装Kibana（5601）【13】安装canal（待补充）【14】安装nginx（80）（1）下载Nginx镜像（下面两种选择一个）（2）创建Nginx配置文件（3）创建Nginx容器并运行（4）结果检测（5）修改nginx配置 【四】总结上面案例中的概念和常用的Docker命令【1】常用的概念【2】镜像命令【3】容器命令【4】镜像构建（1）介绍（2）docker commit构建镜像 【五】挂载是怎么个事【六】网络是怎么个事【七】Dockerfile【1】介绍【2】Dockerfile的基础知识【3】Dockerfile 常用指令【4】Dockerfile指令的使用案例（1）先拉取一个centos的镜像（2）启动centos（3）阻塞操作系统，启动的一刹那就进入操作系统（4）测试FROM指令（5）构建镜像（6）一点优化（7）测试RUN指令（8）测试EXPOSE指令（9）测试WORKDIR指令（10）测试ADD指令（11）测试COPY指令（12）测试ENV指令（13）测试VOLUME指令（14）测试CMD命令（15）测试ENTRYPOINT指令 【3】构建镜像【4】Dockerfile 实践【5】镜像仓库 【六】用dockerfile完成项目部署的案例【1】案例一：自己创建一个增删改查的项目并用Dockerfile部署（1）创建一个springboot项目（2）docker创建网络（3）把项目打成jar包（4）创建Dockerfile文件，并上传jar包（5）用dockerfile构建镜像（6）使用镜像创建容器（7）本地测试 【2】案例二：部署包括mysql和Redis的springboot项目war包（1）准备项目代码进行本地测试（2）修改项目代码的配置（3）项目打成war包（4）启动各个容器（5）导入项目的数据到mysql（6）上传springboot项目到服务器，防火墙开放端口（7）编写dockerfile文件（8）用dockerfile构建镜像（9）使用镜像创建容器（10）本地测试 【3】案例三：用Dockerfile构建一个自定义镜像 【七】docker-compose【1】介绍（docker容器太多了如何管理）【2】举例说明【3】docker-compose.yml 文件详解（1）介绍（2）version 版本信息（3）services 定义服务（4）image 镜像名称标签（5）dockerfile 构建镜像（6）container_name 容器名称（7）depends_on 容器依赖（8）ports 暴露端口（9）expose 接受端口范围（10）restart 重启策略（11）environment 环境变量（12）command 执行命令（13）volumes 目录挂载（14）network_mode 网络模式（15）networks（16）aliases 【4】compose的概念和常用命令 【八】compose的安装【1】在线安装【2】离线安装 【九】用Docker-compose完成项目部署的案例【2】ruoyi系统的容器化部署过程（1）安装Nacos（2）安装Nginx（3）安装Mysql8（4）安装redis（5）下载若依系统（6）修改bootstrap.yml配置文件（7）打包（8）操作项目文件里的文件/docker/ruoyi（9）操作docker/mysql（10）操作docker/nacos（11）操作docker\nginx\conf（12）操作docker\nginx\html\dist这个文件（13）操作docker下docker-compose.yml文件（14）将docker文件夹上传至linux（15）运行服务（16）检查一下启动结果（17）修改完配置后再次启动（18）启动出现问题 【十】基于Docker+Jenkins+Git的发布环境搭建【十】k8s学习笔记 【一】Mac版虚拟机CentOS搭建 【1】shell和ftp工具选择 选择是的mac版termius
【2】linux 命令 ip a / ip addr / ifconfig 不显示ip问题 原因：CentOS 7.x 默认不开启网卡
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8791f37beaea296b7d813dcb632e3f98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb6b2ec9406186bcce4d370059aa130/" rel="bookmark">
			CSerialPort教程4.3.x (8) - CSerialPort调试模式的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSerialPort教程4.3.x (8) - CSerialPort调试模式的使用 前言 CSerialPort项目是一个基于C/C++的轻量级开源跨平台串口类库，可以轻松实现跨平台多操作系统的串口读写，同时还支持C#, Java, Python, Node.js等。
CSerialPort项目的开源协议自 V3.0.0.171216 版本后采用GNU Lesser General Public License v3.0
为了让开发者更好的使用CSerialPort进行开发，特编写基于4.3.x版本的CSerialPort教程系列。
CSerialPort项目地址：
https://github.com/itas109/CSerialPorthttps://gitee.com/itas109/CSerialPort 本文将介绍CSerialPort如何输出详细调试信息及日志。
1. 开启CSerialPort输出详细调试信息及日志 默认情况下，CSerialPort不会输出详细调试信息及日志。
可以通过宏定义CSERIALPORT_DEBUG来开启输出调试信息及日志(v4.2.2及以后版本支持)。
可以输出串口初始化、发送、接收、写缓冲区等详细调试信息。
相关代码位于include\CSerialPort\SerialPort_global.h中
#ifdef CSERIALPORT_DEBUG #include &lt;stdio.h&gt; #include &lt;string.h&gt; // strrchr #ifdef _WIN32 #ifndef __func__ #define __func__ __FUNCTION__ #endif #define LOG_INFO(format, ...) printf("[CSERIALPORT_DEBUG] %s - " format "\n", __func__, ##__VA_ARGS__) #else #define LOG_INFO(format, ...) printf("[CSERIALPORT_DEBUG] %s - " format "\n", __func__, ##__VA_ARGS__) #endif #else #define LOG_INFO(format, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deb6b2ec9406186bcce4d370059aa130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12005557aecbb2d2ec8ee96a860a999d/" rel="bookmark">
			mybatis入门的环境搭建及快速完成CRUD(增删改查)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又是爱代码的一天 一、MyBatis的介绍 ( 1 ) 背景 MyBatis 的背景可以追溯到 2002 年，当时 Clinton Begin 开发了一个名为 iBATIS 的持久化框架。iBATIS 的目标是简化 JDBC 编程，提供一种更直观、易用的方式来处理数据库操作。
在传统的 JDBC 编程中，开发人员需要手动编写大量的重复代码，如连接数据库、创建 Statement、执行 SQL 语句、处理结果集等。这些繁琐的操作不仅增加了开发的工作量，还使代码难以维护和理解。iBATIS 通过提供一个简单易用的 API，封装了这些繁琐的操作，使得开发人员可以更专注于业务逻辑的实现。
iBATIS 的核心思想是将 SQL 语句与 Java 代码分离，使用 XML 或注解的方式来定义和管理 SQL。这样一来，SQL 语句可以更方便地修改和维护，而且可以与 Java 代码解耦，提高了代码的可读性和可维护性。
随着时间的推移，iBATIS 被越来越多的开发人员所接受和使用。然而，iBATIS 的发展也面临一些挑战。比如，它的命名规范和配置方式相对复杂，不够直观；它对动态 SQL 的支持有限，不够灵活；它的插件机制不够完善，无法满足一些特定的需求。
为了解决这些问题，iBATIS 在 2010 年更名为 MyBatis，并进行了一系列的改进和扩展。MyBatis 在保留了 iBATIS 的优点的基础上，进一步增强了灵活性、可维护性和可扩展性。
MyBatis 提供了丰富的映射方式，可以将查询结果映射为 Java 对象、Map、基本类型等。它支持动态 SQL，可以根据条件动态拼接 SQL 语句，提高查询的灵活性和效率。同时，MyBatis 还提供了插件机制，开发人员可以根据实际需求编写插件，实现自己的业务逻辑。
除了 MyBatis 核心框架，还有一些扩展工具出现，进一步增强了 MyBatis 的功能和易用性。比如，MyBatis-Plus 提供了更多的 CRUD 操作和查询功能，简化了开发人员的工作；MyBatis Generator 可以根据数据库表结构自动生成代码；MyBatis Spring Boot Starter 则用于简化 MyBatis 在 Spring Boot 中的集成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12005557aecbb2d2ec8ee96a860a999d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f91ce0f1a5579e13398e6194c9d956/" rel="bookmark">
			socket调试工具、socket调试软件、tcp调试工具、tcp调试软件（sokit）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		真的非常好用，可做服务端，可做客户端
参考文章：socket调试工具
下载地址：https://www.jb51.net/softs/539324.html#downintro2
文章目录 20230816Socket调试工具、Socket调试软件、TCP调试工具、TCP调试软件（SoKIT）一、引言二、Socket调试工具与Socket调试软件2.1 Socket基础2.2 Socket调试工具的使用2.3 Socket调试软件的选择 三、TCP调试工具与TCP调试软件（SoKIT）3.1 TCP基础3.2 TCP调试工具的使用3.3 TCP调试软件（SoKIT） 四、总结 20230816 Socket调试工具、Socket调试软件、TCP调试工具、TCP调试软件（SoKIT） 一、引言 在进行网络编程或者开发网络应用时，调试是不可或缺的一部分。而对于底层的网络通信协议如TCP/IP和UDP等，使用特定的调试工具则更为方便有效。本文将主要讨论四个主题：Socket调试工具、Socket调试软件、TCP调试工具以及TCP调试软件（SoKIT）。我们会详细探讨他们的基础知识，使用场景，常见问题以及解决方法。
二、Socket调试工具与Socket调试软件 2.1 Socket基础 Socket被视为是网络通信的基石，它提供了程序之间通过网络进行数据交换的能力1。当两个程序想要通过网络进行通信时，每一个程序都会创建一个socket，并且这个socket有其唯一的socket描述符。
import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 2.2 Socket调试工具的使用 Socket调试工具可以帮助我们检查和理解应用程序中的socket通信。例如，我们可以使用Wireshark来捕获和分析网络流量2。另一个例子是Netcat，它是一个简单但功能强大的工具，可以用来读取和写入TCP或UDP连接3。
nc -l 1234 2.3 Socket调试软件的选择 选择合适的Socket调试软件也非常重要，不同的调试软件有着不同的特点和优势。例如，RawCap可以在Windows系统上无需任何驱动就能捕获本地回环流量4，而Tcpdump则是Linux下最常用的网络分析工具5。
tcpdump -i eth0 三、TCP调试工具与TCP调试软件（SoKIT） 3.1 TCP基础 传输控制协议（TCP）是一种面向连接的、可靠的、字节流的传输层通信协议，由Internet Engineering Task Force (IETF)的RFC 793定义6。
#include &lt;sys/socket.h&gt; int sockfd = socket(AF_INET, SOCK_STREAM, 0); 3.2 TCP调试工具的使用 TCP调试工具可以帮助我们查看和理解TCP连接中的数据流。例如，Tcpflow可以捕获并记录TCP流量，然后将流量按照每个连接拆分成单独的文件7。另一个工具是tcptrace，它可以分析TCP流量并生成各种统计信息8。
tcpflow -i eth0 port 80 3.3 TCP调试软件（SoKIT） SoKIT是一个强大的TCP/UDP调试工具，它允许用户发送自定义的TCP/UDP数据包，并接收和显示返回的数据包9。它的主要功能包括：
监听模式：监听指定端口，显示接收到的所有数据。客户端模式：连接到指定服务器，发送数据并显示接收到的数据。 sokit -l 8080 sokit -c www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f91ce0f1a5579e13398e6194c9d956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416198f332f293ed373231fd8d5a691f/" rel="bookmark">
			Linux aarch64交叉编译之 mesa图形库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于mesa的交叉编译。该文章的目标是编译一套aarch64 Linux Debian嵌入式版本上可以运行的版本库，接下来就开始趟坑。老套路，先把linux桌面版搞好，然后 移植到嵌入式Linux Debian 板子上。
1 mesa简介 Mesa 3D是一个在MIT许可证下开放源代码的三维计算机图形库，以开源形式实现了OpenGL的应用程序接口。OpenGL的高效实现一般依赖于显示设备厂商提供的硬件，而Mesa 3D是一个纯基于软件的图形应用程序接口。由于许可证的原因，它只声称是一个“类似”于OpenGL的应用程序接口。
简而言之，mesa就是一套OpenGL标准的实现库，接口都是一样的。
附上mesa的gitlab项目下载地址：https://gitlab.freedesktop.org/mesa/mesa/-/tree/main
2 Linux 本地编译 &amp; 交叉编译 2.1 Linux（ubuntu20.04）上mesa的编译 mesa是使用meson进行编译的，根据README.md的提示，编译关键步骤如下：
$meson build $ninja -C build $ninja -C build install 这里关于安装位置，可以通过--prefix=具体路径来设置。mesa编译后生成的是就是我们常见的OpenGL 的那种库，如下所示：
├── dri │ ├── armada-drm_dri.so │ ├── asahi_dri.so │ ├── etnaviv_dri.so │ ├── exynos_dri.so │ ├── hx8357d_dri.so │ ├── i830_dri.so │ ├── i915_dri.so │ ├── i965_dri.so │ ├── ili9225_dri.so │ ├── ili9341_dri.so │ ├── imx-dcss_dri.so │ ├── imx-drm_dri.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/416198f332f293ed373231fd8d5a691f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d42b2ba00407191c36d2ba432a086e/" rel="bookmark">
			华为认证为什么现在这么受欢迎？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为认证目前受欢迎的原因有很多，以下是其中一些主要原因：
高质量的认证培训：华为认证提供了一系列高质量的培训课程，涵盖了IT技术、网络安全、云计算等领域。这些培训课程由华为的技术专家和工程师团队设计和提供，内容丰富、权威性强，能够帮助学员系统地学习和掌握相关技术知识和实践技能。
市场需求：随着信息技术的快速发展和应用的普及，对于高素质、高技能的IT专业人才的需求不断增加。华为认证提供了与市场需求紧密结合的培训课程，帮助学员获得实际应用能力和解决问题的技能，提高了就业竞争力。
行业认可度：华为作为全球领先的信息和通信技术解决方案供应商，其技术和产品在全球范围内得到了广泛应用和认可。华为认证作为华为公司推出的认证体系，具有较高的行业认可度，被许多企业和组织所认可和采用。
就业机会：华为认证能够为学员提供更多就业机会。华为作为全球企业，拥有广泛的合作伙伴网络和客户资源，为通过华为认证的学员提供了更多的就业机会和职业发展空间。许多企业在招聘时会优先考虑拥有华为认证的人才。
国际化认证：华为认证是一个国际化的认证体系，学员可以在全球范围内进行认证考试和培训。这使得华为认证具有更高的国际认可度，为学员提供了更广阔的职业发展空间和机会。
持续更新的课程内容：华为认证持续更新课程内容，与技术发展同步，确保学员学到的知识和技能是最新的。这使得通过华为认证的学员具备了与时俱进的能力，能够适应行业的快速发展和变化。
良好的学习体验：华为认证注重学员的学习体验，提供了多种学习方式和学习资源，包括在线学习平台、实验室设备、教材等。学员可以根据自己的需求和时间安排自主学习，提高学习效果。
成本效益：相比其他认证体系，华为认证的培训费用相对较低，且提供了较多的优惠政策和奖励机制。这使得更多的学员能够接受华为认证的培训，提高自己的技能和竞争力，实现个人职业发展。
综上所述，华为认证之所以受欢迎，是因为其高质量的培训、与市场需求相匹配的课程、较高的行业认可度、更多的就业机会、国际化认证、持续更新的课程内容、良好的学习体验以及成本效益等因素的综合影响。这些因素使得华为认证成为IT专业人才提升技能、获得职业发展机会的重要途径之一。
华为认证自学资料--提取码:1234https://pan.baidu.com/s/1YJhD8QbocHhZ30MvrKm8hg 28.路由器进行数据包转发时需要修改数据包中的目的IP地址。
答案：错误
解析：路由器转发数据包就是这样，所以它始终是不会改IP地址的，只会改MAC。 当有数据包传到路由器时，路由器首先将其的目的地址与路由表进⾏对⽐
29.RSTP协议中，边缘端口收到配置BPDU报文，就丧失了边缘端口属性。
答案：正确
解析：但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通 STP 端口，并重新进行生成树计算，从而引起网 络震荡。
30.根桥交换机上所有的端口都是指定端口。
答案：正确
解析：只有非根桥设备才会存在有"根端口"的说法.而对于根桥自己，只需要指定自己的一个端口与对应的根端口对接。 所以根桥上都是指定端口，没有根端口。
31.二层组网中，如果发生环路则可能会导致广播风暴。
答案：正确
解析：二层网络设备处于同一个广播域下，广播报文在环路中会反复持续传送，无限循环，形成广播风暴，引发MAC地址表不稳定等故障现象，进而影响正常业务，导致用户通信质量较差，甚至通信中断。
32.Telnet基于TCP协议。
答案：正确
解析：telnet 端口号是23。 端口包括物理端口和逻辑端口。 物理端口是用于连接物理设备之间的接口，逻辑端口是逻辑上用于区分服务的端口。
33.IEEE802.11ac标准只支特5GHz频段。
答案：正确
34.STA发现无线网络的方式只有通过AP对外发送的Beacon帧。
答案：错误
解析： 缺省情况下，AP发送Beacon帧的周期为100TUs，2.4G射频发送beacon帧的速率为5.5Mbps，5G射频发送beacon帧的速率为6Mbps。
35.运行SNMP协议的网络设备可以主动上报告警信息以便网络管理员及时发现故障。
答案：正确
解析：SNMP定义了网管管理设备的几种操作，以及设备故障时能向网管主动发送告警。 网络管理使用SNMP协议时存在网络管理站 (NMS)、代理进程 (Agent)和被管理设备3个角色。
[单选题]
36.在RSTP网络中，为提高收敛速度可以将交换机与用户终端相连的端口定义为？
A.快速端口
B.备份端口
C.根端口
D.边缘端口
答案：D
解析：在RSTP标准中，为了提高收敛速度，将交换机直接与终端相连的端口定义为边缘端口。RSTP里面，如果某一个指定端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备直连，这种端口叫做边缘端口。 边缘端口不参与RSTP运算，可以由Disable直接转到Forwarding状态，且不经历时延，就像在端口上将STP禁用。 37.在WLAN中用于接收无线网络，区分不同无线网络的是？
A.AP Name
B.BSSID
C.OISS
D.VAP
答案：C
解析：SSID（Service Set Identifier）即服务集标识符，是 WLAN 网络的标识，用来区分不同的WLAN网络。
38.在WLAN发展历史中不包括以下哪种移动无线业务标准？
A.802.11b
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d42b2ba00407191c36d2ba432a086e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4802427f2366e9c12aea4aea6da9566/" rel="bookmark">
			C&#43;&#43; functional模板 #include ＜functional＞（提供了一种更通用的函数绑定和调用机制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::function提供了一种更通用的函数绑定和调用机制，可以将普通函数、lambda表达式、bind表达式以及其他function对象绑定到std::function，并能够通过std::function调用所绑定的对象，并可以根据不同的参数类型执行不同的操作。
示例：
#include &lt;functional&gt; #include &lt;iostream&gt; int func(int a, int b) { return a + b; } int main() { // 将函数func绑定到std::function std::function&lt;int(int, int)&gt; f = func; // 通过std::function调用绑定的函数 int result = f(1, 2); std::cout &lt;&lt; "result: " &lt;&lt; result &lt;&lt; std::endl; return 0; } 编译运行结果：
文章目录 20230816C++的&lt;functional&gt;库：通用函数绑定与调用机制目录1. 什么是`&lt;functional&gt;`库2. `&lt;functional&gt;`库的主要组件3. 如何使用`&lt;functional&gt;`库4. `std::function`5. `std::bind`6. `&lt;functional&gt;`库的应用案例7. 结论 20230816 C++的库：通用函数绑定与调用机制 在本文中，我们将探讨C++的&lt;functional&gt;库。它提供了一种更通用的函数绑定和调用机制，为程序员开发更加复杂和强大的功能提供了便利。
目录 什么是&lt;functional&gt;库&lt;functional&gt;库的主要组件如何使用&lt;functional&gt;库std::functionstd::bind&lt;functional&gt;库的应用案例结论 1. 什么是&lt;functional&gt;库 &lt;functional&gt;库是C++标准库的一部分，包含了一系列模板类，用于定义和处理函数对象（Functor），也被称为可调用对象(Callable Objects)。函数对象比普通函数更具灵活性，可以保持状态，封装多个函数或进行预设参数等操作。&lt;functional&gt;库不仅提供了对函数对象的支持，还提供了诸如函数绑定(std::bind)和函数包装器(std::function)等功能。
2. &lt;functional&gt;库的主要组件 以下是&lt;functional&gt;库中的主要组件：
Function objects：这是C++的核心概念之一，它允许程序员将函数视为对象。这样，我们就可以将函数作为参数传递，存储在容器中，或者作为其他函数的返回值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4802427f2366e9c12aea4aea6da9566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45b68e9add4d77a1699e1d4de8b0d61/" rel="bookmark">
			【Git】git add撤销和git commit 撤销操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、git add 添加多余文件 撤销操作 git reset HEAD 后面什么都不跟的，就是上一次add 里面的内容全部撤销
git reset HEAD XXX 后面跟文件名，就是对某个文件进行撤销
二、git commit 撤销操作 git reset --soft HEAD^
这样就成功的撤销了commit操作
注意，仅仅是撤回commit操作，您写的代码仍然保留。
git reset 其他参数说明： –mixed
意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作
这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。
–soft
不删除工作空间改动代码，撤销commit，不撤销git add .
–hard
删除工作空间改动代码，撤销commit，撤销git add .
注意完成这个操作后，就恢复到了上一次的commit状态。
commit注释写错了，只是想改一下注释，只需要：
git commit --amend
此时会进入默认vim编辑器，修改注释完毕后保存就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c6f96beca5e9f1ab815e904b44c4ec/" rel="bookmark">
			【Zorro】点击蒙层关闭模态框modal,用nzMaskClosable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 nzMaskClosable 例子： &lt;nz-modal nzTitle="新增流程" [nzMaskClosable]="false" [nzWidth]="1200" [(nzVisible)]="visible" [nzCancelLoading]="saving" [nzOkLoading]="saving" (nzOnCancel)="onModalCancel()" (nzOnOk)="onSave()" &gt; 官方属性 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0b7d302301c829d0e2dcdcb973dd7a/" rel="bookmark">
			【Zorro】【Dayjs】日期组件设置默认为当月第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 dayjs().startOf(‘month’).toDate()
ngOnInit() { this.form = this.fb.group({ fundCode: [[], []], // 组合名称 createdDateBegin: [dayjs().startOf('month').toDate()], // 日期开始 createdDateEnd: [new Date()] // 日期结束 }); this.getTableData(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c24945c4677d98dfd61d80751d8977c/" rel="bookmark">
			排序算法&amp;分析——什么时候 用 什么排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法 &amp; 分析 排序算法历史排序算法分析很快的排序较快的排序中等的排序很慢的排序 分析的结果0.没有要求1.对速度有要求2.边排序边操作3.条件1&amp;条件24.在有序数中操作5.条件1&amp;条件4 了解各种排序，详见排序专栏
排序算法历史 纵观排序算法的历史，有哪些排序算法的速度可以到达 O ( n l o g ( n ) ) O(n~log(n)) O(n log(n))？
冒泡排序（ B u b b l e Bubble Bubble S o r t Sort Sort）：冒泡排序是最简单的排序算法之一。它通过多次比较和交换相邻元素的方式，将最大（或最小）的元素逐渐“冒泡”到数组的一端。尽管冒泡排序的时间复杂度为 O ( n 2 ) O(n^2) O(n2)，效率较低，但它易于理解和实现。
选择排序（ S e l e c t i o n Selection Selection S o r t Sort Sort）：选择排序是一种简单直观的排序算法。它通过每次选择未排序部分的最小（或最大）元素，并将其放置在已排序部分的末尾，逐渐构建有序序列。选择排序的时间复杂度也为 O ( n 2 ) O(n^2) O(n2)，但相比冒泡排序，它的交换次数较少。
插入排序（ I n s e r t i o n Insertion Insertion S o r t Sort Sort）：插入排序是一种稳定的排序算法。它通过将未排序部分的元素逐个插入已排序部分的适当位置，来构建有序序列。插入排序的时间复杂度为 O ( n 2 ) O(n^2) O(n2)，但对于小规模或基本有序的数组，插入排序的性能较好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c24945c4677d98dfd61d80751d8977c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cdd91259bafaf4dc1a3360e083b03ab/" rel="bookmark">
			Android基础入门教程(非常详细)，从零基础入门到精通，看完这一篇就够了（附安装包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件下载
软件：Android Studio版本：2022
语言：英文
大小：1G
安装环境：Win11/Win10/Win8/Win7硬件要求：CPU@2.0GHz 内存@4G(或更高）下载通道①百度网盘丨下载链接：
https://pan.baidu.com/s/1ZdZOfCZz7LE2I6XVKuonNw?pwd=6789
提取码：6789
软件介绍
Android Studio 是谷歌推出的一个Android集成开发工具，基于IntelliJ IDEA. 类似 Eclipse ADT，Android Studio 提供了集成的 Android 开发工具用于开发和调试。 1.1 目标 创建Android项目
Android Studio中的gradle的介绍
使用Android Studio创建虚拟机
运行项目
工程创建与目录结构
1.2 重点 创建Android项目
使用Android Studio创建虚拟机
工程创建与目录结构
1.3 难点 掌握工程创建与目录结构
在虚拟机上运行自己的第一个项目
2 创建Android项目 step1: new Android Studio project
step2: Phone and Tablet
step3: 配置项目信息
step4: finish
3 Android Studio中的gradle的介绍 3.1 Gradle是啥？ gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。
所谓的构建过程就是:编译，测试，依赖管理，打包，部署。以前我们开发是手动导入jar包的，类似于面向过程，一步一步来，缺什么包就导什么包,很麻烦，容易出错，jar包版本还不统一，需要关心jar包与jar包之间的依赖。通过采用gradle的构建方式，只需通过complie xxxxx引入一个jar包，然后这个jar包所依赖的其他jar包gradle会自动帮引入，无需关心jar包与jar包之间的依赖，在什么地方以什么形式引入外部jar包，都委托给gradle管理了，体现了面象对象的思想，无需关心内部实现过程，直接引入就可。（注意Gradle不是一种编程语言,它不能帮你实现软件中的任何实际功能）
3.2 自动化构建工具有哪些？ Ant 2000年诞生，主要是编译代码，测试代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cdd91259bafaf4dc1a3360e083b03ab/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/59/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>