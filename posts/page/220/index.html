<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e601cba781e02f7fab30fea7f730799/" rel="bookmark">
			android设置Activity背景色为透明的3种方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一方法二方法三设置组件（button、TextView、EditView）为透明 这篇文章是我转载的，转载的目的： 1.懒，懒的自己重新写一篇。
2.毕竟不是自己的文章，博主删帖的话，我就失去了一个宝藏。 注：我在原文博主的基础上略做了修改，避免一些坑。
坑的地方：见附加部分
小心有坑
方法一 这种方法比较简单，只有一个步骤，只需要在配置文件中把需要设置为透明的activity的样式设置为
android:theme="@android:style/Theme.Translucent"
即可，这种方式只改变背景的颜色，对其他控件没有影响。但是它只能把背景设置为完全透明。如果要设置为半透明或者要设置透明的程度无法实现。
在实行方法一时遇到了一个问题：在我前面的文章有写：
方法二 这种方法也比较简单，只需要在方法一的基础上，再布局文件中配置背景颜色就可以。（但是我没有实现，一直是全透明）
android:background="#01000000"
“ #01000000”中“01”表示的是背景透明的程度，这个值只能设置01及以上的值，不能设置为00，及不能设置为完全透明，不过设置为01其实和透明的效果也很接近了，肉眼几乎看不出来区别了。这种方法同样对其他控件没有影响。
方法三 这种方法稍微复杂些，有几个步骤，这种方法对其他控件的透明度也会产生影响，并且可以自己设置透明的程度，相对来说要灵活一些。
第一步，在res/values下建立colors.xml文件，设置一个背景颜色，在这里可以设置你背景的颜色和透明度。
1.添加上自定义的颜色
&lt;color name="transparent"&gt;#55ff&lt;/color&gt; 第二步，在res/values/下建styles.xml,设置程序的风格(如果是android studio的话就不必建了，初始化即有)
&lt;style name="Transparent"&gt; &lt;item name="android:windowBackground"&gt;@color/transparent&lt;/item&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowAnimationStyle"&gt;@+android:style/Animation.Translucent&lt;/item&gt; &lt;/style&gt; 第三步，把这个styles.xml用在相应的Activity上。即在AndroidManifest.xml中的任意标签中添加
android:theme="@style/Transparent"
如果想设置所有的activity都使用这个风格，可以把这句标签语句添加在 &lt; application &gt; 中。
这个方法不仅对背景透明有效，而且对其他控件也有效，如果其他控件没有设置背景颜色，会呈现出透明的效果。这种方法比较复杂些，如果不是需要对整个页面及控件都有透明度要求，建议使用前面两方法。
设置组件（button、TextView、EditView）为透明 (这种方式不适合设置为背景透明)
在布局文件中添加：
android:background="#00000000" 8个0 ————————————————
版权声明：本文为CSDN博主「lily9」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lily9/article/details/11983221
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74c7d25d555fb1d8fbc0a75d1aa0f15/" rel="bookmark">
			maven 分模块项目 主子pom之间的引入依赖关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目时用到maven管理项目，在一个就项目的基础上开发新的项目；关于子项目和父项目，子项目与子项目之间的调用问题，发现自己存在不足，以下是自己查询的问题，解决了自己的疑惑。
原文链接：https://www.cnblogs.com/kuoAT/p/6845876.html
问题
下面是一个简略的项目结构图
Parent
`------ childA(BusinessLayer)
`--- pom.xml
`------ childB(WebLayer)
`--- pom.xml
`------ pom.xml
1、Parent怎么能找到childA和childB呢？
在maven中，parent模块组织好childA和childB，叫做"聚合"，多个模块联合编译。实现起来很简单，只需要在parent的pom文件里加入以下内容。
&lt;modules&gt; &lt;module&gt;childA&lt;/module&gt; &lt;module&gt;childB&lt;/module&gt; &lt;/modules&gt; 2、是不是这样写就完全ok了？
这样只是告诉maven编译器，在读取parent的pom文件时去找到childA和childB，但还是会分别去编译他们引入的依赖。这样就会导致pom文件引入的包重复！！于是我们引入了"继承"的概念，也就是形成"父子"关系，子pom可以引用到父pom中引入的依赖。具体做法如下：
在parent中，写入以下内容，其中"*"标识的行可以组成一个路径，通过这个路径可以在maven仓库中找到这个pom文件！本例中，path为M2_Path/com/sang/main/Parent-Moduel/1.0.2/xxxx-1.0.2.pom。所以这三个标签是必须的！！！
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.sang.main&lt;/groupId&gt; * &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt; * &lt;version&gt;1.0.2&lt;/version&gt; * &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;Simple-main&lt;/name&gt; 父pom写好了，子pom就通过&lt;parent&gt;标签继承父pom的依赖，如下：
&lt;parent&gt; &lt;groupId&gt;com.sang.main&lt;/groupId&gt; &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!--本例中此处是可选的--&gt; &lt;/parent&gt; 值得注意的是&lt;relativePath&gt;标签，如果pom的层次关系就像本例中的那样只隔一层，则可以省略这个。maven同样可以找到子pom。
子pom中引入&lt;parent&gt;标签后，就会从父pom继承&lt;version&gt;等属性了，例如childA只需要再加入如下内容即可！
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.sang.business&lt;/groupId&gt; &lt;!--和artifactId一起唯一标识这个jar文件--&gt; &lt;artifactId&gt;ChildA-module&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--指明打包类型--&gt; &lt;name&gt;childA&lt;/name&gt; 3、如何添加依赖？
maven可以让我们方便地管理jar包依赖，具体做法如下：
&lt;dependencies&gt; &lt;dependency&gt; &lt;!--添加一个jar包依赖--&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 如果不通过继承，则需要在每个pom中加入这样的依赖，这样子pom对应的模块可以引用到这个jar包。上面提到的重复引用jar包，可以通过下面的方式解决：
主pom中把依赖通过&lt;dependecyManagement&gt;引起来，表示子pom可能会用到的jar包依赖
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 子pom如果需要引用该jar包，则直接引用即可！不需要加入&lt;version&gt;，便于统一管理。此外也可以加入仅在子pom中用到的jar包，比如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c74c7d25d555fb1d8fbc0a75d1aa0f15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e811126c848a2dba7daa1307cd344f/" rel="bookmark">
			视觉SLAM十四讲 第八讲 视觉里程计2 8.5直接法BA法 代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体思路
提取特征点
构建图优化问题
边（误差项），在直接法中为光度误差
边的增量项
光度误差相对于李代数的雅可比矩阵：
图像坐标对李代数的雅可比矩阵
为 u 处的像素梯度
边的误差项
_error ( 0,0 ) = getPixelValue ( x,y ) - _measurement;
g2o优化库
增加顶点
增加边（每个特征点一条边）
优化迭代
代码
#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;list&gt; #include &lt;vector&gt; #include &lt;chrono&gt; #include &lt;ctime&gt; #include &lt;climits&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/features2d/features2d.hpp&gt; #include &lt;g2o/core/base_unary_edge.h&gt; #include &lt;g2o/core/block_solver.h&gt; #include &lt;g2o/core/optimization_algorithm_levenberg.h&gt; #include &lt;g2o/solvers/dense/linear_solver_dense.h&gt; #include &lt;g2o/core/robust_kernel.h&gt; #include &lt;g2o/types/sba/types_six_dof_expmap.h&gt; using namespace std; using namespace g2o; /******************************************** * 本节演示了RGBD上的稀疏直接法 ********************************************/ // 一次测量的值，包括一个世界坐标系下三维点与一个灰度值 struct Measurement { Measurement ( Eigen::Vector3d p, float g ) : pos_world ( p ), grayscale ( g ) {} Eigen::Vector3d pos_world; float grayscale; }; inline Eigen::Vector3d project2Dto3D ( int x, int y, int d, float fx, float fy, float cx, float cy, float scale ) { float zz = float ( d ) /scale; float xx = zz* ( x-cx ) /fx; float yy = zz* ( y-cy ) /fy; return Eigen::Vector3d ( xx, yy, zz ); } inline Eigen::Vector2d project3Dto2D ( float x, float y, float z, float fx, float fy, float cx, float cy ) { float u = fx*x/z+cx; float v = fy*y/z+cy; return Eigen::Vector2d ( u,v ); } // 直接法估计位姿 // 输入：测量值（空间点的灰度），新的灰度图，相机内参； 输出：相机位姿 // 返回：true为成功，false失败 bool poseEstimationDirect ( const vector&lt;Measurement&gt;&amp; measurements, cv::Mat* gray, Eigen::Matrix3f&amp; intrinsics, Eigen::Isometry3d&amp; Tcw ); // project a 3d point into an image plane, the error is photometric error // an unary edge with one vertex SE3Expmap (the pose of camera) class EdgeSE3ProjectDirect: public BaseUnaryEdge&lt; 1, double, VertexSE3Expmap&gt; { public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW EdgeSE3ProjectDirect() {} EdgeSE3ProjectDirect ( Eigen::Vector3d point, float fx, float fy, float cx, float cy, cv::Mat* image ) : x_world_ ( point ), fx_ ( fx ), fy_ ( fy ), cx_ ( cx ), cy_ ( cy ), image_ ( image ) {} virtual void computeError() { const VertexSE3Expmap* v =static_cast&lt;const VertexSE3Expmap*&gt; ( _vertices[0] ); Eigen::Vector3d x_local = v-&gt;estimate().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86e811126c848a2dba7daa1307cd344f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d06ae1a37bab99435dbde67e2bc8d8/" rel="bookmark">
			视觉SLAM十四讲 第八讲 视觉里程计2 8.5直接法 代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体思路
随机选取图像点
根据选取到的点和depth图、相机内参，获取这些点的三维空间点坐标
由三维空间点坐标，相机位姿，投影到第二幅图像的相机坐标，再由相机内参，投影到第二幅图像。
在第二幅图像上，遍历每个投影点，并累积该投影点固定窗口半径内的误差和雅可比
由雅可比矩阵计算Hessian矩阵和bias矩阵及代价
由LDLT分解法，求解增量，并由增量更新位姿T21 = Sophus::SE3d::exp(update) * T21。重复4-6设定的迭代次数。
代码
#include &lt;opencv2/opencv.hpp&gt; #include &lt;sophus/se3.hpp&gt; #include &lt;boost/format.hpp&gt; #include &lt;pangolin/pangolin.h&gt; using namespace std; typedef vector&lt;Eigen::Vector2d, Eigen::aligned_allocator&lt;Eigen::Vector2d&gt;&gt; VecVector2d; // Camera intrinsics double fx = 718.856, fy = 718.856, cx = 607.1928, cy = 185.2157; // baseline double baseline = 0.573; // paths string left_file = "./left.png"; string disparity_file = "./disparity.png"; boost::format fmt_others("./%06d.png"); // other files // useful typedefs typedef Eigen::Matrix&lt;double, 6, 6&gt; Matrix6d; typedef Eigen::Matrix&lt;double, 2, 6&gt; Matrix26d; typedef Eigen::Matrix&lt;double, 6, 1&gt; Vector6d; /// class for accumulator jacobians in parallel class JacobianAccumulator { public: JacobianAccumulator( const cv::Mat &amp;img1_, const cv::Mat &amp;img2_, const VecVector2d &amp;px_ref_, const vector&lt;double&gt; depth_ref_, Sophus::SE3d &amp;T21_) : img1(img1_), img2(img2_), px_ref(px_ref_), depth_ref(depth_ref_), T21(T21_) { projection = VecVector2d(px_ref.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d06ae1a37bab99435dbde67e2bc8d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076a60f78d56036aa6bef7af1590317a/" rel="bookmark">
			视觉SLAM十四讲 第八讲 视觉里程计2 8.3 使用LK光流 代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体思路
单层图像的光流
对第一帧图像提取FAST角点对提取到的角点提取光流特征检测及描述子生成，调用opencv的GFTTDetector对特征点，假定一个初始的运动量dx=0,dy=0。采用高斯牛顿法，最小化光度误差，求解运动量 雅可比矩阵dx/dt,dy/dt即u,v。由u+1的像素值减u-1的像素值，得到dx/dt，同理得到dy/dt。由雅可比矩阵构建 矩阵和 ，代价值为像素点x和运动后的x+dx点所在的灰度差。由LDLT分解求解dx，dy，即更新量。当代价值或更新量小于阈值时，停止，否则重复1-4步骤。 多层图像的光流
对第一帧图像提取FAST角点对提取到的角点提取光流特征检测及描述子生成，调用opencv的GFTTDetector构建4层图像金字塔由底层的图像的特征点坐标，映射到顶层的特征点坐标，构建特征点的金字塔。遍历每一层金字塔，对每层金字塔求光流 从分辨率最低的图像求LK光流初始值 最顶层，即分辨率最低的层，没有初始值，给一个初始的运动量dx=0,dy=0。从第二层到最底层，有初始值，dx=kp2[i].pt.x-kp.pt.x，同理初始化dy。 采用高斯牛顿法，最小化光度误差，求解运动量 雅可比矩阵dx/dt,dy/dt即u,v。由u+1的像素值减u-1的像素值，得到dx/dt，同理得到dy/dt。由雅可比矩阵构建 H=J^TJ 矩阵和 b=-J^Tf(x) ，代价值为像素点x和运动后的x+dx点所在的灰度差。由LDLT分解求解dx，dy，即更新量。当代价值或更新量小于阈值时，停止，否则重复1-4步骤。将求到的kp2，放到到下一层（坐标值乘以2）。 opencv的光流
直接调用calcOpticalFlowPyrLK函数计算光流，得到第二帧中关键点所在位置。
代码
// // Created by Xiang on 2017/12/19. // #include &lt;opencv2/opencv.hpp&gt; #include &lt;string&gt; #include &lt;chrono&gt; #include &lt;Eigen/Core&gt; #include &lt;Eigen/Dense&gt; using namespace std; using namespace cv; string file_1 = "./LK1.png"; // first image string file_2 = "./LK2.png"; // second image /// Optical flow tracker and interface class OpticalFlowTracker { public: OpticalFlowTracker( const Mat &amp;img1_, const Mat &amp;img2_, const vector&lt;KeyPoint&gt; &amp;kp1_, vector&lt;KeyPoint&gt; &amp;kp2_, vector&lt;bool&gt; &amp;success_, bool inverse_ = true, bool has_initial_ = false) : img1(img1_), img2(img2_), kp1(kp1_), kp2(kp2_), success(success_), inverse(inverse_), has_initial(has_initial_) {} void calculateOpticalFlow(const Range &amp;range); private: const Mat &amp;img1; const Mat &amp;img2; const vector&lt;KeyPoint&gt; &amp;kp1; vector&lt;KeyPoint&gt; &amp;kp2; vector&lt;bool&gt; &amp;success; bool inverse = true; bool has_initial = false; }; /** * single level optical flow * @param [in] img1 the first image * @param [in] img2 the second image * @param [in] kp1 keypoints in img1 * @param [in|out] kp2 keypoints in img2, if empty, use initial guess in kp1 * @param [out] success true if a keypoint is tracked successfully * @param [in] inverse use inverse formulation?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/076a60f78d56036aa6bef7af1590317a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d945e01cf9efbf92d629575669a05d/" rel="bookmark">
			启动应用程序时出现应用程序无法正常启动(0xc000007b)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在百度中搜索directx修复工具，点击下载安装
下载地址：https://www.onlinedown.net/soft/120082.htm
2.点击修复按钮进行电脑修复，修复完成后进行电脑重启
tupina
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ed1809a0dbdda69469704d5360b8db/" rel="bookmark">
			MATLAB的GUI如何清空坐标轴的图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面这两句即可实现清空GUI中的坐标轴
axes(handles.axes1); %指定需要清空的坐标轴 cla reset; 但假如你之前的坐标轴四周是有边框的，而且是没有坐标刻度和坐标值的，如下图所示，你会发现通过上面这两句代码虽然清空了坐标轴的内容，但是四周的边框消失了，而且还会自动给你的坐标轴加上了XY坐标刻度和坐标值，这时你需要通过代码来重新设置边框和删除坐标刻度：
axes(handles.axes1); %指定需要清空的坐标轴 cla reset; box on; %在坐标轴四周加上边框 set(handles.axes1,'xtick',[]); set(handles.axes1,'ytick',[]); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26f0c5e8cb9e1557dd638c413c5c821/" rel="bookmark">
			Android Studio如何去掉丑陋的标题栏//values文件夹结构的粗析//选择你的“APP theme”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：一、修改标题栏二、修改标题栏颜色三、修改你的app名四、选择你的应用主题（APP Theme）**附加：**背景透明设置背景透明的三种方法 前言： 测试环境：
1.（Android Studio）sdk 28
2.真机：Android6.0，对应API level 23
一、修改标题栏 1.首先进入到project模式下：
2.然后找到style.xml文件
路径：工程/app/src/main/res/values/style.xml
3.在这个文件里面，初始化状态下是第4行：
将
&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
修改为：&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;
4.真机验证，可以丑陋的标题栏去掉了。
5.如果我们要加一个标题栏，即如上使用DarkActionBar。
但是要注意一个问题：即当你的类继承的是Activity而不是AppCompatActivity时，DarkActionBar无效，依然不会有标题栏。
二、修改标题栏颜色 与style.xml同级下的colors.xml
①colorPrimary是应用主题颜色
②colorPrimaryDark是顶部状态栏的颜色
③colorAccent是editText（输入）框、按钮框等等的颜色
更改颜色的代码，在colors.xml和style.xml中要一致对应。
三、修改你的app名 第一种：
在与colors.xml同级的strings.xml中，修改：
&lt;string name="app_name"&gt;你的应用名&lt;/string&gt; 第二种：
在androidMainfest.xml中修改：
android:label="你的应用名" 注意：
若修改了androidMainfest.xml文件的lable为“mylable”，同时修改string中的app_name为“myappname”，则最后显示出来的以androidMainfest中的配置为准。
四、选择你的应用主题（APP Theme） 在styles.xml文件下：
我们可选择一下多种主题：
&lt;style name="AppTheme" parent="Theme.AppCompat.Light.Dialog"&gt; 1.Theme.AppCompat.Light.Dialog ： 是轻对话框的意思，应用效果如下：
上面的数字"6"是你的app _name(label).
2.警告对话框：
&lt;style name="AppTheme" parent="Theme.AppCompat.Dialog.Alert"&gt; 标题栏“6”那部分的灰色是这个主题下自带的，我设置的标题颜色本来是红色的。
**解释一下：**如果想去掉那个丑陋的黑框，可以这样配置：
&lt;style name="AppTheme" parent="Theme.AppCompat.Light.Dialog.Alert"&gt; light代表淡色的意思，默认是dark，即暗（深）色。
改完之后默认标题底色为白色。
暂时就写这些，关于诸如模式：
&lt;style name="AppTheme" parent="ThemeOverlay.AppCompat.Dark.ActionBar"&gt; 为什么打不开app 的问题以后再研究，准备抽空学习Android文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a26f0c5e8cb9e1557dd638c413c5c821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c9d78866eeebe9748c133d46d1389f3/" rel="bookmark">
			范围查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		范围查询 描述 数轴上有n个点，对于任一闭区间 [a, b]，试计算落在其内的点数。
输入 第一行包括两个整数：点的总数n，查询的次数m。
第二行包含n个数，为各个点的坐标。
以下m行，各包含两个整数：查询区间的左、右边界a和b。
输出 对每次查询，输出落在闭区间[a, b]内点的个数。
样例
见英文题面
限制
0 ≤ n, m ≤ 5×105
对于每次查询的区间[a, b]，都有a ≤ b
各点的坐标互异
各点的坐标、查询区间的边界a、b，均为不超过10^7的非负整数
时间：2 sec
内存：256 MB
#include&lt;stdio.h&gt; #include&lt;iostream&gt; #include &lt;vector&gt; #include&lt;string&gt; using namespace std; int main() { static vector&lt;char&gt; sum[5]; int count = 0; char temp1; cout &lt;&lt; "*********初始珠子\n"; sum-&gt;resize(500); char* pC = sum-&gt;data(); cin &gt;&gt; pC; //for (int i = 0; i &lt; 5; i++) {	//初始珠子 //	cin &gt;&gt; temp1; //	sum-&gt;push_back(temp1); //	count++; //} cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c9d78866eeebe9748c133d46d1389f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef410dbe4b5f48d71155f4fe96b1ad1/" rel="bookmark">
			灰度直方图均衡化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		灰度直方图均衡化 在计算机视觉和图像处理领域中，图像预处理起着重要的作用，其预处理效果直接影响整个 系统性能。图像预处理主要包括图像增强、滤波处理、边缘检测、旋转、变换等。 灰度直方图均衡化，在图像识别的过程中，增加灰度对比度可以突出图像重要的特征，直方图均衡化是通过改变每个灰度级上像素点分布，使其都具有相同的象素点数，目的是使图像在整个灰度值动态变化范围内分布均匀化，改善图像的亮度分布状态，增强图像的视觉效果。均衡化的原理是根据熵理论，可知当 H（0），H（1）， …，H（n-1）相等时，图像信息量最大。 灰度直方图均衡化matlab算法实现: clear all I=imread('2.jpg'); %读入JPG彩色图像文件 imshow(I) %显示出来 title('输入的彩色JPG图像') I_gray = rgb2gray(I); %灰度化后的数据存入数组 imwrite(I_gray,'1_gray.bmp'); %保存灰度图像 figure,imshow(I_gray); title('灰度图') [height,width]=size(I_gray); %测量图像尺寸参数 p1=zeros(1,256); %预创建存放灰度出现频率的向量 for i=1:height for j=1:width p1(I_gray(i,j) + 1) = p1(I_gray(i,j) + 1) + 1;%因为MATLAB下标是从1开始，所以0灰度对应在下标为1处 end end s=zeros(1,256); s(1)=p1(1); for i=2:256 s(i)=p1(i) + s(i-1); %累计直方图 end for i=1:256 s(i) = s(i)*256/(width*height); %求灰度映射函数 if s(i) &gt; 256 s(i) = 256; end end %图像均衡化 I_equal = I; for i=1:height for j=1:width I_equal(i,j) = s( I(i,j) + 1); end end p2=zeros(1,256); %预创建存放灰度出现频率的向量 for i=1:height for j=1:width p2(I_equal(i,j) + 1) = p2(I_equal(i,j) + 1) + 1;%因为MATLAB下标是从1开始，所以0灰度对应在下标为1处,改变后的直方图 end end figure,imshow(I_equal) %显示均衡化后的图像 title('均衡化后图像') imwrite(I_equal,'1_equal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ef410dbe4b5f48d71155f4fe96b1ad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d71d769550c11ddb8ecbbcc3bea87bf/" rel="bookmark">
			C语言循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、程序结构二、while循环三、do while循环四、循环的跳转五、while循环的应用六、for循环七、for循环嵌套八、循环的选择九、死循环十、应用技巧十一、课后作业十二、版权声明 一、程序结构 在C语言程序中，一共有三种程序结构：顺序结构、选择结构(if和switch分支结构)、循环结构；
1）顺序结构
从头到尾一句接着一句的执行下去，直到执行完最后一句；
2）选择结构
执行到某个节点时，根据判断条件的结果来决定执行分支的方向，由if和switch实现。
3）循环结构
循环结构有一个循环体，循环体里是一段代码。对于循环结构来说，判断循环的条件，来决定是否继续执行循环体，由while、do while和for来实现。
二、while循环 while循环的一般形式为：
while (表达式) { 语句块 } 意思是，先计算表达式的值，当值为真时（非0即是真），执行语句块，执行完语句块后，回到循环首部再次计算表达式的值，如果为真，又执行一次语句块……，这个过程会一直重复，直到表达式的值为假，就不再执行语句块。
循环也常常出现在我们的生活中，以超女选秀为例。
// 超女已准备出场 while (是否有未出场的超女) { // 判断超女的年龄 // 判断超女的身材 // 判断超女的颜值 // 送往后宫 } 超女选秀就是一个循环，是否有未出场的超女是循环首部要判断的条件，它的取值会随着循环次数的增加而改变，判断超女的年龄、判断超女的身材、判断超女的颜值、送往后宫是循环体，随着循环次数的增加，全部的超女已出场，循环体不再执行。
三、do while循环 do while循环的一般形式为：
do { 语句块 } while (表达式) do while先执行一次循环，然后再判断表达式的值，如果为真，再执行一次循环体，如此重复下去。
在实际开发中，几乎不用 do while，所以就不讲它了。
四、循环的跳转 continue和break两个关键字用在循环体中，用于控制循环体代码的执行流程。
continue跳转到循环的首部。
break跳出循环。
以超女选秀为例：
// 超女已准备出场 while (是否有未出场的超女) { // 判断超女的年龄 if (年龄小于16岁) continue; // 判断超女的身材 if (身材不火辣) continue; // 判断超女的颜值 if (颜值不漂亮) continue; // 判断已选出的超女数量，如果已经有10位了，就不要再选了 if (已选出的超女数量等于10) break; } // 送往后宫 超女出场后，先看看身份证上的年龄，如果不够16岁，没到法定年龄，评委就会说直接下一个，即continue，这个不够16岁的小姑娘直接回家。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d71d769550c11ddb8ecbbcc3bea87bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20c0d3af6efb2aa5b5506ec801e549a/" rel="bookmark">
			年月日格式判断-正则表达式 YYYY/MM/DD、YYYY/MM/DD| YY/MM/DD、 ^(^(\d{4}|\d{2})(\-|\/|\.)\d{1,2}\3\d{1,2}$)|(^\d{4}…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单的日期判断（YYYY/MM/DD）： ^\d{4}(\-|\/|\.)\d{1,2}\1\d{1,2}$ 二、演化的日期判断（YYYY/MM/DD| YY/MM/DD）： ^(^(\d{4}|\d{2})(\-|\/|\.)\d{1,2}\3\d{1,2}$)|(^\d{4}年\d{1,2}月\d{1,2}日$)$ 三、加入闰年的判断的： 实例： ^((((1[6-9]|[2-9]\d)\d{2})-(0?[13578]|1[02])-(0?[1-9]|[12]\d|3[01]))|(((1[6-9]|[2-9]\d)\d{2})-(0?[13456789]|1[012])-(0?[1-9]|[12]\d|30))|(((1[6-9]|[2-9]\d)\d{2})-0?2-(0?[1-9]|1\d|2[0-8]))|(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))-0?2-29-))$ 分析： 1、什么是合法的日期范围？对于不同的应用场景，这个问题有不同的解释。这里采纳MSDN中的约定：
DateTime值类型表示值范围在公元（基督纪元）0001 年 1 月 1 日午夜 12:00:00 到公元 (C.E.) 9999 年 12 月 31 日晚上 11:59:59 之间的日期和时间。
2、关于闰年的阐释。
关于公历闰年是这样规定的：地球绕太阳公转一周叫做一回归年，一回归年长365日5时48分 46秒。因此，公历规定有平年和闰年，平年一年有365日，比回归年短0.2422日，四年共短0.9688日，故每四年增加一日，这一年有366日，就是闰年。但四年增加一日比四个回归年又多0.0312日,400年后将多3.12日,故在400年中少设3个闰年,也就是在400年中只设97个闰年，这样公历年的平均长度与回归年就相近似了。由此规定：年份是整百数的必须是400的倍数才是闰年，例如1900年、2100年就不是闰年。
首先需要验证年份，显然，年份范围为 0001 - 9999，匹配YYYY的正则表达式为：
[0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}
其中 [0-9] 也可以表示为 \d，但 \d 不如 [0-9] 直观，因此下面我将一直采用 [0-9]
用正则表达式验证日期的难点有二：一是大小月份的天数不同，二是闰年的考虑。
对于第一个难点，我们首先不考虑闰年，假设2月份都是28天，这样，月份和日期可以分成三种情况：
1、月份为 1, 3, 5, 7, 8, 10, 12，天数范围为 01 - 31，匹配MM-DD的正则表达式为：
(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]) 2、月份为 4, 6, 9, 11，天数范围为 01-30，匹配MM-DD的正则表达式为：
(0[469]|11)-(0[1-9]|[12][0-9]|30) 3、月份为 2，考虑平年情况，匹配MM-DD的正则表达式为：
02-(0[1-9]|[1][0-9]|2[0-8]) 根据上面的成果，我们可以得到匹配平年日期格式为YYYY-MM-DD的正则表达式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f20c0d3af6efb2aa5b5506ec801e549a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3610e9dccac3d9aacb241c77047535/" rel="bookmark">
			Fast R-CNN 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fast R-CNN 详解 一、R-CNN 和 SPPNet（一）R-CNN 缺点（二）SPPNet 缺点 二、网络结构（一）RoI pooling（二）训练过程1. 监督预训练2. Fine-turning3. 多任务 loss4. SVD 分解全连接层5. SGD 超参数 Fast R-CNN 论文链接
Fast R-CNN 是一个 end-to-end 的目标检测模型（除了生成 region proposals 的部分）。它的 主要的创新 有以下几点：
（1）将目标的分类和 Bounding Box 的回归都集成在同一个网络且同时训练。
（2）提出了 roi pooling。使网络可以接受多尺度的输入。
（3）只对整个图像做一次特征提取，后多次利用。大大减少了 R-CNN 中冗余的特征提取操作。
（4）采用 SVD 分解对 Fast R-CNN 网络末尾并行的全连接层进行分解，减少计算复杂度，加快检测速度。
Fast R-CNN 在速度、精度、存储的占用上相对于先前的网络都有了质的飞跃。
一、R-CNN 和 SPPNet （一）R-CNN 缺点 我们先来看一下对于 R-CNN 有哪些缺点？
训练是多阶段的：R-CNN 中每部分的网络都需要单独的训练，步骤十分繁琐。
训练速度慢、占用空间多：R-CNN 中生成的 region 经过 CNN 网络提取特征之后，需要把每一个生成的 feature map 保存到硬盘。用于下一阶段 SVM 分类器的训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c3610e9dccac3d9aacb241c77047535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d72f6a22f2a7213d02f4b5b2a1d87fc/" rel="bookmark">
			nginx设置X-Frame-Options的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍nginx分别通过http和server设置 X-Frame-Options ，防止网站被别人用iframe嵌入使用。需要说明的是，只需用其中一个方法即可，在http配置代码块或server配置代码块里设置。
在http配置里设置X-Frame-Options在server配置里设置X-Frame-Options 在http配置里设置X-Frame-Options 打开nginx.conf，文件位置一般在安装目录 /usr/local/nginx/conf 里。
然后在http配置代码块里某一行添加如下语句即可：
add_header X-Frame-Options SAMEORIGIN; 如图所示：
在http配置里设置X-Frame-Options
添加后，重启nginx，命令是：
/usr/local/nginx/sbin/nginx -s reload 即可生效。
在server配置里设置X-Frame-Options 在server配置里设置X-Frame-Options跟在http配置里设置X-Frame-Options方法是一样的，同样是在server的配置代码块里添加如下语句即可：
add_header X-Frame-Options SAMEORIGIN; 如图所示：
在server配置里设置X-Frame-Options
添加后，重启nginx，命令是：
/usr/local/nginx/sbin/nginx -s reload 即可生效。
知识扩展 X-Frame-Options 响应头
X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 &lt;frame&gt;, &lt;iframe&gt; 或者 &lt;object&gt; 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。
X-Frame-Options 有三个值:
DENY
表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。
SAMEORIGIN
表示该页面可以在相同域名页面的 frame 中展示。
ALLOW-FROM uri
表示该页面可以在指定来源的 frame 中展示。
换一句话说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda0294e019b9e20cd5aa47cacdac200/" rel="bookmark">
			四个标志位SF,ZF,OF,CF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SF 结果为负，即符号位为1时SF=1，否则为0.
ZF 结果为0，ZF=1，否则为0
CF 最高位进位，CF=1，不进位为0
OF 两操作数符号相同但结果与符号位相反，OF=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f9ad49afc789eeccdd9cec27802324/" rel="bookmark">
			svg 组合标签g以及位移变换操作、文本标签text、image标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		g组合标签 &lt;g id='xx' stroke='xx' stroke-width='xx'&gt; 组合标签,对其中的图案进行整体操作,设置的属性必须是所有的图形都有的,不是指g标签内所有图形共有的 &lt;/g&gt; 共有属性: 样式 stroke、fill等样式 位移 translate='transform(xx,xx)' css样式的设置 transform='rotate(-90,350,350)'； 逆时针旋转,后面两个参数为旋转坐标 设置id属性 dom选中css操作 设置style属性 写共有样式 text文字标签 &lt;text&gt;文字&lt;/text&gt; 属性: x/y:基点,文字以x坐标开始,y坐标为基线之上，可以是百分比 font-size:设置字体 text-anchor:'middle'使一行文字的中心位置在基准点上 'start'从基准点开始(默认) 'end'结束位置在基准点 image图片标签 &lt;image x='' y='' width='' height='' xlink:href=''&gt;&lt;/image&gt; 属性: x/y:左上角坐标 width/height:大小设置 xlink:href='' :图片地址 代码示例:
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box{ width:600px; height:600px; margin:0 auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="border:solid 1px orange;" class='box'&gt; &lt;svg width='100%' height='100%' xmlns="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f9ad49afc789eeccdd9cec27802324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcd120997d678090faa5c2a40821eab/" rel="bookmark">
			Java InputStream 转 Byte Array 和 ByteBuffer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java InputStream 转 Byte Array 和 ByteBuffer 本文介绍如何实现InputStream 转 Byte Array 和 ByteBuffer，首先使用Java原生方式，然后介绍Guava和Commons IO。
1. 转成Byte数组 首先，我们看如何从简单输入流中获取字节数组。字节数组重要特性是应用索引按照每八个bit位方式快速访问内存中的值，因此可以操作这些字节至每一位。下面看使用不同方式实现转换。
1.1 使用纯Java方式 先从java处理固定长度流开始：
@Test public void givenUsingPlainJava_whenConvertingAnInputStreamToAByteArray_thenCorrect() throws IOException { InputStream initialStream = new ByteArrayInputStream(new byte[] { 0, 1, 2 }); byte[] targetArray = new byte[initialStream.available()]; initialStream.read(targetArray); } 对于应缓冲流，我们无法知道其底层数据确切大小，实现需更加灵活：
@Test public void givenUsingPlainJavaOnUnknownSizeStream_whenConvertingAnInputStreamToAByteArray_thenCorrect() throws IOException { InputStream is = new ByteArrayInputStream(new byte[] { 0, 1, 2 }); // not really unknown ByteArrayOutputStream buffer = new ByteArrayOutputStream(); int nRead; byte[] data = new byte[1024]; while ((nRead = is.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dcd120997d678090faa5c2a40821eab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad84b345c68d6dfbcaeb21f2a50048e/" rel="bookmark">
			required a bean of type &#39;xxx&#39; that could not be found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 解决办法required 属性 解决办法 新增 application.properties 配置 或者 application.yml 配置注意检查下配置完成后，是否有警告！ application.properties：
# mapper 映射地址（路径改成自己的哦） mybatis.mapperLocations=classpath:/com/example/springbootdemo/mapper/*.xml mybatis.type-aliases-package=com.example.domain application.yml：
# 配置 Mybatis.xml 位置 mybatis: mapper-locations: classpath:/com/example/springbootdemo/mapper/*.xml type-aliases-package: com.example.domain 错误原因：xxMapper 注入失败！
报错截图：
验证：是否是 Mapper 注入的问题（未添加上述配置文件时）
@Autowired 后面追加 (required = false): 表示支持 null运行，然后抛出 空指针异常。 required 属性 @Autowired(required=true)：当使用 @Autowired 注解的时候，其实默认就是 @Autowired(required=true)，表示注入的时候，该 bean必须存在，否则就会注入失败。@Autowired(required=false)：表示忽略当前要注入的 bean，如果有，直接注入；没有跳过，不会报错。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d46ec771bcf9b39b2615e6fc63da53/" rel="bookmark">
			MYSQL实现分组排序并取组内第一条数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用phabricator时，有这么一个需求。找出任务实际开始时间（自定义字段），思路就是找出ID最小的那个并用objectPHID分组。
思路是找到第一次改变 执行开始情况的记录，那么就要进行分组并找出符合条件的第一条记录。
第一种：
SELECT r.* FROM (SELECT * FROM maniphest_transaction where objectPHID in('PHID-TASK-iq5chdco7xnp6ohhvbzt','PHID-TASK-ctmpyikm2l33jlrld2m5') and metadata='{"customfield:key":"std:maniphest:uisftech:begins-the-situation"}'
order by id desc LIMIT 100
) r
GROUP BY r.objectPHID 加上limit 100，对排序进行固定。因为默认是升序，弊端：只能查出来limit后的数据。
第二种：
select * from maniphest_transaction where id in
(select min(id) mid from maniphest_transaction where objectPHID in('PHID-TASK-iq5chdco7xnp6ohhvbzt','PHID-TASK-ctmpyikm2l33jlrld2m5')
and metadata='{"customfield:key":"std:maniphest:uisftech:begins-the-situation"}'
group by objectPHID) 采用in和子查询，此处是min最小，如果要找出来最大，使用max(id)。
或者join
select * from checkin A join (select max(checkin_id) id from checkin GROUP BY card_id) B on A.checkin_id = B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d46ec771bcf9b39b2615e6fc63da53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f26d3bfbb9946e4a314e7461198878/" rel="bookmark">
			在方法内部获取方法的名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		StackTrace st = new StackTrace();
//0:取本身方法，1:取调用方法
StackFrame sf = st.GetFrame(0);
string methodName = sf.GetMethod().Name;
string className = sf.GetMethod().ReflectedType.Name;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f4ce7eeb85c78b7991b72de134f62b/" rel="bookmark">
			JS cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cookie主要用于缓存web页面用户的信息，它是一种将数据缓存到电脑上的文本文件。在web页面上用户的信息不会存储在后端 在页面上使用缓存来进行存储
在用户访问页面的时候，存储用户的信息到cookie 下次访问的时候，直接从cookie读取信息，并且cookie缓存存在有效期。
1：设置cookie
//cookie的简单建立 cookie 在有效期之后会自动删除 document.cookie="maodou"; 2：cookie的相关参数
//设置cookie 的相关参数 var date=new Date(); //expires 有效期 //path 指当前cookie的有效路径 不写的时候默认为有效路径 //cookie的建立 document.cookie = "username=maodou;expires=Mon Mar 16 2020 18:14:52 GMT+0800;"; document.cookie = "userpwd=12345;expires=Mon Mar 16 2020 18:14:52 GMT+0800;"; //设置cookie 成功之后 读取cookie var cookie = document.cookie.split(";"); console.log(document.cookie.replace(/\ /g, "")); var user = {}; var a = cookie[0].split("="); var b = cookie[1].split("="); user[a[0]] = a[1]; user[b[0]] = b[1]; console.log(user); 3：删除cookie 只要修改当前cookie的效期就可以
//设置有效期时间Thu, 01 Jan 1970 00:00:00 GMT 自动过期 document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38f4ce7eeb85c78b7991b72de134f62b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f427a5a844b037f08d6dec48864afb5/" rel="bookmark">
			HTML5video标签播放服务器视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var video=document.querySelector("#video"); //加载播放路径 video.src=""; //事件API //当浏览器加载媒体数据 video.onloadstart=function () { console.log("开始加载"); } //开始加载数据 video.onloadeddata=function(){ console.log("开始加载数据"); } //视频因缓冲停止播放执行的事件 video.oncanplay=function () { console.log("当前视频正在缓冲"); } //视频加载失败执行的一个脚本 video.onerror=function () { console.log("当前视频加载失败"); } //开始播放的时候 video.onplay=function () { console.log("当前视频开始播放"); } //暂停的时候产生的脚本 video.onpause=function () { console.log("当前视频暂停"); } //当设置为静音的时候执行的脚本 video.onvolumechange=function () { console.log("当前视频设置为静音"); } //正在播放执行事件 video.onplaying=function () { console.log("当前视频正在播放"); } //当播放位置发生变化执行事件 //是一个不断被监听的事件 video.ontimeupdate=function () { console.log("当前视频播放位置发生变化"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ee821cd95955b639fe02f042f5548e/" rel="bookmark">
			oracle 同比增长率计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同比计算公式：同比增长率 = (本年-上年)/上年 *100%
例如计算某个东西的绝对量的年度同比增长率
NVL (ROUND (NORM_VLAUE / LAG (NORM_VLAUE) OVER (ORDER BY NORM_NAME, "YEAR") * 100,2) - 100,'0') 计算公式：
ROUND (NORM_VLAUE / LAG (NORM_VLAUE) OVER (ORDER BY NORM_NAME, "YEAR") * 100
NORM_VLAUE 就是用来计算环比的值，按照NORM_NAME、YEAR来排序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422e96b3c9aa6c48aefc0477b13ed6d4/" rel="bookmark">
			【C语言】printf()和scanf()的*修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*修饰符的含义是抑制赋值。 printf() 和 scanf() 都可以使用*修饰符来修改转换说明的含义。但是，它们的用法不太一样。 首先来看printf()的*修饰符： 如果你不想预先指定字段宽度，希望通过程序来指定，可以用*修饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。
例如：如果转换说明是 %*d，那么参数列表中应包含 * 和 d 对应的值。
这个技巧也可用于浮点值指定精度和字段宽度。
举个例子： #include &lt;stdio.h&gt; int main() { unsigned width, precision; int number = 256; double weight = 242.5; printf("Enter a field width:\n"); scanf("%d", &amp;width); printf("The number is :%*d:\n", width, number); printf("Now enter a width and a precision:\n"); scanf("%d %d", &amp;width, &amp;precision); printf("Weight = %*.*f\n", width, precision, weight); printf("Done!\n"); return 0; } 再来看看scanf()的*修饰符： scanf() 中 * 的用法与 printf() 不同。把 * 放在 % 和转换字符之间时，会使得 scanf() 跳过相应的输出项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/422e96b3c9aa6c48aefc0477b13ed6d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027f7d97551b3a92ee2bc5d456d2bd0c/" rel="bookmark">
			矩阵内积、外积（克罗内克积）和Hadamard积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、矩阵的内积：两个矩阵A、B对应分量乘积之和，结果为一个标量，记作&lt;A,B&gt;（与向量的内积/点积/数量积的定义相似）。所以A、B的行数列数都应相同，且有结论&lt;A,B&gt;=tr(A^T* B)。
例如：, ,则&lt;A,B&gt;=1*5+2*6+3*7+4*8=70.
二、矩阵外积：（或向量外积/叉积/向量积），外积是一种特殊的克罗内克积，克罗内克积是两个任意大小的矩阵间的运算，结果是一个矩阵，记作。克罗内克积是张量积的特殊形式。
1.定义：如果A是一个m×n的矩阵，而B是一个p×q的矩阵，克罗内克积则是一个mp×nq的分块矩阵。
更具体地可表示为
2.例子：
三、矩阵的hadamard积：哈达玛积(Hadamard product)是矩阵的一类运算，若A=(aij)和B=(bij)是两个同阶矩阵，若cij=aij×bij,则称矩阵C=(cij)为A和B的哈达玛积，或称基本积。
设且，称m×n矩阵
为矩阵A与B的哈达玛(Hadamard)积，记作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb073c071d9522e4b0624497aa70977/" rel="bookmark">
			BeanUtils.copyProperties的使用(深拷贝，浅拷贝)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 场景BeanUtils是深拷贝，还是浅拷贝? 什么情况适合用BeanUtils有子对象就一定不能用BeanUtils么 代码例子dest ,src 还是 src,dest 这里说的是spring的BeanUtils.copyProperties。 场景 开发中经常遇到，把父类的属性拷贝到子类中。通常有2种方法：
1、一个一个set
2、用BeanUtils.copyProperties
很显然BeanUtils更加方便，也美观很多。
那么任何情况都能使用BeanUtils么，当然不是。要先了解他。
BeanUtils是深拷贝，还是浅拷贝? 是浅拷贝。
浅拷贝： 只是调用子对象的set方法，并没有将所有属性拷贝。(也就是说，引用的一个内存地址)
深拷贝： 将子对象的属性也拷贝过去。
什么情况适合用BeanUtils 如果都是单一的属性，那么不涉及到深拷贝的问题，适合用BeanUtils。
有子对象就一定不能用BeanUtils么 并不绝对，这个要区分考虑：
1、子对象还要改动。
2、子对象不怎么改动。
虽然有子对象，但是子对象并不怎么改动，那么用BeanUtils也是没问题的。
代码例子 下面用代码说明下。
翠山有个儿子无忌，儿子继承了他的face和height。
但是life应该是自己的。
后来翠山自刎而死，无忌也变成dead状态了。这就是浅拷贝，无忌用的life引用的翠山的life对象。
Father类：
@Data public class Father { private String face; // 长相 private String height; // 身高 private Life life; // 生命 } Life 类：
@Data public class Life { private String status; } Son类和main方法：
@Data public class Son extends Father{ private Life life; public static void main(String[] args) { Father cuishan = new Father(); cuishan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb073c071d9522e4b0624497aa70977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9dfba53a4609ff1104dc3fd9c0ca043/" rel="bookmark">
			显式切换，隐式切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.显示切换：
Intent intent=new Intent(MainActivity.this,SecondActivity.class); startActivity(intent); 2.隐式切换：
第一步：将将要打开的页面信息注册在 .xml 文件中
第二步：
3.显式切换与隐式切换的区别：
显式切换明确指定了需要切换到的页面。
隐式切换：有的时候，有的页面并不是我们自己写的，这个时候就只能通过隐式切换了
4.例子：
用隐式切换换方式打开浏览器页面，且页面直接访问百度网址：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0f9a3a7c79bd6ef8881f203840147f/" rel="bookmark">
			分别获取layer.open 和top.layer.open 打开弹框的 iframe 子页面元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 layer.open
layer.open({ type: 2, title: title, area: area, maxmin: true, content: url, yes: function(index, layero){ var iframeBody = layer.getChildFrame('body',index); var iframeElements = iframeBody.find('元素的id').val(); console.log(iframeElements) } }); top.layer.open
top.layer.open({ type: 2, title: title, area: area, maxmin: true, content: url, yes: function(index, layero){ // 这里不同 var iframeBody = top.layer.getChildFrame('body',index); var iframeInnerHTML =iframeBody[0].innerHTML; var iframeElements = iframeBody.find('元素的id').val(); console.log(iframeElements) } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01ac3e2945c3ec9ce120e41e82e5746/" rel="bookmark">
			lsof编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上看到许多人将lsof的源码拿来卖分，像这种开源资源也要花资源分去下载，看着真是有点不地道！特传至此，免费下载！ lsof命令在嵌入式中还是挺有用的，而在一般的嵌入式系统中，并没有移植该命令，需要自己移植。 本资源原下载地址：http://archive.ubuntu.com/ubuntu/pool/main/l/lsof/lsof_4.81.dfsg.1.orig.tar.gz 交叉编译步骤： export LSOF_CC=arm-linux-xx-gcc export LSOF_HOST="arm-linux" export LINUX_CLIB="-DGLIBCV=2" export LI NUX_KERNEL="/path/kernel/Trunk/src" export LSOF_INCLUDE="/path/arm-linux-gnueabihf/8.2.1/include" ./Configure linux make
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4586eb38e6865f947b217ef8e88c823a/" rel="bookmark">
			spring cloud feign 动态设置header
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、这是最简单的一个方法，但是需要对每个调用都一一添加，就是使用@RequestHeader注解添加参数到请求头中去
@FeignClient(name = "capability-register", fallback = ApiServiceClientFallBack.class )
public interface ApiServiceClient {
@GetMapping("/apiDebug/")
Result debug(@RequestParam("url") String path,
@RequestParam("param") String param,
@RequestParam("method") String method,
@RequestParam("appKey") String appKey,
@RequestHeader(name = "Token",required = true) String Token);
}
这里需要注意，其他几个参数都是调用debug接口需要的参数，使用此接口时，直接获取验证信息放进token中，就可以了
2、这个方法是网上大多数人的用法，但是我看到一个大神的博客，说是这种方法有点不好，然后大神自定义了一个Hystrix的策略，这个第三种方法再讲
这种方法是对所有的feign调用统一设置请求头
package com.hiynn.provider.configuration;
import feign.RequestInterceptor;
import feign.RequestTemplate;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import javax.servlet.http.HttpServletRequest;
/**
* @author lidai
* @date 2019/2/27 16:14
* &lt;p&gt;
* Feign调用的时候添加请求头Token
*/
@Configuration
public class FeignConfiguration implements RequestInterceptor {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4586eb38e6865f947b217ef8e88c823a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42dad268af1d21b91c8fba8debe29e09/" rel="bookmark">
			Leetcode双指针题（java作答）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
26.删除排序数组中的重复项
283.移动零
925.长按键入
面试题04.二维数组中的查找
532.数组中的K-diff数对
977.有序数组的平方
88.合并两个有序数组
349.两个数组的交集
830.较大分组的位置
26.删除排序数组中的重复项 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array
class Solution { public int removeDuplicates(int[] nums) { int j=0; for(int i=1;i&lt;nums.length;i++){ if(nums[j]!=nums[i]){ nums[j+1]=nums[i]; j++; } } return j+1; } } 283.移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
必须在原数组上操作，不能拷贝额外的数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42dad268af1d21b91c8fba8debe29e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94181c6ddc644e655b4fc841ad79dd3/" rel="bookmark">
			计算机图形学学习笔记（5.2）：规则形体的表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实体模型的三类表示：
边界表示（Boundary Representation, B-reps），即用一组曲面（含平面）来描 述物体，这些曲面将物体分为内部和外部。边界表示具体又包括多边形表面模型和扫 描表示两种。 构造实体几何表示（Constructive Solid Geometry，CSG），它将实体表示成立 方体、长方体、圆柱体、圆锥体等基本体素的组合，可以采用并、交、差等运算构造新的形体。
空间分割表示（Space-Partitioning），用来描述物体的内部性质，将包含一物体的空间区域划分成一组小的、非重叠的、连续实体（通常是立方体）。
多边形表面模型 边界表示(B-reps)的最普遍方式是多边形表面模型，它使用一组包围物 体内部的平面多边形，也即平面多面体，来描述实体。
表面模型的数据结构如下图：
对于一个多边形平面，其几何信息用几何表来组织，它包括顶点坐标和标识多边形平面空间方向的参数。具体包括：顶点表、边表、多边形表。
任何多边形平面都有两个面，内侧面和外侧面。一般来说，法向量方向指向物体外 部。当多边形顶点序列指定后，它满足右手定则。
除了这三张表给出的几何信息外，还需要增加额外的信息来表示其拓扑信息。例如， 将边表扩充成包括指向面表和顶点表的指针。如下图的例子：
由此可构造出翼边结构表示（Winged Edges Structure），它对于一个多面体的每一 条边指出它的两个相邻面、两个端点，以及四条邻边。这四条邻边好象伸展的翅膀， 所以叫翼边结构表示。
在存储多边形的几何信息和拓扑信息后，还需要用属性表存储多边形面的属性，指明 物体透明度、表面材质和纹理特征等。
多边形网格：
三维形体的曲面边界通常用多边形网格（polygon mesh）的拼接来模拟。这些多边形往往是简单的三角形或四边形。
下图是Maya中的多边形网格：
构造实体几何表示 在构造实体几何法中，集合运算的实现过程可以用一棵二叉树（称为CSG树）来描述：
其中，树的叶子表示基础几何对象，非终端节点表示交并差补操作，根节点就是最终的CSG对象。
这种方法的优缺点如下：
优点：如果体素设置比较齐全，通过集合运算就可以构造出多种不同的符合需要的实体。
缺点：当用户输入体素时，主要是给定体素的有关参数，然后由系统给出该体素的表面方程，再由系统进行集合的求交运算，最后得到生成的实体。
这里面存在两个问题：
（1）一是集合运算的中间结果难以用简单的代数方程表示，求交困难；
（2）CSG树不能显式地表示形体的边界，因而无法直接显示CSG树表示的形体。
为了解决这两个问题，引入了光线投射算法。
光线投射算法
光线投射算法的核心思想是从显示屏幕（投影平面）的每一象素位置发射一根光线（射线）， 求出射线与距离投影平面最近的可见表面的交点和交点处的表面法矢量，然后根据光照模型计算出表面可见点的色彩和亮度，生成实体的光栅图形。
该算法的关键之处在于确定光线与距离投影平面最近的可见表面的交点，这可以通过集合成员分类算法实现。
具体算法步骤：
(1)将射线与CSG树中的所有基本体素求交，求出所有的交点；
(2)将所有交点相对于CSG树表示的物体进行分类，确定位于物体边界上的那部分交点；
(3)对所有位于物体边界上的交点计算它们在射线上的参数值并进行排序，确定距离最 近的交点。
空间分割表示 有三种表示方法：空间位置枚举表示、八叉树、BSP树。
空间位置枚举表示
将包含实体的空间分割为大小相同、形状规则（正方形或立方体）的体素，然 后，以体素的集合来表示图形对象。
用三维数组P[I][J][K]表示物体，数组中的元素与单位小立方体一一对应。
如上图，当P[I][J][K] = 1时，表示对应的小立方体被物体占据。当P[I][J][K] = 0时，表示对应的小立方体没有被物体占据
八叉树
八叉树（octrees）又称为分层树结构，它对空间进行自适应划分，采用具有层次结构的八叉树来表示实体。
下图展示了平面区域的四叉树表示：
对于3维实体，就需要八叉树来表示了。如下图所示，八叉树表示的形体非常容易进行集合运算：
BSP树
二叉空间分割（Binary Space Partitioning，BSP）方法每次将一实体用任一位置和任一方向的平面分为二部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c94181c6ddc644e655b4fc841ad79dd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b6fb3de4c14e2fc299f3bf6a427b24/" rel="bookmark">
			（牛客14602）xinjun与阴阳师（01背包变型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 链接：https://ac.nowcoder.com/acm/problem/14602
来源：牛客网
题目描述： xinjun是各类手游的狂热粉丝，因随手一氪、一氪上千而威震工大，现在他迷上了阴阳师。xinjun玩手游有一个习惯，就是经过层层计算制定出一套方案来使操作利益最大化(因此即使有扫荡券也不用，故称圣雄肝帝)。已知阴阳师有N个模式可以操作，模式i有ai种操作，但每种模式每日只能选用一种操作，可以不选。操作j能收益vj，但需要花费体力wj点。xinjun每日拥有体力M点，求他每日最多能得到多少收益。
输入描述： 第一行一个正整数T(T&lt;=10)，表示共有T组数据。
对于每组数据，第一行两个正整数N，M(1&lt;=N，M&lt;=1000)。
接下来N段数据，每段第一行一个正整数ai(1&lt;=ai&lt;=1000)，第二行ai个正整数vj(1&lt;=vj&lt;=1000)，第三行ai个正整数wj(1&lt;=wj&lt;=1000)。
每组数据ai之和不大于104。
输出描述： 对每组数据输出一行，即xinjun每日最多能得到多少收益。
输入 1
3 10
2
2 3
3 2
2
1 1
3 4
1
5
5
输出 9
这道题本质上还是01背包问题，只不过在此基础上又增加了一重循环（a[i]），多读几遍题目，把输入的数据先给屡清楚，只要输入的数据顺序懂了，那么按照01背包的思路去解就可以了，在此我推一下之前写的01背包模板题思路：01背包问题（动态规划）+一维数组的优化
下面是AC代码：
#include&lt;bits/stdc++.h&gt; using namespace std; int a[1010],v[1010][1010],w[1010][1010]; int dp[1010]; int main(){ int t,n,m,i,j,k; cin&gt;&gt;t;//t组数据 while(t--){ memset(dp,0,sizeof(dp));//每次输入前先重置dp[]，v[]和w[]没有必要重置 cin&gt;&gt;n&gt;&gt;m;//n个模式，m点体力 for(i=1;i&lt;=n;i++){ cin&gt;&gt;a[i];//每个模式下有a[i]种操作 for(j=1;j&lt;=a[i];j++){ cin&gt;&gt;v[i][j];//收益 } for(j=1;j&lt;=a[i];j++){ cin&gt;&gt;w[i][j];//消耗的体力 } }//-------------------以上是输入的数据----------------- //三重循环，思路还是01背包的思路 for(i=1;i&lt;=n;i++){//遍历n中模式 for(j=m;j&gt;=0;j--){//体力倒序遍历（01背包优化） for(k=1;k&lt;=a[i];k++){//遍历收益和体力 if(j&gt;=w[i][k]){ dp[j]=max(dp[j],dp[j-w[i][k]]+v[i][k]);//状态转移方程 } } } } cout&lt;&lt;dp[m]&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4587069b305448ce263419f85a4a69/" rel="bookmark">
			Oracle数据库文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、管理归档日志文件
修改归档模式
查看归档目标
查看归档日志信息
二、管理控制文件
1、控制文件是一个二进制文件，含有数据库的结构信息，包含数据文件和日志文件的信息。
2、控制文件的后缀是 .ctl，只有Oracle进程才能够安全地更新控制文件，所以不要手动编辑控制文件
3、多路复用控制文件：为了提高数据库的安全性，至少要为数据库建立两个控制文件，并且这两个控制文件最好分别保存在不同的磁盘中，这样就可以避免产生由于某个磁盘故障而无法启动数据库的危险，该管理策略被称为多路复用控制文件。如果多路复用控制文件中的某个磁盘发生物理损坏导致其所包含的控制文件损坏，数据库将被关闭（在数据库实例启动的情况下），此时就可以利用另一个磁盘中保存的控制文件来恢复被损坏的控制文件，然后再重新启动数据库，达到保护控制文件的目的。
4、更改control_files参数，更改控制文件
alter system set control_files='路径1','路径2','路径3'
scop=spfile;
5、复制控制文件：
停止OracleServiceORCL和OracleDBConsoleorcl服务， 创建新增加的路径和文件，更改文件名，最后启动OracleServiceORCL和OracleDBConsoleorcl服务
6、system用户下，v$logfile视图记录的是重做日志文件相关信息，v$datafile存放的是数据文件相关信息，
v$controlfile 存放的是控制文件相关信息，v$parameter存放的是spfile初始化参数文件中的所有参数及参数值。
7、创建控制文件步骤:
① shutdown immediate--关闭数据库
②备份所有数据文件和重做日志文件
③startup nomount--启动例程
④创建控制文件 create controlfile --创建控制文件 reuse database 'gwndb' --标识数据库名称 logfile --设置重做日志文件 group 1 'F:\APP\LENOVO\ORADATA\GWNDB\REDO01.LOG ', group 2 'F:\APP\LENOVO\ORADATA\GWNDB\REDO02.LOG', group 3 'F:\APP\LENOVO\ORADATA\GWNDB\REDO03.LOG' datafile --设置数据文件 'F:\APP\LENOVO\ORADATA\GWNDB\SYSTEM01.DBF', 'F:\APP\LENOVO\ORADATA\GWNDB\SYSAUX01.DBF', 'F:\APP\LENOVO\ORADATA\GWNDB\UNDOTBS01.DBF', 'F:\APP\LENOVO\ORADATA\GWNDB\USERS01.DBF', 'F:\APP\LENOVO\ORADATA\GWNDB\EXAMPLE01.DBF' maxlogfiles 50 --最大日志文件数量 maxlogmembers 3 --每一组中最大日志成员数量 maxdatafiles 200 --最大数据文件数量 noresetlogs --使用原有重做日志文件 noarchivelog; --使用原有归档日志文件 8、alter database backup controlfile .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e4587069b305448ce263419f85a4a69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8748f2c4ec0f861bff87975eb7f97d06/" rel="bookmark">
			printf打印函数的原理浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf的底层原理浅析 目录 printf的底层原理浅析前言函数变参格式解析一个简单的printf示例结语 补充 前言 最近在学习linux内核的时候用到了自定义实现的printf，学习了一下，在此记录，希望有助于大家。
在C语言中，我们用到的最多的输出功能函数大概就是printf了。但以前只是调用C语言的库函数，具体printf是如何实现的呢？
说到底两件事：
（1）、函数变参
（2）、格式解析
下面将简要介绍以上两点内容，最后附一个简单的printf例子。
函数变参 何为函数变参？简要来说就是参数个数不固定的函数。大部分时间，我们用的、写的都是参数固定的函数。但是为了应对想printf这种参数不固定的函数（），C语言提供了一种变参函数的机制。
int printf (const char *__format, ...); 如上所示为pritnf的声明。其中format就是我们以前写的格式化字符串，其中包括我们想输出的内容和参数占位符（用%+格式化字符来占位）。后面的 ‘…’，就是代表不固定的参数。
我们调用的使用像下面这样进行调用：
printf（“This is a test: %d,%c,%s”,a,b,c）; 这里的…，就代表了a,b,c三个参数。
说完了变参函数的概念，下面说说变参函数的实现原理。
我们知道，在调用函数的时候，函数的参数是在栈中分配的。 比如说调用下面这个普通函数。
//函数声明 int Add(int a,int b); //函数调用 Add(3,5); 其栈大概是向下面这样分配的。
如下图所示。
即，一般来说，栈空间是从搞地址向低地址分配，函数参数从右依次向左分配。分配完成之后，在函数内部的操作就是对这栈空间的变量进行的操作，这也是为什么我们在函数内部改变传入参数的值，却不能够传到函数外部的原因（如果不使用指针或者地址的话）。
而对于变参函数来说，其基本的传参原则是和上面说的一致。但是 由于其函数声明参数并不固定，所以有些栈中的变量是没有名字的，我们如果想使用这段空间，必须由我们自己通过指针来实现。
是不是有点蒙圈，有点绕？
小二，来点栗子。
如果我这样调用printf函数
printf（“This is a test: %d,%c,%s”,10,'A',"helloworld"）; 看下面栈的内存分配图。
如上图所示，在栈中只有format变量（字符指针类型，在printf的声明函数中定义了此参数），是有名字的，其他的三个内存空间里面只有值，但是没有名字来指明它们。所以，我们只能通过地址变量来找到（访问）它们。
这里要稍微补充一点，一般来说，对于变参函数来说，虽然其参数的个数是不固定的，但是其最少要有一个参数，就像printf函数中至少要有一个format参数一样（好像在宏定义变参函数中，可以由0个参数，这里不讨论）。
为什么呢？
答：这个最少要有的一个参数一般就是用来定位栈顶空间的。就像我们在上面描述的那样，栈内存的分配是从右向左的，最左边的参数就是栈顶元素。相当于，我们知道了栈顶的地址，只要再根据变参中每个参数的类型（int、char型等），相应的进行地址偏移，就可以访问变参的内容。
哎呀，又有一个问题了，在被调用的函数内部我怎么知道变参的类型是什么呢？
嘿嘿，还真是，一般你还真是不知道。这种情况下就需要调用者和被调用者商量好了。对于printf函数来说，调用者通过%+格式字符的方式通知了被调用者（printf的实现者）。
怎么通知的呢？
答：就是通过第一个format参数了。因为%+格式字符都是在format参数里的啊。
格式解析 弄懂了上面所说的，剩下的就没什么好说的了。 简单提一下。
简单来说就是扫描format参数里的字符，如果是普通字符就打印输出，如果是%，就说明后面有可能是格式字符，需要进行检测，然后从栈顶（其实是第一个参数的位置）弹出指定类型的数据，按照指定格式（十进制、十六进制、指定宽度、指定精度等等）进行输出。
基本上是一个字符串解析的过程。后面代码有解析，在此就不详述了。
一个简单的printf示例 //从传递的栈中获取参数的一些设置 typedef char * va_list; #define _INTSIZEOF(n) ((sizeof(n)+sizeof(int)-1)&amp;~(sizeof(int) - 1) )	#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) ) #define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) ) #define va_end(ap) ( ap = (va_list)0 ) #define BUFFER_SIZE 4096 static char print_buf[BUFFER_SIZE]; static char num_to_char[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8748f2c4ec0f861bff87975eb7f97d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3438853fa3d141182d5a1bb2859e3b79/" rel="bookmark">
			JS中Key-Value操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 -- 声明对象 var map = {} -- 添加/修改键值对 map['key1'] = 'key001' map['key2'] = 'key002' console.log(map['key1']) -- 输出：key001 console.log(map['key2']) -- 输出：key002 -- 遍历对象 for(var t in map){ if(map.hasOwnProperty(t)){ console.log(t + ' = ' + map[t]); } } -- 删除键值对 delete map['key1'] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5113543450d3d79c6bb414bd1d4ac58/" rel="bookmark">
			十六进制直接求补码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		举个例子，求060B的补码。
FFFF-060B+1=F9F5 首先设一个与被求数位数相同且每一位都是F的十六进制数，直接相减后加1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad9aae1a70367d8ada36811287d15e9/" rel="bookmark">
			数据就是由一个个表格组成的（通过表格理解Java中的类、对象、方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“数据就是由一个个表格组成的”这句话说的有点绝对，但就一般情况来讲，我们都可以这样理解数据。
无论是公司还是学校或者是我们身边，都要处理各种各样的数据，这些数据我们都可以把他们整理归纳成表格的形式。比如公司的员工情况，可以表示成以下形式：
这样以来，数据就更方便查看和更改。学校中关于我们的一些信息也都是用这样的表格形式呈现的，我们的学籍、课程表、成绩单等等…疫情期间，我们每天上报健康情况，包括时间地点健康情况由我们上报之后，经过处理最终都还是以表格形式进行存储。所以说“数据就是由一个个表格组成的”一点也不为过。
下面我们还以表格的形式再次理解一下Java中的类、对象、方法。
还以上面的表格为例子，表格记录了公司中每个员工的具体数据，我们可以定义一个叫Employee的类，代码如下：
class Employee{//定义的类 String name; String sex; String age; String job; String pay; String time;//类的属性 } 类是一个抽象的概念，公司员工情况就是一个类，我们把类再细分一下，类中的张三、李四、王五就是一个个对象。换句话说，类是抽象的群体概念，而对象是具体的独立个体，一个对象一定属于某个类，就类似张三属于某某公司，这也就说明了，类包含对象。这也就是类和对象的区别。
下面再为上面的表格添加一列数据，
这里的晨会说明是对所有对象都适用的，每个对象都要做的动作。代码描述：
package text;//包名 public class Employee{ String name; String sex; String age; String job; String pay; String time; public static void Chenhui(){ System.out.println("1. 8点打卡签到"); System.out.println("2. 8点10分开始晨会"); System.out.println("3. 8点30晨会结束喊加油"); } } 类中的Chenhui就是一个方法，表示的是一个对象能做什么，官方话就是：类或者对象的行为就叫做方法。关于方法，我上一个博客已经谈了许多，大家可以做个参考。
运用“10步天才(10 step)思维模型”（——尚学堂高琪）浅谈Java中的方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/891a9792ee685ad31a5d32ce47483878/" rel="bookmark">
			使用nodemcu玩转物联网系列（八）：notemcu通过mqtt协议“订阅功能”实现onenet设备的“旋钮”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、onenet数据流增加xuanniu，后边会用到；
2、onenet服务器进行应用设置，数据流选择xuanniu；
3、代码
led_pin = 1--需要控制的led灯 wifi.setmode(wifi.STATION) cfg = {} cfg.ssid = "kyn" cfg.pwd = "20160118" wifi.sta.config(cfg) wifi.sta.connect() DeviceId = "587667371" ProductId = "325428" AuthoInfo = "test" host = "183.230.40.39" port = 6002 timer = tmr.create() function con() if wifi.sta.getip() == nil then print("coneting........") else timer:stop() print("success!~") print(wifi.sta.getip()) --创建mqtt客户端 client_hum = mqtt.Client(DeviceId,120,ProductId,AuthoInfo) client_hum:connect(host,port,0, function(client) print("connect success!") end) function h() --订阅 client_hum:subscribe("$dp",0, function(client) print("subscribe success") end) --返回message client_hum:on("message", function(client,topic,message) print(message) --根据message返回的值，设置pmw，动态调节led灯亮度 pwm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/891a9792ee685ad31a5d32ce47483878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37ae55959108a674216b6d56f68c8c3/" rel="bookmark">
			github clone超时、速度慢，git设置代理和取消代理设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前用公司电脑一直好好的，今年新冠肺炎一直在家办公，公司还没通知何时去上班。本想在github上找几个demo学习，可是一直clone不下来。百度、google了一圈最后解决了。
设置代理
http代理：git config --global http.proxy 'http://127.0.0.1:1087' https代理：git config --global https.proxy 'https://127.0.0.1:1087' git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' 取消代理
git config --global --unset http.proxy git config --global --unset https.proxy 查看代理
git config --global --get http.proxy git config --global --get https.proxy 如果你在git操作时遇到网络非常慢、甚至超时的情况，可以试试设置代理或者取消代理能不能解决你的问题吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e925e55fde8104ceb5cdb0ce613b85/" rel="bookmark">
			【信号与系统】3. 阶跃函数、冲激函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阶跃函数、冲激函数均属于奇异函数
（奇异函数是指函数本身有不连续点或其导数或积分有不连续点的一类函数） 【 1. 阶跃函数 】 1. 单位阶跃函数 将 yn（t）的 n→ ∞ 得到 ε（t）。
2. 延迟单位阶跃函数 3. 阶跃函数的性质 （1）表示某些信号
（2）表示信号的作用区间
（3）积分
相当于对（-∞，t）区间内ε（t）与直线x=t、x轴包围图形的面积。
【 2. 单位冲激函数 】 对强度极大，作用时间极短的一种物理量的理想化模型。
1. 狄拉克定义 函数值只在 t=0 时不为 0 。积分面积为1。t=0 时，δ（t）→ ∞ ，为无界函数。 2. 函数序列定义 δ(t) 对 γ(t) 求导得到 pn(t) ，将 pn(t) 的 n→ ∞ 得到 δ(t) 。 δ(t) 为高度无穷大，宽度无穷小，面积为1的对称窄脉冲。
3. δ(t) 和 ε(t) 的关系 呈导数积分的关系：
4. 引入冲激函数后，间断点的导数也存在 5. 冲激函数的性质 （1）取样性（筛选性） 若 f(t) 在 t=0 处连续，且处处有界，则有
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09e925e55fde8104ceb5cdb0ce613b85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27834dfe6b5fa34936f2ebfdd9f32736/" rel="bookmark">
			反汇编基础、OllyDbg简介和界面、基本操作、初级TraceMe练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下使用的练习示例是《Windows程序设计》第五版第一章的HelloMsg.exe；以及《加密与解密》第三版附带的RebPE.exe；
一 反汇编基础 1 字节顺序
字节存储顺序
和CPU有关；微处理器的存放顺序有正序（Big-Endian），逆序（Little-Endian）；Intel逆序，Power-PC正序；
正序：高位字节存入低地址，低位字节存入高地址；
逆序：反之；
十进制7869，十六进制是1EBD；
看一下此数在emu8086中的存放；Intel逆序；低位字节存入低地址，高位字节存入高地址；
1E是高位字节，BD是低位字节；
1E存入01001单元，BD存入01000单元，逆序；
2 调试符号
Windows调试基础 - 符号
当应用程序被链接以后，代码被逐一地翻译为一个个的地址。
使用vs或者windbg等微软的调试工具进行调试的时候，可以方便地使用变量名来查看内存、可以使用函数名称来下断点、可以指定某个文件的某一行来下断点。
这一切背后，是符号在指导调试器工作，pdb或者dbg文件。
（.NET自己有元数据，符号不需要元数据已有的信息）。
程序运行的时候，计算机只需要逐条执行指令即可。而与源代码对应的关系是完全不需要知道的。这就给调试带来了困难。
无论什么编译都有自己的一套用于对应代码和可执行程序。各种编译器都有自己保存类似这种对应关系的办法，有的直接嵌入可执行文件，有的则是独立出来的。
而微软的编译器则是独立产生了这种文件，它就被成为符号文件。
符号文件一般都是pdb文件。
pdb文件，根据微软官方的解释，包含有： 全局变量；局部变量；函数名及入口点；FPO记录；源代码行号。
3 调试寄存器机制
利用调试寄存器机制
Win操作系统提供了两种层次的进程控制和修改机制：
跨进程内存存取机制；
Debug API 监控目标进程运行信息；
这两种是运行在“操作系统”层次之上的。
自386以后，Intel公司已经在其CPU内部集成了Dr0-Dr7一共8个调试寄存器；并且对EFLAGS标志寄存器的功能也进行了扩展，使其也具有一部分调试的能力。
调试信息通知机制。
作为接收方，不能直接接收DrX调试寄存器发出来的中断/异常信息，Windows已经将这个调试信息包装到了Debug API 体系中，每当DrX调试信息被触发时，ExceptionRecord.ExceptionCode部分都被设置成EXCEPTION_SINGLE_STEP，只需要在Debug API 循环中接受这个消息就可以达到目的。
自Win2000起，CreateProcess后，没有办法在目标进程的入口点地址处中断，常见的解决办法有两种。
1 利用Single Step机制
2 利用ntdll.ntcontinue作为跳板
二 OllyDbg 简介和界面 1
OllyDbg，简称OD；www.ollydbg.de；
结合了动态调试和静态分析；
调试Ring 3级程序的首选工具；
可识别大量被C和Windows频繁使用的函数，并能将其参数注释出；
开放插件接口，功能变得越来越强；
当前默认窗口是CPU窗口，调试的大部分操作在这个窗口中进行；它包含5个面板窗口：反汇编面板，寄存器面板，信息面板，数据面板，堆栈面板；
2
OllyDbg的配置
配置在菜单Options里，有界面选项、调试选项，配置保存在ollydbg.ini文件里；
Options-Appearance-Directories，设置UDD文件和插件的路径；
UDD文件是OllyDbg的工程文件，保存当前调试的一些状态，断点、注释等；
将插件复制到目录，主菜单会出现“Plugin”菜单项；
颜色：可根据喜好设置；
调试设置：一般按默认；异常（Exceptions），可以设置让OllyDbg忽略或不忽略哪些异常；可以全选；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27834dfe6b5fa34936f2ebfdd9f32736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5665c09e7fed8b4c5462c0ce41e8e405/" rel="bookmark">
			Leectcode417太平洋大西洋水流问题_med_C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。
规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。
请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。
提示：
输出坐标的顺序不重要
m 和 n 都小于150
示例：
给定下面的 5x5 矩阵:
太平洋 ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) *
~ 3 2 3 (4) (4) *
~ 2 4 (5) 3 1 *
~ (6) (7) 1 4 5 *
~ (5) 1 1 2 4 *
* * * * * 大西洋
返回:
[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5665c09e7fed8b4c5462c0ce41e8e405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866cff7a89bc7789941a654f5c55b6e7/" rel="bookmark">
			python 写入csv的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		法一：打开一个路径然后用csv.writer写入
#-*- encoding:utf-8 -*- import xlrd import csv # f = open('./dataset/keywords.csv', 'w', encoding='utf-8') #用with一样的： with open('./dataset/abstracts.csv', 'w',encoding='utf-8', newline='') as f: #newline是为了没空行 csv_writer = csv.writer(f,delimiter='\t') #这里可以设置分隔符，默认为用逗号分隔，这里用'\t' csv_writer.writerow(["NAME", "CONTENT", "STATUS"]) #写表头 bk = xlrd.open_workbook(filename) #把excel数据写到csv里面，#filename是excel的文件路径 try: sh = bk.sheet_by_name(sheetname) #excel的sheetname,一般默认是'Sheet1' except: print('no sheet in %s named %s'%(filename,sheetname)) nrows = sh.nrows #excel的行数 print(nrows) ncols = sh.ncols for i in range(1, nrows): #第一行是表头，从第二行开始写 cont = sh.cell_value(i, 1).rstrip() name = sh.cell_value(i, 0).rstrip() label = sh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/866cff7a89bc7789941a654f5c55b6e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abc28b98b906a5b49fb3974db0ffa67/" rel="bookmark">
			MultiBox 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MultiBox 详解 一、生成 Region proposals（一）网络部分（二）Bounding Box（三）置信度（四）损失函数1、Bounding Box Loss2、Confidence Loss3、最终的 Loss （五）三种优化方法 二、对 Region Proposals 分类 Scalable Object Detection using Deep Neural Networks 论文链接
在 R-CNN 网络中，提取 region proposals 使用的是一种传统的基于搜索的策略，这种策略的时间复杂度高而且生成的 region proposals 数量很多，不利于后续网络对生成的 region proposals 进行分类。在这篇论文中，作者提出了一种利用深度学习的方法提取 region proposals，大大减少了时间复杂度和生成 region proposals 的数量。而且可以进行多目标的检测。为之后提出的各种利用 CNN 网络生成 region proposals 的方法奠定了基础。
其中作者的主要实现的功能就是：在不知道类别的情况下定位目标，并提供定位此目标的 confidence。可以理解为，在不知道要分几类的情况下，定位出来图片中所有可能的候选目标。
一、生成 Region proposals 这一步也是本论文的核心，即如何使用 CNN 网络生成 region proposals。注意：无论是生成 Region 还是进行分类，对于 CNN 网络部分，作者使用的都是 AlexNet。
作者定义了一个新的 loss，通过最优化这个新的 loss，实现了对目标的定位，以及提供了在此回归框下的目标的置信度（此时还不知道目标的类别，只是预测了它框住的是一个物体的概率）
（一）网络部分 网络输出的 region proposals 的数量是固定的，这个数量通过超参数 K 指定。在试验中，作者使用的 K = 100 K=100 K=100 或 K = 200 K=200 K=200。我们将第 i i i 个对象框，以及与其关联的置信度，设置为最后一层的节点值。对于每个生成的 region 都有5个值，其中两个坐标（2 x 2 = 4 个值），还有一个置信度（1 个值）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6abc28b98b906a5b49fb3974db0ffa67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc01438d8d91587c4e702e6bb315977/" rel="bookmark">
			使用nodemcu玩转物联网系列（七）：notemcu通过mqtt协议“订阅功能”实现onenet设备的“开关”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现订阅功能：
mqtt:subscribe(topic, qos[, function(client)])
二、实现触发功能：
mqtt:on(event, function(client[, topic[, message]]))
参数：
event 可以是“ connect”，“ suback”，“ unsuback”，“ puback”，“ message”，“ overflow”或“ offline”
function(client[, topic[, message]])回调函数。第一个参数是客户端。如果event为“ message”，则接收第二个和第三个参数主题和消息（字符串）。
gpio.mode(2,gpio.OUTPUT) wifi.setmode(wifi.STATION) cfg = {} cfg.ssid = "kyn" cfg.pwd = "20160118" wifi.sta.config(cfg) wifi.sta.connect() DeviceId = "587667371" ProductId = "325428" AuthoInfo = "test" host = "183.230.40.39" port = 6002 url = 'http://api.heclouds.com/devices/'..DeviceId..'/datapoints?type=3' headers = 'api-key:BO6XuBiKw07JRXakBNvn4JKX7MI=\r\n' dht_pin = 5 --led灯连接在三脚 led_pin = 3 gpio.mode(dht_pin,gpio.INPUT) gpio.mode(led_pin,gpio.OUTPUT) timer = tmr.create() function con() if wifi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc01438d8d91587c4e702e6bb315977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ddf5d623f3cdfb0e6a975beee0e2e1/" rel="bookmark">
			使用nodemcu玩转物联网系列（六）：notemcu通过mqtt协议获取温湿度传感器值上传onenet服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gpio.mode(2,gpio.OUTPUT) wifi.setmode(wifi.STATION) cfg = {} cfg.ssid = "kyn" cfg.pwd = "20160118" wifi.sta.config(cfg) wifi.sta.connect() DeviceId = "587667371" ProductId = "325428" AuthoInfo = "test" host = "183.230.40.39" port = 6002 url = 'http://api.heclouds.com/devices/'..DeviceId..'/datapoints?type=3' headers = 'api-key:BO6XuBiKw07JRXakBNvn4JKX7MI=\r\n' dht_pin = 5 timer = tmr.create() function con() if wifi.sta.getip() == nil then print("coneting........") else timer:stop() print("success!~") gpio.write(2,gpio.HIGH) print(wifi.sta.getip()) client_hum = mqtt.Client(DeviceId,120,ProductId,AuthoInfo) client_hum:connect(host,port,0,function(client) print("connect success!") end) function h() status,temp,humi,temp_dec, humi_dec = dht.read11(dht_pin) print("DHT Temperature:"..temp..";".."Humidity:"..humi) --代码如下： weather表用来存储数据流Temperature和Humidity weather = {} weather.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ddf5d623f3cdfb0e6a975beee0e2e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869be41ac035896d682e37d6d9c56e08/" rel="bookmark">
			利用MATLAB尝试MD码编码与压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MD编码 1.1MATLAB代码：
clc clear A=[ 1 1 1 1 2 2 3 3; 1 1 1 1 2 2 3 3; 1 1 1 1 4 4 5 5; 1 1 1 1 4 4 5 5; 6 6 6 6 7 8 11 11; 6 6 6 6 9 10 11 11; 6 6 6 6 12 12 13 13; 6 6 6 6 12 12 13 13 ]; %a=num2str(123) %a=num2str(1,'%03d')自定义字符串长度，前补0 %a=str2num('234') %可以通过size(str)查看字符串长度 %b=dec2bin(a)十进制转二进制 %a=bin2dec(b)二进制转十进制 %ndims(x)纬度 %length(x)返回数组中长度最长的一维的长度。 %size(x)第一维 第二维 第三维…… %a1='abcd123';b1='decf456';c=[a1,b1]字符串拼接 %d=strcat(a1,b1) 字符串拼接 B(8,8)=0; %B(1,1)=1; for i=1:(size(A)) for j=1:(size(A)) a1=dec2bin(i-1); a2=dec2bin(j-1); b1=num2str(a1); b2=num2str(a2); if length(b1)&gt;length(b2) while length(b1)&gt;length(b2) b2=strcat('0',b2); end elseif length(b1)&lt;length(b2) while length(b1)&lt;length(b2) b1=strcat('0',b1); end end c=''; for k=1:length(b1) c=strcat(b2(length(b1)-k+1),c); c=strcat(b1(length(b1)-k+1),c); %c=strcat(b2(k),c); end B(i,j)=bin2dec(c); end end C(64,2)=0; for i=1:(size(A)) for j=1:(size(A)) C(B(i,j)+1,1)=B(i,j); C(B(i,j)+1,2)=A(i,j); end end D(64,2)=nan; k=1; for i=0:3 j=i*(length(A)/2)^2+1; if length(unique(C(j:j+(length(A)/2)^2-1,2)))==1 D(k,1)=C(j,1); D(k,2)=C(j,2); k=k+1; else for l=1:4 %j=j+l*(length(A)/2^2)^2; if length(unique(C(j:j+(length(A)/2^2)^2-1,2)))==1 D(k,1)=C(j,1); D(k,2)=C(j,2); k=k+1; j=j+(length(A)/2^2)^2; else for m=1:4 D(k,1)=C(j,1); D(k,2)=C(j,2); k=k+1; j=j+1; end end %j=j+(length(A)/2^2)^2; end end end D=D(1:k-1,:); %length(unique()) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869be41ac035896d682e37d6d9c56e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfc6cc3fc4d6a785b27e5346bd81ed7/" rel="bookmark">
			关于java.lang.NoClassDefFoundError: io/netty/channel/EventLoopGroup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错如下：
解决办法：
在pom中加入依赖：
&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.32.Final&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bae0383e92008dcbee29fc3f1c320e/" rel="bookmark">
			使用nodemcu玩转物联网系列（三）：nodemcu连接onenet服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个步骤：
1、建立客户端
mqtt.Client(clientid, keepalive[, username, password, cleansession, max_message_length])
该方法返回一个客户端对象。
2、连接服务器
客户端对象:connect(host[, port[, secure]][, function(client)[, function(client, reason)]])
gpio.mode(2,gpio.OUTPUT) wifi.setmode(wifi.STATION) cfg = {} cfg.ssid = "kyn" cfg.pwd = "20160118" wifi.sta.config(cfg) wifi.sta.connect() --牛逼的三元组 --mqtt.Client(clientid, keepalive[, username, password, cleansession, max_message_length]) 注意该函数，返回一个对象。这个对象再调用方法进行连接。 --设备ID，这个用作客户端的 clientid DeviceId = "587667371" --产品ID，这个用作客户端的 username ProductId = "325428" --鉴权信息，这个用作客户端的 password AuthoInfo = "test" host = "183.230.40.39" --端口不用加引号的 port = 6002 timer = tmr.create() function con() if wifi.sta.getip() == nil then print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38bae0383e92008dcbee29fc3f1c320e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/219/">«</a>
	<span class="pagination__item pagination__item--current">220/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/221/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>