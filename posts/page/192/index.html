<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8561fd3125f14a546b0f7a236cf054/" rel="bookmark">
			c&#43;&#43; string/char* 字符编码转换 (utf8,chs,gbk...)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文用于介绍不同编码格式的string（char*）之间的转换。明确Unicode，UTF-8，string，wstring概念，以及locale name之前， 先简单了解两个概念
字符集： 为每一个字符（asic，中文，日文，俄文等）分配一个唯一的ID（又称码位）。编码规则：将码位转换为字节序列的规则（编码/解码的过程） 由于UTF-8使用广泛，以utf-8编码为例，介绍其与其它编码方式的流程。
UTF-8 广义的Unicode的一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码……
UTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符。会将一个码位编码为 1 到 4 个字节（理论最多6个字节）：
1字节 一个US-ASCIl字符（Unicode范围由U+0000~U+007F）。2字节 带有变音符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文等字母（Unicode范围由U+0080~U+07FF）。3字节 其他语言的字符（包括中日韩文字、东南亚文字、中东文字等）包含了大部分常用字，使用3字节编码。4字节 其他极少使用的语言字符使用4字节编码。 Unicode/UCS-4bit数UTF-8byte数备注0000 ~ 007F0~70XXX XXXX1ASIC 码0080 ~ 07FF8~11110XXXXX 10XXXXXX20800 ~ FFFF12~161110 XXXX 10XXXXXX 10XXXXXX3以上基本定义范围：0~FFFF1 0000 ~ 1F FFFF17~2111110XXX 10XXXXXX 10XXXXXX 10XXXXXX4Unicode6.1定义范围：0~10 FFFF 上表是Unicode中任意字符使用utf-8编码的规则：如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的字节数，其余各字节均以10开头。
例如「知」的码位是 30693，记作 U+77E5（30693 的十六进制为 0x77E5），其对应的UTF-8 编码为字节序列 E79FA5。
根据上表中的编码规则，之前的「知」字的码位 U+77E5 属于第三行的范围，使用三个3个字节编码，将0x77E5的二进制位从地位开始放入编码模板的
7 7 E 5 0111 0111 1110 0101 二进制的 77E5 -------------------------- 0111 011111 100101 二进制的 77E5 1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行） 11100111 10011111 10100101 代入模版 E 7 9 F A 5 这就是将 U+77E5 按照 UTF-8 编码为字节序列 E79FA5 的过程。反之亦然。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b8561fd3125f14a546b0f7a236cf054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3c976cd85642a8e033a6396e7a77a6/" rel="bookmark">
			Mysql查询时的多表连接查询，默认连接，等值连接，JOIN，LEFT JOIN，RIGHT JOIN，INNER JOIN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql查询时的多表连接查询 举个栗子等值连接自然连接：NATUEAL JOIN内连接：INNER JOIN或JOIN左外连接：LEFT OUTER JOIN或者LEFT JOIN右外连接：RIGHT OUTER JOIN或者RIGHT JOIN交叉连接（笛卡尔连接） 举个栗子 我们创建两张表来进行实验：
Table1：wgd_test
Table2：wgd_test1
后面为了展示RIGHT JOIN在Table2中新增了一条
等值连接 从上图中可以看出，该连接是在where子句中使用=号将两个表连接起来。
结果中展示的两个表中的所有列，包括在两个表中重复的列。
自然连接：NATUEAL JOIN 进行自然连接的两个表之间要求有共同的属性。
从上述的结果看，只展示了一条信息，并且第二个表的id属性和name属性也省略了：
1、只有一条是因为没有自定义连接条件，mysql会自然查询所有名字相同的属性，这个例子中就是id和name，只有这两个字段都相等的记录才会显示结果；
2、省略了第二个表的id和name字段，这个是自然连接的特性。
内连接：INNER JOIN或JOIN 内连接的话是在FROM关键字之后，两个表通过JOIN或者INNER JOIN连接。
（内连接是系统默认的，所以可以省略INNER仅仅使用JOIN）
查询结果展示符合条件的所有记录：这个记录中Table1的第一条记录连接了Table2的两条记录。
左外连接：LEFT OUTER JOIN或者LEFT JOIN 结果表中除了有满足条件的查询记录，还包括了左表的全部记录。
右外连接：RIGHT OUTER JOIN或者RIGHT JOIN 结果表中除了有满足条件的查询记录，还包括了右表的全部记录。
交叉连接（笛卡尔连接） 上图所示就是最基本的一个连接，不需要什么关键字，直接把各个表通过逗号列在那里就行。
上面这两张图其实是一样的，无条件的内连接就是笛卡尔连接。
注：左外连接和右外连接，除了符合条件的记录，左外连接时右边的表会显示null，右外连接时左边的表会显示null，利用这一点有时候可以做一些查询的优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4f91305a38ca891a17791e4ebf7158/" rel="bookmark">
			strassen矩阵乘法 java_分治法-Strassen矩阵乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法思想：分治法 实际问题：Strassen 矩阵乘法 编写语言：Java
问题描述
我们知道，两个大小为 2 * 2 的矩阵相乘，一般需要进行 8 次乘法。而Strassen矩阵乘法可以减少一次乘法，只需要 7 次，看似很少，但当数据量很大时，效率就会有显著提升。不过使用 Strassen矩阵乘法需要满足 矩阵边长为 2 的幂次方。因为该算法会用到分治，如果分治后矩阵两边边长不等，结果会出错。
使用下面的方法计算结果矩阵，假设两个长度为 2 的矩阵是 A，B，相乘后的结果矩阵为 C：
M1 = A11(B12 - B22)注：Anm 表示 A 矩阵第 n 行 k 列的值，Bnm，Cnm 同理
M2 = (A11 + A12)B22
M3 = (A21 + A22)B11
M4 = A22(B21 - B11)
M5 = (A11 + A22)(B11 + B22)
M6 = (A12 - A22)(B21 + B22)
M7 = (A11 - A21)(B11 + B12)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba4f91305a38ca891a17791e4ebf7158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a7bf675b50ef39a2e31f5dcc0a827d/" rel="bookmark">
			pytorch的两个函数 .detach() .detach_() 的作用和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：当我们再训练网络的时候可能希望保持一部分的网络参数不变，只对其中一部分的参数进行调整；或者值训练部分分支网络，并不让其梯度对主网络的梯度造成影响，这时候我们就需要使用detach()函数来切断一些分支的反向传播
一、tensor.detach() 返回一个新的tensor，从当前计算图中分离下来的，但是仍指向原变量的存放位置,不同之处只是requires_grad为false，得到的这个tensor永远不需要计算其梯度，不具有grad。
即使之后重新将它的requires_grad置为true,它也不会具有梯度grad
这样我们就会继续使用这个新的tensor进行计算，后面当我们进行反向传播时，到该调用detach()的tensor就会停止，不能再继续向前进行传播
注意：
使用detach返回的tensor和原始的tensor共同一个内存，即一个修改另一个也会跟着改变。
比如正常的例子是：
import torch a = torch.tensor([ 1, 2, 3.], requires_grad= True) print(a.grad) out = a.sigmoid() out.sum().backward() print(a.grad) '''返回： None tensor([0.1966, 0.1050, 0.0452]) ''' 1.1 当使用detach()分离tensor但是没有更改这个tensor时，并不会影响backward():
import torch a = torch.tensor([ 1, 2, 3.], requires_grad= True) print(a.grad) out = a.sigmoid() print(out) #添加detach(),c的requires_grad为False c = out.detach() print(c) #这时候没有对c进行更改，所以并不会影响backward() out.sum().backward() print(a.grad) '''返回： None tensor([0.7311, 0.8808, 0.9526], grad_fn=&lt;SigmoidBackward&gt;) tensor([0.7311, 0.8808, 0.9526]) tensor([0.1966, 0.1050, 0.0452]) ''' 从上可见tensor c是由out分离得到的，但是我也没有去改变这个c，这个时候依然对原来的out求导是不会有错误的，即
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85a7bf675b50ef39a2e31f5dcc0a827d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b935650c5189b3ae5281daa907a998b5/" rel="bookmark">
			边缘测量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 边缘定义 灰度明暗变化产生边缘，如何量化边缘的定义呢？
一维边缘的定义：图像中的点，其一阶导数绝对值是局部最大值，也被称为非最大抑制。一阶导数大于0是正边缘，小于0是负边缘。
等价定义：二阶导数过零的点。
按照上述定义，一维边缘就是点。与此相对应，二维边缘就是线，由一维边缘点组合而成的线（直线、曲线）。
二维边缘的定义：图像中的若干点组合成的线，这些点的方向导数在垂直于边缘的方向上局部最大的。或者说在这些点上梯度值在梯度方向上局部最大。
类似于一维边缘的定价定义：拉普拉斯算子过零的那些点。
但是，对于二维边缘来说，拉普拉斯和梯度计算出来的边缘位置通常是不同的，通过梯度计算二维边缘是首选。
2. HALCON 1D测量 HALCON一维测量的步骤如下：
1) 生成测量矩形或者测量弧形。算子有：
gen_measure_rectangle2 gen_measure_arc
2）执行测量。算子有：
measure_pos： extracts straight edges perpendicular to the main axis of the measure object and returns the positions of the edge centers, the edge amplitudes, and the distances between consecutive edges.
measure_pairs： extracts straight edge pairs perpendicular to the main axis of the measure object and returns the positions of the edge centers of the edge pairs, the edge amplitudes for the edge pairs, the distances between the edges of an edge pair, and the distances between consecutive edge pairs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b935650c5189b3ae5281daa907a998b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7468989d068612129954b4cf50fc861b/" rel="bookmark">
			Keil5中出现UNDEFINED SYMBOL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
一、.C中未定义。
二、.H中未引用。
三、未包含含有该类型的.H文件。
四、在keil中未添加.C或.H文件到工程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b1a05c741e895b4d731a541527f3e3/" rel="bookmark">
			python爬取贴吧数据_Python爬取某贴吧第一页的所有帖子的标题、连接、作者，将数据储存到txt文件中...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习网络爬虫的第二个程序：
#-*- coding:utf-8 -*-
#import re
import urllib
from bs4 import BeautifulSoup
import urlparse #处理url链接的库
import chardet #字符集检测
import sys #解决UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-15: ordinal not in range(128)
reload(sys)
sys.setdefaultencoding( "utf-8" )
"""
爬取某贴吧第一页的所有帖子的标题、连接、作者，将数据储存到txt文件中
"""
def get_content(url):
""" 获取页面源码"""
html = urllib.urlopen(url) #获取网站页面的地址
content = html.read() #将页面读取到content变量中
html.close() #关闭页面
#local = '/root/desktop/python/teiba.html'
#urllib.urlretrieve(url,local) #将页面源码下载的本地
#print chardet.detect(content) #检测网页的字符集，依据网页具体内容
return content
def get_author(info):
"""
提取帖子里面的作者
"""
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b1a05c741e895b4d731a541527f3e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f246476e1ebfc05e243aa9724496afd/" rel="bookmark">
			python字符串定界符_python字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，字符串属于不可变有序序列，使用单引号、双引号、三单引号或三双引号作为定界符，并且不同的定界符之间可以互相嵌套。除了支持序列通用方法(包括双向索引、比较大小、计算长度、元素访问、切片、成员测试等操作)以外，字符串类型还支持一些特有的操作方法，例如字符串格式化、查找、替换、排版等等。字符串属于不可变序列，不能直接对字符串对象进行元素增加、修改与删除等操作，切片操作也只能访问其中的元素而无法使用切片来修改字符串中的字符。最早的字符串编码是美国标准信息交换码ASCII，仅对10个数字、26个大写英文字母、26个小写英文字母及一些其他符号进行了编码。ASCII码采用1个字节来对字符进行编码，最多只能表示256个符号。
原始字符串 在一个字符串字面量前加一个字符r，表示这个字符串是原始字符串，其中的\不被当作是转义字符前缀。
&gt;&gt;&gt; s=r'hello\nworld'
&gt;&gt;&gt; print(s)
hello\nworld
字符串常用方法或函数
字符串常用方法或函数解释S.title()字符串S首字母大写S.lower()字符串S变小写S.upper()字符串S变大写S.strip(),S.rstrip(),lstrip()删除前后空格，删除右空格，删除左空格S.find(sub[,start[,end]])在字符串S中查找sub子串首次出现的位置S.replace(old,new)在字符串S中用new子串替换old子串S.join(X)将序列X合并成字符串S.split(sep=None)将字符串S拆分成列表S.count(sub[,start[,end]])计算sub子串在字符串S中出现的次数
查找子串 find() 在字符串中查找子串，返回第一次出现的位置下标(从0开始)，如果找不到返回-1。
&gt;&gt;&gt; s='He is a student'
&gt;&gt;&gt; print(s.find('is'))
3
&gt;&gt;&gt; print(s.find('am'))
-1
&gt;&gt;&gt; s='This is a test'
&gt;&gt;&gt; print(s.find('is',3)) #指定查找开始位置
5
&gt;&gt;&gt; print(s.find('is',3,6)) #指定查找开始位置及终止位置
-1
统计子串出现的次数count()
&gt;&gt;&gt; s='This is a test.'
&gt;&gt;&gt; print(s.count('is'))
2
删除两端的空格
函数rstrip() 去掉字符串右边的空格函数lstrip() 去掉字符串左边的空格函数strip() 去掉字符串左右两边的空格
&gt;&gt;&gt; s=' hello '
&gt;&gt;&gt; s.rstrip()
' hello'
&gt;&gt;&gt; s.lstrip()
'hello '
&gt;&gt;&gt; s.strip()
'hello'
大小写转换
&gt;&gt;&gt; s="Hello World"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f246476e1ebfc05e243aa9724496afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e795aa4b084f0d2f97baaf841b95ce0/" rel="bookmark">
			js获取某一天的日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const nowTime = new Date("2000-01-22").getTime() const nowDate = new Date(nowTime + 13 * 24 * 60 * 60 * 1000); nowDate.setMonth(nowDate.getMonth()); var date = new Date(nowDate) var y = date.getFullYear() var m = date.getMonth() + 1 m = m &lt; 10 ? ('0' + m) : m; var d = date.getDate() d = d &lt; 10 ? ('0' + d) : d; var h = date.getHours(); h = h &lt; 10 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e795aa4b084f0d2f97baaf841b95ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0877445bcf03175d4bf747173653bc/" rel="bookmark">
			Flink: CEP详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文根据 Apache Flink 系列直播课程整理而成，由哈啰出行大数据实时平台资深开发刘博分享。通过一些简单的实际例子，从概念原理，到如何使用，再到功能的扩展，希望能够给计划使用或者已经使用的同学一些帮助。
主要的内容分为如下三个部分：
Flink CEP 概念以及使用场景。
如何使用 Flink CEP。
如何扩展 Flink CEP。
Flink CEP 概念以及使用场景
1.什么是 CEP CEP 的意思是复杂事件处理，例如：起床–&gt;洗漱–&gt;吃饭–&gt;上班等一系列串联起来的事件流形成的模式称为 CEP。如果发现某一次起床后没有刷牙洗脸亦或是吃饭就直接上班，就可以把这种非正常的事件流匹配出来进行分析，看看今天是不是起晚了。
下图中列出了几个例子：
第一个是异常行为检测的例子：假设车辆维修的场景中，当一辆车出现故障时，这辆车会被送往维修点维修，然后被重新投放到市场运行。如果这辆车被投放到市场之后还未被使用就又被报障了，那么就有可能之前的维修是无效的。
第二个是策略营销的例子：假设打车的场景中，用户在 APP 上规划了一个行程订单，如果这个行程在下单之后超过一定的时间还没有被司机接单的话，那么就需要将这个订单输出到下游做相关的策略调整。
第三个是运维监控的例子：通常运维会监控服务器的 CPU、网络 IO 等指标超过阈值时产生相应的告警。但是在实际使用中，后台服务的重启、网络抖动等情况都会造成瞬间的流量毛刺，对非关键链路可以忽略这些毛刺而只对频繁发生的异常进行告警以减少误报。
2.Flink CEP 应用场景 风险控制：对用户异常行为模式进行实时检测，当一个用户发生了不该发生的行为，判定这个用户是不是有违规操作的嫌疑。
策略营销：用预先定义好的规则对用户的行为轨迹进行实时跟踪，对行为轨迹匹配预定义规则的用户实时发送相应策略的推广。
运维监控：灵活配置多指标、多依赖来实现更复杂的监控模式。
3.Flink CEP 原理 Flink CEP 内部是用 NFA（非确定有限自动机）来实现的，由点和边组成的一个状态图，以一个初始状态作为起点，经过一系列的中间状态，达到终态。点分为起始状态、中间状态、最终状态三种，边分为 take、ignore、proceed 三种。
take：必须存在一个条件判断，当到来的消息满足 take 边条件判断时，把这个消息放入结果集，将状态转移到下一状态。
ignore：当消息到来时，可以忽略这个消息，将状态自旋在当前不变，是一个自己到自己的状态转移。
proceed：又叫做状态的空转移，当前状态可以不依赖于消息到来而直接转移到下一状态。举个例子，当用户购买商品时，如果购买前有一个咨询客服的行为，需要把咨询客服行为和购买行为两个消息一起放到结果集中向下游输出；如果购买前没有咨询客服的行为，只需把购买行为放到结果集中向下游输出就可以了。 也就是说，如果有咨询客服的行为，就存在咨询客服状态的上的消息保存，如果没有咨询客服的行为，就不存在咨询客服状态的上的消息保存，咨询客服状态是由一条 proceed 边和下游的购买状态相连。
下面以一个打车的例子来展示状态是如何流转的，规则见下图所示。
以乘客制定行程作为开始，匹配乘客的下单事件，如果这个订单超时还没有被司机接单的话，就把行程事件和下单事件作为结果集往下游输出。
假如消息到来顺序为：行程–&gt;其他–&gt;下单–&gt;其他。
状态流转如下：
1.开始时状态处于行程状态，即等待用户制定行程。
2.当收到行程事件时，匹配行程状态的条件，把行程事件放到结果集中，通过 take 边将状态往下转移到下单状态。
3.由于下单状态上有一条 ignore 边，所以可以忽略收到的其他事件，直到收到下单事件时将其匹配，放入结果集中，并且将当前状态往下转移到超时未接单状态。这时候结果集当中有两个事件：制定行程事件和下单事件。
4.超时未接单状态时，如果来了一些其他事件，同样可以被 ignore 边忽略，直到超时事件的触发，将状态往下转移到最终状态，这时候整个模式匹配成功，最终将结果集中的制定行程事件和下单事件输出到下游。
上面是一个匹配成功的例子，如果是不成功的例子会怎么样？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a0877445bcf03175d4bf747173653bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b4e23704b9c095ce52d77d4577d206/" rel="bookmark">
			windows自带whiteboard的妙用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无意中打开了白板，简单试用了一下，有点被惊艳到了：
1、手画功能。
2、可以插入照片，
3、可以插入备忘录.
4、可以摄像机抓拍。
5、可以使用模板。
6、自动保存到云.
7、可以搜索没有版权要求的图片。
8、有多个模板可供使用。
9、插入pdf，word，ppt等单张或多张内容。
10、直接从网页粘贴图文。
11、设置背景。
12、设置权限。
下载：https://c.landian.vip/mo/mss/Whiteboard.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19919584a878df01e33440a9884be8e6/" rel="bookmark">
			python中并集的符号_Python 集合set添加删除、交集、并集、集合操作符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中集合set是基本数据类型的一种，它有可变集合(set)和不可变集合(frozenset)两种。创建集合set、集合set添加、集合删除、交集、并集、差集的操作都是非常实用的方法。
1.创建集合 set类是在python的sets模块中，大家现在使用的python2.3中，不需要导入sets模块可以直接创建集合。
&gt;&gt;&gt;set('boy')
set(['y', 'b', 'o'])
2.集合添加、删除集合的添加有两种常用方法，分别是add和update。
集合add方法：是把要传入的元素做为一个整个添加到集合中，例如：
&gt;&gt;&gt; a = set('boy')
&gt;&gt;&gt; a.add('python')
&gt;&gt;&gt; a
set(['y', 'python', 'b', 'o'])
集合update方法：是把要传入的元素拆分，做为个体传入到集合中，例如：
&gt;&gt;&gt; a = set('boy')
&gt;&gt;&gt; a.update('python')
&gt;&gt;&gt; a
set(['b', 'h', 'o', 'n', 'p', 't', 'y'])
集合删除操作方法：remove
set(['y', 'python', 'b', 'o'])
&gt;&gt;&gt; a.remove('python')
&gt;&gt;&gt; a
set(['y', 'b', 'o'])
3.SET集合的遍历遍历Set:def iterSet():
s = set([1,2,3])
for item in s:
print(item)
for i in enumerate(s):
print (i)4.python集合操作符号、数学符号集合的交集、合集(并集)、差集，了解集合set的这些非常好用的功能前，要先了解一些集合操作符号
(本图片来源于网络)
简单的演示下差集、交集和合集的概念：
set集合是无序的，不能通过索引和切片来做一些操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789bac57e530bf77f3e77fe70d68dee5/" rel="bookmark">
			java和javaweb的区别_java和javaweb有什么关系吗？它们之间的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能很多入门学习java已经有一段时间的朋友还是没有很清楚，java和javaweb之间的一些联系是什么?或者说，这两者之间有一些什么样的区别呢?下面我们一起来看看吧。
首先我们需要弄清楚java跟Web之间的区别：
Web前端:
就是用来作我们可以看得到的像网站页面，aap、手机界面等，我们这里所说的前端泛指Web前端，也就是在Web应用中用户可以看得见碰得着的东西。
Java：更多的是与数据库进行交互以处理相应的业务逻辑。需要考虑的是如何实现功能、数据的存取、平台的稳定性与性能等。
Web前端分为网页设计师、网页美工、Web前端开发工程师。首先网页设计师是对网页的架构、色彩以及网站的整体页面代码负责网页美工只针对UI这块的东西，比如网站是否做的漂亮，Web前端开发工程师是负责交互设计的，需要和程序员进行交互设计的配合。
Web前端需要掌握的有脚本技术javascript DIV+CSS现下最流行的页面搭建技术，ajax和jquery以及简单的后端程序等。
那么实际的开发过程中，前端、Java开发人员的定位如下：
前端开发人员：精通JS，能熟练应用JQuery，懂CSS，能熟练运用这些知识，进行交互效果的开发。
Java开发人员：会写Java代码，会写SQL语句，能做简单的数据库设计，会Spring和iBatis，懂一些设计模式等。
Web项目是网页的编码，像jsp,servlet,struts这类的，但是java项目的话，是AWT,SWING这类的编码。最主要的区别是Web项目中的JAVA文件是tomcat服务器来触发的，但是java项目里的是Main()方法来开始的。还有一点是web项目需要服务器。
但是最后我们不得不说，java和javaweb之间其实没什么本质区别，我们可以说javaweb是java在web方面的应用，java是一种技术，可以用来开发应用程序和网站系统，但是java在开发应用程序方面有一定的先天不足，或者说不如别的技术方便吧，但是java在开发网页系统上有很大的优势，是当前java的主流应用方向，可以理解成javaweb就是java在开发web时的一种代号吧。
以上就是有关java与javaweb两者的相关内容了，你都了解了嘛，关注本站可以获取更多相关信息哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2748f55f5c91da1c9fc9d060f03f7c0a/" rel="bookmark">
			阅读笔记-蛋白质序列预训练ESM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读笔记-Biological structure and function emerge from scaling unsupervised learning to 250 million protein sequences 概要数据与模型同源性建模结构预测与比对特征的结合方法与数据数据集下游任务TransformerUniParc 模型UniRef模型ESM-1b 模型预训练任务 概要 \,\,\,\,\,\,\,\,\, 数十年来，公共数据库中蛋白质序列数量的增长呈指数趋势，从而深入了解了整个生命中蛋白质序列的广度和多样性。 该数据为使用人工智能研究生物学的预测和生成模型提供了有希望的基础。 本文的重点是使单个模型适合整个进化过程中的许多不同序列。 因此，本文研究了高容量的神经网络，研究了从大规模进化数据建模中可以学到的关于蛋白质生物学的知识。NLP中有一个假设：单词的语义可以从其出现的上下文中得出。最近，基于自我监督的技术已经被证明可以实现可以在自然语言任务中提升的词义表示，并且借助更大的训练数据集，模型学习此类表示的能力会显着提高。蛋白质序列产生于一个与自然语言极为不同的过程。这些模型和目标函数是否能有效地促进自然语言跨领域的迁移还不确定。最近，自我监督已成为人工智能研究的核心方向。 与需要对每个数据点进行手动注释的监督学习不同，自我监督方法使用未标记的数据集，因此可以利用大量数据。 自我监督学习使用代理任务进行训练，例如在给定所有先前单词的情况下预测句子中的下一个单词或预测从上下文中被掩盖的单词。
\,\,\,\,\,\,\,\,\, 本文探索了自我监督的语言建模方法，这些方法在一系列自然语言处理任务上表现出了最先进的性能，并将其应用于未标记氨基酸序列形式的蛋白质数据。 由于蛋白质序列使用的词汇量很少，只有二十个规范元素，因此建模问题与字符级语言模型相比，更类似于字符级语言模型。
数据与模型 \,\,\,\,\,\,\,\,\, 作者采用了UniProt数据集（250M条蛋白质序列），以MLM为目标来预训练模型。并且没有采用BPE算法来处理蛋白质序列。作者随机选取了1M条序列作为验证集，作者从Uniref50里随机选取了10%聚类保留集是所含的代表性序列组成测试集，并从训练集中删掉了这些聚类保留集。作者探讨了潜在的序列多样性对预训练数据的影响。UniParc聚类显示了簇大小的幂律分布，这意味着大多数序列属于簇的一小部分。使用序列的聚类训练的结果是对掩蔽语言建模损失的重新加权，朝向更多样化的序列集。作者使用UniRef 创建三个具有不同多样性水平的预训练数据集:(i)低多样性数据集(UR100)使用UniRef100代表性序列;(ii)高多样性稀疏数据集(UR50/S)使用UniRef50代表性序列;(iii)高多样性密集数据集(UR50/D)在UniRef50集群中均匀采样UniRef100序列。
作者训练的模型如下所示：
同源性建模 \,\,\,\,\,\,\,\,\, 进化是受约束的;如果对蛋白质的修饰导致其结构被打乱，生物体将失去这种功能并受损。因此，我们希望从数据库中提取的表亲集告诉我们，进化在哪里有自由统治，哪里有回旋的空间，哪里被完全制约。这些蛋白质系列的表示，被恰如其分地称为多序列对齐，是蛋白质结构预测管道的关键输入。直观地讲，在 3D 空间中接近的位置将共同演化，即一个位置的突变通常与另一个位置的容纳性突变同时发生。尽管直系同源基因的序列存在差异，但其结构和功能仍可能保留下来。每个点代表一个基因，每个基因都由其所属的直系同源基团着色（t-SNE降低了维数）。 直系同源基因群密集地聚集在训练的表示空间中。 相比之下，未经训练的表示空间和会标表示不能通过进化关系反映强大的组织。（b）在训练的表征空间中，与常见生物学变异相对应的基因线性相关。 基因由其直系同源基团着色，其种类由字符标签指示。 PCA在训练的表示空间中恢复物种轴（水平）和正交轴（垂直），但在未训练的或唯一字母空间中恢复。 表示形式来自在UniParc上训练的36层Transformer模型。
\,\,\,\,\,\,\,\,\, 作者对PFAM数据集中的PF01010蛋白质家族用训练前后的模型进行相似性分析，发现经过预训练后的模型能够捕捉到相同蛋白质家族内序列之间的相似性。如下图所示：
深蓝色：利用训练后的模型来提取的相似性较高的蛋白质序列浅蓝色：利用训练后的模型未对齐的蛋白质序列（可看作相似性较低）深红色：未训练的模型来提取相似性较高的蛋白质序列浅红色：未训练的模型来提取相似性较低的蛋白质序列图b是利用与训练前后的模型来提取相似性极高的蛋白质序列集的表示，并用来计算序列之间的余弦相似度。可以看出经过预训练的模型更能提取到相似性较高的序列之间的相似性。而图c是利用预训练前后的模型来提取相似性较低的蛋白质序列集的表示，并用来计算余弦相似度。可以看出预训练后的模型不但让相似性高的序列的表示向量相似，更能区分出相似性较低蛋白质序列。而未预训练的模型则不具备这种能力。 蛋白质中氨基酸在特定结构或功能背景下的可互换性取决于它们的生化特性。自监督可以捕捉这些模式，建立反映生化知识的表示空间。作者将各种氨基酸的表示向量利用t-SNE算法投影到二维空间（模型为36层的transformer），如下图所示：
氨基酸的生化特性在Transformer模型的输出嵌入中表示，这里用t-SNE表示。通过无监督学习，残基被聚集成疏水基团、极性基团和芳香基团，并通过分子量和电荷反映整体组织。
蛋白质嵌入将整个蛋白质表示为高维空间中的点。蛋白质的嵌入可以通过对序列中所有氨基酸的嵌入求平均值得到，接下来作者利用t-SNE算法将同源蛋白质的嵌入投影到二维空间，来研究同源基因在这个空间中是如何表现的。
上图a显示，预训练后模型提取到的蛋白质序列的嵌入，同源的蛋白质往往能聚集到一起，而训练前模型并不具备这种能力。
之后作者进行了蛋白质远程同源性检测，发现34层transformer的与训练模型在该任务上与基于比对的HMM模型的检测水平非常接近，Fold检测这项指标上甚至超过了HMM模型。
结构预测 为了预测蛋白质的三级结构信息，作者将两个单独的线性投影拟合到序列中位置对的隐藏表示中，使它们的点积回归到一个二进制变量，该二进制变量指示这两个氨基酸在空间中是否足够的接近。对于二级结构预测，作者使用来自预训练模型的表示向量通过全连接层去预测每个氨基酸对应的8种二级结构标签。
SSP:
Contact Pre：
上图表明了，ECE越低模型越能从蛋白质序列捕获到它的空间结构信息，并且模型容量越大，捕获到蛋白质序列的空间结构的能力上限越高。
与比对特征的结合 对于蛋白质序列x,作者探讨了三种整合表征学习信息的方法：
direct：直接将transformer的输出作为每个氨基酸的表示向量；avg：通过MSA将得到的多序列比对中相同位置处每个氨基酸的嵌入的平均值作为这个位置的最终表示；cov：在用PCA将输出嵌入降维后，使用来自x的MSA的序列之间的非中心协方差，为每对位置生成特征(感觉比较适合蛋白质三级结构预测的任务)。 结果显示在蛋白质二级结构预测的任务上，avg方法效果最好，成为了该任务的SOTA。
在蛋白质三级结构预测的任务上，cov成为了该任务的SOTA
方法与数据 数据集 训练集：
UR100：124.0M条UniRef序列；UR50/S：27.1M条UniRef50序列；UR50/D：从UniRef50集群中平均抽样了124.9M条序列； 验证集：1M，删除了序列长度超过1024个氨基酸的蛋白质序列。
下游任务 远程同源性检测；二级结构预测SSP；三级结构预测Contace Prediction；突变效应预测 Transformer layer normalizationno dropout除了输出层与输入层，其余全连接层均包含偏差q,k,v均为d维的，feed forward层是4d维的 UniParc 模型 UniRef模型 ESM-1b 模型 更大的学习率，使用了dropout，可以学习到的位置表示向量，输出层添加了LayerNorm，作者发现这些均有助于提升模型的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2748f55f5c91da1c9fc9d060f03f7c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935e3af87d14d0fc63b1fb3b7327cd52/" rel="bookmark">
			无人值守安装系统/Linux大作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无人值守安装系统 目 录
1.无人值守安装技术简介 1
1.1 PXE简介 1
1.2 PXE工作流程图 2
1.3 无人值守安装系统架构及工作原理 2
2. 无人值守系统搭建主要步骤 3
2.1 关闭防火墙和selinux 3
2.2 配置基础网络 3
2.3 CentOS7服务器部署DHCP服务 3
2.4 CentOS7服务器部署TFTP服务 5
2.5 CentOS7服务器部署HTTP服务 7
2.6验证实验 9
3. 总结 11
1. 无人值守安装技术简介 1.1 PXE简介 PXE(Pre-boot Execution Environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址，再用TFTP（trivial file transfer protocol）或MTFTP(multicast trivial file transfer protocol)协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端基本软件设置，从而引导预先安装在服务器中的终端操作系统。严格来说，PXE 并不是一种安装方式，而是一种引导方式。
1.2 PXE工作流程图
1.3 无人值守安装系统架构及工作原理 机器开机后, PXE BootROM（自启动芯片） 获得控制权之前先做自我测试，然后以广播形式发出一个请求 FIND 帧。如果服务器收到工作站所送出的要求, 就会送回 DHCP 回应, 内容包括分配的 IP 地址,及pxe引导程序名称，以及下载的地址。 否则, 服务器会忽略这个要求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935e3af87d14d0fc63b1fb3b7327cd52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde99352e545a5f8e68cf860415f5369/" rel="bookmark">
			java.util 语言_java中的import java.util是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中的import java.util是什么意思
发布时间：2020-06-17 10:00:01
来源：亿速云
阅读：177
作者：Leah
java中的import java.util是什么意思？针对这个问题，这篇文章给出了相对应的分析和解答，希望能帮助更多想解决这个问题的朋友找到更加简单易行的办法。
“import java.util.*”语句表示什么意思？
1、“import java.util.*;”表示的是把util这个包下的全部类导入到程序中；
2、导入“import java.util.*;”后程序中后面如果要用到util包里面的别的类都不需要再重新导入包了；
3、*表示的是通配符，包括util的所有类。
相关介绍：
import的两种导入声明
单类型导入(single-type-import) (例:import java.util.ArrayList; )；
按需类型导入(type-import-on-demand) (例:import java.util.*;)。
关于java中的import java.util的意思就分享到这里了，希望以上内容可以对大家有一定的帮助，可以学到更多知识。如果觉得文章不错，可以把它分享出去让更多的人看到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f069b5e4df899499e348c192d5017d/" rel="bookmark">
			关于css中height高度（100%与auto）使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		height：auto
默认情况下，浏览器会计算出实际的高度并填充
height：100%
基于包含它的块级对象的百分比高度
在使用百分比的高度不能填满时，可以设置高度为auto由浏览器自动计算出实际高度（轮播图中调节视频的高度）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19f223e242181db1c5cc48cabc9263a/" rel="bookmark">
			使用EPPlus实现Excel导出功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该示例是在APS.NET MVC使用EPPlus实现Excel导出功能，下面是导出Excel的demo：
前端代码 &lt;div style="float: left; margin-top: 10px; margin-right: 30px; "&gt; &lt;button class="btn btn-primary" type="button" onclick="Export()"&gt; 导出 &lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; function Export() { var data = {}; data["CODE"] = $("#CODE").val(); data["FACTORYNAME"] = $("#FACTORYNAME").val(); data["CREATEDON"] = $("#CREATEDON").val(); data["CREATEDON1"] = $("#CREATEDON1").val(); data["STATE"] = $("#STATE").val(); $.ajax({ url: "/PersonnelModule/YH_SPEED_APPLY/Export?r=" + Math.round(Math.random() * 10000), data: data, type: "POST", cache: false, async: false, dataType: "json", success: function (result) { if (result.url == "") { alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19f223e242181db1c5cc48cabc9263a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403cac80a2f30c421063144811acce9a/" rel="bookmark">
			说一说will-change
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、will-change是做什么的呢 CSS 是用来描述结构化文档（如HTML、XML）怎样渲染的语言。
CSS渲染器在渲染属性前，会有个准备的过程。有些属性需要css渲染器事先做很多准备才能实现渲染。这就容易导致页面出现卡顿，交互体验不好等问题。
如果设置了 will-change 属性，那么浏览器就可以提前知道哪些元素的属性将会改变，提前做好准备。待需要改变元素的时机到来时，就可以立刻实现它们。从而避免卡顿等问题。
例如，使用 3D Transforms 让元素在屏幕上移动时，此元素和它的上下文会被提到另一个“层”，独立于其它元素被渲染。这样那些不变的元素就能避免被重复渲染。这可以显著提高性能。
然而，将元素提取到一个新层，相对来说是代价较高的操作。这可能使 transform 动画延迟几百毫秒。
二、怎么用呢 下面是一个使用脚本应用 will-change 属性的例子：
var el = document.getElementById('element'); // 当鼠标移动到该元素上时给该元素设置 will-change 属性 el.addEventListener('mouseenter', hintBrowser); // 当 CSS 动画结束后清除 will-change 属性 el.addEventListener('animationEnd', removeHint); function hintBrowser() { // 填写上那些你知道的，会在 CSS 动画中发生改变的 CSS 属性名们 this.style.willChange = 'transform, opacity'; } function removeHint() { this.style.willChange = 'auto'; } 语法说明 Formal syntax: auto | &lt;animateable-feature&gt;# &lt;animateable-feature&gt; = scroll-position | contents | &lt;custom-ident&gt; will-change: auto will-change: scroll-position will-change: contents will-change: transform // &lt;custom-ident&gt; 的例子 will-change: opacity // &lt;custom-ident&gt; 的例子 will-change: left, top // &lt;animateable-feature&gt; 的例子 will-change: unset will-change: initial will-change: inherit auto 浏览器会根据情况，自行进行优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/403cac80a2f30c421063144811acce9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e07aaac5e804adb4c2cdf4bf89132fc/" rel="bookmark">
			openocd目录,OpenOCD一次调试多个设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I am trying to debug multiple devices at once with openocd on eclipse. I have 2x STM32F303 discovery borards, I have set the hla_serial flag to a proper board, but still no luck.
Separate boards are doing ok, but when trying to debug it's Eclipse saying it'came to error in last sequence.
So if anyone had experience with that. Thanks
解决方案
We can use hla_serial option within openocd 0.9+ ONLY.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e07aaac5e804adb4c2cdf4bf89132fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832d98a9e634625dbca524e2d6f46710/" rel="bookmark">
			java调用selenium_Java调用Selenium WebDriver在Firefox下测试示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用Java的Selenium WebDriver来做一个简单的测试示例，主要介绍如何调用Firefox浏览器测试。
步骤
Step 1：下载Selenium WebDriver
去 Selenium官网 下载最新版本的Java client，我这里下载的最新版本是3.1.0，下载的是一个压缩包，解压缩以后里面包括一个lib目录以及一个client-combined-3.1.0-nodeps.jar，后面都需要引入。
也可以通过maven在项目中直接引入，而不用下载：
org.seleniumhq.selenium
selenium-java
3.1.0
Step 2 ：下载geckodriver
去 mozilla/geckodriver 中下载最新的release版本的geckodriver，我这里下载的是v0.14.0，我暂时将其放到跟selenium-java-3.1.0的相同目录，如下图：
Step 3：编写java代码测试
新建Java工程，引入client-combined-3.1.0-nodeps.jar及其lib文件夹下的所有依赖jar，编写相应的java代码，目录结构及代码如下：
FirefoxUtils.java源码如下：
package utils;
import java.io.File;
import org.openqa.selenium.firefox.FirefoxBinary;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxProfile;
/**
* Firefox工具类
*
* @author dehua.ye
*
*/
public class FirefoxUtils {
/**
* 设置Firefox路径，返回FirefoxDriver
*
* @param path
* Firefox路径
* @return FirefoxDriver
*/
public static FirefoxDriver getFirefoxDriver(String path) {
File pathToBinary = new File(path);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/832d98a9e634625dbca524e2d6f46710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee8926707604d90650f2921b443a96a/" rel="bookmark">
			SQL语句统计排行前10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL语句统计排行前10 引言一、创建表二、插入数据三、执行查询1、统计当天迟到的人员名单2、统计当月迟到次数排行前十的人员名单 引言 场景：公司每天要进行打卡上班，每个人每天也可以多次打卡，所有打卡信息会记录到表A 中，表A中有name, date, time 等字段。
a. 统计当天迟到的人员名单，请写出相应的SQL。
b. 统计当月迟到次数排行前十的人员名单，请写出相应的SQL。
一、创建表 /**创建表：A*/ CREATE TABLE A(NAME VARCHAR(50),DATE DATE,TIME TIME); 二、插入数据 /*表A：插入数据*/ INSERT INTO A(NAME,DATE,TIME) VALUES('张小小','2021-02-17','08:50:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('张小小','2021-02-17','09:50:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('张小小','2021-02-17','09:26:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('张小小','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('赵晶晶','2021-02-17','09:13:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('赵晶晶','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('赵金晶','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('郭晓明','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('郭晓明','2021-02-17','09:13:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈菲菲','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('赵晶晶','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('赵金晶','2021-02-17','09:13:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈小梅','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('王小敏','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈小梅','2021-02-17','09:13:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('童薇薇','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('童薇薇','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('童芳芳','2021-02-17','09:13:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('张小龙','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('张小龙','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('张大雷','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈大雷','2021-02-17','09:13:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈大雷','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈小凤','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('李小风','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('李西风','2021-02-17','09:13:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('李小风','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈冬冬','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈冬冬','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('陈东东','2021-02-17','09:13:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('高小明','2021-02-17','09:14:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('高小明','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('郭子怡','2021-02-17','09:12:00'); INSERT INTO A(NAME,DATE,TIME) VALUES('高小凤','2021-02-17','09:12:00'); 三、执行查询 这里，我们需要指定一个数据基准：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee8926707604d90650f2921b443a96a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9708431db1b0aa8f5e1e465ff4a54240/" rel="bookmark">
			GD32F450 与 GD32F190 Colibri 开发板的 串口ISP下载程序方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GD32类似STM32可以用GigaDevice MCU ISP Programmer程序 以串口ISP方式下载 下载网址: https://www.cirmall.com/gd32f450mcu/?ziliao 按照Datasheet说明: (1) GD32F190 使用USART1 BOOT0: 接3.3V PA9: USATR1_TX PA10: USART1_RX (2)
GD32F450 使用USART0或USART2 GD32F450 使用USART0或USART2 BOOT0: 接3.3V PA9:USATR0_TX PA10:USART0_RX 或 PC10:USATR2_TX PC11:USART2_RX (3) 1，执行ISP Programmer程序,选择对应的串口.,2，开发板上电或按Reset键,3，再按ISP Programmer程序 的”Next”
,4，ISP Programmer程序侦测到 连接的信息,5，再按”Next”, 分辨出是GD32F450VET6
6，再按”Next”, 则进入ISP Programmer程序, 便可以清除;下载;上载或设定保护模式了 !!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7ceba9e455dffb1a4620b634442d7a/" rel="bookmark">
			[论文学习]DIVIDEMIX:带噪声标签的半监督学习LEARNING WITH NOISY LABELS AS SEMI-SUPERVISED LEARNING
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文研究含噪声标签数据的训练，是目前该领域的SOTA。主要方法是：首先使用高斯混合模型，根据训练集每样本的损失函数值对样本进行分类，分为干净样本和噪声样本，把噪声样本作为无标签样本；然后使用半监督学习常用的协同训练法，即同时训练两个分歧网络，互相使用另一个网络的数据集划分结果工作，目的是避免被错分的样本在单一网络中形成“偏差确认”。该论文收录于ICLR2020，作者Junnan Li，工作单位salesforce。
论文地址：https://arxiv.org/abs/2002.07394
开源代码：https://github.com/LiJunnan1992/DivideMix
一、主要原理 主要原理如上图，同时训练两个同结构但不同参数的网络A和B。
第一步，在每epoch，使用混合高斯模型GMM对每个样本的损失值进行分类。这是因为神经网络对于干净标签和噪声标签会表现出不同的损失值，噪声标签的损失值更大，因此对损失值划定一个阈值即可区分干净标签和噪声标签，但是这个阈值并不能事前确定，需要使用某种聚类算法实现自动的分类，作者认为干净标签和噪声标签的损失值都应是服从各自不同的高斯分布，所以使用含2个组分的高斯混合模型即可分开。
这里复习一下GMM。GMM是一种聚类算法，用来对含有多个高斯分布的数据进行分类，一般使用期望最大（EM）算法来拟合其中每个高斯分布的参数，然后得到分类阈值进行分类。比如，男生的身高和女生的身高都分别服从一个高斯分布，通过计算后可以得到一个阈值1.6米，可以认为1.6米以下的都是女生，1.6米以上的都是男生。可见对于均值比较接近的高斯分布，GMM分类效果并不好。
为了更好的进行GMM分类，文中使用了一些tricks，如figure2所示，进行一定的预热，就是先训练10个epoch左右，加入了一个罚函数（使用负熵函数），可以发现干净标签和噪声标签的损失差别更明显一些；再经过DivideMix的多轮循环，这个差别会更加明显。
第二步，在每mini-batch，使用改进的MixMatch法训练，即两个网络的输出结果混合后再分别输入给两个网络继续训练。
二、优缺点分析 1.优点 根据作者的试验数据，本方法效果很好，比之前的方法有很大提升，噪声50%时比无噪声时精度没有太多下降，噪声80%时仍有相当高的精度。
2.缺点 根据我的试验，本方法对于噪声含量10%以下的低噪声情况效果反而下降很厉害。这是因为对于低噪声含量情况，两个类别的损失分布混在了一起，GMM无法有效识别出噪声样本，所以会把很多干净样本划分为噪声样本。也许调整一下GMM的参数会好一些，我没有进一步试验。
总结 我学习噪声标签问题的主要目的是基于之前做很多数据竞赛题时发现了不少人工标注错误问题，希望能够找到解决这些问题的好方法，然而看了好几篇论文之后并没有找到直接好用的方法，顶多是论文中的思想可供借鉴一下。本文算是标签噪声领域目前效果最好的，但是本文仅在噪声较高情况下才有用，对于噪声含量不超过20%的情况并不适用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e04bab2729e5e9a054f2b87738a1426/" rel="bookmark">
			vue全局配置scss，在vue文件使用scss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面是对scss文件的配置
1.安装sass-resources-loader npm i sass-resources-loader --save-dev
2.修改build文件夹下utils.js，下面的options路径就是你要配置的scss文件的绝对路径 // https://vue-loader.vuejs.org/en/configurations/extract-css.html return { css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders('less'), sass: generateLoaders('sass', { indentedSyntax: true }), // 配置全局的scss文件 要添加的地方 scss: generateLoaders('sass').concat({ loader: 'sass-resources-loader', options: { resources: path.resolve(__dirname, './../src/assets/css/base.scss') } }), stylus: generateLoaders('stylus'), styl: generateLoaders('stylus') } 在app.vue中引入base.scss &lt;style lang="scss"&gt; @import url(assets/css/base.scss); #app { width: 100vw; height: 100vh; } &lt;/style&gt; 在vue文件中使用scss
安装node-sass，sass-loader注意安装版本，与node.js版本有关 sass-loader我的是7.3.1版本 node-sass版本为4.14.1 而我的nodejs版本为12多
在build文件夹下修改webpack.base.conf,在module的rules添加下面的配置即可 { test: /\.sass$/, loaders: ['style', 'css', 'sass'] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28edb1925db32e695bc6fca03e37f59c/" rel="bookmark">
			SpringBoot整合Mybatis Generator逆向工程 并使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在pom.xml中引入依赖 &lt;!-- mybatis逆向工程jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.4&lt;/version&gt; &lt;/dependency&gt; 2、创建配置文件 在resources中创建一个名为generator的文件夹在文件夹中创建一个文件名为generatorConfig.xml的配置文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包,我是mac电脑，和windows的地址不一样--&gt; &lt;classPathEntry location="/Users/xiaxinao/Desktop/毕设/repository/mysql-connector-java-8.0.22.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!-- JavaBean 实现 序列化 接口 --&gt; &lt;plugin type="org.mybatis.generator.plugins.SerializablePlugin" /&gt; &lt;!-- 生成toString --&gt; &lt;plugin type="org.mybatis.generator.plugins.ToStringPlugin" /&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- &lt;property name="suppressAllComments" value="true"/&gt;--&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1:3306/a_ln" userId="root" password="123456"&gt; &lt;property name="nullCatalogMeansCurrent" value="true"/&gt; &lt;/jdbcConnection&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28edb1925db32e695bc6fca03e37f59c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85100479a183bbb5872461710d6db48f/" rel="bookmark">
			ssim 算法 java实现,在Java中实现SIFT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		So I'm working on a simple Java app that allows a user to input an image as a query and have the app compare it against a database of images (which is basically no more than a directory of different images). I'm basically investigating several image similarity measurement techniques to find out which ones are appropriate for comparing pictures of cars.
I've been doing some reading and apart from FFT/SSIM, I've read that the SIFT algorithm can yield very good results.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85100479a183bbb5872461710d6db48f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f646dbc3cc2880e58b07205afe2a280/" rel="bookmark">
			java重定向设置header_在Java中重定向请求时如何传递HTTP头中的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以在HTTP头中传递一些数据，同时将请求从一个服务器重定向到另一个服务器。
这是我的场景，
我有一个通用过滤器，每个请求都通过它。
现在，根据一些条件，我使用API​​ objHttpServletResponse.sendRedirect(strURL)将请求重定向到一些不同的服务器。
但是，问题是，当我在响应头设置一些数据，如objHttpServletResponse.setHeader(“Key”，“Value”);这在重定向服务器中不可用。
所以，我的问题是，
1.在重定向请求时，是否有办法在头文件中传递一些数据？
2.如果没有，在重定向请求时发送一​​些数据的其他可能方法是什么？
请注意：其他几种方式，比如
使用网址参数：
objHttpServletResponse.sendRedirect(strURL“？param =”strParamValue);
要么
使用会话：
HttpSession session = httpRequest.getSession();
session.setAttribute(“Key”，“Value”);
不是我期待的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16ebc0e996db9bf0907c29bd20e9ba3/" rel="bookmark">
			java mail cc,在使用java发送邮件时，在地址中添加cc和bcc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I am sending the email using the java . I want to send the mail as bcc and cc options also in the address how is it possible. I am using the following code.
public String sendemail(String xtomail,String xsub,String xbody)
{
final String username ="adeshsingh86@gmail.com";
final String password ="passwordhere";
Properties props = new Properties();
props.put("mail.smtp.auth", "true");
props.put("mail.smtp.starttls.enable", "true");
props.put("mail.smtp.host", "smtp.gmail.com");
props.put("mail.smtp.port", "587");
Session session = Session.getInstance(props,
new javax.mail.Authenticator() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16ebc0e996db9bf0907c29bd20e9ba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e0d09007f3631377916ef26cd65a27f/" rel="bookmark">
			git报错git@gitlab.com: Permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新PC安装git和Android studio以后尝试拉取代码自己分支的代码会出现下面的错误
23:43	Update failed Warning: Permanently added 'gitlab.com,172.65.251.78' (ECDSA) to the list of known hosts. git@gitlab.com: Permission denied (publickey,keyboard-interactive). Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 出现的原因是SSH key没有配置好：
1.首先输入下面的命令
1)ssh-keygen -t rsa -C "12345@outlook.com" 2)输入回车 3)输入回车 会出现下面的命令：
2.查看.ssh目录下面生成的id_rsa.pub文件
3.去C:/用户目录/.ssh下将公钥添加到gitlab的网站中，即id_rsa.pub文件的内容
4.直接将id_rsa.pub中的内容复制到key中。（title不需要手动填写，如果正确复制的key，titie会自动填上，如果没填上很可能需要手动去掉转行符）
再输入git pull的时候可以拉取到最新的代码了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86aeb05b883947471353ff945001d7e2/" rel="bookmark">
			力扣561. 数组拆分 I-C语言实现-简单题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 传送门
给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。
返回该 最大总和 。
示例 1：
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
(1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3(1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3(1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86aeb05b883947471353ff945001d7e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c7430be92baad8caf5d8c658146d7c/" rel="bookmark">
			java jpa 注解,Java  -  JPA  -  @Version注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		How does @Version annotation work in JPA?
I found various answers whose extract is as follows:
JPA uses a version field in your entities to detect concurrent modifications to the same datastore record. When the JPA runtime detects an attempt to concurrently modify the same record, it throws an exception to the transaction attempting to commit last.
But I am still not sure how it works.
Also as from the following lines:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c7430be92baad8caf5d8c658146d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ffd868b0d98c17c0e1c98800de15141/" rel="bookmark">
			Uncaught (in promise) Error: Request failed with status code 500
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一些状态码400 404 500等原因:
出错:
前端:
// 获取所有的导航菜单 async getMenuList(){ const {data:res} = await this.$http.get("menus"); console.log(res.data); if( res.status != 200) return this.$message.error("操作失败！！！"); this.menuList = res.data; }, 后端：
@RestController public class MenuController { @Autowired MenuDao menuDao; @CrossOrigin @RequestMapping("/menus") public String getAllMenus(){ System.out.println("sucess"); HashMap&lt;String, Object&gt; data = new HashMap&lt;&gt;(); List&lt;MainMenu&gt; mainMenus = menuDao.getMainMenus(); data.put("data",mainMenus); data.put("status",200); String data_json = JSON.toJSONString(data); System.out.println("成功访问！！！"); return data_json; } } xml文件:
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ffd868b0d98c17c0e1c98800de15141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0566987024ca399313bf0d1ee0e1b135/" rel="bookmark">
			基于单目彩色视频的人体实时捕捉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引自视频号【三维匠心】
论文《LiveCap: Real-time Human Performance Capture from Monocular Video》 这是德国马普所和斯坦福大学联合发表的关于实时人体捕捉系统的工作。该工作可以仅通过输入一段单视角RGB视频，重建出稠密，时空一致性的，并且穿着日常衣服的整个人体的发生形变后的几何表面。
该工作提出了一种新颖的两阶段综合分析优化方法——
第一阶段，将蒙皮模板模型与去除背景的输入视频，通过神经网络回归的2D和3D骨架关节点以及一组稀疏的面部关键点检测进行联合拟合。
第二阶段，基于新颖的实时捕捉算法（使用稠密光度和轮廓约束进行非刚性形变追踪），重建了皮肤甚至宽松服装的稠密非刚性三维形变。该系统采用CPU和两个商用GPU设计了流水线并行架构，可以获得每秒25帧的实时性能，并且其重建精度和离线方法相当的情况下，其速度快了好几个两级。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee99235785fb513f4e17a0152d36e37/" rel="bookmark">
			RHEL7.9安装网易云音乐（netease-cloud-music_1.2.1_amd64_ubuntu_20190428.deb）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RHEL7.9安装网易云音乐（netease-cloud-music_1.2.1_amd64_ubuntu_20190428.deb） 系统安装的glibc版本为glibc-2.17-323.el7_9.x86_64
使用命令查看GLIBC_
[rhel@master lib64]$ sudo strings libstdc++.so.6 | grep GLIBC GLIBCXX_3.4 GLIBCXX_3.4.1 GLIBCXX_3.4.2 GLIBCXX_3.4.3 GLIBCXX_3.4.4 GLIBCXX_3.4.5 GLIBCXX_3.4.6 GLIBCXX_3.4.7 GLIBCXX_3.4.8 GLIBCXX_3.4.9 GLIBCXX_3.4.10 GLIBCXX_3.4.11 GLIBCXX_3.4.12 GLIBCXX_3.4.13 GLIBCXX_3.4.14 GLIBCXX_3.4.15 GLIBCXX_3.4.16 GLIBCXX_3.4.17 GLIBCXX_3.4.18 GLIBCXX_3.4.19 GLIBCXX_3.4.20 GLIBCXX_3.4.21 GLIBCXX_3.4.22 GLIBCXX_3.4.23 GLIBCXX_3.4.24 GLIBCXX_3.4.25 GLIBC_2.2.5 GLIBC_2.3 GLIBC_2.14 GLIBC_2.18 GLIBC_2.16 GLIBC_2.3.2 GLIBCXX_DEBUG_MESSAGE_LENGTH GCC: (MW GCC 8.3.0-GLIBC2.17-gold) 8.3.0 貌似版本低了不足以支持网易云音乐
先试试看
下载netease-cloud-music_1.2.1_amd64_ubuntu_20190428.deb
使用ar -vx解包，得到如下三个压缩文件：
control.tar.xz data.tar.xz debian-binary
继续把data.tar.xz解压缩，得到了opt/ usr/两个文件夹，把这两个文件夹用cp递归拷贝的方式，复制到系统相应的文件夹中。
cd /opt/ sudo cp -r * /opt/ cd /usr/ sudo cp -r * /usr/ 这样我们就已经可以在当前用户下用命令行方式来启动网易云音乐了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ee99235785fb513f4e17a0152d36e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62145821d4ccdc98f47abb5b7b80b274/" rel="bookmark">
			xpcom java_[Mozilla] JavaXPCOM 的jar 包概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mozilla 的官方网站上发现，在xulrunner 2.0 以后，将不会对javaxpcom 进行支持。(目前，mozilla 正在寻找个人来支持javaxpcom)。
在SWT 中的browser 中，可以使用mozilla 浏览器，而且可以通过mozilla 得到javaxpcom 的对象，来进一步操作浏览器。
在SWT 中的Mozilla 类中：
public Object getWebBrowser () {
if ((browser.getStyle () &amp; SWT.MOZILLA) == 0) return null;
if (webBrowserObject != null) return webBrowserObject;
try {
Class clazz = Class.forName ("org.mozilla.xpcom.Mozilla"); //$NON-NLS-1$
Method method = clazz.getMethod ("getInstance", new Class[0]); //$NON-NLS-1$
Object mozilla = method.invoke (null, new Object[0]);
method = clazz.getMethod ("wrapXPCOMObject", new Class[] {Long.TYPE, String.class}); //$NON-NLS-1$
webBrowserObject = method.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62145821d4ccdc98f47abb5b7b80b274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e9ed9bd61609d21c8022d78e473034/" rel="bookmark">
			java 查看 工程 版本_springboot项目中如何查看springBoot版本和Spring的版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：通过代码进行查看
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.SpringBootVersion;
import org.springframework.core.SpringVersion;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.class)
public class SpringVersionTest {
@Test
public void getSpringVersion() {
String version = SpringVersion.getVersion();
String version1 = SpringBootVersion.getVersion();
System.out.println(version);
System.out.println(version1);
}
}
方法二，在pom.xml里进行查看
org.springframework.boot
spring-boot-starter-parent
2.0.3.RELEASE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39a46dfbc190c5cf5b9d602b70fbfa2/" rel="bookmark">
			java set获取元素_Set如何获取第一个元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
public class TestSet {
public static void main(String[] args) {
Set set = new HashSet();
set.add("我是第一个");
set.add("我是第二个");
System.out.println(set);
if(!set.isEmpty()){
System.out.println(set.iterator().next());//迭代取第一个
System.out.println(set.toArray()[0]);//变为数组取第一个
}
List list=new ArrayList(set);
System.out.println(list.get(0));//变为list取第一个
}
}
运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7338fda23e6bee6017a5a6cba15ce1df/" rel="bookmark">
			java 二进制 base64编码_java自定义实现base64编码转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.base64编码转换
所谓base64编码，即按照规则把字符转化为"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"这个字符集中的字符。具体规则如下：
a.把每3个字节为一组，共24bit。每6bit一小组，每组前面加00,变为32bit。这样3个字节被扩展成了4个节，按照上面字符集编码。
b.如果字节数不足3:
1)当字节数为2时，共16bit。每6bit一小组，最后一组即只有4bit，则不止前面加00以外,后面也要补00,按照上面字符集编码，末尾补=。
2)当字节数为1时,共8bit。每6bit一小组，最后一组即只有2bit，则不止前面加00以外，后面也要补0000,按照上面字符集编码,末尾补==.。
2.计算机如何表示负数。(以byte基本类型为例)
在java中一个byte为一个字节共8bit，可表示范围00000000——11111111(0～255)。在计算机中把0——01111111表示为0～127,把10000000——11111111表示为-128 ～-1。那么这样如-127+127,即01111111+10000001=100000000，相加等于模(256)，即互为补码。
3.java位运算。
在java中(加，减，乘，除，右移，左移，无符号右移，位与，位或，位异或)操作，均会是首先将byte,short,char转化为int，再进行相应运算。举例：
public class Test {
public static void main(String[] args) {
byte s1 = (byte) 0xFF;// -1
byte s2 = (byte) 0x80;// -128
System.out.println((byte)(s1+s2));//s1+s2=-129,强制转化为byte，此时溢出，java处理溢出(+-)256*n,256为byte类型的模，则结果为-129+256=127;
byte s5 = -28;
System.out.println(s5 &lt;&lt; 2);// 结果为-112, 先转换为int类型，右边补0,高位舍弃
System.out.println(s5&gt;&gt;2);//结果为-7,先转换为int类型，高位补符号位，低位舍弃
System.out.println(s5&gt;&gt;&gt;2);//结果为1073741817,先转换为int类型，高位补0,低位舍弃
System.out.println((s5&amp;0xFC)&gt;&gt;2);
}
}
4.java实现base64编码方式
/**
* @author zyw 2017年2月21日
*/
package test;
import java.io.UnsupportedEncodingException;
/**
* 1.补码 2.位运算 3.base64
*
* @description 学习base64加密 第一步，将每三个字节作为一组，一共是24个二进制位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7338fda23e6bee6017a5a6cba15ce1df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d82c5632feb534f8afec00e38e32f3/" rel="bookmark">
			java jar 是什么文件_什么是.jar文件？如何打开jar文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以对JAR文件内容加上数字化签名。这样，能够识别签名的工具就可以有选择地为您授予软件安全特权，这是其他文件做不到的，它还可以检测代码是否被篡改过。那么jar文件如何打开？下面，小编就来跟大家分享打开jar文件的步骤了。
什么是.jar文件？jar文件是Java项目生成的一个小的文件项目，也可以描述为一个Java压缩包，里面封装了，许多Java类以及方法，变量。通过Java我们该如何打开Jar文件呢？下面，小编为大伙细诉打开jar文件的操作流程了。
如何打开jar文件
1、在安装好java环境条件下，按下Windows+R键，在弹出的运行框中输入CMD(不区分大小写)。若没有安装java环境，以下链接为详细讲解了如何安装java环境和如何配置java环境，可以安装步骤安装。
jar电脑图解-1
2、先在弹出的黑框框中切换到.jar文件的所在目录，在下.jar的文件目录为：F:install,所以切换到F:install。
jar文件电脑图解-2
3、在黑框框中输入java -jar ****.jar，****表示要运行的.jar文件名
jar电脑图解-3
4、敲回车键后，.jar文件就开始成功运行了。
打开jar电脑图解-4
以上就是打开jar文件的操作步骤了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4ce62c8e491348ca0ff0c524fb7a76/" rel="bookmark">
			java 按钮跳转页面_java按钮实现页面跳转 | 学步园
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如有两个frame,分别为frame1,frame2,frame1加个按钮实现跳转.frame1代码如下
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;
public class frame1 extends JFrame implements ActionListener{
/**
* @param args
*/
private JButton jb;
public frame1()
{
this.setSize(300, 200);
this.setLocation(300, 400);
jb=new JButton("跳转");
this.add(jb);
jb.addActionListener(this);//加入事件监听
this.setVisible(true);
}
public static void main(String[] args) {
// TODO Auto-generated method stub
frame1 frame=new frame1();
}
@Override
public void actionPerformed(ActionEvent e) {
// TODO Auto-generated method stub
if(e.getSource()==jb)
{
this.dispose();//点击按钮时frame1销毁,new一个frame2
new frame2();
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca4ce62c8e491348ca0ff0c524fb7a76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db478ea708efe4d463c10848ba5a3c34/" rel="bookmark">
			java 动画 制作_利用Java制作字符动画实例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
今晚闲来无事，整理了一下电脑中尘封已久的旧代码，看着那些年自己写过的代码，踩过的坑，顿时老泪纵横。正当在感叹之际，突然发现在“马克思”文件夹下出现了一个好玩的项目，那就是N年前刚学Java时写的GIF转字符动画的小玩具，虽然是个小玩意，但是在当时能搞点东西出来还是非常有成就感的。
正文
效果展示
原图，某两年半练习生
转成字符动画后的练习生
实现原理
其实字符动画的实现原理比较简单，这里我们抛开GIF，直接拿一张静态图片来说明。
首先我们要把原图转成灰度图，这样图片中每个像素就只存在亮度信息0-255。
取颜色的RGB均值灰度后
接着我们可以定义需要使用的字符，每个字符对应一段亮度范围，比如 图中的M,@,;等字符，接着我们就可以去遍历替换图片中的所有像素，慢慢的调试每个字符对应像素的亮度范围，调试到输出的图像轮毂清晰即可，这样单张图片的字符画就已经成型了。下面关键代码注释。
BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));
int width = bi.getWidth();//原图宽度
int height = bi.getHeight();//原图高度
int minx = bi.getMinX();//BufferedImage 原图 最小X坐标
int miny = bi.getMinY(); //BufferedImage 原图 最小Y坐标
for (int i = miny; i &lt; height; i += 8) {//遍历图片中的像素点，用字符判断像素范围来替换
for (int j = minx; j &lt; width; j += 8) {
int pixel = bi.getRGB(j, i); // 下面三行代码将一个数字转换为RGB数字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db478ea708efe4d463c10848ba5a3c34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935fafec05108369e30b3193e38acd67/" rel="bookmark">
			java自带工具_Java常用自带工具介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jps
jinfo
jmap
jstack
JConsole
Visual VM
一、jps
jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。
jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path。
基本使用方式：
不过，jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。
参数使用
-q
只显示pid，不显示class名称,jar文件名和传递给main方法的参数
-m
输出传递给main方法的参数，在嵌入式jvm上可能是null
-l
输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名
-v
输出传递给JVM的参数
二、jinfo
jinfo可以输出并修改运行时的java进程的JVM参数。用处比较简单，用于输出JAVA系统参数及命令行参数。用法是jinfo -opt pid
另外，jinfo可能在未来的jvm中移除
-flag name
-flag 打印该Java进程的指定的JVM参数的值
如：查看13092的MaxPerm大小可以用
-flag [+|-]name
-flag[+|-] 控制生效或不生效某些JVM参数
如生效PrintGCDetails参数
-flag name=value
-flag= 设定名为name的参数为指定值
如果出现下面这样的情况，说明参数不支持修改
-flags
查看进程的所有JVM参数
三、jmap
打印出某个Java进程(使用pid)内存内的，所有‘对象’的情况(如：产生那些对象，及其数量)。
使用方法：
jmap [ option ] pid
jmap [ option ] executable core
jmap [ option ] [server-id@]remote-hostname-or-IP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935fafec05108369e30b3193e38acd67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26210fdd7d2e83817a93b2cc01de9bf3/" rel="bookmark">
			java broken pipe_java Broken pipe 几种原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Broken pipe产生的原因通常是当管道读端没有在读，而管道的写端继续有线程在写，就会造成管道中断。(由于管道是单向通信的) SIGSEGV(Segment fault)意味着指针所对应的地址是无效地址，没有物理内存对应该地址。 以下是UNIX的信号解释： 11 / SIGSEGV: Unerlaubter Zugriff auf Hauptspeicher (Adressfehler). 12 / SIGUSER2: User-defined Signal 2 (POSIX). 把_JAVA_SR_SIGNUM改成12只是将信号至成user-defined，让它不报出来而已，不能解决问题。 建议采取的方式：
1． 资源没有完全释放，用完后要至NULL 值(JAVA的GC没那么完善)
2． 数据库连接顺序关闭！(RS，PS，CONN)
3． 优化JAVA虚拟机 加入相应的内存参数！
4． 不要在数据库中获取大段文本(即一个栏位的值不要太大)
5． JAVA 不推荐 用String 获取大量信息。(容易造成内存泄露，建议用StringBuffer)
6． 页面重复提交
7． 尽量将METHOD移到JAVA中，在JSP中所有的方法都看做全局变量，编译执行本身就有很多问题。
8． 如果是查询功能，尽可能的使用非XA(事务)。
9． 尽量用较新较稳定版本的JDK，低版本的JVM本身也有很多BUG，比如1。5的垃圾回收比起1。2，1。3一定是非常明显的进步。
10． LINUX系统本身没有这么稳定，有些问题无法避免的~~：)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7de7c5ebfc171abb556fb462d262b8/" rel="bookmark">
			解一元二次方程lisp_只有lisp能做——欧拉计划第66题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅以此文膜拜八年前的自己
序言
欧拉计划(Project Euler)就像LeetCode，是一个编程答题的网站。不同于LeetCode的是，欧拉计划只要求用户提交最终答案即可(一般是一个数字)，而不需要完整代码。因此，可以尽情地使用自己喜欢的编程语言——不少题目甚至光靠笔和纸便能解决。
欧拉计划的第66题非常有意思，它的题目很简单，就是要求找出在不大于1000的整数中，以哪一个数字为丢番图方程的系数，可以得到所有最小解中的最大值。
可以很容易地看出方程有一个直观的暴力算法：让y从1开始递增，对于每一个y，计算公式Dy^2+1的值。如果该值为平方数，那么它的平方根就是最小的x解。再依照这个算法求解所有D不大于1000的方程，便可以求出题目的答案。很容易用Python写出这个算法# -*- coding: utf8 -*-
import math
def is_square(num: int) -&gt; bool:
return math.isqrt(num) ** 2 == num
def find_x(D: int) -&gt; int:
"""
求出给定D时，满足题目所给的丢番图方程的最小的x。
"""
assert not is_square(D)
y = 1
while True:
candidate = D * y * y + 1
if is_square(candidate):
return math.isqrt(candidate)
y += 1
def solve_66(limit):
"""
找出不大于limi的D中，使find_x的返回值最大的那一个数字。
"""
max_D = None
max_x = None
D = 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7de7c5ebfc171abb556fb462d262b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774e7a932bcf581e01af15101c51cdf5/" rel="bookmark">
			java system in_JAVA中的System.in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		System.in读取标准输入设备数据(从标准输入获取数据，一般是键盘)，其数据类型为InputStream。方法：
int read() // 返回输入数值的ASCII码，，该值为0到 255范围内的int字节值。若返回值为-1，说明没有读取到任何字节读取工作结束。
int read(byte[] b) // 读入多个字节到缓冲区b中，返回值是读入的字节数
1 packageInPackage;2
3 /**
4 * System.in.read()返回值为输入数值的ASCII码，该值为0到 255范围内的int字节值5 * 如果因为已经到达流末尾而没有可用的字节，则返回值 -1。6 */
7 public classIntest1 {8 public static void main(String args[]) throwsjava.io.IOException9 {10 int a=0;11 System.out.println("请输入a：");12 a=System.in.read();13 System.out.println("a="+a);14 System.out.println("(char)a="+(char)a);15 }16 /**
17 * 假设我们输入a为118 * 输出结果为：19 * 请输入a：20 * 121 * a=4922 * (char)a=123 */
24
有一个有意思的问题是：当我们输入一个字符，System.in.read()会读取几个字符呢？
1 packageInPackage;2
3 importjava.util.Arrays;4
5 /**
6 * 当我们输入一个字符，System.in.read()会读取几个字符7 * 我们从运行结果可以看出是三个8 * 假设我们输入一个字符，那么它会接着读取该字符后面的/r和/n9 */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/774e7a932bcf581e01af15101c51cdf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d8750682ad266aa5fa68865691076f/" rel="bookmark">
			opc java_Java实现OPC通信---utgard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		importjava.util.concurrent.Executors;importjava.util.concurrent.ScheduledExecutorService;importjava.util.concurrent.TimeUnit;importorg.jinterop.dcom.common.JIException;importorg.jinterop.dcom.core.JIVariant;importorg.openscada.opc.lib.common.ConnectionInformation;importorg.openscada.opc.lib.da.AccessBase;importorg.openscada.opc.lib.da.DataCallback;importorg.openscada.opc.lib.da.Group;importorg.openscada.opc.lib.da.Item;importorg.openscada.opc.lib.da.ItemState;importorg.openscada.opc.lib.da.Server;importorg.openscada.opc.lib.da.SyncAccess;public classUtgardTutorial2 {public static void main(String[] args) throwsException {//连接信息
final ConnectionInformation ci = newConnectionInformation();
ci.setHost("192.168.0.1"); //电脑IP
ci.setDomain(""); //域，为空就行
ci.setUser("OPCUser"); //用户名，配置DCOM时配置的
ci.setPassword("123456"); //密码//使用MatrikonOPC Server的配置//ci.setClsid("F8582CF2-88FB-11D0-B850-00C0F0104305");//MatrikonOPC的注册表ID，可以在“组件服务”里看到//final String itemId = "u.u";//项的名字按实际//使用KEPServer的配置
ci.setClsid("7BC0CC8E-482C-47CA-ABDC-0FE7F9C6E729"); //KEPServer的注册表ID，可以在“组件服务”里看到
final String itemId = "u.u.u"; //项的名字按实际，没有实际PLC，用的模拟器：simulator//final String itemId = "通道 1.设备 1.标记 1";//create a new server，启动服务
final Server server = newServer(ci, Executors.newSingleThreadScheduledExecutor());try{//connect to server，连接到服务
server.connect();//add sync access, poll every 500 ms，启动一个同步的access用来读取地址上的值，线程池每500ms读值一次//这个是用来循环读值的，只读一次值不用这样
final AccessBase access = new SyncAccess(server, 500);//这是个回调函数，就是读到值后执行再执行下面的代码，是用匿名类写的，当然也可以写到外面去
access.addItem(itemId, newDataCallback() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01d8750682ad266aa5fa68865691076f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb247342e1a1dbba71310610e8b1e783/" rel="bookmark">
			java考试系统_Java在线考试系统（含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文demo下载和视频教学观看地址：http://www.wisdomdd.cn/Wisdom/resource/articleDetail.htm?resourceId=1076
本实例介绍了在线考试系统, 前台使用bootstrap技术，后台使用structs和herbinate, 数据库为mysql, 系统分为老师和学生二个角色，老师可以管理学生和试题，学生可以在线进行答题并且实时获得分数
项目对应的实例代码可以通过右侧【下载实例】按钮获取
开发工具: MyEclipse10, JDK1.7, Tomcat7, MySql5.5.60
【项目包含内容】(见下图):
【examOnline】 项目源代码
【exam.sql】 数据库脚本
【实例功能】
1. 登录页面登录功能, 输入用户名与密码, 选择角色, 滑动箭头拉到最右边才可以点击登录
2. 学生角色登录成功后，可以看到需要答题的试卷，有规定的答题时间(倒计时)
题目选择完毕后，【提交答卷】可以立即看到分数, 然后查看试卷答案
3. 老师角色登录成功后, 可以添加学生, 查询所有学生, 添加试题, 查询所有试题
【实例效果图】
访问登录页面: http://localhost:8080/examOnline/
学生角色
老师角色
【实例配置】
1. 修改数据库配置信息(您本地的用户名与密码)
2. 老师角色登录后添加学生时，学生的密码被设置为固定值"123456", 学生角色登录时，使用"123456"为登录密码
3. 数据库表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39ca65faee7b7609161658f606f7b67/" rel="bookmark">
			python的empty函数_python中numpy.empty()函数实例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用python编程的过程中，想要快速的创建ndarray数组，可以使用numpy.empty()函数。numpy.empty()函数所创建的数组内所有元素均为空，没有实际意义，所以它也是创建数组最快的方法。本文介绍python中numpy.empty()函数的使用方法。
1、numpy.empty()函数
这个函数可以创建一个没有任何具体值的ndarray数组，是创建数组最快的方法。
根据给定的维度和数值类型返回一个新的数组，其元素不进行初始化。
2、用法
import numpy as np
np.empty(shape, dtype=float, order='C')
3、参数
shape：返回空数组的维度
dtype：指定输出数组的数值类型
order：是否在内存中以C或fortran(行或列)顺序存储多维数据
4、返回值
返回给定形状和类型的新数组。
5、使用实例
&gt;&gt;&gt; np.empty([2, 2])
array([[ -9.74499359e+001, 6.69583040e-309],
[ 2.13182611e-314, 3.06959433e-309]]) #uninitialized&gt;&gt;&gt; np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
[ 496041986, 19249760]]) #uninitialized
记录numpy.empty()函数引发的问题解决方法
其实使用在使用np.empty()创建list，可以指定类型，如
print(np.empty(3,3,dtype=int))
[[4128860 6029375 3801156]
[4391004 6553711 7536741]
[5242972 7602297 7274600]]
到此这篇关于python中numpy.empty()函数实例讲解的文章就介绍到这了,更多相关python中numpy.empty()函数的用法内容请搜索WEB开发者以前的文章或继续浏览下面的相关文章希望大家以后多多支持WEB开发者！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3019d985d7a882dcbdc78a3b05dbb33/" rel="bookmark">
			python读取文件并分析单词词频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python小作业-读取txt文件并分析单词的词频 python的基本语法。这是三天学习下来最后总结的小作业。
作业内容是分析储存在一个txt文件里的英语四级卷子，分析单词的词频。
整体思路：先读取文件，再清洗数据，去除所有无关数字，符号。然后把数据变成不重复数据，最后在原文统计单词个数。
import re #引入正则库，用来处理数据为统一格式 def get_artical(artical_path): #读取文件，read函数打开整个文件为字符串 with open(artical_path) as fr: data = fr.read() return data data=get_artical(r'C:\Users\Administrator\PycharmProjects\作业\artical.txt') data=re.sub(r'[\n.,!?\'\";/)(-]', ' ', data) #利用正则的sub一次替换多个目标为空格，方便后续统一处理 data=re.sub(r'[0-9]', ' ', data) #处理阿拉伯数字 data=data.lower() #把全部文本处理为小写 key_words=re.split(' ',data) #用re的split分割字符串为列表，利用空格为标记分开 lable=set(key_words) #把列表强制转换为集合，一次性去重，作为标签在后面使用 lable.remove('') #去除标签里的空格，空格又不查找QAQ dict={} #新建一个字典，记录单词和单词频率 for item in lable: #遍历所有标签 dict[item] = key_words.count(item) #每个标签在原文里用count函数计数 print(dict) 整体思路和代码其实很简单，注意细节即可
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/191/">«</a>
	<span class="pagination__item pagination__item--current">192/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/193/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>