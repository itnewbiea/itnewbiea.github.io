<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6425699cb7f14b372a438744285aa22/" rel="bookmark">
			# Oracle 库常见问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle 库常见问题排查 文章目录 Oracle 库常见问题排查查询数据库的相关信息查看正在执行的语句杀掉正在执行的sql查看未提交的事务查看锁表 查询数据库的相关信息 查看正在执行的语句 SELECT s.sid, s.serial#, s.username, s.status, s.sql_id, s.sql_child_number, sq.sql_text FROM v$session s JOIN v$sql sq ON s.sql_id = sq.sql_id WHERE s.status = 'ACTIVE'; 杀掉正在执行的sql -- sid,serial# alter system kill session '7114,14991' 查看未提交的事务 --SQL 语句 1：查询未提交事务 DML 语句 SELECT S.SID ,S.SERIAL# ,S.USERNAME ,S.OSUSER ,S.PROGRAM ,S.EVENT ,TO_CHAR(S.LOGON_TIME,'YYYY-MM-DD HH24:MI:SS') ,TO_CHAR(T.START_DATE,'YYYY-MM-DD HH24:MI:SS') ,S.LAST_CALL_ET ,S.BLOCKING_SESSION ,S.STATUS ,( SELECT Q.SQL_TEXT FROM V$SQL Q WHERE Q.LAST_ACTIVE_TIME=T.START_DATE AND ROWNUM&lt;=1) AS SQL_TEXT FROM V$SESSION S, V$TRANSACTION T WHERE S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6425699cb7f14b372a438744285aa22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6837dc62ebc1541724955519da11c98/" rel="bookmark">
			python3详细安装教程_python3安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 一、下载python—python官网Welcome to Python.org
二、安装python
1.双击打开python的安装程序
2.选择Add Python ---- to PATH（配置PATH环境，如果没有选择则需要手动配置环境）===&gt;选择自定义安装
3.默认点击Next
4.选择安装的路径，点击Next
5.点击Close
三、验证安装是否成功
1.进入命令提示符（可以win+R 输入cmd回车进入）
2.输入python回车出现以下信息表示安装成功。（如果一开始没有选择配置环境变量，需要去配置环境变量）
-END-
一、Python入门 下面这些内容是Python各个应用方向都必备的基础知识，想做爬虫、数据分析或者人工智能，都得先学会他们。任何高大上的东西，都是建立在原始的基础之上。打好基础，未来的路会走得更稳重。所有资料文末免费领取！！！
包含：
计算机基础
python基础
Python入门视频600集：
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
二、Python爬虫 爬虫作为一个热门的方向，不管是在自己兼职还是当成辅助技能提高工作效率，都是很不错的选择。
通过爬虫技术可以将相关的内容收集起来，分析删选后得到我们真正需要的信息。
这个信息收集分析整合的工作，可应用的范畴非常的广泛，无论是生活服务、出行旅行、金融投资、各类制造业的产品市场需求等等，都能够借助爬虫技术获取更精准有效的信息加以利用。
Python爬虫视频资料
三、数据分析 清华大学经管学院发布的《中国经济的数字化转型：人才与就业》报告显示，2025年，数据分析人才缺口预计将达230万。
这么大的人才缺口，数据分析俨然是一片广阔的蓝海！起薪10K真的是家常便饭。
四、数据库与ETL数仓 企业需要定期将冷数据从业务数据库中转移出来存储到一个专门存放历史数据的仓库里面，各部门可以根据自身业务特性对外提供统一的数据服务，这个仓库就是数据仓库。
传统的数据仓库集成处理架构是ETL，利用ETL平台的能力，E=从源数据库抽取数据，L=将数据清洗（不符合规则的数据）、转化（对表按照业务需求进行不同维度、不同颗粒度、不同业务规则计算进行统计），T=将加工好的表以增量、全量、不同时间加载到数据仓库。
五、机器学习 机器学习就是对计算机一部分数据进行学习，然后对另外一些数据进行预测与判断。
机器学习的核心是“使用算法解析数据，从中学习，然后对新数据做出决定或预测”。也就是说计算机利用以获取的数据得出某一模型，然后利用此模型进行预测的一种方法，这个过程跟人的学习过程有些类似，比如人获取一定的经验，可以对新问题进行预测。
机器学习资料：
六、Python高级进阶 从基础的语法内容，到非常多深入的进阶知识点，了解编程语言设计，学完这里基本就了解了python入门到进阶的所有的知识点。
到这就基本就可以达到企业的用人要求了，如果大家还不知道去去哪找面试资料和简历模板，我这里也为大家整理了一份，真的可以说是保姆及的系统学习路线了。
但学习编程并不是一蹴而就，而是需要长期的坚持和训练。整理这份学习路线，是希望和大家共同进步，我自己也能去回顾一些技术点。不管是编程新手，还是需要进阶的有一定经验的程序员，我相信都可以从中有所收获。
一蹴而就，而是需要长期的坚持和训练。整理这份学习路线，是希望和大家共同进步，我自己也能去回顾一些技术点。不管是编程新手，还是需要进阶的有一定经验的程序员，我相信都可以从中有所收获。
资料领取 这份完整版的Python全套学习资料已经上传CSDN官方，朋友们如果需要可以点击下方CSDN官方认证微信卡片免费领取 ↓↓↓【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65960e896b9c7f80926b9b98888dcc1e/" rel="bookmark">
			【Strelitzia项目】vue3&#43;ts实现element-plus中选择器省市区三级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 最近在部署项目时，想要做一个收货地址的功能，但是仅凭用户自己去输入地址感觉不太规范，假设用户输入了一个假的地址改如何处理呢，所以需要做出一个比较规范的选择器来解决这个问题。但是在这个问题的过程中存在着不少疑惑，首先就是百度找不到vue3+ts的代码，而自己本身又是后端开发人员，所以在技术层面存在着不少的疑问，vue2编写代码的方式不太熟练。所以借鉴了这篇博客，首先非常感谢这篇博客给我提供的思路 参考文章
内容 1.编写js内容 首先 点击查看这个网址中的数据格式，https://yjy-oss-files.oss-cn-zhangjiakou.aliyuncs.com/tuxian/area.jsonopen in new window
再去需要定义好需要接受数据的对象，其中三个常量分别是province、city 、area ，接受的数据是省、市、区三级的数据，其次是定义一个接受数据的类型 AreaList，并且创建好三个数据用于存放获取到的JSON数据
import axios from 'axios'; import { onBeforeMount, ref, watch } from 'vue' const province = ref('') const city = ref('') const area = ref('') export type AreaList = { code: string level: number name: string areaList: AreaList[] } const provinceList = ref&lt;AreaList[]&gt;([]) const cityList = ref&lt;AreaList[]&gt;([]) const areaList = ref&lt;AreaList[]&gt;([]) 定义好接收数据的格式之后，需要去编写组件的样式
&lt;div style="display: flex;"&gt; &lt;el-select v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65960e896b9c7f80926b9b98888dcc1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02070cca8485a99e18c44760e7fbc73e/" rel="bookmark">
			Next.js 14 发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考自 原文链接
本文梳理了 Next.js 14 要点内容。
要点汇总 Turbopack 又提速了！Server Actions 迎来稳定版。Partial Prerendering 部分预渲染功能推出预览版。Next.js Learn 免费课现已上线。 Next.js 编译器进一步增强 自版本 13 以来，Next.js 团队就一直在孜孜不倦地提升本地开发性能。新版本又带来了增量化增强方法，而一系列改进的核心就体现在基于 Rust 的 Turbopack 引擎身上。通过快速刷新，本地服务器启动速度提高了53.3%，代码更新速度提高了94.7%。相应的稳定版也将按计划发布，有望带来更加可靠、高效的开发体验。
Server Actions 迎来稳定版 在 Next.js 14 当中，Server Actions 终于迎来稳定版。开发者无需为后端任务手动创建 API 路由，现在可以直接在 React 组件中定义服务器端功能，从而允许客户端与服务器间实现无缝交互，甚至可以在 App Router 模型当中合并错误处理、缓存、重新验证与重新定向。此次更新的意义在于简化开发者工作流程，同时增强用户与应用之间的交互。对于各位 TypeScript 用户来说，稳定版功能还能更好地保障客户端与服务器间实现类型安全。此次稳定升级凸显出 Next.js 项目为增强客户端与服务器间协作所做出的持续努力，也承诺带来更加精简、愈发强大的 Web 开发体验。
// app/page.tsx export default function Page() { async function create(formData: FormData) { 'use server'; await db.form.insertOne({ formData }); } return ( &lt;form action={create}&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02070cca8485a99e18c44760e7fbc73e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4a3b3ce5a7030e7977d14854ad1517/" rel="bookmark">
			git 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记：
git status cd dataflow-etl-module/ git status git add . Git commit -am ‘’ git push origin HEAD:master git status cd .. git status Git add . Git commit -am ‘’ git push git pull git submodule update --remote git status 拉取子模块 git submodule updata --init --recursive 下拉子模块 建立远程连接：
1.设置用户名和邮箱(--global 为全局参数，表明本地所有Git仓库都会使用这个配置)
git config --global user.name "yourname" git config --global user.email "your_email@youremail.com" 非全局配置：　git config user.name "yourname"
git config user.email "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af4a3b3ce5a7030e7977d14854ad1517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f28ee383f22b24070981a956bea7cefd/" rel="bookmark">
			Vue 打包后报 Uncaught SyntaxError: Unexpected token ‘＜‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试了网上各种方法都不行，最终把依赖包 node_modules 全删除 重新 npm install 好了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ae3794585bbe0b944c2087fb30d40a/" rel="bookmark">
			c&#43;&#43;计算t=1&#43;1/2&#43;1/3&#43;...&#43;1/n
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;cmath&gt; using namespace std; int main() { int n; cin &gt;&gt; n; double t = 0; for (int i = 1; i &lt;= n; i++) { double m = 1.0/ i; t = t + m; } cout &lt;&lt; fixed&lt;&lt; setprecision(6) &lt;&lt; t &lt;&lt; endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6f6e01323102db494f4eff12dee7b07/" rel="bookmark">
			【临时对象返回值优化】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#不开启返回值优化。
#include &lt;iostream&gt; using namespace std; class Rational{ public: Rational() { cout &lt;&lt; this &lt;&lt; " called Construct" &lt;&lt; endl; } ~Rational() { cout &lt;&lt; this &lt;&lt; " called destruct" &lt;&lt; endl; } Rational (const Rational&amp; rhs) { cout &lt;&lt; this &lt;&lt; " copy construct" &lt;&lt; endl; } }; const Rational func() { Rational x = Rational(); cout &lt;&lt; "the add of x " &lt;&lt; &amp;x &lt;&lt; endl; return x; } int main() { func(); return 0; } 0xf2127ffc5f called Construct 创建x 对象 the add of x 0xf2127ffc5f 0xf2127ffcaf copy construct 构造拷贝函数，创建匿名临时对象 0xf2127ffc5f called destruct 销毁x对象 0xf2127ffcaf called destruct 销毁匿名对象 #include &lt;iostream&gt; using namespace std; class Rational{ public: Rational() { cout &lt;&lt; this &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6f6e01323102db494f4eff12dee7b07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb72fa49e48b1befbb32901ab1fdba2/" rel="bookmark">
			阿里云linux cenots7 设置不同账号密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 让新用户gengshaoyang也可以密钥登 1 添加账户 useradd gengshaoyang 2 设置用户密码 passwd gengshaoyang 3 阿里云ecs 控制台设置密钥后重启生效 4 copy 密钥文件到新增用户 目录下 cp -rf /root/.ssh /home/gengshaoyang 5 新增用户目录授权所属用户和组 chown gengshaoyang:gengshaoyang -R /home/gengshaoyang/.ssh 6 重启ssh 密钥登录 service sshd restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abbcc7ecb4c48b9e7f1e1c867e7a108/" rel="bookmark">
			Set 接口常用实现类底层分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Set 接口 1.1 特点 无序（添加和取出的顺序不一致），没有索引。不允许重复元素，所以最多包含一个 null。
1.2 常用实现类 HashSet、TreeSet、CopyOnWriteArraySet
1.3 常用方法 和 List 接口一样，Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口是一样的。 1.4 遍历方式 同 Collection 的遍历方式一样，因为 Set 接口是 Collection 接口的子接口。可以使用迭代器、增强 for 循环、但是不能使用索引的方式来获取。
1.5 代码展示 public class SetTest { public static void main(String[] args) { // Set 接口的实现类对象不能存放重复元素，可以添加一个 null // Set 接口对象存放的数据是无序的（添加的顺序和取出的顺序不一致） // 注意：取出元素的顺序虽然不是添加的顺序，但是他每次打印顺序都是固定的 Set set = new HashSet(); set.add("zhangSan"); set.add("liSi"); set.add("zhangSan"); set.add(null); set.add(null); System.out.println("set="+set); System.out.println("----------------"); // 遍历的方式一：使用迭代器 Iterator iterator = set.iterator(); while (iterator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0abbcc7ecb4c48b9e7f1e1c867e7a108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a13ec6ca6e06e4fd5c865d4d43e8a4d4/" rel="bookmark">
			【node&#43;JS】前端使用nodemailer发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言邮箱配置完整代码 前言 最近需要实现客户提交表单后，把表单的内容作为邮件发送到对应的邮箱，不通过后端服务，前端直接进行发送。嘶——，说干就干！
一通搜索下来，get到方法有很多种，但是。。。都尝试了一遍之后，只有一个成功了。
先罗列一下我搜到的方法：
1、formspree：前端实现发送邮件功能（Formspree）
这个注册完formspree的账号之后，准备创建项目表单的时候，一直弹出系统崩溃的表单，额…
2、SmtpJS：SmtpJS发送邮件教程
这一篇似乎看起来很靠谱，于是乎，我一通猛如虎的操作下来。。。它总是给我弹出一个报错：Only elasticemail is supported as an SMTP host. To open an account please visit https://elasticemail.com/account#/create-account?r=20b444a2-b3af-4eb8-bae7-911f6097521c ，大概意思是：只支持elasticemail作为SMTP主机。如需开户，请访问https://elasticemail.com/account#/create-account?r=20b444a2-b3af-4eb8-bae7-911f6097521c，呃…
3、EmailJS：EmailJS 一款不需要服务端实现的邮件发送
这篇文章看起来似乎更靠谱了，可是它告诉我，需要国外的手机号来认证Gmail账号，(⊙o⊙)…
4、nodemailer：「nodemailer」Node 邮件发送模块
好叭，天无绝人之路，我们还是老老实实用node写个接口叭…
邮箱配置 1、打开网易邮箱–&gt;设置–&gt;【POP3/SMTP/IMAP】
2、开启POP3/SMTP/IMAP服务
3、获取授权密码
4、可以记一下这个
5、初始化你的项目：npm init -y
6、添加依赖：npm install express@next dotenv nodemailer --save
dotenv：加载 .env 文件中的变量到 process.env 中
nodemailer：Node.JS 邮件发送模块
7、配置.env信息
完整代码 目录
index.html
&lt;form id="myForm"&gt; &lt;label for="name"&gt;姓名：&lt;/label&gt; &lt;input class="text" type="text" id="name" name="name"&gt;&lt;br&gt;&lt;br&gt; &lt;label for="gender"&gt;性别：&lt;/label&gt; &lt;input type="radio" id="male" name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a13ec6ca6e06e4fd5c865d4d43e8a4d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f694ec3ed5bf3a584afde40a4a40a5c/" rel="bookmark">
			强推！一个项目实现所有文件类型的文件预览功能！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是 Java陈序员。
我们在工作中，经常需要与文件上传下载进行打交道。甚至有时候要实现文件预览功能。
如果是一两种的文件类型，我们或许可以借助一些插件完成工作，那么如果是要适配各式各样的文件类型呢？
今天，给大家介绍一个支持预览多种文件类型的开源项目 —— kkFileView.
项目介绍 kkFileView 是一个基于 SpringBoot 实现文档在线预览的开源项目，基本支持主流办公文档（Word、PPT、Excel、Pdf 等）的在线预览。
项目特性：
基于 SpringBoot 实现，开箱即用提供丰富的 Restful 接口服务支持 http/https/ftp/文件流等多种预览源统一的预览服务接口，方便二次开发支持 Docker 部署 支持多种文件类型，目前已支持：
项目地址：
https://github.com/kekingcn/kkFileView 在线体验：
https://file.kkview.cn/ 在线文档：
https://kkfileview.keking.cn/zh-cn/docs/home.html 功能预览 文本预览 文本预览不仅支持预览 .txt,而且 .html、.js、.xml、.json、.yaml、.java、.py、.cpp 等也是支持的！
图片预览 支持 jpg、jpeg、png、gif 等图片预览，并可以放大、缩小、旋转图片！
Pdf 预览 Pdf 预览支持两种格式
图片模式
PDF 格式
Excel 预览 Word 预览 Word 预览预览有两种模式：
每页 Word 转为图片预览：Word 文件大，前台加载整个 PPT 过慢整个 Word 文档转成 PPT，再预览 PPT：内网访问，加载 PPT 快 PPT 预览 多媒体预览 理论上支持所有的视频、音频文件，默认开启的类型：mp3、wav、mp4、flv,可通过配置文件指定多媒体类型
压缩包预览 支持 zip、rar、jar、tar、gzip 等压缩包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f694ec3ed5bf3a584afde40a4a40a5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f099ad1ea85681a8d56f9540d14ba499/" rel="bookmark">
			直方图学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直方图均衡化（Histogram Equalization）是一种用于增强图像对比度的图像处理技术，通过重新分配图像的像素值，使图像中的亮度级别更加均匀，以改善图像的视觉质量。下面是进行直方图均衡化的一般步骤：
计算原始图像的直方图：首先，计算原始图像的灰度直方图，以了解不同亮度级别的像素数量分布。
计算累积分布函数（CDF）：对于每个亮度级别，计算其累积分布函数（CDF），这是一个表示在该亮度级别以下像素数量累积的函数。CDF可以通过对灰度直方图进行累积求和来计算。
归一化CDF：将CDF的值归一化到[0, 255]的范围内。这可以通过以下公式来实现：
CDF_normalized = (CDF - min(CDF)) / (M * N - 1) * 255
其中，M 和 N 是图像的宽度和高度。
映射像素值：对于原始图像中的每个像素，将其亮度级别映射到归一化的CDF值。具体地，用归一化CDF值替换原始像素值。
生成均衡化后的图像：将所有像素的亮度级别替换后，生成均衡化后的图像。
下面是一个Python示例，演示如何使用OpenCV库进行直方图均衡化：
pythonCopy code
import cv2 # 读取原始图像 image = cv2.imread('input.jpg', cv2.IMREAD_GRAYSCALE) # 计算直方图 hist = cv2.calcHist([image], [0], None, [256], [0, 256]) # 计算累积分布函数 cdf = hist.cumsum() # 归一化CDF cdf_normalized = cdf * 255 / cdf[-1] # 映射像素值 equalized_image = cdf_normalized[image] # 保存均衡化后的图像 cv2.imwrite('output.jpg', equalized_image)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f500104715e977ed08e3f3714b9366eb/" rel="bookmark">
			Json常用序列化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.maven &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; 2.Json序列化工具类 1.对象转Json字符串
2.Json字符串转为对象
3.json列表字符串转List对象
4.json字符串转Map对象
5.单个对象或者list的Json字符串都转换成List对象
import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.ObjectMapper; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.ArrayList; import java.util.List; import java.util.Map; /** * 常用Json序列化 */ public class JsonUtil { private static final Logger log = LoggerFactory.getLogger(JsonUtil.class); /** * 对象转Json字符 * * @param obj 对象 * @return String */ public static String objToJsonStr(Object obj) { try { ObjectMapper objectMapper = new ObjectMapper(); return objectMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f500104715e977ed08e3f3714b9366eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4122e01a44348aa0b2719403758fb6/" rel="bookmark">
			Vuex/Pinia实现数据持久化存储另一种解决方案：vuex页面刷新数据丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一 配合本地storage或cookies，在更新数据时同时将数据保存在本地，state在初始化时先从本地缓存读怪初始值。如登录时保存token：
export default new Vuex.Store({ state: { token: window.sessionStorage.getItem('token') //初始或页面刷新后从本地读取 }, mutations: { saveToken(state, data) { state.token = data window.sessionStorage.setItem('token', data) // 同时保存在sessionStorage } } }) 方案二 对于vuex可使用第三方插件，如vuex-persistedstate实现
方案三 方案一不足之处，当需再存一个用户登录信息时，如userInfo,则需在state里添加userInfo，相当于复制一个state里的token和mutations里的saveToken()，即
export default new Vuex.Store({ state: { token: window.sessionStorage.getItem('token'), //初始或页面刷新后从本地读取 userInfo: window.sessionStorage.getItem('userInfo') }, mutations: { saveToken(state, data) { state.token = data window.sessionStorage.setItem('token', data) // 同时保存在sessionStorage }, saveUserInfo(state, data) { state.userInfo = data window.sessionStorage.setItem('userInfo', data) } } }) 当需要存储更多数据，可在浏览器刷新前将整个state保留起来，刷新完页面加载完成后再将本地值设回给state。可以App.vue中添加如下代码：
export default { created() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab4122e01a44348aa0b2719403758fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb23b2d3707ad4040eaf2faf78b9c35a/" rel="bookmark">
			【SpringMVC】（3）浅谈前台往后台传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【SpringMVC】（3）浅谈前台往后台传参 【一】基本介绍【二】分析URL的概念和组成【1】概念（1）url的概念（2）url的组成 【2】特征【3】URL语法格式（1）URL的一般语法格式（2）案例说明 【4】http请求【5】http响应 【三】SpringMVC的注解【1】@RequestMapping【2】@RequestParam 参数绑定【3】@RequestBody【4】@PathVariable：Spring MVC 支持 RESTful 风格的 URL 参数获取【5】映射Cookie【6】使用 POJO 绑定参数 【四】常用注解总结【1】@RequestParam的使用（1）@RequestParam源码（2）@RequestParam加与不加的区别（3）举些栗子：@RequestParam与@PathVariable一起用，以及一些参数校验注解 【2】@PathVariable的使用【3】@RequsetBody【4】参数上什么注解都不加【5】@RequestParam和@PathVariable的区别（1）@RequestParam是从请求体中获取参数值（2）@PathVariable是从url中获取请求值 【6】@ResponseBody和@RequestBody两者的作用以及如何使用的？（1）@ResponseBody的作用是将java数据格式转换为JSON数据格式 (后台 -&gt; 前台)（2）@RequestBody 将前台JSON 对象数据转换为后台可处理数据 (前台 -&gt; 后台) 【7】@PathParam和@RequestParam的区别【8】@RequestParam是否必传设置 【五】常用的传参案例（1）postman传List集合，用@RequestBody接收（2）postman传List集合，用@RequestParam接收（3）@RequestParam接受一个List类型和Integer类型参数（4）@RequestBody接受前端传来的json数据（5）@RequestBody接受一个List类型和Integer类型参数（6）@RequestParam接受一个Integer类型数组参数 【六】Restful风格案例【1】基本介绍【2】Restful风格和普通风格的区别（1）增的区别（1.1）add的普通风格（1.2）add的Restful风格 （2）删的区别（2.1）delete的普通风格（2.2）delete的Restful风格 （3）改的区别（3.1）edit的普通风格（3.2）edit的Restful风格 （4）查的区别（4.1）select的普通风格（4.2）select的Restful风格 【3】REST 接口规范的总结（1）动作（2）路径（接口命名）（3）过滤信息（Filtering）（4）状态码（Status Codes） 【七】结合前端的传参案例【1】准备表单和pojo实体类（1）前端代码index.jsp（2）pojo实体类（省略setget方法和toString） 【2】五种传参方式（开始Controller）（1）接收普通请求参数（用参数变量接收）1：Controller编写2：前台输入数据3：运行效果 （2）接收普通请求参数（用pojo实体类接收）（3）使用@RequestParam注解获取参数（4）使用URL传递参数（RESTful风格）（5）传递JSON参数（参数较多转成JSON集，@RequestAttribute或者@RequestBody）（6）接收列表数据和表单序列化1：传递数组2：传递多个角色数组3：传递序列化表单 【一】基本介绍 前台往后台发送请求的时候，往往需要同时传递参数，用Controller控制器接收，这样控制器才能对参数进行处理。
RESTful风格：把参数写到请求路径中，而不是以HTTP请求参数JSON：比如查询用户的时候，需要分页，可能用户的信息非常多，那么查询参数可能有数十个，显然一个个传参很麻烦，那就把这些参数组装成一个JSON数据集，而把分页参数作为普通参数传递，然后再把数据传递给后台 【二】分析URL的概念和组成 【1】概念 （1）url的概念 Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL（Uniform Resource Locator, 统一资源定位器）。
它是www的统一资源定位标志，简单地说URL就是web地址，俗称“网址”。
（2）url的组成 （1）URL由三部分组成
资源类型、存放资源的主机域名、资源文件名
（2）也可认为由4部分组成
协议、主机、端口、路径。（很多时候端口都是隐藏的）
（3）还可以认为由7部分组成
协议，域名，端口，虚拟目录，文件名，锚，参数
【2】特征 【3】URL语法格式 （1）URL的一般语法格式 protocol 😕/ hostname[:port] / path / [;parameters][?query]#fragment
(带方括号[]的为可选项)
（2）案例说明 （1）协议、主机、端口、路径
https://blog.csdn.net/weixin_53436351?spm=1011.2124.3001.5343
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb23b2d3707ad4040eaf2faf78b9c35a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b606cd38ce3eab91c76c026809f03d/" rel="bookmark">
			【达梦数据库】学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【达梦数据库】学习笔记 【一】如何使用idea连接达梦数据库【二】idea项目导入本地的达梦数据库驱动jar包（方法一）【三】idea项目把本地的达梦数据库驱动jar包安装到本地仓库（方法二） 【一】如何使用idea连接达梦数据库 （1）打开idea，点击右上角的数据库
（2）把达梦数据库的jar包配置一下
找到jar包在本地的文件目录
（3）点击应用或者确定以后，重新点击idea右侧的数据库
（4）编辑数据源的连接信息
填写完成后，点击Test Connect进行测试连接
一般连接信息可以到项目的配置文件里找，或者在项目的nacos配置里，nacos的访问链接就是url/nacos
【二】idea项目导入本地的达梦数据库驱动jar包（方法一） （1）在根目录下创建lib文件夹
将本地jar包拖入lib文件夹下
（2）引入module
file ——&gt; project structure
选择libraries，点击“+”，选择java
选择新创建的lib文件夹，直接open即可
选择module，我们可以看到dependencies中已经有了lib
（3）修改pom文件
最后修改pom文件即可。
&lt;!-- 本地jar包denpendency样例 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;systemPath&gt;${basedir}/lib/xx-xxx-xx-1.0.jar&lt;/systemPath&gt; &lt;/dependency&gt; 【三】idea项目把本地的达梦数据库驱动jar包安装到本地仓库（方法二） 问题描述：idea Maven异常，Could not find artifact，也就是在本地找不到依赖
上面那个方法的jar包导入后，在本地运行时可以的，项目打jar包也是可以的，但是放到服务器上运行起来就会报错找不到依赖。所以还是要安装到本地
（1）首先确认你的maven是否已经配置
（2）本地的jar包位置
（3）安装本地的jar到本地仓库
命令：
mvn install:install-file -Dfile=D:/taobao-sdk-java-auto-20160607.jar -DgroupId=com.ganshane.specs -DartifactId=taobao-sdk-java-auto-20160607 -Dversion=1.0.0 -Dpackaging=jar
mvn install:install-file -Dfile=D:/taobao-sdk-java-auto-20160607-source.jar -DgroupId=com.ganshane.specs -DartifactId=taobao-sdk-java-auto-20160607-source -Dversion=1.0.0 -Dpackaging=jar
（4）到本地仓库查看安装是否成功：如下截图表示安装成功
（5）最后在自己项目中添加jar依赖
（6）查看maven中是否添加成功
（7）备注
1-自定义jar的artifactId不能一样，但是groupId可以一样
2-上述命令中注意空格，一定查看控制是否执行了build success，否则就添加失败。
3-达梦驱动安装的命令实例：mvn install:install-file -Dfile=D:/DmJdbcDriver18.jar -DgroupId=com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15b606cd38ce3eab91c76c026809f03d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ecff2f1f667e33dccae5d828a045d5/" rel="bookmark">
			基于Pyg实现GCN对Cora数据集的分类任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Pyg的基本使用方法（参考官网） 1.1、图的表示方法 data.x: 节点的特征的shape[num_nodes, num_node_features]
data.edge_index:代表图的连接性，形状是[2, num_edges]
data.edge_attr: 边的特征的shape [num_edges, num_edge_features]
data.y: 对应的标签，可以是图级别的[1, *]，也可以是节点类别的[num_nodes, *]
data.pos: 带形状的节点位置矩阵[num_nodes，num_dimensions] [num_nodes，num_dimensions]
对应下面的代码为如下
import torch from torch_geometric.data import Data #边的表示方式，0和1之间有节点，上面是0，下面是1，因为是无向图，所以有两个边 edge_index = torch.tensor([[0, 1, 1, 2], [1, 0, 2, 1]], dtype=torch.long) #x的特征值 x = torch.tensor([[-1], [0], [1]], dtype=torch.float) #生成图 data = Data(x=x, edge_index=edge_index) print(data) 结果为：Data(x=[3, 1], edge_index=[2, 4])
除此之外，还有一种生成图的方法，仍然以上图为基础
import torch from torch_geometric.data import Data edge_index = torch.tensor([[0, 1], [1, 0], [1, 2], [2, 1]], dtype=torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ecff2f1f667e33dccae5d828a045d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c67163f2747376d852b70778c9b1b2/" rel="bookmark">
			树形Dp 2925. 在树上执行操作以后得到的最大分数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2925. 在树上执行操作以后得到的最大分数
两次DFS
class Solution { public: // 节点状态有两种，选和不选， // dp(u, fa, 0) 不选u 节点，其他节点都可以选，值为以u为根的子树的所有节点的和- 根节点的值。 // dp(u, fa, 1) 选u节点， 其他子几点不选。 vector&lt;vector&lt;int&gt;&gt; g; int n; vector&lt;long long&gt; gsum; void dfs(int u, int fa, vector&lt;int&gt;&amp; values) { for (auto v : g[u]) { if (v == fa) continue; dfs(v, u, values); gsum[u] += gsum[v]; } gsum[u] += values[u]; return; } vector&lt;long long&gt; dp0; vector&lt;long long&gt; dp1; void Dfs2(int u, int fa, vector&lt;int&gt;&amp; values) { dp1[u] += values[u]; for (auto v : g[u]) { if (v == fa) continue; Dfs2(v, u, values); if (g[v].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c67163f2747376d852b70778c9b1b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738930e36441999399997a782846be02/" rel="bookmark">
			OFD开发系列（三）-文本提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：OFD开发系列（三）-文本提取_ofdrw-CSDN博客
一、提取场景
和之前文章类似，我们首先明确文本提取的场景。文本提取是指提取OFD正文的文本数据，然后将文本存储到搜索引擎以对OFD文档进行更好的归档、检索等；文本也可以提取摘要数据方便预览信息；文本还可以分词、分类等，对文档进行智能化分类。这些用法，大大的提高了文档检索效率。注意，ofdrw的文本提取不包含模板页，只提取正文页。
二、准备工作
同样的，我们首先引入ofdrw的依赖包，如下所示：
&lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- ofdrw --&gt; &lt;dependency&gt; &lt;groupId&gt;org.ofdrw&lt;/groupId&gt; &lt;artifactId&gt;ofdrw-full&lt;/artifactId&gt; &lt;version&gt;1.6.10&lt;/version&gt; &lt;/dependency&gt; 其次，我们准备一个待提取文本的文档，此处我们对一个电子发票进行提取（文档为测试所用，侵权联系删除），如下所示：
三、调用API 3.1、提取全部
示例代码如下：
@Test public void testContentExtractor() { try (OFDReader reader = new OFDReader(Paths.get("src/test/resources/b.ofd"))) { ContentExtractor extractor = new ContentExtractor(reader); for (String content : extractor.extractAll()) { System.out.println(content); } } catch (IOException e) { e.printStackTrace(); } } 提取结果如下：
3.2、指定页提取
@Test public void testContentExtractor() { try (OFDReader reader = new OFDReader(Paths.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/738930e36441999399997a782846be02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d79249ca2264b989c7cb5333f7fd03/" rel="bookmark">
			OFD开发系列（二）-模板填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.csdn.net/oAXuHui/article/details/109726036
#、接上篇
我们前面对水印填充方法进行了简单介绍，本章描述的模板填充，可以是正文的填充，也可以是水印填充，水印填充可参考上一篇《OFD开发系列（一）-添加水印》。
一、什么是模板填充
模板填充是指基于固定的模板文档，在指定的位置（坐标/百分比）或文本替换填入所需的图片、文本、日期等内容，最后生成一个可用的文档以供用户存档、检索、签署等。我们知道，PDF可以使用表单填充，并且可以设置文字的字体、颜色、字号、对齐方式等。而在OFD版式文档里，没有表单的概念，我们需要采用其它方法进行填充。如下所示：
基于关键字填充：此处需要查找关键字，然后增加相对应的偏移值进行填充。
基于坐标填充：此处可以指定坐标x/y值（单位mm）或百分比进行填充，这种填充方法需要模板编辑系统的支持，例如：在页面上标注好填充坐标或填充百分比位置。
基于文本替换：此处可以基于模板引擎进行文本替换或自定义标识符，该方法可能会对版式文档的阅读版式产生影响，需要定义好字符长度、字体、字号等参数。
二、模板填充的场景
常见的填充场景有如下几类：电子保单、电子合同、取证报告、调查问卷、电子发票等。总之，关键内容需要变更的电子文档，都需要具备模板填充能力。
三、ofdrw实现填充
3.1、模板填充准备
我们将上文提到的模板填充方法（关键字填充、坐标填充）进行模板填充演示，文本替换各位可以基于模板引擎直接实现文本替换，此处不进行详细说明。
首先，我们需要在maven引入ofdrw的jar包（注意此处由于ofdrw功能优化升级和上一篇的版本不一致）：
&lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- ofdrw --&gt; &lt;dependency&gt; &lt;groupId&gt;org.ofdrw&lt;/groupId&gt; &lt;artifactId&gt;ofdrw-full&lt;/artifactId&gt; &lt;version&gt;1.6.10&lt;/version&gt; &lt;/dependency&gt; 其次，我们准备一个待填充的模板文档，第一列为A列，第二列为B列，其中事项标题为A1，A1旁边为B1，以此类推，如下所示：
3.2、关键字填充
我们需要对事项标题后面的文本框填入“基于ofdrw的关键字模板填充实现”，申请依据后面填入“新版本演示”。代码如下：
/** * 模板处理 */ @Test public void testTemplateTextBaseKeyword() throws IOException, DocumentException { Path inP = Paths.get("src/test/resources/z.ofd"); Path outP = Paths.get("target/Canvas-fillText.ofd"); try (OFDReader reader = new OFDReader(inP); OFDDoc ofdDoc = new OFDDoc(reader, outP)) { String t1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12d79249ca2264b989c7cb5333f7fd03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01bf9750baec98c72b16c82f317b48e8/" rel="bookmark">
			uniapp原生插件之安卓友盟&#43;移动统计原生插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件介绍 安卓友盟+移动统计原生插件，支持账号登录，页面采集，事件统计等
插件地址 安卓友盟+移动统计原生插件 - DCloud 插件市场
超级福利 uniapp 插件购买超级福利
详细使用文档 uniapp 安卓友盟+移动统计原生插件使用文档
用法 在需要使用插件的页面加载以下代码
const module = uni.requireNativePlugin("leven-umeng-uapp-AppModule"); 申请权限 android.permission.ACCESS_NETWORK_STATEandroid.permission.READ_PHONE_STATEandroid.permission.ACCESS_WIFI_STATEandroid.permission.INTERNETandroid.permission.ACCESS_FINE_LOCATIONandroid.permission.ACCESS_COARSE_LOCATION 页面内容 &lt;template&gt; &lt;view&gt; &lt;uni-card title="友盟移动统计原生插件"&gt; &lt;view style="margin-bottom: 20px;"&gt; &lt;button type="primary" @click="requestPermission"&gt;动态授权&lt;/button&gt; &lt;button type="primary" @click="preInit"&gt;预初始化&lt;/button&gt; &lt;button type="primary" @click="init"&gt;初始化&lt;/button&gt; &lt;button type="primary" @click="initData"&gt;一键初始化&lt;/button&gt; &lt;button type="primary" @click="killProcess"&gt;退出进程&lt;/button&gt; &lt;button type="primary" @click="signIn"&gt;账号登录&lt;/button&gt; &lt;button type="primary" @click="signOff"&gt;账号登出&lt;/button&gt; &lt;button type="primary" @click="setPageCollectionMode"&gt;设置页面采集模式&lt;/button&gt; &lt;button type="primary" @click="pageStart"&gt;页面进入&lt;/button&gt; &lt;button type="primary" @click="pageEnd"&gt;页面退出&lt;/button&gt; &lt;button type="primary" @click="eventIdStatistics"&gt;事件id统计分析&lt;/button&gt; &lt;button type="primary" @click="eventLabelStatistics"&gt;事件标签统计分析&lt;/button&gt; &lt;button type="primary" @click="eventObjectStatistics"&gt;事件对象统计分析&lt;/button&gt; &lt;button type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01bf9750baec98c72b16c82f317b48e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03763641d1d19ea42568ac67e82ca20b/" rel="bookmark">
			MOS基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：技术参数详解，MOS管知识最全收录！ - 知乎
三极管工作原理详解 - 知乎
1、S级，源极，代表发射载流子的级，NMOS则代表发射电子(此时S级为低压侧)，PMOS代表发射空穴（此时S级为高压侧）。S极的符号一般有两根线。
2、MOS或三极管符号中，箭头的方向就是电流的方向，也即PN结的方向。
3、N沟道MMOSFET中使用的衬底类型是P型。类似NPN三极管
P沟道MOSFET中使用的衬底类型是N型。类似PNP三极管 4、不论是PMOS还是NMOS，控制结都是源S-栅G，只是PMOS要求VS&gt;VG，而NMOS要求VG&gt;VS，一般手册里面会把PMOS的VGS标注为负值，代表源极S电压高。
耗尽型与增强型MOS管的区别主要在于耗尽型MOS管在G端（Gate）不加电压时有导电沟道存在，而增强型MOS管只有在开启后，才会出现导电沟道；两者的控制方式也不一样，耗尽型MOS管的VGS（栅极电压）可以用正、零、负电压控制导通，而增强型MOS管必须使得VGS&gt;VGS（th）（栅极阈值电压）才行。实际电路中用增强型比较多。
下图是NMOS的示意图，也即N衬底，N沟道。源极S和漏极D都与衬底相连，这个衬底被夹在中间的栅极G给拦出了一条沟。凭什么把衬底的名字作为MOS的名字，而不是把栅极的名字作为MOS的名字？试想一下，你见过用水泥做的水沟，水沟中是水，问你这个水沟是水泥做的，还是水做的？当然是水泥，也即水沟的墙壁的材质，才是水沟的名字。这就是为什么把P衬底叫做P沟道，把N衬底叫做N沟道了。
三极管中的箭头也是PN结的方向，且这个箭头被标注在了控制结上，对于NPN，BE之间的电流控制CE之间的电流，所以箭头在BE上；同理PNP三极管的控制结也在BE上。控制结总是BE所在的结。
对于负载，显然不能接在控制结上，它会影响控制信号，所以负载都在集电极上。
上面这个黄色的图和下面这个图是一模一样的，只是把PNP上下掉了个方向：
找到一个各种mos符号的图如下：这个图里面的箭头方向比较乱，看第一行全是PMOS，箭头有的从S-&gt;G，有的从G-&gt;S。按照前文的标注规则，箭头要画在控制结上，也即G&lt;-&gt;S结上，对于PMOS，电流的流向是S-&gt;G，那么下图第一行的第1个、第4个就符合这条规则。第2/5个不知道咋回事
MOS管是FET的一种（另一种为JFET结型场效应管），主要有两种结构形式：N沟道型和P沟道型；又根据场效应原理的不同，分为耗尽型（当栅压为零时有较大漏极电流）和增强型（当栅压为零，漏极电流也为零，必须再加一定的栅压之后才有漏极电流）两种。因此，MOS管可以被制构成P沟道增强型、P沟道耗尽型、N沟道增强型、N沟道耗尽型4种类型产品。
N沟道MOSFET中使用的衬底类型是P型。类似NPN三极管
P沟道MOSFET中使用的衬底类型是N型。类似PNP三极管 每一个MOS管都提供有三个电极：Gate栅极（表示为“G”）、Source源极（表示为“S”）、Drain漏极（表示为“D”）。接线时，对于N沟道的电源输入为D，输出为S；P沟道的电源输入为S，输出为D；且增强型、耗尽型的接法基本一样。
从结构图可发现，N沟道型场效应管的源极和漏极接在N型半导体上，而P沟道型场效应管的源极和漏极则接在P型半导体上。场效应管输出电流由输入的电压（或称场电压）控制，其输入的电流极小或没有电流输入，使得该器件有很高的输入阻抗，这也是MOS管被称为场效应管的重要原因。
1、NMOS
当将衬底B与源极S短接，在栅极G和源极S之间加正电压，即VGS＞0时，如图表3（a）所示，则在栅极与衬底之间产生一个由栅极指向衬底的电场。在这个电场的作用下，P衬底表面附近的空穴受到排斥将向下方运动，电子受电场的吸引向衬底表面运动，与衬底表面的空穴复合，形成了一层耗尽层。
如果进一步提高VGS电压，使VGS达到某一电压VT时，P衬底表面层中空穴全部被排斥和耗尽，而自由电子大量地被吸引到表面层，由量变到质变，使表面层变成了自由电子为多子的N型层，称为“反型层”，如图表3（b）所示。
反型层将漏极D和源极S两个N+型区相连通，构成了漏、源极之间的N型导电沟道。把开始形成导电沟道所需的VGS值称为阈值电压或开启电压，用VGS（th）表示。显然，只有VGS＞VGS（th）时才有沟道，而且VGS越大，沟道越厚，沟道的导通电阻越小，导电能力越强；“增强型”一词也由此得来。
NMOS和NPN三极管类似，给出一个导通条件的示例电压：D：12V，G：5V，S：0V。负载一般接在D端。GS电压超过阈值电压时，则DS被导通。
2、P沟道增强型场效应管原理
P沟道增强型MOS管因在N型衬底中生成P型反型层而得名，其通过光刻、扩散的方法或其他手段，在N型衬底（基片）上制作出两个掺杂的P区，分别引出电极（源极S和漏极D），同时在漏极与源极之间的SiO2绝缘层上制作金属栅极G。其结构和工作原理与N沟道MOS管类似；只是使用的栅-源和漏-源电压极性与N沟道MOS管相反。
在正常工作时，P沟道增强型MOS管的衬底必须与源极相连，而漏极对源极的电压VDS应为负值，以保证两个P区与衬底之间的PN结均为反偏，同时为了在衬底顶表面附近形成导电沟道，栅极对源极的电压也应为负。
给出一个PMOS导通的示例电压：S：12V ，G:9V，D：0V。
下面是一个PMOS的参数表：VDS代表从D到S的压降，也即S比D高100v，S为高压侧。
下图是某个PMOS的导通特性参数表：
VGS为[-1,-2.5]v之间时导通，具体值取决于温度、工艺的不一致性、DS之间的电压等。
负值代表S比G的电压高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cbd3d4cc7c6df991866f982127013ad/" rel="bookmark">
			Python/Pycharm/Pytorch/Tensorflow/QT等安装的建议（安装/Bug解决统一存放此处）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
1.Python/Anaconda/Pycharm系列安装
1.1安装Python（建议用Windows 10 环境安装，可能会少很多失败问题，而且同等硬件下运行比win7或win8快。）
安装python时，不必单独安装，可直接安装anaconda。速度快，日后省去很多麻烦。以下是安装时所用的文件列表及版本号，安装顺序为win10-&gt;Anaconda-&gt;Pycharm： Note：上述python-3.8.2文件夹可不用安装。整个重装系统/安装所需程序环境耗时约2~3小时。
1.2 Pytorch安装（为何要先创建虚拟环境再安装）
我们在做开发时可能会同时开发多个项目，这些项目可能会依赖于不同的python环境，比如有的用到3.6有的用到3.7，这时我们创建不同版本的python，放到虚拟环境中给不同的项目分别提供其所需要的版本，这样可以将各项目所用的环境隔离开不会相互影响。就算多个项目使用同一个版本的python，这时候还是需要创建conda虚拟环境的，比如一个项目用Pytorch开发，一个项目用TensorFlow开发，不同框架对python包依赖，对底层库的依赖是不同的， 此时可能会起冲突，比如安装Pytorch后再安装TensorFlow时可能会将Pytorch所用依赖更新，则会导致Pytorch无法运行。故创建虚拟环境是非常有必要的，它可以隔离各项目所需环境，让项目之间不会起冲突。
昨天很多错误、jupyter打不开，就是安装了太多乱七八糟的包导致的不匹配。然后也无从查找原因。以后运行不同类型的工程，要放在不同的虚拟环境中，这样包的版本才不会打架。
以下为创建虚拟环境并成功安装Pytorch，且运行chapter11中演示代码main.py的方法：
• 1 ，在 conda 中，创建了新的虚拟环境 Pytorch_transformer . （ 注意，创建时一定要指定 python 版本，否则后面环境中找不到 python.exe. 除非安装 pytorch 时会自带个 python3.10 ，但也得等安装完 pytorch 才能看见 ） [ 顺利 ] • 2 ，激活 pytorch_transformer 虚拟环境中，执行 pytorch 官网的安装程序。 [ 顺利 ] • 3 ，按照 enquirements 的要求继续在虚拟环境中安装包。visdom、fire、torchvision、 tqdm、ipdb [ 前四个顺利 ] ， git+https://github.com/pytorch/tnt.git@master [ 不顺利 ] 。到 https://github.com/pytorch/tnt.git网站看了看，发现能登录，不能下载。然后用翻墙 代理上网就可 把代码下载下来后，手动安装到 pytorch_transformer 虚拟环境中 。（ cd 到 tnt 目录，然后输入 python setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cbd3d4cc7c6df991866f982127013ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe055a758ebf295dc5860657ebc218b4/" rel="bookmark">
			2020博客地址汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作学习工作中积累的文章列表，包含原创和转载优秀的文章 2020博客地址汇总2019年博客汇总 分布式基础架构组件DevOps架构下如何进行微服务性能测试？ 分布式基础架构组件概述及其场景介绍分布式事务对比 seata hmily byetcc easytransaction分布式事务对比 单点cas入门CAS-自定义CAS Server端登录页面CAS 单点登录流程分析自己动手写SSO单点登录服务端和客户端自己动手写SSO单点注销服务端和客户端CAS-搭建CAS Server服务端(静态认证)CAS OAuth2 源码分析Oauth2.0实现SSO单点登录的CAS方式和相关Demo演示cas5.x实现将ticket维护到redis集群（不使用官方提供的哨兵模式）CAS5.2.3 Server端开启restful验证 Nacos 解读：服务发现客户端Nacos 服务注册与发现原理分析nacos 1.3.2 的ui页面 本地化改造Nacos 1.3.2 部署模式 linux服务器磁盘满了查询问题
nginx 1.16.1稳定版性能测试
NGINX基于cookie针对同一域名进行分流转发
gateway 整合sentinel
Skywalking收集与发送链路数据部分源码解析
skywalking 链路监控 8.1.0 集群安装及性能测试
svn迁移到gitlab并保留commit历史记录
docker jenkins gitlab 部署
docker-jenkins 持续集成
解决jenkins 容器部署提示无法访问
GitLab的安装实战
Gitlab gitlab-ce-zh:11.1.4 持续集成
BeanUtils对象属性copy的性能对比以及源码分析
Java日志框架中真的需要判断log.isDebugEnabled()
Spring Cloud Gateway Hoxton.SR8 双重跨域问题
Spring Cloud Gray - 微服务灰度中间件
Spring Cloud Gray 配置参数
Maven Parent聚合工程同步批量修改子模块的版本号
skywalking 8.1.0 skywalking-webapp 的ui页面 本地化改造
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe055a758ebf295dc5860657ebc218b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b45a1f46b1e11717744a13cea3798a48/" rel="bookmark">
			Linux 中的一堆目录上运行 mvn clean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 find -maxdepth 1 -mindepth 1 -type d -exec mvn -f '{}/pom.xml' clean install \; ls -1 | xargs -i -- mvn -f '{}/pom.xml' clean install 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2b6f079486cf6f78d0e34fc0309907/" rel="bookmark">
			使用conda创建Python的虚拟环境（包括linux环境下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、查看已有环境
二、创建虚拟环境
2.1、添加镜像地址
2.2、创建虚拟环境
2.3、激活虚拟环境
2.4、退出虚拟环境
三、pycharm使用环境
四、删除虚拟环境
五、快速创建虚拟环境
一、查看已有环境 键入以下命令：
conda env list 打印出的所有环境如下：
二、创建虚拟环境 2.1、添加镜像地址 创建虚拟环境后，后续会下载一些Python包。为防止下载速度慢，这里可以添加Python镜像源地址：
conda config --add channels https://pypi.tuna.tsinghua.edu.cn/simple 添加好镜像后，键入以下命令查看：
conda config --show-sources 结果如下，可以看到已经把刚刚的镜像地址添加进去了。
当然也可以删除添加的镜像源
conda config --remove channels https://pypi.tuna.tsinghua.edu.cn/simple 2.2、创建虚拟环境 创建一个名为my_env的环境，并且制定Python的版本号为3.6.3
conda create -n my_env python=3.6.3 提示输入y/n时，输入y下载Python基础包。
提示如下信息，则创建虚拟环境成功
2.3、激活虚拟环境 其中 * 表示当前的环境，使用以下命令可以激活（使用）windows下python虚拟环境：
activate env_name 对于linux环境可以输入以下命令使用linux下的python虚拟环境：
source activate my_env 切换后可以再键入conda env list 确定是否已经切换成功。
2.4、退出虚拟环境 windows环境退出虚拟环境命令：
deactivate my_env linux环境下退出虚拟环境命令：
source deactivate my_env 三、pycharm使用环境 以上步骤都做好之后就可以使用这个虚拟环境。这里记录使用pycharm打开刚刚创建的虚拟环境步骤如下：
1）新建Python项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd2b6f079486cf6f78d0e34fc0309907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2d241f251ea749c935713f73258cad/" rel="bookmark">
			「Python」列表3个增加数据常用操作方法_python增加一列数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 列表增加数据无非就是把数据增加到已有的列表序列当中来，首先我们要知道一个点，什么时候需要我们去增加数据？比如我们注册一个账号，判断用户是否能注册这个账号，不能注册就提示用户，如果可以注册那么用户注册后我们就要把这个新注册的账号添加到已有的列表中来，这个时候用到的就是列表增加操作。
一、增加数据作用： 增加指定数据到列表中。
二、增加数据方法： 2.1 append()
列表结尾追加数据，如果append()追加的数据是一个序列，则追加整个序列到列表。
语法：
列表序列.append(数据)
代码体验：
list1 = ['python', 'java', 'php'] # 追加单个数据 list1.append('123') print(list1) # 原列表改变 # 追加序列数据，追加整个数据到列表 list1.append(['aa', 'bb']) print(list1) # 以上原列表已经改变，所以追加一个序列后原列表的数据变化如此 执行结果：
列表追加数据的时候，直接在愿列表里面追加了指定数据，即修改了原列表，所以列表为可变类型。
2.2 extend()
列表结尾追加数据,如果数据是一个序列，则将这个序列的数据逐一添加到列表。
语法：
列表序列.extend(数据)
代码体验：
单个数据：
# 单个数据 list1.extend('123') print(list1) # 结果：['python', 'java', 'php', '1', '2', '3'] 序列数据：
# 序列数据 list1.extend(['aa', 'bb']) print(list1) # ['python', 'java', 'php', 'aa', 'bb'] 2.3 insert()
指定位置新增数据
语法：
列表序列.insert(位置下标, 数据)
代码体验：
list1 = ['python', 'java', 'php'] list1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb2d241f251ea749c935713f73258cad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7651e0f594f85ac2163f1ef9e0385f17/" rel="bookmark">
			Python的计算性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 虽然因其解释性质而在某些场合比编译语言如 C/C++ ，但通过各种策略和工具，可以显著提升其性能。
一. 代码优化 代码优化通常指的是修改代码以提高其效率和性能。在 Python 中，这可以通过减少程序的运行时间、内存使用或二者的结合来实现。以下是一些具体的策略和实践：
1. 算法和数据结构的选择 选择正确的算法和数据结构是最有效的优化手段之一。算法的时间复杂度决定了它处理数据的速度，而数据结构的空间复杂度影响了它的存储需求。
比较不同算法的效率：例如，在排序大量数据时，快速排序通常优于冒泡排序。使用适合的数据结构：如使用集合（set）来检查成员资格而不是列表（list），因为集合在 Python 中是基于哈希表实现的，其查找时间复杂度为 O(1)，而列表为 O(n)。 2. 代码级别的优化 循环优化 循环展开（Loop Unrolling）：手动或使用工具减少循环中的迭代次数。减少循环内部的计算：将不变的计算移出循环外部，减少每次迭代的计算量。 减少函数调用 内联函数：对于小函数，有时可以通过将其内容直接插入到调用点来减少函数调用的开销。避免递归：在可能的情况下，使用迭代代替递归，因为递归函数涉及更多的函数调用和栈操作。 优化数据访问 局部变量访问优化：Python 访问局部变量比全局变量更快，所以应该考虑将经常访问的全局变量传递给局部变量。使用数组和列表推导：这些结构通常在 Python 的 C 层实现，因此执行速度更快。 减少不必要的操作 消除冗余表达式：避免在代码中重复相同的计算。使用缓存：对于重复的计算结果，使用缓存来避免重复计算，这在递归计算中特别有用。 3. 利用 Python 的内置功能 Python 的内置函数往往用 C 写成，因此它们的执行速度远快于纯 Python 代码。
内置函数：比如 map() 和 filter() 相比等价的 Python 循环，执行速度要快得多。字符串操作：使用 join() 而不是在循环中累加字符串，后者在 Python 中会引起大量的内存分配和复制操作。 4. 代码分析和剖析 在不同的代码段中使用分析工具来确定瓶颈，只对程序的热点（执行时间最长的部分）进行优化。
cProfile 和 line_profiler：这些工具可以帮助识别代码中的性能瓶颈。memory_profiler：如果内存是限制因素，它可以帮助跟踪内存的使用情况。 5. 列表推导式（List Comprehension） 列表推导式提供了一种优雅且更有效的方式来创建列表，它通常比相同逻辑的传统的for循环快。
优化前代码示例：
results = [] for i in range(1000): if i % 5 == 0: results.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7651e0f594f85ac2163f1ef9e0385f17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5103583be1d23cc487921bb6ab0b4c65/" rel="bookmark">
			检查代码混淆率proguard-rate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查代码混淆率proguard-rate
使用步骤 (下面的步骤是针对Mac系统)
1.如果没有python3环境，需要先安装，建议用homebrew一键安装。
brew install python3
或者去官网下载安装: https://www.python.org/downloads
2.使用pip拉取混淆率计算的软件包
pip install proguard-rate
（ 如果报错：zsh: command not found: pip
则执行：1. curl https://bootstrap.pypa.io/pip/get-pip.py -o get-pip.py
2.sudo python3 get-pip.py
3. 输入电脑开机密码
4.pip install proguard-rate
）
proguard-rate是这个脚本的名称，也可以去官网查看这个软件包: proguard-rate · PyPI，会默认安装最新版本。
3.拉取成功后，在terminal直接输入calRate命令，enter键，根据提示传入mapping文件地址，就可以计算出混淆率了
MacBook-Pro ~ % calRate请输入mapping文件地址: /Users/weigan/Downloads/mapping.txt 总的有效行数: 70820 已混淆的行数 67697 混淆率 0.9559022874894098
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94889c59b07b531e6e171b9a73143da7/" rel="bookmark">
			uniapp 离线打包 ios umeng友盟统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考
关于uniapp 集成友盟统计，离线SDK打包问题（避坑） - DCloud问答
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4f489da7b016f81906e54c52d6aa52/" rel="bookmark">
			抖音10月榜单有哪些看点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10月20日，抖音双11好物节在抖音平台正式开启抢跑，据数据显示，截止10月31日平台多项双11销售增长记录再次被刷新。
*新抖双十一活动也已开启，最高可省30788元，活动详情👉
抖音平台内大促氛围火爆，双11加持下，又有哪些亮眼主播、热卖商品和出圈达人呢？通过新抖统计的10月1日-10月31日的月榜数据，一起来了解看看吧。
*获取完整榜单数据，可前往&amp;nbsp;新抖数据官网查看
主播带货榜
54位主播带货破亿
据新抖数据显示，10月带货销售额破亿的主播共计54位，销售额区间在7500w-1亿的主播则是有39位。
榜单TOP3的主播排名变化较大，分别是@董先生、@疯狂小杨哥，以及@东方甄选美丽生活。
下面是「主播带货榜」TOP30的排名情况：
*向上滑动阅览*
▲ 制图：新抖
此次榜单第三的@东方甄选美丽生活排名上涨了33位，10月直播30场，销量超100w，带货表现出色，甚至超过了主号@东方甄选。
@东方甄选美丽生活直播间里并没有董宇辉常驻，而是以和董宇辉同时期走红的顿顿为主，其“精致男孩”的人设，与销售美妆个护产品的美丽生活账号定位十分贴合。
综合带货榜单之外，在各垂直带货领域中，也有表现突出的主播，本次新抖选取5个「带货领域榜」，并展示TOP10的主播，包括美妆护肤、服饰鞋帽、食品饮料、家居生活及3C数码，下面是榜单详情：
*滑动查看下一张图片*
▲ 制图：新抖
热门商品榜
纸杯单场直播卖出100w+单
就平台商品带货趋势来说，「直播带货风向-品类带货分析」按直播销售额排序发现，畅销品类仍是服饰鞋帽，销售额占比达整体的40.23%，其次是美妆护肤、食品饮料、家居生活。
▲ 新抖-直播-直播带货风向
热销商品方面，新抖统计的10月「」显示，排名前3的分别是一次性纸杯、手撕素肉、洗衣液。
▲ 新抖-商品-热门商品排行
其中，排名第一的“卡通加厚一次性纸杯”，在@郑香香的直播间里就卖出了100w+份，预估销售额在10w-25w之间。
该场直播时长105个小时，而一次性纸杯也上架了近45个小时，从价格走势中可以看出，直播过程中，不时会放出0.1元的优惠价格进行促单，销量也随之产生了明显的波动。
▲ 新抖-直播详情页-单品分析
下面是销量TOP30商品的排名情况：
*向上滑动阅览*
▲ 制图：新抖
粉丝飙升榜
30+位达人涨粉破100万
10月，共有37位达人涨粉破100万。
「粉丝飙升榜」显示，主打遗憾的@大圆哥涨粉790.56w，排在榜一；普通人@于文亮涨粉367.92w，涨粉率2545.6%，排名第二；@伊朗驻华大使馆涨粉251.26w，位列第三。
下面是涨粉榜TOP30的排名情况：
*向上滑动阅览*
▲ 制图：新抖
10月14日@大圆哥发布的视频作品《爱意随风起，风止意难平，遗憾终究还是遗憾。》成为平台爆款，截止发稿前，该视频获赞超1300w。
视频讲述了一场带有遗憾的爱情故事，作品评论区里有人分享自己的故事，有人被内容打动，不断的情感共鸣，让作品持续传播。
▲ 图源：抖音
将近10分钟的视频，情节一波三折，看完之后，会发现@大圆哥的确很会讲故事。
他通过不断打磨情节，让粉丝猜不到（剧情走向），以此给观众带去意外惊喜，以秒为单位地密集埋梗，并使用极致化的道具，渲染气氛、推动情节发展，再加上真切的情感，一起组成了出圈爆款。
以上就是10月部分月榜的内容，我们可以看到：
#&amp;nbsp;双11活动加持下，破亿直播间频频出现；
#&amp;nbsp;直播间中，利用生活用品低价促单仍然行之有效；
#&amp;nbsp;短视频创作依旧内容为王，打造高质量、有吸引力的内容，才能让更多用户关注和互动。
更多抖音达人/直播/商品/品牌/小店数据，欢迎PC端前往新抖查看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba87f4adedd3624b7e5cf5bf22a4161a/" rel="bookmark">
			5K买的300集全套JAVA面试视频、10W&#43;字文档成功上岸一线互联网大厂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 今年这情况，真心建议所有 Java 后端不要随便被“行情差洗脑”！
目前职友集上搜到的 java 岗位仍有22万+，招聘需求相比其他行业不算少！
大家最应该关注的是：自身技术硬度如何？
毕竟不管在什么时候，市场都是按照高级人才&gt;中等人才&gt;基础工程师的顺序，给打工人发录用 offer 和涨薪。
如果大家不知道该如何准备技术栈所需的技能，今天小编就给大家分享一波2023最新版java面试题300道全套视频讲解+文档，带你成功上岸一线互联网大厂，价值5K的28.81G视频文档！
网上找的资料杂乱无章没答案，只能放在收藏夹吃灰
而这份资料包，由多名一线大厂后端面试官联合整理，含完整版框架、流行技术栈等，可用来突击面试拿offer，也可用来精准学习就业提升！
限于文章篇幅原因，只能以截图的形式展示出来，有需要的小伙伴帮忙转发文章后：
→→→点这里←←←
总共包含十个模块 分布式模块（30道） 多线程模块30道： Mysql模块50道： ​JVM模块35篇 ​ES模块20道： MQ模块30道： Mybatis模块30道： Redis模块30道： SpringBoot模块30道： SpringCloud模块30道： Spring模块30道： 设计模式10道： ​ 面试资料文档整理： ​文档内容节选：
Mysql： SpringCloud 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f5225504b1a905924a54db4310f95c/" rel="bookmark">
			都用HTTPS了，还能被查出浏览记录？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，群里一个刚入职的小伙因为用公司电脑访问奇怪的网站，被约谈了。他很困惑 —— 访问的都是HTTPS的网站，公司咋知道他访问了啥？
实际上，由于网络通信有很多层，即使加密通信，仍有很多途径暴露你的访问地址，比如：
DNS查询：通常DNS查询是不会加密的，所以，能看到你DNS查询的观察者（比如运营商）是可以推断出访问的网站
IP地址：如果一个网站的IP地址是独一无二的，那么只需看到目标 IP地址，就能推断出用户正在访问哪个网站。当然，这种方式对于多网站共享同一个IP地址（比如CDN）的情况不好使
流量分析：当访问一些网站的特定页面，可能导致特定大小和顺序的数据包，这种模式可能被用来识别访问的网站
cookies或其他存储：如果你的浏览器有某个网站的cookies，显然这代表你曾访问过该网站，其他存储信息（比如localStorage）同理
除此之外，还有很多方式可以直接、间接知道你的网站访问情况。
本文将聚焦在HTTPS协议本身，聊聊只考虑HTTPS协议的情况下，你的隐私是如何泄露的。
HTTPS简介 我们每天访问的网站大部分是基于HTTPS协议的，简单来说，HTTPS = HTTP + TLS，其中：
HTTP是一种应用层协议，用于在互联网上传输超文本（比如网页内容）。由于HTTP是明文传递，所以并不安全
TLS是一种安全协议。TLS在传输层对数据进行加密，确保任何敏感信息在两端（比如客户端和服务器）之间安全传输，不被第三方窃取或篡改
所以理论上，结合了HTTP和TLS特性的HTTPS，在数据传输过程是被加密的。但是，TLS建立连接的过程却不一定是加密的。
TLS的握手机制 当我们通过TLS传递加密的HTTP信息之前，需要先建立TLS连接，比如：
当用户首次访问一个HTTPS网站，浏览器开始查询网站服务器时，会发生TLS连接
当页面请求API时，会发生TLS连接
建立连接的过程被称为TLS握手，根据TLS版本不同，握手的步骤会有所区别。
但总体来说，TLS握手是为了达到三个目的：
协商协议和加密套件：通信的两端确认接下来使用的TLS版本及加密套件
验证省份：为了防止“中间人”攻击，握手过程中，服务器会向客户端发送其证书，包含服务器公钥和证书授权中心（即CA）签名的身份信息。客户端可以使用这些信息验证服务器的身份
生成会话密钥：生成用于加密接下来数据传输的密钥
TLS握手机制的缺点 虽然TLS握手机制会建立安全的通信，但在握手初期，数据却是明文发送的，这就造成隐私泄漏的风险。
在握手初期，客户端、服务端会依次发送、接收对方的打招呼信息。首先，客户端会向服务端打招呼（发送client hello信息），该消息包含：
客户端支持的TLS版本
支持的加密套件
一串称为客户端随机数（client random）的随机字节
SNI等一些服务器信息
服务端接收到上述消息后，会向客户端打招呼（发送server hello消息），再回传一些信息。
其中，SNI（Server Name Indication，服务器名称指示）就包含了用户访问的网站域名。
那么，握手过程为什么要包含SNI呢？
这是因为，当多个网站托管在一台服务器上并共享一个IP地址，且每个网站都有自己的SSL证书时，那就没法通过IP地址判断客户端是想和哪个网站建立TLS连接，此时就需要域名信息辅助判断。
打个比方，快递员送货上门时，如果快递单只有收货的小区地址（IP地址），没有具体的门牌号（域名），那就没法将快递送到正确的客户手上（与正确的网站建立TLS连接）。
所以，SNI作为TLS的扩展，会在TLS握手时附带上域名信息。由于打招呼的过程是明文发送的，所以在建立HTTPS连接的过程中，中间人就能知道你访问的域名信息。
企业内部防火墙的访问控制和安全策略，就是通过分析SNI信息完成的。
虽然防火墙可能已经有授信的证书，但可以先分析SNI，根据域名情况再判断要不要进行深度检查，而不是对所有流量都进行深度检查
那么，这种情况下该如何保护个人隐私呢？
Encrypted ClientHello Encrypted ClientHello（ECH）是TLS1.3的一个扩展，用于加密Client Hello消息中的SNI等信息。
当用户访问一个启用ECH的服务器时，网管无法通过观察SNI来窥探域名信息。只有目标服务器才能解密ECH中的SNI，从而保护了用户的隐私。
当然，对于授信的防火墙还是不行，但可以增加检查的成本
开启ECH需要同时满足：
服务器支持TLS的ECH扩展
客户端支持ECH
比如，cloudflare SNI测试页支持ECH扩展，当你的浏览器不支持ECH时，访问该网站sni会返回plaintext：
对于chrome，在chrome://flags/#encrypted-client-hello中，配置ECH支持：
再访问上述网站，sni如果返回encrypted则代表支持ECH。
总结 虽然HTTPS连接本身是加密的，但在建立HTTPS的过程中（TLS握手），是有数据明文传输的，其中SNI中包含了服务器的域名信息。
虽然SNI信息的本意是解决同一IP下部署多个网站，每个网站对应不同的SSL证书，但也会泄漏访问的网站地址。
ECH通过对TLS握手过程中的敏感信息（主要是SNI）进行加密，为用户提供了更强的隐私保护。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/712825ba7b021212c979dfc9b72d31ed/" rel="bookmark">
			Spring 中 @Qualifier 注解还能这么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天想和小伙伴们聊一聊 @Qualifier 注解的完整用法，同时也顺便分析一下它的实现原理。
说到 @Qualifier，有的小伙伴可能会觉得诧异，这也只得写一篇文章？确实，但凡有点开发经验，多多少少可能都遇到过 @Qualifier 注解的使用场景，然而，对于大部分小伙伴来说，我们平时开发遇到的 @Qualifier 注解使用场景，只是 @Qualifier 注解功能中很小的一部分而已，今天咱们就来完整的捋一捋。
1. 基本用法 首先和小伙伴们回顾一下 @Qualifier 注解的基本用法，基本用法我从四个方面来和大家介绍，只有先把这些基本用法捋清楚了，在看源码的时候才会有种醍醐灌顶的感觉。
1.1 指定 Bean 名称 说到 @Qualifier 注解，大家最容易想到的就是处理 Bean 注入的问题了，假设我有如下 Bean：
@Configuration @ComponentScan public class JavaConfig { @Bean(value = "b1") B b1() { return new B(); } @Bean("b2") B b2() { return new B(); } } 将 B 向 Spring 容器中注册了两个，名字分别是 b1 和 b2。
现在在 A 中想要使用 B，如下：
@Component public class A { @Autowired B b; } 由于 @Autowired 注解是按照类型进行 Bean 的注入的，此时 Spring 容器中存在两个 B 实例，那么注入就会出错，通过 @Qualifier 注解我们可以指定具体想要使用哪一个 Bean：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/712825ba7b021212c979dfc9b72d31ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d37ffb41085b1769fd4bbfd335c1e8a/" rel="bookmark">
			Java 数据结构与算法-堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆的基础知识 堆是一种特殊的树形数据结构。根据根节点的值与子节点的值的大小关系，堆又分为最大堆和最小堆。在最大堆中，每个节点的值总是大于或等于其任意子节点的值，因此最大堆的根节点就是整个堆的最大值。在最小堆中，每个节点的值总是小于或等于其任意子节点的值，因此最小堆的根节点就是整个堆的最小值
堆通常用完全二叉树实现。在完全二叉树中，除最底层之外，其他层都被节点填满，最底层尽可能从左到右插入节点……
完全二叉树又可以用数组实现，因此堆也可以用数组实现……
为了在最大堆中添加新的节点，应该先从上到下、从左到右找出第 1 个空缺的位置，并将新节点添加到该空缺位置。如果新节点的值比它的父节点的值大，那么交换它和它的父节点。重复这个过程，直到新节点的值小于或等于它的父节点，或者它已经到达堆的顶部位置。在最小堆中添加新节点的过程与此类似，唯一的不同是要确保新节点的值要大于或等于它的父节点……
通常只删除位于堆顶部的元素。如果删除最大堆的顶部节点，则将堆最底层最右边的节点移到堆的顶部。如果此时它的左子节点或右子节点的值大于它，那么它和左右子节点中值较大的节点交换。如果交换之后节点的值仍然小于它的子节点的值，则再次交换，直到该节点的值大于或等于它的左右子节点的值，或者到达最底层为止。删除最小堆的顶部节点的过程与此类似，唯一的不同是要确保节点的值要小于它的左右子节点的值……
堆的插入、删除操作都可能需要交换节点，以便把节点放到合适的位置，交换的次数最多为二叉树的深度，因此如果堆中有 n 个节点那么它的插入和删除操作的时间复杂度都是 O(logn)
Java 提供了类型 PriorityQueue 实现数据结构堆。PriorityQueue 在默认情况下是一个最小堆，如果使用最大堆调用构造函数就需要传入 Comparator 改变比较排序的规则。PriorityQueue 实现了接口 Queue，它常用的函数如下表所示：
操作抛异常不抛异常插入新的元素add(e)offer(e)删除堆顶元素removepoll返回堆顶元素elementpeek PriorityQueue 和其他实现接口 Queue 的类型一样，在某些时候调用函数 add、remove 和 element 时可能会抛出异常，但调用函数 offer、poll 和 peek 不会抛异常。例如，如果调用函数 remove 从一个空堆中删除堆顶元素，就会抛出异常。但如果调用函数 poll 从一个空堆中删除堆顶元素，则会返回 null
值得强调的是，虽然 Java 中的 PriorityQueue 实现了 Queue 接口，但它并不是一个队列，也不是按照 “先入先出” 的顺序删除元素的……PriorityQueue 的删除顺序与元素添加的顺序无关
同理，PriorityQueue 的函数 element 和 peek 都返回位于堆顶的元素，即根据堆的类型返回值最大或最小的元素，这与元素添加的顺序无关
堆的应用 堆最大的特点是最大值或最小值位于堆的顶部，只需要 O(1) 的时间就可以求出一个数据集合中的最大值或最小值，同时在堆中添加或删除元素的时间复杂度都是 O(logn)，因此综合来看堆是一个比较高效的数据结构。如果面试题需要求出一个动态数据集合中的最大值或最小值，那么可以考虑使用堆来解决问题
堆经常用来求取一个数据集合中值最大或最小的 k 个元素。通常，最小堆用来求取数据集合中 k 个值最大的元素，最大堆用来求取数据集合中 k 个值最小的元素
接下来使用最小堆或最大堆解决几道典型的算法面试题
面试题 59：数据流的第 k 大数字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d37ffb41085b1769fd4bbfd335c1e8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2a3ab92a8569da3e53bfc77f499fe6/" rel="bookmark">
			Leetcode周赛370补题（3 / 3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、找到冠军 Ⅰ- 暴力
2、找到冠军 Ⅱ - 寻找入度为0的点
3、在树上执行操作以后得到的最大分数 - dfs树 + 逆向思考
1、找到冠军 Ⅰ- 暴力 100115. 找到冠军 I
class Solution { public int findChampion(int[][] g) { int n=g.length; for(int i=0;i&lt;n;i++) { int cnt=0; for(int j=0;j&lt;n;j++) if(g[i][j]==1) cnt++; if(cnt==n-1) return i; } return 1; } } 2、找到冠军 Ⅱ - 寻找入度为0的点 100116. 找到冠军 II
思路：
我们通过样例发现冠军点的入度肯定为0，假设有多个入度为0的点，是否能判断出谁是冠军？我们画几种情况看看
我们发现如果有多个入度为0的点，则无法判断出冠军，因为冠军并不是由战胜队伍的数量来衡量的，因此我们只需要找入度为0的点，如果有多个则返回-1
简化代码可以标记入度为0的点，然后遍历找出入度为0的点，如果出现多个则返回-1
class Solution { public int findChampion(int n, int[][] edges) { int[] st=new int[n]; for(int[] e:edges) st[e[1]]=1; //将入度不为0的点标记 int res=-1; for(int i=0;i&lt;n;i++) { if(st[i]==0) { if(res!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2a3ab92a8569da3e53bfc77f499fe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9d27cc13bb7aae2bddeb0ec4355544/" rel="bookmark">
			Node.js：JavaScript世界的全能工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js：JavaScript世界的全能工具 前言什么是Node.js？JavaScript运行时的演变Node.js的特点和优势 安装Node.js并设置开发环境下载与安装配置开发环境 Node.js的模块和包管理CommonJS模块规范NPM及其常用命令 使用Node.js构建简单的Web服务器创建HTTP服务器处理路由和请求 异步编程与事件驱动回调函数与异步操作Promise和Async/Await的使用 构建RESTful API设计API端点使用合适的HTTP方法处理路由和请求使用合适的状态码实现身份验证和授权处理数据验证和输入校验实现错误处理和异常处理编写文档 数据存储与数据库连接使用文件系统进行数据存储整合数据库（如MongoDB）进行数据持久化 实时应用与WebSocket实现基于WebSocket的实时通信构建聊天室或实时游戏 Node.js的性能优化代码优化技巧应用程序性能监控与调优 Node.js在企业级应用中的应用企业级应用的特点与挑战特点挑战 Node.js的解决方案和最佳实践 前言 在互联网的浪潮中，Node.js已经成为了前端开发者和全栈工程师必备的利器。它的出现不仅让JavaScript可以在服务器端运行，还为开发者们带来了许多令人惊叹的技术创新。无论是构建实时应用程序、聊天平台，还是开发高性能的网络服务，Node.js都展现了其无与伦比的灵活性和强大性能。让我们一起探索这个激动人心的世界吧！
什么是Node.js？ Node.js是一个基于Chrome V8引擎的开源、跨平台的JavaScript运行时环境，它允许开发者在服务器端运行JavaScript代码。
由于JavaScript本身是一种轻量级的脚本语言，通常用于前端开发，而Node.js的出现使得开发者可以使用熟悉的语言来构建服务器端的高性能应用程序。Node.js提供了丰富的内置库，使得开发者能够轻松地处理文件系统、网络请求以及其他操作。
​​​​​​​​​​​​​​
JavaScript运行时的演变 JavaScript最初是一种在浏览器中运行的脚本语言，用于改善用户与网页的互动。随着Web应用程序变得更加复杂，对数据处理和实时交互的需求也越来越大。在这种情况下，JavaScript需要在服务器端执行以处理高并发和实时数据交换等任务。这就促成了JavaScript运行时的演变，其中Node.js成为了其中一个突破性的技术。
早期：浏览器端JavaScript
在早期的互联网发展阶段，JavaScript主要用于在浏览器中提供基本的交互性和动态内容。它被用来验证表单、动态改变页面内容以及响应用户的操作，比如点击事件或者表单提交事件。
AJAX的兴起
随着Ajax（Asynchronous JavaScript and XML）技术的兴起，JavaScript开始被用于在后台与服务器进行异步通信。这使得网页可以实现更快的加载速度和更好的用户体验，而无需每次都重新加载整个页面。
服务器端JavaScript的出现
Node.js的出现标志着JavaScript从仅在浏览器中运行扩展到了服务器端。它采用了事件驱动、非阻塞I/O模型，使得JavaScript能够处理大量并发操作而不阻塞整个应用程序的执行。这一转变使得开发者能够使用一种语言进行前后端开发，从而简化了开发流程并提高了开发效率。
后续发展：JavaScript的全面应用
随着Node.js的成功，JavaScript运行时继续发展壮大。出现了许多其他基于JavaScript的后端框架和工具，比如Express.js、Meteor、Nest.js等，使得JavaScript成为全栈开发的首选语言之一。同时，JavaScript也逐渐进入了移动应用开发领域，例如React Native和NativeScript等框架的出现。
WebAssembly的兴起
随着WebAssembly的出现，JavaScript在浏览器端的地位得到进一步巩固。WebAssembly允许开发者使用除JavaScript之外的其他语言编写Web应用程序，从而提高了Web应用程序的性能和功能。
Node.js的特点和优势 事件驱动：
Node.js基于事件驱动的架构，通过事件循环机制处理并发请求，使得它能够高效地处理大量并发操作，避免了传统多线程模型中的资源竞争和死锁问题。非阻塞I/O：
Node.js采用非阻塞I/O模型，使得它能够在执行I/O操作时不会阻塞整个程序的执行，而是通过回调函数或者异步操作来处理I/O事件，从而提高了应用程序的吞吐量和响应速度。轻量和高效：
由于Node.js是基于事件驱动和非阻塞I/O模型，它具有较低的资源消耗，能够在相对较少的硬件资源下处理大量的并发请求，因此非常适合构建高性能的网络应用程序。丰富的包管理工具：
Node.js提供了强大的包管理工具NPM，通过NPM可以方便地安装、管理和共享代码库，使得开发者能够快速集成各种功能丰富的第三方模块和库。单线程：
尽管Node.js本身是单线程的，但是它通过事件循环机制和异步操作，能够充分利用多核CPU的优势，并且可以通过创建多个子进程来充分利用多核处理器，从而提高应用程序的性能和吞吐量。前端技术栈一致性：
由于Node.js和前端JavaScript共享相同的语言环境，使得开发者能够在前后端之间共享代码、工具和技术栈，从而简化了全栈开发的复杂度，加快了应用程序的开发速度。 安装Node.js并设置开发环境 下载与安装 下载Node.js
你可以前往Node.js官方网站（https://nodejs.org/）下载适用于你操作系统的安装包。Node.js提供了适用于多种操作系统的安装程序，包括Windows、macOS和各种Linux发行版。
安装Node.js
一旦下载完成，你可以按照以下步骤安装Node.js：
Windows操作系统： 双击下载的安装程序，按照安装向导提示完成安装。在安装过程中，你可以选择安装Node.js运行时和npm包管理器。
macOS操作系统： 双击下载的安装程序，按照安装向导提示完成安装。安装完成后，你可以在终端中通过输入node -v和npm -v来验证Node.js和npm的安装情况。
Linux操作系统： 对于不同的Linux发行版，你可以使用相应的软件包管理工具进行安装，比如在Ubuntu上可以使用apt命令，而在CentOS上可以使用yum命令。例如，在Ubuntu上可以使用以下命令进行安装：
sudo apt-get update sudo apt-get install nodejs sudo apt-get install npm 验证安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db9d27cc13bb7aae2bddeb0ec4355544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7d376efb41e55ba0bbb69cd6a44c34/" rel="bookmark">
			el-select多选以tag展示时，超过显示长度以...省略号显示，且在一行展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果：
代码：
&lt;span&gt;系统词典维度：&lt;/span&gt; &lt;el-select v-model="dNum" placeholder="请选择" multiple collapse-tags //设置collapse-tags属性将它们合并为一段文字 size="small" style="width:160px" class="tags-select-input" &gt; &lt;el-option v-for="item in gainianOptions" :key="item.uid" :label="item.name" :value="item.en" &gt;&lt;/el-option&gt; &lt;/el-select&gt; css:
.tags-select-input /deep/ .el-select__tags { white-space: nowrap; overflow: hidden; flex-flow: nowrap; display:flex; flex-wrap:nowrap; } .tags-select-input /deep/ .el-select__tags-text { display: inline-block; max-width: 90px;//设置最大宽度 超出显示... white-space: nowrap; overflow: hidden; flex-flow: nowrap; vertical-align:bottom; text-overflow:ellipsis; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a46ad9f0e45ca3cdf289d9757acaf9/" rel="bookmark">
			table的多选行点击和取消事件，复选框选中和取消事件，利用this.$refs.table.selection以及状态变化事件和行点击事件触发，代码简洁，简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!-- import CSS --&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 处理table的复选框选中和取消选中，包含多个表格的情况 1.首先要确认时选中还是取消选中，这个可以通过判断当前行是否在选中的数组中来判断 --&gt; &lt;!-- 处理table至少选择一个，当table剩下最后一个的时候，不允许取消 --&gt; &lt;div id="app"&gt; &lt;el-table ref="multipleTable1" :data="tableData" tooltip-effect="dark" style="width: 100%" @selection-change="handleSelectionChange" @row-click="(a,b,c)=&gt;{rowClick(a,b,c,1)}"&gt; &lt;el-table-column type="selection" width="55"&gt; &lt;/el-table-column&gt; &lt;el-table-column label="日期" width="120"&gt; &lt;template slot-scope="scope"&gt;{{ scope.row.date }}&lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="120"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址" show-overflow-tooltip&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;div style="margin-top: 20px"&gt; &lt;el-button&gt;切换第二、第三行的选中状态&lt;/el-button&gt; &lt;el-button&gt;取消选择&lt;/el-button&gt; &lt;/div&gt; &lt;el-table ref="multipleTable2" :data="tableData" tooltip-effect="dark" style="width: 100%" @selection-change="handleSelectionChange" @row-click="(a,b,c)=&gt;{rowClick(a,b,c,2)}"&gt; &lt;el-table-column type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a46ad9f0e45ca3cdf289d9757acaf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163d48e4d2b475da6bd50772e06f53e6/" rel="bookmark">
			今年程序员工作有多难找，Android的各位 你慌了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文 这是在某乎看到的一个热门回答，这类的回答其实在今年蛮多的，也反应了当前的IT大环境市场。
我们来看看他们是怎么回答的
年轻气盛型 一名程序猿说6月的时候和主管干了一架，撕破脸那种，结果是主管要砍掉他项目组的一半人手，并要求保证项目质量，而且摆明的说出了问题他不背这个黑锅。
然后网友哪能受这个气？随即就开始筹划跑路。
但是从6月到11月，一共就拿到4个offer，但是网友觉得自己，狠话都放出去了，就找了个薪资和距离都合适的，国庆回来就提了离职。
但是到了新公司，新公司的环境简直是一言难尽···，用网友的描述就是从CBD玻璃房搬到了一个鸟不拉屎的烂地方，新场地连电梯都没，除了新公司所在的楼层其他楼层都荒废了，楼下别说停车连站个人都恼火，公司除了名字高大上可能明天倒闭跑路都可能。
然后···然后网友就后悔了···觉得要是新公司出了幺蛾子也会成为失业大军中的一员了。
经此一事，这名网友的人生格言从：我命由我不由天！变成了：忍一忍风平浪静，退一步海阔天空！
埋头苦干型 这位老哥也是久经职场的老程序员了，自己感慨以前毕业一年就是15k，要是现在像以前一样，他这样搞深度学习的起码要报30K以上。
也更是总结到这个行业这几年就是不行，和能力无关，就算能力强，也没几个公司能开的起高价。
现在想要不被干掉，还想薪资可以，大部分人努力往底层跑是最好的选择了。
行业趋势 这两天和朋友谈到Android的行业趋势，随着转行以及毕业的大学生疯狂涌入Android行业。想要获得更好的待遇和机会，不断掌握新的技能，提高业务能力也就变成了目前Android行业人员迫在眉睫需要解决的问题。不论是面试哪个级别的Android工程师，面试官都会问一“会Framework吗？有没有看过底层源码？”，所以还停留在应用开发层面，不去提升技术，还要面临长江后浪推前浪的压力。就只能接受窘境，最后甚至是面临淘汰。更别说升值加薪了
所以如何从应用到系统，达到技术提升的目的，是很多初中级Android人必经的一个阶段。作为一个过来人，对学习过程中的困难深有体会。所以我热衷于收集整理资源，记录踩坑到爬坑的过程。希望能把自己所学，实际工作中使用的技术、自学方法、心得及踩过的一些坑，记录下来。一是更好的梳理自己，二也是能做到更好的社区分享。
《Android Framework源码开发揭秘》 本学习手册深入剖析了Android系统源代码，详细讲解了Android框架初始化过程及主要组件的工作原理,旨在通过实例和案例介绍 Android Framework 的核心概念和技术，从而帮助开发者更好地理解 Android 应用程序的设计和开发。 该手册适合具有一定 Android 应用开发经验的程序员，希望能通过深入学习 Android Framework 来帮助开发者更好地理解和掌握这一技术。
第一章 系统启动流程分析 Android系统完整的启动过程，从系统层次角度可分为 Linux 系统层、Android 系统服务层、Zygote进程模型三个阶段； 知识要点：
第一节 Android启动概括、
第二节 init.rc解析、
第三节 Zygote、
第四节 面试题
第二章 跨进程通信IPC解析 Binder作为Android进程间通信的机制，可以看做是一个驱动。在Android中，常见的进程间通信例如系统类的：打电话、闹钟等；自己创建的：像WebView、视频播放、音频播放、大图浏览等。
第三章 Handler源码解析 第一节 源码分析
第二节 难点问题
第三节Handler常问面试题
搭建了一个基于chatGPT的微信群聊机器人，24小时为大家解答疑难技术问题， 需要的可以扫描二维码进群。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7b7414bc631be5a316e76d7c8f5c05/" rel="bookmark">
			opencascade环境配置教程|vs2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencascade环境配置教程|总结 背景：研究生在读，近期开始学习opencascade源码和使用，业务上需要利用它来几何计算，使用逻辑是先建模再计算。这篇内容将从如何获取源代码、编译，windows环境下的编译、链接常见问题分析、梳理opencascade类的继承关系三个内容部分展开。
希望通过这一系列介绍能够帮助大家快速上手opencascade环境配置以及研究使用，同时记录自己学习过程。如果有什么问题欢迎联系。
什么是opencascade opencascade是c++语言编写的几何计算库，开源使用，提供python和c++两种使用版本，支持可视化、建模、计算，输入输出文件为.BRep文件。同样CGAL也是c++的几何计算库应用于各行各业，Opencascade因广泛应用于CAD产业而出名，笔者由于不是这一领域所以无法对两者库做出对比。🤣🤣
opencascade_继承关系 opencascade有非常多的头文件，总结前缀开头其实主要有GP、Geom、TopoDS开头等等为主，并且彼此之间具有继承关系，下面是我对这些类的初步梳理：
GP_xxx：基本单位如point、vector…
Geom_xxx：几何构型
TopoDS_XXX:复杂几何构型
其中GP-&gt;Geom,是通过GC_xxx方法实现；Geom_xxx-&gt; TopoDS_xx是通过BRepBuilderAPI发放实现，TopoDS_xxx -&gt;Brep（这一步还没实现我也不大确定）是通过BRepPrimAPI_xxx方法实现。
opencascade中的shape是TopoShape类型，在它的子类中还有vertex、Edge、Wire、mesh、Solid等类型。
下载源代码 opencascade是开源的代码，可以从官网下载，建议下载源码版本，然后下载第三方库，记得下载x64位，具体操作可以查看参考链接。
vs环境配置 这一部分主要解释环境配置易出现的问题以及问题背后的解释，帮助大家认识问题来源，尤其hh，笔者之前不会写代码😒
1. 编译和链接 在VisualStudio中，一个cpp程序的运行需要经过两部分处理，编译+链接。
编译是将源码（c++代码）转换成目标代码，也就是obj文件，不可直接执行。而且编译还会生成其他中间文件，如预编译投文件。
链接是在程序运行时，将多个对象文件（obj）与库文件（如lib库）链接生成最终可执行文件（.exe）。
2. lib、dll、pdb 文件关系 lib文件，是静态库文件，包含目标代码，在链接时被直接并入可执行文件，其中包含对其他库文件的引用信息，以供链接时解析。
dll文件，动态链接库文件，包含头文件中声明的函数和变量的实现。
lib和dll文件中都包含obj文件，但不包含c/c++头文件的源代码，头文件会在编译前全部展开到源代码中。
pdb文件：debug时需要，显示源代码辅助。
3. 编译错误和链接错误 在VS中，编译错误主要出现在(compile)阶段，表现位代码语法、引用头文件的错误，源代码会显示红色波浪线。典型的为语法错误、拼写错误、缺少头文件等。
链接错误：(Link)阶段与依赖库设置有关。这类错误一般是缺少库文件、库文件版本不匹配、函数未定义等等。需要检查附加依赖库路径、配置-调试-工作环境。
3.1 vs环境配置-链接错误 opencascade链接配置有三步步骤，首先你得要配置依赖库路径，然后添加准确的lib库文件名，再是在项目属性-调试器-工作环境中添加dll文件、pdb文件路径，以*PATH=“dll、pdb文件路径” %PATH%*格式添加。
其中最麻烦的部分是程序运行报错，显示为LINK错误时，是一堆16进制的函数名称，显示为未识别的符号，如@xxxadaweaweaweaw4579的字符。这里我们可以使用Far Manager工具，在工具打开的命令行中，切换到lib库所在路径，然后copy十六进制的函数，程序会遍历查找，然后手动在vs环境中输入库名字即可。
Far Manager：俄罗斯人创始，是一个在Windows上运行的文件管理器和文本编辑器，提供俄罗斯语和英文。
个人简介 深圳在读研究生，研究方向BIM/CIM，这篇博客主要记录了我配置opencascade学习过程以及问题记录。
参考链接 FarManager Far Manager下载地址
Far Manager使用语法
VisualStudio配置教程 VS配置opencascade_GIF教程
vsDebug模式配置dll库路径
Opencascade层次关系 opencascade类层次关系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6236651ce57a7819f3ca9fc49e3491c/" rel="bookmark">
			【Qt styleSheet样式表】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Qt styleSheet样式表语法 1. 属性列表 下表列出了 Qt 样式表支持的所有属性。可以为属性赋予哪些值取决于属性类型。除非另有说明，否则以下属性适用于所有小部件。标有星号*的属性为Qt特定的，在 CSS2 或 CSS3 中没有等效项。
属性
属性类型
描述alternate-background-colorBrush用于QAbstractItemView子类。
如果未设置此属性，则默认值是为调色板设置的值AlternateBase角色。
可参考background和selection-background-color。backgroundBackground设置背景，相当于指定background-color、background-image、
background-repeat和background-position。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，QComboBox，QDialog，QFrame，QGroupBox，QLabel，QLineEdit，QMenu，QMenuBar，QPushButton，QRadioButton，QSplitter，QTextEdit，QToolTip和QWidget。
可参考background-origin，selection-background-color，background-attachment，background-clip和alternate-background-color。background-colorBrush设置某个小部件的背景颜色background-imageUrl设置某个小部件的背景图像background-repeatRepeat是否以及如何重复背景图像来填充background-origin矩形。
如果未指定此属性，则背景图像在x，y两个方向上重复。background-positionAlignment背景图像在background-origin矩形内的对齐方式。如果未指定此属性，则对齐方式为top left。background-attachmentAttachment确定背景图像是否在QAbstractScrollArea相对于视口滚动或固定。默认情况下，背景图像随视口滚动。background-clipOrigin小部件的矩形，在其中background绘制 。此属性指定区域将background-color和
background-image剪裁。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，QComboBox，QDialog，QFrame，QGroupBox，QLabel，QPushButton，QRadioButton，QSplitter，QTextEdit，QToolTip和QWidget。
如果未指定此属性，则默认为border。background-originOrigin小部件的背景矩形，与background-position和background-image一起使用。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，QComboBox，QDialog，QFrame，QGroupBox，QLabel，QPushButton，QRadioButton，QSplitter，QTextEdit，QToolTip、和QWidget。
如果未指定此属性，则默认为padding。borderBorder设置小部件边框。相当于指定border-color、border-style和border-width。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，QComboBox，QFrame，QGroupBox，QLabel，QLineEdit，QMenu，QMenuBar，QPushButton，QRadioButton，QSplitter，QTextEdit，QToolTip和QWidget。border-topBorder设置小部件顶部边框。相当于指定border-top-color、border-top-style和border-top-width。border-rightBorder设置小部件右部边框。相当于指定border-right-color、border-right-style和border-right-width。border-bottomBorder设置小部件底部边框。相当于指定border-bottom-color、border-bottom-style和
border-bottom-width。border-leftBorder设置小部件左部边框。相当于指定border-left-color、border-left-style和border-left-width。border-colorBox Colors设置所有边框边缘的颜色。相当于指定border-top-color、border-right-color、border-bottom-color和border-left-color。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，
QComboBox，QFrame，QGroupBox，QLabel，QLineEdit，QMenu，QMenuBar，QPushButton，QRadioButton，QSplitter，QTextEdit，QToolTip和QWidget。
如果未指定此属性，则默认为color（即小部件的前景色）。border-top-colorBrush边框上边缘的颜色border-right-colorBrush边框右边缘的颜色border-bottom-colorBrush边框底边缘的颜色border-left-colorBrush边框左边缘的颜色border-imageBorder Image填充边框的图像。图像被切割成九个部分，并在必要时适当拉伸。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，QComboBox，QFrame，QGroupBox，QLabel，QLineEdit，QMenu，QMenuBar，QPushButton，QRadioButton，QSplitter，QTextEdit和QToolTip。
可参考border-color，border-style，border-width和The Box Model。border-radiusRadius边框角的半径。相当于指定border-top-left-radius、border-top-right-radius、border-bottom-right-radius和border-bottom-left-radius。裁剪小部件的background。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，QComboBox，QFrame，QGroupBox，QLabel，QLineEdit，QMenu，QMenuBar，QPushButton，QRadioButton，QSplitter，QTextEdit和QToolTip。
如果未指定此属性，则默认为 0。border-top-left-radiusRadius边框左上角的半径。border-top-right-radiusRadius边框右上角的半径。border-bottom-left-radiusRadius边框左下角的半径。将此属性设置为正值会产生圆角。border-bottom-right-radiusRadius边框右下角的半径。将此属性设置为正值会产生圆角。border-styleBorder Style所有边框边缘的样式。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，QComboBox，QFrame，QGroupBox，QLabel，QLineEdit，QMenu，QMenuBar，QPushButton，QRadioButton，QSplitter，QTextEdit和QToolTip。
如果未指定此属性，则默认为none。border-top-styleBorder Style边框上边缘的样式。border-right-styleBorder Style边框右边缘的样式。border-bottom-styleBorder Style边框下边缘的样式。border-left-styleBorder Style边框左边缘的样式。border-widthBox Lengths边框的宽度。相当于设置border-top-width、border-right-width、border-bottom-width 和border-left-width。
此属性支持以下控件：QAbstractItemView子类，QAbstractSpinBox子类，QCheckBox，QComboBox，QFrame，QGroupBox，QLabel，QLineEdit，QMenu，QMenuBar，QPushButton，QRadioButton，QSplitter，QTextEdit和QToolTip。
也可参考border-color，border-radius，border-style，border-image和The Box Model。border-top-widthLength边框上边缘的宽度。border-right-widthLength边框右边缘的宽度。border-bottom-widthLength边框下边缘的宽度。border-left-widthLength边框左边缘的宽度。bottomLength如果position是绝对的，将子控件向上移动一定的偏移量；指定bottom:y等同于指定top:-y。
如果position是绝对的，该bottom属性指定子控件的下边缘相对于父控件的下边缘（另请参见subcontrol-origin）。
可参考left，right，top。button-layoutNumber按钮的布局QDialogButtonBox或QMessageBox。可能的值为 0 (WinLayout), 1 (MacLayout), 2 (KdeLayout), 3 (GnomeLayout) 和 5 (AndroidLayout）。
如果未指定此属性，则默认为SH_DialogButtonLayout样式提示的当前样式指定的值。colorBrush用于渲染文本的颜色。所有遵守该属性的小部件都支持此属性QWidget::palette。
如果未设置此属性，则默认值是小部件调色板中为QWidget::foregroundRole（通常为黑色）。dialogbuttonbox-buttons-have-iconsBoolean按钮是否位于QDialogButtonBox显示图标。如果该属性设置为1，则显示图标；如果设置为0，则不显示图标。请参阅图标清单有关如何设置图标的信息部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6236651ce57a7819f3ca9fc49e3491c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110a30f74ff43f5538676e8a85f28b94/" rel="bookmark">
			Lamport Clock算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lamport Clock 是一种表达逻辑时间的逻辑时钟（logical clock），能够计算得到历史事件的时间偏序关系。
假设 P0进程是分布式集群中心节点中的监控者，用于统一管理分布式系统中事件的顺序。其他进程在发送消息之前和接受事件消息之后都需要告知 P0 进程，告知的过程是异步的。
如图上图，P1 需要发生消息给 P2。P1在发送消息之前先告知 PO，之后再发送消息给 P2，P2在收到消息后立即告知 PO。将过程中的消息交互分别标识为“事件 A”、“事件 B”和“事件 C”，则对于不同进程的事件序列如下所示。
对于 P0 进程，A-&gt;C；
对于 P1 进程，A-&gt;B;
对于 P2 进程，B-&gt;C;
由偏序关系具有传导性，所以整个事件的顺序应该就是 A -&gt; B -&gt; C。
但在实际过程中，往往伴随着网络等延迟，这时候事件消息的发送与接收并不能保证顺序性。如下图所示，可能就会出现 PO 进程接收到事件 C 消息早于事件 A，
此时对于 P0 进程来说就是 C-&gt;A；
对于 P1 进程，A-&gt;B;
对于 P2 进程，B-&gt;C;
由 P1 和 P2 得出 A-&gt;C，但对于 P0 来说 C-&gt;A,互相矛盾了。
Lamport Clock存在二个假设和五条规则.
结合这三个假设和五条规则，则可以解决上面因网络延迟造成消息乱序的场景
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce6ca1b752742f811ff26c22f976480/" rel="bookmark">
			office2024下载详细安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的说 Office 是一款由Microsoft 开发的一套办公软件，里面包含了常用的办公组件而其中就包含了Word、Excel、PowerPoint、Access等！
并且office是目前最常用的一类办公软件，使用它可以解决日常生活和工作中遇到的很多问题。
熟练掌握office的操作技巧是对计算机工作者的基本要求,也可以帮助你提高工作效率出色的完成办公需求!
那么新版的Office与之前的老版本相比，不仅是界面上有所改进，同时在功能上也带来一些新特性!
现在微软Office 2021版本目前发布正式版了, 今天给大家分享最新版Office的下载、安装的方法!
废话不多说,这里我大致搜集了几种能够免费安装Office 2021的方法以方式,并总结出保姆级教程 如下:
通过Office 2021 RTM镜像下载与安装Office 2021
Office Tool Plus部署和安装 Office 2021 和 Office 365
通过Microsoft 365 订阅会员的方式得到Office 365
以上方式以win10系统为例, 任选一种都可以,简单通俗 无脑易懂, 现在就开始吧!
3|1方式一 Office 2021 RTM镜像下载与安装🔥 这是微软发布的是Office 2021 RTM专业增强零售版
由于微软目前发布的版本只有Office 2021英文版，因此如果想要切换为Office 2021中文版则需要再次手动安装中文语言包
下载好了之后会得到两个文件
如下图
然后解压缩Office 2021 RTM 安装包, 点击其中的Setup开始安装
如下图
然后稍等片刻....
就开始自动安装了!
小提示: 由于零售版采用自动默认安装方式，因此安装时不会出现组件选择和安装位置选择的步骤。
等待滚动条走动完毕之后，Office 2021 RTM专业增强零售版就算安装好了
然后接下来就是最后一步安装中文语言包,否则就是英文版的。同样我们直接运行中文语言安装包文件就可以了!
稍等片刻..
完成中文安装
Office 365最大的特点就是在线办公，协同办公，随时同步，onedrive空间大。这些保证了无论你在任何一台设备修改文件，都可以立刻同步到任何一台联网的设备。
Office 365还有一个特点是: 能够随时保持最新版本。
Office办公软件365mac安装包下载: https://wm.makeding.com/iclk/?zoneid=47172
Office办公软件365win安装包下载: https://wm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ce6ca1b752742f811ff26c22f976480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d42fcb351008092e047a26a16f3bdc9/" rel="bookmark">
			电脑出现错误代码0x0000011b怎么办，一键修复0x0000011b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你的电脑出现了错误代码的提示，这时候应该怎么办？其中，0x0000011b是一个常见的错误代码，它通常会导致系统崩溃或无法正常工作。不用担心，我们可以通过一些解决办法来修复这个问题。今天就教大家如何一键修复0x0000011b。
在解决0x0000011b错误代码问题之前，我们首先需要了解一下它的原因。通常，0x0000011b错误代码是由于驱动程序或软件的冲突引起的。当我们在电脑上安装或更新软件或驱动程序时，可能会出现相互之间不兼容的情况，从而引发错误代码的出现。也有可能是因为电脑打印机设置出错，导致适用于共享打印机时，系统出现的0x0000011b错误代码。
一.解决0x0000011b错误代码的办法 解决办法一：卸载冲突软件或驱动程序 首先，我们可以尝试卸载最近安装或更新的软件或驱动程序。在Windows操作系统中，我们可以通过以下步骤来进行操作：
打开“控制面板”，并选择“程序和功能”。
在应用程序列表中找到最近安装或更新的软件或驱动程序。
右键单击该程序，并选择“卸载”选项。
按照提示完成卸载过程。
解决办法二：更新或回滚驱动程序 如果卸载冲突软件或驱动程序后问题仍然存在，我们可以尝试更新或回滚驱动程序。以下是具体操作步骤：
打开“设备管理器”，我们可以通过在开始菜单中搜索“设备管理器”来快速访问。
在“设备管理器”窗口中，找到与问题相关的设备，通常是显示在“其他设备”或“通用串行总线控制器”下。
右键单击该设备，并选择“更新驱动程序”。
在弹出的选项中，选择“自动搜索更新的驱动程序软件”。
如果系统找到了新的驱动程序，按照提示进行安装。
如果更新驱动程序后问题仍然存在，我们可以尝试回滚驱动程序到之前的版本。以下是具体操作步骤：
在“设备管理器”窗口中，找到与问题相关的设备。
右键单击该设备，并选择“属性”。
在“驱动程序”选项卡中，选择“回滚驱动程序”。
按照提示完成回滚过程。
解决办法三：电脑修复精灵 如果以上的方法都不能解决错误代码0x0000011b的问题，大家可以试试使用这个电脑修复精灵，这是一个专用的解决错误代码问题的工具，具体操作步骤如下：
在浏览器顶部输入：电脑修复精灵.site，按下回车键进入。
进入后将工具点击下载并安装，安装完成即可使用。
安装完成后将工具进行启动，启动完成后点击“一键修复”，
工具将开始对电脑中出现问题的错误代码进行修复，不仅仅能修复0x0000011b错误代码，还能将电脑中出现的其他的错误代码也进行修复。
快速解决0x0000011b错误代码的问题。
关于错误代码0x0000011b的问题解决起来其实也不是很麻烦，希望上面的办法能够帮助大家一件修复0x0000011b。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8defa3f12b894c8bc51bf3079ca09dfa/" rel="bookmark">
			构建信用卡客户风险识别模型 &#43; python 数据分析 &#43; 图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构建信用卡客户风险识别模型
需求说明：
为了推进信用卡业务良性发展减少坏账风险，各大银行都进行了信用卡客户风险识别的相关工作，减少坏账风险，各大银行都进行了信用卡客户风险识别的相关工作。某银行研究的风险识别模型随时间推移不再适应业务发展需求，需要重新进行风险识别模型构建。
实验目标 （1） 掌握异常值的识别与处理方法。
（2） 构建信用卡用户风险分析关键特征。
（3） 掌握 K-Means 聚类算法的应用。
（4） 掌握聚类算法结果分析的方法。
实验内容 为了推进信用卡业务良性发展，减少坏账风险，台湾各大银行都进行了信用卡客户风险
识别相关工作，建立了相应的客户风险识别模型。某银行因旧的风险识别模型随时间推移，不再适应业务发展需求，需要重新进行风险识别模型构建。
（一）处理信用卡数据异常值
实验步骤
（1） 读取信用卡数据。
（2） 丢弃逾期，呆账，强制停卡，退票记录，拒往记录为 1，瑕疵户为 2 的记录。
（3） 丢弃呆账，强制停卡，退票为 1，拒往记录为 2 的记录。
（4） 丢弃频率为 5，刷卡金额不等于 1 的数据。
(二) 特征选取 特征的轩主主要是以下三个方面。
1. 根据特征瑕疵户，逾期，呆账，强制停卡，退票，拒往记录构建历史行为特征。
2. 根据特征借款余额，个人月收入，个人月开销，家庭月收入和月刷卡金额，构建出经济风险情况特征。
3. 根据特征职业，年龄，住家，构建出收入风险情况特征
4. 将历史行为特征，经济风险情况特征以及风险情况特征分别进行降维
（三）构建模型
构建K-Means聚类模型，聚类数为5。
训练模型，求出聚类中心、每类的用户数目。
结果分析
通过观察SSE与k的取值尝试找出合适的k值
雷达图
（一类客户）
（二类客户）
（三类客户）
（四类客户）
（五类客户）
（雷达图）
根据H（历史行为）E（经济风险）I（收入风险）数据，我们可以对客户进行评价分析。
客户聚类HEI图
HEI图
客户价值排名图
客户特征图
客户价值分析
我们重点关注的是H，E，I，从HEI图中可以看到： 1、一类客户 [blue] E I 很高，H也不低，可以看做是重要保持客户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8defa3f12b894c8bc51bf3079ca09dfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405dfce519f7cc318ea53765556f8e26/" rel="bookmark">
			【2023最新】超详细！！！新商盟卷烟js逆向_包括验证码错误问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1 抓包2 搜素加密字段3 断点调试4 js扣代码还原5 破解验证码5 selenium获取cookies6 完成代码展示 前言 新商盟卷烟 密码 js 逆向
密码加密好解决，但是多次请求，还会有一个验证码
这个时候就会请求失败
所以验证码问题我也会解决
1 抓包 先模拟登录，抓到返回表单的包
2 搜素加密字段 输入加密的字段，搜索js文件打断点调试
3 断点调试 在可疑的字段处打上断点
再次输入进行调试
调试后我们发现有两个字段不能确定哪一个是加密字段，但是我们现在可以看到
c是验证码
g.j_mcmm是有验证码的返回值
p.j_mcmm是没有验证码的返回值，我们这里退出调试，看看最后的返回值是哪一个
退出之后可以看到返回的是g.j_mcmm，说明他是加了验证码的
所以：F(F(b)+c) 就是我们需要的函数
b是你的密码
c是验证码
先把b用F函数加密一次
在把加密后的密码加上验证码在加密一次
就是返回的值
4 js扣代码还原 找到F函数，打上断点查看
找到之后打上断点调试
可以看到d就是F函数，参数a就是密码
经过了n,e,o,m函数多次加密就是返回值
所以我们直接扣js代码，记得把n,e,o,m函数也带上
// js代码 function e(a, b) { for (var c = 1732584193, d = -271733879, e = -1732584194, f = 271733878, l = 0; l &lt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/405dfce519f7cc318ea53765556f8e26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a8acd75038aae529b100ae0deaaf20d/" rel="bookmark">
			c语言——数组篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数组简介
一维数组的定义及引用
一维数组的初始化
二维数组
二维数组的定义及引用
二维数组的初始化
多维数组
数组与函数
小结
数组简介 我们都知道 c 有许多数据类型，如整型、实型和字符型等等.....它们都属于基本数据类型。除此之外，c 还提供了一些更为复杂的数据类型，名为构造类型或导出类型，它是由基本类型按照一定的规则组合而成，数组就是最其中基本的构造类型。
数组是按顺序存储的一系列类型相同的值，如10个 char 类型的字符或10个 int 类型的值。整个数组有一个数组名，通过整数下标访问数组中单独的项或元素。用于识别数组元素的数字被称为下标、索引或偏移量。下标必须是整数，而且下标是从0开始计数的。数组的元素依次存储在内存中相邻的位置。
一维数组的定义及引用 定义：
定义一个数组，需要明确数组变量名，数组元素类型以及数组大小。一维数组定义一般形式为：
类型名 数组名 [ 数组长度 ] ；
//类型名指定数组中元素的类型；数组名是数组变量的名称，遵从标识符定义规则；数组长度是一个整型常量表达式，设定数组大小。
int a[10];	//含有10个整型元素的数组 a double b[100]; //含有100个双精度浮点型元素的数组 b char _xiaowei[10*10]; //含有100个字符型元素的数组 _xiaowei 在定义数组之后，系统根据数组中元素的类型及个数在内存中分配一段连续的存储单元用于存放数组各元素，并对这些单元进行连续编号，即下标，以区分不同的单元。每个单元所需的字节数由数组定义时给定的类型确定。如一个 int 类型占用4个字节，我们就假设上面定义的数组 a 的起始地址是 2000 ，则其内存分配形式为：
还有一点需要注意的是，c 中数组名表示该数组所分配连续空间中第一个单元的地址，即数组名==首地址。另外由于数组空间一经分配之后在运行过程中不会改变，因此数组名是一个地址常量，不允许修改。这个一定要记住哦，因为以后说指针与数组区别，你记住这个数组名是地址常量就很容易理解为什么指针可以自增自减而数组不能。
引用：
定义数组后，就可以使用它了。c 规定只能引用单个的数组元素，而不能一次引用整个数组，数组元素引用要指定下标，其形式为：
数组名 [ 下标 ]
下标可以是整型表达式，它的合理取值范围为[ 0 ~ 数组长度-1 ]，使用数组时，要防止下标超出边界，也就是说必须确保下标是有效的值，例如” int a[10] ；”那么在使用该数组时，要确保程序中的数组下标在 0 ~ 9 范围内，编译器不会替你去检查这种错误，在 c 标准中，使用越界下标的结果是未定义的，这意味这程序看上去可以运行，但是运行结果会很奇怪，或直接异常中止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a8acd75038aae529b100ae0deaaf20d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8088d16b7c0fac8e283f6b5f5781c4e0/" rel="bookmark">
			linux 安全系列目录 - seccomp安全模块问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux系列目录 linux 安全系列目录 - seccomp一、Seccomp沙箱安全机制二、安装依赖包三、Seccomp Strict Mode四、Seccomp Filter Mode (Seccomp-BPF) - 推荐五、有用资源六、总结 linux 安全系列目录 - seccomp 涉及seccomp安全模块问题时，可以参照本文档案例进行扩展分析，可以多访问文中的链接，很有用。
一、Seccomp沙箱安全机制 通过使用libseccomp，开发人员可以定义一组允许的系统调用规则，从而限制应用程序的系统调用（system call）集合，阻止对潜在危险的系统调用的调用。它最初被用于 cpushare 这个项目，让人们可以出租自己空闲的 cpu cycle 来执行未受信任代码(untrusted code)。这个 feature 本身并不是一个沙盒 (sandbox)，它只是一种减少 Linux 内核暴露的机制，是构建一个安全的沙盒的重要组成部分。其中，沙箱bwrap也会使用它。
安全计算模式 seccomp（Secure Computing Mode）是自 Linux 2.6.10 之后引入到 kernel 的特性。一切都在内核中完成，不需要额外的上下文切换，所以不会造成性能问题。目前 在 Docker 和 Chrome 中广泛使用。使用 seccomp，可以定义系统调用白名单和黑名单，可以 定义出现非法系统调用时候的动作，比如结束进程或者使进程调用失败。
seccomp机制用于限制应用程序可以使用的系统调用，增加系统的安全性。
在/proc/${pid}/status文件中的Seccomp字段可以看到进程的Seccomp。
二、安装依赖包 sudo apt install libseccomp-dev libseccomp2 seccomp 三、Seccomp Strict Mode 使用prctl来设置程序的seccomp为strict模式，仅允许read、write、_exit和sigreturn四个系统调用。当调用未在seccomp白名单中的系统调用后，应用程序会被kill。
#include &lt;stdio.h&gt; /* printf */ #include &lt;sys/prctl.h&gt; /* prctl */ #include &lt;linux/seccomp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8088d16b7c0fac8e283f6b5f5781c4e0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/43/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>