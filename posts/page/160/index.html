<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078f3bed0956e0d95bed27594cab3557/" rel="bookmark">
			json序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json模块作用 json模块可以将字典、列表等序列化对象转换成特殊的字符串，也就是json数据，再将这种特殊的字符串转换回来。主要的使用场景比如网络传输，文件存储数据。如果用str（）方法转换成普通的字符串，没有办法再转换回原来的数据类型。eval方法除外，不推荐使用。json数据还是各种编程语言通用的数据类型，python的json数据，java也可以获取使用，十分方便。
json方法：
json主要的方法比较简单，有四个，两两一对使用。
json.dump()、json.load():只能用于文件数据读写
json.dumps()、json.loads():既能用于文件读写，也能用于文件传输。
1. json模块在网络传输中的使用
这里我写了一个socket服务端和客户端，演示在网络中传输json数据：客户端发送给服务端一个消息，服务端返回一个字典转换成的json数据给客户端，客户端接收后再转换成字典类型并输出在屏幕上。
服务端代码：
import socket import json server = socket.socket() ip_addr = ('127.0.0.1',8222) server.bind(ip_addr) server.listen() dict = {'status':'ok', 'messages':[{'cityname':'石家庄'},{'citycode':'130100'}] } while 1: conn,addr = server.accept() try: while 1: client_msg = conn.recv(1024).decode('utf-8') print(f'来自客户端的消息:{client_msg}') dict_json = json.dumps(dict) dict_byte = dict_json.encode('utf-8') conn.send(dict_byte) conn.close() except Exception: break 要点解释：
dict_json = json.dumps(dict) #这一步会将dict这个字典转换成特殊的字符串，也就是json数据
dict_byte = dict_json.encode(‘utf-8’) #将json数据编译成字节类型的数据，方便传输通信。
客户端代码：
import socket import json client = socket.socket() client.connect(('127.0.0.1',8222)) msg = input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078f3bed0956e0d95bed27594cab3557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db8593212b73468fea92d803dced4fc2/" rel="bookmark">
			ROS深度相机集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 使用带ROS的gazebo深度摄像头 介绍 在本教程中，您将学习如何将gazebo深度摄影机连接到ROS。教程包括三个主要步骤：
创建一个包括ROS深度相机插件的露台模型在gazebo上安装深度摄影机在RViz中查看深度摄影机的输出。 这是一个独立的教程；它不使用在其他Gazebo ROS教程中开发的RRBot。它的目的是帮助你在ROS和gazebo上 迅速使用电脑视觉。
先决条件 你应该安装gazebo_ros_pkgs在学习本教程之前。
2 创建一个带有深度相机插件的露台模型 因为Gazebo和ROS是独立的项目，互不依赖。默认情况下，来自gazebo_models存储库（如深度摄影机）的传感器不包括ROS插件。这意味着您必须根据Gazebo模型存储库中的自定义摄影机，然后添加自己的摄影机&lt;plugin&gt;标记使深度摄影机数据将点云和图像发布到ROS主题。
你应该从gazebo上提供的相机中选择一个景深相机。本教程将使用Microsoft Kinect，但此过程应与列表中其他深度摄影机的过程相同。
首先，获取深度摄影机并修改其名称。我们从gazebo_models你要做的就是下载然后把它打开。
或者，您可以按照model contribution tutorial从头开始制作自己的相机，或者可以克隆gazebo_models从那里复制一个传感器。
无论你得到它，复制kinect文件夹到你的~/.gazebo/models目录。然后，将模型的名称改为有意义的名称，比如kinect_ros。若要更改模型的名称，应更新文件夹名称&lt;name&gt;存储在.config文件，和型号名称在model.sdf文件。
现在您需要添加ROS插件来发布深度相机信息并输出到ROS主题。ROS插件列表和示例代码可以在插件教程 .
在本教程中，您将使用通用的“opennikinect”插件。你可以（也应该）将此插件用于Kinect之外的其他类型的深度摄影机（它是一个较旧的插件，因此它保留了原来的名称）。
打开model.sdf新模型目录中的文件。将以下SDFmarkup添加到&lt;sensor&gt;在结束后立即标记&lt;/camera&gt;标签：
&lt;plugin name="camera_plugin" filename="libgazebo_ros_openni_kinect.so"&gt; &lt;baseline&gt;0.2&lt;/baseline&gt; &lt;alwaysOn&gt;true&lt;/alwaysOn&gt; &lt;!-- Keep this zero, update_rate in the parent &lt;sensor&gt; tag will control the frame rate. --&gt; &lt;updateRate&gt;0.0&lt;/updateRate&gt; &lt;cameraName&gt;camera_ir&lt;/cameraName&gt; &lt;imageTopicName&gt;/camera/color/image_raw&lt;/imageTopicName&gt; &lt;cameraInfoTopicName&gt;/camera/color/camera_info&lt;/cameraInfoTopicName&gt; &lt;depthImageTopicName&gt;/camera/depth/image_raw&lt;/depthImageTopicName&gt; &lt;depthImageCameraInfoTopicName&gt;/camera/depth/camera_info&lt;/depthImageCameraInfoTopicName&gt; &lt;pointCloudTopicName&gt;/camera/depth/points&lt;/pointCloudTopicName&gt; &lt;frameName&gt;camera_link&lt;/frameName&gt; &lt;pointCloudCutoff&gt;0.5&lt;/pointCloudCutoff&gt; &lt;pointCloudCutoffMax&gt;3.0&lt;/pointCloudCutoffMax&gt; &lt;distortionK1&gt;0&lt;/distortionK1&gt; &lt;distortionK2&gt;0&lt;/distortionK2&gt; &lt;distortionK3&gt;0&lt;/distortionK3&gt; &lt;distortionT1&gt;0&lt;/distortionT1&gt; &lt;distortionT2&gt;0&lt;/distortionT2&gt; &lt;CxPrime&gt;0&lt;/CxPrime&gt; &lt;Cx&gt;0&lt;/Cx&gt; &lt;Cy&gt;0&lt;/Cy&gt; &lt;focalLength&gt;0&lt;/focalLength&gt; &lt;hackBaseline&gt;0&lt;/hackBaseline&gt; &lt;/plugin&gt; 正如您所看到的，这个插件允许您对如何将信息传递给ROS有很多细粒度的控制。注意以下几点：
这个updateRate参数应设置为0，这将导致plugin以与父SDF相同的速率发布深度信息传感器。如果UpdateRate不是0，它将在父级上执行其他限制sensor的更新率。主题名称和frameName可以设置为任何您想要的，但是上面显示的主题与常用的dros包发布的默认主题相匹配，例如 openni2_launch。保持主题名称相同有助于在真实和模拟相机之间切换。这个distortionX参数应符合&lt;distortion&gt;母相机的标签。如果没有&lt;distortion&gt;标记，然后对所有distortionX的值取0。pointCloudCutoff和 PointCloudCutoffMax分别是点的最小和最大距离。超过此距离的点将不显示。在任何一个传感器上都设置了一个附加的限制。 重命名模型后，将上面的代码添加到.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db8593212b73468fea92d803dced4fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ccfefc689f35f36b3c7d68c41b6aee/" rel="bookmark">
			MongoDB操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先附上两个网址
MongoDB 连接 | 菜鸟教程
MongoDB CRUD 操作 — MongoDB Manual 3.4
mongoDB 概念解析
show dbs：命令可以显示所有数据的列表
use 数据库名：如果数据库不存在，则创建数据库，否则切换到指定数据库。
保留数据库名，可以直接访问这些有特殊作用的数据库。
admin： 从权限的角度来看，这是"root"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 dropDatabase() 删除数据库
先选择到要删除的数据库，再使用命令
集合操作 db.createCollection(name, options) 创建集合
例：db.createCollection("mycollection") show collections 命令检查当前数据库中的集合
db.COLLECTION_NAME.drop() 删除集合
数据类型（常用）
String − 字符串是最常用的数据类型，MongoDB中的字符串必须是UTF-8编码。
Integer − 整数类型用于存储数值。整数可以是32位，也可以是64位，这取决于你的服务器。
Boolean − 布尔类型用于存储布尔值(true/ false)。
Double − 双精度类型用于存储浮点值。
Min/ Max keys − 此类型用于将值与最低和最高的BSON元素进行比较。
Arrays − 此类型用于将数组、列表或多个值存储到一个键中。
Timestamp − ctimestamp。时间戳，用于记录文档何时被修改或创建。
Object − 这种数据类型用于嵌入文档。
Null − 此类型用于存储Null值。
Symbol − 此数据类型与字符串用法相同; 然而，它通常用于某些使用特定符号的语言。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7ccfefc689f35f36b3c7d68c41b6aee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87fa128c0884f0cf2873f011360795a/" rel="bookmark">
			详解数据中台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于数据中台，目前业界并没有一个标准的定义，不同厂商、不同企业对数据中台都有着不同的理解。但对于数据中台大家也有一个共识就是它是用来解决企业数据各类数据问题，使得企业数据资源转化为数据资产的解决方案。
今天给大家分享的这篇文章是关于数据中台定义、价值、架构和建设方法，文章来源于公众号“实时数仓架构”，配图来源云徙科技。以下为本文大纲：
1. 数据中台定义
2. 数据中台价值
3. 数据中台VS业务中台
4. 数据中台功能架构
5. 数据中台技术架构
6. 数据中台构建的三大路径
7. 数据中台构建5步法
—01—
数据中台定义
数据中台是一种将企业沉睡的数据变成数据资产，持续使用数据、产生智能、为业务服务，从而实现数据价值变现的系统和机制。
通过数据中台提供的方法和运行机制，形成汇聚整合、提纯加工、建模处理、算法学习，并以共享服务的方式将数据提供给业务使用，从而与业务联动。再者，结合业务中台的数据生产能力，最终构建数据生产—消费—再生的闭环。
—02—
数据中台价值
数据中台不等于大数据平台，数据中台的核心工作也并不是将企业的数据全部收集起来做汇总就够了。
数据中台的使命是利用大数据技术、通过全局规划来治理好企业的数据资产，让数据使用者能随时随地获取到可靠的数据。因此，数据中台一旦建成并得以持续运营，其价值将随着时间的推移将呈指数级增长。
2.1 帮助企业建立数据标准
在有数据中台之前，企业基本不会有全局的数据标准，即使有相关的数据标准，由于没有数据中台这个实体形态，数据标准也无从执行。
数据中台的建设天然会帮助企业建设数据标准，包括数据建设规范和数据消费规范。数据建设规范有诸如数据接入规范、数据建模规范、数据存储规范和数据安全规范等，数据消费规范包含数据权限规范、数据调用规范以及数据销毁规范等。
这些标准都是建设数据中台时必须建立起来并依托数据中台去执行和落地的。
2.2 促进中台组织形成
再宏伟的企业战略规划，都离不开一套科学合理的组织去落地执行。
数据中台建设将是企业宏观战略规划的一个重要部分，那么在践行数据中台建设的过程中，摆在企业第一位的问题就是如何搭建起一套能稳定护航数据中台建设及运营的数据中台班子。
数据中台这种体系化工程将横向拉通企业数据相关方，包括中台建设团队、中台运维团队、数据产品经理团队、数据资产管理团队、数据运营团队等，组成标准的企业数据委员会，从而形成企业真正的中台组织。
需要说明的是，中台组织可以是一个横跨各个业务部门的弱矩阵组织，也可以是一个完整的实体组织。这需要因地制宜，因企业不同而异。
2.3 全面赋能业务，促使降本增效
数据中台的终极价值是降本增效，无论是建设数据标准还是形成中台组织，其核心目标都是帮助企业达成战略规划。
通过数据中台，可以更加合理地布局团队；数据从加工生产到使用的整个时间周期将大大缩短；以中台之力拉通整合企业营销、交易、服务、库存、物流等一方数据，结合二方及三方数据，以全局视角，形成强大的数据资产，滋养各业务板块。
同时有目的性地针对场景，设计出赋能场景的数据应用，帮助其从研、产、销等多个方面缩短产品研发周期，生产未来一段时间畅销的产品，精准找到愿意购买公司产品的群体，以至于增强用户对企业产品及服务的友好体验，提高用户对于企业品牌的忠诚度，降低企业运营过程中的损耗，压缩供应链端的周期等。
—03—
数据中台VS业务中台
无论是业务中台还是数据中台，都是在企业IT系统架构演进过程中形成的，并从企业自身IT系统规划、建设、运营、运维等多年的经验中提炼出来的共性能力。
业务中台和数据中台作为两个轮子并肩构建了数字中台，支撑前台对会员的从营销推广、转化交易到智能服务业务的闭环，促进企业业务的提升和发展。数字中台对内连接企业的后台系统，诸如ERP、人力资源、协同办公、财务管理等。
业务中台与数据中台双轮驱动的数字中台支撑前台业务。
业务中台抽象、包装和整合后台资源，转化为便于前台使用的可重用共享的核心能力，实现了后端业务资源到前台易用能力的转化，为前台应用提供了强大的“炮火支援”能力，随叫随到。
业务中台的共享服务中心提供了统一、标准的数据，减少了系统间的交互和团队间的协作成本。
数据中台接入业务中台、后台和其它第三方数据，完成海量数据的存储、清洗、计算、汇总等，构成企业的核心数据能力，为前台基于数据的定制化创新和业务中台基于数据反馈的持续演进提供了强大支撑。
可以认为数据中台为前台战场提供了强大的“雷达监测”能力，实时掌控战场情况，料敌先机。
不过数据中台所提供的数据处理能力和之上建设的数据分析产品，也不局限于服务业务中台。数据中台的能力可以开放给所有业务方使用。
业务中台与数据中台相辅相成，互相支撑。
对于业务方来说，自己产生数据，并同时消费自己的数据，在消费自己的数据时又在继续产生数据，从而形成数据闭环。
数据中台并不是截然独立的，它与业务中台一起组成了支撑业务的两个轮子。 —04—
数据中台功能架构
数据中台建设是一个宏大的工程，涉及整体规划、组织搭建、中台落地与运营等方方面面的工作，本节重点从物理形态上讲述企业的数据中台应该如何搭建。一般来讲，企业的数据中台在物理形态上分为三个大层：工具平台层、数据资产层和数据应用层。
4.1 工具平台层
工具平台层是数据中台的载体，包含大数据处理的基础能力技术，如集数据采集、数据存储、数据计算、数据安全等于一体的大数据平台；还包含建设数据中台的一系列工具，如离线或实时数据研发 工具、数据联通工具、标签计算工具、算法平台工具、数据服务工具及自助分析工具。
以上工具集基本覆盖了数据中台的数据加工过程。
4.2 数据资产层
数据资产层是数据中台的核心层，总体来讲，可以划分为主题域模型区、标签模型区和算法模型区。
①主题域模型
主题域模型是指面向业务分析，将业务过程或维度进行抽象的集合。业务过程可以概括为一个个不可拆分的行为事件，如订单、合同、营销等。
为了保障整个体系的生命力，主题域即数据域需要抽象提炼，并且长期维护和更新，但是不轻易变动。在划分数据域时，既要涵盖当前所有业务的需求，又要保证新业务能够无影响地被包含进已有的数据域中或者很容易扩展新的数据域.
②标签模型
标签模型的设计与主题域模型方法大同小异，同样需要结合业务过程进行设计，需要充分理解业务过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87fa128c0884f0cf2873f011360795a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcdec1af25b4c0c6300c4175b28e8e5/" rel="bookmark">
			Flutter值得学吗？未来还能走多远？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Flutter？ Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。简单来说，Flutter是一款移动应用程序SDK，包含框架、控件和一些工具，可以用一套代码同时构建Android和iOS应用，并且性能可以达到原生应用一样的性能。
Flutter的优势： 1、开源，也正是由于开源，所以在全球开发者的疯狂支持下，这几年flutter飞速发展，越来越趋于完善，相信以后再windows,mac,linux等各个平台也能大放光彩。真正做到一套代码多端部署。
2、稳定，Flutter UI由于自绘UI，从而避免了平台层面的UI和系统升级导致的各种兼容问题。但是作为跨平台开发技术不可避免的需要去维护底层适配层和各种插件实现与原始平台的通信，这是所有跨平台的通病。
3、高效，对开发者来说，使用 Flutter 开发应用十分高效。Flutter 广受好评的 Hot Reload 功能可以在 1 秒内实现代码到 UI 的更新，使得开发操作周期被大幅缩短。
Flutter应用 通过LibChecker app可以随便打开本人手机所安装的 app（参考了 GSY 方法），选择查看哪些 app 包含了 Flutter:
发现了没有，几乎大厂的 App都在列：
微信
淘宝、天猫、UC、菜鸟、饿了么
度小满、百度贴吧
网易有道词典
…
这些 App 正在尝试甚至已经大规模使用Flutter。
Flutter找工作的加分项 Flutter目前也是Android开发岗位的加分项,通过上图我们可以看出，很多大厂在高薪招聘这方面的人才。
怎么学 Flutter ？ 这份谷歌开源的《Flutter完整开发实战详解》，希望可以帮助大家用最短时间学习Flutter。教程通俗易懂，实例丰富，既有基础知识，也有进阶技能，能够帮助读门者快速入进阶，快收藏起来！！！
一、Dart语⾔和Flutter基础 ⼆、 快速开发实战篇 1、基础控件
2、数据模块
3、其他功能
三、 打包与填坑篇 1、打包
2、细节
3、问题处理
四、 Redux、主题、国际化 1、Redux
2、主题
3、国际化
五、 深⼊探索 1、WidgetsFlutterBinding
2、InheritedWidget
3、内存
4、线程
5、热更新
六、 深⼊Widget原理 七、 深⼊布局原理 1、单⼦元素布局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afcdec1af25b4c0c6300c4175b28e8e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35f6c5917006916caa7ea91b328ffcf/" rel="bookmark">
			vue使用element-ui的cascader，value和label为后台返回的值，并获取选中的value和label值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用element-ui组件库的cascader级联选择器组件时，我们发现组件默认的数据结构是label为键名，value为键值，但通常后端返回的数据键值并不是value和label，就需要我们通过props属性label和value进行自定义。
1、从后台返回的数据结构
expenseList: [ { expenseId: 1, expenseItem: '运输费-1', child: [ expenseId: 11, expenseItem: '运输费-2', child: [ expenseId: 111, expenseItem: '运输费-3' ] ] } ] 2、给cascader绑定props
&lt;el-cascader :options="expenseList" :props="optionProps" v-model="optForm.expenseId" @change="handleChange" ref="cascaderItem" :show-all-levels="false" clearable&gt;&lt;/el-cascader&gt; //:show-all-levels="false"显示选中项最后一级的标签 3、在data中定义props
data() { return { expenseList:[], optionProps: { value: 'expenseId', label: 'expenseItem', children: 'children', checkStrictly: true, //选择任意一级 }, } } 4、获取最终选择的最后一级的id
handleChange(itemIdArr){ //获取id let val=itemIdArr[itemIdArr.length-1] this.optForm.expenseId=val }, 5、获取选中的label值，给el-cascader加ref="cascaderItem"，通过下面代码即可获得：
this.expenseItem = this.$refs['cascaderItem'].inputValue 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ba5b4cbd9d66976b509233907b761a/" rel="bookmark">
			支付设计白皮书：支付系统的概念与中国互联网支付清算体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 “ 文本已收录至我的GitHub仓库，欢迎Star：https://github.com/bin392328206/six-finger
种一棵树最好的时间是十年前，其次是现在
” 絮叨 大家好，我是小六六，三天打鱼，两天晒网，小六六接触进入到支付这个行业也快一年了，从今天开始就开始输出自己的对支付相关的知识的梳理来和大家一起来学习支付，支付是一个非常大并且应用广泛的一个行业，它是万事万物的基础！我觉得任何产品的最后一公里肯定是支付了。有人说：“支付很简单。”，有人说：“支付很难。”如果你对支付感兴趣，建议关注我哦！大家一起学习！
人类支付的上下五千年 人类社会自从有了分工，就有了交换，而有了交换，也就有了支付，交换可以说是支付最古老的表现形态
最早古人们实行以物易物，但是这种交易方法缺陷很大，既不方便也不经济。
新时代晚期，在半坡文化和大汶口文化时期，人们以陶罐和兽骨作为交易货币。这是迄今为止发现的人类使用货币财富的历史文物证据。
商代起，人们开始使用“天然贝”来当作货币。
至春秋时期，“天然贝”泛滥，通货膨胀。各诸侯国开始铸造“金属贝”来替代“天然贝”，管控恢复经济秩序。经济上的独立不但使各诸侯国摆脱了周王朝的控制，更造就社会进一步繁荣，为日后的战国争霸打下了坚实的经济基础。
战国时期，各国纷纷标新立异，推出各种形状的主权铸币。情景和现在当今世界各国印制的主权货币现象差不多。
秦统一六国之后，车同轨，文同书，币同制。开创造了国家货币的统一制式铸造表现形式，并赋予其“天圆地方”的神秘玄学基因。
北宋时期，经济空前繁荣，在频繁的商业往来下，铸币由于重量和体积不方便携带，因此一种名为“交子”的纸币开始出现。这是世界上最早有关纸币的历史记录。标志着纸币这种新型货币表现形式正式登上历史舞台。
元代蒙古人入主中原后，更是把纸币视为解决国家经济困难的的妙法之一。由于当时人们没有什么经济学概念，更不懂什么“MV=PY”货币量发行原则，结果纸币无限制印发。发行量过大导致了纸币迅速贬值，从而诱发严重的通货膨胀。民不聊生，以到元末农民大起义爆发，元朝统治者又被赶回了草原。
明初，因为经济困难，朝廷继续印发“大明宝钞”纸币维持经济，但是依旧陷入了纸币无限制超额印发的陷阱，纸币迅速贬值。明中期后，随着白银大量流入中国，朝廷经济好转，已经完全失去了信用的“大明宝钞”纸币被废止。
清末时期，朝廷在洋枪大炮的威胁下，被迫打开国门开始通商。伴随着各地不断开放通商，清光绪年间，终于仿照外国制度，设立了户部银行，发行正规的纸币。并仿造墨西哥银元铸造了中国第一款无孔银圆。这是铸币形状上2000多年来第一次改变，标志着铸币“天圆地方”时代的趋于结束。
1935年，民国政府开始实行法币制度（即国家法定货币制度）。从明清两朝的“银本位”制度重新回归“金本位”，实现了与国际标准“金本位”制度的同步
如今，随着国家复兴、经济繁荣和科技发展，货币的表现形式也日趋多样化。甚至出现了如“Q币”、“比特币”等虚拟货币。
在国际上，数字货币正在异军突起，被视为传统纸币的取代者。当然，这不可能是一夜之间的事，从纸币完全取代金属铸币的历史算起，也有八、九百年的漫长时间。
如今，随着微信、支付宝的普及，电子支付方式带给了人们空前的便利。从纸币到数字信息交易仅仅不到10年的时间，现在大部分人都能接受电子支付的方式。
支付的最基本的三要素 我们来看一个例子哈
假设小六六在古代，打到了一只野兔，然后隔壁邻居小七七有一个鸭子，然后小六六想跟他换，结果小七七同意了，那么我们来看看这个交换的步骤是什么
第一步，当然是大家想要达成一个交易，也就是六六和七七希望完成兔子和鸭子的交易，商品就是兔子和鸭子
第二步，根据计算情况，小六六应付一只兔子，小七七应付一只鸭子，小六六应收一只鸭子，小七七应收一只兔子
第三步，完成这笔交易交割，小六六获得了鸭子，小七七获得了兔子
上面的三步其实对应了支付的三个基本过程，交易，清分，和结算，这也是支付的基本三要素！
支付基本要素之交易 其实交易的概念是挺简单的，交易是引起债务债权的各种经济活动，交易是支付的前提，交易无处不在，比如在线购物，线下买东西，转账，等等 ，在交易的过程中，需要确保支付指令的生成，确认，和传输，包含交易主体的合法性，身份确认，支付通道的路由，支付能力的查证，交易报文的传输，交易结果查询，数据落地，补偿机制等等！
支付基本要素之清分和清算 “清分（clearing）是清算的数据准备阶段，主要是将当日的全部网络交易数据按照各成员行之间本代他、他代本、贷记、借记、笔数、金额、轧差净额等进行汇总、整理、分类。“
通过这段解释，我们可以从三点来理解：
“清分“字面意思。所谓“清分”就是清清楚楚的分开。
“清分”对应的英文是clearing，也就是理清楚，搞清楚的意思。
定义最后部分，说的是“......等进行汇总、整理、分类。”，这是全定义的重点。
因此，总结来看，“清分”就是网络交易数据分门别类的记录、整理、汇总的过程。
一般而言，支付活动的过程包括交易、清算和结算。其中，清算和结算均是清偿收付双方债权债务关系的过程及手段。在支付活动中，同行内账户资金往来直接结算便可，而涉及不同行之间账户资金往来的，则需先清算再结算
清算主要是指不同银行间的货币收付，可以认为是结算进行之前，发起行和接收行对支付指令的发送、接收、核对确认，其结果是全面交换结算工具和支付信息，并建立最终结算头寸。
清算是用于不同行之间账户资金往来的，同行之间的资金往来，无需清算，直接结算就行。
清算字面意思。清算就是清清楚楚的算清楚。不同行之间谁付谁多少钱，谁欠谁多少钱，最后再一轧差，得出一个最终谁该付谁多少钱的计算过程。
清算要含括发起行和接收行对支付指令的“发送”、“接收“、“核对确认”等动作，即最后付款之前的一个核对确认动作，确保结算无误。
最后，清算不涉及债券债务关系的转移。
支付基本要素之结算 结算（settlement of accounts）是指将清算过程产生的待结算头寸分别在发起行、接收行进行相应的会计处理，完成资金转移，并通知收付双方的过程。
我们从“结算”和“清算”的英文也可以看出来，“结算”是settlement of accounts，是涉及账户的结算，而“清算”的英文是settlement，仅仅是算，并没涉及账户。
所以，《中国银联银行卡联网联合技术规范V2.1》里，对结算的定义是：完成客户账户间资金划拨的过程。
什么是支付系统 自古以来，所有的商业活动都会产生货币的收款与付款行为。在人类漫长的历史长河中，记录收付款行为的方式不断迭代：古代的账房先生通过手工记账，工业社会通过收银机机械记账……
今天，进入了互联网时代的我们，商业行为也一同进行了数字化与信息化的演变，成为今天的「电子商务」。
支付系统伴随着电子商务的出现而出现，为各类电子商务经营活动实现在线收付款交易以及管理交易资金等功能，是具有一定独立性的内部系统模块。
image.png 平台：开展电子商务经济活动的主体。
业务系统：实现平台用户注册、商品定价、营销活动等相关功能。
平台与业务系统的关系：业务系统将用户购买行为通过各种交易订单的形式进行记录，并交付支付系统进行处理，最终由支付系统完成收款与付款。
根据央行的现行规定，人民币交易处理仅限于银行及第三方持牌支付机构，因此支付系统在实现上述功能时，需要通过外部银行、第三方持牌支付机构完成交易资金处理。因此，支付系统需要具备：
统一封装处理的交易接口，以对接外部交易渠道，为业务系统实现交易订单处理的功能。
根据业务系统设置的资金分配规则，在一笔交易有多个收款方参与的情况下根据资金分配规则完成交易资金的自动化清分与结算，而后通过已对接的外部交易渠道完成划付。
账务数据记录功能，上述的交易、清分、结算形成的资金变动信息，需要支付系统通过账务数据记录功能加以记录，对交易资金进行统计并完成交易资金核对等财会工作。
中国的支付清算体系 都说要了解支付的话，那么我们首先要了解下参与中国支付体系的参与方有哪些，它们各自负责的部分又是什么
中国人民银行 又称央妈，支付领域的王者兼创造者，发布各项政策规范的存在。央行并不涉及支付方面的具体业务，作为支付行业的一员只需要牢记央妈是最强大的就足够了，她说什么就是什么。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ba5b4cbd9d66976b509233907b761a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3081ae48000197fa758434a338fb897d/" rel="bookmark">
			一个简单的JavaWeb技术点复盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 要想开发一个简单的看得过去的JavaWeb界面，需要学些啥？ 想要学好JavaWeb，以下的技术不能少，这一整套可以让你比较详细的了解，一定程度深入学习原理。可以这么说，熟练掌握了这些东西，再学习SSM框架，就可以到外面找到工作了！ 下面会介绍每个技术点，通过以下几个点来介绍 概述：也就是介绍它是什么，它能起什么作用快速入门：通过一些简单的例子，来描述一下它，让你更能体会它的作用原理：通过一些简单的描述，让你知道这个技术是怎么实现的。 下面我们就好好掰扯一下上述的所有技术要点。
1 mysql基础 1.1 概述 1 数据库概念：在没有学习过数据库之前，	我们存储数据都是靠文件存储，txt、word、excel等等。这样的方式固然能够存储数据，但是当我们的数据量增大之后，我们想要更快捷的存储数据，用以前传统的文件形式存储存在诸多问题：不便于管理、数据量大之后存储查询速度慢，通常只是需要简单的一个查询，就需要消耗大量的时间。这时数据库就站出来了，数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。既然有组织了，那么性能就更优，因此数据库的应用就更加广泛，而MySQL就是众多优秀数据库中的一员。 1.2 快速入门 select * from tb_user;	这条语句就是查询用户表的所有信息，select是查询，*代表所有，from tb_user表示从tb_user表中来获取。 1.3 MySQL原理 MySQL数据库是RDBMS即关系数据库管理系统(Relational Database Management System)，它有如下优点： 1. 数据以表格的形式出现（理解：一个班级的所有学生信息集成在一张表上） 2. 每行为各种记录的名称（理解：每一行即为一个学生的所有信息） 3. 每列记为记录名称所对应的数据域（理解：每一列即为某种特性，比如姓名列，年龄列） 4. 许多的行和列组成一张表单（理解：一整张表单表示一个班级的信息） 5. 若干的表单组成database（理解：所有班级组合在一起就是整个学习的信息，也就是仓库） 而操控数据库需要一种语言，操控MySQL的就是SQL语言，当然SQL语言也可以操控其它很多的数据库，因此我们学习完一门MySQL数据库之后，相应的学习其它数据库也就很快上手了，因为SQL语言都是大体相同的，只是在某些语法的规定上可能略有不同。我们学习MySQL最主要的就是学习它的增删改查功能insert delete update select： （增加表格，写语句） 增：在数据库增加一条数据，比如班级转校来了一名学生，增加他的信息到数据库中 删：在数据库中删除数据，比如班级转校转出一名学生，从数据库中删除他的信息 改：在数据库中更改已经存在的数据，比如某个学生的姓名录入的时候书写错误，发现后通过改的方式更新数据。 查：在数据库中查询已有的数据，比如我们要查询班级上所有男生的信息 2 MySQL高级 2.1 概述 在1中我们入门，知道了MySQL是什么，能干什么事，在第二part我们聊点高级的东西 我们在讲高级的时候抛出几个问题： 1 既然能够存储数据，那么怎么避免小明的数据被输入两次呢？ 2 建立表的时候，比如年龄这一栏肯定是正数，万一输入错误成负数该如何避免呢？ 3 在实际的查询过程中，很可能学生信息在一个表，学生成绩在一个表，如何联合两张表来进行组合查询呢？ 4 在增删改的过程中，因为涉及到数据的变更，我们如何来保证数据的可靠性，不被非预期的修改。 2.2 技术点原理 其实对应2.1中提及到的4个问题，我们都是可以通过MySQL数据库的几种特性来一一解释的。 一一对应的是约束、表关系及建表原则、表的联合查询、事务 约束：通过约束，比如唯一约束，说明这一列的数据只能存在唯一值，比如学生学号。在学生学号后面建立唯一约束 表关系及建表原则： 联合查询： 事物： 3 JDBC 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3081ae48000197fa758434a338fb897d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c2afbe14210734daca7c913288219d7/" rel="bookmark">
			手写字符识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、手写字符识别原理
以下来源网上。
手写数字识别，可以采用图像识别的方法，左边的x是手写之后的图像，右边的y是对应的数字。
对于图像信息，计算机是用数值来进行表示的，机器学习让计算机具备智能，实际上是训练出数值模型w对于新的输入x，可以通过与w进行数值运算得到y从而进行预测判断的。
上面的一张图片在计算机中的存储方式是数值矩阵。
我们用8×8的像素矩阵来表示这张图片，每个像素点用0~16表示灰度，0对应白色，16对应黑色，11， 12 ，13的数值对应的是深灰色，5，6，7等数字，对应的这是浅灰色，
这样上面的模糊图片就对应到下面的数字矩阵。由此手写数字识别问题就转化为计算机可以处理的数值问题。
机器学习是以矩阵运算为基础的。
来看一下我们的训练数据集，不同人的手写方式不同，写数字有非常多的写法，但不同的写法之间仍然有一些相似性，人可以识别出来并且打上标签，比如第1排的这些手写体，对应的标签都是数字0，而对于机器学习，每个手写数字都对应一个数值矩阵，他们在数值分布上呈现一定的特征。
比如数字1在数字矩阵中呈现的特征是黑色的像素点在数字矩阵当中是相邻的构成了一个线段。利用这些特征，我们可以在n维向量空间中把这些数值矩阵分为10类，分别对应右边0~9这10个数字，这样手写数字识别问题就转化成为了监督式学习的分类问题classification。
但是有时无法正确识别数字，例如识别3
通过编写程序， 机器学习都无法解决这一问题， 这就需要提到神经网络， 根据大脑对图像的识别原理，解决：
通过对每一个神经元赋值， 再乘以权重w, 再加上bias值， 再把计算结果传到激活函数中sigmoid, 用于激活下一层的神经元：
二、手写字符识别例子
下载手写字符识别代码 地址：https://github.com/mivlab/AI_course
下载MNIST_Dataset数据集 地址： https://pan.baidu.com/s/18Fz9Cpj0Lf9BC7As8frZrw 提取码：xhgk。
PyCharm新建工程，打开代码目录classify-pytorch
1、训练数据
运行train_minist.py
一开始会出现错误：
这就需要在菜单栏Run中的Edit Configurations 输入命令行参数
也就是在--datapath=后面输入训练数据的目录
然后就可以正确运行了
2、测试数据
运行tes_minist.py
三、结果
手写字符识别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd2018dfc007787cf7e85a86b1793c8/" rel="bookmark">
			Spring Data JPA 从入门到精通~AliDruidDataSource的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AliDruid 配置方法
（1）在实际工作中，由于 HikariCP 和 Druid 应该各有千秋，会发现偏向于监控，有很多国内开发 者使用频次最高的 AliDruid，我们来看看看如何配置。
&lt;!--druid--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt; &lt;/dependency&gt; （2）一样的思路，我们打开 DruidDataSourceAutoConfigure 配置类。
@Configuration @ConditionalOnClass(com.alibaba.druid.pool.DruidDataSource.class) @AutoConfigureBefore(DataSourceAutoConfiguration.class) @EnableConfigurationProperties({DruidStatProperties.class, DataSourceProperties.class}) @Import({DruidSpringAopConfiguration.class, DruidStatViewServletConfiguration.class, DruidWebStatFilterConfiguration.class, DruidFilterConfiguration.class}) public class DruidDataSourceAutoConfigure { @Bean @ConditionalOnMissingBean public DataSource dataSource() { return new DruidDataSourceWrapper(); } /** * Register the {@link DataSourcePoolMetadataProvider} instances to support DataSource metrics. * * @see DataSourcePoolMetadataProvidersConfiguration */ @Bean public DataSourcePoolMetadataProvider druidDataSourcePoolMetadataProvider() { return new DataSourcePoolMetadataProvider() { @Override public DataSourcePoolMetadata getDataSourcePoolMetadata(DataSource dataSource) { if (dataSource instanceof DruidDataSource) { return new DruidDataSourcePoolMetadata((DruidDataSource) dataSource); } return null; } }; } } 我们发现 Druid 继承了 DataSourceProperties 的配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd2018dfc007787cf7e85a86b1793c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78a3bfde0c44f6493d3442dc7e8a70f/" rel="bookmark">
			NCBI数据下载的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一篇记录一下NCBI/Genbank数据库中批量下载数据的几种方法：
1、迅雷
将所有序列的下载链接整理在一起后在迅雷中创建下载，可以批量进行序列下载
注：不知道是电脑还是网络问题，有时候下载的超慢甚至连接不上
2、TBtools
首先准备好需要下载的序列号，将其放入一个text文件中
打开TBtools软件，点击Sequence Toolkit
点击Start，等待下载即可
3、利用Biopython下载
##一条一条地下载基因序列 from Bio import Entrez,SeqIO Entrez.email = "用户邮箱" ids='序列的ID号' hd_efetch_fa = Entrez.efetch(db='nucleotide', id=ids, rettype="fasta") read_efetch_fa = hd_efetch_fa.read() with open('保存数据的文件',"w") as file: file.write(read_efetch_fa) print(' finished!') ##批量下载序列，序列号存放在download.txt文件中，下载下来的序列分别写入以1为起始名的fasta文件中 from Bio import Entrez，SeqIO file_in_name="download.txt" Entrez.email = '你的邮箱' input_file=open(file_in_name,"r") i=0 for record_id in input_file:##一行一行读取序列的ID号 hd_efetch_fa = Entrez.efetch(db='nucleotide', id=record_id, rettype="fasta") read_efetch_fa = hd_efetch_fa.read() i=i+1 with open(str(i)+'.fasta'', "w") as file:##将下载的序列顺序存放在以i=1为起始名的文件中 file.write(read_efetch_fa) print('finished!')##每当一个序列下载完成就打印一次finished！ ok，静待后续继续补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211f52f6c5e59100b67143e1f2ac6bf4/" rel="bookmark">
			css超链接样式&#43;雪碧图实现导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CSS链接的四种状态【演示前清除浏览器记录】
1.1 a:link 普通的、未被访问的链接？？？
1.2 a:visited 用户已被访问的链接？？？
1.3 a:hover 鼠标指针位于链接的上方=====
1.4 a:active 链接被点击的时刻=====
二、Sprite雪碧图应用
【导航条图标的精确位置】
1.回顾上一页
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style type="text/css"&gt;#oDiv{width: 100px;height: 100px;background-color: red;/*定位*/position: absolute;top: -50px;left: -50px;visibility:}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 课前回顾：1.盒模型:divmargin 外边距左外边距 margin-leftpadding 内填充border 边框content2.HTML标签的分类行内|内联标签块状标签行内-块状3.css布局的属性position定位absolute 绝对定义relative 相对定义static 默认fiexd 固定z-index多个标签处于层叠效果，覆盖的问题。A 遮住 Bdisplayvisibilityoverflowfloat:浮动clear 清除浮动--&gt;&lt;div id="oDiv"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1.中间链接的样式使用 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; /*css设置超链接的样式（选择器）*/ #aa{ color: yellow; } /*未被访问的样式*/ #aa:link{ color: pink; } /*鼠标触碰*/ #aa:hover{ color: orange; } /*超链接被点击不放时所设置的样式*/ #aa:active{ color: green; background-color: red; } #aa:visited{ background-color: black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/211f52f6c5e59100b67143e1f2ac6bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75890e9f1fa15c0a72ab7aaed2df143e/" rel="bookmark">
			C 封装与抽象 面向对象编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装与抽象
封装性是面向对象编程的三大特性（封装性、继承性、多态性）之一，但也是最重要的特性。封装+抽象相结合就可以对外提供一个低耦合的模块。
数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。
在C语言中，数据封装可以从结构体入手，结构体里可以放数据成员和操作数据的函数指针成员。当然，结构体里也可以只包含着要操作的数据。
下面以一个简单的实例作为演示。
设计一个软件模块，模块中要操作的对象是长方形，需要对外提供的接口有：
1、创建长方形对象；
2、设置长、宽；
3、获取长方形面积；
4、打印长方形的信息（长、宽、高）；
5、删除长方形对象。
下面我们来一起完成这个demo代码。首先，我们思考一下，我们的接口命名大概是怎样的？其实这是有规律可循的，我们看RT-Thread的面向对象接口是怎么设计的
我们也模仿这样子的命名形式来给我们这个demo的几个接口命名：
1、shape_create
2、shape_set
3、shape_getArea
4、shape_display
5、shape_delete
我们建立一个rect.h的头文件，在这里声明我们对外提供的几个接口。这时候我们头文件可以设计为：
typedef struct _fun_ptr { int (*area)(void); }fun_ptr; typedef struct _Shape { char* object_name; int length; int width; fun_ptr fptr; }Shape, *pShape; /* 对象操作 */ HandleShape shape_create(const char* object_name); void shape_set(HandleShape shape, int length, int width); int shape_getArea(HandleShape shape); void shape_display(HandleShape shape); void shape_delete(HandleShape shape); 这样做是没有什么问题的。可是数据隐藏得不够好，我们提供给外部用的东西要尽量简单。
我们可以思考一下，对于C语言的文件操作，C语言库给我们提供怎么样的文件操作接口？如：
FILE *fopen(const char *pathname, const char *mode); size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 我们会创建一个文件句柄（描述符），然后之后只要操作这个文件句柄就可以，我们不用关心FILE具体是怎么实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75890e9f1fa15c0a72ab7aaed2df143e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245cb8af5ab32bd6b772a2d2035e20da/" rel="bookmark">
			NET Framework 3.5安装失败的终极解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.NET Framework 3.5 是微软的.NET框架程序的运行库，有很多软件需要NET 3.5 Framework才能运行，比如说AutoCAD、3DMAX等。NET 3.5 Framework可以到系统控制面板里面去开启，但是经常失败，这个方法只是比较快而已。使用条件：Windows系统正常，精简版系统或使用ghost镜像安装的系统很有可能安装失败。
这个方法理论上100%可以成功，然而世界上没有包治百病的药，后面有一些常见问题和安装失败处理方法。
一、安装方法 1.下载NET Framework 3.5安装工具包 链接:https://pan.baidu.com/s/1kSXX432P5yMQP-ZBpQlLZw
提取码:za65
2. 解压下载好的工具包 3. 将解压得到【sxs】文件夹复制到C盘根目录 把解压得到【sxs】文件夹复制到C盘根目录，直接拖进C盘也行。
4.右键&gt;以管理员身份运行【NET Framework 3.5.bat】 5. 等待安装完成 随后会显示启动一个或多功能，等待部署进度100%即可， 黑框会自动退出。
.NET Framework 3.5 安装
二、常见问题和处理方法 1. NET Framework 3.5 安装成功了没有 ? 1.1、 打开“我的电脑“（快捷键：Win+E）；
1.2、复制 %systemroot%\Microsoft.NET\Framework 到文件管理器地址栏 按键盘【Enter】键；
1.3、在列出来的文件夹中，如果看到v1.0.3705 v2.0.50727 v3.0 v3.5文件夹，说明安装成功，否则失败。
2.NET Framework 3.5安装失败处理方法 这个方法不保证一定安装成功， 就算是微软的方法也不一定安装成功， 世界上没有包治百病的药，下面有一些常见问题和安装失败处理方法， 请对症下药。
出现错误0x800F0906、0x800F081F、0x800F0907和其他错误—————点击查看微软官方说明
卡在5.9%或14.X%卡在其他位置？安装失败？
原因对策【sxs】文件夹没有复制到C盘根目录自己把【sxs】文件夹直接拖进C盘再操作Windows后台有更新没有完成重启电脑 更新并重启Windows更新被关闭开启windows自动更新没有管理员权限获取计算机管理员权限国内各类流氓管家、杀毒软件阻止暂时关闭杀毒软件或卸载杀毒软件注册表残留下载注册表清理工具清理注册表 【右键】-【以管理员身份运行】 三、最后的安装办法（终极万能法） 提供您的下载包里有个“方法2”，把里面的运行文件，右键管理员运行。等待安装完成。
到这里大部分的问题都可以迎刃而解了。如果终结万能办法还是不行，只有重装系统可以解决问题了，其他方法就不用再浪费时间了。祝好运！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bac0771b1c6aec45fa8e500d7600ebb/" rel="bookmark">
			mysql 查询表 所有字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复制表结构
CREATE TABLE tb_students_copy LIKE tb_students_info; 查询mysql所有表数据、字段信息
mysql 查询表 所有字段
前2种有重复
select COLUMN_NAME,column_comment from information_schema.COLUMNS where table_name = 'db_car_apply' -- 查询表字段 select COLUMN_NAME from information_schema.COLUMNS where table_name = '表名' and table_schema = '数据库名'; -- 查询所有字段, 含约束 SHOW FULL COLUMNS FROM 表名 MySQL中的备份和恢复 加了–single-transaction就能保证innodb的数据是完全一致的，而myisam引擎无法保证，必须加–lock-all-tables
–single-transaction参数的作用，设置事务的隔离级别为可重复读，即REPEATABLE READ，这样能保证在一个事务中所有相同的查询读取到同样的数据，也就大概保证了在dump期间，如果其他innodb引擎的线程修改了表的数据并提交，对该dump线程的数据并无影响
深入理解mysqldump原理 --single-transaction --lock-all-tables --master-data
以下命令不支持powershell(idea系列控制台也是), 支持cmd
备份所有数据库 mysqldump -uroot -p --all-database &gt; all.sql mysqldump -h localhost -P3306 -uroot -p123456 --single-transaction data docid &gt; F:\docid.sql mysqlcmd = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bac0771b1c6aec45fa8e500d7600ebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96959878886ceb4e3405eaa8bc50fd9/" rel="bookmark">
			2020年网络安全国赛解析（仅个人想法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A-1任务一登录安全加固 请对服务器Log、Web、Data 按要求进行相应的设置，提高服务器的安全性。
1.密码策略（Log,Web,Data）
a. 最小密码长度不少于8个字符;
windows:
打开本地安全策略 (开始菜单/管理工具(管理)/本地安全策略)在账户策略/密码策略中将密码长度最小值修改为8 Linux:
找到配置文件/etc/pam.d/system-auth配置文件在配置文件中找到password requisite pam_cracklib.so try first_pass retry=3 type= 所在行在该行末尾空一格追加minlen=8 (注意这里不换行) b. 密码策略必须同时满足大小写字母、数字、特殊字符。
Windows:
打开本地安全策略 (开始菜单/管理工具(管理)/本地安全策略)在账户策略/密码策略中将密码必须符合复杂性要求修改为已启用 Linux:
找到配置文件/etc/pam.d/system-auth配置文件在配置文件中找到password requisite pam_cracklib.so try first_pass retry=3 type= 所在行在该行末尾空一格追加dcredit=-1 ucredit=-1 lcredit=-1 ocredit=-1 2. 登录策略（Log,Web,Data）
a.在用户登录系统时，应该有“For authorized users only”提示信息;
Windows:
打开本地安全策略 (开始菜单/管理工具(管理)/本地安全策略)在本地策略/安全选项中将交互式登录:视图登录的用户的消息标题修改为For authorized users only.在本地策略/安全选项中将交互式登录:视图登录的用户的消息文本修改为For authorized users only. Linux:
将以下三个配置文件的内容都修改为For authorized users only /etc/issue
/etc/issue.net
/etc/motd
在/etc/ssh/sshd_config中将Banner的注释去掉,修改为以下内容 Banner /etc/issue
重启sshd服务. b.一分钟内仅允许5次登录失败的尝试，超过5次，登录帐号锁定1分钟；
Windows:
打开本地安全策略; (开始菜单/管理工具(管理)/本地安全策略)在账户策略/账户锁定策略中将账户锁定时间修改为1分钟;在账户策略/账户锁定策略中将账户锁定阈值修改为5次;在账户策略/账户锁定策略中将重置账户锁定计数器修改为1分钟;在本地策略/安全选项中将交互式登录:需要域控制器身份验证以对工作站进行解锁修改为已启用. Linux:
在/etc/pam.d/system-auth配置文件第二行后追加一行添加以下内容: auth required pam_tally2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e96959878886ceb4e3405eaa8bc50fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc3b41c6077b72d052ac667450589ba/" rel="bookmark">
			React使用TypeScript和Less
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React使用TypeScript和less 创建应用 yarn create react-app react-ts --template typescript 创建好了之后需要使用less，则需要噢诶之less（使用craco）
yarn add @craco/craco
然后安装craco-less
yarn add craco less
然后在package.json中修改命令
"start": "craco start", "build": "craco build", "test": "craco test",** 然后创建craco.config.js文件
const CracoLessPlugin = require("craco-less"); module.exports = { plugins: [ { plugin: CracoLessPlugin, options: { lessLoaderOptions: { lessOptions: { modifyVars: {}, javascriptEnabled: true, }, }, }, }, ], webpack: { // 这里面是webpack的配置 }, }; 这样就完成了关于less的使用配置和TypeScript的使用配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93ffa2985f505a258ee883bae47e81c/" rel="bookmark">
			winfrom中Oracle.DataAccess.dll使用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Oracle.DataAccess.Client.OracleConnection”的类型初始值设定项引发异常
​​​​​​​winform网上资源太少了。
1、经过严格的测试，使用Oracle.DataAccess.dll时，Oracle.DataAccess.dll为64位，Oracle.Dataaccess.dll位32位，两个dll区分就是64位A大写，32位a小写。
2、以oracle11g为例：
64位Oracle.DataAccess.dll一般在oracle安装目录下(服务端)
盘符:\app\Administrator\product\11.2.0\dbhome_1\ODP.NET\bin\2.x
32位Oracle.DataAccess.dll一般在oracle安装目录下(客户端)
​​​​​​​盘符:\app\Administrator\product\11.2.0\client_1\ODP.NET\bin\2.x
使用64或32一定要与生成中平台目标一致，也就是说使用64dll那么生成平台也要是64位，反之则是32位，还有需要注意的是在使用dll的客户机上一定要有oracle客户端，服务端不行。
对你如果有帮助，请点赞。回复有用谢谢。哈哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac0081dae15b810a5af287b618fdae8b/" rel="bookmark">
			软件研发效能的底层逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创 Test Ninja 软件质量报道 2021-12-24 07:48 最近两年软件研发效能很热，这也促使我去年发起了 全球软件质量&amp;效能大会（QECon）但凡某件事太热，就很容易走火入魔，更多人被带入误区，有点像当初Agile、DevOps一样，把所有好东西都往自己篮中装，想包罗万象、想一网打尽 …… 其实，许多优秀的实践早已存在，不管Agile/DevOps在与不在。当初IBM RUP也想一统天下，如今安在？
整整20年过去了，多少Scrum敏捷教练前赴后继，但Scrum敏捷开发模式在国内实施的效果如何？其实，效果一般。根据去年 和今年 的调查数据，至今天真正实施Scrum敏捷开发模式的组织只有28%左右，这其中估计还有一些是伪敏捷。
在软件研发效能没走火入魔之前，我觉得有必要和大家谈一谈 软件研发效能的底层逻辑，拨开云雾，看清软件研发效能的本质，澄清软件研发效能的是是非非，有利于提升软件研发效能，有利于软件研发团队做好明年或未来的研发计划。
之前写了 软件测试的底层逻辑 和 软件质量管理的底层逻辑 ，今天所写的软件研发效能的底层逻辑，就作为底层逻辑三部曲的最后一篇，算是2021年的收官之作，可能会比较犀利些，不妥之言，望多多包涵。欢迎留言参与讨论。
1. 究竟什么是研发效能？
维基百科给效能（efficacy）的定义是：事物产生功效的能力，常用于通识教育、医学和药理学，可以忽略。然后看百度百科的定义，基本靠谱：效能是指有效的、集体的效应，即人们在有目的、有组织的活动中所表现出来的效率和效果，它反映了所开展活动目标选择的正确性及其实现的程度。
普华永道给出“组织效能关注组织效率、竞争力和员工贡献度”，谷歌（Google）的GSM（Goals-Signals-Metrics）框架，关注目标的达成，并转化为研发效能五个核心元素：代码质量、工程师注意力、智力复杂性、速度与速率、满意度。
其实在我之前写的一篇文章已讨论过，但还是要在这里澄清一下，这也是我们后面讨论的基础。概念不同，相互争辩就没有意义。研发效能（R&amp;D Effectiveness）是指研发团队对业务有实际价值的产出，如果需要加上限制，可以说效能是单位时间内研发团队对业务有实际价值的人均产出，而效率关注速度、生产力，而缺乏关注目标选择的正确性、输出价值。
如果考虑到商业环境变化比较快，还需要考虑研发是否有能力适应环境的变化、是否能与时俱进，保持稳定的、有价值的交付，即我们经常所说的可持续性发展或进步。这和研发效能有关系，但其实是另一个问题，只是影响研发效能的一个重要因素。
研发效能强调效率和效果、正确性、竞争力以及对企业效益的贡献，我们非常关注研发效能，也就毋庸置疑。
2. 研发效能如何落地？
这就需要讨论研发效能的底层逻辑，那么底层逻辑是什么呢？
回到前面的定义，就是要有更高的产出，且产出的价值越高越好，在保证目标正确的情况下产出的速度、效率越快越好；可以通过内建质量（如降低复杂度、提升代码质量）、让员工保持高度的注意力等不断提升效率......这样我们就可以归纳出研发效能的底层逻辑就是：做正确的事，然后正确地做事，再追求速度。但这三层逻辑都依赖于人，人是决定的因素。所以研发效能的底层逻辑第一条是选对人、好好培养人。
基于这样的逻辑，研发效能的落地可分为四个层次：
选对人、好好培养人，如审视公司的招聘流程、培训和绩效考核制度；
做正确的事，如澄清业务战略，明确问题、业务需求和用户需求；
正确地做事：如确定/选择正确的开发模式，制定有效的组织结构和流程；
追求速度/效率，如不断提高研发人员的技能，开发/购买 研发平台，搭建DevOps工具链，实现高度的自动化（包括构建、部署、测试、运维）。
这里虽然比 “大象装进冰箱” 多了一项，但还好，大家还是比较容易记得住，容易实施。比我最近批评的一本书《软件开发的201个原则》要好得多，正如网友说，原则太多，就没有原则。打开书，其中有些原则真不像话，如：
原则4 高质量软件是可以实现的（我们早就知道，但现在不想，代价太高）
原则8 与客户/用户沟通（哪个团队不去和客户/用户沟通？一个动作不适合原则，原则要有明确的态度，告诉我们要做什么、不做什么，如必须和客户/用户沟通面对面沟通、每天和客户/用户保持沟通）
原则34 软件文档都要有索引（不一定，今天有全文搜索功能，或者 画一个思维导图，只要有关键字，但不是索引）
原则44 确定子集 ......
3. 研发效能底层逻辑第1层：解决人的问题
仅仅写人是决定的因素，大家印象还不深刻，甚至还不同意这点，我还不得不说：需求是人挖掘出来的，设计也是人做的，代码也是人写的，测试也是人干的..... 流程也是人制定的、还需要人去执行，工具也需要人去开发和使用，总监、经理也都是人......此时你该认可：研发效能底层逻辑第1层是解决人的问题，对吧？
昨天听一个线上讨论研发效能的直播节目，有两点很深刻：
听众急着要度量指标，想了解如何度量效能；
一位嘉宾说，有的公司把员工不当人看、当成工具。
第1点留到后面去讨论，首先讨论第2点：把员工不当人看、当成工具，要求员工听话，遵守流程、遵守工作纪律，员工只会干活，缺乏思考，没有创新、发展的空间。其次，招聘流程过于粗暴简单、入职培训缺失、绩效考核唯KPI指标..... 等等，没有把 “招对人” 、“培养人” 放在第一位。
要招对人，这点可以学学亚马逊，之前文章 亚马逊QA/测试工程师面试究竟考察应聘者哪些能力？有详细介绍，招一个人要经过5～6个环节（不算多），其中有一个环节比较特别，就是设置Bar raiser。Bar raisers是一群在各个岗位都是精英的评估人，对应聘者录用与否拥有表决权，保证亚马逊能招聘到优秀人才。国内公司流行谁用人，谁最后面试、谁最后决定，这很容易让一些不合格的人进入公司/团队，因为用人部门一般是缺人才招人，常常会因为任务急着有人去干，就放松标准、降低要求，让不合格的人进入自己的团队。甚至有些团队Lead怕比自己更厉害的人进来抢走自己的位置，招进的人的水平都会比他/她低。
良好的组织文化的培养、人员技能的培养（包括人才规划、培训体系建立、课程设置，虽然70%是在工作中学）等等 要紧抓不放，时刻不松懈，微软的愿景之一：帮助员工发挥最大潜能，微软有一套很好的胜任力建设和评估体系，见下面插图，之前在某人才培养峰会上，我曾详细介绍过。由于篇幅所限，以后有机会再谈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac0081dae15b810a5af287b618fdae8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd1be0d9d0a8302381c9a4184408599/" rel="bookmark">
			Git项目自动更新Git版本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的目标是，从git仓库pull之后，在生成项目时可以自动更新git版本信息。但是目前存在尚未解决的问题，在push项目之后仓库中保存的git版本信息仍然是上一个版本。该问题留作后续研究，问题流程如下图所示：
注意：下面所有文件都必须放在项目目录下，而不能放在解决方案目录下，否则执行sh文件时无法找到version文件（对sh文件不太了解，不知道为什么）
一、version.h文件
定义保存了版本信息的头文件，保存了（1）git版本号（2）最近一次提交时间（3）最近一次编译时间（即当前时间），此处我们定义为：
#ifndef GIT_VERSION #define GIT_VERSION "f384194" #define COMMIT_TIME "2022-01-04 15:58:24" #define BUILD_TIME "2022-01-04 15:59:45" #endif 为了生成该格式的头文件，我们定义模板文件version.h.tmp，通过替换字符完成版本信息的更新
#ifndef GIT_VERSION #define GIT_VERSION "MYVERSION" #define COMMIT_TIME "MYCOMMITTIME" #define BUILD_TIME "MYBUILDTIME" #endif 二、sh文件
创建sh文件，计算三个版本信息，通过sed命令将指定字符替换为计算出的版本信息，VersionUpdate.sh文件内容如下：
#!/bin/sh commit_ts=`git log -1 --format="%ct"` commit_time=`date -d@$commit_ts +"%Y-%m-%d %H:%M:%S"` current_time=`date +"%Y-%m-%d %H:%M:%S"` git_version=`git log -1 --pretty=format:"%h"` sed s/MYVERSION/"${git_version}"/g version.h.tmp&gt;version.h sed -i s/MYCOMMITTIME/"${commit_time}"/g version.h sed -i s/MYBUILDTIME/"${current_time}"/g version.h 三、VS生成事件
打开 项目属性》》生成事件 可以看到三类事件：生成前事件、链接前事件、生成后事件。我们此处以链接前事件为例。其语法与cmd命令行类似，我们添加命令行"VersionUpdate.sh"。
四、生成项目
点击生成项目，没有显示错误（可以在sh文件中添加echo命令进行测试），查看version.h文件，更新成功，如下：
#ifndef GIT_VERSION #define GIT_VERSION "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebd1be0d9d0a8302381c9a4184408599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce85ab4f2c7ce7cd501a73fe59e3770/" rel="bookmark">
			OCC通过点反求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过GeomLib_Tool中的接口完成功能
接口使用：
//根据点反求参数 //以求平面上的点对应的参数为例 Handle(Geom_Plane) pln = new Geom_Plane(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1)); gp_Pnt p(1, 2, 0); float maxDistance = Precision::Confusion(); Standard_Real u = 0; Standard_Real v = 0; GeomLib_Tool parameterTool; bool isOnSurface = parameterTool.Parameters(pln, p, maxDistance, u, v); if (isOnSurface) { cout &lt;&lt; "点在曲面上对应的参数为(" &lt;&lt; u &lt;&lt; "，" &lt;&lt; v &lt;&lt; ")" &lt;&lt; endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc4ff1d74577ccc7e0fc83f2b504b664/" rel="bookmark">
			OCC几何求交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OCC求交工具：
（1）二维曲线求交：Geom2dAPI_InterCurveCurve
（2）三维曲线与曲面求交：GeomAPI_IntCS
（3）三维曲面与曲面求交：GeomAPI_IntSS
（4）三维曲线求交：（这里有点不太懂）通过GeomAPI_ExtremaCurveCurve用于两条曲线求机制，可用于三维曲线的求交
接口使用：
//求交 //以二维曲线求交为例 Handle(Geom2d_Line) l1 = new Geom2d_Line(gp_Pnt2d(0, 0), gp_Dir2d(1, 0)); Handle(Geom2d_Circle) l2 = new Geom2d_Circle(gp_Ax2d(gp_Pnt2d(0, 0), gp_Dir2d(0, 1)),5.0); Geom2dAPI_InterCurveCurve intersector(l1, l2, Precision::Confusion()); for (int i = 1; i &lt;= intersector.NbPoints(); i++) { gp_Pnt2d interPoint = intersector.Point(i); cout &lt;&lt; "交点" &lt;&lt; i &lt;&lt; "为：(" &lt;&lt; interPoint.X() &lt;&lt; "，" &lt;&lt; interPoint.Y() &lt;&lt; ")" &lt;&lt; endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0990adef4d404c738cb073da1757b85b/" rel="bookmark">
			字符串与数字转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符串转数字 1）使用stringstream 添加头文件 #include&lt;sstream&gt;
stringstream s；
string str；
int a;
ss&lt;&lt;str;
ss&gt;&gt;a;
[1] stringstream可以多个字符串拼接，所以多次转换需要使用clear清空。
2）使用atoi()与stoi() 这两个都是C++的字符处理函数，把数字字符串转换成int输出，而且头文件都是#include&lt;cstring&gt;
atoi()
atoi()的参数是 const char* ,对于一个字符串str需要调用 c_str()把这个string转换成 const char* 类型的,
atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界。
stoi()
stoi()的参数是const string&amp;, 不需要转化为 const char*。
stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会报错。
另：当输入的字符串不是整形，且前半部分都是数字时，stoi()与atoi()都会取前面为整形的部分。如string str = "1.2";时，两者输出值为1。
当输入的字符串不是整形，且前半部分不是数字时，stoi()会报错，但atoi()会输出0。
3）sscanf() char str[]="123"; int a; sscanf(str,"%d",&amp;a); cout&lt;&lt;a&lt;&lt;endl;
char str1[]="1.1"; double b; sscanf(str1,"%lf",&amp;b); cout&lt;&lt;b&lt;&lt;endl;
不过在VS中使用会告诉你不安全要转换成sscanf_s()
2.数字转字符串 1）使用stringstream 类似于字符串转数字
添加头文件 #include&lt;sstream&gt;
stringstream s；
string str；
int a;
ss&lt;&lt;a;
ss&gt;&gt;str;
[1] stringstream可以多个字符串拼接，所以多次转换需要使用clear清空。
2）sprintf() char str[10]; int a=123; sprintf(str,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0990adef4d404c738cb073da1757b85b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64883463b4bbce47915d3ca212c888c5/" rel="bookmark">
			Java NIO ServerSocketChannel与SocketChannel区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ServerSocketChannel详解 SocketChannel详解 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71acc53bfc334414f570799e245d8d10/" rel="bookmark">
			java 类加载器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发过程中经常会遇到java.lang.ClassNotFoundExcetpion的异常，为何会有这个异常呢？因为你想要使用的类并未加载到虚拟机当中。本文将介绍java的类加载器，让你了解一个class文件加载到虚拟机中的机制，并介绍了如何自定义类加载器。结合代码验证理论。
JVM预定义的三种类加载器 JVM预定义了三种类加载器，分别是：
启动类加载器（BootStrap）扩展类加载器（Extension）系统类加载器（System） 启动类加载器 启动类加载器是使用本地代码实现的，类似于我们看源码时的native方法，找不到具体的class。它负载将JAVA_HOME/lib下的核心类库或-Xbootclasspath选项指定的路径下的jar加载到虚拟机当中。
System.getProperty(“sun.boot.class.path”)参数可以查看该类加载器加载的路径。
因为没有具体的class，所以没法看类图。
扩展类加载器 扩展类加载器是sun.misc.Launcher$ExtClassLoader。它负责将JAVA_HOME /lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。
System.getProperty(“java.ext.dirs”)参数可以查看该类加载器加载的路径。
类图如下：
它是sun.misc.Launcher的内部类。
系统类加载器 系统类加载器是sun.misc.Launcher$AppClassLoader。它负责将用户类路径(java -classpath或-Djava.class.path变量所指的目录，即当前类所在路径及其引用的第三方类库的路径下的类库加载到内存中。开发者可以直接使用系统类加载器。
System.getProperty(“java.class.path”)可查看该类加载器加载的路径。
类图如下：
与扩展类加载器一样，它也是sun.misc.Launcher的内部类。
三种类加载的文件路径测试代码 下面的代码分别打印了三种类加载器加载了哪些路径的jar包，验证上面的介绍
package ClassLoader; /** * @author ludengke * @title: ClassLoader.TestClassLoader * @projectName springcloud-demo * @description: TODO * @date 2021/12/2615:15 */ public class TestClassLoader { public static void main(String[] args) { bootStrapClassLoader(); extClassLoader(); appClassLoader(); // testClassLoader(); } /** * 测试TestBean被哪个类加载器加载的，这个加载器加载的路径是啥 */ // private static void testClassLoader(){ // try { // //查看当前系统类路径中包含的路径条目 // System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71acc53bfc334414f570799e245d8d10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca099a85800e7e1c06d0d66082add3a/" rel="bookmark">
			004. 虚拟机常见配置：网络-防火墙-软件安装限制-关机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章预览： 本文讲解虚拟机的常见配置一、网络二、防火墙三、软件安装限制四、关机方式 本文讲解虚拟机的常见配置 包含：网络、防火墙、软件安装限制、关机方式。 一、网络 查看自己的虚拟网卡地址
步骤：编辑 — 虚拟机网络编辑器 — vmnet8 — NAT设置
在命令行执行指令：
vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改以下参数：
修改完成后，Esc + :wq 保存退出。
测试配置是否成功；依次执行下列命令。
1 ip addr 2 systemctl restart network.service 3 ping www.baidu.com 4 ctrl+c 若连接成功，则表示网络配置成功。
二、防火墙 功能：
保护本机的端口，以防被恶意访问。
如果某个端口需要被外界访问，需要在防火墙中放行。
相关指令：
//查看防火墙状态 systemctl status firewalld //本次服务内关闭防火墙 systemctl stop firewalld //重启虚拟机后禁用防火墙 systemctl disable firewalld //启动防火墙 systemctl start firewalld 三、软件安装限制 虚拟机的OS，对未知来源的软件的安装,有可能会拒绝|警告，我们可以禁止这个功能。
依次执行图示指令，进入指定目录，修改指定文件。
cd /etc/selinux vi config 修改属性：SELINUX=disabled Esc + ：wq 四、关机方式 //相当于直接拔掉电源 halt -p Centos6版本中为 halt //直接关闭机器，但是有可能当前虚拟机其他人在使用 poweroff //马上关闭计算机 ，但是可以给其他用户发送消息(推荐) shutdown -h now //重启虚拟机 reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d4b39759d7c7fb276c7a28d09e451d/" rel="bookmark">
			在sagemaker studio lab中使用from .cv2 import* 报错ImportError: libgthread-2.0.so.0: cannot open shared……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用sagemaker studio lab时，由于无法使用sudo，yum，apt-get（权限问题，笔者水平有限，并没有找到解决的方法）。
因此使用以下的命令解决问题，直接在自己的jupyter笔记本中运行命令即可，笔者亲测有效
问题如下： 解决方法如下： 直接在自己的jupyter笔记本中运行
! conda install glib=2.51.0 -y 或者
! conda create -n glib-test -c defaults -c conda-forge python=3 glib=2.51.0` -y 有可能会使用到albumentations，使用以下命令安装即可。
! pip install albumentations 水平有限，如有误，请尽管批评指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0b8e18a6cf3fbe7dd858d097d9d7df/" rel="bookmark">
			python的期末考核——学生管理系统（5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 通过前四篇的介绍，该学生管理系统的主架构已经搭建完毕，本篇文章主要是整体的介绍一下，该学生管理系统个个功能是如何实现并且如何搭建在一起的，以及运行该程序之前需要做哪些准备。同时，展示一下运行成果。
学生管理系统的架构 本次介绍学生管理系统的整体内容，首先应该定义那些函数，以及需要引入那些包，并且如何运行。
由于需要引入磁盘文件，因此首先需要通过import os 导入os包 定义一个学生信息文件，用来保存学生信息 定义主函数，以及各类功能性函数 通过主程序来运行函数 通过前面四篇文章的介绍，个个函数的功能以及代码都已经展示，在这里就不一一展示了，需要的同学可以去寻找，并且文章末尾会把另外四篇文章的链接展示，需要的同学可以自取。
测试运行成果 第一步测试开始运行界面展示： 第二步测试录入学生信息： 第三步测试查找学生信息： 第四步测试修改学生信息： 第五步测试显示所有学生信息： 第六步测试统计学生总人数： 第七步测试排序功能： 第八步测试删除学生信息： 学生管理系统链接： 学生管理系统（1）简介 学生管理系统（2） 学生管理系统（3） 学生管理系统（4） 寄语 历时五天，将学生管理系统更新完毕。本系统适合初学python语言的童鞋进行对自己能力掌握情况进行测试，代码简单易懂，如果有疑问的小可爱，可以在评论区留言，若评论区解决不了，可以加微信或者QQ。在这里诚邀广大网友，可以相互了解探讨，一起进步，希望大家可以给小落叶一点鼓励。下面，考虑更新贝叶斯网络的知识，有需要的朋友可以点赞关注一波，大家一起探讨研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3972f4e0f718ef358eed6c0483224357/" rel="bookmark">
			【论文学习】Adversarial Examples on Graph Data: Deep Insights into Attack and Defense论文学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 类似GCN这样的图深度学习模型近几年咋一些图数据任务上取得了很好的效果。与其他的深度学习模型类似，图深度学习模型通常也会遭受到对抗攻击。但是，跟非图数据相比，图数据中的离散特征，图连接以及对于扰动的不可感知的不同定义给图对抗攻击带来了许多挑战。在这篇文章中，作者提出了攻击和防御的方法。在攻击的时候，作者发现图数据的这些离散特性可以通过引入积分梯度来解决。这个积分梯度可以反映出对图中的某一条边或者某一个特征做干扰带来的影响（注意，这里的特征也必须是离散的）。在做防御的时候，作者发现通过对抗攻击得到的图跟正常的图在数据上不同的。基于这种观察，作者提出了一个防御方案，可以对图做检查，并且恢复潜在的对抗扰动。作者使用了好几个数据集证明了自己的方法的有效性。
Introduction 图被广泛用用于许多现实关系任务中，诸如社交网络，引文网络，交易网络以及控制流任务。在图数据中最广泛的一个任务是结点分类任务：对于一个图，已知其中一部分结点的标签，目的是对于其他未标注结点做预测。该任务可以应用在许多任务中，例如对于引文网络中论文的主题做预测，对推荐系统中的消费者的类型做预测。
深度学习方法因为缺乏鲁棒性而一直被大家所讨论。这些图神经网络模型在被实施了对抗攻击的时候表现出来的脆弱性使得它很难被应用在一些safety-critical场景中。在图神经网络中，结点可以是社交网络中的一个用户，也可以是一个商业网站。一个恶意用户可以修改自己的profile或者是跟目标用户之间建立联系从而误导系统的分类。同样的，通过对特定的商品添加虚假评论也可以欺骗到推荐系统。
不能将已有的非图数据中的对抗攻击方法应用在图神经网络中，原因在于图数据的输入是离散的。具体而言，图结点的特征通常都是离散的；图数据中的边，尤其是非权重图中的边通常也都是离散的。为了解决这个问题，许多人提出了贪婪算法来攻击图深度学习系统（Nettack）。贪婪算法是不断的迭代，来扰动特征或者边。在这篇文章中，作者指出来，就算是离散数据，也可以通过引入积分梯度来计算它的梯度。积分梯度（Integrated gradient）第一次被提出来是用于解决Shapely value，将部分梯度（partial gradient）和输入特征联系到一起。相比较贪婪选择算法，积分梯度可以大大提高结点选择和边选择的效率。
跟对抗攻击相比，在图模型上对于对抗攻击的防御还没有怎么被研究。在这篇文章中，作者指出来，图神经网络模型之所以有脆弱性，是因为这些模型是基于图结构，来不断的聚合结点周围的其他节点的特征。也就是说，在对某个结点做预测的时候，模型会依赖于周围最邻近结点的特征。作者在对现有的攻击产生的扰动做分析的时候，发现，将一个结点周围的特征不同的其他结点与当前结点建立连边会带来很大的影响。在这篇文章中，作者发现，只要对一个图的邻接矩阵做预处理就可以确定这类边。对于拥有词袋特征（BOW，bag-of-words）的结点而言，Jaccard系数可以有效的衡量结点之间的相似性。通过把不相似的两个结点之间的连边去除，可以有效的防御住有目标的对抗攻击，并且可以保证GCN模型上的准确率不会下降。作者通过使用许多真实世界的数据集，发现提出的攻击和防御是十分有效的。
Preliminaries（基本定义） 1）图卷积网络（GCN） GCN是在半监督结点分类领域被广泛使用的方法。
GCN通常使用如下公式对于邻居节点的特征做聚合（其中的D代表的是对角阵）：
一个2层的GCN就可以很好的解决半监督结点分类任务了。这个模型可以被描述如下：
其中的A是一个对称矩阵，如下所示，其中的D是对角阵。
2）基于梯度的对抗攻击 梯度被广泛使用来攻击深度学习模型。攻击者可以使用损失函数的梯度或者是模型的梯度来实施攻击。有两个典型的例子就是FGSM和JSMA攻击。FGSM是朝着损失函数的梯度方向做梯度上升。这个生成扰动的过程可以描述如下：
JSMA攻击是利用DNN模型的前向偏差（forward derivative）。给定一个前向推理的神经网络F和样本X，计算Jacabian的过程如下所示：
如果攻击者的目标是使得结点被分类成t类别，那就应该使得 F t ( x ) F_t(x) Ft​(x)上升，使得 F j ( x ) F_j(x) Fj​(x)下降。JSMA的对抗显著图可以定义如下：
已知一个正常的样本，攻击者可以得到显著图（saliency map）并且每次以一个很小扰动迭代的生成扰动，直到目标节点的标签被翻转。对于无目标攻击而言，攻击者的目的是最小化真实标签类别的预测分数。
3）对抗攻击的防御 尽管图上的对抗攻击是一个相对很新的问题，已经有一些工作研究对于卷积神经网络的对抗攻击。对于图像而言，由于特征空间是连续的，使用一点点扰动就可以实现对抗攻击。因此，在很多情况下，对图像添加一些随机化操作就可以防御住攻击。其他对于输入的预处理方法，诸如本地平滑（local smoothing）以及图像压缩都可以用于防御住攻击。这些预处理方法基于的前提假设是，一个像素周围的其他像素应该是相似的。也可以使用对抗训练来增强模型的鲁棒性。
基于积分梯度的攻击 尽管FGSM和JSMA并不是最复杂的攻击方法，它们也没有被很好的应用在图问题中。对于图像数据而言，FGSM和JSMA的成功源于特征在像素空间上的连续性。但是最近的研究表明，这些方法直接应用在图领域不能带来很好的攻击效果。就有一些研究者使用贪婪算法或者是强化学习方法来解决图数据这类离散数据，但是贪婪算法和强化学习通常都是很昂贵并且费时的。
图中的结点特征通常都是词袋类型的数据，也就是要么是0，要么是1。不带权重的边也通常是离散的，要么是0，要么是1。使用Vanilla FGSM和JSMA的问题在于梯度是不准确的。给定一个目标节点t，对于FGSM攻击而言，
可以衡量节点中每个特征针对于损失函数的重要性。对于结点n的特定特征i而言，这个梯度越大说明将这个特征修改为1就会带来比较大的影响。但是如果这样这样做就会带来两个问题：（1）特征值可能本来就是1，那就不能再对它做修改了。（2）就算特征本来就是0，GCN模型可能学不到0和1的线性函数，所以这个扰动是不可预测的。JSMA同样会有这样的问题。换句话说，vinilla梯度会有本地梯度问题（local gradient）。以一个简单的RELU为例，当x从0增加到1的时候，Relu的值也从0增加到1。但是在x=0的时候计算梯度还是0，所以无法准确的捕捉到模型的行为。为了解决这个问题，作者提出了积分梯度，而不是直接使用攻击的vanilla偏差。积分梯度在2017年的时候被提出来，可以获得特征属性的偏差。
积分梯度的定义如下：
给定一个模型F，x’是一个baseline input（基准输入），x是真实的输入。考虑从x’到输入x之间的一条直线路径，积分梯度就是对这条路径上的所有梯度进行累加。例如，对于输入x的第i个特征而言，积分梯度IG可以定义如下：
如果是有目标攻击，就是应该要最大化F值，所以当图中的特征或者边是1时，可以选择有最低的负值IG分数的特征或者边，将其修改成0。如果是无目标攻击，就是应该要最小化真实标签的预测分数，所以需要选择有最高IG分数的维度，将其修改成0。 （这里没有理解，可以看看原文）
但是不像图像一样，我们可以将一个全黑的图像（black image）设置成baseline input。作者使用了一个全0或者是全1的特征/邻接矩阵来表示1-&gt;0的扰动或者是0-&gt;1的扰动。当去除一条特定边或者是将一个特定的特征从1改成0后，作者是将邻接矩阵A和特征矩阵X设置成全0，然后逐渐的在当前全0的矩阵上添加边或者特征，然后观察F的整体变化。相反的，当添加一条特定边或者将一个特定的特征从0改成1后，首先将A和X都设置成全1，然后逐渐的移除某条边或者某个特征，然后观察F的整体变化。对于边攻击（edge attack）的IG分数计算如下所示：
算法1展示了无目标的IG-JSMA的伪代码。
可以看到，对于无目标攻击而言，要做的是选择IG最大的边或者特征。
图对抗攻击的防御 为了防御GCN上的对抗攻击，作者首先提出一个假设，那就是，GCN模型之所以很容易被攻击，是因为它极强的依赖于图结构和邻居节点特征的聚合。在被攻击图上训练得到的模型就容易受到这个攻击边界的影响。目前公认的一点是，在一个模型上训练得到的对抗样本可以迁移到其他模型中。目前对于GCN模型的对抗攻击是很成功的，原因在于这些被攻击的图可以直接被用于训练一个新模型。基于这种攻击方式，一个可行的防御方法是让邻接矩阵变得可训练（trainable）。
作者之后开始验证这种防御方法，也就是使得边权重在GCN模型中变得可训练。在没有添加任何防御方法的时候，在被攻击后，目标节点以0.998的置信度被误分类。作者的防御方法是首先对于边的权重做初始化，不修改其他东西，然后再对GCN模型做训练。作者发现，这样的一个简单的防御方法就可以使得目标节点以高置信度0.912被正确分类。为了解释为什么这个防御方法奏效，作者观察了攻击的特点。首先，对边做扰动比直接修改特征要更有效。 在现有的所有攻击方法（FGSM，JSMA和IG-JSMA）中，这一点都是奏效的。只对特征做干扰是很难修改目标节点的预测结果的。而且，很多攻击方法都是倾向于添加边而不是删除边，这样带来的攻击效果要更好。 第二，有着更多邻居节点的结点更难被攻击。这是在之前的工作中就被提到过的。之前就有学者发现，有着更高degree的结点在干净图和攻击图中都有着更好的分类准确率。最后，在攻击的时候，倾向于将目标节点和有着不同特征feature或者不同标签label的结点之间建立连接。在发现了这一点之后，可以借用这点特性来实施攻击。作者使用了CORA-ML数据集来验证这些假设。为了评估结点之间的特征的相似性，作者使用了Jaccard相似性分数，因为CORA-ML数据集中的结点特征是0/1离散的，bag-of-word词袋特征。但是对于那些其他类型的特征，诸如数字特征，作者使用了其他的相似性度量方式。
对于binary离散特征，作者使用了如下的相似性计算公式：
其中的 M 11 M_{11} M11​表示结点u中特征为1，结点v中特征也为1; M 10 M_{10} M10​表示结点u中特征为1，结点v中特征为0； M 01 M_{01} M01​表示结点u中特征为0，结点v中特征为1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3972f4e0f718ef358eed6c0483224357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685243b674dcedd4ff868a81b201c79e/" rel="bookmark">
			Open-Vocabulary Object Detection Using Captions(2021 CVPR)----论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Open-Vocabulary Object Detection Using Captions[2021CVPR]----论文解读 papercode1. AbstractOpen-Vocabulary Object Detection Using Captions 2. Introduction设想与构思思路与做法OVD、ZSD、 WSD的区别？ 3. Related WorkZSDWSDObject detection using mixed supervision运用的两种技术Visual grounding of referring expressionsVision-language transformers总结 3. Method3.1. Learning a visual-semantic space问题： zero-shot 过拟合解决image-caption 预训练loss 3.2. Learning open-vocabulary detection experiment参考blog paper code https://github.com/alirezazareian/ovr-cnn
1. Abstract 目标检测现存的问题? 学习更多的对象类别通常需要更多的边框注释。
比如：目标检测从600类扩展到60,000类需要100倍的资源
解决方法 Weakly supervised and zero-shot learning
缺陷: 将目标检测器扩展到更少监督的类别，但它们还没有像监督模型那样成功和广泛采用。
Open-Vocabulary Object Detection Using Captions 新的训练方法:
1.bounding box 注释有限的目标种类集（基类）,
2.image-caption pairs (图像-标题对) 集（基类+可能包含部分新类）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685243b674dcedd4ff868a81b201c79e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad629a55861dba428dd883f22732919/" rel="bookmark">
			Oracle的kernel.shmmax和kernel.shmall设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. kernel.shmmax ：
是核心参数中最重要的参数之一，用于定义单个共享内存段的最大值。设置应该足够大，能在一个共享内存段下容纳下整个的 SGA , 设置的过低可能会导致需要创建多个共享内存段，这样可能导致系统性能的下降。至于导致系统下降的主要原因为在实例启动以及 ServerProcess 创建的时候，多个小的共享内存段可能会导致当时轻微的系统性能的降低 ( 在启动的时候需要去创建多个虚拟地址段，在进程创建的时候要让进程对多个段进行“识别”，会有一些影响 ) ，但是其他时候都不会有影响。
官方建议值：
32 位 linux 系统：可取最大值为 4GB （ 4294967296bytes ） -1byte ，即 4294967295 。建议值为多于内存的一半，所以如果是 32 为系统，一般可取值为 4294967295 。 32 位系统对 SGA 大小有限制，所以 SGA 肯定可以包含在单个共享内存段中。
64 位 linux 系统：可取的最大值为物理内存值 -1byte ，建议值为多于物理内存的一半，一般取值大于 SGA_MAX_SIZE 即可，可以取物理内存 -1byte 。 内存为 12G 时，该值为 12*1024*1024*1024-1 = 12884901887
内存为 16G 时，该值为 16*1024*1024*1024-1 = 17179869183
内存为 32G 时，该值为 32*1024*1024*1024-1 = 34359738367
内存为 64G 时，该值为 64*1024*1024*1024-1 = 68719476735
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ad629a55861dba428dd883f22732919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08e9c0e9781020caaeeb8e3688b8124/" rel="bookmark">
			react &#43; typescript &#43; materialUI（Mui）系统基础搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react + typescript + materialUI（Mui）系统基础搭建 首先根据 React with TypeScript and Less 这篇教程的介绍搭建基于TypeScript+Less的React项目
然后安装react需要用到的库react-router-dom和react-redux
yarn add react-router-dom yarn add react-redux 技术选型 框架： React + reatc-router + react-redux编程语言：TypeScript + lessUI： Material UI (Mui) Day 01 项目搭建 ​ 基于React with TypeScript and Less 这篇教程搭建项目
安装Mui组件库 // 使用 yarn 安装 yarn add @mui/material @emotion/react @emotion/styled // 安装icon yarn add @mui/icons-material // 安装Mui的style模块（配置主题使用） yarn add '@mui/styles' 初始化项目模块 配置index.tsx入口文件 然后在index.tsx入口文件里面包裹react-redux提供的Provider引入store，store肯定会用到，然后包裹react-router-dom提供的BrowserRouter(有需要也可以用HashRouter替换，两种路由根据自己的项目需求进行选择)。
import ReactDOM from "react-dom"; import { BrowserRouter } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08e9c0e9781020caaeeb8e3688b8124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14065022b7f65270883ec427a7a3700e/" rel="bookmark">
			我的第一次给了它：数据库密码忘记了不要慌傻瓜式教你修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库的的密码忘记了该如何解决 1.找到数据库文件里面的my.ini文件 （1）打开电脑的隐藏文件夹：查看——勾选隐藏的项目 （2）进入磁盘（你安装mysql的磁盘）找到ProgramData——MySQL——MySQL Server 5.7（我的是5.7版本）——my.ini 2.修改my.ini文件的内容 （1）找到[mysqld]在下面添加skip-grant-tables 保存并关闭（注意是[mysqld]不是[mysql]）
3.重启数据库 (1)（window+R）调出命令窗口输入services.msc
(2)找到MYSQL57（我的是5.7版本）点击启动或者是重启动此服务
如果重新启动不行的话可能是你的端口被占用了比如PHP的wampmysql64或者其他工具占用把它们停止掉即可重新启动
4.修改数据库密码 (1)(window+R)输入cmd调出命令行窗口
(2)输入mysql -u root -p回车到输密码的阶段，这时候你会发现不管输啥密码都是可以进入的
(3)进入数据库输入 use mysql然后回车
(4)输入update user set authentication_string=password(‘123456’) where user=‘root’;将mysql的root密码重置为123456（根据自己想设的密码修改挂号里面的内容）然后回车，最后关掉命令行窗口
注意里面所输入的所有符号都要英文状态下注意结束时的分号
5.把你刚才在my.ini文件里面添加的东西删掉 (1)找到my.ini文件打开
(2)把刚才的skip-grant-tables那一行删掉并保存关闭
6.重新启动数据库 (1)（window+R）调出命令窗口输入services.msc
(2)找到MYSQL57（我的是5.7版本）点击重启动此服务
7.最后登录进去验证一下有无成功 (1)(window+R)打开命令输入cmd
(2)输入mysql -u root -p回车
(3)输入你设的密码
(4)如果显示welcome就成功啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9cf798c59d4b38b53dd79ff428555b3/" rel="bookmark">
			解决：cv2.error: OpenCV(4.5.1) XXX\shapedescr.cpp:315: error: (-215:Assertion failed) npoints ＞= 0 &amp;&amp;……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 解决错误方案错误再现源代码修改之后的代码报错原因 解决错误方案 错误再现 Traceback (most recent call last): File "D:/pythonProjects/Object_movement/object_movement.py", line 88, in &lt;module&gt; c = max(cnts, key=cv2.contourArea) cv2.error: OpenCV(4.5.1) C:\Users\appveyor\AppData\Local\Temp\1\pip-req-build-i1s8y2i1\opencv\modules\imgproc\src\shapedescr.cpp:315: error: (-215:Assertion failed) npoints &gt;= 0 &amp;&amp; (depth == CV_32F || depth == CV_32S) in function 'cv::contourArea' 源代码 cnts = cv2.findContours(mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) cnts=cnts[1] 修改之后的代码 cnts, hierarchy = cv2.findContours(mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) 报错原因 新版cv2.findContours返回两个值，[0]号结果为轮廓，而不是[1]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae3579120df1c10e0be914fa329d535/" rel="bookmark">
			vue:使用settimeout获取接口数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按照先从接口获取数据然后生成图表的思路，在data里给图表需要的数据一个初始值，然后在mounted里面按照先后顺序调用了获取数据和初始化图表的方法。
但是执行后发现，initMap永远获取到的是data里stations的初始值，而不是getGasStationInfo()里从接口获取的值，接口调用没问题，也能打印出来数据，但initMap就是一直得不到接口返回的数据。
问题排查：
1、this指向是否有误，我直接用的=&gt;方法，指向vue，并且打印this后也确实指向vue，所以可以排除是this指向问题。
2、同步消息和异步消息问题，想要了解更详细，可以自行百度，简单来说，对于我这个案例，就是 this.getGasStationInfo();接口返回的是异步消息，比下一句的this.initMap();会晚一点执行，所以this.initMap();总是拿不到接口返回的数据，总是读取data里初始化的数据，用一个简单粗暴的办法就是接口请求后，延迟一秒钟，再执行this.initMap();
代码如下：
mounted() { this.getGasStationInfo(); setTimeout(() =&gt; { this.initMap(); }, 1000); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37016d898b4986e67f6e68d751541f75/" rel="bookmark">
			java中jol-core依赖分析对象内存模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引用jol-core依赖 jol-core依赖版本的不同，下面代码分析的结果样式是不同的，下面再展示不同版本的结果
&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.16&lt;/version&gt; &lt;!-- &lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; 2、代码分析 import org.openjdk.jol.info.ClassLayout; import org.openjdk.jol.info.GraphLayout; import org.openjdk.jol.vm.VM; public class test { public static void main(String[] args) { String s = "-1111111111111111111111111011011011110110100001001010001011110111"; // String s = "- 11111111【】 11111111【】 11111111【】 10110110【b6】 11110110【f6】 10000100【84】 10100010【a2】 11110111【f7】"; String b1 = "11110111"; System.out.println("s的长度是="+s.length()); System.out.println("============================="); Person person = new Person(); // int hashCode = person.hashCode(); System.out.println(VM.current().details()); System.out.println("============================"); // String toHexString = Integer.toHexString(person.hashCode()); 136432db System.out.println("10进制》》System.identityHashCode(person)="+System.identityHashCode(person)); System.out.println("16进制》》System.identityHashCode(person)="+Integer.toHexString(System.identityHashCode(person))); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37016d898b4986e67f6e68d751541f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ef3524f81bd74175f50f7c97edbba7/" rel="bookmark">
			字符串加密-后移4位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { char c; while((c=getchar())!='\n') { if(c&gt;='a'&amp;&amp;c&lt;='z'||c&gt;='A'&amp;&amp;c&lt;='Z') { c=c+4; if(c&gt;'z'||c&gt;'Z'&amp;&amp;c&lt;='Z'+4) c=c-26; } printf("%c",c); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb3927ef2d4408a9ba5cb6c21564b939/" rel="bookmark">
			开源公告｜腾讯云代码分析（TCA）对外开源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云代码分析是集众多分析工具的云原生、分布式、高性能的代码综合分析跟踪系统。其主要功能是通过词法分析、语法分析、控制流、数据流分析等技术发现并跟踪管理敏捷迭代下的代码相关问题，并从圈复杂度、重复代码、代码统计角度进行代码综合度量，为代码规范性、安全性、可靠性提供保障，更有益于传承优良的团队代码文化。
更多惊喜，欢迎移步官方体验版：https://tca.tencent.com/
开源目的
培养市场，拉近潜在客户，提升腾讯云代码分析的易用性和知名度。
应用场景
代码安全：腾讯云代码分析支持针对OWASP Top10 中常见的漏洞进行分析，包括SQL注入、XML注入、外部实体注入攻击、敏感信息泄漏、URL重定向漏洞等，并结合CWE中常见漏洞，比如服务端请求伪造漏洞、服务器模板注入漏洞等，进行专项安全漏洞分析，支持Log4j漏洞扫描，可准确识别漏洞所在位置并提供修复建议。
代码可靠性：数组越界(AOB )和空指针解引用(NPD)等这类问题对软件稳定性、代码可靠性影响巨大，但在编码期间很难被检测到。而普通的代码走查方式成本高、有效性差，且不易跟踪管理。腾讯云代码分析支持问题回溯，自动标识数据流追踪路径，识别潜在漏洞，更清晰理解问题并提供解决方案。帮助开发分析和解决代码缺陷，减少代码走查测试成本，提高软件可靠性、健壮性。
代码异味：“代码异味是一种表象，它通常对应于系统中更深层次的问题。”腾讯云代码分析通过针对圈复杂度、重复代码、过长方法、过长参数列表等多类型代码异味扫描，将代码异味可视化，协助您更便捷地重构代码，提升代码的可读性、可维护性。
专项提升：Log4j漏洞扫描，iOS/Android隐私合规检查，C/C++/Objective-C/Java减包扫描。
功能介绍
1）全方面多维度的代码分析和跟踪监管：覆盖规范、质量、安全、度量等；
2）支持定制规则指标：提供更适配团队的个性化质量报告；
3）云原生分布式架构：轻松支持灵活扩/缩容，执行更快更稳定；
4）支持增量全量分析：增量分析快速发现问题，全量分析保证问题分析全覆盖；
5）多工具支持：集成众多自研工具、知名开源工具等，同时支持快速自主集成商业工具，满足高效自助管理工具的需求；
6）多语言支持：覆盖Java、C++、Objective-C、C#、PHP、JavaScript、Python、Go等常用编程语言
7）开放平台，标准化API接口：支持快速对接DevOps平台，提升研发效能；
8）多种使用场景：支持本地化分析、流水线调度分析等各类使用场景，满足多样化的研发环境。
项目规划
完善和优化功能，逐步接入更多优秀的分析工具。
逐步支持相关度量功能，为评估项目工程和管理做参考。
开源地址：https://github.com/Tencent/CodeAnalysis
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2318e232cb4c220f278992f0866d5941/" rel="bookmark">
			用强化学习来玩Atari游戏(基于Tensorflow的深度Q学习模型)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的博客用Tensorflow Agents实现强化学习DQN_gzroy的博客-CSDN博客中，我用TF-Agents实现了一个深度Q学习模型，并且对小车上山这个环境进行了训练。那么更进一步，我们可以看看能否用深度Q学习解决一些更复杂的问题，例如我们是否能训练一个模型，可以玩Atari的游戏，并取得比人类更好的成绩。
在2015年，DeepMind发表的论文《Human-level control through deep reinforcement learning》,提出了用带经验回放和目标网络的深度Q学习算法，直接从游戏界面中学习。本文将基于论文中提到的算法，来实现对Atari游戏进行学习。
首先加载Atari的环境，这里选择的是Pong这个游戏。环境名称中的deterministic表示每次调用Step的时候会得到4帧后的观测，返回的是这4帧的总奖励值。V4表示执行某个动作后，下一个动作没有限定要和上个动作相同。如果是V0则表示有25%的机率下一个动作和上一个动作相同。
from tf_agents.environments import suite_gym from tf_agents.environments import tf_py_environment from tf_agents.networks import q_network from tf_agents.replay_buffers import tf_uniform_replay_buffer from tf_agents.trajectories import trajectory from tf_agents.trajectories import Trajectory from tf_agents.trajectories import time_step, TimeStep from tf_agents.specs import tensor_spec from tqdm import trange from tf_agents.policies.q_policy import QPolicy import tensorflow as tf from tensorflow import keras from tensorflow.keras.initializers import GlorotUniform from tf_agents.networks.q_network import QNetwork from tf_agents.agents.dqn import dqn_agent from tf_agents.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2318e232cb4c220f278992f0866d5941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e8c5b8dabc0cb842437e852b33b1f3/" rel="bookmark">
			【易语言模块】MP3信息标签解析V1.0[源码]分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近下载了许多MP3歌曲，好多歌曲的信息不是乱码就是空白，在车载播放器中显示不正常，一个个修改起来很麻烦，就想做一个简便的信息修改器。
在网上找了好久，没有特别合适的mp3标签信息的模块，有一个mp3支持库可用。但是仅仅对ID3V1信息能修改，对ID3V2信息不能修改，使用起来不顺手。
因此，自己在前辈的基础上进行了重新构造，做成模块。现在分享给大家使用。该版本使用直接在原文件字节集的基础上修改字节集内容的方法。
（附加模块使用了精易模块5.26，使用了几个命令）【模块】MP3信息标签解析V1.0[源码]分享https://download.csdn.net/download/cultwent/73183921
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0948e849567904f47d82978214539cb/" rel="bookmark">
			使用FreeMarker导出Word文档(感觉是重要收获)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、添加maven依赖,导入FreeMarker所需要的jar包
&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.20&lt;/version&gt; &lt;/dependency&gt; 二、定义word模板文件
三、修改模板xml文件
把刚刚制作的word文件另存为xml文件
修改这个xml文件，开发工具我用的idea，我是把这个xml文件放在项目中，Ctrl+Alt+L进行格式化，这样文件内容看起来结构比较清晰，方便修改，你也可以使用其他xml编辑器等等
如XML 在线格式化 | 菜鸟工具
把文档内容中的动态数据，换成freemarker的标识。其实就是Map&lt;String, Object&gt;中key，如把段然涛换成${name}；
房间使用,场地使用,用餐情况是需要循环遍历的，在这里可以循环遍历list,list中存储的都是Map数据，然后再一一取出,并且根据便利的条数进行动态扩展.
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; &lt;?mso-application progid="Word.Document"?&gt; &lt;w:wordDocument xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:sl="http://schemas.microsoft.com/schemaLibrary/2003/core" xmlns:aml="http://schemas.microsoft.com/aml/2001/core" xmlns:wx="http://schemas.microsoft.com/office/word/2003/auxHint" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882" w:macrosPresent="no" w:embeddedObjPresent="no" w:ocxPresent="no" xml:space="preserve" xmlns:wpsCustomData="http://www.wps.cn/officeDocument/2013/wpsCustomData"&gt; &lt;#setting classic_compatible=true&gt; &lt;o:DocumentProperties&gt; &lt;o:Author&gt;K&lt;/o:Author&gt; &lt;o:LastAuthor&gt;K&lt;/o:LastAuthor&gt; &lt;o:Revision&gt;1&lt;/o:Revision&gt; &lt;o:Created&gt;2021-12-28T06:39:00Z&lt;/o:Created&gt; &lt;o:LastSaved&gt;2021-12-30T06:25:07Z&lt;/o:LastSaved&gt; &lt;o:TotalTime&gt;432000&lt;/o:TotalTime&gt; &lt;o:Pages&gt;1&lt;/o:Pages&gt; &lt;o:Words&gt;0&lt;/o:Words&gt; &lt;o:Characters&gt;0&lt;/o:Characters&gt; &lt;o:Lines&gt;0&lt;/o:Lines&gt; &lt;o:Paragraphs&gt;0&lt;/o:Paragraphs&gt; &lt;o:CharactersWithSpaces&gt;0&lt;/o:CharactersWithSpaces&gt; &lt;o:Version&gt;14&lt;/o:Version&gt; &lt;/o:DocumentProperties&gt; &lt;o:CustomDocumentProperties&gt; &lt;o:KSOProductBuildVer dt:dt="string"&gt;2052-11.1.0.11194&lt;/o:KSOProductBuildVer&gt; &lt;o:ICV dt:dt="string"&gt;43DEF8E5B112462190ED0F6108B223F8&lt;/o:ICV&gt; &lt;/o:CustomDocumentProperties&gt; &lt;w:fonts&gt; &lt;w:defaultFonts w:ascii="Times New Roman" w:fareast="宋体" w:h-ansi="Times New Roman" w:cs="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0948e849567904f47d82978214539cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88645674b5d3262f02090b71570cfef/" rel="bookmark">
			MIUI解BL锁失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最后解决办法是：换USB 2.0接口
分析问题：或许可能是软件兼容性不好，USB3.0影响读取设备信息，导致无法解锁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1da88d6f01efff3ea4a57694c008066/" rel="bookmark">
			六六的岁岁年年和年年岁岁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 结束亦或者开始 勤牛渐隐、啸虎又至，时光列车再添年轮。此刻，寒雪也许还未能洗去您2021的尘垢，亦或许，悄然孕育的新芽还未能为您带来2022的第一丝萌绿，回望2021乃至更久远的过往，时光酿成的酒，有苦有甜！2022，属于永毅前行的你。
关于写作 去年一年写的文章也挺多的，不过大多数都是自己的学习之作，记录下来，也算上自己的总结，不过庆幸的是虽然简单的文章也能帮助到不少人，每次自己写的文章被人家点赞收藏，也都会暗暗高兴，也是每个阅读文章的你让我坚持到了现在，明年我也将继续坚持!! 我的座右铭 种一颗树最好的时候是十年前，其次是现在，送给大家共勉！
掘金 经过去年的努力，我的倔强的掘力值终于5000了，也获得的优秀创作者和2021年度年度人气作者的称号，这也使自己非常高兴！也感谢大家对我的支持，估计很多人都帮六六投过票，由衷的感谢！！
image.png github 六六其实也维护过一个Github的一个项目，目前有了 1.1k start了,继续加油哇！！
https://github.com/bin392328206
image.png 去年的Flag 哈哈！我相信每个人都有立过flag,记得有一个Flag我记得很清楚，就是多刷点算法，让自己的算法入个门，啊哈哈，虽然也建立了一个仓库，但是自己其实很多时候也懒，没有去按自己的计划一步步去完成！虽然没能完成，但是吧！至少有行动了，也算不错，大家一起继续加油！
image.png 新年Flag 第一个flag先把go学会
继续算法
然后多看看基础知识
多看看书，去年看了（飞雪连天射白鹿，笑书神侠倚碧鸳）最近在看雪中悍刀行 有机会每个书给大家写一篇水文哈哈
新年祝福 每个人都是时代的一座高山，普通人也可以铸就伟大。生在这个时代，你我互为见证。此致2021，献给每一个平凡而闪耀的我们。
希望新的一年里，大家能够工作顺利，阖家幸福，健康快乐！健康快乐！健康快乐！最重要的要说三遍啦，啊哈哈！
福利1 支付宝搜口令红包
image.png 点收口令红包 输入：六六YYDS
福利2 在本篇文章下留言，可以是你这一年的经历，也可以是自己今年感悟，亦或者是自己新年的flag,六六将选取4条点赞最多的精选留言送9.99的红包（划重点要是被我选的精选留言哦，所以大家要认真一点啦） 这个应该很容易拿吧！毕竟六六好像还没一篇文章有超过4个留言的，开奖时间是2022年1月2号0点为准，获奖的朋友可以加我微信xiaoliuliubin兑奖
结束 好了！文章就到这了，我是小六六，三天打鱼，两天晒网！
image.png 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f24f81b1efa5cb94feb36256b8f20d5/" rel="bookmark">
			【yechaoa】5年Android开发的2021年终总结，实现Flag的一年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不知不觉一年又过去了，总是在回忆的时候感叹时间的流逝，回首这一年来的过往，也是不平凡的一年~
女儿出生了，换了新工作，认识了新朋友，也有很多新体验。
生活 尝试新菜 2021年的第一天家庭聚餐，尝试了道菜，蚂蚁上树，是真的蚂蚁，上次吃的蚂蚁上树还是肉丝炒粉丝…
换驾照 不得不再次感叹时间的流逝，驾照都要过期了，我也从一个小司机慢慢成长为老司机了…
女儿出生 3月底，十月怀胎一朝分娩的老婆把上辈子的小情人送到我面前，看着这个身体里流淌着同样血脉的小家伙，感觉真的很奇特，就像是上天赐予的礼物，惊喜到手足无措。
随后为小情人办各种手续，买保险，也学习了很多育儿知识，成功晋级一名奶爸~
锻炼 考虑到天气因素，以及我觉得我能坚持的蜜汁自信，犹豫再三还是买了跑步机，果然是浪费钱又占地方，还没狗跑的多…
工作 团建 5月份，公司组织团建去了湖州莫干山，带薪旅游是真的爽，玩的很开心，体验了网红项目[滑草]。
离职 7月份，思考再三还是选择离职，同事们都很nice，选择离职也是出于个人的职业规划的考虑。
入职 做技术的，可能每个人都有一个大厂梦吧，我个人也是对阿里有种特殊的情怀。
7月底，如愿收到了阿里的offer，随后开始准备入职材料、找房子，开启了在阿里的新征程。
也是实现了三年前的Flag了~
再次团建 11月底，在阿里的第一次团建，由于疫情原因，只能在上海本市，我们选择去了迪士尼。
很不错，不过更适合情侣去…
第二天，也第一次体验了剧本杀，还是挺有趣，一次不错的体验~
技术 2021年，认识了很多追求技术的新朋友，有时候圈子真的很小…
Android 1.写了第5个版本的玩安卓：
Jetpack版 玩安卓 2.写了两篇协程相关的源码分析：
【协程】LifecycleScope源码解析【协程】ViewModelScope源码解析 3.写了两篇MaterialDesign组件的使用及源码分析：
Android ShapeableImageView使用详解，告别shape、三方库Android MaterialButton使用详解，告别shape、selector 4.写了一篇包体积优化的方案：
Android包体积优化（常规、进阶、极致） Flutter Flutter TextField详解Flutter SliverAppBar全解析，你要的效果都在这了！ 面试 还写了一篇面经…
【面经分享】5年Android开发的求职之路 更多 可在主页查看~
总结 这一年不管是生活还是工作，都经历了很多。不忘初心，砥砺前行！
这一年在技术上的输出并不多，除了懒，也是没时间，草稿箱里还有两位数的博客没有发，一方面觉得体系还没有构建完成，另一方面觉得自己理解的还不够，所以就一直处于搁置的状态了…
其实一篇博客的产出，背后是需要很多的时间和精力的，希望自己能有更多更好的内容分享，也希望各位多多支持~
寄语 祝各位在新的一年，身体健康，事事如意！
生活总有不顺，只要努力，未来一片光明！
共勉~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7722d26aa9c0e8e2a7fc560e85ffe5d7/" rel="bookmark">
			问题记录：Unable to load class ‘javax.xml.bind.JAXBException‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 升级到Android Studio Arctic Fox | 2020.3.1 后报如下错误：
原来是因为JDK问题，解决办法：
Ctrl+Alt+Shift+S 打开“Project Structure”-&gt;选择SDK Location-&gt;点击Gradle Setting，具体看下图
点击Gradle Settings后弹出如下窗口：
修改Gradle JDK为图中第一个，不要选择Android Studio目录下的jre，如果没有图中所示的JDK，可以到Java官网下载
下载地址
修改后点击Apply完成配置即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd59adc8ad463c4ba854f8953962cae/" rel="bookmark">
			大学C语言知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截止到目前我已经写了 600多道算法题，其中部分已经整理成了pdf文档，目前总共有1000多页（并且还会不断的增加），大家可以免费下载
下载链接：https://pan.baidu.com/s/1hjwK0ZeRxYGB8lIkbKuQgQ
提取码：6666
总共16页，就不在一一展示，可以扫描最上面的二维码，关注微信公众号“数据结构和算法”，回复“2025”即可下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23312612a4f58815a5e4dc884011582a/" rel="bookmark">
			Leetcode 518 零钱兑换Ⅱ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：518. 零钱兑换 II - 力扣（LeetCode） (leetcode-cn.com)
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。
示例 1：
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
分析：
这个题是一个多重背包的问题，多重背包和01背包的区别在于：多重背包的物品可以选择多次，那么这时候，dp数组的遍历方式就发生了变化，01背包为了保证每个物品仅放一次，在遍历容量时需要从后往前，那么多重背包没有了这个限制，于是遍历容量时需要从前往后。 确定dp数组及下标含义：dp[j] 表示容量为 j 时，可以凑成该金额的种类数。
递推公式：dp[j] = dp[ j- coins[i] ]
初始化：dp[0] = 1
遍历顺序：遍历顺序在组合问题和排列问题时区别很大，对于组合问题，我们需要先遍历物品，再遍历容量，对于排列问题，我们需要先遍历容量，再遍历物品。
class Solution { public: int change(int amount, vector&lt;int&gt;&amp; coins) { vector&lt;int&gt; dp(amount+1, 0); dp[0] = 1; for (int i = 0; i &lt; coins.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23312612a4f58815a5e4dc884011582a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c3c1034faa040d6e0b1218196f6f23e/" rel="bookmark">
			基于 ARM 开发板的 UnixBench 测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的文章中，有介绍过使用 UnixBench 给 Linux 服务器进行性能的基准测试，但是使用那篇文章中的 UnixBench 脚本安装的 UnixBench 工具并不支持 ARM 平台。
最近着手购入不同的开发板进行测试和开发，由于目前在售的大多数 Linux 开发板都是基于 ARM 架构的平台，因此特地找了一个可以在 ARM 架构平台下运行的 UnixBench 工具。本文下面将介绍如何安装 UnixBench，及简单介绍两个开发板的性能对比。
UnixBench 安装 首先我们需要下载 byte-unixbench 源码。
git clone https://github.com/kdlucas/byte-unixbench.git 这个源码是需要我们自行进行编译的，我们在开始编译之前，需要先安装好依赖。
sudo apt install -y make gcc 安装好依赖之后，开始编译。
cd byte-unixbench/UnixBench make # 等待编译完成 # 编译完成后，需要给 执行程序赋予执行权限 sudo chmod u+x ./Run # Ps：除了 Run 程序测试多核的时候，需要执行其他脚本 # 为了避免报错，最好把 UnixBench 目录下脚本都赋予执行权限 sudo chmod u+x -R ./* 完成后，即可开始测试。
sudo ./Run # 等待测试结果即可 测试结果参考 我使用了树莓派3B(4Core 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c3c1034faa040d6e0b1218196f6f23e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8a5927012c01bd39fdb3ba8ac24bff/" rel="bookmark">
			易语言写出文件、写出字节集编码方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做一个字节集写到文件的过程中，发现写入的字节集经常出现差错，一直找不到原因，一开始怀疑是程序写的问题，久查无果；随后怀疑是编码问题，搜索了一通，对于易语言的默认编码方式没有一个明确的说法，不得已写了一段代码测试，发现易语言默认的写入到文件的编码方式是“ANSI”。在调试过程中发现一些特殊情况：
1、写出文件（）命令中如果字节集参数的内容为空的话，文件在改写完毕之后会自动关闭。
2、写出字节集（）命令在写完文件之后，如果需要输出数据，需要重新打开文件，否则出乱码；
另外，写出字节集（）命令如果长度短于原文件长度，只改写前一部分（和打开方式有关）。
重点：易语言的2个编码方式为：ANSI
具体代码参考：https://download.csdn.net/download/cultwent/72361295https://download.csdn.net/download/cultwent/72361295
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cabc5877df7e0f8831ec0df57b89ef6/" rel="bookmark">
			idea中使用Git推送远程服务器（绝对可以看懂，一步一步全展示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、前提 1.需安装好Git且配置好环境，并将Git实现免密码登录，免密钥链接对应远程仓库
2.本教程主要教学在idea中使用Git推送远程服务器，不对指令操作进行具体讲解
二、详细步骤 1.首先在对应远程仓库（常用Gitee，Github）先新建对应仓库
2.进入idea，在VCS下拉菜单中找到创建Git仓库选项，点击
（此步对应，git init）
2.选中你当前项目的文件夹，确定
3.此时，你项目中的文件应该会变红，这代表你的本地git仓库已经建立完成，VCS下拉菜单也变成了git菜单。
4.选中git下拉菜单，选中管理远程
5.添加远程主机信息，url就是你进行git remote add origin &lt;url&gt;操作的url，也就是你在Gitee或Github对应页面中复制的ssh链接。添加完成，点击确定。
（此步对应，git remote add origin &lt;url&gt;）
6.再次选中git下拉菜单，选择拉取
（此步对应，git pull origin master）
7. 出现下面的窗口后，点击选取分支，此时可能没有分支，按住ctrl + F5，会刷新出来分支，然后点击拉取。
8.此时你右键点击你的项目，点击从磁盘重新加载后，你会发现你的远程仓库模板已经合并到了本地。
9.此时选中git下拉菜单，选择提交，或者点击屏幕右上角的绿色对勾提交。
（此步对应，git add和git commit -m "注释"）
10.提交后等待加载后就会出现以下画面
11.选中如下两项，你就会看到完整的项目结构
12.然后选择你想的想提交的项目，添加你想加的备注。然后提交，有警告就点仍然提交，也可以查看一下git的日志。
13.等待提交完成，此时你提交的文件就在本地仓库了。
提交完成后选中git下拉菜单，选择推送，或者点击屏幕右上角的绿色斜向上箭头推送。
14.出现下面的窗口，在右侧选中你要推送的文件即可，然后推送，我这里就全选推送了。
（此步对应，git push origin master）
15.idea提示推送成功，失败会爆红，可以复制错误，百度修改。
16.此时你就可以去你的远程仓库查看你推送的项目文件了。
如果对你有所帮助，希望可以点个赞👍，谢谢 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/159/">«</a>
	<span class="pagination__item pagination__item--current">160/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/161/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>