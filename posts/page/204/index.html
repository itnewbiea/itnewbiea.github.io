<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83574ec2766886df02112bae5b67dc4c/" rel="bookmark">
			KEPServerEX 6使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 KEPServerEX 6使用核心步骤：1.创建通道KepServer界面介绍新安装的KepServer，会有3个默认模拟器（里面包含8位设备，16位设备以及具体的寄存器）新建通道 （左击图标或者右击**连接性**）根据设备 （添加通道向导）根据硬件设备的厂家或实用协议选择通道向导（这里根据客户设备协议使用的 Modbus TCP/IP Ethemet 协议连接） 下一步输入 通道名字 下一步这里可以根据自己的需要选择，这里默认下一步这边直接下一步这边可以选择监听的端口（默认 502） 下一步 检查配置完 点击完成即可 2.创建设备点击添加设备填写设备名字这边根据实际情况选择 对应的通信类型（这边是Modbus TCP/IP协议）这边根据硬件驱动器站点或节点连接IP设置，或者设置好预留给硬件IP（这边预留 192.168.1.88）直接采用默认值 直接下一步端口根据实际需要设置 设置完后直接下一步检测具体配置后 点击完成 3.创建变量（标记）点击对应设备，点击右边窗口内 添加标记 弹出属相编辑器根据客户硬件放 提供的地址值 选择对应的数据类型（可以模仿默认提供数据示例去创建类型） 添加名称与说明 确定 完成创建默认提供数据示例 KEPServerEX 6 Ua设置（需要注意的细节）1. ip，端口，Url （下面有描述）ip这个可以在cmd ipconfig 自己查项目运行后 证书导入 （右下角右击KEPServerEX 6 点击 OPC UA 设置） 2. 安全策略 （默认无，下面有描述）3.证书（是否在信任状态，Java是在项目运行后导入）如果时Java UA连接 需要项目运行以后（右击点击证书，点信任）点击完效果开启OPC UA 匿名登录（右击项目 左击属相 弹出页面）选择 OPC UA 开启匿名登录 KEPServerEX 6使用核心步骤： 1.创建通道 KepServer界面介绍 新安装的KepServer，会有3个默认模拟器（里面包含8位设备，16位设备以及具体的寄存器） 新建通道 （左击图标或者右击连接性） 根据设备 （添加通道向导）根据硬件设备的厂家或实用协议选择通道向导（这里根据客户设备协议使用的 Modbus TCP/IP Ethemet 协议连接） 下一步 输入 通道名字 下一步 这里可以根据自己的需要选择，这里默认下一步 这边直接下一步 这边可以选择监听的端口（默认 502） 下一步 检查配置完 点击完成即可 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83574ec2766886df02112bae5b67dc4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed346077003f75a8ecce5a397b23255/" rel="bookmark">
			Git&#43;GitHub使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git+GitHub使用教程 文章目录 Git+GitHub使用教程安装Git登录GitHubSSH Key关联管理仓库推送本地仓库到远程拷贝远程仓库到本地使用pycharm管理仓库 安装Git 下载链接
https://git-scm.com/download
运行安装文件，全按默认勾选即可
想要在cmd中运行git，在path eviroment那里要选第二个选项 登录GitHub SSH Key关联 1. 创建github账户
2. 创建SSH Key
打开git bush，输入以下命令
ssh-keygen -t rsa -C "youremail@example.com" 注意这个邮件地址和你的github账户是要是同一个邮箱
一路回车，直到显示创建成功
如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
3. 在github上填写SSH Key
首先，在本地查找id_rsa.pub文件，复制里边的内容。
登陆GitHub，打开“Account settings”-“SSH Keys and GPG keys”页面，创建“New SSH Key”：
Title中填写你给电脑取的名字，在Key文本框里粘贴id_rsa.pub文件的内容即可。
管理仓库 推送本地仓库到远程 在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库；把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库；再通过git commit -m "注释内容"把项目提交到仓库；在Github上设置好SSH密钥后，新建一个远程仓库，通过git remote add origin 远程仓库地址将本地仓库和远程仓库进行关联；最后通过git push -u origin master把本地仓库的项目推送到远程仓库（也就是Github）上。 第一次推送时远程仓库为空，要加 -u
使用git将本地项目推送到远程仓库github
拷贝远程仓库到本地 使用github仓库的URL拷贝
git clone https://github.com/lemonade117/BP_SpikingNN.git
直接从github下载压缩包
这个方法下载下来的是没有git信息的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed346077003f75a8ecce5a397b23255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fdabe55637ecedf007cbde43deff606/" rel="bookmark">
			适合 C&#43;&#43; 新手学习的开源项目——在 GitHub 学编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：HelloGitHub-小鱼干
俗话说：万事开头难，学习编程也是一样。在 HelloGitHub 的群里，经常遇到有小伙伴询问编程语言如何入门方面的问题，如：
我要学习某一门编程语言，有什么开源项目可以推荐吗？
我是某编程语言的新手，有什么练手的项目推荐吗？
等等
See，这就是本系列文章的由来，我们希望学习各类编程语言的同学们，读（Mark）完我们的入门系列，可以找到学习的方向、系统地学习某一门语言，然后做个简单的小玩意，不只是 Hello World 。
《GitHub 上适合编程入门的项目》系列，共计 5 篇文章：
C++ 篇
Python 篇
Go 篇
Java 篇
JavaScript 篇
以下为 C++ 篇 的内容。不管哪门编程语言，基础都是很重要的。所以我们要先从基本的语法和基础知识学习学起，一步步掌握这门语言。
一、基础 1.1 一个项目入门 C++ 足以：CPlusPlusThings CPlusPlusThings 是国人开源一个 C++ 学习项目。它系统地将 C++ 学习分为了【基础进阶】、【实战系列】、【C++2.0 新特性】、【设计模式】和【STL 源码剖析】、【并发编程】、【C++ 惯用法】、【学习课程】、【工具】、【拓展】。
作为一个全面系统的 C++ 学习项目，CPlusPlusThings 是优秀的，它合理地安排了 10 Days 的实战部分，在实战中了解语法和函数用法，唯一不足的是，在注释部分有些不尽人意，对部分新手程序员并不是很友好。【基础进阶】部分内容：
const 那些事
static 那些事
decltype 那些事
引用与指针那些事
宏那些事
GitHub 地址→https://github.com/Light-City/CPlusPlusThings
1.2 基础部分之算法：C-Plus-Plus C-Plus-Plus 是收录用 C++ 实现的各种算法的集合，并按照 MIT 许可协议进行授权。这些算法涵盖了计算机科学、数学和统计学、数据科学、机器学习、工程等各种主题。除外，你可能会发现针对同一目标的多个实现使用不同的算法策略和优化。
GitHub 地址→https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fdabe55637ecedf007cbde43deff606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da393a5298cfb480e7bf068c356d0ebe/" rel="bookmark">
			CAS与Volatile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CASvolatilecas的特点为什么无锁效率高 CAS 全称是Compare And Swap 即比较和交换，是乐观锁的一种实现
一个取钱的例子：
public class TestAccount { public static void main(String[] args) { Account account = new AccountCas(10000); Account.demo(account); } } class AccountCas implements Account { private AtomicInteger balance; public AccountCas(int balance) { this.balance = new AtomicInteger(balance); } @Override public Integer getBalance() { return balance.get(); } @Override public void withdraw(Integer amount) { /*while(true) { // 获取余额的最新值 int prev = balance.get(); // 要修改的余额 int next = prev - amount; // 真正修改 if(balance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da393a5298cfb480e7bf068c356d0ebe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae0f589b2046ad499479840b5164273/" rel="bookmark">
			iphone屏幕镜像_把iphone手机投屏到Mac电脑的技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个Mac软件的共享平台
➤下载
[名称]： AirServer-7.2.0 (Mac版) [大小]： 21 M B [语言]： 简体中文 [安装环境]： Mac OS10.11 或更高(支持10.15) ⬇︎[下载链接]:
https://590m.com/file/23892771-442515059 ➤软件简介 AirServer是一个从 iOS 设备无线传送到 Mac 电脑的屏幕上，把Mac变成一个AirPlay终端的实用工具。是一个非常简单的Mac和PC应用，它只有一个目的，那就是与你的iPhone或者iPad的屏幕搬到电脑上，共同分享iOS设备的屏幕。你安装了AirServer软件，iPhone或者iPad上会显示可用于AirPlay的设备列表，选择你的电脑，你的iPhone屏幕就会立即呈现在电脑上，就像Apple TV与电视的关系一样。你可以通过WIFI将音频、照片、视频以及支持AirPlay功能的第三方App，将屏幕分享到Mac的屏幕上。
1. 如何在公众号下载软件？ 进一步了解 &gt; 2.Mac提示“打不开XX…身份不明的开发者” 或“XX已损坏，打不开”怎么办？进一步了解 &gt; 3.《巴果》官方QQ：707348276 ➤安装步骤
1. 双击下载的【AirServer-7.2.0. dmg】解压镜像文件。
2. 点击【同意】。
3. 将【AirServer.app】图标拖入【Applications】文件内，等待拷贝完成。
4. 点击【启动台】。
5. 点击【AirServer】图标运行软件。
6. 软件的小图标显示在了Mac电脑的上面。
7. 我们打开iphone手机，找到并点击【屏幕镜像】。
8. 这时iphone上已经显示出我们的Mac电脑。点击即连接Mac电脑。
9. 这样iphone手机屏幕就能镜像到我们的Mac电脑上啦。
嘚！嘚！右下角点个【在看】❤️
公众号《巴果》提供的所有下载文件均为网络共享资源，不得用于任何商业用途，请用户下载后24小时内删除，其真实性、准确性和合法性，本公众号不提供任何保证，不承担任何法律责任。 因不当使用本公众号网络共享软件而导致的任何意外、疏忽、合约毁坏、诽谤、版权或其他知识产权侵犯及其所造成的任何损失，本公众号概不负责，亦不承担任何法律责任。 如需长久体验，还请支持各公司正版授权软件。 长按关注 《巴果》官方微信 共享一万个Mac软件
给您第一手资讯和使用技巧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70a951221690c212facfdf791d6a392/" rel="bookmark">
			使用inetaddress测试目标可达性_「福利」6款免费网络延迟测试工具，等你来下载...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为网络管理员或网络工程师，时刻关注网络的交付速度至关重要。不仅需要确保自己有良好的响应时间，还需要确保网络的速度足以满足用户通信所需的每一条路径。而手动测试每个路径将占用你所有的时间。所以需要获得一个测试工具，以确保延迟不会影响网络的性能。
什么是延迟?
延迟是网络流量的速度指标。可接受的传输时间根据使用的应用而变化。视频播放和交互式VoIP呼叫需要比电子邮件传送更快的速度。因此，需要根据你为用户提供的服务计算出网络流量所需的速度。
测量延迟
延迟以毫秒(ms)为单位。但是，有两个指示延迟的指标。无论你选择在网络上进行测试，都要尝试将所有记录保存在同一测试类别中。
最常见的延迟测量称为“往返时间”(RTT)。顾名思义，这是数据包从网络上的一个点到另一个点所需的时间。另外一个测量指标称为“第一个字节的时间”(TTFB)。这记录了数据包的第一部分离开网络上的一个点的时刻与它到达目的地的时间之间的时间差。RTT的使用频率高于TTFB，因为它可以从一个位置运行，不需要在远程目标上安装特殊的数据收集软件。
使用Ping
每台连接网络的计算机都有一个内置于操作系统中的免费延迟测试工具，称为Ping。此工具适用于IP层协议，即Internet控制消息协议(ICMP)。每个网络管理员都使用Ping，它是一个快速检查的有用工具。你无需在远程计算机上安装任何软件，并且可以将报告返回到启动命令的计算机。
典型的Ping执行将向给定目标发送32个字节的数据，并记录响应返回的时间。延迟表示为往返时间，其包括测试分组的传输时间和响应分组。该时间以毫秒为单位显示。
如果要测试RTT到网站，则不必知道目标IP地址，因为Ping将接受域名作为地址而不是实际IP地址。默认情况下，Ping将发送四个测试数据包，但该命令上的一个选项使你可以指定不同数量的测试。
Ping命令的结果显示每个测试的RTT，然后汇总结果。你将看到发送的数据包数，收到的响应数以及丢失的数据包数。还将看到丢失的数据包计数表示为所有测试的百分比。第二个摘要行显示测试批次的最小，最大和平均往返时间。
Ping的问题
当特定路径运行缓慢时，Ping非常适合快速检查。但是，该工具不会帮助你修复延迟问题，并且它不允许你使用一个命令检查多个路径。幸运的是，有许多更复杂的基于Ping的工具可用。这些通常使你能够从同一控制台测试多个路径。还可以经常使用某些工具运行Ping测试。这些常量Ping工具可以实时显示延迟测试的结果。
延迟解决方案
延迟是一个复杂的问题，可以通过流量整形(traffic shaping)方法来管理，例如排队算法。可以使用一系列“服务质量”(QoS)方法对某些流量进行优先级排序。这使你可以在所有其他流量之前通过所有网络设备获得对时间敏感的应用程序流量。如果你在网络上提供IP电话应用的实时视频传送，这非常棒。
通过网络中的交换机和路由器清除一些流量可能会导致其他流量类型被阻止。但是，如果能够节省你必须更换网络电缆，以便为所有流量提供足够的带宽以便以最快的速度通过，那么电子邮件转移延迟几分钟就是值得付出的代价。
▐ 今天就给大家推荐六款免费网络延迟测试工具。
Network Pinger
Network Pinger是一款在Windows上运行的免费工具。这个简单的实用程序具有漂亮的界面，显示面板主要被扫描结果占用。该输出是一个递归Ping。它将测试你输入的范围内的所有目标IP地址作为搜索参数。侧面板显示扫描收集的数据的图形表示。其中包括联系人状态饼图和显示响应时间的折线图。你还可以看到每次联系尝试的RTT(往返时间)。
除了Ping功能外，Network Pinger还包含一个Traceroute工具，可以为你提供指向目标地址的链接中每一跳的响应时间。该工具还具有交换机端口映射器。你可以使用内置的远程桌面，SSH，Telnet和Rlogin实用程序通过该工具联系远程计算机。
ManageEngine
ManageEngine是一个Ping和Traceroute工具。免费软件包还包括DNS查找功能和网站响应时间的专业度量。
此工具的Ping部分显示每个给定主机和每个主机的Ping数据，包括往返时间。屏幕将不断刷新，为你提供RTT的实时更新到你的IP地址列表。
该工具的一个问题是你必须单独输入每个地址，而不是输入地址范围。但是，一旦你在屏幕上输入了这些内容，即使你必须停止显示器切换到其他实用程序，它们也会保留在那里。Ping结果也可以显示在时间序列折线图上。
Traceroute实用程序显示到达给定目的地的路线的每一跳的往返时间，并在旁边显示一个条，这使得RTT易于理解。
如果你输入的URL不存在本地记录，则DNS查找实用程序将引用你的本地网络DNS服务器或最近的基于互联网的服务器。你可以输入IP地址或URL作为此实用程序的搜索词。
Web响应选项卡为你提供了给定网站地址的Web服务器响应时间的精确图表。此图表将继续更新，它会显示TCP会话建立，重定向时间和网页响应时间之间的RTT细分。
这是一个很棒的小工具，你也可以用PDF格式打印报告，你可以保存或发送电子邮件。
NirSoft NetworkLatencyView
NirSoft的NetworkLatencyView工具与此列表中的所有其他延迟测试工具略有不同。该实用程序不是检查指定目标的链接，而是在它们持久存储时侦听所有新的TCP连接和监控。该工具的报告基于Ping，因此你将获得与其他工具相同的延迟反馈。
这是一个免费工具，它安装在Windows上。对于每个检测到的连接，显示窗口最多可显示10个Ping测试RTT值。它还显示了这十个测试的平均值。但是，你可以调整列的大小，拉伸窗口或向右滚动以查看所有数据。结果可以保存为CSV，HTML，XML或文本文件，以便在其他应用程序中进行分析。
Angry IP Scanner
Angry IP scanner是一款免费的Ping实用程序，可在Windows，Linux和Mac OS上运行。界面的简单布局使其成为网络管理员的有用工具。可以通过输入“from”和“to”IP地址或输入主机名和CIDR表示法偏移量来启动Ping扫描。也可以通过从文件加载到接口中来输入非连续的IP地址列表。
该工具将ping给定范围内的每个地址，并在输出中显示每个地址。这可能导致屏幕中出现大量未使用的地址。你可以通过在工具的“首选项”部分中设置仅显示实时IP地址来避免此大量不相关的记录。此要求可以通过一个选项进一步细化，该选项限制输出列表以仅显示具有开放端口的主机。
可以使用经典ICMP消息，TCP或UDP进行测试。虽然该实用程序将在一次运行中ping许多主机，但它只会按需运行每个Ping探测。该服务不会连续重复。如果要刷新报告，则需要再次按“开始”按钮。
默认输出仅显示每个发现的IP地址的平均RTT，以及该目标的主机名和该设备上的开放端口数。你可以通过选择额外的数据类别来自定义输出。这些包括数据包丢失字段。
发出的测试数量由“首选项”屏幕中的一个设置决定。每个地址的默认探测数为3。可以以CSV，XML，文本或IP端口格式导出测试的输出。
Pinkie
Pinkie是一套网络监控工具，包括Ping扫描选项。该工具可以免费使用，并可在Windows上运行。
该工具还包括一个简单的Ping选项，它只能探测一个目标IP地址，也可以作为URL输入。此功能将继续向目标发出Ping数据包，显示RTT以及每个探测数据包中输入的“生存时间”设置。
Ping Sweep选项将测试一系列地址。
但是，测试不是连续的，必须通过按“开始Ping扫描”按钮再次启动该实用程序以刷新结果。通过屏幕搜索部分的复选框，你可以排除非活动的IP地址。此屏幕中的结果显示该探测的IP地址，主机名和RTT。可以将Ping Sweep输出复制到剪贴板，然后粘贴到文本文件中。
Pinkie中的其他实用程序是端口扫描程序，Traceroute实现，DNS查找功能和批量DNS引用工具，它使用文件中的地址列表。捆绑中还有子网计算器和TFTP服务器。这是一组非常有用的工具，可帮助你在一个界面中保留检查网络所需的所有工具。
NetScan Tools
NetScan Tools基础版是一组在Windows上运行的免费网络测试工具。该工具是免费的，但有弹出广告。如果想摆脱这些广告，可以购买NetScan Tools Pro。
在两个版本的NetScan Tools中都可以获得三个基于Ping的实用程序。该软件包还包括Traceroute工具，因此你有四种方法可以测试网络的延迟。
第一个Ping选项是对标准命令的直接图形解释。输入域名，主机名或IP地址，该工具将向该目标发送五个Ping探测。输出将显示每个探测的RTT和生存时间。你可以在“设置”菜单中更改每次运行中发送的数据包数。
图形Ping选项显示对单个目标的持续执行的Ping测试。同样，该目标可以通过主机名，域名或IP地址指定。测试将一直重复，直到选择停止。甚至在你离开后，可尝试不同的实用程序时继续。图表显示了每次尝试的RTT。
Ping扫描程序允许你测试一系列IP地址。输出将向给定范围内的每个地址显示Ping测试的结果。但是，你可以选择删除不响应的地址。结果包括IP地址，主机名，往返时间以及范围中每个地址的状态报告。单击鼠标右键可以使用上下文菜单。这使你可以打印测试的输出或将其保存到文件。
Traceroute工具为你提供了有关网络延迟的另一种视图。这显示了计算机与给定目标地址之间的每一跳。每个跳的RTT与每个中间路由器的IP和地址一起显示。此命令将运行一次。如果要获取连接中每个链接的速度更新，则必须重新发出命令。
包中的其他工具是DNS查找功能和Whois查询工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f70a951221690c212facfdf791d6a392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e20c0659156d5fbd05ff910adca02ff/" rel="bookmark">
			exxi6.7如何传文件到win7_比QQ直传快100倍！它让PC、安卓、iPhone光速互传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想了解有趣有料的数码资讯，手机深度评测，数码选购要点，最新薅羊毛秘诀，动动手指，点击关注我们。避坑的事交给我们来做吧～
每个星期上班都是个煎熬，各种意外在等着你，比如平常工作中各种图片、文章、数据等等，很多都需要进行传送。
每次传资料的时候，我都要感叹一次：
移动硬盘、U 盘还太麻烦了，无线该多好。有人一定会说，无线可以用 QQ 直传啊！
虽然 QQ 可以传较大的文件，但速度极其不稳定呀！上一秒还是 1MB/s，下一秒就 200KB/s，根本不知道要传多久....
微信就更别提了，这上百张原图恐怕要传好几个小时吧？
而且更恐怖的还不是慢，而是它还有出错的情况，这样一来，又得一个个重新点一遍发送，手指都要断了哟。
学霸君今天教你一个电脑自带的直传大法，速度高达 600M/s（友情提示：速度和路由器正相关，普通千兆、百兆路由就已经很快了。）
花 5 分钟简单设置一下，就能在电脑上随意的拷贝文件一样方便。
这直传大法，简单来说就是在同一个局域网内设置一个共享文件夹，就能让任何系统的电脑、手机直接访问。
先让你们瞅瞅这速度！
不过，之前有朋友说共享文件夹咋老出错啊？
他说：“每次共享出去，要么死活打不开文件，要么就找不到共享出去的文件夹，好气！”
学霸君这次连那个出错的解决法都帮你们找好了，用过一次就是真香。 01 五分钟前期准备 很多人觉得，共享文件夹直接共享就行了，其实并不是。
他们之所以出现各种奇奇怪怪的错误，很大一部分原因是没有正确的网络配置。
学霸君就以自己的这台旧电脑为例。
首先我们在在右下角找到联网的图标，单击右键选择「打开“网络和 Internet”设置」，
找到「网络和共享中心」，再点击左边的「更改高级共享设置」。
在「来宾或公用网络」中，选中「启用网络发现」、「启用文件和打印机共享」，保存。
在「所有网络中」，按顺序选中「启用共享」、「使用128位加密」和「关闭密码保护共享」，最后保存即可。
PS：如果你是 Win7 用户，在任务栏的网络图标右键，直接点击「网络和共享中心」即可，操作基本与 Win10 一致
02 如何正确打开共享文件夹 但学霸君发现，很多小伙伴在共享文件夹的过程中，遇到最多的问题就是：共享文件夹为什么打不开，总提示没有权限？
其实是因为共享文件夹还没认识你，自然就不给你进入啦！
我们先找到所需共享的文件夹或者盘符，学霸君这里就以共享整个 C 盘为例，这样想要什么就拿什么，比较方便。
我们右键 C 盘选择「属性」，然后点击「安全」选项，并点击组或用户名下方的「编辑」。
在另外打开的页面中点击「添加」，在弹出页面的空白框内输入「everyone」，点击「检查名称」让单词出现下划线后，点击确定即可。
学霸君在这里就选择了 everyone，意思是让局域网的任何人都能使用我的这个文件夹，省得又出什么岔子，比较万金油。
当然，如果你只想自己一个部门的人使用，也可以改为自己部门所在的组的名称。
最后，我们还要给使用文件夹的用户分配权限。
像学霸君这种电脑里没有珍惜资源的，放心的把所有都勾上。要是担心别人会删你东西，也可以把前两个去掉，只留读取权限即可。
03 共享并分配权限 最后就是共享这个文件夹啦！
很简单，同样在 C 盘「属性」中点击「共享」，再选中「高级共享」。
然后在弹出的页面中，勾选「共享此文件夹」，在「权限」中选择使用文件夹的权限。
最后只管「确定」并「应有」就完成啦！
此时我们的 C 盘的图标就会多了个「共享」的标志，而且在属性中能够看到共享的路径。
04 怎么用 对于在同一个局域网的小伙伴来说，我们可以打开「网络」（也就是 Win 7 的「网上邻居」），大家的电脑都会在「计算机」一栏中显示出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e20c0659156d5fbd05ff910adca02ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866812bab2b513c55554786e2a4726aa/" rel="bookmark">
			c# spire.xls 设置文字为微软雅黑_微软自带de白板应用，超好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的时候你需要为自己一天的工作安排时间表，传统的便签或许可以满足。但是，当你是一个团队时，需要分工合作完成一件任务，又不想花费高额支付软件应用时。微软在 Windows10 早已加入一款高颜值软件。
在新版的 Windows10 系统当中，快捷键 Windows+W，是全屏截图的快捷按钮和一个白板应用 Whiteboard (如果你电脑上没有，点击下载就会自动安装)。在这白板功能当中，你可以在其中添加图片、便签、绘画，然后，共享给其他人，或者一起协作。
你可以在电脑、手机或平板当中，跨设备使用，以安排生活、思考项目或激发更多创意。
在右上角的菜单当中，首先，我们可以事先设置背景格式，给它换个底色、换个背景。
以电脑当中的操作为例( iPad和手机类似 )，点击新建白板之后，你就可以在白板当中随意创作。Whiteboard 和微软自家的另一款优秀应用 OneNote 拥有类似的自由度，你可以不受文本格式的限制，并且随意缩放背景或内容的大小。
OneNote 也是一款超实用的学习工具，随时随地都可以记录笔记，即使你是在浏览网页，你也可以随时保存到OneNote上。详情可以到：用了浏览器扩展程序，瞬间就高大上啦。
通过底部的画笔工具，我们可以随意绘制，还能完成一般实体白板中不能完成的精细绘画工作，我们可以勾选右上角【将墨迹转换为形状】，当你画一个任意形状时，它会自动转换成标准形状。
你可以不受文本格式的限制，并且随意缩放背景或内容的大小，任意图片，便签，甚至整个白板都可以随意放大缩小。
在右上角的菜单当中勾选【将墨迹转换为表格】之后，如果我们贯穿矩形，画出直线，矩形会自动变成表格。有意思的是，表格会根据你书写的内容不断自适应；
当你一个便签不够的话，点击右键就可以添加便签和图像，而 Windows 当中的设计入口更浅。
点击添加的任何对象，你都可以做相应的设置，比如调整大小，复制、剪切、删除、添加文字，锁定图片、点赞，给标签修改背景颜色和内容。而对几乎所有对象，你都可以通过拖拽将它们堆叠起来，通过双击展开。
为了方便更多人使用和提高效率，微软之前默默添加了一个模板功能，提供了头脑风暴、看板、回顾、高效会议、SWOT 分析法、项目相关、KWL 知识学习法、周计划等等模板。所以很明显，Whiteboard 将不只是一个企业级应用。
总体来说，PC端上的便签和团队协作功能都挺好的，其它的功能可能需要在 iPad 或手机上更实用。遗憾的是，Whiteboard 还没有安卓版本。
最后，如果你喜欢我的推荐，欢迎加入我们(关注走起)。感谢你的关注与分享，如果你有更好的推荐，欢迎留言与投稿。微信公众号：轻量生活Share，ID：light72580。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e99e8507b049ac01ac303031a548c4/" rel="bookmark">
			Halcon DeepLearning初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Halcon提供三种类型神经网络： 1、Classification（分类） 2、Object Detection（目标检测） 3、Semantic Segmentation（语义分割） 工作流程： 一、准备网络和数据
使用的网络：可以使用预训练过的网络或者创建一个新的网络，我使用的是18.11.1.0版本有三种网络供选择：
'pretrained_dl_classifier_compact.hdl'：需要图像格式为'real'，该网络不包含全连接层，要求最小图片尺寸大于15*15
'pretrained_dl_classifier_enhanced.hdl'：比上个能处理更复杂的图像，需要图像格式为'read'，最小尺寸要求大于47*47，
'pretrained_dl_classifier_resnet50.hdl'：需要图像格式为'real'，最小尺寸要求大于32*32.
上述三种网络均需要设置基本参数：'image_width'，'image_height'，'image_num_channels'，'image_range_min'，'image_range_max‘，即图像宽高、通道数、灰度范围。准备数据：分类好训练样本的种类准备对应需求的大量图片（例如：图像维度、灰度范围等），在原图基础上还需要进行预处理，剔除背景影响，最大程度突出主体部分。
预处理操作：阈值化，提取特征roi，转换图像格式到'real'，合成3通道图像等等。做好训练集、验证集、测试集：一般地按照70%，15%，15%比例分类。 二、训练网络和评估训练进度
设置超参数适用任务和系统
set_dl_classifier_param：设置'batch_size'，'batch_size_device'，'classes'，'gpu'，'image_width'，'image_height‘，'image_num_channels'，'image_dimensions'，'learning_rate'，'momentum’，'runtime'，'runtime_init'，'weight_prior' 参数名名称定义运用批量大小batch_size批处理中图像(和相应标签)的数量，即在一次训练迭代中同时处理的图像数量。 set_dl_classifier_param(DLClassifierHandle,'batch_size‘,Batch_Size)
批量大小设备
batch_size_device传输到设备存储器的批处理中的图像数目。设置为小于等于批量大小。 set_dl_classifier_param
(DLClassifierHandle,'batch_size_device‘,Batch_Size)
类名classes与要识别的对象类相对应的标签组。set_dl_classifier_param(DLClassifierHandle,'classes‘,Classes)gpugpuGPU标识符 set_dl_classifier_param
(DLClassifierHandle,'gpu',GPU)
图像宽度image_width过程处理图像宽度 set_dl_classifier_param(DLClassifierHandle,'image_width‘,Width)
图像高度image_height过程处理图像高度 set_dl_classifier_param(DLClassifierHandle,'image_height‘,Height)
图像通道数image_num_channels处理图像的通道数 set_dl_classifier_param
(DLClassifierHandle,'image_num_channels‘,Channels)
图像维度image_dimensions包含图像尺寸“image_width”、“image_height”和通道数量“image_num_channels”的元组。 set_dl_classifier_param
(DLClassifierHandle,'image_dimensions‘,Dimensions)
学习率learning_rate训练中决定梯度影响因素的初始值。默认0.001set_dl_classifier_param(DLClassifierHandle,'learning_rate',Rate)动量momentum损失函数的动量参数。默认0.9set_dl_classifier_param(DLClassifierHandle,'momentum‘,Momentum)运行环境runtime执行的设备。默认'gpu‘ set_dl_classifier_param(DLClassifierHandle,'runtime','cpu')
set_dl_classifier_param(DLClassifierHandle,'runtime','gpu')
运行环境runtime_init执行环境初始化使用'immediately'，初始化GPU。否则不初始化。set_dl_classifier_param(DLClassifierHandle,'runtime_init','immediately')正则化参数weight_prior用于损失函数防止过拟合，默认0非0，则使用set_dl_classifier_param(DLClassifierHandle,'weight_prior',WeightPrior)一般的设置：
* ** 训练 Halcon语法** * * 读取训练模型 read_dl_classifier ('pretrained_dl_classifier_compact.hdl', DLClassifierHandle) * 训练图像目录 RawDataFolder := 'food/' + ['apple_braeburn','apple_golden_delicious','apple_topaz','peach','pear'] * 获取图像内容和标签 read_dl_classifier_data_set (RawDataFolder, 'last_folder', RawImageFiles, Labels, LabelIndices, Classes) * 预处理数据集的输出目录路径 PreprocessedFolder := 'fruit_preprocessed' * 关闭覆盖图像.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e99e8507b049ac01ac303031a548c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/067d2471badb1e654f9429a11fbf3c59/" rel="bookmark">
			win10怎么更新显卡驱动_win10系统AMD显卡驱动安装失败的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在操作win10系统电脑的时候,win10系统AMD显卡驱动安装失败的问题对于我们来说其实是比较少见的，一般情况下的正常使用都不会遇到win10系统AMD显卡驱动安装失败的状况。但在win10系统中如果由于我们个人的不当操作导致win10系统AMD显卡驱动安装失败问题出现的话，我们应该怎样去处理解决呢？其实解决这个问题的方法并不复杂，我们只需要1、开始按钮点右键 选“设备管理器”，找到显示适配器。 2、点开“显示适配器” 对驱动程序点右键选“更新驱动程序软件”。就可以轻松处理解决，看完简单教程还不理解的话可以跟着小编一起看下面的教程，教程中会把win10系统AMD显卡驱动安装失败问题详细的操作方法告诉大家，直接傻瓜式跟着教程步骤进行处理就能解决问题。
具体如下:
1、开始按钮点右键 选“设备管理器”，找到显示适配器。
2、点开“显示适配器” 对驱动程序点右键选“更新驱动程序软件”。
3、点击“浏览计算机以查找软件”。
4、点击下面的“从计算机的设备驱动程序列表中选取”。
5、出现下面的界面时，由于我的系统已经装好驱动了，所以截的图是安装之后的。一般情况下你的列表里只有第一个和第四个驱动程序(甚至只有第四个)。
选择“基本显示适配器"，点"下一步"就将微软显卡驱动降为基本显卡驱动了。
6、安装了“Microsoft基本显示适配器”后，也就算是卸载了微软的AMD驱动“ATI Mobility Radeon HD 4500 Series(MicrosoftCorporation WDDM V1.1)”，此时电脑的显示不正常，你就可以正常安装AMD的官方显卡驱动了。
win10系统下AMD显卡驱动安装失败的解决方法就为大家介绍到这里了。遇到同样问题的朋友们，不妨也尝试一下，希望能够帮助到大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e8c99b16d6cc36c251c8a780d9da9a/" rel="bookmark">
			灰度直方图均衡化及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 直方图均衡化定义公式略微证明计算步骤 matlab实现 直方图均衡化 定义 当直方图中像素值集中在狭窄的灰度级范围内或分布极不均匀时，图像呈现较差的对比度。直方图均衡化的目的就是将直方图的灰度级概率分布变换为均匀分布。(如下图所。注意，p(x)是概率密度函数，P(x)是概率分布函数）
由于直方图中概率较小的灰度级合并为更少的几个或一个灰度级内，从而降低了图像的灰度级分辨率，且某些细节信息处于概率较小的灰度级中，这样的灰度级归并到其他灰度级内，从而造成图像细节信息的丢失。
公式 输入r，输出s
s = T ( r ) = ( L − 1 ) ∑ j = 0 k P ( r j ) = L − 1 M N ∑ j = 0 k n j , ( k = 0 , 1... L − 1 ) s=T(r)=(L-1)\sum_{j=0}^k{P(r_j)}=\frac{L-1}{MN}\sum_{j=0}^kn_j ,(k=0,1...L-1) s=T(r)=(L−1)j=0∑k​P(rj​)=MNL−1​j=0∑k​nj​,(k=0,1...L−1)
对于输入图像中每个具有r值的像素值产生一个输出灰度值s.
略微证明 先 定 义 两 个 函 数 s = T ( r ) , r = T − 1 ( s ) 。 两 个 互 为 反 函 数 先定义两个函数s=T(r),r=T^{-1}(s)。 两个互为反函数 先定义两个函数s=T(r),r=T−1(s)。两个互为反函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e8c99b16d6cc36c251c8a780d9da9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9160e3ba3d1bbb9a3b2b721aeaa0ee/" rel="bookmark">
			【c语言】求出每位学生的三门课程的总分，然后按总分由高到低排序，并将排序结果按学号、姓名、数学成绩、语文成绩、英语成绩、总分和名次打印输出到屏幕和文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Question:
输入n个学生的学号、姓名、数学成绩、语文成绩和英语成绩，求出每位学生的三门课程的总分，然后按总分由高到低排序，并将排序结果按学号、姓名、数学成绩、语文成绩、英语成绩、总分和名次打印输出到屏幕和文件 student.dat中。要求用结构体描述学生信息，输出打印时每位学生信息占一行且上下列对齐，总分相同时名次相同，例如，假设有四个成绩为280、275、275、250，则对应的名次为1、2、2、4。
Code:
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; struct student { int id;	// 学号 char name[20];	// 姓名 int math;	// 数学成绩 int chinese;	// 语文成绩 int English;	// 英语成绩 }a[5]; // 输入学生的相关信息 void input(){ for(int i=0; i&lt;4; i++){ scanf("%d %s %d %d %d", &amp;a[i].id, a[i].name, &amp;a[i].math, &amp;a[i].chinese, &amp;a[i].English); } } // 对学生的成绩进行排排名 void sort(){ for(int i=0; i&lt;4; i++){ for(int j=i; j&lt;4; j++){ if((a[i].math+a[i].chinese+a[i].English) &lt; (a[j].math+a[j].chinese+a[j].English)){ a[5].id=a[j].id; strcpy(a[5].name, a[j].name); a[5].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa9160e3ba3d1bbb9a3b2b721aeaa0ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91711d314f82d59077246176376d7fb/" rel="bookmark">
			python在什么系统写代码合适-python用什么软件写代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDE没有统一的标准，自己习惯就是最好的。本文列出一些较常用的IDE，供大家参考。
一般而言，WingIDE、PyCharm、Spyder、Vim是比较常用的IDE。
Spyder
Spyder是Python(x,y)的作者为它开发的一个简单的集成开发环境。和其他的Python开发环境相比，它最大的优点就是模仿MATLAB的"工作空间"的功能，可以很方便地观察和修改数组的值。
最出名的python数据科学发行版本Anaconda自带了Spyder。
WingIDE
WingIDE是Python编写的python专用IDE。 WingIDE提供诸如强大的代码完成，出色的调试器等功能，并且它还可以在Python中编写脚本和扩展。
为什么选择最好的Python IDE？
内置强大的调试器智能编辑器您可以轻松快速地查找和修复错误轻松导航代码您可以使用自己喜欢的键绑定进行编辑并自定义工作区配置简单运行速度比Pycharm等java类的编辑快很多，占用资源少。
Vim IDE
Vim是一个高度可配置的文本编辑器，用于创建和更改任何类型的文本非常有效。
它是Vi的超集 - 是一个非常可靠和强大的文本编辑器，可用于各种平台。
Vim是一个命令行编辑器，因此可用于远程开发。替换100MB +文件中的所有字符串出现是快速而简。vim是基于键盘的，因此更容易理解。Vimscript提供了丰富的脚本功能
据说高手大多用vim。
Eric Python IDE
Python编写，基于跨平台的Qt GUI工具包，集成了高度灵活的Scintilla编辑器控件。
大括号匹配，错误突出显示和可配置语法突出显示。拼写检查库的集成内置Python调试器，包括支持调试多线程和多处理应用程序。分析和代码覆盖支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d282cc46ec406c115d4f089d81ad00/" rel="bookmark">
			python是c语言写的吗-python是用c写的吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python是用c写的，下面给大家介绍一下Python与c的联系：
python的诞生
1991年，第一个Python编译器(同时也是解释器)诞生。它是用C语言实现的，并能够调用C库(.so文件)。从一出生，Python已经具有了：类(class)，函数(function)，异常处理(exception)，包括表(list)和词典(dictionary)在内的核心数据类型，以及模块(module)为基础的拓展系统。
Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的CWI (Centrum Wiskunde &amp; Informatica, 数学和计算机研究所)开发的。Guido在CWI工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。
python与c
Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例(特别是C语言的惯例)。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。
Python从一开始就特别在意可拓展性(extensibility)。Python可以在多个层次上拓展。从高层上，你可以引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。
最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python (也包括工作时间，因为他们将Python用于工作)。随后，Python拓展到CWI之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节 (Guido有一件T恤，写着：人生苦短，我用Python)。这一特征吸引了广大的程序员。Python开始流行。
python的发展
到今天，Python的框架已经确立。Python语言以对象为核心组织代码(Everything is object)，支持多种编程范式(multi-paradigm)，采用动态类型(dynamic typing)，自动进行内存回收(garbage collection)。Python支持解释运行(interpret)，并能调用C库进行拓展。Python有强大的标准库 (battery included)。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django, web.py, wxpython, numpy, matplotlib,PIL.
Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de6f43fb16d912adceb4afd6915c0706/" rel="bookmark">
			OpenCV学习——轮廓检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 轮廓检测是传统视觉中非常常用的功能，这里简单记录一下opencv中的轮廓检测算法使用方法，至于理论，后续有机会再去细品。
国际惯例：
OpenCV官方的轮廓检测教程python版
OpenCV中的二值化方法教程
OpenCV轮廓层级官方文档
维基百科：图像矩(Image Moment)
调用流程和方法 OpenCV里面通常要求是针对二值图像进行二值化，所以轮廓检测包含如下步骤：
载入图像灰度化二值化轮廓检测 代码实现如下：
img =cv2.imread("blackBG.jpg") # grayscale # https://docs.opencv.org/4.5.0/d7/d4d/tutorial_py_thresholding.html gray_img = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) ret,bin_img = cv2.threshold(gray_img,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU) 二值化 注意二值化方法，这里使用的是threshold函数，它的第三个参数代表的意义可以查询此处的官方文档，这里将方法截图贴出来
其实除了threshold还有一个adaptiveThreshold函数可以做二值化，调用方法：
#dst=cv.adaptiveThreshold(src,maxValue,adaptiveMethod,thresholdType,blockSize,C[, dst]) bin_img1 = cv.adaptiveThreshold(img,255,cv.ADAPTIVE_THRESH_MEAN_C,\ cv.THRESH_BINARY,11,2) bin_img2 = cv.adaptiveThreshold(img,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,\ cv.THRESH_BINARY,11,2) 从第三个参数可以发现也有两个二值化方法：
ADAPTIVE_THRESH_MEAN_C：阈值是每个像素邻域区域的均值减去常量CADAPTIVE_THRESH_GAUSSIAN_C:：阈值是每个像素相邻域区域的高斯加权和减去常量C 轮廓检测 python的调用方法如下：
contours, hierarchy	=cv.findContours(image,mode,method[,contours[, hierarchy[, offset]]]) 返回的参数
contours：检测到的轮廓，每个轮廓是由一些点构成的向量组成hierarchy：记录轮廓之间的关系，四个维度分别代表：同级后一个轮廓的序号、同级上一个轮廓的序号、第一个孩子序号，父亲序号 第二个数参数mode是检测轮廓的层级关系排列规则：
RETR_EXTERNAL：仅仅检测外圈轮廓RETR_LIST：检测所有轮廓，但是没有层级关系RETR_CCOMP：仅仅两层包含关系，即只有外层和内层，假设有夹层，那么夹层也算外层，只要某个轮廓还包含有轮廓，都算外部轮廓RETR_TREE：检测所有的轮廓，并建议非常完整的层级关系RETR_FLOODFILL：无描述 第三个参数method是轮廓点的存储方式：
CHAIN_APPROX_NONE：相邻的轮廓点坐标只相差一个像素，所以是连续轮廓点CHAIN_APPROX_SIMPLE：横、竖、对角线段只保存断点数据，比如矩形就只保存四个顶点。还有两种没做过多叙述：CHAIN_APPROX_TC89_L1和CHAIN_APPROX_TC89_KCOS是Teh-Chin chain近似算法里面采取的两种表示 画图函数 就一个函数drawContours，调用方法如下：
image=cv.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]]	) 输入参数：
contours：是list类型的数组，里面存储了很多array数组去代表各个轮廓contourIdx：从上面的轮廓list中取出哪一个画出来，-1代表全部color：线条颜色thickness：线条粗细，-1代表填充式画轮廓，整个轮廓内部被指定颜色填充lineType：线条类型，虚线、实线之类的 【注意】如果将原图传入画图函数，这个原图会被画上轮廓，所以画图时候最好建立一个副本，在副本上画图。
轮廓检测函数验证 主要验证检测时的层级结构和记录关键点的方式，也就是第2和3个参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de6f43fb16d912adceb4afd6915c0706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02fac0c712655f789ca0ab3f2823f2b7/" rel="bookmark">
			java 获取list中的两两组合，给定一个数组，获取排列组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，获取一个数组中两两组合 示例:给定一个List&lt;1,2,3,4&gt;
输出:1,2 1,3 1,4 2,3 2,4 3,4
demo:
public static void main(String[] args) { List&lt;Pair&lt;String, String&gt;&gt; pairs = combineTwoElement(Lists.newArrayList("1", "2","3","4")); List&lt;Pair&lt;String, String&gt;&gt; pairs1 = combineTwoElement(Lists.newArrayList("1", "2","3","4","5")); System.out.println(pairs); System.out.println(pairs1); } public static List&lt;Pair&lt;String, String&gt;&gt; combineTwoElement(List&lt;String&gt; list) { List&lt;Pair&lt;String, String&gt;&gt; resultList = Lists.newArrayListWithExpectedSize(list.size()*list.size()/2); if (CollectionUtils.isEmpty(list)) { return null; } if (list.size() &gt;= 2) { for (int j = 0; j &lt; list.size(); j++) { resultList.addAll(ll(list.subList(j,list.size()))); } } return resultList; } public static List&lt;Pair&lt;String, String&gt;&gt; ll (List&lt;String&gt; list){ List&lt;Pair&lt;String, String&gt;&gt; resultList = Lists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02fac0c712655f789ca0ab3f2823f2b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9efa1751e908d87ae1f523a38fcbef7a/" rel="bookmark">
			ES6中的扩展运算符（...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		... 运算符， 是ES6里一个新引入的运算法， 也叫展开/收集运算符
数组的扩展运算符 展开
收集（扩展运算符参数必须在最后一位）
合并数组
复制数组（会开辟新的内存地址）
和set结构结合实现数组或字符串去重
对象的扩展运算符 合并对象（多个对象有同名属性，则后面的会覆盖前面的）
拷贝对象
和解构赋值结合生成对象（扩展运算符参数必须在最后一位）
根据条件添加对象属性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc9c3455284c5f3364706c41f3279e8/" rel="bookmark">
			二叉搜索树的删除操作详解，图文并茂，化繁为简
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、二叉树搜索树概念二、二叉树删除操作的讲解1.分情况讨论：2.完整代码 总结 前言 一、二叉树搜索树概念 二叉搜索树又称为二叉排序树，它具有二叉树以下的性质：
-若它的左子树不为空，则左子树上所有的结点的值都小于根节点的值；
-若它的右子树不为空，则右子树上所有的结点的值都大于根节点的值；
-它的左右子树也分别为二叉搜索树。
二叉树搜索树的中序一定有序。
int[] a={5,3,7,1,4,6,8,9};
中序遍历：{1，3，4，5，6，7，8，9}；
搜索二叉树的遍历和插入比较简单，所以在这主要讲解一下二叉搜索树的删除操作，我看老师讲解的二叉树的删除操作视频看了好几遍，还看了好几篇讲解二叉搜索树删除操作的，终于理解了，所以想用自己的方法记录一下这个学习的过程。
二、二叉树删除操作的讲解 1.分情况讨论： 删除操作可以分为3种情况：node为待删除的节点，parent为待删除结点的父节点
1.node左右孩子均不存在
2.node只有左孩子或者只有有孩子
3.node左右孩子均存在
第一种情况：当待删除结点node的左右孩子均不存在的时候，那么它是叶子结点或者只有一个根结点的树；删除的时候如果node是根节点，则让根结点为空；如果node为其父节点的左孩子，则把父亲左孩子置为空；否则把父亲右孩子置为空。（如果这一段文字看不懂，可以自己画个图试试看，相信你自己）
代码如下：
if(node.left==null&amp;&amp;node.left==null){ if(node==root){ root=null; }else if(node==parent.left){ parent.left=null; }else{ parent.right=null; } } 第二种情况：当待删除的结点node只有左孩子或者右孩子时，那么在删除的时候要断两个联系，node和parent，node和它的孩子结点的联系；再新建一个一个联系；如下图所示：当要删除的结点没有左孩子时，就是下图中左边的这种情况：
1.首先如果待删除结点为根节点，则让待删除的节点的左孩子为根；
2.如果待删除结点为其父节点的左孩子，则让待删除的结点的左孩子指向其父节点。
3.如果待删除结点为其父节点的右孩子，则让待删除的结点的左孩子指向其父节点。
if(node.left!=null&amp;&amp;node.right==null){ //有左孩子，没有右孩子 if(node==root){ root=node.left; }else if(node==parent.left){ parent.left=node.left; }else{ parent.right=node.left; } }else if(node.left==null&amp;&amp;node.right!=null){ //有右孩子，没有左孩子 if(node==root){ root=node.right; }else if(node==parent.left){ parent.left=node.right; }else{ parent.right = node.right; } } 第三种情况：
当待删除的结点左右孩子都有时，此时采用替换法，定义两个节点，ghost和ghostParent，ghost中存放待删除结点左子树中最大的结点（或者右子树中最小的值替换），ghostParent保存ghost的父节点，找到ghost后，用ghost的值替换待删除结点node的值，然后判断待删除结点是否有左孩子，如果有，则让其左孩子指向其父节点（ghostParent）。
Node ghost=node.left; Node ghostParent=null; while(ghost.right!=null){ ghostParent=ghost; ghost=ghost.right; } //进行替换 node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc9c3455284c5f3364706c41f3279e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2262143be704726251fd7b1b13dbc286/" rel="bookmark">
			BeanUtils工具类中的copyProperties方法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、两个包下的BeanUtils.copyProperties对比2、BeanUtils.copyProperties的深浅拷贝问题2.1、浅拷贝和深拷贝2.2、BeanUtils.copyProperties深浅拷贝问题 3、深拷贝的方法 1、两个包下的BeanUtils.copyProperties对比 BeanUtils是开发中常用到的工具类，而获取这一工具类主要是通过导入org.springframework.beans.BeanUtils或者org.apache.commons.beanutils.BeanUtils包来获取，但是不同的包中BeanUtils的方法使用是不一样的，接下来就对这两个包中的copyProperties方法进行对比。
先来看一下这两个包中的copyProperties方法的定义：
//org.springframework.beans.BeanUtils public static void copyProperties(Object source, Object target){....} //org.apache.commons.beanutils.BeanUtils public static void copyProperties(Object dest,Object orig){....} 由定义可知，在org.springframework.beans.BeanUtils包下的copyProperties第一个参数是被copy的对象，而org.apache.commons.beanutils.BeanUtils中是第二个参数，所以使用时不要弄混。
1）接下来定义两个实体类Student和Teacher，用来模拟目标对象（target/dest）中包含被copy的对象（source/orig）的所有字段时
@Data public class Student { private String id; private String name; private String age; public Student(String id, String name, String age) { this.id = id; this.name = name; this.age = age; } } @Data public class Teacher { private String id; private String name; private String age; private String sex; //多出来的参数 public Teacher() {} public Teacher(String id, String name, String age, String sex) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2262143be704726251fd7b1b13dbc286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6406e899cd77e5e9f257b87c8196d87/" rel="bookmark">
			使用Guava RateLimiter限流入门到深入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流
缓存: 缓存的目的是提升系统访问速度和增大系统处理容量
降级: 降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开
限流: 限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理
常见限流算法 漏桶算法 漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。
令牌桶算法 对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。
RateLimiter使用以及源码解析 Google开源工具包Guava提供了限流工具类RateLimiter，该类基于令牌桶算法实现流量限制，使用十分方便，而且十分高效。
RateLimiter使用 首先简单介绍下RateLimiter的使用
public void testAcquire() { RateLimiter limiter = RateLimiter.create(1); for(int i = 1; i &lt; 10; i = i + 2 ) { double waitTime = limiter.acquire(i); System.out.println("cutTime=" + System.currentTimeMillis() + " acq:" + i + " waitTime:" + waitTime); } } 输出结果：
cutTime=1535439657427 acq:1 waitTime:0.0 cutTime=1535439658431 acq:3 waitTime:0.997045 cutTime=1535439661429 acq:5 waitTime:2.993028 cutTime=1535439666426 acq:7 waitTime:4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6406e899cd77e5e9f257b87c8196d87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b393426791c78d22a4aad45da4d3a3/" rel="bookmark">
			python怎么设置为中文-python怎么变成中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python变成中文版的实现方法：首先下载pycharm汉化包；然后将"resources_en.jar”文件更名为"resources_cn.jar”；最后将"resources_cn.jar”文件复制回lib文件夹内即可。
pycharm是Python编程中常用的一款IDE，今天小编将带大家学习一下怎么将PyCharm汉化，以便达到Python中文版方便咱们使用。
pycharm汉化过程如下：
第一步，下载pycharm汉化包 链接：https://github.com/yaoguangju/shared_documents
第二步，将pycharm安装目录下的lib文件夹内下的resources_en.jar文件复制出来，并更名为resources_cn.jar
第三步，双击打开resources_cn.jar（注意是打开而不是解压出来），将下载的汉化包zh_CN目录下的所有文件拖到刚才打
开的resources_cn.jar文件内的messages目录中，并保存。
第四步，将resources_cn.jar文件复制回lib文件夹内。
PS：建议不要使用汉化版，会导致一些小问题，例如设置界面显示不完整等。
将PyCharm安装目录下的lib里resources_en.jar文件复制，更名resources_cn.jar后移出，完成所有步骤再移回；打开resources_cn.jar将汉化包里文件拖到resources_cn.jar内messages保存。
以上就是python怎么变成中文版的详细内容，更多请关注php中文网其它相关文章！
本文原创发布php中文网，转载请注明出处，感谢您的尊重！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe2eb82fa931e5bbaddcca6b0829490/" rel="bookmark">
			在python中for i in range是什么意思-Python for i in range ()用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for i in range ()作用：
range()是一个函数， for i in range () 就是给i赋值：
比如 for i in range （1，3）：
就是把1,2依次赋值给i
range () 函数的使用是这样的:
range(start, stop[, step])，分别是起始、终止和步长
range（3）即：从0到3，不包含3，即0,1,2
&gt;&gt;&gt; for i in range(3):
print(i)
0
1
2
range(1,3) 即：从1到3，不包含3，即1,2
for i in range(1,3):
print(i)
1
2
range（1,3,2）即：从1到3，每次增加2，因为1+2=3，所以输出只有1
第三个数字2是代表步长。如果不设置，就是默认步长为1
&gt;&gt;&gt; for i in range(1,3,2):
print(i)
1
如果改成range(1,5,2)，就会输出1和3
&gt;&gt;&gt; for i in range(1,5,2):
print(i)
1
3
For i in range(100)
则读取normMat[i,:]样本的编号为：0-99，共100个
以上这篇Python for i in range ()用法详解就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持我们。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fe2eb82fa931e5bbaddcca6b0829490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ef1a0e6b871cf14cec1ecfa1d6e4a6/" rel="bookmark">
			Vuex中五个属性的详细说明，大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.vuex-state单一状态树 如果状态信息保存到多个Store对象，那么后期的管理和维护会变得特别困难所以Vuex使用了单一状态树来管理应用层级的全部状态，即一个项目中只有唯一一个store，用来存储所有的状态信息单一状态树能够让我们更直接的方式找到某个片段的状态，方便维护和管理 二.getters的基本使用 1.getters可以视为计算属性，当数据需要变化后再传给其他组件时，可以使用getters，默认传入state参数
getters:{ powerCounter(state){ return state.counter * state.counter }, more20stu(state){ return state.students.filter(s =&gt; s.age &gt; 20) } } 在调用时，使用$store.getters.方法名，如$store.getters.powerCounter即可
2.getters传递参数
getters里面除了返回固定的值，还可以返回函数
getters中的某个函数如果想接收参数，需要用返回函数的方法
getters:{ powerCounter(state){ return state.counter * state.counter }, more20stu(state){ return state.students.filter(s =&gt; s.age &gt; 20) }, more20stuLength(state,getters){ return getters.more20stu.length }, moreAgeStu(state){ // 返回函数 return function(age) { return state.student.filter(s =&gt; s.age &gt; age) } } } 三.vuex-mutation vuex的store状态的唯一更新方式：提交mutation
mutation主要包括两部分：
字符串的事件类型一个回调函数，该回调函数的第一个参数就是state mutation传递参数
在通过mutation更新数据时，有可能我们希望携带一些额外的参数
参数被称为是mutation的载荷（payload）
组件中的代码 methods:{ addCount(count){ // 传递单个参数 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05ef1a0e6b871cf14cec1ecfa1d6e4a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad91e3fd55260811736b8c47b8f2829/" rel="bookmark">
			JAVA-输出一个三角形（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Demo { /* 注意：编程时不可以使用汉语和拼音，要用英文单词或者英文单词缩写 如图,想要输出一个四行的三角形： 第1行 * 第2行 *** 第3行 ***** 第4行 ******* 思路： 1.将这个图形看成四个直角三角形 2.需要两层for循环，第一层的作用是当前行数 第二层的作用是输出当前行需要的*号 */ public static void main(String[] args) { //需要四行,所以循环四次 for (int i = 1; i &lt;= 4; i++) { System.out.print("第" + i + "行 "); //1.输出第一个直角三角形 //规则:行数的倒序，输出相同数量的* //也就是一共四行，那么第一行就输出 4个，第二行输出3个，第三行输出2个，第四行输出1个 for (int j = 4; j &gt;= i; j--) { System.out.print(" "); } //2.输出第二个直角三角形 //规则:每行输出，与当前行数相同数量的 * // for (int j = 1; j &lt;= i; j++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aad91e3fd55260811736b8c47b8f2829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9351ca844834b7c51924b4cf823a85a5/" rel="bookmark">
			Spark高频面试题(建议收藏)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、你是怎么理解Spark，它的特点是什么？ Spark是一个基于内存的，用于大规模数据处理（离线计算、实时计算、快速查询（交互式查询））的统一分析引擎。
它内部的组成模块，包含SparkCore，SparkSQL，SparkStreaming，SparkMLlib，SparkGraghx等...
它的特点：
快
Spark计算速度是MapReduce计算速度的10-100倍
易用
MR支持1种计算模型，Spsark支持更多的计算模型(算法多)
通用
Spark 能够进行离线计算、交互式查询（快速查询）、实时计算、机器学习、图计算
兼容性
Spark支持大数据中的Yarn调度，支持mesos。可以处理hadoop计算的数据。
二、Spark有几种部署方式，请分别简要论述 1） Local:运行在一台机器上，通常是练手或者测试环境。
2）Standalone:构建一个基于Mster+Slaves的资源调度集群，Spark任务提交给Master运行。是Spark自身的一个调度系统。
3）Yarn: Spark客户端直接连接Yarn，不需要额外构建Spark集群。有yarn-client和yarn-cluster两种模式，主要区别在于：Driver程序的运行节点。
4）Mesos：国内大环境比较少用。
三、Spark提交作业的参数 因为我们Spark任务是采用的Shell脚本进行提交，所以一定会涉及到几个重要的参数，而这个也是在面试的时候容易被考察到的“细节”。
executor-cores —— 每个executor使用的内核数，默认为1，官方建议2-5个，我们企业是4个 num-executors —— 启动executors的数量，默认为2 executor-memory —— executor内存大小，默认1G driver-cores —— driver使用内核数，默认为1 driver-memory —— driver内存大小，默认512M 四、简述Spark的作业提交流程 Spark的任务提交方式实际上有两种，分别是YarnClient模式和YarnCluster模式。大家在回答这个问题的时候，也需要分类去介绍。千万不要被冗长的步骤吓到，一定要学会总结差异，发现规律，通过图形去增强记忆。
YarnClient 运行模式介绍
在YARN Client模式下，Driver在任务提交的本地机器上运行，Driver启动后会和ResourceManager通讯申请启动ApplicationMaster，随后ResourceManager分配container，在合适的NodeManager上启动ApplicationMaster，此时的ApplicationMaster的功能相当于一个ExecutorLaucher，只负责向ResourceManager申请Executor内存。
ResourceManager接到ApplicationMaster的资源申请后会分配container，然后ApplicationMaster在资源分配指定的NodeManager上启动Executor进程，Executor进程启动后会向Driver反向注册，Executor全部注册完成后Driver开始执行main函数，之后执行到Action算子时，触发一个job，并根据宽依赖开始划分stage，每个stage生成对应的taskSet，之后将task分发到各个Executor上执行。 YarnCluster 模式介绍
在YARN Cluster模式下，任务提交后会和ResourceManager通讯申请启动ApplicationMaster，随后ResourceManager分配container，在合适的NodeManager上启动ApplicationMaster，此时的ApplicationMaster就是Driver。
Driver启动后向ResourceManager申请Executor内存，ResourceManager接到ApplicationMaster的资源申请后会分配container，然后在合适的NodeManager上启动Executor进程，Executor进程启动后会向Driver反向注册，Executor全部注册完成后Driver开始执行main函数，之后执行到Action算子时，触发一个job，并根据宽依赖开始划分stage，每个stage生成对应的taskSet，之后将task分发到各个Executor上执行。
五、你是如何理解Spark中血统(RDD)的概念?它的作用是什么？ RDD 可是Spark中最基本的数据抽象，我想就算面试不被问到，那自己是不是也应该非常清楚呢！
下面提供菌哥的回答，供大家参考：
概念
RDD是弹性分布式数据集，是Spark中最基本的数据抽象，代表一个不可变、可分区、里面的元素可并行计算 的集合。
作用
提供了一个抽象的数据模型，将具体的应用逻辑表达为一系列转换操作(函数)。另外不同RDD之间的转换操作之间还可以形成依赖关系，进而实现管道化，从而避免了中间结果的存储，大大降低了数据复制、磁盘IO和序列化开销，并且还提供了更多的API(map/reduec/filter/groupBy...)
如果还想锦上添花，可以添上这一句：
“ RDD在Lineage依赖方面分为两种Narrow Dependencies与Wide Dependencies，用来解决数据容错时的高效性以及划分任务时候起到重要作用
” 六、简述Spark的宽窄依赖，以及Spark如何划分stage，每个stage又根据什么决定task个数? Spark的宽窄依赖问题是SparkCore部分的重点考察内容，多数出现在笔试中，大家需要注意。
窄依赖:父RDD的一个分区只会被子RDD的一个分区依赖
宽依赖:父RDD的一个分区会被子RDD的多个分区依赖(涉及到shuffle)
那Stage是如何划分的呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9351ca844834b7c51924b4cf823a85a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc07ae5cb1dc16dca2b14f5a3c7f8c3/" rel="bookmark">
			Only digits (0-9) can be put inside [] in the path string: daijiaoList[${index}].number
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单独修改某一项的值的时候出现这样的错误 代码是这样的
var up = "daijiaoList[${index}].number" this.setData({ [up]:10 }) 这时候代码才报错 修改一下后
this.setData({[`daijiaoList[${index}].number`]:10}) 这样就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabecf01dbb5c42adf6f7ef87d1164e1/" rel="bookmark">
			局域网内的攻击—Arp欺骗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00:ARP协议 在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的MAC地址。MAC地址就是ARP协议获得的。其实就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。所以说从某种意义上讲ARP协议是工作在更低于IP协议的协议层。这也是为什么ARP欺骗更能够让人在神不知鬼不觉的情况下出现网络故障，危害会很隐蔽。
0x01:ARP欺骗原理 ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。
当局域网中一台机器，反复向其他机器，特别是向网关，发送这样无效假冒的ARP应答信息包时，严重的网络堵塞就会开始。由于网关MAC地址错误，所以从网络中计算机发来的数据无法正常发到网关，自然无法正常上网。这就造成了无法访问外网的问题，由于很多时候网关还控制着我们的局域网LAN上网，所以这时我们的LAN访问也就出现问题了。
0x02:断网攻击 可以使用nmap命令寻找存活主机
nmap -sP 192.168.186.* 也可以使用fping探测一下
fping -asg 192.168.186.0/24 使用命令查看一下当前的网关
cat /etc/resolv.conf 查看当前win7的IP地址，确实是存在131的IP
在攻击前可以先看一下目标机的ARP缓存
ping一下百度的域名
可以ping通百度，说明目标主机的网络环境没有问题。
下面开始断网攻击，使用arpspoof工具，工具使用方法：
arpspoof -i 网卡 -t 目标IP 网关 如果下载了但还是没有这个arpspoof命令，就说明没有加入到环境变量中，修改一下就好了
export PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin" Linux修改环境变量
开启断网攻击
arpspoof -i eth0 -t 192.168.186.131 192.168.186.2 观察目标主机，已经ping不通百度
停止攻击，再次查看
说明断网攻击已经成功
0x03:ARP欺骗（不断网） ARP欺骗攻击是冒充网关向目标主机发送假的ARP数据包。
攻击流程 获取目标主机的流量获取流量之后进行转发 相当于一个中间人，可以在中途拦截一下流量，这样所有的流量都会被监控，
开启IP转发功能
cat /proc/sys/net/ipv4/ip_forward echo 1 &gt; /proc/sys/net/ipv4/ip_forward（转发） #echo 代表写入 这样可以实现流量转发，而不是截断流量 如果要截断流量，写入0即可 #截断流量 echo 0 &gt;/proc/sys/net/ipv4/ip_forward（断网） 欺骗攻击
arpspoof -i eth0 -t 192.168.186.2 192.168.186.131 #网关在前，IP在后 接下来打开另一个终端，使用一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabecf01dbb5c42adf6f7ef87d1164e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c6f926801f7984c8b3d6e40497a19a/" rel="bookmark">
			OpenGL环境的配置（GLUT安装教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL作为最底层的图形显示库，学习了解能对图形建模有着更深刻的理解
目录 概述1.下载Glut的依赖库2.配置 OpenGL环境3.测试运行 概述 编写openGL程序使用的是IDE是Microsoft Visual Studio（毕竟宇宙第一IDE）。安装VS后需要安装OpenGL的图形库依赖了。
由于目前学习采用的是Glut，所以以下为Glut的安装教程。
1.下载Glut的依赖库 OpenGl的官网：https://www.opengl.org/
在官网上目前下载Glut的入口在：https://www.opengl.org/resources/libraries/glut/glut_downloads.php#windows
我们也可以直接下载Glut：https://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip
下载后里面有以下文件
话说库时间有点不对呀😂
2.配置 OpenGL环境 将下载的 glutdlls37beta.zip 解压可发现里面包含glut.dll、 glut32.dll 、glut.lib 、glut32.lib 、glut.h 5个文件。
然后找到VS安装的目录，路径为安装路径\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.27.29110，
首先在include下创建一个名为gl的文件夹，将.h文件glut.h放入
在lib下的x86文件夹中，将将.lib文件glut.h放入glut.lib 、glut32.lib
最后系统文件夹C:\Windows\SysWOW64，将.dll文件glut.dll、 glut32.dll放入
3.测试运行 将文件配置后，在vs中首先要选择具有C++的环境，选择控制台应用程序
在main.cpp中编写测试程序：
#include &lt;GL/glut.h&gt; void myDisplay() { glClear(GL_COLOR_BUFFER_BIT);//清空色彩缓存区 glRectf(-0.5f,-0.5f,0.5f,0.5f);//绘制 glFlush(); } int main(int argc,char *argv[]) { glutInit(&amp;argc,argv);//初始化glut （可不写默认） glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);//显示模式初始化 RGB显示模式，单缓冲模式 glutInitWindowPosition(100, 100);//窗口窗口位置 （可不写默认） glutInitWindowSize(400, 400);//窗口大小 （可不写默认） glutCreateWindow("第一个OpenGl程序");//窗口名称 glutDisplayFunc(&amp;myDisplay);//自定义函数绘图 glutMainLoop();//消息循环相应 return 0; } 编译正常运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c6f926801f7984c8b3d6e40497a19a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084331598e5736570aafb23de0152ea9/" rel="bookmark">
			python中列表的删除操作，五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表的添加操作
列表删除操作 1、列表删除操作1.1 remove（）1.2 pop()1.3 切片1.4 clear与del 1、列表删除操作 五种方式分别为：
remove():一次删除一个元素；如果列表内有重复元素则删除第一个；元素不存在时抛出异常ValueErrorpop():删除一个指定的索引位置上的元素；指定索引不存在则抛出异常IndexError切片:一次至少删除一个元素clear():清空列表del:删除列表 1.1 remove（） 一次删除一个元素；如果列表内有重复元素则删除第一个；元素不存在时抛出异常ValueError。
代码 lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print("原列表为：", lst) lst.remove(5) print("删除后的列表为：", lst) 截图
1.2 pop() 删除一个指定的索引位置上的元素；指定索引不存在则抛出异常IndexError
注意：如果不指定参数，则默认删除最后一个元素
代码
lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print("原列表为：", lst) lst.pop(5) print("删除后的列表为：", lst) 截图
1.3 切片 切片的本意为截取原有列表中指定的的某一段，或者说是复制指定的那一段，并返回了新的列表。
借助列表的添加方式，原来添加的操作中，使得lst[start,stop] = lst1（此为添加的元素）
那么删除操作可以类似的，使lst1为空列表，那么原列表中指定一段的元素被空替代，则完成删除
其中切片的具体操作在python中list列表的切片截取操作，包含倒序输出
代码
# 切片的本意为截取原有列表中指定的的某一段，或者说是复制指定的那一段，并返回了新的列表 lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/084331598e5736570aafb23de0152ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3283d184a50395c1bce08d1b05a1c175/" rel="bookmark">
			python列表的添加的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表删除的五种方式
python列表的增删改 1、list增加元素1.1 append（）1.2 extend（）1.3 insert（）1.4 切片 1、list增加元素 python中列表增加元素有四种方式：
append()：在列表末尾添加一个元素extend()：在列表末尾添加至少一个元素insert()：在列表任意位置添加一个元素切片：在列表任意位置添加至少一个元素 1.1 append（） 在列表末尾添加一个元素，该元素可以是str类型，int类型，或者列表对象
代码如下
lst = ["KO", "no", "Dio", "da"] print("------原列表------") print(lst) print("------append()------") lst.append(100) print(lst) lst.append("100") print(lst) lst1 = ["aaa","bbb"] lst.append(lst1) print(lst) 执行截图
1.2 extend（） 在列表末尾一次性添加多个元素
代码如下
lst = ["KO", "no", "Dio", "da"] print("------原列表------") print(lst) print("------extend()------") lst1 = ["aaa","bbb"] lst.extend(lst1) print(lst) 截图
1.3 insert（） 在列表任意位置插入一个元素，insert（index , value）第一个参数为位置，第二个为
代码
lst = ["KO", "no", "Dio", "da"] print("------原列表------") print(lst) lst.insert(2, "嘿嘿嘿") print(lst) 截图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3283d184a50395c1bce08d1b05a1c175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50af0f4dceaa91470a688e3595a1793/" rel="bookmark">
			python中list列表的切片截取操作，包含倒序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表定义list为list = [*,*,*,*,*,*]，
切片为list[start:stop:step]，
其中，start：开始位（索引值） stop：结束位（索引值） step：步长，start与stop为左闭右开，即[start,stop)，
并且，切片出来的列表与原来的列表是两个新的列表对象，其id值是不一样的。
直接上代码：
注意：python中的列表索引和Java是一样的从0开始计数，便于学习，代码的列表中的值和索引值同步了。倒序需要注意一下。
lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # 参数为 start：开始位 stop：结束位 step：步长 # 其中start与stop为左闭右开，即[start,stop) # 切片后的列表为新的列表 # 步长位1 print("------步长位1------") print(lst[1:6:1]) print(lst[1:6:]) print(lst[1:6]) # start为默认值，且其默认值为0 print("------start为默认值，且其默认值为0------") print(lst[:6:1]) # stop为默认值，且其默认值为列表长度 print("------stop为默认值，且其默认值为列表长度------") print(lst[1:10:1]) # step为负数 print("------step为负数------") '''step为负数时,start&gt;stop，为原列表倒序输出''' print(lst[::-1]) # start，stop都为默认值，step为-1，切片为列表倒序 print(lst[6:1:-1]) print(lst[6:1:-2]) 代码执行的结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b4425428c046dfc652af9d696fbd0b/" rel="bookmark">
			Navicat for mysql远程登录和用户访问权限设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试所需软件 系统：Win10 64位 （两台电脑，一台做服务器，另一台做客户端）数据库：Mysql8.0.18数据库管理工具:Navicat Premium 12.0.11 首先两台电脑上都安装并配置Mysql数据库,安装教程请看https://blog.csdn.net/tiankongzhicheng441x/article/details/103602343
Navicat仓库管理工具请自行百度下载，这里不提供。
1.以管理员身份运行命令提示符窗口（CMD窗口），开启数据库。 2.将两台电脑设置在同一个局域网内，如电脑A的IP为192.168.222.1；电脑B作为服务端IP为192.168.222.2。 3.打开Navicat，这里我已经建好了一个数据库，接下来添加一个用户名为test的新用户，给远程电脑连接时用。 % 表示同一个网段的其他电脑都可以连接该服务器，如果设置成固定IP，则只能是设置成这个IP的电脑访问，其他都访问不了。
服务器权限 在网格里，对照在 权限 列出的服务器权限，勾选 授予 选项以指定这个用户有这个权限。可以授予多个权限（通常都要勾选Select选项）。
权限 要编辑一个用户的特定对象权限，点击 添加权限 以打开窗口并按照下列步骤进行：
1. 在查看树展开节点直至到达目标对象。
2. 勾选对象以显示网格在右边的面板上。
3. 在网格里，对照在 权限 列出的权限，勾选 状态 选项以指定这个用户有这个权限。 可以授予多个权限。
注意：用户权限的信息是保存在 mysql 数据库（即数据库名为 mysql）的 user、 db、 host、 tables_priv、 columns_priv和 procs_priv 表。 MySQL 服务器在启动时读取这些表的内容。
4.在服务器上测试新用户的连接和权限设置情况。选择连接-&gt;MySQL... \
连接名一栏：名称随便起，主机名或IP地址一栏：写数据库所在的主机名（localhost）或服务器的 IP 位址。如果是在另一台电脑连接服务器则写服务器IP地址，用户名就填test，密码是新建用户test时设置的密码。填写完成后点击确定按钮。
现在已经通过test用户登录上了，可以查看test用户针对数据操作所具有的权限。
在test_3306中选择mysql数据库，用户的权限在user表中可以看到，用户对数据库的权限在db表中查看，用户对数据表的权限可以在tables_priv表中查看
5。接下来在Navicat中测试，根据上图可知：mydatabase2数据库没有Create权限，mydatabase3数据库有Create权限。 选择mydatabase3数据库-&gt;点击查询-&gt;选择新建查询,输入如下代码用于创建新表：
CREATE TABLE `Scores` ( `ID` int(4) UNSIGNED ZEROFILL NOT NULL AUTO_INCREMENT, `Name` varchar(20) NOT NULL, `stuNumber` int(8) NOT NULL, `Score` double(3, 1) UNSIGNED ZEROFILL NOT NULL, PRIMARY KEY (`ID`) ); ，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b4425428c046dfc652af9d696fbd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98792d684bd75c406e273fc2f2bcffae/" rel="bookmark">
			计算机视觉——SIFT特征匹配RANSAC剔除错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码地址：https://github.com/AOYLAOTANG/Computer-Vision/tree/main/sift%E6%94%B9%E8%BF%9B
一、基本原理 Sift是计算机视觉里面一个提取特征的经典方法，翻译即尺度不变特性转换，他在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变量，局部影像特征的描述与侦测可以帮助辨识物体，SIFT特征是基于物体上的一些局部外观的兴趣点而与影像的大小和旋转无关。对于光线、噪声、些微视角改变的容忍度也相当高，其基本步骤一般分为：用高斯核构建尺度空间，形成高斯金字塔，在DoG尺度空间中检测极值点，计算特征点方向，计算128维描述子。
本文内容主要是实现ransac算法，其基本思想就是对处理数据进行随机采样，然后利用采样的数据对所有数据进行误差评估，每一次采样都会得到一个结果，在经历足够多次采样之后可以找到一次采样使误差达到最小，这就是ransac的基本思想。
二、核心代码 Sift的实现代码是https://www.cs.ubc.ca/~lowe/keypoints/网站上下载的，这个应该是 加拿大University of British Columbia 大学计算机科学系教授 David G. Lowe发表的matlab代码，里面有很多文件sift.m是提取特征值，match.m是匹配两幅图像的特征值，我写了一个CaflF.m用来实现ransac算法并计算基本矩阵F，并在ransac.m中调用CaflF.m实现特征匹配，下面是CaflF.m的关键代码
for i=1:8 a=randperm(num,1); x1(i)=matchedPoints1(a,1); y1(i)=matchedPoints1(a,2); x2(i)=matchedPoints2(a,1); y2(i)=matchedPoints2(a,2); end f=null(A,'r'); F=[ f(1) f(2) f(3); f(4) f(5) f(6); f(7) f(8) f(9); ]; %遍历所有特征匹配点根据基本矩阵求极线 for i=1:num m=[matchedPoints1(i,1) matchedPoints1(i,2) 1]'; l=F*m; distant=abs(l(1)*matchedPoints2(i,1)+l(2)*matchedPoints2(i,2)+l(3))/sqrt(l(1)*l(1)+l(2)*l(2)); if(distant&lt;0.5) inIndex(i)=1; points=points+1; else inIndex(i)=0; end end if(points&gt;max) max=points; inliersIndex=inIndex; end 三、流程图 左边为Sift的流程图，右边为ransac流程图
四、实验结果 做了三个实验，分别对误差的参数dis进行了测试
Dis&lt;0.5
Dis&lt;0.1
Dis&lt;0.05
五、总结 通过这次实现ransac，刚开始使用人脸做特征匹配，后来效果不太好，发现人脸还是纹理比较少，后面网上搜了很多图实验，发现景观或者纹理比较复杂的图片提取的特征的比较多，像人脸一般就两三个特征点，ransac方法主要思想比较简单，主要是实现到sift特征提取中，网上查了很多资料，中间也问过老师，后来看matlab本身自带的实现函数，因为调用函数太多了就自己模仿写了一个，基本思想就是8点法求一个线性方程组确定一个基础矩阵F，然后对每个特征点用这个F算极线，找匹配点与极线的距离dis，如果在某个范围内就算inlier，否则就是误差点，需要剔除，放到outliner中，开始dis设置的值比较大，所以剔除的误差不算很多，后来dis设置小一点，即缩小极线的区域，发现剔除效果就比较好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60032d760590dd2697f5f9ea754446b9/" rel="bookmark">
			学习JavaWeb这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一章 开发工具 1.1、JDK安装1.2、Tomcat安装1.3、IDEA安装1.4、IDEA集成Tomcat1.5、IDEA运行JavaWeb第二章 XML（选学） 2.1、XML的概述2.2、XML的语法2.3、XML的解析第三章 YAML（选学） 3.1、YAML的概述3.2、YAML的语法3.3、YAML的解析第四章 Servlet 4.1、Servlet概述4.2、Servlet语法格式4.3、Servlet执行过程4.4、Servlet生命周期4.5、Servlet继承体系4.6、ServletContext 4.6.1、获取全局配置参数4.6.2、获取web工程中的资源4.6.3、在Servlet间共享数据域对象4.7、ServletConfig4.8、HttpServletRequest4.9、HttpServletResponse4.10、重定向和请求转发4.11、Cookie4.12、Session第五章 Listener 5.1、监听三个作用域创建和销毁 5.1.1、ServletContextListener5.1.2、ServletRequestListener5.1.3、HttpSessionListener5.2、监听三个作用域属性状态变更 5.2.1、ServletContextAttributeListener5.2.2、ServletRequestAttributeListener5.2.3、HttpSessionAttributeListener5.3、监听HttpSession存值状态变更 5.3.1、HttpSessionBindingListener5.3.2、HttpSessionActivationListener第六章 Filter 6.1、Filter概述6.2、Filter生命周期6.3、Filter语法6.4、Filter执行顺序6.5、Filter匹配规则6.6、Filter拦截类型6.7、Filter统一编码第七章 JSP 7.1、JSP概述7.2、JSP生命周期7.3、JSP语法 7.3.1、JSP脚本程序7.3.2、JSP变量声明7.3.3、JSP表达式7.3.4、JSP注释7.3.5、JSP指令元素 7.3.5.1、page指令7.3.5.2、include指令7.3.5.3、taglib指令7.3.6、JSP动作元素 7.3.6.1、jsp:include动作7.3.6.2、jsp:useBean动作7.3.6.3、jsp:setProperty动作7.3.6.4、jsp:getProperty动作7.3.6.5、jsp:forward动作7.3.7、JSP隐含对象7.3.8、JSP常见控制7.4、EL表达式 7.4.1、EL概述7.4.2、EL语法7.4.3、EL隐含对象7.4.4、EL案例演示7.5、JSTL表达式 7.5.1、JSTL概述7.5.2、JSTL依赖7.5.3、JSTL常用标签第八章 Servlet3.0 8.1、注解开发 8.1.1、servlet注解8.1.2、filter注解8.1.3、listener注解8.1.4、两种配置同时存在8.1.5、如何禁用注解组件8.2、文件上传8.3、异步处理8.4、动态注册 8.4.1、servlet动态注册8.4.2、filter动态注册8.4.3、listener动态注册8.5、可插性支持 第一章 开发工具 1.1、JDK安装 第一步：打开官网进行下载（https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html）
第二步：运行程序进行安装
全部默认下一步即可，不用管路径是不是存在中文和空格，无碍！
注意：如果自己会配置JDK，可以更改它的安装路径，那相应的环境变量也需要修改！
第三步：系统环境变量配置
此电脑 》 右键 》 属性 》 高级系统设置 》 环境变量 》 系统变量 》 新建（需要新建两个，然后修改一个）
新建两个：JAVA_HOME代表Java的安装目录、CLASSPATH代表程序运行的时候，优先加载当前目录中的类，然后再加载指定的类库
变量名变量值JAVA_HOMEC:\Program Files\Java\jdk1.8.0_261CLASSPATH.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 修改一个：编辑PATH环境变量，它会打开一个窗口，新添两条路径，如下图所示
%JAVA_HOME%\bin%JAVA_HOME%\jre\bin 第四步：测试JDK是否安装成功
打开一个cmd命令行窗口，输入以下两个命令查看，如果有内容输出则证明已经配置成功！
java -versionjavac -version 1.2、Tomcat安装 第一步：打开官网进行下载和安装（http://tomcat.apache.org/）
第二步：系统环境变量配置
此电脑 》 右键 》 属性 》 高级系统设置 》 环境变量 》 系统变量 》 新建（需要新建两个，然后修改三个）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60032d760590dd2697f5f9ea754446b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a778e50e99b8ca91f008ac0926287c/" rel="bookmark">
			余弦函数导数推导过程_三角函数公式篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 一、弧度制 二、三角函数的基本定义 三、同角三角函数基本关系 四、三角函数的诱导公式 五、三角函数的和差角公式 六、倍角公式和半角公式 七、积化和差与和差化积公式 八、万能公式 九、辅助角公式 十、求导 十一、反三角函数相关公式 十二、其他常用结论 一、弧度制
我们在初中接触的角基本上是角度制的，例如
。因此，在研究三角函数之前，我们需要把角度制推广，引入弧度制的概念。 弧度是角的大小的另一个计量单位，用rad表示。弧度与角度之间的换算关系为： ，即弧度与角度之间的函数关系可以表示为 。 引入弧度制后，我们便可得出圆弧长、扇形面积的弧度制计算公式。
圆弧周长的计算公式：角度制： ；弧度制： 扇形面积的计算公式：角度值:： ；弧度制： 扇形可以看做一个“ 曲边三角形 ”：弧长 是“底”，半径是“高”弧度制下扇形的面积可以表示为，面积 ， 二、三角函数和反三角函数的基本定义
（一）三角函数
单位圆（及半径 的圆）在三角函数的学习中具有举足轻重的地位。我们可以利用单位圆来定义三角函数、求解三角函数问题。在解决三角函数问题的过程中，单位圆是一个非常有用的工具。 设角 的终边与单位圆（此处是以原点为圆心）交于点 ,则有 正弦：
，余弦： 正切：
，余切： 正割：
，余割： （二）反三角函数
反三角函数是一种基本初等函数，它包括反正弦 、反余弦 、反正切 、反余切 、反正割 、反余割 ，他们各自表示其正弦、余弦、正切、余切 、正割、余割为 时的角。例如，当 时， ；当 时， ，具体如， 。 反三角函地并不能狭义地理解为三角函数的反函数。三角函数的反函数不是单值函数，因为它并不满足一个自变量对应一个函数值的要求，其图像与其原函数关于函数 对称。 三、同角三角函数基本关系
1.倒数关系：
2.商的关系：
3.平方关系：
四、三角函数的诱导公式
诱导公式记忆口诀：“奇变偶不变，符号看象限”.此处仅列出了几个易混的诱导公式，过于常规的就没有列出。个人认为，只需记住 与 、 、 的三角函数值关系，便可推出所有的诱导公式。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a778e50e99b8ca91f008ac0926287c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dbaee3b45775c923f8edba1f125e9af/" rel="bookmark">
			Three.js 模型添加标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在很多的实际的项目中，你可能需要给一个Three.js的模型添加标签，那么我们可以使用three.js的精灵模型来表示，使用精灵模型表示一个模型对象的标签，那么精灵模型就要位于模型对象的附近。可以获得要标注模型的世界坐标，然后来设置精灵标签的位置，适当偏移一点就可以，当然也可以把精灵对象插入到模型对象的父对象中，和模型对象一样作为父对象的子对象，这样的话如果模型父对象的位置变化，精灵模型可以跟着一起变化。如下效果就是使用精灵实现的效果,需要源码联系QQ:1582360909
/**
* 创建点精灵模型
*/
// 创建精灵材质对象SpriteMaterial
var spriteMaterial = new THREE.SpriteMaterial({
map: new THREE.TextureLoader().load("立方体.png"), //设置精灵纹理贴图
transparent: true,//开启透明(纹理图片png有透明信息)
});
// 创建精灵模型对象，不需要几何体geometry参数
var sprite = new THREE.Sprite(spriteMaterial);
sprite.scale.set(30, 30, 1); //精灵大小
// 把精灵模型插入到模型对象的父对象下面
group.add( sprite);
// 父对象group位置变化,网格模型及其对象的标签同样发生变化
group.position.set(10, 0, -80);
// 表示标签信息的精灵模型对象相对父对象设置一定的偏移
sprite.translateY(30); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5868b3b3d20ec507af291a6e207feca9/" rel="bookmark">
			Java大数据平台开发 学习笔记（56）—— session.getAttribute 却显示 null 问题 及其 request.getSession(true/false) 的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、request.getSession()和request.getSession(true/false)的理解： request.getSession() 和 request.getSession(true) 意思相同：如果 session 不存在，就新建一个 session。request.getSession() 和 reqeust.getSession(false) 获取 session,如果 session不存在，则返回 null。 注： 如果项目中无法确定会话一定存在，最好用 request.session(false);
2、session.setAttribute 明明获得了值，但 session.getAttribute 却显示 null： 我们都知道 session 依赖 cookie，因为服务器需要在每次请求中获取 sessionId，然后找到客户端的 session 对象，如果浏览器禁用了cookie 呢 ？
方法一：
手动添加 jsessionid 参数。
------------链接------------
&lt;a href='/jsp/index.jsp;jsessionid=&lt;%=session.getId() %&gt;' &gt;主页&lt;/a&gt; ------------表单------------
&lt;form action='/jsp/index.jsp;jsessionid=&lt;%=session.getId() %&gt;' method="post"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; 方法二：
使用response.encodeURL() 对每个请求的URL处理，这个方法会自动追加 jsessionid 参数。
------------链接------------
&lt;a href='&lt;%=response.encodeURL("/jsp/index.jsp") %&gt;' &gt;主页&lt;/a&gt; ------------表单------------
&lt;form action='&lt;%=response.encodeURL("/jsp/index.jsp") %&gt;' method="post"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; •由 ChiKong_Tam 写于 2020 年 10 月 27 日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0a8ed72214a256795d3db8de69f4e2/" rel="bookmark">
			蓝牙驱动卸载后自动安装_电脑自动安装卸载手机软件-快来Get最简单便捷的方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前我分享过用JavaScript来写脚本实现电脑自动控制手机的功能。但是很多老铁只会易语言、java、python等其他语言怎么办？其实很简单，用 Total Control 提供的REST API 就可以啦！Total Control 的REST API 支持任意脚本语言。今天我又来说说，怎样用易语言实现自动打开、关闭手机上的软件。易语言实现自动安装软件(installApp)
函数功能：将电脑上的 apk 文件安装到设备
请求方式：POST
http://IP:8090/TotalControl/v1/devices/:device/apps?token=:token&amp;file_name=:file_name
参数说明：
易语言实例：将电脑上的 QQ 音乐 apk 文件安装到设备，apk 在电脑存储位置: "E:FileQQyinle_850.apk"
代码如下：
.版本 2
.程序集 窗口程序集_启动窗口
.子程序 __启动窗口_创建完毕
.局部变量 base64, 文本型
.局部变量 token, 文本型
.局部变量 device, 文本型
.局部变量 j_token, 类_json, , , 用来解析获取 token 的 json
.局部变量 j_dev, 类_json, , , 用来解析获取设备ID 值的 json
.局部变量 j_ret, 类_json, , , 用来解析 REST API 接口的json
.局部变量 bool, 逻辑型
.局部变量 bool_dev, 逻辑型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0a8ed72214a256795d3db8de69f4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8818e60ef251655ac20a977843aab2f4/" rel="bookmark">
			ECMAScript 6 入门教程—Module 的语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 阮一峰 概述 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。
在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
// CommonJS模块 let { stat, exists, readfile } = require('fs'); // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。
ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
// ES6模块 import { stat, exists, readFile } from 'fs'; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8818e60ef251655ac20a977843aab2f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77040241ad41130665087d5272dde10e/" rel="bookmark">
			GWAS全基因组关联分析：TASSEL 5.0 Windows版软件使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TASSEL的官方网站：https://tassel.bitbucket.io/
在TASSEL的下载文件夹中…\TASSEL5\TutorialData有示例数据 用此数据进行演示
依次为基因型数据、亲缘关系、表现型数据（这里面包含了分群、表型性状、群体结构）、群体结构、表型性状。
实际只用到基因型数据、群体结构、和表型性状。TASSEL是可以通过基因型数据计算亲缘关系的。
一、加载数据 点击File → Open
将基因型数据、群体结构和表型性状导入进来。（mdp_genotype.hmp、mdp_phenotype、mdp_traits这三个文件）
二、计算亲缘关系 对基因型文件进行过滤
选择基因型数据 点击Filter → Sites
进行设置 → 点击Filter
（此处的标准都是按照TASSEL指导手册中进行设置的）
点击Analysis → Relatedness → Kinship
点击OK
就得到了亲缘关系的矩阵
三、关联分析（一般线性模型） 对基因型文件进行过滤
注意：这里用到的是上一步进行亲缘关系分析时过滤后的文件
即
在此文件的基础上再次进行过滤 点击Filter → Sites
设置过滤条件 点击Filter
得到过滤后的基因型数据
选择性状数据 点击Filter → Traits
选择其中一个性状，点击OK
得到其中一个表型数据
选择群体结构 点击Filter → Traits
将最后一个群体结构（Q3）去掉，指导手册中给出的解释是“如果我们把它们全部作为协变量使用，这会产生线性相依性”。
得到过滤后的群体结构数据
摁住Ctrl键同时选中上述三个文件进行合并 点击Data → Intersect Join
得到合并后的数据集
选中合并后的数据集 点击Analysis → Association → GLM
点击OK
其中Help选项中有该页面参数的解释和默认值，还可以点击User Manual查看更详细的内容。
得到最终结果文件
数据可视化
点击Results → QQ Plot/Manhattan Plot
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77040241ad41130665087d5272dde10e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ec7db4dcbfb897de44a3713996a3dc/" rel="bookmark">
			PyTorch报错：OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
PyTorch报错： **
OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized.
OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. That is dangerous, since it can degrade performance or cause incorrect results. The best thing to do is to ensure that only a single OpenMP runtime is linked into the process, e.g. by avoiding static linking of the OpenMP runtime in any library.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38ec7db4dcbfb897de44a3713996a3dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6047359ca00a5d38e9ecf6a465c5699/" rel="bookmark">
			NP完全性理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：《计算机程序设计与分析》
计算机算法理论中，最深刻的问题之一是：“从计算的观点来看，要解决的问题的内在复杂性如何？”即判断该问题是“易”解决还是“难”解决的。问题的计算复杂性可以通过解决该问题所需计算量的多少来度量，但要确定一个问题的内在计算复杂性是十分困难的。可以把多项式时间内可以解决的问题看做“易”问题，将指数函数时间内可以解决的问题看做“难”问题。这里的多项式时间和指数函数时间是针对问题的规模而言的。为了研究“难”问题，人们提出了“非确定性图灵机计算模型”。通过该模型，很多问题就可以在多项式时间内求解。
通常对于每一个最优化问题都有一个与之对应的判定问题，判定问题较最优化问题容易求解。如下面的旅行售货员问题。
设 是一个带权图。图中各边的费用（权）是正数。图的一条周游路线是包括 V 中的每个顶点在内的一条回路。周游路线的费用是这条路线上所有边的费用之和。旅行售货员的问题要在图 G 中找出费用最小的周游路线。
与之对应的判定形式的旅行售货员问题可描述如下：
对于给定的带权图和一个正数 d 。判定形式的旅行售货员问题要求判定图 G 中是否存在总费用不超过 d 的周游路线。
所有可以在多项式时间内求解的判定问题构成 P 类问题。通常解一个问题要比验证问题的一个解困难的多。P类问题是确定性计算模型下的易解问题类，而 NP类问题是非确定性计算模型下的易验证问题类。
非确定性算法将问题求解分为猜想和验证两个阶段。算法的猜想阶段是非确定性的，他给出问题的一个猜测，算法的验证阶段是确定性的，验证猜想阶段给出的解的正确性。假设算法A是解一个判定问题 Q 的非确定性算法，如果算法 A 的验证阶段可以在多项式时间内完成，则称算法 A 是一个多项式时间非确定性算法，同时也称问题 Q 是非确定性多项式时间可解的。所有非确定性多项式时间可解的判定问题构成 NP 类问题。
从定义可以看出，大多数科学家认为 ，但一直没有明确的答案。同时存在一类 NPC类问题，这类问题具备一个重要的性质，如果一个 NPC 问题可以在多项式时间内解决，那么 NP 中每一个问题都可以在多项式时间内求解，即证明，但目前还没有一个 NPC 问题具备多项式算法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7f2b65bb342061f3bc850b969c3540/" rel="bookmark">
			2020-10-26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试验一下，看能不能用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c02c119d955e28588a6f561338388ba/" rel="bookmark">
			百度Ai studio上运行pytorch和tensorflow（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载 链接：https://www.zhihu.com/question/336485090/answer/1017905011
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
5.4.2020更新（要看正文的，直接跳到原始正文部分）：
大家去看看微软发布了一年半的牛逼项目 ： nni https://github.com/microsoft/nni/blob/master/README_zh_CN.md简单说，这个就是深度学习，神经网络的自动管理包。官方把中文做第二语言，中文的read me。但，重点：看它支持的框架………………什么叫主流？呵呵呵。一年半啦，没……浆。做企业，做开发……………………………………………………………………做人，都不能：自欺欺人啊！格局决定高度，高度决定未来！4.27.2020更新：果然，升级后，持续化环境，直接写在新开的book头部了，大家自己整。把我下面写的东东，扔进去就ok。其实对于kaggle，colab，那些大型的包一样可以这么整。但这个对于百度来说，尤其需要，为啥，因为咱的网络环境下，git和wget在他家是残疾的。附送大家一句尤其重要的代码（飞浆也置了顶，只是它只是写为了pip持续化，而没把核心原理讲清楚。另，.append这个写法我不喜欢，so）：import syssys.path +=[’/usr/local/lib/python3.7/site-packages’,’/到/你的/工作目录/路径’]在最后这个路径文件夹下的所有包（不含路径名本身），都可以以层级关系 import XX，from XX import XX。虽说是python指定路径的常识，但我发现很多兄弟不明白怎么玩包，玩自定义程序。那你不是每次干程序，都得写一堆码？？？？？随着DL3的工业级部署成熟，框架HUB的时代来临了。我觉得很多小伙儿不要钻牛角尖，我们是使用灯泡的，不是研发生产灯泡的。人工智能的细化、分类，一定是越来越垂直。你只需要在你的那个分支够优秀，够深入就行，其他的，交给其他的兄弟们。飞浆的HUB中，我推荐语义分割接口，就是DL3-xp65-humanseg。对于图形图像CV类而言，真的省事儿。虽说这货基本完全复制pytorchhub，但是还真比对方还轻便快捷。哈哈哈。让我产生了一种幻觉，到底，谁高仿了谁？另：大家有能力的，去学习一下microsoft/onnxruntime。这货将来也是你三天两头会用的东东（飞浆里的中文教程挺简单的）。4.14.2020更新：github这段时间各种优秀，一堆兄弟疯了似的发新模，各个领域的。估计是疫情大伙儿都在家整研发了，没法出去混了，大家自己去看吧，我觉得量子位应该写不过来了。4.11.2020更新：百度4.5日起调整时长了，从10小时，变成2小时，白天基本上没任何可能开G机，说明社区这个项目问题大了去了。既封闭没法带来高效便利，又满足不了人工智能现阶段的大规模运算需要，这样它比拼其他平台的优势就彻底没了，运营模式上看来要调整了。全世界范围内，任何新的开源内容失去了大面积群体的验证，无论框架有多少优点，都是没有意义的，其发展思维是背离互联网发展需要的。我和一些搞研发的兄弟最近都只能不上去搞。有一次我想让他们把上传限制改一下（现在已经升级了），管理的兄弟告诉我，这个平台的定位是给大学生用的。于是我就纳闷了，为啥？因为，如果给大学生用，那你为啥限制其他框架？很多同学都刚刚开始接触，他们非常需要学习各种成熟的框架，需要最便捷的方式进入，然后一步步的深入，最好的方式是拉码学习，完成自己的功能实现。这一步是需要大量花时间看论文，看别人的git的……所以，当你限制时，就拒绝了大学生和新人。这不是摆在那里自相矛盾吗？
原始正文 我在这里写的方法是：从此，无论你重新开多少个新项目（核心中的核心哦），都不用重装，只需要5秒以内就搞定框架！！！！！！！！！！！！！！！！！！！！！ok，我索性把tensor和torch都全部补完把，先补充whl页面（先别急着下载，看完再下）：
tensorflow-gpu：https://pypi.tuna.tsinghua.edu.cn/simple/tensorflow-gpu/torch-gpu：https://download.pytorch.org/whl/torch_stable.html 虽然，我不喜欢百度的一些作风。但有一句说一句，飞浆有方便的地方，V100香也摆在那里。另，百度ai云端jupyter限制tensorflow和pytorch等框架，但终端至今能用，用的也流畅。我和一些兄弟在他们坛子里一直批评他们狭隘，说他们不支持这几个框架，不是说技术上完全不支持，是说理念上他们发展自己框架的这种策略不合适（为啥？因为很多新技术，往往处于最前沿的研究过程中。不少论文和项目，连作者自己的验证都不够完善（全球开源率不到6%），待全网开源探讨，这时，所有人的流程是，先用最顺手的框架搞定研究本身，再研究转移框架。转移的目的是为了更高效，而不是为了框架而框架，如果一种技术特别适合tensorflow，那就应该tensor，适合咖啡和妈差奶，就应该是咖啡和妈差奶，适合飞浆，那就应该飞浆，不能本末倒置）。百度的这个策略导致自身平台的使用效率降低，反而限制自身发展壮大，无法做活社区，导流过不来，成本就反而高居不下。
至于技术上：
请所有不明白的小伙伴，搞清楚免费版是CPU版，支持毛线的GPU版（colab的笔记本不是一样让你选硬件加速器吗？NONE\GPU\TPU，一个道理）？人那个算力卡版（其实也免费）是v100是gpu版好嘛！进去先nvcc -V再说支持不支持。（发现有小伙伴还是不明白cpu，gpu，cuda，cudnn，nvcc的关系。补：cpu，机器的心脏，处理一切资源的调度、供给分配。gpu，你就理解成显卡的心脏，图形处理器，咱平时说的nvidia就是产这个的。cuda是啥？一个平台，一种框架，一门‘语言’一个用来发挥gpu计算功能的东东。cudnn，函数集，深度学习的函数集子。nvcc就好比gcc，是编译器，编译啥，编译cuda这门‘语言’。大伙儿要再问，我就瞎了，好嘛！）为了防止还有更多小伙伴不理解，我写一下方法： A.torch 方法1（极简，不换虚拟环境，直接来）：进入终端（重点，别有了notebook忘了最基本的东西，linux 最香是终端！）:
1.0.0pip install torch1.0.0 torchvision0.2.1 -i http://pypi.douban.com/simple --trusted-host pypi.douban.com1.2.0pip install torch1.2.0+cu92 torchvision0.4.0+cu92 -f https://download.pytorch.org/whl/torch_stable.html成功。用！看明白没，九成的兄弟错在你装了cpu版的torch或tensor，你指望cuda gpu匹配，咋配，不false才怪！至于省下点算力卡安装，搞持续化目录，我就不写这里了，大家自己研究，免得大家越整越麻烦。个人体会，几个大包下载下来扔数据集后拉回home，然后改成官方标准文件名安装，最方便。另，torch和torchvision必须同时装（指网络安装，whl无视），分开的话，会丫的帮你升级torch到1.4。好，你喜欢折腾，迷恋conda（有时是非它不可），
方法2：
进入终端，然后：
step1，source activate -n python35-paddle120-env （楼上都写了）
step2，conda install -n python35-paddle120-env pytorch1.2.0 torchvision0.4.0 cudatoolkit==9.2 -c Tsinghua Open Source Mirror --yes；
上面那几个源的http地址，知乎显示成链接缩写了，请不要自己瞎编适配，务必去pytorch的官网和tensorflow的官网复制黏贴一下，都明明白白写着命令。pytorch也好，tensorflow也好，对自身版本，显卡驱动，cuda版本，cudnn版本的匹配要求很严格，尤其是gpu版本和cpu版本是完全不同的，在pip安装时尤其要注意。飞浆云端是cuda9.2（这是值得吐槽的，9.2是猴年马月的事情了。因为适配上他们做的效率低了，光想着飞浆怎么适配，用户可不会等你），我们可以升级成10.0以上，但显卡的驱动是要root的（也就是说，如果你开机拿到的是16G的gpu机子，你只能9.2，你运气好，开机拿到的是32G的机子，就可以10.0+，这个看人品，是百度随机的，其模式和colab一样，人品不好：k80，呵呵），不像cuda可以随便改动，所以，9.2简单使用，10.0、10.2我写在下面tensorflow安装的例子里。conda安装源不顺，挤爆，讲个小技巧：除换源外，下载过程中遇到不顺的包，先跳过，终端ctrl+c，ok，待会把conda install再执行一次，就ok了。当然，长期使用，有些大包，直接下下来，然后放进数据集，拉进home，从此清净！ok！贴图：
B.tensorflow-gpu（1.15.0为例）方法（只需要第一次这样装，以后极简，下文我全部写清楚的）： cuda10.2无root权限静默安装，飞浆开机home目录下：
wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run 下载cudnn-10.2.tgz（这个得你们注册下载，然后放到根目录）静默安装，就一句：
sh cuda_10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c02c119d955e28588a6f561338388ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a743d29145ac5b1565b63c99ee4b334/" rel="bookmark">
			(主机)ARP表(ip/mac)、(交换机)交换/转发/MAC表(mac端口 同一网段)、(路由器)路由表(不同网段)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		reference
转发表(Forwarding Table)
MAC地址
以太网地址或物理地址
它是一个用于确认网络设备位置的地址
每个网络设备(如网络适配器(Network Adapter)，
即网卡(Network Interface Card, NIC))都有世上唯一的MAC地址，
一台设备若有多张网卡，
则每个网卡都必须具有一个唯一的MAC地址，
这个是在网络设备出厂时由厂商烧制确定。
工作流
转发表，又称MAC表–交换表
交换机就是根据转发表来转发数据帧的。
维护记录着局域网主机端口MAC地址与交换机端口对应的表，
交换机就是根据这张表负责将数据帧传输到指定的主机端口上的。
步骤如下：
主机A会将一个源MAC地址为本机网卡物理地址，
目的MAC地址为主机B网卡物理地址的数据帧发送给交换机1；
交换机收到此数据帧后，
首先将数据帧中的源MAC地址和对应的输入端口0
记录到交换机维护的MAC地址表中；
然后交换机会检查自己的MAC地址表中
是否有数据帧中的目的MAC地址的信息，
如果有，则从MAC地址表中记录的对应端口发送出去，
如果没有，则会将此数据帧从非接收端口的所有端口发送出去，
这里仅从端口1发出；
这时，局域网的所有主机(通过交换机相连的全部主机)
都会收到此数据帧，
但是只有主机B收到此数据帧时会响应这个广播帧，
并回应一个数据帧
(这个回应由什么机制确定的，需要再查资料确定一下～TCP的ACK包？)，
此数据帧中包括主机B网络设备的MAC地址；
当交换机收到主机B回应的数据帧后，
也会记录数据帧中的源MAC地址，
即主机B网络设备的MAC地址，
这时，再当主机A和主机B相互通信时，
交换机就根据MAC地址表中的记录，实现单播了，
一趟转发流程实际交换机就“学习”到了两个转发表条目。
小结
从以上两幅图可以看出，
交换机具有动态自学习源MAC地址与物理端口映射的功能，
并且交换机的一个端口可以对应多个MAC地址，
但是一个MAC地址只能对应一个端口。
ARP表(Address Resolution Table)
首先明确一点，
在以太网环境下，
同一个网段的主机之间需要知道对方的MAC地址，
(通过交换机相连的节点处于同一网段)
才能进行通信。
了解到交换机是根据MAC寻址，
查表确认输出端口以完成本节点转发任务的。
看到这里其实应该可以抛出从一开始就被我们忽视了的问题：
在初始构造数据包准备发送时，
源主机究竟要如何获得目的主机网络设备MAC地址的呢？
这时，就需要使用到ARP协议。
在网络拓扑中的每个节点或说主机上， 实际都维护有一张ARP表，
它记录着主机的IP地址(网络地址)到MAC地址(物理地址)的映射关系。
ARP协议，
即地址解析协议，它是一个网络层协议，
运行在各网络节点上，负责完成主机IP地址到MAC地址的映射。
工作流
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a743d29145ac5b1565b63c99ee4b334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d6bb83904d164556b053138052aadb/" rel="bookmark">
			sp工具中最疼的是_盘点花园中最值得信赖的园艺工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想生活并不是为了急忙赶路，而是为了有足够的时间放慢脚步。园艺就是为了放慢脚步而出现的一个特别的存在。随着生活压力的增大，很多人选择种些花花草草来转移注意力，花草园艺的种植，让你收获愉悦的心情，体会大自然美好的生活。
但正如一句老话所说，工欲善其事必先利其器。打造一个美丽健康的花园不仅需要园丁的好手艺，一套安全好用的园艺工具是必不可少的，除此之外，高颜值的工具也能让您的园艺生活别具一格。
— ❶ —
修枝好物
很多园艺工作，包括修剪多年生植物、移除乔灌木上多余的小枝、剪根、摘芯，如果有小型的手用工具在手，便可轻松处理。但有些工作，例如剪枝、摘芯、梳枝等，还是需要借助长柄的剪切工具来完成。它们中的一部分能通用，另一些则“专工专用”，适用于某些特殊的场合，跟小编一起看看吧。
亚特修枝剪
亚特修枝剪采用电为动力源，使你可以轻松的修剪树枝。表面平滑不易生锈腐蚀，刀刃锋利，修剪花草干脆利落，且不会伤害植物的根茎叶脉。无刷电机的安装，在降低噪音、发热的同时也提高了使用寿命与工作效率。续航能力也很强，正常使用可以连续使用两三天。
亚特电动修剪机
亚特电动修剪机，采用了无线设计，携带方便，不累赘。进口电芯加上全铜线磁钢电机，让你修枝无压力。拥有过压、过流、过温、充放四大保护，防护挡板的设计，以及双控开关，每一处的设计，都以使用者的安全为出发点。
— ❷ —
打草好物
一到雨水阳光充沛的季节，草木长势旺盛，而蚊虫也渐渐多了起来。要保持环境优美和洁净，就要时时地给草地剪剪草，给灌木修修枝。传统的园艺工人都是人工用剪刀来修理，不仅辛苦，工作效率也不高。小编也给大家搜集了两款好用的工具。
亚特电动手推式割草机
亚特电动手推式割草机，有着和扫把一样的外观，轻轻松松就能用于剪草，除草，修剪草坪，而且对不同的杂草还有不同的模式设定。它可以推着走，非常轻便，男女皆可轻松操作。可应全铜线电机，利用电机带动打草绳高速旋转，让绳子犹如锋利的刀片一般，从而达到修剪草坪的效果，相比安装金属刀片的草坪修剪类工具，打草机显得更加安全、方便。
亚特手推车式割草机
亚特的这款手推车式的割草机，拥有加强双层机壳，双控开关，使用非常安全，操作也非常地方便。其自带的集草袋可直接将割下来的草收集起来，低噪又省心。高强度锰钢刀片采用二次淬火工艺，坚固锋利，经久耐用，是质量一流的割草机。
— 3 —
灌溉好物
无论新建花床，还是度过干旱期，你都需要给植物浇水。不同的植物，它们的浇水工具也不同，只有使用正确的工具，才能让所浇的水分充分浸透到土壤中。
这是一款从德国来的新款家用园艺喷雾器，采用了高品质塑料，使它拥有更加坚固厚实的壶壁，使用寿命更长。它的设计更符合人的手型，在使用时带来更好的手感。可调节的喷嘴不会损伤到花朵和叶面，能够提示液体位置的指示器为使用带来方便。
这款水枪拥有高压设计，可以很好的喷射，用来给花草浇水或是洗车都非常的方便。弹簧管设计，不会缠绕扭结。与此同时，它的体型也比较小，方便携带，就是出去旅游，也能随时随地使用，给出行带来了很大的便利。
小编的介绍到这里就结束啦，其实无论浇水或是修剪等各种花园工作，只要有园艺工具的辅助，就能让花园主人的户外工作变得简单、轻松许多，为我们节省更多的时间来享受花园成果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e62cd785ec7254c7dff847c2936c5a/" rel="bookmark">
			Halcon阈值算子 -- 局部阈值之var_threshold
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Halcon阈值算子 – 局部阈值之var_threshold 与local_threshold类似，var_threshold也是基于局部均值和方差。只不过计算公式不一样。
算子的函数签名如下：
var_threshold(Image : Region : MaskWidth, MaskHeight, StdDevScale, AbsThreshold, LightDark : )
下面介绍它的阈值计算公式：
令g(x,y)为点（x,y)处的灰度值，m(x,y) 为均值，d(x,y) 为方差（实际是标准差），则点（x,y）处的阈值v(x,y)定义为： 当LightDark = ‘light’:时，满足下述条件的点被选中到输出区域
当LightDark = ‘dark’:时，满足下述条件的点被选中到输出区域
当LightDark = ‘equal’:时，满足下述条件的点被选中到输出区域
当LightDark = ‘not_equal’:时，满足下述条件的点被选中到输出区域 我们来和local_threshold算子的计算公式做个对比：
都是基于均值和方差都可以设置均值运算窗口大小。local_threshold是通过设置mask_size，var_threshold是通过设置MaskWidth, MaskHeight都有一个方差的比例因子。local_threshold的就是参数k，var_threshold的就是参数StdDevScalelocal_threshold中的方差通过参数R做了归一化。var_threshold未做这样的处理var_threshold有一个特别之处：参数AbsThreshold设置了最小灰度差。如果图像的某一区域背景光照很均匀，那么方差就很小。此时，根据上面计算阈值v(x,y)的公式，AbsThreshold就开始起作用。 以下实例来源于官方帮助文档。
list_image_files ('label', 'default', [], ImageFiles) ImageFiles1 := regexp_select(ImageFiles,'label_...png$') * * Open a window to display the results. read_image (Image, ImageFiles1[0]) get_image_size (Image, Width, Height) dev_open_window_fit_size (0, 0, Width, Height, -1, -1, WindowHandle) set_display_font (WindowHandle, 16, 'mono', 'true', 'false') * * Loop over all images.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76e62cd785ec7254c7dff847c2936c5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9928269a43fa4e386528c5b7280dbf30/" rel="bookmark">
			UML模型图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 静态模型1. 用例图2. 类图(1). 关联关系（association）(2). 聚合关系（aggregation）(3). 组合关系（compostion）(4). 泛化关系(继承关系)（generalization）(5). 实现关系（realization）(6). 依赖关系（dependency）(7). 几种关系强弱比较 3. 对象图4. 部署图5. 组件图 二. 动态模型1. 用例图2. 状态图(1). 定义(2). 状态图的组成 3. 活动图(1). 定义 4. 序列图(1). 定义 5. 协作图(1). 定义(2). 协作图与时序图转换 三. UML机制1. 注释2. 规范说明3. 修饰4. 扩充机制5. 公共划分 四. UML建模1. UML建模流程2. 建模步骤举例 五. 建模工具六. UML与软件工程对应关系1、需求分析2、系统分析3、系统设计4、系统实现（构造）5、系统测试 一. 静态模型 1. 用例图 2. 类图 (1). 关联关系（association） 表示对象之间的联系
描述类的结构之间的关系。具有方向、名字、角色和多重性等信息。一般的关联关系语义较弱。也有两种语义较强，分别是聚合与组合
表示类与类之间的连接，它使得一个类知道另外一个类的属性和方法。
关联可以使用单箭头表示单向关联，使用双箭头或者不适用箭头表示双向关联，不建议使用双向关联，关联有两个端点，每个端点可以有一个基数，表示这个关联的类可以有几个实例。
0..1 表示可以有0个或者1个实例 0..* 表示对实例的数目没有限制 1 表示只能有一个实例 1..* 表示至少有一个实例 关联关系体现的是两个类，或者类与接口之间的强依赖关系，这种关系很强烈，比依赖更强，不是偶然性的，也不是临时性的，而是一种长期性，相对平等的关系
表现在代码层面，为被关联的类B以类属性的形式出现在类A中，也可能是关联类A引用了被关联类B的全局变量。
在Java中，关联关系是使用实例变量来实现的 比如：学生与课程之间就是通过选课关系进行关联 (2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9928269a43fa4e386528c5b7280dbf30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461078716b2a28bffdbd9c2ace528af5/" rel="bookmark">
			SpringBoot整合SpringSecurity（通俗易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注重版权，转载请注明原作者和原文链接
作者：码农BookSea
原文链接： https://blog.csdn.net/bookssea/article/details/109262109 先看后赞，养成习惯。
点赞收藏，人生辉煌。
基于数据库的身份认证 一、创建项目
创建一个 SpringBoot 模块项目，选择相关依赖：
先搭建项目正常访问，在pom.xml中，先把Spring Security依赖注释
&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; 在MySQL数据库中创建一张用户表，id主键自增，并添加两个用户如下：
代码：
创建entity实体
@Data public class UserInfo { private int id; private String username; private String password; private String role; } 创建mapper接口
@Mapper @Repository public interface UserInfoMapper { @Select("select * from user where username = #{username}") UserInfo getUserInfoByUsername(String username); } 创建UserInfoService.java文件 @Service public class UserInfoService { @Autowired private UserInfoMapper userInfoMapper; public UserInfo getUserInfo(String username){ return userInfoMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/461078716b2a28bffdbd9c2ace528af5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8fb10290c199aa4410eb5916baae32/" rel="bookmark">
			hex、bin增加CRC32校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		srec_cat.exe Objects\output.hex -intel -crop 0x08000000 0x0801FFFC -fill 0xFF 0x08000000 0x0801FFFC -STM32_Little_Endian 0x0801FFFC -o …\output-crc.hex -intel
srec_cat.exe Objects\output.hex -intel ：以hex方式读取output.hex文件。
-crop 0x08000000 0x0801FFFC ：裁剪出0x08000000到0x0801FFFC的空间（即128KB的末尾字节）。
-fill 0xFF ：未使用的空间填充0xFF。
0x08000000 0x0801FFFC -STM32_Little_Endian 0x0801FFFC：计算0x08000000到0x0801FFFC的CRC值，以小端格式存储到地址0x0801FFFC 。
…\output-crc.hex -intel : hex文件末尾带crc值的output_crc.hex文件存在上一个目录。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/203/">«</a>
	<span class="pagination__item pagination__item--current">204/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/205/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>