<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbce36ce09831e33b9ed1036b9c5dde/" rel="bookmark">
			【WSN定位】基于chan、taylor算法实现移动基站无源定位附各类参数测试matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ⛄ 内容介绍 节点定位问题是无线传感器网络(WSN)面临的一个难点,科技的发展与进步使得对无线传感器网络定位的要求也与日俱增.没有合理的定位技术,无线传感器网络的应用范围将受到极大的限制,目前改进定位技术突破点体现在改进节点硬件设计以及定位算法两方面. 本论文先讲述了无线传感器网络的发展历程,对无线传感器网络的各方面进行综合分析研究.经历多年的研究探索,无线传感器网络的定位技术主要分为两大类:"非测距"和"测距".通过对这两类定位算法进行全面分析,比较,最后在测距类的定位技术领域中,对TDOA定位系统进行研究. 本论文利用chan、taylor算法,通过Matlab仿真结果证明其有效性.
⛄ 部分代码 BSN = [7,6,5,4,3];
%BSN=3;
%BSN = 3;
R = 3000;
CalNum = 10;
%MSP=MSPosition();
%MS(1)=MSP(1)*R;
%MS(2)=MSP(2)*R;
Noise = 150;
%Noise = [30, 60, 90, 150, 210, 300];
%Noise = [30, 60, 90, 120,150, 180];
for m = 1:5,
for i = 1: CalNum,
MSP = MSPosition();
MS(i,1) = MSP(1)*R;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bbce36ce09831e33b9ed1036b9c5dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04f6ec8cd5093ee14f156415470ae372/" rel="bookmark">
			adb 获取日志命令-史上最全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adb 获取日志命令 adb logcat 获取的是日志buffer中从头到尾的日志，并且最新的日志会持续写入。历史日志多少取决于缓冲区大小，并且我们可以通过参数过滤掉无用的日志。可以使用xlog框架将历史日志保存（可以研究下源码）。
日志打印不了
插拔重启
日志缓冲区修改最大
usb驱动查看
adb重启，端口占用
adb bugreport // 将日志打包成zip到当前电脑目录
adb logcat &gt; log. txt 右箭头是保存到文件
adb logcat抓取日志： adb logcat --help
用法： logcat [options] [filterspecs]
options包括：
-s 过滤TAG
-f 输出日志到到手机的sd卡
-v 设置日志消息的输出格式
brief — 显示优先级/标记和原始进程的PID (默认格式)
process — 仅显示进程PID
tag — 仅显示优先级/标记
thread — 显示优先级/标记，消息线程的PID和TID
raw — 显示原始的日志信息，没有其他的元数据字段
time — 显示日期，调用时间，优先级/标记，PID
threadtime — 显示日期，调用时间，优先级/标记以及发出消息的线程的PID和TID
long — 显示所有的元数据字段并且用空行分隔消息内容
-c 清除缓存区的日志，Clear (flush) the entire log and exit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04f6ec8cd5093ee14f156415470ae372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a2c3d17969ceca7858eaea6ca2f587/" rel="bookmark">
			nginx设置X-Frame-Options防止自己的网站被其他人iframe引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍nginx设置X-Frame-Options属性，防止网站被别人用iframe嵌入使用。兼容大部分浏览器。
背景说明：在项目开发中，单独用了一台服务器进行图片保存，网站上所有的上传图片都放在了这台服务器上。基于这个需求我在这台服务器上开发了上传功能，图片上传成功后返回地址，然后把地址保存在数据库中。
使用方法：在需要上传图片的地方用iframe引入上传页面，进行上传。
出现问题：所有人都可以引入我这个iframe 页面把图片上传到我服务器。
解决方法：只允许我的域名或者网站才能引入iframe页面上传，有且只能是引入上传，不允许直接访问。这样就保证此iframe只有本服务器使用，其他人无权限。实现该功能需要在nginx配置中添加同源策略限制。
在nginx.conf配置的server中添加代码，可以在http中也可以在server中：
#设置iframe允许的域名访问，X-Frame-Options值有四种情况可以百度 add_header X-Frame-Options 'ALLOW-FROM www.baidu.com m.baidu.com'; #谷歌火狐浏览器识别不了上面的header,经过百度需要以下设置才可以 add_header Content-Security-Policy 'www.baidu.com m.baidu.com'; 为了防止浏览器访问，并且必须是自己网站引入，在server中进行referer判断添加以下代码：
#防盗链判断，valid_referers 有多种判断，可以百度 valid_referers *.baidu.com; if ($invalid_referer) { return 403; } 以上就是nginx设置网页只允许指定的页面使用iframe进行引入
上传图片页面html代码如下：
&lt;html&gt; &lt;head&gt; &lt;title&gt;上传&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script&gt; document.domain="baidu.com"; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe name="myupiframe" id="myupiframe" style="display:none;"&gt;&lt;/iframe&gt; &lt;form action="./sc.php" id="myform" method="post" enctype="multipart/form-data" target="myupiframe"&gt; &lt;input type="file" id="ycfile" name="ycfile" onchange="uploadimg(this)"&gt; &lt;input type="hidden" id="tupianlujing" name="tupianlujing" value=""&gt; &lt;div id="ycshowimg"&gt; &lt;/div&gt; &lt;/form&gt; &lt;script&gt; function opennewimg(img) { window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a2c3d17969ceca7858eaea6ca2f587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827aaf90562707242aa8080e827669c0/" rel="bookmark">
			嵌入式常使用的库函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己创建简单的mcu中常用的库函数 文章目录 自己创建简单的mcu中常用的库函数1. 自己编写库函数的意义2. 计算字符串长度.以'\0'作为结束符3. 复制字符串4. 字符串比较5. 将整数转换为ASCII数组6. 将ASCII码字符串转换成整数7. 将字节数组转换为16位整数8.计算CRC,用于Modbus协议9. 根据直线方程上的两点，给X计算第三个点的Y值10. 将BCD码转为ASCII字符11.将二进制数组转换为16进制格式的ASCII字符串12. 变长的 ASCII 字符转换为32位整数 声明：这些函数大部分是我在安富莱电子的教程上面抄下来的，硬汉哥写过很多优秀的教程，大家可以去学习学习，论坛链接。有的是我从别处摘抄来的，这篇文章我会一直补充。 1. 自己编写库函数的意义 但我们在使用c语言写mcu程序的时候，有的时候需要使用库函数，当然我们可以使用标准的库函数，如stdio库用于输入输出
string库用于字符串操作等，但是标准的库实在是太大了，对于mcu很不友好，因此mcu往往会使用其它的一些c库，如keil提供了MicroLIB库，还有其它的如newlib等库，这些库虽然比标准库小的多，但是有时候还是太大了，因此我们就需要封装一些常用的库，来减少c库的引入。
2. 计算字符串长度.以’\0’作为结束符 /* ********************************************************************************************************* *	函 数 名: str_len *	功能说明: 计算字符串长度.以'\0'作为结束符 *	形 参: _str : 缓冲区 *	返 回 值: 无 ********************************************************************************************************* */ int str_len(char *_str) { int len = 0; while (*_str++) len++; return len; } 3. 复制字符串 /* ********************************************************************************************************* *	函 数 名: str_cpy *	功能说明: 复制字符串 *	形 参: tar : 目标缓冲区 *	src : 源缓冲区 *	返 回 值: 无 ********************************************************************************************************* */ void str_cpy(char *_tar, char *_src) { do { *_tar++ = *_src; } while (*_src++); } /* ********************************************************************************************************* *	函 数 名: str_copy *	功能说明: 复制字符串 *	形 参: tar : 目标缓冲区 *	src : 源缓冲区 *	返 回 值: 无 ********************************************************************************************************* */ void mem_set(char *_tar, char _data, int _len) { while (_len--) { *_tar++ = _data; } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/827aaf90562707242aa8080e827669c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/901d76ceed6a0f4e7765599e6b8bc3b4/" rel="bookmark">
			【Linux】Linux基本指令（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
紧接上期【Linux】基本指令（上）的学习，今天我们继续学习基本指令操作，深入探讨指令的基本知识。
目录
（一）常用指令 👉more指令
👉less指令（重要）
👉head指令
👉tail指令
👉时间相关的指令
👉Cal指令
👉sort指令
👉find指令：（灰常重要） -name
👉which指令
👉whereis指令
👉alias指令
👉grep指令
👉top指令
👉zip/unzip指令
👉tar指令（重要）：打包/解包，不打开它，直接看内容
👉bc指令
👉uname –r指令
👉热键[Tab],[ctrl]-c, [ctrl]-d
👉关机
（二）扩展命令
（一）常用指令 👉more指令 语法：more [选项][文件]
功能：more命令，功能类似 cat
在讲【more】指令之前，我们需要先在一个文件中放入很多的数据。这个指令当做了解，现阶段不要求大家掌握，具体如下所示：
cnt=0; while [ $cnt -le 1000 ]; do echo "hello $cnt"; let cnt++; done &gt; myfile.c 然后当我们打印这个文件中的内容时，最终结果就是循环打印出1000条【hello】指令，具体如下：
但是当我们想要去具体看一行的代码时，这样来回的翻动会显得很不方便，于是我们有专门的指令可以进行观看，基于这种情况，就引出了【more】指令。
存在的缺点：
对于【more】指令，存在一个问题就是它显示到一个屏幕满了之后就不显示了，而且只能下翻，不能上翻，在下翻的过程中按回车就可以了，想要退出的话按【q】因此不难看出这个指令还是比较麻烦，所以这个命令我们用得比较少一些。 常用选项：
-n 对输出的所有行编号q 退出more 👉less指令（重要） 对于上述【more】存在的不足，【less】就很好的解决了相关情况。接下来，我们具体聊聊【less】指令。
less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极 其强大。less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看但若使用了 less 时，就可以使用 [pageup][pagedown] 等按键的功能来往前往后翻看文件，更容易用 来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜 语法： less [参数] 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/901d76ceed6a0f4e7765599e6b8bc3b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5843544252935327d21fe01289b217c/" rel="bookmark">
			前端解决 “TypeError: Cannot read properties of undefined (reading ‘xxx‘)的多种情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：控制台报错“TypeError: Cannot read properties of undefined (reading ‘xxx‘)“ 例如：TypeError: Cannot read properties of undefined (reading '$el') at eval
原因分析及解决 情况一：
出现该错误的原因是因为你花括号中的某些属性未定义。极大可能是因为你写错了属性名称
情况二：
异步请求获取数据时，由于数据时异步获取的，所以一开始是没有该数据属性，这种情况下也会报这种错误。比如说我这里有一个数据tableData，初始值为一个空对象。我们在使用{{tableData.detail}}是不会报错的，但如果是{{tableData.detail.name}}这样就会报错了，这是为什么呢？
因为，tableData.detail已经是一个undefined了，你undefined.name就肯定会报错了。
所以在初始化时，detail属性赋值为空对象就行了。
情况三：
后端返回给你的数据没有这个属性 或者 返回的有的有数据有的是null
这个时候需要先查一下，可以加v-if进行判断
情况四：
使用$nextTick,刷新表格的时候，表格未自定义属性，或自定义属性引用错了(因为方法是现成复制过来的找了老半天，坑！)
&lt;template&gt; // 起初没有定义ref="multipleTable" &lt;el-table ref="multipleTable" :data="tableData" style="width: 100%" :header-cell-style="{ background: '#f5f7fa' }"&gt; &lt;/el-table&gt; &lt;/template&gt; methods: { getData() { let params = { ...this.queryFrom } params.pageNo = params.pageNo.toString() params.pageSize = params.pageSize.toString() getSettlementOrder(params).then(res =&gt; { this.tableData = res.result.data || [] // 在数据更新后执行刷新表格 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5843544252935327d21fe01289b217c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30627180c623eaca38081f73a9278639/" rel="bookmark">
			新入职一个00后卷王，天天都加班到12点...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序员职场上，什么样的人最让人反感呢？
是技术不好的人吗？并不是。技术不好的同事，我们可以帮他。
是技术太强的人吗？也不是。技术很强的同事，可遇不可求，向他学习还来不及呢。
真正让人反感的，是技术平平，却急于表现自己的人，每天加班到12点，在老板面前表现得格外积极，弄得其他人都很尴尬。
这就是行业当中的“卷王”。
面对这样的同事，我们该怎么办呢？不要紧，我们悄悄提升自己的技术就是了！
为了助力测试员朋友们跳槽面试、升职加薪、职业困境，提高自己的技术，本文给大家整了一套涵盖“软件测试架构进阶所有技术栈”的快速学习方法和面试资源。
本次是免费分享！
通过大数据总结发现，其实软件测试岗都是差不多的。有下面这几块知识点：
第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础 软件测试的步骤是什么?
如何录制测试脚本?
应该考虑进行如何测试的测试方法
怎样估计测试工作量?
测试设计的问题
当测试过程发生错误时，有哪几种解决办法?
测试执行的问题
测试评估的目标
如何提高测试?
C/S模式的优点和缺点
B/S模式的优点和缺点
Linux grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30627180c623eaca38081f73a9278639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9c170dcff1e885856d783cf9e74f73/" rel="bookmark">
			为什么cpu制程工艺非要追求7nm、5nm甚至2nm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，性能：一方面，手机/笔记本电脑的内部空间非常有限，除掉大面积的电池外，剩余的空间其实非常有限；另一方面，人们对于手机/笔记本电脑性能的需求越来越高，厂家想要提升手机/笔记本电脑性能的话，手机CPU内就需要集成更多的晶体管，在面积有限的前提下，提升晶体管数量就要提升制程工艺，制程工艺的提升必然导致精细度越来越小。
二，续航：CPU制程工艺精细度和手机功耗：由于自然物理限制，电池技术方面却一直没有什么大的提升，要想提升手机续航能力的话，就只能提高CPU制程工艺降低功耗来实现。
三，应用成本：实现能耗比，比如AMD的Ryzen 9 5900X虽然在性能上输给intel的12900K，但耗电量确不到150W低于12900K的240W，这样在散热器、主板和Power Suply的供电需求也降低，采购成本自然也就低了一些（300-400元到500-600元）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba49474d7f22660293104f94f573ad5d/" rel="bookmark">
			Java_JDK19.0.2_Ubuntu18.04中配合海康工业相机SDK环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java_JDK19.0.2_Ubuntu18.04中配合海康工业相机SDK环境搭建 简介1. JDK环境搭建JDK下载JDK环境安装 2. 工业相机环境SDK安装 简介 本文主要介绍在ubuntu中如何搭建jdk环境，以及配合海康工业相机sdk，简单运行其示例程序
1. JDK环境搭建 JDK下载 官网链接：Java Downloads | Oracle
选择对应版本（这里取决于你的硬件平台，本文基于x86平台）
JDK环境安装 a) 拷贝jdk-linux-x64.tar.gz 到Linux系统中；
b) 创建目录， 把JDK解压到对应目录中；
sudo mkdir /usr/lib/jvm	//创建jvm文件夹 sudo tar zxvf jdk-19_linux-x64_bin.tar.gz -C /usr/lib/jvm/	//解压安装包文件到对应文件夹 运行截图：
c) 设置环境变量
sudo gedit /etc/profile 在打开的文件末尾，加入以下内容：
#set java environment export JRE_HOME=${JAVA_HOME}/jre export JAVA_HOME=/usr/lib/jvm/jdk-19.0.2 export PATH=$JAVA_HOME/bin:$PATH:$KE_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 编辑截图：
注意事项：
JAVA_HOME版本号取决于官网下载的版本，可以在解压路径下查看，如下图
d) 设置默认jdk
sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk-19.0.2/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk-19.0.2/bin/javac 300 运行截图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba49474d7f22660293104f94f573ad5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c75f9a14e29fd0ebbf88cd85812422/" rel="bookmark">
			stm32毕设分享100例(五)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【单片机毕业设计项目分享系列】
🔥 这里是DD学长，单片机毕业设计及享100例系列的第一篇，目的是分享高质量的毕设作品给大家，包含全面内容：源码+原理图+PCB+实物演示+论文。
🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的单片机项目缺少创新和亮点，往往达不到毕业答辩的要求，为此学长准备了相对容易且工作量达标，并包含创新点的项目分享给大家。
🧿 整理的题目标准：
相对容易工作量达标题目新颖，含创新点 🧿 项目分享：
https://gitee.com/sinonfin/sharing
课题项目1 : 基于单片机的智能窗户系统 主要功能：一款基于单片机的智能窗户设计，主要可以实现烟雾、光照、温湿度采集。当烟雾超标、温湿度超标时，会自动打开窗户、风扇通风。当光线过暗（晚上）会自动关闭窗户，光线过亮时（白天）会自动打开窗户。还可以进行手动开关窗户。
1.使用STC89C52RC单片机做主控制器。
2.使用LCD1602显示温湿度、烟雾、光照值。
3.使用MQ-2检测烟雾值。
4.使用DHT11检测温湿度。
5.使用光敏电阻检测光照值。
6.使用E18-D80NK检测人体触发情况。
7.使用继电器带动风扇通风。
8.当在手动打开窗户的时候，人体传感器检测到人时，会自动报警且关窗。
9.按键具有手动开关窗、阀值设定灯作用。
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分
工作量：4分
创新点：4分
课题项目2：基于单片机的自动晾衣架设计与实现 整个系统的工作过程为，单片机通过检测水滴检测传感器和光敏电阻经过LM393所反馈的高低电平来判断当前环境的亮度情况以及是否有下雨的情况来控制微动电机正反装来控制其上的衣物左右移动，将其移动到事先准备好的不在室外的环境，实现收衣物。
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目3：单片机的自动售货机设计与实现 主要功能: 一款自动售货机设计，能够实现自动售货功能，使用STC89C52RC单片机做控制，LCD12864做显示，按键做货物的选择，步进电机做出货口的控制，蜂鸣器做报警提示。当选择好货物后，会提示投币付款，付款成功后，蜂鸣器会响一声，并伴随着电机转动，自动出货。
1.使用STC89C52RC单片机做主控制器件。
2.使用LCD12864做显示屏，12864可显示汉字、数字、字母等。显示屏显示欢迎界面、货物信息等。
3.使用按键做货物选择、投币、确实、返回等选择。
4.使用步进电机做出货口的控制，出货完成后，步进电机自动归位。
5.使用蜂鸣器做报警提示，当付款完成后，蜂鸣器会自动响一下，伴随电机转动，自动出货。
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 课题项目4：单片机与GSM的火灾与防盗报警系统 主要功能：一款基于单片机的智能防火防盗报警系统，主要可以实现火灾预警、防盗报警功能，当烟雾、温度传感器被触发时，会自动触发防火报警。当人体检测传感器被触发时，会自动触发防盗报警，触发警报后，GSM模块会自动给手机发送短信。
1.使用STC89C52RC单片机做主控制器。
2.使用LCD1602显示温度、烟雾、人体触发情况。
3.使用MQ-2检测烟雾值。
4.使用DS18B20检测温度值。
5.使用HC-SR501检测人体触发情况。
6.使用SIM900A模块给手机发送短信。
7.采集值超过预设阀值后，蜂鸣器报警提示。
8.四个按键进行布防功能和阀值设置。:
资料齐全，包含内容：源码+原理图+器件清单+实物焊接效果+详细文档
🥇项目综合综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 🧿 项目分享：
https://gitee.com/sinonfin/sharing
未完待续，关注DD学长，持续更新 。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc21b0a5445e0eb9247c200bedc22c31/" rel="bookmark">
			b01lers CTF web 复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		warmup 按照提示依次 base64 加密后访问，可以访问 ./flag.txt，也就是 Li9mbGFnLnR4dA== 。
from base64 import b64decode import flask app = flask.Flask(__name__) @app.route('/&lt;name&gt;') def index2(name): name = b64decode(name) if (validate(name)): return "This file is blocked!" try: file = open(name, 'r').read() except: return "File Not Found" return file @app.route('/') def index(): return flask.redirect('/aW5kZXguaHRtbA==') def validate(data): if data == b'flag.txt': return True return False if __name__ == '__main__': app.run() fishy-motd 这题考的是 xss 中的表单劫持，和一点点 csp 的绕过。
在页面中可以看到 default-src 'none'; 以及一些其他的限制，可以用 meta 标签来进行 url 重定向。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc21b0a5445e0eb9247c200bedc22c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53d15ca0e2fac9de7dc1bde15448d4c8/" rel="bookmark">
			【学习记录】Kalibr标定相机与IMU的一点记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一周更多的时间在搞这个Kalibr的相机与IMU的标定，记录一些问题：
相机重投影误差 相机一定要好好标定，如果重投影误差太大，是优化不出来外参的。好在相机内参，与IMU外参标定，都可以用AprilTag棋盘格标定。重投影误差应该在1px以下才能接受，否则重新标定。
IMU的内参标定 IMU内参标定一开始用的是：imu_utils
后来换成了：allan_variance_ros
因为据说后者没有这些问题：
详见：https://discourse.ros.org/t/open-source-allan-variance-tool-for-rosbags/23136/6
IMU串口的USB缓存问题 一开始标定出来的结果，IMU和相机外参旋转看起来正确，但平移极其离谱，接近0，在kalibr上还提了一个issue：issue#599
官方指出，IMU和相机的时间offset有问题：我用的是100Hz的IMU，但时间间隔却是0或者30ms，如下图：
后来发现，是采用 boost::asio::serial_port 读取串口时，时间戳确实有问题：大概过30ms连续读出来3次的IMU数据。最后确定是串口延迟导致，修改方法：每次插入设备后，通过修改 linux 内核，降低串口的延迟。
sudo sh -c 'echo 1 &gt; /sys/bus/usb-serial/devices/ttyUSB0/latency_timer' 之后这个问题解决，能够做到1ms左右输出一个。这个问题整整调试了一天才发现并解决，在此纪念。
其他问题 如下图，是一次失败的标定。这个原因虽然报错是buffer不够，但本质原因是误差太大。注意看， Gyroscope error 在几百，这显然是不正常的。后来发现原因，gyro 的单位是 rad/s 而不能是 degree，因此量级差太多。修改后一切正常。
附一个正常的标定结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/479be4558973eb5dc1621b2ce776b0d9/" rel="bookmark">
			如何查看正在运行的shell脚本程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要查看正在运行的shell脚本程序，可以使用ps命令来列出当前正在运行的进程，并使用grep命令来筛选出与shell脚本相关的进程。具体命令如下：
plaintextCopy codeps -ef | grep sh 其中，ps命令用于列出所有进程的详细信息，-ef选项用于显示所有进程的详细信息。grep命令用于在ps命令的输出中查找包含“sh”关键字的行，这些行表示正在运行的shell脚本程序。如果需要查看特定的shell脚本程序，可以将“sh”替换为脚本的名称或关键字。
假设我们正在运行三个shell脚本程序，分别是test1.sh、test2.sh和test3.sh，现在我们要查看正在运行的这些程序。
查看所有正在运行的shell脚本程序：
plaintextCopy codeps -ef | grep sh 输出结果可能类似于：
plaintextCopy coderoot 1234 1 0 08:00 ? 00:00:00 /bin/sh ./test1.sh user 2345 1 0 09:00 ? 00:00:00 /bin/sh ./test2.sh user 3456 1 0 10:00 ? 00:00:00 /bin/sh ./test3.sh 其中，第一列是进程所属用户，第二列是进程ID，第三列是父进程ID，第四列是进程优先级，第五列是进程开始时间，最后一列是进程命令。我们可以使用grep命令筛选出包含“sh”关键字的行，这些行表示正在运行的shell脚本程序。2. 查看特定的shell脚本程序：
plaintextCopy codeps -ef | grep test1.sh 输出结果可能类似于：
plaintextCopy coderoot 1234 1 0 08:00 ? 00:00:00 /bin/sh ./test1.sh 在这个例子中，我们使用grep命令筛选出包含“test1.sh”关键字的行，这一行表示正在运行的test1.sh脚本程序。3. 查看正在运行的所有bash脚本：
plaintextCopy codeps -ef | grep bash 输出结果可能类似于：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/479be4558973eb5dc1621b2ce776b0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4db3da318183b2e5f5bc7d6aac5ad0f/" rel="bookmark">
			C#针对VS线程间操作提示：程间操作无效: 从不是创建控件“”的线程访问它的几种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程间操作无效: 从不是创建控件的线程访问它的三种解决方法 线程的3种创建方式：1、Task.Factory.StartNew(() =&gt; );2、new Task(() =&gt;{});3、new Thread()； 方法一：异步委托线程中控件访问方法二：采用不同步的自由线程上下文的基类方法三：取消跨线程访问(不推荐) 转载请标明出处：Python Excellent的博客
线程的3种创建方式： 1、Task.Factory.StartNew(() =&gt; ); private void uiButton1_Click(object sender, EventArgs e) { Task.Factory.StartNew(() =&gt; Test1()); } 2、new Task(() =&gt;{}); private void uiButton2_Click(object sender, EventArgs e) { Task task2 = new Task(() =&gt; { Test2(); }); task2.Start(); } 3、new Thread()； 此为最基础方法 （入门级） private void uiButton3_Click(object sender, EventArgs e) { //方式1： Thread TestThread = new Thread(Test1); TestThread.IsBackground = true; TestThread.Start(); //方式2： Thread thread1 = new Thread(new ThreadStart(Test1)) { IsBackground = true }; thread1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4db3da318183b2e5f5bc7d6aac5ad0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79db7e0d9785daf74d95e8f8543f30f9/" rel="bookmark">
			AOP切换数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先呢，在我们Springboot的配置文件中配置我们的datasourse，和以往不一样的是，因为我们有两个数据源，所以要指定相关数据库的名称，其中主数据源为primary，次数据源为secondary如下:
新建一个配置文件，DynamicDataSourceConfig 用来配置我们相关的bean,
而在这所有的配置中，最核心的地方就是DynamicDataSource这个类了，DynamicDataSource是我们自定义的动态切换数据源的类，该类继承了AbstractRoutingDataSource 类并重写了它的determineCurrentLookupKey()方法。
AbstractRoutingDataSource 类内部维护了一个名为targetDataSources的Map，并提供的setter方法用于设置数据源关键字与数据源的关系，实现类被要求实现其determineCurrentLookupKey()方法，由此方法的返回值决定具体从哪个数据源中获取连接。同时AbstractRoutingDataSource类提供了程序运行时动态切换数据源的方法，在dao类或方法上标注需要访问数据源的关键字，路由到指定数据源，获取连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1159c8fca732cfe3e3b8925b9492db5/" rel="bookmark">
			如何在浏览器里面通过js使用ed25519签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejs后端的crypto已经支持ed25519和ed448签名，但是浏览器里面不能直接使用nodejs的crypto模块。有个叫`crypto-browserify`的模块可以作为crypto在浏览器运行，但是`crypto-browserify`已经五六年没更新了，支持的算法非常有限。
目前比较合适的选择应该是是使用`elliptic`模块。参见：https://github.com/indutny/elliptic
TypeScript的代码例子：
import * as eee from 'elliptic' import { logger } from './logger'; export async function testenc() { try { var ed = new eee.ec('ed25519'); var key = ed.genKeyPair(); var msg = '1234555'; var sig = key.sign(msg); var der = sig.toDER(); var ret1 = key.verify(msg, der); var ret2 = key.verify(msg+'123', der); logger('', der + ' ' + ret1 + ' ' + ret2); } catch (e) { logger('', e); } } 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1159c8fca732cfe3e3b8925b9492db5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ed3a8991dbc52ad4e686447def34b1/" rel="bookmark">
			使用代理之后，电脑浏览器连接不上网络的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、解决方法
1、internet 选项
2.局域网设置关掉所有能勾选的选项（尤其是为LAN使用代理服务器）
二、原因
一、解决方法 1、internet 选项 2.局域网设置关掉所有能勾选的选项（尤其是为LAN使用代理服务器） 二、原因 开启vpn的时候这个代理服务器就会打开，当电脑关机时没来得及关闭vpn时这个代理服务器的选项就会没来得及关上。当你再次关机时，vpn没有开启，但是却开启了代理服务器的选项，就会导致网络异常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2b0251a9a5df5210ef7db22280bd23/" rel="bookmark">
			用java写一个超级详细的在线考试系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个在线考试系统通常包含以下模块：
登录模块：管理员、教师、学生或其他用户可以通过该模块进入系统题库管理模块：可以添加、修改、查询、删除试题考试管理模块：可以创建考试、发布试卷、查询考试列表等考生信息管理模块：可以添加、修改、查询、删除考生信息成绩管理模块：教师可以录入、修改、查询学生考试成绩，学生可以查询自己的成绩 以下是一个简单的在线考试系统的代码示例：
//登录模块 class Login { private String username; private String password; private String role; //管理员，教师，学生等 public boolean validate(String username, String password) { //TODO 验证用户名和密码是否正确 return true; //假设都是正确的 } public String getRole() { //TODO 获取用户的角色 return role; //假设都是管理员 } } //题库管理模块 class Question { private String content; private int type; //1为单选题，2为多选题，3为填空题 private String answer; public void add() { //TODO 添加试题 } public void update() { //TODO 修改试题 } public void delete() { //TODO 删除试题 } public void query() { //TODO 查询试题 } } //考试管理模块 class Exam { private String name; private String startTime; private String endTime; private ArrayList&lt;Question&gt; questions; public void create() { //TODO 创建考试 } public void release() { //TODO 发布试卷 } public void query() { //TODO 查询考试列表 } } //考生信息管理模块 class Student { private String name; private String id; public void add() { //TODO 添加考生信息 } public void update() { //TODO 修改考生信息 } public void delete() { //TODO 删除考生信息 } public void query() { //TODO 查询考生信息 } } //成绩管理模块 class Score { private String studentId; private String examId; private int score; public void enter() { //TODO 教师录入考试成绩 } public void update() { //TODO 教师修改考试成绩 } public void query() { //TODO 学生查询考试成绩 } } 需要注意的是，以上代码示例仅包含了各个模块的框架结构，实际上每个具体的方法都需要进行更加详细的设计和实现。同时，还需要考虑到数据库的设计和实现、界面的设计和实现等因素。因此，这个在线考试系统的代码实现可能需要多个人的合作才能完成，并且需要考虑到各种方面的实际情况，因此需要设计一个详细的计划和流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692c332ee34aa2154a38a28976232d45/" rel="bookmark">
			Vue2项目总结-电商后台管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue2项目总结-电商后台管理系统 去年做的项目，拖了很久，总算是打起精力去做这个项目的总结，并对Vue2的相关知识进行回顾与复习
各个功能模块如果有过多重复冗杂的部分，将会抽取部分值得记录复习的地方进行记录
一：项目简介 前端技术栈 Vue2
vue-router
Element-ui
Axios
Echarts
项目构架 功能模块 用户登录/退出模块
用户管理模块
权限管理模块
角色列表模块
权限列表模块
商品管理模块
商品列表模块
分类管理模块
参数管理模块
订单管理模块
数据统计模块
二：各个功能模块 1：项目初始化 通过vue-cli脚手架进行配置安装
vue2配置
配置vue-router
配置axios
后端接口：http://43.143.0.76:8889/api/private/v1/
在main.js文件配置根路径： axios.defaults.baseURL = ‘http://43.143.0.76:8889/api/private/v1/’
1.1：路由器的配置 配置路由器，通过login登录之后会优先跳转到home父组件（Element-ui的布局模式），redirect重定向路由到welcome欢迎组件
const router = new Router({ routes:[ {path: '/' , redirect: '/login'}, {path: '/login' , component:() =&gt; import('@/components/Login.vue')}, { path: '/home' , component:() =&gt; import('@/components/Home.vue'), redirect: '/welcome', children: [ { path: '/welcome' , component:() =&gt; import('@/components/Welcome.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/692c332ee34aa2154a38a28976232d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b441f5fba269da9c75f7031f97387c/" rel="bookmark">
			C语言--从键盘输入两个字符串，将第二个字符串连接到第一个字符串后面，并输出连接后的结果（不能用字符串库函数strcat()）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define N 50 int main(){ char a[N]={0},b[N]={0}; int len=0,i=0; printf("请输入字符串a："); gets(a); printf("请输入字符串b："); gets(b); len=strlen(a); while(b[i]!='\0') a[len++]=b[i++]; printf("连接后的字符串为："); puts(a); return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f073f83273f85566c6ed175f6a4b4a/" rel="bookmark">
			MySQL SELECT语句查询字符串长度大于、小于或等于指定值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在MySQL中查询字符串长度使用length关键字，具体用法如下： 先了解一下，Mysql中length()、char_length()的区别。 length()：mysql里面的length()函数是一个用来获取字符串长度的内置函数。char_length()：在mysql内置函数里面查看字符串长度的还有一个函数是char_length()。 这两个函数的区别是： length()： 单位是字节，utf8编码下,一个汉字三个字节，一个数字或字母一个字节。gbk编码下,一个汉字两个字节，一个数字或字母一个字节。char_length()：单位为字符，不管汉字还是数字或者是字母都算是一个字符。 查询某字段长度大于10的记录： select * from tablename where char_length(字段名)&gt;10 查询某字段长度小于或等于5的记录： select * from tablename where char_length(字段名) &lt;= 5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a245874f61445483a61cacc0443d114/" rel="bookmark">
			web前端开发和后端开发哪个难度大？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为涉及到的具体的应用的领域不同，所以说不能简单地说哪一个难，对于前端而言你会感觉到入门会非常的简单，这也是会给许多人一种错觉，前端很简单，但是只能说是在入门理解上是有利于新手的，前端在主要是在于网页的变化多端，会遇到的第一个槛大概就是在多变的css和js了，后面随着对前端技术的深入，便会感慨前端真的是浩瀚如海，同时技术的更迭飞快，为适应业务发展，你也必须花时间去学新的技术，对于后端，它更多考验的是逻辑思维，在入门上难度高也是绝大多数人所提及的，而在后期开发上都需要面对的问题包括但不限于后端服务的稳定性（对于预防方案的制定、限流等），需要考虑到延迟、数据的准确性，这时后端的难点个人觉得不是是你的方案要设计得多复杂，而是如何将其简单化。
所以，如果只看入门判定一项语言的难度是片面的，我们应当放长眼光，从各方面去审视，才能选出合适自己的，同时，如果有小伙伴对于前端和后端有兴趣，可以看一下我下面整理的两个方向的思维导图和资源的整理，希望能为你提供些许的帮助~
一、前端方向（大方向） 第一阶段：前端三件套（HTML、CSS、Javascript） 文档教程 【HTML 】w3school教程 :https://www.w3school.com.cn/html/index.asp
【CSS 】w3school教程：https://www.w3school.com.cn/css/index.asp
【JavaScript】w3school教程：https://www.w3school.com.cn/js/index.asp
视频教程 【siki学院】HTML:https://www.sikiedu.com/my/course/206
【siki学院】CSS: https://www.sikiedu.com/course/207
【siki学院】JavaScript：https://www.sikiedu.com/course/212
【黑马程序员】JavaScript入门到精通：https://www.bilibili.com/video/BV1Kq4y1e7d2/
【黑马程序员】JS进阶webAPIs：https://www.bilibili.com/video/BV1AT4y1v75t/
【黑马程序员】JS高级：https://www.bilibili.com/video/BV1DY41177dM/
！注意：原生JS的学习非常重要，在你的原生JS没有达到一定造诣 （比如对原生Js有一个全面的理解，能靠自己独自完成对于一个页面功能的交互等）的时候，不要去盲目的学习其他Js库，不可否认J一些s库是非常优秀的，但它们也是建立于原生Js写出来的，原生Js在面试当中也是占了大头，所以一定要对原生Js有深层的认识后再去拓展。
一些优秀的Js库：有哪些必看的 JS 库？ - 知乎
第二阶段：移动端开发&amp;Ajax编程 文档教程 【AJAX】w3school教程：[https://www.w3school.com.cn/js/js_ajax_intro.asp
(w3school的网页当中能直接输入代码练习，可以直接显示页面效果，挺不错的)
视频教程 【黑马程序员】移动端前端：https://www.bilibili.com/video/BV14J4114768/
【黑马程序员】Ajax+Git零基础到精通：https://www.bilibili.com/video/BV1ZS4y1w7Yz/
第三阶段：前端主流框架 文档教程 【Vue】菜鸟教程：https://www.runoob.com/vue2/vue-tutorial.html
【React】菜鸟教程：https://www.runoob.com/react/react-tutorial.html
【Angular】菜鸟教程：https://www.runoob.com/angularjs/angularjs-tutorial.html
【Bootstrap】菜鸟教程：https://www.runoob.com/bootstrap/bootstrap-tutorial.html
（三大框架一般至少掌握一种，国内用得多的是Vue和React，根据自己的需求学习，如果有时间可以都学一下）
视频教程 【尚硅谷】Vue：https://www.bilibili.com/video/BV1Zy4y1K7SH
【尚硅谷】React：https://www.bilibili.com/video/BV1wy4y1D7JT
【尚硅谷】Angular：https://www.bilibili.com/video/BV1ts411E7qg
【尚硅谷】Bootstrap：https://www.bilibili.com/video/BV1YW411T7yy
第四阶段：node.js全栈开发 文档教程 【node.js】菜鸟教程：https://www.runoob.com/nodejs/nodejs-tutorial.html
视频教程 【黑马教程】node.js:https://www.bilibili.com/video/BV1a34y167AZ
第五阶段：就业面试相关 HTML高频面试题:https://juejin.cn/post/6905294475539513352
CSS高频面试题:https://juejin.cn/post/6905539198107942919
JavaScript高频面试题（上篇）：https://juejin.cn/post/6940945178899251230
JavaScript高频面试题（下篇）：https://juejin.cn/post/6941194115392634888
Vue高频面试题：https://cloud.tencent.com/developer/article/1675622
React高频面试题：https://blog.csdn.net/sinat_17775997/article/details/82994810
第六阶段：项目实战 小米商城：https://www.bilibili.com/video/BV1gs411c7AC/
网易云音乐：https://www.bilibili.com/video/BV1c44y1g7ac/
哔哩哔哩移动端：https://www.bilibili.com/video/BV1kS4y1b7du
超简单的微信小程序：https://www.bilibili.com/video/BV13L4y1w729/
头条新闻vue客户端开发实战：https://www.bilibili.com/video/BV1t3411N7aP/
Node听歌识曲：https://www.bilibili.com/video/BV1Qy4y1G71n/
二、后端方向（大方向） 第一阶段：前端基础 文档教程 【HTML 】w3school教程 :https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a245874f61445483a61cacc0443d114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9107e95ce24c28dca18e6f519d703f5c/" rel="bookmark">
			ROS源代码阅读(2)-网络参数初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节我们讲到ros的切入点，其中有初始化了网络模块
上一节原文链接：https://blog.csdn.net/lxj362343/article/details/126088735
//转换传入参数为remapping后调用调用此函数 void init(const M_string&amp; remappings, const std::string&amp; name, uint32_t options) { if (!g_atexit_registered) { g_atexit_registered = true; //atexit函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数， // 一个进程可以登记32个函数，这些函数由exit自动调用，这些函数被称为终止处理函数， //atexit函数可以登记这些函数。exit调用终止处理函数的顺序和atexit登记的顺序相反， //如果一个函数被多次登记，也会被多次调用,也就是说退出时将调用atexitCallback这个函数。 atexit(atexitCallback); } if (!g_global_queue) { g_global_queue.reset(new CallbackQueue); } if (!g_initialized) { g_init_options = options; g_ok = true; ROSCONSOLE_AUTOINIT; // Disable SIGPIPE #ifndef WIN32 signal(SIGPIPE, SIG_IGN); #endif check_ipv6_environment(); //network相关的初始化，调用的network命名空间下的init network::init(remappings); //master相关的初始化 master::init(remappings); // names:: namespace is initialized by this_node this_node::init(name, remappings, options); file_log::init(remappings); param::init(remappings); g_initialized = true; } } network::init(remappings);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9107e95ce24c28dca18e6f519d703f5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/480884c06bed27f4a78cecd8ad834e31/" rel="bookmark">
			【读点论文】A Survey on Vision Transformer,2022年华为诺亚最新综述研究，从发展到任务，整体到局部。ViT有研究价值在于有很多问题还没有解决，真理是阶段性的产物
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A Survey on Vision Transformer Abstract transformer最早应用于自然语言处理领域，是一种主要基于自注意机制的深度神经网络。由于其强大的表示能力，研究人员正在寻找将transformer应用于计算机视觉任务的方法。在各种可视化基准测试中，基于transformer的模型的性能类似于或优于其他类型的网络，如卷积和循环神经网络。由于transformer具有较高的性能和较少的视觉特异性感应偏置（inductive bias）需求，越来越受到计算机视觉界的关注。
在本文中，我们通过对这些视觉transformer模型在不同任务中的分类，并分析它们的优缺点，对它们进行了综述。我们探讨的主要类别包括主干网络、高/中级视觉、低级视觉和视频处理。我们还包括高效的transformer方法，将transformer推向实际的基于设备的应用程序。此外，我们还简要介绍了计算机视觉中的自注意机制，它是transformer的基础部件。在本文的最后，我们讨论了视觉transformer面临的挑战，并提出了进一步的研究方向。
论文地址：[2012.12556] A Survey on Vision Transformer (arxiv.org)
华为诺亚方舟实验室联合北大和悉大整理了业界第一篇视觉Transformer综述入选TPAMI 2022.MindSpore官网
在学习的时候另一篇VIT的综述研究也蛮不错的，[2111.06091] A Survey of Visual Transformers (arxiv.org)
INTRODUCTION 深度神经网络(DNNs)已经成为当今人工智能(AI)系统的基础设施。不同类型的任务通常涉及不同类型的网络。例如，多层感知器(MLP)或全连接(FC)网络是神经网络的经典类型，它由多个线性层和非线性激活叠加在一起。卷积神经网络(cnn)引入了卷积层和池化层来处理平移不变数据，如图像。循环神经网络(RNNs)利用循环单元来处理顺序数据或时间序列数据。transformer是一种新型的神经网络。它主要利用自注意机制来提取内在特征，在人工智能应用中显示出巨大的应用潜力。
根据Google Scholar的数据，Transformer应用的Odyssey和Transformer和ViT引用的增长。
（左上）多份会议出版物中Transformer引用的增长，包括：NIPS、ACL、ICML、IJCAI、ICLR和ICASSP。
（右上）Arxiv出版物中ViT引用的增长。
（左下）语言模型的奥德赛。
（右下）视觉transformer主干，其中黑色是有外部数据的SoTA，蓝色是指没有外部数据的SoTA（最好用颜色查看）。
Transformer首先应用于自然语言处理(NLP)任务，并取得了显著的改进。例如，[Attention is all you need.]首次针对机器翻译和英语选区解析任务提出了基于注意机制的transformer。[Bert]引入了一种新的语言表示模型，称为BERT(来自transformer的双向编码器表示形式的缩写)，它在未标记的文本上预先训练一个transformer，考虑到每个单词的上下文，因为它是双向的。当BERT发布时，它在11个NLP任务上获得了最先进的性能。[Language models are few-shot learners]在45tb的压缩明文数据上使用1750亿个参数预训练了一个名为GPT-3(生成式预训练transformer3的缩写)的基于transformer3的大型模型。它在不需要任何微调的情况下，在不同类型的下游自然语言任务上取得了强大的性能。这些基于transformer3的模型具有很强的表示能力，在自然语言处理方面取得了重大突破。
受NLP领域transformer架构的重大成功的启发，研究人员最近将transformer应用于计算机视觉(CV)任务。在视觉应用中，CNN被认为是的基本组件，但现在transformer显示它是CNN的潜在替代品。[Generative pretraining from pixels]训练了一个序列transformer来自回归预测像素，实现了与cnn在图像分类任务上相当的结果。另一种视觉transformer模型是ViT，它直接对图像补丁序列应用纯transformer对完整图像进行分类。Dosovitskiy等人最近提出[End-to-end object detection with transformers]，它已经在多个图像识别基准上实现了最先进的性能。除了图像分类，transformer还被用于解决各种其他视觉问题，包括物体检测[Deformable detr]，语义分割[Rethinking semantic segmentation from a sequence-tosequence perspective with transformers]，图像处理和视频理解。由于其出色的性能，越来越多的研究人员提出了基于transformer的模型来改善广泛的视觉任务。
由于基于transformer的视觉模型的数量迅速增加，跟上新进展的速度变得越来越困难。因此，迫切需要对现有工程进行勘测，这对社会是有益的。在这篇论文中，我们重点提供了视觉transformer的最新进展的全面概述，并讨论了进一步改进的潜在方向。为了便于今后对不同主题的研究，我们根据应用场景对transformer模型进行分类，如下表所示。主要包括骨干网络、高/中水平视觉、低水平视觉和视频处理。高级视觉处理的是对图像中所看到的东西的解释和使用，而中级视觉处理的是如何将这些信息组织成我们所体验到的物体和表面。
Representative works of vision transformers.
鉴于在基于dnn的视觉系统，高级和中级视力之间的差距越来越模糊，我们在这里将它们作为一个单独的类别来对待。解决这些高/中级视觉任务的transformer模型的一些例子包括DETR，用于物体检测的可变形DETR和用于分割的Max-DeepLab。低级图像处理主要处理从图像中提取描述(这些描述通常表示为图像本身)。底层图像处理的典型应用包括超分辨率、图像去噪和风格转移。目前，只有[Pre-trained image processing transformer]、[Image transformer]少数作品在低级视觉中使用transformer，产生了进一步调查的需要。另一类是视频处理，这是计算机视觉和基于图像的任务的重要组成部分。由于视频的顺序特性，transformer天生就非常适合用于视频任务，在这些任务中，transformer的性能开始与传统的cnn和rnn相当。在这里，我们调查了与基于transformer的可视化模型相关的工作，以跟踪这一领域的进展。下图显示了视觉转换器的开发时间表——毫无疑问，在未来会有更多的里程碑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/480884c06bed27f4a78cecd8ad834e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412d7d4015537b1f7c56421163530ee1/" rel="bookmark">
			rustdesk-server的中继服务器的是什么原理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、rustdesk-server的中继服务器是什么原理？
RustDesk是一个开源的远程桌面应用程序，可以让用户远程连接到另一台计算机，以便能够远程控制和访问该计算机上的应用程序和文件。RustDesk的中继服务器是其网络通信的核心组件之一，它充当了客户端和目标计算机之间的中间人，通过该服务器中转数据传输。
RustDesk的中继服务器是基于WebSocket协议实现的。它使用WebRTC技术建立客户端与中继服务器之间的点对点连接，然后将客户端发送的数据传输到目标计算机上。该中继服务器运行在云服务器上，并具有高可靠性和可扩展性，可以支持大量同时连接的客户端。
当客户端发起连接请求时，中继服务器会向目标计算机发送一个连接请求，以便将其连接到客户端。中继服务器在客户端和目标计算机之间进行数据传输，以确保所有数据都可以通过安全的加密通道进行传输，并确保数据传输的完整性和机密性。
需要注意的是，RustDesk的中继服务器并不会对数据进行存储或监视，其作用仅仅是在客户端和目标计算机之间进行数据传输。
2、RustDesk是数据的中介，那么这个中介是不是显得多余吗？ 直接两个计算机相连接不就好了吗？拿这个中介来干什么？
虽然理论上两台计算机可以直接连接，但实际上，在许多情况下直接连接存在一些限制和挑战。例如，两台计算机可能位于不同的网络中，防火墙或路由器的设置可能会限制连接，或者其中一台计算机可能是动态IP地址。此外，在进行远程连接时，可能会面临诸如安全性、可靠性和可扩展性等挑战。
在这种情况下，使用一个中继服务器可以简化连接过程，并提供更可靠和安全的连接。中继服务器可以作为安全通道来传输数据，中继服务器还可以处理防火墙和路由器限制，并提供网络地址转换（NAT）穿透服务以允许两台计算机之间的直接通信。
此外，使用中继服务器还可以提供额外的功能和优势。例如，它可以为用户提供在线状态和其他相关信息，允许用户轻松管理多个远程连接。还可以提供远程协助功能，允许管理员在没有用户在场的情况下进行故障排除。
因此，使用中继服务器在远程连接中具有许多优势，可以提供更可靠和安全的连接，同时还可以提供其他有用的功能和服务。
但是rustDesk，本来就可以把两个不通局域网的电脑做连接呀？这种情况下建立中继服务器还有什么优势？
RustDes确实可以直接连接两个不同局域网的计算机，无需中继服务器，因为RustDesk使用WebRTC技术，该技术允许浏览器之间进行点对点连接，即使它们在不同的网络中也可以直接通信。
然而，在一些情况下，使用中继服务器仍然有一些优势。比如：
可以提供更可靠的连接。虽然WebRTC技术允许点对点连接，但是在某些网络条件下，直接点对点连接可能不太可靠。使用中继服务器可以提供更稳定的连接，同时也可以提高连接的速度和质量。
可以简化连接过程。对于普通用户来说，使用中继服务器可以使连接过程更加简单和容易，因为他们不需要手动配置端口映射或其他网络设置。
可以提供更好的安全性。中继服务器可以作为安全通道来传输数据，提供更好的加密和身份验证机制，以保护数据传输的安全性。
可以提供更好的管理和监控功能。使用中继服务器可以更方便地管理和监控远程连接，例如记录日志、监视活动等。
总之，尽管RustDesk可以直接连接两个不同局域网的计算机，但是使用中继服务器仍然有许多优势，可以提供更好的连接体验、安全性和管理功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3943809fb78a77b700694bbe038a5fe/" rel="bookmark">
			基于Matlab的脉冲多普勒雷达仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
⛄ 内容介绍 脉冲多普勒(PD)雷达,它利用了多普勒效应原理,既具备脉冲雷达的测距性能,又具备多普勒雷达的测速性能,同时对杂波的抑制能力也比较突出,是一种重要的全相参体制的雷达.
⛄ 完整代码 %% 多普勒雷达信号处理过程
%%
clc;
close all;
clear;
%% 参数设置
fs = 80e6; %载波频率(Hz)
f0 = 100e6; %中频(Hz)
B = 5e6; %脉冲带宽(Hz)
ts =5e-6; %脉冲时宽(s)
prt = 100e-6; %脉冲重复时间间隔(s) prf = 10kHz
num = 32;
N = round(fs*ts); %1个脉冲的采样点数
n = -N/2:1:N/2-1;
NN = round(fs*prt); %1个脉冲重复间隔内的采样点数
NN_total = NN*num; %32个脉冲重复间隔内的采样点数
n_total = -0.5*NN_total:1:0.5*NN_total-1;
t_total = ts/N*n_total;
t = ts/N*n; %1个脉冲对应的时间范围 fd = 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3943809fb78a77b700694bbe038a5fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98af21d50da80f1e982f42cf13d1b932/" rel="bookmark">
			linux-----uboot和kernel移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.uboot移植：
1.1 在U-Boot中添加自己的开发板
1.2 添加开发板默认配置文件
1.3 添加开发板对应的头文件
1.4 添加开发板对应的板级文件夹
1.4.1 修改 mx6ull_alientek_emmc 目录下的 Makefile 文件
1.4.2 修改 mx6ull_alientek_emmc 目录下的 imximage.cfg 文件
1.4.3 修改 mx6ull_alientek_emmc 目录下的 Kconfig 文件
1.4.4 修改 mx6ull_alientek_emmc 目录下的 MAINTAINERS 文件
1.5 使用新添加的板子配置编译 uboot
1.6.1 I.MX6U-ALPHA 开发板网络简介
1.6.2 网络 PHY 地址修改
1.6.3 删除 uboot 中 74LV595 的驱动代码
1.6.4 添加 I.MX6U-ALPHA 开发板网络复位引脚驱动
1.6.5 修改 drivers/net/phy/phy.c 文件中的函数 genphy_update_link
1.7 其他需要修改的地方
2. Linux内核移植：
2.1 在 Linux 中添加自己的开发板
2.2 添加开发板默认配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98af21d50da80f1e982f42cf13d1b932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb05fb5a5e4838a9d8bafeacf1599cf4/" rel="bookmark">
			解决 Could not build wheels for pandas, which is required to install pyproject.toml-based projects
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习李沐老师的深度学习的课程，在安装 d2l 时，
pip install d2l==0.17.6 遇到了问题：
ERROR: Could not build wheels for pandas, which is required to install pyproject.toml-based projects
由于我忘记截错误的图了，在论坛里找了别人的错误截图贴过来：
网上找了好多办法，有说 3.10 降到 3.9，有说 conda 删掉 d2l 重装的，有说网上下载 pandas 编译好的 wheel 直接替换的。尝试了都无法解决。
不过最后一个方法给了我灵感，既然 pip 是下载到本地后进行编译，那我应该可以下载编译好的产物或者源文件，直接安装？
我查了一下 python 官方文档是否支持本地安装，果然是支持的，所以通过本地安装这个包解决了问题：
在 https://pypi.org/project/d2l/1.0.0b0/#files ，推荐下载 wheel： d2l-1.0.0b0-py3-none-any.whl
官方文档也解释了更倾向于用 Wheel
根据官方文档按以下命令，安装本地文件，路径换成你下载文件的本地路径，如：
python -m pip install "C:\Users\xxx\Downloads\d2l-1.0.0b0-py3-none-any.whl" py 就是有些系统里 python 的别名，如果遇到输出找不到 py 对象就用 python
Installing Packages — Python Packaging User Guide
然后我们测试一下是否能正常 import d2l
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb05fb5a5e4838a9d8bafeacf1599cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65dae65a3636242d3fa671231b4ae50/" rel="bookmark">
			MySQL如何正确查询字符串长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 笔者最近有一个需求，需要将一段文字插入到备注字段remark前面。
由于担心插入后超过字段长度的限制，所以需要统计线上数据，根据长度倒序查询remark最长的一批数据看看长度。
刚开始百度了一下 MySQL如何查看字段长度，看到了length()，于是就写了这条sql：
select length(remark) from t_card order by length(remark) desc limit 10; 这个字段类型是varchar(512)，而查出来的10条数据基本都大于512，给我整懵了，当时就怀疑这个函数返回的不是字符数量，于是决定探究一下MySQL如何获取字符串长度。
官方文档 既然网上答案参差不齐，不如就去找找权威的官方文档。
进入MySQL文档首页 https://dev.mysql.com/doc/ ，选择下方的参考手册，根据版本笔者选择了MySQL 5.7 Reference Manual。
进入手册后，因为我们要查询字符串的函数，所以左侧目录选择String Functions and Operators。
跳转后可以看到一个函数表格，包括了接近60个字符串函数，我们需要查询字符串长度的函数，使用CTRL + F查找关键词length，大致筛选出以下5个函数：
函数名解释原文翻译BIT_LENGTH()Return length of argument in bits返回参数的bit数CHAR_LENGTH()Return number of characters in argument返回参数中的字符数CHARACTER_LENGTH()Synonym for CHAR_LENGTH()CHAR_LENGTH()的同义词LENGTH()Return the length of a string in bytes返回字符串的长度(以字节为单位)OCTET_LENGTH()Synonym for LENGTH()LENGTH()的同义词 我们可以看到这些函数返回值的单位有bit、字节、字符数，弄清楚单位之间的转换关系就能更好的理解查询结果的含义。
我们知道字节是计算机最小的存储单位，1字节等于8 bit，那么存储1个字符需要用到多少字节呢？这个和使用的编码集有关，查询手册https://dev.mysql.com/doc/refman/5.7/en/charset-unicode.html，以我们最常用的UTF-8为例：
字母、数字和标点符号：1字节大多数欧洲和中东文字：2字节韩语、中文和日语文字：3字节或4字节 看到这里，最开始的疑惑就能解开了，varchar设置的是字符数量，而笔者sql中使用的是LENGTH()，查询的是字符串的字节数，而备注基本都是中文，结果就大概是字符数的两到三倍。
结论 笔者的核心需求是获取字符串长度，所以这里应该使用CHAR_LENGTH() 或者同义函数CHARACTER_LENGTH()。
后语 本文通过查阅官方文档解决一个简单的MySQL问题，旨在记录和鞭策自身建立一种健康的学习方式，主动探究问题，而不只是简单地获取他人的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d67acf2a5d9223efccfb5dfcc419cbe/" rel="bookmark">
			C语言--从键盘中输入10个整数到数组中，统计数组中正数的个数及正数的平均值（平均值保留两位小数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码：
#include &lt;stdio.h&gt; int main(){ int arr[10]; int i=0,count=0,sum=0; double avg=0; printf("请输入10个整数："); for(i=0;i&lt;10;i++){ scanf("%d",&amp;arr[i]); } for(i=0;i&lt;10;i++){ if(arr[i]&gt;0){ count++; sum=sum+arr[i]; } } avg=(double)sum/count; printf("正数的个数为%d，平均值为%.2lf\n",count,avg); return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b269ff68721edadbd4eda1bee087730a/" rel="bookmark">
			第八章：面向对象编程基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第八章：面向对象编程基础 参见往期文章：
第三章：分支结构
第四章：循环结构
第五章：构造程序逻辑
第六章：函数和模块的使用
第七章：字符串和常用数据结构
或转到专栏"python教程"查看
资源目录：代码（8）
文章资源下载：（1-15章）
链接：https://pan.baidu.com/s/1Mh1knjT4Wwt__7A9eqHmng?pwd=t2j3
提取码：t2j3
文章目录 第八章：面向对象编程基础类和对象定义类创建和使用对象访问可见性问题面向对象的支柱练习练习1：定义一个类描述数字时钟。练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。 活在当下的程序员应该都听过"面向对象编程"一词，也经常有人问能不能用一句话解释下什么是"面向对象编程"，我们先来看看比较正式的说法。
"把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。"
这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于知乎。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-F3eNhpDP-1679200100642)(./res/oop-zhihu.png)]
说明： 以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。
之前我们说过"程序是指令的集合"，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，"每个人都应该学习编程"这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，"软件危机"、"软件工程"等一系列的概念开始在行业中出现。
当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的"银弹"，真正让软件开发者看到希望的是上世纪70年代诞生的Smalltalk编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的Simula语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。
说明： 当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。
类和对象 简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-d8S7CzC2-1679200100645)(./res/object-feature.png)]
定义类 在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。
class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print('%s只能观看《熊出没》.' % self.name) else: print('%s正在观看岛国爱情大电影.' % self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b269ff68721edadbd4eda1bee087730a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af9ca83908bb6c1c14053d989dd4ad0/" rel="bookmark">
			聊聊华为的工作模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、试用期与加班工资
二、招聘
三、月度答辩和转正答辩
四、可信考试认证
五、接口人
六、问题缺陷单
七、代码检视
八、功能开发
九、出征海外
一、试用期与加班工资 一般而言，试用期持续的时间为3-6个月，工资、奖金都按正式员工的标准计算。唯一的区别在于，试用期的员工，周末加班不能转调休，相当于白加班。因此，不到最忙的时候，组长（PL）不会叫试用期的员工周末加班，如果非得加班，也会通过外出公干的方式让他们调休。
如果周末两天都加班，双倍工资就是4天，这样相当于基本工资涨80%，接近翻倍了。当然，这种连续的周末加班也很消耗精力，无论你有多么强的体魄或是多么年轻，最终都不得不承认：命要紧。现在周末加班，依然按双倍工资计算，但不会下月发，而是给你累计，直到8年一次换工号，或者离职的时候，才会统一给你结清。并且，周末加班也需要主管审批，不再按打卡时间直接计算。
二、招聘 刚毕业那会，就听说过华为只要是985/211的学生就招，编程题通过就行，几乎不看你的个人经历。华为会以不信任员工为基础，建立一套完善的制度和流程让员工把活干漂亮。承受不了压力的人被淘汰，承受住压力并遵从制度和流程的人能活下去，在这基础上智商、情商特别高的人会拿钱到手软。 在华为非HR也要参与招聘，这几乎成了他们在华为职业生涯中的必经之路。他们会根据现有的人才库，挨个打电话询问就职意愿，并引导他们做面试题、在线编程并参与面试官的1对1面试。
存储的招聘预算不太够，因此招聘一般倾向于招OD/WX的员工。OD的员工工号以300开头，WX的员工工号以WX开头，这两种员工都不算华为的正式员工，其中OD的员工相对更优秀些，主要从事开发工作。而WX开头的员工基本只能从事测试工作，他们按照测试文档一步步执行并查看是否符合预期，绝大多数WX员工并不知道自己为什么要这么执行，预期的结果代表着什么，因为他们没有资格参加方案的设计和串讲，也没有TDE(Test Design Engineer，负责设计测试用例的华为员工)愿意跟他们讲解。
由于外包的人员流失较大，因此招聘的任务就很重。同时又倾向于招聘OD/WX的员工，所以招聘难度会很大。总结一下就是：有能力的人看不上OD/WX，没有能力的人又过不了在线编程等考核。
三、月度答辩和转正答辩 在试用期，每个月都会有一次月度答辩，你要做PPT详细描述在这一个月内你做了啥，学到了啥，并现场回答评委的问题。在转正那一次，又需要准备转正答辩，把整个试用期的工作进行总结。
在答辩过程中，评委们都会认真听你讲，并经过思考询问你一些问题，这种气氛还是不错的。实际上，答辩对绩效的作用并不是特别大，因为你平时做的事情大家都能看到，也能估算出分量。
答辩最大的作用，在于防止新员工偷懒。当一名员工进入公司后，在完全熟悉流程，成为一颗忙碌的螺丝钉之前，会有短暂的空窗期。在这个阶段，由于你啥也不懂，没人会找你，也没法给你分配任务。这时，如果你知道每个月都需要报告工作和学习进展，就会产生足够的动力，尽快融入团队。转正答辩完成后，基本上你已经是一颗标准的螺丝钉了，这时候不再需要答辩，通过绩效考核进行激励即可。
四、可信考试认证 对开发而言，每个人都需要通过可信考试。可信考试分专业级和工作级，一共四门课，四个考试，往往新来的员工更容易通过，因为他们有更充足的时间；而老员工没有时间学习，几乎都是裸考，除了科目一的在线编程，其他科都是理论知识，涵盖的范围包括编程语言语法和技巧、编程语言规范、需求分析、安全红线、设计模式、敏捷开发等等。这些经验被总结成精炼的语言，通过以考促训的思想灌输到每个员工的脑子
五、接口人 从入职到导师脱手，其实就差不多两个月时间。最重要的任务就是通过可信认证考试。两个月后，开始接手一些简单的任务，修改问题单或者承担一些简单的功能开发。但在一些部门，这时候往往会给你一个恐怖的任务----接口人。
一般而言，一个产品会被分为多个模块，每个小组维护多个模块。当测试发现属于某个组的模块出现问题，或者别的模块依赖该模块的部分工作不正常时，他们需要有人能帮忙查看原因，这个人就叫接口人。
一个组大概10个人，负责的模块代码量在数十~数百万行的级别。乍一看，会觉得应该选一个经验丰富的员工，对组内负责的模块、历史情况等掌握很清楚的人作为接口人。但实际上，帮他人看问题找原因，是一种吃力不讨好的工作，因为领导看不到，身边的同事也感知不到。
在有些公司，通常是主管当接口人，他会对问题进行简单的分析，再根据组内成员的擅长领域、负载情况 ，选择合适的人去分析该问题。在华为，类似的岗位是PL，为了绩效，他们不可能每天把时间浪费在这上面。同时，组内的每个人都忙得要命，最熟悉该领域的人可能正在完成紧急任务，根本没时间去分析。因此，PL通常会找组内资历浅一些的同事去充当接口人，并按固定期限轮换。
一个组维护的代码量不算小，让新员工去做接口人，美其名曰“锻炼”，实际上是让他去抗压。作为接口人，PL的要求就是尽可能不打扰到组内其他人，所有问题，除非真正是Bug，否则不能让测试提单。这样的要求看似简单，但对于新员工而言，很多时候测试咨询的问题你连他讲的啥意思都不明白，再加上设计又存在各种历史原因、特殊情况的考虑，新员工大多是懵逼的。想求助经验丰富的同事？如果项目不太紧张的时候还好说，项目紧张起来，每个人都戴着耳机在通话，你可能好几个小时都见不到他们空闲下来。而测试对你的响应时间是有要求的，一小时不给清楚解释？那就提单吧。
举个例子：你在分析A问题发生的原因，阅读完全陌生的代码，另外2个测试给你留言，找你咨询B、C问题。你简单扫了一下B、C问题，都不是你熟悉的领域，需要花时间去读代码，了解设计，才知道是不是问题，所以你暂时没回复。两分钟后，两个测试分别给你打电话，你很烦，不想接电话，但他们不停的打，并在留言中告诉你再不接电话就提单。你只能接起电话好言相劝，告诉他们现在真的很忙，只能请他们先登记，排队等你的消息。没多久，你读到A问题中一部分看不明白的代码逻辑，想找人问，一抬头组内所有人都在打电话。于是你咬咬牙一边跟A的测试确认测试用例的逻辑，一边忽略部分看不懂的代码去猜测后续的逻辑。这时候B、C的测试告诉你不能再等了，上面催着要提单，你只能暂时放下代码再次解释，给他们合理的截止期限并请求他们接受。突然电话又响了，是一个电话会议，问题很严重，线上四五个开发正在一起讨论，需要你做确认，TDE催促让你赶紧看，搞不定就往上捅。你赶紧放下A问题，一边读D问题的现象，一边凭你的理解去回答这几个开发的问题。D问题的难度不大，但涉及的条件特别多，变量也多，逻辑很绕，你得理一理，正在理的过程中，A测试的TDE气愤的给你留言：都看了两个小时了怎么还没结果？必须提单了。
如果实在搞不定了，测试等不及要提单，一般是要跟PL讲的。但作为新员工，你要做好心理准备，因为这时候免不了一顿臭骂。因为PL永远是忙得要死，他有方案要讨论，有设计要做，还有大量组内杂事，本来已经焦头烂额，你不仅不能帮他分担，还告诉他现有的某个问题搞不明白，他也是很崩溃的。但这顿骂往往又是值得的，因为PL会快速给你指明方向，因为如果是定位偏了，他会快速纠正你的方向。
六、问题缺陷单 刚才提到很多次“提单”，就是指的问题单。测试提的问题单，一般代表某个模块的功能有Bug。
问题单的跟踪，华为有一套系统叫DTS，测试提单，开发解决的流程大致如下：
测试外包员工在DTS系统中创建一个问题单，填写产品、版本、问题描述等信息。问题单提给负责该模块的测试TDE（华为正式员工）审核。测试TDE把问题单转发给负责该模块开发的组内PL。组内PL再把问题转发给需要解决该问题的开发。开发把问题解决，提交代码，填写根因分析并把问题单转给组内PL。开发同时需要与测试TDE预约时间，与测试TDE串讲问题单发生的原因和修改后的影响。组内PL等串讲完成并且最新的Build包含开发的Commit Id后，将问题单转给测试TDE。测试TDE将问题单转交给测试外包员工进行验证。 这么一套流程走下来，感觉脱了层皮。对于上级领导来说，他不需要知道细节，只需要要求一个组的问题单的目标数量即可。比如今天整个组剩下40个问题单，明天的要求是35个，后天是30个...
于是，为了达成目标，PL非常反感问题单走到自己组头上。有的问题单涉及到模块间的协调处理，测试提单的时候发现的是A模块的问题，但A模块经研究后发现，实际问题出在A模块依赖的B模块身上，B模块由另一个组维护，于是跟B模块的接口人沟通。这种情况，即使已经基本确定是B模块的问题，B模块的PL、接口人也会想尽一切办法拖延问题单走给B模块的时间，定位问题根因和修改方案后，才会同意问题走到B模块。毕竟每天的问题单目标放在那里，多一个在自己头上，都是沉重的负担！这种时候，A模块的PL肯定也不希望问题单在自己组，所以这时候就看他们两个PL的PK了，作为PL，至少都在华为奋斗了好几年，大家像战友一样有感情，互相理解下，这次留给你，下次留给我，互相不撕破脸。
在这套流程中，开发最不喜欢的步骤就是测试串讲。这个设计的初衷是好的：担心你的改动造成的影响测试不清楚，从而无法对受影响的场景进行测试。但遗憾的就是这个规定太死板，绝大多数的串讲根本没有意义，只需要测试进行原场景复现，并检查问题是否解决即可。
问题单的设计如此复杂，依然是对员工的不信任。在其它公司，流程就简单多了：
测试创建问题单，填写产品、版本、问题描述等信息。问题单提给需要解决该问题的开发者。开发把问题解决，提交代码，填写根因分析和需要重点测试的场景，把单转回给测试验证。 步骤的简化，就对员工的素质要求高。就拿问题单与测试的串讲来说，一般开发人员觉得这个改动的影响比较大，可能需要重点测试一些场景的时候，就会在问题单上注明；同理，测试如果意识到开发人员的改动有风险，或者对开发人员的根因分析不太理解时，也会主动找开发人员沟通。
华为的流程复杂，它的基本逻辑是：信任DE/TDE这种在华为干了很长时间的老员工，新员工不值得信任。配套的激励也是倾向于PL/DE/TDE，这会让新员工做得很憋屈，但这没关系，因为总会过滤出一批忍得住憋屈，愿意遵从规则坚持努力下去的人。
复杂的流程导致了一个问题，就是测试TDE的繁忙程度超乎想象。因为一个测试TDE往往负责多个模块，也就是对应着多位开发，当问题单较多的时候，容易形成了单点瓶颈。举个例子，假设一名TDE手上有10个外包测试员工，分别测出了10个问题，这10个问题对应着8个开发，那这8个开发人员修复完问题后，跟外包测试员工串讲并不算数，必须排队给这名TDE串讲，从而形成了单点瓶颈。
测试TDE忙得找不着北，脾气自然也不会太好。开发更是一点也不敢得罪测试，如果TDE不爽你，别的不说，就单单在串讲里给你挑刺、或者把你的串讲排到最后，都会大大拖慢你的工作进度和工作热情。
七、代码检视 代码检视，也就是Code Review。每个开发写好代码后，都必须发代码检视才能合入主干分支。
在其它公司，开发一般会找对这个领域比较熟悉的两个开发进行检视，得到两个Approve以后，就顺手合入了。
在华为，代码合入理论上需要以下步骤：
选择两个开发检视检视通过后选择一个Committer审核审核通过后，选择具有合入权限的人合入。 一般Committer是在一个团队里的资深员工，技术比较强，并且做事仔细认真。
在其它公司，代码合入步骤简化为：
选择一个开发检视检视通过后找一个Commiter检视并审核再合入。 Committer的数量是很少的，大概占20%左右。100个人要合入代码，都得找这20个人进行代码审核。这部分人基本已经是DE(Design Engineer)，主要承担方案设计、困难问题攻关等任务，同时还要帮大量的同事检视代码。所以他们大多也会忙到找不到北。
这些Committer一方面承担着方案设计等项目上对自己未来有利的工作，另一方面检视所有人的代码，有任何问题会得到耐心的解释（不解释清楚就不会给你审核通过），所以他们的进步会很快。而新员工大多只是执行者，对整体规划、背景原理等都搞不清楚，他们想让Committer耐心解释是不可能的，只有在审核代码的时候，能学到点东西，但也是零零碎碎的。
这样以来，新员工和老员工(Committer)的差距就拉开了。最终导致的结果就是知识断层，新员工很容易流失，因为他们只能在繁琐的工作之余进行自学，老员工没时间教他们；同时他们得到的激励也相对较少，除非拼死拼活爬到Commiter这个位置，否则未来的发展一片渺茫。
八、功能开发 一个需求过来，需要评估完成的时间。但这只是一个参考，每一级都会想办法把时间往短了压。导致最后到开发者这一层，几乎是不可能完成的任务。
举个例子，一个任务，参与设计的开发和测试预估12+4天，版本给的要求是10+3天，但当这个任务真正给到参与实现的开发和测试时，可能只剩下6+1.5天。
中间的时间到哪儿去了？从上到下，每一层领导都担心任务完不成，所以想预留一点缓冲。所以时间从10+3天传达到下层变成8+2.5天，逐渐往下最终变成6+1.5天。所以，功能的开发极其紧迫，你想在规定的时间里完成几乎是不可能的。
一开始，会因为完不成任务非常焦虑。后来发现大家都完不成，目标放在那儿成了摆设，虽然目标时间快到了就开始催，但实际上做不完也不会怎么样。不过，催你的人心里是有底线的，这个底线就是他的上级给他的要求，只是这个底线他永远不会告诉你。
九、出征海外 出征海外，一般是指上一线去海外销售华为产品，可以选择的驻扎地很多，几乎全球都可以。但是选择欧洲那些条件好的国家，补贴很少，选择非州那些条件不好的国家，补贴很给力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af9ca83908bb6c1c14053d989dd4ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221b0e496757b535035270a7d5534603/" rel="bookmark">
			一文读懂史密斯圆图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、是什么？
三、为什么？
四、怎么看？ 五、干什么？
一、前言
这是什么东东？史密斯圆图能干啥用？
二、是什么？
史密斯圆图，就是做高频电路之间的阻抗匹配用的。
该图表是由菲利普·史密斯(Phillip Smith)于1939年发明的，当时他在美国的RCA公司工作。史密斯曾说过，“在我能够使用计算尺的时候，我对以图表方式来表达数学上的关联很有兴趣”。
史密斯图表的基本在于以下的算式。
当中的Γ代表其线路的反射系数(reflection coefficient)
即S参数（S-parameter）里的S11，ZL是归一负载值，即ZL / Z0。当中，ZL是线路本身的负载值，Z0是传输线的特征阻抗（本征阻抗）值，通常会使用50Ω。
简单的说：就是类似于数学用表一样，通过查找，知道反射系数的数值。
三、为什么？
我们现在也不知道，史密斯先生是怎么想到“史密斯圆图”表示方法的灵感，是怎么来的。
很多同学看史密斯原图，死记硬背，不得要领，其实没有揣摩，史密斯老先生的创作意图。
我个人揣测：是不是受到黎曼几何的启发，把一个平面的坐标系，给“掰”了。
世界地图，其实是一个用平面表示球体的过程，这个过程是一个“掰直”。
史密斯原图，巧妙之处，在于用一个圆形表示一个无穷大的平面。
首先，我们先理解“无穷大”的平面。我们复习一下理想的电阻、电容、电感的阻抗。
在具有电阻、电感和电容的电路里，对电路中的电流所起的阻碍作用叫做阻抗。阻抗常用Z表示，是一个复数，实际称为电阻，虚称为电抗，其中电容在电路中对交流电所起的阻碍作用称为容抗 ,电感在电路中对交流电所起的阻碍作用称为感抗，电容和电感在电路中对交流电引起的阻碍作用总称为电抗。 阻抗的单位是欧姆。
R电阻：在同一电路中，通过某一导体的电流跟这段导体两端的电压成正比，跟这段导体的电阻成反比,这就是欧姆定律。
标准式： （理想的电阻就是 实数，不涉及复数的概念）。
如果引入数学中复数的概念，就可以将电阻、电感、电容用相同的形式复阻抗来表示。既：电阻仍然是实数R（复阻抗的实部），电容、电感用虚数表示，分别为：
Z= R+i( ωL–1/（ωC）)
说明：负载是电阻、电感的感抗、电容的容抗三种类型的复物，复合后统称“阻抗”，写成数学公式即是：阻抗Z= R+i(ωL–1/（ωC）)。其中R为电阻，ωL为感抗，1/（ωC）为容抗。
（1）如果(ωL–1/ωC) &gt; 0，称为“感性负载”；
（2）反之，如果(ωL–1/ωC) &lt; 0称为“容性负载”。
我们仔细看阻抗公式，它不再是一个实数。它因为电容、电感的存在，它变成了一个复数。
电路中如果只有电阻，只影响幅度变化。
我们通过上图，我们知道，正弦波的幅度发生了变化，同时，相位也发生了变化，同时频率特性也会变化。所以我们在计算的过程中，即需要考虑实部，也需要考虑虚部。
我们可以在一个复平面里面，以实部为x轴、以虚部为y轴，表示任意一个复数。我们的阻抗，不管多少电阻、电容、电感串联、并联，之后，都可以表示在一个复平面里面。
任意一个阻抗的计算结果，我们都可以放在这个复平面的对应位置。各种阻抗的情况，组成了这个无穷大的平面。
掰弯
在复平面中，有三个点，反射系数都为1，就是横坐标的无穷大，纵坐标的正负无穷大。历史上的某天，史密斯老先生，如有神助，把黑色线掰弯了，把上图中，三个红色圈标注的点，捏到一起。
弯了，弯了
圆了，圆了
完美的圆
黑色的线上的阻抗，有个特点：实部为0；（电阻为0）
红色的线上的阻抗，有个特点：虚部为0；（电感、电容为0）
绿色的线上的阻抗，有个特点：实部为1；（电阻为50欧姆）
紫色的线上的阻抗，有个特点：虚部为-1；
蓝色的线上的阻抗，有个特点：虚部为1；
四、怎么看？ 简而言之，是看一线、两弧和两圆、三点。
接下来我们就从一线和三点讲起
史密斯圆图被一条名为电阻线的蓝色横线分成上下两个半区，上半部分叫电感区，那里所有点的虚部值部为正。下半部分叫电容区，那里所有点的虚部值部为负。而电阻线本身的虚部阻抗值不正不负，他上面每一个点的阻抗值均为0Ω，所以电阻线是一条特殊的实部线。电阻线上有三个点，最左侧的叫短路点，它表示实部值为0Ω，虚部值也为0Ω的情况；最右侧的叫断路点，他表示实部值为无穷大，虚部值也为0Ω的情况；而中间点，也就是圆心那是匹配点，那里的阻值是标准阴值，一般情况下他是50Ω，三点是史密斯圆图的基点，也是我们校正天线分析仪的起点。
两圆两弧——等实部圆和等虚部弧
红色的圆圈都叫阻抗圆，而绿色的圆圈都叫导纳圆，我们在电阻线上找到实部阻抗值或者实部导纳值之后，就要沿着阻抗圆或者电纳圆去找虚部值。其中电阻线以上的点是正值，代表阻抗点的虚部值呈现感性。电阻线以下的点是负值，代表阻抗点的虚部值呈现容性（上感下容）
到底怎么读图？
先说归一化阻抗值的读图方法：
第一步，用阻抗值除以标准电阻，得到归一化实部阻抗值和归一化虚部阻抗值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/221b0e496757b535035270a7d5534603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ccd41db580a6af772e898a8bc99fe1a/" rel="bookmark">
			2023年华为认证H12-821、H12-831考试指南（包括学习视频和题库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是HCIP-Datacom 英文名：HCIP-Datacom-Advanced Routing &amp; Switching Technology
中文名：培训与认证具备数通领域路由交换高阶知识和技能水平的高级工程师
二、通过认证后可以做什么? 可以胜任中到大型企业网络工程师岗位，掌握中到大型网络的特点和通用技术，具备使用华为数通设备进行中到大型企业网络的规划设计、部署运维、故障定位的能力，并能针对网络应用设计出较高安全性、可用性和可靠性的解决方案。
三、考试科目 四、学习视频推荐 1.前提条件：如果大家没有HCIA的基础，或者HCIA的技术掌握的不好，建议大家重新学一下 免费学习视频（适合自律的学生）：华为认证HCIA视频合集（理论+实验+真题全套综合讲解）_哔哩哔哩_bilibili
收费学习视频（有问题可以和老师交流）：
华为HCIA-Datacom全套学习视频课-学习视频教程-腾讯课堂
2.HCIP学习视频 比路由交换新增了很多的知识点：
学习大纲大家可以看一下，哪些东西你不会：
华为Datacom网络工程师HCIP全套学习课程（全套理论+实验）-学习视频教程-腾讯课堂
五、学习完了以后，大家可以开始刷题了 1.题库有3000多道题（大家最好先学理论，然后再刷题，不但要知其然，还要知其所以然） （1）单选题
题型举例：
（2）多选题
题型举例：
（3）判断题
题型举例：
（4）连线题
题型举例：
（5）填空题
题型举例：
2.模拟软件介绍（只要模拟考可以拿到900分，去VUE考试肯定能过） 模拟软件使用方法：考华为认证想刷题，用这个工具就可以了_哔哩哔哩_bilibili
3.怎么预约考试 预约考试指南：华为Datacom认证报考指南（华为认证考试如何报名）-学习视频教程-腾讯课堂
六：HCIP要掌握的实验 七、考试题库（部分）
501.
（主观题）某园区部署0SPF实现网络互通，R3的GE0/0/2接口也开启OSPF 。其中Area1部署为NSSA区域，各设备地 址如图所示。某工程师在R3上配置静态路由访问R4的环回口地址，且在OSPF进程中引入该静态路由。此 时，R1收到的Type5 LSA中，转发地址（FA）是： 。 （注：请填写IP地址，不加掩码）（无图）
解析：
10.1.12.2
502.
（主观题）大型网络中为了提高RP的可靠性，一般部署动态RP 。 请将动态RP选举的规则按照优先级从高到低进行排序
解析：
​
RP竞选规则如下：
与用户加入的组地址匹配的C-RP服务的组范围掩码最长者获胜。
如果以上比较结果相同，则C-RP优先级较高者获胜（优先级数值越小优先级越高）。
如果以上比较结果都相同，则执行Hash函数，计算结果较大者获胜。
如果以上比较结果都相同，则C-RP的IP地址较大者获胜。
503.
（主观题）缺省情况下，路由器接口上发送PIM Hello。报文的时间间隔是【】秒。（使用阿拉伯数字）
正确答案：30
解析：
30.本题为记忆题，pim hello报文的发送周期为30s
504.
（主观题）请将下列BGP报文与其作用对应起来
解析：
505.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ccd41db580a6af772e898a8bc99fe1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678923b7927622ec42a5c92ccc1bf98d/" rel="bookmark">
			计算imbalanced dataset的class weight
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. import numpy as np def get_weights(n_classes, samples_per_cls, power=1): w = 1/np.array(np.power(samples_per_cls, power)) w = w / np.sum(w) * n_classes return w / np.sum(w) 2. from sklearn.utils.class_weight import compute_class_weight import numpy as np def get_weight(y_train): w = compute_class_weight('balanced', np.unique(y_train), y_train) w = w/np.sum(w) return w y_train = np.array([0]*1113 + [1]*6705+[2]*514+[3]*327+[4]*1099+[5]*115+[6]*143) print(get_weight(y_train)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/780b53fb513fd50a7e29c76daef79cc8/" rel="bookmark">
			Python接口自动化脚本业务框架总概（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
接口自动化框架目录
基础类封装概览
基础类封装方法详解
Log.py文件
Request.py文件
Python是目前主流的接口自动化脚本语言之一。
本专栏将联系业务介绍使用python接口自动化脚本范例。
适合对象：已有一定python基础，对自动化感兴趣的小伙伴。
接口自动化框架目录 目录说明：
在Project目录下新建你的项目，里面再次拆分出本项目的相关配置公共模块、接口层、用例层。
公共模块功能：存放配置、封装公共调用方法
接口层功能：封装调用接口
用例层功能：调用封装的接口，传入不同参数校验、场景模式校验，设置断言
基础类封装概览 将公共的模块封装为基础类，比如发送请求的request、log日志封装等等。
这些模块是每个业务线或者接口都需要使用到的，故将其放在Common下面进行编写封装。
基础类封装方法详解 Log.py文件 目的：用例执行过程中打印日志，定位问题。
小tips：
导入模块，如果有标红显示，说明你的lib下面没有这个第三方的资源了，可以在Terminal下面使用命令直接下载 pip install colorama
下面为封装Log日志的方法：
# -*- coding: utf-8 -*- """ 封装log方法 """ import logging import os import time import stat import datetime from hashlib import md5 from colorama import Fore, Style TRACE_ID_LIST = [] LEVELS = { 'debug': logging.DEBUG, 'info': logging.INFO, 'warning': logging.WARNING, 'error': logging.ERROR, 'critical': logging.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/780b53fb513fd50a7e29c76daef79cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b26938b416aea39da5c3a9a8e53b1ed/" rel="bookmark">
			STM32G070 使用 OpenBLT 记录。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个项目需要使用UART来更新程序。(因为设备组装好之后，拆开就非常麻烦了)
在网上找到了开源的OpenBLT。具体的资料自行百度。
这里记录下使用的流程。
0.下载源码 Feaser - OpenBLT Bootloader
1. 创建boot工程 使用STM32CUBE来创建，使用内部晶振，配置UART口。UART需要使用LL库。
LED 和看门口根据需要进行添加。
参考源码目录下的DEMO进行来添加所需的文件：
openblt\Target\Demo
支持很多MCU。
创建三个组：
core里面的代码貌似适合硬件无关的 直接添加即可。
位置：X:\openblt\Target\Source
App里面的代码是参考demo里面的。
主要是配置openblt的功能，使用UART CAN或者网口进行程序下载。
blt_conf.h就是配置文件。
led可以根据需要进行添加。
myApp.c直接参考demo的main函数写的。
代码位置：X:\openblt\Target\Demo\ARMCM0_STM32G0_Nucleo_G071RB_Keil\Boot
ARMCM0_STM32G0组里面的文件是和硬件相关的，直接拷贝移植到的文件就行。
使用的MCU是STM32G070，因此直接看考作者移植好的文件就行。
代码位置：X:\openblt\Target\Source\ARMCM0_STM32G0
最后在main函数的最后调用：MyAppMain(); 就可以了。
根据自己的需要进行的修改：
我这边需要的功能是，boot启动以后，进入程序更新操作，等待上位机发送更新指令。超时时间为5秒钟。超过5秒后，直接进入到APP程序。
需要修改一个宏：
#define BOOT_BACKDOOR_ENTRY_TIMEOUT_MS (5000)//(500) 在flash.c文件添加一个函数:
blt_bool iap_load_app(void) { unsigned int appRunAddr = flashLayout[0].sector_start; /* Test if user code is programmed starting from address "APPLICATION_ADDRESS" */ if (((*(volatile unsigned int*)appRunAddr) &amp; 0x2FFE0000 ) == 0x20000000) { return BLT_TRUE; }	else { return BLT_FALSE; } } 主要是因为我没看懂 FlashVerifyChecksum()这个函数。原版的代码使用MicroBoot可以让程序启动，但是使用JTAK烧写的程序就无法启动，也无法进行调试。感觉太麻烦了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b26938b416aea39da5c3a9a8e53b1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/896cda4155379db7c1537a31ec7afe66/" rel="bookmark">
			正则替换replace中$1的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、repalce定义
用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。
stringObject.replace(regexp/substr,replacement)；参数一：必需，规定的字符串或者正则表达式参数二：必需，一个字符串值。规定了替换文本或生成替换文本的函数。！！！replacement 中的 $ 字符具有特定的含义。详情见W3C 二、有$1,$2...的例子
//把 "Doe, John" 转换为 "John Doe" 的形式： var str = "Doe, John"; str.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1"); 说明：$1,$2上就是按顺序对应小括号里面的小正则 捕获到的内容。 str.replace(/(\d{3})\d{5}(\d{3})/g, '$1*****$2') //把电话号码中间五位替换成* 三，第二个参数是函数
把字符串中所有单词的首字母都转换为大写： var str = 'aaa bbb ccc'; uw=str.replace(/\b\w+\b/g, function(word){ return word.substring(0,1).toUpperCase()+word.substring(1);} ); 说明：匹配一次就执行一次函数，匹配的内容作为参数 //把数字转成对应的汉子 var ary=["一","二","三","四","五","六"] "123456".replace(/\d/g,function(val){ return ary[val-1] }) 四、一个例子，实现模板字符替换
var obj = { name:'leaf', age:20 } var str = "我是{{name}}，name是我的名字，我今年{{age}}岁"; //最终替换成"我是leaf，name是我的名字，我今年20岁" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/822babcda722d38361110a8935871d1f/" rel="bookmark">
			Java常用工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java常用工具类 Object类 Object类是类层次结构的根。每个类都有 Object作为超类。所有对象，包括数组，实现这个类的方法。
getClass()方法 返回该 Object运行时类。返回的 类对象是由类的代表 static synchronized方法锁定对象。
hashCode()方法 public int hashCode() 返回一个对象的哈希代码值。这种方法对于hash表，如所提供的 HashMap利益支持
//基本数据类型没有hashCode()
public static void main(String[] args) { //每new一个对象hashcode都不同 Student s1 = new Student(); Student s2 = new Student(); int a=10; int ai = new Integer(10); System.out.println(a==ai);//true System.out.println("==================="); /** * 基本类型使用==，是比较基本类型的本身是否相等 * 引用类型==，是比较变量存放的地址值 */ System.out.println(s1==s2);//false //引用类 System.out.println(s1.hashCode()==s2.hashCode());//false Student s3=s2; System.out.println(s3==s2);//true System.out.println(s3.hashCode()==s2.hashCode());//true System.out.println("========================="); String t1="y1"; String y="y",s="1"; String ys=y+s;//y1 String yi = new String("y2"); System.out.println(t1.hashCode()==yi.hashCode());//false //基本数据类型没有hashCode() System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/822babcda722d38361110a8935871d1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c455527dcffdf63482e3a59a3dc76930/" rel="bookmark">
			SpringBoot&#43;Mybatis实例（图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目搭建
二、数据库设计
三、加入代码
四、测试
现在在公司主要还是做大数据平台的测试，而今天记录下SpringBoot整合Mybatis，好记性不如烂笔头。
废话不多说，开干。在网上找到一个不错的轮子。直接整
一、项目搭建 开始时确保具备以下条件：
jdk、IDEA、Maven、mysql
1、新建一个Spring Initializr项目
2、建文件结构选择jdk版本
3、选择依赖。注意spring boot 迭代到3开头了，这里选择默认的2.7.5，点击下一步
4、修改项目名，点击finish完成
5、 完成后，看看pom.xml 依赖
代码：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c455527dcffdf63482e3a59a3dc76930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45381d59991292c0e725660c836ea83/" rel="bookmark">
			数据库连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、连接数据库的方法和工具
数据库连接是访问数据库的关键步骤之一，通过连接数据库，我们可以进行数据的增删改查等操作。下面介绍几种连接数据库的方法和工具。
命令行工具 在命令行中输入相应的命令即可连接数据库。常用的命令行工具包括MySQL命令行工具、PostgreSQL命令行工具、Oracle命令行工具等。
以MySQL为例，连接数据库的命令为：
mysql -h 主机名 -u 用户名 -p
其中，主机名为数据库所在的主机名，用户名为连接数据库所需的用户名，-p参数表示需要输入密码。
图形界面工具 图形界面工具可以通过可视化界面来连接数据库，更加直观和方便。常用的图形界面工具包括MySQL Workbench、Navicat for MySQL、pgAdmin等。
以MySQL Workbench为例，连接数据库的步骤为：
启动MySQL Workbench；
点击“连接到数据库”；
输入连接数据库所需的信息，包括主机名、用户名、密码等；
点击“连接”。
编程语言
通过编程语言连接数据库可以实现更加灵活和高效的数据库访问操作。常用的编程语言包括Python、Java、C#等。
二、使用Python连接数据库
Python是一种功能强大的编程语言，通过Python我们可以轻松地连接和操作数据库。
MySQL数据库连接 使用Python连接MySQL数据库需要先安装MySQL驱动程序。常用的MySQL驱动程序包括MySQL Connector、PyMySQL等。以MySQL Connector为例，连接MySQL数据库的代码如下：
import mysql.connector mydb = mysql.connector.connect( host="localhost", user="yourusername", password="yourpassword", database="mydatabase" ) print(mydb) 其中，host表示数据库所在的主机名，user表示连接数据库所需的用户名，password表示连接数据库所需的密码，database表示需要连接的数据库名称。
PostgreSQL数据库连接 使用Python连接PostgreSQL数据库需要先安装psycopg2驱动程序。连接PostgreSQL数据库的代码如下：
import psycopg2 conn = psycopg2.connect(database="mydatabase", user="myusername", password="mypassword", host="localhost", port="5432") print("Database connected successfully") 其中，database表示需要连接的数据库名称，user表示连接数据库所需的用户名，password表示连接数据库所需的密码，host表示数据库所在的主机名，port表示数据库连接的端口号。
三、使用SQLAlchemy连接数据库
SQLAlchemy是一个Python编写的关系型数据库库，可以让Python开发者更方便地操作数据库。使用SQLAlchemy连接数据库的代码如下：
from sqlalchemy import create_engine engine = create_engine('mysql+mysqlconnector://username:password@host:port/database') connection = engine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45381d59991292c0e725660c836ea83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6f8de8c23b0c7a5585ea9c7181709d/" rel="bookmark">
			爬虫实战（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的不断发展，网络数据的规模和价值也不断提升。在这个大数据时代，如何从海量数据中提取有价值的信息并加以利用，成为了数据科学、商业分析、金融预测、社会研究等领域中一个重要的问题。而网络爬虫作为一种数据采集技术，为我们获取和分析网络数据提供了一种高效、灵活和精准的手段。本文将通过实例介绍三种常见的爬虫技术：单页面爬虫、多页面爬虫和分布式爬虫，并使用Python代码进行演示。
一、单页面爬虫
单页面爬虫是指只爬取单个页面的内容。通常，我们可以通过对页面的HTML代码进行解析，提取出我们需要的信息，并保存到本地文件或数据库中。下面我们将分别演示如何爬取百度搜索结果页面和知乎问题页面。
爬取百度搜索结果页面 百度搜索是一个非常常见的搜索引擎，我们可以使用Python的requests库和BeautifulSoup库来爬取百度搜索结果页面，并提取搜索结果的标题、链接和描述信息。
import requests from bs4 import BeautifulSoup def get_baidu_search_result(keyword): url = 'https://www.baidu.com/s' params = {'wd': keyword} headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'} response = requests.get(url, params=params, headers=headers) soup = BeautifulSoup(response.text, 'html.parser') results = soup.find_all('div', class_='result') for result in results: try: title = result.h3.a.text link = result.h3.a['href'] desc = result.find('div', class_='c-abstract').text print(title) print(link) print(desc) except: pass if __name__ == '__main__': keyword = 'Python' get_baidu_search_result(keyword) 在这个示例中，我们定义了一个get_baidu_search_result()函数，它接收一个关键字参数，表示我们要搜索的内容。我们使用requests库发送GET请求，将搜索结果页面的HTML代码下载到本地，并使用BeautifulSoup库进行解析。我们使用find_all()方法获取所有的搜索结果，并遍历每个搜索结果，提取出标题、链接和描述信息，并输出到控制台中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df6f8de8c23b0c7a5585ea9c7181709d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3cfdb92c8c8fd8b70f920afc6736059/" rel="bookmark">
			AlexNet（ImageNet Classification with Deep Convolutional Neural Networks）网络详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 AlexNet是2012年ImageNet竞赛冠军获得者Hinton和他的学生Alex Krizhevsky设计的。也是在那年之后，更多的更深的神经网路被提出，比如优秀的vgg,GoogleLeNet。其官方提供的数据模型，准确率达到57.1%,top 1-5 达到80.2%
注：其实在AlexNet网络问世之前，在进行图像识别，分割等工作时，我们采用手工提取特征或者是特征+机器学习的方式，但是这样很难。因此有一种说法是我们能不能利用特征本身进行学习，那么特征本身就存在了层级关系（比如第一层是点，第二层是点与线组合的特征，第三层为局部特征，第四层…直到组合到一起到最后整个图像出来）那么这种特征学习的部分就是深度学习中的黑盒子，我们也不知道是如何进行的。
二. AlexNet的网络结构 Alexnet共有8层结构，前5层为卷积层，后三层为全连接层。从上图看，在网络设计上其实并非如上图所示，上图包含了GPU通信的部分。这是由当时GPU内存的限制引起的，作者使用两块GPU进行计算，因此分为了上下两部分
摘自原论文的结构图如下：
值得注意的一点：原图输入224 × 224，实际上进行了随机裁剪，实际大小为227 × 227。 但还有种说法就是原图就是224224，但是经过padding后将大小拓展成227227（源码好像是有padding操作，来自b站up主，下面详情分析是按照没有经过padding得来的） 对每层卷积进行分析：
注：经卷积后的矩阵尺寸大小计算公式为：N=（W-F+2P）/S+1
输入图片大小：W*W卷积核大小：F*Fstride：Spadding的像素数：P 三. AlexNet的亮点 首次使用GPU进行加速训练
使用Relu激活函数，而不是传统的Sigmoid激活函数或Tanh激活函数
Relu函数： f ( x ) = m a x ( 0 , x ) f(x)=max(0,x) f(x)=max(0,x)
ReLU 本质上是分段线性模型，前向计算非常简单，无需指数之类操作ReLU 的偏导也很简单，反向传播梯度，无需指数或者除法之类操作；ReLU 不容易发生梯度发散问题，Tanh 和Logistic 激活函数在两端的时候导数容易趋近于零，多级连乘后梯度更加约等于 0；ReLU 关闭了右边，从而会使得很多的隐层输出为 0，即网络变得稀疏，起到了类似 L1 的正则化作用，可以在一定程度上缓解过拟合。缺点：当然，ReLU 也是有缺点的，比如左边全部关了很容易导致某些隐藏节点永无翻身之日，所以后来又出现 pReLU、random ReLU等改进，而且 ReLU 会很容易改变数据的分布，因此 ReLU 后加 Batch Normalization 也是常用的改进的方法。 使用LRN局部响应归一化
局部响应归一化处理，实际就是利用临近的数据做归一化，该策略贡献了 1.2% 的准确率，该技术是深度学习训练时的一种提高准确度的技术方法，LRN 一般是在激活、池化后进行的一种处理方法。LRN 是对局部神经元的活动创建竞争机制，使得其中响应较大的值变得相对更大，并抑制其他反馈较小的神经元，增强了模型的泛化能力。
在全连接层的前两层使用Dropout随机失活神经元操作，以减少过拟合
四. 一些问题解答 AlexNet学习出来的特征是什么样子的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3cfdb92c8c8fd8b70f920afc6736059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1727b9e069cc92634918cc55a12b8d56/" rel="bookmark">
			人生有何意义？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天问了chatgpt一个问题，下面是它的回答： Question 人生有何意义？ Answers 人生的意义在于：追求幸福和快乐。 人生的意义在于：实现个人价值和成就。 人生的意义在于：为他人做出贡献和服务。 人生的意义在于：寻找自我意义和存在意义。 人生的意义在于：体验和探索世界的奇妙之处。 人生的意义在于：享受和珍惜人际关系和人类共同体验。 人生的意义在于：追求真理和智慧，探索人类的本质和宇宙的奥秘。 人生的意义在于：实现自我超越和成长，挑战自己的极限和突破自我。 人生的意义在于：创造和发展文化、艺术、科技和社会体制，为人类的进步做出贡献。 人生的意义在于：体验和表达人类的情感、信仰和精神追求。 目前我自己的观点是：当从世界离开的时候，比来的时候变得更好了一点。
如果有人也在思考这个问题，
如果你也有自己的想法，欢迎留言，我想学习一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcf3ebc13ff0b1ae18d65eaa4ec1dd21/" rel="bookmark">
			Log4j2修改转储日志文件权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统安全要求，对日志归档文件权限为只读。
附链接：https://blog.csdn.net/weixin_36142042/article/details/109106620
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29589a2de431cdf2e5fb78f43b058ec/" rel="bookmark">
			DM9051--TCP通信实验（基于STM32CUBEMX）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 最近作者一直在研究DM9051芯片的工作机理，在此过程中，上网上找了很多资料，但根据资料还是不能了解很通透。因此我直接开始实战，经过多番周折，终于调通了程序。再此篇文章分享下自己的调试过程，也把疑问分享一下！（写的比较潦草，资料在最后）
2.DM9051介绍 DM9051NP SPI接口网卡芯片是为了方便MCU单片机系统进行以太网通信而开发出的解决方案。DM9051NP芯片是带有行业标准串列外设接口（Serial Peripheral Interface，SPI）的独立以太网控制器。DM9051NP符合IEEE 802.3 规范，它还支持以DMA 模式來传输，以实现资料传送快速。DM9051NP通过1个中断引脚和SPI接口來进行与主控制器/MCU单片机的通信，资料传输规格为10/100 M。
3.主要实现的功能 作者想通过DM9051，实现STM32F103与网络调试助手进行通信。并且能够定时上传数据，或者能够连续传输数据。其中DM9051作为TCP服务器端。
4.单片机配置 SPI配置：
SPI通过DMA进行传输，其它配置根据自己的单片机设置就行。PB12是管脚是SPI-NSS（选择管脚），要通信的话，需要拉低这个管脚。
5.代码分析 1.此处代码是为了配置DM9051的IP地址 dm9051_init(); //DM9051初始化 uip_init();	//uIP初始化 uip_arp_init();	//arp表初始化 uip_ipaddr(ipaddr, 10,0,115,70);	//设置本地设置IP地址 uip_sethostaddr(ipaddr); uip_ipaddr(ipaddr, 10,0,115,1); //设置网关IP地址(其实就是你路由器的IP地址) uip_setdraddr(ipaddr); uip_ipaddr(ipaddr, 255,0,0,0);	//设置网络掩码 uip_setnetmask(ipaddr); uip_listen(HTONS(80));	//80端口,用于TCP Server 2.while循环 while (1) { uip_polling();	//处理uip任务 //开始传送30次数据帧的任务 if(flag_transdata == 1) { for(int i = 0; i&lt;30; i++) { againa: tttt=0; //为了确保每次都会进入mtcp_appcall()函数 rrrr =1;//标志位，为了告诉DM9051需要处理数据了 uip_polling();//处理uip任务 delay_ms(5); if(tttt == 0) //如果没有进入mtcp_appcall()函数，则再来一次 { goto againa; } } rrrr= 0; //标志位清0 flag_transdata = 0;//30次数据发送完成 } delay_ms(20); } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c29589a2de431cdf2e5fb78f43b058ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823e309f5b7ab121955da281441d075b/" rel="bookmark">
			CPU使用率100%如何定位分析？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先通过top指令查看当前占用CPU较高的进程PID $ top -c 2、按下”shift+p”找到CPU使用率最高的进程 （按shft+p按照cpu占用进行排序，按shift+m按照内存占用进行排序）
此时发现9331的java进程CPU高达253.4%，且一直降不下来，很显然9331这个进程出现了问题。
top - 17:57:20 up 91 days, 20:37, 1 user, load average: 3.34, 3.14, 2.23 Tasks: 180 total, 1 running, 179 sleeping, 0 stopped, 0 zombie Cpu(s): 46.1%us, 13.4%sy, 0.0%ni, 36.2%id, 0.1%wa, 0.0%hi, 2.5%si, 1.7%st Mem: 8059860k total, 7888496k used, 171364k free, 22648k buffers Swap: 10485752k total, 0k used, 10485752k free, 2750132k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 7331 kafka 20 0 43.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/823e309f5b7ab121955da281441d075b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c56b6464c203ac30bb864b845590aac6/" rel="bookmark">
			vue2和vue3的 区别 （深度篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、vue3完全支持typescript，提高项目的可维护性 2、Fragment：模板更简单。 vue3用到了一个虚拟的父级，可以多个根节点dom
vue2只能有一个父级节点
3、vue2用 new Vue(); vue3用createApp(); 多个实例时，vue2中的vue实例共享一个Vue构造函数，无法做到完全隔离
createApp方法返回一个提供上下文的应用实例，应用实例挂载的整个组件共享同一个上下文
4、vue2 的双向数据绑定是利用ES5 Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。 vue3 中使用了 es6 的 ProxyAPI 对数据代理。
5、Vue2与Vue3 最大的区别 — Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）
6、建立数据 data Vue2 - 这里把数据放入data属性中
Vue3 setup()方法里。
7、生命周期 Vue2--------------vue3
beforeCreate -&gt; setup()
created -&gt; setup()
beforeMount -&gt; onBeforeMount
mounted -&gt; onMounted
beforeUpdate -&gt; onBeforeUpdate
updated -&gt; onUpdated
beforeDestroy -&gt; onBeforeUnmount
destroyed -&gt; onUnmounted
activated -&gt; onActivated
deactivated -&gt; onDeactivated
vue3还提供了两个调试的钩子 onRenderTracked 状态跟踪,onRenderTriggered 状态触发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c56b6464c203ac30bb864b845590aac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6857aff341fb5d7fcecfe2f161e5eba3/" rel="bookmark">
			playwright--iframe操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、iframe语法二、iframe定位三、frame() 定位四、page.frame 和 page.frame_locator 区别 前言 在playwright中，无需切换iframe，直接定位元素即可。
一、iframe语法 page.frame_locator()
locator = page.frame_locator("frame").get_by_text("登录") 说明：使用frame_locator() 定位到iframe上，再在上面使用locator方法定位元素
二、iframe定位 匹配第一个
frame_locator().first 匹配最后一个
frame_locator().last 使用index索引
frame_locator().nth(index) 获取全部iframes
page.frames 三、frame() 定位 根据name属性和url属性匹配
frame = page.frame(name="frame-name") frame = page.frame(url=r".*domain.*") frame.fill('#username-input', 'John') 四、page.frame 和 page.frame_locator 区别 page.frame_locator() 返回的对象需要用locator() 方法定位元素，再操作元素
page.frame() 返回的对象可直接使用fill() 、 click() 方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c80e8da1a42631c031269277c1f9e261/" rel="bookmark">
			Vue中ref()和 reactive() 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 你一定知道Vue中的响应式编程，它提供了在数据变化时自动更新UI的能力，摒弃了传统的数据更新时手动更新UI的方式。在Vue 3.0之前，我们定义在data函数中的数据会被自动转换为响应式。而在 Composition API 中，还有两种方式让我们定义响应式对象：ref() 和reactive()。 但是，他们有什么不同之处呢？
ref和reactive的区别 对比之前先看一下如何使用，它们的使用方法都很简单，也很类似：
&lt;template&gt; &lt;div&gt;{{user.first_name}} {{user.last_name}}&lt;/div&gt; &lt;div&gt;{{ age }}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { reactive } from 'vue' export default { setup() { const age = ref(18) const user = reactive({ first_name: "Karl", last_name: "Max", }) return { user , age} } } &lt;/script&gt; 复制代码 接下来我们就来分析一下它们的不同点：
可接受的原始数据类型不同
ref() 和reactive()都是接收一个普通的原始数据，再将其转换为响应式对象，例如上面代码中的user和age。却别在于：ref可以同时处理基本数据类型和对象，而reactive只能处理处理对象而支持基本数据类型。
const numberRef = ref(0); // OK const objectRef = ref({ count: 0 }) // OK //TS2345: Argument of type 'number' is not assignable to parameter of type 'object'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c80e8da1a42631c031269277c1f9e261/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/94/">«</a>
	<span class="pagination__item pagination__item--current">95/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/96/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>