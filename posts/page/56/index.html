<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9a33958e133c36178fad9c6f6a398d/" rel="bookmark">
			【typescript】微信小程序扩展你的全局wx对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1， 找到你的ts定义文件
比如 xxx.d.ts文件，确保这个文件有被tsconfig.json识别到
2，添加如下代码
declare namespace WechatMiniprogram { interface Wx { openOfflinePayView: (p?: any) =&gt; void yourOwnPropName: any } } 声明全局变量
declare var __wxConfig: any 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39dd3e8d4b20f5b17b49f40987d09e2b/" rel="bookmark">
			一次性说清楚 JAVA的 ThreadPoolExecutor 、newFixedThreadPool 和newCachedThreadPool 等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Executors.newCachedThreadPool() 与 Executors.newFixedThreadPool(n) 的区别是什么？
2、Executors.newCachedThreadPool() 与 Executors.newFixedThreadPool(n) 可以调参吗，比如线程大小，线程等待时间 等等
3、newCachedThreadPool 与 ThreadPoolExecutor 是什么关系？
4、newFixedThreadPool 与 ThreadPoolExecutor 是什么关系？
5、通过自定义 ThreadPoolExecutor 类可以实现更多的灵活性。
6、newCachedThreadPool() 会堵塞吗？队列会满吗？ 7、ExecutorService 与 ThreadPoolExecutor 有什么区别？
8、ExecutorService还提供了一些工厂方法，除了newFixedThreadPool()和 newCachedThreadPool() 还有其他哪些？
1、Executors.newCachedThreadPool() 与 Executors.newFixedThreadPool(n) 的区别是什么？ Executors.newCachedThreadPool()和Executors.newFixedThreadPool(2)都是创建线程池的工厂方法，但它们之间有几个重要的区别。
线程池大小 newCachedThreadPool()创建一个可缓存的线程池，线程池的大小根据需要自动调整，可以创建任意数量的线程。当需要执行任务时，线程池中没有可用线程时，它会创建新的线程来执行任务。如果线程池中的线程在60秒内没有被使用，则会被终止并从池中移除。因此，该方法适合执行大量短时间的任务。
newFixedThreadPool(n)创建一个固定大小的线程池，该线程池的大小为n。如果有更多的任务提交到线程池中，它们将会被放置在一个队列中等待执行，直到有可用的线程。如果队列已满，则会阻塞新任务的提交。因此，该方法适合执行长时间的任务或需要控制并发数的场景。
线程池的使用 newCachedThreadPool()适用于短期异步任务的执行，例如处理用户请求或发送电子邮件。由于它可以自动调整线程池的大小，因此它可以根据任务的数量动态分配系统资源。但是，由于它会创建大量的线程，因此如果长时间运行，可能会消耗过多的内存和处理器资源。
newFixedThreadPool(n)适用于长期执行的任务，例如服务器进程。由于它可以限制并发数，因此可以控制系统资源的使用。但是，如果任务数量过多，将可能导致队列阻塞和性能下降。
总之，选择使用newCachedThreadPool()或newFixedThreadPool(n)取决于应用程序的需求和特点，需要根据实际情况进行选择。
2、Executors.newCachedThreadPool() 与 Executors.newFixedThreadPool(n) 可以调参吗，比如线程大小，线程等待时间 等等 Executors.newCachedThreadPool()和Executors.newFixedThreadPool(n)方法都允许通过传递不同的参数来进行调整。具体来说，可以通过以下方式进行调参：
newCachedThreadPool()方法允许通过ThreadPoolExecutor构造函数传递参数来自定义线程池的配置，例如设置线程池的最小和最大线程数，线程的存活时间等等。示例代码如下： ExecutorService executorService = new ThreadPoolExecutor( 0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;() ); newFixedThreadPool(n)方法允许通过ThreadPoolExecutor构造函数传递参数来自定义线程池的配置，例如设置线程池的最大线程数，队列的容量等等。示例代码如下： ExecutorService executorService = new ThreadPoolExecutor( n, n, 0L, TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39dd3e8d4b20f5b17b49f40987d09e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4caf6fa1abe0089d3fc2a32ae73ede60/" rel="bookmark">
			安装ensp时所遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		断断续续已经出错很多次，于是记录一下。
久一些的问题当时的图已经不在了。
一、第一次安装时遇到的错误40问题 一开始安装上时没有问题，运行一段时间后报错40
参照40错误手册开始排错。
(1)重装Oracle VM VirtualBox、Wireshark和ensp.。问题依然存在。
(2)检查虚拟网卡（网络适配器里查看）,名为VirtualBox Host-Only Ethernet Adapter的网卡正在运行。没有问题。
(3)重装vBox的更高版本,当前版本是5.1.x，选择了6.x版本。问题依然存在。
(4)删除vBox里的所有*_base（如图）后再重新注册（打开ensp放上AR设备开启后会自动要求注册。注意：需要把ensp里已经放上去的设备移除再点注册）。无法注册。重装。问题存在。
(5)再次重装时选择了5.2.44的vBox,正常运行。
结论:版本不兼容。此时ensp版本1.2.00.500 vbox的版本为5.2.44
二、二次重装vbox时，出现错误41 删除xbox里的全部*_base配置然后重新注册
三、过半年后出现错误43（接着出现41与40） 卸载重装vbox后出现错误41.
重复上面解决错误41的操作后重启vbox和ensp出现错误40
这时按照错误40的方法进行排错,发现VirtualBox Host-Only Network网卡不见了
(1)卸载vbox,下载免费版cclear清理注册表
然后重装vbox，如果没有问题网卡存在了，那么恭喜你。如果还是没有，那就继续：
（2）打开vbox左上角的主机网络管理器，如果是空白的，点击新建。
如果创建成功了，那么恭喜你。如果报错：
那么继续。
（3）打开设备管理器，选择网络适配器，左上角选择添加过时硬件
选择手动添加，浏览到安装vbox的目录下找到VBoxNetAdp6.inf
我的安装路径参考：
E:\vbox\drivers\network\netadp6\VBoxNetAdp6.inf
然后等待安装
如果安装好了，那么恭喜你。如果是如下所示：
那么继续吧。
（4）手动打开注册表,删除以下两个文件夹:
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Network\{4d36e974-e325-11ce-bfc1-08002be10318} HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\NetworkSetup2\Services
其中NetworkSetup2打不开
关闭注册表，下载nsudo，运行后勾选全部特权，打开注册表，就可以了。
（5）在设备管理器里重复添加过时硬件的操作
添加成功。
至此，再打开ensp，可以正常运行AR设备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98ce5128c867dd859ede6ce4af9080c/" rel="bookmark">
			使用了一次VPN关闭后，网页打不开了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主用了一次梯子后，发现正常的网络无法使用了。原来是VPN在我本地开了代理。关掉即可！ 结尾、扫一扫下方微信名片即可+博主徽信哦 ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c5692685d209c26317e9134be7a1897/" rel="bookmark">
			VSCode 中的用户代码片段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户代码块
在 VSCode 中，用户可以通过自定义代码片段（User Snippets）来快速插入常用的代码块。
官方文档
如何创建和使用用户代码片段：
点击用户片段后，即会弹出面板如下：
添加一个代码片段
"片段名称": { "prefix": "快捷键", "body": ["代码片段"], "description": "描述说明" }, 一些常用的代码片段
{ // Place your 全局 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope // is left empty or omitted, the snippet gets applied to all languages.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c5692685d209c26317e9134be7a1897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba660d3b4605c529ae9aedc909e25c1a/" rel="bookmark">
			低代码平台：IVX 重新定义编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🍬一、写在前面
🍬二、低代码平台是什么
🍬三、为什么程序员和技术管理者不太可能接受“低代码”平台？
🍭1、不安全（锁定特性）
🍭2、不信任
🍬四、IVX低代码平台
🍬五、IVX低代码平台优势
🍭1、无缝的云原生体验
🍭2、可视化设计
🍭3、图灵完备逻辑编排
🍭4、代码生成能力
🍭5、保持代码编程逻辑
🍭6、支持结合代码开发
🍭7、支持生成代码和导出
🍬六、iVX 相较于编程语言的优势
🍬七、总结
🦐博客主页：大虾好吃吗的博客
🦐专栏地址：闲谈专栏地址
一、写在前面 高级编程语言诞生已经过去了大半个世纪了，在我们看来，什么都在进步，但是编程语言的发展却有些缓慢了。虽然现在语言更加丰富，框架更多，但是最基本的编程方式还是没有任何改变，就是“写代码”，其实在英文中“Programming”和“Coding”是两个单词，有没有可能，我们只“编程”而不“写代码”？
图形化的编程思路，在几十年前就有许多公司和团队想到过，并且构思出了很多优秀的产品，一些是“图形+代码”快速生成某种编程语言的产品，例如Visual Basic、Dreamweaver、Delphi、C++Builder、JBuilder等等；再到硬件设备图形化编程产品Labview；以及科学计算领域大名鼎鼎的Matlab；都能看到图形化编程的影子。
二、低代码平台是什么 低代码平台是一种软件开发工具，它旨在帮助开发人员通过最小的编码努力来创建应用程序。这些平台使用可视化界面和图形化工具，使开发人员可以通过拖放和配置组件来构建应用程序，而无需手动编写大量的代码。低代码平台提供了预先构建的模块和组件，以及集成了常见功能和服务的工具，例如数据库连接、API 集成和用户界面设计。通过低代码平台，开发人员可以快速搭建原型、快速迭代和部署应用程序，提高开发效率和减少开发成本。
三、为什么程序员和技术管理者不太可能接受“低代码”平台？ 我先总结一下，大部分低代码的特征：
1、 为企业定制的一种内部开发框架，运行时的，整体安装到企业内部，属于企业服务；（还有一种纯SaaS的，国内更难推，不在这里讨论）
2、大部分应用，还是需要代码开发，只是说代码量可能会少一点；但是，开发出来的应用，终身只能在“运行时”环境下运行，不能导出独立部署；
为什么程序员和技术管理者不太可能接受“低代码”平台？
1、不安全（锁定特性） 大部分“低代码”平台实际上是一个为企业定制的“产品”，而不是“一种新技术”！更像是一个“空中楼阁”，只能进不能出那种，由于无法生成代码，因此一旦选择某一“低代码平台”，基本上等于把身家性命都押上了，一旦“平台有事”，基本上会“颗粒无收”，甚至影响现有的运行业务。国内，有上百家类似的低代码平台，基本上都是同质竞争，因此风险极高。因此，我认为技术管理者不敢使用。
2、不信任 程序员只相信“代码”，哪怕是自动生成的代码，也是可以接受的。如果不能生成代码，这将和程序员基本“认知”相冲突，并且这也将阻碍程序员去进一步参与建设“低代码”平台。在程序员眼中“不能生成完整代码”、“不能导出进行编译/调试/运行”的系统是不能被接受的。
四、IVX低代码平台 iVX和其它低代码的区别，可以用一句话说清楚：iVX做的是“开发态”，拖拽生成全栈代码；其它低代码平台做的是“运行时”，配置生成应用。
生成代码代表了一种可逆性，意味着从技术上可以选择将无代码开发的应用“回退”为纯代码版本。将来也许有一天需要继续使用代码开发，或者说从技术上可以更好和现在所有“代码编程”范式直接使用或对接。
目前，绝大多数“低代码平台”，包括国外Mendix、Outsystems、PowerApps等，无一例外都是给客户（企业）安装一个运行时（aPaaS），所有配置出来的应用，都必须在这个“运行时”内部“运行”。就算能导出文件（例如Mendix导出mpk文件），还是只能在Mendix系统环境内运行，这就意味着，这种技术路线是不能“回退”的。假如有一天这些国外平台撤离中国，所有在其平台投入和积累都将“付诸东流”。
然而，iVX是由国内非常优秀的研发团队打造，不仅支持无代码开发，还提供了一种全新的代码“生成”模型，用于直接生成前端（react/vue）、后台（Java/node）和数据库的代码，iVX的技术上本身就是“可逆的”，支持导出源码。因此，开发成果不会被“锁定”在这个平台了。
IVX官网：iVX—人人都能掌握的可视化编程语言-ivx官网
五、IVX低代码平台优势 1、无缝的云原生体验 iVX提供了一种无缝的云原生体验，使开发者可以在浏览器中直接进行开发，不需要安装任何软件，大大提高了开发效率和便捷性。
2、可视化设计 iVX强大的可视化设计工具可以帮助用户快速设计和构建应用。通过拖拉拽的方式，用户可以轻松创建表单、流程、报表等各种元素，无需编写任何代码。这种设计方式不仅可以大大减少开发时间，而且可以使更多的人参与到应用开发中来，从而提高团队的生产力。
3、图灵完备逻辑编排 iVX形成了一套“自洽”且“图灵完备”的逻辑系统，并且在前后台的逻辑处理中都复用了这套逻辑系统。这是一种基于“触发式”的面板系统，并且可以线性扩展，相比基于“流程图”的逻辑编排系统更具优势。
4、代码生成能力 无论前端或后台代码，iVX都可以编译后快速生成。过程中，iVX会先生成AST抽象语法树，然后再根据AST生成对应的代码。如果是其它应用（例如微信小程序），会编译成对应的微信小程序原生代码。下面是由IVX生成的代码，完美应用VUE。
5、保持代码编程逻辑 iVX去掉的是程序语法部分，而解决问题的逻辑部分完全保留下来。因此与目前编程的逻辑并不冲突，程序员上手不用担心，不论是开发前端还是后台，擅长C还是Python，都可以快速学习并具备使用iVX开发各种应用的能力。
6、支持结合代码开发 自定义组件 iVX支持自定义前端组件，如果程序员觉得现有的几百个组件不能满足需求，完全可以根据iVX提供的文档（一个map格式），自定义自己的前端组件，并集成到iVX的组件窗口中。
自定义函数 在iVX中，有一个组件叫自定义函数，可以方便写Javascript代码，前端和后台都可以写。用于处理数据等各种操作。
贴JSON代码（通用变量） 通用变量支持 JSON 数据导入，系统将自动解析其数据结构并建立变量。
该变量可通过循环创建组件进行调用，原理类似于二维数组。
写SQL语法（DBO） 在iVX中，对mysql、ES（全文搜索）、nosql（表格数据库 AWS DynamoDB）支持是最好的，可以通过AST（抽象语法树）直接生成数据库支持的各种语法程序。
而对于，Oracle、SQLServer这些数据库，iVX提供专门一个DBO组件进行控制和管理（DBO层则需要用户自行写SQL语法）。未来争取将Oracle和SQLServer等常见数据库，也整合到AST中，这样就可以不用写SQL语法了，操作会更简单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba660d3b4605c529ae9aedc909e25c1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e884f5b40964f048926fa5a858d988/" rel="bookmark">
			支付宝实现预下单支付使用公钥证书（公钥证书方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支付宝预下单
public PreparePayResultVo preparePay(NftOrder nftOrder) { private final AliPayProperties aliPayProperties; AlipayClient alipayClient =null; try { alipayClient = new DefaultAlipayClient(this.getCertAlipay()); AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest(); request.setNotifyUrl(aliPayProperties.getNotifyUrl()); request.setReturnUrl(aliPayProperties.getReturnUrl()); JSONObject bizContent = new JSONObject(); bizContent.put("out_trade_no", nftOrder.getOrderNo()); bizContent.put("total_amount", nftOrder.getPayAmount()); //utf编码防止出现特殊字符 bizContent.put("subject", URLEncoder.encode(nftOrder.getNftName(), "utf-8")); bizContent.put("product_code", "QUICK_WAP_WAY"); bizContent.put("quit_url", aliPayProperties.getQuitUrl()); bizContent.put("time_expire", LocalDateTime.now().plusMinutes(orderProperties.getPayTimeoutMinutes()).toString("yyyy-MM-dd HH:mm:ss")); // 商品明细信息，按需传入 JSONArray goodsDetail = new JSONArray(); JSONObject goods1 = new JSONObject(); goods1.put("goods_id", nftOrder.getNftId()); if (nftOrder.getNftImageType().equals(NftImageTypeEnum.DRM.getValue())) { goods1.put("goods_name", URLEncoder.encode(nftOrder.getGoodsName(), "utf-8")); } else { goods1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58e884f5b40964f048926fa5a858d988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ccef3e0fb50071a6d7eb6d532fba7db/" rel="bookmark">
			webservice、socket、http 、json傻傻分不清楚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 webservice原理 第一部分: 直观概述 WebService的几种概念:
以HTTP协议为基础，通过XML进行客户端和服务器端通信的框架/组件
两个关键点:
1. 服务端提供的功能, 通过xml描述
2. 第一步中的描述的功能, 嵌入到HTTP协议中, 使得能通过HTTP协议进行通信【所谓的SOAP】.
用图可以如下表示:
图一: WebService的简要表示
采用这两个技术的目的主要是:
1. 跨平台, 支持HTTP协议的主机和服务器, 都能够建立通信联系, 并且大部分的主机和服务器(99.999%以上)将支持HTTP协议。一般而言，不同目标主机之间的通信，需要通过防火墙，打开某个端口, HTTP协议的优势在于，防火墙一般不会封掉80端口, 这样就可以方便，安全的通信。
2. 跨语言, 任何语言, 都支持XML文本解析, 这个的目的是为了实现不同语言之间的通信, 通信的内容，是被xml限制的，因此这样进行通信，能跨越语言障碍，即, Java开发的服务端，客户端可以用C访问, 可以用java，VB等访问, 反之亦然。
第二部分: 基本原理和架构 当然，架构比我们上面说到的图要更为复杂，上面只是说明了一来一回的通信, 实际情况还需要考虑以下问题, 参照图例说明:
1. 服务器端(Provider) 提供统一的标准化服务。就像开办一个公司(即Server Provider), 工商行政管理局，注册一下公司地址和性质。目的是, 别人要用公司的服务，从工商管理局就知道你的地址。这样统一的做法，是方便所有的公司以及所有需要公司提供服务的客户。并且这些信息是最大限度的公开。
2. 客户端(Requester) 到注册中心(Registry)拿到公司的基本信息之后, 去找到这个公司, 然后使用该公司提供的服务。
图二: 基本的WebService架构流程图
注意上面图中的基本步骤的标号, 解释如下
1. Provider节点提供好服务后, 首先注册到节点Registry
2和3. Requester节点到Regitry节点查信息, 找到需要的Provider及其提供的Service
4. Requester使用Provider提供的服务
更具体的介绍, 参照参考文献[2], 下面这些基本由这个参考文献翻译而来:
图三: 细节步骤流程图
上图这些东西, 完完整整的呈现了WebService的整个原理流程:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ccef3e0fb50071a6d7eb6d532fba7db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a3fff0117c8e6887455d233d1ccf1e/" rel="bookmark">
			Docker使用数据卷挂载进行数据存储与共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、挂载和数据卷 在 Docker 中，挂载（Mounting）和数据卷（Data Volumes）是用于在容器和宿主机之间共享数据的机制。
挂载：将宿主机文件系统中的目录或文件与容器中的目录或文件进行关联的过程。数据卷：一种特殊的目录，可以绕过容器文件系统，直接与宿主机文件系统进行交互。 1.1 为什么要使用数据卷？ 如果数据都在容器中，那么把容器删除以后，数据也会随之丢失，所以要把数据进行数据持久化。
如：mysql容器，容器删了，里面的数据就都没了容器之间可以有一个数据共享的技术，使得容器和宿主机实现数据共享。Docker容器中产生的数据，也会同步到宿主机中。 1.2 使用数据卷的好处？ 如修改数据库的配置文件还要进入容器里面修改，比较麻烦。当挂载以后只需要在本地修改会即可，容器会自动同步。
​- 挂载以后会占用磁盘两份存储，即容器内占一份，宿主机占一份。挂载以后，删除容器以后，宿主机对应的挂载目录不会删除。 二、挂载数据卷的方式 可以直接使用docker run -it -v命令来实现数据卷挂载，挂载数据卷命令如下：
docker run -it -v 宿主机路径:容器内路径 其中，宿主机路径为绝对路径，
容器起来以后挂载以后使用docker inspect 容器id 查看目录是否挂载成功
docker inspect 容器id # 搜索Mounts，这里面就是目录的挂载信息 # Source:主机内路径 # Destination：docker容器内的路径 # 如果Mounts这里不展示挂载信息，就说明是挂载失败了 三、具体样例 sudo docker run -it -v /home/Project/data:/data test:1.0 挂载信息如下：
宿主机路径：/home/Project/data容器路径：/data镜像名称：image-test:1.0 接下来，我们可以查看容器是否正常启动运行起来：
sudo docker ps -a 查看容器挂载信息：
sudo docker inspect 921ea03a66ea 搜索Mounts，这里面就是目录的挂载信息，其中：
Source:主机内路径Destination：docker容器内的路径
如果Mounts这里不展示挂载信息，就说明是挂载失败了。
注意：实现数据卷挂载以后，容器停止以后，往宿主机的挂载目录写入对应的数据，此时数据也会同步到容器内对应的目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76df26da38feeba372f7be0950e6d8d5/" rel="bookmark">
			Linux进入单用户方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7系统
1、重启系统
2、开机时一直按退出esc键进入如下截面
在以上截面后，按e键出现下面界面：
找到“ro”一行，将“ro”替换成 rw init=/sysroot/bin/sh，如下：
按Ctrl-x 进行重启进入单用户模式，最关键一步，执行chroot /sysroot，获取root权限
Centos6系统
1、到内核选项按e
2、选到kernel这一行按e
3、最后面输入single 或 1，然后按b启动
ubuntu系统
1、开机时按shift 选高级选项
2、在高级选项中，然后根据最新内核选中对应的（recovery mode）进入recovery模式（我这只有一个，有的可能有多个，一般选中最上面的那个）
3、在该界面找到 recovery nomodeset 这一行 ，替换 ro recovery nomodeset 为 rw single init=/bin/bash ,然后按 Ctrl + x
SUSE11系统
1、重新启动机器，在出现grub引导界面后，在启动linux的选项里加上init=/bin/bash(删除其余的)，通过给内核传递init=/bin/bash参数使得OS在运行login程序之前运行bash。
2、稍等片刻出现(none)#: 提示符。
3、这时执行命令 mount -n / -o remount,rw 表示将根文件系统重新mount为可读写，有了读写权限后就可以通过passwd命令修改密码了。
4、输入passwd root命令就可以重置密码。
5、修改完成后记得用mount -n / -o remount,ro将根文件系统置为原来的状态。
6、重启linux使密码生效：reboot -f
OpenEuler、Anolis系统
openeuler和anolis系统进单用户方式和centos7相同。
但是openeuler系统编辑内核选项模式时，需要输入账号密码：
root/openEuler#12
或者
root/Huawei#12
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e90c04d419520079ccb28fd586a3f7e/" rel="bookmark">
			【工具】JAVA 全角转半角 半角转全角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【工具】JAVA 全角转半角 半角转全角 maven依赖 也可以不用 把判空字符串的那行改一下就行
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.20&lt;/version&gt; &lt;/dependency&gt; 工具代码
import cn.hutool.core.util.StrUtil; /** * 字符工具 */ public class CharUtil { /** * 半角转全角的函数(SBC case) * 全角空格为12288,半角空格为32，其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248 * * @param input 任意字符串 * @return 全角字符串 */ public static String toSbc(String input) { if (StrUtil.isBlank(input)) { return ""; } char[] c = input.toCharArray(); for (int i = 0; i &lt; c.length; i++) { if (c[i] == 32) { c[i] = (char) 12288; continue; } if (c[i] &lt; 127) { c[i] = (char) (c[i] + 65248); } } return new String(c); } /** * 全角转半角的函数(DBC case) * 全角空格为12288，半角空格为32 其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248 * * @param input 任意字符串 * @return 半角字符串 */ public static String toDbc(String input) { if (StrUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e90c04d419520079ccb28fd586a3f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a09eb2081587ade3305d7257869b27fb/" rel="bookmark">
			初识数据结构与算法篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.线性结构1.1 线性表1.2 线性表的顺序存储1.3 线性表优缺点：1.4 线性表的链式存储1.5 线性表的链式存储的优缺点 2.栈和队列2.1 栈2.2 队列 前言 数据结构是程序设计的重要基础。数据结构：是指元素的集合与元素之间的相互关系和构造方法。元素之间的相互关系是数据的逻辑节后，数据元素以及元素之间关系的存储称为存储结构或者物理结构。数据结构存储⽅式总的来说就两种数组:（顺序存储）和链表（链式存储）,也可以称为线性结构与非线性结构。，
散列表、栈、队列、堆、树、图等等各种数据结构都是基于数据和链表实现的。
1.线性结构 线性结构是一种基本的数据结构，主要描述客观世界中具有单一前驱和后继的数据关系，特点是描述元素之间的线性关系，一个元素接着一个元素。
1.1 线性表 线性表：一个线性表是n(n&gt;=0)个元素的有限序列，通常表示(a1,a2…an)。非空线性表的特点：
1.存在第一个元素
2.存在最后一个元素
3.除了第一个元素外，序列中的每个元素均只有一个前驱。
4.除了最后一个元素，序列中的每个元素均只有一个直接后继。
1.2 线性表的顺序存储 线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的元素，逻辑上相邻的的两个元素位置相邻。两个元素之间的关系不需要额外的空间来存储。
a1a2…an-1an 1.3 线性表优缺点： 优点：1.查找元素比较快，节省存储空间
缺点：1.插入与更新元素较慢。
1.4 线性表的链式存储 线性表的链式存储是通过指针链接起来节点来存储数据元素。基本的结构：
数据域指针域 数据域用于存储数据元素的值，指针域存储当前元素的直接前驱或直接后继的位置信息，指针域的信息称为指针(或者域)。
单链表的定义：
typedef struct node{ int data; //节点的数据域，定义数据的类型 struct node *next ;//指针域 }node,*LinkList; 双向链表
typedef struct node{ int data; //节点的数据域，定义数据的类型 struct node *next,*pre ;//指针域 }node,* DoubleLinkList; 1.5 线性表的链式存储的优缺点 优点：插入和更新与删除元素比较快
缺点：查询比较慢，需要额外的空间来存储节点之间的关系。
2.栈和队列 2.1 栈 栈是只能通过它的一端来实现数据存储和检索的一种线性数据结构，栈的修改是先进后出的原则。
栈的基本运算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a09eb2081587ade3305d7257869b27fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be00488276092b3234e299ff217a8091/" rel="bookmark">
			pytest自动化测试两种执行环境切换的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、痛点分析
方法一：Hook方法pytest_addoption注册命令行参数
1、Hook方法注解
2、使用方法
方法二：使用插件pytest-base-url进行命令行传参
一、痛点分析 在实际企业的项目中，自动化测试的代码往往需要在不同的环境中进行切换，比如多套测试环境、预上线环境、UAT环境、线上环境等等，并且在DevOps理念中，往往自动化都会与Jenkins进行CI/CD，不论是定时执行策略还是迭代测试，那么问题来了，难道每次切换环境都需要提供一套测试代码？或者每次切换都要需修改我们的自动化环境配置？答案当然不是，不然怎么能叫测试自动化呢！　在未使用pytest的Hook相关方法之前，切换环境我们一般会使用python的内置模块sys，它有一个argv的方法，可以从我们的命令行接收参数，通过它也可以实现上面的需求，就像如下部分代码这样：
try: if sys.argv[1] == '-p': # 预上线环境 conf_url.write_value(filename=CONFIGS_FILE_PATH_URL, data=p_api_address) modify_properties_url(filename=ENVIRONMENT_PROPERTIES_PATH, url=p_api_address["request"]["url"]) elif sys.argv[1] in [f't{i}' for i in range(1, 8)]: # 测试环境 conf_url.write_value(filename=CONFIGS_FILE_PATH_URL, data=test_api_address(sys.argv[1][1:])) modify_properties_url(filename=ENVIRONMENT_PROPERTIES_PATH, url=test_api_address(sys.argv[1][1:])["request"]["url"]) else: case_logger.error("Please confirm the environmental information.") print("Please confirm the environmental information.") raise Exception except IndexError: # 生产环境 conf_url.write_value(filename=CONFIGS_FILE_PATH_URL, data=formal_api_address) modify_properties_url(filename=ENVIRONMENT_PROPERTIES_PATH, url=formal_api_address["request"]["url"]) 这种方式我们需要使用 "python xxx.py -p" 这种方式进行环境切换，然后再执行pytest命令行去执行测试用例，但是这种方法能在pytest的命令行中使用吗？能不能将环境切换的命令行也集成到pytest的命令行中，执行整个自动化项目只使用一条命令行呢？
方法一：Hook方法pytest_addoption注册命令行参数 1、Hook方法注解 pytest_addoption：可以让用户注册一个自定义的命令行参数，方便用户将数据传递给 pytest这个 Hook 方法一般和内置 fixture pytestconfig 配合使用pytest_addoption 注册命令行参数，pytestconfig 通过配置对象读取参数的值 2、使用方法 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be00488276092b3234e299ff217a8091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01488a66193fd1368cd39639511c54e/" rel="bookmark">
			Vue-组件二次封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次对el-input进行简单封装进行演示
封装很简单，就给激活样式的边框(主要是功能) 本次封装主要使用到vue自带的几个对象
$attrs：获取绑定在组件上的所有属性$listeners: 获取绑定在组件上的所有函数方法$slots： 获取应用在组件内的所有插槽 1、属性传递 element 的input组件有很多属性，
想要实现在封装好后的组件上使用el-input组件的属性，会直接传递到el-input组件上，包括v-model。在组件中，可以使用this.$attrs获取所有绑定在组件上的属性(不包括方法)这样，我们就可以在封装的组件内，使用v-bind="$attrs"，直接把属性传递到内部组件上。在下列案例中，由于v-model是:value 和 @input两个组合的语法糖，$attrs只能获取属性，所以只能传递:value属性 1.1、父组件 &lt;template&gt; &lt;div class="wrapper"&gt; &lt;my-input v-model="val"&gt; &lt;/my-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import MyInput from '@/components/MyInput' export default { components: { MyInput, }, data() { return { val: '111', } }, methods: { inputChange(val){ console.log(val); } } } &lt;/script&gt; &lt;style lang="scss" scoped&gt; .wrapper { padding: 10vh; } &lt;/style&gt; 1.2、子组件 &lt;template&gt; &lt;el-input v-bind="$attrs"&gt;&lt;/el-input&gt; &lt;/template&gt; &lt;script&gt; export default { created() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d01488a66193fd1368cd39639511c54e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581f3d41319a11beeca4cec18e261da8/" rel="bookmark">
			【BUUCTF Web】WriteUp超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BUUCTF Web [极客大挑战 2019]EasySQL[极客大挑战 2019]Havefun[HCTF 2018]WarmUp[ACTF2020 新生赛]Include[ACTF2020 新生赛]Exec[GXYCTF2019]Ping Ping Ping[强网杯 2019]随便注[SUCTF 2019]EasySQL[极客大挑战 2019]Secret File[极客大挑战 2019]LoveSQL[极客大挑战 2019]Http[极客大挑战 2019]Knife[极客大挑战 2019]Upload[ACTF2020 新生赛]Upload[极客大挑战 2019]BabySQL[极客大挑战 2019]PHP[ACTF2020 新生赛]BackupFile[RoarCTF 2019]Easy Calc[极客大挑战 2019]BuyFlag[BJDCTF2020]Easy MD5[护网杯 2018]easy_tornado [极客大挑战 2019]EasySQL 首先第一步 判断是哪一种注入方式：字符型？还是数字型？
在请求框中输入 1 1' 来根据服务器给出的回显进行判断 输入1时
输入1’ 时
根据回显内容可知，该注入类型为字符型注入 接下来因为是字符型注入，可以尝试字符型注入时的万能公式试一试
这里我个人认为区分字符型和数字型的最简单的方式就是看他1后面有没有跟着单引号，如果有就是字符型，如果没有就是数字型
万能公式： 1 and 1=1 数字型 1' and '1'='1 字符型 1 or 1=1 数字型 1' or '1'='1 字符型 使用 1’ or 1=1 进行注入时，注入成功
使用 1’ and ‘1’= '1 进行注入，注入不成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/581f3d41319a11beeca4cec18e261da8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0412a1f5d87cceed2e66957f62dfd853/" rel="bookmark">
			详细图解,二叉排序树的遍历、删除、插入，通过bf优化构建成平衡二叉树(avl树)的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.二叉排序树的建立
二.二叉树的遍历
三.改造树结构
四.有序二叉树的查找
五.二叉排序树的节点删除
六.二叉排序树优化成平衡二叉树
七.平衡二叉树的建立过程
八.总结
一.二叉排序树的建立 1.数据结构定义
class TreeNode { public: int m_data = 0; //数据 TreeNode* m_lch = NULL; //左节点 TreeNode* m_rch = NULL; //右节点 TreeNode* m_father = NULL; //父亲节点 }; class Tree { public: void PreOrderVisit(TreeNode* node); //前序遍历 void InOrderVisit(TreeNode* node); //中序遍历 void PostOrderVisit(TreeNode* node);//后序遍历 void InitTree(int* pArr, int n ); private: void AddChild(TreeNode* TT, TreeNode* node); TreeNode* m_root = NULL; } 下图展示了数据10,7,20,3,1,5,17构建一个有序二叉树的过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0412a1f5d87cceed2e66957f62dfd853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7657d2cf0ef9d8d1eeaa6d5a56436c15/" rel="bookmark">
			yolov5训练加速--一个可能忽视的细节（mmdetection也一样），为什么显卡使用率老是为0？（续）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇训练加速的文章：
https://blog.csdn.net/ogebgvictor/article/details/129784503
但是有些细节需要更正或者补充，故再写一篇。
目录
一。是用缩放到640的jpg训练，还是用缩放到640的npy文件训练？
1.先改一下代码
2.实验
a)缓存到内存中
b)缓存640npy
c)接下来用缩放到640的jpg来训练
d)640npy与640jpg交叉验证
e)数据有点多，为方便对比，放个表上来
3.但是如果我就是有可能要用640jpg呢
直接上汇总表对比
二。更多细节
1.坐标超像素
2.对齐精度
a)图片缩放方法是否一致
b)算法代码会不会有坑？
三。batch-size8和16、32，为啥没区别？
1.取数据比GPU计算快
2.取数据比GPU计算慢
3.取数据比GPU慢，并且提升batch-size
4.取数据比GPU慢，并且继续提升batch-size
一。是用缩放到640的jpg训练，还是用缩放到640的npy文件训练？ 如果训练分辨率用640，那么在训练的过程中，yolov5会先把图片resize成640，然后再进行后续的处理（数据增强、前向推理），所以你把图片事先resize成640，似乎是一样的。但是如果你把它保存为jpg，然后在训练的时候用这个640的jpg，其实与原图resize到640是不一样的！
因为jpg是有损编码，会有一定的损失。而原图resize到640，比如采用双线性插值，它其实是具有超像素的信息的，但是保存为640的jpg，就又会损失掉一部分信息。所以最好在resize成640后，直接用numpy把它保存为npy文件，这是完全无损的。（题外话：比如用1080p的显示器，去播放2K甚至4K的视频，可能就是觉得比播放1080p的视频更清晰，可能就是因为有超像素的信息~~）
你可能会问：损失的那一点点信息有关系吗？下面实验一下。我用的数据集是cityscape数据集，从中选了10个分类：'person', 'rider', 'car', 'truck', 'bus', 'train', 'motorcycle', 'bicycle'。这个数据集的图片分辨率都是2048乘1024的，所以缩放到640的话，缩放比例为3.2，这个比例还是蛮大的。原图上面有大小不一的物体，有的小物体在缩放后就会很小了。并且此数据集中重叠的物体很多。所以用640分辨率来训练，其实并不是很合适，但是这正好用来验证一下640jpg导致的损失信息对训练效果的影响。
1.先改一下代码 用yolov5-7.0的代码来实验，但是他的代码在把图片保存为npy的时候(即训练参数--cache disk)，并没有先缩放到640再保存，而是直接按原图尺寸保存。
对应函数为utils/dataloaders.py中的LoadImagesAndLabels.cache_images_to_disk()，所以我把它修改了一下，如下cache_images_to_disk是我修改后的，cache_images_to_disk_old是修改前的。
def cache_images_to_disk(self, i): # Saves an image as an *.npy file for faster loading f = self.npy_files[i] if not f.exists(): im = cv2.imread(self.im_files[i]) # BGR assert im is not None, f'Image Not Found {f}' h0, w0 = im.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7657d2cf0ef9d8d1eeaa6d5a56436c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102495e1e277cfdbdcfe08183864d4d3/" rel="bookmark">
			OpenGL问题列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✔️ OpenGL没有做任何MVP变换那默认视觉空间的范围多大？
默认的视觉空间为从-z方向看 [ − 1 , 1 ] 3 [-1,1]^3 [−1,1]3标准立方体内没有depth_test的正交投影。也就是只能看见x,y这个平面。
✔️view变换应是先将摄像机平移到原点，之后进行摄像机坐标与世界坐标的对齐，也就是先T再R。glm::lookAt的实现把TR操作放到一个变换矩阵中，岂不是先R后T了？
问题本质源于games101图形学理论与OpenGL中具体实现的区别，即理论支撑和落地实践的区别。
games101：先确定相机位置，将相机移动到原点位置，同时所有物体随之做相对运动，最后对齐相机坐标和世界坐标，所有物体依旧做相对运动。
OpenGL：相机(视点)永远在原点位置，根据定义的摄像机坐标先与世界坐标对齐，最后物体再平移。可以说没有相对运动一说，因为相机永远不动，只有物体去找自己应该站的位置。
template &lt;typename T&gt; GLM_FUNC_QUALIFIER detail::tmat4x4&lt;T&gt; lookAt ( detail::tvec3&lt;T&gt; const &amp; eye, detail::tvec3&lt;T&gt; const &amp; center, detail::tvec3&lt;T&gt; const &amp; up ) { detail::tvec3&lt;T&gt; f = normalize(center - eye); detail::tvec3&lt;T&gt; u = normalize(up); detail::tvec3&lt;T&gt; s = normalize(cross(f, u)); u = cross(s, f); detail::tmat4x4&lt;T&gt; Result(1); Result[0][0] = s.x; Result[1][0] = s.y; Result[2][0] = s.z; Result[0][1] = u.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102495e1e277cfdbdcfe08183864d4d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5455ee2f5412a46231b2e05b84b443/" rel="bookmark">
			Linux图形栈入门概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mesa在图形栈中的位置 游戏引擎：
游戏引擎指的是一种软件框架，通过编程和各种工具，帮助开发者设计、构建和运行视频游戏。它相当于一个虚拟的世界创造工具，提供了各种功能模块和资源，如渲染引擎、物理引擎(碰撞检测、重力计算等)、声音引擎、动画系统等，用来处理游戏中的图形、声音、物理效果、用户输入和逻辑等方面。游戏引擎提供了强大的工具和功能，大大简化了游戏开发的过程，缩短了开发周期，使开发者能够更专注于游戏的创意和设计。
Windowing library OpenGL 包含了一系列可以操作图形、图像的函数。然而，OpenGL 本身并不是一个 API，它仅仅是一个由 Khronos 组织并维护的规范。一般而言，OpenGL 库是由电脑显卡的供应商开发和维护的。而GLFW 是一个专门针对 OpenGL 的 C 语言库，它提供了一些渲染物体所需要的最低限度的接口。GLFW 的主要功能是创建并管理窗口和 OpenGL 上下文，同时还提供了处理手柄、键盘、鼠标输入的功能。
GUN C Library 一般人买车肯定都是买整车而不是买引擎吧？而且称呼这台车的时候一般也是称呼整车的型号或者名称，而不会称呼这台车的引擎的名称。而用过“Linux操作系统”的人一定注意到过一个现象：这些系统的名称一般被叫做Ubuntu、Debian、Fedora、CentOS、Manjaro、openSUSE……等等，并不一定有“Linux”字样。这涉及到Linux世界的一个基本事实：Linux本身并不是一个完整的操作系统，而是一个操作系统的核心程序（一般称为内核），相当于一个引擎。而大家熟知的 grub、bash、ls、cat、gcc、grep、tar、vi、nano、curl、git……等等各种命令严格来说并不属于Linux内核项目，而是GNU旗下的众多软件。将内核和这些软件工具组合到一起形成的完整操作系统（一般称为发行版），相当于各种零部件组合成整车。而细究起来会发现，这台“整车”里的多数基础零件都是来源于GNU项目，例如：
grep 来源于 https://www.gnu.org/software/grep/ tar 来源于 https://www.gnu.org/software/tar/ gzip 来源于 https://www.gnu.org/software/gzip/ wget 来源于 https://www.gnu.org/software/wget/ time 来源于 https://www.gnu.org/software/time/ bc 来源于 https://www.gnu.org/software/bc/ diff 来源于 https://www.gnu.org/software/ sed 来源于 https://www.gnu.org/software/sed/ awk 来源于 https://www.gnu.org/software/gawk/ gcc 来源于 https://www.gnu.org/software/gcc/ make 来源于 https://www.gnu.org/software/make/ C 库也只是GUN所提供的库之一。
Mesa3D 驱动程序就是驱使硬件工作的代码，最简单的例子就是点亮led灯，led厂商提供的驱动程序是以接口形式存在，可能调用open就是打开，close就是关闭，又或许另外一家厂商调用on是打开，off是关闭。那应用程序在写代码时，为了保持良好适用性，可能里面会有一段判断逻辑，如果厂商a是一套逻辑，厂商b则是另外一套逻辑，为了统一，一定会有组织出来安排规范，组织可以规定打开就必须用on，关闭就必须用off，先不考虑厂商愿不愿意改的问题。假如厂商已将驱动程序烧到设备里面，而且部分产品已经到用户手里了。又或者其他原因，厂商无法更改驱动程序，那么怎么办呢？每个应用程序都要写判断的逻辑，而且厂商那么多，写应用程序的并不想关注这么多细节，那么可以提供一套框架，把逻辑写在框架里，操作系统安装这个框架就能为用户提供统一的接口。点led灯通常对应的就是led电子屏，通常应用程序通过特定的算法控制led矩阵上不同位置的灯的亮灭展示图案，如果大家的需求都是展示文字，那么刚才提到的框架甚至可以将这一段逻辑包含进来，上层只需要将要展示的文字传给框架，框架负责安排哪个灯亮还是灭。又进一步简化用户的操作了。mesa差不多就是这样一种框架，不过他关联的设备不是led灯而是图形卡。
OpenGL就是为了统一各厂商图形化所提出的一套规范，只是规定了接口，但是具体细节不作任何要求，所以OpenGL并没有实现，只是做了规范。而Mesa3D就是OpenGL的开源实现，除此之外，他还有一个重要的功能就是在没有图像卡的主机上，可以通过CPU来完成渲染效果。没有Mesa的话，用户在写3D应用时，如果直接调用GPU驱动程序提供的接口，实现会更复杂，代码量也会及其庞大。为了获得更好的通用性，你还需要了解很多图形厂商的细节，如果你把这些都做到了，其实你自己就写了一个Mesa，如果是学习使用，那倒无妨，如果是实际开发，别人写好了为什么不用。但是他们写框架会考虑灵活性，稳定性各种因素，通常会抽象出很多东西(各种上下文)，然而你的思路和他们未必一致，因此在理解他们框架上会造成一定的阻碍。虽然使用更方便但是学习框架并理解它们则需要花费大量的时间。
一言蔽之，Mesa就像一个管理驱动的大型软件，为应用层的编程提供便利，和我们日常使用的软件不同的是，它不是以图形界面展示给我们，而且采用接口的形式。且这不是我们关心的问题，因为我们的工作并不是编写应用程序，而是需要扩充Mesa的能力，让Mesa也能支持我们的卡。
个人理解，如gl.h中的方法在Mesa中都有具体实现，Mesa分为前端和后端，前端是API的实现具体会把产生的状态和数据下发到后端，后端就是用我们自己的逻辑去适配自己的产品。举例例子不一定正确，比如说开辟一个缓冲区，前端可能就是逻辑上开辟一个缓冲区然后用一个对象或指针去绑定它，而后端是具体这个缓冲区开辟在我们硬件的什么位置，就前端而言所有的厂商逻辑都是一样的，而后端是要根据我们自己产品的实际情况去进行处理，毕竟256MB和4G的显存开辟缓冲区的实现肯定是有差异的。而我们需要做的就是向后端追加适配于我们硬件的逻辑代码，扩充Mesa的功能，使其支持我们的产品。
DRM DRM是图形卡硬件编程的管道，主要由mesa使用，也可以理解成是Linux内核的一个子系统，负责与现代视频卡中GPU交互的接口。DRM公开了一个API(DRM Library)，用户空间程序可以使用该API向GPU发送命令和数据，并执行诸如配置显示器的模式设置等操作。DRM允许多个程序同时访问3D视频卡，避免冲突。
DRM从模块上划分，可以简单分为3部分：libdrm、KMS、GEM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d5455ee2f5412a46231b2e05b84b443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1042daf3313d6782bf6fa1b9f85f1296/" rel="bookmark">
			MySQL 使用规范 —— 如何建好字段和索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、案例背景
二、库表规范
1. 建表相关规范
2. 字段相关规范
3. 索引相关规范
4. 使用相关规范
三、建表语句
三、语句操作
1. 插入操作
2. 查询操作
四、其他配置
1. 监控活动和性能：
2. 连接数查询和配置
本文的宗旨在于通过简单干净实践的方式教会读者，如何更好地使用 MySQL 数据库。这包括；库表创建规范、字段的创建规范、索引的创建规范以及SQL使用的相关规范，通过这些内容的讲解，让读者更好使用 MySQL 数据库，创建出符合规范的表和字段以及建出合适的索引。
如果你还想学习更深入的 MySQL 知识，建议可以阅读下官网的参考手册，这比任何一个资料都要有权威性。
MySQL 5.7 参考手册
MySQL 8.0 参考手册
本文涉及的工程【导表语句】：https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-mysql
road_map_5.6.sql
road_map_8.0.sql
一、案例背景 此案例背景定位于使用使用一个简单的订单表，来讲解 MySQL 使用的相关规范。包括；表的引擎、命名约束、字段长度、金额类型、更新时间、索引字段、组合索引等内容，方便大家学习以后，可以基于这些字段的规范演示讲解，在自己创建库表的时候有个参考对照，尽可能创建出性能更佳的库表和索引。
二、库表规范 为了能让读者更加清晰地看到这些相关规范都是如何体现的，小傅哥这里准备了个大图，把库表字段和规范全部整合在一起，方便学习使用。如下；
如上所列规范包括：建表相关规范、字段相关规范、索引相关规范、使用相关规范。
1. 建表相关规范 库名、表名、字段名，使用小写和下划线 _ 分割
库名、表名、字段名，不超过12个字符。默认支持64个字符。
库名、表名、字段名，见名知意，建议使用名词而不是动词。
使用 InnoDB 存储引擎。支持；事务、锁、高并发 性能好。
推荐使用 utf8mb4 可以存emoji
单表字段数，建议不超过40个
2. 字段相关规范 整型定义中不显示设置长度，如使用 INT，而不是INT(4)
存储精度浮点数，使用 DECIMAL 替代 FLOAT、DOUBLE
所有字段，都要有 Comment 描述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1042daf3313d6782bf6fa1b9f85f1296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa39636c30d761f1be58f25177221b0f/" rel="bookmark">
			下载安装Android Studio，到创建第一个虚拟机超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、第一步，打开浏览器，搜索Android Studio官网
二、点击Download Android Studio Giraffe下载软件
三、勾选协议
四、查看浏览器显示下载
五、打开下载的文件夹找到下载的程序
六、点击Next，下一步
七、全部都勾选上，点击Next，下一步
八、修改安装位置，点击Next，下一步
九、点击Install，安装
十、点击Next
十一、点击Finish安装完成
十二、第一次安装，选Do not import settings ,点击OK
十三、点击
十四、点击Next
十五、点击标准就行，点击Next
十六、点击Next
十七、点击Next
十八、点击这三个，都选择Accept,接受，然后点击Finish
十九、点击Finish
二十、安装完成，显示程序页面
二十一、点击Projects,点击New Project创建新项目
二十二、点击Phone and Tablet，进入创建页面选择empty activity
二十三、在后的界面更改项目名称和项目储存位置，点击finish
二十四、运行结果
二十五、
创建Android虚拟机并运行项目
打开虚拟机管理器，创建新的虚拟机。
二十六、选择手机机型，点击Next
二十七、选择操作系统，我选择了第一个
二十八、选择Accept，点击Next
二十九、点击Finish
三十、下载完成，点击Next
三十一、最后选择横竖屏,然后点击Finish
三十二、创建完毕后，启动虚拟机
运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d00d7b75f57f0870a9629664903b58/" rel="bookmark">
			前端LayUI框架快速上手详解(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✍LayUI 🔥前端框架LayUI详解地址🔥前端LayUI框架快速上手详解(一)https://blog.csdn.net/Augenstern_QXL/article/details/119748962🔥前端LayUI框架快速上手详解(二)https://blog.csdn.net/Augenstern_QXL/article/details/119749461 最新版本v2.6.8官方文档讲解较细致，但同时也较繁琐，本篇旨在记录常用样式的用法与注意点.配套视频讲解地址:B站直达 LayUI 1、弹出层 1.1、弹出层 弹出层官方文档：https://www.layui.com/doc/modules/layer.html#use
layer可以独立使用，也可以通过Layui模块化使用
场景用前准备调用方式1.作为独立组件使用如果你只是单独想使用 layer，你可以去 layer 独立版本官网下载组件包。你需要在你的页面引入jQuery1.8以上的任意版本，并引入layer.js。通过script标签引入layer.js后，直接用即可。2.layui 模块化使用如果你使用的是 layui，那么你直接在官网下载 layui 框架即可，无需引入 jQuery 和 layer.js，但需要引入layui.css和layui.js通过*layui.use(‘layer’, callback)*加载模块 1.1.1、作为独立组件使用 首先去 layer 独立版本官网下载组件包。 下载完成后解压，将 layer.js 和 layer.css 拷贝到我们的项目中引入资源 &lt;!-- 引入layer.css --&gt; &lt;link rel="stylesheet" href="layer/layer.css" /&gt; &lt;!-- 引入jquery.js --&gt; &lt;script src="js/jquery-3.4.1.js" charset="utf-8"&gt;&lt;/script&gt; &lt;!-- 引入layer.js --&gt; &lt;script src="layer/layer.js"&gt;&lt;/script&gt; 开始使用 &lt;body&gt; &lt;script type="text/javascript"&gt; layer.msg("Hello"); &lt;/script&gt; &lt;/body&gt; 1.1.2、使用模块化🔥 引入资源 &lt;!-- layui模块化使用 --&gt; &lt;!-- 引入 layui.css --&gt; &lt;link rel="stylesheet" href="layui-v2.5.6/layui/css/layui.css" /&gt; &lt;!-- 引入 layui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d00d7b75f57f0870a9629664903b58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ebecf128d23be06260b5dc197a9597/" rel="bookmark">
			详谈numpy.max,torch.max,argmax...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编写或使用机器学习算法的过程中经常需要对numpy数组、tensor张量进行各种聚合操作，比如max，但是初次接触这块的东西，可能难以理解其中具体的聚合逻辑。
一。先上个简单的例子 给一个3行4列的numpy数组，按第0维取最大值。
import numpy as np import numpy.random np.random.seed(0) a = np.random.randint(0, 100, (3, 4), dtype=np.int32) print(f'a:\r\n{a}') a_max_x = a.max(axis=0) print(f'a_max_x:\r\n{a_max_x}') 按第0维，即指定axis=0。这到底是啥意思呢，直接来个简单的图，就是竖着计算啦，所以就是第0列取个最大值，第1列取个最大值，第2列最个最大值，第3列取个最大值。最终得到的是一行4列的结果。
那我要是按第1维呢，即改成axis=1，那就是横着取啦，第0行取个最大值，第1行。。。，第2行。。。
也就是说按第0维就是竖着取，按第1维就是横着取。好像蛮奇怪的哦，但是也好记，死背！
等等，先别划走，我要是这么说就完了，那就不叫详谈了！
二。再来个难点的例子 二维的数组确实能硬背，但来个三维的呢？现在是2行3列4垂（我瞎起个维度的名字）
import numpy as np import numpy.random np.random.seed(0) a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32) print(f'a:\r\n{a}') a_max_x = a.max(axis=0) print(f'a_max_x:\r\n{a_max_x}') 这箭头怎么画？箭头是不太好画了，因为有3个维度，但现在用平面来展示数据，没法在这其中画出1个维度的箭头了，但是下面的红线两连的一组组数据，就是做聚合的一组组数据。
2行3列4垂，现在按第0维聚合，所以是两两聚合（听不懂没关系，下面有更容易懂的）
如果上面的弄明白了，那直接跳跃一下，argmax的结果又是什么情况？
import numpy as np import numpy.random np.random.seed(0) a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32) print(f'a:\r\n{a}') a_max_x = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55ebecf128d23be06260b5dc197a9597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d3356c5f7f477096094a0433e16153/" rel="bookmark">
			Android 给广播接收器增加权限（permission）或signature签名权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 普通权限
1.添加权限
当普通广播接收器需要增加权限时，需要在广播接收器所在的AndroidManifest.xml 文件中添加权限：
&lt;uses-permission android:name="com.android.permission.MY_PERMISSION"/&gt; &lt;permission android:name = "com.android.permission.MY_PERMISSION"/&gt; 注：我查到的资料是在广播接收器所在的AndroidManifest.xml 文件中添加permission就行了，uses-permission是添加在广播发送方的，但在我实际调试中我发现uses-permission也得加上，否则收不到广播（注意，我调试的时候广播接收器在Android源码的SystemUI中，而发送广播则是普通的app）。
2.注册广播
如果是静态注册，则在广播接收器所在的AndroidManifest.xml 文件中，&lt;application&gt;标签内注册：
&lt;receiver android:name=".com.example.MyReceiver" android:exported="true" android:permission="com.android.permission.MY_PERMISSON"&gt; &lt;intent-filter&gt; &lt;action android:name="com.my.permission" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 如果广播接收器是内部类的话，则使用外部类$内部类的格式。
android:exported="true" 是 AndroidManifest.xml 文件中的一个属性，用于指示一个组件（如 Activity、Service、BroadcastReceiver 或 ContentProvider）是否可以被其他应用程序或组件访问。 如果将 android:exported 设置为 true，则该组件可以被其他应用程序或组件调用，而不需要经过授权或权限检查。这通常用于提供公共 API 或服务。 但是，如果将 android:exported 设置为 false，则该组件只能被同一应用程序中的其他组件访问，而不能被其他应用程序或组件调用。这通常用于保护应用程序的私有数据或服务。 在开发应用程序时，需要小心使用 android:exported 属性，以确保不会意外地将应用程序暴露给未经授权的访问。
如果是动态注册广播，则在onCreate()方法中注册：
IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction("com.my.permission"); getContext().registerReceiver(new MyReceiver(), intentFilter, BROADCAST_PERMISSION, null); 其中关键点在于注册权限时传入的参数是四个。上述代码中BROADCAST_PERMISSION的就是在AndroidManifest.xml文件中自定义的权限。
private String BROADCAST_PERMISSION = "com.android.permission.MY_PERMISSON" 上述两种方法中各选一种注册方式即可。
3.发送广播：
只需要send的时候带上接收广播需要的权限就好了。
int broadcast = 0; Intent intent = new Intent(); intent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d3356c5f7f477096094a0433e16153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ace4b15dc0af5dec760a44f5ecd83bc/" rel="bookmark">
			python如何读取csv文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSV（Comma Separated Values）文件是一种常见的文件格式，它将数据以逗号分隔的形式存储，通常用于存储表格数据。在Python中，我们可以使用多种方法来读取CSV文件，本文将从多个角度分析Python如何读取CSV文件。
一、Python内置的csv库
Python内置了csv库，可以使用该库中的reader对象来读取CSV文件。下面是一个示例代码：
import csv with open('example.csv', newline='') as f: reader = csv.reader(f) for row in reader: print(row) 这里我们使用了with语句来打开文件，使用csv.reader对象读取文件内容，并使用for循环遍历每一行数据，并将其打印出来。注意，我们需要将newline参数设为’'，以免出现换行符带来的问题。
csv.reader对象可以接受多种参数，例如delimiter参数可以指定分隔符，quotechar参数可以指定引号字符等。
二、Pandas库
除了csv库外，Python还有一个强大的数据分析库Pandas，它可以读取多种数据格式，包括CSV文件。下面是一个示例代码：
import pandas as pd df = pd.read_csv('example.csv') print(df) 这里我们使用了Pandas的read_csv函数来读取CSV文件，并将其存储为DataFrame对象。然后我们打印出了整个DataFrame对象。Pandas还有很多强大的数据处理和分析功能，可以方便地对数据进行进一步操作。
三、Numpy库
Numpy是Python中的另一个重要的数据处理库，它也可以读取CSV文件。下面是一个示例代码：
import numpy as np data = np.genfromtxt('example.csv', delimiter=',', skip_header=1) print(data) 这里我们使用了Numpy的genfromtxt函数来读取CSV文件，并将其存储为Numpy数组。我们可以通过delimiter参数指定分隔符，通过skip_header参数指定忽略的行数等。然后我们打印出了整个Numpy数组。
四、使用第三方库
除了内置库外，Python还有很多第三方库可以读取CSV文件，例如：openpyxl、xlrd、pandasql等。这些库都有各自的特点和优劣，可以根据需要选择使用。
综上所述，Python读取CSV文件的方法有很多，可以使用内置库、Pandas、Numpy等，也可以使用第三方库。不同的方法有各自的特点和优劣，可以根据具体的应用场景选择使用。无论使用哪种方法，我们都需要注意文件编码、分隔符、引号字符等细节问题，以免出现读取错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a66fdb794fc1e335d6ed18a6a22d3b/" rel="bookmark">
			selenium中定位shadow-root，以及获取shadow-root内部的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过shadow-root的父级定位到shadow-root,再通过语句进行操作
两种方法：
第一种，Python种JS实现
第二种，selenium实现
1.0 案例网站 参考某橘色网站
2.0 js语句定位 可在控制台进行测试
测试语句
document.querySelector("ali-bar-new").shadowRoot.querySelector("ali-bar-menu").shadowRoot.querySelector("div") 3.0 python实现js的方法 3.1 selenium实现 execute_实现
driver.execute_script('document.querySelector("ali-bar-new").shadowRoot.querySelector("ali-bar-menu").shadowRoot.querySelector("div")') python直接实现
# example root = driver.find_element("id", "form-shadow-root") shadow_root = root.shadow_root textfield = shadow_root.find_element_by_css_selector("div#dialog &gt; div:nth-child(2) input") # id为dialog的div的下一级div的第二个，之后的相对的input tag(无所谓层级) btn = shadow_root.find_element_by_css_selector("button[class='btn next-button']") # tag为button的class为该值的元素 dropdown_item = shadow_root.find_element_by_css_selector('#search-field').find_element_by_xpath("//div//ul/li[text()='default']") # 先找css然后再找sub element 3.2 python中直接调用执行js 3.2.1 基本操作 import js2py# 执行单行js语句 result = js2py.eval_js("console.log(abcd)") print(result) # 执行写在js文件中的 log = js2py.eval_js(open('./log.js','r',encoding='utf-8').read()) print(log) js = js2py.EvalJs({}) js.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6a66fdb794fc1e335d6ed18a6a22d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82bda753aef5ecada141a1e01afe3376/" rel="bookmark">
			在Java中如何接收通过C#代码发送的文件流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		byte[] data = File.ReadAllBytes(Utils.MrFile.PathName); pdfFile.data = BitConverter.ToString(data); 通过以上c#代码，发送流，在java中如何接收？
// 获取从C#发送的十六进制字节数组字符串 String hexData = "AB-CD-EF-01-23"; // 移除连字符，得到十六进制字节数组的字符串数组 String[] byteStrings = hexData.split("-"); // 创建一个字节数组来存储解析后的数据 byte[] data = new byte[byteStrings.length]; // 将每个字节的字符串转换为字节值 for (int i = 0; i &lt; byteStrings.length; i++) { // 解析为十六进制字节值 byte b = (byte) Integer.parseInt(byteStrings[i], 16); data[i] = b; } // 现在你可以使用字节数组 'data' 进行进一步处理 请注意，上述代码仅演示了如何将由 BitConverter.ToString() 方法转换的十六进制字节数组字符串还原为字节数组。实际应用中，你可能需要根据具体的网络通信协议进行数据传输和接收。
通过字节数组转文件：
public static File bytesToFile(byte[] bytes, String outPath, String fileName) { BufferedOutputStream bos = null; FileOutputStream fos = null; File file = null; try { File dir = new File(outPath); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82bda753aef5ecada141a1e01afe3376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d792d9e215c46aaaf9aa495349958e/" rel="bookmark">
			深度学习论文分享（九）Unifying Motion Deblurring and Frame Interpolation with Events
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习论文分享（九）Unifying Motion Deblurring and Frame Interpolation with Events 前言Abstract1. Introduction2. Related Work2.1. Frame Interpolation2.2. Motion Deblurring2.3. Joint Deblurring and Interpolation 3. Problem Statement4. Method4.1. Unified Deblurring and Interpolation4.1.1 Feasibility Analysis4.1.2 Network Architecture 4.2. Self-supervised Learning Framework 5. Experiments and Analysis5.1. Experimental Settings5.2. Results of Deblurring5.3. Results of Interpolation5.4. Ablation Study 6. ConclusionReferences 前言 论文原文：https://openaccess.thecvf.com/content/CVPR2022/papers/Zhang_Unifying_Motion_Deblurring_and_Frame_Interpolation_With_Events_CVPR_2022_paper.pdf
论文代码：https://github.com/XiangZ-0/EVDI
Title：Unifying Motion Deblurring and Frame Interpolation with Events
Authors：Xiang Zhang, Lei Y u†
Wuhan University, Wuhan, China.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d792d9e215c46aaaf9aa495349958e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267523c58b418569b598a11753732cc8/" rel="bookmark">
			sql按序输出但是顺序混乱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的问题是优先级不是integer保存而是varchar，导致’9’&gt;'10’这种情况发生了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d998a0d0e1863f3e453e9d0005bc58d/" rel="bookmark">
			jQuery（前端）怎么直接调用后端的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景：点击保存后数据库修改成功，同时要调用存储过程。
$.ajax({ url: [[@{/后端路径}]] method:'GET/POST', syccess: function(response){ alert("成功"); console.log(response); } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d42eb186985623295bd44c8f85ba24b/" rel="bookmark">
			VMware Workstation Pro 17下载安装和虚拟机创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 VMware下载Vmware安装创建虚拟机 VMware下载 注：VMware要登录后才能下载，若没有账号需要先注册账号并登录。
Account：fkxcjwpesp@iubridge.com Password：@Vmware2022 VLC：JU090-6039P-08409-8J0QH-2YR7F 访问Vmware ，先登录，不然点击下载后还是会跳转到登录页
找到 Resource 栏目，选择 Product Download 下载
选择所有产品从 A-Z 的顺序排列出来，顺序选择降序
此时就会将产品顺序倒序排列，就可以看到VMware Workstation Pro
选择不同的版本和操作系统下载
Vmware安装 下载完成后，进入安装步骤，如果还未下载，请参照上面步骤下载即可
双击运行下载后的.exe文件，下一步并勾选接受协议
更改安装路径，默认是C盘（不建议安装到C盘）
取消勾选产品更新和体验计划（自选）
创建快捷方式，然后下一步安装
安装完成后可以免费试用30天
创建虚拟机 新建虚拟机，选择典型
稍后安装操作系统，创建完虚拟机后安装（需下载系统镜像文件）
选择Linux版本Centos7（我后面是下载Centos7 ），根据自己下载的发行版系统选择
修改虚拟机安装的位置，默认C盘（不建议）
最大磁盘大小默认20GB（注：并不是一下子分配20G存储空间给虚拟机，而是你后面用多少分配多少空间，最多分配20G），选择拆分多个文件
选择自定义硬件，内存默认是1G，根据自己本机内存选择（我内存是16G，所以我选2G）
选择处理器和内核数，根据自己本机CPU处理器和内核数决定（我本机是8处理器，每处理器的内核是4，内核总数是32），分配了2处理器和2内核，共4内核数
查看自己本机的CPU和内核数
网络适配器选择NAT模式
其他默认，然后点击关闭，完成
网络适配器不同模式的区别：
桥接模式：虚拟机可以和外部互相直接通信，但容易造成IP冲突NAT模式：网络地址转换模式，可以和外部通信，外部不可以访问虚拟机，不容易造成IP冲突主机模式：独立的系统，不与外部通信 注意：NAT模式下，虚拟机会和主机生成独立的网络环境，与主机IP段位不同，再通过主机IP代理访问外部网络，但外部不能访问虚拟机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc89981101cf5b5958ad3dc9ca8faae3/" rel="bookmark">
			学习shell网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你想要系统地学习Shell编程，以下网站可能会对你有帮助：
Linux Documentation Project - Advanced Bash-Scripting Guide:
网址：Advanced Bash-Scripting Guide该指南提供了深入的Bash脚本编程知识，从基础到高级都有涵盖。它包含大量的例子和练习，是学习Shell脚本编程的好资源。 Bash Academy:
网址：https://www.bash.academy/Bash Academy提供了一系列交互式的教程，从入门到高级的Shell编程。它的学习方式非常互动和实践导向。 ShellCheck:
网址：ShellCheck – shell script analysis tool虽然ShellCheck本身不是一个完整的学习资源，但它是一个非常有用的工具，用于检查Shell脚本中的语法和常见错误。当你编写脚本时，可以使用ShellCheck来学习如何避免常见的问题。 The Linux Command Line:
网址：Linux Command Line Books by William Shotts这是一本免费的在线书籍，介绍了Linux命令行的基础和Shell编程。尽管它主要关注命令行，但它也包含了一些Shell脚本编程的基础知识。 bash-hackers Wiki:
网址：bash-hackers.org这是一个社区驱动的维基，包含了大量关于Bash编程的信息、教程和技巧。 Codecademy - Learn the Command Line:
网址：Learn the Command Line | CodecademyCodecademy提供了一个交互式的课程，教你学习命令行和Shell脚本编程。 Coursera 和 edX:
在Coursera（https://www.coursera.org/）和edX（https://www.edx.org/）等在线学习平台上，你可能会找到与Shell编程相关的课程，这些课程可能从基础到高级都有。 无论你选择哪个资源，都要保持实践和实验的态度。通过编写实际的Shell脚本，解决实际问题，你会更好地掌握Shell编程的技能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae24c5191af555ac7a23c4b127bd10d/" rel="bookmark">
			人脸开源数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表情数据集： KDEF,RaFD,RAF,EMotionNet等
人脸数据集：CelrBa
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6eaabba963752f5611a89bd36eeee8/" rel="bookmark">
			【浏览器】端数据库存储方案----indexDB、localForage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器存储 localStoragelocalforageIndexDB localStorage 说到本地存储数据，首先想到的是 localStorage，应该很多小伙伴都用过，使用很简单。然而，localStorage 却有下面一些缺点：
存储容量限制，大部分浏览器应该最多5M。我就遇到过localStorage存储字符然后尺寸爆掉的情况；仅支持字符串，如果是存对象还需将使用 JSON.stringify 和 JSON.parse 方法互相转换，有些啰嗦；读取都是同步的。大多数情况下，还挺好使的。如果存储数据比较大，如一张重要图片base64格式存储了，再读可能会有可感知的延迟时间； localforage 官网文档
localforage 的作用就是用来规避上面 localStorage 的缺点，同时保留 localStorage 的优点而设计的。
localForage 是一个 JavaScript 库，通过简单类似 localStorage API 的 异步存储 来改进你的 Web 应用程序的离线体验。
localForage 有一个优雅降级策略，若浏览器不支持 IndexedDB 或 WebSQL，则使用 localStorage。在所有主流浏览器中都可用：Chrome，Firefox，IE 和 Safari（包括 Safari Mobile）。
localForage 提供回调 API 同时也支持 ES6 Promises API，你可以自行选择。 使用
npm install localforage ----------------- import localforage from "localforage"; localforage.config({ name: 'db_name' }); Vue.prototype.$localForage = localforage; // 存储数据 let res = { data: { username: 'wahaha' } } this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6eaabba963752f5611a89bd36eeee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce38acda5911b110947564405b8ed45/" rel="bookmark">
			ROS2运行例程报错：无法找到 librclpy_common.so共享库文件【已解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ROS2（foxy/galactic版本）系统中，不管运行什么例程都会报这个错，显示导入错误： librclpy_common.so： 无法打开共享对象文件。报错信息如下：
ImportError: librclpy_common.so: cannot open shared object file: No such file or directory
ImportError: librclpy_common.so: cannot open shared object file: No such file or directory The C extension '/opt/ros/foxy/lib/python3.8/site-packages/rclpy/_rclpy.cpython-38-aarch64-linux-gnu.so' failed to be imported while being present on the system. Please refer to 'https://index.ros.org/doc/ros2/Troubleshooting/Installation-Troubleshooting/#import-failing-even-with-library-present-on-the-system' for possible solutions 检查python版本得知，系统的python3版本为Python 3.8.10
python3 --version 检查系统是否正常安装ros-eloquent-rclpy：
dpkg -L ros-foxy-rclpy 在ROS论坛查到原因：问题在于：当使用 LD_LIBRARY_PATH 时，LD_LIBRARY_PATH 会被setcap忽略。因此python3.8将无法找到ros库，只能找到python包。
解决办法：
运行以下指令后即可解决问题
sudo setcap -r /usr/bin/python3.8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062b25fe2806948ba3c17203fd1973db/" rel="bookmark">
			【大虾送书第七期】深入浅出SSD：固态存储核心技术、原理与实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
✨写在前面 ✨内容简介
✨作者简介
✨名人推荐
✨文末福利
🦐博客主页：大虾好吃吗的博客
🦐专栏地址：免费送书活动专栏地址
写在前面 近年来国家大力支持半导体行业，鼓励自主创新，中国SSD技术和产业良性发展，产业链在不断完善，与国际厂商的差距逐渐缩小。但从行业发展趋势来看，SSD相关技术仍有大幅进步的空间，SSD相关技术也确实在不断前进。随着闪存芯片制程工艺的进步、堆叠层数的增加等，SSD面临闪存大页问题、写放大导致的性能问题、3D堆叠导致的可靠性问题等，因此，我们仍需不断攻克核心技术，通过软硬件协同等多种方法提升SSD的性能和寿命，从而满足日益增长的应用需求。
中国在SSD技术方面只有面向国际前沿，加强企业研发和自主创新，才能逐步建立起核心竞争力，并在市场中占据更高份额。
《深入浅出SSD》第1版在2018年上市，随即成为SSD从业者，包括研究者、设计者、生产者和应用者，了解SSD工作原理和技术的畅销书。快5年过去了，SSD技术在不断发展，标准也在不断更新，出现了系列新技术或新标准，如可计算存储、ZNS、NVMe协议标准、NVMe over Fabrics、NAND新协议标准等，于是，本书诞生了。本书在第1版的基础上增加了大量新内容，覆盖面更广。本书的作者团队依然来自固态存储行业的技术精英，他们有多年经验，秉持专业、通俗和易懂风格著书，相信本书将继续给读者以良好的体验，助力SSD技术和产业发展。
内容简介 作为经典畅销书的升级版，本书在第1版的基础上新增了大量新知识（如闪存、UFS、测试、文件系统等），并改写或删减了许多过时或不适用的内容，总修改量超过60%。本书由SSD技术社区SSDFans的核心团队成员联合业界、高校SSD方面的专家共同完成，相对于第1版，内容更全面、更新，也更有深度。
本书从产品、技术和应用3个维度展开，全面、详细讲解了SSD的发展历史、产品形态、工作原理、整体架构，以及各个功能模块的原理和使用，从SSD的前端接口协议到FTL算法，再到后端的闪存和纠错，以及测试，本书都有涉及。本书既可以作为一本入门书籍帮读者快速上手工作，也可以作为工具书供读者在需要的时候进行查阅。
产品市场篇：介绍了SSD与HDD的比较、SSD的发展历史及产品形态，固态存储市场、NAND原厂动态及闪存发展趋势，以及可计算存储和航天存储产品等。
核心技术篇：重点介绍了主控内部模块构成和工作原理，闪存的实现原理、实践应用、特性及数据完整性等，FTL的映射管理、磨损均衡、垃圾回收、坏块管理等功能，以及LDPC解编码原理等。
协议篇：从实现原理、实践应用、发展趋势等多个维度对NVMe、PCIe、UFS等进行深度解读，让读者既知其然又知其所以然。
测试篇：详述了与SSD相关的常用测试软件、测试流程、仪器设备、业界认证及专业的测试标准等。
扩展篇：从传统的EXT4文件系统到对闪存更友好的F2FS文件系统都进行了全面解读。 作者简介 SSDFans　由蛋蛋（段星辉，江波龙首席软件工程师）、阿呆（赵占祥，云岫资本合伙人兼CTO）、Marx（王圣，CNEXLABS 固件开发高级经理）、SSD攻城狮于2014 年创立，他们因共同的梦想和追求走到一起。SSDFans 创立的初衷是普及固态存储相关知识，为祖国的固态存储事业添砖加瓦。SSDFans 是目前国内乃至在世界范围内的华人圈中都颇具影响力的 SSD 固态硬盘技术社区。
胡波　毕业于华中科技大学控制系，在固态存储行业从业15年，现就职于Solidigm从事企业级SSD相关工作，曾就职于美光、戴尔、联芸等，负责研发、PM、市场、销售、质量、AE/FAE等工作，涉及的产品有NAND、DRAM、SSD、UFS、控制器等。业余时间热衷写作和分享交流，希望为推动国内固态存储生态和技术发展贡献自己的力量。
石亮　华东师范大学教授/博导，上海市“科技启明星”。研究方向包括存储介质可靠性、存储控制算法、存储文件系统以及全系统软硬件协同技术。在FAST、ATC、MICRO、HPCA等国际顶级会议上发表多篇论文。在存储领域有较高的学术和企业贡献。
岑彪 上海鸾起科技创始人，复旦BI MBA 。曾就职于AMD、Seagate(LSI)、CNEXLABS等公司，当前所在的上海鸾起科技是一家专注于存储产品测试设备开发的科技公司。10余年SSD主控及模组测试经验，是国内较早一批从事SSD研发的工程师，参与过的产品包括SandForce的SATA主控，CNEXLABS PCIe系列主控、DPU等产品。SSD产品测试经验丰富。
名人推荐 我国企业近几年在存储领域发展迅速，在存储技术创新和制造方面的实力越来越强，在这个过程中《深入浅出SSD》在技术普及方面的贡献也是一股推动力。
——蔡华波 江波龙董事长
《深入浅出SSD》第2版对闪存技术原理和发展趋势进行了专业、系统、全面、完整的讲解，必将推动SSD的进一步发展和普及。
——陈 轶 长江存储执行副总裁
《深入浅出SSD》第2版在内容方面进行大幅升级，补充更新了ZNS等新技术和对市场新格局的介绍，强烈推荐大家阅读。
——杨亚飞 博士/大普微电子董事长
我代表得瑞领新祝贺《深入浅出SSD》第2版成功上市，希望这本书能给行业带来更多新关注、新血液、新资源。
——张建涛 得瑞领新董事长
本书最大的价值是帮助你系统而深入地学习SSD技术及知识，是所有固态存储领域的从业者必读书籍。
——康 毅 芯盛智能总裁
本书分析了SSD技术发展的脉络，并全面覆盖了SSD技术栈，真正做到了“深入浅出”，是有志从事SSD行业的工程师的良师益友。
——王 灿 佰维存储CTO 通过阅读本书，相信无论是刚刚进入这一行业的新人，还是久战沙场的老兵都会收获满满。
——张泰乐 忆恒创源CEO
《深入浅出SSD》第2版必将成为数据存储领域不可或缺的参考书。
——张 彤 ScaleFlux首席科学家
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/062b25fe2806948ba3c17203fd1973db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7af13494ea7b5b5c71c351ec22981fd/" rel="bookmark">
			目标检测后的图像上绘制边界框和标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如图所示，有个遗憾就是CV2在图像上显示中文有点难，也不想用别的了，所以改成了英文，代码在下面了，一定要注意一点，就是标注文件的读取一定要根据自己的实际情况改一下，我的所有图像的标注文件是一个XML文件。
import cv2 import os import numpy as np def draw_label_type(draw_img,bbox,label_color): label = str(bbox[-1]) labelSize = cv2.getTextSize(label + '0', cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)[0] if bbox[1] - labelSize[1] - 3 &lt; 0: # 在图像上绘制边界框 cv2.rectangle(draw_img, (bbox[0], bbox[1] + 2), (bbox[0] + labelSize[0], bbox[1] + labelSize[1] + 3), color=label_color, thickness=-1 ) # 在图像中的边界框中打上标签 cv2.putText(draw_img, label, (bbox[0], bbox[1] + labelSize[1] + 3), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), thickness=1 ) else: # 在图像上绘制边界框 cv2.rectangle(draw_img, (bbox[0], bbox[1] - labelSize[1] - 3), (bbox[0] + labelSize[0], bbox[1] - 3), color=label_color, thickness=-1 ) # 在图像中的边界框中打上标签 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7af13494ea7b5b5c71c351ec22981fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04abe1627d08891407e1178e887bcb13/" rel="bookmark">
			CS144（2023 Spring）Lab 0：networking warmup（环境搭建 &amp; webget &amp; bytestream）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言其他笔记相关链接 1. Set up GNU/Linux on your computer2. Networking by hand3. Writing a network program using an OS stream socket3.1 Linux配置3.2 C++规范3.3 Writing webget3.3.1 实现3.3.2 测试 4. An in-memory reliable byte stream4.1 思路分析4.2 代码展示4.3 代码测试 前言 最近心情非常郁闷，搓一个CS144玩玩吧，正好2023 spring出新版了。。。CS144的头4个Lab（加上0是5个），一步步实现了一个TCP。在开始之前，我想贴一下Lab中的这句话：The lab documents aren’t “specifications”—meaning they’re not intended to be consumed in a one-way fashion. They’re written closer to the level of detail that a software
engineer will get from a boss or client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04abe1627d08891407e1178e887bcb13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c5ff457e3b9062a94a32d45542c7d7/" rel="bookmark">
			Java中Comparable接口和Comparator比较器的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Comparable接口和Comparator比较器是实现将一个泛型为某个引用数据类型的集合容器中元素按一定顺序排序的两种方式，下面将对这两种方式进行讲解
一、首先定义一个学生类 public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } /** * 由于Set集合需要去重，所以当泛型传入这个Student类型的时候， * Student需要重写equals()和hashCode()两个方法来保证两个元素逻辑上的不同 * 逻辑上的不同就是说两个元素应该名字或者年龄这些属性不同就算作是不同对象，如果地址不同，但是名字年龄等所有属性都相同的话应该算作同一个对象） * 如果没有重写equals()和hashCode()方法的话，会造成去重失败 */ /** * equals()和hashCode()方法的重写可以借助IDEA的快捷键(alt+insert)来重写，get和set方法还有构造方法也可以 * 我这里就是借助IDEA自动生成的，但是一定要知道重写的原则是什么 * equals()方法重写原则： * 1、对称性：x,y非空，x.equals(y)和y.equals(x)返回值相同 * 2、自反性：x非空，x.equals(x)应该返回true * 3、传递性：x.equals(y)为true，y.equals(z)也为true，那x.equals(z)应该也为true * 4、一致性：对于非空x,y，只要对象的相关信息没有被修改，x.equals(y)多次调用应该始终返回相同的结果 * * @param o 比较另一个对象 * @return true/false表示是否为同一个对象 */ @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10c5ff457e3b9062a94a32d45542c7d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb4f8f548ba26b61e2120a968aa9450/" rel="bookmark">
			深度学习论文分享（八）Learning Event-Driven Video Deblurring and Interpolation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习论文分享（八）Learning Event-Driven Video Deblurring and Interpolation 前言Abstract1 Introduction2 Motivation2.1 Physical Model of Event-based Video Reconstruction2.2 Spatially Variant Triggering Threshold 3 Proposed Methods3.1 Network Architecture3.2 Loss Function 4 Experiment4.1 Implementation Details4.2 Experimental Results 5 Ablation Study5.1 Effectiveness of Physical-Based Framework5.2 Effectiveness of Dynamic Filtering5.3 Effectiveness of Previous Information5.4 Effectiveness of Frame Fusion 6 Concluding RemarksReferences and Interpolation) 前言 论文原文：https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123530681.pdf
论文代码：暂无
Title：Learning Event-Driven Video Deblurring and Interpolation
Authors：ongnan Lin1?, Jiawei Zhang2 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb4f8f548ba26b61e2120a968aa9450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e45ba2d1e93baa9e78075e82bee9163/" rel="bookmark">
			c&#43;&#43;结构体可以直接进行赋值吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 C++ 中，结构体可以直接进行赋值操作，它和基础数据类型一样，在声明时可以直接赋值，进行初始化，在同一结构体的不同对象之间，也可以直接赋值。
但是要注意一点，在结构体被赋值时，会执行结构体中每个类成员变量的拷贝构造函数，如果函数中存在动态分配的资源，则需要谨慎处理，以避免内存泄露，野指针等问题。
声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。
注意：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947246e471023f48d1fe378f1ff06eff/" rel="bookmark">
			Gradio使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与他人分享你的机器学习模型、API或数据科学工作流的最佳方式之一，就是创建一个交互式应用程序，让用户或同事可以在他们的浏览器中尝试演示,Gradio是创建提供了用非常方便的方式快速创建一个前端交互应用，那如何使用Gradio呢？因为用Gradio创建的所有前端交互应用，所以，需要按照Python环境，安装后可以下载VSCode作为IDE工具，环境安装后，pip install gradio后即可开始用gradio框架快速搭建一个前端应用。 下图是一个用gradio搭建的包含name，password等输入信息的前端应用，这里使用了gradio提供的Interface方法，Interface 是 Gradio 的主要高级类，它允许你在几行代码中围绕机器学习模型（或任何 Python 函数）创建一个基于 Web 的图形用户界面（GUI）/ 演示。你需要指定三个参数：（1）要为之创建 GUI 的函数，（2）所需的输入组件，以及（3）所需的输出组件。还可以使用其他参数来控制演示的外观和行为。使用gradio.Interface class的使用格式如下所示：
gradio.Interface(fn, inputs, outputs, ···) import gradio as gr def generate_human_message(username, password, sex, age): human = {} human["name"] = username human["password "] = password human["sex"] = "man" if sex == "Male" else "woman" human["age"] = age return list(human.values()) demo1 = gr.Interface(fn=generate_human_message, inputs=[ "text", "text", gr.Radio(["Male", "Female"], label="sex", info="choose sex"), gr.Slider(1, 100, value=20, label="age", info="show age")], outputs="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947246e471023f48d1fe378f1ff06eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eaa0b5808fb8f296423668a466cc3a0/" rel="bookmark">
			学习笔记230810--vue项目中get请求的两种传参方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 今天写了一个对象方式传参的get请求接口方法，发现没有载荷，ip地址也没有带查询字符串，数据也没有响应。
代码展示 错误分析 实际上这里的query是对象方式带参跳转的参数名，而get方法对象方式传参的参数名是parmas
解决方法 get请求有两种带参的方式
方式1：对象形式传参，参数名是params 方式2：查询字符串带参，添加到地址?后面 export function delUders(id){ return request({ url:'/system/users/list?'+id, method:'get' }) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee172e9434b6a80d3c9d1bd92ffa91d5/" rel="bookmark">
			c#对.ini文件的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		帮助类可以拿过去直接用
using System; using System.Collections.Generic; using System.Runtime.InteropServices; using System.Text; namespace Mdm.Lite.Common.Helpers { public static class IniHelper { // 声明INI文件的写操作函数 WritePrivateProfileString() [DllImport("kernel32")] private static extern long WritePrivateProfileString(string section, string key, string val, string filePath); // 声明INI文件的读操作函数 GetPrivateProfileString() [DllImport("kernel32", EntryPoint = "GetPrivateProfileString")] private static extern long GetPrivateProfileString(string section, string key, string def, StringBuilder retVal, int size, string filePath); [DllImport("kernel32", EntryPoint = "GetPrivateProfileString")] private static extern uint GetPrivateProfileStringA(string section, string key, string def, Byte[] retVal, int size, string filePath); /// &lt;summary&gt; /// 为某个节写入key /// 如果这个key已存在，那么久是更新此key /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee172e9434b6a80d3c9d1bd92ffa91d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa388913155a941a18c6a1896b2c21b/" rel="bookmark">
			【C语言】每日一题（除自身以外数组的乘积）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加链接描述，链接奉上
方法： 暴力循环:前缀积×后缀积（分组）: 暴力循环: 暴力循换真的是差生法宝，简单好懂，就是不实用，大多数的题目都会超过时间限制（无奈）
思路：
1.写一个除自身的数组乘积函数
2.利用for循环遍历数组，i作为循环变量，当遍历到i时，就求出除i以外的数组乘积
3.放入返回数组中
代码实现：
static int arr[100000]; int mul_self(int* nums, int numsSize,int i) //编写一个除自身的数组乘积函数 { int mul=1; for(int j=0;j&lt;numsSize;j++) { if(j!=i) mul*=nums[j]; } return mul; } int* productExceptSelf(int* nums, int numsSize, int* returnSize) { *returnSize=numsSize; int n=0; for(int i=0;i&lt;numsSize;i++) //循环遍历，求出每个除i外数组的乘积 { arr[n++]=mul_self(nums,numsSize,i); } return arr; } 但是此方法局限大，时间超出限制。
前缀积×后缀积（分组）: 思路：
根据题目提示，利用前缀积×后缀积即可得到答案，那么问题就演化为求前缀积与后缀积
创建两个数组，一个用来存放前缀积，另一个存放后缀积。
最后循环，将两者相乘，得到除了nums[i]外的数组乘积
代码实现：
static int ans[100000]; int* productExceptSelf(int* nums, int numsSize, int* returnSize) { int lsum[numsSize];//创建数组 int rsum[numsSize]; lsum[0]=1;//将边界赋值为1 rsum[numsSize-1]=1; for(int i = 1;i &lt; numsSize; i++)//求前缀积 { lsum[i]=lsum[i-1]*nums[i-1]; } for(int i = numsSize-2;i &gt;= 0;i--)//求后缀积 { rsum[i]=rsum[i+1]*nums[i+1]; } for(int i = 0;i&lt;numsSize;i++)//求结果数组 { ans[i]=lsum[i]*rsum[i]; } *returnSize=numsSize; return ans; } 欢迎纠错与讨论哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24056dd8d186238963e217d1390c4cce/" rel="bookmark">
			linux添加sht3x温湿度传感器驱动记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近拿到一块imx6ull板子，上面有一颗温湿度传感器sht30,需要读取其数值。本人能力有限，自己写驱动还有一点困难，好在 linux内核里自带了很多器件的驱动，只需要找到相关的驱动文件根据要求修改一下设备树、添加进内核里编译就可以。
目前新版本的linux都支持设备树，刚开始我认为只要找到内核里的相关驱动文件，根据匹配表里的属性添加好设备树就可以了。万万没想到，linux内核自带的sht3x驱动竟然不支持设备树，支持直接name比对，那就只能根据要求添加i2c_board_info信息了。
内核自带的驱动文件是kernel/drivers/hwmon/sht3x.c，打开文件找到如下位置：
该驱动支持两款温湿度传感器，我的板子上的是sht30，连接在i2c1接口，设备地址为0x44,所以添加i2c_board_info信息如下：
static struct i2c_board_info sht3x_i2c_board_info __initdata = { I2C_BOARD_INFO("sht3x", 0x44), }; 光添加了i2c_board_info信息还不够,还需要实例化i2c设备，根据sht3x驱动文档kernel/Documentation/hwmon/sht3x.rst介绍，
实例化方法需要参考kernel/Documentation/i2c/instantiating-devices.rst文档介绍，这个文档里介绍了多种实例化i2c接口的方法，经过测试有的方法不适用，我用了Method 2: Instantiate the devices explicitly。
需要在init函数中实例化，代码如下：
static int __init sht3x_init(void) { int ret = 0; struct i2c_adapter *adapter; adapter = i2c_get_adapter(0); i2c_new_client_device(adapter,&amp;sht3x_i2c_board_info); ret = i2c_add_driver(&amp;sht3x_i2c_driver); return ret; } 支持设备驱动文件部分就修改好了，接下来就是如何让这个驱动编译到内核了。打开驱动目录下的Makefile文件，如下：
通过文件可以知道要想编译sht3x驱动到内核里就需要让CONFIG_SENSORS_SHT3x编程y。所以有两种方法：
1.修改makefile文件，直接将CONFIG_SENSORS_SHT3x改成y,然后make一下，用新生成的zImage文件启动就可以了；
2.改配置文件，可以通过menuconfig修改
选中SHT3x这个选项，保存后重新make，用新生成的zImage文件启动就可以了。
或者打开.config文件进行修改，修改如下：
保存退出后重新make，用新生成的zImage文件启动就可以了。
好了，到此，SHT30驱动就添加成功了，可以直接通过hwmon进行读取数据了，文件在/sys/class/hwmon/，进去后会发现里面会有hwmon0 hwmon1 hwmon2等文件
可以通过ls -l命令查看详情，根据器件地址找到相应的器件驱动对应的文件，如下：
由上图可以知道sht3x的驱动对应的文件是hwmon1，进入hwmon1文件里可以看到很多属性文件，如下：
具体每一个属性对应的啥意思可以参考kernel/Documentation/hwmon/sht3x.rst具体介绍
可以通过cat指令一个一个参看相关属性的数值。
温度为29.362度。
其他的属性自己去探索吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/344c9e88ace5bf7a10f3d599689bd2e5/" rel="bookmark">
			Swiper10.2.0版本在vue3中的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简单使用示例 vue代码
&lt;template&gt; &lt;swiper :pagination="true" :modules="modules" class="mySwiper"&gt; &lt;swiper-slide&gt;Slide 1&lt;/swiper-slide&gt; &lt;swiper-slide&gt;Slide 2&lt;/swiper-slide&gt;&lt;swiper-slide&gt;Slide 3&lt;/swiper-slide&gt; &lt;swiper-slide&gt;Slide 4&lt;/swiper-slide&gt;&lt;swiper-slide&gt;Slide 5&lt;/swiper-slide&gt; &lt;swiper-slide&gt;Slide 6&lt;/swiper-slide&gt;&lt;swiper-slide&gt;Slide 7&lt;/swiper-slide&gt; &lt;swiper-slide&gt;Slide 8&lt;/swiper-slide&gt;&lt;swiper-slide&gt;Slide 9&lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;/template&gt; &lt;script setup&gt; // Import Swiper Vue.js components import { Swiper, SwiperSlide } from 'swiper/vue'; // Import Swiper styles import 'swiper/css'; import 'swiper/css/pagination'; import './style.css'; // import required modules import { Pagination } from 'swiper/modules'; const modules=[Pagination] &lt;/script&gt; style.css文件
#app { height: 100%; } html, body { position: relative; height: 100%; } body { background: #eee; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14px; color: #000; margin: 0; padding: 0; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/344c9e88ace5bf7a10f3d599689bd2e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d76442fa9986c8ebe117fbba2a26dd47/" rel="bookmark">
			ERROR:Quaternion has length close to zero... discarding as navigation goal解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：变量origation_w为0了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77b12472fa0e89790ce31a4f4fdea1d/" rel="bookmark">
			Java解决文件在线预览（kkFileView）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍 kkFileView为文件文档在线预览解决方案，该项目使用流行的spring boot搭建，易上手和部署，基本支持主流办公文档的在线预览，如doc,docx,xls,xlsx,ppt,pptx,pdf,txt,zip,rar,图片,视频,音频等等
在线体验 链接: https://file.kkview.cn/
使用 1、下载 Gitee地址 链接: https://gitee.com/kekingcn/file-online-preview
GitHub地址 链接: https://github.com/kekingcn/kkFileView
2、解压 3、启动后访问 链接: http://127.0.0.1:8012
http://127.0.0.1:8012 见到这个页面，说明启动成功
4、前端对接 4.1、需要用到 Base64 编码解码 链接: Base64 在线解码编码
4.2、预览 我这里就没有用本地运行了，大家本地运行的话，把协议、IP、端口改成自己的就可以
https://file.kkview.cn/onlinePreview?url=aHR0cHM6Ly93d3cuaG9uZ3d1LmNvbS93cC1jb250ZW50L3VwbG9hZHMvaW1hZ2VzLzIwMjIvMTEvMTMvOGZmNDY0MmZkZWIyNDQ0M2I4ODk3N2IyZmQ5ZWQ0ZTZfMzJvdmNvYnlsMTQucG5n 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059f42f1199b355f459673c9facddf47/" rel="bookmark">
			MySQL的mysql-bin.00xx binlog日志文件的清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 引言手工清理配置自动清理 引言 公司一个项目生产环境mysql数据盘占用空间增长得特别快，经过排查发现是开启了mysql的binlog日志。如果把binlog日志关闭，如果操作万一出现问题，就没有办法恢复数据，很不安全，只能开启。经查相关资料，binlog日志可以手工消除，也可以配置自动清理。
手工清理 如果binlog文件非常多，推荐使用purge命令予清除历史文件,可以清除某个序号以前的文件，也可以清理某个时间点以前的数据。
清理某个序号以前的binlog日志文件 purge binary logs to 'mysql-bin.000430'; mysql-bin.000429文件已被删除
清理某具时间点以前的binlog日志文件 purge binary logs before '2023-08-29 12:00:00'; 可以见把2023-08-29 12:00:00之前的binlog日志文件全部删除了
配置自动清理 配置
修改配置文件my.cnf文件： vim /etc/my.cnf #在[mysqld]标签内增加如下内容 log-bin=mysql-bin binlog_format=mixed max_binlog_size=1024M expire_logs_days=10 expire_logs_days=0：
这里的值如果为0，表示所有binlog日志永久都不会失效，不会自动删除；
这里的值如果为30，表示只保留最近30天。
温馨提示：
修改保存后，以下3种情况才会生效
1)当binlog大小超过max_binlog_size
2)手动执行flush logs
3)重新启动
查看binlog过期时间 show variables like 'expire_logs_days'; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/55/">«</a>
	<span class="pagination__item pagination__item--current">56/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/57/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>