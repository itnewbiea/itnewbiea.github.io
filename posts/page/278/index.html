<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb894659fb7d9cfada8ea3bbca6e9c05/" rel="bookmark">
			Gtk透明窗口全攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用自： http://xy0811.spaces.live.com/blog/cns!F8AECD2A067A6B17!1256.entry
Gtk透明窗口全攻略 如图所示，左边是普通的 ubuntu 桌面，右边是我建立的三个 gtk 特殊窗口，其中包含了：异形窗口（上），透明窗体（中），不同区域不同透明度的窗口（下）。基本包括了各种特殊窗口的需求，而复杂程度和依赖工具又各有不同，下面是实现的代码及说明 1． 环境说明 ubuntu 8.04 系统，安装 glib-dev 和 cairo 包 2． 异形窗口 a) 原理 异形窗口利用蒙板（ mask ）实现，蒙板的数据从图片获得，每一点只有透明和不透明两种状态，不透明区域显示该窗口的背景，透明区域显示其后桌面或其它应用 b) 效果 可实现异形窗口，但不支持半透明，所以弧形边缘看起来不够平滑。 c) 依赖 gtk 的基本功能，一般 gtk 都可以支持 #include &lt;gtk/gtk.h&gt; int main(int argc, char *argv[]) { GtkWidget *window = NULL; GdkPixbuf *pixbuf = NULL; GdkBitmap *bitmap = NULL; GdkPixmap *pixmap = NULL; gtk_init(&amp;argc, &amp;argv); window = gtk_window_new(GTK_WINDOW_TOPLEVEL); gtk_window_set_decorated(GTK_WINDOW(window), FALSE); // 设置无边框 gtk_widget_set_app_paintable(window, TRUE); gtk_widget_realize(window); pixbuf = gdk_pixbuf_new_from_file("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb894659fb7d9cfada8ea3bbca6e9c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65a96ce873b785a2e806cee05efa996/" rel="bookmark">
			ab,webbench,Siege,http_load,Web Application Stress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压力测试工具
----------------------------------------------------------------------------
Http_load
http://baike.baidu.com/view/4137750.htm
http_load性能测试工具
http://blog.19lou.com/11438336/viewspace-2956557
压力测试工具集合【ab,webbench,Siege,http_load,Web Application Stress】
http://hi.baidu.com/sky9812/item/fc120bad088036776dd45562 Web服务器性能/压力测试工具http_load、webbench、ab、Siege使用教程
http://blog.licess.org/http_load-webbench-ab-siege/ 三种web性能压力测试工具http_load webbench ab
http://blog.sina.com.cn/s/blog_490eec930100d0fr.html Linux下四款Web服务器压力测试工具（http_load、webbench、ab、siege）介绍----------------------------------------------------------------------------
一、http_load
程序非常小，解压后也不到100K
http_load以并行复用的方式运行，用以测试web服务器的吞吐量与负载。但是它不同于大多数压力测试工具，它可以以一个单一的进程运行，一般不会把客户机搞死。还可以测试HTTPS类的网站请求。
下载地址：http://soft.vpser.net/test/http_load/http_load-12mar2006.tar.gz
安装
#tar zxvf http_load-12mar2006.tar.gz
#cd http_load-12mar2006
#make &amp;&amp; make install
&lt;!--more--&gt;
命令格式：http_load -p 并发访问进程数 -s 访问时间 需要访问的URL文件
参数其实可以自由组合，参数之间的选择并没有什么限制。比如你写成http_load -parallel 5 -seconds
300 urls.txt也是可以的。我们把参数给大家简单说明一下。
-parallel 简写-p ：含义是并发的用户进程数。
-fetches 简写-f ：含义是总计的访问次数
-rate 简写-p ：含义是每秒的访问频率
-seconds简写-s ：含义是总计的访问时间
准备URL文件：urllist.txt，文件格式是每行一个URL，URL最好超过50－100个测试效果比较好.文件格式如下：
http://www.vpser.net/uncategorized/choose-vps.html
http://www.vpser.net/vps-cp/hypervm-tutorial.html
http://www.vpser.net/coupons/diavps-april-coupons.html
http://www.vpser.net/security/vps-backup-web-mysql.html
例如：
http_load -p 30 -s 60 urllist.txt
参数了解了，我们来看运行一条命令来看看它的返回结果
命令：% .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65a96ce873b785a2e806cee05efa996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba270972bf69e469bb4190b320bce9c5/" rel="bookmark">
			PQ分区魔术师图解教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PQ分区魔术师图解教程 PartitionMagic， 简称PQ、PM。是诺顿公司出品的磁盘分区管理软件。它可以实现在Windows里不影响数据的情况下进行磁盘分区调节，重新分区，分区大小调节，合并分区，转换磁盘分区格式等功能。 但使用时有一定的危险性，如果操作方法不当，可能造成分区丢失，资料丢失，所以在操作它的时候，一定要很清楚的你自己在干什么，需要很熟练的操作技巧来操作它，不然到最后搞的数据丢失，磁盘丢失，才知道他的厉害，那就已时为晚了。它有DOS版和Windows版两种，一般DOS版用在裸机的分区管理，Windows版在Windows界面下操作完成重新分区，分区大小调节，合并分区，转换磁盘分区格式等功能。 下面讲解一下用法： 一、用DOS版给裸机分区 DOS版PQ在很多GHOST系统盘上都有，启动界面如下： 下面进行分区，分区思路：80G硬盘，分三个区，c盘10G，D盘30G，E盘为余下部分。 单击作业--建立 设置主要分区（即C盘） 设置分区格式 设置分区大小 设置完成后点确定，完成 C 盘分区 &lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt; 接着同样步骤，划分逻辑分区（即 D 盘和 E 盘） 分好所有分区后，一定要激活主分区。很多人忘了这步，结果造成无法启动 。 激活主分区：选定 C 盘，然后作业 -- 进阶 -- 设定为作用 确定后，点击执行，使刚才所有设置生效 这样就完成分区工作了，装系统吧。 PQ 中文 DOS 版在很多 GHOST 系统盘上都有，你也可以下载来，考入你制作的 U 盘启动盘来进行操作， U 盘启动盘制作方法见本空间《 U盘启动盘制作攻略 》 转载于:https://blog.51cto.com/simeixiaofeng/210611
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54aac351bbb94948c617a742227e8673/" rel="bookmark">
			Websphere 优化文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WAS配置概要 描述
参数
缺省值
设置原则
JVM堆栈
服务器 &gt; 应用程序服务器 &gt; server1 &gt; Java 虚拟机
无
最小值为总内存1/8,最大值为总内存1/2至3/4
连接池
资源 &gt; JDBC提供程序 &gt; (JDBC提供程序名) &gt; 数据源&gt; (数据源名) &gt; 连接池属性
最小连接数：10
最大连接数：50
通过TPV监控连接池的大小变化曲线设置
语句高速缓存
资源 &gt; JDBC提供程序 &gt; (JDBC提供程序名) &gt; 数据源&gt; (数据源名) &gt; WebSphere Application Server 数据源属性 &gt; 语句高速缓存大小
10
比如实际情况下CPU利用率很高，并且表明有瓶颈，performance advisors报警提示prepare statement缓存丢弃率较高，这说明默认的值(10)太小，需要增加该值大小以提高吞吐
JMS池
资源JMS提供程序缺省消息传递JMS激活规范激活规范名
最大批次大小：无
最大并发端点数：无
根据实际情况分析
Web容器线程池
服务器 &gt; 应用程序服务器 &gt; (服务器名) &gt;
线程池 &gt; WebContainer
最小大小：10
最大大小：50
通过TPV监控Web容器线程池最大值（在可接受的相应时间范围内），根据此值进行设置
EJB缓存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54aac351bbb94948c617a742227e8673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b5461f162193e94fbd9cb8d32c7c8b/" rel="bookmark">
			org.apache.commons.collections.bidimap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 org.apache.commons.collections.bidimap 实现类： 基本类： DualHashBidiMap： 所谓BidiMap，直译就是双向Map，可以通过key找到value，也可以通过value找到key，因为我们除了需 要通过代码找到名称之外，往往也需要处理用户输入的名称，然后获取其代码。需要注意的是BidiMap当 中不光key不能重复，value也不可以。 MultiHashMap： 所谓MultiMap，就是说一个key不在是简单的指向一个对象，而是一组对象，add()和remove()的时候跟 普通的Map无异，只是在get()时返回一个Collection，利用MultiMap，我们就可以很方便的往一个key上 放数量不定的对象，也就实现了一对多。 DualTreeBidiMap: 内部采用两个TreeMap()实现，所以同一个key和value只能在其中存在一次，内部优化，同一对象并没有 存储两次 TreeBidiMap：加入中的元素许实现comparable接口，顺序将按照key，value同时的自然排序来排列。当 需要key-value作为查询的时候，该工具可以用到，内部实现仍然是两个TreeMap，但效率高于TreeMap //包装类： LazyMap： 所谓LazyMap，意思就是这个Map中的键/值对一开始并不存在，当被调用到时才创建. 我们这样来理解：我们需要一个Map，但是由于创建成员的方法很“重”（比如数据库访问）， 或者我们只有在调用get()时才知道如何创建，或者Map中出现的可能性很多很多， 我们无法在get()之前添加所有可能出现的键/值对， 我们觉得没有必要去初始化一个Map而又希望它可以在必要时自动处理数据 。。。 还有许多为实现特定功能实现的包装类，类似buffer 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9c60f3322ca1dc545956a0c79fccfa/" rel="bookmark">
			LoadRunner常见问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自51testing 1.LoadRunner录制脚本时为什么不弹出IE浏览器？ 当一台主机上安装多个浏览器时， LoadRunner录制脚本经常遇到不能打开浏览器的情况，可以用下面的方法来解决。 启动浏览器，打开Internet选项对话框，切换到高级标签，去掉“启用第三方浏览器扩展（需要重启动）”的勾选，然后再次运行VuGen即可解决问题 提示：通常安装Firefox等浏览器后，都会勾选上面得选项，导致不能正常录制。因此建议运行LoadRunner得主机上保持一个干净的测试环境。 2.录制Web脚本时，生成的脚本中存在乱码该如何解决？ 录制脚本前，打开录制选项配置对话框Record-Options，进入到Advanced标签，先勾选“Support charset”，然后选择中支持UTF-8。再次录制，就不会出现中文乱码问题了。 3.HTML-based script与URL-based script的脚本有什么区别？ 使用“HTML-based script”的模式录制脚本，VuGen为用户的每个HTML操作生成单独的步骤，这种脚本看上去比较直观；使用“URL-based script”模式录制脚本时，VuGen可以捕获所有作为用户操作结果而发送到服务器的HTTP请求，然后为用户的每个请求分别生成对应方法。 通常，基于浏览器的Web应用会使用“HTML-based script”模式来录制脚本；而没有基于浏览器的Web应用、Web应用中包含了与服务器进行交互的Java Applet、基于浏览器的应用中包含了向服务器进行通信的JavaScript/VBScript代码、基于浏览器的应用中使用了HTTPS安全协议，这时使用“URL-based script”模式进行录制。 4.为什么脚本中添加了检查方法Web-find，但是脚本回放时却没有执行？ 由于检查点功能会耗费一定的资源，因此LoadRunner默认关闭了对文本及图像的检查。要想开启检查功能，必须修改运行时的配置Run-time Setting。 进入“Run-time Setting”对话框，依次进入“Internet Protocol→Preferences”，勾选Checks下的“Enable Image and text check”选项即可。 检查执行结果时推荐使用web_reg_find方法。 5.运行时的Pacing设置主要影响什么？ Pacing主要用来设置重复迭代脚本的间隔时间。共有三种方法：上次迭代结束后立刻开始、上次迭代结束后等待固定时间、按固定或随机的时间间隔开始执行新的迭代。 根据实际需要设置迭代即可。通常，没有时间间隔会产生更大的压力。 6.运行时设置Log标签中，如果没有勾选“Enable logging”，则手工消息可以发送吗？ Enable logging选项仅影响自动日志记录和通过lr_log_message发送的消息。即使没有勾选，虚拟用户脚本中如果使用lr_message、lr_output_message、lr_error_message,仍然会记录其发出的消息。 7.LoadRunner 8.0版本的VuGen在录制Web Services协议的脚本时一切正常，而回放时报出错误提示“Error：server returned an incorrectly formatted SOAP response”。这时说明原因引起的？ 造成这种情况的主要原因是LoadRunner 8.0的VuGen在录制Web Service协议的脚本时存在一个缺陷：如果服务器的操作系统是中文的，VuGen会自动将WSDL文件的头改为&lt;?xml version=”1.0” encoding=”zh_cn”?&gt;，因此会有上面的错误提示。 解决方法：把“LR80WebservicesFPI_setup.exe”和“lrunner_web_sevices_path_1.exe”两个补丁打上即可解决。 8.VuGen支持Netscape的客户证书吗？ 不支持。目前的VuGen 8.0版本中仅支持Internet Explorer的客户端证书。录制脚本时可以先从Netscape中导出所需的证书，然后将其导入到Internet Explorer中，并确保以相同的顺序导出和导入这些证书。而且，在每台将要录制或运行需要证书的Web Vuser脚本的计算机上都要重复执行前面的过程。 9.VuGen会修改录制浏览器中的代理服务器设置吗？ 会修改。在开始录制基于浏览器的Web Vuser脚本时，VuGen首先会启动指定的浏览器。然后，VuGen会指示浏览器访问VuGen代理服务器。为此，VuGen会修改录制浏览器上的代理服务器设置。默认情况下，VuGen会立即将代理服务器设置更改为Localhost:7777。录制之后，VuGen会将原始代理服务器设置还原到该录制浏览器中。因此，在VuGen进行录制的过程中，不可以更改代理服务器设置，否则将无法正常进行。 10.在LoadRunner脚本如何输出当前系统时间？ LoadRunner提供了char *ctime(const time_t *time)函数，调用参数为一个Long型的整数指针，用于存放返回时间的数值表示。 调用语句与返回值如下示例： typedef long time_t;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c9c60f3322ca1dc545956a0c79fccfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcd3a42c78c235b6973ec315edf2ec1/" rel="bookmark">
			使用PM8.05为系统分区扩大容量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
笔记本买了3年多了，系统盘在最初分配10G，当时估计能满足需要。
期间还原了很多次，都没有扩张系统分区的容量。
而，现在呢，系统分区的空间不断被操作系统以及必要的系统程序占据，导致很慢，系统运行也吃力的很。
又不想随便还原系统（这才是主要因素）
追究原因，在于操作系统的不断长胖，而系统分区的小容量，导致没有过于的空间备用。从而导致其他问题的衍生。
扩容，是必要的。
为了满足需求和以后的，个人分区的建议：20G+35G+25G，总共80G。
怎么扩容呢？
1、不影响当前系统的运行，就是说扩容后，系统分区仍然能运行原有的系统，而不需要还原。
2、原有的数据不能丢失。
那么，采用fdisk之类的，就完全不行了。查询了，PM8.0以上能搞定。
准备工具：
1、带有PM8.0的启动光盘
2、移动硬盘或局域网电脑硬盘
准备工作：
1、把所有非系统分区的数据按照原始的排列顺序直接拷贝到移动硬盘里
备注：拷贝中，有大于3G的数据需要小心了。如果目标盘和源盘都是Ntfs格式，没有什么问题。否则的话，会拷贝不起；这种情况下，需要先分割再拷贝。
另外建议：目标盘的格式最好是NTFS格式。
2、一般现在装好的系统，在不断使用中会有很多启动项。一般有360，那么使用这个工具把一些非系统盘下的启动项暂时关闭了。
扩容系统分区：
1、放入启动光盘，重起后并进入PM8的操作界面。
2、先把非系统分区全部删除
3、然后选择系统分区，调整大小到20G
4、再次，把剩下的按照35/25G来分配，成两个逻辑分区，保存应用
5、应用完后，重起
扩容后的效果：
重起后，进入系统，一切都正常运行。D/E两盘内容全无。C盘系统盘，容量扩了，数据还是原来的数据。
现在该把数据拷贝回来就是了，当然你可以慢慢整理后再拷贝回来。
备注：问题有一个，我只描述自己的情况。我的卡巴是安装在D盘的，在正常系统下，怎么也拷贝不回来，原因在于C盘的卡巴服务安全保护了。怎么办？简单，把这个卡巴的目录暂时拷贝到其他目录里。重起，进入安全模式，再把已拷贝的卡巴目录还原到应改的目录下，再重起进入正常模式，卡巴运行正常，没有问题。
最后启动360，把原来关闭的启动项启动起来就ok了
转载于:https://www.cnblogs.com/GoGoagg/archive/2009/07/25/1530889.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48c32a268083729b740195b4f2cdbba/" rel="bookmark">
			&lt;c:forEach&gt;用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;c:forEach&gt; &lt;c:forEach&gt; 为循环控制，它可以将集合(Collection)中的成员循序浏览一遍。运作方式为当条件符合时，就会持续重复执行&lt;c:forEach&gt;的本体内容。 语法 语法1：迭代一集合对象之所有成员 &lt;c:forEach [var="varName"] items="collection" [varStatus="varStatusName"] [begin="begin"] [end="end"] [step="step"]&gt; 本体内容 &lt; /c:forEach&gt; 语法2：迭代指定的次数 &lt;c:forEach [var="varName"] [varStatus="varStatusName"] begin="begin" end="end" [step="step"]&gt; 本体内容 &lt;/c:forEach&gt; 标签具有以下一些属性： var：迭代参数的名称。在迭代体中可以使用的变量的名称，用来表示每一个迭代变量。类型为String。 items：要进行迭代的集合。对于它所支持的类型将在下面进行讲解。 varStatus：迭代变量的名称，用来表示迭代的状态，可以访问到迭代自身的信息。 begin：如果指定了items，那么迭代就从items[begin]开始进行迭代；如果没有指定items，那么就从begin开始迭代。它的类型为整数。 end：如果指定了items，那么就在items[end]结束迭代；如果没有指定items，那么就在end结束迭代。它的类型也为整数。 step：迭代的步长。 标签的items属性支持Java平台所提供的所有标准集合类型。此外，您可以使用该操作来迭代数组（包括基本类型数组）中的元素。它所支持的集合类型以及迭代的元素如下所示： java.util.Collection：调用iterator()来获得的元素。 java.util.Map：通过java.util.Map.Entry所获得的实例。 java.util.Iterator：迭代器元素。 java.util.Enumeration：枚举元素。 Object实例数组：数组元素。 基本类型值数组：经过包装的数组元素。 用逗号定界的String：分割后的子字符串。 javax.servlet.jsp.jstl.sql.Result：SQL查询所获得的行。 不论是对整数还是对集合进行迭代，的varStatus 属性所起的作用相同。和var属性一样，varStatus用于创建限定了作用域的变量（改变量只在当前标签体内起作用）。不过，由varStatus属性命名的变量并不存储当前索引值或当前元素，而是赋予javax.servlet.jsp.jstl.core.LoopTagStatus类的实例。该类包含了一系列的特性，它们描述了迭代的当前状态，如下这些属性的含义如下所示： current：当前这次迭代的（集合中的）项。 index：当前这次迭代从0开始的迭代索引。 count：当前这次迭代从1开始的迭代计数。 first：用来表明当前这轮迭代是否为第一次迭代，该属性为boolean类型。 last：用来表明当前这轮迭代是否为最后一次迭代，该属性为boolean类型。 begin：begin属性的值。 end：end属性的值 step：step属性的值 下面就来看一个个基本的例子，表格隔行背景色变化 xml 代码 &lt;c:forEach var="item" items="${contents}" varStatus="status"&gt; &lt;tr &lt;c:if test="${status.count%2==0}"&gt;bgcolor="#CCCCFE"&lt;/c:if&gt; align="left"&gt; xxx &lt;/tr&gt; &lt;/c:forEach&gt; 限制 ·假若有begin属性时，begin必须大于等于 0 ·假若有end属性时，必须大于begin ·假若有step属性时，step必须大于等于0 Null 和 错误处理 ·假若items为null时，则表示为一空的集合对象 ·假若begin大于或等于items时，则迭代不运算 说明 如果要循序浏览一个集合对象，并将它的内容显示出来，就必须有items属性。 范例 下面的范例 Core_forEach.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48c32a268083729b740195b4f2cdbba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24b8acb537f644b7cd9f50369de695c/" rel="bookmark">
			模型和策略概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务策略: 模型和策略概述 学习三种事务模型以及使用它们的事务策略
&lt;script type="text/javascript"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;&lt;/script&gt; 级别： 中级
Mark Richards, 总监和高级技术架构师, Collaborative Consulting, LLC
2009 年 7 月 14 日
混淆事务模型与事务策略是一个常见的错误。本系列关于 事务策略 的第二篇文章将概述 Java™ 平台支持的三种事务模型，并介绍使用这些模型的四种主要事务策略。通过使用 Spring Framework 和 Enterprise JavaBeans (EJB) 3.0 规范中的示例，Mark Richards 将解释事务模型的运行原理以及它们如何形成开发各种事务策略（从基本的事务处理到高速事务处理系统）的基础。 开发人员、设计人员和架构师经常会混淆事务模型 与事务策略。我经常会让与客户接触的架构师和技术总监描述他们项目的事务策略。我通常会获得三种回应。有时，他们会说 “我们实际上并未在应用程序中使用事务。”另一些时候，我会听到迷惑的回答：“我不明白你的意思。”但是，我也会遇到非常自信的回答：“我们使用声明式事务。”在本文中，术语声明式事务 描述的是一个事务模型，但它绝不是一种事务策略。
关于本系列
事务将改善您数据的质量、完整性以及一致性，并且让您的应用程序更加可靠。在 Java 应用程序中实现成功的事务处理并不是一项轻松的任务，它是一项与编写代码相关的设计工作。 在这个新的 系列 中，Mark Richards 将指导您设计一个有效的事务策略，它适用于各种用例，从简单的应用程序到高级性能事务处理。
Java 平台支持的三种事务模型包括：
Local Transaction 模型 Programmatic Transaction 模型 Declarative Transaction 模型 这些模型描述事务在 Java 平台中的基本运行方式，以及它们是如何实现的。但是，它们仅提供了事务处理的规则和语义。如何应用事务模型则完全由您决定。举例来说，应该如何在 REQUIRED 和 MANDATORY 事务属性之间做出选择？您应该在何时何种情况下指定事务回滚指令？您应该在何时考虑 Programmatic Transaction 模型与 Declarative Transaction 模型的优劣？您应该如何优化高性能系统的事务？事务模型本身无法回答这些问题。您必须通过开发自己的事务策略或采用本文介绍的四种主要事务策略之一来解决它们。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24b8acb537f644b7cd9f50369de695c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c780c9f43564e40f5a4451f28441e59/" rel="bookmark">
			HTML学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Html (1天) 一、Html简介 HTML 是一种标记语言 忽略大小写，语法宽松 使用 HTML 标记和元素，可以： 控制页面和内容的外观 发布联机文档 使用 HTML 文档中插入的链接检索联机信息 创建联机表单，收集用户的信息、执行事务等等 插入动画 开发帮助文件 HTML 标记的格式组成： &lt;ELEMENT ATTRIBUTE = value&gt; ELEMENT: 元素 - 标识标记 ATTRIBUTE: 属性 - 描述标记 value: 值 - 分配给属性的内容 二、超链接 &lt;A HREF = protocol://host.domain:port/path/filename&gt; Hypertext &lt;/A&gt; Protocol 协议类型 http –超文本传输协议&lt;a href="http://127.0.0.1:8080/shopcart/index.html"&gt; gopher –搜索文件 telnet –打开 telnet会话 ftp –文件传输协议 mailto –发送电子邮件 &lt;A HREF="mailto:daillow@gmail.com"&gt;电子邮件连接 Host.domain 服务器的 Internet 地址 Port 目标服务器的端口号 Hypertext 用户必须单击才能激活链接的文本或图像 三、Html的基本标记 标题标记 &lt;h1&gt;~&lt;h6&gt; 标题标记，可显示六种大小的标题(1最大，6最小) 段落级标记 &lt;ADDRESS&gt; 可包含：到主页的链接,搜索字符串功能,版权信息,文档的作者、地址、签名等信息 &lt;BLOCKQUOTE&gt; 显示文档中的引用文本。用于较长的引用且显示为缩进式段落。 &lt;PRE&gt; 此元素用于预定义文本的格式。文本在浏览器中显示时遵循在HTML源文档中定义的格式。 块标记 &lt;SPAN&gt;定义段落内的内容块； &lt;DIV&gt;可以定义跨段落的内容块 字符级标记 (见下面的语法大全，字体效果) 列表 &lt;li type=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c780c9f43564e40f5a4451f28441e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e568014b27618f2e72c118c6f7999d/" rel="bookmark">
			学习OpenCascade的一点体会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OpenCascade 是一个开源的 3D 造型系统，类似于 ACIS ，但功能相当 ACIS 则要弱很多了。 OpenCascade 包括了曲面造型和实体造型功能、显示功能、数据交换功能等。 OpenCascade 是提供了比较强的实体造型功能，支持非规则实体。 其实体造型功能包括： 基本实体（球、圆柱、圆锥等）的构造 实体的 boolean 运算：并、交、差 拉伸、旋转生成实体 抽壳功能 扫掠功能 放样功能 倒圆角、倒直角功能 实体偏移功能 面缝合成体功能 补面功能 等等。 其曲线、曲面功能也很丰富。 其显示功能包括了：曲线、曲面和实体的网格剖分、消隐显示、交互功能等。 数据交换模块包括了： IGES 和 STEP 文件的导入和导出，其中 STEP 主要支持 step 203 和 step 214 。 具体的结构图参见： http://www.opencascade.org/ex/images/490_techshema2.gif
（上图采自 www.opencascade.org ） Foundation Classes 包含了基本的底层功能。 Modeling Data 包含了表示 2D 和 3D 几何和拓朴模型的数据结构（类）。 Modeling algorithms 包含了大量的拓朴算法和几何算法。 如果仅仅使用 Opencascade 中的算法，上述三个模块可以单独拿出来使用。 Mesh 包含了模型对象的网格化算法等。 Visualization 包含了显示模型对象和模型对象的选择功能，一个基于 OpenGL 的显示系统。 OpenCascade 是一个庞大的系统，内容异常丰富，对于无论是学习图形学、计算几何、曲线曲面造型、实体造型的人来说，都是一个很好的参考资料，可以参考和借鉴其中一些算法的实现，加深对一些理论知识的理解。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6153d1b69404ae60fa04b59510cad04c/" rel="bookmark">
			C# WinForm中将Form显示在Panel中(C#)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在做WinForm的程序时,总是要弹出一些窗体,但弹出窗体看起来效果都不是很好,特别是弹出的窗体很多时,这时候就会影响整个软件的用户体验.所以还是要尽量的避免弹出窗体.
我们可以用这样的方法来解决此问题,将父窗体作为容器,将字窗体显示到父窗体中,而不是作为弹出窗体.
将弹出窗体显示在父窗体中,可在父窗体中加入一个Panel(或其他容器控件),然后将要弹出的窗体作为Panel的控件显示到Panel上.但此处要设置子窗体的两个属性:
1.TopLevel,获取或设置一个值，该值指示是否将窗体显示为顶级窗口。
2.FormBorderStyle,获取或设置窗体的边框样式。
将前者设为false,后者设为System.Windows.Forms.FormBorderStyle.None.
具体代码可参考如下:
pnlOPContainer.Controls.Clear();//移除所有控件
FrmAddUser frmAddUser = new FrmAddUser();
frmAddUser.TopLevel = false;
frmAddUser.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
pnlOPContainer.Controls.Add(frmAddUser);
frmAddUser.Show();
这样一来,就避免了弹出窗体带来不好的用户体验了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ade3b70e46c1aa43e92053a81f114c0/" rel="bookmark">
			一些SQLite不支持的SQL语法，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 TOP
这是一个大家经常问到的问题，例如在SQLSERVER中可以使用如下语句来取得记录集中的前十条记录：
SELECT TOP 10 * FROM [index] ORDER BY indexid DESC;
但是这条SQL语句在SQLite中是无法执行的，应该改为：
SELECT * FROM [index] ORDER BY indexid DESC limit 0,10;
其中limit 0,10表示从第0条记录开始，往后一共读取10条
2 创建视图（Create View）
SQLite在创建多表视图的时候有一个BUG，问题如下：
CREATE VIEW watch_single AS SELECT DISTINCTwatch_item.[watchid],watch_item.[itemid] FROM watch_item;
上面这条SQL语句执行后会显示成功，但是实际上除了
SELECT COUNT(*) FROM [watch_single ] WHERE watch_ single.watchid = 1;
能执行之外是无法执行其他任何语句的。其原因在于建立视图的时候指定了字段所在的表名，而SQLite并不能正确地识别它。所以上面的创建语句要改为：
CREATE VIEW watch_single AS SELECT DISTINCT [watchid],[itemid] FROM watch_item;
但是随之而来的问题是如果是多表的视图，且表间有重名字段的时候该怎么办？
3 COUNT（DISTINCT column）
SQLite在执行如下语句的时候会报错：
SELECT COUNT(DISTINCT watchid) FROM [watch_item] WHERE watch_item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ade3b70e46c1aa43e92053a81f114c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467f133debf31fec9efb230cedfd4460/" rel="bookmark">
			java生成UUID通用唯一识别码 (Universally Unique Identifier)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UUID含义是通用唯一识别码 (Universally Unique Identifier)，这 是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部份。UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。目前最广泛应用的 UUID，即是微软的 Microsoft's Globally Unique Identifiers (GUIDs)，而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。
以下是具体生成UUID的例子：
import java.util.UUID; public class UUIDGenerator { public UUIDGenerator() { } public static String getUUID() { UUID uuid = UUID.randomUUID(); String str = uuid.toString(); // 去掉"-"符号 String temp = str.substring(0, 8) + str.substring(9, 13) + str.substring(14, 18) + str.substring(19, 23) + str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/467f133debf31fec9efb230cedfd4460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6fa9bba198ed46d29ab4dfb31cf4c88/" rel="bookmark">
			Oracle下载地址备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下ORACLE 10gR2的软件下载地址，备用。
下载OTN上的这些软件，你需要一个OTN免费帐号，不过如果通过迅雷进行下载，就不用登陆OTN了：
Oracle Database 10g Release 2 (10.2.0.1.0) Enterprise/Standard Edition for Microsoft Windows (32-bit)
http://download.oracle.com/otn/nt/oracle10g/10201/10201_database_win32.zip http://download.oracle.com/otn/nt/oracle10g/10201/10201_client_win32.zip http://download.oracle.com/otn/nt/oracle10g/10201/10201_clusterware_win32.zip http://download.oracle.com/otn/nt/oracle10g/10201/10201_gateways_win32.zip Oracle Database 10g Release 2 (10.2.0.1.0) Enterprise/Standard Edition for Microsoft Windows (x64)
http://download.oracle.com/otn/nt/oracle10g/10201/102010_win64_x64_database.zip http://download.oracle.com/otn/nt/oracle10g/10201/102010_win64_x64_client.zip http://download.oracle.com/otn/nt/oracle10g/10201/102010_win64_x64_clusterware.zip Oracle Database 10g Release 2 (10.2.0.1.0) Enterprise/Standard Edition for Linux x86
http://download.oracle.com/otn/linux/oracle10g/10201/10201_database_linux32.zip http://download.oracle.com/otn/linux/oracle10g/10201/10201_client_linux32.zip http://download.oracle.com/otn/linux/oracle10g/10201/10201_gateways_linux32.zip Oracle Database 10g Release 2 (10.2.0.1.0) Enterprise/Standard Edition for Linux x86-64
http://download.oracle.com/otn/linux/oracle10g/10201/10201_database_linux_x86_64.cpio.gz http://download.oracle.com/otn/linux/oracle10g/10201/10201_client_linux_x86_64.cpio.gz http://download.oracle.com/otn/linux/oracle10g/10201/10201_clusterware_linux_x86_64.cpio.gz http://download.oracle.com/otn/linux/oracle10g/10201/10201_gateways_linux_x86_64.cpio.gz Oracle Database 10g Release 2 (10.2.0.1.0) Enterprise/Standard Edition for AIX5L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6fa9bba198ed46d29ab4dfb31cf4c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21cd789047712a4bdc4966795b0e609/" rel="bookmark">
			jstl fn 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSTL使用表达式来简化页面的代码，这对一些标准的方法，例如bean的getter/setter方法，请求参数或者context以及session中的数据的访问非常方便，但是我们在实际应用中经常需要在页面调用对象的某些方法，例如我需要调用字符串的length方法来获取字符串的长度时，在以往的开发过程中我们必须把对象先转为String类，然后在调用其length方法，这样的代码繁琐而且容易出错。 因此JSTL内置了几个用于字符串操作的方法，可以直接在表达式中使用，大大的简化了代码，提供代码的可读性。在JSTL的表达是中要使用一个函数，其格式如下
${ns:methodName(args....)}
在使用这些函数之前必须在JSP中引入标准函数的声明
&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %&gt;
下面是JSTL中自带的方法列表以及其描述
函数名函数说明使用举例fn:contains判断字符串是否包含另外一个字符串&lt;c:if test="${fn:contains(name, searchString)}"&gt;fn:containsIgnoreCase判断字符串是否包含另外一个字符串(大小写无关)&lt;c:if test="${fn:containsIgnoreCase(name, searchString)}"&gt;fn:endsWith判断字符串是否以另外字符串结束&lt;c:if test="${fn:endsWith(filename, ".txt")}"&gt;fn:escapeXml把一些字符转成XML表示，例如&lt;字符应该转为&amp;lt;${fn:escapeXml(param:info)}fn:indexOf子字符串在母字符串中出现的位置${fn:indexOf(name, "-")}fn:join将数组中的数据联合成一个新字符串，并使用指定字符格开${fn:join(array, ";")}fn:length获取字符串的长度，或者数组的大小${fn:length(shoppingCart.products)}fn:replace替换字符串中指定的字符${fn:replace(text, "-", "&amp;#149;")}fn:split把字符串按照指定字符切分${fn:split(customerNames, ";")}fn:startsWith判断字符串是否以某个子串开始&lt;c:if test="${fn:startsWith(product.id, "100-")}"&gt;fn:substring获取子串${fn:substring(zip, 6, -1)}fn:substringAfter 获取从某个字符所在位置开始的子串
${fn:substringAfter(zip, "-")}fn:substringBefore获取从开始到某个字符所在位置的子串${fn:substringBefore(zip, "-")}fn:toLowerCase转为小写${fn.toLowerCase(product.name)}fn:toUpperCase转为大写字符${fn.UpperCase(product.name)}fn:trim去除字符串前后的空格${fn.trim(name)} 函数
描述
fn:contains(string, substring)
如果参数string中包含参数substring，返回true
fn:containsIgnoreCase(string, substring)
如果参数string中包含参数substring（忽略大小写），返回true
fn:endsWith(string, suffix)
如果参数 string 以参数suffix结尾，返回true
fn:escapeXml(string)
将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回
fn:indexOf(string, substring)
返回参数substring在参数string中第一次出现的位置
fn:join(array, separator)
将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。
fn:length(item)
返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。
fn:replace(string, before, after)
返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果
fn:split(string, separator)
返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素
fn:startsWith(string, prefix)
如果参数string以参数prefix开头，返回true
fn:substring(string, begin, end)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21cd789047712a4bdc4966795b0e609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/228dc9ca02ad109e6e54c37848b3960a/" rel="bookmark">
			结构体对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#pragma pack(4)
class TestB
{
public:
int aa;
char a;
short b;
char c;
};
int nSize = sizeof(TestB);
这里nSize结果为12，在预料之中。
现在去掉第一个成员变量为如下代码：
#pragma pack(4)
class TestC
{
public:
char a;
short b;
char c;
};
int nSize = sizeof(TestC);
按照正常的填充方式nSize的结果应该是8，为什么结果显示nSize为6呢？
事实上，很多人对#pragma pack的理解是错误的。
#pragma pack规定的对齐长度，实际使用的规则是：
结构，联合，或者类的数据成员，第一个放在偏移为0的地方，以后每个数据成员的对齐，按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
也就是说，当#pragma pack的值等于或超过所有数据成员长度的时候，这个值的大小将不产生任何效果。
而结构整体的对齐，则按照结构体中最大的数据成员 和 #pragma pack指定值 之间，较小的那个进行。
具体解释
#pragma pack(4)
class TestB
{
public:
int aa; //第一个成员，放在[0,3]偏移的位置，
char a; //第二个成员，自身长为1，#pragma pack(4),取小值，也就是1，所以这个成员按一字节对齐，放在偏移[4]的位置。
short b; //第三个成员，自身长2，#pragma pack(4)，取2，按2字节对齐，所以放在偏移[6,7]的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/228dc9ca02ad109e6e54c37848b3960a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceada056b2507c243e9bf843d1c3c0fb/" rel="bookmark">
			const、volatile、mutable的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const修饰普通变量和指针
const修饰变量，一般有两种写法： const TYPE value; TYPE const value; 这两种写法在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。对于一个非指针的类型TYPE，无论怎么写，都是一个含义，即value值不可变。 例如： const int nValue； //nValue是const int const nValue； //nValue是const 但是对于指针类型的TYPE，不同的写法会有不同情况： l 指针本身是常量不可变 (char*) const pContent; l 指针所指向的内容是常量不可变 const (char) *pContent; (char) const *pContent; l 两者都不可变 const char* const pContent; 识别const到底是修饰指针还是指针所指的对象，还有一个较为简便的方法，也就是沿着*号划一条线： 如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； 如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 const修饰函数参数
const修饰函数参数是它最广泛的一种用途，它表示在函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)： void function(const int Var); //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用) void function(const char* Var); //参数指针所指内容为常量不可变 void function(char* const Var); //参数指针本身为常量不可变(也无意义，var本身也是通过传值的形式赋值的) void function(const Class&amp; Var); //引用参数在函数内不可以改变 参数const通常用于参数为指针或引用的情况，若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。
const修饰类对象/对象指针/对象引用
const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。
const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。 例如： class AAA {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceada056b2507c243e9bf843d1c3c0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dede455f67953bc2b87fac3ed0172e3/" rel="bookmark">
			C# WinForm获取soso城市天气预报程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 刚用C#写了一个从soso上获取固定城市天气预报的WinForm小程序。原理很简单，就是让soso搜索出城市的天气，然后再用程序分析搜索出来的数据，自己再进行处理。 soso上搜索到的效果如下： 得到soso的搜索结果后，就获取并处理搜索到的数据。程序获取的天气，效果如下： 代码写得有点笨拙，也不知道还有没有什么更好的办法能够更方便的获取网页数据。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac457d617721917cdeb580c79450425/" rel="bookmark">
			C#中的映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#编译后的文件主要由IL代码和元数据组成，元数据为.NET组件提供了丰富的自描述特性，它使得我们可以在代码运行时获知组件中的类型等重要的信息。C#中这是通过一种称作映射（Reflection）的机制来完成的。
动态类型查询
首先创建一个简单的类型：
namespace ReflectionClass
{
public class MyClass
{
#region Property
private int m_Count = 100;
public int Count
{
get
{
return m_Count;
}
set
{
m_Count = value;
}
}
#endregion
#region Method
public void Print()
{
Console.WriteLine("MyClass.Count = {}", Count);
}
#endregion
}
}
编译后可以得到“ReflectionClass.dll”文件，接下来实现查询类型的测试程序：
namespace TestReflection
{
public class App
{
static void Main(string[] args)
{
Type type = typeof(MyClass); //获取MyClass的类型信息
Console.WriteLine("The Type Name : {0}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eac457d617721917cdeb580c79450425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0333015364657dca35e6bcc82e6d578a/" rel="bookmark">
			OGR坐标变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是自己的一点点心得，留作以后用。可能不正确，欢迎指正 利用GDAL/OGR进行投影变化（VC++中），相关的函数都在ogr_srs_api.h中了。
Lilin大虾写得是关于phython中进行转换的，所以他利用的是这样的。
ct = osr.CoordinateTransformation(osrobj,osrobj3)
ct.TransformPoint(590000,4928000)
在vc中，利用OGRSpatialReference对象的Transform()或TransformEx()方法可以实现不同投影系统之间以及投影坐标和地理坐标之间的转换(两者的区别我还不知道)。
OGRSpatialReference * ShpSpf;//
OGRSpatialReference Raster_spf;
ShpSpf=polayer-&gt;GetSpatialRef(); //获取矢量图像的投影信息 Raster_spf=poDataset-&gt;GetProjectionRef();//获取栅格图像的投影信息 OGRCoordinateTransformation *poCT;
if (!(ShpSpf-&gt;IsProjected()))//判断是否经过投影
{
if(ShpSpf-&gt;IsGeographic())//判断是否有地理坐标信息
{
AfxMessageBox("没有投影信息，只有地理信息！");
return;
}
else
{
AfxMessageBox("没有地理坐标和投影信息！");
return;
}
}
int spf_flag=ShpSpf-&gt;IsSame(&amp;Raster_spf);//spf_flag标示两个投影是否一致，如果一样则为1，反之为0
1、不同投影系统之间转换：
poCT=OGRCreateCoordinateTransformation(ShpSpf,&amp;Raster_spf);
// poCT-&gt;TransformPoint();
if((poCT==NULL))
{
AfxMessageBox("不支持该类型的坐标转换!");
shape=3;//不再画这一层数据
return;
}
if(!poCT-&gt;TransformEx(ipoints,Arrayx,Arrayy))
{
AfxMessageBox("坐标转换失败!");
shape=3;//不再画这一层数据
return;
}
2、投影坐标到地理坐标的转换：
OGRSpatialReference *tempsp;
tempsp=Raster_spf.CloneGeogCS();//获取投影系统中的地理坐标信息
OGRCoordinateTransformation *poCT1;
//投影坐标向地理坐标转换。
poCT1=OGRCreateCoordinateTransformation(&amp;Raster_spf,tempsp);
//&amp;Raster_spf,tempsp顺序颠倒过来就是从地理坐标向投影坐标转换了
if(poCT1-&gt;TransformEx(1,&amp;Arrayx[1],&amp;Arrayy[1]))
{
}
转载于:https://www.cnblogs.com/gisbingxin/archive/2008/12/15/1355414.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89304c21e3b15978ea5a8b75a24a1fe9/" rel="bookmark">
			从c&#43;&#43;到java 之四（类定义&#43;import）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(5) 在Java中，类定义采取几乎和C++一样的形式。但没有标志结束的分号。没有class foo这种形式的类声明，只有类定义。
public class aClass{
int i;
float f;
boolean b;
public static void main(String[] args) { //方法主体
aClass d = new aClass();
d.i = 47;
d.f = 1.1f;
d.b = false;
}
}
(6) Java中没有作用域范围运算符“::”。Java利用点号做所有的事情，但可以不用考虑它，因为只能在一个类里定义元素。即使那些方法定义，也必须在一个类的内部，所以根本没有必要指定作用域的范围。我们注意到的一项差异是对static方法的调用：使用ClassName.methodName()。除此以外，package（包）的名字是用点号建立的，并能用import关键字实现C++的“#include”的一部分功能。例如下面这个语句：
import java.awt.*;
import指示编译器导入一个类库或者一个/些构件，java中的所有代码都必须写在类里面，这与c++是不同的，c++中还可以有非成员函数和数据。
例如：
import java.util.ArrayList;
import java.util.*; //一次性导入一群类
每个程序开头都要使用import导入代码中需要用到的所有额外的类，除了java.lang是自动导入到每个java文件里面的。
如果不知道该包含哪些类，可以在java帮助文档里面选择Tree，然后查找诸如Data之类的类，它会以java.util.Data形式列出来，我们再把它import进来就ok了。
还有一点需要注意：类的名字必须和文件名相同。对于独立运行的程序的创建，除了文件中必须有某个类的名字与文件名是同名，那个类还必须包含一个名为main()的方法
public static void main(string [] args)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c68ba424c5a4ad36f2f37c2f57fd29e/" rel="bookmark">
			vs.net打包程序时设置自动检测环境并安装.net framwork
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs.net打包程序或者制作安装程序时自动检测环境并安装.net framwork的设置方法之前我看过文档也做过，但是过一段时间又忘了，现在终于又找到方法了，还是把这个方法写下来吧，方便自己也方便大家将来查询用。 vs.net打包或者制作安装程序时进行自动检测环境并安装.net framwork的设置方法：
1. 新建一个“安装和部署”的项目；
2. 然后点击“视图”菜单，选择“编辑器”--“文件系统”，然后将要打包的程序以及相关文件添加进来，之后程序将自动检测依赖项；
3. 再次选择“视图”菜单，选择“编辑器”--“启动条件”，打开这个界面后会自动启动条件里一般都会自动添加“.NET Framework”项；
4. 右键点击应用程序名选择“属性”，在弹出的属性页对话框中，点击“系统必备”按钮；
5. 在“请选择要安装的系统必备组件”里把“.NET Framework 2.0”复选框勾上；
6. 在“指定系统必备的安装位置”里选中“从与我应用程序相同的位置下载系统必备组件”，这样就可以保证你下载的.net framwork版本跟自己所做的程序需要的.net framwork版本相同；
7. 确定后再次编译，在debug文件夹下会自动下载并生成“dotnetfx”文件夹，里面有应用程序需要的.net framwork安装程序；
8. 选中第3步的启动条件选项卡，展开“启动条件”文件夹，点击“.NET Framework”，切换到属性管理器中，将其属性“InstallUrl”的值设置为“dotnetfx/dotnetfx.exe”路径即可；
9. 再次编译安装程序就完整的制作出来啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2946deac70a5a721f611de665e5d56b1/" rel="bookmark">
			asp.net中用table表格绑定数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实在asp.net中用table表格绑定数据，并不要像在asp中那么麻烦，那么难理解，也不要用什么循环语句来一项项的读取数据，然后填充表格.asp.net中有一个叫做Repeater的控件,我们可以直接把表格嵌入到Repeater控件中,然后设置Repeate控件的DataSource属性并让其DataBind()就OK了...... 做一个测试: 我创建的SQL数据库如下: create database repeater --创建数据库 use repeater --使用该库 create table tbRepeater --创建表 ( rID int identity(1,1) primary key, rTitle varchar(50) not null, rText text null ) --插入几项数据 insert into tbRepeater values('test1','test1') insert into tbRepeater values('test2','test2') insert into tbRepeater values('test3','test3') insert into tbRepeater values('test4','test4') insert into tbRepeater values('test5','test5') html页面代码如下: 主要是拖进一个Repeater控件,然后往它里面嵌入表格并让其绑定数据字段. &lt;div&gt; &lt;asp:Repeater ID="rpTest" runat="server"&gt; &lt;HeaderTemplate&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Text&lt;/th&gt; &lt;/tr&gt; &lt;/HeaderTemplate&gt; &lt;ItemTemplate&gt; &lt;tr&gt; &lt;td&gt;&lt;asp:Label runat="server" ID="lblID" Text='&lt;%# Eval("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2946deac70a5a721f611de665e5d56b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6075860d51b772d1947d12dd93162dc/" rel="bookmark">
			String 截去其中的一段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：String str= "N=22539 100016&amp;Nty=1&amp;Ntk=product_rank1&amp;Ntt=&amp;Ntx=mode matchallpartial"; 去掉"N=22539 100016&amp;"，即参数"N",N 的值和分隔符"&amp;". 怎么去掉，谢谢!
解答：
1。获取第一个 &amp; 所在位置 offset subString(offset + 1); int index = str.indexOf("&amp;"); String newStr = str.substring(index + 1); 2。正则表达式：
public class Test1 { public static void main(String[] args) {
String str= "N=22539 100016&amp;Nty=1&amp;Ntk=product_rank1&amp;Ntt=&amp;Ntx=mode matchallpartial"; str = str.replaceAll("N=[^&amp;]*&amp;", "" ); System.out.println(str); } }
3。replace()
public class test {
public static void main(String[] args) {
String str= "N=22539 100016&amp;Nty=1&amp;Ntk=product_rank1&amp;Ntt=&amp;Ntx=mode matchallpartial"; String str2 = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6075860d51b772d1947d12dd93162dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1698a0b5b3ca028c364c0e223354794e/" rel="bookmark">
			小结“线程间操作无效: 从不是创建控件的线程访问它” 错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编程中经常会遇到在一个按钮中执行复杂操作，并将复杂操作最后返回的值加入一个ListView或ComboBox中候选。这个时候程序会卡，当程序员将这些卡代码放进线程(Thread)中后发现当对控件操作时出现 “线程间操作无效: 从不是创建控件的线程访问它”异常。
为什么.net不让我们跨线程操作控件，这是有好处的。因为如果你的线程多了，那么当两个线程同时尝试将一个控件变为自己需要的状态时，线程的死锁就会发生。但是难道就是因为这个原因，我们就只能让程序卡着么？当然不是，这里教大家一个解决方案：用BackGroundWorker
这里通过一个实例来告诉大家BackGroundWorker的用法。
首先我们先定义一个BackGroundWorker，大家可以去面板上拖一个，也可以自己手工定义一个。
this .backgroundWorker_Combo = new System.ComponentModel.BackgroundWorker(); // 定义一个backGroundWorker this .backgroundWorker_Combo.WorkerSupportsCancellation = true ; // 设置能否取消任务 this .backgroundWorker_Combo.DoWork += new System.ComponentModel.DoWorkEventHandler( this .backgroundWorker_Combo_DoWork); // 让backgroundWorker做的事 this .backgroundWorker_Combo.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler( this .backgroundWorker_Combo_RunWorkerCompleted); // 当backgroundWorker做完后发生的事件 如果是从面板上拖的，那么请在DoWork事件上双击，添加那些你想在背景线程中执行的代码，也就是那些可能会让你卡的代码。 然后再在RunWorkerCompleted事件上双击，添加那些你想往控件里操作的代码。 这里有一个开发实例，讲的是实现类似Google搜索中下拉列表的实现。其思路是在DoWork中搜索数据库，在Completed中将搜出来的东西放进去。 本文需要一个backgroundWorker，一个ComboBox控件 static char x;
/**/ /**/ /**/ /// &lt;summary&gt;
/// 接受从DLL搜出来的项目
/// &lt;/summary&gt; private string [] global_ListItem;
private void backgroundWorker_Combo_RunWorkerCompleted( object sender, RunWorkerCompletedEventArgs e)
{//如果数组中有东西，那么加入ComboBox
if (global_ListItem.Length&gt;0)
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1698a0b5b3ca028c364c0e223354794e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566c03bdb5b5fe92f6dd9cf79ac91cd1/" rel="bookmark">
			窗口最小化，任务栏不显示图标的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		窗口最小化，任务栏不显示图标的解决办法 具体症状：无论打开多少个浏览器窗口或文档或者是应用程序，任务栏上面一个都不显示，只要缩小窗口后就找不到了，要想关闭只能打开任务管理器从里面关闭 解决办法： 打开记事本，复制进下列虚线内的内容（不包括虚线）
--------------
'xp_taskbar_desktop_fixall.vbs - Repairs the Taskbar when minimized programs don't show.' Kelly Theriot and Doug Knox - 8/22/2003'翻译：Smallfrogs。翻译内容：将英文提示改为简体中文'来源：Microsoft Windows XP NewsGroupSet WSHShell = WScript.CreateObject("WScript.Shell")Message = "本脚本用于修复Windows XP中当最小化程序时，无法在任务栏显示图标的问题。"&amp; vbCR &amp; vbCRMessage = Message &amp; "为了正常工作，本脚本将关闭和重启 Windows Explorer 外壳，这个操作不会损坏你的系统。" &amp; vbCR &amp; vbCRMessage = Message &amp; "请关闭所有杀毒软件的实时监控！并保存所有打开的文件。"&amp; vbCR &amp; vbCRMessage = Message &amp; "是否继续？"X = MsgBox(Message, vbYesNo+vbExclamation, "注意")If X = 6 Then On Error Resume NextWshShell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566c03bdb5b5fe92f6dd9cf79ac91cd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e149a48c6015759ec4f0d098bbbcea0/" rel="bookmark">
			Java调用C语言DLL文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们经常要在 JAVA中调用C语言DLL文件，下面我们将用一个例题来向大家介绍 JAVA调用C语言DLL文件的实现方法 一、 生成C的头文件 1. 编辑Main.java public class Main { public native static int getStrNum(byte str[], int strLen); } 2. 生成头文件 按win + r打开“运行”窗口，输入“cmd”，打开DOS控制台窗口。进入上面Main.java所在的目录中，输入： javac Main.java javah Main 两条命令完成后会生成Main.h文件 二、 生成DLL 1. 新建空工程 在VS中新建工程：Win32 Console Application，取名“MakeDLL”，选择空工程。新建后修改工程属性： (1) General中，将“Configuration Type”改为“Dynamic Library (.dll)”； (2) C/C++的General中，将“Additional Include Directories”添加两项： “C:Program FilesJavajdk1.5.0_06include” “C:Program FilesJavajdk1.5.0_06includewin32” 根据你安装的 JAVA路径而设置，这是因为在C/C++编译过程中要使用 JAVA的jni.h等文件 2. 将上面生成的Main.h添加入工程 3. 新建一个新的文件main.cpp，代码如下： #include ’Main.h’ #include ’string.h’ JNIEXPORT jint JNICALL Java_Main_getStrNum (JNIEnv *env, jclass cls, jbyteArray str, jint strLen) { jbyte *buffer = (*env).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e149a48c6015759ec4f0d098bbbcea0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c5e8c54cfcadc117f8b1003fb5de07/" rel="bookmark">
			SQL查询重复数据和清除重复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择重复，消除重复和选择出序列 有例表：emp emp_no name age 001 Tom 17 002 Sun 14 003 Tom 15 004 Tom 16 要求： 列出所有名字重复的人的记录 ( 1 )最直观的思路：要知道所有名字有重复人资料，首先必须知道哪个名字重复了： select name from emp group by name having count ( * ) &gt; 1 所有名字重复人的记录是: select * from emp where name in ( select name from emp group by name having count ( * ) &gt; 1 ) ( 2 )稍微再聪明一点，就会想到，如果对每个名字都和原表进行比较，大于2个人名字与这条记录相同的就是合格的 ，就有 select * from emp where ( select count ( * ) from emp e where e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c5e8c54cfcadc117f8b1003fb5de07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0887fb904cf787e33e311b74fb95c6eb/" rel="bookmark">
			lsof命令常见参数说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://www.linuxfly.org/post/182.htm lsof全名list opened files，也就是列举系统中已经被打开的文件。我 们都知道，linux环境中，任何事物都是文件，设备是文件，目录是文件，甚至sockets也是文件。所以，用好lsof命令，对日常的linux管理 非常有帮助。以下的说明，大部分内容来自lsof的manual文档。我所做的只是在中文翻译的基础上，进行简单的分类说明，并列举最常用的参数。 一、输出说明 lsof是linux最常用的命令之一，通常的输出格式为： 引用 COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME 常见包括如下几个字段：更多的可见manual。 1、COMMAND 默认以9个字符长度显示的命令名称。可使用+c参数指定显示的宽度，若+c后跟的参数为零，则显示命令的全名 2、PID：进程的ID号 3、PPID 父进程的IP号，默认不显示，当使用-R参数可打开。 4、PGID 进程组的ID编号，默认也不会显示，当使用-g参数时可打开。 5、USER 命令的执行UID或系统中登陆的用户名称。默认显示为用户名，当使用-l参数时，可显示UID。 6、FD 是文件的File Descriptor number，或者如下的内容： （这里很难翻译对应的意思，保留英文） 引用 cwd current working directory; Lnn library references (AIX); jld jail directory (FreeBSD); ltx shared library text (code and data); Mxx hex memory-mapped type number xx. m86 DOS Merge mapped file; mem memory-mapped file; mmap memory-mapped device; pd parent directory; rtd root directory; tr kernel trace file (OpenBSD); txt program text (code and data); v86 VP/ix mapped file; 文件的File Descriptor number显示模式有： 引用 r for read access; w for write access; u for read and write access; N for a Solaris NFS lock of unknown type; r for read lock on part of the file; R for a read lock on the entire file; w for a write lock on part of the file; W for a write lock on the entire file; u for a read and write lock of any length; U for a lock of unknown type; x for an SCO OpenServer Xenix lock on part of the file; X for an SCO OpenServer Xenix lock on the entire file; space if there is no lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0887fb904cf787e33e311b74fb95c6eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb600bcf347994a16023f1e032dffa2/" rel="bookmark">
			清除冗余记录的SQL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;script type="text/javascript"&gt; &lt;/script&gt; &lt;script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt;&lt;script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"&gt; &lt;/script&gt; 问题：设表T中有五个字段A，B，C，D，ID，其中ID字段是为自动增量整型字段(唯一值)。业务数据生成时有重复插入现象，现需对A、B、C、D四字段完全一样的脏数据进行清理，要求一 SQL 语句，对四个字段完全一样的记录，仅保留ID最小的一条，其余作删除处理。 DELETEFROMTWHERE[ID]IN ( select[ID]fromTwhereAin (selectA fromTGroupByA,B,C,DHavingcount(*)&gt;1) and[ID]&lt;&gt; (selectmin(ID)asminID fromTGroupByA,B,C,DHavingcount(*)&gt;1) ) 更正： deletefromT whereT.IDnotin(selectmin(ID)fromTgroupbyT.A,T.B,T.C,T.D) &lt;script type="text/javascript"&gt; &lt;/script&gt; &lt;script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt;&lt;script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"&gt; &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d37dabf5d5020250e8a88378e135ec/" rel="bookmark">
			域名解析、子域名、cname别名指向、MX记录、泛域名与泛解析、域名绑定、域名转向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容均收集于互联网，如有侵权问题，请告知，将在第一时间处理
A记录
A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的子域名。通俗来说A记录就是服务器的IP,域名绑定A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器 子域名
子域名道理等同二级域名，不过比二级域名更加延伸，比如我们继续扩展该域名的主机名，设置主机名为bbs.at,那么就可以建立一个三级域名：bbs.at.abc.com，当然也可以建立四级域名bbs.at.go.abc.com，五级域名bbs.at.go.home.abc.com……，依次类推，可以建立无限级别的域名，我们统称这些域名为顶级域名abc.com的子域名。
CNAME别名指向记录
CNAME (Canonical Name)记录，通常称别名指向。在这里，您可以定义一个主机别名，比如设置ftp.***.com，用来指向一个主机www.***.com,那么以后就可以用FTP.***.com来代替访问www.***.com了。
MX记录
MX记录也叫做邮件路由记录，用户可以将该域名下的邮件服务器指向到自己的mail server上，然后即可自行操控所有的邮箱设置。您只需在线填写您服务器的IP地址，即可将您域名下的邮件全部转到您自己设定相应的邮件服务器上。　简单的说，通过操作MX记录，您才可以得到以您域名结尾的邮局。
TXT 记录
TXT 记录，一般指为某个主机名或域名设置的说明，如：admin IN TXT "管理员, 电话： 13901234567"mail IN TXT "邮件主机, 存放在xxx , 管理人：AAA"Jim IN TXT "contact: abc@mailserver.com"也就是您可以设置 TXT ，以便使别人联系到您 SRV 记录
SRV 记录：一般是为Microsoft的活动目录设置时的应用。DNS可以独立于活动目录，但是活动目录必须有DNS的帮助才能工作。为了活动目录能够正常的工作，DNS服务器必须支持服务定位（SRV）资源记录，资源记录把服务名字映射为提供服务的服务器名字。活动目录客户和域控制器使用SRV资源记录决定域控制器的IP地址。此技术细节请参考相应网站
泛域名与泛解析泛域名是指在一个域名根下，以 *.Domain.com 的形式表示这个域名根所有未建立的子域名。 泛解析是把*.Domain.com 的A 记录解析到某个IP 地址上,然后别人通过任意的前缀.domain.com访问都能访问到你解析的站点上例： 域名根　name.com 只建立了 www.name.com 和 name.com 这两个域名记录， 那么 ftp.name.com mail.name.com bbs.name.com 等域名记录是不存在的， 但为域名根 name.com 建立泛域名记录 *.name.com 后， *.name.com 就涵盖了 ftp.name.com mail.name.com bbs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d37dabf5d5020250e8a88378e135ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2118ea75a52e3ee9b3460330c9e3ac8/" rel="bookmark">
			把MSSQLServer数据库导入到MySql数据库中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境：
Windows XP sp2
MS SQL Server 2OOO sp1
MySql 5.0.41
步骤：
1.安装mysql数据库的ODBC驱动，mysql-connector-odbc-3.51.23-win32.msi，下载并安装。
2.在Mysql中创建数据库实例。
3.打开控制面板 --&gt; 管理工具 --&gt; 数据源ODBC，在用户DSN中添加一个MySQL ODBC 3.51数据源。
4.在登录login选项卡中输入数据源名称Data Source Name，此处输入MysqlDNS（也可以自己随便命名，只要在后面导入数据的时候选择正确的数据源名字就行）；然后输入服务器Server，用户User，密码Password，输入正确后选择要导入的数据库，Database选择你需要导入的数据库。在连接选项connect options中根据需要设置MySql使用的端口port和字符集Character Set。
注：字符集一定要和Mysql服务器相对应，如果Mysql使用了gbk字符集，则一定要设置字符集为gbk，否则导入到Sql Server可能会出现问号乱码。
5.打开sql server企业管理器，选择该数据库，单击右键选择所有任务 --&gt; 导出数据。
6.‘选择数据源’为默认，‘选择目的’为刚刚安装的mySQL数据源，用户/系统DSN为MysqlDNS。在‘指定表复制或查询’中选择‘从源数据库复制表和视图’，在‘选择源表和视图’里，选择需要导入的表，即可将数据从MSSQLServer数据库导入到MySql数据库中。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab0f5a178880ffad9442d8ee54c3103/" rel="bookmark">
			程序员到底应该学什么？！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以前听别人说大公司和小公司在招牌上的差异，自己总是不信，总是沿着自己设计的路一直走，直到碰壁了，才终于醒悟！所以在此以一个过来人的身份再说：大公司和小公司在招聘上的差异，程序员到底应该学什么！可能没有什么新意，甚至可以说是老生常谈！但是，希望在我的献身教育下，能给朋友们一点启发！也算借此机会，整理一下自己的思绪！
大公司和小公司在招聘上存在巨大差异的原因主要是：大公司，有比较雄厚的经济实力，所以在用人制度上，往往是人才储备型！他们招聘员工的时候，并不希望你能马上为其干活，创造价值，因为往后后有比较系统的内部培训；也不怕你会迅速离开，因为走了你一个，还有后来人！他们愿意在他们相中的对象身上投入！而小公司则正好相反。他们没有足够的钱，没有系统的培训，人员流动性大，所以每招一个人都希望你一入司就成为全额劳动力！
正是上面的差异导致了，他们在选拔人才时也存在巨大差异！对程序员行业而言：小公司，通常是到了非加人不可了，才招人。在招聘的时候非常看中你是否熟悉他们所用的框架，开发工具，甚至是开发相关的业务！入司之后是否能马上上手工作！所以，Hibernate，Struts，Spring,，Ajax，Eclipse等，现在市场上广泛实用的东西，你必须会，至少得相当了解。但是由于大家都很清楚，在开发过程中实际用到的技术都是比较皮毛的，并不会涉及到很深的东西，所以，他们也只是要求你会，而并不要求你精！他们对人才的要求注重：知识范围广，实用性高！而大公司则不同。他们，在看到业务发展苗头的时候就会开始招人，招进去之后会进行培训！所以他们招聘是非常看中：英语水平（这个笔者一直没有明白为什么！但确实是事实）。和对数据库，JAVA底层理论知识的理解程度，因为他们认为，如果你能把这些东西掌握到一定的程度，那么Hibernate，Struts，Spring,，Ajax，Eclipse对你来说一定不是问题！所以他们非常看中的是：你的潜力，学习能力，和隐藏价值！
看到他们要求的差异，我想要学什么，就不用多说了！如果，你只是着急要找到一个饭碗。那么，你应该，迅速了解Hibernate，Struts，Spring,，Ajax，Eclipse，不用太深入，每一个都到勉强能用的程度就可以了（准确的说，是能做题，能回到面试官的问题即可！），当然如果能深入肯定更好！你要是想找一个大公司，直接开始你的事业，那你不用顾忌那么全面，强烈建议你学好三个东西即可：英语，数据库理论，JAVA编程思想！
虽然，每一个说起来都非常简单，但是要学会任何一个都不容易！！笔者也是在碰壁中慢慢长大，我也有很多不明白的地方。但是希望大家能根据自己的目标，有一个比较小的方向，能事半功倍！不要徒劳，到最后发现自己掌握的东西原来都不重要，根本不是用人单位需要的东西！GOOD LUCK!
和许多青年朋友一样：我们总是在举手投足之间，割舍了历史；总是在现实的痛击下，才顾得上抱恨前科，总是在永远失去了之后才懂得珍惜！　而我们认为我们永远不会忘记的昨天，总是在我们念念不忘之际被遗忘！　当我们伸开双手，想要抓住身边之物时，却发现明天已经在我们的坚持下变成了昨天！　
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526d8df5b058fa36a27f61de1af3b106/" rel="bookmark">
			关于spring配置BasicDataSource数据源问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 spring访问weblogic配置jndi数据源 环境： db2服务器：aix,db2 8.1 应用服务器：rhel3,weblogic8.1,jdk1.4,db2客户端 数据库是通过app别名方式访问 1、问题描述 前不久，我们系统出现了点毛病，客户那边突然断电，后来应用服务器和db2数据库服务器重新启动，发现客户端依然无法连接应用服务器，问题解决后，将服务器端日志拿下来分析发现，weblogic启动之后，由于一个线程一直在刷库，导致一直报db2连接错误，大约半个多小时后，数据库连接恢复正常，日志中没有再出现db2连接错误，大概又过了10分钟，weblogic出现内存不足报警，随后便大量抛出OutOfMemoryError ,end of stacktrace 异常，整个应用瘫掉。 2、模拟重现 根据日志反应的情况，我们模拟出一致情况。如果在weblogic完全启动之后，db2才启动（或者说才能够正常连接），会导致weblogic出现OutOfMemoryError，从OutOfMemoryError控制台内存监控中可以看到，内存占用成台阶式上升的，之后到了顶部就可以看到控制台weblogic输出报警。后经过bea工程师的相关诊断等，推荐我们应用程序通过JNDI获取应用weblogic提供的数据源。在此之前，我们系统确实使用spring配置的org.apache.commons.dbcp.BasicDataSource数据源。 导致此种情况的不知道是否由BasicDataSource所引起，在网上找了N久，都未曾找到一个说法，暂且记录下来。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8557bd39903d04d0d2aafd1e8b5f9ecc/" rel="bookmark">
			动态创建html内容时所用的W3C DOM属性和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 document的属性和方法: document.createElement(tagName) :文档对象上的createElement方法可以创建由tagName指定的元素.如果以串div作为方法参数,就会生成一个div元素. document.createTextNode(text) :文档对象的createTextNode方法会创建一个包含静态文本text的文本节点. document.createAttribute(): 用指定的名字创建新的Attr节点. document.createComment() :用指定的字符串创建新的Comment节点. document.getElementById(): 返回文档中具有指定id的Element节点. document .getElementsByTagName():返回文档中具有指定标记名的所有Element节点.返回为一Element节点数组; 节点的属性和方法: &lt;element&gt;.appendChild(childNode) :appendChild方法将指定的节点增加到当前元素的子节点列表(作为一个新的子节点).例如,可以增加一个option元素,作为select元素的子节点. &lt;element&gt;.getAttribute(name) :该方法用来获得元素中name属性的值. &lt;element&gt;.setAttribute(name,value) :该方法用来设置元素中name属性的值. &lt;element&gt;.insertBefore(newNode,targetNode) :该方法将节点newNode作为当前元素的子节点插到targetNode子节点元素的前面. &lt;element&gt;.removeAttribute(name) :该方法从元素中删除属性name. &lt;element&gt;.removeChild(childNode) :该方法从元素中删除子元素childNode. &lt;element&gt;.replaceChild(newNode,oldNode) :该方法将节点oldNode替换为节点newNode. &lt;elemnet&gt;.hasChildNodes() :该方法返回一个布尔值,指示元素是否有子元素. &lt;element&gt;.tagName :元素的标记名称,比如&lt;p&gt;元素为PHTML文档返回的tagName均为大写; &lt;element&gt;.getAttributeNode() :以Attr节点的形式返回指定属性的值; &lt;element&gt;.getElementsByTagName() :返回一个Node数组,包含具有指定标记名的所有Element节点的子孙节点,其顺序为在文档中出现的顺序. &lt;element&gt;.hasAttribute() :如果该元素具有指定名字的属性,则返回true; &lt;element&gt;.removeAttributeNode() :从元素的属性列表中删除指定的Attr节点. &lt;element&gt;.setAttributeNode() :把指定的Attr节点添加到该元素的属性列表中． &lt;element&gt;.cloneNode(true) :复制当前节点,true表示复制当前节点以及它的所有子孙节点. Node对象常用属性: &lt;element&gt;.attributes :如果该节点是一个Element,则以namedNodeMap形式返回该元素的属性. &lt;element&gt;.childNodes :以Node[]的形式存放当前节点的子节点.如果没有子节点,则返回空数组. &lt;element&gt;.firstChild :以Node的形式返回当前节点的第一个子节点.如果没有子节点,则为null. &lt;element&gt;.lastChild :以Node的形式返回当前节点的最后一个子节点.如果没有子节点,则为null. &lt;element&gt;.nextSibling :以Node的形式返回当前节点的兄弟下一个节点.如果没有这样的节点,则返回null. &lt;element&gt;.previousSibling :以Node的形式返回紧挨当前节点,位于它之前的兄弟节点.如果没有这样的节点,则返回null. &lt;element&gt;.parentNode :以Node的形式返回当前节点的父节点.如果没有父节点,则返回null. &lt;element&gt;.nodeType :代表节点的类型. &lt;element&gt;.nodeName :节点的名字,Element节点则代表Element的标记名称. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced3a466057df9bc84d0e5a51ae30f61/" rel="bookmark">
			用会声会影10制作高保真电子相册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用会声会影10制作高保真电子相册 随着数码相机的普及，用数码相机记录旅行风光、亲友相聚、宝宝的成长……己成为个人精神生活的重要内容。制作高保真的电子相册不仅方便观看，而且还可节约大量的相片加洗费用。 制作电子相册有许多方法，我就曾经用过“莱莉卡”、“我行我速”、“56网”的视频制作、 “会声会影7”等多种软件，但都不令人满意。过去用 惯了7.0版（正版），还未使用过“会声会影10”正好用来试试，果然效果不错。在此，我将学习使用“会声会影10” 制作高保真的电子相册的体会与各位交流、分享，并再次感谢两位高手的指教。 一、准备工作。两件事，一是安装软件，熟悉软件的使用、操作。二是对即将编辑的照片进行前期处理。主要是分类、排序和对有缺陷的照片进行适当的修补。通常我爱用Photoshop图象处理软件，对需要处理的照片进行调色、调光和剪裁等必要处理。 二、设置。在运行 “会声会影10”前按个人的需要，设置好各项参数，才可收到预期的效果，也才能事半功倍，反之，则否。 1. “项目属性”。启动软件后，在文件菜单中单击“项目属性”，在“编辑文件格式”下拉菜单中选“MPEG”，在下面方框中显示720X576，4：3……。 然后单击右下角的“编辑”按钮，出现新的对话框，出现3个子菜单： （1）“会声会影”。在“执行非正方形渲染”框中打对勾。“非正方”可避免图像失真，能保留的DV和MPEG2文件的实际分辨率。 （2）“普通”。“页面大小”选“720X576”，“显示纵横比选”“4：3”。 （3）“压缩”。“媒体类型”选“PAR DVD”，“质量”，选70，“图像数据”选“变量 ”选“8000 KBPS”。 2. “参数设置”。在文件菜单单击“参数设置”（或按下快捷键F6），弹出“参数选择”对话框。分别有四项选项卡： （1）“常规”选项卡。一共有14项。主要几项是： 1 ）撤消。在空白框中打上对勾，即可启动撤消/重复功能。默认的允许撤消次数为99次，但使用次数多，计算机内存占用也多，会降低性能，可选少点。 2 ）背景色。默认“黑色”，对作电子相册不合适。当照片被剪裁或竖直放置时，照片两侧（或四周）边框就是黑色，要改变背景色，只需单击颜色小方框就会出现有32种色彩的背景色供选择。如果你双击色彩选取器上方“友立色彩选取器”的文字，还可除基本色外“自定义”随心所欲的选色。我常选“白色”，与照片边缘吻合些。 3 ）转场效果。使用“默认”的“随机”转场效果，即方便、快捷，又多变化。否则就需自己一个个的挑选，如照片多，就够麻烦人的。 4 ）工作文件夹。默认是C盘“会声会影”文件夹。做视频会消耗电脑大量的资源，与操作系统共用一个盘不适合。如文件过大，内存和磁盘容量都不够，最好将“视频”单独建文件夹，放在磁盘空间最大的盘内。 5 ）其他各项不一一详谈，如无特殊要求，基本上可按“默认”。 （2）“编辑”。有6个选项。我选择“应用色彩滤镜”、“PAL”（适合电视放映），采样质量选“最好”，图像采样选“保持长宽比”，如选择“调到项目大小”画面是铺满了，但有时会画面会变形。“插入图像默认区间”是3秒，即每幅画面停留的时间仅3秒，除去转场效果我认为欣赏照片的时间太短了，我增加到6秒。转场是1秒，不能太长。 3. “预览”。文件夹、硬盘磁盘空间最好选在专门作视频的磁盘，空间尽可能大些。 4. “智能代理”。 （1）选“启动智能代理”。有利于加快合成视频文件的速度。 （2）“视频尺寸”由352X240到1920x1080共7个等级，可按需要在1440x1080及1920x1080间选择。 （3）“代理文件夹”与工作文件夹相同。 （4）“自动代理模块”打对勾。 三、编辑视频 1. 输入图像。在菜单中单击“编辑”，可从两个途径输入图像，一是“叠覆”和“效果”菜单下方的“视频”下拉菜单中，选“图像”，二是时间轴正中上方的书形黄色按钮（当鼠标停留在上方时出现“将素材插入时间轴”的字样）。由于编辑电子相册的照片较多，我认为最简捷的方法是将你准备好的照片（分类和顺序）按批量，一次和分批选第二种插入方法，直接插入到时间轴。如果你电脑性能好，一次插入数十、上百张照片是轻而易举的事。假如你在“参数设置”“3）”中已选择了效果是“随机”的话，各种变化万千的转场效果，也就随之出现了。所有这些也只是几分钟的事。 2. 根据你的爱好，随想所欲的加上标题、音乐、片头、片尾，编辑工作即可完成。 3. 合成视频文件，即“渲染。” 四、成果分享 “会声会影10”对你制作的视频文件，可通过多种路径让您和你的朋友共同欣赏。主要方式是制成MPEG2视频文件，保存在电脑硬盘里随时打开欣赏，刻录成光盘保存随时放映，制成网络文件发布到网页上让大家欣赏。 如果要将创建的视频刻成光盘，在会声会影10是十分方便的，你只要在“分享”菜单中点击“创建光盘”，即可按照引导，一步步操作下去，即可顺利完成。 最后，我想强调的是制作电子相册软件很多，但我们讨论的中心话题是“制作高保真电子相册”，即保证照片的质量是第一位的，在写这篇博文时，我分别作了几种文件格式的电子相册。题目是“上海夜色美”，素材是在网上选的36张照片，按不同文件格式做成视频文件，片长3分19秒，其结果文件大小差异很大。 “56网”的视频Flash文件格式 545.49K 会声会影10 MPG文件格式 165 MB 会声会影10 WMV文件格式 18.1MB （供网上传阅） 我用“会声会影10”MPG文件格式制成的“老小孩”上海年会活动和在上海探亲期间所拍的照片，共316张照片，片长12.20分，文件竟然高达2.28GB！我按“会声会影10”刻录光的盘向导指引，顺利的刻成盘，放映效果还令人满意，所不足的是每幅照片区间仅3秒，太短了，所以在编辑“上海夜色美”时，延长到6秒。 概括的说，用“56网”的视频Flash文件格式制作电子相册简单、方便，特别适合在网上欣赏。缺点是文件传递压缩像素损失大，且只有3种模板供选择，缺乏个性化，属于“傻瓜型”，一学就会，适合初学者。用会声会影10制作电子相册，熟练掌握需要一点时间，对电脑硬件要求较高，但视频质量高，分享途径多，属于“发烧友”的类型。到底选用哪种？还须按自己的条件和兴趣而定。 最后还要说明，我也刚接触会声会影10才几天，还不熟悉，有的功能还弄不懂，更要说明的是，会声会影10的功能虽然十分强大，然而软件的汉化水平实在太差，许多地方是硬译的，让人弄不懂。我所以尽可能详细的叙述，目的只有一个，即希望有兴趣者，少走些弯路，再者是能得到高手的指导，看我对该软件的掌握、理解是否正确。这里只说到电子相册的有关问题，未涉及的东西很多，有机会再说。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3566f77f96d0f67f695b841ad0d463/" rel="bookmark">
			在Application中如何关闭Frame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天调试书上的一个用于显示窗体(Frame)的例子，感觉很容易。可是，在点击右上方的关闭按钮(X)时，窗口却无法关闭。 解决方法：为新建的窗体添加一个侦听器（addWindowListener(WindowListener l)）
代码如下：
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
public class HelloWorld
{
public static void main(String[] args)
{
// TODO Auto-generated method stub
Frame MyFrame = new Frame("My First Frame");
MyFrame .setSize(200,200);
MyFrame .addWindowListener( new WindowAdapter()
{ public void windowClosing(WindowEvent e) { System.exit(0); }//注意：windowClosing的第一个w是小写
});
MyFrame .setVisible(true);
MyFrame .addWindowListener(l)
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a56af237b70e976acd666f3b11759ba/" rel="bookmark">
			JpGraph中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JpGraph是一个PHP的图形类库，可以方便地生成各种柱状图，饼图，折线图等等，而且还可以方便地加文字。但是，中文的情况就稍微麻烦了一点。在JpGraph中默认是要把字符串转成utf8的，但是如果你的文件本身就是utf8的，并且要用中文字体，它还会转一遍，结果多转了一次，就会出现乱码。 除了编码问题，还有就是字体问题。为了试验中文显示，专门拷了一个simsun.ttc过来是，在代码里用FF_SIMSUN就可以正确显示中文，但是如果改用自己设置的FF_CHINESE，也就是uming.ttf，就又乱码了，而且和simsun.ttf乱码时的不一样。 后来发现FF_CHINESE和FF_BIG5是一样，是繁体字体，所以和用FF_SIMSUN的乱码还不一样。
解决以上问题的方法也就是传递正确的中文字符串给JpGraph，所以可以把字符串先转成gb2312的，这样JpGraph就可以正确转换了。当然，这个方法比较麻烦，每次都需要，还可以直接修改jpgraph_ttf.inc.php，我用的是2.2版本的，大概在99到106行之间的：
elseif( $aFF === FF_SIMSUN ) { // Do Chinese conversion if( $this-&gt;g2312 == null ) { include_once 'jpgraph_gb2312.php' ; $this-&gt;g2312 = new GB2312toUTF8(); } return $this-&gt;g2312-&gt;gb2utf8($aTxt); } 注释掉已有代码，直接返回$aTxt：
elseif( $aFF === FF_SIMSUN ) { // Do Chinese conversion //if( $this-&gt;g2312 == null ) { // include_once 'jpgraph_gb2312.php' ; // $this-&gt;g2312 = new GB2312toUTF8(); //} //return $this-&gt;g2312-&gt;gb2utf8($aTxt); return $aTxt; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfae213670564364ffde5479bdeb2366/" rel="bookmark">
			ApplicationFrame详细简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.jfree.ui.ApplicationFrame 是界面方面的类
其实它就只是一个窗口类
即public Frame(String title) throws HeadlessException
下面贴出它的原代码
package org.jfree.ui;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import javax.swing.JFrame;
/**
* A base class for creating the main frame for simple applications. The frame listens for
* window closing events, and responds by shutting down the JVM. This is OK for small demo
* applications...for more serious applications, you'll want to use something more robust.
*
* @author David Gilbert
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfae213670564364ffde5479bdeb2366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1726f439a967f8a864d3fe55fe1cc23/" rel="bookmark">
			HTML标记属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!&gt; 跑马灯 &lt;marquee&gt;...&lt;/marquee&gt;普通卷动 &lt;marquee behavior=slide&gt;...&lt;/marquee&gt;滑动 &lt;marquee behavior=scroll&gt;...&lt;/marquee&gt;预设卷动 &lt;marquee behavior=alternate&gt;...&lt;/marquee&gt;来回卷动 &lt;marquee direction=down&gt;...&lt;/marquee&gt;向下卷动 &lt;marquee direction=up&gt;...&lt;/marquee&gt;向上卷动 &lt;marquee direction=right&gt;&lt;/marquee&gt;向右卷动 &lt;marquee direction=’left’&gt;&lt;/marquee&gt;向左卷动 &lt;marquee loop=2&gt;...&lt;/marquee&gt;卷动次数 &lt;marquee width=180&gt;...&lt;/marquee&gt;设定宽度 &lt;marquee height=30&gt;...&lt;/marquee&gt;设定高度 &lt;marquee bgcolor=FF0000&gt;...&lt;/marquee&gt;设定背景颜色 &lt;marquee scrollamount=30&gt;...&lt;/marquee&gt;设定滚动速度 &lt;marquee scrolldelay=300&gt;...&lt;/marquee&gt;设定卷动时间 &lt;marquee οnmοuseοver="this.stop()"&gt;...&lt;/marquee&gt;鼠标经过上面时停止滚动 &lt;marquee οnmοuseοver="this.start()"&gt;...&lt;/marquee&gt;鼠标离开时开始滚动 &lt;!&gt;字体效果 &lt;h1&gt;...&lt;/h1&gt;标题字(最大) &lt;h6&gt;...&lt;/h6&gt;标题字(最小) &lt;b&gt;...&lt;/b&gt;粗体字 &lt;strong&gt;...&lt;/strong&gt;粗体字(强调) （同上效果略同） &lt;i&gt;...&lt;/i&gt;斜体字 &lt;em&gt;...&lt;/em&gt;斜体字(强调) &lt;dfn&gt;...&lt;/dfn&gt;斜体字(表示定义) &lt;u&gt;...&lt;/u&gt;底线 &lt;ins&gt;...&lt;/ins&gt;底线(表示插入文字) &lt;strike&gt;...&lt;/strike&gt;横线 &lt;s&gt;...&lt;/s&gt;删除线 &lt;del&gt;...&lt;/del&gt;删除线(表示删除) &lt;kbd&gt;...&lt;/kbd&gt;键盘文字 &lt;tt&gt;...&lt;/tt&gt; 打字体 &lt;xmp&gt;...&lt;/xmp&gt;固定宽度字体(在文件中空白、换行、定位功能有效) &lt;plaintext&gt;...&lt;/plaintext&gt;固定宽度字体(不执行标记符号) &lt;listing&gt;...&lt;/listing&gt; 固定宽度小字体 &lt;font color=00ff00&gt;...&lt;/font&gt;字体颜色 &lt;font size=1&gt;...&lt;/font&gt;最小字体 &lt;font style =’font-size:100 px’&gt;...&lt;/font&gt;无限增大 &lt;!&gt;区断标记 &lt;hr&gt;水平线 &lt;hr size=’9’&gt;水平线(设定大小) &lt;hr width=’80%’&gt;水平线(设定宽度) &lt;hr color=’ff0000’&gt;水平线(设定颜色) &lt;br&gt;(换行) &lt;nobr&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1726f439a967f8a864d3fe55fe1cc23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b61bdde03fbb9578537f238138bbfd/" rel="bookmark">
			通过早期测试弥补不规范软件开发带来的风险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作者： skisky 2007年5月9日 国内很多软件开发公司缺乏项目的规范化管理体制，软件的开发过程类似“作坊式开发”，一些有点规模的软件开发公司虽然建立了一套规范的项目管理体系，但是由于开发的软件规模不大、工期紧等原因，往往是规范让步。这种“作坊式开发”往往给成功开发项目带来很大的风险，项目的失败或者表现为无法实现的不可为、或者表现为开发周期的不可控制、或者表现为项目结果为用户所不认可、或者表现为项目最终的严重亏损，这种失败的惨痛结果可以出乎人们的意料，以至使人无所是从。
项目中应该产生的文档能省则省，甚至没有，如项目计划、进度计划、变更管理文件等；一些项目文档不按时生成，能拖则拖，有些在软件代码开发之前就应该产生的文档到开发结束还不能提供最终的版本，甚至没有。如在进入正式开发之前，从用户处获取准确的需求后，先要进行可行性分析，对于一些无法实现的技术应该仅早对需求进行调整，并制定出一份需求规格说明书，尽可能地分析清楚，哪些是稳定的需求，哪些是易变的需求以及分析人员和客户之间的歧义理解，以便在进行系统设计时，将软件的核心建筑在稳定而全面的需求上。避免在代码开发过程中，由于先期了解不周全，造成需求经常变动，给项目的实施和进度带来很大的影响。
这种类型的项目，往往是一个项目经理带两三个开发人员来完成，开发人员少，意味着不同人员的程序之间交互、接口相对少一些。开发周期短意味着往往是同样的几个人从头到尾负责一个项目。这两者都让人容易犯些错误。往往是几个人碰一下头，讨论一下最基本的数据结构、函数接口便分头去做自己的工作了，没有一份较正式的文档，容易造成误解上的偏差，以及缺少有效的监控。同时大部分的系统开发过程由于大量尝试性、重复性工作而变得缓慢，后期调试会出现许多意想不到的大大小小的问题，狼烟四起之时大多数技术人员特别是技术负责人主要工作是“救火”。这样的项目，工程延期往往是普遍现象，“火势太大”情况下会再投入人力。软件开发的特殊性决定了其工程效率与编程人员的数量并不成正比，没有过程文档支持下的项目到了后期，人员的投入反而有可能使工程进度减慢。工程进度失控将直接导致项目亏损，这是显而易见的。同时客户方面由于系统无法按时上线或投入生产，后续的工作不能按计划实施，造成的经济损失将无法估量。
同样没有任何文档支持的项目，若在项目开发的过程中或后期一旦项目组中的成员由于某种原因被调走，整个项目将进入瘫痪状态，没有人可以接手继续。同时对于软件的后期维护也无据可依、无从下手。
很多软件公司都存在着重开发、轻测试的现象，尤其是一些规模不大的项目根本就不安排测试人员参与，有的公司甚至没有自己的测试团队。测试的目的之一就是能够降低客户在使用产品时发生问题的风险，同时也是在有限的时间内将客户使用产品时发生问题的风险降到最小的过程，测试有助于提高软件的质量。一般而言，内部对产品的测试（称为α测试），需要开发人员与独立的测试小组共同参与。开发人员应该执行“白盒”测试，即测试源程序的逻辑结构以及实现细节（“白盒”是指看得见程序的内部结构）。而独立测试小组应该执行“黑盒”测试，即按照规格说明来测试程序是否符合要求（“黑盒”是指看不见程序的内部结构）。很多情况下“黑盒”测试也是由开发人员自己进行的，也不安排开发小组的成员相互测试对方的程序，这种测试自己开发的程序的做法，往往发现不了很多功能和接口方面的问题。这种不成熟的产品直接交付给客户进行验收，验收测试的工作量是显而易见的，验收的结果往往是错误百出，很多功能无法实现，并存在很多低级错误，开发方拿回去修改后也不能保证关闭所有的缺陷，同时在修改的过程中可能会引入新的缺陷，这样在未达到要求的基础下一遍一遍的测试，等于是在帮开发方完成他们之前应该做的事情，不仅加大了工作量，而且项目的进度得不到保障。
所以在软件开发的初期就引入测试，将测试贯穿到软件项目的整个开发过程中是非常有效的，早期介入测试有助于提早发现问题，同时对大幅度的降低项目风险有很大的好处。在软件的需求分析阶段就可以设计出测试计划书，并对需求进行审核、测试，论证需求是否可以满足用户的要求，从而减少需求风险。在设计阶段，可以明确“黑盒”测试的目标，设计出有效的、可以完全覆盖的测试用例，这种针对函数的测试有助于较早期的发现问题，将软件缺陷消灭在开发早期。在编码阶段，进行每日编译、每日测试，测出的软件缺陷在当天就可以处理，从而保证了把缺陷消灭在早期。这时测试与开发已经完美的结合起来，做到测试与开发的同步，并且不相互冲突。由于测试与开发是同步进行的，所以在开发的后期主要进行的就是对开发过程中发现的问题的回归测试。因为在编码阶段软件缺陷就发现的差不多了，所以这时主要的精力可以放在集成测试，性能测试，兼容性测试等一些测试上来。这样项目的进度就可以得到有效的控制，不至于造成很大的风险。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da909a42b988937f706627c03f1c4e6e/" rel="bookmark">
			sprintf 的详细用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sprintf 的详细用法
----转自网络
在将各种类型的数据构造成字符串时， sprintf 的强大功能很少会让你失望。由于 sprintf 跟 printf 在用法上几乎一样，只是打印的目的地不同而已，前者打印到字符串中，后者则直接在命令行上输出。这也导致 sprintf 比 printf 有用得多。 sprintf 是个变参函数，定义如下： int sprintf( char *buffer, const char *format [, argument] ... );
除了前两个参数类型固定外，后面可以接任意多个参数。而它的精华，显然就在第二个参数： 格式化字符串上。 printf 和 sprintf 都使用格式化字符串来指定串的格式，在格式串内部使用一些以“ % ”开头的格式说明符（ format specifications ）来占据一个位置，在后边的变参列表中提供相应的变量，最终函数就会用相应位置的变量来替代那个说明符，产生一个调用者想要的字符串。 格式化数字字符串
sprintf 最常见的应用之一莫过于把整数打印到字符串中，所以， spritnf 在大多数场合可以替代 itoa 。 如： // 把整数 123 打印成一个字符串保存在 s 中。 sprintf(s, "%d", 123); // 产生 "123"
可以指定宽度，不足的左边补空格： sprintf(s, "%8d%8d", 123, 4567); // 产生： " 123 4567"
当然也可以左对齐： sprintf(s, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da909a42b988937f706627c03f1c4e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77882156f1a08df97a46950c649912d/" rel="bookmark">
			SharpMap AjaxMapControl 中 Zoomin/Zoomout 操作时冻结问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、现象：
在放大/缩小操作时，当 Map.width = Map.MaximumZoom 时再次执行Zoomout 或者当 Map.width = Map.MinimumZoom 时再次执行Zoomin，浏览器显示的地图处于冻结状态（刷新地图停止）；同时，鼠标光标处于长久的等待（wait）状态。
2、原因：
客户端 javascript 脚本在响应鼠标事件处理时发生事件重入。 3、解决方法：
修改AjaxMap.js 中的SharpMap_BeginZoom 函数
function SharpMap_BeginZoom(obj,x,y,zoomval)
{
if(obj.zoomEnded==0) return;
if(obj.zoom/zoomval&lt;obj.minZoom) zoomval = obj.zoom/obj.minZoom;
if(obj.zoom/zoomval&gt;obj.maxZoom) zoomval = obj.zoom/obj.maxZoom;
//当控制动态缩放的zoomval值为1时停止动态缩放并退出
if(Math.abs(1-zoomval)&lt;0.0001) return;
obj.zoomEnded=0;
obj.container.style.cursor = 'wait';
var position = WebForm_GetElementPosition(obj.container);
var imgX = x-position.x;
var imgY = y-position.y;
var center = SharpMap_PixelToMap(imgX+(obj.container.offsetWidth*0.5-imgX)/zoomval,imgY+(obj.container.offsetHeight*0.5-imgY)/zoomval,obj);
obj.zoom = obj.zoom/zoomval;
obj.minX = center.x - obj.zoom*0.5;
obj.maxY = center.y + obj.zoom*obj.container.offsetHeight/obj.container.offsetWidth*0.5;
SharpMap_BeginRefreshMap(obj,1); //Start refreshing the map while we're zooming
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77882156f1a08df97a46950c649912d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa28614ec55c26273a0b5e1a21a508dc/" rel="bookmark">
			2个程序(一个用glue,一个直接连接xpcom)用了NS_GetServiceManager全部死掉,SIGSEGV的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 个程序(一个用glue,一个直接连接xpcom)用了NS_GetServiceManager全部死掉,SIGSEGV gluetest 错误的原因是因为gluetest和libxpcomglue.a编译选项不一致,使得gluetest和libxpcomglue.a中的 getter_AddRefs&lt;nsIServiceManager&gt;(nsCOMPtr&lt;nsIServiceManager&gt;&amp;)
代码不一致(调用方式也不一致),然后执行的时候libxpcomglue.a用的函数用的是gluetest生成的函数---用objdump找到原因的
---解决方法，用和libxpcomglue.a一样的编译选项编译就可以了，原因是如果没有有-DDEBUG -D_DEBUG,
生成的调用方式不一样（我的机器是amd64，gcc 3.4.6-3）,不知道是真正的原因，是否有人知道，望告知
xpcomtest死掉的原因是类似,在so文件中的函数调用了xpcomtest中的getter_AddRefs同名的函数(???)
另外如果不要NS_GetServiceManager,好像是好的,因为这个是没有生成getter_AddRefs,这个是一个模板参数
--原因： 因为exe文件和so文件里面多有一个getter_AddRefs，因为他们是WEAK（elf），所有就可以同时存在，然后so文件调用的时候调用了exe中的函数, 可能是在x86_64中引起的，因为gcc的bug（http://gcc.gnu.org/bugzilla/show_bug.cgi?id=20297），使得编译mozilla的时候加了去掉了这个option ---解决： 1.用同一个编译选项，程序可以执行，但是方法不好 2. 在exe中不输出symbol，要在gcc中找这个option，（还没有找到） 在编译mozilla的时候加ac_have_visibility_buildin_bug=yes,不要加ac_have_visibility_pragram=no 并且在编译自己的程序的时候加-fvisibility=hidden 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef70fe233023e2cea27e6998892b33d8/" rel="bookmark">
			在JavaScript中利用for(…in…)语句实现反射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是反射机制
反射机制指的是程序在运行时能够获取自身的信息。例如一个对象能够在运行时知道自己有哪些方法和属性。
在JavaScript中利用for(…in…)语句实现反射
在JavaScript中有一个很方便的语法来实现反射，即for(…in…)语句，其语法如下：
for(var p in obj){
//语句
}
这里var p表示声明的一个变量，用以存储对象obj的属性（方法）名称，有了对象名和属性（方法）名，就可以使用方括号语法来调用一个对象的属性（方法）：
for(var p in obj){
if(typeof(obj[p]=="function"){
obj[p]();
}else{
alert(obj[p]);
}
}
这段语句遍历obj对象的所有属性和方法，遇到属性则弹出它的值，遇到方法则立刻执行。在后面可以看到，在面向对象的JavaScript程序设计中，反射机制是很重要的一种技术，它在实现类的继承中发挥了很大的作用。
使用反射来传递样式参数
在Ajax编程中，经常要能动态的改变界面元素的样式，这可以通过对象的style属性来改变，比如要改变背景色为红色，可以这样写：
element.style.backgroundColor="#ff0000";
其中style对象有很多属性，基本上CSS里拥有的属性在JavaScript中都能够使用。如果一个函数接收参数用用指定一个界面元素的样式，显然一个或几个参数是不能符合要求的，下面是一种实现：
function setStyle(_style){
//得到要改变样式的界面对象
var element=getElement();
element.style=_style;
}
这样，直接将整个style对象作为参数传递了进来，一个style对象可能的形式是：
var style={
color:#ffffff,
backgroundColor:#ff0000,
borderWidth:2px
}
这时可以这样调用函数：
setStyle(style);
或者直接写为：
setStyle({ color:#ffffff,backgroundColor:#ff0000,borderWidth:2px});
这段代码看上去没有任何问题，但实际上，在setStyle函数内部使用参数_style为element.style赋值时，如果element原先已经有了一定的样式，例如曾经执行过：
element.style.height="20px";
而_style中却没有包括对height的定义，因此element的height样式就丢失了，不是最初所要的结果。要解决这个问题，可以用反射机制来重写setStyle函数：
function setStyle(_style){
//得到要改变样式的界面对象
var element=getElement();
for(var p in _style){
element.style[p]=_style[p];
}
}
程序中遍历_style的每个属性，得到属性名称，然后再使用方括号语法将element.style中的对应的属性赋值为_style中的相应属性的值。从而，element中仅改变指定的样式，而其他样式不会改变，得到了所要的结果。
注:这样就能实现修改我们想要修改的信息,不需要的就和原来一样不改变
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1dd84400c8164a9ddf930dc4308f0d7/" rel="bookmark">
			Servlet入门1——第一個Servlet程式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		從Java程式設計人員的角度來看，Servlet其實就是一個Java類別，它實作 javax.servlet.Servlet介面，通常會繼承實作該介面的javax.servlet.GenericServlet類別或javax.servlet.http.HttpServlet類別，前者用於與協定無關的Servlet，後者專門適於處理HTTP請求與回應的Servlet。
繼承GenericServlet類別的Servlet通常會改寫service()方法，而繼承HttpServlet類別的 service()會處理request並傳送給doXXX()方法，例如doGet()或doPost()方法，通常很少會去改寫service()，而是改寫doGet()或doPost()方法，下面就仍以一個簡單的Hello!Servlet!來示範如何撰寫與設定Servlet，讓其可以傳回一個 HTML網頁顯示Hello!Servlet!文字： HelloServlet.java
package onlyfun.caterpillar;
import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class HelloServlet extends HttpServlet { public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException { res.setContentType("text/html"); PrintWriter out = res.getWriter(); out.println("&lt;html&gt;"); out.println("&lt;head&gt;");
out.println("&lt;title&gt;Hello!Servlet!&lt;/title&gt;");
out.println("&lt;/head&gt;"); out.println("&lt;body&gt;"); out.println("&lt;h1&gt;&lt;b&gt;Hello!Servlet!&lt;/b&gt;&lt;/h1&gt;"); out.println("&lt;/body&gt;"); out.println("&lt;/html&gt;"); } } 為了要能編譯上面這個類別，您需要將servlet-api.jar加至CLASSPATH中，在Tomcat的話servlet-api.jar是放在 common/lib目錄下。
doGet()處理客戶端請求的GET方法，只要是客戶端請求資源時是使用GET方法，就會呼叫它來處理，它獲得兩個參數，分別表示用戶端的請求與回應，您可以回憶一下JSP的隱含物件request與response，其對應的就是HttpServletRequest與 HttpServletResponse物件，您由HttpServletResponse物件取得寫出至用戶端的PrintWriter物件，並寫出一個HTML網頁至用戶端，PrintWriter物件可以使用println()方法將資料寫出。
假設您的Web應用程式位於webapps/myServlet/下，則編譯完成的Servlet類別必須放置在WEB-INF/classes/之下，為了要讓容器能知道這個Servlet的存在並實例化，您必須在WEB-INF/web.xml中告知： web.xml &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" version="2.4"&gt; &lt;description&gt; My Servlet Examples. &lt;/description&gt; &lt;display-name&gt;Servlet Examples&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1dd84400c8164a9ddf930dc4308f0d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f9697ad34b2d47001425b78b21c5b4/" rel="bookmark">
			java调用C的dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早就听说了 jni 可是到现在我才岛鼓出来，是不是很笨.......
好了费话不说了，开始进入正题
1.首先创建一个java类 Hello.java
public class Hello {
//在静态块里面,把lib.dll导进来,记住不能写.dll的，否则会找不到的
static
{
System.loadLibrary("lib");
}
//申明一个本地方法,该本地方法的实现在lib.dll中
public native static void printString(String str);
public static void main(String[] args) {
Hello.printString("Hello");
}
}
2.用javac编译这个类 : java Hello.java
不清楚的QQ:283066589
用javah对.clss生成C的头文件:javah Hello
现在头文件Hello.h的内容是:
/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class Hello */
#ifndef _Included_Hello
#define _Included_Hello
#ifdef __cplusplus
extern "C" {
#endif
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f9697ad34b2d47001425b78b21c5b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b128f1c6a6f134a48a0f2f28223fa2/" rel="bookmark">
			LR中判断HTTP返回状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有天，有个人问： 我在做 b/s 测试，请问如何保存从服务器传回来的 http 头的信息，怎么能得到 http 状态，和状态 200 进行比较？ 后来，我给出的代码如下： Action() {int i; // [WCSPARAM WCSParam_Text1 3 200] Parameter {WCSParam_Text1} created by Correlation Studio web_reg_save_param("WCSParam_Text1", "LB=1.1 ", "RB= ", "Ord=1", "RelFrameId=1", "Search=Headers", "IgnoreRedirections=Yes", LAST); web_url("www.hao123.com", "URL=http://www.hao123.com/", "Resource=0", "RecContentType=text/html", "Referer=", "Snapshot=t1.inf", "Mode=HTML", LAST); i=atoi(lr_eval_string("{WCSParam_Text1}")); if (i == 200) lr_log_message("终于成功了！！我不容易呀！！！"); else lr_log_message("唉，又失败了，不过这才是正常的！ "); return 0; } 后来查了帮助，看到如下方法才好： Action() { int HttpRetCode; web_url("www.hao123.com", "URL=http://www.hao123.com/", "Resource=0", "RecContentType=text/html", "Referer=", "Snapshot=t1.inf", "Mode=HTML", LAST); HttpRetCode = web_get_int_property(HTTP_INFO_RETURN_CODE); if (HttpRetCode == 200) lr_log_message("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b128f1c6a6f134a48a0f2f28223fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826eda88b4000e53362082bcb87fd628/" rel="bookmark">
			关于两个对象交换的问题（实践的角度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于两个对象交换的问题（实践的角度） 首先声明，在面向对象盛行的时代里，我改用对象这两个词来指代最广泛的变量。 现在的变量就不一定只是一个整型或浮点型，甚至不是一个基本数据类型。我们 将在更广泛的意义上讨论对象交换的问题。 在前一篇文章 “ 关于两个对象交换的问题”（注意，名称已改）中，我们讨论了交换两个变量 的几种方法，并给出了形式化的公式。而在这一篇文章中，我们将讨论的是效率 与可行性的问题。（注：这个主题的想法，主要是受farproc朋友对上一篇文章的留言引发 的。） 中间变量方式 首先，我们来看采用最简单直接的交换方式的代码： {
int tmp;
tmp = a;
a = b;
b = tmp;
}
按语言本身的特性来想，这些代码做以下这些工作： 在栈上分配为整型变量tmp分配空间； 将a的值放入tmp中； 将b的值放入a中； 将tmp的值放入b中； 释放为tmp分配的栈空间。 而实际上呢？我们来看看生成的汇编代码： movl b, %eax ;将b从内存载入到寄存器eax
movl a, %edx ;将a从内存载入到寄存器edx
movl %eax, a ;将eax的内容存入到内存a中
xorl %eax, %eax ;将eax清零
movl %edx, b ;将edx的内容存入到内存b中
看起来，汇编指令并不象我们想象的那样复杂。因为变量要参与运算首先要从内 存载入到寄存器中，所以要将两个变量交换只需按相反的顺序再存入到内存中就 可以了。只是四个内存与寄存器之间交换数据的指令，看起来好像没有交换操作 似的。而此处为什么要将eax清零呢？因为eax寄存器是专门用来放函数返回值 的，而我们的测试函数很简单，除了执行上面的操作外，剩下的就是return 0;了，因此它与变量交换根本没有关系。从上面可以看到，编译器为我们做的工 作远比我们想像的要多。 异或方式 接下来，我们来看基于异或方式交换的代码： {
a ^= b;
b ^= a;
a ^= b;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826eda88b4000e53362082bcb87fd628/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/277/">«</a>
	<span class="pagination__item pagination__item--current">278/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/279/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>