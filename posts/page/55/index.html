<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63705b80f43bbba135977cc6e473856/" rel="bookmark">
			YOLOv5 如何关闭wandb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一处：utils/loggers/wandb/wandb_utils.py # try: # import wandb # # assert hasattr(wandb, '__version__') # verify package import not local dir # except (ImportError, AssertionError): # wandb = None # 添加以下语句 wandb = None 第二处：utils/loggers/ __init __.py # try: # import wandb # # assert hasattr(wandb, '__version__') # verify package import not local dir # if pkg.parse_version(wandb.__version__) &gt;= pkg.parse_version('0.12.2') and RANK in {0, -1}: # try: # wandb_login_success = wandb.login(timeout=30) # except wandb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d63705b80f43bbba135977cc6e473856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36327bf45d6cf86c28e3594a710e5d52/" rel="bookmark">
			C&#43;&#43; - 跨平台在Windows、Linux系统上获取当前可执行程序路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 C++跨平台在Windows、Linux系统上获取当前可执行程序路径 跨平台获取当前可执行程序路径是C++跨平台项目中会经常使用的功能，我将这个功能简单的封装成了一个PathUtils工具类，在该类中通过GetCurrentProgramDirectory静态函数获取当前可执行程序路径，下面贴出了功能实现代码。
path_utils.h
#ifndef _PATH_UTILS_H_ #define _PATH_UTILS_H_ #include &lt;string&gt; class PathUtils { public: // 得到当前程序执行路径 static std::string GetCurrentProgramDirectory(); }; #endif // !_PATH_UTILS_H_ path_utils.cpp
#include "path_utils.h" #if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__) #include&lt;Windows.h&gt; #elif defined(linux) || defined(__linux) #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;dlfcn.h&gt; #endif // WINDOWS #if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__) static HMODULE GetSelfModuleHandle() { MEMORY_BASIC_INFORMATION mbi; return ( (::VirtualQuery(GetSelfModuleHandle, &amp;mbi, sizeof(mbi)) != 0) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36327bf45d6cf86c28e3594a710e5d52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b8799d287ba6330dc49ac0a53ca8b3/" rel="bookmark">
			STM32串口中常用的字符函数strlen,strcmp,strstr详解及具体程序实现过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32中 strlen(),strcmp(),strstr() 是我们在使用串口的时候，经常会用到的C语言库&lt;string.h&gt;里的字符串函数，用来对串口接受过来的数据进行一个判断处理。
目录 求字符串长度函数 strlen()函数介绍函数使用函数实现逻辑函数实现·函数实例 字符串比较函数 strcmp()函数介绍函数使用函数实现逻辑函数实现·函数实例 查找子字符串函数 strstr()函数介绍函数使用函数实现逻辑函数实现函数实例 求字符串长度函数 strlen() 函数介绍 传入参数：数组的首元素地址。 返回值： 返回 '\0'之前所有字符个数 数据 类型为size_t无符号整形。 函数使用 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char arr[20] ="hello"; int ret=strlen(arr); printf("%d\n", ret); return 0; } 运行结果：
函数实现逻辑 通过上面函数的返回值，我们可以得知 ‘\0’ 是函数的结束条件，此外 ‘\0’ 是编译器主动加在每一个字符串结尾加上的。
这样逻辑就简单了，只需要一个while循环一直判断是否遇到 ‘\0’ 就可以了，如果没遇到 '\0’就一直向后走，遇到了就退出循环并返回统计的值。
函数实现· size_t my_srtlen(const char * str1)// const 将变量修饰为常量，保证传入的数据的内容不会被修改 { size_t count = 0; while (*str1++ != '\0') { count++; } return count; } 函数实例 #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b8799d287ba6330dc49ac0a53ca8b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd14adae470ec9a2956dddd6975d59d/" rel="bookmark">
			调整Windows11桌面图标间隔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调整Windows11桌面图标间隔 Win+R 快捷键如何使用 在Windows系统中，通过 Win+R 的快捷键可以快速打开Windows系统的“运行”窗口，然后在这里输入相应的命令就可以快速执行指定的任务。
具体的操作方法是，同时按下键盘上的Windows键和R键即可。
按下Windows+R,在运行窗口输入“regedit” 打开注册表编辑器窗口 依次打开路径
计算机\HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics
找到IconSpacing和IconVerticalSpacing两个“字符串” IconSpacing------图标间隔 IconVerticalSpacing------图标垂直间隔
分别双击两个字符串，进入“编辑字符串值”界面，分别将两个数值调整为-1130
重启电脑，对比修改过和修改之前的效果
图1：未修改图标间隔数值之前
图2：修改图标间隔数值之后的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f62eba15f8ae25ade9d7719eb47d7c/" rel="bookmark">
			Mysql&#43;Navicat安装使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql是免费的，以下是官网安装包下载链接 https://www.mysql.com/
1、找到社区版本
2、找到这个 社区版本
3、找到对应版本 ：这里选择 8.0.34 ！！！注意哈
4、不需要其他的，直接选择这个，则开始下载安装包了
5、开始安装，后续安装包需要解压到你希望的地方
前置条件：先解压刚才下载的文件
打开解压后的文件夹 ，创建 my,ini文件，复制下面内容，修改 你压缩的目录文件夹地址 ：
# 设置3306端口 port=3306 # 设置mysql的安装目录 ----------是你的文件路径------------- basedir=D:\Program Files\mysql-8.0.33-winx64 # 设置mysql数据库的数据的存放目录 ---------是你的文件路径data文件夹自行创建 #datadir=D:\Program Files\mysql-8.0.33-winx64\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。 max_connect_errors=10 # 服务端使用的字符集默认为utf8mb4 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 #mysql_native_password default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8mb4 6、我解压到的是E：先以管理员身份打开命令
7、cd 到刚刚解压后的文件夹的 bin文件目录当中。
TIPS : 如果无法跳转就转 第二行 加上 /d 8、自动生成密码
输入命令，记录密码语句 ，注意 要先cd到你解压目录 mysqld --initialize --console 到以下界面才算成功 如果报错，未生成，先执行下面语句，再执行上面的，具体操作如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f62eba15f8ae25ade9d7719eb47d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82990bd853a515b674be26bbe282277c/" rel="bookmark">
			cmd/python命令行密钥上传SFTP，实现自动化上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们会用到用密钥连接SFTP进行文件上传下载移出等操作（比如PS5提交包就需要用到）。而命令行的操作能够集成到生产环境，实现流程自动化，本文简述密钥连接SFTP的方法，实现自动化的上传
文章目录 cmdpython密码连接密钥文件连接上传、移除文件 图形化界面：Filezilla使用密钥文件上传 cmd sftp连接指令：
sftp -i ~/.ssh/id_rsa username@hostname 注意windows下会要求你的密钥不能存在任意用户都可以访问的目录下。如果报了这个错误，可以把密钥放在C:\Users\[yourName]\.ssh下面。
python 上述cmd脚本能正确连接到服务器，连接后可以输入指令（如put localFilePath remoteDir进行文件的上传），但需要先输入连接指令，等待几秒钟出现sftp&gt;提示符后才能开始进一步操作。这种方式无法集成到生产环境的自动化脚本中。
那我们来研究一下python吧！
python使用sftp需要用到paramiko库
密码连接 使用方式：
transport = paramiko.Transport((hostname, port)) transport.connect(username=username, password=password) 完整代码：
import paramiko # 建立SFTP连接 hostname = '远程服务器地址' port = 22 username = '用户名' password = '密码' transport = paramiko.Transport((hostname, port)) transport.connect(username=username, password=password) sftp = transport.open_sftp() # 在此处执行SFTP操作，例如上传、下载、删除文件等 # 关闭SFTP连接 sftp.close() transport.close() 密钥文件连接 ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(host_name, username=user_name, key_filename=private_key_path) 完整代码：
import paramiko # 创建SSH客户端 ssh = paramiko.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82990bd853a515b674be26bbe282277c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a96e28d920dda23d816dc8dbbb96984/" rel="bookmark">
			2023数学建模国赛A题定日镜场的优化设计- 全新思路及代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景资料关键信息和要点如下：
定日镜：塔式太阳能光热发电站的基本组件，由纵向转轴和水平转轴组成，用于反射太阳光。
定日镜场：由大量的定日镜组成的阵列。
集热器：位于吸收塔顶端，用于收集太阳光并转换为热能。
太阳光：并非平行光线，是一束锥形光线。
定日镜工作原理：控制定日镜的法向，使得太阳光经定日镜反射后指向集热器中心。
建设区域：在指定的地理坐标和海拔高度的圆形区域内。
集热器尺寸：高8m、直径7m的圆柱形。
定日镜尺寸：平面矩形，边长在2m至8m之间，安装高度在2m至6m之间。
其他约束：吸收塔周围100m范围内不安装定日镜；定日镜底座中心间距需大于镜面宽度+5m。
计算时点：每月21日的几个特定时刻。
请建立模型解决以下问题：
问题 1 若将吸收塔建于该圆形定日镜场中心，定日镜尺寸均为 6 m×6 m，安装高度均为4 m，且给定所有定日镜中心的位置（以下简称为定日镜位置，相关数据见附件），请计算该定日镜场的年平均光学效率、年平均输出热功率，以及单位镜面面积年平均输出热功率（光学效率及输出热功率的定义见附录）。请将结果分别按表 1 和表 2 的格式填入表格。 思路概要：本题需要根据题目给出的定义以及计算公式逐个计算特定时间节点每片定日镜片的光学效率、热功率。然后将求得数据累加除以时间以获取年平均值。
详解：问题1中给出了镜面边长
，安装高度
附件1中给出了各个镜面的位置平面坐标。
由题干背景部分给出的信息，可以知道。计划建设的镜场坐标系以圆形区域中心为原点，正东方向为x轴正向，正北方向为y轴正向，垂直于地面向上方向为 z 轴正向建立坐标系。如下图所示：
由此可得，在镜面坐标系下，各个镜面的中心位置坐标为Oi，同时，根据规划的吸收塔高度为 80 m，得到集热器中心的位置坐标为O集热（0,0，80）
读取附件中的xy坐标数据并可视化：
import pandas as pd import numpy as np #读取&amp;整理数据 data=pd.read_excel('附件.xlsx') import matplotlib.pyplot as plt # Plot the x and y coordinates plt.figure(figsize=(10, 10)) plt.scatter(data['x坐标 (m)'], data['y坐标 (m)'], color='b', marker='s') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Spatial Distribution of Points') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a96e28d920dda23d816dc8dbbb96984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f2ef3c0865d6b6955f65b0d51463abd/" rel="bookmark">
			数学 {达布定理}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学 {达布定理}
@LOC: 1
达布定理 定义 条件: 函数在开区间 I I I上可导;
结论: 导函数 f ′ ( x ) f'(x) f′(x)在开区间 I I I上具有介值定理 (即: f ′ ( I ) f'(I) f′(I)值域集合 是个区间);
相关定义 #推论#
如果 f f f在 I I I区间上可导, 且 f ′ ( x ) f'(x) f′(x)在 I I I上不连续 则 f ′ ( x ) f'(x) f′(x)在 I I I上的间断点 一定是震荡间断点;
证明 (反证法):
1: 不会是第一类间断点, 因为如果 f ′ ( x 0 − ) , f ′ ( x 0 + ) f'(x_0 -), f'(x_0 +) f′(x0​−),f′(x0​+)都存在 (注意这是前提), 因为导数代表趋势 而且函数在区间 I I I上连续, 他们三者 会是相同的 即: f ′ ( x 0 − ) = f ′ ( x 0 + ) = f ′ ( x 0 ) f'(x_0 - ) = f'(x_0 + ) = f'(x_0) f′(x0​−)=f′(x0​+)=f′(x0​);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f2ef3c0865d6b6955f65b0d51463abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050801e16ff51853963e8805640e5d78/" rel="bookmark">
			在Feign的请求中添加统一的请求头或请求体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Feign配置自定义请求头参数 创建Feign对象创建连接器 最近有个需求需要对接第三方系统，在调用对方接口时需要在请求头中传入token信息。我想能不能使用Feign来调用第三方的接口，用Feign调用十分简洁，那么在Feign调用的时候如何把token信息放入请求头中呢？
创建Feign对象 在使用Feign调用内部服务时@FeignClient注解的value参数对应相应的服务名即可，在调用第三方接口时只需指定url参数为三方接口的链接即可。值得注意的是url参数也可以直接从yml中获取。
@FeignClient(name = "你的feign名字", url = "${你的yml中配置的三方url}", configuration = Remote56ApiFeignConfig.class) public interface Remote56ApiFeignClient { // 获取认证token @GetMapping(value = "/api/oauth/v1/getToken", headers = {"No-Need-To-Token=true"}) WlApiToken get56ApiTokenByAppId(@RequestParam("appId") String appId, @RequestParam("secret") String secret); } 创建连接器 在@FeignClient的参数中有个configuration字段可以传入自定义的配置，那么创建你的拦截器配置实现feign包下的RequestInterceptor连接器，重写apply方法来添加你的请求头。
@Slf4j @Configuration public class Remote56ApiFeignConfig implements RequestInterceptor { // 从yml中获取密钥 @Value("${appid}") private String appId; // 从yml中获取密钥 @Value("${secret}") private String secret; @Resource @Lazy // 这里需要延迟加载 private Remote56ApiFeignClient remote56ApiFeignClient; @Resource private RedisCacheUtil redisCacheUtil; /** * 不需要token请求头标识 */ public static final String NO_NEED_TO_TOKEN = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/050801e16ff51853963e8805640e5d78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352c8ea69bff460d581d68db5d42c723/" rel="bookmark">
			谷歌浏览器离线安装chrome（chrome离线安装）谷歌浏览器企业版、MSI（Microsoft Installer）和软件包（Standalone Installer）区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 下载地址下载安装包安装包文件类型MSI和软件包区别 安装（GoogleChromeStandaloneEnterprise64.msi） 下载地址 https://www.google.com/intl/zh-CN/chrome/
下载安装包 https://chromeenterprise.google/intl/zh_cn/browser/download/#windows-tab
点击下载，弹到另一个页面，稍等一会就开始下载了：
安装包文件类型MSI和软件包区别 MSI和软件包都是安装文件，但它们主要的区别在于使用场景和功能：
MSI（Microsoft Installer）：这是微软的安装程序包格式，通常用于企业环境，因为它可以与Active Directory和其他企业级软件部署工具配合使用。MSI文件提供了更多的自定义选项，例如通过命令行参数静默安装（无需用户交互）、选择安装路径等。此外，管理员可以通过Group Policy（组策略）远程部署MSI安装包到网络中的多台计算机。
软件包（Standalone Installer）：这是一个独立的安装程序，设计为个人用户直接双击运行并完成安装过程。相比之下，它的功能更为简单，主要适用于普通用户进行手动安装。
根据你的需求，如果你需要在多台计算机上进行安装，或者需要进行更复杂的安装配置，那么MSI可能是更好的选择。如果你只是想在一台电脑上进行简单的安装，那么软件包应该就足够了。
安装（GoogleChromeStandaloneEnterprise64.msi） 下载后发现有三个安装包：
三个文件都是Google相关的安装包，但它们有不同的功能：
GoogleChromeStandaloneEnterprise64.msi：这是Google Chrome浏览器的离线安装包，用于在没有网络连接的情况下安装Chrome浏览器。
EndpointVerification_2.0.3.msi：这是Google的端点验证工具，主要用于企业环境。该工具可以帮助IT管理员收集关于其组织内部使用的设备的信息，以便他们更好地了解并管理这些设备。
LegacyBrowserSupport_7.4.0.0_en_x64.msi：这是Google的遗留浏览器支持（Legacy Browser Support，简称LBS）插件。这个插件让IT管理员可以设置一些特定的网站在旧版浏览器中打开，而其他网站则默认在Chrome中打开。这对于一些只能在旧版浏览器中运行的企业应用非常有用。
如果只是想安装Chrome浏览器，只需要运行GoogleChromeStandaloneEnterprise64.msi即可。其他两个msi文件主要是为企业环境设计的。
我们双击GoogleChromeStandaloneEnterprise64.msi，它会自动安装，并且创建桌面快捷方式，不一会儿就安装好了。
ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a03136acceeb1d8018188de93b90d3/" rel="bookmark">
			在家也能轻松使用用友畅捷通T3管理财务，实现高效率远程办公！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 用友畅捷通T3借助cpolar实现远程办公1.1 在被控端电脑上，点击开始菜单栏，打开设置——系统1.2 找到远程桌面1.3 启用远程桌面 2. 安装cpolar内网穿透2.1 注册cpolar账号2.2 下载cpolar客户端 3. 获取远程桌面公网地址3.1 登录cpolar web ui管理界面3.2 启动远程桌面隧道3.3 获取远程桌面公网随机临时地址 4. 实现远程桌面控制4.1 打开远程桌面客户端4.2 使用cpolar所生成的公网tcp地址远程桌面4.3 输入账号密码4.4 远程畅捷通T3桌面 前言 在现代企业中，安全而高效地访问内网资源对于财务软件至关重要。本文将介绍如何使用 cpolar 内网穿透技术来构建一个安全、可靠且高效的内网穿透财务软件。
cpolar是一个功能强大的跨平台、内网穿透工具，它能够安全地将位于NAT或防火墙后面的本地服务器暴露给公共互联网。
1. 用友畅捷通T3借助cpolar实现远程办公 畅捷通T3解决了企业在异地多组织、多机构对财务汇总和对远程仓库、异地办事处的管理需求。它还提供了全面的财务业务一体化管理功能。通常，企业会将畅捷通T3在公司局域网下部署，但当员工出差或居家办公时，无法直接通过本地地址进行访问。
通过利用cpolar内网穿透，我们可以轻松地创建一个安全的隧道，将用友畅捷通财务管理系统安全地映射到公网上。cpolar会自动为我们生成一个公网地址，这样，无论员工是出差在外还是居家办公，只需要通过访问这个公网地址即可连接到公司局域网下的用友畅捷通系统。
cpolar的使用非常便捷，无需公网IP，也无需设置路由器。它支持http、https和tcp协议，并且提供永久免费使用，没有流量限制。
借助cpolar，我们能够轻松实现远程访问用友畅捷通财务管理系统，为员工提供便捷的远程办公体验。
1.1 在被控端电脑上，点击开始菜单栏，打开设置——系统 1.2 找到远程桌面 1.3 启用远程桌面 2. 安装cpolar内网穿透 2.1 注册cpolar账号 进入cpolar官网，点击右上角的免费注册，使用邮箱免费注册一个cpolar账号并登录
2.2 下载cpolar客户端 登录成功后，点击下载cpolar到本地并安装（一路默认安装即可）
cpolar安装成功后会默认安装两个样例隧道（可自行修改或删减）：
remoteDesktop：指向本地3389端口，tcp协议website：指向本地8080端口，http协议 本次我们可以直接使用remoteDesktop远程桌面隧道。
3. 获取远程桌面公网地址 3.1 登录cpolar web ui管理界面 在浏览器上访问127.0.0.1:9200，使用所注册的cpolar邮箱账号登录cpolar web ui管理界面（默认为本地9200端口）
3.2 启动远程桌面隧道 登录成功进入主界面后，我们点击左侧仪表盘的隧道管理——隧道列表，找到远程桌面隧道，并点击启动该隧道
3.3 获取远程桌面公网随机临时地址 隧道启动成功后，我们点击左侧仪表盘的状态——在线隧道列表，可以看到远程桌面隧道已经有生成了相应的公网地址，我们将公网TCP端口地址复制下来（注意tcp://无需复制）。
4. 实现远程桌面控制 4.1 打开远程桌面客户端 在控制端电脑上，点击桌面左下角的搜索栏，搜索远程桌面连接，并打开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a03136acceeb1d8018188de93b90d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d871451832855b378e79df647adb40b/" rel="bookmark">
			阿里云域名注册流程（图文教程很详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云域名注册流程很简单，先注册阿里云账号，账号必须通过实名认证；然后创建信息模版，个人或企业信息模板必须通过实名认证；然后想好域名名称和域名后缀；最后在阿里云域名注册官网进行新域名的注册。阿里云来详细说下阿里云域名注册流程、域名注册官方入口、域名代金券详细说明：
阿里云域名注册流程 本文阿里云域名注册流程是小白教程，包括阿里云账号域名、阿里云账号实名认证、域名信息模板实名认证、域名名称后缀选择、域名优惠口令、域名注册结算详细说明：
一：注册阿里云账号并完成实名认证 你需要注册一个阿里云账号，点击：注册阿里云账号
注册好了，然后到个人中心：
，做一下，实名认证，建议选择企业实名
二：创建域名信息模版 现在注册域名需要选择域名持有者，域名持有者可以是个人或企业，如果你的阿里云账号下没有已经通过实名核验的信息模板，则无法注册，会提示“亲，没有查询到可用的信息模板”，如下图：
亲，没有查询到可用的信息模板
所以，先去创建域名信息模板，再注册域名。
1、登录阿里云域名控制台
2、左侧栏选择“信息模板”--“创建新信息模板”，如下图：
阿里云域名注册创建信息模板
3、填写信息模板，个人企业均可，也可以选择使用账号信息填写，根据实际情况选择
域名信息模板填写
个人模板信息：个人需要上传身份证图片；填写姓名、地址、电话、电子邮件等信息；英文模板信息会自动生成；电子邮件需要完成邮箱验证，填写邮箱地址，阿里云系统会发送验证邮件给你的邮箱，收到后填写数字验证码即可。
企业模板信息：企业需要上传工商营业执照；填写企业名称、域名联系人、地址、电话和电子邮件；英文模板信息自动生成即可；电子邮件需要邮箱验证。
详细参考：阿里云注册域名创建信息模板教程及审核通过时间说明
根据提示填写并上传相关信息后，点“提交”。提交后阿里云将提交至注册局进行审核，信息无误的话，一般20分钟左右即可审核通过。
三：域名名称及域名后缀的选择 常见的域名后缀有com、cn、net等后缀，阿里云百科选择的是com域名。域名名称是指后缀前面的，名称可以是字母、数字或“-”。像com、cn这类域名是比较火的，很多抢手的域名都被别人注册了，也可以结合数字如365、51、58或省市区号。大家根据所在行业及网站内容，选择合适的域名名称。
如果已经选好了域名，可以忽略本步骤。
四：查询并注册域名 打开阿里云域名注册页面，查询域名是否已被注册，如下图：
域名注册加入清单
如上图所示，如果域名可以注册，点右侧的“加入清单”，如果注册多个域名，就都先加入清单。
然后点击“域名清单”，检查好想要注册的域名，然后点“立即购买”，如下图：
域名清单立即购买
选择域名购买年限，阿里云域名可以一次性购买1年、2年、3年、4年、5年、6年、7年、8年、9年及10年不等；选择域名持有者，根据实际情况选择个人或企业，选择刚刚已经通过实名认证的信息模板，如下图：
阿里云域名注册
五：阿里云域名优惠口令 优惠口令是阿里云官方推出的域名优惠码，目前没有com域名注册优惠口令，有com域名续费优惠口令，详细参考：阿里云域名优惠口令（续费/注册/转入）亲测有效
确认无误，点击右下角的“立即购买”，支付域名注册费用即可。
以上是阿里云域名注册全流程，包括阿里云账号注册、阿里云账号实名认证，域名信息模板实名认证、域名名称及后缀选择、域名优惠口令、域名代金券使用详细教程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a837522042b15af5f60909197d8596/" rel="bookmark">
			Cascader 级联选择器结合npm包“element-china-area-data“实现省市区级联选择 相关问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天把之前已经对接好的项目打开看了一下，发现省市区级联选择器出现了问题... 接下来就给大家分享一下
遇到的第一个问题就是 级联组件中change事件中内容出现了错误，简单排除了一下，是引入element-china-area-data中的方法codeToText导致的...
因为我之前在开发的时候，装的是这个包的最新版本，是完全没有问题的，然后在提交代码的时候，发现公司的架子里是有这个包的（"^5.0.2"），我就果断把我装的给撤了...我就考虑是不是包版本带来的问题，然后去仔细查阅了一下，发现不同版本的包，导出的方法是有区别的... import { regionData, codeToText } from 'element-china-area-data'; "^6.0.2" import { regionData, CodeToText } from 'element-china-area-data'; "^5.0.2" 相信你们善于发现美的眼睛已经看出点东西了... 我当时将codeToText替换为CodeToText完美解决这个问题...
但是bug总是不忍心看到你这么轻松的样子... 再来看下遇到的第二个问题，就是编辑的时候，级联数据不能正常回显了，简直我草了...
由于是组件数据的回显问题，当时的我还不能确认是包版本带来的问题，就果断去查了是否存在绑值以及赋值的问题，查了一下没发现有什么，又将code的数组改为text的数组，发现还是回显不了，由于这个包也是和Element下的，也就往版本问题的方向去考虑，然后果断下载了新的版本，完美解决...
感觉对自己有帮助的小伙伴，可以留个star...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c55565cd9359c7a98beb2c94210b1f5/" rel="bookmark">
			Codeforces Round 895 (Div. 3)A~E题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.A. Two Vessels 链接： Problem - A - Codeforces
题解： 直接暴力枚举，假设a&lt;b，不断让a加c，b减c，直至a&gt;=b，输出答案即可。
AC代码： //gyeolhada...in bloom...dream...ricky //string s="ricky";s.insert(0,"hello ");--&gt;hello ricky //transform(s.begin(), s.end(), s.begin(), ::tolower); //2^30=1e9+73741824 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define sall(x) (x).begin(),(x).end() #define ball(x) (x).rbegin(),(x).rend() #define pii pair&lt;int,int&gt; #define pll pair&lt;ll,ll&gt; #define inf 0x3f3f3f3f3f3f3f3f #define Y cout&lt;&lt;"YES"&lt;&lt;endl #define N cout&lt;&lt;"NO"&lt;&lt;endl	void ZB1() { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a&gt;b)swap(a,b); int ans=0; while(a&lt;b)a+=c,b-=c,ans++; cout&lt;&lt;ans&lt;&lt;endl; } int main() { int t; cin &gt;&gt; t; while (t--) { ZB1(); } return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c55565cd9359c7a98beb2c94210b1f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ba7b1500e4f70eab154c3ba02834d6/" rel="bookmark">
			基于Java SSM&#43;layui&#43;mysql实现的图书借记管理系统源代码&#43;数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍 本项目使用的技术栈是SSM+layui+mysql，服务器使用的是tomcat 其中书籍图片存放的位置需要先在tomcat根目录下conf/setting.xml中配置虚拟路径，本项目配置的是D:\upload
完整代码下载地址：图书借记管理系统
用户角色划分 游客 使用本系统的未登录的用户，可以检索并查看馆内图书信息，通过注册可以成为用户用户 使用本系统已登录的用户，可以查看自身借阅情况，并拥有修改密码，手机号信息功能图书管理员 可以查看馆内相关数据，对用户借阅、归还及续订图书进行处理，已经查看图书馆再借图书信息及借阅历史管理员 本系统的最高权限用户，可以对馆内图书，用户及数据字典进行管理 需求说明 前台服务功能
首页功能： 图书搜索：根据图书信息（图书名、作者、出版社）、图书类别以及有无库存等进行搜索图书详情：点击图书下方的查看详情，可以看到该图书相关的所有信息（图书名、出版社、作者、位置等）登录注册： 登录注册：通过登录或注册成为用户，成功后回到首页查看个人信息： 查看个人信息:用户可以看到自己的基本信息修改手机号码:用户可以修改自己的基本信息上的手机号码查看借阅信息： 查看借阅信息：用户可以看到自己的正在借阅的图书及借阅状态修改密码： 修改密码：用户可以输入新密码修改密码 后台管理功能
工作区功能： 借阅：图书管理员可以根据图书编号及用户账号进行对用户借阅图书进行处理归还/续订：图书管理员可以根据用户账号查找到其在借图书，并对这些图书进行归还或者延续借阅时间借阅管理： 查看借阅情况：图书管理员可以查看并搜索图书馆现在借图书的借阅情况删除借阅情况：图书管理员可以删除在借图书的借阅情况提醒用户还书：图书管理员可以对指定的借阅了图书的用户进行消息提醒查看借阅历史：图书管理员可以查看并搜索图书馆借阅历史删除借阅历史：图书管理员可以删除图书馆借阅历史数据展示： 数据展示: 图书管理员可以查看到一些图书馆相关数据统计，例如各种类图书数量、借阅图书、用户总数等图书管理： 添加图书：超级管理员对新入馆图书添加到系统中删除图书：超级管理员删除馆内下架的图书修改图书：超级管理员修改系统内图书的相关信息查询图书：超级管理员可以查看并搜索系统内所有图书用户管理： 添加用户：超级管理员可以添加不同角色的用户删除用户：超级管理员可以删除用户修改用户：超级管理员修改系统内用户的基本信息查询用户：超级管理员可以查看并搜索系统内所有用户数据字典管理： 添加字典值：超级管理员可以添加数据字典中某一类型的值添加字典类型：超级管理员可以添加数据字典中的类型修改字典值：超级管理员可以修改数据字典中字典值内容或切换其所属类型删除字典值：超级管理员删除数据字典中某一类型的值，若删除后该类型无对应值，则该类型自动删除查询数据字典：超级管理员可以查看并搜索数据字典 项目运行截图 登录界面： 注册界面： 系统首页： 工作区： 借阅情况： 借阅历史： 图书管理： 用户管理： 数据字典管理： 数据统计： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa7cb3cc0b9beb59e5c9913c8e8028e/" rel="bookmark">
			毕业设计基于Springboot&#43;layui&#43;mysql实现的在线考试系统源代码&#43;数据库&#43;部署文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整代码下载地址：基于Springboot+layui+mysql实现的在线考试系统源代码+数据库+部署文档
1. 部署相关 1.1. 介绍 一个 JAVA 实现的在线考试系统,主要实现一套基于不同类型的客观题,进行自动组卷、批卷等功能的考试系统（没有主观题）
1.2. 系统架构 后端技术栈基于 Spring Boot数据库MySQLORMMyBatis &amp; MyBatis-plus缓存Redis、guava的LoadingCache安全ShiroExcel 导出easyexcel日志slf4j、log4j2图片上传qiniu其它工具swagger、hutool、guava、hibernate-validator 实在是不怎么懂前端 [菜…]
前端技术栈基于 layui模板引擎thymeleaf表格展示echart 1.3. 部署 单纯启动：
安装 Mysql 并执行 sql 文件, 修改数据源配置 ,见 test-system.sql 、 application.yaml
启动！！
部署服务器：相比上面,多个几个步骤
启动！！
使用mvn clean install 打包项目为 jar 包,我 IDEA 里打包不成功,一定要通过 cmd 进入项目文件夹再执行这个命令（具体原因好像是 IDEA 打包默认没有使用 springboot 的打包插件）推到服务器中,再执行java -jar xxx 启动！！ 2. 需求分析 2.1. 基础功能 登录、注册 首页公告栏 操作日志 2.2. 学生 查询考试列表 参加考试 查看错题集 成绩分析 2.3. 教师 审批管理：管理请求绑定自己班级的审批 学生管理：管理自己班级下的所有学生 班级管理：管理自己的班级 考试管理：发布考试（自动生成试卷）、修改考试信息、取消考试 成绩统计 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa7cb3cc0b9beb59e5c9913c8e8028e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6458442591fce5b79fae3fb1f82b5c1/" rel="bookmark">
			图像加密算法毕业论文【含代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在写论文的时候，也看了很多相关的文章和大神的帖子，对于定题，写作等方面有很多经验和大家分享下。
总的来说，最重要的就是定的题目要确保后续能够写的出来，写的顺畅。论文需要的数据提前准备好，案例提前查阅清楚，文献在定题目前至少看上几十篇。
我是资深论文从业者，专职写论文，所以信我的没错。
这里也总结了适合今年毕业生的选题，几乎涵盖了所有选题方向。有简单的，有难的。有的题目可以直接用，有的还需要再细化下，稍微改动一下，也能作为创新的选题。
后续会陆续更新
——————————————————————————————
混沌系统设计及其在图像加密中的应用
改进混沌的图像加密算法研究
基于三值忆阻器超混沌系统的图像加密算法设计与实现
基于傅里叶单像素成像的图像加密和认证算法研究
基于视觉密码的图像加密及其安全性研究
基于压缩感知和区块链的核环境监测影像增强重构研究
多参数图信号处理方法及其应用研究
基于分数阶变换和混沌系统的双图像加密算法
基于混沌系统的无损图像加密算法
基于分数阶矩变换和非线性置乱扩散的彩色图像加密算法
基于混沌系统和四元数分数变换的多图像加密算法
基于DQWT和量子卷积神经网络的量子图像加密
基于三维动态整数Tent映射的图像加密算法研究
基于混沌系统的图像信息加密算法研究
基于彩色条码的信息加密方法研究
数字混沌映射的动力学特性改进及其在图像加密中的应用研究
一类基于二次剩余密码体制的构造与图像加密研究
基于混沌系统和半张量积压缩感知的图像加密算法研究
基于云端加密图像的安全技术研究
三种数字图像加解密算法研究与GUI工具开发
基于混合混沌系统和动态DNA编码的图像加密
彩色QR码混沌加密隐藏及无损提取算法研究
基于混合加密算法的彩色QR码技术研究与实现
基于DNA计算与位级置换的混沌图像加密算法及其网络脉冲牵制簇同步控制研究
脉冲治理害虫Gompertz模型中的混沌及其在图像加密中的应用
基于复合混沌系统的视频加密技术研究
基于多混沌系统的数字图像加密压缩算法
基于混沌的彩色图像加密算法研究
基于二维混沌映射的图像加密算法研究
基于细胞神经网络的图像混沌加密算法研究
基于混沌系统和压缩感知的图像加密算法研究
基于混沌理论的数字图像加密算法研究与实现
基于混沌的数字图像加密算法设计与仿真
基于RSA与DCT的图像信息加密隐藏算法研究
基于半张量积压缩感知的图像加密算法
若干数字图像置乱算法及相关理论研究
基于混沌和压缩感知的图像压缩加密系统设计与实现
混沌S盒的优化设计及其在图像加密中的应用研究
一类具有置换-扩散结构的图像混沌密码安全分析
基于HVS特性的图像视觉安全评价方法
面向政务图像数据的隐私保护方法研究与实现
基于混沌的空、频域图像加密算法设计
基于对抗神经网络和混沌系统的图像加密算法
基于图像位平面的加密算法研究
混沌序列复杂度算法及其在图像加密中的应用研究
基于混沌系统和DNA计算的图像加密方案
基于ZUC-256算法的图像加密系统设计及硬件实现
基于五维超混沌系统的彩色图像加密研究
基于多混沌系统的图像加密算法研究
基于复合混沌系统的图像加密算法研究
基于新型压缩感知技术的医学图像安全传输
基于多层预测和分级压缩的加密域可逆信息隐藏算法研究
基于多策略标记编码的加密图像可逆信息隐藏算法研究
基于直方图平移的JPEG图像加密域可逆信息隐藏算法研究
针对组合多重置乱图像加密的低代价选择明文攻击
基于块截断编码的图像加密域可逆信息隐藏算法研究
混沌图像加密算法的分析与设计研究
基于混沌的多图像加密算法研究
基于压缩感知的图像混沌加密算法研究
两种基于混沌的图像加密算法的差分分析研究
一类图像混沌加密算法的安全分析
基于混沌的社交多媒体加密算法研究
视频混沌加密技术的研究及Android平台实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6458442591fce5b79fae3fb1f82b5c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19919ff5803d205493f5212632e709fd/" rel="bookmark">
			华为云云耀云服务器L实例评测 | 宝塔8.0镜像应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🍒写在前面
🍒产品优势
🍒购买服务器
🍒服务器配置
🍒登录宝塔页面
🦐博客主页：大虾好吃吗的博客
🦐专栏地址：闲谈专栏地址
写在前面 云耀云服务器L实例是新一代开箱即用、面向中小企业和开发者打造的全新轻量应用云服务器。云耀云服务器L实例提供丰富严选的应用镜像，实现应用一键部署，助力客户便捷高效的在云端构建电商网站、Web应用、小程序、学习环境、各类开发测试等。
产品优势 1、智能不卡顿
华为云擎天架构加持，软硬协同结合AI算法智能调度，为您提供优质性能。
华为云全球存算一张网，数据传输时延比眨眼还短，满足游戏、音视频等低网络时延场景的高要求。
2、价优随心用
超高性价比，超低门槛，敞开随心用。
多种实例规格，平衡性能与成本。
技术升级优化用云成本，普惠更多初创企业和开发者。
3、上手更简单
多种镜像、资源组合一键下单。
严选多款高品质镜像，经过华为云官方严格测试，覆盖七大场景，预置模板，快速搭建，安全可信。
自动化编排，资源一键开通，业务分钟级上线。
平滑学习曲线，向导式应用搭建，应用轻松启用。
4、管理更省心
拓扑、资源、镜像可视化管理，业务架构透明化管理。
贴心服务状态提醒，资源续退一键式操作，实现极简管理。
资源负载、安全，使用率实时监控，保障服务永远在线。
可选配丰富的安全服务，包括丰富的备份、主机安全等服务，提供最高等级的安全防护。
云耀云服务器L实例与弹性服务器（ECS）的主要区别：
云耀云服务器L实例可以快速搭建简单应用，按已搭配的套餐售卖，适用于低负载应用场景，可以更加便捷、更加高效的部署、配置和管理应用。
ECS提供多种计费模式、规格类型、镜像类型、磁盘类型，针对不同的业务场景，自定义配置弹性云服务器。
购买服务器 登录华为云官网，产品页面中选择云耀云服务器L实例，根据对服务器的需求选择合适的实例规格，以及镜像，我这里选择的是应用镜像宝塔8.0面板。
服务器配置 购买完成后，需要进行两方面配置，修改服务器密码（创建），添加安全规则。
登录宝塔页面 宝塔界面默认地址为http://服务器IP:8888，通过web界面访问出现下图界面。
默认给出的地址为随机，通过后面命令修改为abc123456，用户名为administrator。登录宝塔面板后绑定账号就可以根据需求使用了。
root@hcss-ecs-a18d:~# cat /credentials/password.txt ========= credentials for bt ========= bt_user: administrator bt_password: sjGTawRn0Yw99P! ​ root@hcss-ecs-a18d:~# cd /www/server/panel &amp;&amp; btpython tools.py panel abc123456 administrator administrator 绑定宝塔账号后，可定制化安装服务，根据需求安装即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2123680884f841392f17f63e5705f25a/" rel="bookmark">
			mac 环境下mysql登陆失败问题Access denied for user ‘root‘@‘localhost‘ (using password: YES)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库连接问题 在mac环境下，各种软件老是出现莫名其妙的问题，今天mysql遇到了一个问题，很懵逼，明明是正确的密码却登陆不进去，很难受。后来一个老哥说是因为系统认为MySQL认为安装时提供的随机密码不安全，让用户重置密码。当然，我自己不知道怎么回事，我觉得也有可能是自己的密码错了。错了，那就修改密码吧，我把我的操作过程记录下来供大家参考。
第一步：关闭mysql 苹果-&gt;系统偏好设置-&gt;最下面点MySQL，关闭mysql服务
第二步：进入终端设置 1、进入终端输入(cd /usr/local/mysql/bin/)回车
cd /usr/local/mysql/bin/ 2、输入(sudo su)回车以获取管理员权限
sudo su 这里你要注意，当你输入sudo su时，你需要输入的你自己电脑的管理员密码(允许安装软件的那个密码)
3、输入(./mysqld_safe --skip-grant-tables &amp;)回车以禁止mysql验证功能，mysql会自动重启，偏好设置中的mysql状态会变成running。
./mysqld_safe --skip-grant-tables &amp; 4、输入命令(./mysql)回车
5、输入命令(flush privileges;)分号别忘记输了
6、重置密码：ALTER USER 'root'@'localhost' IDENTIFIED BY '你的新密码';
7、执行 quit；退出mysql
8、执行 exit；退出sudo
9、密码重置已完毕，可以试试登陆mysql。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18cf2ef69a199a894e385494407aa681/" rel="bookmark">
			Android Studio中logcat的工具栏消失了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android studio调试时logcat窗口被我误删了，该怎么设置才能重新显示出来 在view --》Android Monitor --》logcat 就OK了
Android Studio中logcat的工具栏消失了 具体操作：先把logcat移出工具栏，然后再移回去。消失的部分就又出现了，很神奇吧！
1.右键 view mode --》 float 2.右键 view mode --》Undock 这样就OK了，思路就是，先移出去，再移回来
微信公众号【码农园区】，技术分享，值得关注 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b96c51256b6927ae18843f4db35d1b/" rel="bookmark">
			Nginx如何重定向 https，成功http80自动跳转https443！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/usr/local/nginx/conf/nginx.conf
#这个位置进行配置
server { listen 80; server_name derfoe.cn; return 301 https://$server_name$request_uri; } 如果已经配置好了SSL 以上配置就可以成功
如果未配置SSL，要先配置SSL证书
以下的 只需要更换域名，还有一个网站路径defult
此域名以 derfoe.cn 域名为例！
######################## default ############################ #只需要将下面部分替换掉，从这开始 ，只需要改SSL证书文件路径 ########################## #重定向句子 server { listen 80; server_name derfoe.cn; return 301 https://$server_name$request_uri; } server { listen 443 ssl; server_name _; access_log /data/wwwlogs/access_nginx.log combined; # ssl证书地址 ssl_certificate /usr/local/nginx/cert/derfoe.cn.pem; # pem文件的路径 ssl_certificate_key /usr/local/nginx/cert/derfoe.cn.key; # key文件的路径 # ssl验证相关配置 ssl_session_timeout 5m; #缓存有效期 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议 ssl_prefer_server_ciphers on; #使用服务器端的首选算法 root /data/wwwroot/derfoe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b96c51256b6927ae18843f4db35d1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec843f093af336a678e4b356a4d8b2cf/" rel="bookmark">
			【BUG】【Ubuntu】apt-get install E: 无法下载 XXXXX 暂时不能解析域名“mirrors.tuna.tsinghua.edu.cn”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 之前正常下载没问题，但是今天下载qemu突然就出现了问题，无法下载。
使用的apt源是清华源。
BUG描述 E: 无法下载 https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/e/edk2/qemu-efi-arm_2022.05-4_all.deb 暂时不能解析域名“mirrors.tuna.tsinghua.edu.cn” E: 有几个软件包无法下载，要不运行 apt-get update 或者加上 --fix-missing 的选项再试试？
解决办法 尝试1：按照提示的，首先尝试apt-get update/--fix-missing,但是失败了，仍然报同样的错误
尝试2：想到操作系统上的一句话，“重启是良药”，于是把Ubuntu重启了，就ok了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8211d76f5af0d9e26caf384eb7dd752/" rel="bookmark">
			video标签自动播放音视频并绘制波形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html中的&lt;video&gt;标签可以用来播放常见的音视频格式，支持的格式包括:MP3、Ogg、WAV、AAC、MP4、WebM、AVI等，当然支持的格式也和浏览器和操作系统有关。这里以一个可以自动播放音视频并绘制波形图的页面为例说明一下&lt;video&gt;标签的用法。
video标签想自动播放，需要设置三个可选属性分别是muted、autoplay、controls，muted负责让音视频播放静音，autoplay让音视频自动播放，controls属性负责显示对应的控制菜单。除了通过html页面设置标签属性之外我们还可以通过js脚本来设置对应的属性，设置方法如下所示:
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;播放音视频&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;video id="myVideo" autoplay muted controls&gt; &lt;source src="./mysong.mp3" type="audio/mpeg"&gt; &lt;!--source src="video.mp4" type="video/mp4"--&gt; Your browser does not support the video tag. &lt;/video&gt; &lt;script&gt; var videoElement = document.getElementById('myVideo'); // 自动静音播放 videoElement.muted = true; videoElement.autoplay = true; videoElement.controls = true; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 浏览器为了防止页面自动播放音频干扰用户，不允许在用户没有进行交互操作的时候，网页自动以非静音的模式播放音视频。所以autoplay属性必须搭配muted属性一块使用。
如果想要绘制音视频播放过程中的音频波形图，我们需要拦截对应的音频上下文，分析绘制对应的音频数据。对应的实现如下所示:
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;绘制音频波形图&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;绘制音频波形图&lt;/h1&gt; &lt;video id="myVideo" controls&gt; &lt;source src="./mysong.mp3" type="audio/mpeg"&gt; Your browser does not support the video tag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8211d76f5af0d9e26caf384eb7dd752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c05e1b14d8eed1d864d5fbc5850cf95/" rel="bookmark">
			SpringMvc导出Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!--导出Excel用包--&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
&lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt;
&lt;version&gt;3.10-FINAL&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
&lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;
&lt;version&gt;3.10-FINAL&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
&lt;artifactId&gt;poi&lt;/artifactId&gt;
&lt;version&gt;3.10-FINAL&lt;/version&gt;
&lt;/dependency&gt;
控制层代码:
@RequestMapping("toExportDone")
@ResponseBody
public String exportDo(HttpServletResponse response){
response.setContentType("application/binary;charset=UTF-8");
try{
ServletOutputStream out=response.getOutputStream();
String fileName=new String((new SimpleDateFormat("yyyy-MM-dd").format(new Date())).getBytes(),"UTF-8");
response.setHeader("Content-disposition", "attachment; filename=" + fileName + ".xls");
String[] titles = { "用户编号", "用户姓名", "用户地址" };
export(titles, out);
return "success";
} catch(Exception e){
e.printStackTrace();
return "导出信息失败";
}
}
public void export(String[] titles,ServletOutputStream out) {
// 1.创建一个workbook，对应一个Excel文件
HSSFWorkbook workbook = new HSSFWorkbook();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c05e1b14d8eed1d864d5fbc5850cf95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487f72af229fc7e8eb4c6601f729a01d/" rel="bookmark">
			pyttsx3 初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、pyttsx3 概述 pyttsx3是Python中的文本到语音转换库。与其他库不同，它可以脱机工作，并且与Python 2和3兼容。
二、安装 pip install pyttsx3 三、简单示例 #!/usr/bin/env python # -*- coding:utf-8 -*- import pyttsx3 """ 语音播放 Hello World """ pyttsx3.speak("Hello World!") 或者
#!/usr/bin/env python # -*- coding:utf-8 -*- import pyttsx3 """ 语音播放 Hello World """ engine = pyttsx3.init() engine.say("Hello World!") engine.runAndWait() 备注：其实 pyttsx3.speak 内部实现就是第二端代码
四、进阶示例 #!/usr/bin/env python # -*- coding:utf-8 -*- engine = pyttsx3.init() # object creation """ 把语音存储到文件 """ engine.save_to_file("Hello World!!!",'~/abc.mp3') """更改速率""" rate = engine.getProperty('rate') # getting details of current speaking rate print (rate) # printing current voice rate engine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/487f72af229fc7e8eb4c6601f729a01d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68eb9d9b6781af5c7adf6177af4cb743/" rel="bookmark">
			eNSP基本命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单交换机VLAN划分
进入系统视图 system
进入系统视图 system-view
退到系统视图 quit
删除vlan 20 undo vlan 20
交换机命名 sysname
显示vlan disp vlan
创建vlan(也可进入vlan 20) vlan 20
把端口1-5放入VLAN 20 中 port e1/0/1 to e1/0/5
显示vlan里的端口20 disp vlan 20
进入端口24 int e1/0/24
把当前端口放入vlan 20 port access vlan 20
表示删除当前VLAN端口10 undo port e1/0/10
查看当前配置 disp curr
删掉配置的命令 复制命令在前加undo
路由器基本配置命令
命名路由器(或交换机) sysname router_name
删除Flash ROM中的配置 delete
将配置写入Flash ROM save
进入接口配置模式 interface serial 0
退出接口模式到系统视图 quit
关闭/重启接口 shutdown/undo shutdown
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68eb9d9b6781af5c7adf6177af4cb743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b1d9faedee3ebbfd45d93e229f51c8/" rel="bookmark">
			NOMA学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NOMA（非正交多址接入技术） NOMA基本概念上行NOMA与下行NOMA上行NOMA（MAC信道）下行NOMA（BC广播信道） SIC解码顺序叠加编码（SC）与串行干扰消除（SIC）叠加编码（superposition code，SC）串行干扰消除（SIC） NOMA基本概念 NOMA，全称是Non-Orthgonal Multiple Access，对应中文是非正交多址接入。
基本思想是在发送端采用非正交发送，主动引入干扰信息，在接收端通过串行干扰消除（SIC）接收机实现正确解调。
NOMA是非正交多址，而并非非正交频分，即NOMA的子信道传输仍然采用OFDM，子信道之间是正交的。但是一个子信道上不再只分配给一个用户，而是多个用户共享，同一子信道上不同用户之间是非正交传输。
在发送端，对同一子信道上的不同用户采用功率复用技术进行发送，不同用户的信号功率按照相关的算法进行分配，这样到达接受端每个用户的信号功率都不一样，SIC接收机再根据不同用户信号功率大小按照一定的顺序进行干扰消除，实现正确解调，同时也达到了区分用户的目的。
上行NOMA与下行NOMA 上行NOMA（MAC信道） 特点：多点发送、单点接收，单用户功率受限，同时发送的用户数越多则总功率越高，发送端难以联合处理而接收端可以联合处理。
下行NOMA（BC广播信道） 特点：单点发送、多点接收，总发送功率受限，发送端可以联合处理而接收端难以联合处理。
对于信道质量差即信道增益低的用户，给之分配更高的功率，反之，分配更低的功率。这便引出了功率分配问题。
可行的优化目标：
总功率受限，最大化下行速率 SIC解码顺序 下行NOMA中，基站将不同用户的信号叠加在一起，UE来实现连续干扰消除技术；而在上行中，基站来实现多用户检测和连续干扰消除技术。
在NOMA下行场景中，基站侧将用户1和2的信号叠加在一起，即
对于User1，接收信号y1=h1x+n1，对于User2，接收信号y2=h2x+n2。
弱用户User1直接解出自己的信号即可，此时将User2的信号当做干扰。
强用户User2先解出User1的信号，然后User2从其接收信号中减去User1的信号，再解自己的信号。
由于基站进行功率分配时，需要用到下行信道状态信息h1和h2，那基站是怎么知道下行CSI的？可以利用信道互易性或者UE利用上行信道进行反馈。
在NOMA上行场景中，基站侧解码顺序：
基站先解码出强用户User2的信号，然后从接收信号减去恢复出来的强用户的信号，之后再解弱用户User1的信号。
UE侧的处理能力有限，且缺少中心处理单元，因此上行链路相较于下行链路中更容易实现。
叠加编码（SC）与串行干扰消除（SIC） 叠加编码（superposition code，SC） 基站侧将不同用户信号进行叠加：
手机侧进行解码：
对于User1来说，收到叠加信号时，先进行均衡（即通过信道估计出h1，并对接收信号乘以h1的逆），然后直接解调出自己信号即可。
对于User2来说，收到叠加信号时，先进行均衡（即通过信道估计出h2，并对接收信号乘以h2的逆），先解调出User1的信号，随后重构出User1的信号，再从接收信号减去重构的User1信号，然后解调出User2的信号。
下面这段代码，是下行NOMA中，User1和User2在总功率约束的情况下，进行功率分配的过程。
% Calculate Power coefficients for each pair txParams.powerCoeffs = zeros(txParams.numUsers, 1); if (txParams.pwrAllocMthd == 1) for iter_pairs = 1: txParams.numUsers / 2 txParams.powerCoeffs(txParams.userPairs(iter_pairs, 1), 1) = (sqrt(1 + txParams.sysPower * abs(txParams.est_CSI(txParams.userPairs(iter_pairs, 2), 1)) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b1d9faedee3ebbfd45d93e229f51c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6e6e7f2e32cbb6c8cee6f6d34c814b/" rel="bookmark">
			Linux命令200例：mount将文件系统挂载到指定目录下（常用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Linux mount命令简介二、mount命令的语法三、mount命令的实际应用 3.1 挂载硬盘分区3.2 挂载ISO镜像文件3.3 挂载网络文件系统3.4 挂载Windows共享文件夹3.5 挂载RAM虚拟文件系统3.6 查看已挂载文件系统3.7 卸载文件系统3.8 自动挂载文件系统 四、总结 一、Linux mount命令简介 mount命令是Linux系统中的一个重要命令，其功能是将文件系统挂载到指定目录下。通过挂载，可以使得文件系统中的数据能够在操作系统中访问和使用。
二、mount命令的语法 mount命令的基本语法如下：
mount [-lrvf] [-t fstype] [-o options] device dir 其中，常用的选项包括：
-l：显示当前已挂载的文件系统。-r：以只读模式挂载。-v：显示详细的挂载信息。-f：强制挂载。-t fstype：指定文件系统类型。-o options：指定挂载选项。 三、mount命令的实际应用 下面给出8个实际的例子，以帮助读者更好地理解和运用mount命令。
3.1 挂载硬盘分区 假设我们有一块新的硬盘分区/dev/sdb1，需要将其挂载到/mnt目录下：
$ sudo mount /dev/sdb1 /mnt 3.2 挂载ISO镜像文件 如果我们有一个名为ubuntu.iso的ISO镜像文件，并需要将其挂载到/mnt目录下：
$ sudo mount -o loop ubuntu.iso /mnt 3.3 挂载网络文件系统 如果我们需要挂载一个远程主机上的NFS文件系统到本地/mnt目录下：
$ sudo mount -t nfs 192.168.1.100:/share /mnt 3.4 挂载Windows共享文件夹 如果我们需要将Windows共享文件夹挂载到Linux系统的/mnt目录下：
$ sudo mount -t cifs //192.168.1.100/share /mnt -o username=user,password=pass 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6e6e7f2e32cbb6c8cee6f6d34c814b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551ee8d9f8cc597656de77fd018fa78b/" rel="bookmark">
			《Python魔法大冒险》010 魔法宝箱：列表与元组的探险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		城堡的大门 随着小鱼和魔法师的深入，他们来到了一个古老的废弃城堡。城堡的大门上挂着一个巨大的锁，而锁的旁边有一排小抽屉，每个抽屉里都有一个物品。
魔法师对小鱼说：“这是一个古老的魔法宝箱，小鱼。为了打开这扇门，我们需要正确地组合这些物品。在Python的魔法世界中，我们使用列表和元组来存储和组合多个物品。”
小鱼：列表和元组？
魔法师继续说：“列表就像这些抽屉，你可以在其中放入任何物品，并随时添加或删除。而元组，就像一个封闭的魔法袋，一旦你放入物品，就不能再更改它。”
小鱼仔细地观察每个抽屉，然后说：“我看到每个抽屉上都有一个数字，这是不是它们的位置？”
魔法师点了点头：“正是如此，这就是列表中的索引。每个物品在列表中都有一个唯一的位置，从0开始计数。所以，第一个物品的索引是0，第二个物品的索引是1，以此类推。接下来让我详细给你讲讲。”
列表与元组是一种能让你组织和管理数据的超能力！
1．创建列表
想象一下，你有三个神奇魔法球。在Python中，我们可以用方括号[]来创建一个列表，像这样：
magic_balls = ["红球", "蓝球", "绿球"] print("我有以下神奇魔法球：", magic_balls) 这段代码告诉计算机：“我有三个神奇魔法球，它们分别是红球、蓝球和绿球。请把它们列出来！”。计算机听懂了，会把列表中的魔法球展示出来。
2．添加和删除
当你获得了新的宝物，你可以把它添加到列表中。就像捡到一颗闪闪发光的宝石：
magic_balls.append("闪亮宝石") print("我有以下神奇魔法球：", magic_balls) # 输出：['红球', '蓝球', '绿球', '闪亮宝石'] 这段代码告诉计算机：“我捡到了一颗闪亮宝石，加入到我的魔法球列表中！”。计算机听懂了，会把新的宝物添加到列表末尾。
当你觉得某个宝物已经不再神奇，你可以把它从列表中移除。就像将一个有瑕疵的魔法药水丢掉：
magic_balls.remove("红球") print("我有以下神奇魔法球：", magic_balls) # 输出：['蓝球', '绿球', '闪亮宝石'] 这段代码告诉计算机：“把那个不神奇的红球从我的列表中去掉！”。计算机听懂了，会把红球从列表中删除。
3．访问列表元素
每个元素在列表中都有一个唯一的位置，称为索引。索引从0开始计数，与字符串下标位置类似。
例如：
magic_balls=['蓝球', '绿球', '闪亮宝石'] print("第一个元素是："+magic_balls [0]) # 输出：蓝球 print("第二个元素是："+magic_balls [1]) # 输出：绿球 要访问第一个元素（“蓝球”），你可以使用 magic_balls [0]。要访问第二个元素（“绿球”），你可以使用 magic_balls [1]。 4．交换列表元素位置
交换列表中两个元素的位置是一个常见的操作。这通常需要使用一个临时变量来完成，但在Python中，我们可以使用一个简洁的方法来交换两个元素。
例如，要交换上面列表中的"蓝球"和"绿球"，你可以这样做：
magic_balls [0], magic_balls [1] = magic_balls [1], magic_balls [0] 这行代码的意思是，将magic_balls [0]和magic_balls [1]的值交换。执行这行代码后，列表变为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551ee8d9f8cc597656de77fd018fa78b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d782640e3bd50473b857a520dd9f4722/" rel="bookmark">
			[MIT]微积分重点学习笔记 目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先介绍下自己的情况，大学的时候学习不认真，很多概念都忘记了，工作中有时要用到微积分，碰到不会的在网上查询，感觉这样学习的比较零散，也不能建立系统的认识。多次想要从头看一遍同济版《高等数学》也只是停留在前几页，配套的网课也听过，但是都没坚持下来。在知乎看到大神杨熙写学习笔记后，打算自己也跟着学习一波，于是就有这篇笔记，由于数学基础比较差，会写得会比较仔细，如有错误，请大家指出，谢谢！
之前看过Gilbert Strang教授的线性代数课程，感觉受益良多。但是之前都是把笔记记在本子上，不利于回看，后续有时间会慢慢整理成电子版，发布出来。下面是教授在本课程简介里说的：
大多数人学微积分只是想了解下重点，本课程就是以此为目的。Strang教授认为学习微积分的时候很容易在厚厚的课本和大量的习题中迷失方向，过分拘泥于细节，无法得到提纲挈领的认识，教授希望该课程能提供一种总览。
我倒是觉得课程没有习题是比较坑的地方，这里放出课程地址和B站搬运视频，课程地址里的书籍我只看了第一章，这里就不推荐了。倒是可以配合 《普林斯顿微积分读本》 和图解普林斯顿微积分读本一起看。
碎碎念：看完线代课程再看这个突然发现教授已经那么老了o(╥﹏╥)o，唉~~。
PS：此时，已将《普林斯顿微积分读本》看了一遍，之前看完视频以为自己学的差不多了，再回头看，其实不过入了个门。做题时会发现自己连概念都没有理清。又转念一想，如果看个视频就能学会，是不是太草率了，该笔记能够起到抛砖引玉的作用也是极好的。——写于2022.06.04
PPS：在B站看了一半（高数上册）宋浩的视频，并做了板书截图笔记，受益良多，对于我是少有的几个不会看困的数学视频。宋老师没讲到的部分可以看孔祥仁老师的，然后看完视频再做课后习题，基本问题不大。——写于2023.09.06
github地址
CSDN目录地址
目录 第一课 微积分总览第二课 导数总览第三课 极值和二阶导数第四课 指数函数第五课 积分总览第六课 sinx和cosx的导数第七课 乘法法则和除法法则第八课 链式法则第九课 极限和连续第十课 逆函数和对数函数第十一课 对数函数和反三角函数的导数第十二课 增长率和对数图第十三课 线性近似和牛顿法第十四课 幂级数和欧拉公式第十五课 关于运动的微分方程第十六课 关于增长的微分方程第十七课 六函数、六法则和六定理 参考 大神杨熙的MIT微积分重点课程笔记
《普林斯顿微积分读本》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fe156759fc2ed0c6b3f41cf4f3b814d/" rel="bookmark">
			Android高通 8.1 老化apk打开摄像头花屏问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、最近由于公司VR 3D系统要做双Camera老化测试apk，同时老化4小时需要轮询切换二个摄像头，保证后面camera标定精度数据更准确。
2、一开始我尝试用之前方案移植过去然后同时打开双摄像头 突然发现花屏 如下图所示
3、于是一第一时间想到是不是分辨率不兼容或者硬件Camera问题 或者找驱动确认 驱动确认结果2D系统没有问题 ，于是我交叉验证换了一台机器 跟硬件结果还是花屏，因为之前也处理类似的case，于是我自己尝试修改固定的分辨率1280*720 (720P)代码如下（这里只是部门代码github上面也有很多camera源码以及骁龙相机源码 大家可以下载自行研究)
private val mStateCallback2: CameraDevice.StateCallback = object : CameraDevice.StateCallback() { override fun onOpened(camera: CameraDevice) { Log.i(TAG, "StateCallback！ onOpened 2") mCameraDevice2 = camera // 打开成功，保存代表相机的CameraDevice实例 val surfaceTexture = mTextureView2!!.surfaceTexture surfaceTexture.setDefaultBufferSize(1280, 720) //3264X2448(800万) val surface = Surface(surfaceTexture) val previewList = ArrayList&lt;Surface&gt;() previewList.add(surface) try { // 6.将TextureView的surface传递给CameraDevice mCameraDevice2!!.createCaptureSession( previewList, object : CameraCaptureSession.StateCallback() { override fun onConfigured(session: CameraCaptureSession) { try { val builder = mCameraDevice2!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fe156759fc2ed0c6b3f41cf4f3b814d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f809d3672a0992400e354d224a4bbc/" rel="bookmark">
			ES delete_by_query条件删除的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 es 查询删除的几种方式
1.根据id删除
#根据id删除 POST /indexname/_delete_by_query { "query": { "match": { "id": "100000" } } } 2.根据多个id删除
#根据多个id删除 POST /indexname/_delete_by_query { "query": { "bool": { "filter": [ { "terms": { "id": [ "100000", "200000" ] } } ] } } } 3.根据多个id范围删除
#根据多个id范围删除 POST /indexname/_delete_by_query { "query": { "range": { "id": { "gte": 100000, "lte": 200000 } } } } 注意：删除完成后，执行以下脚本回收索引空间
curl -XPOST http://127.0.0.1:9200/indexname/_forcemerge?max_num_segments=1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6126135aa51430bf46f4bf3aa744ac/" rel="bookmark">
			【已解决】python读取json报错Expecting property name enclosed in double quotes但文件里属性和变量已经是双引号了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了网上的解法，都是说的替换单引号为双引号。
但是我的json文件里并没有单引号，属性和变量已经是双引号包围了
进一步研究，这个提示应该是读取的时候认为json文件格式不对导致的
报错也是报在json.load函数
检查json文件，vscode里有几个波浪线（但并不影响运行）
去掉注释去掉行尾逗号 原因：python使用的json库版本较老，还不支持上述写法。
如果写了注释，python使用的json会认为你的注释文本也是json的一部分，会识别不了这个语法，报错：json.decoder.JSONDecodeError: Expecting ‘,’ delimiter:
如果写了行尾逗号，python会认为你逗号后面还有东西，这时候会试图检索逗号后面的双引号，没检索到，就报了Expecting property name enclosed in double quotes的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1d943b755b7f39c1a6b4c6000b8dc8/" rel="bookmark">
			ubuntu22.04&#43;detectron2&#43;Adelaidet&#43;blendmask配置运行demo/numpy报错/安装环境参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考教程：基于Detectron2的BlendMask训练 BlendMask环境配置 COCO数据集_no module named 'detectron2_＊大脸猫Katee的博客-CSDN博客
一、遇到问题：在运行blendmask例子中遇到ImportError: numpy.core.multiarray failed to import
解决方法：更新numpy，再重新编译detectron2,即可使用Adelaidet+blendmask demo
pip install --upgrade numpy 二、安装环境参考（python3.8，附部分安装包）
安装下载较慢建议添加清华源
pip install 包名 -i https://pypi.tuna.tsinghua.edu.cn/simple/ absl-py==1.4.0
# Editable install with no version control (AdelaiDet==0.2.0)
-e /home/jiaqi/桌面/software/blendmask/AdelaiDet-master
antlr4-python3-runtime==4.9.3
appdirs==1.4.4
black==21.4b2
cachetools==5.3.1
certifi==2023.7.22
charset-normalizer==3.2.0
click==8.1.7
cloudpickle @ file:///home/jiaqi/%E4%B8%8B%E8%BD%BD/cloudpickle-2.2.1-py3-none-any.whl#sha256=61f594d1f4c295fa5cd9014ceb3a1fc4a70b0de1164b94fbc2d854ccba056f9f
contourpy==1.1.0
cycler==0.11.0
Cython @ file:///home/jiaqi/%E4%B8%8B%E8%BD%BD/Cython-0.29.15-cp38-cp38-manylinux1_x86_64.whl#sha256=072cb90e2fe4b5cc27d56de12ec5a00311eee781c2d2e3f7c98a82319103c7ed
# Editable install with no version control (detectron2==0.6)
-e /home/jiaqi/桌面/software/blendmask/detectron2-0.6
editdistance==0.6.2
fonttools==4.42.1
future==0.18.3
fvcore==0.1.5.post20221221
google-auth==2.22.0
google-auth-oauthlib==1.0.0
grpcio @ file:///home/jiaqi/%E4%B8%8B%E8%BD%BD/grpcio-1.57.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl#sha256=5e5b58e32ae14658085c16986d11e99abd002ddbf51c8daae8a0671fffb3467f
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f1d943b755b7f39c1a6b4c6000b8dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6559936877b098874ec790f76538cd/" rel="bookmark">
			什么情况下适合使用静态路由？什么情况下适合使用动态路由？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、三种路由的划分 1 直连路由 直连路由是由链路层协议发现的，一般指去往路由器的接口地址所在网段的路径，直连路由无需手工配置，只要接口配置了网络协议地址同时管理状态、物理状态和链路协议均为UP时，路由器能够自动感知该链路存在，接口上配置的IP网段地址会自动出现在路由表中且与接口关联，并动态随接口状态变化在路由表中自动出现或消失。
2 静态路由 静态路由是由网络管理员根据网络拓扑，使用命令在路由器上配置的路由，这些静态路由信息指导报文发送，静态路由方式也无需路由器进行计算，但它完全依赖于网络管理员的手动配置。
补充一下，默认路由是一种特殊的静态路由,网络管理管理员手工配置了默认路由后，当路由表中与目的地址之间没有匹配的表项时路由器将把数据包发送给默认网关。
3 动态路由 动态路由是指路由器能够自动地建立自己的路由表，且能根据网络拓扑状态变化进行动态调整。动态路由机制依赖于对路由表的维护以及路由器间动态的路由信息交换。路由器间的路由信息交换是基于路由协议实现的，交换路由信息的最终目的是通过路由表找到“最佳”路由。
二、三种路由的区别 主要从三种路由的优缺点及使用场合来加以区别：
1 直连路由 没什么好说的了，直连路由只能使用于直接相连的路由器端口，非直连的路由器端口是没有直连路由的。
2 静态路由 静态路由信息在缺省情况下是私有的，不会传递给其他的路由器。当然，网络管理员也可通过对路由器设置使之成为共享的。网络管理员易于清楚地了解网络的拓扑结构，便于设置正确的路由信息。静态路由一般适用于较简单的网络环境。
3 动态路由 当网络规模较大或网络拓扑经常发生改变时，此时宜采用动态路由的方式，路由器能够按照相关路由算法自动计算新的路由信息，适应网络拓扑结构的变化。大型和复杂的网络环境通常不宜采用静态路由。网络管理员难以全面地了解整个网络拓扑，同时当网络拓扑和链路状态发生变化时，路由器中的静态路由信息需要大范围地调整，这一工作的难度和复杂程度非常高，所以宜采用动态路由的方式。
三，静态路由和静态路由的区别？ 1、静态路由一般是由管理员手工设置的路由，而动态路由则是路由器中的动态路由协议根据网络拓扑情况和特定的要求自动生成的路由条目。
2、什么样的路由器要使用什么样的路由协议，是由网络的管理策略直接决定的。一般中小型的网络，网络拓扑比较简单，不存在线路冗余等因素，所以通常采用静态路由的方式来配置。但是大型网络网络拓扑复杂，路由器数量大，线路冗余多，管理人员相对较少，要求管理效率要高等原因，通常都会使用动态路由协议，适当的辅以静态路由的方式。
3、静态路由基本上都是人为配置的路由，或由人为的相关设置自动生成的，如你配置了ip地址就会产生一个直连路由。
4、一般的静态路由设置经过保存后重起路由器都不会消失，但相应端口关闭或失效时就会有相应的静态路由消失。反而动态路由却会消失，因为动态路由要在动态路由协议正常运行的前提下才能产生的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf071624088e2c3a6275eef09db1043/" rel="bookmark">
			《Python魔法大冒险》004 第一个魔法程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在图书馆的一个安静的角落，魔法师和小鱼坐在一张巨大的桌子前。桌子上摆放着那台神秘的笔记本电脑。
魔法师： 小鱼，你已经学会了如何安装魔法解释器和代码编辑器。是时候开始编写你的第一个Python魔法程序了！
小鱼：(兴奋地两眼放光)我准备好了！
魔法师： 不用担心，这个魔法是超级简单的，就像是变出彩虹糖果一样有趣！我们的第一个魔法程序会打印出一个神奇的句子，告诉世界你已经开始了魔法之旅。
小鱼充满好奇地看着魔法师，等待下一步的指导。
魔法师： 在你的魔法笔记本——VSCode代码编辑器中，输入这个咒语：
print("Hello，Magic World!")
魔法师： 魔法咒语写好后，我们要告诉计算机运行这个程序。
具体操作步骤：
(1) 打开刚刚安装的VSCode代码编辑器。
(2) 创建魔法文件magic.py。
(3) 写入魔法程序。
也可以单击右上角的三角形运行程序，如图
(4) 按【Ctrl+S】键保存你的魔法程序。
点击运行按钮，计算机会像魔法一样执行你的魔法指令，输出你的魔法文字！如图
小鱼小心翼翼地输入了咒语，并保存了文件为magic.py。
魔法师： 现在，在魔法解释器中执行这个文件，看看会发生什么。
小鱼按照指示执行了文件，屏幕上出现了：“Hello，Magic World!”
魔法师： 嘿，看，计算机输出了一行字：“Hello，Magic World!”。是不是觉得很神奇？你刚刚和计算机交流了，它听懂了你的话！
小鱼： 这真的太神奇了！我真的创造了一个魔法！
魔法师： 是的，小鱼。太棒了！你刚刚成功运行了你的第一个Python魔法程序！这只是开始，你将会学到更多的魔法咒语，创造出更多的奇迹。而且，因为你成功地完成了这个任务，我要送你一个礼物。
小鱼好奇地看着魔法师，魔法师从袍子里拿出了一个闪闪发光的魔法碎片。
魔法师： 这是一个魔法碎片，它代表着你编程之旅的每一个成就。当你收集到足够的魔法碎片，你就可以解锁更强大的魔法能力。
小鱼激动地接过了魔法碎片，决心要努力学习，收集更多的魔法碎片。
魔法师： 你现在可以开始写更多有趣的魔法指令，创造出属于你的编程魔法世界！记得多多练习，探索更多的魔法技能，成为一个了不起的魔法师！编程是一场有趣的冒险，让我们一起去探索吧！
让我们分解一下魔法指令的含义：
“print”是一个特殊的命令，告诉计算机我们要输出一些内容。“"”是一种符号，用来包裹我们要输出的内容。“Hello，Magic World!”就是我们要输出的内容，你可以把它改成你想说的任何话。 通过这个简单的程序，小鱼学会了第一个魔法：print 魔法，可以让计算机输出我们想要的文字！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0db291331dca8b5b5978233899d5363/" rel="bookmark">
			Vue 使用高德地图，添加点标记 &#43; 点击地图获取坐标 &#43; 带搜索（即地理编码 &#43; 逆地理编码） - 附完整示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高德地图：
与真实世界联通 - 高德开放平台为开发者赋能，将地图精致地呈现在您的应用中
无论基于哪种平台，都可以通过高德开放平台API和SDK，轻松地完成地图的构建工作
官方文档：地图 | 高德地图API
地图 | 高德地图API地图，地图sdk，地图JS API，地图定制，自定义地图，地图覆盖物，地图绘制，路线规划，坐标转换，距离/面积计算，距离测量，室内地图，地图显示，地图个性化，地图开发，室内定位https://lbs.amap.com/product/map#/
效果 一、准备工作 1、注册/登录账号 2、点击控制台 3、创建应用 4、获取key和密钥，如上图所示 注：使用web服务API，如下图所示
二、安装依赖包 1、安装命令 npm i @amap/amap-jsapi-loader --save 2、这是我的版本 "@amap/amap-jsapi-loader": "^1.0.1", 三、使用步骤 1、在index.html文件中引入密钥 代码如下（示例）：
&lt;script type="text/javascript"&gt; window._AMapSecurityConfig = { securityJsCode: '', // 你的密钥 } &lt;/script&gt; 2、在vue文件中引入依赖包 代码如下（示例）：
import AMapLoader from "@amap/amap-jsapi-loader" 3、申明变量并初始化调用 代码如下（示例）：
import { shallowRef, defineEmits, ref, onBeforeUnmount } from 'vue'; const map = shallowRef(null); let AMapObj, placeSearch, marker, geocoder; function initMap(){ AMapLoader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0db291331dca8b5b5978233899d5363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25fa4e6aa68fef03f5eeb20949f8eac3/" rel="bookmark">
			Vue JeecgBoot 下拉选使用数据字典，设置默认值，默认选中第一个值 - 附完整示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 一、使用步骤 1、导入依赖文件 import {initDictOptions, filterDictText} from '@/components/dict/JDictSelectUtil'; 2、声明变量 data() { return { dataValue: '', datalist: [] } }, 3、定义方法 methods: { // dictCode="data,data_name,data_num" // 加载数据字典 initDictConfig() { // 初始化字典 initDictOptions('data,data_name,data_num').then((res) =&gt; { console.log(res); if (res.success) { this.datalist = res.result this.dataValue = res.result[0].value; } }); }, } 4、调用方法 created () { this.initDictConfig(); }, 5、HTML &lt;a-form layout="inline" style="width:100%;"&gt; &lt;a-form-item label="label"&gt; &lt;a-select v-model="dataValue" &gt; &lt;a-select-option v-for="d in datalist" :key="d.value" :value="d.value"&gt;{{ d.text }}&lt;/a-select-option&gt; &lt;/a-select&gt; &lt;/a-form-item&gt; &lt;/a-form&gt; 二、完整示例 &lt;template&gt; &lt;a-form layout="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25fa4e6aa68fef03f5eeb20949f8eac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c739c88bf9da7211706c2ac96d925acd/" rel="bookmark">
			Js Vue 获取当月第一天、最后一天、当天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 new Date()
效果 2023-06-12 注：本文示例以获取当天为例
一、new Date() 在vue中使用new Date() 获取当月第一天、最后一天、当天、
二、使用步骤 1、定义方法 代码如下（示例）：
/** * @param // type 0 第一天; 1 最后一天; 不传 当天; */ getCurMonthFirstOrLast(type = 2) { let date = new Date; let y = date.getFullYear().toString(); let m = (date.getMonth() + 1).toString().padStart(2, 0); let d = (['1', new Date(y, m, 0).getDate(), date.getDate()][type]).toString().padStart(2, 0); return [y, m, d].join("-"); }, 2、调用 代码如下（示例）：
getCurMonthFirstOrLast() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f38d84710440f7ae4c0ab650fab1693/" rel="bookmark">
			Jsp jstl表达式中是否包含指定字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入：
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %&gt;
语法：
&lt;c:if test="${fn:contains(“后台传来的数据”, “指定要包含的字符串”)}"&gt;
...
&lt;/c:if&gt;
示例：
&lt;c:forEach items="${page.list}" var="batchRecord" varStatus="index"&gt;
&lt;c:if test="${fn:contains(batchRecord.sheetcode,'P')}"&gt;
&lt;a href="xxx"&gt; ${batchRecord.sheetcode} &lt;/a&gt;
&lt;/c:if&gt;
&lt;c:if test="${fn:contains(batchRecord.sheetcode,'BL')}"&gt;
&lt;a href="xxx"&gt;${batchRecord.sheetcode}&lt;/a&gt;
&lt;/c:if&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3c4408127ef40cab0302bf086a6b60/" rel="bookmark">
			Node包管理使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVM NVM是nodejs的版本管理工具，可以在一个环境中同时安装多个nodejs版本（和配套的npm版本），并随时切换。本文使用的Windows系统，步骤均是实际测试，如遇到新的问题， 可留言交流，共同进步。其他系统教程，可参考菜鸟教程 下载与安装 点击前往Github下载nvm-windows * 访问不了GitHub下载，可前往我的收藏夹下载
直接安装（压缩包请解压后安装）安装完成，打开cmd查看nvm安装版本 nvm version nvm下载太慢？ 查找nvm的安装路径 where nvm 示例：\Users\myname\AppData\Roaming\nvm\nvm.exe 在该路径下，找到setting.txt 复制地址到此电脑中的地址栏 \Users\myname\AppData\Roaming\nvm\ 打开setting.txt文件，并添加如下两行代码，可参考nvm下载太慢问题解决
node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 【注意】「重要通知」原淘宝 npm 域名即将停止解析 http://npm.taobao.org 和 http://registry.npm.taobao.org 将在 2022.06.30 号正式下线和停止 DNS 解析。 域名切换规则： http://npm.taobao.org =&gt; http://npmmirror.com http://registry.npm.taobao.org =&gt; http://registry.npmmirror.com 因此，建议将上述地址及时更换为新地址，参考： node_mirror: https://npmmirror.com/mirrors/node/ npm_mirror: https://npmmirror.com/mirrors/npm/ 保存setting.txt文件后，重启cmd继续执行其他操作 安装NodeJs 1 使用NVM安装（推荐） 查看可用node版本，或前往官网查看 nvm ls available 根据实际需求，安装对应的node版本 nvm install v12.12.0 显示本地已经安装的node版本 nvm list 使用指定版本的node，带星号是当前正在使用的版本 如果执行出现问题，请尝试以管理员权限运行cmd nvm use 12.12.0 卸载指定的node版本 nvm uninstall 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af3c4408127ef40cab0302bf086a6b60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e3305a2b7cea16c0a4cb06c49201776/" rel="bookmark">
			轮足机器人硬件总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文主要根据“轮腿机器人Hyun”总结的硬件部分。
轮腿机器人Hyun开源地址：https://github.com/HuGuoXuang/Hyun
1 电源部分 1.1 78M05 78M05是一款三端稳压器芯片，它可以将输入电压稳定输出为5V直流电压.
1.2 AMS1117-3.3 AMS1117-3.3是一种输出电压为3.3V的正向低压降稳压器，适用于高效率线性稳压器。
1.3 DC-DC DC-DC是一种在直流电路中将一个电压值的电能变为另一个电压值的电能的装置。
2 MPU6050陀螺仪 MPU6050是由三个陀螺仪和三个加速度传感器组成的6轴运动处理组件，它集成了3轴MEMS陀螺仪，3轴MEMS加速度计，以及一个可扩展的数字运动处理器 DMP（ DigitalMotion Processor），可用I2C接口连接一个第三方的数字传感器，比如磁力计。扩展之后就可以通过其 I2C或SPI接口输出一个9轴的信号（ SPI接口仅在MPU-6000可用）
通过MPU6050读取加速度和角度的原始数据，数据管理平台（DMP）将原始角速度转化为四元数，进而完成欧拉角的计算。
2.1 四元数 四元数，是简单的超复数。 复数是由实数加上虚数单位 i 组成，其中i²= -1。 相似地，四元数都是由实数加上三个虚数单位 i、j和k 组成，而且它们有如下的关系： i² = j² = k² = -1， iº = jº = kº = 1 , 每个四元数都是 1、i、j 和 k 的线性组合，即是四元数一般可表示为a + bi+ cj + dk，其中a、b、c 、d是实数。
对于i、j和k本身的几何意义可以理解为一种旋转，其中i旋转代表Z轴与Y轴相交平面中Z轴正向向Y轴正向的旋转，j旋转代表X轴与Z轴相交平面中X轴正向向Z轴正向的旋转，k旋转代表Y轴与X轴相交平面中Y轴正向向X轴正向的旋转，-i、-j、-k分别代表i、j、k旋转的反向旋转。
3 轮腿部分 3.1 AS5147P 超高速磁性旋转位置传感器。
AS5147P在转速最高达28,000rpm的情况下仍能提供精确的绝对和增量测量输出。
AS5147P利用DAEC（动态角度误差补偿）专利技术，即使在极高的转速下也能进行精确的位置测量。DAEC补偿技术将传感器信号链的传输延迟降到几乎为零。
AS5147P采用TSSOP-14封装。
管脚号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e3305a2b7cea16c0a4cb06c49201776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e632b6cac31b1eaa277523a5adc5804a/" rel="bookmark">
			易语言向编辑框导入txt文本乱码怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读： 易语言向编辑框导入外部txt文本的时候，出现的文本内容乱码。这种情况多数是因为编码格式造成的。
易语言编辑框内文本编码格式为gbk，对应在txt文档是ANSI。所以当txt文本的保存格式为其他编码格式时，导入到易语言编辑框的文本就会形成乱码。
解决方法 方法一： 更改需要导入的txt文档编码格式。
打开txt文档，从文档右下角能看到当前文档的编码保存格式为UTF-8,点击左上角文件，另存为
在另存为界面，下面的编码选项中，将UTF-8换成ANSI,点击保存。
方法二： 使用易语言编码转换()命令来解决。
从上一步可以看到当前txt文档文本编码格式为UTF-8,那么在导入文本的时候对文本编码进行转换，代码如下：
.版本 2
.支持库 iconv
.子程序 _按钮1_被单击
.局部变量 文件号, 整数型
.局部变量 临时文本, 文本型
文件号 ＝ 打开文件 (取运行目录 () ＋ “\测试.txt”, 1, )
临时文本 ＝ 读入文本 (文件号, )
关闭文件 (文件号)
编辑框1.内容 ＝ 到文本 (编码转换 (到字节集 (临时文本), #编码_UTF_8, #编码_GBK, ))
方法三： 使用模块，我这里用的是精易模块，导入模块的过程就不赘述了，用到的命令是
编码_utf8到gb2312()
代码如下：
.版本 2
.子程序 _按钮1_被单击
.局部变量 文件号, 整数型
.局部变量 临时文本, 文本型
文件号 ＝ 打开文件 (取运行目录 () ＋ “\测试.txt”, 1, )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e632b6cac31b1eaa277523a5adc5804a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd98e5edda42b6a952e8c0eebcb130b/" rel="bookmark">
			SpringBoot自定义注解&#43;AOP&#43;自定义异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 编写自定义注解2. Aop切面类3. 方法上使用自定义注解4. 步骤2中的自定义异常SnValidationException 本文来源于需要在多个方法中首先判断某个数据是否存在，存在就进行各自的操作，不存在就不执行各自的方法。 1. 编写自定义注解 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface SnValidation { } 2. Aop切面类 import com.thrid.thrid_sdk.dto.req.SetModeRequest; import com.thrid.thrid_sdk.exception.SnValidationException; import com.thrid.thrid_sdk.service.DeviceService; import lombok.RequiredArgsConstructor; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Aspect @Component @RequiredArgsConstructor public class SnValidationAspect { private final PersonService personService; @Before("@annotation(com.thrid.thrid_sdk.annotation.SnValidation)")//指定哪个注解 public void validateSn(JoinPoint joinPoint) {//使用该注解的具体逻辑 Object[] args = joinPoint.getArgs(); for (Object arg : args) { if (arg instanceof Person) { Person person = (Person) arg; boolean isExist = personService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd98e5edda42b6a952e8c0eebcb130b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4ee4af6b9d46f727d2e54b6e55b92c/" rel="bookmark">
			C&#43;&#43; 离群点检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ai.hpp
#ifndef ENGINE_AI_N_H #define ENGINE_AI_N_H #pragma once #endif #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;string&gt; #include &lt;list&gt; #include &lt;unordered_map&gt; #include &lt;tuple&gt; #include &lt;algorithm&gt; #include &lt;memory&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;chrono&gt; using namespace std; typedef std::vector&lt;float&gt; Vector; template &lt;typename T&gt; struct Cvt; template &lt;&gt; struct Cvt&lt;std::string&gt; { static const std::string&amp; to_utf8(const std::string&amp; s) { return s; } static const std::string&amp; from_utf8(const std::string&amp; s) { return s; } }; namespace v { struct LightVector: public std::pair&lt;float *, float *&gt; { using Parent = std::pair&lt;float *, float *&gt;; template &lt;typename.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf4ee4af6b9d46f727d2e54b6e55b92c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb033347f75b82d2ed0f9d3b2b2e855/" rel="bookmark">
			Nginx如何安装SSL证书，在编辑nginx.conf，替换一下代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx.conf 路径 一般 在 /usr/local/nginx/nginx.conf
也可以使用代码找到路径
nginx -t 1.nginx如何修改SSL证书?
首先已经把证书上传服务器
路径任何都行，但是要绝对路径放在哪，路径就在那例图 路径在 /usr/local/nginx/cert
######################## default ############################ #只需要将下面部分替换掉，从这开始 ，只需要改SSL证书文件路径 ########################## server { listen 80; listen 443 ssl; server_name _; access_log /data/wwwlogs/access_nginx.log combined; # ssl证书地址 ssl_certificate /usr/local/nginx/cert/x.derfoe.cn.pem; # pem文件的路径 ssl_certificate_key /usr/local/nginx/cert/x.derfoe.cn.key; # key文件的路径 # ssl验证相关配置 ssl_session_timeout 5m; #缓存有效期 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议 ssl_prefer_server_ciphers on; #使用服务器端的首选算法 root /data/wwwroot/default; index index.html index.htm index.php; #error_page 404 /404.html; #error_page 502 /502.html; location /nginx_status { stub_status on; access_log off; allow 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fb033347f75b82d2ed0f9d3b2b2e855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d38df92dfb399cf0136c0ddda8f48153/" rel="bookmark">
			大数据从入门到精通(超详细版)之Yarn的使用，安装与部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 嗨，各位小伙伴，恭喜大家学习到这里，不知道关于大数据前面的知识遗忘程度怎么样了，又或者是对大数据后面的知识是否感兴趣，本文是《大数据从入门到精通（超详细版）》的一部分，小伙伴们如果对此感谢兴趣的话，推荐大家按照大数据学习路径开始学习哦。
以下就是完整的学习路径哦。
↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
大数据从入门到精通文章体系！！！！！！！！！！！！！！
↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
推荐大家认真学习哦！！！
文章目录 前言大致的资源分配流程Yarn的架构Yarn容器Web应用代理概念独立部署的步骤 Yarn的历史服务器Yarn的部署部署总体说明集群规划配置过程mapreduce的配置配置mapred-env.sh文件配置mapred-site.xml文件 Yarn的配置配置yarn-env.sh配置yarn-site.xml文件把这些配置文件分发到其他节点的服务器 集群的启动命令MapReduce的在Yarn中的执行Yarn可以执行的程序wordCount程序实例 Yarn是什么
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d38df92dfb399cf0136c0ddda8f48153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49eef028ba5f225e40dfeee458706748/" rel="bookmark">
			SpringBoot集成RabbitMQ基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简单模式-无交换机(一个生产者、一个队列、一个消费者）2.发布订阅模式3. routing(direct)模式4. topic模式 1. 简单模式-无交换机(一个生产者、一个队列、一个消费者） 加入maven依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 在 application.yml 中配置rabbitmq的 连接信息
spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest 列配置，启动时创建队列
@Configuration public class RabbitMqConfig { @Bean public Queue createQueue(){ return new Queue("hello-queue"); } } 创建生产者（可以卸载接口里面）
@Component public class Sender { @Autowired private AmqpTemplate amqpTemplate; public void send(String msg){ this.amqpTemplate.convertAndSend("hello-queue",msg); } } 创建消费者
@Component public class Receiver { @RabbitListener(queues = "hello-queue") public void process(String msg){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49eef028ba5f225e40dfeee458706748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8038e0fb70dec300e32b027d51fdbb0d/" rel="bookmark">
			SpringBoot内部消息机制-通用版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot内部消息机制 在 Spring Boot 中，你可以使用 Spring 的事件机制（Application Event）来实现内部消息的发布和订阅。这个机制使得不同组件之间可以松散耦合地通信，当某个事件发生时，其他组件可以监听并采取相应的行动。
具体步骤如下：
1. 创建自定义事件类：首先，你需要创建一个自定义的事件类，该类需要继承自 ApplicationEvent。这个类将用于表示你的事件，可以在其中添加一些属性，以便传递相关信息。 import org.springframework.context.ApplicationEvent; public class MyCustomEvent extends ApplicationEvent { private String eventData; public MyCustomEvent(Object source, String eventData) { super(source); this.eventData = eventData; } public String getEventData() { return eventData; } } 2. 创建事件发布者：创建一个组件，它将用于发布事件。你可以使用 ApplicationEventPublisher 接口来发布事件。这个接口可以通过构造函数或自动注入的方式注入到你的组件中。 import org.springframework.context.ApplicationEventPublisher; import org.springframework.stereotype.Component; @Component public class MyEventPublisher { private final ApplicationEventPublisher eventPublisher; public MyEventPublisher(ApplicationEventPublisher eventPublisher) { this.eventPublisher = eventPublisher; } public void publishEvent(String eventData) { MyCustomEvent customEvent = new MyCustomEvent(this, eventData); eventPublisher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8038e0fb70dec300e32b027d51fdbb0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b4333126291ce0d9a0a1907b9afd63/" rel="bookmark">
			Android四大组件之-Activity的创建与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[TOC](文章目录) 一、Activity的创建与生命周期1.Activity的创建2.Activity的生命周期 二、layout布局常用控件用法与详解1.线性布局2.相对布局a.根据父容器定位属性b.根据兄弟组件定位属性c.偏移属性（设置两个组件之间的边距）d.填充属性（设置组件内部元素之间的边距） 3.表格布局：主要用于数据表显示4.帧布局：用于前景显示，设置跳转页面也不会被覆盖的内容5.网格布局6.绝对布局7.普通控件文本框：输入框：按钮Button和ImageButton图像控件ImageView单选框复选框：每个CheckBox都要设置一个id开关按钮和图标进度条拖动条时间控件 三、apk全局参数的应用四、Activity数据持久化onCreate()方法带一个参数onCreate()方法带两个参数 五、Activity之间的数据传递传递一个数据传递多个数据传递：传递数组传递：传递集合多个Activity间的交互(后一个传回给前一个) 六、activity启动时根据横竖屏状态加载不同的布局六、隐式启动activity七、双击退出APP第一种方法：定义一个变量，来标识是否退出第二种方法：保存点击时间 八、Activity过场动画为单个Activity设置进入和退出的过场动画为所有Activity设置进入和退出的过场动画 九、设置Activity全屏的四种方法十、设置对话框风格Activity的两种方法十、onWindowFocusChanged方法的应用十一、Activity管理类的使用以及关闭所有acitivity和完全退出app的方法十二、设计堆栈的Activity管理类总结 一、Activity的创建与生命周期 1.Activity的创建 1.创建一个layout xml布局文件 2.创建一个java类继承Activity或者AppCompatActivity 3.重写onCreate()方法，在onCreate()方法中调用setContentView()方法设置要显示的layout文件 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main)； } 4.在AndroidManifest.xml文件中注册Activity &lt;activity android:name=".MainActivity2"&gt;&lt;/activity&gt; 做完以上4步就已经完成了一个Activity的创建，Android Studio工具还提供了更快捷的方法，直接鼠标右键-new - Activity - 选择任意一种布局的activity - 重命名一下Activity Name和Layout Name点击Finish完成创建。
2.Activity的生命周期 1.启动activity时依次调用：onCreate，onStart，onResume
2.按back键时依次调用：onPause，onStop，onDestroy
3.按home键或者跳转到其他页面时依次调用：onPause，onStop
4.从其他页面按back键返回时依次调用：onRestart，onStart，onResume
5.横竖屏切换时依次调用： onPause ，onStop， onDestroy，onCreate， onStart，onResume
从activity1跳转到activity2时依次调用:
activity1的onPause
activity2的onCreate
activity2的onStart
activity2的onResume
activity1的onStop
从activity2按back键返回activity1时依次调用：
activity2的onPause
activity1的onRestart
activity1的onStart
activity1的onResume
activity2的onStop
activity2的onDestroy
可复制以下代码运行，自行查看log打印确认
MainActivity.java
public class MainActivity extends AppCompatActivity { TextView bt; @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59b4333126291ce0d9a0a1907b9afd63/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/54/">«</a>
	<span class="pagination__item pagination__item--current">55/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/56/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>