<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a442b93f85bdc4b83057576f4835846d/" rel="bookmark">
			vue element 导入出错  弹窗提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js代码 successF(response, file, fileList) {
if (response.code === "success") {
this.$message.success("导入成功");
this.getList();
} else {
this.getList();
this.errorLists = response.data;
if (this.errorLists &amp;&amp; this.errorLists.length &gt; 0) {
this.dialogFormErrorVisible = true;
}
this.$message.error(response.message || "导入出错");
}
},
html &lt;el-upload
class="upload-demo"
action="api/lotus/sp/stocktaking/excel/import"
name="excel"
:on-success="successF"
:show-file-list="false"
:file-list="fileList"
&gt;
&lt;el-button type="primary" ref="upload"&gt;导入任务&lt;/el-button&gt;
&lt;/el-upload&gt;
错误信息弹窗 &lt;el-dialog
title="错误信息"
:visible.sync="dialogFormErrorVisible"
width="800px"
class="demo-base-dialog dialog-input"
:close-on-click-modal="false"
&gt;
&lt;el-table :data="errorLists" border :stripe="true" max-height="250"&gt;
&lt;el-table-column label="序号" width="68" fixed&gt;
&lt;template slot-scope="scope"&gt;{{scope.$index + 1}}&lt;/template&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a442b93f85bdc4b83057576f4835846d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffacce90eae676ad53b0cf59df89bae6/" rel="bookmark">
			MySQL连接（join）原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL JOIN分类 INNER JOIN，内连接，返回左右表互相匹配的所有行LEFT JOIN，左外连接，返回左表的所有行，若某些行在右表里没有相对应的匹配行，则将右表的列在新表中置为NULLRIGHT JOIN，右外连接，返回右表的所有行，若某些行在左表里没有相对应的匹配行，则将左表的列在新表中置为NULLFULL JOIN，MySQL不支持，可以使用左外连接和右外连接的联合查询CROSS JOIN，交叉连接 二、JOIN顺序 inner join驱动顺序由优化器自己指定，如果优化器选择有误可以使用straight_join自己指定驱动顺序以达到优化的目的
left join驱动顺序是固定的，left join左边的表为驱动表，右边为匹配表，RIGHT JOIN则刚好相反
下面这两个SQL是等价的吗？
select count(*) from t_user_log a left join t_user b on a.uid = b.uid and b.city = 78; select count(*) from t_user_log a left join t_user b on a.uid = b.uid where b.city = 78; 不等价，因为前者在匹配表中加了过滤条件，而后者在关联结果中加了过滤条件，前者不影响驱动表检索出来的数据（与匹配表无法匹配的数据依然会检索出来，只是匹配表字段部分值等于NULL），后者影响驱动表检索出来的数据（因为在结果集中直接被过滤掉了）。
三、MySQL原理介绍 场景： t1表插入100行，t2表插入1000行数据
select * from t1 straight_join t2 on (t1.a=t2.a); Index Nested-Loop Join 连接字段a上有索引，straight_join 让 MySQL 使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去 join，不会自己选择。在这个语句里，t1 是驱动表，t2 是被驱动表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffacce90eae676ad53b0cf59df89bae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0115e3e379b5afa879d5847f813a724a/" rel="bookmark">
			关于Oracle的Merge的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说直接记录！(^_−)☆
自动判断是新增还是修改的关键字： MERGE INTO
MERGE 语法：
MERGE INTO [your table-name] [rename your table here] USING ( [write your query here] )[rename your query-sql and using just like a table] ON ([conditional expression here] AND [...]...) WHEN MATCHED THEN [here you can execute some update sql or something else ] WHEN NOT MATCHED THEN [execute something else here ! ] 例如我们想插入一条数据 {ID=2,NAME=‘newtest2’} 那么可以这么写：
MERGE INTO TEST T1 USING (SELECT '2' as ID, 'newtest2' as NAME FROM dual) T2 on (T1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0115e3e379b5afa879d5847f813a724a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee58e72cd310197b1b55d2f488bac91/" rel="bookmark">
			postwoman(比Postman更好 免费)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
https://github.com/liyasthomas/postwoman
简单使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21105e80d4a7483b99d675cb40dd028f/" rel="bookmark">
			mySql的下载和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载MySQL数据库的官方网站：https://www.mysql.com/
目前最新是这个8.0.18版本。
下载下来的是个压缩文件，我将文件解压到E:\目录下。
配置mySql 1.配置环境变量。
2.在安装文件的根目录下（我的安装根目录E:\mysql-8.0.18-winx64）新建一个文本文件，并将配置写的文本文件中。后将文件扩展名修改为.ini文件。
3.以管理员权限运行cmd.exe。
4.在命令窗口中输入 cd E:\mysql-8.0.18-winx64\bin （我的是在这个磁盘下）回车
5.输入mysqld -install [服务器名] 回车。（服务名不写默认为mysql）（安装mysql，如果不用管理员身份运行，则会报Install/Remove of the service denied!错误。）
6.输入mysqld --initialize 回车。（初始化mysql,如果不初始化，则不存在Data目录，无法启动成功）
7.输入 net start mysql 回车。（启动服务器）
8.输入mysql -u root -p 回车。（登录）
9.如果在输入mysql -u root -p 回车登陆不上时（因为在5.7版本之后自动给了一个随机密码），需要手动在mysql目录下搜索*.err。我的在E:\mysql-8.0.18-winx64\Data\DESKTOP-VITAACD.err中。以文本的形式打开该文档，找到2019-12-18T09:38:49.911765Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 3uRu2WsrnH(G，输入当前密码（即红色字体）就可以登陆上了。
配置环境变量：
E:\mysql-8.0.18-winx64\bin
环境变量配置完成后，还需要在E:\mysql-8.0.18-winx64目录下新建一个ini文件（如my.ini）。
打开my.ini文件，将以下配置粘贴到文本文件中。
[mysqld]
# 设置3306端口
port=3306
# 设置mysql的安装目录
basedir=E:\mysql-8.0.18-winx64
# 设置mysql数据库的数据的存放目录
datadir=E:\mysql-8.0.18-winx64\Data
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。
max_connect_errors=10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21105e80d4a7483b99d675cb40dd028f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2681f84a6b20efbbc72442ffce05a4/" rel="bookmark">
			css实现鼠标悬停图片放大显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;&lt;/title&gt;
&lt;style&gt;
* {
margin: 0;
padding: 0;
font-family: "微软雅黑";
}
.avatar {
display: block;
width: 300px;
margin: 0 auto;
overflow: hidden;
}
.avatar img {
display: block;
border: 0;
width: 100%;
transform: scale(1);
transition: all 1s ease 0s;
-webkit-transform: scale(1);
-webkit-transform: all 1s ease 0s;
}
.avatar:hover img {
transform: scale(1.3);
transition: all 1s ease 0s;
-webkit-transform: scale(1.3);
-webkit-transform: all 1s ease 0s;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb2681f84a6b20efbbc72442ffce05a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3de3d72c5edde811d5ab38d18ad9d69/" rel="bookmark">
			node.js之 EventEmitter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node的事件模块只包含了一个类：EventEmitter。这个类在node的内置模块和第三方模块中大量使用。EventEmitter本质上是一个观察者模式的实现。
所谓观察者模式：
它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。
因此最基本的EventEmitter功能，包含了一个观察者和一个被监听的对象，对应的实现就是EventEmitter中的on和emit：
var events=require('events'); var eventEmitter=new events.EventEmitter(); eventEmitter.on('say',function(name){ console.log('Hello',name); }) eventEmitter.emit('say','Jony yu'); eventEmitter是EventEmitter模块的一个实例，通过eventEmitter的on方法监听，eventEmitter的emit方法say事件，发出say事件，从而执行相应的函数。
EventEmitter模块的基本用法 .addListener()或.on()为指定事件添加一个监听器到监听器数组尾部（这俩作用一样，on是addListener的简写形式）
prependListener(event,listener) 添加一个监听器到监听器数组头部
once(event, listener) 添加一个单次监听器到监听器数组尾部， 监听器最多只会触发一次，触发后立刻解除该监听器。
removeListener 或 off 移除指定事件的某个监听器 removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。
setMaxListeners(n) 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。
listeners(event) 返回指定事件的监听器数组。
emit(event, [arg1], [arg2], [...]) 按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。
例子：
添加监听事件
var events = require('events'); var emitter = new events.EventEmitter(); emitter.on('someEvent', function(arg1, arg2) { console.log('listener1', arg1, arg2); //执行多次 }); emitter.on('someEvent', function(arg1, arg2) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3de3d72c5edde811d5ab38d18ad9d69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7d559baff5ccf8cef8ed98735d3c1e/" rel="bookmark">
			Spark 异常总结及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 总结Spark开发中遇到的异常及解决办法，之前也写过几篇，之所以不再一个异常写一篇博客，是因为现在Spark用的比较熟悉了一些，觉得没必要把异常信息写那么详细了，所以就把异常总结在一篇博客里了，这样既能备忘也方便查找。
1、之前的几篇 spark-submit报错:Exception in thread “main” java.sql.SQLException:No suitable driverhive查询报错:java.io.IOException:org.apache.parquet.io.ParquetDecodingExceptionspark-submit报错:Application application_1529650293575_0148 finished with failed status 2、 spark.executor.memoryOverhead 堆外内存（默认是executor内存的10%），当数据量比较大的时候，如果按默认的就会有下面的异常，导致程序崩溃
异常 1 Container killed by YARN for exceeding memory limits. 1.8 GB of 1.8 GB physical memory used. Consider boosting spark.yarn.executor.memoryOverhead. 解决 具体值根据实际情况配置
新版
1 --conf spark.executor.memoryOverhead=2048 旧版
1 --conf spark.yarn.executor.memoryOverhead=2048 新版如果用旧版，会:
1 WARN SparkConf: The configuration key 'spark.yarn.executor.memoryOverhead' has been deprecated as of Spark 2.3 and may be removed in the future.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7d559baff5ccf8cef8ed98735d3c1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8296603d6328c2129e033d6468cee995/" rel="bookmark">
			java开发调用C语言的DLL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过Java调用OCX控件或者DLL有以下几种方法，使用JNI、JACOB、Jawin等技术完成接口调用；
1.JNI
最直接的方式，也是最麻烦的方式，需要自己完成所有的工作，不推荐。
2.Jawin
尝试了一下，效果不错，但相对来说，其编程风格更贴近Windows，离Java有点远
3.Jacob
使用Jacob非常方便，Java编程风格，需要了解的知识比较少。官方的解释是Java COM Bridge，即java和
com组件间的桥梁（进一步了解com/dcom: http://docs.huihoo.com/com/）
com一般表现为dll或exe等二进制文件
下载地址： http://sourceforge.net/projects/jacob-project/ JACOB。e
Jacob的使用方法（64位的jacob组件对应 64为的OCX控件或者DLL文件）
1、将jacob.jar导入到开发项目（开发项目为需要引用的dll接口的项目）中，导入方法如下https://blog.csdn.net/zxz9900/article/details/99598807；
2、将jacob-1.xx-x64.dll放到 C:\Windows\System32文件夹下（注意：该dll必须与jacob.jar版本一致）；
3、注册DLL文件，regsvr32 D:\Code\EncryptionLibrary64.dll；
如果注册失败，提示没有入口的错误，请进行如下操作：
开始→所有程序→附件→右键点击命令提示符（CMD）→以管理员身份运行。
在DOS窗口中输入 regsvr32 msi.dll，提示成功，然后再执行 regsvr32 xx.dll
键盘操作win+r弹出运行框，输入 regedit 查看注册表；
注意：如果部分电脑不能注册，或者注册失败，可手动进行如下操作，键盘操作win+r弹出运行框，输入 regedit 查看注册表，选中“计算机”根节点，选中“文件”菜单中的【导入】，导入dll的注册文件（共两个注册文件，ProgId.reg与CLSID.reg），，导入完成后请查询“EncryptionLibrary64.EncryptionLibraryCom”，并修改注册文件中“InprocServer32”与“1.0.0.0”中“CodeBase”参数中“EncryptionLibrary64.dll”的相关路径（修改为dll文件在本地的路径）；
1.初始化 ComThread.InitMTA(true);
ActiveXComponent com = new ActiveXComponent("组件的ProgID") ;
Dispatch disp = com.getObject();
2.调用控件里面的方面
2.1调用无参的方法，并返回一个short值
Dispatch.call(disp, "Init").getShort();
2.2调用有一个参数的方法，并返回一个boolean值
Dispatch.call(disp,"Method",new Variant(args)).getBoolean();
调用多个参数依次类推，注意在传递参数前，将Java中的参数转换成Variant。
Demo链接： //download.csdn.net/download/aa2397199142/12038233 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d34fb8811d48796f919a17cd510be981/" rel="bookmark">
			nvidia-smi命令很长时间才输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是由于没有启动显卡的persistenced模式, 导致每次nvidia-smi, 如果没有程序再运行, 都要先进行初始化.
解决方法:
sudo /usr/bin/nvidia-persistenced --verbose # 再试一下应该可以了. nvidai-smi 将上述命令加到开始启动的脚本中, 可以实现每次开机自动运行初始化命令
echo "/usr/bin/nvidia-persistenced --verbose" | sudo tee -a /etc/init.d/rc.local 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c318c1d9d8b905526d6646efc6632f/" rel="bookmark">
			vue项目进行防抖实现请求频繁时取消上一次操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 需求问题：在项目开发中，可能会连续发送多个请求，但是我们只想发送一次请求。比如在搜索框进行输入内容的时候，当在每输入一个字符的时候都会进行搜索查询，频繁发送请求，对服务端造成不必要的请求压力，这就需要在发送新请求的时候取消上一次的操作。只有当所有的内容都输入完毕以后，再进行内容的搜素查询请求。这个也是防抖的常用情景。
二、 需求分析：针对在vue项目中，我们进行防抖，请求频繁时取消上一次的操作，可以通过两种方式。第一种通过clearTimeout()和setTimeout()定时器进行解决，第二种可以通过axios进行防抖解决。我们可以看一下在防抖前和防抖后的network变化。
1. 在防抖前，network中在输入内容时会频繁请求，如图所示：
在防抖后，network中在输入内容时只会请求最后一次，之前的请求都会被取消掉，如图所示：
三、 需求实现：
&lt;template&gt; &lt;div class="search_body"&gt; &lt;div class="search_input"&gt; &lt;div class="search_input_wrapper"&gt; &lt;i class="iconfont icon-sousuo"&gt;&lt;/i&gt; &lt;input type="text" v-model="message"&gt; &lt;/div&gt;	&lt;/div&gt; &lt;div class="search_result"&gt; &lt;h3&gt;电影/电视剧/综艺&lt;/h3&gt; &lt;ul&gt; &lt;li v-for="item in movieList" :key="item.id"&gt; &lt;div class="img"&gt;&lt;img :src="item.img | setWH('128.180')"&gt;&lt;/div&gt; &lt;div class="info"&gt; &lt;p&gt;&lt;span&gt;{{ item.nm }}&lt;/span&gt;&lt;span&gt;{{ item.sc }}&lt;/span&gt;&lt;/p&gt; &lt;p&gt;{{ item.enm }}&lt;/p&gt; &lt;p&gt;{{ item.cat }}&lt;/p&gt; &lt;p&gt;{{ item.rt }}&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Search', data() { return { message: '', movieList: [] } }, methods: { // 取消请求的方法 cancelRequest(){ if(typeof this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c318c1d9d8b905526d6646efc6632f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c83b5c8e174d4be8c4d5d72ce17903b/" rel="bookmark">
			SQL语句大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础 1、说明：创建数据库
CREATE DATABASE database-name
2、说明：删除数据库
drop database dbname
3、说明：备份sql server
--- 创建 备份数据的 device
USE master
EXEC sp_addumpdevice 'disk', 'testBack', 'c:mssql7backupMyNwind_1.dat'
--- 开始 备份
BACKUP DATABASE pubs TO testBack 4、说明：创建新表
create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)
根据已有的表创建新表： A：create table tab_new like tab_old (使用旧表创建新表)
B：create table tab_new as select col1,col2… from tab_old definition only
5、说明：删除新表
drop table tabname 6、说明：增加一个列
Alter table tabname add column col type注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c83b5c8e174d4be8c4d5d72ce17903b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791295e1ba8eabdcbe50c52904d28b32/" rel="bookmark">
			syntax  error near  unexpected token &#39;(&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		syntax error near unexpected token ‘(’ 出现这个问题从字面上看就是语法错误，并且是因为括号引起的，有可能是因为linux上不能直接识别括号，需要转义，既然这样，可以用replace方法，用法就是把有括号的字符串转义，如下:str.replace（’(’, ‘\(’）,当然反括号也是要转义的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9e954c2f599f99fe11d9b9744ba32c/" rel="bookmark">
			JDBC——数据库连接池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。
当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。
好处：
节约资源用户访问高效 实现：
1. 标准接口：DataSource javax.sql包下的
方法：
获取连接：getConnection()
归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接
2. 一般我们不去实现它，有数据库厂商来实现
1. C3P0：数据库连接池技术
2. Druid：数据库连接池实现技术，由阿里巴巴提供的
C3P0：数据库连接池技术
步骤：
1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java- g 2. 定义配置文件：
名称： c3p0.properties 或者 c3p0-config.xml
路径：直接将文件放在src目录下即可。
3. 创建核心对象 数据库连接池对象 ComboPooledDataSource
4. 获取连接： getConnection
代码
//1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); Druid：数据库连接池实现技术，由阿里巴巴提供的
步骤：
1. 导入jar包 druid-1.0.9.jar
2. 定义配置文件：
是properties形式的
可以叫任意名称，可以放在任意目录下
3. 加载配置文件。Properties
4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory
5. 获取连接：getConnection
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e9e954c2f599f99fe11d9b9744ba32c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14f900be1791b8653e0bf2192aedf24/" rel="bookmark">
			web手机端js获取用户当前详细地理位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引入jquery和百度的地图api，如下所示：
&lt;script type="text/javascript" src="skin/jquery.js"&gt;&lt;/script&gt; &lt;script src="http://api.map.baidu.com/api?v=1.2" type="text/javascript"&gt;&lt;/script&gt; 二、具体用法如下（直接复制即可，oppo手机亲测有效）：
&lt;script&gt; $(function(){ getLocation(); }) function getLocation() { var options = { enableHighAccuracy : true, maximumAge : 1000 } if (navigator.geolocation) { //浏览器支持geolocation navigator.geolocation.getCurrentPosition(onSuccess, onError, options); } else { //浏览器不支持geolocation alert('您的浏览器不支持地理位置定位'); } } //成功时 function onSuccess(position) { debugger //返回用户位置 //经度 var longitude = position.coords.longitude; //纬度 var latitude = position.coords.latitude; /* alert('经度'+longitude+'，纬度'+latitude); */ //根据经纬度获取地理位置，不太准确，获取城市区域还是可以的 var map = new BMap.Map("allmap"); var point = new BMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c14f900be1791b8653e0bf2192aedf24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349fed7f106e2eb428e8234b55fa21f5/" rel="bookmark">
			说说在 Python 中，如何找出所有字符串匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Regex 对象有一个 findall() 方法，它会返回包含所查找字符串的所有匹配。这与 search() 方法明显不同，search() 将返回一个 Match 对象，其中包含被查找字符串中的 “ 第一次 ” 匹配文本。请看以下示例，注意区分：
phone_num_regex = re.compile(r'\d\d\d\d-\d\d\d\d\d\d\d\d') mo = phone_num_regex.search('我的联系号码为： 0591-83822032；另一个号码是：0591-83822033.') print('查到的联系号码: ' + mo.group()) phone_num_regex = re.compile(r'\d\d\d\d-\d\d\d\d\d\d\d\d') phone_nums = phone_num_regex.findall('我的联系号码为： 0591-83822032；另一个号码是：0591-83822033.') print('查到的联系号码: ' + str(phone_nums)) 运行结果：
查到的联系号码: 0591-83822032
查到的联系号码: [‘0591-83822032’, ‘0591-83822033’]
如果调用 findall 的正则表达式不存在分组（比如上例），那么方法 findall() 将返回一个匹配字符串的列表，例如上例的 [‘0591-83822032’, ‘0591-83822033’]。
如果调用 findall 的正则表达式存在分组，那么方法 findall() 将返回一个字符串元组的列表（每个分组对应一个字符串），请看下例：
phone_num_regex = re.compile(r'(\d\d\d\d)-(\d\d\d\d\d\d\d\d)') phone_nums = phone_num_regex.findall('我的联系号码为： 0591-83822032；另一个号码是：0591-83822033.') print('查到的联系号码: ' + str(phone_nums)) 运行结果：
查到的联系号码: [‘0591-83822032’, ‘0591-83822033’]
查到的联系号码: [(‘0591’, ‘83822032’), (‘0591’, ‘83822033’)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b1f70e5d838d2b20125019f7210a37/" rel="bookmark">
			uniapp截屏并保存到相册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let pages = getCurrentPages(); let page = pages[pages.length - 1]; let webView = page.$getAppWebview(); let bitmap = new plus.nativeObj.Bitmap('drawScreen'); webView.draw(bitmap, () =&gt; { //保存到本地 bitmap.save('_doc/'+ datefmt(new Date(), 'YYYYMMDDHHmmss') + ".png", { overwrite: true }, res =&gt; { const locationUrl = res.target; // 图片地址 console.log('本地路径:'+locationUrl) //保存到相册 uni.saveImageToPhotosAlbum({ filePath:locationUrl, success: function () { console.log('save success'); } }); bitmap.clear(); // 清除Bitmap对象 //分享给微信 uni.share({ provider: "weixin", scene: "WXSceneSession", type: 0, href: this.shareUrl+"?source=app&amp;shareId="+this.user.id, title: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b1f70e5d838d2b20125019f7210a37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f8c3a0cd87dd8388eca588307c39c9/" rel="bookmark">
			Class 的继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Class 的继承 1.简介 Class 可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。
class Point { } class ColorPoint extends Point { } extends关键字用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。
上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。
class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString() } } super关键字用于访问和调用一个对象的父对象上的函数。
上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
class Point { /* ... */ } class ColorPoint extends Point { constructor() { } } let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f8c3a0cd87dd8388eca588307c39c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda99e83eaaefdbbe73e79f76d37588c/" rel="bookmark">
			MySQL行转列案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建表： 成绩表：表名score，列名：学号、课程号、成绩
CREATE TABLE `score` ( `s_id` varchar(20) NOT NULL, `c_id` varchar(20) NOT NULL, `s_score` int(3) DEFAULT NULL, PRIMARY KEY (`s_id`,`c_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据脚本：
insert into Score values('01' , '01' , 80); insert into Score values('01' , '02' , 90); insert into Score values('01' , '03' , 99); insert into Score values('02' , '01' , 70); insert into Score values('02' , '02' , 60); insert into Score values('02' , '03' , 80); insert into Score values('03' , '01' , 80); insert into Score values('03' , '02' , 80); insert into Score values('03' , '03' , 80); insert into Score values('04' , '01' , 50); insert into Score values('04' , '02' , 30); insert into Score values('04' , '03' , 20); insert into Score values('05' , '01' , 76); insert into Score values('05' , '02' , 87); insert into Score values('06' , '01' , 31); insert into Score values('06' , '03' , 34); insert into Score values('07' , '02' , 89); insert into Score values('07' , '03' , 98); 表数据如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda99e83eaaefdbbe73e79f76d37588c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b297029c1872b99109421e57577656/" rel="bookmark">
			运行vue工程遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.找不到babel-core模块
按控制台里提示的，安装babel-core@7即可
npm install --save-dev babel-core@7 2.You may need an additional loader to handle the result of these loaders.(需要额外的加载器来处理这些加载器的结果)。
这里老是不能按期待的显示，本来应该是id为app的div被替换成带data字段的div，样式也是，但是每次都看到Hello World.都无语了。
最后我看了vue-loader文档，里面提到“你应该将 vue-loader 和 vue-template-compiler 一起安装”，所以，
npm install -D vue-loader vue-template-compiler 并且配置了webpack.config.js
const VueLoaderPlugin = require('vue-loader/lib/plugin') module.exports = { module: { rules: [ // ... 其它规则 { test: /\.vue$/, loader: 'vue-loader' } ] }, plugins: [ // 请确保引入这个插件！ new VueLoaderPlugin() ] } vue-loader参考地址：https://vue-loader.vuejs.org/zh/guide/#%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AE
之后就显示如图，
3.图片加载不出来
这里按书上，书行我不行。。暂时用下面这个方法显示了
(层级关系时是demo，，demo/app.vue，，demo/images，，demo/images/image.png)
//app.vue &lt;template&gt; &lt;div&gt; &lt;p&gt; &lt;img :src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b297029c1872b99109421e57577656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba29d4b6742f551f2facaf738fbed8fe/" rel="bookmark">
			.NET Reactor 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、.NET Reactor介绍
.Net Reactor代码混淆软件，保护代码，当你开发应用程序的时候就可以在软件保护源代码,让别人无法修改你的软件,对于开发人员设置代码加密是非常有帮助的。
.NET Reactor，这个非常小巧，免安装，而且不需要注册。他只是将代码换成随机码，但是混淆后的代码都能正常使用。
二、使用方法
1、打开.NET Reactor，如图所示：
2、单击 Main Assembly 右边的 Open，选择要加密的软件文件exe 或 dll 都可以。
3、勾选 Quick Settings 下要加密的项，每项的含意如下：
NecroBit：把程序集转为非托管代码；
Native Exe File：生成本机 Exe 文件；
Anti ILDASM：反编译；
Obfuscation：混淆；
Create Mapping File：创建地图文件；
Anti Tampering：防篡改；
String Encryption：加密字符；
Compress &amp; Encrypt Resources：压缩并加密资源；
Control FlowObfuscation：混淆控制流。
4、通常勾选“NecroBit、Anti ILDASM、Obfuscation、Anti Tampering 和 String Encryption”，如图2所示：
5、选择 Actions 菜单中的 Protect，则开始加密，加密完成后在源文件同目录下生成一个加密的文件，把这个文件作为软件的发布程序即可在一定程序上确保软件安全。
6、如果想具体设置，则选择 Settings 选项卡，根据需要设置即可，
7、还可以创建 License（签证）文件，选择 License Manager 选项卡，单击 Master Key 右边的 New，可生成一新的 Key，
点击 Create License，输入一个文件名就可以生成签证文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba29d4b6742f551f2facaf738fbed8fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d61fa3656ccdf731967e051aff30cc/" rel="bookmark">
			ORACLE中RECORD、VARRAY、TABLE的使用具体解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自文章：https://www.cnblogs.com/jzssuanfa/p/6749465.html 1 说明 1.1 RECORD
定义记录数据类型。
它类似于C语言中的结构数据类型(STRUCTURE)。PL/SQL提供了将几个相关的、分离的、基本数据类型的变量组成一个总体的方法，即RECORD复合数据类型。在使用记录数据类型变量时，须要在声明部分先定义记录的组成、记录的变量，然后在运行部分引用该记录变量本身或当中的成员。
定义记录数据类型的语法例如以下：
TYPE RECORD_NAME IS RECORD(
V1 DATA_TYPE1 [NOT NULL][:=DEFAULT_VALUE],
V2 DATA_TYPE2 [NOT NULL][:=DEFAULT_VALUE],
VN DATA_TYPEN [NOT NULL][:=DEFAULT_VALUE]);
1.2 VARRAY
数组是具有同样数据类型的一组成员的集合。每一个成员都有一个唯一的下标，它取决于成员在数组中的位置。在PL/SQL中，数组数据类型是VARRAY（variable array。就可以变数组）。
定义VARRAY数据类型的语法例如以下：
TYPE VARRAY_NAMEIS VARRAY(SIZE) OF ELEMENT_TYPE [NOT NULL];
当中，varray_name是VARRAY数据类型的名称。size是正整数。表示能够容纳的成员的最大数量，每一个成员的数据类型是element_typeo默认时。成员能够取空值，否则须要使用NOT NULL加以限制。
1.3 TABLE
定义记录表（或索引表）数据类型。它与记录类型相似，但它是对记录类型的扩展。它能够处理多行记录，类似于C语言中的二维数组，使得能够在PL/SQL中模仿数据库中的表。
定义记录表类型的语法例如以下：
TYPE TABLE NAME IS TABLE OF ELEMENT_TYPE [NOT NULL]
INDEX BY [BINARY_INTEGER|PLS_INTEGER|VARRAY2];
keywordINDEX BY表示创建一个主键索引，以便引用记录表变量中的特定行。
BINARY_INTEGER的说明
如语句：TYPE NUMBERS IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;其作用是,加了”INDEX BYBINARY_INTEGER ”后。NUMBERS类型的下标就是自增长，NUMBERS类型在插入元素时，不须要初始化，不须要每次EXTEND添加一个空间。
而假设没有这句话“INDEXBY BINARY_INTEGER”，那就得要显示对初始化，且每插入一个元素到NUMBERS类型的TABLE中时，都须要先EXTEND。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d61fa3656ccdf731967e051aff30cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8261798c5bd125734b102147ac68c395/" rel="bookmark">
			90后程序员程广坤教你零基础自学编程，用这6种方法就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		90后程序员程广坤，原来学的是数学应用专业，可以说没有程序基础，但是通过自己的自学，现在已成为一家知名网络公司的技术总监。
程广坤表示：
在自学编程的过程中，一部分程序员遇到冰冷的英语字母，枯燥的编程教程，果断选择了放弃。
但其实自学编程不是那么难，只要是理工科生、逻辑思维还行的小伙伴，编程入门完全可以。
下面程广坤给程序员小伙伴们分享自学编程的6种方法，这些方法足够帮助你入门、进阶：
0、书本+视频也许是最好的编程学习方式
对于初学者来说，可以采用视频+书籍的方式进行学习。这两种方式形成互补关系。
编程教学视频可以让你迅速掌握编程，但通常比较生动、浅显，不成系统。而书本是比较系统，深入，但是枯燥，所以最好的方法是书和视频结合。
当你已经过了入门期之后，看书、看视频、看博客就可以随心所欲。
1、入门期守一个“熬”字决
自学编程难免遇到这种现象：学了一两个月，发现自己会的不多。
编程在一开始不会有那么大的反馈，这种现象非常正常!关键是你要坚持个三个月到半年的时间，熬过这个艰难的入门期。
2、初学者尽量不要钻牛角尖
入门期遇到难题，耗了半天时间还是没弄懂，可以暂时跳过，知识积累到一定程度，回头再进行解决你会发现简单多了。
3、站在巨人的肩膀上
你遇到的那点小问题，已经有无数前辈也曾遇到过，他们总结了并分享在互联网上了，前人的经验是你的宝贵资源，要善于利用StackOverFlow，Quora，谷歌等。
4、寻一个编程目的
有些程序员学习编程一上来就想着月薪1W+以上，这样的学习过程会非常痛苦，很容易放弃。
最好是奔着一个小项目而学习编程，当你把作品做出来了，就有成就感，同时基本上具备找工作的能力，直接找个初级的开发岗位，再进阶，你的自学之路功与名都有了。
5、反复练习
编程是一门手艺，需要反复练习，脱离书本和视频看是否能独立实现?学到最后的境界无非就是：我亦无他，惟手熟尔。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a58b48c07720cee961ee8f0ca7e3fc9/" rel="bookmark">
			js监听多个input type=radio的按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 $("input[name='bean.resultFileFlag']").change(function () { alert($(this).val()); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aefacdbaf213f22a2311ab0584c33d9/" rel="bookmark">
			C&#43;&#43;——你所不知的 const &#43; &amp;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我原先写过的《c++——左值、右值、左值引用、右值引用》中有谈到引用。
简单来说，引用是参数的别名，不用额外开辟空间，节省开销。
举个例子：左值引用。
int _x = 0; int &amp;tmp = _x; 在C语言中，左值最初指的是可出现在赋值语句左边的实体，但这是引入关键字const之前的情况。
现在，常规变量和const变量都可视为左值，无非一个可修改，一个不可修改。
特殊点在于如下demo：
不同的是const + &amp;可接收左值 和 右值。
int _x = 0; int &amp;tmp1 = _x; int &amp;tmp2 = 0; //错误 const int &amp;rvalue1 = _x; const int &amp;rvalue2 = 0; const + &amp;的用处：
使用const可以避免无意中修改数据的编程错误使用const使函数能够处理const和非const实参，否则将只能接受非const数据使用const引用使函数能够正确生成并使用临时变量。 一、为何要返回引用
举个例子：
T &amp; test1(T &amp;x) { return x; } T test2(T &amp;x) { return x; } void main() { T x, x1, x2; x1 = test1(x); x2 = test2(x); } test1函数 和 test2函数区别在于 一个 ”&amp;”引用符号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aefacdbaf213f22a2311ab0584c33d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a42b644094f5285d722b0a9eda0149/" rel="bookmark">
			案例干货！如何构建物流行业的数据分析模型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综合物流行业有三个普遍的特点，一是规模巨大，规范缺乏；二是集中度低，市场分散；三是货物复杂，需求复杂。这三个特点衍生出了物流企业四大问题，分别是数据匮乏，过程管控无力；利润口径不一，经营决策分歧；成本分摊不明确，客户质量模糊；管理目标不清晰，工作难聚焦。
这四大问题导致了企业难管理、难壮大，成为企业发展的瓶颈。如何高效处理好上述的四大问题，实现企业管理升级？下面我将以盛丰物流公司为例，展示一下如何通过多维度数据分析，建立物流行业的数据分析模型，解决解决综合物流的四大问题，助力企业管理升级。
一、从信息化角度看综合物流四大问题 盛丰物流2001年创建于福州福兴经济开发区，是一家专注于国内干线运输、货物仓储、市区配送、物流解决方案策划与设计的国家5A级综合物流企业，先后获得中国物流百强企业、中国民营物流企业十强、全国制造业与物流业联动发展示范企业等多项荣誉称号。
同时，该公司业务范围涉及全国，拥有280家分公司，规模巨大，市场分散，公司涉及国内干线运输、货物仓储、市区配送等一系列业务内容，货物复杂，需求复杂。
公司信息部总监认为，从信息角度来看物流行业有四大问题所在：
1. 数据匮乏，过程管控无力。在物流行业主要体现在对订单进行闭环流程管理的仓储运输和交易账目进行事后记录的财务系统上。
2. 利润口径不一，经营决策分歧。企业的运营、营销、财务等人员站在各自的数据维度思考问题从而导致观点不一，产生分歧，造成一定的内耗；
3. 成本分摊不明确，客户质量模糊。在运输行业，一个订单往往会通过多段运输来完成，而每一段运输成本又会涉及到其他数个订单。这导致公司在分析客户优劣的时候，更多的情况下是主观的，缺乏客观数据去衡量客户的价值；
4. 管理目标不清晰，工作难聚焦。在解决问题的过程中会发现在很多问题在管理上没有抓手，导致管理下沉时没办法聚焦。
这些原因汇集在一起最终导致了企业管理难度高，管理复制困难，阻碍企业的进一步发展壮大。
二、多维度数据分析解决综合物流四大问题 为解决上述四大问题，盛丰物流决定从运输、结算、经营三个大维度入手，并将其分为货物调度与货物跟踪、应收账款与过程监督、毛利与管理报表这几方面来分析。通过多维度数据分析，使得管理者可以聚焦问题货物，扩大了分公司的管理半径，目前公司的运输订单交付的延迟率降低了53%，应收账款的周转率提高21%，外部审计从最初35天到现在只需5天。
（一）运输管理——货物跟踪与调度
1. 货物跟踪
举一个简单的例子，你在淘宝上买了一件心仪的礼物送给朋友，你总要时常看一下物流信息，礼物有没有发货，到了什么位置，能不能准时送达等等，如果没有货物跟踪，物流信息，相信我们会胡思乱想，甚至会忧心忡忡的，由此可见货物跟踪的重要性。同样对于企业而言，了解货物目前的状况，跟踪货物信息也是尤为重要的。
管理货物运输过程存在两个痛点问题：
时效要求不统一，较依赖人员对客户及货品熟悉程度；管理边界宽，日常工作难以聚焦。 针对这些问题，制定了如下的几个步骤进行处理。第一步，按照日期进行分组，了解到每一天的总票数；第二步，将时效规则嵌入到整个报表中，包括了普运、快运及客户的合同约定，城市、门到门、站到站等信息；第三步，明确节点个数，了解到这些票是停留在始发方，还是在途，还是到达或者是其他状态
通过前三步便可覆盖全部货物，聚焦问题货物。并且可以根据时效规则，方便快捷地观察到订单的延误状态。通过GPS、北斗、司机端小程序、客服电话等方式，获取货物最新的位置信息。
将时效规则植入计算机，利用数据分析，可以有效解决货物跟踪问题，使得管理者可以聚焦问题货物，扩大了分公司的管理半径。
2. 货物调度配载
货物调度要求调度员及时了解车辆、货物信息，对货物的重量和体积比标准掌握得当，做出合理明确的安排。货物调度合理能够将公司的利润最大化，调度不合理会造成资源浪费以及经济损失。目前货物调度配载存在三个痛点问题：
对个人能力依赖比较严重实现传承比较困难工作方法难以复制推广 如何解决上述问题呢？如下图所示，其中运单数据边界包括目前已经在做的货，已经到达了但还没有卸车的货，也包括在途中马上到达的货。通过预约的时间，可以跟客户确定货物运送时间。还可以进行车型和货物的匹配，包括方向、货重、载重。最终实现，晚上货物可能还在路上或者还在卸货中，公司员工就可以做出一个配载的计划。第二天一早，就可以把单子拿走，装货发车，相当于把整个作业都提前了。
利用数据分析作为支撑的辅助时间，从个人能力到群体的复制。截至目前公司的运输订单交付的延迟率降低了53%。
（二）结算管理——过程监督与应收账款
1. 结算过程监控
结算数据一般来讲都是由运输系统产生，财务根据评审记录结果，哪个过程有所缺失，这些钱有可能会被挪用掉。
报表明确了业务收款人员，移交人员，复核人员，出纳四个岗位。根据这张报表可以得知，哪些是已经收款没有移交；哪些是已经移交没有复核的以及已经收到钱还没有到账的。
2. 应收账款监控
应收账款问题，它是一个连续的订单，很多时候发生最大的问题就在于没办法对客户应收账款进行精准分析，宏观有余，微观不足。
收到钱以后，最核心的是要把钱分解到票，为此制作了这么一个报表，如图 9所示。其核心是聚焦未对账金额，倒推数据问题，聚焦业务源头，找出目标问题。
通过以上集中的改造，可以有效地解决成本分摊不明确，客户质量模糊问题。公司的应收账款的周转率提高了21%。
（三）经营分析 ——毛利与管理报表
1. 毛利
经营分析的三个维度，销售毛利（客户毛利）、线路毛利、单票毛利。这里以单票毛利进行说明，单票毛利是最核心的，单交毛利是客户利润、项目利润、机构利润的基石，单品毛利的难度，是在于说数据的完整性，因为成本它是不是一票一成本，它是多票对应低成本，这样一个分摊的规则，包括数据的变动和评断。通过帆软的产品，公司员工不需要花大量的时间用于数据的录入等方面，数据获取更加及时快捷。
2. 管理报表
运营日报是经营中最常用的报表，能准确清晰地把不同条块的成本、收入、利润呈现出来，对整个经营了如指掌。
公司分总每天只需打开运营日报，查看合计数据，就可以了解到公司整个场站的一个真实的运行情况。对管理来讲，它让经营达到了可视化的效果，更重要的是把管理的难度降低了。
综合这两种方式，能够对利润进行有效统一，避免经营的决策分歧，减少内耗。目前，盛丰物流员工无需在花费大量的时间用于基础数据收集，填报，极大地提高工作效率，降低了人力成本。整个月度财报每月1号准时推出。外部审计最初需35天，现只需5天。
三、结语 综上，我们可以看出通过运输、结算、经营多维度数据进行分析，更加高效地解决了数据匮乏，过程管控无力；利润口径不一，经营决策分歧；成本分摊不明确，客户质量模糊的问题，帮助决策层明确自身的管理目标，聚焦工作重点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab782d0fd62811fb06e2ad6c0fed443/" rel="bookmark">
			CentOS7 修改 MySQL 字符集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 MySQL 时，为了让 MySQL 支持中文，需要把字符集修改为 UTF-8，方法如下：
1.查看 MySQL 字符集： // 启动 MySQL [root@localhost ~]# systemctl status mysqld.service // 登录 MySQL [root@localhost ~]# mysql -uroot -p // 查看 MySQL 字符集 mysql&gt;show variables like 'character_set%'; 结果为：
+--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cab782d0fd62811fb06e2ad6c0fed443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48345630391e5d5eac47b5cc275d5946/" rel="bookmark">
			小程序微信登录获取unionid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序微信登录获取unionid 前端登录代码服务端处理注意 前端登录代码 //小程序自动登录 autoLogin(){ const that = this; wx.login({ success(res) { that.code = res.code wx.getSetting({ success(res) { if (res.authSetting['scope.userInfo']) { // 已经授权，可以直接调用 getUserInfo 获取头像昵称 wx.getUserInfo({ success: function(res) { //上传参数到服务器 that.doMiniProgramLogin(code, res.encryptedData, res.iv) } }) } } }) } }) } //小程序点击按钮登录 &lt;button open-type="getUserInfo" @getuserinfo="getuserinfo" withCredentials="true"&gt;授权登录&lt;/button&gt; getuserinfo(e) { let that = this; wx.login({ success(res) { const code = res.code //上传参数到服务器 that.doMiniProgramLogin(code, e.detail.encryptedData, e.detail.iv) } }) } 服务端处理 //小程序登录 router.all('/miniProgramlogin',function(req, res, next){ var request = require("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48345630391e5d5eac47b5cc275d5946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0719fcb92b5822808ee3052d15ef873b/" rel="bookmark">
			FFmpeg在Windows上通过dshow编解码方式设置为mjpeg并实时显示测试代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows上默认的内置摄像头一般支持两种编解码格式：rawvideo和mjpeg。在调用FFmpeg接口时默认的采用rawvideo。这里通过DirectShow实现为mjpeg进行编解码。
通过命令行调用FFmpeg可执行文件：
(1). 可获取Windows上连接的视频设备，命令如下：
ffmpeg.exe -list_devices true -f dshow -i dummy (2). 可获取指定视频设备支持的编解码格式和video size，命令如下：
ffmpeg.exe -f dshow -list_options true -i video="Integrated Webcam" 这里通过C++实现获取连接的视频设备，代码如下：
AVFormatContext* format_context = avformat_alloc_context(); AVDictionary* dict = nullptr; av_dict_set(&amp;dict, "list_devices", "true", 0); AVInputFormat* input_format = av_find_input_format("dshow"); avformat_open_input(&amp;format_context, "", input_format, &amp;dict); avformat_close_input(&amp;format_context); av_dict_free(&amp;dict); 这里通过C++实现支持的编解码格式和video size，代码如下：
AVFormatContext* format_context = avformat_alloc_context(); AVDictionary* dict = nullptr; av_dict_set(&amp;dict, "list_options", "true", 0); AVInputFormat* input_format = av_find_input_format("dshow"); avformat_open_input(&amp;format_context, "video=Integrated Webcam", input_format, &amp;dict); // video=video device name avformat_close_input(&amp;format_context); av_dict_free(&amp;dict); 设置编解码格式通过av_dict_set好像不能成功，这里是通过AVFormatContext的video_codec_id进行设置，通过av_dict_set设置帧率好像也不能成功。通过调用OpenCV的接口进行实时显示，代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0719fcb92b5822808ee3052d15ef873b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb400255269b276919074d1a5b93fa9/" rel="bookmark">
			elementui表格插槽用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如下:
&lt;el-table-column prop="approveStatus" width="100px" label="发布状态"&gt; &lt;template slot-scope="scope"&gt; &lt;span&gt;{{getDictName(scope.row.approveStatus, "approveStatus")}}&lt;/span&gt; &lt;/template&gt; &lt;template slot-scope="scope"&gt; &lt;span v-if="scope.row.approveStatus == '0'"&gt;待发布&lt;/span&gt; &lt;span v-if="scope.row.approveStatus == '1'"&gt;已发布&lt;/span&gt; &lt;span v-if="scope.row.approveStatus == '2'"&gt;发布审批中&lt;/span&gt; &lt;span v-if="scope.row.approveStatus == '3'"&gt;发布审批不通过&lt;/span&gt; &lt;span v-if="scope.row.approveStatus == '4'"&gt;已下架&lt;/span&gt; &lt;span v-if="scope.row.approveStatus == '5'"&gt;下架审批中&lt;/span&gt; &lt;span v-if="scope.row.approveStatus == '6'"&gt;下架审批不通过&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9806d52df01f41068a37984f1117b501/" rel="bookmark">
			新书推荐 | Big C&#43;&#43;中文版（原书第3版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新书推荐
《Big C++中文版（原书第3版）》
点击上图了解及购买
《Java核心技术》作者新作，面向C++初学者，先学习基础理论，之后通过实例逐步掌握面向对象编程思想。
内容简介
本书由经典畅销书籍《Java核心技术》的作者Cay Horstmann撰写，非常适合C++初学者和爱好者阅读，不仅能够帮助新手快速入门，掌握基础知识，而且有益于培养读者解决实际问题的思维和能力。
书中采用传统的讲授方法，首先强调控制结构、过程分解和数组算法，在较为靠前的章节中就适时地引入了对象的概念。从第9章开始，读者将动手设计和实现自定义的类。最后介绍数据结构和算法，涉及高级C++特性。
本书特色
难度适中，适合自学。从C++繁杂的特性中进行精选，既涵盖大多数现代特性及程序设计的基本思想，又保持了适当的学习难度。
深入浅出，阐述透彻。对于一些难以理解的内容，结合文字、图片、代码及习题等多种方式进行讲解，所有代码均可免费下载。
实例学习，强调实战。共包含25个可运行的示例，通过实践帮助读者理解面向对象程序设计，从新手进阶为富有成效的程序员。
作者简介
凯•霍斯特曼（Cay Horstmann） 圣何塞州立大学计算机科学系教授，Java的倡导者，经常在开发人员会议上发表演讲。他是《Java核心技术》的作者，同时也关注Python、Scala、C++等语言，为专业程序员和计算机科学专业学生编写过数十本图书。
目录
出版者的话
译者序
前言
第1章　引言 1
1.1　何谓编程 1
1.2　计算机的组成 2
1.3　机器代码和程序设计语言 4
1.4　熟悉编程环境 5
1.5　分析第一个程序 8
1.6　错误 11
1.7　问题求解：算法设计 12
1.7.1　算法的概念 12
1.7.2　求解投资问题的算法 13
1.7.3　伪代码 14
1.7.4　从算法到程序 14
本章小结 18
复习题 19
练习题 22
编程项目 23
第2章　基本数据类型 25
2.1　变量 25
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9806d52df01f41068a37984f1117b501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae920697b885002dfbcf9289d9b4d149/" rel="bookmark">
			Java的第一次面试（记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空指针异常/微信or支付宝支付/equals与 == /分布式事务/数组取最多次数问题 Java的第一次面试（记录）空指针异常**== 与 equals**微信/支付宝支付的订单号唯一问题数组取最多次数分布式事务问题 Java的第一次面试（记录） Java第一次面试
空指针异常 为什么会有空指针问题？从JVM的内存解释
网上：指针是对象的引用。空指针，就是指针的内容为空。由于这是一个空的指针，指向了声明类型的类的空对象，所以你在应用这个对象的属性或者方法的时候，就会报空指针异常。
那么空指针指向了空的地址还是指向了错误的地址呢还是没指呢？
1.未加载入内存中（方法区）。
2.未初始化。 not initialized，创建了一个引用，没有为该对象分配任何内存。（java堆）
3.指向了null，方法区地址为系统的0地址单元,对象 = null 指向到一个空地址，声明了一个对象的引用，并没有在jvm中开辟内存，已进行存储。同未初始化，但是null有指向。（java堆）
【注：new出来的就已经是实体了，这个实体会占用内存的。】
类的加载
上面的内容涉及类的加载，网上很多我就不在这里说了，可以在这看看JVM内存结构，类加载器、运行时数据区（内存）、执行引擎。
引用自 超级战斗王 ：https://blog.csdn.net/m0_38075425/article/details/81627349
== 与 equals 网上也很多，简单说就是equals比较值，==比较地址。我只说了string比较值，他让我描述源码。string就是逐个比较字符，其实很多包装类也比较的是值。但是对象的话需要重写equals方法。
微信/支付宝支付的订单号唯一问题 我只遇到过支付宝支付唯一，因为做项目的时候就测试支付宝支付，微信支付的订单号那个时候写了，其实这两个都是订单号唯一，否则不能支付。（厚着脸皮问了对方的解决办法！）
解决：
我的: 如果支付不成功，把订单的状态改为一个失效（比如-1），然后复制订单号，新加一条订单，code不变，id自增肯定变了。
【很麻烦，不知道自己的脑子怎么抽了想出这种】
对方: 调用第三方支付开一张新表，新表的中生成新的下单ucode码（这里有有两个，一个是给用户看的code码，一个是下单用的ucode码，一个是订单id），新表包含ucode和订单id，这样一条失效可以创建新的ucode，而且不用复制订单，只需要用id关联即可。
【欸，一说新表就清楚了，但是谁给你机会呢。】
数组取最多次数 开一个map，存储值的内容和次数。map内原来数组的值做键，次数做值这样的键值对&lt;你要记录的值，次数&gt;，最后查map，两次遍历。或者map排序，肯定低于O(n)。
【还有一个想法，可行性未知。当剩下数个数小于当前最大数量值的个数，可以直接出，不用全部遍历，会不会更快点。但是如何获得这个最大数量值的个数。。。。。】
想着map，我说开一个set？？？我是馋set的身子
分布式事务问题 这一块太多了，等我自己理清了再贴。
感谢面试官给我的教训，只会敲代码还是没用！准备不充足没戏！
以上内容，说的有问题，请大佬们务必直接指出，不胜感激！！！谢谢！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d36959f92ac2070d3610758bb278df2d/" rel="bookmark">
			vue   input输入框 聚焦和失焦时内容处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 input输入框聚焦时，如果内容为0，让其置空处理；如果内容为空，在失焦时，让其为0处理；
html: &lt;input class="input-small-mt" @focus="focusPrice($event)" @blur="blurPrice($event)" v-model="i.purchase_price" type="text" /&gt; js: //文本聚焦事件 为0 置空处理 focusPrice:function($even){ if($even.target.value==='0'||$even.target.value===0){ $even.target.value=''; } }, //文本失焦事件 为空置0处理 blurPrice:function($even){ if($even.target.value===''){ $even.target.value=0; } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ede4aa4a2286243ed6dcab2d012e0f1/" rel="bookmark">
			匹配19开头或者20开头的年月日正则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(((19|20)[0-9]{2})(((0[13578]|1[02])((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|11)((0[1-9])|([12][0-9])|30))|(02((0[1-9])|(1[0-9])|(2[0-8])))))|(((([2][0])00)|((19|20)(([02468][048])|([13579][26]))))(((0[13578]|1[02])((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|11)((0[1-9])|([12][0-9])|30))|(02((0[1-9])|(1[0-9])|(2[0-9])))))
匹配19开头或者20开头的年月日正则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14b984c0832e3c3b25a57ce37de7bc36/" rel="bookmark">
			vue &#43; echart 之热力图，关系图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：在默认引入echart 包的时候并没有关系图表，需要自己手动去官网自定义下载。我这边就是这么操作的
1.引入
2.使用
//初始化图表
initGraph() {
var chart = echarts.init(this.$refs.graph)
var graph = this.ChartData;
var newArr = this.ChartData.nodes;
for (var i = newArr.length - 1; i &gt;= 0; i--) {
var targetNode = newArr[i];
for (var j = 0; j &lt; i; j++) {
if (targetNode.name == newArr[j].name) {
newArr.splice(i, 1);
break;
}
}
}
var categories = [];
graph.nodes.map((node, index) =&gt; {
node.itemStyle = null;
node.size = null;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14b984c0832e3c3b25a57ce37de7bc36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4375af506718b26f92383cfeef04a43/" rel="bookmark">
			Vue开发element-ui公共table组件可显隐列和拖拽列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图： 话不多说，直接撸代码 &lt;template&gt; &lt;div class="pub-table-cla"&gt; &lt;el-button-group style="width: 100%;margin-bottom: 10px;"&gt; &lt;div style="width: 50%;float: left;"&gt; &lt;slot name="btnsArea"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style="float: right;height: 30px"&gt; &lt;el-dropdown :hide-on-click='false' style="float: left; margin-right: 10px;margin-bottom: 13px;"&gt; &lt;el-button type="default"class="pub-button-he"&gt; 显示隐藏列 &lt;span v-show="hiddenColumnTotal &gt; 0"&gt;({{ hiddenColumnTotal }})&lt;/span&gt;&lt;i class="el-icon-arrow-down el-icon--right"&gt;&lt;/i&gt; &lt;/el-button&gt; &lt;el-dropdown-menu slot="dropdown" style="overflow-y: auto;max-height: 70%"&gt; &lt;el-dropdown-item v-for="head in headers" :key="head.attr.prop"&gt; &lt;el-switch v-model="head.isShow" :active-text="head.attr.label" @change="headerChange"&gt;&lt;/el-switch&gt; &lt;span&gt;&lt;/span&gt; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;div style="float: right;"&gt; &lt;slot name="searchBtn"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-button-group&gt; &lt;div class="table-height"&gt; &lt;div class="table-wrap w-table"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4375af506718b26f92383cfeef04a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66244cb1ca04abce0a2828309c40e85b/" rel="bookmark">
			vue-bus 切换页面后第一次触发事件接收不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个 Vue 的管理系统，有几个页面使用了同一个组件。想使用 vue-bus 进行组件间的通信，子组件发布消息，在父组件的 created 中用 on 监听，然后在父组件的 beforeDestory 中使用 off 销毁（否则会重复多次触发事件）。遇到了一个问题，在使用相同组件的页面间切换后，子组件发布消息时，父组件接收不到，必须刷新一次当前页面才可收到消息。后来发现原因在于 Vue 的生命周期。
测试了一下跳转页面时，两个页面的生命周期钩子的执行顺序，代码如下：
// 页面1 beforeCreate () { console.log('1: beforeCreate'); }, created () { console.log('1: created'); }, beforeMount () { console.log('1: beforeMount'); }, mounted () { console.log('1: mounted'); }, beforeUpdate () { console.log('1: mounted'); }, updated () { console.log('1: updated'); }, beforeDestroy () { console.log('1: beforeDestroy'); }, destroyed () { console.log('1: destroyed'); } // 页面2 beforeCreate () { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66244cb1ca04abce0a2828309c40e85b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ee56727cb64d6f12cc2323d5faae31/" rel="bookmark">
			矩阵的迹tr运算及矩阵求导公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、矩阵的迹tr运算 二、矩阵的迹对矩阵求偏导 三、标量函数和矩阵函数对矩阵求偏导 1.向量*矩阵，对矩阵求导
2.矩阵*矩阵，对矩阵求导
3.向量*矩阵，对向量求导
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612cce40ab5460870e01f08218d31854/" rel="bookmark">
			Duplicate keys detected: &#39;3&#39;. This may cause an update error.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复制数据时，id没改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c64501ccca73ef6ce6c56583d6445f6/" rel="bookmark">
			c&#43;&#43;  1.指针和结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、指针运算符
C++ 提供了两种指针运算符，一种是取地址运算符 &amp;，一种是间接寻址运算符 *
&amp; 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 &amp;var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 &amp; 运算符读作"取地址运算符"，这意味着，&amp;var 读作"var 的地址"。
间接寻址运算符 *，它是 &amp; 运算符的补充。* 是一元运算符，返回操作数所指定地址的变量的值。
箭头运算符与点运算符有关，对于一个指针ptr，表达式ptr-&gt;mem等价于(*ptr).mem；
string s1 = "a string",*p = &amp;s1; auto n = s1.size();//运行string对象s1的size()成员 n = (*p).size();//运行p所指对象的size成员 n = p-&gt;size(;)//等价于(*p).size //点运算符针对对象和对象的成员，箭头运算符针对的是指针和成员； #include &lt;iostream&gt; using namespace std; int main () { int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = &amp;var;//ptr存放取出来的地址 // 获取 ptr 的值 val = *ptr;//*寻找地址的内容，存放在val中 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c64501ccca73ef6ce6c56583d6445f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc23082692bb86483fe7a72d5bcd5b4e/" rel="bookmark">
			Access to XMLHttpRequest at &#39;http://localhost:8080/api/login&#39; from origin &#39;http://localhost:8080&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方案：
1.在被请求的php文件中加入请求头部
header('Access-Control-Allow-Origin: *'); &lt;?php header('Access-Control-Allow-Origin: *'); $arr = [ array('id'=&gt;1,'title'=&gt;'one') ]; echo json_encode($arr); ?&gt; 2.nginx代理配置项加上允许跨域：
add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Credentials 'true'; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers *; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa5b7a8f09fc9b42223317e9755d4b3/" rel="bookmark">
			非线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 无约束最优化问题 标准形式： 求解思想： 求解算法： 非线性规划问题： 如果目标函数或约束条件中至少有一个是非线性函数时的最优化问题就叫做非线性规划问题。
一般形式： 注：其他非标准情况可以通过转换变成标准形式，比如求目标函数的最大值、约束条件小于0等。
三个定义： 罚函数： 基本思想是通过构造罚函数把约束问题转化为一系列无约束最优化问题，进而用无约束最优化方法去求解．这类方法称为序列无约束最小化方法．简称为SUMT法．其中SUMT法包含SUMT内点法和SUMT外点法。
二次规划：若非线性规划的目标函数为自变量X的二次函数，约束条件是线性的，则为二次规划。一半非线性规划和二次规划可以通过matlab来求解。
由于图比较多，我还比较懒，CSDN的编译器不能直接导入word，所以只简单介绍了。具体的可以点击我的主页，在我的资源中下载文件，没积分的留言“1”，我给你发百度云资源或私发。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943a8471416f9d88e0e77135b66b7b94/" rel="bookmark">
			安卓刷机教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#wmd-preview h1 {
color: #0077bb; /* 将标题改为蓝色 */
}
安卓刷机教程 1. 刷入第三方recovery 【根据手机型号下载recovery】
1.按住关机键及音量下键进入fastboot模式 2.手机连接电脑 3.使用附件【一键刷入recovery】中的工具点击一键刷入recovery 3.根据弹出窗口提示刷入 刷入完成后自动重启进入如下图所示界面
2. rom包下载 在如下地址中下载想要刷的系统 刷的时候注意看各个刷机包的注意事项
【红米4a手机刷机包下载地址】
如上如所示的点击第一个
进入如下 注意绿色的标注系统的安卓版本为10.0 如果需要下载其他版本的刷机包 返回前一页向后面翻页 默认刷机包排序按照按照版本倒叙排列
以此10.0举例 点击如上图的download进入如下页面 【此刷机包的详情页面】
如上图所示看清楚刷机注意事项等信息
点击图下方的连接下载相应的系统包 以及google服务框架
下面提供了一些原生系统的论坛及网站
安卓手机原生系统论坛
安卓原生系统论坛地址1
安卓原生系统论坛地址2 安卓定制系统
安卓系统下载
3. Gapps下载 谷歌服务框架地址
点击上面的超链接 进入如下图所示的页面 选择对应的版本进行下载 4.magisk下载(用于获取root权限)
magisk下载及使用教程
刷机注意事项
1. 擦除
点击wipe 进入如下图所示的
选中除internal storage 和 Microsd 及usb otg之外的所有 滑动下方的滑块 全部进行擦除 2.读取不到内部存储时
进入首页的地5个 mount中 查看下方的第二个是否为Disable mtb 若不是 点击切换 若是 依然读不到内部存储 则点击切换两次尝试是否可以读到内置存储卡
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943a8471416f9d88e0e77135b66b7b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c2f1b3d5ade8649eca2190982f4add0/" rel="bookmark">
			Hive性能调优之并行执行(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive会将一个查询转化成一个或者多个阶段。这样的阶段可以是MapReduce阶段、抽样阶段、合并阶段、limit阶段。或者Hive执行过程中可能需要的其他阶段。默认情况下，Hive一次只会执行一个阶段。不过，某个特定的job可能包含众多的阶段，而这些阶段可能并非完全互相依赖的，也就是说有些阶段是可以并行执行的，这样可能使得整个job的执行时间缩短。不过，如果有更多的阶段可以并行执行，那么job可能就越快完成。
通过设置参数hive.exec.parallel值为true，就可以开启并发执行。不过，在共享集群中，需要注意下，如果job中并行阶段增多，那么集群利用率就会增加。
set hive.exec.parallel=true; //打开任务并行执行 set hive.exec.parallel.thread.number=16; //同一个sql允许最大并行度，默认为8。 当然，得是在系统资源比较空闲的时候才有优势，否则，没资源，并行也起不来。
本次关于Hive性能调优的分享就到这里了,喜欢的小伙伴们记得点赞加关注哟。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbae24f77cacc405c149510107f459e/" rel="bookmark">
			Android项目迁移到Androidx经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于迟早要迁移到androidx，领导就把这个任务给了我。网上关于Androidx的介绍基本照抄的官方，或是写一个简单的HelloWorld Demo作演示，但是我希望知道的是在庞大或者有很多第三方依赖的项目中如何迁移到Androidx。既然网上没找到想要的，那就只能自己摸索了，最后在大神的帮助下终于迁移成功，感谢坐我旁边的大神。
下面是对我自己项目迁移的经验总结，供参考：
关于Androidx Androidx其实就是将Android Support Library中的代码改包名移到了androidx，为了解决support-v4、v7包依赖的混乱问题。关于什么是Androidx可以看下郭神的这篇博客谷歌官方文档提供了support包与Androidx库的对应关系等，这是传送门 迁移总结 Android Studio菜单：Refactor &gt; Migrate to AndroidX，一路点确定即可，然后运行项目，如果报错就对了，往下看。
迁移完后gradle.properties文件会多出这两句：
android.useAndroidX=true，这个不解释
android.enableJetifier=true，这个的官方解释是：Android 插件会通过重写其二进制文件来自动迁移现有的第三方库以使用 AndroidX。意思是如果你的第三方库依赖了support包且其没有升级到Androidx，没关系，AndroidStudio在打包的时候会把这些support包都改为Androidx包。 所以这个值设为ture后那些依赖了support包的第三方依赖可以不用改。
但是，那些通过注解等方式在build目录中生成的代码如果依赖support包的话就不行了。那么哪些第三方依赖会有这种问题呢？
有问题的第三方依赖：
butterknifeglidedeeplinkdispatch，这个依赖主要是用于外部链接跳转指定页面 解决方法也很简单，将它们升级到新版本
butterknife
插件版本：classpath 'com.jakewharton:butterknife-gradle-plugin:10.0.0'
依赖版本：
api "com.jakewharton:butterknife:10.0.0" api "com.jakewharton:butterknife-compiler:10.0.0" glide，依赖版本：
api "com.github.bumptech.glide:glide:4.10.0" api "com.github.bumptech.glide:compiler:4.10.0" api "com.github.bumptech.glide:okhttp3-integration:4.10.0" deeplinkdispatch, 依赖版本：
api "com.airbnb:deeplinkdispatch:4.1.0" api "com.airbnb:deeplinkdispatch-processor:4.1.0" 以上升级的版本有些不是最新版，因为最新版可能对gradle插件版本有要求。目前我的gradle版本是gradle-4.6-all.zip，插件版本是'com.android.tools.build:gradle:3.2.1'
改到这里应该就可以运行的，但是还是出现dontwarn报错，发现是混淆的问题，这种情况可能是升级的第三方依赖混淆有改动，看官方文档即可。
还有关键一步：全局搜索support、v4、v7、design、app:layout_behavior等，确保都改了。尤其是用到CoordinatorLayout的地方，他的app:layout_behavior属性值引用的可能还是support包的。
最后，附上我的项目中不需要改动的第三方依赖不完全名单：
项目Valuegson‘com.google.code.gson:gson:2.7’greendao‘org.greenrobot:greendao:3.2.0’joda-time‘joda-time:joda-time:2.9.7’SmartRefreshLayout‘com.scwang.smartrefresh:SmartRefreshLayout:1.1.0-alpha-5’leakcanary-android‘com.squareup.leakcanary:leakcanary-android:1.6.3’leakcanary-android-no-op‘com.squareup.leakcanary:leakcanary-android-no-op:1.6.3’blockcanary-android‘com.github.markzhai:blockcanary-android:1.5.0’blockcanary-no-op‘com.github.markzhai:blockcanary-no-op:1.5.0’bugly‘com.tencent.bugly:crashreport:latest.release’bugly‘com.tencent.bugly:nativecrashreport:latest.release’wechat-sdk-android-without-mta‘com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+’tencent tbssdk‘com.tencent.tbs.tbssdk:sdk:43697’高德map2d‘com.amap.api:map2d:latest.integration’高德地图搜索‘com.amap.api:search:latest.integration’zxing-library‘cn.yipianfengye.android:zxing-library:2.1’rxjava‘io.reactivex.rxjava2:rxjava:2.2.1’rxandroid‘io.reactivex.rxjava2:rxandroid:2.1.0’arouter-api‘com.alibaba:arouter-api:1.4.1’arouter-compiler‘com.alibaba:arouter-compiler:1.2.2’glide-transformations‘jp.wasabeef:glide-transformations:4.1.0’flexbox‘com.google.android:flexbox:1.0.0’walle‘com.meituan.android.walle:library:1.1.6’multitype‘me.drakeet.multitype:multitype:3.4.4’oneapm‘com.oneapm.agent.android:agent:5.5.4.0’ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8803850811ab95ded35518d1a24813f/" rel="bookmark">
			解决httpServletRequest.getParameter获取不到参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用httpServletRequest.getParameter接收post请求参数，发送端content Type必须设置为application/x-www-form-urlencoded；否则会接收不到
@RequestMapping(value = "/a2") @ResponseBody public String hello3(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { String string = httpServletRequest.getParameter("json"); System.out.println(string); return "hahah"; } 用@RequestBody接收请求可以用任意类型的content Type
@RequestMapping(value = "/a") @ResponseBody public void hello1(@RequestBody String string) { System.out.println(string); } application/x-www-form-urlencoded通过表单提交，在sevlet实现中，mutipart/form-data和application/x-www-form-urlencoded会被特殊处理，请求参数将被放置于request.paramter，这是一个map。我们可以从map中获取参数进行验证，或者其他拦截需求，map的获取类似hibernate的延迟加载，当调用request.getparamter(）方法，servlet才会从请求流中读取请求参数加载入map。InputStream也会存有这份数据，但如果这份数据被读取，那么到了controller层将无法读出数据，同样，拦截之后到达controller层时请求数据已经被加载入了controller层方法实参，实参对象需要有set方法，框架会以反射的方式调用属性的set方法注入数据，数据只会被注入到已有的属性。
当以application/json的content-type传送数据，被传送的对象只需被json序列化。当以application/x-www-form-urlencoded的方式传送数据。请求的内容需要以..=..&amp;..=..的格式提交，在请求体内内容将会以”&amp;”和“ = ”进行拆分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6759d2498fc15cd071f7a1fb405ad3f5/" rel="bookmark">
			OpenWrt 4G路由器DIY
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言PCB板刷固件4G上网设置无线配置NTP修改微信公众号 前言 OpenWrt 硬件 环境配置编译
OpenWrt 固件定制
第一节讲了下OpenWrt的硬件, 源码下载, 编译, 第二节照猫画虎自己定制了DQ7688的固件(如何换Logo自己查去), 还差一个自己的OpenWrt的板子就可以去骗经费了, 嗯, 硬件它来了&lt;-&gt;_&lt;-&gt;
PCB板 铛铛铛, 先是正面照:
现成Mini PCIe接口的移远EC20(Main口插4G天线)左边4个LAN口右边1个WAN口USB Type-C供电+调试接口(CP2104转串口接到MT7688的调试串口上):贴上DQ7688的Logo 背面:
左下角CP2104(USB转串口)左边5V-&gt;3.3V(MT7688)+3.9V(4G)电源中间 HiLink普通OpenWrt版的MT7688A , 某宝50多元, 开盖是 MT7688AN, NT5TU64M16HG 128MB RAM, W25Q256FVE 32MB Flash, 上节固件定制的16MB的也能用, 可以改一下Flash配置重新编译一遍右上角插Micro-SIM卡 两层板轻轻松松搞下来, 不过不建议, 最好4层板, 性能好一点, 遗憾的忘记把复位键搞上去, 需要复位的时候自己焊了杜邦针, 复位的时候点下地, 有点麻烦.
别忘记接4G天线和2.4G WiFi天线, 有外壳的话固定到外壳正好.
HLK-7688A默认引脚图:
刷固件 上篇 OpenWrt 固件定制 中因为下载太慢去掉了luci-app-samba和 luci-app-qos, 用make V=99编译, 中间又联网下载了其他东西, 花费了大概3个小时最终生成了bin文件: /bin/targets/ramips/mt76x8/openwrt-ramips-mt76x8-dq7688-squashfs-sysupgrade.bin, 大小5.8MB. 拷贝这个文件到Windows电脑桌面.
刷固件的方式参考上上篇: OpenWrt 硬件 环境配置编译 , 下面再啰嗦一下, 注意PCB板子和Windows电脑各自连到局域网中.
USB Type-C线连接PCB板到Windows电脑, 设备管理器查看串口号COM68, 打开Putty, 串口连接类型, 波特率57600:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6759d2498fc15cd071f7a1fb405ad3f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab4c95f7c616c6b58f5a9e44bb83d62/" rel="bookmark">
			27报网MM爬虫福利一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		27报 http://www.126z.net/z/2019/11/28/41365.html
刚学爬虫花了4个小时写的，每一步备注的都很清楚，喜欢的朋友自己可以研究研究......
目标网站：http://www.126z.net
环境：Python3.x
相关第三方模块：requests、lxml
Re：各位在测试时只需要打开终端，使用 python xxx.py 运行即可。
源码如下:
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import time
import requests
from lxml import etree
class MeiZiSpider(object):
"""27 bao website MM spider"""
def __init__(self):
self.base_url = 'https://www.126z.net/meinv/list_1.html'
self.headers = {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)'}
# 构建url的前缀
self.url_prefix = 'https://www.126z.net'
# 构建第二层url的前缀
self.inner_url_prefix = 'https://www.126z.net/meinv/'
# 构建点开每个MM内部的所有url
self.inner_url = 'https://www.126z.net/meinv/56870_{}.html'
# 文件保存的路径
self.path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab4c95f7c616c6b58f5a9e44bb83d62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662e653bed043ecbc534f00964d0e4da/" rel="bookmark">
			访问laravel项目时候出现vendor/autoload.php): failed to open stream: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Warning: require(D:\downEmail\laravleone\bootstrap/../vendor/autoload.php): failed to open stream: No such file or directory in D:\downEmail\laravleone\bootstrap\autoload.php on line 17
Fatal error: require(): Failed opening required 'D:\downEmail\laravleone\bootstrap/../vendor/autoload.php' (include_path='.;C:\php\pear') in D:\downEmail\laravleone\bootstrap\autoload.php on line 17
首先执行 自动加载 //再此运行composer dump-autoload
然后 conposerupdate 最后出错laravle key不存在的时候
最后设置key
php artisan key:generate 设置key
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142699627a0b79d9766c0c2c2f27d4b6/" rel="bookmark">
			本地仓库关联远程仓库（通过仓库地址SSH关联）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将本地仓库（或者说本地项目）推送到远程仓库（或者说远程项目）还需要一步认证。
例如将我的MyTest本地仓库关联到GitHub远程仓库。
打开我的MyTest本地仓库&gt;&gt;鼠标右键&gt;&gt;Git Bash Here&gt;&gt;
在Git Bash Here中输入
git remote add + 代号 + 远程仓库的地址
如下图：本地仓库跟GitHub远程服务器的该地址的仓库建立联系，本地仓库跟码云远程服务器的的该地址的仓库建立联系。 目的是将本地仓库跟远程仓库关联起来；之前的本地PC跟远程服务器关联是为了将本地服务器跟远程服务器关联。
举个例子：
本地PC在A幢楼，GitHub远程服务器在B幢楼， 码云远程服务器在C幢楼，假设有个送货员，现在只负责A幢往来B幢、A幢往来C幢；B幢楼和C幢楼的门口有人脸识别进出通道，要想”随意“进出B幢或C幢就必须分别在他们小区物业那里做人脸识别注册(本地生成的公钥粘贴到GitHub或码云服务器的Key中)，这样就可通过人脸识别”随意“进出该栋楼（远程服务器），如果A幢还要跟D幢楼往来（如coding服务器），只需要在D幢楼物业（coding远程服务器）那里做个人脸识别注册（本地生成的公钥粘贴到coding服务器的Key中）。这样就将本地服务器跟多个远程服务器关联了。
但是我本地PC上有很多仓库，远程服务器也有很多仓库，本地PC中的某个仓库要推送到远程服务器中的哪个仓库或从远程服务器中的哪个仓库中拉取数据？
这时就需要将本地PC中的仓库跟远程服务器中的仓库关联。
继续举例：
假设需要将A幢楼（本地PC）里房间101号（某个仓库）里的文件备份一份放到B幢的房间501号和C幢的房间1201号（远程服务器的某个仓库）去，这时候该房间人找来”送货员“给他B幢和C幢要送达房间的各一把钥匙，钥匙上有收货地址（代号 + 远程仓库的地址(SSH)；代号可以任意取名，一般如果是关联到GitHub远程仓库，代号我就写github;如果是关联码云远程仓库，代号我就写gitee），A幢房间101号只需要给送货员一次钥匙，以后这把钥匙由”送货员“保管（关联远程某个仓库只需添加注册一次）。
这时就将本地仓库跟远程仓库关联起来。
我们查看一下本地仓库关联了几个远程仓库。
在当前仓库中右键进入Git Bash Here，输入
git remote -v 如下图：本地仓库跟码云服务器中的仓库和GitHub服务器中的仓库建立了联系。
以后，我们只需要考虑将本地仓库推送到哪个”代号 + 分支“中取就可以了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/224/">«</a>
	<span class="pagination__item pagination__item--current">225/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/226/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>