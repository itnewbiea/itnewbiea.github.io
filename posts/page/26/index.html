<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f303130e4b4b2dafa2481602578e34b/" rel="bookmark">
			车载工业路由器：连接智能化未来的关键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今日益智能化的汽车行业中，车载工业路由器成为了连接智能化未来的关键。随着车联网技术的快速发展，越来越多的车辆需要与互联网进行数据交流，车载工业路由器应运而生。
一、车载工业路由器
车载工业路由器作为车辆与互联网进行数据交互的核心设备，具备丰富的功能。首先是稳定可靠的数据传输能力，通过高速的4G/5G网络，车载工业路由器可以快速传输车辆数据、导航信息等。其次是强大的数据处理能力，车载工业路由器具备高性能的处理器和大容量的内存，能够对海量数据进行快速处理和存储。此外，车载工业路由器还支持多种通信协议，如Wi-Fi、蓝牙、RS232等，实现与车载设备的互联互通。同时，车载工业路由器具备丰富的安全防护功能，能够抵御网络攻击、保护车辆数据的安全。
二、车载工业路由器的应用场景
车载工业路由器在各个领域都有着广泛的应用。在智能交通领域，计讯物联车载工业路由器可以实现车辆之间、车辆与交通设施之间的高效通信，提升交通运输的智能化水平。
在车辆远程监控领域，车载工业路由器可以通过互联网实时获取车辆的位置信息、行驶状态等数据，提供给后台管理人员进行监控和管理。
在车载娱乐领域，车载工业路由器可以提供高速稳定的Wi-Fi信号，使车内乘客可以随时享受各种网络娱乐服务。
此外，车载工业路由器还可应用于公共安全、物流运输等领域，为各行各业的发展提供技术支持。
三、车载工业路由器的发展前景
随着汽车智能化的迅速发展，车载工业路由器市场也得到了快速增长。据市场研究机构预测，未来几年车载工业路由器市场规模将持续扩大。一方面，汽车企业将越来越注重为车辆提供智能化的服务和功能，车载工业路由器将成为实现这一目标的重要组成部分。另一方面，随着5G网络的普及，车载工业路由器将能够提供更快速、更稳定的网络连接，满足用户对高速互联的需求。因此，车载工业路由器具有广阔的发展前景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eadb5179a7b92a5ee1f90d761e22a1d1/" rel="bookmark">
			不同类型的效度汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效度定义 效度在测量理论中的定义为：在一系列测量中，与测量目的相关的真变异数和总变异数的比。效度反映了测量方法的有效程度或正确性，即测量问卷题是否准确有效，对问卷进行效度检验是实证研究的基本前提，对最终结果的准确性和有效性有重要影响。其一般可以分为四大类：结构效度、内容效度、效标效度以及其它效度（判别效度和聚合效度）。
二、结构效度 1、结构效度说明 结构效度又称构想效度用于测量结果的数据结构与问卷设计是否相符。即研究所测量因子与题项之间的对应关系是否符合预期假设。测量结果的各内在成分是否与设计者打算测量的领域一致。一般可以使用因子分析或者验证因子分析判断结构效度的好坏。
2、结构效度操作 结构效度的分析主要使用因子分析，其通过从量表全部变量中提取一部分公因子分析因子中累积贡献率，共同度等，评价实测指标性质与设计目标是否吻合，如果因子提取的公因子与量表设计时确定的各领域有密切的逻辑关系，则说明有良好结构效度。其操作以SPSSAU为例【进阶方法】→【探索性因子】：
因子个数：意为所将分析项划分为几个因子（比如预期共划分4个维度，这里直接选择4即可），如果没有预期维度则无需选择，系统会自动按照特征根大于1的标准进行选择因子个数。相关系数矩阵：提供分析项的相关性情况，相关性若低可能影响KMO值，相关性若过高（比如大于0.8），意味着信息重叠性高没可能存在共线性。因子得分：得到因子得分可以进行后续分析，比如回归分析等。综合得分：综合得分一般用于后续综合对比等。旋转方法：包括最大方差法和最优斜交法。最大方差法的主要目标是找到一个投影方向，使得在该方向上不同类别的样本投影后的方差最大。这种方法假设方差越大，则分类效果越好。最优斜交法通过最小化同类样本之间的距离和最大化不同类别之间的距离来提高分类准确率。一般最大方差法使用较多。 3、结构效度分析流程 在分析前首先进行设置维度个数，当然也可以不进行设置，spssau会默认以特征根大于1为标准进行设置，然后进行查看KMO值和巴特利特检验，目的是为了查看数据是否适合进行因子分析，进行因子分析时大多需要对模型进行调整，其中包括删除“共同度”值较低的项以及“错位”的分析项，什么是错位？比如某分析项本来应该属于因子1但是在结果展示却是因子2，这样的分析项需要考虑删除后在进行分析，重复进行调整直到结构一致，然后在对因子提取和信息浓缩进行简单分析。
4、结构效度指标说明 对于进行结构效度一些常见的指标说明如下：
Kmo值
进行结构效度的正式分析前，第一步需要通过KMO和巴特利特检验进行测量问卷量表进而决定是否适合进行因子分析，KMO值是用来判断所选取变量在因素分析中的可接受程度，考察变量之间相关关系，其计算公式为： kmo约等于0，所以kmo取值介于0到1之间。那么kmo值的判断标准是怎么样的呢？ 一般进行因子分析需要kmo值大于0.6即可。处理之外还需要关注巴特利特检验。
巴特利特检验
巴特利特检验原理上是检验各变量是否独立，确定因素的相关性，如果模型显著（对应的p值小于0.05）说明适合因子分析。特征根
特征根值一个方阵在线性变化下的变化率，指标旋转前每个因子的贡献程度。此值的总和与项目数匹配,此值越大,代表因子贡献越大。 当然因子分析通常需要综合自己的专业知识综合判断,即使是特征根值小于1,也一样可以提取因子。方差解释率
方差解释率表格，主要用于判断提取多少个因子合适。以及每个因子的方差解释率和累计方差解释率情况。方差解释率越大说明因子包含原数据信息的越多。因子分析中，主要关注旋转后的数据部分。累积方差解释率
累积的方差解释率，所有因子提出的信息量，累积方差解释率一般认为大于60%比较合适。因子载荷系数
因子载荷系数用于衡量观测变量与因子之间的相关程度，一般用于反映观测变量在因子中的贡献程度或者权重，其数值范围一般在-1到1之间，绝对值越大说明观测变量和因子的相关程度就越高。当绝对值为1时，说明观测变量与因子之间存在强相关关系。可以利用此指标进行判断因子与观测变量的对应关系。共同度
因子分析中的共同度也称公因子方差，共同度可以衡量变量之间的相关性，从而了解变量之间的关联程度。并且共同度可以筛选出对因子解释度高的变量，进而简化模型提高模型的解释率，共同度可以通过因子载荷矩阵进行计算。在因子分析中一般要求大于0.4。碎石图
结合碎石图辅助判断因子提取个数。当折线由陡峭突然变得平稳时，陡峭到平稳对应的因子个数即为参考提取因子个数。MSA指标 MSA(Measure of Sample Adequacy)指标测量某项与其余项的相对相关关系情况，MSA指标=A/(A+B)，A为该项与其余项相关系数平方和，B为该项与其余项偏相关系数平方和，MSA指标的意义为某项与其余各项的相关关系情况，该值介于[0,1]之间，如果MSA指标值过低（比如小于0.2），意味着其可能对信息浓缩帮助较小，可以考虑对其进行删除，以提高KMO值表现等。
5、结构效度举列分析 （1）因子适合度分析
KMO值越大越适合进行因子分析，通常认为KMO值≥0.6是进行因子分析的必要条件。Bartlett 球形检验用于测量变量之间的相关性，判断标准为p值 ≤0.05（或者0.1、0.01）。
（3）公因子提取
如果没有预期划分因子个数，一般会以特征根大于1进行提取因子个数,如果有预期划分个数一般在分析前进行选择即可，一般而言，特征根小于1也是可以进行提取因子个数的。
（2）调整因子对应关系
进行筛选分析项的一般标准为：
项目的载荷值需要小于0.4需考虑删除；每个因子最少对应两个分析项；删除与因子对应不一致的项，比如分析项A1对应因子1，但是在分析结果中，分析项A1对应因子2，此时考虑将此分析项进行删除后分析； 此过程是多次重复进行的过程，直至分析项与因子对应，此过程结束。最后因子载荷矩阵如图中所示：
案例来源：疏德明.大学生创业胜任力、创业意向及创业教育的现状与关系[D].苏州大学,2018.
三、结构效度延伸 判别效度和区别效度实质上也是结构效度，具体说明如下。
1、判别效度 判别效度（又称区分效度、区别效度），其评价指标一般包括因子载荷系数和平均方差抽取值，其一般是指不在同一因子下的题项不会被构成在同一个因子中，判断区分效度的好坏一般有三种：AVE和相关系数结果对比，HTMT法以及MSV和ASV法。接下来一一进行说明。
AVE和相关分析结果对比 AVE和相关分析结果对比：是使用AVE的平方根值，然后与因子的相关系数进行对比，如果AVE平方根值大于“该因子与其它因子间的相关系数”，此时说明具有良好的区分效度。AVE平方根值可表示该因子的‘聚合性’，而相关系数表示相关关系，如果该因子自己‘聚合性’很强（明显强于与其它因子间的相关系数），则能说明具有区分效度。
HTMT法 HTMT法也称异质-单质比率：通常情况下使用AVE平方根法较多，HTMT法使用相对较少；如果说HTMT值全部均小于0.9,此时说明数据具有区分效度。
MSV和ASV法 MSV和ASV法，该2个指标可用于区分效度分析（区分效度还可使用Pearson相关与AVE值对比法），一般情况下MSV和ASV值均小于AVE值则说明具有较好的区分效度。
SPSSAU中提供的分析表格：
2、聚合效度 聚合效度也称收敛效度。聚合效度强调本应该在用一个因子下面的测量项，确实在同一个因子下，一般观察AVE和CR指标。AVE反映了每个潜变量所解释的变异量中有多少来自该潜变量中所有题目，加入AVE越高，则表示潜变量（factor）有越高的收敛效度，一般需要大于0.5，不小于0.36，标准化因子载荷大于0.5，CR值是所有测量变量信度的组合，表示潜变量（factor）的内部一致，所以CR值越高，表示内部一致性越好，一般大于0.7。
比如以SPSSAU为例，针对Factor1，其AVE平方根值为0.924，大于因子间相关系数绝对值的最大值0.851，意味着其具有良好的区分效度。针对Factor2，其AVE平方根值为0.895，小于因子间相关系数绝对值的最大值0.917，意味着其区分效度欠佳，可考虑移除标准载荷系数值较低项后重新分析。针对Factor3，其AVE平方根值为0.930，大于因子间相关系数绝对值的最大值0.917，意味着其具有良好的区分效度。Factor4、Factor5也同理。一般文献中的表达方式如下：
如果区分效度不好，通常是由于出现‘错位’现象，比如Factor1里面有5个量表题，很可能其中2个题放在Factor2里面更适合。一般是结合载荷系数值判断出此类题，然后删除掉此类题（或者进行移位）即可。
聚合效度不好的原因可能有以下几种：
量表设计不合理：量表的设计是影响聚合效度的关键因素之一。如果量表的设计不合理，例如测量项与预期的因子结构不匹配，会导致聚合效度不佳。样本特征不匹配：样本特征也是影响聚合效度的因素之一。如果样本特征与量表设计不匹配，例如样本的年龄、性别、职业等因素与量表中的测量项不相关，会导致聚合效度下降。测量误差大：测量误差是影响聚合效度的另一个因素。如果测量误差大，例如由于环境噪声、仪器误差等原因导致的数据不准确，会导致聚合效度下降。 先进行探索性因子分析后在进行验证性因子分析。
四、内容效度 1、内容效度说明 内容效度（CVI）指的是实际测量得到的内容与索要测量的内容之间的吻合程度，主要测量方法有专家判断法、统计分析法和经验推断法。
专家判断法：就每一条目与相关内容维度的关联程度，认为关联较高的专家人数与总人数之比，即为内容效度；
统计分析法：包括复本信度、折半信度和再测法等；
经验推断法：通常通过实验进行检验效度。
一个测验进行内容效度需要进行具备两个条件，第一测验内容的范围需要明确，第二取样需要具有代表性。
2、内容效度判断标准 内容效度一般分为条目内容效度和量表内容效度，一般认为，条目内容效度大于0.78，量表内容信度大于0.9认为内容效度较好。常用的内容效度的评价方法有两种：
专家法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eadb5179a7b92a5ee1f90d761e22a1d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9316cbd3561724fad1137ca92841495e/" rel="bookmark">
			python股票分析挖掘预测利器Numpy,Pandas，Matplotlib库经典练习题和项目代码（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人股市多年的老韭菜了，各种股票分析书籍，技术指标书籍阅历无数，萌发想法，何不自己开发个股票预测分析软件，选择python因为够强大，它提供了很多高效便捷的数据分析工具包，
其中数据分析中常见的3大利器---Numpy,Pandas，Matplotlib库。
俗话说的好，工欲善其事，必先利其器，我们要做好项目，必先打好基础，那我们一起学习一下这三个数据分析库，我们前三章讲了Numpy库基础，Pandas库基础，Matplotlib库基础，
那我们这一章学习一下Numpy,Pandas，Matplotlib库在项目中的常见用法：
(1)Numpy知识代码 (1)常用科学计算函数代码： import numpy as np print(np.abs(-10)) # 求绝对值，该表达式返回10 print(np.around(1.2)) # 去掉小数位数，该表达式返回1 print(np.round_(1.7)) # 四舍五入，该表达式返回2 print(np.ceil(1.1)) # 求大于或等于该数的整数，该表达式返回2 print(np.floor(1.1)) # 求小于或等于该数的整数，该表达式返回1 print(np.sqrt(16)) # 求平方根值，该表达式返回4 print(np.square(6)) # 求平方，该表达式返回36 print(np.sign(6)) # 符号函数，如果大于0则返回1，该表达式返回1 print(np.sign(-6)) # 符号函数，如果小0则返回-1，该表达式返回-1 print(np.sign(0)) # 符号函数，如果等于0则返回0，该表达式返回0 print(np.log10(100)) # 求以10为底的对数，该表达式返回2 print(np.log2(4)) # 求以2为底的对数，该表达式返回2 print(np.exp(1)) # 求以e为底的幂次方，该表达式返回e print(np.power(2,3)) # 求2的3次方，该表达式返回8 (2)存储一维数组和多维数组对象： import numpy as np arr1 = np.arange(0,1,0.2) # 输出[0. 0.2 0.4 0.6 0.8] print(arr1) # 输出&lt;class 'numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9316cbd3561724fad1137ca92841495e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c10f2dd85eee52cc50ab6472db04608/" rel="bookmark">
			软件测试工程师：面试题与经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试技术面试题 1、什么是兼容性测试？兼容性测试侧重哪些方面？
参考答案：
兼容测试主要是检查软件在不同的硬件平台、软件平台上是否可以正常的运行，即是通常说的软件的可移植性。
兼容的类型，如果细分的话，有平台的兼容，网络兼容，数据库兼容，以及数据格式的兼容。
兼容测试的重点是，对兼容环境的分析。通常，是在运行软件的环境不是很确定的情况下，才需要做兼容。根据软件运行的需要，或者根据需求文档，一般都能够得出用户会在什么环境下使用该软件，把这些环境整理成表单，就得出做兼容测试的兼容环境了。
兼容和配置测试的区别在于，做配置测试通常不是Clean OS下做测试，而兼容测试多是在Clean OS的环境下做的。
2、我现在有个程序，发现在Windows上运行得很慢，怎么判别是程序存在问题还是软硬件系统存在问题？
参考答案：
1、检查系统是否有中毒的特征；
2、检查软件/硬件的配置是否符合软件的推荐标准；
3、确认当前的系统是否是独立，即没有对外提供什么消耗CPU资源的服务；
4、如果是C/S或者B/S结构的软件，需要检查是不是因为与服务器的连接有问题，或者访问有问题造成的；
5、在系统没有任何负载的情况下，查看性能监视器，确认应用程序对CPU/内存的访问情况。
3、测试的策略有哪些？
参考答案：
黑盒/白盒，静态/动态，手工/自动，冒烟测试，回归测试，公测（Beta测试的策略）
4、正交表测试用例设计方法的特点是什么？
参考答案：
用最少的实验覆盖最多的操作，测试用例设计很少，效率高，但是很复杂；
对于基本的验证功能，以及二次集成引起的缺陷，一般都能找出来；但是更深的缺陷，更复杂的缺陷，还是无能为力的；
具体的环境下，正交表一般都很难做的。大多数，只在系统测试的时候使用此方法。
同时，在这我为大家准备了一份软件测试视频教程（含面试、接口、自动化、性能测试等），就在下方，需要的可以直接去观看，也可以直接【点击文末小卡片免费领取资料文档】
软件测试视频教程观看处：
3天刷完这软件测试800道面试题，你的测试offer就稳稳的啦！（每日一刷，必拿offer）
5、描述使用bugzilla缺陷管理工具对软件缺陷（BUG）跟踪的管理的流程？
参考答案：
就是Bugzilla的状态转换图。
6、你觉得bugzilla在使用的过程中，有什么问题？
参考答案：
界面不稳定；
根据需要配置它的不同的部分，过程很烦琐。
流程控制上，安全性不好界定，很容易对他人的Bug进行误操作；
没有综合的评分指标，不好确认修复的优先级别。
7、描述测试用例设计的完整过程？
参考答案：
需求分析 + 需求变更的维护工作；
根据需求 得出测试需求；
设计测试方案，评审测试方案；
方案评审通过后，设计测试用例，再对测试用例进行评审；
8、单元测试的策略有哪些？
参考答案：
逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、景泰数据流分析
9、LoadRunner分哪三部分？
参考答案：
用户动作设计；
场景设计；
测试数据分析；
10、LoadRunner进行测试的流程?
参考答案：
1、 测试测试
2、 创建虚拟用户脚本
3、 创建运行场景
4、 运行测试脚本
5、 监视场景
6、 分析测试的结果
以上，最好是结合一个案例，根据以上流程来介绍。
11、什么是并发？在lordrunner中，如何进行并发的测试？集合点失败了会怎么样？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c10f2dd85eee52cc50ab6472db04608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc67c32d82a57a4d0994d0a028c9dd79/" rel="bookmark">
			图片上传与回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片上传与回显 上传 前端页面就不展示了，就是普通的ajax请求，具体可以参照饿了吗-UI。
参数 ：MultipartFile file
if (file.isEmpty()){ return Result.error("请上传文件"); } long currentTime = System.currentTimeMillis(); Date date = new Date(currentTime); //创建Date对象并传入毫秒值 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); //自定义日期格式 String formattedDateTime = sdf.format(date); //截取后缀 String fileName = file.getOriginalFilename(); if (fileName == null) { return Result.error("不能为空"); } int lastDotIndex = fileName.lastIndexOf('.'); String fileExtension = fileName.substring(lastDotIndex); if (!(".jpg".equals(fileExtension)||".png".equals(fileExtension)||".pdf".equals(fileExtension))) return Result.error("图片格式不对"); UUID uuid = UUID.randomUUID(); String string = uuid.toString().replaceAll("-",""); //保存地址 String path = 物理地址+formattedDateTime+"\\"+string+fileExtension; //返回地址 String url = 域名或者ip地址+formattedDateTime+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc67c32d82a57a4d0994d0a028c9dd79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee9f29884505e7f066600d2bbe7a866/" rel="bookmark">
			代码编辑器,代码（JSON，js，Markdown，html，css，java，sql）格式化 fei-editor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示 官方文档： https://ymf930.gitee.io/fei-editor/#/
npm 安装 npm i fei-editor -S # or yarn add fei-editor 想要运行下面的示例，除此之外还要安装f-ui-one、brace
引入 在 main.js 中写入以下内容：
import { createApp } from 'vue' import Editor from 'fei-editor'; import App from './App.vue'; import FUI from 'f-ui-one' import 'f-ui-one/lib/styles/index.css' import * as ace from 'brace' import 'brace/ext/emmet' import 'brace/ext/language_tools' import 'brace/mode/json' import 'brace/snippets/json' // 引入主题 import 'brace/theme/chrome' import 'brace/theme/xcode' import 'brace/theme/clouds' import 'brace/theme/crimson_editor' import 'brace/theme/sqlserver' import 'brace/theme/github' import 'brace/theme/textmate' import 'brace/theme/tomorrow' import 'brace/theme/solarized_light' import 'brace/theme/cobalt' import 'brace/theme/dracula' import 'brace/theme/monokai' import 'brace/theme/solarized_dark' import 'brace/theme/terminal' import 'brace/theme/vibrant_ink' const app = createApp(App) app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee9f29884505e7f066600d2bbe7a866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2d5ceefac5c05735ec34e9b043c0e5/" rel="bookmark">
			中间件系列 - Redis入门到实战(高级篇-多级缓存)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习视频： 黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目
中间件系列 - Redis入门到实战
本内容仅用于个人学习笔记，如有侵扰，联系删除
学习目标
JVM进程缓存Lua语法入门实现多级缓存缓存同步策略 1 什么是多级缓存 传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：
存在下面的问题：
请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈
Redis缓存失效时，会对数据库产生冲击
多级缓存方案：
多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：
浏览器访问静态资源时，优先读取浏览器本地缓存访问非静态资源（ajax查询数据）时，访问服务端请求到达Nginx后，优先读取Nginx本地缓存如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）如果Redis查询未命中，则查询Tomcat请求进入Tomcat后，优先查询JVM进程缓存如果JVM进程缓存未命中，则查询数据库
在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个反向代理服务器，而是一个编写业务的Web服务器了。 因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：
另外，我们的Tomcat服务将来也会部署为集群模式：
可见，多级缓存的关键有两个：
一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询
另一个就是在Tomcat中实现JVM进程缓存
其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。
2 JVM进程缓存 为了演示多级缓存的案例，我们先准备一个商品查询的业务。
2.1 导入案例 为了演示多级缓存，我们先导入一个商品管理的案例，其中包含商品的CRUD功能。我们将来会给查询商品添加多级缓存。
2.1.1 安装MySQL 后期做数据同步需要用到MySQL的主从功能，所以需要大家在虚拟机中，利用Docker来运行一个MySQL容器。
2.1.1.1 准备目录 为了方便后期配置MySQL，我们先准备两个目录，用于挂载容器的数据和配置文件目录：
# 进入/tmp目录 cd /tmp # 创建文件夹 mkdir mysql # 进入mysql目录 cd mysql 2.1.1.2 运行命令 进入mysql目录后，执行下面的Docker命令：
docker run \ -p 3306:3306 \ --name mysql \ -v $PWD/conf:/etc/mysql/conf.d \ -v $PWD/logs:/logs \ -v $PWD/data:/var/lib/mysql \ -e MYSQL_ROOT_PASSWORD=123 \ --privileged \ -d \ mysql:5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f2d5ceefac5c05735ec34e9b043c0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a3220d4997dc055b37162009a0d4b5/" rel="bookmark">
			cesiumlab中las点云转3dtiles注意颜色格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果 1、准备las格式的点云数据 先了解点云的RGB数值范围，了解是0-255还是0-65535，下面这个点云明显是0-255
2、重新导出las数据 选择las1.2的格式导出，las1.2的格式能存储投影信息
3、cesiumlab转换 添加las数据后设置，这个公式的意思是对颜色值范围进行转化，下面的参数表示保持颜色值不变，从第一步看出，点云数据颜色值是0-255，那么就不需要做转化，下面填上65535就行，如果颜色值是0-65535，，下面填上255就行
4、结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5040bf56b403fe0bade21b17c19f97d/" rel="bookmark">
			excel数据使用xlsx读取转换成JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般读取excel的工作都由后端完成，比如java使用poi插件。如果存在少量非敏感数据，比如日志、模板数据，可以直接由前端搞定。
使用xlsx插件
在线json格式化、excel转json测试
一、安装 可以安装以下版本，不会出现问题
yarn add xlsx; "dependencies": { "xlsx": "^0.18.5" } 二、直接使用插件 &lt;script&gt; import * as XLSX from "xlsx"; export default { components: { XLSX, }, data(){ return{ content:"", } }, methods:{ readExcel(files) { const fileReader = new FileReader(); fileReader.readAsBinaryString(files); fileReader.onload = (e) =&gt; { try { const data = e.target.result; const workbook = XLSX.read(data, {//将上传的文件读取成workbook 即excel工作簿 type: "binary", }); const wsname = workbook.SheetNames[0]; // 取第一sheet，如果由多个可以循环获取 const ws = XLSX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5040bf56b403fe0bade21b17c19f97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e62613622ee3676e72daf7dfb00356b/" rel="bookmark">
			Synchronized、ReentrantLock、ReadWriteLock 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Synchronized 关键字 介绍 synchronized 是 Java 中的关键字，用于控制对共享资源的并发访问，提供了一种锁机制来保证共享资源在同一时刻只能被一个线程访问。
优点 简单易用：作为语言的内置特性，使用方便。自动释放锁：当同步块执行完成后，锁会自动被释放，不需要手动操作。 缺点 不够灵活：不支持公平锁，不能中断正在等待锁的线程。无法尝试获取锁：线程尝试获取锁时，如果锁被占用，会一直等待，无法设置超时。锁粒度较粗：锁的是整个类、对象或方法，可能会导致不必要的等待。 使用场景 适用于代码简单、竞争不激烈的同步场景。
ReentrantLock 介绍 ReentrantLock 是 java.util.concurrent.locks 包中的一个类，它提供了比 synchronized 更多的功能。
优点 高度灵活：支持尝试非阻塞地获取锁、可中断的锁获取等。支持条件变量：可以绑定多个 Condition 对象，实现复杂的线程同步。可选择公平锁：支持公平锁，按照线程等待的先后顺序分配锁。 缺点 需要手动释放锁：必须在 finally 块中释放锁，增加了编程复杂性。性能开销：相比于 synchronized，ReentrantLock 在某些情况下可能有更多的性能开销。 使用场景 适用于需要高度并发控制、锁定时间长、条件同步等复杂场景。
ReadWriteLock 介绍 ReadWriteLock 是一个接口，它包含一对锁，一个读锁和一个写锁，通过分离读和写操作来提高并发性能。
优点 读写分离：允许多个线程同时读，但只允许一个线程写，提高了并发性。适应读多写少场景：在读操作远远高于写操作的场景下，性能优于 synchronized。ReentrantLock 允许锁的续租，即一个线程可以重复获取已经持有的锁 缺点 复杂性：编程相对复杂，需要正确管理读锁和写锁。锁升级问题：读锁无法直接升级为写锁，可能会导致死锁。 使用场景 适用于读多写少的并发场景，如缓存系统。
选择依据 在选择同步机制时，应考虑以下因素：
简单性：如果同步逻辑简单，可以优先考虑使用 synchronized。灵活性和功能需求：如果需要高度的灵活性和附加功能（如定时锁等待、公平性选择、条件变量等），应选择 ReentrantLock。读写操作的频率：如果系统是读多写少的，使用 ReadWriteLock 可以提高并发性，但需要注意避免写锁导致的读锁饥饿。性能：如果对性能有极高要求，可以通过基准测试来选择适合的锁。可维护性：更复杂的同步机制可能导致代码难以理解和维护，需要根据团队的熟悉程度和偏好来选择。 在实际应用中，通常需要根据具体的业务场景和性能要求来选择最合适的同步机制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09dadba541c9041b6a1f5f4808a324a/" rel="bookmark">
			MD5--加密原理及代码示例(C#)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MD5详述 MD5（Message-Digest Algorithm 5）是一种哈希算法，用于将任意长度的信息映射为固定长度的哈希值（128位）。MD5算法具有以下特点：
哈希值长度固定：MD5算法将任意长度的输入数据计算为128位长度的哈希值，可以对任意长度的数据进行哈希计算。
单向不可逆：MD5算法是一种单向不可逆的哈希算法，即无法从哈希值还原出原始数据。
雪崩效应：MD5算法具有雪崩效应，即输入数据的微小变化会引起输出结果的巨大变化，从而保证了数据的安全性和完整性。
碰撞概率低：MD5算法在理论上存在碰撞（即不同的输入数据产生相同的哈希值）的可能性，但实际上碰撞的概率非常低。
MD5算法被广泛应用于数字签名、数据完整性校验、密码存储等领域，在网络通信和信息安全中发挥重要作用。然而，由于MD5算法的安全性问题，目前已经被更安全的哈希算法（如SHA-256、SHA-3等）所取代。
2.MD5算法原理 MD5（Message-Digest Algorithm 5）算法的本质是通过对输入的任意长度数据进行一系列复杂的位操作和数学运算，最终将其转换为固定长度（128位）的哈希值。这个哈希值可以用于验证数据的完整性、生成数字签名或存储密码等用途。
MD5算法的核心原理包括：
消息填充：对输入的数据进行填充，使其长度满足算法要求。
初始向量：定义一个初始的128位向量作为算法的起始点。
数据分组：将填充后的数据按512位（64字节）分组。
循环运算：对每个分组进行一系列的循环运算，包括位操作（如与、或、非、异或）、模运算等。
输出连接：将每个分组的处理结果连接在一起，形成最终的128位哈希值。
3.MD5代码实例(C#) using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using System.Windows.Data; using System.Windows.Documents; using System.Windows.Input; using System.Windows.Media; using System.Windows.Media.Imaging; using System.Windows.Navigation; using System.Windows.Shapes; using System.Text; using System.Security.Cryptography; namespace WpfApp13 { /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void Button_Click(object sender, RoutedEventArgs e) { //string input = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e09dadba541c9041b6a1f5f4808a324a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f66e6d198d44678342fe3e5604bfcb/" rel="bookmark">
			首个开源MoE大模型Mixtral 8x7B的全面解析：从原理分析到代码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 23年12月8日，Mistral AI 在 X 平台甩出一条磁力链接(当然，后来很多人打开一看，发现是接近 87 GB 的种子)
看上去，Mixtral 8x7B的架构此前传闻的GPT-4架构非常相似(很像传闻中GPT-4的同款方案)，但是「缩小版」： 8 个专家总数，而不是 16 名(减少一半) 每个专家为 7B 参数，而不是 166B(减少 24 倍)42B 总参数（估计）而不是 1.8T(减少 42 倍)与原始 GPT-4 相同的 32K 上下文 在发布后 24 小时内，已经有开发者做出了在线体验网站：https://replicate.com/nateraw/mixtral-8x7b-32kseqlen
OpenAI 团队一直对 GPT-4 的参数量和训练细节守口如瓶。早些时候，有人爆料 GPT-4 是采用了由 8 个专家模型组成的集成系统。后来又有传闻称，ChatGPT 也只是百亿参数级的模型(大概在 200 亿左右)
传闻无从证明，但 Mixtral 8x7B 可能提供了一种「非常接近 GPT-4」的开源选项，特此，本文全面解析下：从原理解析到代码解读(在此文之前，尚没有资料扒得像本文这样如此之细)
第一部分 首个开源MoE大模型Mixtral 8x7B 1.1 Mixtral 8x7B的整体架构与模型细节 两天后的23年12.11日，Mistral AI团队对外正式发布 Mixtral 8x7B，其在大多数基准测试中都优于 Llama 2 70B，推理速度提高了 6 倍，且它在大多数标准基准测试中匹配或优于 GPT3.5
为免歧义，补充说明下，Mistral AI团队目前总共发布了两个模型
今年10月发布的Mistral 7B今年12月则发布的混合专家模型，称之为Mixtral 8x7B 一个mis 一个mix，本质不同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42f66e6d198d44678342fe3e5604bfcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ce6bfa67fa637bc1ccdc2bf1b96164/" rel="bookmark">
			全链路测试详解：一文掌握其含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件工程的迅猛发展中，保证代码的高标准和质量已成为开发团队的一项至关重要的任务。项目越来越庞大且充满挑战，导致各类测试技术层出不穷。特别地，全链路测试 开始受到工业界的广泛重视。本文旨在深究全链路测试的理念和使用情境，并将其与传统的测试方式进行对照分析，揭示其对提升软件品质所带来的独到价值。
全链路测试的理念 全链路测试是针对软件整体架构的一种测试手段，目标在于鉴定在多个应用组件、服务和单元共同作用下，整个系统的性能、功能和鲁棒性。
区别于压缩视角的单元测试和集成测试，全链路测试的焦点放在用户操作的起始点，穿越系统内部的所有环节，直至达成用户的预期结果。其核心宗旨在于确保系统在实际运行状态下的表现无缝且准确，各环节协作顺畅，并且在性能和用户体验上符合设计指标。
全链路测试的使用情境 以一个在线零售平台为切入点，我们可以一窥全链路测试如何实际应用于此种场景。在这个案例中，测试将连贯起所有的购物环节，从用户打开网站的那一刻起，直到订单支付并进入处理阶段。
1. 用户登入与商品浏览：
用户通过网页或手机应用登录。测试 需验证登录过程的准确性，包括用户身份验证、会话跟踪等。确保用户在浏览商品和详情时的体验流畅无阻。 2. 购物车功能：
用户挑选商品放入购物车。测试需保证购物车的各项功能正常，例如商品添加、数量调整和移除操作。确保购物车的状态实时更新，并在不同设备间保持一致。 3. 支付及结算：
用户提交订单并进行支付。测试需验证结算和不同支付手段的处理是否准确，涉及价格核算、优惠策略应用等。模拟支付成功和失败的场景，验证系统是否能提供适当的反馈。 4. 订单处理与通知机制：
支付成功后系统产生订单。测试需验证订单生成、库存调配、支付状态反映是否同步。模拟订单跟踪，确保用户能得到及时的订单确认和支付通知。 5. 物流跟踪与配送：
订单完成后，物流部门开始配送。测试需确认物流服务是否与订单系统完美整合，确保状态更新精准、物流信息准确无误。模拟各式配送状态，检测系统的即时反应和更新准确度。 6. 客户反馈与客户服务：
用户可以提供反馈或请求客服支持。测试需评估用户反馈的收集和处理机制，确实系统能迅速作出响应并处理。模拟实际问题提交，确保系统提供及时的反馈和解决方案。 通过完整的全链路测试，可以确保软件系统在运行过程中的每一个环节都符合需要，从而为用户提供连贯且一致的高质量体验。
与传统测试方法对比 单元测试 vs 全链路测试 单元测试聚焦于软件最小功能块，如方法或类，其初衷在于保证这些小模块可以独立正确运作。这种测试一般较早在开发流程中引入，帮助开发者尽快定位并解决问题。单元测试多为自动化形式，对维护代码质量具关键作用。
而全链路测试提供了一个更宏观的视角，旨在模拟用户操作，从而测试系统全局的协调与性能。这样的测试需要在开发中后期，或在系统集成阶段进行，以确保各个环节的正常运行和性能达标。
集成测试 vs 全链路测试 集成测试关注各个模块合作时的交互问题，常在单元测试后进行，此举有助于早期发现组件层面的问题。
全链路测试更加注重整个使用场景，以确认从用户角度看系统的各部分是否和谐协作。这种测试可以揭示高层次的整合性和性能问题，通常在开发的后期或系统集成阶段展开。
性能测试 vs 全链路测试 性能测试 专注于在预设条件下分析系统的负载能力，如响应时间和资源使用效率等指标。
全链路测试则综合了功能性和性能，它探究在真实使用案例中系统部分是否能够协调工作。性能测试和全链路测试常被综合运用，以保障所测试的系统在任何情境下都能达到性能指标，同时保证端到端业务流程的稳定运作。
全链路测试最佳实践 Apifox是一个集成了强大 自动化测试 特性的工具，它能通过可视化的测试流程图使端到端测试场景的设计变得简单高效。
它能够从接口文档中批量导入 测试用例，并且支持流程控制如循环、条件判断、等待、分组等。它能够批量运行测试流程，生成全面的测试报告，并提供在线分享功能。
此外，Apifox 可以自动获取“上游”测试步骤的输出结果，并将其直接插入到后续需要的请求参数中，极大提高了全链路测试的灵活性和效率。
结语 在现今变革频繁的软件开发时代，开发团队更加注重保障代码质量。全链路测试通过全面考量软件系统的性能、功能和稳定性，证明了其作为一种新兴测试策略的突出价值。为了提高测试的效率，Apifox 以其直观的自动化测试和丰富的特性为全链路测试的实施提供了有力工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eaedf336fc2065e6a14e4840f41f281/" rel="bookmark">
			实现最高效的数据转换：深入了解Achronix JESD204C解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Manish Sinha，Achronix战略规划与业务发展部
长期以来，Achronix为不同行业的数据密集型和高带宽应用提供了创新性的FPGA产品和技术，并帮助客户不断打破性能极限。其中一些应用需要与先进的模拟/数字转换器（ADC）和数字/模拟转换器（DAC）进行对接——可由JESD204C完美地完成这项任务。
JESD204B/C是由JEDEC定义和开发的高速数据转换器串行接口标准。该标准减少了高速数据转换器和其他高性能器件（如Achronix Speedster7t FPGA）之间的数据输入和输出数量。这种数字和模拟信号链的组合使设计人员能够获得简化的小尺寸电路板布局，同时不会对终端系统的性能产生不利影响，从而使设计人员受益。通过高速通用I/O（GPIO）或SerDes通道来实现数据转换器件之间的接口/互连。
Achronix在其Speedster7t FPGA器件上已经实现了JESD204C接口，使客户能够使用他们所选择的ADC或DAC。由于是在同构FPGA架构上实现了软的JESD204C接口，客户可以使用他们喜欢的ADC/DAC器件并使其设计实现定制化。本文讨论了基于Achronix Speedster7t FPGA器件的JESD204C解决方案。
Achronix JESD204C解决方案支持该标准提及的所有功能，并对以前的版本进行改善。旨在实现由标准机构提出的所有的四个目标：
·提高通道速率以支持所需的更高总带宽——Achronix的解决方案目前支持每SerDes通道高达24.75 Gbps的数据速率。SerDes可以支持32 Gbps的JESD204C上限通道速率。用于测试设计的数据转换器使用的是Analog Devices（ADI）的AD9082，它支持的最大数据速率为24.75 Gbps。
·提升有效载荷传输效率——Achronix的用户可以使用FPGA逻辑来对其设计进行定制和优化。
·链路稳健性——Achronix的解决方案展示了在单通道和多通道模式链路的高度稳健性，同时保持确定性的延迟。例如，对于那些没有量化效应的模式，采样率可以达到AD9082支持的最高极限。
·向后兼容先前的JESD204B版本——Achronix将会提供JESD204B解决方案。
实验室测试方案
Achronix已成功实现并演示了Speedster7t JESD204C的解决方案，该解决方案可连ADI的AD9082，AD9082带有四通道16位DAC和双通道12位ADC转换件。实验环回设置（如图1所示）包括以下组件：
·Bittware的VectorPath S7t-VG6加速卡。板上使用的是Achronix Speedster7t FPGA器件。
·连接VectorPath和ADI的EVAL-AD9082连接器。Achronix开发了一块4-lane的QSFP到FMC的连接器，如果有需要的话，还可以调整为8通道或16通道。
·配备FMC连接器的ADI EVAL-AD9082 ADC/DAC板卡。
·所需的测试设备和其它配件。
图1：连接VectorPath和ADI的EVAL-AD9082连接器板卡
实验设置给发送（Tx）的和接收（Rx）的方向上提供完整的信号链。各组件的功能如下：
·在VectorPath加速卡上的Speedster7t AC7t1500 FPGA器件中实现JESD204C发送/接收IP功能。通过连接的PC上的Linux控制台运行特定的测试脚本。
·Speedster7t SerDes通道通过定制的FMC-QSFP连接器板卡连接到ADC/DAC。QSFP28模块支持四个SerDes通道，每个通道的运行速度为24.75 Gbps。
·通过所连PC调用API，完成对ADI的AD9082-FMCA-EBZ评估板上数千个寄存器进行编程配置。另外，也可以使用FPGA上的软CPU核或SoC中的硬CPU核对寄存器进行编程配置。
·外部时钟源使VectorPath加速卡和AD9082-FMCA-EBZ评估板同步。也可以通过使用AD9082-FMCA-EBZ上的振荡器来生成内部时钟，并通过FMC-QSFP连接器馈送到VectorPath加速卡。
·由一个任意波形发生器（AWG）产生波形被通过外部直传送给ADC0和ADC1。
·环回发生在Speedster7t FPGA内部，处于JESD204C接收和发送模块之间，而DAC输出显示在示波器上。
·DAC0和DAC1输出的预期波形显示在连接的示波器上。
图2：四通道环回示例
上图显示了一个四通道环回配置。信号路径为AWG（I/Q信号）→AD9082-FMCA-EBZ（ADC）→FMC QSFP56→Speedster7t JESD204C Rx→环回→Speedster7t JESD204C Tx→FMC QSFP56→AD9082-FMCA-EBZ （DAC）→示波器。
AD9082-FMCA-EBZ的ADC0和ADC1的输入I/Q波形具有相同的频率，但相位相差90度。频率取决于AD9082-FMCA-EBZ支持的模式，该设置可以在最小且可接受的抖动下，实现该特定模式所声明的最高频率。
基于Speedster7t FPGA器件，实现的先进的Achronix JESD204C解决方案，可以实现JESD204C数据转换器所支持的最高速率。该解决方案为连接的ADC/DAC设备提供了一个与供应商无关的接口，从而支持客户可以选择他们喜欢的ADC/DAC供应商。
联系我们的专家，以安排免费的演示或评估。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3532ad9a2dbd4033ca2b97b699b6dfd/" rel="bookmark">
			奥特曼年终17条总结爆火！OpenAI总裁：违反直觉但真实
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“视学算法”，选择加"星标"或“置顶”
重磅干货，第一时间送达
西风 发自 凹非寺
量子位 | 公众号 QbitAI 疯狂的2023年即将进入最后一周，大佬们的年终总结也来了。
OpenAI CEO奥特曼，就给2023打上了一个新标签——“世界开始认真对待人工智能的一年”。
并将他的思考总结为17条经验，起了个标题叫《我希望有人早点告诉我这些》。
希望这对正在思考2024年该做什么的人们有帮助。
博客发出，网友们纷纷表示“学习了”，还有不少人第一时间分享了“课后笔记”。
be like：
△来源：微博@歸藏的AI工具箱 OpenAI自家人也前往转发。OpenAI产品负责人Joanne Jang就分享说：
这就是我留在OpenAI的原因：我们的最高管理层对废话零容忍。
当然，也有兴奋的吃瓜群众又找到了新的瓜点……
似乎读到了一点“真还传”的怨气……
话不多说，一起来看奥特曼写下了哪些所思所想。
年终总结完整版在此 1. 乐观、执着、自信、原始驱动力和人际关系是一切的开始。
2. 有凝聚力的团队、冷静与紧迫感的恰当结合，以及对目标的超预期承诺，是完成任务的关键。长期规划往往被忽视；不必担心他人在短期内的看法，随着时间的推移，会逐渐好起来。
3. 对于团队来说，完成一件真正重要的难事比做一件无关紧要的易事更容易；大胆的想法能够激发斗志。
这一点也被OpenAI总裁Greg Brockman着重标出：“极其违反直觉但又极其真实。”
4. 激励机制是超能力；要谨慎设定。
5. 将资源集中在少数你深信不疑的事上；这话说起来容易，但做起来难。你能排除掉的东西比你想象的要多。
6. 言简意赅地交流沟通。
7. 每当遇到废话和官僚主义，都要坚决反对，并鼓励他人也这样做。不要让组织架构妨碍人们高效协同工作。
8. 结果才是最重要的；不要让好的过程成为坏结果的借口。
9. 花更多时间招聘。敢于选择那些进步飞速的高潜力人才。除智力外，还要寻找他们完成任务的证据。
10. 超级明星比你想象的更有价值，但必须根据他们对组织的真正影响来评估他们。
11. 快速迭代可以解决很多问题；一般情况下，如果你能迅速做出调整，犯错是可以接受的。计划应该以十年为单位来制定，执行则应该以周来衡量。
12. 不要挑战商业世界的基本法则。
13. 灵感易逝，生命短暂。不行动是一种特别隐蔽的风险。
14. 规模经常会带来出人意料的新特性。
OpenAI研究员Jason Wei给这一条备注的是：
阿门，无论是语言模型，还是人类。
15. 复利指数很神奇。特别是，你真的想建立一个通过规模获得复利优势的企业。
16. 跌倒了就爬起来，继续前进。
17. 与优秀的人共事是人生最美好的体验之一。
One More Thing 除了回顾2023，奥特曼随即还发布了一条推文展望2024：
想听听网友们希望OpenAI在2024构建或者是修复什么。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3532ad9a2dbd4033ca2b97b699b6dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a44fc610e5a80cb70b293ca36347865/" rel="bookmark">
			鸿蒙系统的UI设计规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙系统的UI设计规范是为了确保应用在鸿蒙生态中具有一致性和良好的用户体验。以下是一些关键的鸿蒙系统UI设计规范，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1.HI（Human Interface）设计原则：
遵循鸿蒙系统的HI设计原则，包括自然性、一致性、可预测性、可控制性、反馈性等。这些原则有助于构建直观、易用且具有可操作性的用户界面。
2.全场景设计：
鸿蒙系统鼓励全场景设计，即一个设计适用于不同设备和屏幕尺寸的界面。设计应该能够在手机、平板、电视等各种设备上适应良好。
3.多模输入适配：
支持多种输入方式，包括触摸、语音、手势等。确保设计不仅适配触摸屏，也能够在多模输入场景下提供良好的用户体验。
4.自适应布局：
采用自适应布局，使界面在不同屏幕尺寸和分辨率下自动适应。鸿蒙系统提供了多维度分辨率适配的支持，可灵活应对不同设备的屏幕。
5.窗口适配：
针对刘海屏、异形屏等特殊屏幕，使用安全区域布局，确保应用的关键信息不被遮挡。合理设置窗口布局属性以适应各种屏幕形状。
6.颜色和图标规范：
使用鸿蒙系统提供的颜色和图标规范，确保一致性和统一感。合理选择颜色搭配，避免颜色对比度过低，影响可读性。
7.字体和文本规范：
使用系统字体，合理选择字号和行距，确保文字在不同屏幕上都能够清晰可读。遵循鸿蒙系统的字体规范，保持一致性。
8.动效规范：
添加适度的动效，提升用户体验。动效应该自然、不刺眼，不仅能够吸引用户注意，还要有助于用户理解界面的交互过程。
9.状态栏和导航栏规范：
遵循系统的状态栏和导航栏规范，确保在不同设备上显示一致。灵活使用系统提供的导航模式，以提供更好的导航体验。
10.UI元素规范：
熟悉鸿蒙系统提供的UI元素规范，包括按钮、输入框、列表等。合理使用这些元素，以提高用户界面的一致性。
11.交互规范：
设计良好的交互流程，确保用户能够轻松理解和操作。遵循系统的交互规范，使用户在不同应用之间有一致的交互体验。
12.多语言和文化适配：
支持多语言和文化，确保应用能够在不同地区和语言环境下正常运行。遵循国际化和本地化的最佳实践。
通过遵循这些UI设计规范，开发者可以创建具有一致性、可操作性和易用性的鸿蒙应用，提供更好的用户体验。建议在设计前仔细阅读相关的鸿蒙系统设计文档和规范。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d811e567cc40fd9899b6dc3215ad6b/" rel="bookmark">
			java基础系列(十一) this关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 . 概念 this关键字的本质到底是什么呢？
其实，JVM在堆空间给对象分配空间时，每个对象都有一个隐藏的属性this，this指向该对象本身。即，如果用C语言来解释的话，this就是一个指向堆空间中对象本身的指针，只不过在Java中没有指针，叫做引用而已。this自己是对象的一部分，它也在堆空间，但是它又指向了它自己。
来张内存图直观的表示一下，如下图
图解 : 二. 经典例子 一看图就明白了，就是这么回事儿。当然，我们还可以通过另一种直观的方法来理解this，我们可以分别输出创建的Phone类对象和this对象的哈希码值，并进行比较。进行该操作需要用到hasCode方法（之后我们会讲到hasCode）。
package com.this_test; public class Phone { //成员变量： private String brand; //手机品牌 private String model; //手机型号 private String name; //手机持有人 //setter,getter方法 public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public String getModel() { return model; } public void setModel(String model) { this.model = model; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d811e567cc40fd9899b6dc3215ad6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af06105e240c8a4c8700846fa7c21b2/" rel="bookmark">
			应用于前端的自然断点法：wasm应用示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某月某日，虾神本虾接到了这样一个需求，前端获取数据之后，在渲染之前，要对数据进行分类，分类的方法可以选择常用几种，例如等距法、自然断点法、标准差分类法等……
问：为什么要在前端？这种功能不是一般都是在后台实现的么？虽然JavaScript号称能够重写一切，但是这种写算法的事情，本身不是它的领域啊。
答：前端的数据来源可能是很多不同的系统，组合之后得到的，不一定来源于一个系统或者一个库表，如果让后台做，前后台之间的数据传递就太繁杂了，所以甲方想在前端把这事情给做了，再说： 所以呢，虾神你不是做算法的么？来来来，帮忙给写一个……
虽然我手动写过自然断点法的计算方法，但是我不会JavaScript啊……你要不让我先花两个月，学习一下JavaScript？
虽然自然断点的算法还是比较简单的，我也写过：（见以前的文章：） 但是对于这种造轮子的活动，我一般是努力拒绝的：
所以我果断的把Python推荐给了他，毕竟Python里面已经有好几个身经百战的自然断点法的实现了，然后就毫无意外被拍回来了……
好吧，作为码农，不能说不行……我虽然不会写JavaScript，但是我会写Rust啊……好巧不巧，Rust写的wasm，就正好能在前端用。
首先简单介绍一下wasm
wasm: WebAssembly的简写，是一种新型的浏览器端代码：
用JavaScript的运行原理来说，它实际上是在JS的编译器中动态编译，然后在JS的VM中执行的，那么wasm可以让C/C++/Rust一类的高性能编译语言，转换成一种称之为IR的虚拟指令集，在需要的时候，在转换成JS VM可以运行的机器指令：
这种IR的编译指令，能够最大化的利用客户端的底层(如CPU\内存\显卡等)硬件，所以很多时候，比原生态的JavaScript性能更高。
2019年的时候，wasm就已经正式成为了W3C标准，成为了Web开发的“第四门语言”
有关wasm的其他介绍，大家有兴趣的可以查阅其他资料，反正一句话：这玩意儿就是一个可以运行在前端浏览器上的编译级语言功能。
所以，我们就可以利用一些Rust写的东西，编译成JS可以用的脚本了。
秉承着有的轮子，我们就不用自己去造的原则，首先我们去看看Rust的官方仓库crates.io里面，有没有我们需要的东西：
很快，我告诉你，真的很快啊，就让我找到了这个东西：
然后就简单了——
我们直接去全球最大的同性交友网站gayhub……阿不，github，把这个包clone下来（或者你直接下载zip，然后解压也行），因为作者已经把所有的wasm相关代码都写好，所以你只需要运行编译打包就可以了，注意，官方文档上说-features如下：
wasm-pack build --release -- -features js 在我这里最新的Rust版本里面已经不好使了，直接编译为web就行，命令行如下：
wasm-pack build --release target web 然后看着cargo自动安装一堆东西，自动下载一堆东西，自动编译一堆东西，直到显示：
然后可以了，我们可以看见，在工程根目录下，会得到一个pkg包，里面有我们需要的wasm文件：
其中，index.html是调用的示例文件，搞前端的同学一眼就明白：
然后我们启动一个小http服务器，就可以看见效果了，我这里启动的是python自带的http服务器：
打开浏览器，F12看console:
我们可以简单解析一下这个工程（如果你Rust没有基础也没有兴趣，就可以跳过这一部分了），首先在src/jenks.rs文件中，写了一个函数，做了算法的实现：
//src/jenks.rs pub fn get_jenks_breaks&lt;T: ToPrimitive&gt;(num_bins: usize, data: &amp;[T]) -&gt; Vec&lt;f64&gt; { //jenks的算法见文章开头的链接，这里不解释了 //这里的就是用Rust把jenks的实现过程写了一遍。 } 这个函数在Rust工程里面是可以直接用的了，我们可以在下面写一个测试方法，来看看效果：
但是我们要在前端调用它，所以必须还要封装成wasm，所以还需要一个对外封装的接口： src/wasm.rs： 前面的#[wasm_bindgen]特性，就是声明该方法，是一个wasm的绑定，这样这个方法编译之后，就可以被前端调用了。
#[wasm_bindgen] pub fn get_jenks_breaks(no_bins: usize, data: &amp;[f64]) -&gt; Box&lt;[f64]&gt; { let breaks = crate::jenks::get_jenks_breaks(no_bins, data); breaks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1af06105e240c8a4c8700846fa7c21b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879adbbebcbd3b3023aa7c8b98df12c0/" rel="bookmark">
			腾讯混元大模型(待续)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯混元大模型（Tencent Hunyuan）是由腾讯研发的大语言模型，具备强大的中文创作能力，复杂语境下的逻辑推理能力，以及可靠的任务执行能力。
请求说明 类型
说明
请求协议
HTTPS 协议
请求方式
POST
请求地址
https://hunyuan.cloud.tencent.com/hyllm/v1/chat/completions
接口鉴权
签名鉴权机制
并发限制
默认单账号限制并发连接数为1路
Header参数 名称
值
Content-Type
application/json
Authorization
通过入参以及 SecretKey 加密获取，参考 签名生成﻿
输入参数 参数名称
必填
类型
描述
app_id
是
Integer
腾讯云账号的 APPID﻿
secret_id
是
String
官网 SecretId﻿
timestamp
是
Integer
当前 UNIX 时间戳，单位为秒，可记录发起 API 请求的时间。例如1529223702，如果与当前时间相差过大，会引起签名过期错误
expired
是
Integer
签名的有效期，是一个符合 UNIX Epoch 时间戳规范的数值，单位为秒；Expired 必须与 Timestamp 的差值小于90天
query_id
否
String
请求 ID，用于问题排查
temperature
否
Float
默认1.0，取值区间为[0.0, 2.0]，非必要不建议使用, 不合理的取值会影响效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/879adbbebcbd3b3023aa7c8b98df12c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc0cc04ecbe4cd569af0be902b77c13/" rel="bookmark">
			Linux入门攻坚——10、Linux程序包管理-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux程序包管理（2）
CentOS：yum，dnf
YUM，yellow dog研发，Yellowdog Update Modifier
yum是一个C/S架构的软件工具，需要有一个存储位置（一般是文件服务器）保存提供（或收集的将要使用的）的程序包（程序包仓库），以便给需要的用户提供程序包。而使用者，即客户端使用yum命令，通过本地配置文件（一般是文件服务器的URL），能够找到保存了程序包的文件服务器，下载需要的程序包，然后在yum的管理下使用rpm进行程序包的安装。
1、本地需要有yum程序，即已经安装了yum程序包；
2、要有本地的yum配置文件，以指明使用哪个yum仓库；
3、yum仓库需要存在。
yum是rpm前端管理工具，不是说有了yum，就不需要rpm了。
yum服务器，一般有：FTP://或HTTP://，或者本地（光盘）文件，使用file://
createrepo：创建仓库
yum repository：yum repo
存储了众多rpm包，以及包的相关的元数据文件（放置于特定目录下：repodata）；
文件服务器：
ftp://
http://
nfs://
file://
yum客户端：
配置文件：
/etc/yum.conf ：为所有仓库提供公共配置
/etc/yum.repos.d/*.repo：为仓库的指向提供配置。
仓库的定义：
[repositoryID]
name=Some name for this repository
baseurl=url://path/to/repository/ ：可以指定多个
enabled={1|0} ：是否启用这个仓库，默认启用
gpgcheck={1|0} ：安装时是否验证程序包的完整性和来源合法性
repo_gpgcheck={1|0} gpgkey=URL ：指明密钥文件，光盘安装后在/etc/pki/rpm-gpg/路径有光盘上密钥的副本
enablegroups={1|0} ：是否在此仓库上使用组
failovermethod={'roundrobin'|'priority'} 默认轮循，多仓库地址时，失败后选择其他仓库的方式 cost= 默认1000
对于yum源的baseurl，只需指定到包含repodata目录的路径即可
自己编写一个仓库配置文件：
使用yum repolist会列出已经配置的所有可用仓库的软件源，会下载每个仓库的primary_db：
yum命令的用法：
yum [options] [command] [package ...]
command is one of：
* install package1 [package2] [...]
* update [package1] [package2] [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dc0cc04ecbe4cd569af0be902b77c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c97ddbf529907b80021be7f4909243/" rel="bookmark">
			Ubuntu环境下设置程序开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍Ubuntu环境下开机自启动的方法，主要分为非GUI程序的自启动和GUI程序的自启动。
1.非GUI程序的自启动 这里主要介绍通过增加系统服务的方法
sudo touch /lib/systemd/system/your_service_name.service sudo vi your_service_name.service 在your_service_name.service中增加：
[Unit] ; After=network.target Description="your_service_description" [Service] ExecStart=your_script_name.sh User=your_user_name [Install] WantedBy=multi-user.target 主要解释如下：
After:表示需要在某个服务之后运行，如果没有，可以删除这行。
Description:对于服务的描述。
ExecStart:需要执行的脚本的名称，这里需要给出绝对路径。
User:用户名，该用户需要有执行脚本的权限。
修改完毕后，增加执行权限：
sudo chmod u+x your_service_name.service 上述命令执行完毕后，需要重新加载服务，执行：
sudo systemctl daemon-reload 启动自己的服务，执行：
sudo systemctl start your_service_name 此时可以看到服务的执行结果。
若想结束自己的服务，执行：
sudo systemctl stop your_service_name 查看服务当前状态，执行：
sudo systemctl status your_service_name 测试完成可以正常运行后，需要使能每次启动时都执行：
sudo systemctl enable your_service_name 如果不想每次启动都执行，可以运行：
sudo systemctl disable your_service_name 2.GUI程序的自启动 这里主要有2种方法让GUI程序开机自启动。
1)方法1 方法1是最简单的方法，开机进入界面后，执行：
a)按Alt+F2 弹出“Enter a Command“命令框，输入"gnome-session-properties"，回车。
b)增加需开机自启动的程序 点击“Add”，输入我们需要开机自启动的界面程序或脚本即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9c97ddbf529907b80021be7f4909243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4785b9ee235de3d476b9290a934a6e0b/" rel="bookmark">
			在 Android 手机上从SD 卡恢复数据的 6 个有效应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您有 Android 设备，您可能会将个人和专业的重要文件保存在设备的 SD 卡上。这些文件包括照片、视频、文档和各种其他类型的文件。您绝对不想丢失这些文件，但当您的 SD 卡损坏时，数据丢失是不可避免的。
幸运的是，您不需要这样做，因为现在有许多应用程序可用于在移动设备中恢复损坏的 SD 卡。这些应用程序使用先进的机制来尝试查找卡上的可恢复文件。找到这些文件后，这些应用程序会为您恢复 SD 卡上的这些文件。以下是有关如何从 Android 手机中损坏的存储卡恢复数据的指南以及顶级SD 卡恢复 Android 应用程序的帮助。
第 1 部分. 如何从 Android 上的 SD 卡恢复数据 奇客数据恢复安卓版是从损坏的 SD 卡中恢复数据的最佳数据恢复应用程序。该软件可以找到几乎所有内容，包括存储在存储卡上的照片、视频和其他数据。以下是该应用程序提供的一些主要功能。
现在让我们看看如何使用这款最好的 SD 卡恢复软件从 SD 卡中恢复文件。按照以下简单步骤，您将立即恢复丢失的数据。
如何从手机 SD 卡中恢复数据 1、奇客数据恢复安卓版 首先我们介绍的是奇客数据恢复安卓版，使用这个工具您需要将安卓手机连接到您的计算机（这能很好的避免手机存储空间被二次覆盖）。您也可以使用存储卡读卡器将 SD 卡连接到 PC。
安卓数据恢复-奇客官网免费下载Android数据恢复软件扫描数据，支持文件、照片、视频、邮件、音频、微信消息等1000+种文件格式。https://www.geekersoft.cn/geekersoft-recovergo-android.html将安卓手机连接到计算机后，转到该程序，您将看到以下屏幕。您需要选择应用程序运行扫描的位置。这必须是您的安卓手机，因此在列表中找到它并单击它以选择它进行扫描。
当应用程序扫描完您的安卓手机后，您将在屏幕上看到以下内容。这是您扫描的搜索结果。此处列出的所有文件都可以从您的 安卓手机恢复。单击显示“恢复”的按钮。
在您的计算机上下载此卡恢复应用程序。在您的 PC 上安装该程序并启动它。将安卓手机连接到电脑选择损坏的SD卡进行扫描从 Android 手机上的 SD 卡恢复损坏的照片/文件 手机内存恢复软件将开始恢复您的文件，并会在完成后通知您。如果您的 SD 卡已损坏并且丢失了数据，您无需惊慌，因为有许多应用程序可帮助您从卡中查找数据。上述指南应该可以帮助您找到这些应用程序，以便您可以恢复数据。它还教授如何使用恢复软件从 Android 手机的 SD 卡中检索数据。
立即下载数据恢复来尝试一下！
2、DiskDigger DiskDigger 是一款适用于 Android 设备的数据恢复应用程序，可以从损坏的 SD 卡中恢复丢失的文件，例如照片和视频。该应用程序还支持将恢复的文件直接上传到Google Drive或通过电子邮件地址。这是一个非常好的Android应用程序，可以从Android手机上的SD卡中恢复损坏的照片并查找其他文件。
优点
免费下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4785b9ee235de3d476b9290a934a6e0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625778486cb12776324471ce208d141f/" rel="bookmark">
			【HBase】——安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 规划&amp;前提 Zookeeper 、HDFS 正常部署规划如下 2 解压并重命名 cd /opt/software/ tar -zxvf hbase-2.4.11-bin.tar.gz -C /opt/module/ cd /opt/module mv hbase-2.4.11/ hbase 3 修改配置文件 3.1 hbase-env.sh #!/usr/bin/env bash # #/** # * Licensed to the Apache Software Foundation (ASF) under one # * or more contributor license agreements. See the NOTICE file # * distributed with this work for additional information # * regarding copyright ownership. The ASF licenses this file # * to you under the Apache License, Version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625778486cb12776324471ce208d141f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d48cd7fed9d96c7e1082c16cf2de7c/" rel="bookmark">
			探究element-ui 2.15.8中＜el-input＞的keydown事件无效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 今天看到一个问题，在用Vue2+element-ui 2.15.8开发时，使用input组件绑定keydown事件没有任何效果。
&lt;template&gt; &lt;div id="app"&gt; &lt;el-input v-model="content" placeholder="请输入" @keydown="handelKeydown"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { content: '' } }, methods: { handelKeydown() { console.log('触发了Keydown事件！！！') // 实际不会触发 } } } &lt;/script&gt; 二、问题排查 我们直接调试代码，找到Vue2中事件初始化的地方initEvents：
可以看到，我们的keydown事件其实是有记录到的，那么事件绑定的关键就在updateComponentListeners：
在这里有两句代码很关键：
① target$1 = vm;，target$1 这个变量后面会提到，它就是vm，我们&lt;el-input&gt;组件的实例对象。
② updateListeners：updateComponentListeners实际内部调用的事件更新处理，它里面如何执行，我们往下看：
可以看到，updateListeners里实现事件绑定的逻辑是在add函数内：
在这里我们再次看到了 target$1变量，从而keydown事件其实就是绑定在它上面了。
那么如果要使得keydown事件能够正常触发，&lt;el-input&gt;组件内部在&lt;input&gt;上应该要有@keydown，并$emit('keydown')。于是，到&lt;el-input&gt;组件源码内看看到底有没有这个：
可以看到&lt;el-input&gt;组件并没有绑定keydown事件。
接下来，修改一下它的源码来验证一下：
这时候不要直接去调试，如果直接修改源码后调试会发现没有任何效果，即使你重新启动服务。原因在于，加载的Element-UI目标文件并不是源码文件：
也就是，在main.js中使用的import Element from 'element-ui'导入的其实是node_modules\element-ui\lib\element-ui.common.js
所以这里我们还要再修改一下main.js：
将import Element from 'element-ui'替换成下面的代码：
import Element from 'element-ui/src/index' 最后我们yarn serve重启一下服务，来验证一下：
三、解决方案 在实际开发中，不用去修改element-ui的源码也能使keydown事件生效，这里需要用到Vue的事件修饰符：navtive
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0d48cd7fed9d96c7e1082c16cf2de7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597bda5340aea3ed650479c7cb924976/" rel="bookmark">
			【赠书第7期】从零基础到精通Flutter开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
1 安装Flutter和Dart
2 了解Flutter的基础概念
2.1 Widget
2.2 MaterialApp和Scaffold
2.3 Hot Reload
3 编写你的第一个Flutter应用
3.1 创建一个Flutter项目
3.2 修改默认页面
3.3 添加交互
4 深入学习Flutter高级特性
4.1 路由和导航
4.2 状态管理
4.3 自定义Widget
4.4 网络请求
4.5 动画
5 实战项目
6 结语
7 推荐图书
8 粉丝福利
前言 Flutter 是由 Google 推出的一款开源 UI 工具包，用于构建跨平台的移动应用。它具有快速开发、高度自定义和良好的性能等特点，使得它成为移动应用开发领域的热门选择。本文将从零基础开始，逐步引导你走进 Flutter 的世界，最终达到精通的水平。
1 安装Flutter和Dart 首先，你需要在本地安装 Flutter 和 Dart。Flutter 是 UI 工具包，而 Dart 是 Flutter 的编程语言。你可以从 Flutter 官网（https://flutter.dev）下载安装包，根据操作系统的不同选择对应的安装方式，并根据官方文档进行配置。
安装完成后，你可以在终端或命令行中运行`flutter doctor`来检查你的安装是否成功以及是否需要进行额外的配置。
2 了解Flutter的基础概念 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597bda5340aea3ed650479c7cb924976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2754c9024fc261135603b57fc3e5c9dc/" rel="bookmark">
			Ant Design Vue表单校验数组类型数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 定义数据 及表单结构
const form = ref({ dynamicValidateForm: [{ aas: '', nums: '' }] }); &lt;a-form :model="form" :rules="rules" ref="formRef" name="mp_form" :label-col="{ span: 5 }" :wrapper-col="{ span: 19 }" &gt; &lt;a-space v-for="(sight, index) in form.dynamicValidateForm" :key="index" style="margin-bottom: 8px; margin-left: 50px; width: 500px" align="baseline" &gt; &lt;a-form-item style="width: 600px" :label="index == 0 ? '产品配置列表' : ''" :style="{ marginLeft: index == 0 ? '0px' : '125px' }" :rules="{ required: true, message: '请选择产品配置', trigger: ['change', 'blur'] }"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2754c9024fc261135603b57fc3e5c9dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83178679bca6f10041a7d3e0d973e35/" rel="bookmark">
			Web网站渗透攻击防御：守护网络安全的关键思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
在互联网普及和技术进步的背景下，Web网站已成为人们获取信息、交流和交易的重要平台。然而，随着网络安全问题的不断加剧，黑客们利用各种手段渗透进入Web网站，窃取敏感信息、破坏系统或进行其他恶意行为。为了保护Web网站的安全，防御渗透攻击成为了一项重要的任务。本文将介绍一些常见的渗透攻击手段，并提出相应的防御思路。
一、常见渗透攻击手段
SQL注入攻击：黑客通过在用户输入框中插入恶意的SQL语句，使得服务器执行非预期的数据库操作，从而获取敏感信息或控制整个数据库。XSS攻击：黑客通过在网页中注入恶意的JavaScript代码，使得用户在浏览网页时执行该代码，从而窃取用户的敏感信息或进行其他恶意行为。CSRF攻击：黑客通过伪造用户的请求，使得用户在不知情的情况下执行非预期的操作，例如转账、删除数据等。文件上传漏洞：黑客通过利用Web网站对文件上传的限制不严格或存在漏洞，上传恶意文件到服务器上，从而执行任意代码或控制整个服务器。DDoS攻击：黑客通过控制大量的僵尸网络，向目标Web网站发送大量的请求，导致服务器负载过大，无法正常提供服务。 二、防御思路
输入验证与过滤：对用户输入的数据进行严格的验证和过滤，确保数据的合法性和安全性。可以使用正则表达式、白名单等方式对输入数据进行过滤，避免非法字符的注入。参数化查询与预编译语句：对于数据库操作，使用参数化查询和预编译语句，避免将用户输入直接拼接到SQL语句中，防止SQL注入攻击。输出转义与编码：对用户输出的数据进行转义和编码处理，避免恶意代码的执行。可以使用HTML实体编码、JavaScript编码等方式对输出数据进行处理。安全编码实践：在编写Web应用程序时，遵循安全编码实践，避免常见的安全漏洞。例如，避免使用硬编码密码、合理设置权限、使用安全的加密算法等。安全配置与更新：及时更新Web服务器和应用程序的软件版本，修复已知的安全漏洞。同时，对Web服务器的配置进行优化，关闭不必要的服务和端口，限制访问权限。安全监控与日志分析：建立完善的安全监控系统，实时监测Web网站的访问情况和异常行为。同时，对日志进行分析和审计，及时发现和响应安全事件。渗透测试与漏洞扫描：定期进行渗透测试和漏洞扫描，发现和修复Web网站中的安全漏洞。可以使用自动化的渗透测试工具和漏洞扫描工具进行检测。员工培训与意识提升：加强员工的安全意识和培训，提高他们对网络安全的认识和防范能力。可以通过组织安全培训、制定安全政策等方式进行。 结论：
渗透攻击是Web网站面临的重大威胁，为了保护Web网站的安全，需要采取一系列的防御措施。通过输入验证与过滤、参数化查询与预编译语句、输出转义与编码、安全编码实践、安全配置与更新、安全监控与日志分析、渗透测试与漏洞扫描以及员工培训与意识提升等手段，可以有效地提高Web网站的安全性，减少渗透攻击的风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d49537371ed4e1945d9ceb8dbc57a99/" rel="bookmark">
			boost V2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yugabytedb wget https://downloads.yugabyte.com/releases/2.19.0.0/yugabyte-2.19.0.0-b190-linux-x86_64.tar.gz tar xvfz yugabyte-2.19.0.0-b190-linux-x86_64.tar.gz cd yugabyte-2.19.0.0/ 配置 YugabyteDB ./bin/post_install.sh 运行 ./bin/yugabyted start boostd-data run yugabyte 运行报错 Error: starting yugabyte store: starting local index directory service: running postgres migrations: getting number of rows in PieceTracker table: pq: SSL is not enabled on the server 添加参数 ?sslmode=disable nohup boostd-data run yugabyte \ --hosts 127.0.1.1 \ --connect-string="postgresql://yugabyte:yugabyte@127.0.1.1:5433?sslmode=disable" \ --addr 0.0.0.0:8044 &gt; /var/log/boostd-data/boostd-data.log 2&gt;&amp;1 &amp; Boost Setup 设置 参考 New Boost Setup修改配置文件 [LocalIndexDirectory] ServiceApiInfo = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d49537371ed4e1945d9ceb8dbc57a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d30a8f04da2f95d6fb173e86cc5e34a/" rel="bookmark">
			51单片机结构组成相关知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		51单片机 一、结构组成 内部结构 8位CPU1个片内振荡器和时钟电路4KB片内程序存储（ROM）256字节（2KB）片内数据存储（RAM）2个16位定时/计数器（T/C）可寻址64KB程序存储空间 + 64KB数据存储空间的总线计数器4个8位双向并行IO口1个全双工串行口5个中断源 控制器 程序计数器PC：16位，存放下一条执行指令的首地址（这个地址指向的是程序存储空间，0000H~0FFFH为片内的4KB，超出时便转向片外）
系统复位之后自动赋值为0000H。指令寄存器IR：8位指令译码器ID：对指令寄存器中的指令进行译码，转变为电信号数据指针DPTR：16位，由两个8位寄存器（DPH、DPL）拼装而成，
配合相关指令实现对最高64KB片外RAM和ROM的访问 只要是16位的，必然会涉及到对片外或片内RAM或ROM的访问，这也是为什么片尾RAM和ROM是64KB的原因
运算器 累加器ACC：8位，存放操作数或中间结果
通用寄存器B：8位，配合ACC进行乘法或除法运算，也可以当作普通寄存器
算数逻辑部件ALU：进行运算，结果状态传给PSW
程序状态字寄存器PSW：8位，存放运算过程的各种状态信息
其中：
CY（PSW7）：进位标志位，硬件控制，1表示进位
AC（PSW6）：辅助进位标志位，如果运算结果的低四位向高四位发生进位，则硬件置1
F0（PSW5）：用户标志位，用户自定义作用
RS1、RS0（PSW4，PSW3）：工作寄存器组指针。
OV（PSW2）：溢出标志位，溢出由硬件置1
F1（PSW1）：用户标志位，同F0；
P（PSW0）：奇偶标志位
引脚 51单片机共40个引脚
电源：VCC，接+5V，VSS，接地外接晶振：XTAL1（19），XTAL（18）复位/备用电源：RST/VPD：RST的使用方法是给与足够长时间的脉冲信号 A L E / P R O G ‾ ALE/\overline {PROG} ALE/PROG:地址锁存使能输出/编程脉冲输入：
ALE：如果你想输出片外ROM地址，那么给这个引脚高电平可以让你将第八位地址所存到P0口。 P S E N ‾ \overline {PSEN} PSEN :29脚，如果你从片外ROM读取指令，这个引脚将会在每个机器周期出现两次负跳变脉冲，用作片外ROM芯片的使能信号 E A ‾ / V p p \overline {EA}/V_{pp} EA/Vpp​ : 31脚，当 E A ‾ = 1 \overline {EA} = 1 EA=1或者悬空时，CPU从片内ROM读指令。当PC超出4KB范围时会自动访问片外ROM。如果 E A ‾ = 0 \overline {EA} = 0 EA=0或接地时，单片机只会访问片外ROMIO共32引脚，P0~P3都可以用来输出，P0和P2可以用来输出地址，P3具有第二功能 二、单片机的存储结构 存储器划分方法 51单片机物理上共4个存储空间，分别是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d30a8f04da2f95d6fb173e86cc5e34a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d71118030c739b25367d5e1b033bdb7c/" rel="bookmark">
			Spring Boot中如何优雅的重试调用第三方API？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言 在实际的应用中，我们经常需要调用第三方API来获取数据或执行某些操作。然而，由于网络不稳定、第三方服务异常等原因，API调用可能会失败。为了提高系统的稳定性和可靠性，我们通常会考虑实现重试机制。
本文将深入探讨如何在Spring Boot项目中优雅地重试调用第三方API，并结合代码示例，展示具体实现方式。
2 重试机制的必要性 第三方API调用可能面临各种不可预测的问题，如网络超时、服务器故障等。为了应对这些问题，引入重试机制可以帮助我们：
提高系统的稳定性： 在面对临时性故障时，通过重试机制可以减轻对系统的影响，确保服务的可用性。
降低因故障而导致的用户体验差： 用户可能无法感知到一次短暂的故障，而重试机制可以在不干扰用户操作的情况下自动修复问题。
3 Spring Retry简介 Spring Retry是Spring框架提供的一个模块，它通过提供注解或编程方式的方式，帮助我们实现方法级别的重试机制。在Spring Boot中，可以很方便地集成并使用Spring Retry。
4 Spring Retry实现重试 4.1 添加依赖 首先，我们需要在pom.xml中添加Spring Retry的依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt; &lt;/dependency&gt; 4.2 配置重试策略 在Spring Boot中，我们可以使用@Retryable注解来标记希望重试的方法，并配置相应的重试策略。另外，推荐公众号Java精选，回复java面试，获取在线面试资料，支持随时随地刷题。
4.2.1 代码示例 import org.springframework.retry.annotation.Backoff; import org.springframework.retry.annotation.Retryable; @Service public class ThirdPartyService { @Retryable( value = { RestClientException.class }, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 2) ) public String callThirdPartyApi() { // 调用第三方API的逻辑 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d71118030c739b25367d5e1b033bdb7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf96a9cbe5014faf7530d64e65297d25/" rel="bookmark">
			直接插入排序和希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言概述直接插入排序本质分析代码总结 希尔排序一组一组排序多组同时进行完整的代码 总结 前言 排序： 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性： 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
内部排序： 数据元素全部放在内存中的排序。
外部排序： 数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
概述 直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。
现实生活中，打扑克牌就是一个插入排序的例子
直接插入排序 本质 设一个待排序的数组，a[1]是一个有序的序列将后面的元素和已经排序好的元素进行比较。 图解：
分析 本篇文章，以从小到大的顺序排序为例
以其中一趟排序为例：
前面的4 5 6已经是排序好的数字，现在需要将元素3继续排序。
此时的end指向6，tmp指向的的是end+1的位置，即3。
将end和tmp进行比较，显然3&lt;6，即tmp&lt;end
此时将tmp拿出来，将end移动到tmp位置
end继续往前移动，继续和tmp比较
此时依然tmp&lt;end，end还是需要往前移动，即end--
此时依然tmp&lt;end，end还是需要往前移动，即end--
此时end&lt;0，循环结束，无需再比较，直接将tmp元素插入到最前面。
一趟排序的代码：
while (end &gt;= 0) { if (tmp &lt; a[end]) { a[end + 1] = a[end]; --end; } else { break; } } 因此一趟排序的终止条件为end&lt;0
要想完成所有元素排序，在一趟排序的基础上套一个for循环。从第一个元素开始遍历，end=i，循环结束的标志是i&lt;n-1，此时end指向的的是倒数第二个元素，tmp指向最后一个元素。
代码 # define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;assert.h&gt; void InsertSort(int*a,int n) { // [0,end] end+1 for (int i = 0; i &lt; n - 1; i++) { int end = i; int tmp = a[end + 1]; while (end &gt;= 0) { if (tmp &lt; a[end]) { a[end + 1] = a[end]; --end; } else { break; } } a[end + 1] = tmp; } } //输出排序后的数组 void PrintArray(int* a, int n) { for (int i = 0; i &lt; n; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf96a9cbe5014faf7530d64e65297d25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1789db6b914920fb3b04086663a92f8e/" rel="bookmark">
			Kubernetes(k8s)部署DolphinScheduler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境准备 1.1 集群规划 本次安装环境为：3台k8s+现有的mysql数据库+nfs
1.2 下载及介绍 DolphinScheduler-3.2.0官网：https://dolphinscheduler.apache.org/zh-cn/download/3.2.0
官网安装文档：https://dolphinscheduler.apache.org/zh-cn/docs/3.2.0/guide/installation/kubernetes#appendix-configurationr
2.前置工作 默认k8s集群已经安装完成，本次已腾讯的TKE为例介绍
参考腾讯TKE官方文档：https://cloud.tencent.com/document/product/457/32731
2.1 Helm配置 下载 Helm 客户端 curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 chmod 700 get_helm.sh ./get_helm.sh 如果curl无法下载可以直接网页点开后复制里面的内容，然后创建get_helm.sh文件继续操作即可
配置 Helm Chart 仓库（可选） # 执行以下命令，配置 kubernetes 官方仓库 helm repo add stable https://kubernetes-charts.storage.googleapis.com/ # 执行以下命令，配置腾讯云应用市场。 helm repo add tkemarket https://market-tke.tencentcloudcr.com/chartrepo/opensource-stable 连接集群 #执行以下命令，通过指定参数的形式访问目标集群。 helm install .... --kubeconfig [kubeconfig所在路径] # 如果警告如下：#WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /data/config，修改权限 chmod -R 600 ~/.kube/config helm常用命令举例 #helm 删除 官方仓库 helm repo remove stable #仓库管理)查看添加的chart仓库，可在这些chart仓库中拉取chart helm repo list #将chart包发布到k8s集群中安装部署 helm install releaseName chartName #列出所有已发布的版本 helm list helm list -n test helm list -A 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1789db6b914920fb3b04086663a92f8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c3aa6e11a869df4f3fda72144b636b/" rel="bookmark">
			tcp缓存引起的日志丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 logstash从数据源拉取日志，然后通过tcp插件发送到proxy进程中。在业务侧发现日志量明显少了，所以有了这一次的问题排查。
问题排查定位 首先从logstash侧开始检查。我们先看logstash的日志，没有明显的报错信息。
然后再查看logstash管道的状态。可以很明显的看到，在output管道中，in远远大于out，也就是logstash拉取的日志已经到了output管道，但是无法输出出去，并且duration_in_millis时间很长，这个代表着发出去的速率很慢，这是什么原因呢？
curl -XGET 'localhost:9600/_node/stats/pipelines/azure_event_hubs?pretty' { ... "outputs" : [ { "id" : "99b12e190d297be5d6113d04cf10089a3dccbaef7eed0cc41515e8e5af5f4595", "name" : "tcp", "events" : { "in" : 341, "out" : 69, "duration_in_millis" : 519709 } } } 要么是发送方的原因，要么是接收方的原因。我先从发送方进行排查，我在output管道中，除了tcp插件外，还添加了stdout插件，也就是日志来了除了会通过tcp发送外，还会打印在标准输出中。
output { tcp { ... } stdout {} } 然后等待一段时间，然后再查看该管道的信息，stdout插件的in和out完全相等，但tcp插件in和out还是相差甚大，也就是output管道应该没问题。
我再假设proxy端有问题。日志是可以从logstash端发送到proxy端的，只是很慢，并且还有其他数据源也在往proxy端发送日志，也没有这个问题，所以我突然想到，该数据源的日志很大，会不会是这个原因导致的呢？
我从上面标准输出中抓了一条日志出来，134k大小，然后我手动的用nc命令将日志发送到proxy，因为日志很大，我是将日志写入到文件，然后再用管道的方式发送的
cat test.txt | nc 通过查看proxy的日志发现，其根本没有收到该条日志。那么问题原因找到了，就是因为日志太大，导致日志发生了丢失。
代码排查 proxy服务的是golang写的，通过查看代码，这里使用了bufio.NewScanner来循环读取连接中的数据。
scanner := bufio.NewScanner(conn) for scanner.Scan() { // 处理数据 msg := scanner.Text() ... 查看NewScanner方法可以看到有一个maxTokenSize参数，然后用的默认值MaxScanTokenSize
func NewScanner(r io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34c3aa6e11a869df4f3fda72144b636b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce5648be2cd85f27a789aee9b94b307/" rel="bookmark">
			企业数字化行业分析之 SRM（供应商关系管理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是SRM ？SRM在企业中的作用 ？企业采购端业务痛点 ？SRM如何解决的 ？ SRM核心 ？ 什么是SRM ？ 在了解什么是SRM前我们得先知道什么是供应链，供应链是一个包含原料供货商、供应商、制造商、仓储商、运输商、分销商、零售商以及终端客户等多个主体的系统。
而今天我们要谈及的SRM，SRM（Supplier relationship management ）即供应商关系管理，国内也称数字化采购平台。
SRM是用来改善与供应链上游供应商的关系的，它是一种致力于实现与供应商建立和维持长久、紧密伙伴关系的管理思想和软件技术的解决方案，它旨在改善企业与供应商之间关系的新型管理机制，实施于围绕企业采购业务相关的领域，目标是通过与供应商建立长期、紧密的业务关系，并通过对双方资源和竞争优势的整合来共同开拓市场，扩大市场需求和份额，降低产品前期的高额成本，实现双赢的企业管理模式。
SRM在企业中的作用 ？ 企业采购端业务痛点 ？ 采购成本：采购价格评判标准不规范，采购成本管理水平不高
供应商效率：沟通效率低下，采购没有精力做到采购物料性价比最优和交付管理精益化
合规管理：业务过程不清晰，管控节点不透明，采购决策体系不完善，供应商绩效不客观
管理决策：管理者无法实时进行监控业务流程，采购决策缺乏有效的数据支撑
精细管理：产业差异，需加强流程管控，采购管理要求更细化，复杂的订单程序
供应商关系：业态多，物资差异大，供应结构难以优化，供应商难以稳定，替换成本高昂
SRM如何解决的 ？ 降低采购成本：建立采购价格数据库，建立议价优势；高效协同，有效降低库存水位，减小库存成本
规范采购标准：通过规范化企业采购标准，线上化采购全流程流程，实现阳光化采购
提升采购效率：全流程系统协同，业务线上化、数据共享化，提升采购流程效率和供应链人员效率
全流程精细化管理：优化品类、供应商管理策略，实现供应商分级分类管理，提升企业供应链管理水平
数据分析指导经营决策：基于系统汇总数据建立多维数据看板，建立企业采购管理分析体系，指导各级员工经营决策
SRM核心 ？ 一个采购平台
建设一体化的SRM采购平台，横向覆盖供应商全生命周期管理，纵向实现：供应商←采购部门←需求部门
两项核心能力
采购全流程闭环管理：实现采购从需求、寻源、合同、订单、收发货、质量、财务等全流程线上化闭环管理
供应商全生命周期管理：实现供应商从注册、准入、绩效考核、分类分级、淘汰线上管理，保障企业供应结构的不断优化和稳定
四个建设目标
流程线上化：全流程实现线上闭环化管理
任务代办化：流程节点任务实现，系统自动推送
管控标准化：采购各环节管控标准合规化
业务数据化：基于及时准确的数据，分析支撑采购决策
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55083d51574fcddec691b61e10f3f72f/" rel="bookmark">
			mysql根据条件修改字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据 sql语句 根据field2 字段情况，修改field1字段
update t1 tt1 set tt1.field1= ( case when tt1.field2 in ('我家2') then '1111' when tt1.field2 in ('你的家11') then '2222' else tt1.field2 end ) 结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8297ccf5b3fc90e70873210d48c1593/" rel="bookmark">
			【Python常见数据结构操作-持续更新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，常用的集合类型有列表（list）、元组（tuple）、集合（set）和字典（dict），双端队列（deque）、堆（heapq）、计数器（Counter）和有序字典（OrderedDict）。以下是它们的创建、添加和删除操作的详细说明和示例：
常见数据结构操作 1. 列表（list） 创建：
my_list = [] # 创建空列表 my_list = [1, 2, 3, 4, 5] # 创建包含元素的列表 添加：
my_list.append(6) # 在列表末尾添加元素 my_list.extend([7, 8, 9]) # 在列表末尾添加另一个列表的元素 my_list.insert(0, 0) # 在指定位置插入元素，这里在列表开头插入0 删除：
my_list.remove(0) # 移除列表中第一个出现的指定值 del my_list[0] # 根据索引删除元素 my_list.pop() # 移除列表末尾的元素 my_list.pop(0) # 根据索引移除元素 my_list.clear() # 清空列表 2. 元组（tuple） 创建：
my_tuple = () # 创建空元组 my_tuple = (1, 2, 3, 4, 5) # 创建包含元素的元组 元组是不可变的，因此无法添加或删除元素。但是可以通过连接元组来创建新的元组：
my_tuple = my_tuple + (6, 7, 8) # 将两个元组连接为一个新元组 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8297ccf5b3fc90e70873210d48c1593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ab36d6bf27e4539907be23a25f20f4/" rel="bookmark">
			js 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 npm installnpm run buildnpm run watch npm install npm install 是 Node.js 的包管理工具 npm（Node Package Manager）中的一个命令，用于安装 Node.js 应用程序所需的所有依赖项。以下是关于 npm install 的详细解释：
基本概念：
npm：是 Node.js 的默认包管理器，用于管理 Node.js 项目中的依赖包。
依赖项：项目所依赖的外部库或模块，通常在 package.json 文件中列出。
安装位置：
本地安装：默认情况下，npm install 将模块下载并安装到当前命令行所在的目录下的 node_modules 文件夹中。例如，如果你在项目根目录下运行 npm install，那么依赖项会被安装在该目录的 node_modules 文件夹下。
全局安装：通过使用 -g 选项，如 npm install -g &lt;module_name&gt;，模块将被安装到全局目录中，通常位于 Node.js 的安装目录下的 node_modules 文件夹中。全局安装的模块可以在任何地方通过命令行访问。
调用方式：
本地安装：在代码中，可以通过 require() 函数直接引入本地安装的模块。例如，const myModule = require(‘myModule’)。
全局安装：通常用于命令行工具，如 grunt。全局安装的模块不能通过 require() 调用，而是直接在命令行中使用。
配置：
可以通过 npm config set global true/false 来设置是否使用全局安装模式。使用 npm get global 可以查看当前的安装模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6ab36d6bf27e4539907be23a25f20f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f608ee30218532b4bb4d18b4d577d0/" rel="bookmark">
			xxl-job使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 xxl-job配置文件新增XxlJobConfig类JobHandler例子xxl-job机制xxl-job-admin配置@XxlJob 和 @JobHandler(过时了) 其他报错 msg：job handler [demoJobHandler] not found.xxl-job报错 xxl-job registry fail, registryParam:RegistryParam{registryGroup=‘EXECUTOR’, registryKey=‘xxl-job-invoice-api’, registryValue=‘http://xxxxxx:9990/’}, registryResult:ReturnT [code=500, msg=The access token is wrong., content=null]git地址xxl-job-admin的密码在哪里设置的呢 定时任务的实现方式不只一种。 最基础的是spring的@Scheduled定时任务，使用简单方便，但是用的多了，有一些确定。 因为一般集群都带了xxl-job-admin微服务，这里只说如何集成。
xxl-job 我们常说的xxjob全称是xxl-job，之所以读xxjob，就是为了易读。
maven依赖：
&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; 配置文件新增 xxl: job: admin: # 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行"执行器心跳注册"和"任务结果回调"；为空则关闭自动注册； addresses: http://192.168.0.1/xxl-job-admin # 执行器通讯TOKEN [选填]：非空时启用； accessToken: default_token executor: # 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册 appname: xxl-job-test address: # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 "执行器注册" 和 "调度中心请求并触发任务"； ip: # 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口； port: 9997 # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径； logpath: /data/logs/xxl-job/jobhandler # 执行器日志保存天数 [选填] ：值大于3时生效，启用执行器Log文件定期清理功能，否则不生效； logretentiondays: 7 XxlJobConfig类 直接从git项目复制过来一份。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02f608ee30218532b4bb4d18b4d577d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da380ee36362fa39fba3267371989bd/" rel="bookmark">
			Java研学-Web 组件交互与作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 跳转与数据共享 Jsp 和 Servlet 责任分离,可实现数据获取，查询等重复功能的复用
① Servlet 去数据库中查找
② Servlet 把数据给 jsp
③ jsp 把数据响应给浏览器
二 转发重定向概述 1 作用 利用 JSP, Servlet 完成 web 组件的跳转，从一个组件跳到另一个组件
2 转发 ① 跳转位置
服务器端进行的组件(资源)的跳转
② 转发原理
转发是指由服务器端进行页面跳转
③ 转发方法
// request 对象与转发相关方法 request.getRequestDispatcher("/要跳转到的地址").forward(request, response); 3 重定向 ① 跳转位置
&amp;emsp浏览器端进行的页面(组件/资源)跳转
② 重定向原理
重定向是指由客户端进行页面跳转
③ 重定向方法
// response对象与重定向相关方法 response.sendRedirect("要跳转的地址") 4 转发重定向的区别 区别转发 forward重定向 redirect目录服务端的根目录：http://localhost:8080/项目地址/
跳转的 path 不用写项目路径(虚拟目录)浏览器的根目录(端口之后):http://localhost:8080
跳转 path 需加上项目路径(虚拟目录)地址栏地址栏不会发生变化，还是上一个地址会变化，显示新的地址跳转位置服务端 进行跳转浏览器端 跳转请求对象(域)请求域数据不会丢失，因为是同一个请求请求域数据会丢失，因为不是同一个请求WEB-INF下资源请求转发可以跳转到WEB-INF 下的资源重定向不可以跳转到 WEB-INF 下的资源跨域访问请求转发不可以跳转到其他域名或项目下的资源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1da380ee36362fa39fba3267371989bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e14ce89554a3080f60d9a3acdd0e26/" rel="bookmark">
			cfa一级考生复习经验分享系列（十四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说一下自己的背景，一个和金融没有半毛钱关系的数据分析师，之前考出了FRM。这次用一个半月突击12月的1级考试拿到了9A1B的成绩，纯属运气。以下纯属经（chě）验（dàn），请看看就好，选取适合自己的内容；因为平时工作实在太忙+新项目需求不断，并且每天都是来回3个小时的通行时间，所以留给我的时间不多，我每天基本上都是早上在地铁看视频，晚上回家总结和做题目，就这样坚持看了一个月，剩余的半个月就是疯狂的刷JC百题，但是财报和道德基本没做。在考试前2天请了假，背了下陌生的知识点
* 复习资料：
A:我本人喜欢看纸质的文档，所以早上地铁看视频以后，晚上都会回家再看一遍PPT，做一些备注和记忆，这是为了训练自己的记忆和英语阅读能力。其实我感觉听完JC老师的视频以后基本都能懂，但是脑容量不够啊，看完一门再看下一门的时候，上一门已经忘得差不多了，很揪心。
B:十门课的视频我都是用1.5倍速看的，讲话飞起，但是这也能大大压缩看视频的时间，视频一定要看，因为这是节约时间的最好方法了，而且还不用总结。
C:除了财报和道德的百题没有做以外，其他8门课的题目都做完了。目的和看PPT一样，训练自己的看题目理解题目的速度，增加金融专业词汇，熟悉知识点。基本上我8门百题的准确率在90%以上，所以看节约了很多看错题的时间。
* 考试科目及建议：
1、道德：到的真的是看N遍都不知道在说什么的科目，但是二级和三级仍然会一模一样的考一遍，所以一定要重视，建议把case记住，这门课我没怎么复习，只是把七大条准则通过xmind整理出来了，最后一两天记了一下知识点，考了B，没有太多发言权，大家可以看看道德高分同学的建议。
2、经济学：这一门可对于我来说，真的是太难了，全程死磕。视频看不懂，PPT也云里雾里，AD-AS模型、汇率和汇率制度一头雾水。所幸我是学数学的，把经济学里面偏数学的理解了，然后通过函数的形式，把一些变量记住，并自己加了一些正负号，记住左移还是右移。经济学考察的是常识，所以大家一定要多读经济新闻，多看经济政策。
3、财报：这么课对于没有财务基础的小白来说，真的是难啊！！！视频看了两遍，但是百题没做。和经济学一样，硬生生的把财报学成了数学（无辜），最终考了A。感觉这门课重点很明确，只要跟着视频走，理解背后的推导和逻辑。建议没有会计基础的同学，看一下网上总结的会计学基础提纲，特别是三大报表之间的关系、重点科目。一级的计算量很小，涉及到的会计科目都是很明确的，没有他犄角旮旯的地方。一定要做题，熟练度和思考也会跟着上来。
4、公司理财：学好了财报，感觉公司理财就简单多了，围绕三个重点问题展开。公司理财基本是考公式，所以多练题目，学会套公式。
5、固定收益证券：这么课，我花了蛮多时间的，原因在于知识点太多太杂了，都是债券的一些分类和要素，所以建议大家一定要多看PPT，熟悉每个名词讲的是什么，掌握一些重点的区别。一级的固定收益和FRM比起来简单多了，考试计算题不多，基本是特点、流程、分类等等，多看几遍就行。不过强调一点：计算题虽然考的不多，但是理解了计算才能为二级做准备，毕竟是债券强调的是估值和风险管理。
6、衍生品：衍生品一级就掌握四类产品的特点和分类，衍生品的复制思路，我隐约记得没考计算，所以大家当做看介绍一样过一遍，熟悉一下专业名称就可以了。
7、股票：这门课重点和明确：分类、功能、指数优缺点及计算、有效市场等，把握住重点，练习题目就行，不是很难。
8、数量：一级的数量也是比FRM考得浅多了，重点在于几个利率的计算、年金、描述统计学和推断统计学，其实纯数学的不多，他还是会结合投资和风险来考察，所以要注意每个指标在金融投资里面的应用。
9、另类投资：跟着视频和PPT走，重点熟悉分类、优缺点和比较，fee的计算必考。
10、组合管理，这门课，我复习的最认真，虽然只有6%的权重，但是这么课是FRM一级的重点，是整个投资学的基础和现代投资理论的开启，不敢不好好学。重点掌握三大理论基础、每条线表示什么意思、数学推导。今年新增的热点，其实我没怎么看，因为不会考很多，毕竟传统的投资理论都这么多了，协会应该不会丢了西瓜捡芝麻。讲真的，三级都是组合管理的内容，所以一定要加油。
* 总结：
1、个人觉得一级考试难度排序(不考虑分值)：财报&gt;固定收益&gt;道德&gt;经济学&gt;组合管理&gt;股票&gt;公司理财&gt;数量&gt;衍生品&gt;另类;
2、个人觉得一级考试性价比排序(不考虑分值)：数量&gt;衍生品&gt;另类&gt;公司理财&gt;组合管理&gt;固定收益&gt;股票&gt;财报&gt;经济学&gt;道德;
3、复习顺序：视频听一遍 ——&gt; PPT看一遍记一遍 ——&gt; 原版书课后题刷一遍 ——&gt; 知识要点总结一遍记忆一遍 ——&gt; 百题刷起来 ——&gt; 不懂的视频再看一遍；
4、心态很重要，一定要坚持，不放弃；平时多锻炼，考前有条件的可以模拟几遍；120题目在3个小时里面绝对做得完，不用担心，平时多训练即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f5d2ef2996111f7190561ae3fd3382/" rel="bookmark">
			cfa一级考生复习经验分享系列（十二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：就职于央企金融机构，本科金融背景，一直在传统金融行业工作。工作比较忙，用了45天准备考试，几乎每天在6小时以上。
写在前面的话
先讲一下，整体一级考下来，我觉得知识点多，偏基础，几乎所有的内容和我大学本科4年学习的东西高度重合，所以，建议金融学背景的同学，毕业后可以马上着手准备，性价比更高。
针对普通白领上班族的复习策略，大家可以参考我下面复习安排，当然学习方法和习惯因人而异，大家拿走觉得有用的部分。
由10月国庆之后，我正式开始准备考试，中间还有一个礼拜的时间，在外地出差，不能学习，总共45天左右时间，比较短，因此，时间安排上，我采取一种有效率的方式，听网课和做题。
由于第一次考CFA对它的考试内容和形式，一开始复习有点蒙，但是考完后，反过来看当初的复习策略，我觉得更有利于总结，并且为二级考试打基础。
了解考试形式，难度，注意事项。
考试全部为选择题，上午3小时，下午3小时，比较消耗体力，大家准备期间别忘了多运动，增强体质。
另外这里要着重给大家强调，考题真的不难，但是考试时有一点要注意，就是做题的时间安排，上半场考试我没有经验，在做题时，一旦做不出来，我就空下来，由于没带手表，到最后时间只剩30分钟时，就很心急了，做题时间安排不当，以致于停笔那一刻，看到还有两个答题纸上的空白，当时恨不得马上涂上，但是时间已经不允许了。
所以，下半场我调整策略，不确定的那一题，也尽量在答题纸涂上，把不确定题目那一页折起来，方便回来再思考，所以下半场效率提升很多，提前一小时就做完了题目，开始检查。
建议大家：第一. 带块手表，方便看时间，考试时做到心里有数。第二. 即使不确定的题目，也不要在答题纸上留空白。
准备材料和复习计划。
基础学习
我的学习资料很简单。jc的基础课网课以及百题复习。简单的好处在，让我更专注。去年由于时间紧迫，我首先根据jc网课的时常和课时数，我制定了20天的基础课件的复习计划，每天听3堂课，做笔记。一轮听完后，难点再听，比如财务这章，刚开始学起来比较陌生，有难度，有的章节听了3遍，知识点了解得更清楚，后来居然这章是我考分最高的章节。刷题
还剩下差不多25天，听百题课，同时开始做题和自我总结。这其中我做了一个动作，总结，总结，总结，重要的的事情说3遍。每做完一章的百题，总结一章，形式有思维导图，重点考点的梳理。
最后冲刺复习时，把笔记本拿出来，把所有知识点给自己讲一遍，讲不清楚的，说明你没搞明白，再巩固学习。
其中我觉得百题我觉得很重要。很多一起考的朋友跟我说，她知识点都会，但是没过，原因就是因为没做题，并且要做好质量的题目。所以建议大家一定要做百题，第1遍，做题目，梳理知识点。第2遍，查漏补缺，巩固学习。
这样下来，应对考试基本上能做到心中有数了。
不同的科目学习安排因人而已，我先学习财务（这章大家好好学，看似很难，但是考试真的不难，容易拿高分），最后准备的一门是道德，相对也比较简单，里面最难的一张我觉得是固定收益那一章，内容很多，大家合理安排学习时间。 考试完的总结，对二级的启示。
一级复习中，尽管考过了，但是我认为自己还是漏了一个重要的细节，就是做课后练习题，所以我建议大家没复习完一个章节，一定先做题，然后再开始下一章，巩固你学习的知识。
总结下来，我的复习策略供大家。学习材料：jc基础课+课后习题+百题。
你需要做东西：总结每一章思维导图，详细的知识点，练习课后习题，以及至少2遍的经典百题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032d561c63627989b39dac9cd1107380/" rel="bookmark">
			eBPF 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是 eBPF ？ eBPF 是一项革命性的技术，起源于 Linux 内核，它可以在特权上下文中（如操作系统内核）运行沙盒程序。它用于安全有效地扩展内核的功能，而无需通过更改内核源代码或加载内核模块的方式来实现。
从历史上看，由于内核具有监督和控制整个系统的特权，操作系统一直是实现可观测性、安全性和网络功能的理想场所。同时，由于操作系统内核的核心地位和对稳定性和安全性的高要求，操作系统内核很难快速迭代发展。因此在传统意义上，与在操作系统本身之外实现的功能相比，操作系统级别的创新速度要慢一些。
eBPF 从根本上改变了这个方式。通过允许在操作系统中运行沙盒程序的方式，应用程序开发人员可以运行 eBPF 程序，以便在运行时向操作系统添加额外的功能。然后在 JIT 编译器和验证引擎的帮助下，操作系统确保它像本地编译的程序一样具备安全性和执行效率。这引发了一股基于 eBPF 的项目热潮，它们涵盖了广泛的用例，包括下一代网络实现、可观测性和安全功能等领域。
如今，eBPF 被广泛用于驱动各种用例：在现代数据中心和云原生环境中提供高性能网络和负载均衡，以低开销提取细粒度的安全可观测性数据，帮助应用程序开发人员跟踪应用程序，为性能故障排查、预防性的安全策略执行(包括应用层和容器运行时)提供洞察，等等。可能性是无限的，eBPF 开启的创新才刚刚开始。
1.1. 什么是 eBPF.io ？ eBPF.io 是学习和协作 eBPF 的地方。eBPF 是一个开放的社区，每个人都可以参与和分享。无论您是想阅读第一个介绍 eBPF 文档，或是寻找进一步的阅读材料，还是迈出成为大型 eBPF 项目贡献者的第一步，eBPF.io 将一路帮助你。
1.2. eBPF 和 BPF 分别代表什么 ？ BPF 最初代表伯克利包过滤器 (Berkeley Packet Filter)，但是现在 eBPF(extended BPF) 可以做的不仅仅是包过滤，这个缩写不再有意义了。eBPF 现在被认为是一个独立的术语，不代表任何东西。在 Linux 源代码中，术语 BPF 持续存在，在工具和文档中，术语 BPF 和 eBPF 通常可以互换使用。最初的 BPF 有时被称为 cBPF(classic BPF)，用以区别于 eBPF。
1.3. 标志里面的蜜蜂叫什么名字 ？ 蜜蜂是 eBPF 的官方标志，最初是由 Vadim Shchekoldin 设计的。在第一届 eBPF 峰会上进行了投票，并将蜜蜂命名为 eBee。(有关徽标可接受使用的详细信息，请参阅 Linux 基金会品牌指南。)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032d561c63627989b39dac9cd1107380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92bcd06b6aaee4d0ef7537ebbd694bd/" rel="bookmark">
			亚马逊云科技 re:Invent 2023 产品体验：亚马逊云科技产品应用实践 王炸产品 Amazon Q，你的 AI 助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		意料之中 2023年9月25日，亚马逊宣布与 Anthropic 正式展开战略合作，结合双方在更安全的生成式 AI 领域的先进技术和专业知识，加速 Anthropic 未来基础模型的开发，并将其广泛提供给亚马逊云科技的客户使用。
亚马逊云科技开发者社区为开发者们提供全球的开发技术资源。这里有技术文档、开发案例、技术专栏、培训视频、活动与竞赛等。帮助中国开发者对接世界最前沿技术，观点，和项目，并将中国优秀开发者或技术推荐给全球云社区。如果你还没有关注/收藏，看到这里请一定不要匆匆划过，点这里让它成为你的技术宝库！
在2023年即将结束之际，亚马逊云科技在9月底宣布于Anthropic展开战略合作，此次合作是亚马逊云科技在生成式 AI “三层架构”中持续扩展其独特服务的最新发布。在底层，亚马逊云科技继续提供来自英伟达的计算实例，以及亚马逊云科技的自研芯片，包括用于 AI 训练的 Amazon Trainium 以及用于 AI 推理的 Amazon Inferentia 实例。
在中间层，亚马逊云科技专注于为客户提供来自多个领先模型供应商的最受欢迎的基础模型。此外，客户可以定制这些模型，确保自己数据的隐私和安全，同时还能与亚马逊云科技其他工作负载无缝集成，这一切都由亚马逊云科技的新服务 Amazon Bedrock 提供支持。即日起，客户将能够提前使用定制 Anthropic 模型的功能，利用自己的专有数据来创建自己的私有模型，并且可以通过 Amazon Bedrock 的自助服务使用微调功能。
在顶层，亚马逊云科技为客户提供了生成式 AI 应用程序和服务，比如功能强大的 AI 编程助手 Amazon CodeWhisperer，它可以直接在代码编辑器中生成代码编写建议，从而提高开发人员编写代码的效率。
至此，我们已经可以看到的是亚马逊云科技在 AI 方面的长远布局，也为后面的发展奠定了良好的基础。
Amazon Q 在 Amazon CodeWhisperer 推出之后，就对于 Amazon CodeWhisperer 的一些功能提出了期待，果然不出意料，在2023亚马逊云科技re:Invent大会推出在全新的 AI 生成式助手—Amazon Q
Amazon Q 可以帮助您使用公司信息存储库、代码和企业系统中的数据和专业知识，快速获得紧迫问题的相关答案、解决问题、生成内容并采取行动。 当您与 Amazon Q 聊天时，它会提供即时的相关信息和建议，以帮助简化任务、加快决策速度并帮助激发工作中的创造力和创新。
有问题必定有答案，Amazon Q：一款基于生成式人工智能（AI）的新型助手，专为辅助工作而设计，可以针对客户的业务量身定制，可为开发人员和 IT 专业人员提供支持，可在亚马逊云科技的多个领域提供，无论您在哪里工作，都可以快速访问答案和创意
提供多种功能和使用场景
借助 Amazon Q，AI 专家将随时待命，回答问题、更快地编写代码、排查问题、优化工作负载，甚至可以帮助您编写新功能。这些功能简化了在亚马逊云科技上构建应用程序的所有阶段的工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92bcd06b6aaee4d0ef7537ebbd694bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f149b2b2eb80bf46689563362e98a94/" rel="bookmark">
			亚马逊云科技 re:Invent 2023 产品体验：亚马逊云科技产品应用实践 国赛选手带你看 Elasticache Serverless
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抛砖引玉 讲一下作者背景，曾经参加过国内世界技能大赛云计算的选拔，那么在竞赛中包含两类，一类是架构类竞赛，另一类就是 TroubleShooting 竞赛，对应的分别为亚马逊云科技 GameDay 和亚马逊云科技 Jam，想必也有朋友玩过此类竞赛，那么最经典的一个 Gameday，我认为是 Gameday 2015 那个比赛，感兴趣的朋友可以在这里看看：Amazon-Gameday-2015-Runbook
亚马逊云科技开发者社区为开发者们提供全球的开发技术资源。这里有技术文档、开发案例、技术专栏、培训视频、活动与竞赛等。帮助中国开发者对接世界最前沿技术，观点，和项目，并将中国优秀开发者或技术推荐给全球云社区。如果你还没有关注/收藏，看到这里请一定不要匆匆划过，点这里让它成为你的技术宝库！
上图为一个简易架构示例图
那么在这场比赛中，是有好几个版本的，如果说延伸到后面的版本，那么 Elasticache 是一个拿分的好物(在不考虑 Cloudfront 的情况下)，因为从客户端发送来的数据，会被缓存到 Elasticache 中，在这里当然是用的 Elasticache for memcached，当客户端再次发送同样的数据请求过来的时候，首先会往 memcache 的查询数据，如果有就即刻返回。
那么在这个实践的过程中，我们抛开架构上的设计，我们使用 Elasticache for Memcached 首先是要去创建。
OK，那么问题来了
在生产实践中，我们需要考虑到成本的问题，创建多大呢？我们如何去预估这个缓存数据库的一个规模大小，这是第一个问题(虽然在竞赛中，都是扣一样的) 创建缓存数据库需要花时间，如果设置错误，删除也需要花费时间，在每个阶段会需要时间等待，大约4-5分钟
总结起来就是：弹性伸缩，成本管控
视频简介 点击下方链接，观看视频简介
亚马逊云科技re:Invent 2023产品体验：亚马逊云科技产品应用实践 国赛选手带你看Elasticache Serverless_哔哩哔哩_bilibili
亚马逊云科技 re:Invent 2023 产品体验：亚马逊云科技产品应用实践 国赛选手带你看 Elasticache Serverless
Serverless 助力数据拓展无极限 在 2023 亚马逊云科技 re:Invent 大会中，Peter 宣布推出 Amazon ElastiCache Serverless，这是一种新的无服务器选项，允许客户在一分钟内创建缓存并根据应用程序流量模式立即扩展容量。Amazon ElastiCache Serverless 与两种流行的开源缓存解决方案 Redis 和 Memcached 兼容。
Amazon ElastiCache Serverless 具有以下优势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f149b2b2eb80bf46689563362e98a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e174bb66ab3b0a1862a4ec5f0a6ddf3a/" rel="bookmark">
			提升数据库性能的关键所在！Mysql执行计划解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
简介
使用
执行计划信息
id
select_type
table
partitions
type
possible_keys
key
key_len
ref
rows
filtered
Extra
简介 在MySQL中，执行计划是指数据库系统根据查询语句和相关数据表的统计信息，预先计算出最优的执行方式。执行计划通常包括选择哪个索引来检索数据、按照什么顺序访问表和索引、使用哪些操作符来连接和过滤数据等。
执行计划是数据库提供给我们的一套对sql语句进行解析、分析、优化功能的工具，他具有以下的作用：
展示表的读取顺序；
数据读取操作的类型；
哪些索引是可以使用的；
哪些索引是实际上使用的；
表之间的引用关系；
每张表被查询的行数。
注意：执行计划只是数据库针对sql给出最佳的优化参考方案，并不一定是最优解，即不要过度相信执行计划
使用 在MySQL中，执行计划是一个对象，可以通过查询EXPLAIN语句的结果来获取。EXPLAIN语句用于分析查询语句的执行计划，以便更好地了解查询是如何执行的。
下面是一个示例查询，演示如何使用EXPLAIN语句获取执行计划：
EXPLAIN SELECT * FROM your_table WHERE column1 = 'value1' AND column2 = 'value2'; 在上面的示例中，将your_table替换为实际的表名，column1和column2替换为实际的列名，value1和value2替换为实际的值。执行该查询后，MySQL将返回一张表格，其中包含执行计划的详细信息。
通过分析执行计划的结果，可以了解到查询语句的性能瓶颈，优化查询语句的执行效率。例如，如果发现查询使用了全表扫描，则可以考虑创建适当的索引来提高查询性能。
执行计划信息 执行计划的结果通常包括以下几列：
id：表示查询中每个操作的序号。select_type：表示查询的类型，例如SIMPLE、PRIMARY、SUBQUERY等。table：表示相关的表名。type：表示访问表的方式，例如ALL、INDEX、RANGE、REF等。possible_keys：表示可能使用的索引。key：表示实际使用的索引。key_len：表示使用的索引长度。ref：表示与索引比较的列或常量。rows：表示MySQL估计需要扫描的行数。Extra：表示其他附加信息，例如是否使用了临时表、是否使用了文件排序等。 id select查询序列号，有几个select就有几个id，id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。
select_type select_type：表示select语句的类型，可以有以下取值;
SIMPLE：表示简单查询，其中不包含子查询、连接、分组或排序操作。 PRIMARY： 表示主查询，当查询中包含任何复杂的子部分，最外层的查询被标记成 primary UNION：在 union、union all 和子查询中的第二个和后面的 select 会被标记为 union DEPENDENT UNION：在包含 union 或者 union all 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的 select_type 的值就是 dependent union UNION RESULT： 从 union 表获取结果的 select 会被标记为 union result SEBQUERY：在 select 或者 where 列表中包含子查询（不在from子句中） DEPENDENT SEBQUERY：子查询中的第一个 select（不在 from 子句中），并且取决于外层查询 DERIVED：在 form 列表中包含的子查询被标记为 derived，也叫做派生类 UNCACHEABLE SEBQUERY：一个子查询的结果不能被缓存 UNCACHEABLE UNION：表示 union 的查询结果不能被缓存 SUBQUERY：子查询，嵌套在外部查询中的查询。 DEPENDENT SUBQUERY：表示子查询依赖于外部查询的结果 MULTIPLE_SUBQUERY：包含多个子查询的查询，每个子查询都返回一个结果集。 EXISTS_SUBQUERY：用于检查子查询是否返回任何结果的查询。 IN_SUBQUERY：子查询作为IN条件的一部分。 LEFT_JOIN_SUBQUERY：子查询作为左连接条件的一部分。 RIGHT_JOIN_SUBQUERY：子查询作为右连接条件的一部分。 FULL_JOIN_SUBQUERY：子查询作为全连接条件的一部分。 table table：表示查询的表名，可以有以下几种情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e174bb66ab3b0a1862a4ec5f0a6ddf3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11da78e0d3c43d94c6a3d5496a7c568a/" rel="bookmark">
			Python pandas 操作 excel 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 概述1.1 pandas 和 openpyxl 区别1.2 Series 和 DataFrame 2 常用操作2.1 创建 Excel：to_excel()2.2 读取 Excel：read_excel()2.2.1 header：标题的行索引2.2.2 index_col：索引列2.2.3 dtype：数据类型2.2.4 skiprows：跳过的行数2.2.5 usercols：指定列数2.2.6 head(n)、tail(n)：读取前、后 n 行数据 2.3 读写数据2.3.1 at()：获取单元格2.3.2 loc[]：数据筛选2.3.3 sort_values()：数据排序 3 实战3.1 遍历 Excel 1 概述 1.1 pandas 和 openpyxl 区别 Python 中的 pandas 和 openpyxl 库，均可以处理 excel 文件，其中主要区别： pandas：① 数据操作和分析方面表现优异。它提供了各种文件格式（包括 Excel）中读取数据的函数，在过滤数据、汇总数据、处理缺失值和执行其它数据转换任务方便，特别有用。② 使用方便。DataFrame 对象，使用快速方便，且功能十分强大。openpyxl：侧重单元格格式设置。这个库也允许我们直接处理 Excel 文件。pandas 快，但 pandas 做不了的事情，可以让 openpyxl 来做，例如：单元格注释、填充背景色 等等 1.2 Series 和 DataFrame Series：连续。可理解为 “一维数组”，由一行 或 一列 组成，具体是行，还是列，由 DataFrame 指定DataFrame：数据框。可理解为 “二维数组”，由行和列组成 import pandas as pd # Series 示例 s = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11da78e0d3c43d94c6a3d5496a7c568a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba3fdce713038534f21571969fd49e6a/" rel="bookmark">
			不小心删除了docker/overlay2怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除你的容器，删除你的镜像！ 重新来！
然后，占用大量空间的日志文件位于containers下的文件夹下的会存在以目录名为前缀，以“-json.log”为后缀的目录文件，清理完成可不重启服务，重启更好。
第二种情况：可通过执行docker system prune 命令可用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像（即无tag的镜像）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae89ac01a722513625981b3c6b1f0a6b/" rel="bookmark">
			财务分析进阶篇：终于有人把利润分析怎么做给讲清了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的BI系列文章中，我们给大家介绍了如何用BI进行企业费用分析和毛利分析的方法。
发布后有小伙伴提到：“既然费用和毛利都分析了，顺便把利润表的数据分析一起做了呗”，因此这就有了本期内容。我希望结合前两篇文章，做一个企业利润分析，用BI对财务数据进行系统性分析。
01企业整体利润情况 在做企业利润分析之前，我们首先需要整体了解企业整体的利润情况。
在这里我们采用了可视化的形式去模块化展示：整体利润情况&amp;利润简表数据展示
整体利润情况 通过趋势图展示企业各月的销售收入、费用成本以及对应的毛利率和净利率情况。
例如在下图中，我们可以明显看到，2023年1月收入、净利率有明显下降，若想查询具体下降多少？为何下降？则可点击钻取，与下方利润简表数据联动。
利润简表数据展示 在整体利润情况看板下方，我们通过BI绘制了一张常规的利润数据简表。
这样我们可以通过上图看到利润趋势的概览，再通过数据联动，在下方看到各个月份的具体利润数据，内容包含：本月具体销售收入、销售成本、毛利及营业税金及附加等财务数据。
02企业利润分布来源 在对企业整体利润情况有了大致的了解后，我们下一步就是需要做好规范管理。
例如，很多时候业务同事其实并不清楚自己实际的业务动作最后核算下来是否亏损，所以下一步我们就需要根据管理维度（区域和业务分类）来了解各维度下利润的贡献情况，分析有哪些是低利润甚至负利润的情况，并予以重视：
区域维度 我们以区域为例，能够看到区域利润占比饼图中中，北方区的利润占比非常小，这和我们的经验是不符的，因为对该企业来说，北方区一直是一个高销售额区域。
为了进一步了解原因，此时我们点击筛选“北方”，就能在右侧得到北方区的月度贡献利润情况，通过数据可以看出，北方区的利润近半年都处于负利润，处于异常状态，需要对北方区做好深入的区域业务分析，从而找出亏损原因。
业务维度 同理，我们也可以从产品，也就是业务的角度进行拆解，此处不过多赘述。
03企业费用情况 整体利润情况和利润分布来源分析完了，下一步我们就需要打开具体的指标影响项来完成进一步的分析。
就利润而言，我们一般会针对费用和成本进行利润专项的分析，由于篇幅原因，本次笔者就以费用角度来做介绍。
首先是判断费用的花费是否合理，这一点我们从“预算和费销比”的角度进行考虑。
首先是费用预算（上图左），如果企业有自己的费用预算机制，我们可以直接结合FineBI针对预算建立预警管控机制（下图），根据自己内部的预算管理机制对一些异常花费以及风险部门进行自动推送提醒。
同时我们在衡量费用的花费是否合理时，建议结合费销比（上图右）进行对比考虑。
同时针对明显的费用异常项，我们也可以打开到细分项进行管控：
最后的话是责任归属以及费用明细。
我们可以将这两个视角在BI中进行展示，实现从利润到费用再到明细、责任部门的全链路追踪。
最后就可以将我们上述介绍的东西打包成财务分析应用进行发布，即将【整体利润】、【分责任中心管理】、【费用分析】以及我们每个月的经营分析报告打包成一个“分析应用主题”，挂载在企业BI平台上，设置好权限后分享给我们的领导和同事，领导和同事可随时随地打开看板，进行数据的查看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832b35b37599dc373e5c2d20e06597b3/" rel="bookmark">
			requestium这个Python库更强大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Requestium是一个Python库，它结合了Selenium（用于浏览器自动化）和Requests（用于HTTP请求）的功能。这个库的目标是简化在网页抓取和自动化过程中同时处理静态内容和动态加载内容的过程。
使用Requestium，你可以先用Requests获取网页的静态内容，然后在需要时切换到Selenium来处理JavaScript生成的内容或者进行用户交互。这使得在处理混合型网页（既有静态内容又有动态加载内容）时更加高效和灵活。
Requestium使用示例
from requestium import Session # 创建一个Session实例 s = Session(webdriver_path='path/to/your/webdriver') # 使用Requests方式访问一个网页 s.get('http://example.com') # 现在你可以使用Selenium的方法，比如找到一个元素 element = s.driver.find_element_by_id('my-element') # 或者执行JavaScript代码 result = s.driver.execute_script("return document.title;") # 当你完成操作后，记得关闭WebDriver s.driver.quit() 在这个例子中，我们首先创建了一个Session实例，指定WebDriver的路径。然后，我们可以像使用Requests一样使用s.get()方法来获取网页。接下来，我们可以使用Selenium的方法，如find_element_by_id()或execute_script()来处理动态内容。最后，当我们完成所有操作后，我们需要调用s.driver.quit()来关闭WebDriver。
请注意，要使用Requestium，你需要预先安装Selenium和对应的WebDriver（例如ChromeDriver或GeckoDriver，取决于你使用的浏览器）。你也需要安装Requestium库，可以通过pip来安装：
pip install requestium 由于Requestium是基于Selenium和Requests的，所以在使用前确保已经安装了这两个库：
pip install selenium requests 并且根据你的操作系统和浏览器类型，下载并配置相应的WebDriver。
requestium的高阶使用方法及实例代码
Requestium的高阶使用方法通常涉及到更复杂的网页自动化和交互，包括处理动态加载内容、模拟用户操作、处理Cookies和Headers等。以下是一些高阶使用方法的示例代码：
处理动态加载内容：使用Selenium的implicitly_wait方法来设置一个等待时间，让WebDriver在查找元素时自动等待页面加载完成。
from requestium import Session s = Session(webdriver_path='path/to/your/webdriver') s.driver.implicitly_wait(10) # 设置最大等待时间为10秒 s.get('http://example.com') # 等待页面加载完成后查找元素 element = s.driver.find_element_by_id('my-dynamic-element') 模拟用户操作：使用Selenium的方法来模拟用户点击、输入和滑动等操作。
from requestium import Session s = Session(webdriver_path='path/to/your/webdriver') s.get('http://example.com') # 模拟点击元素 element = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/832b35b37599dc373e5c2d20e06597b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80c4af79bfdaea737dd9b9c004eeece7/" rel="bookmark">
			4款简单Python代码，彻底掌握try语句的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编程中最头疼的莫过于辛辛苦苦写完的代码，运行的某个瞬间突然报错，出现一大堆红色的“error”字样，程序立刻中断，这就是所谓的程序异常。异常一般是由于无效的输入、资源耗尽或代码错误等原因引起的。
本文通过4款简单实用的代码，教会大家如何让程序在遇到错误时优雅地恢复运行或正常退出。
想象一下，你正在尝试编写一个简单的程序。该程序需要用户输入两个数字，并将它们相除得到结果。
用户很有可能不是那么的“听话”，如果用户输入了一个零作为分母，那么程序将会遇到一个“除以零”的错误，这在数学上没有意义，程序会立刻报错中断。
一、try-except 为了处理这种情况，Python提供了try-except语句。下面是一个简单的例子：
try-except结构是用来捕获和处理异常的基本形式。当try块中的代码执行时，如果发生异常，则执行流程会立即转到except块。
try: # 尝试执行的代码块 num1 = float(input("请输入一个数字：")) num2 = float(input("请再输入一个数字：")) result = num1 / num2 print("两数相除的结果是：", result) except ZeroDivisionError: # 如果在try部分的代码执行中发生了ZeroDivisionError异常，则执行这部分代码 print("错误：不能除以零！") 在这个例子中，如果用户输入了0作为第二个数字，程序不会直接崩溃，而是打印出“错误：不能除以零！”的提示信息。
二、try-except-else 更进一步，如果你想在程序没有异常时执行额外的操作，那么可以使用try-except-else结构。else后面的代码将在没有异常发生时正常运行：
try: num1 = float(input("请输入一个数字：")) num2 = float(input("请再输入一个数字：")) result = num1 / num2 except ZeroDivisionError: print("错误：不能除以零！") else: # 如果没有异常发生，则执行这部分代码 print("两数相除的结果是：", result) 在这个例子中，如果没有发生异常，即用户没有输入0作为除数，那么程序将会正常打印出两数相除的结果result。
三、try-except-finally 最后，我们还有try-except-finally结构。**无论是否发生异常，finally之后的代码都将被执行。**这对于执行一些清理工作或总结性的输出是非常有用的：
try: num1 = float(input("请输入一个数字：")) num2 = float(input("请再输入一个数字：")) result = num1 / num2 except ZeroDivisionError: print("错误：不能除以零！") else: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80c4af79bfdaea737dd9b9c004eeece7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/25/">«</a>
	<span class="pagination__item pagination__item--current">26/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/27/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>