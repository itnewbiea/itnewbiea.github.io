<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e443fdde166192b3b332283e001ea7/" rel="bookmark">
			如何设置cookie的过期时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认cookies失效时间是直到关闭浏览器，cookies失效，也可以指定cookies时间。
Response.Cookies("user_name").Expires=Date+1 '指定cookie保存时间
保留COOKIES一个小时
Response.Cookies("MyCookie").Expires= (now()+1/24) Response.Cookies("MyCookie").Expires = DateAdd("h", 1, Now())
设置60个月以后过期
Response.Cookies("CookieName").Expires=DateAdd("m",60,now())
Response.Cookies("User").expires=second()+7
在expires后面定义的时间可以用时间函数代替
例如：date()+7就表示在今天的时间上加上7天，而second()+7则是7秒了。
Response.Cookies("字段名").expires=时间函数+N，
例如： Response.Cookies("name2").expires=date+1，表示Cookies保存1天，
再比如： Response.Cookies("name2").expires=Hour+8，表示Cookies保存8小时。
这种方法我测试过不行（在2003server,iis6.0中)，不管second后面有无加()，
访问时会出现500错误（还是无法显示网页？忘了）。 织梦尤文：这里的时间累加建议还是使用DateAdd函数，比如我们要累加一小时，
则使用： Response.Cookies("baidooglecom").expires = DateAdd("h", 1, Now()) 30分钟：
Response.Cookies("CookieName").Expires=DateAdd("n",30,now()) dateadd("S",30,now()) 得到秒 Expires 指定 cookie 的过期日期。为了在会话结束后将 cookie 存储在客户端磁盘上，
或在许多时候，我们希望能更长时间地在访问者的计算机上保存cookie。必须设置该日期。
若此项属性的设置未超过当前日期，
则在任务结束后 cookie 将到期。 cookie的使用到期时间为“2010年1月1日”： Response.Cookies("CookieName").Expires=#January 01, 2010# cookie的过期时间为“cookie的创建时间＋365天”：Response.Cookies("CookieName").Expires=Date+365 但最好不要随便写 Response.Cookies("CookieName").Expires=Date，
这样页面之间的调用时值会为空。
Function killip(cook,cooktime) '封杀ip，同一个ip不能多次执行,( cookies名字，cookies时间) killip("queip",30)
cook = checkstr(cook)
If Not isint(cooktime) Then
response.write "cooktime is not int"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41e443fdde166192b3b332283e001ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fff56d181bdc7f54412cc5eeaf467e/" rel="bookmark">
			编程语言的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 目前常用的编程语言包括C， C++， Java， C#，PHP，Javascript，Python， Ruby。
我们先把这些语言分类，C，C++是编译型语言，而Java和C#属于基于虚拟机的语言，PHP， Python， Ruby， Javascript属于解释器语言。
所有的编程语言的设计思想基于两个相反的方向，一个是以丘奇的思想为代表的Lisp语系，他们关心的是逻辑和语言， 另一个是以图灵的思想为代表的Ｃ语系，他们更关注物理和机器。简单的说，就是一方面人们希望编程更贴近人的逻辑和语言，而另一方面更贴近机器的思维和语言。
然而，目前看这两个语系都有各自的优点和缺点。贴近人的思维、远离机器的语言，往往性能比较差（用过emacs就知道Lisp的程序有多慢了），但贴进机器的思维往往编程就是在受虐，因为你不能集中精力去解决业务问题，而是不断在解决技术问题。用过Ｃ语言的人都知道，无时无刻不在想着内存在哪里申请，在哪里释放。
但事实上常用的这些编程语言，很多都是两个方向的特性兼而有之，比如Java就吸收了很多C，C++和Lisp的特性。C系的语言从UNIX诞生以来一直是最受欢迎的语言，并成为软件工程界的主流，但最近几年Lisp系的语言逐渐被人们注意，主要原因是由于计算机性能的快速发展，和软件项目的不断膨胀。
开发效率与执行效率人们都想要，但这两者却是矛盾的。也许在不久的将来，人们可以发明一种语言能够平衡两者，从此程序员只需学习这一种语言，也许这种平衡是动态的，需要语言不断的调整。
如何选择，我想你已经有了答案。
建议每个有志于成为Programmer的同学至少要弄清楚C和Lisp这两种语言，不一定拿他来开发产品，但要弄清楚他们的设计思想。如果只想成为码农，那只需掌握Java，并熟练使用它，掌握它的每一个细节。
转载于:https://my.oschina.net/zhoukuo/blog/350490
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e7d8fa9694acf33f19ea422efef7e4/" rel="bookmark">
			Android学习笔记之二-----HelloWorld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，打算学习android，为了加深自己的理解。所以打算把学习历程记录下来。
因为之前已安装过环境，所以打算android环境安装过程以后再写一篇博客。1任何一门语言，开始的例子怎么少得了HelloWorld呢。所以，我第一个学习例子肯定就是Hello
World啦。
首先，新建一个android application project，然后一直next，最终finish保存即可
新建好项目之后，打开MainActivity.java,右键Run As -&gt;Run Configuration是，出来以下图片：
点击Browse，选中自己新建的项目，然后在Launch中选择MainActivity这个类，运行即可。(第一次启动可能有点慢)。运行完之后出现以下图片：
这样，一个HelloWorld的程序就弄好了。刚开始可能会让人觉得很奇怪，感觉自己一行代码都没写，helloworld怎么就出来了。接下来就来分析以下。
打开AndroidManifest.xml这个文件，
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.android_001_helloworld" android:versionCode="1" android:versionName="1.0" &gt; &lt;uses-sdk android:minSdkVersion="8" android:targetSdkVersion="18" /&gt; &lt;application android:allowBackup="true" android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme" &gt; &lt;activity android:name="com.example.android_001_helloworld.MainActivity" android:label="@string/app_name" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 会看到有@string，@style，@drawable这样的写法。@string就对应/res/values下的strings.xml文件， &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;string name="app_name"&gt;Android_001_HelloWorld&lt;/string&gt; &lt;string name="action_settings"&gt;Settings&lt;/string&gt; &lt;string name="hello_world"&gt;Hello world!&lt;/string&gt; &lt;/resources&gt;@string/app_name的值就是Android_001_HelloWorld。res目录写还有很多文件夹如下图： 这些xml文件最终会变异成一个类，R.java,
打开这个类会发现之前的layout，menu，string，style都会在里面建立相应的类和变量。而helloworld就是在res/layout下的activity_main.xml布局文件定义的，
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4e7d8fa9694acf33f19ea422efef7e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103f20ae8ef8489d14d825a7b0ca9860/" rel="bookmark">
			md5 brute force hashcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yes I'm using windows 7 numbers and letters uppercase lowercase 7 characters a single hash OK try this. I have used oclhashcat-plus in this example because you wanted to just test length 7. Normally if you are brute forcing a single MD5 you would probably want to use oclhashcat-lite. However I personally like oclhashcat-plus better and when you want to test a list of MD5 you will have to use oclhashcat anyway.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103f20ae8ef8489d14d825a7b0ca9860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7581f8906354ca0a74561dc1075ca04/" rel="bookmark">
			常见的9种内部排序(C语言实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在已经把常见的9种内部排序算法都用C语言实现了，为了方便自己和大家查看，就弄了这么一个类似于导航目录的东西。
一、冒泡排序
冒泡排序（C语言版）
二、选择排序
选择排序(C语言版)
三、直接插入排序
直接插入排序(C语言版)
四、希尔排序
希尔排序(C语言版)
五、归并排序
归并排序(C语言版)
六、基数排序
基数排序(C语言版)
七、快速排序
快速排序（C语言版）
八、计数排序
计数排序(C语言版)
九、堆排序
堆排序(C语言版)
介绍完这九个常用的排序算法,怎么能没有一个比较呢?下面是我对这九种排序算法进行的简单性能比较:
9种常见内部排序算法的性能比较
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2470a788cde486fe6105e4b3064eba0b/" rel="bookmark">
			Qt text Browser 控件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在界面需要显示收到内容可以使用text Browser空间，在工作中使用方便，我在使用中直接使用
ui-&gt;textBrowser-&gt;insertPlainText()，插入文本可是在输出的内容的时候输出的位置不确定有时按顺序依次向下输出，有时在中间输出！ 解决方法如下： 1、使用其他方法写内容 textBrowser-&gt;textCursor().insertText(),插入文本到光标位置 2、使用控件自带的信号textChange()，当有文本插入的时候就会触发该信号，然后自定义槽函数将光标移动到控件插入最后位置 textBrowser-&gt;moveCursor(QTextCursor::End) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d100b877ddc0583922ad1180151f377/" rel="bookmark">
			MQ报 AMQ9259
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ACTION: None. ------------------------------------------------------------------------------- 11/13/14 09:40:02 - Process(50593992.21) User(mqm) Program(amqrmppa) Host(midcup1) AMQ9259: Connection timed out from host '10.168.16.6'. EXPLANATION: A connection from host '10.168.16.6' over TCP/IP timed out. ACTION: The select() [TIMEOUT] 360 seconds call timed out. Check to see why data was not received in the expected time. Correct the problem. Reconnect the channel, or wait for a retrying channel to reconnect itself. ----- amqccita.c : 3789 ------------------------------------------------------- 11/13/14 09:40:02 - Process(50593992.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d100b877ddc0583922ad1180151f377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16acbfc51ce3246ba004d13658669d3f/" rel="bookmark">
			C语言#define宏中省略号的含义？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ C语言#define宏中省略号的含义？ 2009-08-18 09:27:05 分类： 嵌入式
在LDD第三版第4章中给出如下宏定义，请问args后面的省略号(...)有什么作用？在args与省略号之间加入逗号有什么影响? #define PDEBUG(fmt, args...) printk( KERN_DEBUG "scull: " fmt, ## args)
参与了一些资料之后才明白:宏定义中的省略号表示一串可变的参数, 这一串参数可用args加以引用.比如, 代码 PDEBUG("a=%d, b=%d", a, b);
在展开宏时, 由于args = a, b, 故展开后变为
printk( KERN_DEBUG "scull: " "a=%d, b=%d", a, b);
宏定义中的省略号就是指一串数目不限的参数列表,前面用args只有为了后面引用这串参数.如果在args与省略号之间加入逗号,就变成args = a, 而省略号指向的那串参数只包含一个b.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7540222e36b958fc3c90830e61c7b5e/" rel="bookmark">
			求n个字符的全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* * 对n个不同的字符进行全排列 * 算法思想： * 假设求 1234 的全排列 * ① 把 1 固定，234 求全排，进行递归排列，直到为一个元素，打印所有元素，最后恢复最初的排序 * ② 把 1 和 2 进行交换，把 2 固定，134 求全排列，直到为一个元素，打印所有元素，最后恢复最初的排序 * ③ 同上所示，直到把 4 作为第一个为止。 */ #include &lt;iostream&gt; using namespace std; void FullArray(char *str, int m, int n) { int i, tmp; if (n == m) { for (i = 0; i &lt; n; i++) cout &lt;&lt; str[i]; cout &lt;&lt; endl; } else { for (i = m; i &lt; n; i++) { tmp = str[i]; str[i] = str[m]; str[m] = tmp; FullArray(str, m + 1, n); tmp = str[i]; str[i] = str[m]; str[m] = tmp; } } } int main(void) { char str[100] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7540222e36b958fc3c90830e61c7b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8786b9ae2ac053c64d43b86c4289ce6/" rel="bookmark">
			用for和while循环求e的值[e=1&#43;1/1!&#43;1/2!&#43;1/3!&#43;1/4!&#43;1/5!&#43;...&#43;1/n!]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /*编写程序，根据以下公式求e的值。要求用两种方法计算:1)for循环，计算前50项2)while循环，直至最后一项的值小于10-4e=1+1/1!+1/2!+1/3!+1/4!+1/5!+...+1/n!*/#include&lt;stdio.h&gt;//=====================================================//用for求e的值double For(){double sum=1,temp=1;int i;for(i=1;i&lt;50;i++){temp/=i;sum+=temp;}return sum;}//=====================================================//用while循环求e的值double While(){double sum=1;//首项设置为1double temp = 1;int i=1;while(temp&gt;=1e-4){//【e=1+1/1!+1/2!+1/3!+1/4!+1/5!+...+1/n!】temp = temp/i;//第二项1/1,即1/1!;第三项1/2,即1/2!;第四项(1/2)/3,即1/3!...sum = sum+temp;i++;}return sum;//返回sum}//主函数int main(){double a = For();double b = While();printf("用for循环求出e的前50项的和是%lf\n",a);printf("用while循环求出e和是%lf\n",b);return 0;}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99644817c46dc1daf16e70f192aed4ea/" rel="bookmark">
			C&#43;&#43;函数的导出与导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DLL使用
（1）隐式链接到 DLL 的可执行文件在生成时链接到导入库(.lib文件)。
（2）采用显式连接（LoadLibrary和GetProcAddress）时，不需要.lib文件。
函数导出方式
（1）源代码中的 __declspec(dllexport) 关键字 （2）.def 文件中的 EXPORTS 语句 （3）LINK 命令中的 /EXPORT 规范 所有这三种方法可以用在同一个程序中。LINK 在生成包含导出的程序时还创建导入库，除非生成中使用了 .exp 文件。
导出
CppDynamicLinkLibrary.cpp
#include "CppDynamicLinkLibrary.h" #include &lt;strsafe.h&gt; #pragma region DLLMain BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } #pragma endregion #pragma region Global Data // An exported/imported global data using a DEF file // Initialize it to be 1 int g_nVal1 = 1; // An exported/imported global data using __declspec(dllexport/dllimport) // Initialize it to be 2 SYMBOL_DECLSPEC int g_nVal2 = 2; #pragma endregion #pragma region Ordinary Functions // An exported/imported cdecl(default) function using a DEF file int /*__cdecl*/ GetStringLength1(PCWSTR pszString) { return static_cast&lt;int&gt;(wcslen(pszString)); } // An exported/imported stdcall function using __declspec(dllexport/dllimport) SYMBOL_DECLSPEC int __stdcall GetStringLength2(PCWSTR pszString) { return static_cast&lt;int&gt;(wcslen(pszString)); } #pragma endregion #pragma region Callback Function // An exported/imported stdcall function using a DEF file // It requires a callback function as one of the arguments int __stdcall CompareInts(int a, int b, PFN_COMPARE cmpFunc) { // Make the callback to the comparison function // If a is greater than b, return a; // If b is greater than or equal to a, return b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99644817c46dc1daf16e70f192aed4ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1132c88174c746ec3b49c42115f22378/" rel="bookmark">
			数据源BasicDataSource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何配置数据源，第三方的数据源插件最常用的主要是c3p0和dbcp:
以下是我配置的一个dbcp数据源的一个实例
首先导入commons-dbcp2-2.0.1.jar，commons-pool2-2.2.jar
package com.thinkgis.xxfbxt.dbconn;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import org.apache.commons.dbcp2.BasicDataSource;
/**
* * @author Administrator
*
*/
public class DataBaseSource {
public static void main(String[] args) {
BasicDataSource datasource = new BasicDataSource();
datasource.setDriverClassName("oracle.jdbc.driver.OracleDriver");
datasource.setUrl("jdbc:oracle:thin:@127.0.0.1:1521:oracle");
datasource.setUsername("username");
datasource.setPassword("password");
Connection conn = null;
String sql = "select * from tablename";
PreparedStatement psmt = null;
ResultSet rs = null;
try {
conn = datasource.getConnection();
psmt = conn.prepareStatement(sql);
rs = psmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1132c88174c746ec3b49c42115f22378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220fc50597492478d3406ff45fdcc4d5/" rel="bookmark">
			sql server查询表结构（字段名，数据类型，长度，描述，是否允许为空，是否为主键）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.xxling.com/blog/article/58.aspx
一、为什么要读取表结构
对于一个程序员的平常工作当中，我们常用的都是用来从数据库表中读取数据的sql，而对于表结构的读取就比较少用了。因为有客户端，没事我们也没必要通过sql语句就读取而查找表结构之类的东西。但是在以下的一些情况中可能我们就要用到了。比如：
1.要写一个实体生成器的时候，我们就得读取表的字段、类型等等之类的东西；
2.如果要做一个数据库管理系统，我们不仅要读取结构，我们还得知道怎么去添加和修改这些结构（不过添加和修改不在这篇文章的介绍内容内）；
当然还会有其他的一些用到的情况，这里就不一一列举了。
二、怎么入手
当我们想到要做读取表结构这件事时，我们该如何入手呢。如果我们已经是这方面的专家或已经熟悉了这方面的知识的话，那么我们需要的就是动手去做了。但如果你之前对这一无所知或者了解不够的时候，我们该怎么做呢？
今天我们就说说第二种情况我们该怎么做吧。为什么要说这呢？因为每个人的知识都是有限的，而且不可能每一次在你需要的时候都有人在身边告诉你怎么去做，所以我们就要学会如何用手上可以用的资源来寻找到我们想要的东西。
如果我们完全不知道的情况下，第一，我们可以把我们知道的关键字到搜索引擎去获取一些知识和答案，然后我们根据这些知识可以做进一步的检索或者根据自己已有的经验去引导自己去摸索和认识。第二，我们可以向身边有经验的同事或者同学询问。第三，我们也可以到一些技术论坛发帖提问来寻找答案。学会自己去找答案，这是很重要的，这是我为什么要啰嗦这一部分的原因。
三、需求
今天我们想要读取的结构包括：数据库中的所有用户表，表的字段名，字段类型，字段长度限制，字段描述，是否允许为空，是否为主键。
四、有哪些方案
这里我先说明一下，今天说的是sql server 2005及以上的版本，因为2000版本的会有一些差别，后面会提到。
通过我们掌握的知识，我们知道，数据库表结构相关的元数据是存储在数据库的系统表里的。那我们先看数据库的表结构信息都可以在哪里找得到。
首先打开我们要操作的数据库，展开视图中的系统视图选项，我们就可以看到一大堆的分别以INFORMATION_SCHEMA.XXX,sys.sysXXX和sys.XXX形式存在的视图。这些视图都是些什么呢？
以INFORMATION_SCHEMA.XXX形式存在的视图我们称之为信息架构视图，它们是在系统表的基础上建立的一系列视图，提供了更加直观的结果。2000版本时是在master数据库中，而从2005版本开始，这些视图被移到了每个数据库中去了。其次这些视图是符合ISO标准的。
以sys.sysXXX形式存在视图我们称之为兼容性视图，顾名思义这些视图就是为了向后兼容而存在的，在2000版本时这些视图就已经存在但未公开，只公开了在master中的系统表。2005版本之后公开了这些视图并放在每个数据库中。
以sys.XXX形式存在的视图我们称之为目录视图，是2005版本之后弄出来的东东。
那么具体这些视图中每个视图又都分别有什么数据呢？如果你手头有完整的介绍，那就直接看介绍就好。否则，首先我们可以通过它们的命名来判断它们存储的相关内容，其次我们可以将它们的结果搜索出来看看里面到底是什么东西，而对于每个字段是什么意思，我们可以通过F1去查找到相关的帮助文档。
根据第三部分的需求，我们一一找到数据所在的位置，如下： 数据库的用户表列表：sys.sysobjects或者sys.tables或者INFORMATION_SCHEMA.TABLES 表的字段名：sys.syscolumns或者sys.columns或者INFORMATION_SCHEMA.COLUMNS 字段类型：sys.syscolumns（加上sys.systypes）或者sys.columns（加上sys.types）或者INFORMATION_SCHEMA.COLUMNS 字段长度：sys.syscolumns或者sys.columns或者INFORMATION_SCHEMA.COLUMNS 字段描述：sys.extended_properties 是否允许为空：sys.syscolumns或者sys.columns或者INFORMATION_SCHEMA.COLUMNS 是否为主键：sys.sysobjects（加上sys.sysindexes和sys.sysindexkeys）或者sys.indexes（加上sys.index_columns）或者INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE 注：括号中的表都是需要他们联合才能拿到需要的信息的。比如sys.sysobjects没有与字段id建立关系，所以才加上sys.sysindexes和sys.sysindexkeys这两张表做桥梁来建立关系
五、如何去选择
首先，兼容性视图就是为了兼容而存在，而今天我们只考虑2005版本及以上的版本所以不在推荐使用，可以将它pass掉
其次，我们知道INFORMATION信息架构视图里面的信息会更加的直观而且符合ISO标准，理论上这是我们不二的选择。但是从第四部分的结果可以看出，INFORMATION的视图中找不到我们需要的字段描述的信息（当然可以借助其他办法配合拿到相应的信息）。相反，目录视图中可以找到所有的信息，所以也是一种选择
综上，我们应该选择信息架构视图或者目录视图。而信息结构视图的信息比较直观就不多说，这次主要是以目录视图来开讲，当然最终会给出三种方案的结果。
六、具体实现
1.读取数据库的所有表 select name from sys.objects where type = 'U' 或者 select name from sys.tables where type = 'U'
2.读取表结构
首先，我们先找出表之间的关联以获取表联合的条件。
所有表如下： sys.columns sys.types sys.extended_properties sys.objects（也可以用sys.tables，它是sys.objects派生表） sys.indexes sys.index_columns
既然我们读取的是表结构，那么首先我们的限定范围就应该是表，所以我们先要找到table对应的id，所以我们先从sys.objects表开始。我们可以通过表名进行过滤得到所要表的id。代码如下：
select object_id from sys.objects where name=@TableName
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/220fc50597492478d3406ff45fdcc4d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afdbdd0bc20808ebb13ea4cb50a8470/" rel="bookmark">
			C语言中库函数自带的排序函数qsort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直不知道C语言还有默认的排序函数,而且还是快速排序的函数,当时觉得自己C语言白学了,了解之后我觉得应该把这个函数的用法和用例展示出来,供大家参考。
#include &lt;stdlib.h&gt;
void qsort( void *buf, size_t num, size_t size, int (*compare)(const void *, const void *) );
功能： 对buf 指向的数据(包含num 项,每项的大小为size)进行快速排序。如果函数compare 的第一个参数小于第二个参数，返回负值；如果等于返回零值；如果大于返回正值。函数对buf 指向的数据按非降序排序。
要用这个函数,我们只需要自己实现compare这个函数即可,但是要满足函数规定的功能。
下面是我的实现代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; int compare(const void *value1, const void *value2); void printArray(int *array, int size); int main(int argc, char const *argv[]) { int size = 0; scanf("%d", &amp;size); assert(size &gt; 0); int *array = (int *)calloc(size, sizeof(int)); int i = 0; for (i = 0; i &lt; size; ++i) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5afdbdd0bc20808ebb13ea4cb50a8470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0439e4424980298e35250387a693df4/" rel="bookmark">
			STM32  用定时器产生1Mhz 脉冲，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 用定时器产生1Mhz 脉冲，PWM宽度可调，四路输出
源码：记得要加入文件 gpio rcc tim 等c文件 #include "stm32f10x_conf.h"
void GPIO_CFG(void); void RCC_CFG(void); void TIM_CFG(void); void NVIC_Configuration(void); int main (void) { RCC_CFG(); NVIC_Configuration(); GPIO_CFG(); TIM_CFG(); TIM_Cmd(TIM3,ENABLE); TIM_CtrlPWMOutputs(TIM3,ENABLE); //while(1); } void RCC_CFG(void) { SystemInit(); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE); } void GPIO_CFG(void) { GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP; GPIO_Init(GPIOA,&amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP; GPIO_Init(GPIOB,&amp;GPIO_InitStructure); } void TIM_CFG(void) { TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; // TIM_Period 计数值，比如 TIM_Period=17 分频参数 TIM_Prescaler=3 （0为不分频），APB1 时钟是72Mhz，
//在本参数情况下， 72Mhz/（17+1）/（3+1）= 1Mhz
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0439e4424980298e35250387a693df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6a194339b457bdc063289c70cb06c7/" rel="bookmark">
			Android：AppWidget之桌面小电筒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓开发中很多控件都是Widget类的，但是我们常说的Widget指的是AppWidget，即一些可以放置在桌面的小部件。
下面用两个实例来说一下这个AppWidget怎么来用。
实例一：AppWidget的基本使用
①创建一个AppWidget的布局文件appwidget_layout.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" &gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="今晚打老虎" &gt; &lt;/Button&gt; &lt;/LinearLayout&gt; ②在res文件夹下新建一个xml文件夹，然后在里面添加一个xml文件appwidgetprovider_info.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android" android:initialLayout="@layout/appwidget_layout" //指定布局，这个是最重要的 android:minHeight="72dp" //最小高度 android:minWidth="294dp" //最小宽度 android:updatePeriodMillis="86400000" &gt; //刷新时间 &lt;/appwidget-provider&gt; ③新建一个类继承AppWidgetProvider，重写几个重要的方法 package com.example.d_appwidget; import android.appwidget.AppWidgetManager; import android.appwidget.AppWidgetProvider; import android.content.Context; import android.content.Intent; public class AppWidget extends AppWidgetProvider { @Override public void onEnabled(Context context) { //首次添加AppWidget // TODO Auto-generated method stub super.onEnabled(context); System.out.println("---&gt; onEnabled"); } @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, //更新AppWidget int[] appWidgetIds) { // TODO Auto-generated method stub super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c6a194339b457bdc063289c70cb06c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7ef8f271e0b811069c2f5ae7939554/" rel="bookmark">
			图片切切切~~~ 图片热点，局部超链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;map name="mymap"&gt; &lt;area href="http://taoquan.taobao.com/coupon/unify_apply.htm?sellerId=1645894057&amp;activityId=141088961" shape="rect" coords="500,20,775,125"&gt;//区域坐标 &lt;area href="http://taoquan.taobao.com/coupon/unify_apply.htm?sellerId=1645894057&amp;activityId=141084924" shape="rect" coords="825,20,1100,125"&gt;//区域坐标 &lt;area href="http://taoquan.taobao.com/coupon/unify_apply.htm?sellerId=1645894057&amp;activityId=141050956" shape="rect" coords="1125,20,1420,125"&gt;//区域坐标 &lt;/map&gt; &lt;img src="http://img03.taobaocdn.com/imgextra/i3/1645894057/TB2ITT1aXXXXXb2XXXXXXXXXXXX_!!1645894057.jpg" usemap="#mymap"&gt;//图片地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e9c415d2f977973036df9c566789b6/" rel="bookmark">
			24段魔尺，可以折出哪些精美图案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 24段魔尺，可以折出哪些精美图案 24段魔尺，究竟可以叠成哪些精美图案？ 球、小乌龟、十字架、三叶花、三角形、牛魔王、音符是大家比较熟悉的。 偶对这个问题，比较感兴趣。先将网络上流传的24段魔尺折出的精美图案，进行展示。 小小24段魔尺，真是变化万千。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d40a317c3daad89fda71aa31831c8b2/" rel="bookmark">
			2014年24段魔尺变三叶花视频教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2014年24段魔尺变三叶花视频教程（升级版）
偶是真心喜欢24段魔尺制作的三叶花，那是相当漂亮，体现了几何美，对称美，空间美，色彩美，见下图。
三叶花，又叫三叶草，或者魔尺心。
偶学习和熟练掌握24段魔尺快速玩三叶花，也花费了点时间。
更多魔尺信息，敬请关注魔尺世界网站：www.wanmochi.com
height="498" width="510" src="http://player.youku.com/embed/XNzg1NjgxNTk2" frameborder="0" allowfullscreen=""&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be87c052d4c8d5711d1264621b6e26ed/" rel="bookmark">
			android 上层log 打印 到内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include android/system/core/init/log.h
ERROR("xxxxxxxxxxx '%s'\n", name);
在 system/core/init/init.c 中打印log ，在open_devnull_stdio();后面的ERROR（“XXX”）；
打印不出来，注掉，就好 了。
实际上，就是往"/dev/__kmsg__" 写字符串 ，即__log_buf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0320c7decb738092f1c623630dd976af/" rel="bookmark">
			printf函数实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C中的可变参数研究 一． 何谓可变参数 int printf( const char* format, ...); 这是使用过C语言的人所再熟悉不过的printf函数原型，它的参数中就有固定参数format和可变参数（用”…”表示）. 而我们又可以用各种方式来调用printf,如: printf( "%d ",value); printf( "%s ",str); printf( "the number is %d ,string is:%s ", value, str); 二.实现原理 C语言用宏来处理这些可变参数。这些宏看起来很复杂，其实原理挺简单，就是根据参数入栈的特点从最靠近第一个可变参数的固定参数开始，依次获取每个可变参 数的地址。下面我们来分析这些宏。在VC中的stdarg.h头文件中，针对不同平台有不同的宏定义，我们选取X86平台下的宏定义： typedef char *va_list ; #define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) ) #define va_start(ap,v)( ap = (va_list)&amp;v + _INTSIZEOF(v) ) #define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) ) #define va_end(ap) ( ap = (va_list)0 ) 以下再用图来表示: 在VC 等绝大多数C编译器中，默认情况下，参数进栈的顺序是由右向左的，因此，参数进栈以后的内存模型如下图所示：最后一个固定参数的地址位于第一个可变 参数之下，并且是连续存储的。 |——————————————————————————| |最后一个可变参数 | -&gt; 高内存地址处 |——————————————————————————| .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0320c7decb738092f1c623630dd976af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d21d3a4682bfcbfdb60d6c507d6ed6/" rel="bookmark">
			[2009国家集训队]小Z的袜子--莫队算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命…… 具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。 你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。
Input 输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。
Output 包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例）
Sample Input 6 4 1 2 3 3 3 2 2 6 1 3 3 5 1 6 Sample Output 2/5 0/1 1/1 4/15 【样例解释】 询问1：共C(5,2)=10种可能，其中抽出两个2有1种可能，抽出两个3有3种可能，概率为(1+3)/10=4/10=2/5。 询问2：共C(3,2)=3种可能，无法抽到颜色相同的袜子，概率为0/3=0/1。 询问3：共C(3,2)=3种可能，均为抽出两个3，概率为3/3=1/1。 注：上述C(a, b)表示组合数，组合数C(a, b)等价于在a个不同的物品中选取b个的选取方案数。 【数据规模和约定】 30%的数据中 N,M ≤ 5000； 60%的数据中 N,M ≤ 25000； 100%的数据中 N,M ≤ 50000，1 ≤ L &lt; R ≤ N，Ci ≤ N。 思路:先建曼哈顿最小生成树，然后DFS，注意回溯部分。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; using namespace std; #define maxn 400005 #define LL long long int LL Ans1[maxn],Ans2[maxn]; int Cnt[maxn],key[maxn],S[maxn],T[maxn],nxt[maxn],vis[maxn],vv[maxn],first[maxn]; int lowbit(int x) { return x &amp; (-x); } struct Point { int x,y,id; bool operator &lt; (const Point p)const { return x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d21d3a4682bfcbfdb60d6c507d6ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0fde699c2b1204c495cdd9fbc3c5375/" rel="bookmark">
			dirent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://baike.baidu.com/view/3680174.htm?fr=aladdin dirent，LINUX系统下的一个头文件，在这个目录下/usr/include，为了获取某文件夹目录内容，所使用的 结构体。 目录 1Linux下c语言编程所引用
2结构体说明
▪ 相关函数 ▪ 使用实例 1Linux下c语言编程所引用编辑 LINUX系统下的一个头文件,在这个目录下/usr/include 为了获取某文件夹目录内容，所使用的 结构体。 引用头文件#include&lt;dirent.h&gt; 2结构体说明编辑 struct dirent { long d_ino; /* inode number 索引节点号 */ off_t d_off; /* offset to this dirent 在目录文件中的偏移 */ unsigned short d_reclen; /* length of this d_name 文件名长 */ unsigned char d_type; /* the type of d_name 文件类型 */ char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长256字符 */ } 相关函数 opendir()，readdir(),closedir(); 使用实例 #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0fde699c2b1204c495cdd9fbc3c5375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1ad3dd17f4fdcdaa926c1b136738e7/" rel="bookmark">
			ARP表  MAC表  路由表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARP表是一个动态表，存储在计算机当中，目的是做一个ip地址与mac地址的对应。
假设在同一子网段，计算机A与计算机B通信
计算机A的ip地址192.168.0.1 MAC地址AA-AA-AA-AA-AA-AA
计算机B的ip地址已知192.168.0.2 MAC地址未知
那么计算机A就要发起一个ARP查询，“谁能告诉我，192.168.0.2的MAC地址是多少？”
很显然通过交换机的时候，交换机并不能看懂ip地址，所以要广播这个信息，就把这个查询信息发到除发送端的其它所有端口。(当然，交换机还要记住192.168.0.1主机的mac地址）
其它所有的计算机看到这个广播发现目的ip不是自己，就把这个数据丢弃，只有192..168.0.2的计算机B会响应，并发送回执，告诉计算机A，“我是192.168.0.2，我的MAC地址是AA-AA-AA-AA-AA-AB”当通过交换机，交换机记住从计算机B端口过来的MAC地址，并通过已知的A计算机MAC地址，发动到连接计算机A的端口。（此时不再广播）计算机A与计算机B都知道对方的ip和MAC地址，开始通信。
我相信有些人已经知道答案了。
三层交换机肯定是有arp表的，这个毋庸置疑，因为有路由功能嘛，牵扯到ip，那肯定是有的，可能大家对2层是否有，有点疑问，一般来说2层是没有的，所谓arp是地址解析协议，而地址指的是ip解析成mac，可2层跟ip没关啊，所以一般来说是没的，但当我们配置了管理vlan时，比如int vlan 1 ，然后ip add ······，这是用来管理的，这时就产生了arp表
什么叫ARP表啊！什么叫MAC地址表啊！
你们搞清楚没有啊！二层交换有MAC地址表，没有ARP表。ARP表里面有IP地址，二层设备不会有IP地址的。所以二层交换机不会有ARP表。有MAC表。一定要搞清楚。
谈论学术的一定要严谨啊！定义一定要清楚，不然很难说清楚啊！
三层交换机肯定是有arp表的，这个毋庸置疑，因为有路由功能嘛，牵扯到ip，那肯定是有的，可能大家对2层是否有，有点疑问，一般来说2层是没有的，所谓arp是地址解析协议，而地址指的是ip解析成mac，可2层跟ip没关啊，所以一般来说是没的，但当 ... [/quote]非常赞同，二层交换机有个管理vlan，默认是关闭的，如果开启之后，就有了arp表项了。
arp 是地址解析协议，实现通过IP地直得知MAC地址。
工作原理的话，我就不都说了，上面的兄弟们解释得非常清楚了。
在每台安装有[url=/view/7649.htm][color=#0000ff]TCP/IP协议[/color][/url]的电脑里都有一个ARP缓存表，表里的IP地址与[url=/view/69334.htm][color=#0000ff]MAC地址[/color][/url]是一一对应的。
我们可以在命令提示符下输入：arp -a 查看本机电脑arp 缓存表。
详细参数的话，可以？试看。
arp缓存并不长久存在，ARP缓存表采用了老化机制（即设置了生存时间TTL），在一段时间内（一般15到20分钟）如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。
层二设备的只有 PORT---MAC表
当一个层二交换机启动的时候，它会自动去侦测那些联系到自己端口上的 机器的MAC地址的.从而形成了一个PORT--MAC这样一个对应表
层三设备才有 arp表~
简单来说，ARP这个协议谁也说不准，它是个3层协议但是工作在2层，交换机确切的说是有MAC地址表，当主机要经过2层设备访问的话，先查找它内部的ARP缓存表，如果没有，就发一个广播包，里面携带目的的IP地址，如果对应IP地址的主机看到有人叫它的时候，它才给以回应，发送回包，包里面有本机的MAC地址，这样被交换机放入MAC表中，关于20楼兄弟说的SVI那是一个特例。。。严格意义上来说不是ARP表，ARP这个协议谁也说不好是具体2层的还是3层的，具体说就是2层靠MAC表转发，由于TCP协议是需要ACK的，所以也能导致一些ARP欺骗的问题
要弄明白二三转发原理和流程，必须弄清楚ARP表、交换机转发表和路由表，这是数据转发的依据。由于ARP表和交换机转发表对于管理员来说是透明的，一般很忽视其工作原理，这是我需要注意的学习地方。所以今天主要是弄明白ARP表、交换机转发表、路由表。　数据最终转发依靠的都是ARP表，他是数据转发最基础的依据。ARP直接将硬件地址和网络地址相互映射。
数据最终转发依靠的虽然不是路由表，但路由表是一个向导，指引着数据的走向，让数据能跨越网络，ARP表是没有掩码的，是不区分网段的。　转载于:https://www.cnblogs.com/lianjiehere/p/3945059.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9266836aa71824ef39ba35e489a62a/" rel="bookmark">
			Sqlite常用语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础
1、说明：创建数据库
CREATE DATABASE database-name
2、说明：删除数据库
drop database dbname
3、说明：备份sql server
--- 创建 备份数据的 device
USE master
EXEC sp_addumpdevice 'disk', 'testBack', 'c:\mssql7backup\MyNwind_1.dat'
--- 开始 备份
BACKUP DATABASE pubs TO testBack
4、说明：创建新表
create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)
根据已有的表创建新表：
A：create table tab_new like tab_old (使用旧表创建新表)
B：create table tab_new as select col1,col2… from tab_old definition only
5、说明：删除新表
drop table tabname
6、说明：增加一个列
Alter table tabname add column col type
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c9266836aa71824ef39ba35e489a62a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95508b0af57dd2c44277bf712b4d0f41/" rel="bookmark">
			dts改单流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 提单&gt;测试经理审核&gt;开发人员定位修改&gt;审核人员审核修改&gt;CMO归档&gt;测试经理组织测试&gt;测试人员回归测试
转载于:https://my.oschina.net/hebeijpp/blog/299910
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989769d43e4a182649842b1de58d3f66/" rel="bookmark">
			遥感技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自百度百科。
遥感技术是从远距离感知目标反射或自身辐射的电磁波、可见光、红外线结目标进行探测和识别的技术。例如航空摄影就是一种遥感技术。人造地球卫星发射成功,大大推动了遥感技术的发展。现代遥感技术主要包括信息的获取、传输、存储和处理等环节。完成上述功能的全套系统称为遥感系统,其核心组成部分是获取信息的遥感器。遥感器的种类很多,主要有照相机、电视摄像机、多光谱扫描仪、成象光谱仪、微波辐射计、合成孔径雷达等。传输设备用于将遥感信息从远距离平台(如卫星)传回地面站。信息处理设备包括彩色合成仪、图象判读仪和数字图象处理机等。 遥感技术广泛用于军事侦察、导弹预警、军事测绘、海洋监视、气象观测和互剂侦检等。在民用方面,遥感技术广泛用于地球资源普查、植被分类、土地利用规划、农作物病虫害和作物产量调查、环境污染监测、海洋研制、地震监测等方面。遥感技术总的发展趋势是：提高遥感器的分辨率和综合利用信息的能力,研制先进遥感器、信息传输和处理设备以实现遥感系统全天候工作和实时获取信息,以及增强遥感系统的抗干扰能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d0e2ca1fd433253ac91df7c06067f36/" rel="bookmark">
			oracle Constraint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		约束简介
约束用于确保数据库数据满足特定的商业逻辑或者企业规则，如果定义了约束，并且数据不符
合约束，那么DML操作（INSERT、UPDATE、DELETE）将不能成功执行。约束包括NOT NULL、UNIQUE、PRIMARY KEY、FOREING KEY 以及CHECK等五种类型
定义约束
列级约束：
column [CONSTRAINT constraint_name] constraint_type
表级约束：
column ,...,
[CONSTRAINT constraint_name] constraint_type (column,...)
1.定义NOT NULL约束
NOT NULL 约束只能在列级定义，不能在表级定义
例：
CREATE TABLE emp01(
eno INT NOT NULL,
name VARCHAR2(10) CONSTRAINT nn_name2 NOT NULL,
salary NUMBER(6,2)
);
上例中，eno列与name列上定义了NOT NULL约束，其中eno列的NOT NULL约束没有指定约束名，而
name列则指定了约束名nn_name。
可以通过查询user_constraints字典来查看所定义的约束，如：
SQL&gt; select constraint_name,constraint_type from user_constraints
2 where table_name='EMP01';
CONSTRAINT_NAME CO
------------------------------------------------------------ --
SYS_C0010618 C
NN_NAME C
可见，没有给约束名的，系统将会自动的定义一个约束名称，其中约束类型中，P:表示主键，R:
表示外键，C表示NOT NULL或CHECK，U表示UNIQUE。且系统中同一方案下的的约束名不能重复
2.定义UNIQUE约束
定义了惟一约束之后，惟一约束列的列值不能重复，但可以为NULL。UNIQUE约束既可以在列级
定义，也可以在表级定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d0e2ca1fd433253ac91df7c06067f36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8062dcc6d3604b4d2b988ae9519049/" rel="bookmark">
			hadoop Shell命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用文件系统(FS)Shell命令应使用bin/hadoop fs &lt;args&gt;的形式。所有的的FS shell命令使用URI路径作为参数。
1、cat
说明：将路径指定文件的内容输出到stdout。
用法：hadoop fs -cat URI [URI …]
范例：
hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2
hadoop fs -cat file:///file3/user/hadoop/file4
返回值：成功返回0，失败返回-1。
2、chgrp
说明：改变文件所属的组。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。
用法：hadoop fs -chgrp [-R] GROUP URI [URI …]
范例：hadoop fs -chgrp -R hadoop /user/hadoop/
3、chmod
说明：改变文件的权限。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。
用法：hadoop fs -chmod [-R] URI [URI …]
范例：hadoop fs -chmod -R 744 /user/hadoop/
4、chown
说明：改变文件的拥有者。使用-R将使改变在目录结构下递归进行。命令的使用者必须是超级用户。
用法：hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]
范例：hadoop fs -chmod -R hadoop /user/hadoop/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8062dcc6d3604b4d2b988ae9519049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8e94e1cb4e183394ce1c00b534b44d/" rel="bookmark">
			C语言函数fopen，fclose的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自http://blog.sina.com.cn/s/blog_60059a210101277j.html 函数简介 函数功能： 打开一个文件
函数原型：FILE * fopen(const char * path,const char * mode);
相关函数：open，fclose，fopen_s[1]﻿ ，_wfopen
所需库： &lt;stdio.h&gt;
返回值： 文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回NULL，并把错误代码存在errno 中。
一般而言，打开文件后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以在fopen()后请作错误判断及处理。
参数说明：
参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。
mode有下列几种形态字符串:
r 打开只读文件，该文件必须存在。
r+ 打开可读写的文件，该文件必须存在。
rb+ 读写打开一个二进制文件，只允许读写数据。
rt+ 读写打开一个文本文件，允许读和写。
w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）
a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）
wb 只写打开或新建一个二进制文件；只允许写数据。
wb+ 读写打开或建立一个二进制文件，允许读和写。
wt+ 读写打开或着建立一个文本文件；允许读写。
at+ 读写打开一个文本文件，允许读或在文本末追加数据。
ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。
上述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask 值。
有些C编译系统可能不完全提供所有这些功能，有的C版本不用"r+","w+","a+",而用"rw","wr","ar"等，读者注意所用系统的规定。
表格 1. fopen() 中的 mode 的可能值列表
mode
说明
'r'
只读方式打开，将文件指针指向文件头。
'r+'
读写方式打开，将文件指针指向文件头。
'w'
写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8e94e1cb4e183394ce1c00b534b44d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a332b54013e01389f8a6acc40f0aa65/" rel="bookmark">
			ajax请求获取响应的StatusCode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用jQuery的complete(xhr,ts)函数句柄，其中ts是jQuery定义的success、error等字符串；
获取http请求的状态码是从xhr的status得到，响应的内容从xhr的responseText得到；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/281dcb1f25ed8679616706a2d3d05521/" rel="bookmark">
			JS学习笔记之左边列表移到到右边列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现功能：1.左边的下拉框内容添加到右边的下拉框，支持多选移动，且同时将右边的下拉框对象移除；2.支持列表中项目上下位置的移动；3.效果图如下：
Html代码 &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt; Select Demo &lt;/TITLE&gt; &lt;META NAME="Generator" CONTENT="EditPlus"&gt; &lt;META NAME="Author" CONTENT=""&gt; &lt;META NAME="Keywords" CONTENT=""&gt; &lt;META NAME="Description" CONTENT=""&gt; &lt;/HEAD&gt; &lt;style&gt; center { font-size:12px; color:red; font-weight:bold; } select { font-size:12px; color:green; } &lt;/style&gt; &lt;BODY&gt; &lt;span id='feedback'&gt;&lt;/span&gt; &lt;form method="post" name="myform"&gt; &lt;table border="0" width="400"&gt; &lt;tr&gt; &lt;td&gt;&lt;CENTER&gt;可选择排序方式&lt;/CENTER&gt;&lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt;&lt;CENTER&gt;已选择排序方式&lt;/CENTER&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width="40%"&gt; &lt;select multiple name="left" id="left" size="8" style='width:200;' ondblclick="moveOption(document.getElementById('left'), document.getElementById('right'))"&gt; &lt;option value="20"&gt;测试数据一&lt;/option&gt; &lt;option value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/281dcb1f25ed8679616706a2d3d05521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e61cf4e702cc6a414a999ca4d766e3e/" rel="bookmark">
			ie js实现打开另存为对话框，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js： var userAgent = navigator.userAgent, isIE = /msie/i.test(userAgent) &amp;&amp; !window.opera, isWebKit = /webkit/i.test(userAgent), isFirefox = /firefox/i.test(userAgent); var url = jQuery("#xuwanting")[0].src; if(isIE){ n==0?new function(){frames("savelocals").location=url,n=1}:null; document.all("savelocals").readyState!="complete"?setTimeout(savelocal,100):so(); function so(){frames("savelocals").document.execCommand("SaveAs"),n=0}; } jsp： &lt;iframe src="" name="savelocals" id="savelocals" style="width:0;height:0"&gt;&lt;/iframe&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d631063fcd57216b0b1375ecb6273f60/" rel="bookmark">
			R语言游戏之旅 游戏2048
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R的极客理想系列文章，涵盖了R的思想，使用，工具，创新等的一系列要点，以我个人的学习和体验去诠释R的强大。 R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。 要成为有理想的极客，我们不能停留在语法上，要掌握牢固的数学，概率，统计知识，同时还要有创新精神，把R语言发挥到各个领域。让我们一起动起来吧，开始R的极客理想。 关于作者：
张丹(Conan), 程序员Java,R,PHP,Javascriptweibo：@Conan_Zblog: http://blog.fens.meemail: bsspirit@gmail.com 转载请注明出处：
http://blog.fens.me/r-game-2048/
前言
150行代码写出游戏2048，哪种语言能实现？答案是R语言。虽然R语言并不适合做游戏开发，但是R语言中的向量计算，能极大地简化矩阵算法代码实现的复杂度，可以高效的完成计算任务。如果我们把游戏问题变成数学问题，那么R就是绝佳的工具。
目录
2048游戏介绍场景设计程序设计R语言实现 1. 2048游戏介绍 2048是一款单人在线和移动端游戏，由19岁的意大利人Gabriele Cirulli于2014年3月开发。游戏任务是在一个网格上滑动小方块来进行组合，直到形成一个带有有数字2048的方块，它是滑块类游戏的一种电脑变体。作者开发这个游戏是为了测试自己是否有能力从零开始创造一款游戏，但游戏飙升的人气（不到1周内有400万访客）完全出乎他的预料。事实上，它已被称为网络上「最上瘾的东西」，华尔街日报将其评价为「属于数学极客的 Candy Crush」。
该游戏为开源软件，这导致它衍生出许多改进版和变种，包括积分排行榜和提升的触屏可玩性等。2048是基于HTML5的Javascript应用，源代码的地址：https://github.com/gabrielecirulli/2048，免费的在线版本：http://gabrielecirulli.github.io/2048/。当然本文中R语言的程序现实，完全是我的想法，与游戏作者的JS源代码无关。
游戏玩法
该游戏使用方向键让方块上下左右移动。如果两个带有相同数字的方块在移动中碰撞，则它们会合并为一个数字，为两者之和。每次移动时，会有一个值为2或者4的新方块出现。当值为2048的方块出现时，游戏即胜利，该游戏因此得名。
2. 场景设计 接下来，就回了游戏设计环节，如同上篇文章 R语言游戏之旅 贪食蛇入门 一样。要开发这款游戏，我们应该如何动手呢？我们需要从软件开发的角度，对这款游戏进行需求分析，列出游戏的规则，并设计业务流程，给出游戏的原型，验证是否可行。
2.1 需求分析
2048游戏，应该有3个场景：开机场景，游戏场景，结束场景。
开机场景：运行程序，在游戏前，给用户做准备，并提示如何操作游戏。游戏场景：游戏运行中的场景。结束场景：当用户胜利、失败或退出时的场景，并提示用户在游戏中的得分。 开机场景和结束场景比较简单，不再解释。游戏场景，包括一块4*4的画布，画面中每个格子对应一个数字，数字大于0的格子有背景颜色填充。
2.2 游戏规则
游戏进行时的规则：
1. 开始游戏后，用户可以通过上(up)下(down)左(left)右(right)键，来控制数字的移动。2. 如果两个相同的数字在移动中碰撞，则它们会合并为一个方块，且所带数字变为两者之和。3. 每次移动时，会有一个值为2或者4的新数字出现。4. 当用户按键操作，数字的顺序未发生变化时，则不会生成新数字，视为无效的按键操作。5. 当画布格子被数字填满时，而在上下左边方向，无可合并的数字时，则游戏失败。 2.3 业务流程
场景切换的流程：
打开程序时，用户首先看到开机场景，按任意键后进入游戏场景。在游戏场景，当游戏失败，进入结束场景；按q键，则直接游戏失败。在结束场景，按空格回到开机场景；按q键，则直接能出软件。 业务流程，同贪食蛇游戏的业务流程。
2.4 游戏原型
我们画出3个场景的界面。左边为开机场景，中间是游戏场景，右边是结束场景。
我们根据游戏原型的图，用程序画出游戏的场景。
3. 程序设计 通过上面的功能需求分析，我们已经非常清楚地了解 2048游戏 的各种规则和功能。接下来，我们要把需求分析中的业务语言，通过技术语言重新描述，并考虑非功能需求，以及R语言相关的技术细节。
3.1 游戏场景
我们让每个场景对应于一块画布，及每个场景对应一个内存结构。
开机场景，是静态的，我们可以提前生成好这块画布存储起来，也可以当用户切换时再临时生成，性能开销不大。游戏场景，是动态的，每进行一次用户的交互行为或按时间刷新时，都需要求重新绘制画布，让游戏场景通过绑定事件来生成画布。结束场景，是动态的，在结束场景会显示当次游戏的得分，需要在切换时临时生成。 3.2 游戏对象
在游戏进行中，会产生很多的对象，如上文中提到的。这些对象都需要在内存中进行定义，匹配到对应程序语言的数据类型。
比起贪食蛇游戏，2048游戏要简单的多，我只需要定义一个画布对象就行了。
画布对象：用矩阵来描述。画布中的数字：用矩阵中的数字值来表示。画布的背景色：用矩阵中的数字值来表示。 通过矩阵来描述游戏画布和对象：
矩阵结构：
[,1] [,2] [,3] [,4] [1,] 4 32 4 32 [2,] 32 16 2 4 [3,] 4 2 8 2 [4,] 2 8 2 0 对应该的游戏画布：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d631063fcd57216b0b1375ecb6273f60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3932a4752455656822946c1c54192507/" rel="bookmark">
			java.lang.NoClassDefFoundError: org/hibernate/service/jta/platform/spi/JtaPlatform
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用spring3.2.9与hibernate4.3.5集成，结果报错
ERROR: HHH000302: Unable to construct current session context [org.springframework.orm.hibernate4.SpringSessionContext] java.lang.reflect.InvocationTargetException at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:526) at org.hibernate.internal.SessionFactoryImpl.buildCurrentSessionContext(SessionFactoryImpl.java:1513) at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:532) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1857) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1928) at org.springframework.orm.hibernate4.LocalSessionFactoryBuilder.buildSessionFactory(LocalSessionFactoryBuilder.java:252) at org.springframework.orm.hibernate4.LocalSessionFactoryBean.buildSessionFactory(LocalSessionFactoryBean.java:377) at org.springframework.orm.hibernate4.LocalSessionFactoryBean.afterPropertiesSet(LocalSessionFactoryBean.java:362) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1571) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1509) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:521) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:458) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:296) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:223) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:293) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:328) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:108) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1417) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1158) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:458) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:296) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:223) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:293) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3932a4752455656822946c1c54192507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae1bb688c2a5d5cf8456737ba3ef1e6/" rel="bookmark">
			作业调度框架 Quartz 学习笔记(三) -- Cron表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面两篇说的是简单的触发器(SimpleTrigger) , SimpleTrigger 只能处理简单的事件出发,如果想灵活的进行任务的触发,就要请出
CronTrigger 这个重要人物了.
CronTrigger也是Quartz最重要的特色之一，通过Quartz特有的Cron表达式来确定某类时间，能完成类似"2011年11月11号(神棍节,已经过去了)，每个星期三XXX"之类的复杂定时任务。 代码还是老套路 , 两个类 : SimpleJob.java 和 CronTriggerExample.java
建议先跑代码 ,看结果 ,然后再 看代码
SimpleJob.java
[java] view plain copy print ? import java.text.SimpleDateFormat; import java.util.Calendar; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; public class SimpleJob implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { // job 的名字 String jobName = context.getJobDetail().getKey().getName(); // 任务执行的时间 SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ae1bb688c2a5d5cf8456737ba3ef1e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4fcb811eb3bf816a8cddee3675dfef/" rel="bookmark">
			double ：数据类型保留两位小数，不足补0，满10进1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 double ：数据类型保留两位小数，不足补0，满10进1&lt;span style="white-space:pre"&gt;	&lt;/span&gt; &lt;span style="white-space:pre"&gt;	&lt;/span&gt;double d = 12.2289; java.text.DecimalFormat df = new java.text.DecimalFormat("#.00"); System.out.println(df.format(d)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/920b94148356d0f8a23878cdafd4fcee/" rel="bookmark">
			Java 下划线分隔的字符串，转换为驼峰式字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一（首选）：
public static void main(String[] args) { String destStr = "part_vote_num"; Pattern p = Pattern.compile("_[a-z]"); Matcher m = p.matcher(destStr); StringBuffer sb = new StringBuffer(); while (m.find()) { String firstChar = m.group().substring(1, 2); m.appendReplacement(sb, firstChar.toUpperCase()); } m.appendTail(sb); System.out.println(sb.toString()); } 方法二：
public static void main(String[] args) { String destStr = "part_vote_num"; StringBuilder sb = new StringBuilder(); boolean low = true; for (int i = 0; i &lt; destStr.length(); i++) { if (destStr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/920b94148356d0f8a23878cdafd4fcee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0872419e2b0b13c965f415b458cb5926/" rel="bookmark">
			Linux进入单用户模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单用户模式介绍：
1.1 单用户模式
Linux的运行级别1允许管理官通过服务器主机的单一控制台进行操作，即“单用户模式”。
1.2 单用户模式下的网络
单用户模式已经停止了任何网络服务和网络配置，不会有其他任何人（通过网络）干扰系统的运行状态。
使用ifconfig查看：
二、进入单用户模式
以RedHat系统，GRUB为例进行说明。
有3种方式进入单用户模式。
2.1 进入启动时菜单界面
1. 在Linux启动时，出现以下界面：
2. 按任意键进入启动菜单界面，如下：
2.2 方法一：使用"a"操作进入单用户模式：操作简单（推荐）
1.按下“a”键，编辑kernel参数，在行末输入single，回车即可。
2.3 方法二：使用"e"操作进入单用户模式
1. 按下“e”键进入启动菜单单向界面，移动光标至“kernel”配置项一行。
2. 按下“e”键，编辑“kernel”菜单项，在行末输入single。
3. 按下“b”键使用更改后的启动菜单项，启动单用户模式。
2.4 方法三：使用"c"操作进入单用户模式
1. 按下“c”键进入GRUB命令行界面。
2. 分别使用GRUB下的root、kernel（在行末输入single）、initrd命令指定启动参数。
3. 最后使用boot命令启动到单用户模式。
root、kernel、initrd命令的完整参数是：
root (hd0,0)
kernel /vmlinuz-2.6.32-279.el6.x86_64 ro root=UUID=0155c310-ff7a-4621-98df-fae3f9792f73 rd_NO_LUKS rd_NO_LVM crashkernel=auto selinux=0 rd_NO_MD SYSFONT=latarcyrheb-sun16 KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM LANG=en_US.UTF-8 rhgb quiet
initrd /initramfs-2.6.32-279.el6.x86_64.img
每个系统不一样，如果不知道参数的话，可以在linux中查看：vim /etc/grub.conf 。
参考资料：
CentOS进入单用户模式：http://dusiguxia.blog.163.com/blog/static/556293162010101483711469/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76958786515bb12ed48bb59907d6f961/" rel="bookmark">
			js 实现鼠标按下 拖动div
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;/pre&gt;&lt;pre name="code" class="javascript"&gt;	//div 拖动 div的ID container.onmousedown = function() { //获取鼠标当前坐标 var pageX = event.clientX; var pageY = event.clientY; //获取block的坐标，左边界和上边界 var offX = parseInt(this.style.left) || 0; var offY = parseInt(this.style.top) || 0; //计算出鼠标坐标相对于block坐标的间距 var offLX = pageX - offX; var offLY = pageY - offY; if (!document.onmousemove) { document.onmousemove = function() { container.style.left = event.clientX - offLX; //设置block的X坐标 container.style.top = event.clientY - offLY; //设置block的Y坐标 } } } document.onmouseup = function() { document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76958786515bb12ed48bb59907d6f961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9b8baa782feec213d867699e27900a/" rel="bookmark">
			JS实现拖动div改变大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .upBtn,.downBtn,.upLeftBtn,.upRightBtn,.downLeftBtn,.downRightBtn,.centerLeftBtn,.centerRightBtn { position:absolute; background:#CC0000; width:9px; height:9px; z-index:5; } .upBtn { top:-4px; left:50%; cursor:n-resize; } .downBtn { bottom:-4px; left:50%; cursor:s-resize; } .upLeftBtn { top:-4px; left:-4px; cursor:nw-resize; } .upRightBtn { top:-4px; right:-4px; cursor:ne-resize; } .downLeftBtn { bottom:-4px; left:-4px; cursor:sw-resize; } .downRightBtn { bottom:-4px; right:-4px; cursor:se-resize; } .centerLeftBtn { top:50%; left:-4px; cursor:w-resize; } .centerRightBtn { top:50%; right:-4px; cursor:e-resize; } &lt;/style&gt; &lt;script type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9b8baa782feec213d867699e27900a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c046f83ceda67ae383da2a63bec25fcd/" rel="bookmark">
			日志文件自动压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 log4j 记录日志，每天0点进行分隔，由于日志文件较大，为节省空间，需要将历史文件自动压缩。需要使用 Apache Extras™ for Apache log4j™ 的 org.apache.log4j.rolling.TimeBasedRollingPolicy 类进行配置。配置如下： &lt;?xml version="1.0" encoding="windows-1252"?&gt; &lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt; &lt;log4j:configuration&gt; &lt;!-- Daily Rolling File Appender that compresses old files --&gt; &lt;appender name="file" class="org.apache.log4j.rolling.RollingFileAppender" &gt; &lt;param name="threshold" value="info"/&gt; &lt;rollingPolicy name="file" class="org.apache.log4j.rolling.TimeBasedRollingPolicy"&gt; &lt;param name="FileNamePattern" value="${catalina.base}/logs/myapp.log.%d{yyyy-MM-dd}.gz"/&gt; &lt;param name="ActiveFileName" value="${catalina.base}/logs/myapp.log"/&gt; &lt;/rollingPolicy&gt; &lt;layout class="org.apache.log4j.EnhancedPatternLayout" &gt; &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p - %-26.26c{1} - %m%n" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;priority value="debug"&gt;&lt;/priority&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt;另外 logback 有许多优点，用它来实现压缩的配置如下： &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c046f83ceda67ae383da2a63bec25fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67618734cd2ad7a97c50a4ee0784b7e8/" rel="bookmark">
			Java调用命令行并获取执行结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.io.BufferedReader; import java.io.InputStreamReader; public class Command { public static void exeCmd(String commandStr) { BufferedReader br = null; try { Process p = Runtime.getRuntime().exec(commandStr); br = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) { sb.append(line + "\n"); } System.out.println(sb.toString()); } catch (Exception e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67618734cd2ad7a97c50a4ee0784b7e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1edf3028f4a06aa40caf869f883e21/" rel="bookmark">
			LoadRunner设置检查点的方法有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然现在我自己还看不懂，但是觉得貌似不错啊，先留着
正文：
前段时间在群里跟大家讨论一个关于性能测试的问题，谈到如何评估测试结果，有一个朋友谈到规范问题，让我颇有感触，他说他们公司每次执行压力测试的时候，都要求脚本中必须有检查点存在，不然测试结果将不被认可，这是他们公司的规范。其实，在做压力测试过程，我们很容易忽略很多东西，而且随着自身的技术演变，我们很容易去丢失掉一些很好的习惯，当我们再碰到这些问题的时候，我们才发现其实是我们太粗心大意了，所以说好的习惯要保持。这次我刚好也要接手一些性能工作，因此就如何规范设置检查点来谈谈一些基本的流程和方法。　使用LoadRunner做压力测试，大致如下几个流程：
1、明确测试目标
2、录制测试脚本
3、脚本优化、调试
4、场景运行
5、分析测试结果
当然这里都是概况性的标题，但从这里我们可以明确的是测试脚本是整个压力测试过程中的重点步骤，如果测试脚本都不能确保正确与否，后面的测试过程就无从说起了。很多时候我们把脚本调试就简单的认为是脚本回放没有错误就认为脚本是没有问题的，这当然不能这么肯定，脚本调试是一个非常严谨的过程，我大致归纳如下几步：
1、明确每一行脚本的作用，也就是说每一行脚本执行的功能是什么；
2、删减不需要的脚本语句，比如在录制过程由于LR默认设置导致录制之后出现很多冗余的脚本，这些个脚本对我们的测试过程没有用途的应该删除掉，至于哪些是冗余就要具体分析了，所以说脚本录制完之后要分析脚本运行的过程，方能理解脚本执行的用途，不然在后面施压时运行错误，就会开始到处找问题，而又找不出问题；
3、查找存在的关联并进行相关设置
4、设置检查点，设置检查点的目的就是为了验证页面每次运行之后是否正确，设置检查点的过程总要通过不能的回放来进行验证检查点设置是否正确。
5、通过测试目标明确脚本执行的目标事务，并添加事务；
6、对需要进行并打操作的功能设置集合点
7、根据实际情况设置ThinkTime
8、在以上所有脚本调试步骤完成之后，设置迭代次数，通过在Vuser中设置多次迭代来验证脚本在多次循环运行时是否存在错误
注意：在Vuser中运行和回放脚本的过程，要密切关注replay log，也就是回放日志，很多问题通常都暴露在回放日志中，只不过我们没有认真去检查，所以没发觉。因为大多数情况是我们在回放脚本之后只观察回放日志中有没有红色的错误提示信息，如果没有我们就认为我们的脚本是ok的，其实不然，很多时候一些隐藏的错误就在回放日志中可以被发现，比如回放日志中的Warning信息，也就是警告信息，这些信息一旦你不去理会它，它将在场景运行过程中开始频繁暴露出来，而在场景中报错之后我们就认为可能是系统有问题或者是测试过程存在其他问题等等，而很难去考虑到是脚本的问题，是脚本在Vuser中调试就存在的问题。还有的时候一些问题在一次脚本回放中就不能被发现，他需要通过Vuser中设置多次迭代才能在回放日志暴露出问题来，所以说我们通常的思维就是一旦测试脚本没有一次回放没有出现错误，就去场景中运行，结果在场景中哪怕是运行10个用户都还会报错，这就是问题的根源所在。
下面还是重点说说检查点吧，三种常用的文本检查web_reg_find的方法：
1、 将脚本切换到树结构，在page view页面上找到你要check的文本内容， 并执行鼠标右键，选择Add a text check.
2、 通过Vuesr界面去设置检查点，如图所示：
3、将脚本切换回代码界面， 在光标闪烁的上行，添加如下的代码：　添加的代码根据你检查的方式不同而不同， 你可以选择其中之一即可。
代码一：
web_reg_find("Text=Payment Details",LAST);
注：“Payment Details” 为你要检查的文本；
脚本执行到此处，若在页面上找到了这几个字符串，那脚本继续执行下去；若没有找到，脚本将在此报错并且结束。
代码二：
web_reg_find("Text=Payment Details", "SaveCount=para_count", LAST); //check 的函数
这里是要运行的页面脚本
if (atoi(lr_eval_string("{para_count}"))&gt;0) //验证是否找到了页面上的要检查的字符串
lr_output_message("Pass!");
else
lr_output_message("Failed!");
注意：
“Payment Details” 为你要检查的文本；
脚本执行到此处，不管页面上是否存在你要检查的字符串，脚本都不会报错，而是执行下去。
此段代码将找到的你要检查的字符串的个数，存为一个参数。 然后在页面代码的后面，通过检查这个参数的值是否大于0，来判断是否找到了你所要检查的字符串。
注意：这里的测试结果均以200状态码返回，其失败的结果将在分析报告中进行分类标识。
代码三：
web_reg_find("Text=Payment Detdils", "Fail=NotFound",LAST);或者
web_reg_find("Text=Payment Detdils", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c1edf3028f4a06aa40caf869f883e21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b49fa275e3c382e8faffc9befc5f2107/" rel="bookmark">
			uboot中gd的定义和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做uboot中nand启动相关的工作，遇到一个问题一直纠结着。现在终于明白了这个问题，想想还有好多兄弟在某个黑暗的角落里或者某台电脑前纠结着呢，所以赶紧写下来以供查阅。
uboot version 2014.4
/* Architecture-specific global data */
struct arch_global_data {
#if defined(CONFIG_FSL_ESDHC)
u32 sdhc_clk;
#endif
#ifdef CONFIG_AT91FAMILY
/* "static data" needed by at91's clock.c */
unsigned long cpu_clk_rate_hz;
unsigned long main_clk_rate_hz;
unsigned long mck_rate_hz;
unsigned long plla_rate_hz;
unsigned long pllb_rate_hz;
unsigned long at91_pllb_usb_init;
#endif
/* "static data" needed by most of timer.c on ARM platforms */
unsigned long timer_rate_hz;
unsigned long tbu;
unsigned long tbl;
unsigned long lastinc;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b49fa275e3c382e8faffc9befc5f2107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8f71f22cc4838b20c3375a480469fa/" rel="bookmark">
			Linux查看环境变量当前信息和查看命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文 From: http://os.51cto.com/art/201005/202463.htm
系统的环境变量在配置web server以及编写程序都常常被用到, 因此了解必要的关于系统变量的知识是非常有必要的，下面关于linux系统变量的查看以及方法。
在Windows下，查看环境变量的命令是：set，这个命令会输出系统当前的环境变量。
Linux下Linux查看环境变量准确的说是REDHAT下应该如何查看呢，命令是：export如果你想查看某一个名称的环境变量，命令是：echo $环境变量名，比如：echo $ORACLE_HOMEWindows对应的命令是：set 环境变量名。
外补一篇:
1. Linux查看环境变量显示环境变量HOME$ echo $HOME/home/redbooks
2. Linux查看环境变量设置一个新的环境变量hello$ export HELLO=”Hello!”$ echo $HELLOHello!
3. Linux查看环境变量使用env命令显示所有的环境变量$ envHOSTNAME=redbooks.safe.orgPVM_RSH=/usr/bin/rshSHELL=/bin/bashTERM=xtermHISTSIZE=1000…
4. Linux查看环境变量使用set命令显示所有本地定义的Shell变量$ setBASH=/bin/bashBASH_VERSINFO=([0]=”2″[1]=”05b”[2]=”0″[3]=”1″[4]=”release”[5]=”i386-redhat-Linux-gnu”)BASH_VERSION=’2.05b.0(1)-release’COLORS=/etc/DIR_COLORS.xtermCOLUMNS=80DIRSTACK=()DISPLAY=:0.0…
5. Linux查看环境变量使用unset命令来清除环境变量set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。示例如下：$ export TEST=”Test…” #增加一个环境变量TEST$ env|grep TEST #此命令有输入，证明环境变量TEST已经存在了TEST=Test…$ unset $TEST #删除环境变量TEST$ env|grep TEST #此命令没有输出，证明环境变量TEST已经存在了
6. Linux查看环境变量使用readonly命令设置只读变量如果使用了readonly命令的话，变量就不可以被修改或清除了。示例如下：$ export TEST=”Test…” #增加一个环境变量TEST$ readonly TEST #将环境变量TEST设为只读$ unset TEST #会发现此变量不能被删除-bash: unset: TEST: cannot unset: readonly variable$ TEST=”New” #会发现此也变量不能被修改-bash: TEST: readonly variable
环境变量的设置位于/etc/profile文件
------------------------------------------------------------------------------------
Form: http://songyishan.iteye.com/blog/1008419
$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。 编辑你的 PATH 声明，其格式为： PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt; 你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：$ source .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8f71f22cc4838b20c3375a480469fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73cc79b4cd7dd2349910c4885452daff/" rel="bookmark">
			4、freemarker程序开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、程序开发入门
1.1 创建配置实例
首先，你应该创建一个freemarker.template.Configuration的实例，然后调整它的设置。Configuration实例是存储FreeMarker应用级设置的核心部分。同时，它也处理创建和缓存预解析模板的工作。也许你只在应用（可能是servlet）生命周期的开始执行它一次：
Configuration cfg = new Configuration();
// 指定模板文件从何处加载的数据源，这里设置成一个文件目录。
cfg.setDirectoryForTemplateLoading(
new File("/where/you/store/templates"));
// 指定模板如何检索数据模型，这是一个高级的主题了…
// 但先可以这么来用：
cfg.setObjectWrapper(new DefaultObjectWrapper());
从现在开始，应该使用单实例配置。要注意不管一个系统有多少独立的组件来使用FreeMarker，它们都会使用他们自己私有的Configuration实例。
1.2 创建数据模型
在简单的示例中你可以使用java.lang和java.util包下的类，还有用户自定义的Java Bean来构建数据对象。
 使用java.lang.String来构建字符串。
 使用java.lang.Number来派生数字类型。
 使用java.lang.Boolean来构建布尔值。
 使用java.util.List或Java数组来构建序列。
 使用java.util.Map来构建哈希表。
 使用你自己定义的bean类来构建哈希表，bean中的项和bean的属性对应。例如product中的price属性可以用product.price来获取
构建数据模型的java代码
// 创建根哈希表
Map root = new HashMap();
// 在根中放入字符串"user"
root.put("user", "Big Joe");
// 为"latestProduct"创建哈希表
Map latest = new HashMap();
// 将它添加到根哈希表中
root.put("latestProduct", latest);
// 在latest中放置"url"和"name"
latest.put("url", "products/greenmouse.html");
latest.put("name", "green mouse");
对于latestProduct你也可以使用有url和name属性的Java Bean（也就是说，对象要有公共的String getURL()和String getName()方法）；它和模板的观点相同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73cc79b4cd7dd2349910c4885452daff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a2ec0be8bc45e330f99bc77941dd13/" rel="bookmark">
			linux下 查看 php源代码放在哪个目录底下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下 查看 php源代码放在哪个目录底下
查看配置文件: /etc/httpd/conf/httdp.conf
php源代码放在: DocumentRoot "/var/www/html"
php端口为: ServerName localhost:80 如下图所示:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda5f6d3980d6c832146214f5ed579f7/" rel="bookmark">
			输入流 转换为字节数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //将输入流 转换为字节数组InputStream is=connection.getInputStream(); byte[] buffer=new byte[1024]; int len=0; ByteArrayOutputStream bos=new ByteArrayOutputStream(); while((len=is.read(buffer))!=-1){ bos.write(buffer,0,len); } bos.flush(); return bos.toByteArray();/**这里可以直接将字节数组new成字符窜*///Bitmap类可以直接将byte数组转换成一张图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df88abb17cd6f26069dee4047bd74c8/" rel="bookmark">
			随机任务在云计算平台中能耗的优化管理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将介绍文章“随机任务在云计算平台中能耗的优化管理方法”。
原文链接：http://pan.baidu.com/s/1jGp5mBG
参考文献：Min-Min算法和Max-Min算法
摘要 背景 针对云计算系统在运行过程中由于计算节点空闲而产生大量空闲能耗，以及由于不匹配任务调度而产生大量“奢侈”能耗的能耗浪费问题，本文提出一种通过任务调度方式的能耗优化管理方法。
高能耗是云计算系统最为严重的问题之一云计算系统中，除了处理任务时产生的必要能耗开销，其运行过程中还存在能耗浪费的现象 解决方案 用排队模型对云计算系统进行建模，分析云计算系统的平均响应时间和平均功率，建立云计算系统的能耗模型；提出基于大服务强度和小执行能耗的任务调度策略，分别针对空闲能耗和“奢侈”能耗进行优化控制。基于该调度策略，设计满足性能约束的最小期望执行能耗调度算法ME3PC (minimum expectation execution energy with performance constraints). 结果 大量实验表明，本文提出的能耗优化管理方法在保证其性能的前提下，大幅度降低了云计算系统的能耗
下一步工作 将研究在给定和真实的云计算系统体系结构下，如何根据任务到达率的大小和分布规律，决策系统中应该处于运行状态的计算机个数，结合关闭/休眠技术和电压动态调整技术，进一步对云计算系统的能耗进行优化控制，并且将研究的理论成果在实际云平台上进行评测，以验证其正确性
能耗 能耗分类 空闲能耗：由于计算任务达到的随机性，使得单位时间内到达的任务量时而稀疏，时而密集，而现有的云计算系统通常是长时间处于开启状态，等待计算任务的到达。但是当计算机处于空闲状态时，其空闲功率会占峰值功率的50%~60%。因此，云计算系统会产生大量的空闲能耗。奢侈能耗：由于云计算系统中通常包含不同的计算机，实验结果表明，不同计算机对不同计算任务的执行功率和响应时间一般不同。例如，同一图像处理任务分别在CPU 和GPU 上的执行功率和响应时间不同，任务执行完成后，产生的总能耗也不同。因此，当未考虑能耗因素时，不匹配的调度方式会造成:本来用较低能耗就能解决问题，但却用了较高能耗。本文把由于任务的不合理调度而浪费的能耗称为“奢侈”能耗。执行能耗：执行能耗可定义为：任务在计算机上运行时，指令和数据驱动计算机硬件运转所产生的能耗 传统节能的方法 关闭/休眠技术：最大限度的降低空闲能耗，缺点是当使用计算机时需要较长的启动时间，导致系统性能一定程度的下降电压动态调整技术：为了便于研究，本文假定执行功率为任务整个执行过程的平均耗电功率。根据CMOS 电路动态功率公式Pdynamic~αCV2f 可知，动态功率与电压的平方成正比。因此，降低处理器的电压可以降低处理器的动态功率。但该方法的缺点是，随着电压的下降，处理器的性能会随之下降虚拟化技术：可实现多个任务在一个计算机的不同虚拟机上运行，通过提高计算机资源利用率，以减少所需计算机数量的方式降低能耗。虚拟化技术实现了计算机资源从物理实体向虚拟实体的迁移，提高了计算机资源的利用率。但虚拟化，特别是深层次的虚拟化本身也要付出高昂的效能代价，因为虚拟化技术通过对底层硬件部件到高层服务应用的层层虚拟，每一级的虚拟都造成了效能的损失。 任务和系统模型 随机任务模型 根据任务对计算机资源的需求特征，可分为计算密集型、通信密集型、数据密集型和I/O密集型等。随机到达云计算系统的任务可以用三元组（T，Λ，W）表示，第i类任务可以表示为(ti，λi，wi)。ti表示第i类任务，λi表示ti任务单位时间平均到达数量，wi表示ti任务的计算量 云计算系统模型 现有云计算平台的硬件基础设施通常是架构在大规模廉价服务器集群之上，系统中的不同服务器或计算机通常是由不同公司生产，有不同的硬件配置。这些计算机不仅有不同的功能和性能，其耗电的功率也不同，具体可表现为：功能异构、性能异构、空闲功率和峰值功率异构、执行功率异构；云计算系统可以定义为六元组：(C，Pbusym×n，Pidle，Ppeak，Um×n，S) 云计算系统和能耗分析 调度模型 云计算系统任务调度的过程可描述为：不同类型任务以不同的速率随机到达系统，调度器则根据任务类型、任务到达时机、系统中所有计算机当前的执行状态等信息对任务进行合理映射，最后调度执行
目的是降低系统运行过程中产生的空闲能耗和执行能耗
本文暂不考虑云计算系统中与通信相关的能耗和时间开销
问题描述 根据2.1节和2.2节的分析，并结合能耗的计算公式E=P*T，则任意一个任务从进入云计算系统到执行完成离开所产生的期望能耗可表示为
在给定任务类型、确定云计算系统体系结构的条件下，只有调度概率P ij 的值是根据调度策略的不同而动态变化的，云计算系统的期望能耗与任务和计算机之间的调度策略有关 能耗优化管理 实质 根据任务的到达时间和类型、不同计算机的功率和性能、计算机实时的负载情况，对任务进行合理调度，使系统在满足一定性能的条件下，降低云计算系统运行过程中产生的空闲和执行能耗 假设 根据任务对计算机资源的需求特征，可分为计算密集型、通信密集型、数据密集型和I/O密集型等。不同类型任务要处理的数据形式和问题规模一般不同。为了便于研究，本文假定同一类型任务的计算量相同由于用户服务请求的自主性、地域的分布性，导致不同用户提交的任务之间通常没有优先约束关系，即任务是独立的假设对于系统中的每个计算机，任务的到达间隔相互独立,且服从同一参数的负指数分布每个计算机对不同任务的服务时间也相互独立，且服从同一参数的负指数分布到达间隔时间与服务时间相互独立不同类计算任务以不同的概率调度到不同的计算机上 性能约束的最小期望执行能耗调度算法ME3PC(minimum expectation execution energy with performance constraints) 调度器针对不同的情况，采用不同的调度策略，详情请参考第3章
根据负载情况，将节点分在三个队列：Clight、Cnormal、Chigh，如果Clight不为空，则优先考虑集合Clight中的计算机，并采用基于大服务强度的任务调度策略，使对tCi类任务有大服务强度的计算机cCj有较大的调度概率，其中j∈ClightClight为空，Cnormal不为空，采用基于较小执行能耗的调度策略,使对tCi类任务有较小执行能耗的计算机cCj有较大的调度概率，其中j∈CnormalClight、Cnormal为空，Cnormal不为空，即所有计算机都处于重载状态。这样，在任务调度时，把任务调度到负载最小的计算机上 定理满足性能约束的最小执行能耗调度算法ME3PC的最坏时间复杂度为O(3mn)，其中，m为任务的类型数，n为云计算系统中计算机的个数。
实验 实验环境的设置 为了验证ME3PC算法的有效性，本文使用Matlab 的离散事件模拟工具进行模拟实验。实验环境涉及的相关参数以及取值或取值范围见下表。
实验中任务分为4 类。第i类任务的到达间隔时间服从参数为1/λi的负指数分布。该间隔时间可通过负指数分布函数exprnd(1/λi)来生成，其中，λi的值在[10，15]区间随机生成。根据任务的到达间隔，利用函数cumsum(⋅)可得到第i 类每个随机任务到达系统的时刻。最终可确定所有6000个任务到达系统的时刻。计算机cj对ti类任务的服务时间服从参数为1/μij的负指数分布，同样，服务时间也通过函数exprnd(1/μij)来生成，参数μij的值在[1，5]区间随机生成
为了让模拟系统的运行存在平衡状态，需要满足条件
实验与结果分析 为了进一步说明ME3PC算法的有效性，本文又设计了最小执行功率调度算法(minimum execution power，简称MEP)，并将ME3PC与MEP、经典MIN-MIN 算法进行比较。其中，MEP的算法思想是:在任务调度时，将任务调度到执行功率最小的机器上，而不考虑该计算机当前的负载情况以及执行该任务的服务时间。MIN-MIN是针对独立任务的动态调度算法，广泛应用于同构或异构分布式并行计算环境，有良好的调度性能。本文分别从系统执行任务的平均能耗、任务的平均响应时间、系统的平均功率、负载平衡和可扩展性这5个方面对3种算法进行对比分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df88abb17cd6f26069dee4047bd74c8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/270/">«</a>
	<span class="pagination__item pagination__item--current">271/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/272/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>