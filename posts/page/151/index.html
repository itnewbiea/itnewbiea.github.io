<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13541839c4f024d8e290e6a0f2658765/" rel="bookmark">
			vue中安装使用jquery
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 npm install jquery --save安装依赖文件
然后在 自己的vue.config,js文件中 进行加载 (要是没有就自己新加一个，在最外层)
将jquery导入进去
module.exports = { chainWebpack: config =&gt; { config.plugin('provide').use(webpack.ProvidePlugin, [{ $: 'jquery', jquery: 'jquery', jQuery: 'jquery', 'window.jQuery': 'jquery' }]) } } 然后在你需要的地方
import $ from 'jquery'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a094a87ccaec34c1ea4618e118d7447/" rel="bookmark">
			golang初级进阶（一）：顺序排序、冒泡算法、sort排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、排序算法
1. 顺序排序
2. 冒泡排序
二、sort排序
1. sort升序
2. sort降序
一、排序算法 1. 顺序排序 package main import "fmt" func main() { slice1 := []int{3, 11, 32, 1, 4} //顺序排序：由大到小 =&gt; 从第一个一直比到最后一个 for i := 0; i &lt; len(slice1); i++ { for j := i + 1; j &lt; len(slice1); j++ { if slice1[j] &gt; slice1[i] { temp := slice1[i] slice1[i] = slice1[j] slice1[j] = temp } } } fmt.Println(slice1) // [32 11 4 3 1] } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a094a87ccaec34c1ea4618e118d7447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1de47e2f966e240a28835fb144f4085/" rel="bookmark">
			OpenWrt21 EC20 R2.0驱动添加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、OpenWrt21内核版本为5.4，EC20R2.0的VID、PID为0x2C7C, 0x0125，可以使用qmi拨号或者ppp拨号 2、内核修改 1、修改USB串口驱动 File : [KERNEL]/drivers/usb/serial/option.c
static const struct usb_device_id option_ids[] = { #if 1 //Added by Quectel { USB_DEVICE(0x05C6, 0x9090) }, /* Quectel UC15 */ { USB_DEVICE(0x05C6, 0x9003) }, /* Quectel UC20 */ { USB_DEVICE(0x05C6, 0x9215) }, /* Quectel EC20 */ { USB_DEVICE(0x2C7C, 0x0125) }, /* Quectel EC25/EC20 R2.0 */ { USB_DEVICE(0x2C7C, 0x0121) }, /* Quectel EC21 */ #endif 2.1、添加零包处理 File:[KERNEL]/drivers/usb/serial/usb_wwan.c
static struct urb*usb_wwan_setup_urb(struct usb_serial *serial, int endpoint, int dir, void *ctx, char *buf, int len,void(*callback) (struct urb *)) { …… #if 1 //Added by Quectelfor Zero Packet if (dir == USB_DIR_OUT) { struct usb_device_descriptor*desc = &amp;serial-&gt;dev-&gt;descriptor; if (desc-&gt;idVendor ==cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9090)) urb-&gt;transfer_flags|= URB_ZERO_PACKET; if (desc-&gt;idVendor ==cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9003)) urb-&gt;transfer_flags|= URB_ZERO_PACKET; if (desc-&gt;idVendor ==cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9215)) urb-&gt;transfer_flags|= URB_ZERO_PACKET; if (desc-&gt;idVendor ==cpu_to_le16(0x2C7C)) urb-&gt;transfer_flags|= URB_ZERO_PACKET; } #endif return urb; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1de47e2f966e240a28835fb144f4085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d24b6ac7c7685ce36e78c95cdcb4a7/" rel="bookmark">
			Java Web 03 (页面跳转&amp;JDBC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日思维导图：
一、页面跳转方式（两种） 1、重定向 response : response.sendRedirect("success.jsp");
2、请求 request : request.getRequestDispatcher("success.jsp").forward(request, response);
两者之间的关系：
两者之间的区别：
//页面跳转方式 //1、重定向语法response ①能够将页面跳转，并且地址栏发生转变,但是不能将值传递到下一个页面 ③能够跳转到任意资源 //在客户端发挥作用 //response.sendRedirect("success.jsp"); //2.、转发 request ②能够将页面跳转，地址栏不发生改变，但是能将值传递到下一个值 ④只能跳转到当前页面 //在服务器端发生作用 //request.getRequestDispatcher("success.jsp").forward(request, response); 二、JDBC（连接数据库Oraacle） 主界面效果图展示如下：
代码展示如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt; 注册界面&lt;/h2&gt; &lt;form action="dologin.jsp" method="post"&gt; ID：&lt;input type="text" name="iid"&gt;&lt;br&gt; 用户名：&lt;input type="text" name="iname"&gt;&lt;br&gt; 密码：&lt;input type="password" name="ipwd"&gt;&lt;br&gt; 性别：&lt;input type="radio" name="isex" value="男"&gt;男 &lt;input type="radio" name="isex" value="女"&gt;女&lt;br&gt; 爱好：&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d24b6ac7c7685ce36e78c95cdcb4a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37621fbffac9475dffb01c72713fc3b7/" rel="bookmark">
			gdb 调试 RISC-V
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优秀的产品需要有高效的调试手段，RISC-V的工具链中提供GDB。 使得切换到RISCV后，底软和内核工程师的工作效率不受损害。
我们使用一个有趣的程序来尝试gdb调试的效果。源文件 rot13.c 和 链接描述文件spike.lds如下
rot13.c 中，通过变量wait的值，控制程序进入不同阶段:
阶段1: 程序因为 0 == wait, 停留在一个死循环里面。在后面的gdb调试中，我们可以看到通过修改变量wait的值，控制程序进入下一个阶段。
阶段2: 程序执行简单的“解密”运算，将初始化的“密文”解析为“明文”。在gdb中，我们将看到RISC-V demo 作者想告诉我们的信息。
阶段3: 程序结束。
/* file name: rot13.c */ char text[] = "Vafgehpgvba frgf jnag gb or serr!"; // Don't use the stack, because sp isn't set up. volatile int wait = 1; int main() { while (wait) ; // Doesn't actually go on the stack, because there are lots of GPRs. int i = 0; while (text[i]) { char lower = text[i] | 32; if (lower &gt;= 'a' &amp;&amp; lower &lt;= 'm') text[i] += 13; else if (lower &gt; 'm' &amp;&amp; lower &lt;= 'z') text[i] -= 13; i++; } done: while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37621fbffac9475dffb01c72713fc3b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee6121a46e7e19410f13c60a48ef223/" rel="bookmark">
			C语言字符加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一行字符(不多于60个字符，以回车结束)，将其加密。
加密规则：1）将小写字母转换为相应的大写字母；2）将大写字母转换为相应的小写字母；3）非字母字符不变；4）字母顺序后延3个字符，且x-&gt;a，y-&gt;b，z-&gt;c；5）数字字符顺序后延5个符号。
输入：一行字符(不多于60个字符，以回车结束)
输出：一行字符，为加密后的字符。
思路：输入利用getchar，while循环设置换行符结束输出。
用循环遍历数组讨论不同情况
本题核心：掌握字符的ASCII码，getchar函数，数据类型转换，数组初级运用
#include&lt;stdio.h&gt; int main(){ char ch; char a[60]; int i,cnt=0; do{ ch=getchar(); a[cnt++]=ch; }while(ch!='\n');//输入字符 for(i=0;i&lt;cnt;i++){ if(a[i]&lt;=87&amp;&amp;a[i]&gt;=65)//大写字母转小写然后加3 a[i]=a[i]+35; else if(a[i]&gt;=97&amp;&amp;a[i]&lt;=119)//小写字母转大写加3 a[i]=a[i]-29; else if(a[i]&gt;119&amp;&amp;a[i]&lt;=122)//xyz转大写再变ABC a[i]=a[i]-55; else if(a[i]&gt;=88&amp;&amp;a[i]&lt;=90)//XYZ转abc a[i]=a[i]+9;	if(48&lt;=a[i]&amp;&amp;a[i]&lt;=57){//讨论数字情况 if(a[i]&lt;53) a[i]=a[i]+5;//数字延后5 else if(a[i]&gt;=53)// 讨论5到9的情况 a[i]=a[i]-5;	} printf("%c",a[i]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d86503008db526bc1bc0f2d9897d31a/" rel="bookmark">
			OPCUA客户端Application配置与连接服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、OPCUA客户端初始化二、与服务端建立连接1、登录2、建立连接 前言 OPC全称是OLE（Object Linking and Embedding） for Process Control。为了便于自动化行业不同厂家的设备和应用程序能相互交换数据，定义了一个统一的接口函数，就是OPC协议规范。OPC是基于WINDOWS COM/DOM的技术，可以使用统一的方式去访问不同设备厂商的产品数据。简单来说OPC就是为了用于设备和软件之间交换数据。
UA全称是unified architecture（统一架构）。为了应对标准化和跨平台的趋势，为了更好地推广OPC，OPC基金会近些年在之前OPC成功应用的基础上推出了一个新的OPC标准-OPC UA。OPC UA接口协议包含了之前的 A&amp;E, DA,OPC XML DA or HDA，只使用一个地址空间就能访问之前所有的对象，而且不受WINDOWS平台限制，因为它是从传输层以上来定义的，导致了灵活性和安全性比之前的OPC都提升了。
OPC UA实质上是一种抽象的框架，是一个多层架构，其中的每一层完全是从其相邻层抽象而来。这些层定义了线路上的各种通信协议，以及能否安全地编码/解码包含有数据、数据类型定义等内容的讯息。利用这一核心服务和数据类型框架，人们可以在其基础上（继承）轻松添加更多功能。
OPC UA将成为一个转换工具。其它协议/标准（如BACnet）可以非常轻松地转换为OPC UA内的一个子集。
提示：以下是本篇文章正文内容，下面案例可供参考
一、OPCUA客户端初始化 在工程项目里引用OPCUA相关库，如下图所示：
OPCUA客户端初始化构建 ApplicationInstance和 ApplicationConfiguration，代码示例如下：
#region Private Fields private ApplicationInstance application; //进程 private ApplicationConfiguration m_configuration; //配置信息 private Session m_session; private bool m_IsConnected; //是否已经连接过 private int m_reconnectPeriod = 10; // 重连状态 private bool m_useSecurity; private EndpointDescription endpointDescription; private SessionReconnectHandler m_reconnectHandler; private EventHandler m_ReconnectComplete; private EventHandler m_ReconnectStarting; private EventHandler m_KeepAliveComplete; private EventHandler&lt;string[]&gt; m_ConnectComplete; private EventHandler&lt;OpcUaStatusEventArgs&gt; m_OpcStatusChange; private Dictionary&lt;string, Subscription&gt; dic_subscriptions; // 订阅的节点信息 #endregion /// &lt;summary&gt; /// 默认构造 /// &lt;/summary&gt; public OPCUAClient() { dic_subscriptions = new Dictionary&lt;string, Subscription&gt;(); var certificateValidator = new CertificateValidator(); certificateValidator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d86503008db526bc1bc0f2d9897d31a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b5c4610208e1133fcdd02244f97a2b/" rel="bookmark">
			ROS2_Foxy学习10——多机激光SLAM准备篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2_Foxy学习10——多机激光SLAM准备篇 1 安装Ubuntu20.04 mate2 安装ROS noetic3 安装cartographer4 详细配置cartographer5 安装RPLidar A16 测试建图6.1 配置cartographer6.2 配置RPLidar A16.3 运行测试 7 安装ROS foxy8 安装ros1_bridge8.1 安装8.2 使用与测试 9 镜像备份与恢复 为了实现多机激光SLAM，在上一篇文章《ROS2_Foxy学习9——多机激光SLAM先导篇》中讨论了开源激光SLAM（Cartographer）在ROS2.0中运行的可行性。最后得出的小结是各开源激光SLAM算法对ROS2.0的适配还在进行中（2021年初），暂无法在ROS2.0上运行，因此决定曲线救国，在ROS1.0上跑SLAM，然后通过ros1_bridge这个功能包将产生的地图、车辆位姿、点云等信息上传到DDS，然后由PC端的ROS2程序处理（地图合并等工作）。基于上述情况，在车载的树莓派上安装了两个ROS（16G的SD卡是搞不定的，最少32G）。
odk，下面介绍在树莓派上部署Ubuntu 20.04mate、ROS noetic、ROS foxy、cartographer、rplidar等的过程，由于内容较多，有些部分会直接给出之前写过的一些博文而不再重复记录。
下一篇博文将介绍地图融合相关的内容。
1 安装Ubuntu20.04 mate 参考：树莓派4B——Ubuntu20.04 mate
包括：系统ubuntu20.04 mate，wiringpi库，网络与串口工具，远程，开机启动等。
2 安装ROS noetic 官方教程
配置仓库，即勾选"restricted," “universe,” and “multiverse.”
Setup your sources.list
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list' Set up your keys sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 Installation sudo apt update sudo apt install ros-noetic-desktop 有不同的桌面版本，基于树莓派选择 ros-noetic-desktop
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64b5c4610208e1133fcdd02244f97a2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0a4f79399ffe59ee5f485665b35c7a/" rel="bookmark">
			ResourceNotFound：gazebo_ros
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当将机器人加载到gazebo时，运行launch文件出现如下错误
这是由于缺少gazebo包所导致的。
解决办法：
sudo apt install ros-kinetic-gazebo-ros-pkgs 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69813c8cfe1e56e5d82a69dc280fb584/" rel="bookmark">
			【Python自动化Excel】Python与pandas字符串操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python之所以能够成为流行的数据分析语言，有一部分原因在于其简洁易用的字符串处理能力。
Python的字符串对象封装了很多开箱即用的内置方法，处理单个字符串时十分方便；对于Excel、csv等表格文件中整列的批量字符串操作，pandas库也提供了简洁高效的处理函数，几乎与内置字符串函数一一对应。也就是说：
单个字符串处理，用Python内置的字符串方法；
表格整列的字符串处理，用pandas库中的字符串函数；
本文就以常用的数据处理需求，来对比使用以上两种方式的异同，从而加深对 Python 和 pandas 字符串操作的理解。（本文所有数据都是为了演示用的假数据，切勿当真！）
)
一、替换（去除空格） 场景：在问卷收集的姓名字段中，不少填写者会误输入空格，造成数据匹配不一致的问题。
Python names = '刘 备、关 羽、 张 飞、赵 云、马 超、黄 忠' names = names.replace(' ','') print(names) output
刘备、关羽、张飞、赵云、马超、黄忠 pandas df['姓名'] = df['姓名'].str.replace(' ','') output
pandas替换空格
二、分列 场景：在问卷收集数据的时候，多选题的数据往往是带有分隔符的。在分类汇总前往往需要按分隔符进行分列。
问卷中多选数据导出
Python hobbyStr = "足球┋排球┋羽毛球┋篮球" hobbyList = hobbyStr.split('┋') output
['足球', '排球', '羽毛球', '篮球'] pandas # 利用split进行分列，expand = True 返回dataframe；expand=False返回Series hobbyDf = df['爱好'].str.split('|', expand=True) # 将hobbyDf 与 df安装索引合并 df2 = pd.merge(df, hobbyDf, how="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69813c8cfe1e56e5d82a69dc280fb584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736e4b04970e997a76f0574a6d5b2428/" rel="bookmark">
			Matplotlib 散点图 绘制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基础点的大小点的颜色透明度颜色条多组散点 1 散点图 - 基础 代码 import matplotlib.pyplot as plt import numpy as np # 第一组散点 x = np.array([1, 2, 3, 4, 5, 6, 7, 8]) y = np.array([1, 4, 9, 16, 7, 11, 23, 18]) plt.scatter(x, y) # x 代表x轴 y 代表y轴数据, 数据维度必须相同 plt.show() 图像 2 散点图 - 点的大小 代码 import matplotlib.pyplot as plt import numpy as np # 第一组散点 x = np.array([1, 2, 3, 4, 5, 6, 7, 8]) y = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736e4b04970e997a76f0574a6d5b2428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b21c60b29761ad2f4dc1f14ab3948a/" rel="bookmark">
			运动规划学习笔记5——ROS包_tf2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运动规划学习笔记5——ROS包_tf2 1、坐标系2、坐标变换2.1、坐标变换2.2、广播坐标变换2.3、监听坐标转换 3、问题/usr/bin/env: “python”: 没有那个文件或目录TypeError: cannot use a string pattern on a bytes-like object 在这里分享了运动规划方面的一些基本的算法原理和伪代码实现，其中内容可能存在不完善和错误之处，如有读者发现，欢迎批评指正。
1、坐标系 一个机器人拥有多个坐标系，这些坐标系在tf2中构成坐标树，tf2通过坐标树维护多个坐标系之间的坐标变换。ROS坐标系为右手坐标系，前X、左Y、上Z。两坐标系之间关系用6自由度相对位姿表示，tf2中由tf2::Vector3和tf2::Quaternion表示。查看坐标树 # 方法一：view_frames工具 rosrun tf view_frames # 方法二：rqt rosrun rqt_tf_tree rqt_tf_tree # ros2 sudo apt install ros-foxy-tf2-tools ros2 run tf2_tools view_frames.py 查看坐标转换关系 # 变换关系 rosrun tf tf_echo /world /turtle1 查看坐标转换时间延迟 # 时间延迟 rosrun tf tf_monitor /world /turtle1 2、坐标变换 2.1、坐标变换 坐标变换库：tf2_ros，http://docs.ros.org/en/jade/api/tf2_ros/html/c++/namespacetf2__ros.html。坐标转换消息类型：geometry_msgs/TransformStamped，包括父坐标系、子坐标系、转换关系 std_msgs/Header header uint32 seq time stamp string frame_id string child_frame_id geometry_msgs/Transform transform geometry_msgs/Vector3 translation float64 x float64 y float64 z geometry_msgs/Quaternion rotation float64 x float64 y float64 z float64 w 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b21c60b29761ad2f4dc1f14ab3948a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0de13a7a934c51fcc6de86ef7d25024/" rel="bookmark">
			Dockerfile 构建 Vue 镜像踩坑记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		▌背景
目前在公司维护的测试工具平台，有时候前端需要更新。改完前端 Vue 项目之后，还得在执行 npm run build 打包整个项目，再把打包好的整个项目拷贝过去后端项目中：这一步骤非常繁琐且不符合前后端分离的思想。为此考虑使用 Nginx 部署前端项目，后期可以配合 rancher 进行 CICD。
▌Dockerfile 详解
# 构建镜像基于onbuild_vue:v1镜像 FROM harbor.bluemoon.com.cn/lw/onbuild_vue:v1 AS builder #切换到/app工作目录下 WORKDIR /app # 复制package.json到app目录下 COPY package.json ./ # 执行npm命令 RUN npm config set registry https://registry.npm.taobao.org/ &amp;&amp; \ npm install # 复制当前目录下的所有文件到app目录下 COPY . ./ # 执行npm run build命令 RUN npm run build:prod # 构建镜像基于nginx:alpine镜像 FROM nginx:alpine # 声明端口80。仅声明作用，如果docker run -P 就会指定该端口 EXPOSE 80 # 从名为builder的阶段，复制打包好的文件到/usr/share/nginx/html/ COPY --from=builder /app/dist /usr/share/nginx/html/ # 删除原本的默认配置 RUN rm /etc/nginx/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0de13a7a934c51fcc6de86ef7d25024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e285f29782fcd896ac5a55570dd982/" rel="bookmark">
			SPARK SHUFFLE中 ShuffleId BlockManagerId 以及 与ESS（External Shuffle Server）交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 本文基于SPARK 3.2.1
用来更好的理解spark shuffle中的点点滴滴
分析 我们直接从SortShuffleManager着手，因为这是个shuffle的纽带： override def registerShuffle[K, V, C]( shuffleId: Int, dependency: ShuffleDependency[K, V, C]): ShuffleHandle { ... override def getReader[K, C]( handle: ShuffleHandle, startMapIndex: Int, endMapIndex: Int, startPartition: Int, endPartition: Int, context: TaskContext, metrics: ShuffleReadMetricsReporter): ShuffleReader[K, C] = { ... override def getWriter[K, V]( handle: ShuffleHandle, mapId: Long, context: TaskContext, metrics: ShuffleWriteMetricsReporter): ShuffleWriter[K, V] = { ... 跟shuffle紧密关联的是这三个方法，
其中registerShuffle方法是在ShuffleDependency实例构建出来的时候机会被调用: val shuffleId: Int = _rdd.context.newShuffleId() val shuffleHandle: ShuffleHandle = _rdd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e285f29782fcd896ac5a55570dd982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef0d62aca21a8019ff1f792ce420816/" rel="bookmark">
			Python打印2018年的日历（【问题描述】 打印2018年的日历 【输入形式】 【输出形式】 【样例输入】 【样例输出】）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
打印2018年的日历
【输入形式】
【输出形式】
【样例输入】
【样例输出】
1 January 2018
Mo Tu We Th Fr Sa Su
1 2 3 4 5 6 7
8 9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31
2 February 2018
Mo Tu We Th Fr Sa Su
1 2 3 4
5 6 7 8 9 10 11
12 13 14 15 16 17 18
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ef0d62aca21a8019ff1f792ce420816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702a0517aed076a145efe0aee1c9b292/" rel="bookmark">
			Python 分解质因数（编写函数实现：输入一个正整数n，把数字n分解成不能再分解因子的乘法，比如：8=2*2*2， 10 = 2*5，而不是 8 = 2 * 4 这种可以再分解的。）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【问题描述】
编写函数实现：输入一个正整数n，把数字n分解成不能再分解因子的乘法，比如：8=222， 10 = 2*5，而不是 8 = 2 * 4 这种可以再分解的。
【输入形式】
输入一个正整数n
【输出形式】
输出包含所有因子的列表
【样例输入】
12
【样例输出】
[2, 2, 3]
参考代码
8行足以
n = int(input()) m = [] # 定义一个列表用于存储分解得到的质因数 while n != 1: for i in range(2, n + 1): # 从最小的2开始尝试 while n % i == 0: # 如果有多个相同的质因数就会一直循环 m.append(i) # 将因数加入列表之中 n /= i print(m) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21b64e7588c641683ff6188880b70f1/" rel="bookmark">
			Intel Realsense D435i各类标定教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的实验中用到了realsense-D435i，为了提高精度使用之前必须要进行标定。本篇文章就介绍下各类标定方法。因为我最终的目的是完成IMU和双目的联合标定，整个流程都是围绕整个目的展开的。过程中包括：RGB标定、单目标定、IMU标定、双目标定、IMU-双目标定
标定使用了kalibr标定库，整篇参考了系列博客：路径规划_Nankel Li的博客-CSDN博客。具体的内容可以去看这个，但在实现中还是有所不同（特别是标黄色的注意部分）。在此做下记录希望能够帮助到各位。
第一步 环境配置： 参考：D435i标定摄像头和IMU笔记一（配置环境篇）_Nankel Li的博客-CSDN博客
注：最后一个命令改为：
kalibr_create_target_pdf --type checkerboard --nx 5 --ny 8 --csx 0.045 --csy 0.045 会在~/kalibr_workspace生成PDF文件，就是标定板文件
第二步，RGB标定 参考：D435i标定摄像头和IMU笔记二（RGB摄像头标定篇）_Nankel Li的博客-CSDN博客
注：rosbag包录制的时候要用到标定板文件，打开rviz，用摄像头对齐然后开始录制，录制一段时间之后，有成功的显示为止，在~/calib_data/camera_calib下生成三个文件
第三步：IMU标定 参考：D435i标定摄像头和IMU笔记三（IMU标定篇）_Nankel Li的博客-CSDN博客_d435i imu标定
选择的方法是：港科大imu_utils进行标定
注：ceres-solver安装教程参考：
在linux ubuntu18.04版本中安装ceres solver_YMWM_的博客-CSDN博客_linux安装ceres
注：执行launch文件,出现wait for imu data，再执行rosbag回放，再等待一下，会有结果。录制rosbag要至少两个小时，计算参数也要至少两个小时。这个录制rosbag可以不对齐标定板，静置录制环境即可。
第四步：进行双目标定 参考：D435i标定摄像头和IMU笔记二-2（RGB+双目多摄像头标定篇）_Nankel Li的博客-CSDN博客_d435是双目吗
注：原文中关闭结构光的步骤说的不是很明确，可以参考这篇：Realsense D435i关闭IR结构光_Hecttttttttt的博客-CSDN博客。需要注意下新版的界面现在是下面这样的(设置emitter_enabled为off(0)即可)：
注：如果只想要双目的话，可以不管那个color话题。采集rosbag数据时要对准标定板checkboard进行采集，否则会报错无法提取corners错误。采集角点时对齐的三个轴是下面这三个：
注：realsense默认双目是不开的，所以为了有infra1和infra2话题，要设置下rs_camera.launch。设置如下：
报错：
信息如下：
error:Cameras are not connected through mutual observations, please check the dataset. Maybe adjust the approx. sync. Tolerance 解决：https://blog.csdn.net/DarlingXXY/article/details/119563632
第五步：进行双目IMU联合标定 参考：D435i标定摄像头和IMU笔记四-2（双目摄像头与IMU联合标定篇）_Nankel Li的博客-CSDN博客
注：还是要对齐标定板录制rosbag文件
报错：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f21b64e7588c641683ff6188880b70f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c13ac036306183818d712aa9c0374f1/" rel="bookmark">
			ORB_SLAM2 代码分析及介绍（视觉VO及重定位，Tracking）第二部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 TrackMonocular中的核心步骤Frame中包含的信息畸变矫正UndistorKeyPoints和ComputeImageBounds对双目/RGB-D特征点的预处理双目特征点的处理ComputeSteroMatches深度计算公式原理 RGB特征点的处理ComputeStereoFromRGBD 特征点分配 单目相机的初始化MonocularInitialization初始化类中的初始化方法Initialize()计算基础矩阵F和单应矩阵HRANSAC算法卡方检验，以检测H矩阵为例 TrackMonocular中的核心步骤 我们在第一部分中给出了TrackMonocular函数，其中最重要的一步莫过于GrabImageMonocular，其代码如下所示：
cv::Mat Tracking::GrabImageMonocular(const cv::Mat &amp;im, const double &amp;timestamp) { mImGray = im; // 基于图像进行一些简单的处理 if(mImGray.channels()==3) { if(mbRGB) cvtColor(mImGray,mImGray,CV_RGB2GRAY); else cvtColor(mImGray,mImGray,CV_BGR2GRAY); } else if(mImGray.channels()==4) { if(mbRGB) cvtColor(mImGray,mImGray,CV_RGBA2GRAY); else cvtColor(mImGray,mImGray,CV_BGRA2GRAY); } // 看看有没有初始化完了 if(mState==NOT_INITIALIZED || mState==NO_IMAGES_YET) mCurrentFrame = Frame(mImGray,timestamp,mpIniORBextractor,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth); else mCurrentFrame = Frame(mImGray,timestamp,mpORBextractorLeft,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth); // 进入跟踪！ Track(); return mCurrentFrame.mTcw.clone(); } 接下来，我们进入Tracking过程：
void Tracking::Track() { if(mState==NO_IMAGES_YET) { mState = NOT_INITIALIZED; } mLastProcessedState=mState; // Get Map Mutex -&gt; Map cannot be changed unique_lock&lt;mutex&gt; lock(mpMap-&gt;mMutexMapUpdate); if(mState==NOT_INITIALIZED) { if(mSensor==System::STEREO || mSensor==System::RGBD) StereoInitialization(); else MonocularInitialization(); mpFrameDrawer-&gt;Update(this); if(mState!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c13ac036306183818d712aa9c0374f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49a07f9a43fbb3cee9a0b8a1bfcd30ce/" rel="bookmark">
			数据分析使用pydotplus可视化决策树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Step 1 ：下载graphvizStep 2：测试graphvizStep 3：安装pydotplus 使用Python进行数据分析过程中，需要可视化决策树模型：了解每个节点的决策是如何判断的，还有整个树的结构是如何？
下面是使用pydotplus库得到可视化的决策树图形。
个人的环境配置：
python 3.6anacoda 4win 7 64位 Step 1 ：下载graphviz 计算机安装graphviz:
Windows版本下载网址：https://graphviz.gitlab.io/_pages/Download/Download_windows.html
msi版本安装方便，不容易出错。
按照默认路径C:\Program Files (x86)安装，一直Next安装完成。
再将安装路径C:\Program Files (x86)\Graphviz2.38\bin添加到环境变量中：
Step 2：测试graphviz 测试graphviz是否安装成功：
如果没有安装成功，在程序中使用export_graphviz会继续出现报错：
InvocationException: GraphViz's executables not found
Step 3：安装pydotplus pip install pyplotplus 安装好后可以正常使用，下面使用iris数据生成一个决策树，可视化决策树的分类：
from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier, export_graphviz import pydotplus from IPython.display import display, Image import os os.environ["PATH"] += os.pathsep + 'C:/Program Files (x86)/Graphviz2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49a07f9a43fbb3cee9a0b8a1bfcd30ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d7e7e4e0c88c4db55d939e5f318f92/" rel="bookmark">
			jupyter-notebook的常用设置技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.设置默认打开谷歌浏览器Step 1： 查看配置文件Step 2：修改配置文件jupyter_notebook_config.pyStep 3：更改默认工作路径Step 4：设置环境路径 2.让你的jupyter notebook显示目录3.使用matplotlib的小tip4.如何运行.py文件 我在使用Anaconda进行数据分析过程中，遇到的jupyter-notebook一些跳转默认浏览器等的小问题，下面具体写写配置，让你在任何设备上使用jupyter-notebook都顺畅无比。 个人环境说明：
Win7 64AnacondaPython 3.6 1.设置默认打开谷歌浏览器 安装好jupyter notebook后，启动出现如下情况:
无法自动跳转到浏览器，每次都要自己手动复制网址，很麻烦。jupyter notebook打开后是默认的用户家目录，无法切换到自己的工作目录。
如何使得jupyter notebook的默认打开浏览器为chrome？如何更改默认工作路径？ Step 1： 查看配置文件 打开cmd，在命令行中输入jupyter notebook --generate-config根据你运行实际显示的路径，打开这个配置文件，我电脑上是这个文件C:\Users\Xu\jupyter_notebook_config.py
Step 2：修改配置文件jupyter_notebook_config.py 通过路径找到该文件jupyter_notebook_config.py，推荐使用 notepad++ 打开该文件。找到#c.NotebookApp.browser 并修改然后保存。
在配置文件中添加如下代码：
import webbrowser webbrowser.register('chrome', None, webbrowser.GenericBrowser(u'C:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe')) c.NotebookApp.browser = 'chrome' 其中GenericBrowser里的参数是你电脑安装Chrome浏览器的路径
Step 3：更改默认工作路径 找到#c.NotebookApp.notebook_dir =' '，删掉开头的“#”，在‘ ’中输入你要设置的目录。
Step 4：设置环境路径 设置好配置文件jupyter_notebook_config.py后，还需要修改工作路径。
先找到快捷方式的保存目录，鼠标右击属性， 把目标后面的 % *** %删除掉，% 里面的东西是默认工作路径指定用户的工作路径，不删除无论你怎么设置都不会起作用的。
这样，启动jupyter notebook会默认自动打开浏览器Chrome，Chrome页面显示的目录就是你设定好的路径。
2.让你的jupyter notebook显示目录 查看你的jupyter notebook默认页面的菜单栏是否包含Nbextensions，如果没有，先安装，终端输入： pip install jupyter_contrib_nbextensions 配置nbentensions jupyter contrib nbextension install --user 启动jupyter notebook，选择Nbextensions，勾选Table of Contents.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d7e7e4e0c88c4db55d939e5f318f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430acdaea6f34c58b7f2a59f32f35fb6/" rel="bookmark">
			使用pyecharts渲染图片的selenium方式报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Python3 + selenium 3下环境渲染图片WebDriverException 个人环境： Anaconda 3, Python3.6, window 7, selenium 3
使用 pyecharts 渲染成图片一直是开发者比较关心的功能，pyecharts 提供了 selenium, phantomjs 和 pyppeteer 三种方式。具体可以参看官网：https://pyecharts.org/#/zh-cn/render_images
snapshot-selenium 是 pyecharts + selenium 渲染图片的扩展，使用 selenium 需要配置 browser driver，这部分可以参考 selenium-python 相关介绍，推荐使用 Chrome 浏览器，可以开启 headless 模式。目前支持 Chrome, Safari。
渲染为图片的时候需要额外的第三方程序包支持，包名：selenium，可以通过执行：pip install selenium 执行安装。渲染为图片的时候，需要用的函数为：make_snapshot。
from pyecharts.charts import Bar # 导出图片，需要引入以下对象 from pyecharts.render import make_snapshot from snapshot_selenium import snapshot bar = Bar() bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]) bar.add_yaxis("商家 A", [5, 20, 36, 10, 75, 90]) # render 会生成本地 HTML 文件，默认会在当前目录生成 render.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430acdaea6f34c58b7f2a59f32f35fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7adfba183e739525ed7a736cf0db28/" rel="bookmark">
			2021「AI中国」评选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 2021「AI中国」评选最强技术实力公司TOP 10最具潜力创业公司TOP 10最佳人工智能公司 TOP 30最强技术生态 TOP 10年度开源事件TOP 10最具商业价值解决方案TOP 30最具创新价值落地案例 TOP 30 2021「AI中国」评选 2022年1月各个机构频频发布”2021年度研究报告“，真的是乱花渐欲迷人眼哪。今天来看看，机器之心的2021年度评选，那些在产业中挖掘AI应用价值的公司都在忙活什么呢。
最强技术实力公司TOP 10 谈到技术实力最强，国内几个互联网大厂榜上有名，也不觉得惊讶。
阿里巴巴的关联公司及业务非常广泛，其人工智能的应用涉及方方面面，如智能软件、智能交通、智能医疗、智能物联网、智能物流、智能制造、智能企服、智能文娱、智能家居、智能出行、智能零售等。
稍微陌生的一个应该是博世，它不是我们熟知的互联网公司，而是一个从事汽车与智能交通技术、工业技术、消费品和能源及建筑技术的工业企业。博世在国内主要是生产和销售汽配、家用电器、工业传动和控制技术、安防和通讯系统等。博世主要为智能家居、互联交通等加入人工智能功能，以及在开发和生产中运用AI技术的产品和解决方案。
最具潜力创业公司TOP 10 从创立时间在三年内的公司中，根据融资、企业规模、营运效率、研发投入、技术储备、客户资源等方面评选出10个最具潜力的创业公司。上榜的10家公司中，有4家致力于智能交通（自动/无人驾驶），有2家聚焦智能芯片，有2家定位智能安防（网络、数据安全等），有1家是发力于智能制造（机器人视觉技术），剩下1家公司是隐私计算算力的提供商。
最佳人工智能公司 TOP 30 目前已经具备成熟的商业模式且也有良好的业绩增长表现的人工智能公司，共有创新奇智、九号公司、来也科技、亮亮视野、领创智信、快手、旷视科技、容联云、商汤科技、视比特机器人、医渡科技、影谱科技、优必选科技等三十家企业。
最强技术生态 TOP 10 最强技术生态：目前具备领先性的技术生态，不仅在国际上获得一定认知，且至少在一个细分市场领域有成熟的产品或服务。最强技术生态榜单有阿里云、安谋科技、百度、华为、千寻位置、声网Agora、腾讯、英伟达等机构。其中百度的2个技术生态：阿波罗和飞浆，分别对标自动驾驶和产业级深度学习平台。华为的2个技术生态：昇思MindSpore是一款全场景AI框架，目前应用于医疗、金融、科研等多领域，提供便捷高效的开发体验；昇腾Ascend是基于华为的处理器和基础软件构建的全栈AI计算基础设施、行业应用及服务。千寻位置的时空智能生态圈，是基于北斗卫星系统的定位数据提供定位服务，目前用于智能城市、智能驾驶、智能农业、智能矿山等多行业，全球总用户超10亿。
年度开源事件TOP 10 细数2021年度AI开发者社区高影响力的代表事件，来看看哪些对开源生态运营具有独特的借鉴价值。可以看到，预训练大模型已经成为了开源发展趋势，比如华为的盘古α，达摩院的AliceMind，浪潮的“源1.0”，腾讯的派大星，百度的ERNIE-M都在自然语言处理领域取得重大突破。
2021年4月，华为联合鹏城实验室开源2000亿参数中文预训练模型盘古α
2021年5月，百度开源框架飞桨2.1版本发布万亿级图检索引擎
2021年6月，阿里达摩院开源深度语言模型体系AliceMind，横扫六大权威榜单
2021年7月，安谋科技联合产业龙头企业成立ONIA，共同打造全球首个开源神经网络处理器指令集架构NPUISA
2021年7月，北大团队自研AI框架「河图」（Hetu）正式开源
2021年8月，DeePMD－kitv2．0．0发布（DeePMD，DeepPotentialMolecularDynamics，深度势能分子动力学）
2021年10月，浪潮发布「源1．0」开源开放计划，开放模型API、高质量中文数据集及相关代码
2021年10月，腾讯开源超大预训练系统派大星，使用异构内存管理方法攻坚「GPU内存墙」
2021年11月，华为欧拉操作系统，百万行代码全部贡献开源社区
2021年12月，百度多语言预训练模型ERNIE－M正式开源
最具商业价值解决方案TOP 30 从商业价值角度来看有哪些解决方案已经在市场上取得不错的营收并获得市场认可。榜单上共有360OS奇络物联、百应科技、标贝科技、滴滴出行、格物钛、海天瑞声、华控清交、中国惠普、联想中国、科大讯飞、微云人工智能、亮亮视野、实在智能、零犀科技、盈迪曼德、PIXMoving等三十家企业。各家企业将人工智能与机器学习、深度学习用于各种应用场景中，加速企业完成数字化转型，落地智能化业务，其涉及的主要方向包括安全计算、自动驾驶、数据管理平台、企服、AI监测、机器人、医疗检测、智慧金融等。
例如九章云极针对传统的金融行业，利用AI技术建立自动化数据科学平台，解决小微信贷风控、反欺诈、投研、推荐、用户行为分析、精准营销、客户流失预警等业务场景问题。在明确场景下自动预处理数据、自动建模、自动调参、自动模型评估、自动模型优化、自动更新等，减少对业务分析人员、手工特征工程的传统机器学习算法的高度依赖。
最具创新价值落地案例 TOP 30 如何使用人工智能技术帮助客户提升至少一项主营业务指标，显著提升其市场竞争力？这个榜单是近两年完工且产出落地成果的30个智能化场景案例。从各大人工智能公司与客户公司的合作案例中看，涉及健康医疗、物流、工业质检、AI客服、智能监测、智能政务等。
个人觉得这个案例很具创新价值，也具备社会意义。校园欺凌这个社会热点问题，分音塔科技这家公司设计的校园防欺凌AI报警器就很有意义，特别的是校园安全的监控盲区里也可以传递报警信号，无需手动触发。案例中主要难点是语音数据的收集和处理，提出语音信息分解的方法应用于语音识别，提高低资源语言的建模能力，还可识别说话人的语种、发音情绪等副语言信息。
欢迎各位关注我的个人公众号：HsuDan，我将分享更多自己的学习心得、避坑总结、面试经验、AI最新技术资讯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e52d73959e24d9f9ac35cfb23efe27f/" rel="bookmark">
			实现基于LSTM的情感分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实现基于LSTM的情感分析1. 【情感分析】常用的数据集及开源库1.1 常用数据集1.1.1 亚马逊产品评价1.1.2 Yelp餐饮评价1.1.3 电影评价1.1.4 亚马逊食品评价1.1.5 航空公司Twitter评价1.1.6 共和党辩论Twitter评价 1.2 开源库 2. Seq2Seq模型3. 【情感分析】一个简单例子3.1 评价指标3.2 实现Bi-LSTM+Attention 4. 参考 实现基于LSTM的情感分析 NLP中情感分析是一个比较常见的任务，涉及文本的情感特征提取、情感特征分类、情感特征检索与归纳等方面。
基于情感特征进行分类的方法主要有：
1.基于情感词典的方法
人工构建情感词典（人工总结标注）自动构建情感词典（基于知识库） 基于机器学习的方法 朴素贝叶斯SVM分类器深度学习方法 项目详见GitHub：https://github.com/SoulDGXu/Sentiment-Analysis-Chinese-pytorch
1. 【情感分析】常用的数据集及开源库 以下是一些我们最常用的的用于试验情绪分析和机器学习方法的情绪分析数据集。 它们开源且可以免费下载 。
1.1 常用数据集 1.1.1 亚马逊产品评价 产品评论： 此数据集包含数百万亚马逊客户评论，星级评级，对培训情绪分析模型非常有用。（https://www.kaggle.com/bittlingmayer/amazonreviews ）
1.1.2 Yelp餐饮评价 餐饮评论：此数据集包含5,2百万条评论星级的Yelp评论。（ https://www.kaggle.com/yelp-dataset/yelp-dataset）
1.1.3 电影评价 电影评论：此数据集包含1,000个正面和1,000个负面处理评论。 它还提供5,331个正面和5,331个负面处理句子/片段。（ http://www.cs.cornell.edu/people/pabo/movie-review-data/）
1.1.4 亚马逊食品评价 精美食品评论：此数据集包含来自亚马逊的约500,000份食品评论。 它包括产品和用户信息，评级以及每个评论的纯文本版本。（ https://www.kaggle.com/snap/amazon-fine-food-reviews）
1.1.5 航空公司Twitter评价 Kaggle上Twitter对航空公司的评论：该数据集包含约15,000条有关航空公司的标签推文（正面，中性和负面）。（ https://www.kaggle.com/crowdflower/twitter-airline-sentiment）
1.1.6 共和党辩论Twitter评价 第一次共和党辩论Twitter情绪：这个数据集由关于2016年第一次共和党辩论的大约14,000条标记的推文（正面，中立和负面）组成。（ https://www.kaggle.com/crowdflower/first-gop-debate-twitter-sentiment）
1.2 开源库 SklearnjiebaNLTKspacy 2. Seq2Seq模型 在Seq2Seq（Encoder-Decoder）模型中，Encoder编码器的作用是把一个不定长的输入序列 x 1 , x 2 , … , x T x_1,x_2,\dots,x_T x1​,x2​,…,xT​变换成一个定长的背景变量 c = q ( h 1 , h 2 , … , h T ) c=q(h_1,h_2,\dots,h_T) c=q(h1​,h2​,…,hT​)，并在该背景变量中编码输入序列 x 1 , x 2 , … , x T x_1,x_2,\dots,x_T x1​,x2​,…,xT​的信息。给定训练样本中的输出序列 y 1 , y 2 , … , y T ′ y_1,y_2,\dots,y_{T'} y1​,y2​,…,yT′​，对每个时间步 t ′ t' t′，Decoder解码器输出 y t ′ y_{t'} yt′​的条件概率将基于之前输出序列 y 1 , y 2 , … , y t ′ y_1,y_2,\dots,y_{t'} y1​,y2​,…,yt′​和背景变量 c c c，即 P ( y t ′ ∣ y 1 , y 2 , … , y t ′ − 1 , c ) P(y_{t'}|y_1,y_2,\dots,y_{t'-1},c) P(yt′​∣y1​,y2​,…,yt′−1​,c)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e52d73959e24d9f9ac35cfb23efe27f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd23ecd9041d1b3f634b1c3a4f208a2c/" rel="bookmark">
			MacOS系统下matplotlib中SimHei中文字体缺失报错的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述解决方法：Step 1. 在终端进入python3环境，查看matplotlib字体路径：Step 2. 下载SimHei.ttf字体：Step 3. 将下载好的SimHei.ttf字体移动到第一步查询到的字体目录./fonts/ttf/下：Step 4. 打开终端，进入python环境，清理matplotlib缓冲目录：Step 5. 修改原始文件：Step 6. 重启，测试 问题延伸：安装Seaborn 问题描述 使用matplotlib画图时，因为缺少字体，出现warning，图像上label上的中文显示时空白小方块。因为matplotlib默认没有中文，可以调用中文字体，但是会出现如下图所示的warning：
import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus'] = False 解决方法： Step 1. 在终端进入python3环境，查看matplotlib字体路径： import matplotlib print(matplotlib.matplotlib_fname()) 找到自己的matplotlib字体文件路径：
比如/Users/dan/miniforge3/envs/py38/lib/python3.8/site-packages/matplotlib/mpl-data/matplotlibrc
Step 2. 下载SimHei.ttf字体： 国内SimHei
Step 3. 将下载好的SimHei.ttf字体移动到第一步查询到的字体目录./fonts/ttf/下： mv ~/Downloads/SimHei.ttf ~/miniforge3/envs/py38/lib/python3.8/site-packages/matplotlib/mpl-data/fonts/ttf/SimHei.ttf 注意字体文件名称一定是：SimHei.ttf
Step 4. 打开终端，进入python环境，清理matplotlib缓冲目录： import matplotlib print(matplotlib.get_cachedir()) 获取缓冲目录地址：/Users/dan/.matplotlib
终端输入exit()退出python环境，再删除上面找到的缓冲文件：
rm -rf /Users/dan/.matplotlib Step 5. 修改原始文件： 打开第一步找到的字体路径：/Users/dan/miniforge3/envs/py38/lib/python3.8/site-packages/matplotlib/mpl-data/matplotlibrc进行修改：
通过vi定位几个关键点来修改：
vi /Users/dan/miniforge3/envs/py38/lib/python3.8/site-packages/matplotlib/mpl-data/matplotlibrc 通过:/内容 查找指定内容
如:/font.family， :/font.sans-serif，:/ axes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd23ecd9041d1b3f634b1c3a4f208a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719cf2905a14e4927568b0d25e23ca73/" rel="bookmark">
			vue-element-admin npm install 安装tui-editor失败 （解决方案-但是无法使用富文本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm install 出错 npm ERR! Error while executing: npm ERR! /usr/bin/git ls-remote -h -t git://github.com/adobe-webplatform/eve.git npm ERR! npm ERR! fatal: remote error: npm ERR! The unauthenticated git protocol on port 9418 is no longer supported. npm ERR! Please see https://github.blog/2021-09-01-improving-git-protocol-security-github/ for more information. npm ERR! npm ERR! exited with error code: 128 解决方案
本失败原因是由于tui-editor（富文本编辑器插件）更名造成的，现在已经更名为toast-ui/editor（以下第一步）
并且该插件还进行了文件名的更名（以下第二步）以及方法名的更名（以下第三步）
解决方案如下：
1.首先将package.json中的tui-editor那一行修改为"@toast-ui/editor": "^3.1.3",
2.进入\src\components\MarkdownEditor\index.vue文件，将他的所有import删除换成下面四行
import 'codemirror/lib/codemirror.css' import '@toast-ui/editor/dist/toastui-editor.css' import Editor from '@toast-ui/editor' import defaultOptions from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/719cf2905a14e4927568b0d25e23ca73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/babb47bcfac9d379d23dad32e3b62045/" rel="bookmark">
			phpstudy配置laravel项目除了首页都是404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找到你的站点配置 文件添加以下代码 重启
#autoindex on; if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace943a68241091ecf06f72e44ce148e/" rel="bookmark">
			C&#43;&#43;抽象基类ABC理念(Abstract Base Class)(纯虚函数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于继承来说，有时候is-a规则并不是看上去的那么简单，比如正在开发一个图形程序，程序会显示圆和椭圆。椭圆有长轴和短轴两个数据成员，当长轴等于短轴时，就相当于是一个圆了。因此我们可以将椭圆类作为父类，圆类作为特殊的子类，但是这会带来一些问题。实际上圆并不需要两个数据成员来刻画，用一个半径就能够刻画了。
一.抽象基类理念 对于上面这种问题，我们可以从Ellipse(椭圆)和Circle(圆)类中抽象出它们的共性，将这些特性放到一个ABC（抽象基类）中。再从这个ABC类派生出Circle 和Ellispse类。
二.抽象类（向上强制转换） 所谓抽象类，就是从别的类中抽出其共性而得到的，因此抽象类并不能被创建！！这很重要。
但是抽象类指针却可以指向其派生类，从而统一管理。在我们这个例子中就是BaseEllipse指针可以指向Circle和Ellipse。
BaseEllipse* p = nullptr; p = new(Circle); p-&gt;showAxis(); 向上强制转换:将派生类引用或指针转换为基类引用或指针，使公有继承不需要进行显式类型转换。
向下强制转换：将基类引用或指针转换为派生类引用或指针，这是不合法的。因为is-a关系通常是不可逆的。简单的说，你不能保证基类一定能用派生类的方法。毕竟，如果可以的话，那干嘛还需要派生类？
三.纯虚函数介绍 纯虚函数的声明类似如下,就是在虚函数的基础上加个 = 0，这样的声明代表着该函数为空，即未定义，自然不用实现。实际上当一个类中存在一个纯虚函数时，这个类就变成了抽象类。
virtual double Area() const = 0; 注意：
（1）纯虚函数没有函数体；
（2）最后面的“=0”并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是虚函数”；
（3）这是一个声明语句，最后有分号。 四.例子实现以及注意点 以下为应用ABC的一个例子，小记一下要点把。
1.在基类中protectd中的内容，子类可以访问，但是外部访问不到。即如果 用Circle 实例化一个对象a ，a是访问不到setx的。
而在基类中的private,是更强的，子类不能访问，因此需要在基类中定义一些方法来让子类调用方法访问，因此在我的理解里protected 是用来方便开后门的。
2.上文所说只要基类拥有一个纯虚函数，该类就是一个抽象类了。对于继承抽象类的子类来说，其还是一个抽象类。？？是不是很疑惑，确实是这样，但是是可以变成具体类的，但是要遵循一定的规则。
必须必须，对抽象类的纯虚函数进行改写。而且必须格式一样，如下所示。
1.纯虚函数 virtual double Area() const = 0; 2.1 错误重写（少了const） virtual double Area(){return M_PI*_duanzhou*_duanzhou;};//这里是一个错误的例子，对纯虚函数的重写必须与其格式一致，这里少写了const,因此 Ellipse还是个抽象类。 2.2正确重写 virtual double Area()const{return M_PI*_duanzhou*_duanzhou;};//正确 3.注意这里子类的构造函数，对于自类而言，它只能赋值给自己的数据成员，对于基类private中的内容它是访问不到的。因此需要使用成员初始化列表传递给基类构造函数。下面提供了两种方式，请注意第一种，蛮有趣的。
//实现一 Circle::Circle(double r, double x, double y): _r(r), BaseEllipse(x,y){}; //实现二 Circle::Circle(double r, double x, double y):BaseEllipse(x,y) { _r = r; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ace943a68241091ecf06f72e44ce148e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773003110acd6327bdc4771207fd4b43/" rel="bookmark">
			续之前微信小程序的部分代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.商城（category）
#index.js import { request} from "../../request/index.js"; import regeneratorRuntime from '../../lib/runtime/runtime'; Page({ data: { //左侧的菜单数据 leftMenuList:[], //右侧的商品数据 rightContent:[], //被点击的左侧的菜单 currentIndex:0, // 右侧内容的滚动条距离顶部的距离 scrollTop:0 }, //接口的返回数据 Cates:[], onLoad: function (options) { /* 0 web中的本地存储和 小程序中的本地存储的区别 1 写代码的方式不一样了 web： localStorage.setItem('key', data) localStorage.getItem("key") 小程序中: wx.setStorageSync('key', "data";(储存数据) wx.getStorageSync('key');(获取数据) 2 存的时候有没有做类型转换 web: 不管存入的是什么类型的数据，最终都会先调用一下 toString()， 把数据变成字符串再存入进去 小程序: 不需要进行类型转换 村什么类型就获取什么类型 1 先判断一下本地存储有没有旧的数据 {time:Data.now(),data:[...]} 2 没有旧数据 直接发送新请求 3 有旧数据 同时 旧数据也没有过期 就使用本地存储中的旧数据即可 */ // 1 获取本地存储中的数据 const Cates=wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773003110acd6327bdc4771207fd4b43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2519d118f51a7cfd4ef8729ed9b06a24/" rel="bookmark">
			k8s的ceph
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ceph安装
地址：https://rook.io/docs/rook/v1.8/quickstart.html
特性丰富
1，支持三种存储接口：块存储、文件存储、对象存储。
2，支持自定义接口，支持多种语言驱动。
基本概念
Ceph OSD
Object Storage Device是ceph的核心组件，用于存储数据，处理数据的复制、恢复、回填、再均衡，并通过检查其他OSD守护进程的心跳来向Ceph Monitors提供一些监控信息。ceph集群每台机器上的每块盘需要运行一个OSD进程。
每个OSD有自己日志，生产环境一般要求OSD的journal日志单独放在ssd上，数据对象放在机械硬盘，以提升性能。而OSD使用日志的原因有二：速度和一致性。
1，速度： 日志使得OSD可以快速地提交小块数据的写入，Ceph把小片、随机IO依次写入日志，这样，后端文件系统就有可能归并写入动作，并最终提升并发承载力。因此，使用OSD日志能展现出优秀的突发写性能，实际上数据还没有写入OSD，因为文件系统把它们捕捉到了日志。
2，一致性： Ceph的OSD守护进程需要一个能保证原子操作的文件系统接口。OSD把一个操作的描述写入日志，然后把操作应用到文件系统，这需要原子更新一个对象（例如归置组元数据）。每隔一段 filestore max sync interval 和 filestore min sync interval之间的时间，OSD停止写入、把日志同步到文件系统，这样允许 OSD 修整日志里的操作并重用空间。若失败， OSD 从上个同步点开始重放日志。
Monitor
Ceph Monitor维护着展示集群状态的各种图表，包括监视器图、 OSD图、归置组（ PG ）图、和 CRUSH 图。 Ceph 保存着发生在Monitors、OSD和PG上的每一次状态变更的历史信息（称为epoch ）。Monitor支持高可用部署，可以运行多个Monitor组成一个集群，一个监视器集群确保了当某个监视器失效时的高可用性。存储集群客户端向Ceph监视器索取集群运行图的最新副本，而集群通过Paxos算法就集群当前状态保持一致。
MDS
Ceph Metadata Server为Ceph文件系统存储元数据（也就是说，Ceph 块设备和 Ceph 对象存储不使用MDS ）。Metadata Server使得 POSIX 文件系统的用户们，可以在不对 Ceph 存储集群造成负担的前提下，执行诸如 ls、find 等基本命令。
CRUSH
CRUSH 是 Ceph 使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。Ceph 客户端和 OSD 守护进程都用 CRUSH 算法来计算对象的位置信息，而不是依赖于一个中心化的查询表。与以往方法相比， CRUSH 的数据管理机制更好，它很干脆地把工作分配给集群内的所有客户端和 OSD 来处理，因此具有极大的伸缩性。 CRUSH 用智能数据复制确保弹性，更能适应超大规模存储。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2519d118f51a7cfd4ef8729ed9b06a24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b982ad7f2b51240c28296d65a4c8a998/" rel="bookmark">
			Uncaught (in promise) DOMException: Failed to load because no supported source was found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp 的音频报错，
我的是这样的情况，有时候是好的有时候不是好的。
报错如下图：
搜索了下报错的原因，是因为音频找不到资源。
查看代码，发现路径是这样写的。
于是进行了以下的修改：
直接在上面引入，就可以了。
解决啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a4e7de9de02435281cad7a8a9adad2/" rel="bookmark">
			（四）策略梯度(policy gradient)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面一章表格型方法，进行策略迭代的时候利用到了Q函数。是一种value-base的方法，而之前介绍到还有一种policy-base，本章的就是一种policy-base的方法。
ps：强化学习的目的是寻找最佳策略，value-base相对复杂一点儿，先算价值再找策略。policy-base就是直接寻找策略的。
那有一个大问题就是：==明明已经有了value-base方法，为什么还要去开发policy-base呢？==有什么特殊性吗？当然有了，value-base是有局限性的，只适用于离散动作空间而且是确定性策略(原因还不清楚，但是就是这么回事~)。而policy-base使用场景包括随机策略、动作空间连续(当然也兼容离散动作空间，确定性策略)。所以研究policy-base的方法是十分有必要的。
还记得最开始那张RL的图吗？里面有三个元素组成：agent, reward, environment。其实在这三个里面能由我们主观控制的只有一个agent(其实对应的是policy)，剩下两个都是客观存在的，只不过在选取不同的策略下呈现方式会有不同。所以直接对policy进行修改是有意义的。那现在最大的问题就是：如何从policy出发寻找最佳policy呢？
回想第一章说过的，策略其实就是一个概率分布。会告诉在状态下执行各个动作的概率。那策略梯度的思想就十分清楚了：当判断出某种行为可以带给我们价值大的，就增加这种行为的概率。现在思路理解了，可怎么把思想进行建模呢？既然是概率分布，那就使用机器学习中常见的方法：概率参数化。把问题转换成对参数进行数学操作。本文中统一用Θ代替。下面就介绍下这个流程：
之前从概率的角度出发，每一个动作都是一个概率。而一条轨迹由无数个动作组成，轨迹也可以用概率表示：
注意上面的Θ代表的就是某个策略
RL关注的是奖励最大化，用概率分布的方法来表示策略的奖励：
为了便于说明，还是将上式转变成期望：
所以一切的一切现在都变成了对Θ进行操作，实现期望最大化。
一个问题来了：怎么实现期望最大化呢？——梯度上升
首先解释一下啥叫梯度，其实就是变化率，也叫导数。梯度上升就是一点儿一点儿的变化，但整体是上升趋势。这里求导的对象自然就是Θ了。
先给出结果式，然后再来看看这个东东是怎么来的：
具体的推导过程如下：
这里面用到了一个技巧：
可以很直观的理解上面的式子：从采样得到的数据中，确定状态动作对——(s(t), a(t))。如果发现轨迹奖励是正的，就增加这个动作对的概率。否则降低。那 升高降低多少呢？怎么体现在参数Θ上呢?就是利用上面的计算式确定梯度，然后进行更新。
所以整体策略梯度的更新流程如下图所示：
有几个点需要明确：
1.Θ更新式中的η是权重，就是这场游戏的奖励
2.数据采集时，智能体本身有随机性。对于相同的状态s不一定都会采取相同的a，所以要把每笔数据记录下来(每条数据内容状态动作对及对应的奖励)。
3.策略梯度采样的数据只能使用一次，更新参数后就不能用了(原因我也不知道为啥~)
上面讲的都是关于Θ的，那和我们的策略有啥关系。不要忘记，是用Θ来代表策略的。优化Θ就相当于优化策略。
以上介绍了策略梯度的思想及实现方法，下面介绍一些改进的小技巧。能够帮助我们提高策略梯度的效果。
技巧1：添加基线(baseline)
首先问自己一个问题：为啥要添加基线？
设想这样一种场景，之前解释过在进行梯度更新时，奖励为正的增大其概率，奖励为负的减少其概率。但现实中往往是这样的：奖励全部是非负的，像乒乓球中就是[0,11]。对于这种情况会出现一个问题：之前是使用概率去衡量的，当完成归一化之后，只有原来上升多的才会上升，上升少的相比之下会下降。这不是我们期望的结果。所以我们会期望奖励不要总是正的，这就是基线的作用。把奖励都减去一个常数，只有奖励超过基线的概率上升。否则即使是正的太小了也不好，让其概率下降，数学化的表达如下：
那怎么求呢？对于b的求解，可以使用MC进行一次完整训练，然后取期望，并且也可以不断更新这个b：
技巧2：分配合适的分数(给动作确定权重)
在前面的式子中有这样一个问题：在任意动作中，乘的奖励是相同的。因为一次轨迹的奖励是确定的，baseline也是确定的。但实际上动作有好有坏，所以希望能根据动作分配适合的奖励分数。并且通过这个不同的奖励分数，可以反应每一个动作是好还是不好。举一个例子来进行说明：
从上面图中看到，最终的奖励是+3，如果不进行权重分配的话。所有的动作奖励都会被认定为+3。以(s(b),a(2))这对为例，可以很明显的看出它其实并没有什么作用，奖励都是第一对来的，甚至它会带来负面影响，因为s(b)在执行a(2)后会进入s©，而s©会削弱当前的奖励。同理，如果前面是负的，s(b)即使增强，但幅度小的话，也看不太出来。所以可以认定执行这个动作前的奖励对于评价这个动作没有参考价值。只有把执行这个动作以后发生的所有奖励加起来，才是这个动作真正的贡献。修改后的数学表达式为：
代表从t时刻开始后面的奖励，更能代表动作所对奖励起到的贡献
甚至可以为将来的奖励加上折扣因子：
代表折扣回报
把R-b这一项合起来，就叫做优势函数，即
表示为：
下面介绍一个最简单也最经典的梯度策略算法：REINFORCE(蒙特卡洛策略梯度)
设计到蒙特卡洛思想，就是以回合为单位进行取样的。
因为对于算法了解不是很深入，在此就简单罗列一些相关知识点。等后面学习明确了再过来补充说明。
算法伪代码如下：
算法流程图如下：
老规矩，课后题：
参考资料：【强化学习】策略梯度方法-REINFORCE_哔哩哔哩_bilibili
因作者水平有限，如有错误之处，请在下方评论区指出，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e066c3cd4202c591750751536d14b60d/" rel="bookmark">
			protobuf序列化与反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区分 Protobuf 中缺失值和默认值 - 知乎
做个项目，参数保存使用protobuf协议序列化后写到flash，读出后反序列化赋值。
// &lt;! 参数1 message Param1_t { int32 age = 1; // &lt;! 日龄 int32 weight = 2 [default = 100]; // &lt;! 体重 } message Param2_t { int32 age = 1; // &lt;! 日龄 int32 weight = 2; // &lt;! 体重 } #define Param_t_Default {10, 0} typedef struct _Pig_t { int32 age; // &lt;! 日龄 int32 weight; // &lt;! 体重 } Pig_t; Pig_t pig = Param_t_Default; 消息类型中原始数据类型默认值是0，但在程序其他地方定义默认值，每次读时候都会先把默认值赋值给接收消息体的结构体变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e066c3cd4202c591750751536d14b60d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0176fb0a88f1505c4b66cb0304e39c5/" rel="bookmark">
			C&#43;&#43;之导入其他文件的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++之导入其他文件的函数 相信很多小伙伴在开发的时候，都需要在自己的主文件中导入自己写好的其他文件中的函数，那么具体应该怎么做呢？下面我们来看一个例子
上述图片中的代码是要在主文件中准备调用的test_202(),下面演示一下如何在主文件中调用
#include &lt;iostream&gt; #include "opencv2/opencv.hpp" //错误写法 #include "test.cpp" using namespace std; using namespace cv; //声明这个函数 void test_202(); int main() { test_202(); return 0; } 输出: this is a test202 file 上述程序中可以看到如果使用#include引入了test.cpp，那么其实会报bugmultiple definition of `test_202()，就是函数名冲突的问题。正确写法是直接在主文件中声明要调用的函数，然后在main()中直接调用即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac621f029e0e68de223735490b3de232/" rel="bookmark">
			Visual Studio二次安装时无法更改安装位置解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：去年年底因为一个C#项目，安装过Visual Studio，当时采用的是默认安装，即安装到C盘。最近有个VB的桌面小项目，想安装Windows开发平台负载时发现C盘剩余空间不足15G，随起了卸载重新安装的想法，卸载后重新安装时，发现默认安装位置呈现灰色，不可更改，网络上解决方案好多说的比较单一，那么我在此总结下，方便自己和后来者。
本质：出现这个问题的本质原因为上一次安装卸载不彻底（一般指的是软件从硬盘里移除了，但写到注册表里面的配置信息并没有删除干净），导致后续安装时默认读取的注册表里面未删除的配置信息，本次无法更改安装位置就是这种情形。
搞清楚了问题本质，解决问题方案如下：
1、采用官方卸载工具执行强制卸载。下载地址：Releases · microsoft/VisualStudioUninstaller · GitHub ，点击如图所示的路径下载。
解压缩后，右键管理员运行下图箭头执行的exe文件，根据提示操作即可。注意：卸载时cmd窗口可能会长时间无反应，这一步是在执行卸载，耐心等待提示完成卸载即可！这一步目的是为了更加干净地卸载电脑已安装的Visual Studio软件和配置，只执行这一步可能仍然无法解决无法更改安装位置的问题，至少我是这样的。
2、步骤1执行完毕后，运行regedit打开注册表，查看注册表路径：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\Setup 下是否还存在SharedInstallationPath和CachePath配置项，如果依然存在，那么手动右键删除即可。这一步一定要做，很关键！
注意以上两个步骤建议都操作下，单一执行某个步骤，都可能解决不了问题。
以上，完了！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d339bc5af9c982ccc1569d0755cb30e2/" rel="bookmark">
			VSCode如何返回上一步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/weixin_41044151/article/details/114141396
vscode返回上一步：
在Windows中可以使用快捷键“Alt+←”实现。
在Linux中可以使用快捷键“Ctrl+Alt+ -”实现。
在Mac中可以使用快捷键“Ctrl + -”实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d862ccb8c4895ed71e01cbb779aaf3ab/" rel="bookmark">
			苹果手机相册删除的照片怎么恢复？怎样找回几个月前删除的照片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果手机相册太多照片需要整理，在整理的过程中或许会不小心删除一些不能删除的照片，如果真的删除了，甚至是几个月前删除的照片，该如何恢复？苹果手机相册删除的照片怎么恢复？小编在这里整理了三种有效的方法。
方法一：在手机相册中恢复误删的照片 苹果手机相册删除的照片怎么恢复？如果您的苹果手机删除的照片不超过40天的话，便可以在手机相册中恢复误删的照片。在哪里恢复呢？接着看。
打开手机相册，点击底部的“相簿”，下拉找到“最近删除”，就可以看见最近40天以内删除的照片了，进行选择并还原即可。
方法二：在电脑端iCloud中恢复误删的照片 如果您觉得在手机上不好操作最近删除的照片，或者因为最近删除的照片太多了，手机视野太小，选起来会比较难，那么，苹果手机相册删除的照片怎么恢复？您也可以通过电脑端的iCloud进行恢复误删的照片。
步骤一：在浏览器搜索“iCloud”，点击进去，如下图画面，并登录。
步骤二：登录进去后，点击“照片”。
步骤三：点击“最近删除”，iCloud跟手机相册一样，都是最近删除40天以内的照片才会在这里显示出来，选择完毕后，点击“恢复”即可。
方法三：在专业的恢复软件中恢复误删的照片 若是删除了几个月的照片呢？已经超过40天了，苹果手机相册删除的照片怎么恢复？还可以恢复吗？小编可以告诉你，当然可以呀！数据蛙苹果恢复专家就可以，这款软件能够高效扫描出您的设备的数据，安全性能高，不会泄露您的数据，并且有免费试用版本，针对用户的需求做得越来越人性化。具体操作步骤如下：
步骤一：在您的常用电脑安装这款软件，安装完后，连接手机到电脑上，选择“从iOS设备中恢复”，点击“开始扫描”。
注意：扫描过程不可以随意拔掉数据线，避免扫描失败。
步骤二：扫描结束就会显示以下画面，点击左侧的“相机胶卷”，选取需要恢复的照片，点击右下角的“恢复”即可。
数据蛙苹果恢复专家的操作步骤是不是超级简单的！而且能够将几个月前删除的照片快速找回来！这个软件真的绝了！苹果手机相册删除的照片怎么恢复？若果您删除的照片还没超过40天，可以使用方法一根方法二，超过40天那就使用数据蛙苹果恢复专家吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5e5009a0a9bb860f1188bfbf9af491/" rel="bookmark">
			【git】git入门教程（git bash常用快捷键和命令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git入门教程（git bash常用快捷键和命令） -1 概念-1.1 仓库-1.2 分支-1.3 同步-1.4 暂存-1.5 合并 0 git bash常用快捷键和命令0.1 复制粘贴0.2 光标0.3 编辑0.4 命令0.5 常用命令 1 初始设置1.1 初始设置1.2 避免每次push，clone都输入账号密码1.2.1 ssh协议1.2.2 https协议 2 提交代码2.1 先clone到本地再push2.2 本地初始化仓库再push（对本地现有文件）2.3 撤销或更改提交操作2.3.1 撤销最近的提交2.3.2 撤销几次之前的提交2.3.2.1 git rebase 变基2.3.2.2 git revert 3 下载代码3.1 git clone3.2 fetch 4. 远程仓库管理4.1 修改仓库名4.2 仓库地址相关4.3 移除仓库 5 撤销操作6 通过打tag进行版本控制6.1 列出标签（tag）6.2 创建标签6.3 附注标签6.4 轻量标签6.5 后期打标签6.6 共享标签6.7 删除标签6.8 检出标签 7 Git别名 本文主要使用gitee托管，github同理 入门可以粗略看看概念和复制粘贴，然后直接从1初始设置开始 git文档属实比较难读进去，建议有一定基础后需要时再看 -1 概念 -1.1 仓库 仓库，就是你存在.git目录的那个文件夹内的所有文件，包括隐藏的文件，Git程序会再当前目录以及上级目录查找是否存在.git文件，如果存在，则会将.git目录存在的文件夹开始下的所有文件当成你需要管理的文件
-1.2 分支 分支功能解决了正在开发的版本与上线版本稳定性冲突的问题在Git使用过程中，我们的默认分支一般是Master，当然，这是可以修改的，我们在Master完成一次开发，生成了一个稳定版本，那么当我们需要添加新功能或者做修改时，只需要新建一个分支，然后在该分支上开发，完成后合并到主分支即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e5e5009a0a9bb860f1188bfbf9af491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3190179f3fc5791415d5fe684732704a/" rel="bookmark">
			【git】git冲突解决详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git冲突解决详解 方法1：pull下来然后修改冲突文件方法2： cherry-pick然后checkout git merge时，不免产生各种各样的冲突，可是我们连如何选择版本都晕半天，这里进行详细解答。 本文参考 git merge冲突解决，该文章描述了更多冲突情况，但需要一定git基础，而本文仔细到每一步操作， 适合新手。 案例：我们的远程仓库上有main和master两个分支，我们想将master合并到main上，然后删除master，但是两边都存在README.MD，我们想保留master分支那个
方法1：pull下来然后修改冲突文件 创建并进入工作目录
初始化
$ git init #初始化本地仓库 将一个远程仓库添加到本地的仓库当中
$ git remote add origin https://gitee.com/用户个性地址/xxx.git #之后origin相当于这个url的“别名”，可以用origin来代替整个url 把main分支添加进来，git pull 命令基本上就是 git fetch 和 git merge 命令的组合体，Git 从指定的远程仓库中抓取内容，然后马上尝试将其合并进你所在的分支中
git pull origin main 如果两个分支毫无渊源，要加上后面的–allow-unrelated-histories，否则合并时报错
git pull origin master --allow-unrelated-histories 此时已经进入MERGING状态，查看冲突文件
git status 也可以采用命令：git ls-files -s，查看冲突文件该命令输出的第二列的值如果为0表示对应的文件没有冲突，合并成功，如果不为0，则表示产生了合并的冲突，其中具体的值对应的意义是：1表示两个用户之前一个共同版本的对应文件内容；2表示当前用户对应的文件版本；3表示合并后的文件对应的远程版本
然后使用git mergetool命令或git show :n:filename（n替换为上述数字）查看对应文件的对应版本的内容
比较各版本，用vscode打开冲突文件，上方会弹出选择版本的选项，选择需要保留的版本
冲突解决，添加已经解决冲突的文件
git add -A #添加全部文件 再次git status查看状态，全部都changes to be committed即可提交
git commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3190179f3fc5791415d5fe684732704a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a3623c9519815704582fee68eb245a/" rel="bookmark">
			Linux——用户账号和管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux——账号和权限管理 一、管理用户账号1.1 用户账号概述1.1.1 用户账号分类1.1.2 用户标识UID（User IDentity ，用户标识号）1.1.3 用户账号文件 1.2 用户账号管理1.2.1修改账号和密码期限——chage1.2.2 添加用户账号——useradd1.2.3 设置/更改用户口令——passwd1.2.4 修改用户账号属性——usermod1.2.5 删除用户账号——userdel 1.3 用户账号的初始配置 二、删除历史记录（保护密码）三、管理组账号3.1 组账号概述3.1.1 组账号文件命令3.1.2 四个字段 3.2 添加组账号—groupadd命令3.3 添加、设置、删除组成员——gpasswd3.4 删除组账号—groupdel3.5 查询用户账号所属组——groups3.6 查询当前主机的用户登陆情况——w/who/lastlog -u3.7 查询用户账号身份标识——id 四、文件/目录的权限及归属4.1 查看文件/目录的权限和归属权限：归属 4.2 设置文件和目录权限——chmod4.3 设置文件/目录归属——chown/charp4.4 umask应用 一、管理用户账号 1.1 用户账号概述 1.1.1 用户账号分类 超级用户： root用户是Linux操作系统中默认的超级用户账号，对本主机拥有最高的权限，系统中超级用户是唯一的。普通用户： 由root用户或其他管理员用户创建，拥有的权限会受到限制，一般只在用户自己的宿主目录中拥有完整权限。程序用户： 在安装Linux操作系统及部分应用程序时，会添加一些特定的低权限用户账号，这些用户一般不允许登录到系统，仅用于维持系统或某个程序的正常运行，如bin、daemon、ftp、mail等。 1.1.2 用户标识UID（User IDentity ，用户标识号） root用户账号的UID固定值0程序用户账号的UID默认为Centos5,6: 1~499，Centos7: 1~ 999普通用户的UID默认为Centos5, 6: 500~ 65535，Centos7: 1000~ 65535 1.1.3 用户账号文件 作用： 保护用户名称、宿主目录、登录shell等基本信息
每一行对应一个用户的账号记录
文件位置：
/etc/passwd ：保存用户名称、宿主目录、登录shell等基本信息/etc/shadow ：保存用户的账号、密码等有效信息每一行对应一个用户的账号记录 /etc/passwd： 超级用户root及程序用户的账号信息
基于系统运行和管理需要，所有用户都可以访问passwd文件中的内容，但是只有root用户才能修改。passwd文件的每一行内容中，包含了7个用冒号“：”分割的配置字段，从左到右各配置字段的含义分别如下述：
root:x:0:0:root:/root:bin/bash 用户账号名称用户密码占位符用户的UID号所属基本组账号的GID账号第二个root：用户描述，用户全名第三个/root;宿主目录bin/bash ：登录Shell信息（/bin/bash为可登录系统，/sbin/nologin和bin/false为禁用户登录系统）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74a3623c9519815704582fee68eb245a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ae07e6371daaaf6d4b6ea504202f3f/" rel="bookmark">
			Mongodb:安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入官网下载
官网
安装
点击next
勾选同意，点击next
点击customer
点击修改安装路径
个人修改的路径。点击next
点击next
取消勾选，点击next
点击install
安装进行中
安装完成之后
配置 在data目录新建db目录
在log目录下新建mongodb.log文件
在安装目录新建文件mongo.config
dbpath=D:\frontapplication\mongodb\data\db#数据库路径 #这里是你的安装路径！！！！！ logpath=D:\frontapplication\mongodb\log\mongodb.log#日志输出文件路径 #这里是你的安装路径！！！！！ logappend=true#错误日志采用追加模式 journal=true#启用日志文件，默认启用 quiet=true #过滤掉无用的日志信息，若需要调试使用请设置为false port=27017 #端口号 默认为27017 cmd打开bin目录
输入命令运行MongoDB服务:
mongod --dbpath D:\frontapplication\mongodb\data\db
浏览器打开
http://localhost:27017/
说明启动成功
安装mongodb服务：
mongod --config "D:\frontapplication\mongodb\mongo.config" --install --serviceName "MongoDB"
打开任务管理器：CTRL +alt+ delete
将MongoDB的bin目录的路径加入环境变量
关闭MongoDB 关闭当前服务端窗口（不推荐）
在当前服务窗口使用Ctrl+C（推荐）
进入Mongo客户端运行命令停止（推荐）db.shutdownServer（）；
关闭Windows服务（推荐）net stop MongoDB
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcb8dd6d16ccfd82b3832dee7950d99/" rel="bookmark">
			PCL-利用相机移动模拟小车移动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 通过相机模拟小车的第一视角，这就需要相机模拟小车的运动。
小车数据 //点的位置 struct geometry_msgs_Point { double x; double y; double z; }; //四元数 struct geometry_msgs_Quaternion { double x; double y; double z; double w; }; 坐标x,y,z比较直接使用就可以，这里的问题在于四元数，之前从来没有接触过，于是我花了两天学习了一下四元数的相关内容，大致了解了其是如何表示旋转的，真的是非常巧妙。
根据学到的四元数,我们有单位四元数如下（表示绕向量u旋转θ度）
q = [ cos ⁡ ( 1 2 θ ) , sin ⁡ ( 1 2 θ ) u ] q = [\cos(\frac{1}{2}\theta) , \sin(\frac{1}{2}\theta)\bold{u}] q=[cos(21​θ),sin(21​θ)u]
而u是一个三维单位向量，在这里可以用x,y,z表示，即
q = [ cos ⁡ ( 1 2 θ ) , sin ⁡ ( 1 2 θ ) x , sin ⁡ ( 1 2 θ ) y , sin ⁡ ( 1 2 θ ) z ] q = [\cos(\frac{1}{2}\theta) , \sin(\frac{1}{2}\theta)\bold{x},\sin(\frac{1}{2}\theta)\bold{y},\sin(\frac{1}{2}\theta)\bold{z}] q=[cos(21​θ),sin(21​θ)x,sin(21​θ)y,sin(21​θ)z]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dcb8dd6d16ccfd82b3832dee7950d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59bbb82c42a216e5e17131f430af7093/" rel="bookmark">
			java解析字符串实现计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package cn.hsa.eval.task.executors; public class ArithHelper { // 默认除法运算精度 private static final int DEF_DIV_SCALE = 16; // 这个类不能实例化 private ArithHelper() { } /** * 提供精确的加法运算。 * * @param v1 被加数 * @param v2 加数 * @return 两个参数的和 */ public static double add(double v1, double v2) { java.math.BigDecimal b1 = new java.math.BigDecimal(Double.toString(v1)); java.math.BigDecimal b2 = new java.math.BigDecimal(Double.toString(v2)); return b1.add(b2).doubleValue(); } public static double add(String v1, String v2) { java.math.BigDecimal b1 = new java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59bbb82c42a216e5e17131f430af7093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39031193c63371a2da8c6cdb2a49739/" rel="bookmark">
			C&#43;&#43;_3——库（numeric、limits、math）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++_3——库（numeric、limits、math） limitsC++数学库numericC数学库math.h 这一系列文章的目的是在学习了C++基础后，继续补充一些C++基础和进阶的知识点，包括C++11的相关内容。
以C++11标准为基础。 limits 这个库给出了编译平台的一些算数类型的属性
std::numeric_limits&lt;double&gt;::infinity(); // 返回 double的正无穷大 std::numeric_limits&lt;int&gt;::min();	// 返回 int的最小值 std::numeric_limits&lt;int&gt;::max();	// 返回 int的最大值 std::numeric_limits&lt;int&gt;::is_signed;	// 判断类型有无符号，返回bool std::numeric_limits&lt;int&gt;::has_infinity;	// 判断类型是否存在正无穷的表示 std::numeric_limits&lt;double&gt;::epsilon();	// 返回 1与可表示的大于1的最小值之间的差 近似的0 C++数学库numeric 累积 accumulate，可自定义求和方式 #include &lt;iostream&gt; // std::cout #include &lt;functional&gt; // std::minus #include &lt;numeric&gt; // std::accumulate int myfunction (int x, int y) {return x+2*y;} struct myclass { int operator()(int x, int y) {return x+3*y;} } myobject; int main () { int init = 100; int numbers[] = {10,20,30}; std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39031193c63371a2da8c6cdb2a49739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4cb847a06354c5f2928c2a01f70515/" rel="bookmark">
			微信的转账记录删除了还能恢复吗？2个办法教你找回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信的转账记录删除了还能恢复吗？除了聊天记录外，好像还有很多朋友对于转账记录的恢复问题呼声也蛮高的，所以，小编这期就给大家带来找回微信转账记录的办法，分别有2个，赶紧进入正题，我们一起来看看到底是什么办法吧！
方法1：手机微信上找回微信的转账记录 微信的转账记录删除了还能恢复吗？很不幸地告诉大家，一旦删除转账记录，是无法从手机上恢复的，只能通过账单，查找到来源，并不能恢复到聊天框中。具体步骤如下：
步骤一：打开手机微信，点击右下角的“我”，再点击“服务”，在新的页面点击“钱包”，再点击右上角的“账单”。
步骤二：点击“全部账单”，选择“转账”，所有的转账流水就会显示出来。
注意：虽然有流水，但是并不能恢复到聊天框中。
方法2：利用专业恢复软件恢复删除的转账记录 方法1只能查看转账流水，并不能恢复，微信的转账记录删除了还能恢复吗？当然可以。数据蛙苹果恢复专家就可以做到，这款软件可以快速高效地扫描您的设备的数据，包括图片、文档、通讯录、音频等类型，并且安全性能很高，不必担心扫描出来的转账记录会泄露出去，这款软件还推出了免费试用版本，您可以放心扫描。
步骤一：安装这款软件到您的常用电脑上，并且连接您的手机，进入软件主页，选择“从iOS设备中恢复”，点击“开始扫描”。
步骤二：等待扫描结束后，在左侧应用栏找到“微信聊天记录”，并找到相关的转账记录，点击“恢复”即可。
整个过程是不是很简单易懂呢？微信的转账记录删除了还能恢复吗？安装数据蛙苹果恢复专家就能轻松为您解决这个问题啦！还等着干嘛，赶快安装吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f754b9c62f48e5f5a0b47b614339b276/" rel="bookmark">
			手机丢了微信聊天记录怎么恢复？别担心，教你一招找回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在丢了手机大不了再买一台，重点不是心疼手机丢了，而是心疼所有的数据也跟着丢了，甚至是在没有做备份的情况下弄丢了，那么，手机丢了微信聊天记录怎么恢复？别担心，教你一招找回，不过根据不同的情况，小编提供两种方法供大家选择。
方法一：在电脑端找回手机丢了的聊天记录 手机丢了微信聊天记录怎么恢复？如果手机丢了的情况，那就要试试能不能在电脑端找回聊天记录了，如果您经常使用电脑登录微信的话，找回的机率更大，但是不管怎样，都要先试一试。
步骤一：打开电脑端的微信，点击左下角，再选择“备份与恢复”。
步骤二：在“备份与恢复”中点击“恢复聊天记录至手机”，然后根据手机提示进行。
方法二：在iOS设备中恢复手机丢了的聊天记录 如果在电脑上没办法找回来的话，还有其他招数吗？当然有啊！手机丢了微信聊天记录怎么恢复？小编给大家介绍一种特别实用的方法，在数据蛙苹果恢复专家中找回手机丢了的聊天记录。这款软件能够全面恢复数据文件的类型，操作过程简单，数据恢复高效，并且安全性能很高，不需要担心数据泄露问题，而且这款软件推出了免费试用版本，供大家免费扫描数据。
步骤一：将数据蛙苹果恢复专家安装到您的常用电脑上，打开软件，并连接手机，选择“从iOS设备中恢复”，最后点击“开始扫描”。
步骤二：扫描结束后，可以看到各种数据类型分好类，在应用栏找到“微信聊天记录”，进行筛选，点击“恢复”即可。
手机和微信聊天记录同时丢了真是令人苦恼，能保住一样是一样，手机丢了找不回来了，但是聊天记录可以呀！手机丢了微信聊天记录怎么恢复？数据蛙苹果恢复专家或许可以帮到您哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4444bd9248719aab764570f1b1e2971/" rel="bookmark">
			【开发】vue前后端分离开发问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前后端跨域接口实现1、安装axios插件并设置全局2、设置跨域代理3、 发送请求 二、 动态表格实现三、vue - 将数据存入vuex中以及从vuex中取出数据vuex的五个核心概念：正式进入使用vuex应用核心管理仓库 构建storestate状态管理数据mutations 同步提交数据actions 的异步操作Getters 对state进行加工在Vue组件中获得Vuex状态辅助函数 mapState 和 mapGettersModule子模块化管理 四、解决vuex中刷新数据，数据消失问题解决方法操作 五、一些其他问题的解决方法 一、前后端跨域接口实现 1、安装axios插件并设置全局 npm install axios --save-dev 安装完成后对axios进行全局调用，在main.js中设置
import axios from 'axios' Vue.prototype.$axios = axios 2、设置跨域代理 在config文件夹的index.js文件中(或者是在vue.config.js中），设置proxy模块代理，之后重启项目
devServer: { port: port, open: true, overlay: { warnings: false, errors: true }, // before: require('./mock/mock-server.js') proxy: { [process.env.VUE_APP_BASE_API]: { target: 'http://0.0.0.0:8000/', // 用于本地调试 // target: '', // 用于生产环境 changeOrigin: true, pathRewrite: { ['^' + process.env.VUE_APP_BASE_API]: '' } } } }, 3、 发送请求 在src的views文件夹中创建test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4444bd9248719aab764570f1b1e2971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e1a573e95d383ec5688ef9a04c408e/" rel="bookmark">
			[Android Material Design]组件07 - SwipeRefreshLayout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 效果图关键代码源码地址 效果图 关键代码 xml布局文件代码如下：
&lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout android:id="@+id/srl" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="8dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent"&gt; &lt;TextView android:id="@+id/tv" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:text="下拉刷新!" /&gt; &lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt; SwipeRefreshLayout是一个容器视图，里面可以放listview，recyclerview等控件。当用户下拉控件时，刷新控件的内容。
kotlin逻辑代码如下：
val srl = findViewById&lt;SwipeRefreshLayout&gt;(R.id.srl) val tv = findViewById&lt;TextView&gt;(R.id.tv) srl.setColorSchemeColors(ContextCompat.getColor(this, android.R.color.holo_red_dark), ContextCompat.getColor(this, android.R.color.holo_orange_dark), ContextCompat.getColor(this, android.R.color.holo_blue_dark)) srl.setOnRefreshListener { srl.postDelayed({ srl.isRefreshing = false tv.text = "刷新成功" }, 3000) } SwipeRefrshLayout控件可以实现下拉刷新的效果，基本使用的方法如下：
setOnRefreshListener(OnRefreshListener)
添加下拉刷新监听器setRefreshing(boolean)
显示或者隐藏刷新进度条isRefreshing()
检查是否处于刷新状态setColorSchemeResources()
设置进度条的颜色主题，最多设置四种不同颜色 源码地址 https://github.com/yurensan/MaterialDesignDemo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df4ebb21e1d0f7ff7f0bd7f84214058/" rel="bookmark">
			救援模式（Rescue Mode）、单用户模式（Single-User Mode）、紧急模式（Emergency Mode）的区别与联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://www.cnblogs.com/xuanbjut/p/13100511.html
1、相关概念：runlevel：
一句话：运行级别指的是Linux等类Unix操作系统下不同的运行模式。
运行级别通常分为7等，分别是从0到6，但如果必要的话也可以更多。运行级别决定了计算机启动后的运行环境，根据Linux Standard Base，标准的运行环境可以分为7个：
0 Halt Shuts down the system. 1 Single-user mode Mode for administrative tasks.（注意这里，说明系统返回的shell有root权限） 2 Multi-user mode Does not configure network interfaces and does not export networks services. 3 Multi-user mode with networking Starts the system normally. 4 Not used/user-definable For special purposes. 5 Start the system normally with appropriate display manager (with GUI) Same as runlevel 3 + display manager. 6 Reboot Reboots the system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df4ebb21e1d0f7ff7f0bd7f84214058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30cf0317a4f623446c2aa72a0bf3ec52/" rel="bookmark">
			kubeadm部署ingress-controller
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		九：kubeadm集群裸机部署：nginx-ingress-controller:0.30.0
以daemonset + hostnetwork + nodeselector为例
集群环境：
1.查看开启是ipvs
[root@master01 ~]# kubectl get pods -n kube-system |grep kube-proxy
kube-proxy-5pl4d 1/1 Running 0 3h17m
kube-proxy-lmfmm 1/1 Running 0 179m
kube-proxy-tfq9c 1/1 Running 0 175m
#如果开启ipvs，会有输出，需要查看三个kube-proxy的pod。
[root@master01 ~]# kubectl logs -f kube-proxy-5pl4d -n kube-system |grep ipvs
I1215 04:08:14.351482 1 server_others.go:259] Using ipvs Proxier.
2.如果没有开启，可以修改配置文件，指定kube-proxy调度为ipvs
[root@master01 ~]# kubectl get cm -n kube-system|grep kube-proxy
kube-proxy 2 3h21m
[root@master01 ~]# kubectl edit cm kube-proxy -n kube-system
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30cf0317a4f623446c2aa72a0bf3ec52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4c776cf25243e387926bb289dbab59/" rel="bookmark">
			CTFshow web入门——文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Web 151考点：后端无验证，前端校验 Web 152考点：绕过前端校验 Web 153考点：文件后缀名，黑名单 Web 154-155考点：文件内容过滤，过滤关键字是php Web 156-158Web159Web 160考点：过滤了php，执行函数，反引号等 Web 161Web 162-163Web 164考点： png二次渲染 Web 165考点：jpg二次渲染 Web 166Web 167考点：Apache的包含解析 Web 168考点：免杀，过滤了好多执行函数 Web 169考点：免杀，主要是过滤了php, &lt;&gt;等 Web 170 Web 151 考点：后端无验证，前端校验 查看源码可以发现只能上传png图片
修改为php
写一个php文件上传一句话木马
可以发现已经成功上传
查看上级目录发现可疑文件
查看flag.php文件内容得出flag
Web 152 考点：绕过前端校验 解题思路：
经过一系列的方法测试上题的解题方法并不适用于本题。直接改前端，后端会校验，文件不合格。那就抓包一下。
将Content-Type内容修改成image/png，重发，发现成功上传
剩下的步骤与151相同查看上级目录，发现flag.php，查看flag.php内容得到flag
Web 153 考点：文件后缀名，黑名单 利用上传user.ini进行文件上传绕过
解题过程：
上传一个含木马的图片
接着上传.user.ini内容为 auto_append_file=“xxx”
xxx为我们上传的文件名。
这样就在每个php文件上包含了我们的木马文件。
查看/upload目录下是否上传成功，木马上传成功
Web 154-155 考点：文件内容过滤，过滤关键字是php 上传一个图片木马，发现上传不了，经过一系列的尝试发现是对文件内容作了些过滤，过滤了php，所以采用简短的语句进行绕过
这一步和上题相似
发现已经上传成功
得到flag
Web 156-158 在前面的基础上过滤了[]那我们直接用{}来代替
&lt;?=eval($_POST{1});?&gt; 或者
那就直接输出flag算了，不搞一句话了。摊牌了，反正知道flag位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4c776cf25243e387926bb289dbab59/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/150/">«</a>
	<span class="pagination__item pagination__item--current">151/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/152/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>