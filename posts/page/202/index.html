<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c27fe4b1a45fca678faa96b4efb0be/" rel="bookmark">
			Flink SQL深度篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink SQL深度篇 问题导读 怎样优化Logical Plan?怎样优化Stream Graph?TimeWindow, EventTime, ProcessTime 和 Watermark 四者之间的关系是什么? 序言 时效性提升数据的价值, 所以 Flink 这样的流式 (Streaming) 计算系统应用得越来越广泛.
广大的普通用户决定一个产品的界面和接口. ETL开发者需要简单而有效的开发工具, 从而把更多时间花在理业务和对口径上. 因此流式计算系统都趋同以 SQL 作为唯一开发语言, 让用户以 Table 形式操作 Stream.
程序开发三部曲：First make it work, then make it right, and, finally, make it fast.
让程序运行起来
开发者能用 SQL 方便地表达问题.开发者能通过任务管理系统一体化地管理任务, 如：开发, 上线, 调优, 监控和排查任务. 让程序运行正确
简单数据清洗之外的流计算开发需求通常会涉及到 Streaming SQL 的两个核心扩展：Window 和 Emit.开发者深入理解 Window 和 Emit 的语义是正确实现这些业务需求的关键,否则无法在数据时效性和数据准确性上做适合各个业务场景的决策和折中. 让程序运行越来越快
流计算系统每年也会有很大的性能提升和功能扩展, 但想要深入调优及排错, 还是要学习分布式系统的各个组件及原理, 各种算子实现方法, 性能优化技术等知识.
以后, 随着系统的进一步成熟和完善, 开发者在性能优化上的负担会越来越低, 无需了解底层技术实现细节和手动配置各种参数, 就能享受性能和稳定性的逐步提升.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c27fe4b1a45fca678faa96b4efb0be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3a0c7675e5e3d9c533cb29e55a33e62/" rel="bookmark">
			python没有错误但是不显示结果_【Python错误总结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from import : 从车里把矿泉水拿出来，给我
import : 把车给我
import datetime
print(datetime.datetime.now())
是引入整个datetime包
from datetime import datetime
print(datetime.now())
是只引入datetime包里的datetime类
所以import之后前者是datetime这个包可见 后者是datetime.datetime这个类可见
2. ImportError: No module named 'cookielib'1
Python3中，改成 import http.cookiejar,然后方法里也改成 http.cookiejar，查找替换就行
3. NameError: name 'raw_input' is not defined
在版本3中已经用input()替换
4. Import error: No module name urllib
from urllib.request import urlopen
5. ImportError: No module named urllib2
Python 3中urllib2用urllib.request替代
6、TypeError: write() argument must be str, not bytes
文件打开的方式有问题。
之前文件打开的语句是：
f=open("list.pkl","w+")
然后使用二进制方式打开就没有这个问题：
f=open("list_account.pkl","wb+")
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3a0c7675e5e3d9c533cb29e55a33e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62e912a1878ed75a6285f199d35df23/" rel="bookmark">
			MySQL 计算字符串字段中逗号分隔计数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：计算字段aa的逗号分隔数字个数
解决方案：（来自一位大佬的指导）
用原字符串长度 减 替换了逗号后的字符串长度，就是逗号个数，加1就是逗号分隔的字符串个数
select aa, CHAR_LENGTH(aa)-CHAR_LENGTH(REPLACE(aa,',','')) + 1 as bb from `test`;
或者tableau 对字符串进行度量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b410bc455508d889c488f91d46c022c/" rel="bookmark">
			python如何创建txt_python实现对文件中图片生成带标签的txt文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面为大家分享一篇python实现对文件中图片生成带标签的txt文件方法，具有很好的参考价值，希望对大家有所帮助。一起过来看看吧
在深度学习中经常需要生成带标签的图片名称列表，xxxlist.txt文件，下面写一个简单的python脚本生成该文件列表。
import os
def generate(dir,label):
files = os.listdir(dir)
files.sort()
print '****************'
print 'input :',dir
print 'start...'
listText = open(dir+'\\'+'list.txt','w')
for file in files:
fileType = os.path.split(file)
if fileType[1] == '.txt':
continue
name = file + ' ' + str(int(label)) +'\n'
listText.write(name)
listText.close()
print 'down!'
print '****************'
if __name__ == '__main__':
generate('C:\\Users\\Desktop\\image',1)
运行该脚本，会在image文件夹中生成一个list.txt文件，并且每张图片带有标签1.
相关推荐：
以上就是python实现对文件中图片生成带标签的txt文件方法的详细内容，更多请关注php中文网其它相关文章！
本文原创发布php中文网，转载请注明出处，感谢您的尊重！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1345e9aa8bb1c9ed8901b011b780160/" rel="bookmark">
			Flutter中PageView的滑动开始监听、完成监听自定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近Flutter项目开发中，用到了PageView的上下滚动，但是正常的PageView的使用，onPageChanged的回调，在页面滑到中间的时候，就会把下一个页面的pageIndex值传递过来。但是实际需求中，我需要知道什么时候页面滑动结束，这时候才去执行页面完全展示的方法。所以就需要对PageView进行自定义改造。
一、尝试了使用系统自带的PageController进行滑动监听，失败 开始尝试使用系统给的api进行监听
结果发现，返回的offset和page是Double类型的，更坑爹的是，在某些手机或者滑动距离过长时，返回的数据不够精准，没办法准确判断是否滑动完成。一看不能用，没办法在系统的api里面找到解决办法，就只能看源码了
二、查看PageView的源码，自定义pageView 查看系统源码，看看为什么会出现onPageChanged在中间的时候就返回回调了。在查看源码过程中，发现以下神奇的地方：
根据源码我们能看到，PageView在实际上也是通过NotificationListener进行的监听，而且在onPageChanged的返回前，判断了notification is ScrollUpdateNotification。
ScrollUpdateNotification是什么呢？这就需要我们看一下NotificationListener的回调监听了，也就是返回的ScrollNotification这个类。
点击进去看到ScrollUpdateNotification继承ScrollNotification，那是不是还有其他的监听回调类型，可以实现我们的需求呢？果然最后源码中发现，还有ScrollStartNotification、OverscrollNotification、ScrollEndNotification和UserScrollNotification四种滑动回调类型！
既然我们想要的是滑动完成的回调，就只需要在NotificationListener判断ScrollEndNotification这个滑动类型就行了。
还有OverscrollNotification和UserScrollNotification两种滑动类型没有用到，有其他用到的小伙伴可以告诉我这两个回调可以用在什么场景下。
自定义的PageView全部代码如下：
// Copyright 2016 The Chromium Authors. All rights reserved. // Use of this source code is governed by a BSD-style license that can be // found in the LICENSE file. import 'dart:async'; import 'dart:math' as math; import 'package:flutter/cupertino.dart'; import 'package:flutter/rendering.dart'; import 'package:flutter/gestures.dart' show DragStartBehavior; import 'package:flutter/foundation.dart' show precisionErrorTolerance; ///自定义的PageView ///新增了页面加载开始和结束的回调 final PageController _defaultPageController = PageController(); const PageScrollPhysics _kPagePhysics = PageScrollPhysics(); class CustomPageView extends StatefulWidget { /// Creates a scrollable list that works page by page from an explicit [List] /// of widgets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1345e9aa8bb1c9ed8901b011b780160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ce7a9d6fd5d0488b0a8d1e35cb46b9c/" rel="bookmark">
			php使用yield进行大量数据处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在处理大量数据，比如100万数据导入数据库，一般常规方法如果使用普通循环做逐个处理，很快会导致内存崩溃，无法实现正常的处理。php提供了yield方法来处理。我们看看如何来做的吧。
for($i=0;$i&lt;1000000;$i++){ echo $i;	//这里处理业务数据 } 我们看到上面是，普通循环100万次处理，这样处理如果仅输出$i，比较小，但累计起来也会使电脑变得很慢，直至内存耗尽程序崩溃，如果是数据导入，需要每次连接数据库非常耗内存操作的话，会很快崩溃。所以这种方法不可行，原因是什么呢。这种方式逐次累加消耗内存，一直不会减少，所以会耗尽内存。这样便有了yield方式的处理，php的yield生成器。“生成器yield的优雅体现在每次产出一个值之后，生成器的内部状态都会停顿；向生成器请求下一个值时，内部状态又会恢复。生成器内部的状态会一直在停顿和恢复之间切换，直到抵达函数定义体的末尾或遇到空的 return 语句为止。“，我们可以理解上述语句，可以看出yield生成器，是通过逐个生成值，先停顿休息一下，等处理完后，释放内存，再继续处理下一个，这样内存得到休整，不会被耗尽崩溃，使性能得到很大提升。
注意，yiled必须被包装成函数调用，否则会提示“The "yield" expression can only be used inside a function”。
//构造yield生成器 function make_i(){ for($i=0;$i&lt;1000000;$i++){ yield $i;	} } $i_arr=make_i(); //循环生成的数组 foreach($i_arr as $item){ echo $item.'&lt;br&gt;'; //这里处理业务数据 } 上述代码，这样改进一下处理，我们就可以完成大量数据的处理，内存不会崩溃了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7643c6157cb13fb751ac8866fa3fb5d1/" rel="bookmark">
			循环中 动态参数 传div 层_通过GSAP让vue实现动态效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址: https:// blog.usejournal.com/vue -js-gsap-animations-26fc6b1c3c5a 原文作者: Daily Fire 翻译作者: hanxiansen 中文标题：通过GSAP让vue实现动态效果 单页应用及支持它们的前端框架提供了一个很好的机会，可以为程序设计提供令人惊叹的交互层，本文，我们将了解 vue.js 及如何集成 GASP 动画库来添加令人惊叹的动画效果。 Vue.js 是一个功能强大且易掌握的 JS 框架，在 Vue CLI 的帮助下，我们能够快速构建具有所有最新 Webpack 功能的应用程序，而无需花费时间来配置 webpack，只需安装 Vue CLI，在重大上输入:create &lt;project-name&gt;，您就可以发车了。
GASP是一个JavaScript动画库，它支持快速开发高性能的 Web 动画。GASP 使我们能够轻松轻松快速的将动画串在一起，来创造一个高内聚的流畅动画序列。
在构建新的 Daily Fire 主页时，我为了演示产品如何工作而使用了大量动画，但是通过 GASP的方式（不是 GIF 或视频），我可以为动画添加交互层使它们更具吸引力。如你所见，将 GASP 与 vue相结合是简单且强大的，
让我们看看如何使用 GASP 与 VUE 实现简单的时间轴，我们将在本文使用 .vue 文件，这些文件由 webpack 的 vue-loader加载使用，通过Vue CLI创建的项目将会自动
基础 让我们先编写一些标记，以便了解我们将制作的动画
&lt;template&gt; &lt;div ref="box" class="box"&gt;&lt;/div&gt; &lt;/template&gt; &lt;style&gt; .box { height: 60px; width: 60px; background: red; } &lt;/style&gt; 我们将一个红色 box 绘制到DOM中，注意 div 标签上的ref 标记，当我们在引入GASP 后通过该属性可以引用该元素。VUE 通过组件的$refs属性使通过 ref 标记的元素可以使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7643c6157cb13fb751ac8866fa3fb5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/222362213bc16c73f500029cfb1c4041/" rel="bookmark">
			树型列表结构宽度调整_css揭秘-结构与布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自适应内部元素 难题
我们都知道，如果不给元素指定一个 height，它就会自适应其内容的高度，如果希望 width 也具有类似的行为，应该怎么做呢？
解决方案
css3 给 width 定义了一些新的关键字，其中最有用的应该就是 min-content 了，这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素），样式中的固定的 max-width 是为了给旧版的浏览器提供一个平稳的回退样式。
&lt; 根据兄弟元素的数量设置样式 难题
在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。最常见的场景就是，当一个列表不断延长时，通过隐藏控件或压缩控件等方式来节省屏幕空间，以此提升用户体验。
解决方案
如果列表中只有一个列表项时，可以使用 :only-child 选择符来完成。
li 实际上，:only-child 等效于 :first-child:last-child，道理很简单：如果第一项同时也是最后一项，那从逻辑上来说它就是唯一的那一项。 :last-child 其实也是一个快捷写法，相当于 :nth-last-child(1) ：
li 那么，同时匹配 :first-child 和 :nth-last-child(4) 的元素是什么呢？一个正好有四个列表项的列表中的第一个列表项，现在已经找到一种命中特定数量列表项中第一项的方法，接下来就可以用兄弟选择符（ ~ ）来命中它之后的所有兄弟元素：相当于在这个列表正好包含四个列表项时，命中它的每一项。
li 这个方法需要的代码相当冗长繁琐，可以使用预处理器来避免这个问题。
/* 定义mixin */ 根据兄弟元素的数量范围来匹配元素
li 满幅的背景，定宽的内容 难题
要实现如上图所示的效果，通常会准备两个元素：外层用来实现满幅的背景，内层用来显示定宽的内容，后者通过 margin:auto 实现居中的。
&lt; 难道为了这个效果就一定要添加一层额外的元素？能否在现代 CSS 的帮助下彻底抛弃这个累赘？
解决方案
用 calc() 取代原先的 auto ，内层容器的样式就会变成：
. 也可以将这个长度值应用到父元素的 padding 上，整个效果是保持不变的：
footer 精确控制表格列宽 难题
对于不固定的内容来说，表格的布局是很难预测的，因为列宽会根据表格的内容进行调整，即时我们显式的指定了列宽 width，也只能起到类似的作用。鉴于这个原因，我们往往不得不使用其他元素来呈现表格型数据，或者干脆接受布局效果的不可预测性。有没有什么办法可以让表格的行为更加可控呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/222362213bc16c73f500029cfb1c4041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c08f7ca382af840c3993e083d56f85/" rel="bookmark">
			java配置环境变量2020最新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载JDK JDK官方下载：www.oracle.com 选择对应的系统安装 2. 打开环境变量 1.右击此电脑选择属性
2.点击高级系统设置
3.点击环境变量
3.配置环境变量 1.新建
变量名：JAVA_HOME
变量值：你的JDK路径
2. 新建
变量名：CLASSPATH
变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
3. 在系统变量找到path点击编辑
点击新建将【%JAVA_HOME%\bin】和【%JAVA_HOME%\jre\bin】加入Path的变量值中最后记得点击确定。
4. 查看JDK是否安装成功 Windows+R命令大全输入cmd
输入java和javac看是否有显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387d91bfddd00d5f90a5d3ae7d5b8ffa/" rel="bookmark">
			antimalware service executable占用内存过高_Win10系统svchost.exe进程占用内存和网速过高的解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用Windows10系统的过程中，不少用户一旦发现电脑异常，例如异常卡顿，就会查看一下任务管理器，是否有进程过高占用了CPU、内存、网络等，而在任务管理器中发现了一个名称为“svchost.exe”进程，大量占用了电脑的内存和网速资源，其实svchost.exe并非是病毒程序，而是Windows系统中的一个系统程序，从动态链接库(DLL)中运行的服务的通用主机进程名称，那么我们要如何设置让它不占用内存和网速？下面装机之家分享一下Win10系统svchost.exe进程占用内存和网速过高的解决方法。
svchost.exe进程
操作步骤：
1、首先我们在此电脑右键点击，弹出菜单之后，我们点击“管理”，如下图所示。
2、我们鼠标双击进入“服务和应用程序”，再双击进入“服务”，如下图所示。
3、我们在服务中找到“Background Intelligent Transfer Service”，并双击进入，启动类型修改为“手动”，并停止该服务，最后点击“确定”按钮。
4、为了防止它自动打开，我们可以在恢复选项卡中，第一次失败和第二次失败以及后续失败设置为“无操作”，如下图所示。
注：由于windows10版本不同，找下服务是否有“Superfetch”服务项，如果将启动类型设置为禁用，服务状态改为停止，点击应用，点击确定。
以上就是装机之家分享的Win10系统svchost.exe进程占用内存和网速过高的解决方法，希望本文能够帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57032d6b6e764f0af72a867161207896/" rel="bookmark">
			vue项目在ie浏览器input输入框刷新不清空_经验 | python 操作浏览器的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：selenium导入浏览器驱动，用get方法打开浏览器，例如：
import timefrom selenium import webdriverdef mac(): # browser = webdriver.Chrome() # browser = webdriver.Firefox() browser = webdriver.Ie() browser.implicitly_wait(5) browser.get('http://www.baidu.com/') 第二种：通过导入python的标准库webbrowser打开浏览器，例如：
import webbrowserdef mac(): # web.open(‘http://www.baidu.com’,new=0,autoraise=True) # new:0/1/2 0：同一浏览器窗口打开 1：打开浏览器新的窗口，2：打开浏览器窗口新的tab; autoraise=True:窗口自动增长 # web.open_new_tab(‘http://www.baidu.com’) web.open_new(‘http://www.baidu.com’) 第三种：使用Splinter模块模块
一、Splinter 的安装Splinter 的使用必修依靠 Cython、lxml、selenium 这三个软件。所以，安装前请提前安装 Cython、lxml、selenium。
二、Splinter 的使用
这里，我给出自动登录 126 邮箱的案例。难点是要找到页面的账户、密码、登录的页面元素，这里需要查看 126 邮箱登录页面的源码，才能找到相关控件的 id.
例如: 输入密码，密码的文本控件 id 是 pwdInput. 可以使用browser.find_by_id() 方法定位到密码的文本框，接着使用fill() 方法，填写密码。至于模拟点击按钮，也是要先找到按钮控件的 id, 然后使用 click() 方法。
# coding=utf-8import time from splinter import Browserdef splinter(url): browser = Browser() # login 126 email websize browser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57032d6b6e764f0af72a867161207896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbebfa47f7e6fa02bf0659f777132677/" rel="bookmark">
			VS Code 使用火狐 FireFox 调试网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 总览使用 `launch` 模式进行调试使用 `Attach` 模式进行调试Skipping ("blackboxing") filesPath mappingDebugging WebExtensionsFurther optional configuration propertiesOverriding configuration properties in your settingsTroubleshooting后话 总览 安装 Debugger For Firefox 扩展设置配置文件（根据模式，操作有所不同）启动调试 先了解一下有哪些调试模式 mode：
launch：每次调试会创建一个新的浏览器进程，并在停止测试时同时结束进程。 re-Attach: true：在停止测试的时候不结束进程，可以再次测试时重新附加调试，加快速度。 re-Attach 也适合 WebExtension debugging，每次测试，浏览器插件会被作为一个临时扩展重新安装 attach：会在已存在的浏览器进程上附加调试，这个进程需要手动开启允许远程调试。可以调试网络上的已有网页。 以下参考自 Debugger For Firefox - Visual Studio Marketplace 的说明，翻译融合了一下。
使用 launch 模式进行调试 一般情况 { "version": "0.2.0", "configurations": [ { "name": "Launch index.html", "type": "firefox", "request": "launch", "reAttach": true, // 启用 reAttach "file": "${workspaceFolder}/index.html" // 调试工作区下的 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbebfa47f7e6fa02bf0659f777132677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4321b2e5369875d0bcf230fb0fb50174/" rel="bookmark">
			机器学习分类算法_机器学习分类算法(一)逻辑回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑回归算法原理推导 逻辑回归属于分类算法，做的是分类任务，是一种经典的二分类算法！因为应用的比较广泛，且表现效果不错。如果做的是分类任务，可以先考虑逻辑回归。也可以使用逻辑回归解决多分类问题(softmax)机器学习算法选择：先逻辑回归再用复杂的，能简单还是用简单的。越复杂的结构内部解释起来越复杂，越简单的结构内部解释起来越简单。逻辑回归的决策边界：可以是非线性的 Sigmiod函数 公式：自变量取值为任意数，值域[0,1]解释：将任意的输入映射到了[0,1]区间。我们在线性回归中可以得到一个预测值，再将该值映射到SIgmoid函数中，这样就完成了由值到概率的转换，如果结果大于50%可以设定为0，如果小于50%可以设定为1，也就是分类任务。预测函数：其中，， 输入是,有多少个特征就有多少个输入。分类任务：，整合一下就是解释，对于二分类任务(0,1),整合后y取0只保留，y取1只保留 逻辑回归求解 似然函数：对数似然：此时应用梯度上升求最大值，引入转换为梯度下降任务，求正数的最大值，也就是求负数的最小值。求导过程。计算每个参数梯度方向，计算出偏导数。求解什么样的方式是最合适的，有多少个就对多少个求偏导 其中表示第几个样本,表示第几个特征 1/m表示综合考虑所有样本 *多分类的softmax
逻辑回归手写算法实现 我们先来简单看个例子，使用逻辑回归预测学生能否被录取。我们将建立一个逻辑回归模型来预测一个学生是否被大学录取。假设你是一个大学的管理员你想根据两次考试的结果来决定每个申请人的录取机会。你有以前的申请人的历史数据，你可以根据它作为逻辑回归的训练集。对于每一个培训例子，你有两个考试的申请人的分数和录取决定。为了做到这一点，我们将建立一个分类模型，根据考试成绩估计入学概率。
1.读取数据
pdData=pd.read_csv('LogiReg_data.txt',header=None,names=['Exam1','Exam2','Admitted']);
print(pdData.shape)
print(pdData.head())
2.将数据集中的正类(1:同意入学)和负类(0:拒绝入学)可视化
positive=pdData[pdData['Admitted']==1]
negative=pdData[pdData['Admitted']==0]
fig,ax=plt.subplots(figsize=(10,5))#指定画图域的大小
ax.scatter(positive['Exam1'],positive['Exam2'],s=30,c='b',marker='o',label='Admitted')
ax.scatter(negative['Exam1'],negative['Exam2'],s=30,c='r',marker='x',label='Not Admitted')
ax.legend()
ax.set_xlabel("Examl Score")
ax.set_xlabel('Exam2 Score')
plt.show()
其中，横坐标是Exam1，纵坐标是Exam2，通过和不通过的数据颜色分别设置成蓝色和红色，用圆圈和叉号表示数据分布，标签设置成Admitted和Not Admitted.
从图中可以很容易看出啊，有一条决策边界可以将数据完美分开。
我们接下来就是用上面所说的案例和数据，手写逻辑回归算法。
梯度下降求解逻辑回归 目标：建立分类器，求解出三个参数，，，其中，代表两列考试成绩的参数，代表偏置项的参数。
设定阈值，根据阈值判断录取结果，阈值我们一般取0.5，大于0.5表示被录取，小于0.5表示没有被录取。
要完成的模块：
sigmoid：映射到概率的函数model：返回预测结果值cost：根据参数计算损失值gradient：计算每个参数的梯度方向descent：进行参数更新accuracy：计算精度 sigmoid：映射到概率的函数 def sigmoid(z):
return 1/(1+np.exp(-z))
参数z是线性回归传过来的值，通过sigmoid函数，将数值转换为0-1之间的概率值。
为了对sigmoid函数有更好的理解，我们可视化这个函数。
nums=np.arange(-10,10,step=1)
fig,ax=plt.subplots(figsize=(10,4))
ax.plot(nums,sigmoid(nums),'r')
plt.show()
横坐标是-10~10之间的数字，步长是1。
model：返回预测结果值 def model(X,theta):
return sigmoid(np.dot(X,theta.T))
在这里，我们需要两个参数X和,预测结果的公式可以这样表示
这里的，，分别表示偏置项参数、第一个成绩的参数、第二个成绩的参数。，，分别代表偏置项、第一个成绩和第二个成绩。
也就是预测函数：
我们首先获取包含偏置项的X数据和预先定义的theta参数：
pdData.insert(0,'ones',1) #数据中插入一列都是1，列名是ones
orig_data=pdData.as_matrix() #将数据转换成数组
cols=orig_data.shape[1] #查看数组列数
X=orig_data[:,0:cols-1]
y=orig_data[:,cols-1:cols]
theta=np.zeros([1,3])
本来是3列，现在变成4列：偏置项、两列成绩和标签。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4321b2e5369875d0bcf230fb0fb50174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc23e07c2255d087553c5c546b72639/" rel="bookmark">
			推荐系统----Dual Channel Hypergraph Collaborative Filtering
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(在这篇工作的ACM网页上, 有作者的视频讲解, 比看文章好) 算法核心: 输入: E_u0: user_embedding的初始化E_i0: item_embedding的初始化H: 由邻接矩阵构造的关联矩阵(incidence matrix)(嗯, 这篇文章甚至都不是用关联矩阵, 而是用邻接矩阵)第一步: (注意: 这里的超图和有些部分的超图的构造不太一样: 有些地方首先是超边的构造, 使用k近邻算法, 然后通过超边和结点的关系构造关联矩阵)(超图运算的核心: 构造关联矩阵H, 并使之参与运算)得到user的超图H_u得到item的超图H_i第二步: (每层) user学到高阶连通性的表征M_uitem学到高阶连通性的表征M_i第三步: (每层) 得到这一层user的embedding: E_u得到这一层item的embedding: E_i第四步: 将各层的embedding连接, 得到最后的E_u, E_i 作者卖点: JHConv: 即, 将原本的超图卷积运算+输入的初始X, 得到一个残差图卷积引入超图的结构，构建跳跃超图卷积JHConv，提取高阶关系。 双通道超图结构: 解决: 用户和物品建模不灵活。双通道建模，采用分而治之的策略，既整合用户和物品信息，又保持用户和物品各自特性。 摘要: 从矩阵分解到新兴的基于图的方法，在训练数据非常有限的情况下表现不佳（数据稀疏问题）。现有基于 CF 的方法固有的两个缺点，即: 1)用户和物品建模不灵活; 2)高阶相关性建模不足。首先，引入双通道学习策略(Dual-Channel)，全面利用分治策略，学习用户和物品的表示，使这两种类型的数据可以优雅地相互连接，同时保持其特定属性。其次, 利用超图结构对用户和具有显式混合高阶相关性的物品进行建模。提出了跳跃超图卷积(JHConv)方法，实现高阶关系嵌入的显式和有效传播。 与作者组之前的工作的辨析: 之前是一个图结点分类问题, 可以看作是一个同构图. 结点之间的可以度量距离. 使用KNN做超边的 而协同过滤是一个ui异构图, 所以, 超图的构建使用KNN不够合理. 所以, 超边换了另外一种方式形成.每一跳的邻居构成一个超边 因为二分图需要两种结点关联的交互, 所以, 使用第一步的方式构建了两个名义上的"同够超图", 或者说让u和i足够产生关联, 但是又的的确确是代表u和i各自的矩阵 VS (之前的工作本身就是同够的, 所以不用构建) 参考文章(这篇文章其实挺好的, 懒得看英文可以直接看): https://www.jianshu.com/p/37c500da5ecb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad6e560718cb5245e67d6e91dc20ac3/" rel="bookmark">
			函数拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从今天开始，专注于GAMES102。
渲染成像：光的计算科学。真实感渲染：照片级的渲染。
仿真动画：运动的计算科学。真实感仿真：物理级的运动。
计算机图形学就是在创建虚拟世界。但是巧妇难为无米之炊，几何建模就是给图形学提供数据。
数学是自然科学的语言，一种对客观世界规律进行描述的符号系统。应该培养一种数学思维和数学建模能力。
集合就是一堆具有同样性质的元素。
函数的集合被称为函数空间，空间的完备性就是这个函数空间是否可以逼近任意函数。
万能逼近定理：闭区间上的连续函数可用多项式级数一致逼近，闭区间上的周期函数可用三角函数一致逼近。
大部分的实际应用问题可建模为寻找一个映射、变换、函数，寻找函数的三个步骤：
到哪找？确定某个函数集合/空间找那个？度量哪个函数是好的或是最好的怎么找？求解或优化 曲线/曲面拟合问题：
输入：一些采样点集 输出：一条拟合这些点集的曲线/曲面 首先，我们要选择一个函数空间，然后求解待定系数。
有时候，我们并不一定需要零误差，这时候就可以用逼近。
有时候会产生欠拟合和过拟合现象，这时候就要不断尝试调参。
避免过拟合的常用方法：
数据去噪：剔除训练样本中噪声数据增广：增加样本数，或者增加样本的代表性和多样性模型简化：选用更简单的模型，或者对模型进行裁剪正则约束：适当的正则项，比如方差正则项、稀疏正则项 Focus on GAMES102.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a12e9fe2e78ec346ad626c7ac006fb0/" rel="bookmark">
			unity自学的第四天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创造敌人类 一、敌人类的脚本二、具体代码1.HP2.Fight3.Enemymove 总结 一、敌人类的脚本 1、HP组件(生命)
2、fight组件(攻击)
3、enemymove组件(移动)
二、具体代码 1.HP public class HP : MonoBehaviour { public int hppoint = 100; void Update() { if (hppoint &lt;= 0) Destroy(gameObject);//gameObject为物体 } public void HpCutdown(int x)//掉血 { hppoint = hppoint - x; } } 2.Fight public class fight : MonoBehaviour { private void OnCollisionEnter(Collision collision) { if (collision.gameObject.tag == "Player")//如果碰撞到标签为“Player”就执行下面的 { collision.gameObject.GetComponent&lt;HP&gt;().HpCutdown(100); } } } 3.Enemymove public class enemymove : MonoBehaviour { GameObject go; public float speed; public float look = 100; void Update() { go = GameObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a12e9fe2e78ec346ad626c7ac006fb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb35cc0e3c44e2b46f0fb3f220a19ccd/" rel="bookmark">
			docker image存储路径_云原生存储详解：容器存储与 K8s 存储卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 阚俊宝 阿里云技术专家
导读：云原生存储详解系列文章将从云原生存储服务的概念、特点、需求、原理、使用及案例等方面，和大家一起探讨云原生存储技术新的机遇与挑战。本文为该系列文章的第二篇，会对容器存储的相关概念进行讲述，欢迎大家在留言区参与讨论。
云原生存储的两个关键领域：Docker 存储卷、K8s 存储卷；
Docker 存储卷：容器服务在单节点的存储组织形式，关注数据存储、容器运行时的相关技术；K8s 存储卷：关注容器集群的存储编排，从应用使用存储的角度关注存储服务。 Docker 存储 容器服务之所以如此流行，一大优势即来自于运行容器时容器镜像的组织形式。容器通过复用容器镜像的技术，实现在相同节点上多个容器共享一个镜像资源(更细一点说是共享某一个镜像层)，避免了每次启动容器时都拷贝、加载镜像文件，这种方式既节省了主机的存储空间，又提高了容器启动效率。
1. 容器读写层 为了提高节点存储的使用效率，容器不光在不同运行的容器之间共享镜像资源，而且还实现了在不同镜像之间共享数据。共享镜像数据的实现原理：镜像是分层组合而成的，即一个完整的镜像会包含多个数据层，每层数据相互叠加、覆盖组成了最终的完整镜像。
为了实现多个容器间共享镜像数据，容器镜像每一层都是只读的。而通过实践我们得知，使用镜像启动一个容器的时候，其实是可以在容器里随意读写的，这是如何实现的呢？
容器使用镜像时，在多个镜像分层的最上面还添加了一个读写层。每一个容器在运行时，都会基于当前镜像在其最上层挂载一个读写层，用户针对容器的所有操作都在读写层中完成。一旦容器销毁，这个读写层也随之销毁。
如上图所示例子，一个节点上共有 3 个容器，分别基于 2 个镜像运行。
镜像存储层说明如下：
该节点上共包含 6 个镜像层：Layer 1~6。
镜像 1 由：Layer 1、3、4、5 组成；镜像 2 由：Layer 2、3、5、6 组成。
所以两个镜像共享了 Layer 3、5 两个镜像层；
容器存储说明：
容器 1：使用镜像 1 启动容器 2：使用镜像 1 启动容器 3：使用镜像 2 启动
容器 1 和容器 2 共享镜像 1，且每个容器有自己的可写层；容器 1(2)和容器 3 共享镜像 2 个层(Layer3、5)；
通过上述例子可以看到，通过容器镜像分层实现数据共享可以大幅减少容器服务对主机存储的资源需求。
上面给出了容器读写层结构，而读写的原则：
对于读：容器由这么多层的数据组合而成，当不同层次的数据重复时，读取的原则是上层数据覆盖下层数据；对于写：容器修改某个文件时，都是在最上层的读写层进行。主要实现技术有：写时复制、用时配置。
1)写时复制 写时复制(CoW：copy-on-write)，表示只在需要写时才去复制，是针对已有文件的修改场景。CoW 技术可以让所有的容器共享 image 的文件系统，所有数据都从 image 中读取，只有当要对文件进行写操作时，才从 image 里把要写的文件复制到最上面的读写层进行修改。所以无论有多少个容器共享同一个 image，所做的写操作都是对从 image 中复制后在复本上进行，并不会修改 image 的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb35cc0e3c44e2b46f0fb3f220a19ccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb5701e43232db9df8065cae3b9a3ea/" rel="bookmark">
			第七章 用函数实现模块化程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7.1 为什么要用函数 函数就是功能。每一个函数用来实现一个特定的功能。函数的名字应反映其代表的功能。
一个C程序可由一个主函数和若干个其他函数构成。由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。
除了可以使用库函数外，有的部门还编写一批本领域或本单位常用到的专用函数，供本领域或本单位的人员使用。在程序设计中要善于利用函数，以减少重复编写程序段的工作量，也更便于实现模块化的程序设计。
＃include &lt;stdio.h&gt; int main() {void print_star();//声明print_star函数 void print_message(); //声明print_message函数 print_star();//调用print_star函数 print_message();//调用print_message函数 print_star();//调用print_star函数 return 0; } void print_star()//定义print_star函数 {printf("******************\n");} void print_message() //定义print_message函数 {printf("How do you do!\n");} 程序分析：
print_star和print_message都是用户自定义的函数名，分别用来输出一排"*“和一行文字信息。在定义这两个函数时指定函数的类型为void，意为函数无类型，即无函数值，也就是说，执行这两个函数后不会把任何值带回main函数。
在程序中，定义print_star和print_message函数的位置是在main函数的后面，在这种情况下，应当在main函数之前或main函数中的开头部分，对以上两个函数进行"声明”。函数声明的作用是把有关函数的信息(函数名，函数类型，函数参数的个数与类型)通知编译系统，以便在编译系统对程序进行编译时，在进行到main函数调用print_star( )和print_message( )时并知道它们是函数而不是变量或其他对象。此外，还对调用函数的正确性进行检查(如类型，函数名，参数个数，参数类型等是否正确)。
7.2 怎样定义函数 C语言要求，在程序中用到的所有函数，必须"先定义，后使用"。
定义函数应包括以下几个内容：
指定函数的名字，以便以后按名调用。指定函数的类型，即函数返回值的类型。指定函数的参数的名字和类型，以便在调用函数时向它们传递数据。对无参函数不需要这项。指定函数应当完成什么操作，即函数的功能。这是最重要的，是在函数体中解决的。 定义函数的方法
定义无参函数
类型名 函数名( )
{
函数体
}
或
类型名 函数名(void)
{
函数体
}
函数体包括声明部分和语句部分。定义有参函数
类型名 函数名(形式参数表列)
{
函数体
}
函数体包括声明部分和语句部分。 int max(int x,int y) { int z; //声明部分 z=x&gt;y?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eb5701e43232db9df8065cae3b9a3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91bd41f6510777e9f6591fb1be84b6a4/" rel="bookmark">
			mysql 多表联合查询_数据库 | MySQL多表查询综合练习及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、综合练习 1.1 init.sql文件内容
/* 数据导入： Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50624 Source Host : localhost Source Database : sqlexam Target Server Type : MySQL Target Server Version : 50624 File Encoding : utf-8 Date: 10/21/2016 06:46:46 AM*/SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `class`-- ----------------------------DROP TABLE IF EXISTS `class`;CREATE TABLE `class` ( `cid` int(11) NOT NULL AUTO_INCREMENT, `caption` varchar(32) NOT NULL, PRIMARY KEY (`cid`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of `class`-- ----------------------------BEGIN;INSERT INTO `class` VALUES ('1', '三年二班'), ('2', '三年三班'), ('3', '一年二班'), ('4', '二年九班');COMMIT;-- ------------------------------ Table structure for `course`-- ----------------------------DROP TABLE IF EXISTS `course`;CREATE TABLE `course` ( `cid` int(11) NOT NULL AUTO_INCREMENT, `cname` varchar(32) NOT NULL, `teacher_id` int(11) NOT NULL, PRIMARY KEY (`cid`), KEY `fk_course_teacher` (`teacher_id`), CONSTRAINT `fk_course_teacher` FOREIGN KEY (`teacher_id`) REFERENCES `teacher` (`tid`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of `course`-- ----------------------------BEGIN;INSERT INTO `course` VALUES ('1', '生物', '1'), ('2', '物理', '2'), ('3', '体育', '3'), ('4', '美术', '2');COMMIT;-- ------------------------------ Table structure for `score`-- ----------------------------DROP TABLE IF EXISTS `score`;CREATE TABLE `score` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `student_id` int(11) NOT NULL, `course_id` int(11) NOT NULL, `num` int(11) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_score_student` (`student_id`), KEY `fk_score_course` (`course_id`), CONSTRAINT `fk_score_course` FOREIGN KEY (`course_id`) REFERENCES `course` (`cid`), CONSTRAINT `fk_score_student` FOREIGN KEY (`student_id`) REFERENCES `student` (`sid`)) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8;-- ------------------------------ Records of `score`-- ----------------------------BEGIN;INSERT INTO `score` VALUES ('1', '1', '1', '10'), ('2', '1', '2', '9'), ('5', '1', '4', '66'), ('6', '2', '1', '8'), ('8', '2', '3', '68'), ('9', '2', '4', '99'), ('10', '3', '1', '77'), ('11', '3', '2', '66'), ('12', '3', '3', '87'), ('13', '3', '4', '99'), ('14', '4', '1', '79'), ('15', '4', '2', '11'), ('16', '4', '3', '67'), ('17', '4', '4', '100'), ('18', '5', '1', '79'), ('19', '5', '2', '11'), ('20', '5', '3', '67'), ('21', '5', '4', '100'), ('22', '6', '1', '9'), ('23', '6', '2', '100'), ('24', '6', '3', '67'), ('25', '6', '4', '100'), ('26', '7', '1', '9'), ('27', '7', '2', '100'), ('28', '7', '3', '67'), ('29', '7', '4', '88'), ('30', '8', '1', '9'), ('31', '8', '2', '100'), ('32', '8', '3', '67'), ('33', '8', '4', '88'), ('34', '9', '1', '91'), ('35', '9', '2', '88'), ('36', '9', '3', '67'), ('37', '9', '4', '22'), ('38', '10', '1', '90'), ('39', '10', '2', '77'), ('40', '10', '3', '43'), ('41', '10', '4', '87'), ('42', '11', '1', '90'), ('43', '11', '2', '77'), ('44', '11', '3', '43'), ('45', '11', '4', '87'), ('46', '12', '1', '90'), ('47', '12', '2', '77'), ('48', '12', '3', '43'), ('49', '12', '4', '87'), ('52', '13', '3', '87');COMMIT;-- ------------------------------ Table structure for `student`-- ----------------------------DROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `gender` char(1) NOT NULL, `class_id` int(11) NOT NULL, `sname` varchar(32) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_class` (`class_id`), CONSTRAINT `fk_class` FOREIGN KEY (`class_id`) REFERENCES `class` (`cid`)) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8;-- ------------------------------ Records of `student`-- ----------------------------BEGIN;INSERT INTO `student` VALUES ('1', '男', '1', '理解'), ('2', '女', '1', '钢蛋'), ('3', '男', '1', '张三'), ('4', '男', '1', '张一'), ('5', '女', '1', '张二'), ('6', '男', '1', '张四'), ('7', '女', '2', '铁锤'), ('8', '男', '2', '李三'), ('9', '男', '2', '李一'), ('10', '女', '2', '李二'), ('11', '男', '2', '李四'), ('12', '女', '3', '如花'), ('13', '男', '3', '刘三'), ('14', '男', '3', '刘一'), ('15', '女', '3', '刘二'), ('16', '男', '3', '刘四');COMMIT;-- ------------------------------ Table structure for `teacher`-- ----------------------------DROP TABLE IF EXISTS `teacher`;CREATE TABLE `teacher` ( `tid` int(11) NOT NULL AUTO_INCREMENT, `tname` varchar(32) NOT NULL, PRIMARY KEY (`tid`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;-- ------------------------------ Records of `teacher`-- ----------------------------BEGIN;INSERT INTO `teacher` VALUES ('1', '张磊老师'), ('2', '李平老师'), ('3', '刘海燕老师'), ('4', '朱云海老师'), ('5', '李杰老师');COMMIT;SET FOREIGN_KEY_CHECKS = 1; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91bd41f6510777e9f6591fb1be84b6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d9b7b35907c63f37e4c97fa129ef0b/" rel="bookmark">
			python升序和降序排序_python中sort和sorted排序的实例方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python list内置sort()方法用来排序，也可以用python内置的全局sorted()方法来对可迭代的序列排序生成新的序列。
1）排序基础
简单的升序排序是非常容易的。只需要调用sorted()方法。它返回一个新的list，新的list的元素基于小于运算符(__lt__)来排序。
&gt;&gt;&gt; sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]
你也可以使用list.sort()方法来排序，此时list本身将被修改。通常此方法不如sorted()方便，但是如果你不需要保留原来的list，此方法将更有效。
&gt;&gt;&gt; a = [5, 2, 3, 1, 4]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[1, 2, 3, 4, 5]
另一个不同就是list.sort()方法仅被定义在list中，相反地sorted()方法对所有的可迭代序列都有效。
&gt;&gt;&gt; sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
2）key参数/函数
从python2.4开始，list.sort()和sorted()函数增加了key参数来指定一个函数，此函数将在每个元素比较前被调用。 例如通过key指定的函数来忽略字符串的大小写：
&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d9b7b35907c63f37e4c97fa129ef0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800a9164f8b1528b23044f892b7c9cbd/" rel="bookmark">
			python计算2的n次方编写_python中n次方怎么表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的n次方用pow()方法来表示，pow()方法返回 xy（x的y次方）的值。
语法
以下是 math 模块 pow() 方法的语法：import math
math.pow( x, y )
内置的 pow() 方法pow(x, y[, z])
函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z
注意：pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。
参数
x -- 数值表达式。
y -- 数值表达式。
z -- 数值表达式。
返回值
返回 xy（x的y次方） 的值。
实例#!/usr/bin/python
# -*- coding: UTF-8 -*-
import math # 导入 math 模块
print "math.pow(100, 2) : ", math.pow(100, 2)
# 使用内置，查看输出结果区别
print "pow(100, 2) : ", pow(100, 2)
print "math.pow(100, -2) : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/800a9164f8b1528b23044f892b7c9cbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d7f6d4e51f7747c1f7c5d79ce37835c/" rel="bookmark">
			python求最值_python怎么求一个函数的最值?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我来举个穷举法的例子。
# 函数的功能为 x**2
def multi(x):
y = x**2
return y
# step 为尝试的步进值
def find(func, min_, max_, step=0.01):
i = min_
while min_ print(f'i={i:18} func(i)={func(i)}')
i += step
# 以 0.01 为步进值，打印 multi 函数在-1 和 2 区间的所有值
find(multi, -1, 2)
运行结果如下：
i= -1 func(i)=1
i= -0.99 func(i)=0.9801
i= -0.98 func(i)=0.9603999999999999
i= -0.97 func(i)=0.9409
i= -0.96 func(i)=0.9216
i= -0.95 func(i)=0.9025
i= -0.94 func(i)=0.8835999999999999
i=-0.9299999999999999 func(i)=0.8648999999999999
i=-0.9199999999999999 func(i)=0.8463999999999998
i=-0.9099999999999999 func(i)=0.8280999999999998
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d7f6d4e51f7747c1f7c5d79ce37835c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a35adf4f5adbc6f8b9eb67bb65c363d/" rel="bookmark">
			用什么软件写python_大家都用什么开发工具写python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
前提：用来2113做数据处理和相关的5261系统开发
刚学python时，面对简陋4102的官方版idle和一大堆开发平台和发行1653版，不知道究竟如何下手。在进行多方尝试后，我最后的选择是Anaconda + Pycharm，用anaconda集成的ipython做工作台，做一些分析和小段程序调试的工作，用Pycharm写相应脚本和程序包的开发。这两个工具都是跨平台的，也都有免费版本。
具体来说Anaconda集成了几乎所有我需要的包库，包含了我整个工作流程，做数据分析的pandas\scipy\numpy、绘图的matplotlib、读写Excel文档的xlrd/xlwt，链接SQL数据库的SQLalchemy、机器学习框架sklearn等。对于Anaconda集成的两个工作平台，Spyder——一个类似于Matlab和Rstudio的IDE，是专注于面向数据的分析的，因为其特点也主要是数据区的存在，可以即时知道变量值的变化；Ipython——一个基于cell的shell界面，可以理解为python自带shell的增强版，它将程序分成一块一块的cell，每个cell可以包含多条语句，可以单独调试运行，并将结果保存在内存中，cell之间可以相互调用，并保持一定的相互独立。
可以说有了anaconda自带的这两个工具，足够做数据处理相关的工作了（本身anaconda就是一个为了数据科学而诞生的发行版），但如果涉及到脚本程序和包的开发，感觉spyder还是有点弱，在试过IDE，代码编辑器（比如visual code、sublime等）+插件，这两种方案后，我最后选择了集成度更高的成熟IDE——Pycharm替换spyder作为主要的开发平台，看我头像也可以知道我是一个喷气大脑的死忠，他们家的IDE真的很好用~理由如下：
1、首先作为学生，可以通过edu邮箱申请到Jetbrains全家桶，即便无法获取授权，pycharm的community版本免费并且功能足够
2、对于pycharm，可以方便快捷地切换python不同版本的解释器，甚至可以安装相同版本的python解释器配置不同的开发环境，这可以解决有些包之间冲突的情况，也可以针对有些框架按需装包；并且pycharm内置包管理，可以免去pip或者conda方式管理包。
3、pycharm这个IDE的颜色方案、拼写补全、函数联想、函数跳转源代码、断点调试及debug等功能都让我用的十分顺手。
总之我现在的工作流程就是，先用对我需要的功能进行设计，而后在ipython界面下设计调试每个功能模块，调试成功后放到pycharm中组合起来，写成脚本文件，最后用pycharm做调试形成成品。
2017、10、25 补充：
Pycharm作为IDE还有两个功能值得使用，一个是可以结合unitest包做我们开发模块的单元测试，另一个就是与svn、git等版本工具合作进行我们程序的版本控制，此外，在最新版的pycahrm当中，除了左侧折叠显示程序层次，下方也有我们当前光标所在位置对应的层次，并可以方便进行跳转。
总之，用pycharm写python真是越用越顺手~
已赞过
已踩过&lt;
你对这个回答的评价是？
评论
收起
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a9ab92bba950a25dffa825d32e3876b/" rel="bookmark">
			python怎么用split字符串全部分开_Python中通过多个字符分割（split）字符串的方法--转载...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原博文
2017-03-29 16:00 −
Python中字符串自带的split方法一次只能使用一个字符对字符串进行分割，但是python的正则模块则可以实现多个字符分割 import re re.split('_#|','this_is#a|test') 1 2 1 2 返回的是一个列表（list），输出结果如下： ['this', ...
相关推荐
2019-12-24 15:06 −
函数如下：
1 create or replace FUNCTION fn_rme_split(p_str IN VARCHAR2,
2 p_delimiter IN VARCHAR2)
3 RETURN rme_split
4 PIPELI...
0
274
2019-12-11 10:11 −
首先来看 MapReduce 流程图
一个 map，一个 reduce，中间靠 shuffle 连接，shuffle 左边被划分到 map，右边被划分到 reduce
InputFormat
input 是个文件，进入 mapper 后变成一行一行，如何实现的呢？
在 h...
2019-12-05 15:00 −
split()方法是对字符串的操作；splice()和slice()是对数组的操作。slice()也可用于字符串。
一、作用对象
1、split()方法是对字符串的操作；splice()和slice()是对数组的操作。slice()也可用于字符串。
二、参数
1、split(separator,how...
0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a9ab92bba950a25dffa825d32e3876b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287f5b2bf1dfb928cbe0cac7fb80c5ce/" rel="bookmark">
			网络安全类学习资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录分类 媒体社区类安全公司类应急响应类安全团队类高校社团类CTF类个人类web安全类网络运维类安全研发类二进制安全类硬件安全类其他 媒体社区类 媒体、资讯、社区
网络安全和信息化 :- 《网络安全和信息化》（原《网络运维与管理》）杂志官方所属，IT运维管理人员的专业管理类经验、知识、资料。提高IT基础设施运营水平，提高IT管理人员工作能力。i春秋 :- 专业的网络安全、信息安全、白帽子技术的培训平台及学习社区，78万安全用户的精准推荐。合天智汇 :- 为广大信息安全爱好者提供有价值的文章推送服务！极客公园 :- 用极客视角，追踪你最不可错过的科技圈。实验楼 :- 实验楼是100万+技术学习者关注的IT在线实训平台，提供海量免费教程、技术干货和在线实验环境。官网www.shiyanlou.comGeekPwn :- GeekPwn，全球首个关注智能生活的安全极客大赛！我们在寻找可能默默无闻但出类拔萃—注定可以改变世界、可以和我们一起保护未来的正能量—顶级 Geek 的思路、敢于 Pwn 破禁锢的你，这里是你的舞台，一起来，做到“极棒”！安在 :- 人物、热点、互动、传播，有内涵的信息安全新媒体。青藤云安全资讯 :- 青藤云安全是最理解中国互联网企业的安全伙伴，这里我们一起关注互联网企业安全那些事。FreeBuf :- 国内网络安全行业门户黑白之道 :- 我们是网络世界的启明星，安全之路的垫脚石。SecWiki :- 汇集国内外优秀安全资讯、工具和网站，只做高质量聚合与评论，每天一篇优秀资讯推荐。V安全资讯 :- V安全资讯是隶属于丝路安全团队（SRsec）旗下的一个以分享网络安全技术文稿和网络前端安全资讯的自媒体平台，在这里你可以学习别人的技术和心得，你也可以在这里分享你的学习成果和心得体会！我们期待着您的分享！安全牛 :- 发现、挖掘与推荐、传播优秀的安全技术、产品，提升安全领域在全行业的价值，了解机构与企业的安全需求，一家真正懂安全的专业咨询机构，我们是安全牛！长亭安全课堂 :- 长亭科技专注于为企业提供网络安全解决方案。分享专业的网络安全知识，网络威胁情报。E安全 :- E安全 | 全球网络安全资讯新传媒 新版门户站点：http://www.easyaq.com/安全客 :- 打破黑箱 客说安全网络空间安全军民融合创新中心 :- 作为军地沟通、军地协同的网络空间安全发展产业平台，聚焦网络空间国防安全领域，探索建立网络国防安全建设创新发展模式，致力于打造网络空间安全领域的民间智库。网信军民融合 :- 《网信军民融合》杂志提供网络安全、信息化、军民融合资讯和咨询服务，为网信企业“民参军”、“军转民”搭建桥梁，致力于成为党政军企共推网信军民融合发展的高端平台。中国信息安全 :- 《中国信息安全》杂志，介绍国内外最新网络安全动态，深度解读网络安全事件。重生信息安全 :- 专注安全行业，分享最新安全技术及咨询.MottoIN :- 互联网威胁情报社区阿里云先知 :- 阿里云安全应急响应中心为云上客户提供最精准风险预警通告，基于云安全中心的威胁情报收集能力、分析能力、漏洞挖掘能力、应急响应处置能力为客户上云提供高效、精准，真实的漏洞威胁预警、重大安全事件预警。行长叠报 :- 漏洞银行-行长叠报，最新的安全资讯/最全的黑客干货/最有料的业内伙伴，每时每刻连接热爱安全的你我。网信防务 :- 运筹网络空间，汇聚大众力量维他命安全 :- 信息安全那些事儿安全圈 :- 专注网络安全：网罗圈内热点事件，细说安全风云变幻！安全帮 :- 安全帮，是中国电信基于专业安全能力自主研发的云安全服务平台，包含“1+4”产品体系。“1”：SaaS云安全服务电商；“4”：SDS分布式调度管理系统、安全能力开放平台、安全大数据平台、安全态势感知平台。互联网安全内参 :- 《安全内参》是专注于网络安全产业发展和行业应用的高端智库平台，致力于成为网络安全首席知识官。投稿&amp;合作请邮件联系 anquanneican#163.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/287f5b2bf1dfb928cbe0cac7fb80c5ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfdc8e9875927d8bc4ed30a89ba583d/" rel="bookmark">
			# Spring上下文工具类  SpringContextUtils 工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring上下文工具类 SpringContextUtils 工具类 问题分析 从Spring上下文中获得已经装配的Bean，方便拿到配置文件中的配置的资源信息。当一个类实现ApplicationContextAware之后，这个类就可以方便获得ApplicationContext中的所有的Bean。ApplicationContextAware的实现类中对Application 进行了初始化，所以实现这个类可以拿到当前上下文中所有的Bean。
工具类实现 @Component public class SpringContextUtils implements ApplicationContextAware { private static ApplicationContext applicationContext = null; private static final Logger logger = LoggerFactory.getLogger(SpringContextUtils.class); @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { if(Objects.isNull(SpringContextUtils.applicationContext)){ logger.info("=====&gt;ApplicationUtils初始化..."); SpringContextUtils.applicationContext = applicationContext; } if(Objects.nonNull(SpringContextUtils.applicationContext)){ logger.info("=====&gt;ApplicationUtils初始化成功!"); } } /** * 获得当前的ApplicationContext * * @author LiDong * @date 2020/11/20 * @param '[]' * @return org.springframework.context.ApplicationContext */ public static ApplicationContext getApplicationContext(){ return applicationContext; } /** * 根据名称拿到Bean * * @author LiDong * @date 2020/11/20 * @param '[name]' * @return java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bfdc8e9875927d8bc4ed30a89ba583d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7b9d1b0f9a27572aab7aa85376df6c1/" rel="bookmark">
			完美解决令人头疼的No module named &#39;copy_reg\r&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现的原因：Windows和Linux下的文件编码不同，会在每行的末尾多出恶心的'\r\n'，解决方法，对字节码格式的每行'\r\n'替换为'\n'
替换代码 import pickle # 替换 with open('./pet.pickle','rb') as f: lines=f.readlines() lines=[str(x, encoding="utf-8") .replace('\r\n','\n') for x in lines] lines=[ bytes(x, encoding="utf8") for x in lines] # 写入新的文件 with open('./washData/pet.pickle','wb') as nf: for line in lines: nf.write(line) 测试 import pickle with open('./washData/pet.pickle','rb') as f: p=pickle.load(f, encoding='latin1') print(p) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6416ef00d1225f50bec1d1335152676/" rel="bookmark">
			【JavaDebug（十一）】之 AOP错误：warning can‘t determine implemented interfaces of missing type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一． BUG描述 在使用SpringBoot学习SpringAOP的引入时，在切面导入了注解@DeclareParents，出现了报错信息，如下所示：
warning can‘t determine implemented interfaces of missing type org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration 二． BUG解决 注解@DeclareParents中的属性value的值为需要增强的类的全限定名，我填写的内容如下所示：
@DeclareParents(value = "com.springboot.chapter4.aspect.service.impl.UserServiceImpl+", defaultImpl = UserValidatorImpl.class ) 可以看到，全限定名后面有一个+号，可能是不同版本的Spring要求不同，当我将+号去掉时，就不会报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c15978e7b071f1aa12e1a9e691f1967/" rel="bookmark">
			Linux使用rmp安装tree
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建/mnt/cdrom/目录
#mkdir /mnt/cdrom/ 2.切换到/mnt/cdrom/
# cd /mnt/cdrom/ 3.查看列表使用ls
[root@localhost cdrom]# ls EFI EULA_fr EULA_zh LoadBalancer repodata Server EULA EULA_it GPL media.repo ResilientStorage TRANS.TBL EULA_de EULA_ja HighAvailability Packages RPM-GPG-KEY-redhat-beta EULA_en EULA_ko images README RPM-GPG-KEY-redhat-release EULA_es EULA_pt isolinux release-notes ScalableFileSystem 4.找到Packages这个目录，并切换到这个目录
[root@localhost cdrom]# cd Packages/ 5.找到tree的包
[root@localhost Packages]# ls tree* tree-1.5.3-3.el6.x86_64.rpm 6.使用rmp下载这个包
[root@localhost Packages]# rpm -ivh tree-1.5.3-3.el6.x86_64.rpm warning: tree-1.5.3-3.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY Preparing... ########################################### [100%] 1:tree ########################################### [100%] 显示两个100%就下载完成啦~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c15978e7b071f1aa12e1a9e691f1967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d204c82a05c5c14633871d6465dd54/" rel="bookmark">
			RT-Thread学习1-tcp_modbus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RT-Thread Studio实现以太网modbus功能：
1.创建芯片对应工程，STM32F407VGT6,这个网络很多。
2.添加文件stm32f4xx_hal_msp.c
3.stm32f4xx_hal_msp.c添加以太网管脚驱动代码,通过STM32CubeMX生成或直接在官网例程中复制。
管脚操作，包含文件：#include &lt;rtdevice.h&gt;
#ifdef BSP_USING_ETH #define RESET_IO GET_PIN(C, 0) void phy_reset(void) { rt_pin_mode(RESET_IO, PIN_MODE_OUTPUT); rt_pin_write(RESET_IO, PIN_HIGH); rt_thread_mdelay(50); rt_pin_write(RESET_IO, PIN_LOW); rt_thread_mdelay(50); rt_pin_write(RESET_IO, PIN_HIGH); } /** * @brief ETH MSP Initialization * This function configures the hardware resources used in this example * @param heth: ETH handle pointer * @retval None */ void HAL_ETH_MspInit(ETH_HandleTypeDef* heth) { GPIO_InitTypeDef GPIO_InitStruct = {0}; if(heth-&gt;Instance==ETH) { /* USER CODE BEGIN ETH_MspInit 0 */ /* USER CODE END ETH_MspInit 0 */ /* Peripheral clock enable */ __HAL_RCC_ETH_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOG_CLK_ENABLE(); /**ETH GPIO Configuration PC1 ------&gt; ETH_MDC PA1 ------&gt; ETH_REF_CLK PA2 ------&gt; ETH_MDIO PA7 ------&gt; ETH_CRS_DV PC4 ------&gt; ETH_RXD0 PC5 ------&gt; ETH_RXD1 PG11 ------&gt; ETH_TX_EN PG13 ------&gt; ETH_TXD0 PG14 ------&gt; ETH_TXD1 */ GPIO_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0d204c82a05c5c14633871d6465dd54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408c5b6da8e2a850d41aae4d13fe651a/" rel="bookmark">
			秀米复制到公众号格式变了_如何从微信公众号下载MP4格式的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中，我们经常遇到要将一些“微信公众号”中的视频文件下载下来的需求。微信公众号中的视频大部分都会先上传到腾讯视频平台中，我们可以下载腾讯视频客户端，然后点击下载视频进行影音资源的下载。但是下载下来的影音格式是qlv格式的，播放时只能使用腾讯播放器才能播放。如果需要MP4格式的文件，我们可以使用下面的方法。
如上图，我们需要下载漯河都市频道公众号中对原漯河市工商行政管理局集中开展扫黑除恶专项治理宣传活动的视频介绍。可以在需要下载的视频资源上点击鼠标右键，点击复制视频页面地址，将视频资源的地址保存下来。
然后，在浏览器上输入http://v.ranks.xin/这个网址，进入视频助手
一键下载在线视频这个平台。将刚才复制的连接粘贴到输入框中，点击解析视频。(该平台还支持下载腾讯视频、秒拍视频、微博视频、今日头条、阳光宽频网、快手、微信、百度视频、梨视频、西瓜视频等)。视频解析成功后，点击预览并保存，就可以进入预览页面。
在预览页面了，点击下图箭头所在位置进行下载，选择需要保存视频资源的目录，点击保存，就能将格式为MP4的视频文件下载到指定的目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad7fbcadadcb0317edf3145447ff4cf6/" rel="bookmark">
			计算机图形学综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机图形学主要研究的是如何在计算机中表示图形，以及对图形进行处理。实际上计算机的本质也就是信息的表示与处理，把这个信息限定在图形上，那就是计算机图形学的内容。主要内容有三大块：建模、渲染与模拟。
平时接触到的电子游戏、电影特效、动画、CAD、可视化、VR、AR、模拟、计算机艺术等都属于图形学的领域。
学习图形学所需要的基础知识主要是数学和编程，其它还包括英语、物理等。通过计算机图形学，我们可以自己创作一个虚拟世界、并与之交互，这是一件十分让人兴奋的事。我对计算机总是很兴奋，同时对图形学也是很兴奋。
建模就是用计算机的方式表示三维世界，渲染就是将三维世界显示出来，模拟则是按照既定程序运动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64b9d6e55b5af8eb51e487bf79c15d8/" rel="bookmark">
			pyecharts生成柱形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.版本：pyecharts版本1.9.0
2.功能：pandas数据框生成柱形图
from pyecharts.charts import Bar from pyecharts import options as opts import pandas as pd a = {'num':[1,2,3,4,5],'name':['a','bb','c','d','f']} df = pd.DataFrame(a) mean_kh = df['name'].values.tolist() label = df['num'].values.tolist() bar=( Bar() .add_xaxis(mean_kh) .add_yaxis('平均价位',label) .reversal_axis() #翻转 .set_series_opts(label_opts=opts.LabelOpts(position="right")) .set_global_opts(title_opts=opts.TitleOpts(title="测试")) ) bar.render("aa.html") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c16cda8f5a322ed18fc3df2584e9dee/" rel="bookmark">
			推荐系统深度学习篇-NFM 模型介绍(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、推荐系统深度学习篇-NFM 模型介绍(1) NFM是2017年由新加披国立大学提出的一种模型，其主要优化点在于提出了Bi-Interaction，Bi-Interaction考虑到了二阶特征组合，减轻了后面MLP部分学习特征信息的压力
论文地址：https://arxiv.org/pdf/1708.05027.pdf
其结构如下
BI-Interaction的结构为
该式可化简为
详细推导过程如下
编程简单记忆方式： 和的平方-平方的和
需要注意的是：
1.该图显示的是在Bi-Interaction后由三层MLP构成，但论文中，只用到了一层隐层；
2 dropout ratio是最重要的超参, 文中在Bi-Interaction层用了0.5
二、美图优化的nfm结构 可看出，美图的nfm并不是直接在Bi-Interaction后加上MLP层，而是将LR，Bi-Interaction，MLP三个部分进行拼接，最后送入到全连接层然后输出
这里的S指的是LR+人工特征组合
三、美图的nfm实现
3.1 S部分
只进入连续特征
3.2 Bi-Interaction
只进入category的特征，category的特征经过embeding处理
3.3MLP部分
MLP部分进入 全部特征（包含连续和类别特征）
3.4 代码介绍
由于S 部分和MLP部分比较简单，在此，只展示Bi-Interaction 的代码，如下
def BiInteractionPooling(inputs): concated_embeds_value = inputs # 计算二阶部分 # square_of_sum 先求和再平方 square_of_sum = tf.square(tf.reduce_sum(concated_embeds_value, axis=1)) # sum_of_square 先平方再求和 sum_of_square = tf.reduce_sum(concated_embeds_value * concated_embeds_value, axis=1) cross_term = 0.5 * (square_of_sum - sum_of_square) return cross_term 这里的input代码如下
sparse_embedding_layer_list=[] sparse_embedding_layer_list.append(cat_id1) sparse_embedding_layer_list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c16cda8f5a322ed18fc3df2584e9dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b038798f54b8aee8e8b2639dab919877/" rel="bookmark">
			idea2019.3开启类的serialVersionUID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位置 File–&gt;setting–&gt;Editor–&gt;Inspections–&gt;Java–&gt;Serialization issues–&gt;Serializable class without serialVersionUID
找到后选中该选项应用即可
选中后将光标停留在对应类的类名上，输入Alt+Enter
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015ff61ef5657804a277d652d0bf5683/" rel="bookmark">
			Windows10安装使用redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows10安装使用redis 一、下载redis 地址：https://github.com/microsoftarchive/redis/releases
二、解压安装 打开redis.windows-service.conf文件修改密码
打开命令行窗口，安装和注册redis(安装命令和启动命令均需要在redis的根目录下执行)
安装命令
redis-server.exe --service-install redis.windows.conf --loglevel verbose 启动命令
redis-server.exe --service-start 关闭命令
redis-server.exe --service-stop 启动后可在服务中查看是否启动成功
(右击我的电脑----管理----服务和应用程序----服务----)
三、命令行使用redis 新建一个命令行窗口执行下述命令
redis-cli.exe -h 127.0.0.1 -p 6379 四、使用Jedis操作redis 新建Jedis对象连接redis
public static void main(String[] args) { //连接本地redis，端口默认6379 Jedis jedis = new Jedis("127.0.0.1"); //获得本地redis端口号 System.out.println(jedis.getClient().getPort()); //测试 System.out.println(jedis.ping()); } 操作String类型 //操作String public static void operaString(Jedis jedis){ //添加一条数据 jedis.set("username","LiMing"); jedis.set("age","18"); //添加多条数据 //参数奇数为key，偶数为value jedis.mset("hobby","football","sex","man"); //获取一条数据 System.out.println(jedis.get("username")); //获取多条数据 List&lt;String&gt; mget = jedis.mget("username", "age", "sex"); for (String s : mget) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015ff61ef5657804a277d652d0bf5683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fa4d26765ede56e64fa1e7c83235a6/" rel="bookmark">
			arcgis密度分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密度分析
密度分析是指根据输入的要素数据集计算整个区域的数据集状况，从而产生一个连续的密度表面。通过计算密度，将每个采样点的值散布到整个研究区域，并获得输出栅格中每个像元的密度值。在 ArcGIS 中，分布密度的计算方法有点密度分析、线密度分析和核密度分析三种。
1.点密度分析
导入实验数据居民点图层和道路图层
在自定义里勾选空间分析模块Spatial Analyst
点击空间分析工具中密度分析内的点密度分析，
参数设置如下，其中输出像元大小表示输出栅格数据集的像元大小。值越小越细腻
点密度分析结果如下
2核密度分析
核密度分析
核密度分析用于计算要素在其周围邻域中的密度，既可计算点要素的密度也可计算线要素的密度。常用于测量建筑密度、获取犯罪情况报告、预测道路或管线对野生动物栖息地造成的影响等。
在核密度分析中，落入搜索区域内的点（或线）具有不同的权重，（如犯罪，每个点代表一个犯罪事件，但是核密度分析可以再把它犯罪的严重程度作为一个的权重）靠近格网搜索中心的点或线会被赋予较大的权重，随着其与格网中心距离的加大，权重降低。核密度分析的操作步骤如下：
具体参数设置如下
核密度分析结果如下
3线密度分析
线密度分析用于计算每个输出栅格像元邻域内的线状要素的密度，密度的计量单位为“长度单位/面积单位”。理论上，使用以各个栅格像元中心为圆心以搜索半径绘制一个圆，每条线上落入该圆内的部分长度与POPU字段值相乘，对这些数值进行求和，然后将求得的总和除以圆面积就得到该栅格单元的的密度。其基本概念与点密度分析相似
线密度分析操作如下：
具体参数设置如下
结果如下
点密度工具与线密度工具的输出与核密度工具的输出的区别
对于点密度和线密度，需要指定一个邻域一边计算出各输出像元周围像元的密度。核密 度则可将各点的已知总体数量从点位置开始向四周分散。在核密度中，在各点周围生成表面 所依据的二次公式可表为表面中心（点位置）赋予最高值，并在搜索半径距离范围内减少到
零。对于各输出像元，将计算各分散表面的累计交汇点总数。半径参数值越大，生成的密度栅格的概化程度便越高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cffecefcbeeff9d69505101681b5b4f7/" rel="bookmark">
			ORACLE存储过程RECORD数据类型的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RECORD记录数据类型，是将多个基本数据类型变量组合成一个整体，作为一个复合数据类型使用
RECORD定义及使用 create or replace procedure zhzitywp.test is --记录数据类型定义 type stu_record is record( id integer not null, name varchar2(20) not null, score number(20,2) not null := 0 ); --声明记录数据类型变量 stu_record_val stu_record; begin select id,name,score into stu_record_val from user where rowid = 1; dbms_output.put_line(stu_record_val.id); dbms_output.put_line(stu_record_val.name); dbms_output.put_line(stu_record_val.score); end test; 需要注意的是，RECORD记录数据类型，仅能接收单行多列的查询结果，如果查询结果返回是多行就需要配合数组使用
RECORD搭配数组使用 create or replace procedure zhzitywp.test is --记录数据类型定义 type stu_record is record( id integer not null, name varchar2(20) not null, score number(20,2) not null := 0 ); --记录数据类型的数组定义 type stu_record_arr is table of stu_record; --声明数组变量 stu_record_arr_val stu_record_arr ; begin --查询结果是多行多字段，此处不能使用select into，而要用select bulk collect into select id,name,score bulk collect into stu_record_arr_val from user; --遍历查询结果，每行都是一个RECORD记录数据类型 for i in 1 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cffecefcbeeff9d69505101681b5b4f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa65db71373645b09ad7770b0ecab022/" rel="bookmark">
			GYP用户文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍标准的Chromium .gyp文件的骨架.gyp文件中标准的可执行目标.gyp文件中标准的库目标使用实例添加新的源文件添加一个在所有平台构建的源文件添加特定平台的源文件 添加可执行文件为目标添加设置跨平台编译添加新的库目标目标之间依赖支持 MAC OS X bundle移动文件自定义构建步骤构建特色 GYP 是一个元构建系统，一个生成其他构建系统的构建系统
GYP旨在支持需要构建在多个平台上的大型项目(例如，Mac、Windows、Linux)，重要的是项目可以使用在每个平台上流行的IDE来构建，就像项目是一个“本地”项目一样。
它可以用来生成XCode项目、Visual Studio项目、Ninja构建文件和makefile文件。在每种情况下，GYP的目标都是尽可能地复制使用IDE设置本机构建项目的方式。
GYP还可以用于生成“混合”项目，这些项目为良好的用户体验提供IDE脚手架，但需要Ninja来进行实际的构建(这通常比IDE的本地构建系统快得多)。
介绍 本文档旨在提供用户级的GYP指南，这里的重点是如何使用GYP来完成特定的任务，而不是完整的技术语言规范。(对此，请参阅语言描述。)
下面的文档从提供上下文的览开始:.gyp文件本身的结构概览、.gyp文件中典型的可执行程序目标概览、.gyp文件中典型的库目标概览。
在概览之后，有一些针对不同常见用例的gyp模式示例。
标准的Chromium .gyp文件的骨架 这是Chromium项目中一个典型的.gyp文件的骨架：
{ 'variables': { . . . }, 'includes': [ '../build/common.gypi', ], 'target_defaults': { . . . }, 'targets': [ { 'target_name': 'target_1', . . . }, { 'target_name': 'target_2', . . . }, ], 'conditions': [ ['OS=="linux"', { 'targets': [ { 'target_name': 'linux_target_3', . . . }, ], }], ['OS=="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa65db71373645b09ad7770b0ecab022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ffefcef65bdad19f3a0a5e4bb7a92d/" rel="bookmark">
			switch手柄可以连电脑吗_你想要的手柄：既能连switch又能连PC！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您好！我是Manta科技资讯，首先，聊一聊任天堂switch，任天堂switch主机模式下是通过DOCK底座将游戏主机与电视连接以实现无缝切换，这个DOCK底座有2个USB接口，很多小伙伴不知道用它来干嘛，其实DOCK底座能够拓展很多额外的设备，比如鼠标键盘，或者其他游戏外设等等。那么我个人认为能够同时连接switch游戏主机和电脑的游戏手柄有两种方案，一种是不需要额外设备，一种是需要额外的蓝牙接收器具体如下：
switch手柄pro
1.目前switch原装的pro手柄能够无线连接到switch游戏主机，如果电脑支持蓝牙同样也能无线连接，不过电脑本身不识别手柄键位，需要进入steam设置，如果电脑没有蓝牙也能够能使用type-c有线接口连接电脑！可以完美兼容steam。这些是不需要额外硬件支持的！
Xboxone手柄
2.还有一种方案就是：买一个微软的xboxone游戏手柄，它可以完美的通过无线连接win10电脑(支持蓝牙)；而连接到switch游戏主机就需要使用额外的蓝牙接收器(如下图)，才能无线连接到switch。不过这种使用方法仅限底座模式通过底座上了USB接口实现额外蓝牙接收器的连接。
手柄
Tips:在市面上也有很多其他品牌游戏手柄控制器，是可以蓝牙直连win10，然后再用额外的蓝牙接收器同样能连接switch。或许这样能够提供经济型和性价比！这里我就不说品牌了，大家自行某宝。如果您是双机党，额外有XBOX或者PS4游戏主机，那么只需要购买一个给switch用的蓝牙转换器即可！
PS4手柄
总结：目前这些方法各有各的好，因为switchpro手柄价格相比xboxone手柄稍贵，且摇杆有漂移风险。推荐使用xboxone手柄加额外蓝牙接收器！我是Manta科技资讯，如果您有更好的想法，可以下方留言哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c54a6436d29d270bc93ba9dbd24b3d7/" rel="bookmark">
			switch手柄可以连电脑吗_电脑可以拍照吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑可以拍照吗？如果可以该怎么设置，相信对于很多想通过电脑进行拍照的朋友来说，这个问题相当重要，下面就给大家科普一下吧。
电脑可以拍照吗？
电脑可以拍照。电脑拍照的方法很多，随着如今摄像头的像素的提升，电脑摄像头摄取的照片质量也在不断提升。详细介绍一下电脑的拍照功能吧。
１、从硬件来说，拍照是需要具备摄像头的。Winsows系统下系统直接会将usb视频设备显示为一个系统图标。这个图标在我的电脑中可以找到。点击左边的拍照按钮就可以进行拍照了。这是最简单的方式。
２、还有一种使用照相机的途径。就是在开始菜单的附件里面。有一个扫描仪和照相机的选项，点击就能进入usb照相机管理同样会像上面的操作一样只要点击拍照即可。
3、当然系统自带的摄像功能不强大。如果需要更加多样，比如定时拍照可以使用软件来实现功能。具体软件可以自己选择。不过win7则系统无自带的开启摄像的功能，需要驱动或软件来实现。比如在网上下载一款比较绿色的软件。
4、运行软件然后点击开启摄像头这时候桌面会创建一个摄像头的图标。点击该图标则可以进入视频摄影设备。
5、运行该功能则可以实现摄像或者照相的功能。这只是最简单的win7照相软件。基本不实现什么复杂的功能。如果想功能强大则可以下载一些更专业的软件。因为我经常会用到美图顺便便提一下美图可以直接用摄像头照相也可以当做摄像软件使用，相信很多同类型的照片美化都基本兼顾该功能了。
6、最后说一个最比较另类的办法，如果你在与别人视频。直接用qq截图也是算是一种照相方法。只不过动态视频照的照片清晰度可能不怎么好。
以上就是如何使用Windows系统拍照的方法，有很多的途径，希望能对大家有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5655355a8720eaf8634942d4b31d5551/" rel="bookmark">
			平板电脑怎么投屏到电视上_电脑怎么投屏到电视？图文讲解电脑投屏具体方法步骤...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑投屏到电视的方法您会吗？电脑投屏电视一般是在工作的时候才会用到，对于电脑投屏电视，相信很多人知道借助HDMI接口来投屏，只要电脑上有这个接口，一般智能电视都有HDMI接口，用一根HDMI数据线就可以投屏到电视了，如果没有HDMI接口或者数据线那该怎么投屏呢？今天蜜罐蚁小编给大家介绍下电脑投屏电视三种常见方法。
一、最简单的HDMI投屏
1、电脑和电视用HDMI数据线连接
电脑和电视需要用一根HDMI接口连接，如果不是特别老的电脑，都会有HDMI接口，只要把对应的HDMI接口，电脑和电视连接好就行。
2、设置信号源
不同电视设置方法略有不同有，一般遥控器上面有个信号源按钮，按一下就会切换信号源，电脑和电视用HDMI数据线连接好之后，就可以用遥控器切换信号源，选择HDMI1接口，电视插入的那个HDMI接口即可，就可以把电脑屏幕投屏到电视上了。
二、Win7和Win10系统DLNA投屏
如果不借助HDMI投屏，也不借助第三方投屏软件，只用系统自带的投屏协议可以的
1、win10投屏
win10系统有自带的DLNA投屏功能，只需要将电脑和电视处于同一个局域网就行了，使用的时候，选择某个视频播放到设备就行了。还有一种简单方法，就是win10自带的播放器软件Windows Media Player在鼠标右键的时候，选择DLNA/WiDi播放，也可以把电脑投屏到电视上面。
2、win7投屏
win7系统投屏稍微复杂点，需要改动操作系统开启电脑里面的媒体流功能，分别是Windows Media Player Network Sharing Service、SSDP Discovery”、“UPnP Device Host”服务依次开启(默认的是开启了)这些服务都要开启了。
具体方法如下：
A、左下角单击开始按钮，运行，输入services.msc然后开启windwows media player 服务，然后再开启SSDP Discovery”、“UPnP Device Host，方法都是一样的，都是输入运行命令，打开这些服务。
B、在电脑-控制面板-网络和Internet，再点击网络和共享中心，打开后更改高级共享设置，然后选择“流媒体”开启流媒体服务。然后将所有的状态都设置为开启状态。
三、第三方投屏软件乐播投屏
1、电脑下载乐播投屏电脑端软件并安装，电视也是安装乐播投屏软件，电视必须是安装TV版，电脑安装电脑版即可
2、电脑端软件打开后悔扫码设备，发现设备后，选择连接电视，就可以直接连接到电视上面了，很简单电脑投屏到电视的方法。
上面是蜜罐蚁小编给大家整理的有关电脑投屏到电视的方法，希望对大家有用，如果您觉得本文不错，不妨把本文分享给您身边的朋友们吧！
▼长按下图二维码关注蜜罐蚁家居▼
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78868b1d0057e66aad7c45cc8666f79e/" rel="bookmark">
			适合 Go 新手学习的开源项目——在 GitHub 学编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：HelloGitHub-小鱼干&amp;卤蛋
故事要从 2007 年说起。因为受够了 C++ 煎熬的 Google 首席软件工程师 Rob Pike 召集 Robert Griesemer 和 Ken Thompson 两位牛人，决定创造一种新语言来取代 C++，这就是 Go 的由来。
在 2009 年 11 月 10 日 Google 正式发行 Go 这一编程语言。Go 从 C 语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有 C 语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。
Golang 项目地址：https://github.com/golang/go
经过十多年的发展，截止北京时间：2020 年 11 月 17 日定稿时 Go 的最新版本已经到了 1.15.5。同时国外的 Twitter、Google、Netflix 等大厂和国内的字节跳动、腾讯、B 站等公司都在用 Go 开发他们的主要业务，诸如 PingCAP 这一新兴 NewSQL 数据库厂商的主产品 TiDB 更是使用 Go 进行开发，并成为了 GitHub 上知名的 Go 语言开源项目。可见 Go 在互联网公司的开发地位日渐重要，在开源社区也十分活跃。
那这个时候新手“上车”晚不晚？GitHub 上面有什么好玩、入门级的 Go 语言项目？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78868b1d0057e66aad7c45cc8666f79e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592eb49ef801f11c479244e773521865/" rel="bookmark">
			平板电脑怎么投屏到电视上_将笔记本电脑信号无线投屏到电视或投影机上显示...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将笔记本电脑信号无线投屏到电视或投影机上显示
本文主要是介绍通过无线投屏器，将电脑无线投屏到大屏幕的不同情况的一个统计。
电脑无线投屏到一台显示屏幕
显示结果：电脑与显示屏同步显示，或显示屏为电脑的扩展空白屏幕，自行选择。
硬件准备：一台电脑、一套AWIND奇机无线投屏器，一体机【只要是带有HDMI或者VGA信号输入接口的显示器都可以，这里以一体机为例】
1、将无线投屏器盒子通过HDMI线与一体机连接，连接之后，一体机的屏幕就会变成无线投屏器的待机画面【待机画面就是一张图片，可以自定义修改】；
2、将无线投屏器的USB按键插在电脑USB接口上，按下按钮，电脑屏幕和一体机屏幕同步（AWIND奇机投屏器默认的是屏幕复制，我们可以自行将复制更改为扩展，那样一体机屏幕就是一个只显示电脑桌面的空白屏幕）。
电脑投屏到多个显示屏幕
显示结果：电脑与多个显示屏幕同步显示，或者单独的屏幕显示指定的内容，这里就介绍电脑投屏多个屏幕之后，多个屏幕与电脑同步显示。
硬件准备：一台电脑，10套AWIND奇机无线投屏器，10台一体机（无线投屏器的数量与显示屏数量一样）
1、将无线投屏器分别用HDMI线与一体机连接；
2、在无线投屏器的后台开启组播功能，每一台都需要设置。
AWIND奇机无线投屏器组播设置：电脑和投屏器都通过网线连接同一个路由器——打开浏览器输入投屏器IP地址（在投屏器底部标签上有个IP地址）——输入账号、密码【初始账号：admin;初始账号12345678】——网络设置——组播——开启【开/关单选】——保存、退出——重启投屏器。
3、给所有的无线投屏器都插上网线，让所有的无线投屏器和电脑要在一个局域网；
4、电脑上插上USB按键，然后按一下按键，电脑与多个显示屏幕同步。
如果想要显示不一样的，需要经过AWIND奇机的多屏互动服务器，连接方式与组播一样的，只不过通过多屏互动服务器之后，电脑可以指定任何一个显示屏幕显示指定的内容。
温馨提示：AWIND奇机无线投屏器常见的有单画面、双画面、四画面，也就是我们可以同时允许多个发送端同时投屏,一部手机、平板、笔记本、电脑算一个发送端设备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4b19e2878ab19352e31abcfea5a66f5/" rel="bookmark">
			【已解决】调用mysql函数错误Call to undefined function mysql_connect()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示Call to undefined function mysql_connect()，明显是函数调用错误
查到一篇博客才知道是自己看的教程太老了，现在mysql的函数已经不用mysql_connect()这种写法了。
改为：
mysqli_connect() 即可
同理，其它函数也作类似的修改，其中部分函数需要再加上一个$connection参数，如下：
mysql_select_db(数据库名)改为mysqli_select_db($conneciton, 数据库名 )
mysql_query(sql语句)改为mysqli_query($connection, sql语句)
mysql_num_rows($result) 改为 mysqli_num_rows($result)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434ebbca44fe774136319a215e9a7d9b/" rel="bookmark">
			doLayout 解决 elementui table加载数据之后错位问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有的时候在使用elementui 的table时候，更新完数据之后。表格就会错位。
这个时候只需要使用doLayout重新加载一下table就好了。
&lt;el-table ref="tableref" &gt;&lt;/el-table&gt; //当页面数据加完完毕后 t.$nextTick(() =&gt; { // 初始化表格 t.$refs.tableref.doLayout(); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450b7b55d0aff596f945688b44b0fa6d/" rel="bookmark">
			Flutter  修改appBar 高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Scaffold( appBar: PreferredSize( child: AppBar( title:Text("AppBar"), bottom: _appBarView(), ), preferredSize: Size.fromHeight(60.0)), //自定义高度 body: _tabBarView(), ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91deec86ef59b3ee4996974ca437ce7f/" rel="bookmark">
			matlab中的~用法和~=
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用法1：表示非（与java中的！类似）
if ~flag count++; end 用法2：忽略函数返回的某个参数。比如size函数有两个返回值，而我们只需要第一个参数。则
[m,n]=size(A);%返回矩阵A的行和列 [m,~]=size(A); ps：看程序看到一段sum([1 2 3 4]~=[2 3 1 4])。分开来看 里面的~=返回的是个逻辑数组[1 1 1 0],每个值对应的是向量中元素是否相等，相等为0，否则为1.
整个意思就是得到两向量中不同元素的个数。在命令行输入验证
&gt;&gt; [1 2 3 4]~=[2 3 1 4] ans = 1×4 logical 数组 1 1 1 0 &gt;&gt; sum([1 2 3 4]~=[2 3 1 4]) ans = 3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a8f3bfbf5459888e91766a7f91b9b1/" rel="bookmark">
			什么是 ill-posed 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ill-posed就是不well-posed.
well-posedness的定义就是解存在唯一以及稳定。
适定问题（Well-posed problem）是指满足下列三个要求的问题:
1)解是存在的;
2)解是惟一的;
3)解能根据初始条件连续变化，不会发生跳变，即解必须稳定。
这三个要求中，只要有一个不满足，则称之为不适定问题（ill-posed problems）。图像处理中不适定问题（ill posed problem）或称为反问题（inverse Problem）的研究从20世纪末成为国际上的热点问题，成为现代数学家、计算机视觉和图像处理学者广为关注的研究领域。典型的图像处理不适定问题包括：图像去噪（Image De-nosing），图像恢复（Image Restorsion），图像放大（Image Zooming），图像修补（Image Inpainting），图像去马赛克（image Demosaicing），图像超分辨(Image super-resolution )等
ill posed problems是病态问题，可以解释为不存在稳定的唯一解。病态，简单来说就是结果不唯一，比如a+b=5，求a和b的值就是病态问题。矩阵乘法如果是病态问题，通常是因为那个矩阵不满秩。零空间不为空，这样即使真实解发生很大的变化，仍然得到相同的结果或者观测量。所以对于病态问题，需要做各种先验假设，来约束它，使它变为well posed，从而能够求解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd1120604410a37f6b5868e0df62905/" rel="bookmark">
			2020年，关于事件相机(event camera)的最新研究论文总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅用于学习过程中的一些总结记录。2020年发表的关于事件相机在一些领域的总结。
1. 运动估计 Motion Estimation 有不少关于运动估计的论文，基本是围绕之前最大化事件积累图对比度的方式进行。
最小化Entropy [1] 采用最小化熵函数的方式，对运动参数进行估计。文章指出最大的优点是，这种方法不需要将空间中的事件投影到平面上去最大化对比度。然而数学内容太复杂真的看不懂。
全局最优解计算 [2] [3] 两篇论文，都是解决运动参数估计时陷入局部最优解的问题。如果在使用最大对比度函数进行计算运动参数时，需要有一个较好的参数初值，否则对于图像问题在优化时会陷入局部最优解。如下图所示，左下角的运动参数就是局部最优解。
论文采用了分支定界（Branch-and-bound）的方法进行全局搜索，提出了某个区域的近似上界和下界，加速运算。
运动参数时间连续性 [4] 这篇论文提出，相机的运动应该是连续的，之前的方法只是针对每个积累图进行一次优化得到运动参数，并没有考虑与前后时刻的运动参数是否一致。
论文将一段儿时间内的运动参数设置为时变的，但这样难以优化，所以不得不再次切片成多个更短的时间离散化，分别优化运动参数。同时增加一阶导数作为惩罚项避免过拟合，保证参数变化的连续性。如下图，待优化的运动参数是时变的 θ t \theta_t θt​，最后一项是参数的一阶导。
这个想法让人眼前一亮，从实验结果上看，增加噪声以后，考虑了时间上的连续性情况下的运动曲线更加平滑。
2. 建图、场景识别与VIO Frame+event的深度估计 [5] 使用了事件相机+传统相机进行深度估计。作者指出这是第一个关于二者融合的深度估计，二者结合得到了时间上连续的稠密深度图。
方法架构如上图。stereo相机数据过来以后进行稠密重建，然后根据运动参数推测和收到的events在两帧图像之间对depth图进行更新。由于利用到了视差的信息，论文提到这种方法更适合于平行于平面运动，但仍然不失为一种不错的尝试。毕竟这种方法补全了两帧之间的深度图，还是挺有趣的。
基于事件的场景识别 [6] 是我读到的第一个event-based的场景识别的论文。时空窗口的选择方式常见的有定事件数量或定时间，但无论如何事件只归属于一个窗口。而这篇论文采用了多种尺度的时间窗口，一个事件同时隶属于多个窗口。然后通过已有的E2VID方法恢复到图像，再进行匹配。
如上图的流程所示，第一个图示意某一个时刻某一个事件可能同时归属于6个窗口（3种时间间隔、3种数量上限），之后所有的窗格恢复images，再分别提取特征，与之前关键位置的images进行比对，形成Ensemble matrix。最近的那个就是成功匹配。这种方法给出了一些近似方法，降低了比对的复杂度。这个方法还是比较有趣的，虽然感觉有点儿暴力。
利用线特征的VIO [7] 这篇论文提出了一个IMU+DVS的VIO。大致看了一下主要是优化的点到线距离。
4. 信号处理领域相关研究 降噪
2020降噪的研究有不少在我之前的一篇博客中有所总结：【事件相机整理】信号处理、噪声与滤波。这里就不展开介绍。
数据编码与压缩
之前没有注意，最近发现在github的event camera的汇总中出现了“Compression”相关的研究，以为是2020年才开始的，结果打开论文发现，[10][11]中已经指出了不少的研究。想简单看一看发现实在是太深入了，之前研究传统图像编码与压缩的方法，大量的用在event上面。真的是新的应用场景又养活了一批人。
压缩与编码目的：降低数据量，总线传输更快，降低存储空间，IoT领域降低传输数据量
数据编码与压缩的主要衡量指标：压缩率、编解码速度、编解码延时
方法比较的结果：压缩率：LZMA（静态），Spike（动态）； 编解码速度：LZ4和Snappy；综合性能：Brotli算法
5. 图像/视频恢复 Reconstruction 我对重建部分了解不多。传统方法是基于一些假设前提，例如亮度一致性，或利用泊松积分等方式进行恢复。现在更多地采用learning的方法。
包含了超分辨率与降噪的重建 [12] 这篇工作，采用事件对图像进行增强，得到了降噪、超分的图像。多说一句，event的超分工作也很少，这篇论文的作者表示只遇到了一篇相关论文。这篇论文的视频上传到了bilibili，可以看一看。干杯~https://www.bilibili.com/video/av838383543/
E2VID 视频恢复 E2VID基本可以算是最常对比的一种方法了，也衍生了许多改进方案。[9] 这篇论文是rpg组Henri Rebecq的工作，好像是在18年基础上的改进，并公开了代码。event数据流直接通过learning后转成视频。看着效果还是不错的，应该比之前基于泊松的一些重建要方便许多。
基于光度一致性的自监督重建 E2VID的采用了仿真生成了带有标签的数据进行的训练，[13] 这工作不需要真值，直接自监督。思路如下图，利用FlowNet和ReconNet两个网络生成的数据，和事件积累图采用光度一致性，确定误差，反向传播到两个网络进行调整。
基于cycle-GAN的重建 [14] 采用cycle-GAN进行重建。对GAN我也不懂，说到这些又想到了伤心的过去。算了不说了。
基于representation learning 和 domain adaption的learning 这个也是好新的内容啊，完全不懂。大概理解，[15] 的主要解决的问题是，在黑暗环境下的重建可以利用光照条件良好的数据进行学习，经过domin adaption把光照良好的一些domain-invariant representations迁移到光照不好的情况下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dd1120604410a37f6b5868e0df62905/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/201/">«</a>
	<span class="pagination__item pagination__item--current">202/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/203/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>