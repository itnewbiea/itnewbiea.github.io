<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2afc52ecd57d3568614e690b76bd8b0d/" rel="bookmark">
			Pinia知识点（vue3版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要使用 Pinia？ Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。
Pinia的好处：
1.dev-tools支持 跟踪动作，突变的时间线 Store出现在使用他们的组件中 time travel 和 更容易的调试 2.热模块更换 在不重新加载页面的情况下修改您的 Store 在开发时保持任何现有状态 3.插件 使用插件扩展 Pinia 功能 4.为 JS 用户提供适当的 TypeScript 支持或 autocompletion 5.服务器端渲染支持 与Vuex的比较 与Vuex相比，pinia提供了更简单的API，更少的规范，提供了 Composition-API 风格的 API，最重要的是，在与 TypeScript 一起使用时具有可靠的类型推断支持。 mutations 不再存在。他们经常被认为是 非常 冗长。他们最初带来了 devtools 集成，但这不再是问题。 与 Vuex 3.x/4.x 的比较 mutations 不再存在。他们经常被认为是 非常 冗长。他们最初带来了 devtools 集成，但这不再是问题。 不再需要注入、导入函数、调用函数 安装Pinia 安装：npm i pinia 创建pinia（根存储）并且全局都能使用 import { createPinia } from 'pinia' app.use(createPinia()) 什么是 Store 什么是Store 简单来说就是 托管全局状态 一个任何人都能读取和写入的组件 它有三个概念state、getters 和 actions 等同于组件中的 数据、计算和方法 定义一个Store Store 是使用 defineStore() 定义的，并且它需要一个唯一名称，作为第一个参数传递
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2afc52ecd57d3568614e690b76bd8b0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc42cff4d1a2cd0e792ae29d8d37103/" rel="bookmark">
			js获取某天日期，当前时间，时间戳转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 获取n天前日期 console.log(getDate(0), '当前日期--------------&gt;') //yyyy-MM-dd console.log(getDate(-1), '昨天日期--------------&gt;') //yyyy-MM-dd console.log(getDate(-8), '8天前日期--------------&gt;') //yyyy-MM-dd console.log(getDate(1), '明天日期--------------&gt;') //yyyy-MM-dd console.log(getDate(10), '10天后日期--------------&gt;') //yyyy-MM-dd function getDate(num) { var date1 = new Date(); //今天时间 var time1 = date1.getFullYear() + "-" + (date1.getMonth() + 1) + "-" + date1.getDate(); var date2 = new Date(date1); date2.setDate(date1.getDate() + num); //num是正数表示之后的时间，num负数表示之前的时间，0表示今天 var time2 = addZero(date2.getFullYear()) + "-" + addZero((date2.getMonth() + 1)) + "-" + addZero(date2.getDate()); return time2; } function addZero(num) {//补0方法 if (parseInt(num) &lt; 10) { num = '0' + num; } return num; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc42cff4d1a2cd0e792ae29d8d37103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f74a987aca23149bd5c0f83a53739d/" rel="bookmark">
			高效液相色谱图中峰高、峰面积、峰面积比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、高效液相色谱图中峰高、峰面积、峰面积比都是代表什么呢？ 高效液相色谱图中峰面积、峰面积比都是代表什么呢？ 分析测试百科网wiki版
峰高指待测组分从柱后洗脱出最大浓度时检测器输出的信号值，单位一般为mAU，AU或mV，也可代表相对含量，但不如峰面积准确。
峰面积指峰高与保留时间的积分值，单位一般相应为mAU*min，AU*min或mV*min，代表相对含量比较准确。
峰面积比代表各物质的相对百分含量，单位一般为%。
峰高和峰面积的选择
在色谱定量分析中，选用峰高法还是选用峰面积法，主要决定在检测器的线性范围内，峰高和峰面积测量的准确性和重复性。除了归一化法最好用峰面积法外，其他三种定量方法中峰高和峰面积都可用作精确的定量方法。
在检测器的线性范围内，峰高和峰面积测量的准确性受色谱分离度的影响，要准确地测量峰高和峰面积，色谱分离应达到一定的分离度才行。
于世林老师编著的《高校液相色谱方法及应用》
二、高效液相色谱法怎么分析谱图? 分析峰的个数，位置，峰高，峰面积
作者：秋硕
链接：https://www.zhihu.com/question/359904536/answer/1782634211
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
色谱图其实简单地讲是一个横坐标是时间；纵坐标是电信号的二维图谱。
高效液相色谱法，你可以简单地想象，固定相是一个多空海绵状的柱形结构，样品在孔洞中进进出出。因为各个物质的吸附能力不同，所以才会在色谱图中拉开距离。
实验相关的参数：
保留时间是溶质通过色谱柱所需的时间。这种特性可以在一种混合物的几个组分之间共享，这就是为什么应用MS方法的原因。由此产生的色谱图显示保留时间与强度(存在的组分量)的关系。
1、保留时间：也就是可以定性的数据参数
保留时间是溶质通过色谱柱所需的时间。这种特性可以在一种混合物的几个组分之间共享，这就是为什么应用MS方法的原因。由此产生的色谱图显示保留时间与强度(存在的组分量)的关系。
如果使用同样的色谱柱，同样的流动相，分析同样的样品，那么这个样品的保留时间，应该是固定的。不同保留时间的色谱峰，应该表现出的是不同的物质。如果你跑的是反相色谱，那么色谱峰越靠后，它对应物质的极性也就越小。
2、峰面积：也就是可以定量的数据参数
峰值检测在滤波之后进行，其中峰值表示成分或成分的断裂。峰可以根据它们覆盖的高度或面积来选择。通过将存在的峰与已知的峰进行匹配，可以通过眼睛识别某些峰模式。这可以帮助确定存在什么分子，或者分子中存在多少原子。
色谱图中可以读出来的参数，在同一个色谱条件下，同一个物质的浓度和峰面积是成正比的。也就是说，如果你配制1.0mg/ml的X物质，进样后峰面积是10000，那么，你配制0.5mg/ml的X物质，进样后峰面积差不多就是5000
3、波长:这个是可以顺利进行试验的前提条件
同一样品，同一方法，同一色谱柱，在不同波长的峰面积是不同的。一个物质指在某些特殊波长下有吸收。比如一个物质在210nm和254nm处有吸收。那么波长在280nm处可能无法检出该物质。所以一个实验方法开始时要进行波长扫描。
答：分析方法其实有个入门级别的。
1，首先区分溶剂峰跟产物峰。在区分这两个之前，你要知道一件事情。我们都是用高极性溶剂来溶解待测产物的（我用的是DMSO溶解的产物，它的极性在常用溶剂里面排第四），所以如果你用的仪器如果不是正相色谱仪，5分钟内必定会出一个溶剂峰。除了这个溶剂峰以外，后面的就都是特征产物。做到了这一步你就成功了一半。
2，然后就是根据峰值数量的多少来判断产物多样性。主要是数哪些非常尖锐的峰，然后比大小。
3，最后就是各种产物的含量配比，比较峰高就行了。
4，高效液相色谱图的目的就是在于探究待测物中产物多样性以及含量配比情况。
链接：https://www.zhihu.com/question/359904536/answer/1932677473
峰面积_百度百科
峰面积比是指在色谱图，背景线以上部分的总面积，表示待测物的含量，面积越大，含量越高。
目录 1 内标法2 外标法3 峰高和峰面积的选择 内标法 内标法是一种间接或相对的校准方法。在分析测定样品中某组分含量时，加入一种内标物质以校准和消除出于操作条件的波动而对分析结果产生的影响，以提高分析结果的准确度。 内标法在气相色谱定量分析中是一种重要的技术。使用内标法时，在样品中加入一定量的标准物质，它可被色谱拄所分离，又不受试样中其它组分峰的干扰，只要测定内标物和待测组分的峰面积与相对响应值，即可求出待测组分在样品中的百分含量。采用内标法定量时，内标物的选择是一项十分重要的工作。理想地说，内标物应当是一个能得到纯样的己知化合物，这样它能以准确、已知的量加到样品中去，它应当和被分析的样品组分有基本相同或尽可能一致的物理化学性质(如化学结构、极性、挥发度及在溶剂中的溶解度等)、色谱行为和响应特征，最好是被分析物质的一个同系物。当然，在色谱分析条什下，内标物必须能与样品中各组分充分分离。需要指出的是，在少数情况下，分析人员可能比较关心化合物在一个复杂过程中所得到的回收率，此时，他可以使用一种在这种过程中很容易被完全回收的化合物作内标，来测定感兴趣化合物的百分回收率，而不必遵循以上所说的选择原则。
外标法 外标法external standard method 色谱分析中的一种定量方法，它不是把标准物质加入到被测样品中，而是在与被测样品相同的色谱条件下单独测定，把得到的色谱峰面积与被测组分的色谱峰面积进行比较求得被测组分的含量。外标物与被测组分同为一种物质但要求它有一定的纯度，分析时外标物的浓度应与被测物浓度相接近，以利于定量分析的准确性 [1] 。
峰高和峰面积的选择 在色谱定量分析中，选用峰高法还是选用峰面积法，主要决定在检测器的线性范围内，峰高和峰面积测量的准确性和重复性。除了归一化法最好用峰面积法外，其他三种定量方法中峰高和峰面积都可用作精确的定量方法。
在检测器的线性范围内，峰高和峰面积测量的准确性受色谱分离度的影响，要准确地测量峰高和峰面积，色谱分离应达到一定的分离度才行。图2-3-18 至图2-3-22给出了峰高比1:1至16:1 时的标准分离度曲线，每张图上的黑点表示了每个峰峰尖的真实位置，此黑点与图中所示的峰尖的垂直位移就是测量误差。峰高比越大，要求能准确测量峰高的分离度也越大。峰高比为1/1和2/1时，峰高能得到准确测量的最低分离度为0.8；峰高比为4/1 时，峰高能得到准确测量的最低分离度为1.0；峰高比16/1 时，峰高能得到准确测量的最低分离度为1.25。关于分离度对峰高测定准确度的影响大致可认为：当分离度Rs-1.0 时，相对峰高从128:1 变化到1:128时，峰高的测量误差小于+-3%。
在分离度较好，色谱峰形较好，峰面积可以准确测量时，以用峰面积法定量为好。特别是在气相色谱使用程序升温和液相色谱使用多元梯度洗脱时，最好使用峰面积法定量。但当分离度不好，色谱峰形不好（如严重拖尾）时，峰面积测量引起的误差较大，此时使用峰高法定量较好。保留时间短的色谱峰峰形较尖（峰尾宽较小），此时峰高测定较峰面积测定准确，宜用峰高法定量；而保留时间长的色谱峰峰形较宽（峰尾宽较大），此时峰面积测定较峰高测定准确，宜用峰面积法定量 [2] 。
三、怎么看懂液相色谱图（液相色谱仪图解） 怎么看懂液相色谱图（液相色谱仪图解）_环球信息网
对于每一个身经百柱的实验人员来说，液相色谱图是他们打开未知物质世界的大门，科研中的很多问题都能从色谱图中得到很好的反映，有些问题可以通过改变设备参数得到解决，而有些问题则必须通过修改操作程序来解决，毕竟，正确选择色谱柱和流动相才是得到好的色谱图的关键。
狮妹在此根据大家实践中可能会经常遇到的一些图谱问题进行了整理汇总，大家一起来看一下吧。
01 拖尾峰
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f74a987aca23149bd5c0f83a53739d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f185438334ca345e8024cf08f7d36fe/" rel="bookmark">
			JS获取Shadow DOM中的节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的网站中有ShadowDOM节点，对于这种节点，直接在控制台使用元素选择器是无法获取到的。
那怎么获取呢？这里结合ShadowDOM的特性分“shadow-root(open)”和“shadow-root(closed)”两种情况。
1、shadow-root(open) 假设页面中有一个id为open的div元素，我们可以通过下面的代码将它设置为一个open状态的ShadowDOM节点，并为它添加一个子节点ele_open_child。
&lt;div id="open"&gt;&lt;/div&gt; &lt;script&gt; let ele_open = document.querySelector('#open') // 将ele_open设置为open状态的shadow节点 let ele_open_shadow = ele_open.attachShadow({mode: 'open'}) // 为ele_open的shadow上下文添加一个子节点 let ele_open_child = document.createElement('div') ele_open_child.id = 'ele_open_child' ele_open_child.innerText = '123' ele_open_shadow.appendChild(ele_open_child) &lt;/script&gt; 此时，我们想要访问它下面的子节点，可以通过open元素下的shadowRoot属性获取到它下面的shadow上下文，然后再通过元素选择器获取到它的子节点
// JS获取shadow中的节点 document.querySelector('#open').shadowRoot.querySelector('#ele_open_child') 2、shadow-root(closed) 假设页面中有一个id为closed的div元素，我们可以通过下面的代码将它设置为一个closed状态的ShadowDOM节点，并为它添加一个子节点ele_closed_child。
&lt;div id="closed"&gt;&lt;/div&gt; &lt;script&gt; let ele_closed = document.querySelector('#closed') // 将ele_closed设置为closed状态的shadow节点 let ele_closed_shadow = ele_closed.attachShadow({mode: 'closed'}) // 为ele_closed的shadow上下文添加一个子节点 let ele_closed_child = document.createElement('div') ele_closed_child.id = 'ele_closed_child' ele_closed_child.innerText = '123' ele_closed_shadow.appendChild(ele_closed_child) &lt;/script&gt; 此时，上面的方法就行不通了，closed元素的shadowRoot属性为null
此时如果想要获取closed shadow中div，就需要借助浏览器插件，思路是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f185438334ca345e8024cf08f7d36fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc69db0811e81a7ad621274f1de80112/" rel="bookmark">
			基于vue3&#43;ts&#43;scss的后台管理系统(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建项目 vite创建项目 注意：vite需要Node.js版本&gt;=12.0.0
安装方式（不使用模板）：
#使用 NPM: npm init vite@latest #yarn 【推荐】 yarn create vite #pnpm pnpm create vite 填写项目名-&gt;选择vue-&gt;选择TS-&gt;安装依赖(npm i)-&gt;启动项目(npm run dev)
清除项目&amp;工程化项目搭建 src api ajax工具管理文件夹assets 静态资源目录components 公共小组件directives 自定义指令文件夹hooks 全局hooks函数 文件夹layout 框架router 路由store pinia仓库utils 工具文件夹views 页面级别组件文件夹 types 全局ts约束配置 重置样式&amp;安装sass及配置 重置样式：拷贝一些样式文件到assets/styles下
安装sass: npm i sass -D
在main.ts文件中引入重置样式文件
import { createApp } from 'vue' import App from './App.vue' import './assets/styles/index.scss' const app = createApp(App) app.mount('#app') 使用重置样式中的变量，要先在vite.config.ts中配置
export default defineConfig({ plugins: [vue()], css: { // CSS 预处理器 preprocessorOptions: { scss: { additionalData: `@import '@/assets/style/variables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc69db0811e81a7ad621274f1de80112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea480deff1560f0b841beed3828acdc/" rel="bookmark">
			毕业设计 图像识别文字区域提取算法研究与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 项目说明1 使用说明2 算法流程3 部分实验效果4 项目源码5 最后 0 项目说明 图像中文字区域提取研究
提示：适合用于课程设计或毕业设计，工作量达标，源码开放
1 使用说明 基于swt和mser算法的文本检测，用到了SVM分类器只限于检测字体较为规范的英文文本使用时，先运行mser_swt.m文件，再运行detection_Eng.m文件 2 算法流程 3 部分实验效果 4 项目源码 %函数功能：计算输入图像的笔画宽度图像 %包含两次计算，第二次为笔画拐角处的计算值的修正 function [swtmap2]=SwtTransform(str,searchDirection) im=imread(str); if size(im,3)==3 im=rgb2gray(im); end im=im2double((im)); %figure,imshow(im); edgeMap=edge(im,'canny'); %figure,imshow(edgeMap,[]); sobelMask = fspecial('sobel'); dx = imfilter(im,sobelMask); dy = imfilter(im,sobelMask'); [edgePointRows, edgePointCols] = find(edgeMap); %初始化梯度角度矩阵 theta=zeros(size(edgeMap,1),size(edgeMap,2)); %计算边缘图像中每个像素的梯度方向 for i=1:size(edgeMap,1) for j=1:size(edgeMap,2) if edgeMap(i,j)==1 theta(i,j)=atan2(dy(i,j),dx(i,j)); end end end [m,n] = size(edgeMap); % 初始化笔画宽度 swtMap = zeros(m,n); for i=1:m for j=1:n swtMap(i,j) =1000; end end % 笔划宽度最大值 maxStrokeWidth = 350; % 初始化矩阵储存所有可能的笔画点 strokePointsX = zeros(size(edgePointCols)); strokePointsY = zeros(size(strokePointsX)); sizeOfStrokePoints = 0; widthvalue=zeros(1,10000); widthvalue(1)=inf; % Iterate through all edge points and compute stoke widths for i=1:size(edgePointRows) step = 1; initialX = edgePointRows(i); initialY = edgePointCols(i); isStroke = 0; initialTheta = theta(initialX,initialY); sizeOfRay = 0; pointOfRayX = zeros(maxStrokeWidth,1); pointOfRayY = zeros(maxStrokeWidth,1); % 记录射线的第一个点 pointOfRayX(sizeOfRay+1) = initialX; pointOfRayY(sizeOfRay+1) = initialY; % 增加射线长度 sizeOfRay = sizeOfRay + 1; while step &lt; maxStrokeWidth nextX = round(initialX + cos(initialTheta) * searchDirection * step); nextY = round(initialY + sin(initialTheta) * searchDirection * step); step = step + 1; if nextX &lt; 1 || nextY &lt; 1 || nextX &gt; m || nextY &gt; n break end % 记录射线的下一个点 pointOfRayX(sizeOfRay+1) = nextX; pointOfRayY(sizeOfRay+1) = nextY; %增加射线长度 sizeOfRay = sizeOfRay + 1; % 找到对应的边缘像素点 if edgeMap(nextX,nextY) oppositeTheta = theta(nextX,nextY); % 判断梯度方向角度 if abs(abs(initialTheta - oppositeTheta) - pi) &lt; pi/2 isStroke = 1; strokePointsX(sizeOfStrokePoints+1) = initialX; strokePointsY(sizeOfStrokePoints+1) = initialY; sizeOfStrokePoints = sizeOfStrokePoints + 1; end break end end if isStroke % 计算笔划宽度 strokeWidth = sqrt((nextX - initialX)^2 + (nextY - initialY)^2); widthvalue(i)=strokeWidth; % Iterate all ray points and populate with the minimum stroke width for j=1:sizeOfRay swtMap(pointOfRayX(j),pointOfRayY(j)) = min(swtMap(pointOfRayX(j),pointOfRayY(j)),strokeWidth); end end end a=max(widthvalue,[],2); [a,b]=size(swtMap); for i=1:m for j=1:n if swtMap(i,j)&gt;=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea480deff1560f0b841beed3828acdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc7c71a1fa0c5b92b07865cb4d5bcfce/" rel="bookmark">
			Ubuntu/Linux用户管理与权限管理（超详细解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于实验室几个老师的学生要共同使用一台服务器，所以需要规范一下服务器的使用，并且给各位学生配置相关的用户和权限，之前一直都是自己用，所以借此机会学习和总结一下Linux服务器的用户管理与权限管理。
Ubuntu/Linux用户管理与权限管理 用户与用户组根用户——root用户用户组创建与删除创建新用户修改用户与用户账号有关的系统文件（查看用户/用户组） 文件/目录权限管理查看权限修改/设置权限修改文件所属权 用户与用户组 根用户——root用户 在Ubuntu下，终端提示符里$表示普通管理员，#表示系统管理员（也就是root用户），root用户默认是没有密码的，启用root用户，就需要给root用户设置密码，命令如下：
$ sudo passwd root 系统会先验证当前普通管理员的密码，然后要求输入两次root用户的密码，之后就可以进入root用户了，关于用户和权限的管理，最好是在root用户下操作。进入root用户下的命令如下：
$ su root 输入密码后就进入root用户了。
用户组创建与删除 很多时候在创建新用户的时候，希望把一些用户归为一个组，以便后续的管理，例如我就打算把学生的账号都放到StudentGroup里面去，在Ubuntu中，一个用户是可以同时在几个组里面的，会指定一个主要组。
1.查看用户所在组情况
可以通过id命令查看当前用户或通过id user1来查看用户user1的用户组情况，例如： id user1 uid=1001(user1) gid=1001(userGroup) groups=1001(userGroup),4(adm),27(sudo) 上面的命令可以看到，id user1命令的结果为显示用户名及id（uid），显示用户所在主组（gid），显示用户所在的组列表（groups），这里例子中，用户user1所在的主组为userGroup，同时也在adm，sudo用户组中。
2.创建用户组
创建用户组的命令是groupadd，普通管理员需要加sudo来执行，root用户不用。具体命令语法如下： $ sudo groupadd [options] GroupName 其中的选项可以通过命令groupadd --help来查看，一般用的不多，就不细说了，需要的自己看。
3.删除用户组
删除用户组的命令语法如下： $ sudo groupdel GroupName 4.修改用户组信息
修改用户组的命令语法如下： $ sudo groupmod [options] GroupNameOld 其中的选项可以通过命令groupmod --help来查看，常用的主要是以下两个：
-g NewID：为GroupNameOld用户组指定新的组id -n NewGroupName:为GroupNameOld用户组指定新的组名称 例如下面一条命令：
$ sudo groupmod -g 10001 -n group2 group1 即为将用户组group1改名为group2，同时组id设置为10001。
4.用户组管理
用户组管理的命令是gpasswd，通常用来给用户组添加或移除用户，其基本语法如下： gpasswd [option] GroupName 可以通过gpasswd --help来查看选项列表，其中常用的选项有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc7c71a1fa0c5b92b07865cb4d5bcfce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf832e24c9065ff33b04f63fce87994/" rel="bookmark">
			JAVA获取磁盘名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码
FileSystemView fileSystemView = FileSystemView.getFileSystemView(); File[] files = File.listRoots(); for (File file : files) { System.out.println(fileSystemView.getSystemDisplayName(file)); } 输出
Windows (C:) 软件 (D:) 数据 (E:) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb52c75373bb884563250ada0adc544/" rel="bookmark">
			el-table @selection-change实现多选框的效果以及可以进行批量删除的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.2.2今天我学习了如何在表格中添加多选框并且可以进行多选的效果，以及可以进行批量删除的操作。
效果：
没选中时 多选但不全选 全选 html代码如下：
// @selection-change="handleSelectionChange"实现多选框的方法 &lt;el-table @selection-change="handleSelectionChange"&gt; // type="selection" 设置多选框 把type类型设置为selection为多选框 &lt;el-table-column type="selection" width="55" align="center"/&gt; &lt;/el-table&gt; //:disabled="multiple"设置没有选中框时的禁用状态，在data里面默认为true（禁用） &lt;el-button type="danger" plain icon="el-icon-delete" size="mini" :disabled="multiple" @click="handleDeleteArr" &gt;删除 &lt;/el-button&gt; js代码如下：
// 多选框选中数据 handleSelectionChange(selection) { //selection拿到当前的选中数据 console.log(selection) //选中的数据 /**让data里面的默认的multiple(true)不等于选中的长度， 这样可以触发取消禁用的效果（也就是可以进行删除了）**/ this.multiple = !selection.length console.log(this.multiple) //fasle //可以使用map遍历数组拿到需要的值进行删除 let dict_code_arr = selection.map(item =&gt; (item.变量名)) /**拿到多选的长度，data里面的selected_num = [] 主要用于提示框的文字说明，比如可以知道当前删除了几个数据**/ this.selected_num = dict_code_arr.length //join用于截取字符串，传到接口的时候需要使用 let dict_code = dict_code_arr.join(',') console.log(dict_code_arr) // 1 2 3 console.log(dict_code) // 1,2,3 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eb52c75373bb884563250ada0adc544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/645b4ccef8f4ef1f52e9e68c9d194423/" rel="bookmark">
			FFmpeg 音频重采样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.音频重采样 1.1 什么是重采样 所谓的重采样，就是改变⾳频的采样率、sample format、声道数等参数，使之按照我们期望的参数输 出。
1.2 为什么要重采样 原有的⾳频参数不满⾜我们的需求，⽐如在FFmpeg解码⾳频的时候，不同的⾳ 源有不同的格式，采样率等，在解码后的数据中的这些参数也会不⼀致(最新FFmpeg 解码⾳频后，⾳频格 式为AV_SAMPLE_FMT_FLTP，这个参数应该是⼀致的)，如果我们接下来需要使⽤解码后的⾳频数据做 其他操作，⽽这些参数的不⼀致导致会有很多额外⼯作，此时直接对其进⾏重采样，获取我们制定的⾳频 参数，这样就会⽅便很多。
再⽐如在将⾳频进⾏SDL播放时候，因为当前的SDL2.0不⽀持planar格式，也不⽀持浮点型的，⽽最新的 FFMPEG 16年会将⾳频解码为AV_SAMPLE_FMT_FLTP格式，因此此时就需要我们对其重采样，使之可以在SDL2.0上进⾏播放。
1.3 可调节的参数 通过重采样，我们可以对：
sample rate(采样率)sample format(采样格式)channel layout(通道布局，可以通过此参数获取声道数 2.音频重采样参数解析 2.1. 采样率 采样设备每秒抽取样本的次数 nb_samples
2.2. 采样格式(位宽) 每种⾳频格式有不同的量化精度（位宽），位数越多，表示值就越精确，声⾳表现自然就越精准。 FFMpeg中⾳频格式有以下⼏种，每种格式有其占⽤的字节数信息（libavutil/samplefmt.h）：
enum AVSampleFormat { AV_SAMPLE_FMT_NONE = -1, AV_SAMPLE_FMT_U8, ///&lt; unsigned 8 bits AV_SAMPLE_FMT_S16, ///&lt; signed 16 bits AV_SAMPLE_FMT_S32, ///&lt; signed 32 bits AV_SAMPLE_FMT_FLT, ///&lt; float AV_SAMPLE_FMT_DBL, ///&lt; double AV_SAMPLE_FMT_U8P, ///&lt; unsigned 8 bits, planar AV_SAMPLE_FMT_S16P, ///&lt; signed 16 bits, planar AV_SAMPLE_FMT_S32P, ///&lt; signed 32 bits, planar AV_SAMPLE_FMT_FLTP, ///&lt; float, planar AV_SAMPLE_FMT_DBLP, ///&lt; double, planar AV_SAMPLE_FMT_S64, ///&lt; signed 64 bits AV_SAMPLE_FMT_S64P, ///&lt; signed 64 bits, planar AV_SAMPLE_FMT_NB ///&lt; Number of sample formats.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/645b4ccef8f4ef1f52e9e68c9d194423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05b5fc7fc9edcf9dc165d2123b0410a/" rel="bookmark">
			TemplateInputException: An error happened during template parsing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TemplateInputException: An error happened during template parsing (template: "ServletContext resource [/WEB-INF/templates/index.html")
ssm项目，用的thymeleaf，视图解析时总出错，检查了视图解析器和视图名称，都没错。最后才发现是把WEB-INF目录搞成webapp的同级目录了，把WEB-INF目录移到webapp目录里面就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e7d6dca152841e30d0000e05b3da48d/" rel="bookmark">
			Docker使用记录——测试LIO_SAM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker使用记录——测试LIO_SAM 参考链接 🐳Docker概念，工作流和实践 - 入门必懂_哔哩哔哩_bilibili
Docker学习笔记：Docker 基础用法和命令帮助 - docker ppt - docker中文社区
Docker Hello World | 菜鸟教程 相关概念 docker build docker run docker push docker pull docker commit docker tag Dockerfile
定制镜像文件 Image
镜像 Container
容器 Docker
Hub 获取管理员权限 docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令
sudo groupadd docker #添加docker用户组 sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中 newgrp docker #更新用户组 docker ps #测试docker命令是否可以使用sudo正常使用 获取镜像 如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：
docker pull ubuntu #默认拉取最新的latest # docker pull ubuntu:18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e7d6dca152841e30d0000e05b3da48d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13becc0087411d3bc1e74c5b13624764/" rel="bookmark">
			AOP的一点浅薄理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP思想应该怎么去理解！
Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。
Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。
Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。
Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。
Target（目标对象）：织入 Advice 的目标对象。
Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程
以下仅代表个人理解
个人理解,Join point就是需要Advice的方法,而切面操作可能要对大量的类进行Advice,所以就要先声明这些所有的Join point,可以这么理解Pointcut切点是所有Join point连接点的集合,Join point 是Pointcut的真子集,Pointcut可以使用通配符,这样就降低Join point的声明成本,即没有Pontcut或者说Pointcut不是必须的,必须的是Join point,指代需要进行切面处理的方法
总结,Join point指代需要进行切面处理的方法,Pointcut是所有需要进行切面处理的方法,Advice是对方法进行的处理(即增强操作,与业务无关,如日志打印,全局异常拦截,统一返回值,多数据源的切换等)
个人认为最难理解的点可能就是命名,真是莫名其妙,我之前学习的时候就一直没搞明白切点,连接点,叫切线还差不多,线是点的集合,哈哈
要我命名的话,我要把Join point 命名为处理点handle point,Pointcut命名为切入点集(英文还没想好),Advice通知,叫这名也行,可以理解为通知Join point,要对其进行增强了,只能这么强行理解了
dependencies 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- aop 依赖, aspectj --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13becc0087411d3bc1e74c5b13624764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13571d3356c0ca8b8c665dbcfe045b9/" rel="bookmark">
			opencv&#43;pytorch&#43;ncnn使用CNN学习颜色空间RGB踩坑记（附带NCNN源码学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习和使用opencv读取和处理图像，然后用pytorch训练深度学习模型，部署和推理的时候用opencv+ncnn进行，过程中参考了很多网上教程和案例，结合源码发现了一个关于颜色空间的问题，很多网上资料的源码示例中并没有注意，自己也被误导了，特别记录一下，也供大家参考
核心思想总结：当我们所有的彩色图像处理都打算采用RGB格式数据的时候，切记用opencv读取图像后要将图像从BGR转成RGB，因为opencv读取彩色图像默认是BGR！！！
贴两段网上找的网友给出的代码，
代码一（opencv+ncnn，C++）：
cv::Mat img = cv::imread("image.jpg", 1); int w = img.cols; int h = img.rows; // subtract 128, norm to -1 ~ 1 ncnn::Mat input = ncnn::Mat::from_pixels_resize(img.data, ncnn::Mat::PIXEL_BGR, w, h, 100, 100); float mean[1] = { 128.f }; float norm[1] = { 1/128.f }; in.substract_mean_normalize(mean, norm); ncnn::Net net; net.load_param("model.param"); net.load_model("model.bin"); ncnn::Extractor ex = net.create_extractor(); ex.set_light_mode(true); ex.set_num_threads(4); ex.input("data", in); ncnn::Mat feat; ex.extract("output", feat); 代码二（opencv+pytorch，python）：
img = cv2.imread('a.png', 1).astype(np.uint8) img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13571d3356c0ca8b8c665dbcfe045b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b71dccd1740d7d9c9b0c824606424f2/" rel="bookmark">
			Google Chrome谷歌浏览器离完整离线安装包下载地址整理总汇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google Chrome谷歌浏览器离完整离线安装包下载地址整理总汇 每次重装系统，都要为安装 Chrome 而烦恼。
虽然现在可以直接从谷歌浏览器官网下载在线安装包进行安装，但是在线安装包安装的版本不可控，大概率是 x86 版本，而且在断网状态下也是行不通的。
整理了一些可以直接下载 Google Chrome 离线完整包的地址：
官方渠道： 1、链接直接打开就可以下载，最新版实时更新。
32位（x86）：https://dl.google.com/tag/s/installdataindex/update2/installers/ChromeStandaloneSetup.exe
64位（x64）：https://dl.google.com/tag/s/installdataindex/update2/installers/ChromeStandaloneSetup64.exe
2、各版本官方下载地址：
在 Chrome 首页的链接下载 https://www.google.com/intl/zh-CN/chrome/thank-you.html?installdataindex=empty&amp;standalone=1&amp;statcb=0&amp;defaultbrowser=0
参数说明：
platform=win ：适用平台为 Windows（包括 win 32位和 win64 64位版）
installdataindex=defaultbrowser ：安装后设 Chrome 为默认浏览器
extra=stablechannel ：指定版本为稳定版（版本有 stablechannel、betachannel、devchannel、canarychannel ）。
如果没有自动下载，尝试点击右上角的“下载 Chrome”。如果链接打不开，可以尝试使用 P2P 下载。
分平台/版本快捷下载：
Windows 平台：
1、Windows 平台 32 位版本（在线安装包）：
Stable正式版：下载 Chrome
Bata 测试版：下载 Chrome 测试版
DEV 开发版：下载 Chrome 开发者版
Canary 金丝雀版：下载 Chrome Canary 版
2、Windows 平台 64 位版本（在线安装包）：
Stable正式版：下载 Chrome（64位）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b71dccd1740d7d9c9b0c824606424f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98828de3cfa2a57fa25aa19842232244/" rel="bookmark">
			数据库密码定期轮换（AWS版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 需要定期轮换AWS上面的RDS数据库的密码，而且，需要让业务程序无感知。
思路 AWS有个一个aws-secretsmanager-jdbc库，只要在SpringBoot的基础上面集成即可，就可以使用secrets manager来定期轮换数据库的密码了。
解决步骤 这里用的是私有vpc，所以需要一些准备工作。
安全组 这里需要许可内网vpc内部能够访问Secrets Manager的REST API，所以，需要许可vpc内部的能够使用443端口进行出入站。配置类似如下：
注意：这里的出站入站规则都是内网地址，并且都是443端口的流量。
endpoint 接下来，配置vpc的Secrets Manager服务端口，保证vpc内部能够通过内网访问调用Secrets Manager接口。
注意：这里私有vpc必须是RDS同一个，这里的安全组，选择之前创建许可出站443端口的安全组即可。
Secrets Manager 参加一个密钥，并且让Secrets Manager定期轮换这个密钥的密码。后期，还需要将这个密钥集成到SpringBoot里面。创建密钥类似如下：
这里填入数据库用户名和密码。
注意：这里的数据库用户必须是数据库已经存在的用户。
注意：这里配置Lambda轮换函数，这里Lambda轮换函数也可以自动生成，默认是自动生成的，也是可以的。
直接验证 点击【立即轮换密钥】，进行密钥轮换，如下图：
然后，在执行轮换密钥的Lambda的监控CloudWatch日志组中可以发现类似日志：
finishSecret: Successfully set AWSCURRENT stage to version ...，则表示轮换密码完成。最后，可以从【检索密钥值】中查看密码。进行登录测试，测试验证结果如下图：
上图使用test用户和轮换后的密码，成功登录数据库。
aws-secretsmanager-jdbc集成 假设基础工程是SpringBoot的Maven项目。
Maven &lt;dependency&gt; &lt;groupId&gt;com.amazonaws.secretsmanager&lt;/groupId&gt; &lt;artifactId&gt;aws-secretsmanager-jdbc&lt;/artifactId&gt; &lt;version&gt;1.0.11&lt;/version&gt; &lt;/dependency&gt; application.yml spring: datasource: url: jdbc-secretsmanager:mysql://xxx:3306/xxx username: dev/test/rds driver-class-name: com.amazonaws.secretsmanager.sql.AWSSecretsManagerMySQLDriver 这里主要就是设置jdbc驱动类为com.amazonaws.secretsmanager.sql.AWSSecretsManagerMySQLDriver和设置数据库用户为Secrets Manager的密钥名称；url使用的jdbc-secretsmanager协议。
总结 到这里aws-secretsmanager-jdbc+Spring Boot就集成完成了，这样Spring就可以在AWS云中使用轮换密钥了。
参考： Amazon Secrets Manager 轮换问题排查如何在私有 VPC 中轮换 AWS Secrets Manager 密钥？Spring Boot project using AWS RDS and Secrets Manageraws-secretsmanager-jdbc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f473facbbebcb23ec2d17ba0347d281d/" rel="bookmark">
			N个字符串全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 输入n个长度m的字符串，输出这n个字符串的全排列（n &lt;= 100, m &lt;= 100） #include &lt;stdio.h&gt; // 保存n个字符串 struct A { char str[100]; }Mem[101]; // IsUsed[10] = true， 表示字符串Mem[10]已经使用 // IsUsed[10] = false，表示字符串Mem[10]未使用 bool IsUsed[101]; // Order[1] = 10, 表示Mem[10]在第1个位置输出 int Order[101]; // n个字符串 int n; void Print(int count) { count++; if (count == n) { for(int i = 1; i &lt;= n; ++i) { if(IsUsed[i] == false) { IsUsed[i] = true; Order[count] = i; for(int i = 1; i &lt;= n; ++i) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f473facbbebcb23ec2d17ba0347d281d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e66554753e86d1e8b577f53bd53ad58/" rel="bookmark">
			keil中c语言问题汇总（佛科院——深夜学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、不理解该函数
1.TH0,TL0的解释：
2.分析：
3.总结：
二、如何理解左移右移操作：
三、如何关闭未调用函数警告：
三、sprintf函数的使用：
1、作用：
1、调用库：
2、函数参数解释：
3、格式化符号：
4、基本功能：
1、格式化数字：
5、注意：
一、不理解该函数 1.TH0,TL0的解释： 在16位定时器模式下，TH0相当于计数器0的高8位，TL0相当于定时器0的低8位。
2.分析： 假设TH0=200,TL0=100,用二进制表示应该是TH0=1100 1000，TL0=0110 0100.
TH0&lt;&lt;8:将TH0右移8位 （TH0&lt;&lt;8）=1100 1000 0000 0000
（TH0&lt;&lt;8）| TL0:将（TH0&lt;&lt;8）与 TL0进行与运算，也就是只要一方某一位为1，最后结果该位也为1，（TH0&lt;&lt;8）| TL0=1100 1000 0110 0100
3.总结： 这是最常见的处理16位数据的方法，应为一般一个字节只有8位，如果一个数据是16位，最好是把它分为高8位和低8位
二、如何理解左移右移操作： 1、移位操作会导致位溢出和位补偿0
2、具体溢出看具体定义的类型，unsign char 为8位，unsign int 为16位，unsigned long 为32位
3、左移右移操作还可以用在串行通信上：
//高位先行，也就是先发高位 void Write_byte(u8 w_data) { u8 i; for(i=0;i&lt;8;i++) { SDA=w_data&gt;&gt;7;//将低七位都溢出，留下最高位发送 w_data&lt;&lt;=1;//将次高位变成最高位 /*后面是发送的步骤*/ SCL=1; delay_us(5); SCL=0; delay_us(5); } } 三、如何关闭未调用函数警告： 找到Disable Warning Number输入相应警告的编号，就能关闭该警告
就例如这个警告的编号是16
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e66554753e86d1e8b577f53bd53ad58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d9832e79c033843f75e2a16b819f7a2/" rel="bookmark">
			如何利用 HBuilderX 制作图文混排的网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何利用 HBuilderX 制作图文混排的网页
实践项目：
1、在D盘创建名为web的基本web项目
2、创建一个空白网页文件，命名为gsjj.html
3、网页文件用于介绍公司的基本情况，要求包含标题，正文和图片。
一、新建一个基本项目，项目名称命名为web。
二、将素材图片文件复制粘贴到项目文件夹的img文件夹中。
三、鼠标右击标题“web1”，在菜单栏中选择新建一个html文件，命名为gsjj.html
四、两title之间为标题文字，两body之间为正文文字，根据要求在其两者之间编辑内容即可。
五、使用&lt;p标签在开始和结束标签之间插入文本文字，其中强调文本加粗显示的文字两边加上标签&lt;strong。斜体显示的文字两端加上&lt;em标签。编辑完成后选择相应浏览器运行即可。（具体标签如图所示，该编辑器无法显示。）
六、运行界面
七、HBuilderX 界面
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;蜘蛛侠&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;&lt;strong&gt;蜘蛛侠&lt;/strong&gt;,全名彼得·本杰明·帕克&lt;em&gt;（Peter Benjamin Parker）&lt;/em&gt;， &lt;p&gt;是美国的一名普通学生，毕业后成为《号角日报》的记者。&lt;/p&gt; &lt;p&gt;由于意外被一只受过放射性感染的蜘蛛咬到，因此获得了和蜘蛛一样的超能力、 超人般的耐力、反应、敏捷和速度。&lt;/p&gt; &lt;p&gt;并发明了蛛网发射器，从此化身&lt;strong&gt;蜘蛛侠&lt;/strong&gt;&lt;em&gt;（Spider-Man）&lt;/em&gt;守卫纽约。&lt;/p&gt; &lt;img src="img/x蜘蛛侠.jpeg"&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e78cf820ea112f5d7e965ef789caa1d/" rel="bookmark">
			设计模式之状态模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 状态这个词汇我们并不陌生，在日常生活中，不同时间就有不同的状态，早上起来精神饱满，中午想睡觉，下午又渐渐恢复，晚上可能只想睡觉，这就对应着一天中不同的状态。
二、定义 状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。
2.1. 模式的结构
状态模式包含以下主要角色。
环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。 UML图如下：
代码
using System; using System.Collections.Generic; namespace ConsoleApp1 { /// &lt;summary&gt; /// 环境类 /// &lt;/summary&gt; public class Context { private State state; //定义环境类的初始状态 public Context() { this.state = new ConcreteStateA(); } //设置新状态 public void setState(State state) { this.state = state; } //读取状态 public State getState() { return (state); } //对请求做处理 public void Handle() { state.Handle(this); } } /// &lt;summary&gt; /// 抽象状态类 /// &lt;/summary&gt; public abstract class State { public abstract void Handle(Context context); } //具体状态A类 public class ConcreteStateA : State { public override void Handle(Context context) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e78cf820ea112f5d7e965ef789caa1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6828bbd751adfbbbb5edd552e5f947/" rel="bookmark">
			电子技术——MOS放大器基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子技术——MOS放大器基础 我们已经学过MOS可以当做一个压控流源，使用栅极电压 v G S v_{GS} vGS​ 控制漏极电流 i D i_D iD​ 。尽管两个量的关系不是线性的，稍后我们将会介绍偏置在线性区的工作方法。
构建压控压源放大器 现在，我们有了一个压控流源，将电流线性转换为电压只需要将电流通过一个电阻，然后测量电阻电压即可。
如上图，电阻 R D R_D RD​ （称为负载电阻）通过栅极电流，输出电压：
v O = v D S = V D D − i D R D v_O = v_{DS} = V_{DD} - i_D R_D vO​=vDS​=VDD​−iD​RD​
电压传导特性曲线 根据上面的关系式，我们构建起 v O v_O vO​ 和 v G S v_{GS} vGS​ 之间的传导特性关系曲线：
注意到，当 v G S &lt; V t v_{GS} &lt; V_t vGS​&lt;Vt​ 的时候，MOS管处于截止区，此时栅极无电流通过，输出电压即为 V D D V_{DD} VDD​ 。当 v G S v_{GS} vGS​ 继续增大，MOS管进入饱和区，输出电压持续减小，当达到临界点 B B B 点时，MOS管进入三极管区，输出电压迅速减小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6828bbd751adfbbbb5edd552e5f947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4c743ea4507aa92de5ca8b3dda1c33/" rel="bookmark">
			uniapp 分页加载吸顶（模仿微信账单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分页吸顶
(一个php程序员刚学会uniapp 开发的，目前不能用scroll-view,没法获取到页面滚动的距离)
废话不说，直接上代码
&lt;template&gt;
&lt;view class="pageBox"&gt;
&lt;view class="border-bottom white" v-for="(item,index) in list" &gt;
&lt;view v-if="item.ismf" class="flex-between pd20 bg box" :class="[(isFixedTop[item.mfk]) ?'fixedTop' : '']" :style="{'z-index':index+10000}"&gt;
&lt;view class="fontSize30 "&gt;{{item.Y}}年{{item.M}}月&lt;/view&gt;
&lt;view class="fontSize26 fontColor mgtop10"&gt;支出￥{{item.income}} &amp;nbsp;&amp;nbsp;收入￥{{item.expenditure}}&lt;/view&gt;
&lt;/view&gt;
&lt;!-- 占位 --&gt;
&lt;view v-if="!index" class="tops"&gt;&lt;/view&gt;
&lt;view class="flex-between pd20" &gt;
&lt;view class="fontSize28 fontColor"&gt;
&lt;view class="lineHeight"&gt;申请提现&lt;/view&gt;
&lt;view class="lineHeight"&gt;订单编号：29928822982227&lt;/view&gt;
&lt;/view&gt;
&lt;view class="fontSize28 fontColor"&gt;
&lt;view class="blackColor text-right lineHeight fw"&gt;{{item.amount}}&lt;/view&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;view class="lineHeight50 fontSize28 fontColor flex-align-center pd20"&gt;
&lt;u-icon name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4c743ea4507aa92de5ca8b3dda1c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2fb13ced5552500e753c5125859779/" rel="bookmark">
			[NSSRound#7 Team]Web学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录一、ecRCE二、Shadowflag三、[NSSRound#7 Team]新的博客四、[NSSRound#7 Team]0o0 提示：以下是本篇文章正文内容，下面案例可供参考
一、ecRCE 进入题目直接给出了源码：
&lt;!-- A EZ RCE IN REALWORLD _ FROM CHINA.TW --&gt; &lt;!-- By 探姬 --&gt; &lt;?PHP if(!isset($_POST["action"]) &amp;&amp; !isset($_POST["data"])) show_source(__FILE__); putenv('LANG=zh_TW.utf8'); $action = $_POST["action"]; $data = "'".$_POST["data"]."'"; $output = shell_exec("/var/packages/Java8/target/j2sdk-image/bin/java -jar jar/NCHU.jar $action $data"); echo $output; ?&gt; 直接使用了shell_exec运行了一个java文件，后面接了 a c t i o n 和 action和 action和data变量，可以使用管道符直接运行命令。
二、Shadowflag 进入题目直接给出源码 from flask import Flask, request import os from time import sleep app = Flask(__name__) flag1 = open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2fb13ced5552500e753c5125859779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd164cf2a3a4366e0de76ac201015dd/" rel="bookmark">
			elementUI Steps 步骤条 样式以及方法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改步骤条颜色 原本步骤条：
期望修改：
实现：（主要是css修改）
div class="theSteps"&gt; &lt;el-steps :active="active" finish-status="success" &gt; &lt;el-step title="步骤 1" description=""&gt;&lt;/el-step&gt; &lt;el-step title="步骤 2"&gt;&lt;/el-step&gt; &lt;el-step title="步骤 3"&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;/div&gt; // 步骤条 .theSteps{ /* 进行中状态：圈线 */ .el-step__head.is-process { color: #0076F6; border-color: #0076F6; } /* 进行中状态：圈内 */ .el-step__head.is-process &gt; .el-step__icon { background: #0076F6; color: #fff; } /* 进行中状态：title（文字） */ .el-step__title.is-process { color: #0076F6; font-size: 14px; } /* 完成状态：圈线 */ .el-step__head.is-success { color: #0076F6; border-color: #0076F6; } /* 完成状态：圈内 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcd164cf2a3a4366e0de76ac201015dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8572718e57d594650e5a58db25e1b5/" rel="bookmark">
			os.system 返回值乱码一行代码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python os.system 返回值乱码一行代码解决 核心代码：os.system('chcp 65001') # 将cmd的显示字符编码从默认的GBK改为UTF-8
import os os.system('chcp 65001') # 将cmd的显示字符编码从默认的GBK改为UTF-8 while True: b = input("请输入windows命令:") def van(): return os.system(b) a = van() print(a) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af92fa63328e313d6f5964ea0a97d54/" rel="bookmark">
			cmd命令行下将多个文件按文件名合并为一个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.将所有需要合并的文件放到同一个文件夹folder，要求需要合并的文件后缀一致。
2.打开cmd，根据文件路径找到forder文件夹。
3.命令行中输入
copy *.文件后缀 合成文件名.文件后缀 意思为：将当前文件夹的所有文件后缀为 .文件后缀 的文件合并为 合成文件名.文件后缀。
注意事项：
此命令是按照文件名的顺序合并文件的。对于数字命名文件，11.文件后缀 会优先 2.文件后缀 合并，22.文件后缀 会优先 3.文件后缀合并，等等。
于是1.文件后缀，11.文件后缀，111.文件后缀，1111.文件后缀…都会优先于 2.文件后缀 合并。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b78e84b143a9c6212550a9b0bead59d/" rel="bookmark">
			【工具】【安卓】EasyClick安卓代理模式批量激活器【Beta】,基于官方1.13激活器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试版,有什么功能建议可以在此贴留言
adb版本1.40.0
agent版本1.13.0
软件下载地址csdn:
https://download.csdn.net/download/mr_oldcold/87404506?spm=1001.2014.3001.5501
或到我的论坛里搜索下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813ca7cfa450af47561b5cc00faa19f3/" rel="bookmark">
			Centos使用lanproxy，搭建一个属于自己的内网穿透服务器(附转发失败解决方法)，小白向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
准备工作
搭建与使用
1. 安装git工具
2. 安装java环境
3. 安装maven工具
4. 搭建Lanproxy
5. 启动内网穿透服务 6. 设置开机自启
转发失败解决方法
前言 最近白嫖了7个月阿里云的服务器，顺带研究了一下，发现有挺多有趣又好玩的东西，比如搭建博客、网站呀，还有搭建内网穿透服务器和socket5、http代理服务器等等。因为刚开始不太懂，搭建的时候出了点问题，本文就简单记录一下搭建过程和转发失败解法思路，希望对萌新有所帮助吧
工具github地址： https://github.com/ffay/lanproxy
工具gitee地址 ： https://gitee.com/fengfei/lanproxy
准备工作 1. 服务端，一台公网服务器(这里我用的是阿里云的，目前学生活动可以白嫖7个月)
2. 客户端，能联网的机器linux或windows都行(这里用kali)
3. 爱动手和爱思考的你
搭建与使用 1. 安装git工具 许多系统都默认安装有这个工具，Centos安装命令
yum install git 2. 安装java环境 这里我选用的是OpenJDK 8的环境，Centos系统可以用yum快速安装
先搜索一下包名
yum search java-1.8.0 这里安装java的运行环境和开发环境
yum install java-1.8.0-openjdk java-1.8.0-openjdk-devel -y 3. 安装maven工具 maven工具用于构建项目，直接用yum安装
yum -y install maven 4. 搭建Lanproxy 先用git下载Lanproxy包（包含服务端和客户端），Github用不了可以用Gitee
git clone https://gitee.com/fengfei/lanproxy.git (推荐) 或 git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/813ca7cfa450af47561b5cc00faa19f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6699cd052f3a4c4cec6eea902d77ac0/" rel="bookmark">
			mvc报错template: “ServletContext resource [/WEB-INF/templates/index.html]“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP Status 500 - Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: “ServletContext resource [/WEB-INF/templates/index.html]”)
发现是自己创建的web文件夹和project structure里标的不一样，Web Resource Directory这里爆红了，只需要把这个文件夹改成工程里的web文件夹就可以了
可以参考The requested resource is not available——idea运行web项目一些细节的疏忽而导致的错问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12752dbe9976a3990d56873f00f9c432/" rel="bookmark">
			【2023年Android面试题汇总】金三银四必看，中高级Android程序员面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022 被视为全球经济的低谷期，如今 2023 新一年的到来，被众人赋予了很高的期望。
最近又赶上跳槽的高峰期，好多粉丝，就问我要有没有最新面试题，我连日加班好多天，终于整理好了，16000+道，930+页，2023年最新Android中高级面试题汇总。
无论是你短期内想提升 Android 内功实力，突破自己工作中的能力瓶颈，还是准备参加 Android 面试，相信都会在这份指导手册中有所收获
面试题内容展示如下：
由于文章篇幅限制，不可能将所有面试题以文字形式把大厂面试题展示出来，本篇为大家精选了一些面试题，如果你需要这份完整版的面试笔记，大厂面试真题！可以直接点击下方卡片领取
第一章 Java方面 第一节 Java基础第二节 Java集合第三节 Java多线程第四节 Java虚拟机 第二章 Android 方面 第一节 Android 四大组件相关第二节 Android 异步任务和消息机制第三节 Android UI 绘制相关第四节 Android 性能调优相关第五节 Android 中的 IPC第六节 Android 系统 SDK 相关第七节 第三方框架分析第八节 综合技术第九节 数据结构方面第十节 设计模式第十一节 计算机网络方面第十二节 Kotlin方面 第三章 音视频开发高频面试题 为什么巨大的原始视频可以编码成很小的视频呢?这其中的技术是什么呢?怎么做到直播秒开优化？直方图在图像处理里面最重要的作用是什么？数字图像滤波有哪些方法？图像可以提取的特征有哪些？… 第四章 Flutter高频面试题 第一节 Dart部分
Dart 语言的特性？Dart的一些重要概念？dart是值传递还是引用传递？Dart 多任务如何并行的？说一下 mixin？… 第二节 Flutter 部分
Flutter 特性有哪些？Flutter 中的生命周期Widget 和 element 和 RenderObject 之间的关系？mixin extends implement 之间的关系?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12752dbe9976a3990d56873f00f9c432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6250bcc826e6fb9376899ac105c2d662/" rel="bookmark">
			Centos7.9 使用rsyslog &#43; LogAnalyzer搭建日志服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装LAMP环境 略
二、安装rsyslog 查看是否已安装rsyslog
rpm -qa | grep rsyslog
导入数据库
cd /usr/share/doc/rsyslog-8.24.0/
mysql -uroot -p&lt;mysql-createDB.sql
创建用户
mysql -uroot -p
grant all privileges on Syslog.* to rsyslog@localhost identified by '&lt;数据库密码&gt;';
flush privileges;
备份rsyslog配置文件
cp /etc/rsyslog.conf /home/cgyxt/syslog/
修改rsyslog配置文件
vim /etc/rsyslog.conf
在#### MODULES ####下：
取消以下两行注释（使用UDP端口514接收日志。UDP面向无连接，适用于获取内网中的设备日志）
$ModLoad imudp
$UDPServerRun 514
增加以下内容（加载mysql连接模块，设置数据库参数）
$ModLoad ommysql
*.* :ommysql:localhost,Syslog,rsyslog,&lt;数据库密码&gt;
rsyslog默认将日志都写入本地文件/var/log/messages，查看验证：
tail -f /var/log/messages
（显示/var/log/messages文件后10行，文件有变化就显示出来）
也可以将本地日志文件按日期-IP地址归档存放：
在/etc/rsyslog.conf文件中#### GLOBAL DIRECTIVES ####下加入以下内容：
$template Remote,"/var/log/%$YEAR%-%$MONTH%-%$DAY%/%fromhost-ip%.log"
# 设置远程日志存放路径和文件格式
:fromhost-ip, !isequal, "127.0.0.1" ?Remote # 如果是本机日志则不记录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6250bcc826e6fb9376899ac105c2d662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843101a41dee3f8dd32f408f00d21c1d/" rel="bookmark">
			vue中的vuex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步:安装 vuex
npm install vuex@3
安装完成后,在package.json文件中存在vuex版本:如图
在main.js文件中导入store的配置文件
import Vue from 'vue' import App from './App.vue' import store from "@/store/store";//导入store的配置文件 Vue.config.productionTip = false new Vue({ store,//在vue实例中引用 render: function (h) { return h(App) }, }).$mount('#app') 在src文件夹下创建文件夹store。store下再创建store.js文件，在store.js文件中:
store分为:
state:{}该对象中声明的值在其他所有组件中都可直接调用
getters:{}监听state中的属性值是否变动,当属性值发生变动时getters会主动监测并进行改变，不需要进行显示调动；
mutations:{}同步修改store中的值
actions:{}异步的方式触发mutations，间接的实现对state的修改
modules:{}让每一个模块拥有自己的state、mutation、action、getters
import Vue from 'vue' import Vuex from 'vuex' //全局注册vuex Vue.use(Vuex) //定义全局的store export default new Vuex.Store({ state:{//Vuex核心 //定义状态属性并进行初始化,在组件中可以通过 this.$store.state.属性名 直接获取属性值 count:0, age:0 }, //getters: //(1)类似于组件的computed计算属性; //(2)作用:监听state中属性的变化(获取state中的值); //(3)用法:this.$store.getters.属性名 getters:{ getAge(state){//this.$store.getters.getAge可以获取到state中的age return state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/843101a41dee3f8dd32f408f00d21c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580cb02334ec1eb9c7fd1447abc8c71a/" rel="bookmark">
			MyBatis中使用Mapper代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
Mapper代理解决硬编码 前言一、定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下二、1.设置SQL映射文件的namespace属性为Mapper接口全限定名2.修改mybatis-config.xml中的映射文件 三，在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id,并保持参数类型和返回值类型一致四.编码六.添加MyBatisX插件 前言 一、定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下 二、 1.设置SQL映射文件的namespace属性为Mapper接口全限定名 2.修改mybatis-config.xml中的映射文件 Mapper代理，可以用包扫描的方式加载映射文件
三，在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id,并保持参数类型和返回值类型一致 四.编码 在MybatisDemo中过SqlSession的getMapper方法获取Mapper接口的代理对象调用对应方法完成sq的执行 package com.itheima; import com.itheima.mapper.UserMapper; import com.itheima.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; import java.util.List; /* * Mybatis中Mapper代理开发 * */ public class MybaitsDemo { public static void main(String[] args) throws IOException { //1.加载Mybaits核心配置文件，获取SqlSessionFactory String resource = "mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.获取sqlSession对象，来执行sql语句 SqlSession sqlSession = sqlSessionFactory.openSession(); //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/580cb02334ec1eb9c7fd1447abc8c71a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c032b2fd1a304970f35c65f1abb841b6/" rel="bookmark">
			【高并发】高并发环境下优化Tomcat性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【摘要】 并发环境下优化Tomcat性能可以提升很大的系统性能，不信你试试？
写在前面 Tomcat作为最常用的Java Web服务器，随着并发量越来越高，Tomcat的性能会急剧下降，那有没有什么方法来优化Tomcat在高并发环境下的性能呢？ Tomcat运行模式 Tomcat的运行模式有3种。
1.bio模式
默认的模式,性能非常低下,没有经过任何优化处理和支持。
2.nio模式
利用java的异步io护理技术,noblocking IO技术。要想运行在该模式下，则直接修改server.xml里的Connector节点,修改protocol为如下配置。
protocol="org.apache.coyote.http11.Http11NioProtocol" 重启Tomcat后，就可以生效。
3.apr模式
安装起来最困难,但是从操作系统级别来解决异步的IO问题,大幅度的提高性能。此种模式下，必须要安装apr和native，直接启动就支持apr。如nio修改模式，修改protocol为org.apache.coyote.http11.Http11AprProtocol，如下所示。
protocol="org.apache.coyote.http11.Http11AprProtocol" Tomcat并发优化 安装APR [root@binghe ~]# yum -y install apr apr-devel openssl-devel[root@binghe ~]# tar zxvf tomcat-native.tar.gz[root@binghe ~]# cd tomcat-native-1.1.24-src/jni/native[root@binghe native]# ./configure --with-apr=/usr/bin/apr-1-config --with-ssl=/usr/include/openssl/[root@binghe native]# make &amp;&amp; make install 安装完成之后 会出现如下提示信息
Libraries have been installed in: /usr/local/apr/lib 安装成功后还需要对tomcat设置环境变量，方法是在catalina.sh文件中增加1行：
在这段代码下面添加：
============# OS specific support. $var _must_ be set to either true or false.cygwin=false darwin=false ==============CATALINA_OPTS=”-Djava.library.path=/usr/local/apr/lib” 修改server.xml的配置，如下所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c032b2fd1a304970f35c65f1abb841b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2723672e993855706894ac69bdbe9989/" rel="bookmark">
			LINQ表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LINQ表达式 1.概述2.from子句2.1 单个from子句2.2 复合from子句 2.3多个from子句3.where子句3.1常见的where子句查询3.2在where子句中使用自定义函数3.3动态谓词的筛选 4.select子句4.1输出查询结果4.2对查询结果进行投影 5.group子句5.1分组查询 6.into子句7. 排序子句7.1ThenBy和ThenByDescending 8.let子句9.join子句 1.概述 LINQ的全称是Language Integrated Query，中文译成“语言集成查询”。LINQ作为一种查询技术，首先要解决数据源的封装，大致使用了三大组件来实现这个封装，分别是LINQ to Object、LINQ to ADO.NET、LINQ to XML。首先需要引入命名空间：
using System Linq
要使用LINQ来编程，首先要学习使用LINQ的子句以及由查询语法构成的查询表达式。C#3.0和VB9开始将这种查询语法引入到了编程语言，并新增了一系列的关键字。但对于CLR本身来说，它并不了解查询语法，它能理解的是由编程语言的编译器将这种查询语法转换成的方法。这些方法叫“标准查询运算符”，它们具有类似这样的名称——Where、Select、GroupBy、Join。下面就以C#为例，从编程语言的层面来具体介绍这些查询语法（注意VB9也支持这种查询语法）。
LINQ的查询由3基本部分组成：获取数据源，创建查询，执行查询。
// 1，获取数据源
List&lt;int&gt; numbers = new List&lt;int&gt;() { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; // 2，创建查询 var numQuery = from num in numbers where num % 2 == 0 select num; // 3,执行查询 foreach (var num in numQuery) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2723672e993855706894ac69bdbe9989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdced55733de66a32696881686270065/" rel="bookmark">
			【MySQL自定义变量】 查询结果新增行号列 使用自定义变量@rownum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在表格显示等众多场景中，通常需要显示数据的序号，可强调数据的顺序性。
添加简单数字行号列 -- 1.建表test (工作中id 99.99%不用自增) CREATE TABLE `test` ( `id` int PRIMARY KEY auto_increment, `text` VARCHAR(30) DEFAULT NULL )ENGINE=InnoDB DEFAULT CHARSET=utf8mb3; -- 2.添加4条数据 INSERT test(text) VALUES ('数据1'),('数据2'),('数据3'),('数据4') -- 3.添加行号 SELECT @rownum:=@rownum+1 as row_num, t.* from ( -- 需要添加行的表 select * from test ) t, (select @rownum:=0) r; row_numidtext11数据122数据233数据344数据4 添加行号列 并前后拼接其他描述文字 使用concat字符串拼接函数 CONCAT(str1,str2,...)
SELECT CONCAT('no.',@rownum:=@rownum+1) as row_num, t.* from ( -- 需要添加行的表 select * from test ) t, (select @rownum:=0) r; row_numidtextno.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdced55733de66a32696881686270065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d736c2cd7d16454beccd062eb98602/" rel="bookmark">
			Win10 x64 红米note 11 解锁工具识别不到手机 问题[已解决]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10 x64 红米note 11 解锁工具识别不到手机 问题解决 最近买了部小米红米note11 想着刷机玩，解锁的时候，出现进入fastboot模式后，解锁工具检测不到手机的情况，网上查了问题，安装小米助手也没能解决，最后在解锁工具目录下找到驱动更新了下，解决问题
解锁工具软件目录下的驱动位置：miflash_unlock-6.5.406.31\driver\win10
解决问题步骤： 1、右键【此电脑】——&gt;【属性】——&gt;【设备管理器】
在未知设备例找到 带问号的Android
2、右键【Android】选择更新驱动 ——&gt;【浏览我的电脑以查找驱动程序】
3、跟着提示一直下一步，直至完成，现在先连接手机，刷机设备就能检测到手机了
踩过的坑记录下，希望能帮助到需要的人
温馨提示：小米账号要与设备关联7天才能解锁，否则大概率解锁失败，网上有其他可以绕过的方法，不过不没有试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9feae977cf1dd2a40d32ef9e7963a3/" rel="bookmark">
			C语言打印金字塔，菱形，V形图案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目录
文章目录
前言
一、打印金字塔（等腰三角形）
1.图案
2.代码
二、打印菱形（两个三角形拼在一起）
1.图案
2.代码
三.打印V形 1.图案 2.代码
四.打印(倒着的)V 1.图案 2.代码
总结
前言 使用C语言打印图形，金字塔（等腰三角形），菱形（用两个等腰三角形上下拼在一起），V形（有正V和倒V）。
所编写的代码是可以改变行数的，在运行时，输入行数，就可以打印出来！当然也可以直接用printf打印出来，但是行数就不可以更改了。这里是前者啊。
一、打印金字塔（等腰三角形） 1.图案 我们要打印出来如图所示的图案。
这里我们可以找到规律：第一行是1个，第二行是3个，以此类推1，3，5，7，9......... （自己想一想怎么得到这些数）。
然后我们可以发现图案前面空格的规律：第一行6个，第二行5个，以此类推6,5,4,3,2,1,0（再想一想这要怎么得到）。
2.代码 #include&lt;stdio.h&gt; int main() { int i = 0; int j = 0; int n = 0; int s = 0; printf("请输入行数："); scanf("%d", &amp;n); for (i = 0; i &lt; n; i++)//行数 { for (j = 1; j &lt; n - i; j++)//每一行之前的空格 { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba9feae977cf1dd2a40d32ef9e7963a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29e8a2662414516f3fd1139625949df/" rel="bookmark">
			【YOLO学习笔记——数据集】VOC格式转YOLO格式数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：需要下面打包好的代码文件，可私聊博主（免费）
目录
1.统计数据集中包含的类别数量
2.划分数据集并转换为YOLO格式（txt格式）
3.修改数据集yaml
4.修改train.py中的数据集格式yaml路径
1.统计数据集中包含的类别数量 这一步是为了后续改写数据集格式yaml文件所需要，为必要步骤，具体代码如下。
整个文件唯一需要改动的地方为xml_path变量，填写xml标签所在的文件夹即可。运行后即可得到数据集的所有类别及各自目标数量。
import os import random import xml.etree.ElementTree as ET clses = [] cls_num = {} xml_path = r'Annotations' temp_xml = os.listdir(xml_path) total_xml = [] for xml in temp_xml: if xml.endswith(".xml"): total_xml.append(xml) for name in total_xml: try: in_file = open(os.path.join(xml_path, name), encoding='utf-8') tree = ET.parse(in_file) root = tree.getroot() except: in_file = open(os.path.join(xml_path, name)) tree = ET.parse(in_file) root = tree.getroot() for obj in root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f29e8a2662414516f3fd1139625949df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa9a30aa2a4d66955ed36b99366da87/" rel="bookmark">
			c&#43;&#43;（24）STL引入：函数模板、类模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在C语言的常规编程工作中，经常会遇到因为形参数据类型，而定义多个函数。比如功能交换A和B的值
//int 类型数据交换 void MySwap(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; } //double 类型数据交换 void MySwap(double &amp;a, double &amp;b) { double temp = a; a = b; b = temp; } 只要A和B 这两个数据的类型不同，我就要重定义一个新函数，而这两个函数除了形参数据类型不一样，其他的逻辑都是一样的。这样就造成了代码的重复，增加维护成本。
为了解决这个问题，c++引入了 模板。
1、函数模板的基本语法 函数模板使形参类型化，实现定义的时候不关心具体的数据类型，只关心功能的实现。
编译器为了与普通函数区分，使用关键字template。
template&lt;class T&gt; template&lt;typename T&gt; 这两种使用方式表达的意思一样，根据习惯喜欢用哪个就用哪个。如果说需要使用多个类型的参数，那么也可以增加定义
template&lt;typename T1, typename T2, typename T3&gt;
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;memory&gt; using namespace std; //template&lt;class T&gt; // template&lt;typename T&gt; //这两种方式都可以 //如果需要多个类型参数的时候，可以增加定义 //template&lt;typename T1, typename T2, typename T3&gt; //使用template模板函数的时候，当出现template关键字的时候，只对紧接着出现的函数名生效 void MySwap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } //上面template的作用域消失 int main(void) { int a = 10, b = 20; cout &lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa9a30aa2a4d66955ed36b99366da87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08761a19e908c6fd7939a92c50ec9af1/" rel="bookmark">
			js 红绿灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script&gt;
// 红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何使用Promise让三个灯不断交替重复亮灯？（海康威视笔试题）
// function red(){
// console.log('red');
// }
// function green(){
// console.log('green');
// }
// function yellow(){
// console.log('yellow');
// }
setInterval(() =&gt; {
var promise=new Promise((resolve,reject)=&gt;{
setTimeout(() =&gt; {
document.write("red\n")
document.write("&lt;br&gt;")
resolve()
}, 3000);
}).then(function(){
return new Promise(function(resolve,reject){
setTimeout(() =&gt; {
document.write("green\n")
document.write("&lt;br&gt;")
resolve()
}, 1000);
})
}).then(function(){
setTimeout(() =&gt; {
document.write("yellow\n")
document.write("&lt;br&gt;")
}, 500);
})
}, 6000);
&lt;/script&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4ec233fea40a36c2aebc250565133f/" rel="bookmark">
			机器学习2-numpy和pandas的常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy numpy创建数组及基础属性 numpy是数据处理的基础，pandas也是基于numpy的，首先是numpy数组的创建。
一般我们默认导入了一下库
import numpy as np import pandas as pd 1.numpy创建数组及基础属性
arr=np.array([[1,2,3],[4,5,6],[7,8,9]]) numpy的核心特征之一就是N-维数组对象----ndarray。一个ndarray的每个元素均为相同类型
numpy的基础属性：shape ，dtype ，ndim， size
每一个数组都有一个shape属性用来表征数组每一维度的数量；每个数组都有一个dtype属性用来描述数组的数据类型。ndim返回数组的维数。size返回数组元素个数。
生成随机数 生成无约束条件的随机数
生成指定shape的均匀随机数
生成符合正太分布的随机数
random具体函数用法 一维数组索引 布尔索引 只有索引为True的会返回，所以可以根据这一特点筛选想要的数据
多维数组的索引 这是一个二维数组，假如我们要取12这个元素，那么我们要找出12所在的行列索引,中间用逗号隔开
对二维数组的切片与一维数组类似
也可以逻辑索引和切片混合
Numpy矩阵介绍 矩阵的生成
矩阵运算
Numpy读写二进制文件 Numpy读写文本文件 pandas pandas读取文本文件 一般使用pd.read_csv读取csv文件，read_table读取文本文件。两者的参数基本相同
pandas读取excel文件 将数据框存储为excel文件 这样保存数据左边也会出现一列从0开始的index，可以加参数index
构建数据框 创建DataFrame,可以用列表充当data
按行列名称访问数据框中的元素 当数据框的数量较大的时候，按顺序访问较为麻烦，这时后可以采用按行列名称访问数据框中的元素。
先构建一个新的数据框
使用loc函数进行名称的访问
转换成时间类型数据 groupby分组操作 从中提取三列数据，以’order_id’为分组依据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc3a2ffd5debe3cfb90f07241c466ba/" rel="bookmark">
			mysql排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、sort_buffer_size配置 sort_buffer_size是设置MySQL排序内存（sort_buffer）的大小的配置。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则会转到磁盘临时文件辅助排序。
二、mysql有两种排序方式 1、全字段排序，就是把所有需要查询的字段放到内存排完序后直接返回。全字段排序的优点是处理快，缺点是占内存多，这样很有可能超出sort_buffer，从而导致要用文件辅助排序。
2、排序字段排序，这是mysql为了尽量采用内存排序设计的排序方式，这种排序方式是只把需要排序的字段和每一行数据对应的唯一标识（rowid）放到内存排序，然后通过rowid找到对应的数据返回。
三、max_length_for_sort_data配置 mysql是通过max_length_for_sort_data的值判断是用“全字段排序”还是“排序字段排序”的。一行记录的大小超过这个值时则用“排序字段排序”，否则用“全字段排序”。
（这里是根据建表时所定义的字段大小的和，与这个配置的值比较大小的，并不是和数据的实际大小比较。所以建表时定义字段长度时建议越小越好）
*mysql8.0版本之前使用group by进行分组查询时，mysql会把分组查询的结果进行排序后再返回。在sql末尾加order by null 可以让mysql分组后不再进行排序。对性能有一定的优化。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf9b93f2be7f318e5aad0795dbbfadf/" rel="bookmark">
			【零基础学习YOLO】学习路径资料整理（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意：博主可有偿辅导入门，需要的可私信
1.Yolov1： 算法视频：【精读AI论文】YOLO V1目标检测，看我就够了_哔哩哔哩_bilibili【深度学习YOLO V1】深刻解读YOLO V1（图解）_ciky奇的博客-CSDN博客_yolov1网络结构图详解博客：https://zhuanlan.zhihu.com/p/32525231 2.Yolov2： 算法视频: 【精读AI论文】YOLO V2目标检测算法_哔哩哔哩_bilibili
2）博客：https://zhuanlan.zhihu.com/p/35325884
3.Yolov3： 算法视频: 【精读AI论文】YOLO V3目标检测（附YOLOV3代码复现）_哔哩哔哩_bilibili代码：https://github.com/bubbliiiing/yolo3-pytorch代码解读：https://www.bilibili.com/video/BV1Hp4y1y788?spm_id_from=333.999.0.0博客：一文看懂YOLO v3_小小小绿叶的博客-CSDN博客_yolov3 build target博客2.0（深度解析版本）：https://blog.csdn.net/leviopku/article/details/82660381 4.Yolov4： 算法视频: https://www.bilibili.com/video/BV1NF41147So?spm_id_from=333.999.0.0
代码：https://github.com/bubbliiiing/yolov4-pytorch代码解读：https://www.bilibili.com/video/BV1Q54y1D7vj?spm_id_from=333.999.0.0博客：https://zhuanlan.zhihu.com/p/143747206（包含很多yolo版本解读，只需要看v4部分即可） 5.Yolov5： 1）算法视频:
https://www.bilibili.com/video/BV1T3411p7zR?spm_id_from=444.41.0.0
代码：https://github.com/bubbliiiing/yolov5-pytorch博客：https://zhuanlan.zhihu.com/p/172121380 6.Yolov7： 1）算法视频：https://www.bilibili.com/video/BV1VG411u79Z/?spm_id_from=333.999.0.0
2）代码：https://github.com/bubbliiiing/yolov7-tiny-pytorch
3）博客：https://zhuanlan.zhihu.com/p/540068099
7.YolovX： 算法视频与代码解读: https://www.bilibili.com/video/BV1DL4y1B7eU?p=3
代码：https://github.com/bubbliiiing/yolox-pytorch 博客：https://zhuanlan.zhihu.com/p/397993315 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d070555d60b625a93607ca27e60a35/" rel="bookmark">
			win11更改系统字体的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑用久了可能早就看腻了默认的字体，那么电脑怎么更改系统字体？win11系统怎么更改系统字体？下面就由小编来给大家介绍一下win11修改系统字体的方法吧，方便快速。
win11修改系统字体的方法
1、首先，在任务栏搜索中，搜索任务面板并打开。
2、打开后，在右上角将类别更改为小图标。
3、然后在面板中找到字体。
4、然后在里面找到自己想要更改的系统字体即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f87f20f5314aadeee38457751f94311/" rel="bookmark">
			【零基础学习YOLO】学习路径资料整理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：博主可有偿辅导入门，需要的可私信
第一阶段：
python基础：
https://www.bilibili.com/video/BV1c4411e77t?from=search&amp;seid=14969610454588791599&amp;spm_id_from=333.337.0.0
要求：跟随视频一起动手敲代码，一定要动手！！
深度学习基础：
https://www.bilibili.com/video/BV1J54y187f9?spm_id_from=333.999.0.0
系列课程的0-30节内容，其中0,1,3,17可以不用看
要求：理论内容，代码部分可以跳过。理论部分需要掌握深度拿捏不准的，可以问我
3）pytorch基础
https://www.bilibili.com/video/BV1hE411t7RN?from=search&amp;seid=1218562196352595306&amp;spm_id_from=333.337.0.0
注意 2）3）可同步进行，因为2我们并不涉及代码，导致有些操作如卷积，并不清楚如何用代码实现，这是们要寻找3）中的视频对应的小节去学习如何用代码实现相应的操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a063ede9e9066fd17a5e5e7d0c8416/" rel="bookmark">
			vue3 ts import时报错An import path cannot end with a ‘.ts‘ extension
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		typeScript导入时是不需要加入扩展名.ts的,考虑到需要编译出可以用于 &lt;script type="module" ...&gt; 的 JS，所以允许加 .js 扩展名
因此直接把.ts的后缀去掉就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc2cdebaa973c88659b057d4c0e0ca8/" rel="bookmark">
			CSS 中的 :root
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:root { --blue: #007bff; --indigo: #6610f2; --purple: #6f42c1; --pink: #e83e8c; --red: #dc3545; --orange: #fd7e14; --yellow: #ffc107; --green: #28a745; --teal: #20c997; --cyan: #17a2b8; --white: #fff; --gray: #6c757d; --gray-dark: #343a40; --primary: #007bff; --secondary: #6c757d; --success: #28a745; --info: #17a2b8; --warning: #ffc107; --danger: #dc3545; --light: #f8f9fa; --dark: #343a40; --breakpoint-xs: 0; --breakpoint-sm: 576px; --breakpoint-md: 768px; --breakpoint-lg: 992px; --breakpoint-xl: 1200px; --breakpoint-xxl: 1600px; --font-family-sans-serif: -apple-system, BlinkMacSystemFont; --font-family-monospace: SFMono-Regular, Menlo, Monaco, Consolas; } :root :root是一个伪类，表示文档根元素，所有主流浏览器均支持 :root 选择器，除了 IE8 及更早的版本。在:root中声明相当于全局属性，只要当前页面引用了:root segment所在文件，都可以使用var()来引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc2cdebaa973c88659b057d4c0e0ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/accb980d330788f9ac7fd9062ef35786/" rel="bookmark">
			选项卡 js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; * { margin: 0; padding: 0; } .header { display: flex; height: 50px; width: 600px; } .header li { text-align: center; line-height: 50px; list-style: none; border: 1px solid red; flex: 1; } .body { height: 300px; width: 600px; position: relative; } .body li { list-style: none; background-color: aquamarine; position: absolute; top: 0; left: 0; height: 300px; width: 600px; display: none; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/accb980d330788f9ac7fd9062ef35786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f5fc7d1a65eca9a210e678ca5b0b2c/" rel="bookmark">
			求质数 js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;script&gt; var a = 57; var flag = true; for (var i = 2; i &lt; a; i++) { if (a % i == 0) { flag = false; break; } } if (flag) { console.log(a + '是质数'); } else { console.log(a + '不是质数'); } &lt;/script&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/104/">«</a>
	<span class="pagination__item pagination__item--current">105/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/106/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>