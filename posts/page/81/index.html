<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/400a080ea402939e843dcf967e608a8e/" rel="bookmark">
			Android APP启动优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用启动的类型 冷启动
从点击应用图标到UI界面完全显示且用户可操作的全部过程。
启动流程
Application 阶段、handle message 间隙、Activity 阶段和数据加载间隙，全路径各部分细分涵盖的内容如下图所示：
APP 进程由 zygote 进程 fork 出来后会执行 ActivityThread 的 main 方法，该方法最终触发执行bindApplication，这也是 Application 阶段的起点；然后是我们在应用中能触达到的attachBaseContext阶段，4.x 的机型在该阶段具有较长的 MultiDex 耗时可以做针对性优化（可参考“抖音 BoostMultiDex 优化实践”），本阶段也是最早的预加载时机；接下来是installProvider阶段，很多三方 sdk 借助该时机来做初始化操作，很可能导致启动耗时的不可控情形，需要按具体 case 优化；此后就到了 Application 的onCreate阶段，这里有很多三方库和业务的初始化操作，是通过异步、按需、预加载等手段做优化的主要时机，它也是 Application 阶段的末尾。
在Application 阶段和 Activity 阶段之间往往会不可避免地被插入很多 post 到主线程的消息及相应待执行任务，这是拉长启动耗时的另一不可控问题点，需要加以监控治理或通过消息调度优化来尽量减小此间隙。
在来到 Activity 阶段后，首先经历的是其onCreate生命周期，这里涵盖了首屏业务优化的主要场景也是开启异步并发的主要时机，在其中有个重要的 setContentView 方法会触发 DecorView 的 install，可尝试对 DecorView 的构建进行预加载；后续自然来到View 构建的阶段，该阶段在抖音上相当耗时，可采用异步 Inflate 配合 X2C（编译期将 xml 布局转代码）并提升相应异步线程优先级的方法综合优化；再来到View 的整体渲染阶段，涵盖 measure、layout、draw 三部分，这里可尝试从层级、布局、渲染上取得优化收益。
最后是首屏数据加载阶段，这部分涵盖非常多数据相关的操作，也需要综合性优化，可尝试预加载、缓存或网络优先级调度等手段。
此外，针对全路径所有阶段还可以实施通用性的优化项，如：启动任务调度框架、类重排、IO 预加载、全局通用性框架优化等。
启动耗时成因分析
启动耗时成因分析：所有的耗时均因代码运行时不合理地消耗系统资源产生，而不合理的耗时点正是需要做归因分析之处。抖音按照不合理耗时点消耗的主要系统资源类型划分出五大成因，分别是：CPU Time、CPU Schedule、IO Wait、Lock Wait 和 IPC，下面分别对各成因进行剖析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/400a080ea402939e843dcf967e608a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5363f16f55b8147d01389d10f64a2d40/" rel="bookmark">
			软件工程 毕业设计题目汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序 校园表白墙微信小程序 房屋租赁管理系统 航空售票管理系统高校会议室管理系统高校就业管理系统失物招领系统图书销售系统微信小程序 商城系统 微信小程序 资料分享系统 微信小程序 校园点歌系统校园资料分享系统电影网站系统 人事管理系统视频教学网站网上花店系统在线考试系统 个人博客网站班级作业管理系统 crm客户关系管理系统课程评价系统 学生管理系统工程财务管理辅助系统【校园】新闻网站系统停车位管理系统基于协同过滤算法课程推荐系统基于协同过滤算法和KNN 图书馆借阅推荐系统大学生健康管理系统 在线答题微信小程序选课微信小程序仓库管理系统医药管理系统校园招聘信息管理系统校园论坛系统二维码门禁管理系统酒店后台管理系统校园二手交易网大学生宿舍管理系统奖学金申请系统企业进销存系统校园报修平台防疫登记系统实验室预约系统校园点歌 推荐系统校园报修微信小程序客户关系管理系统 0001汽车租赁系统 0002 Java 基于协同过滤实现插画交流平台中的插画信息推荐功能
0003
Java 基于协同过滤算法实现宠物商城系统
校园报修微信小程序 Java校园报修系统
校园作业发布微信小程序 校园作业发布助手微信小程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ecc101c90f5a4896d3a3a8a44e51ed7/" rel="bookmark">
			APP启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Launcher 调用startActivity Launcher 向AMS请求创建根Activity
调用startActivitySafely，里面调用Instrumentation的execStartActivity方法,最终通过ASM的代理类调用AMS的startActivity。
2. AMS 向Zygote请求创建进程 AMS判断根Activity是否存在并启动，不存在就会向Zygote进程请求创建应用程序进程
3. Zygote fork 进程 创建应用程序进程通过动态代理的方式去调用ActivityThread.main()
4. ActivityThread main() Zygote进程里通过动态代理的方式去调用
4.1启动主Looper
Looper.prepareMainLooper();
4.2. ActivityThread attach:
获取ActivityManagerService的代理对象IActivityManager通过代理对象调用attachApplication()，获取启动application所需信息(应用进程相关数据)执行Application的attach方法,里面执行attachBaseContext绑定Context 4.3. installContentProviders
启动ContentProviders
4.4. Application onCreate
Application创建完毕ActivityThread 进入loop循环 5. ActivityThread main()执行完毕后通知AMS启动完成 Launcher启动的时候需要启动的信息保存为一个ActivityRecord，main执行完后AMS通过ActivityRecord找到需要启动的根Activity，启动根Activity。
6. AMS与ApplicationThread交互 ApplicationThread是应用程序与ASM所在进程的通信桥梁,AMS最终调用ApplicationThread的scheduleLaunchActivity方法；
然后调用H(H是ActivityThread的内部类，继承自Handler)的handleLaunchActivity；然后调用performLaunchActivity()。
ApplicationThread.scheduleLaunchActivity() → H.handleLaunchActivity() → ActivityThread.performLaunchActivity()
7. ActivityThread.performLaunchActivity() (1)创建ContextImpl
ContextImpl appContext = createBaseContextForActivity()
(2)用类加载器加载Activity实例
(3)初始化Activity
执行Activity.attach()方法
创建PhoneWindow(mWindow = new PhoneWindow())关联WindowManager(mWindow.setWindowManager()) (4)调用Instrumentation.callActivityOnCreate()方法启动Activity
里面会调用Activity的onCreate()方法 (5)onCreate() → setContentView()
初始化DecorView(继承自FrameLayout)通过LayoutInflater.inflate把布局文件解析后塞到DecorView中 8. 至此create流程结束，回到ActivityRecord开始resume流程 onStart是在resume流程里调用的Activity.performResume()→performRestart()→performStart()执行handleResumeActivity() 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ecc101c90f5a4896d3a3a8a44e51ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6fe609fa2ce265770102e035eec8fec/" rel="bookmark">
			Vue - vxe-table 表格合并行应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue - vxe-table 表格合并行应用 一. 将相同的列数据合并为一行实现效果实现方法 二. 拓展合并：根据某个字段合并后的数据 进行合并其他字段列实现效果实现方法 vxe-table 地址：https://vxetable.cn/v2/#/table/start/install
一. 将相同的列数据合并为一行 实现效果 实现方法 使用 API 中的 span-method 方法：
span-method 使用方法&lt;vxe-grid border resizable align="center" :columns="tableColumn" :data="tableData" :span-method="rowspanMethod" &gt; &lt;/vxe-grid&gt; // 将相同的列数据合并为一行 rowspanMethod({ row, _rowIndex, column, visibleData }) { // 需要合并的列字段 let fields = []; const cellValue = row[column.property]; if (cellValue &amp;&amp; fields.includes(column.property)) { const prevRow = visibleData[_rowIndex - 1]; let nextRow = visibleData[_rowIndex + 1]; if (prevRow &amp;&amp; prevRow[column.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6fe609fa2ce265770102e035eec8fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596a2a4f347179edd3cb6c592adb2b1f/" rel="bookmark">
			vue3中pinia的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.pinia基本使用 1.首先先安装依赖
1
npm install pinia
2.在main.js中引入pinia并创建容器挂载到根实例上
1
2
3
4
//引入stores暴露出的pinia的实例
import pinia from './stores'
createApp(App).use(pinia).mount('#app')
3.创建stores文件夹和index.js文件（这个文件以后基本不用管了）
1
2
3
import { createPinia } from "pinia";
const pinia = createPinia()
export default pinia
4.在stores文件夹下创建counter.js文件。这个文件就是存有关counter相关的数据。（类似vuex的模块化）
defineStore 是需要传参数的，
第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间.第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
//定义关于counter的store
import {defineStore} from 'pinia'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/596a2a4f347179edd3cb6c592adb2b1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4c3049443318fa16bd173435bae6f4/" rel="bookmark">
			PCL可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可视化（Visualization）是利用计算机图形学和图像处理技术、将数据转换为图形或者图像在屏幕上显示出来，并进行交互处理的理论、方法和技术。它涉及计算机图形学、图像处理、计算机视觉、计算机复制设计等多个领域、成为研究数据表示、数据处理、决策分析等一系列问题的综合技术。
可视化深度图像的两种方法：一种是在3D视窗中以点云形式进行可视化（深度图像来源于点云）；另一种是将深度值映射为颜色，从而以彩色图像方式可视化深度图像。
PCLVisualizer可视化类具有全面的功能，如显示发现、绘制多种形状和多个视口。
查看复杂的点云经常会让用户没有方向感，为了让用户保持正确的坐标判断，需要显示坐标系统方向，可以通过使用X,Y,Z圆柱体代表坐标轴的显示方式来解决，圆柱体的大小通过scale参数控制。
显示法线是理解点云的一个重要步骤，点云法线特征是非常重要的基础特征.
pcl可以和qt结合进行展现，具体后面学会了，会专门写个帖子
1）下采样 Downsampling
一般下采样是通过构造一个三维体素栅格，然后在每个体素内用体素内的所有点的重心近似显示体素中的其他点，这样体素内所有点就用一个重心点来表示，进行下采样的来达到滤波的效果，这样就大大的减少了数据量，特别是在配准，曲面重建等工作之前作为预处理，可以很好的提高程序的运行速度
（2）上采样 ：上采样是一种表面重建方法，当你有比你想象的要少的点云数据时，增采样可以帮你恢复原有的表面（S），通过内插你目前拥有的点云数据，这是一个复杂的猜想假设的过程。所以构建的结果不会百分之一百准确，但有时它是一种可选择的方案。所以，在你的点云云进行下采样时，一定要保存一份原始数据！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19bce3f4fe69557202dc41c166550e0b/" rel="bookmark">
			ubuntu中pycharm配置cv2，解决cv2无法找到对应的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开pycharm终端输入以下指令
pip install opencv-python --user -i https://pypi.tuna.tsinghua.edu.cn/simple
这是我的opencv-python的安转位置
opencv-python in /home/zj/.local/lib/python3.8/site-packages (4.7.0.72)
2、打开opencv-python安装的位置，找到cv2安装包
3、复制cv2中的cv2.abi3.so文件，复制到site-packages路径下，并将其名称改为cv2.so，即可在pycharm中找到cv2的相应函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daff07a616e0dc68d7ac973c63baa626/" rel="bookmark">
			LaTex常用数学符号大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，小写希腊字母 字母实现字母实现字母实现字母实现 α \alpha α\alpha β \beta β\beta γ \gamma γ\gamma δ \delta δ\delta ϵ \epsilon ϵ\epsilon ζ \zeta ζ\zeta η \eta η\eta θ \theta θ\theta ι \iota ι\iota κ \kappa κ\kappa λ \lambda λ\lambda μ \mu μ\mu ν \nu ν\nu ξ \xi ξ\xi π \pi π\pi ρ \rho ρ\rho σ \sigma σ\sigma τ \tau τ\tau υ \upsilon υ\upsilon ϕ \phi ϕ\phi χ \chi χ\chi ψ \psi ψ\psi ω \omega ω\omega ο \omicron ο\omicron ε \varepsilon ε\varepsilon ϑ \vartheta ϑ\vartheta ϰ \varkappa ϰ\varkappa ϖ \varpi ϖ\varpi ϱ \varrho ϱ\varrho ς \varsigma ς\varsigma φ \varphi φ\varphi ϝ \digamma ϝ\digamma 注：\omicron与数学环境下的英文字母o很像，可混用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daff07a616e0dc68d7ac973c63baa626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2071f5c39d81ee89a7e04c652cf7019b/" rel="bookmark">
			vue3引入cdn使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景:引入cdn直接调用提示undefined
原因:因为你没有在vue.confing注册，然后重新运行项目
正确做法：
1.
如果是vue.config.js的项目就在public/index.html 里面的body里面引入cdn
如果是vite.config.ts/js的项目就在项目的最外层的index.html里面引入cdn
&lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key=你自己申请的key"&gt;&lt;/script&gt; 2.
方法一：在vue.config.js里面配置cdn
module.exports = { configureWebpack: { externals: { AMap: 'AMap' } } } 方法二：如果是vite.config.js 里面,需要安装插件
npm i -D vite-plugin-resolve-externals import resolveExternalsPlugin from 'vite-plugin-resolve-externals' export default defineConfig({ plugins: [ resolveExternalsPlugin({ Amap: Amp }) ] }) 方法三:如果你想直接使用也可以
直接打印window，先看看window对象有没有挂载AMap,如果有,直接调用
console.log(window) const AMap = window.AMap console.log(AMap) 3.在需要的vue文件里面调用
&lt;section class="map" id="map"&gt;&lt;/section&gt; import AMap from 'AMap' import { reactive } from 'vue' const gaodeAMap = () =&gt; { //创建地图示例 let map = new AMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2071f5c39d81ee89a7e04c652cf7019b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9059895d072ba656eef787a25c3ead9/" rel="bookmark">
			Java实现PDF导出/预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上有很多关于PDF导出的文章，但是个人感觉实现的过于复杂，又是模板又是html的，有的还需要字体模板的支持，本片文章只是实现简单的PDF表格导出，可以实现PDF动态表格导出/预览，这类文章网上很少，就给你们整理一篇吧！
实现思路：本地创建PDF文件 --》打开PDF文件 --〉写入各种数据 --》保存PDF --〉 将PDF输出到页面下载 --》 删除本地PDF文件
第一步：导入相关的依赖，如果原来有依赖记得替换一下哦，免得版本不一致导致其他产生的各种问题。
&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; 第二步：创建所需要的实体类
package com.hyper.pdf; import lombok.Data; /** * 标题名称/内容设置实体类 */ @Data public class ProcessVo { /** * 序号 */ private String index; /** * 审核人 */ private String assignee; /** * 审核人名称 */ private String assigneeName; /** * 审核时间 */ private String verifyTime; /** * 审核结果 */ private String verifyResult; /** * 审核意见 */ private String verifyMessage; } package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9059895d072ba656eef787a25c3ead9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39416af8e0cfd95a449cbee9c5e2936/" rel="bookmark">
			接口返回base64图片，如何在画布中显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 话不多说直接上代码：
html： &lt;canvas id="mycanvas"&gt;&lt;/canvas&gt; js： var canvas = document.getElementById("mycanvas"); var ctx = canvas.getContext("2d"); //创建图片 var image = new Image(); //设置图片地址 image.src = res.data //res.data为接口返回的base64图片 image.onload = function () { //2个参数 图片的xy坐标 // ctx.drawImage(image, 0, 0) //4各参数 图片的起始坐标和宽高 ctx.drawImage(image, 0, 0, 300, 150) //参数 408, 81 切片的起始坐标， 147, 182 切片切掉原图的尺寸， 0, 0,切完之后切片的位置400, 400切完之后 切片的大小 // ctx.drawImage(image, 900, 100, 0, 0, 0, 0, 0, 0) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d06b616d7a63d52f13897fb4c5790a/" rel="bookmark">
			html 表格单元格的宽度和高度如何设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做网页的时候，经常会碰到表格宽度对不齐的问题。详细地看了html中表格标签table的高度和宽度设置的细节，现总结如下：
1、table中的width和height设置及其作用：table中设置的height其实是设置个最小值，也就是当表格中的内容或者行高总值超过这个设置值时，会自动延长表格的height值，当表格中的内容或者行高没有达到这个值时，会自动扩大到这个值。table中设置的width值一般为表格宽度的最大值，不能改变，即使内部的内容宽度超过也不能改变。（这个内部内容如果是图片的话是可以改变表格宽度的。）
2、tr标签中width和height设置及其作用：tr标签里面的width设置不起任何作用，因为从第一点可以看出，表格的width是不能改变的，tr标签当然就不起作用了。所以在tr中只有讨论height设置的可能了，tr中的height设置和几个tr之间的设置有关。当几个tr都设置了height的具体数值时，各个tr的height按照设置的值的比例来分配总的height值，注意这里说的是总的height值。当几个tr都没有设置height具体值时，平均分配总的height值。当有的tr设置了具体的数值，有的没有设置具体的数值为默认时，先保证各个tr的基本需要，剩下的再满足设置了具体值的tr，之后再全部给没有设置具体值的tr。最后一种情况还要考虑总的宽度不够tr总的设置值的情况，不够的话要满足tr的基本需要，这里会自动延长表格的height的。然后再考虑设置了heightr的tr，最后考虑没有设置height的tr。
3、td标签中width和height设置及其作用：td标签里面的width和height都是起作用的。先看td的width吧，某一个td的width是和所处的一列每个td的width都相关的，取其中最大的width作为这一列中每个td的width，这点是让我们最混淆的地方，一定要从全局把握某个td的width，不能从这一个的width设置就断言它的宽度就是多少，这样是不准确的。当我们把每一列的宽度都弄清楚之后，事情就好办了。这时候各个td之间的宽度分配按照第二条中各 tr的height分配规律，有一点不同的是全部是默认的情况下，各td的width不是平均分配，而是根据各自的实际内容按比例分配。再看看td的height设置吧，这个相对简单一点了，不过各个td的height要看这个td所在的行的最大高度来确定这一行的每个td的height，然后各个行的高度情况和tr中的height分配原则是一样的。还有一点要注意，就是td的height和tr的height之间的关系。首先肯定是根据内容的需 要，在这个基础上，再根据设置的值来确定，哪个设置的值大就按照哪个，如果一个设置了值一个没有设置值，那么按照设置值的算。
1,使用传统的方法
1
2
3
4
5
6
7
8
&lt;table width="400"&gt; &lt;tr&gt; &lt;td width="100"&gt;&lt;/td&gt; &lt;td width="100"&gt;&lt;/td&gt; &lt;td width="100"&gt;&lt;/td&gt; &lt;td width="100"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;table&gt;
2,使用css
1
2
3
4
5
6
7
8
9
10
11
&lt;style&gt;
.td{width:100px;}
&lt;/style&gt;
&lt;table width="400"&gt; &lt;tr&gt; &lt;td class="td"&gt;&lt;/td&gt; &lt;td class="td"&gt;&lt;/td&gt; &lt;td class="td"&gt;&lt;/td&gt; &lt;td class="td"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;table&gt;
以上两种方法可能出现的问题就是,如果内容超过设定,如图片宽度大于100,会自然撑开,自动调节表格宽度
3,用css
1
2
3
4
5
6
7
8
9
10
11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d06b616d7a63d52f13897fb4c5790a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3916f852717d5554551295a6f91916c4/" rel="bookmark">
			css实现登录表单简单交互动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章结构 前言效果图拆解动画细节注意代码实现 前言 虽然现在在努力学习前端，立志成为一名前端工程师，但兴趣爱好很喜欢设计之类的，包括平面设计、画画，我也因此常常追求于美的事物和设计。所以我在学这些的同时也喜欢整这些样式和交互动画，我认为一些适当且有意思的交互设计是可以丰富视觉体验以及满足一部分心理需求。
效果图 今天要讲的是表单里的一个很常见的交互设计，相信大家应该都在很多网站看到过，起初我是在openAI上看到的。觉得很有意思，所以来自己动手实现一下。
拆解动画 总共有3个状态，而变化的只有边框颜色和input框中的文字位置和颜色。
失焦、未填写任何字段时：边框颜色为灰色，文字处于input框内。
聚焦、未填写任何字段时：边框颜色为蓝色，文字处于input框上
失焦、框内有字段时：边框颜色为灰色，文字处于input框上。
细节注意 html部分：我们在布局的时候有两个元素，一个input框和一个label标签的文字，他们是兄弟元素。
注意！！input框中的属性required必须添加上，它是确保这个框内只有在有字段时才算有效（因为我们在css中会用到:valid这个伪类）。
css部分：
对于框内文字需要设置属性pointer-events:none;，作用是屏蔽鼠标事件。
因为不设置这个，在我们点击input框时因为文字在框内，我们点到文字就不能使得input框聚焦。
代码实现 html：
&lt;div class="form-item"&gt; &lt;input type="text" class="text" name="username" required=""&gt; &lt;label class="move" for="username"&gt;phone&lt;/label&gt; &lt;/div&gt; css：
&lt;style&gt; :root { --input-width: 200px; --input-height: 40px; --input-border-radius: 30px; --input-color: #cccec1; --theme-color: #143a64; } .form-item .move { padding: 0 5px; position: absolute; top: 50%; left: 10px; color: var(--input-color); /* 屏蔽鼠标事件 */ pointer-events: none; background-color: #fff; transform: translateY(-55%); transition: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3916f852717d5554551295a6f91916c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bbfcb19b8adc260a99fe545d280e054/" rel="bookmark">
			Vue - 组件重新渲染的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue - 组件重新渲染的两种方式 一. 组件上进行 key 值更改二. v-if 指令 一. 组件上进行 key 值更改 最简单，推荐使用
Vue是通过diffing算法比较虚拟DOM和真实DOM，来判断新旧 DOM 的变化。key是虚拟DOM对象的标识，在更新显示时key表示着DOM的唯一性。DOM是否变化的核心是通过判断新旧DOM的key值是否变化，如果key发生改变，则重新渲染该DOM，如果key没变，则不会重新DOM。 如果想让组件重新渲染，只需要给组件加上key属性，然后在需要重新渲染的时候，将组件绑定的key值更改就可以。
父组件：
&lt;template&gt; &lt;div class="home"&gt; &lt;h2&gt;父组件&lt;/h2&gt; &lt;button @click="rerender"&gt;改变组件绑定的key值，重新渲染组件&lt;/button&gt; &lt;div class="item" v-for="(item, index) of 3" :key="index"&gt; &lt;child :id="item" :key="key"&gt;&lt;/child&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Child from "./child.vue"; export default { components: { Child }, data() { return { key: Date.now() }; }, methods: { rerender() { this.key = Date.now(); } } }; &lt;/script&gt; &lt;style scoped&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bbfcb19b8adc260a99fe545d280e054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe2d5fb9c2a7ff9213f3e8c20242a14/" rel="bookmark">
			获取近一天/近三天/近一周/近一个月/本日/本周/本月/本年的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、近一天 let time = new Date().getTime() let endTime = time - 1 * 24 * 3600 * 1000 this.startTime = this.$dayjs(endTime).format('YYYY-MM-DD 00:00:00') this.endTime = this.$dayjs(time).format('YYYY-MM-DD 23:59:59') console.log(this.startTime) // 开始时间 console.log(this.endTime) // 结束时间 2、近三天
let time = new Date().getTime() let endTime = time - 3 * 24 * 3600 * 1000 this.startTime = this.$dayjs(endTime).format('YYYY-MM-DD 00:00:00') this.endTime = this.$dayjs(time).format('YYYY-MM-DD 23:59:59') console.log(this.startTime) // 开始时间 console.log(this.endTime) // 结束时间 3、近一周
// 方法1 let time = new Date().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe2d5fb9c2a7ff9213f3e8c20242a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac066abb2d03ef6ec94634d1d2fbf977/" rel="bookmark">
			Vue入门学习笔记（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一、安装工具二、前置设置2.1 淘宝加速2.2、华为云加速 三、安装vue工具3.1 安装vue/cli3.2 安装vite 四、创建项目4.1 使用vue/cli创建4.2 使用vite创建 一、安装工具 首先须安装以下工具：
vscode（如果下载慢的话建议使用360安装，或者迅雷下载）node.js（推荐最新版，自带npm）（如果下载慢的话建议迅雷下载）git（推荐安装，如果下载慢的话建议迅雷下载） 二、前置设置 后续命令会大量使用npm，但是npm节点在国外，所以下载可能有问题，所以最好设置一下国内加速。一般加速节点可用：
2.1 淘宝加速 npm config set registry https://registry.npm.taobao.org 验证命令
npm config get registry 如果返回https://registry.npm.taobao.org，说明镜像配置成功。
2.2、华为云加速 npm config set registry https://mirrors.huaweicloud.com/repository/npm/ 验证命令
npm config get registry 如果返回https://mirrors.huaweicloud.com/repository/npm/，说明镜像配置成功。
三、安装vue工具 创建vue项目，可使用的工具有vue/cli或者vite。两者的区别就是前者可创建vue2项目，且可以自定义初始化组件，但编译启动较慢。后者作为vue3的专属工具，效率高，不需要设置很多不懂的参数。
下列安装类型均是全局安装，方便快捷，新手建议！！
安装方法非常简单，使用cmd、powershell、或者win11的终端都可以。
3.1 安装vue/cli npm install -g @vue/cli 3.2 安装vite npm install vite -g 四、创建项目 首先，创建一个根目录，最好全英文。例如：
D:\OpenCode\VueStudent 然后用vscode打开
然后在菜单-&gt;终端-&gt;新建终端
4.1 使用vue/cli创建 vue create vue-demo 4.2 使用vite创建 npm init vite-app vue-demo 以上vue-demo是项目名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31eed46ecb370365d9b247900d8e2d1b/" rel="bookmark">
			Centos 7 自定义路径安装 mysql - rpm包自定义路径安装mysql - 测试记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 就目前而言，笔者觉得rpm包是挺方便的，不过如果想要自定义安装路径，说实话，笔者都不知道怎么改，看网上的都是 tar 包安装，然后更改各种路径，就可以的样子。
rpm 包是笔者的测试过程记录，bug多
rpm包 自定义Mysql安装路径 这里就不介绍安装 rpm 包安装 mysql 的方法，自行查看如下rpm包安装mysql 教程链接：
Centos + Django + Nginx + uwsgi 部署项目-rpm包安装 Mysql 5.x 服务器-删除 Mysql 服务器-自定义安装mysql-utf8编码问题（3）
这里第一次安装mysql容易出现报错：
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using passwor 解决方法如下：
1. 修改mysql的初始密码（有两种方法） 1.1 第 1 种方法 （不推荐，无聊时弄出来的） MySQL第一次启动后会创建超级管理员账号 root@localhost，初始密码存储在日志文件中：/var/log/mysqld.log
查看 Mysql 服务器初始密码的命令如下：
grep 'temporary password' /var/log/mysqld.log 通常而言，界面显示的 A temporary password is generated for root@localhost: 后面就是 Mysql 服务器的初始密码
[root@localhost ~]# mysql -uroot -p
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31eed46ecb370365d9b247900d8e2d1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642276edf355df04227c546987890092/" rel="bookmark">
			SpringBoot整合MyBatis-Plus实现增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 MyBatis-Plus (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。
特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 SpringBoot整合MyBatis-Plus 引入maven依赖
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; yml配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/642276edf355df04227c546987890092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae709c346d31d33ac8b35e1d2842a8e7/" rel="bookmark">
			遗传算法超详细图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法（Genetic Algorithm）顾名思义，是一种基于自然选择原理和自然遗传机制的启发式搜索算法。该算法通过模拟自然界中生物遗传进化的自然机制（选择、交叉和变异操作），将好的遗传基因（最优目标）不断遗传给子代，使得后代产生最优解的概率增加（后代还是会有一些差的结果）。它的整个算法流程如下：
首先根据具体问题确定可行解域和编码方式，用数值串或字符串的形式表示可行解域中的每一个可行解；构建适应度函数度量每一解，该函数为非负函数；确定种群的大小、选择、交叉和变异的方式、交叉和变异的概率，判断终止条件（可以是某一阈值或者是指定进化的代数）。 在这个过程当中，交叉操作是优化的主要操作，而变异操作可以看成对种群的扰动。根据具体的问题我们构建适应度函数，并优化极值（可以是求最大值，也可以求最小值）。
名词解析 生物遗传概念在遗传算法中的对应关系如下：
生物遗传概念遗传算法中的作用适者生存算法停止时，最优目标值的解大概率被找到个体每个可行解染色体对每个可行解的编码基因可行解中的每个组成部分适应性适应度函数的函数值种群可行解域，根据适应度函数选择的一组解选择保留适应度函数的函数值优的解交叉将两个可行解内的组分随机交叉，产生新解变异随机变异可行解中的某些组分 算法步骤 我们还是以一个简单的例子来讲解整个算法的流程。比如，我们需要寻找函数y=x12+x22+x33+x44在[1,30]之间的最大值。我们很容易就知道，当x1=x2=x3=x4=30时，该函数能取到最大值。
首先我们构建一个叫Gene的类：
1
2
3
4
class Gene:
def __init__(self, **data):
self.__dict__.update(data)
self.size = len(data['data']) # length of gene
这个类只有一个初始化方法，该方法就是获得基因里面的内容和大小，在这个例子中，内容就是[1,30]之间的任意4个数字组成的列表。
接着构建一个叫GA的类，这个类包括算法的所有操作方法：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
class GA:
def __init__(self, parameter):
pass
def evaluate(self, geneinfo):
pass
def selectBest(self, pop):
pass
def selection(self, individuals, k):
pass
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae709c346d31d33ac8b35e1d2842a8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a7474490d14e1dee9a7e2f9a3b278c/" rel="bookmark">
			Docker相关命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器相关命令
镜像：Docker镜像是由文件系统叠加而成（是一种文件的存储形式）；是docker中的核心概念，可以认为镜像就是对某些运行环境或者软件打的包，用户可以从docker仓库中下载基础镜像到本地，比如开发人员可以从docker仓库拉取（下载）一个只包含centos7系统的基础镜像，然后在这个镜像中安装jdk、mysql、Tomcat和自己开发的应用，最后将这些环境打成一个新的镜像。开发人员将这个新的镜像提交给测试人员进行测试，测试人员只需要在测试环境下运行这个镜像就可以了，这样就可以保证开发人员的环境和测试人员的环境完全一致。
查看本地镜像
# 查看镜像可以使用如下命令： docker images REPOSITORY：镜像名称
TAG：镜像标签
IMAGE ID：镜像ID
CREATED：镜像的创建日期
SIZE：镜像大小
搜索镜像
# 如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 docker search 镜像名称 NAME：镜像名称
DESCRIPTION：镜像描述
STARS：用户评价，反应一个镜像的受欢迎程度
OFFICIAL：是否官方
AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的
拉取镜像
# 拉取镜像就是从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本 命令如下： d docker pull 镜像名称 # 如拉取centos 7； docker pull centos:7 删除镜像
# 可以按照镜像id删除镜像，命令如下： docker rmi 镜像id 1、 docker rmi $IMAGE_ID：删除指定镜像
2、 docker rmi docker images -q：删除所有镜像
容器相关命令 容器，也是docker中的核心概念，容器是由镜像运行产生的运行实例。镜像和容器的关系，就如同Java语言中类和对象的关系。
1、查看容器
查看正在运行的容器使用命令： docker ps 查看所有容器使用命令： docker ps -a 2、创建并启动容器
可以基于已有的镜像来创建和启动容器，创建与启动容器使用命令：docker run
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87a7474490d14e1dee9a7e2f9a3b278c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac1d0ba9f4184232b2728b308a4b8ad/" rel="bookmark">
			javascript-基础知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
（一）基础语法
1、javaScript引入方式
2、变量与常量
3、数据类型
typeof操作符
4、运算符
5、输出函数
6、类型转化
7、转移字符
8、注释
（二）流程控制
1、选择结构
switch
2、循环结构
for
（三）函数
1、函数的定义
2、函数的调用
（四）字符串操作
（五）数组操作
（六）时间对象:Date
1、实例化对象
2、操作年、月、日
3、 操作时、分、秒
4、获取星期
（七）数学对象
1、Math对象的属性:
2、Math对象的方法
（一）基础语法 1、javaScript引入方式 JavaScript的3种引入方式：
外部JavaScript内部JavaScript元素事件JavaScript 外部JavaScript：指的是把HTML代码和JavaScript代码单独放在不同的文件中，然后在HTML文档中使用“script标签”来引入JavaScript代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!--1.在head中引入--&gt; &lt;script src=”index.js”&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--2.在body中引入--&gt; &lt;script src="index.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 内部JavaScript：指的是把HTML代码和JavaScript代码放在同一个文件中。其中，JavaScript代码写在&lt;script&gt;&lt;/script&gt;标签对内
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!--1.在head中引入--&gt; &lt;script&gt; …… &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--2.在body中引入--&gt; &lt;script&gt; …… &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 元素事件JavaScript：指的是在元素的“事件属性”中直接编写JavaScript或调用函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac1d0ba9f4184232b2728b308a4b8ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2cd2151e55b4faa792d68d8e02d9917/" rel="bookmark">
			SpringBoot实操篇1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、工程打包与运行（windows版） 在浏览器中就可以访问到了，此时IDEA并没有启动。服务器就是命令行窗口。
跳过测试：可以看到多了很多数据，是因打包的时候将功能测试了一遍。在IDEA中可以关掉。
注意：必须要有打包插件（插件作用：打一个可以独立运行的jar包）
二、Boot工程快速启动（Lunix版） 前提：
mysql安装在/root下，由root用户启动
tomcat安装在/root下，由普通用户tomcat启动
将打包好的文件上传到Linux中：
输入指令启动就OK：
三、配置高级 1.设置临时属性 如果要设置临时属性：命令行设置的临时属性高于配置文件。
要设置多个临时属性，用空格分开：
2.如何在开发环境中设置临时属性 配置方式1：
是传到args中的
方式二：上面看到是传入args中，我们就可以直接在代码中设置
为了安全，也可以不要这个参数，外部人员就在命令行改不了了，之能用配置文件的。
3.配置文件4级分类 在IDEA中提供两个级别的配置文件，一个是程序员使用的，一个是做程序总控的。
这两个文件合作配置。高级别的配置文件覆盖低级别的配置文件。
在打包好的目录里还有两个配置文件。
总结：SpringBoot中4级配置文件
1级：file：config/application.yml 最高
2级：file：application.yml
3级：classpath：config/appliction.yml
4级：classpath：application.yml 最低
作用：
1级和2级留作系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控。
3级和4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控。
4.自定义配置文件 1.通过启动参数加载配置文件（无序书写配置文件扩展名）
2.通过启动参数加载指定文件路径下的配置文件时可以加载多个配置
后面的配置文件生效了。
重要说明：
单服务器项目：使用自定义配置文件需求较低
多服务器项目：使用自定义配置文件需求较高，将所有配置放置在一个目录中，统一管理
基于SpringCloud技术，所有的服务器将不再设置配置文件，而是通过配置中心进行设定，动态加载配置信息
四、多环境开发 1.yml版本 多环境开发需要设置若干常用环境，例如开发、生产、测试环境
yaml格式中设置多环境使用—区分环境设置边界
每种环境的区别在于加载的配置属性不同
启用某种环境时需要指定启动时使用该环境
#应用环境 #公共配置 spring: profiles: active: pro --- #设置环境 #生产环境 spring: config: activate: on-profile: pro server: port: 80 --- #开发环境 spring: config: activate: on-profile: dex server: port: 81 --- #测试环境 spring: config: activate: on-profile: test server: port: 82 会有暴露配置的问题？把配置文件分开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2cd2151e55b4faa792d68d8e02d9917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2adc20133e2d40ae1e26afd668fdfe89/" rel="bookmark">
			Java Spring boot 使用SSH连接Mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入JSch和MySQL驱动程序的依赖。 &lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.55&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;{your version}&lt;/version&gt; &lt;/dependency&gt; 创建SSH连接和MySQL连接的配置类。 import com.jcraft.jsch.JSch; import com.jcraft.jsch.JSchException; import com.jcraft.jsch.Session; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; @Configuration public class MysqlSSHConfig { @Value("${ssh.host}") private String sshHost; @Value("${ssh.port}") private int sshPort; @Value("${ssh.user}") private String sshUser; @Value("${ssh.password}") private String sshPassword; @Value("${mysql.host}") private String mysqlHost; @Value("${mysql.port}") private int mysqlPort; @Value("${mysql.user}") private String mysqlUser; @Value("${mysql.password}") private String mysqlPassword; @Value("${mysql.database}") private String mysqlDatabase; @Bean public Session sshSession() throws JSchException { JSch jsch = new JSch(); Session session = jsch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2adc20133e2d40ae1e26afd668fdfe89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9783e38fef3ec000e760493be090ad2a/" rel="bookmark">
			现在有什么基于vue3.0的优秀开源项目呢?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 以下是一些github上一些基于vue3.0的优秀开源项目，可以自己选择一些去练一下手，废话少说，直接进入正题----
1、 vue-manage-system
Star: 16k
是一个基于 Vue3 和 Element Plus 的后台管理系统解决方案，它提供了一系列的通用组件和基础功能，可以帮助开发者快速搭建后台管理系统。该系统包含了用户管理、权限管理、数据可视化、表单编辑等常见功能，同时也提供了多种主题风格和自定义配置选项，方便开发者根据自己的需求进行定制。 github地址:https://github.com/lin-xin/vue-manage-system
线上地址：https://lin-xin.gitee.io/example/work
2、DataV
Star: 7.7k
一款可视化数据分析工具，是阿里云推出的一款数据可视化产品。它基于阿里云的大数据技术，可以对海量数据进行快速处理和可视化展示，支持多种图表展示方式、多种数据源接入和多维度数据分析。DataV可以帮助用户快速构建交互式的数据可视化应用，帮助企业快速了解业务数据，从而更好地做出决策。同时，DataV还提供了丰富的数据安全和权限控制机制，确保数据的安全性和隐私性 github地址:https://github.com/DataV-Team/DataV
在线地址：http://datav.jiaminghi.com/
3、 vue-vben-admin
Star: 17.3k
Vue Vben Admin 是一个基于 Vue3 和 TypeScript 的开源后台管理系统模板，它包含了众多的组件和插件，可以帮助开发者快速构建出高质量的后台管理系统。Vue Vben Admin 具有极高的可扩展性和灵活性，可以轻松地满足不同的业务需求。它还提供了丰富的文档和示例代码，使得开发者可以快速上手并进行开发 github地址:https://github.com/vbenjs/vue-vben-admin
在线地址：https://vben.vvbin.cn/#/login?redirect=/dashboard
4、newbee-mall-vue3-app
Star: 4.9k
是一个基于 Vue 3 和 TypeScript 的电商前端项目，它是 newbee-mall 项目的升级版。该项目包含了商品列表、商品详情、购物车、订单结算等功能，同时还使用了 Element Plus UI 组件库和 Axios 库等 github地址:https://github.com/newbee-ltd/newbee-mall-vue3-app
在线地址：http://47.99.134.126:5008
5、PPTist
Star: 4.1k
是一个基于 Vue3.x + TypeScript 的在线演示文稿（幻灯片）应用，还原了大部分 Office PowerPoint 常用功能，支持 文字、图片、形状、线条、图表、表格、视频、音频、公式 几种最常用的元素类型，每一种元素都拥有高度可编辑能力，同时支持丰富的快捷键和右键菜单，支持导出本地 PPTX 文件，支持移动端基础编辑和预览，支持 PWA github地址:https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9783e38fef3ec000e760493be090ad2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b555372984d19a1c0b15002d69e4e437/" rel="bookmark">
			learn C&#43;&#43; NO.4 ——类和对象（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.类的6个默认成员函数 1.1.默认成员函数的概念 在 C++ 中，如果没有显式定义类的构造函数、析构函数、拷贝构造函数和赋值运算符重载函数，编译器会自动生成这些函数，这些函数被称为默认成员函数。
class Date { }; 初步了解了默认成员函数，上面的空类Date，其实在程序运行时，编译器会默认生成它的默认成员函数。
小结 当没有显示实现默认成员函数时，编译器会自动生成默认成员函数。
2.构造函数 2.1.构造函数的概念 构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，以保证每个数据成 员都有 一个合适的初始值，并且在对象整个生命周期内只调用一次。
2.2.为什么类需要构造函数呢？ 我们以日期类举例，如果不用构造函数来初始化一个对象会是怎么样的呢？
class Date { public: void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1; d1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b555372984d19a1c0b15002d69e4e437/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18fc7d4956c92d07ef028f2c40691ad4/" rel="bookmark">
			【MySQL】浅谈事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，大家好~我是你们的老朋友：保护小周ღ 谈起 “事务”，可能大家都会在心中出现一个大大的 ？，博主的理解——事务就是解决 MySql数据库在应对多线程环境下针对同一存储空间的数据修改引起的数据安全问题的一种机制，本质是将多个 sql 语句打包一个整体，要么全部执行成功，要么都不执行，当出现 sql 语句执行到中间的时候 “服务”，从而造成数据安全问题。
本期收录于博主的专栏：JavaEE_保护小周ღ的博客-CSDN博客
适用于编程初学者，感兴趣的朋友们可以订阅，查看其它 “JavaEE基础知识”。
更多精彩敬请期待：保护小周ღ *★,°*:.☆(￣▽￣)/$:*.°★* ‘
一、事务 MySql 本质是客户端、服务器交互的一种机制，双方建立连接后，客户端，通过用 sql 语句，向MySql 服务器发出请求，服务器收到并解析请求，然后在硬盘上“拿出”相关数据，作为响应返回客户端，客户端将数据以临时表的形式展现给用户。MySql 使用硬盘作为存储介质。
以上机制，如果多个客户端同时针对服务器存储的数据进行增删查改，有可能造成数据安全问题
举个例子1： ​举个例子2 ：
​
MySql的事务就是为了解决上述问题。 事务的本质就是把多个 sql 语句打包一个整体，要么全部执行成功，要么都不执行，当出现 sql 语句执行到中间的时候 “宕机”，造成数据安全问题，事务会将已修改的数据进行 “回滚”（rollback）,将数据还原成没有执行之前的状态，主观上看起来就像没有执行过。
以及解决多线程（多个执行流）针对同一存储空间的数据进行修改的造成的数据安全问题。
1.1 事务的使用 1. 开启事务： start transaction
2. 执行多条 SQL 语句
3. 回滚事务： rollback / 提交事务：commit rollback 代表全部执行失败 ，commit 代表全部执行成功
start transaction; // 开启事务 update balance set balance = balance - 100 where name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18fc7d4956c92d07ef028f2c40691ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078acec22eeab3accdafbd4649f1de2c/" rel="bookmark">
			Windows系统下的Openface安装及使用--亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置openface所需环境 openface主要依赖于opencv和dlib等工具包，工具包安装可win+r进入用户终端下载安装（需要先下载python），或者下载ananconda，创建anaconda虚拟环境安装：
pip install opencv-python
安装dlib前需要安装CMake和Boost：
pip install CMake
pip install Boost
pip install dlib
二、下载安装openface安装包 1.下载解压安装包，安装包下载地址：
https://codeload.github.com/cmusatyalab/openface/zip/master
2.win+r进入用户终端，然后cd进入在解压缩包后的setup.py所在的文件夹，然后输入：
python setup.py install
然后可以看到，下载的openface解压缩包里面多了一个build文件。
接下来就去检验一下openface是否安装成功,在终端里输入python，进入python环境，然后依次输入：
import cv2
import dlib
import openface
如果没有提示错误，即为安装成功，安装成功后如下图所示：
三、安装Visual Studio 2017，并编译openface二进制文件 1.首先下载VS2017安装（只支持2017），安装过程中一定要勾选c++桌面，windows平台
2.然后安装好后，下载openface二进制文件
openface二进制文件：https://github.com/TadasBaltrusaitis/OpenFace/releases/tag/OpenFace_2.2.0.
下载下面两个之一，不要下错了：
3.用vs2017打开openface安装包文件下的openface.sln文件
4.然后随便找一个可执行文件生成一下，比如FaceLandmarkImg，可能生成不成功不过没关系，他会生成一个x64/release文件夹，这就够了。生成的时候注意切换成release模式，x64.
生成的x64/release文件夹如图所示：
5.然后把二进制文件文件拷到x64/release文件夹下，再重新生成一下各个可执行文件，一共五个都生成一下，图片上是其中一个。
6：下载cen文件
下载链接：
https://pan.baidu.com/s/1gh2xmrxCpL7VLjPmjhgBIg 密码：65jp
然后解压cen文件，其中 .dat文件放到lib\local\LandmarkDetector\model\patch_experts
这个文件夹下 ；.mat文件放到.\matlab_version\models\cen这个文件夹下
7:再都重新生成一下
8：都没有问题的话，然后我们就可以进行测试了
四、测试 在你的x64/release文件下，找到OpenFaceOffline.exe文件，点开他（如果点不开说明安装应该有点问题），点开之后基本上就证明你的模型已经ok了，然后就可以打开图片或者视频进行测试了。
参考文章：Openface的安装和使用_贝嘎贝嘎贝嘎处的博客-CSDN博客_openface
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/028738888bed6d883a05f9159b0cd703/" rel="bookmark">
			URL 转为QR code（二维码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结几种把网页url转为二维码的方法。
1. Chrome浏览器 最快的一种方法就是用chrome自带的QR code分享。
这种方法的缺点就是不能自定义二维码的格式（颜色、logo之类的），都是默认的小恐龙图标。
2. chrome插件 可以在chrome里添加一个插件：
这个插件的好处就是很方便，能够在浏览器里一键生成二维码；而且还能自定义logo和颜色之类的。
缺点就是二维码很丑。。可以自行尝试一下。
3. 网站 推荐一个良心的网站，能够免费地将url、text编码为二维码，而且还能设计logo、颜色等。
https://www.the-qrcode-generator.com/
如下图：
可以自己定义logo、颜色：
还能查看扫描历史等统计信息：
上述所有功能都是免费的！而且扫描无次数上限，二维码永不过期！
这比起很多其他网站简直不要良心太多！
可以参考如下的对比：
Free plan的仅有缺点是：
扫描之后会有3秒广告（不是那种商业广告，而是他们介绍自己的网站，使用起来完全没啥影响）只能下载png，不能下载svg；分辨率有限不能 PDF 2 QR不能自定义域名 如果需要上述的额外功能，开通会员也只需要每月10刀。
但是对于大多数用户来说，free plan的功能也已经强到足够用了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bedfc0b01e2567a22af45c307398c02a/" rel="bookmark">
			java实现发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍下java实现邮件的发送，意在网站用户评论时能够及时通知站长和用户评论被回复后能够及时通知用户。
下文介绍下具体实现。
java实现 首先引入springboot的邮箱依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 配置邮箱参数，这里以qq邮箱作为示例
spring: mail: host: smtp.qq.com #qq邮箱 username: #用户名，填qq邮箱地址。例如xxx@qq.com password: #qq邮箱授权码，网上搜索怎么获得 此时就差不多了，接下来实现邮箱工具类
@Component public class MailUtil { @Value("${spring.mail.username}") private String from; //这是发送人 @Autowired JavaMailSender javaMailSender; public ResponseDto sendMail(String to,String subject,String content){ SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setFrom(from); simpleMailMessage.setTo(to); simpleMailMessage.setSubject(subject); simpleMailMessage.setText(content); javaMailSender.send(simpleMailMessage); return ResponseDto.Ok(); } } 此时调用MailUtil里的sendMail方法就能实现发送邮件了。
实践中发现每次都需要等待邮件发送成功后接口才会返回，不符合我们的实际需求。故需在发送邮件时开辟一个新线程，即可满足我们的需求。
为了减少大规模请求下创建线程的开销，引入线程池来处理发送邮件事件。
线程池 使用**@Configuration注解保证初始化线程池只有一次，使用@Bean注解在程序启动时就注入到IOC容器**内，这样可以保证程序启动后就会初始化线程池。
@Configuration @Slf4j public class ThreadPool { private Integer maxPoolSize = Runtime.getRuntime().availableProcessors()*5; private Integer corePoolSize = 5; @Bean public ExecutorService buildThreadPool() { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bedfc0b01e2567a22af45c307398c02a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22418514a1bb471f625a69f9f987f9fb/" rel="bookmark">
			Ambari-2.7.7源码编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 说明 本文基于Ambari-2.7.7版本进行源码编译。所需的编译资料统一提供如下：
链接：https://pan.baidu.com/s/1F2D7zBGfKihxTBArnOilTw 提取码：8m17 1 前提条件 1.1 下载ambari源码包 wget https://github.com/apache/ambari/releases/tag/release-2.7.7-rc0/ambari-release-2.7.7-rc0.tar.gz wget https://www-eu.apache.org/dist/ambari/ambari-2.7.7/apache-ambari-2.7.7-src.tar.gz wget https://mirrors.tuna.tsinghua.edu.cn/apache/ambari/ambari-2.7.7/apache-ambari-2.7.7-src.tar.gz 选择其中一个下载一个就行，下载完成后解压
tar -zxvf apache-ambari-2.7.7-src.tar.gz chown -R root:root apache-ambari-2.7.7-src 1.2 需要安装软件 java1.8.0_201mavenApache Maven 3.8.6rpm-buildrpm-build-4.11.3-48.el7_9.x86_64gcc-c++4.8.5python2.7.5python-develpython-devel-2.7.5-92.el7_9.x86_64git1.8.3.1nodejsv4.5.0 注：①rpm-build安装
yum install rpm-build -y 查看rpm-build版本
② python-devel安装
yum install python-devel -y 查看安装版本
③ 安装node
wget https://nodejs.org/dist/v4.5.0/node-v4.5.0-linux-x64.tar.gz tar -zxvf node-v4.5.0-linux-x64.tar.gz -C /usr/lib/node 安装完成后确保npm和node命令正常
注：如果执行npm -v时发生如下报错：
Cannot find module ‘npmlog’ 解决办法：
# cd 命令进入nodejs安装目录然后执行如下命令，建立软连接： ln -s ../lib/node_modules/npm/bin/npm-cli.js ④ 将以上安装的jdk/maven/node配置环境变量
#java environment export JAVA_HOME=/usr/local/java export CLASSPATH=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22418514a1bb471f625a69f9f987f9fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0b5ffbfb67454155a557199d087fde/" rel="bookmark">
			【Win&amp;Ubuntu环境下pip换源&#43;超级稳定的pip安装相关工具包的指令】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win&amp;Ubuntu环境下pip换源+超级稳定的pip安装相关工具包的指令 Win环境下pip换源教程 （1）首先依次执行下列代码
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud//pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ conda config --set show_channel_urls yes （2）执行后，再运行下列代码检查是否成功
conda config --show channels （3）在C盘目录中输入
%appdata% 按回车会进入下图类似的文件目录中
（4）在上述目录下，新建pip文件夹，然后进入该文件夹，创建一个pip.ini文件，注意是.ini文件不是txt文件。有同学可能不知道如何在win下创建该文件，看下图，在窗口勾选文件拓展名，然后将文件重命名为pip.ini，即可。
(5)将以下内容复制到pip.ini文件中
[global] timeout = 6000 index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = https://pypi.tuna.tsinghua.edu.cn 再重新pip install 即可。
Ubuntu环境下pip换源教程 操作如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab0b5ffbfb67454155a557199d087fde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65f088559f860d0fc9acf2d0b6bf4da/" rel="bookmark">
			js获取一个月的第一天和最后一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 获取本月第一天
function getStartTime() { let date = new Date() date.setDate(1) // 将当前时间的日期设置成第一天 let year= date.getFullYear() // 得到当前年份 let month = date.getMonth() + 1 // 得到当前月份（0-11月份，+1是当前月份） month = month &gt; 10 ? month :'0' + month // 补零 let day = date.getDate() // 得到当前天数，实际是本月第一天，因为前面setDate(1) 设置过了 // console.log(month) 03 return new Date(year +'-'+ month +'-'+ day) // 这里传入的是字符串 }; getStartTime() [输出结果]
setDate(day) 方法将月份中的某一天设置为日期对象，day 必需是整数，表示月中的某一天。预期值是 1-31，但允许其他值：
0 将导致上个月的最后一天
-1 将导致上个月的最后一天的前一天
如果一个月有 31 天：32 将导致下个月的第一天
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65f088559f860d0fc9acf2d0b6bf4da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10740eb2837c738aaa55cc13e470db82/" rel="bookmark">
			什么是DMA与零拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IO 1. 传统IO CPU 发出对应的指令给磁盘控制器，然后返回；磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断；CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。 2. DMA技术 将IO设备与内存之间的数据传输工作交给DMA控制器，这样 CPU 就可以去处理别的事务。
二、文件传输 1. 传统文件传输 四次用户态/内核态切换 + 四次数据拷贝
2. mmap + write 用 mmap() 替换 read() 系统调用函数。mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样就不需要再从内核拷贝数据到用户缓冲区。四次用户态/内核态切换 + 三次数据拷贝
3. sendfile sendfile接收源端和目的端的文件描述符作为参数，通过一次sendfile系统调用就可以直接在内核态中将内核缓冲区里的数据拷贝到 socket 缓冲区。两次用户态/内核态切换 + 三次数据拷贝
4. 支持SG-DMA的sendfile（零拷贝） 如果网卡支持 SG-DMA 技术，那么在sendfile() 系统调用的过程中网卡的 SG-DMA 控制器可以直接将数据从PageCache拷贝到网卡，不需要CPU在内存中进行数据拷贝，因此称为零拷贝。两次用户态/内核态切换 + 两次数据拷贝
5. 大文件传输 （异步 + 直接IO） 大文件传输如果采用零拷贝，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：
PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次； 因此在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术。绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。它把读操作分为两部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10740eb2837c738aaa55cc13e470db82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d68f089da4a7de095332d9444d06e6/" rel="bookmark">
			(基于mysql的java毕业设计)在线答题系统(附源码&#43;论文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好！我是职场程序猿，感谢您阅读本文，欢迎一键三连哦。
💞当前专栏：Java毕业设计
精彩专栏推荐👇🏻👇🏻👇🏻
👉🎀 安卓app毕业设计
👉🌎微信小程序毕业设计
目录 一、项目简介二、系统设计2.1软件功能模块设计2.2数据库设计 三、系统项目部分截图3.1用户管理功能3.2管理员功能模块 四、论文目录五、部分核心代码4.1 用户部分 获取源码或论文 一、项目简介 论文主要是对在线答题系统进行了介绍，包括研究的现状，还有涉及的开发背景，然后还对系统的设计目标进行了论述，还有系统的需求，以及整个的设计方案，对系统的设计以及实现，也都论述的比较细致，最后对在线答题系统进行了一些具体测试。
本文以java为开发技术，实现了一个在线答题系统。在线答题系统的主要使用者分为管理员、用户；管理员：首页、管理员信息、用户信息、新闻资讯、公告信息、试题类别、题型信息、试题信息、试卷信息、成绩信息、个人信息、修改密码、退出登录；用户：首页、新闻资讯、公告信息、试题类别、题型信息、试题信息、试卷信息、成绩信息、个人信息、修改密码、退出登录等功能。通过这些功能模块的设计，基本上实现了整个课程信息管理的过程。
具体在系统设计上，采用了B/S的结构，同时，也使用java技术在动态页面上进行了设计，后台上采用Mysql数据库，是一个非常优秀的在线答题系统。
二、系统设计 2.1软件功能模块设计 系统架构图属于系统设计阶段，系统架构图只是这个阶段一个产物，系统的总体架构决定了整个系统的模式，是系统的基础。在线答题系统的整体结构设计如图4-2所示。
2.2数据库设计 本系统的E-R图如下图所示：
1、试题信息管理实体图如图4-3所示：
2、试卷信息管理实体图如图4-4所示：
三、系统项目部分截图 3.1用户管理功能 用户进入系统可以对首页、新闻资讯、公告信息、试题类别、题型信息、试题信息、试卷信息、成绩信息、个人信息、修改密码、退出登录等功能进行操作。程序效果图如下图5-9所示：
3.2管理员功能模块 2.1 管理员功能
管理员对登录后台后可以对首页、管理员信息、用户信息、新闻资讯、公告信息、试题类别、题型信息、试题信息、试卷信息、成绩信息、个人信息、修改密码、退出登录等内容进行相关操作。程序成效图如下图5-2所示:
四、论文目录 1 概述 1
1.1课题背景及意义 1
1.2 国内外研究现状 1
1.3 本课题主要工作 2
2 系统开发环境 3
2.1 java技术 3
2.2 Mysql数据库 3
2.3 B/S结构 4
3 系统分析 5
3.1 可行性分析 5
3.1.1 技术可行性 5
3.1.2操作可行性 5
3.1.3 经济可行性 5
3.1.4 法律可行性 6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19d68f089da4a7de095332d9444d06e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93351567bf71fcdc2917a4626acfb69d/" rel="bookmark">
			面试经历整理|持续四个月面试19家公司，收获8家offer，面试总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年总共投了 19 家公司，有几家挂在了不同的阶段，最后拿到了 8 家的 offer，这段时间里面了几十场面试，大多数面试的问题都懒得做记载了，在此只记录一下大概的问题走向、一些面试常见的问题以及一丢丢面试技巧供大家参考。
一、战况 投递统计（统计了一下，共向以下 19 个公司投递了简历，共拿了 8 个 offer）
一线大厂：字节、百度、腾讯、拼多多准一线大厂：***、华为、快手、美团、图森未来、京东、猿辅导二线小厂：TP-Link、招银科技、深信服、b站国企：中电 29 所、国电南自、农行外企：shopee(算半个外企吧) 二、面试情况 挂在简历筛选的公司
只招与需求极度相符的人：b站、图森未来
要求没达到：农行(英语六级没过)
未知理由：京东(听说面试都挺迷的)
挂在机试的公司
机试一般有性格评测和笔试两部分，性格评测主要是性格测试题+阅读理解+小学奥数+找规律+图表题，大概30min完成。
性格评测挂了：拼多多(忘做了)、华为实习生(挂了被捞了)
笔试挂了：(应该是和简历综合评判之后觉得不符合)
挂在面试的公司
实习生面试挂太多了：腾讯(之前实习生面试挂了三次，估计评分很低)
只招与需求极度相符的人：shopee(后端岗疯狂问用过哪些后端框架，不问基础和C++)
面试累了，鸽了面试：快手、猿辅导
自己拒了：中电 29 所(研究方向不符)
收割 offer
TP-Link：公司有 985 情结，面试基本就聊天，很容易就过了，在北京工资不高，并且无加班费字节：典型的挂了又捞，捞了有挂，经历了安全岗简历挂和一面挂，被广告部门捞起来，技术面三轮 +hr 面拿 offer深信服：机缘巧合投的大牛批，一面很水，二面是正常技术面，三面主管面很契合项目方向，拿了 ssp招银科技：调过电话面(摸底)，两轮技术面，问的东西都很浅，范围还比较广国电南自：一面技术面，比较简单，三天发 offer，本科生薪资低，还需要出差百度：无人车部门两面挂，语音识别部门三轮技术面+一轮主管面，跟字节类似，主管画技术饼华为(待安排)：实习生过了所以免笔试，一轮技术面+主管面，基本聊天，但 offer 下发周期长美团点评(待安排)：三轮技术面不是很难，hr面后两个月不给结果，估计是 hc 少，池子深 三、面试总结 由于大部分公司都是投的提前批，所以很少有笔试，面试一般是 2-5 轮，摸底面+技术面+主管面+hr面，侧重点各不相同。
摸底面 摸底面也就是很多公司的电话面，比如招银科技、国电南自，一般时间不会很长，大概在 10-20 分钟之间，主要是自我介绍+项目经历简介，有的会有一些常见的基础题，比如 TCP 为什么三次握手这种。只要有一定的准备，电话面基本都不会挂，有的公司如果你简历 or 笔试表现好会跳过这个环节。
技术面 技术面是面试流程中的核心环节，主要考察我们对计算机基础知识的掌握程度，一般会涉及计网、操作系统/Linux、数据库，编程语言(c++/Java等)，部分会问到编译原理这种比较偏向计算机专业的问题。
一般公司的技术面为 2-3 轮，主要模式都大概相似，开始自我介绍，紧接着问一些基础知识相关的问题 or 项目相关的技术问题，最后是 1-2 道现场编程题，也有的公司会先上来让你写题，后续根据你的表现来决定问什么问题。
主管面 并不是所有公司都有主管面，一般是部门直招 or 你前面面试表现较好，可能有 sp 的情况下才会有主管面试，一般主管的级别越高就说明你的评级越高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93351567bf71fcdc2917a4626acfb69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06c0757603929d7fee39d801eb5387e/" rel="bookmark">
			Java连接MySQL改成连接SQL Server数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两个数据库的语句基本上是一样的，从MySQL数据库转为SQL Server数据库只需要修改以下部分即可
1、驱动包不一样，sql server的驱动包是第一个，mysql的驱动包是第二个
这个要自己去下载，直接百度搜java连接xxx数据库的驱动包，一大堆教程
2、驱动程序的反射路径不一样
Class.forName("com.mysql.cj.jdbc.Driver"); //mysql的驱动反射路径 Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");//sql server的驱动反射路径 3、连接数据库的url不一样
上面是mysql的url，需要改成下面sql server这样的url写法
String dburl="jdbc:sqlserver://localhost:1433（默认端口号）;DatabaseName=pets（自己数据库名）"; Connection con = DriverManager.getConnection(dburl,"sa","sql2008");//连接到目标数据库 System.out.println("连接成功"); 注意：通常 sql server 的超级管理员的名称是sa
温馨提示：如果在sql server中建立的表名是user这样跟sql server中的关键字一致，那就会报错！解决办法就是在sql语句的user表名那改成 [user],也就是加个[ ],表示把User用中括号括起来后表示把user不作为关键字使用~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8573db888f14cac1481c4ad697434eb4/" rel="bookmark">
			React配置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一： 在package.json中追加如下配置：
"proxy":"http://localhost:5000"
方式二： 1.创建代理配置文件 （setupProxy.js） 在src下创建配置文件：src/setupProxy.js
2.编写setupProxy.js配置具体代理规则 setupProxy.js文件
// react脚手架自带这个库 const proxy = require("http-proxy-middleware"); module.exports = function (app) { app.use( proxy("/api1", { // 遇见api1这个前缀就会触发该代理配置 target: "http://localhost:5000", // 请求转发给谁 changeOrigin: true, // 控制服务器中的请求头中Host字段的值 pathRewrite: { "^/api1": "" }, // 重写请求路径 }), proxy("/api2", { target: "http://localhost:5001", changeOrigin: true, pathRewrite: { "^/api2": "http://localhost:3000/" }, }) ); }; App.js文件
// 创建“外壳”组件App import React, { Component } from "react"; import axios from "axios"; // 创建并暴露App组件 export default class App extends Component { gethandleData = () =&gt; { axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8573db888f14cac1481c4ad697434eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ad69067e7d6863d079850847034753/" rel="bookmark">
			matlab使用udpport实现udp通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了实现程序间udp通信，可以使用matlab的udpport函数建立本地udp端口，监听及发送数据。
主要可以参考matlab官网给出的文档：udpport函数的使用
以下是我的整理。
1. 建立端口 u = udpport('IPV4', ... 'LocalHost','127.0.0.1', ... 'LocalPort',8000); 这段可以直接用，表明建立了一个端口号为8000的udp端口，可以负责监听和发送数据。
2. 属性设置 建立好udp后，会出现一个udpport实例，打开会发现其中有很多属性可以设置，我选择了几个比较常用的、可能需要自己设定的属性详细说一下。
2.1 Timeout 设置可以进行端口监听或数据发送的操作时长，单位是秒，类似于这个端口可以工作的时长。
例如：
u.Timeout=100; 那么udpport建立后的100s内，都可以进行监听。
2.2 OutputDatagramSize 发送一次数据到该udpport后，最大可以被读入的字节数，可以设置为1到 65507。
有时候会发现读入的数据不完整，很可能是因为这个值设置的太小了，因为默认只有512。
举例：
u.OutputDatagramSize = 65500; 2.3 LocalPort和LocalHost 这两个属性我在上面创建udpport的代码中已经设定了，就不再赘述。
2.4 NumBytesAvailable 这是可以读的字节数
比如在读取数据的时候，可能不知道有多少数传过来了，就可以：
data = read(u,u.NumBytesAvailable,'string'); 另外，每次读取某个长度的数据后，NumBytesAvailable会自动减去这个长度。
关于read函数参考下文。
2.5⭐BytesAvailableFcn、BytesAvailableFcnCount、BytesAvailableFcnMode 这个是放在一起设置的，通过这三个参数，就可以达到这样的效果：当目前udpport缓存的BytesAvailableFcnMode数为BytesAvailableFcnCount时，就可以唤起BytesAvailableFcnCount函数。
举例：
% 当有5个数据包可获得时，调用函数myCallbackFcn configureCallback(u,"datagram",5,@myCallbackFcn); % 当有5个字节可获得时，调用函数myCallbackFcn configureCallback(u,"byte",50,@myCallbackFcn); 这里比较特别的是，需要使用configureCallback这个函数进行设置，关于这个函数也参考下文。
3. 相关函数 3.1 read函数 可参考官网：read函数
这个函数是用来实现从udpport中读取已收到的数据，例如：
data = read(u,5,'string'); 就是读取5个字节，并指定了返回类型是string。
如果是在监听端口的过程中，调用这个函数来获取收到的数据，那么执行完毕之后程序会停止，不再继续监听了。
所以说，用matlab进行应用间通信时，如果是只需要传输一次数据，比较适合用read函数，如果是多次不定时地传输，最好用configureCallback设定事件触发。
3.2 write函数 可参考官网：write函数
这个函数是用来实现从udpport向某个端口发送数据，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ad69067e7d6863d079850847034753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be267c909435b2ab900d159371560bf/" rel="bookmark">
			HTML概述及常用语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 HTML HTML 用来描述网页的一种语言 HTML -- hyper text markup language 超文本标记语言 超文本包括：文字、图片、音频、视频、动画等等 标记语言：是一套标记标签， HTML 使用标记标签来 描述 网页 &lt;&gt; HTML 发展史 HTML5 的优势 浏览器厂商对 HTML5 的支持 Microsoft edge Google chrome Opera Mozila ...... 市场的需求 跨平台 W3C W3C World Wide Web Consortium -- 万维网联盟 成立于 1994 年， Web 技术领域最权威和具有影响力的国际 中立性技术标准机构 http://www.w3.org/ http://www.chinaw3c.org/ W3C 标准包括 结构化 标准语言（ HTML 、 XML ） 表现 标准语言（ CSS ） 行为 标准（ DOM 、 ECMAScript ） HTML 基本结构 如下图所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0be267c909435b2ab900d159371560bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da890ca1a070c697fb7365052a74613b/" rel="bookmark">
			【RxJava】RxJava 简介 ( RxJava 概念 | RxJava 组成 - 被观察者 / 观察者 / 订阅 / 操作符 | RxJava 适用场景 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、RxJava 简介1、RxJava 概念2、RxJava 组成 - 被观察者 / 观察者 / 订阅 / 操作符3、RxJava 适用场景 一、RxJava 简介 1、RxJava 概念 RxJava 框架 是一个 异步编程函数库 , 包含了如下要素 :
观察者模式迭代器模式函数式编程 RxJava 框架应用场景 :
异步操作事件流 2、RxJava 组成 - 被观察者 / 观察者 / 订阅 / 操作符 RxJava 组成要素 :
Observable（被观察者）： Observable 是一个 可以发送消息的数据源 , 可以同时发送若干消息 , 消息的格式可以通过泛型进行定义 ; 消息发送完毕后 会 通知观察者。Observable 通过 订阅观察者 来实现 消息的传递。
Observer（观察者）： Observer 表示一个接收 Observable 发送消息 的观察者。 它可以处理从 Observable 发射的消息， 还可以处理错误和完成的事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da890ca1a070c697fb7365052a74613b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25333f2b00c961327fc89931b2fac10/" rel="bookmark">
			MySQl乱码问题解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 拓展- 01 MySQl乱码问题解决方式1.方式一：卸载当前版本，下载最新版的MySQL 8.02.方式二：MySQL命令方式3.方式三：通过修改配置文件方式 拓展- 01 MySQl乱码问题解决方式 在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3。网站开发人员在数据库设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0 开始，数据库的默认编码改为 utf8mb4 ，从而避免了上述的乱码问题。mysql是我们项目中非常常用的数据型数据库。但是当我们需要在数据库保存中文字符，就经常会遇到数据库乱码情况。下面就来介绍一下如何彻底解决数据库中文乱码情况。
1.方式一：卸载当前版本，下载最新版的MySQL 8.0 2.方式二：MySQL命令方式 通过MySQL命令的方式，修改mysql默认字符集的方法。
SET character_set_client = utf8 ; SET character_set_connection = utf8 ; SET character_set_database = utf8 ; SET character_set_results = utf8 ; SET character_set_server = utf8 ; SET collation_connection = utf8 ; SET collation_database = utf8 ; SET collation_server = utf8 ; 一般就算设置了表的mysql默认字符集为utf8并且通过UTF-8编码发送查询，你会发现存入数据库的仍然是乱码。问题就出在这个connection连接层上。解决方法是在发送查询前执行一下下面这句：
SET NAMES 'utf8'; 它相当于
SET character_set_client = utf8; SET character_set_results = utf8; SET character_set_connection = utf8; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25333f2b00c961327fc89931b2fac10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59feb20e22ce97deabdec0926d283ef1/" rel="bookmark">
			纯JS前端分页方法（JS分页）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JS分页函数：开发过程中，分页功能一般是后台提供接口，前端只要传page（当前页码）和pageSize（每页最大显示条数）及对应的其他查询条件，就可以返回所需分页显示的数据。
但是有时也需要前端本地进行一些简单的分页处理以减轻浏览器渲染时的内存损耗。如后台传回的数据条数非常多，达到几千条甚至上万条，但是后台又不方便分页传回数据，这个时候就只能前端先获取所有数据保存下来，然后前端本地进行分页并渲染显示。
2、只需要一个纯原生的js函数就可以实现前端的分页功能，直接上js代码：
/** * @name getTableData * @desc 纯JS前端分页方法 * @param {Number} page 当前页码，默认1 * @param {Number} pageSize 每页最多显示条数，默认10 * @param {Array} totalData 总的数据集，默认为空数组 * @return {Object} { data, //当前页展示数据，数组 page, //当前页码 pageSize, //每页最多显示条数 length, //总的数据条数 } **/ const getTableData = (page = 1, pageSize = 10, totalData = []) =&gt; { const { length } = totalData; const tableData = { data: [], page, pageSize, length, }; if (pageSize &gt;= length) { //pageSize大于等于总数据长度，说明只有1页数据或没有数据 tableData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59feb20e22ce97deabdec0926d283ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9840d764e10988dc08d55f4bb03949d8/" rel="bookmark">
			linux centos 安装DOCKER开原版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装DOCKER CE
centos7 yum 命令：
yum -y install docker
安装最新版本的Docker CE，或转到下一步安装特定版本：
&lt;span style="color:#333333"&gt;&lt;code&gt;&lt;span style="color:#00688b"&gt;$ &lt;/span&gt;&lt;span style="color:#658b00"&gt;sudo &lt;/span&gt;yum install docker-ce &lt;/code&gt;&lt;/span&gt; 如果提示接受GPG密钥，请验证指纹是否匹配060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35，如果匹配 ，则接受它。
有多个Docker存储库？
如果您启用了多个Docker存储库，则在未指定yum install或 yum update命令中的版本的情况下安装或更新始终会安装尽可能高的版本，这可能不适合您的稳定性需求。
Docker已安装但尚未启动。该docker组已创建，但没有用户添加到该组。
要安装特定版本的Docker CE，请列出repo中的可用版本，然后选择并安装：
一个。列出并对您的仓库中可用的版本进行排序。此示例按版本号对结果进行排序，从最高到最低，并被截断：
&lt;span style="color:#333333"&gt;&lt;code&gt;&lt;span style="color:#00688b"&gt;$ &lt;/span&gt;yum list docker-ce &lt;span style="color:#8b008b"&gt;--showduplicates&lt;/span&gt; | sort &lt;span style="color:#8b008b"&gt;-r&lt;/span&gt; docker-ce.x86_64 18.03.0.ce-1.el7.centos docker-ce-stable &lt;/code&gt;&lt;/span&gt; 返回的列表取决于启用的存储库，并且特定于您的CentOS版本（.el7在此示例中以后缀表示）。
湾 通过其完全限定的包名称安装特定版本，包名称（docker-ce）加上版本字符串（第2列）直到第一个连字符，-例如，用连字符（） 分隔docker-ce-18.03.0.ce。
&lt;span style="color:#333333"&gt;&lt;code&gt;&lt;span style="color:#00688b"&gt;$ &lt;/span&gt;&lt;span style="color:#658b00"&gt;sudo &lt;/span&gt;yum install docker-ce-&lt;VERSION STRING&gt; &lt;/code&gt;&lt;/span&gt; Docker已安装但尚未启动。该docker组已创建，但没有用户添加到该组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9840d764e10988dc08d55f4bb03949d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824d67fbd016cdf9f89a1d492dceadef/" rel="bookmark">
			快速解决浏览器访问http或者不安全https 地址栏出现不安全或者Not secure
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2018 年开始 google 浏览器 开始对 http 所有的网址都做出了 不安全的提示 ，如
这样的话 让很多 http的网址显得很“不安全”
在对外展示的时候，不禁给客户留下不好的印象
解决此问题的 正规方案当然是 改成 浏览器推荐的 https ，有正规的域名，但是本方案不是本文重点，我们的重点是能够快速通过浏览器配置，屏蔽 “不安全“ 和 Not secure 这些看起来让人不安的因素
接下来我们会分浏览器分别介绍
Chrome:
1、地址栏 输入 chrome://flags/
2、搜索 secure 关键字 找到 Insecure origins treated as secure 选项
把开关 从 Default 改成 Enabled 并在地址栏输入 不安全的来源的网址 ，多个可以用，分割
最后再访问 就不会提示不安全
FireFox：
亲测可用
Edge 和 欧鹏 等浏览器 基本上跟Chrome 差不多 ，我并未尝试，大家可以试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e5eee1e0929e97b7ea8bacd05b2a38/" rel="bookmark">
			vue 控制浏览器返回 防止返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 methods: { goBack() { console.log("点击了浏览器的返回按钮"); if (this.isPublicize) { //禁止浏览器返回 history.pushState(null, null, location.href); this.isPublicize = false; } else { // 可以返回的时候 this.$router.go(-1); } }, }, mounted() { if (window.history &amp;&amp; window.history.pushState) { // 向历史记录中插入了当前页 history.pushState(null, null, location.href); window.addEventListener("popstate", this.goBack, false); } }, destroyed() { window.removeEventListener("popstate", this.goBack, false); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886a1c4aa6b92acb36a2119198c0d25b/" rel="bookmark">
			Python查看已安装模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过 help("modules") 查看 help("modules") 通过 pip list 查看 pip list 通过web端口查看 python -m pydoc -p 1234 Server ready at http://localhost:1234/ Server commands: [b]rowser, [q]uit server&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c64523313f98c234822baeb646fc18/" rel="bookmark">
			5.6 Mybatis代码生成器Mybatis Generator (MBG)实战详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Mybatis Generator简介二、Maven插件运行方式三、生成配置 generatorConfig.xmlMyBatis3Simple风格MyBatis3风格MyBatis3DynamicSql风格 四、Java代码运行方式五、MGB生成全部表六、增加Ext包七、Git提交总结 前言 本文我们主要实战Mybatis官方的代码生成器：Mybatis Generator(MBG)，掌握它以后，可以简化大部分手写代码，我们只需要写复杂逻辑代码！
通过前几篇，我们掌握了在SpringBoot下Mybatis的基本用法，操作步骤回顾一下：
创建与MySQL表对应的Java PO对象，字段一一对应；创建Mapper接口，和对应的XML映射文件(或注解)。 在实际开发中，你会发现有很多重复的工作：
首先是PO对象，我们往往创建与数据库表字段一一对应的PO对象;其次在Mapper里，通常都会写基本的增删改查代码。 重复不符合我们程序员的风格：
其实对于PO对象，只需要读取数据库表字段，然后做SQL列类型与Java字段类型转换，再将列名转成骆驼命名就可以实现，所以能实现的代码生成器也非常多！再者对于单表的基本增删改查是ORM的基本功能，像JPA对单表的基本增删改查都进行了封装！
那么在Mybatis里，这些当然也不在话下，Mybatis官方为我们提供了非常好用的代码生成器：Mybatis Generator (MBG) 。 本文就带大家实战一下Mybatis Generator，用它生成实战项目全部表的PO对象和基本增删改查代码！
一、Mybatis Generator简介 Mybatis Generator（MBG）是Mybatis官方提供的一个代码生成工具，它可以根据数据库表自动生成对应的Java Model、Mapper和XML文件，甚至还可以生成一些高级查询功能，使用Mybatis-Generator可以大大降低开发者的工作量，提高开发效率！
支持使用Maven插件生成，也支持编写Java代码生成，还有命令行等等多种方式！
支持生成XML映射文件风格的代码，也支持生成全注解风格的代码！
二、Maven插件运行方式 首先在工程tg-book-dal的pom.xml中，根节点project下添加build节点，如下：
&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 然后刷新tg-book-dal的Maven依赖，你就能看到mybatis-generator插件了，如下图：
注意，这时生成时会报错，因为我们还需要添加配置文件，接着向下看.
三、生成配置 generatorConfig.xml 在tg-book-dal 的 src/main/resources 下 添加配置文件： generatorConfig.xml ，用于配置生成风格，数据库连接、生成代码包路径、生成哪些表等等，各配置参数详解参考注释：
注意：==我增加了几个实用的可选配置，像生成时覆盖原文件、去除注释、自增主键列、columnOverride ==
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c64523313f98c234822baeb646fc18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf22ece6d32a6865996eb2fae461a0c/" rel="bookmark">
			YOLOv5算法的一些心得（框架&#43;目录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究无人机视觉，并接触了YOLOv5算法。作为一个视觉小白，一些细节问题总会耗费我很多时间，这很容易打击到学习的热情。因此我想写一些博客，在介绍YOLOv5使用的同时将我所遇到的问题和解决方法记录下来，从而帮大家节约一部分时间，同时也方便自己复习查阅。当然，水平有限，错误在所难免，欢迎大家批评指正。
接下来更新的内容大体如下（自己画的框图有点丑，请见谅），一些关键步骤已在图中给出，方便大家查阅。这个框架是基本框架，随着学习的深入，我会将一些新学到的内容及时更新到框架中，希望能帮助到大家。第一次写博客，废话很多，没什么干货，之后会积极改正，希望大家多多支持。
目录：
环境配置相关 YOLOv5环境配置中的一些细节
YOLOv7环境配置的一些细节
YOLO环境配置中一些常见的问题
YOLO算法入门 使用YOLOv5实现图片、视频的目标检测
使用YOLOv5实现单摄像头实时目标检测
使用YOLOv5实现多摄像头实时目标检测
YOLOv5识别目标的实时坐标打印
YOLOv5训练部署
YOLOv5自制数据集训练与部署
YOLO拓展功能 YOLOv5冷门小知识
YOLOv5调用IP摄像头
YOLOv5实现目标计数
YOLOv5+DeepSort实现目标跟踪
使用YOLOv5实现实时目标检测结果保存
求学路上，你我共勉(๑•̀ㅂ•́)و✧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1da54076e5983d8fc70190359fa1de9/" rel="bookmark">
			vue3中ts定义对象，pinia中使用ts定义状态对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引入reactive中使用数组reactive中定义对象类型pinia中定义状态对象 引入 用惯了js，突然使用ts属实有点不习惯，这里介绍一下自己在vue3中使用ts初始化内容的一些小技巧
reactive中使用数组 例如下面所示的代码，我们就像写js代码一样定义一个空数组，但是ts自动推断的类型确是 never[] ，这样我们就给数组添加元素
const userInfo = reactive({ name:"", age:18, likes:[] }); userInfo.likes.push("game") 我们使用数组对象结合泛型即可解决这个问题，如下所示：
可以看到代码提示推断出的类型是string数组，元素添加也完全没问题 likes:new Array&lt;string&gt;() reactive中定义对象类型 就以上面的案例扩展，我们完全可以将userInfo抽象为一个接口，来规范各个属性，如下所示：
这样使用，数组添加元素也完全没问题 interface IUserInfo { name: string; age: number; likes: Array&lt;string&gt;; } const userInfo = reactive&lt;IUserInfo&gt;({ name: "", age: 18, likes: [], }); userInfo.likes.push("game"); pinia中定义状态对象 如下所示，我们定义一个counter的状态管理，并且使用对象进行初始化
import { defineStore } from "pinia"; interface ICounterStore { counter: number; messages: Array&lt;string&gt;; map: Map&lt;string, string&gt;; } // 定义一个Store，名称要保证全局唯一 export const useCounterStore = defineStore("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1da54076e5983d8fc70190359fa1de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2597b780670cfc86e8a01f79393e8493/" rel="bookmark">
			FastAPI自定义接口参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fastapi接口定义：
首先需要定义一个参数类Item，其只有一些基本属性，代表接口所需要的各个参数，继承Basemodel是为了更方便的处理参数，如将参数转化成字典或json类型;如果参数较少，可以不用特地封装一个类，可以参考test_next_api接口,Optional[]的作用是为可选参数限定类型，Query()的作用可以自行了解，参考连接如下：
Query: FastAPI入门篇一Query参数与字符串验证启动fastapi服务：uvicorn模块是一个基于asyncio开发的一个轻量高效的web服务器框架，使用起来比较方便 import uvicorn import json from fastapi import FastAPI app = FastAPI() # ----------------fastapi接口定义---------------- class Item(BaseModel): # 定义一个参数类 name: str age: int message: dict @app.post("/testapi") def send_message(info: Item): result = { "code": "", "message": "", "error": None, "data": "" } try: print(f'收到参数：{info}') print(info.name) print(info.age) cases = info.message case1 = cases['case1'] print(case1['round']) result["code"] = "0000" result["message"] = "成功接收参数" result["data"] = info except Exception as e: result["code"] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2597b780670cfc86e8a01f79393e8493/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/82/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>