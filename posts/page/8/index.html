<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce0235b666b008fbafcc6a0ea58c6e9/" rel="bookmark">
			Weblogic安全漫谈(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇介绍coherence.jar中的漏洞利用链及后续绕过。
经历2015到2018的3年迭代后，Weblogic的黑名单逐渐完善，废掉CC反序列化更是釜底抽薪。另一方面也促使研究员去挖掘新组件新利用链，这篇介绍的就是@testbnull在发现Spring写文件链后[1]，继续挖掘出coherence.jar中的漏洞利用链及后续绕过。因为10.3.6默认没有启用coherence，我们用12.2.1.3作为调试环境。
CVE-2020-2555 CC链的核心是InvokerTransformer#transform方法对Method.invoke的调用，Weblogic几百个lib中有没有类CC链呢？
1. 查找调用了Method.invoke的方法
2. 筛出可被序列化的方法所在类
3. 剔除参数不可控的结果
注意到com.tangosol.util.extractor.ReflectionExtractor#extract，与transform不说丝毫不差至少也是大同小异。
同包中也有与ChainedTransformer作用一致的ChainedExtractor，ReflectionExtractor实现了ValueExtractor接口满足类型要求：
tabby的分析找到了关键的com.tangosol.util.filter.LimitFilter#toString，这样就能链上CC5开头用的BadAttributeValueExpException实现完整利用链。
更进一步可以找到很多具有套娃能力的类方法：
除此以外注意到期间出现过的MVEL包，方便地查到也可以com.tangosol.coherence.rest.util.extractor.MvelExtractor#extract作为sink执行MVEL表达式。
根据关键类方法的变量要求构建利用链就行：
extract:95, MvelExtractor (com.tangosol.coherence.rest.util.extractor) extract:112, ReflectionExtractor (com.tangosol.util.extractor) extract:83, ChainedExtractor (com.tangosol.util.extractor) // extract:96, MultiExtractor (com.tangosol.util.extractor) toString:581, LimitFilter (com.tangosol.util.filter) readObject:86, BadAttributeValueExpException (javax.management) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invokeReadObject:1170, ObjectStreamClass (java.io) readSerialData:2178, ObjectInputStream (java.io) readOrdinaryObject:2069, ObjectInputStream (java.io) readObject0:1573, ObjectInputStream (java.io) CVE-2020-2883 上文搜索"具有套娃能力的类"时，有一个与很多节点是[ALIAS]关系的抽象基类com.tangosol.util.extractor.AbstractExtractor在compare中调用了extract：
这样就能链上CC2开头用的PriorityQueue实现完整利用链。
extract:95, MvelExtractor (com.tangosol.coherence.rest.util.extractor) extract:112, ReflectionExtractor (com.tangosol.util.extractor) extract:83, ChainedExtractor (com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ce0235b666b008fbafcc6a0ea58c6e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2182621ea8483dca611f35010912b06/" rel="bookmark">
			python3基础知识-学习目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次学习的内容是以python3.X为平台，详细的阐述python编程的基础知识和高级技巧。虽然之前学习过相关的知识，但是并未真正掌握python的原理，此次的学习更是为了加深自己的印象，并更深入的理解python的高阶知识。
为了学习效率更好，在学习之前，先把要学习的知识进行了体系化的整理，搭建了一个基本的学习框架，希望可以更进一步提前了解自己所学习的知识，以便构成一个体系框架。
学习的对象 1.python编程初学者和爱好者，想要快速掌握python编程的人员 2.培训结构的老师和学生，想要进一步回顾人员 3.想要进入人工智能行业的初学者 4.从事数据分析的科研工作人员 5.想进入机器学习和深度学习领域的技术人员 未来要学习的内容 1.python的编辑环境 2.入门知识 3.字符串 4.容器 5.函数 6.循环 7.条件选择 8.模块 9.类 10.类的特殊成员 11.文件 12.异常处理 13.日期和时间 14.测试代码 15.程序打包 16.数据库 17.网络编程 18.图形用户界面 19.科学计算numpy等工具 简单介绍学习的内容 1.python的编辑环境 1.1了解python的历史 1.2安装python 1.3pythonIDE和anaconda的介绍 1.4人士python程序 1.4.1.命令行 1.4.2.python代码行 1.4.3.python脚本 1.4.4缩进 1.4.5缩进 2.入门知识 2.1 编码规范 2.2 关键字 2.3常量和变量 2.4标识符 2.5运算符 2.5.1算术运算符 2.5.2比较运算符 2.5.3逻辑运算符 2.5.4.位运算符 2.5.5.成员运算符 2.5.6.身份运算符 2.5.7.赋值运算符 2.5.8.运算符优先级 2.6.数据类型 2.6.1.整数型 2.6.2.浮点型 2.6.3.复数型 2.6.4.字节型 2.6.5.布尔型 2.6.6.字符串型 2.7内置函数 3.字符串 3.1字符串的基本操作 3.1.1索引和切片 3.1.2不可变操作 3.1.3拼接 3.1.4长度 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2182621ea8483dca611f35010912b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a49425c3265cc6f074eb15fbcec9e66/" rel="bookmark">
			msvcr120.dll丢失怎样修复，教你msvcr120.dll丢失的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用电脑的过程中出现关于msvcr120.dll丢失的问题，那么出现这样的问题应该怎么解决呢？其实解决的办法也很简单，今天就和大家说说msvcr120.dll丢失怎样修复，同时给大家介绍一些关于msvcr120.dll文件的相关内容，了解msvcr120.dll文件的重要性。
一.msvcr120.dll文件的相关介绍 文件描述：msvcr120.dll的全名是Microsoft C Runtime Library。它包含了与C++编译器和运行时环境相关的函数、类和变量。这些函数和组件是为了帮助应用程序开发人员在运行时执行常见操作而设计的。
位置：msvcr120.dll通常位于Windows系统目录（比如C:\Windows\System32）中。它也可能与编译的应用程序放在同一目录下，以确保应用程序能够正确地加载并使用该文件。
版本：msvcr120.dll的具体版本号取决于Visual Studio 2013的具体发行版和更新级别。不同的更新版本可能会引入修复和改进，所以在解决问题时确保使用最新的更新版本是很重要的。
二.msvcr120.dll丢失怎样修复 卸载程序软件 电脑出现msvcr120.dll丢失可能是因为软件出现了问题，所以解决msvcr120.dll丢失可以尝试使用将软件进行卸载，具体操作步骤：
1.按Windows + X打开“开始”按钮上下文菜单。在这里，选择选项应用与功能。
2.在应用程序和功能页面，在已安装应用程序列表中查找有问题的程序。双击软件图标找到卸载的提示，然后选择卸载。在弹出的确认提示中再次单击卸载。
3.等待程序从你的电脑上卸载。重新启动你的电脑。
4.从其网站下载应用程序的安装程序。使用下载的安装程序安装应用程序。
5.启动应用程序并检查它是否因msvcr120.dll错误而崩溃。
使用dll修复工具 msvcr120.dll丢失小编认为最好的解决办法就是使用dll文件丢失的问题，小编也使用是这个工具进行解决msvcr120.dll丢失的问题。详细操作步骤如下：
1.先获得dll修复工具，可以在浏览器顶部输入：dll修复.site ，点击回车键进入获得这个工具
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
2.获得工具之后开始使用dll修复工具，dll修复工具中的一键修复和手动修复都可以将msvcr120.dll丢失的问题进行修复。
3.一键修复可以将电脑缺失的msvcr120.dll文件和其他的dll文件都进行修复完成。
4.手动修复在页面中搜索msvcr120.dll，在点击手动修复即可将msvcr120.dll文件修复完成。
运行 SFC 扫描和 DISM 工具 1. 使用Windows 和 R组合键打开运行对话框。键入cmd并按Ctrl + Shift + Enter以管理员身份打开命令提示符。当用户帐户控制提示时单击是。
2. 键入以下命令并按Enter运行 SFC 扫描证监会sfc /scannow
3. 等待扫描检查 Windows 系统文件是否损坏并修复它们。扫描完成后，检查msvcr120.dll丢失问题是否已解决。
4. 如果问题仍然存在，则以管理员身份打开命令提示符并使用以下命令执行 DISM 扫描。DISM /在线 /Cleanup-Image /RestoreHealth
5. DISM 工具检查 Windows 映像中的任何损坏并修复它们。工具完成运行后，尝试运行有问题的程序并检查是否已解决msvcr120.dll丢失。
执行系统还原 1.使用Windows + R组合键打开运行框。键入rstrui并按Enter打开系统还原。
2. 在“系统还原”窗口中，选择“推荐还原”选项。然后，单击下一步。
注意：如果你需要其他还原点，请选择选择其他还原点。单击下一步。然后，从列表中选择还原点。单击下一步。但如果没有创建那么这个方法将不能进行使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a49425c3265cc6f074eb15fbcec9e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed710a3879923a1b969f0376c6cbd1ef/" rel="bookmark">
			Langchain-Chatchat开源库使用的随笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN越来越不好用了，
降低CSDN发文，本篇后续持续更新会在：
Langchain-Chatchat开源库使用的随笔记
https://zhuanlan.zhihu.com/p/676061269
笔者最近在研究Langchain-Chatchat，所以本篇作为随笔记进行记录。
最近核心探索的是知识库的使用，其中关于文档如何进行分块的详细，可以参考笔者的另几篇文章：
大模型RAG 场景、数据、应用难点与解决（四）RAG 分块Chunk技术优劣、技巧、方法汇总（五） 原项目地址：
Langchain-ChatchatWIKI教程（有点简单） 1 Chatchat项目结构 整个结构是server 启动API，然后项目内自行调用API。
API详情可见：http://xxx:7861/docs ，整个代码架构还是蛮适合深入学习
2 Chatchat一些代码学习 2.1 12个分块函数统一使用 截止 20231231 笔者看到chatchat一共有12个分chunk的函数
这12个函数如何使用、大致点评可以参考笔者的另外文章（RAG 分块Chunk技术优劣、技巧、方法汇总（五））：
CharacterTextSplitter LatexTextSplitter MarkdownHeaderTextSplitter MarkdownTextSplitter NLTKTextSplitter PythonCodeTextSplitter RecursiveCharacterTextSplitter SentenceTransformersTokenTextSplitter SpacyTextSplitter AliTextSplitter ChineseRecursiveTextSplitter ChineseTextSplitter 借用chatchat项目中的test/custom_splitter/test_different_splitter.py来看看一起调用make_text_splitter函数：
from langchain import document_loaders from server.knowledge_base.utils import make_text_splitter # 使用DocumentLoader读取文件 filepath = "knowledge_base/samples/content/test_files/test.txt" loader = document_loaders.UnstructuredFileLoader(filepath, autodetect_encoding=True) docs = loader.load() CHUNK_SIZE = 250 OVERLAP_SIZE = 50 splitter_name = 'AliTextSplitter' text_splitter = make_text_splitter(splitter_name, CHUNK_SIZE, OVERLAP_SIZE) if splitter_name == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed710a3879923a1b969f0376c6cbd1ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e949c7662d1ce4c624ec9ea3fa600bd1/" rel="bookmark">
			【大数据（一）】hadoop2.4.1集群搭建(重点)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
1.准备Linux环境 1.0先将虚拟机的网络模式选为NAT 1.1修改主机名 vi /etc/sysconfig/network
NETWORKING=yes HOSTNAME=server1.itcast.cn 1.2修改ip地址 vi /etc/sysconfig/network-scripts/ifcfg-eth0
重新启动网络：service network restart
1.3修改ip地址和主机名的映射关系 vi /etc/hosts
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.0.101 server1.itcast.cn 1.4关闭防火墙iptables并设置其开机启动/不启动 #查看防火墙状态
service iptables status #关闭防火墙
service iptables stop #查看防火墙开机启动状态
chkconfig iptables --list #关闭防火墙开机启动
chkconfig iptables off 1.5 修改sudo （sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具）
1. su root #进入超级用户 2. ll /etc/sudoers #查看/etc/sudoers的权限 3. chmod 777 /etc/sudoers #修改/etc/sudoers文件的权限成可读可写可执行 4 vi /etc/sudoers # 给hadoop用户添加执行的权限 root ALL=(ALL) ALL hadoop ALL=(ALL) ALL 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e949c7662d1ce4c624ec9ea3fa600bd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27a3ca4279c60d695adff206d8433c7/" rel="bookmark">
			安装部署halo博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 安装文档：https://docs.docker.com/engine/install/
Docker Compose 安装文档：https://docs.docker.com/compose/install/
mkdir ~/halo &amp;&amp; cd ~/halotouch ~/halo/docker-compose.yamlvim application.yaml application.yaml version: "3" services: halo: image: halohub/halo:2.11 container_name: halo restart: on-failure:3 #network_mode: "host" volumes: - ./halo2:/root/.halo2 ports: - "8090:8090" command: # 修改为自己已有的 MySQL 配置 - --spring.r2dbc.url=r2dbc:pool:mysql://ip:3306/halo - --spring.r2dbc.username=root - --spring.r2dbc.password=password - --spring.sql.init.platform=mysql # 外部访问地址，请根据实际需要修改 - --halo.external-url=http://localhost:8090/ # 端口号 默认8090 - --server.port=8090 docker-compose up -d 原文：出处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a302fe8a1c20e9f83fa31ca9595381f/" rel="bookmark">
			大创项目推荐 深度学习卷积神经网络垃圾分类系统 - 深度学习 神经网络 图像识别 垃圾分类 算法 小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 简介1 背景意义2 数据集3 数据探索4 数据增广(数据集补充)5 垃圾图像分类5.1 迁移学习5.1.1 什么是迁移学习？5.1.2 为什么要迁移学习？ 5.2 模型选择5.3 训练环境5.3.1 硬件配置5.3.2 软件配置 5.4 训练过程5.5 模型分类效果(PC端) 6 构建垃圾分类小程序6.1 小程序功能6.2 分类测试6.3 垃圾分类小提示6.4 答题模块 7 关键代码8 最后 0 简介 🔥 优质竞赛项目系列，今天要分享的是
深度学习卷积神经网络垃圾分类系统
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 背景意义 近年来，随着我国经济的快速发展，国家各项建设都蒸蒸日上，成绩显著。但与此同时，也让资源与环境受到了严重破坏。这种现象与垃圾分类投放时的不合理直接相关，而人们对于环境污染问题反映强烈却束手无策，这两者间的矛盾日益尖锐。人们日常生活中的垃圾主要包括有害垃圾、厨余垃圾、可回收垃圾以及其他垃圾这四类，对不同类别的垃圾应采取不同分类方法，如果投放不当，可能会导致各种环境污染问题。合理地进行垃圾分类是有效进行垃圾处理、减少环境污染与资源再利用中的关键举措，也是目前最合适最有效的科学管理方式，利用现有的生产水平将日常垃圾按类别处理、利用有效物质和能量、填埋无用垃圾等。这样既能够提高垃圾资源处理效率，又能缓解环境污染问题。
而对垃圾的分类首先是在图像识别的基础上的，因此本文想通过使用近几年来发展迅速的深度学习方法设计一个垃圾分类系统，从而实现对日常生活中常见垃圾进行智能识别分类，提高人们垃圾分类投放意识，同时避免人们错误投放而产生的环境污染。
2 数据集 数据集采用了中国发布的垃圾分类标准，该标准将人们日常生活中常见的垃圾分为了四大类。其中，将废弃的玻璃、织物、家具以及电器电子产品等适合回收同时可循环利用的废弃物归为可回收垃圾。将剩菜剩饭、果皮果壳、花卉绿植以及其他餐厨垃圾等容易腐烂的废弃物归为厨余垃圾。将废电池、废药品、废灯管等对人们身体健康和自然环境有害而且应当门处理的废弃物归为有害垃圾。除以上三类垃圾之外的废弃物都归为其他垃圾。
该数据集是图片数据，分为训练集85%（Train）和测试集15%（Test）。其中O代表Organic（有机垃圾），R代表Recycle（可回收）
3 数据探索 我们先简单的大致看看数据的情况
所得的垃圾图片数据集中有40个二级类别，图片数量合计
14802张。由图3-1可以看出，各个垃圾类别的图像数据量不均衡，其中图片数据量较少的类别有：类别0(一次性快餐盒)、类别3(牙签)、类别20(快递纸袋)；数据量较多的类别是：类别11(菜叶根)、类别21(插头电线)、类别25(毛绒玩具)。
4 数据增广(数据集补充) 数据增广就是对基础数据集进行扩充，避免因为数据集太少导致在模型训练过程可能出现的过拟合现象，以此来提高模型泛化能力，达到更好的效果。根据扩充数据集的来源可分为两类：内部数据增广是对基础数据集进行水平翻转、垂直翻转、高斯噪声以及高斯模糊等变换操作，来产生新的特征；而外部数据增广是引入新的高质量外部数据来扩充数据集，包括数据爬取与数据筛选两个步骤。
数据爬取是通过网络爬虫技术来实现的，爬虫的流程是，首先向远程服务器端发送请求，获取目标网页的HTML文件；然后跟踪这个链接文件，获取文件数据。各种搜索引擎就是通过爬虫技术来实现网页数据更新，爬取的效率直接决定了搜索的效果。
根据流程图可以看到，爬虫的流程与用户浏览网页的过程相似，首先输入目标URL地址，向服务器发送请求，接着服务器端会返回包含大量链接的HTML文件，然后提取这些链接将其组成URL列表，通过串行或并行方式从服务器端中下载数据。
由于基础数据集中类别数量不均衡，所以本设计使用网络爬虫方式从百度图库对数量较少的类别进行数据扩充，首先输入想要爬取的图片名称关键字，然后输入想要爬取图片的数量以及存放的文件夹之后，进行图片爬取。
5 垃圾图像分类 5.1 迁移学习 5.1.1 什么是迁移学习？ 迁移学习是指在一个数据集上，重新利用之前已经训练过的卷积神经网络，并将其迁移到另外的数据集上。
5.1.2 为什么要迁移学习？ 卷积神经网络前面的层提取的是图像的纹理、色彩等特征，而越靠近网络后端，提取的特征就会越高级、抽象。所以常用的微调方法是，保持网络中其他参数不变，只修改预训练网络的最后几层，最后几层的参数在新数据集上重新训练得到。其他层的参数保持不变，作为特征提取器，之后再使用较小的学习率训练整个网络。因为从零开始训练整个卷积网络是非常困难的，而且要花费大量的时间以及计算资源，所以采取迁移学习的方式是一种有效策略。
通常在非常大的数据集上对ConvNet进行预训练，然后将ConvNet用作初始化或者是固定特征提取器，以下是两个主要的迁移学习方法：
1.微调卷积网络。使用预训练的网络来初始化网络而不使用随机初始化，比较常用的方法是使用在ImageNet数据集上训练好的模型参数进行初始化，然后训练自己的数据集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a302fe8a1c20e9f83fa31ca9595381f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af42d8927b00cf89c6c7b4c30e6af1c0/" rel="bookmark">
			常用的xpath合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的匹配逻辑 精确匹配：= 示例
匹配label的innerText值为123的标签
'//label[text()="123"]'
模糊匹配：: 示例
匹配label的innerText值包含456的标签
'//label[text():"456"]'
开头匹配：^ 示例
匹配label的innerText值以00开头的标签
'//label[text()^"00"]'
结尾匹配：$ 示例
匹配label的innerText值以99开头的标签
'//label[text()$"99"]'
常用的查找语法 id查找：# 示例
查找label的id属性为123的标签
'//label[#id=123]'
class查找：. 示例
查找label的class属性为123的标签
'//label[.=123]'
属性查找：@ 示例
查找label的属性名是data-value,值为为123的标签
'//label[@data-value=123]'
多属性查找：@@ 示例
查找label的属性名是data-value,值为为123；属性名是data-text,值为为456的标签
'//label[@@data-value=123@@data-text=456]'
扩展语法 包含文本 contain(查找语法,"具体的值")
示例
查找input的innerText包含123的标签
’//input[contain(text(),"123")]‘
过滤文本前后空值 normalize-space(text())
示例
查找input的innerText去除前后空格后等于123的标签
’//input[normalize-space(text())="123"]‘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f16b3017c3fb2a3e83d06a3bf4e8929/" rel="bookmark">
			Grafana告警发送至飞书配置指定at某人或所有人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述 通过webhook向飞书机器人发送消息，根据飞书机器人官方文档，始终无法指定某个人或者所有人通知，后来发现是文档参数有问题。
文档地址：https://open.feishu.cn/document/client-docs/bot-v3/add-custom-bot
官方文档给出的文本消息的 @ 用法
// @ 单个用户 &lt;at user_id="ou_xxx"&gt;名字&lt;/at&gt; // @ 所有人 &lt;at user_id="all"&gt;所有人&lt;/at&gt; // @ 单个用户时，user_id字段需填入用户的 Open ID 或 User ID，且必须是有效值（仅支持 @ 自定义机器人所在群的群成员），否则取名字展示，并不产生实际的 @ 效果。 // @ 所有人：必须满足所在群开启 @ 所有人功能。 实测不能发出
2.问题解决 后来找到官方答疑：https://www.feishu.cn/hc/zh-CN/articles/131324417719-%E9%A3%9E%E4%B9%A6%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98
名称语法效果注意事项加粗**粗体** 粗体斜体*斜体* 斜体删除线~~删除线~~删除线文本颜色&lt;font color='green'&gt; 绿色文本 &lt;/font&gt; &lt;font color='red'&gt; 红色文本 &lt;/font&gt; &lt;font color='grey'&gt; 灰色文本 &lt;/font&gt;绿色文本红色文本灰色文本@指定人&lt;at id=open_id&gt;&lt;/at&gt;&lt;at id=user_id&gt;&lt;/at&gt;&lt;at email=test@email.com&gt;&lt;/at&gt;@用户名@所有人&lt;at id=all&gt;&lt;/at&gt;@所有人At 所有人需要群主开启权限，若未开启，卡片发送失败超链接&lt;ahref='https://botbuilder.feishu.cn/home'&gt;&lt;/a&gt;https://botbuilder.feishu.cn/home超链接必须包含 schema 才能生效，目前仅支持：https、http文字链接[飞书机器人助手](https://botbuilder.feishu.cn/home) 飞书机器人助手`超链接必须包含 schema 才能生效，目前仅支持：https、http // @所有人需要配置参数如下方可 &lt;at id=all&gt; // @某人 &lt;at id=open_id&gt; 3.open_id查询 飞书的webhook目前不支持邮箱at某人，只能制定open_id或者user_id，查询方式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f16b3017c3fb2a3e83d06a3bf4e8929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5156ca47f25b93ca62ed92b628282e/" rel="bookmark">
			Spring Task之定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：这里可以添加系列文章的所有文章的目录，目录需要自己手动添加
Spring Task之定时任务
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、什么是Spring Task使用 Spring Task 的优势Spring Task 的核心概念和组件 二、Spring Task_Cron表达式三、Spring Task_Cron案例四、定时任务的使用五、@Scheduled的使用六、多线程任务总结 前言 提示：这里可以添加本文要记录的大概内容：
在软件开发中，定时任务是非常常见的需求。它们允许我们在预定的时间或间隔内自动执行某些特定的操作，如数据备份、文件清理、报表生成等。而 Spring Task 就是 Spring 框架提供的一个强大工具，用于简化定时任务的开发和管理。
通过 Spring Task，我们可以轻松地定义、配置和执行定时任务，无需关心复杂的线程管理和调度细节。它提供了灵活的任务执行机制，可以根据需求设置任务的执行时间、频率以及执行的逻辑。
在这篇博客中，我将深入探讨 Spring Task 之定时任务的相关概念和特性。我们将了解如何使用 Spring Task 来创建定时任务、配置任务执行的时间和频率，以及如何处理任务执行过程中的异常情况。
无论你是 Spring 框架的新手还是有经验的开发者，我相信这篇博客都将为你提供有价值的信息和实用的技巧。让我们一起探索 Spring Task 的世界，掌握定时任务的开发技能，为我们的项目增添自动化的魅力！
准备好开始了吗？让我们一起踏上这段定时任务的探索之旅吧！
提示：以下是本篇文章正文内容，下面案例可供参考
一、什么是Spring Task Spring Task是Spring框架提供的一种任务调度和异步处理的解决方案。它可以帮助开发者在Spring应用中轻松地实现定时任务、异步任务等功能，提高应用的效率和可维护性。
Spring Task的主要特点包括：简单易用、内置支持、灵活的任务调度、异步任务支持以及集成注解和监控管理。它提供了简洁的注解和配置方式，使得任务调度和异步处理变得容易上手。同时，Spring Task还支持基于cron表达式的定时任务调度，能够满足各种复杂的调度需求。
使用 Spring Task 的优势 提供了简单而强大的注解和配置方式，简化了定时任务的创建和管理。集成了 Spring 的依赖注入功能，使得任务可以方便地获取其他服务和资源。支持任务的灵活调度，包括执行时间、重复间隔等。 Spring Task 的核心概念和组件 @EnableScheduling：启用定时任务支持的注解，通常配置在定时任务的配置类上。@Scheduled：用于注解定时任务方法，指定任务的执行时间和重复规则。TaskExecutor：任务执行器，负责执行定时任务的具体逻辑。 二、Spring Task_Cron表达式 Spring Task依靠Cron表达式配置定时规则。Cron表达式是一个字符串，分为6或7个域，每一个域代表一个含义，以空格隔开。有如下两种语法格式：
Seconds Minutes Hours DayofMonth Month DayofWeek YearSeconds Minutes Hours DayofMonth Month DayofWeek 每一个域可出现的字符如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee5156ca47f25b93ca62ed92b628282e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703b526f1a0b6da16873cad601578bc6/" rel="bookmark">
			数据中快速查找和提取的强大工具 JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON（JavaScript Object Notation）在现代应用程序中广泛使用，但是如何在复杂的JSON数据中 查找和提取所需的信息呢？JSONPath是一种功能强大的查询语言，可以通过简单的表达式来快速准确地定位和提取JSON数据。本文将介绍JSONPath的基本语法和用法，并为您展示如何封装和使用JSONPath方法来处理和操作JSON数据。
随着互联网和移动应用的高度发展，JSON已成为一种常见的数据交换格式。在处理JSON数据时，经常需要从复杂结构中提取特定的值或对象。传统的遍历和条件语句方法可能显得繁琐且低效。 JSONPath提供了一种更简洁、灵活和高效的方式来查询、定位和提取JSON数据中的内容。
01、JSONPath语法 JSONPath采用类似XPath的语法，使用表达式来描述所需的查询和操作。
以下是一些常用的JSONPath表达式示例：
$：表示根元素$.key：选择根元素下的指定键名的值$.*：选择根元素下的所有属性值$.array[*]：选择根元素中的数组的所有元素$.key[subkey]：选择根元素中的键名为key，子键名为subkey的值$.key[*].subkey：选择根元素中的键名为key的所有元素的子键名为subkey的值 过滤表达式：
JSONPath允许使用过滤表达式来筛选符合特定条件的元素。
以下是一些过滤表达式示例：
$.key[?(@.subkey == value)]：选择根元素中key为指定值且具有subkey并且值等于value的元素。$.array[?(@.value &gt; 10)]：选择根元素中值大于10的数组元素。 范围表达式：
JSONPath支持范围表达式来选择特定的元素范围。
以下是一些范围表达式示例：
$.array[start:end]：选择根元素中从start索引到end索引之间的数组元素。$.array[:end]：选择根元素中从开头到end索引之间的数组元素。$.array[start:]：选择根元素中从start索引到末尾的数组元素。 通配符表达式：
JSONPath提供通配符表达式来匹配多个键或数组元素。
以下是一些通配符表达式示例：
$.*：选择根元素下的所有键值对。$..key：选择根元素和所有子元素中的具有指定键名的值。 操作符表达式：
JSONPath支持许多操作符来进行比较和运算。
以下是一些操作符表达式示例：
$.key[?(@.value &gt; 10 &amp;&amp; @.value &lt; 20)]：选择根元素中值大于10且小于20的key。$.key[?(@.name =~ /pattern/)]：选择根元素中name符合正则表达式pattern的key。 02、封装JSONPath方法 为了更方便地使用JSONPath，我们可以封装一个方法来处理和操作JSON数据。
下面是一个Python的封装示例：
import json def jsonpath(expr, data): result = [] if expr.startswith("$."): expr = expr[2:] def rocess_data(expr, data): if isinstance(data, dict): for key,value in data.items(): if key == expr: result.append(value) elif isinstance(value, (dict, list)): process_data(expr, value) elif isinstance(data, list): for item in data: process_data(expr, item) try: json_data = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/703b526f1a0b6da16873cad601578bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d78487956f9a8d33ffa66150e8dbdb2/" rel="bookmark">
			高阶形状函数（线性应变杆）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了说明高阶元的概念，我们将从图10-14所示的三节点线性应变二次位移(和二次形状函数)开始。如图10-14所示为一个二次型等参杆单元(又称线性应变杆)，其节点坐标为x1、x2和x3。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792bf67909e478b31807f829a383e857/" rel="bookmark">
			【Linux驱动】Linux中断（二）—— 按键中断驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一篇已经在设备树的 gpio-led 节点中引入了中断信息，接下来将通过API来获取设备树中的中断信息。gpio-led 节点具体内容如下：
gpio-key0 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;pinctrl_gpio_keys&gt;; // pinctrl子系统配置电气属性 key-gpio = &lt;&amp;gpio1 18 GPIO_ACTIVE_HIGH&gt;; // gpio子系统进行引脚初始化 interrupt-parent = &lt;&amp;gpio1&gt;; // 中断类型为 gpio1 interrupts = &lt;18 IRQ_TYPE_EDGE_FALLING&gt;; // 中断引脚为 GPIO1_IO18，触发方式为下降沿 status = "okay"; }; 一、中断 API 1、获取中断信息 获取设备树中 interrupts 属性的信息有两种方式，一种是针对 gpio 的方式，另一种是比较通用的方式。最终获取到的都是中断号，这里的中断号和裸机开发时的中断号不一样，裸机开发我们是根据参考文档来获取中断号
而下面通过 API 获取到的中断号是经过映射的，类似于虚拟内存和物理内存的映射，这样做的目的是保护原中断号。这也是为什么后续获取到的中断号会与裸机开发时使用的中断号不一致。
gpio_to_irq
gpio_to_irq 是仅用于获取 gpio 中断相关信息，要求对应节点的父类中断控制器为 gpio，即 interrupt-parent 属性引用的是 gpio 控制器。该接口的声明在 &lt;asm/gpio.h&gt;，接口原型如下: #define gpio_to_irq	__gpio_to_irq /** * @ param gpio 表示根据gpio设备树节点获取到的 gpio 编号 * @ return 成功返回中断号，失败返回负值 */ int __gpio_to_irq(unsigned gpio); irq_of_parse_and_map
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792bf67909e478b31807f829a383e857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008c815246e59e39b6a43eeee35a4a12/" rel="bookmark">
			Linux引导过程和服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux操作系统引导过程 1.引导过程 bios 加电自检——mbr——grub——加载内核——启动进程
加电后BIOS程序回自检硬件，硬件无故障后，会根据第一次启动项去找内核，一般来说第一启动项是硬盘，找到硬盘后，会根据mbr指引找到完整的grub程序，再根据grub的配置文件找到内核文件具体位置，然后将内核文件加载到内存中运行内存加载好会启动第一个程序。
BIOS：检测硬件是否正常，然后根据BIOS中的启动项设置，去找内核文件
mbr：应为grub太大第一个扇区存不下所有的grub程序，所以分为两部分指引硬件找到内核文件
grub：根据grub配置文件中记录的位置，找到内核文件
加载内存：把内核运行在内存中
启动进程：启动第一个祖宗进程centos 6：init centos 7：systend
区别：
init :串行启动后续的程序一个一个按顺序启动
systemd: 是并行启动程序全部一起启动
二、服务排除启动类故障 2.1 systemd服务 systemd 是系统级的程序 代为管理系统上的服务程序
systemd 保姆级 yum以及rpm安装的软件可以直接使用systemctl去启动关闭，重启开机自启等功能编译安装，不可直接使用systemctl 命令去管理程序，需手写一个配置文件
2.2 Linux设置运行级别 格式：init 数字 runlevel 当前等级
Linux操作系统有运行级别
0：关机
1：单用户模式(root自动登录), single, 维护模式
2：多用户模式，启动网络功能，但不会启动NFS；维护模式
3：多用户模式，正常模式；文本界面
4：预留级别；可同3级别
5：多用户模式，正常模式；图形界面
6：重启
2.3 修复mbr分区 MBR位于第一块硬盘（/dev/sda）的第一个物理扇区处，总共512字节，前446个字节是GRUB程序，后面64个字节是分区表。
故障原因 病毒、木马的等造成的破坏；
不正确的分区操作、磁盘读写误操作等。
故障现象
找不到引导程序，启动中断；
无法加载操作系统，开机后黑屏
①备份mbr引导扇区到其他磁盘
②模拟破坏mbr引导扇区
③引导镜像急救模式进行mbr扇区恢复
练习1：模拟破坏mbr和分区表然后修复
第一步：新加一块硬盘，将文件备份到新盘
第二步：备份mbr分区表
第三步：模拟破坏
然后进入急救模式:选项3、2、1 再重启，就好了
ip a a 192.168.100.100 dev ens33 配置IP地址 scp 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/008c815246e59e39b6a43eeee35a4a12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc651122a1bcf8014fbb989bccb976a/" rel="bookmark">
			AE （4）_ 直方图调整的理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#灵感# 在短暂的高通平台调试中，很看重直方图调整的理解。后来其它平台，不怎么调整这个了。但还是记录一下。 我个人还是倾向 招式简单，但应用到极致。
绝大部分内容来自：刘斯宁，Image Enhancement - CLAHE - 知乎 (zhihu.com)
穿插个人的部分理解。
目录
英文解释：
对比度：
简单---对比度拉伸：
升级---直方图均衡化 HE：
直方图均衡的局限：
改进---自适应直方图均衡化（AHE）：
高通平台的直方图调整---好像不一样：
另个平台的直方图-----只是参与亮度计算：
英文解释： A histogram is a type of graph that has wide applications in statistics. Histograms provide a visual interpretation of numerical data by indicating the number of data points that lie within a range of values. These ranges of values are called classes or bins. The frequency of the data that falls in each class is depicted by the use of a bar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dc651122a1bcf8014fbb989bccb976a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6cffeddfff127a1588cfcab446e93da/" rel="bookmark">
			CSS免费在线字体格式转换器 CSS @font-face 生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天竟意外发现的一款免费的“网页字体生成器”，功能强大又好用~
工具地址：https://transfonter.org/
根据你设置生成后的文件预览：
支持TTF、OTF、WOFF、WOFF2 或 SVG字体格式转换生成，每个文件最大15MB。转换完成以后还会生成一个在线demo页面直接预览字体效果不过只有英文的，总的来说满足了我所有的需求。
好工具值得推荐和拥有🤗
最后，附上其他转换工具：
工具地址：https://kombu.kanejaku.org/
源码地址：https://github.com/bashi/kombu
推荐一篇文章供大家参考：CSS3 使用@font-face引入字体的兼容性方案及优化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49443bf54fb808aefc89abc0e3b195d4/" rel="bookmark">
			MybatisPlus—利用IService实现业务接口练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		练习：实现以下接口
代码目录
实体
Po实体
vo实体
DTO实体
Controller层代码
Service接口
Service接口实现类
Mapper层
实体 Po实体 package com.itheima.mp.domain.po; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import lombok.Data; import java.time.LocalDateTime; @Data @TableName("tb_user") public class User { @TableId(type= IdType.AUTO) private Long id; /** * 用户名 */ @TableField("`username`") private String username; /** * 密码 */ private String password; /** * 注册手机号 */ private String phone; /** * 详细信息 */ private String info; /** * 使用状态（1正常 2冻结） */ private Integer status; /** * 账户余额 */ private Integer balance; /** * 创建时间 */ private LocalDateTime createTime; /** * 更新时间 */ private LocalDateTime updateTime; } vo实体 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49443bf54fb808aefc89abc0e3b195d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15ee4e8b550f14d5baae72ebeebaf1f/" rel="bookmark">
			Linux第3步_安装Ubuntu操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建好虚拟机后，就可以安装Ubuntu操作系统了。
1、双击“VMware Workstation Pro”，得到下面的界面。
2、点击“编辑虚拟机设置”，见下图：
3、等几秒钟，得到下面的界面：
4、点击“CD/DVD”，得到下图：
5、选择“使用ISO映像文件(M)”，见下图：
6、点击“浏览”，选择“ubuntu-18.04.5-desktop-amd64.iso Archive”，见下图：
6、点击“打开”，得到下图：
7、点击“确定”，这时ubuntu-18.04.5-desktop-amd64.iso Archive处于安装准备状态。
8、打开“虚拟机”，点击“开启此虚拟机”，就可以执行自动安装。
9、等待出现“选择语言”，见下图：
10、点击“English”，然后拖动滑块，就可以选择“中文简体”。见下图：
11、点击“安装Ubuntu”，得到下图：
12、点击“继续”，得到下图：
13、不勾选“安装Ubuntu时下载更新”，不勾选“为图形和无先硬件安装第3方软件”。
14、选择“清除整个磁盘并安装Ubuntu”，其他不选择，点击“继续”，得到下图：
15、点击“现在安装”，得到下图：
16、点击“继续”，等待几分钟，得到下图：
17、输入合肥的拼音“Hefei”，见下图：
18、点击“继续”，得到下图：
19、输入姓名:zgq，用户名:zgq，密码：123456。名字要简洁，后面要用到，太长了，你会后悔的。
20、点击“继续”，等待1分钟，得到下图：
21、安装完成得到下面的界面：
22、点击“现在重启”
23、设置虚拟机关机，得到下图：
24、点击“编辑虚拟机设置”
25、选择“CD/DVD（SATA）”,得到下图：
26、勾选“使用物理驱动器”，见下图选择：
27、点击“确定”
28、点击“开启此虚拟机”，启动完成后，得到下图：
29、点击“zgq”,得到下图：
30、输入密码“123456”，点击“登录”，得到下图：
31、点击“前进”
32、点击“前进”
33、点击“完成
34、点击“编辑”，见下图：
35、点击“首选项”，见下图：
36、点击上图中的“更新”
37、去掉勾选“启动检测产品更新”，保证Ubantu的版本不变，见下图：
38、点击“确定”。
至此，Ubuntu操作系统安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e35db72981fac763debd281550be3d/" rel="bookmark">
			企业新媒体运营年度回顾与总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元旦已过，在一年伊始的关键节点上，相信很多企业还忙着收尾上一年的工作，准备年终复盘。
但是，可能还有企业不清楚新媒体年终复盘该怎么搞？
想要做好复盘，一开始就要围绕着企业目标确定好复盘的方向，通过收集并分析运营关键数据，发现问题，总结经验，才能实现以数据驱动运营策略，为决策作指导。
本文基于不同企业使用「企业年度回顾」的需求，整理了三种复盘方向，希望能为大家带来一些启发。
快速开启企业年终高效复盘→
证券公司利用账号/作品年度榜单
了解新媒体团队运营水平
该证券公司的战略目标是要将企业矩阵账号做到金融领域的头部。
在各项指标中，他们尤其关注的数据指标是粉丝量、阅读曝光、账号综合指标，基于此，该证券公司通过「企业年度回顾」生成年榜。
账号能力榜以账号综合指数排名，展示新媒体发展成绩；账号影响力榜通过粉丝数排名，帮助企业发现优质账号，明确各账号价值；作品传播榜以阅读曝光为维度，发现年度优质内容。
该公司通过年榜明确新媒体发展现状，展现各账号、团队运营水平，便于他们激励员工，优化内部资源分配，发展优势账号，助力最终目标的实现。
▲矩阵通制图
商业银行通过年度报表和分析报告
轻松完成新媒体年度总结汇报
在矩阵通推出「企业年度回顾」后，一家商业银行找上我们，希望能帮助他们做新媒体年度总结汇报。
他们在抖音、小红书、公众号、视频号等七个主流平台，拥有200多个账号，这么多账号进行年度数据汇总，对他们来说是一个负担。
而我们根据提供的账号名单自动生成了账号年度数据报表，通过增量和总量数据展示账号整体运营趋势，此外还提供运营分析报告，帮助企业识别优劣势平台，分析内容策略，提供运营策略和建议。
这些内容均支持一键导出，让该企业轻松快速地完成内部总结汇报，实现对一年新媒体运营成果更加完善全面的复盘。
▲矩阵通制图
科技软件公司获取账号全年明细数据
实现自定义数据分析和总结
该公司基于年底管理要求，需要回溯在抖音、小红书等七个平台所有账号过去一年的明细数据，详细分析账号的运营情况，明确重点账号和潜力账号。
他们在各大平台上账号数量总计50个左右。
如果通过人工统计汇总，费时费力且准确性难以得到保证，一旦数据准确性无法保证，那这份数据汇总带来的指导意义就不大了。
最终他们通过「企业年度回顾」一次性获取2023年全年的作品列表、表现数据及账号最新数据，实现账号管理优化，并根据数据发现优质内容方向，提升账号内容运营策略。
▲矩阵通制图
不同的企业需要根据复盘目的、业务目标等确定新媒体年终复盘方向。
为了更好地帮助企业全面复盘新媒体，「企业年度回顾」包含4个模块：①获取账号全年数据、②打造企业年度榜单、③生成年度数据报表、④提供运营复盘报告，产出的所有资料均可直接复用，助力企业年终汇报总结。
想快速完成年终汇报，准确又高效地对企业新媒体全年运营情况、发展水平进行全面深入地分析，请点击下方按钮，帮助您高效完成运营复盘。
「企业年度回顾」由矩阵通出品，矩阵通是新榜旗下的新媒体数字化内容资产管理SaaS，能帮助企业集中管理跨平台矩阵账号，完成数据回收、报表分析、内容沉淀与分发、竞对监测、风险监管、用户线索挖掘等。
如果您有跨平台、多账号运营需求，欢迎百度搜索「新榜矩阵通」或前往矩阵通官网体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd50cbdcf55e51148e60439738aea18/" rel="bookmark">
			实时记录和查看Apache 日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache 是一个开源的、广泛使用的、跨平台的 Web 服务器，保护 Apache Web 服务器平台在很大程度上取决于监控其上发生的活动和事件，监视 Apache Web 服务器的最佳方法之一是收集和分析其访问日志文件。
Apache 访问日志提供了有关用户如何与您的网站交互以及 Apache 服务器如何处理用户请求和响应的见解，这些日志存储在本地磁盘上，为了有效地分析访问日志，您需要集中存储、处理和分析它们。
Apache 日志有哪些不同类型 有两种类型的 Apache 日志：
访问日志：Apache 访问日志包含 Web 服务器信息，例如进入特定 Web 服务器的请求数量、服务器响应所需的时间、访问者查看的页面类型以及这些请求的成功状态。错误日志：Apache 错误日志包含处理用户 Web 请求的错误信息，包括未找到的文件和服务器诊断。 Apache 日志是有关 Web 服务器性能指标、流量错误以及用户如何访问您的网站并与之交互的重要信息来源，这些错误日志在识别和排查事件的根本原因方面起着至关重要的作用。
Apache 日志记录 维护系统和网络的健康和稳定性需要始终提供有关网络操作的连续信息流。日志记录构成了这些过程的支柱。日志使用户和 IT 管理员能够在指定事件之前和之后访问重要的系统信息，从而帮助评估和诊断根本原因。
Apache 日志大致可分为访问日志和错误日志。虽然访问日志记录有关向 Apache 服务器发出的请求的信息，但错误日志记录了由服务器或服务器上的应用程序引起的问题和异常。Apache 附带了一些指令和模块，可用于修剪日志消息并通过将它们上下文化来提高其质量。Apache 指令是可以输入到配置文件中的规则，Apache 模块是加载时扩展 Apache 功能的代码文件。模块不驻留在配置文件中。
制定 Apache 日志记录策略对于在不威胁整体系统性能的情况下生成无噪音且可用的日志数据非常重要。
Apache 日志记录的最佳实践 选择正确的 Apache 日志格式使用 Apache 条件日志记录减少噪音改进了 Apache 日志级别的分析和存储使用 Apache 日志取证模块增强安全性实施 Apache 日志轮换以实现高效的资源管理 选择正确的 Apache 日志格式 组织可能具有内部策略或合规性要求，用于指定其 Web 服务器的日志记录格式和保留策略。在这种情况下，管理员将不得不放弃默认的通用日志格式来捕获必要的数据。可以使用指令修改 Apache 的日志记录行为。指令还可以启用日志设置的全局或定向应用。LogFormat 就是这样一种支持日志格式修改的指令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd50cbdcf55e51148e60439738aea18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b110dcef8bb1ddf54137d7c7f7d896e6/" rel="bookmark">
			C#进制--2进制、10进制、16进制(Modbus通讯部分)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：最近接触了一些通讯方面信息，写个小结记录一下，即时更新 1.二进制数： 是计算技术中经常采用的一种数制。二进制数据是由0和1两个基本数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。
2.十进制数： 是组成以10为进位单位基础的数字系统，是以0，1，2，3， 4， 5， 6， 7， 8， 9十个基本数字组成。十进制计数是由印度教教徒在1500年前发明的，由阿拉伯人传承至11世纪。
3.十六进制（简写为hex或下标16） 是一种基数为16的计数系统，是一种逢16进1的进位制。通常用数字0、1、2、3、4、5、6、7、8、9和字母A、B、C、D、E、F（a(10)、b(11)、c(12)、d(13)、e(14)、f(15)）表示，其中:A~F表示10~15，这些称作十六进制数字。
4.补充关于Modbus中的16进制数据传输 0x06：表示的是一个8位(1byte-一个字节)的十六进制数，也就是二进制的00000110。
在C#中，0x前缀表示接下来的数字是十六进制表示。因此，0x06就是十进制数6的十六进制表示。
进制表示如下：
data = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x04, 0x00, 0x48, 0x00, 0x06 };
newclient.Send(data);
中的{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x04, 0x00, 0x48, 0x00, 0x06 }
转换为十进制表示为：
{ 0, 0, 0, 0, 0, 6, 1, 4, 0, 72, 0, 6 }
255：十六进制表示 0xff
0： 十六进制表示 0x00
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b110dcef8bb1ddf54137d7c7f7d896e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ecf55d0b1bf696b7a320ece91bda9d/" rel="bookmark">
			批量生成datax同步JSON（mysql到doris）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述 使用datax同步mysql数据到doris，表的数量过多，写datax的配置文件很麻烦。鉴于此，编写了一个datax的配置文件生成脚本，可以灵活的实现一键生成配置文件，提高生产效率。
废话不多说，脚本如下
2.问题解决 vim gen_import_mysql_config_simple.py # coding=utf-8 import json import getopt import os import sys import MySQLdb #MySQL相关配置，需根据实际情况作出修改 mysql_host = "xxx" mysql_port = "xxx" mysql_user = "xxx" mysql_passwd = "xxx" #HDFS NameNode相关配置，需根据实际情况作出修改 doris_host = "xxx" doris_port = "xxx" doris_http_port = "xxx" doris_user = "xxx" doris_passwd = "xxx" condition = True #生成配置文件的目标路径，可根据实际情况作出修改 output_path = "/data/job" def get_connection(): return MySQLdb.connect(host=mysql_host, port=int(mysql_port), user=mysql_user, passwd=mysql_passwd) def get_mysql_meta(database, table): connection = get_connection() cursor = connection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8ecf55d0b1bf696b7a320ece91bda9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aec5431174d9ee8aa3848c77e36ea12/" rel="bookmark">
			ruoyi-ai 基于ruoyi-plus实现AI聊天和绘画功能-后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于ruoyi-plus实现AI聊天和绘画功能-后端
本项目完全开源免费！ 后台管理界面使用elementUI服务端使用Java17+SpringBoot3.X
ruoyi-ai: 基于ruoyi-plus实现AI聊天和绘画功能-后端
实现功能
集成OpenAi API (gpt-4-vision-preview + dall-e-3)接入文生图模型（MidJourney / Stable Diffusion Model）支持微信小程序: ruoyi-uniapp: 基于ruoyi-plus实现AI聊天和绘画功能-小程序已接入易支付 测试功能: 私有知识库
项目地址
后端: https://gitee.com/ageerle/ruoyi-ai小程序端: https://gitee.com/ageerle/ruoyi-uniapp前端-后台管理: https://gitee.com/ageerle/ruoyi-admin前端-用户端: https://gitee.com/ageerle/ruoyi-web演示地址: web.pandarobot.chat 小程序演示 PC端演示 写作助手&amp;思维导图 私有知识库管理（开发中） 进群学习 参考项目 https://github.com/Grt1228/chatgpt-javahttps://gitee.com/dromara/RuoYi-Vue-Plushttps://github.com/hncboy/ai-beehive 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3664bc3d94c68a78cc861cd51bed091/" rel="bookmark">
			源启行业AI平台 银行智能业务的驱动引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI技术已经深入金融行业，在营销、渠道、风控等领域广泛应用，但人工智能开发与应用面临成本高、难度大、门槛高、重复建设、无统一管理复用AI模型资产等问题，这些问题也正是源启AI行业平台要解决的。
源启行业AI平台定位为“企业级AI能力的集中化生产和运营平台”，提供全链路端到端AI算法开发和服务管理能力。借助此平台，开发人员可以实现模型的规模化开发，总部可以对模型和资源的进行统一管理，业务部门可以共享调用各种应用的AI服务。截至目前，源启行业AI平台已经在30多家金融机构、5家非金融客户落地应用，基于此平台开发和上线模型数达500个以上。
源启行业AI平台有哪些功能优势？如何赋能银行业务场景？中电金信研究院副院长、人工智能实验室主任单海军对源启行业AI平台做了更详细的介绍，可点击图片观看视频。
应用背景
以金融机构为代表的行业客户已从信息化、数据化全面迈向智能化。金融机构需要从企业全局视角布局全面的智能化升级，向上支撑业务战略，因此金融机构需要统一的智能底座平台，用于企业内生产和管理各类AI算法，提供从数据处理、算法开发、模型训练、模型部署到模型管理等功能，成为企业智能化的发动机。源启行业AI平台针对人工智能技术研发门槛高、周期长、落地难等问题，采用全新前沿技术，打造全链路端到端AI算法开发套件和工具，降低复杂模型开发难度，提升开发效率，为行业提供针对性、可信的AI算力。
功能介绍
源启行业AI平台提供AI服务平台、AI开发平台、AI计算框架、AI算力平台、AI安全中心五大功能模块。
· 功能特色一：精细化的智能算力集群管理
· 功能特色二：普惠化的AI开发能力
· 功能特色三：随用随取-AI模型服务编排
· 功能特色四：安全的AI服务
案例场景
· 应用场景一：利用行业AI平台构建智能视觉技术，赋能银行信贷业务下沉
· 应用场景二：利用行业AI平台构建OCR技术，赋能金融单据自动识别
· 应用场景三：利用行业AI平台构建NLP模型，提升文档处理能力
· 应用场景四：利用行业AI平台构建数据分析模型，支持银行营销智能化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe44bc99571fedeb47a60682c0168e5/" rel="bookmark">
			安装、配置并使用atop监控工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云原文
1、sudo yum install atop
报错的话执行：
dnf install epel-release
dnf install atop
2、sudo vim /etc/sysconfig/atop
3、修改以下配置。
LOGINTERVAL：监控周期，建议将默认的监控周期600s修改为30s。
LOGGENERATIONS：日志保留时间，为避免atop长时间运行占用太多磁盘空间，建议将默认的日志保留时间28天修改为7天。
LOGOPTS="" LOGINTERVAL=30 LOGGENERATIONS=7 LOGPATH=/var/log/atop 4、sudo systemctl restart atop
5、atop -r /var/log/atop/atop_2023XXXX
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61bd7eaf8d2ee0edbcb5877b77c7e76/" rel="bookmark">
			HarmonyOS应用开发之DevEco Studio安装与初次使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、DevEco Studio介绍 DevEco Studio是基于IntelliJ IDEA Community开源版本打造，面向华为终端全场景多设备的一站式集成开发环境（IDE），为开发者提供工程模板创建、开发、编译、调试、发布等E2E的HarmonyOS应用/服务的开发工具。
2、DevEco Studio安装步骤 进入官网下载对应系统版本的DevEco Studio：HUAWEI DevEco Studio和SDK下载和升级 | 华为开发者联盟 解压后得到exe安装文件 双击exe文件开始安装选择要安装的目录，尽量不要安装在C盘 勾选创建图标到桌面，勾选将bin目录安装到path环境变量，然后点击Next 点击Install继续安装 安装完成后会要求重启才能使用软件，可以选择立刻重启，也可以选择之后重启 3、DevEco Studio初次使用 重启电脑后双击运行DevEco Studio后，点击Agree 选择开发工具的一些设置，如果没有就默认选择Do not import settings，然后点击OK 接下来是要求安装node.js，如果系统已经安装，会默认选择Local，并且选择对应的文件位置；没有安装则选择Install会默认安装对应版本，并且可以指定安装目录。 接下来是Ohpm setup from 鸿蒙的包管理系统，需要依赖一些第三方库，一般都没有的，要选择Install安装 接下来要安装一个HarmonyOS的SDK，选择安装目录后点击Next 进入到协议选择页面，全部选Accept，然后点击Next 来到确认页面，继续点击Next，就开始去下载所有的依赖了 等待下载页面完成，会需要等待一些时间 安装完成后选择Finish，进入到开发工具界面。 说明：接下来是检查SDK是否全部安装成功，如果安装过程出现SDK没有安装成功，需要执行下面的步骤继续安装；
选择Help，点击第一个出现SDK相关界面 如果存在安装失败的SDK，会给出提示信息，并且出现一个Fix按钮，点击重新下载即可；全都是绿色的勾说明安装成功。 关于DevEco Studio更为详细和全面的操作，可以去看官方文档的操作指南： 文档中心
4、创建第一个Hello World项目 选择Create Project按钮 选择项目的模板，选择一个空的模板，点击Next 来到项目的信息填写界面，项目名、目录结构、文件路径等，基本都可以走默认；点击Finish后就只需等待项目创建完毕 接下来是到了代码界面； 点击右侧的Previewer按钮，关闭Tutorial教程后，即可看到初始项目Hello World的运行效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/126c285ea1e6573f58db609156a916cf/" rel="bookmark">
			5G工业物联网网关：连接未来的智能工业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数字化时代，工业物联网正迅速崛起，并引领着全球工业的数字转型。而5G工业物联网网关作为实现IIoT的关键基础设施，在连接未来的智能工业中发挥着举足轻重的作用。
什么是5G工业物联网网关
5G工业物联网网关是连接工业设备和5G网络的关键枢纽，它充当着数据采集、传输、处理和管理的桥梁。通过与各种传感器、终端设备、计算机和云平台的连接，5G工业物联网网关实现了工业设备之间和设备与云平台之间的高效通信与数据交互。它的出现将加速工业自动化、智能化和数字化的进程，为工业企业提供更高效、安全和可靠的运营环境。
5G工业物联网网关的特点是什么
首先，5G工业物联网网关具备高速、低延迟和大容量的特点。借助5G网络的优势，它能够实现毫秒级的数据传输和响应，满足工业生产中对实时性和即时性的要求。其次，5G工业物联网网关拥有高可靠性和高安全性。通过采用多重备份、容错机制和加密算法，它能够保证数据的可靠性和隐私的安全性。此外，5G工业物联网网关还具备灵活可扩展的特点，可以根据不同工业场景和需求进行定制化和升级优化。
5G工业物联网网关的应用场景有哪些
5G工业物联网网关在工业领域有着广泛的应用场景。首先，它可以用于工业设备的远程监控与维护。通过连接到5G网络，工程师可以远程实时监测设备运行状态、预测故障并做出相应的维护措施，大大提高了设备运行效率和可靠性。
其次，5G工业物联网网关在智能制造中扮演着重要角色。它可以实现设备之间的智能互联、工艺优化和生产调度优化，为企业提供全方位的智能化生产解决方案。
此外，5G工业物联网网关还可应用于智能物流、智能能源管理和智慧城市等领域，大幅度提升物流效率、节能减排和城市管理水平。
计讯物联5G/4G工业物联网网关，工业级设计，质量可靠性能稳定，通过各性能测试并取得emc测试报告，具备采集、边缘计算、传输、加密、控制等功能，丰富接口及协议库，支持各智能终端、传感器、自动化设备、视频监控等接入联网，建立前端设备与管理中心的数据通信，实现远程自动化、程序化、精准化监控及控制，适用于各物联网场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6df774f04f65e0a96704193ff9448b6/" rel="bookmark">
			C# 中英文及字符所占字节详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.C#中英文字符占用的空间大小 一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。
ASCII 码中，一个英文字母(不分大小写)为一个字节，一个中文汉字为两个字节。
UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。
Unicode 编码中，一个英文为一个字节，一个中文为两个字节(C#默认UniCode编码)。
符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号 。占2个字节的大小。
UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节(Unicode 扩展区的一些汉字存储需要 4 个字节)。
UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。
2.1M等于多少字节byte(1MB=1024(KB)*1024byte)--个byte--千K--兆M 1MB等于1048576字节。算法是: 1byte(字节)=8bit(位)，1KB=1024byte(字节)，1MB=1024KB，1GB=1024MB1TB=1024GB，一个汉字要占用2个字节，如果换算成中文汉字那么就是1M=524288个汉字
带宽的单位一般有两种表现形式;第一种是B/s、KB/s或MBs，表示单位时间(秒)内传输的数据量(字节、千字节、兆字节)，第二种是bps (或称b/s) 、Kbps (或称Kb/s) 或Mbps (或称Mb/s) ，表示单位时间(秒)内传输的数据量(比特、千比特、兆比特)。这两种带宽的换算公式是: B/s=8bps (b/s) 、1KB/s=8Kbps (Kb/s)1MB/s=8Mbps (Mb/s)
3.关于C#中Byte和byte区别 通过查询Java API 发现，Byte是类，byte是基本数据类型，准确来说Byte是byte的封装类。
因此Byte[ ]本身就不存在。而byte[ ]是字符类型的数组，可以用来存放数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c5c0fc7088b108fb450b658dd10bee/" rel="bookmark">
			如何从单应矩阵H中分解旋转矩阵R和平移向量t？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机视觉中，单应矩阵通常用于图像配准和相机标定等任务。下面是使用SVD分解单应矩阵来求解旋转矩阵（R）和平移向量（t）的简要推导过程。
假设求解得到一个单应矩阵H：
H = [ h 11 h 12 h 13 h 21 h 22 h 23 h 31 h 32 h 33 ] H = \begin{bmatrix} h_{11} &amp; h_{12} &amp; h_{13} \\ h_{21} &amp; h_{22} &amp; h_{23} \\ h_{31} &amp; h_{32} &amp; h_{33} \\ \end{bmatrix} H= ​h11​h21​h31​​h12​h22​h32​​h13​h23​h33​​ ​
单应矩阵H可以分解为旋转矩阵R和平移向量t。具体而言，我们可以将H表示为：
H = R + 1 d t N T H = R + \frac{1}{d}tN^T H=R+d1​tNT
其中， R R R是旋转矩阵， t t t是平移向量， d d d是尺度因子， N N N是一个3x3的上三角矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26c5c0fc7088b108fb450b658dd10bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097089dc4ed9d3bf88b8a7658cc44cca/" rel="bookmark">
			【面试高频算法解析】算法练习3 双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本专栏旨在通过分类学习算法，使您能够牢固掌握不同算法的理论要点。通过策略性地练习精选的经典题目，帮助您深度理解每种算法，避免出现刷了很多算法题，还是一知半解的状态
专栏导航 二分查找回溯双指针滑动窗口深度优先搜索广度优先搜索 算法解析 双指针技术是一种常用的算法策略，它使用两个指针以不同的速度或方向遍历数据结构（通常是线性结构如数组或链表），从而达到解决问题的目的。双指针技术可以帮助我们简化复杂度，减少不必要的运算，尤其是在解决一些与序列相关的问题时非常有效。
双指针通常有以下几种分类：
快慢指针：
快慢指针通常用于解决链表中的问题，例如检测链表中的循环。快指针每次移动两步，慢指针每次移动一步。如果链表中有循环，则快指针最终会追上慢指针。
左右指针：
左右指针通常用于有序数组或字符串，开始时一个指向头部（左指针），另一个指向尾部（右指针），然后向中间移动。例如在二分查找、合并两个有序数组或是计算一组数的对数（如两数之和）时会用到。
滑动窗口(面试中很常见我将另开一篇详细介绍)：
滑动窗口可以看作是一种特殊的双指针，通常用于解决数组/字符串的子区间问题。两个指针共同定义了一个窗口，可以增加或减少窗口的大小以满足特定条件，例如找出满足条件的最长/最短的子数组/子字符串。
双指针技术的优势在于它可以减少时间复杂度。例如，在排序数组中寻找两数之和等于特定值的问题中，暴力解法需要 O(n^2) 的时间复杂度，而使用双指针技术则可以降低到 O(n)。
下面是一个使用双指针（左右指针）解决“两数之和”问题的示例：
def two_sum_sorted(numbers, target): left, right = 0, len(numbers) - 1 while left &lt; right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] # 返回的是位置，不是索引 elif current_sum &lt; target: left += 1 # 和太小，移动左指针 else: right -= 1 # 和太大，移动右指针 return [-1, -1] # 如果没有找到，返回[-1, -1] 在这个函数中，左指针从数组的开始位置向右移动，右指针从数组的结束位置向左移动，直到找到两数之和等于目标值或左右指针相遇。通过这种方式，我们只需要遍历数组一次，从而提高了算法的效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/097089dc4ed9d3bf88b8a7658cc44cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2f10de8123b1032dde1b3be9f74903/" rel="bookmark">
			【Matlab】基于遗传算法优化BP神经网络 (GA-BP)的数据时序预测（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源下载： https://download.csdn.net/download/vvoennvv/88682033
资源合集： https://download.csdn.net/download/vvoennvv/88700669
目录 【Matlab】BP 神经网络时序预测算法
【Matlab】CNN卷积神经网络时序预测算法
【Matlab】ELM极限学习机时序预测算法
【Matlab】基于遗传算法优化BP神经网络 (GA-BP)的数据时序预测
【Matlab】LSTM长短期记忆神经网络时序预测算法
【Matlab】PSO-BP 基于粒子群算法优化BP神经网络的数据时序预测
【Matlab】RBF径向基神经网络时序预测算法
【Matlab】RF随机森林时序预测算法
【Matlab】SVM支持向量机时序预测算法
一，概述 基于遗传算法优化BP神经网络 (GA-BP) 的数据时序预测是一种常用的机器学习方法，用于预测时间序列数据的趋势和未来值。
在使用这种方法之前，需要将时间序列数据转化为适合BP神经网络处理的形式。常用的方法是将时间序列数据转化为滞后观测值的矩阵形式，以便将其作为BP神经网络的输入。
然后，使用遗传算法对BP神经网络的权重和阈值进行优化。遗传算法通过模拟自然选择和遗传机制，使用种群中的个体来表示网络权重和阈值的不同组合。通过计算每个个体的适应度，根据适应度选择和交叉繁殖优秀的个体，并引入变异操作以增加种群的多样性。这个过程通过多次迭代，逐步优化网络的权重和阈值，使其能够更好地拟合时间序列数据的特征和趋势。
最后，使用优化后的GA-BP神经网络进行数据时序预测。通过将过去的时间序列数据传递给网络，网络将根据优化后的权重和阈值进行计算，并预测未来的数值。优化后的网络能够更准确地捕捉时间序列数据中的趋势和周期性，并提供更精确的预测结果。
综上所述，基于遗传算法优化BP神经网络的数据时序预测方法能够结合遗传算法的优化能力和BP神经网络的非线性拟合能力，实现更准确和可靠的时间序列预测。这种方法在各种时间序列预测问题中都有广泛的应用，例如股票价格预测、气象数据预测等。
二，代码 代码中文注释非常清晰，按照示例数据修改格式，替换数据集即可运行，数据集为excel。
部分代码示例如下：
%% 清空环境变量 warning off % 关闭报警信息 close all % 关闭开启的图窗 clear % 清空变量 clc % 清空命令行 %% 导入数据（时间序列的单列数据） result = xlsread('数据集.xlsx'); %% 添加路径 addpath('goat\') %% 数据分析 num_samples = length(result); % 样本个数 kim = 15; % 延时步长（kim个历史数据作为自变量） zim = 1; % 跨zim个时间点进行预测 %% 构造数据集 for i = 1: num_samples - kim - zim + 1 res(i, :) = [reshape(result(i: i + kim - 1), 1, kim), result(i + kim + zim - 1)]; end %% 数据集分析 outdim = 1; % 最后一列为输出 num_size = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb2f10de8123b1032dde1b3be9f74903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1919c0e41a73a04f5a5f3092accaa5cf/" rel="bookmark">
			如何使用 Python&#43;selenium 进行 web 自动化测试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Selenium是一个自动化测试工具，它可以模拟用户在浏览器中的操作，比如点击、输入、选择等等。它支持多种浏览器，包括Chrome、Firefox、Safari等等，并且可以在多个平台上运行。
安装和配置Selenium 在使用Selenium之前，需要安装Selenium和相应的浏览器驱动程序。这里我们以Chrome浏览器为例，介绍如何安装和配置Selenium。
首先，我们需要安装Selenium库。可以通过以下命令来安装：
pip install selenium 接下来，我们需要下载Chrome浏览器驱动程序。可以从ChromeDriver官网 ↗上下载适合自己的版本。下载完成后，将驱动程序所在的路径添加到环境变量中。
from selenium import webdriver # 指定驱动程序 所在路径 driver_path = '/path/to/chromedriver' # 创建Chrome浏览器实例 browser = webdriver.Chrome(executable_path=driver_path) # 打开网页 browser.get("https://www.baidu.com") 上面的代码中，我们首先导入了webdriver模块，并指定了Chrome浏览器驱动程序所在的路径。接下来，我们创建了一个Chrome浏览器实例，并打开了百度首页。
模拟用户操作 接下来，我们将介绍如何使用Selenium模拟用户在浏览器中的操作。比如，我们可以使用Selenium来自动登录某个网站，或者自动填写表单等等。
点击元素 要点击一个元素，可以使用click()方法。比如，我们可以点击一个链接：
# 点击百度首页的新闻链接 news_link = browser.find_element_by_link_text("新闻") news_link.click() 上面的代码中，我们首先找到了百度首页中的新闻链接，然后使用click()方法来点击它。
输入文本 要输入文本，可以使用send_keys
()方法。比如，我们可以在搜索框
中输入关键字：
# 在百度搜索框中输入关键字 search_box = browser.find_element_by_id("kw") search_box.send_keys("Python") 上面的代码中，我们首先找到了百度搜索框，然后使用send_keys()方法来输入关键字。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：691998057【暗号：csdn999】 选择元素 有时候，我们需要从下拉列表或者单选框中选择一个选项。可以使用select()方法来实现这个功能。比如，我们可以选择一个下拉列表中的选项：
from selenium.webdriver.support.ui import Select # 选择一个下拉列表中的选项 select = Select(browser.find_element_by_name ("select")) select.select_by_value("value") 上面的代码中，我们首先找到了一个下拉列表，然后创建了一个Select对象。接下来，我们使用select_by_value
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1919c0e41a73a04f5a5f3092accaa5cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148d1bca4148ca770033f01d17a73413/" rel="bookmark">
			Jmeter 性能压测 —— 常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、怎么确定系统最大负载？
通过负载测试，不断增加用户数，随着用户数的增加，各项性能指标也会相应产生变化，当出现了性能拐点。
比如，当用户数达到某个数量级时，响应时间突然增长，那么这个拐点处对应的用户数就是系统能承载的最大用户数
2、系统哪些地方（哪些功能）做了性能测试？
选用了用户使用最频繁的功能来做测试。
比如：登陆，搜索，提交订单
3、并发用户数是怎么确定的？
会先上线一段时间，根据收集到的用户访问数据进行预估；
根据需求来确定，使用高峰时间段，注册用户数，单次响应时间等；
4、实现200用户的并发？
在脚本对应的请求后添加集合点(绝对并发)
相对并发：线程组设置200线程数
5、什么情况下要做关联，怎么做的？
当脚本的上下文有联系，就用关联。
比如登录token关联，增删改查主键id关联
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：691998057【暗号：csdn999】 6、有验证码的功能，做性能测试？
将验证码暂时屏蔽，完成性能测试后，再恢复；
使用万能的验证码；
7、性能测试做的是前台还是后台？
BS项目：测试的是后台服务器的性能和浏览器端性能
APP项目：手机端和服务器端的性能都做
8、如何脚本增强？
做参数化做关联添加事务添加断言添加集合点(jmeter的同步定时器)添加思考时间(jmeter的统一随机定时器和固定定时器) 9、怎么找到并发数、平均响应时间、TPS的最佳平衡点？
性能测试常用的指标有三个：并发、响应时间、TPS
并发：跑道里参加赛跑的人数（这里的并发是广义的并发，即同一个时间段内对系统发起的请求数量）响应时间：也就是平均每个事务的处理时间TPS：每秒处理的事务数 需求指标：分为单指标和多指标
单指标：一般是单测试tps，或者根据并发测试响应时间，或者根据响应时间测试并发，只考虑单指标的很少多指标：要同时考虑多个指标，比如tps + 响应时间(&lt;1s) 意思就是要找到这三个指标同时最佳值的点，即：不能只追求并发数大，而忽略TPS。
所以，这是一个多指标性能需求，假设是这样的：要求响应时间1秒以内，并发数要尽可能的多，TPS要尽可能的大。
先画一个简单的示意图，方便大家理解：
随着并发数增加，响应时间肯定是越来越高，所以，上面红线是响应时间；
随着并发数增加，tps是先升高到峰值，然后下降（也可能是一直平稳，或者平稳一段时间再下降），所以，上面蓝线是tps；
紫色表示并发用户数；
该怎么去找这个最佳平衡点呢？
①尽可能多的做不同并发数下的压测，记录下响应时间（1s以内）和最大TPS。
当然，服务器端，各个服务器的资源利用率在可接受范围内（每个公司不一样）
②然后根据获取到的不同并发下的指标数据（并发数、tps、响应时间），画出图，关注右侧的交点，即tps下降的地方和响应时间的交点，这个点的tps最大。
如果响应时间在1s以内，此时并发数也是比较大的，这个点就可以认为是三个指标都不错的平衡点（这里把tps放在第一位优先考虑了，这个就看大家最在乎哪个指标了，排个优先级）；
如果响应时间大于1s，最佳平衡点就往左找，找到响应时间为1秒的点，此时对应的tps和并发值，就是最佳平衡点。
总之，测试采样越多，获取的平衡点就越准确。
以上就是本次分享，有学习性能测试的伙伴有什么不清楚的，可以留言，看到了会及时回复！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b999bc2837ada13fe0c838f2b09dc375/" rel="bookmark">
			echarts环形图内接分类名称并且颜色名称颜色跟随变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家首先看一个echarts图，地址：圆环图自定义legend、设置默认选中 - category-work,legend,series-pie饼图,title标题 - makeapie echarts社区图表可视化案例
该图如下所示： 以上是采用echarts4.8.0绘制的，代码如下：
var color = [ '#0CD2E6', '#3751E6', '#FFC722', '#886EFF', '#008DEC', '#114C90', '#00BFA5', ]; var title = '自定义legend、默认选中'; var legend = [ 'A需求类型', 'B需求类型', 'C需求类型', 'D需求类型', 'E需求类型', '其他' ]; var seriesData = [ { "name": "A需求类型", "value": 30 }, { "name": "B需求类型", "value": 10 }, { "name": "C需求类型", "value": 15 }, { "name": "D需求类型", "value": 23 }, { "name": "E需求类型", "value": 10 }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b999bc2837ada13fe0c838f2b09dc375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5270651d54a0401f1482c76da783b3/" rel="bookmark">
			uni-ui 版本升级提示做个记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		appUpdate.js
var _maskView, _contentView, _downloadTask, _loadingProgress, _screenHeight, _screenWidth, _config = {
forceUpgrade: false,
titleText: "版本更新",
content: "",
contentAlign: "left",
loadingColor: "#329EEE",
cancelText: "暂不升级",
cancelColor: "#666",
confirmText: "立即升级",
confirmColor: "#329EEE",
windowHeight: 380,
packageUrl: "",
browser: false,
maskColor: "rgba(0,0,0,0.3)"
},
_calculatePosition = function() {
return {
top: (_screenHeight - _config.windowHeight) / 2,
left: _screenWidth * .05,
width: _screenWidth * .9,
right: _screenWidth * .05,
height: _config.windowHeight
}
},
_createMask = function() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5270651d54a0401f1482c76da783b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8eb3e879036167a6917ded5716603bb/" rel="bookmark">
			【Netapp数据恢复】Netapp存储lun被删除如何恢复数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Netapp存储数据恢复环境&amp;故障情况：
某单位一台Netapp存储，该Netapp存储内共有数十块SAS硬盘。
工作人员误操作删除了Netapp存储中12个lun，删除的数据包括客户信息和其他重要数据。
Netapp存储数据恢复过程：
1、将故障存储中所有磁盘编号后取出，硬件工程师经过检测没有发现存在硬件故障。以只读方式将所有磁盘进行扇区级全盘镜像。镜像完成后将所有磁盘按照编号还原到原存储中，后续的数据分析和数据恢复操作都基于镜像文件进行。避免对原始磁盘数据造成二次破坏。
2、基于镜像文件分析底层数据，找到盘头位置的超级块。
3、通过分析超级块获取磁盘组的起始块信息、磁盘组名称、逻辑组起始块号、raid编号等信息。
分析超级块：
校验块描述信息样例：
分析盘序表:
Netapp的节点分布在数量众多的数据块内，在数据块内又被统一组织为节点组。每个节点组的前64字节记录一些系统数据，用192字节为一项来记录各个文件节点。根据用户级别分为两类：“MBFP”系统文件节点和“MBFI”用户文件节点。
节点样例图：
4、根据更新序列值获取到最新节点。解析节点中节点类型、逻辑块号、文件数量、文件大小、所占块数量、数据指针，获取节点在节点文件中的逻辑块号。
5、获取目录项，并根据节点编号找到对应节点。
获取Netapp内对应节点：
6、使用北亚企安自主研发程序扫描节点信息。
扫描服务器节点信息：
节点扫描类：
节点扫描程序完整流程：
在循环扫描完毕之后将所有扫描到的MBFP、MBFI和DOC数据块分别写入到三个文件内。
7、将ScanNode扫描得到的MBFI和MBFP、Dir存入数据库。
MBFI导入数据库整体流程：
函数执行完毕后，查看数据库。
节点导入信息：
Netapp在更改inode节点时不会直接覆盖而是重新分配inode进行写入。单个文件的节点node_uid唯一不变，mbfi_usn会随着节点的变化而增大（正常情况下提取某个文件时使用usn值最大的节点）。一般情况下存储划分出的单个节点会作为LUN映射到服务器使用，根据file_size可以确定这个文件的大小，按照文件大小分组后再选取usn值最大的节点，跳转到MBFI文件的offset值偏移位置，取出节点。
节点样例图示：
8、在获取到要提取的文件的Node之后，开始提取块设备文件。
提取块设备文件：
初始化完毕后，开始提取文件的各级MAP。由于本次提取的文件大小均大于1T且MAP层级为4，所以需要提取4次。第一级MAP默认只占用1个块，所以在程序内直接提取，后三级MAP在GetAllMap函数内进行提取。通过块号计算数据块位置时，由于NetApp使用JBOD组织LVM，直接用块号除以每块磁盘上的块数可得到当前块所在的磁盘序号；再使用块号取余块数，得到数据块在此磁盘上的物理块号，物理块号乘以块大小，得到数据块偏移位置。
9、块设备lun使用的是aix小机的jfs2文件系统，解析jfs2文件系统并提取里面的数据库备份文件。
10、解析lvm。找到记录lvm描述信息的扇区，获取pv大小和pv序号；找到vg描述区，获取lv数和pv数；找到pv描述区，解析pp序号和pp数。
解析文件系统块信息：
LV类型及LV挂载信息区域：
11、解析8个1Tlun组成oralce ASM文件系统，提取其中的数据库文件。
添加8个lTlun：
解析asm文件系统，提取出数据库文件。
Netapp存储数据验证及数据移交：
北亚企安数据恢复工程师对恢复出来的数据进行检测后没有发现异常情况。用户方对恢复出来的数据进行验证后，确认恢复出来的数据完整有效。本次Netapp存储数据恢复工作完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aff51899d1d8ce5a0316cb41a9a95d0/" rel="bookmark">
			嵌入式Linux之Ubuntu学习笔记（shell脚本条件判断，函数，循环）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.shell脚本条件判断 shell脚本支持条件判断。虽然可以通过&amp;&amp;和||来实现简单的条件判断，但是稍微复杂一点的场景就不合适了。
shell脚本提供了if then 条件语句，写法：
if[条件判断]；then //判断成立要做的事情
fi
还有if then else 语句， 写法：
if 条件判断；then
//判断成立要做的事情
else
//条件判断不成立要做的事情
fi
或
if 条件判断；then
//判断成立要做的事情
elif[条件判断]；then
//判断成立要做的事情
else
//条件判断不成立要做的事情
fi
最后还有case语句
case $变量 in
第一个变量内容）
程序段
；；//程序在此结束
第二个变量内容）
程序段
；；//程序在此结束
第三个变量内容）
程序段
；；//程序在此结束
esac
fi的意思是结束！ 2.shell脚本函数 shell脚本也支持函数，函数写法如下：
function fname(){
//函数代码段
}
3.shell循环 shell脚本也支持循环，比如while do done，表示当条件成立的时候就一直循环，直到条件不成立。
while[条件] //括号内的状态是判断式
do //循环开始
//循环代码段
done
还有另外一种until do done，表示条件不成立的时候循环，条件成立以后就不循环了，写法如下：
until[条件]
do
//循环代码段
done
for循环，使用for循环可以知道有循环的次数，写法
for var in con1 con2 con3…….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aff51899d1d8ce5a0316cb41a9a95d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74044699f0a07ed06e9d76d99b9ca088/" rel="bookmark">
			李沐机器学习系列4---全连接层到卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 从全连接到卷积 1.1 平移不变性 从概率分布的角度来看卷积的定义, f ( τ ) f(\tau) f(τ)是概率密度， g ( t − τ ) g(t-\tau) g(t−τ)是在这个分布下的均值
( f ∗ g ) ( t ) = ∫ − ∞ ∞ f ( τ ) g ( t − τ ) d τ (f*g)(t)=\int_{-\infin}^{\infin}f(\tau)g(t-\tau)d\tau (f∗g)(t)=∫−∞∞​f(τ)g(t−τ)dτ
2 图像卷积 2.1 互相关运算 import torch from torch import nn from d2l import torch as d2l def corr2d(X, K): #@save """计算二维互相关运算""" h, w = K.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74044699f0a07ed06e9d76d99b9ca088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b6fd4a95f30439ae8a1dd06ba052d4/" rel="bookmark">
			【开源】基于JAVA语言的智能教学资源库系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 课程档案模块2.3 课程资源模块2.4 课程作业模块2.5 课程评价模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 课程档案表3.2.2 课程资源表3.2.3 课程作业表3.2.4 课程评价表 四、系统展示五、核心代码5.1 新增课程评价5.2 生成课程作业5.3 新增课程资源5.4 查询课程5.5 新增课表 五、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的智能教学资源库系统，包含了课程管理、资源中心、授课中心、作业发布、课程评价、课程质量分析模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，智能教学资源库系统基于角色的访问控制，给高校管理员、教师和学生角色使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 近年来，计算机技术、网络技术的迅猛发展，给传统办学提供了新的模式。绝大部分大学和学院都已介入互联网领域，并建成校园网，各校的硬件设施也已经比较完善。通过设计网络拓扑架构、数据库基础结构，建设网络安全系统、信息共享与管理系统、信息的发布与管理系统，方便了管理者、老师和学生间的信息发布、信息交流和信息共享。以现代计算机技术、网络技术为基础的数字化教学，主要是朝着信息化、网络化、现代化的目标迈进。
本文设计的课程资源库管理系统的包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了课程档案模块、课程资源模块、课程作业模块、课程评价模块、授课管理模块和学习质量分析模块这六大模块，用于存放系统的核心业务逻辑。
2.1 数据中心模块 数据中心模块包含了对课程资源库管理系统的基础模块，比如管理谁可以登录这套系统，记录这些人登录系统做了什么，不同的人拥有不同权限的管理。
2.2 课程档案模块 课程档案模块用于对课程的数据进行管理，其中包括课程标题、课程介绍、课程图片、课程状态、创建人、创建时间、更新人、更新时间等，可以通过此模块对课程数据进行添加、编辑更新、删除、查询操作。
2.3 课程资源模块 课程资源管理模块是对课程的资源信息进行管理，课程有了资源才能更好的被学生所接受，课程资源的字段包括课程ID、课程名称、资源名称、文件、创建人、创建时间、更新人、更新时间等，教师可以新增课程的资源数据，学生可以查询教师发布的课程资源信息。
2.4 课程作业模块 课程作业模块是为了管理课程的作业数据，有了课程后，教师可以发布指定课程的作业数据，支持一键生成课程作业，其中课程作业的字段包括课程ID、课程名称、作业名称、作业附件、完成附件、学生ID、学生姓名、创建人等，教师可以增加、删除、编辑和条件查询课程作业，学生可以提交属于自己的作业数据。
2.5 课程评价模块 课程评价模块是维护关于课程的评价信息，学生学习完课程后，可以对课程进行评价，撰写评语，以便于改进课程的质量。其中课程评价字段包括课程ID、课程名称、评价人、评价内容、评价时间、备注、创建人、创建时间等，学生可以增加、删除、编辑和条件查询自己的课程评价，教师可以查询课程的评价内容。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 课程档案表 3.2.2 课程资源表 3.2.3 课程作业表 3.2.4 课程评价表 四、系统展示 五、核心代码 5.1 新增课程评价 @RequestMapping(value = "/addOne", method = RequestMethod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b6fd4a95f30439ae8a1dd06ba052d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ea42cddd26ba1077c6487f42aa510f/" rel="bookmark">
			数据挖掘与数据分析的主要区别是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数字化时代，数据已经成为了企业决策的重要依据，而数据挖掘与数据分析作为数据处理的重要工具，都在帮助企业从数据中发现价值，从而提升业务效益。然而，许多人对于数据挖掘与数据分析的区别并不清晰。数聚将从不同角度深度剖析数据挖掘与数据分析的区别，并探讨它们在实际应用中的差异和优势。
首先，数据挖掘和数据分析在定义上存在一定的差异。数据挖掘是指通过应用统计学、机器学习等方法，自动发现数据中隐藏的模式、关联规则和趋势，从而找出对业务决策有指导意义的信息。而数据分析则更侧重于对数据的分析和解释，通过统计学方法，对数据的特征进行探索和分析，以揭示数据背后的规律和趋势。
其次，数据挖掘和数据分析在应用领域上也有所不同。数据挖掘主要应用在商业领域，包括市场营销、客户关系管理、风险分析等。通过挖掘大量的消费数据和用户行为数据，企业可以更好地了解市场需求、预测用户行为，从而制定更精准的营销策略和商业决策。同时，数据挖掘也在科学研究和医疗健康领域有着广泛的应用。
而数据分析则更广泛地应用在各个行业和领域。无论是金融、制造业、物流，还是教育、医疗、政府等，数据分析都扮演着至关重要的角色。通过对大数据的采集、整理和分析，企业和组织可以更好地优化业务流程、提升工作效率，甚至发掘新的商业机会。
此外，数据挖掘和数据分析在方法和技术上也存在一定的差异。数据挖掘通常采用机器学习、聚类分析、关联规则挖掘等技术手段，而数据分析则采用统计学方法、数据可视化等手段。数据挖掘更加注重对数据的自动分析和挖掘，而数据分析更为细致地分析和解释数据，以帮助企业和组织做出更明智的决策。
在数聚看来，数据挖掘与数据分析虽然在某些方面存在重叠和相似之处，但在定义、应用领域和技术手段等方面存在明显的差异。企业在选择数据处理方法时，应根据实际需求和目标来选择合适的方法。无论是数据挖掘还是数据分析，都可以为企业带来巨大的商业价值，帮助企业在激烈的市场竞争中脱颖而出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca622cca1d0105956dc2bfa0d0069fa/" rel="bookmark">
			常见的并查集题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 并查集逻辑实现的优化有两种，第一种是查找时路径压缩，第二种是按秩合并，合并时将高度较小的树作为较高树的子树,从代码量来看，推荐使用路径压缩，可以参考lc 547. 省份数量的两种UnionFind写法
题目 1 LC990. 等式方程的可满足性 class Solution { class UnionFind{ int[]p; int[]rank; public UnionFind(int n){ p=new int[n]; rank=new int[n]; for(int i=0;i&lt;n;i++){ p[i]=i; rank[i]=1; } } public void union(int x,int y){ int r1=find(x); int r2=find(y); if(r1==r2)return; if(rank[r1]&gt;rank[r2]){ p[r2]=r1; }else if(rank[r1]&lt;rank[r2]){ p[r1]=r2; }else{ p[r2]=r1; rank[r1]++; } } public int find(int x){ while(x!=p[x]){ x=p[x]; } return x; } } public boolean equationsPossible(String[] equations) { int n=equations.length; UnionFind uf=new UnionFind(26); for(int i=0;i&lt;n;i++){ String equation=equations[i]; int a=equation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca622cca1d0105956dc2bfa0d0069fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735874f2496ccdafbb1277b598dd877d/" rel="bookmark">
			网络安全试题进阶——附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择题 什么是CSRF攻击的全称？
A. Cross-Site Request ForgeryB. Cross-Site ScriptingC. Credential Sniffing and Retrieval ForceD. Cyber Security and Risk Framework 哪种安全攻击利用用户的社交工程，诱使他们点击似乎是合法链接的恶意链接？
A. PhishingB. SpoofingC. DDoSD. Ransomware 以下哪个不是常见的密码攻击类型？
A. Brute ForceB. Social EngineeringC. DNS SpoofingD. Man-in-the-Middle 在网络安全中，常用的用于保护机密性的加密算法是？
A. RSAB. AESC. SHAD. MD5 HTTP协议默认使用的端口是？
A. 80B. 443C. 22D. 21 哪种安全协议用于在互联网上传输加密的数据？
A. HTTPB. FTPC. SSL/TLSD. UDP 以下哪个不是常见的恶意软件类型？
A. TrojanB. WormC. SpywareD. Router 在计算机安全领域，CSIRT是指什么？
A. Computer Security Incident Response TeamB. Cyber Security Infrastructure and Response TeamC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/735874f2496ccdafbb1277b598dd877d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e11c396d285135d32b920ea397f60eb/" rel="bookmark">
			使用Go语言实现RESTful API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RESTful架构是一种设计风格，用于构建网络应用程序的API。它基于HTTP协议，并使用不同的HTTP方法（如GET、POST、PUT、DELETE等）来处理不同的操作。在Go语言中，我们可以使用标准库中的net/http包来实现RESTful API。
下面是一个简单的示例，演示如何使用Go语言实现一个基本的RESTful API：
go复制代码
package main import ( "encoding/json" "log" "net/http" ) // 定义一个结构体来表示资源 type User struct { ID int `json:"id"` Name string `json:"name"` Age int `json:"age"` } // 定义一个处理GET请求的处理函数 func getHandler(w http.ResponseWriter, r *http.Request) { // 从数据库或其他数据源获取用户数据 user := User{ID: 1, Name: "John", Age: 30} // 将用户数据转换为JSON格式 userJSON, err := json.Marshal(user) if err != nil { http.Error(w, "Internal Server Error", http.StatusInternalServerError) return } // 将JSON数据写入响应中 w.Header().Set("Content-Type", "application/json") w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e11c396d285135d32b920ea397f60eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d485a69eeb3d6248f95b94938cb95c4/" rel="bookmark">
			Go语言中的HTTP路由处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Web开发中，路由处理是至关重要的部分。它决定了当用户访问某个URL时，服务器应该如何响应。Go语言提供了多种库和工具来处理HTTP路由。下面，我们将深入了解如何在Go语言中处理HTTP路由。
Go语言的net/http包本身提供了基本的功能来处理路由。你可以使用http.HandleFunc函数来为特定的URL路径注册处理函数。例如：
go复制代码
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello, World!") })
在上述代码中，我们为根URL路径“/”注册了一个处理函数，该函数简单地返回“Hello, World!”。
然而，对于更复杂的路由需求，你可能需要使用更强大的路由库。一些流行的Go语言HTTP路由库包括：
Gorilla Mux: Gorilla Mux是一个功能强大且灵活的路由库，支持正则表达式匹配、路径参数提取等。Echo: Echo是一个高性能的Web框架，提供了简洁的路由功能。它支持中间件、静态文件服务、自动生成路由文档等功能。Chi: Chi是一个轻量级的Web框架，具有可扩展的路由功能和良好的性能。Pat: Pat是一个简单的、可扩展的路由库，适用于小型到中型Web应用程序。 下面是一个使用Gorilla Mux的示例：
go复制代码
import ( "github.com/gorilla/mux" "net/http" ) func main() { router := mux.NewRouter() router.HandleFunc("/home", HomeHandler).Methods("GET") router.HandleFunc("/about", AboutHandler).Methods("GET") http.ListenAndServe(":8080", router) }
在上述代码中，我们创建了一个新的路由器实例，并使用HandleFunc方法为“/home”和“/about”路径注册了处理函数。我们还指定了这些处理函数只响应GET请求。最后，我们使用http.ListenAndServe启动了一个Web服务器，监听8080端口。
除了这些库之外，还有一些更高级的框架提供了更为完整和现代化的路由功能，例如FastAPI和Beego。这些框架通常提供了自动生成路由文档、中间件支持、参数验证等功能。
总之，Go语言提供了多种工具和库来处理HTTP路由。根据你的项目需求和规模，可以选择适合你的路由解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b4cc2988af3bd0f6978534ff6ef9e08/" rel="bookmark">
			使用Go语言的HTTP客户端库进行API调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着微服务架构和RESTful API的普及，API调用成为了日常开发中的常见任务。Go语言提供了多种工具和库来帮助开发者轻松地与API进行交互。本文将介绍如何使用Go语言的HTTP客户端库进行API调用。
在Go语言中，标准库中的net/http包提供了基本的HTTP客户端功能。要使用net/http包进行API调用，你需要遵循以下步骤：
安装和导入必要的包：首先，确保你已经安装了Go语言环境，并在代码中导入net/http包。
go复制代码
import ( "net/http" )
创建HTTP客户端：使用http.Client创建一个新的HTTP客户端。
go复制代码
client := &amp;http.Client{}
构建HTTP请求：使用http.NewRequest函数创建一个新的HTTP请求。你需要指定请求方法（如GET、POST等）、URL和可选的请求体。
go复制代码
req, err := http.NewRequest("GET", "https://api.example.com/endpoint", nil) if err != nil { // 处理错误 }
设置请求头：如果需要，你可以使用req.Header.Set方法设置请求头。例如，设置Content-Type为JSON。
go复制代码
req.Header.Set("Content-Type", "application/json")
发送请求：使用之前创建的HTTP客户端发送请求。你可以使用client.Do(req)方法发送请求。
go复制代码
resp, err := client.Do(req) if err != nil { // 处理错误 }
处理响应：检查响应的状态码，并使用ioutil.ReadAll读取响应体。然后，你可以根据需要解析响应数据。
go复制代码
body, err := ioutil.ReadAll(resp.Body) if err != nil { // 处理错误 } defer resp.Body.Close()
处理JSON数据：如果你的API返回JSON数据，可以使用Go语言的encoding/json包来解析这些数据。定义一个结构体来映射JSON数据，并使用json.Unmarshal方法将响应体解析为该结构体。关闭连接和清理资源：在完成API调用后，确保关闭响应体和释放资源。错误处理：在整个过程中，始终检查和处理可能出现的错误。这包括网络错误、解析错误等。并发和性能优化：如果你需要并发地调用多个API，可以使用Go语言的goroutines和channels来优化性能。这样，你可以同时处理多个API请求，并有效地管理并发操作。跟踪API调用：为了更好地监控和管理API调用，你可以使用跟踪和日志记录工具，如OpenCensus或Jaeger，来追踪请求的执行时间、响应状态等信息。遵循最佳实践：确保遵守API提供商的最佳实践和建议，特别是在发送请求时设置正确的请求头、使用合适的请求参数等。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ebcff6f2e1ead7529e4de60bcb0120/" rel="bookmark">
			KNN 分类（选择最佳的 K 值，并可视化模型精度与 n_neighbors 的关系）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import matplotlib.pyplot as plt from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split from sklearn.neighbors import KNeighborsClassifier # 导入乳腺癌数据集 cancer = load_breast_cancer() # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(cancer.data, cancer.target, random_state=66, stratify=cancer.target) training_accuracy = [] test_accuracy = [] # n_neighbors 取值范围为 [1, 10] neighbors_settings = range(1, 11) # 模型构建及模型评估 for n_neighbors in neighbors_settings: clf = KNeighborsClassifier(n_neighbors=n_neighbors) clf.fit(X_train, y_train) training_accuracy.append(clf.score(X_train, y_train)) # 记录训练精度 test_accuracy.append(clf.score(X_test, y_test)) # 记录泛化精度 # 打印不同的 n_neighbors 值对应的训练精度和泛化精度 neighbor_dict = {} for n_neighbors in neighbors_settings: neighbor_dict[n_neighbors] = [training_accuracy[n_neighbors - 1], test_accuracy[n_neighbors - 1]] print(neighbor_dict) # 可视化模型精度与 n_neighbors 的关系 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ebcff6f2e1ead7529e4de60bcb0120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315bf68b65a2a4cea0740e81ddf8e797/" rel="bookmark">
			微软开源.net core如何在linux系统搂钱?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年给linux基金会捐款50万，真的很少。比尔盖茨几千亿的身价，股市一个波动就是几百亿。也许这个就是给他们送了一杯咖啡。
相比如果是把它作为敌人，拿出出几百亿要打压他们，这已经是一个很好的信号了。
2023年10月份左右，又计划了一个10亿美元的投资
因为主流的互联网服务工具大多数是都是基于Linux等开源系统的，而微软在云计算方面显然落后于竞争对手，为了抢夺更多的客户，微软的举动就不难理解了。
加入Linux基金会以后，微软可以更加深入的参与Linux系统的演进，从而让这个互联网上最主流的系统可以更好的在自己的云服务平台上运行，就可以更好的卖云服务，显然是符合微软的利益的。
微软已经准备推出了Linux版本的SQL Server，这个原来只跑在微软自家系统上的数据库系统竟然也拥抱开源了。
------------
随着开源技术的迅速发展和普及，Microsoft 在过去几年也开始逐渐转向开源领域。而最近，Microsoft的一个重大动作，就是宣布了长达5年、总计10亿美元的投资计划，用于支持开发人员使用基于Linux的操作系统。具体而言，Microsoft计划投资在 CentOS、Debian、Fedora、Kali Linux、 openSUSE、SLES、Ubuntu 和其他 Linux 发布版上。
在这个消息公布之后，社区版的Linux成为了大家讨论的焦点。的确，这项投资计划对开源领域来说毫无疑问是一个巨大的动作。那么，在此背景下，社区版Linux是如何受益的？而一家历史上曾经反对开源的公司变成投资者，是否会对市场带来很大的影响？那么，接下来将详细探讨此问题。
开源领域的受益者
让我们看看开源社区会如何受益。这个投资显然会帮助 Linux 社区的软件包维护、生态系统建设和创新研发。Microsoft 投资将使得这些社区能更加稳定和持久，因为社区不再依赖单一贡献者或公司的支持。
在研发开源技术的过程中，团队涉及很多方面，不仅包括了技术层面，还包括了社区的运营和营销。因此，Microsoft的参与也将为这个生态系统注入新动力，使得包括 Linux 在内的开源技术生态圈进一步发展。
另外，这项投资还有可能帮助建立一个更加统一的开源生态系统。在过去，开源生态系统中存在着很多分支和异构性，在某种程度上限制了其发展。但若是得到微软的接纳支持，则有望在未来实现更加统一平台的发展。
社区版Linux的维护和升级也是一大受益者。从传统来看，社区版Linux一直以来都是由社区志愿者在无偿维护的。而微软的投资，有望支持这些社区志愿者，为他们提供大量资源、设备和资金支持。这有助于社区版Linux的长期发展和更好地满足用户需求。
为什么微软要投资Linux
那么，微软为什么会投资 Linux 呢？这样一个历史上一直以来的 Microsoft 投资开源技术的动作究竟意味着什么？实际上，微软的这一动作已经充分反映出现今微软已经明白开源技术的重要性，并将其列在其重要战略部署之一。
从业务层面看，当今大量的业务流程基于开源技术，并且在多个层面上都需要和开源技术深入互动和集成。除此之外，从开发和测试平台到运行时环境，开源技术贯穿于 IT 系统的每一个角落。正是考虑到这些业务需求，Microsoft 才不得不改变一贯针对开源的敌对态度，同时加强与 Linux 社区相互合作，以满足其客户在 IT 基础设施上的需求。
从技术层面来看，微软投资 Linux 是必然的。在当今技术变革的年代，技术的爆发性发展以及 Linux 的普及率上升，也迫使传统的 Microsoft Windows 进行了势在必行的变革。这些原因让人们相信微软在从技术方面进一步发展上的需求，从而使其在知识产权和其他前沿技术方面积极推进和投资。
更重要的是，这样的投资力度并非出于次要考虑。而是因为开源技术的浪潮已经来临，微软的“再次出征”已经到来。如果 Microsoft 想要在新的技术政策下继续满足用户需求，那么这些技术将不得不在微软产品中得到更广泛的应用和升级。
让我们更好地预测这种变化吧：我们将看到更多开源技术在微软产品中得到应用，这将使得微软有更丰富的产品线，同时也将带来更加多元化开放的技术组合。
开源技术的未来
无论是 Microsoft 的转变还是对开源技术未来发展的展望，都预示着开源技术未来将会更加强大和稳定。当今，开源技术已经获得了广泛的应用，不断地推动数码行业的普及和发展。通过投资开源技术，Microsoft 也证明了在这种颠覆性技术革命的浪潮中，对于微软来说，开源技术已经成为其未来发展的必然趋势。
即便是将来微软也依旧是自己的老维度，但是通过开源技术的支持和投资，微软势必将促进业务的再次快速发展，并且为客户提供更加开放、更加多元化的产品组合。
无论是社区版Linux还是微软的转变，都是开源技术在市场中不断推荐自身价值和震撼力的证明。开源技术的蓬勃发展，将迎来更加开放和多元的发展之路，而这样的发展很可能会带来更好的使用体验和新的商业机会
linux加入微软,破天荒！微软宣布加入Linux基金会：成白金会员 转载
2021-05-25 11:47:54
在周三于纽约举行的年度性Connect();开发者大会上，微软宣布，将加入Linux基金会，并支付50万美元的年费成为该基金会最高级的白金会员。微软Azure团队的架构师约翰·格斯曼(John Gossman)将成为基金会的董事会成员。
Linux基金会的其他10家白金会员分别为思科、富士通、惠普企业、华为、IBM、英特尔、NEC、甲骨文、高通和三星。
微软表示，将与开源社区展开更深入的合作，通过此番举措，微软将与多样化的生态系统展开进一步协作和创新，帮助更多客户获益。
同时，微软也对谷歌加入独立的.NET基金会，并与三星电子合作帮助.NET开发者为全球超过5千万三星设备用户开发应用的举措表示欢迎。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315bf68b65a2a4cea0740e81ddf8e797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b02f283ebad6a4b5221a9226836f2c/" rel="bookmark">
			【LeetCode每日一题】2397. 被列覆盖的最多行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024-1-4
文章目录 [2397. 被列覆盖的最多行数](https://leetcode.cn/problems/maximum-rows-covered-by-columns/)方法：二进制枚举 2397. 被列覆盖的最多行数 方法：二进制枚举 1.获取矩阵的行数和列数，并创建一个大小为m的一维数组rows来保存每行的状态
2.通过遍历矩阵的每个元素，将每行的状态用位运算保存到rows数组中。
3.通过使用位掩码mask来遍历所有可能的行选择情况
4.如果mask二进制表示中1的个数不等于numSelect，则跳过当前循环。
5.计算在当前行选择情况下，有多少行满足被选择行的状态，即与mask进行位与运算后等于自身的行数
6.代码更新保存结果的变量ans，取当前结果与新计算的行数满足条件的行数之间的较大值。
public int maximumRows(int[][] matrix, int numSelect) { int m = matrix.length; // 获取矩阵的行数 int n = matrix[0].length; // 获取矩阵的列数 int[] rows = new int[m]; // 创建一个长度为m的一维数组来保存每行的状态 for (int i = 0; i &lt; m; ++i) { // 遍历矩阵的行 for (int j = 0; j &lt; n; ++j) { // 遍历矩阵的列 if (matrix[i][j] == 1) { // 如果当前元素为1 rows[i] |= 1 &lt;&lt; j; // 利用位运算将当前行的状态保存到rows数组中 } } } int ans = 0; // 初始化结果变量为0 for (int mask = 1; mask &lt; 1 &lt;&lt; n; ++mask) { // 通过位掩码mask遍历所有可能的行选择情况 if (Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86b02f283ebad6a4b5221a9226836f2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e53bac48ced92f527676919acd83bf6/" rel="bookmark">
			【React系列】Hook（一）基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自#React系列教程：https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5MDAzNzkwNA==&amp;action=getalbum&amp;album_id=1566025152667107329)
一. 认识hook 1.1. 为什么需要hook Hook 是 React 16.8 的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。
我们先来思考一下class组件相对于函数式组件有什么优势？比较常见的是下面的优势：
class组件可以定义自己的state，用来保存组件自己内部的状态； 函数式组件不可以，因为函数每次调用都会产生新的临时变量； class组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑； 比如在componentDidMount中发送网络请求，并且该生命周期函数只会执行一次；函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求； class组件可以在状态改变时只会重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等； 函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次； 所以，在Hook出现之前，对于上面这些情况我们通常都会编写class组件。
但是class组件依然存在很多的问题：
复杂组件变得难以理解：
我们在最初编写一个class组件时，往往逻辑比较简单，并不会非常复杂。但是随着业务的增多，我们的class组件会变得越来越复杂；比如componentDidMount中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在componentWillUnmount中移除）；而对于这样的class实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度； 难以理解的class：
很多人发现学习ES6的class是学习React的一个障碍。比如在class中，我们必须搞清楚this的指向到底是谁，所以需要花很多的精力去学习this；虽然我认为前端开发人员必须掌握this，但是依然处理起来非常麻烦； 组件复用状态很难：
在前面为了一些状态的复用我们需要通过高阶组件或render props；像我们之前学习的redux中connect或者react-router中的withRouter，这些高阶组件设计的目的就是为了状态的复用；或者类似于Provider、Consumer来共享一些状态，但是多次使用Consumer时，我们的代码就会存在很多嵌套；这些代码让我们不管是编写和设计上来说，都变得非常困难； Hook的出现，可以解决上面提到的这些问题；
简单总结一下hooks：
它可以让我们在不编写class的情况下使用state以及其他的React特性；但是我们可以由此延伸出非常多的用法，来让我们前面所提到的问题得到解决； Hook的使用场景：
Hook的出现基本可以代替我们之前所有使用class组件的地方（除了一些非常不常用的场景）；但是如果是一个旧的项目，你并不需要直接将所有的代码重构为Hooks，因为它完全向下兼容，你可以渐进式的来使用它；Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用； 这里有一个Dan Abramov文章中提到的class组件和函数式组件的对比图：
1.2. hooks的基本演练 我们通过一个计数器案例，来对比一下class组件和函数式组件结合hooks的对比：
class组件实现：
import React, { PureComponent } from 'react' export default class Counter01 extends PureComponent { constructor(props) { super(props); this.state = { counter: 0 } } render() { return ( &lt;div&gt; &lt;h2&gt;当前计数: {this.state.counter}&lt;/h2&gt; &lt;button onClick={e =&gt; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e53bac48ced92f527676919acd83bf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764ff8ec6c6081902d1c20f2b10e77bb/" rel="bookmark">
			（一）看参考手册学stm32基于hal库，点灯时钟配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）看参考手册学stm32基于hal库，点灯时钟配置 这篇文章主要是个人的学习经验，想分享出来供大家提供思路，如果其中有不足之处请批评指正哈。
废话不多说直接开始主题，本人是基于STM32F407VET6芯片，但是意在你看懂这篇文章后，不管是F1,F4,H7等一系列系统时钟配置都能明白如何通过参考手册去学习配置。而不是Ctrl c，Ctrl v。
时钟配置 首先看看数据手册目录找找有木有时钟相关的内容好定位。
1.这句话就告诉你了你可以不用外部接时钟用它内部的就行，16 MHz内部RC振荡器在出厂时经过修整，在整个温度范围内提供1%的精度。他是这么说但是我不这么相信，主要是我的开发板上有一块8M的外部晶振，不用就浪费了。
2.这就是外部晶振的频率要求，我就不翻译了。
3.看看我自己的开发板原理图，8M没问题
4.数据手册中告诉你了，APB，AHB总线的频率要求，一会我就会参照着他的要求设置cubemx的时钟树配置，是不是配置时钟有点思路了？
几个预分频器允许配置三个AHB总线，即高速APB(APB2)和低速APB (APB1)域。三个AHB总线的最大频率为168 MHz，而高速APB域的最大频率为168 MHz，84 MHz。低速APB域允许的最大频率为42Mhz。该器件嵌入了一个专用的锁相环(PLLI2S)，可实现音频级性能。在这种情况下，i2s主时钟可以产生从8khz到192khz的所有标准采样频率。
再看看定时器的时钟配置
数据手册中还写到APB1线上的定时器84MHZ，APB1=42MHZ
APB2线上的定时器168MHZ,APB2=84MHZ.
CUBEMX时钟树的这几个数为什么知道由来了吧。
5.来到参考手册这看看相关时钟配置，你该想想如果是别的系列的芯片怎么看手册该怎么配置了？
6.他说3个不同的时钟源，三种不同的时钟源可用于驱动系统时钟(SYSCLK):
•恒生指数振荡器时钟
•HSE振荡器时钟
•主锁相环(PLL)时钟
好看看cubemx
还真是3个时钟源啊，只不过我用的主锁相环(PLL)时钟。其他时钟源还可以试试不会坏的，又不是VCC,GND。
7.设备有以下两个备用时钟源:
•32 kHz低速内部RC (LSI RC)，驱动独立的看门狗，可选的RTC用于从停止/待机模式自动唤醒。
•32.768 kHz低速外部晶体(LSE晶体)可选驱动RTC时钟(RTCCLK)
本人用的外部时钟始终秉持着不用就浪费原则。
好好看看翻译，好好看看这几张图，思考一下你会豁然开朗的，因为每一块都是一一对应的关系。
9.这张抽象无比的时钟树真正关键的只有这几个小点，其他的我爱答不理。
配置cubemx 有了参考基础，接下来开始正式配置外部时钟
1.打开cubemx
2.本人用的是f407，如果是不一样的芯片按自己的型号来
3.上文也介绍了我不管是高速还是低速都用的是外部晶振，详见上文第3条第7条。
4.cubemx时钟树需要根据你的选择如果是外部晶振，需要根据你的原理图去配置，我原理图是32.768K,8M所以本人根据此配置。
5.再根据要求系统时钟（sysclk）不能超过180MHz，APB1&lt;=42MHZ,APB1 CLOCK&lt;=84MZ,APB2&lt;=84MHZ,APB1 CLOCK&lt;=168MZ满足以上要求即可，如图所示
至此你应该明白了，噢原来时钟只要小于他的限幅频率即可，那我设多少都可以比如SYSCLK&lt;=180,那我179，178，176.52，168无论是不是浮点数只要小于180都是可以的。至此外部晶振的工作已经完成。
内部源时钟配置 1.失能即可，即进入内部时钟源
2.你会发现外部的时钟源那部分已经改不了了，其他内容配置同外部晶振配置
接下来怎么测试可行性呢？点个灯试试
F407按键点灯
经过测试不管是内部时钟还是外部时钟都没问题哈哈。
本文没有对点灯部分详细讲解，将会在下一篇文章中讲解物理知识以及hal库的使用，纯属个人经验，有不足之处希望大家指正。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/7/">«</a>
	<span class="pagination__item pagination__item--current">8/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/9/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>