<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65dfa5367eab527a4a2bfd657fd2e67f/" rel="bookmark">
			vue diff算法原理以及v2v3的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		diff算法简介 diff算法的目的是为了找到哪些节点发生了变化，哪些节点没有发生变化可以复用。如果用最传统的diff算法，如下图所示，每个节点都要遍历另一棵树上的所有节点做比较，这就是o(n^2)的复杂度，加上更新节点时的o(n)复杂度，那就总共达到了o(n^3)的复杂度，这对于一个结构复杂节点数众多的页面，成本是非常大的。
实际上vue和react都对虚拟dom的diff算法做了一定的优化，将复杂度降低到了o(n)级别，具体的策略是：
同层的节点才相互比较 从根节点起遍历整个节点数，只对同层的节点进行相互比较。所以我们在代码开发中，如果节点内容没有发生变化，那不要轻易改变它的层级，否则会导致节点无法复用。
节点比较时，如果类型不同，则对该节点及其所有子节点直接销毁新建。类型相同的子节点，使用key帮助查找，并且使用算法优化查找效率。其中react和vue2以及vue3的diff算法都不尽相同。 接下来我们就介绍一下vue里面的具体代码实现
Vue2 中的Diff算法 整体流程图
patch 先判断是否是首次渲染，如果是首次渲染那么我们就直接createElm即可；如果不是就去判断新老两个节点的元素类型否一样；如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。
function patch(oldVnode, vnode, hydrating, removeOnly) { // 判断新的vnode是否为空 if (isUndef(vnode)) { // 如果老的vnode不为空 卸载所有的老vnode if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return } let isInitialPatch = false // 用来存储 insert钩子函数，在插入节点之前调用 const insertedVnodeQueue = [] // 如果老节点不存在，直接创建新节点 if (isUndef(oldVnode)) { isInitialPatch = true createElm(vnode, insertedVnodeQueue) } else { // 是不是元素节点 const isRealElement = isDef(oldVnode.nodeType) // 当老节点不是真实的DOM节点，并且新老节点的type和key相同，进行patchVnode更新工作 if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) { patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) } else { // 如果不是同一元素节点的话 // 当老节点是真实DOM节点的时候 if (isRealElement) { // 如果是元素节点 并且在SSR环境的时候 修改SSR_ATTR属性 if (oldVnode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65dfa5367eab527a4a2bfd657fd2e67f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760745052a3c918799770aa0672c1372/" rel="bookmark">
			若依前端问题集合[前后端分离版本]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.若依前后端分离页面改变title1.修改icon2.修改title文字 2.若依关闭Login页面验证码1.关闭验证码登录杂项 3.若依前端替换代理地址4.侧边菜单和全局样式1.侧边菜单2.侧边栏顶部logo替换或隐藏(删除)①替换logo②隐藏logo 3.全局样式修改背景色 *bug及杂项1.若依字典相关①使用字典对el-select回显赋值时,输入框中只回显字典值②若依字典值单独回显（通过input方式或者{{xxx}}在页面展示） 2.Elment-Ui 全局样式设置①全局公共样式②el-tooltip(el-tabel中show-overflow-tooltip文字提示默认全屏,设置屏幕百分比显示)③对于el-input类型的样式修改④el-dialog__header样式设置 3.百度地图设置百分比宽高 vscode代码格式化不换行 1.若依前后端分离页面改变title 修改浏览器title和icon图标
在项目public文件夹中有index.html文件
1.修改icon 将icon图标替换为自己需要使用的icon后更改文件名直接使用或者将右边link中的地址替换为自己的文件名,由于不知道&lt;%= BASE_URL %&gt; 的地址是什么所以我是直接改的文件名
&lt;%= BASE_URL %&gt; 根目录
链接: &lt;%= BASE_URL %&gt;详解
后面通过面向百度思想开始查询,这篇博文是看的比较详细的
2.修改title文字 最初是直接修改的文字,就是下面注释的那一行,后来运行项目时发现只有login页面的title是修改成功了,后来在查询才发现全局配置title需要改 .env.development 里面的配置
修改之后重新启动项目就可以发现改成功了
若依框架更改浏览器的title和图标
链接: 若依框架更改浏览器的title和图标
2.若依关闭Login页面验证码 1.关闭验证码 为了演示是减少登录页的操作,将验证码进行关闭,找到菜单内参数设置,将账号自助-验证码开关进行修改,参数键值设置为false
登录杂项 登录页面的标题和底部的一些文本,在view文件夹内login.vue中修改
标题在title标签内修改,底部不需要的文本可以注释掉,也可以进行替换
链接: 若依框架更改浏览器的title和图标
3.若依前端替换代理地址 在vue.config.js中将target内容替换成后端需要代理的IP
hearder中添加keep-alive的作用:有时和后端用的局域网但是链接一直失败,在博客中发现需要添加请求头,同事端口号需要和后端配置一致
详见
链接: Could not proxy request
链接:若依中反向代理解决跨域问题
4.侧边菜单和全局样式 修改样式建议先把variables.scss和slidebar.sass和最新的若依同步，老版本修改可能导致开启topnav时只有一级菜单的页面会出现左侧空白（如：首页），若依3.85版本解决了该问题，因此需要在更新代码之后编写样式
链接: 若依gitee地址
1.侧边菜单 侧边菜单主要通过assets文件夹中style内的slidebar.sass和variables.scss两个文件进行修改,variables.scss主要是定义颜色的变量,对应的变量修改为自己需要的样式就可以了
slidebar.scss主要是定义侧边组件的样式,对应的变量修改为自己需要的样式就可以了,如果只是改颜色之类就不需要改动
我们的需求是给被点击的菜单添加左侧一个高亮添加的border,在更改过程中发现如果是二级菜单会导致一级菜单显示高亮所有二级菜单都会显示高亮,需要找到对应的地方添加 .el-menu-item.is-active
3.85版本若依slidebar.sass
链接: 开启topnav之后一级菜单顶部导航栏会收缩，但是slidebar会显示空白
&lt;style&gt; #app { .main-container { height: 100%; transition: margin-left .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/760745052a3c918799770aa0672c1372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aecc135e7a24b8b82762d453c494f348/" rel="bookmark">
			【重学Python】：Python 拓展之迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在之前 今天来讲讲「迭代器」的内容，其实已经拖了好多天了，感觉再不写就要忘记了。「迭代」相信对你来说已经不陌生了，我前面曾经专门用一篇文章来讲，如果你已经没有什么印象的话，就再点进去看看。
迭代器 首先我们先来看一种检查是否可迭代的方法：
&gt;&gt;&gt; hasattr(list,'__iter__') True 可以用上面的这种方法检查已经学习过的其他默认类型的对象，比如字符串，列表，字典等是否是可迭代的。
iter() 是一个特殊方法，它是迭代规则的基础，有了它，就说明对象是可迭代的。跟迭代有关的一个内建函数 iter()，这个函数我们在之前的文章中介绍过，它返回的是一个迭代器对象，比如像下面这样：
&gt;&gt;&gt; list1 = [1,2,3,4] &gt;&gt;&gt; iter_list = iter(list1) &gt;&gt;&gt; iter_list &lt;list_iterator object at 0x00000000021CE438&gt; 从上述代码的结果可以看出，iter_list 引用的是迭代器对象。那么在这里有一个问题，iter_list 和 list1 有区别吗？我们来试一下：
&gt;&gt;&gt; hasattr(list1,'__iter__') True &gt;&gt;&gt; hasattr(iter_list,'__iter__') True 从上面看出它们都有 iter，说明它们都是可迭代的。
&gt;&gt;&gt; hasattr(list1,"__next__") False &gt;&gt;&gt; hasattr(iter_list,"__next__") True 我们把像 iter_list 所引用的对象那样，称之为「迭代器对象」。显而易见的是，迭代器对象必然是可迭代的，反正则不一定。且 Python 中迭代器对象实现的是 next() 方法。
为了体现一下 Python 在这的强大之处，我们先来写一个迭代器对象：
python 复制代码 class MyRange: def __init__(self,n): self.i = 1 self.n = n def __iter__(self): return self def __next__(self): if self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aecc135e7a24b8b82762d453c494f348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0237697c36f02afa18c336c34d96f693/" rel="bookmark">
			Google Earth Engine（GEE）操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地理信息网站 Eatrth Explorer操作界面 在研究中，我们常需要遥感数据。在下面的网站中，可以得到遥感数据。
EarthExplorer (usgs.gov)https://earthexplorer.usgs.gov/登陆网站：
通常，在Additional Criteria中，可以下载遥感数据。
不过，这个似乎选择不了，也登录不上。
于是，需要选择用VPN 的方式科学上网。
Google Earth Engine操作界面 下面进入Google Earth Engine界面。
https://developers.google.com/earth-engine/guides/getstartedhttps://developers.google.com/earth-engine/guides/getstarted
该网站（https://developers.google.com/earth-engine/guides/getstarted）是操作说明。
然后，需要注意，用谷歌账号登录。
Catalog界面的数据
GEE开发者界面 注册账号 会让你填写一个Sign Up
https://signup.earthengine.google.com/#!/https://signup.earthengine.google.com/#!/
https://earthengine.google.com/noncommercial/https://earthengine.google.com/noncommercial/
然后，注册完之后，提交信息。
注意，需要关闭浏览器插件ABP，因为有时候，插件会把弹出来的验证当作广告屏蔽掉，导致你看不到信息。
然后，会收到这样的信息：
We're glad you're interested.Keep an eye on your inbox for ……（注册邮箱）. We'll let you know when you're good to go.
Please note:
It may take up to one week to evaluate your request.The response email may end up in your spam folder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0237697c36f02afa18c336c34d96f693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50164a7b33873c06ab8d773fb9d0847e/" rel="bookmark">
			vscode设置前进、后退快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我们使用vscode编写程序时，经常需要在不同的文件之间跳来跳去，如果只是依靠个人记忆去操作会显得非常不方便。本文介绍如何设置vscode的前进、后退快捷键。
1 vscode设置前进、后退快捷键 点击“设置”图标，然后点击“键盘快捷方式”，输入“navigateBack”设置后退快捷键，这里我们根据通常习惯设置为alt+←：
输入“navigateForward”设置前进快捷键，这里我们根据通常习惯设置为alt+→：
2 总结 （1）前进和后退快捷键包含的关键字分别为navigateForward、navigateBack。
（2）vscode默认的前进快捷键为alt+→、后退快捷键为alt+←。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c706635fc192d09307abbb7708b20e7/" rel="bookmark">
			Java 算法篇-链表的经典算法：判断回文链表、判断环链表与寻找环入口节点(“龟兔赛跑“算法实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 链表的创建
2.0 判断回文链表说明
2.1 快慢指针方法
2.2 使用递归方式实现反转链表方法
2.3 实现判断回文链表 - 使用快慢指针与反转链表方法
3.0 判断环链表说明
3.1 实现判断环链表与寻找环入口节点 - "龟兔赛跑"算法实现
3.2 解释为什么第一次相遇后，兔、龟每一次都走一步最终会相遇且该节点是环入口节点的原因
4.0 实现判断回文链表、判断环链表且寻找环入口节点的完整代码
1.0 链表的创建 链表是一种常见的数据结构，用于存储一系列元素。链表由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表可以分为单向链表和双向链表，其中单向链表的节点只有一个指针指向下一个节点，而双向链表的节点有两个指针，分别指向前一个节点和后一个节点。 为后续实现算法方便，这里需要实现一个带哨兵节点的单链表。
代码如下：
import java.util.Iterator; public class List implements Iterable&lt;Integer&gt;{ private final Node sentry; static class Node { public int value; public Node next; public Node() { } public Node(int value, Node next) { this.value = value; this.next = next; } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c706635fc192d09307abbb7708b20e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10a85ee3d2925b59f01861998f88a58d/" rel="bookmark">
			gradle8.0或者其他版本下载太慢或者time out超时（完美解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网镜像地址 如果其他软件除了android studio可以在下面完整直接下载
地址：https://mirrors.cloud.tencent.com/gradle/
distributionUrl=https://mirrors.cloud.tencent.com/gradle/gradle-8.0-bin.zip Android Stuiod如何配置更换 项目名称\gradle\wrapper\gradle-wrapper.properties
下面是我已经更改后的了，大家如果跟这个不一样换成跟，图片一样就，gradle-8.0-bin.zip这个名称可以根据自己的不同的版本进行更改 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58d1f33db135af77b8e43290e92b25f/" rel="bookmark">
			# Apifox前后端开发人员使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apifox前后端开发人员使用场景 概述 官网：Apifox 快速入门 | Apifox 帮助文档
功能描述 1、在日常编程开发过程中经常使用前后端分离架构的模式，一个项目的落地会通过产品、开发、测试三方会审，对项目需求评审过后，前后端开发会制定一些接口，通常会用以下方式：
编写指定接口文档。后端开发依据接口文档开发接口，一边开发一边测试。前端开发需要（Mock）数据供前端调用。开发完成后，测试通过（Postman，Jmeter）去进行接口测试。 2、为了能让项目落地更加便捷，Apifox应运而生实现了API设计开发测试一体化协作。Apifox=Postman+Swagger+Jmeter+Mock工具集。
优势 1、Apifox 是 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台。高效、及时、准确！
2、接口信息云端实时同步更新，响应团队协作。
3、Apifox 项目可“在线分享” API 文档，分享出去的 API 文档可设置为公开或需要密码访问，方便与外部团队进行协作。
4、支持导出各种数据格式OpenApi (Swagger)、Markdown、Html等
开发人员使用流程 总述 前端（或后端）在 Apifox 上定好接口文档初稿。前后端 一起评审、完善接口文档，定好接口用例。前端 使用系统根据接口文档自动生成的 Mock 数据进入开发，无需手写 mock 规则。后端 使用接口用例 调试开发中的接口，当所有接口用例调试通过，接口即开发完成。若开发过程中接口有改动，调试的时候会自动更新文档，零成本的保障了接口维护的及时性。后端 每次调试完一个功能就保存为一个接口用例。测试人员 直接使用接口用例测试接口。所有接口开发完成后，测试人员（也可以是后端）使用集合测试功能进行多接口集成测试，完整测试整个接口调用流程。前后端 都开发完，前端从Mock 数据切换到正式数据，联调通常都会非常顺利，因为前后端双方都完全遵守了接口定义的规范。 新建团队 创建团队、创建新项目
邀请团队成员设置团队权限、设置项目权限通知设置：支持将通知集成到第三方应用平台，接口变更后可发送消息通知 编写接口文档 编写基本信息请求参数设置：新建数据模型，参数直接关联模型的属性返回响应定义
响应示例编写：响应示例可根据MocK规则自动生成
前端使用Mock 发送Mock快捷请求，直接获取接口样例数据
后端调试模式开发接口 后端开发人员用调试模式对接口进行开发调试后端人员调试用例可以保存下来 接口用例测试 测试人员或者后端人员对保存的接口用例进行测试 前后端联调 前后端都开发完，前端从Mock 数据切换到正式数据 接口文档分享 可以生成在线文档进行查看
其它使用场景 接口管理 查看历史版本 查看接口修改历史时，可以与某次操作进行对比
在线分享 在 API 设计、开发、沟通、协作中，逻辑上应该以团队内共同定义的 API 文档为标准。实际操作中，团队成员习惯依靠 Word、PDF 格式文件进行 API 文档协作，造成大量信息未能及时同步，将接口以在线形式分享将有助于提高团队之间的沟通效率。 用例管理 定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。 Mock功能 根据接口/数据结构定义、Mock 规则配置、Mock 期望配置等功能自动生成模拟数据 登录状态获取 Session/Cookie 方式 先执行登录接口，执行完成后全局 Cookie 会自动保存返回的 Session/Cookie 信息。然后运行其他接口，会自动带上 Session/Cookie 信息。 Token 方式 在环境 里的全局参数统一设置，所有接口运行时会自动加上全局参数，无需每个接口手动设置 全自动登录 自动登录过一次后，保存登录态，避免每次执行用例都调用登录接口。编写前置脚本，将登录接口返回的登录凭证写入环境变量 接口自动化测试 获取Token公共脚本 编写前置脚本（获取用户登录token） // 定义发送登录接口请求方法 function sendLoginRequest() { // 获取环境里的 前置 URL const baseUrl = pm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58d1f33db135af77b8e43290e92b25f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f623ae898dc2ac0e1fccb2e4eb418499/" rel="bookmark">
			JMeter HTTP请求的详细指南，还不知道的快来看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTTP请求简介 在JMeter中，服务器名称和它的路径对于检查请求是否到达了正确的目的地非常重要。默认情况下，HTTP协议与请求一起被遵循，如果需要，可以转换为HTTPS。如果需要，用户参数可以包含在特定页面的请求中。如果，有时多个请求被转移到同一个服务器上，而且在所有的请求中都是常见的，那么默认的HTTP请求在这里是有效的。因此，一旦在JMeter的配置元素中固定了该属性，所有属于同一线程组的请求都会接管同一属性。本文将简要讨论JMeter中HTTP请求的配置。
什么是JMeter HTTP请求？ 采样器是用来传输HTTPS或HTTP请求到网络服务器上进行负载测试的。所以在HTTP请求的下拉菜单中有很多选项，可以用JMeter测试应用程序。请求表示对webserver部分的采样器中提到的资源的操作。它也被称为HTTP动词。在JMeter中最常用的HTTP请求是Get, Patch, Post, Put, Delete, Options, Head, 和Trace。
如何使用JMeter的HTTP请求？ Get是用来请求给定资源的表示。带有Get选项的请求只接收数据。patch用于暗示对请求或资源的部分修改。Post用于向给定的资源提交一个单元，这将导致请求状态的改变。 Put是用来用有效载荷替换目标资源的所有给定表示。Delete是用来删除所述资源的。Head用于从Get请求中获得响应，但没有任何响应。选项用于定义目标资源的通信方法。跟踪用于在目标资源旁边执行消息回环。 JMeter HTTP请求配置 在高级配置中，用户可以移动到高级选项卡，检查是否需要测试或发送请求。在HTTPclient4中推荐了一个客户端实现选项，可以设置为默认选项。但如果需要，用户也可以利用Java实现。
超时是用来启动连接和配置毫秒的选项。例如，如果用户执行一个HTTP请求，服务器的连接时间和响应时间是最大的，并提到HTTP请求将自动停止。
用户可以在高级选项中检索HTML文件中的嵌入资源。当启动网站的URL时，HTML资源有不同的静态资源，如JavaScript，网站中的图像，在客户端有很少的代码，和CSS文件，可以添加到HTML元素的风格。在收到请求后，浏览器会接收HTML并进行解析。然后，它自动从新的HTTP请求中检索出所有的嵌入资源。用户可以启用检索嵌入式资源选项，使JMeter像浏览器一样行事。源地址选项给出了从适当的IP地址转接请求的功能和名称。代理服务器方法是另一个有用的选项，用户可以测试网站，这涉及到代理。用户可以给出服务器名称、IP、密码和用户名。
创建JMeter HTTP请求 要添加一个HTTP请求，添加线程组，添加采样器，并选择HTTP请求。在HTTP采样器中，配置两个字段，名称和注释。给予适当的名称和描述性的注释，便于在执行时检查。要配置基本请求，用户必须给出协议、IP、服务器名称、方法、路径和端口。
用户可以自动重定向请求，并检查服务器的响应是否在重定向范围内。如果该条目为真，它将导向该URL。如果添加了监听器，它类似于视图结果树。
KeepAlive用于保持连接值的活力，像请求头一样。
多部分配置内容值的类型与请求头类似。
浏览器兼容头用于抑制内容类型，对头文件进行编码，只发送内容处置头文件。
在最后一个窗口中，启用两个参数，即正文数据和参数，以向服务器发送请求信息。最后，文件上传选项被用来上传图片、视频和文件。
JMeter HTTP请求实例 在这个例子中，我们可以搜索从巴黎到法国的可用火车。首先，添加一个HTTP请求，然后在标签名称中，给搜索火车。让HTTPS成为协议。服务器名称或IP是主机名。该方法可以是一个Post。方法Post的主体包括来源和目的地的两个变量。符号可以是一个可以被编码的空间。最后，它可以被执行以查看结果。用户可以保存这个查询，以后可以使用。用户可以在浏览器本身的右上角进行检查。使用HTTP请求的最佳方法如下：
给予有意义的、简洁的名称，以便在执行时容易识别。
在默认的HTTP请求中，当JMeter中的每一个请求被发送到同一个服务器时，配置元素是隐含的。用户可以创建一个新的HTTP，在需要参数和路径的地方只给出相同的路径。
在测试计划中，将HTTP cookie管理器添加到根端，config元素必须管理服务器需要的所有cookie。然后，可以在HTTP请求中加入断言，以确保用户到达适当的网站。
结论 因此，HTTP请求在JMeter中被配置为将请求从网络服务器转送到负载测试部分。为了有效地实施，可以根据用户的要求，当时就改变设置中的所有字段。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
免费领取软件测试+自动化测试全套资料+软件测试面试真题+面试刷题工具+简历模板
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad45a0d4bcc8c9e24029d77bb11a3f3/" rel="bookmark">
			Selenium定位不到元素怎么办？一定要这么做
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Selenium进行自动化测试时，碰到无法定位元素该怎么办？这里总结了9种情况下的元素定位方法：
1、frame/iframe表单嵌套 WebDriver只能在一个页面上对元素识别与定位，对于frame/iframe表单内嵌的页面元素无法直接定位。
解决方法：
driver.switch_to.frame(id/name/obj) switch_to.frame() 默认可以直接取表单的id或name属性。如果没有可用的id和name属性，可以先定位到frame/iframe，再将定位对象传给 switch_to.frame(对象) 方法。
xf = driver.find_element_by_xpath('//*[@class="if"]') driver.switch_to.frame(xf) ... driver.switch_to.parent_frame() 切到父frame。影响性能，可以提给开发，让其改进。
driver.switch_to.default_content() 跳回最外层的页面
2、页面跳转到新标签页，或弹出警告框等 在页面操作过程中有时候点击某个链接会弹出新窗口，这时就需要切换焦点到新窗口上进行操作。
解决方法1：
driver.switch_to.window(window_handle) //切换到新窗口 首先获取当前窗口的句柄 driver.current_window_handle，接着打开弹出新窗口，获得当前打开的所有窗口的句柄driver.window_handles 。通过for循环遍历handle，如果不等于第一次打开窗口的句柄，那么一定是新窗口的句柄，因为执行过程只打开了两个窗口；改变条件，如果等于第一次打开窗口的句柄，那么可以切换回第一次打开的窗口。
解决方法2：
对于JavaScript生成的alert、confirm以及prompt，无法使用前端工具对弹出窗口进行定位的，使用driver.switch_to.alert 方法定位弹出框。
alert的方法有：
.accept() 等同于点击“确认”或“OK”
.dismiss() 等同于点击“取消”或“Cancel”
.text 获取alert文本内容，对有信息显示的alert框
.send_keys(text) 发送文本，对有提交需求的prompt框
.authenticate(username,password) 验证，针对需要身份验证的alert
3、页面元素失去焦点导致脚本运行不稳定 解决方法：
driver.switch_to.active_element 遇到脚本不稳定，有时会失去焦点导致测试失败的情况下，可以先切到焦点元素再进行操作。注意：.active_element后面不带括号()。
下面是一个参考案例：
driver.find_element_by_class_name('fnew').click() time.sleep(2) driver.switch_to.active_element.send_keys('filename') time.sleep(2) 4、使用Xpath或CSS定位 find_element_by_xpath("//标签[属性='值']") 使用Xpath/CSS方法，非常适合定位属性值动态生成、不容易定位的元素。如果不想指定标签，则可以使用“*”代替，使用xpath不局限于id、name和class这三个属性，元素的任意属性值都可以使用，只要它能唯一的标识一个元素。
解决方法1：
如果一个元素没有唯一属性，那么我们可以一级一级向上查找，直到找到可以唯一定位元素的属性，再向下查找其子元素。
find_element_by_xpath("//form[@id='form']/span[2]/input") 首先通过唯一标识属性id=form定位最外层元素，接着找到最外层元素下的第2个span标签的元素为父元素，最后向下查找定位到父元素下标签为input的子元素。
解决方法2：
如果一个属性不能唯一地区分一个元素，那么使用多个属性来唯一地定位一个元素。
find_element_by_xpath("//input[@id='kw'and@class='su']/span/input") 首先找到标签为input，id=kw且class=su的元素，接着找到其下标签为span的子元素，继续向下查找找到标签为input的子元素。
解决方法3：
检查Xpath描述是否有误，导致无法定位到元素。
5、页面还没加载出来就对页面上的元素进行操作 因为加载元素延时造成的脚本失败，我们可以通过设置等待时间来提升自动化脚本的稳定性。
解决方法1：
WebDriverWait() 显示等待，等待单个的元素加载，通常配合until()、until_not()方法使用。
WebDriverWait(driver,timeout,poll_frequency=0.5,ignored_exceptions=None) - driver - 传入WebDriver实例，必填 - timeout - 最长等待时间，必填 - poll_frequency - 调用`until`/`until_not`方法的时间间隔，默认为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad45a0d4bcc8c9e24029d77bb11a3f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cdac67976a62efd3c2ca676368b031a/" rel="bookmark">
			使用vpn后，不能正常上网或连接vpn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、控制面板
2、网络和internet
3、internet选项
4、连接
5、局域网设置
6、取消勾选代理服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a74836eadd01b109ff4d40ff54ae1ca/" rel="bookmark">
			ubuntu Setforeground 前台应用切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景分析 有这样一个系统，一个服务主进程用于接收指令，其它服务是独立的gui 程序，服务进程根据命令将对应的gui 程序切换到前台。
windows 平台有Setforeground 这个api，可以根据进程ID，将某个应用的窗口切换到前台。ubuntu 并没有类似的api， 这里借助xdotool 这个第三方库，实现类似的功能。
xdotool git clone 后，直接make，生成动态库libxdo 和执行程序程序 xdotool。
需求 SetForeGround 大概就是根据进程ID，并激活该窗口为前台窗口。用xdotool 命令实现如下
xdotool search --pid 进程ID #返回窗口id xdotool windowactivate 窗口ID search 返回的ID 如果有多个，是因为一个进程有多个窗口，需要根据窗口标题再筛选
实际应用中，一般直接调用库，代码实现如下：
bool SetForeground(uint32_t pid, const char* window_name) { Window *list = NULL; unsigned int nwindows; xdo_search_t search; xdo_t *context = xdo_new(NULL); memset(&amp;search, 0, sizeof(xdo_search_t)); search.max_depth = -1; search.require = xdo_search::SEARCH_ANY; search.pid = pid; search.searchmask = SEARCH_PID; do { if(list !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a74836eadd01b109ff4d40ff54ae1ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c741d33ecefe3b89a27898181594c7/" rel="bookmark">
			有屏RV1126部署QT应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇在RV1126上移植QT的文章，当时只是重点记录了项目移植的方法及交叉编译的配置等。RV1126只有buildroot系统，因此想要编译有界面的app需要借助QT和framebuffer实现。
下面记录一下如何通过buildroot的方式构建有界面的qt程序
首先在buildroot中添加QT5的内容
source envsetup.sh //选择rockchip_rv1126_rv1109 make menuconfig Target packages-&gt;Graphic libraries and applications (graphic/text)
开启 Qt5 下的 gui module 和 widgets module
保存退出
make savedefconfig ./build.sh rootfs 随后在 SDK/buildroot/package/rockchip/ 目录下，新建工程文件夹（QT Creator创建的项目名称，我的项目名称是qhyccd，下文提到的项目名称都是指这个），在文件夹中添加两个文件， Config.in 和 项目文件名.mk 。
Config.in
config BR2_PACKAGE_QHYCCD bool "qhyccd" help hya qt demo qhyccd.mk
################################################################################ # # qhyccd # ################################################################################ QHYCCD_VERSION = 1.0 QHYCCD_SITE = $(TOPDIR)/../app/qhyccd QHYCCD_SITE_METHOD = local TEST_LICENSE = Apache V2.0 TEST_LICENSE_FILES = NOTICE define TEST_CONFIGURE_CMDS cd $(@D); $(TARGET_MAKE_ENV) ~/workspace/rv1126SDK0/buildroot/output/rockchip_rv1126_rv1109/host/bin/qmake endef define QHYCCD_BUILD_CMDS $(TARGET_MAKE_ENV) $(MAKE) -C $(@D) endef define QHYCCD_INSTALL_TARGET_CMDS $(INSTALL) -D -m 0755 $(@D)/qhyccd $(TARGET_DIR)/usr/bin/qhyccd endef $(eval $(generic-package)) 2）移植源码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c741d33ecefe3b89a27898181594c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0579e8c09576907cbf3251df878194d7/" rel="bookmark">
			AKStream部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.git安装
sudo apt-get install git
2.docker安装
https://developer.aliyun.com/article/762674
3.安装.Net6运行环境
https://blog.csdn.net/qq_42754614/article/details/128308112
4.下载和编译ZLMediaKit流媒体服务器
https://github.com/ZLMediaKit/ZLMediaKit/wiki/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ee1dc32629fed6694e0a557d19f47b/" rel="bookmark">
			在浏览器的舞台上演：前端如何挑战页面刷新的极限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在浏览器的舞台上演：前端如何挑战页面刷新的极限 前言基础篇：location.reload()的妙用基本介绍：优缺点：优点：缺点： 适用场景： 进阶篇：Ajax带来的无刷新体验Ajax 基本用法：利用 Ajax 提升用户体验的方法：例子： 框架篇：Vue 和 React 的局部刷新Vue.js：示例： React.js：示例： 便捷性和性能优势： 实践篇：动态页面刷新的创意应用1. 实时数据更新2. 实时聊天3. 游戏动态更新4. 实时地图更新5. 实时投票或表决思考和实践方法： 前言 在无尽的数字海洋中，用户和浏览器之间建立了一座看不见的桥梁，连接了网页的现实与虚拟。而在这座桥上，JavaScript像是一位魔法师，可以通过各种巧妙的技巧，让页面焕然一新，展示出绚丽的景象。
这个博客将带你走进前端的奇妙世界，揭示页面刷新的幕后秘密。从简单的方法到高级的技术手段，我们将探讨如何在浏览器的舞台上演一场让用户眼前一亮的表演。
基础篇：location.reload()的妙用 location.reload() 是 JavaScript 中用于重新加载当前页面的方法。它有一些妙用，但也需要谨慎使用，因为页面的刷新可能会影响用户体验。以下是关于 location.reload() 的基础介绍以及一些相关的优缺点和适用场景。
基本介绍： location.reload() 方法用于刷新当前页面，它重新加载页面并保留当前页面的状态。这意味着用户正在填写的表单、滚动位置等状态都会被保留。这个方法可以通过直接调用或者在事件处理程序中使用，例如按钮点击事件。
// 直接调用 location.reload(); // 在事件处理程序中使用 document.getElementById('refreshButton').addEventListener('click', function() { location.reload(); }); 优缺点： 优点： 简单易用： location.reload() 是一种非常简单的刷新页面的方法，适用于快速的页面更新需求。保留状态： 页面刷新后，用户当前的状态（例如表单数据、滚动位置）会被保留，不会丢失。 缺点： 用户体验： 强制刷新页面可能会打断用户的操作，影响用户体验。在某些情况下，最好使用更细粒度的刷新策略，例如局部刷新而不是整个页面刷新。性能开销： 整页刷新会重新加载所有资源，包括不必要的资源，导致性能开销。在需要频繁刷新的场景中，可能会影响网页加载速度。 适用场景： 简单页面更新： 当页面只需进行简单的更新而不涉及复杂的逻辑时，可以使用 location.reload()。开发调试： 在开发过程中，如果需要强制刷新页面以查看最新的代码变更，可以使用此方法。用户交互不频繁的页面： 如果页面上的交互较少，用户不太可能在刷新时失去重要数据，那么可以考虑使用 location.reload()。 总的来说，location.reload() 是一个简单而有效的页面刷新方法，但在使用时需要谨慎，特别是在强制刷新整个页面可能影响用户体验的情况下。在一些情境中，考虑使用更细粒度的刷新策略，比如局部刷新，以提高性能和用户体验。
进阶篇：Ajax带来的无刷新体验 进阶篇：Ajax带来的无刷新体验
Ajax（Asynchronous JavaScript and XML）是一种用于创建快速动态网页的技术，它允许在不重新加载整个页面的情况下，通过异步请求与服务器进行数据交换。通过使用Ajax，可以实现局部刷新，从而提升用户体验。
Ajax 基本用法： 创建 XMLHttpRequest 对象：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ee1dc32629fed6694e0a557d19f47b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd886670ee26a0cea7c03fddde235420/" rel="bookmark">
			JavaScript的过滤大师：深度解析Filter用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript的过滤大师：深度解析Filter用法 前言基础篇`filter`的基本用法语法示例 自定义过滤函数数组对象的过滤复杂条件的筛选常见应用场景性能优化注意性能的建议在大规模数据集下的优化方法 案例分析实际案例：用户筛选使用 `filter` 方法解决问题代码优化的实践 最佳实践与技巧 前言 在编程的世界里，数组就像是一本百科全书，而filter方法则是其中一张魔法的页。这个神奇的滤镜能帮你筛选出数组中的精华，让你的代码变得更为简洁和高效。本文将带你穿越到JavaScript的滤镜世界，揭开filter方法的神秘面纱。
基础篇 filter的基本用法 filter 是 JavaScript 数组的一个高阶函数，用于过滤数组中的元素，并返回一个满足条件的新数组。filter 接受一个回调函数作为参数，该回调函数定义了过滤条件。
以下是 filter 的基本用法：
语法 const newArray = array.filter(callback(element[, index[, array]])[, thisArg]); callback: 用于测试每个元素的函数。接受三个参数： element: 当前被处理的元素。index（可选）: 当前被处理的元素的索引。array（可选）: 调用 filter 的数组。 thisArg（可选）: 执行 callback 函数时，用于设置 this 的值。 示例 过滤偶数：
const numbers = [1, 2, 3, 4, 5, 6]; const evenNumbers = numbers.filter(function (num) { return num % 2 === 0; }); console.log(evenNumbers); // 输出: [2, 4, 6] 过滤长度大于等于3的字符串：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd886670ee26a0cea7c03fddde235420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb82876b742498b96002c2f7a205954/" rel="bookmark">
			源启容器平台KubeGien 打造云原生转型的破浪之舰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云原生是应用上云的标准路径，也是未来发展大的趋势。如何将业务平滑过渡到云上？怎样应对上云期间的各项挑战呢？中电金信基于金融级数字底座“源启”打造了一款非常稳定可靠、多云异构、安全可控、开放灵活的容器平台产品——源启容器平台KubeGien，是源启四大平台之一的数字基础支撑平台重要组成部分，源启通过该平台向上实现应用的云原生容器化支撑，向下屏蔽多种异构底层基础计算环境的差异，助力广大用户打造云原生转型的破浪之舰，一路披荆斩棘、砥砺前行。
​
提到云化转型，不得不提及云原生。什么是云原生呢？01 云化转型的征程——产品概念
它是以容器、微服务、DevOps为代表的技术体系和方法论，应用生于云并且成长于云，是应用上云的标准化实现路径。云原生能够最大程度发挥云的优势，有极致的弹性，服务故障时可自愈，具备大规模可复制的能力，助力实现异构资源标准化，重塑IT数字基础设施。
为什么说云原生重塑了IT底层基础设施呢？​
举例说明，传统的IT基础设施就像铁锅大烩菜，所有东西混杂在一起，一不小心就会串味儿。用虚拟机基础设施就好比砂锅米线，不会串味但是有点废锅人手一个。最后云原生基础设施则好比鸳鸯火锅，用更少的资源去搭配更多的东西，界限分明不串味儿，从而更好地降本增效和管控资源。
01 传统IT基础设施业务部署模式
物理机承载一切，堆叠杂乱，业务规模起来，无法运维。
02 虚拟机基础设施部署模式
分类有序部署，但虚拟机遍地，动辄上千License费用、运维成本、资源浪费(需要太多船)。
03 云原生数字基础设施部署模式
集装箱(容器)屏蔽货物属性，堆叠有序，管理通过货运码头(kubernetes)有序调度。
但云原生转型之路并不平坦，常常面临各种问题，比如硬件兼容性、成本问题、服务集成、稳定性和易用性等，需要借助“杀器”一一化解。源启容器平台KubeGien就像055导弹驱逐舰，帮助用户消灭云原生转型之路上的敌人，清除障碍。
云原生转型遇到的各种问题
055型驱逐舰是中国海军有史以来建造的吨位最大、技术先进的全能型防空驱逐舰，是我国海军驱逐舰发展史上一个重要的里程碑，也是航母身边当之无愧的“带刀侍卫”。就像055一样，源启容器平台KubeGien在垂发、指挥、雷达、操控、近防、舰炮等装备性能上，具备灵活的PAAS服务集成、异构资源统一管理、灵活分级一云多芯、智能弹性应用管理、稳定安全容器底座以及易用灵活服务能力，依靠六大杀手锏为用户打造云原生转型之路上的破浪之舰。
源启容器平台KubeGien的“055型六大杀手锏”
02 如何构筑破浪之舰——产品架构
如何构建破浪之舰？灵活可靠的产品架构是这艘破浪之舰的龙骨。
技术架构上，源启KubeGien容器平台以kubernetes为代表的云原生技术作为基础，为金融、泛金融、能源、电力等行业用户，提供应用管理、集群管理、镜像管理、资源管理等全栈服务，最大化实现云原生的价值。
技术架构采用了分层模块化的设计思路，功能上整个系统由六大部分组成，分别是面向用户的服务门户、提供API接口的API Server、提供核心功能的核心服务、提供辅助功能的扩展服务、采用可插拔模式的服务插件以及提供基本能力的容器底座。
产品功能架构
就像055要能适应各种作战任务一样，源启容器平台为了适应多种业务场景，采用“三群两面”的部署架构（控制节点集群、工作节点集群、存储节点集群 、管理&amp;业务网络平面、存储网络平面），将管理节点进行集群部署并结合多网络平面，提升系统的稳定性。
03 攻坚克难的杀器——产品能力
源启容器平台以“开源、成熟、灵活”为原则，采用主流成熟开源项目+自研增强的方式进行产品研发。在GPU虚拟化、虚拟机负载、安全容器、Pod故障诊断等方面均做了自研和增强。值得一提的是，中电金信源启容器平台团队多人通过CKA认证，同时积极进行开源社区贡献，最近一年提交了10余项开源社区贡献。
源启容器平台KubeGien产品凭借六大能力为用户的云原生转型之路保驾护航。
1. PAAS服务集成——“垂发”、灵活
冷热共架的大型国产垂直导弹发射系统，是055的杀手锏之一，能够在一个垂直发射单元中同时装填多枚导弹，并兼容多种武器系统。那么这种垂直发射、一坑多弹的先进理念能否应用于我们的KubeGien容器平台呢？答案是肯定的。
丰富解耦的服务集成
产品在设计之初没有采用部分友商“全家桶”式的服务绑定模式，而是希望可以通过容器平台产品与其他服务进行灵活的、解耦式的服务集成能力，为用户提供符合自身实际需要的产品能力集合，产品之间均通过标准开放的API接口进行对接，既可整体提供服务，也可以拆分单独提供。
为了丰富破浪之舰的武器库，应对实际执行任务中错综复杂的场景，KubeGien容器平台在业界首次提出云原生适配层概念，向下屏蔽底层平台差异，向上提供云原生适配层货架能力，产品按需适配模块化功能，增强集成产品能力，降低开发成本与复杂度，提升应用交付效率。
2. 异构资源统一管理——“指挥”、统管
055型驱逐舰采用了最新的数字化技术，配备了高性能的指挥和通信系统，能够快速响应指挥部的指令，并精准执行各项任务。源启KubeGien容器平台对异构资源进行统一管理，具备多集群管理能力、随需而动的混合负载、按需分配GPU资源。
统一管理的多云集群
Q ：当前金融行业生产环境愈发复杂，通常会部署多个分布于不同数据中心的Kubernetes集群，如何运维？如何监管？如何快速进行应用发放？
A ：借助KubeGien容器平台，用户可轻松进行多集群场景下的统一资源管理，通过纳管接入、跨集群调度、自定义策略下发和标准开放接口等核心能力，实现分布式集群的可见、可管、可用。
随需而动的混合负载
Q ：对于暂时无法进行容器化改造的虚拟化应用如何处理，或者能否在同一平台对现有虚拟化负载和容器化负载进行统一管理，能不能鱼与熊掌兼得？
A ：KubeGien除支持容器类型负载外，还支持虚拟化类型负载，用户可在服务门户上创建虚拟机，并和容器负载一样进行生命周期管理和控制台访问，轻松满足混合负载的需求。
按需分配GPU资源
Q ：结合具体使用场景，产品对于算力资源又该如何分配？
A ：为了满足用户对高性能计算、视频处理或图形渲染的需求，KubeGien容器平台提供GPU资源给有需求的用户使用，既可以多任务共享使用GPU设备资源，也可以在特定租户及项目内进行GPU资源专用。
3. 灵活分级一云多芯 ——“雷达”、兼容
055型驱逐舰安装了双波段的相控阵雷达，为组织指挥防空反导作战提供了敏锐的“视力”和聪明的“脑力”，防空防导作战能力全面提升。KubeGien容器平台通过灵活分级的资源模型和一云多芯的信创适配能力兼容多种用户场景。
灵活分级的资源模型：KubeGien采用四级资源模型设计，对集群资源进行逐级分解抽象，提供不同粒度的管控能力，每个层级都可以进行资源配额管控，构建了高度灵活的分级资源模型，不论用户自身容器集群规模如何，都可充分对资源进行细粒度的管理。
一云多芯的信创适配：随着信创政策的实施，许多用户存在多种芯片架构服务器混用的场景，KubeGien针对这种情况专门提供一云多芯服务，为用户提供硬件资源异构管理能力，构建不同类型云原生物理资源池，通过上层云原生引擎的兼容性和调度能力，为用户提供满足不同场景所需的资源适配需求。
一云多芯的信创适配
4. 智能弹性应用管理 ——“舰炮”、快速
055型驱逐舰装备有种新型武器系统，能够在多个领域发挥重要作用。其中近防炮被网友称之为"土豪炮"，每秒能发射166发炮弹，每分钟发射近万枚炮弹。KubeGien容器平台也支持智能弹性的应用管理和业务应用快速上线，方便用户使用。
应用管理弹性伸缩：应用上云后的一大变化就是从以往围绕计算、网络、存储这些资源为重心，转变为以应用生命周期为重心。源启容器平台立足这一点，从应用管理的两个重要支撑技术（应用包管理和应用镜像管理）出发，形成双仓库的管理和基于Helm Chart包的应用生命周期管理能力。用户可以在平台上传和下载应用包和镜像，并支持在分布式集群中对应用进行分发部署。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcb82876b742498b96002c2f7a205954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77a89663f62531adb04b2132ca992a84/" rel="bookmark">
			报错：Error creating bean with name ‘Controller‘，Unsatisfied dependency expressed through field ‘Servic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错来源： 初始化项目生成代码注解不全 或 路径有错 报错信息： org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘sysUserController’: Unsatisfied dependency expressed through field ‘sysUserService’; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘sysUserService’: Unsatisfied dependency expressed through field ‘baseMapper’; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type ‘com.xyz66.mapper.SysUserMapper’ available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
解决方案： 1.添加@MapperScan扫描mapper注解 2.添加@Mapper注解 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca522c11d5311151a8452364a55eca2f/" rel="bookmark">
			【论文阅读】Swin-transformer网络结构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 之前的Transformer主要应用在NLP领域，从ViT开始在应用在视觉领域后，也逐渐出现更多Transformer在视觉领域的研究工作，今天介绍的Swin-transformer可以作为计算机视觉上的一种通用backbone。
优点 提出了一种层级式网络结构，解决视觉图像的多尺度问题。
提出了Shifted Windows，极大降低了transformer的计算复杂度。
可以广泛应用到所有计算机视觉领域(包括分类任务、分割任务、目标检测任务等)
解决的问题 和NLP领域不同，视觉领域同类的物体，在不同图像上/同意图像上的尺度会相差很大。
相较于文本，图像的尺寸过大，计算复杂度更高。
创新处 使用任意尺度的输入，计算复杂度和图像大小是线性关系而非平方级增长。
在小窗口内计算自注意力，特征图大小递减。好处是当窗口大小固定时，自注意力的复杂度就固定，复杂度和尺度呈线性关系，利用了图像的局部性的先验知识。
局部性指的是同一个物体不同部位或者语义相近的不同物体，大概率会出现在相邻的地方，所以对视觉任务来说，在小窗口内计算自注意力是合理的，在全局计算会造成计算的浪费。
和ViT区别 整体架构 网络架构 下图是Swin-transformer的网络架构：
整体架构分为多个stage，输入图片大小为H*W*3；(默认为224*224*3)
经过patch partition操作将输入图片打成多个patch；patch size=4*4，则操作后得到的图片大小为56*56*48；
stage1：包括一个Linear Embedding操作和2个swi-transformer block，C代表一个超参数，即Transformer可以接受的值，对于Swin-Tiny 网络来说，C默认为96，此时维度变成56*56*96；(transformer block块不改变图片大小)
这里的patch partition操作和Linear Embedding操作相当于ViT的Linear Projection操作，而在代码中，利用一次卷积操作即可完成。
stage2：包括Patch Merging和2个block，Patch Merging相当于pixel shuffle的逆操作；具体如下图所示，此时维度为28*28*192；对于Patch Merging操作整体来说，空间维度减半，通道数量×2，这样和卷积神经网络完全对等；
stage3：重复stage2，维度为14*14*384；
stage4：重复stage2，维度为7*7*768.
上述架构图中b图是两个连续的Swin Transformer Block。一个Swin Transformer Block由一个带两层MLP的shifted window based MSA组成。在每个MSA模块和每个MLP之前使用LayerNorm(LN)层，并在每个MSA和MLP之后使用残差连接。两层属于一个组合使用，所以stage中的block块是双数。
滑动窗口(shifted Windows) 论文中一个主要亮点是提出了滑动窗口的概念。
同时给出普通MSA和基于窗口的W-MSA(计算复杂度)的比较：
W-MSA虽然降低了计算复杂度，但是不重合的window之间缺乏信息交流，于是进一步引入shifted window partition：一种基于掩码的方式来解决不同window的信息交流问题，该方法在连续的Swin Transformer块中的两个Swin Transformer Block之间交替进行。
移动窗口达到了窗口与窗口之间的通信，但窗口数量增多（从原来的4个到之后的9个）且增多后各个窗口元素大小不同，而基于掩码的方式可以很好的解决这一问题。经过循环移位后在切分四宫格，则得到的还是4个窗口，再各个窗口做基于掩码的Mutil-Self Attention，最后操作是还原循环移位。
关于掩码的操作：
实验结果 分类实验 目标检测实验 语义分割实验 在多个任务中均可以达到很好的效果，也证明了Transformer完全可以在多个领域取代CNN。
论文地址及代码 论文：Swin Transformer: Hierarchical Vision Transformer using Shifted Windows
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca522c11d5311151a8452364a55eca2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd3d5e2766d108da89f7f43c54c5ff9/" rel="bookmark">
			深度学习系列54：使用 MMDETECTION 和 LABEL-STUDIO 进行半自动化目标检测标注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考https://mmdetection.readthedocs.io/zh-cn/latest/user_guides/label_studio.html，这里进行简要概述：
1. 启动目标检测服务 在mmdetection文件夹中，执行
label-studio-ml start projects/LabelStudio/backend_template --with \ config_file=configs/rtmdet/rtmdet_m_8xb32-300e_coco.py \ checkpoint_file=...pth \ device=cpu \ --port 8003 2. 启动labelstudio 另开一个terminal，执行
label-studio start 打开浏览器访问 http://localhost:8080/ ，建立一个新项目。此时不要着急save，需要先点击后面的Labeling Setup连接第一步的目标检测服务
3. 连接服务 按照如图顺序点击
看到如下 Connected 就说明后端推理服务添加成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa82508c4dcbc59079afe5bff5d5b3d/" rel="bookmark">
			【项目实战】Python实现循环神经网络RNN-LSTM回归模型项目实战(股票价格预测)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：这是一个机器学习实战项目（附带数据+代码+文档+代码讲解），如需数据+代码+文档+代码讲解可以直接到文章最后获取。
1.项目背景 金融一直是现代社会非常热门的一个研究方向，随着社会的发展，越来越多的数学方法被应用于金融领域的描述中。我们寄希望于用一种更客观地表达来研究金融。而股票市场作为一个看似门槛极低的金融市场，参与者众多，与利益直接挂钩，是金融市场的一个大热研究方向。
中国股市于 1989 年开始试运行，自此，开始了中国股市近30年的起起伏伏。中国股市虽相较于美国股市还没有很成熟，但是经过30年的发展，也在逐渐向一个成熟的市场发展。截至2019年，沪深A股交易股票已有3589只，如何在其中筛选出有潜力的股票，或者说如何对股票价格进行短期的预测，这在深度学习日趋兴起的背景下，成为了我们想要尝试解决的一个问题。
2.数据获取 本次建模数据来源于网络(本项目撰写人整理而成)，数据项统计如下：
数据详情如下(部分展示)：
3.数据预处理 3.1 用Pandas工具查看数据
使用Pandas工具的tail()方法查看后十行数据：
关键代码：
3.2查看AAPL公司股票数据的描述性统计分析
使用Pandas工具的describe()方法AAPL公司的描述性统计分析信息：
从上图可以看到，AAPL公司股票数据开盘价、最高价、最低价、收盘价、成交量的平均值、标准差、最小值、中位数、最大值。
关键代码：
3.3查看AAPL公司股票数据的摘要信息
通过Pandas工具的info()方法来查看AAPL公司股票数据的摘要信息：
通过上图可以看到，总共有6个数据项，1259条数据，数据时间范围为2013到2018年，数据中无缺失值。
关键代码如下：
4.探索性数据分析 4.1 绘制股票收盘价曲线图
用Pandas工具的plot()方法进行绘图，图形如下：
通过上图可以看到，4家公司的股票收盘价格基本每年呈上升趋势。
4.2 绘制股票成交量曲线图
从上图中可以看到，每家公司股票的成交量基本都是在一定的范围内进行波动。
4.3 绘制股票收盘价10天、20天、50天累计曲线图
从上图中可以看到，APPLE公司股票收盘价10天、20天、50天内累计收盘价呈上升趋势，而APPLE公司股票收盘价比较稳定。
关键代码：
4.4 绘制股票日收益曲线图
从上图中可以看到，每家股票的日收益都存在一定的波动，同时也说明了股票有风险、入市需谨慎。
关键代码如下：
4.5 绘制股票日收益直方图
从上图中可以看到，4家公司的日收益均集中在-0.05-0.05之间。
关键代码：
4.6 相关性分析
通过Pandas工具的corr()方法进行相关性分析：
从上图可以看到，除成交量外其它数据项之间相关性比较高。
5.特征工程 5.1 建立特征数据和标签数据
close为标签数据，除 close之外的为特征数据。关键代码如下：
5.2 数据集拆分
训练集拆分，分为训练集和验证集，70%训练集和30%验证集，关键代码如下：
5.3 数据归一化
通过MinMaxScaler工具进行数据的归一化，把数据缩放到0-1区间，关键代码如下：
6.构建LSTM回归模型 Hochreiter 等学者（1997）[21]提出了长短时记忆单元（Long Short-Term Memory，LSTM）用于改进传统的循环神经网络模型（RNN），该模型通过门的开关实现时间上的记忆功能，并反之梯度小时，实验结果表明，LSTM 能有效地解决 RNN 训练时的梯度爆炸和梯度消失问题。2005 年，Alex Graves，Jürgen Schmidhuber[22]提出了使用完全的后向传播方式训练 LSTM 模型，使得LSTM 的实现过程更加可靠。2015 年，Chung 等学者提出了简化版本的LSTM，门控反馈 RNN（GF-RNN）通过允许和控制从上部复现层流向下层的信号，使用每对层的全局选通单元，扩展了堆叠多个复现层的现有方法。层之间交换的递归信号基于先前的隐藏状态和当前输入自适应地选通。相比于传统的神经网络模型。LSTM 神经网络模型对于神经组织的认知过程的模拟更为准确。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa82508c4dcbc59079afe5bff5d5b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c848db7177a1db29ab84a85834fcb2d/" rel="bookmark">
			pandas &#43;re获取pubmed中文献的标题和摘要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pubmed 网站 https://pubmed.ncbi.nlm.nih.gov/
后面加上文献的pmid号就可以查询到该文献的详情页
爬虫逻辑就是，requests获取网页源代码，正则表达式进行提取，得到我们需要的内容就好了
import requests import re key=input("请输入你想查找的信息：") #即你在pubmed查找的关键词，推荐看一下pubmed能不能查询到 local_url=input("请输入你想存储的位置及名称：") #是位置加名称哈 turl="https://pubmed.ncbi.nlm.nih.gov/" tdata=requests.get(turl,params={"term":key}).text pat_allpage='&lt;span class="total-pages"&gt;(.*?)&lt;/span&gt;' allpage=re.compile(pat_allpage,re.S).findall(tdata) num=input("请输入大致想获取的文章数目（总数为"+str(int(allpage[0].replace('\n ','').replace(',',''))*10)+"):") for j in range(0,int(num)//10+1): url="https://pubmed.ncbi.nlm.nih.gov/"+"?term="+key+"&amp;page="+str(j+1) data=requests.get(url,params={"term":key}).text pat1_content_url='&lt;div class="docsum-wrap"&gt;.*?&lt;.*?href="(.*?)".*?&lt;/a&gt;' content_url=re.compile(pat1_content_url,re.S).findall(data) hd={'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0','User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3741.400 QQBrowser/10.5.3863.400'} for i in range(0,len(content_url)): curl="https://pubmed.ncbi.nlm.nih.gov/"+content_url[i] try: cdata=requests.get(curl,headers=hd).text pat2_title="&lt;title&gt;(.*?)&lt;/title&gt;" pat3_content='&lt;div class="abstract-content selected".*?&gt;(.*?)&lt;/div&gt;' pat4_date='&lt;span class="cit"&gt;(.*?)&lt;/span&gt;' title=re.compile(pat2_title,re.S).findall(cdata) print("正则爬取的题目是："+title[0]) content=re.compile(pat3_content,re.S).findall(cdata) date=re.compile(pat4_date,re.S).findall(cdata) fh=open(local_url+".html","a",encoding="utf-8") fh.write(str(title[0])+' ----'+str(date[0])+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c848db7177a1db29ab84a85834fcb2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31abdd5baa969ccb5ded2f8174798255/" rel="bookmark">
			【Linux】了解文件的inode元信息，以及日志分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、inode表结构，以及元信息
1、了解inode信息有哪些
2、关于inode表的说明
Linux中访问文件的过程：
3、硬连接与软连接的区别，（请看前面，写过的）
二、文件系统的备份与恢复
三、几种常见的日志
四、系统日志管理
1、根据信息的优先级别重要程度，设置日志消息的不同级别
2、rsyslog配置文件的格式
实操1、修改/etc/rsyslog.cong和/etc/ssh/sshd_config配置文件，将ssh服务的日志单独生成，便于查看
实操2、修改/etc/rsyslog.cong配置文件，打开tcp或udp端口，共享传输日志信息
五、journalctl日志管理
案例说明
一、inode表结构，以及元信息 1、了解inode信息有哪些 inode表的元信息有哪些inode号相当于文件的身份证号文件类型七大文件类型文件权限读、写、执行文件属主uid文件属组gid文件硬链接数指向文件名路径名称的个数该文件占块的大小块大小该文件的实际大小实际大小文件的三种时间atime访问时间，mtime修改时间，ctime元信息变化时间指向磁盘上文件的数据块指针　指向真实数据的块（可以理解为坐标）有关文件的其他数据　不知道啥意思，理解为间接指针等等 查看inode号的命令方法：ls -i和stat
关于文件的三种时间戳
最近访问atime：最后一次查看文件（cat、vim、more、less、head、tail等）
最近更改mtime：最近更改文件内容的时间，注意：更改完内容之后，ctime也会改变（内容改变）
最近改动ctime：最近更改文件元信息的时间，比如改变权限等（mtime变化ctime也会跟着变）
2、关于inode表的说明 ①文件是存储在硬盘上的，硬盘的最小存储单位叫做“扇区”(sector)，每个扇区存储512字节。 一般连续八个扇区组成一个"块”(block)，一个块是4K大小，是文件存取的最小单位。操作系统读取硬盘的时候，是一次性连续读取多个扇区，即一个块一个块的读取的。4k一读,8个扇区一读文件数据包括实际数据与元信息(类似文件属性)。文件数据存储在“块"中，存储文件元信息(比如文件的创建者、创建日期、文件大小、文件权限等)的区域就叫做inode表。 因此，一个文件必须占用一个inode，并且至少占用一个block。 ②du 显示inode不包含文件名。文件名是存放在目录文件夹当中的。Linux 系统中一切皆文件，因此目录也是一种文件。 ③每个inode都有一个号码，操作系统用inode号码来识别不同的文件。Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称，文件名和inode号码是一一对应关系，每个inode号码对应一个或多个文件名。 ④同一设备上，不可能出现相同inode号（不同设备可以）；inode号的数量与硬盘分区大小有关，可以使用df -i查看，inode号是有限制的！！
Linux中访问文件的过程： 当用户在Linux系统中试图访问一个文件时，系统会先根据文件名去查找它对应的inode号码:通过inode号码，获取inode信息;根据inode信息，看该用户是否具有访问这个文件的权限;如果有，就指向相对应的数据block，并读取数据。
3、硬连接与软连接的区别，（请看前面，写过的） 硬连接软连接本质与源是相同的文件与源不是一个文件inode号与源相同与源不同文件类型与源相同，不是l与源不同，为l目录不能对目录创建可以对目录创建文件大小与源文件一样文件大小与源路径字符有关修改内容修改源一起生效修改源一起生效删除删除源无影响删除源失效权限修改权限一起生效原本权限就不同，修改权限不一起生效连接数连接数一样，有多少个硬连接就是连接数与源连接数不一样，软连接始终为1 二、文件系统的备份与恢复 ext4文件不能备份和恢复，xfs文件系统可以恢复
[root@localhost ~]# xfsdump -f /opt/dump_sdb2 /dev/sdb2 [-L dump_sdb1 -M sdb1] # 命令 指定备份目录路径和文件名 分区 打上标记 现在不打后面也要输入 #使用 xfsdump 命令备份整个分区 并打上标记 [root@localhost opt]#xfsrestore -f /opt/dump_sdb1 /data/ # 使用 bak文件 将数据恢复到 /data 下 [root@localhost opt]#ls /data/ passwd test 这个之前写过了，请查看这篇文章https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31abdd5baa969ccb5ded2f8174798255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36857e8f90d92c1da9ad45922764e1e0/" rel="bookmark">
			函数式编程框架 functionaljava 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、函数式编程起源二、functionaljava 框架简介 一、函数式编程起源 ​ 函数式编程起源于数理逻辑（范畴论，Category Theory），起源于λ演算，这是一种演算法，它定义一些基础的数据结构，然后通过归约和代换来实现更复杂的数据结构，而函数本身也是它的一种数据。所以函数式编程语言（ Scala、Groovy、Clojure 、Haskell 等）中引入了一些数学上抽象的知识，需要借助于相关知识来辅助学习。
λ演算是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它由数学家阿隆佐·邱奇在 20 世纪 30 年代首次发表。lambda 演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值，它能模拟单一磁带图灵机的计算过程；尽管如此，lambda演算强调的是变换规则的运用，而非实现它们的具体机器。
—摘自于 wikipedia
函数式编程的特性如下（下面介绍的 functionaljava 框架基本实现了这些特性）：
函数是一等公民闭包和高阶函数惰性（Lazy）计算：每一步都是单纯的运算，而且都有返回值。纯函数：输入一定时，输出一定。即输出不受外部环境影响，同时也不影响外部环境，无副作用。递归调用函数柯里化：函数元降维技术Immutable 不可变性Composition 函数组合：将多个单函数进行组合，像流水线一样工作… 这里讲述函数式编程起源的原因是为了更好地理解函数式编程：λ演算是函数式编程的基础（比如λ演算能模拟单一磁带图灵机的计算过程），编程式语言都具备λ演算的规则和特性。
二、functionaljava 框架简介 ​ JDK8 引入了 lambda 表达式，吸收了函数式编程的部分特性，目的是对现有编码语义的优化，减少语法冗余。轻量级的将代码封装为数据，使代码简洁，易于理解。但 Java 非函数式编程语言。（有兴趣的同学可结合函数式编程的起源来理解 JDK8 的 lambda 表达式使用）。functionaljava 框架是一个提升 Java 函数式编程的开源库，该库实现了许多基本和高级编程抽象，有助于面向组合式的开发。该框架同样可以作为学习函数式编程概念的平台。
​ 学习一种新概念需要进行思维的转变，函数式编程不同于面向对象编程，最好结合 functionaljava 中的 demo 和源码来理解函数式编程思想。以下是 functionaljava 框架的知识图谱：
附：functionaljava github 地址：https://github.com/functionaljava/functionaljava
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c53705402b7d4f2d8f02494cf4ba89/" rel="bookmark">
			【Linux】冯诺依曼体系结构、操作系统、进程概念、进程状态、环境变量、进程地址空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、冯诺依曼体系结构二、操作系统(OS)1. 操作系统是什么2. 操作系统如何做管理3. 系统调用和库函数概念 三、进程1. 进程是什么？2. 描述进程-PCB3. 查看进程的方法 四、进程状态1 运行、阻塞和挂起状态2 Linux中的进程状态 五、进程优先级1. 什么是优先级2.查看优先级3. 修改优先级 六、其他概念七、环境变量1.引入2.环境变量和本地变量的关系3.命令行参数表和环境变量表4.子进程获取环境变量的方式 八、进程地址空间1.虚拟地址空间的引入2.虚拟地址空间布局 3.为什么要存在虚拟地址空间？ 一、冯诺依曼体系结构 冯诺依曼思想包括：存储程序、程序控制和计算机的五大功能部件。
存储程序：将程序存放在计算机的存储器中。
程序控制： 按指令地址访问存储器并取出指令，经译码依次产生指令执行所需的控制信号，实现对计算的控制，完成指令的功能。
五大功能部件：控制器、运算器、存储器、输入设备、输出设备。
其中，运算器完成算术运算、逻辑运算，
控制器控制指令的执行， 根据指令功能给出实现指令功能所需的控制信号；
控制器和运算器构成了中央处理器CPU。
存储器就是内存，存放程序和数据，带电存储，具有掉电易失的特性。
输入设备能够输入操作者提供的原始信息，并将其转化为机器能识别的，如键盘、鼠标等。
输出设备将计算机处理的结果用人们或其他机器能够接受的方式输出，如显示屏。
在不考虑缓存的情况下，CPU只能对内存进行读写，不能直接访问其他设备。外设（输入设备或输出设备）想要输入或输出数据，也只能写入内存或从内存中读取。 二、操作系统(OS) 1. 操作系统是什么 操作系统是一个进行软硬件资源管理的软件。
操作系统包括：内核（进程管理、内存管理、文件管理、驱动管理）、其他程序（如函数库，shell程序等等）
操作系统为什么对软硬件资源进行管理呢？ 操作系统通过管理好软硬件资源(手段)，给用户提供良好(安全、稳定、高效、功能丰富)的执行环境(目的)。
2. 操作系统如何做管理 先描述，在组织。将需要管理的对象用结构体描述，再将每个结构体进行连接，形成链表一样的数据结构。
当操作系统下达命令后，驱动程序就会对这些结构进行增删查改等操作。
计算机的层状结构：
3. 系统调用和库函数概念 系统调用：在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。在执行一段程序时，比如printf(“hello world”)时，实际上进行了系统调用，但我们并不知道，因为编译器帮你做了。库函数：系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更上层用户或者开发者进行二次开发。 三、进程 1. 进程是什么？ 进程是程序的一个执行实例，是正在执行的程序。
以上是书本中的概念，一句话来概括：进程=内核描述进程的数据结构+当前进程的代码和数据。
当我们写好一段代码经过编译、链接等过程后生成了可执行程序，此时的可执行程序是一个文件，存储在磁盘中。当我们运行该程序时，该程序的代码和数据就会被加载到内存中。此时操作系统会将进程的各种属性放在一个叫做PCB的结构体中，并将PCB用链表等数据结构管理起来，方便进行增删查改。
2. 描述进程-PCB 进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合。课本上称之为PCB（process control block），Linux操作系统下的PCB是：task_struct。 Linux中描述进程的结构体叫做task_struct，它会被装载到RAM(内存)里并且包含着进程的信息。
task_struct内容分类
标示符：描述本进程的唯一标示符，用来区别其他进程。状态：任务状态，退出代码，退出信号等。优先级：相对于其他进程的优先级。程序计数器：程序中即将被执行的下一条指令的地址。内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针。上下文数据：进程执行时处理器的寄存器中的数据。I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表。记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。其他信息。 3. 查看进程的方法 进程的信息可以通过/proc系统文件夹查看
要获取PID为1的进程信息，需要查看/proc/1这个文件夹。
大多数进程信息同样可以使用top和ps这些用户级工具来获取。
当我们执行上述程序，便可以通过以下指令查询到该进程的信息。
通过系统调用查看进程PID进程id：PID，通过getpid()获取父进程id：PPID，通过getppid()获取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c53705402b7d4f2d8f02494cf4ba89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0118b77822cecd6fca6161ccdf473888/" rel="bookmark">
			JUnit 单元自动化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Junit 是什么？ Junit 是 Java 中用于单元测试的框架。使用 Junit 能让我们快速高效的完成单元测试。
自动化测试：JUnit提供了自动化测试的能力，开发人员可以编写一次测试用例，然后通过简单的命令或集成到持续集成工具中进行反复运行，大大减少了重复性的测试工作量。注解和断言：JUnit使用注解对测试方法进行标记，使用断言进行结果验证，让测试用例编写更为简洁、直观，同时减少了手动编写测试代码的出错概率。 传统模式下，我们写完代码想要测试这段代码的正确性，那么必须新建一个类，然后创建一个 main() 方法，然后编写测试代码。如果需要测试的代码很多呢？那么要么就会建很多main() 方法来测试，要么将其全部写在一个 main() 方法里面。这也会大大的增加测试的复杂度，降低程序员的测试积极性。而 Junit 能很好的解决这个问题，简化单元测试，写一点测一点，在编写以后的代码中如果发现问题可以较快的追踪到问题的原因，减小回归错误的纠错难度。
二、配置 Junit 环境 配置 Junit 只需要在单元测试中导入相关依赖即可，我们这里使用的是 Junit5。maven 地址：https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api/5.8.2
&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.8.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 下面我们写个demo测试一下是否导入成功：
import org.junit.jupiter.api.Test; public class JunitTest { @Test void testDemo() { System.out.println("这是第一个单元测试!"); } } 1、常用注解 @Test 注解用于标记测试方法。JUnit 将会执行所有被 @Test 注解标记的方法作为测试用例。
@Disabled 注解用于标记测试方法并禁用它，这在你暂时不想执行某个测试方法时非常有用。
@BeforeAll 注解用于标记在所有测试方法执行之前只需执行一次的方法。且被该注解修饰的方法必须为静态方法。通常用于初始化静态资源。
@AfterAll 注解用于标记在所有测试方法执行之后只需执行一次的方法。且被该注解修饰的方法必须为静态方法。通常用于释放静态资源。
@BeforeEach 注解用于标记在每个测试方法之前需要执行的方法。通常用于初始化测试环境。
@AfterEach 注解用于标记在每个测试方法之后需要执行的方法。通常用于清理测试环境。
public class JunitTest { @BeforeAll static void setUp() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0118b77822cecd6fca6161ccdf473888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac89bb5e26924949a204df81e4f72fb6/" rel="bookmark">
			APP测试常见功能测试点汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装和卸载 安装和卸载是任何一款APP中都属于最基本功能。一旦出错，就属于优先级为紧要的BUG。因此APP的安装和卸载应作为一个测试点多加重视。
1 应用是否可以正常安装（命令行安装；豌豆荚／手机助手等第三方软件安装；apk／ipa安装包安装
2 应用是否可以在iOS和Android不同系统，版本，机型上进行安装（有的系统版本过低，应用不能适配）
3 安装过程中是否能暂停，再次点击，是否能继续安装
4 安装空间不足时如何表现，是否有相应提示，提示是否友好
5 安装过程中断网或网络不稳定的情况下，是否有相应提示，以及网络恢复后是否能继续安装
6 是否可以正常删除应用（桌面删除；第三方软件删除；命令行删除）
7 应用卸载后所有的安装文件夹是否全部删除
8 卸载过程中出现死机，断电，重启等意外的情况，等待环境恢复后是否可以继续正常卸载
9 卸载是否支持取消功能，单击取消后软件卸载情况是否正常
2、运行 1 软件安装后需要检查应用是否能正常运行： 2 APP安装完成后，是否可以正常打开，稳定运行 3 APP的速度是可以让人接受，切换是否流畅 4 网络异常时，应用是否会崩溃:在请求超时的情况下，如果程序逻辑处理的不好，就有可能发生Crash。 3、注册和登录 用户注册和登录功能是很多APP产品最基础的构成之一，而主流的登录页面大致分为三种：（1）账号密码注册登录；（2）手机号注册登录；（3）第三方授权登录。本文针对前两种注册登录方式进行阐述：
3.1账号密码注册登录
1 输入正确的账号密码，可正常注册和登录
2 已注册用户再次注册
3 未注册用户尝试登录
4 密码“****”展示
5 账号输入框对最大长度和格式应有校验（比如邮箱账号需要邮箱格式等）
6 账号或密码输入错误时建议提示“账号或密码错误”，而不是“账号错误”或“密码错误”
7 密码是否加密传输（可抓取请求查看）
8 密码更改后，登录时是否做到了有效数据的校验：修改前的密码失效；
9 未登录时对一些页面的操作，是否做了控制
10 切换账号登录，检验登录的信息是否做到及时更新
11 对于多个端都进行操作时，确保数据库操作无误，且每个端可以及时看到数据的更新
12 多设备同时登录同一帐号时（iOS+iOS，Android+Android，iOS+Android），检查是否将原用户剔除，弹出异地登录提示，且对一些需要登录后才能使用的页面无操作权限。
3.2手机号注册登录；
1 手机号输入框格式校验检查
2 验证短信的接收是否及时；
3 用验证码可正常登录；
4 验证码错误时，登录失败+友好提示
5 验证短信文案是否符合所测APP；
6 重复发送验证码，前一个验证码正常失效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac89bb5e26924949a204df81e4f72fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4707208b6b74640d77773c2ab54a512/" rel="bookmark">
			【2023最新】Scrapy框架教程一-Scrapy的创建与启动及Scrapy基础命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Scrapy框架Scrapy五大组件Scrapy五大文件 Scrapy创建项目Scrapy启动项目启动项目第一种方法启动项目第一种方法 Scrapy总结基础命令 Scrapy框架 Scrapy 是一个快速的高级网络爬虫和网络抓取框架，用于 抓取网站并从其页面中提取结构化数据。它可以被使用 用途广泛，从数据挖掘到监控和自动化 测试。
scrapy官网学习网址：https://docs.scrapy.org/en/latest/
Scrapy五大组件 ''' Scrapy是一个Python编写的开源网络爬虫框架，它的五大核心组件包括： 1.引擎（Engine）：是Scrapy的核心，负责控制整个爬虫流程的运行，包括调度器（Scheduler）、下载器（Downloader）和管道（Pipeline）等组件的协调工作。 2.调度器（Scheduler）：负责接受引擎发送过来的请求，并将其加入到队列中，队列会自动去重，等待下载器进行下载。同时，调度器还会根据一定的策略，从队列中选择一定数量的请求发送给下载器进行处理。 3.下载器（Downloader）：负责将调度器发送过来的请求进行处理，并将响应数据返回给引擎。下载器还可以处理一些请求的中间件，如代理、用户代理等。 4.爬虫（Spider）：负责定义爬取网站的规则，包括起始URL、如何跟踪链接、如何解析页面等。爬虫会将爬取到的数据交给管道进行处理。 5.管道（Pipeline）：负责处理爬虫爬取到的数据，包括清洗、去重、存储等。管道可以定义多个，用于对不同类型的数据进行处理 工作流程： 引擎先获取爬虫文件的起始url连接，传递给调度器，由调度器进行安排顺序（同时去除重复连接），之后便让引擎给下载器，引擎给下载器的需要过下载中间件的手，该做代理做代理，该换请求头换请求头，下载器拿到包装好的需要请求的东西，向互联网进行请求，获取下载来的数据（response）给下载中间件，下载中间件过一手让引擎给爬虫文件，爬虫文件开始解析，如果还需要请求的，再重复上面的步骤，需要存储的，通过item给管道，管道开始存储，保存为Mysql,Mongodb,csv等 ''' Scrapy五大文件 items.py ： 管道文件，用来传输文件到pipelines.py进行保存 middlewares.py ： 中间件，可以用来设置ua，ip代理，selenium等等等，可为 Scrapy 添加其他功能。我们可以将很多开源中间件附加到 Scrapy 以获得额外的功能。 pipelines.py：保存文件的地方，可以把管道文件传输过来的数据进行保存，保存为Mysql，mongodb,csv等等等 settings.py：设置爬虫的地方，像管道保存是否开启，日志输出等等等 spiders下的爬虫文件：是我们核心的文件，用来爬取数据，分析数据的文件 Scrapy创建项目 首先安装scrapy
# 使用清华源安装scrapy pip install -i https://pypi.tuna.tsinghua.edu.cn/simple Scrapy 前提:路径切换 cd 需要cd到你准备放scrapy的文件下 1. 创建scrapy项目 scrapy startproject 项目名 例： scrapy startproject douban 创建后显示这个样就成功了
他的意思是让我们创建爬虫文件，因为爬虫文件需要我们输入爬虫名字和域名
2.1 先cd到路径 cd douban 2.2 创建爬虫程序 scrapy genspider example example.com scrapy genspider：固定的 example：爬虫程序的名字(不固定的) 不能和项目名一样 example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4707208b6b74640d77773c2ab54a512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09c671a9e1b6529e67c7a245a017acd/" rel="bookmark">
			C&#43;&#43;多线程编程（2）：四种线程管理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章首发于我的个人博客：欢迎大佬们来逛逛
文章目录 线程管理get_idsleep_forsleep_untilyield 线程管理 有一个this_thread的名称空间中定义了许多的线程管理方法：
get_id：获取当前线程idsleep_for：当前线程休眠一段时间sleep_for：当前线程休眠，直到某个时间点之后结束休眠yield：当前线程立刻被抛弃，释放CPU时间片 get_id 获取当前线程id，每个线程的id都是唯一的，并且也可以获取主线程的id：
//获取线程Id void threadID() { std::cout &lt;&lt; "Id: " &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n'; } sleep_for chrono库提供了许多关于时间的操作，在我们接下来的介绍中需要用到。
当前线程休眠一段时间，其中一段时间是你自己给出的。
实际上调用这个函数会立刻使得线程从运行态转为阻塞状态，并且休眠一段时间。
位于阻塞态会让出当前的CPU资源，因此可以使得其他线程使用他让出的CPU资源，提高资源的利用率。
线程的五种状态：创建，就绪，运行，阻塞，终止
函数原型如下：
chrono::duration：表示一个时间段。 void sleep_for(const chrono::duration&lt;...&gt;&amp; durationTime) 具体如何传参？
std::this_thread::sleep_for(std::chrono::seconds(2)); // 休眠两秒 std::this_thread::sleep_for(std::chrono::microseconds(2000)); //休眠两千毫秒 还有minutes，hours等等。
//sleep_for延迟函数 void testSleep_for() { std::cout &lt;&lt; "子线程sleep_for: \n"; std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout &lt;&lt; "子线程sleep_for结束: \n"; } sleep_until 该函数与上面的函数类似，只不过他接受一个时间点，上面的sleep_for是一个时间段。
void sleep_until(const chrono::time_point&lt;...&gt;&amp; _Abs_time) 对于chrono如何表示一个时间点**time_point** 有以下方法：
system_clock：获取系统时间
steady_clock： 表示稳定时间间隔，即不随系统时间修改而变化的时间间隔。
high_resolution_clock： 实际上就是上一种
using high_resolution_clock = steady_clock; 如何获取当前时间？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c09c671a9e1b6529e67c7a245a017acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447affd38f29223cfb0ddbdf23dc65f5/" rel="bookmark">
			Windows 下提取EXE文件中的图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用两种工具：
1 使用 IconViewer 下载地址:
https://www.botproductions.com/iconview/download.html
2 使用 QuickAny2Ico 下载地址：
Quick Any2Ico - Create icons from any source
2.1 操作步骤
样例(采用 python-3.7.9.exe 作为例子提取为 .png)：
首先 将 python-3.7.9.exe 拖入第一个框中 或 点击 Browse 找到，然后选中 Save as PNG instead of ICO, 最后点击导出，出现 python-3.7.9.png。
2.2 查看生成的文件
参考：
如何从EXE文件中提取或保存图标 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee15ba561a17d9b9426b09ea43c756d/" rel="bookmark">
			小程序开通电子发票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总目录 文章目录 总目录前言结语 前言 随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
首先登录商户号：https://pay.weixin.qq.com/index.php/core/home/login
进入产品中心，然后在【运营工具】栏中找到【电子发票】这一项
点击【申请开通】电子发票
详情操作见：接入前准备
结语 以上就是本文的内容，希望以上内容可以帮助到您，如文中有不对之处，还请批评指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e9b9cb1fa53fd73e37a5fd486b6196/" rel="bookmark">
			（附源码）django学生就业管理系统 毕业设计24237
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生就业管理系统
摘 要
随着社会的快速发展和人们生活水平的不断提高，旅游已逐渐成为人们生活的重要组成部分，用户能够获取旅游信息的渠道也随信息技术的广泛应用而增加。大量未经过滤的信息在展示给用户的同时，也淹没了用户真正感兴趣的信息。为了方便用户快速定位自己感兴趣的信息，个性化学生就业管理系统应运而生。
本系统的前端界面涉及的技术主要有Django， HTML，jQuery等等，通过这些技术可以实现前端页面的美观和动态效果使之符合广大群众的审美观，后台主要使用的技术主要有Python编程语言，MySQL数据库，Ajax异步交互，根据Ajax异步模式的学生就业管理系统解决了传统旅游推荐方式中数据分析所带来的人力、物力和时间上的虚耗和交流深度的限定，这让交流的过程更快捷、准确、便利，同时完成学生就业管理系统的基本功能：学生用户、就业信息、平均工资等。本次报告，首先分析了研究的背景、作用、意义，为研究工作的合理性打下了基础。针对学生就业管理系统的各项需求以及技术问题进行分析，证明了系统的必要性和技术可行性，然后对设计系统需要使用的技术软件以及设计思想做了基本的介绍，最后来实现学生就业管理系统和部署运行使用它。
关键词：就业管理；Python语言；Mysql数据库
Student employment management system
Abstract
With the rapid development of society and the continuous improvement of people's living standards, tourism has gradually become an important part of people's life, and the channels for users to obtain tourism information have also increased with the wide application of information technology. While a large amount of unfiltered information is displayed to users, it also drowns the information that users are really interested in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e9b9cb1fa53fd73e37a5fd486b6196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44964eba8c98e206461d8e6acaf86815/" rel="bookmark">
			【Linux网络】详解使用http和ftp搭建yum仓库，以及yum网络源优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、回顾yum的原理
1.1yum简介
yum安装的底层原理：
yum的好处：
二、学习yum的配置文件及命令
1、yum的配置文件
2、yum的相关命令详解
3、yum的命令相关案例
三、搭建yum仓库的方式
1、本地yum仓库建立
2、通过http搭建内网的yum仓库
3、通过ftp搭建内网的yum仓库
4、创建本地的国内的网络源
一、回顾yum的原理 1.1yum简介 yum是一个基于RPM包（是Red-Hat Package Manager红帽软件包管理器的缩写）构建的软件更新机制，能够自动解决软件包之间的依赖关系。解决了日常工作中的大量查找安装依赖包的时间 为什么会有依赖关系的发生 因为linux本身就是以系统简洁为自身优势，所以在安装操作系统的时候并没有将所有的库文件以及编译软件包进行安装，所以在linux操作系统上进行软件安装的时候会出现软件包依赖的情况。yum由仓库和客户端组成，也就是整个yum由两部分组成，所以yum可以存放在两台服务器上。也可以存放在一台服务器上。可以有官方来提供服务，也可以由第三方来提供，比如国内的阿里云，搜狐云，还有一些非盈利组织比如学校等。官方的源一般在国外，下载速度肯定有限，手动更改成国内的云可以大幅提升下载速度。
YUM 的前身是 YUP（Yellow dog Updater，Yellow dog Linux 的软件更新器），最初由 TSS 公司（Terra Soft Solutions，INC.）使用 Python 语言开发而成，后来由杜克大学（Duck University）的 Linux 开发队伍进行改进，命名为 YUM（Yellow dog Updater，Modified）。 要成功使用 YUM 机制来更新系统和软件，需要有一个包含各种 rpm 安装包文件及其依 赖软件的软件仓库（repository），提供软件仓库的服务器也称为“源”服务器。在客户机中只 要正确指定软件仓库的地址等信息，就可以通过对应的“源”服务器来安装或更新软件。
yum安装的底层原理： 之前有博客专门详细讲解了rpm、yum、编译安装：详解三大安装方式的原理和使用情况
yum需要依赖于环境，依赖于服务端和客户端，允许跨网络
服务器：
RPM包 （Packages文件夹中）
元数据（repodata文件夹：软件的依赖关系，软件的位置）
yum的好处： 与rpm相比，能解决依赖关系
二、学习yum的配置文件及命令 1、yum的配置文件 [root@localhost]# /etc/yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever //yum下载的RPM包的缓存目录 $basearch代表硬件架构 $releasever系统版本比如7 keepcache=0 //是否保存缓存 0代表不保存，1代表保存 debuglevel=2 //调试级别了解即可 logfile=/var/log/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44964eba8c98e206461d8e6acaf86815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1220718dc571189027cb4abbd14d44d2/" rel="bookmark">
			李宏毅机器学习第十七周周报GAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 week 17 GAN摘要Abstract一、李宏毅机器学习——GAN1. Introduce1.1 Network as Generator1.2 Why distribution 2. Generative Adversarial Network2.1 Unconditional generation2.2 Basic idea of GAN 二、文献阅读1. 题目2. abstract3. 网络架构3.1 Theoretical Results 4. 文献解读4.1 Introduction4.2 创新点4.3 实验过程4.3.1 数据集4.3.2 参数设置 4.4 结论 三、实现GAN1. 任务要求2. 实验结果3.实验代码3.1数据准备3.2 模型构建3.3 展示函数3.4 训练过程 小结本周内容简报下周计划 参考文献 week 17 GAN 摘要 本文主要讨论了生成式对抗神经网络。首先，本文介绍了生成式对抗网络的设计思路。在此基础下，本文阐述了GAN的网络结构以及训练过程。生成器与解释器相互迭代，随着更新，生成器的效果趋近于真实图片。其次，本文展示了题为Generative Adversarial Networks论文的主要内容。这篇论文提出了生成式对抗网络的网络结构以及训练过程，该模型填补了生成任务方面神经网络的空白。此外，这篇论文还从理论角度证明了生成器的数据分布能够达到全局最优以及训练算法的可收敛性。最后，本文基于pytorch以及MNIST数据集实现了GAN绘制手写数字。
Abstract This article mainly discusses Generative Adversarial Networks (GANs). Firstly, this article introduces design philosophy of Generative Adversarial Networks. Building upon this foundation, the article elucidates the network structure and training process of GANs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1220718dc571189027cb4abbd14d44d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45e0df2db996b84a91bad310bc916a2/" rel="bookmark">
			Linux系统编程学习 NO.9——git、gdb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章简单介绍了Linux操作系统中两个实用的开发工具git版本控制器和gdb调试器。
git 什么是git？ git是一款开源的分布式版本控制软件。它不仅具有网络功能，还是服务端与客户端一体的软件。它可以高效的处理程序项目中的版本管理。它是Linux内核的设计者Linus Torvalds为了帮助管理Linux内核开发和维护而开发的一个开放源码的版本控制软件。
如何使用git 这里我们推荐使用国内基于git，为用户提供远端代码仓库服务的网站gitee。然后手把手教你管理自己对应的本地仓库以及远端仓库。
第一步，你得注册并登录你的gitee网站的账户，在你的网页右上角有一个“+”号，点击里面的新建仓库。
第二步，创建远端仓库
第三步，将远端仓库克隆到本地仓库。首先现将远端仓库的链接拷贝下来。
然后打开本地环境
在终端bash命令行输入以下指令
git --version 如果显示出了对应的版本，则请看下一步。若显示未找到指令，则表示git还未安装。所以需要安装git。在bash命令行中输入下面指令安装git
sudo yum install -y git 当你看到本行是文字时，相信你的git也在你的本地环境已经安装，下面我们将远端仓库克隆到本地环境里，形成本地仓库。如果你是第一次安装git也会要求你提供你的身份信息，这是为了对代码进行溯源。具体提交身份信息的指令简单提供一下demo版本的。
git config --global user.email "你的email" git config --global user.name "你的姓名" git clone 你的远端仓库URL 第四步，提交本地仓库代码到远端仓库。需要用到三板斧进行相应的提交。
git add . git commit -m "提交内容描述" git push git add .命令是将你当前的目录下的文件提交到暂存区中。git commit -m 命令是将暂存区的文件提交到本地仓库中，并要求写上你在本次提交中做了什么？git push命令是将当前本地仓库的内容同步到远端仓库中。在初学时不建议通过配置文件省略用户名密码确认。
第五步，远端仓库对于本地仓库的管理。当我们需要删除或者调整代码仓库的结构时，需要在远端仓库进行相应的调整操作后，然后在本地环境中将远端仓库的操作后内容拷贝到本地仓库中。需要用到同步远端仓库内容与本地仓库内容的指令。
git pull 可以通过下面指令查看当前日志信息
git log 可以使用下面指令查看当前git的状态
git status gdb 什么是gdb？ gdb是一款开源的源代码调试器。用于Linux环境下，C、C++、Python等编程语言的错误调试。gdb只能在debug版本下起作用，release版本是无法调试的。因为release版本对应目标的是用户，用户可不会去调试。
gdb的使用 这里可以看到gcc环境下默认是以release版本发布程序，如果我希望我的程序是以debug版本发布呢？ 这就要使用gcc的-g选项。
这里可以看到debug版本程序的容量是要略大于release版本的。因为debug程序内部携带了调试信息。下面简单介绍两个gdb指令，l和q。l表示默认显示当前程序的前10代码，可以按回车换行符继续输出代码，也可以指定对应的行号显示代码。q表示退出gdb。
下面在正式介绍调试前先给大家看一下样例的源文件的代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a45e0df2db996b84a91bad310bc916a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c4c9ab355499b7a2edb8d7259983db/" rel="bookmark">
			小程序申请，商户号申请，微信支付开通操作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总目录 文章目录 总目录前言1 申请商户号（如已有商户号跳过）1 申请流程与资料2 详细申请步骤 2 申请开通接入微信支付步骤3 申请微信小程序1 申请小程序步骤2 查看小程序AppID 4 微信支付普通商户与AppID账号关联结语 前言 本文主要讲解如何申请微信商户号和开通微信支付功能。
1 申请商户号（如已有商户号跳过） 1 申请流程与资料 2 详细申请步骤 步骤1：访问微信支付网址：https://pay.weixin.qq.com/static/applyment_guide/applyment_index.shtml
步骤2：选择【我有小程序】，然后点击 【接入微信支付】按钮
步骤3：当没有商户号的时候，点击【注册微信支付商户号】
步骤4：填写申请单信息
申请单创建后，点击【提交】进入下一步。
步骤5：填写商户资料
填写完毕，提交信息，等待审核即可。 2 申请开通接入微信支付步骤 步骤1：访问微信支付网址：https://pay.weixin.qq.com/static/applyment_guide/applyment_index.shtml
步骤2：选择【我有小程序】，然后点击 【接入微信支付】按钮
步骤3：如果已有商户号选择【登录已有商户号】，然后扫码登录即可
步骤4：进入产品中心=》我的产品=》选择对应的【支付产品】申请开通即可。
附：官方接入指引-小程序接入支付https://mp.weixin.qq.com/s/u8F1beSBX8H4K85RncrdpQ
3 申请微信小程序 1 申请小程序步骤 步骤1：进步微信公众号平台：https://mp.weixin.qq.com/?token=&amp;lang=zh_CN
选择小程序
步骤2：点击【前往注册】
步骤3：填写注册信息
点击【注册】后，会发送激活信息到邮箱，进入邮箱点击链接即可。
步骤4：信息登记
根据需要选择主体类型
步骤5：填写完毕，扫码验证信息，点击【继续】即可
2 查看小程序AppID 当我们申请完小程序后，就可以进入小程序后台页面进入【开发=》开发管理=》开发设置=》就可得到AppID 备注：在小程序的开发中，很多地方都会用到AppID
4 微信支付普通商户与AppID账号关联 详细操作可见：微信支付普通商户与AppID账号关联管理
结语 以上就是本文的内容，希望以上内容可以帮助到您，如文中有不对之处，还请批评指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b92d689e73fa5ba0330c4a107b0229/" rel="bookmark">
			【Linux网络】从原理到实操，感受PXE无人值守自动化高效批量网络安装系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PXE网络批量装机的介绍
1、常见的三种系统安装方式
2、回顾系统安装的过程，了解系统安装的必要条件
3、什么是pxe
4、搭建pxe的原理
5、Linux的光盘镜像中的isolinux中的相关文件学习
二、关于实现PXE无人值守装机的四大文件与五个软件的对应关系详解
5个程序的使用原因：
1、DHCP服务器：
2、TFTP服务器：
3、syslinux程序：
4、FTP服务器：
5、kickstart程序：
三、实操PXE批量安装详解
做任何动作之前先关闭selinux和防火墙，以及安装五个软件
第一步：dhcp服务器搭建
第二步：准备好vsftpd服务，挂载光盘镜像
第三步：开启tftp开机自启，配置好tftp传输的文件，内核和驱动
第四步：找到grub小程序——也就是syslinux提供的pxelinux.0程序
第五步：手写grub.cfg配置文件——default文件
第六步：生成ks.cfg配置文件
第七步：启动所有服务，见证奇迹
第八步：实现自动化装机过程
四、总结
一、PXE网络批量装机的介绍 1、常见的三种系统安装方式 第一种：u启动安装，在优盘中下载相关的安装系统和镜像文件，优盘插入即可安装，将想要的操作系统安装进自己的硬盘（需要将优盘设置u启动或者把镜像烧录进去）
第二种：光驱安装，将相关的安装系统镜像放入光盘，插入电脑服务器中，即可按照引导进行装机，将操作系统安装进自己的硬盘
第三种：网卡安装，需要通过网络下载，在网上的某个服务器上去下载相关镜像系统，来进行安装
2、回顾系统安装的过程，了解系统安装的必要条件 这是硬盘启动的过程：开机自检（bios主板）——mbr引导（主要是去找grub菜单）——找到grub配置文件（找到内核的位置）——加载内核到内存——初始化启动
光驱安装系统的过程：bios引导选择光驱——boot.cat引导（通过isolinux.bin程序找到配置文件）——读取isolinux.cfg配置文件知道内核和光驱的位置——加载光驱里面的内核vmlinuz和驱动initrd.img到内存——再通过光驱里面找到各种初始化程序安装包，启动进程并开机
那么我们想要裸机通过网络来能够完成这样的过程，那么得有哪些必要条件呢？
①裸机主板需要支持网络引导（现在大多数的服务器主机都支持，需要在bios设置中可以允许network或者lan启动）
②需要有一个引导程序能找到grub配置文件（类似mbr引导）
③需要有一个类似grub配置文件指引找到内核（类似于grub.cfg）
④需要有vmlinuz内核程序和initrd.img驱动，加载到内存中（类似于vmlinuz-3.10.0-693.el7.x86_64和initramfs-3.10.0-693.el7.x86_64.img）
3、什么是pxe PXE 的全称是 preboot execute environment它其实是Intel在很久以前提出来的一项用于通过网络来引导系统的标准。允许客户机通过网络从远程服务器上下载引导镜像，并加载安装文件或者整个操作系统。
pxe是通过网卡引导启动需要的条件：
1.BIOS支持
2.网卡支持（现在基本都已支持）
3.需要在bios中开启开关，服务器一般没打开（bmc界面里打开）
4.网络中有一台 DHCP 服务器以便为客户机自动分配地址、指定引导文件位置，网卡自带DHCP功能，dhcp 指明分配的ip地址
4、搭建pxe的原理 第一步网卡需要查找相关的dhcp服务器，来获取ip地址和时间；第二步dhcp服务器，通过offer报文传给裸机客户端，不仅提供了ip地址，还提供了引导程序（boot loader，这里是pxelinux.0）的地址，以及tftp-server的地址（指向dhcp服务器自己）；第三步客户机通过tftp服务器获取引导程序pxelinux.0，将其加载到内存中；第四步引导程序pxelinux.0通过tftp服务器获取pxelinux.cfg中的default配置文件；第五步配置文件指明内核和驱动的位置，通过tftp服务器获取vmlinuz和initrd.img；最后启动内核； 5、Linux的光盘镜像中的isolinux中的相关文件学习 boot.cat相当于grub的第一阶段 isolinux.bin光盘引导程序，在mkisofs的选项中需要明确给出文件路径，这个文件属于SYSLINUX项目isolinux.cfg启动菜单的配置文件，当光盘启动后（即运行isolinux.bin），会自动去找isolinux.cfg文件（相当于boot里面的grub.cfg）vesamenu.c32是光盘启动后的启动菜单图形界面，也属于SYSLINUX项目，menu.c32提供纯文本的菜单（指明背景图位置）memtest内存检测程序splash.png光盘启动菜单界面的背景图（这是一张图片）vmlinuz是内核映像initrd.imgramfs文件（精简版的linux系统，文件系统驱动等） 二、关于实现PXE无人值守装机的四大文件与五个软件的对应关系详解 TFTP服务器的家目录/var/lib/tftpboot的四大文件一定是这样，标点符号都要一模一样：
​​​​​​
5个程序的使用原因： 1、DHCP服务器： 在这里DHCP服务器是用来动态分配客户端ip地址以及指明TFTP服务器的ip地址和引导程序“pxelinux.0”的位置
DHCP服务端是udp的67端口，客户端是udp的68端口
2、TFTP服务器： 这是网卡自带的功能，基于udp协议实现客户机和服务端之间进行简单的文件传输协议，适用于小型文件传输。TFTP服务默认由xinetd服务进行管理，使用UDP69端口。
这里的TFTP服务器是用来提供传输四大文件，一共52M
3、syslinux程序： syslinux是一个功能强大的引导加载程序，而且兼容各种介质。它的目的是简化首次安装Linux的时间，并建立修护或其它特殊用途的启动盘。它的安装很简单，一旦安装syslinux好之后，sysLinux启动盘就可以引导各种基于DOS的工具，以及MS-DOS/Windows或者任何其它操作系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b92d689e73fa5ba0330c4a107b0229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed039c623412d85ef522f9b9ed089959/" rel="bookmark">
			系统盘升级-系统迁移记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 原盘：512SSD—系统盘
新盘：1TSSD—替换为系统盘
均为M.2接口，因笔记本自带m.2盘位和SATA3.0盘位，SATA3.0盘和m.2盘传输速率相差甚大且价格基本相同，故购入1T m.2 SSD盘替换原512SSD盘。
要求： 1.目标： 因电脑涉及资料和开发环境很多，故期望无损迁移系统。
2.工具准备： wepe工具箱（diskgenius分区工具、fastcopy复制、Dism++引导修复）、硬盘盒
实践： 1、备份： 将较为重要旧资料在网盘、U盘做好备份
2、wepe工具： 下载好wepe并使用U盘制作好启动盘微PE工具箱 - 下载 (wepe.com.cn)https://www.wepe.com.cn/download.html
3、硬盘分区工具：diskgenius （wepe中已包含，该工具也包含迁移系统、克隆硬盘功能，我们U盘启动进入wepe使用该工具的迁移系统功能，原系统盘迁移到新盘）
4、fastcopy复制工具 剩下的D.E盘我选择的方案是全量fastcopy到新盘分区中，以保证软件其中的软链接、指向路径不变。
5、Dism++引导修复： 启动时可能会遇到蓝屏、黑屏的情况。选择wepe中的dism++工具引导修复功能完成修复，重新启动顺利进入系统。（引导修复工具还有其他，经测试并不适合我的电脑，原因暂未知）
6、启动电脑： 启动后发现，电脑没有任何变化。顺利完成无损迁移。
文末注：将原盘数据全量复制到新盘后，把旧盘拆下，新盘装上再进行引导修复即可，旧盘可用硬盘盒使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaf534341b1a22f8fea5c6fd35715903/" rel="bookmark">
			C#设计模式——工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#设计模式——工厂模式 ​ 工厂设计模式是实时应用程序中最常用的设计模式之一。工厂设计模式属于创意设计模式类别。这里主要介绍以下相关内容：
​ 一、什么是工厂设计模式
​ 二、通过示例了解工厂设计模式
​ 三、在 C# 中不使用工厂模式的示例
​ 四、理解不使用工厂设计模式的问题
​ 五、工厂设计模式在C# 中的实现
​ 六、理解工厂设计模式的UML图
​ 七、何时在实时应用中使用工厂设计模式
​ 八、何时不在实时应用程序中使用工厂设计模式
一、什么是工厂设计模式 ​ 工厂是一个用于创建其他对象的对象。用技术术语来说，我们可以说工厂是一个带有方法的类。该方法将根据接收到的输入参数“创建并返回不同的对象，简单来说，如果我们有一个超类和 n 个子类，并且根据提供的数据，如果我们必须创建并返回其中一个子类的对象，那么我们需要使用 C# 中的工厂设计模式。在工厂设计模式中，我们创建一个对象，而不将对象创建和初始化逻辑暴露给客户端，客户端将使用公共接口引用新创建的对象。工厂设计模式背后的基本原理是，在运行时，我们根据传递的参数获取相似类型的对象。因此，客户端将获取适当的对象并使用该对象，而无需知道该对象是如何创建和初始化的。
二、通过实例了解工厂设计模式 ​ 现有三种信用卡类别，即MoneyBack, Titanium, and Platinum。这三个类是 CreditCard 超类的子类，或者可以说是超级接口。CreditCard接口具有三个方法，即GetCardType、GetCreditLimit和GetAnnualCharge。MoneyBack、Titanium、Platinum 子类都实现了CreditCard 的上述三个方法。
我们需要要求用户选择信用卡。用户选择信用卡后，我们需要显示有关所选信用卡的所需信息。让我们首先讨论在 C# 中不使用工厂设计模式来实现这一点。然后，我们将讨论这些问题，最后，我们将使用 C# 中的工厂设计模式创建相同的应用程序。
三、在 C# 中不使用工厂模式的示例 步骤 1：创建抽象产品或产品接口（信用卡） ​ 我们需要创建一个接口或一个抽象类来公开信用卡应具有的操作。因此，创建一个名为CreditCard.cs的类文件并复制并粘贴以下代码。正如您所看到的，我们根据我们的要求使用三种方法创建了 CreditCard 接口。
namespace FactoryDesignPattern { public interface CreditCard { string GetCardType(); int GetCreditLimit(); int GetAnnualCharge(); } } 接下来创建三个Product类来实现上述接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaf534341b1a22f8fea5c6fd35715903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7e012733f1767e096147ca1acdcc52/" rel="bookmark">
			充分性和必要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		充分性和必要性是数学和逻辑中常用的两个概念，它们用来描述条件语句或定理中的不同性质。为了通俗易懂地解释它们，我们可以使用一个简单的例子来说明。
假设你想要考虑一个条件语句： “如果一个人是学生，那么他每天都会去学校。”
充分性（Sufficiency）：这个概念涉及到条件语句的“如果…那么…”部分。在这个例子中，条件是“一个人是学生”，充分性指的是，如果条件成立，也就是一个人是学生，那么结论部分（他每天都会去学校）也一定成立。换句话说，充分性告诉我们条件成立是导致结论成立的足够条件。（“有它即可”）
举例：如果小明是一名学生（条件成立），那么小明每天都会去学校（结论成立）。这就满足了充分性。
必要性（Necessity）：这个概念与条件语句的“如果…那么…”部分有关，但侧重于条件部分。在这个例子中，必要性指的是，如果结论部分成立，也就是一个人每天都会去学校，那么条件部分（一个人是学生）一定成立。换句话说，必要性告诉我们结论成立是需要条件成立的必要条件。（“非它不可”）
举例：如果小明每天都会去学校（结论成立），那么小明一定是一名学生（条件成立）。这就满足了必要性。
总结起来，充分性关注的是条件成立导致结论成立的情况，而必要性关注的是结论成立需要条件成立的情况。在我们的例子中，充分性是如果是学生就每天去学校，而必要性是每天去学校的话一定是学生。这两个概念有助于我们更深入地理解条件语句和数学定理的性质。
容易混淆的几个点 A的充分条件是B B推A
A是B的充分条件 A推B
A的充分必要条件是B，充分性怎么证明，必要性怎么证明 证明"A的充分必要条件是B"涉及两个方面：充分性和必要性。充分性是证明如果B成立，那么A一定成立，而必要性是证明如果A成立，那么B一定成立。
证明充分性（Sufficiency）： 要证明充分性，即如果B成立，那么A一定成立
如果你能够建立一个合理的证据链，说明B的成立导致A的成立，那么也证明了充分性。
证明必要性（Necessity）： 要证明必要性，即如果A成立，那么B一定成立，同样可以使用逻辑推理或证明方法：
如果你能够建立一个合理的证据链，说明A的成立导致B的成立，那么就证明了必要性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1c9fbed5500ea69511f0629b0d06ed/" rel="bookmark">
			Java项目:物业管理系统(java&#43;SpringBoot&#43;SSM&#43;JSP&#43;JQuery&#43;Mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码获取：俺的博客首页 "资源" 里下载！ 项目介绍
基于SpringBoot的物业管理系统(附带论文+PPT)
角色：管理员、业主
管理员和业主
业主功能: 缴费信息，报修，投诉,注册，公告，修改密码等
管理员功能：用户管理，楼栋信息，房间信息，房屋绑定，车位绑定，缴费信息，报修信息，投诉信息，修改密码，公告信息等
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 4.数据库：MySql 5.7/8.0版本均可；
5.是否Maven项目：是；
技术栈
后端：SpringBoot(Spring+SpringMVC+Mybatis)
前端: JSP、css、JavaScript、JQuery、Ajax
使用说明
项目运行：
1. 使用Navicat或者其它工具，在mysql中创建对应sql文件名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，导入成功后请执行maven clean;maven install命令，然后运行；
3. 将项目中application.yml配置文件中的数据库配置改为自己的配置;
4. 运行项目，控制台提示运行成功后再去运行前端项目；
5. 管理员用户名密码：admin/admin
普通用户名密码：user/123456
文档介绍（课题背景与意义、系统实现功能、课题研究现状、系统相关技术、java技术、B/S架构、Mysql介绍、Mysql环境配置、Springboot框架、系统需求分析、系统功能、可行性研究、经济可行性、技术可行性、运行可行性、事件可行性、系统业务过程分析、系统业务过程分析、系统用例图、系统设计、数据库设计、系统整体设计、系统设计思想、系统流程图、系统详情设计、系统功能模块、系统功能模块、管理员功能模块）： 小区物业报修： 我的账单展示页： 小区物业系统登录页： 小区物业系统统计展示页面： 投诉管理展示页面： 用户管理展示页面： 缴费管理展示页面： 用户管理控制层： @RestController public class UserController { @Autowired UserService service; @GetMapping("/api/getUsers") public ResBody getUsers(@RequestParam int page, @RequestParam int limit) { ResBody resBody = new ResBody(); int count = service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f1c9fbed5500ea69511f0629b0d06ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af96f5d76613a25d988aff73fdf7be5/" rel="bookmark">
			题解 | #2021年11月每天的人均浏览文章时长#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浙江杭州就业求职好公司及薪资汇总
室友微信✌开23+4觉得没有多少😭
感觉是这岗位ssp
2023秋招｜移动研究院人力资源面试
菜鸡混子的秋招路
为什么奉劝大家第一份工作一定要进大厂！
山东人，本硕双非仔，大佬给个offer选择建议
帮选offer 双9女
旷视补录&amp;实习生招聘
同学一个月前华子主管面通过，前几天挂了
毕业论文搞定了没，入职之前别忘了这些事
这样的毕业论文应该不会被延毕了吧？
竞技世界 OC
理想汽车开奖后降薪，避雷
TP普联，我和你拼了！😅
交行软开长沙
拿到拼多多意向被规劝
理想汽车开奖后降薪，避雷
NLP算法工程师秋招面试情况汇总（一）
中信银行总行信息科技岗
中信银行
工行江苏分行科技岗面经（开发方向）
2022.9-11 中信银行 总行信息科技岗 秋招
TP普联，我和你拼了！😅
C题，来个佬帮忙看看哪里有问题吧
#include&lt;bits/stdc++.h&gt;#define int long long#define For(i,a,b) for(int i=a
想统计下今年这形势双非本都能拿到什么级别的薪资
🐭🐭{nowcoder-vote}{100551}
题解 | #合并k个已排序的链表#
/** * struct ListNode { * int val; * struct ListNode *next; * }; *//** * 代码中的类名、
题解 | #整型数组合并#
import java.util.*;// TreeSetpublic class Main { public static void main(Stri
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af96f5d76613a25d988aff73fdf7be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d55e059ecfbf7edbb837ca1ba6258ce/" rel="bookmark">
			Arcgis坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arcgis坐标 坐标系分类 坐标系有两种：①地理坐标系；②投影坐标系。
地理坐标系：用经纬度描述地面的位置，经度读等于0时，称作本初子午线。
投影坐标系：用x,y来描述地面的位置，有坐标系单位，通常为米（m）
投影坐标系统 (Projection coordinate system) 使用基千 X.Y 值的坐标系统来描述地球上某个点所处的位笠。这个坐标系是从地球的近似椭球体投影得到的．它对应于某个地理坐标系。平面坐标系统地图单位通常为米（m），或者是平面直角坐标系。
（闫磊：《ArcGIS从0到1》，北京：北京航空航天大学出版社，2019年，第65页。）
投影坐标系统 (Projection coordinate system) 为了区别某一坐标系统属千哪一带．在横坐标 轴东移 500km 当作起始轴，这样一个带内的所有横坐标值均加500,000m 。
轴坐标前加上带号，如 (21,655,933m, 4,231,898m) ，其中 21 即为带号。
（闫磊：《ArcGIS从0到1》，北京：北京航空航天大学出版社，2019年，第71页。）
如果导入的数据是经纬度，则应当选择地理坐标系。
投影分类 WGS1984，使用UTM投影(Universal Transverse Mercator Projectioin，横轴墨卡托投影)，是横轴等角割圆柱面投影。
国家2000，使用高斯-克吕格投影。以中央经线投影为纵轴 Y，以赤道投影为横轴 X ．两轴交点即为坐标原点。纵坐标以赤道为零开始算，赤道以北为正．以南为负。我国位千北半球，纵坐标均为正值。
数据框属性中的不同投影效果 在Arcgis中，可以调整Arcgis数据框中的投影，形成不同的视觉效果，如下。
如图，选择菜单栏中的“视图”，选择“数据框属性”，可以选择不同的投影。如World1984墨卡托投影效果如下：
可以选择不同的投影，体验不同效果，认识到各个投影形成地图的视觉效果。
如Adam Square Ⅱ （World）投影效果：
又如Cassini的投影效果如下：
又如Winkel Tripel的投影效果如下：
可以根据所需要，灵活调整不同投影，形成符合研究需求的视觉效果。
定义坐标系/ 定义投影 对于已经创建好的数据，可以使用ArcCatalog中的“定义投影”（Define Projection）工具。
查看地理矢量图的坐标系 在导入的矢量地图中，可以查看该地图采用的坐标。鼠标右键单击矢量图层，选择“属性”。
然后选择“源”，即可查询相关的地理坐标信息。
地理坐标信息，也会在Arcgis右下角显示。
查看天地卫星图的坐标系 同理，也可以查询导入的卫星图所采用的坐标系。如图所示，在xdc导入的天地图中，坐标为WGS1984：
在天地图官网api导入的地图中，是GCS_China_Geodetic_Coordinate_System_2000。
不同卫星图采用的坐标 卫星图也采用了WGS_1984投影，和矢量图所采用的坐标系一致。
在使用Arcgis软件的时候，检查各个图层所采用的坐标系，坐标系一致后，就不会产生谬误，方可继续下一步的研究。
（1）天地图：CGCS2000，2000国家大地坐标系；我们其实很多时候直接用WGS84的坐标来代替CGCS2000坐标。因为CGCS2000的定义与WGS84实质一样。采用的参考椭球非常接近。扁率差异引起椭球面上的纬度和高度变化最大达0.1mm。当前测量精度范围内，可以忽略这点差异。可以说两者相容至cm级水平，但若一点的坐标精度达不到cm水平，则不认为CGCS2000和WGS84的坐标是相容的。
（2）百度地图：bd09II坐标。首先了解一下火星坐标，它是在国际标准坐标WGS-84上进行的一次加密，由于国内的电子地图都要至少使用火星坐标进行一次加密，百度直接就任性一些，直接自己又研究了一套加密算法，来了个二次加密，这就是我们所熟知的百度坐标(BD-09)。
（3）高德地图：gcj02坐标，也称为火星坐标。火星坐标是国家测绘局为了国家安全在原始坐标的基础上进行偏移得到的坐标，基本国内的电子地图、导航设备都是采用的这一坐标系或在这一坐标的基础上进行二次加密得到的。
（来源：简书）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d55e059ecfbf7edbb837ca1ba6258ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4de3c49667a417422ed507f3438dfc/" rel="bookmark">
			opencv dnn模块 示例(23) 目标检测 object_detection 之 yolov8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、YOLOv8介绍1.1、概述1.2、骨干网络和 Neck1.3、Loss 计算1.4、数据增强1.5、训练策略1.6、推理过程 2、测试2.1、官方Python测试2.2、Opencv dnn测试2.3、测试统计 3、训练4、Yolov8-pose 简单使用 1、YOLOv8介绍 YOLOv3之前的所有YOLO对象检测模型都是用C语言编写的，并使用了Darknet框架，Ultralytics发布了第一个使用PyTorch框架实现的YOLO (YOLOv3)；YOLOv3之后，Ultralytics发布了YOLOv5，在2023年1月，Ultralytics发布了YOLOv8，包含五个模型，用于检测、分割和分类。 YOLOv8 Nano是其中最快和最小的，而YOLOv8 Extra Large (YOLOv8x)是其中最准确但最慢的，具体模型见后续的图。
YOLOv8附带以下预训练模型:
目标检测在图像分辨率为640的COCO检测数据集上进行训练。实例分割在图像分辨率为640的COCO分割数据集上训练。图像分类模型在ImageNet数据集上预训练，图像分辨率为224。 1.1、概述 心特性和改动可以归结为如下：
提供了一个全新的SOTA模型（state-of-the-art model），包括 P5 640 和 P6 1280 分辨率的目标检测网络和基于YOLACT的实例分割模型。和 YOLOv5 一样，基于缩放系数也提供了 N/S/M/L/X 尺度的不同大小模型，用于满足不同场景需求骨干网络和 Neck 部分可能参考了 YOLOv7 ELAN 设计思想，将 YOLOv5 的 C3 结构换成了梯度流更丰富的 C2f 结构，并对不同尺度模型调整了不同的通道数，属于对模型结构精心微调，不再是一套参数应用所有模型，大幅提升了模型性能。Head 部分相比 YOLOv5 改动较大，换成了目前主流的解耦头结构，将分类和检测头分离，同时也从Anchor-Based 换成了 Anchor-FreeLoss 计算方面采用了TaskAlignedAssigner正样本分配策略，并引入了Distribution Focal Loss训练的数据增强部分引入了 YOLOX 中的最后 10 epoch 关闭 Mosiac 增强的操作，可以有效地提升精度 1.2、骨干网络和 Neck 骨干网络和 Neck 部分可能参考了 YOLOv7 ELAN 设计思想，将 YOLOv5 的 C3 结构换成了梯度流更丰富的 C2f 结构，并对不同尺度模型调整了不同的通道数，属于对模型结构精心微调，不再是一套参数应用所有模型，大幅提升了模型性能。 具体改动为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc4de3c49667a417422ed507f3438dfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb39d1edb4d090d122be6fc8f920ec49/" rel="bookmark">
			linux内存空间深度清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 du -sh * 只能查看可见空间的占用，查看隐藏空间的大小使用：
du -sh .[^.]* * 可以看到 .cache .config .ros 占用大量空间。
清理：
1、删除.cache 文件夹
rm -rf ~/.cache 2、清理vscode 在.config中缓存
rm -rf ~/.config/Code/User/workspaceStorage/* 3、清理ros日志
ros日志在~/.ros/log/中，清理用以下命令：
rosclean check rosclean purge 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89326c260176988de4e795770aa86f3b/" rel="bookmark">
			JavaScript 中如何终止网络请求？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.JavaScript 中使用 AbortController 和 AbortSignal 中止网络请求。（AbortController.abort()）
通过 AbortController 创建新的 AbortController 对象，然后使用其 abort() 方法来中止请求。在创建请求时，将 AbortController.signal 分配给请求的 signal 属性，以便在调用 abort() 方法时取消请求。以下是使用 AbortController 中止 fetch 请求的示例：
// 创建 AbortController 实例 const controller = new AbortController(); // 获取 AbortController 的 signal 属性 const signal = controller.signal; // 使用 Fetch API 发起网络请求，传递 signal 作为 signal 选项 fetch(url, { signal }) .then(response =&gt; { // 处理响应 }) .catch(error =&gt; { // 检查错误类型是否为 AbortError if (error.name === 'AbortError') { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89326c260176988de4e795770aa86f3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f4a0d80b34a73cf7171d676e825043/" rel="bookmark">
			OPCClient_UA源码OPC客户端 UA客户端源码（c#开发）为opcClient_UA版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OPCClient_UA源码OPC客户端 UA客户端源码（c#开发）
为opcClient_UA版本，由C#开发，可二次开发。
另外有opcserver,opcclient的da,ua版本的见其他链接。
本项目为VS2010开发，可用VS其他版本的编辑器打开源码。
已应用到多个行业的几百个应用现场，长时间运行稳定，可靠。
本项目中提供测试OPCClient的软件开发源码，有详细的注释，二次开发清晰明了。
OPCClient_UA源码OPC客户端 UA客户端源码（c#开发）
OPCClient_UA源码是一款使用C#开发的工具，可用于二次开发 OPC 客户端。同时，该工具也支持 OPC 服务器和 OPC DA/UA 客户端版本。该项目采用VS2010作为开发工具，可以用其他版本的编辑器打开其源码。
该工具已被广泛应用于多个行业、数百个应用现场，长时间运行稳定可靠。除此之外，该工具还提供了测试 OPCClient 的软件开发源码，并且有详细的注释，非常清晰明了，可以供开发者参考和学习。
OPCClient_UA工具的优势和应用
OPCClient_UA源码是一款强大、高效、稳定、可靠的 OPC 客户端工具，主要具有以下优势和应用：
可靠稳定的运行环境：OPCClient_UA源码采用了高效、稳定的开发框架，经过了多个应用场景的测试，已经稳定运行了多年。因此，如果您使用该工具，可以放心使用，不必担心出现问题。
良好的二次开发性：OPCClient_UA源码代码清晰、注释详尽、结构清晰，可供开发者进行二次开发。开发者可以在原有基础上进行自由扩展和优化，让客户端更加符合自己的需求。
多种版本选择：OPCClient_UA源码支持 OPC 服务器和 OPC DA/UA 客户端版本，可以满足各种不同场景的需求，使得工具更加灵活多用。
完备的使用文档：OPCClient_UA源码提供了详细的使用文档，让初学者也能轻松上手，快速掌握该工具。
多个行业应用案例：OPCClient_UA源码已被广泛应用于多个行业数百个应用场景，如工业自动化、机械设备、能源、冶金、石油化工等。并且多个案例均已长时间稳定运行。
监控设备实时状态：使用 OPCClient_UA源码，您可以快速实现对设备的实时监控，及时发现设备故障，加快故障排除速度，让生产效率更高。
总结：
以上就是对于OPCClient_UA源码OPC客户端的详细介绍。如果您需要开发一款可靠稳定的 OPC 客户端工具，该工具是您的不二之选。该工具具有良好的二次开发性、多种版本选择、完备的使用文档和多个行业应用案例等优势，让您的开发工作更加快捷、高效、灵活，助力您的生产工作更上一层楼。
相关代码,程序地址：http://lanzouw.top/674475355272.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0adf02dcc001a6fc23ee62e9d072ad95/" rel="bookmark">
			vue&#43;springboot实现登录或注册滑动验证码（ AJ-Captcha）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我们使用 开源的AJ-Captcha行为验证码，包含滑动拼图、文字点选两种方式。
参考官方文档和开源页面，使用比较简单，但是有几个坑
vue端实现验证码弹出窗 提示1：在开源页下载整个项目后，需要把captcha-master.zip\captcha-master\view\vue\src\assets\image复制到你vue项目对应路径下提示2： @success="'success'"要把单引号去掉，:mode="'pop'"、:captchaType="'blockPuzzle'"要保留单引号 提示3：verifition\utils\axios.js中默认的网址前缀是axios.defaults.baseURL = process.env.BASE_API，根据需要修改，例如我修改成 axios.defaults.baseURL = "http://127.0.0.1/api" 也可以用constants.js设置全局变量
springboot实现校验 提示1：依赖包要导入 &lt;artifactId&gt;spring-boot-starter-captcha&lt;/artifactId&gt;，再配置application.properties，这样启动才能访问到…/captcha/get和…/captcha/check提示2：复制springboot\src\main\resources\images到项目static文件夹下，修改application.properties图片路径 aj.captcha.jigsaw=classpath:static/images/jigsaw aj.captcha.pic-click=classpath:static/images/pic-click 提示3：如果有拦截安全设置，放行…/captcha/get和…/captcha/check提示4：如果前端校验成功，发起登录请求或者发起发送短信验证码请求，在后端就需要第二次校验（防止用户恶意调用接口）
vue示例中使用技巧使axios同时传输@RequestBody请求体和@RequestParam请求参数的数据 success(params){ // params 返回的二次验证参数, 和登录参数一起回传给登录接口，方便后台进行二次验证 //captchaVerification是必传参数 this.captcha = params.captchaVerification //假设用axios发起post登录请求 this.$http.post("/user/login", { //请求体 username:"xing", password:"1234", }, { params:{captcha:this.form.captcha,},//网址携带请求参数 } ) .then((response)=&gt;{ if(response.data.code === 0){//登录成功 this.$message({ message: '登录成功', type: 'success', }); localStorage.setItem("user",JSON.stringify(response.data.data));//保存用户信息 this.$router.push("/"); } else{ this.$message.error("用户名或密码错误，请重试！！！"); } }) .catch((error)=&gt;{ //未接受到response的网络传输等错误 console.log(error); }); }, login登录方法要校验验证码通过，才执行登录逻辑。代码中CommonResult返回结果类、CustomException自定义异常类和Jwt之前文章实现过，请自行搜索。Jwt实现登录鉴权，视频链接。
@PostMapping("/user/login") public CommonResult&lt;Object&gt; login(@RequestBody User user,@RequestParam String captcha) { //必传参数：captchaVO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0adf02dcc001a6fc23ee62e9d072ad95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4440b0d3c364bea5c12d05b2d0d81bc0/" rel="bookmark">
			PX4&#43;gazebo仿真中给无人机添加相机，以及改变相机的位姿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加无人机摄像头 找到你的需要运行的lauch文件，例如mavros_posix_sitl.lauch，编辑（最好先备份一份）。 cd ~/your_path/launch degit mavros_posix_sitl.launch 修改sdf部分(也就是添加一个传感器给无人机)，传感器模块路径,选择一个相机（本文选择的是iris_depth_camera）： ～/path_yo_your_px4/Tools/sitl_gazebo_models 根据选择的相机修改launch文件，如下：
&lt;include file="$(find px4)/launch/posix_sitl_cp.launch"&gt; &lt;arg name="x" value="$(arg x)"/&gt; &lt;arg name="y" value="$(arg y)"/&gt; &lt;arg name="z" value="$(arg z)"/&gt; &lt;arg name="R" value="$(arg R)"/&gt; &lt;arg name="P" value="$(arg P)"/&gt; &lt;arg name="Y" value="$(arg Y)"/&gt; &lt;arg name="world" value="$(arg world)"/&gt; &lt;arg name="vehicle" value="$(arg vehicle)"/&gt; &lt;arg name="sdf" value="$(arg sdf)"/&gt; &lt;arg name="gui" value="$(arg gui)"/&gt; &lt;arg name="interactive" value="$(arg interactive)"/&gt; &lt;arg name="debug" value="$(arg debug)"/&gt; &lt;arg name="verbose" value="$(arg verbose)"/&gt; &lt;arg name="paused" value="$(arg paused)"/&gt; &lt;arg name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4440b0d3c364bea5c12d05b2d0d81bc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098377a83a4aea5659605f44b0ebac60/" rel="bookmark">
			iOS 添加震动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. AudioServicesPlaySystemSound 较早的系统版本，我们会使用AudioTool.framework。
#import &lt;AudioToolbox/AudioToolbox.h&gt; 一般震动
AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); 普通短震（类似3D Touch的 Peek 反馈 ）
AudioServicesPlaySystemSound(1519); 普通短震 （类似3D Touch Pop 反馈）
AudioServicesPlaySystemSound(1520); 连续三次短震
AudioServicesPlaySystemSound(1521); 2. UIImpactFeedbackGenerator iOS 10之后提供了UIImpactFeedbackGenerator
@interface UIImpactFeedbackGenerator : UIFeedbackGenerator - (instancetype)initWithStyle:(UIImpactFeedbackStyle)style; // 调用后开始震动 - (void)impactOccurred; // 调用后开始震动，强度从0～1 - (void)impactOccurredWithIntensity:(CGFloat)intensity API_AVAILABLE(ios(13.0)); @end UIImpactFeedbackStyle定义了震动的等级
typedef NS_ENUM(NSInteger, UIImpactFeedbackStyle) { UIImpactFeedbackStyleLight, UIImpactFeedbackStyleMedium, UIImpactFeedbackStyleHeavy, UIImpactFeedbackStyleSoft API_AVAILABLE(ios(13.0)), UIImpactFeedbackStyleRigid API_AVAILABLE(ios(13.0)) }; UIImpactFeedbackGenerator使用
UIImpactFeedbackGenerator *generator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleLight]; [generator prepare]; [generator impactOccurred]; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/40/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>