<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588ad0d465c4904a0a813d6ce4c84dcb/" rel="bookmark">
			c#如何采集需要登录的页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明：代码片段是从网络获取，然后自己修改。我想好的东西应该拿来分享。
先说下原理：当我们采集页面的时候，如果被采集的网站需要登录才能采集。不管是基于Cookie还是基于Session，我们都会首先发送一个Http请求头，这个Http请求头里面就包含了网站需要的Cookie信息。当网站接收到发送过来的Http请求头时，会从Http请求头获取相关的Cookie或者Session信息，然后由程序来处理，决定你是否有权限访问当前页面。
好了，原理搞清楚了，就好办了。我们所要做的仅仅是在采集的时候（或者说HttpWebRequest提交数据的时候），将Cookie信息放入Http请求头里面就可以了。
在这里我提供2种方法。
第一种，直接将Cookie信息放入HttpWebRequest的CookieContainer里。看代码：
protected void Page_Load(object sender, EventArgs e)
{
//设置Cookie，存入Hashtable
Hashtable ht = new Hashtable();
ht.Add("username", "youraccount");
ht.Add("id", "yourid");
this.Collect(ht);
}
public void Collect(Hashtable ht)
{
string content = string.Empty;
string url = "http://www.ibest100.com/需要登录后才能采集的页面";
string host = "http://www.ibest100.com";
try
{
//获取提交的字节
byte[] bs = Encoding.UTF8.GetBytes(content);
//设置提交的相关参数
HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(url);
req.Method = "POST";
req.ContentType = "application/json;charset=utf-8";
req.ContentLength = bs.Length;
//将Cookie放入CookieContainer，然后再将CookieContainer添加到HttpWebRequest
CookieContainer cc = new CookieContainer();
cc.Add(new Uri(host), new Cookie("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588ad0d465c4904a0a813d6ce4c84dcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2567d9838cac1b169a38999e1f5e8f92/" rel="bookmark">
			Java（多）线程中注入Spring的Bean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题说明 今天在web应用中用到了Java多线程的技术来并发处理一些业务，但在执行时一直会报NullPointerException的错误，问题定位了一下发现是线程中的Spring bean没有被注入，bean对象的值为null。 原因分析 web容器在启动应用时，并没有提前将线程中的bean注入（在线程启动前，web容易也是无法感知的） 解决方案 方法有多种，网上也看到了不少。 1. 使用static声明变量 可参见 引用 http://blog.csdn.net/bjamosgavin/article/details/6125497 但这个方法自己试了一下但是没有成功。。。 2. 把线程设置为主程序的内部类 这也是一种简单的方法，主程序在web容器加载时肯定是可以注入Spring bean的，那么将线程的实现类放在主程序的类中便可以“共享”Spring的bean，（当然，这需要提前把线程中的需要用到的bean定义在外层的类中）。 具体操作方法，就是将生成线程的线程池定义在主程序的类中，每个线程的实现类作为内部类也定义在主程序中。这个方法自己试过，是可以的。 3. 使用静态方法直接取的容器中的spring对象 这个方法稍微专业点，可以线程的分发与线程的实现分离出来。在每个线程中使用静态方法直接取的容器中的spring对象。 使用静态方法获取容器中的spring对象可以参见 引用 http://littie1987.iteye.com/blog/937877， 或者http://my.oschina.net/skyline520/blog/181158?p={{page}} 但一定要记住，你定义这个工具类也要配置成spring中的bean! 下面贴一下我在使用时的代码 （1）定义工具类 public class SpringApplicationContextHolder implements ApplicationContextAware { private static ApplicationContext context; @Override public void setApplicationContext(ApplicationContext context) throws BeansException { SpringApplicationContextHolder.context = context; } public static Object getSpringBean(String beanName) { notEmpty(beanName, "bean name is required"); return context==null?null:context.getBean(beanName); } public static String[] getBeanDefinitionNames() { return context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2567d9838cac1b169a38999e1f5e8f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95dfa833cf7da13277cdda4a00a69937/" rel="bookmark">
			wireshark过滤rtmp协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抓包，明明有rtmp协议，但是wireshark里输入rtmp却过滤不出来！
原来rtmp是给了另外一个路由协议用掉了！要输入rtmpt!
多个t
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bbbdd8985c49e943d6522fc9c0bdbf4/" rel="bookmark">
			解决Android Studio默认AppTheme主题找不到的问题 The following classes could not be found:     - android.support.v
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法1: 打开build.gradle (Module:app) 在dependencies中找到compile 'com.android.support:appcompat-v7:23.1.1' 改成com.android.support:appcompat-v7:23.0.1' 更新配置即可
解决方法2: 在style.xml中把&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; 改成&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; 也可以解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8c2b793053952602c7d3b004de1d25/" rel="bookmark">
			win10实现开机播放视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事先说明本文技术上没有什么发明，大多数是网上能找的到，更多是记录贴而不是技术创新。另外我不是windows方向而是android，当然这不是借口，只是如果可以不用windows高手专家的标准来批判的话，你可以少生一点“什么Windows烂文”的气，我的玻璃心也可以少一点郁闷，大概算皆大欢喜吧。
最近得到一个任务要弄一个win10平板上的开机视频播放，而且是用户刚拿到的机子，连win10系统第一次进入的设置都还没做过的机子，要让它第一次开机（包括设置过程）和后面开机都能一进去就全屏播放需要它播放的视频。
像我这样没怎么接触windows开发应该一开始想到的就是直接写个BAT或者VBS，然后放到“启动”目录下就好了。直接在“运行”里输入“shell:startup”，就能找到“启动”目录。最初的应急版本我也确实是这么做的，当然后面改用系统服务启动的方式，如果只是想看基于系统服务的直接跳过一就好。还有win10的“启动”目录如果要通过文件夹点击方式找的话，把hide Item勾选上，因为是在隐藏文件夹里，具体目录是：C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup。
一、基于开机启动项的方式
我的vbs代码是这样的
Set shell = Wscript.createobject("wscript.shell") shell.Run("""C:\Program Files\Windows Media Player\wmplayer.exe"" ""C:\Windows\ANTHEM.mp4"" -fullscreen""") WScript.Sleep 2000 shell.sendKeys "{UP}{UP}{enter}" WScript.Sleep 2000 shell.sendKeys "%{TAB}" WScript.Sleep 127000 CreateObject("WScript.Shell").Run "taskkill /f /im wmplayer.exe", 0 使用上前面已经讲过就是把vbs放入开机启动项目录里，需要说明一下为什么这样。之所以用windows media player不是因为我多喜欢他，只是这是一个刚刚安装的原始系统，除了“movies &amp; TV”(中文版就是：电影和电视)就是media player。至于为什么不用"movies &amp; TV"来播放，当时确实纠结过，原因很乱，比如我找到的“movies &amp; TV”播放目录里的是需要在什么“应用容器上下文中运行”的，如果有知道怎么可以用vbs运行，请不吝指教。如果直接用vbs不指定播放器来播放，那么第一次播放会用media player,而第二次播放又变成“movies &amp; TV”(或者是反过来)。还有一个原因“movies &amp; TV”的全屏播放快捷键是什么我不知道（知道的也请教一下），当然可以通过按键模拟来实现，但是总是又多了一些不稳定隐患。这条运行wmplayer的命令一开始可不是这样的，正如我说的我的vbs也就是初学者水平，media player的快捷键有-fullscreen一开始也不知道，这是后来不断搜索和修改的结果。
然后解释一下下面的模拟按键是怎么回事，"{UP}{UP}{enter}"是因为要解决media player第一次播放会弹出的设置框，想看的可以自己在自己的windows机子上运行"C:\Program Files\Windows Media Player\setup_wm.exe"，如果你的windows上有media player没被你毁掉的话，就能看见了。模拟按键的效果就是选中“推荐设置”然后确定。
"%{TAB}"是为了应对，win10用户开机后切换到平板模式，然后关机再开机，这个时候进入的是平板模式，前面做的全屏播放，这个时候只会再后面的windows界面播放，而平板开机看到的界面看不到，所以需要用这个模拟按键，把视频切换出来。
最后一条命令是为了让视频播放完能自动关闭。
基于开机启动项模式确实太初学者，就讲这些了，主要要记录一下基于windows系统服务的方法。
二、基于windows系统服务的方式
用这种方式是因为一的方式太慢，用系统服务就快了。代码用的是C#，一开始也是在C++和C#中间游离，最后决定就用C#，主要是2里得到现成的C#的方案，而这个方案解决了一个关键问题。
1.注册系统服务程序
首先是如何注册系统服务程序，这个没什么可说百度或者谷歌“C#注册系统服务”，我的代码除了自己的需求都和别人的没两样。说点自己试验的过程中遇过的问题。“添加安装程序”这一步后，得到的serviceInstaller里的serviceName属性的命名必须和你的系统服务cs文件里的base.ServiceName = "**";要一致，以及在你的service.cs里一定要有base.ServiceName = "**"，否则都无法注册系统服务。而serviceprocessInstaller里的Account最好用LocalSystem，否则可能出现你注册了自启动服务，但是服务却没有开机启动。
2.会话0隔离的突破
注册里系统服务后发现无论如何都无法播放视频，这个问题发现之后花了不少时间来找答案，最后才知道原来windows自从vista以来就开始有会话0隔离。直接效果上说就是你注册的自定义的系统服务打开的GUI界面在我们开机看到的界面里是看不到的，如果你不突破session 0的话，不管你怎么设置这个服务的属性，sc命令了如指掌也没用。而这个问题对我很关键，如果不能看到视频播放界面，那用系统服务就没用了。这里有一篇C#突破会话0隔离的文章，我就是借鉴的这个方法，就不敢卖弄了，直接给大牛的链接：点击打开链接。（如果对链接文章有什么感悟希望能来这里指点一二）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8c2b793053952602c7d3b004de1d25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de9e999685c4f3927c6efd2c9e215cdf/" rel="bookmark">
			oracle client 64位的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载安装；
1. 下载；
百度云网盘地址：http://pan.baidu.com/s/1o7tMI3C
提取密码：894v
2. 解压；
3. 运行setup.exe；
4. 选择“管理员”，然后下一步，直至安装成功；
二、配置；
1. 开始&gt;所有程序&gt;Oracle - OraClient11g_home1&gt;net configuration Assistant
2. 按如下图选择；
说明监听启动成功；
然后选择下图，按照提示填写服务名和IP地址；并进行测试
详细的步骤见百度经验：
http://jingyan.baidu.com/album/7e440953de84682fc0e2ef95.html?picindex=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c33dc7cccd00a406d9f637fffda0b0c/" rel="bookmark">
			关于如何彻底消除unity中的弹力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，在unity中应该是无法彻底消除弹力的，即使你把physics中的弹力设为0，即使你给collider添加物理材质，都是没法消除弹力的，具体表现为：改和没改一个样。。。。呵呵，我想这可能物理引擎的一个bug， 为什么这么说呢，因为可以改变的只是带有刚体的物体和不带有刚体的物体之间的碰撞(对，可以彻底消除)，然后刚体之间的弹力是无法解决的。 那么问题来了，我们该怎么消除刚体之间的弹力呢？有一个很巧妙的方法，那就是通过改变刚体的速度，即rigidbody.velocity，你只要在物体即将弹起的时候把速度设为0就可以了。 具体代码有时间再写吧，今天太累。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/470f97a79b5fbf231bbed187dd3469cd/" rel="bookmark">
			Tegra X1性能解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[摘要]它是一个名副其实的性能怪兽：虽然它的图形性能是iPad Air 2上搭载的A8X芯片的两倍，但是耗费的电量却相差不多。
腾讯数码讯（编译：Hamish）今天英伟达抢在CES 2015大会召开前发布了新款移动芯片Tegra X1，这是一个名副其实的性能怪兽：虽然它的图形性能是iPad Air 2上搭载的A8X芯片的两倍，但是耗费的电量却相差不多。目前Tegra X1已经准备进入投产阶段，不久之后人们就能在搭载这款芯片的平板电脑上体验到它强大的图形处理能力。
Tegra X1强劲的性能表明，未来市面上平板电脑的游戏性能将越来越接近台式电脑。Tegra X1采用的是英伟达最新的Maxwell架构，和该公司目前最新的GeForce GTX系列桌面显卡保持一致，此前Tegra K1采用的也是和桌面一致的Kepler架构。由于Tegra X1和桌面显卡采用相同的架构，因此游戏开发商可以更便捷地通过桌面游戏的API实现产品的移动化。
Tegra X1搭载了256个核心的Maxwell架构显卡和一颗8核64位ARM处理器。它可以播放每秒60帧的4K超高清视频，支持H.265和VP9解码。和苹果一样，它采用的是20纳米工艺制程，因此我们可以直接将这两款芯片的图形性能进行比较。我们在经过了一系列的基准测试后发现，Tegra X1的性能不仅超过了苹果A8X，还超过了自家的Tegra K1。要知道，配备Tegra K1的Nvidia Shield Tablet是当前Android平板电脑中图形处理性能的王者。
在1080p（Offscreen）测试中，Tegra X1的分数几乎是Tegra K1的两倍。在3Dmark 1.3 Icestorm Unlimited测试中，Tegra X1的分数是Tegra K1的1.5倍，大约是A8X的两倍；在BasemarkX 1.1测试中，Tegra X1的分数分别是Tegra K1和A8X的1.5倍。实际上，Tegra X1在功耗控制方面的表现更加让人印象深刻：在相同功耗下，它的性能是Tegra K1的2倍，A8X的1.7倍。
当前Netflix等其他内容提供商正准备为用户提供4K视频服务，它们将从英伟达在移动显卡和芯片方面的努力中获益，每秒60帧的速度对于体育内容和游戏视频的好处显而易见。另外，能够播放超高清视频的芯片对于虚拟现实技术这样的新兴技术而言相当重要，今后玩家可以在设备中获得更加光滑、无缝的视频体验。
另外，Tegra X1还支持每秒60帧的4K视频输出，这些视频相比30帧的版本看起来要顺畅不少。不过当前这类别的资源并多见，好在市面上支持4K视频拍摄的设备（如GoPro Hero 4 Black）越来越多，不久之后4K视频将覆盖更多的人群。
去年有不少应用在Tegra K1上出现了崩溃的情况，为了真正打动用户，英伟达必须阻止这种情况再次发生。不过在Android的世界里，想要做到这点并不容易，因为这个系统存在严重分裂的情况。
这也正是促使英伟达决定打造覆盖Shield平板电脑在内的平台，同时马上将Tegra X1投入生产的原因。看来距离我们见到Tegra X1设备的日子已经不是太远。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdff4918f5d93e6bcda4a754bb598fde/" rel="bookmark">
			sqlServer 查看表结构（字段类型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sp_help tableXXX
对MySQL和Oracle熟悉的朋友知道用desc就可以查询一张表的结构，但是在SQL Server里执行desc命令会报错。
现提供两条命令查询表结构：
1.sp_help table_name; 如： [sql] sp_help Student;
2.sp_columns table_name;
如： [sql] sp_columns Student;
推荐使用sp_help table_name，因为这条命令查询出的表结构信息更加详细。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b2c30991eb52be8add8dea92f3e6193/" rel="bookmark">
			Visual Studio 2015专业版安装激活图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载安装镜像 下载地址：http://msdn.itellyou.cn/ （微软的东东在这里下方便快速） 本人下载的是专业版。 二、安装 Windows 8.1系统双击下载好的ISO文件会自动虚拟光驱。
双击运行文件。
想体验新版的更多功能，这里选择【自定义】，点击【下一步】。
选择【全选】，点击【下一步】。
点击【安装】。
这个时候就剩下慢长的等待，20M光纤宽带花了将近5个小时。
终于看到【安装已完成】，点击【立即重新启动】。
装完桌面没的快捷图标，点开始再点【Visual Studio 2015】。
起动界面来啦！哈哈。
这里要用微软账号【登录】，没有的就先自己注册一个吧。
输入你的微软账号和密码，点击【登录】。
点击【继续】。
点击【继续】。
开发设置里我选的是常规，可以根据自己的实情选择。
喜欢黑色的主题，点击【启动Visual Studio】。
这次等的时间不长，一会就好。
哈哈，看到这张图，你就安装完成了。
三、激活
安装完成也先别高兴，不激活的话只能试用90天。
让我们把它激活一下吧。
选择【帮助】菜单，点【注册产品】。
点击【使用产品密钥获得许可】。
输入专业版的【产品密钥】，点击【应用】。
附送产品密钥
专业版：HMGNV-WCYXV-X7G9W-YCX63-B98R2
企业版：HM6NR-QXX7C-DFW2Y-8B82K-WTYJV
看到这个你就可以开始你的开发旅程啦，加油！冲啊！
Visual Studio 2015 发行说明：
https://visualstudio.com/zh-cn/news/vs2015-vs.aspx
Visual Studio 2015 特性简介： 通过使用单个 IDE，可以创建面向 Windows、iOS、Android 等的多平台应用。
—Web、移动和云开发工具 — 构建面向 Windows、Android 和 iOS 的应用 —集成的设计器、编辑器、调试器和探查器 —采用 C#、C++、JavaScript、Python、TypeScript、Visual Basic、F# 等进行编码 —能够部署、调试和管理 Microsoft Azure 服务 —成千上万的扩展（从 PHP 到游戏）
Visual Studio Community 2015 简体中文免费版
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b2c30991eb52be8add8dea92f3e6193/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5525650e15ae83e03366db70ee52006a/" rel="bookmark">
			Unity中创建自己的mesh以及动态修改mesh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开头 最近发现有很多人不知道在unity中可以创建和修改mesh，以为mesh只能从3dmax等软件中导入，所以这篇就相当于科普了。 正文 首先介绍如何创建mesh。 先创建一个空物体，名为test。 然后为这个物体增加 meshrender 和 meshfilter 两个组件
下面就要写将要赋给它的脚本了，先贴上代码，解释在下面。 using UnityEngine; using System.Collections; public class Test: MonoBehaviour { void Start() { Vector3[] newVertices = { new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 0), new Vector3(1, 0, 0) }; Vector2[] newUV = { new Vector2(0, 0), new Vector2(0, 1), new Vector2(1, 1), new Vector2(1, 0) }; int[] newTriangles = {0,2,1,0,3,2}; Mesh mesh = new Mesh(); GetComponent&lt;MeshFilter&gt;().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5525650e15ae83e03366db70ee52006a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6765d437b679480e72b88aec7a5ec6/" rel="bookmark">
			ios开发-判断邮箱、手机号、车牌、身份证。。。。。合法性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//邮箱 + (BOOL) validateEmail:(NSString *)email { NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}"; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex]; return [emailTest evaluateWithObject:email]; } //手机号码验证 + (BOOL) validateMobile:(NSString *)mobile { //手机号以13， 15，18开头，八个 \d 数字字符 NSString *phoneRegex = @"^((13[0-9])|(15[^4,\\D])|(18[0,0-9]))\\d{8}$"; NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",phoneRegex]; return [phoneTest evaluateWithObject:mobile]; } //车牌号验证 + (BOOL) validateCarNo:(NSString *)carNo { NSString *carRegex = @"^[\u4e00-\u9fa5]{1}[a-zA-Z]{1}[a-zA-Z_0-9]{4}[a-zA-Z_0-9_\u4e00-\u9fa5]$"; NSPredicate *carTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",carRegex]; NSLog(@"carTest is %@",carTest); return [carTest evaluateWithObject:carNo]; } //车型 + (BOOL) validateCarType:(NSString *)CarType { NSString *CarTypeRegex = @"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6765d437b679480e72b88aec7a5ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2120399652cafdb8f5a43f7dcdf6685/" rel="bookmark">
			Android线程管理（二）——ActivityThread
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程通信、ActivityThread及Thread类是理解Android线程管理的关键。 线程，作为CPU调度资源的基本单位，在Android等针对嵌入式设备的操作系统中，有着非常重要和基础的作用。本小节主要从以下三个方面进行分析： 《Android线程管理（一）——线程通信》 《Android线程管理（二）——ActivityThread》 《Android线程管理（三）——Thread类的内部原理、休眠及唤醒》 二、ActivityThread的主要工作及实现机制 ActivityThread是Android应用的主线程（UI线程），说起ActivityThread，不得不提到Activity的创建、启动过程以及ActivityManagerService，但本文将仅从线程管理的角度来分析ActivityThread。ActivityManagerService、ActivityStack、ApplicationThread等会在后续文章中详细分析，敬请期待喔~~不过为了说清楚ActivityThread的由来，还是需要简单介绍下。
以下引用自罗升阳大师的博客：《Android应用程序的Activity启动过程简要介绍和学习计划》
Step 1. 无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口； Step 2. ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息； Step 3. ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread代表的是调用ActivityManagerService.startActivity接口的进程，对于通过点击应用程序图标的情景来说，这个进程就是Launcher了，而对于通过在Activity内部调用startActivity的情景来说，这个进程就是这个Activity所在的进程了； Step 4. ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity； Step 5. 对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动； Step 6. ActivityManagerServic调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作； Step 7. ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。
大师的这段描述把ActivityManagerService、ActivityStack、ApplicationThread及ActivityThread的调用关系讲的很清楚，本文将从ActivityThread的main()方法开始分析其主要工作及实现机制。
ActivityThread源码来自：https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java
public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2120399652cafdb8f5a43f7dcdf6685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17c60d46db5770a9ca954e74c01e950/" rel="bookmark">
			Oracle&amp;nbsp;Constraint_type,约束类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 oracle constraint_type 问题 select distinct constraint_type from dba_constraints; 结果： CONSTRAINT_TYPE ? C --check O P --primary key R --forgien key U --unique V 其他三个是什么？ constraint的类型： 1、primary key unique and not null,可以是多个column的联合。composite pk只能被定义为table constraint 2、foreign key parent table 中的primary key中的values必须包含child table中所有的values. share column的parent-child 关系 3、unique 4、check present in a static list of values permitted for the column. 5、not null 只能被定义在column constraint （2，3，4允许null) Type Code Type Description Acts On Level C Check on a table Column O Read Only on a view Object P Primary Key Object R Referential AKA Foreign Key Column U Unique Key Column V Check Option on a view Object 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156d05129829052b8fbf861e1d7fd824/" rel="bookmark">
			卷积神经网络(CNN)基础介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是对卷积神经网络的基础进行介绍，主要内容包括卷积神经网络概念、卷积神经网络结构、卷积神经网络求解、卷积神经网络LeNet-5结构分析、卷积神经网络注意事项。
一、卷积神经网络概念
上世纪60年代，Hubel等人通过对猫视觉皮层细胞的研究，提出了感受野这个概念，到80年代，Fukushima在感受野概念的基础之上提出了神经认知机的概念，可以看作是卷积神经网络的第一个实现网络，神经认知机将一个视觉模式分解成许多子模式（特征），然后进入分层递阶式相连的特征平面进行处理，它试图将视觉系统模型化，使其能够在即使物体有位移或轻微变形的时候，也能完成识别。
卷积神经网络(Convolutional Neural Networks, CNN)是多层感知机(MLP)的变种。由生物学家休博尔和维瑟尔在早期关于猫视觉皮层的研究发展而来。视觉皮层的细胞存在一个复杂的构造。这些细胞对视觉输入空间的子区域非常敏感，我们称之为感受野，以这种方式平铺覆盖到整个视野区域。这些细胞可以分为两种基本类型，简单细胞和复杂细胞。简单细胞最大程度响应来自感受野范围内的边缘刺激模式。复杂细胞有更大的接受域，它对来自确切位置的刺激具有局部不变性。
通常神经认知机包含两类神经元，即承担特征提取的采样元和抗变形的卷积元，采样元中涉及两个重要参数，即感受野与阈值参数，前者确定输入连接的数目，后者则控制对特征子模式的反应程度。卷积神经网络可以看作是神经认知机的推广形式，神经认知机是卷积神经网络的一种特例。
CNN由纽约大学的Yann LeCun于1998年提出。CNN本质上是一个多层感知机，其成功的原因关键在于它所采用的局部连接和共享权值的方式，一方面减少了的权值的数量使得网络易于优化，另一方面降低了过拟合的风险。CNN是神经网络中的一种，它的权值共享网络结构使之更类似于生物神经网络，降低了网络模型的复杂度，减少了权值的数量。该优点在网络的输入是多维图像时表现的更为明显，使图像可以直接作为网络的输入，避免了传统识别算法中复杂的特征提取和数据重建过程。在二维图像处理上有众多优势，如网络能自行抽取图像特征包括颜色、纹理、形状及图像的拓扑结构；在处理二维图像问题上，特别是识别位移、缩放及其它形式扭曲不变性的应用上具有良好的鲁棒性和运算效率等。
CNN本身可以采用不同的神经元和学习规则的组合形式。
CNN具有一些传统技术所没有的优点：良好的容错能力、并行处理能力和自学习能力，可处理环境信息复杂，背景知识不清楚，推理规则不明确情况下的问题，允许样品有较大的缺损、畸变，运行速度快，自适应性能好，具有较高的分辨率。它是通过结构重组和减少权值将特征抽取功能融合进多层感知器，省略识别前复杂的图像特征抽取过程。
CNN的泛化能力要显著优于其它方法，卷积神经网络已被应用于模式分类，物体检测和物体识别等方面。利用卷积神经网络建立模式分类器，将卷积神经网络作为通用的模式分类器，直接用于灰度图像。
CNN是一个前溃式神经网络，能从一个二维图像中提取其拓扑结构，采用反向传播算法来优化网络结构，求解网络中的未知参数。
CNN是一类特别设计用来处理二维数据的多层神经网络。CNN被认为是第一个真正成功的采用多层层次结构网络的具有鲁棒性的深度学习方法。CNN通过挖掘数据中的空间上的相关性，来减少网络中的可训练参数的数量，达到改进前向传播网络的反向传播算法效率，因为CNN需要非常少的数据预处理工作，所以也被认为是一种深度学习的方法。在CNN中，图像中的小块区域（也叫做“局部感知区域”）被当做层次结构中的底层的输入数据，信息通过前向传播经过网络中的各个层，在每一层中都由过滤器构成，以便能够获得观测数据的一些显著特征。因为局部感知区域能够获得一些基础的特征，比如图像中的边界和角落等，这种方法能够提供一定程度对位移、拉伸和旋转的相对不变性。
CNN中层次之间的紧密联系和空间信息使得其特别适用于图像的处理和理解，并且能够自动的从图像抽取出丰富的相关特性。
CNN通过结合局部感知区域、共享权重、空间或者时间上的降采样来充分利用数据本身包含的局部性等特征，优化网络结构，并且保证一定程度上的位移和变形的不变性。
CNN受视觉神经机制的启发而设计,是为识别二维或三维信号而设计的一个多层感知器,这种网络结构对平移、缩放、倾斜等变形具有高度不变性。
CNN可以用来识别位移、缩放及其它形式扭曲不变性的二维或三维图像。CNN的特征提取层参数是通过训练数据学习得到的，所以其避免了人工特征提取，而是从训练数据中进行学习；其次同一特征图的神经元共享权值，减少了网络参数，这也是卷积网络相对于全连接网络的一大优势。共享局部权值这一特殊结构更接近于真实的生物神经网络使CNN在图像处理、语音识别领域有着独特的优越性，另一方面权值共享同时降低了网络的复杂性，且多维输入信号（语音、图像）可以直接输入网络的特点避免了特征提取和分类过程中数据重排的过程。
CNN是一种特殊的深层的神经网络模型，它的特殊性体现在两个方面，一方面它的神经元的连接是非全连接的，另一方面同一层中某些神经元之间的连接的权重是共享的（即相同的）。它的非全连接和权值共享的网络结构使之更类似于生物神经网络，降低了网络模型的复杂度（对于很难学习的深层结构来说，这是非常重要的），减少了权值的数量。
CNN是一种深度的监督学习下的机器学习模型，具有极强的适应性，善于挖掘数据局部特征，提取全局训练特征和分类，它的权值共享结构网络使之更类似于生物神经网络，在模式识别各个领域都取得了很好的成果。
稀疏连接：在BP神经网络中，每一层的神经元节点是一个线性一维排列结构，层与层各神经元节点之间是全连接的。卷积神经网络中，层与层之间的神经元节点不再是全连接形式，利用层间局部空间相关性将相邻每一层的神经元节点只与和它相近的上层神经元节点连接，即局部连接。这样大大降低了神经网络架构的参数规模。
权重共享：在卷积神经网络中，卷积层的每一个卷积滤波器重复的作用于整个感受野中，对输入图像进行卷积，卷积结果构成了输入图像的特征图，提取出图像的局部特征。每一个卷积滤波器共享相同的参数，包括相同的权重矩阵和偏置项。共享权重的好处是在对图像进行特征提取时不用考虑局部特征的位置。而且权重共享提供了一种有效的方式，使要学习的卷积神经网络模型参数数量大大降低。
最大池采样：它是一种非线性降采样方法。在通过卷积获取图像特征之后是利用这些特征进行分类。可以用所有提取到的特征数据进行分类器的训练，但这通常会产生极大的计算量。所以在获取图像的卷积特征后，要通过最大池采样方法对卷积特征进行降维。将卷积特征划分为数个n*n的不相交区域，用这些区域的最大(或平均)特征来表示降维后的卷积特征。这些降维后的特征更容易进行分类。
最大池采样在计算机视觉中的价值体现在两个方面：(1)、它减小了来自上层隐藏层的计算复杂度；(2)、这些池化单元具有平移不变性，即使图像有小的位移，提取到的特征依然会保持不变。由于增强了对位移的鲁棒性，最大池采样方法是一个高效的降低数据维度的采样方法。
Softmax回归：它是在逻辑回归的基础上扩张而来，它的目的是为了解决多分类问题。在这类问题中，训练样本的种类一般在两个以上。Softmax回归是有监督学习算法，它也可以与深度学习或无监督学习方法结合使用。
CNN是一种带有卷积结构的深度神经网络，通常至少有两个非线性可训练的卷积层，两个非线性的固定卷积层（又叫Pooling Laye）和一个全连接层，一共至少5个隐含层。
卷积神经网络中，输入就是一幅幅的图像，权值W就是卷积模板，一般是卷积层和下采样层交替，最后是全连接的神经网络。
局部区域感知能够发现数据的一些局部特征，比如图片上的一个角，一段弧，这些基本特征是构成动物视觉的基础。
CNN中每一层的由多个map组成，每个map由多个神经单元组成，同一个map的所有神经单元共用一个卷积核（即权重），卷积核往往代表一个特征，比如某个卷积核代表一段弧，那么把这个卷积核在整个图片上滚一下，卷积值较大的区域就很有可能是一段弧。注意卷积核其实就是权重，我们并不需要单独去计算一个卷积，而是一个固定大小的权重矩阵去图像上匹配时，这个操作与卷积类似，因此我们称为卷积神经网络，实际上，BP也可以看作一种特殊的卷积神经网络，只是这个卷积核就是某层的所有权重，即感知区域是整个图像。权重共享策略减少了需要训练的参数，使得训练出来的模型的泛华能力更强。
CNN一般采用卷积层与采样层交替设置，即一层卷积层接一层采样层，采样层后接一层卷积...这样卷积层提取出特征，再进行组合形成更抽象的特征，最后形成对图片对象的描述特征，CNN后面还可以跟全连接层，全连接层跟BP一样。
CNN的最大特点就是稀疏连接（局部感受）和权值共享。稀疏连接和权值共享可以减少所要训练的参数，减少计算复杂度。
卷积神经网络是一个多层的神经网络，每层由多个二维平面组成，而每个平面由多个独立神经元组成。
卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。卷积网络执行的是有导师训练，所以其样本集是由形如：（输入向量，理想输出向量）的向量对构成的。所有这些向量对，都应该是来源于网络即将模拟的系统的实际“运行”结果。它们可以是从实际运行系统中采集来的。在开始训练前，所有的权都应该用一些不同的小随机数进行初始化。“小随机数”用来保证网络不会因权值过大而进入饱和状态，从而导致训练失败；“不同”用来保证网络可以正常地学习。实际上，如果用相同的数去初始化权矩阵，则网络无能力学习。训练算法与传统的BP算法差不多。
二、卷积神经网络结构
卷积神经网络整体架构：卷积神经网络是一种多层的监督学习神经网络，隐含层的卷积层和池采样层是实现卷积神经网络特征提取功能的核心模块。该网络模型通过采用梯度下降法最小化损失函数对网络中的权重参数逐层反向调节，通过频繁的迭代训练提高网络的精度。卷积神经网络的低隐层是由卷积层和最大池采样层交替组成，高层是全连接层对应传统多层感知器的隐含层和逻辑回归分类器。第一个全连接层的输入是由卷积层和子采样层进行特征提取得到的特征图像。最后一层输出层是一个分类器，可以采用逻辑回归，Softmax回归甚至是支持向量机对输入图像进行分类。
卷积神经网络结构包括：卷积层，降采样层，全链接层。每一层有多个特征图，每个特征图通过一种卷积滤波器提取输入的一种特征，每个特征图有多个神经元。
卷积层：使用卷积层的原因是卷积运算的一个重要特点是，通过卷积运算，可以使原信号特征增强，并且降低噪音。
降采样层：使用降采样的原因是，根据图像局部相关性的原理，对图像进行子采样可以减少计算量，同时保持图像旋转不变性。
采样的目的主要是混淆特征的具体位置，因为某个特征找出来后，它的具体位置已经不重要了，我们只需要这个特征与其他的相对位置，比如一个“8”，当我们得到了上面一个"o"时，我们不需要知道它在图像的具体位置，只需要知道它下面又是一个“o”我们就可以知道是一个'8'了，因为图片中"8"在图片中偏左或者偏右都不影响我们认识它，这种混淆具体位置的策略能对变形和扭曲的图片进行识别。
全连接层：采用softmax全连接，得到的激活值即卷积神经网络提取到的图片特征。
卷积层的map个数是在网络初始化指定的，而卷积层的map的大小是由卷积核和上一层输入map的大小决定的，假设上一层的map大小是n*n、卷积核的大小是k*k，则该层的map大小是(n-k+1)*(n-k+1)。
采样层是对上一层map的一个采样处理，这里的采样方式是对上一层map的相邻小区域进行聚合统计，区域大小为scale*scale，有些实现是取小区域的最大值，而ToolBox里面的实现是采用2*2小区域的均值。注意，卷积的计算窗口是有重叠的，而采样的计算窗口没有重叠，ToolBox里面计算采样也是用卷积(conv2(A,K,'valid'))来实现的，卷积核是2*2，每个元素都是1/4，去掉计算得到的卷积结果中有重叠的部分。
CNN的基本结构包括两种特殊的神经元层，其一为卷积层，每个神经元的输入与前一层的局部相连，并提取该局部的特征；其二是池化层，用来求局部敏感性与二次特征提取的计算层。这种两次特征提取结构减少了特征分辨率，减少了需要优化的参数数目。
CNN是部分连接网络，其最底层是特征提取层（卷积层），接着是池化层（Pooling），然后可以继续增加卷积、池化或全连接层。用于模式分类的CNN，通常在最后层使用softmax.
一般情况下，CNN的结构形式是：输入层--&gt; Conv层 --&gt; Pooling层 --&gt; (重复Conv、Pooling层) … --&gt; FC(Full-connected)层 --&gt; 输出结果。通常输入层大小一般为2的整数倍，如32,64,96,224,384等。通常卷积层使用较小的filter，如3*3，最大也就5*5。Pooling层用于对卷积结果进行降低维度，例如选择2*2的区域对卷积层进行降低维度，则选择2*2区域的最大值作为输出，这样卷积层的维度就降为之前一半。
一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。
对于图像识别任务，卷积神经网络的结构一般如下图所示。输入层读入经过简单的规则化（统一大小）的图像。每一层中的单元将前一层中的一组小的局部近邻的单元作为输入。这种局部连接观点来源于早期的感知器，并且和Hubel、Wiesel从猫科动物的视觉系统中发现的局部感知、方向选择神经元相一致。通过局部感知场，神经元能够抽取一些基本的视觉特征，比如有向边、结束点、边角等等。这些特征然后被更高层的神经元所使用。并且，适用于某个局部的基础特征抽取器同样也倾向于适用于整个图像。通过利用这种特征，卷积神经网络利用一组分布于图像各个不同位置但具有相同权值向量的单元，来获取图像的特征并构成一幅特征图（Feature Map）。在每个位置，来自不同特征图的单元得到各自不同类型的特征。一个特征图中的不同单元被限制为对输入图中的各个不同位置的局部数据进行同样的操作。这种操作等同于将输入图像对于一个小的核进行卷积。一个卷积层中通常包含多个具有不同权值向量的特征图，使得在同一个位置能够获得多种不同的特征。如下图，第一个隐含层包含4个特征图，每个特征图由5*5的局部感知区域构成。一旦一个特征被检测到，只要其相对于其他特征的相对位置没有改变，那么其在图像中的绝对位置就变得不是特别重要。因此，每个卷积层后面跟随着一个降采样层。降采样层进行局部平均和降采样的操作，降低特征图的分辨率，同时降低了网络输出对于位移和变形的敏感程度。第二个隐含层进行2*2的平均化降采样的操作。后续的卷积层和降采样层都交替分布连接，构成一个“双金字塔”结构：特征图的数目逐渐增多，而且特征图的分辨率逐渐降低。
由于所有权重都是通过反向传播算法训练得到 ，卷积神经网络可以被看作自动合成其自身的特征抽取器。
一般情况下卷积神经网络中，卷积层和降采样层交替连接在一起，用于降低计算时间并逐步建立起更高的空间和数据结构不变性，并通过比较小的降采样系数使得这些特性得以维持。
CNN的分类模型与传统模型的不同点在于其可以直接将一幅二维图像输入模型中，接着在输出端即给出分类结果。其优势在于不需复杂的预处理，将特征抽取，模式分类完全放入一个黑匣子中，通过不断的优化来获得网络所需参数，在输出层给出所需分类，网络核心就是网络的结构设计与网络的求解。这种求解结构比以往多种算法性能更高。
CNN是一个多层的神经网络，每层由多个二维平面组成，而每个平面由多个独立神经元组成。网络中包含简单元（S-元）和复杂元（C-元），S-元聚合在一起组成S-面，S-面聚合在一起组成S-层。C-元、C-面和C-层之间存在类似的关系。网络的中间部分由S-层与C-层串接而成，输入级只含一层，它直接接受二维视觉模式。样本特征提取步骤已嵌入到卷积神经网络模型的互联结构中。
一般，S为特征提取层，每个神经元的输入与前一层的局部感受野相连接，并提取该局部的特征，一旦该局部特征被提取，它与其它特征之间的位置关系就被确定；C是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射为一个平面，平面上所有神经元的权值相同。特征映射结构采用影响函数核小的Sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。由于每个映射面上的神经元权值共享，减少了网络的自由参数数目，降低了网络参数选择的复杂度。CNN中的每一个特征提取层（S-层）都跟着一个用来求局部平均与二次提取的计算层（C-层），这种特有的两次特征提取结构使网络在识别时对输入样本有较高的畸变容忍能力。
CNN网络除了输入输出层，还有中间的卷积层，抽样层与全连接层，将原始图像直接输入到输入层，原始图像的大小决定了输入向量的尺寸，神经元提取图像的局部特征，每个神经元都与前一层的局部感受野相连，通过交替出现的抽样层（S）与卷积层（C）和最后的全连接层，在输出层给出网络的输出。在卷积层和抽样层中有若干个特征图，每一层有多个平面，每层中各平面的神经元提取图像中特定区域的局部特征，如边缘特征，方向特征等，在训练时不断修正S-层神经元的权值。同一层面上的神经元权值相同，这样可以有相同程度的位移、旋转不变性。由于权值共享，所以从一个平面到下个平面的映射可以看做是作卷积运算，S-层可看作是模糊滤波器，起到二次特征提取的作用。隐层与隐层之间空间分辨率递减，每层所含的平面数递增，这样可用于检测更多的特征信息。
卷积层中，前一层的特征图与一个可学习的核进行卷积，卷积的结果经过激活函数后的输出形成这一层的神经元，从而构成该层特征图。卷积层与抽样层间隔出现，卷积层每一个输出的特征图可能与前一层的几个特征图的卷积建立关系。每个特征图可以有不同的卷积核。卷积层主要的任务就是从不同的角度来选择前一层特征图的各角度特征使其具有位移不变性。卷积的本质就是对前一层的特征图进行处理，来得到这一层的特征图。抽样层主要作用是降低网络的空间分辨率，通过降低图像的空间分辨率来消除偏移和图像的扭曲。
隐层的参数个数和隐层的神经元个数无关，只和滤波器的大小和滤波器种类的多少有关。隐层的神经元个数,它和原图像，也就是输入的大小（神经元个数）、滤波器的大小和滤波器在图像中的滑动步长都有关。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/156d05129829052b8fbf861e1d7fd824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92de6a6353d656058dd946e9403ff3fa/" rel="bookmark">
			android  sdk是个啥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、sdk顾名思义就是提供的开发工具集。日常开发中常用的工具，比如logcat,traceview,sqlite3等 2、sdk platforms其实也是提供各种工具的，只不过为了照顾不同的Android版本，这些工具在每个版本都可能有不同的实现，这里提供的工具有adb,aapt,aidl等。还是截个图看看都有哪些工具吧 3、tools和build-tools包含了太多好用的工具，每个单独拿出来都可以介绍一大篇，建议题主先去官方文档了解一下，如果想深入的话，可以看看源码。比如adb的源码其实就蛮有意思的，已经有人把adb移植到Ubuntu，这样adb就可以识别任何你想识别的设备。 sdk+版本号，主要是提供你开发时候要使用的那个版本api。比如你开发中如果用到了5.0的api，那么你就要安装5.0的sdk android support repository主要是方便在gradle中使用android support libraries，因为Google并没有把这些库发布到maven center或者jcenter去，而是使用了Google自己的maven仓库。 support library就是提供suppport库给你用的，比如support v4,support v7。 google repository主要是给gradle使用的，方面添加比如Google Play Service的引用。这样gradle就可以使用google的maven仓库中的库了，而不需要去maven centee或者jcenter了。 根据官方文档的描述 SDK Tools 必须 SDK Platform-tools 必须 SDK Platform必须至少安装一个版本 System Image建议安装 Android Support建议安装 SDK Samples建议安装 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576e97f689f745aa3407db71986ebc21/" rel="bookmark">
			自定义Dialog，实现由下而上的弹出效果（模仿QQ退出等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法：
public Dialog createDialog(Context context, View view) { Dialog mSelectPhotoDialog = null; mSelectPhotoDialog = new Dialog(context, R.style.transparentFrameWindowStyle); mSelectPhotoDialog.setContentView(view); Window window = mSelectPhotoDialog.getWindow(); // 设置显示动画 window.setWindowAnimations(R.style.select_photo_dialog_animstyle); WindowManager.LayoutParams wl = window.getAttributes(); wl.x = 0; wl.y = getActivity().getWindowManager().getDefaultDisplay().getHeight(); // 以下这两句是为了保证按钮可以水平满屏 wl.width = ViewGroup.LayoutParams.MATCH_PARENT; wl.height = ViewGroup.LayoutParams.WRAP_CONTENT; // 设置显示位置 mSelectPhotoDialog.onWindowAttributesChanged(wl); // 设置点击外围解散 mSelectPhotoDialog.setCanceledOnTouchOutside(true); mSelectPhotoDialog.show(); } 样式：
&lt;!-- 头像弹出窗的动画效果 --&gt; &lt;style name="select_photo_dialog_animstyle"&gt; &lt;item name="android:windowEnterAnimation"&gt;@anim/photo_dialog_in_anim&lt;/item&gt; &lt;item name="android:windowExitAnimation"&gt;@anim/photo_dialog_out_anim&lt;/item&gt; &lt;/style&gt; &lt;!-- 头像弹出窗的样式：无边框 背景透明--&gt; &lt;style name="transparentFrameWindowStyle" parent="android:style/Theme.Dialog"&gt; &lt;item name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576e97f689f745aa3407db71986ebc21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef18fcad8f22f530bf8549f3f00a763/" rel="bookmark">
			使用gdal ogr创建shapefile文件（c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ogr库创建点状要素的shapefile文件以及将经纬度坐标转为投影坐标。实例如下：
#include "ogrsf_frmts.h" #include "gdal.h" #include "gdal_priv.h" #include "cpl_string.h" #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;strstream&gt; using namespace std; void convertToShp(double longitude, double latitude, char *outshp) { //使属性表字段支持中文 CPLSetConfigOption("SHAPE_ENCODING",""); OGRRegisterAll();//注册所有的驱动 //创建ESRI shp文件 char *pszDriverName = "ESRI Shapefile"; //调用对Shape文件读写的Driver OGRSFDriver *poDriver = OGRSFDriverRegistrar::GetRegistrar()-&gt;GetDriverByName(pszDriverName); if (poDriver == NULL) { cout&lt;&lt;pszDriverName&lt;&lt;"驱动不可用！"&lt;&lt;endl; return; } //创建数据源 OGRDataSource *poDs = poDriver-&gt;CreateDataSource(outshp, NULL); if (poDs == NULL) { cout&lt;&lt;"DataSource Creation Error"&lt;&lt;endl; return; } //创建图层Layer string outShapName = outshp; string layerName = outShapName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fef18fcad8f22f530bf8549f3f00a763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b51d2edda6850772222956a81e49a3d2/" rel="bookmark">
			JavaMail邮件传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QQ邮箱服务器
网易邮箱服务器
一、发送一封只包含文本的简单邮件
import java.util.Properties; import javax.mail.Message; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; public class Sendmail { public static void main(String[] args) throws Exception { Properties prop = new Properties(); prop.setProperty("mail.smtp.host", "smtp.163.com"); prop.setProperty("mail.transport.protocol", "smtp"); prop.setProperty("mail.smtp.auth", "true"); // 使用JavaMail发送邮件的5个步骤 // 1、创建session Session session = Session.getInstance(prop); // 开启Session的debug模式，这样就可以查看到程序发送Email的运行状态 session.setDebug(true); // 2、通过session得到transport对象 Transport ts = session.getTransport(); // 3、使用邮箱的用户名和密码连上邮件服务器，发送邮件时，发件人需要提交邮箱的用户名和密码给 // smtp服务器，用户名和密码都通过验证之后才能够正常发送邮件给收件人。 ts.connect("smtp.163.com", "18883283****@163.com", "****avfnmrjptvpz"); // 4、创建邮件 Message message = createSimpleMail(session); // 5、发送邮件 ts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b51d2edda6850772222956a81e49a3d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4b857385120f5dc3169f144915fc46/" rel="bookmark">
			Caffe学习系列(17)：模型各层特征和过滤器可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：
Caffe学习系列(17)：模型各层特征和过滤器可视化 - denny402 - 博客园
http://www.cnblogs.com/denny402/p/5105911.html
cifar10的各层数据和参数可视化
先用caffe对cifar10进行训练，将训练的结果模型进行保存，得到一个caffemodel，然后从测试图片中选出一张进行测试，并进行可视化。
In [1]: #加载必要的库 import numpy as np import matplotlib.pyplot as plt %matplotlib inline import sys,os,caffe In [2]: #设置当前目录，判断模型是否训练好 caffe_root = '/home/bnu/caffe/' sys.path.insert(0, caffe_root + 'python') os.chdir(caffe_root) if not os.path.isfile(caffe_root + 'examples/cifar10/cifar10_quick_iter_4000.caffemodel'): print("caffemodel is not exist...") In [3]: #利用提前训练好的模型，设置测试网络 caffe.set_mode_gpu() net = caffe.Net(caffe_root + 'examples/cifar10/cifar10_quick.prototxt', caffe_root + 'examples/cifar10/cifar10_quick_iter_4000.caffemodel', caffe.TEST) In [4]: net.blobs['data'].data.shape Out[4]: (1, 3, 32, 32) In [5]: #加载测试图片，并显示 im = caffe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4b857385120f5dc3169f144915fc46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/155bfb385c6860474bc7876e49ce13b4/" rel="bookmark">
			Spark读取数据库(Mysql)的四种方式讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前Spark支持四种方式从数据库中读取数据，这里以Mysql为例进行介绍。
一、不指定查询条件 这个方式链接MySql的函数原型是：
def jdbc(url: String, table: String, properties: Properties): DataFrame 我们只需要提供Driver的url，需要查询的表名，以及连接表相关属性properties。下面是具体例子：
val url = "jdbc:mysql://www.iteblog.com:3306/iteblog?user=iteblog&amp;password=iteblog" val prop = new Properties() val df = sqlContext.read.jdbc(url, "iteblog", prop ) println(df.count()) println(df.rdd.partitions.size) 我们运行上面的程序，可以看到df.rdd.partitions.size输出结果是1，这个结果的含义是iteblog表的所有数据都是由RDD的一个分区处理的，所以说，如果你这个表很大，很可能会出现OOM
WARN TaskSetManager: Lost task 0.0 in stage 1.0 (TID 14, spark047219): java.lang.OutOfMemoryError: GC overhead limit exceeded at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3380) 这种方式在数据量大的时候不建议使用。
二、指定数据库字段的范围 这种方式就是通过指定数据库中某个字段的范围，但是遗憾的是，这个字段必须是数字，来看看这个函数的函数原型：
def jdbc( url: String, table: String, columnName: String, lowerBound: Long, upperBound: Long, numPartitions: Int, connectionProperties: Properties): DataFrame 前两个字段的含义和方法一类似。columnName就是需要分区的字段，这个字段在数据库中的类型必须是数字；lowerBound就是分区的下界；upperBound就是分区的上界；numPartitions是分区的个数。同样，我们也来看看如何使用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/155bfb385c6860474bc7876e49ce13b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd7269cadc745fda61486afb4b14883/" rel="bookmark">
			bitnami 版 gitlab 修改端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转自：http://blog.csdn.net/zxgis/article/details/44096901
感谢原作者！！
一般安装包路径在： /opt/gitlab-version/
应该修改一下路径的文件 /opt/gitlab/apache2/conf/httpd.conf Listen 80 /opt/gitlab/apache2/conf/bitnami/bitnami.conf virtual hostdefault:80 /opt/gitlab/apps/gitlab/gitlab-shell/config.yml /opt/gitlab/apps/gitlab/htdocs/config/gitlab.yml 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44644283643e429ac4a03bea311c6cd/" rel="bookmark">
			JAVA调用windows下dll文件程序代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA调用windows下dll文件程序代码 java是一个很强大的程序了，它可以做很多操作，下面我来介绍在java中调用windows系统的dll文件的程序代码，各位朋友可参考参考。 JNA(Java Native Access)：建立在JNI之上的Java开源框架，SUN主导开发，用来调用C、C++代码，尤其是底层库文件（windows中叫dll文件，linux下是so【shared object】文件）。
JNI是Java调用原生函数的唯一机制，JNA就是建立在JNI之上，JNA简化了Java调用原生函数的过程。JNA提供了一个动态的C语言编写的转发器（实际上也是一个动态链接库，在Linux-i386中文件名是：libjnidispatch.so）可以自动实现Java与C之间的数据类型映射。从性能上会比JNI技术调用动态链接库要低。
1.简单写个windows下的dll,文件命名为forjava.dll,其中一个add函数,采用stdcall调用约定
java是一个很强大的程序了，它可以做很多操作，下面我来介绍在java中调用windows系统的dll文件的程序代码，各位朋友可参考参考。 JNA(Java Native Access)：建立在JNI之上的Java开源框架，SUN主导开发，用来调用C、C++代码，尤其是底层库文件（windows中叫dll文件，linux下是so【shared object】文件）。
JNI是Java调用原生函数的唯一机制，JNA就是建立在JNI之上，JNA简化了Java调用原生函数的过程。JNA提供了一个动态的C语言编写的转发器（实际上也是一个动态链接库，在Linux-i386中文件名是：libjnidispatch.so）可以自动实现Java与C之间的数据类型映射。从性能上会比JNI技术调用动态链接库要低。
1.简单写个windows下的dll,文件命名为forjava.dll,其中一个add函数,采用stdcall调用约定
main.h文件
#ifndef __MAIN_H__ #define __MAIN_H__ #include &lt;windows.h&gt; /* To use this exported function of dll, include this header * in your project. */
#ifdef BUILD_DLL #define DLL_EXPORT __declspec(dllexport) __stdcall #else #define DLL_EXPORT __declspec(dllimport) __stdcall #endif #ifdef __cplusplus extern "C"
{ #endif int DLL_EXPORT add(int a,int b); #ifdef __cplusplus } #endif #endif // __MAIN_H__
main.cpp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f44644283643e429ac4a03bea311c6cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f12ac57c287584407cf17f8c7dffc37/" rel="bookmark">
			Spark Shuffle模块——Suffle Read过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在阅读本文之前，请先阅读Spark Sort Based Shuffle内存分析
Spark Shuffle Read调用栈如下： 1. org.apache.spark.rdd.ShuffledRDD#compute() 2. org.apache.spark.shuffle.ShuffleManager#getReader() 3. org.apache.spark.shuffle.hash.HashShuffleReader#read() 4. org.apache.spark.storage.ShuffleBlockFetcherIterator#initialize() 5. org.apache.spark.storage.ShuffleBlockFetcherIterator#splitLocalRemoteBlocks() org.apache.spark.storage.ShuffleBlockFetcherIterator#sendRequest() org.apache.spark.storage.ShuffleBlockFetcherIterator#fetchLocalBlocks()
下面是fetchLocalBlocks()方法执行时涉及到的类和对应方法： 6. org.apache.spark.storage.BlockManager#getBlockData() org.apache.spark.shuffle.hash.ShuffleManager#shuffleBlockResolver() ShuffleManager有两个子类，如果是HashShuffle 则对应的是org.apache.spark.shuffle.hash.HashShuffleManager#shuffleBlockResolver()方法，该方法返回的是org.apache.spark.shuffle.FileShuffleBlockResolver，再调用FileShuffleBlockResolver#getBlockData()方法返回Block数据 ；如果是Sort Shuffle，则对应的是 org.apache.spark.shuffle.hash.SortShuffleManager#shuffleBlockResolver()，该方法返回的是org.apache.spark.shuffle.IndexShuffleBlockResolver，然后再调用IndexShuffleBlockResolver#getBlockData()返回Block数据。
下面是org.apache.spark.storage.ShuffleBlockFetcherIterator#sendRequest()方法执行时涉及到的类和对应方法 7. org.apache.spark.network.shuffle.ShuffleClient#fetchBlocks org.apache.spark.network.shuffle.ShuffleClient有两个子类，分别是ExternalShuffleClient及BlockTransferService ，其中org.apache.spark.network.shuffle.BlockTransferService又有两个子类，分别是NettyBlockTransferService和NioBlockTransferService，对应两种不同远程获取Block数据方式，Spark 1.5.2中已经将NioBlockTransferService方式设置为deprecated，在后续版本中将被移除
下面按上述调用栈对各方法进行说明，这里只讲脉络，细节后面再讨论
ShuffledRDD#compute()代码 Task执行时，调用ShuffledRDD的compute方法，其代码如下：
//org.apache.spark.rdd.ShuffledRDD#compute() override def compute(split: Partition, context: TaskContext): Iterator[(K, C)] = { val dep = dependencies.head.asInstanceOf[ShuffleDependency[K, V, C]] //通过org.apache.spark.shuffle.ShuffleManager#getReader()方法 //无论是Sort Shuffle 还是 Hash Shuffle，使用的都是 //org.apache.spark.shuffle.hash.HashShuffleReader SparkEnv.get.shuffleManager.getReader(dep.shuffleHandle, split.index, split.index + 1, context) .read() .asInstanceOf[Iterator[(K, C)]] } 可以看到，其核心逻辑是通过调用ShuffleManager#getReader()方法得到HashShuffleReader对象，然后调用HashShuffleReader#read()方法完成前一Stage中ShuffleMapTask生成的Shuffle 数据的读取。需要说明的是，无论是Hash Shuffle还是Sort Shuffle，使用的都是HashShuffleReader。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f12ac57c287584407cf17f8c7dffc37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf1aceabcce277c0cda4caa367bd3e0/" rel="bookmark">
			POI：数据批量导出、按模板导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Action或者Servlet中
Workbook wb=new HSSFWorkbook();
String headers[]={"编号","姓名","电话","Email","QQ"}; ResultSet rs=userDao.userList(con, null); ExcelUtil.fillExcelData(rs, wb, headers);
ResponseUtil.export(ServletActionContext.getResponse(), wb, "导出excel.xls");
public static void fillExcelData(ResultSet rs,Workbook wb,String[] headers)throws Exception{
int rowIndex=0;
Sheet sheet=wb.createSheet();
Row row=sheet.createRow(rowIndex++);
for(int i=0;i&lt;headers.length;i++){
row.createCell(i).setCellValue(headers[i]);
}
while(rs.next()){
row=sheet.createRow(rowIndex++);
for(int i=0;i&lt;headers.length;i++){
row.createCell(i).setCellValue(rs.getObject(i+1).toString());
}
}
}
public static void export(HttpServletResponse response,Workbook wb,String fileName)throws Exception{
response.setHeader("Content-Disposition", "attachment;filename="+new String(fileName.getBytes("utf-8"),"iso8859-1"));
response.setContentType("application/ynd.ms-excel;charset=UTF-8");
OutputStream out=response.getOutputStream();
wb.write(out);//这是利用Response，可以利用Action的下载功能，就需要转换输出流到输入流
out.flush();
out.close();
}
利用模板导出
Workbook wb=ExcelUtil.fillExcelDataWithTemplate(userDao.userList(con, null), "userExporTemplate.xls");
ResponseUtil.export(ServletActionContext.getResponse(), wb, "利用模版导出excel.xls");
public static Workbook fillExcelDataWithTemplate(ResultSet rs,String templateFileName)throws Exception{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf1aceabcce277c0cda4caa367bd3e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982b878ee2b3bb187ec9e300a706ce20/" rel="bookmark">
			HDU 4347 The Closest M Points
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Closest M Points Time Limit: 8000MS Memory Limit: 98304KB 64bit IO Format: %I64d &amp; %I64u
Submit Status
Description The course of Software Design and Development Practice is objectionable. ZLC is facing a serious problem .There are many points in K-dimensional space .Given a point. ZLC need to find out the closest m points. Euclidean distance is used as the distance metric between two points. The Euclidean distance between points p and q is the length of the line segment connecting them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/982b878ee2b3bb187ec9e300a706ce20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefde60b3929cbc102520f1488cc4663/" rel="bookmark">
			最近邻搜索之乘积量化（Product Quantizer）理解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Product Quantizer是由Herv´e J´egou等人2011年在IEEEE上发表的论文《Product Quantization for Nearest Neighbor Search》中提出来的。它的提出是为了在内存和效率之间求得一个平衡，既保证图像索引结构需要的内存足够，又使得检索质量和速度比较好。对于任何基于固定维数特征的事物，它可以应用到其索引结构的建立及检索上。它属于ANN(approximate nearest neighbor)算法。与它相关的算法有E2LSH（Euclidean Locality-Sensitive Hashing）， KD-trees，K-means。
主要思想 Product Quantizer翻译过来是乘积量化，从字面理解大概包括了两个过程特征的分组量化过程和类别的笛卡尔积过程。假设有一个数据集，那么K-means的做法就是给定类别数目K，目标函数是所有样本到类中心的距离和最小，迭代计算优化目标函数，得到K个类中心和每个样本所属的类别。目标函数不变，乘积量化的做法是： （1）数据集为K个类别，每个样本以一个vector的形式表示，维数为d，将vector的各个分量分成m组。 （2）将所有vector的某组分量作为数据集，采用k-means算法得到个类中心，运行m次k-means算法，则每组都有个类中心，记这个类中心为一个集合。 （3）将上述得到的m个集合做笛卡尔积，就得到整个数据集的类中心了。
下图辅助理解。 其实只要联系欧式空间中点的笛卡尔积就很好理解了。
举个栗子 注：例子中示意图引用自Jae-Pil Heo的论文《Distance Encoded Product Quantization》 （转载请注明作者和出处：http://blog.csdn.net/CHIERYU 未经允许请勿用于商业用途）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ccf5aa6fcccb13a3c8249cf0d57716/" rel="bookmark">
			NIPS 2015 Deep Learning Symposium
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天小S 决定咬着牙写写 NIPS 2015 的论文总结。NIPS 文章理论较多，耗时耗力，如果有总结不周的地方，大家多多包涵，多多指正。因为 NIPS 文章也很多，我将会按照官方的 topic 分类。今天先分享 Deep Learning Symposium 中一些 references。依然很多，今天是第一部分，周五争取分享剩下的。
今天包括的：
《Character-aware Neural Language Models》. Yoon Kim, Yacine Jernite, David Sontag, Alexander M. Rush.
《Character-level Convolutional Networks for Text Classification》. Xiang Zhang, Junbo Zhao, Yann LeCun.
《A Neural Algorithm Of Artistic Style》. Leon A. Gatys, Alexander S. Ecker, Matthias Bethge.
《Listen, attend and spell》. William Chan, Navdeep Jaitly, Quoc V. Le, Oriol Vinyals.
《Skip-thought vectors》.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ccf5aa6fcccb13a3c8249cf0d57716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc7eecbb6bc9a185d990f623ffe240b/" rel="bookmark">
			人工神经网络简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要对人工神经网络基础进行了描述，主要包括人工神经网络的概念、发展、特点、结构、模型。
本文是个科普文，来自网络资料的整理。
一、人工神经网络的概念
人工神经网络（Artificial Neural Network，ANN）简称神经网络(NN)，是基于生物学中神经网络的基本原理，在理解和抽象了人脑结构和外界刺激响应机制后，以网络拓扑知识为理论基础，模拟人脑的神经系统对复杂信息的处理机制的一种数学模型。该模型以并行分布的处理能力、高容错性、智能化和自学习等能力为特征，将信息的加工和存储结合在一起，以其独特的知识表示方式和智能化的自适应学习能力，引起各学科领域的关注。它实际上是一个有大量简单元件相互连接而成的复杂网络，具有高度的非线性，能够进行复杂的逻辑操作和非线性关系实现的系统。
神经网络是一种运算模型，由大量的节点（或称神经元）之间相互联接构成。每个节点代表一种特定的输出函数，称为激活函数（activation function）。每两个节点间的连接都代表一个对于通过该连接信号的加权值，称之为权重（weight），神经网络就是通过这种方式来模拟人类的记忆。网络的输出则取决于网络的结构、网络的连接方式、权重和激活函数。而网络自身通常都是对自然界某种算法或者函数的逼近，也可能是对一种逻辑策略的表达。神经网络的构筑理念是受到生物的神经网络运作启发而产生的。人工神经网络则是把对生物神经网络的认识与数学统计模型相结合，借助数学统计工具来实现。另一方面在人工智能学的人工感知领域，我们通过数学统计学的方法，使神经网络能够具备类似于人的决定能力和简单的判断能力，这种方法是对传统逻辑学演算的进一步延伸。
人工神经网络中，神经元处理单元可表示不同的对象，例如特征、字母、概念，或者一些有意义的抽象模式。网络中处理单元的类型分为三类：输入单元、输出单元和隐单元。输入单元接受外部世界的信号与数据；输出单元实现系统处理结果的输出；隐单元是处在输入和输出单元之间，不能由系统外部观察的单元。神经元间的连接权值反映了单元间的连接强度，信息的表示和处理体现在网络处理单元的连接关系中。人工神经网络是一种非程序化、适应性、大脑风格的信息处理，其本质是通过网络的变换和动力学行为得到一种并行分布式的信息处理功能，并在不同程度和层次上模仿人脑神经系统的信息处理功能。
神经网络，是一种应用类似于大脑神经突触连接结构进行信息处理的数学模型，它是在人类对自身大脑组织结合和思维机制的认识理解基础之上模拟出来的，它是根植于神经科学、数学、思维科学、人工智能、统计学、物理学、计算机科学以及工程科学的一门技术。
二、人工神经网络的发展
神经网络的发展有悠久的历史。其发展过程大致可以概括为如下4个阶段。
1. 第一阶段----启蒙时期
(1). M-P神经网络模型：20世纪40年代，人们就开始了对神经网络的研究。1943 年，美国心理学家麦克洛奇（Mcculloch）和数学家皮兹（Pitts）提出了M-P模型，此模型比较简单，但是意义重大。在模型中，通过把神经元看作个功能逻辑器件来实现算法，从此开创了神经网络模型的理论研究。
(2). Hebb规则：1949 年，心理学家赫布（Hebb）出版了《The Organization of Behavior》（行为组织学），他在书中提出了突触连接强度可变的假设。这个假设认为学习过程最终发生在神经元之间的突触部位，突触的连接强度随之突触前后神经元的活动而变化。这一假设发展成为后来神经网络中非常著名的Hebb规则。这一法则告诉人们，神经元之间突触的联系强度是可变的，这种可变性是学习和记忆的基础。Hebb法则为构造有学习功能的神经网络模型奠定了基础。
(3). 感知器模型：1957 年，罗森勃拉特（Rosenblatt）以M-P 模型为基础，提出了感知器（Perceptron）模型。感知器模型具有现代神经网络的基本原则，并且它的结构非常符合神经生理学。这是一个具有连续可调权值矢量的MP神经网络模型，经过训练可以达到对一定的输入矢量模式进行分类和识别的目的，它虽然比较简单，却是第一个真正意义上的神经网络。Rosenblatt 证明了两层感知器能够对输入进行分类，他还提出了带隐层处理元件的三层感知器这一重要的研究方向。Rosenblatt 的神经网络模型包含了一些现代神经计算机的基本原理，从而形成神经网络方法和技术的重大突破。
(4). ADALINE网络模型： 1959年，美国著名工程师威德罗（B.Widrow）和霍夫（M.Hoff）等人提出了自适应线性元件(Adaptive linear element，简称Adaline)和Widrow-Hoff学习规则（又称最小均方差算法或称δ规则）的神经网络训练方法，并将其应用于实际工程，成为第一个用于解决实际问题的人工神经网络，促进了神经网络的研究应用和发展。ADALINE网络模型是一种连续取值的自适应线性神经元网络模型，可以用于自适应系统。
2. 第二阶段----低潮时期
人工智能的创始人之一Minsky和Papert对以感知器为代表的网络系统的功能及局限性从数学上做了深入研究，于1969年发表了轰动一时《Perceptrons》一书，指出简单的线性感知器的功能是有限的，它无法解决线性不可分的两类样本的分类问题，如简单的线性感知器不可能实现“异或”的逻辑关系等。这一论断给当时人工神经元网络的研究带来沉重的打击。开始了神经网络发展史上长达10年的低潮期。
(1). 自组织神经网络SOM模型：1972年，芬兰的KohonenT.教授，提出了自组织神经网络SOM(Self-Organizing feature map)。后来的神经网络主要是根据KohonenT.的工作来实现的。SOM网络是一类无导师学习网络，主要用于模式识别﹑语音识别及分类问题。它采用一种“胜者为王”的竞争学习算法，与先前提出的感知器有很大的不同，同时它的学习训练方式是无指导训练，是一种自组织网络。这种学习训练方式往往是在不知道有哪些分类类型存在时，用作提取分类信息的一种训练。
(2). 自适应共振理论ART：1976年，美国Grossberg教授提出了著名的自适应共振理论ART(Adaptive Resonance Theory)，其学习过程具有自组织和自稳定的特征。
3. 第三阶段----复兴时期
(1). Hopfield模型：1982年，美国物理学家霍普菲尔德（Hopfield）提出了一种离散神经网络，即离散Hopfield网络，从而有力地推动了神经网络的研究。在网络中，它首次将李雅普诺夫（Lyapunov）函数引入其中，后来的研究学者也将Lyapunov函数称为能量函数。证明了网络的稳定性。1984年，Hopfield 又提出了一种连续神经网络，将网络中神经元的激活函数由离散型改为连续型。1985 年，Hopfield和Tank利用Hopfield神经网络解决了著名的旅行推销商问题（Travelling Salesman Problem）。Hopfield神经网络是一组非线性微分方程。Hopfield的模型不仅对人工神经网络信息存储和提取功能进行了非线性数学概括，提出了动力方程和学习方程，还对网络算法提供了重要公式和参数，使人工神经网络的构造和学习有了理论指导，在Hopfield模型的影响下，大量学者又激发起研究神经网络的热情，积极投身于这一学术领域中。因为Hopfield 神经网络在众多方面具有巨大潜力，所以人们对神经网络的研究十分地重视，更多的人开始了研究神经网络，极大地推动了神经网络的发展。
(2). Boltzmann机模型：1983年，Kirkpatrick等人认识到模拟退火算法可用于NP完全组合优化问题的求解，这种模拟高温物体退火过程来找寻全局最优解的方法最早由Metropli等人1953年提出的。1984年，Hinton与年轻学者Sejnowski等合作提出了大规模并行网络学习机，并明确提出隐单元的概念，这种学习机后来被称为Boltzmann机。
Hinton和Sejnowsky利用统计物理学的感念和方法，首次提出的多层网络的学习算法，称为Boltzmann 机模型。
(3). BP神经网络模型：1986年，儒默哈特（D.E.Ru melhart）等人在多层神经网络模型的基础上，提出了多层神经网络权值修正的反向传播学习算法----BP算法（Error Back-Propagation），解决了多层前向神经网络的学习问题，证明了多层神经网络具有很强的学习能力，它可以完成许多学习任务，解决许多实际问题。
(4). 并行分布处理理论：1986年，由Rumelhart和McCkekkand主编的《Parallel Distributed Processing：Exploration in the Microstructures of Cognition》，该书中，他们建立了并行分布处理理论，主要致力于认知的微观研究，同时对具有非线性连续转移函数的多层前馈网络的误差反向传播算法即BP算法进行了详尽的分析，解决了长期以来没有权值调整有效算法的难题。可以求解感知机所不能解决的问题，回答了《Perceptrons》一书中关于神经网络局限性的问题，从实践上证实了人工神经网络有很强的运算能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfc7eecbb6bc9a185d990f623ffe240b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ca12fc6bbf5c6433fff1bbd138591f/" rel="bookmark">
			std::function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 • cplusplus.com：http://www.cplusplus.com/reference/functional/function/
• cppreference.com：http://en.cppreference.com/w/cpp/utility/functional/function
std::function简介 • 类模板声明 // MS C++ 2013 template&lt;class _Fty&gt; class function; template&lt;class _Fty&gt; class function : public _Get_function_impl&lt;_Fty&gt;::type { ... } // GCC 4.8.2 template&lt;typename _Signature&gt; class function; template&lt;typename _Res, typename... _ArgTypes&gt; class function&lt;_Res(_ArgTypes...)&gt; : public _Maybe_unary_or_binary_function&lt;_Res, _ArgTypes...&gt;, private _Function_base { ... }
// cplusplus.com
template &lt;class T&gt; function; // undefined template &lt;class Ret, class... Args&gt; class function&lt;Ret(Args...)&gt;; • 类模板说明 std::function是一个函数包装器模板，最早来自boost库，对应其boost::function函数包装器。在c++0x11中，将boost::function纳入标准库中。该函数包装器模板能包装任何类型的可调用元素（callable element），例如普通函数和函数对象。包装器对象可以进行拷贝，并且包装器类型仅仅只依赖于其调用特征（call signature），而不依赖于可调用元素自身的类型。
一个std::function类型对象实例可以包装下列这几种可调用元素类型：函数、函数指针、类成员函数指针或任意类型的函数对象（例如定义了operator()操作并拥有函数闭包）。std::function对象可被拷贝和转移，并且可以使用指定的调用特征来直接调用目标元素。当std::function对象未包裹任何实际的可调用元素，调用该std::function对象将抛出std::bad_function_call异常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ca12fc6bbf5c6433fff1bbd138591f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e5792b64f1d5cdfbcc5300a1a69ce2/" rel="bookmark">
			gitlab傻瓜式安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装ssh server
sudo apt-get install ssh 2.启动ssh server
sudo service ssh start 3.下载gitlab傻瓜式安装包，由bitnami提供
下载地址：https://bitnami.com/stack/gitlab/installer
4.管理员权限双击就行了，点击NEXT
这是安装路径，一般默认就行了
创建管理员账号
设置域名或IP地址，这里默认是127.0.1.1
配置服务器邮箱，主要是给用户提供忘记密码发信，通知等。这里简单起见就不配了。
之后一直NEXT至开始安装，完成后就会启动控制面板。
默认的端口是80，若要修改端口在Apache的configure中修改
修改成你想设定的端口就行了。
之后访问git服务器的IP地址，就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd3fd2b3aaab9fd996430c3b55614bb/" rel="bookmark">
			pandas行转列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 原始文件 Year Country medal no of medals 1896 Afghanistan Gold 5 1896 Afghanistan Silver 4 1896 Afghanistan Bronze 3 1896 Algeria Gold 1 1896 Algeria Silver 2 1896 Algeria Bronze 3 目标 Year Country Gold Silver Bronze 1896 Afghanistan 5 4 3 1896 Algeria 1 2 3 方法 保存为’/home/yanghao3/pandas.csv’脚本 df = pd.read_csv('/home/yanghao3/pandas.csv') medals = df.pivot_table('no', ['Year', 'Country'], 'medal') medals.reset_index(level=0,inplace=True) medals.reset_index(level=0,inplace=True) #改变列的顺序 medals = medals.reindex_axis(['Year', 'Country', 'Gold', 'Silver', 'Bronze'], axis = 1) medals.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbd3fd2b3aaab9fd996430c3b55614bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a616eb731c274f10032b4c9e6ed21d4b/" rel="bookmark">
			C&#43;&#43;-day07-指向对象的指针－student.cpp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt;
/**
*指向对象的指针
*/
using namespace std;
class Student{
private:
string name;
int age;
public:
//因为有了析构函数，所以我们在写共有函数的时候尽量把无参数构造加上
Student()
{
cout&lt;&lt;"构造被调用了"&lt;&lt;endl;
}//构造最好加上
~Student()
{
cout&lt;&lt;"析构被调用了"&lt;&lt;endl;
}
Student(string n,int a)
{
name=n;
age=a;
}
string setName(string n)
{
name=n;
}
int setAge(int a)
{
age=a;
}
void print()
{
cout&lt;&lt;"My Name: "&lt;&lt;name&lt;&lt;endl;
cout&lt;&lt;"My Age:"&lt;&lt;age&lt;&lt;endl;
cout&lt;&lt;"*****************"&lt;&lt;endl;
Student *pc=new Student("yang2",18);//开辟内存
(*pc).print();
//*p-&gt;print();
delete(pc);//清空内存
}
};
int main()
{	Student S("yangyang",22);
//	S.setName("yangyang");
//	S.setAge(22);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a616eb731c274f10032b4c9e6ed21d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51670941066108a0f362dcd473d0c6f/" rel="bookmark">
			Linux下MySQL的数据文件存放在哪里的？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://bbs.csdn.net/topics/390620630
mysql&gt; show variables like '%dir%'; +-----------------------------------------+----------------------------+ | Variable_name | Value | +-----------------------------------------+----------------------------+ | basedir | /usr | | binlog_direct_non_transactional_updates | OFF | | character_sets_dir | /usr/share/mysql/charsets/ | | datadir | /var/lib/mysql/ | | ignore_db_dirs | | | innodb_data_home_dir | | | innodb_log_group_home_dir | ./ | | innodb_max_dirty_pages_pct | 75 | | innodb_max_dirty_pages_pct_lwm | 0 | | innodb_undo_directory | . | | lc_messages_dir | /usr/share/mysql/ | | plugin_dir | /usr/lib/mysql/plugin/ | | slave_load_tmpdir | /tmp | | tmpdir | /tmp | +-----------------------------------------+----------------------------+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f51670941066108a0f362dcd473d0c6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178bb4cd9cde2d519772ce887079ddfd/" rel="bookmark">
			Android之android.intent.category.LAUNCHER的用途和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android之android.intent.category.LAUNCHER的用途和使用
有时候我们只是在eclipse新建一个android工程，然后 run下,然后在手机上就有一个带logo的apk；然而我们很少考虑没有图标的apk，下面要说的就是android.intent.category.LAUNCHER。 1：我们先看带android.intent.category.LAUNCHER 的工程运行后的效果 1.1：工程名如下 1.2：manifest.xml如下：（注意其中含有android.intent.category.LAUNCHER） 1.3：运行效果后，可以看到手机截屏（可以看到有个launcher（cp3）） 2：我们看不带android.intent.category.LAUNCHER 的工程运行后的效果 2.1：工程名如下 2.2：manifest.xml如下：（注意其中没有android.intent.category.LAUNCHER） 2.3：运行后，可以看到屏幕上没有任何效果 2.4控制台显示如下： 可以看到确实已经安装了。 2.5：这时候我们进入目录下验证一下： 可以看到这里面含有com.tcl.cp3-2.apk 。
1和2 对比可以发现 android.intent.category.LAUNCHER的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7522f7e5483a43b03045b199c129d1/" rel="bookmark">
			C语言中对结构体赋初值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C 语言中结构体的赋初值，可以对指定元素赋值，不必按照顺序，前提是通过 "." 来操作，在 c-free 5.0版本下验证通过。 &lt;pre name="code" class="cpp"&gt; #include &lt;stdio.h&gt; typedef struct{ int a; char b; float c; }structTest1; int main(int argc, char *argv[]) { structTest1 st1 = { .b = 'A',//赋值的时候，可以用 "." 对指定元素赋值，不必按照原来的顺序 .c = 10.1, .a = 100	}; printf("a=%d\r\nb=%c\r\nc=%f\r\n",st1.a,st1.b,st1.c); return 0; } 执行的结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c8f6318367ed8aef5bc6918a730a4c/" rel="bookmark">
			C&#43;&#43;调用python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/pipisorry/article/details/49532341
C++调用python 在C/C++中嵌入Python，可以使用Python提供的强大功能，通过嵌入Python可以替代动态链接库形式的接口，这样可以方便地根据需要修改脚本代码，而不用重新编译链接二进制的动态链接库。至少你可以把它当成文本形式的动态链接库，需要的时候还可以改一改，只要不改变接口， C++的程序一旦编译好了，再改就没那么方便了。
C++调用Python有两种方式 第一种方式：通过找到Python模块，类，方法，构造参数来调用。
第二中方式，就是通过构造出一个Python的脚本，用python引擎来执行。
第一种方式可能更为优雅，符合大多数的反射调用的特点。（如c#的反射机制，c#调用Com+，c#调用javascript脚本等）。
一个问题：两种语言互相调用的时候，需要做数据结构（如基本类型，字符串，整数类型等，以及自定义的类等类型）间的转换，共享内存中的一个对象。比如，如何将C++的对象实例传入python中，并在python中使用。c++和python并不在一个进程中，因此可以使用boost的shared_ptr来实现。Python调用C++，换句话说就是需要把C++封装成Python可以“理解”的类型。同理可知C++怎么去调用Python脚本。
下面这个例子，主要是演示了c++调用python，可以在c++中形成一个python脚本，然后利用PyRun_SimpleString调用;并且，构造一个c++的对象，传入到python中，并在python的脚本中调用其函数。
皮皮blog
VS中编译运行 vs安装配置 安装python3.4，然后配置系统环境变量。
安装Visual Studio2010（注意可以不用安装其它好多东西，只要安装c++就可以了）。[Visual Studio相关设置]
vs中新建一个win32控制台应用程序，一路确定完成。
VS2010的配置(设置编译环境) 1. c++调用python需要在vs2010中的cpp文件中加入&lt;Python.h&gt;，这个头文件在python安装目录Python\include下
要成功引入就要把Python.h的头文件目录（如D:\python3.4.2\include放在菜单 &gt; 项目 &gt; 属性 &gt; C/C++ &gt; 常规 &gt; 附加包含目录下（或者右键项目）
2. 还需要一个python34.lib，如果不导入的话，会提示你出现这个文件的缺失。文件在python\libs下，找到此文件之后进入VS2010，菜单 &gt;项目 &gt; 属性 &gt; 配置属性 &gt; VC++目录 &gt; 库目录，把刚才的绝对路径（如D:\python3.4.2\libs）添加进去，此时变成这样的了：D:\python3.4.2\libs;$(VCInstallDir)lib;$(VCInstallDir)atlmfc\lib;$(WindowsSdkDir)lib;$(FrameworkSDKDir)\lib。这样就可以在VC程序中执行python文件了。
或者把D:\python3.4.2\libs放进项目 &gt; 属性 &gt; 配置属性 &gt; 链接器 &gt; 常规 &gt; 附加库目录中。
Note: 上面的设置是对某个模式生效，如果将运行模式从debug改成了release，要再进去设置，否则设置不成功。
程序编辑 编辑c++代码
将PythonInvoke.cpp文件改成下面的代码，用于调用python程序helloworld
// PythonInvoke.cpp : 定义控制台应用程序的入口点。
#include "stdafx.h"
#include&lt;Python.h&gt;
void main(){
Py_Initialize(); /*初始化python解释器,告诉编译器要用的python编译器*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c8f6318367ed8aef5bc6918a730a4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc241de173a5b88747ceec8ff2e6571/" rel="bookmark">
			Windows命令行查看文件的MD5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很实用的命令, Mark一下
certutil -hashfile D:\1.exe MD5
certutil -hashfile D:\1.exe SHA1
certutil -hashfile D:\1.exe SHA256
原文地址：https://www.exchen.net/windows%e5%91%bd%e4%bb%a4%e8%a1%8c%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e7%9a%84md5.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d783504c6a641e5d1e396971130f22de/" rel="bookmark">
			S3c2440如何利用JLINK烧写U-boot到NAND Flash中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多同学使用笔记本作为自己的ARM开发和学习的平台，绝大多数笔记本都没有并口，也就是无法使用JTag调试和烧写程序到Nand Flash中，幸好我们还有JLINK，用JLINK烧写U-boot到Nor Flash中很简单，大部分NOR Flash都已经被JLink的软件SEGGER所支持，而新手在学习的时候经常会实验各种各样的命令，最悲剧的莫过于将NAND Flash中原有的bootloader给删除了，这时候开发板上电后由于没有bootloader，硬件没有被初始化，在NAND Flash中的操作系统也就无法被加载，开发板成“砖”了，这时候笔记本又无法利用JTag烧写程序进Nand Flash。起始这些可以利用JLink通过两种方法解决：
提示：Nor Flash是可以像内存SDRAM一样直接操作，但是NAND Flash必须操作nand的控制器。
一、方法一，利用NOR Flash。
这种方法是利用JLink能够烧写程序到NOR Flash来完成的，首先利用J-FLASH ARM将u-boot.bin烧写进NOR Flash（记得烧写到NOR Flash的0x0起始地址处），然后设置开发板从NOR Flash启动，这时候系统进入U-boot命令行模式，这时候打开J-Link commander，输入命令：r 看JLink是否能识别开发板的信息（也就是判断JLink是否连接正常）。/* 此时SDRAM已经初始化好了 */
以下是在J-Link commander里的命令，先假设u-boot.bin在你电脑的D盘根目录下。
执行命令方式如下：
h speed 12000 //设置TCK为12M，下载程序时会很快 loadbin d:\u-boot.bin 0x30000000 //注意：0x30000000是你想要下载u-boot.bin到开发板的内存地址，内存地址根据不同的开发板设定不同，因为本文中使用的是FL2440，片上系统是S3C2440，内存挂载的地址区域是0x30000000~0x33ffffff，我们只需要把u-boot.bin下载到这片区域即可， 然后我们在U-boot命令行模式输入NAND Flash擦除和写入命令即可：
nand erase 0 40000 //擦除从0地址开始的大小为0x40000的Nnad Flash扇区，0x40000是待写入的U-boot.bin的大致长度，长度必须为NAND Flash页大小的整数倍，通常会需要比u-boot.bin实际长度。
nand write 30000000 0 40000 // 把前面下载到0x30000000的u-boot.bin烧写到Nand的 0 ~40000 二、方法二，直接通过JLink
假如你的开发板没有NOR Flash或者是你使用的NOR Flash还未被J-FLASH ARM所支持，这时上面的方法你就无法使用了，这时候你需要一个初始化内存SDRAM的程序，这个程序完成的功能也就是配置好SDRAM的寄存器，使它能正常工作，fl2440的内存初始化程序下载地址：“2440init.bin”。你还需要准备一个特殊的u-boot_SDRAM.bin，它与你要烧写到NAND Flash的u-boot.bin有区别，u-boot_SDRAM.bin编译时需要在include/configs/fl2440.h文件中添加：
#define CONFIG_SKIP_LOWLEVEL_INIT 1 //用来支持uboot在内存中直接运行 跳过底层初始化 。添加这个宏定义之后，U-boot就跳过了内存初始化的部分，因为此时我们的内存已经先由“2440init.bin“初始化好了，再次初始化会出现内存数据的丢失。
做好上面的准备工作之后，首先将开发板设为从NAND Flash启动，启动J-Link commander，先假设“uboot.bin”和“2440init.bin”，"u-boot_SDRAM.bin"在电脑的D盘根目录下。
h speed 12000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d783504c6a641e5d1e396971130f22de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e069e311d39d2b214538e37f1020b27b/" rel="bookmark">
			php unexpected end of file错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; php.ini 设置为：short_open_tag = On 转载于:https://my.oschina.net/colin86/blog/521404
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7499ab1d599010ccfe6b3877dc0b53/" rel="bookmark">
			设置sort_buffer_size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sort_buffer_size mysql&gt; show variables like ‘%sort_buffer_size%’; +————————-+———+ | Variable_name | Value | +————————-+———+ | innodb_sort_buffer_size | 1048576 | | myisam_sort_buffer_size | 8388608 | | sort_buffer_size | 262144 | +————————-+———+ 3 rows in set (0.00 sec)
默认256K
每个session 需要做一个排序分配的一个buffer,sort_buffer_size 不指定任何的存储引擎,
适用于一般的方式进行优化
如果你看到很多的ort_merge_passes per second mysql&gt; SHOW GLOBAL STATUS like ‘%sort%’; +——————-+———-+ | Variable_name | Value | +——————-+———-+ | Sort_merge_passes | 1490 | | Sort_range | 1086174 | | Sort_rows | 23988490 | | Sort_scan | 213850 | +——————-+———-+ 4 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b7499ab1d599010ccfe6b3877dc0b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50db9838ea02313fc3d51ac0a2ae5d20/" rel="bookmark">
			Loadrunner 录制的脚本保存不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Loadrunner：11.0
浏览器：火狐
系统：win7（64位）
Loadrunner 录制的脚本保存不了:
现象：点击保存后，弹出的保存信息框闪退，并且百度打“保存”字样，浏览器也会闪退。
原因：是系统内存不够，关闭一些耗内存较大的程序，再保存即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/842a5159b012b5f5f2f8165f6e1e73c2/" rel="bookmark">
			禅道环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		禅道环境搭建 1. 下载： 禅道开源版下载地址
http://nchc.dl.sourceforge.net/project/zentao/7.3/ZenTaoPMS.7.3.stable.exe 2. 解压安装到根目录即可（建议不要放在C盘）； 3. 然后以管理员身份启动xampp文件下的.exe文件； 4. 然后访问禅道即可；（推荐火狐浏览器） 5. 浏览器打开后，选择开源版，进入登录界面； 6. 如果要局域网内共享，其他人可以访问：你的IP地址：端口号/zentao（192.168.1.XXX:81/zentao） 7. 使用之前要先阅读xampp文件下的readme.txt文档。里面有基础的设置。 8. 使用说明见禅道的官方文档： http://www.zentao.net/book/zentaopmshelp.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06a5d3a5c942c061b3627cab8010d912/" rel="bookmark">
			固态硬盘安装Win7双系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在固态硬盘里安装双系统。最初希望能从原来硬盘，克隆一份原XP系统，但没有成功。所以保留该系统而新建一个Win7 64X分区。
1.使用Win7控制面板--管理工具--计算机管理中的“磁盘管理”，从空闲较多的分区D中划分60G空间。右击D分区，选择压缩卷，设置60G容量即可。
2.参照《菜鸟win7双系统安装教程 两个系统都用Win7》使用GimageX工具在第一个Win7系统中安装第二个Win7系统。这里注意：install.wim在win7安装盘\sources\文件夹下。
3.安装后系统自动建立启动引导。如果对引导不满意，可以使用BOOTICE修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15e585ea42ba94f9ef74c5e9e2584f9/" rel="bookmark">
			遥感应用综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 原文地址：遥感应用综述 作者：ENVIIDL 在获取基础地理数据、地球资源信息和应急灾害的第一手资料方面，遥感比其它技术手段更有优势，同时越来越多的 GIS 系统依赖于遥感信息。 基础地理数据重要获取手段
遥感影像是地球表面的“相片”，真实地展现了地球表面物体的形状、大小、颜色等信息。这比传统的地图更容易被大众接受，影像地图已经成为重要的地图种类之一。 随着商业卫星影像的分辨率越来越高（最高已经到达 0.5 米），可以满足较大比例尺“ 4D ”产品生产要求。同时，卫星影像具有获取数据范围大和周期短的特点，卫星遥感已经成为基础地理数据采集与更新的重要手段。 卫星影像应用于部分4D产品生产
获取地球资源信息的最佳手段
遥感影像上具有丰富的信息，多光谱数据的波谱分辨率越来越高，可以获取红边波段、黄边波段等。高光谱传感器也发展迅速，我国的环境小卫星也搭载了高光谱传感器。从遥感影像上可以获取包括植被信息、土壤墒情、水质参数、地表温度、海水温度等丰富的信息。这些地球资源信息能在农业、林业、水利、海洋、生态环境等领域发挥重要作用。
从影像上获取的地球资源信息 为应急灾害提供第一手资料
遥感技术具有在不接触目标情况下获取信息的能力。在遭遇灾害的情况下，遥感影像是我们能够方便立刻获取的地理信息。在地图缺乏的地区，遥感影像甚至是我们能够获取的唯一信息。在5.12汶川地震中，遥感影像在灾情信息获取、救灾决策和灾害重建中发挥了重要作用。海地发生强震后，已有多家航天机构的20余颗卫星参与了救援工作。
影像上获取的灾情信息
成为GIS系统核心组成
遥感具有动态、多时相采集空间信息的能力，遥感信息已经成为GIS的主要信息源。
GIS系统中的遥感信息
(说明：以上部分图片不是原创，如有侵权请告诉我们)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc581876fb35a2d2ed0b4038689df3e/" rel="bookmark">
			如何在Maven项目模块A引用子模块B的war项目的类文件?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先在war模块B添加一个maven-jar-plugin，并设置其classifier为jar. 1 &lt;plugin&gt; 2 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 3 &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; 4 &lt;version&gt;2.4&lt;/version&gt; 5 &lt;configuration&gt; 6 &lt;classifier&gt;jar&lt;/classifier&gt; 7 &lt;/configuration&gt; 8 &lt;executions&gt; 9 &lt;execution&gt; 10 &lt;goals&gt; 11 &lt;goal&gt;jar&lt;/goal&gt; 12 &lt;/goals&gt; 13 &lt;/execution&gt; 14 &lt;/executions&gt; 15 &lt;/plugin&gt; 2.然后模块A引用模块B的jar文件 1 &lt;dependency&gt; 2 &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; 3 &lt;artifactId&gt;B&lt;/artifactId&gt; 4 &lt;version&gt;${project.version}&lt;/version&gt; 5 &lt;classifier&gt;jar&lt;/classifier&gt; 6 &lt;scope&gt;runtime&lt;/scope&gt; 7 &lt;/dependency&gt; 转载于:https://www.cnblogs.com/MDK-L/p/4881556.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cda392498bbdd4cb06f57885d7e99a9/" rel="bookmark">
			C语言中函数参数的省略号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++允许定义形参个数和类型不确定的函数。例如，C语言中的标准函数printf便使用这种机制。在声明不确定形参的函数时，形参部分可以使用省略号“…”代替。“…”告诉编译器，在函数调用时不检查形参类型是否与实参类型相同，也不检查参数个数。 例如： void ConnectData(int i,...) 在上面的代码中，编译器只检查第一个参数是否为整型，而不对其他参数进行检查。 对于可变参数的函数，需要进行特殊的处理。首先需要引用 &lt;stdarg.h&gt; 头文件，然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。 这几个宏的定义如下（在 ANSI C 中）： type va_arg( va_list arg_ptr, type ); void va_end( va_list arg_ptr ); void va_start( va_list arg_ptr, prev_param ); 说明如下： va_start sets arg_ptr to the first optional argument in the list of arguments passed to the function. The argument arg_ptr must have va_list type. The argument prev_param is the name of the required parameter immediately preceding the first optional argument in the argument list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cda392498bbdd4cb06f57885d7e99a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3a97b1ae746d0faefc451be58c1e85/" rel="bookmark">
			Java中System的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.System类及一些常用方法 System类是一些与系统相关的属性和方法的集合，在System类中所有的属性都是静态的，所以可以直接用System类调用即可 public final class System extends Object
System类的常用方法： 1.取得一个操作的计算时间 public static long currentTimeMillis() public class SystemDemo01{ public static void main(String[] args){ long startTime = System.currentTimeMillis(); int sum = 0; for(int i=0;i&lt;30000000;i++){ sum+=i; } long endTime = System.currentTimeMillis(); System.out.println("花费时间："+(endTime-startTime)+"ms"); } } 2.获取计算机全部属性 public class SystemDemo02{ public static void main(String[] args){ System.getProperties().list(System.out); } } 此代码取得的是全部的属性，如果只取得几个固定的属性，可以如下操作： public class SystemDemo02{ public static void main(String[] args){ System.out.println("系统版本："+System.getProperty("os.name")+ "系统用户:"+System.getProperty("user.name")); } } 二.垃圾对象的回收操作 一个对象如果不使用（无引用），则肯定要等待进行垃圾回收，垃圾回收可以自动调用也可以手动调用，手动调用的时候用System.gc()或者Runtime.getRuntime().gc().但是，如果一个对象在回收之前需要做一些收尾工作，则必须覆写Object类中的finalize()方法： protected void finalize() throws Throwable 在对象被回收之前进行调用，以处理对象回收前的若干操作，比如释放资源 class Person{ private String name; private int age; public Person(String name,int age){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3a97b1ae746d0faefc451be58c1e85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd6026d1664abe22c1a19f2f77770ab/" rel="bookmark">
			Github错误：fatal: Authentication failed for &#39;https://github.com/ ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub push代码发生错误：fatal: Authentication failed for ‘https://github.com/ …
使用的https提交，在用SourceTree提交代码时候发生错误，返回的错误提示说：
fatal: Authentication failed for 'https://github.com/ ... 解决方案，重新执行git config命令配置用户名和邮箱即可：
git config -–global user.name "xxx" git config –-global user.email "xxx@xxx.com" 转载：http://blog.csdn.net/zhangphil/article/details/47981757
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb80d0380d41928c7ff1c7b157da215a/" rel="bookmark">
			我写了一个高并发的BlockingQueue，有兴趣的可以看看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是代码所在的github的地址，有兴趣的可以看看，电脑核心比较多的可以跑跑测试程序，看看具体的性能数据如何，我只有一个双核的笔记本.......
https://github.com/MyHighConcurrentBlockingQueue/beta1.git
这是基于java的LinkedTransferQueue而实现的高并发的BlockingQueue，各位可以随便使用。顺便可以可以给点建议。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/267/">«</a>
	<span class="pagination__item pagination__item--current">268/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/269/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>