<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c623a1c7239e893b7eeba86e118e7ba6/" rel="bookmark">
			notepad&#43;&#43;怎么自动缩进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考如下：
https://jingyan.baidu.com/article/ea24bc398530b3da62b331c1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d316bb456cc70c929cbf7e2d503743/" rel="bookmark">
			Java面试题之基础篇概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java面试题之基础篇概览 1、一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？ 可以有多个类，但只能有一个public的类，且public的类名必须与文件名相一致。
2、Java有没有goto？ Java中的保留字，现在未在Java中使用。
3、说说&amp;和&amp;&amp;的区别？ &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。
&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str!= null&amp;&amp; !str.equals(s))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。if(x==33 &amp;++y&gt;0) y会增长，if(x==33 &amp;&amp; ++y&gt;0)不会增长。
&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。
4、在Java中如何跳出当前的多重嵌套循环？ 在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后再里层循环体的代码中使用带有标号的break语句，即可跳出外层循环。
test:for(int i=0;i&lt;10;i++){ for(intj=0;j&lt;10;j++){ System.out.println(“i=” + i + “,j=” + j); if(j == 5) break test; } } 另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。
int arr[][] ={{1,2,3},{4,5,6,7},{9}}; boolean found = false; for(int i=0;i&lt;arr.length&amp;&amp;!found;i++) { for(intj=0;j&lt;arr[i].length;j++){ System.out.println(“i=” + i + “,j=” + j); if(arr[i][j] ==5) { found =true; break; } } } 5、switch语句能否作用于byte上，能否作用在long上，能否作用在String上？ 在 switch(e) 中，e 只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以使int或Integer，由于byte，short，char都可以隐式转换为int，所以，这些类型及其包装类也是可以的。特例，Java1.7以后，switch语句支持String。综上可知，long类型不符合switch的语法规定，并且不能隐式转换成int类型，故不能作用于switch语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d316bb456cc70c929cbf7e2d503743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed630128c681c7866d650d6bd3ce17c5/" rel="bookmark">
			matlab找出二维矩阵中最大值的位置或者最小值的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab寻找最大值或者最小值是通过max和min命令
对应二维矩阵寻找最大元素就是max(max(A))，注意二维矩阵要写两个max
找对应位置用find函数
举个例子：
&gt;&gt; A=[1 2 3 ;4 5 6]
A =
1 2 3
4 5 6
&gt;&gt; max(max(A))
ans =
6
&gt;&gt; [x y]=find(A==max(max(A)))
x =
2
y =
3
&gt;&gt; 找到最大元素是6,对应位置是x=2,y=3,就是第2行,第3列
对于一维的数组就很简单
[m,n]=max(A)
m就是一维矩阵A的最大值，n就是最大值所在的位置
PS：有定制开发需求，可以QQ联系：2472853871
欢迎关注公众号：算法工程师的学习日志
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e11d32c17948a5267f7a1d9f3c1bb3/" rel="bookmark">
			vuecli3&#43;webpack4优化实践（删除console.log和配置dllPlugin）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍如何在vuecli3生成的项目中，打包输出时删除console.log和使用dllplugin，并记录了配置过程中踩到的坑。 （本人水平有限～希望大家多多指出有误的地方）
一、生产环境中删除console.log 在开发代码中写的console.log，可以通过配置webpack4中的terser-webpack-plugin插件达成目的，compress参数配置如下:
module.exports = { optimization: { minimizer: [ new TerserPlugin({ terserOptions: { compress: { warnings: false, drop_console: true, drop_debugger: true, pure_funcs: ['console.log'] }, }, }), ], }, }; 复制代码 而@vue/cli-service的配置源码也是使用了terser-webpack-plugin插件进行Tree Shaking，以下是@vue/cli-service/prod.js的源码
module.exports = (api, options) =&gt; { api.chainWebpack(webpackConfig =&gt; { if (process.env.NODE_ENV === 'production') { const isLegacyBundle = process.env.VUE_CLI_MODERN_MODE &amp;&amp; !process.env.VUE_CLI_MODERN_BUILD const getAssetPath = require('../util/getAssetPath') const filename = getAssetPath( options, `js/[name]${isLegacyBundle ? `-legacy` : ``}${options.filenameHashing ? '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e11d32c17948a5267f7a1d9f3c1bb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923b578a2d45d21dd586b53f28479926/" rel="bookmark">
			使用神经网络进行数据预测（TensorFlow&#43;包含数据预处理过程&#43;train&#43;test&#43;predict）（文末有github源代码&#43;数据链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.总览 神经网络、数据预处理、分类问题的入门教程。使用TensorFlow搭建基本的网络，使用one-hot对于数据进行预处理，通过神经网络对数据进行训练，最终取得较好的分类效果，accuracy&gt;97%.
1.数据来源 数据来源于可穿戴传感器健康老年人动作识别，在网站注册后即可下载（偶然的机会找到的网站），这是一个十万级的数据集。
下载后的截图如下，数据的github下载链接
文件夹S1_Dataset中的数据们
2.数据预处理 下面开始数据预处理啦，直接上代码：
file_dir = "data_try/S1_Dataset" def pre_data(): data_num_total = 0 with open('train.csv', 'w',newline='') as f: f_csv = csv.writer(f) f_csv.writerow(headers) for root, dirs, files in os.walk(file_dir): #print(root) #当前目录路径 #print(dirs) #当前路径下所有子目录 print(files) #当前路径下所有非目录子文件 for i in range(len(files)): #print(len(files)) sex = files[i][-1] print(sex,i) if sex == 'M': sex = 1 elif sex == 'F': sex = 0 input_file = 'data_try/S1_Dataset/' + files[i] reader = open(input_file, 'r') while True: line = reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/923b578a2d45d21dd586b53f28479926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634081acd68fa42e689616d3d86fd615/" rel="bookmark">
			单片机寄存器的位操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、连续多位需要操作 假如需要将B16的D8~D10位改为0001，但是更改D8~D10位时又不能改变其它位状态：所以需要先将D8~D10位 清0，再改为0001 PORTB-&gt;PCR[16] &amp;= 0XFFFFF8FF; //需要修改D8~D10位，确保D8~D10位为0，其他位不变（只有为0才能确保能正确修改该位的值） PORTB-&gt;PCR[16] |= 0X00000100; //更改D8~D10状态 D8~D10写为001配置为GPIO功能 2、单个位需要改变状态 假如需要将寄存器的D4位 置0：先将D4位置1后，整体取反，这样就变成了D4位为0，其它位都为1，然后再按位与。
PTD-&gt;PDDR &amp;= ~(1&lt;&lt;4);	//D4位 置1 取反 相当于置0（这样做的目的是为了保证别的位不受影响，只改变需要改变的位） 假如需要将寄存器的D4位 置1：将D4位置1后，再按位或。
PTD-&gt;PDDR |= (1&lt;&lt;4); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb434f845658c8b54da11fce43de28b5/" rel="bookmark">
			[填坑]QT Creator调用VS2017自带调试器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方案一： 需要单独下载Windows SDK进行下载，然后勾选debug工具进行安装。
Win10下QtCreator设置MSVC2017x64:https://www.jianshu.com/p/d14ca31c529e
方案二： 其实对于大多数安装了VS的开发者，已经装了SDK，如果再下载有点多余。并且如果安装了更低版本，可能提示"You must uninstall the windows software development kit"
其实只需要在控制面板-》程序-》程序和功能-》找到Windows software development kit进行更改即可，过程如下图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332ba07cabb80b7672e07547fce9ef5f/" rel="bookmark">
			【软件构造】课件精译（四）软件构造过程与工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、本章概述 1、软件构造的一般过程：设计→编程/重构→Debug→测试→构建→发布 编程/重构
审查和静态代码分析
Debug和测试
动态代码分析/剖析
2、软件构造的狭义过程（构建）：验证→编译→链接→测试→打包→安装→部署 构建系统：组件和进程
构建变量和构建语言
构建工具：Make, Ant, Maven, Gradle, Eclipse
3、总结 二、本章目标 了解软件构造的一般过程（设计、编程、调试、生成、发布）。
使用Eclipse IDE作为Java构建环境和工具。
了解典型的评审工具和静态分析、调试（dumping、日志记录）和测试，以及动态分析/剖析。
学习狭义软件构建过程（构建）：验证，编译，链接测试，打包，安装，部署。
使用一个构建工具（Make，Ant，Maven，Gradle，Eclipse IDE）来构建自己的Java项目。
三、正文 1、软件构造的一般过程 （1）编程 构造语言
编程语言（例如：C，C++，Java，Python）
模型语言（例如：UML）
配置语言（例如：XML）
基于语言学的
基于数学的（正式的）
基于图形的（可视化的）
编程语言 编程工具
集成开发环境（IDE）：为程序员提供软件开发的综合设施。
IDE通常包括：
带有智能代码完成、代码重构工具的源代码编辑器，文件管理工具，图书馆管理工具，类浏览器、对象浏览器、面向对象的类层次结构图，图形用户界面（GUI）生成器，编译器、解释器，构建自动化工具，版本控制系统
另外，IDE应该能够被更多第三方工具扩展。
举例：Eclipse
建模语言和工具 建模语言是一种人工语言，用于表达信息、知识或系统，以一套一致的 规则定义来可视化、推理、验证和交流系统的设计。
UML：统一建模语言
用例图
类图
时序图
组件图
配置语言 用来配置程序的参数和初始设置，应用应提供工具支持配置文件的维护。
举例：
Key-Value texts (.ini, .properties, .rc, etc)
XML, YAML, JSON
（2）审查和静态代码分析 代码审查是对源代码的系统性检查，正式评审会， 逐行审查代码，轻量级代码审查要求相对第一点。
（3）动态代码分析/剖析 运行程序以分析代码；程序需要经过充分的测试；利用测试度量技术（如覆盖率）确保代码的可能功能均被充分测试到；用来测量程序的时空复杂度，特定指令或函数的调用频率或持续时间。
（4）Debug和测试 测试为软件的利益相关者提供有关被测产品或服务质量的信息。
调试是识别错误的根本原因并对其进行纠正的过程；调试往往是成功测试的后续环节，成功测试不意味着没有发现错误， 反而相反。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332ba07cabb80b7672e07547fce9ef5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f580668a8d79e5b4853f65c7834b96e/" rel="bookmark">
			Python操作Excel删除一个Sheet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Python进行数据分析处理，操作Excel，有时需要删除某个Excel里的某个sheet，这里记录一个我测试成功的一个办法
软件环境：
1、OS：Win 10 64位
2.Python 3.7
3、使用openpyxl这个库
4、在当前文件夹下准备一个xlsx格式的Excel文件，【注意】：不支持删除xls格式的Excel文件的sheet
文件名：Test1.xlsx，其中有三个sheet，分别为:sheet1、sheet2、sheet3
参考代码：
#! -*- coding utf-8 -*- #! Python Version 3.7 import openpyxl def main(): sExcelFile="Test1.xlsx" wb = openpyxl.load_workbook(sExcelFile) ws = wb["Sheet2"] wb.remove(ws) wb.save(sExcelFile) print("It is over") if __name__=="__main__": main() 此代码成功运行，网上查找到的一些资料，可能和软件环境有关，执行屡屡报错，所以，这里给出明确的软件环境。
转载于:https://www.cnblogs.com/SH170706/p/10497139.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176e1d347f828bdda518746bf8db7fc4/" rel="bookmark">
			android架构组件之ViewModel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ViewModel所解决的问题 对于当前的界面，可能由于配置、旋转或是其他的原因导致当前的界面异常销毁，当出现这种情况时，界面恢复时也同时需要恢复一些数据，之前的做法就是利用onSaveInstanceState（）在异常销毁时将数据保存起来，然后在页面重新启动时通过onRestoreInstanceState（）对数据进行恢复，这种做法通常是对于一些简单的数据进行保存。现假如当前界面有个网络请求，当界面异常销毁后重新创建时不在进行网络请求，而是直接使用上一次请求的数据，这时该怎么去做呢？这时就需要使用到这里的主角ViewModel了。
ViewModel定义 现在来看看ViewModel是如何定义：
public abstract class ViewModel { /** * This method will be called when this ViewModel is no longer used and will be destroyed. * &lt;p&gt; * It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel. */ @SuppressWarnings("WeakerAccess") protected void onCleared() { } } 还是很简单的，里面就是定义了一个方法，这个方法会在onDestroy（）中被调用，所以这个方法里可以做一些释放资源的工作，他有一个实现类AndroidViewModel，这个类主要是提供了一个全局的Application，这样就可以在这个类中使用全局上下文了。
ViewModel使用 首先是定义一个继承ViewModel（如果需要Application，可以继承AndroidViewModel）类，如下：
public class CustomViewModel extends ViewModel { public MutableLiveData&lt;List&lt;String&gt;&gt; listData = new MutableLiveData&lt;&gt;(); public void getListData(){ //假设这里是一个网络请求 new Thread(new Runnable() { @Override public void run() { try { TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/176e1d347f828bdda518746bf8db7fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bbcf92af8e00cda660482e6d69a961e/" rel="bookmark">
			产品的10大设计原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迪特·拉姆斯提出了做好硬件产品的10个设计原则，乔布斯把这些产品设计的原则，不仅用在苹果硬件产品上，还用在软件产品上。而张小龙把这些好产品的原理应用到微信设计上。
迪特·拉姆斯的好产品设计的 10 个原则：
Good design is innovative.Good design makes a product useful.Good design is aesthetic.Good design makes a product understandable.Good design is unobtrusive.Good design is honest.Good design is long-lasting.Good design is thorough down to the last detail .Good design is environmentally friendly.Good design is as little design as possible. 张小龙在2019年的微信公开课演讲时对设计原则的理解：
第一条，好的产品是有创意的，它必须是一个创新的东西；第二条，好的产品是有用的，一定要对人有用；第三条，好的产品是优美的，它必须有美感，很美丽，你会喜欢它；第四条，好的产品是非常容易使用的，不难用，没有说明书，一看就会了；第五条，好的产品是含蓄的，并不招摇的；第六条，好的产品是诚实的，对用户是很诚实的。第七条，好的产品会经久不衰，它不会随着时间的流逝而迅速消亡掉；第八条，好的产品不会放过任何一个细节；第九条，好的产品是环保的，或者说是不浪费太多资源的；第十条，好的产品会尽可能少的体现它的设计，或者说少即是多。 简单说来，好的产品应当是：有用、有创意、有美感的、易用的、不招摇的、诚实的、有长期计划的、注重细节的、节省的、简洁的。
可以说，这10条几乎已经涵盖了市面上的所以的知道产品设计的书了。这些书，其实都是在为这10条做注解罢了。
这10条原则最初其实是为硬件产品而制定的，现在拿过来作为通用的或者软件产品的设计原则，也是适用的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d3113e74dda070b434b92b79edfdf02/" rel="bookmark">
			Object Detection 之基础知识 (02)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下知识来自网易云课堂：深度学习：算法到实战
目录
一、评价标准
二、滑动窗口
三、目标候选框生成（Object Proposal generation）
四、难负样本挖掘（Hard Negative Mining）
五、 非极大值拟制（Non-Maximum Suppression）
六、边界框回归（Bounding Box Regression）
一、评价标准 1，准确率（Precision）: 正确预测为正类的样本占所有预测为正类的比例 （所有预测为正类的样本中有多少是真正为正类）
2，召回率（Recall）：正确预测为正类的样本占所有实际为正类样本的比例（所有为正类的样本中有多少被预测为正类）
其中P为预测结果区域Prediction，G 为目标区域Ground Truth
3，交并比（IOU, Intersection-over-Union）: 二、滑动窗口 传统的方法是用一个滑动窗口，从左到右，从上到下滑动，匹配窗口内是否含有目标。下面的需要滑动512x512次（上下步长为1）
三、目标候选框生成（Object Proposal generation） 使用一些方法去生成目标候选框，可能就几百个或几千个候选框，而传统的滑动窗口法，窗口可能会有几万个或是几十万个。
目标候选框生成方法，代表算法有：
其中SS常用在经典目标检测算法中，比如R-CNN，Fast-RCNN
SS：首先，对输入图像进行分割算法（Graph-Based Image Segmentation）产生许多小的子区域。其次，根据这些子区域之间相似性(相似性标准主要有颜色、纹理、大小等等)进行区域合并，不断的进行区域迭代合并。每次迭代过程中对这些合并的子区域做bounding boxes(外切矩形)，这些子区域外切矩形就是通常所说的候选框。
四、难负样本挖掘（Hard Negative Mining） negative相对于positive，是相对于正样本来说，不含有目标的负样本。但是，negative包括很多，有完全不包含目标的的，也有部分含有的，其中比较容易被判定是负样本（比如全是背景）的对于训练并不能起到很好的监督作用。我们需要找一些难划分的负样本，也就是hard negative，来增强网络的判别性能。
1，我们先用初始的正负样本(一般是正样本+与正样本同规模的负样本的一个子集)训练分类器,；
2，然后再用训练出的分类器对样本进行分类, 把其中负样本中错误分类的那些样本(hard negative)放入负样本集合, 再继续训练分类器；
3， 如此反复, 直到达到停止条件(比如分类器性能不再提升). 这个过程就是 Hard Negative Mining。
五、 非极大值拟制（Non-Maximum Suppression） NMS:
1，在进行目标检测时一般会采取窗口滑动的方式，在图像上生成很多的候选框，然后把这些候选框进行特征提取后送入分类器，一般会得出一个得分（score），比如人脸检测，会在很多框上都有得分;
2，然后把这些得分全部排序。选取得分最高的那个框，接下来计算其他的框与当前框的重合程度（overlap）；
3，如果重合程度大于一定阈值就删除，因为在同一个脸上可能会有好几个高得分的框，都是人脸但是不需要那么框我们只需要一个就够了。
注：那么肯定有人会好奇，如果图片中有好几个人脸，你这选取一个最大的，那第二个人脸怎么办呢。
实际上这是一个迭代的过程，第一步的非极大值抑制就是选取了某一个最大的得分，然后删除了他周边的几个框，第二次迭代的时候在剩下的框里面选取一个最大的，然后再删除它周围重叠区域大于一定阈值的，这样不停的迭代下去就会得到所有想要找到的目标物体的区域。
六、边界框回归（Bounding Box Regression） 红色框口P表示建议框Region Proposal，绿色窗口G表示实际框Ground Truth，红色窗口G^表示Region Proposal进行回归后的预测窗口，现在的目标是找到P到G^的线性变换，使得G^与G越相近，这就相当于一个简单的可以用最小二乘法解决的线性回归问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac4e6ba0257e585f00e0b71c1575c4ad/" rel="bookmark">
			如何向maven 项目中导入依赖，并且完成测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在IDEA中的Maven项目中 添加第三方的Jar依赖，其实很简单，请看图:
1.先打开项目中的pom.xml文件,并使用快捷键 Alt+Insert :
2.选择 Depenency 后，并输入要添加的Jar包的相关包名或者类名检索：
3.选择搜索结果列表中你需要的版就导入成功了，这时你会发现，pom.xml文件里会自动添加这些jar的依赖了！
在测试程序的方法上@Test就可以运行方法，完成测试
如果在右下角提示错误：Maven project need to be import
点击： Enable Auto_Import
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8ee0b71b2b269671754dc70e47632d/" rel="bookmark">
			最新详细mysql安装和连接navicat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，去下载，这里使用的是当前最新版本的zip（mysql-8.0.15，64-bit）注意位数 2，解压到 D 盘： 3，配置环境变量： 之后将 %MYSQL_HOME%\bin; 添加到path中（注意自己的路径！！！！！！！） 4，再在mysql-8.0.15-winx64文件下，用记事本新建文件 my.ini ，写入内容： [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=D:\mysql-8.0.15-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\mysql-8.0.15-winx64\Data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 #mysql_native_password default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 由于之前安装的phpstudy中已有了mysql，且端口号为3306，所以这里我改为3309 ，（注意自己的路径！！！！！！！！！） 5，以管理员身份运行CMD (C：\ Windows \ System32目录下找到cmd.exe右键以管理员身份运行) 命令 mysqld --initialize 获取初始密码 （Ki4psjWk6y#j 记住密码） 在mysql-8.0.15-winx64目录下使用命令 mysqld --install 注册服务 如果出现之前的服务
The service already exists!
The current server installed: D:\mysql-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a8ee0b71b2b269671754dc70e47632d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26710233fcc8de609640749ab55f0d60/" rel="bookmark">
			扩展卡尔曼滤波在导航中的应用概述和整定参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文名：Extended Kalman Filter Navigation Overview and Tuning
翻译自http://ardupilot.org/dev/docs/extended-kalman-filter.html
这篇文章描述直升机和飞机基于陀螺仪、加速计、罗盘、GPS、空速和气压计等设备估算位置、速度和航向角的卡尔曼滤波算法。文章包括算法的概述和用于整定的参数。
概述 更快的处理器（如Pixhawk上的处理器）能够使用更高级的数学算法估计飞行器的方向、速度和位置。使用陀螺仪、加速度计、罗盘、GPS、空速和气压测量来估计飞行器的位置、速度和角度方向的扩展卡尔曼滤波器算法已经被开发了。此算法在AP_NavEKF库中实现，初步工作记录于：https://github.com/priseborough/InertialNav。
PX4和Pixhawk的用户可以设置AHRS_EKF_USE（使用高程航向参考系统） = 1，从而使用此算法代替传统补充滤波器。
相比方向余弦矩阵和直升机惯性导航使用的简单补充滤波算法，扩展卡尔曼滤波器的优势在于融合了所有可用的测量方法，能够改正测量中的重大错误，因此飞行器不易受单个传感器错误的影响。
扩展卡尔曼滤波器的另一个特点是可以为飞机、直升机和车辆估算罗盘偏移和地球磁场。这使它比现行的方向余弦矩阵和惯性导航算法更不易受罗盘标定错误的影响。
它也使可选传感器例如光流和激光测距仪能用于航行辅助。
理论 已实现的扩展卡尔曼滤波器算法通过以下方法得到基础方程组，估计总共22个状态：https://github.com/priseborough/InertialNav/blob/master/derivations/GenerateEquations22states.m
以下是滤波器工作原理的非常简化的非数学描述：
对惯性测量单元角速度积分以计算角位置。通过角位置，把惯性测量单元加速度从船体的XYZ坐标系转换为以北、东和下为正方向的地球坐标系，并进行重力校正。对加速度积分以计算速度。对速度积分以计算位置。 从1）到4）的过程被称为“状态预测”。“状态”是试图估计的变量，如横摇、纵摇、首摇、高度、风速等。除了位置、速度和角度之外，滤波器还具有其他状态，包括陀螺仪偏差、Z加速度计偏差、风速、罗盘偏差和地球磁场，并且假设这些状态变化缓慢。这些其他状态不是通过“状态预测”步骤直接修改的，而是通过稍后描述的测量来修改。从1）到4）的过程被称为“状态预测”。“状态”是试图估计的变量，如横摇、纵摇、首摇、高度、风速等。除了位置、速度和角度之外，滤波器还具有其他状态，包括陀螺仪偏差、Z加速度计偏差、风速、罗盘偏差和地球磁场，并且假设这些状态变化缓慢。这些其他状态不是通过“状态预测”步骤直接修改的，而是通过稍后描述的测量来修改。
使用惯性测量单元数据计算角度、速度和位置，用预计的陀螺仪噪声和加速度计噪声（EKF_GYRO_NOISE和EKF_ACC_NOISE）估计计算结果的误差增长。这些参数越大，会导致滤波器估计的误差增长得越快。如果没有使用其他测量（例如GPS）进行校正，则该估计误差将继续增长。这些估计的误差被存放在称为“状态协方差矩阵”的矩阵中。
每当获得惯性测量单元的新数据时，重复步骤1）至5），直到可以使用来自另一传感器的新测量。 如果有完美的初始估计、完美的惯性测量单元测量和完美的计算，那么可以在整个飞行过程中不断重复1）到4）而无需其他计算。但是，初始值中的误差、惯性测量单元测量中的误差以及计算中的舍入误差意味着只能在速度和位置误差变得太大之前停留几秒钟。
扩展卡尔曼滤波器算法提供了一种组合或融合来自惯性测量单元、GPS、罗盘、空速和气压计以及其他传感器的数据的方法，以更准确和可靠地估计位置、速度和角度方向。
以下示例描述了如何使用GPS水平位置测量，但是相同的原理适用于其他测量类型（气压高度、GPS速度等）
当GPS测量到达时，滤波器计算4）的预测位置与GPS位置之间的差值。这种差值被称为“创新”。综合利用来自6）的差值、来自5）的“状态协方差矩阵”以及由EKF_POSNE_NOISE（水平位置噪声）表示的GPS测量误差，以计算每个滤波器状态的校正值。这被称为“状态校正”。 这是卡尔曼滤波器高明的地方，因为它能够使用不同误差和不同状态之间的相关性的知识来校正其它状态，而不只是校正被测量的状态。例如，GPS位置测量能够校正位置、速度、角度和陀螺仪的误差。
校正量的数值由状态误差与测量误差的假定比例控制。这意味着如果滤波器认为计算的位置比GPS测量更准确，则校正时GPS测量的权重将更小。如果它认为计算的位置不如GPS测量精确，则校正时GPS测量的权重将更大。GPS测量的假设精度由EKF_POSNE_NOISE（水平位置噪声）参数控制。EKF_POSNE_NOISE（水平位置噪声）越大，会导致滤波器认为GPS位置越不准确。
由于现在已经进行了测量，因此减少了每个已更新状态的不确定性。滤波器计算由于“状态校正”导致的不确定性的降低，更新“状态协方差矩阵”，并返回步骤1）。 整定参数 AHRS_EKF_USE（使用高程航向参考系统） 将此值设置为1表示启用滤波器，设置为0表示使用传统算法。请注意，无论此参数为何值，两种算法都在运行，而且无论是否启用全速率的高程航向参考系统数据记录，都将记录所有扩展卡尔曼滤波数据。
从Copter3.3开始，默认情况下已启用扩展卡尔曼滤波，不能使用此参数。Plane和Rover的用户仍然可以选择使用传统算法。
EKF_ABIAS_PNOISE（加速度计偏差噪声） 该噪声控制垂直加速度计偏差状态的估计误差的增长。增大它会使加速度计的估计偏差变化得更快更嘈杂。
EKF_ACC_PNOISE（加速度计噪声） 该噪声控制由于加速度计的除偏差之外的测量误差导致的预计误差的增长。增大它使得滤波器更不信任加速度计测量而更信任其他测量。
EKF_ALT_NOISE（高度噪声） 这是高度测量中的噪声的均方根。如果增大此参数，滤波器会认为气压计噪声较大，并且减小其测量值的权重。
如果此参数设置得太小，则滤波器将不断对气压计测量中的噪声做出反应，这将导致滤波器输出的高度产生噪声。在直升机中，这将导致直升机在尝试保持高度时上下摆动。
如果此参数设置得太大，则高度精度将过小，并且更容易受到GPS垂直速度误差的影响。
有关使用日志数据帮助设置此参数的详细信息，请参阅解释EKF3日志数据的部分。
EKF_ALT_SOURCE（高度来源） 此参数控制在光流导航期间使用哪个测量源来确定高度。设置为0表示使用气压计，或1表示使用测距仪。如果设置为1，则飞行器将尝试相对于地面保持恒定的高度，这是光流导航期间的默认行为。警告：EK2_ALT_SOURCE = 1仅适用于平缓地面上的低空和低速操作，不适用于上飞行和下飞行。要在较低高度使用测距仪和使用气压计进行上行和下行，请设置EK2_ALT_SOURCE = 0，并且使用RNG_USE_HGT（测距仪用于高度）参数。
EKF_EAS_GATE（预计空速阈值） 此参数调整测量空速与预计空速的一致性检查的阈值。减小它会使拒绝好的测量结果的可能性增大。增大它会使接受不良测量的可能性增大。它以标准差为单位进行缩放。例如，设置为3表示大于3倍的假设标准差的差值将导致测量被拒绝。
EKF_EAS_NOISE（预计空速噪声） 这是罗盘测量中的噪声的均方根。增大它会减小这些测量的权重。有关使用日志数据来帮助设置此参数的详细信息，请参阅解释EKF3日志数据的部分。
EKF_FALLBACK（回退） 此参数表示传感器数据中的不一致是否会导致回退到方向余弦矩阵。如果设置为0，则检测到不一致的传感器不会导致回退。如果设置为1，那么当方向余弦矩阵可用时，大的数据不一致将导致回退到方向余弦矩阵。
EKF_FLOW_DELAY（流速滞后） 这是光流速度测量滞后于惯性测量单元测量的毫秒数。
EKF_FLOW_GATE（流速阈值） 该参数控制测量的光流速度与预测速度之间的最大差值。差值超过此数值，扩展卡尔曼滤波将开始拒绝测量值。减小该参数会使拒绝有效的光流速度测量的可能性增大。增大该参数会使接受无效的光流速度测量的可能性增大。它以标准差为单位进行缩放。例如，设置为3表示大于3倍假设标准差的差值将导致测量被拒绝。
EKF_FLOW_NOISE（流速噪声） 该参数表示允许的光流速度测量误差和噪声。它表示以rad / sec为单位的预计均方根误差。如果设置得太大，位置偏差会更大。如果设置得太小，扩展卡尔曼滤波输出的位置和速度将变得嘈杂，并且存在扩展卡尔曼滤波在机动期间开始拒绝光流速率测量的风险。
EKF_GBIAS_PNOISE（陀螺仪偏差噪声） 该噪声控制陀螺仪偏差状态的估计误差的增长。它越大使得陀螺仪的估计偏差变化得越快越嘈杂。
EKF_GLITCH_ACCEL（加速度误差） 此参数控制滤波器预测的水平加速度与GPS测量值之间的最大差值（以cm / s ^ 2为单位）。差值超过此数值，滤波器将拒绝GPS位置测量。如果此值设置得太低，则将经常丢弃有效的GPS数据，而且位置精度将降低。如果此参数设置得太高，则GPS故障会导致位置发生很大的快速变化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26710233fcc8de609640749ab55f0d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db70daa34786b9de1e9ea7319ff486f4/" rel="bookmark">
			Leetcode.合并两个有序数组(Java实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 合并两个有序数组 * 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 * &lt;p&gt; * 说明: * &lt;p&gt; * 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 * 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 * 示例: * &lt;p&gt; * 输入: * nums1 = [1,2,3,0,0,0], m = 3 * nums2 = [2,5,6], n = 3 * &lt;p&gt; * 输出: [1,2,2,3,5,6] * &lt;p&gt; * 解题思路：定义一个新数组，定义三个指针分别指向三个数组的第一个元素，比较两个数组的大小，将小的元素放入新数组，当一个数组放入结束后就将另一个全部放入新数组中，最后将新数组的元素赋值给nums1数组 */ public class MergeArray { public static void main(String[] args) { int[] nums1 = {1, 2, 3,0,0,0}; int[] nums2 = {2, 5, 6}; merge(nums1, 3, nums2, 3); } public static void merge(int[] nums1, int m, int[] nums2, int n) { int[] newArray = new int[m + n];//定义一个新的数组，长度为两个原数组长度之和 int i = 0, j = 0, count = 0;//定义三个指针，分别指向三个数组的第一个元素 //当指针位置小于数组长度时，比较两个数组的元素的大小，小的放入新数组 while (i &lt; m &amp;&amp; j &lt; n) { if (nums1[i] &lt; nums2[j]) { newArray[count++] = nums1[i++]; } else { newArray[count++] = nums2[j++]; } } if (i &gt;= m) {//当第一个数组遍历完成，直接将第二个数组元素放入新数组 while (j &lt; n) { newArray[count++] = nums2[j++]; } } if (j &lt;= n) {//当第一个数组遍历完成，直接将第二个数组元素放入新数组 while (i &lt; m) { newArray[count++] = nums1[i++]; } } for (int k=0;k&lt;newArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db70daa34786b9de1e9ea7319ff486f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe9843865eb15a78b0282fdeddc4956/" rel="bookmark">
			AT指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AT 指令介绍 基本命令 基本用法 测试命令(Test Command)在 AT 指令后面加上“=?”即构成测试命令。例如“AT+CSCS=?”会列举出所有支持的字符集。读取命令(Read Command)在 AT 指令后面加上“?”即构成读取命令。例如“AT+CSCS?”会列举出当前设置。执行命令（Execute Command）一般而言在 AT 指令后加上“=”及命令参数即可。有些命令例如 AT+CMGR 命令没有参数，直接就可以执行。 注: 并不是所有的 AT 指令都支持 1 和 2
基本指令 指令含义示例返回结果AT测试连接是否正确AT\rOKAT+CGMI得到厂商信息AT+CGMI\rQuectelAT+CSCS获取、设置手机当前字符集。可设置为 GSM 或 UCS2AT+CSCS=?\r+CSCS: (“IRA”,“GSM”,“UCS2”)AT+CNUM机身号码。分为线路一和线路二AT+CNUM\r+CNUM: ,"+8613200000000",145AT+CPIN?是否有 SIM 卡AT+CPIN?\r+CPIN: READYATD用于拨打任意电话号码ATD13200000001;\r+CGREG: 1,“F115”,“A15ED09”,2 挂断电话显示:NO CARRIERATA即可接听来电ATA\r-ATH用于挂断电话，要想结束正在进行的通话，只需给模块发送： ATH，即可挂断。ATH\r-AT+CMGF优先信息格式。执行格式有 TEXT 方式和 PDU 方式。AT+CMGF=1\rOKAT+CPMS优先信息存储。这个命令定义用来读写信息的存储区域。 表示手机支持 MT(手机终端),SM(SIM 卡),ME(手机设备)AT+CPMS=“SM”,“SM”,“SM”\rOKAT+CMGR读短信。信息从+CPMS 命令设定的存储器读取AT+CMGR=3\r+CMGL: 1,“REC UNREAD”,"+8613200000001",“19/03/06,11:41:00+32” 53D177ED4FE165F650196D4B8BD5AT+CMGL列出存储的信息AT+CMGL=?\r+CMGL: (“REC UNREAD”,“REC READ”,“STO UNSENT”,“STO SENT”,“ALL”)AT+CMGD删除短信息。删除一个或多个短信息AT+CMGD=1\rOK 拨打电话 # 电话打进来 2019/3/6 14:22:45#********# +CIEV: 1,4 2019/3/6 14:22:45#********# +CREG: 1,"F115","A15ED09",2 +CGREG: 1,"F115","A15ED09",2 2019/3/6 14:22:49#********# +CIEV: 7,1 2019/3/6 14:22:49#********# +CRING: VOICE +CLIP: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe9843865eb15a78b0282fdeddc4956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc39bd58e38c7f1b39cdacfef2444f1/" rel="bookmark">
			[填坑]QT5.12 &#43; MYSQL8.0 &#43; VS2017解决各种报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尝试1： https://blog.csdn.net/qq_29176963/article/details/82776559
将C:\Program Files\MySQL\MySQL Server 8.0\lib 下的ilbmysql.lib和libmysql.dll复制到 D:\Qt\5.12.0\msvc2017_64的bin和lib目录下 ，提示QMYSQL driver not load 还有其他教程提示C:\Program Files\MySQL\MySQL Server 8.0\bin中若干文件进行复制依旧没有用
原因：5.12Qt的mysql 驱动可能和 安装的mysql 的版本不一样
尝试2： 解决问题 Qt + MySql："QSqlDatabase: QMYSQL driver not loaded"
https://blog.csdn.net/sigmarising/article/details/80664639
重新下载Connector/C++驱动https://dev.mysql.com/downloads/connector/cpp/ ，结果8.0版本，压缩包内并没有ilbmysql.lib和libmysql.dll，只有vs14编译的动态链接库
尝试3： 使用ODBC连接mysql
https://blog.csdn.net/qq_37105120/article/details/84000341
VS2017解决不了问题，提示“由于系统错误 182: (MySQL ODBC 8.0 ANSI Driver, C:\\Program Files\\MySQL\\Connector ODBC 8.0\\myodbc8a.dll)，指定驱动程序无法加载。 QODBC3: Unable to connect”
最终： 回退到MySQL5.6版本依旧无法运行！
新建一个空白项目，MySQL5.6可以运行！最终排查发现QT MySQL库与项目中包含的MATLAB DLL冲突！应该是需要同时加载同名不同版本dll引起的冲突。
解决方案：调整环境变量顺序，删除无关的环境变量 QT5.12与MySQL8.0配合也没有任何问题！！！但是相比MySQL5.6还要多添加 libeay32.dll 和ssleay32.dll
Beside libmysql.dll and qsqlmysql.dll, other two *.dll files are also necessary (but no solution I searched refers to them): libeay32.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc39bd58e38c7f1b39cdacfef2444f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a831ad0f336025eac22c565ff70ac066/" rel="bookmark">
			OD使用初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是OD OD全称Ollydbg，是反汇编常用的工具，经常用作动态调试。
2.OD中文版下载 下载地址
3.界面简介 4.默认功能 1）汇编代码对应的地址窗口（虚拟地址，一般情况下，同一程序的同一条指令在不同系统环境下此值相同。）
2） 汇编代码对应的十六进制机器码窗口
3）反汇编窗口
4）反汇编代码对应的注释信息窗口
5）寄存器信息窗口
6）当前执行到的反汇编代码的信息窗口
7~9） 数据所在的内存地址，十六进制，ASCII码
10~12）栈地址，存放的数据，对应说明信息
5.OD快捷键 F2
下断点，也就是指定断点的地址
F3
加载一个可执行程序，进行调试分析
F4
程序执行到光标处
F5
缩小、还原当前窗口
F7
单步步入
F8
单步步过
F9
直接运行程序，遇到断点处，程序暂停
Ctrl+F2
重新运行程序到起始处，一般用于重新调试程序
Ctrl+F9
执行到函数返回处，用于跳出函数实现
Alt+F9
执行到用户代码处，用于快速跳出系统函数
Ctrl+G
输入十六进制地址，快速定位到该地址处
6.寄存器 EAX:扩展累加寄存器
EBX扩展基址寄存器
ECX扩展计数寄存器
EDX扩展数据寄存器
ESI扩展来源寄存器
EDI扩展目标寄存器
以下三个不可随便用，他们的范围是（0--ffffffff）
EBP扩展基址指针寄存器，主要用于栈和栈帧
ESP扩展堆栈指针寄存器，指向当前进程的栈空间地址
EIP:扩展的指令指针寄存器，总是指向下一条被被指向的命令
7.常用方法 1）F2下断点，Alt+b打开断点编辑器，可编辑所有下过的断点，空格键可快速切换断点状态。
2）当位于某个CALL中，这时想返回到调用这个CALL的地方时，可以按“Ctrl+F9”快捷键执行返回功能。
这样OD就会停在遇到的第一个返回命令（如RET、RETF或IRET）。
3）如果跟进系统DLL提供的API函数中，此时想返回到应用程序领空里，可以按快捷键“Alt+F9”执行返回到用户代码命令。
4）所谓领空，实际上就是指在某一时刻，CPU执行的指令所在的某段代码的所有者。
如004013F7这类地址一般是可执行文件领空，7C8114AB这类大地址一般是系统DLL所在的地址空间。
5）程序通常读取文本框内容的字符串用的是以下两个函数： GetDlgItemTextA（GetDlgItemTextW）
GetWindowTextA（GetWindowTextW）
6）按“Ctrl+G”键打开跟随表达式的窗口。（***很重要，可追踪函数）
7）通过“Ctrl+N”键打开应用程序的导入表（输入表），然后查看应用程序总共导入了哪些函数来以此推断需要在哪里挖坑下陷阱！（***很重要，可追踪导入的dll等文件）
8）返回值，汇编代码的返回值约定是存放在eax这个寄存器里边的，如果32位的eax不够存放返回值，系统会将返回值放在内存某个位置并把该位置的地址放在eax返回。
8.操作指南 指南地址
9.寄存器简介 EBP是当前函数的存取指针，即存储或者读取数时的指针基地址；
ESP就是当前函数的栈顶指针。每一次发生函数的调用（主函数调用子函数）时，在被调用函数初始时，都会把当前函数（主函数）的EBP压栈，以便从子函数返回到主函数时可以获取EBP。
通过一段程序理解esp和ebp：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a831ad0f336025eac22c565ff70ac066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb63297e361e2c603571a5071aaf5a9d/" rel="bookmark">
			版本控制和构建工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本控制：
版本控制系统主要有两种，分别是集中式版本控制系统和分布式版本控制系统，我们熟知的CVS及SVN都是集中式的版本控制系统，而近年来作为分布式版本控制系统的GIT占据了主流。
集中式/分布式版本控制系统区别：
集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。
那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。
和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。
构建工具的简单理解：
在进行编程操作的时候，我们常常会遇到很多与编程无关的项目管理工作，如下载依赖、编译源码、单元测试、项目部署等操作。一般的，小型项目我们可以手动实现这些操作，然而大型项目这些工作则相对复杂。构建工具是帮助我们实现一系列项目管理、测试和部署操作的工具。 软件构建（Software Build）是指软件开发过程中涉及到的一系列处理工作，如将源代码编译成二进制代码，打包二进制代码，运行自动化测试等。为了方便编程人员的操作，人们开发了自动构建（Build Automation）工具来帮助人们处理这些工作。
Java项目构建工具——Maven：
Maven是一个强大的Java项目构建工具。当然，你也可以使用其它工具来构建项目，但由于Maven是用Java开发的，因此Maven被更多的用于Java项目中。
Maven的中心思想是POM文件（项目对象模型）。POM文件是以XML文件的形式表述项目的资源，如源码、测试代码、依赖（用到的外部Jar包）等。POM文件应该位于项目的根目录下。
下图说明了Maven是如何使用POM文件的，以及POM文件的主要组成部分：
POM文件
当你执行一条Maven命令的时候，你会传入一个pom文件。Maven会在该pom文件描述的资源上执行该命令。
构建生命周期、阶段和目标
Maven的构建过程被分解为构建生命周期、阶段和目标。一个构建周期由一系列的构建阶段组成，每一个构建阶段由一系列的目标组成。当你运行Maven的时候，你会传入一条命令。这条命令就是构建生命周期、阶段或目标的名字。如果执行一个生命周期，该生命周期内的所有构建阶段都会被执行。如果执行一个构建阶段，在预定义的构建阶段中，所有处于当前构建阶段之前的阶段也都会被执行。
依赖和仓库
Maven执行时，其中一个首要目标就是检查项目的依赖。依赖是你的项目用到的jar文件（java库）。如果在本地仓库中不存在该依赖，则Maven会从中央仓库下载并放到本地仓库。本地仓库只是你电脑硬盘上的一个目录。你可以根据需要制定本地仓库的位置。你也可以指定下载依赖的远程仓库的地址。这些将会在后续的小节中详细介绍。
插件
构建插件可以向构建阶段中增加额外的构建目标。如果Maven标准的构建阶段和目标无法满足项目构建的需求，你可以在POM文件里增加插件。Maven有一些标准的插件供选用，如果需要你可以自己实现插件。
配置文件
配置文件用于以不同的方式构建项目。比如，你可能需要在本地环境构建，用于开发和测试，你也可能需要构建后用于开发环境。这两个构建过程是不同的。在POM文件中增加不同的构建配置，可以启用不同的构建过程。当运行Maven时，可以指定要使用的配置。
Maven POM 文件
Maven的POM文件是一个xml文件，描述项目用到的资源，包括源代码目录、测试代码目录等的位置，以及项目依赖的外部jar包。
POM文件描述的是构建“什么”，而不是“如何”构建。如何构建是取决于Maven的构建阶段和目标。当然，如果需要，你也可以向Maven构建阶段中添加自定义的目标。
每一个项目都有一个POM文件。POM文件即pom.xml，应该放在项目的根目录下。一个项目如果分为多个子项目，一般来讲，父项目有一个POM文件，每一个子项目都有一个POM文件。在这种结构下，既可以一步构建整个项目，也可以各个子项目分开构建。
转载于:https://www.cnblogs.com/hamac/p/10476451.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada93be82102f626e386171ee2eab262/" rel="bookmark">
			centos7安装python3.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上教程一大把，真是坑了爹，各种问题。
安装wget yum install wget 安装依赖包 yum install gcc	# 依赖包一定要装，否则编译出错 yum install zlib* yum install openssl-devel 下载python3.6 cd /tmp wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz 解压 tar -zxvf Python-3.6.5.tgz 安装 cd Python-3.6.5 ./configure --with-ssl	# 参数很重要，不加后面各种问题 make &amp;&amp; make install 建立软链接 ln -s /usr/local/bin/python3 /usr/bin/python3	# 软链接需要使用绝对路径 ln -s /usr/local/bin/pip3 /usr/bin/pip3 升级pip3 pip3 install --upgrade pip 完美结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124f6e84f9e4f84710fe1bdf54594d59/" rel="bookmark">
			List移除元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List 移除某个元素 四种方式：
方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。方式三，正序遍历 List ，如果找到元素，则使用 remove 方法进行移除，然后进行索引 “自减”。方式四，使用jdk1.8新增的Stream流操作
1.Iterator 迭代器 @Test public void fun9(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("赵云"); list.add("黄忠"); list.add("马超"); list.add("关羽"); list.add("张飞"); // 获取迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ String str = it.next(); if("关羽".equals(str)){ it.remove(); } } System.out.println(list); } 2.倒序遍历
@Test public void fun10(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("赵云"); list.add("黄忠"); list.add("马超"); list.add("关羽"); list.add("张飞"); for (int i = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124f6e84f9e4f84710fe1bdf54594d59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9aa73225bce1124d5942e8a2bf42dd4/" rel="bookmark">
			TCP/IP详解--基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多厂家生产各种型号的电脑，他们运行于不同的操作系统，但TCP/IP协议族允许他们互相进行通信。TCP/IP不是一个协议，而是一个协议族的总称，里面包含了IP协议，IMCP协议，TCP协议，http,ftp等，电脑有了这些，即可以在型号系统等不同的情况下互相交流。
TCP/IP协议通常被认为是一个四层协议系统，每一层负责不同的功能。如下图：
链路层：设备驱动程序及接口号 网络层：处理分组在网络层中的活动，例如分组的选路。IP，ICMP，IGMP。 运输层：为两台主机上的应用程序提供端到端的通信。TCP（传输控制协议），UDP（用户数据报协议）。 应用层：处理特定的应用程序细节。Telnet, FTP, SMTP, SNMP。
一些基本的概念
互联网的地址(ip地址)
互联网上的每个接口必须有一个唯一的IP地址，长32bit。分为单播，广播，多播。这些IP由互联网络信息中心(InterNIC)分配，主机号的分配由系统管理员负责。
TCP 传给IP的数据单元称作TCP报文段。IP传给网络接口层的数据单元称作IP数据报。通过以太网传输的比特流称作幀。
为了区分是谁传来的信息，IP在首部存入一个长度为8bit的数值，1表示IGMP协议，2表示IGMP协议，6表示TCP协议，17表示UDP协议。
TCP和UDP采用16 bit的端口号来识别应用程序。任何TCP/IP实现所提供的服务都用知名的1~1023之间的端口号，例如FTP的TCP端口号为21，Telnet服务器的TCP端口号为23，TFTP为69等。大多端口号对应信息在文件 /etc/services中。 服务器使用知名端口号，客户使用临时设定的端口号。
域名系统
域名系统是一个分布的数据库，它提供主机名(网址)转换成ip的服务。
RFC
用来记录互联网规范、协议、过程等的标准文件。基本的互联网通信协议都在RFC文件内详细说明。
端口
端口包括物理端口和逻辑端口。 物理端口是用于连接物理设备之间的接口。 逻辑端口是逻辑上用于区分服务的端口。TCP/IP协议中的端口就是逻辑端口，通过不同的逻辑端口来区分不同的服务。一个IP地址的端口通过16bit进行编号，最多可以有65536个端口。端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535。平常所说的封掉某端口其实是在IP层次把带有这个号码的IP包给过滤掉了。
应用编程接口
常用的两个应用编程接口：socket和TLI(运输层接口)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4964478846a3df87b6bbe3869662de15/" rel="bookmark">
			三星研究院上机题（Order of task）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thereare V tasks to do. Some task(s) can begin only after a particular task ends,which we will call precedence relation. A graph indicating precedence relationof tasks is given. In this graph, each task is denoted as vertex, and the precedencerelation as directed edge. Note there is no cycle with this graph (cycle refers to a path that starts from one vertex and returns to the same vertex). The graph below is one example of such graph
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4964478846a3df87b6bbe3869662de15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109361d0471ec00332eb190c403f841a/" rel="bookmark">
			node.js学习第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.安装node.js
参考如下网址：http://www.runoob.com/nodejs/nodejs-install-setup.html
二.使用node.js运行脚本文件
（1）创建01node.js文件
var foo = 'bar' console.log(foo) 打开cmd输入cd C:\Users\Administrator\Desktop\nodestudy进入js文件所在的文件夹。
输入node 01按tab键会自动将其补全，显示结果为：
（2）创建02没有bom和dom.js
//在Node中，采用EcmaScript进行编码 //没有Bom和Dom //和浏览器中的JavaScript不一样 console.log(window) console.log(document) 显示结果：
（3）创建03读取文件.js
//浏览器中的JavaScript是没有文件操作的能力的 //但是Node中的JavaScript是有文件操作的能力 //fs 是 file-system的简写，就是文件系统的意思 //在Node中如果想要进行文件操作，就必须引入fs这个核心模块 //在fs这个核心模块中，就提供了所有的文件操作的API //例如：fs.readFile就是用来读取文件的 //1.使用require方法加载fs核心模块 var fs = require('fs') //2.读取文件 //第一个参数就是要读取的文件路径 //第二个参数就是一个回调函数 //	成功 //	data 数据 //	error null //	失败 //	data underfind没有数据 //	error 错误对象 fs.readFile('./a.txt',function(error,data){ //&lt;Buffer 68 65 6c 6c 6f 77 6f 72 6c 64&gt; //文件中存储懂的其实都是二进制数据0和1 //这里看不到0和1是因为二进制转化为16进制了 //通过toString去转换 //console.log(data) // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109361d0471ec00332eb190c403f841a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a37d5f5a650d40cde547e114a007354/" rel="bookmark">
			Hadoop Hdfs扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现状和目标
Hadoop目前运行三个节点上，有一台做Namenode，其余为DataNode 主机IP 功能
主机IP功能10.3.5.40NameNode10.3.5.39DataNode10.3.5.41DataNode Hadoop以后运行在6个节点上，有一台做Namenode，其余为DataNode
主机IP功能10.3.5.40NameNode10.3.5.39DataNode10.3.5.41DataNode10.3.5.123DataNode10.3.5124DataNode10.3.5.125DataNode 对业务影响
指标数据暂时无法查询
前置条件和准备过程
Transter-metricstore先关闭优先关闭Transter-metricstore模块登录10.3.5.101 [root@zfr ~]# cd /home/ycm/ycmsys/transfer-metricstore [root@zfr ~]# ./transfer.sh stop SSH无密码认证
在做Hbase、OpenTsDb扩容的时候已经做好了无密码认证。 制作无密码进入过程可参考如下方式：
生成密钥对
[root@zfr ~]# ssh-keygen -t rsa #
把密钥追加到授权的key里面去
[root@zfr ~]# cat id_rsa.pub &gt;&gt; authorized_keys
把公钥复制所有的Slave机器上 把各个机器的密钥追加到授权的key里面去
修改配置文件 修改sshd_config文件
[root@zfr ~]# vi /etc/ssh/sshd_config 修改如下参数 RSAAuthentication yes # 启用 RSA 认证 PubkeyAuthentication yes # 启用公钥私钥配对认证方式 AuthorizedKeysFile .ssh/authorized_keys # 公钥文件路径（和上面生成的文件同） 重启ssh服务 [root@zfr ~]# systemctl restart sshd.service 授权 授权方式需要严格执行
[root@zfr ~]# chmod 755 /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a37d5f5a650d40cde547e114a007354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60074d1ed93b20d52d1c93b861a23928/" rel="bookmark">
			三星研究院上机题（Optimal Path）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mr. Kim has to deliver refrigerators to N customers. From the office, he is going to visit all the customers and then return to his home. Each location of the office, his home, and the customers is given in the form of integer coordinates (x,y) (0≤x≤100, 0≤y≤100) . The distance between two arbitrary locations (x1, y1) and (x2, y2) is computed by |x1-x2| + |y1-y2|, where |x| denotes the absolute value of x; for instance, |3|=|-3|=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60074d1ed93b20d52d1c93b861a23928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feebc63d3855ef613123011d5f8d3aab/" rel="bookmark">
			JS获取radio值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;input type="radio" value="0" name="status" checked="checked"&gt;好评 &lt;input type="radio" value="1" name="status"&gt;差评 $('input:radio[name="status"]:checked').val() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f1c633a5d97a9c935759d3e27d7efa/" rel="bookmark">
			sql查询之 max使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql版本
这是我测试查询最大age的记录；
mysql&gt; select id,name,age from user where age=(select max(age) from user );
网上查了好多都是错误的，所以记下来，备以后使用
欢迎讨论勘正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02355122b096ec7ebbac33f5833785f8/" rel="bookmark">
			线性代数学习心得（一）矩阵乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性代数属于应用数学，应用数学的特点就是应用的目的往往是很明确的。线性代数的目的就是研究向量空间，线性变换等问题。这些问题在很多领域都被广泛应用，特别是在计算机领域。图形学、游戏开发、VR等等。总之，线性代数是计算机学者的必经之路。
此博客是我在学习MIT的线性代数课程中所学到的心得体会。虽然之前我已经对线性代数有了一些浅显的认识。但是这远远不够，对其新的认识我将会以博客的方式记录下来。
那么，我又开始了。
1、向量以及向量乘矩阵 1.1向量 啥叫向量呢？物理中，我们会定义成有方向有有大小量。但是在数学的抽象思维中，向量是可以抽象成一个高维度的点。也可以说向量是一个向量空间的元素。但是这又涉及到啥是向量空间，在这里不多说，以后会对其详细探究。总之现在，你尽可以想像一个n维向量是一个n元的有序序列，也可以是n维空间的点。如果是一个点，那么它必须要有坐标:
例如三维空间某个向量 (右边的括号就是指该维度的名字，我给第一个维度叫x轴，第二个叫y轴，第三个是z轴)，向量中的每一个数字都是向量在该维度延伸的量。
1.2矩阵 矩阵其实是一门很复杂的学问，有一个数学分支就叫《矩阵论》。可见矩阵是一个很重要，而且很有挖掘空间的问题。这里只谈一谈我对矩阵的理解。
如果只是单纯的给出一个矩阵，我会把它看成多个向量。例如一个m*k的矩阵A=
我会认为这个矩阵由m个行向量组成，或者看成由k个列向量组成。
1.3矩阵乘向量 但是如果是给出矩阵乘向量，我会认为矩阵是一个函数，也就是一个映射。
为什么我要这么看呢？就像一个函数 f(x)，向函数中输入一个x就会输出一个函数值。矩阵也是如此，我向矩阵输入一个向量（也就是矩阵乘向量）那么输出的也是一个向量。这就像对向量的一个映射。但是受MIT线性代数课的影响，我又有了新的认识。例如矩阵 向量 在我过往的认知中，矩阵乘法是一个函数，而且在这个函数中向量每行的值只与矩阵对应的行有关。也就是说b1只与a1j有关，bi只与aij有关。既然是函数，就存在数据丢失的可能，原本的向量b为k维，现在的向量是m维。m&lt;=k，如果m&lt;k那么说明有部分维度的数据压缩了，而且这种压缩是不可逆的那么这个矩阵也是不可逆的（以后会具体叙述）。想要了解这部分的原理，可以看我的离散数学第二篇，https://blog.csdn.net/ACM5100/article/details/87353395。
不过在吉尔伯特-斯特朗的讲解下，现在我又对其有了新的认知。
矩阵是多个向量，矩阵乘向量是对矩阵中的向量进行线性组合。
例如： 矩阵A由k个列向量组成，分别是这k个向量。A*b是对A当中的这些向量进行线性组合，向量中的数就是这些组合的参数。如下：
相信常数乘以向量，以及向量的加法运算不需要我多说了。
我们都知道一个规则，无论是在做矩阵乘法还是矩阵乘向量运算时，左边矩阵的列必须等于右边的行。说道这里也许你已经知道为什么了，因为右边的无论是矩阵还是向量，都是对左边矩阵中向量的组合方式。
2、矩阵乘法的理解 先来看看同济大学的《线性代数第六版》中是怎么写的。
乘积矩阵AB=C的(i,j)元Cij就是A的第i行与B的第j列的乘积。
也就是说：A是m*k的矩阵， B是k*n矩阵 那么C是m*p矩阵 对于每一项 Cij= 这种计算方式过于暴力而且不便于理解。
2.1向量的组合 上面我们已经谈到过矩阵乘向量时，向量就是对矩阵中每个向量的线性组合。那么我们在做矩阵乘以矩阵时也可以如此思考。
右边的矩阵同样是由多个向量组成，那么矩阵乘矩阵就是矩阵分别乘以多个不相干的向量。如下：
这样，我们再组合这些单独的向量，就变成了矩阵C。
谈到这里我们一直都在叙述，左边矩阵提供向量，右边矩阵提供组合方式的理解方法。其实我们反过来看也是行的同的。
我们可以认为，左边的矩阵提供组合方式，右边的矩阵提供向量。不过这个时候组合的不是列向量，而是行向量。
如下：
同样矩阵 矩阵
A*B=C 矩阵
我们可以认为，A和B由行向量，例如B的行向量就是 ....... 这时我们把左矩阵，也就是A矩阵中的每个行向量作为组合的方式：
....
c的每一个行向量都可以通过右矩阵的行向量组合的方式计算。
最后总结一下，我们认为矩阵相乘是矩阵中的向量进行线性组合。其中，一个矩阵作为向量组，一个矩阵作为组合方式。
共有两种方式组合：
1、右矩阵中的列向量作为组合方式，左矩阵的列向量作为向量组。
2、右矩阵中的行向量作为向量组，左矩阵的行向量作为组合方式。
2.2列向量*行向量 列向量 行向量 相信列向量乘行向量很好理解，只是需要注意一个特点，结果C矩阵中的每个列向量的方向都是相同的，同样所有行向量也是相同方向。这点很好证明，就不赘述了。
另外还有一个我现在还没有理解清楚的结论
C=A*B C等于A的各列与B的各行的乘积。例如：
这个计算方式我还不太理解，以后我再回来补，如果有人看到我的这个博客也可以评论我教教我，ヾ(o′▽`o)ノ°°谢啦。
2.3矩阵分块 矩阵是可以分块计算的，直接给出例子吧：
注意这里的A1或是B1不是指的单个数字，而是指的一块矩阵。也就是说我把A分成4块，B分成4块。
C1=A1*B1+A2+B3 我们把矩阵分块之后，矩阵依然可以把每一个块当做元素，遵循原来矩阵计算的规则。
也就是说，C矩阵的某一块等于矩阵A的分块行乘以矩阵B的分块列。
3、结语 矩阵乘法是我们理解矩阵的基础，更是重中之重。我们必须通过矩阵乘法来窥视矩阵的抽象意义，不然线性代数的学习是根本进行不下去的。下一篇线性代数我会写关于逆矩阵的问题，以及为什么矩阵可以解方程，也许你会看到和你平时不一样的理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a392b9a66f7ca0eccfda58eb99d5fbb/" rel="bookmark">
			论文复现之医学图像应用：视网膜血管分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文复现之医学图像应用：视网膜血管分割 0.导语 今日研究为继续上次论文中的一个内容：U-Net网络，于是找了一篇经典论文，并学习论文及代码解读。在学习U-Net网络后，使用U-Net神经网络提取视网膜纹理血管。
1.论文阅读 论文题目：U-Net Convolutional Networks for Biomedical Image Segmentation。
中文翻译为：用于生物医学图像分割的U-Net卷积网络。
1.1 摘要 之前，在训练一个深度网络需要大量已标注的训练样本。在这篇论文中，提出了一种网络和训练策略。为了更有效的使用标注数据，使用了数据扩张的方法。本片论文的网络分为两部分：收缩路径(contracting path)和扩张路径(expanding path)。
收缩路径主要用于捕捉上下文特征
扩展路径用于定位
该网络获得了赢得了ISBI cell tracking challenge 2015。不仅如此，这个网络非常的快，对一个512x512的图像，使用一块GPU只需要不到一秒的时间。
1.2 介绍 卷积神经网络的典型用途是分类任务，其中输出到图像是单个类别标签。 然而，在许多视觉任务中，尤其是在生物医学图像处理中，期望的输出应该包括定位，即：应该将类别标签分配给每个像素。 此外，在生物医学任务中，千量级的训练图像通常难以训练。 因此，Ciresan等人 在滑动窗口设置中训练网络，通过提供围绕该像素的局部区域（补丁）作为输入来预测每个像素的类别标签。
首先，这个网络可以局部化。 其次，补丁方面的训练数据远大于训练图像的数量。 由此产生的网络大幅度赢得了ISBI 2012的EM segmentation challenge。
显然，Ciresan等人的策略 有两个缺点。
首先，它非常慢。
因为网络必须分别为每个补丁运行，并且由于补丁重叠而导致大量冗余。
其次，需要在局部准确性 和 获取整体上下文信息之间取舍。
较大的补丁需要更多的最大池化层来降低局部准确性，而较小的补丁则使网络只能看到很少的上下文。 最近的方法提出了一个分类器输出，它考虑了来自多个层的特征。 良好的本地化和上下文的使用是可能的同时。
在这篇文章中，就建立了一个更加优雅的框架，通常被称为“全卷积网络”（FCN)。随后修改并拓展了这个框架，使其可以仅使用少量训练图片就可以工作，获得更高的分割准确率。网络架构如下图所示：
对FCN中的重要修改是：
上采样部分有大量的特征通道，它们允许网络将上下文信息传播到更高分辨率的层。
使得网络架构中扩张路径与收缩路径基本对称，并产生u形结构。
没有任何完全连接的层，分割图仅包含像素，对于该像素，输入图像中的完整上下文是可用的。
该策略允许通过重叠拼贴策略对任意大的图像进行无缝分割。 为了预测图像的边界区域中的像素，通过镜像输入图像来推断丢失的上下文。 这种平铺策略对于将网络应用于大图像很重要，否则分辨率将受到GPU内存的限制。
在上述谈了，使用少量数据做训练，在这篇论文中也使用了数据增强方法，对于这篇论文中的任务，论文中通过对可用的训练图像应用弹性变形来使用过多的数据增强。
这使得网络能够学习这种变形的不变性，而不需要在注释图像语料库中看到这些变换。 这在生物医学分割中特别重要，因为变形曾经是组织中最常见的变异，并且可以有效地模拟真实变形。 Dosovitskiy等人证明了学习不变性的数据增强在无监督特征学习的范围内的价值。
许多细胞分割任务中的另一个挑战是分离相同类别的触摸物体。
为此，论文中提出使用加权损失：触摸单元之间的分离背景标签在损失函数中获得大的权重。
1.3 网络架构 网络架构如上图所示：它由一条收缩路径（左侧）和一条扩展路径（右侧）组成。
【收缩路径】
收缩路径是典型的卷积网络架构。它的架构是一种重复结构，每次重复中都有2个卷积层和一个pooling层，卷积层中卷积核大小均为3x3，激活函数使用ReLU，两个卷积层之后是一个2x2的步长为2的最大池化层。每一次下采样后我们都把特征通道的数量加倍。
【扩张路径】
扩展路径中的每一步包括对特征映射先进行上采样，然后进行2x2卷积（“上卷积”）。该特征映射将特征通道的数量减半，与收缩路径中相应裁剪的特征拼接起来，以及两个3x3卷积，每个卷积都有一个ReLU。由于每个卷积中边界像素的丢失，裁剪是必要的。在最后一层，使用1x1卷积来将每个64通道特征图映射到特定深度的结果。
【卷积层总数】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a392b9a66f7ca0eccfda58eb99d5fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2b47e24a35c58ac3405c6ed1c74d65/" rel="bookmark">
			面试之-mybatis中$和#的区别*
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis中$和#的区别
mybatis中KaTeX parse error: Expected 'EOF', got '#' at position 2: 和#̲的区别 今天面试遇到这个面试题…，但是具体的区别还真的不清楚，今天总结一下分享给大家。
#{}是预编译处理，KaTeX parse error: Expected 'EOF', got '#' at position 20: …符串替换。mybatis在处理#̲{}时，会将sql中的#{}替…{}时，就是把${}替换成变量的值。使用#{}可以有效的防止SQL注入，提高系统安全性。
总结一
1 #是将传入的值当做字符串的形式，eg:select id,name,age from student where id =#{id},当前端把id值1，传入到后台的时候，就相当于 select id,name,age from student where id =‘1’.
2 是 将 传 入 的 数 据 直 接 显 示 生 成 s q l 语 句 ， e g : s e l e c t i d , n a m e , a g e f r o m s t u d e n t w h e r e i d = 是将传入的数据直接显示生成sql语句，eg:select id,name,age from student where id = 是将传入的数据直接显示生成sql语句，eg:selectid,name,agefromstudentwhereid={id},当前端把id值1，传入到后台的时候，就相当于 select id,name,age from student where id = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a2b47e24a35c58ac3405c6ed1c74d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc737942abf66dc96e1ced6ad6f25d8/" rel="bookmark">
			双字节乘法执行过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双字节两数相乘，其积为四字节。
（1）首先将积的存储单元清零。一般习惯按低地址单元存放数据高字节（大端模式）。
（2）各位相乘，错位带进位相加。
双字节乘法 要点：
（1）部分积求和时每一位求三个地址，本位，上位，上上位
（2）最后一次求和指针会落到高位地址的前一位，应该加1以修正
（3）积的每一位进行相加运算时保证低位先运算，因为要考虑到进位，所以进入子程序前先将指针调至本次部分积求和的最低位。积的存放地址不一定，故要根据情况分析数据低位的存放地址。
（4）程序读不懂时，写入keil中，观察内部RAM及各寄存器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b9feccacead9ac00312561d0a27d94/" rel="bookmark">
			十六进制转换为ASC码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单片机能够识别与处理的是二进制码，一位十六进制数在内存中的表现为四位二进制数。至于ASC码与BCD码，通俗来讲，前者是某个数字、字母、或符号的代码，固定且唯一，而后者则是二进制编码的十进制数。举个栗子，大写字母A的ASC码为41H，十六进制数0AH，表示为二进制位00001010B，表示为十进制则为10。
此时十六进制中的A与大写字母A并不是一个东西。此处补充一点，ASC码能表示的数字限于0~9。那么此时如何将一位十六进制数转换为相应的ASC码呢？
十六进制数0~9对应的ASCII码为30H~39H，字母A~F对应的ASCII码为41H~46H。
故数字0~9表示为ASCII码只需加上30H，便可得到相应的ASC码值，即可表示为ASCII码。对于A~F，以A举栗，0AH的二进制码为00001010B，加上37H（0011 0111B），便可得到41H（0100 0001B），而41H便为大写字母A的ASCII码值。
此时再来说为何要将好端端十六进制码转换为ASCII码？因为单片机能识别和处理的是二进制码，而输入/输出设备（如LED显示器、微型打印机等）则常使用ASCII码或BCD码。故需要进行此转换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42040c6ccefdde4d87a1712f9900cb9/" rel="bookmark">
			jsp中引入js、css时出现net::ERR_ABORTED 404 (Not Found)错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GET http://localhost:8080/static/My/Sub.js net::ERR_ABORTED 404 (Not Found) 出现此问题主要是引入的js、css不起作用。
路径引入
&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type="text/javascript" src="../static/My/Sub.js" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; 不起作用
(1)改为：
&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; %&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42040c6ccefdde4d87a1712f9900cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8314ab26b293440f5b1b39026c0d62b1/" rel="bookmark">
			python爬虫(爬取贴吧第一页，标题，作者，时间，链接，一楼内容只含文本信息)第一版(不用函数，不用类)，只能爬取指定网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import lxml.html import pymongo import requests ''' 1.爬取相应主题贴吧，解析出所有帖子(取帖子标题、作者、时间) 2.下载帖子详情页的1楼信息(只要文字，不要多媒体信息) 3.能够点击下一页进行翻页 4.将解析结果存入数据库(mongodb) ''' #连接mongodb数据库并创建tieba数据库和tiezi集合 client = pymongo.MongoClient(host='localhost', port=27017) db = client.tieba collection = db.tiezi #获取页面信息，并用xpath解析内容，通过页面分析可知道每一个帖子都是一个li response=requests.get('https://tieba.baidu.com/f?kw=lol&amp;ie=utf-8&amp;pn=0') parse_result=lxml.html.fromstring(response.text) tiezis=parse_result.xpath('//li[@class=" j_thread_list clearfix"]') #循环遍历取出内容，并拼接帖子url，进入帖子详情页面通过html分析获得一楼文本 for tiezi in tiezis: title=tiezi.xpath('.//a[@class="j_th_tit "]/text()')[0]#标题 author=tiezi.xpath('.//span[@data-field]/@title')[0]#作者 time=tiezi.xpath('.//span[@title="创建时间"]/text()')[0]#时间 lianjie='https://tieba.baidu.com'+tiezi.xpath('.//a[@class="j_th_tit "]/@href')[0]#作者连接 details = requests.get(lianjie) deta_html = lxml.html.fromstring(details.text) content = deta_html.xpath( '//div[@class="d_post_content_main d_post_content_firstfloor"]//div[starts-with(@id,"post_content_")]/text()')[0] # print(title) # print(author) # print(time) # print(lianjie) # print(content) #根据发帖人不同创建不同信息，然后导入数据库中 info=author info= { 'title': title, 'author': author, 'time': time, 'lianjie': lianjie, 'content': content } collection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8314ab26b293440f5b1b39026c0d62b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5479e889693dc672e8482bb9b6ef081a/" rel="bookmark">
			Flutter 页面之间传参— —pushNamed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pushNamed&lt;T extends Object&gt; method @optionalTypeArgs Future&lt;T&gt; pushNamed &lt;T extends Object&gt;(BuildContext context,String routeName, {Object arguments})
@optionalTypeArgs
Push a named route onto the navigator that most tightly encloses the given context.
The route name will be passed to that navigator's onGenerateRoute callback. The returned route will be pushed into the navigator.
The new route and the previous route (if any) are notified (see Route.didPush and Route.didChangeNext). If the Navigator has any Navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5479e889693dc672e8482bb9b6ef081a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f416d91496e460b67360173e7267b404/" rel="bookmark">
			数组中的k-diff 数对（给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.
示例 1:
输入: [3, 1, 4, 1, 5], k = 2
输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
示例 2:
输入:[1, 2, 3, 4, 5], k = 1
输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
示例 3:
输入: [1, 3, 1, 5, 4], k = 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f416d91496e460b67360173e7267b404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0becbbe93ebb79b6ce698c18119c56d4/" rel="bookmark">
			最近面试前端遇到的一些面试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数组从小到大排序有哪些方法？
利用数组Aarr.sort()排序 var arr = [45,3,12,4,8,25]; function compare(a,b){ return a-b; } arr.sort(compare); ==================================================================================== for遍历数组对比 var arr = [45,3,12,4,8,25]; var min; for(var i=0;i&lt;arr.length;i++){ for(var j=i;j&lt;arr.length;j++){ if(arr[i]&gt;arr[j]){ min=arr[j]; arr[j]=arr[i]; arr[i]=min; } } } console.table(arr); 2.一个关于闭包的题目
var name = 'Hello'; (function(){ if(name==undefined){ var name = 'Jack'; console.log('you are'+' '+name) }else{ console.log(name+'world'); } })() 这段代码最终输出是 you are Jack
在这我们聊聊闭包问题吧
闭包的概念：
我的理解是，闭包就是能够读取其他函数内部变量的函数。
优点：
1.保护函数内的变量安全,加强了封装性
2.在内存中维持一个变量(用的太多就变成了缺点，占内存)
缺点：
闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。
console.log("100"+2-"1") // number 1001 typeof (1+"5"); // string 15 typeof (1-"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0becbbe93ebb79b6ce698c18119c56d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce83a209f7041e64199378a479fd38e/" rel="bookmark">
			判断集合中是否存在重复元素/查找集合中所有的重复元素,并进行显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没写这种代码了,特此记录一下
需求 判断集合中是否存在重复元素(我项目中的一个实际需求),需求如下: { 1, 2, 3, 5, 4, 3, 7, 2, 0, 1, 3, 2, 0, 2 } ------&gt; 存在重复元素 { 1, 2, 3, 4, 5, 6}--------------------------------&gt; 不存在重复元素 查找集合中所有的重复元素,并进行显示(自己瞎写着玩的☺),需求如下: { 1, 2, 3, 5, 4, 3, 7, 2, 0, 1, 3, 2, 0, 2 } ------&gt; 查询结果为:{1=[0, 9], 2=[1, 7, 11, 13], 3=[2, 5, 10]} 代码 package com.nrsc.job; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class Demo { public static void main(String[] args) { int[] arr = { 1, 2, 3, 5, 4, 3, 7, 2, 0, 1, 3, 2, 0, 2 }; int[] arr1 = { 1, 2, 3, 4, 5, 6 }; // 判断集合中是否存在重复元素 Boolean flag = existRepeatedElements(arr); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce83a209f7041e64199378a479fd38e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/914007b40c9af2113344bfb9d7eae69e/" rel="bookmark">
			shell脚本练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、猜数字游戏 系统随机给出一个数，猜大小，
#!/bin/bash echo "可以输入q或者quit退出！" a=$[RANDOM%100+1] while : do read -p "请输入一个1-100之间的整数：" num i=`echo $num | sed 's/[0-9]//g'` if [ -z "$num" ];then echo '输入为空，请重新输入！' continue fi if [ $num == q ] || [ $num == quit ];then exit 2 fi if [ ! -z "$i" ];then echo "你输入的不是一个数字，请重新输入！" continue fi if [ $num -lt 0 ] || [ $num -gt 100 ];then echo "请输入1-100之间的整数！" continue fi if [ $num -lt $a ];then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/914007b40c9af2113344bfb9d7eae69e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a386972e71843bc15c21fbcb0c42599c/" rel="bookmark">
			语言_JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是JVM？ JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。
Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。
JRE/JDK/JVM是什么关系？ JRE(JavaRuntimeEnvironment，Java运行环境)，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。
JDK(Java Development Kit)是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。
JVM(JavaVirtualMachine，Java虚拟机)是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。
3. JVM原理
JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行java的字节码程序。
java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。
JVM执行程序的过程 加载.class文件 2) 管理并分配内存 3) 执行垃圾收集
JRE（java运行时环境）由JVM构造的java程序的运行环，也是Java程序运行的环境，但是他同时一个操作系统的一个应用程序一个进程，因此他也有他自己的运行的生命周期，也有自己的代码和数据空间。JVM在整个jdk中处于最底层，负责于操作系统的交互，用来屏蔽操作系统环境，提供一个完整的Java运行环境，因此也就虚拟计算机。操作系统装入JVM是通过jdk中Java.exe来完成，通过下面4步来完成JVM环境：1) 创建JVM装载环境和配置 2) 装载JVM.dll 3) 初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例4) 调用JNIEnv实例装载并处理class类。 JVM的生命周期 JVM实例对应了一个独立运行的java程序它是进程级别
a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void
main(String[] args)函数的class都可以作为JVM实例运行的起点
b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以表明自己创建的线程是守护线程
c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出
JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的
JVM的体系结构
类装载器（ClassLoader）（用来装载.class文件）
执行引擎（执行字节码，或者执行本地方法）
运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）
7. JVM运行时数据区
第一块：PC寄存器
PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。
第二块：JVM栈
JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。
第三块：堆（Heap）
它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。
（1） 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的
（2） Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配
（3） TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a386972e71843bc15c21fbcb0c42599c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ab9242d79a405d3bf3e3456f091866/" rel="bookmark">
			Android数据存储五种方式总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍Android平台进行数据存储的五大方式,分别如下: 1 使用SharedPreferences存储数据
2 文件存储数据 3 SQLite数据库存储数据
4 使用ContentProvider存储数据
5 网络存储数据
第一种： 使用SharedPreferences存储数据 SharedPreferencese的使用:https://blog.csdn.net/augfun/article/details/54563808
适用范围：保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口 令密码等。
核心原理：保存基于XML文件存储的key-value键值对数据，通常用来存储一些简单的配置信息。通过DDMS的File Explorer面板，展开文件浏览树,很明显SharedPreferences数据总是存储在/data/data/&lt;package name&gt;/shared_prefs目录下。SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。 SharedPreferences本身是一 个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例
class ViewOcl implements View.OnClickListener{ @Override public void onClick(View v) { switch(v.getId()){ case R.id.btnSet: //步骤1：获取输入值 String code = txtCode.getText().toString().trim(); //步骤2-1：创建一个SharedPreferences.Editor接口对象，lock表示要写入的XML文件名，MODE_WORLD_WRITEABLE写操作 SharedPreferences.Editor editor = getSharedPreferences("lock", MODE_WORLD_WRITEABLE).edit(); //步骤2-2：将获取过来的值放入文件 editor.putString("code", code); //步骤3：提交 editor.commit(); Toast.makeText(getApplicationContext(), "口令设置成功", Toast.LENGTH_LONG).show(); break; case R.id.btnGet: //步骤1：创建一个SharedPreferences接口对象 SharedPreferences read = getSharedPreferences("lock", MODE_WORLD_READABLE); //步骤2：获取文件中的值 String value = read.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ab9242d79a405d3bf3e3456f091866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d5a89a93d2a4c33f8a99e73f261f8c/" rel="bookmark">
			LaTeX中argmin / argmax下标书写方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		符号代码 arg ⁡ min ⁡ θ \mathop{\arg\min}\limits_{\theta} θargmin​$\mathop{\arg\min}\limits_{\theta}$ arg ⁡ max ⁡ θ \mathop{\arg\max}\limits_{\theta} θargmax​$\mathop{\arg\max}\limits_{\theta}$ 举个栗子：
w ∗ = arg ⁡ min ⁡ w ∑ i L ( y i , f ( x i ; w ) ) + λ Ω ( ω ) w^*=\mathop{\arg\min}\limits_{w}\sum_iL(y_i,f(x_i;w))+\lambda\Omega(\omega) w∗=wargmin​i∑​L(yi​,f(xi​;w))+λΩ(ω)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd79adbabe8f9b6604c14af230684b95/" rel="bookmark">
			Zabbix - 添加自定义监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用shell，python等
1. 创建通过输出传递结果值。
1.1 监控脚本
1.1.1 echo / print
vim test_count_echo.sh
---------------------------------------------------------------------------
PSQL=/usr/local/pgsql/bin/psql
DBNAME=$1
result=`$PSQL -U dbadmin -d $DBNAME -Aqt -c "select count(*) from test01;"`
echo $result
---------------------------------------------------------------------------
1.2. 配置文件
# cd /etc/zabbix/zabbix_agentd.d
# vim userparameter_test.conf
UserParameter=test_echo.get.count[*],/data/zabbix_scripts/test_count_echo.sh "$1"
修改之后要重启
# service zabbix-agent restart
测试
# zabbix_get -s 192.168.3.51 -p10050 -k"test_echo.get.count[db1]"
3
1.3. 添加监控项
可以将监控项添加至普通的item或Discovery中的item。
添加至Dsicovery中 Item prototypes
Name: [{#DBNAME}] test_count
Key: test_echo.get.count[{#DBNAME}]
Applications: 可选存在的或新建
2. 通过zabbix_sender发送结果值，可以包含多个信息。
这个通过pg_monz中的自动发现数据库名称列表来做实验。
2.1 监控脚本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd79adbabe8f9b6604c14af230684b95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a6c2de301d99d802811c4826f57b48d/" rel="bookmark">
			带分销小程序商城源码，完整代码分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 源码免费下载地址：https://github.crmeb.net/u/gitee **技术交流群：**116279623 包含功能： 1.商品: 能够对商品的状态分类管理 (出售中、待上架、库存中、已售馨、库存警戒、回收站)、添加产品、添加商品分类等功能
2.会员:站内会员的管理 (发放优惠劵、发通知、发图文消息、增加余额、会员行为详情)、站内通知 、微信端用户管理 (微信用 户的管理、分组、行为观察、添加标签) 等功能
3.营销:能够管理优惠的发放和制作、用户积分的统计使用情况、秒杀产品的管理等
4.财务:能够对用户的消费、充值、返佣的记录
5.订单:能够完成用户的订单管理(发货、订单详情、修改订单、订单备注、订单记录、订单退款) 、售后服务 (评论的回复与删除)
6.分销:后台有分销统计管理，分销可以设置人人分销和指定人分销，也可以自己稍微开发一下修改规则，例如下单后成为分销等
7.数据统计图表统计分析(财务统计、产品统计、会员统计、营销统计、分销统计、交易统计等)
8.设置:能够完成管理员对网站的商品资料（添加大类、添加小类、商品添加、属性快速生成、商品审查）、商品交易（外理订单、发 货查询）、会员管理（会员审查）、操作管理（管理员添加、管理员审查、管理员退出）、系统配置、后台通知等功能
9.内容:管理文章分类 (添加分类、删除分类、修改分类) 、 管理文章
10.维护:查看系统日志、文件变动效验、刷新网站缓存、在线更新系统、清除数据、文件管理等功能
11.强大的权限管理系统
演示后台： 演示后台：http://demo25.crmeb.net
**账号：**demo
**密码：**crmeb.com
演示前台： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a370ee287e2ed9bbfa548334202f6a/" rel="bookmark">
			无缝拼接文件 copy/b 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频拼接的好办法 一. 拼接视频二.打造隐藏文字图片三.加密 腾讯视频的下载是分段的。记得当时用手机缓存下来的，想在电脑上播放。后来发现好多文件，每一个文件是播放的一部分。。。。。竟然做出这样的事。太令人失望了。我还非要给他合起来。啥也不懂的我用格式工厂一点一点的拼接，非常慢。
今天偶然看到，copy/b 命令，令我眼前一亮，这就是当年需要的东西。要记下来。
一. 拼接视频 举个例子，我现在有以下文件
14sd55sd4f8s5dfs85df5sdf55sdf5dsf5sdf5sd.000.tdl
14sd55sd4f8s5dfs85df5sdf55sdf5dsf5sdf5sd.001.tdl
14sd55sd4f8s5dfs85df5sdf55sdf5dsf5sdf5sd.002.tdl
14sd55sd4f8s5dfs85df5sdf55sdf5dsf5sdf5sd.003.tdl
14sd55sd4f8s5dfs85df5sdf55sdf5dsf5sdf5sd.004.tdl
14sd55sd4f8s5dfs85df5sdf55sdf5dsf5sdf5sd.005.tdl
记下他的路径，打开 cmd
cd 路径 //CD 显示当前目录的名称或将其更改。
copy/b 14s.tdl 新名字.mp4* //即可复制出一个文件
二.打造隐藏文字图片 （1）无缝拼接任何文件，拼接*.txt和*.jif合成*.jif。
（2）记事本打开，乱码之后是隐藏文字。
（3）看图软件打开，只有图片，没有文字。
（4) 这里可以使用这个命令 copy/b 文件名1+文件名 合并后的文件名
小提示：其中参数/前指定以二进制格式复制、合并文件;参数/后指定以ASCII格式复制、合并文件。这里要注意文件的顺序，二进制格式的文件应放在加号前，文本格式的文件放在加号后。有一点要提醒大家:就是这个文本文件的前面最好至少空3行，这样它头部的内容就不易丢失。
三.加密 隐藏一些敏感文件，不过分离我不会。。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b52591d3cdcb0f3066d1a197ad866b/" rel="bookmark">
			ECS方式实现帧同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00. 引言 ECS是Entity-Component-System（实体-组件-系统） 的缩写，是一种非常好用的框架思想，可以提高代码复用率，游戏逻辑开发中使用这种组合由于继承的方式可以很大程度上简化复杂度，而且在性能上也是有很大提升的。Entiy是一个包含唯一ID的容器对象，在Entity内部可以绑定很多Component，每个Component只负责存储数据，正是因为Component的功能单一性，它可以很方便的做数据快照。System内部负责操作Component数据，从而最终作用于Entity。 帧同步的应用场景很多， （帧同步与状态同步的区别，感谢知乎作者云影）从格斗游戏，Rts，到现在的几乎所有Moba类游戏，他们各自的实现方式细节各不相同，帧同步对不同类型的游戏也有各种变种。列举一下例子，如格斗游戏，由于参与角色不多，玩家对角色操作反馈及时性要求很高，因此这种帧同步需要有预测能力，在预测对方玩家行为之后还需要有回退矫正的能力。有预测能力意味着操作反馈会很流畅，也是由于角色不多，出现预测错误的几率也不多回退矫正造成的视觉影响也不会很大，因此格斗游戏的帧同步就要采用这种方式定制。再比如魔兽争霸游戏，这种早期局域网环境下的对局方式，网络的环境比较好，各个客户端采用的是锁帧方式的帧同步，如果其中一个客户端出现小延迟情况，客户端自己会迅速根据关键帧标记跟上服务器的步伐，如果出现大延迟甚至断线，那么所有的客户端需要一起暂停等待，因此这种方式对于多控制单位的游戏类型很好用也很简单。 0x01.开始结合 准备将帧同步与ECS合起来工作，帧同步逻辑实现的第一步是要将逻辑和显示彻底的分离，可以把很多逻辑放到线程里去，这点也是ECS可以带来的便利。 首先需要实现一个模拟器，这部分的代码功能主要是实现一个stopwatch的机制，在线程中使用stopwatch记录时间流逝，在设定逻辑帧帧率参数一致下同时启动模拟器保证在经过相同的一段时间内所有的模拟器执行的帧数一样。模拟器还需要有添加行为的功能，各种行为以互相排列组合的方式共同协助模拟器完成整个模拟过程， 下图可以看到一个模拟器中每一帧需要依次执行下列几个模块。 #逻辑帧记录：主要负责记录当前的逻辑帧编号； #网络数据回滚：负责收取服务器广播的带帧编号的网络数据，这部分也是帧同步的核心，收到的逻辑帧数据需要和本地的数据进行回滚并向后继续演算，并且记录下操作以便播放战报； #实体操作：在这里会是所有ECS中System的执行入口，如MoveSystem等； #用户输入：完成监听并记录用户操作，用于最后一步的请求同步； #数据备份：对当前帧的所有数据进行快照保存，以便用户回滚； #请求同步：将操作发送给服务器； 整个顺序过程会在一个逻辑帧内执行，因为上述所有逻辑都放置与线程中执行，所以在显示方面和这部分逻辑是没有调用关系的，因此需要在主线程中对于当前的数据做出响应，这就是一个数据驱动显示的过程。这样做的好处有很多，首先就是逻辑显示分离后服务器也可以执行逻辑代码进行验证，其次线程里执行的逻辑运算功能可以分担主线程压力。 上述的模块还可以继续扩展，比如可以在用户输入模块后继续加上AI输入模块，在实体操作模块中添加子系统，子系统以ECS中的System形式出现，负责根据需求改变数据。 关于ECS的实现可以有很多种，具体情况因地制宜，当然也可以自己DIY一下。我在这里把ECS扩展成ECSR，多出来的R表示Render，Render会根据Component数据内容用于主线程画面的表现。 0x02. 扩展一下 上述完成了对帧同步模拟过程，还有一项帧同步特有的功能就是战报回放，这是状态同步开发下无论如何也完成不了的。战报回放的replay文件可以以不同速率完整的模拟出整个帧同步过程，这依赖于逻辑帧命令的记录和保存。同样是用模拟器去完成只是在模拟器中添加不同的模块。 #逻辑帧记录：这里和上述的稍作改变，作用相似，也是记录逻辑帧编号； #实体操作：同上 #回放输入：根据回放的replay文件，读取逻辑帧命令； 0x03. GIF效果展示 效果展示为多用户移动命令下的帧同步效果。 0x04. 后续 关于帧同步的网络通信方面的选择，最好还是使用UDP方式，采用发送冗余信息，外加丢帧请求的方式。我这里为了简单实现同步的过程采用的是TCP方式。后续的修改应该是往UDP方式改进。 另外帧同步中的数学运算官方提供了 Unity.Mathematics数学库 。 项目地址 https://github.com/dudu502/LittleBee.git 转载于:https://www.cnblogs.com/monkeycoder/p/10414132.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9b73c401b322f5adb2a32e83faf253/" rel="bookmark">
			Android系统和关键进程的的启动过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Android虚拟机
1.1 dalvik虚拟机
1.2 Dalvik虚拟机与JVM比较
1.3 进程管理
1.4 init进程
1.5 Xposed
1.6 init.rc
1.7 android关键服务的启动
1.7.1 ServiceManager
1.7.2 Zygote
1.7.2.1 zygote的名字由来
1.7.2.2 AndroidRuntime
1.7.3 SystemServer的启动
1.8 android相关服务和应用启动过程图
1、Android虚拟机 1.1 dalvik虚拟机 Google于2007年底正式发布了Android SDK, 作为 Android系统的重要部分，Dalvik虚拟机问世。每一个Android应用在底层都对应一个独立的Dalvik虚拟机实例， 应用代码在虚拟机中解释执行。
因为Android使用的编程语言是java，让很多人误以为 Dalvik虚拟机就是JVM，这种说法不正确，因为Dalvik虚拟机不是按照JVM规范来实现的，而且两者不兼容；
1.2 Dalvik虚拟机与JVM比较 Dalvik虚拟机JVM dalvik虚拟机是基于寄存器JVM基于栈，必须使用指令来载入和操作栈上数据，所需指令更多 Dalvik运行的是自定义的.dex字节码格式。java类被编译成.class文件后，然后通过dx工具将.class文件转换成.dex文件，Dalvik虚拟机运行的是dex文件JVM运行的是字节码，java类文件在javac后会被编译成class文件，打包到.jar文件中，JVM从相应的.class文件和.jar文件中获取相应的字节码 在Dalvik虚拟机中，常量池被修改为只使用32位的索引，简化了解释器，Dalvik的堆和栈的参数可以通过-Xms和-Xmx更改 一个应用对应一个进程，一个Dalvik虚拟机实例，android应用都运行在自己的沙盒中，不同的应用在不同的进程中运行，对应一个Dalvik虚拟机实例，每个应用程序都被赋予了一个独立的PID，可类似Linux的 pid 1.3 进程管理 Dalvik进程管理是基于Linux的体系结构的，如果要为应用程序创建一个进程，会fork一个进程效率更高。
Zygote是虚拟机的一个进程，而且是虚拟机实例的孵化器，它通过init进程来启动，每当系统要求执行一个android应用程序时，Zygote就fork出一个子进程来作为该应用的进程。
1.4 init进程 init进程它是一个由内核启动的用户级进程，也是是Linux内核启动的第一个进程，由内核自行启动。
启动过程就是代码init.c中main函数执行过程：system\core\init\init.c
main函数中会进行一下初始化操作：文件夹建立、挂载、rc文件解析、属性设置、各项服务的启动、动作的执行、Socket的监听等
如下面是一段源码：
int main(int argc, char **argv) { int fd_count = 0; struct pollfd ufds[4]; char *tmpdev; char* debuggable; char tmp[32]; int property_set_fd_init = 0; int signal_fd_init = 0; int keychord_fd_init = 0; bool is_charger = false; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9b73c401b322f5adb2a32e83faf253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3df7826057ba1ffde91a5a00b36a3e/" rel="bookmark">
			Java蓝桥杯试题集——算法训练ALGO-95——2的次幂表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求 解题思路 这道题使用递归，change函数传入int型数字，先转乘二进制，然后循环判断各位是否是1，如果是，进入switch，除了2，1，0三个幂次的，直接输出，其他的用2（）包起来进入循环。
这里输出 + 的时候要注意，设置一个flag = 0， 如果是第一个，则不在前面输出 + ，否则在数前先输出 + 。这样就能保证加号的正确啦~
import java.util.Scanner; public class Main { public static void main(String[] args) { // TODO Auto-generated method stub Scanner in = new Scanner(System.in); int n = in.nextInt(); change(n); } public static String change (int x) { char[] binary = Integer.toBinaryString(x).toCharArray();	// 转成二进制 int flag = 0;	// 判断是否是第一个 //	判断位数 for (int i = 0; i &lt; binary.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c3df7826057ba1ffde91a5a00b36a3e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/240/">«</a>
	<span class="pagination__item pagination__item--current">241/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/242/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>