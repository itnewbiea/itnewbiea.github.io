<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d063c254f6861be0ec4d4c2b7487bbe/" rel="bookmark">
			js websocket onClose 回调问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、websocket 调用close 方法后，onclose 事件不会马上触发，大概10S 左右才会触发，有时主动调用close 方法 后就不需要触发onclose 事件，可以设置onclose 事件为undefined。
ws.onclose = undefined; 或者如果用 addEventListener 注册的事件，可以使用removeEventListener 移除相关事件。
2、怎么判断onclose 事件是哪个websocket 触发的，可以在onclose 里面拿到currentTarget 对象进行比较。
ws.onclose = function (e) { if(e.currentTarget == ws) { ..... ..... } } 至于onclose 超时时间，好像并没有找到相关方法可以设置，有朋友知道的麻烦告诉一声。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aedca00e49d8971e3c2f97eae13d1fb/" rel="bookmark">
			人工智能截稿日期重磅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ICIGP
全称
International Conference on Image and Graphics Processing
举办信息
Sanya, China
January 1-2, 2021
已截稿
官方网址
http://icigp.org/cfp.html
网络补充信息
汇集学术界和工业界的研究人员，促进图形处理相关领域的技术和教育合作活动
ICPR
全称
International Conference on Pattern Recognition
举办信息
线上召开
January 10-15, 2021
已截稿
官方网址
http://icpr2020.com/
备注
两年一次，本届实为2020年推迟召开的会议
AAAI
全称
AAAI Conference on Artificial Intelligence
举办信息
线上召开
February 2-9, 2021
已截稿
官方网址
https://aaai.org/Conferences/AAAI-21/
网络补充信息
人工智能领域顶级会议，每年一届
PAKDD
全称
The Pacific-Asia Conference on Knowledge Discovery and Data Mining
举办信息
Delhi, India
May 11-14, 2021
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aedca00e49d8971e3c2f97eae13d1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3cfb2bfaf4817a5abf5fb4d5a19f58/" rel="bookmark">
			在 Python 中创建物理模拟和可微分图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 NVIDIA Warp 在 Python 中创建可微分图形和物理模拟 通常，为获得最佳性能, 实时物理模拟代码是用底层的 CUDA C++ 编写的。 在这篇文章中，我们介绍了 NVIDIA Warp，这是一个新的 Python 框架，可以轻松地在 Python 中编写可微分图形和模拟 GPU 代码。 Warp 提供了编写高性能模拟代码所需的构建块，但具有使用 Python 等解释语言工作的生产力。
在这篇文章的最后，您将学习如何使用 Warp 在 Python 环境中编写 CUDA 内核，并利用一些内置的高级功能可以轻松编写复杂的物理模拟，例如海洋模拟 （下图）。
安装 Warp 是 GitHub 上的一个开源库。
下载地址:
https://github.com/NVIDIA/warp
要下载发布包并安装到本地 Python 环境中，请按照 README 说明并使用以下命令：
pip install . 初始化 导入后，必须显式初始化 Warp：
import warp as wp wp.init() 启动内核 Warp 使用 Python 装饰器的概念来标记可以在 GPU 上执行的函数。 例如，您可以编写一个简单的半隐式粒子积分方案，如下所示：
@wp.kernel def integrate(x: wp.array(dtype=wp.vec3), v: wp.array(dtype=wp.vec3), f: wp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e3cfb2bfaf4817a5abf5fb4d5a19f58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae5d0ed0ab8285e9f22dba39a97de513/" rel="bookmark">
			关于37%法则的探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言
一、37%法则是什么？
1.故事导入
2.问题提出
3.问题抽象
4.问题解答
二、用python代码模拟
1.设计思路
2.生成随机数列表
3.模拟挑选过程
3.输出结果
4.开始执行
三、生成的随机列表问题
1.问题发现
2.其他随机列表的生成方式
3.列表元素偏态与均匀分布的探究
四、关于37%法则的更多细节
1.什么情况？
2.何为最优解？
总结
前言 数学家欧拉发现了37%这个分界点，与大众来说应该毫无关系。可是现在越来越多人鼓吹用37%法则来进行选择，他们以为这是科学决策，其实只是对另一种未知事物的信仰。
我不否定37%法则的存在，也不推崇37%法则的运用。我只想通过这篇文章提高大众对37%法则的理解。
一、37%法则是什么？ 1.故事导入 苏格拉底的3个弟子曾求教老师，怎样才能找到理想的伴侣。于是苏格拉底带领弟子们来到一片麦田，让他们每人在麦田中选摘一支最大的麦穗，要求是不能走回头路且只能摘一支。
第一个弟子刚刚走了几步便迫不及待地摘了一支自认为是最大的麦穗，结果发现后面的大麦穗多的是。
第二个弟子一直在寻找最大的麦穗，直到终点才发现前面最大的麦穗已经错过了。
第三个弟子把麦田分为三段，走过第一段麦田时，只观察，在心中把麦穗分为大、中、小三类；走过第二段时，还是只观察，验证第一段的判断是否正确；走到第三段，也就是最后三分之一时，摘下第一支他遇到的属于“大”类中的麦穗，然后走到终点。
故事来源点这里
2.问题提出 有一个列表，由n个随机分布的数字组成。从第一个数字开始，依次查看列表中的数字，并记录其大小。挑选一个正在查看的数字，已查看过的数字不能挑选。挑选完毕即停止查看列表数字。从什么时候挑选才能最大概率的挑中列表中的最大值？
3.问题抽象 可以建立一个挑选模型，分为观察阶段和选择阶段。
观察阶段：依次查看列表中前k个数字，并记录其大小，留意其中的最大值。
选择阶段：将前k个数字中的最大值与正在查看的数字作比较，如果遇到比它更大的数字就选择它。
这样，只需要求解出k为何值时，挑选出最大数字的概率最大，就可以知道答案了。
4.问题解答 对于某个固定的 k，如果最适合的数字出现在了第 i 个位置，此时挑选出最大值的概率记作P(k)。计算公式如下： 其中1/n是最适合的数字出现在第i个位置的概率，k/(i-1)表示k到i之间的数字比前k个数字都小的概率。只有满足上述两个条件才能挑出适合的数，因此这两个概率相乘。只有i&gt;k，才有可能在第k个数字之后挑选出最大的数字。将i出现在k到n的情况进行概率累加，就是参考位置为k时挑选最适合数字的概率。
用 x 来表示 k/n 的值，并且假设 n 充分大，则上述公式可以写成：
对 -x · ln x 求导，并令这个导数为 0，可以解出 x 的最优值—— 1/e 。
1/e 大约等于 0.37（e ≈2.718281828459）。因此列表前37%的数字作为参考，如果遇到比这些数字还大的，就选择它。这样挑选出最大数字的概率最大。
二、用python代码模拟 1.设计思路 通过python代码，我们可以模拟非常非常多次决策过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae5d0ed0ab8285e9f22dba39a97de513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65596101b5a34e5d80f2ec5a349d28c5/" rel="bookmark">
			netty源码之Channel：注重NioServerSockerChannel和NioSocketChannel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		netty源码之Channel：注重NioServerSockerChannel和NioSocketChannel 类结构展示1、NioServerSockerChannel的类结构：2、NioSocketChannel的类结构： 顶层接口Channel骨架类AbstractChannel1、属性2、构造方法3、实现方法 NIO骨架类AbstractNioChannel1、新增的属性2、构造方法3、实例方法doRegister()方法doBeginRead()方法 AbstractNioMessageChannel1、newUnsafe()2、doWrite(ChannelOutboundBuffer in)方法 AbstractNioByteChannel1、newUnsafe()方法2、doWrite(ChannelOutboundBuffer in)方法3、clearOpWrite()方法4、doWriteInternal(ChannelOutboundBuffer in, Object msg)5、incompleteWrite(boolean setOpWrite)方法 NioServerSocketChannel1、构造方法2、doBind(SocketAddress localAddress)方法3、doReadMessages(List buf)方法 NioSocketChannel1、构造方法2、doBind(SocketAddress localAddress)方法3、doConnect(SocketAddress remoteAddress, SocketAddress localAddress)方法4、doWrite(ChannelOutboundBuffer in)方法 类结构展示 1、NioServerSockerChannel的类结构： 2、NioSocketChannel的类结构： 顶层接口Channel Channel接口中还包含了另一个顶层接口Unsafe，其实这个Unsafe才是承受了最多的脏活累活的家伙。
id()方法返回Channel实例的id。
eventLoop()方法返回给Channel实例关联的EventLoop实例。
parent()方法返回该Channel的父Channel，服务端才有。
unsafe()方法返回该Channel使用的Unsafe实例。
pipeline()方法返回该Channel关联的ChannelPipeline实例。
alloc()方法返回该Channel的内存分配器ByteBufAllocator实例。
read()和flush()是两个出站方法，会调用pipeline的出站方法。
骨架类AbstractChannel 1、属性 定义了netty网络通信的基本属性。
2、构造方法 id是netty提供了一个实现算法。
unsafe是一个钩子方法，执行时调用子类实现方法。
pipeline是new了一个DefaultChannelPipeline。注意，这里实例化DefaultChannelPipeline的时候就会创建HeadContext和TailContext。
3、实现方法 实现了诸如上面的一些网络通信方法，但是只是单纯调用了pipeline的对应方法。
此外，还定义了一批抽象方法，让子类去具体实现。
NIO骨架类AbstractNioChannel 1、新增的属性 新增了网络通信中NIO模式使用的对象，selector用到的一些东西。
SelectableChannel，这个玩意是java提供的，代码中看到的javaChannel()方法返回的就是这个玩意，类比于NIO编程中的ServerSocketChannel和SocketChannel。
2、构造方法 调用父类实例化unsafe和pipline。
赋值SelectableChannel，构造方法传入。
赋值感兴趣的操作readInterestOp，构造方法传入。
设置SelectableChannel为非阻塞模式，类比于NIO设置ServerSockerChannle启动时设置非阻塞模式。
3、实例方法 doRegister()方法 做的事情也很简单，将channel注册到selector上，但是注册的事件是一个0，以为着不关注任何事件。
doBeginRead()方法 检查当前channel的selectionKey，并将构造函数传进来的readInterestOp事件类型添加到其中，表示该channel开始关注readInterestOp事件。
AbstractNioMessageChannel 1、newUnsafe() 负责自己及其子类的unsafe实例化。NioMessageUnsafe的实例。
2、doWrite(ChannelOutboundBuffer in)方法 在一个死循环中进行写操作，具体的操作在一个抽象方法中，由具体的子类实现，如果发现ChannelOutboundBuffer中的内容已经全部写完，则取消对写事件的关注。如果在写数据的时候发现缓冲区满了写不进去，就继续关注写事件。
AbstractNioByteChannel 1、newUnsafe()方法 负责自己及其子类的unsafe实例化。NioByteUnsafe的实例。
2、doWrite(ChannelOutboundBuffer in)方法 首先获取一次性默认写次数限制writeSpinCount，默认值是16，表示该线程在这次写任务中最多写16次，到了16次还没有写完的化，也会释放线程的控制权，将剩余的写需求封装成任务入队列。这样设计的目的是防止有大文件的操作一直占用io线程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65596101b5a34e5d80f2ec5a349d28c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e00eaa7422c9e8bd251a227dd9b66b/" rel="bookmark">
			uniapp中sqlite数据库常用操作的简单封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考HTML5联盟
SQLite模块用于操作本地数据库文件，可实现数据库文件的创建，执行SQL语句等功能。
// 监听数据是否打开 function isOpenDB(name, path = "") { let dbName = name; let dbPath = path || `_doc/${name}.db`; //数据库打开了就返回true,否则返回false let isopen = plus.sqlite.isOpenDatabase({ name: dbName, path: dbPath }) return isopen } // 创建数据库/打开数据库 function openDB(name, path = "") { return new Promise((resolve, reject) =&gt; { plus.sqlite.openDatabase({ name: name || 'test', path: path || `_doc/${name}.db`, success: async function(res) { let a = await closeDB(name) resolve('success!') }, fail: async (e) =&gt;{ let a = await closeDB(name) console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95e00eaa7422c9e8bd251a227dd9b66b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b840ef63f72a35d206d07bed8fe378/" rel="bookmark">
			机器视觉——相机标定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 机器视觉为什么要做相机标定 机器视觉是采用相机成像来实现对三维场景的测量、定位、重建等过程。是一个利用二维图像进行三维反推的过程，我们所处的世界是三维的，而图像或者照片是二维的，可以把相机认为是一个函数，输入量是一个三维场景，输出量是一幅二维图像。正常来说，这个从三维到二维的过程是不可逆的。
如果我们能够找到一个合适的数学模型，来近似以上这个三维到二维的过程，然后找到这个数学模型的反函数，就可以实现二维到三维的的反过程，即：用简单的数学模型来表达复杂的成像过程，并且求出成像的反过程。
在前几篇文章《机器视觉模型——投影矩阵》以及《机器视觉模型——畸变模型》中，我们讨论了机器视觉的两个重要数学模型——投影成像模型和畸变模型，我们知道，这几个模型中都包含了若干个未知参数。那么这些未知参数如何获得？这就是相机标定的作用了。
2 相机标定的作用 如前所述，成像矩阵及畸变模型中包含了以下几个未知数：
内参矩阵：4个参数， f / d x f/dx f/dx、 f / d y f/dy f/dy、 u 0 u_0 u0​、 v 0 v_0 v0​；外参矩阵：6个参数，相机刚体的位姿，平移和旋转各3个参数。畸变参数：5个参数，径向畸变3个 k 1 k_1 k1​、 k 2 k_2 k2​、 k 3 k_3 k3​，切向畸变2个 p 1 p_1 p1​、 p 2 p_2 p2​； 相机标定：就是确定相机的内外参数、畸变参数的过程。
相机标定可以说是计算机视觉/机器视觉的基础，任务就是通过具有对应关系的像点和物点的点对，来解出模型的9个（内参+畸变）或15个（内参+畸变+外参）未知参数。 大多数相机标定都是为了标定出相机内参和畸变参数，因为外参属于相机位姿，工作过程中相机位姿是不断变化的，但有些应用，也需要同时标定出外参，即相机位姿。
3 相机标定常用方法 根据标定过程的数学模型，相机标定可以分为：
(1) 线性标定法：运算速度快，标定精度相对不高
(2) 非线性优化标定法：标定精度高，模型复杂，计算量大；
(3) 两步法：以上两者的结合，综合了两者的优缺点，如Tsai两步法、张氏标定法等。
下表给出了几类常用标定方法的对比。
标定方法优点缺点常见方法相机自标定法灵活性强、可在线标定精度低、鲁棒性差分层逐步标定、基于Kruppa方程主动视觉相机标定法不需要标定物、算法简单、鲁棒性高成本高、设备昂贵主动系统控制相机做特定运动标定物标定法可使用于任意的相机模型、 精度高需要标定物、算法复杂Tsai两步法、张氏标定法 3.1 相机自标定法 相机自标定方法并不需要知道图像点的三维坐标，它通过计算某一点在不同拍摄角度的场景图中的相对关系来确定相机标定的参数问题。自标定法的这种特性，使得它能够完成一些未知相机参数的标定。
摄像机自标定方法仅仅利用图像点之间的对应关系或约束关系而不需要标定物就可以得出标定系统的内外参数，这就使得在一些相机任意运动或者复杂未知场景下的相机标定成为现实，这得益于20世纪90年代初，Luong, Faugeras, Maybank等首先提出的自标定概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6b840ef63f72a35d206d07bed8fe378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33ad8489e2e5f4977ce9a9532517a4a/" rel="bookmark">
			面试了一位7年软件测试工作者：成也“7”年，败也“7”年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在众多面试中，对于那个工作了7年的面试者，我印象很深刻，因为最开始拿到简历的时候，我一摸:"这简历，好厚啊！"再一看，工作7年。
于是我去找了我的领导，我说:“这人我应该没法面试，我工作经验都没他一半高啊。咋面？”
领导说:“没事，你先去聊聊，怕什么，就当是技术交流，别当成面试。”
面试的过程中我们聊的技术问题，他都没有回答的很好，他的技能就像一块大平板，一眼望去，什么都会一点，但是稍微一深入探讨，就两眼一抹黑了。
面试的最后，我直接给他说:“在整个面试的过程中，其实你有些问题回答的是不太好的，可能今天我们的面试就到这里了，但是我还想请问你一个问题，你可以不回答。你工作了7年了，应该有很多行业内的朋友呀，为什么没有内推呢？而且你的技术能力和你的工作年限有点不太匹配。”
他回答了我，大概的意思是这样的：
我刚参加工作的时候，计算机行业还没那么火，大多数都是传统公司，所以我一直就在传统行业里面，属于比较内向的人，也没有刻意的去积累人脉。期间换了几家公司，没有一家是真正意义上的互联网科技公司，我也一直是做开发工作。最后的这家公司是把我辞退了，辞退之前，我还是一个底层的老员工。但是我努力想往管理岗发展，但是最终不得人意。由于最近几年一直想往管理方向发展，更多的是注重业务了，家庭方面的事情也越来越多，有时会影响工作。技术方面就有点停滞不前了。最终导致这样的局面。 听了之后，我说：
你是我的前辈，我很尊重你，但是我从我的角度再加上你刚刚的面试表现来说，你说的这是一部分原因，而且不是主要原因。我觉得主要原因是，对于技术你失去了追寻的态度。在过去的这几年里面，你只要对于每次碰到的问题，稍微深入地研究一下，思考一下，整理一下，然后再找一项技能深挖下去，日积月累下来，今天的结果应该会大不一样。我理解你，也许是在家庭和工作的双重压力下，迷失了方向。 后来，我把他送到公司门口，他已经走出去了，又转过身来和我握了一下手，他握的很用力，说:“谢谢！”
我在面试结果描述那一栏写的是:
此人专业技能与工作年限不匹配。不建议进入下一轮面试。
面试结束之后，我把面试结果反馈给我的领导，领导看到我写的评语，意味深长的一笑，对我说:“和我预想的一样，年龄大，工作年限长，但是技术一般”。
之后，他用力握我手的场景有时候会不由自主的在我脑海里面浮现。
仿佛在鞭策我：前车之鉴，要警惕啊。
做为一名测试人，我想分享一下这些年来，我对于技术一些归纳和总结，和自己对作为一名高级自动化测试需要掌握那些技能的笔记分享，希望能帮助到有心在技术这条道路上一路走到底的朋友！
内容涉及：测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等
作为一位过来人也是希望你们少走一些弯路，在这里我给大家分享一些进阶自动化测试的路线资源，希望帮你们更好的突破自己
1.自动化测试必备Python编程内容 2.Web UI 自动化测试基础内容 3.Web UI 自动化测试实战内容 4.APP UI 自动化测试基础内容 5.APP UI 自动化测试实战内容 6.API 接口自动化测试基础内容 7.API 接口自动化测试实战内容 8.CI/CD持续集成专项技术 9.自动化测试框架实战技术 上面就是我为大家整理出来的一份软件测试工程师发展方向知识架构体系图。希望大家能照着这个体系，完成这样一个体系的构建。可以说，这个过程会让你痛不欲生，但只要你熬过去了。以后的生活就轻松很多。正所谓万事开头难，只要迈出了第一步，你就已经成功了一半，古人说的好“不积跬步，无以至千里。”等到完成之后再回顾这一段路程的时候，你肯定会感慨良多。
这些资料，还很多录制的视频教程，对于做软件测试的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！凡事要趁早，特别是技术行业，一定要提升技术功底。希望对大家有所帮助…….
加油吧，测试人！如果你需要提升规划，那就行动吧，在路上总比在起点观望的要好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf866a036eeef24a20a2bb2db56f9465/" rel="bookmark">
			Win11字体怎么调大？Win11调整字体大小的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win11字体怎么调大？在我们平常电脑的使用中，系统字体的大小十分影响电脑的整体使用体验，如果你想要调整系统字体的大小，那么可以参考以下小编带来的两种方法，步骤简单，我们一起来看看吧。
更多系统教程
方法一：
1、按【Win】键，或点击左下角的【开始】，在打开的所有应用中，找到并点击【设置】；
2、设置（Win+i）窗口，左侧点击【辅助功能】；
3、右侧点击【文本大小（在整个 Windows 和应用中显示的文本大小）】；
正在上传…重新上传取消
4、辅助功能 - 文本大小，文本大小预览，这些文字的大小将随着你调整滑块而更改。在此处所做的更改将适用于设备上的大部分文字。可以拖动文本大小，这个位置的滑块，将字体调大调小；
5、将字体调整到合适的大小之后，点击【应用】就可以了；
6、应用之后，可以明显看到字体变大了，也更容易看清楚文字。
方法二：
1、首先，按键盘上的【Win】键，或点击底部任务栏上的【Windows 徽标】；
2、打开的菜单项中，选择所有应用下的【设置】；
3、设置窗口，找到并点击【显示（显示器、亮度、夜间模式、显示描述）】；
4、缩放和布局下，点击【缩放（更改文本、应用和其他项目的大小）】右侧的对话框，就可以修改缩放比例，系统推荐100%，但是也可以调整为其他比例大小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e238d95712762dfdb5154a3c4e5d3a/" rel="bookmark">
			OutputStream流写入中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OutputStream流写入中文乱码问题 FileOutputStream流 的 write() 方法，写入英文没有问题，中文就变乱码。
原因是该流时字节流，只能写入字节。
而在UTF-8编码中，英文、数字为1字节，汉字为3字节。
解决方案1：将写入的字符串进行编码，然后再存储即可。
编码方法:
String str = "我爱你中国"; byte[] b = str.getBytes(); 【案例】将中文字符串通过OutputStream流写入到文件内
public class Demo3 { public static void main(String[] args) throws IOException { File f = new File("File/myFile.txt"); f.createNewFile(); OutputStream s1 = new FileOutputStream("File/myFile.txt");	String str = "我爱我凡"; byte[] b = str.getBytes(StandardCharsets.UTF_8); for (int i = 0; i &lt; b.length; i++) { s1.write(b[i]); } s1.close(); } } 成功写入~
解决方法2：直接用字符流FileWriter写入，该流写入字符，一劳永逸。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7c7a97a9a3fe38ca46d28bc7b2df96/" rel="bookmark">
			Linux免密登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 客户端生成公私钥 ssh-keygen 上传公钥到服务器 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.111.111 或
# 这里scp会覆盖....需要拷贝追加 scp -p ~/.ssh/id_rsa.pub root@192.168.111.111:/root/.ssh/authorized_keys authorized_keys 权限需为600
chmod 600 authorized_keys 免密登录 ssh root@192.168.111.111 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36d7f85ffb8860946fb31dd9aaa5606/" rel="bookmark">
			C&#43;&#43;详细学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，本次学习主要参考的书籍是C++Primer Plus第六版，为了方便今后参阅，故写下该学习笔记。 C++是在C语言基础上开发的一种集面向对象编程、泛型编程和过程化编程于一体的编程语言，是C语言的超集。 一、预备知识 C++有三件法宝：1、继承了C语言高效、简洁、快速和可移植性的传统（C代表的过程性编程）；2、面向对象的特性带来了全新的编程方法，这种方法是为了应付复杂程度不断提高的现代编程任务而设计的；3、C++的模板特性提供了另一种全新的编程方法—泛型编程。 （1）C++简史 20世纪70年代，C和Pascal语言引领人们进入结构化编程时代，其中C还能生成简单、快速运行的程序，并提供了处理硬件问题的能力，如管理通信端口和磁盘驱动器，使得C成为20世纪80年代占统治地位的编程语言，这段时间同时见证了OOP的发展。 20世纪70年代早期，贝尔实验室的Dennis Ritchie致力于开发UNIX操作系统（所谓操作系统是能够管理计算机资源、处理计算机与用户之间交互的一组程序），为了完成这项工作，Ritchie需要一种语言，不仅要生成简洁、快速的程序，并能有效地控制硬件。传统的方法是使用汇编语言，但这是一种低级语言，不仅直接操作硬件，而且依赖于计算机的内部机器语言，无法在不同的计算机平台工作，这就需要一种高级语言和编译器程序。因此C就是融合了这两种特性，不仅具有低级语言的效率、硬件访问能力，而且具有高级语言的通用性、可移植性。 （2）C语言编程原理 计算机语言要处理两个概念——数据和算法（程序）。数据是程序使用和处理的信息，算法是程序使用的方法。C语言刚出世的时候也是过程性的语言，这意味着它强调的是编程的算法方面。从概念上说，过程化编程首先要确定计算机应采取的操作，然后使用编程语言来实现操作。随着规模扩大，就会形成像“意大利面条式编程”这样的情况。 因此引入结构化编程以及自顶向下的原则，即将大型的程序分解成小型，便于管理的任务。 （3）面向对象编程 面向对象编程强调的是数据。OOP不像过程性编程那样，试图使问题满足语言的过程性方法，而是试图让语言满足问题的要求，其理念是设计与问题本质特性相对应的数据格式。 所以在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。通常，类是规定了可使用哪些数据来表示对象以及可以对这些数据执行哪些操作。OOP程序设计方法首先设计类，它们准确表达了程序要处理的东西。然后可以设计一个使用这些类的对象的程序。这体现了一种自下而上的编程方法，即从低级组织（类）到高级组织（程序）的处理过程。因为OOP语言使得程序员可以轻松使用一些已有的类，所以C++真正的优点之一是：可以方便地重用和修改现有地、经过仔细测试的代码。 （4）泛型编程 泛型编程是C++支持的另一种编程模式，与OOP的目标相同，但是却使重用代码和抽象通用概念更简单。不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型，它们的侧重点不同，OOP是一个管理大型项目的工具，而泛型编程提供了执行常见任务的工具，如对数据排序或合并链表。术语泛型指的是创建独立于类型的代码。例如，要对不同类型的数据进行排序，通常必须为每种类型创建一个排序函数，泛型编程需要对语言进行扩展，以便可以只编写一个泛型函数（即不是特定类型的），并将其用于各种实际类型。C++模板提供了完成这种任务的机制。 （5）C++的起源 与C语言一样，C++也是在贝尔实验室诞生的，Bjarne Stroustrup于20世纪80年代在这里开发出了这种语言。用他自己的话说，“C++主要是为了我的朋友和我不必再使用汇编语言、C语言或其他现代高级语言来编程而设计的。它的主要功能是可以方便地编写出好程序，让每个程序员更加快乐”。 称C++来自C语言中地递增运算符++，运算符将变量加1，名称C++表明，它是C的扩充版本，因为Stroustrup虽然在C上加入了OOP特性和对C的泛型编程支持，但是并没有对C的组件作很大的改动，因此C++是C语言的超集，这意味着任何有效的C程序都是有效的C++程序。C++程序可以使用已有的C软件库。其中OOP部分赋予了C++语言将问题所涉及的概念联系起来的能力，C部分则赋予了C++语言紧密联系硬件的能力，这种能力的结合成就了C++的广泛传播。 在C++获得一定成功后，才添加的模板，这使得进行泛型编程成为可能。在模板特性被使用和改进后，然们才意识到它们和OOP一样重要。 C++融合了OOP、泛型编程和传统的过程性方法，这表明C++强调的是实用价值，而不是意识形态方法。 二、C++学习的最基本知识
（1）进入C++ 注意点： 1、C++对大小写敏感，其中编译器也是对拼写敏感的； 2、文件扩展名cpp是一种表示C++程序的常用方法； 3、C++输入输出函数为cin和cout函数，但也可使用printf（）和scanf（）函数，但要包含常规C语言的stdio.h文件； 4、#include预处理编译指令、int main（）作为接口的函数头、using namespace编译指令、结束mian函数的return函数； 5、C++中，语句结束后不能省略分号； 6、如果编译器到达main（）函数末尾时没有遇到返回函数，则认为main（）函数以return 0结尾； 7、代码#include &lt;iostream&gt;该编译指令导致预处理器将iostream文件的内容添加到程序中，这是典型的预处理器操作：在源代码被编译之前，替换或者添加文本；将 iostream文件的内容添加到程序中这一预处理器操作涉及程序与外部世界之间的通信。iostream中io指的是输入和输出。C++的输入/输出方案涉及iostream文件中的多个定义。#include编译指令导致iostream文件的内容随着源代码文件的内容一起被发送给编译器。实际上，iostream文件的内容将取代程序中的代码行#include&lt;iostream&gt;。原始文件没有被修改，而是将源代码文件和iostream组合成一个复合文件，编译的下一个阶段将使用该文件。 8、像iostream这样的文件叫做包含文件——由于它们被包含在其他文件中，也叫头文件——由于它们被包含在文件的起始处。C++编译器自带了很多头文件，每个头文件都支持一组特定的工具。C语言中头文件使用扩展名h，在C++中，对老式C的头文件保留了扩展名h，即C++也可以使用这种文件，但是C++风格的头文件是没有扩展名的，有些C头文件被转换时，会进行重命名，去掉扩展名h，并在文件名称前加上前缀c,如math.h-&gt;cmath。有时C头文件的C版本和C++版本相同，而有时新版本做了一些修改。对于纯粹的C++头文件来说，去掉h不只是形式上的改变，没有h的头文件也可以包含名称空间。 9、如果使用iostream，而不是 iostream.h，则应使用using namespace std的名称空间编译指令来使 iostream中的定义对程序可用。名称空间支持是一项C++特性，旨在让你编写大型程序以及将多个厂商现有的代码组合起来的程序时更容易，它有助于组织程序。一个潜在的问题是，可能使用两个已封装好的产品，而它们都包含一个名为wanda（）函数，这样，使用wanda（）函数时，编译器将不知道指的是哪个版本，名称空间让厂商能够将其产品封装在一个叫做名称空间的单元中，这样就可以使用名称空间来指出想使用哪个厂商的产品。因此，Microflop Industries可以将其定义放到一个名为Microflop的名称空间中，这样其wanda（）函数的全称为Microflop::wanda();这样，程序就可以使用名称空间来区分不同的版本了。按这种方式，类、函数和变量便的是C++编译器的标准组件，它们现在都被放置在名称空间std中，这意味着在 iostream中定义的用于输出的cout变量实际上是std::cout，因此可以省略编译指令using。 10、对于cout&lt;&lt;"Come up";语句来说，从概念上看，输出是一个流，即从程序流出的一系列字符。cout对象表示这种流，其属性是在 iostream文件中定义的。cout的对象属性包含一个插入运算符&lt;&lt;,它可以将其右侧的信息插入到流中。 11、endl控制符，其重起一行的作用，和cout一样，endl也是在头文件中定义的，且位于名称空间std中。其中所谓的控制符是像endl一样对cout来说有特殊含义的特殊符号。C++中还提供了一种在输出中指示换行的旧方法，就是在“/n”，一般将其放在字符串的引号中，两者之间的区别在于，endl确保程序继续运行前刷新输出（将其立即显示在屏幕上），而使用“\n“不能提供这样的保证，这意味着在有些系统中，有时可能在你输入信息后才出现提示。 12、源代码中的标记和空白。标记是指一行代码中不可分割的元素，空白则是空格、制表符和回车的统称。标记之间一般用空白来分开。 13、声明不一定是定义，在C++中尽可能首次使用变量前声明它，这意味着将导致编译器为变量分配内存空间，而C中所有变量的声明通常都位于函数或过程的开始位置。 14、对于类ostream和istream类，从技术上说，它们并没有被内置到C++语言中，而是语言标准指定的类，这些类的定义位于 iostream文件中，没有被内置到编译器中。 15、类描述了可对类对象执行的所有操作，要对特定对象执行这些允许的操作，需要给该对象发送一条信息。C++提供了两种发送消息的方法：一种是使用类方法；另一种方式是重新定义运算符，cin和cout采用的就是这种方式。 16、例如x=sqrt(6.25)，表达式sqrt(6.25)被称为函数调用，被调用的函数叫做被调用函数，包含函数调用的函数叫做调用函数。对于有返回值的函数来说，函数执行完毕后，语句中的函数调用部分将被替换为返回值。因此在使用函数之前，C++编译器必须知道函数的参数类型和返回值类型。如果缺少这些信息，编译器将不知道如何解释返回值。C++提供这种信息的方式就是使用函数原型语句。例如sqrt()的函数原型就像这样：double sqrt(double)；函数原型之于函数就像变量声明至于变量——指出涉及的类型。原型结尾的分号表明它是一条语句，这使得它是一个函数原型，而不是函数头。如果省略分号，编译器将这行代码解释为一个函数头，并要求接着提供定义该函数的函数体。但不要混淆函数原型和函数定义，原型只描述函数接口，它描述的是发送给函数的信息和返回的信息，而定义中包含了函数的代码。C和C++将库函数的这两项特性分开了，库函数中包含了函数的编译代码，而头文件只包含了原型.
17、函数变体：有多个参数，如 double pow(double,double);不接受任何参数，如int rand(void);没有返回值，如void bucks(double)，这个函数是将数字以美元、美分的格式显示在屏幕上，由于这个函数把值发送给屏幕，而不是调用函数，因此不需要返回值，也不能将该函数调用放在赋值语句或其他表达式中。相反，应使用一条纯粹的函数调用语句：bucks(1234.56)。
18、对于main()函数来说，main函数是一个有返回值函数，所以需要使用关键字return来提供返回值，并结束函数，这就是为什么在main()函数结尾使用语句：return 0；的原因，但是这个返回值到底是返回到哪里了呢？事实上，可以将计算机操作系统看成是调用程序，因此main()函数的返回值并不是返回给程序的其他部分，而是返回给操作系统。
19、让程序访问名称空间std的方法有多种，下面是其中4种：(1)将using namespace std;放在函数定义之前，让文件中所有函数都能使用名称空间std中所有元素；(2)将using namespace std；放在特定的函数定义中，让该函数能够使用名称空间std中的所有元素；(3)在特定的函数中使用类似using std::cout；这样的编译指令，而不是using namesapce std；，让该函数能够使用指定的元素，如cout。(4)完全不使用编译指令using，而在需要使用名称空间std中的元素时，使用前缀std::，如下所示：std::cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a36d7f85ffb8860946fb31dd9aaa5606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd5186d24175775aeab7fb4cb8e3b50/" rel="bookmark">
			面试必刷，MySQL面试夺命20问，值得收藏背诵！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看下目录：
小伙伴们有兴趣想了解内容和更多相关学习资料的请点赞收藏+评论转发+关注我，后面会有很多干货。我有一些面试题、架构、设计类资料可以说是程序员面试必备！
所有资料都整理到网盘了，需要的话欢迎下载！私信我回复【111】即可免费获取
1 说说MySQL 的基础架构图
2 一条SQL查询语句在MySQL中如何执行的？
3 日常工作中你是怎么优化SQL的？
4 怎么看执行计划（explain），如何理解其中各个字段的含义？
5 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？
6 聚集索引与非聚集索引的区别
7 为什么要用 B+ 树，为什么不用普通二叉树？
8 Hash 索引和 B+ 树索引区别是什么？你在设计索引是怎么抉择的？
9 什么是最左前缀原则？什么是最左匹配原则？
10 索引不适合哪些场景?
11 索引有哪些优缺点？
12 MySQL 遇到过死锁问题吗，你是如何解决的？
13 说说数据库的乐观锁和悲观锁是什么以及它们的区别？
14 MVCC 熟悉吗，知道它的底层原理？
15 MySQL事务得四大特性以及实现原理
16 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？
17 什么是幻读，脏读，不可重复读呢？
18 MySQL数据库cpu飙升的话，要怎么处理呢？
19 MYSQL的主从延迟，你怎么解决？
20 如果让你做分库与分表的设计，简单说说你会怎么做？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f091df4f2df29f21039530dc91cbff/" rel="bookmark">
			java中事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.开启事务 事务的四大特性
ACID是原子性（atomicity）、一致性（consistency）、隔离性 （isolation）和持久性（durability）的缩写。
事务的原子性：事务作为整体执行，要么都成功，要么都回滚。
原子：不可以再次分割 在事务中多条sql 语句，要么都执行成功，有一条失败，其他成功的sql 回滚 事务的一致性：表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。
以转账为例：xiaoming 给wangli 转1000 xiaoming 和 wanli 的账户 总额 ，在转账前后不会发生变化 ​ 转账成功：xiaoming -1000 wangli +1000 转账失败：金额数据不变 事务的持久性：事务对数据库所做的操作是永久性的。
凡是事务提交的数据，当机器宕机、掉电 重启以后，数据还在，不丢失 事务的隔离性：多个事务在并发执行过程中，是相互独立的（隔离的）比如：售票过程。
隔离性 就是，一个事务能否看读取到另外一个事务未提交的数据 隔离级别
隔离级别：指的就是一个SqlSession 能否看到另外一个SqlSession 事务未提交的数据
隔离级别本质就是我们允许脏数据的程度
正在上传…重新上传取消
脏数据的程度
问题描述脏读一个事务读取到另一个事务还未提交的数据。大于等于 read-commited 可防止不可重复读一个事务内多次读取一行数据的相同内容，其结果不一致。大于等于 repeatable-read 可防止幻影读一个事务内多次读取一张表中的相同内容，其结果不一致。serialized-read 可防止 正在上传…重新上传取消
3.1.1 概念
isolation 隔离级别
名称描述default(默认值）（采用数据库的默认的设置) （建议）read-uncommited读未提交read-commited读提交 （Oracle数据库默认的隔离级别）repeatable-read可重复读 （MySQL数据库默认的隔离级别）serialized-read序列化读 隔离级别由低到高为：read-uncommited &lt; read-commited &lt; repeatable-read &lt; serialized-read
3.1.2 特性
安全性：级别越高，多事务并发时，越安全。因为共享的数据越来越少，事务间彼此干扰减少。
并发性：级别越高，多事务并发时，并发越差。因为共享的数据越来越少，事务间阻塞情况增多。
3.1.3 并发问题
事务并发时的安全问题
问题描述脏读一个事务读取到另一个事务还未提交的数据。大于等于 read-commited 可防止不可重复读一个事务内多次读取一行数据的相同内容，其结果不一致。大于等于 repeatable-read 可防止幻影读一个事务内多次读取一张表中的相同内容，其结果不一致。serialized-read 可防止 不可重复读:可以解决更新时数据的一致性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f091df4f2df29f21039530dc91cbff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361118641927a3178f1a8408c5fe0059/" rel="bookmark">
			【netty源码之ChannelHandlerContext】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		netty源码之ChannelHandlerContext 一、ChannelHandlerContext是什么？二、ChannelHandlerContext的API1、channel()、pipeline()、handler()、alloc()、executor()2、fire类方法3、read()4、write() 三、骨架类AbstractChannelHandlerContext1、alloc()方法2、read()方法3、write方法 四、实现类HeadContext1、read()方法2、write()方法3、channelActive()方法 五、实现类TailContext1、channelRead()方法 六、实现类DefaultChannelHandlerContext 一、ChannelHandlerContext是什么？ ChannelHandlerContext代表了ChannelHandler和ChannelPipline之间的关联，每当有一个ChannelHandler添加到ChannelPipline中时，都会创建一个ChannelHandlerContext。主要功能是管理它所关联的ChannelHandler和在同一个ChannelPipline中的其他ChannelHandler之间的交互。
二、ChannelHandlerContext的API 1、channel()、pipeline()、handler()、alloc()、executor() 返回该ChannelHandlerContext绑定的各种组件。
2、fire类方法 触发对pipeline上下一个ChannelInBoundHandler上的对应方法的调用。
3、read() 将数据从Channel读取到第一个入站缓冲区；如果读取成功则触发一个channelRead事件，并在最后一个消息被读取完成后通知ChannelInBoundHandler的channelReadComplete(ctx)方法。
4、write() 通过该ctx写入消息。
三、骨架类AbstractChannelHandlerContext 在AbstractChannelHandlerContext类中实现了ChannelHandlerContext的绝大多数方法逻辑。
1、alloc()方法 通过pipeline获取channel，再获取到对应的ChannelConfig，调用DefaultChannelConfig的getAllocator()方法。
private volatile ByteBufAllocator allocator = ByteBufAllocator.DEFAULT; ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR; 可以看到，只有android是默认使用unpooled的，其他均使用pooled。
alloc = PooledByteBufAllocator.DEFAULT; public static final PooledByteBufAllocator DEFAULT = new PooledByteBufAllocator(PlatformDependent.directBufferPreferred()); 至此，我们看到默认的分配器是PooledByteBufAllocator。
2、read()方法 首先会寻找下一个出站处理器，然后取其线程调用其read方法。其实普通的ctx在read的时候就是做了一个传递，真正有执行逻辑的就是pipeline的最后一个出站处理器，也就是HeadContext。接第四节第1个方法描述。
3、write方法 注意到，在进行基础检验或者发生异常时，调用了ReferenceCountUtil.release(msg)方法进行内存释放。
接下来就如出一辙了，沿着出站处理器往下传递，直到最后一个HeadContext。
4、file类方法fireChannelRead()方法
找到下一个进站处理器，触发对应方法的调用。
四、实现类HeadContext pipeline中的第一个ctx，既是入站处理器，也是出站处理器。
1、read()方法 调用了unsafe的beginRead方法。
这个unsafe是channel的unsafe。
该方法在AbstractChannel中实现。调用了钩子方法doBeginRead。我们进AbstractNioChannel类继续追踪
最终是给该channel在selector上注册了读事件。
2、write()方法 同样也是调用了unsafe的write方法。
可以看到是把数据写到了出站缓冲区中。
3、channelActive()方法 除了向后传递，还调用了readIfIsAutoRead()方法。
这个方法也很简单，调用了channel的read方法，最终调用了HeadContext的read方法，也就是本节介绍的第1个方法，为该channel注册了读事件。
五、实现类TailContext pipeline中的最后一个ctx，入站处理器链的最后一个节点。
1、channelRead()方法 看到仅仅是调用了DefaultChannelPipline的onUnhandledInboundMessage()方法。
在这个方法中，只是打印了日志，并对内存进行了释放。这就告诉我们，在我们自定义实现的inBoundHandler中，只要我们调用file方法把msg传递下去，netty已经给我们做好了内存回收，不用担心内存泄露问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361118641927a3178f1a8408c5fe0059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919f655318f20f833ff8df2ed50aadd3/" rel="bookmark">
			Win10搭建gym运行atari游戏pong
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022.06.07
Cauchyoooo
Windows10搭建Gym-Atari环境
本人由于做某个大作业，需要用到强化学习。各种教程参差不齐（比如各种转载复制粘贴的），导致我踩了很多坑。
参考仅供参考。
参考1：迷途无归的博客
参考2：_李子树_的博客
可涉及的版本号（仅供参考）
python = 3.9.7
gym = 0.24.0
gym-notices = 0.0.7
ale-py = 0.7.5
atari-py = 1.2.2
1.VS下载安装（C++编译器） 这里是为了避免“ale_interface/ale_c.dll OSError: [WinError 126] 找不到指定的模块”这一个error。
VS下载链接：https://visualstudio.microsoft.com/zh-hans/downloads/
勾选红框此项安装
2.pip安装各种库 win+r打开运行，输入cmd，打开命令行（或者Anaconda Prompt）看自己python环境配置吧，如果Anaconda有新建虚拟环境，记得conda activate [虚拟环境名]切换环境。（如何创建虚拟环境可参考：https://zhuanlan.zhihu.com/p/94744929，镜像可以加速下载啥的）
由于本人也在踩坑过程中反复install和uninstall，所以下面部分库是必需的，部分库是多余的。
pip install gym[atari] 这条会装下图所示的一些包，因为我已经装了，就展示一下。
pip install ale-py 以上两个应该是必要的，以下的就不知道了。
有的教程说要装cmake，我现在也不知道要不要。这个东西用清华的镜像源下载比较块。
pip install cmake 这个我也不知道具体什么用的，经常超时（没科学上网，github随缘）
pip install --no-index-f https://github.com/Kojoley/atari-py atari_py 游戏开发模块，计算机视觉库…？
pip install pyglet pip install opencv-python 3.导入ROMS 据说是版本更替问题，导致需要手动导入某些东西。
就是这个Error
先到网站[http://www.atarimania.com/rom_collection_archive_atari_2600_roms.html]下载
然后解压
然后有人告诉你要用，命令行进入到这个ROMS文件夹所在的文件夹，图中是Roms，然后运行该命令
ale-import-roms ROMS/ 路径对了，能行就行。反正我是跑几次都RunTime Error，就放弃这条命令了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/919f655318f20f833ff8df2ed50aadd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c0c1435a7020056efb9dc9f65d52e4/" rel="bookmark">
			AndroidStudio Logcat窗口不见了解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		logcat过滤窗体消失不见，如下解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf0fb4a2cf5d30b34937d4827aab178/" rel="bookmark">
			[激活官方作弊模式]关于＜野兽与乡巴佬＞中文版游戏的修改-已研究成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;野兽与乡巴佬&gt; 这篇文章 不是讨论 怎么下载和安装 野兽与乡巴佬,也不是讨论 怎么下载网上的修改器来修改,
而是因为从一开始玩这游戏,在大约十多年前吧,我就想如何能生出一堆的 小孩,以及炸死那些令人讨厌的狼和僵尸.,如果你刚好也是这样,欢迎进来…你可以直接跳过 一二三 ,到四去看
一.这款游戏的魅力 ​ &lt;野兽与乡巴佬&gt; 这个游戏可以生孩子,创建自己的家园 ,打怪兽,是一款非常奇葩的游戏
二.下载 方式 ​ &lt;野兽与乡巴佬&gt;有中文版和英文版, 先说英文版,下载后在&lt;野兽与乡巴佬&gt;SETUP.EXE上 用兼容模式 选择WIN95 来安装
三.&lt;野兽与乡巴佬&gt; 在WIN10中如何使用
​ 在 此处下载 http://dege.freeweb.hu/dgVoodoo2/dgVoodoo2/
dgVoodoo2不用安装,解压到某个目录 ,先把 Dgvoodoo2 目录 中MS\ x86 拷到乡巴佬目录下,有这么些文件DDraw.dll, D3DImm.dll, D3D9.dll, D3D8.dll
打开 dgVoodooCpl.exe
设置如下:
Output API: \- Best available one Adapters to use: \- Your main GPU Full screen output: \- Default Appearance: \- Full screen Progressive scanline order \- NO Enumerate refresh rates \- NO Colors: \- Leave as is Misc: \- Keep window ratio?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf0fb4a2cf5d30b34937d4827aab178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384345edd4325cea76ac1c838130aa02/" rel="bookmark">
			ADI超声解决方案 和系统成像设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、ADI 医疗超声解决方案
2、超声成像系统及主要子功能电子元件的设计考虑 | Maxim Integrated
3、超声系统的架构原理及医学超声芯片的模拟参数-医疗电子-与非网
4、连续多普勒（CW）和脉冲多普勒(PW)的区别
5、用于超声成像系统的连续波 (CW) 信号调节子系统 - 电路城
超声成像系统及主要子功能电子元件的设计考虑 By: John Scampini
摘要 : 该应用笔记介绍了超声成像系统的设计考虑，讨论成像系统的小型化、低成本和便携化的发展趋势，同时阐述了在小型系统中实现大型车载系统所具备的性能和诊断能力的重要条件。文章探讨了超声系统的子功能以及对电子元件的要求，重点讨论了传感器、高压复用器、高压发射机、成像通道接收机、数字波束成形、波束成形数字信号处理及显示处理等。
概述 通过发射超声能量进入人体，接收并处理返回的反射信号，相控阵超声系统可以生成体内器官和结构的图像，映射血液流动和组织运动，同时提供高准确度的血流速度信息。传统设计中，构建这样的成像系统需要大量的高性能相控阵发射器和接收器，使得车载设备体积庞大且价格昂贵。近年来，随着集成工艺的进步，设计人员能够获得小尺寸、低成本而且高度便携的成像系统方案，并可达到接近大型成像设备的性能指标。而新的设计挑战依然存在，即在进一步提高方案集成度的同时提高系统性能和诊断能力。
传感器 成像系统的关键器件是超声传感器。典型的超声成像系统需要使用各种传感器支持特定的诊断要求。每个传感器由一组压电传感器单元阵列构成，它们集中能量并发射到人体内部，然后接收相应的反射信号。每个单元通过纤细的同轴电缆连接到超声系统。通常，传感器由32至512个单元构成，工作频率为1MHz至15MHz。多数超声系统提供两个至四个传感器转换接口，临床医生可根据不同的检测类型方便地更换传感器。
高压复用开关 典型的相控阵超声系统配备了32至256个发射器和接收器。多数情况下，系统配备的发射器和接收器的数量少于传感器单元的数量。这些情况下，需要在传感器或系统中安装高压开关，用于信号复用，开关连接在特定的传感器单元和发送器/接收器(Tx/Rx)对之间。由此，系统能够在所提供的传感器阵列中动态改变有效的传感器孔径。
成像系统对高压开关的要求主要包括几个方面：必须能够承受电压摆幅高达200VP-P且峰值电流高达2A的发射脉冲；开关必须能够迅速切换，以快速调整有效孔径、满足图像帧率的要求；最后，这些开关还必须具有极小的电荷注入，从而避免杂散传输以及相关的虚假图像。
超声成像系统功能框图。关于Maxim推荐的超声方案，请参考：china.maximintegrated.com/ultrasound。
高压发射机 数字发射波束成形器用于产生所要求的数字发射信号，以正确的时间和相位生成聚焦发射信号。高性能超声系统可通过任意波形发生器产生复杂的发射波形，从而优化图像质量。这些情况下，发射波束成形器以大约40MHz速率生成8位至10位数字字符，并以此产生所要求的发射波形。数/模转换器(DAC)将数字波形转换成模拟信号，通过线性高压放大器进行放大，用于驱动传感器单元。由于这种发射技术占用较大体积，而且价格昂贵、需要消耗较高能量，所以，这种架构只限于昂贵的非便携设备。多数超声系统并不使用这种发射波束成形技术，而是采用多级高压脉冲发生器产生需要发射的信号。在这种替代方案中，利用高集成度、高压脉冲发生器快速切换传感器单元至适当的可编程高压电源，产生发射波形。为了产生一个简单的两极发射波形，脉冲发生器需要交替地将传感器单元切换到由数字波束成形器控制的正、负发射电压。更复杂的设计可以让传感器单元切换至多路电源和地，从而产生更复杂、性能更好的多重波形。
近几年，随着二次谐波成像的广泛应用，高压脉冲发生器对于斜率和对称性的要求越来越高。二次谐波成像利用了人体的非线性声学特性。这些非线性特性倾向于将频率fo的声能转变成2fo频率。多种原因使得接收二次谐波信号能够获得更高的图像质量，因此，二次谐波成像得到了广泛应用。
二次谐波成像有两种基本的实现方法。一种称为标准谐波成像，尽可能抑制发射信号的二次谐波，从而使接收到的二次谐波主要源于人体的非线性。这种模式要求二次谐波的发射能量至少低于基波能量50dB。所以，发射脉冲的占空比要求是准确的50%且误差小于±0.2%。另一种方法称为脉冲反相，利用反相后的发射脉冲产生同一图像路径的相位相反的两路接收信号。在接收器中对这两路反相接收信号求和，恢复由于人体非线性产生的谐波信号。这种脉冲反相的方法必须在叠加时尽可能抵消发射脉冲的反相成分。所以，高压脉冲发生器的上升时间和下降时间必须严格一致。
成像通道接收机 超声成像通道的接收机用于检测二维(2D)信号以及彩超流体成像所需的脉冲多普勒(PWD)信号和频谱PWD。接收机包括Tx/Rx开关、低噪声放大器(LNA)、可变增益放大器(VGA)、抗混叠滤波器(AAF)和模/数转换器(ADC)。
Tx/Rx开关 Tx/Rx开关可以保护低噪声放大器免受高压发射脉冲的影响，同时在接收间歇期间隔离低噪声放大器输入和发射机。该开关一般采用一组正确偏置的二极管阵列实现，当有高压发射脉冲出现时，它们会自动闭合或断开。Tx/Rx开关必须具备很快的恢复时间，以保证接收机在发射一个脉冲后能够立刻开启。这些快速恢复时间对于浅埋成像和提供低导通电阻确保接收灵敏度至关重要。
低噪声放大器(LNA) 接收机中的LNA必须具有出色的噪声性能和足够增益。对于设计合理的接收机，LNA将决定整个接收机的噪声性能。传感器单元通过较长的同轴电缆连接到相应的低阻抗LNA的输入端。如果没有适当的电缆终端匹配，电缆电容和传感器单元的源阻抗将大大制约从宽带传感器接收信号的带宽。传感器电缆匹配至低阻，有助于降低这一滤波的影响，有效提高图像质量。不幸的是，这种端接也降低了LNA的输入信号，因而降低接收灵敏度。由此可见，为LNA提供有源输入端接非常重要，可以在上述条件下提供必要的低输入阻抗端接和出色的噪声性能。
可变增益放大器(VGA) VGA有时也称为时间增益控制(TGC)放大器，能够在整个接收周期内为接收机提供足够的动态范围。超声信号在体内大约每秒传输1540米，往返衰减率为1.4dB/cm-MHz。发射一个超声脉冲后，可立即在LNA输入接收到高达0.5VP-P的回波信号，该信号会快速跌落到传感器单元的热噪声基底。接收该信号所要求的动态范围约为100dB至110dB，超出了实际ADC的输入量程。因此，需要利用VGA 将信号转换成与ADC量程相当的信号幅度。典型应用中采用12位ADC，要求VGA能够提供30dB至40dB的增益。增益随时间调整(即“时间增益控制”)，实现所要求的动态范围。
超声接收机的瞬态动态范围也很关键，它会影响2D图像的质量和系统检测多普勒偏移(血液或组织的运动)的能力，尤其是在二次谐波成像系统中，感兴趣的二次谐波信号明显低于发射信号的基波。对于小的多普勒信号同样如此，多普勒信号频率可能在1kHz以内，幅度远远低于组织或血管壁的反射信号。因此，需要特别关注可变增益放大器的带宽和近载波SNR，这些参数通常是制约接收机性能的关键。
抗混叠滤波器(AAF)和ADC 抗混叠滤波器AAF置于接收通道，用于滤除高频噪声和超出正常最大成像频率范围的信号，防止这些信号通过ADC转换混叠至基带。设计中大多采用可调节的AAF，为了抑制混叠并保证信号的时域响应，滤波器需要对第一奈奎斯特频率以外的信号进行衰减。因此，常常使用巴特沃斯滤波器或更高阶的贝塞尔滤波器。
典型应用中采用12位ADC，采样率通常在40Msps至60Msps之间。ADC提供必要的瞬态动态响应范围，同时具有适当的成本和功耗。在设计得当的接收器中，ADC会限制接收通道的瞬态SNR。如上所述，性能差的VGA会限制整个接收通道的SNR指标。
数字波束成形器 ADC的输出信号通过高速LVDS串口传输给数字接收波束成形器。这种传输方式降低了PCB的设计复杂度和接口引脚数。波束成形器内置上变频低通滤波器或带通数字滤波器，这些滤波器把有效采样速率提高4倍，提高了系统波束成形的精度。上变频信号存储在内存中，经过适当的延时，通过延迟系数加法器进行叠加，得到合适的焦点。信号还进行适当的加权或“变迹”，在叠加之前进行变迹，可以调节接收孔径，降低旁瓣对接收波束的影响，提高图像质量。
波束成形的数字信号处理 接收到的波束成形数字超声信号由DSP和基于PC的设备进行处理，得到视频和音频输出信号。这一过程通常可以划分为B超或2D图像处理，以及具有彩超流体成像信息的多普勒处理，多普勒处理又分为脉冲多普勒(PWD)处理和连续波多普勒(CWD)处理。
B超处理 B超处理中，RF波束成形数字信号经过滤波和检波处理。检测信号具有极宽的动态范围，B超处理器必须将这些信号进行数字压缩，使其达到显示器规定的动态范围。
彩超流体信号处理 在彩超流体信号处理中，RF数字波束成形信号与正交本振信号(LO，频率为发射频率)进行混频，得到I、Q基带信号。每个接收通道采集的超声信号都有对应的幅度和相位。彩超流体信号处理中，8至16路超声信号集中在一个成像通道，测量多普勒频移。血液流动或沿成像通道的组织移动产生的反射信号具有一定的多普勒频移，从而改变了I/Q基带采样信号的相位。彩超流体处理器决定了成像通道的8至16路超声信号的平均相移和时间关系。处理器还用彩色表示平均流速。通过这种方法，实现了血液或人体组织移动的二维造影成像。
多普勒频谱 频谱处理中，波束成形数字信号经过数字滤波，并通过正交本振信号(LO，频率为发射频率)混频至基带信号，然后以发射脉冲重复频率(PRF)进行采样。利用复杂的快速傅里叶变换(FFT)获得多普勒频谱，以重现接收信号的速度信息。FFT输出的每个二进制信号幅度经过计算和压缩，使其达到显示图像所要求的动态范围。最终信号幅度作为时间函数，显示在超声设备的显示屏上。
在连续波多普勒(CWD)成像系统中，信号处理的过程基本相同。除了处理这些显示信号外，频谱处理器还产生左、右声道的立体声音频信号，表示正向和负向运动。DAC对这些信号进行转换，驱动外部扬声器和耳机。
显示处理 显示处理器进行必要的计算，绘制极坐标图。B超中的声音、图像数据或彩超流体信息被处理成矩形位图，从而消除图像中的杂散信号。这一过程通常称为R-θ变换，显示处理器还提供空间图像增强功能。
连续波多普勒(CWD) 多数的心脏检查和一些通用的超声成像系统中，常常使用连续波多普勒CWD以确保精确测量心脏内高速流动的血液。CWD模式下，超声传感器单元以传感器孔径为中心分割成对等的两部分。一半单元用于发射，产生CWD聚焦波束；另一半单元用于接收，产生聚焦的接收波束。发射单元的驱动波形为多普勒频率的方波，频率范围通常为1MHz至7.5MHz。发射波形的抖动必须足够小，以防止相位噪声对多普勒频移检测的影响。通过正确调整发射波形的相位，实现发射波束聚焦。类似地，通过正确调整接收波形的相位并进行叠加，实现CWD接收信号聚焦。在此模式下，发射和接收同时进行，有用的多普勒信号频率和不移动的人体组织在发射基波频率下产生的强反射信号的频率相差只有几kHz。处理如此大的信号所需要的动态范围已经超出了图像接收通道VGA、AAF和12位ADC可以承受的范围。因此，CWD必须使用其它高动态范围接收解决方案。
CWD接收机通常使用两种方法处理CWD信号。第一种方法是高性能超声系统在LNA输出端提取接收到的CWD信号。本振频率等于发送频率的混频器对信号进行波束成形，再混频至基带进行处理。I/Q本振信号可以逐通道调整相位，对接收到的CWD信号相位进行偏移。混频器输出相叠加，经带通滤波器，最后进入ADC进行采样。采样得到的基带波束信号处于音频范围(100Hz至50kHz)，采用工作在音频频率范围的ADC对I和Q CWD信号进行数字化。这些ADC需要出色的动态范围，以便处理运动组织产生的较大的低频多普勒信号和血液产生的微弱信号。
另一种方法是使用延迟线接收CWD信号，该方法常用于低成本设备。在此方法中，信号还是从LNA输出提取，然后转化成电流信号。通过一个交叉开关对相同相位的通道进行叠加，产生8至16路独立输出，具体由接收波束成形器决定。延迟线产生延迟，并将这些信号求和构成一路波束成形RF信号，然后利用一个本振频率等于发送频率的I/Q混频器将信号混频至基带，然后将基带音频信号滤波后，转换至数字形式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf07b8288ad9a65ab50693e097dd330/" rel="bookmark">
			关于找不到mfc120u.dll文件错误与0xc000007b错误的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 基于VisionMaster 4.1.0 SDK的二次开发
开发工具Visual Studio 2017
问题描述 打不开C:\ProgramFiles\VisionMaster4.1.0\Development\V4.x\ComControls\Tool\ImportRef.exe
报找不到mfc120u.dll文件错误
重新下载软件多次无法解决
于是根据其他网上教程下载补齐mfc120u.dll文件
找不到文件问题解决后，出现新的错误0xc000007b错误
原因分析： C++环境安装与配置问题
解决方案： 下载DirectX修复工具增强版
解压DirectX后使用管理员身份运行
选择工具 -&gt; 选项 -&gt; 高级
勾选强制检测 , C++强力修复 , API Sets强力修复
点击检测并修复
修复完成后重启电脑
再次进入工具 -&gt; 选项
选择注册勾选包括64位的dll文件后点击注册系统文件夹中所有dll文件注册成功后重启电脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f0fc43aea830b381a13b289c8e5435/" rel="bookmark">
			Netty源码分析之ChannelPipline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Netty源码分析之ChannelPipline 接口ChannelPipeline接口ChannelPipeline的唯一默认实现类DefaultChannelPipeline 接口ChannelPipeline 定义：
public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundInvoker, Iterable&lt;Entry&lt;String, ChannelHandler&gt;&gt; 继承了ChannelInboundInvoker的入站传递事件的方法：
继承了ChannelOutboundInvoker的出站事件处理方法：
定义了自己管理ChannelHandler的方法：
接口ChannelPipeline的唯一默认实现类DefaultChannelPipeline DefaultChannelPipeline的构造方法：
在构造方法中，有对tail和head的实例化，并把head和tail连成了双向链表。
TailContext和HeadContext都是类DefaultChannelPipeline的内部类：
HeadContext：
final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler TailContext：
final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler 可以看到，TailContext和HeadContext都是类AbstractChannelHandlerContext类的子类，而AbstractChannelHandlerContext是接口ChannelHandlerContext的骨架抽象实现，这两个类就是pipline中的两个节点，HeadContext是链第一个，TailContext是链的最后一个。此外HeadContext还实现了ChannelOutboundHandler和ChannelInboundHandler，表明它不仅是一个入站节点还是一个出站节点，而TailContext只实现了ChannelInboundHandler，表明它仅作为入站节点使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e92e4e55a4b1ff594362ef1f1ed2a857/" rel="bookmark">
			html或者jsp中radio选择改变事件,单选框radio改变事件详解（用的jquery的radio的change事件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、总结
1、用的jquery的radio的change事件：当元素的值发生改变时，会发生 change 事件，radio选择不同选项的时候恰巧是值发生改变。
二、单选框radio改变事件详解
Cllot Fransfer $(document).ready(function() { $('input[type=radio][name=bedStatus]').change(function() { if (this.value == 'cllot') { alert("Cllot Thai Gayo Bhai"); } else if (this.value == 'fransfer') { alert("Fransfer Thai Gayo"); } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c04f1a7cf0dbd7948cc6ede48cc0f91/" rel="bookmark">
			vscode github copilot 报错 unable to verify the first certificate.解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我发现我的copilot审核终于过了，但是VS还是弹不出网页，就去VScode试，结果下载插件、登录github、使用魔法后依旧一直报错 unable to verify the first certificate.
unable to verify the first certificate. 找了半天原因，最后发现是我一直挂着的steamcommunity302的锅，关了之后重启vscode就好了。。。（如果有使用steam++的也一样，因为steam++就是内置的302）。
然后就可以愉快地使用了！
人工zz= =，当我愉快地按tab的时候，意识到哪里不对劲，定睛一看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39018e7604b3c11060104cb6863ac8c/" rel="bookmark">
			西门子S7-200PLC入门及介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.S7-200CPU 西门子200CPU或者Smart200的CPU都是将一个微处理器，一个集成电源和数字量IO组成一个封装的盒子，从而构成一个功能强大的微型PLC，也就是西门子200或者Smart200PLC.
盒子外观如下图所示:
西门子200PLC的CPU模块 - 图片来源网络
2.S7-200CPU一览 S7-200CPU有5个系列，如下图示：
3.S7-200CPU硬件特点 其硬件如下所示:
4.S7-200CPU硬件接口 S7-200CPU硬件接口组成如下，有AI/AO.DI/DO,RS232/RS485以及电源端子，这些是和外部通信，以及输入输出的通道。
5.S7-200CN CPU 连接到编程 PC 可以通过USB-PPI电缆将PLC连接到电脑上
6.S7-200CPU模块可以通过扩展电缆扩展其他功能模块 7.S7-200PLC的功能与性能 如下图，越往右PLC功能越多，越强大
8.S7-200PLC通信 如下图，S7-200PLC可以连接很多外部设备，可以连接GPRS,变频器，触摸屏等等，通过扩展模块都可以连接互联网，可见麻雀虽小五脏俱全。
9.S7-200扩展模块 如下图所示，为了更好的满足各种应用需求，S7-200PLC提供了很多扩展模块，比如数字量模块，模拟量模块等
10.STEP7-Micro/WIN编程软件 西门子S7-200PLC使用STEP7-Micro/WIN软件编写程序，调试，以及下载程序到PLC,其界面如下所示：
附录： 西门子200模拟器下载地址：西门子S7-200PLC模拟器.zip-单片机文档类资源-CSDN文库
西门子200编程软件下载地址：西门子200编程软件-MicroWinSp9.zip-单片机文档类资源-CSDN文库
附图：西门子200PLC总览 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9194f8e35acdde53ec358471ec5d660/" rel="bookmark">
			Unity常用标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签的概念 标签在C#中也被叫做特性。特性(attribute)是一种允许我们向程序的程序集添加元数据的语言结构。它是用于保存程序结构信息的特殊类型的类。
特性的目的：告诉编译器把程序结构的某组元数据嵌入程序集。可以通过特性应用到结构来实现
特性的使用 1、通过在结构前放置特性片段来应用特性。
2、特性片段由方括号包围特性名和参数列表构成。
Unity的常用标签 标记字段 [Space] [Space]：可以与上面的字段形成一个间隙，并且可以带参数。例如 [Space(20)]
代码：
[Space(30)] public int HP; [Space(50)] public string MP; 例图：
[Header(“XXX”)] [Header(“XXX”)]：在Inspector面板上给定义的字段的上一行加段描述，可以将属性隔开，形成分组的感觉。
代码：
[Header("个人属性")] public int HP; public int MP; [Header("天赋属性")] public string Power; 例图：
[Tooltip(“XXX”)] [Tooltip(“XXX”)]：在Inspector面板上鼠标移上定义的字段弹出描述 。
代码：
[Tooltip("个人属性")] public int HP; public int MP; [Tooltip("天赋属性")] public string Power; 例图：
[Range(min, max)] [Range(min, max)]：限制数值变量的取值范围并以滑动条显示在Inspector面板上。
代码：
[Range(1,12)] public int HP; public int MP; 例图：
[SerializeField] [SerializeField]：限在Inspector版面中显示非public属性，并且序列化 。
序列化：对象的寿命通常随着生成该对象的程序的终止而终止，有时候需要把在内存中的各种对象的状态（也就是实例变量，不是方法）保存下来，并且可以在需要时再将对象恢复。虽然你可以用你自己的各种各样的方法来保存对象的状态，但是Java给你提供一种应该比你自己的好的保存对象状态的机制，那就是序列化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9194f8e35acdde53ec358471ec5d660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd855dee92dafc5cb64e3b686696d6d/" rel="bookmark">
			JavaScript_事件相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件执行步骤 获取事件源； 形式如：var 自定义变量名 = document . 各种获取元素方式（' 标签名 '）； 特别地：1. 获取body元素——document . body;
2. 获取html元素——document . documentElement;
绑定事件 注册事件; 形式如：1. 传统方式：自定义变量名 . (on开头)各类事件；
2.方法监听方式：自定义变量名 . addEventListener ( '(开头去on)各类事件' , 函数); 引入 — — （各类事件）
添加事件处理程序； 形式如：1. 传统方式：自定义变量名 . (on开头)各类事件 = function ( 事件对象 ) { 相关执行内容 }
2.方法监听方式：自定义变量名 . addEventListener ( ' ( 开头去on ) 各类事件 ' , function ( 事件对象 ）{ 相关执行内容 } , true (事件流的捕获阶段) / false (事件流的冒泡阶段) ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd855dee92dafc5cb64e3b686696d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53fd4c6a6ecba2faf4a25de82d9fb119/" rel="bookmark">
			CTFshow之web171~180---SQL注入（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
web171
总结：
web172
web173 web174
方法一：字符串转化绕过
方法二：盲注
web175
方法一：时间盲注
方法二：文件写入
总结：
web176
web177
总结：
web178
总结：
web179 web180
总结：
web171 用order by判断字段，确认字段数为3
接着用联合注入爆出当前数据库的所有表名
-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database()--+
根据题目给的SQL语句判断，flag就在字段password里，且旁边对应的字段username值为flag，故构造payload直接查看flag
-1' union select 1,2,password from ctfshow_user where username = 'flag' --+
总结： 有时候注释符#用不了，可以换成--+注释掉，联合查询的结果跟前面where的限制条件无关，比如前面username != ‘flag’对联合注入无效
web172 跟上一题差不多，只不过这里字段数为2，还有个约束条件
判断回显的字段是否有flag，有flag就不能回显
先看一下表
-1' union select 2,group_concat(table_name) from information_schema.tables where table_schema = database()--+
这里明显flag不在第一个表里，构造payload -1' union select 2,password from ctfshow_user2 where username = 'flag' --+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53fd4c6a6ecba2faf4a25de82d9fb119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a389edc2a261d2d640a9587c01523421/" rel="bookmark">
			Java多线程【三种实现方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java多线程 并发与并行 小伙伴们有兴趣想了解内容和更多相关学习资料的请点赞收藏+评论转发+关注我，后面会有很多干货。我有一些面试题、架构、设计类资料可以说是程序员面试必备！
所有资料都整理到网盘了，需要的话欢迎下载！私信我回复【111】即可免费获取
并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行
并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。
对比：并发是指:在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)
进程与线程 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础
线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
java的线程 java多线程机制
多线程是指一个应用程序同时存在几个执行体，按照几条不同的执行线索共同工作的情况。java多线程机制，它使得编程人员可以很方便的开发出具有多线程功能、能同时处理多个任务的强大应用程序。java内置对多线程的支持，java虚拟机可以快速的从一个线程切换到另一个线程。这些线程的轮流执行使得每个线程都有机会使用cpu资源。
java的主线程
每个java程序都含有一个线程，那就是主线程（main线程）。Java应用程序都是从主类main方法执行的，当jvm加载代码，发现卖弄方法之后，就会启动一个线程，这个线程就是主线程，负责执行main方法。如果在主线程里面创建其他线程，就会在主线程和其他线程来回切换，直到其他所有线程结束才会结束主线程。
线程的生命周期
运行
线程创建之后只占有了内存资源，在JVM管理的线程中并没有刚刚创建的这个线程，只有这个线程调用start（）方法后，JVM才知道有一个新线程进入队列等待cpu调用。
中断原因（4种）
jVM把cpu资源切换给其他线程。线程使用cpu期间，执行了sleep(int millsecond)方法，使当前线程进入休眠状态，调用该方法之后会立即让出cpu，经过参数millsecond指定的毫秒后，重新加入队列等待cpu。
-使用cpu期间，执行了wait()方法，使得当前进程进入等待状态，这个等待个sleep()不同，这个等待需要其他线程调用notify()方法唤醒该线程，此线程才会重新进入队列，等待cpu。
线程使用cpu期间，执行了某个操作进入阻塞状态，例如（读、写、打印等），只有这些造成阻塞的原因完成，这个线程才会进入队列，等待cpu。 创建线程（3种） 继承Thread类实现线程创建
一种是创建一个类继承Thread类，这种继承可以重复使用！一种是直接使用匿名内部类继承，这种类型只能使用一次，每次使用都要重新创建不论哪种都需要重写run()方法，并且在定义之后调用start()方法，把这个线程调入线程队列等待调用。 下面我们使用匿名内部类创建一个打印100以内的奇数线程，使用类继承Thread类打印100内的偶数线程。
package hello; public class Hello { public static void main(String[] args) { Thread1 thread1 = new Thread1(); Thread thread = new Thread() { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 1) { //打印线程名，线程名是从0开始的 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a389edc2a261d2d640a9587c01523421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e776898092632815f8c7f384890222/" rel="bookmark">
			TX2超详细，超有用的刷机教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TX2超详细，超有用的刷机教程 TX2被Nvidia官方称作是最快，最节能的嵌入式AI计算设备。它的功耗小，只有7.5W，体型也小，只有一张信用卡那么大，它是真正可以实现AI边缘计算的利器。在刷机前，我首先针对开发对它进行一下简单的介绍。
TX2有几个比较重要的知识点：
（1）它有6个CPU内核，由双核Denver2处理器和四核ARM Cortex-A57组成，还有一个很强大的GPU，这个GPU有256个CUDA核心，算力是6.2。
（2）它有8G的运行内存，32G的实际内存（这个内存会偏小，在后期开发的时候，往往需要扩展内存，可以见我的另一篇博客。）
（3）CPU内核有5种功耗模式，见下图
通常情况下，TX2处于Max-Q低功耗模式，可以开到火力全开的Max-N最高功耗模式。
（4）开发TX2通常需要将在终端上训练好的机器学习或神经学习的模型部署到jetson TX2上，TX2使用的是TensorRT框架，其预先为开发者做了大量繁重的准备工作，使开发者能充分利用GPU中的Tensor Core（张量计算核心）和DLA单元（Deep Learning Accelerator，深度学习加速器），所以当你使用自己训练的TensorFlow模型或者caffe模型，需要进行转换，当然你也可以直接安装TensorFlow，但是这样你就有可能舍弃了张量核和DLA，开发板的性能有可能得不到充分的发挥。
一、刷机前言 开发TX2的过程中，很多情况下都要认准Nvidia官方文档，像刷机（其实是往TX2装jetpack SDK），官网就有比较详细，几乎不会出错的教程。这个官方教程在这里：https://docs.nvidia.com/jetson/jetpack/install-jetpack/index.html
这个教程讲了三种刷机方法，适合TX2刷机的是后面两种方法，下面我将详细展开说明这两种方法，两种方法亲测有效。注：第一种方法会比较麻烦，如果嫌麻烦，可以直接用第二种方法。
二、利用安装包刷机 这一步有比较详细的官方安装教程。
1、刷机前需要准备一台装有ubuntu16.04的主机，如果不想装双系统，或者没有多台计算机的话，亲测虚拟机也可以。主机需要连网和至少10GB的磁盘空间。
2、在这台主机上下载JetPack，最完整的Jetpack目录在这个网址里，可以根据自己需要的版本进行下载，推荐下载最新版本的jetpack SDK。注：下载的时候需要有账号，没有账号的话注册一个。
3、下载好Jetpack后，开始进行安装。
（1）、在ubuntu终端，进入安装Jetpack SDK的目录cd 文件名，进行以下命令更改权限：
chmod +x ./JetPack-(这个是安装包的名字).run （2）、在终端输入命令运行（注：命令前不用加sudo）：
./JetPack-(这个是安装包的名字).run （3）、然后就进入了Jetback的安装。按照指示，一步一步的进行下去，先选择安装目录，选择
是否启用数据收集（通常选NO），设置开发环境（选TX2）。
（4）、完成上面的操作后会出现组件管理器，选择full，点击next，然后在出现的页面选择accept all，继续点击next。
（5）、在中间的过程中可能会出现
输入在主机设置的密码即可。
（6）、然后开始进行了组件安装，界面的process会出现进度条，下载完成后，继续点击Next出现以下界面
（7）、继续点击next，出现下面的界面
好了，到了这一步，就快成功了，先冷静一下，之后的操作会很关键。
（8）、上面的操作是在自己的计算机上装了Jetpack SDK，现在需要将这个SDK“刷到”TX2上。第七步提示可以选择两种方式刷SDK，这里不用管这两种方法有什么具体的区别，直接选择第一种方法，因此第一种的成功率更高，也比较简单。
（9）、选好后，先别急着点击next，要做一些准备，首先是先用网线将TX2和上面用的主机连在路由器或者交换机上，然后点击next，接着继续点击next，最后出现这个界面
（10）、上面这个界面提示要将TX2置于“强制USB恢复模式”，以便进行刷新。这时候，将TX2断电，用一根USB线将TX2和主机连接在一起，然后上电开机，按住TX2的RECOVERY键不放，接着按下RESET键，两秒后松开RECOVERY键。按照提示，这时候终端输入lsusb，会出现
“NVIDIA Corpration”（大概率是有的，如果没有，不要慌，可以再进行一下第9和10步。）
（11）、最后一步，按下回车，然后就开始了刷机，等待一段时间后，最后出现“installation of target compoents finished ,close this windows to continue”。关闭这个界面，点击finish，恭喜你，刷机成功，可以喝杯茶了。
三、利用Nvidia SDK Manager刷机（推荐） 上面的刷机是不是比较繁琐？作为一个产品，Nvidia肯定考虑到了这一点，因此Nvidia Jetson专门开发一个SDK Manager来进行更简单，更方便的刷机。
1、刷机前的准备，同样需要一台装有ubuntu（可以是16.04，也可以是18.04）的主机，下载Nvidia SDK Manager，网站里有安装指南。
2、安装好后，打开并登录。
3、按照步骤一步一步来，第一步，选择产品类型，选择TX2；第二步，选择安装包，有主机端和TX2端，主机端不要选，TX2端全选，勾选同意协议，点击continue；第三步，开始下载，下载好后，会弹出一个窗口。以上三步见相关截图。
4、同样的这时候需要将SDK刷到TX2里，弹出上面的窗口后，选择手动安装（manual setup），同样的，按照提示，将TX2和主机用网线连接在用一个路由器或者交换机上，用ucb线将主机和TX2连接在一起。让TX2连接上电源适配器，但是断电，按下并松开TX2的POWER键；按下并保持FORCE RECOVERY键；在此期间按下并松开RESET键；等待2秒后松开FORCE RECOVERY键，接着点击flash，这时候大概率是不会报错，如果报错，重复这一步。（注：关于如何判断是否进入Recovery模式，在终端中输入lsusb指令，如果Nvidia Corp对应的ID号为0955:7c18或0955:7e19,表示进入Recovery模式；如果Nvidia Corp对应的ID号为0955:7020，表示未进入Recovery模式。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6e776898092632815f8c7f384890222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3de27e6d322fa9fdb1674709b0af1f/" rel="bookmark">
			linux下安装 erlang
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、下载erlang安装包 http://erlang.org/download/ 二、上传安装包到目标文件夹，并解压erlang安装包 tar -zxvf otp_src_22.2.tar.gz 三、重命名 mv otp_src_22.2 erlang 四、安装 erlang 的依赖工具 yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel 五、 进入 erlang目录进行安装环境的配置 #步骤1 cd erlang/ #步骤2 ./configure #步骤3 make &amp;&amp; make install PS：编译的过程可能会有点久，请耐心等待 六、验证 erlang 是否安装成功 能够正常运行说明erlang安装成功!!!
./bin/erl # 测试用例 输入语句：io:format("Hello World~n", []). 七、添加环境变量 vim /etc/profile # 找到最后一行加入以下内容 export PATH=$PATH:/data/app/hzt/erlang/bin 八、刷新环境变量 source /etc/profile 九、输入 erl 查看 erlang 环境变量是否配置正确 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81275894c51f1c0bf1cd6ea38204bd48/" rel="bookmark">
			VScode使用Remote SSH进行远程开发，跳转缓慢文件解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 众所周知，一些特定的编程语言可能需要Linux环境的支持，比如在golang代码中引用C语言，就需要使用到cgo，而这个环境配置需要Linux作为支撑。如果本机使用的是Windows环境，想要在Linux环境中进行代码编译、调试、部署，还有如下几种方式：
1. 搭建Windows + Linux双系统。Windows进行文档处理等办公操作，Linux进行开发、编译、调试等工作。缺点是，系统切换比较慢，有些沟通工具支持不好，比如在开发环境下，如果团队使用微信进行沟通，就可能导致信息延迟、沟通不畅等问题，从而影响开发效率。 2. 在虚拟机上安装Ubuntu或者Centos等Linux桌面系统。缺点是，虚拟机比较笨重，再在此基础上构建体量更加大的Linux系统，一方面对软硬件环境配置要求比较高，另一方面像一些数据库、接口调试等可视化工具使用不方面。 3. 使用VMware + VScode + Remote SSH远程开发工具 + Ubuntu Server无桌面版。虽然这种方式也使用了虚拟机 + Linux，但是相对使用桌面版系统，会节省不少空间。 使用Remote SSH构建远程开发环境 在VMware上安装完Ubuntu Server版后，进入VScode左侧扩展局域栏的Extension扩展市场，搜索Remote - SSH，然后进行Install安装。然后，使用ssh-keygen命令生成密钥对，用public key生成authorized_keys，再进入密钥所在目录cd ~/.ssh，使用scp命令将本地Windows生成的公钥上传到Ubuntu系统，通过如下命令生成authorized keys。
# 本地Windows系统生成公钥、私钥 ssh-keygen cd C:\Users\xxx\.ssh\ # 使用scp命令将公钥上传远程Ubuntu的~/.ssh目录下 scp .\id_rsa.pub xxx@192.168.xx.xxx:~/.ssh/ # 使用公钥生成authorized keys cat id_rsa.pub &gt;&gt; authorized_keys 然后，选择Remote SSH配置文件，一般选择C:\Users\xxx.ssh\config，配置如下字段信息
Host name-of-ssh-host-here User your-user-name-on-host HostName host-fqdn-or-ip-goes-here Port port-of-host IdentityFile C:\Users\xxx\.ssh\id_rsa # 私钥所在路径 配置完上面的Remote SSH后，打开VScode使用Remote SSH，选择远程Ubuntu上的项目文件，即可以进行远程代码开发。
使用VScode通过Remote SSH进行远程开发时，本地开启VScode，连接上remote ssh服务器后，会在远程服务器上生产VScode服务器版本（在~/.vscode-server目录下，该目录下有VScode的二进制文件，用户及remote ssh配置文件settings.json，还有相关扩展extensions）。
无法跳转问题 如果vscode无法跳转，可能与ssh版本有关系，首先可以通过如下命令检查git版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81275894c51f1c0bf1cd6ea38204bd48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74188c2df5e1c36f72b2f322a4e317e/" rel="bookmark">
			requests结果显示“请开启JavaScript并刷新该页”，selenium不用cookie解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Selenium爬取可不使用cookie，即可获取完整html内容 引言~~ 今天无意间看到了很多纪念币，突然一股强烈的占有欲涌上心头。虽然手里捧着窝窝头，菜里没有一滴油，但是我还是胆大妄为地想去看看纪念币的发行。
一同乱七八糟的操作后，终于在中国人民银行-货币金银局里找到了‘普通纪念币’和‘贵金属纪念币’两个公告板。于是我立刻、毫不犹豫地点进了‘普通纪念币’，结果发现发布的公告数量不多，频率也很低。转念一想，每天都点点点的也太麻烦了，于是一个大胆的想法蹦了出来：爬它！
这是第一次对类似国家网站上手，心情还是很忐忑的。话不多说。开搞。
过程~~ 第一步当然是看看robots.txt了 结果很意外，HTTP ERROR 404
虽然没有爬虫限制，但还是自觉遵守网络道德！
第二步盘代码 一开始我选择的是requests+BeautifulSoup，
import requests from bs4 import BeautifulSoup url = 'http://www.pbc.gov.cn/huobijinyinju/147948/147964/index.html' headers = {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.162 Safari/537.36', } res = requests.get(url,headers=headers) res.encoding = 'utf-8' soup = BeautifulSoup(res.text,'html.parser') print(soup) 执行后显示的结果却没有预期的内容，仔细浏览后发现了问题所在：
&lt;h1&gt;&lt;strong&gt;请开启JavaScript并刷新该页.&lt;/strong&gt;&lt;/h1&gt; 我又在CSDN一通乱翻，找到了别人的解决办法python爬虫时爬取的html代码显示“请开启JavaScript并刷新该页”，简单来说就是带rookie访问。
加上rookie后果然获取了完整的内容。
之后进行的都很顺利。直到那一刻、那一秒的到来… 那一刹，我记起了BUG带来的恐惧。
带rookie访问 虽然带rookie访问可以获取到想要的内容，但是每次rookie都要手动到网络中获取。非常的不方便。之后我又找到了自动获取rookie的方法，但是有个问题出现了~
res = requests.get(url,headers=headers) cookies = requests.utils.dict_from_cookiejar(res.cookies) （提一句，rookie一直在变）
因为一开始是无法知道rookie的，所以用不带rookie的headers，通过上面的代码获得了rookie，但是这个rookie是不能用于下一次的访问的，而下一次访问的意图正是为了带rookie而获得完整html内容。心态崩了呀！
Selenium解决 突然，我想起来了前几天写的爬虫。用了selenium的driver，想试试能不能用这个方法搞定它。不试不知道，一试真奇妙。
一开始，只想试试水
from selenium import webdriver from selenium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d74188c2df5e1c36f72b2f322a4e317e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45412613fb45c04ecb393470db5fea18/" rel="bookmark">
			python爬虫练习(一)之使用urllib获取百度贴吧中的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习编程没有一蹴而就的，无论什么时候都要记住一句话：基础不牢地动山摇！拥有一个扎实的基本功才能有更好的前途如果你对urllib库不太了解，可以去看一看我写的urllib基础，在来看这段代码，相信你会有更多的收获！
需要注意的点： 1. quote()转换中文
2. url拼接
3. 请求与响应的方式
4.怎么指定获取的起始页和结束页 5. 写入文件的格式
import urllib.parse from urllib import request ''' 网址分析： 海贼王吧 https://tieba.baidu.com/f?kw=%E6%B5%B7%E8%B4%BC%E7%8E%8B&amp;ie=utf-8&amp;pn=0 https://tieba.baidu.com/f?kw=%E6%B5%B7%E8%B4%BC%E7%8E%8B&amp;ie=utf-8&amp;pn=50 https://tieba.baidu.com/f?kw=%E6%B5%B7%E8%B4%BC%E7%8E%8B&amp;ie=utf-8&amp;pn=100 lol陪玩 https://tieba.baidu.com/f? kw=lol%E9%99%AA%E7%8E%A9 &amp;ie=utf-8&amp; pn=0 https://tieba.baidu.com/f? kw=lol%E9%99%AA%E7%8E%A9 &amp;ie=utf-8&amp; pn=50 ''' url='https://tieba.baidu.com/f?' headers={ 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.0.0 Safari/537.36' } name1=input('请输入你要搜索的贴吧名称：') # 处理name（贴吧名称） name=urllib.parse.quote(name1) start=int(input('请输入起始页：')) end=int(input('请输入结束页：')) for i in range(start,end+1): #处理页数 pn=(start-1)*50 #链接url url=f'{url}kw={name}&amp;ie=utf-8&amp;pn={pn}' #urlopen请求并接受响应url html=urllib.request.urlopen(url) html_read=html.read().decode('utf-8') #将获取到的内容写入文件 with open(f'{name1}的贴吧第{i}页.html', mode='w',encoding='utf-8')as f: print(f'正在写入第{i}页.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45412613fb45c04ecb393470db5fea18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51cfe1a907f2e3254342188de46f4960/" rel="bookmark">
			Windows7上安装pytorch1.11后报api-ms-win-core-path-l1-1-0.dll错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows7上通过Anaconda安装PyTorch v1.11.0后，执行程序时报如下图所示错误：无法启动此程序，因为计算机中丢失api-ms-win-core-path-l1-1-0.dll。尝试重新安装该程序以解决此问题。
此Windows7上，之前已安装过PyTorch的v1.8.1，可正常执行程序。
搜索后发现Windows7本身确实没有api-ms-win-core-path-l1-1-0.dll这个库。从https://cn.dll-files.com/api-ms-win-core-path-l1-1-0.dll.html 下载此库，Verison为6.3.9600.16384，最新版本。
将此库放到C:\WINDOWS\System32目录下或D:\ProgramFiles\Anaconda3\envs\pytorch1.11.0目录下，错误会变成：应用程序无法正常启动(0xc000007b)。请单击”确定”关闭应用程序。如下图所示：出现“0xc000007b”错误，说明我们刚下载的是32位的dll，但是我们是64位的程序，因此也需要64位的dll。微软官方只提供了32位的dll。
在PyTorch v1.8.1中依赖Python的版本是3.7.11；在PyTorch v1.11.0中依赖的Python的版本是3.10.4。
根本原因是Python 3.9及以上版本已不适用于Windows7。workaround的解决方法如下：
从https://github.com/nalexandru/api-ms-win-core-path-HACK/releases 下载最新版本0.3.1，即api-ms-win-core-path-blender-0.3.1.zip，解压缩，将x64目录下的api-ms-win-core-path-l1-1-0.dll拷贝到D:\ProgramFiles\Anaconda3\envs\pytorch1.11.0目录下，再次执行以上程序显示正常，如下图所示：
GitHub： https://github.com/fengbingchun/PyTorch_Test
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c19bbe085312bccb87ba508339fc49c/" rel="bookmark">
			软构复习3 软件构造过程与版本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SDLC（软件开发的生命周期）
从无到有，从1到n
二、软件流程模型：
两类基本类型：
线性过程，迭代过程
现有的软件流程模型： 瀑布过程： • 线性推进 • 阶段划分清楚 • 整体推进 • 无迭代 • 管理简单 • 无法适应需求增加/变化 增量过程（非迭代）： • 线性推进 • 增量式（多个瀑布的串行） • 无迭代 • 比较容易适应需求的增加 V型模型：用于验证，是瀑布式的延伸
原型过程（迭代）
迭代：开发出来之后由用户试用/评审，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。 循环往复这个过程，直到用户满意为止。 时间代价高，但开发质量也高。 螺旋（迭代）
三、敏捷开发：
通过快速迭代和小规模的持续改进，以快速适应变化
Agile = 增量 + 迭代 每次迭代处理一个小规模增量 四、软件配置管理(SCM)和版本控制系统(VCS) 软件配置管理：追踪和控制软件的变化 软件配置项（SCI）：软件中发生变化的基本单元（例如：文件）（build-time,component,period） 基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本） CMDB：配置管理数据库 存储软件的各配置项随时间发生变化的信息+基线 版本控制：为软件的任意特定时刻指派一个唯一的编号，成为身份标识 用于：回退到上个版本，比较两个版本之间的差异，备份，合并，在多个开发者之间共享协作，记录每个开发者的动作，方便审计 仓库：即于SCM中的CMDB 工作拷贝：在开发者本地机器上的一份项目拷贝 文件：一个独立的配置项 版本：在某个特定时间点的所有文件的共同状态 变化：即code churn，两个版本之间的差异 HEAD：程序员正在其上工作的版本 版本控制系统（VCS） 本地VCS：
仓库存储于开发者本地机器，无法共享协作 集中式版本控制系统：仓库存储于独立的服务器， 支持多开发者之间的协作 分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器 五、Git：
git仓库的三个组成部分：
git directory：本地的CMDB
working directory：工作目录：本地文件系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c19bbe085312bccb87ba508339fc49c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba2beb6650ebb434c5d2174ca098110/" rel="bookmark">
			easy-x常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## easy-x库常用函数 (1)：与设备相关的函数
1.void clearcliprgn()：用于清除种植区域。
2.void cleardevice()：此功能用于清除绘图设备。具体地说，绘图设备将以当前背景色清空，并将当前点移动到(0,0)。
3.void closegraph();用于关闭图形窗口
4.void getaspectratio(float *pxasp,float *pyasp)：用于获取当前的长宽比
5.void graphdefaults()：用于将视图、当前点、绘图颜色、背景颜色、线条样式、填充样式、字体样式重置为默认。
6.HWND initgraph(int width,int height,int flag = NULL)：此函数用于初始化图形窗口
7.void setaspectratio(float xasp, float yasp)：本功能用于设置当前长宽比。
8.void setcliprgn(HRGN hrgn);此功能用于设置当前绘图设备的剪切区域。
9.void setorigin(int x, int y);该函数用于设置坐标原点。x
原点的x坐标(使用物理坐标)。y 原点的y坐标(使用物理坐标)。
(2)：颜色模型相关函数
10.COLORREF BGR(COLORREF color)：BGR宏用于交换红色和蓝色。
11.BYTE GetB（G|R）Value(COLORREF rgb)：宏GetB（G|R）Value用于返回指定颜色的蓝（绿|红）色值。
12.COLORREF HSLtoRGB( float H, float S, float L)：用于将HSL颜色转换为RGB颜色
13.COLORREF HSVtoRGB( float H, float S, float V)：此函数用于将HSV颜色转换为RGB颜色
14.COLORREF RGB( BYTE Red,BYTE Green, BYTE Blue )：以三原色色彩体系定义一种颜色
15.COLORREF RGBtoGRAY(COLORREF rgb)：用于返回与指定颜色对应的灰度颜色。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fba2beb6650ebb434c5d2174ca098110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a257a1c4739d9b9448992b9c93b09ffe/" rel="bookmark">
			软构复习2测试与测试优先的原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、测试
测试无法达到百分百的无错误
1-10个错误每千行代码：标准工业级软件
0.1-1个：高质量的验证（Java库能达到）
0.01-0.1个：极高质量的，严格安全的如NASA，Praxis等公司
再好的测试也不能证明系统无错误，测试时的目标应该是破坏性的，证错的
好的测试的特点：能发现错误，不冗余，最佳特性，既不太复杂也不太简单
测试的等级：
单元测试（功能层面，一个方法，函数），集成测试（类，包等），系统测试（一个体系系统），验收测试
静态测试：用眼睛看，检查代码，浏览代码
动态测试：执行程序来发现错误
测试：发现错误 调试：找到错误根源，消除错误
白盒测试：对程序内部代码结构的测试 黑盒测试：对程序外部表现出来的行为的测试 测试困难的原因：暴力穷举不可能；偶然测试没有意义 ；基于样本的统计数据对软件测试意义不大—软件与产品的巨大差异；软件行为在离散空间中差异巨大：大多数正确，少数错误；无统计规律可循； 测试时转变心态：让代码尽快出错 二、测试用例： test case = {test inputs + execution conditions+ expected results} 测试用例：输入+执行条件+期望结果 三、测试优先的编程 先写spec，再写spec的测试用例，再写代码，测试，发现问题，解决问题，重复步骤 写测试用例就是不断理解，修正，完善spec的过程 测试优先会节省大量的调试时间 四、单元测试： 针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试 前面要声明@Test 一般以test+被测试单元名称命名，且用断言式，一般期望值在前 Test目录和src目录一样，且两个文件夹可以放入同一个包中来方便访问被测试的成员 五、黑盒测试： 检查代码功能，不关心内部实现细节 检查程序是否符合规约，用尽可能少的测试用例，尽快运行，发现尽可能大的程序错误 1.通过等价类划分选择测试用例： 针对每个输入数据需要满足的约束条件，划分等价类 基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为 测试用例即可，进而降低测试用例数量 2.在分区中包含边界（BVA）： 边界值分析方法是对等价类划分方法的补充 在等价类划分时，将边界值作为等价类之一加入考虑 例如：小于最小值，最小值，略大于最小值，略小于最大值，最大值，大于最大值 覆盖分区的两种极端： 1.笛卡尔积全覆盖，多个维度的每个情况都要有一种组合，但是实际并非所有组合情况都可能 测试完备，但是用例数量多，代价高 2.最小覆盖：每个维度的每个取值至少被覆盖一次即可 用例少，代价低，但是覆盖度未必高 六、白盒测试： 考虑内部代码实现细节 根据程序内部路径实现测试用例 典型的白盒测试：独立/基本路径测试：对程序所有执行路径进行等价类划 分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试 用例使每一条基本路径被至少覆盖1次。 七、测试覆盖度： 测试效果：路径覆盖&gt;分支覆盖&gt;语句覆盖 测试难度同上，但是路径数目巨大，难以全覆盖 实际当中，根据预先设定的覆盖度标准，逐步增加测试用例的数量， 直到覆盖度达到标准（例如语句覆盖100%、路径覆盖90%） 八、自动测试和回归测试 自动： 自动调用被测函数、自动判定测试结果、自动计算覆盖度 只是测试用例的自动执行，而非自动生成测试用例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a257a1c4739d9b9448992b9c93b09ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a3ce88fd5c1e0e756f22b194ffb834/" rel="bookmark">
			春节期间重装anaconda&#43;opencv血泪史分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于网络上的分享 进过2022年2月~6月这一段时间重装2次(指达到目的的次数)的血泪史，阅读国内外众多苦主的分享后，我意识到，其实大家都是不明白深层或根本原因，不清楚全面彻底解决问题的方法以及解决问题的机理，只是在不断沟通和尝试中发现的自己成功经验。
因此，如果本分享帮助到各位，本人深感实现自我价值的快乐；如果相反，那么也恳请各位在找到解决问题的方法后，请留言或私信指点批评，我不胜感激~
故事背景 本人在学习KMeans算法的时候在import sklearn库中函数时，发生一系列bugs(真的是bugs，解决了一个问题马上出现新的问题，最后博主崩溃)导致我不得不选择重装anaconda。重装之后虽然sklearn库的问题消失了(这里不能说解决了，你们懂的)，然而opencv库居然无法安装，于是博主不得不研究这个新的问题……
一、重装Anaconda 1.1 卸载anaconda ①如何彻底的卸载anaconda（包括配置文件）【written by kuweicai】https://blog.csdn.net/kuweicai/article/details/90145242②Anaconda如何卸载干净【written by Skilllllll】https://blog.csdn.net/qq_43200548/article/details/104806678?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_aa&amp;utm_relevant_index=6③【官方文档】Uninstalling Anacondahttps://docs.anaconda.com/anaconda/install/uninstall/ 之前博主也“惯性地”直接采用win11界面的“开始→设置→应用→应用和功能”中找到python x.x(anaconda...)卸载。但这次灵光乍现质疑这样卸载会不会不够“科学”，于是查找资料，发现CSDN上数位博主分享了比较符合官方文档提供的卸载教程，能够比较完全地卸载anaconda。
个人推荐按照官方文档的步骤卸载anaconda，如果阅读英文文档有困难的小伙伴也可以参考上面两位博主的博客。
1.2 安装Anaconda 这部分网上有大量教程，博主不过多赘述，但也为小白们提供官网教程参考阅读。
anaconda官方文档https://docs.anaconda.com/anaconda/ 1.3 添加清华源【2022.06.04 update】 运行Anaconda Prompt，在命令行中一次运行如下命令：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 运行完毕后，即添加了清华镜像，好处就是下载库更快~
二、问题来了，有直行也有岔路 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20a3ce88fd5c1e0e756f22b194ffb834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13e4ebd51a5ecc049e29eb7affcd847/" rel="bookmark">
			CUDA中动态Global Memory分配和操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA中动态Global Memory分配和操作 CUDA中动态Global Memory分配和操作1. Heap Memory Allocation2. Interoperability with Host Memory API3. Examples3.1. Per Thread Allocation3.2. Per Thread Block Allocation3.3. Allocation Persisting Between Kernel Launches 动态全局内存分配和操作仅受计算能力 2.x 及更高版本的设备支持。
__host__ __device__ void* malloc(size_t size); __device__ void *__nv_aligned_device_malloc(size_t size, size_t align); __host__ __device__ void free(void* ptr); 从全局内存中的固定大小的堆中动态分配和释放内存。
__host__ __device__ void* memcpy(void* dest, const void* src, size_t size); 从 src 指向的内存位置复制 size 个字节到 dest 指向的内存位置。
__host__ __device__ void* memset(void* ptr, int value, size_t size); 将 ptr 指向的内存块的 size 字节设置为 value（解释为无符号字符）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13e4ebd51a5ecc049e29eb7affcd847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcabe19e8951f2a6ab4a452505627e58/" rel="bookmark">
			某微信小程序连锁超市响应参数解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序名称：
57qi5peX6L+e6ZSB5ZOB5ZWG5Z+O
抓包 请求
POST /?web046&amp;tims=1654269437000,A8Iis6GGN2lkVJM1WdkuGd1Ux/tKJpwyCW8I354g+HU=&amp;tk=GwS4fe4eKzUbO6/g4tNkKg== HTTP/1.1 Host: www.hqwg.com.cn Connection: close Content-Length: 402 charset: utf-8 User-Agent: Mozilla/5.0 (Linux; Android 10; MI 8 Build/QKQ1.190828.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/86.0.4240.99 XWEB/3225 MMWEBSDK/20220402 Mobile Safari/537.36 MMWEBID/8261 MicroMessenger/8.0.22.2140(0x28001657) WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64 MiniProgramEnv/android content-type: application/json Accept-Encoding: gzip,compress,br,deflate Referer: https://servicewechat.com/wxd83270faef1a8689/94/page-frame.html {"json":"V/huXeWtzjg9kIpJdqNd22qf3EskWegXcKPpx+PdQjH/GGFK5EdfhcCBbhCHBdHsw0I6TpTO1LA9lQzFMMW/nNozRYM0BrWe0Rc+6H09fjeaumAg4Zii3EIidFVpicvlZKO6nYN/mMQX6Usz1Qt304u8nzdX4Wc1KH4BNiadAOLxsBaeO2gMUjJh/DOZsjePLmAp4dF60Sgr1rEkSm/GzcagJuQa0EY3YGBlLF2BTiFXbBJ7cOxP3K4ZbcgnFFYA/B/1rtRmwq1YA5fU/v4MwFaGiG/c+0X5j2zeOzc5HqAiWIJ7oK2JKQepAfcfTiHsI24QLFc9mjgSmLTbsUzxCV4ftayc+I4dZ1+UWMcgxj8qvvVezed8sg==","mdl":"web046"} 返回数据
1sRiKSwCkGRMaVkChPmLKjw2YY8h+VAKq14r5HTtx7Mus6HKEOnpbwdHR4yeQCI5IdbZYEgr29R2XWRMRvebYMeP0KLyIpaOK+exCUNeunUl5SQnQutbNOugp2IcaOQFFpCl2EvAfb2+uAhw3RNXflE4WVe0TetPEf3chlUfjcRNkrwd0UnI5Fq6tlVC2ILGEaitz6CbyRe6VW7nYCBszw7MI/x0gGVGIsXWxl0tUrk54+yzZALZ7nPa4kW/K11F+n/cMo0xHj4wNM6zPRMBpAssLmdSqoieJ1IuxdCXYpmzZN3o6rceDS3hYGv7F1q48vNtK/7hH3WTips1tLDJYfez38euVrrFU2NqLcOPkcB9tS4//Fr502YDSYwnWzNCl6ZYsxoBqXchK3slaFS9POuzpRmWBMmwAvIsI3Jpsd/RRhdkhM1xY/6bu4l6QVrAZ6sNbEguV3jwADc6B//FJeQHACrifABFr0eXRjUWk7DzgJGLg93ACqgWQG+FAKdyj8DRhTehEhjNH9NZSfN88z186VlZJQfZgLyDTMR1pOa8angnLwZAIXwkhJemNhD3x0xSNoin5ekQbzIPGmEho8Rc/+lMdg7Gkse7shWEFd+ZxVukwwkliSj7QSijyBjhp8WxOoy0KP48BZ7cY+A/0OVMafzWSEbqZo/j2HnigfCfy8amOt1D4P7ts6inio1Fd1WuQmgPPYRVcv/kaUUHd/+wZKPTmNlXHcOtyhQnmMGSQVRB/GxnqeQo0+1ydvmvik8kgONF5lJFpczV+WStUu5BjGoYxEa0I+xjHtZ4RsHgNtA9322b3KATDk3hG8t1Nx3xW4NReAz/Wv18daCtjgSzEpoFw1GL63Of2ZOf4nVjxTmycIJKMXq+ZOktTwQ419mBi2MpgqEWuENznBuThC84Vx1sWFemZ6IVpacVQ330w4anuqNGheNzAZ1MWXESYeAN8MpnEnPMTq9dXj3SYXh7ptjs9RVkhkLqkaZxOl5hnU5ZQDeUImbkKnC9TPdPL6hWFUtsUC2gXesX0WIIC+3fjKt2zlxjf7UeEvsuHVqUpmmJRHf2Ik6eZGBI/olJFXzXlKx9fY2eAtLn/x72n4q7C9EeD5K86qUHNX5PwZMxKC3DyiJKDv6ku5Ha8Y8tV8/HiUMFl6eIGeDO6YtfRmvkTSoaHgyUh7iwaEINsPznAjXMHMsDBTfyD7sdhwE0XZDLt1/xCiWUrG350thJET3BxGPo7pZAtyeN6losbpxiEVLvty/Oq+I3slL8pjB9oS+Xr9fqtAPbGibd6/VK/diXu+RPGfKL 微信小程序解包 相关定位 根据链接里边所提供的相关参数我们可以定位到
很明显可以看到上方方法定义里边有一个加密一个解密函数
我们试着扣代码试试；
当然，我们也要把引用的CryptoJS.js一块拿过来了
然后我们开始对返回的body进行解密
代码自己动手扣吧！翻译的代码有时间再放出来吧！
详细代码以及微信解包请查看：https://download.csdn.net/download/weixin_45171937/85540785
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e39c6b943ee0cce0edf070b180a464cd/" rel="bookmark">
			日期控件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日期控件的使用 日期选择是常用的一个需求，今天来稍微总结下a-date-picker和a-range-picker的使用
这里使用的 v1.7.8版本
基本使用 &lt;a-date-picker :locale="locale" :showToday="false" :valueFormat="valueFormat" :disabled-date="disabledDate" @change="onChange" /&gt; &lt;a-range-picker :locale="locale" :valueFormat="valueFormat" :disabled-date="disabledDate" @change="onChange2" &gt;&lt;/a-range-picker&gt; 默认显示的是英文，第一个导入让日期控件显示中文；但是发现月份显示的还是英文，接下来的3行，是为了解决中英文混合的问题，
&lt;script&gt; import locale from "ant-design-vue/es/date-picker/locale/zh_CN"; import moment from "moment"; import "moment/locale/zh-cn"; moment.locale("zh-cn"); export default { data() { return { locale, valueFormat: moment().format("YYYY-MM-DD"), // 日期格式为2022-06-03这种格式 disabledDate: (current) =&gt; { // 禁用了今天之后的时间的选择 return current &amp;&amp; current &gt; moment().endOf("day"); }, }; }, methods: { onChange(today，selectedDate) { console.log(today，selectedDate); }, onChange2(today，selectedDateArr) { console.log(today，selectedDateArr); }, }, }; &lt;/script&gt; 常见参数及使用说明： 参数说明值补充locale语言类型默认是英文valueFormat设置日期值的格式默认是一个moment对象showToday是否显示今天的按钮Boolean默认为true显示今天按钮value(v-model)默认值为moment对象renderExtraFooter底部添加自定的内容vslot比如一些快捷的时间选择按钮，确定按钮等dateRender自定义单元格内容和样式vslot比如使用圆圈替换默认的矩，当然也可以直接css设置disabledDate设置不可选择的日期fngetCalendarContainer日期控件放在哪里，默认是body中fntrigger=&gt;{ return trigger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e39c6b943ee0cce0edf070b180a464cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a888b4aa5b0432632175ac7d0e22b35/" rel="bookmark">
			C#序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化是将对象或对象图转换成字节流的过程。反序列化是将字节流转换回对象图的过程。序列化可以用于应用程序状态的保存、剪贴板复制/粘贴对象、对象克隆和网络对象传输等。序列化的方式有：
1) BinaryFormatter 早期的序列化方式，存在安全风险，不推荐使用。
2) BinaryReader/BinaryWriter 二进制读写Primitive Type，并支持字符串读写时的编码设定。
3) XML序列化
4) Json序列化 除了MS提供的库外，Newtonsoft.json非常好用。
因为BinaryFormatter存在大量的存量使用，做个简单记录。使对象能够通过BinaryFormatter序列化有特性和接口两种实现方式。当特性和接口同时使用时，忽略特性。接口对数据进行完全的控制，且避免使用反射。
1、通过特性实现
[Serializable] class Circle { private double _radius; [NonSerialized] private double _area; public Circle(double radius) { _radius = radius; _area = Math.PI * _radius * _radius; } public double Area { get =&gt; _area; } [OnDeserialized] private void OnDeserialized(StreamingContext context) { _area = Math.PI * _radius * _radius; } } class Program { static void Main(string[] args) { Circle circle = new(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a888b4aa5b0432632175ac7d0e22b35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bb6ebb4996f3a91cb8478adfe5135a/" rel="bookmark">
			HBuilderX：HBuilderX安装以及其常用插件安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBulderX安装 HBuilderX下载地址：https://www.dcloud.io/hbuilderx.html
下载后解压即可使用！
插件安装 打开工具-插件安装
下载需要账号，有HBuilderX账号可以直接登录下载，没有的就需要注册后下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f6e587b8efee7211f8f2db89bc63a1/" rel="bookmark">
			MSQL写入中文报错，Incorrect string value: ‘\xE5\xBC\xA0\xE4\xB8\x89‘ for column ‘name‘ at row 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学mysql，在插入中文时报错，经查阅资料发现是编码错误。需要修改数据库编码格式。
问题：
在mysql中插入中文时报错：Incorrect string value: '\xE5\xBC\xA0\xE4\xB8\x89' for column 'name' at row 1
解决方案：修改数据库编码格式
执行命令查看数据库编码：
mysql&gt; show variables like "%char%"; 执行结果： 这几个变量代表的含义是：
character_set_client: 设置客户端使用的字符集。
character_set_connection: 设置连接数据库时的字符集，如果程序中没有指明连接数据库使用的字符集类型则按照这个字符集设置。
character_set_database: 设置默认创建数据库的编码格式，如果在创建数据库时没有设置编码格式，就按照这个格式设置。
这一栏的编码为latin1，此编码不支持中文，需要修改
character_set_filesystem: 文件系统的编码格式，把操作系统上的文件名转化成此字符集，即把 character_set_client转换character_set_filesystem， 默认binary是不做任何转换的。
character_set_result: 数据库给客户端返回时使用的编码格式，如果没有指明，使用服务器默认的编码格式。
character_set_server: 服务器安装时指定的默认编码格式，这个变量建议由系统自己管理，不要人为定义。
character_set_system: 数据库系统使用的编码格式，这个值一直是utf8，不需要设置，它是为存储系统元数据的编码格式。
character_set_dir: 这个变量是字符集安装的目录。
// 引用自关于MySQL中的8个 character_set 变量说明_qq_34352013的博客-CSDN博客_character_set_filesystem
尝试修改character_set_database变量
执行命令修改character_set_database变量：
set character_set_database = utf8; 修改后再次查询编码：
mysql&gt; show variables like "%char%"; 执行结果：
character_set_database变量已经修改成功，再次尝试插入中文字符
插入成功！问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dcaa9afa4bb63ec94608b700b58a02b/" rel="bookmark">
			yolox修改focalloss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://www.csdn.net/tags/MtTaEgxsNTQ4MTE2LWJsb2cO0O0O.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc607558a07de2de91bddedd98d58ed/" rel="bookmark">
			Echarts 数值（label）颜色设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Echarts 数值（label）颜色设置 柱状图、折线图等图表上的数字需要展示不一样的颜色。比如：
条形柱状的颜色可以在series-itemStyle中通过color进行设置，并且每一根都可以设置为不同。因为color可以定义为function，可以直接在function内判断设置return出所需要的颜色即可， 由于textStyle中的color 只能设置为字符串，所以以上方法是没有作用的。但可以通过以下两种方式设置。
第一种：可以利用富文本样式来设置 效果图：
完整代码：
import * as echarts from 'echarts'; var chartDom = document.getElementById('main'); var myChart = echarts.init(chartDom); var option; option = { tooltip: { trigger: 'axis', axisPointer: { type: 'cross', crossStyle: { color: '#999' } } }, toolbox: { feature: { dataView: { show: true, readOnly: false }, magicType: { show: true, type: ['line', 'bar'] }, restore: { show: true }, saveAsImage: { show: true } } }, legend: { data: ['Evaporation', 'Precipitation', 'Temperature'] }, xAxis: [ { type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'], axisPointer: { type: 'shadow' } } ], yAxis: [ { type: 'value', name: 'Precipitation', min: 0, max: 250, interval: 50, axisLabel: { formatter: '{value} ml' } }, { type: 'value', name: 'Temperature', min: 0, max: 25, interval: 5, axisLabel: { formatter: '{value} °C' } } ], series: [ { name: 'Evaporation', type: 'bar', tooltip: { valueFormatter: function (value) { return value + ' ml'; } }, data: [ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfc607558a07de2de91bddedd98d58ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a5cd11f23e4e39a184dff8ef13d7c5/" rel="bookmark">
			idea下载插件的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过idea软件提供的方式下载
file --&gt; settings–&gt;plugins搜索即可
外部安装导入-直接安装
2.1 登录插件库：https://plugins.jetbrains.com/idea
2.2 查询需要的插件，并且直接对应到你的软件，直接安装到idea，重启idea
外部安装导入-配置安装
下载对应的插件
然后idea导入，然后重启idea即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70a00e31f02ac6731abca757121ce4e/" rel="bookmark">
			java培训SpringBoot 实现 Office 各种格式在线预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.项目特性
支持word excel ppt，pdf等办公文档支持txt,java,php,py,md,js,css等所有纯文本支持zip,rar,jar,tar,gzip等压缩包支持jpg，jpeg，png，gif等图片预览（翻转，缩放，镜像）支持mp3，mp4，flv等多媒体文件预览使用spring boot开发，预览服务搭建部署非常简便rest接口提供服务，跨平台特性(java,php,python,go,php，....)都支持，应用接入简单方便支持普通http/https文件下载url、http/https文件下载流url、ftp下载url等多种预览源提供zip，tar.gz发行包，提供一键启动脚本和丰富的配置项，方便部署使用提供Docker镜像发行包，方便在容器环境部署抽象预览服务接口，方便二次开发，非常方便添加其他类型文件预览支持最最重要Apache协议开源，代码pull下来想干嘛就干嘛 2.部署过程
部署方式，可以直接下载二进制步骤，也可以通过docker直接拉取，还可以通过源码编绎进行，下面分别说明
前提条件：Jdk需要先安装设置好，kkFileWiew是Java开发的，Jdk必需。
tar -xvf jdk-8u191-linux-x64.tar.gz -C /usr/local
cat &gt;&gt; /etc/profile &lt;&lt; EOF
export JAVA_HOME=/usr/local/jdk1.8.0_191/
export PATH=\$JAVA_HOME/bin:\$PATH
export CLASSPATH=.:\$JAVA_HOME/lib/dt.jar:\$JAVA_HOME/lib/tools.jar
EOF
source /etc/profile
[root@localhost testuser]# java -version
java version "1.8.0_191"
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)
2.1 二进制下载部署文件进行部署
1.从码云发行版本下载最新版发行包，这里只以linux为例，一般服务器都是linux的，如果用windows也可，看官网说明进行。
2.解压kkFileView-x.x.x文件（Windows用.zip包，Linux/MacOS用.tar.gz包），如：
tar xvf kkFileView-4.0.0.tar.gz -C /opt/
3.运行startup脚本（Windows下以管理员身份运行startup.bat，Linux以root用户运行startup.sh）
cd /opt/kkFileView-4.0.0/bin
注：linux下kkFileWiew需要LibreOffice的支持，因此startup.sh会判断系统是否已安装LibreOffice,如果没有安装，将自动下载安装，因此需要有互联网环境的支持，如果是内网的机器，可以考虑在一台有互联网环境下的机器上搭建一个http代理服务器，然后通过export命令设置通过代理下载，如在192.168.56.1上搭建了一个http代理（设置了账号和密码），可以通过如下命令执行，然后再执行startup.sh
export http_proxy=http://admin:admin123@192.168.56.1:1080
export https_proxy=http://admin:admin123@192.168.56.1:1080
export no_proxy='127.0.0.1'
运行startup.sh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f70a00e31f02ac6731abca757121ce4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b05a071daa5b8227cecb0614ed124c58/" rel="bookmark">
			gin 多结构体嵌套 效验范例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者工作中遇到需求，需要多级别效验 结构体，但是范例很少，特意留下范例，写得不好，请轻喷
版本： github.com/go-playground/validator/v10
主结构体
type SceneProcessUpdateRequest struct { Chat *Chat `json:"chat" form:"chat" binding:"required_without=Name"` // 流程json UpdateNote *NodeList `json:"update_note" form:"update_note" binding:"required_without_all=Name DeleteNote"` // 需要更新的节点 ,Name DeleteNote 不存在时必传 DeleteNote *DeleteNote `json:"delete_note" form:"delete_note" binding:"required_without_all=Name UpdateNote"` // 需要删除的节点 ID string `json:"id" form:"id" binding:"required"` // 流程ID SceneID string `json:"scene_id" form:"scene_id" binding:"required"` // 场景ID Name string `json:"name" form:"name" binding:"required_without=Chat"` // 名称 IsComplete int32 `json:"is_complete" form:"is_complete" binding:"required_with=Chat,omitempty,oneof=1 2"` // "是否完整，1是 2否" Chat存在时必须存在，不存在时，可为空 } type Chat struct { NodeList []NodeList `json:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b05a071daa5b8227cecb0614ed124c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82878bbd52d76b8abdc17cc77c59d7b/" rel="bookmark">
			OAuth2相关知识和理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 什么是OAuth2？
2 OAuth2核心-令牌Token是什么？
3 OAuth2的优势
4 OAuth2的缺点
5 OAuth2的相关术语与其关系
5.1 角色
5.2 其他术语
5.3 交互关系
6 OAuth2的授权方式（Flows）
6.1 授权码模式（Authorization Code）
6.2 简化模式（Implicit）
6.3 密码模式（Resource Owner Credentials）
6.4 客户端模式（Client Credentials）
7 刷新令牌（Refresh Token）
8 授权流程渠道（Channels）
9 客户应用类型
10 令牌类型
11 如何选择授权类型
12 授权服务器的组成
13 对OAuth2的误解
文档链接
1 什么是OAuth2？ 是一个代理授权的框架/协议是基于令牌Token的授权（无需用户密码也能拥有访问权限）认证和授权解耦分离主流的标准安全框架，可以支持多种使用场景 服务器WebApp浏览器单页SPA无线/原生APP服务器对服务器之间 OAuth使用代理协议的方式解决了密码共享反模式问题。
2 OAuth2核心-令牌Token是什么？ 给应用赋予有限的访问权限，让应用有权限去访问用户数据。
举个例子，你把你的保时捷911停到一家酒店，那么你会给酒店服务员保时捷钥匙帮你停车，你给服务员的钥匙，是有限制的，不能行使太远的距离，也不能打开车里的柜子或者是后备箱。
给服务员的钥匙是一个仆从钥匙，相当于令牌Token。
OAuth2的本质就是如何获取token，如何使用token。 3 OAuth2的优势 比OAuth1.0更易于实现和理解，也是主流（OAuth1.0有点复杂，而且跟OAuth2几乎是不相干）更安全，避免暴露了用户密码，服务器端更易集中保护广泛传播并被持续采用，成为主流token有效期较短并且可以自定义封装token资源服务器和授权服务器解耦集中式授权，简化客户端HTTP/JSON友好，易于请求和传递token支持多种架构场景客户可以自定义权限 4 OAuth2的缺点 协议框架过于宽泛，导致兼容性和互操作性较差和OAuth1.0不兼容OAuth2.0不是一个认证协议，是一个授权框架，本身并不能告诉你任何用户信息。 5 OAuth2的相关术语与其关系 5.1 角色 客户应用 - 想要访问用户的受保护资源资源服务器 - 用户的受保护数据保存在此授权服务器 - 在客户应用成功认证并获得授权后，向客户应用颁发访问令牌（Access Token）资源拥有者 - 想要分享某些资源给客户应用 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d82878bbd52d76b8abdc17cc77c59d7b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/139/">«</a>
	<span class="pagination__item pagination__item--current">140/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/141/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>