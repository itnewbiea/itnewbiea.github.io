<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b39da348c80731c6764618342a55eb/" rel="bookmark">
			Oracle数据库面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是数据库？
使用数据结构存储数据的仓库。
2、什么是关系型数据库？
使用关系模型存储数据的数据库。
关系模型指表与表之间的关系，包含一对一、一对多、多读多。
3、什么是非关系型数据库？
使用非关系模型保存数据的数据库。例如列存储、键值对、文件形式。
4、说一说数据库三大范式？
第一范式，表中字段是原子的，不可再分；
第二范式，表中字段必须依赖主键的全部字段，不能只依赖一部分；
第三范式，表中字段必须直接依赖主键，不能存在传递依赖。
其实真正的数据库设计并没有遵循三大范式，特别是OLAP型数据库
5、说一说对DML、DDL、DCL语言的理解
DML：数据库操纵语言，例如update、insert、delete对表中数据操作的语言；
DDL：数据库定义语言，例如create、drop、alter、truncate等对数据库对象操作的语言；
DCL：数据库控制语言，例如grant、revoke、commit、rollback、savepoint对事物控制的语言。
6、delete与truncate的区别？
1）Delete是DML语言，truncate是DDL语言；
2）delete删除时写undo日志，truncate不写undo日志；
3）delete删除后可以找回数据，truncate是永久删除；
4）delete可以全删也可以删除部分数据，truncate只能全部删除数据；
5）delete删除高水位线不变，truncate删除会重置高水位线。
7、表的分类
1）堆组织表，我们最常用的一种表，分配的存储空间是不连续的，无组织的；
2）索引组织表，将表中所有字段有序存储的一张表，可以把整张表看作一个索引；关键字：
3）临时表，用来临时存储数据的表，可以用在存储过程中保存中间结果。关键字：
4）聚簇表，如果一些表有一些共同的列，则将这样一组表存储在相同的数据块中
聚簇还表示把相关的数据存储在同一个块上。分为：Hash clustered table与索引聚簇表。Hash clustered table与索引聚簇表非常相似,只有一个主要区别:聚簇键索引被一个hash函数所取代,表中的数据就是索引.
5）对象表，先定义一个对象类型，再创建一个对象类型的表
6）嵌套表，一个表作为另一个表的字段
7）外部表，使用外部文件存储数据，需要先在磁盘空间中指定一个目录存储数据文件
8、分区表的分类
范围分区、列表分区、哈希分区、复合分区（范围—列表、范围—哈希）
范围分区：每个分区给分区字段指定一个区间，最后需要创建一个maxvalue分区
列表分区：每个分区给分区字段设置一个或多个值，有时候需要创建一个default分区
哈市分区：分区的范围不可控，系统使用hash函数自动计算数据应存储在哪个分区
9、分区的优点和缺点
优点：
1）提高查询速度
2）减少IO操作
3）提高可用性，一个分区出错，不影响其他分区数据使用
4）减少恢复时间，一个分区出错，只对当前分区恢复
5）操作分区表可以像操作普通表一样简单
缺点：
数据如果没有映射到分区，将会报错
按时间划分的分区，需要定期增加分区
10、索引的是什么？使用索引的优缺点
索引是一种排好序的数据结构。
优点：提高查询速度
缺点：占用空间，insert、delete、update需要维护索引
11、索引分类
主键索引：作为主键的字段不能全空，主键必须唯一
唯一索引：作为索引的字段可以全为空，索引字段必须唯一
普通索引：
组合索引：一个索引包含两个及以上字段
函数索引：使用函数创建的索引
倒叙索引：将字段倒排序之后创建索引
反向键索引：将字段中数据从头到尾颠倒过来后创建索引
位图索引：与以上所有的数据结构不同，是一张表，对索引字段值组合出所有情况，并比较每一行数据的索引字段值的分部。
12、创建索引的注意事项
1）一个表上的索引个数不应超过5个
2）对经常一起使用的字段，建组合索引
3）不要在频繁修改的字段上建索引
4）不要对识别率不高的字段建索引
5）不要对持续增加分区的分区表建全局索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b39da348c80731c6764618342a55eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5e994cd8a406fd0c158ad6696b1c3d/" rel="bookmark">
			Android插件化（一、插件化基本原理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件化简介 插件化概念 插件化开发就是将整个app拆分成很多模块，每个模块都是一个apk，最终打包的时候将宿主apk和插件apk分开打包，插件apk通过动态下发到宿主apk。
插件化优点 宿主和插件分开编译可并发开发，都是apk，开发互不影响（宿主需要给插件下发一个context）动态更新插件按需下载模块可解决方法数超过65536的问题 插件化难点 插件化需要解决的问题 插件中代码的加载与主工程的相互调用插件中资源的加载与主工程的相互访问四大组件生命周期的管理 解决方法 插件中代码的加载与主工程的相互调用
类加载
Android中对于外部apk的类加载有两种常用的类加载器，DexClassLoader和PathClassLoader,他们都继承自BaseDexClassLoader区别在于调用父类构造器时，DexClassLoader多传了一个optimizedDirectory 参数，这个目录必须是内部存储路径，用来缓存系统创建的dex文件，我们可以用DexClassLoader去加载外部apk，用法如下
双亲委派机制
ClassLoader在加载类时，先查看自身是否已经加载过该类，如果没有加载过会首先让父加载器去加载，如果父加载器无法加载该类时，该类才会调用自身的findClass方法去加载，该机制很大程度上避免了类的重复加载。
ClassLoader的加载过程
DexClassLoader重载了findClassLoader方法，在加载类时会调用其内部的DexPathList去加载，
DexPathList是在构造DexClassLoader时生成的，其内部包含了DexFile。DexPathList的loadClass()会去遍历DexFile知道找到需要加载的类。
插件中的类加载
通过给插件生成相应的DexClassLoader便可以访问其中的类，有两种处理方式，单DexClassLoader和多DexClassLoader
互相调用：
插件调用主工程
在构造插件的ClassLoader时会传入主工程的ClassLoader作为父加载器，所以插件可以直接通过类名引用主工程的类。
主工程调用插件：
若使用多classLoader机制，主工程引用插件的类需要先通过插件的ClassLoader加载该类，再通过反射调用其方法，插件化框架一般会通过统一的入口去管理对各个插件中类的访问，并且做一定限制。
若使用单ClassLoader机制，主工程可以直接通过类名去访问插件中的类，该方式有一个问题，若两个不同插件工程引用了同一个库的不同版本，程序可能会报错，所以一定要通过一些规范去避免该情况的发生。
资源加载
Android系统通过Resource对象加载资源，该对象生成过程如下：
因此，只需要将插件apk的路径加入到AssetManager中，就可以实现对插件资源的访问。但是AssetManager并不是一个public的类，因此实现时需要用反射去创建。
和代码加载过程相似，插件和主工程的资源关系也有两种处理方式。
·合并式：addAssetPath的时候加入所有插件和主工程路径
·独立式：各个插件只添加自己的路径
注：合并式由于AssetManager中加入了主工程和所有插件的路径，生成的Resource可以访问主工程和插件的所有资源，但是由于插件和主工程都是独立编译的，所以生成的资源ID会存在相同的情况，就会出现资源访问冲突的问题。
独立式各个插件资源都是互相隔离的，如果想实现资源的共享，就必须拿到对应的Resource对象
·资源冲突
合并式的资源处理，会引入资源冲突。资源 id 是由 8 位 16 进制数表示，表示为 0xPPTTNNNN。PP 段用来区分包空间，默认只区分了应用资源和系统资源，TT 段为资源类型，NNNN 段在同一个 APK 中从 0000 递增。
所以思路是修改id的PP段，不同的插件使用不同的PP段，从而区分不同插件资源，具体实现方式有两种：
1.修改aapt源码，编译期修改PP段
2.修改resources.arsc,该文件列出了资源id到具体资源路径的映射
推荐第二种，不会入侵原有的编译流程。
四大组件支持
Android开发中有一些特殊的类，是由系统创建的，并且由系统管理生命周期，如常用的四大组件，activity,service,broadcastReceiver和contentProvider,仅仅构造出这些类的实例是没有用的，还需要管理组件的生命周期。其中以activity的最为复杂，不同的框架有不同的方式，大致分为两种方式
1.ProxyActivity代理
2.hook方式
hook启动插件activity需要解决两个问题：
·插件Activity没有在Manifest文件中注册，如何绕过检测
·如何构造Activity实例，并同步生命周期
解决方法：
·先在manifest中预埋StupActivity,启动时hook住，将intent替换成StubActivity
·通过插件的ClassLoader反射创建插件activity
·之后Activity的所有生命周期都会回调给插件Activity
Service：Service 和 Activity 的差别在于，Activity 的生命周期是由用户交互决定的，而 Service 的生命周期是我们通过代码主动调用的，且 Service 实例和 manifest 中注册的是一一对应的。实现 Service 插件化的思路是通过在 manifest 中预埋StubService，hook 系统 startService 等调用替换启动的 Service，之后在 StubService 中创建插件 Service，并手动管理其生命周期。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b5e994cd8a406fd0c158ad6696b1c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e4e4804fac11ade4f731e6f06b4952/" rel="bookmark">
			相机标定——张氏标定法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言动机为什么要进行相机标定什么是张氏标定法 张氏标定法的原理透镜成像原理世界坐标系到相机坐标系的转换相机坐标系到图像坐标系的转换图像坐标系到像素坐标系单应性矩阵内参求解外参求解Matlab实操 前言 动机 前段时间在整机械臂的手眼标定，也就是标定3D相机到机械臂末端坐标系之间的转化关系，需要用到Matlab的相机标定工具来得到相机与标定板之间的齐次变换矩阵（也就是相机标定中的外参）。Matlab标定工具箱使用起来确实方便，不需要知道其中的标定原理，但是我认为要使用好一个工具，对原理有一定的了解是必要的，故而花了点时间研究了一下Matlab标定工具箱使用的标定算法——张氏标定法。
为什么要进行相机标定 相机需要标定，总结起来主要有以下两点原因：
由于透镜制造精度以及组装工艺的偏差会引入畸变，导致原始图像失真，需要进行矫正 在进行一些视觉任务如三维重建、视觉抓取的时候，我们需要建立从世界坐标系到图像坐标系之间的映射关系。例如可以通过某一点P在图像坐标系中的位置推导出其在世界坐标系中的位置，这是进行后续工作的基础。 什么是张氏标定法 张氏标定法是张正友博士在1999年发表在国际顶级会议ICCV上的论文《Flexible Camera Calibration By Viewing a Plane From Unknown Orientations》中，提出的一种利用平面棋盘格进行相机标定的实用方法。其后2000的这篇《A flexible new technique for camera calibration》引用数更是达到了恐怖的13885次，江湖地位可见一斑。该方法介于摄影标定法和自标定法之间，既克服了摄影标定法需要的高精度三维标定物(贵，操作麻烦)的缺点，又解决了自标定法鲁棒性差的难题。标定过程仅需使用一个打印出来的棋盘格，并从不同方向拍摄几组图片即可（理论上3组就可以求解所有的未知数，不过一般采15~20组，用优化的方法保证求解精度较高），任何人都可以自己制作标定图案，不仅实用灵活方便，而且精度很高，鲁棒性好。因此很快被全世界广泛采用，极大的促进了三维计算机视觉从实验室走向真实世界的进程。（摘自张正友标定法-完整学习笔记-从原理到实战 - 知乎 (zhihu.com)）
张氏标定法相比于其他标定方法，在保证一定精度以及鲁棒性的情况下，操作简单、成本较低。但是有一点要注意，张氏标定法只考虑了径向畸变，没有考虑切向畸变。
Tips(本文为了方便（简单），不考虑相机的畸变)
张氏标定法的原理 张氏标定法的整体思路为先求出世界坐标系到像素坐标系的单应性矩阵（单应性矩阵其实就是一个图像中的像素点到另外一个图像中像素点的变换矩阵，双目相机系统中也有单应性矩阵，其是左右相机图像之间的变换矩阵），然后根据单应性矩阵得到内参矩阵，最后得到外参矩阵，不过这其中有个东西要考虑，就是尺度因子，我花了一段比较长的时间去思考这个。
透镜成像原理 我将主要用图来呈现，比码字快而且直观，透镜成像原理如下所示：
上图总的来说就是建立了从像素坐标系到世界坐标系之间的映射关系。其步骤为:先通过外参建立相机坐标系与世界坐标系之间的联系，然后通过内参与相机成像模型建立相机坐标系与图像坐标系，图像坐标系与像素坐标系之间的联系。接下来，我们对上图的步骤进行拆解与分析。
世界坐标系到相机坐标系的转换 上式子中，[xc,yc,zc] ， [xw,yw,zw] 分别为点在相机坐标系与世界坐标系下的位置（注意，这还没有投影变换，只是换了个参考坐标系，R为从世界坐标系到相机坐标系的旋转矩阵，T为平移向量，两者构成了4*4的齐次变换矩阵，这也就是标定过程中得到的外参，这个外参正常情况下可能用不上，但是在机械臂的手眼标定中这个外参是必须的参数之一。
相机坐标系到图像坐标系的转换 相机坐标系到图像坐标系的关系如下图所示：
从相机坐标系到图像坐标系经过了投影变换，图像坐标为二维坐标，没有Z轴分量，成像平面距光心的距离为焦距f,这边有个要注意的是，从相机坐标系到图像坐标系的变化会引入一个尺度因子，这个尺度因子和 Zc 相关。
图像坐标系到像素坐标系 相机实际输出的图片是按像素进行排列的，我们最后得到的数据也是像素的位置，像素坐标系相当于对图像坐标系做了原点偏移与坐标值离散化。
其中，1/dx, 1/dy 分别为像素在 x , y 轴方向上的物理尺寸，u0 , v0 为主点（图像原点）在像素平面的偏移。（其实正常来说的话，在上图3*3矩阵中的第一行第二列位置还会有一个 γ ，这个参数是 x, y 轴之间的主轴偏差，因为实际透镜，两个光轴可能不是垂直的）
单应性矩阵 接下来，我们综合上述从世界到相机、从相机到图像、从图像到像素的转化关系，可以得到如下式子：
我们对式子进行化简，我们可以将世界坐标系的 XOY 平面移动到标定板上，那么标定板上的点在世界坐标系上的 z 坐标就是0，显然，这只是换了一种世界坐标系的选取方式，只会影响外参，对内参没有任何影响。在此基础上，进行合并，我们可得：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e4e4804fac11ade4f731e6f06b4952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed62f1fc5b166f7423dca3c173cc0b0/" rel="bookmark">
			解决Xshell连不上virtualBox虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明virtualBox虚拟机的网络设置模式：NAT+Host-Only模式
选择该模式既能保证虚拟机连外网，也能保证本机电脑连接虚拟机。
网络1：NAT模式 网络2：Host-Only模式 进入虚拟机，输入ifconfig发现没有显示ip： 但是ping百度，是可以ping通的： 所以可以推断出NAT网络是没有问题的，Host-Only存在问题。
而且正常还说应该是有两个网卡的信息的，但是目前只有enp0s3，因此我们还可以合理的推测，Host-Only的网卡没有启动。
解决方法： 1、首先设置enp0s3开机自启
vim /etc/sysconfig/network-scripts/ifcfg-enp0s3 添加ONBOOT="yes" 2、没有enp0s8，则创建enp0s8
cp enp0s3 enp0s8 vim enp0s8 配置如下： TYPE="Ethernet" PROXY_METHOD="none" BROWSER_ONLY="no" BOOTPROTO="static" DEFROUTE="yes" IPV4_FAILURE_FATAL="no" IPV6INIT="yes" IPV6_AUTOCONF="yes" IPV6_DEFROUTE="yes" IPV6_FAILURE_FATAL="no" IPV6_ADDR_GEN_MODE="stable-privacy" NAME="enp0s8" UUID="3ec9eebb-f9e1-4e4a-8ea7-ae6c4df8c795" DEVICE="enp0s8" ONBOOT="yes" IPADDR="192.168.56.105" 注意：复制过来的UUID要做一下简单修改，和ifcfg-en0s3中的做区分。
3、重启网络
systemctl restart network 4、查看ip就已经有了
到这里就可以使用本机电脑Xshell连接虚拟机， 同时ping http://www.baidu.com 也是可以联网的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2413442e4d2933526115a53be8d4d5a4/" rel="bookmark">
			面试官：说说你对责任链模式的理解？应用场景？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、是什么 责任链模式（Chain of Responsibility Pattern）就是某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系
将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止
职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递
常见的流程如下：
发送者知道链中的第一个接受者，它向这个接受者发出请求
每一个接受者都对请求进行分析，要么处理它，要么往下传递
每一个接受者知道的其他对象只有一个，即它的下家对象
如果没有任何接受者处理请求，那么请求将从链上离开，不同的实现对此有不同的反应
二、使用 假设我们负责一个售卖手机的网站，需求的定义是：需经过分别缴纳500元定金和200元定金的两轮预订，才能到正式购买阶段
公司对于交了定金的用户有一定的优惠政策，规则如下：
缴纳500元定金的用户可以收到100元优惠券
纳200元定金的用户可以收到50元优惠券
而没有缴纳定金的用户进入普通购买模式，没有优惠券，而且在库存不足的情况下，不一定能保证买得到
下面开始设计几个字段，解释它们的含义：
orderType：表示订单类型，值为1表示500元定金用户，值为2表示200元定金用户，值为3表示普通用户。
pay：表示用户是否支付定金，值为布尔值true和false，就算用户下了500元定金的订单，但是如果没有支付定金，那也会降级为普通用户购买模式。
stock：表示当前用户普通购买的手机库存数量，已经支付过定金的用户不受限制。
代码实现如下：
const order = function (orderType, pay, stock) { if (orderType === 1) { if (pay === true) { console.log('500元定金预购，得到100元优惠券') } else { if (stock &gt; 0) { console.log('普通用户购买，无优惠券') } else { console.log('手机库存不足') } } else if (orderType === 2) { if (pay === true) { console.log('200元定金预购，得到50元优惠券') } else { if (stock &gt; 0) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2413442e4d2933526115a53be8d4d5a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e563f27ab08c236816d64b995df021/" rel="bookmark">
			MissingServletRequestParameterException: Required request parameter ‘id‘ for method parameter type I
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、报错信息
1.1idea中报错信息
Resolved [org.springframework.web.bind.MissingServletRequestParameterException: Required request parameter 'id' for method parameter type Integer is not present] 1.2网页报错信息
Whitelabel Error Page This application has no explicit mapping for /error, so you are seeing this as a fallback. Sun Nov 14 15:36:12 CST 2021 There was an unexpected error (type=Bad Request, status=400). Required request parameter 'id' for method parameter type Integer is not present org.springframework.web.bind.MissingServletRequestParameterException: Required request parameter 'id' for method parameter type Integer is not present 2、报错原因
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17e563f27ab08c236816d64b995df021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed13999125e50aeb0d1eb5801f9bb156/" rel="bookmark">
			Nginx网页优化（隐藏版本号，日志分割，更改进程数，网页压缩，防盗链详
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.安装Nginx服务
1.安装Nginx服务
2.编译安装Nginx
3.优化路径
4.添加 Nginx 系统服务
二.隐藏版本号
1.查看版本号
2.隐藏版本号法一
修改主配置文件
3.隐藏版本号法二
修改源码文件，重新编译安装
重新编译安装 三.修改用户与组
四.缓存时间
五.日志切割
六.连接超时
七.更改请求进程数
八.网页压缩
九.防盗链
一.安装Nginx服务 1.安装Nginx服务 [root@localhost ~]# systemctl stop firewalld.service [root@localhost ~]# setenforce 0 [root@localhost ~]# yum -y install pcre-devel zlib-devel gcc gcc-c++ make 2.编译安装Nginx [root@localhost opt]# rz -E rz waiting to receive. [root@localhost opt]# ls nginx-1.12.0.tar.gz [root@localhost opt]# tar zxf nginx-1.12.0.tar.gz [root@localhost opt]# ls nginx-1.12.0 nginx-1.12.0.tar.gz [root@localhost opt]# cd nginx-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed13999125e50aeb0d1eb5801f9bb156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cdd991a20c1f666ca76ffa01ea2e2f/" rel="bookmark">
			STM32的哪来的LED=0 ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（想了老半天）一个看似普通的LED0=0；看似平凡，实际却是天选之子。
往芯片型号一看，这不是TM的 stm32 吗。我对这语句中的LED=0；瞬间产生了好奇。
宏定义怎么可以给它=0呢？不科学啊
往深处去 go to Definition Of ‘LED0’ 后果然内有玄机，
go to进去它的每一层，发现它不简单啊，多层 带参宏 之间进行嵌套。我们去究其本质来理解，发现其实原理也都差不多。
LED=0;	//51可以 LED=0;	//STM32也可以 代码来自 正点原子 STM32 MINI 例程
以上仅仅是个人的片面理解，不一定对，但望能引发思考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e024c5aa8aa60de591ee96dbe82d961/" rel="bookmark">
			33.基带传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、基带传输基本概念 模拟基带信号：模拟信源发出的原始电信号。数字基带信号：数字信源发出的基带信号。模拟基带信号可以通过信源编码转换为数字基带信号。基带传输：直接在信道中传送基带信号。 数字基带传输系统：
二、数字基带传输编码 二、数字基带传输编码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7da8e4adb987c1709a7ffda8ae20c0d/" rel="bookmark">
			列出每位学生的各科成绩，要求输出格式：姓名、学号、语文成绩、数学成绩、英语成绩，SQL怎么编写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select name,code,max(case when subject="语文" then score else 0 end)as 语文,
max(case when subject="数学" then score else 0 end)as 数学,
max(case when subject="英语" then score else 0 end)as 英语
from (select s.name,s.code,e.subject,e.score
from student s left join exam e on s.code=e.code order by e.subject)as a group by a.code;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a31ecc4fe334b99cd07abebec58d42/" rel="bookmark">
			1.什么是Javascript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是Javascript 1.1、概述 JavaScript是一门世界上最流行的脚本语言
Java、javaScript
10天~
一个合格的后端人员，必须要精通JavaScript
1.2、历史 ECMAScript它可以理解为是JavaScript的一个标准
最新版本已经到了es6版本~
但是大部分浏览器还停留在支持es5代码上~
开发环境–线上环境，版本不一致
2、快速入门 2.1、引入JavaScript 内部标签
alert（‘xxx’）:弹窗
&lt;!--内部js--&gt; &lt;script&gt; alert('hello word!') /*弹窗 alert*/ &lt;/script&gt; 外部引入
&lt;script src="../JS/MW.js"&gt;&lt;/script&gt; [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hnm13Jh9-1636732352338)(C:\Users\陈明伟\AppData\Roaming\Typora\typora-user-images\image-20211010110620228.png)]
注意：Script成对出现
//不用显示定义type，也默认就是javascript &lt;script type="text/javascript"&gt;&lt;/script&gt; 2.2、基本语法入门 浏览器调试须知：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-13DR9uOi-1636732352341)(C:\Users\陈明伟\AppData\Roaming\Typora\typora-user-images\image-20211012162248432.png)]
Elements：元素
Console：控制台
Sources：源码调试
Network：互联网抓包
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZkHirD2e-1636732352342)(C:\Users\陈明伟\AppData\Roaming\Typora\typora-user-images\image-20211012162006203.png)]
&lt;script&gt; &lt;!--script严格区分大小写！--&gt; /*1、定义变量*/ var source=66;/*变量类型只有一个var 变量名=变量值*/ /* alert(source);*/ /*2、条件控制*/ if(source&gt;60 &amp;&amp; source&lt;70){ alert(source) }else if (source&gt;70 &amp;&amp; source&lt;80){ alert(source); } alert('999'); // 在浏览器的控制台打印变量！ console.log('我的宝儿！') &lt;/script&gt; [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uzmuPGdT-1636732352345)(C:\Users\陈明伟\AppData\Roaming\Typora\typora-user-images\image-20211012163403768.png)]
2.3、数据类型 数值，文本，图形，视频，音频。。。。
变量
var _$ //变量名不能用数字开头 number
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15a31ecc4fe334b99cd07abebec58d42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326ba5bcaddcb20185db5c14c39a46be/" rel="bookmark">
			图像边缘检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 图像边缘检测 代码展示 import cv2 #导入opencv模块 import numpy as np img = cv2.imread("D:\jupyter\img/1.jpeg") #导入图片，图片放在程序所在目录 cv2.namedWindow("imagshow", 2) #创建一个窗口 cv2.imshow('imagshow', img) #显示原始图片 #高斯模糊 blurred = cv2.GaussianBlur(img, (3, 3), 0) #转换为灰度图 out_img_GRAY=cv2.cvtColor(blurred,cv2.COLOR_BGR2GRAY)#将图片转换为灰度图 cv2.namedWindow("img_GRAY", 2) #创建一个窗口 cv2.imshow('img_GRAY', out_img_GRAY) #显示原始图片 #使用Canny算子进行边缘检测 edge_output = cv2.Canny(out_img_GRAY, 10, 300) cv2.namedWindow("Canny", 2) #创建一个窗口 cv2.imshow('Canny', edge_output) #显示原始图片 #使用sobelx算子进行边缘检测 sobelx = cv2.Sobel(out_img_GRAY,-1,1,0,ksize=3) cv2.namedWindow("sobelx", 2) #创建一个窗口 cv2.imshow('sobelx', sobelx) #显示原始图片 #使用laplacian算子进行边缘检测 laplacian = cv2.Laplacian(out_img_GRAY,-1) cv2.namedWindow("laplacian", 2) #创建一个窗口 cv2.imshow('laplacian', laplacian) #显示原始图片 cv2.waitKey() 运行效果图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f337fbb8b3cd955893c4ab3cb34994/" rel="bookmark">
			海康工业网口相机组播功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康工业网口相机组播功能 1.组播功能MVS演示1.1网络拓扑图1.2MVS功能演示 2.组播功能SDK接口调用实现3.组播功能使用常见问题 什么是组播？ 网口相机的组播功能可以实现多个PC对同一个相机同时进行访问。 简单直白的说，就是电脑A、电脑B、电脑C，可以同时获取一个相机的图像数据，电脑A的软件可以进行图像处理，而电脑B、C的软件可以进行录像监控等等 有什么限制条件？ 1.需要有千兆网交换机进行数据分流，转包 2.同一个相机，只能被一台电脑进行控制（参数设置：曝光修改等），其余的电脑，只能进行图像数据接收 3.只有网口相机支持 1.组播功能MVS演示 本文简单演示下1台相机，通过交换机被两台不同PC链接的情况
1.1网络拓扑图 1.控制端-主机1：用于相机参数配置，图像接收处理
2.接受端-主机2、3,N:仅支持，用于相机图像接收
3.交换机：千兆网交换机，用于相机图像的分包，接收端主机越多，对交换机性能要求越高
1.2MVS功能演示 1.控制端-主机1，以“控制与接收模式”打开相机，开始取流
2.接收端-主机2，以“数据接收模式”打开相机，开始取流
3.在控制端主机设置相机参数，可以看见接收端图像同步变化
2.组播功能SDK接口调用实现 海康SDK提供了示例以供用户调用其接口实现组播功能，示例代码路径如：
C:\Program Files (x86)\MVS\Development\Samples\VC\VS\SimpleSamples\MultiCast
代码整体结构相对简单，在opendevice是，使用不同权限打开相机即可，相机打开部分代码如下：
// ch:选择设备并创建句柄 | en:select device and create handle nRet = MV_CC_CreateHandle(&amp;handle, stDeviceList.pDeviceInfo[nIndex]); if (MV_OK != nRet) { printf("Create Handle fail! nRet [0x%x]\n", nRet); break; } // ch:询问用户启动多播控制应用程序或多播监控应用程序 // en:Ask the user to launch: the multicast controlling application or the multicast monitoring application. printf("Start multicast sample in (c)ontrol or in (m)onitor mode?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25f337fbb8b3cd955893c4ab3cb34994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eee0ee42d5f3dc0e55f6cdcc90fb7d1/" rel="bookmark">
			Hough变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hough变换 1. 简单介绍 Hough变换是图像处理中从图像中识别几何形状的基本方法之一。Hough变换的基本原理在于利用点与线的对偶性，将原始图像空间的给定的曲线通过曲线表达形式变为参数空间的一个点。这样就把原始图像中给定曲线的检测问题转化为寻找参数空间中的峰值问题。也即把检测整体特性转化为检测局部特性。比如直线、椭圆、圆、弧线等。
2.Hough变换思想 在原始图像坐标系下的一个点对应了参数坐标系中的一条直线，同样参数坐标系的一条直线对应了原始坐标系下的一个点，然后，原始坐标系下呈现直线的所有点，它们的斜率和截距是相同的，所以它们在参数坐标系下对应于同一个点。这样在将原始坐标系下的各个点投影到参数坐标系下之后，看参数坐标系下有没有聚集点，这样的聚集点就对应了原始坐标系下的直线。
3.代码实现 import cv2 import numpy as np #hough变换的程序实现 img = cv2.imread("D:\jupyter\img/building.jpg")#读取图片 img2 = img.copy() gray =cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)#将图片转换为灰度图 edges = cv2.Canny(gray,50,150,apertureSize = 3)#canny算法提取轮廓 #基于概率的hough变换...................................................... lines_Probabilitys = cv2.HoughLinesP(edges,1,np.pi/180,30,minLineLength=60,maxLineGap=10)#概率hough变换 lines_Probability = lines_Probabilitys[:,0,:]#提取为二维 for x1,y1,x2,y2 in lines_Probability[:]: cv2.line(img,(x1,y1),(x2,y2),(255,0,0),1) cv2.namedWindow("HoughLines_Probabilitys", 2) #创建一个窗口 cv2.imshow('HoughLines_Probabilitys', img) #显示原始图片 #标准的hough变换...................................................... lines_standards = cv2.HoughLines(edges,1,np.pi/180,200) #标准hough变换查找直线 #绘制hough变换后找到的所有直线，返回数据是一个二位数组 for lines_standard in lines_standards: for rho,theta in lines_standard: a = np.cos(theta) b = np.sin(theta) x0 = a*rho y0 = b*rho x1 = int(x0 + 1000*(-b)) y1 = int(y0 + 1000*(a)) x2 = int(x0 - 1000*(-b)) y2 = int(y0 - 1000*(a)) cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eee0ee42d5f3dc0e55f6cdcc90fb7d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612d01fa8ebed630f40875ed6bcbfcc6/" rel="bookmark">
			开源公告｜通用的分布式shuffle服务-Firestorm开源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Firestorm介绍
Firestorm是一个通用的分布式shuffle服务，满足大数据框架在云原生、离线混合等场景的需求，同时解决MR style shuffle在大规模场景下遇到的稳定新和性能问题。
项目采用了Coordinator和Shuffle Server结合的多主多从的分布式架构，对于Shuffle数据能预聚合，降低shuffle过程对于磁盘IO的开销，以此提升Shuffle任务的稳定性。目前支持的存储模式有Local，HDFS，Ozone，以及 Local + HDFS/Ozone混合模式。
Firestorm 适用的场景
1. 对于计算存储分离的集群架构，由于计算节点本地空间不足，原来的实现方案在shuffle过程中容易遇到磁盘空间不足等问题，Firestorm则能基于存储介质的配置，避免该问题。
2. 对于Shuffle数据量大，partition数量多的计算任务，原来的实现方案将会导致大量的磁盘随机读写，造成性能损失，Firestorm能基于预聚合的特性，避免该问题。
Firestorm 特点
1. 支持计算存储分离的集群架构
2. 支持Partition数据聚合
3. 各模块实现解耦，支持便捷增加计算引擎以及存储方式，目前项目仅支持Spark计算引擎(版本为2.4.6, 3.1.2)
4. 支持shuffle数据的强一致性校验，包括数据是否缺失，数据是否匹配
5. 支持Shuffle Server端配置多种存储
6. 支持基于http请求获取各项指标
7. 支持整体架构多活模式
8. 支持在线升级，且不影响实际使用
Firestorm 项目规划
1. 优化整体容错性
2. 优化Shuffle数据读写性能
3. 支持更多存储介质
4. 支持更多计算引擎
Firestorm 开源地址
https://github.com/Tencent/Firestorm（复制到浏览器打开或点击阅读原文访问）
请给项目 一个 Star !
欢迎提出你的 issue 和 PR！
国内镜像地址：
https://git.code.tencent.com/Tencent_Open_Source
（登录后才能访问公开项目）
腾讯工蜂源码系统为开源开发者提供完整、最新的腾讯开源项目国内镜像
关注腾讯开源公众号
获取更多最新腾讯官方开源信息！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a99bf3811551d8afaaa2acc6f87cec/" rel="bookmark">
			【项目分析笔记】卡通感风格的渲染方法和思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是基于腾讯TA大咖的一篇分享作的笔记，主要内容来自于Unity社区的分享，下面指路。基于个人的阅读习惯和一些陌生的方法做了补充和引用。主要是面对NPR的一个渲染效果分析，通俗易懂适合新手阅读。
引用及原文地址指路如下：
腾讯TA大咖分享，做卡通渲染时对风格和影视化的探索
Unity NPR之日式卡通渲染（基础篇）
kuwahara filter 实现
1、卡通渲染到写实渲染之间的质感比较： 2、构成卡通感的几个要素，从以下思路入手渲染： （1）减少色阶的数量（色阶的控制）
A使用Smoothstep函数
使用Smoothstep函数将兰伯特光照二值化成一个卡通的赛璐璐光照。同时我们也可以通过这个函数的曲线，来控制物体亮面跟暗面交界处的软硬。
B 用ramp贴图来控制
ramp贴图可以方便控制多个色阶，并且可以对色调来进行控制。
（2）明暗色调分离：
A在写shader的过程中要注意给美术一个指定暗面颜色（图片）的途径。
有时候是用贴图来表现阴影，如果使用一张贴图来表现阴面的话，角色的亮面跟暗面的色调对比更加强烈，看起来卡通感会更强。
B 阴和影颜色的统一
日系动画中将物体背向光的一面称作阴，将由于物体被遮挡而产生的一个区域叫做影，如下图所示：
左边这张图它的阴和影的颜色是一致的，这张图的色调会更加的干净。看起来就会比右边这张阴和影的颜色不一致的的贴图，显示的光感会更好，也更加的卡通。
（3）阴影区域的控制
影响阴影的几个要素，
①灯光的方向
②灯光的阈值
③法线方向
我们可以对这三个要素进行控制，来控制阴影的形状。
①灯光的方向
一般在卡通游戏场景中，人物的每个部分、每个任务角色都是单独打光的。但是为了整体场景的考量，也可以给光照方向加一些偏移值，这样的好处就是可以分材质去调整光照方向。（单独打光不会很浪费资源吗？）
比方说我们角色脸部的阴影，为了好看可能我们需要一个平视的光源方向。但我们的场景一般是俯视的光源方向，那么这个时候我们就可以通过计算对光照方向做一些偏移，来让这个角色面部的阴影看起来比较好看。
②阈值的控制
在调整好光照方向之后，就可以通过绘制阈值图来控制这个角色的阴影形状。
③控制法线
可以直接编辑法线来控制阴影形状。也可以去制作一个法线比较圆滑的模型，然后通过像Maya一类软件的法线传递的工具，把圆滑的法线传递到这个角色模型身上，让这个角色模型的效果看起来更好。
（4）描边
A内描边
内描边就是物体贴图上面的描边，这个描边有一个问题就是放大后容易产生锯齿。像《罪恶装备》的话，它采取了一个称为本村线（有时为了表现衣服上的褶皱等折痕，美术会做一张纹理贴图来储存褶皱的形状。本村线贴图有一个很显眼的特点：所有的线横平竖直。这是因为如果有斜向的线段，在UV采样中会产生锯齿。所以，使用本村线的UV是经过美术特殊处理的，对于美术来说相比普通的展UV会多费一些功夫。）的方式，人物的纹理描边都是横平竖直的，然后通过扭曲UV来做出各种形状的描边。这样做出来的描边虽然费时，但是这个描边在放大的时候仍然能保持非常锐利。
B外描边
角色外描边的话主要有两种，一种是Back facing的两次绘制方法，一种是Sobel算子的这种屏幕边缘检测。
①back facing
将这个物体按照法线方向进行膨胀，绘制描边，然后再绘制物体。
这种的方式在绘制描边的时候可以拿到材质属性，就比较便于对这个描边进行精确的控制。我们可以控制这个描边的粗细和颜色，对角色这种描边要求比较高的东西，会更加合适一些。
②Sobel算子的边缘检测
像是有很多物体的场景，能够一次性把他们全都给描了。这种方法处理场景描边更合适一点。人物描边同样也可以采用Sobel算子的边缘检测，根据我们的项目需要来选择就好了。
3、赛璐璐的材质表达 赛璐璐表达的一些优势
某些模型的Mesh已经夸张到非常奇怪了，但是它的2D表现还是非常好的。这就说明赛璐璐风格虽然抹掉了色阶，但是其实它也忽略了Mesh的物理结构。我们可以通过一些非常夸张的Mesh在一些镜头下做出好看的2D效果，它会更接近于我们2D手绘的效果。
赛璐璐表达的材质，我可以用这张图来对比一下。它处理角色的面部、头发、布料、金属还有皮革，这些材质它的表现都是比较好的，基本可以满足人物材质的的需要。
赛璐璐表达的缺陷
赛璐璐其实不擅长表达材质质感。因为它在抹平色阶的时候，它的材质表达力也减弱了。只凭借赛璐璐的话，可能很难看出这个东西到底是个什么材质的。比方说我们的场景对材质表现要求非常高的话，它有非常多的不同的材质，那么赛璐璐就不太适合表达这样的东西了。
4、立绘的材质质感及表达 参考的游戏是《碧蓝幻想VS》，我们可以看到它的一些角色图。通过对角色图进行一些分析，我们能看到这个角色大概是有几种不同的材质，比如有这种柱状的金属（剑柄）、肩甲、胸甲、还有角色的皮肤以及布料。
可以看的出，立绘效果相比起赛璐璐效果，材质表达更加丰富。
对于圆柱型金属，清漆光（我们把经典光照模型中的N·H，改成N·V，这个高光形状就会非常接近于卡通的清漆光的形状。很适合用来处理一些皮革，圆柱形的金属等。）的光照会更加合适一些。
皮肤的话，有一个单层的锐利阴影。
肩甲有两层锐利的阴影，除了一层暗的，还有一层相对浅一点的阴影。
胸甲有一个很明显的高光的mask，来做出这种卡通化的金属高光。
布料有一层较柔和的单层阴影。
可以看到，针对这幅图，团队针对不同的材质去设计了不同的渲染方案。
通过对于不同材质，组合不同的漫反射、高光和边缘光，它实现了比传统赛璐璐两个色阶更多的材质效果，这也使得它的角色更加接近于立绘插画的表现。
这个设计思路其实是很好的，我们在做卡通渲染的时候，实际上也是需要针对这个角色的材质进行分类，然后根据不同类型的材质去做出一些合适它的材质表达。
5、混合了PBR质感的处理方式 拿到设计图之后，应该就开始想它的材质特性。它里面有哪些材质适合用NPR（非真实渲染）来表达，哪些材质适合用PBR（基于物理的渲染）来表达，我们可以通过蒙版来区分不同的材质。
其分析结果如下：
适用于 NPR（非真实渲染）部分：比方说毛衣和角色的皮肤，我们用了黑色蒙版来表示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a99bf3811551d8afaaa2acc6f87cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e2568bcda0c86faf645bd946180dee/" rel="bookmark">
			MySQL进阶系列: 怎么创建更合适的索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ 不要当库里的数据较多的时候才能知道索引的重要性，更不要当库里的数据更多的时候才能知道合适的索引重要性。本文介绍下怎么创建高效且合适的索引”
1. 当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层 如下图 两个sql的结果是一样的，但是两个sql的执行计划是不一样，在type中index的效率远不如const where条件中 actor_id+4 表达式影响了执行计划,对于type表示的含义请参考 explain详解一篇
2. 尽量使用主键查询，而不是其他索引，主键查询不会出现回表查询。 我们所有的表基本都会有主键的，所以平时开发中能用索引就用索引，能用主键索引就用主键索引。
3. 使用前缀索引 很多时候我们的索引其实都是字符串，不可避免会出现长字符串，就会导致索引占用过大，降低其效率。尤其是对于blob,text, varchar这样的长列。这时候处理方式就是不使用字段的全值作为索引，而是只取其前半部分即可(选择的这部分前缀索引的选择性接近于整个列)。这样可以大大减少索引空间，从而提高效率，坏处就是降低了索引的选择性。
索引选择性：不重复的索引值和数据表记录总数的比值(#T),范围从1/#T到1之间。索引的选择性越高查询效率也高，因为数据的区分度很高，可以过滤掉更多的行。唯一性索引的选择性是1，其性能也最好。
例如公司的员工表中邮箱字段，一个公司的邮箱后缀都是一样的如xxxx@qq.com, 其实用邮箱作为索引有效的就xxxx部分，因为@qq.com都是一样的，对索引是无意义的，明显只用xxxx作为索引，其选择性和整个值的是一样的，但是xxxx作为索引明显就会减少索引空间。
下面我们已employee表为例子(表结构和数据看文末)
我们以email字段建立索引为例：
这个数据的邮箱其实是手机号+@qq.com为例的，其实前11位后面都是相同的。我用下面的sql来看看这些数据的选择性(分别取前10，11，12)位计算。
-- 当是11个前缀的时候选择性是1，在增加字段长度，选择性也不会变化 select count(distinct left(email,10))/count(*) as e10,count(distinct left(email,11))/count(*) as e11,count(distinct left(email,12))/count(*) as e12, from employee; 结果：
从上图我们可以看出前10，前11，前12的选择性分别是0.14，1.0，1.0 ,在第11位的时候索引选择性是最高的1，就没必要使用全部作为索引，增加了索引的空间。
-- 创建前缀索引 alter table employee add key(email(11)); 我们也可以使用count计算频率来统计(出现的次数越少，说明重复率越低，选择性越大)
-- 查找前缀出现的频率 select count(*) as cnt,left(email,11) as pref from employee group by pref order by cnt desc limit 10; 4.使用索引扫描来排序 我们经常会有排序的需求，使用order by 但是order by是比较影响性能的，它是通过把数据加载到内存去排序的，如果数据量很大内存放不下，只能分多次处理。但是索引本身就是有序的，直接通过索引完成排序更省事。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19e2568bcda0c86faf645bd946180dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57a2e6a3d3afc7b8780a8603dc9f93d/" rel="bookmark">
			Android Studio的LogCat过滤栏(选择设备界面)不见了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开LogCat界面方法： 1、View --- Tool Windows --- Event Log
2、在 android studio整个界面的左下角，鼠标移动过去会自动弹窗界面
LogCat的过滤栏界面
有时候会莫名其妙的不见了这个过滤栏
解决方式： 1、尝试移动log框到左右上下（效果最好）
2、尝试启用并停用 Split Mode （有时有效）
3、尝试启用并停用 Windowed Mode （好像比较靠谱）
4、尝试重启 Studio （低概率修好）
5、尝试重启电脑 （有时有效）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36aa239d3becfd1dd97ef38c9271e0c5/" rel="bookmark">
			【已解决】已拦截跨域请求：同源策略禁止读取位于接口的远程资源：原因：CORS缺少Access-Contorl-Allow-Origin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前后端开发跨域问题 1 问题记录2 前端2.1新手配置：有问题2.1.1纠错处：2.1.2注意 2.2老手配置：正常 3 后端3.1新手配置：有问题3.1.1纠错处：3.1.2注意 3.2老手配置：正常 4 总结 有用请留下你的足迹，让更多人的人看到，谢谢 1 问题记录 今天笔者有一次遇到前后端跨域问题，下面小编详细的记录下整个过程：
环境是：后端在公司，前端在远程，两人协同开发
后端写好接口，并发布在外网后，接下来就是远程前端的对接接口阶段，前端在配置接口时，配置成功，在测试访问时，浏览器报“已拦截跨域请求：同源策略禁止读取位于接口的远程资源：原因：CORS缺少Access-Contorl-Allow-Origin”问题，错误提示是“cors跨域问题”，后端看到只接受到了预请求，此刻，两者都不确定是谁的问题，都着手解决这个问题，好了，小编暂时代替他配合后端联调，首先用之前已经正常的登录界面来配合他来联调，联调时，还是出现相同的问题，此时判断出是后端请求规则配置有问题。解决方法本篇文章后面会记录。待后端解决后，我两联调正常后，接下来就是远程前端和后端的联调，结果调试还是出现问题，说明此刻问题是前端的配置有问题，果不其然，小编将自己的main.js文件配置给他后，解决啦，问题到此结束，下面将详细记录解决方案！！
2 前端 2.1新手配置：有问题 import Vue from 'vue' import App from './App.vue' import axios from 'axios' import router from './router' import store from './store' Vue.config.productionTip = false Vue.prototype.$axios = axios Vue.prototype.$http = axios // 全局挂载axios const base_url = 'httt://117.xx.xx.198:1024/' axios.defaults.baseURL = base_url axios.defaults.headers.post['Content-Type'] = 'application/json;charset=utf-8' / new Vue({ router, store, render: h =&gt; h(App), }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36aa239d3becfd1dd97ef38c9271e0c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e08b1ed63ebf8a302e7822a977106c/" rel="bookmark">
			OpenCVSharp在C#项目中的环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#环境下使用OpenCV,需要用到OpenCvSharp库，有两种方法进行配置。
方法一： 在项目中安装配置OpenCvSharp第一种方法是通过Nuget获取相应的库文件，若VS没有nuget，需要下载安装一个。
步骤如下：
打开/新建一个项目-&gt;选择工具(T)-&gt;NuGet包管理器(N)-&gt;管理解决方案的NuGet程序包(N)-&gt;
在搜索框中输入OpenCvSharp,搜索-&gt;选择适应电脑系统的版本安装-&gt;在项目中添加命名空间OpenCvSharp即可
亲测：win7,win10系统可装OpenCvSharp3-AnyCPU(若需要最新的版本，建议用方法二下载)。
成功安装后可以看到引用里自动添加了OpenCvSharp，项目文件夹中也会多出相应的库文件。 方法二：
第二种方法是通过直接下载库文件。
下载地址：https://github.com/shimat/opencvsharp/releases
选择OpenCvSharp-4.5.3-20210821.zip，sample是官方例子，都可以下载学习
解压后，复制如下(OpenCvSharp.dll和OpenCvSharpExtern.dll)两个dll文件到项目Debug目录下，如下OpenCvSharpExtern.dll文件可以根据自己项目的目标平台选择 （AnyCPU 或者x86复制x86文件夹中的dll,x64平台复制x64文件夹中的dll），或者右键项目属性-&gt;生成-&gt;修改项目的目标平台。
在vs项目中，添加OpenCvSharp引用
using OpenCvSharp; 用以上方法配置好以后，可以写个Demo测试一下：
（简单显示一张图片）
private void button1_Click(object sender, EventArgs e) { Mat image0 = new Mat(@"C:\\Users\\Administrator\\Desktop\\hello world.png", ImreadModes.AnyColor); using (new Window("Hello_World", image0)) { Cv2.WaitKey(); } } 学习总结：
（1）添加Nuget的时候，安装不同的nuget包，得到的dll都不一样，要根据自己的系统选择合适的，建议还是到github下载，方法后续更新；
（2）若出现如下报错：
---------------------------
由于缺少调试目标“C:\Users\Administrator\Desktop\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\WindowsFormsApplication1.exe”，Visual Studio 无法开始调试。请生成项目并重试，或者相应地设置 OutputPath 和 AssemblyName 属性，使其指向目标程序集的正确位置。
---------------------------
原因是引用的OpenCvsharp版本和项目.net平台对不上，下载相应的版本或者更改项目为.net4.6.1（跟下载的OpenCvSharp版本对应）即可
---------------------------
“System.TypeInitializationException”类型的未经处理的异常在 OpenCvSharp.dll 中发生 其他信息: “OpenCvSharp.Internal.NativeMethods”的类型初始值设定项引发异常。
---------------------------
原因是没有OpenCvSharpExtern.dll，或者OpenCvSharpExtern.dll对不上项目的目标平台，重新选择x86或者x64的dll即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af90978f95f37a4ff8f15a7b953dead/" rel="bookmark">
			QR扫码综合示例教程（二十一）Qt5.15.2&#43;Qt6.2.1（qml）&#43;opencv4.5.4实现扫码功能（多线程、微信扫码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在前面的教程中，使用openCV的库实现了扫码功能，但实际使用时却很不理想。本次教程使用微信的扫码代码来测试
本教程是在 Qt5.15.2+Qt6.2.1（qml）+opencv4.5.4实现扫码功能（多线程） 示例的基础上修改
QR扫码综合示例教程（二十）Qt5.15.2+Qt6.2.1（qml）+opencv4.5.4实现扫码功能（多线程）_aggs1990的专栏-CSDN博客
一、准备openCV库 微信的扫码在附加库里，所以必需要自己编译官方源码，请需要的小伙伴们自己参考以下链接
Qt+openCV学习笔记_aggs1990的专栏-CSDN博客
笔者使用的是自己编译库 一、修改pro工程文件 修改工程文件是为了添加openCV的库
若是使用的VS2019 64位编译器，添加如下代码
win32{ CONFIG(release, debug|release){ LIBS += -LOPENCV_DIR/opencv4.5.4/build_vs2019_64/install/x64/vc16/lib/ -lopencv_core454 LIBS += -LOPENCV_DIR/opencv4.5.4/build_vs2019_64/install/x64/vc16/lib/ -lopencv_imgproc454 LIBS += -LOPENCV_DIR/opencv4.5.4/build_vs2019_64/install/x64/vc16/lib/ -lopencv_wechat_qrcode454 } else:CONFIG(debug, debug|release){ LIBS += -LOPENCV_DIR/opencv4.5.4/build_vs2019_64/install/x64/vc16/lib/ -lopencv_core454d LIBS += -LOPENCV_DIR/opencv4.5.4/build_vs2019_64/install/x64/vc16/lib/ -lopencv_imgproc454d LIBS += -LOPENCV_DIR/opencv4.5.4/build_vs2019_64/install/x64/vc16/lib/ -lopencv_wechat_qrcode454d } LIBS += -LOPENCV_DIR/opencv4.5.4/build_vs2019_64/install/x64/vc16/bin/ INCLUDEPATH += OPENCV_DIR/opencv4.5.4/build_vs2019_64/install/include DEPENDPATH += OPENCV_DIR/opencv4.5.4/build_vs2019_64/install/include } #OPENCV_DIR为openCV库存放目录 只要加载自己需要的模块就可以了，以减小发布包的体积
若是使用的android arm64-v8a编译器，添加如下代码
unix:!macx{ contains(ANDROID_TARGET_ARCH,arm64-v8a) { message("arm64-v8a") ANDROID_OPENCV = opencv_dir/opencv4.5.4/build_android_arm64-v8a/install/sdk/native INCLUDEPATH += $$ANDROID_OPENCV/jni/include/opencv2 \ $$ANDROID_OPENCV/jni/include LIBS += \ $$ANDROID_OPENCV/libs/arm64-v8a/libopencv_wechat_qrcode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af90978f95f37a4ff8f15a7b953dead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd52ef5b573c305c125832cf6352f514/" rel="bookmark">
			实现微信小程序分享朋友圈及好友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示分享按钮 首先需要通过wx.showShareMenu实现在当前页面显示分享按钮。如不实现该代码，分享按钮为灰色不可用状态。showShareMenu微信小程序API文档链接
注意事项
显示“分享到朋友圈”按钮时必须同时显示“发送给朋友”按钮，显示“发送给朋友”按钮时则允许不显示“分享到朋友圈”按钮
onLoad() { // "shareAppMessage"表示“发送给朋友”按钮，"shareTimeline"表示“分享到朋友圈”按钮 wx.showShareMenu({ menus: ['shareAppMessage', 'shareTimeline'],// 需要显示的转发按钮名称列表.合法值包含 "shareAppMessage"、"shareTimeline" success(res) { console.log(res); }, fail(e) { console.log(e); } }); }, 实现好友分享 添加Page.onShareAppMessage事件(与onLoad同级)，来监听用户点击转发按钮（button 组件 open-type=“share”）或右上角菜单“转发”按钮的行为，并自定义转发内容。onShareAppMessage微信小程序API文档链接
注意事项
只有定义了onShareAppMessage事件处理函数，右上角菜单才会显示“转发”按钮
onShareAppMessage() { return { title: '邀请您使用XXX小程序', // 分享出的卡片标题 path: 'pages/index/index', // 他人通过卡片进入小程序的路径，可以在后面拼接URL的形式带参数 imageUrl: '/static/mainImg/logosareas.jpg', // 分享出去的图片，默认为当前页面的截图。图片路径可以是本地文件路径或者网络图片路径。支持PNG及JPG。 }; }, 分享按钮
注意事项
触发分享的容器需要经过button标签的包裹，并设置 open-type=“share”
&lt;button type="default" open-type="share" class="clear-style"&gt;分享&lt;/button&gt; 由于button带有自定义样式，往往与需要实现的样式有冲突，此时需要清理原有的样式
.clear-style { border: none; border-radius: 0; background-color: transparent !important; padding: 0rpx !important; margin: 0rpx !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd52ef5b573c305c125832cf6352f514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56909dcfc229f7fdeac2f42d632010bb/" rel="bookmark">
			Mybatis之使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis之使用 一、Mybatis是什么？二、小试牛刀1.创建表2.新建maven项目并导入依赖3.编写mybaitis的配置文件4.编写实体类5.编写ORM映射文件6.在mybatis配置文件注册映射文件6.1映射文件放置在哪 7.编写测试方法 三、对象分析1.Resources2.SqlSessionFactoryBuilder3.SqlSessionFactory4.SqlSession5.执行过程 四、配置日志文件1.添加jar依赖2.添加日志配置文件3.结果展示 五、使用Mapper的接口编写Mybatis项目1.编写StudentMapper.java2.编写StudentMapper.xml3.在mybatis.xml中配置映射文件4.编写测试类5.展示结果6.getMapper实现原理 六、映射文件编写1.获取自增主键1.1正常返回1.1.1向StudentMapper.java添加方法1.1.2向StudentMapper.xml添加sql语句1.1.3编写测试方法1.1.4展示结果 1.2主键为数字自增11.2.1修改StudentMapper.xml1.2.2展示结果 1.3主键为数字自增21.3.1修改StudentMapper.xml1.2.3展示结果 1.4主键为varchar类型获取1.4.1 新建表1.4.2 复制Student.java并修改1.4.3 向StudentMapper.java添加方法1.4.3 修改StudentMapper.xml1.4.4 添加测试方法1.4.5 展示结果 七、映射1. 输入映射parameterType1.1 单个参数1.2 多个参数指定参数名1.2 多个参数不指定参数名 2.输出映射1.1resultType1.1.1输出基本类型1.1.2输出pojo类型1.1.3输出Map类型 1.2数据库与列名不一致1.1.1使用别名1.1.2使用resultMap 1.3resultMap 3. #{} 和 ${}的区别1.1 #{}1.2${} 八、全局配置文件1.文件头部约束2.配置文件内容3.自定义别名4.Mappers5.事务 九、映射关系1.多对一2.一对多 十、动态SQL1.where2.set3. forEach 十一、分页插件1.引入依赖2.配置插件3.测试方法 十二、Mybatis缓存简介1.作用2.一级缓存3.二级缓存 一、Mybatis是什么？ Mybatis是一个基于Java的持久层框架，内部封装类JDBC，让开发人员只需要关注sql语句本身，不需要花费精力在驱动的加载、连接的创建、Statement的创建等复杂的过程。Mybatis通过XML或注解的方式将要执行的各种statement配置起来，并通过Java对象和statement中的sql动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql语句，并将结果直接映射为Java对象。
Mybatis采用ORM（对象关系映射）思想解决了实体类和数据库表映射的问题。对JDBC进行了封装，屏蔽了JDBC API底层的访问细节。
二、小试牛刀 1.创建表 CREATE TABLE `student` ( `studentid` int NOT NULL AUTO_INCREMENT, `studentname` varchar(10) NOT NULL, `studentsex` varchar(5) NOT NULL, `studentage` int(5) NOT NULL, `studenttel` varchar(20) NOT NULL, PRIMARY KEY (`studentid`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56909dcfc229f7fdeac2f42d632010bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29aed8a3c41b5a8fcd2e0aa4276bc8f4/" rel="bookmark">
			Qt&#43;openCV学习笔记（八）openCV4.5.4&#43;android如何使用动、静态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在Android下使用openCV的库，与在其他系统下的原理基本相同，但又有点差异。本次笔记记录下具体的使用方法，供小伙伴们参考
一、使用官方的静态库 静态库使用时，要注意，若库与库之前有相应的依赖，加载的先后顺序不变，若是无法预知需要使用哪些库，可以按照如下的方法测试需要哪些库
1.先放入$$ANDROID_OPENCV/libs/arm64-v8a/libopencv_java4.so在最下面
2.把第三方库放在前面
3.把$$ANDROID_OPENCV/staticlibs/arm64-v8a/libopencv_core.a放在最前面
4.直接编译程序，等到源码报错时，查看报错的函数是存放于哪个库中，并直接添加到最前面
5.不断重复第4步，直到加入所有需要的库
6.若确认可以正常编译，开如注释掉第三方库，找出程序运行不需要的静态库，最终得到最小的库配置
以arm64-v8a为例，若需要使用二维码识别，最终要加入pro文件的内容如下
unix:!macx{ #添加opencv库（android arm64-v8a版） contains(ANDROID_TARGET_ARCH,arm64-v8a) { message("arm64-v8a") ANDROID_OPENCV = opencv_dir/opencv4.5.4/OpenCV-android-sdk/sdk/native INCLUDEPATH += $$ANDROID_OPENCV/jni/include/opencv2 \ $$ANDROID_OPENCV/jni/include LIBS += \ $$ANDROID_OPENCV/staticlibs/arm64-v8a/libopencv_objdetect.a \ $$ANDROID_OPENCV/staticlibs/arm64-v8a/libopencv_imgproc.a \ $$ANDROID_OPENCV/staticlibs/arm64-v8a/libopencv_core.a \ $$ANDROID_OPENCV/3rdparty/libs/arm64-v8a/libcpufeatures.a \ $$ANDROID_OPENCV/3rdparty/libs/arm64-v8a/libittnotify.a \ $$ANDROID_OPENCV/3rdparty/libs/arm64-v8a/libquirc.a \ $$ANDROID_OPENCV/3rdparty/libs/arm64-v8a/libtegra_hal.a \ $$ANDROID_OPENCV/libs/arm64-v8a/libopencv_java4.so } #若不添加，打包时不加入 ANDROID_EXTRA_LIBS = opencv_dir/opencv4.5.4/OpenCV-android-sdk/sdk/native/libs/arm64-v8a/libopencv_java4.so } 二、使用自行编译的静态库 自行编译的静态库，同样需要注意有先后顺序。若库与库之前有相应的依赖，加载的先后顺序不变，若是无法预知需要使用哪些库，可以按照如下的方法测试需要哪些库
1.把第三方库放在前面
2.把$$ANDROID_OPENCV/staticlibs/arm64-v8a/libopencv_core.a放在最前面
3.直接编译程序，等到源码报错时，查看报错的函数是存放于哪个库中，并直接添加到最前面
4.不断重复第4步，直到加入所有需要的库
5.若确认可以正常编译，开如注释掉第三方库，找出程序运行不需要的静态库，最终得到最小的库配置
以arm64-v8a为例，若需要使用微信二维码识别，最终要加入pro文件的内容如下
unix:!macx{ contains(ANDROID_TARGET_ARCH,arm64-v8a) { message("arm64-v8a") ANDROID_OPENCV = opencv_dir/opencv4.5.4/build_android_arm64-v8a/install/sdk/native INCLUDEPATH += $$ANDROID_OPENCV/jni/include/opencv2 \ $$ANDROID_OPENCV/jni/include LIBS += \ $$ANDROID_OPENCV/staticlibs/arm64-v8a/libopencv_wechat_qrcode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29aed8a3c41b5a8fcd2e0aa4276bc8f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af51d2fdff36a97b483751721b0d15d/" rel="bookmark">
			序列化Serializable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个类，实现Serializable接口（这是一个标志接口，给jvm识别的）
package com.io; import java.io.Serializable; public class Student implements Serializable { private String name; private String password; public Student() { } public Student(String name, String password) { this.name = name; this.password = password; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4af51d2fdff36a97b483751721b0d15d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2219d99baa518a1138133e1e992876af/" rel="bookmark">
			2021-2027年全球与中国顶面基层行业市场前瞻与投资战略规划分析报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021-2027年全球与中国顶面基层行业市场前瞻与投资战略规划分析报告
本报告研究全球与中国市场顶面基层的发展现状及未来发展趋势，分别从生产和消费的角度分析顶面基层的主要生产地区、主要消费地区以及主要的生产商。重点分析全球与中国市场的主要厂商产品特点、产品规格、不同规格产品的价格、产量、产值及全球和中国市场主要生产商的市场份额。
主要生产商包括：
FrieslandCampina Kievit (Netherlands)
Meggle (Germany)
Ingrizo NV (Belgium)
Wacker Chemie AG (Germany)
Asia Saigon Food Ingredients Joint Stock Company (Vietnam)
Nexira (France)
Basf (Germany)
Mokate Ingredients (Poland)
Peak Foods, LLC (US)
Lacto Misr (Egypt)
Rich Products Ltd (UK)
针对产品特性，本报告将其分为下面几类，主要分析这几类产品的价格、销量、市场份额及增长趋势。主要包括：
粉末
液体
针对产品的主要应用领域，本报告提供主要领域的详细分析、每种领域的主要客户（买家）及每个领域的规模、市场份额及增长率。主要应用领域包括：
粉甜点
装饰奶油
填充应用
即食应用
蛋糕馅料
其他
本报告同时分析国外地区的生产与消费情况，主要地区包括北美、欧洲、日本、东南亚和印度等市场。对比国内与全球市场的现状及未来发展趋势。
主要章节内容：
第一章，分析顶面基层行业特点、分类及应用，重点分析中国与全球市场发展现状对比、发展趋势对比，同时分析中国与全球市场的供需现在及未来趋势。
第二章，分析全球市场及中国生产顶面基层主要生产商的竞争态势，包括2019年和2020年的产量 、产值（万元）、市场份额及各厂商产品价格。同时分析行业集中度、竞争程度，以及国外先进企业与中国本土企业的SWOT分析。
第三章，从生产的角度，分析全球主要地区顶面基层产量 、产值（万元）、增长率、市场份额及未来发展趋势，主要包括美国、欧洲、日本、中国、东南亚及印度地区。
第四章，从消费的角度，分析全球主要地区顶面基层的消费量 、市场份额及增长率，分析全球主要市场的消费潜力。
第五章，分析全球顶面基层主要厂商，包括这些厂商的基本概况、生产基地分布、销售区域、竞争对手、市场地位，重点分析这些厂商的顶面基层产能 、产量 、产值（万元）、价格、毛利率及市场占有率。
第六章，分析不同类型顶面基层的产量 、价格、产值（万元）、份额及未来产品或技术的发展趋势。同时分析全球市场的主要产品类型、中国市场的产品类型，以及不同类型产品的价格走势。
第七章，本章重点分析顶面基层上下游市场情况，上游市场分析顶面基层主要原料供应现状及主要供应商，下游市场主要分析顶面基层的主要应用领域，每个领域的消费量 ，未来增长潜力。
第八章，本章分析中国市场顶面基层的进出口贸易现状及趋势，重点分析中国顶面基层产量、进口量、出口量 及表观消费量关系，以及未来国内市场发展的有利因素、不利因素等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2219d99baa518a1138133e1e992876af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58d032fec9e6d189a15bef7327b9b8d/" rel="bookmark">
			2021-2027年全球与中国豪华地毯行业市场前瞻与投资战略规划分析报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021-2027年全球与中国豪华地毯行业市场前瞻与投资战略规划分析报告
本报告研究全球与中国市场豪华地毯的发展现状及未来发展趋势，分别从生产和消费的角度分析豪华地毯的主要生产地区、主要消费地区以及主要的生产商。重点分析全球与中国市场的主要厂商产品特点、产品规格、不同规格产品的价格、产量、产值及全球和中国市场主要生产商的市场份额。
主要生产商包括：
Shaw Industries
Mohawk
Oriental Weavers
Milliken
Beaulieu
Interface
Dinarsu
Balta
Infloor
Tarkett
Dixie Group
Brintons
Merinos
Dongsheng Carpet Group
Jiangsu Kaili Carpet
Shanhua Carpet
Haima Carpet
TY Carpet
COC Carpet
Shenzhen Meijili Carpet
HUADE Group
Zhemei Carpets
针对产品特性，本报告将其分为下面几类，主要分析这几类产品的价格、销量、市场份额及增长趋势。主要包括：
编织
针毡
打结
其他
针对产品的主要应用领域，本报告提供主要领域的详细分析、每种领域的主要客户（买家）及每个领域的规模、市场份额及增长率。主要应用领域包括：
商业
首页
运输
本报告同时分析国外地区的生产与消费情况，主要地区包括北美、欧洲、日本、东南亚和印度等市场。对比国内与全球市场的现状及未来发展趋势。
主要章节内容：
第一章，分析豪华地毯行业特点、分类及应用，重点分析中国与全球市场发展现状对比、发展趋势对比，同时分析中国与全球市场的供需现在及未来趋势。
第二章，分析全球市场及中国生产豪华地毯主要生产商的竞争态势，包括2019年和2020年的产量 、产值（万元）、市场份额及各厂商产品价格。同时分析行业集中度、竞争程度，以及国外先进企业与中国本土企业的SWOT分析。
第三章，从生产的角度，分析全球主要地区豪华地毯产量 、产值（万元）、增长率、市场份额及未来发展趋势，主要包括美国、欧洲、日本、中国、东南亚及印度地区。
第四章，从消费的角度，分析全球主要地区豪华地毯的消费量 、市场份额及增长率，分析全球主要市场的消费潜力。
第五章，分析全球豪华地毯主要厂商，包括这些厂商的基本概况、生产基地分布、销售区域、竞争对手、市场地位，重点分析这些厂商的豪华地毯产能 、产量 、产值（万元）、价格、毛利率及市场占有率。
第六章，分析不同类型豪华地毯的产量 、价格、产值（万元）、份额及未来产品或技术的发展趋势。同时分析全球市场的主要产品类型、中国市场的产品类型，以及不同类型产品的价格走势。
第七章，本章重点分析豪华地毯上下游市场情况，上游市场分析豪华地毯主要原料供应现状及主要供应商，下游市场主要分析豪华地毯的主要应用领域，每个领域的消费量 ，未来增长潜力。
第八章，本章分析中国市场豪华地毯的进出口贸易现状及趋势，重点分析中国豪华地毯产量、进口量、出口量 及表观消费量关系，以及未来国内市场发展的有利因素、不利因素等。
第九章，重点分析豪华地毯在国内市场的地域分布情况，国内市场的集中度与竞争等。
第十章，分析影响中国市场供需的主要因素，包括全球与中国整体外部环境、技术发展、进出口贸易、以及行业政策等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58d032fec9e6d189a15bef7327b9b8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b20d63be2d52640f85bb57ec180757/" rel="bookmark">
			2021-2027年全球与中国常规脱水呼吸器行业市场前瞻与投资战略规划分析报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021-2027年全球与中国常规脱水呼吸器行业市场前瞻与投资战略规划分析报告
本报告研究全球与中国市场常规脱水呼吸器的发展现状及未来发展趋势，分别从生产和消费的角度分析常规脱水呼吸器的主要生产地区、主要消费地区以及主要的生产商。重点分析全球与中国市场的主要厂商产品特点、产品规格、不同规格产品的价格、产量、产值及全球和中国市场主要生产商的市场份额。
主要生产商包括：
ABB (Switzerland)
Siemens (Germany)
Des-Case (US)
Dry-Tech (US)
AGM Container Controls (US)
针对产品特性，本报告将其分为下面几类，主要分析这几类产品的价格、销量、市场份额及增长趋势。主要包括：
&lt;20千克
20千克至40千克
40千克
针对产品的主要应用领域，本报告提供主要领域的详细分析、每种领域的主要客户（买家）及每个领域的规模、市场份额及增长率。主要应用领域包括：
公用事业
工业
大型车
其他
本报告同时分析国外地区的生产与消费情况，主要地区包括北美、欧洲、日本、东南亚和印度等市场。对比国内与全球市场的现状及未来发展趋势。
主要章节内容：
第一章，分析常规脱水呼吸器行业特点、分类及应用，重点分析中国与全球市场发展现状对比、发展趋势对比，同时分析中国与全球市场的供需现在及未来趋势。
第二章，分析全球市场及中国生产常规脱水呼吸器主要生产商的竞争态势，包括2019年和2020年的产量 、产值（万元）、市场份额及各厂商产品价格。同时分析行业集中度、竞争程度，以及国外先进企业与中国本土企业的SWOT分析。
第三章，从生产的角度，分析全球主要地区常规脱水呼吸器产量 、产值（万元）、增长率、市场份额及未来发展趋势，主要包括美国、欧洲、日本、中国、东南亚及印度地区。
第四章，从消费的角度，分析全球主要地区常规脱水呼吸器的消费量 、市场份额及增长率，分析全球主要市场的消费潜力。
第五章，分析全球常规脱水呼吸器主要厂商，包括这些厂商的基本概况、生产基地分布、销售区域、竞争对手、市场地位，重点分析这些厂商的常规脱水呼吸器产能 、产量 、产值（万元）、价格、毛利率及市场占有率。
第六章，分析不同类型常规脱水呼吸器的产量 、价格、产值（万元）、份额及未来产品或技术的发展趋势。同时分析全球市场的主要产品类型、中国市场的产品类型，以及不同类型产品的价格走势。
第七章，本章重点分析常规脱水呼吸器上下游市场情况，上游市场分析常规脱水呼吸器主要原料供应现状及主要供应商，下游市场主要分析常规脱水呼吸器的主要应用领域，每个领域的消费量 ，未来增长潜力。
第八章，本章分析中国市场常规脱水呼吸器的进出口贸易现状及趋势，重点分析中国常规脱水呼吸器产量、进口量、出口量 及表观消费量关系，以及未来国内市场发展的有利因素、不利因素等。
第九章，重点分析常规脱水呼吸器在国内市场的地域分布情况，国内市场的集中度与竞争等。
第十章，分析影响中国市场供需的主要因素，包括全球与中国整体外部环境、技术发展、进出口贸易、以及行业政策等。
第十一章，分析未来行业的发展走势，产品功能、技术、特点发展趋势，未来的市场消费形态、消费者偏好变化，以及行业发展环境变化等。
第十二章，分析中国与欧美日等地区的销售模式、销售渠道对比，同时探讨未来销售模式与渠道的发展趋势。
第十三章，是本报告的总结部分，该章主要归纳分析本报告的总体内容、主要观点以及对未来发展的看法。
正文目录
第一章 行业概述及全球与中国市场发展现状
1.1 常规脱水呼吸器行业简介
1.1.1 常规脱水呼吸器行业界定及分类
1.1.2 常规脱水呼吸器行业特征
1.1.3不同种类常规脱水呼吸器价格走势（2021-2027年）
1.2 常规脱水呼吸器产品主要分类
1.2.1.&lt;20千克
1.2.2.20千克至40千克
1.2.3.&gt;40千克
1.3 常规脱水呼吸器主要应用领域分析
1.3.1.公用事业
1.3.2.工业
1.3.3.大型车
1.3.4.其他
1.4 全球与中国市场发展现状对比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b20d63be2d52640f85bb57ec180757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff7535d957d69fb42d71f8a99f151140/" rel="bookmark">
			SQL Server内存恶意增加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MSSQL -&gt; Log -&gt; Polybase -&gt; dump
将这里面，除去最后一个文本文件以外的所有的日志文件全部删除
数据库选择 属性 -&gt; 文件
设置日志文件限制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b305cb2bde43bcbcfcca9c29a7d01b56/" rel="bookmark">
			电脑双屏时，微信截屏会部分黑屏-解决办法（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 鼠标右键点击微信图标--属性--兼容性--更改更高dpi设置--勾选 替代高DPI缩放行为。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b148c25746de1c5bd941802a65d43a80/" rel="bookmark">
			javaWeb:连接池学习druid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接池 1.连接池是什么？2.druid开源连接池：结果：运行成功：druid:配置文件：和jdbc工具类一样学习中遇到的错误： 1.连接池是什么？ 连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。是装有连接的容器
2.druid开源连接池： druid中有API :获取连接mysql
DruidDataSource dataSource=new DruidDataSource();//创建druid对象
dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);//驱动连接
dataSource.setUrl(“jdbc:mysql://localhost:3306/new_schema”);//连接数据库
dataSource.setUsername(“root”); //用户名
dataSource.setPassword(“your-password”);//密码
Connection conn=dataSource.getConnection(); //连接完整
代替了：
导入druid开源连接池：
版本：(要不然不兼容) 选择合适的
mysql-connector: 8.0.27
druid:1.2.8
import com.alibaba.druid.pool.DruidDataSource; import java.sql.*; public class yourew { //driverClassName=com.mysql.jdbc.Driver //url=jdbc:mysql://localhost:3306/new_schema //password=your-password //username=root public static void main(String[]args) { DruidDataSource dataSource=new DruidDataSource(); // dataSource.setDriverClassName("com.mysql.jdbc.Driver"); // dataSource.setUrl("jdbc:mysql://localhost:3306/new_schema"); //dataSource.setUsername("root"); //dataSource.setPassword("your-password"); // Connection conn=dataSource.getConnection();//获得连接 try{ //手动设置数据库连接参数 dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/new_schema"); dataSource.setUsername("root"); dataSource.setPassword("your-password"); Connection conn=dataSource.getConnection(); String sql="select* from user"; Statement sqtm=conn.createStatement(); ResultSet rs=sqtm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b148c25746de1c5bd941802a65d43a80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6216003c581956a90be372b2aae7fc/" rel="bookmark">
			linux下安装mysql8/5.6/5.7&#43;设置远程连接全攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装mysql8
安装mysql5.6
安装mysql5.7
一、安装mysql8 基本命令
安装 :　yum install mysql-community-server
启动 :　service mysqld start/restart
停止 :　service mysqld stop
查看状态: service mysqld status
本文包括： mysql安装 修改密码 开启远程访问 忘记密码后重置密码 卸载mysql
【安装步骤】
contos7默认安装了mariadb数据库,这里把他移除：yum remove mariadb-libs.x86_64
创建文件目录 mkdir /etc/mysql
获取下载链接
4. 在该目录下 下载刚刚的安装链接。wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm
下载完成后，会得到这个文件名，直接yum localinstall把它添加到本地。
5. 这时可以先看添加成功没有 yum search mysql
6. 安装：yum install mysql-community-server
启动测试： service mysqld start service mysqld status
【修改密码】
1. 刚刚启动成功之后, 用命令查看默认密码并且登录
查看：cat /var/log/mysqld.log | grep password
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b6216003c581956a90be372b2aae7fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23e740ade088280d156f3944436e377/" rel="bookmark">
			数据结构考研 结构体类型总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 typedef struct{ //线性表的顺序存储 ~ 数组 + 长度 ElemType data[maxsize]; int length; }SqList; typedef struct{ //线性表动态分配定义 ElemType *data; int listsize; int length; }SeqList; typedef struct LNode{ //单链表 ~ 栈链式 ElemType data LNode *next }LNode,*LinkList; typedef struct DNode{ //双链表 ElemType data; DNode *prior,*next; }DNode,*DLinkList; typedef struct{ //栈的顺序存储 ElemType data[maxsize]; int top; }SqStack; typedef struct Linknode{ //栈的链式存储 ~ 单链表 ElemType data; Linknode *next; }*LiStack; typedef struct{ //队列的顺序存储 ElemType data[maxsize]; int front,rear; }SqQueue; typedef struct Linknode{ //队列的链式存储 ~ 单链表 + ElemType data; LinkNode *next; }LinkNode; typedef struct{ LinkNode *front,*rear; }LinkQueue; typedef struct{ //串的定长顺序存储 ~ 顺序线性表 char ch[maxsize]; int length; }SString; typedef struct{ //串动态分配定义 ~ 定长串顺序存储 char *ch; int length; }HString; //二叉树的顺序存储，用于堆排序（完全二叉树） ~ 数组 （+ 长度） //且数组第0位一般不放数据；用“0”表示树中不存在的空节点（因为不一定是完全二叉树） typedef struct BiTNode{ //二叉树的链式存储 ElemType data; BiTNode *lchild,*rchild; }BiTNode,*BiTree; typedef struct CSNode{//二叉树的孩子兄弟表示法 ElemType data; struct CSNode *firstchild,*nextsibling; }CSNode,*CSTree; typedef char VertexType; typedef int EdgeType; //图的邻接矩阵存储定义 typedef struct{ VertexType Vex[maxsize];//顶点表 EdgeType Edge[maxsize][maxsize];//邻接矩阵，边表 int vexnum;//顶点数 int arcnum;//弧数 }MGraph; //图的邻接表存储定义 typedef struct ArcNode{//与顶点连接的点 int adjvex; ArcNode *next; }ArcNode; typedef struct VNode{//顶点表节点 VertexType data; ArcNode *first; }VNode,AdjLst[maxsize]; typedef struct{ AdjList vertices;//邻接表 int vexnum;//顶点数 int arcnum;//弧数 }ALGraph; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed3599cf5b29c55784d899f1bd1e7ab/" rel="bookmark">
			LDR2001电脑免驱USB转串口芯片方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USB转串口对于需要用到串口的用户们提供了便利，下面介绍的这款LDR2001芯片功能强大，电脑免驱，自带Billboard功能。
LDR2001 芯片是乐得瑞科技设计的一个免驱的 USB 转串口的 CDC 类芯片，可以实现USB 转串口和 Billboard 的功能。当使用了 LDR2001 芯片的设备接入 USB HOST 时，会在HOST 端弹出 Billboard 窗口，提醒用户该设备所具有的 Alternate Mode 功能。电脑直接免驱动使用。
LDR2001特点：
全速 USB 设备接口，支持 1.1 以上版本，Billboard 支持 USB2.01 以上的版本，外围元器件无需晶体和电容。
仿真标准免驱串口，用于升级原串口外围设备，或者通过 USB 增加而外串口。
计算机端无需下载驱动，Billboard 设备类在 Windows10 以上系统免驱。
硬件全双工串口，内置收发缓冲区，支持通讯波特率 50bps～2Mbps。
无奇偶，偶数，奇数，标记或空间奇偶校验。
支持奇偶校验，溢出和成帧错误。
支持单通道 RS-232 和 RS-422 接口。
支持 5V 电源电压和 3.3V 电源电压。
支持本地 Billboard 设备类驱动程序。
LDR2001采用MSOP10封装，体积小
功能说明
LDR2001 芯片内置了 USB 上拉电阻，UDP 和 UDM 引脚应该直接连接到 USB 总线上。
LDR2001 芯片内置了电源上电复位电路。还提供了低电平有效的外部复位输入引脚。
LDR2001 芯片已经内置时钟发生器，无需外部晶体及震荡电容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ed3599cf5b29c55784d899f1bd1e7ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ba56ff6d8d1da72a8818c0abacdf13/" rel="bookmark">
			X86汇编调试环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近毕设需要做一个基于X86的微型OS内核，一直在学习汇编，前来记录一下
汇编环境搭建 本次使用vscode搭建的，需要的插件有X86 and X86_64 Assembly（也可以使用masm插件）,还有一个hexdump for VSCode。
安装NASM，并添加到环境变量
安装QEMU,并将其添加到环境变量下
编写代码：（代码来自30天自制操作系统）
; hello-os ; TAB=4 ; 标准FAT12格式软盘专用的代码 Stand FAT12 format floppy code DB 0xeb, 0x4e, 0x90 DB "HELLOIPL" ; 启动扇区名称（8字节） DW 512 ; 每个扇区（sector）大小（必须512字节） DB 1 ; 簇（cluster）大小（必须为1个扇区） DW 1 ; FAT起始位置（一般为第一个扇区） DB 2 ; FAT个数（必须为2） DW 224 ; 根目录大小（一般为224项） DW 2880 ; 该磁盘大小（必须为2880扇区1440*1024/512） DB 0xf0 ; 磁盘类型（必须为0xf0） DW 9 ; FAT的长度（必须是9扇区） DW 18 ; 一个磁道（track）有几个扇区（必须为18） DW 2 ; 磁头数（必须是2） DD 0 ; 不使用分区，必须是0 DD 2880 ; 重写一次磁盘大小 ; 书中作者说原因不明的两行代码我查到了，see https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ba56ff6d8d1da72a8818c0abacdf13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e206e1c2c320e9d9245d96bde7a4a64b/" rel="bookmark">
			Python读取json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、JSON文件二、读取JSON数据 一、JSON文件 准备一个json文档数据，把对应的参数添加至此json文件下，通过python去获取对应的数据
代码如下（示例）：
{ "item": [ { "requests": { "url": "", "body": { "isWindow": 0, "logoUrl": "", "name": "new2", "router": "", "sort": 0, "systemId": 0, "useType": 0 } }, "response": [ {"code":"200"} ] }, { "requests": { "url": "", "body": { "isWindow": 0, "logoUrl": "", "name": "new6", "router": "", "sort": 0, "systemId": 0, "useType": 1 } }, "response": [ {"code":"200"} ] }, { "requests": { "url": "", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e206e1c2c320e9d9245d96bde7a4a64b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/069b97739a8e469ba71c13caebf62c60/" rel="bookmark">
			炫酷的css例子网站，赶紧收藏起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址一：https://shiroi.netlify.app/
网址二：https://juejin.cn/post/6844904031513477128
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63a4086f644f58be359727ac0506191/" rel="bookmark">
			今日初学异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常是程序中的一些错误，但并不是所有的错误都是异常。
异常体系 Throwable类是Java语言中所有错误或异常的超类，它有两个子类分别是Error,Exception.
Error（错误）是Throwable的子类，Error一般是指程序的严重错误，一般不被捕获，只能抛出。
Exception（异常/例外）是Throwable的子类，Exception可以捕获也可以抛出。
.异常的处理方式
抛出异常： 1 声明抛出异常 1）在方法签名上声明，具体是在参数列表后，大括号前，使用throws异常类名来声明
例：
public static void test(int a) throws ArithmeticException{} 2）声明异常，不一定就会抛出异常
3）如果有异常要抛出，就是将异常信息以标准错误流打印到控制台
4）throws后面可以写多个异常类名，中间用 , 隔开。该方法可以抛出多种异常，但不是同时抛出多种异常
5）程序抛出异常，那么程序就会在抛出异常处停止，不再向下执行
6）异常抛出是向上抛出，即抛给方法调用者，一层一层向上抛，直到main方法，main方法抛出到控制台。
2 主动抛出异常 1）在程序中是以throw主动抛出异常对象
2）throw异常对象：
private static void m(int n) throws MyException1, MyException2 { if (n == 1) { throw new MyException1("n==1"); } else { throw new MyException2("n==2"); } } } 3 throw和throws的区别： 1）作用：throw是抛出异常对象，throws是声明异常类型的
2）位置：throw是在方法体重，throws是在方法签名上
3）写法：throw后面跟异常对象，且只能是一个对象
throws后面跟异常类名，且可以写多个异常类名 捕获异常 使用try和catch关键字可以捕获异常。try/catch代码块放在异常可能发生的地方，try/catch代码块称为保护代码，语法如下：
try { //程序代码 } catch (Exception e) { // catch 块 } } catch语句包含要捕获异常类型的声明，当保护代码块中发生一个异常时，try后面的catch块就会被检查。如果发生的异常包含在catch块中，异常会被传递到该catch块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63a4086f644f58be359727ac0506191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e539c08bf325701cd5a55507b589a3c0/" rel="bookmark">
			Vscode - 回到上一次编辑代码位置和下一次代码编辑位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		alt+-&gt;:下一次代码编辑位置
alt+&lt;-:上一次代码编辑位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cc40169387565c6f9ea3f1c2989195/" rel="bookmark">
			关于C#的用途
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于C#的用途，本人的见解是十分片面的，希望大家见谅。
因为大学只学过C语言，并没有学习过类似于C++或者C#这种面向对象的语言，所以C#的编程功力十分有限。但是在毕业后的几年时间里，通过各种不同的途径学习了解QT、C#和Python，层面仅限于了解。最终在各种工作场景下，发现C#还是比较适合我的,因为C#的语法和编译工具都贴切C语言，这让我这个没怎么读过书的人都能比较容易上手实现我的目标。
C#在我的工作中都是编写上位机做一些辅助性质的工作，因为水平有限所以不可能成为主要工作，并且目前的工作主要语言也是C语言。如果想单纯的靠写winform这个简单上位机存活，可能工资会有所限制，C#目前的工作机会也是相对较少，也可能是我不在这个行业里，但是如果会openCV视觉等技术，结合C#的话，在工控、自动化应该也还是很吃香的。
我用C#主要做文件的处理、串口通信、软件升级这种比较简单的功能，也玩不出什么花，但是C#相比于C语言，就帮开发者造好了好多轮子，方便开发者实现功能，相比于嵌入式的环境下，更是大大的便利。
如果想要用C#做上位机，可以先网上看教学视频，新建工程，控件的使用，然后就百度一个和自己想要实现的功能相似的工程或者源码，下载下来改吧改吧，就能最快时间的实现目标。当然可以买本书回来，跟着书上的教学，自己敲一遍。为什么软件会比较多人学，而硬件工程师会比较少呢，就因为软件见效快，敲了立马能验证出结果，而硬件还得捣鼓半天，所以跟着书敲是完全可行的，前提是比较想深入了解C#。
最后你想要选用那种语言来做上位机，我肯定建议你选择QT，QT是跨平台的，可以再Windows上，也可以在Linux上，如果你真的做腻了嵌入式，完全可以凭着你过硬的技术转行做QT，而且工资也不低。但是C#就比较尴尬了，你要是由嵌入式转C#就很难拿到高的工资，而且有些是生产做自动化上位机或者工控机，环境条件也差一点吧。但是如果你只想快速的实现你的目标，而且没有过多的想法的情况下，C#还是很好用的，方便快捷。
最后的最后，以上见解仅仅个人十分片面的看法。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c283800fc7f9d4ca3fe2db9a16cb617/" rel="bookmark">
			关于一次post请求参数为json格式时，HTTPServletRequest拿不到请求参数，从而记录一次笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在试着搭建微服务zuul网关的时候，想到用zuul自带的过滤器来做一次token校验，结果就是为了图省事儿用了post方法传了json格式的参数，结果就是传了token参数，他就是校验不到。
自己在代码里用的 HTTPServletRequest来接受参数
结果当然就是无论怎么传都接受不到了，对于getParameter这种获取方式，只能获取到表单形式（header），从而拿不到参数为json格式的post请求参数。（对于请求参数的获取方式大家自行百度吧哈哈，选择适合自己的最重要。）
所以更改取值方法，用I/O流去读取就可以拿到一个json类型的字符串，从而在取出自己想要的token去校验就可以了：
@Override public Object run() { RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); log.info(String.format("%s &gt;&gt;&gt; %s", request.getMethod(), request.getRequestURL().toString())); // Object accessToken = request.getParameter("token"); Object accessToken = null; try { ServletInputStream inputStream = request.getInputStream(); String s = CharStreams.toString(new InputStreamReader(inputStream, Charsets.UTF_8)); JSONObject jsonObject = JSON.parseObject(s); accessToken = jsonObject.get("token"); log.info("token值为:" + accessToken); } catch (IOException e) { e.printStackTrace(); } if (accessToken == null) { log.warn("token is empty"); requestContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c283800fc7f9d4ca3fe2db9a16cb617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12cdfb4f0028fd6ca5bd7b090cb61939/" rel="bookmark">
			element-UI 图标点击切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a6d395b6aa8300ae89bd91203f9fdb/" rel="bookmark">
			AD 画PCB 布线时，连线就变绿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：把PCB界面缩小，如果发现了一个红色的阴影矩形块，那么把它删除。 红色的矩形块成为ROOM，在原理图导入PCB的时候会出现是否需要勾选的选项，默认是勾选的，新手一般都是默认，然后把红色的框删除即可。
下面的是另一个错误，老鸟勿喷。
先思考一下，是不是太久没画PCB了吧，忘得差不多了
下面说一下原因，可以看到下图，有一个变绿了，有一个没有。这是为什么呢？
很简单的一个原因：因为布线选择的线选错了。
在布线的时候我们应该使用的是交互式布线，而不是就简单的随便画一根文本线条。
如下图所示：出现绿色的原因就是选择了错误的线。
太久没有画PCB了，惭愧惭愧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73e2975c157008d05b43d3d998dfcb2/" rel="bookmark">
			pinia简介和setup语法糖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pinia简介和setup语法糖 1.pinia的基本特点 ​ pinia同样是一个Vue 状态管理工具，它和vuex有很多相似的地方。本质上他是vuex团队核心成员开发的，在vuex上面提出了一些改进。与vuex相比，pinia去除了vuex中对于同步函数Mutations和异步函数Actions的区分。直接在Actions中便能够使用同步和异步方法（在vuex的开发计划中也将会除去同步和异步的区分）。其次相比于vuex，pinia对于typescript的支持性更好，友好的devTools支持，pinia只有1kb，简化了很多方法的写法。由于vuex比较完善，因此,pinia更加适合小型项目，vuex更加适合大型项目。
2.基本配置和使用 //利用vue-cli创建一个pinia项目（这里选择创建vue3项目） vue create pinia //在项目中安装pinia npm install pinia@next 项目中导入pinia
import { createApp } from 'vue' import App from './App.vue' import { createPinia } from 'pinia' //需要注意的是从pinia中结构出来的createPinia是一个函数,挂载需要先调用执行 createApp(App).use(createPinia()).mount('#app') 配置状态管理专用文件，在根目录下创建一个store文件，并新建一个index.js文件
import {defineStore} from 'pinia'; export const userTestStore = defineStore({//需要注意的是，defineStore返回的是一个回调方法 id:'test',//test是该状态管理的唯一标志也可以使用defineStore(id,{});的形式 state(){ return { name:'hello pinia', age:20 } }, getters:{ testGetters(){ return this.name+'...';//直接利用this便能够获取到里面的内容不需要使用state中间对象 } }, actions:()=&gt;{ addAge:function(){ setInterval(()=&gt;{ this.age++; },1000) } } }) 在组件中引用状态管理变量
从上图可以看出，获取参数的方法被简化了。
3.pinia传参与调用 下面给出调用store里面的带参方法例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d73e2975c157008d05b43d3d998dfcb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85be0223ce5560adee98bf4abd6377c3/" rel="bookmark">
			实现二叉树类及若干应用算法（附具体代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、二叉树的存储结构 1. 顺序存储结构
由于每个数据元素的存储位置彼此之间有着一定的关系，因此可以根据结点的编号直接计算出他的父结点、左右孩子结点的位置。类似的，其他操作也可以通过计算得出。
但是此存储结构只对于满、完全二叉树来说效率极高，而对于一般的二叉树而言使用顺序存储会造成空间极大的浪费。
2. 链式存储结构
链式存储中，每个结点结构应该包含两个指针域，分别指向左、右孩子结点，以及一个结点数据。
struct BiNode { T data;	//结点数据 BiNode&lt;T&gt;* lchild;	//左孩子 BiNode&lt;T&gt;* rchild;	//右孩子 }; 使用链式存储虽然还是有许多空指针域，但是后面会进一步改进该程序使得空指针域得以利用，所以我们选择链式存储。
二、二叉树的遍历算法 1.先序遍历
先输出本身的值，再依次输出左、右孩子的值。
void BiTree&lt;T&gt;::PreOrder(BiNode&lt;T&gt;* p) { if (p == NULL) return; cout &lt;&lt; p-&gt;data; PreOrder(p-&gt;lchild); PreOrder(p-&gt;rchild); } 2.中序遍历
先输出左孩子的值，再输出本身的值，最后输出右孩子的值。
void BiTree&lt;T&gt;::InOrder(BiNode&lt;T&gt;* p) { if (p == NULL) return; InOrder(p-&gt;lchild); cout &lt;&lt; p-&gt;data; InOrder(p-&gt;rchild); } 3.后序遍历
先输出左、右孩子的值，最后输出本身的值。
void BiTree&lt;T&gt;::PostOrder(BiNode&lt;T&gt;* p) { if (p == NULL) return; PostOrder(p-&gt;lchild); PostOrder(p-&gt;rchild); cout &lt;&lt; p-&gt;data; } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85be0223ce5560adee98bf4abd6377c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e5f3d0a962db75b548c20c61d7e4d9/" rel="bookmark">
			计算机图形学基础-图形的表示和数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三维形体的表示
线框模型
早期，由定义一个物体的直线和曲面组成
(二义性、无效形体，曲面表示困难，无法进行线面消隐等)
边界表示：用平面&amp;曲面表示；
构造实体几何：基本体素的交并差；
空间分割：空间区域划分成连续非重叠实体。
边界表示法 BR
多边形表面模型：用一组包围物体内部的多边形表示。
1.数据结构
正确存储多边形的集合&amp;拓扑&amp;属性信息
几何信息
顶点表、包含指向顶点表指针的边表、包含指向边表指针的多边形表
示例：
平面的方向：
通常约定法向量指向平面外侧。多边形顶点序列指定为逆时针方向时，法向量方向满足右手定则。
拓扑信息
几何信息+额外信息 = 拓扑信息
将边表扩充成包含指向面表和顶点表的指针，构造出翼边结构
对于不同的面，中间的边V1V2的表示不同。用右手表示，面在边的左侧，端点从内向外；对于面F1，记为边V2V1；对于面F2，记为V1V2.
属性信息：略
2.多边形网格：
多为三角形带或四边形网格
优点：精确实用，适用于多种工具和算法
缺点：表示拓扑关系数据结构较复杂，无法计算空间容积等
扫描表示
沿路径扫描，利用运动规则生成实体；作扫描运动的基本图形和运动方式
表示简单，但是需要时间
构造实体几何法
简单实体的交并差操作
该方法的集合运算实现过程可用二叉树(CSG树)表示
叶子：基本体素或形体变换参数
非终端节点：正则集合运算或变换操作
根节点：最后构造出的实体
优点：构造出多种满足不同需要的实体
缺点：求交困难，且不能显式表示形体边界(解决：光线投射算法)
光线投射算法：
①射线与每个基本体素相交，求交点
②交点相对于CSG树表示的物体进行分类，确定位于边界上的部分交点
③计算参数值并排序，确定最近的交点，得到其所在基本体素表面的法矢量
空间位置枚举
将包含实体的空间分割成小体素，以体素的集合来表示图形对象
简单易理解，容易进行集合、体积运算；存储容量大，且没有边界信息不利于显示。
八叉树(分层树)
对空间自适应划分，是一般的空间位置枚举法的改进。
简单来说，没有实体的部分忽略，停止分割;
完全是实体的部分全部计入，不再分割；
部分是实体的部分继续分割。
二维平面图形的四叉树类似：
BSP树
二叉空间分割；每次将一实体用任一位置和任一方向的平面分为二部分
非规则对象的表示
分形几何
使用过程对具有不规则几何形态的物体（如自然景物）建模
无限自相似性：物体的整体和局部之间细节的无限重现
两个描述要点：分形维数(分数维数)和生成过程(初始生成元、生成元)
分形维数：分形物体的细节变化。物体粗糙性或细碎性的度量。
M=B^d 其中B指放大倍数，M是总个数，d相当于对象的维数。 d=logM/logB 其中指数d相当于维数。
欧式几何便于使用方程来描述由平滑表面和规则形状的物体；
分形几何适用于例如自然景物等的不规则几何形态物体建模。
奠基人B.B.Mandelbrot 周长无穷，但面积为定值
分形物体的细节变化用分形维数(分数维)表示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e5f3d0a962db75b548c20c61d7e4d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a194823b96cbb2e737b20e82106c6639/" rel="bookmark">
			解决SSH连接超时自动断开问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、操作系统 centos7
2、具体步骤 1.修改文件 # vim /etc/ssh/sshd_config 找到 #ClientAliveInterval 0 #ClientAliveCountMax 3 修改为 ClientAliveInterval 60 ClientAliveCountMax 5 参数示意：
ClientAliveInterval：指定服务器向客户端检测是否活动状态的间隔时间，默认为0，将它修改为60，就是每60秒检测一次。
ClientAliveCountMax：指定服务器向客户端检测无响应最大次数，达到次数断开连接，默认为3，可将该参数改为5。
2.重启sshd服务 #检查当前ssh服务 systemctl status sshd.service #重启ssh服务，使新的配置文件生效 systemctl restart sshd.service #检查当前ssh服务 systemctl status sshd.service 3、备注 当前ssh连接超时还是会自动断开，新建立的连接~连接超时后不会再自动断开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5deb2ef1b94713bce6ed701cafc3780/" rel="bookmark">
			STM32CubeMX通过FatFS读写U盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近出现了使用STM32读写U盘的需求，本着自己也出了好多良心博客的份上就像偷懒抄一篇CSDN，但是鉴于某些博主这点小东西都要收费、还不公开源码，一气之下准备自己写一篇博客来谴责某些不良心的博主；（上述气话，接下来上干货）
大致思路 STM32读写U盘主要分为以下几个方面：
1、文件系统（抽象层，以统一方式对不同外设进行读写）
2、USB_Host（USB硬件驱动，维持USB的正常工作）
3、FreeRTOS（操作系统，鉴于各位可能右用到操作系统的需求加上，也可以裸机跑）
具体思想如下：(是不是很简单，就搞不懂这点事为啥要收费)
FatFS USB_Host 需要存储的数据 文件系统规范格式 USB文件 为了方便观察文件是否真实写入到U盘，所以我的想法是在U盘写一个文件，内部写一些数据，然后重新读这个文件，并通过串口将读出来的东西显示出来！
接下来就要配置STM32CubeMX了（我使用的板子是STM32F407IGTx，串口使用串口1，对应收发引脚是PB6和PB7，各位看官可以根据自己的需求更改）
使用的是STM32CubeMX6.3.0，对应的F4芯片的包也要更新，不然会卡死在USB的初始化（被坑过，请勿嘲笑）
具体操作 1、首先选择芯片：STM32F407IGTx
2、配置RCC和SYS（我用的是SWD下载方式）
因为一会儿要配置FreeRTOS，所以时钟源定义为TIM1
3、配置串口1为波特率115200，1停止位8数据位无校验（端口自行定义）
4、配置USB_OTG_FS（默认即可）
5、配置USB_HOST（配置为大容量存储，默认即可）
其中，USBH_DEBUG_LEVEL是用来检查u盘状态的，可以通过串口反馈usb的状态信息，由于我已经测试过了，这里我就配置为0，不返回信息
6、配置文件系统FATFS（按图配置即可）
7、配置FreeRTOS，此处为了简单配置成一个默认任务即可，主任务的堆需要配置的大一点，因为存储数据需要定义较大的空间，定义的堆太小会导致代码跳进硬件错误（Hard_Fault）
8、配置时钟树（我的高速晶振为8MHz，大家按自己的板子配置）
9、配置项目管理界面（我用Keil写，IED配置为MDK-ARM，堆和栈都需要设大一些，防止数据溢出导致的Hard_Fault）
代码生成器如图配置，我个人习惯
配置完成后点击右上方生成代码即可！（出现警告不用管，那个是因为某些USB需要通过MCU的IO或外部的IIC芯片的IO控制三极管给USB供电，需要在USB内配置供电IO的接口，我的是5V直供，故不管）
代码部分 打开项目之后直接转到freertos.c下，找到刚刚建立的任务，可见CubeMX已经帮我们对USB进行初始化了
1、引入对应的头文件
此处我需要使用到串口、文件系统的USB相关数据，故在/* USER CODE BEGIN Includes */后追加包含对应的头文件：
/* USER CODE BEGIN Includes */ #include "usart.h" #include "usb_host.h" #include "fatfs.h" /* USER CODE END Includes */ 2、添加相关变量并执行对应的FatFS操作（说明看注释）此部分代码在for循环中添加
if(Appli_state == APPLICATION_READY)//U盘已经加载完成 { if(status == 0)//U盘加载后只运行一次 { status = 1; retUSBH=f_mount(&amp;USBHFatFS, (TCHAR const*)USBHPath, 1); if(retUSBH==FR_OK) { HAL_UART_Transmit(&amp;huart1,(uint8_t*)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5deb2ef1b94713bce6ed701cafc3780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e494e5c40837115e8c3f8e4063b84f81/" rel="bookmark">
			解决电脑蓝牙连不上问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我目前试过最有效办法
进入bios系统，关闭蓝牙设置，重启，再进入BIOS系统，打开蓝牙设置，重启后就可以用了。
如何进入BIOS系统？
搜索栏搜索恢复弹出重启此电脑
依次点击疑难解答，高级选项，uefi固件设置，重启
然后你就进入啦，哈哈哈哈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e32721ca5e4891b8d8db259209d3d70/" rel="bookmark">
			An HTTP error occurred when trying to retrieve this URL.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用 " Anaconda Prompt " 创建 pytorch虚拟环境时，一直一直一直一直出现
"""
An HTTP error occurred when trying to retrieve this URL. HTTP errors are often intermittent, and a simple retry will get you on your way. """
这个问题！！
很多大佬的关于更换清华源什么的回答（网上有很多这个问题的解决办法），很多人都回答有用 可我的还是不可 : ( 哭辽
终于！！！！
找到了这篇
"""
Anaconda抛出HTTP错误，任何下载命令使用不了 - 简书 (jianshu.com)
"""
可能是防火墙问题？？！！ （ 闻所未闻.jpg）
我试试
使用命令 """
conda config --set ssl_verify false
"""
woc!!!!
解决！
加油啊大家！虽然解决各种安装bug的问题很痛苦 但请坚持下去 我们一起 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/164/">«</a>
	<span class="pagination__item pagination__item--current">165/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/166/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>