<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5974be047c25b752c34fff2b5b13764/" rel="bookmark">
			python程序的name属性作用是什么_Python关于__name__属性的含义和作用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的模块(.py文件)在创建之初会自动加载一些内建变量，__name__就是其中之一。Python模块中通常会定义很多变量和函数，这些变量和函数相当于模块中的一个功能，模块被导入到别的文件中，可以调用这些变量和函数。那么这时 __name__ 的作用就彰显了，它可以标识模块的名字，可以显示一个模块的某功能是被自己执行还是被别的文件调用执行，假设模块A、B，模块A自己定义了功能C,模块B调用模块A，现在功能C被执行了：
如果C被A自己执行，也就是说模块执行了自己定义的功能，那么 __name__=='__main__'
如果C被B调用执行，也就是说当前模块调用执行了别的模块的功能，那么__name__=='A'(被调用模块的名字)
其实换一种说法也就是表示当前程序运行在哪一个模块中
下面举例说明：
首先自定义模块Student,在模块中定义功能Differ()
然后先自身执行，结果如下， __name__=='__main__'
然后B调用执行，结果 __name__=='Student'
上面出两次结果，是因为python中导入模块会先将文件执行一遍，如下图
到这儿可能有人已经注意到，上面的__main__ 在python中作可以为函数的入口，而实际工程常用 if __name__=='__main__'来表示整个工程开始运行的入口。此外你如果不想让功能的某部分被别的模块调用执行，比如我自定的模块Student里的‘我的密码是xxx',只有自己执行才可以打印密码。所有你可以把部分写在if语句里，只有__name__=='__main__'的时候才能执行。这个可以这么理解，在if语句之外代码是最外层的，有点“全局变量”的意思，放入if里面就成了私有的了。
知识点扩充
1.__name__
__name__ 是属于 python 中的内置类属性，就是它会天生就存在与一个 python 程序中，代表对应程序名称。
也分两种情况：
1)当python程序自己执行时，__name__变量的值就是：__main__
2) 当python程序是作为模块被导入时，那么__name__变量的值就是：程序的文件名，也就是.py前面的文件名称。
2.使用场景
一般我们说使用场景，肯定会根据该知识点的功能来判断。
情况一：比如有个功能模块的程序test.py，在该程序里面有一部分是测试代码，测试代码块会输出内容，验证该程序是否能完成我们需求的功能。
但是我们在实际导入该模块时，不需要输出测试内容。因此可以用if语句判断__name__的值，进而限制测试代码是否执行。
以上就是python博客结合多篇整理的相关内容，感谢大家的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff171c996f36d7c6515db54049e0916/" rel="bookmark">
			怎么看rx580是不是470刷的_rx580显卡看是不是刷的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rx580显卡怎么看是不是矿卡？开学季到了，狂潮也来了，相信很多学生党都在想着买电脑吧，rx580性价比之王毋庸置疑是不错的选择，很多买家会买到矿卡，那么怎么辨别rx580矿卡是不是刷上去的呢？下面一起来看看吧。
一、矿卡的辨识
网上流传甚广的说法是看菊花黄不黄，NONONO，那都是陈年往事了，现在的矿卡都是降核心频率超显存频率，看菊花有个毛用，正确的姿势是看显存，如果显存发黄、烤焦、流油，100%是矿卡无误了，这代矿卡真正的问题是显存，而不是核心。
二、矿卡BIOS和参数设置
很简单，还是看核心频率和显存频率，凡是降核心频率超显存频率100%是矿卡BIOS，具体参数照着型号网上搜，一眼就能看出来！
刷原厂BIOS的方法网上有教程，照着学吧，刷成转头我不负责，不想冒风险的可以直接在A卡驱动里调参数，给几个关键参数(RX580公版)：核心频率1340MHz，电压1150mV，显存频率2000MHz，电压950mV，鉴于矿卡显存比较脆弱，可以适当降低显存频率使用，胆子大的可以将功耗墙往右拉满(+50%)，因为矿卡BIOS往往限制了TDP，不拉功耗墙跑不满1340默频，性能受到很大限制
三、一些小问题
频繁掉驱动：说明显卡已经无法稳定使用，加电压或者降低核心显存频率，可以苟一段时间，二选一的话建议降频使用，矿卡再加电压很可能直接烧了
开机雪花屏：A卡驱动问题，更新19.1.1版本驱动可解决。
频繁蓝屏死机：重装系统，清灰换硅脂，更新显卡驱动，降低频率，如果还不行，多半是没救了
相关视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ff04471a403750f48670c4ac6b8d0e/" rel="bookmark">
			Summit Wireless科技有限公司推出首款支持无线多通道音频的低成本物联网模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持电视和条形音箱用无线将音频信号传输到环绕声和低音炮音箱，
以获得身临其境的声效体验
沉浸式无线声效技术领先供应商Summit Wireless科技（Summit Wireless Technologies, Inc，纳斯达克股票代码：WISA）推出了一款全新的物联网（IoT）收发器模块，该模块旨在将音频信号以无线的方式从电视和条形音箱低成本地传输到环绕声和低音炮音箱，从而便捷地获得沉浸式声效体验。
这款名为“Discovery”的全新模块由Summit Wireless先进的Wi-Fi兼容软件提供支持，该软件专为固定的低延迟无线音频传输而设计。这款收发器模块可在宽达10平方米的房间内保持多达4个独立的无线音频通道完全同步。Discovery模块非常适合入门级家庭娱乐系统，包括条形音箱、电视、低音炮和杜比全景声（DolbyAtmos®）应用等。
Discovery模块引入了一个名为“ConexUs™”的新型无线扬声器配对过程选项，该选项只需一个简单的按钮即可对扬声器进行配对并为其分配合适的音频通道。一旦扬声器接通电源并放置在所需的家庭影院配置中，配对过程通常只需不到60秒的时间。ConexUs配对过程无需访问路由器、网络密码、特殊用户界面或移动应用程序，从而极大地简化了消费者的开箱即用体验。
Summit Wireless科技业务拓展与战略副总裁Tony Parker说道：“当今，世界各地的消费者正在投资于他们的住所，家庭娱乐已成为当务之急。然而到目前为止，环绕声和低音炮音箱的设置成本和复杂性阻碍了除基本条形音箱之外的大规模市场应用。全新的Discovery模块大大降低了将无线扬声器添加到条形音箱和电视上的集成成本，而这正是消费者的需求。ConexUs使用户有信心自行设置系统，而无需花费额外的费用来雇佣定制安装人员。”
益登科技（EDOM Technology）首席执行官侯靖圻表示：“作为半导体产品代理商和分销商，我们对最新趋势了如指掌，并且我们看到了对高性价比无线家庭娱乐解决方案的需求日益增长。作为Summit Wireless科技Discovery模块在亚洲地区的主要分销商，我们很高兴将新模块带给我们的客户群，并认为它将满足市场对强健可靠无线连接的关键需求。”
如需进一步了解Discovery模组和ConexUs技术，请浏览以下网页：
https://china.summitwireless.com/summit-wifi-coming-soon/
关于益登科技：
益登科技（台湾证券交易所代码：3048）成立于1996年7月，是一家专业的半导体产品代理商和分销商，总部位于中国台湾，在中国大陆、新加坡、泰国、越南、印度、马来西亚等国家和地区设有子公司。我们的分布式产品应用于便携式和可穿戴设备、有线和无线通信、物联网（IoT）、汽车产品、工业控制、计算机、光电和消费类电子产品，涉及数字、模拟和混合信号领域。
关于Summit Wireless科技有限公司：
Summit Wireless科技（纳斯达克股票代码：WISA）是为智能设备和下一代家庭娱乐系统提供沉浸式无线声效技术的领先供应商。通过与领先的消费电子品牌和制造商合作，如三星哈曼国际、LG电子、Klipsch、Bang＆Olufsen、微软Xbox子公司等，Summit Wireless为高解析度内容提供无缝的动态音频体验，可支持包括电影和视频、音乐、体育、游戏/电子竞技等应用。Summit Wireless是WiSA无线扬声器和音频协会的创始成员，并与合作伙伴携手在整个音频行业推广最可靠的互联互通标准。Summit Wireless的前身为Summit Semiconductor，Inc.，总部位于加利福尼亚州圣何塞市，并在台北、中国大陆、日本和韩国设有销售团队。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245e95ae75b0c7ed82b782ce76c81510/" rel="bookmark">
			python 2个列表相减的2种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 list1 = [1, 2, 3, 4, 5, 6] list2 = [1, 3, 4, 5] 第一种 list3 = [item for item in list1 if item not in set(list2)] print(list3) # [2, 6] 第二种 print(set(list1) - set(list2)) # {2, 6} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5545bda572b1dcf39ba13cffec792ab5/" rel="bookmark">
			内容创作者不要再复制粘贴啦，一劳永逸自建个文章多发平台吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文作者：HelloGitHub-蔡文心
大家好！这里是 HelloGitHub 推出的《讲解开源项目》系列，今天给大家带来的一款基于 Node.js 实现的一文多发平台开源项目——ArtiPub（文章发布者）。
一、介绍 众所周知文章每发到一个平台，就能增加一丝让更多人看到的机会。所以内容创作者们不仅需要编写高质量的文章，还要手动分发到不同的平台。这个同步可不是简单地复制粘贴，需要重新排版、上传图片等，十分耗时和繁琐。
HelloGitHub 明白你的痛，所以今天带来一款免费开源的文章自动分发管理平台——ArtiPub，它可以帮助内容创作者将编写好的文章自动发布到掘金、SegmentFault、CSDN、知乎、开源中国等技术社区，传播技术内容的同时获取更多的曝光和关注。它不仅能完成文件的在线编辑和同步，还有数据统计的功能，简直是内容创作的必备神器呀！
项目地址：https://github.com/crawlab-team/artipub
让我们来跟着本文了解下 ArtiPub 的优点和功能，然后跟着步骤用起来，最后让你从 手动同步 内容变为 自动同步。
1.1 安全性 市面上已经存在一文多发的平台会要求用户将自己的账户信息，例如 Cookie 或账号密码上传到对方服务器这样不安全。因为一旦平台发生问题，自己的账户信息会遭到泄漏。虽然我相信一般平台不会恶意操作用户的账户，但如果出现误操作，您的账户隐私将遭到泄漏，平台上的财产也可能遭到损坏，所以还是要尽可能规避这样的风险。而 ArtiPub 不要求用户上传账户信息，所有账户信息全部保存在用户自己本地或者服务器的数据库中，从而规避了这个安全风险。
1.2 Chrome 插件 ArtiPub 有配套的 Chrome 插件，通过 Chrome 插件可以方便地获得用户登陆信息（Cookie），然后将 Cookie 注入到 Puppeteer 操作的 Chromium 浏览器中，浏览器就可以正常登陆网站进行发文操作了。
1.3 支持的平台 掘金
SegmentFault
CSDN
简书
知乎
开源中国
今日头条
博客园
1.4 支持的安装方式 ArtiPub 安装简单，提供了多种安装方式，可以一键安装使用，安装一般只要 5 分钟。
Docker
Npm
源码
考虑到此项目的受众可能包括非程序员人群，接下来本文中将演示最方便的一种方案 使用 Docker 安装。
二、安装 2.1 Docker 准备
Docker 安装文档
Docker-compose 容器编排安装文档
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5545bda572b1dcf39ba13cffec792ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25478923ee00a79a52083e374f1c27da/" rel="bookmark">
			leetcode90. 子集 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例:
输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路 1.类似leetcode78. 子集,但要去重
2.先排序
3.当连续重复数字时， 允许1 1 1 0 0,不允许 1 0 1 0 1或者1 0 0 1 1，即前一个重复数字未选取时，当前数字选取会造成重复
实现
// 去重：当连续重复数字时， 允许1 1 1 0 0,不允许 1 0 1 0 1或者1 0 0 1 1，即前一个重复数字未选取时，当前数字选取会造成重复 class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; tmp; if (nums.empty()) { res.push_back(tmp); return res; } sort(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25478923ee00a79a52083e374f1c27da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad6f3b0106ac67536584aac7d5e9014/" rel="bookmark">
			内部排序算法的性能分析_八大排序算法性能分析及总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、排序算法说明 排序的定义：对一个无序的序列进行排序的过程。
输入：n个数：a1,a2,a3,…,an。
输出：n个数的排列:a1,a2,a3,…,an，使得a1&lt;=a2&lt;=a3&lt;=…&lt;=an。排序的稳定性：相同值的节点相对位置是否会发生改变。
稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面。排序的时间复杂度：一个算法执行所耗费的时间，一般在三种情况下考虑：最好情况、最坏情况、平均情况。空间复杂度：运行完一个程序所需内存的大小。 二、各种排序算法性能分析 1. 插入排序1.1 直接插入排序
直接插入排序的原理是将未排好序的序列一个个地插入到已排好序的序列中，插入时，需要与已排好序的序列进行多次比较，直到找到合适的位置插入，而原来已排好序的部分节点可能需要进行后移操作，这个过程中需要一个额外的空间保存一个值用于交换节点，所以空间复杂度为O(1)。
时间复杂度
最坏情况：当待排序序列正好为逆序状态，首先遍历整个序列，之后一个个地将待插入元素放在已排序的序列最前面，之后的所有元素都需要向后移动一位，所以比较和移动的时间复杂度都是O(n)，再加上遍历整个序列的复杂度，总复杂度为O(n^2)。
最好情况：当待排序序列正好为正序状态，则遍历完整个序列，当插入元素时，只比较一次就够了，所以时间复杂度为O(n)。
平均情况：当被插入的元素放在已排序的序列中间位置时，为平均情况，比较和移动的时间复杂度为O(n/2)，所以总的时间复杂度依然为O(n^2)。
稳定性
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。
1.2 希尔排序
希尔排序是对直接插入排序的优化，它的原理是加大插入排序中元素的间隔，并在这些有间隔的元素中进行插入排序，从而使数据进行大幅度的移动，当进行过依次排序后，再减小间隔再一次进行插入排序，直到间隔缩小为1。这样做的目的可以使得最后排序时整个序列基本有序，而无需再进行过多的元素比较和移动次数，在这个过程中也只需要一个额外的空间保存一个值用于交换节点，所以空间复杂度为O(1)。
时间复杂度与增量的选取有关，计算起来较为复杂，不再细述。
稳定性
希尔排序是进行多次直接插入排序的算法，由于多次插入排序，虽然每一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的。
2. 选择排序2.1 直接选择排序
直接选择排序的原理是在待排序的序列中选取最小（大）的值放在序列的第一个位置。遍历整个序列，首先选取第一位置的值分别与之后所有的值比较，如果后边值更小则与之交换，直到第一轮遍历结束时，序列第一个位置的值就是最小的，接下来继续从第二个、第三个做同样的操作，此过程需要一个额外的空间保存最小值用于交换，所以空间复杂度为O(1)。
时间复杂度
序列无论是正序还是逆序状态，每一轮的最小值需要比较到最后才能确定，所以最坏情况和最好情况下都需要 比较n次，再加上遍历整个序列的O(n)，总的复杂度为O(n^2)，平均情况的复杂度也是O(n^2)。
稳定性
直接选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9， 第一遍选择时第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。
2.2 堆排序
堆排序是对直接选择排序的改进算法，选择排序的特点在于每次选取最小或最大的值，而选取最大值时的比较次数为复杂度的关键，堆排序采用二叉树的方法存储元素，每个节点都满足父节点的值大于等于子节点的特点，与直接选择排序类似，堆排序需要两个个值的空间来存储临时变量，用于交换节点，一次用于存储子树最大节点用于交换子节点，一次用于存储堆顶的值用于交换最后的节点，所以空间复杂度为O(1)。
采用堆的方式寻找最大值是降低时间复杂度的关键，假设有n个数据，需要n-1次建堆的过程，每次建堆的时间复杂度为log2n，但是无论序列的开始状态如何，都需要对堆进行遍历寻找最大值，所以在最好情况、最坏情况和平均情况下的时间复杂度都是O(nlog2n)。
稳定性
堆排序是利用堆的特点，堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆)，这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是一个稳定的排序算法。
3. 交换排序3.1 冒泡排序
冒泡排序是交换类排序算法的典型实现，它的原理是遍历整个序列，比较前后相邻两个值的大小，如果前边比后边大，则交换它们，直到序列的最后的两个值进行比较，这样最后的值就是最大的，之后再进行第二轮、第三轮遍历，直到剩下序列的最前的值。从实现原理上可以知道，冒泡排序只需要一个值的空间用于交换节点，所以空间复杂度为O(1)。
时间复杂度
最坏情况：序列为逆序状态，则每一轮遍历都需要n次交换位置，所以时间复杂度为O(n^2)。
最好情况：序列为正序状态，每一轮遍历不需要交换位置，所以时间复杂度为O(n)。
平均情况：每一轮遍历需要n/2次交换位置，所以时间复杂度依然为O(n^2)。
稳定性
冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，不会发生交换。如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，也不会发生交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。
3.2 快速排序
快速排序是另一种交换类排序方法，它的原理是选择一个基准元素，通常选择第一个元素或者最后一个元素，通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素，此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。首先就地快速排序使用的空间是O(1)的，而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据，每一次都平分数组的情况下空间复杂度为O(logn) ，最差的情况下空间复杂度为O(n)。
时间复杂度
最坏情况：每一次选取的基准元素都是最大或最小的，复杂度为O(n^2)
最好情况：每一次选取的基准元素都能平分整个序列，由于快排涉及到递归调用，所以时间复杂度为O(nlog2n)。
平均情况：平均情况下复杂度也是O(nlog2n)。稳定性
快速排序有两个方向，左边的i下标一直往右走，当a[i]&lt;=a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j]&gt;a[center_index]。如果i和j都走不动了，i&lt;=j， 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11，现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fad6f3b0106ac67536584aac7d5e9014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/635d6f5da38f5b6fccfdd4f8e844ee7c/" rel="bookmark">
			Maven项目中如何引用另一个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目A的pom文件：
&lt;project xmlns="&lt;http://maven.apache.org/POM/4.0.0&gt;" xmlns:xsi="&lt;http://www.w3.org/2001/XMLSchema-instance&gt;" xsi:schemaLocation="&lt;http://maven.apache.org/POM/4.0.0&gt; &lt;http://maven.apache.org/xsd/maven-4.0.0.xsd&gt;"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;myCompanyName&lt;/groupId&gt; &lt;artifactId&gt;mavenA&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; ... &lt;/project&gt; 项目B要想引用项目A，则在B的pom文件中添加A的 groupId,artifactId,version 即可：
&lt;project xmlns="&lt;http://maven.apache.org/POM/4.0.0&gt;" xmlns:xsi="&lt;http://www.w3.org/2001/XMLSchema-instance&gt;" xsi:schemaLocation="&lt;http://maven.apache.org/POM/4.0.0&gt; &lt;http://maven.apache.org/xsd/maven-4.0.0.xsd&gt;"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;myCompanyName&lt;/groupId&gt; &lt;artifactId&gt;mavenB&lt;/artifactId&gt; &lt;dependices&gt; &lt;dependicy&gt; &lt;groupId&gt;myCompanyName&lt;/groupId&gt; &lt;artifactId&gt;mavenA&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependicy&gt; &lt;/dependices&gt; ... &lt;/project&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48da9f6d9c1881d15524f6420b5ea2c5/" rel="bookmark">
			五行名字的由来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五行来源 源于黄河流域人们对于四季五时气候特点的总结抽象：
木火土金水名字由来 春：草木之生长 用木表示，由曲到直，木曰曲直
夏：温热，向上向外的气势，用火来表示，火曰炎上
长夏：虽然还在向上向外，但以湿为主，雨量集中，土湿，且万物入土则化，生成果实，土爰稼穑（爰：说，稼穑：播种收割）
秋：由向上向外变向下向内的凉燥，金有凉燥特点，密度大，重，金曰从革（从：跟从，革：变革）
冬：气候寒冷，万物凋零，水性寒凉，且有渗入地下藏的特点，水曰润下（滋润到其它物体，渗下）
注：冬为何不用冰，因为冰没有渗入收藏的特点，而水可以渗入土
五行相生 四季五时的演化
木 -&gt; 火 -&gt; 土 -&gt; 金 -&gt; 水
五行相克 五时主特点风热湿燥寒之间相互制约承接的特点
自然界天气炎热到一定程度，会出现冷气团制约，然后出现下雨，雨后温差导致刮风，风带走湿气，天气干燥，干燥又产生气温升高至热
风 -&gt; 湿 -&gt; 寒 -&gt; 热 -&gt; 燥
木 -&gt; 土 -&gt; 水 -&gt; 火 -&gt; 金
五脏 肝 — 主气血运行，与春天生机勃勃相似 — 木
心 — 主神明，主血脉，与夏季阳气盛，万物生长的性质相似 — 火
脾 — 运化水谷，化生精微以营养脏腑，化生气血 — 土
肺 — 主气，气下降，与秋天肃降之性相似 — 金
肾 — 主封藏，与冬天万物闭藏相似 — 水
五大系统 肝胆相表里，肝主筯，肝开窍于目，其华在爪
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48da9f6d9c1881d15524f6420b5ea2c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd95ccbcb406a29108e006155cda5af/" rel="bookmark">
			个推实人认证SDK使用初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一位开发者在集成个推实人认证SDK时的亲身经历：
概述：
在某次产品迭代中，公司项目要用到对用户身份证信息的实人认证，我作为移动端的新晋萌新，Team Leader 把这个光荣的任务交给我来集成开发。小心翼翼地打开搜索引擎一看，我发现网上大部分公司所采取的方案是接入市面上形形色色的身份认证SDK，来进行实人信息的校验，但很多 SDK文档繁杂，接入工作量大，让人望而却步。平时喜欢拿来主义的我迫切想知道有没有什么已经封装好的实人认证SDK，可以简单集成，直接使用。于是，我在网上搜索了下，突然发现个推公司提供的实人认证SDK，说是对权威机构的身份认证API进行了封装，服务端也做了相应的部署，方便用户快捷接入、极易上手。这也太适合我这种日常瑟瑟发抖的研发萌新了吧。[bigbao1] 抱着试一试的态度，我集成了个推实人认证SDK。
个推实人认证系统的初体验：
个推的实人认证系统，又名CTID平台，为金融、文旅、广告等多个行业提供统一、权威、多级可信的网络身份服务。系统基于公安部法定证件制证数据，采用国密算法，对居民身份信息进行脱敏、去标识化处理，统一生成不可逆、不含明文信息、且与法定证件一一映射的数据文件，能够在不泄露身份信息的前提下实现在线身份认证。
实人认证的一般适用场景：实名认证、风险核验；
个人认为的个推实人认证产品优势：
1、安全性高，采用更符合终端的公钥体制，CTID不慎遗失后不会造成隐私泄露；
2、权威性高：统一使用公安系统法定证件制证数据作为对比源，其结果权威、可信；
3、法理性强：以《居民身份证法》和各行各业条例法规作为支撑，适用性广；
4、便捷性好：SDK结合证件信息、持证人照片等因子，可形成多层级认证。
个推实人认证的接入方法：
1、登录个推官网的开发者中心网址https://dev.getui.com ，联系个推的技术支持人员申请获取个推实人认证的SDK资料包。如果还没有个推开发者账号，则需要我们先行注册个推开发者账号，如下图所示：
2、获取并配置个推应用参数：
拥有了个推开发者账号后，我们就可以进入个推开发者中心了。在应用管理中，我们要先与个推商务进行联系与对接，确认无误后则会启用实人认证的管理控制平台，获取所对应的APPID。接着，我们就可以进行实人认证应用的创建与使用了：
1）创建实人认证APP并填写相关基础信息，进而获取应用对应的APPID：
2）实人认证APP创建完成后的效果图：
至此，实人认证APP就已经在个推开发者平台上注册好了！
个推实人认证的依赖配置：
个推实人认证SDK的接入方法非常简单，由于统一采用Maven的接入方式，仅仅需要几行代码就可以搞定。开发者在Android Studio开发工程的 app/build.gradle 文件中android.defaultConfig字段中添加如下代码：
manifestPlaceholders = [
GETUI_APPID : "请填写您所申请的GETUI_APPID",
]
同时，在当前文件的dependencies{}模块中添加如下依赖:
dependencies {
...
implementation 'com.getui:ctid:1.1.0.0'
...
}
最后，在开发工程的根目录build.gradle文件中选择allprojects{}下的repositories{}模块，添加如下Maven仓库的配置：
maven {
url "http://mvn.gt.igexin.com/nexus/content/repositories/releases/"
}
至此，只要短短几行配置，我们就完成了实人认证SDK的Maven接入！
个推实人认证的使用方法：
实人认证的核心类为 com.getui.ctid.CTIDManager，其核心接口方法共有三个：
1、实人认证的初始化接口：
实人认证的初始化方法很简单，只有一行代码：
CTIDManager.getInstance().init(Context context, CTIDCallBack callback);
其中Context即为上下文，callback为回调对象，⽤用于接受初始化结果回调。代码示例如下所示，是不是特别简单：
CTIDManager.getInstance().init(context, new CTIDCallBack() {
@Override
public void onSuccess(String gtcid) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdd95ccbcb406a29108e006155cda5af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa100536830172df2dd4671a8a08c277/" rel="bookmark">
			SpringCloud采用Jackson序列化统一响应不正当的消息转换器导致的异常问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud采用Jackson序列化统一响应不正当的消息转换器导致的异常问题 环境说明 org.springframework.cloud.spring-cloud-dependencies.2020.0.0
org.springframework.boot.spring-boot-dependencies.2.4.0
com.fasterxml.jackson.core.jackson-core.2.12.0
问题说明 我们在使用@RestControllerAdvice注解与ResponseBodyAdvice制定微服务统一返回值的时候,Spring根据消息转换器的是否支持进行选择，而我们在此时更改了返回值类型，导致的返回值类型转换出现异常 出现异常:org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.ClassCastException: class com.pkk.spring.cloud.core.common.rpc.response.ResponseBody cannot be cast to class java.lang.String (com.pkk.spring.cloud.core.common.rpc.response.ResponseBody is in unnamed module of loader ‘app’; java.lang.String is in module java.base of loader ‘bootstrap’)
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) ~[spring-webmvc-5.3.1.jar:5.3.1]
at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.1.jar:5.3.1]
问题分析解决思路 消息处理器在处理的时候被StringHttpMessageConverter消息处理器给捕获了,并做了处理,这时我把方法返回的值给变为ResponseBody对象,再去转String出现了异常 解决思路一:优先使用自定义的MappingJackson2HttpMessageConverter消息处理返回的数据 方式一:通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法改变排序 解决思路二:把匹配到的StringHttpMessageConverter消息处理器给删除掉,让给我们自定义的消息处理器 方式一:通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法删除此消息处理器 解决思路三:我们直接不转换返回值类型,在beforeBodyWrite方法中判断返回值如果是String类型,我们处理完之后在转为JSON字符串 通过下面的源码分析思路,发现我们配置的MappingJackson2HttpMessageConverter消息转换器在处理一个请求的时候,没有被匹配到,直接跳过？ 解决思路一:分析发现【converter.canWrite】不符合,不符合的原因就是MediaType的原因,增加支持相应的MediaType(原因分析见org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#canWrite) 解决代码示例 通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法改变排序 /** * Mvc的配置 * * @author peikunkun * @version V1.0 * @date 2021-01-07 17:46 **/ @Configuration public class MessageConverterOrderWebMvcConfigurer implements WebMvcConfigurer { @Autowired private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter; @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa100536830172df2dd4671a8a08c277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1029d68e33fdd8bb6fd98dc65863ea18/" rel="bookmark">
			新一代轻量级应用服务器 — WebSphere Liberty Profile Server 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2012 年 6 月 15 日，IBM 正式发布了 WebSphere Application Server V8.5 版本（简称 WAS V8.5）。WebSphere Liberty Profile Server（简称 Liberty）是 WAS V8.5 中最主要的新特性，它是一个基于 OSGi 内核，高模块化，高动态性的轻量级 WebSphere 应用服务器，其安装极为简单（解压即可）、启动非常快、占用很少的磁盘和内存空间，支持 Web、mobile 和 OSGi 应用的开发，旨在提高开发人员的生产效率。
在本文中，我们将详细介绍什么是 Liberty 以及如何使用 Liberty 快速的开发和部署应用，使读者迅速的掌握这一全新的轻量级应用服务器。
2012 年 7 月 19 日
内容 什么是 WebSphere Liberty Profile Server ？ Liberty 是一款全新的轻量级应用服务器，它将用户的良好开发体验作为最主要的出发点。其主要特点和内容包括：
高 模块化——该功能允许用户根据自己应用程序的需求启用或者禁用相关的 feature（所谓 feature，在这里指的是运行应用程序所需要的各种资源的支持。比如，应用程序用到了 JSP，我们就需要启动 JSP 这个 feature，如果不在需要此 feature，就可以将其禁用。通过这种模块化的控制，我们可以按需启动不同的 feature，包括 JSP, Servlet, JPA 等等，这种控制是实现轻量级应用服务器的基础）。轻量级—— Liberty 采用了多种技术进行瘦身和优化（主要是 OSGi 的应用），与传统的 WAS 相比，极大的减少了运行时的内存消耗。高动态性——由于采用了 OSGi 的架构，程序员在开发的时候，可以动态修改配置文件，应用程序以及服务器的运行时信息，这些修改都是实时生效的，不需要重启服务器。快速——由于采用了高模块化的设计，Liberty 应用服务器会“按需启动”，自身消耗的系统资源很少，对执行任务的反应时间也非常短，例如，一般来说 Liberty 的启动时间小于 5 秒。配置简单——在整个开发过程中，用户只需要和一个配置文件（server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1029d68e33fdd8bb6fd98dc65863ea18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e2a2b13356332149c24baa4ff4be30/" rel="bookmark">
			fillstyle属性_从零打造Echarts —— V2 属性更新和样式解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从零打造Echarts —— V2 属性更新和样式解析 本文开始v2版本（直到xrender初步完成为止，标题均指xrender的版本和特性）。
回顾V1 在上个版本中，我们实现了zrender官方文档首页的代码示例。不过还有一些问题等待我们解决。
样式规则 运行之前的代码可以看到其结果如下。
没有指定填充颜色的图形会被填充为黑色，描边同理。就我个人理解而言，对于一个图形，通常需要默认描边，而填充则不需要。需要更多的样式规则应用，如透明度，线宽。 回到XElement.ts中，显然随着样式越来越复杂，需要将样式处理抽离为一个函数。
/** * 将指定样式绑定到上下文中 */ function bindStyle (ctx: CanvasRenderingContext2D, style: XElementStyle) { let fill = style.fill || 'transparent' ctx.fillStyle = fill ctx.strokeStyle = style.stroke ctx.globalAlpha = style.opacity ctx.lineWidth = style.lineWidth } 然后在之前的beforeRender中应用即可。之后可以看到没有指定填充的图形不再有填充（更多的样式则需要依次处理，后面用到了再添加）。
~~高倍屏~~ ~~但是看着看着就觉得有什么不对，怎么这么模糊呢？这牵扯到设备独立像素和绘制像素等东西，和图片在高倍屏下的问题是一样的，不明白的可以自行搜索。解决方式和1px边框类似，找到渲染倍率，绘制的时候数据乘以这个倍率，然后将画布缩放为一倍大小即可。~~
添加元素后重绘频率 在之前的代码中，如果连续调用add，会连续触发render，这种情况下应该将其合并为一次。使用防抖函数，很容易做到这一点。
在util.ts中添加防抖函数。
export function debounce (fn: Function, delay = 300) { let timer = null return function (...args) { clearTimeout(timer) timer = setTimeout(() =&gt; { fn(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55e2a2b13356332149c24baa4ff4be30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab0d59050a112a3289c7f0943a52b74/" rel="bookmark">
			点击出现蓝色边框或者出现半透明蓝色背景解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*{
outline: none !important;
-webkit-tap-highlight-color: transparent;
-webkit-appearance: none;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38df3a605a94d190da9f1812416b8ca4/" rel="bookmark">
			slf4j&amp;log4j2&#43;lombok
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用lombok的@Slf4j注解，需要的依赖包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 同时在/main/resources/下新增log4j.properties文件
参考地址：https://www.cnblogs.com/mengxinrenyu/p/7636400.html
___________________
log4j.rootLogger=INFO, Console ,File #Console log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n #File log4j.appender.File = org.apache.log4j.FileAppender log4j.appender.File.File =log/log4j2.log log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n ________
思考：slf4j、log4j,log4j2,logback
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; resources下：log4j2.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configuration status="WARN"&gt; &lt;Appenders&gt; &lt;Console name="Console" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38df3a605a94d190da9f1812416b8ca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3173f56d43ce23039470b2a2a2eeb37c/" rel="bookmark">
			MediaPipe plugin for Unity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		google/mediapipe https://github.com/google/mediapipe
This is a Unity (2019.4.10f1) Plugin to use MediaPipe.
Example Graphs Hello World!Face Detection (on CPU/GPU)Face Mesh (on CPU/GPU)Iris Tracking (on CPU/GPU)Hand Tracking (on CPU/GPU)Pose Tracking (on CPU/GPU)Hair Segmentation (on GPU)Object Detection (on CPU/GPU)Official Demo (on CPU/GPU) Edit official_demo_cpu.txt (or official_demo.gpu.txt) and you can test your favorite official graph (if only it can be run on your platform) https://github.com/homuler/MediaPipeUnityPlugin
Unity Hand Tracking with Mediapipe https://github.com/TesseraktZero/UnityHandTrackingWithMediapipe
https://github.com/TesseraktZero/mediapipe_multi_hands_tracking_aar_unity
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79de870e24b324f98dc888c1c6050c32/" rel="bookmark">
			减少网络卡顿，华为HMS Core无线传输服务赋能连接与通信领域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网络技术的发展，大众对于网络的顺畅体验要求持续升高，连接与数据通信成为移动应用开发者的核心需求。华为HMS Core无线传输服务(Wireless Kit)为开发者提供了完善的无线通信传输能力，打造了定制化的5G+WiFi通信解决方案，帮助开发者解决一系列低速率、高时延、连接不稳定等网络问题，给用户带来更丰富的无线传输功能和更流畅的网络体验。
多环节提升开发体验 华为无线传输服务提供的无线通信感知能力，不仅可以感知和反馈当前的网络质量、应用运行情况，还可以对网络通信质量进行预测。
华为无线传输服务带来更可靠的Wi-Fi传输能力，集成Wireless SDK后，开发者应用能够获取Wi-Fi增强服务，降低传输时延与丢包率。如果关连的是华为路由器，终端和通信网络协同效果更加明显，在Wi-Fi网络不稳定时，可大大提升抗干扰能力。
开发者还可获得应用传输质量反馈，根据反馈进行精细化调度，让用户在弱网环境下也能流畅地观看视频或直播、打游戏，减少卡顿。
携手开发者带来低时延、高可靠的网络体验 基于华为的5G技术沉淀和高质量通信解决方案，华为无线传输服务能够帮助游戏、娱乐、教育、办公、数据传输等多个行业的应用降低时延率，增强无线网络通信的能力，为开发者提供畅快的无线传输业务体验。
例如：如果视频类App在播放过程中卡顿，将卡顿信息报给无线传输服务后，无线传输服务会将信息反馈给无线通信业务模块。模块会根据当前网络情况自动的优化底层链路，例如：选择更优的通信制式，更优的业务通道等，提高业务传输能力。目前，爱奇艺集成华为无线传输服务开放的底层通信质量精准实时的反馈能力，使视频卡顿减少15%以上；在火爆的直播行业也有华为无线传输能力的加持，保障了用户在直播过程中的流畅性。（以上数据来源于开发者反馈）
拓展更多应用场景和能力 随着智能生活场景的增加，华为无线传输服务还将开放多网能力，让开发者可以简易且灵活的使用华为终端设备，利用双卡与双Wi-Fi的多通道并发能力可以更快下载，或是在网络不佳的情况下，快速智能切换网络，保证上网低时延流畅体验。
华为无线传输服务也正在与手游加速器厂商加强合作。其中，迅游手游加速器集成了双WiFi并发能力，腾讯手游加速器除了集成双WiFi，更进一步使用主卡副卡双卡并发加速，在移动场景与网络拥塞的场景，打造稳定低卡顿的游戏体验。
华为会继续致力于通信技术创新，让开发者获得高吞吐、低时延、高可靠的网络服务的同时，为用户提供高质量通信保障，享受新技术发展带来的高效便捷。
更多华为无线传输服务信息 ，详见华为开发者联盟官网。您也可以通过发送邮件至devConnect@huawei.com，快速找到我们的专业技术人员进行开发咨询。我们期待您的加入！
原文链接：https://developer.huawei.com/consumer/cn/forum/topic/0201443607078290505?fid=18
原作者：本无所为之
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58150bccdfe68dcd22305f33fa9d59db/" rel="bookmark">
			有向图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有向图 术语有向图的可达性单点最短有向路径环和有向无环图有向图中的强连通性 在有向图中，边是单向的：每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的。
术语 一幅有方向的图（或有向图）是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点
处理有向图就如同在一座只有单行道的城市中穿梭，而且这些单行道的方向是杂乱无章的。
我们使用邻接表来表示有向图。
有向图取反的操作很有用，它返回该有向图的一个副本，但将其中所有的边反转。这样用例就可以找出“指向”每个顶点的所有边。
class Digraph { private: int V; int E = 0; std::vector&lt;std::vector&lt;int&gt;&gt; adj; public: Digraph(int V) : V(V) { adj.resize(V); } int getV() { return V; } int getE() { return E; } void addEdge(int v, int w) { adj[v].push_back(w); E++; } auto getAdj(int v) { return adj[v]; } auto getAdjs() { return adj; } Digraph reverse() { Digraph R(V); for (int v = 0; v &lt; V; v++) for (int w : getAdj(v)) R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58150bccdfe68dcd22305f33fa9d59db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6b0673d45ec7534358f58674668634/" rel="bookmark">
			vue实战性能优化-节流防抖路由懒加载gzip减少接口请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**前言：**这是自己在做vue移动端项目中总结的几点关于性能优化的知识点，分享记录一下。
文章有以下几个优化部分
gzip图片压缩路由懒加载减少接口请求keep-alive页面缓存防抖节流工具型方法封装​ 一、gzip图片压缩
** **gizp压缩是一种http请求优化方式，通过减少文件体积来提高加载速度。html、js、css文件甚至json数据都可以用它压缩，可以减小60%以上的体积。(需要后端的支持)
步骤：（按步骤来）
1、安装 npm i compression-webpack-plugin@1.1.11 -D 2、在vue.config.js 配置里面 进行导包 // 导包 const CompressionWebpackPlugin = require('compression-webpack-plugin') // 匹配文件名const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i// 配置module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { return { plugins: [ new CompressionWebpackPlugin({ filename: '[path].gz[query]', algorithm: 'gzip', // 默认为gzip test: productionGzipExtensions, threshold: 2048, // 对超过2k的数据进行压缩 minRatio: 0.8, // 仅压缩比该比率更好的（minRatio = Compressed Size / Original Size） deleteOriginalAssets: false // 是否删除原文件 }) ] } } }} 3、运行 npm run build 进行打包 gzip压缩后,通过gzip压缩可以使Vue首页加载速度大大提升,以下是压缩前与压缩后，差距还是非常大的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea6b0673d45ec7534358f58674668634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce64162116078a3017feaa6ceeae629d/" rel="bookmark">
			PIM DM技术原理与实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： PIM-DM使用“推（Push）模式”转发组播报文，一般应用于组播组成员规模相对较小、相对密集的网络。在实现过程中，它会假设网络中的组成员分布非常稠密，每个网段都可能存在组成员。当有活跃的组播源出现时，PIM-DM会将组播源发来的组播报文扩散到整个网络的PIM路由器上，再裁剪掉不存在组成员的分支。PIM-DM通过周期性的进行“扩散（Flooding）—剪枝（Prune）”，来构建并维护一棵连接组播源和组成员的单向无环SPT（Source Specific Shortest Path Tree）。如果在下一次“扩散-剪枝”进行前，被裁剪掉的分支由于其叶子路由器上有新的组成员加入而希望提前恢复转发状态，也可通过嫁接（Graft）机制主动恢复其对组播报文的转发。
PIM-DM的关键工作机制包括邻居发现、扩散、剪枝、嫁接、断言和状态刷新。其中，扩散、剪枝、嫁接是构建SPT的主要方法。上游接口和下游接口对于每个组播是相对的。也就是同一个路由器在不同的组播组中接口角色不同，完全是按照组播组划分。对于DM来说，接收组播的接口为上游接口，其他开启了PIM的接口都被称为下游接口。下游接口有两种状态（正常活动-&gt;转发组播流量，抑制-&gt;不转发组播流量）。
PIM DM组播路由表： [R1] display pim routing-table fsm VPN-Instance: public net Total 0(*, G) entry, 1 (S, G) entry Abreviations for FSM states and Timers: N-no info, Jjoined NJ-not joined, P-pruned, NP-not pruned, PP pune pending, w. winner, L-loser, F-forwarding. AP ack pending, DR-designated router, NDR-non-designate router, RCVR-downstram reivers, PPT-prmcpeneing timer, GRT. graft rety timer, OT-override timer, PLT-prune limit timer, ET-join expiry tmer,JT-oin timer, AT-assrt timer, PT-prune timer (10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce64162116078a3017feaa6ceeae629d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/139ab6ba1c463e69b8eb37fef0a3b26d/" rel="bookmark">
			华为认证hcia含金量_华为认证是什么？华为认证的含金量高吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为认证是什么？ 华为认证是华为技术有限公司凭借多年通讯信息通信技术人才培养经验，以及对行业发展的理解，以层次化的职业技术认证为指引，推出的覆盖IP、IT、CT以及ICT融合技术领域的认证体系，是唯一的ICT全技术领域认证体系。
华为认证的含金量高吗？ 众所周知，华为是国内最大的厂商，国内大部分的网络设备都是国产的华为设备，华为公司自己推出的认证，首先可以肯定的就是其权威性，是大部分公司都认可的，并且在维护使用华为设备过程中所应用到的技术需求也是相当大的。那么具有华为认证的网络工程师也是华为公司及其他公司优先考虑的人才。所以华为认证成为许多网络工程师心中的不二认证，自然华为认证网络工程师也成为业界的抢手人才，随着云计算、大数据、人工智能等新技术的兴起，相关人才的需求变得越来越急迫。
华为认证分几个等级？ 华为认证共分为3个等级。分别是HCIA、HCIP、HCIE。考试难度依次递增，含金量也是越来越高。
华为HCIE在2020年到多少号了？ 华为HCIE号在2020年达到1.5W左右了。因为疫情原因，目前也没有再增加，那么关于HCIE号码，我就略微花些篇幅解释下。当通过HCIE考试后，华为会颁发证书以及获取全球唯一性的HCIE号码，但是一个人考了多个方向的HCIE考试，也只会有一个HCIE号。
华为认证哪个方向比较好？ 一般从初学者的角度来说，59學習網肯定会推荐考HCIE R&amp;S(数通)方向，也就是明年的datacom方向。无论是云计算，安全还是大数据，都是基于路由交换的基础往上延伸。如果是从业多年的high level同学，建议选安全、云等当前热门方向。
华为认证 | HUAWEI CERTFICATION
本文系59學習網原创，未经允许不可转载。
本次分享就到这里！各位同学可以关注我，持续分享华为认证所需干货资料。有什么问题，直接文末留言，看到都会回复哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf2aca0461f191de20e4a3024ff989b/" rel="bookmark">
			超详细的卷积后大小的计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算公式定义 定义几个参数
输入图片大小 W×W
卷积核大小 F×F
步长 S
padding的像素数 P
于是我们可以得出计算公式为：
N = (W − F + 2P )/S+1
输出图片大小为 N×N
以resnet50为例，输入为[1,3,224,224]，其中1为batchsize，3为通道数，224为height和width。
经过第一层卷积后，其大小为[1,64,112,112]
in_channels= 3//输入通道 out_channels= 64 //输出通道 nn.Conv2d(in_channels, out_channels, kernel_size=7, stride=2, padding=3, bias=False) N = (W − F + 2P )/S+1 = （224-7+2x3）/2 + 1 = 112
解释 1为batchsize，不改变。
对于通道数，会生成与设定的输出通道个数相同个数的卷积核，对图片进行卷积，即卷积核的个数等于输出特征图的通道数。
得到最终输出大小为[1,64,112,112]
(W − F + 2P )相当于计算除了第一次卷积后剩下的可用来卷积的大小
(W − F + 2P )/S为按照S大小的步长在刚刚得到的大小上可以向后移动多少次，即还可以做几次卷积
因为不包括第一次卷积，所以再加上一个1，
即N = (W − F + 2P )/S+1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf2aca0461f191de20e4a3024ff989b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e72d08c49f8b4a93fdfb8f84f8378376/" rel="bookmark">
			卷积尺寸计算公式（含膨胀卷积和反卷积情况）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在搭配深度学习多个卷积层时我们经常要计算卷积层的输出张量的尺寸大小，可以用如下公式计算：
1, 公式 卷积层输出尺寸： o = ⌊(i + 2p - k) / s⌋ + 1
式中，i:输入尺寸；o:输出尺寸；p:padding；k: kernel_size；s: stride。⌊…⌋表示向下取整。
2, 推导过程 这个公式不用死记，下面我用非常便于理解的方法描述这个推导。卷积就是对相邻的一片数据进行加权求和得到一个数的一种“合并”操作，将此操作对输入张量进行滑动扫描以得到输出张量。循着这个过程，我们很容易推导出卷积输出尺寸的计算公式。
（1）注意padding指的是两边同时补零，所以补零后输入尺寸相当于变成了i+2p；
（2）用卷积核扫描的时候，想象一把尺子在桌子上从左移动到右，受到左右边框的界限，它的移动范围只有i+2p-k大小。
（3）如果每次移动的步长是s，实际上移动的步数就是 (i+2p-k)/s，但移动的步数必须是整数，因为不能出界，如果最后一步哪怕还差一点也不能算，所以必须要向下取整。
（4）即使一步不移动，也会在原位得到一个输出点，所以最后得到的输出尺寸是移动的总步数再加上1。
3, 膨胀卷积 对于膨胀卷积，上公式不变，只需要把卷积核k改为膨胀后的卷积核k’，
膨胀后卷积核： k’ = d × (k-1) + 1
式中，k: 输入的卷积核尺寸; d: 膨胀系数; k’: 膨胀后等效的卷积核尺寸。用k’代入上公式的k，就可以计算出输出尺寸。
4, 反卷积 反卷积就是把卷积的i, o调换就可以了，推导后得到
反卷积输出尺寸： o = (i-1)×s + k - 2p
5, 常用等尺寸变换配置 经常希望经过卷积后张量尺寸不变，常用以下（k, s, p)组合：
（k, s, p) = (1, 1, 0) or (3, 1, 1) or (5, 1, 2) or (7, 1, 3)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e72d08c49f8b4a93fdfb8f84f8378376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0f60fb7e40de08aaac7e5d7daed682/" rel="bookmark">
			更改Ubuntu终端复制和粘贴的快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu终端复制和粘贴的快捷键不是ctrl+C和ctrl+V，用起来很不适应
但我们可以把它们自定义为ctrl+C和ctrl+V
首先ctrl+alt+t打开终端，点击终端的菜单栏的"编辑"，"首选项"
在弹出的窗口中进行设置:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dfedaf1ba4433adefdc7ddb111610a6/" rel="bookmark">
			com.aspose.cells使用ICustomFunction自定义函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		com.aspose.cells当前版本20.5中days函数有问题。自定义一个days2函数。
package test; import java.text.SimpleDateFormat; import java.util.ArrayList; import com.aspose.cells.ICustomFunction; import com.aspose.cells.ReferredArea; /** * 自定义函数 * 使用方法：wb.calculateFormula(true, new CustomFunction()); * @author * @date 2021年1月7日 下午12:00:26 */ public class CustomFunction implements ICustomFunction { @Override public Object calculateCustomFunction(String functionName, ArrayList paramsList, ArrayList contextObjects) { /*for (Object o : paramsList) { ReferredArea ra = (ReferredArea) o; if (ra.isArea()) { o = ra.getValues(); } else { o = ra.getValue(0, 0); } }*/ try { if ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dfedaf1ba4433adefdc7ddb111610a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5109cfb43a68cb887813223c9ef62894/" rel="bookmark">
			RecyclerView内嵌套RecyclerView导致外层item点击不响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用RecyclerViewCommonAdapter时，recyclerView嵌套一个显示图片的recyclerView，外层recyclerView需要响应item的点击进行跳转，在嵌套的RecyclerView中点击无效。没用原生的Adapter写过，不知道会不会响应。
首先，需要知道触摸事件的响应机制是怎么样的：由上至下，最下层不消费后，则由下至上；然后需要了解一下这三个方法：dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent。
dispatchTouchEvent：事件分发，一般不处理，返回false，事件到onInterceptTouchEvent中处理。
onInterceptTouchEvent：事件拦截，返回true的话，则不向下传递，事件到onTouchEvent，返回false事件往下传递
onTouchEvent：返回true代表事件消费，返回false不消费，事件往上传递。
只需要内部RecyclerView用于显示，不需要任何操作的情况下，为了使外层RecyclerView的item响应，把嵌入的RecyclerView触摸事件拦截，并且不消费就行了，事件就会传递到上一层，重写嵌套的RecyclerView
import android.content.Context; import android.util.AttributeSet; import android.view.MotionEvent; import androidx.annotation.Nullable; import androidx.recyclerview.widget.RecyclerView; /** * @Author: * @CreateDate: 2021/1/7 10:54 * @Version: 1.0.0 * @Description: RecyclerView内嵌套RecyclerView导致外层item点击不响应, 去除子recycleView的touch监听 */ public class NoTouchRecyclerView extends RecyclerView { public NoTouchRecyclerView(Context context) { super(context); } public NoTouchRecyclerView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public NoTouchRecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } @Override public boolean onTouchEvent(MotionEvent e) { return false; } @Override public boolean onInterceptTouchEvent(MotionEvent e) { return true; } @Override public boolean dispatchTouchEvent(MotionEvent ev) { return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5109cfb43a68cb887813223c9ef62894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0053cfdff5362fd3ad3755aac8c10c70/" rel="bookmark">
			【填坑】ESP-IDF 环境安装常见报错信息和解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Windows 平台 ESP-IDF 环境安装常见报错信息和解决方案一、install 时报错**Q1 ： 错误信息：Download failed 操作超时 或者 installation has failed with exit code -2****Q2 ： 错误信息：Download failed: an error occurred in the secure channel support****Q3 ： 错误信息：'python'：permission denied** 二、export.bat 时报错**Q1. 错误信息：'.' 不是内部或外部命令，也不是可运行的程序****Q2. 错误信息：File "...\lib\subprocess.py", line 1207, in _execute_child startupinfo) FileNotFoundError: [WinError 2] The system cannot find the file specified** 三、idf.py build 时报错**Q1. 错误信息： idf.py 不是内部或外部命令，也不是可运行的程序****Q2. 错误信息： Windows requires an MSYS2 version of gcc on the PATH to build mconf-idf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0053cfdff5362fd3ad3755aac8c10c70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df592ebe9fd6d0b01cebb684e5c9f805/" rel="bookmark">
			图片标注工具Labelme-简明使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 记录Labelme的使用方法，方便快速上手使用。
labelme简介 LabelMe 可用于实例分割，语义分割，目标检测，分类任务的数据集标注工作。
在线标注版本
python版本
labelme官方文档 分类标注：Classification
目标检测标注：Object Detection
语义分割标注：Semantic Segmentation
实例分割标注：Instance Segmentation
视频标注：Video Annotation
其他形式标注：LabelMe Primitives
安装 所有操作在已经安装Anaconda环境下运行
1.安装pyqt5
pip install pyqt5 -i https://pypi.tuna.tsinghua.edu.cn/simple 2.安装labelme
pip install labelme -i https://pypi.tuna.tsinghua.edu.cn/simple 3.安装完成后命令行启动labelme
labelme 使用 此处打开一个图片文件夹做示范：
1.点击左侧Open Dir选择需要标注的数据文件夹。
2.在顶部 edit 菜单栏中可选不同的标记方案，依次为：多边形（默认），矩形，圆、直线，点。
3.制作图像分割的数据，选择多边形，点击左侧的 create polygons ，回到图片，按下鼠标左键会生成一个点，完成标注后会形成一个标注区域，同时弹出labelme的框，键入标签名字，点击 OK或者回车完成标注。
1.如果需要更改标注的数据，可以选择左侧的编辑框，或者把鼠标移动到标签上，点击鼠标右键，可以选择编辑标签或者标注的名字。在编辑模式下，把鼠标移动到边界上，右键，可以增加点。
2.标注完成后点击Save保存。会在图片路径下生成同名的json文件。在目录下打开终端键入：
labelme_json_to_dataset &lt;文件名&gt;.json 会把生成的json转化成对应的数据文件：
*.png info.yaml label.png label_names.txt label_viz.png 常用命令 1.启动labelme的方式
# 直接打开labelme labelme # 打开某个文件夹，加载该文件夹下及其子文件夹下的所有图片 labelme path/to/imgfile/ # 直接打开指定的图片 labelme cat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df592ebe9fd6d0b01cebb684e5c9f805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ae66fa8fa8b85bdc49411ca4d0ffff/" rel="bookmark">
			Node.js之 EventEmitter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。 例如，net.Server 会在每次有新连接时触发事件，fs.ReadStream 会在打开文件时触发事件，stream会在数据可读时触发事件。
从官网上的这段话，我们能获取到的信息就是，Node.js 的核心 API 是使用的一套共同的异步事件驱动，因此这个肯定会独立成一个专属的类。今天我们一起学习这个类 EventEmitter。
EventEmitter 所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上。 事件的命名通常是驼峰式的字符串，但也可以使用任何有效的 JavaScript 属性键。
先来一个简单的示例 const { EventEmitter } = require('events') const eventEmitter = new EventEmitter() // 添加事件回调 eventEmitter.on('say', () =&gt; { console.log('say hello'); }) setTimeout(() =&gt; { eventEmitter.emit('say') }, 1000) console.log('执行结束！'); // 执行结果 // 执行结束！ // say hello 通过观察上面的方法，可以得出的是： 通过 on 注册事件，等同 addListener(event, listener)；可以异步触发监听的事件。 再看 const { EventEmitter } = require('events') const eventEmitter = new EventEmitter() eventEmitter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ae66fa8fa8b85bdc49411ca4d0ffff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c899dd4da2eadfceaf9f379e1b692d02/" rel="bookmark">
			手把手教你vue3.0项目搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：最近公司想重构一个项目，CTO选择了vue3.0 + ant-design-vue技术栈，正好自己也想尝试一下，试着搭建一下，以后有更好的会及时补充修改
注：粗体是命令指令，推荐使用cnpm指令，没有安装淘宝镜像的使用npm（淘宝镜像安装指令：npm install -g cnpm --registry=https://registry.npm.taobao.org）
一、安装node.js，vue-cli升级到4.0版本（安装vue3.0版本之前需要先把vue-cli升级到4.0版本，如果之前安装过vue-cli需要卸载之后重新安装，如果没有安装过不需要卸载可以直接安装，具体指令看第2项）
1.先要安装node.js
运行：node -v
如果提示，说明已安装node，如果没有请参照
官网：https://nodejs.org/zh-cn/download/
2、nodejs安装后：
a.如果之前安装过vue-cli，你需要把2.0相关的删除
cnpm uni -g vue-cli
b.如果没有安装过vue-cli的话，直接在全局的命令窗口，输入
cnpm i -g @vue/cli
c.检查版本号
vue -V
执行上面的指令，那么vue-cli的4.0版本就安装好了。
二、vue的3.0版本的初始化
1、新建一个文件夹,然后右键选择打开命令行窗口
2、在命令窗口输入指令
vue create 项目名称
3、选择初始化项目的配置
第一步：Default是自动安装，在这里我选择最后一个手动安装，按下回车键进行选择
第二步：Vue-cli3.x 将提供以下特性供选择，可以根据项目需要进行选择添加的配置项，使用空格键来选中，熟练使用TS的可以选择TypeScript
*Babel：使用babel，便于将我们源代码进行转码（把es6=&gt;es5）
*TypeScript：使用TypeScript进行源码编写，使用ts可以编写强类型js，对我们的开发有很大的好处
*Progressive Web App(PWA)：使用渐进式网页应用（PWA）
*Router：使用vue-router
*Vuex：使用vuex状态管理器
*CSS Pre-processors：使用CSS预处理器，比如：less，sass等
*Linter/Formatter：使用代码风格检查和格式化
*Unit Testing：使用单元测试
*E2E Testing：使用E2E测试, end to end（端到端）是黑盒测试的一种
第三步：选择版本，我这里选择3.x
第四步：Use history mode for router?
路由模式, 是否选择history模式，启用history模式，项目build之后，可能会出现打开页面空白的情况哦。我这里选择n
第五步：Pick a CSS pre-processor?
选择一种css 预处理器，我这里选择第二个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c899dd4da2eadfceaf9f379e1b692d02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3f8980439cae263368617bdb9ec3b6/" rel="bookmark">
			数据脱敏？Hive一个函数搞定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据屏蔽函数（Data Masking Functions） Hive在2.1.0版本后，支持数据屏蔽函数（Data Masking Functions），可以用于数据的快速掩码处理（脱敏）。
比如mask函数，默认会将查询回的数据，大写字母转换为X，小写字母转换为x，数字转换为n。当然也可以添加参数自定义转换的字母mask(string str[, string upper[, string lower[, string number]]])，upper定义大写字母转换，lower定义小写字母转换，number定义数字转换。
--函数调用 mask("abcd-EFGH-8765-4321") --结果为： xxxx-XXXX-nnnn-nnnn 其余函数mask_first_n(string str[, int n])可对前n个字符进行掩码处理。
mask_first_n(string str[, int n]) mask_last_n(string str[, int n])可对后n个字符进行掩码处理。
mask_last_n(string str[, int n]) 而mask_show_first_n(string str[, int n])则是除了前n个字符，其余进行掩码处理，mask_show_last_n(string str[, int n])是除了后n个字符，其余进行掩码处理。
mask_show_first_n(string str[, int n]) mask_show_last_n(string str[, int n]) 当然，最后mask_hash(string|char|varchar str)会返回字符串的hash编码。
mask_hash(string|char|varchar str) 使用这些函数，可以方便的对一些数据进行脱敏，从而在保证数据安全的情况下，交由教学使用。
后话 如果有帮助的，记得点赞、关注。在公众号《数舟》中，可以免费获取专栏《数据仓库》配套的视频课程、大数据集群自动安装脚本，并获取进群交流的途径。
我所有的大数据技术内容也会优先发布到公众号中。如果对某些大数据技术有兴趣，但没有充足的时间，在群里提出，我为大家安排分享。
公众号自取：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9549574106579ff1befa64cacb1741c3/" rel="bookmark">
			java.lang.NoClassDefFoundError: org/springframework/context/ApplicationContext崩溃解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.NoClassDefFoundError: org/springframework/context/ApplicationContext
崩溃了，这到底咋整啊？我弄了快8个小时了，怎么都是错！博客都快让我泛滥了，跪求各位大神啊！
这是我前几天，发的一条blink，发出后，有很多大神伸出援手，向我提出了很多解决方案；在这里再次感谢那些大神们，真的不胜感激；
NoClassDefFoundError
发生在编译时对应的类可用，而运行时在Java的classpath路径中，对应的类不可用导致的错误。
在这里我总结了几种使用Spring框架可能导致这种异常的原因；
jar包没导全，或导入失败；SE项目中，Spring配置文件没有放在src目录下；Spring版本是否与jdk版本的兼容问题还有最后一种就是也是让我崩溃的一种，jar包路径含有中文； 三天，我找了好多关于这种异常的文章，以及解决办法，也问过了老师，将源码发过去，在老师那里就是没有问题，一到我这里就出错，真的让人无语；
但，还好；虽然花了好几天的时间，最后还是解决了；希望能帮到向我一样的同学；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdbfe77ee424223d2cf391fdcc9af5e/" rel="bookmark">
			单独安装ubuntu18_ubuntu18.04安装opencv&#43;opencv_contrib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来在win7+VS2017下配置好了opencv3.3.0，但在后来使用过程中才发现，当时安装的是一个基础版的，opencv的许多应用，比如sift检测等，需要单独安装opencv_contrib库才能使用。后来，在win7+VS2017一下折腾很久，最终由于很多辅助软件无法下载而放弃，转到ubuntu18.04系统下配置opencv，安装过程也是各种折腾，所以把配置中出现过的问题及解决办法记录一下。
需要特别说明的是，我的电脑是hp probook440 G2，主系统安装的是win7 SP1，ubuntu18.04作为第二系统，C++使用的IDE是kdevelop。把电脑系统情况说一下，是因为最近在安装ubuntu和配置opencv时，发现win7和win10有很大差异，出现的问题也是五花八门，特别是新的电脑采用UEFI启动模式，让安装双系统、设置系统启动更加麻烦，以后再针对win10安装双系统总结一下。
1、下载源文件 在下载源文件前需要安装好C++编译器，下载源文件时可以在终端利用git下载opencv及opencv_contrib源文件，我使用的下在链接为：
git clone https://github.com/opencv/opencv.git git clone https://github.com/opencv/opencv_contrib.git 编译源文件 遇到问题最多的，就是编译源文件。因此，在编译前建议先看完本小结涉及的内容再操作，避免出错。 首先在opencv文件夹里新建build目录，再进入build目录。
在build目录下输入以下命令，进行编译: cmake -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=/usr/local -DINSTALL_C_EXAMPLES=ON -DINSTALL_PYTHON_EXAMPLES=ON -DWITH_TBB=ON -DWITH_V4L=ON -DWITH_QT=ON -DWITH_OPENGEL=ON -DOPENCV_EXTRA_MODULES_PATH=~/opencv/opencv_contrib/modules -DOPENCV_ENABLE_NONFREE=ON -DPYTHON_EXECUTABLE=/usr/bin/python -DBUILD_EXAMPLES=ON .. 遇到的问题 （1）如果直接在opencv文件夹中用cmake命令编译，会报错，提示不允许在源文件中进行编译，同时会在源文件的一些配置文件中记录你在源文件夹下进行编译操作。这时候，需要删除这个记录信息，并新建build，并在该目录下编译。因为我不知道这个信息具体是记录在哪个文件中的，我就是直接删除所有源文件，重新下载一份。
（2）如果在cmake命令中输漏了最后的..标识符，就会提示当前目录下没有CMakeLists. txt文件，这是由于我们现在进入了build目录，所以最后一定加上..这个符号。
（3）在安装过程中，会下载一些第三方依赖，而这些依赖会出线下载超时的情况，因为它采用的是默认的下载地址。解决办法是在网上先下载好这些依赖，然后再到安装文件中去修改这些依赖的默认下载地址，然后再重新输入上述cmake命令。以下是我单独下载的依赖和修改默认安装源地址的方法:
cmake_files文件下载及安装：opencv3_cmake_files
这个依赖位于~/Downloads目录下，需要将他们拷贝到opencv默认安装目录才能生效。因此，将这部分文件拷贝到我下载的源文件的目录下：
~/opencv/opencv_contrib/modules/xfeatures2d/src/ ippicv下载及安装：ippicv
下载的文件存放在~/Downloads目录下，需要修改opencv默认安装源目录。
打开源文件：~/opencv/3rdparty/ippicv/ippicv.cmak，将其中
"https://raw.githubusercontent.com/opencv/opencv_3rdparty/${IPPICV_COMMIT}ippicv/" 替换为
"file:~/Downloads/" face_landmark_model.dat下载及安装：face_landmark_model
类似的，对opencv默认安装源进行修改。
在源文件中打开：~/opencv/opencv_contrib/modules/face/CMakeLinks.txt，将其中的
"https://raw.githubusercontent.com/opencv/opencv_3rdparty/${__commit_hash}/" 替换为
"file:~/Downloads/" 至此，我配置完了无法下载的第三方依赖项，然后在重新进入:~/opencv/build利用cmake进行编译，可以顺利通过。
特别说明 （1）DPYTHON_EXECUTABLE=/usr/bin/python这个是你python的安装目录，可以通过which python查询。
（2）DOPENCV_EXTRA_MODULES_PATH=~/opencv/opencv_contrib/modules这个是你下载的opencb_contrib中modules文件夹的地址。
（3）修改第三方依赖项的下载地址时，需要用你下载的第三方依赖存储地址去替换。
2、生成及安装库文件 用sudo make -j8生成库文件。
sudo make -j8 其中的数字8是可用的线程数，可以用npro查询得到。
用sudo make install完成库文件安装。
sudo make install 3、配置库文件 参考网上配置方法，在终端输入以下命令，配置库文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdbfe77ee424223d2cf391fdcc9af5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e81e601d8125c306b8f5e77806fc019/" rel="bookmark">
			torch.pairwise_distance(): 计算特征图之间的像素级欧氏距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 torch.pairwise_distance(x1, x2)使用示例1使用示例2正确性检查程序1程序2 torch.pairwise_distance(x1, x2) 这个API可用于计算特征图之间的像素级的距离，输入x1维度为[N,C,H,W]，输入x2的维度为[M,C,H,W]。可以通过torch.pairwise_distance(x1, x2)来计算得到像素级距离。
其中要求N==M or N==1 or M==1
这个API我在官方文档没有搜到，而是在通过一篇文章的github源码偶然得知，通过自己的尝试从而总结，如有不全面，还请见谅。
使用示例1 已有模板特征T，其维度为[1,C,H,W]，想要计算特征图F（维度为[1, C, H, W]）与模板特征之间每个像素点(共HxW个像素)的距离。代码示例如下：
t = torch.randn(1,3,3,3) f = torch.randn(4,3,3,3) dist_matrix = torch.pairwise_distance(t, f) print(dist_matrix.shape) # torch.Size([4, 3, 3]) 使用示例2 已有像素级模板特征T，其维度为[1,C,1,1]，想要计算特征图F（维度为[1, C, H, W]）中每个像素(共HxW个像素)与模板像素特征的距离。代码示例如下：
t = torch.randn(1,3,1,1) f = torch.randn(4,3,3,3) dist_matrix = torch.pairwise_distance(t, f) print(dist_matrix.shape) # torch.Size([4, 3, 3]) 还有许多不同的用法，这里不再叙述
正确性检查 因为没有找到对应的官方文档，因此自己写了一些检测程序。代码如下：
程序1 x = torch.from_numpy(np.array([1,1,1])).float().view(-1,3).unsqueeze(-1).unsqueeze(-1) y = torch.from_numpy(np.array([[[3,3,3],[1,1,1]], [[1,1,1],[1,1,1]]])).float().permute(2,0,1).unsqueeze(0) # print(x.shape,'\n',x) # print(y.shape,'\n',y) dist_matrix = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e81e601d8125c306b8f5e77806fc019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb5889f28efa3904b8bd6ceb799772d/" rel="bookmark">
			Mac 维修前的准备工作你都知道吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多伙伴在使用mac时难免会对电脑造成一些物理伤害，例如说键盘进水，摔在地上等等，如果打算将mac送修，为了保护您的信息并节省时间，请在为您的 Mac 获取服务之前先提前准备好这些工作！
1、进行备份
进行备份是 Mac 维修前准备工作中非常重要的一部分。使用“时间机器”可以轻松备份和恢复您的所有文件，您也可以使用其他备份方法。
了解如何备份您的 Mac。
2、安排服务
从您所在地区提供的服务选项中选取：预约 Apple Store 商店、查找 Apple 授权服务提供商或安排 Mail-In 维修。为您的 Mac 安排服务。
3、收集您的信息
如果您还保留有销售收据，请携带它前往服务地点。您可能还需要准备好 Apple ID 密码和个人身份证件，如驾照、护照或由政府签发的其他身份证件。
您应该知道您 macOS 用户帐户的名称和密码，以便需要时在服务地点登录您的 Mac。此外，如果您使用了开机密码，请在获取服务之前将它关闭。
4、收集您的产品
携带您的 Mac、电源线和您需要获取协助的所有配件。
如果您安排了 Mail-In 维修，只需按照您收到的包装说明和邮寄说明操作即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86079bd7c2c377b1a54d26cd157a0dbc/" rel="bookmark">
			为什么需要 WebSocket 协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在把 Facebook Message 接入客服系统，由于与 Facebook Message 对接的收发消息都是通过调用 http 接口来实现的，如果想实现即时通讯，还需要在中间加一个 WebSocket 来转发消息。如下图：
转存失败重新上传取消
其中用到了 WebSocket 协议和 IO多路复用相关的知识。在这里做一个学习记录。
为什么需要 WebSocket 协议
因为 HTTP 协议有一个缺陷：通信只能先由客户端发起，然后服务器再作出响应，并不能由服务器主动向客户端推送消息。
WebSocket 协议最大的特点是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息。
WebSocket 与 socket 的之间关系
WebSocket 是一个网络通信协议，是属于网络七层模型中的应用层的协议，同样属于应用层的协议还有 HTTP 协议、FTP协议、SMTP协议等等。
而 socket 是操作系统提供的一套接口，利用这一套接口就可以编写程序实现进程之间的通信、网络通信等功能。
一个 WebSocket 连接是如何建立起来的
WebSocket 连接的初期是基于 HTTP 协议的，假如 WebSocket 的地址是这个：wss://www.xxx.com/websocket ，在连接 WebSocket 的初期浏览器首先会向这个地址发出一个 HTTP GET 请求，请求头信息截图如下：
转存失败重新上传取消
红色框标出的是比较重要的请求头：
Connection: Upgrade 告诉服务端这个连接需要升级。
Upgrade: websocket 告诉服务端需要升级到 WebSocket 协议。
Sec-WebSocket-Key: d97OXZzuRlSJV/6SrX+uUA== 是浏览器随机生成的一个字符串。
服务端接收到这个 HTTP 请求，会作出响应，响应头的截图如下：
转存失败重新上传取消
红色框标出的是比较重要的响应头：
HTTP/1.1 101 Switching Protocols 告诉浏览器，服务端已经成功切换了协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86079bd7c2c377b1a54d26cd157a0dbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bddfac07673656247a2e38246bf534/" rel="bookmark">
			OpenGL入门（1）——建立一个OpenGL项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL入门（1）——建立一个OpenGL项目 前言一、OpenGL是什么？二、建立OpenGL项目1.准备工作2.建立项目2.1 建立项目文件2.2 链接OpenGL库2.3 测试 总结 前言 本系列为OpenGL入门系列，用于记录自己的学习过程并分享学习经验。本人是跟随视频博主The Cherno发布的视频教程进行学习，B站也有搬运过来的视频最好的OpenGL教程之一，有兴趣的朋友可以一同学习。
（注：文中关于OpenGL、GLFW、GLEW的理解还存在一些问题，有兴趣的朋友可以查看LearnOpenGL纠正理解。同样这个网站也极为推荐大家去看，里边有详细教程，内容非常丰富。本文中建立的工程文件已上传至LearnOpenGL—1）
一、OpenGL是什么？ OpenGL（英语：Open Graphics Library，译名：开放图形库或者“开放式图形库”）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。
根据视频里的内容了解到OpenGL实际上是一种用于控制GPU的规范，这一规范获得了各平台和软硬件厂商的认可，同样也被遵守。但这并不是说他们共用同一套OpenGL，实际上他们各自有自己的OpenGL，针对自身系统或软硬件有不同程度的优化，且大多为非开源，不过在我们这些调用者的眼中，他们表面上所用的调用语句基本一样，实现的效果基本一样，很容易就认为这是一样的东西。
二、建立OpenGL项目 1.准备工作 上文说大多数的OpenGL都不是开源的，那有没有开源的OpenGL呢？答案是肯定的！
这里我们使用GLFW开源的OpenGL库进行学习。
进入主页我们会看到这样的页面：
可以看到直接就有下载的提示，不过这个是大而全的，而我们想用的是小而美的，适合个人开发使用的。找到右上方“下载”按钮，点击进入如下页面：
这里就要根据自己的平台进行选择了，本人所用平台为Windows，可以选择32位的和64位的。有一点需要知道的是，这里32位的能在32位和64位的操作系统中运行，64位的只能在64位的操作系统中运行，而且运行的速度据说也差不多，所以为了能适用于更多的操作系统选择32位的进行下载。
下载并解压后得到
至此准备工作完成。
2.建立项目 2.1 建立项目文件 在项目下添加Dependencies文件夹，并在文件夹内添加GLFW文件夹，将之前下载的文件里的includ文件和lib-vc2019（本人用的VS为2019版本，这个别的应该也差不多都适用）复制到GLFW文件夹内。
得到如下的项目文件：
至此完成项目文件的建立。
2.2 链接OpenGL库 在VS中资源管理器下右键项目
点击最下方的“属性”，出现项目属性页
找到C/C++下的“常规”里的“附加包含目录”，写入$(SolutionDir)Dependencies\GLFW\include(此处用到了宏，编译器会自动对$SolutionDir进行解析得到对应的路径)
找到“链接器”下的“常规”里的“附加库目录”，写入$(SolutionDir)Dependencies\GLFW\lib-vc2019
至此完成OpenGL库的链接。
2.3 测试 在VS中建立好的OpenGL项目下新建筛选器“src”，用于存放源代码，在其下添加Applications.cpp
将如下代码复制到Applications.cpp中
#include &lt;GLFW/glfw3.h&gt; int main(void) { GLFWwindow* window; /* Initialize the library */ if (!glfwInit()) return -1; /* Create a windowed mode window and its OpenGL context */ window = glfwCreateWindow(640, 480, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44bddfac07673656247a2e38246bf534/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2da01459379f440da5711846a4d942/" rel="bookmark">
			Halcon算子threshold、dyn_threshold、binary_threshold、auto_threshold、fast_threshold、var_threshold
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、threshold 全局阈值 threshold(Image : Region : MinGray, MaxGray : ) 对应参数分别为输入图像、输出区域、阈值下限、阈值上限 使用全局阈值分割图像，阈值选择输入图像中灰度值g满足以下条件的像素： 图像中所有满足条件的点会被作为一个整体区域被返回，对于矢量图像，阈值不是对应于灰度值，而是对应于矢量的长度。 注意点：MaxGray &gt;= MinGray，MaxGray和MinGray的值可以是浮点类型也可以是整数类型，如果图像是整数类型的，MaxGray和MinGray的值类型应当为整数类型，如果是浮点类型，小数部分会被舍弃； 二、dyn_threshold 局部阈值 dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark : ) 对应参数分别为原始图像、阈值图像、输出区域、偏移量、输出类型 使用局部阈值分割图像,dyn_threshold从输入图像中选择满足条件的区域方法如下： 注意：g0是原始图片，gt是阈值图片，通常，阈值图像是原始图像的平滑版本，可以利用 mean_image, binomial_filter, gauss_filter等来创建阈值图片； 当LightDark = 'light' 时 g0 &gt;= gt+Offset; 当LightDark = 'dark' 时 g0 &lt;= gt-Offset; 当LightDark = 'equal' 时 gt-Offset &lt;= g0 &lt;= gt+Offset; 当LightDark = 'not_equal' 时 gt+Offset &lt; g0 或者 g0 &lt; gt-Offset; 利用dyn_threshold可以提取目标图片的轮廓，如下图 代码如下： read_image (Image2, 'C:/Users/Administrator/Desktop/2注册图片.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa2da01459379f440da5711846a4d942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2286d4cda51329dd370cf1c616e69c00/" rel="bookmark">
			MySql单独安装 8.0版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
网址
哔哩
网址
Windows 上安装 MySQL 下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在 D:\ck-files 下。
接下来我们需要配置下 MySQL 的配置文件
打开刚刚解压的文件夹D:\ck-files\mysql-8.0.21-winx64\mysql-8.0.21-winx64 ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：
[client] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\ck-files\mysql-8.0.21-winx64\mysql-8.0.21-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 # datadir=C:\\web\\sqldata # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 接下来我们来启动下 MySQL 数据库：
以管理员身份打开 cmd 命令行工具，切换目录：
cd C:\web\mysql-8.0.11\bin 环境变量配置
报错处理
初始化数据库： 可以显示密码 上面可见
mysqld --initialize --console 启动输入以下命令即可：
注意需要最高权限
网址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18b28646650fc01046c6b7ed4c7799e/" rel="bookmark">
			HTML复习和查阅文档——小白篇(10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML复习和查阅文档 返回目录 遗忘的知识记起来，重复学习学过的东西，使对其印象更加深刻，在脑海中存留的时间更长一些。查阅文档是个非常好的学习习惯。
百度：http://www.baidu.com（通常都说不懂就问百度）MDN Web文档：https://developer.mozilla.org/zh-CN/
求一键三连——余神永远的神
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d88d21be18efe29d901354f9e98b5a/" rel="bookmark">
			手写BundleAdjustment（尽量仅使用eigen库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手写BundleAdjustment 使用手写BA解决了PnP问题，除了读取图片、显示图片用的opencv，其他基本上只使用了eigen、sophus。
代码放在了百度云上（github还在研究怎么用，以后可能会上）
链接：https://pan.baidu.com/s/1CBJMKXGeelBSuJUuk7E1mw
提取码：br5o
文章目录 手写BundleAdjustment 一、总览二、搭建各种数据结构1.存储一个关键点信息的KeyPoint类型2.存储匹配情况的Match类型 三、构建一些方法，即算法1、提取特征点的算法2、计算BREIEF描述子3、进行BFmatch4、其他的方法 四、手写BA结果 一、总览 由于c++基本功及其不扎实，除了上课内容其他啥东西也没写过，因此本次实验的手写BA主要还是一个简单版的实现，在很多地方有了简化。复杂的算法逻辑等以后想加了再加，本次实验主要是搭建一个从读图、到提取特征点、到求得描述子、到匹配特征点、到求解相机位姿的一套流程框架，是对已学的视觉slam十四讲的前端内容做一个连贯的整理。
此次程序的总体框架按照高翔的十四讲上编写一个小型系统的框架来进行。如下图：
先解释下各文件夹里面装的东西。
app:主函数BA_PnP.cpp，及它的CmakeLists.txt.
bin:可执行文件.
build:编译中间文件.
cmake_modules: 啥也没有.
data:原始图片素材.
include:各种头文件，都是自己写的.
lib:不知道有啥用，应该是什么的中间文件存放地.
src:各种cpp文件，存放各种用于实现头文件的源文件.
test:啥也没有.
二、搭建各种数据结构 常言道，程序 = 数据类型 + 算法 。之前对这句话没什么体会，这次编写下来，深感这句话是真理！此篇博客就先从数据结构开始讲起。
1.存储一个关键点信息的KeyPoint类型 存储关键点，在opencv中有cv::KeyPoint类型可以直接使用，本次实验用的是自己写的类型。
KeyPoint类主要需要存储关键点的坐标信息x_,y_.为了之后匹配关键点时方便些，给它加了id_参数。pyramid_金字塔层数没有用到。
类型的方法就随便搞了几个，主要是为了学习一下头文件和源文件的链接。
注意：在头文件和源文件链接时，需要在src/CMakeLists.txt之中加上源文件的名字，不然会链接不上。
KeyPoint.h：
#ifndef _KeyPoint_H_ #define _KeyPoint_H_ #include "common_include.h" class KeyPoint { public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW; // typedef std::shared_ptr&lt;KeyPoint&gt; Ptr; int x_,y_; int id_; int num_;//周围一圈亮度差别大的点的个数，用来筛选，防止角点过于集中。 int pyramid_ = -1;//金字塔层数 KeyPoint(); KeyPoint(int x , int y , int id , int num ): x_(x) , y_(y) , id_(id) , num_(num){} KeyPoint(int x , int y , int id , int num , int pyramid): //有金字塔的构造 x_(x) , y_(y) , id_(id) , num_(num) , pyramid_(pyramid){} // KeyPoint(const cv::Mat &amp;img1 , double threshold = 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d88d21be18efe29d901354f9e98b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9842aee1e1e8e25ddd84cb2e07a12fd4/" rel="bookmark">
			HTML学习总篇——小白篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML学习 1. HTML的了解——小白篇（1）
2. HTML的基本信息——小白篇(2)
3. HTML图像标签————小白篇(3)
4. HTML的超链接——小白篇(4)
5. HTML注释——小白篇(5)
6. HTML列表——小白篇(6)
7. HTML表格——小白篇(7)
8. HTML表单标签——小白篇(8)
9. HTML多媒体元素——小白篇(9)
10. HTML复习和查阅文档——小白篇(10)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9390e020058ed06e816ebbf8a05cca47/" rel="bookmark">
			大一微积分笔记整理_期末来了，请收下这筐学霸笔记！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子科技大学 有这么些人
他们手握着数本这样的“秘籍”
上载天文异象可溯古
下记沙海沉浮能追今
也有这么一些人
考试季临时抱佛脚
在学习教材和ppt后
抬头45度仰头而叹
“恨哉，诲哉，求笔记啊！”
学科笔记，是我们大学里认真与勤奋的见证，是学习中必不可少的一步阶梯。
而在成电，丰富的课程体系和专业知识并没有难住众多的学子们，他们用平凡的笔，创作了一份份优秀的学习笔记。
近日，党委学生工作部学生发展指导中心收集了一波学霸笔记，一起来围观吧！
微积分
△物理学院 李鑫
△计算机科学与工程学院 巩嘉诚
线性代数
△信息与通信工程学院 张凌焰
△数学科学学院 陈晓庆
英语
△外国语学院 黄铮
△外国语学院 刘科竞
大学物理
△机械与电气工程学院 高馨
△自动化工程学院 曹恬
量子力学
△电子科学与工程学院 刘煜
数字逻辑电路
△物理学院 乔晓丰
概率论
△公共管理学院 张睿
△自动化工程学院 尹呈今
经济学原理
△公共管理学院 张睿
模拟电路
△信息与通信工程学院 罗鼎
△信息与通信工程学院 李奕璇
通信原理
△信息与通信工程学院 罗鼎
组织胚胎学
△医学院 唐宇彤
生物化学
△生命科学与技术学院 王渝鸿
电子工程数学方法
△电子科学与工程学院 牛嘉
各学科的精美笔记见证了
成电学子心有学海，笔下生花
当一页页笔记被翻开
抚摸着知识的线条
温故而知新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9390e020058ed06e816ebbf8a05cca47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b60c5092caf03c856c6a00afa6e73e/" rel="bookmark">
			Linux遇到Aborted (core dumped)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题描述 或出现：
2、关于Core Dump的分析 2.1 什么是Core Dump Core的意思是内存, Dump的意思是扔出来, 堆出来。在开发（或使用）一个程序时，有时程序莫名其妙的down了, 却没有任何的提示(有时候会提示core dumped)。虽然系统没事，但我们下次仍可能遇到相同的问题。这时候可以查看一下有没有形如core.PID的core文件生成，这个文件便是操作系统把程序down掉时的内存内容扔出来生成的，让我们或是 debugger 做为参考。这个动作就叫作 core dump。core dump又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dump。简而言之，进程异常终止，进程用户空间的数据就会被写到磁盘。 2.2 为何有时程序Down了，却没生成 Core文件。 有时候程序down了, 不像编译错误一样会提示到文件一行，而是没有任何信息。一种办法是用gdb的step（linux下调试工具gdb是很强大的调试器）, 一步一步寻找，但要step一个上万行的代码让人难以想象。 我们还有更好的办法，这就是core file。但是core文件却没有生成，这是因为core.PID的core文件的生成跟你当前系统的环境设置有关系，系统默认core文件的大小为0（注意core file size (blocks, -c) 0 这行，这表示的是分配给core文件的长度（单位为字节，一个块的大小要分系统而定了），为0肯定是不得行的，那就修改之）
则需要用ulimit命令查看和修改core文件的大小，使用ulimit -a查看大小，使用 ulimit -c unlimited表示对core文件不做限制 或 使用ulimit -c 1024 对core文件分配1024个字节。
然后再运行程序便成生成core.PID的core文件（core文件生成的位置一般和运行程序的路径相同, 文件名一般为core.进程号）。 2.3 如何使用core文件? 发生core dump之后，使用gdb查看core文件的内容, 以定位文件中引发core dump的行，在在Linux下，查看core文件中的出错堆栈信息有二种方式，使用：gdb -c core.pid program_name或gdb [program_name] [core.pid]可以进入gdb模式：
在进入gdb后输入where并回车，就可以指出是在哪一行被Down掉，在哪个函数内，由谁调用等等。在进入gdb后输入 bt，用bt命令查看backtrace以检查发生程序运行到哪里，来定位core dump的文件-&gt;行。 3、多种示例 3.1 batch_size过大导致的 Aborted(core dumped)
3.2 线程被谋杀， 被谋杀者所在线程会抛出一个异常 Cancellation &amp; C++ Exception
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9b60c5092caf03c856c6a00afa6e73e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a20e02132cae6c8750cf2bb4175eaf/" rel="bookmark">
			无向图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无向图 术语表表示无向图的数据类型深度优先搜索广度优先搜索连通分量 在很多计算机应用中，由相连的节点所表示的模型起到了关键作用。为了描述这些问题，我们要使用一种抽象的数学对象，叫做图。
图论作为数学领域中的一个重要分支已经有数百年的历史了，关于图的算法研究相对来说才开始不久。尽管有些基础的算法在几个世纪前就已经发现了，但大多数有趣的结论都是近几十年才被发现。
图论有着广泛的应用，比如地图、计算机网络、电路、任务调度、社交网络等等。
术语表 在无向图中，边仅仅是两个顶点之间的连接。
图是由一组顶点和一组能够将两个顶点相连的边组成的
我们使用0至V-1来表示一张含有V个顶点的图中各个顶点，这样是为了方便使用数组索引来编写能够高效访问各个顶点中信息的代码。
特殊的图
自环：即一条连接一个顶点和其自身的边
平行边：连接同一对顶点的多条边
如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是连通图。一幅非连通的图由若干连通的部分组成，它们都是极大连通子图。一般来说，要处理一张图就要一个个地处理它的连通分量。树是一幅无环连通图。
树的定义非常有用，稍作改动就可以变成用来描述程序行为的（函数调用层次）模型和数据结构（二叉查找树）。
当且仅当一幅含有V个顶点的图G满足下列5个条件之一是，它就是一棵树：
G有V-1条边且不含环G有V-1条边且是连通的G是连通的，但删除任意一条边都会使它不再连通G是无环的，但添加任意一条边都会产生一条环G中任意一对顶点之间仅存在一条简单路径 图的密度是指已经连接的顶点对占所有可能被连接的顶点对的比例。在稀疏图中，被连接的顶点对很少，而在稠密图中，只有少部分定点对之间没有边连接。
二分图是一种能够将所有节点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。
表示无向图的数据类型 数据结构需要有以下两种要求：
它必须为可能在应用中碰到的各种类型的图预留出足够的空间Graph的实例方法的实现一定要快 邻接矩阵：邻接矩阵对内存的要求太高，不满足第一个条件。
事实上，我们可以使用邻接表数组，我们可以使用一个以顶点为索引的列表数组，其中每个元素都是和该顶点相邻的顶点列表。
数据结构使用的空间和V+E成正比
添加一条边所需的时间为常数
遍历顶点V的所有相邻顶点所需的时间和V的度数成正比
多个不同的邻接表可能表示同一幅图
class Graph { private: const int V; // vertex num int E = 0; // edge num std::vector&lt;std::vector&lt;int&gt;&gt; adj; public: Graph(int V) : V(V) { adj.resize(V); } int getV() { return V; } int getE() { return E; } void addEdge(int v, int w) { adj[v].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a20e02132cae6c8750cf2bb4175eaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296c732662dfd1d85c6c17487ce32e52/" rel="bookmark">
			rto净化效率计算公式_【搞懂】如何计算RTO空车运行天然气消耗量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. RTO热量平衡RTO 正常运行时，系统需要补充的热量等于系统排放的热量。RTO 系统排放的热量分为两部分：①烟气带走的热量；②系统表面散热。 根据现有的工程设备设计，RTO 系统排放的热量中系统表面散热远小于烟气带走的热量。因此，理论核算过程中，可不考虑RTO 系统的表面散热。 2. 理论核算 假定一套10000Nm ³/h 的三床式RTO ，入口温度为25 ℃，设计热效率≥95% ，炉膛平均温度为800 ℃，天然气热值为36000kJ/Nm ³。核算RTO 空车运行需要的天然气消耗量。 RTO空车运行即设备按照设计负荷运行，但是VOCs浓度为0时的状态。RTO 出口温度计算详见：【搞懂】如何计算RTO进出口温差RTO 进出口的温差为38.75 ℃； 根据热量计算公式： RTO系统空车运行时的热量需求为：
Q=1.005×1.293×10000×38.75=503542kJ/h;
因此天然气的消耗量计算为：
VNG=503542÷36000=14Nm³/h；
热量计算公式的解释详见《化工原理》。
往期精彩回顾：
【搞懂】如何计算RTO进出口温差
【涨知识】疏水性分子筛是什么原理
【RTO】一文读懂两床式、三床式、旋转式RTO技术区别
【周末学习时间】沸石转轮系统焖烧风险防控
【安全】化工废气 RTO 净化系统爆炸原因分析
【涨知识】VOCs催化氧化原理及催化剂失活分析
常见沸石转轮无法处理的物质及沸石转轮不易处理的物质
【解密了！】影响沸石分子筛转轮去除效率的因素
沸石转轮选用及使用中的注意事项
RTO设计3T设计参数
你知道么？烟囱高度、直径及烟囱取样口的设计规范
空气过滤器的等级划分介绍G，F，H，U是什么等级
常用VOCs废气处理工艺的优缺点分析
【收藏版】常用VOCs物质的爆炸上下限表
【学习】沸石转轮吸附浓缩与活性炭吸附浓缩技术对比
【对比】一文读懂RTO、CO、RCO的技术区别
欢迎大家关注支持本公众号(VOCs治理减排技术)，同时欢迎大家在本站投稿！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd878ea4a28ba442f647d7314f7df35/" rel="bookmark">
			单片机sprintf函数的用法_单片机STM32在开发中常用库函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.GPIO初始化函数
用法：
voidGPIO_Configuration(void) { GPIO_InitTypeDefGPIO_InitStructure;//GPIO状态恢复默认参数 GPIO_InitStructure.GPIO_Pin=GPIO_Pin_标号|GPIO_Pin_标号; //管脚位置定义，标号可以是NONE、ALL、0至15。 GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;//最高输出速度为50MHz GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;//推挽输出 GPIO_Init(GPIOC,&amp;GPIO_InitStructure);//C组GPIO初始化 /*注：以上四行代码为一组，每组GPIO属性必须相同，默认的GPIO参数为：ALL，2MHz，FLATING。如果其中任意一行与前一组相应设置相同，那么那一行可以省略，由此推论如果前面已经将此行参数设定为默认参数(包括使用GPIO_InitTypeDefGPIO_InitStructure代码)，本组应用也是默认参数的话，那么也可以省略。以下重复这个过程直到所有应用的管脚全部被定义完毕。*/ } GPIO基础应用：向管脚置1||0
GPIO_SetBits(GPIOC,GPIO_Pin_1);//置1 GPIO_ResetBits(GPIOC,GPIO_Pin_1);//置0 2.RCC:单片机时钟管理。
管理外部、内部和外设的时钟，设置、打开和关闭这些时钟。
用法：
函数初始化
voidRCC_Configuration(void)//时钟初始化函数 { ErrorStatusHSEStartUpStatus;//等待时钟的稳定 RCC_DeInit();//时钟管理重置 RCC_HSEConfig(RCC_HSE_ON);//打开外部晶振HSEStartUpStatus=RCC_WaitForHSEStartUp();//等待外部晶振就绪 if(HSEStartUpStatus==SUCCESS) { FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);//flash读取缓冲，加速 FLASH_SetLatency(FLASH_Latency_2);//flash操作的延时 RCC_HCLKConfig(RCC_SYSCLK_Div1);//AHB使用系统时钟 RCC_PCLK2Config(RCC_HCLK_Div2);//APB2(高速)为HCLK的一半 RCC_PCLK1Config(RCC_HCLK_Div2);//APB1(低速)为HCLK的一半 /*注：AHB主要负责外部存储器时钟。APB2负责AD，I/O，高级TIM，串口1。APB1负 责DA，USB，SPI，I2C，CAN，串口2345，普通TIM。*/ RCC_PLLConfig(RCC_PLLSource_HSE_Div1,RCC_PLLMul_9); //PLLCLK=8MHz*9=72MHz RCC_PLLCmd(ENABLE);//启动PLL while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY)==RESET){}//等待PLL启动 RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);//将PLL设置为系统时钟源 while(RCC_GetSYSCLKSource()!=0x08){}//等待系统时钟源的启动 } RCC_AHBPeriphClockCmd(ABP2设备1|ABP2设备2|,ENABLE);//启动AHP设备 RCC_APB2PeriphClockCmd(ABP2设备1|ABP2设备2|,ENABLE);//启动ABP2设备 RCC_APB1PeriphClockCmd(ABP2设备1|ABP2设备2|,ENABLE);//启动ABP1设备 } 3.NVIC：系统中断管理。
管理系统内部的中断，负责打开和关闭中断。
基础应用1，中断的初始化函数，包括设置中断向量表位置，和开启所需的中断两部分。
用法：
voidNVIC_Configuration(void) { NVIC_InitTypeDefNVIC_InitStructure;//中断管理恢复默认参数 #ifdefVECT_TAB_RAM /*如果C/C++CompilerPreprocessorDefinedsymbols中的定义了VECT_TAB_RAM(见程序库更改内容的表格)*/ NVIC_SetVectorTable(NVIC_VectTab_RAM,0x0);//则在RAM调试 #else//如果没有定义VECT_TAB_RAM NVIC_SetVectorTable(NVIC_VectTab_FLASH,0x0);//则在Flash里调试 #endif//结束判断语句 /*以下为中断的开启过程，不是所有程序必须的。*/ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置NVIC优先级分组，方式。 NVIC_InitStructure.NVIC_IRQChannel=中断通道名;//开中断，中断名称见函数库 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0;//抢占优先级 NVIC_InitStructure.NVIC_IRQChannelSubPriority=0;//响应优先级 NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;//启动此通道的中断 NVIC_Init(&amp;NVIC_InitStructure);//中断初始化 } 注：一共16个优先级，分为抢占式和响应式。两种优先级所占的数量由此代码确定，NVIC_PriorityGroup_x可以是0、1、2、3、4，分别代表抢占优先级有1、2、4、8、16个和响应优先级有16、8、4、2、1个。规定两种优先级的数量后，所有的中断级别必须在其中选择，抢占级别高的会打断其他中断优先执行，而响应级别高的会在其他中断执行完优先执行。
4.FLASH：芯片内部存储器flash操作函数
对芯片内部flash进行操作的函数，包括读取，状态，擦除，写入等等，可以允许程序去操作flash上的数据。
基础应用1，FLASH时序延迟几个周期，等待总线同步操作。推荐按照单片机系统运行频率，0—24MHz时，取Latency=0;24—48MHz时，取Latency=1;48~72MHz时，取Latency=2。所有程序中必须的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd878ea4a28ba442f647d7314f7df35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f3431f2d0eefc3c22a2e4199a7c04f4/" rel="bookmark">
			kvm架构服务器_浪潮K1 Power与云计算基础架构（五）｜天空中最亮的星
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“云”给人的第一感觉总是神秘莫测，虚无飘渺。很多事情如果和云联系在一起，立刻会高大上起来，就像西游记中的孙悟空，除了火眼金睛，七十二变，那一个跟头十万八千里的筋斗云也不可或缺。
“云计算”无疑是当今IT界最火热的概念之一，“上云”也成为越来越多的企业在考虑的事情。在云计算的基础架构中，浪潮K1 Power能发挥怎样的作用？有哪些优势？或者在某些人的印象中，云计算基础架构除了构建在x86平台，还有其他可选项吗 ？阅读本文后，希望您能找到一些答案
05 寻找天空中最亮的星
虚拟化技术优势 LPAR硬件逻辑分区
LPAR硬件逻辑分区技术兼顾隔离性和灵活性需求，是硬件分区技术的最佳实践。对比物理分区如友商仅高端支持的HP nPar、Oracle Physical Domains等，提供更好的灵活性；对比软件虚拟化如VMWare、KVM等，提供更好的安全隔离、性能保障。
客户收益：
减少管理服务器数量资源灵活变更，更好的硬件资源利用率 PowerVM
PowerVM 为运行 AIX、IBM i和Linux工作负载的浪潮K1 Power服务器提供了行业领先的虚拟化解决方案。经过十余年的发展和创新，PowerVM成为最先进的企业级虚拟化技术的代表，并被大多数的Power Systems拥有者广泛地部署在世界各地的生产环境中。
PowerVM虚拟化技术在性能、安全性、企业级应用认证等方面遥遥领先其他虚拟化技术。对比小众的HP/Oracle小型机的虚拟化软件，各维度技术保持领先，案例数量碾压；对比x86虚拟化软件如VMWare、KVM等，提供更好的安全隔离、性能保障。
客户收益：
为用户提供一个动态的，共享的基础架构整合服务器等资源，减少硬件，软件，管理和能源成本迅速反应和灵活应对新需求，提高IT基础架构的服务性 计算优势 虚拟机密度优势
使用LPAR硬件逻辑分区技术，浪潮K1 Power E980单机支持最大192个逻辑分区使用PowerVM虚拟化技术，单机支持最大1000个分区使用KVM虚拟化技术，以一款服务器FP5280G2为例，该服务器为2路CPU，每路CPU有16物理核，每物理核有4线程，所以共有 2X16X4=128线程，如果每个虚拟机最低使nv用1线程，可以虚拟出128个虚机，大大提高虚拟机密度运行Docker容器，同样得益于Power的SMT并发多线程技术，在一款服务器S924 上，运行超过10000个容器 性价比优势 EnterpriseDB Postgres Advanced Server 10
性能结果如下，可以看到每美元的TPS，也就是性价比，提升了2.4倍 (5.9/2.5=2.4)
MongoDB 3.6
性能结果如下，可以看到每美元的OPS，也就是性价比，提升了2倍 (22/11=2)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6b452768dbe4c7df8c14af24ad831b/" rel="bookmark">
			手机prt文件浏览器_手机看电脑里存货只距离这么一个软件，各种神操作随你耍Windows...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 平时我们想看电脑里面的照片、文档、视频的话，你是怎么操作的呢？
手机和电脑在同一路由下的操作可能是：
小白用户：小文件我直接QQ或者微信发过去用，大文件数据线传！
大神用户：我建个服务器，如FTP服务器，抛弃数据线数据；或者建个HTTP服务器，手机直接访问电脑资源！
至尊用户：如果你家有NAS或者其他家庭云的话，这文章没法写了！！！
大神用户的这套神操作可能比较麻烦，你查询教程半天还不够麻烦的！所以神器说今天就推荐一款不到7M的小软件，搭建轻量HTTP服务器，实现手机秒连电脑，这款软件名叫「Fast」
软件甚至没有图标，双击即可使用，双击后一般会弹出一个防火墙警告，选择保存就OK了。
重点技巧来了：我把这个「Fast」放到哪个文件夹里，该个文件夹就作为未来手机访问的主目录。
比如我放置在I盘的python文件夹下，打开「Fast」弹出来一个内网地址，手机浏览器直接打开提示的内网地址就可以了(你为了方便可以把fast放到任何你想放置的目录，但是打开时只保留一个窗口)，并且这个CMD的黑背景窗口不要关闭！
浏览器直接打开的样子是这样的，mp4文件可以直接点击在浏览器中进行播放。
有的文件我们点击的时候会提示进行下载，比如上面的AVI格式的文件，浏览器可能并不支持直接在线观看，如果你想在线观看的话可以长按复制链接地址，在视频播放器软件中比如安卓手机MXplayer中粘贴地址使用串流播放(可以支持倍速播放)。
我在这个文件夹中添加了一张图片「设计师.jpg」的图片，只需要在手机浏览器刷新一下页面，会出现新的「设计师.jpg」的图片链接，浏览器打开即可看到图片。
总的来说这款软件非常无脑方便的解决了手机电脑互联看电脑资料的功能，如果你也想偷偷的看电脑里面的存货，不妨尝试回复「fast」或「20190602」来开启轻量HTPP服务器体验一下吧。
你点的每一个在看，我都觉得你长得好看 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6ec4567343f47005f6eb065513970b/" rel="bookmark">
			vue element 表格多选框的使用心得selection-change和row-click
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @selection-change="handleSelectionChange"多选框被选中时触发
@row-click=“textRowClick” 行点击被触发
&lt;el-table :data="textDocList" border style="width: 100%" @selection-change="handleSelectionChange" ref="textDocRef" @row-click="textRowClick" max-height="700" &gt; 多选框被选中触发，参数为selection，可获取选中行的数据，数组类型，多选后，会将选中的每行都放进数组里面，数组套数组。可通过selection.length获取选中的行数量从而去做一些判断
// 监控多选框事件 handleSelectionChange(selection) { this.selectNum = selection.length; this.selection = selection; }, 行点击触发，可以在这个方法中调用表格的方法toggleRowSelection实现点击行就选中多选框
textRowClick(row) { this.$refs.textDocRef.toggleRowSelection(row); }, 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/195/">«</a>
	<span class="pagination__item pagination__item--current">196/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/197/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>