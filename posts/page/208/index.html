<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64058891d131ba2f9739395af385a41/" rel="bookmark">
			以太坊加密原理（内容为链接的内容目录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容源自https://www.jianshu.com/p/abfc4f442325
以太坊加密原理总结：
一、非对称加密基础知识
（一）非对称加密解决的问题
（二）非对称加密过程演示与相关问题
1、公钥加密演示
2、私钥加密公钥解密演示
3、双重加密演示–先公钥加密，后私钥签名
4、双重加密演示–先私钥签名，后公钥加密
（三）、消息认证
（四）、消息签名
(五)、混合加密–不变的共享对称秘钥
(六)、混合加密–随机的共享对称秘钥
二、基于ECC的加密套件
(一)、加密套件概念
(二)、在网络中都涉及哪些加密呢？
(三)、ECC、ECDSA、ECDHE、ECIES
(三)、ECC算法
1、ECC定义：
2、ECC算法的理解
3、ECC加法体系
4、ECC的乘法计算与点倍积的推导​
5、ECDSA 签名
6、ECDH原理
三、以太坊中 UDP通信的加密方案
(一)、H-MAC的加密认证签名模型：
1、H-MAC基本模型：
2、以太坊中UDP的加密，认证，签名模型：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f776413e6b7d3251117344190ca28e/" rel="bookmark">
			Web低危漏洞之缺少“X-XSS-Protection“头的处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 xss攻击会导致网站的低危漏洞，需要进行防护
漏洞呈现 解决 使用 X-XSS-Protection值的使用场景 0：禁用XSS保护；
1：启用XSS保护；
1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；
方法一: PHP配置设置 在Header.php文件中添加如下内容:
···
… …
header(
“X-XSS-Protection: 1”
);
… …
···
方法二: nginx配置设置 ... ... server { ... ... add_header X-XSS-Protection 1; ... ... 结语 … …
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb1e4ee36c4f5a9212497d497f8a4e0/" rel="bookmark">
			Java 的浅拷贝与深拷贝详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先讲一讲Java 中equals() 和==的区别 1. 基本数据类型(byte,short,char,int,long,float,double,boolean) 双等号（==）和 equals ,比较的是他们的值。
2. 类 当使用==比较的是两个对象的内存地址
当时用equals比较的也是内存地址 ，因为Object类中的equals方法就是用==比较的
什么是浅拷贝？什么是深拷贝？ 一般对于类而言 深拷贝： 对基本数据类型进行值传递，对引用数据类型，创建一个新的，对其进行赋值。（两个指针指向不同的内存单元） 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用(类似C 中的指针，等于两个指针指向同一个内存单元) ​ 比如:
​ 当使用浅拷贝中的clone
​ 测试结果如下，f1与f2中的成员变量并不相等。
​ 所以说如果要深拷贝必须将所有的成员变量都进行clone
在写浅拷贝和深拷贝之前，还需要了解Java中的Clone
可以看到如果类没有实现Cloneable接口就会报错，如果实现了就调用 internalClone() ， internalClone() 这个方法会返回一个这个类的一个新实例。
所以说如果一个类需要调用Clone()， 那么这个了类需要实现Cloneable 接口
Cloneable 接口 只起到一个标识作用，表明这个类需要用到Clone()方法。
如何进行浅拷贝？如何进行深拷贝 浅拷贝 ​ 如图中的clone()方法 ，这就实现了浅拷贝
​ 首先，这个类中有一个名为SonObject的子类。并且FatherObject 实现了Cloneable接口，并且Clone() 方法调用了Object中的Clone（）方法。
深拷贝 ​ 实现浅拷贝有两种方法，一种是利用Object中的Clone() ，一种是将类序列化然后再反序列化.
​
1. 利用Object中的clone() ​	图中实现了深拷贝的clone 2. 先序列化，反序列化 网络上的列子挺多的，这里就不详细描述。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d464b002868791401343e2fdbe7200e0/" rel="bookmark">
			Redis主从复制（八）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言：之前写到在系统中集成Redis之后，可以减少对数据库的访问量，从而增加系统的并发量，但是单个Redis的性能终究是有限的，在系统业务量不断增大的时候，单节点的Redis的并发量很容易就达到上限，这种时候就需要引入Redis的主从复制模式（读写分离模式，一般搭配哨兵机制一起使用）。
一、主从复制模式 在单节点Redis的基础上，再扩展Redis节点，选择其中一台作为主节点，其余的Redis节点就是从节点，主节点主要负责数据的写入，从节点负责读数据请求，主节点会复制自身的数据到从节点。
主从复制原理： 首先进行全量更新
slave服务器向master发送psync命令，告诉master我需要同步数据了。master接收到psync命令后会进行BGSAVE命令生成RDB文件快照，同时将此刻起的写命令记录在缓存区。master生RDB成完后，会将RDB文件发送给slave。slave接收到RDB文件后会载入内存，并且将数据库状态变更为master在执行BGSAVE时的状态一致。master会发送保存在缓冲区里的所有写命令slave执行这些写命令。 运行过程中进行增量更新
在master全量数据同步到slave之后，如果再有写命令进到master，在master执行完该写命令之后，会把这条写命令发送给所有slave节点，增量更新可以把master看作是redis的客户端，slave看作是redis的服务端：
例如：用户先向master发送一条写命令：set name shanxi，master在执行完这条命令之后，会向所有slave发送这条写命令，slave接收到之后，会在本地执行set name shanxi。
主从模式：一主一从、一主二从（常用）、树状模式（当有多个从节点时，这种模式会降低主节点的同步压力）
一般不推荐一个主节点对应多个从节点，一来会占用内网的带宽，二来主节点的同步压力也会很大。
二、主从复制模式配置 首先删除从节点的rdb和aof文件，以防出现影响。
在配置主从复制的时候，只需要配置从节点即可，不需要对主节点进行配置。
修改redis的配置文件：
################################# REPLICATION ################################# # 配置所属主节点的地址与端口 slaveof 192.168.40.41 6379 # 配置所属主节点的认证密码 masterauth 123456 # 配置从节点为只读模式，默认配置，不需要进行修改 slave-read-only yes 注意：使用主从复制模式后，master必须开启持久化，否则master宕机重启以后会把从节点的数据清空
三、查看与测试 1、主从配置好之后，重启redis，然后进入到redis的客户端（redis-cli命令进入），在客户端输入info replication命令可以看到主从相关信息，在主节点输入该命令可以看到如下信息：
从节点输入info replication命令会看到如下信息：
2、测试
在主节点执行一些写命令，然后在从节点使用get命令看是否能获取到主节点写入的值。 主节点执行：set name 10087
从节点执行：get name（从节点可以获取到10087）
在从节点执行写命令，会报不允许写入错误停掉一台从节点，然后在主节点执行一些写的命令，然后再次启动这台停掉的从节点，会发现在停机（或宕机）期间主节点写入的数据都被同步了进来 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8abdc49fa05d68096a2f0b378fed027/" rel="bookmark">
			Vue  Itea软件里直接npm run build 报错npm ERR！ missing script :build
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导致报错的环境：
1、missing script :build；
看了下项目的整个目录：
2、度娘了一番,大多数的解决方案是：查看package.json的内容，比如：
如果是build：prod -----&gt; 对应你输入的指令就是：npm run build:prod --report
3、如第二步 ：本人的项目里有两个package.json文件，本人点开了第一文件，查看：
看图可知本人指令：npm run build 是没错的，
4、后来我把第二个package.json文件删除，重新输入指令运行，出现了找不到package.json文件的错误，
本人就发现我是文件夹打开错误了，Itea软件需打开logistic(我的项目名)，我一开始打开的是它上一层文件LogisticDep
5、进入到logistic文件后，重新运行npm run build,无报错了。具体原理·····
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c19320e3bf2a86d9a1215ff248368ea/" rel="bookmark">
			Docker常用命令-自用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker常用命令-自用 1. 镜像仓库 1.1 登陆/登出 登陆-默认Docker Hub
docker login -u [username] -p [password] 登陆到指定镜像
docker login -u [username] -p [password] [镜像地址] 登出
docker logout 1.2 拉取镜像 拉取镜像
docker pull mcr.microsoft.com/dotnet/core/aspnet 拉取指定tag的镜像
docker pull mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim 拉取镜像所有tag
docker pull --all-tags mcr.microsoft.com/dotnet/core/aspnet 1.3 推送镜像 PS：推送到Docker Hub镜像仓库时候莫名会出现权限问题，把镜像重命名为[用户名/镜像名]后可以解决
docker push [username/]NAME:TAG 2 镜像操作 2.1 查看镜像 默认显示所有顶级图像，隐藏了中间镜像，以下命令作用相同
docker images docker image ls docker image list 显示所有镜像，包括中间镜像
docker images -a 仅显示镜像ID
docker images -q format序列化，列出镜像ID和仓库名的命令，和列出ID、Repository和tag的命令
docker images --format "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c19320e3bf2a86d9a1215ff248368ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc91575a83f12be84a2b716c793149ce/" rel="bookmark">
			【学习总结】Lidar与IMU标定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅用于自己学习雷达与IMU标定过程中的一些记录。
最近项目需要入手了镭神智能的“镭神C32”激光雷达，和KVH的1750IMU模块。在调用驱动完成初步数据读取之后，现在需要对雷达IMU系统进行标定。查阅了一些资料，发现并没有太多关于Lidar+IMU标定的资料。大多数论文中只是提到一句“我们认为雷达和IMU已经完成了标定”或者“Lidar与IMU采用离线的方式完成标定”。真的让人摸不着头脑。
标定需要标什么? 参考文献[1]中指出 “the LiDAR-IMU calibration mainly includes the LiDAR extrinsic parameters calibration, IMU intrinsic parameters calibration, and coordinate transformation between LiDAR and IMU”，即需要标定三个：Lidar的外参、IMU内参、Lidar与IMU之间的变换。
Lidar外参是什么鬼，我也没搞清楚，好像和Lidar探测时球坐标系有关，但一般厂商都做了标定，所以不用管。
IMU的内参，首先需要给出IMU的测量模型： a m = R G I ( a − g ) + b a ( t ) + n a a_m = R_G^I(a-g)+b_a(t)+n_a am​=RGI​(a−g)+ba​(t)+na​ w m = w + b g ( t ) + n g w_m=w+b_g(t)+n_g wm​=w+bg​(t)+ng​ 等号左侧是测量值， a , w a, w a,w是实际的真值， g g g是重力加速度（可以看出IMU在z轴正方时会有一个 + g +g +g的输出，而且是归一化的，表示“几个 g g g”）， b a , b g b_a, b_g ba​,bg​ 是随机游走噪声，随时间变化，而 n g , n a n_g,n_a ng​,na​是测量高斯白噪声。在IMU启动后，需要确定到世界系/大地系/地球系的旋转矩阵 R R R，并需要实时估计两个bias。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc91575a83f12be84a2b716c793149ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a08fd5f9a0ade784232ff113fd236b45/" rel="bookmark">
			zynq之ps端开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf和xil_printf的不同 https://www.eefocus.com/walkie/blog/09-02/165549_bf04c.html
ps端对DDR的读写 /***************************************************************************/
/
*
@brief Performs an input operation for a memory location by reading
from the specified address and returning the 8 bit Value read from that address. @param Addr: contains the address to perform the input operation
@return The 8 bit Value read from the specified input address.
******************************************************************************/
static INLINE u8 Xil_In8(UINTPTR Addr)
{
return *(volatile u8 *) Addr;
}
/***************************************************************************/
/
*
@brief Performs an input operation for a memory location by reading from the specified address and returning the 16 bit Value read from that address.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a08fd5f9a0ade784232ff113fd236b45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e28a58052caa4fcfbc34896905f475/" rel="bookmark">
			unity学生demo_欢迎参加Unity全球学生挑战赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity学生demo
Whether you’re just starting to learn or you’ve been making games for years, join the Unity Global Student Challenge to show the world what you can create!
无论您是刚开始学习还是已经从事游戏多年，都可以参加Unity全球学生挑战赛 ，向世界展示您可以创造什么！ At Unity, we’ve seen students create amazing projects from competitions to the classroom to their dorm room. When given the right tools and inspiration to create, they turn their ideas into reality. In just 24 hours at a hackathon or game jam, these minds are able to produce playable prototypes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e28a58052caa4fcfbc34896905f475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc3a52cfb2a87c18b24d4ee293c2d66/" rel="bookmark">
			python 提取jpg文件名字到txt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python 提取jpg文件名字到txt # -*- coding:utf-8 -*- import os # 图片地址 data_base_dir = r"C:\Users\HP\Desktop\SRNet-eng\SRNet-Datagen\dataset/bg" file_list = [] #建立列表，用于保存图片信息 # txt文件地址 write_file_name = r'C:\Users\HP\Desktop\SRNet-eng\SRNet-Datagen\dataset/bg/labels.txt' write_file = open(write_file_name, "w") #以只写方式打开write_file_name文件 for file in os.listdir(data_base_dir): #file为current_dir当前目录下图片名 if file.endswith(".jpg"): #如果file以jpg结尾 write_name = file #图片路径 + 图片名 + 标签 file_list.append(write_name) #将write_name添加到file_list列表最后 sorted(file_list) #将列表中所有元素随机排列 number_of_lines = len(file_list) #列表中元素个数 #将图片信息写入txt文件中 for current_line in range(number_of_lines): write_file.write(file_list[current_line] + '\n') #关闭文件 write_file.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b5fe4a6485e2f88000351a7cd057db/" rel="bookmark">
			事件相机 Event Camera 论文汇总（总是在持续更新中的汇总）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件相机 Event Camera 论文汇总（总是在持续更新中的汇总） 目录
Survey ECCV
2020 ECCV
2018 ECCV CVPR
2020 CVPR
2019 CVPR
2018 CVPR
2017 CVPR
ICCV
2019 ICCV
2017 ICCV
WACV
2020 WACV
AAAI 2020 AAAI
ICME
2019 ICME
Survey Event-based vision: A survey
Event-based media processing and analysis: A survey of the literature
ECCV 2020 ECCV Reducing the Sim-to-Real Gap for EventCameras
Spike-FlowNet: Event-based Optical FlowEstimation with Energy-Efficient Hybrid NeuralNetworks
Entropy Minimisation Framework forEvent-based Vision Model Estimation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b5fe4a6485e2f88000351a7cd057db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a9797fa41aad22310c2bf7cdaa67b7/" rel="bookmark">
			30个极简python代码(demo）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/weixin_45912307/article/details/108529670
30个极简python代码(demo） 1重复元素判定
以下方法可以检查给定列表是不是存在重复元素，它会使用 set() 函数来移除所有重复元素。
def all_unique(lst): return len(lst)== len(set(lst)) x = [1,1,2,2,3,2,3,4,5,6] y = [1,2,3,4,5] all_unique(x) # False all_unique(y) # True 2字符元素组成判定
检查两个字符串的组成元素是不是一样的。
from collections import Counter def anagram(first, second): return Counter(first) == Counter(second) anagram("abcd3", "3acdb") # True 3内存占用
import sys variable = 30 print(sys.getsizeof(variable)) # 24 4字节占用
下面的代码块可以检查字符串占用的字节数。
def byte_size(string): return(len(string.encode('utf-8'))) byte_size('') # 4 byte_size('Hello World') # 11 5打印 N 次字符串
该代码块不需要循环语句就能打印 N 次字符串。
n = 2 s ="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a9797fa41aad22310c2bf7cdaa67b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0179e0138e1775a97b8fc0711da6cf1d/" rel="bookmark">
			C#可以自由移动和伸缩的TextBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 主体代码 using System; using System.Collections.Generic; using System.Drawing; using System.Windows.Forms; namespace FrameControl { public partial class MoveTextBox : UserControl { /// &lt;summary&gt; /// 鼠标点击该控件时的事件 /// &lt;/summary&gt; public event Action&lt;object, EventArgs&gt; CtrMouseClick; public event Action&lt;object, KeyEventArgs&gt; CtrKeyDown; enum MousePosOnCtrl { NONE = 0, TOP = 1, RIGHT = 2, BOTTOM = 3, LEFT = 4, TOPLEFT = 5, TOPRIGHT = 6, BOTTOMLEFT = 7, BOTTOMRIGHT = 8, } Dictionary&lt;Panel, MousePosOnCtrl&gt; _dictPanl = new Dictionary&lt;Panel, MousePosOnCtrl&gt;(); MousePosOnCtrl _mpoc; //鼠标在控件中位置 const int MinWidth = 20; //最小宽度 const int MinHeight = 20;//最小高度 public TextBox TextBox { get { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0179e0138e1775a97b8fc0711da6cf1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7d17a2ff2041ece1074a0731c5d627/" rel="bookmark">
			边缘计算网关是什么 边缘计算网关功能优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		边缘计算，即在源头部署数据处理活动和操作，而不必经过集中式网段。通过使计算更接近产生数据的这些项目的网络边缘，此计算过程可优化设备，IoT设备和应用程序。根据所考虑的设备，网络边缘可以指的是设备与Internet通信的区域。
边缘计算网关的功能
驱动自动化 –通过将边缘计算完全集成到驱动运营的设备，设备和流程中，可以在工业车间内实现真正的自动化。在IIoT设备产生大量数据集的情况下，在将可行结果发送回设备之前，将捕获的数据发送到集中式系统进行分析，会降低自动化速度。可以集成边缘计算，以消除通信和处理时滞，从而推动实时自动化。
增强IT安全性 –在制造业中，事实证明，应对整个IT生态系统中的安全漏洞对于大型企业和中小型企业都是一个挑战。将IIoT引入车间也增加了这些挑战，因为IIoT设备创建了供攻击者利用的多个访问点。由于其计算过程背后的概念，将边缘计算应用于工业物联网是解决这些安全挑战的一种方法。
边缘计算的应用减少了故障点或接入点，因为每台IIoT设备都可以独立运行。独立边缘计算功能还可以扩展到旧设备，并创建一个车间，在该车间中可以进行本地数据处理。这意味着IIoT和旧设备将捕获，处理和丢弃临时数据，同时将特定的永久数据发送到集中式网关。
计讯物联TG462系列边缘计算网关采用ARM架构高能效处理器作为主控、采用Linux作为操作系统的嵌入式工业计算机，可实现边缘节点数据优化、实时响应、快速连接、智能应用、安全与隐私保护等业务处理提供计算资源，可以加快采集到的数据的处理与传送速度，减少延迟，有效分担云计算资源负荷。该产品广泛应用工业、智慧水利、智慧城市、智慧电力等行业领域。
计讯物联边缘计算网关的功能
采用Arm架构高端处理器;标准Linux系统，集成Python开发环境和C语言开发环境，提供标准API接口及开发指导，为用户的二次应用开发提供稳定快捷的平台，用户可轻松调用系统各种接口及资源，打造差异化核心竞争力。
丰富的采集控制端口满足各种传感器的采集和控制，支持工业路由器功能，实现2路局域网接入和视频数据的采集和上传。支持WAN/LAN、ADSL、GPRS、4G、WIFI等满足不同环境下对远程通信的需求。
设备远程管理、维护，降低运维成本
集GPRS、4G、5G网络、广域网、局域网、WIFI等多种通信方式，可选NB-IOT通方式，支持有线和无线互为备份，支持多中心通信，可同时与多个后台服务器进行通信。内置高精度的GPS模块，能够实时上报站点位置信息。
支持各种行业协议，同时可提供供通信中心入库的方式接入第三方平台或定制第三方协议。支持国内主流组态软件;兼容多种设备主流工业协议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589a2429bb35a932d14ae415f3b62275/" rel="bookmark">
			【并发编程】AQS源码分析(四)通过ReentrantReadWriteLock来查看读写锁的源码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几篇文章分别介绍了AQS的基本的加锁解锁流程，Condition，CountDownLatch共享锁等。这篇文章继续介绍关于ReentrantReadWriteLock相关的原理。
从名字来看就知道ReentrantReadWriteLock是读写锁，读锁指的是共享锁，而写锁则是独占锁。在前几篇文章中了解到ReentrantLock内部通过AQS来实现的是独占锁加锁，其中利用了state变量的值来实现是否加锁的操作。而CountDownLatch则是通过state值是否减为0来实现共享锁。那么ReentrantReadWriteLock却可以既实现共享锁又实现独占锁，它具体是怎么实现的呢？，下面就一步一步解析一下源码。
ReentrantReadWriteLock的类结构 注：下图中绿色箭头代表 implements 实现
紫色箭头代表 extends 继承
红色带’+'号的 代表 内部类
1、从图中，我们可以看到 ReentrantReadWriteLock 实现了 ReadWriteLock 接口。其中只有两个方法如下：
// ReadWriteLock 只有两个方法，一个获取读锁，一个获取写锁 public interface ReadWriteLock { Lock readLock(); Lock writeLock(); } 2、ReadLock和WriteLock作为ReentrantReadWriteLock 内部类 都实现了Lock接口中的lock和tryLock等方法。
3、FairSync和NonFairSync作为ReentrantReadWriteLock 内部类 继承自Sync类，分别实现了公平锁和非公平锁。
这里和ReentrantLock实现不太一样。
在ReentrantLock中，FairSync和NonFairSync都有自己各自的实现方式。都有自己的实际的方法体。
而在ReentrantReadWriteLock 中则将主要实现过程都放在了Sync类中，FairSync和NonFairSync中只是简单的判断了是否为阻塞方式进行（判断是否需要进行排队），需要注意的是，读写锁都可以支持公平和非公平两种模式。
源码解析 首先要解决开始的疑问。
同时实现共享和独占锁 ？ 通常state的含义在不同模式下表示方式也不同
独占模式：0 代表未获取锁，1代表获取锁。
共享模式：每个线程都可以获取锁，对state进行加减操作。
为了能够兼容共享和独占模式，jdk将state这个int类型的值（4个字节，32位）分为了高16位和低16位。其中高16位用于共享模式锁的获取次数，低16位用于独占模式锁的重入次数。
好了，具体的细节，怎么操作的下面跟着源码一步一步来看吧。
ReadLock 我们源码都从构造方法和方法调用入口：
//1、默认非公平锁实现模式 ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //获取读锁 Lock readLock = readWriteLock.readLock(); //加读锁 readLock.lock(); //释放读锁 readLock.unlock(); 构造方法：
//读写锁的内部类变量声明 private final ReentrantReadWriteLock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/589a2429bb35a932d14ae415f3b62275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0364df7976f7e6fdb229ccf1ecd298a3/" rel="bookmark">
			v-model和v-decorator同用时的赋值方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue中v-model和v-decorator的使用 Vue中，使用v-model来进行数据绑定，在Vue-Ant Design 框架的使用中，会有v-decorator的使用，但是两者同时使用的时候，v-model数据绑定却会失效，使用this.name可以获取到组件的值，但是却不能给组件赋值。即使用v-decorator后，组件的赋值方式变了
v-decorator v-decorator 是 Ant Design 的控件验证属性。
经过 getFieldDecorator 或 v-decorator 包装的控件，表单控件会自动添加 value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性），数据同步将被 Form 接管，这会导致以下结果：
不再需要也不应该用 onChange 来做同步，但还是可以继续监听 onChange 等事件。
不能用控件的 value defaultValue 等属性来设置表单域的值，默认值可以用 getFieldDecorator 或 v-decorator 里的 initialValue。
不能用 v-model，可以使用 this.form.setFieldsValue 来动态改变表单值。
v-decorator 取值：
this.form.validateFields((err, values) =&gt; { if (err) { console.log(values) // { name: '' } } }) v-decorator 赋值： this.form.setFieldsValue({ name: '设置值' }) 清空表单数据： this.form.resetFields 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beee5a385da3d4d7e597d5752a564c7c/" rel="bookmark">
			备战蓝桥---可移动的炸弹人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述: 嘿嘿~这个游戏大家都玩过吧。本题是自己给定一张地图和炸弹的初始位置，炸弹位置可移动，现在你需要移动炸弹是炸弹能够炸掉最多的敌人，炸弹一次可以炸掉一行和一列但是墙可以挡住炸弹。
给定的地图中#代表墙，G代表敌人，. 代表炸弹可以移动的地方，保证结果唯一。
输入: 第一行输入炸弹起始位置坐标，第二行输入地图大小n、m（n，m&lt;=10）。
第三到3+n行输入地图。
样例输入: 3 1 6 8 # # # # # # # # # G G . G G G . # # # . # G # G # . . . . . . . # G # . # # G G # # G . . . . G 样例输出: 1,3 5 问题分析: 用DFS(深度优先)算法，对炸弹人能到达的位置进行遍历(find函数)，每到达一个位置，将当前位置坐标传入Boom函数进行爆破，计算每一个位置能炸掉的敌人并记录，并将消灭的最多的敌人数返回到find函数记录到变量Max，实时更新消灭敌人最多的位置的坐标。经过的位置用符号’*'标记。
实现代码： #include&lt;bits/stdc++.h&gt; using namespace std; char Map[100][100]; int m,n,X,Y; int Max=0; int Boom(int x,int y){ int i = 1; int sum = 0; while(Map[x+i][y]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beee5a385da3d4d7e597d5752a564c7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5483c4884f16f04b793718b11d0267f/" rel="bookmark">
			unity学生demo_宣布Unity全球学生挑战赛优胜者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity学生demo
After several weeks of design, development, prototyping, and playtesting, we saw amazing student projects from all over the world! Thank you to all who participated!
经过数周的设计，开发，原型制作和游戏测试，我们看到了来自世界各地的精彩学生项目！ 谢谢所有参加的人！ In November, we challenged student creators to come together and show the world what you could do. The development and growth of the projects in this competition really proved that anything is possible. Every week brought excitement as more and more students joined the competition and works in progress were shared by everyone.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5483c4884f16f04b793718b11d0267f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49cff0c88228426b1fe8d54b3193e38e/" rel="bookmark">
			unity学生demo_Unity全球学生挑战赛的最后一个月
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity学生demo
We’re now officially under the 30 day mark for the Unity Global Student Challenge, and we’re excited to share some inspiration from student projects that made an impact this past year!
现在，我们正式进入Unity全球学生挑战赛的30天大关，很高兴与大家分享来自去年产生影响的学生项目的一些启发！ With the start of a new year and the return of many students back to school, it’s been a busy start to 2019, and January marks the last month of submission for the Global Student Challenge on Unity Connect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49cff0c88228426b1fe8d54b3193e38e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6544508cb697ead27cc5d774e38472/" rel="bookmark">
			设计模式之装饰模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等。在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰模式来实现。
一、装饰模式的定义与特点 装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。
装饰（Decorator）模式的主要优点有：
采用装饰模式扩展对象的功能比采用继承方式更加灵活。可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。 其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。
二、实现 1. 模式的结构
装饰模式主要包含以下角色。
抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 2、代码实现
/// &lt;summary&gt; /// 抽象构件角色 /// &lt;/summary&gt; interface Component { void operation(); } /// &lt;summary&gt; /// 具体构件角色 /// &lt;/summary&gt; class ConcreteComponent : Component { public ConcreteComponent() { Console.WriteLine("创建具体构件角色"); } public void operation() { Console.WriteLine("调用具体构件角色的方法operation()"); } } /// &lt;summary&gt; /// 抽象装饰器角色 /// &lt;/summary&gt; class Decorator : Component { private Component component; public Decorator(Component component) { this.component = component; } virtual public void operation() { component.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6544508cb697ead27cc5d774e38472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db39fa45d9639ee33b32d0381644d5a7/" rel="bookmark">
			VUE element UI 结合Spring Boot 的 Spring Data Jpa进行分页查询并且按id字段进行动态正序逆序排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这不仅仅是前端查出全部数据，然后做假分页和排序，而是结合SpringData Jpa 以及其封装的进行真分页以及排序后查询，每次只从数据库动态获取指定条数和指定页码的数据,解决了全表查询数据量太大的问题。
首先是前端Vue的部分
写一个table加pagination并且绑定必要的方法
&lt;div class="elshowtablediv"&gt; &lt;div&gt; &lt;el-table class="eltable1" :data="UsertableData" :header-cell-style="{background:'#F2F9FF', 'text-align':'center'}" :cell-style="{'text-align':'center'}" @sort-change="changeUsertableSort" style="width: 85vw" border&gt; &lt;el-table-column prop="id" label="编号" width="180" :sortable="'custom'"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="username" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="usernumber" label="账号"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="password" label="密码"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="userrole" label="身份类型"&gt; &lt;/el-table-column&gt; &lt;el-table-column label="操作" width="150"&gt; &lt;template slot-scope="scope"&gt; &lt;el-button circle size="mini" type="primary" icon="el-icon-edit" @click="handleEdit(scope.row)"&gt;&lt;/el-button&gt; &lt;el-button circle size="mini" type="danger" icon="el-icon-delete" @click="handleDelete(scope.row)"&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;div class="divpagenation"&gt; &lt;el-pagination background @size-change="handleSizeChange" @current-change="handleCurrentChange" :current-page="currentPage4" :page-sizes="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db39fa45d9639ee33b32d0381644d5a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b05d9be6efff40b2c51002c0d052f9/" rel="bookmark">
			Python OpenCV  实现yolo目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python opencv 实现yolo 目标检测 YOLO 是现今非常流行的目标检测框架。源代码是用C 写的。这里我们利用opencv 调用训练好的yolo 模型来实现一个demo。
#首先导入相应的模块 import cv2 as cv import argparse import sys import numpy as np import os.path # 初始化变量 confThreshold = 0.5 #置信度阈值 nmsThreshold = 0.4 # 非极大值一直阈值 inpWidth = 416 # 网络输入图像的宽 inpHeight = 416 # 网络输入图像的高 # 构建参数解析器 parser = argparse.ArgumentParser(description='Object Detection using YOLO in OPENCV') parser.add_argument('--image', help='Path to image file.') parser.add_argument('--video', help='Path to video file.') args = parser.parse_args() # 载入类别名称 classesFile = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00b05d9be6efff40b2c51002c0d052f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287e154840f17bb47e33d62cd6710b66/" rel="bookmark">
			unity 2019_宣布Unity for Humanity 2019挑战赛冠军
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity 2019
There’s nothing more inspiring for us than seeing how creators are using Unity to produce world-changing games, films, and XR experiences. We created the Unity for Humanity 2019 Challenge to recognize and support some of the incredible socially conscious experiences people are making with Unity. 看到创作者如何使用Unity来产生改变世界的游戏，电影和XR体验，对我们而言，没有什么比鼓舞人心的了。 我们创建了Unity for Humanity 2019挑战赛，以表彰并支持人们在Unity中所做的令人难以置信的具有社会意识的体验。 Unity for Humanity invites creators to submit projects in production or development that address social and environmental issues and offer impactful solutions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/287e154840f17bb47e33d62cd6710b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd258ed966f81b5c9bf302a9ee467d5/" rel="bookmark">
			备战蓝桥---地质调查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述: 小明是一个地质调查员，在他调查的地方突然出现个泉眼。由于当地的地势不均匀，有高有低，他觉得这意味着这里在不久的将来将会一个小湖。水往低处流，凡是比泉眼地势低或者等于的地方都会被水淹没，地势高的地方水不会越过。而且又因为泉水比较弱，当所有地势低的地方被淹没后，水位将不会上涨，一直定在跟泉眼一样的水位上。现在给出小明掌握的地图，所有的地图都是一个矩形，并按照坐标系分成了一个个小方格，小明测量除了每个方格的具体高度。我们假定当水留到地图边界时，不会留出地图外，现在他想通过这些数据分析出，将来这里将会出现一个多大面积的湖。
输入: 有若干组数据，每组数据的第一行有四个整数n,m,p1,p2(0&lt;n,m,p1,p2&lt;=100)，n和m表示当前地图的长和宽，p1和p2表示当前地图的泉眼位置，即第p1行第p2列，随后的n行中，每行有m个数据。表示这每一个对应坐标的高度。
输出: 输出对应地图中会有多少个格子被水充满。
样例输入: 3 5 2 3
3 4 1 5 1
2 3 3 4 7
4 1 4 1 1
样例输出: 6
问题分析: 此题可以用DFS（深度优先算法）来解决，从泉眼位置出发分别向上，下，左，右四个方向进行递归，找到的位置如果高度小于泉眼的高度，那么它就能够被充满，如果高度高于泉眼位置，则不能够被充满。
实现代码: #include&lt;bits/stdc++.h&gt; using namespace std; int Map[100][100]; int n,m,sum = 0,center = 0; //sum记录被填满格子的数量，center表示泉眼高度 void find(int x,int y) { sum++; Map[x][y]=0x7fffffff;//如果这个格子可以被填满，则标记为一个数值很大的数，表示已访问 //down if(Map[x+1][y]&lt;=center&amp;&amp;x+1&lt;=n) find(x+1,y); //right if(Map[x][y+1]&lt;=center&amp;&amp;y+1&lt;=m) find(x,y+1); //up if(Map[x-1][y]&lt;=center&amp;&amp;x-1&gt;0) find(x-1,y); //left if(Map[x][y-1]&lt;=center&amp;&amp;y-1&gt;0) find(x,y-1); return; } int main(){ int p1,p2; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p1&gt;&gt;p2; fill(Map[0],Map[0]+100*100,0);//初始化地图 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++) { cin&gt;&gt;Map[i][j]; } } center = Map[p1][p2]; find(p1,p2); cout&lt;&lt;sum; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ebdbc416665bd5c483db39474cb205/" rel="bookmark">
			计算机网络思维导图&#43;《王道考研》习题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.计算机网络概述1.思维导图2.知识点 二. 物理层1.思维导图2.知识点 三. 数据链路层1.思维导图2.知识点 四. 网络层1.思维导图2.知识点 五. 传输层1.思维导图2. 知识点 六. 应用层1.思维导图2.知识点 #更新ing 一.计算机网络概述 1.思维导图 2.知识点 计算机网络是由自治计算机互联起来的集合体。关键点：自治计算机，互联，集合体。一个网络中可以没有数据库系统。从物理组成上看，计网由硬件，软件和协议组成。区别局域网和广域网关键在于所采用的协议而非覆盖范围。在n个结点的星型拓扑结构中，有 n-1 条物理链路。其他n-1个结点直接与中心结点相连构成网络。分组交换网络缺点：附加信息开销大。广播式网络 共享广播信道，不存在路由选择问题，可以不要网络层，需要服务访问点。三网指的是电信网络，广播电视网络，计算机网络计网两个最重要的功能：连通性，共享性分组交换：面向无连接 电路交换:面向连接分组交换特点：高效，灵活，迅速，可靠中央处理机之间的距离非常近，一般将它称为多处理机系统分层的好处：各层之间是独立的，灵活性好，结构上相互分割开，易于实现和维护，能促进标准化工作。OSI把层与层之间的交换的数据的单位称为：服务数据单元（SDU）OSI把对等层次之间传送的数据单位称为该层的协议数据单元（PDU）分层的原则： 1）每层至少完成一个独立的完整的功能
2）每层只和相邻的上下层交互，相邻两层之间的交互尽可能简单分组交换每个分组100个字节，其中包含20字分组头，因此400字节数据应分为400/80=5个分组 二. 物理层 1.思维导图 2.知识点 1数据，信号，码元
数据传输方式
通信交互方式
2信源，信道，信宿
3速率，
波特
带宽
4 奈奎斯特定理（带宽和极限码元传输速率之间关系)
香农定理(带宽+信噪比）
5.编码和调制
{
数据-&gt;数字信号（编码）
1）非归编码0101
2）曼彻斯特编码
3）差分曼彻斯特
4）4B/5B编码
数据-&gt;模拟信号
1）幅移键控（改变振幅，频率相位不变）
2）频移键控（改变频率，振幅相位不变）
3）相移键控（改变相位，振幅频率不变)
4) 正交振幅调制
PCM ：抽样，量化，编码
}
6.电路交换
{
连接建立。数据传输，连接释放
关键点：在数据传输过程中，用户始终占用端到端的固定传输带宽。
优点：
1.通信时延小
2.有序传输
3.没有冲突
4.适用范围广
5.实时性强
6.控制简单
缺点：
1.建立连接时间长
2.线路独占
3.灵活性差
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25ebdbc416665bd5c483db39474cb205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/010a8c4b40816b86fc9cc039f8abf0e5/" rel="bookmark">
			5G中非正交多址接入技术（NOMA）是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我，菜拐拐，今天又来了！今天的笔记是关于非正交多址技术（NOMA），就大体康康&gt;==&lt;啊！
5G中非正交多址接入技术（NOMA）是什么？ NOMA的简要介绍？由频分多址到NOMA的发展（原理）？*给定例子来说明功率分配对每一个用户的吞吐量的影响* NOMA的分类(大类单载波和多载波)？NOMA中的关键技术？参考？ NOMA的简要介绍？ 在正交多址技术中，只能为一个用户分配单一的无线资源，例如按频率分割或按时间分割。然而，非正交多址技术（NOMA）方式可将一个资源分配给多个用户。在某些场景中，比如远近效应场景和广覆盖多节点接入的场景，特别是上行密集场景，采用功率复用的非正交接入多址方式较传统的正交接入有明显的性能优势，更适合未来系统的部署。其优点是可以提高频谱效率和接入量，这恰好符合了即将到来的5G时代的爆炸性的数据增长和接入需求。目前已经有研究验证了在城市地区采用NOMA的效果，并已证实，采用该方法可使无线接入宏蜂窝的总吞吐量提高50%左右。非正交多址复用通过结合串行干扰消除能取得容量极限，因此技术实现的难点在于是否能设计出低复杂度且有效的接收机算法。其解决的问题是：频谱短缺。 由频分多址到NOMA的发展（原理）？ 正交频分复用技术（OFDM）是在频分复用(FDMA)的基础上进一步压缩频带，提高频谱利用率。 LTE系统的视频资源结构，时间上每个单位叫做一个OFDM符号，频域上每个单位叫做一个子载波。LTE系统可以同时利用时域和频域进行区分用户。 NOMA跟以往的多址接入技术不同，NOMA采用非正交的功率域来区分用户。所谓非正交就是说用户之间的数据可以在同一个时隙，同一个频点上传输，而仅仅依靠功率的不同来区分用户。NOMA在发送端采用非正交发送（叠加编码），主动引入干扰信息，在接收端通过串行干扰删除技术实现正确解调。借此，在相同的时频资源块上，通过不同的功率级在功率域实现多址接入。NOMA在发送端根据对信道传输质量的评估来分配用户发射功率的非正交发送，主动引入干扰信息。对信噪比高的信道分配较小的功率，对信噪比低的信道分配较大的功率。在接收端通过SIC接收机消除干扰，实现正确解调。 给定例子来说明功率分配对每一个用户的吞吐量的影响 看下行链路中串行干扰删除接收机采用NOMA方案的示意图，有一台发射机，两台接收机，并且每个接收机有一个接收天线。系统带宽1hz，基站发送一个信号x，给两个用户发送的功率为x1,x2，采用叠加编码即 x = P 1 x 1 + P 2 x 2 x = \sqrt {{P_1}} {x_1} + \sqrt {{P_2}} {x_2} x=P1​ ​x1​+P2​ ​x2​。每个用户收到的信号为： y i = h i x + w i {y_i}={h_i}x+{w_i} yi​=hi​x+wi​。在下行链路，SIC由用户接收机完成，当其他用户解码后，便可以将对本用户的干扰消除，本用户便可以成功解码。以两个用户为例子在满足：先解调出第二个用户的信号，使用y1减去第二个用户的成分，因此，第一个用户可成功解码。信息速率在这里代表吞吐量，则可以表示为：由此可见，功率分配对对于每一个用户的吞吐量都有着很大的影响。 NOMA的分类(大类单载波和多载波)？ 单载波非正交多址技术指的是较早提出的，利用单个载波传输多个用户信号的非正交多址技术，包括传统的功率叠加非正交多址和认知无线非正交多址。功率叠加非正交多址和认知无线非正交多址利用功率的不平衡分配来区分用户，实现多用户并行传输。
功率叠加非正交多址
功率叠加非正交多址技术的本质是将更多的发送功率分配给信道条件更差的用户。检测时，用户1将用户2视为噪声，首先检测出自己的信号。用户2则利用串行干扰抵消技术，先检测出用户１的信号，再将它从原始接收信号中减去，最后得到自身信号。 认知无线非正交多址
传统功率叠加非正交多址技术为了保障用户的公平性，为信道条件较差的用户分配更多的功率。然而，它并不能严格保证每个用户预期的服务质量。认知无线非正交多址CR-NOMA技术对功率叠加非正交多址技术进行了优化和改进，严格确保所有用户的QoS需求得到满足。其思想是将非正交多址看作认知无线的特例，设计相应的功率分配策略去满足用户预定的QoS需求。其主要优势体现在能尽可能满足所有用户的QOS需求。假设用户１是一个物联网设备，速率需求相对较低，而用户2却有很高的速率需求，传统的正交多址接入系统（如OFDMA）会为每个用户分配一个相同带宽的子载波。这样，用户１所分配到的带宽比它的实际需求大，而用户2分配的带宽则不足以满足其需求。使用CR-NOMA技术则不仅可以使用户1的目标QoS需求得到满足，还尽可能地将剩余的频带资源与额外用户（用户2）共享，从而提高整个系统的吞吐量。满足所有用户的QoS需求。 多个子载波并行传输各用户信号以提高系统容量，并利用对传统多用户信号检测算法的改进，提升整个系统的性能。
交织多址接入技术
它基于不同的码片交织器来区分每个用户，以此获得分集增益，抵抗深度衰落。如图所示，在发送端，其先对每个用户的编码比特依次进行扩频、码片交织和符号调制，最后将所有用户的调制符号叠加在同一物理资源块上。在接收端，先利用高斯近似算法对接收信号进行低复杂度检测，然后将得到的各用户编码比特的软信息进行解交织和解扩频，最后通过译码器进行译码，得到原始信息比特。 稀疏码多址接入技术
将用户信息按组稀疏地叠加到有限的物理资源块上，同组用户共享相同的时频资源。也正因为这样，SCMA相较于传统的正交多址接入系统拥有更高的吞吐量，能够同时服务于更多用户，满足5G大连接的需求。 如图2-6所示，在发送端，SCMA系统先将每个用户的二进制编码比特直接映射成复数域上的码字，再根据预定好的用户分组将这些码字以稀疏的方式叠加到相应的时频资源上。由图可知，同一物理资源块将复用多个用户的码字信息，这也正是SCMA提高吞吐率的关键。在接收端，利用消息传递或串行干扰抵消等低复杂度非线性检测算法对叠加信号进行检测，并结合译码器恢复出每个用户的信息比特序列。 图分多址接入技术
PDMA在相同时频域资源块内，对每个用户的信号在编码域、空域和功率域进行联合或单独的编码传输，能够有效提高频谱效率，增加接入用户数，进而提高整体系统性能。
在发送端，PDMA先将用户分组，然后确定扩频图样，最后将用户按组叠加在有限时频资源块上进行传输。在接收端，PDMA通过串行干扰抵消技术逐一检测用户信息，并将得到的编码比特信息送入译码器进行译码，最终恢复原始信息比特序列。与其他非正交多址技术相同，PDMA也能有效提高系统的频谱效率，提升用户接入数量，扩大系统的吞吐量。与SCMA不同，PDMA的扩频图样更具有灵活性。一方面，每一个物理资源块上叠加的用户数可以不同；另一方面，每个用户信息传输时所连接的时频资源块也并未受到稀疏特性的限制，负载度相对更高。PDMA多用户编码矩阵为例，表示在三个时频资源单位上传输五个用户的信息，映射关系为：
由式可知，PDMA多用户编码矩阵不同列之间的汉明重量和稀疏特性不同，不同行之间的多用户数目应尽量一致，但并未做严格要求。
NOMA中的关键技术？ 串行干扰删除（SIC）
在接收信号中对用户逐个进行判决，进行幅度恢复后，将该用户信号产生的多址干扰从接收信号中减去，并对剩下的用户再次进行判决，如此循环操作，直至消除所有的多址干扰。
功率复用
SIC在接收端消除多址干扰（MAI），需要在接收信号中对用户进行判决来排出消除干扰的用户的先后顺序，而判决的依据就是用户信号功率大小。基站在发送端会对不同的用户分配不同的信号功率，来获取系统最大的性能增益，同时达到区分用户的目的，这就是功率复用技术。功率复用技术在其他几种传统的多址方案没有被充分利用，其不同于简单的功率控制，而是由基站遵循相关的算法来进行功率分配。
参考？ 知网文章《非正交多址系统信号叠加与检测技术研究》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/010a8c4b40816b86fc9cc039f8abf0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58963fe81d5703faf3ad7a716df6f79d/" rel="bookmark">
			zoom in   zoom out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zoom in 和baizoom out是摄像du技术用语。
zoom in 指（照相机等）用变zhi焦距镜头使景物dao放大，即将景物推近；
zoom out刚好相反，表示用变焦距镜头使景物缩小，即将景物拉远。
摘抄自：
https://zhidao.baidu.com/question/559641809087391764.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d5d8a74ce1c897e637f40afb46c6e0c/" rel="bookmark">
			Idea使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装:只选一个X64，其余一路next
使用：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d77149f1615aafdf1185ab4ad33f09/" rel="bookmark">
			Linux的目录挂载详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		挂载的基本概念 前面讲过，Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。
因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。
挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。
纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此，挂载新增设备，根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。
举个例子，我们想通过命令行访问某个 U 盘中的数据，图 1 所示为 U 盘文件目录结构和 Linux 系统中的文件目录结构。
图 1 中可以看到，目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。
接下来，我们在根目录下新建一个目录 /sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录，挂载效果如图 2 所示。
可以看到，U 盘文件系统已经成为 Linux 文件系统目录的一部分，此时访问 /sdb-u/ 就等同于访问 U 盘。
前面讲过，根目录下的 /dev/ 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件（比如 sdb1），就位于 /dev/ 目录下（/dev/sdb1），但无法通过 /dev/sdb1/ 直接访问 U 盘数据，访问此目录只会提供给你此设备的一些基本信息（比如容量）。
总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载。
系统的磁盘挂载 如果我们新建VMware虚拟机，分配了2核CPU，2G内存，20G 磁盘存储，新装一个CentOS系统。系统装好后，默认会产生一个以“/” 为根目录的目录结构。那么我们划分的磁盘是如何与目录对应的呢？这就是磁盘挂载。
根目录下的子目录可以挂载磁盘，但是不一定都需要挂载。如果安装CentOS系统时，默认不做分区的话，所有磁盘会挂载在根目录。
1、使用df -h 可以查看到磁盘挂载的详细情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d77149f1615aafdf1185ab4ad33f09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea356a93dc64a97ed392f26778f0cb77/" rel="bookmark">
			unity 2019_现在接受报名参加$ 25K Unity for Humanity 2019挑战赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity 2019
We’re happy to announce that the annual Unity for Humanity Challenge is now open for submissions!
我们很高兴地宣布，年度人类团结挑战赛现已开始接受报名！ As our world evolves at a rapid rate, Unity creators are developing projects and tools that have a positive and meaningful impact on our planet. Whether they touch on social, healthcare, science, education, humanitarian or environmental issues, we see inspirational content being created and shared every day.
随着我们世界的快速发展，Unity的创造者正在开发对我们的星球产生积极而有意义的影响的项目和工具。 无论他们涉及社会，医疗保健，科学，教育，人道主义还是环境问题，我们每天都在创作和分享鼓舞人心的内容。 The Made with Unity team created this initiative because our mission is to celebrate inspiring, innovative, and pioneering content – and sometimes our creators need a little financial support.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea356a93dc64a97ed392f26778f0cb77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96635a4d07bb03fac54fa2bce65f345b/" rel="bookmark">
			校验List集合中的对象属性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景需求 controller接收参数是一个List&lt; User &gt;的集合，需要校验User中的name，password等属性。
之前操作 实体类上加@NotNull和@Pattern注解
public class BizAgentRewardInfo extends BaseEntity { /** * 主键 */ private Long ruleId; /** * 收益类型 */ private String ruleType; /** * 级别 */ @NotBlank(message = "级别不能为空") @Pattern(message = "请输入数字",regexp = "^[0-9]*$") private String ruleLevel; /** * 最低值 */ @NotNull(message = "最低值不能为空") private Integer ruleMin; /** * 最高值 */ @NotNull(message = "最高值不能为空") private Integer ruleMax; /** * 比率 */ @NotNull(message = "比率不能为空") private BigDecimal ruleRatio; 但是对象被List包裹后，校验不生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96635a4d07bb03fac54fa2bce65f345b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c72c5951c460cacc2730c090e4db0ad/" rel="bookmark">
			3种 Springboot 全局时间格式化方式，别再写重复代码了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间格式化在项目中使用频率是非常高的，当我们的 API 接口返回结果，需要对其中某一个 date 字段属性进行特殊的格式化处理，通常会用到 SimpleDateFormat 工具处理。
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); Date stationTime = dateFormat.parse(dateFormat.format(PayEndTime())); 可一旦处理的地方较多，不仅 CV 操作频繁，还产生很多重复臃肿的代码，而此时如果能将时间格式统一配置，就可以省下更多时间专注于业务开发了。
可能很多人觉得统一格式化时间很简单啊，像下边这样配置一下就行了，但事实上这种方式只对 date 类型生效。
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 而很多项目中用到的时间和日期API 比较混乱， java.util.Date 、 java.util.Calendar 和 java.time LocalDateTime 都存在，所以全局时间格式化必须要同时兼容性新旧 API。
看看配置全局时间格式化前，接口返回时间字段的格式。
@Data public class OrderDTO { private LocalDateTime createTime; private Date updateTime; } 很明显不符合页面上的显示要求（有人抬杠为啥不让前端解析时间，我只能说睡服代码比说服人容易得多~）
未做任何配置的结果 一、@JsonFormat 注解 @JsonFormat 注解方式严格意义上不能叫全局时间格式化，应该叫部分格式化，因为@JsonFormat 注解需要用在实体类的时间字段上，而只有使用相应的实体类，对应的字段才能进行格式化。
@Data public class OrderDTO { @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd") private LocalDateTime createTime; @JsonFormat(locale = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c72c5951c460cacc2730c090e4db0ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f0c9c012e27346f0683af3610c22ee/" rel="bookmark">
			Element Ui 修改MessageBox内容（图片&#43;文字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Element Ui 修改MessageBox内容（图片+文字） 效果图：
核心代码：
const Url = require("图片路径"); this.$confirm("&lt;img src=" + Url + "&gt;&lt;p&gt;确定删除此用户？&lt;/p&gt;", "提示", { dangerouslyUseHTMLString: true, customClass: 'messageBox_class', confirmButtonText: "确定", showCancelButton: false, type: "warning" }) css样式：
可根据自己需求，这个只是上面效果图的样式而已。
// MessageBox样式修改 .messageBox_class { width: 540px; .el-message-box__header { background: #f1f2f6 !important; } .el-message-box__headerbtn .el-message-box__close { color: #3a3d46; } .el-message-box__status.el-icon-warning { display: none; } .el-message-box__status + .el-message-box__message { padding: 0; margin: 0; } .el-message-box__message p { text-align: center; color: #3a3d46; margin-top: 10px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f0c9c012e27346f0683af3610c22ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b140c125c8016b22e40fc02061469b6/" rel="bookmark">
			文件的读写基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件是计算机中数据持久化存储的表现形式 读写文件标准操作格式1：
1、打开文件：file1 = open('文件名','读写模式') 2、操作文件 3、关闭文件：file1.close() 文件操作完毕后必须关闭，否则长期保持对文件的连接状态，造成内存溢出的现象发生
读写文件操作格式2：
# 1、打开文件 file1 = open('demo.txt','w') # 2、操作文件 file1.write('hello world') # 3、关闭文件 file1.close() 1、打开文件：with open('文件名','读写模式') 2、操作文件 3、关闭文件：（自动关闭文件） #1、打开文件 with open ('dmeo2.txt','w') as file1: #2、操作文件 file1.write('hello python') #3、关闭文件，用 with open是免关闭文件的 二、文件读写模式 读写模式功能r读取文件内容数据w对文件进行数据写入a对文件内容数据进行追加 文件不存在文件存在( r ) 出现异常读取文件内数据(w) 自动创建新文件，并且写入内容数据覆盖原文件内数据，重新写入( a ) 自动创建新文件，并且写入内容数据在原文件内容最后进行数据的追加，并不覆盖 文件不存在的情况下，新建文件，然后将内容写入：
with open('demo3.txt','w') as file: file.write('hey') 文件存在的情况，里面的内容会进行一个覆盖：
with open('demo6.txt','w') as file: file.write('hey-hey-hey') a模式 ‘a’ append 追加 文件不存在的情况下（新建了一个文件，将内容写入）：
with open('d.txt','a') as file: file.write('lll-lll-lll') 文件存在的情况下（在最后追加内容）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b140c125c8016b22e40fc02061469b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b101cd8fc66b57778daa16bd0f75c5f1/" rel="bookmark">
			printf的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要了解变参函数的实现，首先我们的弄清楚几个问题：
1: 该函数有几个参数。
2: 该函数怎样去访问这些参数。
3: 在访问完成后，如何从堆栈中释放这些参数。
函数变参 对于c语言，它的调用规则遵循_cdedl调用规则。 在_cdedl规则中：
1. 参数从右到左依次入栈
2. 调用者负责清理堆栈
3. 参数的数量类型不会导致编译阶段的错误
printf的声明： int _cdecl printf(const char* format, …); // _cdecl是C和C＋＋程序的缺省调用方式
栈由高地址向低地址生长，又参数从右到左依次入栈，所以栈的高地址是printf最右边的参数。以
printf("%d %f %c %s\n", 3, 5.40, A, "hello world");为例，其栈的结构如下：
在被调用的函数内部我怎么知道变参的类型是什么呢？对于printf函数来说，调用者通过第一个fmt参数中的%+格式字符的方式通知了被调用者（printf的实现者）。
格式解析 扫描format参数里的字符，如果是普通字符就打印输出，如果是%，就说明后面有可能是格式字符，需要进行检测，然后从栈低（其实是第一个参数的位置）弹出指定类型的数据，按照指定格式（十进制、十六进制、指定宽度、指定精度等等）进行输出。基本上是一个字符串解析的过程。
typedef char *va_list;
#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) ) /* 1 */
#define va_start(va_list ap, format) ( ap = (va_list)&amp;format+ _INTSIZEOF(format) ) /* 2 */ #define va_arg(va_list ap,type) ( *(type*)((ap += _INTSIZEOF(type)) -_INTSIZEOF(type)) ) /* 3 */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b101cd8fc66b57778daa16bd0f75c5f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c812f084491ce1df3c4c6977c42ac9/" rel="bookmark">
			Python爬虫——片库网 爬取 视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		片库url：http://tv.cnco.me/
一、进入网站
二、输入关键字跳转界面
格式：
url = "http://tv.cnco.me/" search_keyword = '脱单告急' search_url = url + "vodsearch/-------------.html?wd=" + search_keyword + '&amp;submit=' 三、点击立即播放进入播放界面
导入BeautifulSoup模块
获取该视频的网址：在上个界面按下F12，利用查看器点击立即播放。得到播放网站
url = "http://tv.cnco.me/" search_keyword = '脱单告急' search_url = url + "vodsearch/-------------.html?wd=" + search_keyword + '&amp;submit=' def find_url(search_url): r = requests.get(search_url) r.encoding = 'utf-8' html = r.text bs = BeautifulSoup(html, 'lxml') search_bs = bs.find_all(class_='margin-0') href = "" for s in search_bs: if s.a: print(s.a) href = s.a['href'] dst_url = url + href return dst_url 在播放页面按下F12，点开网络选项，看到传输的视频格式为m3u8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c812f084491ce1df3c4c6977c42ac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94cfadbad9a54c59ffd4cc6b24d1848e/" rel="bookmark">
			opencascade 提取mesh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Builds the mesh of a shape with respect of their correctly triangulated parts.
#include &lt;BRepMesh_IncrementalMesh.hxx&gt;
网上资源很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031c3f37707ad3c0aeb5b75e653f033d/" rel="bookmark">
			vue  element tabs   选项卡刷新页面默认到当前位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		data 里定义
activeName：1 默认第一个
creade created() {
this.getLocket()
},
methods{
getLocket() {
if(localStorage.getItem('user') !== null){
this.activeName = localStorage.getItem('user')
}
},
handleClick(tab,event) {
localStorage.setItem("user",tab.name)
},
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ad7744d8d6e39726f3fd3e4bd80429/" rel="bookmark">
			【seeprettyface.com】开源源码：PULSE-for-chs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PULSE-for-chs 项目内容 在做人脸超分任务的时候，发现PULSE的结果不是很接地气，超分的结果经常变成欧美人的样貌。这个Github提供的模型对生成脸域做了黄种人限制，使得超分的结果都是黄种人。另外附赠了一个明星脸域的生成器（纯属好玩）。
Github link: https://github.com/a312863063/PULSE-for-chs 。
效果展示 黄种人脸投射器 矫正对比 第1行：输入；第2行：PULSE输出；第3行：黄种人投射器输出。
单幅输出 输入（32x32）
⬇
输出（1024x1024）
赠品：明星脸投射器 输入（32x32）
⬇
输出（1024x1024）
（虽然和真实明星的人脸有一定差距，但这不失为解决特定领域人脸超分任务的一种思路）
Usage The main file of interest for applying PULSE is run.py. A full list of arguments with descriptions can be found in that file; here we describe those relevant to getting started.
Prereqs You will need to install cmake first (required for dlib, which is used for face alignment). Currently the code only works with CUDA installed (and therefore requires an appropriate GPU) and has been tested on Linux and Windows.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ad7744d8d6e39726f3fd3e4bd80429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c04393f5678311e18448dd19a529aa3/" rel="bookmark">
			Python爬虫抓包工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python爬虫抓包工具使用 一. 常用的工具 pythonpycharm浏览器chrome火狐fiddler2 fiddler的使用 二. 操作界面 三.界面含义 1. 请求 (Request) 部分详解 2. 响应 (Response) 部分详解 四. 设置 1. 如何打开 启动Fiddler，打开菜单栏中的 Tools &gt;Options，打开“Fiddler Options”对话框
2. 设置 Capture HTTPS CONNECTs 捕捉HTTPS连接Decrypt HTTPS traffic 解密HTTPS通信Ignore server certificate errors 忽略服务器证书错误all processes 所有进程browsers onlye 仅浏览器nono- browsers only 仅非浏览器remote clients only 仅远程链接
Trust Root Certificate(受信任的根证书) 配置Windows信任这个根证书解决安全警告
Allow remote computers to connect 允许远程连接Act as system proxy on startup 作为系统启动代理resuse client connections 重用客户端链接 五. 捕获链接(抓包) 1. 安装SwitchyOmega 代理管理 Chrome 浏览器插件 选择下载后解压的文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c04393f5678311e18448dd19a529aa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1453956917dd8070442cdc4d007a3113/" rel="bookmark">
			经典面试题: for循环setTimeout取值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经典面试题: for循环setTimeout取值 问题： 以下代码 console 出来的值是什么
const arr = [1,2,3] for (var val of arr) { setTimeout(()=&gt; { console.log('setTimeout:', val) }, 3000) } 可能你会说：3秒之后控制台输出 1 2 3
但这么想是 错的
实际上输出的是 3个3
让我们再来加一层console试一下
看下setTimeout外层是不是也这样
const arr = [1,2,3] for (var val of arr) { console.log('for:', val) setTimeout(()=&gt; { console.log('setTimeout:', val) }, 3000) } 返回的结果
setTimeout外面依次返回了1 2 3
然后3秒后返回了3个3
也就是说都是返回的数组的最后一项
因为定义了一个 val 变量，
for循环的时候后面的值把前面的值覆盖了，
由于setTimeout是异步的，
所以setTimeout输出console的时候覆盖操作已经发生了。
这不是智障小儿科，
这确实是一道经典面试题，
很多大公司都会问到，
我自己就经历过2次，
希望能对看到这篇帖子的你有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ccfcb37e405bc46c66424ffc43afc9b/" rel="bookmark">
			在DLL 中输出调试信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在C++ dll 中使用printf输出调试信息，可能会出现输出信息不及时的问题（尤其是在C#项目中），可以使用OutputDebugString 函数代替。这里为了方便，将OutputDebugString封装成一个函数，顺便支持不定长参数和时间打印，便于使用。
#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; void ShowDbgInfo(const char* data, ...) {	char temp[2048]; if (!logFile) { logFile = fopen("debug.log", "w+"); } SYSTEMTIME st; GetLocalTime(&amp;st); sprintf(temp, "DLL日志输出: %d-%d-%d %02d：%02d：%02d：%03d ", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); OutputDebugStringA(temp); fprintf(logFile, "%s", temp); va_list ap; va_start(ap, data); vsprintf(temp, data, ap); OutputDebugStringA(temp); va_end(ap); fprintf(logFile, "%s \n", temp); fflush(logFile); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de178b1fca04b7027d38da3fb63f459/" rel="bookmark">
			qt   无法进入断点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突然有同事问我怎么qt进入不了断点，然后我就写这篇文章给后来者吧。
（1）在release模式下是无法进入断点的（目前我用的这个版本是这样，其他版本我不敢说，下同）
（2）如果使用的是运行模式（Ctrl+R，图标是三角形）也是无法进入断点的，
（3）只有在Debug模式（F5，图标是三角形加一只虫子，是不是虫子我不知道，暂且这么叫）下才会进入断点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec9c61e5fc470070d1d9ca12bb12fb78/" rel="bookmark">
			如何在Apple Watch上静音，管理和隐藏通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		One of the principle appeals of a smartwatch is easy wrist-based notifications but things can get a little out of control. Read on as we show you how to tweak your Apple Watch notifications to your liking.
智能手表的主要原理之一是基于手腕的轻松通知，但事情可能会有些失控。 请继续阅读，我们会向您展示如何根据自己的喜好调整Apple Watch通知。 Apple Watch通知如何工作？ (How Do Apple Watch Notifications Work?) Before we dive into actually managing your Apple Watch notifications, let’s run through a quick overview of how the notifications function by default so you’ve got a solid understanding of the notifications and what you may or may not want to modify.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec9c61e5fc470070d1d9ca12bb12fb78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0b3acb615e5cfd8c375af775242397/" rel="bookmark">
			idea显示Services工具栏方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Idea的Services窗口可以展示项目的入口引导类及端口，可以方便的启动及停止相关服务。
假如自己的idea里边不显示，可以通过一下方式解决：
1、找到自己.idea工作空间的workspace.xml文件
2、文件内搜索“RunDashboard”，假如不存在这个组件，则新增如下内容，否则修改为如下内容，修改完毕后，保存
&lt;component name="RunDashboard"&gt; &lt;option name="configurationTypes"&gt; &lt;set&gt; &lt;option value="SpringBootApplicationConfigurationType" /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name="ruleStates"&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name="name" value="ConfigurationTypeDashboardGroupingRule" /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name="name" value="StatusDashboardGroupingRule" /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt; &lt;/component&gt; 3、重启idea
4、重启完成后，idea右下角会出现services的弹窗， 打开选择第一个链接即可
IDEA中DashBoard不显示端口号解决办法 关闭所有java进程到 “C:\Users\用户名\AppData\Local\Temp\hsperfdata_用户名”目录下，将 “hsperfdata_用户名”文件夹删除。IDEA 重启一下，在Dashboard 中启动项目，则可以在DashBoard 中看到相应进程后面的端口号。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc919e46aae1c4fe584b992f4b0e1dd/" rel="bookmark">
			HPACK和twitter hpack源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HPACK和twitter hpack源码解析 HPACK是用于压缩HTTP/2中header信息的压缩算法。
引言 在HTTP/1.x中，header信息以字符串的方式进行传输，随着大量并发的网络请求，冗余的header字段会造成没必要的带宽浪费，从而增加网络时延。
HTTP/2的对这个问题进行了优化，它对header信息进行压缩编码，提高了的带宽利用率，其中的压缩编码规范就是HPACK。
HPACK中将 header 字段列表视为 name-value 对的有序集合，其中可以包括重复的对。名称和值被认为是八位字节的不透明序列，并且 header 字段的顺序在压缩和解压缩后保持不变。
Static Table Definition IndexHeader NameHeader Value1:authority2:methodGET3:methodPOST4:path/5:path/index.html6:schemehttp7:schemehttps8:status2009:status20410:status20611:status30412:status40013:status40414:status50015accept-charset16accept-encodinggzip, deflate17accept-language18accept-ranges19accept20access-control-allow-origin21age22allow23authorization24cache-control25content-disposition26content-encoding27content-language28content-length29content-location30content-range31content-type32cookie33date34etag35expect36expires37from38host39if-match40if-modified-since41if-none-match42if-range43if-unmodified-since44last-modified45link46location47max-forwards48proxy-authenticate49proxy-authorization50range51referer52refresh53retry-after54server55set-cookie56strict-transport-security57transfer-encoding58user-agent59vary60via61www-authenticate 从Static Table可以看出压缩的核心之一就是把http协议中常用的字符串用数字来代替，以此来减少header中的字节数。
编号的范围是1-61，很容易想到用一个8bit的byte来表示就可以了，但是实际上像1这种数字我们用1bit也可以表示，由此引入了霍夫曼编码，编码的作用就是使用频次高的数字用更少的字节来表示，这样可以使总体的字节数更少。
Dynamic Table Dynamic Table是可以看做是一个先进先出的队列，新加入的entry的index最小，最早的entry的index最大。
Dynamic Table初始是空的。当每个header块被解压缩时，将添加条目。Dynamic Table有容量限制，当容量不足以添加新的条目时会将按照最老的条目先移除的顺序移除条目，直到容量足够添加新的条目为止，如果新添加条目比Dynamic Table最大容量还要大，那么清空Dynamic Table。
Dynamic Table是针对一个连接的，因此HTTP/2提倡使用尽可能少的连接头，这样Dynamic Table会更全，头部压缩效果更好。
Index Address Space Static table和Dynamic Table组成了一个连续的地址空间，如下所示。
&lt;---------- Index Address Space ----------&gt; &lt;-- Static Table --&gt; &lt;-- Dynamic Table --&gt; +---+-----------+---+ +---+-----------+---+ | 1 | ... | s | |s+1| ... |s+k| +---+-----------+---+ +---+-----------+---+ ^ | | V Insertion Point Dropping Point Index Address Space Header Filed Representation 编码的header字段可以表示为index或者literal，index为static table或者dynamic table中的引用；header字段name可以用literal形式表示，也可以作为static table或者dynamic table中的引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc919e46aae1c4fe584b992f4b0e1dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d4d1758d4b47da42f7ad4869806936/" rel="bookmark">
			go-zero微服务框架入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么使用go-zero 你还在手撕微服务？快试试 go-zero 的微服务自动生成神器，这可能是我见过最简单好用的微服务框架。
还有比它更简单好用的吗？欢迎留言评论和推荐。
几分钟搞定个接口和微服务，还不用担心稳定性和高并发，这不香吗？还有比这更简单和高效的吗？
工具大于约定和文档的理念，编码自动化，大幅度的提高效率和生产力，这会是个趋势，让精力更多的放在业务和创新上。
推荐下go-zero 微服务框架，致力于打造国内最简单好用的框架。
为什么使用go-zero？
可以有第三个选择 golang圈子不大,微服务框架框架屈指可数:除了go-micro、go-kit,几乎没有其他选择。go-zero为此提供第三个可能。
go-micro 对webapi支持并不友好，需要运行micro指令,难以定制
需要一款支持业务成长的框架 我们到底需要什么样的框架?
我们需要一款可以支持业务成长的框架!产品运营初期,比如需求验证阶段，我们并不需要采取微服务架构，因为运营成本太高，一款单体应用足以应付。随着业务发展,微服务成为必要,此时我们又希望不进行太多的代码编写工作，柔性升级。这正是go-zero价值所在。
go-zero是什么 以下安利是copy的的，具体参考https://github.com/tal-tech/go-zero
go-zero是一个集成了各种工程实践的包含web和rpc框架，有如下主要特点：
强大的工具支持，尽可能少的代码编写
极简的接口
完全兼容net/http
支持中间件，方便扩展
高性能
面向故障编程，弹性设计
内建服务发现、负载均衡
内建限流、熔断、降载，且自动触发，自动恢复
API参数自动校验
超时级联控制
自动缓存控制
链路跟踪、统计报警等
高并发支撑，稳定保障了晓黑板疫情期间每天的流量洪峰
怎么用 在阅读本文档前,请将golang 升级到go14及以上版本,并开启go module支持,GO14以上只是为了支持Gorm
export GOPROXY=https://goproxy.io,direct export GO111MODULE=on 安装goctl goctl是go-zero配套的代码生成器,偷懒神器,毕竟写代码大多时间是体力活
如何安装呢?先把源代码下载下来吧!
git clone https://github.com/tal-tech/go-zero cd go-zero/tools/goctl go build goctl.go 最后生成goctl.exe 复制到$gopath/bin下
goctl指令说明 自行浏览文档吧https://github.com/tal-tech/go-zero/blob/master/tools/goctl/goctl.md
本文用到指令如下
goctl api go -api open.api -dir . #代码说明如下 goctl api go -api open.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5d4d1758d4b47da42f7ad4869806936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110f830bbcd36903acbb8b64be5df8c7/" rel="bookmark">
			C中printf函数的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、printf函数的实现原理 在C/C++中，对函数参数的扫描是从后向前的。C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf("%d,%d",a,b);（其中a、b都是int型的）的汇编代码
.section .data string out = "%d,%d" push b push a push $out call printf 你会看到，参数是最后的先压入栈中，最先的后压入栈中，参数控制的那个字符串常量是最后被压入的，所以这个常量总是能被找到的。
二、可变参数表函数的设计 标准库提供的一些参数的数目可以有变化的函数。例如我们很熟悉的printf，它需要有一个格式串，还应根据需要为它提供任意多个“其他参数”。这种函数被称作“具有变长度参数表的函数”，或简称为“变参数函数”。我们写程序中有时也可能需要定义这种函数。要定义这类函数，就必须使用标准头文件&lt;stdarg.h&gt;，使用该文件提供的一套机制，并需要按照规定的定义方式工作。本节介绍这个头文件提供的有关功能，它们的意义和使用，并用例子说明这类函数的定义方法。
C中变长实参头文件stdarg.h提供了一个数据类型va_list和三个宏（va_start、va_arg和va_end），用它们在被调用函数不知道参数个数和类型时对可变参数表进行测试，从而为访问可变参数提供了方便且有效的方法。va_list是一个char类型的指针，当被调用函数使用一个可变参数时，它声明一个类型为va_list的变量，该变量用来指向va_arg和va_end所需信息的位置。下面给出va_list在C中的源码：
typedef char * va_list; void va_start(va_list ap,lastfix)是一个宏，它使va_list类型变量ap指向被传递给函数的可变参数表中的第一个参数，在第一次调用va_arg和va_end之前，必须首先调用该宏。va_start的第二个参数lastfix是传递给被调用函数的最后一个固定参数的标识符。va_start使ap只指向lastfix之外的可变参数表中的第一个参数，很明显它先得到第一个参数内存地址，然后又加上这个参数的内存大小，就是下个参数的内存地址了。下面给出va_start在C中的源码：
#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) ) #define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) ) //得到可变参数中第一个参数的首地址 type va_arg(va_list ap,type)也是一个宏，其使用有双重目的，第一个是返回ap所指对象的值，第二个是修改参数指针ap使其增加以指向表中下一个参数。va_arg的第二个参数提供了修改参数指针所必需的信息。在第一次使用va_arg时，它返回可变参数表中的第一个参数，后续的调用都返回表中的下一个参数，下面给出va_arg在C中的源码：
#define va_arg(ap,type) ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)) ) //将参数转换成需要的类型，并使ap指向下一个参数 在使用va_arg时，要注意第二个参数所用类型名应与传递到堆栈的参数的字节数对应，以保证能对不同类型的可变参数进行正确地寻址，比如实参依次为char型、char* 型、int型和float型时，在va_arg中它们的类型则应分别为int、char *、int和double.
void va_end(va_list ap)也是一个宏，该宏用于被调用函数完成正常返回，功能就是把指针ap赋值为0，使它不指向内存的变量。下面给出va_end在C中的源码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/110f830bbcd36903acbb8b64be5df8c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2353f4ffa5cb393e2db9bc6592251c/" rel="bookmark">
			Vue中滚动插件vue-seamless-scroll的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm安装：
npm install vue-seamless-scroll --save 页面中引入组件：
import vueSeamlessScroll from 'vue-seamless-scroll' 页面中调用组件：
components: { vueSeamlessScroll }, 在页面的computed中定义变量
computed: { classOption () { return { step: 0.4, // 数值越大速度滚动越快 limitMoveNum: 8, // 开始无缝滚动的数据量 hoverStop: true, // 是否开启鼠标悬停 direction: 1, // 0向下 1向上 2向左 3向右 openWatch: true, // 开启数据实时监控刷新dom singleHeight: 0, // 单步运动停止的高度(默认值0是无缝不停止的滚动) direction =&gt; 0/1 singleWidth: 0, // 单步运动停止的宽度(默认值0是无缝不停止的滚动) direction =&gt; 2/3 waitTime: 1000 // 单步运动停止的时间(默认值1000ms) } } }, 页面中使用：
&lt;vue-seamless-scroll :data="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a2353f4ffa5cb393e2db9bc6592251c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd18398e0416b04cf27a8f5bcc6831f/" rel="bookmark">
			selenium 反爬虫之跳过淘宝滑块验证，这个有点难！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理问题的之前，给大家个第一个锦囊！ 你需要将chorme更新到最新版版本84，下载对应的chorme驱动 链接：http://chromedriver.storage.googleapis.com/index.html
注意 划重点！！一定要做这一步，因为我用的83的chorme他是不行滴，~~~~~~~
问题 1.一周前我的滑块验证代码还是可以OK的，完全没问题！附代码 low一眼
url = "https://login.taobao.com/member/login.jhtml" browser.get(url) browser.maximize_window() # 最大化 # 填写用户名密码 user = '*****' password = '*******' time.sleep(8) iframe = browser.find_element_by_xpath('//div[@class="bokmXvaDlH"]//iframe') print(iframe) browser.switch_to.frame(iframe) browser.find_element_by_xpath('//*[@id="fm-login-id"]').send_keys(id) browser.find_element_by_xpath('//*[@id="fm-login-password"]').send_keys(password) time.sleep(2) # 获取滑块的大小 span_background = browser.find_element_by_xpath('//*[@id="nc_1__scale_text"]/span') span_background_size = span_background.size print(span_background_size) # 获取滑块的位置 button = browser.find_element_by_xpath('//*[@id="nc_1_n1z"]') button_location = button.location print(button_location) # 拖动操作：drag_and_drop_by_offset # 将滑块的位置由初始位置，右移一个滑动条长度（即为x坐标在滑块位置基础上，加上滑动条的长度，y坐标保持滑块的坐标位置） x_location = span_background_size["width"] y_location = button_location["y"] print(x_location, y_location) action = ActionChains(browser) source = browser.find_element_by_xpath('//*[@id="nc_1_n1z"]') action.click_and_hold(source).perform() action.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd18398e0416b04cf27a8f5bcc6831f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/207/">«</a>
	<span class="pagination__item pagination__item--current">208/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/209/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>