<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9c43435a4ee156b3864e313d2a5692/" rel="bookmark">
			C#--序列化和反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化是指将对象转换成字节流，从而存储对象或将对象传输到内存、数据库或文件的过程。 它的主要用途是保存对象的状态，以便能够在需要时重新创建对象。 反向过程称为“反序列化”。
序列化的工作原理
下图展示了序列化的整个过程。
对象序列化
若要序列化对象，需要具有要序列化的对象、包含已序列化对象的一个流，以及一个 Formatter。
将 SerializableAttribute 特性应用于某个类型，以指示此类型的实例可以被序列化，具体做法在类之前加[Serializable]。
如果想让类中的某个字段不可序列化，请应用 NonSerializedAttribute 特性，具体做法在字段之前加[NonSerialized]。
C#代码实现：
using System; using System.IO; using System.Runtime.Serialization.Formatters.Binary; namespace NetFrame { public class SerializeUtil { /// &lt;summary&gt; /// 对象序列化 /// &lt;/summary&gt; /// &lt;param name="value"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static byte[] Encode(object value) { //创建编码解码的内存流对象 MemoryStream ms = new MemoryStream(); //二进制流序列化对象 BinaryFormatter bw = new BinaryFormatter(); //将obj对象序列化成二进制数据 写入到 内存流 bw.Serialize(ms, value); byte[] result = new byte[ms.Length]; //将流数据 拷贝到结果数组 Buffer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9c43435a4ee156b3864e313d2a5692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d84badf4d04f9ab74a55f49e3fecad9c/" rel="bookmark">
			response设置响应头，解决跨域请求问题，No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天被跨域请求的问题困扰了很久，跨域一句话的理解就是：服务端和请求端的地址不一样。
跨域的详细介绍可以参考：浏览器和服务器实现跨域(CORS)判定的原理，这里不多赘述。
我出现的问题，主要就是客户端向发送了服务端请求，服务器已经能返回数据，但是浏览器不接收。
Failed to load http://localhost:8080/XXXX: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:8081' is therefore not allowed access. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.
英语不是很好，根据翻译报错的内容大概就是：
未能加载这个地址（http://localhost:8080/XXXX）请求的资源，因为没有“Access-Control-Allow-Origin”这个响应头。因此，访问源（http://localhost:8081）不被允许接收这个资源。如果这个资源是你需要的，请将请求的模式设置为“no-cors”，以获取与CORS禁用的资源。
也就是说，从报错的内容来看，大概能有两种方式可以解决这个问题，一个是在服务器端设置这个响应头，第二就是设置CORS。但是对于初入门的小白来说，能有一个方法解决就已经很不错了。当然，网上找了一些资料，方法非常多，但是那些精髓的内容，我等小白实在参不透，没一个知道具体怎么用上去的。
后来在一位群里请教了一位大神，大神的回复也是比较简短：
“好像是在服务端的request设置ContentType可以解决”
我都快要哭了，好在都在群里，能继续追问，我马上截图服务端的代码给大神参考
等了一会，大神让我加上这个：
this.response.setHeader("Access-Control-Allow-Origin", "*");
this.response.setHeader("Cache-Control","no-cache"); 生硬地加上去肯定是报错的：
而后我思考了一会，以前学Servlet的时候，doGet和doPost里面request和response基本都是成对出现的，所以我这里就加上了HttpServletResponse response，最后如下图所示，跨域访问可总算解决了。
为了感谢大神，我把QQ钱包仅剩的6.21元贡献了出来（原本想发6.66，结果不够钱），对大神表示诚挚的感谢！
其实，当自己这个流程走通了之后，有些地方自然就会明白了。我后端的代码是从其他的地方学习的，方法始终是死的，人是活的，这段代码只有request，没有response，因为request是处理客户端的请求等等，而当地址一样的时候自然不会出现跨域的问题。当理解了request是处理请求，response是返回结果，其实问题也就简单多了。
2018-05-17 更新：
最后发现，如果是使用Spring Boot创建的项目，直接添加一句注解到controller和方法就可以了。
@CrossOrigin 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a6dd67c27976797e4c442fc0c7ec70/" rel="bookmark">
			解决twaver 引起的文本不可复制问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、问题：
easyUi treegrid 放置于 twaver页面后 树表单元格中文本的复制功能消失；
treegrid不在Network中 而是borderPane中， 树表的checkbox可以勾选，单击行的时候也可以高亮显示，只是单元格内的文本不可右键复制
二、分析：network是在canvas上的，有可能会将treegrid覆盖，只能显示，但是无法操作。
因为treegrid中继承了父元素的设置：user-select : none;
三、解决：
在对应wrapper中添加下面这行css代码，即可重现复制功能：
-moz-user-select : text; user-select : text; 然后修改光标的显示样式，整体代码如下：
div{ /* 解决treegrid单元格中文本不能复制的问题 */ -moz-user-select : text; user-select : text; cursor:auto;/*修改光标的显示样式*/ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48746314bed45ec678f6971b313a8550/" rel="bookmark">
			android使用logwrapper进行log重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android有一些应用程序的日志输出是通过printf之类的标准函数输出的，这类log是无法记录到的。主要是由于init进程会把0,1,2三个fd指向到/dev/null，而其他进程都是由init fork出来的，所以标准输出和标准错误输出都会继承自父进程，所以默认也都是不打印出来的。
android init的实现在system/core/init/init.c中：
int main(int argc, char** argv) { ...... // At this point we're in the second stage of init. InitKernelLogging(argv); LOG(INFO) &lt;&lt; "init second stage started!"; ...... } init会执行log初始化动作，也就是把所有的标准输入标准输出和标准错误输出都指向/dev/null：
void InitKernelLogging(char* argv[]) { // Make stdin/stdout/stderr all point to /dev/null. int fd = open("/sys/fs/selinux/null", O_RDWR); if (fd == -1) { int saved_errno = errno; android::base::InitLogging(argv, &amp;android::base::KernelLogger); errno = saved_errno; PLOG(FATAL) &lt;&lt; "Couldn't open /sys/fs/selinux/null"; } dup2(fd, 0); dup2(fd, 1); dup2(fd, 2); if (fd &gt; 2) close(fd); android::base::InitLogging(argv, &amp;android::base::KernelLogger); } android中提供了logwrapper程序用来重定向log的输出，重定向的log可以使用logcat查看，我们来看下他的实现机制又是怎样的呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48746314bed45ec678f6971b313a8550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ab531ee8f8ee917b86a135cbdfc0f1/" rel="bookmark">
			线性代数导读&#43;总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些学习线性代数的心得和资源分享，供大家参考。
资源 Introduction to Linear Algebra, Fifth Edition 学线性代数主要的参考书，Strang 教授也算是网红了，讲课讲得十分浅显易懂，网上有配套的video，强烈推荐。
线性代数2
清华马辉老师的线性代数慕课，讲法比较传统，但课件很清晰，不太需要看video也能看懂。
这主要是针对相似矩阵、SVD、PCA、伪逆等矩阵论的内容，是传统线性代数的很好补充。
数值线性代数
这本书主要介绍解的问题，以及在现实中如何求解大型系数矩阵的逆、特征值以及一些迭代的方法。
如何理解线性代数 不得不说，对于我来说，线性代数一直是很头疼的。这种头疼不在于说计算特征值、求PCA有多么多么复杂；而是自己一直没有办法直观理解矩阵是什么、向量又是什么、矩阵乘法为什么这么定义、特征值代表什么。我想这些问题也同样困扰着学习线性代数的很多同学。
因此我整理了一些学习中对我有收获的资料，也便于自己复习：
知乎上的讨论：如何理解线性代数？科普类视频：线性代数的本质据说很好的教材，自己也还没看：Linear Algebra Done RightCSDN上关于矩阵的理解，适合Review：理解矩阵 Jon Shlens大神写的PCA tutorial：Tutorial on Principal Component Analysis 笔记 自己总结了学习线性代数中最基本和最重要的知识点：
矩阵的四个基本子空间 介绍四个基本子空间的概念，非常重要。
基本子空间的正交性及性质 引出子空间正交的性质，以及矩阵的秩。
向量投影 投影的概念以及投影矩阵。
最小二乘法 很巧妙的用向量投影的角度重新认识最小二乘法。
Gram-Schmidit正交化 介绍Schmidit正交化方法，以及QR分解。
行列式 介绍矩阵行列式的概念。
特征向量 介绍特征值与特征向量，以及矩阵对角化。
矩阵的对角化 介绍对角化条件、几何重数与代数重数与应用。
特征值在微分方程中的应用 这里利用特征值将矩阵和微分方程联系在一起。
实对称矩阵 介绍Schur定理以及实对称矩阵的特殊性质。
正定矩阵理解及推导 特征值的应用：正定矩阵以及半正定矩阵的充要条件和性质。
二次型与函数极值 如何将数值函数用矩阵表示，并使用正定矩阵来指示函数的极值。 PageRank问题建模 大规模稀疏矩阵。
范数与矩阵条件数 这一讲进入矩阵论，讨论矩阵更深层次的问题和性质。
SVD分解 谱分解、Schur定理、SVD推导。
理解PCA 从协方差矩阵、仿射变换理解PCA。
SVD通俗理解 更直观的理解SVD。
线性变换与基变换 更好的理解矩阵以及矩阵乘法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6356ecb9f1df14118109f8f416f566f8/" rel="bookmark">
			Spring Boot基础教程：使用spring-data-jpa-h2进行数据访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 本节讲解如何使用spring-data-jpa来访问数据，通过内存数据库h2来存储数据。在这个过程中，我们将了解到： spring-data-jpa的特点和强大之处如何使用内存数据库h2 2. 环境要求 使用环境参考Spring Boot基础教程汇总中的讲解：详情请点击
3. 快速开始 使用maven构建项目 项目结构如下： └─src ├─main │ ├─java │ │ └─com │ │ └─qingtian │ │ ├─entity │ │ └─service │ └─resources └─test └─java └─com └─qingtian pom.xml，特别注意，其中spring-boot-starter-data-jpa和h2 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qingtian&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-jpa-h2&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-jpa-h2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6356ecb9f1df14118109f8f416f566f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259b5b71920a8accdcc9045ec4af31ff/" rel="bookmark">
			Python中的split()函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		split()：拆分字符串。
通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）
语法：str.split(str="",num=string.count(str))[n]
参数说明：
str:表示为分隔符，默认为空格，但是不能为空('')。若字符串中没有分隔符，则把整个字符串作为列表的一个元素
例如：s.split('')是不合法的表达 num:表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串，并且每一个子字符串可以赋给新的变量 [n]:表示选取第n个分片
注意：当使用空格作为分隔符时，对于中间为空的项会自动忽略
split()当不带参数时以空格进行分割（不管几个空格全部砍掉），当代参数时，以该参数进行分割。
例如：
不同参数示例：
1）以'.'为分隔符
2）分割一次
3）分割两次，取第一个分片（序号为0）
4) 分割两次，并把分割后的三个部分保存到三个变量中
5）一个小应用
6）一个有趣的例子
收到二楼大神的指教在这里略作说明，对于分隔符出现在首尾的情况，在首尾处分割，会产生同一个空串，对于出现在字符串中间的情况，单独出现，和普通情况没有区别，如果出现多个，两个分隔符中间就会产生一个空串。
第一次写博客，不足之处希望大家指正啊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86de6fc08fb13b6dc55e36be423f4769/" rel="bookmark">
			AccessibilityService自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现AccessibilityService自启动的方法
说明：自定义AccessibilityService时，默认关闭的，需要在无障碍界面手动打开。若需自动打开有两种方法。
1.源码中修改
frameworks\base\packages\SettingsProvider\src\com\android\providers\settings\DatabaseHelper.java 在loadSecureSettings函数中添加如下代码： loadSetting(stmt, Settings.Secure.ACCESSIBILITY_ENABLED,1); loadSetting(stmt, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
"com.gdvictor.victortool/com.gdvictor.victortool.IntelligentUpgrade.MyAccessibilityService"); 2.在APP中修改，需要给APP授权系统权限，将APP在源码中编译
在AndroidManiferst.xml中声明权限
&lt;uses-permission android:name="android.permission.WRITE_SETTINGS" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" /&gt;
在APP启动入口处添加：
Settings.Secure.putString(getContentResolver(), Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, "com.gdvictor.victortool/com.gdvictor.victortool.IntelligentUpgrade.MyAccessibilityService"); Settings.Secure.putInt(getContentResolver(), Settings.Secure.ACCESSIBILITY_ENABLED, 1);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56749f470fd453ff81f23c4541cbe9c7/" rel="bookmark">
			grpc java 安全性设计SSL/TLS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 基于 SSL/TLS 的通道加密当存在跨网络边界的 RPC 调用时，往往需要通过 TLS/SSL 对传输通道进行加密，以防止请求和响应消息中的敏感数据泄漏。跨网络边界调用场景主要有三种： 1. 后端微服务直接开放给端侧，例如手机 App、TV、多屏等，没有统一的 API Gateway/SLB 做安全接入和认证；
2. 后端微服务直接开放给 DMZ 部署的管理或者运维类 Portal；
3. 后端微服务直接开放给第三方合作伙伴 / 渠道。
除了跨网络之外，对于一些安全等级要求比较高的业务场景，即便是内网通信，只要跨主机 /VM/ 容器通信，都强制要求对传输通道进行加密。在该场景下，即便只存在内网各模块的 RPC 调用，仍然需要做 SSL/TLS。
目前使用最广的 SSL/TLS 工具 / 类库就是 OpenSSL，它是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及 SSL 协议。
多数 SSL 加密网站是用名为 OpenSSL 的开源软件包，由于这也是互联网应用最广泛的安全传输方法，被网银、在线支付、电商网站、门户网站、电子邮件等重要网站广泛使用。
二. 认证和鉴权RPC 的认证和鉴权机制主要包含两点： 1. 认证：对调用方身份进行识别，防止非法调用； 2. 鉴权：对调用方的权限进行校验，防止越权调用。
事实上，并非所有的 RPC 调用都必须要做认证和鉴权，例如通过 API Gateway 网关接入的流量，已经在网关侧做了鉴权和身份认证，对来自网关的流量 RPC 服务端就不需要重复鉴权。
另外，一些对安全性要求不太高的场景，可以只做认证而不做细粒度的鉴权。
三. gRPC 安全机制 谷歌提供了可扩展的安全认证机制，以满足不同业务场景需求，它提供的授权机制主要有四类：
1. 通道凭证：默认提供了基于 HTTP/2 的 TLS，对客户端和服务端交换的所有数据进行加密传输；
2. 调用凭证：被附加在每次 RPC 调用上，通过 Credentials 将认证信息附加到消息头中，由服务端做授权认证；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56749f470fd453ff81f23c4541cbe9c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4c7d582446e6bfe0877f9e52286d3c/" rel="bookmark">
			HTML复习笔记汇总(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要写一下，复习HTML时候觉得有必要要记下来的东西
一，HTML文档的基本结构
1,一个简单的html页面例子
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt;
&lt;title&gt;html标签&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
一个html页面
&lt;/body&gt;
&lt;/html&gt;
2,html中的标准属性
(1):calss:表示特定元素所属的一个类或组
(2):id:为元素指定一个唯一性的标志符
(3):style:为元素指定CSS属性，这称为内联样式
(4):title:为元素提供一个文本标题，
语言属性: dir 把文本的阅读方向设置为值ltr(从左到右)或rtl(从右到左)所指定的方向 lang 指定用于书写所包含的内容的语言
3,html字符实体
显示结果:实体名称 ：&amp;nbsp &lt;:&amp;lt &gt;:&amp;gt &amp;:&amp;amp ":&amp;quot ':&amp;apos 分:&amp;cent 磅:&amp;pount 元:&amp;yan 节:&amp;sect 版权:&amp;copy 注册商标:&amp;reg 乘号:&amp;times 除号:&amp;divide
4,为文档添加注释
&lt;!-- 注释内容 --&gt;
注意注释只是在浏览器中不显示，但是在客户端的源代码中仍是可以看到的
二:辅助性元素
1，用&lt;title&gt;标签为文档添加标题
例子:&lt;title&gt;这是一个文档标题&lt;/title&gt;
2，用&lt;base&gt;标签为文档设置基础URL
例子:&lt;base href="http://www.myweb.com/" /&gt;
3，用&lt;link&gt;标签定义文档关系链接
例子:&lt;link rel="stylesheet" type="text/css" href="main.css" /&gt;
4，用&lt;style&gt;标签为文档创建内部样式表
5，用&lt;script&gt;标签添加脚本程序
例子:&lt;script type="text/javascript"&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4c7d582446e6bfe0877f9e52286d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fb3273fd46c99d1ff2076864d7b4a6/" rel="bookmark">
			pyinstaller 打包成exe出现的问题&#43;解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：exe文件运行无反应 首先查看自己打包时候用的参数，如果码中没有tkinter之类的GUI窗口的话就不要用 -w 了
同时查看一下码里面有没有标准化输入输出，例如print，如果有就不要用 -w
因为 -w 参数的意思是关掉控制台dos窗口,本来要显示的东西就只能显示在dos上，所以自然什都没有 解决方案 pyinstaller -F xxx.py 问题：提示failed to execute script xxx 这个问题我遇到的时候是用tkinter在写一个小程序，生成exe点开之后就出现了failed to execute script xxx的问题，如下图
解决方案 重新打包，在打包的时候加入了参数 -c 加入参数-c后重新打包再次运行exe
-c的作用是返回错误信息！错误信息如上图所示，没有找到‘bg.jpg’！
这个文件是我用作tkinter窗口背景的一张资源。
这张图片是直接放在py文件的同一目录下的，直接打开py文件运行没有问题
而生成exe后运行却提示failed to execute scrip...
问题就出在这里！打包后的exe生成在dist文件夹中，exe不在与资源文件在同一目录，将‘bg.jpg’ copy到 与exe文件同一目录下以后问题解决。由此知道，pyinstaller打包并没有将调用到的资源文件打包在exe文件中，所以exe没有办法再用到该资源。解决办法是将资源和exe文件放到同一目录或者将源码中用到的资源路径改成绝对路径。
问题：打包的时候出现了很多warning：lib not found...dll 原因是pyinstaller 没有办法识别到这些dll 解决方案 解决办法是中copy warning中一些dll文件的名字，再电脑中搜索到他们的路径！
我搜索到的路径：C:UsersASUSAppDataRoamingpyinstallerbincache00_py36_64bit
该路径下面就是那一大堆warning的dll文件，这个路径添加到环境变量里面
方法如下
右键 此电脑——属性——高级——环境变量——用户变量中Path编辑新建然后填入刚刚dll所在的路径
然后问题就解决了
以上是我用pyinstaller时遇到的一些问题和解决办法，有不正确的地方欢迎指正，有问题也欢迎大家提出交流~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5370b1215f8f659add545d80c1a8afa4/" rel="bookmark">
			在玩ubuntu的时候一不小心运行了 $sudo rm -r /* 怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是小米笔记本13.3,原本装的是win10+ubuntu17.10双系统.
某天,我和室友要到了尼尔机械纪元汉化版的资源(接近50G),兴冲冲的放到电脑上,然而根本不能玩,而且我的电脑外存还只有256G,原本就让我感觉不太够用(我对自己的电脑也真是自信啊).在图书馆学Python的时候越想越气(我这个时候用的是ubuntu系统),就找到那个文件地址,用终端打开,输入 $sudo rm -r /* ,我以为这个是删除当前目录下的所有文件,然而因为我加了一个"/",所以代表的是根目录下的所有文件.然后我就看着终端刷刷地删文件,倒也有一种挥斥方遒的感觉.直到听到机子发出表示"我要死了"的duang的一声.好像大事不妙了啊......我赶紧按下Ctrl+C.停下来了,但是电脑不能动.于是强制断电.重启的时候出现黑底白字的"cannot find boot device"(就算记错了也大概是这个意思),然后毫无反应.
我的系统是通过grub2来引导的,当初装ubuntu的时候也是把ubuntu的引导放在了ubuntu这边,而没有做win10那边的引导(其实可以在开机的时候按F12选择启动盘).
分析了一下,应该只有ubuntu的东西没了而已,而win10那边只是引导坏了,到时候修复一下就行.
本着这样的假设,我先是用别人的电脑重新下了一个ubuntu17.10做了U盘启动盘(能够装上双系统的人就不用说怎么做U盘启动盘了吧),我用新的ubuntu把原来ubuntu占用的磁盘空间覆盖掉了.
装完又出现了下面这个报错.
原因就是boot分区太小,因为我之前的那个内核(应该是吧)都没有删掉,所以才会造成这样的情况,我也去尝试着删掉那个东西,可是一直删不掉,于是我就放弃了,直接给boot分区分配更大的空间,这样就没有这个报错了.
然后我又参照这位仁兄的建议Win10和Ubuntu的引导修复,Ubuntu引导Win10,用boot repair工具去修复了一下(后面还会用到这个),情况没有任何好转(但是这位仁兄真的让我学到了很多东西,也至少让我在暗无天日的自责中抓到了一根救命稻草,还是很感谢他的).我这时候就想到了当时win10系统出问题的时候直接用微软提供的工具就修好了的经历,所以决定试试win10安装程序的修复功能.我又去搞了一个win10的U盘启动盘.
结合这两篇文章:win10技巧：使用win10轻松自动恢复系统, Win10如何手动修复系统引导文件?
我先是用安装程序进入到这个地方,点击高级选项
就会出现这个
接着照Win10如何手动修复系统引导文件?这第二篇文章接下来的步骤去做,然后再用boot repair去修复(当然如果你不是像我那样把引导都放在ubuntu那边的话就随便了),最后win10总算是能用了.
损失总计:
ubuntu17.10加上里面的jupyter,mxnet,cuda(当初装这些我可是花了很大的功夫啊,中间重装系统都不知道有多少次)
两周的时间来重新装上之前ubuntu里面的东西
对rm命令产生阴影,再也不敢随便用这个命令了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dacd3102b64de5d64c4a0b2829108dcf/" rel="bookmark">
			VirtualBox 磁盘扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时工作在linux主机上，公司的一些软件无法使用，无奈使用虚拟机虚拟windows，喜欢web版的软件，跨平台方便呀。
以前使用过vmware，在windows是上跑的当当的，linux版本虚拟机开机关机，内核模块总是内存泄露。导致机器占用内存越来越多，无法接受，况且vmware还得找序列号，偶然间发现Sun VirtualBox （现在是Oracle的了），非常好用，速度快，免费，还没有内存泄露，跨平台。
VirtualBox的虚拟磁盘vdi文件，分为两种，一种是固定大小，一种是动态大小，因为发懒从同事那里拷贝了一个虚拟机vdi文件，直接运行，他本身才10G，以前曾经因为撞不上软件自己又添加了一个vdi扩展磁盘，因为VirualBox不允许你想网络磁盘安装软件。最近因为要调试windows端得一个小程序和我们的linux嵌入式单板通信，要安装visual studio 2008，这下c盘可是无法接受的，于是谷歌靠谱扩展磁盘，发现可以使用如下方式
VBoxManage modifyhd &lt;path to your vdi&gt; --resize &lt;new size in megabytes&gt; 扩展你的磁盘容量，于是使用VBoxManage modifyhd winxp3.vdi --resize 50000 将文件扩展到了50G，我的虚拟机文件为winxp3.vdi, 然后启动进入windows,发现磁盘还是以前的10G大小。
谷歌一下，发现如下提示
Step 3. Let your OS know the new logical size of the drive
于是使用PM进行磁盘扩容，至此，我的C盘已经50G了，放心大胆的安装vs 2008
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06504c240d59a315baa3ef4d268a99a2/" rel="bookmark">
			JVM内存屏障(Memory Barrier)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#
内存屏障(Memory Barrier) 内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：
保证特定操作的执行顺序。
影响某些数据（或则是某条指令的执行结果）的内存可见性。
编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。
Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。
“这和java有什么关系？上面java内存模型中讲到的volatile是基于Memory Barrier实现的” 如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个volatile变量，就可以保证：
一个线程写入变量a后，任何线程访问该变量都会拿到最新值。
在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。
参考资料
【Java内存模型Cookbook（二）内存屏障】http://ifeve.com/jmm-cookbook-mb/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f148e1716d4805e12c020bba8c2ff479/" rel="bookmark">
			vue字符串换行(绝对管用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 中 用 {{}} 进行数据绑定的时候，如果我么你想让字符串换行是不生效的
解决办法，不用上边的方式进行数据绑定，用v-html标签代替{{}}
data中的str为 "&lt;b&gt;1111&lt;/b&gt;&lt;br/&gt;2222"
例1，&lt;div&gt;{{str}}&lt;div&gt;
例1效果:
&lt;i&gt;1111&lt;/i&gt;&lt;br/&gt;2222
例2，&lt;div v-html="str"&gt;&lt;div&gt;
例2效果 1111
2222
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c473378da0c6a083799bd823614484da/" rel="bookmark">
			gcc与g&#43;&#43;的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编译的四个阶段 预处理：编译处理宏定义等宏命令（eg:#define）——生成后缀为“.i”的文件 编译：将预处理后的文件转换成汇编语言——生成后缀为“.s”的文件 汇编：由汇编生成的文件翻译为二进制目标文件——生成后缀为“.o”的文件 连接：多个目标文件（二进制）结合库函数等综合成的能直接独立执行的执行文件——生成后缀为“.out”的文件 在我们理解了上述四个流程后，我们在关注gcc和g++在流程上的区别。 gcc无法进行库文件的连接，即无法编译完成步骤4；而g++则能完整编译出可执行文件。（实质上，g++从步骤1-步骤3均是调用gcc完成，步骤4连接则由自己完成）
二、gcc 与g++的区别 首先说明：gcc 和 GCC 是两个不同的东西 GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。 gcc是GCC中的GUN C Compiler（C 编译器） g++是GCC中的GUN C++ Compiler（C++编译器）
误区一：gcc只能编译C代码，g++只能编译c++代码。 事实上，二者都可以编译c或cpp文件。 gcc和g++的主要区别
对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（cpp的语法规则比c的更强一些）对于 .c和.cpp文件，g++则统一当做cpp文件编译 误区二：编译只能使用gcc,连接只能使用g++ 这句话混淆了概念。编译可以用 gcc 或 g++，而链接可以用 g++ 或者 gcc-lstdc++。 因为 gcc 命令不能自动和 C++ 库链接，所以通常使用 g++ 来完成链接。 但在编译阶段，g++ 会自动调用 gcc，二者等价。
在编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。
误区三：extern “C” 与 gcc/g++ 有关系 实际上并无关系， 无论是 gcc 还是 g++，用 extern “c” 时，都是以 C 的命名方式来为symbol 命名， 否则，都以 C++ 方式为函数命名。
这里以reciprocal.cpp为例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c473378da0c6a083799bd823614484da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e6f9be7c5266c067f646bb63581479/" rel="bookmark">
			用新命令在Centos 7快速开启redis的6379端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS Linux release 7.3.1611 (Core) 上安装完redis之后，打算在Spring Boot中集成一下redis，然后测试下redis 的相关操作，但是还没打开redis 的6379端口，根据网上查找的资料，需要先修改/etc/sysconfig 路径中的iptables-config（修正：这里我看错了，不是iptables.config而是iptables文件，抱歉），但是在我在该文件当中并没有找到与网络上方法一样的内容去做修改，百度之后发现 Centos 7.3 无法使用iptables控制Linux的端口（修正：这里不是不能使用iptables控制端口，而是centos7默认使用了firewalld，但我们一样能安装iptables来控制端口），而是用firewalld 代替了原来的iptables。
我根据这篇文章（原文链接 https://blog.csdn.net/l_jun0112/article/details/73163498）想要设置，可是出现 FirewallD is not running 的提示，如果出现这种情况可以参考这里的方法解决https://jingyan.baidu.com/article/5552ef47f509bd518ffbc933.html， 执行firewall-cmd --permanent --zone=public --add-port=6379/tcp，提示FirewallD is not running，如下图所示。
通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。
通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。
再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。
如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。
再次执行执行firewall-cmd --permanent --zone=public --add-port=6379/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。
最后这样就是打开了6379端口了。 最最后，如果我的这篇文章有什么写的不对之处请路过的大神指出，以免误人子弟，谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df50f53d1427577e453ccef41d2bdc7/" rel="bookmark">
			java环境变量JAVA_HOME、CLASSPATH、PATH设置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境变量是一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。我们需要通过设置环境变量，来让jdk完成程序的编译和运行。 首先，打开我的电脑--属性--高级--环境变量： 新建系统变量JAVA_HOME 和CLASSPATH，内容如下： 变量名：JAVA_HOME 变量值：C:\Program Files\Java\jdk1.7.0 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 【注意】：最前面的".;"，这个是告诉JDK，搜索CLASS时先查找当前目录的CLASS文件。CLASSPATH 环境变量的设置比较关键，是因为以后你出现的莫名其妙的怪问题80%以上都可能是由于CLASSPATH设置不对引起的，所以要加倍小心才行。 然后，选择“系统变量”中变量名为“Path”的环境变量，双击该变量，把JDK安装路径中bin目录的绝对路径，添加到Path变量的值中，并使用半角的分号和已有的路径进行分隔。 变量名：Path 变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 以上就是java的环境配置。现在测试环境变量的配置成功与否。在DOS命令行窗口输入“javac”，输出帮助信息即为配置正确。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f95f12dc488b83a4dc898782288bd2/" rel="bookmark">
			idea中的spring boot maven项目的依赖和pom.xml文件不一致的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用idea创建了一个spring boot项目，包含了spring security，在pom文件和项目依赖都存在security依赖的情况下，对项目的访问链接都会跳转到输入账号密码的验证登录页面，代码和跳转如下：
为了验证security的作用，将pom文件中的security注释掉，操作如下：
重启后还是一样跳转到登录页面，经过排查是项目引入的依赖与pom文件中的不一致：
这时，需要进行idea 的maven clean操作，方法如下：
依赖与pom文件中一致后，重启项目，就不会再跳转到login页面了。（此处如果启动不了，
选择 File -&gt; Project Structure-&gt;Modules-&gt;Dependencies
找到 tomcat-embed-core 的jar包 作用域默认是provided ，把它改为 compile。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d45cb905603b6b023da9695e80f8a3/" rel="bookmark">
			CentOS7开机进入紧急模式EmergencyMode的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：CentOS7开机以后本来应该默认进入图形界面，但本次开机眼看着要进入图形界面成功了，突然转回了命令行页面，并提示进入了紧急模式Emergency Mode，并给出了几种也许可以解决问题的操作提示，如下图（照片有点模糊，见谅）：
尝试着查看系统错误日志，很遗憾，没有找到问题原因，只勉强看到了一句出错的日志：TSC Fast TSC calibration failed。
网友们给出的解决办法是，重启，然后系统会提示更新，更新就好了，很遗憾，reboot之后，没有提示更新问题依旧。继续求助，突然看到一篇文章里边写的可能是由于 /etc/fstab文件被修改导致的（文章地址：https://blog.csdn.net/data8866/article/details/57986878） ，灵光一现：我前几天为了找回CentOS7安装之后覆盖掉的MBR中windows系统的引导貌似确实手动修改过一个文件，加上了windows的开机引导内容，可能就是这个导致的。速度：vi /etc/fstab编辑这个文件。但是我并没有像文章中说的那样，注释掉/dev/mapper/centos-home /home xfs default 0 0这一句。因为我印象中我没有动过原来的语句，而是在文件的最后加了一句，因此我做的事是：把我添加在最后的那一句给注释掉，如下图：
编辑完，按esc，输入:wq，回车，保存成功，然后reboot。Yes！！！成功了
特此记录，希望能够帮到与我遇到同样问题的朋友。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef82d5a1d070345ef87267004c7ad61/" rel="bookmark">
			历史搜索记录SearchHistory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该demo使用了自定义的流式布局+AutoCompleteTextView+SharedPreferences实现了各大APP常用到的搜索历史记录的功能，代码简单实用。 废话不多说，上效果图为证：
上代码：第一步：自定义流式布局ZFlowLayout（让标签自动换行）
package cn.cnpp.searchhistory; import android.content.Context; import android.util.AttributeSet; import android.view.View; import android.view.ViewGroup; import java.util.ArrayList; import java.util.List; /***************************** * @Copyright(c) 2014-2018 * @Author：dengyalan * @Date：2018/1/16 * @Description：自定义搜索标签布局 * @Version:v1.0.0 *****************************/ public class ZFlowLayout extends ViewGroup { /** * 存储所有子View */ private List&lt;List&lt;View&gt;&gt; mAllChildViews = new ArrayList&lt;&gt;(); /** * 每一行的高度 */ private List&lt;Integer&gt; mLineHeight = new ArrayList&lt;&gt;(); public ZFlowLayout(Context context) { this(context, null); } public ZFlowLayout(Context context, AttributeSet attrs) { this(context, attrs, 0); } public ZFlowLayout(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //父控件传进来的宽度和高度以及对应的测量模式 int sizeWidth = MeasureSpec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef82d5a1d070345ef87267004c7ad61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2e01f6af1a593c852186f4ebaaade5/" rel="bookmark">
			mybase数据文件损坏，在数据流里侦测到无效的版本号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时工作或者学习资料都习惯使用mybase来记录，最近一份几个月差不多2G的学习资料，早上打开.nyf文件的时候提示：在数据流里侦测到无效的版本号，英文提示是“Incorrect version number detected in data stream”
还好自己前不久做了一次备份，最坏的情况也就是重新补回最近的资料，不用一切都没了，庆幸自己做过备份。所以就不慌，试着在网上看能不能找到修复的方法。
看了一个贴子，说可以使用“Nyf-Repair-Tool”工具修复损坏的.nyf文件，下载尝试了一下，运气不错，第一次就修复了，省去了很多麻烦。
下载链接：http://www.wjjsoft.com/downloads/Nyf-Repair-Tool.zip
以后一定要及时备份才行，每次更新都做备份。这也让我联想到在企业中备份的重要性，如果没有一个好的备份方案，等到出故障的时候，造成的损失不可估量。备份就是给你在出故障时，一个强大的心理支撑，不然没有备份方案，出现故障时，首先整个人就慌了，对接下来处理故障的逻辑思维影响很大。
转载于:https://blog.51cto.com/13691477/2112936
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f8387cfd783b7fd9b943cd012031f6/" rel="bookmark">
			实验五 继承与派生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的和要求 1.掌握派生类的定义方法的和派生类构造函数定义方法。
2.掌握在不同继承方式的情况下，基类成员在派生类中的访问权限。
3.掌握在多继承方式的情况下，构造函数与析构函数的调用时机与顺序。
实验内容 1.调试下列程序，并在对程序进行修改后再调试，指出调试中出错原因。
//sy5_1.cpp #include&lt;iostream&gt; using namespace std; class A { public: void seta(int i){a=i;} int geta(){return a;} public: int a; }; class B:public A { public: void setb(int i){b=i;} int getb(){return b;} void show(){cout&lt;&lt;"A::a="&lt;&lt;a&lt;&lt;endl;} public: int b; }; int main() { B bb; bb.seta(6); bb.setb(3); bb.show(); cout&lt;&lt;"A::a="&lt;&lt;bb.a&lt;&lt;endl; cout&lt;&lt;"B::b="&lt;&lt;bb.b&lt;&lt;endl; cout&lt;&lt;"A::a="&lt;&lt;bb.geta()&lt;&lt;endl; cout&lt;&lt;"B::b="&lt;&lt;bb.getb()&lt;&lt;endl; return 0; } 运行结果： 按下列要求对程序进行修改，然后调试，对出现的错误分析其原因。
（1）将派生类B的继承方式改为private时，会出现哪些错误和不正常现象？为什么？
答：将派生类B的继承方式改为private时，编译程序指出语句2、语句5、语句7有错。这是因为当类的继承方式为私有继承时，基类A的公有成员函数a，公有成员函数seta（）和geta（）作为派生类B的私有成员，派生类成员可以直接访问它们，但在类外部，派生类的对象无法访问它们。
（2）将派生类B的继承方式改为protected时，会出现哪些错误和不正常现象？为什么？
答：将派生类B的继承方式改为protected时，编译程序指出语句2、语句5、语句7有错。这是因为当类的继承方式为保护继承时，基类A的公有数据成员a，公有成员函数seta（）和geta（）作为派生类B的保护成员，派生类成员可以直接访问它们，但在类外部，派生类的对象无法访问它们。
（3）将派生类B的继承方式恢复为public，再将类A中的数据成员int型变量a的访问权限改为private时，会出现哪些错误和不正常现象？为什么？
答：主函数中的语句5、语句9出现了错误；因为B采用的是公有继承，所以B中和主函数中不能访问A中的私有函数。
（4）派生类B的继承方式仍为public，将类A中的数据成员int型变量a的访问权限改为protected时，会出现哪些错误和不正常现象？为什么？
答：主函数中的语句5出现了错误；因为B采用公有继承，所以A中保护成员在B中仍为保护成员，B中可以访问A中的保护成员，但不能通过类的对象访问类的保护成员。
2.重写教材中的Li4_10.cpp，给每个类增加一个析构函数，并使类之间的关系如附图1所示，再写出程序的输出结果。（sy5_2.cpp）
附图1 类之间的关系 修改程序如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f8387cfd783b7fd9b943cd012031f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68084e31d52ad58af548bde4fd80c8ad/" rel="bookmark">
			unity如何用代码创建自已的logo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建一个场景用于进入游戏的logo。如图：
Canvas 画布下有两个ui。image个是黑色的背景。logo 我自已设置的是一个text UI ，这里我先将它的color的透明度调为0现在是看不到文字的。如下图：
然后创建一个c#的脚本。命名为Logo。挂在logo Ui上。
接着就是写代码了，附上代码图：
using UnityEngine;
using UnityEngine.UI;//引用UI
using UnityEngine.SceneManagement;//场景的切换
public class Logo : MonoBehaviour {
private Text GetText;//声明一个存放Text的对象
bool startlogo = true;//透明度的开始增加
Color GetColor;//保存GetText的color
// Use this for initialization
void Start () {
GetText = GameObject.Find("logo").GetComponent&lt;Text&gt;();//查找logo的对象获得Text组件给GetText。
//if (GetText != null)
// print(GetText.name);//测试代码
GetColor = GetText.color;//获取GetText开始的color
}
// Update is called once per frame
void Update () {
Logoa();//定义一个方法
}
void Logoa() {
if (startlogo)//判断是否真和假
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68084e31d52ad58af548bde4fd80c8ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47dd5a0b465d637c2996b9fec0ab3235/" rel="bookmark">
			docker国内拉取国外docker镜像加速服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于国内直接拉取dockerhub的镜像速度比较慢，有以下一种加速方法 daocloud镜像市场：https://hub.daocloud.io/ 先到以上网址注册并登陆， 点击镜像加速图标， 复制命令到 需要拉取镜像的服务器执行， 这里有一个注意的点，需要检查以下文件格式， 执行脚本后需要手动删除” ] ” 的 ” , ” 然后重启docker, 输入 systemctl restart docker
然后拉取国外镜像的速度就会快很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2eceec9a6194469b5a22a2fe8718801/" rel="bookmark">
			httprunner的用例模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		httprunner的用例模板。
1. 用例用[{"config":{}},"test":{}}]格式。
2. config 为全局配置变量
name
required
格式：string
测试用例集的名称，在测试报告中将作为标题 variables
optional
格式：list of dict
定义的全局变量，作用域为整个用例集 parameters
optional
格式：list of dict
全局参数，用于实现数据化驱动，作用域为整个用例集 request
optional
格式：dict of dict
request 的公共参数，作用域为整个用例集
常用参数包括 base_url 和 headers base_url
optional
格式：string
测试用例集请求 URL 的公共 host，指定该参数后，test 中的 url 可以只描述 path 部分
headers
optional
格式：dict of dict
request 中 headers 的公共参数，作用域为整个用例集 output
optional
格式：list of string
整个用例集输出的参数列表，可输出的参数包括公共的 variable 和 extract 的参数
在 log-level 为 debug 模式下，会在 terminal 中打印出参数内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2eceec9a6194469b5a22a2fe8718801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e1b6ff6947e0b04d619bae81cffbd2/" rel="bookmark">
			主机怎么加入组播组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://www.zhihu.com/question/27233903 知乎用户：车小胖
组播也是一种IP包，也有源IP地址，目的IP地址，源IP地址为组播源的服务器IP地址，目的地址为一个特殊的IP地址，它位于 224.0.0.0 - 239.255.255.255 中，由于 224.0.0.0/8用于本地链路，即一跳的组播，239.0.0.0/8 为私有组播地址，所以实际的可用于在互联网上组播地址是225.0.0.0/8 - 238.0.0.0/8，这个组播地址不属于任何服务器或个人，它有点类似一个微信群号，任何成员（组播源）往微信群（组播IP）发送消息（组播数据），这个群里的成员（组播接收者）都会接收到此消息。
IPTV就是组播的应用：
IPTV里的一个电视频道对应一个组播IP， 假设CCTV1 对应的组播IP =238.1.1.1 ，IPTV节目源IP=1.1.1.1，就以238.1.1.1 为目的地址封装发送，这里有两个问题需要解决：
IPTV组播源不知道收看此节目的用户在哪里？
收看此节目的用户不知道IPTV组播源在哪里？
用户IPTV机顶盒只知道节目组播地址为238.1.1.1 ，至于谁是这个节目源（IP=1.1.1.1）并不清楚。
于是就引入了一个中介机构（RP），Rendezvous Point，RP点，组播的汇聚点，RP IP = 2.2.2.2 ，组播源通过单播隧道的方式把组播238.1.1.1 发给 RP，简称组播源的注册。
机顶盒静态配置了RP IP = 2.2.2.2，知道RP会有组播数据，于是就向RP（ 2.2.2.2）申请加入这个238.1.1.1 的组，于是RP就把自己收到的注册组播源数据发送给机顶盒，这个就是基于RP的 树，RPT。
机顶盒收到第一个组播包，定睛一看，原来组播源是1.1.1.1，于是发一个申请给1.1.1.1 ，申请加入238.1.1.1，这就是基于源的 树，SPT。即然已加入了SPT ，就不需要RPT 了，向RP申请退出就可以了。
着重强调一点：一旦组播用户（接收者）知道了组播源，那RP的任务就算完成了，RP的存在就是为了组播接收者发现组播源，组播用户会加入路径更优的SPT树，会申请退出路径不是最优的RPT树，避免收到两份组播的复制。
以上就是组播工作的大概过程，IPTV是IGMPv2 以及 PIM SM mode 的一个应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0dc2f2e8d12ed904ffa19bde553c43/" rel="bookmark">
			Integer类源码解析之toString方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接附上toString()方法源码
/** *@param i an integer to be converted to a string. *@param radix 字符串使用的基数(即指将i转成radix进制的字符串) *@return a string representation of the argument in the specified radix. **/ public static String toString(int i, int radix) { //基数的范围为2（MIN_RADIX）到36（MAX_RADIX） if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX) radix = 10; /* Use the faster version */ //十进制时，则调用十进制专用的的toString() //具体看下面的函数 if (radix == 10) { return toString(i); } //int型为32位，加上符号位，最长可以为33位，故先创建一个33位的char数组 char buf[] = new char[33]; boolean negative = (i &lt; 0); int charPos = 32; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e0dc2f2e8d12ed904ffa19bde553c43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b396a5f7cddd5afa8f37eb7604f7e8/" rel="bookmark">
			关于Linux下安装MATLAB Compiler Runtime(MCR) 所遇到的问题以及解决方法（以Ubuntu 16.04 为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Linux下安装MATLAB Compiler Runtime(MCR) 所遇到的问题以及解决方法（以Ubuntu 16.04 为例） 要解决的问题 通过MATLAB deploytool 将matlab的源文件打包成 jar 包并在Java Web 项目中使用解决在Linux服务器上安装MATLAB Compiler Runtime(MCR)并配置环境变量的问题 遇到的问题 在修改了/etc/profile之后出现错误，导致系统出现异常无法正常进入图像界面不同版本的MCR目录下的文件不一样，配置方式可能不同，在配置MCR9.1无果并且没有MATLAB R2017a的Linux编译器 所以改装了一个MCR8.1 （MATLAB R2013a）(遇到的第三个问题会解释原因)百度到的答案都是各种复制，千篇一律都是MATLAB 2012对应的MCR，而且举例都一样，具体过程也语焉不详。。。 - 实现的过程以及做过的尝试 首先尝试的是安装MCR9.2 因为本地MATLAB R2017a，按以下步骤安装： 1. 在matlab官网下载对应的压缩包之后解压后再当前解压到的目录进行安装
sudo ./install -mode silent -agreeToLicense yes
第一个问题来了 matlab的安装程序，给出的提示是再LD_LIBRARY_PATH 变量下追加给出的路径信息(会在终端打印出来)，讲道理官方给得提示应该不会有问题，然而按照这个步骤做之后java调用编译好的jar包出现了以下问题（StackOverflow上搜索到了相同的问题）
Exception in thread "main" java.lang.UnsatisfiedLinkError: Failed to find the required library libmwmclmcrrt.so.9.0 on java.library.path. 此处是原文 java.library.path, classpath Netbeans 8.0.2 在搜索相关内容之后，发现是找不到相应的动态连接库，找了一圈(对linux不熟悉)后发现就是要在LD_LIBRARY_PATH所配置的路径，然后检查了以下/etc/profile文件发现确实已经按照官方给的路径配置了，然而并没有什么用，考虑是环境变量没有生效，遂重启系统。 然而第二个问题出来了 开机之后正确输入密码，进不了系统一直在登录界面，查了一些资料之后发现应该是环境变量配置有问题，所以通过Xshell登录查看profile文件，和官方给的提示以及网上各种大佬的简明扼要的教程是一样的，在删除新添加的LD_LIBRARY_PATH 后恢复正常，
此处是什么原因，还不清楚坐等大佬来解答
2.姑且认为是系统抽风了进不去图形界面就用命令行吧，抱有一丝幻想做个demo来测试一下
function test() x = 1:100; y = 1:100; plot(x,1:y); end %画一条斜线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b396a5f7cddd5afa8f37eb7604f7e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3914bfe342b35b96537de023333efbf/" rel="bookmark">
			MySQL 基本用法(二)多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库 1. 数据完整性 作用：保证用户输入的数据保存到数据库中是正确的。
确保数据的完整性 = 在创建表时给表中添加约束
完整性的分类：
实体完整性域完整性引用完整性 1.1 实体完整性 实体: 即表中的一行(一条记录)代表一个实体(entity)
实体完整性的作用：标识每一行数据不重复
约束类型： 主键约束（primary key） 唯一约束(unique) 自动增长列(auto_increment)
1.1.1 主键约束 注：每个表中要有一个主键。
特点：数据唯一，且不能为null
例子:
第一种添加方式:
CREATE TABLE student( id int primary key, name varchar(50) ); 第二种添加方式:
CREATE TABLE student( id int, name varchar(50), primary key(id) ); CREATE TABLE student( classid int, stuid int, name varchar(50), primary key(classid，stuid) ); 此种方式优势在于，可以创建联合主键
第三种方式:
CREATE TABLE student( id int, name varchar(50) ); ALTER TABLE student ADD PRIMARY KEY (id); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3914bfe342b35b96537de023333efbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8896ee66c77a154086732e7ad0b4c2a9/" rel="bookmark">
			JAVA代码实现身份证18位校验码合法性校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		身份证第18位（校验码）的计算方法
1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。
2、将这17位数字分别和系数相乘的结果相加。
3、用加出来和除以11，看余数是多少。
4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X－9－8－7－6－5－4－3－2。
5、通过上面得知如果余数是2，就会在身份证的第18位数字上出现罗马数字的Ⅹ。如果余数是10，身份证的最后一位号码就是2。
例如：某男性的身份证号码是34052419800101001X。我们要看看这个身份证是不是合法的身份证。
首先我们得出前17位的乘积和是189，然后用189除以11得出的结果是17+2/11，也就是说其余数是2。最后通过对应规则就可以知道余数2对应的数字是x。所以，可以判定这是一个合格的身份证号码。
import java.util.Arrays; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * purpose: 身份证号码有效性验证 * author : 永顺 * date : 2018-03-27 17:15 */ public class ShenFenZheng { public static void main(String[] args) { ShenFenZheng s = new ShenFenZheng(); s.getShenFenZhengBollean("411322197505291935"); } /** * 判断身份证号码是否合法 * * @param number * @return true为合法 false为不合法 */ public boolean getShenFenZhengBollean(String number) { //获取身份证长度除去最后一位的长度 int length = number.length() - 1; Boolean trueOrFalse = true; if (17 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8896ee66c77a154086732e7ad0b4c2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bb647e745665a41dc413e3ab49d544/" rel="bookmark">
			Android Studio 不显示logcat日志的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自： https://blog.csdn.net/victor_E_N_01185/article/details/52818809
写代码时怎么回事突然就不显示logcat日志了，下边是解决办法
现象如图所示，logcat无日志显示：
首先，你可以试试修改以下参数：
2.若修改上述参数依然不显示，你可以打开Device Moniter，查看logcat，步骤如下：
如果在这里有logcat日志正常显示的话，你可以设置Tool--&gt;Android--&gt;Enable ADB Integration为勾选状态：
若已经是勾选状态，可重启一下 AS ！
这样就能看到logcat日志了，我碰到的logcat日志不显示的问题是用上述方法解决的，不显示logcat日志的原因有很多，上述方法只能解决部分原因导致的logcat日志不显示的问题，若还有其他方法，欢迎留言交流！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354f3943000e726fc08ed9577bc5ec24/" rel="bookmark">
			Android Studio 报错集合解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android Studio 报错集 根据个人在开发使用过程中遇到的错误为契机，将Android Studio的报错汇集一起，做一个记录，也提供给各位参考：
1、Error:android-apt plugin is incompatible with the Android Gradle plugin. Please use ‘annotationProcessor’ configuration instead. 解决方案： plugin开始，第三方android-adt不在受支持，所以我们将项目中的adt 替换成 annotationProcessor。以Banner为例：
将 app下的adt依赖替换成 annotationProcessor，然后将apply plugin: ‘android-apt’去除： 将根目录下的build.gradle 中的依赖移除： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71010b1f8519b61202d5dc0a4a5ef5f2/" rel="bookmark">
			Servlet中通过request获取不到具体参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述：由于公司系统管理要求，A公司登录系统必须经过4A验证才能跳转登录系统，工程p1中提供服务端（Servlet1），4A请求Servlet1然后实现p1与4A数据交互验证，项目使用的中间件为tomcat。该功能在测试环境（tomcat8.5.4）测试验证正常，但是上生产环境（tomcat8.5.9）时发现Servlet1中通过request获取不到相关参数。
经过核查发现可能出现以上问题的原因如下：
1、request的header头过大（可能性较小）；
2、tomcat版本问题导致解析不了4A的票据
p1与4A交互时，加密校验数据token中有“|”，由于tomcat某些版本处于安全考虑，对某些特殊字符进行了过滤，可以通过以下配置（tomcat.util.http.parser.HttpParser.requestTargetAllow）临时支持以下三个字符： | { }，其它安全字符不支持配置允许使用，官网配置说明（页尾）：
http://tomcat.apache.org/tomcat-8.0-doc/config/systemprops.html#Other
通过尝试配置后未解决相关问题，最终对生产环境tomcat版本降级为和测试环境一致，问题得以处理，对于tomcat不同版本对比，大家可以查看以下文章。 ﻿﻿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b671db1b2b8f4371e8316d527788b9e0/" rel="bookmark">
			Android Studio aar包的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio生成的aar可以包含所有的资源文件，包括res资源和class文件等，如果有so文件或者依赖的jar包也会打包进去。但是如果项目有依赖的aar则不会被打包进去（这点目前无法解决，除非拿到源码重新编译），AS当中只有library module才能编译生成aar包。
编译生成aar执行Build Project或者在右边的gradle栏中选中对应的library module然后执行对应的assemble命令即可。 编译完成以后会在对应的module下面的/build/outputs/aar/下面生成aar包： 如果你执行的是Build操作那可能生成的aar包只有debug包，如果你执行的是assemble操作，则对应目录下会生成debug和release包，其中release包也是可以配置混淆的（如果想要减少aar包的体积或者不想让别人看到源码）。
使用aar包时一般将对应的aar复制到app module下面的libs下面，然后在gradle里面android下面添加配置：
android{ ...... repositories { flatDir { //第一个libs是主项目的libs,其他module的libs路径需要用逗号隔开../module名/libs dirs 'libs', '../base_lib/libs' } } } 这里注意要的是如果项目中app所依赖的library module中也使用了aar包，那么在app的gradle中配置时需要将依赖library的libs目录也配置进去否则会编译出错。另外如果你要生成aar包的module也依赖其他的module或者aar, 则相关依赖的module或者aar也要添加到app module中进行依赖。
即app依赖A， A依赖B和C.aar，则使用A.aar时需同时将B（可以选择生成B.aar或者直接依赖）和C.aar添加到app的依赖，如果选择app直接依赖B，而B中也使用了aar，那么也要在app中配置B的aar目录。
还有一种方式是在Project 根目录下的 build.gradle 中的 repositories 中添加相应的引用如下：
allprojects { repositories { jcenter() flatDir { // 由于Library module中引用了 gif 库的 aar，在多 module 的情况下， // 其他的module编译会报错，所以需要在所有工程的repositories // 下把Library module中的libs目录添加到依赖关系中 dirs project(':AppLibrary').file('libs') } } } AS中目前无法将library中所使用的所有相关aar包一并打包进去，使用的时候需注意这一点。这篇文章(点击跳转)说可以解决一次性打包所有aar不过我没有试过。
然后在dependencies里配置：
dependencies { ...... implementation(name:'base_lib-release', ext:'aar') } AS3.0以前使用的compile，3.0以后都使用implementation关键字进行编译。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b671db1b2b8f4371e8316d527788b9e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d47b2ecf3d4b4a5b462967f7ff3eea11/" rel="bookmark">
			Silicon Labs完成对Sigma Designs 公司Z-Wave事业单位的收购
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广泛部署的网状网络技术以强化公司在智能家居领域的领先地位
德州，奥斯汀和加州，弗里蒙特 - 2018年4月18日 - Silicon Labs公司（亦称“芯科科技”，NASDAQ：SLAB）和Sigma Designs公司（纳斯达克股票代码：SIGM）今日宣布，Silicon Labs以2.4亿美元的现金交易完成对Sigma Designs公司Z-Wave事业单位的收购，包括约100名员工的团队。
Z-Wave是智能家居在网状网络方面领先的技术。 蓬勃发展的Z-Wave联盟拥有遍布全球的700多家制造商和服务厂商，提供超过2,400种经过认证、可互操作的Z-Wave基础设备。
结合Z-Wave网状网络技术和可互操作的产品特性，加上Silicon Labs 多协议的专业知识，智能家居研发人员可以取得大型、多样的生态系统网络，以及全方位的端节点（end-node）技术选项，为数百万智能家居的潜在客户提供广大的商机。Silicon Labs此次的收购策略达成了为智能家居市场提供全方位无线硬件和软件产品组合的目标，其中包括Wi-Fi®、Zigbee®、Thread、蓝牙（Bluetooth®）和专有协议。
Silicon Labs首席执行官Tyson Tuttle表示：“结合Z-Wave、Silicon Labs应用广泛的IoT连接产品组合，让我们能够在智能家居市场上达成无线技术一体化的愿景。安全、可互操作的客户体验是智能家居产品设计、部署和管理的核心。我们的智能家居愿景是多种技术能够安全地共同运作，任何使用我们所有连接选项的设备均可轻松连接家庭网络，并可自动执行安全更新和功能升级。”
Z-Wave副总裁兼总经理Raoul Wijgergangs表示：“合并后，Silicon Labs和Z-Wave联盟及其生态系统将继续精进Z-Wave的技术蓝图，为数以百万计的智能家居产品用户提供创新的技术。Z-Wave是种经过验证、广泛部署的技术，设备销量已达到1亿数量的市场里程碑。此次收购将推动多元生态系统网络合作伙伴的共同合作，扩大对亚马逊、Alarm.com、ADT、三星SmartThings，Yale，Vivint，Google Home和Comcast等的链接。”
Sigma Designs代理总裁兼首席执行官，暨首席财务官Elias Nader表示：“我们很高兴Sigma Designs绝大多数股东能批准出售我们的Z-Wave事业单位给Silicon Labs。出售这项资产此一过程是可尽快将资金返还给股东的重要里程碑 。”
Silicon Labs预计此次收购将增加2018年non-GAAP的收益，并将在2018年4月25日美国中部时间上午7时30分，于2018会计年度第一季损益电话会议上另外提供财务细节和指引。
关于Z-Wave
Z-Wave®技术是一个开放、国际公认的ITU标准（G.9959）。它是目前领先市场上的无线智能家居技术之一，在全球拥有超过2400种经过认证的可互操作产品。该标准由Z-Wave联盟代表，并得到全球700多家公司的支持，是居家安全与安防、能源、酒店、办公和轻商业应用等智能生活解决方案的关键推动技术。
关于Sigma Designs
Sigma Designs Inc.®（纳斯达克股票代码：SIGM）持续开发用于行动物联网（IoT）市场的技术。有关Sigma Designs的更多信息，请访问www.sigmadesigns.com 。
关于Silicon Labs
Silicon Labs（NASDAQ：SLAB）是领先的芯片、软件和解决方案供应商，致力于建立一个更智能、更互联的世界。我们屡获殊荣的技术正在塑造物联网、互联网基础设施、工业自动化、消费电子和汽车市场的未来。我们世界一流的工程团队创造的产品专注于性能、节能、互联和简易化。更多信息请浏览网站：www.silabs.com。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ed4f9279916717478084a3145a6a0f/" rel="bookmark">
			Java中printf的用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf的格式控制的完整格式： % - 0 m.n l或h 格式字符 下面对组成格式说明的各项加以说明： ①%：表示格式说明的起始符号，不可缺少。 ②-：有-表示左对齐输出，如省略表示右对齐输出。 ③0：有0表示指定空位填0,如省略表示指定空位不填。 ④m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。N指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n=6位。 ⑤l或h:l对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
格式字符 格式字符用以指定输出项的数据类型和输出格式。 ①d格式：用来输出十进制整数。有以下几种用法： %d：按整型数据的实际长度输出。 %md：m为指定的输出字段的宽度。如果数据的位数小于m，则左端补以空格，若大于m，则按实际位数输出。 %ld：输出长整型数据。 ②o格式：以无符号八进制形式输出整数。对长整型可以用"%lo"格式输出。同样也可以指定字段宽度用“%mo”格式输出。 ③x格式：以无符号十六进制形式输出整数。对长整型可以用"%lx"格式输出。同样也可以指定字段宽度用"%mx"格式输出。 ④u格式：以无符号十进制形式输出整数。对长整型可以用"%lu"格式输出。同样也可以指定字段宽度用“%mu”格式输出。 //不可使用 //在实践中没有运行出来。
⑤c格式：输出一个字符。 ⑥s格式：用来输出一个串。有几中用法 %s：例如:printf("%s", "CHINA")输出"CHINA"字符串（不包括双引号）。 %ms：输出的字符串占m列，如字符串本身长度大于m，则突破获m的限制,将字符串全部输出。若串长小于m，则左补空格。 %-ms：如果串长小于m，则在m列范围内，字符串向左靠，右补空格。 %m.ns：输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。 %-m.ns：其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n&gt;m，则自动取n值，即保证n个字符正常输出。 ⑦f格式：用来输出实数（包括单、双精度），以小数形式输出。有以下几种用法： %f：不指定宽度，整数部分全部输出并输出6位小数。 %m.nf：输出共占m列，其中有n位小数，如数值宽度小于m左端补空格。 %-m.nf：输出共占n列，其中有n位小数，如数值宽度小于m右端补空格。 ⑧e格式：以指数形式输出实数。可用以下形式：//在实践中没有运行出来。 %e：数字部分（又称尾数）输出6位小数，指数部分占5位或4位。 %m.ne和%-m.ne：m、n和”-”字符含义与前相同。此处n指数据的数字部分的小数位数，m表示整个输出数据所占的宽度。 ⑨g格式：自动选f格式或e格式中较短的一种输出，且不输出无意义的零。 //在实践中没有运行出来。 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
关于printf函数的进一步说明： 如果想输出字符"%",则应该在“格式控制”字符串中用连续两个%表示，如: printf("%f%%", 1.0/3); 输出0.333333%。 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
对于单精度数，使用%f格式符输出时，仅前7位是有效数字，小数6位． 对于双精度数，使用%lf格式符输出时，前16位是有效数字，小数6位． ######################################
对于m.n的格式还可以用如下方法表示（例） char ch[20]; printf("%*.*s\n",m,n,ch); 前边的*定义的是总的宽度，后边的定义的是输出的个数。分别对应外面的参数m和n 。我想这种方法的好处是可以在语句之外对参数m和n赋值，从而控制输出格式。 -------------------------------------------------------------------------
将所输出字符串的长度值赋绐一个变量, 见下例: int slen; printf("hello world%n", &amp;slen); 执行后变量被赋值为11。 代码部分：
public class printf {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ed4f9279916717478084a3145a6a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b288537066f02206172ac831971f58e/" rel="bookmark">
			互斥锁与死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在多线程程序中，多个线程可能会共用同一个对象，为了防止多个线程在争夺、使用同一份对象时可能会对该对象造成的改变，引入互斥锁。互斥锁可保证在任一时刻，只能有一个线程访问该对象，从而保证共享数据操作的完整性。
互斥锁基本原理： 互斥锁是一个二元变量，其状态为开锁(允许0)和上锁(禁止1)，将某个共享资源与某个特定互斥锁在逻辑上绑定(要申请该资源必须先获取锁)。 (1)访问公共资源前，必须申请该互斥锁，若处于开锁状态，则申请到锁对象，并立即占有该锁，以防止其他线程访问该资源；如果该互斥锁处于锁定状态，则阻塞当前线程或返回busy。 (2)只有锁定该互斥锁的进程才能释放该互斥锁，其他线程试图释放无效。 (3)互斥锁在同一个线程内，没有互斥的特性。
从互斥锁的行为看，线程加锁和解锁之间的代码相当于一个独木桥，同一时刻只有一个线程能执行。从全局上看，在这个地方，所有并行运行的线程都变成了排队运行了。比较专业的叫法是同步执行，这段代码区域叫临界区。同步执行就破坏了线程并行性的初衷了，临界区越大破坏得越厉害。所以在实际应用中，应该尽量避免有临界区出现。实在不行，临界区也要尽量的小。
互斥锁主要函数 初始化 静态方式初始化 POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁，方法如下： pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_t是一个结构，而PTHREAD_MUTEX_INITIALIZER则是一个结构常量。
动态方式初始化 int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr); 参数： mutex：表示初始化的互斥锁的指针。 attr：指向互斥锁对象属性的指针，通常情况下初始化为NULL，即使用默认属性。
申请互斥锁 如果一个线程要占用共享资源，必须先申请对应互斥锁，使用函数：
int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); 这两种方式的区别是，前者采用阻塞方式申请互斥锁，当一个线程在申请共享资源时发现该资源已经被锁定，就会阻塞等待。而pthread_mutex_trylock却不会阻塞，当要申请共享资源时发现该资源已经被锁定时，会返回一个EBUSY信号，使用pthread_mutex_trylock的目的是提高程序运行的并行性。
释放互斥锁 也称为解锁，使用函数：
int pthread_mutex_unlock(pthread_mutex_t *mutex); 释放只能由占有该互斥锁的线程完成，如果释放成功，返回0，失败返回错误编号。
销毁互斥锁 使用函数：
int pthread_mutex_destory(pthread_mutex_t *mutex ); 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。
死锁 什么是死锁 一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。 另一种：若线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。
死锁产生的四个必要条件 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
循环等待条件：若干进程间形成首尾相接循环等待资源的关系。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
如何避免死锁 预防死锁： 我们可以通过破坏死锁产生的4个必要条件来预防死锁。 首先明确一下资源互斥是资源使用的固有特性是无法改变的，所以只能从其他3个条件入手。
破坏”请求与保持条件“：第一种方法，静态分配，即每个进程在开始执行时就申请他所需要的全部资源。第二种方法，动态分配，即每个进程在申请所需要的资源时他本身不占用系统资源。
破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源，以及新申请的资源才可以重新启动，执行。
破坏“循环等待”条件：采用资源有序分配法。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。
避免死锁: 死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 解除死锁 当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有： 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态； 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b288537066f02206172ac831971f58e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a8444e9dbc920b357896a8e3b323b6/" rel="bookmark">
			数据存储——动态内存申请和释放（c语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态内存： malloc函数： 作用：用于申请一块连续的指定大小的内存块区域以（void *）类型返回分配的内存区域地址，当无法知道内存具体位置的时候，就要用到动态分配内存。
函数声明：（返回为（void *）类型）
void *malloc( size_t size ); 需要的头文件：
#include &lt;stdlib.h&gt; 或 #include &lt;malloc.h&gt; 应用：(指针类型） 变量名 =（指针类型）malloc（n * sizeof(类型））；//（指针类型）强转为同变量类型；
如：int *arr = （int *）malloc( n * sizeof( int )); //分配n个（int）大小的内存，arr指向该内存的首部；
相当于：int arr[n]; //c99不支持；大部分编译器会出现语法错误；
当n=4时，
malloc的“近亲”：calloc，realloc；
calloc函数： 作用：在内存的动态存储区分配n个长度为size（类型）的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。
函数声明：（返回为（void *）类型）
void *calloc( size_t num, size_t size ); 同malloc函数相同的头文件：
#include &lt;stdlib.h&gt; 或 #include &lt;malloc.h&gt; 应用：(指针类型） 变量名 =（指针类型）calloc（n ，sizeof(类型））；//（指针类型）强转为同变量类型；
如：int *arr = (int *) calloc ( n , sizeof(int) ); //将n个（int）初始化为0；arr指向该内存首部；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a8444e9dbc920b357896a8e3b323b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac3bd1e9ceea1d8eff47b8d3abec952/" rel="bookmark">
			MongoDB日志logappend方式以每天为单位自动切割日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、编写logAppend.sh
/save/mongodb-linux-x86_64-2.6.0/bin/mongo 127.0.0.1:27017/admin logAppend.js 二、编写logAppend.js
db.runCommand({logRotate:1}); 三、权限设置
chmod 755 logAppend.* 四、编辑crontab
crontab -e 增加 0 3 * * * /save/mongodb/shell/logAppend.sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9daed6716b1afcc19c292cb26576837/" rel="bookmark">
			【Unity 多人游戏（Multiplayer and Networking）】1.配置UnityMultiPlayer功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般我们做网络游戏都是自己C/S框架，这次我们使用Unity 自带的网络功能实现一个多人在线游戏的开发，因为比较方便。
文章正在创作-------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3829ef1dc2bbfc172a4102214dae41/" rel="bookmark">
			redis-dump数据导出以及redis-load还原数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、安装Ruby依赖 1）安装Ruby环境
yum -y install ruby ruby-devel
yum -y install rubygems
2)添加taobao Ruby镜像
添加淘宝ruby源;
gem sources --add http://gems.ruby-china.org --removehttps://rubygems.org/ http://gems.ruby-china.org added to sources source https://rubygems.org/ not present in cache 查看现有ruby源;
#gem sources --l *** CURRENT SOURCES *** http://rubygems.org/ http://gems.ruby-china.org 二、安装redis-dump Centos默认支持ruby到2.0.0，可gem 安装redis需要最低是2.2.2
解决办法是 先安装rvm，再把ruby版本提升至2.3.3
#gem install redis-dump
select id,user,host,db,command,time,state,info from information_schema.processlist where command &lt;&gt;'sleep' order by time; ERROR: Error installing redis-dump: redis requires Ruby version &gt;= 2.2.2. #gpg2 --keyserver hkp://keys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3829ef1dc2bbfc172a4102214dae41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6955518a722ce64c8bfe32810c365cb8/" rel="bookmark">
			Svn总是提示输入账号密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C:\Users\{yourname}\AppData\Roaming\Subversion
C:\Users\{yourname}\AppData\Roaming\TortoiseSVN
删除这两个目录，重新更新，输入密码，就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f8ed330ca7401bb186414cc694c519/" rel="bookmark">
			TF-IDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		词频 (term frequency, TF) 指的是某一个给定的词语在该文件中出现的次数。 逆向文件频率 (inverse document frequency, IDF)是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到。 TFIDF实际上是：TF * IDF TFIDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。
参考文献: https://blog.csdn.net/sangyongjia/article/details/52440063
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbdc3525f39d4e6fdba13147a6fdb6e0/" rel="bookmark">
			MySql数据库中文字符乱码问题之set names utf8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用php链接数据库实现“查询”和“添加”，英文字符相安无事，中文确出现乱码，学习发现原因如下：
首先给出解决办法：
原代码：
$conn = mysqli_connect('localhost', 'root', 'passworld', 'test');
$query = mysqli_query($conn, 'select * from users;');
修改之后：
$conn = mysqli_connect('localhost', 'root', 'passworld', 'test');
mysqli_query($conn, 'set names utf8');
$arr = "select * from users";
$query = mysqli_query ($conn, $arr); 核心就是在进行数据库查询时加了一个'set names utf8'。
经过学习，解释如下：
mysql5提供了以下几个设置字符集的系统变量：
character_set_client 客户端字符集
character_set_connection 客户端与服务器端连接采用的字符集
character_set_results SELECT查询返回数据的字符集
character_set_database 数据库采用的字符集
乱码问题一般是由于以上几个变量设置错误照成的，所以只要理解这几个变量，就可以告别乱码了。
使用上述变量，要理解这个核心思想：
character_set_client、character_set_connection、character_set_database编码要一致；
character_set_results则保证与SELECT返回的结果与当前程序的编码一致。
我们可以在程序中使用 set names来同时设置character_set_client, character_set_connection, character_set_results这三个系统变量。
例如 set names 'utf8' 等同于 ：
set character_set_client = 'utf8'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbdc3525f39d4e6fdba13147a6fdb6e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9218f7c4dba319b65bbe6b84277198/" rel="bookmark">
			C# Convert类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Convert类常用的类型转换方法 方法说明Convert.ToInt32()转换为整型(int)Convert.ToChar()转换为字符型(char)Convert.ToString()转换为字符串型(string)Convert.ToDateTime()转换为日期型(datetime)Convert.ToDouble()转换为双精度浮点型(double)Conert.ToSingle()转换为单精度浮点型(float) 使用Convert类转换数据类型 using System; using System.Collection.Generic; using System.Linq; using System.Text; namespace Shujuleixingzhuanhuan { class Lizi { static void Main(string[] args) { float num1=82.26f; int integer,num2; string str,strdate; DateTime mydate=DateTime.New; //Convert类的方法进行转换 integer=Convert.ToInt32(num1); str=Convert.ToString(num1); strdate=Convert.ToString(mydate); num2=Convert.ToInt32(mydate); Console.WriteLine("转换为整型数据的值{0}",integer); Console.WriteLine("转换为字符串{0},str"); Console.WriteLine("日期型数据转换为字符串值为{0}"，strdate); Console.ReadKey(); } } } 提示 转换为int型数据后进行了四舍五入的计算。 用convert类转换时注意数据表达方式的有效性，并不是任意类型之间都可以转换。
C# Convert类
——————————————————————————————————————————（分页符）
c#的convert To语句 int a=int.Parse(Console.ReadLine());
int a=Convert.ToInt32(Console.ReadLine());
double a=int.Parse(Console.ReadLine());
double a=Convert.ToDouble(ReadLine());
我想问，第1和第2的功能是不是一样的？ 第3和第4的功能又是不是一样的？ 如果要转换的 是字符串，1和2是一样的。此时Convert.ToInt32内部就是调用int.Parse，反编译可以看到。 但int.Parse里面只能传字符串。 而Convert.ToInt32可以传别的，比如时间类型，小数类型等等，此时调用datetiem.Parse等方法。Convert.ToInt32适应性更强，当然你如果只是将字符串转成数字，两者没区别。3和4类似1和2关系，一个只能传字符串，一个可以传object。 点击打开链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647cb3ea775b5d3c5cc73f84b72335f5/" rel="bookmark">
			什么是Android SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android SDK 指的是Android专属的软件开发工具包。
Android SDK:免费的开发手机应用的谷歌Android平台;
谷歌的目标是在android平台的发布上创建一个手机操作系统的大变革。为开发者设计完全开放和免费的平台，应用可以改变手机软件的使用方式，使所有的基于手机数据和web工具的应用程序相一致,android SDK也可以应用到mac
Android SDK为移动软件开发人员提供了在新平台上玩的机会。它包含了用这种编程语言开始构建应用程序所需的所有内容，以及一个完整的功能设备模拟器，以便在您完成测试时进行测试。
详见https://android-sdk.en.softonic.com/#app-softonic-review
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a3d1b60e22477b332874cac5690154/" rel="bookmark">
			MySQL主从复制，启动slave时报错Slave failed to initialize relay log info structure from the repository
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		症状：
MySQL主从复制，启动slave时，出现下面报错： mysql&gt; start slave; ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository
解决办法：查看日志， 可以看到报错，原来是找不到./server246-relay-bin.index文件，找到原因所在了，由于我使用的是冷备份文件恢复的实例，在mysql库中的slave_relay_log_info表中依然保留之前relay_log的信息，所以导致启动slave报错。 mysql提供了工具用来删除记录：slave reset； slave reset执行候做了这样几件事： 1、删除slave_master_info ，slave_relay_log_info两个表中数据； 2、删除所有relay log文件，并重新创建新的relay log文件； 3、不会改变gtid_executed 或者 gtid_purged的值
mysql&gt; reset slave; Query OK, 0 rows affected (0.01 sec) mysql&gt; change master to ...... mysql&gt; start slave; Query OK, 0 rows affected (0.00 sec) 这样slave 就可以启动了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815ab53345e45160b706d9d70d029700/" rel="bookmark">
			图文讲解：QT样式表StyleSheet的使用与加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0、相关链接
1、在设计师界面上直接添加
1.1 注意事项
2、用程序添加样式
2.1 用程序语句添加
2.2 用qss文件添加
2.2.1引用qss文件的外部路径
2.2.2引用qss文件的资源路径
3、样式表选择器
0、相关链接 官网的样式表链接：http://doc.qt.io/archives/qt-4.8/stylesheet.html
各种控件的样式：http://doc.qt.io/archives/qt-4.8/stylesheet-reference.html
QSS语法：http://www.w3school.com.cn/css/css_syntax.asp
使用样式表的3种方法：《Qt 之 样式表的使用——设置样式的方法 》https://blog.csdn.net/goforwardtostep/article/details/60884870
其实本质上就两种：1、在设计师界面上直接添加，2、用程序设置
1、在设计师界面上直接添加 举例，在设计师界面拖入一个QPushButton，右击这个按钮，选择改变样式表，就会弹出添加样式的窗口；
或者，左键选中这个按钮，在右侧的属性对话框中找到StyleSheet属性，点击...按钮也可打开样式表窗口，如下图所示
在打开的编辑样式表窗口直接输入“样式语句”，点击应用apply即可实时看到样式的效果，如下图所示：
编辑样式表这个窗口可以实时提示，我们输入的qss语句语法是否正确，如果正确会在左下角提示：有效样式表，当然，这个语法检查功能非常有限，只能检查语法的格式，例如是否缺少了大括号、是否漏了冒号、分号。
1.1 注意事项 1、这里有一点比较另类，设定背景颜色background-color时，必须要同时把设置一下边框属性：如边框圆角border-radius、边框粗细等，否则背景色无法生效。
2、如上图所示，样式表可以用大括号限定作用的控件类型，比如QPushButton{ }，如果不用大括号限定控件类型，那么该控件的所有子控件都会显示为父控件的样式，最典型的例子，使用容器类控件时，
例如QGroupBox，我们不用QGroupBox{ }限定qss语句的作用范围，而是直接设置其样式，那么该容器中的任何子控件（按钮、单选框、label等）都会显示为QGroupBox的样式，如下图所示：
由此我们还可以联想到，主窗口是所有控件的父控件，
（1）如果我们设置了主窗体的样式，而不指定作用范围，那么窗体内的所有控件都会按照主窗体的设置的样式来显示；
（2）如果我们在主窗体中设置样式时指定作用范围为QPushButton，那么该窗体内的所有QPushButton就都会显示为所设置的样式。
（3）如果父控件和子控件都设置了样式，那么子控件就按照自己的样式来显示，这是覆盖机制，因为父控件总是在子控件之前构造，子控件在构造时，会把原先的设置给覆盖掉。
2、用程序添加样式 2.1 用程序语句添加 这种方法更简单粗暴，每一个控件都有自己的setStyleSheet(QString &amp;)成员函数，直接把方法一里面的样式语句，作为形参传入该方法即可，例如：
QString pushButton_SS = "QPushButton{border-radius: 10px; /*圆角半径*/color:green;/*字体颜色*/}"; ui-&gt;pushButton_SerialSend-&gt;setStyleSheet(pushButton_SS); 2.2 用qss文件添加 跟2.1节的方法基本一样，唯一的不同就是，样式表的语句是从文件中读入的，而2.1节的样式语句是直接写在程序里的。
步骤如下：
1、新建一个txt文本文档，并修改后缀名为.qss，文件名任取，例如：myStyleSheet.qss，
2、在这个qss文件中写qss语句
3、在程序中用QFile类读取该文件，并把读出的内容传递给setStyleSheet()函数
下面是从别处抄来的例程：
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui-&gt;setupUi(this); this-&gt;loadStyleSheet(":/qss/myStyleSheet.qss"); } void MainWindow::loadStyleSheet(const QString &amp;styleSheetFile) { QFile file(styleSheetFile); file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/815ab53345e45160b706d9d70d029700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224c321998576369e2617453d0c2071d/" rel="bookmark">
			python绘制科赫雪花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码如下 # -*- coding: utf-8 -*- """ Created on Sun Apr 15 11:12:58 2018 @author: dell """ #Coch import turtle def coch(size,n): if n==0: turtle.fd(size) else: for angle in [0,60,-120,60]: turtle.left(angle) coch(size/3,n-1) def main(): turtle.setup(600,600) turtle.penup() turtle.pensize(2) turtle.goto(-200,100) turtle.pendown() level=3 coch(400,level) turtle.right(120) coch(400,level) turtle.right(120) coch(400,level) turtle.hideturtle() main() 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/252/">«</a>
	<span class="pagination__item pagination__item--current">253/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/254/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>