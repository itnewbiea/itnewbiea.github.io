<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131c72016c48a1ab1234b4cca7030813/" rel="bookmark">
			实现随机标签，字体大小、颜色随机显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写毕业，想实现一下如下图所示的效果（这里以学弟个人博客里的为示例）：
如上图所示，随机标签，字体颜色随机，字体大小随机。
下面贴一下我的实现代码。
&lt;template&gt;&lt;/template&gt;中的代码：
&lt;router-link v-for="item in tagList" :key="item.id" :to="`/tag/${item.id}`" :style="{ color: getColor(), fontSize: getSize() }" &gt;{{ item.text }} &lt;/router-link&gt; &lt;script&gt;/&lt;script&gt;中的代码：
&lt;script&gt; export default { data() { return { tagList: [ { id: 1, text: "前端", }, { id: 2, text: "JavaScript", }, { id: 3, text: "Node.js", }, { id: 4, text: "Vue", }, { id: 5, text: "webpack", }, { id: 6, text: "个人总结", }, { id: 7, text: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131c72016c48a1ab1234b4cca7030813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc55d0df9ab0027bd00b32e903beedf/" rel="bookmark">
			Exception in thread “Thread-99“ java.net.BindException: Address already in use: bind
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 xxljob配置好之后总会有这个错，但不影响启动 版本2.2.0出现这个问题，2.3.0无这个问题 xxl-job配置遇到的坑：java.net.BindException:
Address already in use: bind
最初以为端口被占用了，排查发现不是端口问题，xxl-job在版本更新之后//@Bean(initMethod = “start”,
destroyMethod = “destroy”)不需要加 改成@Bean
看一了篇文章，它里面用的是 @ConditionalOnClass()代替了@Bean(initMethod = “start”, destroyMethod = “destroy”)，启动是没错啦，但是定时不能用了。最后换成 @Bean了 就好了
@Bean // @Bean(initMethod = "start", destroyMethod = "destroy") // @ConditionalOnClass() public XxlJobSpringExecutor xxlJobExecutor() { logger.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init."); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(addresses); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a9297a67a602c4abec87e01b178c95f/" rel="bookmark">
			Verilog HDL与FPGA数字系统设计第2版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数字技术的高速发展，人们已经不再采用各种功能固定的通用中、小规模集成电路和电路图输入方法设计数字系统，而是广泛地采用硬件描述语言对数字电路的行为进行建模，并使用电子设计自动化（Electronic Design Automation，EDA）软件自动地对所设计的电路进行优化和仿真，然后使用逻辑综合工具将设计转化成物理实现的网表文件，最后用可编程逻辑器件或者专用集成电路（Application Specific Integrated Circuit，ASIC）完成数字系统。因此，掌握硬件描述语言、EDA技术和可编程逻辑器件已成为当今数字系统设计者的重要任务。
目前，符合IEEE标准的硬件描述语言（Hardware Description Language，HDL）有VHDL和Verilog HDL。两者的应用广泛，都能够通过程序描述电路的功能，从而进行数字电路的设计。由于Verilog HDL在ASIC设计领域占有重要的地位，并且它是在C语言的基础上发展起来的，语法较自由，易学易用，因此本书选取Verilog HDL进行电路设计。同时，本书还介绍了ModelSim软件和Quartus II软件的使用方法，读者可以使用它们仿真和综合Verilog HDL代码。
《Verilog HDL与FPGA数字系统设计第2版》是作者根据多年的教学科研经验以及指导学生参加全国电子设计竞赛的经验编写而成的。
扫码了解更多 ↑
在内容上，将数字逻辑设计和Verilog HDL有机结合在一起，方便读者快速进入现代数字逻辑设计领域。按照“数字逻辑设计基础、Verilog HDL建模技术、可编程逻辑器件的结构原理、EDA设计工具软件、数字电路系统设计实践”的体系结构编写。为了让读者更容易掌握Verilog HDL知识，本书在介绍数字电路设计的过程中列举了Verilog HDL的很多例程，并假定读者没有任何数字逻辑基础知识。
读者对象
本书可用作高等学校电气信息类专业的本、专科学生参加全国大学生电子设计竞赛的教材或教学参考书，也可以作为学习EDA技术、数字系统设计或电子技术的参考书。
目录
上拉下滑查看目录 ↓
前言
第1版前言
教学建议
第一篇　数字系统基础
第1章　数字逻辑设计基础 / 2
本章目的 / 2
1.1　数制及其相互转换 / 2
1.1.1　数制 / 2
1.1.2　不同进制数的相互转换 / 4
1.2　二进制代码 / 5
1.2.1　二-十进制编码 / 5
1.2.2　格雷码 / 6
1.2.3　奇偶校验码 / 8
1.2.4　ASCII字符编码 / 9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a9297a67a602c4abec87e01b178c95f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23ea0ee40756217a495443f6d61d058/" rel="bookmark">
			解决eclipse没有Dynamic web Project问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是需要安装java EE 插件。
help-&gt;Install New Software打开Work with的下拉菜单，版本地址一般会自动出现（如果没有出现则搜索自己版本的版本地址手动输入）。（如果找不到help，只在点击搜索图标搜索Install New Software也可）
加载完成后，下拉找到Web,XML,Java EE....这一栏，选择Eclipse Java EE Developer Tools, Eclipse Java Web Developer Tools
Eclipse Web Developer Tools
Eclipse XML Editors and Tools
JST server Adapters JST Server Adapters Extentions
如果搞不懂插件嫌麻烦可以把Web,XML,Java EE....这一栏全选了。
注意下面第四项不要选。
然后一直next，有条款选择I accept即可，最后点击finish等待安装。
安装完成后重启eclipse。
注意：下载过程中可能会在某个进度卡住一段时间，这是正常现象，如果网络没问题。等待一段时间即可，一般不会超过半小时。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae41f007da61ab0a4291f85b7fea3014/" rel="bookmark">
			玩转react——通过CDN引入玩转（直接引用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		玩转vue的时候，直接引入只需要引入一个文件就可以使用了。
但是玩转react时候，需要引入引入三个文件。
分别是：
名字说明react.jsreact的核心语法react-dom.js虚拟dom的语法babel.js讲高级js语法解析为浏览器认识的js 三个CDN的链接分别为：
&lt;script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"&gt;&lt;/script&gt; &lt;script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/babel-standalone@6/babel.min.js"&gt;&lt;/script&gt; 对应的官网链接：前两个、第三个
引入讲究：
react一定要在dom前面，而babel随便你怎么放，或者就直接复制过去不要改。
为什么要引入babel.js？
因为react很多地方运用到了JAX语法，它是react团队发明的一种语法。配合虚拟dom和模板引擎使用。jsx相当于是js的语法糖，为了方便书写DOM。
第一个react例子
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"&gt;&lt;/script&gt; &lt;script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/babel-standalone@6/babel.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- react的容器 --&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type="text/babel"&gt; //OH的右边的内容就是JSX的语法 //（script type="text/babel" 需要这么写，不然就会报错，需要告诉babel需要转哪些，只需要在script标签写type="text/babel"就可以了） let oH = &lt;div&gt; hello react! &lt;/div&gt;; // ReactDOM.render(要渲染什么内容，渲染到哪里) //只有用了这个才会创建虚拟DOM，先创建再更新 ReactDOM.render(oH, document.querySelector("#app")); &lt;/script&gt; 如果没用JSX语法该怎么写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae41f007da61ab0a4291f85b7fea3014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08bdc21bb3940d0bac185558ef63f442/" rel="bookmark">
			Python字符串中提取国家名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从文本中抽取国家名称，是一个命名实体识别的问题。但是因为国家个数有限，用机器学习大材小用，用直接匹配的方法看起来是快速且准确的选择。Python中也有第三方包可以调用，在这里整理一下相关资源。
Python从字符串串中如何提取国家、地区或者城市信息？中列出了两个方法。一个是Python工具包geotext，另一个是使用数据库自己匹配的方法。
geotext（0.4.0） 一个实用的Python工具包，主要是匹配的方法识别地名，包括国家和城市，可以转换为国家的ISO编码。这个包安装简单，速度非常快，处理一个句子长度的文本大概是 1 0 − 5 s 10^{-5}s 10−5s，可以用于大批量数据的处理。github上给的用法例子就很好了，搬运一下。
from geotext import GeoText places = GeoText("London is a great city") places.cities # "London" # filter by country code result = GeoText('I loved Rio de Janeiro and Havana', 'BR').cities # 'Rio de Janeiro' GeoText('New York, Texas, and also China').country_mentions # OrderedDict([(u'US', 2), (u'CN', 1)]) 这个包的正确率很高，但是召回率不太行。识别出来的国家基本都是正确的，但是对于一些相对模糊的国家缩写识别不出来，比如USA和America都识别不出来，国家名称的变体比如Chinese也识别不出来。
GeoText('USA, America').countries # [] geograpy3（0.2.2） geograpy3是geograpy的一个分支，geograpy已经不再维护了，安装也是一堆报错。geograpy3与Python3兼容，geotext能实现的功能它都能实现，但安装稍微麻烦一些，速度也相对慢，处理一个句子长度的文本大概需要 1 0 − 1 s 10^{-1}s 10−1s，大数据量用起来还是比较慢。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08bdc21bb3940d0bac185558ef63f442/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b750931d2ea97d214277a5c55f38dbb/" rel="bookmark">
			【链表】数据结构与算法——代码随想录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目的
1.会链表的定义、常用的基本操作。
2.会解决几种常用的链表相关的题目。
（一）链表基础知识
1.概念基础
（1）组成：数据+指针
（2）类型：单链表、双链表、循环链表
（3）存储方式：分散存储
2.代码实现
（1）节点定义
struct ListNode{ int val; ListNode *next; ListNode(int x): val(x),next(NULL){} }; （2）节点初始化
初始化节点：
使用默认构造函数初始化节点时，默认构造函数不会初始化头结点。
ListNode*head = new ListNode() head-&gt;val = 5; （3）虚拟头结点
//设置一个虚拟的头结点 ListNode* dummyHead = new ListNode(0); //让头结点与head发生联系 dummyHead-&gt;next = head; //定义一个新的节点，对现有链表进行操作 ListNode* cur = dummyHead; ...//之间是删除添加等一些基本操作 //把头结点还给头结点 head = dummyHead-&gt;next; //删除虚拟结点 delete dummyHead; return head; 3.常用操作
（1）删除结点
（2）添加结点
（二）链表例题
1.移除链表中的元素
移除链表中的元素
题目梳理：删除满足某一个值的所有结点
步骤：
a.设置虚拟头结点（考察结点的创建，初始值以及下一个指针的指向）【在代码的末端同步写一个删除头结点】
b.遍历列表（链表中结点具体值的读取、while 循环的编写）
c.删除符合条件的结点（链表结点的删除）
运行时出现的错误以及解决：LeetCode：执行出错runtime error: member access within null pointer of type ‘ListNode‘ (solution.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b750931d2ea97d214277a5c55f38dbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8acf542ae490d86247c7590bc1d3db98/" rel="bookmark">
			Java开发常用Util工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接:秋夜雨巷
1 字符串工具类
2 数据类型转换类
3 集合工具类
4 数组工具类
5 Properties文件操作类...
6 常用流操作工具类
7 编码工具类
8 Json工具类
9 日期工具类
10 时间戳工具类
11 精度计算工具类
12 下载文件工具类
13 解压ZIP工具类
14 文件编码转码
15 打印方法栈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edcec56a052aeaf5f972a788168ce9d/" rel="bookmark">
			east文本检测&#43;rcnn文本识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		east文本检测+rcnn文本识别，python开发，只依赖OPENCV，里面增加了登录sqlite的相关功能，可加Q 2830025146联系哦
效果见 east文本检测+crnn文本识别，Python版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b71345ef99563abc1adedbaecba1e3b/" rel="bookmark">
			Android TextView多行最后一行显示不全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现个奇怪的问题CheckBox与TextView一起放在一个横向LinearLayout中，当TextView文字内容超过一行时，最后一行文字显示不全，给控件加上背景之后，发现TextView与父控件顶部有个间距，但是并没有设置这个间距。
解决方案：
方案一、LinearLayout加入android:gravity="center_vertical"属性
方案二、把LinearLayout修改为RelativeLayout
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c80717ef146860b5dfe3f24cf0343ac1/" rel="bookmark">
			二叉树的遍历及应用（详细代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 很久没有写博客了，主要是因为懒。但是有些东西确实是比较好，值得分享。
二、二叉树的遍历（基础版） 如果学过数据结构的话，应该都了解二叉树的遍历，所以这里对于遍历是什么就不做赘述了。本文的目的是对遍历的算法代码进行回顾和优化。
1、前序遍历 如果我们将一棵二叉树的局部提取出来，所谓前序遍历就是按照“中左右的方式遍历”。有些朋友可能会搞混他们的关系，可以这样理解：什么序遍历就是“中”放的位置。怎么理解呢？如下*
前序遍历：中--&gt;左--&gt;右
中序遍历：左--&gt;中--&gt;右
后序遍历：左--&gt;右--&gt;中
我们可以观察到，不管是什么遍历，“左右”的访问顺序是不变的，唯一变化的是中间节点的访问顺序，所以我们可以知道前序遍历就是中间节点在前面访问的遍历，中序遍历就是中间节点在中间访问的遍历。
之后我们在来看看代码，最普遍的前序遍历方式是递归，代码如下：
C++ void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); traversal(cur-&gt;left, vec); traversal(cur-&gt;right, vec); } 写成非递归形式就是：
C++ vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); if (node-&gt;left) st.push(node-&gt;left); } return result; } 2、中序遍历 递归形式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c80717ef146860b5dfe3f24cf0343ac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f954227d0a73ca1bfec948fa340395/" rel="bookmark">
			IDEA从零到精通（37）之导入IDEA开发的web项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 作者简介引言导航概述一、导入项目二、修改数据库配置三、启动tomcat小结导航热门专栏推荐 作者简介 作者名：编程界明世隐
简介：CSDN博客专家，从事软件开发多年，精通Java、JavaScript，博主也是从零开始一步步把学习成长、深知学习和积累的重要性，喜欢跟广大ADC一起打野升级，欢迎您关注，期待与您一起学习、成长、起飞！
引言 我本来是一直用eclipse和myeclipse的老程序员了，很多我的粉丝小伙伴都说他们要用idea，问我怎么不用idea，其实明哥觉得用啥开发工具都不是重点，重点是要跟着明哥多学Java知识、多练习，但是作为一个宠粉的人，我怎么能拒绝粉丝的要求呢，于是我偷偷的去学习了一波（拿来吧你），然后就写了这个系列，希望小伙伴们能有所收获，明哥会努力更新的。
导航 ✪ IDEA从零到精通目录索引
◄上一篇【36】快速返回上次代码的位置
►下一篇【38】优化内存设置、提高启动运行速度
概述 在IDEA中如果导入别人开发好的web项目的，这里我就来把步骤详细说一说，当然针对不同的框架和场景，方式会稍微有些不一样，但是大体方向，是差不多的。
一、导入项目 在欢迎界面选择导入 2. 选择代码的根目录即可
3. 打开项目结构
检查jdk的版本和输出目录，我一般用jdk1.6 1.8 检查库文件，如果没有就自己添加一下，注意路径哦 配置tomcat，比如原来是7，但是现在的没有7，只要6，需要重新配置(这里要注意如果是tomcat6，jdk不能配置1.8要配置为1.6，1.8tomcat6不支持，文章后面就碰到了) 这里是报红的，所以要重新配的
配置好正确的tomcat，并修改名字
检查部署情况
如果出现 javax.servlet.http包不存在的情况，需要把tomcat重新设置
打开项目结构，选择Modules这个选项，再选择到你的项目中，选择右边的Dependencies，添加正确的tomcat配置，删除报红无用的tomcat7，然后应用设置即可(应用后不生效，则rebuild项目)。
二、修改数据库配置 看自己的情况，我这里用的是c3p0，对应修改
建好数据库和创建表
三、启动tomcat 发生错误
org.apache.jasper.compiler.JDTCompiler$1 findType
严重: Compilation error
org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException
原来是tomcat6不支持jdk1.8 ，这就很尴尬，下载个tomcat7、或者去修改jdk的编译环境也是可以的，看自己的喜好吧。
我这里采用的是修改jdk为1.6（修改的地方有几个呀）
重新编译项目
重新启动tomcat6，然后输入地址访问
小结 这节总结了“导入IDEA开发的web项目”，希望能对大家有所帮助，请各位小伙伴帮忙 【点赞】+【收藏】+ 【评论区打卡】， 如果有兴趣跟小明哥一起学习Java的，【关注一波】不迷路哦。
请到文章下方帮忙【一键三连】谢谢哈！
导航 ✪ IDEA从零到精通目录索引
◄上一篇【36】快速返回上次代码的位置
►下一篇【38】优化内存设置、提高启动运行速度
热门专栏推荐 【1】Java小游戏（俄罗斯方块、植物大战僵尸等）
【2】JavaWeb项目实战（图书管理、宿舍管理等）
【3】JavaScript精彩实例（飞机大战、验证码等）
【4】Java小白入门200例
【5】从零学Java、趣学Java
【6】IDEA从零到精通
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8349319433d905c095dc39f73d4e3b5/" rel="bookmark">
			在VMware上如何创建虚拟机以及安装linux操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建 Linux 学习环境有以下三种方式： 1 ）安装独立的 Linux 系统 , 不再安装其他操作系统。 2 ）安装 Windows 与 Linux 并存的多操作系统，启动时通过菜单选择要启动的操作系统。 3 ）在虚拟机中安装 Linux 操作系统。 建议使用 VMware Workstations 最新版本 1.新建虚拟机 2.点击首页的创建新的虚拟机，或者点击标签栏“文件”下面的新建虚拟机 3.选择自定义，可以自己按照喜好设置虚拟机的配置。点击下一步 4.兼容性按照默认就好，点击下一步 5.选择稍后安装操作系统，点击下一步 6.选择Linux操作系，版本可以选择CentOS 8 64 位，点击下一步。
7.设置虚拟机名称以及安装位置，点击下一步
8.可选择虚拟机的CPU数量以及CPU核数，完成后点击下一步 9.选择虚拟机的内存，依个人需求而定。点击下一步 10.选择网络连接类型，具体的介绍请参考。这里选择NAT，点击下一步 11.选择I/O控制器类型，默认即可。点击下一步 12.选择虚拟磁盘类型，默认即可。点击下一步
13.选择磁盘，建议使用创建新磁盘。如现有虚拟磁盘也可以选择第二项，不建议直接使用物理磁 盘。点击下一步 14.设置磁盘大小，20即可，其他保持默认。点击下一步
15.设置磁盘文件的名称，直接下一步即可
16.虚拟机至此已经创建成功，点击完成即可。接下来开始安装操作系统，通过虚拟光驱安装。
18.按照图中选择CentOS的镜像文件，点击确定 19.点击开启此虚拟机
20.鼠标点进去，用键盘选择第一项，Install CentOS Linux 8.0.0。等待界面加载完成
21.选择安装时的语言，这个随意，本人习惯使用英文。点击Continue（下一步）
22.点击Installation Destir，选择安装位置。
23.安装源默认为光盘，无需修改。软件选择Server with GUI（带有图形化界面）。软件有很多 种，老手可自行选择，新手直接确定就行 24.安装位置选择磁盘，选中Custom，点击确定更改磁盘。
25.点击Click here to create them automatically.给磁盘进行分区
26.空间大小如图所示就好，第一次安装这些东西都不重要，等你清楚的对每个分区以及目录了解 之后，按照自己需求而定。点击Done 27.点击Accept Changes（接受修改），其他配置可以先不考虑。
28.点击Root Password，需要为Root用户设置密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8349319433d905c095dc39f73d4e3b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4593c3d19041c722cf2d98054ffec6/" rel="bookmark">
			Ubuntu vim配置支持鼠标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改~/.vimrc文件，添加如下命令：
set mouse=a 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c2697fdc78e1c6633dfa8a9e25a354/" rel="bookmark">
			win10上Typora卡顿的问题及其解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑上运行较多应用，内存占用较高，发现Typora特别卡顿，但是同时chrome同时开着40+网页也没有卡顿，多个Pycharm也正常，打开任务管理器发现
Typora使用了0号显卡，怀疑是导致其卡顿的原因。
于是决定关闭GPU, 找到Typora的配置文件
大概在如下所示位置
c:\Users\\AppData\Roaming\Typora\conf\conf.user.json 打开后修改flags, 保存并重启typora，就不再使用GPU了:
"flags": [["disable-gpu"]] 禁用GPU之后，软件启动的时候比之前慢，但是打开之后不卡顿了。
怀疑是跟Chromium，GPU驱动有冲突。
我的0卡是集显，1卡是nvidia独显；有兴趣的同学可以试一下换1号GPU支持来试一下。
Reference https://support.typora.io/Trouble-Shooting/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680a9ec8ba57635589d780cb4b1c745a/" rel="bookmark">
			轨迹跟踪—线性 MPC 控制算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轨迹跟踪—线性 MPC 控制算法 在自动驾驶和无人车领域的路径规划常常被分为运动轨迹生成与车辆路径跟踪控制两个部分。传统的基于几何条件的跟踪算法如pure-pursuit由于没有考虑车辆运动学导致控制精度和稳定性等方面存在不足，因此目前大部分采用线性MPC控制算法，从而平衡控制精度与计算量。
本文首先介绍通用的MPC控制流程，对这一基于优化的控制理论有一定的认知。然后对常见的差速运动模型和自行车模型进行运动学分析，接着针对轨迹跟踪问题介绍如何将通用MPC算法应用至轨迹跟踪问题。最后基于开源代码对整体代码流程进行进一步的理解。
MPC控制算法 状态量 z z z：系统的状态（也可认为是系统输出量），通常可以构成一个空间，如车辆状态 ( x , y , θ ) T ∈ S E 2 (x,y,\theta)^T \in SE2 (x,y,θ)T∈SE2
控制量 u u u：系统的输入量，不同的系统模型有不同的控制参数
系统模型：描述系统输入与输出的精确关系，通常是非线性的关系。
采用增量的形式对系统模型进行表达：
z k + 1 = f ( z k ) + g ( u k ) z_{k+1} = f(z_k) + g(u_k) zk+1​=f(zk​)+g(uk​)
线性系统模型：系统模型的线性化结果，用于近似求解，具有速度快、不会陷入局部极值的优势。
z k + 1 = A ∗ z k + B ∗ u k + C z_{k+1} = A * z_{k} + B * u_k + C zk+1​=A∗zk​+B∗uk​+C
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/680a9ec8ba57635589d780cb4b1c745a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d143dbd4ca940718a4669a903c7928d8/" rel="bookmark">
			SpringBoot项目初始化配置（Spring Initializr）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Group：即GroupID,表示项目组织的标识符，实际对应Java的包结构，是main目录里Java的目录结构。Artifact：即ArtifactId，表示项目的标识符，实际对应项目的名称，也就是项目根目录的名称。Description：表示项目描述信息。Package name：表示项目包名。 生成项目的pom.xml文件中显示内容如下，对应上面的Group,Artifact,Version,Name,Description
&lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; 生成的目录结构：
可以看到项目的根目录名称为：demo,对应 Artifact
项目的包名称为：com.example.demo,对应Package name
com.example对应GroupId
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f0cb98c8df29702dacd15b4aa7f758/" rel="bookmark">
			k8s(九）—访问控制（创建serviceaccount账号、创建useraccount账号）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.访问控制简介 2.创建sa账号 [root@server2 ~]# kubectl create serviceaccount admin 创建sa账号为admin serviceaccount/admin created [root@server2 ~]# kubectl get sa NAME SECRETS AGE admin 1 60s admin创建成功 default 1 5d19h [root@server2 ~]# kubectl describe sa admin 查看admin账号详细信息 Name: admin Namespace: default Labels: &lt;none&gt; Annotations: &lt;none&gt; Image pull secrets: &lt;none&gt; Mountable secrets: admin-token-fqlpn Tokens: admin-token-fqlpn 生成sa时会生成对应的token Events: &lt;none&gt; [root@server2 secrets]# kubectl get secrets 查看secrets NAME TYPE DATA AGE admin-token-fqlpn kubernetes.io/service-account-token 3 78m default-token-zjzbf kubernetes.io/service-account-token 3 5d21h myregistrykey kubernetes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f0cb98c8df29702dacd15b4aa7f758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048943606fc17e3746d151665bdc8ae9/" rel="bookmark">
			C&#43;&#43;_3——库（functional）与函数对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++_3——库（functional）与函数对象 1 函数对象2 lambda表达式3 functional4 一些用于理解的引用附录lambda表达式捕获类型更多内置函数对象类型 参考 这一系列文章的目的是在学习了C++基础后，继续补充一些C++基础和进阶的知识点，包括C++11的相关内容。
以C++11标准为基础。 C++网站：http://www.cplusplus.com/reference/
1 函数对象 任何定义了函数调用操作符的对象都是函数对象（也叫仿函数），C++ 支持创建、操作新的函数对象，同时也提供了许多内置的函数对象，可以像调用函数一样使用。可以自定义函数类如下：
// func.h class MyType{ public: void operator()(){ std::cout&lt;&lt;"mmmm\n"; } void operator()(int bbb){ std::cout&lt;&lt;bbb+10&lt;&lt;"\n"; } int operator()(char a){ if(isdigit(a))	// isdigit在lacale.h 里面还有很多实用的判断函数 return atoi(&amp;a); else return -1; } }; // a.cpp #include "func.h" int main(){ MyType val; val(); // print mmmm val(123); // print 133 std::cout&lt;&lt;val('a')&lt;&lt;std::endl; // print -1 } 2 lambda表达式 利用lambda表达式可以编写内嵌的匿名函数，替换独立函数或者函数对象，不用写一个额外的函数或类或结构体，并且使代码更可读。
基本使用 [ 捕获 ] ( 形参 ) -&gt; 返回类型 { 函数体 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/048943606fc17e3746d151665bdc8ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ef1607bfcc7f0edd45f78c8275561f/" rel="bookmark">
			EasyExcel导出详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.EasyExcel简单介绍 EasyExcel工具是阿里的一个操作excel的开源项目，对现有的POI框架进行性能优化，解决了大数据量时内存溢出的问题。同时封装的更加简单灵活，适合初学者上手。
EasyExcel仓库
EasyExcel官方文档
maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 首先创建类,表头对应的就是属性名
@Data @ContentRowHeight(21) @HeadRowHeight(30) @ColumnWidth(15) public class EvaluationStatistics { @ExcelIgnore private String id; @ExcelProperty(value = {"班级名称"},index = 0) private String name; @ExcelProperty(value = {"培训天数"},index = 1) private String projectDays; @ExcelProperty(value = {"培训开始时间"},index = 2) private String beginDate; @ExcelProperty(value = {"培训结束时间"},index = 3) private String endDate; @ExcelProperty(value = {"学员人数"},index = 4) private String planNum; /*@ExcelProperty("学员等级") private String planNum;*/ } @ContentRowHeight(21) 内容行高
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ef1607bfcc7f0edd45f78c8275561f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab03601db63cc505d4cd28a285b9fab6/" rel="bookmark">
			使用IDEA创建springboot项目时，出现错误Cannot download ‘https://start.spring.io‘: connect timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1.将红框中的地址改为： http://start.spring.io
方法2.使用阿里云地址：https://start.aliyun.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b99a5ac5f6013af88a639767e93dd27/" rel="bookmark">
			【编程之路（003）】循环语句（for,while,do while语句）（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
总体介绍（引言）
for语句
基本语法
具体使用
for循环中的break和continue
while语句
基本语法
具体使用
while语句中的break和continue
do...while()循环
具体使用
while语句中的break和continue
总体介绍（引言） 循环执行语句： do while 语句、 while 语句、 for 语句。其中for循环使用频率最高，其次是while。 如果对于C语言的语句还不太了解的话，可以参考 【编程之路（002）】分支语句（if，switch语句）（C语言实现）_p_fly的博客-CSDN博客 这一篇的基本概念。 for语句 基本语法 for ( 表达式 1 ; 表达式 2 ; 表达式 3 ) { 循环语句 ; } 表达式 1 表达式 1 为 初始化部分 ，用于初始化循环变量的。 表达式 2 表达式 2 为 条件判断部分 ，用于判断循环时候终止。 表达式 3 表达式 3 为 调整部分 ，用于循环条件的调整。 具体使用 打印1-100的整数。
#include &lt;stdio.h&gt; int main() { int i = 0; //for(i=1/*初始化*/; i&lt;=100/*判断部分*/; i++/*调整部分*/) for (i = 1; i &lt;= 100; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b99a5ac5f6013af88a639767e93dd27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abf3019a9826370605301df8c23c262/" rel="bookmark">
			关于数据结构（八）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。
目录
1.树和二叉树的定义
1.树的定义
2.树的基本术语
2.二叉树的定义
2.树的抽象数据类型定义
3.小总结
1.树和二叉树的定义 1.树的定义 树（Tree）是n个节点的有限集，它或为空树（n=0），或为非空树。对于非空树T：
（1）有且仅有一个称之为根的节点；
（2）除根节点以外的其余节点可分为m个互不相交的有限集，其中每个集合本身又是一棵树，并且称为根的子树（SubTree）。
下面为二叉树的示意图：
其中1，2，3即为根，诸如4，5，6，7都是根的子树。
2.树的基本术语 （1）节点：树中的一个独立单元。包含一个数据元素及若干指向其子树的分支。如图中的A、B、C、D等。
（2）节点的度：节点拥有的子树数称为节点的度。例如，A的度为3，C的度为1，F的度为0.
（3）树的度：树的度是树内各节点度的最大值。
（4）叶子：度为0的节点称为非终端节点或分支节点。节点K、L、F、G、M、I、J都是树的叶子。
（5）非终端节点：度不为0的节点称为非终端节点或分支节点。除根节点之外。非终端节点页称为内部节点。
（6）双亲和孩子：节点的子树的根称为该节点的孩子，相应地，该节点的孩子，相应地，该节点称为孩子的双亲。例如，B的双亲为A，B的孩子有E和F。
（7）兄弟：同一个双亲的孩子之间互称兄弟。例如，H，I和J互为兄弟。
（8）祖先：从根到该节点所经分支上的所有节点。例如，H、I和J互为兄弟。
（9）子孙：以某节点为根的子树中的任一节点都称为该节点的子孙。如B的子孙为E、K、L和F。
（10）层次：节点的层次从根开始定义，根为第一层，根的孩子为第二层。树中任一节点的层次等于其双亲节点的层次加1。
（11）堂兄弟：双亲在同一层的节点互为堂兄弟。例如，节点G与E、F、H、I、J互为堂兄弟。
（12）树的深度：树中节点的最大层次称为树的深度或高度。
（13）有序树和无序树：如果将树中节点的各子树看成从左至右是有次序的（不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
（14）森林：m棵互不相交的树的集合。对数中的每个节点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。
2.二叉树的定义 二叉树（Binary Tree）是n个节点所构成的集合，它或为空树（n=0），或为非空树。对于非空树T；
（1）有且仅有一个称之为根的节点；
（2）除根节点以外的其余节点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。
二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点：
（1）二叉树每个节点至多只有两棵子树（二叉树中不存在度大于2的节点）；
（2）二叉树的子树有左右之分，其次序不能任意颠倒。
2.树的抽象数据类型定义 根据树的结构定义，加上树的一组基本操作，就构成了如下树的抽象数据类型定义：
ADT Tree{ 数据对象：D：D是具有相同特性的数据元素的集合。 数据关系R:若D为空集，则称为空树。 （1）在D中存在唯一的称为根的数据元素root，它的关系H下无前驱； 基本操作P： InitTree(&amp;T) 操作结果：构造空树T DestroyTree(&amp;T) 初始条件：树T存在 操作结果：销毁树T CreatTree(&amp;T,definition) 初始条件：definition给出树T的定义。 操作结果：按definition构造树T。 ClearTree（&amp;T） 初始条件：树T存在。 操作结果：将树T清为空树 TreeEmpty(T) 初始条件：树T存在 操作结果：若T为空树，则返回true，否则false TreeDepth(T) 初始条件：树T存在 操作结果：返回T的深度 Root(T) 初始条件：树T存在 操作结果：返回T的根 Value(T,cur_e) 初始条件：树T存在，Cur_e是T的某个节点。 操作结果：返回Cur_e的值。 Assign(T,cur_e) 初始条件：树T存在，cur_e是T中某个节点。 操作结果：节点Cur_e赋值为Value Parent(T,cur_e) 初始条件：树T存在，cur_e是T中某个节点 操作结果：若Cur_e是T的非叶子节点，则返回它的双亲，否则返回"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0abf3019a9826370605301df8c23c262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0989b9a974bdc86660051342d7d2c86c/" rel="bookmark">
			maven项目中，导入其它Module，并修改项目名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/weixin_45193791/article/details/124165100
方法一：maven导入 1、复制一个maven模块，修改模块名
2、保证项目下只有src和pom.xml，删除其他文件
3、打开pom.xml，修改artifactId与模块名一致
4、打开IDEA，点击右侧的maven，点击+，找到要导入的maven模块的pom.xml，点击刷新。
方法二：工程结构导入 1、复制一个maven模块，修改模块名。
2、保证项目下只有src和pom.xml，删除其他文件。
3、打开pom.xml，修改artifactId与模块名一致。
4、点击File–Project Structrue。
5、点击Modules–+，选择Import Module。
6、选择要导入的maven模块的pom.xm，点击ok。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69562a49a74c13e233a3bd5d583b28a2/" rel="bookmark">
			LLVM Language Reference Manual： LLVM语言参考手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLVM Language Reference Manual — LLVM 15.0.0git documentationhttps://llvm.org/docs/LangRef.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ffcba21af133efac3d9f10221abe06/" rel="bookmark">
			MATLAB绘图之添加虚线、指定坐标刻度和标签、为y轴添加标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 %% clear all clc x=[0 1 2 3 4] y1=[0 0 0.5 1 1] y2=[0 0 1 0 0] y3=[1 1 0.5 0 0] plot(x,y1,x,y2,x,y3) %添加虚线 line([1,1],[0,1],'linestyle','--'); line([2,2],[0,1],'linestyle','--'); line([3,3],[0,1],'linestyle','--'); %doc 指定坐标轴刻度值和标签 xticks([1 2 3]) xticklabels({'F_{min}','F_{mean}','F_{max}'}) yticks([0 1]) %为y轴添加标签 ylabel('函数值') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dce11beeed80b00926ca0b27d13f1726/" rel="bookmark">
			Python将excel或者csv表格中的空行删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
首先说明一下可以直接用excel工具筛选空行，然后删除空白行。这个方法百度，知乎搜索可以很容易搜到。
但是我尝试使用了一下用wps处理csv删除空行，由于数据量比较大或者我电脑垃圾的原因，它卡在那一段时间才完成。
于是找用python处理的方式解决
用python处理csv或者说excel文件不可避免的就是用pandas库
之前学习过pandas，但是并没有怎么实际用过，所以只能网上找解决办法
但是并没有找到比较对应的所以写一下记录一下。
处理数据：
首先看一下数据是什么样的：
可以看到数据有好几万行，没两行数据之间有空白行，我想把这些空白行删掉
怎么解决呢？
四行代码搞定
在数据的相同目录下创建一个py文件
import pandas as pd data = pd.read_csv("monitor.csv") res = data.dropna(how="all") res.to_csv("monitor1.csv", index=False) 运行文件会生成一个新文件monitor1.csv
打开这个文件看一下
OK，解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2cff4acc8a633d7a01229006f6a8076/" rel="bookmark">
			Docker 快速安装Jenkins完美教程（解决无法安装插件问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
有人问，为什么要用Jenkins？我说下我以前开发的痛点，在一些中小型企业，每次开发一个项目完成后，需要打包部署，可能没有专门的运维人员，只能开发人员去把项目打成一个war包，可能这个项目已经上线了，需要把服务关，在部署到服务器上，将项目启动起来，这个时候可能某个用户正在操作某些功能上的东西，如果你隔三差五的部署一下，这样的话对用户的体验也不好，自己也是烦的很，总是打包拖到服务器上。希望小型企业工作人员学习一下，配置可能复杂，但是你配置好了之后，你只需要把代码提交到Git或者Svn上，自动构建部署，非常方便。有任何地方不懂的翻到最下方随时咨询我，想帮助更多的初学者共同一起努力成长！
二、Jenkins简介
Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。
三、jenkins基本工作原理
以上为基本工作原理，只是为了开发人员更好的理解画的（个人理解），详情可查看官方文档：https://www.jenkins.io/zh/
四、准备工作
1.需要准备一台服务器。
2.需要准备一个远程连接工具，连接到Linux系统，作者采用的是：Xshell 工具 （注意：Xshell下载地址翻到本文最下面）。
3.如果没有安装Docker的，给大家准备好了教程如下：
Docker安装教程：https://www.cnblogs.com/fuzongle/p/12781828.html 五、开始安装
1.启动docker，下载Jenkins镜像文件（注意这里最好使用最新版本的Jenkins镜像，否则可能插件会无法下载）
docker pull jenkins/jenkins:lts 2.创建Jenkins挂载目录并授权权限（我们在服务器上先创建一个jenkins工作目录 /var/jenkins_mount，赋予相应权限，稍后我们将jenkins容器目录挂载到这个目录上，这样我们就可以很方便地对容器内的配置文件进行修改。 如果我们不这样做，那么如果需要修改容器配置文件，将会有点麻烦，因为虽然我们可以使用docker exec -it --user root 容器id /bin/bash 命令进入容器目录，但是连简单的 vi命令都不能使用）
mkdir -p /var/jenkins_mount chmod 777 /var/jenkins_mount 3.创建并启动Jenkins容器
-d 后台运行镜像
-p 10240:8080 将镜像的8080端口映射到服务器的10240端口。
-p 10241:50000 将镜像的50000端口映射到服务器的10241端口
-v /var/jenkins_*mount*:/var/jenkins_mount /var/jenkins_home目录为容器jenkins工作目录，我们将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里我们设置的就是上面我们创建的 /var/jenkins_mount目录
-v /etc/localtime:/etc/localtime让容器使用和服务器同样的时间设置。
–name myjenkins 给容器起一个别名
docker run -d -p 10240:8080 -p 10241:50000 -v /var/jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime --name jenkins jenkins/jenkins:lts 注意：
这样构建是有问题的，后面maven和jdk没办法使用。所以建议在创建容器的时候将jdk和maven的目录挂载到jenkins容器中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2cff4acc8a633d7a01229006f6a8076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b1a65209c4302169851742749081eb/" rel="bookmark">
			Android SDK解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次接触到AndroidSDK 是在安装Android Studio的时候，需要下载SDK，下载完之后会有一个SDK的目录文件夹，除此之外在我印象中就没有主动去使用过SDK了。
SDK全称Software Development Kit，是开发工具的集合，开发工具包含软件包，软件框架或者操作系统等等；我们自己也可以编译自己的SDK，我们所写的SDK是基于系统的SDK进行开发的、可以完成特点功能的工具集合，形式由jar、aar、so等，我使用过的百度地图的sdk或者酷我音乐的sdk都是这种形式的文件。
Android SDK 目录形式：
1. extras
该目录用于存放 Android 附加支持文件，主要包含 Android 的 support 支持包、Google 的几个工具和驱动、Intel 的 IntelHaxm。
2. platforms
该目录用于存放 Android SDK Platforms 平台相关文件，包括字体、res 资源、模板等。
3. platform-tools
该目录包含各个平台工具，其中主要包含以下几部分。 名称 作用 api 目录api-versions.xml 文件，用于指明所需类的属性、方法、接口等 lib 目录目录中只有 dx.jar 文件，为平台工具启动 dx.bat 时加载并使用 jar 包里的类aapt.exe把开发的应用打包成 APK 安装文件，如果用 Eclipse 开发，就不用通过命令窗口输入命令+参数实现打包adb.exe (Android Debug Bridge 调试桥)通过它连接 Android 手机（或模拟器）与 PC 端，可以在 PC 端上控制手机的操作。如果用 Eclipse 开发，一般情况 下 ADB 会自动启动，之后我们可以通过 DDMS 来调试 Android 程序 。 aidl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b1a65209c4302169851742749081eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc7f4c5d565e84c5ac7cb5e0bf0b4a70/" rel="bookmark">
			JAVA设计模式之组合模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 JAVA设计模式之组合模式 组合模式（Composite）的定义 组合(Composite)模式是一种对象的行为模式。将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
组合模式的本质：统一叶子对象和组合对象。
组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。
从上图可以看出，文件系统是一个树结构，树上长有节点。树的节点有两种，一种是树枝节点，即目录，有内部树结构，在图中涂有颜色；另一种是文件，即树叶节点，没有内部树结构。
显然，可以把目录和文件当做同一种对象同等对待和处理，这也就是合成模式的应用。
合成模式可以不提供父对象的管理方法，但是合成模式必须在合适的地方提供子对象的管理方法，诸如：add()、remove()、以及getChild()等。
合成模式的实现根据所实现接口的区别分为两种形式，分别称为安全式和透明式。
组合模式（Composite）优缺点 组合模式是一种结构型设计模式。其主要优点如下：
组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； 缺点：
设计较复杂，客户端需要花更多时间理清类之间的层次关系；不容易限制容器中的构件；不容易用继承的方法来增加构件的新功能； 适用环境：
在现实生活中，存在很多“部分-整体”的关系。汽车与轮胎、发动机的关系。医院与科室、医生的关系。学校与学院、学生、老师的关系。
组合模式是一种非常普遍和常用的模式，接口服务互相组合，提供更丰富的接口，实现复杂的业务逻辑。一般情况会选择使用组合代替继承，组合更灵活、更方便。
安全式合成模式的结构 安全模式的合成模式要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。
这种形式涉及到三个角色：
抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。 安全式合成模式的应用实例 // 抽象构件角色类 public interface Component { /** * 输出组建自身的名称 */ public void printStruct(String preStr); } // 树枝构件角色类 public class Composite implements Component { /** * 用来存储组合对象中包含的子组件对象 */ private List&lt;Component&gt; childComponents = new ArrayList&lt;Component&gt;(); /** * 组合对象的名字 */ private String name; /** * 构造方法，传入组合对象的名字 * @param name 组合对象的名字 */ public Composite(String name){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc7f4c5d565e84c5ac7cb5e0bf0b4a70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceea975ec095c385bbe75a42470f8332/" rel="bookmark">
			VSCode 必备插件推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode 必备插件推荐 1 界面美化 1.1 Chinese (Simplified) | 简体中文 1.2 vscode-icons | 美化图标 1.3 Bracket Pair Colorizer | 彩色括号 1.4 indent-rainbow | 给缩进加颜色 1.5 Better Comments | 彩色注释 1.6 Trailing Spaces | 语句结尾空格高亮显示 1.7 Material Theme | 主题 1.8 Power Mode | 打字特效 2 工具 2.1 open in browser | 右键在浏览器中显示 2.2 Live Server | 本地服务 2.3 Code Runner | 选择代码独立运行 2.4 A-super-translate | 英文翻译 2.5 Auto Close Tag | 自动闭合标签 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceea975ec095c385bbe75a42470f8332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb6475c6f9a6acaed230fee53841008e/" rel="bookmark">
			jQuery 学习笔记（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 jQuery 概述 1.1 JavaScript 库 库，是用于开发软件的子程序集合。库和可执行文件的区别是，库不是独立程序，他们是向其他程序提供服务的代码库链接。
JavaScript 库：即 library，是一个封装好的特定的集合（方法和函数）。就是把各种常用的代码片段，组织起来放在一个 js 文件里，组成一个包，这个包就是 JavaScript 库。
简单理解：就是一个 JS文件，里面对我们原生 js 代码进行了封装，存放到里面。这样我们就可以快速高效的使用这些封装好的功能了。
比如 jQuery，就是为了快速方便的操作 DOM，里面基本都是函数（方法）。再比如 Prototype、Dojo、Extjs 、 YUI、移动端的 zepto 等等，这些都是优秀的 JavaScript 库。它们都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的。
1.2 jQuery jQuery 是一个快速、简洁的 JavaScript 框架，是继 Prototype 之后又一个优秀的 JavaScript 代码库（ 或 JavaScript 框架 ）。 jQuery 设计的宗旨是 “write Less，Do More”，即倡导写更少的代码，做更多的事情。
jQuery = javascript Query（查询）。意思是查询 js，把 js 中的 DOM 操作做了封装，我们可以快速的查询使用里面的功能。
它封装 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb6475c6f9a6acaed230fee53841008e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56aaba4d0f694c3ded756b5f6bbd20cc/" rel="bookmark">
			记录＜a-tabs＞ ＜a-tab-pane＞遍历数组赋值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;a-tab-pane&gt;标签属性:key="XXX" :tab="XXX" &lt;a-tabs v-show="tabKey == 1" :activeKey="tabKey" :tabBarStyle="{ marginBottom: '30px' }" @change="handleTabsKey"&gt; &lt;a-tab-pane v-for="(item) in List" :key="item.id" :tab="item.name"&gt;&lt;/a-tab-pane&gt; &lt;/a-tabs&gt; 遍历赋值时用属性:tab="XXX"，手写中文提示时只能是 tab="XXX"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbad6b9fcda5c2c43d1ba1d5c08abd14/" rel="bookmark">
			教程更新丨手把手带你玩转ORB-SLAM3（2.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是的，你没看错！「手把手带你玩转ORB-SLAM3」教程2.0来了，在原有教程基础上更细节、更全面，不仅有SDK及ORB-SLAM3安装过程中的各种常见性问题解决方法及安装细节，同时还提供官方完整编译代码包哦，真正带你手把手~
本文主要讲解如何在orb-slam3中使用ros接入INDEMIND的双目鱼眼+imu模组。
具体分为以下4部分：
SDK安装orb-slam3安装SDK orb-slam3中ROS程序修改和配置文件运行 其中【SDK orbslam3中ROS程序修改和配置文件】又分为4部分：
SDK中ros程序的修改orbslam3 ros中自定义msg的添加和topic订阅orbslam3 ros中配置文件的修改orbslam3 中读取配置文件代码修改 本文操作系统：ubuntu18.04
完整代码包下载地址：https://github.com/INDEMIND/ORB-SLAM3-Course
一、SDK安装 SDK下载及准备安装：
安装过程主要参考产品手册中Ubuntu一节，官方产品手册地址：https://imsee-sdk-docs.readthedocs.io/zh/latest/src/sdk/contents.html
1.安装依赖：
2.然后使用git下载 SDK：
3.准备安装SDK需要的依赖，执行以下命令即可：
安装OpenCV3.4.3版本 1.为什么安装OpenCV3.4.3版本？
解决方法：安装OpenCV3.4.3版本，并把SDK中的libIndemind.so替换掉
2.安装Opencv参考如下：
MNN安装：
因为MNN依赖protobuf，而安装protbuf有两种方式，一种是源码安装（可参见产品手册），另一种方法如下（较容易）：
完成这些步骤，SDK就安装完毕了。
二、orb-slam3安装 如何安装：
具体安装过程请参考orbslam3官网。
安装注意：
orbslam3依赖的opencv是4.4以上的版本，而Indemind的sdk使用的是3.4.3版本。因此，需要修改orbslam3的工程，方法如下：
1.打开orbslam3工程的cmakelist.txt找到如下片段：
2.然后将该片段注释掉并添加代码，修改如下：
3.之后进行编译，成功后如下：
4.运行如下：
5.编译中的问题：
解决方法：修改 build.sh文件 将其中的make -j 改为 make -j2 或者-j1。
至此，ORB-SLAM3的安装结束。
三、SDK orb-slam3中ROS程序修改与配置文件 SDK中ros程序的修改 接下来是介绍SDK中的ros程序imsee_ros_wrapper，浏览${xx}/sdk/IMSEE-SDK/ros/src/imsee_ros_wrapper的目录：${xx}是下载sdk的路径
其中添加了自定义的msg文件夹，里面包含了自定义的设备信息消息。主要包含双目鱼眼相机的参数和imu参数。
在src/wrapper_nodelet.cc中添加了发送设备信息函数和对应的topic：
从SDK接口中读取设备信息，使用ROS Topic方式，将信息发送出去。
程序中ros参数器的读取，需要修改相应的字段
否则，config文件中的配置参数不会生效。这里工程师将图像频率改为25hz，imu频率改为200hz
orbslam3 ros中自定义msg的添加和topic订阅 随后是orbslam3中的ros程序修改：
工程师将Example_old/ros 拷贝到了 Example中
然后在build_ros.sh文件中添加如下命令：
运行 build_ros.sh后出现报错：
解决方法：将Thirdparty中的Sophus依赖加入到ros中的Cmakelist.txt中。如下：
再次运行后显示成功。
然后 在终端输入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbad6b9fcda5c2c43d1ba1d5c08abd14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8412e09012cf2720f3a9cc21304988b0/" rel="bookmark">
			将inputstream转化为数组byte[]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 come on code：
/** * 得到图片字节流 数组大小 * */ public static byte[] readStream(InputStream inStream) throws Exception{	ByteArrayOutputStream outStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024];	int len = -1;	while((len = inStream.read(buffer)) != -1){	outStream.write(buffer, 0, len);	}	outStream.close();	inStream.close(); return outStream.toByteArray();	} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1eff3476903827ec30e7bb468630066/" rel="bookmark">
			prometheus监控k8s集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		prometheus监控k8s集群
实现思路
pod性能：
使用cadvisor进行实现，监控容器的CPU、内存利用率
Node性能：
使用node-exporter实现，主要监控节点CPU、内存利用率
K8S资源对象：
使用kube-state-metrics实现，主要用于监控pod、deployment、service
k8s基础环境准备
IP 角色
192.128.232.11 k8s-master,nfs
192.128.232.12 k8s-node1
192.128.232.13 k8s-node2
一.部署nfs作为prometheus存储，可以使用对象存储，
1.部署nfs服务
[root@nfs ~]# mkdir /data/prometheus
[root@nfs ~]# yum -y install nfs-utils
[root@nfs ~]# vim /etc/exports
/data/prometheus 192.128.232.0/24(rw,sync,no_root_squash)
[root@nfs ~]# systemctl restart nfs
[root@nfs ~]# systemctl enable nfs
[root@nfs ~]# showmount -e
[root@nfs ~]# chomd -R 777 /data/prometheus
2.获取prometheus yaml文件
[root@k8s-master ~]# git clone -b release-1.16 https://github.com/kubernetes/kubernetes.git
[root@k8s-master ~]# cd kubernetes/cluster/addons/prometheus/
#可以参考我的文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1eff3476903827ec30e7bb468630066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac8affe72f7c2d269f6c4786f51a85c/" rel="bookmark">
			索引下推详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 概述适用条件工作过程不使用索引条件下推优化时的查询过程使用索引条件下推优化时的查询过程EXPLAN分析 示例配置思考其他 概述 索引条件下推优化（Index Condition Pushdown (ICP) ）是MySQL5.6添加的，用于优化数据查询。
不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。 网上搜了下相关的文章不少都将Index Condition Pushdown 称为索引下推优化，我认为还是索引条件下推优化更合适一些，因为这个优化技术关键的操作就是将与索引相关的条件由MySQL服务器向下传递至存储引擎，由此减少IO次数。MySQL服务器到存储引擎是向下，传递的是与索引列相关的查询条件，所以还是索引条件下推优化更容易理解一些。
适用条件 需要整表扫描的情况。比如：range, ref, eq_ref, ref_or_null 。适用于InnoDB 引擎和 MyISAM 引擎的查询。（5.6版本不适用分区表查询，5.7版本后可以用于分区表查询）。对于InnDB引擎只适用于二级索引，因为InnDB的聚簇索引会将整行数据读到InnDB的缓冲区，这样一来索引条件下推的主要目的减少IO次数就失去了意义。因为数据已经在内存中了，不再需要去读取了。引用子查询的条件不能下推。调用存储过程的条件不能下推，存储引擎无法调用位于MySQL服务器中的存储过程。触发条件不能下推。 工作过程 既然是优化，我们要清楚优化了些什么就要了解原本是如何工作的，所以分为两部分来描述工作过程。
不使用索引条件下推优化时的查询过程 获取下一行，首先读取索引信息，然后根据索引将整行数据读取出来。
然后通过where条件判断当前数据是否符合条件，符合返回数据。
使用索引条件下推优化时的查询过程 获取下一行的索引信息。
检查索引中存储的列信息是否符合索引条件，如果符合将整行数据读取出来，如果不符合跳过读取下一行。
用剩余的判断条件，判断此行数据是否符合要求，符合要求返回数据。
EXPLAN分析 当使用explan进行分析时，如果使用了索引条件下推，Extra会显示Using index condition。并不是Using index因为并不能确定利用索引条件下推查询出的数据就是符合要求的数据，还需要通过其他的查询条件来判断。
图一：不使用ICP技术（过程使用数字符号标示，如①②③等）
过程解释：
①：MySQL Server发出读取数据的命令，这是在执行器中执行如下代码段，通过函数指针和handle接口调用存储引擎的索引读或全表表读。此处进行的是索引读。
if (in_first_read) { in_first_read= false; error= (*qep_tab-&gt;read_first_record)(qep_tab); //设定合适的读取函数，如设定索引读函数/全表扫描函数 } else error= info-&gt;read_record(info); ②、③：进入存储引擎，读取索引树，在索引树上查找，把满足条件的（经过查找，红色的满足）从表记录中读出（步骤④，通常有IO），从存储引擎返回⑤标识的结果。此处，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要进行进行步骤④，通常有IO。
⑥：从存储引擎返回查找到的多条元组给MySQL Server，MySQL Server在⑦得到较多的元组。
⑦–⑧：⑦到⑧依据WHERE子句条件进行过滤，得到满足条件的元组。注意在MySQL Server层得到较多元组，然后才过滤，最终得到的是少量的、符合条件的元组。
图二：使用ICP技术（过程使用数字符号标示，如①②③等）
过程解释：
①：MySQL Server发出读取数据的命令，过程同图一。
②、③：进入存储引擎，读取索引树，在索引树上查找，把满足已经下推的条件的（经过查找，红色的满足）从表记录中读出（步骤④，通常有IO），从存储引擎返回⑤标识的结果。
此处，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要在③这个阶段依据下推的条件进行进行判断，不满足条件的，不去读取表中的数据，直接在索引树上进行下一个索引项的判断，直到有满足条件的，才进行步骤④，这样，较没有ICP的方式，IO量减少。
⑥：从存储引擎返回查找到的少量元组给MySQL Server，MySQL Server在⑦得到少量的元组。因此比较图一无ICP的方式，返回给MySQL Server层的即是少量的、符合条件的元组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac8affe72f7c2d269f6c4786f51a85c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb04193df33faf42a6d835df2c138f7/" rel="bookmark">
			java连接远程服务器--SSHD方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖:
&lt;dependency&gt; &lt;groupId&gt;org.apache.sshd&lt;/groupId&gt; &lt;artifactId&gt;sshd-core&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; demo
public static void main(String[] args) throws IOException { System.out.println(new Date().toString()); listFolderStructure("root", "password", "ip", 22, 5, "ls"); System.out.println(new Date().toString()); } } public static void listFolderStructure(String username, String password, String host, int port, long defaultTimeoutSeconds, String command) throws IOException { SshClient client = SshClient.setUpDefaultClient(); client.start(); try (ClientSession session = client.connect(username, host, port) .verify(defaultTimeoutSeconds, TimeUnit.SECONDS).getSession()) { session.addPasswordIdentity(password); session.auth().verify(defaultTimeoutSeconds, TimeUnit.SECONDS); try (ByteArrayOutputStream responseStream = new ByteArrayOutputStream(); ClientChannel channel = session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb04193df33faf42a6d835df2c138f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a41999b20dfa88d2e5623d3c15c91d/" rel="bookmark">
			常见卷积尺寸计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在搭配深度学习多个卷积层时我们经常要计算卷积层的输出张量的尺寸大小，可以用如下公式计算：
1, 公式 卷积层输出尺寸： o = ?(i + 2p - k) / s? + 1
式中，i:输入尺寸；o:输出尺寸；p:padding；k: kernel_size；s: stride。?…?表示向下取整。
2, 推导过程 这个公式不用死记，下面我用非常便于理解的方法描述这个推导。卷积就是对相邻的一片数据进行加权求和得到一个数的一种“合并”操作，将此操作对输入张量进行滑动扫描以得到输出张量。循着这个过程，我们很容易推导出卷积输出尺寸的计算公式。
（1）注意padding指的是两边同时补零，所以补零后输入尺寸相当于变成了i+2p；
（2）用卷积核扫描的时候，想象一把尺子在桌子上从左移动到右，受到左右边框的界限，它的移动范围只有i+2p-k大小。
（3）如果每次移动的步长是s，实际上移动的步数就是 (i+2p-k)/s，但移动的步数必须是整数，因为不能出界，如果最后一步哪怕还差一点也不能算，所以必须要向下取整。
（4）即使一步不移动，也会在原位得到一个输出点，所以最后得到的输出尺寸是移动的总步数再加上1。
3, 膨胀卷积 对用膨胀卷积，上公式不变，只需要对卷积核膨胀计算一下，
膨胀后卷积核： k’ = d × (k-1) + 1
式中，k: 输入的卷积核尺寸; d: 膨胀系数; k’: 膨胀后等效的卷积核尺寸。用k’代入上公式的k，就可以计算出输出尺寸。
4, 反卷积 反卷积就是把卷积的i, o调换就可以了。
反卷积输出尺寸： o = (i-1)×s + k - 2p
5, 常用等尺寸变换配置 经常希望经过卷积后张量尺寸不变，常用以下（k, s, p)组合：
（k, s, p) = (1, 1, 0) or (3, 1, 1) or (5, 1, 2) or (7, 1, 3)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1f620ad654b986f17c0efe0aaf742a/" rel="bookmark">
			IDEA在一个工程中导入一个maven模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：maven导入 1、复制一个maven模块，修改模块名
2、保证项目下只有src和pom.xml，删除其他文件
3、打开pom.xml，修改artifactId与模块名一致
4、打开IDEA，点击右侧的maven，点击+，找到要导入的maven模块的pom.xml，点击刷新。
方法二：工程结构导入 1、复制一个maven模块，修改模块名。
2、保证项目下只有src和pom.xml，删除其他文件。
3、打开pom.xml，修改artifactId与模块名一致。
4、点击File–Project Structrue。
5、点击Modules–+，选择Import Module。
6、选择要导入的maven模块的pom.xm，点击ok。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b373a5a024ed960f7bec3388987a7d/" rel="bookmark">
			支持中文！秒建 wiki 知识库的开源项目，构建私人知识网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道有没有人和我一样，觉得自建的东西是互联网上的“自留地”、私人空间，有一种自己的一亩三分地随心所欲的痛快。
比如自建的博客想写什么随笔就写什么，可以自娱自乐不必取悦读者；再比如自建的 wiki 有不会的知识点就可以直接记录，不用担心被嘲笑低级。抛开共建这块不聊，Wiki 不同于博客的随性，记录的内容更注重知识点和分类，可以用来构建自己的知识网络。
如果把博客比作“日记本”，那 wiki 就是“笔记本”它用来记录知识点，方便用时查阅和更新，有清晰的目录而且一个知识点还可以关联到其它知识点，逐步拓展成“百科全书”。
一、介绍 知识在于积累，还不能忘记梳理。
今天，我们要介绍的开源项目是专门用来构建 wiki 平台，助你梳理知识点的 wiki.js
地址：https://github.com/requarks/wiki
它是一款轻量级、功能强大的 wiki 开源项目，拥有评论、Markdown 编辑器、图片上传、标签、全局搜索、协同编辑、编辑历史、用户管理、谷歌分析等功能，而且支持高度自定义。
用到的技术栈也不同于老旧的 wiki 系统，它采用了 Node.js、PostgreSQL、Vue.js、Docker 等技术。基于 Docker 实现的一键部署，颇有 WordPress 之风，不要太爽！
重点是支持中文，而且界面简洁还不失美感，这点足以让它在众多同类项目中脱颖而出。
看到这儿，你是不是手痒了呢？下面就和我一起来让它跑起来吧！
二、安装 开源项目成功的必要因素之一就是有详细易懂的文档，而安装说明又是重中之重。
Wiki.js 官方文档提供了多种部署方法，包括：Linux、macOS、Windows、Docker、k8s 等，涵盖了几乎所有可能性，十分全面。
下面我就介绍其中最快捷和通用的一种，即基于 Docker 的 Docker Compose 部署。
Tips：如果你不懂 Docker 建议跟着 https://docs.requarks.io/install/ubuntu 逐步执行
下面我将主要介绍 Linux 下的安装步骤，其它系统有桌面版不再赘述。
如果你机器上有 Docker 仅需两步即可完成安装。
第一步，安装 docker-compose：
1、下载
curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 2、加执行权限
$ sudo chmod +x /usr/local/bin/docker-compose 3、创建快捷方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b373a5a024ed960f7bec3388987a7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009cdaec500a528bb09fb4d8cf8abc28/" rel="bookmark">
			第二届无线通信AI大赛参赛总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参加了第二届无线通信AI大赛 基于 AI 的信道状态信息反馈 题 ，最后仅得第13名，不论成绩好坏，毕竟花了几个星期时间，还是应该做个梳理总结。
一、赛题简介 1.数据和任务 赛题数据是来自多小区多用户的 32T4R 的 MIMO 信道特征信息，总共有60万个样本，每个样本包含768个数据，包括12条子带，每个子带长度32，每个位置又都包含实部和虚部，也就是说768 = 12 x 32 x 2 。任务是开发编码-解码算法，编码器用于UE(手机端)，把每个样本的数据分别压缩到48bits和128bits，然后发送到BS(基站)后再用解码器解码，要求解码后的数据和原数据有尽量高的相似性。评价指标是12条子带的余弦相似性的平均值。随机抽取两个样本，数据可视化后如下：
图1. 本题数据中的两个样本 2.比赛达到的效果 比赛参赛人数378人，不算很多，但由于已经是第二届了，和第一届赛题也比较像，前排选手也都非常专业，做的应该是比较充分的。下表给出了非AI方法当前最优的Type II码本方法和本次比赛的效果对比。
表1. 基于非AI方法（Type II 码本）和AI方法的CSI反馈效果对比 方法48bits*128bitsType II码本0.760.83本届冠军0.880.94我渣的成绩0.840.91 *注：Type II码本使用的是49bits
可见，基于AI的方法在CSI反馈上具有惊艳的效果，即使我一个外行都可以在短时间内超过传统方法。
二、使用的方法 1.数据处理 发现用一维（沿32长度这个维度）傅里叶变换把数据变换到频域，再进行编码-解码，解码后再傅里叶逆变换回原时域信号，用这种方法可以大大加快训练收敛速度，而且训练最终精度也好一些。
下图2给出了和图1对应的样本经傅里叶变换到频域后的数据可视化图，与图1对比，可看出在32长度上稀疏了很多。
图2. 图1两个样本经过一维（32长维度）傅里叶变换后 我分析其原因是，原时域信号存在一定的周期性，编码压缩的过程就是要去掉重复冗余的信息，把主要的特征信息提取出来，进行傅里叶变换到频域实际上也是做了同样的工作，自然减轻了神经网络学习处理的任务量，加快了训练收敛速度。当然，神经网络本身是一种强大的万能拟合工具，不进行数据预处理，往往神经网络也能自己学会必要的数据预处理过程，但这加大了网络学习的难度。
这里再多说一些，怎么判断一种数据预处理或后处理方法是否是必要的呢。我觉得一般原则是这样的：如果预处理能够达到和学习目的一致的效果，能够减轻网络学习的难度/任务量，就相当于给网络加入了先验，这种数据处理就是必要的。如果数据处理不能够引入有价值先验信息，甚至引入了错误的先验约束，这种数据处理就是没有必要的。其实除了数据处理，包括激活函数、网络算子、结构设计等在整个使用机器学习技术的系统中都涉及到如何把先验引入的问题，这是机器学习系统设计的核心问题之一（另一个核心问题是如何保证信息/特征能够顺畅、稳定、高效的流动）。
回到这个题目继续思考，我们肯定会想，如果进行二维傅里叶变换，在32长度和12子带维度上都进行傅里叶变换，不是可以更加的稀疏，更加利于编解码学习吗？二维傅里叶变换后的数据可视化图如下图3，确实更加稀疏了很多。但用这种处理实际试验下来效果不行，我分析是因为本题考察指标是12子带每子带的相关性的平均值，如果进行12子带维度上的傅里叶变换，就破坏了每个子带的信息的独立性，所以反而难以在解码过程中把这个信息还原出来。这就是上面说的带来了错误的先验约束。
图3. 图1两个样本经过二维（32长维度和12子带维度）傅里叶变换后 数据处理是我在本题中提分最有效的一个措施，所以说的多一些。
2.网络结构 这方面没有什么新的思路和太多可说的，就是在此领域经典网络CRNet基础上又杂糅进了多种常规模块，如SE模块等，又做了多个不同参数尺寸的网络并联，最后又加入了transformer并联，把各个子网络的结果cat起来输入一个1x1卷积层保证输出尺寸是bs x 2 x 32 x 12，然后再flatten之后接全连接层和量化层，解码的过程几乎是上述过程逆过来，只不过解码器在基站端运行有更好的硬件算力，所以使用了更大参数量的网络。
由于这个题目的训练过程非常慢，训练40多个小时都没有完全饱和，所以调参非常麻烦，我也没有充分对比各种网络结构的性能，只好是相信越大的网络越好，就用了一个大杂糅网络。
3.损失函数 我直接使用了评价指标，即各子带余弦相似性均值，做为损失函数。我还尝试了MSE和NMSE等其他损失函数，效果都没有这个直接用相似性做为损失函数效果好。实际上，MSE / NMSE是一个更强的条件，当MSE小时，相似性肯定小，但相似性小时，MSE不一定小，所以用相似性做为损失函数降低了网络收敛的难度。
4.量化层 举办方提供的baseline里给出了量化层的设计，默认是2比特量化，就是一个浮点数均匀切成四段，再量化为两个比特。我尝试了多种修改思路都没有用，只有混合比特量化有一点点用处。我在48bits任务中使用了一半1比特一半2比特量化，也就是说网络输出为32长度的浮点数据，其中一半用1比特量化为16bits，另一半用2比特量化为32bits，最后合起来总共是48bits；对于128bits任务，我把网络输出设置为72长度浮点数，其中16长度用1比特，56长度用2比特。
三、一些失败的尝试 我没有做上届的比赛，这次比赛我从零进入，总共投入了三个星期的时间。这个题目的灵活性很高，在这三个星期时间内我尝试过非常多的方案，但几乎都没有奏效，往往是每天早上一觉醒来想到一个非常激动人心的方法，努力一天实现之后失望的发现并没有什么卵用，也因此浪费了很多时间，造成最后失利。这些方案虽然无效，但毕竟花了时间去做，也记录在这里，给大家避坑。
1.聚类法预编码 压缩编码任务也可以理解为把某一类相近的样本编成相同的码，这和聚类是类似的，我自然想到用聚类的思路去试一试。当然我们不可能全部用聚类，那样即使48bits任务也需要聚成2的48次方类，类别太多了，样本数也不够。但我们也许可以将其中部分比特拿出来用聚类做，比如拿出7个比特可以存储128类，8个可以存储256类，等等。在解码的时候这部分比特可以直接解算为每个类的聚类中心点。剩余的比特存储的信息可以再用深度学习的方法来学习每个样本再怎么从聚类中心去修正。我做了简单的试验，即使用Kmeans进行简单的聚类（对此任务，kmeans并不是最好的），仍可以观察到聚类所用的少数比特可以存储更多的信息，如下表：
表2. 使用聚类-恢复为聚类中心的方法和使用CRNet在少数比特上编解码的效果对比 聚类占用比特对应的聚类类别用聚类中心点还原后的相似性同样比特数用CRNet可以达到的相似性120.23640.2030240.29870.2751380.38150.31724160.45160.37335320.51930.43006640.56700.491471280.60810.526282560.64280.5725 从这个观察出发，我认为占用少数bits存储聚类信息，可以更高效的编码。然而剩下的难题是，怎么用深度学习网络来学习使用剩余的比特存储每个样本和聚类中心之间的修正关系呢？我尝试了若干种方案都没有奏效的，后来实在没时间只好放弃。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009cdaec500a528bb09fb4d8cf8abc28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d2786309a4100cc2b1db7ecb9fdf639/" rel="bookmark">
			知识图谱综述（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识图谱综述（三） 论文原文链接
这部分为数据图（页码4）部分，主要包括了： 图结构数据模型的介绍：有向边标签图（多关系图）、异构体、属性图、图数据集、其他图数据模型、图存储；查询（语言）：图模式、复杂的图模式、导航图模式、其他特性。 下文的每一小点即论文中的一个段落。 任何KG的建立都要事先将数据抽象成图模型，本章选取一些在实际中常用的图结构数据模型来表示数据图。然后，我们在图查询语言的基础上，讨论了此类数据图的查询原语。
一、图结构数据模型 撇开图表不谈，先假设我们所呈现示例中的旅游董事会尚未决定如何对有关景点、活动、服务等的相关数据进行建模。首先董事会会先使用一个表格结构来表示所需的数据，尤其是关系型数据库。尽管他们不知道真正需要捕获哪些数据，但他们起初设计了一个关系模式。
他们设计的活动表格有五列，其中下划线表示表的主键，以唯一标识重复活动的发生（同样的活动可能反复举行）：
活动（活动名称，活动地点，活动类型，开始时间，结束时间）
但是，他们采用这种方法会遇到以下问题：
活动可能有多个名字，如用不同的语言；活动地点可能有多个；他们甚至还不知道未来活动的开始和结束时间；活动有多种类型；…… 随着数据变得多样化，问题被逐步得到解决，他们为活动生成内部标识符并调整它们的关系模式：
活动名称（id, name），活动开始时间（id, start），活动结束时间（id, end），活动地点（id, venue），活动类型（id, type）
使用上述模式，该组织现在对活动进行建模时可以使用0-n个活动名称、活动地点和活动类型，以及使用0–1标明活动是否有开始日期和活动结束日期（不需要在表格上使用关系空值/空白单元格，id=0，则start/end=null；id=1，则start/end=某个时间点）。
在此过程中，董事会为了与新数据进行同步，必须多次改变该模式，并且每次改变都要对数据进行昂贵的重构、重新载入数据、重新索引数据（此处我们仅考虑一张表）。董事会在关系模型上苦苦挣扎，因为他们不知道哪些数据应该被建模，以及将使用哪些数据源。
然而，当董事会实现了后一种关系模式后，他们可以在不进行更多更改的情况下整合更多的数据资源：对多重性的最小假设（如1对1,1对n等），该模式为集成不完整和多样化的数据提供了很大的灵活性。
事实上，董事会最后得到的模式本质上是对实体之间的一系列二元关系进行建模，这实际上就可以看作是对图进行建模。如果从一开始就采用图数据模型，董事会就可以摒弃之前所考虑的模式，并且可以随时定义任意实体对之间的任何（二元）关系。
下面开始介绍实际应用中常用的图数据模型。
有向带标签边图（又：多关系图） 由一些 节 点 \color{#FF0000}{节点} 节点（例如圣地亚哥、阿里卡、EID16、2018-03-22 12:00）和一些节点之间带标签的 有 向 边 \color{#FF0000}{有向边} 有向边（例如“圣卢西亚–城市–&gt;圣地亚哥”）组成；
在KG中，“节点”表示“实体”，“边”表示这些实体之间的（二元）关系。下图提供了一个多关系图的例子，旅游董事会将一些相关活动的数据建模为多关系图。图1中的数据包括：活动名称、活动类型、活动开始和结束时间、以及活动地点。
我们使用双向边来更加简洁地描述两种方向的边，例如图1中的“比尼亚德尔马&lt;–巴士–&gt;阿里卡”。此外，虽然一些命名约定推荐包含动词的更完整边标签，如has venue或is valid from，但是在本论文中，为了便于演示，将省略这些标签中的“has”和“is”动词，而只使用venue或valid from。
向这样的多关系图中添加新信息通常包括添加新的节点和边（除了之后提到的一些例外情况）。表述不完整的信息只需要省略某个边，例如图1中还没有定义Food Truck festival的开始和结束时间。
以下是多关系图的形式化定义（附录B中将进行更加细致的描述）：
相比于标准的关系模型（模式必须预先定义，并且每一步都要遵循），这种将数据建模成图的方法可以更加灵活地整合新数据源。尽管其他结构化数据模型，比如树结构（XML、JSON等）也同样灵活，但是图不需要分层组织数据（比如“活动地点”是父节点、孩子节点还是兄弟节点类型呢？）。图还可以使用 环 \color{#FF0000}{环} 环进行表示和查询（比如图1中圣地亚哥、阿里卡和比尼亚德尔马之间路径上的有向环）。
多关系图的标准数据模型是RDF（资源描述框架），它由W3C所推荐。RDF模型定义了不同类型的节点，包括：
IRIs（国际化资源标识符），它可以对web上的实体进行全方位识别；字面量（literal）则能够表示字符串（带或不带语言标签）和其他数据类型的值（整型、日期等）；空节点是还未分配标识符的匿名节点，比如可以在RDF中使用空白节点，而不是创建像EID15、EID16这样的内部标识符。（我们将在3.2节讨论标识符时，进一步讨论不同类型的节点） 异构图（Heterogeneous graphs）
异构图（又：异构信息网络）的每个节点和边都分配了一种类型。因此，异构图类似于del图（边标签与边类型相对应），但异构图中节点的 类 型 \color{#FF0000}{类型} 类型 构成了图模型本身的一部分，而不是像del图中的类型那样被表示为一种特殊的关系，如图2所示。 如果某个边是在相同类型的两个节点之间，那么该边（如borders）是同质的（homogeneous），否则该边（如capital）是异构的（heterogeneous）。异构图的一个好处是：它们允许根据节点的类型进行划分，例如为了实现某种机器学习任务。反之，异构图通常只支持节点和类型间一种一对一的关系，即一个节点只会和一种类型相关联（该情况不会出现于del图中，例如图1中Santiago是0类型的，而EID15具有多种类型）
异构图的形式化定义：
属性图（property graph，PG）
属性图可以灵活地建模更加复杂的关系。整合输入的数据后，它们将提供“哪些公司提供哪些航班的票价信息”，从而让旅游董事会更好地了解城市间的可以利用的线路（例如国际航班）。在多关系图中，我们无法说明提供某条航线的公司，如边“圣地亚哥–航班–&gt;阿里卡”。但是我们可以添加一个新节点（LA380、LA381）来表示航班，并将它与始发地、目的地、公司和交通类型相关联，如下图3所示。 然而，将属性图运用于图1中的所有路径上需要对图进行大改。另一种办法可以将不同公司的航班放在不同的已命名的图中，但是如果已经使用命名图来追踪图中的始发地点（？），那么这将变得很麻烦。
因此，属性图的提出是为了将数据建模为图的时候提供额外的灵活性。属性图允许一些“属性-值”对和一个标签同时与节点和边相关联（即PG中每个节点或边拥有一个标签（节点名）和一些属性（值））。如下图4是一个简单的PG例子，它与图3相似。
上图，我们使用边上的“属性-值”对来对公司进行建模（在PG的实际应用中，属性可能会有多个值，例如可表示为一个数组。但这样的情形并不影响图的表现力，也不影响我们的讨论）。关系的类型被赋予标签“flight”。我们进一步使用节点标签来表示两个节点的类型，并使用“属性-值”对来表示它们的纬度和经度。
PG最常用于目前流行的图数据库中，如Neo4j。在图模型的选择上，最重要的是PG可以在不丢失任何信息的情况下与多关系图（MG）进行相互转换。如上图4。总之，MG提供了一个更小的模型，而PG提供了一个更加灵活的模型。通常来说，相比于其他实际因素（比如不同模型的可实现性），模型的选择是次要的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d2786309a4100cc2b1db7ecb9fdf639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e84ec0161afb1195062c6f6207cda0/" rel="bookmark">
			报错：Incorrect string value: ‘\xE5\x90\x83\xE9\xA5\xAD‘ for column ‘msg‘ at row 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 在学习Spring项目时，爆出了数据的如下错误：
Incorrect string value: '\xE5\x90\x83\xE9\xA5\xAD' for column 'msg' at row 1 二、原因 原因：发现在创建数据库的时候将编码格式创建为了latin1编码。
三、解决方法 解决方法：重新建表设置为utf8编码格式。或者想偷懒的话，把涉及到这个字段修改为utf8格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df10c37109ba7336f80825fc1737d75/" rel="bookmark">
			Java中求一个数的幂次方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中求 m 的 n 次方不能使用 m^n，可使用 Math.pow(m, n) 来求m的n次方，求得结果为浮点类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dcfa2348f1c8039836c3fbff7c56e8f/" rel="bookmark">
			【项目一】医疗实战-传智健康
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传智健康 一、项目概述1.1 项目介绍1.2 技术架构1.3 功能架构 二、环境搭建2.1 项目结构2.2 maven项目搭建 三、Power Designer和ElementUI3.1 Power Designer3.2 ElementUI 四、模块实现4.1 预约管理-检查项管理4.1.1 新增检查项4.1.2 检查项分页4.1.3 删除检查项4.1.4 编辑检查项 4.2 预约管理-检查组管理4.2.1 新增检查组4.2.2 检查组分页4.2.3 编辑检查组（需要多次理清关系）4.2.4 删除检查组 4.3 预约管理-套餐管理4.3.1 图片存储方案4.3.2 新增套餐4.3.3 体检套餐分页4.3.4 定期清理垃圾图片（定时任务组件Quartz） 4.4 预约管理-预约设置4.4.1 Apache POI4.4.2 批量导入预约设置信息4.4.3 日历展示预约设置信息4.4.4 基于日历实现预约设置 4.5 移动端开发-体检预约4.5.1 移动端开发4.5.2 需求分析和环境搭建4.5.3 套餐列表页面动态展示4.5.4 套餐详情页面动态展示4.5.5 短信发送 4.6 页面静态化4.6.1 页面静态化介绍4.6.2 Freemarker4.6.3 生成移动端静态页面 4.7 移动端开发-体检预约4.7.1 体检预约4.7.2 预约成功页面展示 4.8 移动端开发-手机快速登录、权限控制4.8.1 手机快速登录4.8.2 权限控制4.8.3 在项目中应用Spring Security4.8.4 显示用户名4.8.5 用户退出 4.9 图形报表ECharts4.9.1 会员数量折线图4.9.2 套餐预约占比饼形图 4.10 POI报表4.10.1 运营数据统计4.10.2 运营数据统计报表导出（EXCEL形式）4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dcfa2348f1c8039836c3fbff7c56e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2900f56feb673e76692603a0d776ee66/" rel="bookmark">
			用jquery来实现轮播图效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示
首先就是布局，在这里面我们会使用div，ul，li等多个标签，
一.html部分的代码如下 &lt;div class="bigbox"&gt; &lt;div class="dianji"&gt; &lt;li class="left"&gt;&amp;lt;&lt;/li&gt; &lt;li class="right"&gt; &amp;gt; &lt;/li&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- 真正要轮播的只有这5张图片 --&gt; &lt;li&gt; &lt;img src="imagess3/gui.jpg" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="imagess3/other.jpg" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="imagess3/huo2.jpg" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="imagess3/long.jpg" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="imagess3/qian.jpg" alt=""&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class="current"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; 注意我们要在最后加上一张和第一张重复的图片，方便后续功能的实现
ol中装的li时下面的小圆点，left，right分别就是左右切换按钮
二 .css部分如下 &lt;style&gt; /* 首先要去除默认浏览器的样式 */ * { margin: 0px; padding: 0px; } li { list-style: none; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2900f56feb673e76692603a0d776ee66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684a8f732893aca2a6e2944094402249/" rel="bookmark">
			理解 Python 的 for 循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本篇博客中，我们将讨论 Python 中 for 循环的原理。
我们将从一组基本例子和它的语法开始，还将讨论与 for 循环关联的 else 代码块的用处。
然后我们将介绍迭代对象、迭代器和迭代器协议，还会学习如何创建自己的迭代对象和迭代器。
之后，我们将讨论如何使用迭代对象和迭代器实现 for 循环，以及利用 while 循环通过迭代器协议实现 for 循环逻辑。
最后，我们将反编译一个简单的 for 循环，并逐步介绍 Python 解释器在执行 for 循环时执行的指令，以满足大家的好奇心。这些有助于理解 for 循环运行时的内部工作原理。
Python的for循环
for 语句是 Python 中执行迭代的两个语句之一，另一个语句是 while。如果你对 Python 的迭代并不是很熟悉的话，Python中的迭代：for、while、break、以及continue语句是一个不错的切入点。
Python 中，for 循环用于遍历一个迭代对象的所有元素。循环内的语句段会针对迭代对象的每一个元素项目都执行一次。暂且可以将迭代对象想象成一个对象集合，我们可以一个个遍历里面的元素。我们将在下一节对迭代器和迭代对象作详细说明。
一个简单的 for 循环
我们先从一个简单 for 循环开始，它遍历一个字符串列表并打印每一个字符串。
如你所见，这个循环实际上遍历了列表中的每一个单词并打印它们。也就是说，在循环的每一次遍历中，变量 word 都被指定为列表中的一个元素，然后执行 for 语句中的代码块。由于列表是一个有序的元素序列，所以循环也是以相同的顺序遍历这些元素。
带有 else 子句的 for 循环
Python 中的 for 循环可以选择是否关联一个 else 子句。else 子句中的代码块是在 for 循环完成后才开始执行的，即在迭代对象中的所有元素都遍历完毕之后。现在我们看一下如何扩展前面的示例以包含一个 else 条件（子句）。
else 子句适用于何时？
你已经注意到，else 子句是在 for 循环完成之后才执行的。那么 else 代码块的意义是什么呢？for 循环之后的语句不是也是同样会执行吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684a8f732893aca2a6e2944094402249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1768ef540b7e587aa6d1cbcddf0351/" rel="bookmark">
			docker镜像运行时指定application文件，docker启动传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker启动传参 使用-e命令 可以多次使用
eg：
docker run -p 8088:8088 -e "SPRING_PROFILES_ACTIVE=test" an-order:v2.0 -- 多次使用 docker run -p 8088:8088 -e "SPRING_PROFILES_ACTIVE=test" -e "read.message=llll" an-order:v2.0 2 编写dockerfile ENTRYPOINT 命令
# Image创建容器时的初始化内存，最大内存，及启动时使用的profile. -c为清除以前启动的数据 # 这里指定了appication-mysql.properties配置文件 ENTRYPOINT ["java","-Xms1024m","-Xmx1024m","-jar","/app.jar","--spring.profiles.active=mysql","-c"] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b332c306d9261edc688bf7ce5669d034/" rel="bookmark">
			matlab绘图相关技巧记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.matlab fo循环 在一个figure上画图，实时清空上一次绘图 for i = 1:5:1800 i one_view = prj(:,:,i); [judge,position] = JudgeView(one_view); figure(1); hold on; h1 = plot(one_view); title(['view :',num2str(i)]) xlabel("channel number"); ylabel("projection"); h2 = scatter(position(:,1) ,position(:,2)); grid on; hold off; pause(0.5); delete(h1); delete(h2); end 2.在三维空间绘制散点时，明明时三维坐标，绘制出来的却是二维的图 原因是，使用了hold on ; hold off
waterTemp = LwAll(:,:,viewIndex); alTemp = LmAll(:,:,viewIndex); OnePrj = prj(:,:,viewIndex); counter = 1; point = []; for i = 1:size(OnePrj,1) for j = 1:size(OnePrj,2) if(waterTemp(i,j) ~=0 || alTemp(i,j) ~= 0) point(counter,:) = [waterTemp(i,j),alTemp(i,j) ,OnePrj(i,j)]; counter = counter +1; end end end % % Lw = reshape(waterTemp,[N_CHANNEL*16,1]); % % Lm = reshape(alTemp,[N_CHANNEL*16,1]); % % PrjValue = reshape(OnePrj,[N_CHANNEL*16,1]); figure(1); hold on; scatter3(point(:,1),point(:,2),point(:,3),'b*'); 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/147/">«</a>
	<span class="pagination__item pagination__item--current">148/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/149/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>