<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04c2a126f3f59e93ad99ba29901a2b5/" rel="bookmark">
			nginx alias和root
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx 目录:
[root@zz conf]# ls -ltr /root/www/backoffice/
total 4
-rwxrwxrwx 1 755 root 18 Dec 29 22:20 index.html
server {
listen 8080;
server_name localhost;
#charset koi8-r;
access_log logs/host.access.log main;
location /backoffice {
root /root/www;
index index.html index.htm;
}
[root@zz sbin]# curl http://192.168.137.200:8080/backoffice/
aaaaaaaa
bbbbbbbb
----------------------------------------------------------------------
location / {
alias /root/www/;
index index.html index.htm;
}
[root@zz sbin]# curl http://192.168.137.200:8080/backoffice/
aaaaaaaa
bbbbbbbb
[root@zz sbin]# ls -ltr /root/www/backoffice/
total 4
-rwxrwxrwx 1 755 root 18 Dec 29 22:20 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04c2a126f3f59e93ad99ba29901a2b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b723d5f980bf2175e577e6ce6bdc0018/" rel="bookmark">
			C#常用类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C#常用类 C#中有一些具有特定功能的类，例如操作字符串的类、用于操作日期的类、生成随机数的类
字符串的基本特征
1、字符串的不可变性
字符串对象一旦创建，就无法对其进行修改。
.NET框架的底层提供了一种机制，当一个字符串已经被创建，那么以后每次创建相同值的字符串时都会直接引用它的地址值，而无需为自己的值开辟新的内存空间，这种机制被称为字符串拘留池机制。
2、string数据类型是一个类，而其他数据类型基本都是机构(struct)。
3、对一个字符串变量赋值后，其实那个变量也就是new后的实例对象。(也就是说string这个类可以不通过new关键字来实例化一个对象，直接赋值也就是对其实例化后的对象赋值)
字符串与字符串数组
可以将字符串看作一个char类型的只读数组，即字符数组。可以通过Length属性来获取字符串长度
二、String和string异同及String类的构造方法 1、String和string异同
string类型是C#语言中用来表示字符串的类型，而String类型是.NET Framework通用类型系统中用来表示字符串的类型。在程序开发过程中，这两种类型之所以都能表示字符串，是因为程序编译时，C#语言中的string类型会被编译成.NET Framework通用类型系统的String类型。
string str=“”;
string str=String.Empty;
这两种空字符串的定义是一样的。
三、String类的静态方法 1、Compare()方法
功能：用于比较两个字符串是否相等，该方法有两个string类型参数，用于接收进行对比的字符串，如果第一个字符串大于第二个字符串，则返回一个大于0的int整数1；如果两个字符串相同，则返回0；若第一个字符串小于第二个字符串，则返回一个小于0的int整数-1。(字母大于数字，同一个字母大写大于小写，可以设置第三个参数为true，表示忽略大小写)
String.Compare(str1, str2,true) 2、Format()方法
Format()方法的作用是格式化字符串，它的用法与Console.WriteLine()非常类似，不同的是Format()方法只能格式化字符串，而Console.WriteLine()可以输出。
string res = String.Format("字符串{0}包含{1}个字符", str, str.Length); 3、IsNullOrEmpty()方法
IsNullOrEmpty()方法用来判断字符串是否为空或长度是否为0，当字符串为空或者长度为0时，返回值为true，否则返回false。
4、Join()方法
Join()方法的作用是使用指定的字符串，将字符串数组中的元素连接起来。
string[] strs = { "字符串", "使用竖线", "连接" }; string res = String.Join("|", strs); 四、String类的实例方法 除静态方法外，String类中还提供了一些方法，这些方法需要先创建实例对象才能被调用，即String类的实例方法。
1、Contains()方法
Contains()方法用于判断一个字符串中是否包含指定字符串。常用格式：
bool Contains（string str）
注意赋值也就是实例化后的对象 if (str1.Contains(str2)) { Console.WriteLine("str2包含在str1中"); } else { Console.WriteLine("str1不包含str2"); } 2、EndsWith()方法
判断当前字符串是否以指定字符串结尾。常用格式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b723d5f980bf2175e577e6ce6bdc0018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d158ec81754a20188e44139de571a991/" rel="bookmark">
			STM32传输FPGA业务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实现功能：
FPGA芯片两个信号管脚分别是TTL_RX与TTL_TX，stm32读取FPGA采集信号TTL_RX的数据，再写到FPGA中通过TTL_TX发送出去，实现FPGA串口功能
2、大概方法：
①、FPGA中FIFO_RX和FIFO_TX,分别负责TTL_RX采集接收与TTL_TX发送功能
②、stm32通过FSMC nand flash 驱动与FPGA通讯，读取FIFO_RX接收到的数据，把想发送的数据写入FIFO_TX中
3、遇到的问题与解决方法：
①什么时候读写FPGA?
方法：FPGA中fifo有空、满、快空、快满信号，可以设置快空、快满触发条件，输出给STM32形成中断触发读写
②怎么保证数据在时间上连续，STM32接收到快满标志，去读FPGA时候，FPGA中FIFO_TX中数据已经发完了，这中间时间误差可能ns级的，但是TTL_TX信号中可能有几ns是默认的值，波特率不高可能看不出误码，但实际存在。
方法：FIFO_TX无数据，输出默认未知值，那么在程序启动时候先往FIFO_TX写入足够TTL_TX发送1~2ms的数据，STM32读写FPGA任务优先级调高，接收到FIFO_RX快满中断读写时间误差在1~2ms以内，那么TTL_TX发送的数据一定是TTL_RX接收的数据
③程序快满设置1024字节触发，但是STM32接收到中断只读1000字节，FIFO_RX为什么出现空信号？
方法：STM32接收FIFO_RX快满中断后在读FPGA数据过程中接收到快满中断丢弃
原因：STM32读FPGA过程中，FIFO_RX中数据剩余1023个，快满标志清零了，但FIFO_RX刚好这时候又采集到TTL_RX数据，恢复到1024个，再次触发快满标志，造成STM32读2*1000数据。
④FIFO_RX出现满标志，并且stm32没有接收到快满中断
原因：fpga启动后FIFO_RX不断接收，STM32可能启动慢或没到读FPGA数据
方法：通过STM32控制FPGA的FIFO启动时间（或操作FPGA且先读fpga，把FIFO_RX读空）
⑤fpga采样时钟2M正常，8M，16M后FIFO_TX再次出现②问题，但是fpga中的fifo资源有限，高速实现2ms缓存需求资源太大，芯片无法满足需求
方法：在STM32添加fifo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ae62dd8464dce97d0a450b30c09a88/" rel="bookmark">
			如何利用小红书笔记API进行高效内容运营？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数字化时代的来临，内容运营在品牌营销中占据了越来越重要的地位。小红书作为全球最大的生活方式分享社区之一，拥有数亿用户和海量的优质内容。通过利用小红书笔记API，内容运营者可以更加高效地管理、发布和推广内容，提升品牌影响力，增加用户互动和转化率。本文将为你详细介绍如何利用小红书笔记API进行高效内容运营。
一、了解小红书笔记API
小红书笔记API（应用程序编程接口）是一种允许开发者与小红书平台进行交互的方式。通过API，我们可以获取小红书上的笔记数据、发布新笔记、管理笔记等。要使用小红书笔记API，首先需要在小红书开放平台上注册账号并创建应用。
二、利用API高效获取笔记数据
通过API，我们可以获取小红书上的笔记数据，包括笔记内容、作者信息、标签、点赞数、评论数等。这些数据可以帮助我们了解用户喜好、竞品动态以及热门话题等信息，为内容创作提供灵感。
以下是使用Python调用API获取笔记数据的示例代码：
import requests import json # 定义API接口地址和请求参数 url = "https://api.xiaohongshu.com/v4/graphql" headers = { "Authorization": "Bearer YOUR_ACCESS_TOKEN" } query = """ { page(channel:"笔记", page:1, size:20){ totalCount, list{ id, title, content, authorId, tags, likes{ totalCount }, comments{ totalCount } } } } """ # 发送请求并处理响应 response = requests.post(url, headers=headers, data={"query": query}) data = response.json()["data"]["page"]["list"] for note in data: print(f"笔记ID: {note['id']}, 标题: {note['title']}, 内容: {note['content'][:100]}...") print(f"作者ID: {note['authorId']}, 标签: {note['tags']}, 点赞数: {note['likes']['totalCount']}, 评论数: {note['comments']['totalCount']}\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4ae62dd8464dce97d0a450b30c09a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6400bde1ac33dd6af88ef37c394edf27/" rel="bookmark">
			编程语言的未来：JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们思考编程语言的未来时，我们不能忽视JavaScript的重要性。作为前端开发者，我们深知JavaScript在开发中的重要性。它不仅改变了我们与网页的交互方式，还推动了整个前端开发领域的发展。
那么，从当前的趋势和技术发展来看，JavaScript的未来将如何呢？
JavaScript的持久地位 JavaScript已经成为现代Web开发的标准语言。据统计，95%以上的网站使用JavaScript，而且这个数字在过去几年中一直在稳步增长。随着React、Vue和Angular等前端框架的普及，JavaScript在构建复杂、交互式的Web应用程序方面发挥着越来越重要的作用。
预计在未来几年中，JavaScript将继续占据主导地位，因为它的语法简单、灵活性强，以及拥有庞大的社区和丰富的生态系统。
TypeScript的崛起 随着项目规模的扩大和复杂性的增加，对静态类型检查的需求也在增长。TypeScript提供了强大的类型系统和静态类型检查，有助于提高代码质量和减少运行时错误。
随着TypeScript生态系统的不断完善，预计未来将有更多的开发者选择使用TypeScript进行开发。
WebAssembly的影响 WebAssembly是一种能够在现代Web浏览器中运行的二进制指令格式。虽然它不是JavaScript，但WebAssembly的设计初衷是为了让开发者在Web上使用任何语言编写高性能应用程序。
通过将其他语言（如C++、Rust等）编译为WebAssembly，开发者可以在Web浏览器中运行高性能的应用程序。随着WebAssembly技术的不断成熟，预计未来将有更多的应用场景涌现。
AI与机器学习的融合 AI和机器学习是当前最热门的技术领域之一。JavaScript由于其灵活性和生态系统的丰富性，已经成为AI和机器学习领域的重要语言。
TensorFlow.js等库的出现使得JavaScript开发者能够轻松地构建和训练机器学习模型，并在浏览器或Node.js环境中运行。预计未来，随着AI和机器学习的普及，JavaScript将在这一领域发挥更大的作用。
结论：未来充满无限可能 从JavaScript的持久地位、TypeScript的崛起、WebAssembly的影响以及AI与机器学习的融合等方面来看，JavaScript语言的未来充满无限可能。
作为前端开发者，我们需要不断关注新技术的发展趋势，掌握最新的编程范式和工具，以适应这个瞬息万变的时代。同时，我们也应该对JavaScript的未来保持乐观态度，相信它将继续引领编程语言的发展潮流。
在未来几年中，我们可能会看到更多新的技术和工具出现，这些技术和工具将进一步推动JavaScript的发展和普及。例如，WebAssembly可能会为JavaScript带来更多的应用场景和性能优势；AI和机器学习的普及可能会为JavaScript带来更多的机会和挑战；新的前端框架和技术可能会出现，改变我们构建和组织代码的方式。
总的来说，JavaScript的未来充满了无限的可能性。作为前端开发者，我们需要时刻保持敏锐的洞察力和开放的心态，以应对未来的挑战和机遇。让我们一起期待着JavaScript的未来发展！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b910951f31ad91612f045145a635a0a/" rel="bookmark">
			什么是计算机视觉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉（Computer Vision）是一门研究如何让计算机能够理解和分析数字图像或视频的学科。简单来说，计算机视觉的目标是让计算机能够像人类一样对视觉信息进行处理和理解。为实现这个目标，计算机视觉结合了图像处理、机器学习、模式识别、计算几何等多个领域的理论和技术。计算机视觉在许多领域和行业中具有广泛应用，如自动驾驶、医疗影像分析、无人机、智能监控、虚拟现实（VR）和增强现实（AR）等。随着深度学习和神经网络技术的发展，计算机视觉取得了许多突破性成果，为实际应用带来了巨大价值。
《计算机视觉处理设计开发工程师》
了解到一项2024年企业和个人都在报考的工业和信息化部电子工业标准化研究院颁发的证书，分享给大家：
为进一步贯彻落实中共中央印发《关于深化人才发展体制机制改革的意见》和国务院印发《关于“十四五”数字经济发展规划》等有关工作的部署求，深入实施人才强国战略和创新驱动发展战略，加强全国数字化人才队伍建设，持续推进人工智能专业人员能力培养和评价，工业和信息化部电子工业标准化研究院牵头研制的SJ/T11805-2022《人工智能从业人员能力要求》已经于2022年7月1日发布实施。依据该标准，工业和信息化部电子工业标准化研究院联合业界企事业单位开发了人工智能专业人员培训项目，并将于北京举办以下证书培训安排：
《计算机视觉处理设计开发工程师》2024年1月24日至28日-北京
培训对象：
证书样式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b478ae013be402d86b05a872aaeb15/" rel="bookmark">
			基于vue2&#43;elementUI年份范围选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于vue2+elementUI实现年份范围选择器，支持时间跨度设置。代码如下：
&lt;template&gt; &lt;el-popover ref="popover" placement="bottom" v-model="showPanel" popper-class="custom_year_range" trigger="manual" @hide="onHide()" v-clickoutside=" () =&gt; { showPanel = false; } "&gt; &lt;div class="_inner floatPanel"&gt; &lt;div class="_inner leftPanel"&gt; &lt;div class="_inner panelHead"&gt; &lt;i class="_inner el-icon-d-arrow-left" @click="onClickLeft"&gt;&lt;/i&gt; &lt;span&gt; {{ leftYearList[0] + '年 ' + '- ' + leftYearList[9] + '年' }} &lt;/span&gt; &lt;/div&gt; &lt;div class="_inner panelContent"&gt; &lt;div :class="{ oneSelected: item === startYear &amp;&amp; oneSelected, startSelected: item === startYear, endSelected: item === endYear, betweenSelected: item &gt; startYear &amp;&amp; item &lt; endYear, disabledSelect: compareNum &amp;&amp; (compareNum - maxRange &gt; item || compareNum + maxRange &lt; item) }"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b478ae013be402d86b05a872aaeb15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdc164fa9b631bdc7897cfc088e997d/" rel="bookmark">
			性能测试之（三）：性能指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 性能指标 一些经过运算得出的结果，来衡量某种操作性能的统称，用实际数据与指标数据作对比，达成需求则无问题。比如：错误率 0.5%
常见性能指标：响应时间、并发量、吞吐量、错误率、点击率、资源利用率
一、响应时间 响应时间是指用从客户端发起一个请求开始，到客户端接收到从服务器返回的结果，整个过程所耗费的时间 响应时间 = 网络时间+应用程序处理时间 二、并发数 系统用户数：系统注册的总用户数量 在线用户数：某段时间内访问系统的用户数，这些用户并不一定同时像系统提交请求。 并发用户数：某一时刻同时向系统提交请求的用户数 三、吞吐量 单位时间内处理 的 客户端请求数量，直接体现软件系统的性能承载能力 每秒事务数TPS、每秒查询数QPS 衡量服务器服务器具体性能处理能力
1、每秒查询数QPS 服务器每秒钟处理的接口请求数量（一个服务器可有多个接口）
2、每秒事务数TPS（Transactions Per Second） 服务器每秒钟处理的事务请求数量，一个事务通常是值得界面上的一个操作，一个事物可有包含一个或多个请求接口
TPS = 并发数/平均响应时间
四、点击数 点击数 是衡量Web服务器处理能力的一个重要指标 是页面（html、js、图片等）加载时，向服务器发送的请求数量。 可以用每秒点击数来衡量服务器的处理能力 五、错误率 系统在高负载情况下，失败业务的占比。错误率=（失败业务数/总业务数）*100% tips:1、不同系统对错误率的要求不同，但一般不能超过0.5% 2、稳定性较好的系统，其错误率应由超时引起，即超时率 六、资源利用率 是指系统各种资源的使用情况，一般用"资源的使用量/总的资源可用量*100%"形成资源利用率的数据 通常：建议CPU不高于80(+-5)%、内存不高于80%、磁盘不高于90%、网络不高于80% 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644136e568352e633a32d0d5afdfd556/" rel="bookmark">
			接口测试工具：Postman的高级用法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman 是一款功能强大的 API 开发和测试工具，以下是一些高级用法的详细介绍和操作步骤。
一. 环境和全局变量 环境变量允许你设置特定于环境（如开发、测试、生产）的变量，全局变量则在所有环境中都能访问。
操作步骤：
1. 转到左侧的侧边栏，点击"Environments"。
2. 点击"Add"按钮创建一个新环境。
3. 输入环境名称。
4. 添加变量名和对应的初始值以及当前值。
5. 点击"Add"保存环境。
6. 在发送请求时，选择对应的环境即可使用其中的变量。
二. 预请求脚本（Pre-request Scripts） 预请求脚本允许你在发送请求之前执行脚本，可以用于设置变量、生成时间戳等。 操作步骤：
1. 打开一个请求。
2. 转到"Pre-request Script"标签页。
3. 编写 JavaScript 代码。
4. 发送请求，代码将在请求发出前执行。
三. 测试脚本（Tests） 在请求执行后，可以用测试脚本来验证响应。
操作步骤：
1. 打开一个请求。
2. 转到"Tests"标签页。
3. 使用 JavaScript 和 Postman 断言库编写测试逻辑。
4. 发送请求，测试将在响应返回后执行。
四. 链式请求（Request Chaining） 可以将一个请求的响应数据用作另一个请求的输入。
操作步骤：
1. 在"Tests"脚本中解析第一个请求的响应体。
2. 使用pm.environment.set设置环境变量。
3. 在随后的请求中使用这些变量。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：691998057【暗号：csdn999】 五.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/644136e568352e633a32d0d5afdfd556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac855e60b15058d4ec8963cd71960da/" rel="bookmark">
			三巨头对决：深入了解pnpm、yarn与npm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的博客，代码的世界里，每一行都是一个故事 三巨头对决：深入了解pnpm、yarn与npm 前言包管理器简介npm（Node Package Manager）：Yarn：pnpm（Performant Npm）： 2. 性能比较：安装速度：磁盘空间： 3. 特性和优势：依赖管理：私有仓库和安全：社区和生态系统： 使用场景和最佳实践项目适用性：团队协作：迁移策略： 总结： 前言 在JavaScript的世界中，有三个强大的武器帮助开发者管理复杂的项目依赖：pnpm、yarn和npm。它们像是我们的盔甲和剑，保护和加速我们的开发进程。但是，每个工具都有其独特的魔法和力量。让我们开始一场神奇的旅程，探索它们的秘密，找到最适合你的那一个。
包管理器简介 npm（Node Package Manager）： 定义：npm 是 Node.js 的默认包管理器，它是 JavaScript 世界中最大的软件注册处，用户可以从中获取和发布包（package）。特点： 庞大的社区：拥有最大的模块生态系统，几乎所有你能想到的功能，都有相应的包可以使用。易用性：直接集成在 Node.js 安装包中，易于开始使用。脚本支持：支持强大的脚本功能，可以简化很多开发、构建和部署过程。 挑战： 依赖深度：可能会产生庞大的node_modules目录，导致安装速度缓慢和磁盘空间大量占用。版本一致性：不同环境下可能因为依赖版本微小差异导致运行结果不一致。 Yarn： 定义：由 Facebook 开发的包管理工具，旨在解决 npm 的一些问题，提供更快的依赖安装速度和更严格的依赖控制。特点： 速度快：并行安装机制使得速度比 npm 快很多。lockfile：引入yarn.lock文件来锁定依赖的版本，确保不同设备和环境下依赖的一致性。更好的安全性：提供了更多的安全特性和工具来保障包的安全。 挑战： 学习曲线：虽然与npm类似，但有些命令和概念需要用户新学习。兼容性：虽然努力保持与npm的兼容性，但在某些情况下可能会遇到问题。 pnpm（Performant Npm）： 定义：一个更为高效的包管理器，致力于提高性能和减少磁盘空间的占用。特点： 空间效率：通过硬链接和符号链接的方式复用已下载的包，大幅减少node_modules的体积。高性能：并行操作和内容寻址存储机制提高了性能。严格的依赖平面：为每个包提供一个独立的依赖视图，减少包之间的冲突和意外影响。 挑战： 社区支持：虽然在不断增长，但社区和模块生态系统仍然不如npm和yarn那么庞大。兼容性问题：在某些复杂场景下可能会遇到兼容性问题。 了解这三个包管理器的基本特性和差异，可以帮助开发者更好地选择适合自己项目和工作流的工具。在实际使用中，你可能需要根据项目具体需求、团队偏好以及生态系统支持来做出选择。
2. 性能比较： 安装速度： npm： 冷缓存（无缓存数据）：传统上，npm在冷缓存时的安装速度较慢，因为它需要从远程仓库下载所有依赖项。热缓存（已有缓存数据）：npm v5及以上版本引入了package-lock.json，在热缓存情况下可以加快重新安装速度，但仍然可能不如yarn和pnpm快。 Yarn： 冷缓存：Yarn在首次安装时使用并行下载，性能通常优于npm。热缓存：Yarn的yarn.lock文件确保了依赖版本的一致性，同时缓存机制也加快了再次安装的速度。 pnpm： 冷缓存：pnpm通过使用硬链接和符号链接的方式来复用已下载的包，即使在冷缓存下也能有很好的表现。热缓存：由于其独特的存储方式，pnpm在热缓存情况下可以非常迅速地完成依赖安装。 磁盘空间： npm：传统上会为每个项目单独存储依赖项，这意味着相同的包在不同项目中会重复下载和存储，占用更多磁盘空间。Yarn：Yarn也为每个项目存储依赖项，但通过更好的缓存管理和yarn.lock文件来优化存储。它不会像npm那样减少磁盘空间使用，但提供了更一致的依赖管理。pnpm： 硬链接和符号链接：pnpm创建了一个中央存储，所有下载的包都存储在这里，并通过硬链接和符号链接在项目中使用。这意味着一个包无论被多少项目使用，都只存储一份实体，极大地节省了磁盘空间。严格的依赖平面：pnpm为每个包提供独立的依赖视图，减少了不必要的包冗余。 3. 特性和优势： 依赖管理： lockfile： 概念：lockfile是一个特定格式的文件，它精确记录了项目依赖的每个包的版本号。这确保了不同的开发环境和部署环境使用完全相同的依赖，从而避免了“在我机器上运行正常”这类问题。npm：使用package-lock.json来锁定依赖版本。Yarn：引入了yarn.lock文件，提供了更快的安装速度和更一致的依赖解析。pnpm：使用shrinkwrap.yaml作为其lock文件，与npm和Yarn的锁文件类似，但结构和算法有所不同，旨在提供更严格的依赖管理。 私有仓库和安全： 私有仓库：私有仓库允许团队存储和管理内部的、私有的包，而不是公开到全球的npm仓库。 npm：可以通过npm Enterprise或其他第三方服务如Nexus、Artifactory来搭建私有仓库。Yarn：支持私有npm仓库，并且可以很容易地与这些仓库一起使用。pnpm：同样支持私有仓库，可以与任何兼容npm的私有仓库一起工作。 安全特性： npm：提供了npm audit来分析和修复安全漏洞。Yarn：提供了yarn audit，并在Yarn 2中引入了插件系统，可以增加额外的安全检查。pnpm：虽然没有内置的安全审计命令，但可以通过第三方工具或与npm、Yarn的安全功能配合使用。 社区和生态系统： npm： 社区：作为最早的包管理器，拥有最大的用户基础和社区支持。模块数量：提供了数百万个包，是目前最大的JavaScript包注册处。 Yarn： 社区：由Facebook背书，并且受到了许多大公司和开发者的支持。模块数量：由于与npm注册处兼容，用户也可以访问所有npm提供的包。 pnpm： 社区：社区相对较小，但正在快速增长，并且受到了一些大型项目和公司的支持。模块数量：与npm和Yarn一样，可以访问所有npm注册处的包。 使用场景和最佳实践 项目适用性： 小型项目： npm：由于其广泛的支持和简单性，对于小型项目来说是一个很好的选择。Yarn：对于希望提高安装速度和确保依赖一致性的小型项目也是合适的。pnpm：对于磁盘空间有限的小型项目，pnpm的空间优化特性非常有用。 大型/复杂项目： Yarn：Yarn的workspaces特性使得管理多包项目变得简单，非常适合大型项目和单体仓库。pnpm：凭借其高效的性能和严格的依赖隔离，非常适合大型和高度模块化的项目。 微服务： Yarn/Pnpm：都支持工作区的概念，有助于在单个仓库中管理多个服务。 团队协作： 确保一致性：无论选择哪个包管理器，都应在团队内部达成一致，确保所有成员都使用相同的工具和版本，避免依赖不一致问题。文档和规范：创建明确的文档和规范，指导团队成员如何正确使用包管理器和lockfile。持续集成/持续部署(CI/CD)：在CI/CD流程中集成包管理器，确保自动化过程中的依赖安装与开发环境保持一致。 迁移策略： 评估原因：在迁移前，明确迁移的动机和目标，例如是否为了提高安装速度、减少磁盘空间占用或改善依赖管理。备份当前状态：在进行任何迁移步骤之前，备份当前项目的状态，包括node_modules文件夹和现有的lock文件。逐步迁移：在小规模或分支上测试新的包管理器，观察是否有任何问题或不兼容之处。更新文档：一旦迁移完成，更新项目文档，包括README和开发者指南，确保团队成员了解如何使用新的包管理器。团队培训：对团队成员进行新工具的培训，特别是如果工具带来了工作流的重大变化。 总结： 每个包管理器都有其适用的场景和特定的优势。选择最适合的工具需要考虑项目的大小、复杂度、团队协作需求以及迁移的可行性。最佳实践包括确保团队内部一致性、文档和规范的清晰以及在迁移过程中的细致规划和测试。通过明智的选择和规范的使用，可以最大化包管理器的效益，提高项目的开发效率和稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a52eae013bd977f24d6edddc39439b44/" rel="bookmark">
			docker学习笔记05-TCP远程连接与docker compose简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置docker客户端远程访问 A.在另一台机器上安装客户端 远程访问，再搭建一台测试机，先安装包dockercli 客户端
yum install -y yum-utils --或者用阿里源 快些 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum -y remove runc --只安装客户端 sudo yum install docker-ce-cli B.docker服务服务端开启访问端口 开启远程访问 vi /usr/lib/systemd/system/docker.service 找到 [Service] 节点，修改 ExecStart 属性，增加 -H tcp://0.0.0.0:2375 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375 这样相当于对外开放的是 2375 端口，当然也可以根据自己情况修改成其他的 重新加载配置 systemctl daemon-reload systemctl restart docker Docker的Client和Engine之间的通讯有一下几种方式
Unix Socket 这是类unix系统进程间通讯的一种方式，当Client操作本机的Engine是就是使用这种方式。缺省的socket文件是unix:///var/run/docker.sockSystemd socket activation : 这是systemd提供的一种为了服务并行启动设计的socket，缺省值为fd:// TCP : 上面两种都是只能连接本地Engine，需要连接远程Engine，必须在服务端开始TCP连接。此连接为不安全连接，数据通过明文进行传输。缺省端口2375。TCP_TLS : 在TCP的基础之上加上了SSL的安全证书，以保证连接安全。缺省端口2376 C.查看一下是否能访问端口 浏览器输入格式为：http://ip:2375/version 测试一下
这样就是端口开通成功了
D. 在客户端上配置环境变量，实现远程访问 这里就把这个变量写入环境变量文件中就行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a52eae013bd977f24d6edddc39439b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a765ffd20345176c0176f2fac833f3f8/" rel="bookmark">
			浏览器强缓存和协商缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 强缓存是什么？
强缓存是利用 http 的返回头中的 Expires 或者 Cache-Control 两个字段来控制的，用来表示资源的缓存时间
Expires
缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age+请求时间，需要和 Last modified 结合使用。但它的优先级比Cache-Control 低。
Expires 是Web服务器响应消息的头字段，在响应的HTTP请求时告诉浏览器在过期时间前，浏览器可以直接从浏览器缓存取数据，而无需再次请求 Cache-Control
Cache-Control 是一个相对时间，例如 Cache-Control:3600，代表着资源的有效期是 3600秒。由于是相对时间，并且都是与客户端时间比较,所以服务器与客户端时间偏差也不会导致问题。 Cache-Control 与Expires 可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。
浏览器的缓存主要是为了提高访问效率，强制缓存，第一次访问一个网站的时候，里面的静态资源如图片、CSS、JS 、icon这些资源实际上是从服务器上下载的，刷新网页这个资源是没有必要在服务器上重新去请求的，像这样的资源，浏览器会默认是一些强制缓存，强制缓存当用户第二次访问的时候，它不会再服务器上重新下载资源了，同样返回200状态码，但这个资源会从浏览器的本地缓存里面去取，这种第二次取的缓存的状态就是一种强制缓存。 协商缓存是什么？
HTTP请求的状态码为 304
和后台去协商资源，要不要对它进行缓存；如果是第一次请求,返回状态码200,在响应头中返回cache-Control，用来控制缓存使用的时间 / 方式(私有缓存和共享缓存)，还会返回一个唯一标识 etag（可以理解为内容资源的一个hash或者一个唯一的标识）在第二次发起请求时,先查看 max-age， 如果过期了，在请求头设置 If-None-Match 等于刚刚 Etag的值,去后台对比,如果 etag 值相同，（或者对比Last Modified的一个时间）证明后端没更新,所以返回 304状态，浏览器接收到304状态之后，判断这个资源无变化，只需从本地把缓存的资源继续使用(也是协商缓存)。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23239b37e2f807162512ed40716889a1/" rel="bookmark">
			《深入理解JAVA虚拟机笔记》运行时栈帧、方法分派、动态类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行时栈帧结构 Java 虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在 Java 编译程序代码时，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的 Code 属性之中。换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的内存布局形式。
一个线程中的方法调用链可能会很长，以Java 程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的、生效的，其被称为“当前栈帧（Current Stack Frame）”，与之关联的方法被称为“当前方法（Current Method）”。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧结构如下图所示：
局部变量表 局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。
局部变量表的容量以变量槽（Variable Slot）为最小单位。《Java 虚拟机规范》中并没有明确指出一个变量槽应占应用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、 byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储，它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化，保证了即使在64位虚拟机中使用了64位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段让变量槽在外观上看起来与32位虚拟机中的一致。
一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference 和returnAddress这8种类型。前面6种不需要多加解释，读者可以按照Java语言中对应数据类型的概念去理解它们（仅是这样理解而已，Java语言和Java虚拟机中的基本数据类型是存在本质差别的），而第7种reference类型表示对一个对象实例的引用，《Java 虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息。第8种returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转，但现在也已经全部改为采用异常表来代替了。
对于 64 位的数据类型，Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。Java 语言中明确的 64 位的数据类型只有 long 和 double 两种。这里把long和double数据类型分割存储的做法，与Java内存模型中“long和double的非原子性协定”，允许把一次long和double数据类型读写分割为两次 32 位读写的做法有些类似。不过，由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。
Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。
当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。
[隐式参数this][显示的参数列表][方法内的局部变量] 为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的，方法体中定义的变量，其作用域不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。不过，这样的设计除了节省栈帧空间以外，还会伴随有少量额外的副作用，例如在某些情况下变量槽的复用会直接影响到系统的垃圾收集行为。
// 代码清单 8—1 局部变量表槽复用对垃圾收集的影响之一 public static void main(String[] args) { byte[] placeholder = new byte[64 * 1024 * 1024]; System.gc(); // 没有回收上面的 64M 空间 } 代码清单 8-1 中的代码很简单，向内存中填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上 “-verbose:gc” 来看看垃圾收集的过程，发现在System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23239b37e2f807162512ed40716889a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b032d5d1971866757d3f238a3e0613f/" rel="bookmark">
			Ubuntu 20.04 上安装和使用 Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 20.04 上安装和使用 Docker
在 Ubuntu 上安装 Docker 非常直接。我们将会启用 Docker 软件源，导入 GPG key，并且安装软件包。
一、开始安装 首先，更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源：
sudo apt update sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common 使用下面的 curl 导入源仓库的 GPG key：
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 将 Docker APT 软件源添加到你的系统：
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" 二、安装 Docker 最新版本 运行下面的命令:
sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 三、安装指定版本 首先列出 Docker 软件源中所有可用的版本：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b032d5d1971866757d3f238a3e0613f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005db6a16874961fce4c2db0384b6230/" rel="bookmark">
			保时捷版小米汽车来了，9.9万不可能！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米汽车，来了！
2021年3月30日，雷军哽咽着立下他创业路上的一个重大flag：
“小米汽车是我人生之中最后一次重大的创业项目，愿意押上人生全部的声誉，亲自带队，为小米汽车而战。
”2023年12月28日，雷军在小米汽车技术发布会上讲到：
他谈到：小米造车的出发点，是打造先进的「移动智能空间」。从2021年3月正式宣布造车以来，小米汽车团队，就下定决心，十倍投入，从底层核心技术做起，认认真真做一辆好车，我们的目标是通过15到20年的努力，成为全球前五的汽车厂商，为中国汽车工业全面崛起而奋斗。 今天下午2点，小米汽车召开技术发布会。我也是早早就守在屏幕旁，对小米新车充满期待。
发布会我全程看完，其中有几个点印象极为深刻。
小米汽车非常专注电动车核心技术
就比如：电机是电动汽车最核心的技术，直接决定了汽车的性能。
小米官宣造车后，首先立项的就是自研自产的超级电机，小米从底层技术做起，组建了100人的专家团队，一次性做出了两款超级电机：V6和V6s，都达到了21000转！目前已量产，将搭载于小米SU7 首批车型上。
实际情况还不止于此。
21000转的已经装车，行业领先。
27000转的2025年量产，全球第一。
35000转的已经预研成功。
电机技术，小米实现了三代同步研发：成熟一代、研发一代、预研一代。
第二个，电池！小米自研了全新超级800V碳化硅高压平台，是真800V，最高电压高达871V。还与宁德时代一起投入上千名研发工程师，历时两年多共同研发小米800V高压电池包。
小米CTB电池包+地板厚度仅为120mm，实现了全球领先的体积效率77.8%，技术平台能力上限可达到150kWh，续航超过1200km。
再比如，小米全栈自研的9100t大压铸集群。
2020年，特斯拉开启了大压铸时代，在特斯拉上海工厂率先实现6000吨大压铸量产，将70个零件整合成了一个。
大压铸的确是趋势，效率特别高，但是投资大，难度高，小米直接建厂自己研发。
对于大压铸技术，小米全栈自研，不仅自研了材料，还自研了设备集群系统，几乎完成了大压铸产业链里所有环节的自研。
大家比较关心的另一个点是智能驾驶！
发布会上的一段视频令人印象深刻。通过智能驾驶，小米汽车能实现精准泊入0.05m的机械库位。
反正我自己停车时，遇到这种偏窄的机械车位，一般就选择放弃了。
雷军讲到，这点还将坚定的持续投入，保持感知技术，底层技术的持续领先，实现在2024年进入智能驾驶第一梯队的目标。
性能上，小米汽车也堪称怪兽级别！
小米SU7零百加速直接飙到2.78秒，这样的成绩直接超过了保时捷Taycan Turbo，对于电车来说，零百加速和最高时速很难兼得，SU7最高车速达到了265km/h，同样超越保时捷Taycan Turbo 260km/h。
雷总还欢迎大家帮我们测试一下，看看跟行业公认顶尖的保时捷相比哪个更好。
发布会上讲的核心技术点还有不少，这里我不再一一列举，感兴趣的可以随时看回放。
但很明显的一点感悟是，在很多核心技术上，小米直接投入自研的决心和能力，不但敢于投入去做，还能做到行业领先！这点是很令人敬佩的。
在小米汽车技术发布会上，雷军分享了小米汽车未来的目标和愿景。
雷军表示，小米汽车的目标是媲美保时捷、特斯拉，打造汽车工业新时代的梦想之车，做好看、好开、舒适、安全的移动智能空间，为中国汽车工业全面崛起而奋斗。
长期目标方面，雷军重申将从底层核心技术出发和“十倍投入”的决心，最终目标是通过15-20年的努力，成为全球前五的汽车厂商。
无论这个时代有多少宏大叙事，无论你有多少责任与担当，每个人的心里，都有一个奔涌澎湃的梦，都有一个自由无垠的向往。
当然，目前我们看到的小米汽车，在PPT上的各项指标参数都遥遥领先，真正实际驾驶体验，确实还有待市场的检验。
等上市了，有机会先去试驾体验一下。
写在最后
AI变现训练营第五期，正式开启招募！最后3天了！
这次为了迎接2024新年我们搞一场大促。力度史无前例，报‮的名‬朋友立‬享满300抵500，每天‮有仅‬一‮优个‬惠‬名额，先‮先到‬得！
对于我公众号粉丝，加甜甜备注“微笑”，会额外送你一份价值199元的《AI代写实战操作手册》。
注意！添加务必备注：【微笑】，否则你拿不到实战操作手册。
文末推荐安老师的新书！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194a084d2ea2c637a32dbbe5e227dfd0/" rel="bookmark">
			Electron &#43; Vue3 开发桌面应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、搭建项目1、创建 Vue 项目2、安装 Electron3、运行 Electron4、Vue 和 Electron 结合5、其它配置6、其它问题（1）热更新失效、控制台报错 二、打包1、安装 electron-builder2、打包配置（1）修改公共基础路径（2）修改 Electron 配置（3）打包配置（3）打包 3、其它问题（1）web和客户端同时部署（2）刷新页面后报错问题（3）不带协议的 url 被解析为 file 协议问题（4）存取 `cookie` 问题（5）限制只能打开一个窗口（6）关闭窗口时提示 三、代码签名（1）windows（2）mac 四、自动更新 相关文档
Vite: https://vitejs.cn
Vue : https://cn.vuejs.org
Electron: https://www.electronjs.org/
electron-builder: https://github.com/electron-userland/electron-builder
concurrently: https://github.com/open-cli-tools/concurrently
示例环境
电脑： MacBook Pro (13-inch, M1, 2020)
系统： macOS 11.6
Node 版本： v16.14.0
npm 版本： v7.1.2
Electron 版本： v20.1.0
Vue 版本： v3.2.37
一、搭建项目 1、创建 Vue 项目 参考：https://cn.vuejs.org/guide/quick-start.html
确保你安装了最新版本的 Node.js，然后在命令行中运行以下命令：
npm init vue@latest 这一指令将会安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示，本项目只做示例，所以只选了 Vue Router ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/194a084d2ea2c637a32dbbe5e227dfd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dbfbf3a649674a84f16f73e6260f21e/" rel="bookmark">
			clickhouse连接工具dbeaver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 地址 地址： Download | DBeaver Community
安装 表引擎 表引擎之TinyLog
以列文件的形式保存在磁盘上，不支持索引，没有并发控制。一般保存少量数据的小表，
生产环境上作用有限，多用于平时练习测试用。
内存引擎， 数据以未压缩的原始形式直接保存在内存当中，服务器重启数据就会消失。
读写操作不会相互阻塞， 不支持索引。 简单查询下有非常非常高的性能表现（超过 10G/s） 。
一般用到它的地方不多，除了用来测试，就是在需要非常高的性能，同时数据量又不太
大（上限大概 1 亿行）的场景。
MergeTree
ClickHouse 中最强大的表引擎当属 MergeTree（合并树）引擎及该系列（*MergeTree）中的其他引擎， 支持索引和分区， 地位可以相当于 innerdb 之于 Mysql。 而且基于MergeTree，还衍生除了很多小弟，也是非常有特色的引擎。
连接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186d40c587ac1024305bd09b374f508f/" rel="bookmark">
			VScode的入门手册(IDEA迁移到VScode)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从IDEA迁移到VScode的过程中，会有很多不适应的地方，下面算是一篇VScode的入门手册，也可以说是从IDEA迁移到VScode的手册。
命令面板（Command Palette） 允许你快速访问和执行命令。
在 Visual Studio Code 中，你可以通过以下步骤打开命令面板：
·按下 F1 键，或者
·按下 Ctrl+Shift+P（在 Mac 上是 Cmd+Shift+P）
打开命令面板后，你可以开始输入命令的名称，它会显示一个匹配你输入的命令列表。然后，你可以使用上下箭头键来选择一个命令，然后按回车键来执行它。
如下：
定义与引用 Ctrl+鼠标左键点击函数名或者类名即可跳转到定义处，在函数名或者类名上按F12也可以实现同样功能。调到定义处后，再对定义执行相同操作，就可以找到它的引用处。
注记：mac上是command+点击。
这个方式跟IDEA不一样，习惯了使用command+B了，因此修改快捷键如下：
打开命令面板，可以通过快捷键Ctrl+Shift+P（Windows）或Cmd+Shift+P（Mac）来打开。在命令面板中输入Keyboard Shortcuts，然后选择Preferences: Open Keyboard Shortcuts。也可以通过左下角的设置按钮来打开 在打开的键盘快捷键设置页面中，你可以搜索你想要修改的命令，然后点击相应命令行右侧的铅笔图标进行修改。
在弹出的输入框中，按下你想要设置的新快捷键组合，然后按Enter确认。
配置如下即可。
查找子类与子接口 IDEA在类/接口的左边会有一个按钮，查找该类的子类/子接口。
vscode中有这些功能Go to Implementations，但是没有提供这种方便的按钮。
给它配置一个快捷键 command+D。
查找接口方法的具体实现，查找子类方法对应的接口定义 如下图
第一个功能：查找接口方法的具体实现，其实就是上一小节的Go to Implementations功能，因此command+d即可。
第二个功能：查找子类方法对应的接口定义，对应vscode的Go to Declaration，因此也将它设置快捷键 Command+D，但这会让Go to Implementations失效。
因此让Go to Declaration改成command+shift+d。
搜索 当前文件搜索
command + f
全局搜索
command + shift + f
全局搜索其实就是左侧工具栏这里
但是注意，vscode中的全局搜索并不会搜索到java依赖库里的类等内容！只会对当前项目里的内容进行全局搜索。
要搜索java依赖库里的内容，
·如果想要搜索的类在你的代码中，则使用上面的查找定义即可。
·如果想要搜索的类不在你的代码中，可以尝试在 "Command Palette"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/186d40c587ac1024305bd09b374f508f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7abd700921c03d9541e9e0fe8e045638/" rel="bookmark">
			Flink（十一）【状态管理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink 状态管理 我们一直称 Flink 为运行在数据流上的有状态计算框架和处理引擎。在之前的章节中也已经多次提到了“状态”（state），不论是简单聚合、窗口聚合，还是处理函数的应用，都会有状态的身影出现。状态就如同事务处理时数据库中保存的信息一样，是用来辅助进行任务计算的数据。而在 Flink 这样的分布式系统中，我们不仅需要定义出状态在任务并行时的处理方式，还需要考虑如何持久化保存、以便发生故障时正确地恢复。这就需要一套完整的管理机制来处理所有的状态。
1、Flink 中的状态 在流处理中，数据是连续不断到来和处理的。每个任务进行计算处理时，可以基于当前数据直接转换得到输出结果；也可以依赖一些其他数据。这些由一个任务维护，并且用来计算输出结果的所有数据，就叫作这个任务的状态。
1.1、概述 在 Flink 中，算子任务可以分为有状态和无状态两种情况。
1.1.1、无状态算子任务 无状态的算子任务只需要观察每个独立事件，根据当前输入的数据直接转换输出结果。比如我们之前学的 map、flatMap、filter 等，计算时不依赖其它数据，就属于无状态的算子。
1.1.2、有状态算子任务 而有状态的算子任务则除了当前数据外，还需要一些其他数据来得到计算结果。这里的“其他数据”就是所谓的状态（State）。比如我们之前学的 聚合算子、窗口算子都属于有状态的算子。
比如我们之前窗口函数中学的增量聚合函数，每来一条数据它都会把处理后的结果保存到一个中间值，当窗口内再来一条数据就更新这个中间值，这个中间值就是所谓的状态。
再比如我们的全窗口函数，它会把来的所有数据都保存到一个中间值当中，直到窗口关闭时才会触发计算，同样，这个中间值就是所谓的状态。
此外还有我们的一些聚合算子比如 sum、min、max 等，它肯定是要把中间结果存储起来的，所以这都叫有状态算子。
1.2、状态的分类 1.2.1、托管状态（Managed State）和原始状态（Raw State） Flink 的状态有两种：托管状态（Managed State）和原始状态（Raw State）。托管状态就是由 Flink 统一管理的，也就是管理状态的存储、访问、故障恢复和重组等一系列问题都由 Flink 实现，我们只要调接口就可以；而原始状态则是自定义的，相当于就是开辟了一块内存，需要我们自己管理，实现状态的序列化和故障恢复。
通常我们都是采用 Flink 托管状态来实现需求。只有在遇到托管状态无法实现的特殊需求时，我们才会考虑使用原始状态；一般情况下不推荐使用。
1.2.2、算子状态和按键分区状态 我们知道在 Flink 中，一个算子任务会按照并行度分为多个并行子任务执行，而不同的子任务会占据不同的任务槽（task slot）。由于不同的 slot 在计算资源上是物理隔离的，所以 Flink能管理的状态在并行任务间是无法共享的，每个状态只能针对当前子任务的实例有效。而很多有状态的操作（比如聚合、窗口）都是要先做 keyBy 进行按键分区的。按键分区之后，任务所进行的所有计算都应该只针对当前 key 有效，所以状态也应该按照 key 彼此隔离。在这种情况下，状态的访问方式又会有所不同。
基于这样的想法，我们又可以将托管状态分为两类：算子状态和按键分区状态。
（1）算子状态（Operator State） 状态作用范围限定为当前的算子任务的各个子任务，也就是只对当前并行子任务实例有效。这就意味着对于一个并行子任务，占据了一个“分区”，它所处理的所有数据都会访问到相同的状态，状态对于同一任务而言是共享的。
算子状态可以用在所有算子上，使用的时候其实就跟一个本地变量没什么区别——因为本地变量的作用域也是当前任务实例。在使用时，我们需要进一步实现 CheckpointedFunction 接口 。
新版本的 Flink 重构了 Source （也就是使用 fromSource 的写法），所以新版本则需要继承 SourceReaderBase 抽象类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7abd700921c03d9541e9e0fe8e045638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41bea100632363ccefbd675673bc3ed7/" rel="bookmark">
			《基于 Vue 组件库 的 Webpack5 配置》- 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Vue2 项目升级到 Webpack5 后，相关的配置也有所变化！此篇以记录和总结，共同学习 Webpack ~
推荐相关文章：
《Vue2.x 组件库 Webpack3 升 5》《Vue2.x 项目 Webpack 4 升级 5（半自动升级）》 配置 1. 模式 Mode 一定要配置 模式 Mode，这里有个小知识点，环境变量 process.env.NODE_ENV
module.exports = { mode: 'production',// process.env.NODE_ENV 或 development, } 2. vue-loader 一定要配置 vue-loader
Vue Loader v15 现在需要配合一个 webpack 插件才能正确使用；
一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件；
vue-loader 和 vue-template-compiler 要一起安装，以保证版本的一致性。npm install -D vue-loader vue-template-compiler；
package.json 的 webpack 中必须配置该插件，如下
const { VueLoaderPlugin } = require('vue-loader') module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41bea100632363ccefbd675673bc3ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91bf622877de945437a858f86663100f/" rel="bookmark">
			el-date-picker 日期组件切换的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-date-picker 日期组件切换的坑 问题描述：
问题1. 根据类型切换需要的时间选择器组件（搜索栏是一个form组件，里面有input、select、picker等，在使用的页面里传入指定的类型就能展示）第一次按顺序切换日常发，周常发，月常发是没问题的，但是当第二次选择周常发时，选择器无变化，然后再一次切换会出现上一次应该出现的选择器，并且会有 问题2. 选择器错位的现象 解决：
传给后端的值为 startTIme、endTime但实际选择器保存的是一个未格式化的时间，问题1：应该在每次切换select值后删除日期的值（为了处理后端需要的数据格式因此日 周 月保存的时间值是同一个）问题2：在form组件中给每个picker添加key 完整的formComponent组件
&lt;!-- * @Description: form组件 页面 * @Use: type可选值：'',numberInput,select,dept,radio,switch,date,daterange,dateNoTime,datetimerange * @Author: mhf * @Date: 2023-06-29 17:08:33 --&gt; &lt;!-- eslint-disable vue/no-mutating-props --&gt; &lt;template&gt; &lt;div class="search-component"&gt; &lt;!-- 表单区域 --&gt; &lt;el-form ref="formRef" :model="form" :inline="inline" :rules="formRules"&gt; &lt;el-form-item v-for="(item, index) in formLabel" :key="index" :label="item.label + ' :'" :prop="item.value" &gt; &lt;el-input v-if="!item.type" v-model.trim="form[item.value]" :placeholder="'请输入' + item.label" size="small" :type="item.type ? item.type : 'text'" /&gt; &lt;el-input v-if="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91bf622877de945437a858f86663100f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70801595d2d72007b9b304444eb60ad8/" rel="bookmark">
			论文阅读——Slide-Transformer（cvpr2023）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Slide-Transformer: Hierarchical Vision Transformer with Local Self-Attention
一、分析
1、改进transformer的几个思路：
（1）将全局感受野控制在较小区域，如：PVT，DAT，使用稀疏全局注意力来从特征图选择稀疏的键对值，并且在所有查询中共享它们。
（2）就是Swin Transformer这条窗口注意力范式，输入被分为特殊设计的窗口，特征在窗口中提取并融合。非常有效，但是有一些局限性，一方面，稀疏全局注意力在捕捉局部特征方面往往较差，并且容易受到关键和值位置的影响，在这些位置，其他区域中的信息特征可能会被丢弃。另一方面，窗口注意可能会阻碍跨窗口通信，这又引入了额外的设计，如窗口偏移，从而对模型结构设置限制。
一个自然有效的替代方案不是缩小全局感受野，而是通过将每个查询的感受野约束在其自己的相邻像素中来采用局部注意力。与前面提到的注意力模式相比，局部注意力具有与平移等变和局部归纳偏差卷积的优点，同时也享有自注意机制的灵活性和数据依赖性。许多工作已经研究了将局部注意力应用于现代卷积或Transformer模型。然而，他们要么使用低效的Im2Col函数，这会导致推理时间的大幅增加，要么依赖于精心编写的CUDA内核，这限制了在没有CUDA支持的设备上的适用性。因此，开发一个既高效又可推广的局部注意力模块仍然具有挑战性。
PVT将特征图中的稀疏位置采样视为键值对。DAT采取了进一步的步骤，并以数据相关的方式将固定位置向不同的方向移动。MViT在输入上使用池化函数，以获得键和值对，这可以被视为特征图的较低分辨率。Swin Transformer使用窗口+位移，CSwin Transformer在此基础上使用十字形窗口，进一步提高模型能力。local attention限制每个查询的感受野在周围的像素。
2、Attention Patterns（即总结一下）
（1） 稀疏全局注意力考虑选择一组稀疏的键值对，而不是密集的特征图。然而，这也限制了将特征提取到有限的输入子集中的潜力。此外，键和值对对于所有查询都是相同的。这种查询不可知的选择策略可能导致整个特征图中的特征同质化。
（2） 窗口注意力是另一种将输入小心地完全划分为特定窗口的选项，在特定窗口中提取特征。尽管部分解决了查询不可知的键值对的限制，但所设计的模式可能会导致不自然的情况，即不同窗口边缘的特征尽管在特征图中很近，但却被完全隔离。此外，窗口模式需要在连续的块之间转换，以促进跨窗口的连接，这涉及到模型结构中的额外设计。
（3） 局部注意力将每个查询的感受野约束在其自己的相邻像素中，与卷积共享相似的模式。与以前的模式相比，局部注意力同时具有卷积和自我注意力的优点：1）以查询为中心的注意力模式产生的局部归纳偏差；2） 像传统卷积一样的平移等方差，显示出对输入偏移方差的鲁棒性；3） 涉及很少的人工设计，对模型架构设计的限制最小。
3、 Local Attention Implementation
不同方法的效率：
二、方法
1. New Perspective on Im2Col
图（1）是原本的Im2Col的基于列的试图。图2是基于行的试图，是作者发现的。以k=3为例，如果我们首先将原始特征图向9个不同的方向移动（图3（2.b）），然后将这些特征展平成行，最后将它们连接成列（图3的2.c）），则所获得的键/值矩阵被证明等效于HW局部窗口，该窗口可以恢复与原始Im2Col函数完全相同的输出（图3中的1.c））。
2. Shift as Depthwise Convolution
采用一个精心设计卷积核的深度卷积来代替低效的特征偏移。如上图（3.（3））
3. Deformed Shifting Module
引入了一种并行卷积路径，其中核参数在训练过程中被随机初始化并可学习。与将特征向不同方向转移的固定内核相比，可学习内核可以被解释为所有局部特征的线性组合。
（1） 局部注意力中的关键和价值对由一个更灵活的模块来处理，该模块大大提高了模型容量，并可以捕捉各种特征。（2） 可学习卷积核与DCN中的可变形技术表现出相似性。类似于DCN中四个相邻像素的双线性插值，我们的变形移位模块可以被视为局部窗口内特征的线性组合。这最终有助于增强输入的空间采样位置和模型几何变换。（3） 我们使用重新参数化技术[8]将两条平行路径转换为单个卷积。这样，我们可以在保持推理效率的同时提高模型容量。
结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b43b75df18d5b8e8c7f7ec58bb607d/" rel="bookmark">
			SVG实现点击元素弹窗展示对应信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVG实现点击元素弹窗展示对应信息 实现思路：通过javascript给相应的元素添加按钮点击事件，通过style动态控制弹窗的显示或隐藏
示例如下： SVG
&lt;g&gt; &lt;text x="12.25" y="781.51" class="st11" v:langID="2052"&gt;&lt;v:paragraph v:horizAlign="1"/&gt;&lt;v:tabList/&gt;10. &lt;a xlink:href="javascript:Button_onclick()" id="a237"&gt;点击测试&lt;/a&gt; &lt;/text&gt;	&lt;/g&gt; &lt;g id="78945" style="display: none" data-toggle="popover" data-container="body" title="Popover Header" data-content="Some content inside the popover" data-placement="right"&gt; &lt;defs&gt; &lt;linearGradient id="gradient-test"&gt; &lt;stop offset="0%" stop-color="#DCE35B" /&gt; &lt;stop offset="100%" stop-color="#45B649" /&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;rect x="600" y="100" width="226" height="430" rx="10" ry="10" stroke="black" fill="url(#gradient-test)" stroke-width="1"/&gt; &lt;/g&gt; javascript
function Button4_onclick(){ var style = document.getElementById("78945").style.display; if(style === "none"){ document.getElementById("78945").style.display = "block"; }else if(style === "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50b43b75df18d5b8e8c7f7ec58bb607d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c1812baa65810256ad5d896ad1842b/" rel="bookmark">
			新能源汽车冷却系统的水道管口类型有哪些？格雷希尔针对这些管口密封的快速接头有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于新能源汽车，不仅电池，还有电机、电控、充电单元部件，都需要处于适宜的工作温度，才能维持整车的正常运行。而这些部件在运行过程中会产生大量的热量，如果不及时散热会对汽车的性能、寿命产生影响，甚至可能引发安全问题。因此，冷却系统的作用至关重要，它可以控制各个部件的工作温度，使其能够正常运行。冷却系统需要进行各种如：气密、老化、运行、高低温、静压强度､压力循环､震动､内部腐蚀､爆破､耐候等等多达十多种性能测试，而很多测试都需要用到格雷希尔GripSeal快速密封连接器来实现产品与测试设备的快速密封与连接。
比如说水道管路的进出水口，在进行各种测试时就需要对其进行快速的密封与连接，水道管口的材质有PTV、橡胶、铝合金、不锈钢等;其形状有凸缘管口、直通管口、或VDA管口等，材质不同，管口形状不同，所对应的快速密封连接器也各不相同。　针对凸缘管口连接的需求，可选用G70和G70P系列连接器。这两款连接器在操作方式、材质、测试功能方面都是一样的，区别在于G70系列采用金属卡爪，对于铝合金、不锈钢等金属管件，它可能会导致外观造成刮伤，有些客户对这方面没有要求，而有些客户则要求管件外观的整体美感不允许有刮痕，此时，可以选用G70P系列，G70P系列的卡爪内嵌高分子工程塑料爪牙，可以有效避免刮伤的情况发生。
针对直通管口，可以选用G35和G35P系列，两款都是用于内管径密封，G35系列的爪牙都是高硬度金属爪牙，会对管件的内部造成不同程度的损伤，如果有这方面的禁忌，可选用G35P系列，此系列的爪牙整个采用高分子工程塑料制成，不会对管件内壁造成任何损伤，当然，它的缺点也是有的，比如测试压力没有G35 的高，抓紧力也没有金属爪牙的高，塑料爪牙的使用寿命也没有金属爪牙的长等问题，客户可根据自己的实际使用情况和现场的操作环境进行选择，不求最贵的，只求最适合自己的。
针对VDA管口，可以选用G70-NW、G90L-NW和G90R-NW，VDA接口通常都是塑料材质，如果对管件的外观没有特别要求的话，可以选用G70-NW系列，此系列整体不锈钢材质，耐高压、高温、腐蚀等特性，使用寿命长，但同样的会对管件表面造成轻微刮伤，如果有这方面的禁忌可选用G90L-NW系列，此系列整体铝合金材质，在保证连接器强度的同时减轻了操作强度，内部采用特殊结构设计，不会对管件表面造成任何损伤，保证管件外观的完整性。G90L-NW与G90R-NW的区别在于当操作空间不够时，可以选用G90R-NW系列，此系列L型结构，尾部流体孔可以360°自由旋转，免去了气管缠绕烦恼，解决了因操作空间不足引起的干涉问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63777ff9dc156a819feb6ad62f891ce/" rel="bookmark">
			使用 Jsmooth 将 Java 程序打包为exe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何生成可运行jar包 （如何将一个普通的main方法打包后变成可执行的jar，注意springboot的jar是可以执行的，这里讲的的是非springboot的情况）
工具地址jsmooth(jar打包成exe) v0.9.9.8汉化版；
注意事项：
xxxx.jar,xxxx.exe和jre要放在一个目录制作完成后拷贝给别人，要将jre和xxx.exe一起拷贝（所以这个东西其实还是蛮大的，有200M左右），单独拷贝xxx.exe会提示“java has not been found,do you want to downlod it” 1,准备好的文件如下（jre即java的jre; logo.jpg即后面生成的exe文件的图标（即windows常见软件安装留在桌面那个快捷方式的图标），XXX.exe 是新建的空的文件，XXX.jar就是可运行的jar,上面有介绍如何生成）：
2，选择骨架，如图
3，可执行文件配置，可执行文件的图标选择logo.jpg，这里图片太大不方便截图所以没选到它。
4， 应用程序，如果你的jar包中有多个class中包含main方法，选择了那个作为主类就是执行哪个的main方法。
5.JVM设置
6，开始执行
第一次点击会让你选择文件，直接选你之前新建的那个空的XXX.exe文件即可，成功后弹出对话框
如果你要更新代码，只要把最新的XXX.jar覆盖原来的的，然后点击运行就可以生成新的exe,不用再做其他配置了，当然前提是你没更换主类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972eeb912ae3f1ee78a692567ff7cd64/" rel="bookmark">
			企业品牌推广在国外媒体投放的意义和作用何在？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海外广告投放是企业在国际市场推广的重要战略，具有多种形式，包括社交媒体广告、短视频广告、电视广告等。这些广告形式在传播信息、推动销售、塑造品牌形象等方面发挥着独特的作用。
其中软文发稿是一种注重叙事和信息传递的广告形式，对于企业的品牌影响有着长远而积极的作用。通过在媒体或平台上发布有深度、有趣的软文，企业能够建立起专业、可信的形象，深刻地向受众传达品牌理念和价值观。软文的影响通常更为持久，因为它通过讲述故事和提供有价值的信息，与受众建立更为深层次的连接。
国外媒体投放在当今全球化时代具有重要的意义和作用，这体现在品牌推广、市场拓展、形象建设等方面。
通过在国外媒体投放广告或软文，企业可以迅速提升其在国际市场上的品牌知名度。国外媒体的覆盖范围广泛，能够让企业的声音传达到更多潜在消费者，使品牌在全球范围内为人所知。
拓展海外市场：
国外媒体投放是拓展海外市场的有效手段。通过在目标国家或地区的主流媒体上发布广告或软文，企业可以吸引更多本地受众的关注，提高产品或服务在海外市场的销售。
国际市场调研和洞察： 在国外媒体投放广告不仅仅是一种宣传手段，也是进行国际市场调研和获取洞察的途径。通过媒体投放，企业可以了解目标市场的文化、消费习惯、竞争格局等信息，为更好地适应和满足当地需求提供参考。
建立国际企业形象：
在知名国际媒体上投放广告或发布软文，有助于企业在国际舞台上树立良好的形象。通过正面的宣传内容，企业能够向国际受众传递积极的价值观和形象，增加在国际市场上的信任度。
吸引国际投资与合作： 在国外媒体投放广告，特别是在财经类媒体上展示企业的业绩和前景，有助于吸引国际投资者的注意。这也为企业寻求国际合作伙伴提供了机会，推动国际合作的发展。
提高搜索引擎可见性： 国外媒体上的内容在搜索引擎中的排名通常较高。通过在国外媒体上发布内容，企业可以提高在搜索引擎上的可见性，增加被搜索到的机会，进而吸引更多流量。投放在国外媒体上的广告或软文有望在社交媒体上引发更多关注和讨论，进而扩大品牌影响力。
国外媒体投放在全球化战略中扮演着重要的角色。通过在国际舞台上展示企业形象、产品、服务等方面的优势，企业能够更好地适应全球市场的需求，实现更广泛的市场影响力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a917ae813af885c44b406c692ea2ffc/" rel="bookmark">
			HashMap使用-LeetCode做题总结 454. 四数相加 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		454. 四数相加 II 最初思路优化思路Java语法增强for的使用场景 最初思路 枚举，因为是要计算有多少个元组，所以每个元素肯定都要遍历到，所以干脆算出所有元组的和。
我想用四个for循环加，但是失败。
优化思路 参考力扣
四数相加为零，a+b+c+d=0，那么 a+b = -(c+d)，这个等式可以利用哈希表。
class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { Map&lt;Integer,Integer&gt; countAB = new HashMap&lt;Integer,Integer&gt;(); for(int v : nums1) { for(int u : nums2) { countAB.put(u+v,countAB.getOrDefault(u+v,0)+1); } } int ans=0; for(int v : nums3) { for(int u : nums4) { if(countAB.containsKey(-(v+u))) { ans += countAB.get(-(v+u)); } //countAB.put(u+v,countAB.getOrDefault(u+v,0)+1); } } return ans; } } Java语法 增强for的使用场景 使用范围：用来遍历集合和数组(必须有遍历目标，目标只能是集合或者数组)，所有单列表集合都可以使用增强for循环。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192bc3e9c093a4612c27b66ffba9fb99/" rel="bookmark">
			【LeetCode:LCR 143. 子结构判断 | 二叉树 &#43; 递归】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 算法题 🚀 🌲 算法刷题专栏 | 面试必备算法 | 面试高频算法 🍀
🌲 越难的东西,越要努力坚持，因为它具有很高的价值，算法就是这样✨
🌲 作者简介：硕风和炜，CSDN-Java领域新星创作者🏆，保研|国家奖学金|高中学习JAVA|大学完善JAVA开发技术栈|面试刷题|面经八股文|经验分享|好用的网站工具分享💎💎💎
🌲 恭喜你发现一枚宝藏博主,赶快收入囊中吧🌻
🌲 人生如棋，我愿为卒，行动虽慢，可谁曾见我后退一步？🎯🎯
🚀 算法题 🚀 🍔 目录 🚩 题目链接⛲ 题目描述🌟 求解思路&amp;实现代码&amp;运行结果⚡ 二叉树 + 递归🥦 求解思路🥦 实现代码🥦 运行结果 💬 共勉 🚩 题目链接 LCR 143. 子结构判断 ⛲ 题目描述 给定两棵二叉树 tree1 和 tree2，判断 tree2 是否以 tree1 的某个节点为根的子树具有 相同的结构和节点值 。
注意，空树 不会是以 tree1 的某个节点为根的子树具有 相同的结构和节点值 。
示例 1：
输入：tree1 = [1,7,5], tree2 = [6,1]
输出：false
解释：tree2 与 tree1 的一个子树没有相同的结构和节点值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/192bc3e9c093a4612c27b66ffba9fb99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a465dde2eb03455afae74d58db6b704/" rel="bookmark">
			显示器新赛道Type-C接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果把主机比作大脑，那显示器就是眼睛，没有眼睛，大脑再强大也发挥不出效果，所以显示器作为电脑最重要的输出设备，有着举足轻重的地位，可以说在生活中处处都有显示器的影子。
其实显示器的历史也是科技发展史，从早期的CRT显示器，也称阴极射线管显示器，笨重且分辨率低，随着电脑整体水平的进步，人们对显示器的要求也越来越高，这时候就出现了液晶显示器，体积小分辨率更高，再到后来的OLED屏幕，一直在向更好的显示效果和更高的分辨率发展。
显示器的接口也同样在进步，早期多为色差分量接口，这种接口的特点是分辨率低不稳定，后来出现了VGA接口，这种接口到现在依然有在使用，不过缺点是无法传输音频，为了达到更好的显示相关，接着出现了DVI接口，DVI接口最高能达到1080P的分辨率，但是仍然不能同时传输音频，为了解决这个问题，发展成了HDMI接口，也是目前最主流的显示接口，分辨率能达到8K，并且能同时传输音频，本来以为HDMI就是目前最完美的接口了，想不到还有高手！也是本文的主角Type-C接口。
Type-C接口到底比HDMI强在哪里？我们不妨看看参数，Type-C接口拥有24个引脚，最高速率能达到40Gbps，分辨率可达8K，并且能同时传输音频，这样看貌似只能跟HDMI接口旗鼓相当，难分伯仲，真让Type-C接口超越HDMI的是反向供电功能，在投屏的过程中能反向给设备提供快充，因为在长时间HMID接口投屏时，都需要额外给设备接一个充电线，而Type-C接口自带反向充电，而且接口小巧且支持正反盲插，这是HDMI接口做不到的。
目前显示器已经逐渐开始采用Type-C接口投屏，比如投影仪，桌面显示器，便携显示器都有Type-C接口的身影，现在支持Type-C接口视频输出的设备也越来越多，现在各大厂商都在抢占Type-C显示器的市场，可见未来的趋势就是往统一Type-C接口靠拢。
目前许多Type-C显示器采用的是乐得瑞的LDR6020的PD控制芯片，乐得瑞算是最早接触Type-C显示器领域的了，在技术方面累积了丰富的经验，不仅提出了双盲插的设计思路，还在桌面显示器提出反向充电的方案。
LDR6020具有三组6路DRP通道，完全满足各种显示器应用场景，比如双Type-C接口便携显示器，双Type-C接口自动识别充电或者投屏，不需区分；再比如桌面显示器，DC供电，单Type-C接口连接设备投屏，并给设备反向快充，可以做到智能分配功率。
LDR6020的功能非常强大，除了支持PD协议功能，还可以定制MCU控制逻辑，支持重复烧录，联网升级，就算在用户手上也可以在线升级，并且成本便宜，非常适合Type-C显示器的应用场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e806b5f4076b1d33e44f33ac77da139/" rel="bookmark">
			IDEA/VScode &#43; Git Blame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA IDEA中支持查看每行代码的commit信息，这是靠git blame命令来完成的。
鼠标悬置在上面，可以看到更多信息。
VScode vscode中有相应插件完成类似的工作。
找到一个Git Blame插件，就是专门用来完成这项工作的。
安装完成后，下面的状态栏就会显示光标所在行的代码的git blame信息。
点击它，弹窗显示commit信息。
点击Terminal，则构造git show命令来显示该commit的完整提交日志。
点击Online，则自动构造一个url去访问。
手动构造commit对应url的方法 如果你的代码托管在 GitHub 上，你可以通过以下格式构造 commit 的链接：
https://github.com/&lt;username&gt;/&lt;repository&gt;/commit/&lt;commit_id&gt;
其中，&lt;username&gt; 是仓库所有者的用户名，&lt;repository&gt; 是仓库的名字，&lt;commit_id&gt; 是 commit 的 ID。
例如，如果你的代码托管在 GitHub 上，用户名是 apache，仓库名是 bookkeeper，commit id 是 bd50cacd2b759d53b06a2356c5a9369b6100d635，那么 commit 的链接就是：
https://github.com/apache/bookkeeper/commit/bd50cacd2b759d53b06a2356c5a9369b6100d635
你可以将这个链接复制到浏览器中打开，查看该 commit 的详细信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d7975e718050446a83540253b633a8/" rel="bookmark">
			初识隧道代理HTTP：理解基础概念的重要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨，小伙伴们！如果你对网络世界充满好奇，那么这篇文章就是为你准备的。我们将一起踏上一段奇妙的旅程，探索一个叫做“隧道代理HTTP”的新领域。但在这之前，我们需要先穿上“基础概念”的防护服，以免被这个复杂世界的各种“专业术语”搞晕头。
隧道代理HTTP，这个名字听起来就像是一个神秘的密码。其实，当你深入了解后，你会发现它并没有那么复杂。简单来说，隧道代理HTTP就是一种能够帮助你在网络上“隐身”的神秘力量。
想象一下，网络世界就像一个大迷宫，而我们每个人都在这个迷宫里探索。有时候，我们可能会遇到一些“危险”，比如网页浏览记录被追踪、个人信息被泄露等。这时候，隧道代理HTTP就像是一把魔法盾牌，保护我们免受这些“危险”的侵害。
那么，隧道代理HTTP是如何工作的呢？其实，它就像是一个“传送门”，将你的网络请求从一处传送到另一处。在这个过程中，你的真实IP地址被隐藏起来，就像是在网络世界中玩起了“躲猫猫”。这样一来，你的浏览行为就变得更加安全了。
那么，如何使用隧道代理HTTP呢？其实很简单。你只需要在浏览器中设置一个代理服务器地址，然后所有的网络请求都会通过这个代理服务器进行传输。这样一来，你的真实IP地址就被隐藏了，你的网络行为也变得更加安全了。
说了这么多，你是不是已经对隧道代理HTTP产生了浓厚的兴趣？别急，这还只是冰山一角。在接下来的文章中，我们将一起深入了解隧道代理HTTP的更多用途和技巧。我们将一起探索如何选择合适的代理服务器、如何配置和使用各种代理工具、以及如何在使用隧道代理HTTP的同时保护我们的网络安全。所以，如果你想在网络世界中畅游无阻、保护自己的隐私安全，那就一定要关注我们的后续文章哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33052d1f212bbd98c39cdf755dea8427/" rel="bookmark">
			编程笔记 html5&amp;css&amp;js 012 HTML分块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程笔记 html5&amp;css&amp;js 012 HTML分块 一、HTML 块级元素二、HTML 内联元素三、HTML` &lt;div&gt;` 元素四、HTML `&lt;span&gt;` 元素五、HTML`&lt;article&gt;`元素六、`&lt;article&gt;元素和&lt;div&gt;元素`的区别与联系小结 像报纸排版一样，很多时候需要把平面划分为多个块，网页也是一样，这里就看一下，怎么在页面中划分区块。 HTML &lt;div&gt; 和&lt;span&gt;
HTML 可以通过 &lt;div&gt; 和 &lt;span&gt;将元素组合起来。
一、HTML 块级元素 大多数 HTML 元素被定义为块级元素或内联元素。
块级元素在浏览器显示时，通常会以新行来开始（和结束）。
实例: &lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;
二、HTML 内联元素 内联元素在显示时通常不会以新行开始。
实例: &lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;
HTML中的块级元素指的是在渲染时以块的形式显示的元素。
以下是一些常见的HTML块级元素：
&lt;div&gt;：用于创建一个分隔的块级区域，常用于布局和样式的分离。&lt;p&gt;：用于段落文本。&lt;h1&gt; - &lt;h6&gt;：用于标题，其中&lt;h1&gt;表示最高级别的标题，&lt;h6&gt;表示最低级别的标题。&lt;ul&gt;：用于创建无序列表。&lt;ol&gt;：用于创建有序列表。&lt;li&gt;：用于列表项，必须位于&lt;ul&gt;或&lt;ol&gt;内部。&lt;table&gt;：用于创建表格。&lt;thead&gt;：用于定义表格的表头部分。&lt;tbody&gt;：用于定义表格的主体部分。&lt;tr&gt;：用于定义表格的一行。&lt;th&gt;：用于定义表格的表头单元格。&lt;td&gt;：用于定义表格的数据单元格。&lt;form&gt;：用于创建表单。&lt;fieldset&gt;：用于将相关表单元素分组。&lt;legend&gt;：用于为元素定义标题。&lt;blockquote&gt;：用于引用长段落的文本。&lt;address&gt;：用于定义联系信息。&lt;pre&gt;：保留空白字符和换行符的格式化文本。&lt;figure&gt;：用于包含独立的内容，如图像或表格。&lt;figcaption&gt;：用于为&lt;figure&gt;元素定义标题。 这只是一些常见的块级元素，还有其他块级元素，如&lt;article&gt;、&lt;section&gt;、&lt;nav&gt;、&lt;header&gt;等等。
三、HTML &lt;div&gt; 元素 HTML &lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器。
&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。
如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。
&lt;div&gt; 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt;table&gt; 元素进行文档布局不是表格的正确用法。&lt;table&gt; 元素的作用是显示表格化的数据。
四、HTML &lt;span&gt; 元素 HTML &lt;span&gt; 元素是内联元素，可用作文本的容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33052d1f212bbd98c39cdf755dea8427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e7c0dbd601d8f36c8473608f1dffe6/" rel="bookmark">
			机器视觉在智能交通与无人驾驶领域的应用及前景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​引言 机器视觉算法对于智能交通系统和无人驾驶技术是十分重要的。机器视觉技术是无人驾驶汽车感知环境、做出决策的关键，它使得车辆能够理解周围的世界并安全地导航。在智能交通系统中，机器视觉也发挥着至关重要的作用，从提高交通效率到增强道路安全，其应用前景广阔。本文将探讨机器视觉算法在这些领域的使用场景、重要性，并对其未来的应用前景提出个人见解。
机器视觉算法的使用场景 1. 环境感知 在无人驾驶技术中，机器视觉算法用于处理来自车载摄像头的图像数据，以便检测和识别道路上的车辆、行人、交通标志和路面标线。这些信息对于无人驾驶汽车的定位、导航和决策至关重要。
2. 障碍物检测 无人驾驶车辆必须能够准确地检测和避开障碍物。机器视觉算法可以识别静态障碍物（如停车的车辆、建筑物）和动态障碍物（如行人、其他车辆）。
3. 交通监控 智能交通系统利用机器视觉技术监控交通流量，分析道路状况，预测交通拥堵，并提供实时交通信息。此外，机器视觉还能够检测交通违规行为，提高道路安全。
4. 自动泊车 机器视觉算法使得车辆能够自动识别停车空间，并精确计算出泊车轨迹，实现自动泊车。
5. 高级驾驶辅助系统（ADAS） 机器视觉是实现ADAS功能的关键技术，包括车道保持、自适应巡航控制和自动紧急制动等功能。
机器视觉技术的重要性 1. 提高安全性 机器视觉技术通过实时监控周围环境，提供了比人类驾驶员更快、更准确的反应能力，从而显著提高了行车安全。
2. 增强效率 在智能交通系统中，机器视觉技术可以优化交通流量，减少拥堵，提高整体交通效率。
3. 降低成本 自动化的交通监控和管理系统通过减少人力需求，降低了运营成本。
4. 环境友好 通过优化交通流量和减少停滞，机器视觉技术有助于降低汽车尾气排放，减少环境污染。
机器视觉技术在交通应用的前景 1. 全面自动化的无人驾驶 随着技术的进步，我们将迎来完全自动化的无人驾驶时代。机器视觉系统将成为实现这一目标的核心技术，使得车辆能够无需人工干预地在各种道路条件下安全行驶。
2. 车联网 机器视觉技术将与车联网（V2X）技术相结合，提供更全面的环境感知能力。车辆不仅能够“看到”周围环境，还能够“听到”其他车辆和基础设施的信息，实现更高级别的自动驾驶。
3. 智慧城市 在智慧城市的构建中，机器视觉技术将与其他传感器和大数据分析相结合，形成一个综合的交通管理系统，实现更高效、更安全、更可持续的城市交通。
4. 法规与伦理挑战 随着技术的发展，法律法规和伦理问题将成为机器视觉技术广泛应用的重要挑战。如何确保无人驾驶汽车的决策符合社会伦理标准，将是一个需要解决的问题。
结语 作为一名机器视觉工程师，我对机器视觉技术在智能交通和无人驾驶领域的应用前景充满信心。随着技术的不断进步和成熟，我们将看到一个更加智能、安全和高效的交通系统的到来。未来的交通将不仅仅是点对点的移动，而是一个高度集成、互联互通的生态系统。然而，技术的发展也带来了新的挑战，包括确保数据安全、保护个人隐私以及制定相应的法律法规，以引导和促进技术的健康发展。总之，机器视觉技术将是推动交通行业变革的关键力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf176c58a1eff36f9623578301f9f8b1/" rel="bookmark">
			CAVER: Cross-Modal View-Mixed Transformer for Bi-Modal Salient Object Detection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、论文阅读笔记：
1、摘要：
2、主要贡献点：
3、方法：
3.1 网络的总体框架图：
3.2 Transformer-based Information Propagation Path (TIPP)
3.3 Intra-Modal/Cross-Scale Self-Attention (IMSA/CSSA)
Q1: MHSA计算复杂度较高
A1:Patch-wise Token Re-Embedding (PTRE)
Q2:目前的MHSA只考虑空间视图上的特征对齐，而忽略了通道视图的潜在值
A2:View-Mixed Attention (VMA)
3.4 Inter-Modal Cross-Attention (IMCA)
4、实验：
二、代码复现
1、实验细节：
2、数据集：
3、实验步骤：
3.1 将对应的代码和数据集上传到服务器上
3.2 将根目录下的datasets.py里的路径更改成自己的路径
3.3 更改对应的./configs/rgbd-2dataset.py中的路径信息
3.4 将预训练模型从给出的网址上下载下来，上传到对应文件夹 (/root/autodl-tmp/CAVER/pretrained)
3.5 安装对应的module
3.6 在两个数据集上的训练结果
三、BUGS
问题1：assert path.endswith(".jpg") or path.endswith(".png") or path,endswith(".bmp") AssertionError
问题2： TypeError: FormatCode() got an key word 'verify'
​编辑
​编辑 问题3：RuntimeError: CuDA error: no kernel imade is available for execution on the deviceCUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrectFor debugging consider passing CUDA LAUNCH BLOCKING=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf176c58a1eff36f9623578301f9f8b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ad049ce2dbb3514b11688a7e88bb10/" rel="bookmark">
			计算机网络【Cookie和session机制】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。
本章将系统地讲述Cookie与Session机制，并比较说明什么时候不能用Cookie，什么时候不能用Session。
1.1 Cookie机制 在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。
而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。
Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。
1.1.1 什么是Cookie Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。
由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。
Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。
查看某个网站颁发的Cookie很简单。在浏览器地址栏输入**javascript:alert (document. cookie)**就可以了（需要有网才能查看）。JavaScript脚本会弹出一个对话框显示本网站颁发的所有Cookie的内容，如图1.1所示。
​ 图1.1中弹出的对话框中显示的为Baidu网站的Cookie。其中第一行BAIDUID记录的就是笔者的身份helloweenvsfei，只是Baidu使用特殊的方法将Cookie信息加密了。
注意：Cookie功能需要浏览器的支持。
如果浏览器不支持Cookie（如大部分手机中的浏览器）或者把Cookie禁用了，Cookie功能就会失效。
不同的浏览器采用不同的方式保存Cookie。
IE浏览器会在“C:\Documents and Settings\你的用户名\Cookies”文件夹下以文本文件形式保存，一个文本文件保存一个Cookie。
1.1.2 Unicode编码：保存中文 中文与英文字符不同，中文属于Unicode字符，在内存中占4个字符，而英文属于ASCII字符，内存中只占2个字节。Cookie中使用Unicode字符时需要对Unicode字符进行编码，否则会乱码。
提示：Cookie中保存中文只能编码。一般使用UTF-8编码即可。不推荐使用GBK等中文编码，因为浏览器不一定支持，而且JavaScript也不支持GBK编码。
1.1.3 BASE64编码：保存二进制图片 Cookie不仅可以使用ASCII字符与Unicode字符，还可以使用二进制数据。例如在Cookie中使用数字证书，提供安全度。使用二进制数据时也需要进行编码。
注意：本程序仅用于展示Cookie中可以存储二进制内容，并不实用。由于浏览器每次请求服务器都会携带Cookie，因此Cookie内容不宜过多，否则影响速度。Cookie的内容应该少而精。
1.1.4 设置Cookie的所有属性 除了name与value之外，Cookie还具有其他几个常用的属性。每个属性对应一个getter方法与一个setter方法。Cookie类的所有属性如表1.1所示。
属 性 名描 述String name该Cookie的名称。Cookie一旦创建，名称便不可更改Object value该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码int maxAge该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1boolean secure该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为falseString path该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”String domain可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”String comment该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明int version该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 1.1.5 Cookie的有效期 Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。Cookie中通过getMaxAge()方法与setMaxAge(int maxAge)方法来读写maxAge属性。
如果maxAge属性为正数，则表示该Cookie会在maxAge秒之后自动失效。浏览器会将maxAge为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在maxAge秒之前，登录网站时该Cookie仍然有效。下面代码中的Cookie信息将永远有效。
Cookie cookie = new Cookie("username","helloweenvsfei"); // 新建Cookie cookie.setMaxAge(Integer.MAX_VALUE); // 设置生命周期为MAX_VALUE response.addCookie(cookie); // 输出到客户端 如果maxAge为负数，则表示该Cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该Cookie即失效。maxAge为负数的Cookie，为临时性Cookie，不会被持久化，不会被写到Cookie文件中。Cookie信息保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。Cookie默认的maxAge值为–1。
如果maxAge为0，则表示删除该Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置该Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除，
例如：
Cookie cookie = new Cookie("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65ad049ce2dbb3514b11688a7e88bb10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24172ad7f30e9b2d7c9448df5a6f6bd0/" rel="bookmark">
			目标检测-One Stage-YOLOv1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、YOLOv1的网络结构和流程二、YOLOv1的损失函数三、YOLOv1的创新点总结 前言 前文目标检测-Two Stage-Mask RCNN提到了Two Stage算法的局限性：
速度上并不能满足实时的要求 因此出现了新的One Stage算法簇，YOLOv1是目标检测中One Stage方法的开山之作，不同于Two Stage需要先通过RPN网络得到候选区域的方法，YOLOv1将检测建模为一个回归问题，直接在整张图的特征图（Feature Map）上进行目标的定位和分类，因此速度比当时正红的Fast R-CNN快很多。而且，也正是因为YOLOv1看的是全局的信息，把背景误判成目标的错误率比只看候选区的Fast R-CNN低很多，但整体的准确率还是Fast R-CNN高。
提示：以下是本篇文章正文内容，下面内容可供参考
一、YOLOv1的网络结构和流程 首先将输入图像划分成7 * 7的网格使用ImageNet数据集（224大小）对前20层卷积网络进行预训练使用PASCAL VOC数据集（448大小）对完整的网络进行对象识别和定位的训练对于每个网格都预测2个边框（bounding box），即预测98（7 * 7 * 2）个目标窗口，输出7 * 7 * 2 * 30 的张量。 ps：最后一维为30，包含每个预测框的分类与位置信息：20个类别的概率+2个边框的置信度+2*4（2个边框的位置，每个边框4个参数：x_center, y_center, width, height）
根据上一步预测出98个目标窗口，使用非极大值抑制NMS去除冗余窗口
ps：YOLOv1的最后一层采用线性激活函数，其它层都是Leaky ReLU。训练中采用了drop out和数据增强（data augmentation）来防止过拟合。
二、YOLOv1的损失函数 可看出由5个部分组成：（真阳样本的中心定位误差、宽高误差、confidence误差），负样本confidence误差，正样本类别误差
可以看到宽高误差先取了平方根，这样可以降低大小对象对差值敏感度的差异超参数 λ c o o r d = 5 ， λ n o o b j = 0.5 \lambda_{coord}=5，\lambda_{noobj}=0.5 λcoord​=5，λnoobj​=0.5，可看出真阳样本位置误差的权重较高，负样本置信度误差权重低 三、YOLOv1的创新点 去除候选区模块，直接将目标检测任务转换成一个简单的回归问题，大大加快了检测的速度（45fps-155fps）由于每个网络预测目标窗口时使用的是全图信息（图片的全局特征），使得false positive比例大幅降低（充分的上下文信息），precision较高 总结 尽管YOLOv1速度提升很多，但是精度较低：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24172ad7f30e9b2d7c9448df5a6f6bd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648ef0104a37b68ecb9f44726ff4315a/" rel="bookmark">
			聚观早报 |小米汽车SU7官图发布；优酷上线“AI搜片”功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚观早报每日整理最值得关注的行业重点事件，帮助大家及时了解最新行业动态，每日读报，就读聚观365资讯简报。
整理丨Cutie
12月29日消息
小米汽车SU7官图发布
优酷上线“AI搜片”功能
小米汽车智能驾驶技术公布
百度投资AIGC公司必优科技
12家日本公司已成立ASRA
小米汽车SU7官图发布 小米在12月28号下午举行汽车技术发布会，小米官方公布了首款量产车SU7的实拍照片。
外观方面，新款配色官方命名为海湾蓝，整体造型与保时捷Taycan极为相似，采用轿跑设计，车头部分比较低趴，前脸为封闭式，并搭载矩阵式大灯组。此外，新车在车顶位置还搭载了瞭望式激光雷达。
车身侧面采用流线型造型，溜背的设计极具运动感，同时还可以看到黄色刹车卡钳以及开放式的门把手。车尾部采用贯穿式尾灯组，并有“xiaomi”的品牌标识，尾标则为“北京小米”。此外，新车还将配备主动尾翼。
动力方面，新车提供单电机和双电机版本可选，单电机峰值功率为220kW，双电机峰值功率分别为220kW和275kW。
优酷上线“AI搜片”功能 优酷上线“AI搜片”功能，号称是全网首个AI对话影视搜索引擎。
根据优酷官方介绍，“AI搜片”覆盖全网百万级影视剧实体信息，融合万亿条文娱相关知识词条，通过多轮对话实现模糊搜索、影视问答、剧情检索等智能互动，无需具象问题就能精准作答。
具体操作上，用户点击优酷APP搜索栏的“AI”按钮进入对话页面，即可通过模糊、口语化的提问获取精准匹配的影视信息，还能和AI交流全网影视知识。
比如，当你问“想看和《西出玉门》类似的影视剧剧”时，AI就会通过算法推荐同类型影视剧，还能实现跳转观看。而当你询问某部剧的大结局是什么也能获取精准回答。
小米汽车智能驾驶技术公布 在小米汽车技术发布会上，雷军宣布了小米汽车在智能驾驶技术方面的最新成果。他强调，尽管小米汽车在智能驾驶领域起步较晚，但小米的目标是在2024年成为行业第一。
小米汽车的全栈自研智能驾驶技术是其核心优势之一。该技术不仅全面自研底层算法，还对AD三件套（BEV、Transformer、OCC占用网络）进行了全面自研，并融入了大模型技术。
小米汽车采用变焦BEV技术，可根据车辆行驶场景自动切换识别模式。此外，它还拥有超分辨率占用网络技术，可以精确识别障碍物，并支持雨雪天气的智能降噪。
小米汽车还自研了无图方案道路大模型，通过大模型实时生成道路拓扑，生成高精度地图，实现了路口识别和障碍物自动绕行等功能。
百度投资AIGC公司必优科技 近日，珠海必优科技有限公司发生工商变更，新增北京百度网讯科技有限公司为股东，同时，注册资本由111.11万人民币增至约112.85万人民币。
珠海必优科技有限公司成立于2020年9月，法定代表人为周泽安，经营范围含人工智能应用软件开发、人工智能公共数据平台、人工智能理论与算法软件开发、互联网数据服务等。
股东信息显示，该公司由周泽安、陈润天、金山办公、北京百度网讯科技有限公司共同持股。官网显示，必优科技是一家专注于智能内容生成技术（AIGC）的科技型公司。
12家日本公司已成立ASRA 据外媒报道，12家日本公司已成立“汽车先进SoC研究中心”（ASRA），共同研发用于汽车的高性能数字半导体（系统级芯片，SoC）。
这12家公司包括5家汽车制造商（本田、马自达、日产、斯巴鲁、丰田）、2家电子元件制造商（日本电装公司、松下汽车系统）和5家半导体公司（Cadence Design Systems日本公司、Mirise Technologies、瑞萨电子、Socionext和Synopsys日本公司）。
其中，丰田汽车公司高级研究员Keiji Yamamoto被任命为ASRA的主席，日本电装公司的高级顾问Nobuaki Kawahara被任命为执行董事。
ASRA将利用芯粒（别称“小芯片”）技术研发汽车SoC，以便从2030年起在量产汽车中安装SoC。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ff2aa784f4a880c25796c1d7674ecd/" rel="bookmark">
			二-从C到C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章会介绍一些C++拓展的非面向对象的功能 引用 1 概念 引用从一定程度上讲是指针的平替，几乎被所有的面向对象语言所使用。引用相当于对某一目标变量起“别名”。
操作这个别名，与操作原变量一样。（操作同一块地址）不能有相同别名
#include &lt;iostream&gt; using namespace std; int main() { int a = 1; // b是a的引用 int &amp;b = a; cout &lt;&lt; a &lt;&lt; " " &lt;&lt; &amp;a &lt;&lt; endl; // 1 0x61fe88 cout &lt;&lt; b &lt;&lt; " " &lt;&lt; &amp;b &lt;&lt; endl; // 1 0x61fe88 return 0; } 2 引用的性质 1)可以改变引用的值，但是不能再次成为其他变量的引用 #include &lt;iostream&gt; using namespace std; int main() { int a = 1; // b是a的引用 int &amp;b = a; int c = 3; b = c; // 只是单纯的赋值，不是引用，b还是a的引用 cout &lt;&lt; a &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81ff2aa784f4a880c25796c1d7674ecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8491751833ebfe49922683c90e4455/" rel="bookmark">
			k8s 架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要组件 k8s有如下的主要组件：
Control plane(s) and worker node(s)OperatorsServicesPods of containersNamespaces and quotasNetwork and policiesStorage.
一个k8s集群是有一个或多个 cp（控制平面）节点和一组worker 节点组成的。这个集群全都是由对operators的api call驱动的。一个网络插件帮助处理内部和外部流量。我们接下来会更加仔细地查看这些组建。
大部分进程是在容器内部进行的。
当省级一个集群的时候，需要注意每个组件的版本匹配。 kubeadm upgrade plam 命令对观测此类信息非常有用。
Control Plane Node (cp Node) Kubernetes cp 为集群运行各种服务器和管理器进程。随着软件的成熟，新的组件被创建来处理专用需求，例如云控制器管理器(cloud-controller-manager)；它处理曾经由kube-controller-manager处理的任务，以便与其他工具交互，例如用于第三方集群管理和报告的 Rancher 或 DigitalOcean。
有几个附加组件对于典型的生产集群至关重要，例如 DNS 服务。其他的是第三方解决方案，Kubernetes 尚未开发本地组件，例如集群级别的日志记录和资源监控。
作为一个概念，负责确保集群当前状态与所需状态匹配的各种 Pod 称为控制平面(control plane)。
使用 kubeadm 构建集群时，kubelet 进程由 systemd 管理。运行后，它将启动/etc/kubernetes/manifests/中找到的每个 pod 。
control plane node 的组件
kube-apiserver kube -apiserver是 Kubernetes 集群运行的核心。所有请求（包括内部和外部流量）均通过此代理处理。所有操作均由该代理接受并验证，并且它是与etcd数据库的唯一连接。它验证和配置 API 对象的数据，并为 REST 操作提供服务。因此，它充当整个集群的 cp 进程，并充当集群共享状态的前端。
Konnectivity 服务从 v1.18 中开始作为测试版功能，提供了将用户发起的流量与服务器发起的流量分开的能力。在开发这些功能之前，大多数网络插件都会混合流量，这会对性能、容量和安全性产生影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d8491751833ebfe49922683c90e4455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d450afe25ea32c72b2cb0e3965184ffb/" rel="bookmark">
			[TS]学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 TS8种基础类型 string、number、boolean、undefined、null、object、bigint、symbol
特俗类型： void、never、any、unknown
void：用于函数没有返回值
never：用于函数抛出异常或函数内部死循环
any：任意类型
unknown：不知道什么类型
Array和函数类型定义： let list:number[] = [1,2,3] let list:string[] = ['a,'b','c'] let list:Array&lt;number&gt; = [1,2,3] function add(x:number,y:number):number{ return x+y; } 元组、交叉类型、联合类型 //元组 let list:[number,string,boolean] = [1,'jack',true] // 交叉类型 type User = { name: string } type AgeType = { age: number } let jack: User &amp; AgeType = { name:'jack', age: 30 } // 联合类型 let num:string | number = '1' 接口5种场景 interface Person { name: string; age?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d450afe25ea32c72b2cb0e3965184ffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a2d8c4a8d6e5ce77290d16e565cca8/" rel="bookmark">
			postman win7 低版本 postman7.0.9win64 postman7.0.9win32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度网盘：
==============================================
postman7.0.9win64：
链接: https://pan.baidu.com/s/18ck9tI0r9Pqoz36MOwwnnQ 提取码: rkf7
==============================================
postman7.0.9win32：
链接: https://pan.baidu.com/s/1HrpGPrgvVzyAcjdHuwVOpA 提取码: ke5k
==============================================
win7系统安装postman，可能会遇到 .NET 4.5 问题，可以点击Install按钮安装，
或者 也可以使用官方软件单独安装.NET 4.5：
https://blog.csdn.net/torpidcat/article/details/135280815
==============================================
官网下载最新版本：
https://www.postman.com/downloads/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98ea79f64dae63338bae915051cb4b5/" rel="bookmark">
			OSFP协议配置实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的：
（1）理解OSPF；
（2）掌握OSPF的配置方法；
（3）掌握查看OSPF协议的相关信息。
实验器材：
Cisco packet
实验内容：
实验步骤：
（1）布置拓扑：
（2）成功布置拓扑：
（3）配置主机IP地址： 路由器配置： 路由器R0：
Router&gt;enable
Router#configure terminal
Enter configuration commands, one per line. End with CNTL/Z.
Router(config)#int g0/0
Router(config-if)#ip address 192.168.10.1 255.255.255.0
Router(config-if)#no shutdown
Router(config-if)#exit
Router(config)#int g0/1
Router(config-if)#ip address 192.168.20.1 255.255.255.0
Router(config-if)#no shutdown
Router(config-if)#int s0/3/0
Router(config-if)#ip address 192.168.50.1 255.255.255.0
Router(config-if)#no shutdown
路由器R1：
Router&gt;enable
Router#configure terminal
Enter configuration commands, one per line. End with CNTL/Z.
Router(config)#int g0/0
Router(config-if)#ip address 192.168.30.1 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98ea79f64dae63338bae915051cb4b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa26884dd320279a5533b90b786a9ebd/" rel="bookmark">
			Python&#43;OpenCV 零基础学习笔记(6):ROI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 相关链接运行环境前言ROI颜色区域分割颜色通道合并 相关链接 【2022B站最好的OpenCV课程推荐】OpenCV从入门到实战 全套课程
CSDN标题里个括号对应视频的分P
OpenCV+Python CSDN专栏
Gitee 项目地址
运行环境 Python:3.11.5Anaconda:23.7.4IDE:vscode运行环境：WindowsOpenCV:4.8.1 Python+OpenCV 零基础学习笔记(1-3):anaconda+vscode+jupyter环境配置
前言 ROI简单来说就是截取区域。本章来了解以下OpenCV如何简单的截取ROI。
ROI ROI就是局部图像处理
#%% import cv2 import matplotlib.pyplot as plt import numpy as np input_img={} input_img['rgb'] = cv2.imread('Resource\cat.png') # 截取ROI区域 input_img['roi'] = input_img['rgb'][0:50,0:200] # 展示ROI区域 cv2.imshow('roi',input_img['roi']) cv2.waitKey(0) 运行结果
颜色区域分割 #%% import cv2 import matplotlib.pyplot as plt import numpy as np input_img={} input_img['rgb'] = cv2.imread('Resource\cat.png') # 截取ROI区域 input_img['roi'] = input_img['rgb'][0:50,0:200] # 展示ROI区域 # cv2.imshow('roi',input_img['roi']) # 截取颜色通道 b,g,r = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa26884dd320279a5533b90b786a9ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7bc09dc4e1df454220e0d4ee390ae2/" rel="bookmark">
			深信服AF防火墙配置SSL VPN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防火墙版本：8.0.85
需提前确认防火墙是是否有SSL VPN的授权，确认授权用户数量
1、确认内外网接口划分
2、网络→SSL VPN，选择内外网接口地址
3、SSL VPN→用户管理→新增一个SSL VPN的用户
4、新增L3VPN资源，类型选择Other，端口选择全部，再加上可以访问的内网地址
4、新增角色授权，将刚刚创建的用户和L3VPN资源关联起来
5、新增一条应用控制策略，双向放通内网和SSL VPN的流量
注意：在防火墙有策略路由的情况下，SSL VPN的路由优先级需要高于策略路由
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72695a19529f0d9390acb1f42a81db8c/" rel="bookmark">
			MySQL数据库多版本并发控制（MVCC)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库中，并发控制是确保多个事务能够同时执行，而不会导致数据不一致或冲突的关键机制。多版本并发控制(MVCC)是一种流行的并发控制方法，它可以允许多个事务同时读取同一数据项的不同版本，而不会相互阻塞。本文将讨论MVCC的原理、实现、优势以及举例说明。
MVCC通过维护数据项的不同版本，使得事务可以看到一个一致性的数据。当一个事务修改数据时，MVCC会创建一个新版本的数据，其他事务仍然可以看到旧版本的数据，直到该事务提交或者回滚。这样方式可以大大减少事务之间的锁等待和冲突，从而提高系统的并发性能，后续我们也将讨论MySQL数据库的并发性能。
MVCC具有以下优势：
1.高并发，减少了事务之间的锁等待和冲突，允许多个事务同时访问数据；
2.非阻塞读操作：读操作不会阻塞写操作，写操作同样不会阻塞读操作；
3.更好的隔离性：通过维护多个数据版本，确保每个事务都能看到一个一致性的数据。
在MySQL默认的隔离级别（Repeatable Read）下，MVCC是如何控制数据版本的，下面举例进行说明：
当开启事务后，进行全表更新时，在INNODB_TRX表中就是有事务版本信息
查看INFORMATION_SECHEMA.INNODB_TRX表，可以看到有一个事务版本信息
关键字段的含义分别是：
如果在当前表被锁住的情况，另外一个事务想要修改其中的某项数据，那么就会产生一个等待锁的事务：
trx_state、trx_started、trx_mysql_thread分别描述了事务的状态、事务的开始时间、事务是由哪个线性产生的。
MySQL使用了一个叫做“版本链”的机制，每个行都有一个隐藏的“版本”列，用来跟踪数据的版本，当数据被更新时，新的版本会被创建，而旧版本会被保留。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab0bbf886beb954086b9536eec58097/" rel="bookmark">
			css中sprite（css精灵）是什么,有什么优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 将多个小图片拼接到一个图片中 。通过 background-position 和元素尺寸调节需要显示的背景图案。
优点 减少 HTTP 请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小
更换⻛格方便， 只需在一张或几张图片上修改颜色或样式即可实现
缺点 图片合并麻烦
维护麻烦，修改一个图片可能需要从新布局整个图片，样式。
详细介绍参考我之前的这篇文章
Web前端，CSS精灵图的使用
https://blog.csdn.net/qq_37255976/article/details/124711334
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad5e145be86c140cb0a90569933d0e9/" rel="bookmark">
			在Oracle数据库中，你可以使用LENGTH和LENGTHB函数来判断一个字符串是否包含中文。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Oracle数据库中，你可以使用LENGTH和LENGTHB函数来判断一个字符串是否包含中文。 在Oracle数据库中，你可以使用LENGTH和LENGTHB函数来判断一个字符串是否包含中文。
LENGTH函数计算字符串的字符长度，而LENGTHB函数计算字符串所占的字节长度。在英文中，一个英文字符只占一个字节，但在中文中，一个中文字符至少占两个字节。
因此，你可以通过比较LENGTH和LENGTHB函数的返回值来判断一个字符串是否包含中文。如果两个函数的返回值相等，则字符串中不包含中文；如果返回值不相等，则字符串中包含中文。
以下是一个示例查询，用于判断names列是否包含中文：
sql
SELECT * FROM your_table WHERE LENGTH(names) != LENGTHB(names); 这个查询将返回所有在names列中包含中文的行。如果你只想判断某个特定的字符串是否包含中文，可以使用类似以下的查询： sql
SELECT LENGTH(string) != LENGTHB(string) AS contains_chinese FROM dual WHERE string = 'your_string'; 将’your_string’替换为你想要检查的字符串，执行上述查询即可判断该字符串是否包含中文。
是的，通过比较LENGTH和LENGTHB函数的返回值来判断字符串是否包含中文是一种常见的方法。如果返回值相等，则字符串中不包含中文；如果返回值不相等，则字符串中包含中文。
另外，需要注意的是，数据库的字符集也会影响中文字符的字节长度。例如，在UTF-8编码下，一个中文字符通常占3个字节。所以，在使用LENGTHB函数时，需要考虑数据库的字符集设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9833c64bea32149aa55ef1b0ed379d74/" rel="bookmark">
			【计算机视觉】角点检测（Harris、SIFT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Harris 角点指的是窗口延任意方向移动，都有很大变化量的点。
用数学公式表示为：
E(u,v)反映的移动后窗口的差异，w(x,y)为每个像素的点权值，I(x+u,y+v)是移动的像素值，I(x,y)是移动前的像素值。
将E(u,v)进行泰勒展开，直接建立E(u,v)和u,v的联系
最终：
M称为二阶矩矩阵（second moment matrix）
若 互不影响：
假设 ：
只有在u方向上变化是E才会变，因此只有 都不为0时(x,y)才是角点。
若 相关可以通过正交化变成前面的形式：
就反映了点在某个方向上的变化率，之后当都很大时，该点才是角点。
为了减少计算可以用R来判定是否为角点
SIFT Harris角点检测不具有尺度不变性，窗口大小不同，响应的结果也不同。
所谓的尺度不变性，指的是提取器能够对不同的尺度下的同一个点，有比较大的响应值。
接下来，介绍的SIFT就是具有尺度不变性的特征提取算法。
在边缘提取的时候，用高斯一阶导对信号进行卷积，响应值最大的就是边界。
如果用高斯二阶导对信号进行卷积，0点就是边界点（二阶导等于0的点，对应一阶导的极值点）如果用高斯二阶导在不同的信号上进行卷积，当信号宽度与高斯滤波核匹配的时候，就能得到绝对值最大的信号，这样就建立了尺度和滤波核之间的联系。
用不同的Laplacian对同一个信号进行卷积的时候，随着的增大，响应值会越来越不明显。
因为作为分母，越来越大，卷积后的信号值就会越来越小 ，对于一阶偏导需要对卷积后的信号补偿，对于二阶偏导需要对卷积后的信息补偿 ，将响应值固定在一个尺度上。
补偿之后，就能用反映尺度
二维Laplacian高斯卷积核如下图所示：
当半径值正好与Laplacian为0的值匹配上的时候，响应值最大
假设这个圆是二进制的，简单来说就是找到一个合适的laplacian卷积核，卷积之后使得laplacian卷积核中小于0的部分权值为0，laplacian大于0的部分权值为1。
找到合适的laplacian卷积核，它的与信号半径有对应关系
SIFT使用的是DoG模版（两个高斯模版的差分），拥有和Laplacian类似的特性
一般而言，随着的增大，窗口也会变大，Laplacian每一次都会在原图进行卷积，卷积的成本就会增大。而DoG是利用高斯卷积核来做的，可以通过对较小的卷积核卷积得到较大的卷积核，减小卷积成本。
在找合适的尺度空间的时候，会进行非极大值抑制，只有当该点是27（上下两个尺度18个，当前尺度9个）个领接点中的极值时，认为该点为特征点，因此，有效DoG 个数为S时，总共的DoG个数为S+2(首尾不能构成三个尺度空间)。
每一个Octave表示对GuassianSpace缩小1/2后卷积，当我们需要更大的尺度的时候，需要跟大的sigma，意味着更大的卷积核更多的计算。SIFT算法中，将这样操作可以转换为，将图像缩小1/2，得到结果后将响应的sigma放大2倍，这样减少了计算的同时也得到了更大的尺度空间。
K的取值同样也很讲究， ，s为有效DoG个数。
K这样取值的好处是，对应高斯空间来说，只要将倒数第三图下采样2倍就能得到下一个Octave的第一个图，对于DoG空间来说，当前最后一个有效DoG的sigma与下一个Octave的第一个有效DoG的sigma是连续的（如图所示）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6784b544c036e64f5ae861c3a65a6238/" rel="bookmark">
			案例237:基于微信小程序的医院挂号预约系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
用户管理
医院管理
医生管理
公告资讯管理
科室信息管理
预约信息课程
小程序首页
科室预约
我的
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 现代经济快节奏发展以及不断完善升级的信息化技术，让传统数据信息的管理升级为软件存储，归纳，集中处理数据信息的管理方式。本微信小程序医院挂号预约系统就是在这样的大环境下诞生，其可以帮助管理者在短时间内处理完毕庞大的数据信息，使用这种软件工具可以帮助管理人员提高事务处理效率，达到事半功倍的效果。此微信小程序医院挂号预约系统利用当下成熟完善的SSM框架，使用跨平台的可开发大型商业网站的Java语言，以及最受欢迎的RDBMS应用软件之一的MySQL数据库进行程序开发。微信小程序医院挂号预约系统有管理员，用户两个角色。管理员功能有个人中心，用户管理，医生信息管理，医院信息管理，科室信息管理，预约信息管理，预约取消管理，留言板，系统管理。微信小程序用户可以注册登录，查看医院信息，查看医生信息，查看公告资讯，在科室信息里面进行预约，也可以取消预约。微信小程序医院挂号预约系统的开发根据操作人员需要设计的界面简洁美观，在功能模块布局上跟同类型网站保持一致，程序在实现基本要求功能时，也为数据信息面临的安全问题提供了一些实用的解决方案。可以说该程序在帮助管理者高效率地处理工作事务的同时，也实现了数据信息的整体化，规范化与自动化。
系统展示 用户管理 此页面提供给管理员的功能有：对用户信息进行查询，添加，删除以及批量删除操作。
医院管理 管理员可以对医院信息进行添加，修改，删除，查询操作。
医生管理 管理员可以对医生信息进行添加，修改，删除，查询操作。
公告资讯管理 管理员可以对公告资讯进行添加修改删除查询操作。
科室信息管理 教师可以对科室信息进行添加修改删除查询操作。
预约信息课程 管理员可以查看和审核用户预约信息。
小程序首页 用户可以看到公告资讯信息以及下面的导航栏。
科室预约 用户点击科室信息可以进行预约操作。
我的 我的里面可以查看订单和收藏，点击小齿轮还可以退出当前用户。
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6784b544c036e64f5ae861c3a65a6238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c3d9ee4d6a82a813f368d4f47f5002/" rel="bookmark">
			表情串转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 NWAFU 2021阶段二 D
一、题目描述 题目描述 在一个字符串中，设置了由‘/’前导字符和某些特定字母构成的转义子字符串，如“/s”、“/f”、“/c”等用于表示特殊表情符号。现要求编写一个函数，将给定字符串中的转义字符串转换为表情字符串，同时其他字符保持不变，然后返回转换后的字符串首地址。需要转义的符号串仅有以下4个：
原字符串中的特殊符号子串要转成的表情串含义/s^_^ 微笑 /f@_@ 困惑 /cT_T 哭泣/z^_~ 眨眼 函数原型规定为： int ConvertEmoji(char **dst,const char *src);
其中dst是指向转换后的带有表情串的字符串指针的指针，src是指向需要转换的原始字符串指针。函数返回的是转换后的字符串的长度。
特别说明，转换后的字符串长度长短不一，所以需要在函数中根据需要给dst所指向的转换目标字符串分配内存。函数调用结束后，需自行释放该内存。
提交时，只提交ConvertEmoji()及其调用的自定义函数的实现代码。
#include &lt;stdio.h&gt; //注意：原内容h后面多打了空格，需要删除 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define N 64 int ConvertEmoji(char **dst, const char *src); int main() { char str[N], *p = NULL; int len, i = 0; fgets(str, N, stdin); while(i &lt; strlen(str)) { if (str[i]=='\n') { str[i]='\0'; break; } i++; } len=ConvertEmoji(&amp;p, str); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09c3d9ee4d6a82a813f368d4f47f5002/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/21/">«</a>
	<span class="pagination__item pagination__item--current">22/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/23/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>