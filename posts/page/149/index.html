<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50742b121c4abc6d7ab31e812e2e9199/" rel="bookmark">
			Java基础【之】输出一个菱形（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java基础【之】输出一个菱形（详解） 代码示例《目录：Java渐进式学习》《目录：Java设计模式》《目录：从零手写Tomcat》 代码示例 public class Demo { /* 注意：编程时不可以使用汉语和拼音，要用英文单词或者英文单词缩写 如图,想要输出一个菱形： 第1行 * 第2行 *** 第3行 ***** 第4行 ******* 第5行 ***** 第6行 *** 第7行 * 思路： 1.将这个图形看成两个三角形 2.每个三角形，需要两层for循环，第一层的作用是当前行数 第二层的作用是输出当前行需要的*号 */ public static void main(String[] args) { /* *第一个，四行的，正三角形 *需要四行,所以循环四次 */ for (int i = 1; i &lt;= 4; i++) { System.out.print("第" + i + "行 "); //1.输出第一个直角三角形 //规则:行数的倒序，输出相同数量的* //也就是一共四行，那么第一行就输出 4个，第二行输出3个，第三行输出2个，第四行输出1个 for (int j = 4; j &gt;= i; j--) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50742b121c4abc6d7ab31e812e2e9199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb328a4f58a8a7c51c39a41cd6bb31fa/" rel="bookmark">
			减肥日记---那个胖子终于瘦下来了 程序员减肥记录 程序员减肥日记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		减肥日记---那个胖子终于瘦下来了 程序员减肥记录 程序员减肥日记 一、前言
早晨起来，称一称 67.6，心中窃喜，目标达成。当了这么多年胖子，终于摆脱了。 我，又瘦下来了，终于不再是胖子啦，哈哈哈。。。
二、承认自己是个胖子
1、常言道：人无需努力就会增加的是年龄，还有体重；无需努力会默默减少的是头发。不记得从何时起就是一个胖子，只记得回家过年时，和人打招呼，湾里人看到都会半信半疑的问：“你是xx家的 ，噢~~ ， 你都这么胖了... ”。 在近些年的工作生活中，我---是个胖子，已经在大家的记忆中。 （比如：死胖子）
2、很长一段时间，都不愿意承认自己是个胖子。心宽体胖啊，扛得住大风啊。 我并不是很差，我只是某方面很差：
早起不行，熬夜可以啊；减肥不行，所有的不开心，我能化作食欲啊；工作不行，我会复制粘贴啊。 3、还会立出flag：本月减肥10斤，如果没做到，下个月再发一次。 （心态好）
三、灵魂的拷问
1、难道我这辈子只能做个胖子吗？ 这是年初的给自己一个灵魂的拷问。结论是：不能，你能瘦下来。
2、胖的坏处：易生病，形象不好。 易生病：当今社会工作压力那么大，没有一个强健的体魄，上班三天，生病两天，未来如何扛起相应的责任呢？ 形象不好：对自我的要求，展示给世人的应该是个体型匀称、干净、整洁的人，而应该是一个大腹便便的胖子。
四、开始做
1、龚自珍先生《病梅馆记》有一句经典的话：梅以曲为美，直则无姿；以欹为美，正则无景；以疏为美，密则无态。引用到现在：人以白为美，黑则无姿；以瘦为美，胖则无形。总结就是：" 一白遮千丑，一胖毁所有"。胖，对应的瘦。怎么瘦？由胖到瘦的过程，叫减肥！
2、减肥原理： 大道至简，少食多动，输出 &gt; 输入 。
3、于是，做了个运动作息计划，如下：
睡满8小时 --- 23点开始上床睡觉， 睡眠不足，会变胖日行一万步 --- 小米手环记录 ， 运动量要足够每天60个俯卧撑 ， 多动。每天100个深蹲 ， 多动。合格标准是：一个月30天，27天达到。 坚持，持续性输出。 4、开始做： 立了个小目标，就有了方向，做事有了动力，师出有名。
为了实现每天一万步，能走过去的，绝对不坐地铁；能走楼梯，不电梯；弯路能到达的，绝不走直线（斑马线和天桥都可以到达的，走天桥） ... 几乎达到了一种入魔的地步。 步数再不够，跑步来填。
俯卧撑开始60个，要3次做完，慢慢的2次，再然后一次可以做到80-100个，深蹲同样。
跑步，开始跑5圈，要40分钟，跑完气喘吁吁，近乎废猫一只，一段时间后，5圈只要20多分钟，40分钟可以跑8圈左右。速度变快，效率提高。
5、瓶颈： 坚持了几个月后，真的瘦下来了不少。 再继续坚持锻炼，也仅仅是收效甚微。减肥的路上，遇到了瓶颈。少食多动，当前仅仅做到多动 ， 现在要少食，双管齐下，才能达到减肥目标。
7、改进：
原来的早餐 2碗粥2个包子1个鸡蛋，减少为1粥2包子1个鸡蛋，再减少为1粥一包子1个鸡蛋。 中餐正常 ， 晚餐适当少吃。
作为村里人，知道食物来之不易。一碗米饭，要经过 育苗，插秧，除草，收割，碾米等流程才能到饭桌上。原来在外面吃饭、自己做饭，会努力将所有食物吃完，实在撑不下了为止！ 思想上有个改变，吃到一定量，吃饱了，就不能再吃。看一眼，那些食物与你无缘，放生吧。（补充：这里没有提倡浪费、不响应国家号召的光盘行动的意思，做饭、点餐时，请量力而行，不要造成浪费即可。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb328a4f58a8a7c51c39a41cd6bb31fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6926878aa2a495e81617396cbfa2e6/" rel="bookmark">
			element ui 表格合并行和列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element ui 表格合并行和列 &lt;el-table :data="tableData" :span-method="arraySpanMethod" border style="width: 100%" &gt; &lt;el-table-column v-for="col in columns" :prop="col.dataIndex" :key="col.dataIndex" :label="col.title" align="center" &gt;&lt;/el-table-column&gt; &lt;/el-table&gt; methods: { // 合并行或列 arraySpanMethod({ row, rowIndex, columnIndex }) { // 合并的列（成一整行） if (row.colSpanRow) { if (rowIndex === rowIndex) { // 哪一行需要合并 if (columnIndex === 1) { // 第二列的值保留 return [1, 19] } else { // 其余隐藏 return [0, 0] } } } else { // 第一列和第二列 if (columnIndex === 1 || columnIndex === 0) { if (row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e6926878aa2a495e81617396cbfa2e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86aea2660e3c1c77a983a25299532b9/" rel="bookmark">
			nginx 配置 解决iframe 跨域问题 cookie失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		server { listen 443 ssl; # listen 80; server_name 10.2.168.1; #access_log /var/log/nginx/host.access.log main; # location / { # root /usr/share/nginx/html; # index index.html index.htm; # } ssl_certificate /etc/nginx/conf.d/key/server.crt; ssl_certificate_key /etc/nginx/conf.d/key/server.key; location / { #root /usr/share/nginx/html; #try_files $uri $uri/ @router; #index index.html index.htm; proxy_pass https://127.0.0.1:8020$request_uri; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header 'Access-Control-Allow-Origin' *; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' *; add_header 'Access-Control-Allow-Headers' *; proxy_cookie_path / "/; httponly; secure; SameSite=None"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d86aea2660e3c1c77a983a25299532b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bffccbeacbd6d64c0b80b4988b40f5d/" rel="bookmark">
			Prometheus抓取Docker Swarm集群副本服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dns_sd_configs在这篇博文中，我将演示如何通过在 Docker swarm 中引入一个中间 Prometheus 实例并结合几个 Prometheus 功能（主要是跨服务联合）来收集和获取所需的指标数据，从而很容易地做到这一点。
在 Docker swarm 集群中，应用程序作为服务运行。对于外部宿主机中（特指swarm 集群之外的所有东西），该服务看起来就像通过已发布端口访问的实例。但是在 swarm 内部，通常有多个运行该服务的实例（副本）。外部主动请求时，Docker 网络将到已发布服务端口路由到正在运行的副本之一。作为调用者，您无法感知被路由到服务具体实例。
如果你想拥有一个在 Docker swarm 之外运行的 Prometheus 服务器来抓取服务的指标，最简单的方法是让它主动拉取已发布服务的监控，如果服务在具有多个实例的复制模式下运行，将无法准确获得具体的实例。因为对服务的调用实际上最终在 Docker 网络负载均衡器中完成，它将抓取请求转发到一个正在运行的实例。因此，您获得的数据是其中一个服务实例的指标（您不知道是哪一个）。由于 Prometheus 会定期抓取服务指标，并且每个抓取请求都独立于之前的请求进行路由，因此下一个抓取请求可能会被路由到返回该实例指标的不同服务实例并由其响应，等等。因此，最坏的情况是 Prometheus 在每次抓取请求时都会获得一组不同的指标，不会为您提供连贯的数据。
如果 Prometheus 知道多个服务实例并可以单独抓取它们，它将为指标添加一个instance标签，并由此为每个指标和实例存储不同的时间序列。Docker swarm 在向 Prometheus 隐藏这些细节方面做得很好，至少在 swarm 之外是这样。因此，如果您将 Prometheus 本身作为 Docker swarm 中的服务运行，您可以将其dns_sd_configs功能与 Docker swarm DNS 服务发现一起使用，以单独抓取所有实例。结合 Prometheus 的跨服务联合功能，您可以从 swarm 之外的 Prometheus 服务器上抓取这些服务实例指标。
在这篇博文中，我将设置一个运行示例服务的本地 Docker swarm 集群来演示它的外观。
使用示例服务设置 Docker 群 首先，我为本地 Docker 实例初始化 swarm 模式（可以使用 再次停用docker swarm leave --force）
docker swarm init 我正在为 Mac 运行 Docker Desktop，所以这里不需要任何其他选项。有关如何在其他环境中设置本地 swarm 的详细信息，请参阅docker swarm 教程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bffccbeacbd6d64c0b80b4988b40f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84430f5329507a5194c233e3ad2b5f1/" rel="bookmark">
			关于CNN训练时loss停留在0.69，acc为0.5左右的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在用CNN作为主干网络来训练二分器时，出现了loss停留在0.69左右，acc在0.5左右的情况，在这里记录一下解决方法。
首先是我在网上收集到的方法以及我最终的解决方法。
方法1：查看数据有没有问题，看输入的数据及label是否正确。
方法2：数据没有问题的话，再查看一下输入到网络前你的data是否进行了归一化处理，如果数据没有进行归一化处理模型也容易爆炸无法收敛。
方法3：如何前面两个没有出现问题的话很大概率就是数据分布的问题，这也是一般模型无法收敛的重要原因，其解决方法就是在网络的最后一层的FC层前面加上一层BN层调整数据分布。
方法4：还是不行的话，还可以试试改变一下的bias，因为也可能因为初始bias都为0,网络太深导致梯度消失的出现。
如果上面的方法的都无法解决问题的话，那多半就是训练的问题了，网络没有正常反向传播，显然我就是属于这种情况。
可是使用下面这个代码来查看网络的参数情况，看每个batch后网络参数是否更新：
for name, param in model.named_parameters(): print(name, " ", param) 其中name是每层网络的名字，param为其对应的参数。 经过观察发现，原来其网络参数并没有更新，于是我检测了一下代码，原来loss.bcackward（）部分写错了，大家见下面的代码发现问题所在了吗？ cost = loss(output1, targets) ##计算BCE损失 model.zero_grad() loss.backward() #计算梯度回传 optimizer.step() 对没错，正确的应该是cost.backward()，backward()函数的对象是loss计算的结果cost，这里比较容易出现混淆，希望大家注意一下，将其改正后训练时loss就正常下降啦！
希望我的分享能够帮助到你！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc5111a2f9d57850db14d6a1c0ec6e7/" rel="bookmark">
			分类模型训练完之后，测试效果极差可能原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在知乎上有这样一个问题：
acc很高，但预测正确的样本占比又很低，怎么回事？ - 知乎
关于这个问题，在这个问题的回答中，有许多大佬从数据的分布、模型的结构、数据集的划分，以及验证指标等层面进行了解答。
在这里按照我的理解，简单描述一下这个问题：模型训练正常，模型测试效果很差，甚至在训练集上的测试效果都很差。简单分析一下大概有以下几个方面的原因可以排查：
1、检查模型训练和模型测试的数据处理pipeline是否一致，比如训练时做了Normalize，测试时也要做Normalize，这一点至关重要，我遇到的这类问题基本上都是因为数据预处理不一致导致的
2、检查模型在测试时有没有切换到推理模式，如pytorch中的eval()转换
3、检查输入的数据维度是否正确，比如训练时使用[N, C, H, W]，测试时也要使用同样的数据维度顺序，现在好多分类模型在后面会添加AdaptiveAvgPool层，即使输入的数据尺寸和训练时不一样也不会报错
4、检查模型参数加载是否正确，还是以pytorch框架为例，pytorch在加载模型时如果设置完全匹配的参数为False，在加载过程中即使参数和模型不匹配也不会报错，但是会使用默认的随机参数
以上就是目前在实际工作中遇到的一些可能原因分析，如果还有其他可能原因，欢迎随时指导。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa17ca93c6676010289d6dc13849c46/" rel="bookmark">
			编译GitHub上的A-LOAM开源项目出现error: ‘CV_LOAD_IMAGE_GRAYSCALE’ was not declared in this scope
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A-LOAM链接：https://github.com/HKUST-Aerial-Robotics/A-LOAM
catkin_make后出些如下错误：
/home/caohaojie/SLAM/LOAM/src/A-LOAM/src/kittiHelper.cpp: In function ‘int main(int, char**)’: /home/caohaojie/SLAM/LOAM/src/A-LOAM/src/kittiHelper.cpp:91:64: error: ‘CV_LOAD_IMAGE_GRAYSCALE’ was not declared in this scope 91 | cv::Mat left_image = cv::imread(left_image_path.str(), CV_LOAD_IMAGE_GRAYSCALE); | ^~~~~~~~~~~~~~~~~~~~~~~ 解决措施：
找到对应的kittiHelper.cpp文件，将91行与93行的CV_LOAD_IMAGE_GRAYSCALE改为cv::IMREAD_GRAYSCALE
更改后如图所示：
参考链接：https://stackoverflow.com/questions/27424285/cv-load-image-grayscale-is-not-definedpy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b87a380978feefe1bbb1401a48f05a3/" rel="bookmark">
			windows批处理命令记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批处理是一种简化的脚本语言，也称作宏。它应用于DOS和Windows系统中，它是由DOS或者Windows系统内嵌的命令解释器（通常是COMMAND. COM或者CMD.EXE）解释运行。类似于Unix中的Shell脚本。批处理文件具有.bat或者.cmd的扩展名。批处理语法中是不区分大小写。
REM 在批处理文件或 CONFIG.SYS 里加上注解或说明。
REM [comment]
ECHO 显示消息，或者启用或关闭命令回显。
ECHO [ON | OFF] 设置为OFF后不显示注释信息和不显示命令
ECHO [message]
若要显示当前回显设置，请键入不带参数的 ECHO。
PS：echo off 还是会显示这一行命令，若是执行 @echo off 就不会显示
PAUSE 暂停批处理程序，并显示以下消息:
请按任意键继续. . .
SET 显示、设置或删除 cmd.exe 环境变量。
SET [variable=[string]]
variable 指定环境变量名。
string 指定要指派给变量的一系列字符串。
要显示当前环境变量，键入不带参数的 SET。
如果命令扩展被启用，SET 会如下改变:
可仅用一个变量激活 SET 命令，等号或值不显示所有前缀匹配SET 命令已使用的名称的所有变量的值。
例如:SET P会显示所有以字母 P 打头的变量
如果在当前环境中找不到该变量名称，SET 命令将把 ERRORLEVEL设置成 1。
SET 命令不允许变量名含有等号。
在 SET 命令中添加了两个新命令行开关:
SET /A expression
SET /P variable=[promptString]
set str=hello world设置一个字符串变量，若是字符串中含特殊字符，用双引号包含：set str="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b87a380978feefe1bbb1401a48f05a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a2e9b450febe8219b1c908350cce238/" rel="bookmark">
			windows批处理运算符记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一元运算符 算数运算符 +求和set /a a=1+1 rem a=2-求差set /a a=2-1 rem a=1*求积set /a a=2*2 rem a=4/求商set /a a=4/3 rem a=1%%求余set /a a=5%%3 rem a=2 例1：
set /a a=5,b=3
set /a c=a%%b
set /a d=%a% %% %b%
rem %c%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5fedce868e0b5f3a03e716617f618d/" rel="bookmark">
			Flink CEP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 1. CEP 是什么 所谓CEP，其实就是“复杂事件处理（Complex Event Processing）”的缩写；而 Flink CEP，就是 Flink 实现的一个用于复杂事件处理的库（library）。
那到底什么是“复杂事件处理”呢？就是可以在事件流里，检测到特定的事件组合并进行处理，比如说“连续登录失败”，或者“订单支付超时”等等。
具体的处理过程是，把事件流中的一个个简单事件，通过一定的规则匹配组合起来，这就是“复杂事件”；然后基于这些满足规则的一组组复杂事件进行转换处理，得到想要的结果进行输出。
总结起来，复杂事件处理（CEP）的流程可以分成三个步骤：
（1） 定义一个匹配规则
（2） 将匹配规则应用到事件流上，检测满足规则的复杂事件
（3） 对检测到的复杂事件进行处理，得到结果进行输出
如图所示，输入是不同形状的事件流，我们可以定义一个匹配规则：在圆形后面紧跟着三角形。那么将这个规则应用到输入流上，就可以检测到三组匹配的复杂事件。它们构成了一个新的“复杂事件流”，流中的数据就变成了一组一组的复杂事件，每个数据都包含了一个圆形和一个三角形。接下来，我们就可以针对检测到的复杂事件，处理之后输出一个提示或报警信息了。
所以，CEP 是针对流处理而言的，分析的是低延迟、频繁产生的事件流。它的主要目的， 就是在无界流中检测出特定的数据组合，让我们有机会掌握数据中重要的高阶特征。
2. 模式（Pattern） CEP 的第一步所定义的匹配规则，我们可以把它叫作“模式”（Pattern）。模式的定义主要就是两部分内容：
每个简单事件的特征简单事件之间的组合关系 当然，我们也可以进一步扩展模式的功能。比如，匹配检测的时间限制；每个简单事件是否可以重复出现；对于事件可重复出现的模式，遇到一个匹配后是否跳过后面的匹配；等等。
所谓“事件之间的组合关系”，一般就是定义“谁后面接着是谁”，也就是事件发生的顺序。我们把它叫作“近邻关系”。可以定义严格的近邻关系，也就是两个事件之前不能有任何其他事件；也可以定义宽松的近邻关系，即只要前后顺序正确即可，中间可以有其他事件。另外， 还可以反向定义，也就是“谁后面不能跟着谁”。
CEP 做的事其实就是在流上进行模式匹配。根据模式的近邻关系条件不同，可以检测连续的事件或不连续但先后发生的事件；模式还可能有时间的限制，如果在设定时间范围内没有满足匹配条件，就会导致模式匹配超时（timeout）。
Flink CEP 为我们提供了丰富的API，可以实现上面关于模式的所有功能，这套 API 就叫作“模式API”（Pattern API）。关于 Pattern API，我们会在后面详细介绍。
3. 应用场景 CEP 主要用于实时流数据的分析处理。CEP 可以帮助在复杂的、看似不相关的事件流中找出那些有意义的事件组合，进而可以接近实时地进行分析判断、输出通知信息或报警。这在企业项目的风控管理、用户画像和运维监控中，都有非常重要的应用。
风险控制
设定一些行为模式，可以对用户的异常行为进行实时检测。当一个用户行为符合了异常行为模式，比如短时间内频繁登录并失败、大量下单却不支付（刷单），就可以向用户发送通知信息，或是进行报警提示、由人工进一步判定用户是否有违规操作的嫌疑。这样就可以有效地控制用户个人和平台的风险。用户画像
利用 CEP 可以用预先定义好的规则，对用户的行为轨迹进行实时跟踪，从而检测出具有特定行为习惯的一些用户，做出相应的用户画像。基于用户画像可以进行精准营销，即对行为匹配预定义规则的用户实时发送相应的营销推广；这与目前很多企业所做的精准推荐原理是一样的。运维监控
对于企业服务的运维管理，可以利用 CEP 灵活配置多指标、多依赖来实现更复杂的监控模式。 CEP 的应用场景非常丰富。很多大数据框架，如 Spark、Samza、Beam 等都提供了不同的CEP 解决方案，但没有专门的库（library）。而 Flink 提供了专门的CEP 库用于复杂事件处理，可以说是目前CEP 的最佳解决方案。
二、快速上手 1. 需要引入的依赖 想要在代码中使用 Flink CEP，需要在项目的pom 文件中添加相关依赖：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a5fedce868e0b5f3a03e716617f618d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04af24c12ace30b5b563c278d3509859/" rel="bookmark">
			ImportError: /lib64/libstdc&#43;&#43;.so.6: version `CXXABI_1.3.11‘ not found (requi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载libstdc++.so.6.0.26
拷贝到/usr/lib64/
重命名mv libstdc++.so.6 libstdc++.so.6.bak
ln -s libstdc++.so.6.0.26 libstdc++.so.6重新构建动态库libstdc++.so.6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ca67c9059178e3c641be583b331af9/" rel="bookmark">
			原生js实现分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生javascript分页 html分页与ajax数据请求结合使用 前端js分页 1. page.css .pagination { padding:5px; font-family: '微软雅黑',Arial,Verdana,arial,serif; } .pagination ul { list-style: none; padding-left: 0; font-size: 0; } .pagination ul li { padding: 0 10px; vertical-align: bottom; display: inline-block; font-size: 14px; min-width: 36px; min-height: 28px; line-height: 28px; cursor: pointer; box-sizing: border-box; text-align: center; margin-left: -1px; color: #606266; border: 1px solid #ebebeb; height: 30px; transition: all .3s; } .pagination ul li:hover { color: #80bd01; } .pagination ul li.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ca67c9059178e3c641be583b331af9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a68148ecc63b5993e576eda1c336f7/" rel="bookmark">
			NUMA架构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 1、SMP VS. AMP SMP(Symmetric Multiprocessing)， 即对称多处理器架构，是目前最常见的多处理器计算机架构。AMP(Asymmetric Multiprocessing)， 即非对称多处理器架构，则是与SMP相对的概念。 那么两者之间的主要区别是什么呢？ 总结下来有这么几点，
SMP的多个处理器都是同构的，使用相同架构的CPU；而AMP的多个处理器则可能是异构的。SMP的多个处理器共享同一内存地址空间；而AMP的每个处理器则拥有自己独立的地址空间。SMP的多个处理器操通常共享一个操作系统的实例；而AMP的每个处理器可以有或者没有运行操作系统，运行操作系统的CPU也是在运行多个独立的实例。SMP的多处理器之间可以通过共享内存来协同通信；而AMP则需要提供一种处理器间的通信机制。 SMP和AMP的深入介绍很多经典文章书籍可参考，此处不再赘述。现今主流的x86多处理器服务器都是SMP架构的， 而很多嵌入式系统则是AMP架构的。
2、NUMA VS. UMA NUMA(Non-Uniform Memory Access)非均匀内存访问架构是指多处理器系统中，内存的访问时间是依赖于处理器和内存之间的相对位置的。 这种设计里存在和处理器相对近的内存，通常被称作本地内存；还有和处理器相对远的内存， 通常被称为非本地内存。
UMA(Uniform Memory Access)均匀内存访问架构则是与NUMA相反，所以处理器对共享内存的访问距离和时间是相同的。
由此可知，不论是NUMA还是UMA都是SMP架构的一种设计和实现上的选择。
阅读文档时，也常常能看到ccNUMA(Cache Coherent NUMA)，即缓存一致性NUMA架构。 这种架构主要是在NUMA架构之上保证了多处理器之间的缓存一致性。降低了系统程序的编写难度。
x86多处理器发展历史上，早期的多核和多处理器系统都是UMA架构的。这种架构下， 多个CPU通过同一个北桥(North Bridge)芯片与内存链接。北桥芯片里集成了内存控制器(Memory Controller)。
下图是一个典型的早期 x86 UMA 系统，四路处理器通过 FSB (前端系统总线, Front Side Bus) 和主板上的内存控制器芯片 (MCH, Memory Controller Hub) 相连，DRAM 是以 UMA 方式组织的，延迟并无访问差异。
图：x86 UMA
注：PCH(Platform Controller Hub)，Intel 于 2008 年起退出的一系列晶片组，用于取代以往的 I/O Controller Hub（ICH)
在 UMA 架构下，CPU 和内存控制器之间的前端总线 (FSB) 在系统 CPU 数量不断增加的前提下， 成为了系统性能的瓶颈。因此，AMD 在引入 64 位 x86 架构时，实现了 NUMA 架构。之后， Intel 也推出了 x64 的 Nehalem 架构，x86 终于全面进入到 NUMA 时代。x86 NUMA 目前的实现属于 ccNUMA。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a68148ecc63b5993e576eda1c336f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70904403a511abe5e388fa156f26adb9/" rel="bookmark">
			excel中设置下拉框sheet关联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel中添加下拉框内容 1.直接输入来源，流程如下图
注：每个选项之间需要用英文逗号隔开。
2.通过引用方式，首先先准备好内容，再供引用。
流程如下
1.创建内容，选定创建的所有内容并设置其名称，这里新建一个sheet用于提供内容选项
注：这里的名称是唯一标识，不可重复，绑定的是所选定的内容。
然后引用，引用的方式有两种，一种是直接使用=name，一种是使用=Sheet2!$A 1 : 1: 1:A 4 这 个 好 理 解 一 种 是 直 接 通 过 n a m e 来 获 取 绑 定 的 A 1 − A 4 的 内 容 ， 一 种 就 直 接 是 A 1 − A 4 格 式 如 上 S h e e t m ！ 4 这个好理解一种是直接通过name来获取绑定的A1-A4的内容，一种就直接是A1-A4格式如上Sheetm！ 4这个好理解一种是直接通过name来获取绑定的A1−A4的内容，一种就直接是A1−A4格式如上Sheetm！A B : B: B:A$D ,Sheetm为内容的sheet页面，A为第A列，BD为B行至D行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70904403a511abe5e388fa156f26adb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c6c2c8dade28d732dd98515b8dd1ca/" rel="bookmark">
			PWA详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PWA（Progressive Web App，渐进式网页应用，逐渐接近原生app的web app）是一种理念，使用多种技术来增强web app的功能，可以让网站的体验变得更好，能够模拟一些原生功能，比如通知推送。在移动端利用标准化框架，让网页应用呈现和原生应用相似的体验。
PWA不能包含原生OS相关代码。PWA仍然是网站，只是在缓存、通知、后台功能等方面表现更好。Electron程序相当于包裹OS原生启动器（Launcher）的网站，未来，许多Electron程序可能转化为PWA。
1. 概念 PWA 是 Google 于 2016 年提出的概念，于 2017 年正式落地，于 2018 年迎来重大突破，全球顶级的浏览器厂商，Google、Microsoft、Apple 已经全数宣布支持 PWA 技术。
PWA 全称为 Progressive Web App，中文译为渐进式 Web APP，其目的是通过各种 Web 技术实现与原生 App 相近的用户体验（用户体验逐渐接近原生App）。
纵观现有 Web 应用与原生应用的对比差距，如离线缓存、沉浸式体验等等，可以通过已经实现的 Web 技术去弥补这些差距，最终达到与原生应用相近的用户体验效果。
2. 特性 安全可靠
使用 Service Work 技术实现即时下载，当用户打开应用后，页面资源的加载不再完全依赖于网络，而是使用 Service Work 缓存离线包存在本地，确保为用户提供即时可靠的体验。
访问更快
首屏可以部署在服务端，节省网页请求时间，加载速度更快，拥有更平滑的动态效果和快速的页面响应。
响应式界面
支持各种类型的终端和屏幕。
沉浸式体验
在支持 PWA 的浏览器和手机应用上可以直接将 Web 应用添加到用户的主屏幕上，无需从应用商店下载安装。从主屏幕上打开应用之后，提供沉浸式的全屏幕体验。
3. 功能 手机应用配置(Web App Manifest)
可以通过 manifest.json 文件配置，使得可以直接添加到手机的桌面上。
离线加载与缓存(Service Worker+Cache API )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83c6c2c8dade28d732dd98515b8dd1ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b8303b5ae31fb6674cf97d5c70656f/" rel="bookmark">
			HTML——HTML基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是HTML?
2.HTML基础语法
（1）HTML标签
（2）HTML元素
3.实例
1.什么是HTML? HTML 指的是超文本标记语言: HyperText Markup Language,是一种用来描述网页的一种语言。值得注意的是HTML不是一种编程语法，而是一种标记语言。标记语言是一种标记标签，HTML就是使用标记标签来描述网页。HTML文档也叫做web网页，包含了HTML标签和文本内容。
2.HTML基础语法 （1）HTML标签 HTML标签是HTML的一个重要组成部分，是由尖括号所包围的关键词，比如&lt;html&gt;。HTML标签通常是成对出现的，比如&lt;p&gt;内容&lt;/p&gt;，其中第一个是开始标签，第二个是结束标签。值得注意的是虽然大多数的浏览器在没有使用结束标签的情况下也可以正确的显示HTML，但是不能依赖这种做法，忘记使用标签会产生不可预料的结果或错误。
（2）HTML元素 HTML元素和HTML标签通常是描述同样的意思，但是一个HTML元素包含了开始标签与结束标签。
以下是常用的HTML的常用元素
&lt;html&gt; &lt;/html&gt;定义整个HTML文档&lt;body&gt; &lt;/body&gt;定义HTML文档的主体 &lt;title&gt; &lt;/title&gt;
定义HTML文档的标题&lt;hx&gt; &lt;/hx&gt;(x=1~6)定义HTML文档的x级标题&lt;p&gt; &lt;/p&gt;定义HTML文档的段落&lt;a&gt; &lt;/a&gt;在HTML文档种添加链接 3.实例 一个简单HTML文档实例框图
代码实例：
&lt;!DOCTYPE html&gt;&lt;!-- 首先声明为HTML5文档 --&gt; &lt;html&gt;&lt;!-- 定义html文档 --&gt; &lt;head&gt; &lt;!-- 定义html头部 --&gt; &lt;meta charset="utf-8"&gt; &lt;!-- 修改编码为中文 --&gt; &lt;title&gt;My First Html&lt;/title&gt; &lt;!-- 定义网页标题 --&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- 定义html文档主体 --&gt; &lt;h1&gt;我的一级标题&lt;/h1&gt; &lt;!-- 定义一级标题 --&gt; &lt;p&gt;我的第一个段落&lt;/p&gt; &lt;!-- 定义段落 --&gt; &lt;h2&gt;我的二级标题&lt;/h2&gt; &lt;!-- 定义二级标题--&gt; &lt;p&gt;我的第二个段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 运行效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ecfe22c4890f494376e462710f00be6/" rel="bookmark">
			PCL教程-PCLVisualizer可视化类的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：PCLVisualizer — Point Cloud Library 0.0 documentation
PCLVisualizer是PCL中全功能的可视化类。虽然在使用上比CloudViewer更加复杂，但是它功能更加强大，提供了比如显示法线、绘制图形以及多视点等特性。
本篇教程将从显示一个独立点云开始，使用一个示例代码来演示PCLVisualizer的一些功能。大多数代码示例都是样板文件，用于设置可视化的点云。每个示例的相关代码都包含在特定于该示例的函数中。代码如下所示。
/**创建一个视口从 [xmin,ymin] 到 [xmax,ymax]. * 参数 xmin ：视口在X轴的最小值 (0.0 &lt;= 1.0) * 参数 ymin ：视口在Y轴的最小值 (0.0 &lt;= 1.0) * 参数 xmax ：视口在X轴的最大值 (0.0 &lt;= 1.0) * 参数 ymax： 视口在Y轴的最大值 (0.0 &lt;= 1.0) * 参数 viewport： 新视口的id，传入的是个引用参数 * * 注意： *如果当前窗口不存在渲染器，将创建一个，并且*视口将被设置为0 ('all')。如果一个或多个渲染 *器存在，视口ID将被设置为渲染器的总数- 1 */ void createViewPort (double xmin, double ymin, double xmax, double ymax, int &amp;viewport); //简单显示PointXYZ点云,返回一个视窗的shared智能指针 pcl::visualization::PCLVisualizer::Ptr simpleVis(pcl::PointCloud&lt;pcl::PointXYZ&gt;::ConstPtr cloud) { //打开3D视窗并添加点云 pcl::visualization::PCLVisualizer::Ptr viewer(new pcl::visualization::PCLVisualizer("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ecfe22c4890f494376e462710f00be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a32c18ae44b6b75c8b6204de7f6409c/" rel="bookmark">
			mmdetection之config文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. config配置文件命名规则
2. config 文件概述
3.config 类
3.1 读取配置文件
3.2 修改配置参数
3.3使用中间变量
3.4 打印配置文件
1. 官方文档--config文件教程
2. 知乎--MMCV核心组件Config
1. config配置文件命名规则 MMDetection已经实现的配置文件都位于./configs文件夹下，配置文件都按照统一的规则命名，具体段的含义可以去官方文档自行查阅。
#命名规则
{model}_[model setting]_{backbone}_{neck}_[norm setting]_[misc]_[gpu x batch_per_gpu]_{schedule}_{dataset}
#其中各个字段的含义
{model}： 模型种类，例如 faster_rcnn, mask_rcnn 等。
[model setting]： 特定的模型，例如 htc 中的without_semantic， reppoints 中的 moment 等。
{backbone}： 主干网络种类例如 r50 (ResNet-50), x101 (ResNeXt-101) 等。
{neck}： Neck 模型的种类包括 fpn, pafpn, nasfpn, c4 等。
[norm_setting]： 默认使用 bn (Batch Normalization)，其他指定可以有 gn (Group Normalization)， syncbn (Synchronized Batch Normalization) 等。 gn-head/gn-neck 表示 GN 仅应用于网络的 Head 或 Neck， gn-all 表示 GN 用于整个模型， 例如主干网络、Neck 和 Head。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a32c18ae44b6b75c8b6204de7f6409c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1cdaca07b1c4cd884ae69836bd8cb9e/" rel="bookmark">
			SpringSecurity-OAuth2万文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringSecurity-OAuth2万文详解 Oauth2.0是目前流行的授权机制，用于授权第三方应用，获取数据。Oauth协议为用户资源的授权提供一个安全、开放并且简易的 规范标准 。和以往授权不同的是Oauth不会使第三方触及到用户的账号信息(用户和密码)，也就是说第三方不需要使用用户的用户名和密码就可以获取到该用户的用户资源权限。
OAuth2设计的角色 资源所有者（Resource Owner） :通常是 用户（User） ，如昵称、头像这些资源的拥有者(用户只是将这些资源放到服务提供商的资源服务器中)。第三方应用 ：或者称为第三方客户端(Clinet),希望使用资源服务器提供的资源认证服务器(Authorization Server) :专门用于对资源所有者的身份进行认证，对要访问的资源进行授权、产生令牌的服务器。访问资源，需要通过认证服务器由资源所有者授权才可以访问。资源服务器(Resource Server) :存储用户的资源，验证令牌有效性。比如：微信资源服务器存储了微信用户信息，淘宝资源服务器存储了淘宝的用户信息。服务提供商(Service Provider) :认证服务和资源服务归属于一个机构，该机构就是服务提供商。 OAuth2认证流程 OAuth在第三方应用和服务提供商之间，设置一个授权层(authorization layer)。第三方应用不能直接登录"服务提供商"，只可以通过授权层将"第三方应用"和用户区分开来。"第三方应用"通过授权层获取令牌（accesstoken）,获取令牌后拿令牌去访问服务提供商。令牌和用户密码不同，可以指定授权层令牌的权限范围和有效期，"服务提供商"根据令牌的权限范围和有效期，向"第三方应用"开放用户对应的资源。第三方客户端登录主要步骤如下：
第三方应用，向认证服务器请求授权。用户告知认证服务器同意授权（通常是通过用户扫码或输入“服务提供商”的用户名密码的方式）认证服务器向第三方应用告知授权码（code）第三方应用使用授权码（code）申请Access Token认证服务器验证授权码，颁发Access Token OAuth2四种授权方式 OAuth2有四种授权方式分别如下
授权码模式(Authorization Code) 授权码模式(Authorization Code):功能是最完整的，流程也是最严密的，国内各大服务提供商(微信、微博、淘宝、百度)都是使用此授权模式进行授权。该授权模式可以确定是用户进行授权的， 并且令牌是认证服务器放发到第三方应用服务器，而不是浏览器上 。
简化模式(Implicit) 简化模式(Implicit):和授权码模式不同的是，令牌发放给浏览器，OAuth2客户端运行在浏览器中，通过KS脚本去申请令牌。而不是发放该第三方应用的服务器。
密码模式(resource owner password credentials) 密码模式(resource owner password credentials):将用户和密码传过去，直接获取 accesstokne ,用户同意授权动作是在 第三方应用上完成 ，而不是在认证服务器。第三方应用申请令牌时，直接带用户名和密码去向认证服务器申请令牌。 这种方式认证服务器无法断定用户是否真的授权，用户和密码可能是第三方应用盗取过来的 。
流程如下：
用户向客户端直接提供认证服务器想要的用户名和密码。客户端将用户名和密码发给认证服务器，向认证服务器请求令牌认证服务器确认后，向客户端提供访问令牌 客户端模式(client credentials) 客户端模式(client credentials):使用较少，当一个第三方应用自己本身需要获取资源(而不是以用户的名义)，而不是获取用户资源时，客户端模式十分有用。
具体流程如下：
客户端向认证服务器进行身份认证，并要求一个访问令牌认证服务器确认后，向客户端提供访问令牌 Spring Security OAuth2认证服务器 Spring Security登录信息存储在Session中，每次访问服务的时候，都会查看浏览器中Cookie中是不是存在JSESSIONID,如果不存在JSESSIONID会新建一个Session，将新建的SessionID保存到Cookie中。每一次发送请求都会通过浏览器的SessionID查找到对应的Session对象。从而获取用户信息。
前后端分离后，前端部署在单独的Web服务器，后端部署在另外的应用服务器上，浏览器先访问Web服务器，Web服务器访问请求到应用服务器，这样使用Cookie存储就不合适具体原因如下：
开发复杂安全性差客户体验差有些前端技术不支持Cookie,比如:小程序 解决方式:
使用令牌方式进行认证解决上面说的问题，可以使用OAuth2协议。
基础模块创建 创建spring-oauth2-base模块 在spring-oauth2-base模块的pom.xml中添加相关依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1cdaca07b1c4cd884ae69836bd8cb9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d17c5e11be9b0fd2a06b30541e57781/" rel="bookmark">
			第一个Unity项目——Flappy Bird
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity是什么：
它就是一个2D/3D编辑器，同时又是一个游戏引擎
游戏引擎：使用者只需要调用这些功能，而不需要重写实现这些功能
第一步：资源导入与资源处理 资源导入的方法：
直接将资源拖入Project面板
资源处理
2D游戏总的来说是依靠Sprites(图片精灵)
Sprite的类型
Default——默认纹理类型
Normal map——法线贴图资源
Editor GUI and Legacy ——用户界面的特图资源
Sprite——图片精灵
Cursor——鼠标光标
Cookie——光斑
Lightmap——光照贴图
Directional Lightmap——方向光贴图
Single Channel——单通道纹理
主角图片的创建
首先要将Single(单张图片) 变为Multiple(多张图片)
然后点击Sprite Editor 进行图片编辑
对图片进行分割
Automatic 自动
Grid By Cell Size 按照每一格像素切割
Gird By Cell Count 按照图片的数量切割
透明模式与颜色模式
场景创建 场景的层级关系
不同的图片处于不同的层级
Sorting Layer 层级的设置
Order in Layer 层级的优先级
1、
同一层级的图片，优先级越大，图片越处在前面
2、
添加新的图层，越在下的图层就越在前。
项目开始：快捷Ctrl+P
主角组件创建
增加组件
2D物理组件
2D刚体
圆形碰撞器
场景组件创建
添加Colider(碰撞器)
编辑编辑器
第二步：添加代码脚本 设置代码编辑器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d17c5e11be9b0fd2a06b30541e57781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08fa3c6b7f516094d938098f979d779/" rel="bookmark">
			JS闭包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS闭包 基本知识作用域函数作用域和全局作用域块级作用域和暂时性死区 执行上下文和调用栈代码执行的两个阶段调用栈 闭包内存管理内存管理基本概念内存泄漏场景举例浏览器垃圾回收内存泄漏和垃圾回收注意事项 例题分析实战例题1实战例题2实战例题3实战例题4 总结 基本知识 作用域 作用域可以理解为某种规则下的限定范围，该规则用于指导开发者如何在特定场景下查找变量。
函数作用域和全局作用域 function foo () { var a = 'bar' console.log(a); } foo(); 对以上代码改动：
var b = 'bar'; function foo(){ console.log(b); } foo(); 执行时，foo函数在自身作用域内未找到b变量，会继续向外扩大查找范围，在全局作用域中找到了变量b。
function bar(){ var b = 'bar'; } function foo(){ console.log(b); // b is not defined } foo(); foo和bar分属两个彼此独立的函数作用域，foo无法访问bar中定义的变量b，foo作用域链内(直到上层全局作用域中)也不存在相应的变量，报错。
在Js执行函数时，遇见变量且需要读取其值，就会“就近”先在函数内部查找该变量的声明和赋值。如果在函数内部无法找到，就跳出函数作用域，到更上层作用域中查找。
function bar(){ var b= 'bar'; function foo(){ console.log(b); } foo(); } bar(); foo执行时，变量b的声明和赋值是在foo的上层函数bar的作用域中获取的。
var b= 'bar'; function bar(){ function foo(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08fa3c6b7f516094d938098f979d779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da40bf7e28a862f575459b8d04db4eef/" rel="bookmark">
			C&#43;&#43;_4——关键字（extern）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++_4——关键字（extern） 1 extern "C" 与 C/C++混合编程C++与C混合编程的问题C++链接规范 extern"language string"编译器 gcc和g++条件编译的几个使用场景 2 extern 修饰变量 / 函数修饰变量修饰函数 3 其他的一些点存储持续性和链接性 参考 这一系列文章的目的是在学习了C++基础后，继续补充一些C++基础和进阶的知识点，包括C++11的相关内容。
C++网站：http://www.cplusplus.com/reference/
1 extern “C” 与 C/C++混合编程 C++与C混合编程的问题 为什么不直接用C编译器编译C++代码
因为，C++有很多内容是C没有的，比如一些 很多关键字…
另外，编译器将函数名编译成各种符号供链接器使用，C++编译器编译出来的符号是与形参列表相关的，因而重载的函数其编译出来的符号是不同的；而，C编译器编译出来的符号仅与函数名有关，因而重载的函数器编译出来的符号是相同的，这在链接时就会报错
为什么不直接使用C++编译器编译C代码
虽然一般意义上讲C++是C的超集，但C++与C并不是完全包含的关系，C中也有C++不支持的内容，如这篇博提及的各种差异…
另外，假设…
有C代码文件 a.c 和 a.h，并用C编译器生成目标文件 a.o；
有C++代码文件 b.cpp，并引用C头文件（a.h）和使用其中的函数，使用C++编译器生成目标文件 b.o；
链接时，需要链接 a.o 和 b.o ，这将在 b.o 产生符号未定义的错误，原因是两个目标文件对C函数编译后的符号是不同的
不同语言的代码尽量使用其对应的编译器编译。C++制定了链接规范，来指定编译器，比如，当需要在C++编译器中编译C代码时，使用extern “C” 调用C编译器
C++链接规范 extern"language string" 常用有两个：extern “C” 和 extern “C++” ，当只有extern修饰函数时，默认为extern “C++”
用法1单个声明：extern "C" void foo();
用法2一组声明：
extern "C" { void foo(); int bar(); } 当然，加了 extern"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da40bf7e28a862f575459b8d04db4eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076a58903d00a3d3d4be52f13abb39d2/" rel="bookmark">
			Visual Studio无法调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、最近Visual studio调试不起来，运行完报错 二、解决方法 打开 调试&gt;&gt;&gt;&gt;选项&gt;&gt;&gt;&gt;常规&gt;&gt;&gt;对ASP.NET启用JavaScript调试勾勾去掉
转载于:https://www.cnblogs.com/xqz0618/p/wfts.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c34b96e8ed78aefb52e3a11b5cd168/" rel="bookmark">
			java调用C或者C&#43;&#43;动态库dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java调用C或者C++动态库dll，本文章使用的是IntelliJ IDEA Community Edition 2021.2.3版本测试的
1、新建项目 linjie.demo，添加类HelloLinjie
2、选择项目---新建----目录，输入libs，回车，新建根目录下libs成功，然后把需要的jar包-jna.jar拷贝到libs中
3、然后导入本地jna.jar Jar 包（java调用C或者C++动态库dll 需要的jar包---jna.jar）
选择 文件--项目结构
选择 项目结构-----库--- + 选择java，然后选择路径中的libs找到需要添加的jar包，选中，点击应用，确定
选择 项目结构-----模块--- + 选择需要添加的jar包，选中，点击应用，确定 4、选择src ，右键新建java类，输入MyDll，选择接口，然后引用jna.jar中api，import com.sun.jna.Library，import com.sun.jna.Native，加载需要的DLLT.dll(java调用C或者C++动态库dll,64位的dll，32位的需要安装对应的jre即可)
package linjie.demo; import com.sun.jna.Library; import com.sun.jna.Native; /** * 功能简述 *java调用C或者C++动态库dll,64位的dll * @author yangsx * @version 1.0.0 * @date 2021-09-07 */ public interface MyDll extends Library { //1、动态库拷贝到Java工程目录下 //MyDll mydll = (MyDll) Native.loadLibrary("DLLT.dll",MyDll.class); //2、动态库拷贝不在Java工程目录下，指定绝对路径 MyDll mydll = (MyDll) Native.loadLibrary("G:\\测试\\64\\DLLT.dll",MyDll.class); int add(int a,int b);//c或者c++中的方法 } 5、main方法中内容如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c34b96e8ed78aefb52e3a11b5cd168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2783f5fc1cf07a9a3ab8cb33f178bef6/" rel="bookmark">
			CODA：自动驾驶中道路目标检测的极端情况数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“3D视觉工坊”，选择“星标”
干货第一时间送达
来源丨计算机视觉深度学习和自动驾驶
2022年3月arXiv论文“CODA: A Real-World Road Corner Case Dataset for Object Detection in Autonomous Driving“，华为和香港、广州两所大学一起发表。
大多数现有的检测器无法检测到不常见的目标和极端情况（例如，狗过马路），在某些情况下可能导致严重事故，使得可靠自动驾驶的实际应用时间表变得不确定。阻碍开发真正可靠的自动驾驶系统的一个主要原因是缺乏公共数据集来评估极端情况下目标检测器的性能。因此这里引入了一个CODA的挑战性数据集，该数据集揭示了基于视觉检测器的关键问题。该数据集由 1500 个精心挑选的真实世界驾驶场景组成，每个场景包含四个目标级的极端案例（平均），跨越 30 多个目标类别。在大规模自动驾驶数据集上训练的标准目标寄存器在CODA的mAR表现显着下降到不超过12.8%。
此外，采用最先进的开放世界目标检测器进行实验，发现无法可靠地识别CODA中的新目标，这表明用于自动驾驶的强大感知系统可能还遥不可及。CODA数据集期望能促进对真实世界自动驾驶可靠检测的进一步研究。
数据集网址：https://coda-dataset.github.io
如图是CODA和其他公开数据集的检测结果比较：
该图是CODA的一些例子：
CODA中场景是从三个大型自动驾驶数据集中精心挑选的：KITTI 、nuScenes 和ONCE，一共为CODA贡献了1500个不同的场景，每个场景至少包含一个对自动驾驶汽车或其周围生活和资产有害的目标级极端案例。极端情况通常可以分为7个超级类别：车辆，行人，骑自行车，动物，交通设施，障碍物和杂项，如图列出的是下面34个细分类别：
用于确定目标是否为极端情况的主要标准如下：
风险：目标阻挡或即将阻挡自动驾驶汽车的潜在路径。不在道路上的静态目标，如树木和建筑物，不被视为阻挡。
新颖性：该目标不属于任何通用类的通用驾驶基准，或者它是通用类的新实例。为简单起见，把SODA10M的类作为通用类。
CODA的数据集建设分两个主要阶段进行。第一阶段是自动生成提议，从初始数据中识别潜在的极端情况，然后第二阶段，手动选择和标记过程，消除提议误报，对剩余的真目标进行分类，同时调整其边框使其更精确。
下图是用于生成极端案例提议（COPG）的流水线。流水线输入是给定场景的点云和图像。点云用于计算（a），而图像（b）用于生成（c）和（d），这有助于删除无效的提议。输出（g）是一组边框，指示图像中提议的极端情况。
下表是与其他道路异常数据集的比较。与CODA相比，其他数据集要么是合成的，要么是小规模的。BDD-Anomaly （v1） 是现实世界中最大的一个道路异常集，尽管它在实例数量上与 CODA 相当，但只包含两个目标类。
下表是CODA上的检测结果：
下图是COPG的提议和标注例子：
下表是COPG和其他非正常/目标检测器的评估：
本文仅做学术分享，如有侵权，请联系删文。
干货下载与学习
后台回复：巴塞罗那自治大学课件，即可下载国外大学沉淀数年3D Vison精品课件
后台回复：计算机视觉书籍，即可下载3D视觉领域经典书籍pdf
后台回复：3D视觉课程，即可学习3D视觉领域精品课程
3D视觉精品课程推荐：
1.面向自动驾驶领域的多传感器数据融合技术
2.面向自动驾驶领域的3D点云目标检测全栈学习路线！(单模态+多模态/数据+代码)
3.彻底搞透视觉三维重建：原理剖析、代码讲解、及优化改进
4.国内首个面向工业级实战的点云处理课程
5.激光-视觉-IMU-GPS融合SLAM算法梳理和代码讲解
6.彻底搞懂视觉-惯性SLAM：基于VINS-Fusion正式开课啦
7.彻底搞懂基于LOAM框架的3D激光S‍LAM: 源码剖析到算法优化
8.彻底剖析室内、室外激光SLAM关键算法原理、代码和实战(cartographer+LOAM +LIO-SAM)
9.从零搭建一套结构光3D重建系统[理论+源码+实践]
10.单目深度估计方法：算法梳理与代码实现
11.自动驾驶中的深度学习模型部署实战
12.相机模型与标定(单目+双目+鱼眼）
13.重磅！四旋翼飞行器：算法与实战
14.ROS2从入门到精通：理论与实战
15.国内首个3D缺陷检测教程：理论、源码与实战
重磅！3DCVer-学术论文写作投稿 交流群已成立
扫码添加小助手微信，可申请加入3D视觉工坊-学术论文写作与投稿 微信交流群，旨在交流顶会、顶刊、SCI、EI等写作与投稿事宜。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2783f5fc1cf07a9a3ab8cb33f178bef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d4b2e6bc8e9a8201e5cc43e401bdbe/" rel="bookmark">
			蓝桥杯嵌入式第三届省赛——“里程仪”旧板标准库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、赛题分析 “里程仪”具有即时速度、平均速度、行车时间、行驶里程显示及超速报警等功能。所用模块：LCD，LED，KEY，EEPROM，PWM输出，输入捕获。从这开始，博主会对每个用到的模块进行讲解。
二、程序设计 1、LED初始化 初始化结构体，使能时钟，配置引脚初始化参数，LED初始化引脚，锁存器配置，锁存器初始化引脚，LED初始化灭。
#ifndef __LED_H #define __LED_H #include "stm32f10x.h" #include "delay.h" #define LED1 GPIO_Pin_8 #define LED2 GPIO_Pin_9 #define LED3 GPIO_Pin_10 #define LED4 GPIO_Pin_11 #define LED5 GPIO_Pin_12 #define LED6 GPIO_Pin_13 #define LED7 GPIO_Pin_14 #define LED8 GPIO_Pin_15 #define LEDALL	GPIO_Pin_All //led void LED_Init(void); void LED_Control(u16 LEDx, u8 state); #endif #include "led.h" void LED_Init(void) { GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStruct.GPIO_Pin = 0xff00; GPIO_InitStruct.GPIO_Speed =	GPIO_Speed_50MHz; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOC, &amp;GPIO_InitStruct); GPIO_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d4b2e6bc8e9a8201e5cc43e401bdbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eeaf3704a52a7268e0b07181e2bc41f/" rel="bookmark">
			Pointnet以及Pointnet&#43;&#43;论文笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tips：写这篇Blog主要目的是在写的过程中加深对网络的理解，可能很多地方个人理解有偏差或者表述不明白。然后建议大家看了原论文再来看这个blog，这个Blog不是论文的翻译。有问题请留言或者qq交流：1981425845。大家一起讨论，共同进步。有做3D视觉的可以一起来讨论呀。
目录 论文及代码链接Pointnet部分论文研究背景Pointnet的主要工作网络结构分析Pointnet网络总结 Pointnet++部分论文研究背景Pointnet++的主要工作网络结构分析Pointnet++网络总结 论文及代码链接 Poinenet
论文链接：论文链接代码链接
官方代码（TF1.0.1）
大佬复现版本（Pytorch1.0） Pointnet++
论文链接：论文链接代码链接：
官方代码（TF1.2）
大佬复现版本（Pytorch1.3，里头也有Poinenet的实现） Pointnet部分 论文研究背景 点云是3D物体的最自然的表现形式，具有最全面的物体的几何特征，然而点云具有无序性(irregular)。如果我们设可以直接处理点云的网络为 f f f，那么， f f f应该满足式子(1)，也就是我们无论以什么顺序输入点云，输出应该是一样的。这就导致了以往的用于2D图片的网络结构无法直接用于处理点云数据，因为现有的2D处理网络要求输入数据是有序的，我们可以试想一下，如果我们把一个图片中的像素数据随机打乱之后再扔到网络中去处理，得到的结果肯定是不同的
f ( x 1 , x 2 , x 3 , . . . ) = f ( x n , x n − 1 , x n − 2 , . . . ) = . . . ( 1 ) f(x_{1},x_{2},x_{3},...)=f(x_{n},x_{n-1},x_{n-2},...)=... (1) f(x1​,x2​,x3​,...)=f(xn​,xn−1​,xn−2​,...)=...(1)现有的3D物体的检测与分割方法存在各种各样的问题，主要表现有：voxel-based方法 采用体素化的方法，将3D空间化为一个一个的网格，根据该网格中是否具有点云数据来决定网格的值，我们可以把体素理解成3D像素。voxel-based方法的思想是通过牺牲分辨率来换取数据的有序性，从而采用3DCNN来进行数据处理。然而，由于点云数据往往具有稀疏性，这会导致如果体素化的分辨率过低，也就是每个体素网格比较大，会造成比较大的信息损失，而当体素化的分辨率过高，又会造成较大的内存开销与计算量增加。（内存开销与计算量增加与分辨率成立方关系）。multiview方法 ：将3D点云从不同方向投影为2D图片，采用2D中的CNN进行处理，这已经破坏了3D数据的几何机构，对于分类任务或许可以，但是对于分割任务无能为力，这部分所需要的特征已经在投影过程中丢失。 Pointnet的主要工作 Pointnet的目标是设计出一个网络，该网络可以不考虑输入的顺序，也就是不同的输入顺序情况下，网络的输出是一样的，这样就可以直接对点云数据进行处理了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eeaf3704a52a7268e0b07181e2bc41f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce899364ca8845afe1b98e4b1be6e9d0/" rel="bookmark">
			模板注入（tornado_render）之[护网杯 2018]easy_tornado1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据提供的三个文件可以知道，flag在fllllllllag目录下；根据题目tornado 还有提示render知道，这大概念是考模板注入{{}} ；然后观看URL发现，可以猜测：
这道题需要构造/file?filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(filename))
当然在此之前用{{}}来注入会发现每次都会跳到error？msg
在这里构造{{1}}就会返回一个值；大可判定就是模板注入；关于render渲染函数知识
所以就是把cookie_secret找到，与/fllllllllllllag的md5加密连起来再md5加密是我们需要下一步做的事情；看了好多大佬的wp,说百度tornado的官方文档会发现cookie 在handler.settings中；这里主要参考wpBUUCTF [护网杯 2018]easy_tornado 1_wow小华的博客-CSDN博客
找cookie_secret小白属实有点难度；
然后构造{{handler.settings}}
就可以发现cookie；cookie值会一直变；
复制下来，和/fllllllllllllag的md5值连起来再用md5加密；可以使用在线md5加密工具； /fllllllllllllag的md5加密为3bf9f6cf685a6dd8defadabfb41a03a1
则md5加密：be56489f-17ee-4533-950b-0d74e4be4ecc3bf9f6cf685a6dd8defadabfb41a03a1
结果为：d305cf647ad41991edefbec04f38263d
则构造payload：
file?filename=/fllllllllllllag&amp;filehash=d305cf647ad41991edefbec04f38263d
此题主要还是要知道模板注入；{{}}
难点是cookie的查找；属实不会；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a647faab6ebfebf1aa8cbbd7db0e457/" rel="bookmark">
			bootstrapv5轮播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div id="carouselExampleIndicators" class="carousel slide" data-bs-ride="carousel"&gt; &lt;div class="carousel-indicators"&gt; &lt;button type="button" data-bs-target="#carouselExampleIndicators" data-bs-slide-to="0" class="active" aria-current="true" aria-label="Slide 1"&gt;&lt;/button&gt; &lt;button type="button" data-bs-target="#carouselExampleIndicators" data-bs-slide-to="1" aria-label="Slide 2"&gt;&lt;/button&gt; &lt;button type="button" data-bs-target="#carouselExampleIndicators" data-bs-slide-to="2" aria-label="Slide 3"&gt;&lt;/button&gt; &lt;button type="button" data-bs-target="#carouselExampleIndicators" data-bs-slide-to="3" aria-label="Slide 4"&gt;&lt;/button&gt; &lt;button type="button" data-bs-target="#carouselExampleIndicators" data-bs-slide-to="4" aria-label="Slide 5"&gt;&lt;/button&gt; &lt;/div&gt; &lt;div class="carousel-inner"&gt; &lt;div class="carousel-item active"&gt; &lt;img src="./img/img1.jpg" class="d-block w-100" alt="..."&gt; &lt;/div&gt; &lt;div class="carousel-item"&gt; &lt;img src="./img/img2.jpg" class="d-block w-100" alt="..."&gt; &lt;/div&gt; &lt;div class="carousel-item"&gt; &lt;img src="./img/img3.jpg" class="d-block w-100" alt="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a647faab6ebfebf1aa8cbbd7db0e457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ea661ae4141a3906a44c416d389fbd/" rel="bookmark">
			CSS属性复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：基础选择器
①标签选择器/元素选择器
标签名 {
}
②类选择器
标签内加上class="类名"
类名最好不要使用纯数字、中文等命名，尽量使用中文字母来表示
.类名 {
}
也可以使用多类名
class="类名1 类名2 类名3"
③id选择器
标签内加上id="id名"（常与JS搭配使用）
#id名 {
}
类选择器与id选择器的区别：
同一个类可以被多次调用，但同一个id只能调用一次
④通配符选择器
选取页面中的所有元素标签
* {
}
2：复合选择器
⑤后代选择器（包含选择器）
父级元素 子级元素/孙子级元素 {
}
⑥子选择器
只能选择最近一级子元素
父级元素&gt;子级元素 {
}
⑦并集选择器
可以选择多组标签，同时为他们定义相同样式，通常用于集体声明，
元素1，元素2 {
}
⑧链接伪类选择器
a:link /选择所有未被访问过的链接/
a:visited /选择所有已被访问过的链接/
a:hover /选择鼠标指针位于其上的链接/
a:active /选择活动链接(鼠标按下未弹起的链接)/
如果写多种，要按照上述顺序来写，否则不会生效
⑨focus伪类选择器
input:focus {
}
3：字体属性(font)
①:font-family
定义文本的字体系列
font-family:'微软雅黑'/'Microsoft YaHei'/Arial;
②font-size
定义字体大小
font-size:20px;
标题标签比较特殊，需要单独指定文字大小
③font-weight
定义文本文字的粗细
font-weight:normal(正常)/bold(粗体)/bolder;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ea661ae4141a3906a44c416d389fbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54096716378d92d38b3e4cc85d795cbf/" rel="bookmark">
			ubuntu18.04深度学习环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. ubuntu18.04安装2. nvidia显卡驱动3. 安装anaconda34. 安装pytorch（含cuda、cudnn） 前言 为跑代码方便，实验室电脑一般都用ubuntu系统，但无奈买来的电脑都是预装windows，所以需要重装系统，然后再配置一系列的环境。走一遍流程总要有些坑，下次再重复安装总是隐约记得但又会再踩坑，为了之后提高效率，这次把整个流程记录下来，以后用着也方便。
1. ubuntu18.04安装 现在ubuntu已经出到了21版本，一般安装LTS（长期支持）版本就没啥问题，但为了兼容一些老环境、老配置，这里选18版本的稳妥一些。
镜像在官网下载：https://ubuntu.com/#download
我用的是18.04.6桌面版，可以在这里下载：
链接：https://pan.baidu.com/s/1p4kAtoaZSzxJa2VqtjuFmg
提取码：vwj5
下载之后，要制作启动盘，用u盘或光盘都可，这里用u盘制作
制作工具用 UltraISO软碟通，下载之后，准备好一个空u盘（制作启动盘需要格式化u盘），8g的就够，然后按照这个来就行
https://jingyan.baidu.com/article/154b46311befea28ca8f41ae.html
之后就是关机，插上u盘，开机进入bios，选择u盘启动那一项，按照引导安装就行。（因为是重装系统，直接覆盖原系统，所以分区、存储那些配置都按照默认的来就行，记得选择覆盖原系统就行）
2. nvidia显卡驱动 深度学习网络都离不开显卡，安装显卡驱动算是最重要的一步。
首先，有个准备工作，禁用BIOS中的secure boot（需要重启一下进BIOS）。
进入系统后，禁用默认使用的开源显卡驱动nouveau：
创建文件 sudo vim /etc/modprobe.d/blacklist-nouveau.conf写入
blacklist nouveau options nouveau modeset=0使禁用生效 sudo update-initramfs -u检验是否生效（没有输出就是生效了） lsmod | grep nouveau 想使用nvidia的独立显卡，就需要安装对应的显卡驱动，所以要知道自己显卡的信息，确定驱动版本。
终端输入：ubuntu-drivers devices
可以看到推荐安装的是 nvidia-driver-470，直接安装就可。
sudo apt update
sudo apt install nvidia-driver-470
安装后重启一下，终端输入：nvidia-smi
如图安装成功。
其实也可以去nvidia官网下载对应版本的驱动，除去官网的版本可能更新一点之外，其实都差不多，上边的方法更简单。
具体过程参考：
https://zhuanlan.zhihu.com/p/59618999
https://blog.csdn.net/new_delete_/article/details/81544438
！！踩坑！！：之前安装显卡驱动后，再重启会显示驱动的版本和系统不一致，这是由于linux内核自动更新导致的，所以为了方便起见，避免之后出现问题，在显卡驱动安装后，先设置禁止系统内核更新，之后再重启查看显卡驱动。
查看一下在使用的内核版本 uname -a
然后 sudo apt-mark hold linux-image-5.4.0-84-generic
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54096716378d92d38b3e4cc85d795cbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaae58dbf0439a5e025be6358bfc9fab/" rel="bookmark">
			BUUCTF--web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
[极客大挑战 2019]EasySQL
[极客大挑战 2019]Havefun
[极客大挑战 2019]Secret File
[极客大挑战 2019]LoveSQL
[极客大挑战 2019]EasySQL 打开题目发现需要输入用户名和密码，因为刚刚看了万能密码，所以可以尝试使用万能密码绕过，得出flag。
[极客大挑战 2019]Havefun 点击网页进去以后发现是一只小猫，没有任何线索，所以就可以考虑查看源代码，发现一段php语句，是一个简单的get传值。
意思就是cat=dog的时候输出后面的字符串，所以在url后面加上?cat=dog，然后得出flag。
[极客大挑战 2019]Secret File 打开题目以后没有任何线索，所以还是查看源代码，发现一个链接，打开它。
中间有个按钮，点击过后，发现来到了另一个页面
根据文本提示可以尝试burp进行抓包处理，将抓到的右键送到repeater，然后send一下，发现了一条线索。 加上后缀进行访问
看到这里我以为flag要出来了，结果还是没有，加上后缀访问。
这时便想到了文件包含漏洞，看代码是对file进行了一定过滤，但并没有过滤filter用php://fileter伪协议来获取文件?file=php://filter/convert.base64-encode/resource=flag.php php://filter
可以获取指定文件的源码，但是当他与包含函数结合是，php://filter流会被当做php文件执行
。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取 。利用filter协议读文件±，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。而使用的convert.base64-encode，就是一种过滤器。
常用：
php://filter/read=convert.base64-encode/resource=index.php php://filter/resource=index.php 然后base64解密得出flag。
这道题最后要对php伪协议有了解，所以我还是需要对这方面进行学习。
[极客大挑战 2019]LoveSQL 这一题是第一题的延续，还是先用万能密码进行测试，结果出了这个页面
老老实实的进行SQL注入，首先就是查看有多少列，order by
username=admin&amp;password=873d83e01fbdd109654b2ee2c7a06416' order by 3 %23 username=admin&amp;password=873d83e01fbdd109654b2ee2c7a06416' order by 4 %23 到第四列是报错，说明有三列。
然后查询注入点
username=admin&amp;password=-873d83e01fbdd109654b2ee2c7a06416' union select 1,2,3 %23 得到回显点位为2和3，查询当前数据库名：
username=admin&amp;password=-873d83e01fbdd109654b2ee2c7a06416'union select 1,2,database() %23 爆表 username=admin&amp;password=-873d83e01fbdd109654b2ee2c7a06416' union select 1,2,group_concat(table_name) from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaae58dbf0439a5e025be6358bfc9fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6906ea74e67298c385fdefe08e76723e/" rel="bookmark">
			SQL注入点判断及万能密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SQL注入漏洞的类型
1.数字型判断
2.字符型判断 SQL注入--万能密码
SQL注入漏洞的类型 1.单引号判断
http://www.xxx.com/xxx.asp?id=10' 如果出现错误提示，则该网站可能就存在注入漏洞。
2.and判断
http://www.xxx.com/xxx.asp?id=10'and 1=1这个条件永远都是真的，所以当然返回是正常页
http://www.xxx.com/xxx.asp?id=10'and 1=2如果报错那说明存在注入漏洞，还要看报的什么错，不可能报任何错都有注入漏洞的。
3.Or判断(or跟and判断方法不一样的，and是提交返回错误才有注入点，而OR是提交返回正确有注入点)
http://www.xxx.com/xxx.asp?id=10'or 1=1
http://www.xxx.com/xxx.asp?id=10'or 1=2
4.xor判断(xor后面的语句如果是正确的，则返回错误页面，如果是错误，则返回正确页面，说明存在注入点。)
http://www.xxx.com/xxx.asp?id=10'xor 1=1
http://www.xxx.com/xxx.asp?id=10'xor 1=2
5.加减号数字判断(返回的页面和前面的页面相同，加上-1，返回错误页面，则也表示存在注入漏洞.)
http://www.xxx.com/xxx.asp?id=10-0
http://www.xxx.com/xxx.asp?id=10-1
http://www.xxx.com/xxx.asp?id=10+1
and,or,xor等判断可以参考这三种逻辑运算的规律进行理解
sql注入漏洞通常为2种
数字型字符型 1.数字型判断 当输入的参 x 为整型时，通常 abc.php 中 Sql 语句类型大致如下：select * from &lt;表名&gt; where id = x这种类型可以使用经典的 and 1=1 和 and 1=2 来判断：
Url 地址中输入 http://xxx/abc.php?id= x and 1=1 页面依旧运行正常，继续进行下一步。Url 地址中继续输入 http://xxx/abc.php?id= x and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。 我们输入的是 x and 1=1 和x and 1=2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6906ea74e67298c385fdefe08e76723e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58fa95bfe29951567bcf1722ef171912/" rel="bookmark">
			柔性数组：char data[0]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有如下定义： typedef struct{ char a; char b[0]; }; 其中元素Char b[0];叫做柔性数组，主要用于使结构体包含可变长字段。详细内容如下： 柔性数组; 【柔性数组结构成员 C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。】 C语言大全，“柔性数组成员” 看看 C99 标准中 灵活数组成员： 结构体变长的妙用——0个元素的数组 有时我们需要产生一个结构体，实现了一种可变长度的结构。如何来实现呢？ 看这个结构体的定义： typedef struct st_type { int nCnt; int item[0]; }type_a; （有些编译器会报错无法编译可以改成：） typedef struct st_type { int nCnt; int item[]; }type_a; 这样我们就可以定义一个可变长的结构，用sizeof(type_a)得到的只有4，就是sizeof(nCnt)=sizeof(int)那个0个元素的数组没有占用空间，而后我们可以进行变长操作了。 C语言版： type_a *p = (type_a*)malloc(sizeof(type_a) + 100*sizeof(int)); C++ 语言版: type_a *p = (type_a*)new char[sizeof(type_a) + 100*sizeof(int)]; 这样我们就产生了一个长为100的type_a类型的东西用p-&gt;item[n]就能简单地访问可变长元素，原理十分简单 ，分配了比sizeof(type_a)多的内存后int item[];就有了其意义了，它指向的是int nCnt;后面的内容，是没有内存需要的，而在分配时多分配的内存就可以由其来操控，是个十分好用的技巧。 而释放同样简单： C语言版： free(p); C++ 语言版： delete []p; 其实这个叫灵活数组成员(fleible array member)C89不支持这种东西，C99把它作为一种特例加入了标准。但是，C99所支持的是incomplete type，而不是zero array，形同int item[0];这种形式是非法的，C99支持的形式是形同int item[];只不过有些编译器把int item[0];作为非标准扩展来支持，而且在C99发布之前已经有了这种非标准扩展了，C99发布之后，有些编译器把两者合而为一。 下面看看这样做的用处 Typedef struct{ Char a[1]; Char b[]; }AA; AA *pf； pf = malloc(sizeof(AA) + 5*sizeof(char));/*只分配一块内存*/ 如果这样定义 Typedef struct{ Char a[1]; Char *b; }AA; AA *pf； pf = malloc(sizeof(AA）); pf-&gt;b = malloc(5*sizeof(char));/*看出来了么，这样需要分配两块内存，在释放时也要先释放b的内存，再释放pf的内存*/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3ab3897918ad1c49cc286cd0662f58/" rel="bookmark">
			App Designer使用UIAxes显示图片并隐藏坐标轴和标题等信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在设计GUI时，显示图片通常使用坐标轴控件（UIAxes），但是当用坐标轴空间来显示图片时，我们不希望显示X轴Y轴标题等坐标轴信息。
如上图所示，显示X和Y和Title会显得比较难看。
因此需要进行隐藏，具体代码如下：
I = imread(img_file_name); %读取图片 imshow(I,'parent',app.UIAxes); % 显示图片到坐标轴 axis(app.UIAxes,'off'); %不显示坐标轴 title(app.UIAxes,''); % 不显示标题 xlabel(app.UIAxes,'') % 不显示X轴标签 ylabel(app.UIAxes,'') % 不显示Y轴标签 如果想在启动GUI时就隐藏X轴标签、Y轴标签和标题等，可以将上述隐藏代码即该部分：
axis(app.UIAxes,'off'); %不显示坐标轴 title(app.UIAxes,''); % 不显示标题 xlabel(app.UIAxes,'') % 不显示X轴标签 ylabel(app.UIAxes,'') % 不显示Y轴标签 写入启动回调函数 startupFcn：
在该位置写入即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c7197e050d97966563572137978442/" rel="bookmark">
			tkinter库绘图实例15：制作滚动字幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例代码
import tkinter as tk # 导入tkinter库，并重命名为tk mywindow = tk.Tk() # 创建一个窗体 mywindow.title("滚动字幕效果") # 设置窗体的标题 # 创建画布并布局 mycanvas = tk.Canvas(mywindow,width=500,height=100,bg="black") mycanvas.pack() x = 0 width = 500 dx = 5 mycanvas.create_text(x,50,text="你好，Python！你好，世界！",tag="mytext",font="Arial 16 bold",fill="white") while True: mycanvas.after(100) mycanvas.move("mytext",dx,0) mycanvas.update() if x &lt; width : x =x +dx else : x = 0 mycanvas.delete("mytext") mycanvas.create_text(x,50,text="你好，Python！你好，世界！",tag="mytext",font="Arial 16 bold",fill="white") 运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/244c77d0f1d5ba2f28f359a091f7e0aa/" rel="bookmark">
			蓝桥2022c&#43;&#43;B组 F 统计子矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最暴力的做法： #include&lt;iostream&gt; using namespace std; int a[505][505]={0}; long long q[505][505]={0}; int main() { int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int i,j,b,c,ans=0; for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=m;j++){ cin&gt;&gt;a[i][j]; q[i][j]=q[i][j-1]+q[i-1][j]-q[i-1][j-1]+a[i][j];//构建前缀和数组 } } for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=m;j++)//左上角 { for(b=i;b&lt;=n;b++) { for(c=j;c&lt;=m;c++)//右下角 { if(q[b][c]-q[i-1][c]-q[b][j-1]+q[i-1][j-1]&lt;=k) ans++; } } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 看了大佬之后的做法：
#include&lt;iostream&gt; using namespace std; int a[505][505]={0}; long long q[505][505]={0}; int main() { int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int i,j,b,c,ans=0; for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=m;j++){ cin&gt;&gt;a[i][j]; q[i][j]=q[i][j-1]+q[i-1][j]-q[i-1][j-1]+a[i][j];//构建前缀和数组 } } for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=m;j++)//左上角 { for(b=i;b&lt;=n;b++) { c=m; while(q[b][c]-q[i-1][c]-q[b][j-1]+q[i-1][j-1]&gt;k) c--; if(c&lt;j) break; ans+=c-j+1; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 大佬2022年蓝桥杯软件类省赛 C/C++ B组 解析 - StelaYuri - 博客园 (cnblogs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/244c77d0f1d5ba2f28f359a091f7e0aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d02aa8fec84d27cc02ed1c165a01513/" rel="bookmark">
			Profile配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Spring Boot 中约定的不同环境下配置文件名称规则为：application-{profile}.properties，profile占位符表示当前环境的名称。
properties文件配置：
application-dev.properties 开发环境配置
application-prod.properties 生产环境配置
然后在application.properties中进行配置：
spring.profiles.active=dev yml文件配置：
application-dev.yml 开发环境配置
application-prod.yml 生产环境配置
然后在application.yml中进行配置：
spring: profiles: active: dev #激活应用 application-dev.yml 配置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b7d3584c5d74dae9636c39a18b0b980/" rel="bookmark">
			2022 IDEA 不编译整个工程 只编译单个Java文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：工程里面其他有好多编译报错，但是我只想当前文件编译运行不受影响。
1. 编译单个的Java文件 2. 更改运行配置 ![
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daffbe7329e3317d859d2ff79c9904d1/" rel="bookmark">
			iframe嵌入页面之Cookies存取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：最近工作上遇到个两个不同产品间嵌入的问题。A产品（www.aaa.com）需要使用B产品（www.bbb.coom）的某个功能。于是在A产品中通过iframe嵌入B产品的页面。
一、X-Frame-Options
通过iframe嵌入页面后，首先碰到的问题是如下报错，原因是B产品因为安全性的考虑设置了X-Frame-Options，禁止其他页面通过iframe引入。
解决办法就是设置B产品允许被A产品引用。X-Frame-Options响应头的属性有如下三种：
1、DENY：不能被嵌入到任何iframe。
2、SAMEORIGIN：页面只能被本站页面嵌入。
3、ALLOW-FROM uri：只能被嵌入到指定域名的框架中。
二、单点登录（Single Sign On）
可以正常请求到B产品的页面后，由于没有登录会自动跳到B产品的登陆页面去，需要登陆B产品才能继续使用（这里也是可能无法登陆的），这对于A产品用户肯定是不能接受的，于是我们需要配置上单点登录。单点登录的概念和如何配置就不展开说明了，这里大概说下在当前场景下的登录流程。
1、用户访问产品A并成功登录，访问包含引用B产品的页面。
2、B产品没有登录，前端会跳转B的登陆校验地址，由于已经配置了单点登录，后端会重定向到A产品的登录页面。
3、由于A产品已经登录，A产品会根据传递的重定向地址重定向到B产品的sso校验地址，信息无误会重定向到B的校验地址。
4、B产品后端校验无误，重定向回B产品页面，登陆成功。
三、Cookie的SameSite
本次页面嵌入遇到的最大的问题是整个登陆过程中，因为Cookie的配置无法正常获取并传给后端，导致登陆无法成功，这就是上面说的可能无法登陆的原因。这个一般前后端都需要进行设置。具体是在设置Cookie时，设置SameSite属性。有如下三种：
1、Strict：严格模式，禁止第三方Cookie。跨站点时，不会携带任何Cookie。
2、Lax：正常模式，链接（a标签）、预加载（link）、GET表单（form）等情况下跨站点会携带Cookie。其它大部分跨站点的情况下也是不会携带Cookie。
3、None：不限制，任何情况都会携带Cookie。不过同时需要Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。
我是使用的universal-cookie库来设置的Cookie，可以通过设置options属性来控制Cookie的属性。
import Cookies from 'universal-cookie'; const cookies = new Cookies(); const options = { secure: true, sameSite: 'none', }; cookies.set('access_token', 'c212e015-d66e-460f-97ab-55fab8e19bed', options); 至此，页面的嵌入在框架层面上就已经正常了，可以正常进行功能开发测试了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37390f8cbc6aa3a5af85aafad49ab99f/" rel="bookmark">
			信号量（Semaphore）与线程计数器（CountDownLatch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🍉信号量（Semaphore）
🥭线程计数器（CountDownLatch）
🍉信号量（Semaphore） Semaphore属于共享锁，即多个线程可以同时获取，用来表示可用资源的个数，本质上是一个计数器
🥩理解信号量：
🍂我们将信号量理解为一个停车场的空车位，例如当前有100个空车位，表示100个可用资源
🍂当有车开进停车场，就相当于申请一个可用资源，空车位就-1（这个称为信号量的P操作）
🍂当有车开出停车场，就相当于释放一个可用资源，空车位就+1（这个称为信号量的V操作）
🍂如果可用资源为0，会尝试申请资源，就会阻塞等待，直到有其他线程释放资源
🥩注意：Semaphore的PV操作的加减计数器操作都是原子性的，可以直接在多线程环境下使用
🍡Semaphore的构造方法：
🍭Semaphore的常用方法：
🍢使用场景：
☘️等待一组线程执行完，再执行某个任务
☘️同一个时间最多执行n个线程（有限资源的使用）
🍴示例：
创建Semaphore实例，初始化为4，表示4个可用资源
acquire方法表示申请资源（P操作），release方法表示释放资源（V操作）
创建20个线程，每个线程都尝试申请资源，sleep等待1秒后，释放资源，观察程序执行结果
👁‍🗨️代码展示：
import java.util.concurrent.Semaphore; public class SemaphoreTest { public static void main(String[] args) { Semaphore sem = new Semaphore(4); Runnable runnable = new Runnable() { @Override public void run() { try { System.out.println("申请资源"); sem.acquire(); System.out.println("获取到资源"); Thread.sleep(1000); sem.release(); System.out.println("释放资源"); } catch (InterruptedException e) { e.printStackTrace(); } } }; for(int i = 0;i &lt; 20;i++){ Thread t = new Thread(runnable); t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37390f8cbc6aa3a5af85aafad49ab99f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536d68075bdbce3e008745acd38c83d4/" rel="bookmark">
			uniapp小程序父组件与子组件之间调用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详情
报错：VM6271 WAService.js:2 TypeError: Cannot read property ‘isSellerView’ of undefined at VueComponent.checkCur
解决：父组件调用子组件方法，如果子组件是在v-if中的则会报错，改用v-show
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d12047b17a10625fe3f8e4adb36752f/" rel="bookmark">
			禅道二次开发（一）：开发环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		禅道是一个开源的项目管理软件，作为测试人员最常用的功能就是用例管理和bug管理。目前的禅道开源版可能无法满足业务需求，可以基于禅道进行二次开发。先来介绍下如何配置禅道开发环境。
目录 前言禅道环境部署禅道安装禅道升级 连接数据库配置linux和windows文件共享Vscode 配置PHP开发环境参考资料 前言 禅道项目管理软件主要使用PHP语言，是基于zentaoPHP框架进行开发的。要对禅道进行二次开发需要对PHP语言、zentaoPHP框架、前端ZUI框架、MySQL数据库、HTML、JavaScript等有一定的了解。后续我会陆续发布一些禅道二次开发的相关笔记，文章不会对这些基础进行过多介绍，关于禅道二次开发的相关资料可滑到文章末尾查看，都是禅道官方提供的资料，介绍的比较详细。
下面介绍我是如何配置禅道开发环境的。
禅道环境部署 在Windows中部署PHP环境可以使用XAMPP，它是一个Apache发行版，其中包含了MariaDB、PHP和Perl。下载地址：
https://www.apachefriends.org/index.htmlhttps://www.apachefriends.org/zh_cn/download.html 由于我们的禅道部署在Linux系统上，我选择在Linux上部署环境。Linux也可以使用XAMPP部署，我觉得太麻烦就没有使用它，而是直接在Linux上安装禅道，因为禅道安装包内置了apache、php、mysql这些应用程序，不需要再单独安装部署。直接在禅道目录中进行二次开发就可以了。
禅道安装 在linux中使用禅道一键安装包安装禅道，下载地址：https://www.zentao.net/download.html ，我下载的是禅道16.4版本。
1、将禅道一键安装包解压到/opt目录下
$ sudo tar -zxvf ZenTaoPMS.16.4.zbox_64.tar.gz -C /opt 解压完成后可以查看PHP的版本：
$ /opt/zbox/bin/php -v PHP 7.2.33 (cli) (built: Jul 14 2021 12:01:31) ( ZTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with the ionCube PHP Loader + ionCube24 v10.4.4, Copyright (c) 2002-2020, by ionCube Ltd. with Zend OPcache v7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d12047b17a10625fe3f8e4adb36752f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44e890d9d09585335f46fb1075bcb42/" rel="bookmark">
			Map补充：map遍历方法和computeIfAbsent()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Map 的遍历二、map.computeIfAbsent()方法 一、Map 的遍历 （1）使用 Iterator 输出 Map 实例
public class Test{ public static void main(String[] args) { Map&lt;String,String &gt; map = new HashMap&lt;String, String&gt;();//实例化 map map.put("2","Java"); map.put("1","Python"); map.put("3","Html"); Set&lt;Map.Entry&lt;String ,String &gt;&gt; allSet = null;//声明一个 Set 集合，指定泛型 allSet = map.entrySet();//将 Map 接口实例变为 Set 接口实例 Iterator&lt;Map.Entry&lt;String ,String &gt;&gt; iter = null;//声明 Iterator 对象 iter = allSet.iterator();//实例化 Iterator 对象 while (iter.hasNext()){ Map.Entry&lt;String ,String &gt; me = iter.next();//找到 Map.Entry 实例 System.out.println(me.getKey() + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44e890d9d09585335f46fb1075bcb42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22c6d3f969a87312059748b2f0ad379/" rel="bookmark">
			vscode配置go开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者在网上找了很多关于VSCODE配置Go语言的教程，但是由于版本等种种问题，最终都已失败告终。无奈只能在官方文档上寻求帮助，现在终于可以了！！话不多说，咱们开始吧！！
下载安装包
网上有的教程采用的是数据包安装.msi，有的是采用的是解压包。这二者最终效果都是一样的，但是为了防止不必要的意外，你们还是和我保持一致吧。
官网下载地址：
Downloads - The Go Programming Language (google.cn)
安装：
建议大家不要安装在默认路径下；在这里笔者是安装在D:/soft/go
更改安装位置 剩余的一路next
最终的安装效果：
设置环境变量
这一步就是将go安装目录下面的bin放进path，我在安装的时候发现已经有了（所以你们需要检查一下，没有就设置一下）PS:点击新建）
验证结果：
配置Go环境
打开命令行输入：
go env 查看自己的一些配置，如图所示
我们需要将GO111MODULE功能打开
然后配置代理 set GOPROXY=https://goproxy.cn
我们可以依次输入：
set GO111MODULE=on set GOPROXY=https://goproxy.cn 这样，配置就完成了
这里简单介绍一下：
GOPATH: Go项目的位置，网上很多教程需要在这里做文章，其实笔者之前也是在这里遇到了很多坑。
​ 之前低版本的时候需要依赖gopath来管理项目，但是现在我们用GO MOD来管理项目，所以可以不用管他
GOROOT: 这个就是我们的go的安装路径
VSCode的调试
网上关于VSCode的安装有很多，这里我就不再赘述了，在VSCODE里面打开一个文件夹
新建main.go文件，当我们创建完后缀名之后，Vscode会提示我们安装Go的拓展，我们接受并且安装。
创建第一个Go程序：
package main import "fmt" func main() { fmt.Println("hello go") } 安装Go的依赖包：
此时vscode会提示需要依赖包：我们直接选择 Install All
—PS: 网上很多教程需要自己去在Github官网上去下载，这种做法有些麻烦。
–得益于我们之前配置的set GOPROXY=https://goproxy.cn代理，我们这里可以直接下载，如果这里下载下载失败了，那大概率是代理没有配置好的问题，回去检查一下吧！
当出现下图时，依赖包安装成功!!
运行第一个Go程序：
新建一个终端：
输入：
go run main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22c6d3f969a87312059748b2f0ad379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff5e5627a81de8cf019dd7dac649f48/" rel="bookmark">
			卷积神经网络参数尺寸计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 CNN卷积神经网络理解参数尺寸计算理解 CNN卷积神经网络理解参数尺寸计算理解 图片尺寸大小经过卷积后计算
卷积尺寸计算：尺寸变为（（原始尺寸+2*填充-核尺寸）/步长）+1
Conv2d参数如下：
conv2d 参数(输入通道，输出通道，核尺寸，步长，填充等) in_channels: int, out_channels: int, kernel_size: _size_2_t, stride: _size_2_t = 1, padding: Union[str, _size_2_t] = 0, dilation: _size_2_t = 1, groups: int = 1, bias: bool = True, padding_mode: str = 'zeros', # TODO: refine this type device=None, dtype=None 卷积尺寸计算：经过Conv2d卷积后，尺寸变为（（原始尺寸+2填充-核尺寸）/步长）+1
举个例子，卷积自编码为例，原始数据为1通道，2828的图片
class AutoEncoder(nn.Module): def __init__(self): super(AutoEncoder, self).__init__() self.en_conv = nn.Sequential( nn.Conv2d(1, 16, 4, 2, 1), 原始图像 1通道 尺寸 28*28，核尺寸4*4，步长为2，填充1 nn.BatchNorm2d(16), 经过一次卷积 16通道 14*14 按上面公式计算的 (28+2-4)/2 +1 =14 nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ff5e5627a81de8cf019dd7dac649f48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7d3902f2952799ae25272530e05fee/" rel="bookmark">
			一台服务器上安装多台Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、确认系统中是否安装了gcc、pcre-devel、zlib-devel、openssl-devel
rpm -qa|grep gcc rpm -qa|grep pcre-devel rpm -qa|grep zlib-devel rpm -qa|grep openssl-devel 如果没有安装则进行第二步，否则进入第三步
2、使用yum安装gcc、pcre-devel、zlib-devel、openssl-devel
yum install -y gcc、pcre-devel、zlib-devel、openssl-devel 3、解压
tar zxvf nginx-1.11.6.tar.gz 4、进入解压的目录
cd nginx-1.11.6 5、编译
./configure \ --prefix=/usr/local/nginx2 \ --sbin-path=/usr/local/nginx2/sbin/nginx2 \ --conf-path=/usr/local/nginx2/conf/nginx.conf \ --error-log-path=/usr/local/nginx2/logs/error.log \ --http-log-path=/usr/local/nginx2/logs/access.log \ --pid-path=/usr/local/nginx2/logs/nginx2.pid \ --lock-path=/var/run/nginx2.lock \ --http-client-body-temp-path=/usr/local/nginx2/client_body_temp \ --http-proxy-temp-path=/usr/local/nginx2/proxy_temp \ --http-fastcgi-temp-path=/usr/local/nginx2/fastcgi_temp \ --http-uwsgi-temp-path=/usr/local/nginx2/uwsgi_temp \ --http-scgi-temp-path=/usr/local/nginx2/scgi_temp \ --user=nginx2 \ --group=nginx2 \ --with-pcre \ --with-http_v2_module \ --with-http_ssl_module \ --with-http_realip_module \ --with-http_addition_module \ --with-http_sub_module \ --with-http_dav_module \ --with-http_flv_module \ --with-http_mp4_module \ --with-http_gunzip_module \ --with-http_gzip_static_module \ --with-http_random_index_module \ --with-http_secure_link_module \ --with-http_stub_status_module \ --with-http_auth_request_module \ --with-mail \ --with-mail_ssl_module \ --with-file-aio \ --with-ipv6 \ --with-http_v2_module \ --with-threads \ --with-stream \ --with-stream_ssl_module 安装多个nginx则需要多次执行该步骤，但是每次执行的路径不一样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7d3902f2952799ae25272530e05fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a3af7513013964502fd6852294e74b/" rel="bookmark">
			PCL系列笔记——(滤波)Filter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 直通滤波(PassThrough filter)体素滤波（VoxelGrid filter）离群点滤波器（StatisticalOutlierRemoval filter） 直通滤波(PassThrough filter) 这个滤波很直接，就是按照我们的设置的要求直接进行滤波，例如我们可以通过直通滤波直接得到z分量在(0-500)的点云。
code
#include &lt;iostream&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/filters/passthrough.h&gt; int main() {	pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); // Fill in the cloud data cloud-&gt;width = 5; cloud-&gt;height = 1; cloud-&gt;points.resize(cloud-&gt;width * cloud-&gt;height); for (auto&amp; point : *cloud) { point.x = 1024 * rand() / (RAND_MAX + 1.0f); point.y = 1024 * rand() / (RAND_MAX + 1.0f); point.z = 1024 * rand() / (RAND_MAX + 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6a3af7513013964502fd6852294e74b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ba89a199e366437e85f2853f2ef59f/" rel="bookmark">
			JS获取今天的开始和结束，本周的开始和结束，本月的开始和结束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码（我自己没有测试过本周和本月的函数）：
var initDateTools = (function(){ // 获取今天的开始：00:00:00:00 function getTodayStartTime(){ return new Date(new Date().setHours(0, 0, 0, 0)); } // 获取今天的结束 function getTodayEndTime(){ return new Date(new Date().setHours(23, 59, 59, 0)); } // 获取本周的开始 function getWeekStartTime(){ var now = new Date(); // 获取今天是星期几 var weekDay = now.getDay() || 7; var date = now.getDate(); // 今天几号 // 为什么要额外减一呢？ /** * 假如今天是周一，则weekDay是1 * 今天恰好是这周的开始，所以应该减去0，而不是1 * 同理，今天是周二，则减去1，得到这周开始的那天； */ var startTime = new Date(new Date(now.setDate(date - weekDay - 1)).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ba89a199e366437e85f2853f2ef59f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/148/">«</a>
	<span class="pagination__item pagination__item--current">149/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/150/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>