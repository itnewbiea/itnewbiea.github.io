<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f61f8694b048b2407eadfd1bc38044/" rel="bookmark">
			Mpvue [ app.json 文件内容错误] dist/wx/app.json: dist/wx/app.json 未找到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mpvue [ app.json 文件内容错误] dist/wx/app.json: dist/wx/app.json 未找到
1,npm install 把包安装到当前目录下的node_modelus中
2,npm run dev 执行build/dev-server.js文件启动服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cda9cece6cc85c7dbee084256337c6c/" rel="bookmark">
			leetCode 回文数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
例如，121 是回文，而 123 不是。
方法一 数字转位字符串，然后转成数组，然后反转，然后在专为字符串
/** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { return x == String(x).split("").reverse().join("") }; 方法二 看题解，反转数字，但是可能会出现，正数溢出的情况，考虑只反转一半数字负数 和 个位数位0的数，是不可能是回文数，直接返回false每次循环拿到最后一个并且添加到加到新元素上，并且吧x的的最后一位删除如何拿到最后一位数字 1221 % 10如何删除最后一位数字 Math.floor(1221 / 10) 直接舍弃掉小数点之后的数字如何判断循环结束，当前原始数字小于 当前数字 ，就已经处理了一半的数字了返回值处理，比较原始数据和当前反转的数据，是否相等，有可能是基数长度的数字，处理之后的数字就比原始数字多一个，处理掉最后一位在进行比较 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { // return x == String(x).split("").reverse().join("") if(x&lt;0 || (x % 10 === 0 &amp;&amp; x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cda9cece6cc85c7dbee084256337c6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6166bfe9dbff8da1caf3b4fdbb41ce78/" rel="bookmark">
			opencv学习（6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像混合
目录
任务
图片相加
图像混合
按位操作
小结
平滑图像
滤波与模糊
任务 1.图片间的数学运算，如相加、按位运算等
2.OpenCV函数：cv2.add()，cv2.addWeighted()，cv2.bitwise_and()
图片相加 要叠加两张图片，可以用cv2.add()函数，相加两幅图片的形状（高度/宽度/通道数）必须相同numpy中可以直接用res = img + img1相加，但这两者的结果并不相同：
x = np.uint8([250]) y = np.uint8([10]) print(cv2.add(x, y)) # 250+10 = 260 =&gt; 255 print(x + y) # 250+10 = 260 % 256 = 4 如果是二值化图片（只有0和255两种值），两者结果是一样的（用numpy的方式更简便一些）
图像混合 cv2.addWeighted()也是一种图片相加的操作，只不过两幅图片的权重不一样，γ相当于一个修正值：
img1 = cv2.imread('lena_small.jpg') img2 = cv2.imread('opencv-logo-white.png') res = cv2.addWeighted(img1, 0.6, img2, 0.4, 0) 注：α和β都等于1时，就相当于图片相加 按位操作 按位操作包括按位与/或/非/异或操作，有什么用途呢？
比如说我们要实现下图的效果：
如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用按位操作
首先来了解掩膜（mask）概念：
掩膜是用一副二值化图片对另外一幅图片进行局部的遮挡，
下图一目了然：
所以思路就是把原图中要放logo的区域抠出来，再把logo放进去就行了：
img1 = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6166bfe9dbff8da1caf3b4fdbb41ce78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef03b84454f1234a64b7d39bbe67d2c3/" rel="bookmark">
			leetCode轮转数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
解题思路 1、k 可能大于数组长度，所以需要取余
2、最后需要改变nums数组，而不是直接返回
/** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */ var rotate = function(nums, k) { let len = nums.length; let newArr = new Array(len); for(let i=0;i&lt;len;i++){ newArr[(i+k)%len] = nums[i]; } for(let i=0;i&lt;len;i++){ nums[i] = newArr[i]; } }; 二、splice 取模获取真实需要反转个数截取需要反转的拼接后赋值 if(k &gt; nums.length){ k %= nums.length } Object.assign(nums,nums.splice(nums.length - k,nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef03b84454f1234a64b7d39bbe67d2c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a630f5ab3c9894f670ebac3796eabe/" rel="bookmark">
			VS2019 PCL12.0 Eigen::internal::aligned_free bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
随便跑了一段程序
PointCloud&lt;PointNormal&gt;::Ptr subsampleAndCalculateNormals(const PointCloud&lt;PointXYZ&gt;::Ptr&amp; cloud) { PointCloud&lt;PointXYZ&gt;::Ptr cloud_subsampled(new PointCloud&lt;PointXYZ&gt;()); VoxelGrid&lt;PointXYZ&gt; subsampling_filter; subsampling_filter.setInputCloud(cloud); subsampling_filter.setLeafSize(subsampling_leaf_size); subsampling_filter.filter(*cloud_subsampled); PointCloud&lt;Normal&gt;::Ptr cloud_subsampled_normals(new PointCloud&lt;Normal&gt;()); NormalEstimation&lt;PointXYZ, Normal&gt; normal_estimation_filter; normal_estimation_filter.setInputCloud(cloud_subsampled); search::KdTree&lt;PointXYZ&gt;::Ptr search_tree(new search::KdTree&lt;PointXYZ&gt;); normal_estimation_filter.setSearchMethod(search_tree); normal_estimation_filter.setRadiusSearch(normal_estimation_search_radius); normal_estimation_filter.compute(*cloud_subsampled_normals); PointCloud&lt;PointNormal&gt;::Ptr cloud_subsampled_with_normals( new PointCloud&lt;PointNormal&gt;()); concatenateFields( *cloud_subsampled, *cloud_subsampled_normals, *cloud_subsampled_with_normals); PCL_INFO("Cloud dimensions before / after subsampling: %zu / %zu\n", static_cast&lt;std::size_t&gt;(cloud-&gt;size()), static_cast&lt;std::size_t&gt;(cloud_subsampled-&gt;size())); return cloud_subsampled_with_normals; } 这个函数运行之后报错，报错信息定位到
D:\Program Files\PCL 1.12.0\3rdParty\Eigen\eigen3\Eigen\src\Core\util\Memory.h
Memory.h中的Eigen::internal::aligned_free上，看起来是一个释放指针或者什么的函数，不管怎么运行程序，或者重装PCL库、VS2019都解决不了这个bug。
/** \internal Frees memory allocated with aligned_malloc. */ EIGEN_DEVICE_FUNC inline void aligned_free(void *ptr) { #if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED std::free(ptr); #else handmade_aligned_free(ptr); #endif } 后来我去PCL库的GitHub仓库去搜，有好多人也遇到这个bug。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a630f5ab3c9894f670ebac3796eabe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcde7f0ecc6c0071e8fd948f6277841d/" rel="bookmark">
			python tcping（ping命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python tcping（ping命令) 使用tcping库中的ping方法使用如下：
from tcping import Ping ping = Ping('www.baidu.com', 80, 200) # 地址、端口、超时时间 ping.ping(3) # ping命令执行次数 ret = ping.result.table # 以表格形式展现（ping.result.raw # 原始形态，ping.result.rows # 行显示） print(ret) 其他：
该库中其他方法产生的值可以以字典的形式展现，
tcping.Ping('www.baidu.com', 80, 10).__dict__ # .__dict__ 奇技淫巧 —通过修改tcping库参数，让ping间隔发生改变
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc0e0be954dc849581f9ff1817647de/" rel="bookmark">
			2021-09-07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js递归方式1–100求和 // 递归 let add = function(num1,num2){ var num = num1+num2 if(num2+1&gt;100){ return num }else{ return add(num,num2+1) } } add(1,2) // 循环 let sun=0; for(let a=0;a&lt;=100;a++){ sun+=a } console.log(sun) // function sun(n) { if (n === 1) return 1 return sun(n - 1) + n } sun(100) 数组去重 ES5
let arr = [1,2,321,1,1,3,1] function fn(){ let arr1=[] for(let a of arr){ if(arr1.indexOf(a) === -1){ arr1.push(a) } } } ES6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cc0e0be954dc849581f9ff1817647de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef4626d77d229e54647e8e90e00301b4/" rel="bookmark">
			uniapp监听页面与滚动h5监听页面滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在uniapp中，使用生命周期onPageScroll() onPageScroll(e) {
console.log(e.scrollTop)
if (e.scrollTop &gt;= 120) {
console.log(true)
this.isFixed = true
} else {
this.isFixed = false
}
},
2.在普通h5页面中使用原生js进行监听 window.onscroll = function () {
//为了保证兼容性，这里取三个值，哪个有值取哪一个
//scrollTop就是触发滚轮事件时滚轮的高度
var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
console.log("滚动距离" + scrollTop);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf176a923db057dcd48adf4259d8d38/" rel="bookmark">
			HTML .CSS实现购物车（cart）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、购物车页面演示
.html
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;购物车&lt;/title&gt; &lt;link href="css/common.css" rel="stylesheet"/&gt; &lt;link href="css/cart.css" rel="stylesheet"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="all"&gt; &lt;iframe class="iheader" src="header.html"&gt;&lt;/iframe&gt; &lt;div class="cars"&gt; &lt;table&gt; &lt;tr class="tr1"&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;市场价&lt;/th&gt; &lt;th&gt;定购价&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr class="tra"&gt; &lt;td&gt; &lt;a&gt;&lt;img src="img/ico_checkout.png" style="width: 20px;height: 20px;margin-top: 15px;"/&gt;&lt;/a&gt; &lt;span&gt;&lt;img src="img/cake1_s1.jpg" style="width: 100px;height: 80px; margin-top: -20px;"/&gt;&lt;/span&gt; &lt;span&gt;[悦轩饼家蛋糕]榴芒双拼(约2磅)一双拼蛋糕&lt;/span&gt; &lt;/td&gt; &lt;td&gt;&lt;p style="text-decoration: line-through; text-align: center;"&gt;￥298&lt;/p&gt;&lt;/td&gt; &lt;td style="text-align: center;"&gt;￥198&lt;/td&gt; &lt;td style="text-align: center;"&gt;2&lt;/td&gt; &lt;td style="text-align: center;"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;tr class="tra"&gt; &lt;td&gt; &lt;a&gt;&lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf176a923db057dcd48adf4259d8d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72fb5d8ff4c29d33ba242dfee48eabc0/" rel="bookmark">
			FCN全卷积网络理解及代码实现（来自pytorch官方实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频链接：https://www.bilibili.com/video/BV1J3411C7zd?vd_source=a0d4f7000e77468aec70dc618794d26f
代码：https://github.com/WZMIAOMIAO/deep-learning-for-image-processing
FCN是2015年提出的首个端对端的针对像素级预测的全卷积网络。
如今的pytorch实现的FCN都是基于ResNet-50的backbone，不是论文中的VGG16，且使用的是空洞卷积（也叫膨胀卷积）
pytorch官方实现的FCN网络结构图 博主github：https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_segmentation/fcn
一、相比以前网络的巨大提升： 二、传统使用池化层最后得到的其实是一个长度为1000的向量： 而换为卷积层之后，最后得到的是1000通道的2D图像，可以可视化为heat map图。
三、回顾VGG16 一般说的vgg16是D：
全连接操作前后：77512（通道）
【 假 设 忽 略 偏 置 】 \color{red}{【假设忽略偏置】} 【假设忽略偏置】
全连接FC1计算：计算对应某一个结点的输出，将该节点与上一层某一个结点的权重与输入对应节点数值相乘，再求和
FC1参数：25088*4096=102760448 下层使用7*7的卷积核、stride=1，4096个卷积核的一个卷积层
Conv参数：77512*4096=102760448 一 个 卷 积 核 和 F C 1 一 个 节 点 参 数 量 一 样 \color{red}{一个卷积核和FC1一个节点参数量一样} 一个卷积核和FC1一个节点参数量一样，一共4096个卷积核，FC也是4096个节点。
【 不 忽 略 偏 置 的 正 常 卷 积 操 作 ， 4096 个 卷 积 核 应 该 有 4096 个 偏 置 项 】 \color{red}{【不忽略偏置的正常卷积操作，4096个卷积核应该有4096个偏置项】} 【不忽略偏置的正常卷积操作，4096个卷积核应该有4096个偏置项】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72fb5d8ff4c29d33ba242dfee48eabc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b7e2fd3ac5d712b81ce5db557a9232/" rel="bookmark">
			基于vant UI设计一个下拉选择跟搜索功能的组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		theme: smartblue 简介： 这个是基于 vant3.0跟vue3.0的项目，在开发中封装的一个组件
效果图： 组件功能 1. 组件的下拉框数据进行排序从小到大，分别为四个字体及以下，一行占四个位置，四个字体以上十个字体以下，一行占2个位置均匀分布，超过十个字体，一行占一个位置，本来想过说用padding自动设置数据的宽度，但是效果不太好看，最后选择了这种方法
2.防抖跟节流，这个是在搜索框加的，进行模糊查询，输入字符，结束一秒后没有任何操作在进行请求
3.进行下拉框的遍历，下拉框为一个数组，根剧数据的数据遍历下拉框，以及下拉框的隐藏跟搜索框的隐藏
开发 第一步 首先先将下拉框改造成可以进行循环渲染的
参数：
title: 菜单项标题
menuList: 父组件传来的数据
&lt;template&gt; &lt;div class="menu-list"&gt; &lt;van-dropdown-menu&gt; &lt;van-dropdown-item v-for="(item,index) in menuList" :key="item.name" :title="self.activeName[index]||item.name" :ref="el =&gt; { nodes[index] = el }" &gt; &lt;div&gt;自定义内容&lt;/div&gt; &lt;div class="dropdown-bottom"&gt; &lt;van-button color="#F8F8F8" type="default" class="button" style="color:rgba(107,107,107,1)" @click="onfailed(index)" &gt; 重置 &lt;/van-button&gt; &lt;van-button type="primary" class="button" @click="onConfirm(index,item.data)" &gt; 确定 &lt;/van-button&gt; &lt;/div&gt; &lt;/van-dropdown-item&gt; &lt;/van-dropdown-menu&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { onActivated, reactive, toRefs, ref } from 'vue' export default { props: { menuList: { type: Array, default: () =&gt; [] }, }, setup (props, ctx) { const node = ref({}) // 关闭的方法 const onfailed = (index) =&gt; { // 置空title值 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2b7e2fd3ac5d712b81ce5db557a9232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcaf18008cad652e1d2e2c92ed05d4b/" rel="bookmark">
			【MySQL】MySQL进阶之路（五）MySQL索引详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面的话
脑子是个好东西，可惜的是一直没有搞懂脑子的内存删除机制是什么，所以啊，入行多年，零零散散的文章看了无数，却总是学习了很多也忘了很多。
痛定思痛的我决定从今天开始系统的梳理下知识架构，记录下零散的知识，方便温故知新的同时也顺便清除一些大脑空间用来学习更高深的技术。
目录
何为索引？有什么作用？
索引的优缺点
索引的底层数据结构
Hash表
B 树&amp; B+树
索引类型
主键索引(Primary Key)
二级索引(辅助索引)
聚集索引与非聚集索引
聚集索引
非聚集索引
非聚集索引一定回表查询吗(覆盖索引)?
覆盖索引
联合索引
最左前缀匹配原则
索引下推
创建索引的注意事项
使用索引的一些建议
MySQL 如何为表字段添加索引？
何为索引？有什么作用？ 索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。
索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。
索引的优缺点 优点 ：
使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点 ：
创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间。 但是，使用索引一定能提高查询性能吗?
大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。
索引的底层数据结构 Hash表 哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。
为何能够通过 key 快速取出 value呢？ 原因在于 哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。
hash = hashfunc(key) index = hash % array_size 但是！哈希算法有个 Hash 冲突 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 链地址法。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fcaf18008cad652e1d2e2c92ed05d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92302680dc6631b80ca0fe57ed03456/" rel="bookmark">
			C&#43;&#43;volatile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 Volatile，词典上的解释为：易失的；易变的；易挥发的。那么用这个关键词修饰的C/C++变量，应该也能够体现出”易变”的特征。大部分人认识Volatile，也是从这个特征出发。volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从内存中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象易变性。
Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。
二、实例 定义一下原子的类型：
volatile std::atomic_bool isReady = false; volatile std::atomic_int mycount = 0; 这里的volatile保证了每次数据都是从内存拿，而不是有一定安全性风险的寄存器。
我们这里准备计算10个线程的累加和
#include &lt;thread&gt; #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;atomic&gt; #include &lt;list&gt; using namespace std; volatile std::atomic_bool isReady = false; volatile std::atomic_int myCount = 0; // 使用原子类型 int normalCount = 0; // 普通全局变量，不使用原子类型 void task() { while (!isReady) { std::this_thread::yield(); // 线程出让当前的CPU时间片，等待下一次调度 } for (int i = 0; i &lt; 100; ++i) { myCount++; normalCount++; } } int main() { list&lt;std::thread&gt; tlist; for (int i = 0; i &lt; 10; ++i) { tlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a92302680dc6631b80ca0fe57ed03456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d53b8bb79de1d03daa595d1df6516ddf/" rel="bookmark">
			Elasticsearch&amp;Kibana从6.0升级到7.9的踩坑全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 需求来源 公司当前使用的elasticsearch&amp;kibana是6.0.0版本，这已经是快三年前的古老版本了，最新的7.9.X，出于性能上的提升以及漏洞的修复（客户爸爸对于漏洞扫描的结果表示了深切的担忧-_-！），所以近期将elasticsearch&amp;kibana升级提上日程，由于我们公司是elasticsearch&amp;kibana的重度用户，而且绝大多数有价值的数据都存在elasticsearch中，所以就先在一个单机版本的elasticsearch上进行试验填坑，成功后再复制到集群上，这也就是本文的来源
环境介绍 单机版本的elasticsearch&amp;kibana，版本号为6.0.0，中途由于kibana无法正常使用，于是使用了cerebro进行集群状态确认和管理
升级目标 本着一步到位的原则，直接升级到最新的大版本7.9.0，一次升级解决未来两三年的需求
正文 elasticsearch升级 由于公司的集群既有公有云的集群部署，更多的是私有化或者私有云部署，所以每个集群的配置都各不相同，很多数据规模较小的客户elasticsearch只有一台server，而且index也没有配置replica，所以滚动升级在很多场景下是不可实现的，再加上我们的业务特点，数据不是特别敏感，所以短时间的停机是可以接受的，所以在此仅讨论停机升级，并尽量复用旧版本的配置，滚动升级的情况资料也相当多了，这里就不赘述了
首先优先说明，因为elasticsearch底层使用Lucene存储数据，而Lucene版本也在不断的升级，所以数据跨版本的兼容也只能尽量保证，数据在大多数情况下无法跨大版本直接升级（血与泪得到的教训与结论），所以本文采用的方式是6.0.0&gt;&gt;6.8.0&gt;&gt;7.9.0的升级方式
然后去官网上下载6.8.0以及7.9.0的elasticsearch安装包，上传到服务器解压缩，然后将现有的配置文件分发到新版本的config目录下待使用，下面就分两部分来介绍整个升级过程：
准备工作 由于数据库升级存在很多的不确定性，而数据库里的数据一般来说都是一个公司最重要的资产，所以建议先对旧版本的es进行备份，建议生成一个snapshot用于数据恢复，以备不时之需。
snapshot可以通过kibana来生成，也可以通过cerebro来进行创建：
cerebro的图形化生成：
也可以使用kibana的dev tools来使用命令生成：
#创建一个类型为fs，名称为backups的repository（如果没有的话） PUT _snapshot/backups { "type":"fs", "settings": { "location": "/bb_home/bb_es/backups" } } #在repository下创建一个名称为levelup的snapshot PUT _snapshot/backups/levelup?wait_for_completion=true #查看该snapshot的详情 GET _snapshot/backups/levelup 复制代码 所谓有备无患，一向很懒的笔者这次的勤劳没有白费，开始笔者直接尝试停机直接从6.0.0升级到7.9.0，受到了技术铁锤的无情暴击，直接报了无数的错误，启动直接失败，这时候笔者想吃回头草，用6.0.0去启动，但是由于前面的操作，7.9.0的启动失败已经污染了之前的数据，导致数据无法被识别，这时候笔者心一横，直接将data目录下的数据全部删除，重新启动elasticsearch，然后使用snapshot进行恢复。
中途经历了两个错误：第一个是由于data目录清空，所以之前创建的repository失效，这个问题重新创建repository即可解决；第二个问题时由于kibana还在启动，所以elasticsearch启动后，.kibana这个index自动创建了，所以直接恢复的命令失败了，后续使用配置将snapshot中的.kibana重命名后问题解决，elasticsearch恢复到升级之前的状态，恢复命令如下：
#直接使用snapshot进行数据恢复 POST _snapshot/backups/levelup/_restore?wait_for_completion=true #报错repository missing exception，创建新的repository，与之前一致类型为fs，名称为backups PUT _snapshot/backups { "type":"fs", "settings": { "location": "/bb_home/bb_es/backups" } } #直接使用snapshot进行数据恢复 POST _snapshot/backups/levelup/_restore?wait_for_completion=true #报错cannot restore index [.kibana] because it's open后的恢复，将snapshot中的.kibana重命名 POST _snapshot/backups/levelup/_restore?wait_for_completion=true { "indices": "*", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d53b8bb79de1d03daa595d1df6516ddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33eb95b4ddf59e0c766d19f9b69189cb/" rel="bookmark">
			Docker开启远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker开启远程访问 查找docker.service
# 文件是在/lib目录下 find / -name "docker.service" 修改docker.service
vim /lib/systemd/system/docker.service # 在ExecStart后加入 -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重新载入Docker服务
systemctl daemon-reload 重启docker服务
systemctl restart docker.service 查看端口是否开启
netstat -nlpt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953545f8334e65af80cf9574857aa24a/" rel="bookmark">
			Mysql分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql分布式事务 XA协议分布式事务模型流程两阶段提交 Mysql中的XA语法使用演示XA状态转换图 XA的BUGXA的性能问题总结参考资源 XA协议 为了规范分布式事务的管理,X/OPEN 提出了分布式事务处理规范XA协议，XA规范了TM与RM之间的通信接口，在TM与多个RM之间形成一个双向通信桥梁，从而在多个数据库资源下保证ACID四个特性。目前知名的数据库，如Oracle, DB2,mysql等，都是实现了XA接口的，都可以作为RM。
XA是数据库的分布式事务，强一致性，在整个过程中，数据都处于被锁住的状态，即从prepare到commit、rollback的整个过程中，TM一直拥有参与分布式事务RM对应的数据库的锁，如果有其他人要修改数据库的该条数据，就必须等待锁的释放，存在长事务风险。
分布式事务模型 X/Open定义了分布式事务处理模型，包括应用程序AP、事务管理器TM、资源管理器RM、通信资源管理器CRM。
在XA规范中分布式事务有AP、RM、TM组成：
应用程序（Application Program）：定义事务边界（定义事务开始和结束）并访问事务边界内的资源 资源管理器（Resource Manager）：RM管理计算机共享的资源，资源包含比如数据库、文件系统等 事务管理器(Transaction Manager，简称TM)：负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。 流程 分布式事务的基本流程如下:
具体流程如下:
配置TM，将RM注册到TMAP从TM获取资源管理器的代理，获取TM所管理的RM的JDBC连接AP向TM发起全局事务TM将XID通知到各RMAP通过Connection连接直接对RM进行操作AP结束全局事务TM会通知RM全局事务结束开始二阶段提交 两阶段提交 当每个RM都结束了全局事务的执行后，此时每个RM管理的分布式事务分支还没有提交，只是把该事务管理的业务逻辑执行完了。
进入二阶段提交阶段，在这个阶段,会先进入prepare阶段，然后再是commit或者rollback阶段。
具体流程如图:
第一阶段分为两个步骤：
事务管理器通知参与该事务的各个资源管理器，通知他们开启事务、执行SQL（暂不提交），并进入prepare状态（该状态下可执行commit/ rollback）。 资源管理器接收到消息后开始准备阶段，写好事务日志并执行事务，但不提交，然后将是否就绪的消息返回给事务管理器 RM根据自己的情况，如果判断自己进行的工作可以被提交，那就就对工作内容进行持久化，并给TM回执OK；否者给TM的回执NO RM在发送了否定答复并回滚了已经的工作后，就可以丢弃这个事务分支信息了 第二阶段也分为两个步骤：
事务管理器在接受各个消息后，开始分析，如果有任意其一失败，则发送回滚命令，否则发送提交命令。 各个资源管理器接收到命令后，执行（耗时很少），并将提交消息返回给事务管理器。 两阶段提交的好处是有了事务管理器进行统一管理，让事务在提交前尽可能的完成所有能完成的工作。同时两阶段提交可以保证事务的一致性，不管是事务管理器还是各个资源管理器，每执行一步操作都会被日志记录，为出现故障后的恢复提供依据。
Mysql中的XA语法 Mysql中分布式操作的基本模板如下：
开启xa事务，XA start &lt;xid&gt; DML语句，即SQL增删改查语句 终止XA事务，XA end &lt;xid&gt; 预提交事务， XA prepare &lt;xid&gt;，这一步是有返回值的 提交，XA commit &lt;xid&gt;，根据prepare操作的返回结果做的处理 回滚，XA rollback &lt;xid&gt;，根据prepare操作的返回结果做的处理 XA RECOVER: 返回当前数据库中处于PREPARE状态的分支事务的详细信息 每个事务必须有一个唯一的xid值,因此当前值不能被其他XA事务使用,xid是一个XA事务标识符,用来唯一标识一个分布式事务。
xid值可以由客户端提供，或者由Mysql服务器生成。
xid基本格式如下:
xid: gtrid [,bqual] [, formatID] gtrid 是一个分布式事务标识符,相同的分布式事务使用相同的gtrid,这样可以明确知道XA事务属于哪一个分布式事务 bqual是一个分支限定符,默认为空串,对于一个分布式事务中的每个分支事务,bqual必须是唯一的 formatID是一个数字,用于标识由gtrid和bqual值使用的格式,默认为1 XA语法中用到的xid值都必须和START操作使用的xid值相同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/953545f8334e65af80cf9574857aa24a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489439686031ce8c750098578af3f822/" rel="bookmark">
			js的六种继承方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、原型链继承
核心： 将父类的实例作为子类的原型
function Parent1() { this.name = 'parent1'; this.play = [1, 2, 3] } function Child1() { this.type = 'child2'; } Child1.prototype = new Parent1(); console.log(new Child1()); // 潜在的问题 let s1 = new Child1(); let s2 = new Child1(); s1.play.push(4); console.log(s1.play, s2.play); // [1,2,3,4] [1,2,3,4] // 两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。 特点：
1.非常纯粹的继承关系，实例是子类的实例，也是父类的实例
2.父类新增原型方法/原型属性，子类都能访问到
3.简单，易于实现
缺点：
1.要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
2.无法实现多继承
3.来自原型对象的所有属性被所有实例共享（来自原型对象的引用属性是所有实例共享的）
4.创建子类实例时，无法向父类构造函数传参
2、构造函数继承（借助 call）
核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
function Parent1(){ this.name = 'parent1'; } Parent1.prototype.getName = function () { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489439686031ce8c750098578af3f822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59c3152cf20261d0fd6cafe32677269/" rel="bookmark">
			Python一 —— Python的垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Python的垃圾回收机制概述引用计数引用技术的概念及缺点引用计数的案例循环引用导致内存泄漏的情况 分代回收标记—清除技术垃圾回收的触发gc 模块 (解决循环引用问题)常用函数gc 实践案例gc 模块的自动垃圾回收机制自动回收阈值 1. Python的垃圾回收机制 概述 Python采用的是 引用计数为主， 标记—清除 和 分代收集 为辅的策略。
引用计数 引用技术的概念及缺点 Python语言默认采用的垃圾回收机制 是 引用计数法（Reference Counting）。引用计数法的原理是：每个对象维护一个ob_ref字段，用来记录该对象被引用的次数吗，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象引用失效时ob_ref减1，一旦该对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是： ① 需要额外的空间维护引用次数，这个问题是其次的② 最主要的问题是：它不能解决对象的循环引用，循环引用会出现内存泄漏的情况，因此很多语言比如Java并没有采用该算法来做垃圾回收机制。 引用计数的案例 import sys class A(): def __init__(self): '''初始化对象''' print('object born id:%s' %str(hex(id(self)))) def f1(): '''循环引用变量与删除变量''' while True: c1=A() del c1 def func(c): print('obejct refcount is: ',sys.getrefcount(c)) #getrefcount()方法用于返回对象的引用计数 if __name__ == '__main__': #生成对象 a=A() func(a) #增加引用 b=a func(a) #销毁引用对象b del b func(a) 执行结果：
object born id:0x265c56a56d8 obejct refcount is: 4 obejct refcount is: 5 obejct refcount is: 4 导致引用次数 +1的情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59c3152cf20261d0fd6cafe32677269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f460304e213a1d6e589a4a876c7f0b3/" rel="bookmark">
			机器学习之卷积神经网络--CNN介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络–CNN 1. 卷积神经网络介绍 卷积神经网络（Convolutional Neural Networks，CNN）是一种包
含卷积计算且具有深度结构的前馈神经网络，是深度学习的代表算法之一。
常见的CNN网络有LeNet-5、VGGNet、GoogleNet、ResNet、
DenseNet、MobileNet等。
CNN主要应用场景： 图像分类、图像分割 、 目标检测 、 自然语言处
理等领域。
2. 卷积神经网络基本结构及原理 卷积神经网络基本结构 CNN基本结构：INPUT -&gt; 卷积-&gt;激活 -&gt; 池化 -&gt; 全连接 -&gt;OUTPUT
卷积层 对输入的图像数据与卷积核做卷积运算提取图像的高阶特征
卷积过程的几个参数
1、深度（depth）：卷积核个数，也称神经元个数，决定输出的特征图的数量。
2、步长（stride）：卷积核滑动一次的大小，决定滑动多少步可以到达边缘。
3、填充值（padding）：在外围边缘补充0的层数。
卷积过程 卷积网络最主要的两个特征
1、局部感知
2、权值共享
激活层、Relu函数
池化层 下采样（downsamples），对输入的特征图进行压缩；
一方面使特征图变小，简化网络计算复杂度，有效控制过拟合；
另一方面进行特征压缩，提取主要特征。
池化，规模一般为 2＊2，操作一般有2种：
最大池化（Max Pooling）。取4个点的最大值。这是最常用的池化方法。均值池化（Mean Pooling）。取4个点的均值。 全连接层 连接所有的特征，将输出值送给分类器，实现分类。
3. pytorch中卷积的实现 卷积层 torch.nn.Conv2d（）
参数说明
in_channels：输入通道数（深度）
out_channels：输出通道数（深度）
kernel_size：滤波器（卷积核）大小
stride：表示滤波器滑动的步长
padding：是否进行零填充
bias：默认为 True，表示使用偏置
groups：控制分组卷积，默认不分组，为1组。
dilation：卷积对输入的空间间隔，默认为 True
激活层 torch.nn.ReLU（）
参数说明
inplace:是否在原数据进行操作，默认是False
池化层 torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f460304e213a1d6e589a4a876c7f0b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a492a2e92b5abc440e519dbc82c7a9/" rel="bookmark">
			西门子200PLC指令详解——位逻辑指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文所描述的指令符合SIMATIC和IEC1131指令，不仅可用于西门子S7-200PLC，其他小型PLC也可作为参考。比如SMART200的PLC.
1.S7-200存储器范围 如下表所示，为西门子S7-200各型号PLC的存储器范围值。
2.S7-200CPU操作数范围 下图为CPU操作数范围
3. 位逻辑指令 位逻辑指令如下图，有很多个，我们一个一个来解读。
1.触点指令 如下图所示：触点指令分为常开触点，常闭触点，立即触点，取反指令，边沿检测等指令。
常闭触点：当触点值为1时闭合或者说接通，触点值为0时断开；
常闭触点：与常开触点相反；
立即触点：直接与物理输入输出交互，不经过输入输出映像寄存器，不经过扫描刷新。
取反指令：对前面的计算值取反，如果前面为1则后面为0；
上升沿检测：输入值从0到1跳变一次，则上升沿接通一个PLC扫描周期
下降沿检测：输入值从1跳变到0一次，则下降沿接通一个PLC扫描周期
注意：红色？是要输入的位软元件，也就是触点值或者说输入值。
触点指令示例程序如下图
2. 线圈指令 线圈指令有输出线圈，立即输出，置位指令，复位指令，立即置位指令，立即复位指令，空指令等。
输出指令：即前面接通则它是1，前面断开则它是0；
立即输出：不经过扫描周期立即输出到物理IO点；
置位指令：让从指定地址开始的N个软元件一直保持1的状态；
复位指令：让从指定地址开始的N个软元件一直保持0的状态
空指令：啥都不干
线圈指令示例程序如下图 3. 位逻辑指令的有效软元件(或者操作数) 位逻辑指令的有效软元件(或者操作数)就是值位逻辑指令红色?处可以输入的符号，它的有效范围如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb693a096e563203e9dce085617f534/" rel="bookmark">
			“元起：前元宇宙时代的眺望”讲座学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为下一代互联网，元宇宙是一个万物互连、普适计算的世界，是一个虚实融合、共生的世界，它将改变工业、公共安全、文娱等终极形态，提高人们的生产、沟通、协作效率，带动生产力提升和产业变革。
4月28日，“元宇宙与虚实交互前沿系列论坛”的首场主题报告“元起：前元宇宙时代的眺望”以线上直播的形式展开。本次论坛由元宇宙与虚实交互前沿论坛组委会主办，元宇宙与虚实交互联合创新中心协办。活动得到了复旦大学国家智能评价与治理实验基地、南京大学信息管理学院、中山大学大数据研究院、同济大学绿色建筑及新能源研究中心、市北高新、上海图书馆机构支持，上海市多媒体行业协会、广东省虚拟现实产业技术创新联盟协会支持。
通过学校公众号推送的相关信息，本人在4月28日在线上参与了此次论坛讲座。论坛一共有四场报告，分别是：总起主题报告：前元宇宙时代的眺望、软件主题报告：虚幻引擎5与虚实交互、软硬结合报告：大话元宇宙-元宇宙产业发展解析、综合主题报告：元宇宙的思考与实践，因此我的学习笔记也按这四场报告来展开。
1. 前元宇宙时代的眺望（赵星） 作为首位演讲嘉宾，复旦大学国家智能评价与治理实验基地、大数据研究院的赵星教授就“前元宇宙时代的眺望”这一主题进行了阐述，表达了他对元宇宙的现状与影响、创新与泡沫、机遇与挑战等话题的看法。
对于元宇宙这个概念而言，或许不同的人有不同的答案。元宇宙的英文是Metaverse，前缀meta意为超越，词根verse则由universe演化而来，泛指宇宙、世界。在维基百科中，元宇宙通常被用来描述未来互联网的迭代概念，由持久的、共享的、三维的虚拟空间组成，是一个可感知的虚拟宇宙。
赵星教授认为，当前仍处于“前元宇宙时代”，目前最重要的是厘清元宇宙不是什么——“我们当前所处的还是前元宇宙时代，目前最重要的首先厘清元宇宙是什么，而不应在绝大部分应用都还未落地之前就给元宇宙下定义。”他提出了元宇宙发展的三种模式：一是基于数字孪生、工业互联网行业力推的明镜世界；二是基于游戏和社交、美国企业力推的虚拟世界；三是基于实体经济传统工商业、中国部分区域探索的虚实交互世界。
元宇宙不是空谈数字化，而是一个全真、全新的数字世界，它将实现我们总结的“五大融合”：数字世界与物理世界的融合、数字经济与实体经济的融合、数字生活与社会生活的融合、数字资产与实物资产的融合、数字身份与现实身份的融合。
最后，赵星教授提到：由目前全球十余家元宇宙头部企业、我国10所顶尖高校及政府事业单位共建的”元宇宙与虚实交互联合创新中心，目前已在最后的筹备阶段，将于疫情后在上海的多个区同时启动。
2. 虚幻引擎5与虚实交互（褚达） 第二位做报告的是虚幻引擎中国区教育经理褚达。他认为：“元宇宙是一个通过实时技术构建全要素交付、多价值体现与现实世界完全平行并持续演化的虚拟空间。”正如在元宇宙系列——《元宇宙：互联网的下一站》中阐述的：从功能上看，元宇宙 是一个承载虚拟活动的平台，用户能进行社交、娱乐、创作、展示、教育、交易等社会 性、精神性活动。元宇宙的核心在于可信地承载人的资产权益和社交身份。这种对现实 世界底层逻辑的复制，让元宇宙成为了坚实的平台，任何用户都能参与创造，且劳动成 果受到保障。基于此，人们在元宇宙的劳动创作、生产、交易和在实际生活中的劳动创 作、生产、交易没有区别。比如用户在元宇宙中建造的虚拟房子，不受平台限制能够轻 松交易，换成元宇宙或者真实宇宙的其它物品，其价格是由市场决定。
此外，他还提到：“虚幻引擎在构建数字孪生世界中可以发挥重要作用。在这个数字孪生的互联生态系统中，创作者可以易用尽心创作，平台可以提供数据整理，同事协作均是可以实现的。”因此，他也在演讲中详细介绍了虚幻引擎5在构建数字虚拟世界和虚实结合的数字孪生世界中的具体功用。
3. 大话元宇宙：元宇宙产业发展解析（张中阳） 第三位做报告的是华为上海代表处产业生态总监张中阳。
纵观全球，去年 3 月第一个元宇宙概念股 Roblox 的上市将市场的目光吸引到了元宇宙这 一概念上，伴随着 NFT、GameFi 的出圈，元宇宙产业发展迅速。去年十月，在 Facebook 一年一度的 Connect 大会上，扎克伯格细致、完整地阐释了 Facebook 对元宇宙的认识、 战略规划以及目前在元宇宙领域上所取得的各项进展，并宣布将正式转型更名为 Meta。 大拇指 Logo 被替换成了一个类似于“无穷”的新标志。元宇宙开启了一个重要篇章，各大企业纷纷入局元宇宙。
张中阳表示，元宇宙的突然爆红是偶然因素+多方诉求叠加的共振，元宇宙整个产业从基础到应用的发展呈现了一种螺旋上升的方式。他认为元宇宙是科技向艺术的一次概念借用，目前虽还处于定义期，但是无论成熟与否，关键是能否构建数字文明。他称，元宇宙将大量离散的单点创新聚合形成新物种，带来长期超越想象的潜力和机会。
具体而言，张中阳认为短期来看，未来3-5年，元宇宙将进入雏形探索期，VR/AR、NFT、AI、云等领域渐进式技术突破和商业模式创新将层出不穷。而中长期来看，元宇宙产业机会包括了GPU/NPU，3D图形引擎、云计算和IDC等。元宇宙的建设和普及还将促进数字经济与实体经济实现更深层次的融合，从而助力“百行千业”全面转型升级，为实体产业开辟全新的发展空间。
此外，他也抛出了对元宇宙当前发展的另一面看法：不跟风、不反对、不推波助澜、不错失机会，理性看待，保持定力持续推进原定战略目标。
4. 元宇宙的思考与实践（唐荣兴） 最后做分享的是上海元宇宙企业亮风台联合创始人兼COO唐荣兴。他提出了“元宇宙思维”这一概念，即面对每一代互联网的到来，需要抓住本质的变化实现认知升级，积极思考技术、经济、社群、产业、人文等的变化，并拥抱变化。
他从西游记、庄子的中国传统文化想象，谈到两弹一星科学家钱学森深具中国文化特色的“灵境”描述，再到乔布斯、凯文凯利等互联网先驱的信息技术畅想。“更早的先知启发了早期的信息技术与更近的互联网；当我们认真看待互联网的发展、进化，才能更好地看到未来”。
谈到元宇宙的价值，唐荣兴认为：“元宇宙的价值并不是让我们脱离现实，沉迷虚拟世界，元宇宙需要为实体经济服务，为制造业服务，为各种传统行业的数字化转型服务。因此我们需要推进产业元宇宙，通过构建与真实世界完全打通的虚拟空间，为真实世界提供更好的数字化支持。”在新型基础设施的赋能之下，未来的十年将是社会数字化转型加速的十年，所有行业都值得重新做一遍。例如，工业元宇宙可以连接可见的人、设备、产线、环境与不可见的“数据、模型、知识、智慧”，完成“感知-认知-决策-执行”的闭环，实现“看到不可见，看懂看不懂，做到不可能”。
不管是消费级、产业级还是城市级元宇宙，当下元宇宙并不是遥不可及，AR/VR技术给我们带来沉浸式体验，AR交互让我们在元宇宙里实现虚实共生，千行百业逐步走向数字化、智能化、全息化。
唐荣兴说道：“曾经有一个热词叫“互联网思维”，其实面对每一代互联网的到来，我们需要抓住本质的变化进行认知的转化，实现思维模式的转变，正如“元宇宙思维”需要思考技术、经济、社群、产业、人文等变化，并积极拥抱变化，才能有所创新有所成长”。元宇宙就是未来的互联网，或第三代互联网。我们知道，第一代互联网是PC时代，第二代则是移动互联网，而第三代互联网，则是以大数据、物联网、云计算、人工智能、虚拟现实及增强现实、区块链等为核心的内容，这些事物的集合，就是我们讲的元宇宙。他认为，行业应以新的思维模式迎接即将到来的巨大的数字经济增量市场。
5. 个人总结 总体来看，元宇宙仍处于发芽发展时期，只有了解技术的界限，我们才能清楚地看到元宇宙的现状和未来。我也是听了讲座才知道，元宇宙还能有基于数字孪生、工业互联网行业力推的明镜世界，基于游戏和社交、美国企业力推的虚拟世界，基于实体经济传统工商业、中国部分区域探索的虚实交互世界这3种模式。看来元宇宙的未来还是有很多可能性的，虽然它可以说是机会和泡沫并存，但所有人的努力也可以让它变成一个使现实世界更美好的元宇宙。从风口到落地，我们正站在下一代互联网、站在下一个时代的起点，只有更多地了解和学习新的技术、新的知识，才能一直跟上时代的步伐。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6598b645fbc1fd0dc913b9a6191eca4f/" rel="bookmark">
			“科研素养与论文写作”讲座学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教授线上应邀开展了一次题为“科研素养与论文写作”的讲座，以大量丰富而又生动的例子阐述了对科研发现、科研素养的理解，重点阐述了义理（即哲学思想）的重要性，丝丝入扣的讲解引人深思。
1. 讲座内容 教授首先从辞源上剖析了“素养”一词的由来，老师从阅读积累与发现的角度切入，以古诗中“黄鹂”、“无邪”二词含义的考证为例，展示了研究发现的有趣经历；继而以《中国文化地理》中蝗灾与蝗神庙相关性的发现等为例，进一步展示科研发现的过程；并以中国历代人物传记数据库为例指出，当今时代，以现代化的数据库为基础，同样可以进行人文研究。从文学、艺术、哲学、美学、考古、校雠学、地理学等学科领域，大量枚举国内外诗词、绘画、书法、文化名人、古籍文献等经典案例，阐明了“创新”这一科研素养的重要性及实现路径：即科研创新的来源在于日常学习生活中善于发现问题并有效积累。
通过这些生动的例子，揭示何为科研素养。之后老师对积累与发现进行了理论总结与阐释，引用孔德、胡适等人的论点说明科研的正确过程，并以蚂蚁、蜘蛛和蜜蜂来形象地说明三种科研类型。最后，老师还列举了“尿布与啤酒”、古代名人手札中异体字的考证、图书馆与档案学中著名学者理论发现的过程等例子来深入解析这种科研发现的正确过程及过程中科研素养的体现。老师强调说，规律是对现象的观察归纳，积少成多，提出并反复验证假设后提取的，假设的提出应当遵循大胆假设，小心求证原则。
在论文写作探讨中，教授指出了选题有意义、观点明确、结构清晰、内容充实、方法得当、引证丰富、语言流畅等优秀论文的评判标准，并结合国内外优秀学者的论文分析其中的写作方法与技巧。接着以一些选题和构思巧妙的论文为例，展示何为好的论文；其中特别强调了如何选题以及在论文引言中如何解释课题的价值及课题设计的科学性。在论文选题上，他指出选题即为选择研究的对象、切入点和内容，标题的拟定应简练、准确、醒目和新颖。内容贯穿了纵向的时间跨越同时也联结了横向的空间建构，从古到今，从中到西，为我们徐徐阐述了一门蕴含深刻思考和严谨治学态度的学问。
最后，老师借用曾国藩的“义理、考据与辞章”来总结写好论文的三个法门，还以梁启超的治学为例证明这三者的重要性；老师特别指出，义理是形而上的指导，对于治学尤为重要。能够做好研究的基础是从书目的研究开始，老师引用了唐镜海先生对于检身之要、读书之法的言论，“为学只有三门、曰义理、曰考核、曰辞章。”并且表示，这一说法是通过桐城派发扬光大的一种方法。接着在如何读书上谈到了在桐城派想法之上他对于此的理解，老师更多的是从一个与读书相关联的角度来谈，“从一个一个相关联的角度，我们要写好文章，一个人要写好文章，关键是什么？关键在于你有没有一个考核的基础，或者考据，那么你要写好文章的话，关键就在于你能不能前面有一个考据，这样首先是一个资料的积累，还有是一个方法的使用。你有了这样一个做学问的积累和一个方法的使用之后，才能够写好文章。 但是这样一个方法的使用，学问的积累，也就是说在这个过程当中最关键的还是义理。”紧接着又谈及到了义理，从孔子的《论语》开始讲到了儒家的核心，并且与我们当下的时代改革所联系，并且谈到儒家的核心是“一个做人的思想”，而做人最根本的就是忠恕。而后，从程朱理学提到了张之洞先生的《书目答问》，谈到在《书目答问》之中关于如何读好书的学问有三个关键点，为“语行、语学、语文”，教授表示，“一个是关于行的，一个是关于学的，一个是关于文的。这三个方面实际上是这一个指导人一辈子如何读书的一个核心的指导”，三个关键词可以与“义理、考核、辞章”相对应。之后谈到清代学者颜元，教授进一步的说明对于张之洞先生三个关键点的理解，认为学者应该更多要去考据，去积累从而在一个不断积累的过程当中有所体会，最终才可以写好文章。并且列举了梁启超、叶德辉、罗继祖、张舜徽、程千帆和徐特立在求学过程当中，书目对于其研学过程的重要性。
最后，老师还与我们积极互动，针对“如何有效选择参考文献与著作”、“学术论文产出应注重质量还是数量”等问题均进行了专业细致的解答。
2. 个人感悟 所以，在当今时代，科研人员、我们研究生学子究竟需要怎样的科研素养呢？我对这个问题也尝试进行了自己的思考。
个人觉得，首选需要的是渊博的知识，包括掌握领域内所有的知识结构和扎实的科研基本能力；然后是要有正确的动机和目的，以及实事求是的态度和严谨的治学学风，必须把推动科学和社会的前进放在首要地位，而不是单纯地发文章；除了这两者之外，应该还需要掌握写作能力、计算机使用能力、调查研究能力、收集资料的能力、观察能力、社交能力、实验能力、合作能力、数学表达能力、逻辑思辨能力等等，每一项都很重要。
总而言之，本次讲座内容丰富、案例详实、深入浅出，就如何提高科研素养、如何更好地进行论文写作的问题进行了生动地讲解，拓宽了我们的学术视野与研究思路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660c6034c4dad2e59de34acd4d521258/" rel="bookmark">
			“文化遗产图像智能应用——让图像价值看得见”讲座学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教授围绕如何让图像成为活的资源，如何深度挖掘图像的价值展开了一次题为“文化遗产图像智能应用——让图像价值看得见”的讲座，结合团队的研项目成果“多维度图像智慧系统”（MISS平台），让我们探索文化遗产图像的智能应用，在图像中去锁略文化的魅力，在交互中去触摸技术的美感。本人的学习笔记围绕老师讲解的文化遗产图像智能应用的发展背景、技术框架、智慧系统、设计理念和发展趋势这五个部分展开。
1. 文化遗产的概念 文化遗产是历史留给人类的财富。从存在形态上分为物质文化遗产（有形文化遗产）和非物质文化遗产（无形文化遗产）。 文化遗产是具有历史、艺术和科学价值的文物；非物质文化遗产是指各种以非物质形态存在的、与群众生活密切相关且世代相承的传统文化。
在数字人文的建设中，不同资源库和平台使用独立的技术框架、资源格式和应用程序，不同机构在资源共享上存在障碍。在数字人文和文化遗产图像智能应用的背景下，实现文化遗产、籍、文物、藏品中的文字识别、图文识别、版本比对、特征提取、光谱分析等应用，能够驱动人文艺术研究的创新。数字人文已逐渐成为一种学术时尚，但正因为有了技术的加持才促进了数字人文的变革与飞跃。
2. 国际图像互操作框架 IIIF 随着互联网技术的发展，数据时代的来临，分散的知识文化因为网络传播产生空前的连接，人们可以冲破地理阻碍进行文化交融。这种文化的频繁互动极大地加快了社会文明的进程，同时在文化交融过程中也不断产生新的诉求。数字化的图像媒介作为一种非文本型的数据资源，因承载丰富的表现形式、深刻的文化内涵、跨时空的交流共享和多元抽象的隐喻，受到艺术界、教育界空前关注。但目前大部分图像资源被数字化之后分散在各个国家的档案机构中，难以被再发现、利用、转换、比较，逐渐形成图像“孤岛”。
基于这种背景，国际图像互操作框架（International Image Interoperability Framework，IIIF）于2015年6月由大英图书馆、牛津大学图书馆、哈佛大学等29个非营利图像资源存储机构共同成立，用于定义一组规范的资源传输接口（API），促进异构平台和资源库对图像资源的交换和共享，旨在确保全球图像存储的互操作性和可获取性，对以图像为载体的书籍、地图、卷轴、手稿、乐谱、档案资料等在线资源进行统一展示和使用。
机构采用IIIF技术后，可以突破自身资源的限制，完全实现和其他馆藏机构之间图像资源的互操作，极大地提高了在网络数据环境下的研究能力。总的来说，IIIF并非一个平台或系统，而是定义了一套交互的“标准”。
IIIF于2016年产生至今，全球该领域的产品有限，但整体的发展趋势数据可观。从IIIF官网2019年4月公布的数据来看，符合IIIF标准的全球图像已达约10亿张。这些数字化图像主要集中在全球各大图书馆、博物馆、档案馆和文化遗产机构中。与IIIF相关的应用有两类：图像服务器与图像浏览器。目前IIIF官网已经有多款支持IIIF的浏览器被开发，大部分产品是开源，有些是针对IIIF专门开发，有一部分是对现有浏览器进行改进。这些图像浏览器分别有不同的功能侧重和交互方式，针对目前观看者的诉求有不同的特点。目前研究比较深入和比较完整的有以下几个机构研发的浏览器。
其中一个，也是老师重点提到的使用工具“Mirador 3”。Mirador是由斯坦福大学开发的图像浏览器，是目前IIIF资源中比较成熟的产品，目前已开发到第三版本，是使用可视化操作工具针对高清图像资源开放共享的专门化工具。由于该浏览器属于开源软件，哈佛大学又进行了改进。其采用的图形化操作界面主要有以下特征：可以深度缩放和平移高分辨率图像，可以使用缩略图和目录查看和导航多图像对象（如书籍和手稿），能够显示图像区域的注释。Mirador关键的改进和新功能，是预设了图像浏览器用户在不同使用情境下的使用习惯。例如，其可以将图像窗口拟合到相邻空间中，用户可以将窗口移动到可扩展工作空间中的任何位置，甚至重叠;将非常有利于用户作图像比较研究。并且，Mirador允许使用者根据使用目的自定义外观，弹性化的设计使它拥有广泛的使用受众。
目前，我国各地的图书馆、美术馆、博物馆、档案馆等机构均已开始建立大规模的数字化图像资源数据库，不同于以往文本资源的使用方式，这些数字化图像资源在开放共享过程中呈现出了全新的共享模式。所以，对IIIF技术图形化操作界面的研究势在必行，它更好地利用我国的图像资源，架起用户与我国珍贵璀璨史料之间的桥梁。
最后，老师还提到，IIIF框架给图像资源的利用带了新的思考方向和研究模式，基于IIIF、关联数据、语义网等框架和技术，因此，他们研发了多维度图像智慧系统（MISS）平台，该平台可作为数字人文图像研究的基础设施。MISS平台以一站式方式提供图像资源的管理、复用、策展、标注、分享等应用生态，支持超清超大图像的在线研究。
3. 个人总结 在NFT（非同质化代币）、计算机视觉、A/V/3D等领域发展推动下，文化遗产图像智能应用领域必将迸发出新的生机与活力，老师的讲座将理论技术与实践应用巧妙结合，让广大师生受益匪浅。在这些文化遗产图像智能应用新技术的加持下，音、视频等其他资源的开发利用在未来也会变得方便很多。最后，感谢老师本次关于IIIF的分享，相信在未来，将有更多人关注并投身到文化遗产图像智能领域的学习与研究中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf26c2eed2708441671c2b509028e0e7/" rel="bookmark">
			JS基础知识总结 （一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JS简介 JavaScript是一种运行在客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。
浏览器就是一种运行JavaScript脚本语言的客户端，JavaScript的解释器被称为JavaScript引擎，为浏览器的一部分。
二、JS的基础知识 1、JS的编写位置 (1) 将JS写到外部文件
可以将js写到外部文件，然后通过script标签引入
注：script 一旦引入外部标签就不能在内部写
如果需要则创建一个新的script标签
(2) 将js写到script标签中
&lt;script type="text/javascript"&gt; alert("在script标签中"); &lt;/script&gt; (3) 将js代码编写到onclick属性中
可以将js代码编写到onclick属性中
当我们点击按钮时，js代码执行
注：虽然可以写到属性中，但是他们属于结构与行为耦合，不方便维护
&lt;button onclick="alert('讨厌，点我干嘛')"&gt;点我一下&lt;/button&gt; 特别
&lt;!-- 可以将js代码写在超链接的href属性中， 这样当点击超链接时会执行js代码 --&gt; &lt;a href="javascript:alert('让你点你就点！');"&gt;也点我一下&lt;/a&gt; 2、JS基本知识 JS的基本语法 /* 多行注释 */ // 单行注释 /* * 1、在js中严格执行大小写 * 2、js中每一条语句以分号结尾 * 如果不写分号浏览器自己添加，会消耗资源系统，也可能会加错使出错 * 3、js中会忽略多个空格和换行，可利用空格或换行进行代码格式化 */ 字面量、变量以及标识符 字面量 ：是不可改变的值 比如：1、2、3、字面量可以直接使用，但是一般不直接使用
变量 ：变量可以用来保存字面量，而且字面量可以任意改变，变量更加方便使用，开发中用变量保存字面量，很少直接使用字面量
// 声明变量 // 在js中使用var关键字声明变量 var a; // 为变量赋值 a = 123; // 声明赋值同时进行 var b=789; 标识符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf26c2eed2708441671c2b509028e0e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4c72956b30e2d2def067a7cf7697544/" rel="bookmark">
			vue&#43;electron 跨平台桌面应用开发实战教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建项目 1.1 安装vue-cli 先查看是否已经安装了vue-cli，vue-cli的版本是什么?
查看版本命令：vue --version
如果版本叫老，可以直接卸载，再安装最新版本
卸载命令：npm uninstall vue-cli -g
安装目录：npm install @vue/cli -g
1.2 使用vue-cli创建项目 选取一个项目存放的路径，然后开始创建项目
创建项目命令：vue create raje-rebot-front
这里将项目名定为：raje-rebot-front
输入完上述命令之后进入vue项目的创建过程。出现以下内容
第一个选项是 “default” 默认(Vue3)，只包含babel和eslint第二个选项是 “default” 默认(Vue2)，只包含babel和eslint第三个选项是 “Manually select features”自定义安装 选择自定义安装，进入下一步选择
这里我们选择：
babel（高级的语法转换为低级的语法）
Router（路由）
Vuex（状态管理器）
CSS Pre-processors（css预处理器）
Linter / Formatter（代码风格、格式校验）
然后进入下一步
这步是选择vue.js使用的版本，这里选择2.x，接着进入下一步
这步是设置router是否使用history模式，这里选择n，接着进入下一步
这步是设置css预处理模块，这里选择 Stylus ，接着进入下一步
这步是选择ESLint代码检查工具的配置，这里选择ESLint + Standard config，接着进入下一步
这步是选择何时执行ESLint检查，这里选择保存时检查“Lint on save”，接着进入下一步
这步是询问 babel, postcss, eslint 这些配置是单独的配置文件还是放在package.json 文件中，这里选择“In package.json”，接着进入下一步
这步是询问以后创建项目的时候是否也采用同样的配置，这里选择N。
到目前为止，vue项目是创建完成了，我们等待项目下载依赖包，等项目构建完毕我们开始集成electron
1.3 使用electron-builder集成electron 进入项目根目录（raje-rebot-front），然后执行下列命令：vue add electron-builder
这步是选择Electron的版本，这里选择最新版本13.0.0，等待安装完成即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4c72956b30e2d2def067a7cf7697544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66fc67614acbe53879d08b7b62ac011/" rel="bookmark">
			SQL查询语法30例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01基础表
学生表：
老师表：
课程表：
成绩表：
02题目
1、查询名字中含有"华"字的学生信息
2、查询并统计同龄学生人数
3、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列
4、按平均成绩从高到低显示所有学生的平均成绩
5、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分
6、按各科平均成绩从低到高顺序排序
7、查询学生的总成绩并进行排名
8、检索至少选修两门课程的学生学号
9、查询每门课程被选修的学生数
10、查询不及格的课程，并按课程号从大到小排列
11、查询出只选修了一门课程的全部学生的学号和姓名12、12、查询课程编号为"01"且课程成绩在60分以上的学生的学号和姓名
13、查询“01”课程比“02”课程成绩高的所有学生的学号
14、查询平均成绩大于60分的同学的学号和平均成绩
15、查询姓“李”的老师的个数；
16、查询没学过“何倩文”老师课的同学的学号、姓名
17、查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名
18、查询没学过"李征辉"老师讲授的任一门课程的学生姓名
19、查询所有同学的学号、姓名、选课数、总成绩
20、查询学过“张三”老师所教的课的同学的学号、姓名
21、查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名
22、查询所有课程成绩小于60分的同学的学号、姓名；
23、查询没有学全所有课的同学的学号、姓名
24、查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名
25、查询和"01"号的同学学习的课程完全相同的其他同学的学号和姓名
26、把“成绩”表中“高磊”老师教的课的成绩都更改为此课程的平均成绩
27、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩
28、检索"01"课程分数小于60，按分数降序排列的学生信息
29、查询不同老师所教不同课程平均分从高到低显示
30、查询选修“李征辉”老师所授课程的学生中，成绩最高的学生姓名及其成绩
最后感谢每一个认真阅读我文章的人，下面这个网盘链接也是我费了几天时间整理的非常全面的，希望也能帮助到有需要的你！
这些资料，对于想转行做【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！凡事要趁早，特别是技术行业，一定要提升技术功底。希望对大家有所帮助……
如果你不想一个人野蛮生长，找不到系统的资料，问题得不到帮助，坚持几天便放弃的感受的话，可以点击下方小卡片加入我们群，大家可以一起讨论交流，里面会有各种软件测试资料和技术交流。
点击文末小卡片领取 敲字不易，如果此文章对你有帮助的话，点个赞收个藏来个关注，给作者一个鼓励。也方便你下次能够快速查找。
自学推荐B站视频： 零基础转行软件测试：25天从零基础转行到入职软件测试岗，今天学完，明天就业。【包括功能/接口/自动化/python自动化测试/性能/测试开发】
自动化测试进阶：2022B站首推超详细python自动化软件测试实战教程，备战金三银四跳槽季，进阶学完暴涨20K
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9252b095820d1fbdb00c1b3dc29da7/" rel="bookmark">
			安森美用于汽车负载应用的上桥SmartFET驱动器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上桥SmartFET因其易于使用和高水平的保护而越来越受欢迎。与标准MOSFET一样，SmartFET非常适合各种汽车应用。它们的区别在于内置在上桥SmartFET器件中的控制电路。控制电路持续监控输出电流和器件温度，同时针对电压瞬变和其他意外应用条件提供被动保护。这种主动和被动保护功能的结合确保了稳定可靠的应用方案，延长了器件本身及其所保护的应用负载的使用寿命。
安森美(onsemi)现在提供从45 mΩ到160 mΩ的上桥 SmartFET系列 。这些器件是受保护的单通道上桥驱动器，可切换各种负载，如灯泡、螺线管和其他执行器。如表1所示，器件名称表示SmartFET在25°C时的典型RDSOn。下面列出了完整的产品系列：
安森美的该系列器件采用SO8封装，小占位，同时提供高功率。45 mΩ至140 mΩ器件的系列引脚布局为设计人员提供了便利，允许一个引脚布局用于各种应用负载。根据特定应用所需的电流水平，只需将一个器件切换到另一个。这些器件驱动12 V汽车接地负载，并提供保护和诊断功能。该系列器件集成了先进的保护功能，如主动浪涌电流管理、带自动重启的过温关断和主动过压钳位。
一个专用的电流检测引脚对输出进行精确的模拟电流监测，并对电池短路、接地短路以及ON和OFF状态的开路负载检测进行故障指示。所有诊断和电流检测功能都由一个主动大电流检测禁用引脚(仅NCV84160)或一个主动大电流检测使能引脚(该系列的所有其他器件)来禁用或启用。
对上桥SmartFET的“最终要求”是切换负载，市场上为此提供了不同的替代方案。例如，继电器已在行业中使用了很长时间，用于切换各种汽车负载，尤其是那些需要大电流激活的负载。随着汽车零部件和组件的重量和尺寸不断减小，已从继电器过渡到半导体开关，占位更小，抗噪能力更强，电磁干扰更低。
上桥SmartFET已成为汽车市场的主流SmartFET配置，取代了通常更简单的下桥SmartFET。图1所示是上桥与下桥SmartFET配置的示例。上桥SmartFET的负载始终接地，通过切换连接到电源，而下桥SmartFET的负载始终连接到电源，通过切换接地。
SmartFET通常安装在控制单元或ECU内。负载线是连接负载和ECU上针式连接器的电缆长度。根据负载类型及其在车辆中的位置，该负载线可能很长，从而增加了底盘接地短路的可能性，这可能对下桥SmartFET配置中的负载造成严重压力。
下面的图2显示了安森美的NCV84xxx上桥SmartFET系列的顶层框图和引脚布局。请注意，上桥SmartFET实际上是个NMOS FET，由一个稳压电荷泵，将栅极电压拉高到足以驱动负载的水平。
输入(IN)引脚是个逻辑电平引脚，用于打开和关断控制逻辑/电荷泵以使FET工作。电流检测使能(CS_EN)引脚启用和禁用电流检测功能。电流检测(CS)引脚将一定比例的负载电流检测反馈到微控制器以实时反馈。该引脚是多路复用的；它报告很容易与正常工作区分开来的模拟故障事件，从而使用户能实时检测输出电流或故障情况。电压(VD)引脚直接连接到电池或电源，OUT引脚连接到负载。最后，接地(GND)引脚只是器件的GND。
NCV84xxx SmartFET系列器件提供以下保护功能：
过压保护保护整个器件，在电压&gt;41 V时，箝制VD-GND。
欠压保护，在电池电压低的情况下，关断器件并等待电池电压升高到足以使稳压电荷泵工作以正常运行 FET。
限电流(参见下面的图3)在发生短路或浪涌事件时限制电流以防止损坏。电流将一直受到限制，直到器件的内部芯片温度超过过温点，并且会自行关断以提供保护，直到它充分冷却为止。此功能非常适合驱动需要高初始浪涌电流的灯泡负载，并且还限制了高功率和温度波动对芯片的应力量。
具有自动重启功能的过温和电源保护防止器件因高功耗和过高的环境温度升高而过热。如果激活过温保护，器件将自行关断，直到它充分冷却并自动重试，假设输入为“高”。
关机状态开路负载检测在输入“高”之前提醒微控制器，与负载的连接已在关机状态下丢失。
电感式负载开关的输出钳位，在电感放电期间，输出钳位将安全地导通FET以处理电感放电电流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7a78c6f1ec7f2e3df6d51fa1e143a5a/" rel="bookmark">
			Hive参数与性能调优参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. SQL语句优化
1. union all
2. distinct
2. 数据格式优化 3. 小文件过多优化
4. 并行执行优化
5. 数据倾斜优化
6. Limit 限制调整优化
7. JOIN优化
8. 谓词下推优化
最后
1. SQL语句优化 1. union all insert into table stu partition(tp) select s_age,max(s_birth) stat,'max' tp from stu_ori group by s_age union all insert into table stu partition(tp) select s_age,min(s_birth) stat,'min' tp from stu_ori group by s_age; 我们简单分析上面的SQl语句，就是将每个年龄的最大和最小的生日获取出来放到同一张表中，union all 前后的两个语句都是对同一张表按照s_age进行分组，然后分别取最大值和最小值。对同一张表相同的字段进行两次分组，这造成了极大浪费，我们能不能改造下呢，当然是可以的，为大家介绍一个语法：from ... insert into ... ，这个语法将from前置，作用就是使用一张表，可以进行多次插入操作：
--开启动态分区 set hive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7a78c6f1ec7f2e3df6d51fa1e143a5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bedd0d0f731c22a26c856b651c994da/" rel="bookmark">
			第五单元 用python学习微积分（三十三）反常积分（下）-- 无穷级数和收敛判定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-无穷级数和收敛判定-网易公开课
Bullseye：第一单元 用python学习微积分（一） 安装开发环境Anaconda 和 导数（上）- 1/x的导数
Bullseye：第五单元 用python学习微积分（三十二）无穷的处理--不定式（下）和反常积分
芝诺悖论_百度百科
一、第二种类型的反常积分
1、定义
如果极限存在就是收敛的否则就是不收敛的，
2、例1
积分是收敛的
import numpy as np from sympy import * import matplotlib.pyplot as plt figure, ax= plt.subplots( 1 ) ax.set_aspect( 1 ) def DrawXY1(xFrom,xTo,steps,expr,color,label,plt, arrow =False): yarr = [] xarr = np.linspace(xFrom ,xTo, steps) for xval in xarr: #print(expr.subs(x,xval), xval) yval = expr.subs(x,xval) yarr.append(yval) y_nparr = np.array(yarr) x_nparr = np.array(xarr) length = len (xarr) plt.plot(x_nparr, y_nparr, c=color, label=label) if(arrow and steps &gt; 2): plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bedd0d0f731c22a26c856b651c994da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275978b1e19bd6329c731c5ef6ece198/" rel="bookmark">
			元素操作及节点操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
元素操作
更改标签内容
更改元素属性内容
更改元素标签样式
节点操作
元素操作 更改标签内容 方1：自定义变量名 . innerText = ' 内容 ' ;
方2：自定义变量名 . innerHTML = ' 内容 ' ; （常用）
更改元素属性内容 1.图片类
img . src / img . title / img . alt = ' 内容 ' ;
2.表单元素类
① input . value / input . placeholder = ' 内容 ' ;
② input . type = ' 各种类型框 ' ;
③ input . checked / input .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/275978b1e19bd6329c731c5ef6ece198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f4dfd5a7ee6dfcb00915f34f1a034b/" rel="bookmark">
			Android Studio 常用快捷键整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 调换格式 Ctrl + D → 复制行
alt + shift + ↑ → 移动到上一行
alt + shift + ↓ → 移动到下一行
Ctrl + R → 查找后替换
Ctrl + G → 快速定位行
Ctrl + Alt + L → 对当前类的所有代码进行格式化
Ctrl + / → 注释
alt + ← → 返回上一步操作的地方
二 快速出代码 shift + ' → 提示输入的参数类型
alt +enter → (选中单词)快捷提示 添加方法,导入类啊
ctrl + 空格 → 补全
Ctrl + J → 弹出快捷代码提示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f4dfd5a7ee6dfcb00915f34f1a034b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a05d6078bb092f03cb8136dac627b1d/" rel="bookmark">
			stm32标准库串口输出乱码情况解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先检查波特率，查看自己串口设定的波特率和串口助手波特率是否匹配 我的开发板为stm32f407vet6，一这块开发板为例 这里我设置的波特率为9600，与串口助手波特率一致 2.开发板晶振频率和标准库默认频率不一致 如果第一个问题没有解决，应该就是第二个问题了 首先确定自己开发板的晶振频率，以我为例 可以明显看到，晶振为8M （1）首先更改stm32f4xx.h中，其他解决办法中在第120行这个位置添加一个宏定义 但是我没有这步更改只有后面的更改就已经不会输出乱码，如果后面的几步更改后没有用可以考虑这个 （2）查看system_stm32f4xx.c中的PLL_M的值，大概在320行左右 把这个值切换到8就行 但是同样，我的不更改这个只更改第三个好像就可以，如果第三个更改了也不行，就返回来也更改这些 （3）查看stm32f4xx_usart.c中大概327和332行 把integerdivider也就是整数分频器，中的25改成8，我的是这两行的两个都改 如果这四个方法还不行的话，有可能是字符格式的问题，可以查找其他文章 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8d351930ab2c66735db1391d0f6b1a/" rel="bookmark">
			Python实现文字转图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、需求二、实现文字转单个图片代码三、实现文字转配对图片代码 一、需求 目前想要将输入的文字，转为指定风格的图片，比如宋体、草体
二、实现文字转单个图片代码 import os import pdb import PIL import numpy as np from PIL import Image, ImageFont from PIL import ImageDraw import scipy.misc as misc CANVAS_SIZE = 256 # CANVAS_SIZE = 224 # CHAR_SIZE = 200 CHAR_SIZE = 220 EMBEDDING_DIM = 128 X_OFFSET = 20 Y_OFFSET = 20 def _draw_single_char(font, ch, width, height): img = Image.new("RGB", (width, height), (255,255,255)) draw = ImageDraw.Draw(img) draw.text((0, 0), ch, fill=0, font=font) # 这里的设置是为了和原始的训练集参数设置一致 # draw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8d351930ab2c66735db1391d0f6b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bfd42176b102e7b0244751ca1633d06/" rel="bookmark">
			多传感器融合之雷达图像数据集自动生成 - 20220613
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Automatic Radar-Camera Dataset Generation for Sensor-Fusion Applications1. Radar Camera Co-Calibration2. ROS pipeline3.Sensor-Fusion Data-Set Generation4. Radar-Only Data-Set Generation5. Sensor Fusion Feature Representation6. 实验结果 Automatic Radar-Camera Dataset Generation for Sensor-Fusion Applications Sengupta A, Yoshizawa A, Cao S. Automatic Radar-Camera Dataset Generation for Sensor-Fusion Applications[J]. IEEE Robotics and Automation Letters (二区, IF:3.741), 2022.
Code : github.com/radar-lab/autolabelling_radar
本文提出了一种新的多传感器数据集生成方法，利用基于YOLOv3的高精度目标检测从相机自动标记点云数据从一个共同校准的雷达传感器，以生成标记的雷达图像和雷达数据集。
首先校准视觉和雷达传感器，并获得一个雷达到相机的变换矩阵。采用基于密度的聚类方法将采集到的雷达回波信号被不同的目标分离，并利用变换矩阵将聚类质心投影到相机图像上。然后使用匈牙利算法将雷达聚类质心与YOLOv3生成的目标框质心关联起来，并使用预测类进行标记。 典型的基于传感器融合的目标识别方案包括4个阶段，即 (i)数据采集和预处理，(ii)传感器之间的协同校准和关联，(iii)传感器融合特征表示(SFFR)，然后是(iv)分类网络，如图1所示。
首先，同时采集摄像机和毫米波雷达的检测结果，进行预处理，利用协同标定变换矩阵将雷达检测簇投影到摄像机图像平面上。从图像数据中检测到的对象通过边界框进行本地化，边界框内的区域称为感兴趣区域(ROI)。ROI与这些区域内的雷达集群相关联。然后，将每个ROI-Cluster对进行单独的特征提取网络，并将转换后的特征表示从单个传感器的数据进行融合/拼接，得到SFFR。然后，该SFFR被置于全连接多层感知器(MLP)中，直到分类输出层。此外，“回退”网络也必须能够使用传感器的数据单独识别/分类对象，特别是在有不相关的ROI/集群的情况下。这是为了解释由于视场受限、电子故障、遮挡或光照不足导致的单个传感器故障，但仍然能够识别场景中的目标，尽管其置信值低于基于SFFR的分类。 1. Radar Camera Co-Calibration 使用张氏标定程序获取摄像机的内参数。使用一个边缘尺寸为22.14 mm的9 × 6棋盘格图案作为校准板，并使用张氏方法的两个软件实现，即MA TLAB的相机校准工具箱和ROS相机校准器，来估计USB-8MP相机模块的内在参数(包括径向和切向失真参数)，该模块被放置在一个使用3-D打印框架安装的静态三脚架上，离地面1米高。
数据收集设置:(a)运行Ubuntu 18和ROS Melodic的NVidia Jetson Xavier使用UART通过USB集线器从相机-雷达系统捕获数据;(b)两个雷达安装在3-D打印线性轨道上，使用M3螺栓固定，间隔23厘米;©将两个雷达的数据投影到图象上进行数据关联。YOLO输出的包围盒内的雷达投影决定了共校准精度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bfd42176b102e7b0244751ca1633d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1922bb1a11241b98584b52537c999a46/" rel="bookmark">
			Python实现将多张图片拼接为一张
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、需求二、代码 一、需求 将多个这样的图片进行拼接为一张
拼接效果：
更多照片张数同理
二、代码 import PIL.Image as Image import os IMAGES_PATH = 'img\\test\\' # 图片集地址 IMAGES_FORMAT = ['.png', '.jpg'] # 图片格式 IMAGE_SIZE = 224 # 每张小图片的大小 IMAGE_ROW = 1 # 图片间隔，也就是合并成一张图后，一共有几行 IMAGE_COLUMN = 2 # 图片间隔，也就是合并成一张图后，一共有几列 IMAGE_SAVE_PATH = 'img/to1.jpg' # 图片转换后的地址 # 获取图片集地址下的所有图片名称 image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item] print(image_names) # 简单的对于参数的设定和实际图片集的大小进行数量判断 if len(image_names) != IMAGE_ROW * IMAGE_COLUMN: raise ValueError("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1922bb1a11241b98584b52537c999a46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c059264b9284cc349a74cf6aa2c3b795/" rel="bookmark">
			Android下拉刷新的实现(一) - SwipeRefreshLayout篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android下拉刷新的实现(一) - SwipeRefreshLayout篇 👉关于作者 已经工作三年的95后程序员，坐标上海。平时在公司写Android原生App，业务时间会抽空学习Java后端，目标是成为全栈工程师，志同道合的可以私我聊聊haha。加入CSDN快4年了，看了很多优秀作者的博客收获很多。后面的时间里，我写也会整理总结一些工作中使用到的知识分享出来。我的座右铭：人生在勤，不索何获。大家一起努力加油吧
👉正文部分 Android下拉刷新的实现系列文章准备了两篇，对应SwipeRefreshLayou和PtrFrameLayout。SwipeRefreshLayout作为Android原生的下拉刷新控件，UI效果比较简洁，也比较容易开发，但是实现的效果过于简单，对于提升页面的美观度有着局限性；PtrFrameLayout是一款下拉刷新框架，提供的UI效果比较好，复杂度也会高一点，大家可以按照自己的实际情况来进行选择
1、使用场景 当界面中的数据需要刷新时，通过下拉界面从而触发刷新，刷新开始的同时会去请求数据，等到数据请求结束关掉Loading
2、实现效果 3、gradle引用 implementation "androidx.swiperefreshlayout:swiperefreshlayout:1.0.0" 4、具体使用 4.1、xml布局，将需要更新的内容布局嵌套到SwipeRefreshLayout中 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".swipe_refresh_layout.SwipeRefreshLayoutDemoActivity"&gt; &lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout android:id="@+id/swipe_refresh_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:text="@string/swipe_refresh_layout_demo_activity" android:gravity="center" /&gt; &lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt; &lt;/RelativeLayout&gt; 4.2、代码设置 1、findViewById
SwipeRefreshLayout swipeRefreshLayout = findViewById(R.id.swipe_refresh_layout); 2、Loading的样式设置
//设置进度条的颜色 swipeRefreshLayout.setColorSchemeResources(R.color.green); //设置进度条的背景颜色 swipeRefreshLayout.setProgressBackgroundColorSchemeResource(R.color.d3_bg_gray); 设置后的效果
3、代码中设置监听器，监听到刷新事件后开始请求数据，请求结束后关闭Loading
//设置刷新监听器 swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { //开始网络请求 String url = "..."; final Request request = new Request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c059264b9284cc349a74cf6aa2c3b795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1cde1b0aa7e207e2f6aac89608a51c7/" rel="bookmark">
			RHCE-ansible第二次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、给受管主机部署yum仓库，示例如下：
仓库1 ：
Name: base
​ Description: baseos
​ Base url: https://mirrors.163.com/centos-vault/8.5.2111/BaseOS/x86_64/os/
​ 需要验证软件包 GPG 签名
​ GPG key 在 /etc/pki/rpm-gpg/RPM-GPG-KEY-*
​ 启用此软件仓库
仓库 2：
Name: app
Description: appstream
Base url： https://mirrors.163.com/centos-vault/8.5.2111/AppStream/x86_64/os/
需要验证软件包 GPG 签名
GPG key 在： /etc/pki/rpm-gpg/RPM-GPG-KEY-*
启用此软件仓库
注：检查你自己的linux系统版本，并选择相应版本仓库。
部署成功后在受管主机上安装vsftpd软件包
首先确保该工作路径下存在ansible.conf和inventory文件并且配置正确
然后vim 一个以.yml结尾的文件
这里以1-create-yum.yml为例：
[admin@master test1]$ vim 1-create-yum.yml
然后在文件中编辑如下内容：
代码如下：
--- - name: play1 hosts: all tasks: - name: create base yum_repository: name: base description: baseos baseurl: https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1cde1b0aa7e207e2f6aac89608a51c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6512506c2b9b322ed99202b5c57beb/" rel="bookmark">
			第五单元 用python学习微积分（三十二）无穷的处理--不定式（下）和反常积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-反常积分-网易公开课
Bullseye：第一单元 用python学习微积分（一） 安装开发环境Anaconda 和 导数（上）- 1/x的导数
目录
一、洛必达法则复习
1、无限比无限的情况（ ）
二、反常积分
1、基本概念
2、例1
（1）( k &gt; 0 )
（2） 放射性粒子的平均衰减度（概率相关）
3、例2 一个概率计算中重要的常量
4、例3 1/x的p次幂 （p&gt;0）
（1）临界情况 p=1
（2）
（3）结论：式子 ， 当 时是发散的，而当 p &gt;1 时是收敛的（ ）
5、极限的比较
6、例4
7、例5
8、例2 - 续
一、洛必达法则复习 1、无限比无限的情况（ ） 如果 , , 成立， 则 , 其中 或 是允许的。
可以理解为 ， 函数值排序：
增长： 函数值排序：
减小：
二、反常积分 1、基本概念 如果这个积分极限存在(这个极限有限)，他就是收敛的(converges)，否则就是发散的(diverges)
函数的积分收敛的情况，也就是函数曲线到x轴的面积是有限的，否则这个曲线下的面积就是无限的
​
添加图片注释，不超过 140 字（可选）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f6512506c2b9b322ed99202b5c57beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da0b4d8cef3e3e6d73fba7bba0beb5a/" rel="bookmark">
			sockjs.js?9be2:1603 GET http://192.168.1.7:8080/sockjs-node/info?t=1654959638136 net::ERR_C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方式：
vue项目 报sockjs.js?9be2:1606 GET http://192.168.43.226:8080/sockjs-node/info?t=1584966826465 net::ERR_笑道三千的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91a847175414b6def67228e97684aef/" rel="bookmark">
			Linux 常用命令详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目录管理 处理目录的的常用命令；
ls：列出目录
cd：切换目录
cd..：返回上级目录
cd / :回到根目录
pwd：显示当前目录
mkdir：创建一个新的目录
rmdir：删除一个目录
cp：复制文件或目录
rm：移除目录或文件
mv：移动目录或文件，修改目录或文件的名称
ls目录中还有以下两种用法
-a:显示全部文件，包括隐藏文件（以.开头的文件）
-l:长数据串输出，包含文件的属性与权限等
pwd显示当前所在的目录
如果是链接则显示真实的地址用-p参数
mkdir 创建目录
-m 可以设置访问权限 例如：mkdir -m 777 test 设置访问权限为777 的文件test
-p 可以设置多级目录 例如：mkdir -p test/test1/test2
rmdir 删除目录
-p 删除多级目录：rmdir -p test/test1/test2
cp 复制文件
-a：相当於 -pdr 的意思
-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；
-r：递归持续复制，用於目录的复制行为；(常用)
-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。
-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；
-u：若 destination 比 source 旧才升级 destination ！
例如：复制 root 下的test 到 home文件下 cp /root/test/home
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91a847175414b6def67228e97684aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eae892cc725e1918d66d1961df039a5/" rel="bookmark">
			jQuery_01 快速入门 了解&amp;选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是JQuery? 1.J:javascript 2.Query: 查询
二、它的作用是什么？
三、特点
1.JQuery是JS的类库（封装了很多函数）； 2.市场上有很多封装JS的插件，JQuery只是一个。
四、 如何下载JQuery插件
五、如何导入？
1.内部导入
例 : script标签中 src属性：指定JQuery插件；
2.外部导入：
​ 3.内部式与外部式的区别：
1.外部式：公司使用较多； 2.内部式：学习用； 4.关于版本：
1.开发版本 2.生产版本 3.测试版本
六、JQuery的加载函数
1.JavaScript： window.οnlοad=function(){}; 2.JQuery: $(function(){}); 3.JQuery完整版的加载函数: $(document).ready(function(){}); 4.JQuery点击事件的关键词：click
七、什么是选择器？
答：选择器可以指定网页标签
1.选择器的作用：更加方便的获取元素。 2. JavaQuery其选择器 2.1.ID选择器： 例子：$("#id属性名"); 符号：# （属性：id）; 2.2.类选择器： 例子：$(".类属性名"); 符号：. （属性：class）; 2.3.标签选择器： 例子：$("元素"); 符号：无 （属性：）
2.4.与Javascript不同的地方：
八、JQuery获取value属性的方法：val();
1.如何用jQuery去获取文本框的值?
1.1.JavaScript:document.getElementById().value; 1.2.JQuery:$("选择器").val();
九、JQuery里如何动态设置样式css的? 单个属性和多个属性的区别?
1.css();设置样式
十、其他的选择器：
十一、HTML的转义字符
&gt;:大于 &lt;:小于
十二、表单选择器的使用
1. :input 拿到所有的input属性的标签 2. :text 拿到所有文本框标签 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eae892cc725e1918d66d1961df039a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e0820a8c0178764c459ed936339367/" rel="bookmark">
			Python实现将一张图片裁剪多张
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、需求二、代码 一、需求 需要将一张图片，从中间对半裁剪为两张图片
如：
裁剪为两张：
二、代码 import os from PIL import Image IMAGES_PATH = 'img\\test\\' # 图片集地址 # 支持的格式 IMAGES_FORMAT = ['.png', '.jpg'] # 图片格式 # 获取图片集地址下的所有图片名称 image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item] print(image_names) # 定义图像拼接函数 def image_compose(): # 循环遍历，把每张图片按顺序粘贴到对应位置上 for index in range(0, len(image_names)): img = Image.open(IMAGES_PATH + image_names[index]) # 打开图像 # 截取的位置 box1 = (0, 0, 256, 256) box2 = (256, 0, 512, 256) roi1 = img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58e0820a8c0178764c459ed936339367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c893f24001da90e5df525fd1f97fa47/" rel="bookmark">
			（十八）Flink Table API &amp; SQL 编程指南 Table API 和Datastream API 集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 DataStream 和 Table 之间的转换依赖项和导入配置执行行为datastream APItable API 批处理运行时模式Changelog统一 处理（仅插入）流 (Handling of (Insert-Only) Streams)fromDataStreamcreateTemporaryViewtoDataStream 处理变更日志流fromChangelogStreamtoChangelogStream 将 Table API 管道添加到 DataStream APITypeInformation 和 DataType 之间的映射TypeInformation 到 DataTypeDataType 到 TypeInformation 在定义数据处理管道时，Table API 和 DataStream API 同样重要。
DataStream API 在一个相对较低级别的命令式编程 API 中提供了流处理的原语（即时间、状态和数据流管理）。Table API 抽象了许多内部结构，并提供了结构化和声明性的 API。
两种 API 都可以处理有界和无界流。
处理历史数据时需要管理有界流。无限流发生在可能首先用历史数据初始化的实时处理场景中。
为了高效执行，两个 API 都以优化的批处理执行模式提供处理有界流。但是，由于批处理只是流的一种特殊情况，因此也可以在常规流执行模式下运行有界流的管道。
一个 API 中的管道可以端到端定义，而不依赖于另一个 API。但是，出于各种原因，混合使用这两种 API 可能会很有用：
在 DataStream API 中实现主管道之前，使用表生态系统轻松访问目录或连接到外部系统。在 DataStream API 中实现主管道之前，访问一些用于无状态数据规范化和清理的 SQL 函数。如果 Table API 中不存在更底层的操作（例如自定义计时器处理），请不要切换到 DataStream API。 Flink 提供了特殊的桥接功能，使与 DataStream API 的集成尽可能顺畅。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c893f24001da90e5df525fd1f97fa47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c86b5d0ab68dcce53b23cd9f7c224cd/" rel="bookmark">
			【opencvsharp】斑点检测 条码解码 图像操作 图像旋转/翻转/缩放 透视变换 图像显示控件 demo笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//斑点检测 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using OpenCvSharp; using OpenCvSharp.Blob; namespace KeyboardLabeling { class Program { static void Main(string[] args) { Mat src = new Mat("../../keyboard.png"); Mat bin = new Mat(); Mat binary = new Mat(); src = src.SubMat(new Rect(300, 300, 1000, 1000)); //裁剪图像 Cv2.CvtColor(src, bin, ColorConversionCodes.BGR2GRAY); // gray Cv2.Threshold(bin, binary, 125, 255, ThresholdTypes.BinaryInv); //二值化 Mat result = new Mat(src.Size(), MatType.CV_8UC3); CvBlobs blobs = new CvBlobs(); blobs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c86b5d0ab68dcce53b23cd9f7c224cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4939f41c79868dddfc9009fc95cd845e/" rel="bookmark">
			Android Studio debug方法和Logcat不打印日志问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始以为代码写的不对,后来debug发现走到了打印日志的地方,但是Logcat 就是没有日志,解决方法记录如下:
一 dubug方法 二 Logcat 不打印日志问题 如果 手机、模块名、tag 等都没有问题,但就是没有log ,请重启Android studio重启Android studio重启Android studio 重启就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c040bfc437f24799cbd0401feffdd37e/" rel="bookmark">
			SpringBoot启动过程：SpringApplication及SpringApplicationBuilder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot应用的启动是基于SpringApplication类的，下面一步步地分析。
构造方法及初始化 其构造方法有二，都调用了initialize方法，完成注解源的配置。
public SpringApplication(Object... sources) { initialize(sources); } public SpringApplication(ResourceLoader resourceLoader, Object... sources) { this.resourceLoader = resourceLoader; initialize(sources); } private void initialize(Object[] sources) { if (sources != null &amp;&amp; sources.length &gt; 0) { this.sources.addAll(Arrays.asList(sources)); } this.webEnvironment = deduceWebEnvironment(); setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); } initialize方法首先将注解源设置到成员变量this.sources中，然后deduceWebEnvironment方法中根据类路径是否有javax.servlet.Servlet、org.springframework.web.context.ConfigurableWebApplicationContext这两个类判断是否是web环境this.webEnvironment。利用spring.factories机制机制加载ApplicationContextInitializer和ApplicationListener。然后找到main方法所在类mainApplicationClass。 run方法 run方法是程序运行的主要方法
public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c040bfc437f24799cbd0401feffdd37e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6ebdda502f670cc37096623c6ff11f/" rel="bookmark">
			C# EPPlus按照Excel模板导出Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		甲方给的Excel模板如下：
我们导出的Excel内容如下：
代码中有详细的注释，如下：
/// &lt;summary&gt; /// 导出按钮点击事件 /// &lt;/summary&gt; /// &lt;param name="sender"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; private void btnExport_Click(object sender, EventArgs e) { ExcelPackage.LicenseContext = LicenseContext.NonCommercial; // 声明EPPlus许可 SaveFileDialog saveFileDialog = new SaveFileDialog(); saveFileDialog.Filter = "*.xlsx|*.xlsx"; saveFileDialog.Title = "导出文件"; saveFileDialog.InitialDirectory = "D:\\"; saveFileDialog.FileName = $"ECU检测记录-{DateTime.Now.ToString("yyyyMMddHHmmss")}.xlsx"; DialogResult dialogResult = saveFileDialog.ShowDialog(); if (dialogResult == DialogResult.OK &amp;&amp; !saveFileDialog.FileName.Equals("")) { var fileInfo = new FileInfo(saveFileDialog.FileName); using (var pck = new ExcelPackage(fileInfo)) // 打开Excel文件 { string sheetName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6ebdda502f670cc37096623c6ff11f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75458fa9bde46248eeb0ed856609dcb/" rel="bookmark">
			论文汇报--SIGIR2022--基于用户价格偏好及兴趣偏好的会话推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fc57fc459734abd9aedaa761eff6d2/" rel="bookmark">
			Linux下安装Nginx服务并设置开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装Nginx
二、开机自启动服务配置
一、安装Nginx 系统平台：CentOS Linux release 7.9.2009 (Core) 64位
Nginx安装版本（liunx-64位）：nginx-1.20.2 .tar.gz 安装包下载地址
1、上传安装包
在/data下创建目录：/data/nginx/nginx 并把 nginx-1.20.2 .tar.gz 上传到此目录下
[root@MiWiFi-R3-srv /]# mkdir data
[root@MiWiFi-R3-srv /]# cd /data/
[root@MiWiFi-R3-srv data]# mkdir nginx
[root@MiWiFi-R3-srv data]# mkdir nginx/nginx
[root@MiWiFi-R3-srv data]# cd nginx/nginx
2、安装包解压
[root@MiWiFi-R3-srv nginx]# tar -zxvf nginx-1.20.2.tar.gz
3、进入安装包目录
[root@MiWiFi-R3-srv nginx]# cd nginx-1.20.2
4、编译及安装
查看pre版本及安装路径
[root@MiWiFi-R3-srv /]# pcre-config --version
[root@MiWiFi-R3-srv /]# rpm -ql pcre
配置configure执行配置命令
[root@MiWiFi-R3-srv nginx-1.20.2]# ./configure --prefix=/data/nginx/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/data/pcre/pcre-8.32
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7fc57fc459734abd9aedaa761eff6d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803d2e6f560fc51ff23e646b3a3b053a/" rel="bookmark">
			python--如何进行去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、自定义函数去重二、内置函数去重 一、自定义函数去重 解析思路：
1、确定去重目标
2、给一个空列表去接收去重后的元素
3、遍历需要去重的序列，将重复数据过滤
4、打印去重后的数据
l = [1,1,3,2,2,3,4,2,5] new = [] for i in l: if i not in new: new.append(i) print(new) 输出结果：
[1, 3, 2, 4, 5] 二、内置函数去重 l = [1,1,3,2,2,3,4,2,5] b = list(set(l)) print(b) 输出结果：
[1, 2, 3, 4, 5] 可以看出去重后改变了序列的顺序，所以去重后需要按元素索引进行排序，才会保持序列的原有顺序
代码如下：
l = [1,1,3,2,2,3,4,2,5] a = list(set(l)) a.sort(key=l.index) print(a) 输出结果：
[1, 3, 2, 4, 5] 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/138/">«</a>
	<span class="pagination__item pagination__item--current">139/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/140/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>