<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d031ad49b034f4107b32a181160f91/" rel="bookmark">
			lodash防抖节流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 应用场景： 当用户高频率的触发事件，事件较短，内部出现卡顿现象
解决方法： 防抖节流 防抖节流功作用： 主要目的是为了降低高频事件触发，减少dom操作或请求次数，提升性能
防抖函数debounce 使用的原理：前面所有的触发，是最后一次执行后在规定的时间内触发（只执行一次）
n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时
举例： 假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制
电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖
节流函数throttle 使用原理：少量的触发，在规定的时间内是不会重复触发的，只有超过这个事件才会再次的触发
n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效
举例： 假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制
电梯第一个人进来后，15秒后准时运送一次，这是节流
使用方式： 使用lodash插件，安装lodash插件
npm i lodash
引入
import _ from 'lodash'
节流
this.right=_.throttle(this.right,1000)
防抖
this.left=_.debounce(this.left,1000) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be5e90582280664c0dfce64f87df98b/" rel="bookmark">
			BigDecimal比较大小(compareTo)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		compareTo：用于两个相同数据类型的比较，两个不同类型的数据不能用此方法来比较。
BigDecimal1小于BigDecimal2，返回-1，大于返回1，相等返回0
(String)"a"是ASCII，比较结果是差值（a == 97，c==99）;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e621d64fb346e1e3654ff2b70bb252a8/" rel="bookmark">
			list集合包含某个元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List list;
list.contains(“a”) —&gt;判断list中是否有"a"这个元素
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22bdc7d61f02a4d4dcf9d58935d23475/" rel="bookmark">
			Android中FrameLayout的底部布局被软键盘顶上来问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android Manifest中使用的activity中加上：android:windowSoftInputMode="adjustPan"
对于没有滚动控件的布局来说，采用的是adjustPan方式
对于有滚动控件的布局来说，采用的是adjustResize方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247a797b329bea55e6b7e20fd1fa9471/" rel="bookmark">
			Mac修改hosts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo vi /etc/hosts 输入密码
ESC
:wq! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f395a40f3e51ad86b50025bdbfc695a/" rel="bookmark">
			虚拟机没有IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将虚拟机设置为连接wifi重新启动网路 service network restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3996e980920400816c82b1291fd185c8/" rel="bookmark">
			pywinauto keyborad.send_keys raise RuntimeError(‘SendInput() inserted only ‘&#43;str(num_inserted_events
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pywinauto中keyborad.send_keys()函数是报错：
RuntimeError: SendInput() inserted only 0 out of 2 keyboard events
解决方案：
关闭退出360安全卫士。
成功解决！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb1cf6fda14c5c316b81da2f1fcf020/" rel="bookmark">
			android Leakcanary/Studio Profiler/MAT 处理内存问题(泄漏和Big超大内存对象)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Android Leakcanary 使用 1.1在项目中依赖： 根据项目实际情况，选择对应的版本，因项目中暂时不支持android x，因此这里选择leakcanary 2.2版本。
//放开下边的代码,即可在debug包中使用leakcanary 检测内存泄露 debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.2' 1.2.运行项目查看内存泄漏信息。 在logcat 中，可以查看到泄漏的信息：
2022-08-31 11:14:07.757 32255-10246/com.xxx.miniworld D/LeakCanary: ==================================== //.... 1174715 bytes retained by leaking objects Signature: 4bfb4367c5b0b4b1a7aeb7ff3b45e02cba6a3d87 ┬─── │ GC Root: System class │ ├─ android.net.ConnectivityManager class │ Leaking: NO (a class is never leaking) │ ↓ static ConnectivityManager.sInstance │ ~~~~~~~~~ ├─ android.net.ConnectivityManager instance │ Leaking: UNKNOWN │ ↓ ConnectivityManager.mContext │ ~~~~~~~~ ╰→ org.appplay.minibrowser.BrowserActivity instance ​ Leaking: YES (ObjectWatcher was watching this because org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adb1cf6fda14c5c316b81da2f1fcf020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f7f5510c46d49581d8a549f78ea6fc/" rel="bookmark">
			dayjs-入门及常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dayjs是一个轻量的处理时间和日期的 JavaScript 库
官方github： github.com/iamkun/dayj…
中文使用文档： github.com/iamkun/dayj…
dayjs好处 🕒 和Moment.js有着相同的API和模式
💪 不可变、持久性
🔥 提供链式调用
🌐 国际化标准
📦 超小的压缩体积，仅仅有2kb左右
👫 极大多数的浏览器兼容
dayjs安装 npm install dayjs --save import dayjs from 'dayjs' &lt;script src="https://unpkg.com/dayjs"&gt;&lt;/script&gt; Day.js 的返回值都是新的 Dayjs 对象
dayjs 解析相关的API 直接运行 dayjs()，得到包含当前时间和日期的 Dayjs 对象
dayjs() //返回当前时间 Tue, 28 May 2019 05:57:34 GMT 可以解析传入的一个标准的ISO 8601时间字符串。
dayjs('1995-12-25') //Sun, 24 Dec 1995 16:00:00 GMT 可以解析传入的一个 Javascript Date 对象。
dayjs(new Date(2018, 8, 18)) //Mon, 17 Sep 2018 16:00:00 GMT 可以解析传入的一个 Unix 时间戳 (13 位数字)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f7f5510c46d49581d8a549f78ea6fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4d8a4b25cb4940561f9cac4ebfb5b6/" rel="bookmark">
			java 调用C#语言写的dll文件代码 超详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近在编写项目时候，遇到了java调用C#类库的情况，试了很多种方法，也遇到了很多坑。解决之后写下来。作为记录和分享给有用的朋友们。在这里我用的工具是jni4net-0.8.8.0，Visual Studio2015
一、编写C#类库代码，并生成DLL文件。
1.按如图步骤用Visual Studio(我用的vs2015)新建一个C#的类库项目，项目名称为HelloWorld。
创建C#类库项目步骤
2.重命名类名Hello
3.类库代码
namespace HelloWorld
{
public class Hello
{
public static int display(int a,int b)
{
return a+b;
}
}
}
4.右键项目，生成。编译成dll
二、编写java代码
1.用jni4net工具把dll文件编译；(jni4net工具下载地址：jni4net - Browse Files at SourceForge.net)
文件夹找到jni4net的bin目录，创建cmd命令文件，方便后续使用；
命令：.\proxygen.exe “DLL所在路径” -wd “java项目根路径”
如：.\proxygen.exe “D:\Java\HelloWorld.dll” -wd “E:\Project\Jni4netProject”
执行后java项目的根目录下会多出下图红色框中的文件和一个build.cmd文件
(运行是可能会遇到javac' 不是内部或外部命令,也不是可运行的程序 或批处理文件和'csc' 不是内部或外部命令,也不是可运行的程序 或批处理文件;需要配置JDK环境变量JDK 安装 Java环境变量配置 详细教程_yyongsheng的博客-CSDN博客和Microsoft.NET的环境变量在dos下用csc命令编译，提示“csc不是内部或外部命令,也不是可运行的程序”_yyongsheng的博客-CSDN博客)
​
2.将dll文件打包乘jar包
将命令行切换到java项目的根目录下(和src同级目录)，执行命令build.cmd，java项目根目录下会编译出2个文件分别为HelloWorld.j4n.dll和HelloWorld.j4n.jar,
如下图：
​
3.拷贝文件并添加jar包依赖；
然后将jni4net的lib目录下的jar文件和dll文件copy到java项目的根目录下，将C#项目的HelloWorld.dll的文件也copy到java项目的根目录下， ​
添加依赖的方式有多种(我用的第一种)，如：
1.将HelloWorld.j4n.jar和jni4net.j-0.8.8.0.jar添加到File—Progect Structure --Modules–Depengdenies–
​
2.把jar包放到指定位置，在pom文件中添加依赖，如：
&lt;dependency&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4d8a4b25cb4940561f9cac4ebfb5b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d572b7fbdef593c1ede5282ce684f1/" rel="bookmark">
			Nvidia Jetson TX2入门指南(白话版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近要用到jetson tx2，但之前也完全没有接触过。边用边学，这篇文章就是向新手介绍下jetson tx2刚入手的一些事项(适合纯小白~)。
一、TX2初认识 开发板全称：Nvidia Jetson tx2(本文简称为tx2)
开发板照片：
功能描述：
TX2是英伟达公司主要研发的AI边缘计算设备，功能强大，很适合作为边缘设备的开发平台，可以在上面部署诸如图像处理等等任务。不再赘述，详见官网
详细参数：
二、TX2再认识 tx2有几个特点是需要新手了解的：
1）tx2自带GPU+CPU，内存为8G，存储量为32G
2）tx2外接屏幕只支持HDMI的(网上说VGA转HDMI行，但我实操后发现还是不行)
3）tx2上只有一个USB接口，要接键盘、鼠标等等，需要一个USB-pub
看着开发板却不知道各个部分是干啥的吧~ 详见下图：
两个天线，两个USB(一个正常，一个Micro要转接线)
注：M.2接口是一种新的主机接口方案，可以兼容多种通信协议，如sata、PCIe、USB、HSIC、UART、SMBus等
参考：m.2接口_百度百科 (baidu.com)
对于一个新手来说，第一件事就是找开关(当然，前提是要插电源)。开发板的开关就是那四个红色按钮里面最右边那个(Power Button)，最左边是Reset键。中间两个Force Recover Button和User Defined Buttton我也不知道是啥意思。
三、对TX2动手 tx2中自带ubuntu18.04，此时tx2就是个小白，要想把它变成强大的开发板需要向其中导入各种包(主要是jetpack包)。也就是人们常说的“刷机”。每个tx2第一步都有进行刷机的。刷机的攻略可以参考下面这两个：
刷机教程一
刷机教程2
注：因为版本的不同，软件图形化界面的排布可能不同，但基本操作步骤是类似的。以上两篇刷机教程可以互相印证着看(笔者实测有效)
刷完机发现原来的30G就剩下了10多个G了，说明这个包还是很大滴~
刷完了机来跑两个样例看看是否成功了吧，可以参考这篇博客：NVIDIA Jetson TX2入门傻瓜教程：带你30分钟跑完这几个经典程序
注：该网址的样例笔者都跑了一下，有两个问题需要注意一下：
1）调用板载摄像头的命令是
nvgstcapture-1.0 --prev-res=3 但如果直接调用的话相机界面是会占满整个屏幕的，导致退出不了。所以最好后面加上指定的屏幕分辨率，具体细节可以参考：TX2 学习记录（开启板载/USB摄像头)
2）那个tensorRT的例子运行会报错：
Could not find xx.pgm in data directories: data/mnist data/samples/mnist/ 意思是在当前数据集下没有可对照的图像，去数据集目录下找(/usr/src/tensorrt/data/mnist)没有数据集，但有一个生成数据的py文件(download_pgms.py)，应该运行就会下载数据集。但py文件执行又需要配一些py的库(PIL)什么的，我就没有跑
现在我们已经熟悉了jetson tx2这块板子了，也对这块板子完成了初始化工作。正如上面教程所说的，我们现在需要认真想想我们要拿这块板子干什么啦？
参考：
Jetson TX2介绍 - shinedaisiki - 博客园 (cnblogs.com)
因作者水平有限，如有错误之处，请在下方评论区指出，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de6ef6d256aa6b5c5e4c22c71419eb62/" rel="bookmark">
			【Mixamo】记录mixamo导出动画踩的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明笔者遇到的具体场景：由于在网上下载的模型很多都不一定适用于游戏中（往往会出现面数过多、材质不能定制化修改等问题）都是需要在引擎中再处理的，往往我们下载到本地的zip文件中只包含一个白模和一堆材质。对于笔者这样的初学者来说，很多时候不能遵从次世代美术流程“先做材质然后绑骨”这样的顺序来对角色进行处理，对于这个问题笔者差不多被坑了两三周，现记录一下对于初学者来说正确使用mixamo的方法：
从mixamo中导出动画的正确顺序应该如下：
1、把白模导入到UE中进行减面的操作，然后重新导出（如果模型面数不高，可以直接上传），上传到mixamo中进行绑骨；
2、绑好网站进行解算后，会出现这个界面：
首先记住，千万不要因为好奇而点击任何动作！！！！我们在模型还只是个不会动的模型的时候点击右边界面的橙色按钮“DOWNLOAD"
接下来会弹出下设置，我们在Pose处点击T-pose。
3、然后下载，这样我们就可以看到下载到一个带绑骨的模型。
由于mixamo导出的物体如果导入引擎的话，其所有的材质会变成一样的一个，这样我们就没法把我们的材质分别赋予物体的不同部分了。
4、所以我们需要把这个绑好骨的模型导入3DMax然后对模型的每个部分进行Material ID的制定，这样我们导入引擎后才会有足够多数量的插槽让我们指定材质给不同的部分。
5、指定好我们的材质插槽之后，我们就可以把我们在3DMax的模型（如果骨骼和模型的定向都没有问题的话）导入UE了。
6、现在，我们回到mixamo，然后在界面左侧选择自己想要的动画；
7、如果选择好了一个动画序列，我们则下载这个动画序列：注意，既不要蒙皮，也不要骨骼，只需要序列。可以勾选上是否要创建根节点。
8、然后，把我们下载了的动画序列导入UE中，骨骼选择我们刚刚之前导入到UE中的那个骨骼。
9、最后，利用之前分好的材质插槽来对我们不同部分的UV赋予材质即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef9f43bf4cd88e315c3ce71f4f6fbdc/" rel="bookmark">
			前端 vue antd ui库a-range-picker 时间限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日、昨日、近7天、近30天、自定义 进入页面默认选择今日
自定义：时间选择跨度最多31天，只能选择当前日期之前的半年时间（前端限制）
&lt;template&gt; &lt;div class="select-box"&gt; &lt;div class="flex"&gt; &lt;template v-if="dateString.length &lt;= 1"&gt; &lt;span&gt;统计时间：&lt;/span&gt; &lt;div class="flex-item"&gt; {{ date | formatDateTime }} &lt;/div&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;span&gt;统计时间：&lt;/span&gt; &lt;div v-for="item in dateString" :key="item" class="flex-item"&gt; {{ item | parseTime("{y}-{m}-{d}") }} &lt;/div&gt; &lt;/template&gt; &lt;/div&gt; &lt;div class="select-type"&gt; &lt;div class="time-type" v-for="item of timeType" @click="changeTimeType(item)" :key="item.id" :class="item.id == selectTimeType ? 'time-type-active' : ''"&gt; &lt;div&gt; {{ item.name }} &lt;/div&gt; &lt;/div&gt; &lt;div class="time-type1" :class="selectTimeType == 0 ? 'active' : ''"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ef9f43bf4cd88e315c3ce71f4f6fbdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca05cc917e60b2a94cc55dab39552861/" rel="bookmark">
			Map中的compute、computeIfAbsent和computeIfPresent的使用和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Map中的compute、computeIfAbsent和computeIfPresent的使用和区别 computeIfAbsentcomputeIfPresentcompute完整代码 先准备一个简单的map数据吧
Map&lt;Long, String&gt; testMap = new HashMap&lt;&gt;(); testMap.put(1L, "张三"); testMap.put(2L, "李四"); testMap.put(3L, "王五"); computeIfAbsent 简单来说这个方法就是根据第一个参数key，去查询map，只有当返回值为null即Map中查询不到对应的数据时，向Map中添加一条数据
//测试，没有新增 testMap.computeIfAbsent(4L, aLong -&gt; "computeIfAbsent"); //有返回值，不做任何操作 testMap.computeIfAbsent(3L, aLong -&gt; "computeIfAbsent2"); 操作之前的截图
没有的新增
有的不做操作
computeIfPresent 简单来说这个方法就是根据第一个参数key，去查询map，如果查询到了就更新对应的值，如果查询不到，不做任何操作
//Map中有就更新，没有不做操作 testMap.computeIfPresent(2L, (aLong, s) -&gt; "computeIfPresent"); //Map中没有不做操作 testMap.computeIfPresent(5L, (aLong, s) -&gt; "computeIfPresent2"); 有就更新
没有不做操作
compute 简单来说这个方法就是根据第一个参数key，去查询map，无论是否查询到，都会执行第二个方法体，没有就新增，有就更新值
testMap.compute(1L, (aLong, s) -&gt; "compute"); testMap.compute(6L, (aLong, s) -&gt; "compute2"); 有就更新
没有就新增
完整代码 Map&lt;Long, String&gt; testMap = new HashMap&lt;&gt;(); testMap.put(1L, "张三"); testMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca05cc917e60b2a94cc55dab39552861/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255509e85424ef59160ada7504d004c6/" rel="bookmark">
			《算法导论》学习（五）---- 分治策略(递归)的时间复杂度求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、用主方法求解递归式（1）递归式的一般形式（2）主方法（3）理解主方法 二、利用主方法求解一些实例(1)例子1(2)例子2(3)例子3(4)例子4(5)例子5(6)例子6(7)例子7 总结 前言 求解递归式的时间复杂度是学习算法很重要的一部分
本文主要讲解了利用“主方法”来求解递归式的时间复杂度，并对其进行了一定程度上的逻辑证明
一、用主方法求解递归式 （1）递归式的一般形式 T ( n ) = a T ( n / b ) + f ( n ) ，其中 a ⩾ 1 和 b ⩾ 1 是常数 T(n)=aT(n/b)+f(n)， 其中a\geqslant1和b\geqslant1是常数 T(n)=aT(n/b)+f(n)，其中a⩾1和b⩾1是常数
该一般形式描述的是分治策略算法的运行时间：
该算法将规模为n的问题分解为a个子问题，每个子问题规模为n/b，其中a和b都是常数。a个子问题递归地进行求解，每个花费时间 T ( n / b ) T(n/b) T(n/b)。函数 f ( n ) f(n) f(n)包含了问题分解和子问题解合并的代价。
（2）主方法 令 a ⩾ 1 和 b ⩾ 1 是常数， f ( n ) 是一个函数， T ( n ) 是定义在非负整数上的递归式： 令a\geqslant1和b\geqslant1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式： 令a⩾1和b⩾1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255509e85424ef59160ada7504d004c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cab9bb8ee4754cea9cc0ffd0d6e828/" rel="bookmark">
			.NET Reactor简单使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 .NET Reactor简单使用教程简述下载安装简单使用选择文件，选择加密项 附：加密工具一览 .NET Reactor简单使用教程 简述 .Net Reacto加密工具是一款强大的 .NET 代码保护和授权管理系统，安全可靠、简单易用，主要用来帮助开发人员保护他们的 .NET 软件产品，本文给大家简单介绍C#程序加密工具.Net Reactor教程。
下载安装 下载地址：https://www.eziriz.com/dotnet_reactor.htm
安装完成之后的主界面：
简单使用 选择文件，选择加密项 单击 Main Assembly 右边的 Open，选择要加密的软件文件，exe 或 dll 都可以。勾选 Quick Settings 下要加密的项，每项的含意如下：
NecroBit：把程序集转为非托管代码；
Native Exe File：生成本机 Exe 文件；
Anti ILDASM：反编译；
Obfuscation：混淆；
Create Mapping File：创建地图文件；
Anti Tampering：防篡改；
String Encryption：加密字符；
Compress &amp; Encrypt Resources：压缩并加密资源；
Control FlowObfuscation：混淆控制流。
注：设置可以自己需求勾选，也可以通过菜单栏Protection Presets中选择预设的项
3. 选择Actions菜单中的Protect
软件自动开始加密，加密完成在源文件同目录下生产一个以 ** _Secure**结尾的文件夹，并生成一个加密文件，此文件可以作为发布文件使用。
附：加密工具一览 除.Net Reactor之外，还有一些其他的加密工具，做了一个简单的对比表格，供参考。
加密产品加密内容加密方式Js和其他可授权推荐理由.NET Reactor（v6.7.0.0）.NET Framework、.NET 5.0、.NET Core和ASP.NET Core代码混淆/虚拟化/隐藏方法调用等unity、xamarin、blazor支持可集成VS，覆盖所有.NET开发场景，可以软件/硬件方式加密，支持跨平台VMProtect可执行文件（EXE，SCR），动态链接库（DLL，OCX，BPL）和驱动程序（SYS)软件加壳，虚拟化执行旗舰版支持加壳使用方便，新版本防护能力提升Themida检测/欺骗任何类型的调试器的反调试器技术，支持软件防编译软件加壳不支持软件级别的防护，纯粹防破解、防反编译Code Virtualizer可执行文档(EXEs,system services,DLLs,OCXs,ActiveX编译器混淆不支持软件级别的防护，纯粹防破解、防反编译Zend Guard只加密混淆PHP代码，最后一次升级是针对PHP5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24cab9bb8ee4754cea9cc0ffd0d6e828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c782ae0b337843139c5f75b8a412d7a/" rel="bookmark">
			centos7 二进制安装MySQL8（精简版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载MySQL8安装包 1、wget从官网拉取压缩包：wget https://cdn.mysql.com/archives/mysql-8.0/mysql-8.0.28-1.el7.x86_64.rpm-bundle.tar 2、上传提前下载的安装包到服务器上进行解压安装 上述两种办法取其一即可！！！！！！！！！！！！！！！！！！！！！！！
二、安装MySQL 1、在安装MySQL之前呢，先将系统内自带的mariadb安装包卸载掉，以防数据库冲突！！！ rpm -aq | grep mariadb 强制卸载自带的mariadb rpm -e --nodeps mariadb-libs 2、解压MySQL安装包 解压之后会有很多rpm安装包，只安装我们所需要的即可
rpm -ivh mysql-community-common-8.0.28-1.el7.x86_64.rpm rpm -ivh mysql-community-client-plugins-8.0.28-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-8.0.28-1.el7.x86_64.rpm rpm -ivh mysql-community-client-8.0.28-1.el7.x86_64.rpm rpm -ivh mysql-community-icu-data-files-8.0.28-1.el7.x86_64.rpm rpm -ivh mysql-community-server-8.0.28-1.el7.x86_64.rpm 发现载安装最后一个的时候有报错，是缺少环境导致的。我们先安装一下环境在尝试部署
[root@mysql ~]# rpm -ivh mysql-community-server-8.0.28-1.el7.x86_64.rpm
warning: mysql-community-server-8.0.28-1.el7.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 3a79bd29: NOKEY
error: Failed dependencies:
/usr/bin/perl is needed by mysql-community-server-8.0.28-1.el7.x86_64
net-tools is needed by mysql-community-server-8.0.28-1.el7.x86_64
perl(Getopt::Long) is needed by mysql-community-server-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c782ae0b337843139c5f75b8a412d7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e8a4b08096440544a23b594fb19dab/" rel="bookmark">
			​利用Azure Migrate完成华为云虚拟机迁移至Azure步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目背景 因某某企业内部需求，需将华为云上的Linux机器迁移至Azure。
架构如下： 先决条件 在进行试验之前，请确保满足这些先决条件 在其他云上所需要迁移的虚拟机和安装Azure Migrate设备的虚拟机必须在同一网段，保证相互通信，相互将使用内网传输。以托管复制设备。 此实例必须正在运行 Windows Server 2012 R2 或 Windows Server 2016。 查看设备的硬件、软件和网络要求VM 在端口 HTTPS 443（控制通道业务流程）和 TCP 9443（数据传输）上与复制设备进行入站通信，从而管理复制和传输复制数据。 然后，复制设备会通过端口 HTTPS 443 出站来协调复制数据并将该数据发送到 Azure。 若要配置这些规则，请编辑安全组入站/出站规则，在其中加入相应的端口和源 IP 信息 要求
详细信息
设备
需要一台服务器来运行 Azure Migrate 设备。 服务器应拥有：
- 已安装 Windows Server 2016。
（目前只有 Windows Server 2016 支持设备部署。）
- 16 GB RAM，8 个 vCPU，约 80 GB 磁盘存储
- 静态或动态 IP 地址，可直接访问或通过代理访问 Internet。
- 从设备到所需 URL的出站 Internet 连接。
Windows 服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e8a4b08096440544a23b594fb19dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5bfbdb1a1209a9d66ef565e1dcda7f/" rel="bookmark">
			《算法导论》学习（四）---- 矩阵乘法的Strassen（斯特拉森）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、矩阵乘法的普通递归方法1.C语言代码实现2.算法原理分析3.编程细节（1）用索引的方式进行伪切割（2）编写递归结构 二、矩阵乘法的Strassen（斯特拉森）方法1.C语言代码实现2.算法原理分析3.编程细节（1）分割矩阵 三、算法的时间复杂度分析1.两个方法的时间复杂度2.两个方法时间上的比较 前言 矩阵乘法可以采用分治的策略。
这里提供了两个分治策略的解决 n ∗ n n*n n∗n矩阵之间乘法的算法
1.矩阵乘法的普通递归方法 2.矩阵乘法的Strassen（斯特拉森）方法 但是着两个方法的缺点是只能是两个 n ∗ n n*n n∗n矩阵的乘法，同时n必须为2的幂
之后也对这两个算法进行了时间复杂度上的分析
一、矩阵乘法的普通递归方法 1.C语言代码实现 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; //宏定义改变矩阵的大小 //此处size指的是n*n矩阵的宽度或者长度n //由于Strassen算法本身的局限性 //两个相乘的矩阵只能是n*n,且n只能是2的幂 //即size为1,2,4,8,16... #define size 4 //矩阵的合并 //就是将A11,A12,A21,A22合并为 //	|A11	A12| // |A21	A22| //这样的形式 void Merge_Matrix(int *a,int *b,int *c,int *d,int* c0,int rows) { //rows是子矩阵的宽度，那么合并后矩阵的宽度就是2*rows int i=0;//子矩阵遍历索引 int j=0;//合并矩阵遍历索引，此处先合并A11 for(i=0;i&lt;(rows*rows);i++) { //如果执行了rows次就需要换行，要锁定到合并后矩阵的第二行，所以加上2*rows即可 if((i%rows==0)&amp;&amp;i!=0) { j=(rows*2)*(i/rows);//(i/rows)代表需要换多少行；(rows*2)就是行数 c0[j]=a[i]; j++; } else { c0[j]=a[i]; j++; } } //此处是A12的首元素，令索引等于子矩阵的那个函数 j=rows; for(i=0;i&lt;(rows*rows);i++) { //这里的条件和之前的一样的，其它四部分也是一样的，底层逻辑是一致的 if((i%rows==0)&amp;&amp;i!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f5bfbdb1a1209a9d66ef565e1dcda7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715359894851d030e1584eb4a847f7dc/" rel="bookmark">
			Monaco-Editor配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方地址
https://microsoft.github.io/monaco-editor/api/modules/monaco.editor.html
基础配置 this.editor = monaco.editor.create(this.$refs.editor, { acceptSuggestionOnCommitCharacter: true, // 接受关于提交字符的建议 acceptSuggestionOnEnter: 'on', // 接受输入建议 "on" | "off" | "smart" accessibilityPageSize: 10, // 辅助功能页面大小 Number 说明：控制编辑器中可由屏幕阅读器读出的行数。警告：这对大于默认值的数字具有性能含义。 accessibilitySupport: 'on', // 辅助功能支持 控制编辑器是否应在为屏幕阅读器优化的模式下运行。 autoClosingBrackets: 'always', // 是否自动添加结束括号(包括中括号) "always" | "languageDefined" | "beforeWhitespace" | "never" autoClosingDelete: 'always', // 是否自动删除结束括号(包括中括号) "always" | "never" | "auto" autoClosingOvertype: 'always', // 是否关闭改写 即使用insert模式时是覆盖后面的文字还是不覆盖后面的文字 "always" | "never" | "auto" autoClosingQuotes: 'always', // 是否自动添加结束的单引号 双引号 "always" | "languageDefined" | "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/715359894851d030e1584eb4a847f7dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0f65d21f16f0a0db8d5a718a503caf/" rel="bookmark">
			TCP协议及特性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 TCP确认应答超时重传 连接建立与断开三次挥手四次挥手四种常见状态 效率提升机制滑动窗口流量控制拥塞控制延时应答捎带应答 粘包问题 TCP TCP 协议是一个有连接, 可靠传输, 面向字节流, 全双工的传输层通信协议
相比 UDP , TCP 最大的差异和优势无疑是可靠传输, 而为了保证可靠传输, TCP 协议中有两个核心的机制, 确认应答 和 超时重传
确认应答 发送方在发送完数据之后, 为了确认接收方是否收到了数据, 接收方会返回一个应答报文, 表示自己已经收到了数据。那怎么判断这是个普通的数据报还是一个应答报文呢 ? 这就涉及到了 TCP 报头结构, 如下, TCP 报头中有 6 位比特位, 其中第二个比特位 ACK 就用来表示这是不是应答报文, 如果 ACK 为 1 说明这是个应答报文 (也称为 ACK 报文, 后面统称应答报文为ACK报文), 相反为 0 则不是。
如果发送方一次性发送了多组数据, 怎么判断 ACK 接收了哪组数据呢
如下, TCP 报头中有个32位序号, TCP 会给数据报中数据的每一个字节进行编号, 而由于一个 TCP 数据报只能记录一个序号, 所以这个序号就是字节流的起始序号, 而确认序号就是接收方期望从发送方接收到的下一个字节的序号, 例如, 发送方发送了一个序号为1, 长度为 1000 的数据报, 也就是发送了序号为 1 - 1000 的数据, 接收方期望下次接收到的字节序号为1001, 所以此时确认序号就是 1001, 确认序号就是表明当前序号之前的数据都收到了, 而发送方下次发送的数据也应该从1001开始。需要注意, 确认序号只有当 ACK 为1 的时候有效, 也就是应答报文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd0f65d21f16f0a0db8d5a718a503caf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f5389655a40d93623b225d82911e5a/" rel="bookmark">
			【鸿蒙】鸿蒙App应用-《记账软件》开发步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍 《记账软件》是日常生活中每天都要使用的软件，通过软件来统计和规划每天的收入和支出情况，并根据日，周，月，年的数据进行生成图表，折线图，柱状图等等，并对消费情况进行分析给出合理的规划策略。
实现思路： 创建Java语言的项目，完成欢迎引导页滑动页面创建登录页面，注册页面，找回密码页面创建主界面，包含明细，图表，记账，发现，我的五大模块明细模块：展示每天的收入支出情况，并可以根据月份统计本月，本日的收入支出的总和等功能图表模块：根据收入支出情况生成日，周，月，年的折线图，饼状图，折线图等等，并对各种支出情况分类显示支出金额记账模块：对消费的情况按不同分类进行记账，例如水果，公交，餐饮，工资等等发现模块：这里接入web端的网站展示在移动端中我的模块：对用户个人信息的设置和显示，头像，VIP设置，主题设置，提醒等等功能 2. 搭建HarmonyOS环境 我们首先需要完成HarmonyOS开发环境搭建，可参照如下步骤进行。
安装DevEco Studio，详情请参考下载和安装软件。设置DevEco Studio开发环境，DevEco Studio开发环境依赖于网络环境，需要连接上网络才能确保工具的正常使用，可以根据如下两种情况来配置开发环境： 如果可以直接访问Internet，只需进行下载HarmonyOS SDK操作。如果网络不能直接访问Internet，需要通过代理服务器才可以访问，请参考配置开发环境。 3. 搭建项目开发架构 在鸿蒙系统项目中，一个项目只会存在一个Application类作为管理整个软件的应用程序。因此我们使用该类进行管理所打开的所有Ability页面，在开启一个新的页面，或者关闭一个页面的同时，我们更好的对页面的状态以及生命周期进行监听。代码如下:
package com.example.bookkeepproject; import ohos.aafwk.ability.Ability; import ohos.aafwk.ability.AbilityPackage; import java.util.ArrayList; import java.util.List; /** * 主应用程序类，一个应用只有一个应用程序类 */ public class MyApplication extends AbilityPackage { private static List&lt;Ability&gt; abilities; @Override public void onInitialize() { super.onInitialize(); abilities=new ArrayList&lt;&gt;(); } /** * 将开启的界面添加至界面集合 * @param ability */ public void addAbility(Ability ability) { if (!abilities.contains(ability)) { abilities.add(ability); } } /** * 销毁所有的界面对象 */ public void removeAllAbility() { for (Ability activity : abilities) { activity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8f5389655a40d93623b225d82911e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c55ddf328aba4e34bbac02952a61e0/" rel="bookmark">
			React渲染不出来dom元素，有数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遍历数据使用map来遍历，使用foreac遍历数据就不会显示，
JSX本质是一种语法糖，JSX中的数组会被解析成一个对象
本质上是一个js对象，然后就是map和forEach的区别，forEach对每个元素进行操作，map对每个元素进行操作并且将每个元素的操作结果作为新的数组返回，所以用forEach什么都不会显示，需要用map
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a45f9fe696dc76af1a251640f8c2a9/" rel="bookmark">
			docker高效搭建本地开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景安装docker更新yum源安装Docker所需要的一些工具包建立Docker仓库 (映射仓库地址)安装docker引擎启动docker 常用的docker命令以安装redis为例启动docker查看镜像查看redis版本获取最新的版本redis查看是否下载成功启动redisredis客户端连接redis查看正在运行的容器 RedisDesktopManager连接redis 背景 Docker 是一个用于开发、发布和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分离，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 快速交付、测试和部署代码的方法，可以显着减少编写代码和在生产环境中运行之间的延迟。
安装docker 安装参考官方地址进行安装即可。以centos7为例，使用yum安装。
更新yum源 sudo yum update 安装Docker所需要的一些工具包 sudo yum install -y yum-utils 建立Docker仓库 (映射仓库地址) sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 安装docker引擎 sudo yum install docker-ce docker-ce-cli containerd.io 启动docker sudo systemctl start docker 常用的docker命令 docker attach ##Attach local standard input, output, and error streams to a running container docker build ##Build an image from a Dockerfile docker commit ##Create a new image from a container's changes docker cp ##Copy files/folders between a container and the local filesystem docker create ##Create a new container docker diff ##Inspect changes to files or directories on a container's filesystem docker events ##Get real time events from the server docker exec ##Run a command in a running container docker export ##Export a container's filesystem as a tar archive docker history ##Show the history of an image docker images ##List images docker import ##Import the contents from a tarball to create a filesystem image docker info ##Display system-wide information docker inspect ##Return low-level information on Docker objects docker kill ##Kill one or more running containers docker load ##Load an image from a tar archive or STDIN docker login ##Log in to a Docker registry docker logout ##Log out from a Docker registry docker logs ##Fetch the logs of a container docker pause ##Pause all processes within one or more containers docker port ##List port mappings or a specific mapping for the container docker ps ##List containers docker pull ##Pull an image or a repository from a registry docker push ##Push an image or a repository to a registry docker rename ##Rename a container docker restart ##Restart one or more containers docker rm ##Remove one or more containers docker rmi ##Remove one or more images docker run ##Run a command in a new container docker save ##Save one or more images to a tar archive (streamed to STDOUT by default) docker search ##Search the Docker Hub for images docker start ##Start one or more stopped containers docker stats ##Display a live stream of container(s) resource usage statistics docker stop ##Stop one or more running containers docker tag ##Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE docker top ##Display the running processes of a container docker unpause ##Unpause all processes within one or more containers docker update ##Update configuration of one or more containers docker version ##Show the Docker version information docker wait ##Block until one or more containers stop, then print their exit codes 以安装redis为例 启动docker #启动docker sudo systemctl start docker 查看镜像 #查看镜像 docker images 查看redis版本 #查看软件的版本 $ docker search redis 获取最新的版本redis #获取最新的版本 docker pull redis:latest 查看是否下载成功 docker images 启动redis #启动redis docker run -itd --name redis -p 6379:6379 redis redis客户端连接redis #redis客户端连接redis docker exec -it redis /bin/bash 到此为止已经创建成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27a45f9fe696dc76af1a251640f8c2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96f00da63228412064a3f38e52fb8d7/" rel="bookmark">
			常用的Java开发工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：轮子。
如果在我们的日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升我们的开发效率。
今天我决定把一些压箱底的小工具，分享给大家，希望对你有所帮助。
本文会分享17个我们日常工作中一定会用得到的小工具，主要内容如下：
1. Collections 首先出场的是java.util包下的Collections类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。
1.1 排序 在工作中经常有对集合排序的需求。
看看使用Collections工具是如何实现升序和降序的：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Collections.sort(list);//升序 System.out.println(list); Collections.reverse(list);//降序 System.out.println(list); 执行结果：
[1, 2, 3] [3, 2, 1] 1.2 获取最大或最小值 有时候需要找出集合中的最大值或者最小值，这时可以使用Collections的max和min方法。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Integer max = Collections.max(list);//获取最大值 Integer min = Collections.min(list);//获取最小值 System.out.println(max); System.out.println(min); 执行结果：
3 1 1.3 转换线程安全集合 我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。
换句话说，这些集合在多线程的环境中，添加数据会出现异常。
这时，可以用Collections的synchronizedxxx方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); List&lt;Integer&gt; integers = Collections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e96f00da63228412064a3f38e52fb8d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b342950f794fcefbecff78e86d954946/" rel="bookmark">
			[VUE]报错: Invalid prop: type check failed for prop “value“. Expected String, Number, got Array found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制台报错：[Vue warn]: Invalid prop: type check failed for prop "value". Expected String, Number, got Array found in。
错误翻译：属性无效：属性“值”的类型检查失败。应为字符串，数字，在中找到了数组。
查找了报错相关文件，最终查出了问题所在，将数据类型写成了数组型。
将改为就可以解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60df1a75c7b4a5624908ad73002cd43a/" rel="bookmark">
			linux创建文件夹命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以使用mkdir命令在 Linux 或类似 Unix 的操作系统中创建新目录或文件夹。本文将介绍如何在 Linux 或 Unix 系统中创建文件夹（也称为“目录”）。
操作步骤如下：1.在 Linux 中打开终端应用程序。2.输入mkdir命令。3.输入文件夹名称。
具体的语法如下图所示：
mkdir folder mkdir [option] folderName mkdir directory 知道了最基本的语法，那么我们就上机实践一下。
首先我们打开中断后，在终端页面输入mkdir foo。
接着使用ls命令，我们可以查看是否创建成功。
可以看到，文件夹被成功创建。最基本的创建方法知道了，那么就可以接着往下进行，大家注意到上面第二行公式有一个[option]，我们开源通过此命令提供或传递了不同的选项，比如：
-m：设置文件夹的权限级别。默认情况下，如果未指定权限，它将采用其父级的相同权限。
-p：它将从父路径创建目录结构。
-v：它将打印显式创建的目录。
-Z：默认情况下，它将设置 SELinux 安全性。
连续文件夹创建
同样，linux也可以连续创建文件夹，比如下图所示：
可以看到我们同时创建了三个不同的文件夹。
结论 要在Linux中创建一个文件夹，我们可以在Linux服务器中使用“mkdir”命令行。此命令还有助于同时创建多个目录，甚至授予文件夹的权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3fdf2d8ad087f721e4cfd0e8e5b825/" rel="bookmark">
			分支与循环结构测试题(无答案版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 python基础知识之分支与循环结构练习题一、基础题：二、进阶题三、高阶地狱题 python基础知识之分支与循环结构练习题 一、基础题： 分别用单分支结构和多分支结构实现判断一个年份是否是闰年。
判断一个年份是不是闰年的条件：
能被400整除的年份是闰年，否则是平年。 能被4整除，并且不能被100整除的年份是闰年，否则是平年。
写出判断⼀个数是否能够被2或者5整除，但是不能同时被2或者5整除的条件语句， 并且打印对应。
判断解决问题是需要单分支还是多分支变式1：判断⼀个数是否能同时被2和5整除的条件语句, 并且打印对应的结果。 假设今天的上课时间为15678秒，编程计算今天上课时间是多少⼩时，多少分钟，多少秒；以‘XX时XX分XX秒’的⽅式表示出来。
例如：100秒表示成**0时1分40秒**时间取余，先保留小时，剩下的先分配分钟，最后为秒。 定义两个变量保存⼀个⼈的身⾼和体重，编程实现判断这个⼈的身材是否正常!输出格式：是否正常：True / False
公式：体重(kg) / (身⾼(m)的平⽅值) 在18.5 ~ 24.9之间属于正常。 摄氏度和华氏度转换。
C = (F - 32) / 1.8判断条件：单位 使用循环语句输出0~100以内所有3的倍数。
适用两种不同的循环语句作答考虑还有没有其它更简单的解法 有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？
判断需要哪一种循环语句来做 一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？
高空抛物问题 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。(斐波那契数列变式)
求1+2!+3!+…+20!的和。(阶乘求和)
使用两种方法解决问题 求100之内的素数。
2是最小的素数素数是除了 统计 1 到 100 之和。
使用两种方式解法 求0—7所能组成的奇数个数。
用户输入一个4位的整数，如果是回文数显示True，如果不是回文数显示False。
回文数，就是反过来的数字和正着的数字是相同的，如1221，倒过来的数还是1221，这就是一个回文数，1234倒过来是4321，不相等，就不是回文数。 使用循环语句打印星型直角三角形。
二、进阶题 计算一段分段函数的值
x (x&lt;1) y = 2x-1 (1&lt;=x&lt;10) 3x-11 (x&gt;=10) 输入任意一个正整数，求他是几位数？
世界最高山峰是珠穆朗玛峰（8844.43米=8844430毫米），假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度？
打印所有的水仙花数
所谓水仙花数是指一个三位数，其各位数字⽴方和等于该数本身。例如:153是⼀个⽔仙花数,因为 1³ + 5³ + 3³ 等于 153。 斐波那契的兔子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce3fdf2d8ad087f721e4cfd0e8e5b825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4eec6b7e87118c89f06f61979ac3d4d/" rel="bookmark">
			傅里叶变换与Matlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		傅里叶变换与Matlab 文章目录 傅里叶变换与Matlab前言一、背景二、原理二、Matlab演示二、问题分析1.单边谱和双边谱1.变换后的频域坐标讨论 三、总结 前言 很多初学者学习了傅里叶变换之后，只是对其公式死记硬背，从而达到做题的目的，但并不理解其原理，对于很多时频分析问题的理解不够透彻。之前自己也是如此，在经过深入学习之后，对变换公式的的本质进行探讨，理解变换的原理及意义所在，同时将傅里叶变换和时频分析结合起来，运用理论和实际相结合的方式，形成一个较为系统的概念，可以从而这个系统从而引伸到其他方面，也加深自己的理解。
同时，将对在Matlab中进行FFT变换进行简要分析，解决一些相关问题，加深理解。
本文采用正弦信号作为FFT变换演示。如有不足之处，希望大家指出。
一、背景 1、如果大家已经学习了傅里叶变换，那么大家肯定也从老师或者相关书籍了解到了它对重要性。在信号分析领域，它的重要性就类比于正余弦信号在数学中重要性。但是如果只是经过初始的学习，不能够将所学串联起来，很难建立一个系统的概念。
2、在使用Matlab中的FFT变换进行信号的频域分析，但是对FFT变换Matlab代码中的一些基本构成却不是很明白。
二、原理 傅里叶告诉我们，现实中的所有信号波形都可以视为一系列正弦信号的叠加。而傅里叶变换则是将原始波形分解为一系列的正弦频率。
傅里叶变换：
连续时间傅里叶变换： F ( j w ) = ∫ − ∞ + ∞ x ( t ) e − j w t d t F(jw) = \int_{-\infty}^{+\infty}x(t)e^{-jwt}dt F(jw)=∫−∞+∞​x(t)e−jwtdt
离散时间傅里叶变换： X ( e j w ) = ∑ i = − ∞ + ∞ x [ n ] e − j w n X(e^{jw})=\sum_{i=-\infty}^{+\infty}x[n]e^{-jwn} X(ejw)=i=−∞∑+∞​x[n]e−jwn
根据欧拉公式： e j θ = c o s ( θ ) + j s i n ( θ ) e^{j\theta}=cos(\theta)+jsin(\theta) ejθ=cos(θ)+jsin(θ)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4eec6b7e87118c89f06f61979ac3d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5196d5412597ad2510ae8dd7e4f98b91/" rel="bookmark">
			wangEditor 粘贴从 word 复制的带图片内容的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么要写这篇文章基于 Layui 本地安装 wangEditor 最新版本下载 JS 和 CSS 文件在 Layui 中创建 wangEditor wangEditor 实现 word 带图片格式内容粘贴场景描述分析思路关键点：图片如何粘贴最终实现代码（因为仅涉及 JS 代码，所以只提供 JS 代码） 总结 为什么要写这篇文章 首先源自于实际项目的客户需求，真实且刚需。本人在网上查找了很多相关资料，也对比和参考了其他类似的文本编辑器，才实现到本文实现的效果。提前声明，本文没有做到百分百粘贴前后同样的效果，介意者慎入！！以免浪费您的宝贵时间。基于 wangEditor 免费开源的前提下实现，没有任何需要付费或使用限制。出于整理收藏、个人积累，分享出来，抛砖引玉。 基于 Layui 本地安装 wangEditor 最新版本 不建议使用官网的 CDN，亲测不是很稳定。官网安装文档
下载 JS 和 CSS 文件 在任意位置新建一个 test1 文件夹，打开控制台，目录定位到该文件夹，执行 npm install @wangeditor/editor 或 yarn add @wangeditor/editor;安装完成，打开 node_modules/@wangeditor/editor/dist 文件夹，即可找到 JS CSS 文件： index.jscss/style.css 把上面两个文件拷贝到你的项目中。 在 Layui 中创建 wangEditor 新建一个引入 Layui 的 HTML 文档 &lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5196d5412597ad2510ae8dd7e4f98b91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e0d8e015ecfc26bae9a9de9b2d456d/" rel="bookmark">
			Python多线程QThread的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用pyQt5开发GUI界面是，我们通常会使用到多线程，一般采用pyQt5自带的QThread模块。
from PyQt5.QtCore import QThread, pyqtSignal # 创建线程1的类 class ThreadOne(QThread): trigger = pyqtSignal(data_type) # 此处输入待传送数据类型 def __init__(self): super().__init__() def run(self): # 该线程要干嘛 self.trigger.emit(data) # 传输数据data # data处理函数（一般在另一个线程中） def receive_data(data): # 怎么处理data # 线程1实例化 threadone = ThreadOne() # 设定线程1传出数据data的接收函数receive threadone.trigger.connect(receive_data) # 开启线程1 threadone.start() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c201abac1adc88701ee354738271d3a/" rel="bookmark">
			【小案例】字符串转换为数字数据类型的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;script&gt; var string="88.96"; var num=string*10; console.log(string,num,typeof num); &lt;/script&gt; //第一种方法就是用关键字强式转换 //var string="88.96"; var num=Number(string); //第二种方法就是用转换函数进行转换 //var string="88.96";var num=parseInt(string);parseFloat、Mash.sin,Mash.round,Mash.random,Mash.floor //第三种方法就是用算数运算进行隐式转换 //var string="88.96";var num=string-10; 加号除外，减号，除号，乘号，取余 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917267672af61e8f73d1c7b31f33cc44/" rel="bookmark">
			cks--最小化IAM角色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fc892867ff338d61d6f30347a4c364/" rel="bookmark">
			海康工业相机连续存图、录像功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康工业相机连续存图功能介绍 1.MVS连续存图功能基本使用方法2.抓图测试与实际问题分析总结 3. SDK代码开发关键接口介绍 在使用工业相机做日常的数据采集，分析过程中，存图、录像功能必不可少，但是在使用该功能中，会出现丢帧、少图等现象，本文简单介绍下存图、录像使用过程中的技术瓶颈与解决方法，本文以介绍连续抓图为主，录像功能原理基本一致； 1.MVS连续存图功能基本使用方法 i. MVS通用设置中，设置图像路径、存图格式
图1：MVS中设置存储路径
图2：MVS中设置图片格式 ii. MVS开启连续抓图功能后，开始取流存图
图3：MVS中设置图片格式 图4：MVS中设置图片格式 2.抓图测试与实际问题分析 a) 相机参数
MV-CA050-20UM相机，图像分辨率为2048*2048，黑白mono8图像，存图格式为bmp
采集帧率90fps，使用触发模式，单次触发，采集1023张图片
b) 测试结果：
图4：MVS抓图结果
图5：本地存图结果 预计采集1023张图片，实际抓图398张图片，丢帧帧数625帧，采集图像数1023张
c) 原因分析
在抓图过程中，缓存使用率会上升，那么，先增加缓存大小，在通用设置里面，设置缓存大小
图6：存图缓存节点设置 存图缓存节点设置到100后，再次测试
图7： MVS抓图结果 预计采集1023张图片，实际抓图475张图片，丢帧帧数546帧，采集图像数1021张
继续增大缓存节点，对比不同缓存节点，对抓图数量的影响，如下表
取流缓存节点 录像缓存节点 采集图像数 存图图像数 丢帧图像数
取流缓存节点录像缓存节点采集图像数存图图像数丢帧图像数2210233986252100102147554625121008889119280010221022030800102310230 从结果来看，将缓存节点设置的足够大，能够满足一定时刻的抓图需求
但是也存在两个问题：
1.当缓存节点继续加大时，计算机内存占用很大（3.28G上升到6.5G）MVS会提示报错，由此可见，缓存不可无限加大
图8：存图缓存节点设置报错 2.图像在缓存里面，采集、存储耗时长，采集1024张图片，只需要11s左右，而完成存储需要30s以上
d) 验证不同硬盘写入速度对图片保存的影响
取流缓存节点录像缓存节点采集图像数存图图像数丢帧图像数22102339862521001021475546 当设置录像缓存节点为100时，存图数量比节点1时，增加了76张
那么当缓存节点小时，因素是什么?
我们使用CrystalDiskMark8，来测试硬盘读写速度，结果如下：
图9：机械硬盘读写速度 硬盘写入速度为93.53M，而一张图像2048*2048，黑白mono8的bmp图像大小为4MB
93.53M的写入速度，支持101.71/4=23.38，23.38张图片同时写入，而相机采集帧率为90fps，
当写入速度，低于采集速度时，就会产生大量的丢帧
那么换用ssd固态硬盘，来提高硬盘写入速度
图10：固态硬盘读写速度 数据来看，这块SSD有点拉跨 那么重复测试结果如下：
取流缓存节点录像缓存节点采集图像数存图图像数丢帧图像数2210235684552100101652249425121014794220305121023910113 从结果来看，
提高硬盘读写速度，能够保存到更多的图片，但是还是会存在丢帧，需要配合缓存节点使用，才能保证不丢帧
SSD写速度达到了123.10M，理论上能够存储30.75张图片，但是相较于相机90fps的帧率，还是远远不够的
注意：这里有个误区，正常的SSD速度，一般在300、500MB/s,而本文中使用的ssd仅有123MB/s,原因在于工具中的参数，测试文件大小为16MB，而硬盘的读写速度与文件大小息息相关，而工业相机的图像大小通常在几百k~20M不等，因此，硬盘读写速度，一般都是低于理论值的；
图11：CrystalDiskMark工具参数介绍 如果要继续提升硬盘读写速度，那么就要考虑更高速的硬盘方案
PCIe 5.0 SSD 读取速度可达 10GB / sRAID方案（RAID磁盘阵列（Redundant Array of Independent Disks）通过同时使用多个磁盘，提高了传输速率。RAID通过在多个磁盘上同时存储和读取数据来大幅提高存储系统的数据吞吐量，理论上读写速度是单片硬盘的N倍） e) 验证不同图片格式对图片保存的影响
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13fc892867ff338d61d6f30347a4c364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53d5cb62268309156a8a5d9735df56ff/" rel="bookmark">
			.NET/C# 生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，在本章是如何通过.net/C#来生成二维码首先大家还是需要仔细阅读这篇文档有小细节就需要注意大家需要生成一些类，把我的方法复制进去，如果不想添加类的话，大家需要再主代码上更改引用信息找到我们所添加的方法不适用于零基础的朋友，适用于有点经验的懂一点代码的就行 1、首先我们新建一个自己的项目.net core 或其他项目新建好后新建一个控制器我们需要在里面写自己的代码，在控制器里面生成一个index页面如下是我的index页面。 上方是我的前台页面，里面主要的就是那个按钮，我呢是通过这个按钮把我的一张图片做成了二维码的内容，大家可以把自己想变成二维码的内容弄进去，这里我只弄功能。
上面那个是二维码结构图片
2、前台页面的代码是这样的，大家肯定会和我的不一样，也没关系，只要作用是一样的就行，大致就是需要一个生成二维码的按钮和点击后弹出二维码。前台代码大家尽量别复制，大家按照自己的写就行了。 //一个按钮用来触发 &lt;script type="text/html" id="barList"&gt; &lt;a class="layui-btn layui-btn-xs" lay-event="live"&gt;图片二维码&lt;/a&gt; &lt;/script&gt; //触发后弹出的二维码 &lt;div class="QRCodeDownload" style="display:none;"&gt; &lt;img class="QRCodeImg" id="QRCodeImg" style="display:block;width:250px;height:250px;margin:0 auto;margin-top:20px;" /&gt; &lt;div id="ActivityTitle" style="text-align:center;"&gt;&lt;/div&gt; &lt;div style="display:inline-block;width:160px;margin-left:15px;"&gt;&lt;p style="display:inline-block;"&gt;二维码尺寸为：&lt;/p&gt;&lt;input type="number" min="200" max="2000" class="layui-input" id="slideCon1" value="250" style="width:60px;display:inline-block;"&gt;&lt;/div&gt;&lt;div id="slide1" class="slider1" style="width:60%;display:inline-block;margin-left:10px;"&gt;&lt;/div&gt; &lt;input type="hidden" id="codeContent1" value="250"&gt; @*&lt;input type="text" name="ActivityTitle" id="ActivityTitle" placeholder="" autocomplete="off" class="layui-input" style="width: 460px; margin-left: 15px"&gt;*@ &lt;input type="text" name="Activitylink" id="Activitylink" placeholder="" autocomplete="off" class="layui-input" style="width:460px; margin:10px auto 0;"&gt; &lt;/div&gt; 3、有了HTMl代码肯定也要有ajax请求的方法：主要有一下几个步骤，首先是监听一下页面是否点击了我们的二维码按钮，点击后应该请求的接口是哪个。下面是我的请求方法，大家也是不要复制，按照自己的前端代码写就行，我们主要是实现后台代码。我这个你们复制过去也不管用，所以看看逻辑就行。 //我们不管通过什么办法进行监听都可以我这里用的是表格所以我就监听表格里面的二维码按钮 case 'live': //我这里的这个src是二维码内容大家到时候根据自己的改就行 var src ='' if (data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53d5cb62268309156a8a5d9735df56ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52468a01917c6f515ceadedffa762dd/" rel="bookmark">
			QString转std::string中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QString qstr="qstr"; string str = null; str = qstr.toStdString();//出现中文乱码 //处理方法 str = string(qstr.toLocal8Bit()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52353e0455651d90b86981a4ca5f8a2a/" rel="bookmark">
			windows server处理 CVE-2014-3566漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows server处理 CVE-2014-3566漏洞 漏洞信息漏洞处理工具介绍HTTPS说明协议检测方式下载IISCrypto工具SSLSCAN工具 结束 漏洞信息 未探测到主机有其他网站服务，该漏洞暴露于1433端口；属于信息泄露级别低危漏洞，可依据实际生产环境进行处理。 漏洞处理 禁用服务端浏览器SSL 3.0协议，本文以server 2008 r2为例。
工具介绍 Windows Server查询、启用或禁用TLS,SSL协议工具:IIS Crypto HTTPS说明 SSL/TLS 系列中有五种协议：SSL v2，SSL v3，TLS v1.0，TLS v1.1和TLS v1.2：SSL v2 是不安全的，不能使用。当与 HTTP（POODLE 攻击）一起使用时，SSL v3 是不安全的，当与其他协议一起使用时，SSL v3 是弱的。它也是过时的，不应该被使用。TLS v1.0 也是不应该使用的传统协议，但在实践中通常仍然是必需的。其主要弱点（BEAST）在现代浏览器中得到缓解，但其他问题仍然存在。TLS v1.1 和 v1.2 都没有已知的安全问题，只有 v1.2 提供了现代的加密算法。TLS v1.2 应该是您的主要协议，因为它是唯一提供现代认证加密（也称为 AEAD）的版本。如果您今天不支持 TLS v1.2，则缺乏安全性。 协议检测方式 下载IISCrypto工具 官网：https://www.nartac.com/Products/IISCrypto/下载：https://www.nartac.com/Products/IISCrypto/Download该工具需.net 4.0环境 附下载地址https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=17718
通过查询可知该服务端未启用SSL 3.0协议。 SSLSCAN工具 SSLSCAN也没有探测到SSL 3.0。 结束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a3079e9c51f7a9db20ce8f757744c6/" rel="bookmark">
			天玥运维安全网关（启明星辰堡垒机）无法登录资源主机的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 天玥运维安全网关（启明星辰堡垒机）无法登录资源主机的问题 问题描述解决方案结束 问题描述 用户可正常登录天玥运维安全网关平台，在登录资源主机的时候有报错
解决方案 调出运行，输入gpedit.msc调出组策略；依次点击计算机配置-windows设置-安全设置-安全选项，找到系统加密:将FIPS兼容算法用于加密、哈希和签名；右键属性，禁用该项目，再次测试，即可成功登录
用户登录资源主机后可正常跳转
结束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbce57e97913858a44387eb6f9f8d654/" rel="bookmark">
			Windwos Server 2012 R2 安装LLDP协议驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windwos Server 2012 R2 安装LLDP协议驱动程序 情况说明问题说明安装步骤结束 情况说明 该协议驱动程序在WindowsServer2016及更高版本的Server操系统中均已自动安装。
问题说明 打开网络和共享中心，点击以太网，在弹出的以太网属性窗口，没有找到LLDP协议驱动程序相关项
安装步骤 打开服务器管理仪表盘，点击添加角色功能；在弹出的添加角色和功能向导窗口继续点击下一步；继续点击下一步；继续点击下一步；不许点击添加任何角色，继续点击下一步；在功能界面找到数据中心桥接并勾选，点击下一步；点击安装；进入安装过程，这需要一点时间；功能安装完毕。
功能安装完毕，再次查看网络共享中心中的以太网属性，LLDP协议驱动程序已安装
结束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c58be12f5dfb70565336204211c8df3d/" rel="bookmark">
			KALI LINUX修改root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 KAKI LINUX修改root密码 KALI 简介操作步骤修改完成 KALI 简介 多年以来，Kali从BackTrack继承了默认的root用户策略。作为对Kali工具和策略的评估的一部分，因此Kali 决定对此进行更改，并将Kali移至“传统默认非根用户”模型。 操作步骤 启动Kali Liunx 进入开机启动页面，按键盘e键进入Kali GNU GRUB页面
进入KALI GNU GRUB界面
在Kali GNU GRUB页面，选择linux那一行，将ro 改为 rw 在此行末尾增加 init=/bin/bash 修改完毕以后按Ctrl+X 键进入单用户模式 按Ctrl + C 进入单用户模式命令行界面
执行passwd命令重置root账号密码，请连续输入两次密码～密码是密文的，直接如即可，输入完自己设置的密码以后会提示密码更新成功
重启Kali 到此登陆页面，输入刚才设置的账号密码，回车进行登陆，至此已经使用root账号登陆成功
修改完成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d9a261c3de607bb6983479586115a0/" rel="bookmark">
			前端实现带行号的文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候要实现带有滚动条或者带有行号的文本输入区域，采用css可以很简单的实现。
实现方式一： 使用 CodeMirror 来实现 ：CodeMirror官网
官网实例地址：CodeMirror示例
可以选择不同的示例场景，比如代码折叠、双向文本、自定义滚动条等等
如果你想使用不同的主题请修改下面代码的第10行和第40行，加载你想使用的主题 js 和修改主题名称。
可参考的主题：codemirror主题效果概览
代码 &lt;!DOCTYPE html&gt; &lt;html lang="en-us"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;!--codemirror必须引入的--&gt; &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/codemirror.min.css" rel="stylesheet" /&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/codemirror.min.js"&gt;&lt;/script&gt; &lt;!--引入css文件，用以支持主题--&gt; &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/theme/mdn-like.css" rel="stylesheet" /&gt; &lt;!--对光标所在行和选中区域高亮--&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/addon/selection/active-line.js"&gt;&lt;/script&gt; &lt;!--javascript代码高亮--&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/mode/javascript/javascript.min.js"&gt;&lt;/script&gt; &lt;!--xml代码高亮--&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/mode/xml/xml.min.js"&gt;&lt;/script&gt; &lt;!--java代码高亮--&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/mode/clike/clike.min.js"&gt;&lt;/script&gt; &lt;!--支持代码折叠--&gt; &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/addon/fold/foldgutter.css"/&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/addon/fold/foldcode.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/addon/fold/foldgutter.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/addon/fold/brace-fold.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.3/addon/fold/comment-fold.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body &gt; &lt;div &gt; &lt;textarea class="form-control" id="code" name="code"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;script type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d9a261c3de607bb6983479586115a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83ab92c9a903a992e5a0ed682e1ea33/" rel="bookmark">
			whistle的安装，浏览器和手机的配置以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前提 下载node.js，通过node.js去下载whistle
2、安装whistle 安转完nodejs后，在命令提示符中，使用管理员身份，输入以下命令，安装whistle
npm install -g whistle 执行命令 whistle help 或 w2 help，查看whistle的帮助信息，检查下是否已安装成功，如果能正常输出whistle的帮助信息，表示whistle已安装成功。
启动whistle:
w2 start 停止whistle:
w2 stop 要使用的话得先start哦
3、给浏览器配置安全证书 在常用的浏览器中，习惯用谷歌，以谷歌为例
具体如下图点击，
配置好对应的代理服务器和端口号
代理服务器：127.0.0.1
端口号是8899
并且给浏览器安全证书的认证，这样才能正常抓包
然后就能直接在浏览器中打开该代理服务器
下载安全证书
下载完双击，具体步骤如下：
4、给手机配置安全证书 手机中也需要下载安全证书，才能进行抓包，使用手机直接扫码下载，或者直接将电脑的证书传输给手机，知道存储地址即可
手机需要授权才行，具体手机型号就自行百度，不同手机设置情况不同，
例：本人是小米手机，在设置里面，点击系统安全-》加密与凭证-》从SD卡安装，选择对应的安全证书即可
接下来是代理手机
连接的wifi点进去，将代理模式选为手动
主机名为电脑的IP地址，不知道的可以
win+R,输入cmd,
在输入ipconfig
查考ip地址
端口号为自己设置的8899，即可接收到数据
5、简单的使用 只过滤对应的网址
在settings中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ed25d0d3932aaa1a9432cc2454fe0f/" rel="bookmark">
			JS学习：条件语句--奇偶性判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##JS学习：条件语句–奇偶性判断
判断一个数是奇数还是偶数 题目要求：编写一个程序，获取用户输入的整数，通过程序显示这个数是奇偶性
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;奇数偶数的判断&lt;/title&gt; &lt;script&gt; let num= +prompt("请输入整数") //+prompt转换成字符串 //let num=parseInt(prompt("请输入一个整数")) //验证用户输入是否合法，当是有效数字是才检查奇偶性 //不能使用==或者===来检查一个值是NaN //可以使用isNaN()函数来检查一个值是NaN if (isNaN(num) || num%1!==0){ alert("输入不合法，请输入整数") }else { if( num % 2 === 0 ){ alert(`${num}是偶数！`) //`英语格式的波浪号键位，不是引号建 }else{ alert(`${num}是奇数！`) } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 暂时不知道0这个非奇非偶的，后期在补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee41a12cdde3c2d965e526a3afbaf26f/" rel="bookmark">
			论文阅读 | Bringing a Blurry Frame Alive at High Frame-Rate with an Event Camera
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：这是一篇事件相机面向去糊方向的文章。发表在了CVPR2019 oral，之后也改进出了一篇PAMI。内容主要是对事件相机的成像原理和图片的模糊原理进行建模，整理出公式并给出了优化函数，通过不断调整阈值C似的图像变得锐利清晰。
论文：【here】
代码：code
Bringing a Blurry Frame Alive at High Frame-Rate with an Event Camera 目的 根据事件相机拍到的一张模糊图片（或是低帧率视频）和一系列事件点，还原出高帧率的锐利且清晰的视频。
不同于一些传统方法的去糊工作，即一张模糊图片还原出一张清晰图片。
主要思想 先构建一个潜在帧的概念。
潜在帧即假设可以用事件相机记录下来的高帧率帧，然而事件相机记录的是事件点，理论上我们可以通过事件点还原出每个潜在帧。
假设强度帧intensity frame不是模糊的，我们可以构建f时刻的锐利帧和事件点之间的关系，即我们可以直接用事件积分来表示不同时刻图像之间的残差。
即对应T时刻的图像I_t
I t = I f + E ( t ) = I f + ∫ t f e ( s ) d s . I_t=I_f+ E(t)=I_f+ \int_t^f\ e(s)ds\,. It​=If​+E(t)=If​+∫tf​ e(s)ds.
然而这只是一个理想的情况，因为它只对于边缘锋利的清晰帧可行。
对于模糊帧，我们先要找到模糊帧与锐利帧之间的关系，再根据上式某时刻锐利帧和事件之间的关系，我们即可以恢复出每个时刻的锐利帧。
模糊帧和锐利帧之间的关系如下：
在第f时刻的模糊帧，其实是这一段T时刻的锐利帧的积分取平均（这里假设锐利帧和模糊帧的帧率差距很大）
结合模糊帧和锐利帧之间的关系和锐利帧和事件点的关系，可以构造出一个双积分模型：
外面的积分是模糊帧的积分，里面的积分是事件点叠加的积分。就这样，可以利用已有的一张模糊帧和一系列事件点，生成一系列锐利帧。
优化函数 以上的公式中有一个变量未知，即事件相机出发事件的阈值C。我们可以通过不断调整阈值C，来获得一个最满意的去糊结果。因此，本文还构建了一个优化函数，通过不断调整C，使得公式中的优化损失最小。
优化思想是：用事件积分得到的模型会更不容易受到噪声影响。因此得到两幅图，事件积分的图片和生成的锐利帧，对两幅图取sobel算子得到边缘，边缘应该足够接近。这里的接近程度用互相关表示。
其次，我们也希望生成的锐利帧的噪声小，保持边缘，因此需要惩罚空间波动。
于是最终的优化函数就变成了：
这里作者放了一些中间结果图来阐释优化的作用：
总结 这篇文章作者主要从成像原理的角度对事件相机的两类成像进行了建模，并用Matlab进行了实验，这对很多之后的深度学习方法很有启发，之后的一些卷积神经网络架构即建立在本文的原理上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ded649313d8c19eb2b4546f288f888/" rel="bookmark">
			晶体与晶振知识详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		晶体与晶振知识详解 1. 振荡器 振荡器的作用是产生特定的输出信号，因此也常常被称为信号发生器(signal creator)，振荡器类型繁多。
按照振荡过程是否依赖于外部激励信号的参与，分为它激振荡器和自激振荡器；
按照波形分类，分为正弦波振荡器与非正弦波振荡器；
按照振荡频率分类，分为低频、中频、高频振荡器；
按照振荡器的选频元件分类，则有RC振荡器、LC振荡器、石英晶体振荡器等。
2. 石英（Quartz）与晶片 2.1 石英 石英是一种各向异性的结晶体，其主要成分是二氧化硅SiO2，石英晶体有天然晶体（nature）与人工合成晶体（synthetic）两种。从一块石英上按一定的方位角切下的薄片称为晶片。天然石英晶体的杂质含量和形态等大多不统一，因此电子线路中使用的晶体多是来源于人造石英晶体。
2.2 晶片的压电效应 当在晶片的两面上加交变电压时，晶片会产生的机械变形，而这种振幅较小频率稳定的机械振动又会反过来产生交变电压。当外加交变电压的频率与晶片的固有频率（由晶片的尺寸和形状决定）相等时，机械振动振幅明显加大，这种现象称为压电谐振，压电谐振状态的建立和维持都必须借助于振荡电路才能实现。
2.3 晶片的生产流程 3. 晶体（Crystal，又称晶体谐振器，无源晶振） 晶体是利用了晶片的压电效应制造的，在薄层晶片的两个对应表面上涂敷银层并装上一对金属板，再用金属外壳密封，就构成石英产品——晶体。
其内部结构示意图为
晶体产生振荡必须附加外部时钟电路，一般是一个放大反馈电路，只有独立的一片晶体是不能实现震荡的。
前述的RC、LC型正弦自激振荡电路，频率受控于阻、容、感值，当温度变化时，电容和电感的变化很大，导致频率稳定性很差。
（注：频率稳定性（frequency stability），指的是在时间、温度、湿度、电源电压等一定变化范围内，振荡频率的相对变化量，
△ f f 0 \frac{△f}{f0} f0△f​ = f − f 0 f 0 \frac{f-f0}{f0} f0f−f0​ （f0:标称频率；f:实际频率）
晶体的等效电路也可以认为是一个LCR振荡电路。晶体作为回路元件，工作在感性区，等效为电感元件，谐振曲线里可以看出晶体在很窄范围内（两个固有谐振频率，串联谐振与并联谐振之间）才呈现感性，且该频率范围内曲线非常陡峭，对频率的补偿能力极强 。
3.1串联型晶体振荡电路 如下图所示，在串联型振荡器电路中，晶体管Q1、Q2构成的两级放大器，石英晶体X1与电容CL构成LC电路。在这个电路中，石英晶体相当于一个电感，CL为可变电容器，调节其容量即可使电路进入谐振状态，输出波形为方波。
3.2皮尔斯晶体振荡器（Pierce oscillator） 在并联型晶体振荡电路中，常在单片机电路中出现是皮尔斯晶体振荡器。主要结构如下图所示
在分析皮尔斯晶体振荡器电路的起振条件时，可以将上图进行一下变形。
在左图中，Rf 是一个兆欧级别的电阻，其作用是给反相放大器提供一个合适的偏置，并不影响电路谐振的频点，再讲晶体用等效电路去代替，得到下图
注意，起振需要满足两个条件
对于相位
相位需要满足2nπ，在该电路中，存在有反向放大器，已经相移π，而Rext 与 Cl1 组成一个低通滤波电路，带来的相移是小于90°，因此，晶体与Cl2带来的相移必须要大于90°，才有可能使得整个电路的相移是360°（2nπ，n=1）。
那么在什么条件下，晶体的等效电路带来的相移是大于90°呢？答案是晶体工作在感性区时。此时，晶体工作的频率范围就在两个固有频率点之间。
4. 晶振（oscillator，晶体振荡器，有源晶振） 晶振将外部时钟电路跟晶体放在同一个封装里面，一般都有4个引脚，两条电源线为里面的时钟电路提供电源，内部有谐振和输出端的驱动电路，一般还要做一些温度补偿电路在里面，让振荡频率能更加准确。
4.1 晶振的分类 国际电工委员会（IEC）将石英晶体振荡器分为4类：
普通晶体振荡器（XO）
电压控制式晶体振荡器（VCXO）
温度补偿式晶体振荡器（TCXO）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ded649313d8c19eb2b4546f288f888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3b8fab2f8a240a211dd656260c9854/" rel="bookmark">
			epoll源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		epoll_create epoll的第一个系统调用epoll_create，生成一个文件描述符，创建eventpoll结构，保存到文件的私有数据结构中。
当创建好epoll句柄后，它也会占用一个fd值，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。
注意：size参数只是告诉内核这个 epoll对象会处理的事件大致数目，而不是能够处理的事件的最大个数。在 Linux最新的一些内核版本的实现中，这个 size参数没有任何意义。
/* * This structure is stored inside the "private_data" member of the file * structure and represents the main data structure for the eventpoll * interface. */ struct eventpoll { /* Protect the access to this structure */ spinlock_t lock; /* * This mutex is used to ensure that files are not removed * while epoll is using them. This is held during the event * collection loop, the file cleanup path, the epoll file exit * code and the ctl operations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3b8fab2f8a240a211dd656260c9854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d688b153ecde1ac4813f661b46a3a49/" rel="bookmark">
			git下载报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：从git官网下载widows中git的安装包，老是下载失败。
git官网下载地址：https://git-scm.com/downloads
解决方法：
使用淘宝镜像的git下载地
// 淘宝镜像的git下载地址 https://npm.taobao.org/mirrors/git-for-windows/ 选择需要的版本下载即可
另外，如果一个git包在下载过程中一直报错，有可能那个包被用了太多次，已经损坏了，此时去官网重新下一个就好，用以上网址下载就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f81aaaedf77c318b9a6ec01ed1762b/" rel="bookmark">
			mysql修改用户密码（踩坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间：2022-08-27
在《MySQL必知必会》的第28章中，其中介绍到更改用户密码(口令)，但在我本机的MySQL版本8.0.29中执行时报错，在查阅其他博友的文章发现原因在于 MySQL版本过高。
问题解决方式：
《MySQL必知必会》原语句：SET PASSWORD = Password('new password');
修改成：SET PASSWORD = 'new password';
其他修改方式：ALERT USER ‘username’@‘%’ IDENTIFIED BY ‘new password’;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92911f47bfa2c1ec3c0ee7452bda940/" rel="bookmark">
			python绘图之turtle库的相关使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python绘图之turtle库的相关使用
目录 turtle库的介绍turtle库的使用turtle库中相关的函数窗体setup()函数screensize()函数 坐标goto()函数position()函数home()函数 运动forward()函数back()函数circle()函数 方向seth()函数left()函数right()函数 画笔penup()函数pendown()函数pensize()函数pencolor()函数colormode()函数 turtle库的介绍 turtle库也叫海龟库，1969年诞生，是turtle绘图体系的Python实现。turtle库是Python语言的标准库之一，是入门级的图形绘制函数库。
turtle库的使用 方法一：import turtle
这种方法在之后每次引用turtle库里面的函数都需要在函数之前添加“库名.”
例如下面代码片段：
import turtle turtle.setup(600,300,0,200) turtle.penup() 方法二：使用from和import保留字共同完成
格式：from turtle improt *（*表示添加turtle库中所有方法）
这种方法在函数调用时不用写 “库名.” ,但是如果有其他同名函数，会造成函数的多次定义
from turtle import* setup(600,350,200,200) penup() 方法三：使用import和as保留字共同完成
格式：import 库名 as 库别名
这种方法使用别名，可以减少调用函数时库名过于冗长而造成的工作量，也可避免造成函数的多重定义
import turtle as t t.setup(600,400,200,200) t.penup() turtle库中相关的函数 窗体 setup()函数 作用：设置窗体大小及位置
turtle.setup(width,height,startx,starty)
setup()函数不是必须的
startx,starty不给定，默认在正中间
screensize()函数 作用：设置画布的高、宽（单位为像素）、背景颜色
turtle.screensize(canvwidth,canvheight,bg)
eg:turtle.screensize(bg=“green”)默认画布宽高，背景颜色设置为绿色
坐标 goto()函数 turtle.goto(x,y):小乌龟沿着绝对坐标前进,到达坐标(x,y)处
position()函数 别名：pos()
获取小乌龟当前坐标位置
turtle.position()：获取小乌龟当前坐标
代码：
import turtle turtle.screensize(bg="green")#设置背景颜色 turtle.goto(100,100) print(turtle.pos()) turtle.done() 结果终端输出：（100.00,100.00）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a92911f47bfa2c1ec3c0ee7452bda940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb75875d09e90bc6a5e402183217f54/" rel="bookmark">
			fiddler打开后浏览器无法上网，抓包灰色锁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开fiddler-tools-options-https
2.decrypt https traffic取消勾选
3.actions-remove interception certficates 删除所有证书
4.decrypt https traffic重新勾选安装证书
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/127/">«</a>
	<span class="pagination__item pagination__item--current">128/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/129/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>