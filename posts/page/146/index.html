<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6b7a5621828f7dd890da3c91551099/" rel="bookmark">
			第三单元 用python学习微积分（二十）壳层法、圆盘法求体积 (下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-壳层法、圆盘法求体积-网易公开课
开发环境准备：CSDN
目录
2、壳层法（method of shells）求体积
2、壳层法（method of shells）求体积 ​
考虑 的曲线在y轴右侧的部分，如果绕y轴旋转360度， 会形成一个像水缸的体，而如上图中红色矩形部分，会形成一个空心的圆柱，一个圆柱形的壳。这个壳的厚度为dx(趋近于无穷小)，高度为a-y(注意最左侧图上y=a直线), 半径为x。
这个壳展开为一个厚片（最右侧图），这个厚片的厚度为dx， 高度为a-y, 底边长为中间图中圆柱的底面圆形的周长 。
代码主体部分请参考Bullseye：第三单元 用python学习微积分（二十）壳层法、圆盘法求体积 (上）
fig = plt.figure(figsize=(12, 12), facecolor='lightyellow' ) # draw sphere ax = fig.gca(fc='whitesmoke', projection='3d' ) x = symbols('x') a = 4 expr = x**2 DrawXY(0,2,100,expr,'b','',plt) RotateByAxis(0,2,100,expr,-0.5*np.pi,'r',ax, EnumAxis.YAxis) RotateByAxis(0,2,100,expr,0.5*np.pi,'r',ax, EnumAxis.YAxis) RotateByAxis(0,2,100,expr,-np.pi,'b',ax, EnumAxis.YAxis) DrawAxis(ax, 5,5,5) plot_surface(-2, 4, -2, 4, 0, 4, ax) ax.view_init(elev=30, # 仰角 azim=-20 # 方位角 ) plt.show() ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac6b7a5621828f7dd890da3c91551099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8104d0d60ee85a1b6ba774cc3cb0b2ad/" rel="bookmark">
			第三单元 用python学习微积分（十七）微积分第一基本定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-微积分第一基本定理-网易公开课
开发环境准备：CSDN
目录
一、微积分基本定理（FTC1）
1、例子：
(1) ​
(2) 求曲线 f(x) = sin(x) ，x 在 (0, 𝝿) f(x)到x轴的面积
(3) ​
二、微积分基本定理的直观解释
1、假设 x(t) 是你在时刻 t 的位置
2、扩展积分到 函数 f &lt; 0 (或 f &gt; 0)
三、积分的性质
1、 ​
2、 ​ 当c是常数
3、a
4、 ​......（ F(a) - F(a) ）
5、 ​（ F(b) - F(a) =- (F(a) - F(b)) ）
6、积分估计
7、改变变量
(1) ​
(2)
一、微积分基本定理（FTC1） 如果F'(x) = f(x), 新的计算符号
1、例子： (1) 如上节课上的例子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8104d0d60ee85a1b6ba774cc3cb0b2ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1aec7b76c4e85a4e0379246a06ba13/" rel="bookmark">
			第二单元 用python学习微积分（十六）定积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-定积分-网易公开课
开发环境准备：CSDN
目录
一、定积分的概念
二、计算面积的步骤
1、切割成多个"矩形"
2、把这些"矩形"的面积累加起来
3、修正前面的结果，（通过让"矩形"变窄来取得极限值，到无穷窄）
三、例子
1、 ​，a = 0, b 任意
2、 f(x) = x ,a = 0, b 任意
3、f(x) = 1 ,a = 0, b 任意
四、定积分的符号（黎曼和）
1、求解定积分的通常的步骤
一、定积分的概念 几何意义找到曲线下的面积（另 累积和）
​
和不定积分的区别在于，不定积分并没有给出上限或下限（a,b）
二、计算面积的步骤 1、切割成多个"矩形" 2、把这些"矩形"的面积累加起来 3、修正前面的结果，（通过让"矩形"变窄来取得极限值，到无穷窄） ​
三、例子 1、 ，a = 0, b 任意 面积= 这里要计算 ， 老师给了一个算法，把数列中的每个数看作一个高为1的长方体的下底面（正方形）的一条边，这样组成了一个金字塔，另外这个金字塔有一个内接的4棱锥和一个外接的4棱锥。
体积依次为 import matplotlib as mpl from matplotlib import cm from matplotlib import pyplot as plt from mpl_toolkits.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b1aec7b76c4e85a4e0379246a06ba13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f2bb7a0127fe54a099669aaffa67d7/" rel="bookmark">
			第二单元 用python学习微积分（十）曲线构图下和最值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-最值问题-网易公开课
开发环境准备：CSDN
目录
一、曲线构图例子
二、曲线构图总结：
1、描点
a 找到函数的不连续点（尤其是函数值趋向于无穷的点）
b 找到无限远端的点即x趋向于无穷（ ​ ）的点
c 标出那些容易找到的点，比如在坐标轴上的....(optional)
2、计算
a 求导f'(x) = 0
b 求驻点和驻点的值
3、根据导数检查
4、根据2次导数检查（由于求二阶导数经常非常复杂，所以没有要求尽量避免这一步）
5、综合以上
三、例子
1、描点
a ​
b 远端点
2、计算
3、根据导数检查
4、根据2次导数检查
四、最值问题
一、曲线构图例子 (看出原函数双曲线函数)
因为导数永不为0， 所以这个函数没有驻点
画这个函数的简图，首先考虑非法点x=-2
当 则 当 则 可以想象这个会是
这时考虑当x取 时 ，同时由于f'(x) 永不为0，因此没有驻点，所以不会出现翻转（没有turning point， 函数中没有一个点有一根平的切线）（非法点也已经考虑清楚了）。
检查：这双曲线在下-infinity&amp;amp;lt;x&amp;amp;lt;-2 -2&amp;amp;lt;x&amp;amp;lt;infinity 随x增长y增长， 因为导数恒正
from sympy import * import numpy as np import matplotlib.pyplot as plt fig = plt.figure() ax = fig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9f2bb7a0127fe54a099669aaffa67d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c755ce346a2abf4ecb3f560e0c370230/" rel="bookmark">
			解决 OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言`原因分析 前言` 今天调试代码，遇到了这样的问题：
OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized. OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. That is dangerous, since it can degrade performance or cause incorrect results. The best thing to do is to ensure that only a single OpenMP runtime is linked into the process, e.g. by avoiding static linking of the OpenMP runtime in any library.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c755ce346a2abf4ecb3f560e0c370230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04e08dabb900d6a92e48e1d2ea7e1ad/" rel="bookmark">
			layui table 头部栏输入框无法输入问题，文字无法显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般工具栏都装在toolbardemo
装在带有layui-btn-container样式的盒子里
而layui的css设置了
这里设置看font-size 0导致无法显示input 已经文字信息
只需要在style 让它不为0就可以显示文字了
&lt;style&gt; .layui-btn-container{font-size:inherit} &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e49fe83bc404484f125098843bddb39/" rel="bookmark">
			第一单元 用python学习微积分（二） 导数（上）- 瞬时速度 -- vscode -- pygame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自学习麻省理工学院公开课：单变量微积分-极限和连续-网易公开课
目录
一、准备：
二、课程内容，导数可以在几何中表示曲线的变化率，同时也可以在物理中表现速度的变化率
三、python的展示，找找资料，选定了用pygame来展示这个南瓜坠落的实验。
四、这个小程序的说明：
一、准备： 安装vs code https://code.visualstudio.com/Download
安装pygame
pip install pygame 如果你的系统路径的python不是anaconda，还需要把sympy安装下
pip install sympy 二、课程内容，导数可以在几何中表示曲线的变化率，同时也可以在物理中表现速度的变化率 提出在80米的楼上，自由落体一个物体，设重力加速的为， 于是有如下公式：
(m)
从公式上看，很明显t最大为4， 因为这个时后物体已经落地， 下落至的离地高度为0
这时整个过程的平均速度： 当物体落地的瞬时速度: ( 此时使用了上节课的结论， )
由于 t=4 时物体落地， 所以落地时的瞬时速度为 三、python的展示，找找资料，选定了用pygame来展示这个南瓜坠落的实验。 由于坐标系做的有点问题，偏移时像素没有对应到小数位，结果不很准确，不过也能说明问题了。
import random import pygame import math import sys import time from pygame.constants import K_RETURN from Coordinate import * from screen import * from XRectangle import XRectangle from timer import Timer def CalculateDistance(seconds, g): return int(1/2*g*seconds**2) def CalculateSpeed(seconds, g): return seconds *g if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e49fe83bc404484f125098843bddb39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6991e265a9788adacc22de66738bac8d/" rel="bookmark">
			Excel添加下拉选项菜单的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下拉选项菜单用于某些需要输入确定内容的单元格。比如在性别列，输入的内容为男/女，这时候就可以使用下拉菜单，一是防止输入错误，二是减少输入量，通过选择即可输入内容。
具体实现方法：
1.选中需要设置下拉菜单的单元格
2.依次点击“数据”菜单——“数据验证”——“数据验证”
3.在数据验证对话框中，将“允许”设置为“序列”，在来源里输入允许的选项，不同选项之间用英文逗号隔开，点击确定按钮。
如果要取消某个单元格的下拉选项菜单应该怎么做呢？
选中该单元格，在数据验证对话框里，将允许设置为“任何值”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261e07d53765d48ff8f14ba6a3b489ba/" rel="bookmark">
			2021年国内一线互联网大厂内部题库Android面试(Java篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9.进程和线程的区别（猎豹）
简而言之,一个程序至少有一个进程,一个进程至少有一个线程。
线程的划分尺度小于进程，使得多线程程序的并发性高。
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。
10.Java中==和equals的区别，equals和hashCode的区别（乐视）
[http://blog.csdn.net/tiantiandjava/article/details/46988461](()
11.常见的排序算法时间复杂度（小米）
12.HashMap的实现原理（美团）
HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。
13.java 状态机
[http://www.jdon.com/designpatterns/designpattern_State.htm](()
14.java中int char long各占多少字节数
byte 位数 8 字节数 1
short 16 2
int 32 4
long 64 8
float 32 4
double 64 8
char 16 2
15.java int与integer的区别
[http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html](()
16.string stringbuffer stringbuilder 区别（小米、乐视、百度）
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）
简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/261e07d53765d48ff8f14ba6a3b489ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cac0665be032a995fec6157d28478e2/" rel="bookmark">
			2020荒诞的一年，35岁程序员现状：我现在房贷车贷家庭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为什么造成这一现状？如何解决！ 第一、老员工工资比较高 why？
其实在职场中，工作并不是领导不愿意提拔老员工，而是因为老员工的工资确实高得离谱，这是公司领导难以承受的，所以在提拔员工时，有些领导他们甚至会注重那些新员工，并不愿意去看重老员工的能力，毕竟老员工的收入就占了公司用工成本的很大一部分，有些公司老板会隔三差五的劝退老员工，让老员工在职场中没有办法有更稳定的工作状态。
solve
很多人陷入了一个误区，价值和价钱这个是2个概念，你要努 《Android学习笔记总结+最新移动架构视频+大厂安卓面试真题+项目实战源码讲义》无偿开源 徽信搜索公众号【编程进阶路】 力让老板看到你身上的价值。比如：10块钱的东西用不了几次，100块钱的就可以用几年，这是产品价值，你要让老板看到你的价值，不是你一个人可以抵几个新的员工（当然这也是价值），更重要你要让老板知道你给公司带来的那部分价值除了你，谁也不能创造出来，独一性，才是让你立于不败之处！
第二、老员工能力难以得到提升 why？
在公司里工作，其实35岁以上的老员工都不愿意再去学习，因为他们想要通过过往的能力和经验在公司里执行任务，而且当他们发现凭借自己的能力可以去解决问题，那么就没有必要再去参加培训班去学习，提升自己的综合能力，所以这些老员工是不可能通过领导考核的，相反那些新员工敢想敢拼，而且敢于学习，最后在职场中才能够得到领导的特别照顾。
solve
1.android中级程序员 总结：能够分析问题，能够解决问题；
技能：了解android的签名机制（实现原理，具体操作等等），打包机制（多渠道打包，打包流程等等），了解apk安装文件压缩（压缩图片，代码压缩，.so文件压缩等等），事件分发，View绘制流程，webview相关知识点（与Native的交互，性能优化等），熟悉数据库的使用（基本API，第三方ORM框架，ORM框架的实现原理等等），java反射原理与简单实践等，activity的启动模式，activity，service，fragment，broadcastreceiver广播生命周期，屏幕适配，AIDL与messager的简单实用，自定义组件（自定义View与自定义ViewGroup），动画（补间动画，帧动画，属性动画），通知栏消息，版本新特性等等等等；
要求：开始阅读android方面的而源码，不但能看懂别人的代码还需要能够修改别人源码，对android的体系结构，组成方式，常见开源社区，技术要点能够了然于胸。
2.android高级程序员 总结：能够解决问题，能够发现问题；
技能：手动编写框架，设计模式，代码规范，项目进度，时间估算，启动流程，性能优化，OOM，没存溢出与泄露，JNI，脚本开发，activity启动流程，android中的IPC机制（Binder原理），对IOS等其他移动开发现学现用等等；
要求：能够造轮子，比如写一个网络框架，事件总线控件，特效View等，重点是能够为产品造轮子。
3.android技术专家 总结：对某一方面非常精通与专注；
技能：比如对android的对媒体模块十分熟悉，阅读过android多媒体模块的源码，能够更改其中的不足与BUG等等；
要求：熟读android源码，对android的某一模块有自身的看法并能够有相应的修改能力，能够知道团队他人的日常产品开发等。
4.CTO img-9o8vkQer-1651375314674)]
4.CTO 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d968c4007496af5dcf56247b12f434a/" rel="bookmark">
			vue创建项目报错：command failed: npm install --loglevel error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实重点不在这句话 很多人看了各种解决方式都没有创建项目成功，没有解决的原因就是太注意这个报错
command failed: npm install --loglevel error
这个问题解决的关键是下面这句话
npm ERR! Invalid dependency type requested: alias
问题就是你的alias 低版本的npm不支持.必须要6.9版本以上
两个方案
方法一
单独升级npm版本,升级为大于6.9版本的npm
命令附上
npm -g install npm@6.9.0
方法二
直接升级nodejs,其自带的npm也会升级
然后再创建项目 解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3c88d21e504907d13ef914b768072e/" rel="bookmark">
			Twaver-HTML5基础学习(29)界面交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		界面交互 拓扑图上的鼠标、键盘、触屏交互通过一堆Interaction组成，每个Interaction包含独立的事件监听和卸载操作，其中最基本的实现类是twaver.network.interaction.BaseInteraction，其他交互类都是从它继承衍生出来的
下面是BaseInteraction{}的实现代码，其中的setUp函数用于添加监听事件，tearDown函数卸载监听，实现交互监听类时，通常需要重写这两个方法。
twaver.vector.interaction.BaseInteraction = function (network) { this.network = network; }; _twaver.ext('twaver.vector.interaction.BaseInteraction', Object, { setUp: function () { }, tearDown: function () { }, addListener: function () { for (var i = 0; i &amp;lt; arguments.length; i++) { var type = arguments[i]; $html.addEventListener(type, 'handle_' + type, this.network.getView(), this); } }, removeListener: function () { for (var i = 0; i &amp;lt; arguments.length; i++) { $html.removeEventListener(arguments[i], this.network.getView(), this); } }, }); 上面的其实也不太懂…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd3c88d21e504907d13ef914b768072e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302d7064be9520bf6c49bb252a501504/" rel="bookmark">
			【数学建模】分类问题的几种常见指标（一）——准确率、召回率、F1值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分类问题的几种常见指标（一）——错误率、精度、准确率、召回率、F1值 前言1 错误率与精度2 准确率与召回率2.1 混淆矩阵2.2 准确率（Precision）2.3 召回率（Recall） 3 F1值（F1-score）4 代码实现 前言 分类问题是数学建模和大数据竞赛中几大常见题型之一。评价分类效果的指标有错误率、精度、准确率（precision，也称之查准率）、召回率（recall，也称之查全率）、F1-Score、ROC曲线、AUC和对数损失（logloss）等。这些指标都可以评价一个模型的好坏，其之间也有许多关联，需要针对具体题目场景来选择评价指标。本节主要介绍错误率、精度、准确率、召回率、F1值这几种评价指标。
1 错误率与精度 在分类问题中，错误率是分类结果错误的样本数占样本总数的比例，精度则是分类结果正确的样本数占样本总数的比例。即，错误率 = 1–精度。
2 准确率与召回率 2.1 混淆矩阵 以二分类问题为例，介绍一个重要的定义：混淆矩阵，如下图所示
假设A类为Positive，正例（阳性）；B类为Negative，反例（阴性），则
Ture Positive（TP）：预测对了（T），预测结果为A（阳性-P），原类别为A；False Positive（FP）：预测错了（F）,预测结果为A（阳性-P）,原类别为B；False Negative（FN）：预测错了（F）,预测结果为B（阴性-N），原类别为A；Ture Negative（TN）：预测对了（T），预测结果为B（阴性-N）,原类别为B。
总而言之，混淆矩阵的字母代表该次预测的对的还是错的（T/F）和预测结果是正例还是反例（P/N），进而就可以推断原来的类别是什么。（比如FN，预测的是类别B，预测错了，那原来的类别就是A） 2.2 准确率（Precision） 准确率（Precision）是指被分类器判定为正类的样本中真正的正类样本所占的比重，即被分类器判为正类的所有样本中有多少是真正的正类样本，其公式定义见以下公式
2.3 召回率（Recall） 召回率是指被分类器正确判定的正类样本占总的正类样本的比重，即所有正类样本中有多少被分类器判为正类样本，定义如以下公式：
3 F1值（F1-score） 准确率和召回率反映了分类器性能的两个方面，单依靠其中一个并不能较为全面地评价一个分类器的性能。一般来说，鱼与熊掌不可兼得，你的准确率越高，召回率越低；反之，召回率越高，准确率越低。继而为了平衡准确率和召回率的影响，较为全面地评价一个分类器，便有了 F1-score 这个综合了这两者的指标。
4 代码实现 构建一个计算准确率、召回率和 F1-score 的评价代码也很简单，具体实现代码如下：
假设有A类样本10个，B类样本5个，A类样本用1表示，B类样本用0表示。正确预测A类样本7个，正确预测B类样本3个
所以混淆矩阵的具体表示如下：
准确率 Precision = TP/(TP+FP) = 7/(7+2) = 0.78召回率 Recall = TP/(TP+FN) =7/(7+3) = 0.7F1值 F1 = 2PrecisionRecall/(Precision+Recall) = 0.74 以下为代码实现：
from sklearn.metrics import precision_score, recall_score, f1_score # 假设有A类样本10个，B类样本5个 y_train = [1,1,1,1,1,1,1,1,1,1,0,0,0,0,0] # 正确预测A类样本7个，正确预测B类样本3个 y_pred = [1,1,1,1,1,1,1,0,0,0,1,1,0,0,0] precision = precision_score(y_train, y_pred) recall = recall_score(y_train, y_pred) f1 = f1_score(y_train, y_pred) print('准确率为：', precision) print('召回率为：', recall) print('F1值为：', f1) 执行结果如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b455203afaafa689d5f80abaaaef40/" rel="bookmark">
			csdn五一勋章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"红色联合"对"四。二八兵团"总部大楼的攻击已持续了两天，他们的旗帜在大楼周围躁动地飘扬着，仿佛渴望干柴的火种。
"红色联合"的指挥官心急如焚，他并不惧怕大楼的守卫者，那二百多名"四。二八".战士，与诞生于l966年初、经历过大检阅和大串联的"红色联合"相比要稚嫩许多。他怕的是大楼中那十几个大铁炉子，里面塞满了烈性炸药，用电雷管串联起来，他看不到它们，但能感觉到它们磁石般的存在，开关一合，玉石俱焚，而"四。二八"的那些小红卫兵们是有这个精神力量的。比起已经在风雨中成熟了许多的第一代红卫兵，新生的造反派们像火炭上的狼群，除了疯狂还是疯狂。
大楼顶上出现了一个娇小的身影，那个美丽的女孩子挥动着一面"四。二八"的大旗，她的出现立刻招来了一阵杂乱的枪声，射击的武器五花八门，有陈旧的美式卡宾枪、捷克式机枪和三八大盖，也有崭新的制式步枪和冲锋枪——后者是在"八月社论"发表之后从军队中偷抢来的（注：1967年8月《红旗》杂志发表"揪军内一小撮"的社论，使冲击军区、抢夺军队枪支弹药的事件愈演愈烈，全国范围的武斗也进入高潮。）——连同那些梭标和大刀等冷兵器，构成了一部浓缩的近现代史……"四。二八"的人在前面多次玩过这个游戏，在楼顶上站出来的人，除了挥舞旗帜外，有时还用喇叭筒喊口号或向下撒传单，每次他们都能在弹雨中全身而退，为自己挣到了崇高的荣誉。这次出来的女孩儿显然也相信自己还有那样的幸运她挥舞着战旗，挥动着自己燃烧的青春，敌人将在这火焰中化为灰烬，理想世界明天就会在她那沸腾的热血中诞生……她陶醉在这鲜红灿烂的梦幻中，直到被一颗步枪子弹洞穿了胸膛，十五岁少女的胸膛是那么柔嫩，那颗子弹穿过后基本上没有减速，在她身后的空中发出一声啾鸣。年轻的红卫兵同她的旗帜一起从楼顶落下，她那轻盈的身体落得甚至比旗帜还慢，仿佛小鸟眷恋着天空。
其实，比起另外一些人来，她还是幸运的，至少是在为理想献身的壮丽激情中死去。
这样的热点遍布整座城市，像无数并行运算的CPU，将"文革大革命一联为一个整体。疯狂如同无形的洪水，将城市淹没其中-并渗透到每一个细微的角落和缝隙。
在城市边缘的那所著名大学的操场上，一场几千人参加的批斗会已经进行了近两个小时。在这个派别林立的年代，任何一处都有错综复杂的对立派别在格斗。在校园中，红卫兵、文革工作组、工宣队和军宣队，相互之间都在爆发尖锐的冲突，而每种派别的内部又时时分化出新的对立派系，捍卫着各自不同的背景和纲领，爆发更为残酷的较量。
但这次被批斗的反动学术权威，却是任何一方均无异议的斗争目标，他们也只能同时承受来自各方的残酷打击。
与其他的牛鬼蛇神相比，反动学术权威有他们的特点：当打击最初到来时，他们的表现往往是高傲而顽固的，这也是他们伤亡率最高的阶段；在首都，四十天的时间里就有一千七百多名批斗对象被活活打死，更多的人选择了更快捷的路径来逃避疯狂，老舍、吴晗、葛伯赞、傅雷、赵九章、以群、闻捷、海默等，都自己结束了他们那曾经让人肃然起敬的生命。
从这一阶段幸存下来的人，在持续的残酷打击下渐渐麻木，这是一种自我保护的精神外壳，使他们避免最后的崩溃。他们在批斗会上常常进入半睡眠状态，只有一声恫吓才能使其惊醒过来，机械地重复那已说过无数遍的认罪词；然后，他们中的一部分人便进入了第三阶段，旷日持久的批判将鲜明的政治图像如水银般：注入了他们的意识，将他们那由知识和理性构筑的思想大厦彻底摧毁，他们真的相信自己有罪，真的看到了自己对伟大事业构成的损害，并为此痛哭流涕，他们的忏悔往往比那此非知识分子的牛鬼蛇神要深刻得多，也真诚得多：而对于红卫兵来说，进入后两个阶段的批判对象是最乏味的，只有处于第一阶段的牛鬼蛇神才能对他们那早已过度兴奋的神经产生有效的刺激，如同斗牛士手上的红布，但这样的对象越来越少了，在这所大学中可能只剩下一个，他由于自己的珍稀而被留到批判大会最后出场。
叶哲泰从文革开始一 直活到了现在，并且一直处于第一阶段，他不认罪，不自杀，也不麻木。当这位物理学 教授走上批判台时，他那神情分明在说：让我背负的十字架更沉重一些吧！红卫兵们让他负担的东西确实很重，但不是十字架。别的批判对象戴的高帽子都是用竹条扎的框架，而他戴的这顶却是用一指粗的钢筋焊成的，还有他挂在胸前的那块牌子，也不是别人挂的木板，而是从实验室的一个烤箱上拆下的铁门，上面用黑色醒目地写着他的名字，并沿对角线画上了一个红色的大叉。
押送叶哲泰上台的红卫兵比别的批判对象多了一倍，有六人，两男四女。两个男青年步伐稳健有力，一副成熟的青年布尔什维克形象，他们都是物理系理论物理专业大四年级的，叶哲泰曾是他们的老师；那四名女孩子要年轻得多，都是大学附中的初二学生，这些穿着军装扎着武装带的小战士挟带着逼人的青春活力，像四团绿色的火焰包围着叶哲泰。叶哲泰的出现使下面的人群兴奋起来，刚才已有些乏力的口号声又像新一轮海潮般重新高昂起来，淹没了一切。
耐心地等口号声平息下去后，台上两名男红卫兵中的一人转向批判对象："叶哲泰，你精通各种力学，应该看到自己正在抗拒的这股伟大的合力是多么强大，顽固下去是死路一条！今天继续上次大会的议程，废话就不多说了。老实回答下面的问题：在六二至六五届的基础课中，你是不是擅自加入了大量的相对论内容？！"
"相对论已经成为物理学的古典理论，基础课怎么能不涉及它呢？"叶哲泰回答说。
"你胡说！"旁边的一名女红卫兵厉声说，"爱因斯坦是反动的学术权威，他有奶便是娘，跑去为美帝国主义造原子弹！要建立起革命的科学，就要打倒以相对论为代表的资产阶级理论黑旗！"
叶哲泰沉默着，他在忍受着头上铁高帽和胸前铁板带来的痛苦，不值得回应的问题就沉默了。在他身后，他的学生也微微皱了一下眉头。说话的女孩儿是这四个中学红卫兵中天资最聪颖的一个，并且显然有备而来，刚才上台前还看到她在背批判稿，但要对付叶哲泰，仅凭她那几句口号是不行的。他们决定亮出今天为老师准备的新武器，其中的一人对台下挥了一下手。
叶哲泰的妻子，同系的物理学教授绍琳从台下的前排站起来，走上台。她身穿一件很不合体的草绿色衣服，显然想与红卫兵的色彩拉近距离，但熟悉绍琳的人联想到以前常穿精致旗袍讲课的她，总觉得别扭。
"叶哲泰！"绍琳指着丈夫喝道，她显然不习惯于这种场合，尽量拔高自己的声音，却连其中的颤抖也放大了，"你没有想到我会站出来揭发你，批判你吧！？是的，我以前受你欺骗，你用自己那反动的世界观和科学观蒙蔽了我！现在我醒悟了，在革命小将的帮助下，我要站到革命的一边，人民的一边！"她转向台下，"同志们、革命小将们、革命的教职员工们，我们应该认清爱因斯坦相对论的反动本质，这种本质，广义相对论体现得最清楚：它提出的静态宇宙模型，否定了物质的运动本性，是反辩证法的！它认为宇宙有限，更是彻头彻尾的反动唯心主义……"听着妻子滔滔不绝的演讲，叶哲泰苦笑了一下。琳，我蒙蔽了你？其实你在我心中倒一直是个谜。一次，我对你父亲称赞你那过人的天资——他很幸运，去得早，躲过了这场灾难——老人家摇摇头，说我女儿不可能在学术上有什么建树；接着，他说出了对我后半生很重要的一句话：琳琳太聪明了，可是搞基础理论，不笨不行啊。
以后的许多年里，我不断悟出这话的深意。琳，你真的太聪明了，早在几年前，你就嗅出了知识界的政治风向，做出了一些超前的举动，比如你在教学中，把大部分物理定律和参数都改了名字，欧姆定律改叫电阻定律，麦克斯韦方程改名成电磁方程，普朗克常数叫成了量子常数……你对学生们解释说：所有的科学成果都是广大劳动人民智慧的结晶，那些资产阶级学术权威不过是窃取了这些智慧。但即使这样，你仍然没有被"革命主流"所接纳，看看现在的你，衣袖上没有"革命教职员工"都戴着的红袖章；你两手空空地上来，连一本语录都没资格拿……谁让你出生在旧中国那样一个显赫的家庭，你父母又都是那么著名的学者。
说起爱因斯坦，你比我有更多的东西需要交待。1922年冬天，爱因斯坦到上海访问，你父亲因德语很好被安排为接待陪同者之一。你多次告诉我，父亲是在爱因斯坦的亲自教诲下走上物理学之路的，而你选择物理专业又是受了父亲的影响，所以爱翁也可以看作你的间接导师，你为此感到无比的自豪和幸福。
后来我知道，父亲对你讲了善意的谎言，他与爱因斯坦只有过一次短得不能再短的交流。那是l922年11月l3日上午，他陪爱因斯坦到南京路散步，同行的好像还有上海大学校长于右任、《大公报》经理曹谷冰等人，经过一个路基维修点，爱因斯坦在一名砸石子的小工身旁停下，默默看着这个在寒风中衣衫破烂、手脸污黑的男孩子，问你父亲：他一天挣多少钱？问过小工后，你父亲回答：五分。这就是他与改变世界的科学大师唯一的一次交流，没有物理学，没有相对论，只有冰冷的现实。据你父亲说，爱因斯坦听到他的回答后又默默地站在那里好一会儿，看着小工麻木的劳作，手里的烟斗都灭了也没有吸一口。你父亲在回忆这件事后，对我发出这样的感叹：在中国，任何超脱飞扬的思想都会砰然坠地的，现实的引力太沉重了。
"低下头！"一名男红卫兵大声命令。这也许是自己的学生对老师一丝残存的同情，被批斗者都要低头，但叶哲泰要这样，那顶沉重的铁高帽就会掉下去，以后只要他一直低着头，就没有理由再给他戴上。但叶哲泰仍昂着头，用瘦弱的脖颈支撑着那束沉重的钢铁。
"低头！你个反动顽固分子！！"旁边一名女红卫兵解下腰间的皮带朝叶哲泰挥去，黄铜带扣正打在他脑门上，在那里精确地留下了带扣的形状，但很快又被淤血模糊成黑紫的一团。他摇晃了一下，又站稳了。
一名男红卫兵质问叶哲泰："在量子力学的教学中，你也散布过大量的反动言论！"说完对绍琳点点头，示意她继续。
绍琳迫不及待地要继续下去了，她必须不停顿地说下去，以维持自己那摇摇欲坠的精神免于彻底垮掉。"叶哲泰，这一点你是无法抵赖的！你多次向学生散布反动的哥本哈根解释！" "这毕竟是目前公认的最符合实验结果的解释。"叶哲泰说，在受到如此重击后，他的口气还如此从容，这让绍琳很吃惊，也很恐惧。
"这个解释认为，是外部的观察导致了量子波函数的坍缩，这是反动唯心论的另一种表现形式，而且是一种最猖狂的表现！" "是哲学指引实验还是实验指引哲学？"叶哲泰问道，他这突然的反击令批判者们一时不知所措。
"当然是正确的马克思主义哲学指引科学实验！"一名男红卫兵说。
"这等于说正确的哲学是从天上掉下来的，这反对实践出真知，恰恰是违背马克思主义对自然界的认知原则的。"绍琳和两名大学红卫兵无言以对，与中学和社会上的红卫兵不同，他们不可能一点儿道理也不讲。但来自附中的四位小将自有她们"无坚不摧"的革命方式，刚才动手的那个女孩儿又狠抽了叶哲泰一皮带，另外三个女孩子也都分别抡起皮带抽了一下，当同伴革命时，她们必须表现得更革命，至少要同样革命。两名男红卫兵没有过问，他们要是现在管这事，也有不革命的嫌疑。
"你还在教学中散布宇宙大爆炸理论，这是所有科学理论中最反动的一个！"一名男红卫兵试图转移话题。
"也许以后这个理论会被推翻，但本世纪的两大宇宙学发现：哈勃红移和3K宇宙背景辐射，使大爆炸学说成为目前为止最可信的宇宙起源理论。"
"胡说！"绍琳大叫起来，又接着滔滔不绝地讲起了宇宙大爆炸，自然不忘深刻地剖析其反动本质。但这理论的超级新奇吸引了四个小女孩儿中最聪明的那一个，她不由自主地问道："连时间都是从那个奇点开始的！？那奇点以前有什么？"
"什么都没有。"叶哲泰说，像回答任何一个小女孩儿的问题那样，他转头慈祥地看着她，铁高帽和已受的重伤，使他这动作很艰难。
"什么……都没有？！反动！反动透顶！！"那女孩儿惊恐万状地大叫起来，她不知所措地转向绍琳寻求帮助，立刻得到了。
"这给上帝的存在留下了位置。"绍琳对女孩儿点点头提示说。
小红卫兵那茫然的思路立刻找到了立脚点，她举起紧握皮带的手指着叶哲泰，"你，是想说有上帝？！" "我不知道。" "你说什么！" "我是说不知道，如果上帝是指宇宙之外的超意识的话，我不知道它是不是存在；正反两方面，科学都没给出确实的证据。"其实，在这噩梦般的时刻，叶哲泰已倾向于相信它不存在了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08401250d5252ef4a929d8241dba011c/" rel="bookmark">
			关于Typora的研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天 装了Typora 1.15版,因为这个版本 可以链接 其它文件
它这个压包 其实是一样的,不过,压包的时候,包里的目录中要有一个main.node文件,可以是0字节,要不然就会失败,其它和1.03是一样的
1.13版的,也弄好了,好像是1.13版更快一点(莫非是心理作用吗?)
总结一下
1.02版要改 menu.js 1.13 开始改的是 atom.js 文件 1.13 开始的这个文件,整齐多了 PS:为什么办公室的电脑打开1.15版 会很卡呢,打开1.02 就 非常快.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa6597e063c87575fc3c7ad3ced8244/" rel="bookmark">
			2020年Android高级面试题总结（附答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答：方法名+参数类型+参数顺序(返回值不是)
2.finalize的工作原理
答：一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.所以如果使用finalize()，就可以在垃圾收集期间进行一些重要的清除或清扫工作。此外系统进行垃圾回收时并不保证一定会调用它，所以可以说它和对象被回收没有必然关系。
3.一个对象的创建过程
答:例如有一个Dog类：
1.即使没有static，构造器其实也是静态方法，所以当首次创建Dog时或者Dog的静态域或者静态方法被访问的时候，Dog的class对象会被加载。
2.在加载Dog的class的时候可能会发现其有基类，此时先暂停Dog的加载，转而去加载其基类。所以基类的static域比子类先初始化。
3.载入class文件之后，会创建一个该该类的class对象，所有关于静态初始化的动作会被执行，所以静态初始化只在Class对象首次加载时进行一次。
4.当使用new的时候，首先为Dog对象在堆上分配足够内存空间。这块内存控件会被清零，所有实例都被初始化成了默认值，包括基类。
5.执行所有字段定义处的初始化，从基类开始。
6.执行构造器。(在第一行会执行基类的构造器)
4.对象的销毁是按照创建的逆序来进行的。
5.final的方法和类都不允许覆盖和继承。private默认实现了final。
6.简述内部类的特点
7.形式参数可被视为local variable，也就是说形式参数相当于在方法中定义了一个局部变量a，当传入c时，只是将c指向的对象给a
8.finally 语句块是在 try 或者 catch 中的 return 语句之前执行的
9.简述jvm中默认的classLoader与功能
10.switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持
11.重写的特性
12.!=和==，当用于基本类型时候，是比较值是否相同；当用于引用类型的时候，是比较对象是否相同，比较内存地址
13.null可以被强制类型转换成任意类型的对象，于是通过它来执行静态方法
14.如何终止一个线程
15.静态属性和静态方法是否可以被继承
16.列出各种List，Set，Map，Queue并说出他们的同与不同。
17.列出几种线程池
18.解释一下java内存模型
19.解释一下java代码的原子性
20.解释一下volatile字段
21.解释一下synchronized字段
22.Lock的使用
23.wait()和sleep()区别
24.死锁产生的条件
…
篇幅原因，参考答案均整理到下面这份PDF文档里，需要的朋友可以[点击我的GitHub](()，前往免费领取！**
Java相关
二 Android相关 Android部分我就不分几大块了。直接列举，但是列举到的每一项都是面试经常会问到并且会延伸问的，所以需要深入的去研究。
1.Android事件分发机制，请详细说下整个流程
2.Android view绘制机制和加载过程，请详细说下整个流程
3.Activty的加载过程 请详细介绍下
4.Activity的启动模式：
5.Activity缓存方法：
6.Service的生命周期，两种启动方法，有什么区别：
7.怎么保证service不被杀死8.广播的两种注册方法，有什么区别。
9.Intent可以传递哪些数据类型10.Json有什么优劣势
11.动画有哪几类，各有什么特点：
12.Handler、Loop消息队列模型，各部分的作用。
13. 怎样退出终止App:自己设置一个Activity的栈，然后一个个finish()。
14. Android IPC:Binder原理
15.android的优化
16.一个single 《Android学习笔记总结+最新移动架构视频+大厂安卓面试真题+项目实战源码讲义》无偿开源 徽信搜索公众号【编程进阶路】 ton如何实现线程的同步问题
17.android重要术语解释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efa6597e063c87575fc3c7ad3ced8244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7150341fd518aac31741e2fda10ff87b/" rel="bookmark">
			element-ui分页器设置每一页显示数量(page-size)后页码没有发生变化原因与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 element-ui当中分页器,设置每一页显示数量(page-size)后页码没有发生变化
比如 原来是每一个显示数据量为3个数据 后面想每一页显示数据为5个,那么按照道理来说,页码也会变化的
然而并没有发生变化
原因 page-size要和page-sizes当中的数据对得上才可以,也就是说page-size如果数字没有与page-sizes这个数组里面的数组对应上,那么就会区page-sizes当中的第一个值来计算页码 示例1 page-size有值但是page-sizes不填写 示例1效果图 示例1分析 page-sizes不填写(注意是page-sizes),则取默认值为 :page-sizes = " [10, 20, 30, 40, 50, 100] "这里填写的 :page-size = “12”,在 :page-sizes = "[10, 20, 30, 40, 50, 100] " 找不到对应的,就忽略page-size设置的值,而去取page-sizes数组当中第一个值,也就是10最终计算页码: 10898 / 10 向上取整就为1090页 示例2 page-size有值并且page-sizes填写但是page-sizes当中没有对应值 示例2效果图 示例2分析 page-size的值在page-sizes没有有对应的值,于是取page-sizes数组当第一个值,也就是3计算页码: 10898/3 向上取整 = 3633页 示例3 page-size有值并且page-sizes填写并且page-sizes当中有对应值 示例3效果图 示例3分析 page-size的值在page-sizes有对应的值,所以可以正常按照我们设置的显示页码计算页码: 10898/6 向上取整 = 1817页 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74869bc074657381687a1b06e3f0594/" rel="bookmark">
			Lamp——mysql组复制协议（全同步机制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql组复制协议（全同步机制） 搭建MySQL集群，实现组复制成员故障 ** 默认MySQL主从复制方式是异步的，after_commit模式和after_sync模式是半同步方式。**
同步方式复制对数据一致性要求高，速度最慢。
同步方式的部署分为单主模式和多主模式。
多主模式是每个节点都可以对数据写，单主模式是只能master写数据。mysql的主从复制是单主模式，salve不可以对数据写。
当集群中的任何节点在执行的时候，都会将日志发送到集群中所有节点上，然后开始校验。只要有一个节点校验不通过，那么所有节点都不做该操作。
MySQL集群，基于组复制技术，每个节点即是主又是从，每个节点都可以主从复制
实验环境：
server5上安装了MHA管理器，关闭server5.
server2、server3和server4构成MySQL集群。server2为引导节点。
可以根据官方文档进行。
搭建MySQL集群，实现组复制 server3关闭mysqld
server4关闭mysqld
server2关闭mysqld：
将mysql的数据文件清空。（至于数据文件在哪个目录，可以查看/etc/my.cnf中的datadir）
并编写主配置文件
将虚拟机上的mysql卸载，重装了一次，发现 /etc 下没有 my.cnf 文件 !!!
使用mysql --help | grep my.cnf
可以查看到mysql 是从哪些目录读取配置文件的，然后自己 vim my.cnf 并将自己写的 my.cnf 文件放到这个目录中，重启mysql就可以识别自己的配置文件了。
在重启mysql服务之前，一定要确认mysql的数据文件目录是空的。
重启服务之后，进行初始化
server2为引导节点
将server2上的配置文件传到server3上
先将server3的mysqld关闭，并把mysqld的数据文件目录清空。
MySQL初始化
server2为引导节点，server3只需开启组复制即可。
设置server3强制加入
在server2上可以看到集群中成员的状态。
如果看到某个成员，比如server3的状态是RECOVERING，
那么就要查看serve3的日志，cat /var/log/mysqld.log
在做实验的时候，有一次server3的状态是RECOVERING，查看日志，发现是server3和server2上的域名解析没写对。将/etc/hosts文件写正确就好了。
server2将配置文件传给server4
同样地，server4先将mysql服务关闭，并数据文件目录清空。
server4的my.cnf 因为是直接从server2复制来的，直接修改server-id 以及local_address就好
在最后加上，强制加入集群
vim /etc/my.cnf
在server2上查看到集群成员的状态为online
在server2上创建数据库test，并在test中创建表t1，并插入一条数据。
在server3上可以同步到server2上的数据，查看到数据库test，
server3也可以对数据进行写操作
server4上可以读取到server2与server3写的数据
同时，server4也可以写数据
server2上也可以看到server3和server4上写的数据
成员故障 这时，server2突然down。。。
server3看到只有server4和自己是online。
server3再向数据库中写入数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d74869bc074657381687a1b06e3f0594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922256d06de601808acfb14b55946cd7/" rel="bookmark">
			正则匹配yyyy-mm-dd以及数字千分位详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则匹配yyyy-mm-dd以及数字千分位详解 一、yyyy-mm-dd1.被400整除，前两位是4的倍数，后两位是02.被4整除不能被100整除3.四位随机4.月+日表示： yyyy-mm-dd答案为：二、数字千分位 一、yyyy-mm-dd 年：0000-9999 月：00-12
日：1、3、5、7、8、10、12 31-天 4、6、9、11 30-天 2 28-天 闰年29-天
我们分成三部分：
1部分是闰年-能被400整除 2月包括29天
2部分是闰年能被4整除但不能被100整除 2月包括29天
3部分是平年
1.被400整除，前两位是4的倍数，后两位是0 先看4的倍数：00不算
找规律
04 24 44
08 28 48
12 32 52
16 36 56
20 40 60 。。。。。。
可以看出个位及十位都是有规律的 0[48],1[26],2[048],3[26]
表达成正则为：/(0[48]|[2468][048]|[1357][26])00/ 不包含00
2.被4整除不能被100整除 100能被4整除，所以前两位可以是任何数,只要后面是4的倍数就行
可表示为：
/(\d\d(0[48]|[2468][048]|[1357][26]))/
3.四位随机 可表示为：
/\d{4}/
4.月+日表示： 1、3、5、7、8、10、12 ：/(0[13578]|1[02])-(0[1-9]|1\d|2\d|31)/
4、6、9、11：/(0[469]|11)-(0[1-9]|1\d|2\d|30)/
2-28天：/02-(0[1-9]|1\d|2[0-8])/
2-29天：/02-(0[1-9]|1\d|2\d)/ （闰月）
合并表示：
润：
/((0[13578]|1[02])-(0[1-9]|1\d|2\d|31)|(0[469]|11)-(0[1-9]|1\d|2\d|30)|02-(0[1-9]|1\d|2\d))/
^润：
/(0[13578]|1[02])-(0[1-9]|1\d|2\d|31)|(0[469]|11)-(0[1-9]|1\d|2\d|30)|02-(0[1-9]|1\d|2[0-8])/
若不包含^与&amp;的话
合并的答案为：
400 + 4 ^100 + ^润(闰年的年用|合一起，月是一样的)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/922256d06de601808acfb14b55946cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efd86c629ea993930baa95d91866b31/" rel="bookmark">
			＜img＞ 的 title 和 alt 有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签是图片标签
title有标题的意思，有解释说明的作用
html中alt是一种参数属性，alt的作用就是当HTML元素本身的物件无法被渲染时，就可以显示alt文字作为一种补救措施；alt属性主要用于img与area元素中。alt作用
Title是通常当⿏标滑动到元素上的时候显示
alt 是 的特有属性，是图⽚内容的等价描述，⽤于图⽚⽆法加载时显示、读屏器阅读图⽚。可提图⽚⾼可访问性，除了纯装饰图⽚外都必须设置有意义的值，搜索引擎会 重点分析。
（img标签应该在一个块级元素里面这样才能显示出来）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3a425f41304305a5ce63319e3f5677/" rel="bookmark">
			Shell循环语句详解--for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.for循环基本格式二.for循环脚本2.1测试主机状态2.2添加用户2.3乘法表 三.总结 引言：在shell编程中，除了选择判断之外，对一些特殊情况需要进行循环操作，比如遍历目录文件，批量添加用户等操作，都需要循环操作 一.for循环基本格式 语法格式：
for 变量名 in 取值列表 do 命令 done for循环执行次数，取决于取值列表中的变量个数
for i in {1..5};do echo $i;done {1..5}为取值范围1到5 echo $i 输出当前的取值 for((i=1;i&lt;=5;i++));do echo $i;done 使用（（））双括号，可以支持C语言的一些命令 i=1;i&lt;=5;i++ #i初始值为1，如果i小于等于5时执行循环，每次循环后+1 for i in `seq 5`;do echo $i;done seq 5 与{1..5}效果一样 for i in `seq 5`;do echo "hello world";done 使用变量i 循环5次 每次执行echo "hello world"命令 使用for循环遍历当前目录
二.for循环脚本 利用for循环，实现的简单脚本
2.1测试主机状态 检测局域网内，主机存活状态
#!/bin/bash for IP in `cat /root/for/ip.txt` #ip文件为存放ip地址的 do ping -c 3 -i 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad3a425f41304305a5ce63319e3f5677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674eedcfba4e4350adfe8aac33a5b825/" rel="bookmark">
			使用wireshark抓取手机的rtmp推流包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：这种方法只适用于笔记本，台式机如果不能设置共享wifi的话就不能抓包。
1.下载猎豹wifi
猎豹wifi下载
2.解压到非c盘，然后点击安装，记得安装到非C盘，这样好一点
3.然后它会自动将笔记本电脑变成wifi热点，弹出弹框
4.手机连上这个wifi
5.打开wirshark
选择多出来的本地连接2
然后输入rtmpt
5.使用手机向服务器推rtmp数据，可以看到被抓取出来的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b5652a2d85e1a39793bcdc506c1dc2/" rel="bookmark">
			浅析 postMessage 方法介绍、如何接收数据（监听message事件及其属性介绍）、使用postMessage的安全注意事项、具体使用方式（父子页面如何互发消息、接收消息）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postMessage 是 html5 引入的API，postMessage()方法允许来自不同源的脚本采用异步方式进行有效的通信，可以实现跨文本文档、多窗口、跨域消息传递，多用于窗口间数据通信，这也使它成为跨域通信的一种有效的解决方案。
一、Window postMessage() 方法介绍
postMessage() 方法用于安全地实现跨源通信。（只有同源脚本才能相互通信，window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。）
1、语法：otherWindow.postMessage(message, targetOrigin, [transfer]);
（1）otherWindow：其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。
（2）message：将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。
（3）targetOrigin：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。
在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；
只有三者完全匹配，消息才会被发送。
这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。
如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。
（4）transfer可选：是一串和message 同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。
2、接收数据：监听message事件的发生
// 执行如下代码, 其他window可以监听分发的message: window.addEventListener("message", receiveMessage, false); function receiveMessage(event) { var origin = event.origin if (origin !== "http://example.org:8080") return; // ... } message 的属性有:
（1）data：从其他 window 中传递过来的对象。
（2）origin：调用 postMessage 时消息发送方窗口的 origin。
这个字符串由 协议、“😕/“、域名、“ : 端口号”拼接而成。例如 “https://example.org (隐含端口 443)”、“http://example.net (隐含端口 80)”、“http://example.com:8080”。
请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。
（3）source：对发送消息的窗口对象的引用，您可以使用此来在具有不同origin的两个窗口之间建立双向通信。
（4）type: 指的是发送消息的类型;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b5652a2d85e1a39793bcdc506c1dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa39f38f460499db63585f701aee088d/" rel="bookmark">
			应用软件运行速度提升16倍：Lightbits与Ceph的存储性能对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者: Russ Fellows, Mohammad J Rabin
概述 云计算和基于容器的应用是推动当今IT领域产生重大变革的两大趋势。与其他技术和方法相比，二者都能够以更高的灵活性和更低的成本去运行和操作应用，因此日益受到欢迎。然而，在所有新的机遇面前，要实现潜在优势也都会有巨大的挑战。
层出不穷的新技术通常会对业务运营产生渐进式的影响。但是，以云计算作为运行模式，结合管理云原生应用的Kubernetes——这一做法已经改变了信息技术的交付、管理和使用方式。
此外，为支持这些环境而设计的系统需要选择计算、网络，尤其是存储系统，这些系统具备高度可扩展的容量和性能，而无需采用传统管理方式。Kubernetes提供机制，帮助应用以透明的方式利用多种计算和存储资源。但是，要确保应用对持久数据的访问，需要底层存储基础架构具有弹性，同时还能满足成千上万个应用的容量和性能需求。
在此背景下，Evaluator Group获邀对适合云原生应用环境的两种存储系统展开对比。
Ceph：云原生环境中常用的开源软件定义存储Lightbits云数据平台：专为云环境设计的软件定义存储 如下所示，在使用相同硬件和存储介质的情况下，Lightbits在所有工作负载测试中，实现的性能均远远优于Ceph。表1汇总显示了使用QLC介质的NVMe固态硬盘（SSD）的测试结果。该测试使用在OpenShift Kubernetes环境中作为容器运行的工作负载来进行。
Ceph IOPs
Lightbits IOPs
Lightbits Advantage
4K-100% Read
1,032,428 4,068,462 3.94 X
4K-100% Write
30,728 515,697 16.78 X
8K-80% Read
90,363 1,129,335 12.50 X
16K-70% Read
35,740 372,009 10.41 X
32K-50% Read
19,797 111,852 5.65 X
表表1表11表1：在容器环境中使用QLC介质时的Lightbits与Ceph I/O速率比较。
（来源：Evaluator Group）
本文的其余部分将更深入地探讨二者的技术和性能差异，以及使用NVMe SSD与TLC介质时的性能数据。
新兴技术 如前所述，多个趋势正在推动IT领域发生重大变化；其中，利用公共云等服务的趋势正在改变IT运行的地点和付费方式，影响了应用程序的运行方式。云原生应用程序（CNA）的推行正在改变应用程序的开发和管理方式，这在一定程度上得益于企业向服务和云端迁移的趋势。此外，可通过Fabric去访问NVMe存储的新技术，以及新的非易失性存储技术的出现，使得那些能够利用这些功能的系统拥有显著的性能优势。
云原生应用程序 基于容器的应用程序设计旨在运行于云环境，包括本地云和公共云。云原生应用程序被设计为可独立扩展的服务，又称为微服务。借助微服务架构，CNA能够在少量或甚至无需管理介入的情况下，按需扩展应用程序的各个部分。
此外，CNA部署在一个位置后，可以根据可用资源甚至根据资源的价格而移动到其他位置。另外，许多此类应用程序所需的持久性存储也必须动态响应不断变化的容量和性能需求。
NVMe over Fabrics协议 非易失性存储主机控制器接口规范（NVMe）是一个支持固态硬盘（SSD）去使用高速PCIe总线进行通信的接口，以实现对固态设备的低时延访问。与SCSI或SATA设备相比，NVMe支持数十亿条命令，显著减少了延迟或时延。为了兼容与外部设备的通信，NVMe over Fabrics扩展了NVMe协议，支持通过Fabric去访问NVMe。
NVMe over Fabric访问的最新选择之一是使用TCP传输协议，即NVMe/TCP。实施这项协议的技术负担可显著减少，无需任何特定的硬件或交换机设置即可支持商用以太网。总体而言，与TCP上的其他存储协议相比，在仍然使用现有网络基础设施的情况下，NVMe over TCP具有更低的时延和更高的吞吐量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa39f38f460499db63585f701aee088d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e549e920edf5a2b90d66dd0e2e1d9c2a/" rel="bookmark">
			ICEM绘制体积网格的基本操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 (一) 在开始菜单中找到ICEM，单击打开
(二) 左上角File工具栏设置工作文件夹
(三) 左上角File工具栏import geometry 导入STL文件
(四) 设置右键surface，点击solid和transparent
这样可以让几何体看起来更舒服
(五) 右键part，点击add part
全选所有的面，命名为wall
(六)点击Mesh 设置全局属性
根据我的工况，设置Sclae factor 为1000，最大单元尺寸为15
点击Compute mesh 注意选择体积网格
点击Compute
观察网格的数量和大小，如果不合适，换另外的Scale factor重新生成网格
清除网格：
左上角的Close mesh可以清除网格 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22e0708e7b0e62758f576ec57535535/" rel="bookmark">
			Vue2.0教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Vue入门 1、概述 ​ 在众多的语言排名中，JavaScript 已经非常靠前，它是前端的核心编程语言，我们可以利用 js 开发 动态 效果的网页，也可以开发 app，为了简化 JavaScript 的使用，在其基础上，发展出两个门派：
真实 DOM 操作的 jQuery 门派，例如：bootstrap、layui、easyui 都使用了 jQuery 技术。
虚拟 DOM 操作门派，复杂的如 angular.js ，简单的国产框架
我们以虚拟 DOM 操作的 vue.js 为例它有以下优点：
它的核心库文件只有 jQuery 的 1/3，这非常有利于用于移动端 ;采用虚拟 DOM，只有在必须的时候才去操作真实 DOM，让显示性用数据 来驱动 呈现，在数据和表现控件 之间 建立一个适时互通 通道，任一方的改变，另一方也直 接改变，在通道构建完毕后，程序员进行业务逻辑处理时，只考虑数据，呈现完全自动化。 1.1、Vue到底是什么？ ​ 官方解读：Vue (读音 /vju:/，类似于 view) 是一套用于构建用户界面的"渐进式框架"。与其它大型框架 不同的是，Vue 被设计为可以"自底向上逐层应用"。Vue 的核心库只关注"视图层"，易于上手，便于与第三方库 或既有项目整合。
​ 简单来说，Vue 就是一个用于搭建表单项繁多且内容需要根据用户的操作进行修改的网页应用的框架。
1.2、为什么要使用Vue？ 使用 JQuery 也可以完成相应的功能啊，为什么还要使用 Vue？
​ jQuery 是使用选择器（$）选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，其实和原生的 HTML 的 区别只在于可以更方便的选取和操作 DOM 对象，而数据和界面是在一起的。比如需要获取 label 标签的内容： $(“lable”).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c22e0708e7b0e62758f576ec57535535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817f8922f7894aad4479fff2cec6c3ae/" rel="bookmark">
			嵌入式人工智能/机器学习（AI/ML）以“生态&#43;集成&#43;定制”差异化发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：陈娇 刘朝晖
随着嵌入式处理器的能力不断提升，超小型化的硬件加速器不断被引入，以及原厂及商业的开发环境和工具不断出现，嵌入式人工智能/机器学习（AI/ML）技术在近几年得到了快速的发展。同时因为这些技术与千姿百态的各种应用需求十分贴近，因此正在进入差异化发展的新空间，未来其增长速度将可以比肩甚至超过需要强大资源体系的、立足良好通信条件的和基于云的人工智能应用。
人工智能并不是一个近几年才提出的名词，但是在近几年随着谷歌AlphaGo战胜人类围棋世界冠军等事件的推动，才使诸如卷积神经网络、深度学习和机器学习等技术走进了大众的视野，同时也使“人工智能=数据+算法+算力”的模型得到广泛的认同。
其结果是，在很多人的印象中，人工智能和机器学习就是在英特尔最新服务器处理器或者英伟达的GPU加速模组的基础上的全新的、巨大的算法应用，特别是人工智能的训练更是一场资源消耗战，成为了进入门槛很高的新兴领域，传统上设计MCU或者SoC的芯片企业基本上与高贵的AI/ML无缘。
但是人们很快发现在非常领先的人工智能企业所提供的解决方案中，不仅包括诸如自动驾驶路况分析、自然语言处理、快速医学影像识别和高频金融交易等复杂功能，也包括更大量车牌识别、智能音箱唤醒词识别、便携智能健康监测设备、人脸识别开机和智能家居安防等Lite级别的应用。
在市场强烈需求的拉动下，随着谷歌的开源TensorFlow Lite嵌入式机器学习架构和类似产品的推出，以及诸如Imagination公司的PowerVR神经网络加速器（NNA）等硬件加速器在移动设备或嵌入式设备上商用，各种功耗和成本更低的，以及更加小巧的嵌入式AI/ML功能解决方案不断涌现。
通过分析，北京华兴万邦管理咨询有限公司认为：嵌入式AI/ML的广泛兴起，带来了与传统AI技术以“人工智能=数据+算法+算力”为中心的发展范式不同的新模式，针对特定或者一些应用和功能的嵌入式AI/ML的重点已转向“生态+集成+定制”。下面我们从融入物联网生态、硬件和商用开发工具集成、以及基于RISC-V开发定制处理器这三个方面来进行分析：
为嵌入式AI/ML带来最新Matter协议和物联网大生态
Silicon Labs（亦称“芯科科技”）是一家全球领先的物联网芯片、软件和解决方案供应商，该公司在业界以支持最全面的物联网通信协议和提供优异的产品性能而著名，其客户包括智能家居、智慧城市、工业与商业、智慧医疗和能源等领域内的领导厂商。
今年初，该公司宣布推出其BG24和MG24系列2.4 GHz无线SoC，它们不仅都支持最新的Matter物联网通信协议，还分别支持蓝牙和多协议操作，同时还为电池供电的边缘设备和应用提供了人工智能/机器学习功能，并带来了高性能无线功能和物联网大生态。
BG24和MG24无线SoC代表业界前沿的生态、功能和技术组合，其中包括支持无线多协议、长电池寿命（低功耗）、机器学习、以及面向物联网边缘应用的安全性。Silicon Labs为它们提供的全新软件工具包支持开发人员通过一些常用的工具套件（如TensorFlow），来快速构建及部署AI/ML算法。
为了实现AI/ML算力，BG24和MG24系列率先集成了专用的AI/ML加速器，帮助开发人员部署人工智能或机器学习功能并解决功耗难题。这种专用硬件旨在快速高效地处理复杂计算，内部测试显示其性能提升最高达4倍，能效提升最多达6倍。由于机器学习计算是在本地设备上而不是在云端进行，因此消除了网络延迟，加快了决策和行动。
此外，BG24和MG24系列还具有Silicon Labs产品组合中最大的闪存和随机存取存储器（RAM）容量，使其可支持多协议、Matter以及用大型数据集训练ML算法。这些芯片载有获得了PSA 3级认证的Secure VaultTM物联网安全技术，可为门锁、医疗设备和其他需小心部署的产品提供所需的高安全性。
高集成度嵌入式AI/ML配合领先商用开发工具
IAR Systems是嵌入式开发软件和服务的全球领导者，其领先的IAR Embedded Workbench®工具链已在全球获得广泛采用。IAR Systems的开发工具为Alif Semiconductor™高集成度的Ensemble™和Crescendo™系列芯片提供支持，打造了基于人工智能的、高效的微控制器（MCU）和融合处理器，赋能下一代嵌入式互联应用。
对更多功能的集成代表了嵌入式AI/ML的一个发展方向，Alif Semiconductor的这些高能效产品系列提供多达4个处理内核，以及人工智能/机器学习（AI/ML）加速、多层安全、集成的LTE Cat-M1和NB-IoT连接、全球导航卫星系统（GNSS）定位等功能，从而使其应用范围得到了大幅扩展。
为了让这些功能得到更好的发挥，就需要利用诸如IAR Systems的Arm开发工具这些在行业中已被验证过的、领先的编译器技术，对代码大小和速度都进行优化，另外还提供高性能的调试功能，从而为企业提供了一个很好的平台。
2021年11月，IAR Systems宣布其最新版本的IAR Embedded Workbench for Arm®增加了对Arm Cortex®-M55处理器的支持。该处理器是一款支持AI技术的Cortex-M系列处理器，带来了节能的数字信号处理（DSP）和机器学习功能。
双方此次合作可以支持Ensemble或Crescendo器件的应用开发商利用IAR Embedded Workbench® for Arm开发工具链，以实现高性能的且强大的代码优化功能，充分发挥器件的AI/ML潜能，同时又尽可能地保持能源效率。
RISC-V使嵌入式AI/ML可针对边缘应用实现定制
多样化的需求是嵌入式应用的特征之一，MCU供应商长期以来是通过不同的处理器内核与外设搭配来满足用户的个性化需求。而RISC-V的兴起，带来了定制处理器这一新的潮流，这一潮流将继续延伸到嵌入式AI/ML领域，并得到业内领先厂商的支持。
Codasip就是一家提供领先的RISC-V处理器IP和高级处理器设计工具的供应商，为IC设计者提供RISC-V开放ISA的所有优势，以及定制处理器IP的独特能力。Codasip在今年2月推出了两款专为定制处理器而优化的最新低功耗嵌入式RISC-V处理器内核L31和L11。
基于这些新内核，客户可以很方便地使用Codasip Studio工具去定制处理器设计，以支持诸如神经网络、AI/ML等具有挑战性的应用，包括例如物联网边缘计算等极小型化的、功率受限的应用。Codasip的内核可定制功能是其成功的基石，目前全球已有超过20亿颗处理器使用了Codasip的IP。
Codasip L31/L11嵌入式内核运行在谷歌的TensorFlow Lite for Microcontrollers（TFLite Micro）上，并利用Codasip Studio工具定制一类全新的嵌入式AI内核，可为AI/ML计算密集型和内部资源有限的嵌入式系统等应用提供足够的性能。不同应用对器件的需求也有巨大的差异，而且现有的处理器并不能很好地加载AI/ML应用。
Codasip可提供“创造差异化设计”模式，意味着使用其Studio工具的客户，可以根据其特定系统、软件及应用程序的要求来定制处理器。通过将TFLite Micro）、RISC-V定制指令以及Codasip处理器设计工具三者相结合，就可以为嵌入式的、高效率的边缘神经网络处理功能带来低延迟、高安全性、快速通信和低功耗等优势。
展望未来：新的应用与新的技术都将不断涌现
随着产业的发展，嵌入式AI/ML技术和应用都将得到进一步的发展，基于华兴万邦提出的“生态+集成+定制”新范式，以及不断推陈出新的边缘应用，我们可以看到在未来一些新的技术值得高度关注，比如新的、适合边缘应用的硬件加速器和安全技术。
以硬件加速器为例，近年来广泛兴起并得到高度关注的xPU将会从云端走向嵌入式应用；在一些应用场景中，还需要针对算法和标准的演进和升级对硬件进行再编程，那么诸如Achronix公司的Speedcore嵌入式FPGA（eFPGA）这样的IP产品也会从服务器和数据中心市场走入嵌入式AI/ML应用，推动采用不同硬件加速器的异构计算模式向前发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32d50a1abdbc6b7b4eab16ce533f3176/" rel="bookmark">
			Nacos 获取配置时启用权限认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下获取 Nacos 中的配置是不需要权限认证的, 这个估计是由其使用场景决定的(绝大多数都是仅内网可访问).
今天调查了下如何在获取配置时增加权限验证以提高其安全性.
1. 启用 Nacos 的权限认证 只要 nacos.core.auth.enabled 设置为 true 就行了.
### If turn on auth system: nacos.core.auth.enabled=true 2. 添加 Nacos 用户 默认的用户 nacos 绑定的角色是 ROLE_ADMIN , 权限比较大, 最好是新增一个只读的用户用来读取对应命名空间(namespace)的配置.
权限控制 -&gt; 用户列表 中新增用户权限控制 -&gt; 角色管理 中新增用户对应的角色
一个用户可以绑定多个角色.权限控制 -&gt; 权限管理 中新增角色对应的权限
可以设置角色对应的命名空间(页面上名称为资源), 在动作下拉框中指定读写权限(只读\只写\读写).
一个角色可以配置多个权限. 合理的使用 namespace 和 group 来隔离配置文件, 再辅以用户的角色、权限控制, 组合的权限策略还是比较灵活的, 应该能满足大多数项目的安全需求.
创建好用户后可以通过 curl 命令验证一下效果.
curl -XGET 'http://localhost:8848/nacos/v1/cs/configs?dataId=test.yaml&amp;group=DEFAULT_GROUP&amp;tenant=&amp;username=test&amp;password=123456' 这里需要注意的是默认的 public 命名空间对应的值是空字符串, 而不是 public .
在 PowerShell 中对应的命令:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32d50a1abdbc6b7b4eab16ce533f3176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c23d4dd7a1e7807df8e1da5be2ae1e0/" rel="bookmark">
			JAVA_求最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JAVA_求最小公倍数 题目链接
思路:
1.首先计算m和n中的较大者，用max记录。
2.然后利用循环，在max到m*n之间找最小公倍数。
3.如果既能被m整除又能被n整除，说明是最小公倍数，直接返回。
代码：
import java.util.*; public class Main { public static void main(String[] args) { Scanner console = new Scanner(System.in); int m = console.nextInt(); int n = console.nextInt(); int result = getCM(m, n); System.out.println(result); } public static int getCM(int m, int n){ //write your code here...... //从max到m*n之间找最小公倍数 for( int i= (m&gt;n?m:n);i&lt;=m*n;i++){ //如果既能被m整除又能被n整除，说明是最小公倍数，直接返回 if(i%n==0&amp;&amp;i%m==0){ return i; } } return -1; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84dd3dc142a3252964354c8dfab4c59/" rel="bookmark">
			Servlet访问URL 使用*通配符 映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Servlet访问URL 使用*通配符 映射 在Servlet映射到的URL中也可以使用通配符，但是只能有两种固定的格式：一种格式是".扩展名"，另一种格式是以正斜杠（/）开头并以"/"结尾 。例如：
对于如下的一些映射关系：
Servlet1 映射到 /abc/
Servlet2 映射到 /*
Servlet3 映射到 /abc
Servlet4 映射到 .do
问题：
当请求URL为“/abc/a.html”，“/abc/”和“/”都匹配，哪个servlet响应
Servlet引擎将调用Servlet1。
当请求URL为“/abc”时，“/abc/”和“/abc”都匹配，哪个servlet响应
Servlet引擎将调用Servlet3。**
当请求URL为“/abc/a.do”时，“/abc/”和“.do”都匹配，哪个servlet响应
Servlet引擎将调用Servlet1。
当请求URL为“/a.do”时，“/”和“.do”都匹配，哪个servlet响应
Servlet引擎将调用Servlet2。
当请求URL为“/xxx/yyy/a.do”时，“/”和“.do”都匹配，哪个servlet响应
Servlet引擎将调用Servlet2。
匹配的原则就是"谁长得更像就找谁"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b6da3db4ec7f2a13f0c1f54fd8018d/" rel="bookmark">
			git merge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有如下版本日志
创建分支提交后的版本日志如下
在dev1分支上进行合并操作git merge master，此时将master的两个提交d3,36放到dev指向的8cc48ec(HEAD)后面。此时d405874有两个子节点。同时生成一个合并的786dc72作为两个分支HEAD指向的子节点，
即786dc72有两个子节点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84413e5a9ead84921d7fe3e06b4cceda/" rel="bookmark">
			Jetson TX2零基础学习（一）——连线、刷机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景介绍
二、连线
三、刷机
四、鸣谢
五、结束语
系列文章
一、背景介绍 大家好，我是潇湘小硕士，注册账号已经两年有余，今天第一次发文，希望能够帮助到大家。
我是通信专业研一学生一枚，前几天组里给我两块板卡：Jetson Nano和Jetson TX2，用来参加研电赛，做的是目标检测方向的一个软件，程序在windows已经跑通，下一步是移植到板卡上，从没接触过板卡的我该怎么做呢？我先选择的Jetson nano，费了好大劲完成了烧录、安装pip3、pytorch、torchvision和pycharm，但是由于性能原因，跑程序直接卡住（卡住不要断电，等它自己运行好，时间很久）。之后我开始用Jetson TX2，这个以前有师兄之前装的系统，但是又由于某种原因一跑程序就自动停止，确定难以解决后，我选择刷机，过程中还是遇到不少困难的，特此记录下来，方便之后学习的同学。
二、连线 这是我调完的样子，程序都可以正常运行，在干活之前你需要准备一些东西：一个USB扩展器（因为USB接口只有一个，鼠标和键盘需要两个口，还要插U盘）、小显示器（必须是用HDMI线的，不能用转接，否则不识别）、U盘、键盘和鼠标。如果要参赛展示成果的话，显示器还是买好点的吧，我这个显示就不怎么清晰，如图所示
我是用pycharm来跑的，还是很方便的。所有过程我都会介绍，本篇文章先说连线和刷机。我们先来研究一下板卡的接口
需要插六个接口，我从左到右介绍一下：第一个是电源线接口（圆孔），第二个和第三个是天线接口（需要拧进去），第四个是板卡与电脑的连接线接口（非常重要，保存好），第五个是USB接口（插USB扩展器），第六个口是显示器接口（HDMI线）。把这些线插好之后，正式开机！视线转向板卡另一侧，看按钮
最右边的按钮是开机键，按住2秒，灯亮就表示开机成功，可以松开了，如果按一下就松开是不会启动的。启动后照片如图所示
那么连线部分就介绍到这里，下节是刷机过程。
三、刷机 刷机我参考了站内两位高手分享的教程，地址贴在这里，非常感谢！
http://t.csdn.cn/f8EFd
http://t.csdn.cn/uYJrW
简单来说就是先要在你的电脑上装个VMware虚拟机，然后安装ubuntu18.04镜像，给虚拟机分配80G以上存储，这个网上有很多教程就不细说了，装好之后，你要先下载一个软件：NVIDIA SDK Manager
下载地址：NVIDIA SDK Manager | NVIDIA Developer
【没有NVDIA账号先注册，最好科学上网，否则很难z注册和下载】
如果你不方便下载的话，我把我下载好的资源分享给你
链接：https://pan.baidu.com/s/15Nt4A0Hh1h2b_LtCDAiEMA 提取码：lha6
下载好了放进U盘里
将U盘插上，与虚拟机连接，把安装包拷贝到虚拟机中，如果虚拟机不识别U盘的话可能是USB控制器关闭了，站内也有很多教程，这里不详述了。
接下来就是安装sdkmanager了，打开命令框，输入下面的指令（注意输入指令时应该先进入到安装包所在路径，-i后面是你的安装包名字）
#sudo dpkg -i 安装包路径 （这是代码格式，无需输入） sudo dpkg -i sdkmanager_1.7.3-9053_amd64 安装好了之后，在命令框输入sdkmanager 即可启动
登录之后，就可以把板卡与电脑连接了，也就是把那根连接线的USB端插在电脑上，记得选择与虚拟机连接。
注意：画红线处必须显示了板卡才能点继续
对比站内其他教程，我发现我的这个最新版的sdkmanager多了个HOST COMPONENTS，不过事实证明这个里面的东西下载成功与否，不影响板卡。所以TARGET COMPONENTS 是我们必须成功安装的。打勾按照我图中来点就可以。点继续之前，先科学上网，否则有一定概率会在中途失败。后面我就没截图了，我从这个博客http://t.csdn.cn/f8EFd转载几张图来为大家介绍我的经验，再次感谢这位作者的博客。
建议下载时不要最小化，一直保持在虚拟机中，开始下载一段时间后会弹出这个窗口，这就是下载好了问你是不是要开始往板卡烧录系统，选择Manual Setup，点击Flash开始烧录
过一段时间系统就会烧录完成，然后回到板卡，进行Linux系统的设置，设置好了之后换源，在命令框输入下面的命令
sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup sudo gedit /etc/apt/sources.list 打开源文件后，将里面的内容全部删除，把下面的代码复制粘贴到源文件中
deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84413e5a9ead84921d7fe3e06b4cceda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114919f2beb217413366b9d301318075/" rel="bookmark">
			09.语义分割和数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义分割 PDF：part-2_13.pdf (d2l.ai)
视频：46 语义分割和数据集【动手学深度学习v2】_哔哩哔哩_bilibili
语义分割（semantic segmentation）问题重点关注于如何将图像分割成属于不同语义类别的区域。 与目标检测不同，语义分割可以识别并理解图像中每一个像素的内容：其语义区域的标注和预测是像素级的。与目标检测相比，语义分割标注的像素级的边框显然更加精细。
图像分割和实例分割 计算机视觉领域还有2个与语义分割相似的重要问题，即图像分割（image segmentation）和实例分割（instance segmentation）。 我们在这里将它们同语义分割简单区分一下。
图像分割将图像划分为若干组成区域，这类问题的方法通常利用图像中像素之间的相关性。它在训练时不需要有关图像像素的标签信息，在预测时也无法保证分割出的区域具有我们希望得到的语义。以下面以黑色为主的嘴和眼睛，另一个覆盖以黄色为主的其余部分身体。
实例分割也叫同时检测并分割（simultaneous detection and segmentation），它研究如何识别图像中各个目标实例的像素级区域。与语义分割不同，实例分割不仅需要区分语义，还要区分不同的目标实例。例如，如果图像中有两条狗，则实例分割需要区分像素属于的两条狗中的哪一条。
语义分割数据集 书籍：13.9. 语义分割和数据集 — 动手学深度学习 2.0.0-beta0 documentation (d2l.ai)
代码：semantic-segmentation-and-dataset slides (d2l.ai)
视频：46 语义分割和数据集【动手学深度学习v2】_哔哩哔哩_bilibili
[最重要的语义分割数据集之一是Pascal VOC2012。] 下面我们深入了解一下这个数据集。
import os import torch import torchvision from d2l import torch as d2l 数据集的tar文件大约为2GB，所以下载可能需要一段时间。 提取出的数据集位于../data/VOCdevkit/VOC2012。
#@save d2l.DATA_HUB['voc2012'] = (d2l.DATA_URL + 'VOCtrainval_11-May-2012.tar', '4e443f8a2eca6b1dac8a6c57641b67dd40621a49') voc_dir = d2l.download_extract('voc2012', 'VOCdevkit/VOC2012') # voc_dir是voc2012的根目录 Downloading …\data\VOCtrainval_11-May-2012.tar from http://d2l-data.s3-accelerate.amazonaws.com/VOCtrainval_11-May-2012.tar…
下载数据完成后，删除上面的下载代码，把voc_dir的值改为voc_dir = "../data/VOCdevkit/VOC2012"。防止每次调试运行都会下载解压代码浪费时间。
进入路径../data/VOCdevkit/VOC2012之后，我们可以看到数据集的不同组件。 ImageSets/Segmentation路径包含用于训练和测试样本的文本文件，而JPEGImages和SegmentationClass路径分别存储着每个示例的输入图像和标签。 此处的标签也采用图像格式，其尺寸和它所标注的输入图像的尺寸相同。 此外，标签中颜色相同的像素属于同一个语义类别。 下面将read_voc_images函数定义为[将所有输入的图像和标签读入内存]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/114919f2beb217413366b9d301318075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21feff47d4aab0685ca0d8ef263a943a/" rel="bookmark">
			海康工业相机SDK &#43; OpenCV实例(3)：相机初始化Bug调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康工业相机SDK + OpenCV实例(3)： 相机初始化Bug调试 文章目录 海康工业相机SDK + OpenCV实例(3)：相机初始化Bug调试前言一、心跳时间设置二、相机先关闭再打开 前言 前文海康工业相机SDK+OpenCV实例(2)：RawDataFormatConvert详解中，以RawDataFormatConvert为例，讲解了海康工业相机的基本操作与转为Mat格式的操作。但是在实际应用中，相机开关初始化遇到了种种不便利的情况。
（1）调试时期，相机默认的心跳时间为60s，导致重启周期很长。
（2）当相机已经打开或者连接，再次访问，导致开机报错。
基于上述可能存在的问题，本文进行调试。
一、心跳时间设置 相机在调试过程，在程序中，若相机已经开机，如果在程序异常退出前相机没有进行相应的关机操作，会导致一段时间内相机无法连接，这个时间就叫心跳时间。海康相机默认的心跳时间为60s，这意味着如果程序异常跳出，海康相机60s内不能重新进行连接，这会给相机的调试带来困扰。
海康工业相机SDK提供了心跳时间HeartBeatTimeout设置的接口MV_CC_SetHeartBeatTimeout，可以在相机开机后加入下述程序段，设置心跳时间为3s（心跳时间的最小值为500ms）。
int HeartBeatTimeout = 3000; nRet = MV_CC_SetHeartBeatTimeout(handle, HeartBeatTimeout); if (MV_OK != nRet) { printf("Set HeartBeatTimeout fail! nRet [0x%x]\n", nRet); } 尽管重新设置了心跳时间，但也不排除在极短的心跳时间内，程序需要重新启动。我们可以通过一个判断设备是否可达的接口MV_CC_IsDeviceAccessible，倘若当前相机仍然处于心跳时间内，程序会自动等待心跳时间。
nRet = MV_CC_IsDeviceAccessible(stDeviceList.pDeviceInfo[nIndex], MV_ACCESS_Exclusive); if (nRet == 0) Sleep(3000); MV_ACCESS_Exclusive是一种相机访问模式，具体种类可详见于SDK。
二、相机先关闭再打开 当相机已经在服务端被打开，客户端初次连接后，倘若客户端异常跳出，没有下达相机关闭指令，当客户端再次尝试连接相机时，由于相机已经打开，会有相机开机异常的报错。
因此，我们可以尝试在每次连接相机之前，先调用判断相机连接状态的接口MV_CC_IsDeviceConnected，倘若相机已经连接，尝试先关闭再打开相机；倘若，相机没有连接，直接打开相机。
//判断设备是否已经连接，如果已经连接，尝试先关闭相机 nRet = MV_CC_IsDeviceConnected(handle); if (nRet == 1) { nRet = MV_CC_CloseDevice(handle); if (MV_OK != nRet) { printf("ClosDevice fail! nRet [0x%x]\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21feff47d4aab0685ca0d8ef263a943a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8977996f1012bd887807307976d436/" rel="bookmark">
			为什么Creating a tensor from a list of numpy.ndarrays is extremely slow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题简介 今天运行一个DQN的代码时出现了如下图的warning：
UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at C:\cb\pytorch_1000000000000\work\torch\csrc\utils\tensor_new.cpp:210.) state = torch.tensor([state], dtype=torch.float).to(self.device) 警告说我们创建用一个包含numpy.ndarrays的列表创建tensor太慢了，建议我们转换为tensor之前考虑用numpy.array()将列表转换为一个单独的numpy.ndarry。
所以就想对tensor的转换这部分学习一下。
找到一篇文章：https://zhuanlan.zhihu.com/p/429901066
这篇文章介绍了一下这个问题，但是自己对于代码运行过程中数据类型的变换不是很懂，想弄透彻一点，所以记录一下代码的调试过程中变量类型的变换。
2.实验与结论 先说结论
如果list中没有ndarrays，则选择list-&gt;tensor更快。
如果list中有ndarrays，则选择list-&gt;ndarrays-&gt;tensor更快；
注：为了减小偶然因素的影响，所以将转换的部分运行10遍
2.1 list-&gt;tensor（注：list中的元素不含numpy.ndarrays） import numpy as np import torch import time l = [i for i in range(50000000)] # 五千万 stime = time.time() for _ in range(10): a = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c8977996f1012bd887807307976d436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5628c0e8a03d91c95ec85a22e6b6165b/" rel="bookmark">
			小程序获取不了用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在资源网下载的跑腿小程序，获取不了头像昵称，后台也看不到，哪位大佬能帮忙解决一下，谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7340ceb408b31e011f452608adbfc10b/" rel="bookmark">
			Androidstudio的约束布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面我们开始用边学边练的方式来进行学习，首先打开你的Android Studio，并新建一个ConstraintLayoutTest项目。另外，确保你的Android Studio是2.2或以上版本。
为了要使用ConstraintLayout，我们需要在app/build.gradle文件中添加ConstraintLayout的依赖，如下所示。
dependencies { compile 'com.android.support.constraint:constraint-layout:1.0.0-beta4' }
1
2
3
目前ConstraintLayout库最新的版本是1.0.0-beta4，还没有推出正式稳定版本，不过这并不影响我们提前进行学习和使用。
现在打开res/layout/activity_main.xml文件，由于这是一个新建的空项目，Android Studio会自动帮我们创建好一个布局，如下图所示。
不过，Android Studio自动创建的这个布局默认使用的是RelativeLayout，我们可以通过如下操作将它转换成ConstraintLayout。
转换完成之后，原RelativeLayout中的内容也会自动转换到ConstraintLayout中，比如图中的TextView。如果你不需要它的话，可以选中这个控件，然后按键盘上的Delete键即可删除。
我们可以看到，现在主操作区域内有两个类似于手机屏幕的界面，左边的是预览界面，右边的是蓝图界面。这两部分都可以用于进行布局编辑工作，区别是左边部分主要用于预览最终的界面效果，右边部分主要用于观察界面内各个控件的约束情况。
[](()基本操作
====================================================================
下面我们来学习一些具体的操作吧，ConstraintLayout的基本用法很简单，比如我们想要向布局中添加一个按钮，那么只需要从左侧的Palette区域拖一个Button进去就可以了，如下图所示。
虽说现在Button已经添加到界面上了，但是由于我们还没有给Button添加任何的约束，因此Button并不知道自己应该出现在什么位置。现在我们在预览界面上看到的Button位置并不是它最终运行后的实际位置，如果一个控件没有添加任何约束的话，它在运行之后会自动位于界面的左上角。
那么下面我们就来给Button添加约束，每个控件的约束都分为垂直和水平两类，一共可以在四个方向上给控件添加约束，如下图所示。
上图中Button的上下左右各有一个圆圈，这圆圈就是用来添加约束的，我们可以将约束添加到ConstraintLayout，也可以将约束添加到另一个控件。比如说，想让Button位于布局的右下角，就可以这样添加约束，如下图所示。
我们给Button的右边和下边添加了约束，因此Button就会将自己定位到布局的右下角了。类似地，如果我们想要让Button居中显示，那么就需要给它的上下左右都添加约束，如下图所示。
这就是添加约束最基本的用法了。
除此之外，我们还可以使用约束让一个控件相对于另一个控件进行定位。比如说，我们希望再添加一个Button，让它位于第一个Button的正下方，并且间距64dp，那么操作如下所示。
现在添加约束的方式我们已经学完了，那么该怎样删除约束呢？其实也很简单，删除约束的方式一共有三种，第一种用于删除一个单独的约束，将鼠标悬浮在某个约束的圆圈上，然后该圆圈会变成红色，这个时候单击一下就能删除了，如下图所示。
第二种用于删除某一个控件的所有约束，选中一个控件，然后它的左下角会出现一个删除约束的图标，点击该图标就能删除当前控件的所有约束了，如下所示。
第三种用于删除当前界面中的所有约束，点击工具栏中的删除约束图标即可，如下图所示。
[](()Inspector
=========================================================================
这样我们就把ConstraintLayout的基本用法学完了，接 《Android学习笔记总结+最新移动架构视频+大厂安卓面试真题+项目实战源码讲义》无偿开源 徽信搜索公众号【编程进阶路】 下来我们开始学习一些进阶的内容。
当你选中任意一个控件的时候，在右侧的Properties区域就会出现很多的属性选项，如下图所示。
在这里我们就可以设置当前控件的所有属性，如文本内容、颜色、点击事件等等。这些功能都非常简单，我就不再进行详细介绍，大家自己点一点就会操作了。
需要我们重点掌握的是Properties区域的上半部分，这部分也被称为Inspector。
首先可以看到，在Inspector中有一个纵向的轴和一个横向的轴，这两个轴也是用于确定控件的位置的。我们刚才给Button的上下左右各添加了一个约束，然后Button就能居中显示了，其实就是因为这里纵横轴的值都是50。如果调整了纵横轴的比例，那么Button的位置也会随之改变，如下图所示。
不过，虽然我们将横轴的值拖动到了100，但是Button并没有紧贴到布局的最右侧，这是为什么呢？实际上，Android Studio给控件的每个方向上的约束都默认添加了一个16dp的间距，从Inspector上面也可以明显地看出来这些间距的值。如果这些默认值并不是你想要的，可以直接在Inspector上进行修改，如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997725f1d9994d6192690d6d11b0a22a/" rel="bookmark">
			Java中 String 转 Long 类型需要注意的事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java中 String 转 Long 类型需要注意的事项 注意事项：
1.字符串内不能包含除数字之外的字符
不然会报错，java.lang.NumberFormatException
2.字符串长度要限制，不然也会出错
比如：String s =“20160926120625100000”，超过19位，就会出错，报java.lang.NumberFormatException
String s =“2016092612062510000”，不超过19位就不会
原因是Long类型的最大值位 Long.MAX_VALUE = 9223372036854775807，大于这个值都会出错
Long类型的最小值位 Long.MIN_VALUE=-9223372036854775808，小于这个值也会报错
String 转 Long
Long.ValueOf(String); 返回Long包装类 Long.parseLong(String); 返回long基本数据类型 Long 转字符串
// 第一种： String s = String.valueOf(long) // 第二种： String s = Long.toString(long) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78cbd711a85586c8b875795d730dff2d/" rel="bookmark">
			攻防世界-shrine write up
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开靶机，发现源码是没有排序的python代码，CTRL+u 查看源码：
可知：引入了flask和os库，render_template_string（）函数说明引入了SSTI（详见上一篇easy_tornado1），
@app.route('/shrine/&lt;path:shrine&gt;') 在/shrine/路径下提交参数，
app.config['FLAG'] = os.environ.pop('FLAG') 说明注册了FLAG，而flag可能就在这里面，
s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] 这两行说明他把（和）都替换成了空格，而且把config跟self加进了黑名单，那么就不能使用config来查看FLAG的内容了，没有过滤可以直接{undefined{config}}查看所有app.config。
return ''.join(['{{% set {}=None% }}'.format(c) for c in blacklist]) + s 这一行把blacklist里的所有东西遍历为空。
但是pythonflask框架有其他内置函数和·变量：Python中Flask框架的变量和函数 - 简书 (jianshu.com)
用内置函数url_for，构造payload:
/shrine/{{url_for.__globals__}}
图上传不了了，，救命，反正就是会发现一大堆代码，中间有个非常亮眼的 'current_app': &lt;Flask 'app'&gt;。利用url_for()函数查看current_app里的flag:
构建payload：/shrine/{{url_for.__globals__['current_app'].config['FLAG']}}
或者用get_flashed_message函数：
构建payload：
/shrine/{{get_flashed_messages.__globals__['current_app'].config['FLAG']}}
flag：flag{shrine_is_good_ssti}（岂可休，我上传不了图片orz）
拓展：
url_for：
会根据传入的路由器函数名,返回该路由对应的URL,在模板中始终使用url_for()就可以安全的修改路由绑定的URL,则不比担心模板中渲染出错的链接，经常用于超链接
get_flashed_message：
这个函数返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ae52c5e605ff2171a80095d4221d5d/" rel="bookmark">
			ctfshow SQL注入Web171-174
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		42022/4/24
SQL注入 Web171 语法：查询表中的数据
查询所有行
命令： select &lt;字段1，字段2，...&gt; from &lt; 表名 &gt; where &lt; 条件&gt;
例如：查看表 MyClass 中所有数据
mysql&gt; select * from MyClass;查询语句
//拼接sql语句查找指定ID用户
$sql = "select username,password from user where username !='flag' and id = '".$_GET['id']."' limit 1;";
select username,password from user where username !='flag' and id = ‘10000’;(输入一个很大的，表中没有的值或者-1) or id=’26’ limit 1;
Playload:
10000’ or id=’26 试了一下25不是，就试一下26
ctfshow{4d873b5b-6861-4d54-bed8-7e3b857d878a} Web172 "select username,password from ctfshow_user2 where username !='flag' and id = '注入的地方' limit 1;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77ae52c5e605ff2171a80095d4221d5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701fa75583b9c074ed96698d8216ecf3/" rel="bookmark">
			vue elementUI中级联选择器获取label值？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue elementUI中级联选择器获取label值？ 需求是获取级联选择器的lable 将label赋入到别的div中，如下图：
思路：提交表单，我是将更换配件作为一个字段传给后台，然后将下边的数据和input框的数据组成[{}]格式的传给后台，首先获取更换配件的id值，然后获取到节点的信息，比较两者id是否相同，然后进行赋值
直接看代码更为清晰：
&lt;template&gt; &lt;div class="content"&gt; &lt;el-form ref="testRef" :model="testform" label-width="80px"&gt; &lt;el-form-item label="更换配件"&gt; &lt;el-cascader ref="partRef" :options="options" :props="props" clearable :show-all-levels="false" @change="changeHandle" v-model="testform.partsValue" &gt;&lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;div style="display: flex" v-for="(item, index) in partsList" :key="index" &gt; &lt;div class="test-num"&gt;{{ item.name }}&lt;/div&gt; &lt;input type="text" name="" id="" v-model="item.num" /&gt; &lt;/div&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { testform: { partsValue: [], }, partsList: [], partNum: "", partsName: "ssss", props: { multiple: true }, options: [ { value: 1, label: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/701fa75583b9c074ed96698d8216ecf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d83a02286ee628d23109e5951d14f45/" rel="bookmark">
			找不到限定符（*****）的bean，报告 Spring Bean 注入点的自动装配问题：不止一种 ‘concrete‘ 类型的 Bean没有 ‘concrete‘ 类型的 Bean没有带限定符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家在做SSM项目或spring，springMVC项目时会遇到以下问题：
找不到限定符（*****）的bean，报告 Spring Bean 注入点的自动装配问题：不止一种 'concrete' 类型的 Bean没有 'concrete' 类型的 Bean没有带限定符，SpringBean组件中的注入点滴自动装配问题的检查
这种情况出现原因有三种：
1.bean没有装配到Spring容器当中
2.没有配置bean扫描器
3.没有SetGet方法
Bean注入有2种方式：
1.通过注解的方式
2.在配置文件中写Bean：
废话不说，上解决方案
第一步：
首先看看自己的项目中有没有扫描器 以下图
第二步 通过注解的方式来进行装配：
Service层：
其中@Service注解的作用就是实例化下面的类：默认名称为类名首字母小写
@Autowired：完成自动装配
@Qualifier:指定使用哪个类，来为以下的属性进行注入
Controller层：
其中红圈的名称就是实例化SuperAdminServiceImpl后的名称
有的做项目的时候注解都不差为什么还是爆红呢？
原因就是SuperAdminServiceImpl中属性的SetGet方法
这说明 实例化是需要Set方法的
接下来我们说说注入第二种方法 在配置文件中写入bean
通过以上图可发现爆红了，这是因为没有bean
接下来我们把bean注释去掉
其中Qualifier是要和bean id名称一样的
注意 红圈中的superAdminDao为属性，因为spring已经帮我们实例化了superAdminDao了，这里要用 ref对象注入的方式，而不是用普通类型value的方式注入，
如果尝试以上方法还是不行的话，可能是因为实例化太多了，Spring不知道用哪一个
可以试试在@Service后面加入名称
以上应该能帮你解决问题，本人经验尚且不足，有不足的望大佬帮忙指正 谢谢！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f02f694abd9e3453888bf4fbc8957a/" rel="bookmark">
			【Bootstrap】Bootstrap v5 nav导航条实现部分居左，部分居右布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、效果二、修改后代码三、分析3.1 修改前效果3.2 修改前代码3.3 方法 四、学习网址 一、效果 在同一行中，资产收集、信息探测等内容居左对齐，而测试与退出登录居右对齐。
二、修改后代码 &lt;!-- nav --&gt; &lt;nav class="navbar navbar-expand-sm bg-light navbar-light"&gt; &lt;!-- div1 start --&gt; &lt;div class="collapse navbar-collapse justify-content-start"&gt; &lt;!-- Brand --&gt; &lt;a class="navbar-brand" href="/"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;欢迎{{ request.session.username }}&lt;/a&gt; &lt;!-- navbar-nav --&gt; &lt;ul class="navbar-nav"&gt; &lt;!-- Dropdown1 --&gt; &lt;li class="nav-item dropdown"&gt; &lt;a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-bs-toggle="dropdown"&gt; 资产探测 &lt;/a&gt; &lt;div class="dropdown-menu"&gt; &lt;a class="dropdown-item" href="{% url 'Bing_search' %}"&gt;Bing查询&lt;/a&gt; &lt;a class="dropdown-item" href="{% url 'ip138_search' %}"&gt;ip138查询&lt;/a&gt; &lt;a class="dropdown-item" href="{% url 'subdomain_search' %}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50f02f694abd9e3453888bf4fbc8957a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4312935b8d3dc74a361e2d24be4381d/" rel="bookmark">
			执行hadoop jar 或者是yarn jar 报Exception in thread “main“ java.lang.NoClassDefFoundError：XXX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在idea中打包，上传到虚拟机中。
找到上传的目录，执行 yarn jar 或者 hadoop jar 报一下的错。 报错的原因可能是：在idea打包的过程中没有相关的类，那你在打包的时候，没有把相关依赖都打进去。
打包插件: 这个打包插件会把需要的相关依赖全部打到jar中
在pom.xml添加这个。
在把之前打包的包，清理掉； 再重新打包
运行指令：
mvn assembly:assembly -Dmaven.test.skip=true
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0cdcf1a83beb3c3535ce802189f5eb/" rel="bookmark">
			AN AUTOREGRESSIVE FLOW MODEL FOR 3D MOLECULAR GEOMETRY GENERATION FROM SCRATCH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Paper: https://openreview.net/pdf?id=C03Ajc-NS5W
Code: https://github.com/divelab/DIG
ICLR 2022 | 从头开始生成三维分子几何结构的自回归流模型 我们考虑了从头开始生成三维分子几何图形的问题。虽然已经开发了多种生成分子图的方法，但从头开始生成三维分子几何图形在很大程度上还有待探索。在这项工作中，我们提出了G-SphereNet，一个新的自回归流模型来生成三维分子几何形状。在这项工作中，我们提出了G-SphereNet，一个新的自回归流模型来生成三维分子几何形状。G-SphereNet采用了一种灵活的顺序生成方案，通过在三维空间逐步放置原子。**我们不直接生成三维坐标，而是通过生成距离、角度和扭转角来确定原子的三维位置，从而保证了不变性和等方差。**此外，我们还提出利用球形消息传递和注意机制进行条件信息抽取。实验结果表明，G-SphereNet方法在随机分子几何生成和目标分子发现方面优于以往的方法。
INTRODUCTION 设计和合成具有理想性质的新分子是药物发现中的一项具有挑战性的任务和化学科学。所有化学分子的搜索空间估计在 1 0 33 10^{33} 1033个左右，因此无法进行彻底搜索。近年来，机器学习方法的进步大大加快了这一领域的进展。许多研究将分子表示为二维分子图，并提出利用深度生成模型自动生成分子图和优化分子性质，如变分自编码器。
然而，从二维分子图中不能获得分子的完整信息，因为三维结构，也称为三维分子几何，是决定许多分子性质的关键。三维分子几何表示原子的三维坐标，对精确预测量子性质具有重要意义。因此，我们认为，生成2D分子图可能不是识别具有某些理想量子特性的新分子的最佳方法。相反，开发一种生成模型，可以从头生成三维分子几何图形，是解决这个问题的一个有希望的解决方案。目前，这一领域仍未得到充分开发。最近，一系列开创性的研究提出了从给定的二维分子图生成三维分子几何图形。这些方法本身不会在给出二维分子图后产生新的分子。
在这项工作中，我们提出了G-SphereNet，一个从零开始生成三维分子几何的生成模型。在G-SphereNet中，三维分子几何图形是通过在三维空间中顺序地放置原子而生成的。原子的三维位置通过生成距离、角度和扭转角度来隐式确定，以确保不变性和等方差特性。我们的工作受到了SphereNet的启发，它使用距离、角度和扭转角度来计算分子的预测表示。此外，G-SphereNet利用SphereNet和注意力机制提取条件信息。实验结果表明，G-SphereNet方法在三维分子几何生成任务上优于现有方法。
BACKGROUND AND RELATED WORK 2D MOLECULAR GRAPH GENERATION 近年来，由于深度生成模型的发展，分子设计与生成问题取得了重大进展。一些方法使用序列模型来生成分子的SMILES字符串表示。其他研究将分子视为图形，其中分子的原子和化学键分别用节点和边表示。这些研究或生成图的节点类型和邻接矩阵，或通过节点和边的顺序添加形成分子图，或由分子基序的连接树组成分子。
然而，这些方法只生成分子的图形结构，而忽略了关键的三维分子几何形状。换句话说，分子中原子的三维坐标是未知的。因此，这些生成模型无法区分空间异构体，即具有相同分子图但具有不同三维分子几何形状的分子。此外，计算分子的一些量子性质，如HOMO-LUMO间隙，需要分子的三维几何形状。因此，当需要空间异构体或量子特性时，这些生成方法不能使用。
3D MOLECULAR GEOMETRY GENERATION FROM SCRATCH 在这项工作中，我们考虑了从头生成三维分子几何图形的问题。设 G = { G j } j = 1 m \text{G} = \{G_j\}^m_{j=1} G={Gj​}j=1m​是一组三维分子几何图形，函数 S ( G ) ∈ R S(G) \in R S(G)∈R计算 G G G的特定量子性质分数。我们考虑定义的两代任务:
从 G G G中学习随机生成模型 p θ ( ⋅ ) pθ(·) pθ(⋅)，使模型能够以高概率的 p θ ( G ) pθ(G) pθ(G)对有效的三维分子几何 G G G进行采样。学习一个目标分子发现模型 p θ ( ⋅ ) pθ(·) pθ(⋅)以最大化(或最小化)期望量子性质分数 E G ∼ p θ [ S ( G ) ] E_{G \sim pθ}[S(G)] EG∼pθ​[S(G)]。 这个问题在很大程度上还有待探索，只有少数研究试图解决这个问题。G-SchNet利用基于SchNet的自回归模型，依次生成新原子，并将其放置在焦点原子的局域网格点上。另一方面，EDMNet 和3DMolNet 分别利用生成对抗网络(GAN) 和变分自编码器(VAE) 产生原子之间的成对距离。此外，E-NFs提出了一个将flow模型与E(n)等变图神经网络相结合的几何生成模型。它一次性生成所有原子的三维坐标，并定义潜在空间子空间中的先验分布，以确保平移不变性。与这些方法不同的是，我们的方法采用了基于自回归流模型的灵活的顺序生成流水线，可以更有效地捕获三维分子几何密度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0cdcf1a83beb3c3535ce802189f5eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c0f16f214abfa53a62ba98efb395b8/" rel="bookmark">
			Java对象~类变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象变量是对象的管理者而非所有者
在一个成员函数里面调用另一个成员函数不用.调用
本地变量：定义在函数内部的变量，其生存期和作用域都是函数内部
成员变量：生存期是对象的生存期，作用域是类内部的成员函数
对象初始化：
对类里面的成员变量，如果你没有主动给他赋过值，java会自动给一个该类型对应的0值
我们可以在类里声明成员变量的地方直接给它赋值或者调用函数赋值，
构造函数：如果有一个成员函数和类的名字完全相同，则在创建这个类的每一个对象的时候都会自动调用这个函数，且在进行构造函数的时候会先做外面的类的定义初始化，在定义初始化里面做完所有东西以后，才会进入构造函数，这个函数没有也不能有返回类型
函数重载：一个类可以有多个构造函数，只要它们的参数表不同；创建对象的时候给出不同的参数值，就会调用不同的构造函数；通过this()还可以调用其他的构造函数（不常用）；一个类里的同名但是参数表不同的函数构成了重载（overload）关系
封闭的访问属性：
封装：把数据和对数据的操作放在一起
数据：属性或状态 操作：函数
对象=属性+服务
Java：所有的成员都可以设定访问属性
Private:该关键字只能用于成员变量或成员寒素，只有那个类内部（类的大括号里）可以访问，即指成员函数和定义初始化，（还有类对应的main也算是类的成员），这个限制是对类的而不是对对象的，是从代码角度看的，同一个类的所有的不同的对象之间可以互相访问别人的私有的成员
一个基本原则：成员变量都应该是私有的，以防止其他对它的调用
对象数组中的每个元素都是对象的管理者而非对象本身
调用函数：在一个成员函数调用另一个成员函数只需要直接调用那个函数就行，且this会代入进去，在外部需要用对象的名字.来调用
Public：任何人都可以访问，意味着在其他地方可以用它。如果没有在成员前面加上publi，private关键字限定它，那么它就会被认为是friendly的：和它位于一个包的其他类可以访问
一个类是public表明：任何类可以用这个类的的定义来定义变量如果类是public的，那么它必须存在一个源文件里面，且它的文件名必须和这个类的名字相同，否则会报错
编译单元：编译的时候一次对一个编译单元做动作，一个源代码文件，一个.java文件是一个编译单元，在一个编译单元里面可以有很多java类，一个编译单元里面有不止一个java类的时候，只有一个类可以是public的，其他类只能在这个包里面起作用，如果这个类是public的，它必须在一个同名的源文件里面
使用其他包里的public类时，要import 包名字.类名字或包名字.*（通配符，把包里的所有东西引进去，但可能会出现两个包里的东西重名）
包的名字的.代表的是文件夹的层次import java.util.Scanner;
Static：类变量，属于一个类，而不在它的对象里面，该类的任何一个对象都可以访问它的类变量，也可以类名.类变量访问它
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35f99d00b32cff1adb28a884c6c3849/" rel="bookmark">
			export LANG不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前发现export LANG=zh_CN.UTF-8不生效，一直不知道原因，直到在安装fontconfig时看到如下注释：
As a user, if your language has been installed for this package, you
only have to set the 'LANG' environment variable to the appropriate
'LL_CC' combination. If you happen to have the 'LC_ALL' or some other
'LC_xxx' environment variables set, you should unset them before setting
'LANG', otherwise the setting of 'LANG' will not have the desired
effect. Here 'LL' is an ISO 639 two-letter language code, and 'CC' is
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f35f99d00b32cff1adb28a884c6c3849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e238c97618c49a929b71454920acb011/" rel="bookmark">
			MySQL分割字符串，一行转多行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 MySQL中，某个字段通过分隔符保存了多个字符串，如下：
需要将字段中的字符串分成不同的行，如下：
用到的知识 MySQL提供了一系列字符串处理函数
1、left(str, len)：从左边开始截取指定长度
2、right(str, len)：从右边开始截取指定长度
3、substring(str, pos)：从第pos个字符开始截取（注意从1开始计数）
当pos为正数：从左往右数第pos个当pos为负数：从右往左数第pos个
比如pos为-2，字符串为"a,b,c"，截取结果为",c" 4、substring(str, pos, len)：从第pos个字符开始截取指定长度（注意从1开始计数）
5、substring_index(str, delim, count)：根据delim分隔符进行分割，从头开始截取到第count个分隔符之前
select id, substring_index("a,b,c", ',', 2) from test_split;
截取到第二个分隔符之前
最终实现 实现效果 select b.help_topic_id + 1 as id, substring_index(substring_index(a.name, ',', b.help_topic_id + 1) ,',', -1) as name from test_split a join mysql.help_topic b on b.help_topic_id &lt; LENGTH(a.name) - LENGTH(REPLACE(a.name,',','')) + 1; 一行变成多行，需要借助辅助表，这里选择mysql.help_topic
mysql.help_topic表的id特点是从0开始递增，最大为700
1、分割成多少份：LENGTH(a.name) - LENGTH(REPLACE(a.name, ',' , '')) + 1
length(‘a,b,c’) - length( replace(‘a,b,c’, ‘,’, ‘’) ) + 1 = 5 - 3 + 1 = 3原始长度 - 去掉分隔符,之后的长度 = 分隔符数量分隔符数量 + 1 = 被分割的数量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e238c97618c49a929b71454920acb011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef5a6be987657a642a85357109e5216/" rel="bookmark">
			【Flask】WARNING: This is a development server. Do not use it in a production deployment. falsk WSGI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我是一个甜甜的大橙子🍊，欢迎关注✉️！
我相信技术的力量💪
努力将所学分享给大家😎
你的点赞❤️分享🚀收藏📖就是对我最大的鼓励！
在用flask进行开发的时候，突然看到有如下警告
* Serving Flask app "5star" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on 解决问题的关键就在于
Use a production WSGI server instead. 很快搜到了解决方案：
if __name__ == '__main__': server = make_server('127.0.0.1', 5000, app) server.serve_forever() app.run() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8d3eef0c97820d7c864b08edfc40bd/" rel="bookmark">
			nodejs-(一)win10安装配置nodejs(v12.20)环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejs-(一)win10安装配置nodejs(v12.20)环境
一、什么是Nodejs？
Node.js是一个基于Chrome V8擎JavaScript运行时环境。Node.js听名字好像是个JS库，其实Node.js是C++开发的JavaScript运行时环境。
使用Node.js可以访问读写txt文本、访问数据库，开发Web网站等等。
二、下载地址
官网：
https://nodejs.org/zh-cn/
其它版本：
https://nodejs.org/zh-cn/download/releases/
源码地址：
https://github.com/nodejs
三、node和npm两个重要的命令行工具介绍
node，是Nodejs的执行命令，输入node可以进入Nodejs环境，键入标准js可以在控制台查看输出内容。如果想独立运行hello.js文件，可以输入命令：node hello.js 查看执行结果。
npm，(Node Package Manager)是Nodejs包管理工具，可以安装我们需要的依赖包到本地。通过package.json文件来管理插件包的包管理工具，包都存在node_modules里面，安装node环境会自动集成npm工具，不需要额外安装。
四、搭建环境和修改配置
下面以v12.20.0为例在win10中配置一个Nodejs环境，我们使用zip包手动安装Nodejs。
1.下载文件
下载地址：https://nodejs.org/download/release/v12.20.0/
下载node-v12.20.0-win-x64.zip文件
2.将文件解压到D:\nodejs\node-v12.20.0-win-x64目录
node.exe 文件应在此路径下 D:\nodejs\node-v12.20.0-win-x64\node.exe；
在根目录新建 node_global 、node_cache 文件夹，用于存放全局包；
后续使用命令配置全局包和国内镜像地址：
3.配置环境变量
3.1 新建 NODE_HOME 变量，指向node命令目录：D:\nodejs\node-v12.20.0-win-x64
3.2 新建 NODE_PATH 变量，指向全局包所在目录：%NODE_HOME%\node_global\node_modules
3.3 在Path变量中添加三个路径
%NODE_HOME%
%NODE_HOME%\node_global
%NODE_PATH%
注：后续如果需要安装其它版本的Nodejs只需要修改NODE_HOME变量值即可。
4.验证Nodejs是否安装成功
分别键入node -v 和 npm -v 看到版本号就算成功了。
&gt;node -v
v12.20.0
&gt;npm -v
6.14.8
5.修改npm全局包的默认存放路径和国内镜像地址；
npm config set prefix "D:\nodejs\node-v12.20.0-win-x64\node_global"
npm config set cache "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af8d3eef0c97820d7c864b08edfc40bd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/145/">«</a>
	<span class="pagination__item pagination__item--current">146/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/147/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>