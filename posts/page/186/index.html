<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ee868a220f40190bab8cdd1e4abbe9/" rel="bookmark">
			linux开启命令模式,linux进入救援模式的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么情况下我们需要进入救援模式，当我们无法以超级用户登录到系统，同时GRUB也设置了密码，我们无法修改kernel参数以单用户模式修改超级用户的密码。无论什么原因导致以上无法进入系统的情况，这时候我们只有通过救援模式来解决这个问题。通过光盘启动进入下面界面，我们选择Rescue installed system来进入救援模式
使用版本：Centos6.5
救援模式有什么作用：
◆可以更改root密码；
◆恢复硬盘、文件系统操作；
◆系统启动不来的时候，只能通过救援模式来启动；
救援模式启动的步骤如下：
1、首先开机进入BIOS设置(每台电脑进入bios的方法不同根据自己的电脑进入)，BOOT启动顺序为光盘优先启动 CD-ROM Drive使用小键盘的+ -号调整上下顺序；设置好后保存并退出。
2、重启系统后进入安装启动菜单，上下键移动到Rescue install system 救援安装系统；
4、选择键盘类型，保持默认us
5、是否启动网络，需要根据你实际情况进行选择，如果需要通过联网拷贝数据，选择YES，在这里我们选择NO；
6、进入到Rescue界面，选择Continue
7、系统挂载在/mnt/sysp_w_picpath下 如果要到root环境下，运行 chroot /mnt/sysp_w_picpath 命令
8、三种选项：shell 进入命令行模式；fakd是诊断模式；reboot重启电脑；我们这里选择shell
9、进入shell命令行，提示符为bash-4.1#
ls /mnt/sysp_w_picpath/ 显示挂载的目录为根目录的文件
执行chroot /mnt/sysp_w_picpath/ 将/mnt/sysp_w_picpath/目录下的文件移动到根目录；
命令后提示符为sh-4.1# (此状态下执行password可修改密码)
ls 显示为根目录的文件；
10、在sh-4.1#模式下需要先exit退出，回到bash-4.1#才可以reboot重启系统；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb4d779906a6020f1db3cadaba2d52d/" rel="bookmark">
			进Linux系统单用户模式,Linux进入单用户模式的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单用户模式的作用
在使用Linux系统中，维护人员经常会碰到一个问题，就是在拥有root账号权限和密码的用户中，总是会出现忘记root密码的情况。
遇到这种情况，一般情况下，维护人员就会通过最常用的方法进行root密码重置，那就是单用户模式。
其次，单用户最突出且实用的一个好处就是：可以无密码登录，所以，在忘记密码时，可以进入单用户模式修改登录密码。
方法一
先重启系统
在Linux系统启动 内核启动顺序选择界面(如下图倒计时的界面时) 按键盘任意键 让Linux引导启动停留内核选择阶段通过上下键(任意按键也可以的)让Linux引导启动停留内核选择阶段。
在上一个界面 计时 时按任意按键便可进入如下图界面，根据提示 键入小写字母e，进入下一步
进入如下图界面后，选择kernel 开头这项(第二个)按下按键e，进入下一步
进入后会显示如下图这个界面 如图输入空格single后 按回车 编辑完毕
编辑完后回到第二步界面，直接输入b重新引导系统，系统重启后 会直接进入root用户模式下，在此模式下你就可以使用root功能的东西了
如上一步骤输入b后便重启系统 如下图所示 等待一会之后 就会进入单用户模式
进入单用户模式了 输入 passwd就可以更改密码了，然后就可以直接用passwd命令修改root
以上操作便是进入单用户模式下修改root密码，解决root密码忘记以及root用户被锁等需要root权限执行而root账户无法使用的问题。
方法二
先重启系统
在Linux系统启动 内核启动顺序选择界面(如下图倒计时的界面时) 按键盘任意键 让Linux引导启动停留内核选择阶段通过上下键(任意按键也可以的)让Linux引导启动停留内核选择阶段。
在如下图界面键入字母 a
如下图 输入 (空格)1 回车 即可直接进入单用户模式
如上图输入完后 回车后等待一会 即可进入单用户模式
进入单用户模式一般是用于修改密码 修改完大部分人都会关机然后重启
这里有个便捷的方法 修改完密码后 直接按下快捷键ctrl+d 即可立即启动系统
Centos6进入单用户模式的两种方法
单用户模式的作用 在使用Linux系统中,维护人员经常会碰到一个问题,就是在拥有root账号权限和密码的用户中,总是会出现忘记root密码的情况.遇到这种情况,一般情况下,维护人员就会通过最常用的方法 ...
linux尝试登录失败后锁定用户账户的两种方法
linux尝试登录失败后锁定用户账户的两种方法 更新时间:2017年06月23日 08:44:31 作者:Carey 我要评论 这篇文章主要给大家分享了linux尝试登录失败后锁定用户账 ...
linux访问windows共享文件夹的两种方法
有时需要在linux下需要访问windows的共享文件夹,可以使用mount挂载或者使用samba连接. 1.mount挂载 首先创建被挂载的目录: $ mkdir windows 将共享文件夹挂载到 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb4d779906a6020f1db3cadaba2d52d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb265ec5b6a295ad9423f1fa7494224/" rel="bookmark">
			Docker 如何删除及清理镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过标签删除镜像 通过如下两个都可以删除镜像：
docker rmi [image] 或者：
docker image rm [image] 支持的子命令如下：
-f, -force: 强制删除镜像，即便有容器引用该镜像；-no-prune: 不要删除未带标签的父镜像； 例如，我们想删除上章节创建的 allen_mysql:5.7 镜像，命令如下：
docker rmi allen_mysql:5.7 从上面章节中，我们知道 allen_mysql:5.7 和 docker.io/mysql:5.7 实际上指向的是同一个镜像，那么，您可以能会有疑问，我删除了 allen_mysql:5.7, 会不会将 docker.io/mysql:5.7 镜像也给删除了？
实际上，当同一个镜像拥有多个标签时，执行 docker rmi 命令，只是会删除了该镜像众多标签中，您指定的标签而已，并不会影响原始的那个镜像文件。
不信的话，我们可以执行 docker images 命令，来看下 docker.io/mysql:5.7 镜像还在不在：
可以看到，docker.io/mysql:5.7 镜像依然存在！
那么，如果某个镜像不存在多个标签，当且仅当只有一个标签时，执行删除命令时，您就要小心了，这会彻底删除镜像。
例如，这个时候，我们再执行 docker rmi docker.io/mysql:5.7 命令：
从上图可以看到，我们已经删除了 docker.io/mysql:5.7 镜像的所有文件层。该镜像在本地已不复存在了！
二、通过 ID 删除镜像 除了通过标签名称来删除镜像，我们还可以通过制定镜像 ID, 来删除镜像，如：
docker rmi ee7cbd482336 一旦制定了通过 ID 来删除镜像，它会先尝试删除所有指向该镜像的标签，然后在删除镜像本身。
三、删除镜像的限制 删除镜像很简单，但也不是我们何时何地都能删除的，它存在一些限制条件。
当通过该镜像创建的容器未被销毁时，镜像是无法被删除的。为了验证这一点，我们来做个试验。首先，我们通过 docker pull alpine 命令，拉取一个最新的 alpine 镜像, 然后启动镜像，让其输出 hello, docker!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bb265ec5b6a295ad9423f1fa7494224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79c63f72afa15ea123263807b593634/" rel="bookmark">
			AD生成PCB引脚出现绿色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引脚出现绿色是因为引脚之间的间距过窄，与AD默认的连线之间的规则冲突。
解决办法：
https://blog.csdn.net/qq_41862220/article/details/90548806
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86120b9304ae3c81b0b2eada17762763/" rel="bookmark">
			【MySQL笔记】MySQL有些参数的学习记录-sort_buffer_size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上干货：关注sort_buffer_size的参数，
sort_buffer_size： 是 MySQL 执行排序使用的缓冲大小。 如果想要增加 ORDER BY 的速度，首先看是否可以让 MySQL 使用索引而不是额外的排序阶段。 如果不能， 可以尝试增加sort_buffer_size 变量的大小。
以上几张图摘自不知名的大佬，以及第一张图是来自mysql5.7参考手册。 以上以上，前人栽树，后人乘凉。
生产一般配置：
[mysqld]
sort_buffer_size=8m
myisam_sort_buffer_size=32m
[myisamchk]
key_buffer = 512M
sort_buffer_size = 512M
read_buffer = 8M
write_buffer = 8M
官方文档：https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_sort_buffer_size
==================End====================
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29529507fd435310f562b7e82204deb/" rel="bookmark">
			苹果iPad忘记了Apple ID密码该怎么办?（手机教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码解锁设备是一种常用并重要的解锁方式。这边换换回收整理了iPad不同密码忘记的情况下的解决方法，希望对部分的网友们有所帮助。
一：锁屏密码忘记：
(1)锁屏密码忘记后，多次解锁失败，iPad会进入“已停用”状态;
(2)用苹果数据线将iPad和安装了itunes的电脑连接起来，重新恢复即可。
二：忘记Apple ID，它有多种找回方式，如通过注册邮箱找回等。小编在这里给大家介绍一个简单的方法，记得锁屏密码能正常进入ipad。
(1)打开iPad的设置，在AppleID里点击“密码与安全性”;
(2)点击“更改密码”。
(3)输入锁屏密码，就可以重置Apple ID的密码了。
三：两个密码都忘记。
法1：找到购买发票等能证明iPad属于你的凭证，找苹果售后解锁就可以了。
以上是ipad忘记密码的解决方法，因为ioad的密码能互相解锁，请网友们一定要保管好自己的锁屏密码和AppleID密码!大家实在解决不了的话，可以拿到售后哦!更多的电脑小知识可以去本站学习交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42eb1c6b8071160392722c1823d9870f/" rel="bookmark">
			C语言中&amp;、&amp;&amp;、|、||
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&amp;——按位与运算，口诀：有0为0，全1为1
|——按位或运算，口诀：有1为1，全0为0
&amp;&amp;——逻辑与运算，整体看做一位二进制，非0为1，
||——逻辑或运算
与运算：
a&amp;0→0→清0
a&amp;1→a→保持
或运算：
a|0→a→清零
a|1→1→置1
代码：
#include &lt;stdio.h&gt; int main(void) { int a = 0b00001111; //二进制数字 int b = 0b11110000; //八进制数字 printf("十六进制输出：\n"); //以十六进制形式输出 printf(" a=%#X\n", a); //X大写，则输出的前缀和字母都大写 printf(" b=%#X\n", b); printf("&amp;和&amp;&amp;的区别：\n"); printf(" a&amp;b=%#X\n", a&amp;b); printf(" a&amp;&amp;b=%#X\n", a&amp;&amp;b); printf("|和||的区别：\n"); printf(" a|b=%#X\n", a|b); printf(" a||b=%#X\n", a||b); printf("与运算的特性：\n"); printf(" 和0与清0：a&amp;0=%#X\n", a&amp;0); printf(" 和1与保持：a&amp;0XFF=%#X\n", a&amp;0XFF); printf("或运算的特性：\n"); printf(" 和0或保持：a|0=%#X\n", a|0); printf(" 和1或置1：a|0XFF=%#X\n", a|0XFF); return 0; } 运算结果：
参考：C语言中数的二进制、八进制、十进制以及十六进制表示及输出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b23c4f001833758939c1f42d9ec986/" rel="bookmark">
			Python函数与方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数类似于C++的全局方法。
方法分为类方法（C++的静态成员方法），实例方法（C++的非静态成员方法），静态方法（可以理解为定义在类中的函数）。
参考链接Difference between staticmethod and classmethod
Python实例方法、静态方法和类方法详解（包含区别和用法）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c56e5a6413b80e60cb37b75a42944a3/" rel="bookmark">
			视频编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频编码 图像基础知识 1、像素
像素点的英文叫Pixel，缩写为PX，它是图像显示的基本单位，我们通常说一幅图片的大小，如1920X1080，就是图片长度为1920个像素点，宽度为1080个像素点，长宽乘积是2073600，也就是说，这个图片是200w像素的。1920X1080也被称为这幅图片的分辨率
2、PPI
PPI是“Pixels Per Inch”，每英寸像素数，也就是显示器屏幕上每英寸面积。PPI的值越高，图像就越清晰细腻；相反，PPI的值越低，屏幕看起来就有很强的颗粒感。
3、图像中的颜色表示
在计算机里，R、G、B也被称为“基色分量”。它们的取值，分别从0-255，一工256个等级。所以任何颜色都可以用R、G、B三个值的组合表示。
通过这种方式，一共能表达多少种颜色呢?256×256×256=16,777,216种，因此也简称为1600万色。RGB三色，每色有8bit，这种方式表达出来的颜色，也被称为24位色(占用24bit)。这个颜色范围已经超过了人眼可见的全部色彩，所以又叫真彩色。再高的话，对于我们人眼来说，已经没有意义了，完全识别不出来。
视频编码基础知识 视频和图像的关系
大量的图片连续起来就是视频。衡量视频的指标参数—帧率。
在视频中，一个帧就是指一幅静止的画面。帧率，就是指视频每秒钟包括的画面数量，帧率越高，视频就越逼真、越流畅。
对视频编码的必要性
一个视频若未经编码，它的体积是非常庞大的。
以一个分辨率1920×1280，帧率30的视频为例：
共：1920×1280=2,073,600(Pixels 像素)，每个像素点是24bit;
也就是：每幅图片2073600×24=49766400 bit，8 bit(位)=1 byte(字节);
所以：49766400bit=6220800byte≈6.22MB。
这是一幅1920×1280图片的原始大小，再乘以帧率30。
也就是说：每秒视频的大小是186.6MB，每分钟大约是11GB，一部90分钟的电影，约是1000GB。
什么是视频编码
编码：就是按照指定的方法，将信息从一种形式转换成另外一种形式。
视频编码：就是将一种视频分时转换成另一种视频格式。
编码的终极目的，就是为了压缩。各种编码格式都是为了让视频变得提价更小，有利于存储和传输。
视频录制播放的整个过程如下：
摄像机（图像传感器）—&gt;预处理（A/D转换）—&gt;预处理（YUV转换等）—&gt;压缩编码—&gt;数据封装及传输—&gt;解码—&gt;图像格式变换—&gt;播放
首先时视频采集，通常我们会使用摄像机、摄像头进行视频采集。
采集了视频数据之后，就要进行模数转换，将模拟信号变成数字信号。其实现在很多摄像机直接输出数字信号。信号输出之后，还要进行预处理，将RGB信号变成YUV信号。
那么什么时YUV信号呢？
简单来说，YUV就是另外一种颜色数字化表示方式。视频通信系统之所以要采用YUV，而不是RGB，主要时因为RGB信号不利于压缩。在YUV这种方式里面，加入了亮度这一概念。在最近十年中，视频工程师发现，眼睛对于亮和暗的分辨要比对颜色的分辨更精细一些，也就是说，人眼对色度的敏感程度要低于对亮度的敏感程度。
所以，工程师认为，在我们的视频存储中，没有必要存储全部颜色信号。我们可以把更多带宽留给黑—白信号(被称作“亮度”)，将稍少的带宽留给彩色信号(被称作“色度”)。于是，就有了YUV。
YUV里面的“Y”，就是亮度(Luma)，“U”和“V”则是色度(Chroma)。
YUV主流的采样方式有三种：
1）YUV4:4:4;
2)YUV4:2:2;
3)YUV4:2:0。
通常来说，YUV4:2:0的采样方式，能获得1/2的压缩率。
视频编码的实现原理 1、视频编码技术的基本原理
所谓编码算法，就是寻找规律，构建模型。谁能找到更精准的规律，建立更高效的模型，谁就是厉害的算法。
通常来说，视频里面的冗余信息包括：
种类内容压缩方法空间冗余像素间的相关性变换编码，预测编码时间冗余时间方向上的相关性帧间预测，运动补偿图像构造冗余图像本身的构造轮廓编码，区域分割知识冗余收发两端对人物的共有认识基于知识的编码视觉冗余人的视觉特性非线性量化，位分配其他不确定性因素 视频编码技术优先消除的目标，就是空间冗余和时间冗余。
2、视频编码技术的实现方法
视频是由不同的帧画面连续播放形成的。
这些帧，主要分为三类：
1）I帧；
2）B帧；
3）P帧。
I帧：是自带全部信息的独立帧，是最完整的画面(占用的空间最大)，无需参考其它图像便可独立进行解码。视频序列中的第一个帧，始终都是I帧。
P帧：“帧间预测编码帧”，需要参考前面的I帧和/或P帧的不同部分，才能进行编码。P帧对前面的P和I参考帧有依赖性。但是，P帧压缩率比较高，占用的空间较小。
B帧：“双向预测编码帧”，以前帧后帧作为参考帧。不仅参考前面，还参考后面的帧，所以，它的压缩率最高，可以达到200:1。不过，因为依赖后面的帧，所以不适合实时传输(例如视频会议)。
通过对帧的分类处理，可以大幅压缩视频的大小。
我们举个例子来看一下。
这有两个帧：
好像是一样的？
不对，我做个GIF动图就能看出来，是不一样的
人在动，背景时没有在动的
第一帧是I帧，第二帧是P帧。两个帧之间的差值，就是如下：
也就是说，图中的部分像素，进行了移动。移动轨迹如下：
这个就是运动估计和补偿
当然了，如果总是按照像素来算，数据量会比较大，所以，一般都是把图像切割为不同的“块(Block)”或“宏块(MacroBlock)”，对它们进行计算。一个宏块一般为16像素×16像素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c56e5a6413b80e60cb37b75a42944a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ef01fb6ebbe5981e8611139bb6f8ae/" rel="bookmark">
			树模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树 ID3
决策树 C4.5
决策树-CART
决策树-剪枝方法
决策树
Ensemble Learning
Bagging
booststraping
Bagging
Boosting
Boosting AdaBoost
Boosting GDBT
Boosting Xgboost
参考文献:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af97669f6740fc77c49c4c98bfc56382/" rel="bookmark">
			LeetCode 560 和为k的子数组（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LeetCode 560 和为k的子数组
题目描述：
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 ​ 示例 1 : ​ 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : ​ 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 代码：
class Solution { public int subarraySum(int[] nums, int k) { int len = nums.length; int count = 0; for(int i = 0;i&lt;len;i++){ int sum = 0; for(int j=i;j&lt;len;j++){ sum=sum+nums[j]; if(sum == k){ count++; } } } return count; } } ​ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe4066614185fe278994100573ba6af/" rel="bookmark">
			常见k8s 安装部署错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、no matches for kind "Deployment" in version "extensions/v1beta1" 0x00 Problem [root@k8sm90 demo]# kubectl create -f tomcat-deployment.yaml error: unable to recognize "tomcat-deployment.yaml": no matches for kind "Deployment" in version "extensions/v1beta1" 0x01 Solution 修改 apiVersion 选项： apps/v1
[root@k8sm90 demo]# cat tomcat-deployment.yaml apiVersion: apps/v1 kind: Deployment ... 因为我的 k8s 版本是 1.16.9，在这个版本中 Deployment 已经从 extensions/v1beta1 弃用
DaemonSet, Deployment, StatefulSet, and ReplicaSet resources will no longer be served from extensions/v1beta1, apps/v1beta1, or apps/v1beta2 by default in v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe4066614185fe278994100573ba6af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a8d74a391f2063d15ae8c33302e4d9/" rel="bookmark">
			C 语言 —— printf()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语法：printf(格式字符串，[参数列表]);
注意：使用 printf 打印数据时，待打印的数据的类型一定要和格式字符串中的转换说明相匹配！！！
如果对格式转换符还不了解的，可以点击这里查看格式转换符
1. 格式化输出 数字 表示最小字段宽度。
如果需要打印的数据宽度小于该数字，那么在前面自动补空格；如果需要打印的数据宽度大于等于该数字，正常打印。默认是右对齐的，搭配 - 表示左对齐。搭配 0 表示不足补 0，而不是空格。
#include &lt;stdio.h&gt; int main() { int i = 100; printf("*%d*\n",i); printf("*%6d*\n",i); printf("*%-6d*\n",i); printf("*%06d*\n",i); getchar(); return 0; } *100* * 100* *100 * *000100* .数字 表示精度。
对于浮点数来说，精度就是显示小数点后几位，如果浮点数小数点后位数比这个数字小，则补零；如果浮点数小数点后面位数比这个数字大，则四舍五入。
对于整型数来说，精度就是待打印的数据的最小位数，如果待打印数据位数不足，前面补零。
PS:如果 0 标记和精度一起出现，0 标记会失效。
printf("*%06.4d*\n",i);// 0标记失效，输出* 0100* 2. 转换说明 转换说明把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。例如，数字76在计算 机内部的存储格式是二进制数01001100。%d 转换说明将其转换成字符 7 和 6，并显示为 76；%x 转换说明把相同的值（01001100）转换成十六进制记数法 4c；%c 转换说明把 01001100 转换成字符 L。
整数类型的转换说明不匹配浮点数类型的转换说明不匹配 // 转换说明不匹配示例1 short j = -336; // 将一个负数打印为无符号 short int 类型，输出结果是65200 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a8d74a391f2063d15ae8c33302e4d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6016ae68e35cc4f9de6ef8753754a980/" rel="bookmark">
			关于数组的优缺点、数组遍历和数组拷贝.....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数组的特征 1.空间存储上，内存地址是连续的。 2.每个元素占用的空间大小相同。 3.知道首元素的内存地址。 4.通过下标可以计算出偏移量。 5.通过数学表达式，可快速计算某个下标位置元素的内存地址，直接通过内存地址定位，效率非常高。 2.数组的优缺点 优点：检索效率高。 缺点：随机增删效率较低，数组无法存储大数据量。 注意：数组最后一个元素的增删效率不受影响。 3.数组的初始化 1.一维数组初始化： 数组类型[] 数组名 = {元素1，元素2，元素3....}; 例如： int[] i = {2,5,3,7}; 以上是通过直接给数组中每个元素赋值并用{}的方式存储元素，该初始化方式称为“静态初始化”。 数组类型[] 数组名 = new 数组类型[数组长度]; 例如： String[] s = new String[4];//此时定义了一个长度为4，每个元素默认值为null的数组 通过new创建了一个定长数组，每个元素赋予默认值，该初始化方式为“动态初始化”。 2.数组动态初始化默认值： 基本数组类型： byte,short,int,long--默认值为：0 float,double--默认值为：0.0 boolean--默认值为：false char--默认值为：空格 引用数据类型： 默认值都为null。 3.二维数组初始化： 数组类型[][] 数组名 = {{元素1，元素2..},{元素10，元素11..},{}...}; 例如：int[][] i ={{1,2}{3,4}{7,8,9}}; 以上为静态初始化。 数组类型[][] 数组名 = new 数组类型[外层一维数组长度][内层一维数组长度]; 例如：int[][] i = new int[3][4]; 以上为动态初始化。 4.数组遍历 1.一维数组遍历：
int[] i = {2,4,5,6}; //1.采用for循环遍历 for(int j = 0; j &lt; i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6016ae68e35cc4f9de6ef8753754a980/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f64914aa939e0b577e8f8a55fc19567/" rel="bookmark">
			Win10新增的应用及功能说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10新增的应用及功能说明 适用于win10-19042.631版本，在之前的版本不一定会有以下应用 Win10-19042版似乎很多内置应用都是UWP应用，因此，多了很多有关UWP核心的exe，这些exe不能禁也不能删，会出现在“任务管理器中”。同时“服务”和“组策略”中也应小心应对有关UWP的设置。 一、基础知识 应用：即APP或程序，以前称为软件UWP 即 “Windows通用应用平台”，说简单一点，就是这种应用可以跨设备运行，即一个UWP应用可在平板、手机、电脑上运行，但是仅限于安装的win10系统的这些设备，所以，UWP只是跨设备，不能跨平台(即，在不同系统中运行，如可同时在windows、安桌、苹果上运行就叫跨平台），UWP程序只能在应用商店下载，所以有关应用商店的设置需要注意。UWP应用使用的是”Metro风格“，所以，若有提到”Metro应用“，则与UWP应用是相同的。 二、新增的应用及功能说明 1、ApplicationFrameHost.exe “应用程序框架主机进程”是支持Window通用应用的进程，结束该进程后，所有的windows 通用应用（就是Metro应用，UWP应用）都会强行结束。 2、CredentialEnrollmentManager.exe 凭据注册管理器，这是用于自动保存密码用的，可在【控制面板】【凭据管理器】找到，并进行密码管理 3、ctfmon.exe 微软的输入法，强制禁用会导致输入法消失 4、fontdrvhost.exe 应是管理字体的 5、LockApp.exe 管理windows的锁屏界面 6、Runtimebroker.exe 系统核心，且会运行N个，而且会时不时的自动运行或消失，不知道算不算新版win10的一个巨大BUG，因为，已经有巨量的svchost.exe了，现在又来一群Runtimebroker.exe运行Win10系统核心进程，用来进行Metro App(UWP应用)权限管理。主要用来进行开始屏幕磁贴与桌面的后台交互，负责检查App是否有某项权限(例如网络连接，打开摄像头之类的)，并提醒用户是否允许应用获取这些权限。 7、SearchApp.exe 这玩意儿似乎也不能强制禁掉，一禁掉后windows的所有搜索功能都会失灵，比如，使用文件管理器搜索文件都会失败，记事本搜索文字失灵等。 8、ShellExperienceHost.exe 是Explorer“外挂”， 管理开始菜单、通知中心、时钟界面、网络界面等Metro系统界面 9、StartMenuExperienceHost.exe 此程序要是没有了，直接导致开始菜单打不开 本文作者：黄邦勇帅（原名：黄勇）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9725f441c5001c61c87421a976ae4620/" rel="bookmark">
			AJAX常见的status状态码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.jianshu.com/p/a746b18396e2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565c1d6cf912ba32485b8cb38fb60018/" rel="bookmark">
			解决python的to_csv，会以科学记数法的方式写入到csv文件中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、本文案例背景
二、使用步骤
1.引入相关库函数
2.读入数据并拼接处理
3.写入到csv文件
总结
前言 码农张！ 此账号记录一些日常工作中遇到的一些问题，附解决方案
一、本文案例背景 背景：有一些相关数据，分为多张csv和excel文件，现需要对这些文件进行统计，取出需要的字段（此数据敏感，正文与数据相关使用XXX替代）。进行多表的数据拼接。最终写入到csv文件。
二、使用步骤 1.引入相关库函数 import pandas as pd 2.读入数据并拼接处理 data_1 = pd.read_csv( 'C:\\Users\\dell\\Desktop\\XXX\\XXX\\XXX.csv',encoding='gbk') data_2 = pd.read_excel( 'C:\\Users\\dell\\Desktop\\XXX\\XXX\\XXX.xlsx') #设置取的列名 此处时按列取 column = ['columns'] #取出相关数据字段 data_1 = data_1[column] data_2 = data_2[column] #合并数据 cancat的连接方式 合并后剔除空值和缺失值并重新赋值下标 concat_data=pd.concat([data_1,data_2],axis=0,join='outer').dropna().drop_duplicates(ignore_index=True) 结果数据如下所示： print(concat_data) 3.写入到csv文件 python的pandas同时也提供了多方式写出的功能，常用的如to_sql、to_excel、to_csv等等。本文使用to_csv导出到csv文件。 data.to_csv('C:\\Users\\dell\\Desktop\\XXXX.csv',encoding='utf-8') 这样写出方式是最普遍最常规的方法，但是对于本文使用的数据就出现了如下的错误。写出的csv表如下：
原因是因为pandas的to_csv底层实现原理是对一些比较长的数字通过科学计数法来写出的，会自动把后面位数变成0。这不是我们想要的。解决方法如下（将长数字转换为str类型）：
def num_out(data): data = str(data)+'\t' return data data = concat_data['XXX'].map(num_out) 通过上面的操作，我们的长数子就完美得到了解决了！
总结 主要做了一些简单的统计工作，总体来说是没有太大的难度。毕竟活全是pandas干的！ 哈哈哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04a672a2c05cc8b685d7d7f2301c548/" rel="bookmark">
			博弈论入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言一、什么是博弈？二、巴什博奕（Bash Game）三、再来看一下引言这道题四、再来试试某大学的招新赛的一道题 博弈论，又称为对策论（Game Theory）、赛局理论等，既是现代数学的一个新分支，也是运筹学的一个重要学科。（摘自百度百科）
引言 不知大家是否还记得这道题目？
一、什么是博弈？ 博弈的英文为game，我们可以简单把它理解为“做游戏”。
只是这个游戏有一定的规则，并且有至少两个参加者，参加者需要在遵守游戏规则的前提下想方设法让自己获取胜利。对于两名参加者，两人都足够聪明且不会出现失误。
通俗的讲，博弈就是对于游戏中一种选择策略的研究。
二、巴什博奕（Bash Game） 巴什博奕是博弈论中最基础的问题，是合作博弈的一种。只要找出其必胜态，那么问题就解决了。
题目：两个顶尖聪明的人在玩游戏，有n个石子，每人最少拿1个，最多拿m个，两人轮流取石子，谁先把石子拿完谁就获得胜利。
从简单情况开始分析，进而推广到一般情况
简单情况
当剩余石子有1—m个时，则先手必赢
当剩余m+1个石子时，先手不论拿走多少个，后手都可以一次拿完所有石子，后手必赢
当剩余m+2（m+1+1）个石子时，由于先手足够聪明，使用策略，先拿走1个，对于剩余的m+1个石子，不论后手怎么取，对于取剩下的石子先手都能一次性取完，先手必赢
当剩余m+3（m+1+2）个石子时，由于先手足够聪明，使用策略，先拿走2个，对于剩余的m+1个石子，不论后手怎么取，对于取剩下的石子先手都能一次性取完，先手必赢
当剩余2m+1（m+1+m）个石子时，由于先手足够聪明，使用策略，先拿走m个，对于剩余的m+1个石子，不论后手怎么取，对于取剩下的石子先手都能一次性取完，先手必赢
当剩余m+2—2m+1 （m+1+1—m+1+m）个石子时，先手均可通过策略，赢得胜利
当剩余2m+2（2(m+1)）个石子时，不论先手取1—m个，后手均可使用策略赢得游戏
当剩余2m+3（2(m+1)+1）个石子时… … …先手必赢
当剩余3m+2（2(m+1)+m）个石子时… … …先手必赢
当剩余3m+3（3(m+1)）个石子时… … …后手必赢
推广到一般情况
当n=k*(m+1)+x时，先手必赢（k=0,1,2,3… ，1&lt;=x&lt;=m）当n=k*(m+1)时，后手必赢（k=0,1,2,3…） #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; if(n%(m+1)==0){ cout&lt;&lt;"后手赢"; }else{ cout&lt;&lt;"先手赢"; } return 0; } 三、再来看一下引言这道题 随便举一个例子，比如这个字符串：00110
不难发现，在变成00000的前一步，字符串的最后一个字符都是‘1’。如此我们可以大胆的推测：如果末位字符为‘0’，则先手必败；否则先手必胜。
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { int t; string a; cin &gt;&gt; t; while(t--){ cin &gt;&gt; a; if(a[a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04a672a2c05cc8b685d7d7f2301c548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/901beb06206dff522da58fa2123bca65/" rel="bookmark">
			【STM32F042】串口发送字符串函数的注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 平时使用串口发送数据的时候，没有特意关注过它的实现细节，今天深入探究了一下，由32的中文参考手册，如下图所示，我们发送数据需要做的步骤是：
1.等待TXE(发送数据寄存器可写)标志位变成1
2.往寄存器USAERT_TDR里装数据
3.等待TC(发送完成)标志位置1，准备发送下一字节，重复1~3
代码实现发送字符串：
// 使用串口发送字符串 // 这里用的串口1 void usart_send(u8 *data) { while(*data) { while((USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET)); // TXE= 0 USART_SendData(USART1,*data); // TXE = 1可以发送 while(!USART_GetFlagStatus(USART1,USART_FLAG_TC)); // TC = 0 data++; // TC=1 } } } 测试： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c27ef1ffa7aef10e5a1e1707a668d4e/" rel="bookmark">
			如何将字符串转化为数字？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.stringstream方法 记得头文件添加sstream
#include &lt;iostream&gt; #include &lt;string.h&gt; #include&lt;sstream&gt; using namespace std; int main() { string a="1234"; stringstream geek(a); int b; geek&gt;&gt;b; cout&lt;&lt;b+5&lt;&lt;endl; return 0; } 2.-'0’法 number = number*10+a[i]-‘0’;
#include &lt;iostream&gt; using namespace std; int main() { string a="1234"; int l = a.length(); int b[l]; for(int i=0; i&lt;l; i++) { b[i]=a[i]-'0'; } for(int i=0; i&lt;l; i++) { cout&lt;&lt;b[i]; } } 3.标准库函数 itoa()：将整型值转换为字符串。
ltoa()：将长整型值转换为字符串。
ultoa()：将无符号长整型值转换为字符串。
gcvt()：将浮点型数转换为字符串，取四舍五入。
ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。
fcvt()：指定位数为转换精度，其余同ecvt()。
这里只进行演示了itoa 和 gcvt。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c27ef1ffa7aef10e5a1e1707a668d4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65383750c31e94108813725a4fd5fafe/" rel="bookmark">
			jQuery实现word导出功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在工作中应客户要求将前端table表格导出到word文档里（好想吐槽）
表格导入到Excel里不是更方便…（无语ing）废话不多说
首先实现导出功能想到的就是jQuery
要用到jQuery里面的几个Js文件
//必要的js文件 &lt;script src="FileSaver.js"&gt;&lt;/script&gt; //导出为docx文件 word2007也可以打开 &lt;script src="html-docx.js"&gt;&lt;/script&gt; //导出为doc文件 不支持旧版本的word &lt;script src="wordexport.js"&gt;&lt;/script&gt; //导出为doc文件需要引入jQuery docx则不需要 &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; 这个链接是几个JS源文件的压缩包需要的小伙伴自行下载
提取码是 Mont
https://pan.baidu.com/s/1bb7pulbgUp9Lv7D5jxFX4w
一.导出为Docx 1.引用插件html-docx.js
&lt;script src="html-docx.js"&gt;&lt;/script&gt; 2.编写完整html内容文档
var content = '&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;/head&gt;'+ 要导出的html信息 +'&lt;/html&gt;' content要导出的html信息，建议在服务端自己拼接完成。
若是想从页面抓取html信息，可以用下面的方法（不建议，客户端消耗高）
&lt;div id="content"&gt; 要导出的html信息 &lt;img src="xxx"&gt; &lt;/div&gt; var contenta = document.getElementById('content').innerHTML var content = '&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;/head&gt;' + contenta + '&lt;/html&gt;' 图片格式转换为base64
function convertImagesToBase64 (content) { var regularImages = content.querySelectorAll("img"); var canvas = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65383750c31e94108813725a4fd5fafe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6beadefb4debaeceef29773eb9752e/" rel="bookmark">
			python保存csv时出现中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述 在pycharm中用下面代码保存成csv格式时候，结果出现中文乱码
open('数据.csv',mode='a',encoding='utf-8',newline='') 2.问题解决 在网上搜索找到一个办法可以有效解决
将encoding=‘utf-8’ 改为 encoding=‘utf-8-sig’
3. 问题产生原因 以前没有遇到过这种解决的方法，对两者区别产生了好奇，又进行了搜索，整理如下：（反正我是看不懂orz）
1、”utf-8“ 是以字节为编码单元,它的字节顺序在所有系统中都是一样的,没有字节序问题,因此它不需要BOM,所以当用"utf-8"编码方式读取带有BOM的文件时,它会把BOM当做是文件内容来处理, 也就会发生类似上边的错误。
2、“utf-8-sig"中sig全拼为 signature 也就是"带有签名的utf-8”, 因此"utf-8-sig"读取带有BOM的"utf-8文件时"会把BOM单独处理,与文本内容隔离开,也是我们期望的结果。
参考链接来源：https://blog.csdn.net/qq_40258748/article/details/96306878
https://blog.csdn.net/qq_39248703/article/details/80175976
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1bc322b52a95a9aac0320f7ee6991e/" rel="bookmark">
			Java报错Exception in thread “main“ java.lang.NoClassDefFoundError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，编Java程序遇到的问题，具体报错如下图：
后来，自己捣鼓了两下，发现在second包下的Example14.java文件中有一个First类，如下图：
猜测，可能是类重名了？？然后，修改类名，如下图：
运行结果如下图：
祝大家顺利解决问题！
最后，感谢大家前来观看鄙人的文章，文中或有诸多不妥之处，还望指出和海涵。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bbf893b1ef1837d9d0ea974bdc84f7/" rel="bookmark">
			vue3 源码之内置组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		teleport组件 有一种场景是组件的一部分逻辑上属于该组件，但是需要显示在其它地方，类似于react的portals；
一个常见的场景是创建一个包含全屏模式的对话框组件。在大多数情况下，我们希望对话框的逻辑存在于组件中，但是对话框的定位 CSS 是一个很大的问题，它非常容易受到外层父组件的 CSS 影响。
把该组件渲染的这部分 DOM 挂载到 body 下面，这样就不会受到父级样式的影响了。
而 Vue.js 3.0 把这一能力内置到内核中，提供了一个内置组件 Teleport，它可以轻松帮助我们实现上述需求：
Teleport 实现原理 &lt;template&gt; &lt;button @click="showDialog"&gt;Show dialog&lt;/button&gt; &lt;teleport to="body"&gt; &lt;Dialog ref="dialog"&gt;&lt;/Dialog&gt; &lt;/teleport&gt; &lt;/template&gt; &lt;script&gt; import Dialog from './components/dialog' export default { components: { Dialog }, methods: { showDialog() { this.$refs.dialog.show() } } } &lt;/script&gt; 对于这类内置组件，Vue.js 从编译阶段就做了特殊处理，我们先来看一下前面示例模板编译后的结果：
import { createVNode as _createVNode, resolveComponent as _resolveComponent, Teleport as _Teleport, openBlock as _openBlock, createBlock as _createBlock } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54bbf893b1ef1837d9d0ea974bdc84f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad7566dcd8546e5906dfe0162da2746/" rel="bookmark">
			UnixBench-Linux主机性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UnixBench是一个类unix系统（Unix，BSD，Linux）下的性能测试工具，一个开源工具，被广泛用于测试linux系统主机的性能。
Unixbench的主要测试项目有：系统调用、读写、进程、图形化测试、2D、3D、管道、运算、C库等系统基准性能提供测试数据。
Unixbench一个基于系统的基准测试工具，不单纯是CPU内存或者磁盘测试工具。测试结果不仅仅取决于硬件，也取决于系统、开发库、甚至是编译器。
UnixBench会执行一系列的测试,包括2D和3D图形系统的性能衡量,测试的结果不仅仅只是CPU,内存,或者磁盘为基准,还取决于硬件,操作系统版本,编译器.
测试系统各个方面一系列的性能,然后将每个测试结果和一个基准值进行比较,得到一个索引值,所有测试项目的索引值结合在一起形成一个测试分数值.
UnixBench一键执行脚本,脚本会自动下载unixbench最新版本,并自动运行.根据机器性能,测试执行完大约需要10-30分钟.
1.下载Unixbench：
链接：https://pan.baidu.com/s/1KnHn_xBoUjXInvsOBEYE_A
提取码：2jmw
2.安装Unixbench：
[root@localhost unixbench]# ls UnixBench5.1.3.tgz [root@localhost unixbench]# tar zxf UnixBench5.1.3.tgz [root@localhost unixbench]# ls UnixBench UnixBench5.1.3.tgz [root@localhost unixbench]# cd UnixBench/ [root@localhost UnixBench]# ls Makefile pgms README results Run src testdir USAGE WRITING_TESTS [root@localhost UnixBench]# make Checking distribution of files ./pgms exists ./src exists ./testdir exists ./results exists gcc -o ./pgms/arithoh -DTIME -Wall -pedantic -ansi -O2 -fomit-frame-pointer -fforce-addr -ffast-math -Wall -Darithoh ./src/arith.c gcc -o .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad7566dcd8546e5906dfe0162da2746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dca99c99c278e27cc245743f9a19c29/" rel="bookmark">
			Error in render: “RangeError: Maximum call stack size exceeded“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单中点击提交按钮，无法跳转到相应界面并报错。
出现这个问题的原因是cros跨域，解决的方法就是令提交端口为本地端口，这样的话就不存在跨域请求了。
出现的Error in render: "RangeError: Maximum call stack size exceeded"问题，是因为堆栈溢出，原因是路由跳转进入死循环。经查验发现是路由拦截axios里出现了问题，当时给baseurl这里没有写http://直接写了localhost:8080。更改后跳转成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665bf4e3dd4398db50c6988211c9fac7/" rel="bookmark">
			vue3 源码之生命周期钩子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生命周期钩子对应的生命周期Option如下:
beforeCreate -&gt; 使用 setup() created -&gt; 使用 use setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy-&gt; onBeforeUnmount destroyed -&gt; onUnmounted activated -&gt; onActivated deactivated -&gt; onDeactivated errorCaptured -&gt; onErrorCaptured 除此之外, 还新增了两个用于调试的生命周期:
onRenderTrackedonRenderTriggered 注册钩子函数 export const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT) export const onMounted = createHook(LifecycleHooks.MOUNTED) export const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE) export const onUpdated = createHook(LifecycleHooks.UPDATED) export const onBeforeUnmount = createHook(LifecycleHooks.BEFORE_UNMOUNT) export const onUnmounted = createHook(LifecycleHooks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665bf4e3dd4398db50c6988211c9fac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212cebd2afb8f8e9b666359738559188/" rel="bookmark">
			STM32CubeMX_以太网_RMII_LwIP_TCP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 STM32CubeMX_以太网_RMII_LwIP_TCP 前言一、参考博文二、注意事项1.Server端网关的配置2.LwIP库针对每种协议类型都出台了参考源码3.网速测试 前言 提示：使用CubeMx配置以太网LwIP，stm32配置为TCP Server端。
一、参考博文 https://blog.csdn.net/weifengdq/article/details/102960914
https://blog.csdn.net/wofreeo/article/details/89359583
二、注意事项 1.Server端网关的配置 stm32作为Server端网关的配置要和电脑的的网关一致，如下
2.LwIP库针对每种协议类型都出台了参考源码 3.网速测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc78dabd53b59f70121be169742f99f/" rel="bookmark">
			电流采样电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、差分放大电路的优点？二、注意事项总结 前言 有时候我们需要对电流进行采样，但是电流实际是不好测量的，最简单的方法就是把电流转化为电压，这里推荐一种比较简单的放大电路。差分放大电路。大家可以看模电课本 283-284页的加减运算电路。
在这里就不推导公式了
一、差分放大电路的优点？ 差分放大电路的优点就是具有很高的共模抑制比，就共有的成分都被减掉了，剩下的就是两端的电压差并进行放大，这对于小信号的检测也是可以的。
Uo=(UI2-UI1)Rf/R.
二、注意事项 1.电阻要完全对称，最好完全一致
2.运放的供电电压要大于输入端电压
总结 这个电路还是比较重要的，反反复复碰到了好几次，也很好用哦。
参考博文：运放电流采样电路电压采样电路
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a94b52f2726994c7c7792d81c96f7378/" rel="bookmark">
			爱奇艺容器实践（内附云原生落地沙龙干货下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4月10日下午，爱奇艺技术产品团队举办了“i技术会”线下技术沙龙，本次技术会的主题是“云原生落地探索与实践”，邀请快手、百度和字节跳动的技术专家，与爱奇艺技术产品团队共同分享与探讨云原生落地的实践经验。
其中，来自爱奇艺的技术专家赵慰为大家带来了爱奇艺容器实践的分享，讲述了爱奇艺的容器应用场景和在容器网络、容器运行时方面的实践经验。
PS：关注公众号，在后台回复关键词“云原生”，就可以获得本次技术会嘉宾分享PPT和录播视频。
以下为“爱奇艺容器实践”干货分享，根据【i技术会】现场演讲整理而成。
爱奇艺容器实践/分享嘉宾：爱奇艺技术专家赵慰
本场分享的主要内容包括爱奇艺近年来在容器方面的实践经验和遇到过的问题，以及我们在选型和探索过程中的一些心路历程。
1、爱奇艺容器应用场景
爱奇艺内部超过一半的应用实例正在以容器形式运行，这些容器基本都运行在物理机集群上面。最初爱奇艺采用Mesos框架、基于Mesos的开源服务调度框架Marathon和自研批处理框架Sisyphus，并基于Marathon研发了QAE（iQIYI App Engine）。当时，大量公司以Mesos/Marathon为基础做着类似的事情。前不久，有消息表明Mesos即将从Apache光荣退休，而Twitter贡献的著名Mesos调度框架Aurora项目也早在去年二月份就已进入Apache退役名单。对于Mesos的告别，我们感到非常遗憾，同时也加快了向Kubernetes转型的脚步。爱奇艺在Kubernetes方面起步较晚，之后除提供原生K8S服务之外，我们还会进一步在K8S基础上提供不同抽象级别的应用引擎，包括Serverless、FaaS、workflow等，希望以后能够有机会和大家分享我们后续的工作。
2、容器网络实践
爱奇艺容器网络应用的发展如图所示：
我们在Mesos框架用的最多的是Docker原生的local Bridge + NAT，于2014年投入使用，现在还在大量运行；中途尝试过Calico，然而当时Docker和K8S等组织有关容器网络标准的争论导致我们无法全力投入某种技术，加之管理难度的限制，最终导致Calico方案并没有在爱奇艺大规模应用；后来发展K8S时，由于之前NAT策略在应用上不太友好，所以我们定了一个基础方向，将容器网络跟内网打通，并选了一些具体实现方法，比如VXLAN、Calico/CNI。后来Cilium出现，并在一些公司得到应用，大家比较感兴趣；既然我们起步已经晚了，倒不如直接采用一些激进的新方案奋起直追。
可能有些同学对CNM（Container Network Model，容器网络模型）和CNI（Container Network Interface，容器网络接口）的容器标准之争不太了解，下面做一个简单的解释：
Docker将自己的网络方面剥离出一个独立项目libnetwork并提出了CNM，定义了网络、接入点等概念以及创建网络、加入网络等操作，允许第三方插件按照标准与Docker对接；CoreOS则提出了更为简单的CNI，只定义了往网络里面加减容器的接口标准。当时对于两款接口的使用，两家公司各执一词。对于K8S方来说，他们觉得CNM的接口和Docker的结合过于紧密，所定的用户操作标准也过于复杂，CNI相比CNM来说更加安全、简单、松耦合；Docker方对此的官方回复是，K8S等社区的意见和建议不符合Docker的整体设计。最终K8S选择了CNI作为网络方案。现在CNI在行业应用中占据主导地位，但对于插件来说，无论对哪个接口，所做的工作内容都是差不多的，例如CNM要求网络配置要通过Docker的libKV存储，而CNI没有这方面的要求，但对于网络插件来说，它的存储总是要有的，只不过由插件自己管理或由K8S统一管理对于K8S用户来说更加方便。
（1）Bridge + NAT 回到Mesos环境中。由于当时Mesos还没有很好地支持CNI，而爱奇艺在使用CNM中遇到了很多管理和运维上的困难，最简单可靠的Bridge + NAT方案成为了唯一选择。当时我们想的也比较简单、理想化，认为不管走NAT还是不走NAT，在服务注册发现把这些信息掩饰掉就好。但在长期的实践中，这层NAT还是给我们的运维工作带来了无比多的烦恼。
我们遇到的常见问题包括RPC暴露服务地址、排障时IP PORT查应用不能正常使用、Nginx Keepalive失效等。另外还有一些偶发问题比如网卡无法释放、IP冲突等等，但整体来说还是比较可靠。
Nginx Keepalive失效是这几个问题里面比较棘手的一个。
问题：多个 RS，通过 Nginx 代理请求，QPS 极低，偶发 502，有一定规律复现。
解决：
1）抓包：——Nginx：502 时，直接收到 RST；
——RS 容器内：中间发送过 FIN，502 时没有包。
2）解决：
推测几个可能性：
——iptables 有 bug——然而相关文章表明，这种情况只会小概率出现并不会稳定出现，不太符合这个 bug 的现象，而且该服务使用短链接访问 FIN 正常，故排除此原因；
——bridge 网络问题：小概率出现，同样不符合；
——iptables NAT 规则问题：继续抓包，从RS容器发出的FIN包入手，主机上被没有处理，进而发现时主机NAT表里已经没有了Nginx到RS的连接转换规则，联系到低频请求的情况，最终判断为是RS空闲超时后主动断开keepalive连接，而Nginx并不知情仍尝试使用旧连接导致访问失败。
这个问题没有完美的解决方案，缓解思路有几个：
1）将内核参数net.netfilter.nf_conntrack_tcp_timeout_established调大，使NAT规则容忍的空闲时间超过RS容忍的空闲连接时间；
2）Nginx或其他客户端使用Keepalive时使用TCP心跳等机制维持连接；
3）全部使用短连接请求。
（2）Bridge/CNI + VXLAN
应用K8S之后，一开始爱奇艺尝试了Bridge/CNI + VXLAN。对于二层网络，K8S官方至今没有给出最佳实践方案。我们只了解到类似GCE等公有云通过这种方式使用，但整个工作应该和Docker早期一个叫pipework的工具差不多，还是比较简单好用的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a94b52f2726994c7c7792d81c96f7378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36553893ad227207312fb385a305e05b/" rel="bookmark">
			QT应用编程: 程序发布添加版权、版本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境介绍 操作系统: win10 64位
QT版本: QT5.12.6
编译器: MinGW 32
二、在xxx.pro文件里添加产品、版权信息 #可执行文件名称 TARGET=FFMPEG_Player #版本信息 VERSION = 1.3.3 #图标 RC_ICONS =resource/logo.ico #公司名称 QMAKE_TARGET_COMPANY = "Jiangxi Shangdao Jingcheng" #产品名称 QMAKE_TARGET_PRODUCT = "QMDK_VedioPlayer" #文件说明 QMAKE_TARGET_DESCRIPTION = "Qt Creator based on Qt 5.12.6 (MinGW 32 bit)" #版权信息 QMAKE_TARGET_COPYRIGHT = "Copyright 2021-2026 The Jiangxi Shangdao Jingcheng Company Ltd. All rights reserved." #中文（简体） RC_LANG = 0x0004 如果设置的变量值是中文，需要将.pro文件以system本地编码保存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9331aba33531a76f6bf1e48bb626cc95/" rel="bookmark">
			vue 中v-model和v-decorator的用法区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-model:是双向数据绑定，啥为双向绑定，即为绑定的是个变量，当变量的值改变，双方都会跟着改变。也可用于form表单。
v-decorator：一般用于form表单下的a-form-item 下的控件上，其用法如下：
相当于html的name属性，用来识别和绑定加载的数据，‘qcStatus’即为name值，validatorRules验证规则，用来设置验证信息，like this :qcStatus: { rules: [{ required: true, message: ‘请选择评审结果’ }] }。
两个的用法相近，开发过程中根据实际情况选用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5104c7ba25db8834c881d9ce4fce3c44/" rel="bookmark">
			C语言中数的二进制、八进制、十进制以及十六进制表示及输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以十进制数163为例： 二进制的英文是Binary，简写为B或BIN，所以163 = 0b10100011（前面加上“0b”或“0B”）
八进制的英文是Octal，简写为O或OCT，所以163 = 0243（前面加上数字0，以示与十进制的区别）
十进制的英文为Decimal，简写为D或DEC，所以163 = 163（没有前缀）
十六进制的英文为Hexadecimal，简写为H或HEX，所以163 = 0xA3（前面加上“0x”或“0X”） win10自带计算器：
代码：
#include &lt;stdio.h&gt; int main(void) { int a = 0b10100011; //二进制数字 int b = 0244; //八进制数字 int c = 0XA5; //十六进制数字 printf("八进制输出：\n"); //以八进制形似输出 printf("a=%o, b=%#o, c=%#o\n", a, b, c); //中间加上#，可以输出前缀 printf("十进制输出：\n"); //以十进制形式输出 printf("a=%d, b=%#d, c=%#d\n", a, b, c); //十进制没有前缀，加上没啥用 printf("十六进制输出：\n"); //以十六进制形式输出 printf("a=%x, b=%#x, c=%#X\n", a, b, c); //X大写，则输出的前缀和字母都大写 return 0; } 运行结果：
参考文章：2.1 C语言中的进制数的表示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc009b217197f797a9a5db9504461f0/" rel="bookmark">
			Aspose.Words For Java破解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自大佬的文章https://blog.csdn.net/xiaostuart/article/details/111479549
1.项目中引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.27.0-GA&lt;/version&gt; &lt;/dependency&gt; 2.修改指定类中的返回值 public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException { ClassPool.getDefault().insertClassPath("/Volumes/KESU/安装程序/aspose-words-20.12.0-java/lib/aspose-words-20.12.0-jdk17.jar"); CtClass zzZJJClass = ClassPool.getDefault().getCtClass("com.aspose.words.zzZDZ");//找到指定类 //找到指定方法 CtMethod zzZ4u = zzZJJClass.getDeclaredMethod("zzZ4n"); CtMethod zzZ4t = zzZJJClass.getDeclaredMethod("zzZ4m"); //修改返回值 zzZ4u.setBody("{return 1;}"); zzZ4t.setBody("{return 1;}"); //输出到指定路径 zzZJJClass.writeFile("/Volumes/KESU/安装程序/aspose-words-20.12.0-java/"); } 3.把aspose-words-20.12.0-jdk17.jar后缀改成rar/zip等能解压的格式，解压为aspose-words-20.12.0-jdk17（文件名随意） 4.把刚刚生成zzZDz.class文件替换到com.aspose.words中 5.删除aspose-words-20.12.0-jdk17中META-INF中的.RSA和.SF后缀的文件 6.进入aspose-words-20.12.0-jdk17的根目录，执行命令jar cvfm aspose-words-20.12-jdk17-crack.jar META-INF/MANIFEST.MF com/ 7.将生成的jar文件放到maven库中，mvn install:install-file -Dfile="/Volumes/KESU/安装程序/aspose-words-20.12.0-java/lib/aspose-words-20.12-jdk17-crack.jar" -DgroupId=com.aspose -DartifactId=aspose-words -Dversion=20.12 -Dpackaging=jar https://pan.baidu.com/s/1EHuDR-1pxRCzB4iQlqJxWQ 提取码 i8uv
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760545ae4e4a54eb85782390fbb96102/" rel="bookmark">
			samba不允许一个用户使用一个以上用户名与服务器或共享资源的多重连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景： 背景一：同一台电脑A，访问过服务器的一个samba共享文件夹B，此时再访问服务器的另一个共享文件夹C时显示访问出错，再访问共享文件夹B时也显示访问出错，出错信息如下： 无法访问，你可能没有权限使用网络资源。请与这台服务器的管理员联系以查明你是否有访问权限。
不允许一个用户使用一个以上用户名与服务器或共享资源的多重连接。中断与此服务器或共享资源的所有连接，然后再试一次。
背景二：在CMD窗口下使用以下各类命令依旧无效果 net use * /del /y net use \\服务器IP\用户名 /delete net use \\服务器IP\用户名 /user:用户名 net use \\服务器IP\用户名 "用户密码" /user:用户名 解决办法： win10系统下，直接在搜索框搜索【凭据管理器】，然后添加windows凭据，填入将要访问的共享地址D，用户名、密码，确定，最后访问共享地址D即可。
注：此时你只能访问共享文件夹zhangsan，如果你想访问共享文件夹lisi，需要重新按照以上步骤添加lisi共享文件夹相关的凭证信息。 参考博文 https://blog.csdn.net/cyj51060/article/details/108472088?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-4.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-4.nonecase
注：参考博文中有讲win7中的设置方法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d80870e8e0f9a81eafa1b32064f631/" rel="bookmark">
			JSONP 方式实现跨域请求数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在了解 浏览器的同源政策（SOP） 后知道了浏览器的同源政策对保护用户信息安全的重要性。但是有些时候我们确实需要两个网站间的数据共享。例如腾讯天气的天气数据就是从其他服务器上获取到的，并不是腾讯天气服务器上的数据。那它们是怎么做到跨域资源（数据）共享的呢？在这里学习一下 jsonp 方式实现跨域资源共享。
JSONP 实现原理 并不是页面中所有的请求都受同源政策的限制。例如外链外部 js 文件文件时是不受同源政策的限制的，这也是为什么在使用 jQuery 时，我们并不是一定要将库文件下载到项目后才能引入使用。我们也可以直接引入 jQuery 的线上文件，并不影响正常使用。它的原理是虽然此时进行了跨域（线上资源在 jQuery 的官网上），但是 script 标签的 src 属性外链的资源请求不受浏览器同源政策的影响。这也是我们使用 JSONP 实现跨域资源共享的原理。
JSONP 的基础原理如下示例代码所示（注意 A 服务器监听 3000 端口，B 服务器监听 3001 端口，下面的所有示例都在同源政策的基础上改进，所以不会再做具体说明。）：
&lt;!-- A服务器响应的页面中的代码 --&gt; &lt;body&gt; &lt;h2&gt;A服务器的页面&lt;/h2&gt; &lt;!-- 全局作用域下定义fn1函数（用来处理接收数据） --&gt; &lt;script&gt; function fn1(data) { console.log(data); } &lt;/script&gt; &lt;!-- 利用script标签发送跨域请求 --&gt; &lt;script src="http://localhost:3001/jsonp1"&gt;&lt;/script&gt; &lt;/body&gt; 如下图是响应的结果，想必从图中也你可以猜出了服务器端的代码。
// B服务器响应路由的代码 B.get('/jsonp1', (req, res) =&gt; { res.send('fn1({name: "tkop", age: 18})'); }); 结合上面的代码示例总结 JSONP 的原理：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d80870e8e0f9a81eafa1b32064f631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c284d0f9a743763930ed658879fc7f/" rel="bookmark">
			[现代密码学] Crypto 知识点总结（古典密码&amp;&amp;对称加密&amp;&amp;hash函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 . 常见加解密SM1-4 二. 古典密码代换密码置换密码Hill密码转轮密码代换密码的唯密文攻击例题例题 三. 对称加密算法分组密码DES算法（数据加密标准）1. Feistel结构2. 轮函数3. 密钥编排算法4. 末置换5. 安全增强 AES算法（高级加密标准）对称加密流程AES的密钥编排算法AES的解密变换 分组密码的运行模式1. ECB模式2. CBC模式3. CFB模式4. CTR模式（计数器） 例题流密码RC4算法（序列密码）例题 四. Hash函数SHA-256算法例题 一 . 常见加解密 SM1-4 国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。
SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。
SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。
SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。
SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。
二. 古典密码 代换密码 分类：
移位（凯撒）密码
仿射密码
单表代换
多表代换
置换密码 Hill密码 转轮密码 恩格码机
代换密码的唯密文攻击 1.统计攻击2.重合指数法 例题 密码分析可分为那几类，它们的含义是什么？
根据密码分析者可能取得的分析资料的不同，密码分析（或称攻击）可分为下列四类：
1）唯密文分析（攻击），密码分析者取得一个或多个用同一密钥加密的密文；
2）已知明文分析（攻击），除要破译的密文外，密码分析者还取得一些用同一密钥加密的明密文对；
3）选择明文分析（攻击），密码分析者可取得他所选择的任何明文所对应的密文（当然不包括他要恢复的明文），这些明密文对和要破译的密文是用同一密钥加密的；
4）选择密文分析（攻击），密码分析者可取得他所选择的任何密文所对应的明文（要破译的密文除外），这些密文和明文和要破译的密文是用同一解密密钥解密的，它主要应用于公钥密码体制。移位密码，仿射密码，单表代换密码都没有破坏明文的频率统计规律，可以直接用统计分析法
字母频率分析法对（单表代换密码）算法最有效
例题 三. 对称加密算法 引自合天网安实验室：https://www.hetianlab.com/expc.do?ce=7bbc91e0-a9b3-4af9-a108-ce94117ee430 以及现代密码学（谷利泽版） 分组密码 设计思想：
混淆：明文/密钥和密文之间的关系复杂分组：明文/密钥的每一个比特都影响密文的每一个比特 DES算法（数据加密标准） 1. Feistel结构 明文和密文分组长度为64Bit，密钥长度56bit（密钥空间2^56）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03c284d0f9a743763930ed658879fc7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba555ea76e87cd74e5ec8dd48c995d6/" rel="bookmark">
			2021毛概知识点章节整理(完整版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想看更多算法题，可以扫描上方二维码关注我微信公众号“数据结构和算法”，截止到目前我已经在公众号中更新了500多道算法题，其中部分已经整理成了pdf文档，截止到目前总共有1000多页（并且还会不断的增加），可以在公众号中回复关键字“pdf”即可下载。
总共有20页，就不在一一复制，可以扫描最上面的二维码，关注微信公众号“数据结构和算法”，回复1003即可获得下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60edcf1db9ce986e1d23fff9897f7c8c/" rel="bookmark">
			2021年专升本高等数学真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想看更多算法题，可以扫描上方二维码关注我微信公众号“数据结构和算法”，截止到目前我已经在公众号中更新了500多道算法题，其中部分已经整理成了pdf文档，截止到目前总共有1000多页（并且还会不断的增加），可以在公众号中回复关键字“pdf”即可下载。
可以扫描最上面的二维码，关注微信公众号“数据结构和算法”，回复1007即可获得下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2002d3381ae0808ec6d1ad127e380b4a/" rel="bookmark">
			浅谈数据开发神器——数栈离线开发平台（BatchWorks）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数栈是云原生—站式数据中台PaaS，我们在github和gitee上有一个有趣的开源项目：FlinkX，FlinkX是一个基于Flink的批流统一的数据同步工具，既可以采集静态的数据，也可以采集实时变化的数据，是全域、异构、批流一体的数据同步引擎。大家喜欢的话请给我们点个star！star！star！
github开源项目：https://github.com/DTStack/flinkx
gitee开源项目：https://gitee.com/dtstack_dev_0/flinkx
随着数智化时代的到来，企业需要汇聚各业务板块数据，提供一个强大的中间层为高频多变的业务场景提供支撑。基于此类需求，“数据中台”应运而生，将数据提炼为数据资产，转换成业务需要的数据「血液」。
数据中台的建设与运营，通常包含如下活动：数据汇聚、数据加工与提炼、对外提供数据服务这3部分。其中的数据汇聚、数据加工与提炼能力，是由作为数据中台建设基座的离线开发平台提供的。
一、应用场景 例如，某服装企业需要统计最近3个月在全国不同城市中，不同款式的服装的销量情况/库存情况，用于指导下一步的销售活动和款式设计，这些数据需要每天更新，这就是典型的离线计算场景。为了完成上述流程，数据部门需要进行如下处理动作：
将最近3个月的销售数据、库存数据从业务系统中抽取出来，要支持每天的增量抽取；结合统计需求，编写SQL进行统计；数据每天更新，需要以天为周期，触发数据抽取、SQL统计的脚本，每天进行数据更新；监控任务的运行情况，当发生异常情况时，需要进行排错、重刷历史数据等操作； 为解决以上场景的问题，需要在数据采集、存储、加工等方面进行各种选型对比，通常可归类为以下2类：
1、基于MySQL、Greenplum等关系型或MPP类数据库：
数据采集：可采用开源的Kettle、DataX等组件，配合shell脚本实现数据抽取；数据开发：本地文本编辑器、Navicat等工具，配合Shell脚本实现数据开发+周期调度；数据运维：人工观察结果数据产出，没有成熟的运维工具，通常都是业务方发现数据问题反馈给技术人员，响应滞后；集群运维：集群监控、告警、扩缩容均手动进行。 2、基于Hadoop体系的技术方案
Hadoop体系通常会采用HDFS+YARN作为基座，再配合Hive、Spark、Impala等引擎作为扩展；数据采集、开发、调度，均有多种可选，例如Sqoop、Hue、Oozie/Azkaban/AirFlow等，再配合Shell进行各类组件的打通与配置管理集群运维：可采用开源的Cloudera Manager等工具。 3、以上2类场景存在以下几种问题：
采集、开发、调度、运维的工具都比较原始，由各种开源组件拼凑组合形成，没有统一高效的管理方式，适用于小规模团队，无法满足大规模、团队协作化的数据中台建设；在数据采集方面，DataX、Kettle等组件一般都是单点使用，无法满足大吞吐量、高并发的数据同步场景；在数据开发、任务调度方面，通常只能采用文本编辑器+Navicat+Shell的原始方案，数据开发体验较差，在系统参数、调度打通、函数管理、元数据查看等方面存在各种体验问题；调度引擎与任务运维方面，开源的Azkaban、AirFlow虽然支持基本的调度逻辑，但与开发环节彼此割裂，没有实现无缝打通。在任务运维方面，只有基本的状态监控，在重刷历史数据、任务异常处理、告警配置等方面均有所欠缺；在数据管理方面，开源的Hue只有基本的元数据查看，在数据权限、生命周期、元数据扩展等方面均难以满足。 二、BatchWorks主要功能 BatchWorks提供的各项功能，完整覆盖上述场景中的各种需求，包含的功能模块如下：
1、数据同步：
分布式系统架构：基于自研分布式同步引擎（FlinkX），用于在多种异构数据源之间进行数据同步，具有高吞吐量、高稳定性的特点；丰富的数据源支持：支持关系型数据库、半结构化存储、大数据存储、分析性数据库等20余种不同的数据源；可视化配置：主要包括同步任务选择源表、目标表、配置字段映射、配置同步速度等步骤，2分钟即可完成配置；断点续传：系统自动记录每次的同步点位，下一周期运行时，自动从上次的读取位置继续同步，既可以减轻源库的压力，又可以保障同步的数据无遗漏、无重复；整库同步：快速、批量配置大量同步任务，节省大量初始化精力。脏数据管理：在读取、写入阶段发生异常的数据，系统可将这部分数据保存下来，便于用户及时排查脏数据问题。 2、数据开发：
丰富的任务类型：支持SparkSQL、HiveSQL、Python、Shell等10余种不同的任务类型，满足不同场景下的数据处理需求；丰富的系统参数：内置多个系统参数，可根据需要指定自定义系统参数，支持常量、变量，可指定丰富的时间格式和时间计算模式；优秀的开发体验：支持代码高亮、关键字/表名/字段名智能提示、语法检测、编辑器主题、快捷键等功能，为用户提供优秀的编码体验；本地文件导入：支持本地csv、txt文件导入至数据表，用于临时性数据分析；函数管理：支持Hive、Spark等计算引擎的函数查看、UDF函数的注册。 3、调度引擎：
基于自研分布式调度引擎，满足任务的周期性、依赖性调度，支持百万级别任务调度；系统可智能识别当前任务的代码与依赖信息，并自动推荐上游任务；根据用户的调度配置，智能识别超出有效期的任务，自动取消运行，节约计算资源。 4、运维中心：
自动监控并统计每日跑批进度、异常情况等信息，汇总易出错任务，协助用户排查代码质量、平台运行情况等问题；实时监控实例运行情况，进行查看日志、重跑、终止、恢复调度等操作；通过指定时间范围，快速重刷历史数据，操作简单、便捷；可根据失败、超时等多种条件触发告警规则，通过短信、邮件等方式将异常信息发送给指定人员。 5、安全保障：
BatchWorks采用多种方式保障数据安全和功能操作的安全，主要涵盖集群安全、数据安全和功能安全3部分：
集群安全：可对接开源Kerberos组件，保障平台安全访问。数据安全：支持用户跨项目权限申请，可指定需要的具体操作内容和字段信息，经管理员审批通过后可访问。功能安全：内置管理员等多种角色，不同的角色有不同的操作权限，保障功能安全。 三、产品优势 1、全生命周期覆盖：
覆盖数据采集、数据处理、调度依赖、任务运维等场景，充分满足离线数据开发过程中的各项需求，相比传统的开源工具，可以节省80%数据开发时间。
2、多引擎、异构对接：
兼容开源、Cloudera、Hortonworks、星环、华为Fusion Insight等各种Hadoop体系或MPP类数据库作为计算引擎；一套离线开发平台支持同时对接多套云环境的异构引擎，例如：一套BatchWorks同时对接阿里云 EMR、AWS EMR、本地机房TiDB引擎； 3、自主知识产权：2大核心模块100%自研，掌握全部知识产权
批流一体数据同步引擎FlinkX：基于Flink框架自主研发的分布式、插件化、批流一体数据同步引擎FlinkX，具备全量/增量/实时数据抽取全栈能力。该引擎已经在Github上开源高性能分布式调度引擎DAGScheduleX：自主研发的分布式DAG调度引擎，支持百万级任务并发，具备周期性、依赖性、优先级等多种调度配置 4、在线化、可视化操作：
产品通过Web页面为用户提供服务，屏蔽底层复杂的分布式计算引擎，在线化开发平台，提高开发效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad34ca76a1d6a6af66a18dde6f629695/" rel="bookmark">
			u盘格式化后如何恢复数据，三步轻松恢复！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		u盘是工作中必不可少的设备，特别是出差的时候，大家都会携带u盘，但是如果操作不当导致u盘格式化怎么办？U盘格式化后数据会全部被清空，出门在外请维修人员上门又不方便，难道就只能这样干着急吗？
小编推荐使用u盘格式化恢复工具 — 易我数据恢复软件恢复u盘格式化后的数据。
当我们的u盘出现误删的时候，首先要做的就是不要去写入新的数据，也不要再去删除u盘上的数据，这些做法是防止数据被覆盖，导致我们无法恢复u盘上的数据。
接着，我们就可以使用易我数据恢复软件找回u盘上的数据。
下载Win版本
下载Mac版本 步骤 1. 连接U盘和计算机
将u盘插入计算机，紧接着运行易我科技U盘格式化恢复软件。
查看外置硬盘列表中是否显示U盘，如果软件没有读取到移动盘，请点「刷新」图标。
步骤 2. 从格式化的U盘还原资料
在「外置设备」下，左键点击usb图标，接着点击「扫描」。
在扫描的过程中，数据恢复软件会逐一将查找到的资料显示在结果栏中。
扫描结束后，请优先检查「丢失的分区」下的结果。
步骤 3. 预览后还原
通过预览面板查看资料内容。
选择需要的资料，点击「恢复」。
参考资料：https://www.easeus.com.cn/format-recovery/gshhf1003.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5552c4ff4ca59971bf2627225e94f9c9/" rel="bookmark">
			18.Flink开发笔记三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink开发笔记三 1. 表2. 更新模式3. 输出到mysql4. 动态表转换成DataStream5. 时间特性6. 窗口6.1. 案例 7. 函数7.1. 一对一，scalar函数 1. 表 2. 更新模式 3. 输出到mysql 4. 动态表转换成DataStream 5. 时间特性 6. 窗口 6.1. 案例 package com.xiaofan.apitest.tabletest import com.xiaofan.apitest.source.SensorReading import org.apache.flink.streaming.api.TimeCharacteristic import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor import org.apache.flink.streaming.api.scala._ import org.apache.flink.streaming.api.windowing.time.Time import org.apache.flink.table.api._ import org.apache.flink.table.api.bridge.scala.StreamTableEnvironment import org.apache.flink.types.Row object TimeAndWindowTest { def main(args: Array[String]): Unit = { val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val tabEnv: StreamTableEnvironment = StreamTableEnvironment.create(env) val inputPath = "D:\\big-data\\code\\FlinkTutorial\\src\\main\\resources\\sensor.txt" val inputStream: DataStream[String] = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5552c4ff4ca59971bf2627225e94f9c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84d132d52136cd40ee7d300d361fb9d/" rel="bookmark">
			element ui table 组件固定列踩坑 使用doLayout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		切换数据源 导致table 固定列多出一行空白 使用table 组件自带的方法可解决
获取数据后
就哦啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83939ba5def80281912b52cb22cf1d3f/" rel="bookmark">
			js 常见算法（递归、循环）实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		斐波拉契数列 斐波拉契数列 （Fibonacci sequence）又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）
递归 函数自己调用自己本身，或者在自己函数调用的下级函数中调用自己。所有的递归都可以用循环来实现
求和 // 递归 function sun(n) { if (n === 1) return 1 return sun(n - 1) + n } sun(100) // 循环 function sun1(n) { let a = 0 while (n &gt; 0) { a += n; n-- } return a } sun1(100) 斐波拉契数列 // 斐波拉契数列 1,1,2,3,5,8,13,21,34,55,89...求第 n 项 // 递归 function fib(n) { if (n === 1 || n === 2) return n - 1 return fib(n - 1) + fib(n - 2) } fib(10) // 循环 function fn(n) { var a = 0, b = 1, c = a + b; for (let i = 3; i &lt; n; i++) { a = b; b = c; c = a + b; } return c } fn(10) 爬楼梯 假如楼梯有 n 个台阶，每次可以走 1 个或 2 个台阶，请问走完这 n 个台阶有几种走法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83939ba5def80281912b52cb22cf1d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a852b9bbe4d7dbcb960491b9bdd59d0/" rel="bookmark">
			面试官：如何使用CSS完成视差滚动效果?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、是什么 视差滚动（Parallax Scrolling）是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验
我们可以把网页解刨成：背景层、内容层、悬浮层
当滚动鼠标滑轮的时候，各个图层以不同的速度移动，形成视觉差的效果
二、实现方式 使用css形式实现视觉差滚动效果的方式有：
background-attachment
transform:translate3D
background-attachment 作用是设置背景图像是否固定或者随着页面的其余部分滚动
值分别有如下：
scroll：默认值，背景图像会随着页面其余部分的滚动而移动
fixed：当页面的其余部分滚动时，背景图像不会移动
inherit：继承父元素background-attachment属性的值
完成滚动视觉差就需要将background-attachment属性设置为fixed，让背景相对于视口固定。及时一个元素有滚动机制，背景也不会随着元素的内容而滚动
也就是说，背景一开始就已经被固定在初始的位置
核心的css代码如下：
p { height: 100vh; } .g-img { background-image: url(...); background-attachment: fixed; background-size: cover; background-position: center center; } 整体例子如下：
&lt;style&gt; div { height: 100vh; background: rgba(0, 0, 0, .7); color: #fff; line-height: 100vh; text-align: center; font-size: 20vh; } .a-img1 { background-image: url(https://images.pexels.com/photos/1097491/pexels-photo-1097491.jpeg); background-attachment: fixed; background-size: cover; background-position: center center; } .a-img2 { background-image: url(https://images.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a852b9bbe4d7dbcb960491b9bdd59d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e193fe7dfa6a3f59b23d677d96e78fb7/" rel="bookmark">
			Python学习第三天_条件分支与循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python学习第三天_条件分支与循环 个人简介条件选择 (if ... elif ... else...)循环语句 (while...)循环语句 (for...in...)数值序列方法 (range)停止(break) 与 跳出(continue）成员运算符（in） 与 身份运算符（is）成员运算符innot in 身份运算符isis not 运算符优先级 个人简介 本文由JAVA小白：林夕—梦雪编写
林夕—梦雪（本人）为自学者
如有错误请练习修改
欢迎各位道友提出建议
QQ:2190287907
条件选择 (if … elif … else…) if 判断条件: 当if条件成立时，执行此处代码 elif 判断条件: #当前面if不成立时才会执行elif判断 当elif条件成立时,执行此处代码 else:	#前面所有条件都不成立时才会执行 当前面条件都不成立时，执行此处代码 循环语句 (while…) while 判断条件: #当条件成立时才会执行循环体内代码 循环体	#每执行完一次循环体都会再次判断条件是否成立 #成立则再次执行循环体内代码 #不成立则跳出 循环语句 (for…in…) for 变量名 in 集合: 循环体 #变量名内储存的变量会自动获取集合内容 #注意字符串也属于集合 数值序列方法 (range) range(起始值,结束值+1,步进) #起始值不输入默认为0 #步进不输入默认为1 我们可以使用range生成等差数值序列
for a in range(11): print(a) #输出为 0 1 2 3 4 5 6 7 8 9 10 停止(break) 与 跳出(continue） break 停止当前循环
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e193fe7dfa6a3f59b23d677d96e78fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2855078c2e3647f1605982a9ce98ccb7/" rel="bookmark">
			【墨尘の笔记】数据结构与算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 仙人指路 [第一章]为入门，讲解数据结构是干什么的
[第二章]到第四章是数据结构基础，主要讲解链表，栈，队列，串等
[第五章]是二叉树
[第六章]是图,此章偏难，非考研或算法从业可粗略看
[第七章]到第八章是查找以及各种排序
[第九章]为补充，教材中没有的部分概念我随机补充上去
墨尘の话 本文内容主要参考王道考研，其中21版本咸鱼学长的课尚可，20版本比较枯燥,可选择性学习
浙大陈越姥姥的课比较精简且侧重于练习，能看懂且时间多的蛋疼可以看这个
因时间关系,后期比较匆促，本人也就是学着玩玩╮(╯▽╰)╭，可多参考链接自主学习
参考视频 2020 王道考研 数据结构 - B站
数据结构-浙江大学 - B站
第一章 1.1.1 数据机构的基本概念 1. 什么是数据结构 数据：信息的载体，是描述客观事务属性的数，字符，以及所有能输入到计算机种并被计算机程序识别和处理的符号集合
数据对象： 具有相通性质的数据元素的集合，是数据的一个子集
数据元素： 数据的基本单位，通常作为一个整体进行考虑和处理
数据项： 构成数据元素的不可分割的最小单位
举例：一群人，就是一个数据对象，每个人就是一个数据元素，他们的手，头等就是数据项
结构：数据中存在某种关联关系，称为结构
举例：小明是八年级一班中的学生，成绩为100
上例中小明和成绩是数据项，一班是数据元素，八年级是数据对象
2. 数据结构三要素 1. 逻辑结构 线性结构
线性结构： 数据元素是一对一的关系，除了第一个元素，所有都有唯一前驱（前面有一个节点）；除了最后一个元素，所有元素都有唯一后继（后面有一个节点）
非线性结构
集合： 一组元素属于同一个集合，除此外别无关系
树形结构： 数据元素之间是一对多的关系
图状结构： 数据元素之间是多对多的关系
2. 存储结构 顺序存储
顺序存储： 把逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系靠存储单元的邻接关系体现
非顺序存储
链式存储： 逻辑上相邻的元素在物理位置上可以不相邻，借助元素存储地址的指针来表示元素之间的逻辑关系
索引存储： 在存储元素信息的同时，还建立附加的索引表。索引表中每项称为索引项，索引项一般为（关键字，地址）
散列存储： 根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储
顺序存储便于查找，非顺序查找便于增删
3. 数据的运算 3. 概念 1.2.1 算法的基本概念 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2855078c2e3647f1605982a9ce98ccb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2606df1c2fd801e5b47327ca41bf41ab/" rel="bookmark">
			同源政策（same-origin policy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 浏览器同源政策（Same-origin policy） 是浏览器安全的基石。它是前端开发人员必须要理解的一个知识点，也是后面各种实现跨域资源访问方式学习的基础。在接触这方面的知识时个人思考很多，在此记录一下。只能看作是个人的当前理解，并不代表一定准确，如果有误，希望指出。
1. 同源的定义 学习同源政策之前我们先明确一下同源的概念。在浏览器中，如果两个页面（请求）拥有相同的协议、域名和端口，那么这两个页面就属于同一个源（origin）。其中只要有其中一个不相同，就是不同源。例如网址 http://www.tkop.com/dirname/home 与下列各网址的同源关系分析如下。
http://www.tkop.com/dirname3/admin （同源）http://www.yangchen.com/dirname/home （不同源，域名不相同）http://v1.www.tkop.com/dirname/home （不同源，域名不相同）http://www.tkop.com:81/dirname/home （不同源，端口号不相同）https://www.tkop.com/dirname/home （不同源，通信协议不同） 2. 同源政策对 ajax 请求的限制 同源政策由 Netscape 公司于 1995 年提出，其目的是为了保证用户信息的安全，防止恶意网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie 在 B 网站（非同源页面）不能访问。
但是随着互联网的发展，同源政策也越来越严格（限制越来越多）。其中还规定了在不同源的情况下，无法向非同源地址发送 ajax 请求（ajax 请求限制），如果发请求，浏览器就会报错。通俗地讲就是 ajax 只能向自己地服务器发送请求。例如现有 A、B 两网站（服务器），A 网站中的页面只能向 A 服务器发送 ajax 请求，B 网站中的页面只能向 B 服务器发送 ajax 请求。但是浏览器是不允许 A 网站中的页面向 B 服务器发送 ajax 请求的（其实是允许的，不过拒绝接受处理响应），同理，也不允许 B 网站中的页面向 A 服务器发送 ajax 请求。 以上都是理论，下面我演示一下同源政策的 ajax 限制。
1、首先服务器端创建两个监听不同端口的服务。注意 A 监听 3000 端口，B 监听 3001 端口，两个服务不同源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2606df1c2fd801e5b47327ca41bf41ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3884eef0f7b2a27b84aaf96ca0e7839f/" rel="bookmark">
			17.Flink开发笔记二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink开发笔记二 1. WindowFunction2. Watermark2.1. 分布式的Watermark2.2. DataStream和其他流之间的转换2.3. Window的抽象概念2.4. Window Trigger2.5. Window Evictor2.6. 1.11版本Watermark写法 3. State 状态管理3.1. 算子状态（operator state）3.2. 键控状态（keyed state）3.3. 状态编程 4. ProcessFunction API（底层 API）4.1. 如果传感器 10秒内连续上升，则需要报警 5. 侧输出流6. Flink的容错机制6.1. 一致性检查点6.2. 检查点的实现算法6.3. 检查点和重启策略配置6.4. 保存点6.5. 端到端一致性 7. AsyncFunction 1. WindowFunction 2. Watermark 2.1. 分布式的Watermark 2.2. DataStream和其他流之间的转换 2.3. Window的抽象概念 2.4. Window Trigger 2.5. Window Evictor 2.6. 1.11版本Watermark写法 val dataStream: DataStream[LoginEvent] = inputStream .map { data =&gt; { val arr: Array[String] = data.split(",") LoginEvent(arr(0).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3884eef0f7b2a27b84aaf96ca0e7839f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ae8fadda681df04a7f87dc2dcbad99/" rel="bookmark">
			整数二分 如何确定mid及划分条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
目录
前言
一、mid是什么？
二、mid的两种取值方式
1.mid= (l+r) / 2
2.mid= (l+r+1) / 2
三、为什么会有这两种区分？以及对应的查找方式是什么？
总结
前言 本文主要讲解整数二分mid如何取值
一、mid是什么？ mid是middle的简写
二、mid的两种取值方式 1.mid= (l+r) / 2 2.mid= (l+r+1) / 2 三、为什么会有这两种区分？以及对应的查找方式是什么？ 首先讲解一下为什么会有第二种，也就是+1的选项。我们知道在c++中，如果对一个int型变量赋值小数，他只会保留不大于这个小数的最大整数值，比如int a = 2.99;最终a的值是2.
那么问题来了，如果我想要四舍五入怎么办？那就只能给原先的数+0.5，这样只要他达到四舍五入的标准，就可以自动进1，比如我们改成int a = x+0.5;当x=2.5时，他就会让a = 3;现在，
你是不是对为什么+1有点想法了？但是你会疑惑为什么是+1呢？因为后面是/2，1/2=0.5对不对？恍然大悟哈哈！
那么随之而来的问题出现了，我们既然是要找对应的区间，如果采取第一种方式，
总结 提示：这里对文章进行总结：
例如：以上就是今天要讲的内容，本文仅仅简单介绍了pandas的使用，而pandas提供了大量能使我们快速便捷地处理数据的函数和方法。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/185/">«</a>
	<span class="pagination__item pagination__item--current">186/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/187/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>