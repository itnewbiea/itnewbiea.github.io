<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d7fc6342cea7a52683b32e04458f9b/" rel="bookmark">
			【MySql】多版本并发控制MVCC前置知识——隐藏字段、undo日志与Read View
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3个记录隐藏列字段undo日志模拟 MVCCRead View 数据库并发的场景有三种： 读-读 ：不存在任何问题，也不需要并发控制
读-写 ：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
写-写 ：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
一个数据库大部分情况下是读写并发。
多版本并发控制（ MVCC ）是一种用来解决读-写冲突的无锁并发控制
1.每个事务都要有自己的事务ID，可以根据事务ID的大小，来决定事务到来的先后顺序
2.mysqld可能会面临处理多个事务的情况，事务也有之间的生命周期，mysqld要对多个事务进行管理，先描述，在组织，在事务看来，mysqld中一定是对应的一个或者一套结构体对象/类对象。事务也要有自己的结构体。
理解 MVCC 需要知道三个前提知识： 3个记录隐藏字段、undo 日志、Read View
3个记录隐藏列字段 建表时虽然指明了表中有多少列，但是mysql都会默认添加3个隐藏列字段。
DB_TRX_ID ：6 byte，最近修改( 修改/插入 )事务ID，记录创建这条记录/最后一次修改该记录的事务ID
DB_ROLL_PTR : 7 byte，回滚指针，指向这条记录的上一个版本（简单理解成，指向历史版本就行，这些数据一般在 undo log 中）
DB_ROW_ID : 6 byte，隐含的自增ID（隐藏主键），如果数据表没有主键， InnoDB 会自动以DB_ROW_ID 产生一个聚簇索引
补充：实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了
mysql&gt; create table student( -&gt; name varchar(11) not null, -&gt; age int not null -&gt; ); Query OK, 0 rows affected (0.20 sec) mysql&gt; insert into student (name, age) values ('张三', 28); Query OK, 1 row affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d7fc6342cea7a52683b32e04458f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e3f35f759ca6c91dea4335e56c1e17/" rel="bookmark">
			如何在kaggle上下载输出文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出的文件没有下载的选项，怎么办
那就把output打包成压缩包，就会出现下载选项
import os import zipfile import datetime def file2zip(packagePath, zipPath): ''' :param packagePath: 文件夹路径 :param zipPath: 压缩包路径 :return: ''' zip = zipfile.ZipFile(zipPath, 'w', zipfile.ZIP_DEFLATED) for path, dirNames, fileNames in os.walk(packagePath): fpath = path.replace(packagePath, '') for name in fileNames: fullName = os.path.join(path, name) name = fpath + '\\' + name zip.write(fullName, name) zip.close() if __name__ == "__main__": # 文件夹路径 packagePath = '/kaggle/working/' zipPath = '/kaggle/working/output.zip' if os.path.exists(zipPath): os.remove(zipPath) file2zip(packagePath, zipPath) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17e3f35f759ca6c91dea4335e56c1e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869108d2ceefc5a3bd9b81633a5a6a4d/" rel="bookmark">
			【Spring Boot学习】怎么配置文件，配置文件有什么用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
💞💞今天我们依然是学习Spring Boot，这里我们会更加了解Spring Boot的知识，知道Spring Boot的配置文件是什么样子的。有什么用？怎么使用Spring Boot的配置文件。
💞💞路漫漫，希望大家坚持下去，不忘初心，成为一名优秀的程序员
个人主页⭐： 书生♡
gitee主页🙋‍♂：奋斗的小白
专栏主页💞：JavaEE进阶专栏
博客领域💥：java编程前端，算法，强训题目
写作风格💞：超前知识点，干货，思路讲解，通俗易懂
支持博主💖：关注⭐，点赞、收藏⭐、留言💬
目录 1.配置文件1.1什么是配置文件1.2 配置文件的作用1.3 配置文件的格式 2.properties文件2.1 properties文件的格式2.2 properties文件的读取2.2 properties文件的缺点 3.yml 配置⽂件3.1 yml文件的格式3.2 yml文件的优缺点3.3 读取yml文件的对象3.4 yml文件配置不同的类型 4.properties VS yml5.设置不同环境的配置⽂件 1.配置文件 1.1什么是配置文件 配置文件本质上是包含成功操作程序所需信息的文件，这些信息以特定方式构成。是用户可配置的，通常存储在纯文本文件中
配置文件可以是各种格式，完全凭借程序员的发挥，不过出于方便，大部分会选择的配置文件格式集中在那几种.一般而言程序启动时，会加载该程序对应的配置文件内的信息
1.2 配置文件的作用 在我们所编写的项目中，所有的重要数据都是在配置文件中配置的，因此配置文件是非常重要的。
有这么几点作用：
1.数据库的连接工作
2.端口号的配置
3.打印日志等等
我们的后端程序都是要连接数据库的，所以没有配置信息你就不能连接数据库，甚至不能排查日志问题。
1.3 配置文件的格式 Spring Boot 配置⽂件主要分为以下两种格式：
.properties
.yml
properties 类型的配置⽂件就属于⽼款，也是创建 Spring Boot 项⽬时默认的⽂件格式，⽽ yml 属于新版，如果⽤户了解情况直接指定要新款，那么就直接发给他。
注意：
理论上讲 properties 可以和 yml ⼀起存在于⼀个项⽬当中，当 properties 和 yml ⼀起存在⼀个项⽬中时，如果配置⽂件中出现了同样的配置，⽐如 properties 和 yml 中都配置“server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869108d2ceefc5a3bd9b81633a5a6a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4be2caa8b9194c48ae8994868780f8/" rel="bookmark">
			C&#43;&#43; 笔记 23 （STL常用算法 - 算术生成 &amp; 集合）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五. STL-常用算法 5. 常用算术生成算法 算术生成算法属于小型算法，使用时包含的头文件为 :
#include &lt; numeric &gt;
accumulate //计算容器元素累计总和 fill //向容器中添加元素 5.1 accumulate 功能：计算区间内容器元素累计总和
原型：
accumulate(iterator beg ,iterator end ,value); //其中value是起始值 int total = accumlate (v.begin(),v.end(),0); 总结：accumulate 使用时头文件是numeric，这个算法很使用
5.2 fill 功能：向容器中填充指定的元素
原型：
fill (iterator beg , iterator end , value); //其中value是填充的值 fill(v.begin(), v.end(),100); 总结：利用fill可以将容器区间内元素填充为指定的值
6. 常用集合算法 set_intersection //求两个容器的交集 set_union //求两个容器的并集 set_difference //求两个容器的差集 6.1 set_intersection 功能：求两个容器的交集
原型：
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); //两个集合必须是有序序列，其中iterator dest是目标容器开始迭代器 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a4be2caa8b9194c48ae8994868780f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cc1f400555025a9317d9fb1344f261/" rel="bookmark">
			C&#43;&#43; 笔记 22 （STL常用算法 - 排序 &amp; 拷贝 &amp; 替换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五. STL-常用算法 3. 常用排序算法 sort //对容器内元素进行排序 random_shuffle //洗牌，指定范围内的元素随机调整次序 merge //容器元素合并，并储存到另一容器中 reverse //反转指定范围的元素 3.1 sort 功能：对容器内元素进行排序
原型：
sort(iterator beg, iterator end, _Pred); 示例：
//sort默认从小到大排序 sort(v.begin(),v.end()); //从大到小排序 sort(v.begin(),v.end(),greater&lt;int&gt;()); 总结：sort属于开发中常用的算法之一，需熟练掌握
3.2 random_shuffle 功能：洗牌，指定范围内的元素随机调整次序
原型：
random_shuffle(iterator beg, iterator end); srand((unsigned int)time(NULL)); random_shuffle(v.begin(),v.end()); 总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子
3.3 merge 功能：两个容器元素合并，并存储到另一容器中
原型：
merge(iterator beg1, iterator end1,iterator beg2, iterator end2, iterator dest) //注意，两个容器必须是有序的 示例：
//目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并，需要两个有序序列 merge(v1.begin(),v1.end(),v2.begin(),v2.end(),vtarget.begin()); 总结：merge合并的两个容器必须是有序序列
3.4 reverse 功能：将容器内元素进行反转
原型：
reverse(iterator beg, iterator end); //反转指定范围元素 reverse(v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cc1f400555025a9317d9fb1344f261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c46f42000fbe7d7fb99337252944fe69/" rel="bookmark">
			基于大数据的智能消防可视化平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 0 前言
Hi，大家好，今天给大家介绍一个大数据可视化项目，大家可以用于自己的课设或毕设，可以灵活耦合任意数据，为自己的项目添加灵活的可视化动态效果！
今天要分享的是：基于大数据的智能消防可视化平台
包含内容：
完整可视化实现源码html一键入口(双击直接启动) 项目获取：https://gitee.com/sinonfin/system-sharing
1 介绍 大数据大屏可视化系列：基于大数据的智能消防可视化平台
可搭载任意自己想用的数据，动态效果不错
2 实现效果 整体实现效果如下，可以看到CSS优化相对漂亮的，而且动态效果也很好，适合搭载各种数据。
3 部分代码展示 &lt;body&gt; &lt;div class="main" id="appIndex"&gt; &lt;div class="header"&gt; &lt;img style="width: 80px;height: 84px;margin-right: 20px;" src="img/logo.png" /&gt; &lt;img src="img/lzxfdsjpt.png" alt="智慧消防大数据平台" /&gt; &lt;div class="dateBox"&gt; &lt;span id="time"&gt;{{ year }}-{{ month }}-{{ date }}&amp;nbsp;&amp;nbsp; {{ hour }}:{{ minute }}:{{ second }}&amp;nbsp;&amp;nbsp; {{ strDate }} &lt;!-- &lt;img style=" width: 25px; height: 16px; margin: 0 5px 0 10px; " :src="weather_icon" alt="天气" /&gt; {{ weather_curr }}&lt;/span &gt; --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c46f42000fbe7d7fb99337252944fe69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/126e8206d3489bc3e51459a126915fa0/" rel="bookmark">
			耗时一个月！手撸博客系统，主打美观实用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先附上博客链接RoCBlog 关于博客 关于博客
RoCBlog
完成耗时：20天
起初是想搭建自己的博客，看了网上许多开源框架，感觉没啥意思，于是决定自己写一套
纯手撸Vue+Springboot
其实是个我一边学vue一边写出来的东西，前期因为对vue的理解不足，边查边写，写起来有点痛苦🤮，但写了两三天基本就熟悉了vue的基本写法，后面就呼哧呼哧写，写到一半发现底层架构有点问题，又重新改底层🤮。
自从改了底层，后面写着就快多了。
大部分时间在纠结前端怎么写好看（励志做后端工程师，却对前端十分执着）
写的过程中遇到的问题不计其数，头都大了，但最终还算是完成了，有价值的问题会陆续写博客发到网站里。
博客托管于腾讯云轻量云服务器🚀，水管小，有点慢别介意🤕
至此，本站用于记录以后值得记录的东西🌍
最重要的事！ 欢迎交换友链~😊 昵称：RoChes一句话： 扯一下灰色的帘个人网站：http://www.rocblog.cn头像url：https://img1.imgtp.com/2023/06/04/UxihXpEC.jpg背景图url：https://img1.imgtp.com/2023/06/04/roRlMRkk.jpg 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb5b34354dfdb819727c18dd5f979d2/" rel="bookmark">
			SpringBoot 使用minio实现异步分片上传、秒传、续传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Spring Boot和MinIO实现异步分片上传、秒传和续传的示例代码。
首先，确保您的Spring Boot项目已正确配置和集成了MinIO SDK。然后，您可以按照以下步骤实现所需功能：
异步分片上传： import io.minio.MinioClient; import io.minio.ObjectWriteResponse; import io.minio.PutObjectOptions; import io.minio.errors.MinioException; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; @Component public class MinioUploader { private final MinioClient minioClient; private static final String BUCKET_NAME = "your-bucket-name"; public MinioUploader(MinioClient minioClient) { this.minioClient = minioClient; } @Async public void uploadFileAsync(MultipartFile file, String objectName) { try { PutObjectOptions options = new PutObjectOptions(file.getSize(), -1); options.setContentType(file.getContentType()); ObjectWriteResponse response = minioClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eb5b34354dfdb819727c18dd5f979d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275096ed9d11e2c121c4766814dff648/" rel="bookmark">
			在x86_64平台上搭建龙芯MIPS64交叉编译环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在x86_64平台上搭建龙芯MIPS64交叉编译环境 下载龙芯交叉编译器 下载地址
搭建交叉编译示例环境 系统：deepin15.11
系统用户：dev
交叉编译器：gcc-4.4.7-7215-n64-loongson.tar.gz
步骤 #创建GCC安装目录 mkdir ~/App #解压安装包到GCC安装目录 tar xf gcc-4.4.7-7215-n64-loongson.tar.gz -C ~/App # 配置环境变量 echo "" &gt;&gt; ~/.bashrc # 当安装有多个交叉编译器时，则不能将CROSS_COMPILE配置到环境变量中，需要每次编译前设置CROSS_COMPILE环境变量 # export CROSS_COMPILE=mips64el-redhat-linux- echo "export PATH=~/App/gcc-4.4.7-7215-n64-loongson/usr/bin:\$PATH" &gt;&gt; ~/.bashrc # 立即生效环境变量 source ~/.bashrc 编译说明 LD_LIBRARY_PATH环境变量配置 在执行交叉编译代码时，需要使用交叉编译器提供的动态链接库，确保下面的语句在当前终端已经执行，否则报执行代码中的configure、Configure、config等命令时会报checking whether the C compiler works... no。
export LD_LIBRARY_PATH=~/App/gcc-4.4.7-7215-n64-loongson/usr/lib:~/App/gcc-4.4.7-7215-n64-loongson/usr/x86_64-unknown-linux-gnu/mips64el-redhat-linux/lib:$LD_LIBRARY_PATH CROSS_COMPILE环境变量配置 当安装有多个交叉编译器时，不能将CROSS_COMPILE配置到系统环境变量中，需要每次编译代码前设置CROSS_COMPILE临时环境变量
export CROSS_COMPILE=mips64el-redhat-linux- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50e2c81948666004ac11b8588e6495bb/" rel="bookmark">
			Linux下 文件删除但是空间未被释放 或者 磁盘已满但找不到对应的大文件 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下文件删除但是空间未被释放的解决方案 前言1. 查看当前磁盘占用情况2. 模拟进程占用3. 执行rm -rf 命令删除文件4. 查看被删除但是未释放空间的文件5. 执行清空文件操作 前言 linux磁盘空间已满，手动rm -rf 删除了大文件之后，df -h 查看一下发现空间占用还是不变，有时候会想rm -rf 删除只是逻辑删除到回收站一样？其实不然，通常这种情况都是文件被删除，但是还被进程占用，因此删除文件空间未释放
通常的建议是kill 掉对应的进程，但是如果是生成环境，不能轻易kill进程的话，可以通过置空文件的方式来释放空间
通过lsof | grep deleted 找到未能删除掉的文件，确定占用的进程号
通过 ls -l /proc/PID/fd/* | grep 文件名，找到相应文件句柄
清除文件内容 echo &gt; /proc/PID/fd/FD_NUM
此操作不会删除文件，而是将文档内容清空的方法释放空间，文件仍存在
1. 查看当前磁盘占用情况 首先查看磁盘占用，然后创建了一个5GB的文件，然后继续查看磁盘占用，可以看到磁盘可用已经减少了5GB
# 查看磁盘占用 df -h # 创建1个5000MB的文件 dd if=/dev/zero of=/delete.tmp bs=1000MB count=5 2. 模拟进程占用 这里使用tail -f 命令对文件进行占用
tail -f /delete.tmp 3. 执行rm -rf 命令删除文件 下图可以看到，由于文件被占用，执行删除命令成功后仍然没有释放空间
# 查看磁盘占用 df -h # 删除创建文件 rm -f /delete.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50e2c81948666004ac11b8588e6495bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880e943d4f12478cc2d4edc6d8a93f7c/" rel="bookmark">
			有效的rtsp流媒体测试地址汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是从网上搜集的一些有效的rtsp流媒体测试地址：
1. rtsp://218.204.223.237:554/live/1/0547424F573B085C/gsfp90ef4k0a6iap.sdp
2. rtsp://218.204.223.237:554/live/1/66251FC11353191F/e7ooqwcfbqjoo80j.sdp
3. rtsp://211.139.194.251:554/live/2/13E6330A31193128/5iLd2iNl5nQ2s8r8.sdp
4. rtsp://218.204.223.237:554/live/1/67A7572844E51A64/f68g2mj7wjua3la7.sdp
5. rtsp://46.249.213.87:554/playlists/brit-asia_hvga.hpl.3gp
6. rtsp://46.249.213.87:554/playlists/ftv_hvga.hpl.3gp
7. rtsp://217.146.95.166:554/live/ch11yqvga.3gp
8. rtsp://217.146.95.166:554/live/ch12bqvga.3gp
9. rtsp://217.146.95.166:554/live/ch14bqvga.3gp
2019年5月17日试了下上面给出的rtsp测试地址，发现已都无效，又在网上找了几个有效的，如下：
1. rtsp://184.72.239.149/vod/mp4://BigBuckBunny_175k.mov
2. rtsp://184.72.239.149/vod/mp4:BigBuckBunny_115k.mov
3. rtsp://wowzaec2demo.streamlock.net/vod/mp4:BigBuckBunny_115k.mov
2022年11月11日试了下上面给出的rtsp测试地址，发现已无效，又在网上找了几个有效的，如下：
1. rtsp://wowzaec2demo.streamlock.net/vod/mp4:BigBuckBunny_115k.mp4
2. rtsp://rtsp.stream/pattern
2023年6月22日试了下上面给出的rtsp测试地址，发现已无效，可通过以下方式获取测试地址：
(1).打开 https://rtsp.stream/ ；
(2).拉取到最后，点击Free下的"Get started"填写邮箱；
(3).打开邮箱，打开指定的链接后，会给出2个免费的有效地址，每月有2G流量可免费使用。
可通过VLC播放器直接打开播放，操作步骤：
打开VLC播放器，然后点击"媒体", 打开网络串流，点击"网络"，最后在url中输入上面的rtsp地址即可。
为了测试，也可以通过VLC播放器自己搭建一个rtsp流媒体测试地址，可参考：Windows上通过VLC播放器搭建rtsp流媒体测试地址操作步骤_fengbingchun的博客-CSDN博客_window安装vlc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7badcf638d8d6c5beb276920b396b05a/" rel="bookmark">
			微信小程序与uniapp面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简单描述下微信小程序的相关文件类型?
简述微信小程序原理?
小程序页面间有哪些传递数据的方法？
小程序的wxss和css又哪些不一样的地方？
小程序的双向绑定和Vue哪里不一样？
vue , 微信小程序 , uni-app属性的绑定
vue , 微信小程序 , uni-app的页面生命周期函数
vue、小程序、uni-app中的本地数据存储和接收
暂时先这样，后面在补充！！！
1、简单描述下微信小程序的相关文件类型? WXML是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面结。内部主要是微信自己定义的一套组件。
WXSS是一套样式语言，用于描述WXML的组件样式 js逻辑处理，网络请求 json小程序设置，如页面注册，标题及tarBar。
主要文件
app.json：必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。
app.js：必须要有这个文件，没有也是会报错！但是这个文件创建一下就行，什么都不需要写，以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 app.wxss：可选
参考：小程序的开发文档
2、简述微信小程序原理? 1）微信小程序采用JavaScript、WXML、WXSS三种技术进行开发，本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口
2）微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现
3）小程序分为两个部分，webview和appService。其中，webview主要用来展现UI，appService用来处理业务逻辑、数据及接口调用。它们在连个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理
3、小程序页面间有哪些传递数据的方法？ 1）使用全局变量 全局变量实际上是定义了一个全局对象，并在每个页面中引入； 在初始化代码的时候，小程序会读取app.js的文件，在这里我们可以定义我们所需要的全局变量； 然后在页面中，可以通过getApp()方法获取到全局应用对象，可以对全局变量进行读取并更改； 由于app.js在项目中是用来做基础配置的，因此不建议将很多变量放在这里配置。一般情况下会将一些持久化的常量配置在这里，对于经常需要变动的量不建议使用这个方法。
2）使用本地缓存 本地缓存是微信小程序提供的一个功能，可以将用户产生的数据做本地的持久化，类似于NoSQL，可以读取和修改的操作。 那么在不同的页面之间，如何利用它，进行数据的交互呢？ 假设我们在A页面保存了用户信息。 这样做，这个数据就存在了本地。挡在B页面需要使用的时候，可以直接获取到数据池中的数据，并进行增删改查操作 需要注意的是，在回到A页面的时候，小程序需要重新读取数据。这时候，可以选择放在生命周期的onShow中对数据重新加载
3）父级往子级页面的数据传递 我们通常会在页面之间进行跳转、重定向的操作。这时候，我们可以选择将部分数据放在url里面，并在新页面的时候进行初始化
4、小程序的wxss和css又哪些不一样的地方？ WXSS和CSS类似，不过在css的基础上做了一些补充和修改
1)尺寸单位：rpx rpx是响应式像素，可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在iphone6上，屏幕宽度为375rpx，共有750的物理像素，则750rpx=375rpx=750rpx物理像素
2)样式导入：@import 标签来导入外联样式。@import后跟需要导入的外联样式表的相对路径，用;表示语句结束
5、小程序的双向绑定和Vue哪里不一样？ 小程序直接this.data的属性是不可以同步到视图中对中，必须调用。
通过绑定事件，--传值--this.setData({// 设置数据})
6、vue , 微信小程序 , uni-app属性的绑定 vue和uni-app动态绑定一个变量的值为元素的某个属性的时候，会在属性前面加上冒号":";
小程序绑定某个变量的值为元素属性时，会用两个大括号{{}}括起来，如果不加括号，为被认为是字符串。
7、vue , 微信小程序 , uni-app的页面生命周期函数 vue：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7badcf638d8d6c5beb276920b396b05a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b7f5ad8390fc4b8385ed8cb8879a366/" rel="bookmark">
			2023前端面试题总结（html，css，js）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML篇 1、HTML5常用的语义化标签有哪些？并写出你对语义化的理解？ &lt;header&gt;&lt;/header&gt; // 头部 &lt;nav&gt;&lt;/nav&gt; // 导航条 &lt;article&gt; // 主要内容 &lt;section&gt;&lt;/section&gt; 区块 &lt;/article&gt; // 主要内容、文章、帖子、博客等 &lt;aside&gt;&lt;/aside&gt; // 侧边栏 &lt;footer&gt;&lt;/footer&gt; // 页脚 语义化的理解：
正确的标签干正确的事
让页面结构化，结构更清晰，便于对浏览器、搜索引擎解析
有利于SEO
方便其他设备解析执行，例如盲人阅读器
便于团队开发与维护
2、列举HTML的block元素和inline元素 &lt;body&gt; // 块级元素： div、h1~h6、p、ol、ul、li、dl、dt、dd、table、tr、td、form、footer、 nav、header、aside、section、article等 // 行内元素： span、a、img、b、i、u、del、sup、em、strong、video、input、button、textarea、 label、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; // 内联块状元素： &lt;img&gt;、&lt;input&gt; // 空元素： br hr img input link meta 鲜见的有：area base col colgroup param &lt;/body&gt; 3、块元素和行内元素的区别？ 1、块级元素:块级元素独占一行，默认宽度为100%
2、行内元素:行内元素在同一行显示，默认宽度由内容撑开
3、块级元素可以设置宽高，行内元素设置宽高不生效
4、行内元素width 和 height 属性将不起作用.
5、块级元素可以设置margin和padding的四周，行内元素只能设置margin和padding的左右 6、块级元素默认display为block，行内元素默认display为inline
7、布局时，块级元素可以包含块级元素和行内元素，行内元素一般不要包含块级元素
4、 iframe 是什么？有什么缺点？ 行内框架，在网页中可以嵌入另外一个网页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b7f5ad8390fc4b8385ed8cb8879a366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed68d94db4fc44dd30c8a55126976c2/" rel="bookmark">
			软件工程用例图画法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 用例图是一种用于描述系统功能和用户行为的UML（统一建模语言）图表。
绘制步骤 1.确定参与者（Actors）：首先要确定系统与外部实体之间的交互参与者如用户、外部系统或设备等。这些参与者是系统的用户或外部实体，与系统进行交互并对系统执行某些用例。
2.确定用例（Use Cases）：用例是描述系统功能或行为的情景或场景。识别主要的用例，即系统中最重要和关键的功能或任务。每个用例应该表示一个用户或参与者与系统之间的特定目标或功能。
3.绘制参与者和用例：使用UML建模工具或画图工具，绘制用例图的主要框架。将参与者表示为位于图的左侧或顶部的小人图标，用椭圆表示用例，用线将它们连接起来。
4.添加关系：确定参与者和用例之间的关系。
5.添加注释和细节：根据需要，可以为参与者和用例添加注释和描述。这些注释和描述可以提供更详细的说明，帮助读者理解用例图的含义和功能。
6.完善用例图：进一步完善用例图，包括调整参与者和用例的位置和布局，添加连线、箭头和标签以显示关系，确保用例图的清晰易读。
常用关系 关联（Association）：关联关系用来表示参与者（Actor）和用例（Use Case）之间的关联。在用例图中，可以使用直线连接参与者和用例，可以为关联线添加角色名称或其他关联信息。
包含（Include）：包含关系用于表示一个用例（基础用例）包含另一个用例（包含用例）的功能。包含用例是在基础用例中执行的子功能。在用例图中，可以使用带有虚线箭头的包含关系线连接基础用例和包含用例，箭头指向包含用例。
扩展（Extend）：扩展关系用于表示一个用例（扩展用例）可以扩展另一个用例（基础用例）的功能。扩展用例提供了在基础用例中可选的、可扩展的行为。在用例图中，可以使用带有虚线箭头的扩展关系线连接基础用例和扩展用例，箭头指向基础用例。
泛化（Generalization）：泛化关系用于表示用例之间的继承关系。一个用例（子用例）可以继承另一个用例（基础用例）的行为和属性。在用例图中，可以使用带有空心三角形的实线箭头表示泛化关系，箭头指向基础用例。
调用（invokes）：表示一个用例或组件调用另一个用例或组件来完成特定的功能或行为。这种关系通常用于描述不同用例或组件之间的函数或方法调用。“invokes” 关系用箭头表示，箭头指向被调用的用例或组件。
实现（realizes）：表示一个用例实现了另一个用例的功能或行为。这种关系通常用于表示一个更高层次的抽象用例（父用例）被一个或多个具体用例（子用例）实现。“realizes” 关系用带空心三角形的实线箭头表示，箭头指向被实现的用例。
前置（proceeds）：表示一个用例在另一个用例之前执行或发生。这种关系用于描述用例之间的顺序关系，其中一个用例必须在另一个用例之前完成。“proceeds” 关系用实线箭头表示，箭头指向前置的用例。
建议 绘制用例图时，可以使用各种UML工具（如Visio、Enterprise Architect、StarUML等）或在线绘图工具。此外，参考UML的语法和规范，保持用例图的一致性和规范性，以确保其有效地传达系统功能和用户行为。
提示 边界别忘了画
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dede6350adc96cb0f517cbee4f790bc3/" rel="bookmark">
			Windows Terminal配置2023.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重装系统 成品效果图 配置PowerShell步骤 PowerShell + oh-my-posh + posh-git+PSReadLine 应用商店Micorsoft Store 更新Windows Terminal（因为Win11 自带的可能不是最新的，功能不全）
在商店Micorsoft Store 顺便下载PowerShell
Windows PowerShell 5.1 是在 .NET Framework v4.5 基础上构建的，PowerShell 成为基于 .NET Core 2.0 构建的开源项目，成为可跨平台的解决方案。 PowerShell 在 Windows、macOS 和 Linux 上运行
安装美化插件OhMyPosh
方式一：通过Micorsoft Store 应用商店下载(PS：这种方式简单，但有时无法安装成功）方式二：通过PowerShell 执行命令 winget install JanDeDobbeleer.OhMyPosh -s winget（不要再使用以前教程中的Install-Module命令来安装了，官网中已经没有这种安装方法了）方式三：如果上述两种方式都无法安装，则通过第三种方式，下载软件包直接安装:
Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('&lt;https://ohmyposh.dev/install.ps1&gt;')) 创建配置文件
if (!(Test-Path -Path `$PROFILE )) { New-Item -Type File -Path $PROFILE -Force } 执行 notepad $PROFILE打开文件，并在文件内写入oh-my-posh init pwsh | Invoke-ExpressionGet-PoshThemes获取主题修改主题oh-my-posh init pwsh --config 'C:\Users\{xxxxxx}\AppData\Local\Programs\oh-my-posh\themes\paradox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dede6350adc96cb0f517cbee4f790bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edc07f93f9066052f453537f6afa4e93/" rel="bookmark">
			小样本学习(Few-Shot Learning)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 本文讲解小样本学习(Few-Shot Learning)基本概念及基本思路，孪生网络（Siamese Network）基本原理及训练方法。
小样本学习(Few-Shot Learning)（二）讲解小样本学习问题的Pretraining+Fine Tuning解法。
小样本学习(Few-Shot Learning)（三）使用飞桨（PaddlePaddle）基于paddle.vision.datasets.Flowers数据集实践小样本学习问题的Pretraining+Fine Tuning解法。
本文搬运自我的CSDN博客，更多机器学习及深度学习文章请关注：DeepGeGe
2. 小样本学习 1997年5月2日，小敏生日，在动物园游玩。小敏走进极地馆，发现了图一所示毛茸茸的可爱小动物，她非常喜欢，但是小敏之前没有见过，不知道它的名字。小敏拿出入园时领取的动物学识卡，逐一翻阅卡片，确定图一中的小动物是狐狸。
小敏去动物园游玩之前没有见过狐狸，因此不可能认识图一中的小动物，但是她只需要看一下动物学识卡，就能学会辨认图一中小动物是狐狸。小敏可以做到，那么计算机是否也可以做到？
或者说，如果训练集中每一类只有一两个样本，计算机能否做出像小敏一样正确的分类呢？
2.1. 基本概念 2.1.1 元学习（Meta Learning） 元学习的解释为学会学习（Learning to learn）。“学会”是指训练模型直至收敛，“学习”是指学习的能力。“学会学习”是指通过训练机器学习模型，使得其具备学习的能力。
元学习是人工智能领域的一个重要研究分支，是一切尝试让机器具备学习能力的理论和工程方法的统称。小样本学习是元学习的一个子领域。
如何理解【学习的能力】？
上述例子中，小敏没有见过狐狸，她作出图一中小动物是狐狸这一判断的依据是图一中的小动物和入园时领取的动物学识卡中的狐狸长得非常像，即小敏能够判断动物之间的异同。这种能够判断事物之间异同的能力就是一种【学习的能力】。
【学习的能力】远不止判断事物之间的异同这一种，但是在小样本学习领域，主要方法之一是通过训练深度学习模型，使其具备这种判断事物之间异同的能力，从而解决小样本学习问题。
2.1.2 Support Set和Query 将上述小敏学会辨认狐狸的例子抽象成小样本学习问题，由于小敏在进动物园游玩前没有见过狐狸，因此小敏不可能认识狐狸。小敏要知道图一中小动物的名字，必须有入园时领取的动物学识卡提供额外信息。
在小样本学习中，动物学识卡这种数据集被称为Support Set，图一这种需要判断其类别的图片被成为Query。根据Support Set中类别数量和样本数量的不同，Support Set可被称为�k-way �n-shot Support Set。
�k-way：Support Set中存在�k个类别�n-shot：每个类别中存在�n个样本 在上述小敏学会辨认狐狸的例子中，小敏入园时领取的动物学识卡构成的Support Set中有狐狸、松鼠、兔子、仓鼠、水獭和海狸6种不同的小动物，因此�k等于6。每种小动物卡片只有一张，所有�n等于1。这个Support Set是6-way 1-shot Support Set。
小样本分类准确率会受到Support Set中类别数量和样本数量的影响，随着类别数量增加，分类准确率会降低。随着每个类别样本数增加，分类会更准确。
Support Set与训练集的区别：
训练集是一个非常大的数据集，每一类均包含非常多张图片。训练集足够大，可以用来训练一个深度神经网络。Support Set非常小，每一类只包含一张或几张图片，不足以训练一个深度神经网络。Support Set用于在预测时提供额外信息，使得模型能够断出所属类别不在训练集中的Query图片的类别。
2.1.3 传统机器学习与小样本学习的区别 传统监督学习首先会在一个训练集上训练模型，模型训练好之后可以用来做预测，给定一张测试图片，模型预测该图片类别。测试图片不在训练集中，但是其归属于训练集中的某一类。
小样本学习与传统监督学习有所不同，小样本学习的目标不是让机器识别训练集中的图片并且泛化到测试集，小样本学习的目标是让机器自己学会学习。用一个很大的数据集训练神经网络，学习的目的不是让模型知道什么是狐狸什么是老鼠，从而能够识别没有见过的狐狸和老鼠。学习的目的是让模型理解事物的异同，学会区分不同的事物。给定两张图片，不是让模型识别两张图片是什么，而是让模型判断两张图片中的对象是否相同。
因为训练集中不包含测试样本及其类别，因此小样本学习比传统监督学习更难。
2.2 基本思路 在小样本学习问题中，Support Set中每一类往往只有少数几个样本，单单依靠这些样本，不可能训练出一个深度神经网络，甚至无法采用迁移学习中的Pretraining+Fine Tuning方法。即对于小样本学习问题，不能采用传统的监督学习方法来进行分类。
小样本学习的最基本想法是学习一个���sim函数来判断相似度。给定两张图片�x和�′x′，如果两张图片越相似，则���(�,�′)sim(x,x′)的值越大。在理想情况下，若�x和�′x′属于同一类，则���(�,�′)=1sim(x,x′)=1，若�x和�′x′属于不同类，则���(�,�′)=0sim(x,x′)=0。
具体可以按照如下思路解决小样本学习问题：
在一个大数据集中学习一个判断两张图片相似程度的相似度函数；给定一个Query图片，将其和Support Set中各图片逐一对比，计算相似度；在Support Set中找到与Queryt图片相似度最高的图片，将其类别作为预测结果。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edc07f93f9066052f453537f6afa4e93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c2fdf5e8c7a3f1fd9080c41c112d3c/" rel="bookmark">
			利用ADV和Mixamo快速绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）我们准备一个需要绑定的模型，记得要清理历史记录，打成组。
2）我们可以利用AVD目录栏里Model Clear对模型进行一个整理，清除一些历史记录。点击Model Clear后，先按Create，再点击Clean。
3）然后我们就可以把我们的模型（要导FBX格式）导出到mixamo网站（www.mixamo.com），进行一个自动的蒙皮绑定。网站要注册一下才能用哈。
这是它网站的界面，我们点左上方的Characters，然后再右边一栏里点UPLOAD CHARACTER。
4）会出来一个这样的框。我们把我们需要导入模型，直接拖到下方的虚线框里面，然后会进入加载界面。导入的速度跟文件的大小和网络有关，会魔法，上网的可以试试会快点。
5）导入完成了之后，我们点击NEXT。 6）然后左边出现带不同颜色圆环的界面，我们对着右边的示意图，分别把圆环放到我们的模型它相对应的位置上去。完成后点击右下角的NEXT。它会自动帮你蒙皮绑定，这需要一段时间，等它运算完成。 7）接上面的步骤完成后我们接着点NEXT。然后会看到下面的界面，我们的角色会出现在它们的网格界面里。再点击右边的DOWNL OAD。 8）这里会弹出导出的设置框，因为我们角色导入的时候不是一个T-pose的姿势，所以我们在Pose的选项里选择Oringinal Pose。再点击DOWNL OAD。它就会开始下载啦。 9）我们把下载好的文件导入Maya。现在这个模型是带骨骼和蒙皮的。但是它不能做动画，因为没有IK没有FK，也没有控制器。所以我们现在用ADV给它完成最终的绑定。这个时候我们可以检查一下这个模型，以防到时候出现各种错误。有一个好办法就是把它目前的骨骼整体删掉，如果模型出现位移，坐标轴变化，或者模型形变。那么就说明模型有错误，正常情况是删掉模型会保持不变。如果有错误我们就要返回之前的步骤，看看哪里出了问题。
10）接上面的步骤，检查完问题后，我们打开ADV插件。在Tools栏里点击NameMatcher。然后会弹出NameMatcher的窗口。在files栏里选择Mixamo（因为我们是Mixamo网站导出的模型）。然后任意选择一个骨骼，点击下方的detect from selected。它会自动识别是Mixamo导入的骨骼。 11）完成上面的步骤后再点击下方的创建Place FitSkeletor，创建完成了我们再点Build AdvancedSkeleton。 12）完成上面这步后，我们已经创建了控制器，但是这个控制器并不能控制我们的人物。我们现在要做的就是把之前mixamo导入的骨骼的信息转移到现在ADV创建的控制器中。我们点击NameMatcher窗口下面的Transfer SKinning选项。它就会完成绑定信息的转移，非常方便的完成了我们的绑定。 13）这里有些小伙伴到第11）有可能出现的问题就是，点了Place FitSkeletor后。上方的Joints选项会出现异常，一般就是我们从Mixamo导入的模型缺少眼睛的骨骼。我们要做的是按照我下面图片的路径找到mixamorig:HeadTop_End骨骼。然后按住复制两个骨骼，把这两个骨骼分别对应左眼球和右眼球。然后为了方便命名我们可以直接复制下面mixamorig:LeftShoulder和mixamorig:RightShoulder的命名，删掉后面的Shoulder改成Eye（大小写一致），并且要左（Left）右（Right）分别和它们对应。千万别弄反了。这样就不会出现这个异常啦。 14）这里再补充一点，这个ADV生成的两个膝盖的控制器，会比较开，正常情况下，我们还是朝着正前方会比较好做动画。这里我们要如何修改呢？ 15）我们选择ADV选项里的Body，再点Build，选择Toggle Fit。现在就回到了一开始一半骨骼的状态。
16）然后在Body选项里点击Edit，勾选pole-vector。会发现模型的关节处有红色的三角。
17）我们选择腿的骨骼，点W移动键，再按D键。让它朝向正前方。再点击Build项里的ReBuild。等它进度走完就完成调整啦。 希望以上内容会对大家有所帮助，一起学习进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1774b53a9dddff84a8390bf91dcc56b8/" rel="bookmark">
			微信小程序扫码打开H5页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在微信小程序中扫描二维码打开H5页面，你需要使用微信小程序的API接口wx.scanCode()。以下是示例代码：
1 . 在小程序页面中添加一个按钮，并绑定点击事件：
&lt;view class="btn" bindtap="scanCode"&gt;扫码打开H5页面&lt;/view&gt; 在小程序页面的js文件中编写scanCode()方法： scanCode: function () { wx.scanCode({ success: (res) =&gt; { //扫码成功后获取二维码中的链接地址 var result = res.result; //跳转到H5页面 wx.navigateTo({ url: '/pages/webview/webview?url=' + result, }) } }) } 在小程序中添加一个webview页面用于展示H5页面，代码如下： &lt;!-- pages/webview/webview.wxml --&gt; &lt;web-view src="{{url}}" bindmessage="onMessage"&gt;&lt;/web-view&gt; JS代码
// pages/webview/webview.js Page({ data: { url: '' }, onLoad: function (options) { var url = options.url; //将接受到的url传递到webview页面中显示 this.setData({ url: url }); }, onMessage: function (e) { console.log(e); } }) 以上代码实现了在微信小程序中扫描二维码打开H5页面，你可以根据自己的需求进行定制修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fe52ccf8d3bae9b2861c75eb7a5736/" rel="bookmark">
			使用mysql语句查询某个字段的数据长度大于、小于、等于某个数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用mysql的SELECT语句查询某个字段的数据长度大于、小于、等于某个数值 在 mysql 内有内置函数：length() 、char_length()；
这两个函数都是用来获取用来获取字符串长度的；
区别为：
length()： 单位是字节，utf8编码下,一个汉字三个字节，一个数字或字母一个字节。gbk编码下,一个汉字两个字节，一个数字或字母一个字节。
char_length()：用于返回字符串的长度，长度单位为字符，不管汉字,数字或是字母都算是一个字符，包括中英文标点符号，空格也算是一个字符
mysql具体使用语法为：
查询某个字段长度大于10的数据：
SELECT * FROM `表名` WHERE char_length(字段名)&gt;10 查询某个字段长度小于等于10的数据：
SELECT * FROM `表名` WHERE char_length(字段名)&lt;=10 查询某个字段长度等于10的数据：
SELECT * FROM `表名` WHERE char_length(字段名)=10 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9364e924fe3c6f36808d2e01c362bf/" rel="bookmark">
			npm ERR! missing script: build
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、执行命令：npm run build 时，提示：npm ERR! Missing script: “build”。如图1
PS E:\xxx\yeunho-power-frontend\src&gt; npm run build npm ERR! npm ERR! To see a list of scripts, run: npm ERR! npm run npm ERR! A complete log of this run can be found in: npm ERR! C:\Users\86166\AppData\Local\npm-cache\_logs\2023-06-21T06_15_35_572Z-debug-0.log 2、查看 package.json 文件，可以确认 scripts 中并未包含 build 脚本。如图2
所以正确的命令应该为:
npm run build:prod 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fcf2e5717f779dc8597e0b450da6747/" rel="bookmark">
			vue中出现报错Duplicate keys detected: ‘0‘. This may cause an update error. found in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 控制台报错
Duplicate keys detected: ‘0’. This may cause an update error. found in
是因为一个页面组件中for循环的key值重复
index避免重复命名即可
图中key值修改后同样会导致报错，这是因为v-for在循环时index值都是从0、1、2…的方式来增加，同时我们把index当成了key值。
在同一个父元素下有两个key值相同的for循环会导致相同的报错，建议是key值尽量避免使用index赋值，如果使用的话，可以添加后缀。如：
&lt;span class="ref-line v-line" v-for="(item, vindex) in vLine" :key="vindex" v-show="item.display" :style="{ left: item.position, top: item.origin, height: item.lineLength}" /&gt; &lt;span class="ref-line h-line" v-for="(item,index) in hLine" :key="index+'a'" v-show="item.display" :style="{ top: item.position, left: item.origin, width: item.lineLength}" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a4b004eec7f63b2cc0d5fdd6324dfd/" rel="bookmark">
			【误码率仿真】基于matlab模拟16QAM和16PSK调制误码率对比附GUI界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ⛄ 内容介绍 调制作为通信系统组成必不可缺的一部分,主要用于将基带信号进行一定的处理加到载波上,使其变为适合于信道传输的形式.传统的调制分为调幅,调频,调相3种方式,在数字通信系统中,采用16PSK调制和QAM调制较多,文章通过通信系统中常用的MATLAB仿真软件,选取16PSK调制和16QAM调制方式,通过对其星座图以及误码率进行对比仿真,得出两种调制方式的优缺点。
16PSK调制和16QAM调制是两种常用的调制技术，用于将数字数据转换为模拟信号以进行无线通信。
16PSK(16相位偏移键控)调制： 16PSK使用16个不同的相位来表示4比特的数据。每个相位之间的相位偏移为22.5度。由于相位的离散性，16PSK在信号传输的过程中相对较容易受到相位偏移、多径衰落等干扰的影响。 16QAM(16方振幅调制)调制： 16QAM使用16个不同的幅度和相位组合来表示4比特的数据。
信号空间包含4个幅度级别和4个相位级别。
16QAM在相同频带宽度下能够传输更高的比特速率，但也更容易受到噪声和信道失真的影响。
无论是16PSK还是16QAM，它们都具有一定的优势和适用性。16PSK可以提供较好的相位鲁棒性，适用于对相位变化较为敏感的应用。16AM则在相对较低的信噪比条件下能够提供较高的数据传输速率。
⛄ 运行结果 ⛄ 部分代码 function varargout = compare_psk_qam(varargin)
% COMPARE_PSK_QAM MATLAB code for compare_psk_qam.fig
% COMPARE_PSK_QAM, by itself, creates a new COMPARE_PSK_QAM or raises the existing
% singleton*.
%
% H = COMPARE_PSK_QAM returns the handle to a new COMPARE_PSK_QAM or the handle to
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a4b004eec7f63b2cc0d5fdd6324dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca8b4c5bfc2f7a71b2f2fc062ffa4fa/" rel="bookmark">
			Kali Linux 系统暴力破解压缩包密码工具总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Kali Linux 系统中，有多种工具可以用于暴力破解压缩包密码。下面将介绍几种常用的工具，包括 fcrackzip、zipcracker 和 John the Ripper。
1、fcrackzip
fcrackzip 是一款高效的 ZIP 文件密码破解工具。它可以使用多种破解模式来尝试解密 ZIP 文件密码，如字典攻击、暴力攻击等。
使用 fcrackzip 的命令格式如下：
fcrackzip -u -v -D -p PASSWORD_FILE ZIP_FILE 其中，-u 表示使用暴力攻击模式，-v 表示详细输出，-D 表示使用字典攻击模式，-p PASSWORD_FILE 表示指定密码字典文件，ZIP_FILE 表示要破解的 ZIP 文件。
2、zipcracker
zipcracker 是另一款 ZIP 文件密码破解工具，它也是使用暴力破解和字典攻击两种模式来猜测密码。
使用 zipcracker 的命令格式如下：
zipcracker -d PASSWORD_FILE -p PASSWORD_LEN ZIP_FILE 其中，-d 表示使用字典破解模式，-p PASSWORD_LEN 表示指定密码长度，PASSWORD_FILE 表示密码字典文件，ZIP_FILE 表示要破解的 ZIP 文件。
3、John the Ripper
John the Ripper 是一个功能强大的密码破解工具，它支持破解多种加密算法的密码，包括 ZIP 文件密码、Unix/Linux 系统密码等。
使用 John the Ripper 破解 ZIP 文件密码的命令格式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ca8b4c5bfc2f7a71b2f2fc062ffa4fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3320c79cd2ef8be3e26de9d49a2dbe6/" rel="bookmark">
			解决python无法识别中文或中文相关符号问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在代码开头加上转码标识
# -*- coding:utf-8 -*- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8838378a21d077785bd90638a1d634e/" rel="bookmark">
			Linux Powershell 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微软爱上 Linux 之后，PowerShell 这个原本只是 Windows 才能使用的组件，于 2016 年 8 月 18 日 开源并且成为跨平台软件：https://linux.cn/article-7699-1.html ，登陆了 Linux 和 macOS。 PowerShell 是一个微软开发的自动化任务和配置管理系统。它基于 .NET 框架，由命令行语言解释器（shell）和脚本语言组成。
PowerShell 提供对 COM (组件对象模型Component Object Model) 和 WMI (Windows 管理规范Windows Management Instrumentation) 的完全访问，从而允许系统管理员在本地或远程 Windows 系统中 执行管理任务，以及对 WS-Management 和 CIM（公共信息模型Common Information Model）的访问，实现对远程 Linux 系统和网络设备的管理。
通过这个框架，管理任务基本上由称为 cmdlets（发音 command-lets）的 .NET 类执行。就像 Linux 的 shell 脚本一样，用户可以通过按照一定的规则将一组 cmdlets 写入文件来制作脚本或可执行文件。这些脚本可以用作独立的命令行程序或工具。
在 Linux 系统中安装 PowerShell Core 6.0
要在 Linux 中安装 PowerShell Core 6.0，我们将会用到微软软件仓库，它允许我们通过最流行的 Linux 包管理器工具，如 apt-get、yum 等来安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8838378a21d077785bd90638a1d634e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17fdf6120ae8814a1c319033dffe258b/" rel="bookmark">
			PHP反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP反序列化 一：php面向对象基础知识 操作均在windows下进行
1.基本概念 1.面向对象 面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个“对象”：对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。
2.面向过程 面向过程是一种以“整体事件”为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。
3.类和对象 类是定义了一件事物的抽象特点，它将数据的形式以及这些数据上的操作封装在一起。
对象是具有类类型的变量，是对类的实例。
内部构成：成员变量（属性）+成员函数(方法)
成员变量：定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可成为对象的属性。
成员函数：定义在类的内部，可用于访问对象的数据。
4.继承 继承：继承性是子类自动共享父类数据结构和方法的机制，是类之间
的一种关系。
​ 在定义和实现一个类的时候，可以在一个已经存在的类的基础
之上来进行，把一个已经存在的类所定义的内容作为自己的内容，并
加入若干新的内容。
父类：一个类被其它类继承，可将该类成为父类，或基类，超类。
子类：一个类继承其他类称为子类，也可称为派生类。
2.实例化 1.类的结构 class Class_Name{ //成员属性 //成员方法 } 2.类的内容 创建一个类：
class student{//定义类（类名） var $name;//声明成员变量，var为一种修饰符 var $age; function study($var1){//声明成员方法 echo $this-&gt;name;//使用预定义$this调用成员变量 echo $this-&gt;age; echo $var1.'学习'//成员函数传参$var1可直接调用 } } 3.实例化和赋值 $zs = new student();//实例化 $zs-&gt;name = "张三";//赋值 $zs-&gt;age = 34; $zs-&gt;study("好好");//函数调用 print_r($zs); 4.类的修饰符 访问权限修饰符：对属性的定义
常用访问权限修饰符：
public:公共的，在类的内部、子类中或者类的外部都可以使用，不受限制：
protected:受保护的，在类的内部、子类中可以使用，但不能在类的外部使用：
private:私有的，只能在类的内部使用，在类的外部或者子类中都无法使用。
class student{ public $name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17fdf6120ae8814a1c319033dffe258b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea5359e01a41842884943125518289b/" rel="bookmark">
			Canvas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Entry @Component struct LikePage { @State message: string = 'Hello World' //设置 setting: RenderingContextSettings = new RenderingContextSettings(true) //画笔 paint: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.setting) build() { Canvas(this.paint).width("100%").height("100%").backgroundColor(Color.Pink) .onReady(() =&gt; { this.draw() }) } draw() { //当前的弧度 var currentRadian = 0 //每一次增加的弧度 var add_radian = Math.PI / 180 //将画布的圆心坐标移动到其他位置 this.paint.translate(180, 180) //设置画笔颜色 this.paint.strokeStyle = "#ff0000" this.paint.lineWidth = 10 //将画笔移动到起点 this.paint.moveTo(this.call_x(currentRadian), this.call_y(currentRadian)) //周期执行方法 setInterval(()=&gt;{ //绘制 if (currentRadian &lt;= Math.PI * 2) { //获取当前的弧度 currentRadian = currentRadian + add_radian var endX = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ea5359e01a41842884943125518289b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302ddf30c8645d0a48c038bf9281e01b/" rel="bookmark">
			C语言&#43;单片机-内存分布详解，全网最全，值得收藏保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、C语言内存分区
1. 代码区
2. 常量区
3. 全局(静态)区
4. 堆区(heap)
5. 栈区(stack)
二、STM32存储器分配
1. 随机存储器—RAM
2. 只读存储器—ROM
三、基于STM32代码验证
1. 详细代码如下
2. 运行结果如下
四、单片机中的内存分布
1.含义解释
2. 程序存储分布
3.程序占用Flash和SRAM的空间
五、各段划分缘由(精华部分)
1.为什么把程序的“ 代码段 ”和“ 数据段 ”分开存放？
2. 为什么数据段还需要分 .data、.bss、.rodata 这么麻烦？有什么区别？
3. 为什么全局变量还有细分初始化和未初始化?
本篇主要讲在C语言和单片机中内存分布情况。
一、C语言内存分区 C语言内存分区示意图如下：
1. 代码区 程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。
字符串常量和define定义的常量也有可能存放在代码区。
2. 常量区 字符串、数字等常量存放在常量区。
const修饰的全局变量存放在常量区。
程序运行期间，常量区的内容不可以被修改。
3. 全局(静态)区 全局(静态)区介绍
编译器编译时即分配内存，全局变量和静态变量的存储是放在一块的。C语言中，已初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
全局区有 .bss段 和 .data段组成，可读可写。
.bss段
未初始化的全局变量和未初始化的静态变量存放在.bss段。
初始化为0的全局变量和初始化为0的静态变量存放在.bss段。
.bss段不占用可执行文件空间，其内容由操作系统初始化(清零)。
.data段
已初始化的全局变量存放在.data段。
已初始化的静态变量存放在.data段。
.data段占用可执行文件空间，其内容由程序初始化。
4. 堆区(heap) 堆区介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302ddf30c8645d0a48c038bf9281e01b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b2c2633fe0c6e6259c4a3207869569/" rel="bookmark">
			linux正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下的正则表达式 1、字符匹配元字符 . 任意单个字符，包含汉字，一个汉字也是一个字符 [wang] 指定范围的字符 [^wang] 不在指定范围的字符 [:alnum:] 字母和数字 [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:lower:] 小写字母,示例:[[:lower:]],相当于[a-z] [:upper:] 大写字母 [:blank:] 空白字符（空格和制表符） [:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广） [:cntrl:] 不可打印的控制字符（退格、删除、警铃...） [:digit:] 十进制数字 [:xdigit:]十六进制数字 [:graph:] 可打印的非空白字符 [:print:] 可打印字符 [:punct:] 标点符号 yang@yang-user:~$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:120:126:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin # “.”匹配任意单个字符 yang@yang-user:~$ grep r..t /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:120:126:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin # 一个“.”代表一个字符 yang@yang-user:~$ echo roter |grep r..t yang@yang-user:~$ # 也可以是汉字 yang@yang-user:~$ echo r测试ter |grep r..t r测试ter [ ] 指定范围的字符
# 会将检索到的字符给标红显示 yang@yang-user:~$ echo abc |grep '[abcd]' abc yang@yang-user:~$ echo abcd |grep '[ab]' abcd yang@yang-user:~$ echo ab cd |grep '[ab]' ab cd yang@yang-user:~$ echo a bcd |grep '[ab]' a bcd [^root]不在指定范围的字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06b2c2633fe0c6e6259c4a3207869569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc14bdeeeef2dc3a6735e815c468ae6/" rel="bookmark">
			Vue Springboot前后端交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Axios的使用
1、简介
Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。
2、请求配置
这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。
{ // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `headers` 是即将被发送的自定义请求头 headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: 'Fred' }, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cc14bdeeeef2dc3a6735e815c468ae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1827b77fa1215d53f287200a94a82b/" rel="bookmark">
			Elasticsearch使用篇 - 管道聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		管道聚合 基于前一次聚合的结果，进行二次聚合统计。
从结构上可以分为兄弟级（Sibling）管道聚合和父级（Parent）管道聚合两种方式。
兄弟级管道聚合：在同一聚合级别上可以产生新的聚合。 GET kibana_sample_data_logs/_search { "size": 0, "aggs": { "count_per_day": { "date_histogram": { "field": "@timestamp", "calendar_interval": "day" } }, "total_bytes_of_download": { "sum": { "field": "bytes" } } } } 父级管道聚合：由父聚合提供输出，子聚合能够产生新的桶，然后可以添加到父桶中。 GET kibana_sample_data_logs/_search { "size": 0, "aggs": { "count_per_day": { "date_histogram": { "field": "@timestamp", "calendar_interval": "day" }, "aggs": { "total_bytes_per_day": { "sum": { "field": "bytes" } } } } } } max_bucket、min_bucket、avg_bucket、sum_bucket 基于兄弟级管道聚合的方式，从多个分桶中获取指定数值指标的聚合结果（最大值 / 最小值 / 平均值 / 和）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed1827b77fa1215d53f287200a94a82b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9808215e5cf78a4f4260bd0b7fb7107a/" rel="bookmark">
			redis 数据导出及导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本操作在linux-示例在centos6.x上操作：
redis 数据导出
命令进入redis，在ssh上输入
redis-cli -a password #个人设置的密码在redis上输入，先把当操作保存
bgsave然后停止redis
service redis stop进入rdb文件路径，复制dump.rdb
cd /var/lib/redis/重新启动redis
service redis start redis 数据导入
导入则是先停redis再替换此文件
service redis stop把复制的dump.rdb 上传到以下路径
默认路径在 /var/lib/redis/，若非默认请自己查找
/var/lib/redis/执行bgsave启动redis
service redis start确认redis的数据是否正常只要有dump.rdb 文件在 可以重复执行，注意不要随便删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd5ad2b2ffdf5767d6a08924bf756e5/" rel="bookmark">
			运行RSCNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境，徐黄机器 980显卡， cuda8.0，torch 0.4， python 3.7.16
困难主要来自于 torch 0.4的安装，其要求低版本的cuda，进而要求低版本的显卡。相近版本的软件(cuda, torch)是可以兼容的，但是版本相差太大应该不行。
Could NOT find CUDA (missing: CUDA_CUDART_LIBRARY) (found version “8.0”)
https://github.com/nicehash/nheqminer/issues/317
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc8c0cf778d3a4871f7fe264c1c0ab1/" rel="bookmark">
			Java使用jna调用c开发的动态库dll文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.c开发动态库dll1.1 新建项目dllDemo1.2 选择C library 在选择shared1.3 项目的目录结构1.4 定义动态库函数1.5 导出动态库 2.java中使用jna调用dll2.1 需要引入jna的依赖2.2 加载动态库dll2.3 测试程序2.3.1 测试代码：2.3.2 测试结果输出 前言 在日常的开发中，对接外部接口常常有很多的对接方式，wsdl,rest,以及第三方提供的动态库等，本次将讲解在java中如何调用c开发的动态库。
1.c开发动态库dll 开发工具Clion,创建动态链接库。
1.1 新建项目dllDemo 1.2 选择C library 在选择shared 要选择shared，static是静态的
1.3 项目的目录结构 包含头文件.h，和主要的代码.c文件，cmakelist.txt构建的脚本
1.4 定义动态库函数 头文件定义两个动态库方法，hello以及add方法。
#ifndef DLLDEMO_LIBRARY_H #define DLLDEMO_LIBRARY_H void hello(void); int add(int a,int b); #endif //DLLDEMO_LIBRARY_H 在.c中写方法的具体实现。
#include "library.h" #include &lt;stdio.h&gt; void hello(void) { printf("调用动态库hello方法成功!\n"); } //定义一个加法的方法 int add(int a,int b){ int result = a+b; printf("调用动态库add方法:%d + %d=%d",a,b,result); return result; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acc8c0cf778d3a4871f7fe264c1c0ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3ba1c1c48b1737bbff4fa9f55cb59f/" rel="bookmark">
			vue跨域实现：proxy配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是跨域 要了解跨域，首先得知道浏览器的同源策略。
同源策略：是由Netscape提出的一个安全策略，能够阻挡恶意文档，保护本地数据。它能限制一个源的文档或脚本对另一个源的交互，使得其它源的文档或脚本，无法读取或修改当前源。
是否同源：当两个url的域名、协议和端口均相同。
举例来说：url： http://127.0.0.1:80/demo/01.html 中组成部分如下图所示：
url是否同源原因 http://127.0.0.1:80/demo/02.html http://127.0.0.1:80/demo2/01.html 同源协议、域名、端口均相同，只是文件地址不同http://127.0.0.1:90/demo/01.html不同源端口不同http://127.1.1.1:80/demo/01.html不同源域名不同https://127.0.0.1:80/demo/01.html不同源协议不同http://127.0.0.1/demo/01.html同源http:// 默认端口是 80 不同协议有不同的默认端口，当未指定端口时，则使用默认端口。
跨域：能实现在不同源之间的资源交互。
为什么要跨域：因为所有的资源有可能不在同一个域内，比如一个公司有很多子域，中间的通信就需要跨域。
二、vue项目跨域vue.config.js文件配置 1. publicPath配置
publicPath是部署时的基本url，一般情况下vue项目起什么名称，publicPath就赋值什么名称。
假设一个项目的初始地址为： http://127.0.0.1:80/，若是配置上publicPath: "/demo"，则项目的初始地址则会变成http://127.0.0.1:80/demo/。
vue打包后的静态文件资源需要访问，所以需要一个文件路径放置vue的打包文件，后端nginx中对应配置的也是这个地址。
2. devServer.proxy代理配置
该字段主要是为了实现前后端通信的，当前后端分离开发，为了让前端开发人员在开发时访问到后端的接口，需要进行nginx配置实现跨域请求。
参考这个同学的文章：vue配置反向代理 devServer配置proxy，说明如下：
// vue.config.js文件 module.exports = { //..... devServer: { host: 'localhost', port: 8080, proxy: { "/api": { target: "http://www.xxx.com", // 请求到/api/xx 就会被代理http://www.xxx.com/api/xxx // secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 接口跨域 需打开这个参数 pathRewrite: { '^/api': '', // 忽略前缀/api 则会被代理到http://www.xxx.com/xxx }, } } }, } 其实很好理解，简单来说就是给实际的接口路径做了一层代理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a3ba1c1c48b1737bbff4fa9f55cb59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a96f8ee18556541e503311d5a1cd38a/" rel="bookmark">
			STM32 RGB屏幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ST的HAL库进行开发，RGB屏幕是480*272的4.3寸LCD，由于驱动RGB屏幕需要较多的内存，
所以使用了外部SDRAM，内存是32M字节，关于SDRAM的驱动本文不进行讨论。
RGB屏幕常用的像素格式有：ARGB8888、RGB888、RGB565、ARGB1555、ARGB4444等格式，本文讨论RGB565格式的使用。
RGBLCD的信号线如下表：
上表共有24根颜色信号线，RGB565格式只用了其中的16根颜色信号线，分别是：R[3:7]，G[2:7]，B[3:7]，共16位，
这样在表示颜色的时候就可以用16位长度的数据进行表示了，增加了数据的传输速度。
RGBLCD接口的原理图如下：
除了16位数据线之外，还有用到如下几个信号线：
LCD_BL：背光；
LCD_DE：数据使能信号；
LCD_VSYNC：垂直同步信号；
LCD_HSYNC：水平同步信号；
LCD_CLK：时钟信号；
STM32F429有自带的RGBLCD外设接口LTDC，可以用来直接驱动RGBLCD，另外配上专用于图像处理的DMA2D，
使得RGBLCD用起来更加方便快速。
下面开始介绍使用到的单片机引脚对应：
PI9 ------&gt; LTDC_VSYNC
PI10 ------&gt; LTDC_HSYNC
PF10 ------&gt; LTDC_DE
PG7 ------&gt; LTDC_CLK
PH9 ------&gt; LTDC_R3
PH10 ------&gt; LTDC_R4
PH11 ------&gt; LTDC_R5
PH12 ------&gt; LTDC_R6
PG6 ------&gt; LTDC_R7
PH13 ------&gt; LTDC_G2
PH14 ------&gt; LTDC_G3
PH15 ------&gt; LTDC_G4
PI0 ------&gt; LTDC_G5
PI1 ------&gt; LTDC_G6
PI2 ------&gt; LTDC_G7
PG11 ------&gt; LTDC_B3
PI4 ------&gt; LTDC_B4
PI5 ------&gt; LTDC_B5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a96f8ee18556541e503311d5a1cd38a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51c625cce2a2618e6a161055bcf81ff/" rel="bookmark">
			Java 的 IO 笔记——拨开云雾见月明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 的 IO 笔记 首先 ，IO 是指输入和输出，它是所有程序都必不可少的部分，程序使用输入机制，允许程序读取外部数据（包括来自磁盘、光盘等存储设备的数据）、用户输入数据；程序使用输出机制，允许程序记录运行状态，将程序数据输出到磁盘、光盘等存储设备中。
Java 的 IO 通过 java . io 包下的类和接口支持，在 java . io 包下主要包括输入、输出两种 IO 流，每种输入、输出流又分为字节流和字符流两大类。其中字节流以字节为单位来处理输入、输出操作，而字符流则以字符来处理输入、输出操作。除此之外，Java 的 IO 流使用了一种装饰者设计模式，它将 IO 流分成底层节点流和上层处理流，其中节点流用于和底层的物理存储节点直接关联——不同的物理节点获取节点流的方式可能存在一定的差异，但程序可以把不同的物理节点流包装成统一的处理流，从而允许程序使用统一的输入、输出代码来读取不同的物理存储节点的资源。
1 . File 类 File 类是 java . io 包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件和目录，都可以通过 File 类来完成。值得指出的是，不管是文件还是目录都是使用 File 来操作，File 能新建、删除、重命名文件和目录，File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入、输出流。
1 . 1 访问文件和目录 File 类可以使用文件路径字符串来创建 File 实例，该文件路径字符串既可以是绝对路径，也可以是相对路径。在默认情况下，系统总是依据用户的工作路径来解释相对路径，这个路径由系统属性“ user.dir ” 指定，通常也就是运行 Java 虚拟机时所在的路径。
一旦创建了 File 对象后，就可以调用 File 对象的方法来访问，File 类提供了很多方法来操作文件和目录，下面列出一些比较常用的方法。
（1）dian访问文件名相关的方法
String getName( ) : 返回此 File 对象所表示的文件名或路径名（如果是路径，则返回最后一级子路径名）。String getPath( ) : 返回此 File 对象所对应的路径名。File getAbsoluteFile( ) : 返回此 File 对象的绝对路径。String getAbsolutePath ( ) : 返回此 File 对象所对应的绝对路径名。String getParent ( ) : 返回此 File 对象所对应目录（最后一级子目录）的父目录名。boolean renameTo ( File newName ) : 重命名此 File 对象所对应的文件或目录，如果重命名成功，则返回 true ，否则返回 false 。 （2）文件的检测相关的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e51c625cce2a2618e6a161055bcf81ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303cddcc5a9099867017e30fb5128df9/" rel="bookmark">
			Linux系统权限详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一·权限解释
1. 所有者权限：
2. 所属组权限：
3. 其他人权限：
二·用户用户组解释
3·解释权限含义
4·权限命令解释
三·基本权限 U G O 1·权限对象
2·基本权限
3·高级权限 一·权限解释 在Linux系统中，文件和目录的访问权限由三个部分组成：所有者、所属组和其他人。每个部分都有自己的权限设置，包括读取、写入和执行权限。以下是Linux系统权限的详细介绍：
1. 所有者权限： 文件或目录的所有者可以读取、写入和执行该文件或目录。如果文件或目录的所有者是当前用户，那么用户可以使用chmod命令更改该文件或目录的权限。
2. 所属组权限： 文件或目录的所属组成员可以读取、写入和执行该文件或目录。如果当前用户属于该文件或目录的所属组，那么用户可以使用chmod命令更改该文件或目录的权限。
3. 其他人权限： 文件或目录的其他人可以读取、写入和执行该文件或目录。如果当前用户既不是该文件或目录的所有者，也不属于该文件或目录的所属组，那么用户可以使用chmod命令更改该文件或目录的权限。
在Linux系统中，可以使用chmod命令更改文件或目录的权限。chmod命令的语法如下：
chmod [who] [operator] [permission] file
其中，who表示要更改的权限对象，operator表示要执行的操作，permission表示要设置的权限，file表示要更改权限的文件或目录。例如，要将文件file.txt的所有者权限设置为读取、写入和执行，可以使用以下命令：
chmod u+rwx file.txt
这将为文件file.txt的所有者添加读取、写入和执行权限。
二·用户用户组解释 cat /etc/group 查看用户组及权限内容
cat /etc/passwd 查看用户及权限内容
3·解释权限含义 以 " : " 为分隔符，每一列代表的含义
①·用户名
②·密码
③·用户标识号-（uid）是一个整数，系统内部用来标识用户，通常用户标识号的取值范围是0-65535,0=root（超级用户）
④·gid
⑤·描述信息
⑥·家目录
⑦·是用户登录到界面的第一个命令，开启一个shell，登录shell
解释：uid= 系统用来识别账户的
gid= 系统用来识别组的
4·权限命令解释 useradd 用户名 -u 678 -指定新用户的uid为678
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/303cddcc5a9099867017e30fb5128df9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251294f4ddd2a8e8ce04e464ce55cfa8/" rel="bookmark">
			python小游戏毕设 消消乐小游戏设计与实现 (源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 项目简介1 游戏介绍2 实现效果3 开发工具3.1 环境配置3.2 Pygame介绍 4 具体实现5 最后 0 项目简介 🔥 Hi，各位同学好呀，这里是L学长！
🥇今天向大家分享一个今年(2022)最新完成的毕业设计项目作品
python小游戏毕设 消消乐小游戏设计与实现 (源码)
🥇 学长根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：3分
创新点：4分
项目获取：
https://gitee.com/sinonfin/system-sharing
1 游戏介绍 利用python制作的简易消消乐小游戏。
游戏规则：
玩家通过鼠标交换相邻的拼图，若交换后水平/竖直方向存在连续三个相同的拼图，则这些拼图消失，玩家得分，同时生成新的拼图以补充消失的部分，否则，交换失败，玩家不得分。
玩家需要在规定时间内获取尽可能高的得分。
2 实现效果 3 开发工具 3.1 环境配置 Python版本：3.6.4
相关模块：
pygame模块；
以及一些Python自带的模块。
3.2 Pygame介绍 简介
Pygame是一系列专门为编写电子游戏而设计的Python模块(modules)。Pygame在已经非常优秀的SDL库的基础上增加了许多功能。这让你能够用Python语言编写出丰富多彩的游戏程序。
Pygame可移植性高，几乎能在任何平台和操作系统上运行。
Pygame已经被下载过数百万次。
Pygame免费开源。它在LGPL许可证(Lesser General Public License，GNU宽通用公共许可证)下发行。使用Pygame，你可以创造出免费开源，可共享，或者商业化的游戏。详情请见LGPL许可证。
优点
能够轻松使用多核CPU(multi core CPUs) :如今双核CPU很常用，8核CPU在桌面系统中也很便宜，而利用好多核系统，能让你在你的游戏中实现更多东西。特定的pygame函数能够释放令人生畏的python GIL(全局解释器锁),这几乎是你用C语言才能做的事。
核心函数用最优化的C语言或汇编语言编写:C语言代码通常比Python代码运行速度快10-20倍。而汇编语言编写的代码(assembly code)比Python甚至快到100多倍。
安装便捷:一般仅需包管理程序或二进制系统程序便能安装。
真正地可移植:支持Linux (主要发行版), Windows (95, 98, ME, 2000, XP, Vista, 64-bit Windows,), Windows CE, BeOS, MacOS, Mac OS X, FreeBSD, NetBSD, OpenBSD, BSD/OS, Solaris, IRIX, and QNX等操作系统.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/251294f4ddd2a8e8ce04e464ce55cfa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03d53a47f4a70a1344e1c9fd444a03e/" rel="bookmark">
			python小游戏毕设 推箱子小游戏设计与实现 (源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 项目简介1 游戏介绍2 实现效果3 开发工具3.1 环境配置3.2 Pygame介绍 4 具体实现5 最后 0 项目简介 🔥 Hi，各位同学好呀，这里是L学长！
🥇今天向大家分享一个今年(2022)最新完成的毕业设计项目作品
python小游戏毕设 推箱子小游戏设计与实现 (源码)
🥇 学长根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：3分
创新点：4分
项目获取：
https://gitee.com/sinonfin/system-sharing
1 游戏介绍 游戏简介：
经典的推箱子是一个来自日本的古老游戏，目的是在训练你的逻辑思考能力。在一个狭小的仓库中，要求把木箱放到指定的位置，稍不小心就会出现箱子无法移动或者通道被堵住的情况，所以需要巧妙的利用有限的空间和通道，合理安排移动的次序和位置，才能顺利的完成任务。
控制方式：
↑↓←→键控制人物行动，r键重新开始本关。
2 实现效果 3 开发工具 3.1 环境配置 Python版本：3.6.4
相关模块：
pygame模块；
以及一些Python自带的模块。
3.2 Pygame介绍 简介
Pygame是一系列专门为编写电子游戏而设计的Python模块(modules)。Pygame在已经非常优秀的SDL库的基础上增加了许多功能。这让你能够用Python语言编写出丰富多彩的游戏程序。
Pygame可移植性高，几乎能在任何平台和操作系统上运行。
Pygame已经被下载过数百万次。
Pygame免费开源。它在LGPL许可证(Lesser General Public License，GNU宽通用公共许可证)下发行。使用Pygame，你可以创造出免费开源，可共享，或者商业化的游戏。详情请见LGPL许可证。
优点
能够轻松使用多核CPU(multi core CPUs) :如今双核CPU很常用，8核CPU在桌面系统中也很便宜，而利用好多核系统，能让你在你的游戏中实现更多东西。特定的pygame函数能够释放令人生畏的python GIL(全局解释器锁),这几乎是你用C语言才能做的事。
核心函数用最优化的C语言或汇编语言编写:C语言代码通常比Python代码运行速度快10-20倍。而汇编语言编写的代码(assembly code)比Python甚至快到100多倍。
安装便捷:一般仅需包管理程序或二进制系统程序便能安装。
真正地可移植:支持Linux (主要发行版), Windows (95, 98, ME, 2000, XP, Vista, 64-bit Windows,), Windows CE, BeOS, MacOS, Mac OS X, FreeBSD, NetBSD, OpenBSD, BSD/OS, Solaris, IRIX, and QNX等操作系统.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03d53a47f4a70a1344e1c9fd444a03e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a57a215b34a83b4dd1a2037d8461254/" rel="bookmark">
			python小游戏毕设 接金币小游戏设计与实现 (源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 项目简介1 游戏介绍2 实现效果3 开发工具3.1 环境配置3.2 Pygame介绍 4 具体实现5 最后 1 项目简介 🔥 Hi，各位同学好呀，这里是L学长！
🥇今天向大家分享一个今年(2022)最新完成的毕业设计项目作品
python小游戏毕设 接金币小游戏设计与实现 (源码)
🥇 学长根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：3分
创新点：3分
项目获取：
https://gitee.com/sinonfin/system-sharing
1 游戏介绍 基于python实现的接金币小游戏。
游戏规则：
方向键控制小人左右移动接金币。
2 实现效果 3 开发工具 3.1 环境配置 Python版本：3.6.4
相关模块：
pygame模块；
以及一些Python自带的模块。
3.2 Pygame介绍 简介
Pygame是一系列专门为编写电子游戏而设计的Python模块(modules)。Pygame在已经非常优秀的SDL库的基础上增加了许多功能。这让你能够用Python语言编写出丰富多彩的游戏程序。
Pygame可移植性高，几乎能在任何平台和操作系统上运行。
Pygame已经被下载过数百万次。
Pygame免费开源。它在LGPL许可证(Lesser General Public License，GNU宽通用公共许可证)下发行。使用Pygame，你可以创造出免费开源，可共享，或者商业化的游戏。详情请见LGPL许可证。
优点
能够轻松使用多核CPU(multi core CPUs) :如今双核CPU很常用，8核CPU在桌面系统中也很便宜，而利用好多核系统，能让你在你的游戏中实现更多东西。特定的pygame函数能够释放令人生畏的python GIL(全局解释器锁),这几乎是你用C语言才能做的事。
核心函数用最优化的C语言或汇编语言编写:C语言代码通常比Python代码运行速度快10-20倍。而汇编语言编写的代码(assembly code)比Python甚至快到100多倍。
安装便捷:一般仅需包管理程序或二进制系统程序便能安装。
真正地可移植:支持Linux (主要发行版), Windows (95, 98, ME, 2000, XP, Vista, 64-bit Windows,), Windows CE, BeOS, MacOS, Mac OS X, FreeBSD, NetBSD, OpenBSD, BSD/OS, Solaris, IRIX, and QNX等操作系统.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a57a215b34a83b4dd1a2037d8461254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1ed4d66841b680dd162a60714cb388/" rel="bookmark">
			python小游戏毕设 拼图小游戏设计与实现 (源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 项目简介1 游戏介绍2 实现效果3 开发工具3.1 环境配置3.2 Pygame介绍 4 具体实现5 最后 0 项目简介 🔥 Hi，各位同学好呀，这里是L学长！
🥇今天向大家分享一个今年(2022)最新完成的毕业设计项目作品
python小游戏毕设 拼图小游戏设计与实现 (源码)
🥇 学长根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：3分
创新点：4分
项目获取：
https://gitee.com/sinonfin/system-sharing
1 游戏介绍 游戏规则：
将图像分为m×n个矩形块，并将图像右下角的矩形块替换为空白块后，将这些矩形块随机摆放成原图像的形状。游戏目标为通过移动非空白块将随机摆放获得的图像恢复成原图像的模样，且规定移动操作仅存在于非空白块移动到空白块。
例如下图所示：
2 实现效果 3 开发工具 3.1 环境配置 Python版本：3.6.4
相关模块：
pygame模块；
以及一些Python自带的模块。
3.2 Pygame介绍 简介
Pygame是一系列专门为编写电子游戏而设计的Python模块(modules)。Pygame在已经非常优秀的SDL库的基础上增加了许多功能。这让你能够用Python语言编写出丰富多彩的游戏程序。
Pygame可移植性高，几乎能在任何平台和操作系统上运行。
Pygame已经被下载过数百万次。
Pygame免费开源。它在LGPL许可证(Lesser General Public License，GNU宽通用公共许可证)下发行。使用Pygame，你可以创造出免费开源，可共享，或者商业化的游戏。详情请见LGPL许可证。
优点
能够轻松使用多核CPU(multi core CPUs) :如今双核CPU很常用，8核CPU在桌面系统中也很便宜，而利用好多核系统，能让你在你的游戏中实现更多东西。特定的pygame函数能够释放令人生畏的python GIL(全局解释器锁),这几乎是你用C语言才能做的事。
核心函数用最优化的C语言或汇编语言编写:C语言代码通常比Python代码运行速度快10-20倍。而汇编语言编写的代码(assembly code)比Python甚至快到100多倍。
安装便捷:一般仅需包管理程序或二进制系统程序便能安装。
真正地可移植:支持Linux (主要发行版), Windows (95, 98, ME, 2000, XP, Vista, 64-bit Windows,), Windows CE, BeOS, MacOS, Mac OS X, FreeBSD, NetBSD, OpenBSD, BSD/OS, Solaris, IRIX, and QNX等操作系统.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1ed4d66841b680dd162a60714cb388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc7b9f6c3c554eb6a890953715da7d8/" rel="bookmark">
			python小游戏毕设 扫雷小游戏设计与实现 (源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 项目简介1 游戏介绍2 实现效果3 开发工具3.1 环境配置3.2 Pygame介绍 4 具体实现5 最后 0 项目简介 🔥 Hi，各位同学好呀，这里是L学长！
🥇今天向大家分享一个今年(2022)最新完成的毕业设计项目作品
python小游戏毕设 扫雷小游戏设计与实现 (源码)
🥇 学长根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：3分
创新点：4分
项目获取：
https://gitee.com/sinonfin/system-sharing
1 游戏介绍 《扫雷》是一款大众类的益智小游戏，于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子，同时避免踩雷，踩到一个雷即全盘皆输。
今天我们利用Python实现经典扫雷游戏
2 实现效果 3 开发工具 3.1 环境配置 Python版本：3.6.4
相关模块：
pygame模块；
以及一些Python自带的模块。
3.2 Pygame介绍 简介
Pygame是一系列专门为编写电子游戏而设计的Python模块(modules)。Pygame在已经非常优秀的SDL库的基础上增加了许多功能。这让你能够用Python语言编写出丰富多彩的游戏程序。
Pygame可移植性高，几乎能在任何平台和操作系统上运行。
Pygame已经被下载过数百万次。
Pygame免费开源。它在LGPL许可证(Lesser General Public License，GNU宽通用公共许可证)下发行。使用Pygame，你可以创造出免费开源，可共享，或者商业化的游戏。详情请见LGPL许可证。
优点
能够轻松使用多核CPU(multi core CPUs) :如今双核CPU很常用，8核CPU在桌面系统中也很便宜，而利用好多核系统，能让你在你的游戏中实现更多东西。特定的pygame函数能够释放令人生畏的python GIL(全局解释器锁),这几乎是你用C语言才能做的事。
核心函数用最优化的C语言或汇编语言编写:C语言代码通常比Python代码运行速度快10-20倍。而汇编语言编写的代码(assembly code)比Python甚至快到100多倍。
安装便捷:一般仅需包管理程序或二进制系统程序便能安装。
真正地可移植:支持Linux (主要发行版), Windows (95, 98, ME, 2000, XP, Vista, 64-bit Windows,), Windows CE, BeOS, MacOS, Mac OS X, FreeBSD, NetBSD, OpenBSD, BSD/OS, Solaris, IRIX, and QNX等操作系统.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc7b9f6c3c554eb6a890953715da7d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475be57be42ca369d179654895469dc2/" rel="bookmark">
			Apache Log4j Server 反序列化命令执行漏洞（CVE-2017-5645）（漏洞复现详细过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、漏洞介绍
二、漏洞环境搭建
三、漏洞利用
四、漏洞流量特征：
一、漏洞介绍 CVE-2017-5645 是 Apache Log4j 服务器的一个反序列化命令执行漏洞，攻击者可以利用这个漏洞通过发送精心制作的请求，远程执行命令，从而危及服务器的安全。
二、漏洞环境搭建 进入漏洞目录文件，启动漏洞环境：docker-compose up -d
查看容器运行状态：docker ps -a
可以看到环境启动成功后，会在4712端口开启了一TCP服务。（至此漏洞环境搭建完成了，使用docker搭建环境就是如此简单易操作）
三、漏洞利用 扫描目标开启的端口：nmap your-ip -p 4712
在这里我们呢可以看到4712端口是开启的，然后我们使用ysoserial生成payload，然后直接发送给your-ip:4712端口即可。
ysoserial介绍：
是在常见的java库中发现的一组实用程序和面向属性的编程“小工具链”，在适当的条件下，可以利用执行对象不安全反序列化的Java应用程序。（没有工具的小伙伴 可以私聊我）
我们下载打包好的jar文件到我们的kali主机上。
执行命令：
java -jar ysoserial-all.jar CommonsCollections5 "touch /tmp/success" | nc your-ip 4712
这个命令是在靶机的/tmp目录下创建一个success文件，如果我们的命令执行成功，那么在靶机上可以找到这个文件。
到靶机上进行检测文件是否被创建，命令是否执行成功。
查看容器id：docker ps -a
在靶机上执行命令，打开网站目录：docker exec -it [容器id] /bin/bash
然后进入到tmp目录，执行命令：cd tmp ，显示目录下文件：ls，可以看到success文件，可见touch /tmp/testsuccess执行成功。
至此漏洞复现完成。
四、漏洞流量特征： 1、攻击者通常利用Log4j漏洞来执行远程指令，因此攻击流量中可能包含恶意代码。
2、攻击者可以通过利用Log4j漏洞来绕过Web应用程序的安全性，因此攻击流量中可能包含对Web应用程序的修改和访问。
3、攻击者通常会尝试使用恶意代码来启动已被收集的许多有价值的数据，因此攻击流量中可能包含大量的数据包。
在攻击流量中， Log4j漏洞的攻击通常会使用特定的Payload。
判断是否已经攻击成功我们要检查应用程序的日志文件，特别是logs文件夹中的日志文件。
以下是一些可以帮助判断漏洞是否被利用的指标：
当日志文件中出现“RememberMe”或“Admin”等关键字。
日志文件中出现远程代码执行相关的异常信息。
检查系统中是否存在未知的网络流量，特别是与恶意IP地址之间的流量。
检查服务器的端口使用情况，确认是否存在未知的端口使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f54e5d9802b5792dea5a7b5ffb0b650d/" rel="bookmark">
			JMeter工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. Jmeter设置语言为简体中文 2. Jmeter添加线程组 3. Jmeter添加http请求 4. Jmeter添加数据统计结果 5. JMeterAddress Already in use 错误解决 windows本身提供的端口访问机制的问题。 Windows提供给 TCP/IP链接的端口为1024-5000，并且要四分钟来循环回收他们。就导致 我们在短时间内跑大量的请求时将端口占满了。 1.cmd中，用regedit命令打开注册表 2.在HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters下 1.右击parameters，添加一个新的 DWORD，名字为MaxUserPort和TCPTimedWaitDelay 2.然后双击MaxUserPort，输入数值数据为65534，基数选择十进制（如果是分布式运 行的话，控制机器和负载机器都需要这样操作哦） 3.然后双击TCPTimedWaitDelay，输入数值数据为30，基数选择十进制（如果是分布式运 行的话，控制机器和负载机器都需要这样操作哦） 4．修改配置完毕之后记得重启机器才会生效 https://support.microsoft.com/zh-cn/help/196271/when-you-try-to-connect-from-tcp-ports-greater-than-5000-you-receive-t 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d42a5c70bc55deceda353c5b898444e/" rel="bookmark">
			使用 Docker 高效搭建本地开发环境（详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker本地开发环境的好处 试错 对开发者而言，每天会催生出的各式各样的新技术都需要尝试，然而开发者却不太可能为他们一一搭建好环境并进行测试。时间非常宝贵，正是得益于 Docker，让我们有可能在一条或者几条命令内就搭建完环境，而且这个环境大到一个特定版本的操作系统，小到一个软件。Docker 有一个傻瓜化的获取软件的方法，Docker后台会自动获得环境镜像并且运行环境。
统一开发和生产环境 对于一般的小公司来说，搭建一个公用的开发环境是一件不那么划算的事情。那么就可以用Docker来统一开发环境，因为不管你用的是Windows、Mac 还是 Ubuntu。如果生产环境也使用的Docker的话，你甚至可以直接打包一套环境，直接丢上去就可以运行了，再也不用担心开发-生产环境之间的差异了。
高性能 虚拟机的粒度是虚拟出的机 ，而Docker的粒度则是被限制的应用 ，相比较而言 Docker 的内存占用更少，更加轻量级，性能也更优。
而秒级的启动，也可以让我们启动电脑时候，开发环境的运行是无感知的。
成果展示 我们可能经常要给用户或者是同事展示一样功能的，但是搭建演示环境的过程却是非常麻烦的。现在可以直接将我们的镜像打包丢过去，而不必去做任何环境配置的工作，同时也不必担心他们的环境配置会导致我们的产品无法运行。
安装Docker 在mac平台下，就是去下载一个dmg的安装文件。下载好了之后，双击，然后拖入就可以了，windows应该也是类似的。
就是安装qq一样简单，傻瓜式的。
附上dockerhub上的下载链接：
https://hub.docker.com/search/?type=edition&amp;offering=community&amp;q=
成功之后属于docker version如果出来版本信息就是安装成功，类似如下
Client: Docker Engine - Community Version: 18.09.0 API version: 1.39 Go version: go1.10.4 Git commit: 4d60db4 Built: Wed Nov 7 00:47:43 2018 OS/Arch: darwin/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 18.09.0 API version: 1.39 (minimum version 1.12) Go version: go1.10.4 Git commit: 4d60db4 Built: Wed Nov 7 00:55:00 2018 OS/Arch: linux/amd64 Experimental: true 安装docker-composer 一般来说，mac安装docker之后就会携带docker-composer。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d42a5c70bc55deceda353c5b898444e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e941b7c89045cf8dbf10758a9346af4/" rel="bookmark">
			原生mybatis实现数据加密存储和读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生mybatis实现数据加密存储和读取 物料准备：
1.mysql,mybatis等依赖
2.定义数据库表以及对应的Java实体类、mapper接口/xml等代码
3.定义加密类和字段的Java注解
4.定义mybatis拦截器插件以及数据加解密工具类
5.测试数据插入和查询的效果
pom.xml中引入相关依赖 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 定义数据库表以及对应的Java实体类mapper接口xml等代码 数据库表SQL代码 CREATE DATABASE test619; ALTER DATABASE `test619` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; USE `test619`; CREATE TABLE `t_account` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(255) NOT NULL, `password_ciper` VARCHAR(255) NOT NULL DEFAULT '1', PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; java实体类 @Data @AllArgsConstructor @NoArgsConstructor @Builder @EncryptDecryptClass public class Account implements Serializable { private static final long serialVersionUID = -8114863398578320034L; private Integer id; private String username; @EncryptDecryptField private String passwordCiper; } 对应的mapper接口以及xml package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e941b7c89045cf8dbf10758a9346af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0254c2b4eae41db2eedaee1d5ea64a37/" rel="bookmark">
			Linux文件系统——文件系统、挂载点、目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目录结构
1.1 基本介绍
1.2 详细说明目录作用
二、挂载点
一、目录结构
1.1 基本介绍
Linux是一切皆文件，将所用的东西当做文件处理
目录结构就是一个单一的树状结构
整个的目录树只有一个树根：/ 根目录
文件夹分门别类的放到根目录下面，看起来就是根目录文件夹的类别了，每个树枝对应一个文件夹
树枝还可以分支（也就是层层嵌套，形成层级式目录结构）
每个文件一级一级的往上返，都会追随到根目录
Linux路径是用正斜杠划分的（Windows系统中是反斜杠，但是我们底层时通常用反斜杠进行转义字符的表示，Windows中的路径转译教麻烦，Linux直接使用正斜杠）
上面的文件在Linux中就是下图的样子
我们仔细看下图中有一个小小的波浪线，这个波浪线就代表着用户的主录目（如果后面是#就代表着root用户的主目录）
我们也可以解释一下下面，atguigu表示我们当前是atguigu用户，Hadoop100是我们创建当前及其的时候给的主机名， ~ 代表所在的位置，#或/号代表着输入命令的提示符号，root用户是#，普通用户是$
那怎么切换到根目录？如下图所示，切换过来了
1.2 详细说明目录作用
根目录下都是一些通用的目录名称，每一个目录对应一个常见的功能
/bin 是Binary（二进制）的缩写,这个目录存放着最经常使用的命令 我们发现bin目录和其他的三个目录都和其他的不太一下，右下角有一个箭头
这个箭头代表着这个文件夹不是直接放在当前的根目录下面的 ，而是以链接的形式，实际指向的是usr/bin，也就是说usr/bin文件下的内容和下面文件夹下的bin的内容是一模一样的
/sbin s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序 /lib 统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。
/lab64 64位相关的比较特殊的一些文件
/home 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。不会有root管理员用户的文件夹
/root 该目录为系统管理员，也称作超级权限者的用户主目录
/usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。
/lost+found 当系统非法关机后，这里就存放了一些文件这个目录一般情况下是空的
/etc 所有的系统管理所需要的配置文件和子目录
/boot 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里。
/proc 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
Isrv service缩写，该目录存放一些服务启动之后需要提取的数据
/sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs
/tmp 这个目录是用来存放一些临时文件的
/dev 类似于windows的设备管理器，把所有的硬件用文件的形式存储.
/media(CentOS6)
linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后linux会把识别的设备挂载到这个目录下
CentOS7迁移到 /run/media
/mnt
系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。
/opt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0254c2b4eae41db2eedaee1d5ea64a37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be2ec5570173d9d483080295c14349f/" rel="bookmark">
			NotePad&#43;&#43; 配置Python运行环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言： 由于Pycharm，Vscode等IDE的启动速度太慢了，其实还是因为本人电脑台烂了，生产力不太行，所以最近尝试了很的编辑器，于是就看中了隔壁的NotePad++，体验效果不错，语法高亮；字词自动完成功能；支持同时编辑多重文档；支持自定义语言；支持多种编程语言。NotePad++和EditPlus，Sublime Text差不多，软件小，运行快，十分轻便，代码写起来很舒服。上次写了用Visual Studio Code配置Python的运行环境Blog，接下来讲一下NotePad++的相关操作… 二. 安装NotePad++ 首先需要下载该应用，通常我们会去官网下载，但有时候官网可能会加载不进去，于是可以选择渠道下载，推荐官方下载。 官网链接：https://notepad-plus-plus.org/downloads/项目链接：https://github.com/notepad-plus-plus/notepad-plus-plus/渠道链接：https://www.onlinedown.net/soft/10031411.html 安装向导全部按默认下一步，有必要的话可以更改安装路径和创建软件的桌面快捷键图标。 三.配置Python运行环境 要想在IDE中写运行代码，前提是需要安装解释器，其实在像Notepad++这样的编辑器中本质并不是有这么一个运行环境，只不过是写完在外部调出终端运行程序罢了。这就先跳过…
选择菜单栏的 &gt; 运行 &gt; 运行。或者按快捷键F5打开运行。
在‘运行程序名’内输入如下代码并保存，保存前会定义一个运行程序的快捷键，注意不能和其他快捷键重复。
若不知道哪些快捷键可用，可以通过菜单栏的 &gt; 运行 &gt; 管理快捷键 查看编辑器内已被定义的快捷键。
cmd /k cd "$(CURRENT_DIRECTORY)" &amp; python "$(FULL_CURRENT_PATH)" &amp; ECHO. &amp; PAUSE &amp; EXIT； 四.解释代码 关于以下这串代码什么意思这里解释一下： cmd /k cd "$(CURRENT_DIRECTORY)" &amp; python "$(FULL_CURRENT_PATH)" &amp; ECHO. &amp; PAUSE &amp; EXIT； cmd /k python ： 启动cmd命令提示符并运行/k后面的Python命令“$(FULL_CURRENT_PATH)” ： 当前文件的完整路径&amp; ： 用于连接过个命令的符号echo ： 换行pause ： cmd结束时暂停exit ： 设置cmd结束时按任意键关闭窗口… 五. 运行程序 一切准备就绪后就可以运行代码了，随便测试一段Python程序。通过自定的快捷键运行它，结果很成功…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1be2ec5570173d9d483080295c14349f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d08bff510243a18ae7205471d679b31/" rel="bookmark">
			抖音人气协议开发最新版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抖音协议开发是指开发者使用抖音提供的API接口，实现与抖音服务器的交互和数据传输。通过抖音协议开发，开发者可以获取抖音平台上的数据、推送内容和实现与抖音平台的交互等功能。
以下是抖音协议开发的具体步骤：
1. 申请开发者账号和应用程序：开发者需要在抖音开发者平台上注册账号，并创建应用程序，获取应用程序的App ID、App Secret和Access Token等信息。
2. 熟悉API接口文档：开发者需要熟悉抖音开发者平台提供的API接口文档，了解API接口的使用方法、请求参数和返回结果等信息。
3. 调用API接口：开发者通过HTTP协议向抖音服务器发送API请求，包括请求方法、请求参数和请求头等信息。抖音服务器会根据请求参数和请求头返回相应的数据结果。
4. 解析数据结果：开发者需要对抖音服务器返回的数据结果进行解析，解析成具体的数据格式，如JSON、XML等格式。
5. 处理错误和异常：在开发抖音协议时，会遇到各种错误和异常，开发者需要对这些错误和异常进行处理，如重试机制、异常捕获等。
6. 安全性考虑：在开发抖音协议时，需要考虑数据传输的安全性，如加密传输、防止中间人攻击等。
7. 测试和调试：在开发抖音协议时，需要进行测试和调试，确保开发的程序可以正常运行和与抖音服务器正常交互。
总之，抖音协议开发需要开发者熟悉API接口文档，调用API接口，解析数据结果，处理错误和异常，考虑安全性等方面，才能实现与抖音平台的交互和数据传输。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/71/">«</a>
	<span class="pagination__item pagination__item--current">72/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/73/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>