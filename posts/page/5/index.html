<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e3e0d73896a631b16c865ffb83be836/" rel="bookmark">
			element的Table表格组件树形数据与非懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.代码实现 &lt;template&gt; &lt;div&gt; &lt;el-row :gutter="10" class="mb8"&gt; &lt;el-col :span="1.5"&gt; &lt;el-button type="info" plain icon="el-icon-sort" size="mini" @click="toggleExpandAll"&gt;展开/折叠&lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-table v-if="refreshTable" :data="menuList" row-key="menuId" :default-expand-all="isExpandAll" :tree-props="{ children: 'children', hasChildren: 'hasChildren' }"&gt; &lt;el-table-column prop="menuName" label="名称" :show-overflow-tooltip="true" width="160"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="orderNum" label="排序" width="60"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="创建时间" align="center" prop="createTime"&gt; &lt;template slot-scope="scope"&gt; &lt;span&gt;{{ (scope.row.createTime) }}&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label="操作" align="center" fixed="right" min-width="220"&gt; &lt;template slot-scope="scope"&gt; &lt;el-button size="mini" type="primary" @click="clickHandle(scope.row)"&gt;查看&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "TablePage2", data() { return { // 菜单表格树数据 menuList: [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e3e0d73896a631b16c865ffb83be836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b68803f0abdcd8995c5ca4e134acbb/" rel="bookmark">
			Pytest fixture 及 conftest详解！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 fixture是在测试函数运行前后，由pytest执行的外壳函数。fixture中的代码可以定制，满足多变的测试需求，包括定义传入测试中的数据集、配置测试前系统的初始状态、为批量测试提供数据源等等。fixture是pytest的精髓所在，类似unittest中setup/teardown，但是比它们要强大、灵活很多，它的优势是可以跨文件共享。
一、Pytest fixture 1.pytest fixture几个关键特性 有独立的命名，并通过声明它们从测试函数、模块、类或整个项目中的使用来激活按模块化的方式实现，每个fixture都可以互相调用fixture可以实现unittest不能实现的功能，比如unittest中的测试用例和测试用例之间是无法传递参数和数据的，但是fixture却可以解决这个问题fixture的范围从简单的单元扩展到复杂的功能测试，允许根据配置和组件选项对fixture和测试用例进行参数化 2.Pytest fixture定义 定义fixture跟定义普通函数差不多，唯一区别就是在函数上加个装饰器@pytest.fixture()，fixture命名不要用test_开头，跟用例区分开。用例才是test_开头的命名；fixture装饰器里的scope有四个级别的参数：function（不写默认这个）、class、module、session；fixture可以有返回值，如果没有return，默认会是None；用例调用fixture的返回值，就是直接把fixture的函数名称作为参数传入；fixture可以返回一个元组、列表或字典；测试用例可传单个、多个fixture参数；fixture与fixture间可相互调用； 3.Pytest fixture用法 1）用法一：作为参数使用 fixture的名字直接作为测试用例的参数，用例调用fixture的返回值，直接将fixture的函数名称当做变量名称；如果用例需要用到多个fixture的返回数据，fixture也可以返回一个元祖，list或字典，然后从里面取出对应数据。
① 将fixture函数作为参数传递给测试 @pytest.fixture() def login(): print("this is login fixture") user = "chen" pwd = 123456 return user, pwd def test_login(login): """将fixture修饰的login函数作为参数传递给本用例""" print(login) assert login[0] == "chen" assert login[1] == 123456 assert "chen" in str(login) ② 同一个用例中传入多个fixture函数 @pytest.fixture() def user(): user = "cris" return user @pytest.fixture() def pwd(): pwd = "123456" return pwd def test_trans_fixture(user, pwd): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6b68803f0abdcd8995c5ca4e134acbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da2107fc1c9810177ce34570744e171/" rel="bookmark">
			CSS基础笔记-01CSS概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言CSS是什么CSS的作用CSS语法添加CSS的方法 前言 CSS是什么？有什么作用？怎么编写CSS？怎样添加CSS？本文对CSS的四个方面作了学习并形成学习笔记。
CSS是什么 CSS （Cascading Style Sheets，层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。
CSS的作用 我们知道HTML 是最常见的标记语言，html文档是由该语言组织起来的文本文件。
CSS就是配合html，用于设计文档的风格和布局等。
例如：
添加样式， 比如改变标题和链接的颜色及大小。创建布局， 比如将一个单列文本变成包含主要内容区域和存放相关信息的侧边栏区域的布局。特效，比如动画。 CSS语法 CSS 是一门基于规则(rule)的语言，你能定义用于你的网页中特定元素样式的一组规则。
/* syntax */ selector{ property: value; } 语法由一个 选择器（selector）起头，它选择了我们将要用来添加样式的 HTML 元素。在这个例子中我们为一级标题（主标题&lt;h1&gt;）添加样式。
接着输入一对大括号 { }。在大括号内部定义一个或多个形式为属性（property）—值（value）对的声明。每个声明都指定了我们所选择元素的一个属性，后面再跟一个我们想赋给这个属性的值。
冒号之前是属性，冒号之后是值。不同的 CSS 属性对应不同的合法值。
比如“我希望页面中的主标题是红色的大字”。
h1 { color: red; font-size: 5em; } 在这个例子中，我们指定了 color 属性，它可以接受许多颜色值；还有 font-size 属性，它可以接收许多 size unit 值。
一个 CSS 样式表可以包含很多个规则。
h1 { color: red; font-size: 5em; } p { color: black; } 添加CSS的方法 最通用的在html文档中加入CSS样式的方法是在html的head标签中链接css文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8da2107fc1c9810177ce34570744e171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478feddd9c11236523069deaad291798/" rel="bookmark">
			DNs服务学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS：域名系统（英文：Domain Name
System)是一个域名系统，是万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。类似于生活中的114服务，可以通过人名找到电话号码，也可以通过电话号码找到人名(生活中没有那么准确的原因是人名有重名，而域名是全世界唯一的)。
DNS协议运行在UDP协议之上，使用端口号53
域名: 域名是一个网站的逻辑地址，比如www.zutuanxue.com，相比IP地址更加方便人类记忆，所以被广泛使用。 一、DNS介绍 计算机的发展起源于上世纪60年代，最初只有美国的几所高校在使用，计算机之间通信需要知道对方的地址(IP地址)，但是人们对IP地址的记忆又是不敏感的(就像生活中你能记住多少个好友的手机号码一样)。为了方便人类记忆，大学的科学家们把计算机的名字和对应的IP地址写入到计算机中的hosts文件，以此文件来做解析。
但是随着计算机和网络的发展出现了局域网，计算机的数量随之增加；后来为了解决方便通信问题，我们使用了wins服务器来进行计算机名和IP的注册服务，通过一个名称服务器来自动管理局域网中的计算机，并提供解析服务。人们在局域网中通过计算机名就能连接到了对应的计算机。该技术中要求计算机名称必须唯一，正是由于这个原因使得局域网中的计算机又不能太多。
微型计算机的出现和局域网的发展推动了广域网的发展，hosts文件只能针对极少的计算机网络，wins可以管理局域网的解析。到了广域网，人们就迫切需要一个新的服务做解析服务器，使解析方便、快速、高效的应对广域网环境。为了解决广域网解析问题，美国人研发出了DNS服务，以及成立了管理DNS相关的机构，并提出了域名命名规则。
域名管理机构 Internet 域名与地址管理机构（ICANN）是为承担域名系统管理，IP地址分配，协议参数配置，以及主服务器系统管理等职能而设立的非盈利机构. 现由IANA和其他实体与美国政府约定进行管理。 域名分国际域名和国内域名两种，对于国际域名而言，其命名规则是： 域名可以由（a-z、A-Z大小写等价）26个英文字母、数字（0-9）以及连接符“-”组成，但是域名的首位必须是字母或数字。对于域名的长度也有一定 的限制：国际通用顶级域名长度不得超过26个字符，中国国家顶级域名长度不得超过20个字符 二、DNS的解析原理 目前，因特网的命名方法是层次树状结构的方法。采用这种命名方法，任何一个连接在因特网上的主机或设备，都有一个某一的层次结构的名字，即域名(domain name)。域是名字空间中一个可被管理的划分。域可以继续按层次划分为子域，如二级域、三级域等等。
三、DNS查询 递归查询:一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后,若DNS服务器本身不能解析,则会向另外的DNS服务器发出查询请求，得到结果后转交给客户机；如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那本地 DNS就会扮演DNS客户的角色，去代理原客户去帮忙找根域名服务器发出请求，递归即递给服务器，所有操作都有服务器来完成。
迭代查询:一般DNS服务器之间属迭代查询，如：DNS1问DNS2,DNS2不知道会告诉DNS1一个DNS3的IP地址，让DNS1去问问DNS3知不知道，以此类推，就是迭代查询。
关于递归和迭代举个生活例子帮助大家理解：比如你问张老师一个问题，张老师告诉他答案这之间的叫递归查询。这期间也许张老师也不会，这时张老师问李老师，张老师去问崔老师，这之间的查询叫迭代查询！
正向查找：将域名解析为IP
www.zutuanxue.com ---&gt; 118.190.209.153 反向查找：将IP解析为域名
118.290.209.153 ---&gt; www.zutuanxue.com 四、DNS服务器部署 约定：本实验中使用过的机器为centos8.0_x86_64系统，IP地址192.168.11.16/24.请关闭防火墙和SELINUX。
4.1）DNS安装 DNS服务是由bind程序提供的，所以要实现DNS服务就需要安装bind程序包。
[root@zutuanxue ~]# dnf -y install bind bind-chroot bind DNS主程序包 bind-chroot DNS安全包，改变默认DNS根目录，将DNS运行在监牢模式 说明:chroot监牢模式 监牢是一个软件机制，其功能是使得某个程序无法访问规定区域之外的资源，同样也为了增强安全性（LCTT 译注：chroot “监牢”，所谓“监牢”就是指通过chroot机制来更改某个进程所能看到的根目录，即将某进程限制在指定目录中，保证该进程只能对该目录及其子目录的文件进行操作，从而保证整个服务器的安全）。Bind Chroot DNS 服务器的默认“监牢”为 /var/named/chroot。 4.2）DNS启动 DNS的守护进程叫做named,DNS是以named用户身份来运行，named用户在安装包的时候会在系统中自动创建。
CentOS8下安装了bind-chroot之后，若要使用named-chroot.service，则需要关闭named.service。两者只能运行一个 方法一: 不使用chroot模式启动DNS 开启开机启动 [root@zutuanxue ~]# systemctl enable named Created symlink from /etc/systemd/system/multi-user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/478feddd9c11236523069deaad291798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa05ee2d83a8045fcf1d15c34c72985/" rel="bookmark">
			互联网加竞赛 基于YOLO实现的口罩佩戴检测 - python opemcv 深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题介绍2 算法原理2.1 算法简介2.2 网络架构 3 关键代码4 数据集4.1 安装4.2 打开4.3 选择yolo标注格式4.4 打标签4.5 保存 5 训练6 实现效果6.1 pyqt实现简单GUI6.3 视频识别效果6.4 摄像头实时识别 7 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 **基于YOLO实现的口罩佩戴检测 **
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题介绍 受全球新冠肺炎疫情影响，虽然目前中国疫情防控取 得了良好效果，绝大多数地区处于疫情低风险，但个别地 区仍有零星散发病例和局部聚集性疫情。在机场、地 铁
站、医院等公共服务和重点机构场所规定必须佩戴口罩， 口罩佩戴检查已成为疫情防控的必备操作。目前，口罩 佩戴检查多为人工检查方式，如高铁上会有乘务人员一节
节车厢巡逻检查提醒乘客佩戴口罩，在医院等高危场所也 会有医务人员提醒时刻戴好口罩。人工检查方式存在检 查效率低下、难以及时发现错误佩戴口罩以及未佩戴口罩
行为等弊端。采用深度学习目标检测方法设计一个具有口罩识别功能的防疫系统，可以大大提高检测效率。
2 算法原理 2.1 算法简介 YOLOv5是一种单阶段目标检测算法，该算法在YOLOv4的基础上添加了一些新的改进思路，使其速度与精度都得到了极大的性能提升。主要的改进思路如下所示：
输入端：在模型训练阶段，提出了一些改进思路，主要包括Mosaic数据增强、自适应锚框计算、自适应图片缩放；
基准网络：融合其它检测算法中的一些新思路，主要包括：Focus结构与CSP结构；
Neck网络：目标检测网络在BackBone与最后的Head输出层之间往往会插入一些层，Yolov5中添加了FPN+PAN结构；
Head输出层：输出层的锚框机制与YOLOv4相同，主要改进的是训练时的损失函数GIOU_Loss，以及预测框筛选的DIOU_nms。
2.2 网络架构 上图展示了YOLOv5目标检测算法的整体框图。对于一个目标检测算法而言，我们通常可以将其划分为4个通用的模块，具体包括：输入端、基准网络、Neck网络与Head输出端，对应于上图中的4个红色模块。YOLOv5算法具有4个版本，具体包括：YOLOv5s、YOLOv5m、YOLOv5l、YOLOv5x四种，本文重点讲解YOLOv5s，其它的版本都在该版本的基础上对网络进行加深与加宽。
输入端-输入端表示输入的图片。该网络的输入图像大小为608*608，该阶段通常包含一个图像预处理阶段，即将输入图像缩放到网络的输入大小，并进行归一化等操作。在网络训练阶段，YOLOv5使用Mosaic数据增强操作提升模型的训练速度和网络的精度；并提出了一种自适应锚框计算与自适应图片缩放方法。基准网络-基准网络通常是一些性能优异的分类器种的网络，该模块用来提取一些通用的特征表示。YOLOv5中不仅使用了CSPDarknet53结构，而且使用了Focus结构作为基准网络。Neck网络-Neck网络通常位于基准网络和头网络的中间位置，利用它可以进一步提升特征的多样性及鲁棒性。虽然YOLOv5同样用到了SPP模块、FPN+PAN模块，但是实现的细节有些不同。Head输出端-Head用来完成目标检测结果的输出。针对不同的检测算法，输出端的分支个数不尽相同，通常包含一个分类分支和一个回归分支。YOLOv4利用GIOU_Loss来代替Smooth L1 Loss函数，从而进一步提升算法的检测精度。 3 关键代码 ​
class Detect(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaa05ee2d83a8045fcf1d15c34c72985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b8f755519e00989319153a04027466/" rel="bookmark">
			Python爬取天气数据及可视化分析！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天气预报我们每天都会关注，我们可以根据未来的天气增减衣物、安排出行，每天的气温、风速风向、相对湿度、空气质量等成为关注的焦点。
本次使用python中requests和BeautifulSoup库对中国天气网当天和未来14天的数据进行爬取，保存为csv文件，之后用matplotlib、numpy、pandas对数据进行可视化处理和分析，得到温湿度度变化曲线、空气质量图、风向雷达图等结果，为获得未来天气信息提供了有效方法。
1、数据获取
请求网站链接
首先查看中国天气网的网址：http://www.weather.com.cn/weather/101280701.shtml这里就访问本地的天气网址，如果想爬取不同的地区只需修改最后的101280701地区编号即可，前面的weather代表是7天的网页，weather1d代表当天，weather15d代表未来14天。这里就主要访问7天和14天的中国天气网。
采用requests.get()方法，请求网页，如果成功访问，则得到的是网页的所有字符串文本。这就是请求过程。
def getHTMLtext(url): """请求获得网页内容""" try: r = requests.get(url, timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding print("成功访问") return r.text except: print("访问错误") return" " 提取有用信息
这里采用BeautifulSoup库对刚刚获取的字符串进行数据提取，首先对网页进行检查，找到需要获取数据的标签：
可以发现7天的数据信息在div标签中并且id=“7d”，并且日期、天气、温度、风级等信息都在ul和li标签中，所以我们可以使用BeautifulSoup对获取的网页文本进行查找div标签id=“7d”，找出他包含的所有的ul和li标签，之后提取标签中相应的数据值，保存到对应列表中。
这里要注意一个细节就是有时日期没有最高气温，对于没有数据的情况要进行判断和处理。另外对于一些数据保存的格式也要提前进行处理，比如温度后面的摄氏度符号，日期数字的提取，和风级文字的提取，这需要用到字符查找及字符串切片处理。
def get_content(html): """处理得到有用信息保存数据文件""" final = [] # 初始化一个列表保存数据 bs = BeautifulSoup(html, "html.parser") # 创建BeautifulSoup对象 body = bs.body data = body.find('div', {'id': '7d'}) # 找到div标签且id = 7d 下面爬取当天的数据
data2 = body.find_all('div',{'class':'left-div'}) text = data2[2].find('script').string text = text[text.index('=')+1 :-2] # 移除改var data=将其变为json数据 jd = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b8f755519e00989319153a04027466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de572f5390d25d01a9de7d230e15d603/" rel="bookmark">
			HTTP网络相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@1 第一步：
URI(统一资源标识符)= URL（统一资源定位符）+URN（统一资源名称）；
@2 传输协议：
HTTP: 超文本传输协议
HTTPS: HTTP + SSL（加密证书）相对于http传输会更加安全
FTP: 文件的传输 上传工具 资源共享 域名：域名是外网IP一个标识，相对于IP来说牢记比较困难，域名会更加便捷。
端口号：0-65535，每个端口号对应统一服务器 中不用的项目，默认http:80, https:443.
编码问题，如果url对应参数存在中文特殊字符等，传递的时候会解析出错，这时候需要编码
encodeURL / decodeURL ; (适合解析url所有的)， encodeURLComponent / decodeURLComponent ; 适合解析url特殊字符中的
@3 强缓存与协商缓存
强缓存：
http/1.1 Cache-Control max-age = 259200 http/1.0 Exprices Sun, 15 May 2022 20:14:22 存在问题， 如果本地有缓存， 然而服务器更新了资源如何保障客户端获取最新的？
这个时候我们可以把 css js 最缓存，但是不能对 html 页面 做缓存。因为html页面是渲染的入
口，其他资源在渲染解析HTML的时候再去请求的。
协商缓存: 哪怕本地有缓存也要和服务器进行协商
第一次请求页面，本地没有缓存，向服务器发送请求，如果需要设置协商缓存，在响应头返
回相对应的字段。【last-modified 记录资源最后一次更新的时候】【Etag 记录资源最后一次
更新的标识】，客户端浏览器看到标识，会把标识和资源全部做缓存。
第二次向服务器发送请求的时候也是会重新发送的，会把协商缓存存储的标识和资源通过
【if-modified-since/if-None-math】传递给服务器，服务器如果返回的304则说明资源没有更
新，从本地缓存中获取就可以了。 如果资源更新了，则返回200，使用服务器新的资源，同
时把最新的资源缓存起来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de572f5390d25d01a9de7d230e15d603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c595c02744f58a03047dc83593caec2e/" rel="bookmark">
			【React系列】ES6学习笔记（四）module、编程风格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考自电子书《ECMAScript 6 入门》：https://es6.ruanyifeng.com/
Module 的语法 1. 概述 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。
在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
// CommonJS模块 let { stat, exists, readfile } = require('fs'); // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c595c02744f58a03047dc83593caec2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb58c2b99edd57eb294d7a59fbfbb920/" rel="bookmark">
			k8s---容器探针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apiVersion: v1 kind: Pod metadata: labels: run: nginx2 name: nginx2 spec: containers: - image: centos:7 name: nginx2 command: ["/bin/bash","-c","sleep 3600"] readinessProbe: exec: command: ["/usr/bin/test","-e","/etc/passwd"] initialDelaySeconds: 4 periodSeconds: 2 因为-c是查看字符串，但/usr/bin/test和/etc/passwd是文件，所以readinessProbe探针探测不到
改成-e即可
apiVersion: v1 kind: Pod metadata: labels: run: nginx1 name: nginx1 spec: containers: - image: tomcat:8.0.52 name: nginx1 readinessProbe: httpGet: scheme: HTTP port: 8080 path: /index.jsp initialDelaySeconds: 4 periodSeconds: 2 readinessProbe
就绪探针，pod的状态是running ,ready是notready
存活探针和就绪探针会伴随整个容器的生命周期 启动探针 apiVersion: v1 kind: Pod metadata: labels: run: nginx1 name: nginx1 spec: containers: - image: tomcat:8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb58c2b99edd57eb294d7a59fbfbb920/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c83cd75de882f368167735743886f8/" rel="bookmark">
			【React系列】ES6学习笔记（一）let与const、解构赋值、函数参数默认值\rest参数\箭头函数、数组和对象的扩展、Set和Map等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考自电子书《ECMAScript 6 入门》：https://es6.ruanyifeng.com/
let 和 const 命令 1. let 命令 尽量使用 let 声明变量，而不是 var。let 声明的变量是块级作用域， var 声明的变量是全局作用域。使用 let 变量必须先声明再使用，否则报错，不存在变量提升。相对的 var 声明的变量如果提前使用，不会报错，只会提示为undefined。let不允许在相同作用域内，重复声明同一个变量。ES6的块级作用域允许使用多层 {} 无限嵌套，只有位于同一层的 let 变量相互影响，跨层之间的 let 变量即便是同名也无影响，只要在同一层内使用自己层的变量即可。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。（if语句后面最好必须跟上大括号） 2. const 命令 const声明一个只读的常量。一旦声明，常量的值就不能改变。必须在声明时指定初始值。const的作用域与let命令相同：只在声明所在的块级作用域内有效。同样不存在变量提升，必须先声明后使用，不可重复声明。 ES6 声明变量的六种方法
ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。
变量的解构赋值 1. 数组的解构赋值 let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。
本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。
let [foo, [[bar], baz]] = [1, [[2], 3]]; foo // 1 bar // 2 baz // 3 let [ , , third] = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2c83cd75de882f368167735743886f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6a15704f726db970de47fda4980483/" rel="bookmark">
			antd的动态表单配置默认拥有一个或几个，第一个是否可以删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		antd官方示例里面有这样的组件，直接使用Form.List来实现了，只需要配置一个规则就可以了，但是配置的时候，它官方示例里面都是默认没有内容的，需要手动再另外添加一个结果，所以就想在初始化的时候，就配置拥有一个，并且第一个还不能删除：
要想初始化的时候就有一个，可以配置Form.List的配置项：initialValue
比如将其配置为：initialValue={[1]} ，那么初始化的时候，就会拥有一个表单域。
如果想配置第一个表单域不能删除，就可以在 删除的地方做个判断，是不是第一个：
在map遍历的时候，添加一个索引，通过判断这个索引是不是第0个，然后是否展示关闭按钮
表单域逻辑代码：
&lt;Form.List name="items" key={1} initialValue={[1]}&gt; {(fields = [], { add, remove }) =&gt; ( &lt;div style={{ display: 'flex', rowGap: 16, flexDirection: 'column', justifyContent: 'center', }} &gt; {fields.map((field, index) =&gt; ( &lt;Card size="small" title={`价格规则${field.name + 1}`} key={field.key} extra={ index !== 0 ? ( &lt;CloseOutlined onClick={() =&gt; { remove(field.name) }} /&gt; ) : null } &gt; &lt;Form.Item label="整场价格" name={[field.name, 'name']} &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae6a15704f726db970de47fda4980483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ea2ca75638486699e692371490be6c/" rel="bookmark">
			【dfs】 2397. 被列覆盖的最多行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/?envType=daily-question&amp;envId=2024-01-04
class Solution { public: // 将Mat 第cur 列设为0 void processMat(vector&lt;vector&lt;int&gt;&gt; &amp;mat, int cur) { for (int i = 0; i &lt; mat.size(); i++) { mat[i][cur] = 0; } } // 得到最大的全零行数 int getMaxRows(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int res = 0; for (auto row : mat) { int flag = 0; for(auto ele : row) { flag |= ele; if (flag) break; } if (flag == 0) res++; } return res; } int res = 0; void dfs(vector&lt;vector&lt;int&gt;&gt; mat, int cur, int coveredRows, int numSelect) { // if () return; // cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ea2ca75638486699e692371490be6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b462f2b231539b604291f0b80bfd8526/" rel="bookmark">
			内网穿透的应用-使用Docker本地部署可编辑导航页结合内网穿透实现远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 使用Docker搜索镜像2. 下载镜像3. 查看镜像4. 启动容器5. 浏览器访问6. 远程访问6.1 内网穿透工具安装6.2 创建远程连接公网地址6.3 使用固定二级子域名地址远程访问 今天和大家分享如何使用Docker本地部署一个开源的简约风格网址导航页，支持五种搜索引擎，可以自由增删改网站，拖动调整网站顺序。另外还支持响应式布局、主题切换、夜间模式，可以导入或导出数据来在不同设备之间同步数据，结合cpolar内网穿透工具还能实现分享给好友远程使用，下面就来看看如何部署吧！
1. 使用Docker搜索镜像 本例中使用的是Ubuntu系统，输入下方命令：
sudo docker search luode0320/web-start 显示如下图所示结果
2. 下载镜像 输入命令：
sudo docker pull luode0320/web-start 显示如下图所示结果
3. 查看镜像 输入命令：
sudo docker images 可以看到镜像已经下载好了
4. 启动容器 输入命令：
sudo docker run --restart=always --name web -d -p 2000:2000 luode0320/web-start:latest 5. 浏览器访问 在任意浏览器输入本机ip加端口号即可，本例使用地址为 127.0.0.1:2000
6. 远程访问 这个时候我们已经成功使用Docker在本地部署了这个简洁的导航页，如果想要分享给你的好友使用，那么可以使用cpolar内网穿透工具实现公网远程访问需求。
安装好内网穿透工具后，使用它来创建公网地址即可分享给他人进行远程访问。
6.1 内网穿透工具安装 下面是安装cpolar步骤：
cpolar官网地址: https://www.cpolar.com
使用一键脚本安装命令 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar cpolar安装成功后，在外部浏览器上访问Linux 的9200端口即:【http://服务器的局域网ip:9200】，使用cpolar账号登录,登录后即可看到cpolar web 配置界面,结下来在web 管理界面配置即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b462f2b231539b604291f0b80bfd8526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aedb090975ae61b6f5684cf8a2f84c5/" rel="bookmark">
			【LeetCode每日一题】1944. 队列中可以看到的人数（单调栈）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024-1-5
文章目录 [1944. 队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/)思路： 1944. 队列中可以看到的人数 思路： 1.采用单调栈，从最后一个高度开始，从后往前进行遍历
2.用一个循环，先解决比当前低的身高
3.因为栈不为空且栈顶比现在身高低，当前身高把栈顶身高挡住了，栈顶无法影响后续，弹出，记录看到的低栈顶
4.当前栈不为空，并且之前已经排除了比当前栈顶元素低的，所以当前栈顶元素比当前身高要高，记录看到的这个高的
5.每次循环，都对当前身高进行压栈，用来更新栈顶元素。
//1944. 队列中可以看到的人数---单调栈 public int[] canSeePersonsCount(int[] heights) { int n = heights.length; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); int[]answer = new int[n]; for (int i = n-1; i &gt;=0 ; i--) { //int h = heights[i]; while (!stack.isEmpty()&amp;&amp;stack.peek()&lt;heights[i]){// //栈不为空且当前高度大于栈顶元素 stack.pop(); //当前高度把栈顶挡住了，栈顶出栈，看栈中的下一个元素 answer[i]++; //看到了一个比当前低的，加1 } if (!stack.isEmpty()){ //栈不为空，当前高度小于栈顶元素 answer[i]++; //只能看到栈顶，能看见一个比当前高的，加1 } stack.push(heights[i]); //当前高度压栈 } return answer; } 点击移步博客主页，欢迎光临~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f82fcc3a020f94f9fc79342480b2ca/" rel="bookmark">
			Java 8的Stream API分组。将List＜Map＜String, String＞＞集合分组，分组条件为动态集合List＜String＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一个集合：
{ "condition": [ "key3774","key3770" ], "body": [ { "key3779": "44406107.75", "key3778": "-49468430.57", "key3774": "一二三航", "key3770": "SHY", "key": "1742796948097728512" }, { "key3782": "634", "key3775": "634", "key3774": "一二三航", "key3770": "SHY", "key": "1742796948097728513" }, { "key3779": "971864954.96", "key3778": "-98854650.65", "key3774": "上航", "key3770": "SHK", "key": "1742796948097728514" }, { "key3782": "3921", "key3775": "3921", "key3774": "上航", "key3770": "SHK", "key": "1742796948097728515" } ] } 将该集合中的body，根据分组条件condition进行分组，后再聚合。
最终变为如下集合：
{ "condition": [ "key3774","key3770" ], "body": [ { "key3779": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f82fcc3a020f94f9fc79342480b2ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64440969b417e7187dc70208c4b757a3/" rel="bookmark">
			Intelrealsense D435i关闭结构光
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		roscore roslaunch realsense2_camera rs_camera.launch rosrun rqt_reconfigure rqt_reconfigure 把emitter_enabled设置成off
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b9998cd015839063b602010497cec1/" rel="bookmark">
			element中Tree 树形控件实现多选、展开折叠、全选全不选、父子联动、默认展开、默认选中、默认禁用、自定义节点内容、可拖拽节点、手风琴模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.代码实现2. 效果图3. 使用到的部分属性说明4. 更多属性配置查看element官网 1.代码实现 &lt;template&gt; &lt;div class="TreePage"&gt; &lt;el-checkbox v-model="menuExpand" @change="handleCheckedTreeExpand($event, 'menu')" &gt;展开/折叠&lt;/el-checkbox &gt; &lt;el-checkbox v-model="menuNodeAll" @change="handleCheckedTreeNodeAll($event, 'menu')" &gt;全选/全不选&lt;/el-checkbox &gt; &lt;el-checkbox v-model="menuCheckStrictly" @change="handleCheckedTreeConnect($event, 'menu')" &gt;父子联动&lt;/el-checkbox &gt; &lt;el-row :gutter="20" style="margin-top: 20px"&gt; &lt;!--村数据--&gt; &lt;el-col :span="24"&gt; &lt;div class="head-container"&gt; &lt;el-input v-model="deptName" placeholder="请输入名称" clearable size="small" prefix-icon="el-icon-search" style="margin-bottom: 20px" /&gt; &lt;/div&gt; &lt;!-- 组织树 --&gt; &lt;div class="head-container"&gt; &lt;el-tree ref="menu" :props="defaultProps" :default-expanded-keys="defaultExpandedKeys" :default-checked-keys="defaultCheckedKeys" :expand-on-click-node="false" :data="menuOptions" show-checkbox node-key="deptId" :check-strictly="!menuCheckStrictly" empty-text="加载中，请稍后" :filter-node-method="filterNode" @node-click="handleNodeClick" draggable @node-drag-start="handleDragStart" @node-drag-enter="handleDragEnter" @node-drag-leave="handleDragLeave" @node-drag-over="handleDragOver" @node-drag-end="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b9998cd015839063b602010497cec1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423d3da9b5d9bd1212500865c35a083f/" rel="bookmark">
			深度解析Webpack：现代前端工程化的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
前端工程化是当今前端开发的不可或缺的一部分，而Webpack作为其中的瑞士军刀，在项目构建和优化中扮演着至关重要的角色。本文将深度解析Webpack，从基础概念到实际应用，为前端开发者提供全面的学习指南，帮助他们充分发挥Webpack在现代前端工程化中的威力。
主要内容：
Webpack基础概念的深度剖析：
解释Webpack是什么，为什么它如此重要。深入探讨Entry、Output、Loaders、Plugins等核心概念的作用和原理。 Webpack配置的艺术：
详细介绍Webpack的配置文件，包括各种选项的用途和配置方式。提供高级配置示例，如多环境配置、优化策略等。 加载器与插件的全面解读：
深入了解常用加载器（Babel、CSS加载器等）的原理和用法。分析常见插件（HtmlWebpackPlugin、CleanWebpackPlugin等）的实际应用场景和效果。 性能优化与调试技巧：
探讨Webpack中的性能优化策略，如代码分割、懒加载等。提供调试Webpack配置的实用技巧，帮助开发者更高效地排查问题。 实际项目中的Webpack应用：
提供一个真实项目的Webpack配置案例，从项目初始化到生产构建，详细展示每个步骤的配置和原因。强调在实际项目中的最佳实践和注意事项。 结论：
总结Webpack在前端工程化中的作用和价值，鼓励开发者深入学习和理解Webpack，从而更好地应对复杂的前端项目和不断变化的技术栈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5932ae3bfcc3210b541b70cadf2c600/" rel="bookmark">
			kaill靶场vulhub安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		换源：sudo vim /etc/apt/sources.list
deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
当我们在执行 sudo vim /etc/apt/sources.list 提示需要输入密码
每次sudo 执行的时候需要提示输入密码，比较麻烦
我们可以在vim /etc/sudoers #tanttrt账户 执行 sudo命令的时候可以免密输入
tanttrt ALL=(ALL) NOPASSWD: ALL 接下来执行操作该博主即可
kali中vulhub靶场搭建详细教程_vul靶场-CSDN博客
在安装pip install docker-compose后出现部分服务无法正常启动的现象
加上sudo 命令后问题解决
最后成功安装vulhub靶场
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ff20be52dc98cdf6008c9b3f0ef94c/" rel="bookmark">
			Redis面试题3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 过期键的删除策略是什么？有什么优缺点？
Redis 采用了惰性删除和定期删除相结合的策略来删除过期键。
惰性删除：在查询时检查 Key 是否过期并删除；
定期删除：每隔一段时间扫描数据库删除过期键。
优点：采用两种方式互补，保证过期键及时删除；
缺点：可能导致过期键并没有及时删除。
Redis的持久化机制有几种，分别是什么？它们有什么区别？
Redis 的持久化机制包括 RDB 和 AOF 两种。
RDB 是将内存中的数据以快照的形式保存到磁盘中，适合用于备份和恢复数据。缺点是如果宕机，会有数据丢失。
AOF 是将每个写操作以日志的形式记录下来，并将日志追加到磁盘中的 AOF 文件中，适合用于数据持久化和避免宕机数据丢失。缺点是文件可能会很大。
Redis 如何实现分页查询？
Redis 中可以使用有序集合（Sorted Set）来实现分页查询。
可以使用 ZRANGE 命令获取指定区间之间的元素，将总记录数 / 每页显示记录数计算出总页数，并结合当前页数和每页显示记录数计算出需要查询的元素区间。
Redis 如何实现计数器？
Redis 中使用 INCR 和 INCRBY 命令可以实现基于 Key 的计数器。
在实现流量限制等场景时，可以结合 Redis 的过期机制实现计数器的时效性，适时地删除无用的计数器 Key。
Redis 与 MySQL 之间的区别是什么？
Redis 和 MySQL 都是数据存储系统，但 Redis 是基于内存的缓存系统，而 MySQL 是基于磁盘的关系型数据库。
Redis 适用于高速读写场景和缓存系统，MySQL 适用于需要复杂查询、事务以及高级数据处理的场景。
Redis 如何实现分布式锁？有没有什么问题需要考虑？
Redis 可以使用 SETNX（SET if Not eXists）指令实现分布式锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25ff20be52dc98cdf6008c9b3f0ef94c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f590c12f68af3af98fd4364a105a25/" rel="bookmark">
			python项目分享 基于Django的商品销售系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 前言 Hi，大家好，今天给大家介绍一个python管理系统，大家可以用于自己的课设或毕设！
今天要分享的是：毕业设计 基于Django的商品销售系统
项目分享：
https://gitee.com/sinonfin/system-sharing
1 设计说明 51商城项目分为网站前台和后台两个部分，下面将分别介绍这2个部分的使用。
网站前台
在虚拟环境中启动程序后，使用浏览器访问“http://127.0.0.1:5000”即可进入网站前台首页。如图1所示。
单击首页左上角“注册”按钮，进入注册页面，如图2所示。注册完成后，进入登录页面，如图3所示。
登录成功后，可以在首页选择商品，也可以通过顶部导航栏分类选择商品。选择商品时，可以将鼠标悬浮到商品图片处，此时会在图片右下角显示一个购物车按钮，如图4所示，单击购物车按钮，将商品加入购物车，如图6所示。
另外，还有一种添加商品到购物车的方法，即可以单击商品图片，进入到商品详情页，如图5所示。
在商品详情页，可以更改商品数量（默认为1），然后单击“添加到购物车”按钮，即可进入购物车页面，如图6所示。
在购物页面，需要填写物流信息，也可以清空购物车。单击“结账”按钮，即可进入支付宝扫码支付页面，如图7所示。
本项目为本地项目，不包含线上支付功能，单击“支付”按钮，则默认用户已经支付成功。单击网站右上方的 “我的订单”，可以查看用户订单，如图8所示。
此外，用户还可以在顶部搜索栏根据商品名称模糊查询商品，如图9所示。搜索结果如图10所示。
网站后台
后台管理账号： mr
后台管理员密码：mrsoft
在浏览器中输入网址”http://127.0.0.1:5000/admin/login/” 即可访问网站后台登录页。如图11所示。
登录成功后，进入后台首页，运行效果如图12所示。
单击顶部菜单的“大分类管理”和“小分类管理”，可以管理大分类和小分类。例如，“图书—&gt;管理”和“图书—&gt;小说”中，图书就是大分类，管理和小说都是该大分类下的小分类。图13和图14分别为大分类管理和小分类管理页面。
添加商品前，需要选择对应的大分类和小分类。此外，在添加图片文件时，需要添加商品的图片路径。现将图片拷贝到“app\static\images\goods”路径下，如图15所示。
然后，在添加商品表单的“图片文件”处填写图片的名称，如图16所示。
部分相关源码
# _*_ coding: utf-8 _*_ from flask_wtf import FlaskForm from wtforms import StringField, PasswordField, SubmitField, TextAreaField, RadioField,DecimalField,SelectField from wtforms.validators import DataRequired, ValidationError,Length from app.models import Admin class LoginForm(FlaskForm): """ 管理员登录表单 """ manager = StringField( label="管理员名", validators=[ DataRequired("管理员名不能为空") ], description="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f590c12f68af3af98fd4364a105a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7697fa5cfcdce56f0e829bcd783d08df/" rel="bookmark">
			零配置，零麻烦：MapStruct 的轻松对象映射之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的博客，代码的世界里，每一行都是一个故事 零配置，零麻烦：MapStruct 的轻松对象映射之旅 前言MapStruct是什么快速上手：基础映射高级映射技巧1. 针对复杂类型的映射：2. 自定义映射逻辑： MapStruct 的进阶用法1. 构造函数映射：2. 嵌套映射：3. 集合映射： 伪出错结语： 前言 你是否曾为繁琐的对象映射代码而感到头疼？MapStruct 登场了！它不仅是 Java 开发者的得力助手，更是一个能够消除样板代码的魔法师。在这篇博客中，我们将一同踏上 MapStruct 的奇妙之旅，解锁它的神奇技能，让你的代码更为简洁、高效。
MapStruct是什么 MapStruct 是一个用于 Java 编程语言的对象映射框架，它的主要目标是简化 Java bean 类型之间的映射过程。在软件开发中，经常需要将一个对象的数据映射到另一个对象，而 MapStruct 通过注解处理器的方式，根据开发者提供的映射规则自动生成映射代码，从而减少手动编写重复、繁琐的映射代码的工作。
MapStruct 的定位是提供一种高性能、可扩展、易用的对象映射解决方案。相比其他对象映射框架，MapStruct 有以下优势：
性能优越： 由于 MapStruct 生成的映射代码是静态的，在编译期间就已经生成，因此它的性能通常比运行时反射的映射框架更高效。
可读性和维护性： MapStruct 生成的映射代码相对清晰简洁，易于阅读和维护。生成的代码包含了开发者定义的映射规则，也支持自定义转换逻辑。
类型安全： MapStruct 在编译期间就能够检测到潜在的映射错误，提供了类型安全性，减少了在运行时可能发生的错误。
灵活性： 支持自定义转换器，开发者可以通过注解指定特定的映射规则，也可以手动编写转换器以满足特定需求。
总体而言，MapStruct 是一款强大的对象映射框架，适用于各种 Java 项目，尤其在需要处理大量对象映射的场景下，能够提高开发效率并保证映射代码的质量。
快速上手：基础映射 快速上手 MapStruct 的基础映射需要完成一些简单的步骤。以下是一个基本的示例，演示如何创建一个简单的映射。
假设有两个类 Source 和 Target，它们具有相似的字段，我们希望将一个对象映射到另一个对象。
引入 MapStruct 依赖：
在项目的 pom.xml 文件中，添加 MapStruct 的依赖：
&lt;dependencies&gt; &lt;!-- 其他依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7697fa5cfcdce56f0e829bcd783d08df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d81c0cd60486eacc3d72a25af8c8b4d/" rel="bookmark">
			什么是DNS解析？DNS解析的详细过程是什么样的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址和域名的关系
TCP/IP网络要求每一个互联的计算机都有一个唯一的IP地址，如39.162.20.48。IP地址是网络中每一台计算机的电子标识符，计算机通过IP地址与其他计算机进行定位和通信。但直接使用IP地址有很多不便之处，因为IP地址是由一串纯数字组成，很难区分和记忆。
在互联网早期，网站较少，人们还可以直接根据IP地址去定位网站。但随着互联网的快速发展，各种各样的网站快速增长，每个人在日常工作中都会接触到大量的网站，而要记住所有网站的IP地址显然是不现实的。
目前我们访问网站的主要方式并不是IP地址，而是使用另外一种寻址符——域名。域名是由数字、字母和特殊符号组成的字符串，如baidu.com、12306.cn等，和IP地址相比，域名具有一定的规律性，更方便人们记忆。
但从计算机的角度来看，由于域名的字节长度更长，计算机利用域名进行通信会消耗更大的资源。而且计算机更擅长处理纯数字，对于字母和数字的组合理解起来更加困难。所以目前的互联网中有域名和IP两种通信方式，分别由人类和计算机使用。
为了打破两者之间的互通障碍，DNS解析服务应运而生，DNS解析能够将域名与IP地址进行绑定，实现两者之间的一一指向关系。通过DNS解析的翻译功能，用户就能通过域名，访问到网站对应的服务器IP，获取最终的服务。
DNS系统结构
提供DNS解析服务的系统被称为DNS（Domain Name System，域名系统），它是一个存储域名IP地址相互映射关系的一个分布式数据库，能够为用户提供DNS解析服务，将用户请求的域名翻译成计算机可直接识别的IP地址，从而能够让用户更方便地访问互联网，而不用去记住每个网站的IP地址。
域名与IP地址的映射关系必须储存在域名服务器中，供其他应用查询，为了提升解析的稳定性和效率，DNS系统采用了分层式结构，每一层的域名服务器只对其所辖的部分进行应答。根据不同域名服务器起到的作用，可以将域名服务器划分为四种不同的类型：
根域名服务器
根域名服务器是DNS结构中最高层次的域名服务器。当本地域名服务器无法对域名进行解析时，首先会请求根域名服务器。
顶管域名服务器
顶级域名服务器是根服务器下第二层服务器，本地DNS服务器在根服务器请求不到结果后，会向顶级域名服务器发起查询请求，顶级域名服务器返回二级域名授权的DNS服务器地址。
权威域名服务器
权威域名服务器负责某一个区的域名服务器。当一个顶级域名服务器还不能给出最后查询回答时，就会告知下一步应当请求的权威域名服务器地址。
本地域名服务器
本地域名服务器并不属于下图中的树状结构的DNS域名服务器，但是它对域名系统非常重要。当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者ISP都可以拥有一个本地域名服务器。
DNS解析是分布式存储的，其中根域名服务器只存储了260个顶级域名服务器的IP地址。顶级域名服务器如.cn的顶级域名服务器，则存储着下一级权威解析服务器地址，如vip1.sfndns.cn，而这才是提供域名与IP地址指向关系的服务器，是整个DNS解析环节的核心。
DNS解析的具体流程
每当发送一个url请求，浏览器就会启动一个DNS查询，使浏览器获得域名对应的IP地址。
为了节省DNS解析时间，在DNS解析各个环节中都引入了缓存机制，当客户端发起解析请求时，首先会从各级的DNS缓存中查询结果，如果命中直接返回，无需再请求各级域名服务器。
（1）查看浏览器缓存
浏览器会将每一条域名解析结果缓存一段时间，当用户发起请求时，浏览器首先会查询自身的缓存中是否有想要的结果，如果有直接返回，解析到此结束；如果没有再请求下一级。
（2）查看系统缓存
如果浏览器中没有要找的记录，浏览器就会做一个系统调用（windows里是gethostbyname），从系统缓存中查找信息。
（3）查看路由器缓存
当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客户端的 DNS 缓存。
（4）查看ISP DNS 缓存
当在用户客户端查找不到域名对应 IP 地址，则将进入 ISP DNS 缓存中进行查询。比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找。
如果以上步骤中都没有目标域名的缓存记录，本地DNS服务器才开始通过DNS系统发起全球的迭代查询。
（5）本地DNS服务器首先请求根域名服务器；
（6）根域名服务器告知下一级顶级域名服务器的地址；
（7）本地DNS服务器请求顶级域名服务器；
（8）顶级域名服务器告知域名授权的权威域名服务器地址；
（9）本地DNS服务器请求权威域名服务器；
（10）权威服务器将域名对应的IP地址告知本地DNS服务器；
（11）本地DNS服务器将解析记录返回给客户端浏览器。
至此，整个DNS解析流程结束，客户端浏览器根据解析记录对目标IP发起访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/466f50a483c20ae4991185d7fc3d08eb/" rel="bookmark">
			【设计模式之美】开闭原则方法论、开闭原则如何取舍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 如何理解“对扩展开放、修改关闭”？二. 修改代码就意味着违背开闭原则吗？三. 如何做到“对扩展开放、修改关闭”？四. 如何在项目中灵活应用开闭原则？ 一. 如何理解“对扩展开放、修改关闭”？ 具体的说，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。
举例说明：
//业务逻辑主要集中在 check() 函数中。当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。 public class Alert { private AlertRule rule; private Notification notification; public Alert(AlertRule rule, Notification notification) { this.rule = rule; this.notification = notification; } public void check(String api, long requestCount, long errorCount, long durationOfSeconds) { long tps = requestCount / durationOfSeconds; if (tps &gt; rule.getMatchedRule(api).getMaxTps()) { notification.notify(NotificationEmergencyLevel.URGENCY, "..."); } if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) { notification.notify(NotificationEmergencyLevel.SEVERE, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/466f50a483c20ae4991185d7fc3d08eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb5f9e34d24688c97e9fa2beec79c0a5/" rel="bookmark">
			git 管理vivado工程， tcl 恢复vivado工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Git进行Vivado版本控制
english
youtube
如果不是上边目录结果 ， 参考上边目录结构 ，重新建一个工程；
在目录work下产生proj.tcl
修改proj.tcl
主要删除bd wrapper相关的部分；
set origin_dir "." ####改为 set origin_dir [file dirname [info script]] bd部分放在synth前边 # Import local files from the original project set files [list \ [file normalize "${origin_dir}/Lab_5_AXILITE/Lab_5_AXILITE.srcs/sources_1/bd/design_1/design_1.bd" ]\ [file normalize "${origin_dir}/Lab_5_AXILITE/Lab_5_AXILITE.srcs/sources_1/bd/design_1/hdl/design_1_wrapper.v" ]\ ] set imported_files [import_files -fileset sources_1 $files] # Set 'sources_1' fileset file properties for remote files # None # Set 'sources_1' fileset file properties for local files set file "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb5f9e34d24688c97e9fa2beec79c0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5dfb9f614206bf4734e0293e6fe4f6c/" rel="bookmark">
			《软件项目接口安全设计规范》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.token授权机制
2.https传输加密
3.接口调用防滥用
4.日志审计里监控
5.开发测试环境隔离，脱敏处理
6.数据库运维监控审计
软件全套文档：软件开发全套资料-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f4a266621b256c14e7a874b314cdf8/" rel="bookmark">
			大数据毕设分享 opencv python 深度学习垃圾图像分类系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言课题简介一、识别效果二、实现1.数据集2.实现原理和方法3.网络结构 最后 0 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的毕设题目缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的项目系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的是
🚩 opencv python 深度学习垃圾分类系统
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 课题简介 如今，垃圾分类已成为社会热点话题。其实在2019年4月26日，我国住房和城乡建设部等部门就发布了《关于在全国地级及以上城市全面开展生活垃圾分类工作的通知》，决定自2019年起在全国地级及以上城市全面启动生活垃圾分类工作。到2020年底，46个重点城市基本建成生活垃圾分类处理系统。
人工垃圾分类投放是垃圾处理的第一环节，但能够处理海量垃圾的环节是垃圾处理厂。然而，目前国内的垃圾处理厂基本都是采用人工流水线分拣的方式进行垃圾分拣，存在工作环境恶劣、劳动强度大、分拣效率低等缺点。在海量垃圾面前，人工分拣只能分拣出极有限的一部分可回收垃圾和有害垃圾，绝大多数垃圾只能进行填埋，带来了极大的资源浪费和环境污染危险。
随着深度学习技术在视觉领域的应用和发展，让我们看到了利用AI来自动进行垃圾分类的可能，通过摄像头拍摄垃圾图片，检测图片中垃圾的类别，从而可以让机器自动进行垃圾分拣，极大地提高垃圾分拣效率。
基于深度学习的垃圾分类系统，是非常好的毕业设计课题
一、识别效果 老样子， 废话不多说，先展示图像垃圾分类的识别效果
训练模型精度：
可以看到，只迭代了10轮精度达到87.50%，而且没有出现过拟合现象
我最高训练达到96%，迭代200轮
识别结果：
实际验证正确率还是很高的。
二、实现 1.数据集 该数据集包含了 2507 个生活垃圾图片。数据集的创建者将垃圾分为了 6 个类别，分别是：
如下所示：
一共6类垃圾， 比如玻璃类的如下：
塑料类的如下：
其他的不列举了。
2.实现原理和方法 使用深度残差网络resnet50作为基石，在后续添加需要的层以适应不同的分类任务
模型的训练需要用生成器将数据集循环写入内存，同时图像增强以泛化模型
使用不包含网络输出部分的resnet50权重文件进行迁移学习，只训练我们在5个stage后增加的层
需要的第三方库主要有tensorflow1.x，keras，opencv，Pillow，scikit-learn，numpy
安装方式很简单，打开terminal，例如：pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple
数据集与权重文件比较大，所以没有上传
如果环境配置方面有问题或者需要数据集与模型权重文件，可以在评论区说明您的问题，我将远程帮助您
3.网络结构 这里我只使用了resnet50的5个stage，后面的输出部分需要我们自己定制，网络的结构图如下：
stage5后我们的定制网络如下：
"""定制resnet后面的层""" def custom(input_size,num_classes,pretrain): # 引入初始化resnet50模型 base_model = ResNet50(weights=pretrain, include_top=False, pooling=None, input_shape=(input_size,input_size, 3), classes=num_classes) #由于有预权重，前部分冻结，后面进行迁移学习 for layer in base_model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31f4a266621b256c14e7a874b314cdf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ceebca998e1bcedb65251a8ea054357/" rel="bookmark">
			CentOS 7.6下的HTTP隧道代理配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS 7.6操作系统中，配置HTTP隧道代理需要一定的技术知识和经验。下面我们将详细介绍如何配置HTTP隧道代理，以确保网络通信的安全性和稳定性。
首先，我们需要了解HTTP隧道代理的基本原理。HTTP隧道代理是一种通过HTTP协议传输其他协议数据的网络通信方式。通过配置HTTP隧道代理，我们可以实现跨网络、跨防火墙的通信，并确保数据传输的安全性和隐私性。
在CentOS 7.6下配置HTTP隧道代理，需要遵循以下步骤：
安装代理服务器软件：在CentOS 7.6上，我们可以选择多种代理服务器软件，如Squid、Nginx等。根据实际需求选择合适的软件，并使用yum包管理器进行安装。例如，要安装Squid，可以运行yum install squid命令。配置代理服务器：编辑代理服务器的配置文件，以指定代理服务器的监听端口、访问控制列表、缓存设置等参数。具体配置方法取决于所选择的代理服务器软件。配置HTTP隧道代理转发规则：在代理服务器上配置HTTP隧道代理的转发规则，以确定如何将客户端请求转发到目标服务器。转发规则通常包括目标服务器的IP地址、端口号等参数。启动代理服务器：保存配置文件后，启动代理服务器软件，以使配置生效。可以使用系统服务管理工具（如systemctl）来启动、停止和重启代理服务器。测试代理服务器：通过客户端发送请求到代理服务器，检查是否能够成功访问目标服务器，并验证数据传输是否正常。可以使用多种工具进行测试，如浏览器、curl命令等。安全性考虑：在配置HTTP隧道代理时，需要注意安全性问题。确保代理服务器能够抵御常见的网络攻击，如DDoS攻击、SQL注入等。同时，要限制对代理服务器的访问权限，只允许可信的客户端通过代理访问网络资源。 通过以上步骤，我们可以在CentOS 7.6下成功配置HTTP隧道代理。需要注意的是，具体配置方法可能因所选的代理服务器软件而有所不同。因此，在实际操作中，建议参考所选软件的官方文档或相关资料进行配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7512a7298c9bff3b9d9b74fca92c87dc/" rel="bookmark">
			使用CentOS 7.6搭建HTTP隧道代理服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代网络环境中，HTTP隧道代理服务器因其灵活性和安全性而受到广泛关注。CentOS 7.6，作为一个稳定且功能强大的Linux发行版，为搭建此类服务器提供了坚实的基础。
首先，我们需要明确HTTP隧道代理的基本原理。HTTP隧道代理允许客户端通过HTTP连接发送非HTTP流量，从而实现跨网络、跨防火墙的通信。在CentOS 7.6上搭建此类服务器，主要涉及软件的选择、安装和配置。
对于软件选择，Squid和Nginx是两种流行的选择。Squid是一个功能强大的代理服务器，支持多种协议，包括HTTP、HTTPS和FTP。而Nginx则以其高性能和易配置性著称，尤其适合作为反向代理服务器使用。
安装过程相对简单。对于CentOS 7.6，我们可以使用yum包管理器来安装所需的软件包。例如，要安装Squid，只需运行yum install squid命令即可。安装完成后，我们需要对配置文件进行修改，以满足实际需求。
配置文件通常包括监听端口、访问控制列表、缓存设置等。在HTTP隧道代理的场景中，我们还需要特别关注转发规则的设置。这些规则决定了来自客户端的请求如何被转发到目标服务器。
在配置过程中，安全性是一个不容忽视的问题。我们需要确保代理服务器能够抵御各种网络攻击，如DDoS攻击、XSS攻击等。此外，访问控制列表的设置也很重要，它可以防止未经授权的访问和数据泄露。
搭建完成后，我们需要对代理服务器进行测试和调优。测试可以帮助我们发现配置中的问题，并确保服务器的稳定性。而调优则是为了提高服务器的性能，以满足更高的并发需求和更快的响应时间。
总的来说，使用CentOS 7.6搭建HTTP隧道代理服务器是一个相对简单且实用的任务。通过选择合适的软件、进行必要的配置和安全性考虑，我们可以轻松地实现跨网络、跨防火墙的通信，为现代网络环境提供更加灵活和安全的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c315a3c1f48c9729e8be81e4982429/" rel="bookmark">
			权重初始化和激活函数小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章参考李沐老师的动手深度学习,作为个人的笔记.
4.8. 数值稳定性和模型初始化 — 动手学深度学习 2.0.0 documentation (d2l.ai)
文章目录 前言
首先我们理想的神经网络是什么样子的?
一.权重初始化
二.检查激活函数
总结
前言 选择合理的权重初始化和选择合理的激活函数在训练是保证训练的稳定性尤为重要,本文介绍其做法,帮助我们事半功倍.
首先我们理想的神经网络是什么样子的? 这样的一个神经网络对于我们来说才是很好的,并且我们要达到这样的要求我们要做什么呢?
一.权重初始化 在合理值区间例随机初始参数.训练开始得时候更容易有数值不稳定. 远离最优解的地方损失函数的表面可能很复杂.最优解附近表面会比较平 使用N(0,0.01)来初始可能对小网络没有问题,但不能保证深度神经网络. 这里放一个图帮助大家理解.
二.检查激活函数 上述公式表明我们的激活函数必须是f(x) = x 在零附近可以近似的看作是f(x) = x,而且神经网络的权重通常是在零点附近比较小的数,所以tanh(x)与relu(x)是可以满足我们要求的,而sigmoid函数不满足,但可以进行平移变换来将函数调整.
总结 梯度消失和梯度爆炸是深度网络中常见的问题。在参数初始化时需要非常小心，以确保梯度和参数可以得到很好的控制。
需要用启发式的初始化方法来确保初始梯度既不太大也不太小。
ReLU激活函数缓解了梯度消失问题，这样可以加速收敛。
随机初始化是保证在进行优化前打破对称性的关键。
Xavier初始化表明，对于每一层，输出的方差不受输入数量的影响，任何梯度的方差不受输出数量的影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ba868e788502c05b9e226dea04363c9/" rel="bookmark">
			NeurIPS 2023 Spotlight | 基于超图的表格语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©PaperWeekly 原创 · 作者 | 陈沛
单位 | 德州农工大学
研究方向 | 大语言模型和信息抽取
NeurIPS 2023 接收的 Spotlight 论文 “HYTREL: Hypergraph-enhanced Tabular Data Representation Learning” 提出了把表格建模成超图，再利用超图神经网络模型和大规模的表格数据学习得到表格语言模型。将表格建模成超图可以最大限度地保留表格的结构信息，包括表格行列排列的不变性，层级结构，以及表格单元格之间的联系等。
本文从理论和实验的角度都证实了该方法能够学得表格鲁棒的，富有表达性的表示， 并在下游四个表格表示学习任务中取得了超越基线模型的表现。
论文标题：
HYTREL: Hypergraph-enhanced Tabular Data Representation Learning
论文地址：
https://arxiv.org/abs/2307.08623
背景 表格数据的表示学习（Tabular Data Representation Learning）问题，近年来由于大语言模型的流行越来越受到关注。许多下游的表格智能任务，比如表格分类、表格信息抽取、表格问答以及表格生成等，都需要表格富有表达性、鲁棒的表示。
目前的大语言模型由于其自回归特性，使得其对于具有结构化或半结构化的特征表格数据还不能直接学得很好的表示。这就使得专门研究适合表格数据的表格语言模型以学得更好的表格数据的表示尤为重要。
表格数据，由于其天然的结构化或半结构化的特征，和序列化的自然语言有着本质的不同。下图是之前的工作提出的 TAPAS 表格语言模型，这些表格语言模型为了利用现有的语言模型的强大的语言理解能力，如 BERT，将表格数据按行排列，强行序列化 （图中将表格序列化为：col1, col2, 0, 1, 2, 3），然后利用已有的自然语言预训练目标如遮蔽词预测。
然而，这类工作都假设表格是一个序列，忽略的表格本身结构特征。我们人在理解一个表格数据时并非一行一行的读下去，而是会按照表格的结构去理解，比如从表格标题，再到各个列名，然后到感兴趣的行和单元格。基于这样的背景，本文提出基于超图的表格语言模型将克服这些工作的缺陷，最大程度地保留表格的结构信息，以学得表格数据更好的表示。
动机
我们为了最大程度地建模表格数据，将其建模成为了超图（hyper-graph）。超图是普通图的更一般化的形式，在超图中，一条边可以连接若干个节点，不只是两个节点。
如下图所示，对于一个表格，我们把所有的单元格建模成超图中的节点（绿色椭圆），然后用三种超图边将他们连接起来：列超图边连接来自同一列的节点（橙色不规则图形），行超图边连接来自同一行的节点（蓝色不规则图形），表格超图边连接来自同一个表格的所有节点（灰色不规则图形）。
这样建模的好处是我们可以最大程度的保留表格的结构信息，我们总结了表格的结构信息有以下四类， 均可由超图保留下来。
表格是具有行列排列的不变性的特征。如上图，如果将表格的第一行和第三行交换，并不会影响表格的内容；同理，交换表格的第二列和第三列，也不会影响表格内容。而超图本身的不变性特征，可以天然地建模表格的这个特征。
来自同一行或者同一列的单元格具有天然的联系。如上图中，第一列的单元格都是足球俱乐部名称，而第一行的单元格，都是 Barcelona 这只球队的不同属性。超图模型将这些单元格连起来，可以自然地学得其联系。
表格是有层级结构的：从最细粒度的单元格，到中间粒度的行与列，再到最粗粒度的表格。我们的超图模型对于不同的层级都有对应的节点或者超图边。我们将中间粒度的行与列，以及粗粒度的表格都建模成了超图边，可以保留这样的层级结构。
来自同一列或者行的单元格之间的交互联系，是多边的交互关系，而并不是两两交互关系。这是我们使用超图来建模，而非用普通图模型的重要原因。在超图中，相互连接的节点被看作是一个集合（set），集合之间的交互式多边的，而非两两之间的关系。
方法 在将表格建模成超图以后，我们利用超图神经网络在大规模的表格数据上对网络进行学习。如下图所示，我们的 HYTREL 语言模型主要由 层 HyperTrans 模块构成。HyperTrans 模块是基于超图，对其节点和超图边的表示进行更新。为了获得节点和超图边的初始表示，我们首先将表格的标题、列名、单元格中的语义信息标记化，然后通过一个词表征层，最后再池化后获得。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ba868e788502c05b9e226dea04363c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7ce1b73e3dc74c569afd506e71c9d6/" rel="bookmark">
			博士申请 | 香港科技大学（广州）孙莹老师招收人工智能方向全奖博士生/RA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		合适的工作难找？最新的招聘信息也不知道？
AI 求职为大家精选人工智能领域最新鲜的招聘信息，助你先人一步投递，快人一步入职！
香港科技大学（广州）
香港科技大学是亚洲以至全球领先的研究学府之一，并被认为是世界上发展最快的大学之一。在2021年，科大位列QS世界大学排名第34位和泰晤士高等教育世界年轻大学排名第3位。作为港科大在内地筹建的独立法人办学机构，香港科技大学（广州）将不会重叠清水湾校园已提供的学科，而将重点发展交叉学科，以相互补足。在保证两个校区地位平等，学位证、学生待遇一致的前提下，广州校园政策更加灵活，交通与生活更加便利舒适。目前香港科技大学（广州）已招收五届学生，2024 Fall是第六批招生。 导师简介
孙莹博士2022年于中国科学院计算技术所获得博士学位，现任香港科技大学（广州）人工智能学域助理教授。主要研究方向为可解释人工智能、数据挖掘及相关交叉领域应用。近五年，孙莹博士在Nature Communications、Nature Cities、TKDE、KDD、NeurIPS 、SIGIR、WWW、IJCAI等人工智能、数据挖掘及交叉领域顶级期刊和会议发表诸多学术论文，申请国内外专利10余项，其中关于市场驱动的技能定价的开创性工作发表于Nature Communications，受到光明网、中国日报等国内媒体广泛报道。作为负责人主持国家自然科学基金项目及多项省、市级自然科学基金项目，并参与国家自然科学基金重大项目。担任KDD、ICLR、AAAI、IJCAI等顶级国际会议程序委员会委员。曾获部分荣誉包括2023年度CCF博士学位激励计划（原CCF优博）、中科院朱李月华奖、百度奖学金全球20强、三次国家奖学金、入选AI华人女性青年学者榜单等。
此外，孙莹博士具有丰富的算法和编程经验，曾获两次ACM-ICPC亚洲区域赛季军、ACM-ICPC World Final入围等荣誉。孙莹博士有丰富的产业界实践经验，与华为、百度、OPPO、BOSS直聘等企业保持着长期的学术合作，多项科研成果实现了产品应用转化，曾获华为公司火花奖、最佳创新合作奖。 孙莹博士重视学生科研素养和问题解决能力培养，并与产业界保持深度合作，优秀学生在完成基础课程后可推荐到国内外知名企业进行实习和联合培养，在业务场景中开展落地的应用研究。此外，孙莹博士与人工智能学域主任熊辉教授及其他老师目前通过共同指导博士生和共同承担科研项目保持深度合作，录取学生也可以选择感兴趣的教授作为第二导师进行联合指导。
导师主页：
https://sunyinggilly.github.io/
研究方向
1. 可解释人工智能：包括不限于自解释神经网络、神经符号学习、因果学习、大模型推理等相关研究；
2. 数据挖掘：包括不限于图/时空数据挖掘、强化学习/决策、推荐系统等相关研究；
3. 可解释人工智能及数据挖掘在商业、社会/自然科学等交叉领域应用研究。
招生要求
1. 对人工智能和数据科学的基础研究和应用有浓厚兴趣，希望做出原创性、有价值的工作；
2. 具备较强的数学和编程能力；
3. 具有求知欲和好奇心，愿意学习探索新知识并深入了解算法原理；
4. 务实自驱，有较强抗压能力，能适应高强度的科研工作节奏。
加分项
1. 有过数据挖掘或机器学习研究和项目经验，作为主要作者在顶级会议发表过论文；
2. ICPC/CCPC/蓝桥杯/Kaggle等编程或数据挖掘竞赛中取得良好成绩；
3. 在头部互联网公司或研究机构有过实习经历，对机器学习的应用有系统深刻理解，并在实习阶段取得过突出成果。
薪资待遇
1. 所有录取研究生均保证全额奖学金（博士生约1.5万人民币/月）；
2. 为RA提供具有竞争力的薪资，并根据项目进度提供项目奖金，表现优异者可优先录取博士项目。
申请方式
请发送简历、成绩单、代表性论文或项目（如有）到 yings@ust.hk。标题请注明“PhD/RA Application + Name”。
注：开放与企业界资深研究员、港科大（广州）客座教授祝恒书博士 (zhuhengshu.com) 联合指导AI交叉研究方向PhD名额一位，欢迎计算机相关或交叉学科背景同学投递，如有意向请在申请邮件中备注并将邮件抄送 zhuhengshu@gmail.com
说明：对于所有投递申请会在24小时内仔细阅读并进行评估。由于申请人数较多，恕不能一一回复。若通过简历筛选，会有邮件通知面试；若一个月内没有收到任何回复，则没有进入下一轮。
实习内推
中国电信总部大数据AI中心｜京东零售推荐算法团队｜创业黑马科技集团｜微信视觉团队｜小红书搜索团队｜VIVO影像算法研究部｜阿里通义实验室对话智能团队｜智源人工智能研究院｜微软亚洲研究院媒体计算组｜华为云｜小米自动驾驶团队｜字节跳动国际化短视频搜索团队｜京东广告研发部｜默沙东高阶分析团队｜浙江清华长三角研究院｜阿里通义实验室对话智能团队｜新加坡科技研究局A*STAR｜联想数字化转型部门｜腾讯优图实验室｜快手Y-tech部门｜中国科学院自动化研究所｜腾讯IEG光子工作室群｜微软亚洲研究院自然语言计算组｜粤港澳大湾区数字经济研究院｜好未来AI增长实验室｜腾讯混元大模型团队｜微软亚洲互联网工程院｜AMD北京AI算法团队｜Apple中国NLP团队｜右脑科技｜途深智合｜微软亚洲研究院自然语言计算组｜上海人工智能实验室｜百川智能｜阿里通义实验室｜百度文心团队
校招岗位
小红书社区技术部｜百度搜索策略部相关性团队｜京东营销与商业化中心｜同花顺问财团队｜商汤科技｜小红书｜华为云算法创新Lab｜智源人工智能研究院｜阿里云PAI深度学习算法团队｜秘塔科技｜美柚研究院｜百度搜索策略部｜华为云算法创新Lab｜淘宝搜索算法团队｜百川智能｜IDEA数字经济研究院｜百度搜索策略部｜阿里达摩院视觉技术实验室｜地平线｜阿里巴巴淘天集团｜阿里达摩院对话智能团队｜百度文心一言团队｜京东零售内容算法部｜蚂蚁网商银行智能引擎团队｜腾讯AI Lab决策智能中心｜理想汽车智能座舱团队｜阿里通义实验室对话智能团队｜元象XVERSE｜蚂蚁集团算法数据技术团队｜腾讯游戏AI大语言模型团队｜秘塔科技
社招岗位
微信技术架构部｜Avolution.AI团队｜百度搜索策略部｜蚂蚁集团｜阿里达摩院视觉技术实验室｜海康威视研究院｜阿里巴巴淘天集团｜阿里达摩院对话智能团队｜第四范式大模型团队｜美团流量安全团队｜蚂蚁网商银行智能引擎团队｜Sony AI｜阿里达摩院OCR团队｜OPPO研究院语音语义研究部｜京东智能服务与产品部算法团队｜阿里淘天集团客户满意中心｜理想汽车智能座舱团队｜阿里通义实验室对话智能团队｜百度AIGC团队｜光明实验室媒体内容生成团队｜奇虎360｜美团平台｜元象XVERSE｜Shopee内容搜索团队｜VIVO影像算法研究部｜蚂蚁集团机器智能团队｜腾讯游戏AI大语言模型团队｜京东广告研发部｜阿里通义实验室对话智能团队｜NVIDIA中国｜腾讯混元大模型团队｜秘塔科技｜途深智合｜蚂蚁集团风险智能团队
高校招生
南方科技大学魏鸿鑫老师｜佛罗里达大学方若谷教授｜香港城市大学赵翔宇老师｜北京大学孔桂兰老师｜新加坡科技设计大学段凌杰教授｜香港中文大学宋永健老师｜西蒙菲莎大学陈武阳老师｜宁波东方理工大学沈晓宇老师｜香港科技大学冯雁教授｜香港科技大学（广州）李昊昂老师｜鹏城实验室童倩倩老师｜悉尼大学Hesham El Gamal教授｜麦考瑞大学AIoT课题组｜加州大学河滨分校董悦老师｜西交利物浦大学颜宏盛副教授｜北京大学张文涛教授｜清华大学未来实验室人居组｜波士顿学院Prof. Donglai Wei｜华盛顿大学计算机系王晟老师｜香港科技大学（广州）骆昱宇老师｜伊利诺伊大学香槟分校张欢老师｜西湖大学机器智能实验室｜新加坡国立大学尤洋老师课题组｜清华大学信息国家研究中心｜香港理工大学Boris NG教授｜香港科技大学（广州）张延林老师｜香港科技大学（广州）谢思泓教授｜北京大学王乐业老师｜伊利诺伊大学香槟分校张潼教授
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f7ce1b73e3dc74c569afd506e71c9d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1481c2d2ea71aa9ffe7651aa47d27368/" rel="bookmark">
			清华叉院提出「GenH2R」框架，用百万场景打造基于视觉的通用人机交接策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©作者 | 机器之心编辑部
来源 | 机器之心
来自清华大学交叉信息研究院的研究者提出了「GenH2R」框架，让机器人学习通用的基于视觉的人机交接策略（generalizable vision-based human-to-robot handover policies）。这种可泛化策略使得机器人能更可靠地从人们手中接住几何形状多样、运动轨迹复杂的物体，为人机交互提供了新的可能性。
‍‍‍
‍‍随着具身智能（Embodied AI）时代的来临，我们期待智能体能主动与环境进行交互。在这个过程中，让机器人融入人类生活环境、与人类进行交互（Human Robot Interaction）变得至关重要。我们需要思考如何理解人类的行为和意图，以最符合人类期望的方式满足其需求，将人类放在具身智能的中心（Human-Centered Embodied AI）。
其中一个关键的技能是可泛化的人机交接（Generalizable Human-to-Robot Handover），它使机器人能够更好地与人类合作，完成各种日常通用任务，如烹饪、居室整理和家具组装等。
大模型的火爆发展预示着海量高质量数据+大规模学习是走向通用智能的一种可能方式，那么能否通过海量机器人数据与大规模策略模仿获取通用人机交接技能？然而，若考虑在现实世界中让机器人与人类进行大规模交互学习是危险且昂贵的，机器很有可能会伤害到人类：
‍
‍而在仿真环境中（Simulation）进行训练，用人物仿真和动态抓取运动规划来自动化提供海量多样的机器人学习数据，然后将其部署到真实机器人上（Sim-to-Real Transfer），是一种更可靠的基于学习的方法，可以大大拓展机器人与人协作交互的能力。
因此，「GenH2R」框架被提出，分别从仿真（Simulation），示例（Demonstration），模仿（Imitation）三个角度出发，让机器人第一次基于端到端的方式学习对任意抓取方式、任意交接轨迹、任意物体几何的通用交接：
1）在「GenH2R-Sim」环境中提供了百万级别的易于生成的各种复杂仿真交接场景；
2）引入一套自动化的基于视觉 - 动作协同的专家示例（Expert Demonstrations）生成流程；
3）使用基于 4D 信息和预测辅助（点云 + 时间）的模仿学习（Imitation Learning）方法。
相比于 SOTA 方法（CVPR2023 Highlight），GenH2R 的方法在各种测试集上平均成功率提升 14%，时间上缩短 13%，并在真机实验中取得更加鲁棒的效果。
论文标题：
GenH2R: Learning Generalizable Human-to-Robot Handover via Scalable Simulation, Demonstration, and Imitation
论文地址：
https://arxiv.org/abs/2401.00929
论文主页：
https://genh2r.github.io/
论文视频：
https://youtu.be/BbphK5QlS1Y
方法介绍
A. 仿真环境（GenH2R-Sim）
为了生成高质量、大规模的人手 - 物体数据集，GenH2R-Sim 环境从抓取姿势和运动轨迹两方面对场景建模。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1481c2d2ea71aa9ffe7651aa47d27368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913fa035a6ea5a04f982c5091de9eb0f/" rel="bookmark">
			Golang语言基础—函数调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. C语言的函数调用惯例 所谓“调用惯例(calling convention)”是调用方和被调用方对于函数调用的一个明确的约定，包括：函数参数与返回值的传递方式、传递顺序。只有双方都遵守同样的约定，函数才能被正确地调用和执行。如果不遵守这个约定，函数将无法正确执行。
C语言中，一般使用gcc将C语言编译成汇编代码是分析函数调用的最常见方式，比如以下的代码：
int my_function(int arg1, int arg2) { return arg1 + arg2; } int main() { int i = my_function(1, 2); } 通过gcc -S main.c指令生成main.s：
.file "main.c" .text .globl my_function .type my_function, @function my_function: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl %edi, -4(%rbp) // 取出第一个参数放到栈上 movl %esi, -8(%rbp) // 取出第二个参数放到栈上 movl -4(%rbp), %edx // 设置edx = edi = 1 movl -8(%rbp), %eax // 设置eax = esi = 2 addl %edx, %eax // 返回值放在eax，eax = eax + edx = 3 popq %rbp .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913fa035a6ea5a04f982c5091de9eb0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/602aff35a2567e0360932abad8e79a7e/" rel="bookmark">
			推荐 5 个本周很火的 GitHub 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期推荐开源项目目录：
1. OpenVoice
2. 大模型课程
3. 看电影的应用
4. 基于大模型的多模态代理框架
5. 使用 ChatGPT 制作的 PDF 工具
01 OpenVoice
OpenVoice 主要优势可以分为三个方面：
准确的音色克隆：OpenVoice 能够准确地克隆参考音色，并生成多种语言和口音的语音。
灵活的语音风格控制：OpenVoice 允许对语音风格进行细粒度控制，例如情感和口音，以及其他风格参数，包括节奏、停顿和语调。
零样本跨语言语音克隆：生成的语音或参考语音的语言都不需要出现在大规模多语言训练数据集中。
OpenVoice 自 2023 年 5 月以来一直在为 myshell.ai 的即时语音克隆功能提供支持。截至 2023 年 11 月，全球用户已经使用了数千万次语音克隆模型，并在平台上见证了用户数量的爆炸性增长。
开源地址：https://github.com/myshell-ai/OpenVoice
02 大模型课程
Large Language Model Course（大型语言模型课程）是一个开源项目，该课程分为三个部分：
LLM 基础：涵盖了数学、Python 和神经网络的基础知识。
LLM 科学家：专注于学习如何使用最新技术构建最佳的大型语言模型。
LLM 工程师：专注于如何创建基于大型语言模型的解决方案并部署它们。
此外，该项目还提供了一系列与大型语言模型相关的笔记本和文章。这些资源可以帮助用户更深入地理解和应用大型语言模型，无论是从理论基础、模型构建，还是实际应用和部署等方面，都提供了丰富的学习材料。
开源地址：https://github.com/mlabonne/llm-course
03 看电影的应用
movie-web 是一个看电影的网络应用开源项目，目前已经获得了 14k 的 Star，你可以访问 movie-web.app 体验。该服务通过直观且美观的用户界面中显示来自第三方提供商的视频文件来工作。
这个项目旨在保持简单易用。功能要保持最小化，但要打磨得很好。我们不希望这个项目成为另一个庞大的流媒体网站，而是追求极简主义。
项目的主要特点包括：自动保存进度 - 可选择同步到账户、书签显示或电影，跟踪你想要观看的内容、极简主义界面，只显示所需内容
开源地址：https://github.com/movie-web/movie-web
04 基于大模型的多模态代理框架
AppAgent 是一个创新的基于大型语言模型（LLM）的多模态代理框架，设计用于操作智能手机应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/602aff35a2567e0360932abad8e79a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d42546309eb73d86312e8b67d6b3c0/" rel="bookmark">
			软件质量全面管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件质量全面管理是确保软件开发过程中各个环节都符合高质量标准的一种管理方法。它涉及到从需求分析到设计、编码、测试、发布和维护等各个阶段的质量管理。
以下是一些常见的软件质量全面管理的实践方法：
需求管理：确保需求明确、准确，并与相关利益相关者进行充分沟通和确认。
设计管理：采用适当的设计方法和工具，确保软件系统的结构合理、模块化、可扩展，并满足性能、安全等要求。
编码管理：遵循良好的编码规范，使用合适的开发工具和技术，确保代码的可读性、可维护性，并进行代码审查和版本控制。
测试管理：建立全面的测试策略和测试用例，包括单元测试、集成测试、系统测试、性能测试等，对软件进行全面的功能和性能验证。
发布管理：在发布前进行充分的验证和准备工作，包括部署环境的准备、文档编写、用户培训等，确保软件能够稳定运行并满足用户需求。
维护管理：及时响应用户反馈和问题，并进行适当的维护和升级，确保软件持续运行并保持高质量。
此外，软件质量管理还需要建立合适的质量指标和度量方法，对软件质量进行定量评估和监控。同时，建立适当的质量管理体系和流程，确保各个环节都能够有效地执行。
总之，软件质量全面管理需要在软件开发的各个环节中注重质量，采取相应的管理措施和实践方法，以确保软件交付具备高质量和可靠性。这样可以提高软件的稳定性、安全性和用户满意度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452c24e914587e39f4ca77afe5f02c8a/" rel="bookmark">
			力扣labuladong一刷day53天LFU 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣labuladong一刷day53天LFU 算法 一、460. LFU 缓存 题目链接：https://leetcode.cn/problems/lfu-cache/description/
class LFUCache { HashMap&lt;Integer, Integer&gt; ktv; HashMap&lt;Integer, Integer&gt; ktf; HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; ftk; int cap; int minFreq; public LFUCache(int capacity) { ktv = new HashMap&lt;&gt;(); ktf = new HashMap&lt;&gt;(); ftk = new HashMap&lt;&gt;(); cap = capacity; minFreq = 0; } public int get(int key) { if (!ktv.containsKey(key)) { return -1; } Integer v = ktv.get(key); up(key); return v; } private void up(int key) { Integer f = ktf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452c24e914587e39f4ca77afe5f02c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a69fdc3e22538422a415ab19db0e102/" rel="bookmark">
			生成式AI如何重塑开发流程和开发工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的飞速发展，人工智能（AI）已经成为当今世界最重要的技术趋势之一。在众多AI应用中，生成式AI以其独特的优势，正在对软件开发行业产生深远的影响。生成式AI通过自动化和优化软件开发过程，提高开发效率和质量，为开发人员带来了前所未有的便利。
本文将深入探讨生成式AI如何重塑开发流程和开发工具，以及它对软件开发行业的影响。
一、生成式AI简介 生成式AI是指利用机器学习、深度学习等技术，从大量数据中学习和提取知识，进而生成全新的、真实的、有用的数据。在软件开发领域，生成式AI可以用于自动生成代码、测试用例、部署配置等，从而极大地提高开发效率和质量。
二、生成式AI重塑开发流程 1. 自动化代码生成 生成式AI可以通过学习已有的代码，自动生成类似的代码。这种自动化代码生成技术可以帮助开发人员快速生成基础代码框架，减少重复劳动，提高开发效率。同时，自动生成的代码经过适当的调整和优化，可以作为生产环境的代码使用，降低错误率。
2. 智能测试用例生成 生成式AI可以通过分析软件的需求和功能，自动生成相应的测试用例。这些测试用例覆盖了各种场景和条件，能够全面检测软件的稳定性和可靠性。此外，生成式AI还可以对测试结果进行分析和评估，帮助开发人员快速定位和修复问题。
3. 自动化部署配置 生成式AI可以根据软件的需求和环境，自动生成部署配置文件。这些配置文件包含了软件运行所需的各种参数和设置，能够帮助开发人员快速部署软件，降低部署成本。同时，自动化部署配置还可以减少因人为因素导致的错误和漏洞。
三、生成式AI重塑开发工具 1. 集成开发环境（IDE） 传统的IDE主要提供代码编辑、调试和运行等功能。而随着生成式AI的引入，IDE的功能得到了进一步扩展。现在的IDE可以自动完成代码补全、语法检查、代码风格纠正等任务，极大提高了开发效率和质量。同时，基于生成式AI的IDE还可以提供智能提示和代码推荐功能，帮助开发人员更快地编写高质量代码。
2. 版本控制系统 版本控制系统是软件开发中不可或缺的工具。通过引入生成式AI技术，版本控制系统可以实现自动化代码审查、冲突解决等功能。这样不仅可以减少人工审查的时间和成本，还可以提高代码的质量和一致性。同时，基于生成式AI的版本控制系统还可以提供智能分支推荐功能，帮助开发人员更快地迭代和发布软件。
3. 缺陷管理工具 缺陷管理工具是软件开发中的重要组成部分。通过利用生成式AI技术，缺陷管理工具可以实现自动化缺陷检测、定位和修复等功能。这不仅可以提高缺陷处理的效率和质量，还可以降低缺陷对软件质量和用户体验的影响。同时，基于生成式AI的缺陷管理工具还可以提供智能缺陷预测功能，帮助开发人员更好地预防和解决潜在的缺陷问题。
四、结论 生成式AI正在深刻地改变软件开发行业。它通过自动化和优化软件开发过程，提高开发效率和质量，为开发人员带来了前所未有的便利。随着技术的不断发展，我们相信生成式AI将会在软件开发领域发挥越来越重要的作用。
未来，我们期待看到更多基于生成式AI的开发工具和服务出现，推动整个行业的进步和发展。同时，我们也需要关注到生成式AI可能带来的挑战和风险，如数据隐私、伦理问题等。因此，在推进生成式AI的应用时，需要充分考虑各种因素，确保技术的合理和可持续应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e9f6592e22f0d891763f8f2667d963/" rel="bookmark">
			MYSQL多种提权方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐙MYSQL-提权条件 - 数据库的最高权限用户的密码 - secure-file-priv没进行目录限制 - 拿下了网站的权限（通过webshell或者其他方式） - 获取到了数据库的账号密码 （获取密码：D:/phpstudy/MySQL/data/mysql/user.MYD 或者 查看网站配置文件） 🐙MYSQL-数据库帐密获取方式 0、网站存在高权限SQL注入点 1、数据库的存储文件或备份文件 2、网站应用源码中的数据库配置文件 3、采用工具或脚本爆破(需解决外连问题) 🐙MYSQL-提权方式 🐼udf提权🐼mof提权🐼开机启动脚本（启动项提权）🐼反弹Shell（也属于udf的一种） 🐙MYSQL-UDF提权 UDF(user-defined function)是MySQL的一个拓展接口，也可称之为用户自定义函数，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()或version() 一样方便。
UDF提权的整个原理主要是建立在MySQL的func上，官方的定义是：对认证的用户——只要拥有INSERT和DELETE这两个权限的用户，就可以在任意的数据库下面以MySQL创建一个函数，然后用这个函数去攻击数据库来达到我们的目的。
UDF限定条件：
① 如果MySQL的版本大于5.1，这个udf.dll文件就得放到MySQL的安装目录下的lib\plugin文件夹下，如果没有这个目录，那么我们就自己创建一个就行了。 ② 如果MySQL的版本小于5.1，这个udf.dll文件就得放置于C:\windows\system32 通过webshell的功能查询数据库版本命令：
select version(); 通过webshell的功能查询MYSQL的安装目录
select @@basedir; 因此udf.dll文件就得放到MySQL的安装目录下的lib\plugin文件夹下，如果没有这个目录，那么我们就自己创建一个就行
没有目录采用手工创建plugin目录或利用NTFS流创建
💝方式一：MSF导出dll 前提：数据库root要开启 允许用户远程连接（外连）
GRANT ALL PRIVILEGES ON . TO ‘帐号’@‘%’ IDENTIFIED BY ‘密码’ WITH GRANT OPTION;
使用MSF中的exploit/multi/mysql/mysql_udf_payload模块可以进行UDF提权，MSF会将dll文件写入lib\plugin\目录下(前提是该目录存在，需手工创建),该dll文件中包含sys_exec()和sys_eval()两个函数，但是默认只创建sys_exec()函数，该函数执行并不会有回显。我们可以手动创建 sys_eval() 函数，来执行有回显的命令。
MySQL默认禁止root外连，而且对方MySQL数据库可能处于内网。
那么为什么哥斯拉连接的webshell可以直接连接对方MySQL呢？是因为webshell上传后处于其内网环境。
MSF是处于外部的，所以需要MySQL开启外连才行。
当MySQL设置 secure-file-priv 选项时，只允许在指定目录写入文件，所以MSF也无法写入dll文件
修改 my.ini 文件，在 [mysqld] 块下，如果没有 secure_file_priv 则新增
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17e9f6592e22f0d891763f8f2667d963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aadf3adb2e861bca772d0e7cb999c7af/" rel="bookmark">
			pod进阶版(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pod的相关知识 k8s的pad重启策略: Always deployment的yaml文件只能是Always pod的yaml三种模式都可以。
Onfailure:只有异常退出状态码非0才会重启。正常退出不重启。
Never：非正常退出和非正常退出都不重启。
容器的退出了pod才会重启。
pod可以有多个容器，只要有一个容器退出，整个pod都会重启，pod内的所有容器都会重启。
docekr的重启策略： docker的默认策略是Never。
on-failure：非正常退出，才会重启容器。
always：只要容器退出都会重启。
unless-stopped：只要退出就会重启，docker守护进程时已经停止的容器，不会重启。
单机部署：docker就够用了
集群化部署：k8s部署
yaml模板文件快速生成的三种方式 可以生成pod、service、deployment等yaml文件
1、手写
2、对已有资源进行导出
kubectl get deployments.apps nginx -o yaml &gt; /opt/lyw.yaml 3、通过api的组件，使对象不执行命令生成文件
kubectl create deployment nginx1 --image=nginx:1.22 --dry-run=client -o yaml &gt; /opt/test1.yaml --dry-run=client 只是调用api的对象不执行命令 pod的状态： pod状态简述说明说明pending挂起状态 pod已被创建，但是尚未被分配到运行的node节点
（原因：节点资源不够或等待其他pod节点调度）
running运行中pod已经被分配到了node节点，pod内部的所有容器都已经启动，运行状态正常，稳定。completed 成功运行完毕并退出容器内部的进程运行完毕，正常退出，没有发生错误。successdedfaild运行错误并退出 pod中的容器非正常退出，发生了错误。
需要通过查看详细和日志来定位问题。
Unkown未知 由于某些原因，k8s集群无法获取pod的状态。
APIserver出了问题
terminating在终止中 这个pod正在被删除，里面的容器正在终止。
终止过程中，资源回收、垃圾清理、以及终止过程中需要执行的命令。
crashloopbackoffpod当中的容器退出，kubelet正在重启imagepullbackoff正在重试拉取镜像errimagepull 镜像拉取出错
（1、网速太慢 2、镜像名字写错了 3、镜像仓库挂了）
Evictepod被驱赶（node节点的资源不足部署pod，或者是资源不足，kubelet自动选择一个pod驱逐。） pod内的容器使用节点资源的限制： 1、request：需要的资源
2、limit 最高占用系统多少资源
limit需要多少，最多也只能占用这么多
两个限制(cpu、内存): cpu ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aadf3adb2e861bca772d0e7cb999c7af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc662aa734ca02c26bbca70fa1f21055/" rel="bookmark">
			AI时代Python金融大数据分析实战：ChatGPT让金融大数据分析插上翅膀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
1. Python在股票市场分析中的应用
2. 投资组合优化
3. 风险管理与预测
时间序列分析
机器学习在风险预测中的应用
大数据分析与风险建模
总结
⭐️ 好书推荐
【内容简介】
前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。 点击跳转到网站
引言 随着人工智能时代的到来，Python作为一种功能强大的编程语言，在金融领域的大数据分析中扮演着日益重要的角色。本文将探讨Python在金融领域的应用，重点介绍其在大数据分析方面的实际应用案例，涉及股票市场分析、投资组合优化、风险管理等方面，并提供相关的代码示例。
随着金融市场数据规模的不断增长，金融机构和投资者们越来越依赖于大数据分析和人工智能技术来做出更准确、更智能的决策。Python作为一种高效且易于学习的编程语言，以其丰富的库和工具成为金融大数据分析的首选工具。
1. Python在股票市场分析中的应用 在这部分，我们将深入研究如何使用Python来获取、处理和分析股票市场数据。我们将介绍如何使用第三方库（如Pandas、Numpy、Matplotlib等）来下载股票数据，进行可视化分析，甚至是构建简单的股票预测模型。
# 代码示例：获取股票数据并可视化 import pandas as pd import yfinance as yf import matplotlib.pyplot as plt # 下载股票数据 data = yf.download('AAPL', start='2020-01-01', end='2021-01-01') # 绘制股票走势图 plt.figure(figsize=(10, 6)) plt.plot(data['Close'], label='AAPL') plt.title('AAPL Stock Price') plt.xlabel('Date') plt.ylabel('Price') plt.legend() plt.show() 2. 投资组合优化 我们将探讨如何使用Python对投资组合进行优化。通过数学建模和优化技术，我们可以创建一个有效的投资组合，以最大化收益并控制风险。
# 代码示例：投资组合优化 import numpy as np from scipy.optimize import minimize # 假设我们有一些资产的收益率数据 returns = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc662aa734ca02c26bbca70fa1f21055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb5ec7db51628923a282d242c007512/" rel="bookmark">
			用Delphi调用阿里云的OpenAPI更新动态域名解析记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Delphi调用阿里云的OpenAPI更新动态域名解析记录 家里一直是电信的宽带，虽然只是200M下行30M上行的平均水平，但是对于平时下载量不大的我来说已经绰绰有余了，很多时候需要从外网访问家里的NAS的资料，但是因为不是固定IP，每次一重启路由器或者每隔几天，家里的IP地址都是变动一下，前阵子一直使用docker安装了一个阿里云的DDNS软件非常好用，突然有一天不更新IP到阿里云的服务器上了，又加上自己的管理软件的服务端是安装到Windows下（用unRaidNAS虚拟了一个WindowsServer），所以干脆想办法把这个功能加到自己的管理服务端软件上，这时候开始祭出我们的工具Delphi。（前几篇文章已经说了如何安装社区版的Delphi和如何在unRaid下虚拟Windows）。
在正式操作之前，首先说明下使用aliyun的DDNS的基本条件。 1、这个也是最最关键的必不可少的一步，就是你家必须要有公网IP，现在很多地方宽带供应商只给内网IP（特别是移动和联通），如果是电信的话，可以打10000号免费开通公网IP功能，至于给不给你开，看各地的政策。反正我家一直是公网IP。
2、你得有个阿里云的域名，如果没有，赶紧去阿里云上去买个，不差钱的可以买个.com、.cn的，如果只是玩玩的可以买个.xyz等超级便宜的域名。至于腾讯云的域名，有两种方法：你可以把域名改为阿里云托管，也可以将下面的代码稍微改动改成腾讯云的。因为我只有阿里云的域名，所以没法测试腾讯云的，这里就不改动了
3、获得阿里云的访问key和访问key的密钥。这个在你登录阿里云后，在头像上点击鼠标左键会弹出来一个菜单，就可以直接看到。这里也给个建议，最好不要用主key和密钥，因为一旦泄露，也就是将你的阿里云的所有权限暴露给别人了，所以可以建立一个子用户key并且给他设置权限只能修改域名解析。
4、提前在阿里云的域名管理上建立一个新的二级域名，虽然可以通过代码添加，但是我觉得自己手工添加会更安全，至少不会让自己的域名列表不经意的多出很多无用的二级域名。
有了前面的几步，现在正是进入主题。代码写起来比较简单，只要根据阿里云的OpenAPI的文档编写就可以，当然你得学会看懂文档。很快我就将所有的代码完成，但是运行的时候一直提示错误，最主要错误就是一直提示签名值错误，这个签名值在我的理解也就是校验值，用来校验你是否有权限访问和修改域名解析。然后慢慢调试，在查看文档和阿里云公开的代码，发现有几个大坑，而在文档上却没有说明，当然也可能和每个编程工具的处理有点小关系，现在将每个大坑一一的说明下：
坑1：做签名值的时候，发现调试出来的签名值很长，几乎是官方计算出来的两到三倍，代码仔细看看没什么打问题，已经按照文档要求使用了URL编码后再进行HMAC_SHA1然后最后再进行BASE64编码，整个过程都没任何问题，而且编码函数经过测试也没问题。文档上也没有任何说明要做其他的编码或者转变。后来发现惊醒HMAC_SHA1编码的时候，一定要生成他的原始二进制数据，而我们正常情况下一般都是生成字符串数据，我了了个去！好了，现在生成的签名值已经和官方的签名值的长度一模一样。
Pascal
var sSignByte: TBytes; begin // 构造用于签名的字符串 Result := Format('GET&amp;%s&amp;%s', [TURI.URLEncode('/'), TURI.URLEncode(sCanonicalQueryString)]); // 使用HMAC-SHA1计算返回原始二进制数据 sSignByte := THashSHA1.GetHMACAsBytes(Result, sKeyScret + '&amp;'); // 得到签名值 Result := TURI.URLEncode(TNetEncoding.Base64.EncodeBytesToString(sSignByte)); end; 坑2：这下自以为没问题了，但是生成的签名值一直没官方的不一样啊，编码前的原始字符串貌似也一模一样，就是生成的签名值确实另外一个值，无奈，只能又是一步一步调试并且每一步和官方的值做对比，突然发现，UTC时间经过URL编码后会把里面的时间分隔符的"："会编码上"%3A"，在生成签名值前，再进行一次URL编码，官方的会把签名的“%3A”里面的"%"再进行一次编码，变成了"%253A"，而在Delphi中却没有编码，在我的理解中，确实不需要再编码了啊，因为这里已经按URL编码过一次了，这也算是一个坑吧，没办法，只能按照阿里云的要求，对其中的%再进行一次单独的替换。所以就有了下面代码的最后2行代码。
Pascal
sBody := Format('AccessKeyId=%s&amp;Action=DescribeSubDomainRecords&amp;Format=json&amp;SignatureMethod=HMAC-SHA1&amp;', [sKey.Trim]); sBody := sBody + Format('SignatureNonce=%s&amp;SignatureVersion=1.0&amp;SubDomain=%s&amp;', [GetNowStr, LowerCase(sDomain.Trim)]); sBody1 := sBody + Format('Timestamp=%s&amp;Version=2015-01-09', [GetUTC]); sBody := sBody + Format('Timestamp=%s&amp;Version=2015-01-09', [GetUTC.Replace('%', '%25')]); 坑3：获取UTC时间，UTC时间也就是我们说的世界标准时间，正常我们获取UTC时间都是带毫秒的，这个一点问题都没有，而且也都是ISO8601的标准对时间进行格式化，但是我发现，在生成签名值的时候，和官方算出来的虽然一模一样，但是每次还是提示签名值不对，这个坑整整耗了我一天时间，百思不得其解。后来仔细对比，官方获取的UTC时间只精确到秒，而我获取的UTC时间是精确到毫秒，理论上这个没太大的关系，但是我尝试和官方同步使用精确到秒之后，这个问题竟然给解决了。
Pascal
function GetUTC: string; // 获取ISO8601格式的UTC世界标准时间 var pTime: _TIME_ZONE_INFORMATION; begin GetTimeZoneInformation(pTime); // 自带的函数带有毫秒，在Update的时候签名值出错，所以使用不带毫秒的时间 // Result := TURI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb5ec7db51628923a282d242c007512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36bc7d4869a534e143962875468ed66e/" rel="bookmark">
			零信任（Zero Trust）：理论与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零信任 （Zero Trust） 网络安全原则强调在组织内外始终不假设信任，并要求对每一个通信尝试进行严格的验证。无论是来自外部的访问请求还是内部网络的数据访问，零信任模型均要求对其进行细致的审查。
用一个简洁的口号来概括，那就是：“信任无处，验证至上”。
零信任模型关键原则 零信任模型遵循以下核心指导原则：
对内对外均不给予自动信任。对所有入站和出站请求执行彻底验证。连续监控用户与设备活动，确保检测出任何非正常动向。对发现的任何异常或可疑行动，立即实施阻断措施。 零信任模型的明显优势包括：
加强防御：强制执行用户和设备的验证，降低攻击成功概率。风险最小化：实时监控可早期发觉并应对安全风险。增加敏捷性：更好地适应新兴服务和设备，如云平台和物联网。控制成本：通过强化防御减少安全漏洞，降低相关开销。 实施零信任安全的策略方法 构建零信任安全结构通常包括以下步骤：
策略与原则定义
明确定义零信任安全策略并获取全方位支持，执行"最小必要权限"原则，对访问权限进行精准控制。敏感数据和资产的识别
对网络资源进行全面扫描，识别关键数据和资产的存放位置，与需要进行交互的用户和设备。网络微细分
对网络进行分区，减小潜在威胁的影响范围，对每个区块定制访问政策。强化多因素认证
实施多因素验证，确保身份核实更为严格。动态访问控制
根据情境信息对访问权限进行实时调整，以迅速反应潜在风险。监控与记录
加强监控，以即时发现异常行为，维持完整的日志以供后续分析和审计。利用安全分析与自动化
使用高级安全分析工具，自动化威胁检测和应对，减少人为失误。不断的验证和优化
定期更新访问控制和安全设置，持续开展安全培训和意识提高活动。 结合 API 工具进行零信任实践 Apifox 是一款集成了 API 文档、测试、Mock 和 自动化测试 功能的平台，可帮助开发人员更有效地进行 API 的管理与协作。
结合 Apifox 实行零信任模型，可以提高接口管理的安全性：
接口权限控制
在 Apifox 中控制接口权限，确保每次使用经过认证和授权，遵守零信任原则。 执行访问控制
利用 Apifox 设置如 API 秘钥、OAuth 2.0 或 JWT 等访问控制策略，保证 API 测试合规。 API 安全测试
集成的测试功能可用于验证 API 安全 措施的有效性，如权限验证和抵御常见漏洞攻击。日志和请求追踪
Apifox 记录详尽请求日志，有助于监控异常行为并作安全事件回溯分析。 Mock 服务
利用 Apifox Mock 服务进行独立测试，减少对真实环境的操作风险。 通过以上实践，可以看出零信任与 Apifox 的结合有助于维护接口级别的安全防护。尽管如此，要完全实施零信任策略需要整个组织的安全政策和程序相互配合，Apifox 作为安全实践中的一部分，应当与其他安全工具、策略形成协同效应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36bc7d4869a534e143962875468ed66e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9332e11187cc3b964d452da1102b383a/" rel="bookmark">
			梯度消失与梯度爆炸的问题小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考李沐老师动手深度学习,上篇激活函数有遇到这个问题我们来深入探讨一下
文章目录 前言
一、梯度爆炸
二、梯度爆炸的问题
三、梯度消失
四.梯度消失的问题
总结
前言 到目前为止，我们实现的每个模型都是根据某个预先指定的分布来初始化模型的参数。 有人会认为初始化方案是理所当然的，忽略了如何做出这些选择的细节。甚至有人可能会觉得，初始化方案的选择并不是特别重要。 相反，初始化方案的选择在神经网络学习中起着举足轻重的作用， 它对保持数值稳定性至关重要。 此外，这些初始化方案的选择可以与非线性激活函数的选择有趣的结合在一起。 我们选择哪个函数以及如何初始化参数可以决定优化算法收敛的速度有多快。 糟糕选择可能会导致我们在训练时遇到梯度爆炸或梯度消失。
4.8. 数值稳定性和模型初始化 — 动手学深度学习 2.0.0 documentation (d2l.ai)
一、梯度爆炸 首先我们就需要回顾一下反向传播求导的计算.也就是我们的链式法则,以及对梯度下降法的原理大致了解.
这个d-t很大也就是我们的深度很大这样累乘起来就会得到一个很大很大的值.
二、梯度爆炸的问题 三、梯度消失 最典型的例子就是我们的sigmoid函数,这个函数我们在激活函数中简单了解了一下什么叫梯度消失.
蓝色线为sigmoid函数图像,黄色是sigmoid梯度.
可见当梯度很小时,深度越深,这样累乘起来就会得到很小的数.导致梯度变化很小.
四.梯度消失的问题 梯度反向传播时对于底部,通过链式法则的累乘,梯度变化很小,所以跟那些深度很小的神经网络差不多.
总结 当数值过大或过小时会导致数值问题.
常常发生在深度模型当中,因为会对n个累乘.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32718c884a60051e50a8496d5f7eb826/" rel="bookmark">
			修改安卓apk设置为安卓主屏幕（launcher）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改安卓apk 将apk可以设置安卓主屏幕 原理： 将打包好的apk文件进行拆包增加配置文件在重新编译回apk包
需要得相关文件下载 解包 apktool :https://pan.baidu.com/s/1oyCIYak_MHDJCvDbHj_qEA?pwd=5j2xdex2jar：https://pan.baidu.com/s/1Nc-0vppVd0GPnD6_Y-SRBA?pwd=cmkejd-gui：https://pan.baidu.com/s/1ckfGv0cyzC7e-DA3lDdv4w?pwd=l0lz 签名 用来将编译好的包重新签名。
Auto-Sign：https://pan.baidu.com/s/1foGt50h4EWQNjFvyTGQWDg?pwd=d9f1 开始解包 为了方便，把工具（apktool.jar）和apk文件放在一个文件夹中*(非必须，本人把apk复制到了文件夹里面)；
java -jar apktool.jar d -f card.apk -o card --only-main-classes 解包之后得
进入card文件夹 找到 AndroidManifest.xml
用编辑器打开且全局搜索 android:name="io.dcloud.PandoraEntry"
在里面新增下面四行代码
&lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;category android:name="android.intent.category.HOME"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; 编译回apk 新建一个apktool.bat文件用记事本编辑新增内容，文件存位置。
@echo off if "%PATH_BASE%" == "" set PATH_BASE=%PATH% set PATH=%CD%;%PATH_BASE%; chcp 65001 2&gt;nul &gt;nul java -jar -Duser.language=en -Dfile.encoding=UTF8 "%~dp0\apktool.jar" %* 用管理员的方式打开cmd 并且切换到 文件位置
file 是解包出来的文件夹
apktool b card 解出来之后会在文件夹下的dist文件下面
重新签名 https://pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32718c884a60051e50a8496d5f7eb826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d07fdb65a0636d39da1a1d728b24a0/" rel="bookmark">
			自动驾驶HWP对HMI显示需求规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概述... 6
1.1 目的... 6
1.2 范围... 6
1.3 术语及缩写... 6
1.4 设计与实验标准... 6
1.4.1 设计标准... 6
2 HMI交互需求... 7
2.1 HWP功能界面... 7
2.2 HMI信号需求... 7
2.2.1 输入信号... 7
2.2.2 输出信号... 7
2.3 HWP功能交互策略... 8
2.3.1 界面主题... 8
2.3.2 软开关交互... 8
2.3.3 硬开关交互... 8
2.3.4 手势操作交互... 8
2.3.5 界面重叠交互... 8
2.3.6 指示灯交互... 9
2.3.7 报警声音交互... 9
2.3.8 语音交互... 9
3 HMI功能需求... 10
3.1 自检需求... 10
3.2 HWC功能显示需求... 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d07fdb65a0636d39da1a1d728b24a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691efd3f05e3a9005f51d1cc35ee16dc/" rel="bookmark">
			【Python数据分析基础】: 数据缺失值处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		再好的模型，如果没有好的数据和特征质量，那训练出来的效果也不会有所提高。数据质量对于数据分析而言是至关重要的，有时候它的意义会在某种程度上会胜过模型算法。
本篇开始分享如何使用Python进行数据分析，主要侧重介绍一些分析的方法和技巧，而对于pandas和numpy等Pyhon计算包的使用会在问题中提及，但不详细介绍。本篇我们来说说面对数据的缺失值，我们该如何处理。文末有博主总结的思维导图。
1 数据缺失的原因 首先我们应该知道：数据为什么缺失？数据的缺失是我们无法避免的，可能的原因有很多种，博主总结有以下三大类：
无意的：信息被遗漏，比如由于工作人员的疏忽，忘记而缺失；或者由于数据采集器等故障等原因造成的缺失，比如系统实时性要求较高的时候，机器来不及判断和决策而造成缺失；有意的：有些数据集在特征描述中会规定将缺失值也作为一种特征值，这时候缺失值就可以看作是一种特殊的特征值；不存在：有些特征属性根本就是不存在的，比如一个未婚者的配偶名字就没法填写，再如一个孩子的收入状况也无法填写； 总而言之，对于造成缺失值的原因，我们需要明确：是因为疏忽或遗漏无意而造成的，还是说故意造成的，或者说根本不存在。只有知道了它的来源，我们才能对症下药，做相应的处理。
2 数据缺失的类型 在对缺失数据进行处理前，了解数据缺失的机制和形式是十分必要的。将数据集中不含缺失值的变量称为完全变量，数据集中含有缺失值的变量称为不完全变量。而从缺失的分布来将缺失可以分为完全随机缺失，随机缺失和完全非随机缺失。
完全随机缺失（missing completely at random,MCAR）：指的是数据的缺失是完全随机的，不依赖于任何不完全变量或完全变量，不影响样本的无偏性，如家庭地址缺失；随机缺失(missing at random,MAR)：指的是数据的缺失不是完全随机的，即该类数据的缺失依赖于其他完全变量，如财务数据缺失情况与企业的大小有关；非随机缺失(missing not at random,MNAR)：指的是数据的缺失与不完全变量自身的取值有关，如高收入人群不原意提供家庭收入； 对于随机缺失和非随机缺失，直接删除记录是不合适的，原因上面已经给出。随机缺失可以通过已知变量对缺失值进行估计，而非随机缺失的非随机性还没有很好的解决办法。
3 数据缺失的处理方法 重点来了，对于各种类型数据的缺失，我们到底要如何处理呢？以下是处理缺失值的四种方法：删除记录，数据填补，和不处理。
1. 删除记录 优点：
最简单粗暴； 缺点：
牺牲了大量的数据，通过减少历史数据换取完整的信息，这样可能丢失了很多隐藏的重要信息；当缺失数据比例较大时，特别是缺失数据非随机分布时，直接删除可能会导致数据发生偏离，比如原本的正态分布变为非正太； 这种方法在样本数据量十分大且缺失值不多的情况下非常有效，但如果样本量本身不大且缺失也不少，那么不建议使用。
Python中的使用： 可以使用 pandas 的 dropna 来直接删除有缺失值的特征。
#删除数据表中含有空值的行 df.dropna(how='any') 2. 数据填补 对缺失值的插补大体可分为两种：替换缺失值，拟合缺失值，虚拟变量。替换是通过数据中非缺失数据的相似性来填补，其核心思想是发现相同群体的共同特征，拟合是通过其他特征建模来填补，虚拟变量是衍生的新变量代替缺失值。
替换缺失值
均值插补： 对于定类数据：使用 众数（mode）填补，比如一个学校的男生和女生的数量，男生500人，女生50人，那么对于其余的缺失值我们会用人数较多的男生来填补。
对于定量（定比）数据：使用平均数（mean）或中位数（median）填补，比如一个班级学生的身高特征，对于一些同学缺失的身高值就可以使用全班同学身高的平均值或中位数来填补。一般如果特征分布为正太分布时，使用平均值效果比较好，而当分布由于异常值存在而不是正太分布的情况下，使用中位数效果比较好。
注：此方法虽然简单，但是不够精准，可能会引入噪声，或者会改变特征原有的分布。 下图左为填补前的特征分布，图右为填补后的分布，明显发生了畸变。因此，如果缺失值是随机性的，那么用平均值比较适合保证无偏，否则会改变原分布。
Python中的使用： #使用price均值对NA进行填充 df['price'].fillna(df['price'].mean()) df['price'].fillna(df['price'].median()) 热卡填补（Hot deck imputation）： 热卡填充法是在完整数据中找到一个与它最相似的对象，然后用这个相似对象的值来进行填充。通常会找到超出一个的相似对象，在所有匹配对象中没有最好的，而是从中随机的挑选一个作为填充值。这个问题关键是不同的问题可能会选用不同的标准来对相似进行判定，以及如何制定这个判定标准。该方法概念上很简单，且利用了数据间的关系来进行空值估计，但缺点在于难以定义相似标准，主观因素较多。
K最近距离邻法（K-means clustering） 另外一种方法就是利用无监督机器学习的聚类方法。通过K均值的聚类方法将所有样本进行聚类划分，然后再通过划分的种类的均值对各自类中的缺失值进行填补。归其本质还是通过找相似来填补缺失值。
注：缺失值填补的准确性就要看聚类结果的好坏了，而聚类结果的可变性很大，通常与初始选择点有关，并且在下图中可看到单独的每一类中特征值也有很大的差别，因此使用时要慎重。
拟合缺失值
拟合就是利用其它变量做模型的输入进行缺失变量的预测，与我们正常建模的方法一样，只是目标变量变为了缺失值。
注：如果其它特征变量与缺失变量无关，则预测的结果毫无意义。如果预测结果相当准确，则又说明这个变量完全没有必要进行预测，因为这必然是与特征变量间存在重复信息。一般情况下，会介于两者之间效果为最好，若强行填补缺失值之后引入了自相关，这会给后续分析造成障碍。
利用模型预测缺失变量的方法有很多，这里仅简单介绍几种。
回归预测： 如我们之前提到的房价预测项目一样数据分析实战—北京二手房房价分析（建模篇），基于完整的数据集，建立回归方程。对于有缺失值的特征值，将已知特征值代入模型来估计未知特征值，以此估计值来进行填充，以下图为例。当然关于回归的方法有很多，这里就不详细介绍了。
缺失值是连续的，即定量的类型，才可以使用回归来预测。
极大似然估计（Maximum likelyhood）： 在缺失类型为随机缺失的条件下，假设模型对于完整的样本是正确的，那么通过观测数据的边际分布可以对未知参数进行极大似然估计（Little and Rubin）。这种方法也被称为忽略缺失值的极大似然估计，对于极大似然的参数估计实际中常采用的计算方法是期望值最大化(Expectation Maximization，EM）。该方法比删除个案和单值插补更有吸引力，它一个重要前提：适用于大样本。有效样本的数量足够以保证ML估计值是渐近无偏的并服从正态分布。但是这种方法可能会陷入局部极值，收敛速度也不是很快，并且计算很复杂，且仅限于线性模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691efd3f05e3a9005f51d1cc35ee16dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48bb9eca4ae68f19a6a63665fd8e9dc7/" rel="bookmark">
			基于Java SSM框架实现旅游资源网站系统项目【项目源码&#43;论文说明】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的SSM框架实现旅游资源网站系统演示
摘要 本论文主要论述了如何使用JAVA语言开发一个旅游资源网站 ，本系统将严格按照软件开发流程进行各个阶段的工作，采用B/S架构，面向对象编程思想进行项目开发。在引言中，作者将论述旅游资源网站的当前背景以及系统开发的目的，后续章节将严格按照软件开发流程，对系统进行各个阶段分析设计。
旅游资源网站的主要使用者分为管理员和用户，实现功能包括管理员：首页、个人中心、用户管理、景点信息管理、购票信息管理、酒店信息管理、客房类型管理、客房信息管理、客房预订管理、交流论坛、系统管理，用户：首页、个人中心、购票信息管理、客房预订管理、我的收藏管理，前台首页；首页、景点信息、酒店信息、客房信息、交流论坛、红色文化、个人中心、后台管理、客服等功能。由于本网站的功能模块设计比较全面，所以使得整个旅游资源网站信息管理的过程得以实现。
本系统的使用可以实现旅游资源网站管理的信息化，可以方便管理员进行更加方便快捷的管理，可以提高管理人员的工作效率。
关键词：旅游资源网站 JAVA语言；MYSQL数据库；SSM 框架 研究背景 随着网络不断的普及发展，旅游资源网站依靠网络技术的支持得到了快速的发展，首先要从用户的实际需求出发，通过了解用户的需求开发出具有针对性的旅游资源网站管理，利用目前网络给用户带来的方便快捷这一特点对系统进行调整，设计的系统让用户的使用起来更加方便，本系统的主要目的就是给用户带来快捷与高效、安全，用户只要在家中就可以进行操作[1]。同时随着电子商务的发展旅游资源网站已经受到广大用户的关注。
互联网发展至今，已经解决了很多我们解决不了的难题，使得我们工作更加便捷，提高了我们的工作效率。目前各行各业都在运用网络信息管理程序，不同的用户也都接触到信息管理，特别是在各大电商行业广泛的应运起来。通过对当前网络环境发展的分析与总结，开发旅游资源网站可以改变以往的管理方式，改变传统线下旅游资源网站的状态，由于用户的不断增多，使用传统的线下手工模式已经远远不能满足于用户需求了，而且越来越多的旅行社也在开通线上进行旅游资源网站，所以开发一个旅游资源网站可以解决旅行社不利于线下旅游资源的问题，同时旅行社可以利用网络对旅游资源网站信息进行管理，设计的网站保证信息的完整安全，这样才能提高工作效率，保证系统安全正常的运行[2]。
研究现状 在国外他们的信息技术的发展是我国的许多倍，从1946年诞生在美国的世界上第一台计算机开始，国外的信息技术就一直在飞速地发展，一些计算机应用软件也纷纷出现，软件技术也一直在不断完善和更新[3]。软件行业早已遍布各个地方。
在国内，我国信息技术发展起步比较晚，后期慢慢的不断地进行优化和改革，才让我们的信息技术上升到新的阶段。在现在软件开发的技术经过大量研究和生活实践基本能够达到独立开发系统应用的水平，生活中的各个行业也把软件操作替换成传统的记录模式。软件行业正是现在比较热门的行业[4]。
社会主义进入新时代，经济实力越来越强。我们也变得越来越忙碌、对生活的要求也变得更加严格，对快速和方便的服务的需求也在逐渐增加，所以旅游资源网站的开发给用户带来了足够的便利，用户通过系统来满足生活中的需求，因此，由于信息的增加，信息处理系统也随之增加，通过网络来满足现代用户需求[5]。此次开发设计主要是实现旅游资源网站 ，结合java技术以及MYSQL数据库进行设计，弥补目前在线旅游资源网站中的不足，来开发出一款即方便又实用的旅游资源网站 ，并且设计的程序具有界面整洁、功能强大等特性，从全局来说，旅游资源网站的设计解决了信息零散，该系统实现，可以投入到真实环境中，这样不仅能解决以上提及的问题，让信息管理更准则。
研究内容 该旅游资源网站的开发和设计根据用户的实际情况出发，对系统的需求进行了详细的分析，然后进行系统的整体设计，最后通过测试使得系统设计的更加完整，可以实现系统中所有的功能，在开始编写论文之前亲自到图书馆借阅SSM 框架书籍，MYSQL数据库书籍等编程书籍，然后针对开发的旅游资源网站 ，去网上查找了很多别人做好的系统，参照他们的设计结果，来对自己的系统进行更加详细的系统的设计，将系统中所有的功能结果一一列举出来，然后进行需求分析，最后对所有的功能模块进行编码，最后完成系统的整体测试，实现系统的正常运行[6]。
这次编写的论文包含了6个部分的内容，具体内容如下：
第一部分绪论：文章主要从课题背景以及研究现状综合阐述了开发此系统的必要性。
第二部分相关技术：系统开发用到的各种技术都大致做出了简介。
第三部分系统分析：对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
第四部分系统设计：功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
第五部分系统实现：进行系统主要功能模块的界面展示。
第六部分系统测试：测试系统的每一个功能是否能够正常运行，是否可以满足用户的需求。
系统结构设计 整个系统是由多个功能模块组合而成的，要将所有的功能模块都一一列举出来，然后进行逐个的功能设计，使得每一个模块都有相对应的功能设计，然后进行系统整体的设计。
本旅游资源网站结构图如图4-2所示。
系统页展示 旅游资源网站 ，在系统首页可以查看首页、景点信息、酒店信息、客房信息、交流论坛、红色文化、个人中心、后台管理、客服等内容，如图5-1所示。
景点信息，在景点信息页面通过填写景点名称、景点图片、景点等级、景点地址、门票价格、开放时间、购票须知等信息进行购票，如图5-3所示。
在酒店信息页面通过填写酒店名称、图片、星级、酒店类型、酒店地址、联系电话等信息进行点我收藏操作，如图5-4所示。
用户管理，在用户管理页面中可以通过填写用户名、密码、姓名、性别、头像、手机、身份证等内容进行修改、删除，如图5-6所示。
还可以根据需要对景点信息管理进行详情，修改或删除等详细操作，如图5-7所示。
如需要可扫取文章下方二维码联系得源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e5ae6eee28913ddcf1552705f517b6/" rel="bookmark">
			GoogleNetv1：Going deeper with convolutions更深的卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 GoogleNetv1全文翻译论文结构摘要1 引言2 相关工作3 动机和高层考虑稀疏矩阵 4 结构细节引入1x1卷积核可以减少通道数 5 GoogleNet6 训练方法7 ILSVRC 2014 分类挑战赛设置和结果8 ILSVRC 2014检测挑战赛设置和结果目标检测的平均精度和 [mAP](https://towardsdatascience.com/breaking-down-mean-average-precision-map-ae462f623a52) 9 总结 论文研究背景、成果及意义论文图表论文代码复现准备工作GoogleNetv1推理代码及运行结果GoogleNetv1训练代码及运行结果 GoogleNetv1全文翻译 论文结构 摘要 我们提出了一种代号为 Inception 的深度卷积神经网络架构，它负责在 2014 年 ImageNet 大规模视觉识别挑战赛（ILSVRC14）中为分类和检测设定新的技术水平。 该架构的主要特点是提高了网络内部计算资源的利用率。 这是通过精心设计的设计实现的，该设计允许增加网络的深度和宽度，同时保持计算预算不变。 为了优化质量，架构决策基于 Hebbian 原理和多尺度处理的直觉。 我们提交的 ILSVRC14 中使用的一种特殊形式称为 GoogLeNet，这是一种 22 层深度网络，其质量是在分类和检测的背景下进行评估的。
1 引言 在过去三年中，主要由于深度学习（更具体地说是卷积网络）[10]的进步，图像识别和目标检测的质量取得了巨大的进步。 一个令人鼓舞的消息是，大部分进展不仅是更强大的硬件、更大的数据集和更大的模型的结果，而主要是新想法、算法和改进的网络架构的结果。 例如，ILSVRC 2014 竞赛中的顶级参赛作品除了用于检测目的的同一竞赛的分类数据集外，没有使用任何新的数据源。 我们向 ILSVRC 2014 提交的 GoogLeNet 实际上使用的参数比两年前 Krizhevsky 等人 [9] 的获胜架构少了 12 倍，同时明显更加准确。 目标检测的最大收益并非来自单独使用深层网络或更大的模型，而是来自深层架构和经典计算机的协同作用视觉，如 Girshick 等人的 R-CNN 算法 [6]。
另一个值得注意的因素是，随着移动和嵌入式计算的持续发展，我们算法的效率（尤其是其功耗和内存使用）变得越来越重要。 值得注意的是，本文提出的深层架构设计的考虑因素包括了这个因素，而不是纯粹关注准确率数字。 对于大多数实验，模型的设计目的是在推理时保持 15 亿次乘加的计算预算，因此它们最终不会成为纯粹的学术好奇心，而是可以应用于现实世界，甚至以合理的成本处理大型数据集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e5ae6eee28913ddcf1552705f517b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e113704a5d0063688999cce5be31240/" rel="bookmark">
			全网最低价——组合预测模型全家桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		往期精彩内容： 时序预测：LSTM、ARIMA、Holt-Winters、SARIMA模型的分析与比较-CSDN博客
风速预测（一）数据集介绍和预处理-CSDN博客
风速预测（二）基于Pytorch的EMD-LSTM模型-CSDN博客
风速预测（三）EMD-LSTM-Attention模型-CSDN博客
风速预测（四）基于Pytorch的EMD-Transformer模型-CSDN博客
风速预测（五）基于Pytorch的EMD-CNN-LSTM模型-CSDN博客
风速预测（六）基于Pytorch的EMD-CNN-GRU并行模型-CSDN博客
CEEMDAN +组合预测模型(BiLSTM-Attention + ARIMA)-CSDN博客
CEEMDAN +组合预测模型(CNN-LSTM + ARIMA)-CSDN博客
CEEMDAN +组合预测模型(Transformer - BiLSTM+ ARIMA)-CSDN博客
CEEMDAN +组合预测模型(CNN-Transformer + ARIMA)-CSDN博客
包括 完整的风速数据集， 以及已经生成制作好的数据集、标签，对应代码均可以运行
包括数据CEEMDAN预处理的代码，和完整 组合预测 模型代码、可视化代码、模型评估代码
环境：python 3.9
任何环境安装或者代码问题，请联系作者沟通交流
1.CEEMDAN +(BiLSTM-Attention+ARIMA)组合预测模型
2.CEEMDAN +组合(CNN-LSTM+ARIMA)预测模型
3.CEEMDAN+(Transformer-BiLSTM+ARIMA)组合预测模型
4.CEEMDAN+(CNN-Transformer+ARIMA)组合预测模型
5.基于Python时序预测：LSTM、ARIMA、Holt-Winters、SARIMA模型的分析与比较
​
​
代码全家桶 时序预测模型
1.单步预测模型（一）LSTM
2.单步预测模型（二）CNN-LSTM模型
3.单步预测模型（三）CNN-GRU并行模型
4.Pytorch风速预测：基于EMD-LSTM的预测模型
5.Pytorch风速预测：EMD-Transformer模型
6.风速预测：EMD-LSTM-Attention(基于Pytorch实现)
7.风速预测：EMD-CNN-LSTM模型(基于Pytorch实现)
8.风速预测：EMD-CNN-GRU并行模型(基于Pytorch实现)
​
轴承故障诊断
1.Python-凯斯西储大学（CWRU）轴承数据解读与分类处理
2.Python轴承故障诊断时频图像处理-短时傅里叶变换STFT
3.Python轴承故障连续小波变换-代码与时频图像分类
4.Pytorch-LSTM轴承故障一维信号分类
5.Pytorch-CNN轴承故障一维信号分类
6.Pytorch-Transformer轴承故障一维信号分类
7.Python基于EMD-LSTM轴承故障分类
8.Python基于EMD-CNN轴承故障分类
9.Python基于EMD-Transformer轴承故障分类
​
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/6/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>