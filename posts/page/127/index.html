<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1adb68d6403c6ea96d858c81d915448c/" rel="bookmark">
			VMware16安装Ubuntu16.04.7虚拟机（最全步骤&#43;踩坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装准备 环境：VMware Pro 16.2.1
镜像：ubuntu 16.04.7
2. 安装VMware 官网地址：VMware
3. 下载Ubuntu 官网地址：Ubuntu
我是 64 位的机器，所以直接选择下载 64 位的镜像
4. 在 VMware 下创建 Linux 虚拟机 1、创建虚拟机，在vmware主界面的 “主页” 标签点击创建虚拟机向导。如下图所示。
2、向导界面选择“自定义高级”，如下图所示。
3、然后下一步，兼容性选择当前 vmware 版本，如下所示。
4、下一步，选择你刚下载的镜像文件，如下所示。
5、下面的信息是 Ubuntu 使用的信息，即 linux 的用户名和口令，设置完后请注意保存。
6、下一步，虚拟机名称可以随便取。“位置” 就是将来虚拟机文件所在的目录，因为虚拟机文件比较大，要选择一个磁盘空间比较大的目录。
7、下一步，设置要分配给虚拟机的CPU，电脑配置高的可以往上调，如果要同时运行两个以上虚拟机就少分配一点，一般采用默认值就可以。
8、下一步，Ubuntu16 和 18 内存一般采用默认 4G 比较合适。
9、网络配置，如果公司局域网里有足够的 IP，就用桥接网络，否则就用 NAT 模式。
10、硬盘控制器，没有特殊情况就选默认值。
11、硬盘类型，没有特殊情况就选默认值。
12、创一个新的磁盘，如果使用单独物理磁盘的选第三项。
13、磁盘空间，一般默认 20G 就够了，如果要装的软件特别多就多分配一点，一般空的 Ubuntu16 装完占用 10G 左右，剩 10G 软件空间。磁盘文件选单个文件，否则文件数量比较多，不利于分发和管理。（我这里给了 40G ）
14、磁盘文件名，使用默认就好了。
15、到这一步就创建完一个虚拟机了，如下。如果对刚才的配置不满意可以点 “自定义” 进一步修改。
点击 “完成”，虚拟机就会自动运行，然后开始安装啦！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1adb68d6403c6ea96d858c81d915448c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13826fafaf073e211cf7af84c4ad592a/" rel="bookmark">
			模型微调(finetune)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		----接上次的鸟的图像分类，其acc为84%。
这次依然使用此数据集，并用resenet网络进行finetune，然后进行鸟的图像分类。
1、什么是finetune？ 利用已训练好的模型进行重构（自己的理解）。 对给定的预训练模型（用数据训练好的模型）进行微调，直接利用预训练模型进行微调可以节省许多的时间，能在比较小的epoch下就达到比较好的效果。通常进行微调，1、自己构建模型效果差，所以采用一些常用的模型，别人用数据训好的。2、数据量不够大，所以采用微调。以下是模型微调的例子：
2、数据为鸟类的数据集，其一共有4个类别，如下所示：
1、数据的类别
2、图像数据
数据的前期处理和划分，划分可以用random.shuffule直接进行打乱，然后划分。
2、数据导入 import torch from torch.utils.data import DataLoader from torchvision import transforms from PIL import Image import numpy as np random_seed = 1 torch.manual_seed(random_seed) transform = transforms.Compose([ # transforms.RandomRotation(1), transforms.Resize(224), # transforms.CenterCrop(224), # transforms.ToTensor(), # 将图片(Image)转成Tensor，归一化至[0, 1] transforms.Normalize(mean=[.5,.5,.5], std=[.5,.5,.5]), # 标准化至[-1, 1]，规定均值和标准差 ]) transform1 = transforms.Compose([ # transforms.RandomRotation(1), # transforms.Resize(224), # # transforms.CenterCrop(224), # 从图片中间切出224*224的图片 transforms.ToTensor(), # 将图片(Image)转成Tensor，归一化至[0, 1] transforms.Normalize(mean=[.5,.5,.5], std=[.5,.5,.5]), # 标准化至[-1, 1]，规定均值和标准差 # transforms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13826fafaf073e211cf7af84c4ad592a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4522c227c3b45f674865e675aad3d1a9/" rel="bookmark">
			Java的.replace()优化（重写）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：今天刚好看到一篇重写replace性能提升了10倍的文章，里面的replace方法改造我觉得挺有意思，而且性能提升很夸张，我一看就心动了，代码我做了下改造比较贴近我们常用的.replace()替换方法，直接上代码。
public class StringUtils { public static String replace(String content,String oldChar, String newChar){ int beginIndex = 0; int endIndex = 0; StringBuffer stringBuffer = new StringBuffer(); if(isNotEmpty(content)&amp;&amp;isNotEmpty(oldChar)){ int len = oldChar.length(); beginIndex = content.indexOf(oldChar,0); if(beginIndex&gt;0){ stringBuffer.append(content,0,beginIndex); } stringBuffer.append(newChar); while (beginIndex !=-1){ endIndex = content.indexOf(oldChar,beginIndex+len); if(endIndex == -1){ stringBuffer.append(content.substring(beginIndex+len)); beginIndex=-1; continue; } stringBuffer.append(content,beginIndex+len,endIndex); stringBuffer.append(newChar); beginIndex = content.indexOf(oldChar,endIndex+len); if(beginIndex-endIndex&gt;=1){ stringBuffer.append(content,endIndex+len,beginIndex); stringBuffer.append(newChar); } } if(endIndex!=-1){ stringBuffer.append(content.substring(endIndex+len)); } }else{ return content; } return stringBuffer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4522c227c3b45f674865e675aad3d1a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4279cfb4cca78926a100ba6fba74a6d1/" rel="bookmark">
			Linux驱动-设备树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在Linux内核没有引进设备树之前，每一个具体的硬件平台都会在 linux 源码包 arch/arm/mach-xxx/ 目录下存在一个硬件信息描述的源码包，其中定义了 GPIO、I2C 等外设和系统信息。这些信息也定义为 .h、.c 文件，内容多为描述设备信息的结构体，同驱动源码一起编译。这就会在内核中增加了许多没有技术含量的.c文件。Linux的祖师爷Linus看到这种现象后就大发雷霆："this whole ARM thing is a f*cking pain in the ass"，所以为了解决这种现象，从linux-3.x版本开始引进了设备树。
什么是设备树？ 设备树（Device Tree）将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等。 在Linux内核源码中，ARM架构的设备树文件一般位于 linux 源码的 arch/arm/boot/dts 目录，对应 .dts(device tree source) 后缀的文件。dts 文件可以通过make dtbs 命令编译成 .dtb(device tree blob) 后缀的二进制文件，以供内核驱动使用。
概念 dts (device tree source) 设备树描述文件，硬件的相应信息都会写在.dts为后缀的文件中，每一款硬件可以单独写一份xxxx.dts，一般在Linux源码中存在大量的dts文件，对于 arm 架构可以在 arch/arm/boot/dts 目录下找到相应dts文件。
dtsi (device tree sourceinclude) 设备树头文件，对于一些相同的dts配置可以抽象到dtsi文件中，然后类似于 C 语言的方式可以include到dts文件中，对于同一个节点的设置情况，dts中的配置会覆盖dtsi中的配置；dtsi是关于芯片级别的描述。
dtc (device tree compiler) 设备树编译器，编写 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4279cfb4cca78926a100ba6fba74a6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a9e946b0be828adef68988050a445b/" rel="bookmark">
			Pyside2&amp;PyQt5设置背景图片不影响其它控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyside2&amp;PyQt5设置背景图片
平时我们在Designer中的styleSheet设置背景图片会导致其它控件也会被设置上背景图片。（如果一定要用Designer解决方法在下面）
为解决这个问题，在代码中按如下设置即可单独设置背景图不影响其它。图片会随着窗口的尺寸变化自适应改变大小。
核心代码： self.centralwidget.setObjectName("wkWgt") # 替换背景图片只对当前窗口生效 核心代码 self.centralwidget.setStyleSheet("#wkWgt{border-image:url(C:/User/变色龙.jpg);}") # 替换图片路径 核心代码 完整案例 from PySide2 import QtCore, QtGui, QtWidgets from PySide2.QtWidgets import QMainWindow, QApplication,QMessageBox import sys class Ui_MainWindow(QMainWindow): def __init__(self, parent=None): super(Ui_MainWindow, self).__init__(parent) self.setupUi(self) def setupUi(self, MainWindow): MainWindow.setObjectName("MainWindow") MainWindow.resize(518, 421) self.centralwidget = QtWidgets.QWidget(MainWindow) self.centralwidget.setObjectName("wkWgt") # 替换背景图片只对当前窗口生效 核心代码 self.centralwidget.setStyleSheet("#wkWgt{border-image:url(C:/User/变色龙.jpg);}") # 替换图片路径 核心代码 self.pushButton = QtWidgets.QPushButton(self.centralwidget) self.pushButton.setGeometry(QtCore.QRect(20, 330, 201, 61)) self.pushButton.setObjectName("pushButton") MainWindow.setCentralWidget(self.centralwidget) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate("MainWindow", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58a9e946b0be828adef68988050a445b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3500bab3daf5a50326bce58c7a03be5/" rel="bookmark">
			微信小程序——开篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开篇 前言锻造兵器开发者账号微信开发者工具 写在最后 前言 如今微信小程序已经成为我们日常生活中不可或缺的‘介质’，如我们的出行、购物、餐饮、社交、娱乐等活动的小程序已经因有尽有，相比于去安装一个app人们自然更加倾向于在微信中去直接访问某个小程序，而且我们的小程序极为方便的为用户提供服务；
疫情的来袭我们各地方都针对的上架了健康码、疫苗接种、健康宝、全民健康等等小程序，让用户简单的在小程序中操作为我们的防疫工作带来了很大的便捷；
微信小程序负责人曾鸣披露了2021年小程序的大盘数据。 数据显示，2021年微信小程序日活超过4.5亿，日均使用次数同比2020年增长了32%，小程序的支付用户增长了80%，并且客单价相比2020大幅提升。
具体来看，2021年累计超过7亿用户使用小程序来享受医疗服务。“除了疫苗接种、核酸等疫情防控之外，还有几千家医院都接入了小程序，用小程序来承载他们的医疗服务。”曾鸣说到。
去年累计有7.5亿用户在使用小程序的协同工具，其中，有超过一亿的用户在小程序上享受数字化的政务服务。
曾鸣披露，现在活跃小程序在稳步增长，相比2020年增长40%，其中有交易的小程序增长接近30%，而这里的增长90%都来自于中小商家，可以看到整个小程序的生态正在比较健康地、茁壮地成长。
现如今我们的微信开发人员也可以达到了300W，可见微信小程序开发的市场以及前景，其实我们很容易看出微信小程序在传统app面前的优势；
1、开发成本：app开发需要组建团队进行H5开发同时还需要嵌入安卓/ios工程师，虽然现如今我们的前端工程师也可以进行app开发，但是如果涉及到安卓/ios的适配问题，开发成本还是相对比较高的，反观微信小程序，不需要考虑安卓/ios，只需要基于微信支持即可；
2、发版问题：常规app如果应用涉及到发布到软件商城是需要一定时间的审核，尤其是ios应用发布到App Store是比较麻烦的，反观微信小程序，我们开发完成后只需要将小程序提交审核即可，速度很快；
3、用户体验：常规app需要我们的用户去商场所有应用然后进行下载安装，而我们的小程序则只需要微信中去搜索相关小程序即可，我们完全可以避免手机上安装繁多的软件，只需要一个微信即可；
上面说了这么多，相信很多人都已经对微信小程序开发充满了激情，博主也将带领大家一起来走进微信小程序中去；为了帮助大家更好的进行学习，博主刻意编写了专栏【30天拿捏微信小程序】希望能够通过这个专栏帮助你掌握微信小程序开发；手把手带你完成小程序的开发、上线、使用；下面就来开始我们的微信小程序开发之旅吧！
锻造兵器 大家都知道打仗前需要士兵‘利其兵器’其实我们准备学习一门语言也是一样的，首先我们要做好语言开发的一些兵器——开发依赖、编译器、账号等
当然我们的微信小程序开发其实还是比较简单的，只需要我们准备好自己的微信开发账号、官方推出的微信小程序开发工具；
可能有的小伙伴会问道，必须要用我们微信开发者工具吗？我是用别的 VS code、HbuilderX就不行吗？其实也不是不可以，我刚工作的时候也抛出过这样的问题，但是我觉得我们最好还是用专业的工具做专业的事
开发者账号 官方地址：https://mp.weixin.qq.com/
我们访问上面这个官方地址然后点击右上角的注册
选择小程序
然后我们按照他上面的三步完成就可以了，完成后我们可以去访问官方然后进行登录；我们可以直接通过微信扫一扫登陆即可，这就是我们微信小程序的开发控制台；
登陆成功后我们去拿到我们的 小程序的 ID
微信开发者工具 访问链接 https://developers.weixin.qq.com/miniprogram/dev/framework/
在这里我们选择稳定版，而且根据自己的电脑情况去选择版本
下载下来进行安装即可，我这里是mac，其实我们的windown也是比较简单的
安装后是这个样子的
首次打开是需要我们微信扫一扫登陆的
本期推荐
一本书打好技术基础，轻松玩转人工智能。无限制。人工智能有很多应用的使用平台，但很多平台需要注册才可以使用，本书中涉及的技术源码中有模块的支持文件，无限制，无须注册，使用起来很方便。全方位。针对人工智能主要的发展领域：应答机器人、图像识别、物体识别、语音识别、视频识别等层面都有原理的解释和应用的扩展，让读者能全方位开启对人工智能技术的认识。
内容简介
区别于市场上同类书，本书不但侧重于理论知识的普及，也将技术融合于Python模块进行实验上的操作与演示。本书主要内容包括：人工智能技术概述，人脸识别技术、物体识别技术，视频识别技术、语音识别技术、文本识别技术，区块链技术等。全书综合了各种模块对人工智能技术的实践，将分散的技术点统一起来，并把抽象的原理与适应读者思维的案例相融合，实现知识点的充分理解。
本书适合从事数据科学及AI的读者阅读。
写在最后 其实到这里我们的前期准备工作就做好了，我们拿到了微信小程序的ID，安装好了我们开发微信小程序的工具，再次强调一下其实可以开发微信小程序的代码工具很多，但是还是像上面所说的我们尽量用最专业的工具做专业事情；好啦我们下面见吧！带领大家创建属于你的第一个小程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c2c8b2eafc4dff9dd10605a42459d6/" rel="bookmark">
			Fast R-CNN讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：解决的问题二：模型结构三：训练步骤1.预训练模型2.Fine-tunningstep1:转化预训练模型step2:训练图像的RP搜索与ROI选择step3:输入网络中进行调优训练① RoI池化层② 损失函数③ 采用SVD分解改进全连接层 四：测试步骤五：Fast R-CNN的缺点 一：解决的问题 Fast R-CNN是基于R-CNN提出的，有关R-CNN的详细介绍请看R-CNN史上最全讲解。Fast R-CNN主要是为了解决R-CNN的以下几个问题：
训练分多步。通过上一篇博文我们知道R-CNN的训练先要fine tuning一个预训练的网络，然后针对每个类别都训练一个SVM分类器，最后还要用regressors对bounding-box进行回归，另外region proposal也要单独用selective search的方式获得，步骤比较繁琐。时间和内存消耗比较大。在训练SVM和回归的时候需要用网络训练的特征作为输入，特征保存在磁盘上再读入的时间消耗还是比较大的。测试的时候也比较慢，每张图片的每个region proposal都要做卷积，重复操作太多。 二：模型结构 由图可见，Fast R-CNN剔除掉了R-CNN中的SVM分类器和bbox线性回归器，而是将两者都放在一体化网络中。同时，运用了ROI-pooling 层，将大小不一的RP转换成同样的size，因此可以将整张图像进行过SS操作后，直接输入进CNN层，一次性对所有的RP完成分类和bbox回归。
总结以下，Fast RCNN主要有3个改进：
1、卷积不再是对每个region proposal进行，而是直接对整张图像，这样减少了很多重复计算。原来RCNN是对每个region proposal分别做卷积，因为一张图像中有2000左右的region proposal，肯定相互之间的重叠率很高，因此产生重复计算。
2、用ROI pooling进行特征的尺寸变换，因为全连接层的输入要求尺寸大小一样，因此不能直接把region proposal作为输入。
3、将regressor放进网络一起训练，每个类别对应一个regressor，同时用softmax代替原来的SVM分类器。
因此，Fast R-CNN相对于R-CNN来说，在训练速度上比RCNN快了将近9倍，比SPPnet快大概3倍；测试速度比RCNN快了213倍，比SPPnet快了10倍。在VOC2012上的mAP在66%左右。
下面介绍模型训练、测试的具体流程，创新点会在其中讲到。
三：训练步骤 1.预训练模型 首先用ILSVRC 20XX数据集对VGG-16进行有监督的分类预训练。
2.Fine-tunning 进行完预训练之后，需要对模型加以修改，然后在PASCAL VOC样本上进行调优训练。下面分步骤进行讲解：
step1:转化预训练模型 微调前，需要先对有监督预训练后的模型进行3步转化：
RoI池化层取代有监督预训练后的VGG-16网络最后一层池化层；
两个并行层取代VGG-16网络的最后一层全连接层和softmax层，并行层之一是新全连接层1+原softmax层1000个分类输出修改为21个分类输出【20种类+背景】，并行层之二是新全连接层2+候选区域窗口回归层；
上述网络由原来的单输入：一系列图像-----&gt;&gt;双输入：一系列图像和这些图像中的一系列候选区域；
step2:训练图像的RP搜索与ROI选择 在调优训练时，每个mini-batch包含2张图像，对它们进行SS区域搜索算法后，采样出128个region proposal（或者叫ROI），也就是每张图像有64个ROI。这些ROI中约25%的ROI作为正样本，正样本和ground truth的IOU值都大于0.5。剩下的ROI作为负样本，IOU都小于0.5。
step3:输入网络中进行调优训练 输入图像是224*224，不满足的先resize。然后经过5个卷积层和2个降采样层（这两个降采样层分别跟在第一和第二个卷积层后面）后，进入ROIPooling层，该层的输入是conv5层的输出和region proposal，region proposal的个数差不多2000。然后再经过两个都是output是4096的全连接层。最后分别经过output个数是21和84的两个全连接层（这两个全连接层是并列的，不是前后关系），前者是分类的输出，代表每个region proposal属于每个类别（21类）的得分，后者是回归的输出，代表每个region proposal的四个坐标。最后是两个损失层，分类的是softmaxWithLoss，输入是label和分类层输出的得分；回归的是SmoothL1Loss，输入是回归层的输出和target坐标及weight。
下面我对其中的细节部分再进行讲解：
① RoI池化层 RoI池化层可以说是SPP（spatial pyramid pooling）的简化版，关于SPPnet的总结见我的另一篇文章 https://www.jianshu.com/p/90f9d41c6436。RoI池化层去掉了SPP的多尺度池化，直接用MxN的网格，将每个候选区域均匀分成M×N块，对每个块进行max pooling。从而将特征图上大小不一的候选区域转变为大小统一的特征向量，送入下一层。
② 损失函数 ③ 采用SVD分解改进全连接层 图像分类任务中，用于卷积层计算的时间比用于全连接层计算的时间多，而在目标检测任务中，selective search算法提取的建议框比较多【约2k】，几乎有一半的前向计算时间被花费于全连接层，就Fast R-CNN而言，RoI池化层后的全连接层需要进行约2k次【每个建议框都要计算】，因此在Fast R-CNN中可以采用SVD分解加速全连接层计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c2c8b2eafc4dff9dd10605a42459d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ac0e9312b337a7303116a96fa29117/" rel="bookmark">
			ubuntu20.04编译imu_tk时所遇问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在imu_tk下建立build文件夹， cmake ..时提示usr/share/FindQt4.cmake与Qt5.12.8版本不匹配 查看CmakeList.txt 如何解决呢？当然不是卸载Qt5安装Qt4啊，虽然笔者差点这么做了，哈哈。
我们要安装依赖
sudo apt-get install build-essential cmake libeigen3-dev libqt4-dev libqt4-opengl-dev freeglut3-dev gnuplot 再次cmake .. perfect!
但进行make时，出现 error: ‘exclusive_scan’ is not a member of ‘std’ 260 | std::exclusive_scan(values.begin(), values.end(), result.begin(), 0); /usr/local/include/ceres/product_manifold.h:309:59: error: expected constructor, destructor, or type conversion before ‘;’ token 309 | ld&lt;Manifold0, Manifold1, Manifolds...&gt;; 我们在CMakeLists.txt中添加SET( CMAKE_CXX_FLAGS "-std=c++17 -O3")再次进行make,完美通过。
以下是编译成功的截图
注：曾试着添加了C++11、14都报错，只有17能编译通过。
接着再执行bin目录下的标定文件
cd bin ./test_imu_calib test_data/xsens_acc.mat test_data/xsens_gyro.mat 执行后又出现了以下问题，真恶心啊！ Importing IMU data from the Matlab matrix file : test_data/xsens_acc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ac0e9312b337a7303116a96fa29117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3248e2505bc3fb97e9d6c7830e9df3/" rel="bookmark">
			两个系统跳转实现免登录(单点登录)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义：多个系统之间在某个系统登陆一次即可访问所有系统。
假设A站登录，跳转B站无需登录。
1.A站登录后，拿着A站账号名获取B站的token，同时在B站保存改账号的信息（用户名+token+过期时间）
2.点击跳转，拿着用户名+token重定向到B站，B站在全局路由守卫beforEach判断to.query.token和to.query.userName是否为空，不为空则代码从别的的系统跳转过来的，调用免密登录（用户名+token）获取用户权限数据信息。并返回给B站。B站持久化储存或Vuex储存。
3.B站跳转A站同上。
相关代码：
/// &lt;summary&gt; /// 用户名获取token /// &lt;/summary&gt; /// &lt;param name="userName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpPost, HttpGet] [IgnoreLoginFilter]//忽略过滤器 public async Task&lt;IActionResult&gt; GetLoginToken(string userName) { //return await NewTask(() =&gt; { if (string.IsNullOrEmpty(userName)) { return Ok(new BaseResultModel(code: 200, data: "用户名不能为空")); } try { SysUsrBLL bll = new SysUsrBLL(); Yw_Sys_Usr user = bll.GetUserByName(userName); if (user != null &amp;&amp; user.usr_id != 0 &amp;&amp; user.usr_status == true) { Model.UserModel model = new Model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef3248e2505bc3fb97e9d6c7830e9df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25bccbe8cdfd8e6b7c0d140e064d8b1d/" rel="bookmark">
			docker cp报错no such directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终于找到问题所在了，先说一下结论其实就是run的时候/bin/bash的问题
背景 windows10电脑上，自己玩docker，下载了一个tomcat官方镜像后，想往webapps里面扔个war包
问题 docker cp报错误
总是提示：“no such file or directory”
网上资料很少要么说斜杠打反方向了，要么说应该用Container的全ID，总之都实验了无效
换方法 搜索docker cp报错作为关键字无果之后，我转战搜索“Docker容器和本机之间的文件传输方法”作为关键字搜索，推荐了集中方法，除了cp外，还有一个就是文件挂载，点击如下链接可以查看具体信息。
docker与主机间文件挂载的详细说明链接
最后实在没辙了就想到了用这个方法，实验后发现也挺好，本来想着就这么用了，也不知道是那根劲搭错了，看到run名利后面跟着/bin/bash，然后发现我的docker ps后的该容器的command跟人家的不一样
破局点 在搜索解决方案中发现了一篇文章介绍docker的文件挂载，虽然不是解决我这个错误的，但是发现在他的成功截图中Command中跟我的不一样，我的是/bin.???（忘记了）
正确的应该是如下图所示
成功 重新写run命令在最后加上 /bin/bash后，再次实验docker cp成功了
总结 1.要坚持不懈的探索，这点很重要，我不知道自己到底为什么突然关注了/bin/bash但是我知道如果没有之前我坚持不懈的4天的探索，我是无法灵光一现的
2.程序发生问题，解决问题问题的点，往往不在发生的位置，需要向前追溯
3.探索的过程最好能记录下来一些关键的截屏，否则后面用脑子回想太累了
最后：希望我的这篇文章能够帮助更多跟我有类似情况的同行们；同时也希望大家多免费的分享自己的经验
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f2197dda361eb2161b5bb4bc4d6e35/" rel="bookmark">
			Oracle数据库中的多表关联查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多表关联查询：在实际开发中，每个表的信息都不是独立的，而是若干个表之间存在一定的联系，如果用户查询某一个表的信息时，可能需要查询关联表的信息，这就是多表关联查询。
1.查询语句的执行顺序
from&gt;where&gt;group by&gt;having&gt;select&gt;order by
2.表的别名：在多表关联查询时，如果多个表存在相同的列，，则必须使用表名来限定列的引用，当查询语句越来越复杂，每次输入表名会使得sql语句过于臃肿，这时就可以使用别名来代替原来的表名了。
语法：table_name 别名
列的别名也是如此。
如：select e.ename 名字,e.deptno,d.dname 名字 from emp e,dept d;
3.多表关联查询：根据连接条件的不同分为很多种。
①交叉连接：不需要任何连接条件的连接，执行结果是一个笛卡尔积，即将原表的记录数相乘，这种连接方式，将表2中的每一条记录都和表1中的每条记录连接一次。
如：表1中的4条记录，表2中的5条记录，交叉连接后有4*5=20条记录。
注：此种连接方式产生的结果集冗余度高，很少使用。
语法：select 查询列 from 表1 [别名] , 表2 [别名];
例:select ename,empno,e.deptno,d.deptno,dname from emp e,dept d;
②内连接：内连接是使用频率最高的连接查询
内连接的实现方式：
1）使用inner join关键字来实现，其中inner可以省略，使用这种方式，需要在from子句后面定义一个on子句来指定连接条件。
语法：select 查询列 from 表1 [别名] [inner] join 表2 [别名] on 连接条件；
例：select e.*,d.* from emp e join dept d on e.deptno=d.deptno;
2）使用where子句来连接
语法：select 查询列 from 表1 [别名],表2 [别名] where 连接条件;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f2197dda361eb2161b5bb4bc4d6e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26fcc04facef62813632f4908ba8f10a/" rel="bookmark">
			Android屏幕适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为啥适配不多赘述，直接上适配方案：
1. 布局适配（layout目录） 布局适配即根据适配方案之一加载指定布局
layout 默认目录 layout-land 横屏 layout-port 竖屏 正常情况下，默认目录是竖屏，单独增加layout-land适配横屏，反之亦然
1.1. 宽高限定符 android3.0之前，适配指定分辨率，将layout文件夹做如下命名：
layout-1024 × 768
layout-1024 × 600
layout-1280 × 768
android3.0以后，需将高度减去48像素，即底部状态栏的高度：
layout-976 × 768
layout-976 × 600
layout-1232 × 768
如果要区分横竖屏适配（android3.0以后），目录名加上land （横屏）或port（竖屏）
横屏适配：layout-land-1024 × 720
竖屏适配：layout-port-976 × 768
注意：新版本Android程序（Android10以后）命名有改动：
规则：layout-（屏幕高-48px） × 屏幕宽
但有时此定义仍不准确，建议创建一下三级目录即可适配大部分屏幕：
layout
layout-1920 × 1080
layout-2340 × 1080
1.2. sw限定符 命名如下：
layout-sw360dp
layout-sw392dp
layout-sw411dp
如果要区分横竖屏适配，目录名加上land （横屏）或port（竖屏）
layout-sw360dp-land
layout-sw360dp-port
1.3. w或h限定符 此外还有一种目录layout-w360dp，与layout-sw360dp的区别，举例说明
1.3.1.layout-sw360dp 这里的sw代表smallwidth的意思，当你的屏幕的绝对宽度大于360dp时，屏幕就会自动调用layout-sw360dp文件夹里面的布局。
注意：这里的绝对宽度是指手机的实际宽度，与手机横竖屏无关。sw最小宽度是指屏幕宽高的较小值，每个屏幕都是固定的，不会随着屏幕横向纵向改变而改变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26fcc04facef62813632f4908ba8f10a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e20cb7eccd6747e25037ff4224c7257/" rel="bookmark">
			自学软件测试的3个技巧，萌新必看！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在有很多朋友想转行，自学软件测试。但是为什么有的人能自学成才，有的人却不行呢？因为学习的过程本身也是一个筛选人才的过程。
今天给大家分享3个关于自学软件测试的技巧，一起来看看！
用对方法 在网上找视频教程是最常见的一种学习方式，但是我们学习也要有针对性。先打牢基础，下面列出来的是一些重要的学习点。
计算机的理论知识，比如各层的协议，测试现在最常接触到的可能是HTTP，TCP，IP，抓包工具如fiddler，wireshark，tcpdump之类的；操作系统上，主要还是为了将来能够解决测试和运维交叉的领域，熟悉Linux基本的操作和命令来维护好自己的测试环境，另外shell脚本、iOS和Android系统（移动APP测试）都可以接触；前端基础知识，目的是解决测试和开发的交叉领域，bootstrap、css、html、javascript、jquery，如果你要做一些web自动化测试脚本的话，这些前端的基础对你很重要。如果你是一点web测试都不做，那这些你可以暂时不学习；数据库，性能测试和接口测试都要用到。 除了视频，一些不错的测试相关书籍也非常值得阅读。
入门基础： 《鸟哥的Linux私房菜》、《软件测试》、《head first python》
测试技术： 《深入理解Java虚拟机》、《移动App性能评测与优化》、《性能之巅》
代码分析： 《不测的秘密精准测试之路》、《head first 设计模式》、《重构改善既有代码的设计》
学习工具 学习软件测试的过程是很枯燥很难熬的，所以我们可以借助一些学习工具让自己轻松一些。
知犀：一款免费的思维导图软件，在学习过程中我们需要梳理自己的学习内容和想法，用思维导图的形式是非常合适的，清晰有条理，还能用来做思维风暴。
野葱：一款可以免费用的超轻量级录屏分享软件，如果你想录制自己在电脑上的测试实操，便于后续回顾和改错，那这个工具你值得拥有。
Cold Turkey Blocker：如果你的自制力比较差，可以安装这个网站屏蔽应用程序，创建要屏蔽的网站和桌面应用程序清单，然后设置屏蔽时间表。例如，你可以在学习时间屏蔽社交媒体和视频网站。
拒绝懒惰 懒惰，不全指在学习上懒惰，我们在思想上也一定不能懒惰。一天看几个小时的网课，但是一点都没有思考，那就是浪费时间和精力。
学习的过程一定要做好时间管理。视频，每天可以看上2个小时，然后下来实操；书籍，结合视频的内容去针对性地看，多复习。学习的重点在于思路和灵感的积累。
无论学习时间的长短，一定不要应付，不要为了学习而学习。学习的目的在于解决问题，解决找工作的问题，解决升职加薪的问题等等。
以上就是今天分享的全部内容了，总的来说就是我们要找到适合自己的学习方法，勤于思考，用对工具，高效学习！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786b060991c6a11975eb03a2cdfeb37c/" rel="bookmark">
			MyBatis扩展之动态sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		佞言者，谄而于忠；谀言者，博而于智
文章目录 前言一、动态sql1.1sql标签：1.2 include标签：1.3. if标签：进行条件判断1.4. where标签：进行多条件拼接，在查询，删除，更新中使用1.5. set标签：1.6. foreach标签： 二、指定参数下标位置查询三、入参是Map四、返回值是map总结 前言 mybatis内容扩展的真多…
一、动态sql 可以定义代码片段，可以进行逻辑判断，可以进行循环处理（批量处理）
使条件判断更为简单
1.1sql标签： 用来定义代码片段，可以将所有的列名，或复杂的条件定义为代码片段，供使用时调用
&lt;!-- 定义代码片段--&gt; &lt;sql id="allColumns"&gt; id,username,birthday,sex,address &lt;/sql&gt; 1.2 include标签： 用来引用sql标签定义的代码片段
&lt;select id="getById" parameterType="int" resultType="users"&gt; select &lt;include refid="allColumns"&gt;&lt;/include&gt; from users where id=#{id} &lt;/select&gt; 1.3. if标签：进行条件判断 1.4. where标签：进行多条件拼接，在查询，删除，更新中使用 &lt;select id="getByCondition" parameterType="users" resultType="users"&gt; select &lt;include refid="allColumns"&gt;&lt;/include&gt; from users &lt;where&gt; &lt;if test="userName != null and userName != ''"&gt; and username like concat('%',#{userName},'%') &lt;/if&gt; &lt;if test="birthday != null"&gt; and birthday = #{birthday} &lt;/if&gt; &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786b060991c6a11975eb03a2cdfeb37c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/260dc9c9149738b295001d3f2bd80cac/" rel="bookmark">
			JAVA中的正则表达式基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是正则表达式： 用于描述字符串内容格式，使用它通常用于匹配一个字符串的内容是否符合格式要求。
1.[ ]:表示一个字符,该字符可以是[]中指定的内容
例如:
[abc]:这个字符可以是a或b或c
[a-z]:表示任意一个小写字母
[a-zA-Z]:表示任意一个字母
[a-zA-Z0-9]:表示任意一个字母数字
[a-zA-Z0-9_]:表示任意一个数字字母下划线
[^abc]:该字符只要不是a或b或c
2.预定义字符:
点( . ) :表示任意一个字符,没有范围限制
\d : 表示任意一个数字,等同于[0-9]
\w : 表示任意一个单词字符,单词字符指字母/数字/下划线（ _ ）等同于[a-zA-Z0-9_]
\s : 表示任意一个空白字符
\D : 表示不是数字
\W : 表示不是单词字符
\S : 表示不是空白字符
3.量词:
问号（?） : 表示前面的内容出现0-1次
例如: [abc]? 可以匹配:a 或 b 或 c 或什么也不写
加号（+） : 表示前面的内容最少出现1次
例如: [abc]+ 可以匹配:b或aaaaaaaaaa...或abcabcbabcbabcba....
但是不能匹配:什么都不写 或 出现内容之外的单词字符，如：abcfdfsbbaqbb34bbwer...
星号（*) : 表示前面的内容出现任意次(0-多次)---匹配内容与+一致，只是可以一次都不写
例如: [abc]* 可以匹配:b或aaaaaaaaaa...或abcabcba....或什么都不写
但是不能匹配有出现内容之外的单词字符:abcfdfsbbaqbb34bbwer...
{n} : 表示前面的内容出现n次
例如: [abc]{3} 可以匹配:aaa 或 bbb 或 aab 或abc 或bbc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/260dc9c9149738b295001d3f2bd80cac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a23ed3e057958b918d55000e7b8616/" rel="bookmark">
			vue-ElementUI表单,upload上传功能，在查看详情中屏蔽删除功能，只能查看下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 图片上传
通过设置hide样式，isInfo为标记
&lt;el-upload :class="{hide:isInfo}" action="customize" :http-request="handleUploadFiles" list-type="picture-card" :file-list="photosList" :on-remove="handleRemove"&gt; &lt;i class="el-icon-plus"&gt;&lt;/i&gt; &lt;/el-upload&gt; .hide{ display:none; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83c68feb0e303dd62053621a1b62435/" rel="bookmark">
			认识---static在c&#43;&#43;里到底干点啥？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		立个小目标 “非弄懂你”
静态 --&gt; 理解为 不动的，不能被改变的
一、全局变量 和 +static的全局变量 有什么区别？
相同点，都
1. 作用于 整个文档
2. 内存分配在全局数据区
3. 不会因 函数的退出 而释放空间
不同之处：
1.static静态全局变量 是不动的、不能被 其他文档 使用，其他文档可定义相同变量，并且不会产生冲突； 然而因为普通全局变量 默认为动态的，所以在其他文档中也可使用该全局变量 ，只需在普通全局变量前 +extern关键字 方可。
2.
二、静态的局部变量 和 静态的全局变量 区别？
相同点：
1. 内存分配在 全局数据区
不同之处：
1. 静态局部变量 只对 定义自己的函数体 始终可见
三、静态的 局部变量 和 普通局部变量 区别？
相同点：
1. 当定义它的函数 或 语句块 结束时，其 作用域随之结束
不同之处：
1. 普通局部变量 分配栈内存，程序退出后，系统回收栈内存
2. 静态局部变量 分配全局数据区。每次的值 保存至下一次调用。
3. 静态局部变量 作用体现在 -&gt; 当需要在两次调用接口间对 变量的值 进行保存时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d83c68feb0e303dd62053621a1b62435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1546d38bdba1034b2d464bdb80aba1/" rel="bookmark">
			C&#43;&#43;学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++学习笔记 一 .C与C++区别1.1 const与常量const与指针 1.2 引用（别名）*引用与const 1.3 默认值参数1.4 内联函数1.5 函数重载1.6 C与C++函数的互相调用1.7 函数摸板数组引用与函数模板 1.8 new与malloc1.9命名空间*C++中的右值引用 二.面向对象2.1 面向对象2.2 this 指针const与成员方法 2.3构造函数构造函数的类型转化 拷贝构造函数2.4析构函数友元=运算符重载（）运算符重载缺省函数 2.5 C++中的权限静态成员变量与静态成员方法 三 . 继承与多态3.1继承：同名问题属性同名方法同名 赋值兼容规则 3.2 多态动多态虚函数vftable(虚表)虚表指针_vfptr RTTI菱形继承与虚继承 纯虚函数与抽象类 一 .C与C++区别 C++的介绍：
C++是一种计算机高级程序设计语言，由C语言扩展升级而产生，最早于1979年由本贾尼·斯特劳斯特卢普在AT&amp;T贝尔工作室研发。
C++既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计。
C++拥有计算机运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。 (来源百度百科)
从上述介绍中，我们可以提炼出：
- C++是对C语言的扩展升级 -----------&gt;&gt; C的多数特性和语法规则在C++中依然适用。
- C++是一个面向对象的程序设计语言-----------&gt;&gt; 相对于面向方法的C语言，C++语言提出了面向对象的设计思想与 类 Class的概念
除此以外，为了方便封装各种抽象的数据类型，C++提供了功能强大的STL库，该库中有封装好的各种常用数据结构；同时，C++也提供了template类模板的方法，通过template，我们可以创造一个类模板或函数模板，再通过提供不同类型的数据，使其产生处理对应数据类型的模板类与模板函数，这样极大提高了C++代码的复用性与可移植性。
因此，可以说 C++ = C + Class + STL + Template
1.1 const与常量 在原来的认识中，被const修饰的量其值不可被更改，我们称这样不可被修改的量为常量。但在C语言中，有些变量即使被const修饰，但在某些情况下其值仍可被修改，如下例：
const int b = 10; int* p = (int)&amp;b;	//通过强制类型转换，p可以获取b的地址 *p = 20; //通过修改*p来修改b的值 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1546d38bdba1034b2d464bdb80aba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4926c86cc5091dede6700878e9f1b8e9/" rel="bookmark">
			Ubuntu下搭建伪分布式从0开始安装Hive详细教程（从JDK安装、Hadoop搭建开始）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu下搭建伪分布式从0开始安装Hive详细教程（从JDK安装、Hadoop搭建开始） 环境：VMware® Workstation 16 Pro、Ubuntu18.04
1、安装SSH和配置SSH无密码登录 sudo apt-get install openssh-server 安装后，可使用以下命令登录本机：
ssh localhost 输入 yes 与用户密码，就可以登录到本机
接着我们退出 SSH 登录
exit 配置无密码登录：
cd ~/.ssh/ ssh-keygen -t rsa 注意这里第二步要你输入文件名时不用输入，直接一路 Enter 选择默认值就好了！
cat ./id_rsa.pub &gt;&gt; ./authorized_keys 此时再用 ssh localhost 命令无需密码即可登录了。
2、安装Java环境 2.1 安装JDK 对于 Hadoop3.1.3 及以上版本而言，需要使用 JDK1.8 或者更新的版本，这里我们使用的 JDK 版本为1.8.0_301，安装包可以从 Oracle 官网下载：Java Downloads | Oracle，Java官网安装太麻烦了
也可从我的百度网盘下载：jdk-8u301-linux-x64.tar.gz（提取码：6del）
接着在 /usr/lib 目录下创建 jvm 文件夹来保存 JDK 文件：
cd /usr/lib sudo mkdir jvm 可以用 Xshell 连接虚拟机，把 JDK 文件上传到虚拟机，解压缩之前的 JDK 文件到上述目录中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4926c86cc5091dede6700878e9f1b8e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f9fb94f963b980b6132836086f14c7/" rel="bookmark">
			HTML基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念
基本语法
声明
html的基本结构
头部区域
注释
标签
标签属性
常用标签
特殊符号转义
表格
表格的基本结构
表格的属性
表格的合并
表单
表单中的组件
概念 超文本标记语言
超文本:指网页中的内容(超链接,图片,视频等)
标记:指标签 网页通过浏览器进行解释执行,通过标签可以对网页中的内容进行解释
例: &lt; a href="百度一下，你就知道" &gt;百度&lt; /a&gt;
&lt; b &gt;新浪&lt; /b &gt;
html的学习过程就是对各种标签的学习
使用开发工具HBuilder X可以进行对前端语言的开发
基本语法 声明 html4的文档声明
&lt; !DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd" &gt;
html5的文档声明
&lt; !DOCTYPE html &gt;
如果不声明解析网页时会产生一些不可预期的行为，所以我们应该避免出现。
html的基本结构 &lt;!DOCTYPE html&gt; 声明html的语言版本 &lt;html&gt;是网页的根标签,所有的内容都写在此标签中 作为标记语言必须有一个根标签 &lt;head&gt; &lt;meta charset="utf-8" /&gt;设置网页的字符集 &lt;title&gt;&lt;/title&gt;设置网页的标题 &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt; html &gt;…&lt; /html &gt; 标签标记 HTML 文档的开始和结束 &lt; head &gt;…&lt; /head &gt; 标签包括标题和其他说明信息。头部部分 &lt; body &gt;…&lt; /body &gt; 标签包含文本、图像和链接。主体部分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38f9fb94f963b980b6132836086f14c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e39b84fe72bc3bed8eb5d104ef1ff61/" rel="bookmark">
			【JavaSE】多线程篇（四）线程的同步机制、互斥锁、线程死锁与释放锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💁 个人主页：黄小黄的博客主页
❤️ 支持我：👍 点赞 🌷 收藏 🤘关注
🎏 格言：All miracles start from sometime somewhere, make it right now.
本文来自专栏：JavaSE从入门到精通
文章目录 1 走进Synchronized1.1 线程同步机制1.2 同步的具体方法--synchronized1.3 使用线程同步解决售票问题 2 互斥锁2.1 基本介绍2.2 使用互斥锁解决售票问题 3 线程死锁3.1 基本介绍3.2 案例演示 4 释放锁4.1 释放锁的情况4.2 不会释放锁的情况 写在最后 1 走进Synchronized 1.1 线程同步机制 在前面的多线程篇的学习中，我们可以尝试对售票活动进行模拟，将每个售票窗口看成一个进程。但是，前面由于没有学习过线程的同步，有可能会出现超卖的问题。比如只剩最后一张票，但是，两个窗口此时都在同时卖，就会由于数据更新不及时，导致多卖出票。
🐱何为线程同步机制？
在多线程编程中，一些敏感数据不允许被多个线程同时访问， 此时就需要使用同步访问技术，保证数据在任何时刻，最多有一个线程被访问，以保证数据的完整性。线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作。 1.2 同步的具体方法–synchronized 1️⃣ 同步代码块：
synchronized(对象){//得到对象的锁，才能操作同步代码 //需要被同步的代码 } 2️⃣ 同步方法：
public synchronized void method(参数列表){ //需要被同步的代码 } 1.3 使用线程同步解决售票问题 在下面的案例中，我们模拟售票问题，通过synchronized解决超卖问题。
package syn; /** * @author 兴趣使然黄小黄 * @version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e39b84fe72bc3bed8eb5d104ef1ff61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6166ac46c3e2a5236e9b0f8b7c7f3498/" rel="bookmark">
			zabbix自定义监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-进程监控 1-1 在agent端编写脚本 取出需要监控资源的状态值 //创建目录 [root@localhost ~]# mkdir /scripts //编写内容脚本 [root@localhost ~]# vim /scripts/check_process.sh [root@localhost ~]# cat /scripts/check_process.sh #!/bin/bash status=$(ps -ef |grep $1|grep -Ev "$0|grep"|wc -l) if [ $status -eq 0 ];then echo '1' else echo '0' fi //给执行权限 [root@localhost ~]# chmod +x /scripts/check_process.sh //查看 [root@localhost ~]# ll /scripts/check_process.sh -rwxr-xr-x 1 root root 134 Sep 6 21:23 /scripts/check_process.sh 1-2 在agent端编写配置文件 //将下面两行取消注释作修改，或者直接添加这两行 [root@localhost ~]# vim /usr/local/etc/zabbix_agentd.conf # Mandatory: no # Range: 0-1 # Default: UnsafeUserParameters=1 //取消注释 改为1 ### Option: UserParameter # User-defined parameter to monitor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6166ac46c3e2a5236e9b0f8b7c7f3498/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ff95aac90256ef3ff3bd0378365137/" rel="bookmark">
			python复制文件到指定文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言：
今天做项目遇到一个问题，在做单元测试时，由于要上传文件夹，但是测试完成后程序会删除上传的文件，这样每次都要手动上传文件，维护成本很大！故想到把上传的文件放到指定的路径，每次运行测试的时候，复制一份即可。
python中复制文件用shutil模块
首先安装此模块：pip install shutil
具体代码如下：
有一处要点，要切记
在用copyfile时，来源与目的路径，需要把目标文件名也要拼进去
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e676adb500fa34abe8a35975fdb2e3bd/" rel="bookmark">
			mysql分组排序取第一条记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式1：内层使用DISTINCT
SELECT type, senderName, subTitle FROM ( SELECT DISTINCT TYPE AS type, SENDER_USERNAME AS senderName, TARGET_NAME AS subTitle FROM `feed_message` ORDER BY CREATE_TIME DESC ) f GROUP BY type 方式2：添加limit
select id,user_name,user_sex,user_age from ( SELECT id,user_name,user_sex,user_age FROM `user_test` order by user_age limit 100 )A group by A.user_sex 转载：mysql分组排序取第一条记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b032764d069cb43d40cf8a5e3ab98dd5/" rel="bookmark">
			Linux系统与编程——02命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件简介 由创建者定义的，具有文件名的一组相关元素的集合即是文件，文件可以是文本文档、图片、程序等。
文件的命名依旧需要遵守规则（ps:感觉咋这么像C++命名的规则）：不可使用“/”；转义字符（如？，*，$，&amp;）最好不用；避免使用“+”，“-”，“.”作为普通文件名的第一个字符；注意大小写，大小写不同即为不同的文件。
文件种类 普通文件：也称为常规文件，是最一般格式的文件，包括系统文件、用户文件、库函数。
目录文件：由文件目录信息构成，是特殊文件，用来检索普通文件的目录信息。
设备文件：在Linux种输入输出设备被视为特殊文件，称为设备文件，存放在/dev目录。有字符设备文件和块设备文件。
符号链接文件：是一种特殊类型的文件，内容为一个字符串。
目录简介 Linux文件系统中的一种特殊文件，文件系统通过目录完成按名存取和文件的共享与保护
目录种类 工作目录：也称为当前目录，是用户登录到Linux系统后所处的目录
用户主目录：是系统管理员增加用户时创建，以后可以改变。
注：普通用户的主目录在/home下，系统管理员在/root下
路径简介 从树型目录中的某个目录层次到某个文件的道路即为路径，路径由目录或目录和文件名构成，中间由“/”分隔
路径种类 绝对路径：也成为完全路径，从“/”开始
相对路径：从用户工作目录或用户主目录开始
注：以下均为文件操作命令 文件操作命令 文件操作命令 显示文件命令 cat命令
more命令
less命令
head命令
tail命令
cat命令 格式：cat [选项] [文件]
效果：将多个文件连接后输出到屏幕中或是以“&gt;文件名”输出到另一文件
-b或--number-nolank:从1开始对所有非空输出行进行编号
-n或--number:从1开始对所有输出行编号
-s或--squeeze-blank:将连续两行以上的空白行合成一行空白行
more命令 格式：more [选项] [文件]
效果：显示文本文件的内容，一次显示一屏，满屏后停下。
按Space键显示文本下一屏内容
按Enter键显示文本下一行内容
按D或CTRL D键显示文本下半屏，默认11行
按B或CTRL B键显示文本上一屏
按Q或Interrupt键退出more命令
-num:指定整数，表示一屏显示多少行
-d:在每屏底部显示提示信息
-c或-p:不滚屏，在显示下一屏之前先清屏
+num:从行号Num开始显示
+/pattern:定义字符串，在文件中查找该字符串，从该字符串后开始显示
less命令 格式：less [选项] [文件]
效果：类似于more命令，分屏显示文件内容，允许向前或向后浏览文件。
按Q键退出less命令
-i或--ignore-case:搜索时忽略大小写，除非搜索串中包含大写字母
-I或--IGNORE-CASE:搜索时忽略大小写
-m或--long-prompt:显示读取文件的百分比
-M或--LONG--PROMPT:显示读取文件的百分比、行号、总行数
-N或--LINE-NUMBERS:在每行前输出行号
-p pattern或--pattern=pattern:定义字符串，在文件中查找该字符串，从该字符串后开始显示
head命令 格式：head [选项] [文件]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b032764d069cb43d40cf8a5e3ab98dd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df094074de11603c76740c7ffb28fbd9/" rel="bookmark">
			轻松理解20种最常用的AI算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用AI算法知多少？他们的主要特征是什么？分别用在什么场景？
如何用1-3句话，让小白也能充分理解各算法？
本文梳理了20中常用AI算法极其简明解释，快来一起挑战“算法之王”呀！
1) 线性回归（Linear Regression）：一种基于过去已经发生的事件来预测未来可能发生的事件的方法。例如，你能够根据过去的收入，使用线性回归来预测你未来的收入。
2) 逻辑回归（Logistic Regression）：一种用于预测事件发生概率的统计分析。它是一种当因变量为二元（变量值只有0和1，或这是或否）时使用的回归分析。
3) 支持向量机（Support Vector Machines）：一种可以从例子中学习并做出预测的模型。它常用于将事务分类。
4) 决策树（Decision Trees）：一种通过穷举出所有可能的选项来帮助你做出决定的方法。构建出决策树后，你可以通过查看所有可能的结果来选出最优解。
5) 随机森林（Random Forests）：用于预测事物。它通过查看一系列可能影响你尝试预测的事件的不同场景来学习，之后，再根据所学到的知识进行猜测。
6) 梯度提升算法（Gradient Boosting）：一种将多个较弱模型结合起来，创建出更强模型的技术。较弱模型使用梯度下降算法开发，最终模型是所有较弱（相对最终模型而言）模型的加权组合。
7) 神经网络（Neural Networks）：一种对数据中复杂模式（pattern）进行建模的机器学习算法。神经网络和其他机器学习算法一样，都可以学习识别输入数据的模式，但不同的是，神经网络由大量互相连接的处理节点（或者将其称为神经元）组成。
8) 主成分分析（Principal Component Analysis，简称PCA）：一种用于查找数据模式的技术。它查看数据，并从中查找数据变化最大的方向。
9) 线性判别分析（Linear Discriminant Analysis，简称LDA）：一种找出对预测目标变量最重要的一组变量（特性）的机器学习技术。LDA是一种可以通过分析数据来预测行为结果的方法，被用于识别数据中不同变量间的关系，然后再使用这些关系来预测未来。
10) K均值聚类（K-Means Clustering）：机器学习中一种将数据进行分组，以便更可能找出数据之间的关联的技术。这是一种通过找到最近的数据点并将它们分成一组，来协助对数据点（例如，数据库中的记录）进行分组的方法。
11) 层次聚类（Hierarchical Clustering）：是一种将数据项组合起来以使其更易理解的方法。它的工作原理是将数据分成组，再查看这些组之间的关系。它是一种在分层结构中将数据点组合在一起的方法，该算法从每个数据点自己所在的组开始，然后再与最近的组，合成一个新组，直到数据中只有一个组，即一个根节点。
12）DBSCAN（Density-Based Spatial Clustering of Applications with Noise）：一种能将数据点聚集起来的算法。它通过分析数据点的密度，将相近的数据点分为一组。
13）高斯混合模型（Gaussian Mixture Models）：它使用线性模型和非线性模型的混合模型来预测结果。它是一种预测一组对象行为的机器学习模型。此模型使用一组输入数据点来预测一组新输入数据点的行为。
14) 自动编码器（Autoencoders）：可以学习到输入数据的隐含特征，称为编码(coding)，同时用学习到的新特征可以重构出原始输入数据，称为解码（decoding）。它是一种用于学习如何压缩数据的神经网络。该算法的目标是学习一种较源数据占用空间更小的表示（编码）方法。
15) 孤立森林（ Isolation Forest）：用于检测数据中的异常值。它通过随机选择数据点并创建决策树来工作。如果该点是异常值，则将更容易地将其与其余数据分隔开。
16) 单类向量支持机（ One-Class SVM）：类似孤立森林，单类向量支持机同样被用来查找异常值：异常值的评估标准就是创建一条最能将数据分成两组的直线，任何远离这条直线的数据点都会被判别为异常值。
17) 局部线性嵌入（Locally Linear Embedding）：一种用于数据降维的技术。它通过找到接近原始数据的另一数据的线性表示来做到这一点。局部线性嵌入是一种将数据集表示为空间中点序列的方法。这样，你可以更轻松地看出数据点之间的关系，并做出更好地预测。
18) t-SNE（t-distributed stochastic neighbor embedding）：通过降低数据的维度来帮助我们可视化数据。t-SNE的工作原理是创建数据点的映射，然后找到在低维空间中表示这些点的最佳方法。
19) 独立成分分析（Independent Component Analysis，简称ICA）：用于发现隐藏在数据中的模式（pattern），ICA通过查看数据中不同变量之间的关系来做到这一点。这是一种从混合信号中分离出各种单个信号的技术。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df094074de11603c76740c7ffb28fbd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c2e4aa024a6860a70c5e988229cd9a/" rel="bookmark">
			前端网址转二维码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先安装依赖 npm install qrcode-npm 2.导入模块
import $ from "jquery"; 3.前端点击事件和方法
&lt;el-button type="primary" size="mini" @click="qrCode"&gt;生成二维码&lt;/el-button&gt; //在data定义弹窗变量： qrVisable:false //qrCode 将链接生成二维码 qrCode(){ if(this.form.linkAddress){ this.qrVisable = true var QRCode = require('qrcode') QRCode.toDataURL(this.form.linkAddress) .then(url =&gt; { var qrbox = document.querySelector("#qrcode"); qrbox.innerHTML = ''; const img = new Image(); img.src=url; img.width = 150; qrbox.appendChild(img); }) .catch(err =&gt; { console.error(err) }) } }, 4.弹出生成二维码组件
&lt;el-dialog :visible="qrVisable" width="300px" @close="qrVisable = false"&gt; &lt;div id="qrcode" style="width:100px; margin-left: 50px;"&gt;&lt;/div&gt; &lt;/el-dialog&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c630b1c904efaa06582e859aa44406/" rel="bookmark">
			利用IO-Link技术实现小型高能效的工业传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用IO-Link技术实现小型高能效的工业传感器 【导读】无论过去还是现在，许多情况下，工业传感器都采用模拟形态，其中包含检测元件和将检测数据传输至控制器的某种方式。数据采用单向模拟方式进行传输。之后出现了可提供数字开/关信号的二进制传感器，包含电感、电容、超声波、光电等检测元件，以及半导体开关元件。其输出可能是：高端（HS）开关（PNP）或低端（LS）开关（NPN），或者是推挽式（PP）。但数据仍然受到限制，只能从传感器单向传输至主机，不提供纠错控制，仍然需要现场技术人员来执行手动校准等任务。因此，业界亟需一种更好的解决方案来满足“工业4.0”、智能传感器和可重新配置的厂区部署等需求。
时下获得公认的解决方案是IO-Link协议，一种相对较新的工业传感器标准，目前已呈现出迅速增长态势。据IO-Link相关组织预测，截至当前，行业使用支持IO-Link标准的节点已超过1600万个，而这个数字仍再不断攀升。
图1：据 IO-Link联盟跟踪显示，IO-Link协议应用快速增长（https://io-link.com/en/）
IO-Link是一种标准化技术（IEC 61131-9），规定工业系统中的传感器和执行器如何与控制器交互。作为一种点对点通信链接，IO-Link采用标准连接器、电缆和协议。IO-Link系统设计用于工业标准3线传感器和执行器基础设施，由IO-Link主机和IO-Link器件产品组成。
IO-Link通信在一个主机和一个器件（传感器或执行器）之间进行。通信采用二进制（半双工）形式，使用非屏蔽电缆时，通信距离限制在20米内。进行通信需要使用三线式接口（L+、C/Q和L-）。在IO-Link系统中，主机的供电范围为20V至30V，器件（传感器或执行器）的供电范围为18至30V。
ADI发布的IO-Link手册中详细介绍了IO-Link的优势：
“IO-Link是一种技术，能够将传统的二进制或模拟传感器变成智能传感器，不再只是收集数据，还允许用户根据获取的有关线上其他传感器的健康和状态的实时反馈，以及需要执行的操作，在远程更改其设置。IO-Link技术通过一个通用物理接口，使传感器变得可以互换，该接口使用协议栈和IO器件描述(IODD)文件来实现可配置的传感器端口。它切实做到即插即用，并且能够实时重新配置参数。”
在工厂网络层次结构中，IO-Link协议位于边缘，该位置通常部署传感器和驱动器，如图2所示。很多时候，边缘器件与网关通信，网关将IO-Link协议转换为所选的现场总线。
图2：IO-Link协议用于将智能边缘器件连接至工厂网络
有关IO-Link如何助力实现下一代制造环境或工业物联网（有时称为IoT）的更多信息，请点此了解详细。
设计IO-Link传感器
工业场景传感器必须坚固、小巧且节能，以尽可能降低散热需求。大多数IO-Link传感器包含以下组件：
● 带有相关模拟前端(AFE)的检测元件；
● 用于处理数据的微控制器，在使用IO-Link传感器的情况下，也运行轻量级协议栈；
● 作为物理层的IO-Link收发器；
● 电源，以及在许多情况下提供的保护功能（用于提供浪涌保护的TVS、EFT/突发、ESD等）。
散热（能效）
了解这些典型组件之后，再来看看考虑如何预估假定传感器的功率。参见图3。所有这些数值都是估算值。图中数值表明，在考虑传感器的总系统功耗预算时，收发器（输出级）的功耗很重要。
最左侧代表较早一代IO-Link传感器。从图中可以看出，多年来微控制器（MCU）和输出平台（例如收发器）的技术进步对于降低系统总功耗所做的贡献。
最初的或第一代IO-Link收发器的功耗为400mW或更高。ADI公司新推出的低功耗IO-Link收发器的功耗低于100mW。此外，MCU也有助于降低功耗。传统MCU的功耗高达180mW，但较新的低功耗MCU的功耗可降至50mW。
先进的IO-Link收发器与低功耗MCU配合使用，可以将传感器的总功率预算保持在400mW到500mW之间。
功耗与散热直接相关。传感器越小，功耗规格越严格。据估计，直径为8mm (M8)的封闭式圆柱形IO-Link传感器的最大功耗为400mW，直径为12mm (M12)的封闭式圆柱形IO-Link传感器的最大功耗为600mW。
技术一直在不断进步。MAX14827A是ADI公司推出的一款新型IO-Link收发器，在驱动100mA负载时，其功耗非常低，仅70mW。这是通过优化技术，提供非常低的2.3Ω（典型值）导通电阻RON来实现的。
图3.假设的IO-Link工业传感器功率预算
对于工作电流非常低（例如3到5mA）并且要求使用3.3V和/或5V电源的传感器，可以通过LDO提供稳压电源。事实上，ADI公司的IO-Link收发器集成了一个LDO。但随着所需的电流增加到30mA，LDO很快会成为系统中主要的供电/散热源。在30mA时，LDO的功耗可能高达600mW。
30mA时，LDO功率 = (24-3.3) x 30mA = 621mW
相比之下，为30mA传感器提供3V输出电压的DC-DC降压转换器的功耗仅为90mW。假设该转换器的效率为90%（仅损失9mW功率），那么总功耗仅为90 + 9 = 99mW 3。
如图4所示，ADI公司新推出的IO-Link收发器集成了一个高效DC-DC稳压器。
图4：ADI公司新推出的IO-Link收发器集成了一个高效DC-DC稳压器
IO-Link传感器的尺寸
除了散热之外，工业传感器的第二关注点是尺寸，新IO-Link传感器也是如此。随着转向更小的外形尺寸，板空间变得越来越重要。
图5显示，对于直径为12mm的外壳，收发器（采用晶圆级封装- WLP -封装）和DC-DC可以并排部署在宽度为10.5mm的标准PCB上。在同一侧还有空余空间，可以部署通孔和走线。如果传感器外壳直径为6mm，那么PCB宽度可以减小至4.5mm。在这种情况下，即使采用小型WLP封装，芯片也必须安装在PCB两侧。
图5：在新型IO-Link传感器设计中，尺寸是另一大问题
要实现这些尺寸，收发器必须采用晶圆级封装(WLP)，以实现更小尺寸。这种尺寸限制也是ADI在新型IO-Link收发器（如之前所示）中集成DC-DC的原因之一。
但大多数工业传感器必须设计为能够在严苛的环境中工作，因此必须包含保护电路，例如TVS二极管（图5中未显示）。所以，需要注意IO-Link收发器的绝对最大额定值规格。
再来看看：为什么IO的绝对最大额定电压为65V有助于减小传感器子系统的尺寸？通常，传感器需承受4个引脚之间的浪涌脉冲：GND、C/Q、DI、DO。ADI公司IO-Link收发器的绝对最大额定电压为65V。如果以C/Q和GND之间的24V浪涌下1KV为例。
C/Q和GND之间的电压 = TVS箝位电压 + TVS正向电压
绝对最大额定电压较高时，设计人员可以使用小型TVS二极管，例如SMAJ33，其箝位电压为60V/24A，TVS正向电压为1V/24A。
C/Q和GND之间的电压 = 61V
以上数值在ADI公司收发器的绝对最大额定值范围内。
买电子元器件现货上唯样商城
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7c630b1c904efaa06582e859aa44406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d32501b0ff64c44ed7cbfb199d56af/" rel="bookmark">
			使用Jmeter轻松实现AES加密测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在自己公司做接口测试的时候，有没有遇到过接口做加密处理的情况呢？相信我们的读者朋友们都有一定的概率会遇到这种情况，尤其是对接口数据安全有一定要求的公司接口数据一定会做加密处理。那么遇到加密情况，大家使用工具JMeter如何做接口测试呢？可以借助JMeter提供的函数digest和MD5，其中digest支持的加密方法是如下这7个：
由此可见到目前为止，JMeter自带的支持的加密方法仅MD和SHA，如果很幸运你所供职公司用的就是这两种加密中的任意一种，那么我们就可以通过JMeter提供的加密方法进行加密处理。但是我们很多读者遇到的是使用其他的通用加密算法，一说到通用加密方法，不得不说AES加密，AES加密算法是英文单词Advanced Encryption Standard的首字母缩写，AES加密采用的是效率较高的对称加密算法，也就是说，其加密、解密使用相同的密钥。
AES网络传输过程加密、解密过程详见如下图所示
术语说明：
明文：没有经过加密处理的数据
密文：经过加密处理后的数据
如果大家公司业务对应的接口是走AES加密，我们通过接口测试工具JMeter做接口测试时，需要对请求数据做加密处理，并且对应答数据做解码处理，我们拿响应数据解密处理来看，具体怎么实现接口aes解密处理。
01 解密方法获取 首先我们要获取到aes解密方法，可以跟开发要，也可以网上找，毕竟aes是比较通用的加密算法。
如下所示，是某公司开发提供的aes解密方法：
02 加密方法引入 接下来我们就需要将获取到的加密方法引入到JMeter中，有多种解决方案，咱们这里使用引入java源文件的方式，首先将java源文件拷贝到指定的盘符，例如：D盘。
然后在添加的beanshell后置处理器中增加如下脚本，来实现引入带加密方法的java源文件：
03 调用解密方法 如下脚本所示：
第4行实现调用aes解密方法，入参有2个，分别是aes密文字符串、秘钥
第2行定义aes密文字符串
第3行表示获取应答报体，并赋值给aes密文字符串变量decodeStr
第4行在日志查看面板打印应答报体aes明文
如下图所示，是经过aes解密后的应答报体内容：
经过以上步骤一、二、三操作即可实现对aes密文的解密。
接口请求aes加密，需要获取aes加密方法，不同于解密操作步骤是步骤三，调用的是获取到的aes加密方法。
04 URL解码 有些公司开发还会对应答报体进行URL编码处理，这种情况下，我们做接口、性能测试时，需要对应答做断言判断，因而需要先进行URL解码，然后再进行aes解密操作，然后再对解密后的应答信息做断言处理。
如下所示在JMeter的BeanShell 后置处理程序中已编写的脚本中，增加第5行调用url解码方法对应答报体做url解码处理，当然JMeter自带的urldecode函数也能实现url解码处理，第1行实现的是引入java.net包下的URLDecoder类，提供给第5行url解码方法调用，其他脚本行的注释内容详见步骤三，这里就不再赘述了
相应的开发对接口请求也会做对应的URL编码处理，我们测试的接口脚本就需要增加如下两行脚本。
以上就是AES+URL接口的JMeter解决方案。
现在我邀请你进入我们的软件测试学习交流群：【746506216】，备注“入群”， 大家可以一起探讨交流软件测试，共同学习软件测试技术、面试等软件测试方方面面，还会有免费直播课，收获更多测试技巧，我们一起进阶Python自动化测试/测试开发，走向高薪之路。
喜欢软件测试的小伙伴们，如果我的博客对你有帮助、如果你喜欢我的博客内容，请 “点赞” “评论” “收藏” 一 键三连哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd46f21cf9a28fc247ba813925833f4/" rel="bookmark">
			Uncaught TypeError: Failed to construct ‘FormData‘: parameter 1 is not of type ‘HTMLFormElement‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写formData demo的时候，报错：
检查文档：
19行打印了一下form，发现没有成功获取到DOM元素，把script标签放到body最后就行。
应该是浏览器渲染顺序问题，script在body前获取不到DOM元素。
换下顺序即可：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824e8b74a9b38382aef92ff63930a41d/" rel="bookmark">
			vue3项目启动报错 in ./src/App.vue?vue&amp;type=style&amp;index=0&amp;lang=scss解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ERROR Failed to compile with 1 error 上午9:18:37 error in ./src/views/Login.vue?vue&amp;type=style&amp;index=0&amp;id=26084dc2&amp;lang=less&amp;scoped=true TypeError: this.getOptions is not a function 第一步 ，先卸载 sass-loader npm uninstall sass-loader 如果卸载也报错，就执行下的代码 npm uninstall node-sass npm uninstall sass-loader 第二步 再安装一个sass@1.26.5和sass-loader@7.0.0版本 npm install sass@1.26.5 --save-dev npm install sass-loader@7.0.0 --save-dev 最后 ，安装低版本的sass-loader需要引入node-sass依赖来支持,请执行下列代码 npm install node-sass 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a933cc4731a4a294788e181fa7004d87/" rel="bookmark">
			如何应用Python助你在股票中获利？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习如何利用Python创建模型,以根据财务报表计算股票的公允价值。
扫码关注《Python学研大本营》，加入读者群，分享更多精彩
股票市场中需要低买高卖的投资策略，必须以合理的价格购买投资，这意味着以公允价值购买。但是如何计算股票的公允价值或内在价值呢？
有几种方法可以考虑，具体来说：
一种方法是公允价值是未来自由现金流的现值。
另一种方式是，公允价值是可以支付并产生所需回报率的价格。
第三种方式是，公允价值是在当前倍数下包含财务未来增长的价格。
当然，他们都假设分析和模型是正确的。随着央行利率政策正常化和投资回归基本面，这些方法越来越多地重新成为主流。
在本文中，我们将根据来自公司季度损益表和资产负债表的财务指标数据创建三种不同的模型。使用收益、自由现金流、收入、相应的增长和出色的股票作为模型的输入。这实际上进入了第三个假设，其中公允价值是在给定当前倍数的情况下包含未来增长的价格。
对于高质量的基本面数据，使用EOD的 API，对于价格数据，使用 yfinance。
项目特点 下载给定公司的基本面数据（资产负债表、损益表、现金流量表）。
计算财务指标模型的输入。
将输入插入每个模型并估计公司的公平价格。
可视化股票的价格序列并将市场价格与公允价格进行比较。
需要准备以下内容： Python：安装 3.9.7 版本。
Jupyter Notebook：为操作系统安装 Anaconda的个人版本，确保已经安装了 Jupyter。
EOD API 密钥：按照此处的说明进行操作。
一旦设置好了，就可以继续执行了。
开始 让我们加载整个项目所需的包并启动我们以后需要的变量。
包是一组结构化函数，可以导入到我们的 Python 解释器中，然后我们可以从中调用和使用它们。
import matplotlib.pyplot as plt import requests import pandas as pd from datetime import * import numpy as np import json import urllib.request import yfinance as yf import warnings warnings.filterwarnings('ignore') EOD_API_KEY = 'your-api-key' SYMBOL = 'FVRR.US' 我为这个演示选择了 Fiverr 股票 (FVRR)，因为喜欢这家公司，而且我认为评估其当前的公平价格和潜在的未来增长有点困难，所以这仍然是一个有趣的练习。但是，最终会将整个代码组合成一个函数，该函数可以对指定给它的任何股票进行此评估！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a933cc4731a4a294788e181fa7004d87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858e64a0907400614619c8837a8acb0c/" rel="bookmark">
			人工神经网络的结构模型,神经网络模型结构图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给出一个如图所示的BP神经网络，X1，X2 为输入，求输出Y 这个应该是隐层和输出层吧，直接purelin(X*W)即可得到输出Y，两输入单输出。
基础知识：BP（BackPropagation）网络是1986年由Rumelhart和McCelland为首的科学家小组提出，是一种按误差逆传播算法训练的多层前馈网络，是目前应用最广泛的神经网络模型之一。
BP网络能学习和存贮大量的输入-输出模式映射关系，而无需事前揭示描述这种映射关系的数学方程。它的学习规则是使用最速下降法，通过反向传播来不断调整网络的权值和阈值，使网络的误差平方和最小。
BP神经网络模型拓扑结构包括输入层（input）、隐层(hiddenlayer)和输出层(outputlayer)。
谷歌人工智能写作项目：小发猫
人工神经元网络的拓扑结构主要有哪几种？谢谢大侠~~~ 神经网络的拓扑结构包括网络层数、各层神经元数量以及各神经元之间相互连接的方式卷积神经网络从入门到精通，卷积神经网络教程。人工神经网络的模型从其拓扑结构角度去看，可分为层次型和互连型。
层次型模型是将神经网络分为输入层（InputLayer）、隐层（HiddenLayer）和输出层（OutputLayer），各层顺序连接。
其中，输入层神经元负责接收来自外界的输入信息，并将其传递给隐层神经元。隐层负责神经网络内部的信息处理、信息变换。通常会根据变换的需要，将隐层设计为一层或多层。
扩展资料：人工神经网络模型主要考虑网络连接的拓扑结构、神经元的特征、学习规则等。目前，已有近40种神经网络模型，其中有反传网络、感知器、自组织映射、Hopfield网络、波耳兹曼机、适应谐振理论等。
人工神经网络采用了与传统人工智能和信息处理技术完全不同的机理，克服了传统的基于逻辑符号的人工智能在处理直觉、非结构化信息方面的缺陷，具有自适应、自组织和实时学习的特点。
参考资料来源：百度百科-人工神经网络。
如何简单形象又有趣地讲解神经网络是什么？ 神经网络神奇的地方在于它的每一个组件非常简单——把空间切一刀+某种激活函数(0-1阶跃、sigmoid、max-pooling)，但是可以一层一层级联。
输入向量连到许多神经元上，这些神经元的输出又连到一堆神经元上，这一过程可以重复很多次。
这和人脑中的神经元很相似：每一个神经元都有一些神经元作为其输入，又是另一些神经元的输入，数值向量就像是电信号，在不同神经元之间传导，每一个神经元只有满足了某种条件才会发射信号到下一层神经元。
当然，人脑比神经网络模型复杂很多：人工神经网络一般不存在环状结构；人脑神经元的电信号不仅有强弱，还有时间缓急之分，就像莫尔斯电码，在人工神经网络里没有这种复杂的信号模式。
matlab BP神经网络 performance 图这五条线的详细解释 图上的三个彩色实线分别是：每一代BP训练过程的MSE指标的性能，每一代BP交叉验证过程的MSE指标的性能以及BP测试的MSE指标在每一代中执行的过程。
特别是，应该注意内部的TEST红线，这是BP计算/训练结果。BEST虚线表示当BP网络被训练到第八代时，BP训练结果是最佳的。
GOAL虚线是在编程或直接使用MATLAB的ANN工具箱训练此BP时设置的网络容量训练停止目标（一个）。
扩展资料：BP（BackPropagation）神经网络是由Rumelhart和McCelland领导的一组科学家于1986年提出的。
BP（BackPropagation）是由反向传播误差反向传播算法训练的多层前馈网络，是使用最广泛的神经网络模型之一。
BP网络可以学习并存储大量的输入-输出模式映射关系，而无需事先揭示描述这些映射关系的数学方程式。
BP网络的学习规则是使用最速下降法，并通过反向传播来不断调整网络的权重和阈值，以最小化网络的平方误差之和。BP神经网络模型的拓扑包括输入层，隐藏层和输出层。
神经网络是什么 神经网络是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。
生物神经网络主要是指人脑的神经网络，它是人工神经网络的技术原型。
人脑是人类思维的物质基础，思维的功能定位在大脑皮层，后者含有大约10^11个神经元，每个神经元又通过神经突触与大约103个其它神经元相连，形成一个高度复杂高度灵活的动态网络。
作为一门学科，生物神经网络主要研究人脑神经网络的结构、功能及其工作机制，意在探索人脑思维和智能活动的规律。
人工神经网络是生物神经网络在某种简化意义下的技术复现，作为一门学科，它的主要任务是根据生物神经网络的原理和实际应用的需要建造实用的人工神经网络模型，设计相应的学习算法，模拟人脑的某种智能活动，然后在技术上实现出来用以解决实际问题。
因此，生物神经网络主要研究智能的机理；人工神经网络主要研究智能机理的实现，两者相辅相成。扩展资料：神经网络的研究内容相当广泛，反映了多学科交叉技术领域的特点。
主要的研究工作集中在以下几个方面：1、生物原型从生理学、心理学、解剖学、脑科学、病理学等方面研究神经细胞、神经网络、神经系统的生物原型结构及其功能机理。
2、建立模型根据生物原型的研究，建立神经元、神经网络的理论模型。其中包括概念模型、知识模型、物理化学模型、数学模型等。
3、算法在理论模型研究的基础上构作具体的神经网络模型，以实现计算机模拟或准备制作硬件，包括网络学习算法的研究。这方面的工作也称为技术模型研究。
神经网络用到的算法就是向量乘法，并且广泛采用符号函数及其各种逼近。并行、容错、可以硬件实现以及自我学习特性，是神经网络的几个基本优点，也是神经网络计算方法与传统方法的区别所在。
参考资料：百度百科-神经网络（通信定义）
求BP神经网络训练模型 110 不知道他是用什么做的，如果是matlab可能是用GUI工具做的。CSDN下载的积分通过评论可以返还，不用担心分数问题。我也传一个C++的类。
BP（BackPropagation）神经网络是1986年由Rumelhart和McCelland为首的科学家小组提出，是一种按误差逆传播算法训练的多层前馈网络，是目前应用最广泛的神经网络模型之一。
BP网络能学习和存贮大量的输入-输出模式映射关系，而无需事前揭示描述这种映射关系的数学方程。它的学习规则是使用最速下降法，通过反向传播来不断调整网络的权值和阈值，使网络的误差平方和最小。
BP神经网络模型拓扑结构包括输入层（input）、隐层(hiddenlayer)和输出层(outputlayer)。
CNN、RNN、DNN的内部网络结构有什么区别？ 从广义上来说，NN(或是更美的DNN)确实可以认为包含了CNN、RNN这些具体的变种形式。在实际应用中，所谓的深度神经网络DNN，往往融合了多种已知的结构，包括卷积层或是LSTM单元。
但是就题主的意思来看，这里的DNN应该特指全连接的神经元结构，并不包含卷积单元或是时间上的关联。因此，题主一定要将DNN、CNN、RNN等进行对比，也未尝不可。
其实，如果我们顺着神经网络技术发展的脉络，就很容易弄清这几种网络结构发明的初衷，和他们之间本质的区别。
神经网络技术起源于上世纪五、六十年代，当时叫感知机(perceptron)，拥有输入层、输出层和一个隐含层。输入的特征向量通过隐含层变换达到输出层，在输出层得到分类结果。
早期感知机的推动者是Rosenblatt。
(扯一个不相关的：由于计算技术的落后，当时感知器传输函数是用线拉动变阻器改变电阻的方法机械实现的，脑补一下科学家们扯着密密麻麻的导线的样子…)但是，Rosenblatt的单层感知机有一个严重得不能再严重的问题，即它对稍复杂一些的函数都无能为力(比如最为典型的“异或”操作)。
连异或都不能拟合，你还能指望这货有什么实际用途么。
随着数学的发展，这个缺点直到上世纪八十年代才被Rumelhart、Williams、Hinton、LeCun等人(反正就是一票大牛)发明的多层感知机(multilayerperceptron)克服。
多层感知机，顾名思义，就是有多个隐含层的感知机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55360e3866540e2860025977fb53c13/" rel="bookmark">
			[护网杯 2018]easy_tornado
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目打开有三个链接
点第一个发现
第三个
猜测这里的filehash就是md5加密得到的，我们需要找到cookie_secret
在第二个链接中
有个render，而且题目是easy_tornado，可是SSTI
因为render（）是tornado里的函数，可以生成html模板。是一个渲染函数 ，就是一个公式，能输出前端页面的公式。
tornado是用Python编写的Web服务器兼Web应用框架，简单来说就是用来生成模板的东西。和Python相关，和模板相关
尝试
/file?filename=/fllllllllllllag&amp;filehash={{1}} 发现
报错，可能存在过滤
然后我们需要找到cookie_secret
百度得到Tornado框架的附属文件handler.settings中存在cookie_secret
此时构造payload:
http://71b67625-1f9d-4e09-bcb6-cee825a1a3a5.node4.buuoj.cn:81/error?msg={{handler.settings}} 得到提示信息，得到cookie_secret:61375ac6-5e1d-4510-a256-12786c3e1f09
然后结合md5(cookie_secret+md5(filename))
即md5('61375ac6-5e1d-4510-a256-12786c3e1f09'+md5('/fllllllllllllag'))
得到
(注意使用php写的话中间的是 “.”)
然后得到payload：
/file?filename=/fllllllllllllag&amp;filehash=17f40d52bf376fb1d8637095e2854997 得到flag
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e9f2802dbf5e141718a82d09f124f4/" rel="bookmark">
			C# &#43; Oracel 批量插入数据（List，Array等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		static OracleConnection OpenConn() { string connstr = "Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=***.***.***.***)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=***)));Persist Security Info=True;User ID=***;Password=***;"; OracleConnection conn = new OracleConnection(); conn.ConnectionString = connstr; conn.Open(); return conn; } public bool insert(string tableName, IList&lt;HDDL_Shipe_Point&gt; list, int length) { string sql = "INSERT INTO " + tableName + "(XH,MMSI,UTC,LAT,LON,SOG,COG,UDATE) values(SEQ_SHIPPOINT.Nextval,:MMSI,:UTC,:LAT,:LON,:SOG,:COG,:UDATE)"; //string sql = "INSERT INTO " + tableName + "({0}) values(SEQ_SHIPPOINT.Nextval,{1})"; using (OracleConnection conn = OpenConn()) { try { int returnrow = 0; int recordCount = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85e9f2802dbf5e141718a82d09f124f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f96aa54eb6bcae566b6fd3e434dcda2/" rel="bookmark">
			Oracle.ManagedDataAccess 连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 36 static OracleConnection OpenConn() 37 { 38 OracleConnection conn = new OracleConnection(); 39 conn.ConnectionString = "Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=***.***.***.***)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=***)));Persist Security Info=True;User ID=***;Password=***;"; 40 conn.Open(); 41 return conn; 42 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39f0c83d1c75119c0031d0f813ccf1a/" rel="bookmark">
			单日直播GMV破亿，爆品热销628w&#43;，8月榜单有哪些看点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年的“抖音818发现好物节”，再次引爆了用户们在夏日的消费热情。
截止8月18日24时，大促成交额破百万直播间达3894个，挂购物车短视频投稿量达1621条，交易额破百万品牌达5560个，泛商城交易额破百万单品个数达400+。
而纵观整个8月，抖音电商中销售额上亿的主播环比增多，消费者购物偏好明显，品牌直播间排名竞争激烈。
那么，8月有哪些主播表现突出，哪些单品在畅销，哪些品牌直播表现优异呢？通过新抖统计的8月1日至8月31日的月榜数据，我们一起盘点看看吧。
主播带货榜
单日带货近1亿，噱头不断引关注
据新抖的［主播带货榜］数据显示，8月带货销售额上亿的主播共有21位，与同样拥有大促活动加持的6月基本持平，而环比7月，数量则明显增多。
其中，近3个月带货约20亿的@东方甄选稳定发挥，第三次斩获带货榜榜首，8月销售额6.3亿；回归后人气不减的@疯狂小杨哥蝉联榜二，直播销售额4.28亿；榜三则是排名上升7位的@衣哥，直播销售额3.83亿。
下面是主播带货榜TOP30的排名情况：
*向上滑动阅览*
▲ 制图：新抖
此次登上榜三的@衣哥，近期在抖音势头正强，8月共有5场直播的销售额破5000万，8月14日和18日，每天开播两场，单日销售额均破亿，涨粉共近250w，成为8月的黑马主播。
全平台2800w+粉丝的@衣哥，并不是在抖音刚冒头的新人，2019年5月底该达人正式入驻抖音，成为正能量类内容的短视频创作者，2020年4月起转型电商主播，并在愈加完善的直播运作系统及持续的流量曝光中，获得了不俗的带货成绩。
在他的直播间里，平均有2~5款价格低于1元的秒杀福利爆品，其销量均在1w单以上，高性价比的商品往往能直接为直播间带来流量，另一方面，主播深谙用户害怕错过优惠的心理，直播间的福利商品往往上架少且售卖时间短，犹豫就可能错过，提高了用户下单的积极性。
▲ 图源：新抖-直播详情
同时，@衣哥的团队还建立了专属的“衣选”供应链，通过自主选品，保证售后和产品质量，降低品质风险。
邀请明星站台，也是其直播间的常见套路，合作明星包括：黄晓明、钟丽缇、陈紫函、赵雅芝、李依晓等，现在翻看他在抖音发布的短视频作品，主题已经从过去的“正能量”内容转变为以“明星宣传”为主的直播预热视频。
开播之前，@衣哥会在抖音发布2~10条短视频，内容大部分是该达人和明星同时出镜，或是一起摆拍耍帅，或是一起卡点跳舞，并在文案附上明星话题及开播时间。
▲ 图源：抖音
@衣哥的成功或许不能复制，但仍有可借鉴之处，如精准打造励志人设，内容契合生活；安排明星及福利，刺激粉丝喜好；以及搭建专属供应链等。
此外，带货达人的长期发展，还离不开明晰的直播运营体系的规划，包括一步步完善优质的供应链、良好的产品和完善的服务体系...
综合带货榜外，在各垂直带货领域中，也有表现突出的主播，通过新抖的［直播带货风向］可以分析出，8月，服装鞋帽、食品饮料、美妆护肤、家居生活、钟表配饰这5个品类的商品，贡献了超过80%的销售额。
▲ 图源：新抖-直播带货风向
本期将展示以上5个分类的［带货领域榜］TOP10主播，下面是榜单详情：
&lt;&lt;滑动查看下一张图片&gt;&gt;
▲ 制图：新抖
热门商品榜
一次性纸杯上架3593场直播
在热销商品中，商品名称常见“宠粉”、“专享”及“精选”等关键词，关联商品如纸杯、湿巾纸、垃圾袋等，此类实用产品常作为直播间的福利引流款，以低于1元的标价，吸引用户下单。
观察新抖的8月［］，标价0.1元的“一次性纸杯”以628.05w的抖音销量排名第一。
据趋势分析图显示，近30天，该产品的推广达人数呈现上升趋势，热推达人共计520人，且每日直播均在82场以上，带货直播场次共3593场，成为抖音8月的爆款商品。
▲ 图源：新抖-商品详情
而在8月［热门商品榜］TOP10中，有2款单品均是来自抖音小店“耐德家居旗舰店”的一次性垃圾袋，售价0.06元，抖音销量累计约494.42w。
通过趋势分析图的显示，该单品在818期间的热推达人、每日直播趋势均高于日常水平，且抖音达人@陈三废姐弟、@张老虎等，均在818期间的直播中上架该商品。
▲ 图源：新抖-商品详情
价格实惠的一次性垃圾袋，非常符合福利款商品的特点——客单价低、实用性高、用户的购买决策路径短。
下面是销量TOP30商品的排名情况：
*向上滑动阅览*
▲ 制图：新抖
此外，通过对［直播带货风向］的潜力类目分析观察，还能发现其他热销类目。从直播销量的表现上看，医药保健类商品环比提升81.65%，在8月持续热卖；而从销售额看，母婴用品类商品环比提升53.39%，热销趋势明显。
▲ 图源：新抖 - 直播带货风向
品牌自播榜
设计师款女装月销8152.35w
8月，抖音品牌店的自播情况也火爆非常，新抖的8月［品牌自播榜］中，TOP8的品牌店带货销售额均在5000w以上，TOP30均在2700w以上，相较7月增幅明显。
下面是品牌自播榜TOP30的排名情况：
*向上滑动阅览*
▲ 制图：新抖
其中，@洛哥以8152.35w的带货销售额位居榜首，8月共直播24场，固定在7:50左右开播，场均直播时长7.33小时。
@洛哥直播间带货品类以女装为主，主打设计师品牌，强调设计理念，适合对服装品味及穿着舒适度有要求的职业女性。
▲ 图源：新抖-直播详情
根据新抖的账号详情显示，该达人的粉丝以女性居多，占比87.26%，年龄层上，也覆盖了追求时尚与实用并存的31—40岁之间的群体，而开播时段既在上班前，也囊括了午休时间，为目标用户群体提供了便利的购物场景。
▲ 图源：新抖-粉丝画像
除了@洛哥，8月［品牌自播榜］TOP10中，@Teenie Weenie官方旗舰店、@老贝轻奢女装定制、@ojaer 鸥纪儿、@罗拉密码的带货选品均以女装为主，直播主题基本都围绕着夏末清仓、秋冬上新、818大促等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c39f0c83d1c75119c0031d0f813ccf1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985929ce20c1476517bc2bcb735946d3/" rel="bookmark">
			LaTeX 2022 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LaTeX 排版工具需要安装两样东西：TeXLive + TeXstudio
1 安装 TeXLive 首先在官网下载 TeXLive 安装包：LaTeX - A document preparation system
下载完成后，解压安装包，点击运行 install-tl-windows.bat 文件
此处可以修改安装路径，默认安装在 C 盘
修改完安装路径后，点击左下角的 Advanced，出现以下界面，
想节省内存的可以只选上 红框 里的，只安装中文和英文，此处我把所有的语言全装上了（虽然大概率也不会用）
之后点击右下角的“安装”即可，安装速度非常慢非常慢（我装了快一下午，虽然可能是因为我网不好）
打开 cmd，依次输入以下命令验证 TeXLive 是否安装成功
latex -v xelatex -v pdflatex -v 2 安装 TeXstudio 从官网下载 TeXstudio：TeXstudio - A LaTeX editor
下载完成后运行安装程序，选择安装路径后点击“安装”
安装好之后打开 TeXstudio，菜单栏 Options – Configure TeXstudio
依次选择 General -&gt; Language -&gt; zh_CN（Chinese），将语言设置为中文
依次选择 编辑器 -&gt; 显示行号 -&gt; 所有行号，为段落添加行号
依次选择 构建 -&gt; 默认编译器，英文论文设置为PdfLaTeX，中文论文设置为XeLaTeX
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/985929ce20c1476517bc2bcb735946d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d895e46fb6e7654138bd4baf0477392e/" rel="bookmark">
			个推解读Android13新特性，发布《Android13适配指南》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8月16日，谷歌宣布Android13新系统的源代码已经上传到Android开源项目（AOSP）中，Android13正式发布。自从2022年2月Android13第一个预览版上线以来，历经7个月的测试和优化，正式版本的Android13终于来了！Android13仍然聚焦个人隐私保护和安全，并提供了万物互联时代下大小屏适配、电池利用率优化等相关的技术开发能力。
感兴趣的开发者可以登录官网下载源码测试学习：https://developer.android.google.cn/about/versions/13
个推服务开发者多年，一直密切关注和跟进行业发展趋势。Android13正式版发布后，我们使用模拟器进行了研究和适配测试。本文将从权限变更、系统优化、功能更新等方面来谈谈Android13新特性，以帮助开发者快速上手完成Android新系统的适配。
权限变更 一、通知权限 通知栏消息一直是App和用户沟通的有效渠道。在Android13之前，App只需要使用NotificationManager即可向终端用户推送通知栏消息。Android13则引入了新的运行时通知权限：POST_NOTIFICATIONS。对此，App开发者需要予以重点关注。
个推对该权限进行了测试，总结如下：
1. 首先看TargetSdk&lt;33的情况。
如下图，当App使用通知栏功能时，系统将自动弹出授权弹窗：
用户点击“允许”，App可正常给用户推送消息：
2. 再看TargetSdk == 33的情况。
开发者需要在AndroidManifest.xml中声明POST_NOTIFICATIONS权限，还需要在使用通知栏推送功能时在代码中申请运行时权限：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.gt.demo.mubai.push"&gt; &lt;uses-permission android:name="android.permission.POST_NOTIFICATIONS"/&gt; &lt;/manifest&gt; requestPermissions(new String[]{“android.permission.POST_NOTIFICATIONS”})复制 以上是用户点击“允许”App推送的情况。当然，用户也有可能点击“不允许”。值得注意的是，一旦被用户拒绝授权，下次系统将不会再出现权限申请的弹窗。
如果App仍然要推送重要消息（比如重大版本更新）给用户，则需要引导用户前往设置界面打开通知权限。代码如下：
private void jumpNotificationSetting() { final ApplicationInfo applicationInfo = getApplicationInfo(); try { Intent intent = new Intent(); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("app_package", applicationInfo.packageName); intent.putExtra("android.provider.extra.APP_PACKAGE", applicationInfo.packageName); intent.putExtra("app_uid", applicationInfo.uid); startActivity(intent); } catch (Throwable t) { t.printStackTrace(); Intent intent = new Intent(); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); intent.setData(Uri.fromParts("package", applicationInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d895e46fb6e7654138bd4baf0477392e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326005ea23b8dd08c6b42923bcc32ab9/" rel="bookmark">
			SpringCloud Feign 远程调用（史上最详细讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：大三的土狗
专栏：SpringCloud
快速导航 前言1、Feign 介绍2、Feign 的使用1、引入依赖2、添加注解3、编写Feign的客户端4、测试 3、Feign的自定义配置4、Feign的优化使用1、引入依赖2、配置连接池 5、Feign的最佳实践1、继承方式2、抽取方式 总结 前言 Feign是声明式的 web service 客户端，它让微服务的调用变得更简单了，帮助我们优雅的实现 http 请求的发送。SpringCloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端。
1、Feign 介绍 利用RestTemplate发起远程调用代码如下：
//url String url = "http://user-service:8081/user/" + order.getUserId(); //发起调用 User user = restTemplate.getForObject(url,User.class); 此时代码可读性差，参数复杂 URL 难以维护。
而 Feign 是一个声明式的http客户端，其作用就是帮助我们优雅的实现 http 请求的发送。
官方地址：https://github.com/OpenFeign/feign
2、Feign 的使用 Feign替代RestTemplate的步骤如下：
1、引入依赖 在调用其他微服务的微服务order-service的pom.xml中添加。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2、添加注解 在调用其他微服务的微服务order-service的启动类添加注解开启Feign的功能。
@SpringBootApplication @EnableFeignClients public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } } 3、编写Feign的客户端 新建一个接口，代码如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/326005ea23b8dd08c6b42923bcc32ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25bcf7db1f37af0ea26cabf484c5756b/" rel="bookmark">
			vue 路由守卫 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由守卫：保护路由的安全。控制路由跳转权限。路由跳转有两种方式：1 、&lt;router-link&gt;方式，2、编程式跳转。路由守卫：控制路由在符合某种条件下才能完成跳转。
一、全局路由守卫 全局，所有的路由，此时需要找路由器router，可以是在src/router/index.js文件中，也可以是在main.js中，亦或者是在与某个引入了src/router/index.js文件暴露的router的perssion.js文件中（需要在main.js中引入），借助beforeEach()/afterEach()实现
1. 全局前置路由守卫 前置，在路由切换之前判断，不符合条件则不跳转。在初始化的时候调用，在路由切换的时候调用
// to：要去的路由，from：当前路由，next：触发跳转
router.beforeEach((to, from, next) =&gt; {
...逻辑
next()
}
2.全局后置路由守卫 后置，在跳转之后判断，不管符不符合，路由都会跳转，浏览器地址栏都会变化，多用于跳转后修改页签标题等。
// to：要去的路由，from：当前路由
router.afterEach((to, from) =&gt; {
...逻辑
}
二、独享路由守卫 某一个路由单独享有的路由守卫，需要在配置路由的地方，添加beforeEnter函数，只有前置，没有后置
{ name: 'home', path: '/home', component: () =&gt; import('@/views/home/Home), meta: { isAuth: true, title: '首页' }, beforeEnter: (to, from, next) =&gt; { /*... //逻辑 if(to.meta.isAuth){ if(条件){ next() } else { alert('暂无权限查看') } } else{ next() } */ } } 三、组件内路由守卫 组件内的路由守卫，属于data，methods等的同等级配置选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25bcf7db1f37af0ea26cabf484c5756b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870c1647d03dd2b83e8edf5600fb984c/" rel="bookmark">
			Android的JSON解析（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍖🍖 作者 ： 不良使
🍖🍖🍖🍖 潜力创作新星 华为云享专家
🍖🍖🍖🍖🍖 Python+Android
🍖🍖🍖🍖🍖🍖 博客记录学习的思路，项目和错误,寻找志同道合的朋友
🍖🍖🍖🍖🍖🍖🍖 如果觉得有帮助记得一键三连 ┗|｀O′|┛ 嗷~~
JSON（JavaScript Object Notation, JS对象简谱）是一种轻量级的数据交换格式。它基于 ECMAScript（European Computer Manufacturers Association, 欧洲计算机协会制定的js规范）的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。
🥭🥭JSON数据解析 Android里面一个很重要的方面就是接受后端接口数据，解析JSON字符串。已经解析数据了，那么依赖和网络权限应该都已经开了，我们直入主题。没有去单独写接口，下面我们以okhttp的同步请求进行讲解。写完了想了想还是把依赖和权限操作加在后面
activity_main
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tv" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="这是一个TextView"/&gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="getSync" android:text="get同步请求" /&gt; &lt;/LinearLayout&gt; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.JsonReader; import android.util.Log; import android.view.View; import android.widget.TextView; import org.jetbrains.annotations.NotNull; import org.json.JSONArray; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/870c1647d03dd2b83e8edf5600fb984c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39da0ba3c2bda9d791d5615681eddd5/" rel="bookmark">
			HTTPS下强制重定向认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全准入对终端设备最开始和直接的就是强制其认证合法性。
原有基于HTTP重定向认证已失效，因为HTTP不安全。且浏览器都强制HSTS技术只能HTTPS。
怎么在HTTPS下还能重定向来认证？
住宿酒店和搭乘飞机时会对我们有所启发。接入提供的免费WIFI后会重定向。
结论就是诱使OS发出HTTP。
技术背景 网络准入产品可以验证终端设备是否安全，使用强制网络门户认证技术实现此验证
强制网络门户认证(captive portal），终端入网后，强制弹出浏览器的认证页面，强制用户认证后使用网络HSTS(HTTP Strict Transport Security), 防止MiTM中间人攻击，浏览器强制使用HTTPS与服务器创建连接，用户无法发出HTTP请求Captive Portal实现依赖于阶段性的HTTP劫持，当设备入网后，通过DHCP服务获取本机IP地址和网关地址后，发出的HTTP请求被劫持后返回重定向到指定的HTTP认证页面 存在问题 用户终端入网后先用浏览器手动访问HTTPS网站时，返回给终端浏览器的重定向响应，由于浏览器验证服务器证书不匹配会警告，无法实施强制认证，使此技术方案失效。如图用户终端网络在线时，由管控服务端实施准入策略，在未认证前断网，直到浏览器发出HTTP后被准入服务重定向后去认证。由于浏览器预制的HSTS域名缓存或服务端支持HSTS技术，HTTP被浏览器强制转换为HTTPS，致使浏览器验证服务器证书不匹配会警告，使此技术方案失效原有准入系统实施基于浏览器http重定向的认证功能，在https下失效，报错证书不匹配，无法实施强制认证，使此技术方案失效。 可以利用OS的一个机制 操作系统：Windows/Linux/MacOS/Android/iOS下 刚入网时回探测是否需要认证，先探测有强制门户，再做认证
终端操作系统入网后探测是否处于认证网关之下，多次尝试连接指定的HTTP的url，最长超时 30 秒如果指定服务返回了204状态码，即未发现强制门户，不需要验证如果指定服务返回HTTP重定向认证，即强制门户认证，认证后网络放行 图1 OS发出探测
图2 OS收到无强制门户的204状态
以下是部分固定的探测强制门户的url
Windows :http://www.msftconnecttest.com/connecttest.txt Google：http://www.gstatic.com/generate_204 / ， ... Android:https://www.google.com/generate_204，... 小米： http://connect.rom.miui.com/generate_204 华为： http://connectivitycheck.platform.hicloud.com/generate_204 如何利用OS的这个机制 在交换机或浏览器上处理，诱发OS发出强制门户认证探测
两种方案各有优劣，也可同时使用
交换机方案依赖交换机的控制，普通服务没有控制交换机的权限浏览器方案依赖用户先打开浏览器 图3 HTTPS重定向的网络拓扑
基于交换机的技术方案 准入服务控制交换机对终端断网后再开网终端重新入网诱发其探测强制门户Windows尝试强制认证，访问http://www.msftconnecttest.com/connecttest.txt终端桌面上托盘中的网络图标闪烁，提示用户点击图标，会打开浏览器并跳入认证页面准入服务流量截获HTTP请求并重定向到认证页面 终端 交换机 强制门户 准入服务 |&lt;---断网后再开网----| | | | | |-------------探测强制门户--------&gt;|----捕获HTTP----&gt;| | | | | |&lt;------------发送模仿强制门户的重定向认证------------| 表1 基于交换机的HTTPS重定向
交换机实施控制技术 与终端直连的交换机将终端地址通过snmp trap上报准入服务准入服务给指定终端断网再入网snmpset [up / down] 基于浏览器证书的技术方案 客户端浏览器 网络通讯 服务器(流量镜像)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39da0ba3c2bda9d791d5615681eddd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3f8c45e2a5fa6b324950c1dfc729d4/" rel="bookmark">
			【学习 vite &#43; vue3 &#43; pinia &#43; ts】框架搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建项目 Vite 需要 Node.js 版本 &gt;= 12.0.0
npm init vite@latest yarn create vite
// 或者
# npm 6.x
npm init vite@latest 项目名称 --template vue
# npm 7+, 需要额外的双横线：
npm init vite@latest 项目名称 -- --template vue
# yarn
yarn create vite 项目名称 --template vue
以上命令，根据自己需要取一行即可。我用的是yarn create vite，没有yarn的可以安装一下
npm install -g yarn 二、给路径配别名 yarn add @types/node -D //或者 npm i --save-dev @types/node
修改vue.config.ts
import { resolve } from 'path' export default defineConfig({ //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed3f8c45e2a5fa6b324950c1dfc729d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699200dd8f08b2aa12c2e874a6be6d5a/" rel="bookmark">
			Zookeeper 集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 Zookeeper 简介 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。
zookeeper 集群node节点数量 n -1宕机，集群仍然可以正常提供服务，所以一般以奇数的节点组成集群，故集群节点数量通常为 3节点，5节点 … 二、 Zookeeper 集群部署 部署环境 操作系统IP主机名CentOS Linux release 7.5.1804 (Core)192.168.169.10zk-node1CentOS Linux release 7.5.1804 (Core)192.168.169.20zk-node2CentOS Linux release 7.6.1810 (Core)192.168.169.30zk-node3 1、zookeeper 依赖 JDK，检查每个节点是否安装jdk ，如果没有则需安装JDK
[root@zk-node1 zookeeper]# java -version //执行命令会显示JDK版本信息 openjdk version "1.8.0_161" OpenJDK Runtime Environment (build 1.8.0_161-b14) OpenJDK 64-Bit Server VM (build 25.161-b14, mixed mode) 2、zookeeper 节点之间需要互相通信，需要关闭防火墙，保证节点之间网络连通正常，在每个节点执行
[root@zk-node1 zookeeper]# setenforce 0 [root@zk-node1 zookeeper]# sed -ri 's/^(SELINUX=).*/\1disable/g' /etc/selinux/config [root@zk-node1 zookeeper]# systemctl stop firewalld [root@zk-node1 zookeeper]# systemctl disable firewalld 3、zookeeper 官网下载安装包，上传至所有节点服务器，并解压
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/699200dd8f08b2aa12c2e874a6be6d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a744c222ff56d33ea5d6590acf8653f3/" rel="bookmark">
			Java 异常的捕获及处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎个人主页：亮点的博客
🍊个人信条：理想如果不向现实做一点点屈服，那么理想也将归于尘土
🍑刷题专栏：【Java】牛客网刷题
🥭刷题网站：牛客网 学习的一种有效途径就是刷题，丰富的做题经验可以加深对知识点的理解，推荐一款刷题网站，赶快点击这里注册学习吧👉你的进阶之路！
前言 在Java中程序的错误主要是语法错误和语义错误。一个程序即使在编译时没有错误信产生，在运行时也有可能出现各种各样的错误导致程序退比，那么这些错误在Java中统一称为异常，在Java中对异常的处理提供了非常方便的操作。
学习内容：
了解异常的产生原理。 掌握异常处理语句的基本格式。 掌握throw和throws关键字的作用。 可以自定义异常。 了解Exception与RuntimeException的区别。 了解断言的作用。 ​
文章目录 前言1、异常的基本概念2、throws与throw关键字（1）throws关键字（2）throw关键字（3）范例throw与throws的应用 3、Exception类与RuntimeException类4、自定义异常类5、断言 1、异常的基本概念 异常：就是在程序运行过程产生的错误，它会中断正在运行的程序。
Java异常是Java提供的用于处理程序中错误的一种机制。所谓错误是指在程序运行的过程中发生的一些异常事件（如：除0溢出，数组下标越界，所要读取的文件不存在）。
设计良好的程序应该在异常发生时提供处理这些错误的方法，使得程序不会因为异常的发生而阻断或产生不可预见的结果。
Java程序的执行过程中如出现异常事件，可以生成一个异常类对象，该异常对象封装了异常事件的信息并将被提交给Java运行时系统，这个过程称为抛出（throw）异常。
当Java运行时系统接收到异常对象时，会寻找能处理这一异常的代码并把当前异常对象交给其处理，这一过程称为捕获（catch）异常。
public class Test { public static void main(String[] args) { String friends [] ={ "Tom","John","Jenni" }; for (int i = 0;i &lt; 4;i++){ System.out.println(friends[i]);. } } } 🌻在Java之中如果要进行异常的处理，可以使用：try、catch、finally这几个关键字来完成，其基本的处理结构如下：
try{ //可能出现异常的语句 }[catch(异常类型 异常对象){ //异常处理 }catch(异常类型 异常对象){ //异常处理 }catch(异常类型 异常对象){ //异常处理 }.....] [finally { 不管异常是否处理都要执行 ； }] 🌻处理异常
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a744c222ff56d33ea5d6590acf8653f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70edee9e5e7c8fda6a0ed747de023d52/" rel="bookmark">
			使用node加密excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 万能的node生态，直接上npm包 xlsx-populate
const XlsxPopulate = require('xlsx-populate'); XlsxPopulate.fromBlankAsync().then(workbook =&gt; { workbook.sheet("Sheet1").cell("A1").value("Some sample text"); return workbook.toFileAsync("./Book1.xlsx", { password: "S3cret!" }); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb0e83315fd6f09d34ca7cfc4460316/" rel="bookmark">
			动态时间规整算法: 从DTW到FastDTW
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 动态时间规整算法: 从DTW到FastDTW总结：简介[^1]DTW[^1]FastDTW：使用多级粗化的方法[^1]结果 动态时间规整算法: 从DTW到FastDTW 总结： FastDTW作者对DTW的改进点很巧妙！先通过举例说明在一些情况下目前现有的方法对DTW改进的缺陷，然后阐述自己的算法如何避免这些缺陷，最后还在三个数据集上证明在较长时间序列数据中取得线性复杂度。 说明在做算法时，在无法找到更低复杂度的方法的时候，可以考虑在牺牲一些可接受的准确度的情况下实现更低的复杂度算法！！！同时，必须通过实验证明准确度降低的程度，文中就使用正常复杂度算法和近似复杂度算法进行对比，从而计算出降低的准确率！！最后，可以吸取现有的一些改进的基础上，再进一步改进，就比在原始的DWT算法上改进的效果更好！！！！ 简介1 Dynamic time warping：动态时间扭曲 (DTW) 是一种在两个时间序列之间找到最佳对齐的技术，其中一个时间序列可以通过拉伸或收缩其时间轴来非线性地“扭曲”。 这种比对可用于找到对应的区域或确定两个时间序列之间的相似性。 DTW 经常用于语音识别，以确定两个波形是否代表相同的口语短语。 在语音波形中，每个语音的持续时间和声音之间的间隔是允许变化的，但整体语音波形必须相似。 DTW 还用于许多其他学科 ，包括数据挖掘、手势识别、机器人技术、制造和医学。 一个时间序列“扭曲”到一个示例如图 所示: FastDTW：动态时间规整 (DTW) 具有平方时间和空间复杂度，这限制了它在大时间序列中的使用。 后面有很多优化，本文主要解释 FastDTW，它是 DTW 的近似，具有线性时间和空间复杂度。 FastDTW 使用多级方法，从较粗的分辨率递归地投影计算并细化投影。 从理论上和经验上证明了 FastDTW 的线性时间和空间复杂度。FastDTW 与其他两种现有的近似 DTW 算法进行比较来分析 FastDTW 的准确性：约束（例如 Sakoe-Chiba Bands）和抽象。 与现有方法相比，准确性有了很大提高。使用的方法太过巧妙，如下所示： 1) 粗化——将时间序列缩小为更小的时间序列，以更少的数据点尽可能准确地表示相同的曲线。 2) 投影——在较低分辨率下找到最小距离扭曲路径，并将其用作更高分辨率最小距离扭曲路径的初始猜测。 3) 细化——通过局部调整扭曲路径来优化从较低分辨率投影的扭曲路径。
DTW1 动态时间扭曲 (DTW) 是一种在两个时间序列之间找到最佳对齐的技术，其中一个时间序列可以通过拉伸或收缩其时间轴来非线性地“扭曲”。最初的实现是使用动态规划，使用数学表达如下： D ( i , j ) = D i s t ( i , j ) + m i n [ D ( i − 1 , j ) , D ( i , j − 1 ) , D ( i − 1 , j − 1 ) ] , 其中： i = 1 , 2 , ⋯ , x _ l e n + 1 ; j = 1 , 2 , ⋯ , y _ l e n + 1 D(i,j)=Dist(i,j)+min[D(i-1,j),D(i,j-1),D(i-1,j-1)], \\其中：i=1,2,\cdots,x\_len+1;j=1,2,\cdots,y\_len+1 D(i,j)=Dist(i,j)+min[D(i−1,j),D(i,j−1),D(i−1,j−1)],其中：i=1,2,⋯,x_len+1;j=1,2,⋯,y_len+1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afb0e83315fd6f09d34ca7cfc4460316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4305e5863cb032127e7206588103832a/" rel="bookmark">
			双连通与网络可靠性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 割点的定义 如果去掉有向图G中的顶点v及其关联的边，剩下的图将不再联通，则顶点v被称为割点。
2. 双连通的定义 没有割点的连通图称为2-连通的（也称为块）。图G中极大的2-连通子图称为G的一个2-连通分支。
3. 深索数的定义 当采用深度优先遍历算法时，顶点v被访问的序数称为v的深索数，记做DFN(v)
4. 割点的特征分析 (1) 关于深度优先搜索树T，图G的每一条边（u，v）的两个端点u、v之间，或u是v的祖先，或v是u的祖先，即不是平辈关系。
(2) 树T的根是图G的割点当且仅当其在T中至少有两个子节点。
(3) 如果节点u既不是根也不是叶，那么它不是G的割点当且仅当u在深度优先搜索树T中的每个子节点w都至少有一个子孙（或w本身）关联着一条边e（实际上是余边），e的另一个端点是u的某个祖先（e一定是树T的余边）。
(4) 叶节点不能是割点。
由（3）、（4）可知，深度优先搜索树T的非根节点u是G的割点当且仅当u至少有一个儿子w，w及其子孙都不与u的任何祖先相邻。同时u的深索数一定小于其子孙的深索数，所以深索数DFN并不能反映一个顶点是否是割点的情况。为此，我们递归地定义各个顶点u的最低深索数L(u)
5. 最低深索数L(u) 顶点u的最低深索数L(u)定义为
L(u) = min{DFN(u), min{DFN(x)|(u,x)是T的余边},min{L(w)|w是u的子节点}} 结论：如果u不是深度优先搜索树的根，则u是图G的割点当且仅当u有某个子节点w看，w的最低深索数不小于u的深索数，即存在v的子节点w，使得
L(w)&gt;=DFN(u) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718c778a46a0559371461e8742698897/" rel="bookmark">
			Vue开发需要的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue开发文档：Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)webpack：概念 | webpack 中文网 (webpackjs.com)组件网址： 移动端：
1. Vant https://youzan.github.io/vant2. Cube UI https://didi.github.io/cube-ui3. Mint UI http://mint-ui.github.io PC端：
1. Element UI https://element.eleme.cn2. IView UI https://www.iviewui.com Vuex：https://github.com/vuejs/vuex ES6：ES6入门文档-ES6官方文档,ES6新特性,ES6标准入门文档,ES6教程 (caibaojian.com)
Vue笔记（他人总结）：
vue3: https://github.com/Panyue-genkiyo/vue3-learning
vue2依据脚手架:https://github.com/Panyue-genkiyo/vue-advance
vue基础不依赖脚手架:https://github.com/Panyue-genkiyo/vue-learning HTML 5+CSS+js笔记（他人总结）：https://github.com/JERRY-Z-J-R/I-love-you-3-thousand/tree/master/
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/126/">«</a>
	<span class="pagination__item pagination__item--current">127/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/128/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>