<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e02c4a3c73e68ca438d61fce0c22f97/" rel="bookmark">
			win10 conda 虚拟环境迁移到不能联网的主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地的conda环境 查找本机conda环境下的路径
win+r 打开运行窗口，输入cmd,打开命令行窗口，输入
conda info --envs 可以找到虚拟环境的路径。以pytorch环境为例。
复制整个虚拟环境 由于环境包含的包比较多，可能要很久。
等待离线主机anaconda装好，再复制过去
复制与envs同路径下的pkgs pkgs文件夹同样需要复制
Anaconda安装包 下载 使用清华镜像：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/
清华大学
vscode 下载 注意：需要下载.zip压缩包，而不是安装器
为能够使用python, 还要安装python插件
插件下载 VSCOD插件下载：https://marketplace.visualstudio.com/vscode
下载的插件格式为.vsix
插件离线安装 点击扩展，点击省略号，选择 install from vsix,找到下载好的插件的路径即可。
环境迁移 将pytorch文件夹全部复制到anaconda安装路径的envs文件夹下。
将pkgs文件夹替换掉原有的pkgs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4dca4d2d73de2ad39684afd74e215eb/" rel="bookmark">
			怎样轻松实现一个 EventEmitter？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎样轻松实现一个 EventEmitter？ 之所以要特地讲解这部分知识，是因为虽然严格意义上来说，events模块属于 Node.js 服务端的知识，但是由于大多数 Node.js 核心 API构建用的是异步事件驱动架构。
在开始前请先思考几个问题：
EventEmitter采用什么样的设计模式？EventEmitter常用的API是怎样实现的？ Events 基本介绍 Node.js的events模块对外提供了一个 EventEmitter 对象，用于对 Node.js 中的事件进行统一管理。因为 Node.js 采用了事件驱动机制，而 EventEmitter就是 Node.js 实现事件驱动的基础。在 EventEmitter的基础上，Node.js中几乎所有的模块都继承了这个类，以实现异步事件驱动架构。
为了对此有一个大概的了解，先来看下 EventEmitter的简单使用情况，代码如下。
const events = require('events'); const eventEmitter = new events.EventEmitter(); eventEmitter.on('say',(name)=&gt;{ console.log('hello',name); }) eventEmitter.emit('say','mark'); // hello mark 以上代码中，新定义的eventEmitter是接收 events.EventEmitter模块 new之后返回的一个实例，eventEmitter的 emit方法，发出 say事件，通过 eventEmitter的 on方法监听，从而执行相应的函数。
常用的 EventEmitter 模块的 API 除了上面的那段代码中已经使用的 on和emit这两个 API，EventEmitter还提供了其他的 API方法，我通过一个表格简单整理了一下对应的方法和功能总结。
方法名方法描述addListener(event,listener)为指定事件添加一个监听器到监听器数组的尾部prependListener(event,listener)与addListener相对，为指定事件添加一个监听器到监听器数组的头部on(event,listener)其实就是addListener的别名removeListener(event,listener)移除指定事件的某个监听器，监听器必须是该事件已经标注过的监听器off(event,listener)removeListener的别名removeAllListeners([event])移除所有事件的所有监听器，如果指定事件，则移除指定事件的所有监听器setMaxListeners(n)默认情况下，EventEmitters中如果添加的监听器超过10个就会输出警告信息；setMaxListeners函数用于提高监听器的默认限制的数量。listeners(event)返回指定事件的监听器数组emit(event,[arg1],[arg2],[…])按参数的顺序执行每个监听器，如果事件有注册监听返回true,否则返回falseonce(event,listener)为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器 除此之外，还有两个特殊的事件，不需要额外手动添加，下表所示的就是 Node.js 的 EventEmitter模块自带的特殊事件。
事件名事件描述newListener该事件在添加新事件监听器的时候触发removeListener从指定监听器数组中删除一个监听器，需要注意的是，此操作会改变处于被删监听器之后的那些监听器的索引。 addListener 和 removeListener、on 和 off 方法对比 addListener方法的作用是为指定事件添加一个监听器，其实和 on方法实现的功能是一样的，on其实就是 addListener方法的一个别名。二者实现的作用是一样的，同时 removeListener方法的作用是为移除某个事件的监听器，同样 off也是 removeListener的别名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4dca4d2d73de2ad39684afd74e215eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/281b4fbcdef3a6e2e18cc8642c016292/" rel="bookmark">
			00后确实卷，公司新来的卷王，我们这帮老油条真干不过.....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		都说00后躺平了，但是有一说一，该卷的还是卷。这不，前段时间我们公司来了个00后，工作没两年，跳槽到我们公司起薪18K，都快接近我了。后来才知道人家是个卷王，从早干到晚就差搬张床到工位睡觉了。
最近和他聊了一次天，原来这位小老弟家里条件不太好，一大家子指望他一个人养活，所以他再大三的时候就已经开始自学Java了，大四获得了一个小公司的实习机会。在工作中不断的学习、实践，花的时间比别人多一倍，所以才能打下扎实的基础，现在工作也是得心应手。
前段时间程序员节刚刚过去，而1024程序员节设立的意义正是在于向那些追求知识、技术和创新的程序员们致敬。
我认为这位小老弟正式我们学习的榜样，倒不是说应该学习他加班内卷，而是他这种不断学习进阶的精神!
为了助力程序员朋友们跳槽面试、升职加薪、职业困境，提高自己的技术，本文给大家整了一套涵盖Java架构面试进阶所有技术栈的快速学习方法和资源。
包括各大厂最新面试题以及面经，还有涉及JVM，Mysql，并发，Spring，Mybatis，Redis，MQ，Zookeeper，Netty，Dubbo，Spring Boot，Spring Cloud，数据结构与算法，设计模式，网络与操作系统等相关技术领域的大厂面试题及详解。若是感兴趣想学习的朋友点击文末名片扫码免费领取，无套路。
笔记内容 基础篇 JVM 篇 多线程 &amp;并发篇 Spring 篇 MyBatis 篇 MySQL 篇 SpringBoot 篇 SpringCloud 篇 Dubbo 篇 Nginx 篇 MQ 篇 数据结构与算法篇
Linux 篇 Zookeeper 篇 Redis 篇 分布式篇 网络篇 设计模式 maven 篇 ElasticSearch 篇 tomcat 篇 Git 篇 简历篇 限于平台篇幅原因，更多内容展示不了，点击下方名片扫码，无套路免费领取完整版PDF文档。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3dea849b79a9cbbb608e2463e5fd28/" rel="bookmark">
			css快速入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在开始之前，先做说明：本文只涉及到基本css知识，如果有做前端开发的同学跳过即可，本文针对刚刚入门以及从其他方向转向前端开发的同学。众所周知，CSS并不是一门编程语言，它的学习在前期主要来源于对属性的积累和各种属性的联合搭配，所以并不存在学通一门编程语言再学css就进度飞快的情况.
本文总结了作者所认为的，css入门必学的知识点，其他的可以在开发中，通过百度练习逐渐掌握，以下是本文所涉及的内容。
css基本使用方式和常用选择器css层叠性和权重css常用属性css盒子模型浮动position定位flex弹性盒子
css十分困难，以至于几乎没有人敢说自己是css大神，但是入门却十分简单，接下来让我们开始css的学习过程。
注意：本文默认读者拥有一定的html知识，对html部分不做说明。 css基本使用方式和常用选择器 在开始学习之前，选择一个喜欢的开发环境。因为只是学习的原因，这里就推荐两个比较轻量的编辑器。Hubuilderx 和 VsCode.VsCode比较好用，但是需要自己安插件，如果懒的话，就用Hubuilderx吧，不过Hubuilderx是国产的，体验上有点问题。（亲身体会，并非看不起国产）。
HBuilderX-高效极客技巧 (dcloud.io)
Download Visual Studio Code - Mac, Linux, Windows
现在我们开始学习，在编辑器上新建文件，并且编辑基本html代码。
&lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;针对后端开发的css快速入门教程&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;开始css学习&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;一个无序列表&lt;/li&gt; &lt;li&gt;一个无序列表&lt;/li&gt; &lt;li&gt;一个无序列表&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;一个有序列表&lt;/li&gt; &lt;li&gt;一个有序列表&lt;/li&gt; &lt;li&gt;一个有序列表&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;这是一行段落&lt;/p&gt; &lt;div&gt;一个平平无奇的div元素路过。。。。&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 按下电脑F12或者右键浏览器选择检查元素，可以打开控制台。这里就是浏览器调试代码的地方。可以看到我们现在页面的样子已经出现，只是只有html光秃秃的。
css基本使用方式 css的引入有三种方式，内链式，外链式，和行内式。其实就是css写在不同的三个地方。这个可以自己去百度一下，很简单，这里就带过，我们直接使用外链式，给我们的h1标签写上样式。在body里面加上style标签，表示我们在这里面写css样式。
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;针对后端开发的css快速入门教程&lt;/title&gt; &lt;style&gt; h1 { color: red; } &lt;/style&gt; &lt;/head&gt; 可以看到，h1标签已经有了样式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a3dea849b79a9cbbb608e2463e5fd28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f74162252a863d41f3c592dce26984/" rel="bookmark">
			接口，封装练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个题大多数初学者应该都会遇见：
定义一个接口MediaPlayer，表示家庭影院的一个设备。MediaPlayer 中包含play()，stop()， open()三个方法，分别表示播放、停止和开仓功能。 MediaPlayer 有三个实现类，分别为：DVDPlayer，表示DVD 播放器；CDPlayer，表示CD 播放器；TapePlayer，表示录音机（播放磁带）。类图如下：
创建一个遥控器Controller 类。该遥控器有三个控制通道，可以分别控制三个设备。部分代码如下：
class Controller { private MediaPlayer[] players; public Controller() { // 构造函数中初始化players 数组 } // 对相应的设备调用play 方法 public void play(int i) { players[i].play(); } } 要求：
1) 完成MediaPlayer 接口及其子类的代码。
2) 把Controller 补充完整，完善其构造函数，并为其增加stop(int i)和open(int i)方法 。
代码：
接口：
package com.xiaobai; //接口，媒体播放机 public interface MediaPlayer { // 播放 void play(); // 停止 void stop(); // 开仓 void open(); } DVDPlayer类：
package com.xiaobai; //DVD播放机 public class DVDPlayer implements MediaPlayer { @Override public void play() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6f74162252a863d41f3c592dce26984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ae8bc754da3bef037715b916a05096/" rel="bookmark">
			Navicat工具获取操作数据库和表的SQL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具
Navicat Premium 15MySQL服务器技术 SQL语句MySQL 在使用Navicat Premium 15客户端时，对数据库和表进行操作，会产生SQL语句。有时我们不记得SQL语句如何编写，可以直接从工具中获取SQL语句。下面利用实例说明获取SQL语句的几种方法：
操作步骤：
从数据库表获取SQL语句 1、打开Navicat Premium 15工具，选择一个数据库连接
2、选择一个数据库表，鼠标右键，选转储SQL文件—&gt;结构和数据，导出SQL脚本
3、打开SQL文件，复制新建表和插入记录语句
从数据库表记录获取SQL语句 1、打开数据库表，选中表记录
2、鼠标右键选复制为Insert语句或Update语句
3、新建一个查询，鼠标右键粘贴语句
从新建数据库表获取SQL语句 1、在表鼠标右键新建表，插入几个字段
2、切换到SQL预览，复制SQL语句
从历史日志获取SQL语句 1、点击工具，选泽历史日志
2、打开历史日志，复制SQL语句
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aae0335864f678271eb8ad2cbedea6f/" rel="bookmark">
			交换机telnet远程登陆配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验环境配置 Switch_2960 1台；PC（终端） 1台；直连线；配置线
实验步骤 新建拓扑图
配置交换机管理ip地址（进入VLAN1接口，设置IP地址）
//进入特权模式 switch&gt;en //进入全局配置模式 switch#conf t //进入vlan 1 接口 switch(config)#int vlan 1 //配置IP地址 switch(config-if)#ip address 192.168.1.254 255.255.255.0 //开启vlan 地址栏 switch(config-if)#no shutdown 结果演示：
3.配置进入特权模式的密码、连接console端口的密码及telnet的登录密码
//在全局配置模式下设置进入特权模式的密码 switch(config)#enable password 123456(自定义密码) //进入console口 switch(config)#line console 0 //设置进入端口的密码 switch(config-line)#password 123456（和上面的密码不一定要一样） //开启密码登录 switch(config-line)#login //进入telnet口 switch(config)#line vty 0 4 //设置密码 switch(config-line)#password 123456(和上面的密码不一定要一样) //开启密码登录 switch(config-line)#login 结果演示：
提醒： PC（终端机）同样需要配置同网段的IP地址
验证 在pc端使用telnet的方式登录交换机（需验证telnet的登录密码）
对交换机进行管理，并验证进入特权模式的密码。
//telnet远程登录交换机 PC&gt;telnet 192.168.1.254 提醒：输入的密码不会有显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0db6a66c7e5fbd8349642fde16753b2/" rel="bookmark">
			iterm堡垒机rz和sz环境配置（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用人群：更灵活使用iterm上传和下载
1、首先要有iTerm2
iTerm2官网下载地址:iTerm2下载链接
2、本地安装lrzxz
brew install lrzsz 3、下载iterm2-send-zmodem.sh 和 iterm2-recv-zmodem.sh脚本文件
见附件
iterm2-send-zmodem.sh
#!/bin/bash osascript -e 'tell application "iTerm2" to version' &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm if [[ $NAME = "iTerm" ]]; then FILE=`osascript -e 'tell application "iTerm" to activate' -e 'tell application "iTerm" to set thefile to choose file with prompt "Choose a file to send"' -e "do shell script (\"echo \"&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0db6a66c7e5fbd8349642fde16753b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59cd252e6c0eb94a636e7fbc47ecd6fe/" rel="bookmark">
			认识常见的显卡外接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下几种为显卡接口的常见类型：
1、VGA接口；（Video Graphics Array 视频图形阵列）
VGA接口是最常见的、应用最广的显卡接口，电脑显示器连接的很多都是这种接口，以前的CRT显示器用的也是这种接口，它也称为D-Sub。
它支持高达2028×1536分辨率，支持热拔插，一般电脑显示器在20英寸以下使用，大尺寸下字体看着有点虚。
VGA是模拟信号，如果要转为数字信号可能造成一些细微的损耗，对应的就是数字图像的显示效果差一点。目前高端显示器可能没有了这种接口。
这个接口最常见的一个故障就是缺色或者掉色，可能就是红、绿、蓝的某一个针歪了。
2、DVI接口；（Digital Video Interface）
DVI接口有3种类型5种规格，包括DVI-A、DVI-D和DVI-I的接口形式。
我想多了解一些硬件信息，在网络上收集了一些资料的说明，略微做了修改，关注电的正负、电压的大小、时钟和数据。
了解一下即可。
3、HDMI接口：（High Definition Multimedia Interface 高分辨率多媒体接口）
高清晰度多媒体接口是一种数字化视频/音频接口技术，是适合影像传输的专用型数字化接口，其可同时传送音频和影音信号，最高数据传输速度为5Gbps。
这种接口接口目前常见。
4、DisplayPort接口；
俗称DP接口，相比HDMI传输更为先进和稳定。
上面是目前比较常见的，还有其他的DMS59，这个用得少，有59针，外形呈现梯形；
比如手机上用的圆形接口，可充电和传输数据，这个比较复杂，电脑上还没有开始普及。
还有Mini HDMI接口和Micro HDMI接口，Mini DisplayPort接口和Thunderbolt接口（雷电接口）等等，就是HDMI和DP接口都有标准和Mini、Micro之分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca61ee8daa186678101a20b36c8b8944/" rel="bookmark">
			pyhton根据城市名称获取省份名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取地理数据
Fetching geodata with geopy
在Feature Engineering的环节中经常会遇到地理数据的处理。地理数据通常包括地市\省份\经纬度等信息，这些不同level的特征可以被利用在模型训练中。
但是通常我们能拿到的数据只是部分信息，如果想要增加特征维度，Python的geopy是一个获取geographic data很好的package。它内含地区的完整地址和经度纬度，并且支持包括中英文在内的多语言输入。
以下是geopy的基本查询方式：
!pip install geopy from geopy.geocoders import Nominatim # initiate nominatim geolocator = Nominatim(user_agent="aaa515") # search for location location = geolocator.geocode("广州市") print(location.address) print((location.latitude, location.longitude)) print(location.raw) &gt;&gt;&gt;广州市, 广东省, China 中国 &gt;&gt;&gt;(23.1301964, 113.2592945) &gt;&gt;&gt;{'place_id': 235779999, 'licence': 'Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright', 'osm_type': 'relation', 'osm_id': 3287346, 'boundingbox': ['22.5176916', '23.9360754', '112.9529252', '114.0500833'], 'lat': '23.1301964', 'lon': '113.2592945', 'display_name': '广州市, 广东省, China 中国', 'class': 'boundary', 'type': 'administrative', 'importance': 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca61ee8daa186678101a20b36c8b8944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe2b27cf9cbd4a3e02b54ad02061336a/" rel="bookmark">
			python中使用time.pref_counter()精确计时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		time.pref_counter()返回一个CPU级别的精确时间值，以秒为单位。
它通常用于测量某段程序的运行时间，因此取两次调用pref_counter()的差值才有意义。
import time time_start = time.perf_counter() for i in range(100000): a = 0 time_end = time.perf_counter() time_consumed = time_end - time_start print("耗费的时间: {} s".format(time_consumed)) 耗费的时间: 0.0059451 s
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb062cd4e139fd27b8891be7d5c2629f/" rel="bookmark">
			模电_第八章_功率放大电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述功放电路的类型基本分类功放电路的性能指标 乙类互补对称功放电路基本电路结构工作原理静态分析动态分析 分析计算输出功率管耗电源供给功率功率转换效率 甲乙类功放电路交越失真甲乙类功放的原理电路OCL(output capacitorless)功放电路OTL功放电路基本电路结构性能分析 综合电路读图集成功放电路LM384内部结构LM384外部电路通用集成运放F007 概述 功放电路的类型 基本分类 根据功率管导通时间/导通角的不同将功放电路分为甲类、乙类、甲乙类和丙类等多种类型。
功放电路的性能指标 最大输出功率 P o m a x P_{omax} Pomax​，功放电路提供给负载的最大交流信号(正弦波)功率 P o m a x = ( V o m a x 2 ) × ( I o m a x 2 ) = 1 2 V o m a x I o m a x P_{omax}=(\frac{V_{omax}}{\sqrt2})\times(\frac{I_{omax}}{\sqrt2})=\frac{1}{2}V_{omax}I_{omax} Pomax​=(2 ​Vomax​​)×(2 ​Iomax​​)=21​Vomax​Iomax​功率转换效率 η = P o m P v × 100 % \eta=\frac{P_{om}}{P_v}\times 100\% η=Pv​Pom​​×100%总谐波失真 T H D = V 2 2 + V 3 2 + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb062cd4e139fd27b8891be7d5c2629f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9bb4712e3cc85295dc20b3788b6097c/" rel="bookmark">
			海康机器人工业相机常用参数功能设置与获取（持续更新全-C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康机器人工业相机常用参数功能设置与获取（C语言） 前言相机属性树1.设备控制/DeviceControl1.1相机序列号获取/DeviceSerialNumber1.2相机自定义命名设置与获取/DeviceUserID1.3相机上电时间获取/DeviceUptime 2.相机格式控制/ImageFormatControl2.1获取相机图像最大宽、高值2.2设置相机图像ROI区域2.3恢复相机图像ROI区域，恢复最大值2.4获取相机支持的图像格式2.5修改相机图像格式2.6打开/关闭相机自带测试图像2.6.1关闭测试图像（默认状态）2.6.2打开测试图像 2.7打开/关闭相机图像X镜像、Y镜像2.8打开/关闭相机嵌入式图像水印功能 3.采集控制/AcquisitionControl3.1采集模式设置3.2多帧采集设置/AcquisitionBurstFrameCount3.3帧率控制/AcquisitionFrameRate3.4触发模式设置3.4.1软触发设置/Software3.4.2硬触发设置/line3.4.3任意触发设置/Anyway 3.5曝光设置3.5.1手动曝光设置3.5.2自动曝光设置3.5.3超短曝光设置 3.6HDR多曝光增益切换 4.模拟控制/AnalogControl4.1模拟增益设置4.2数字增益设置4.3伽马设置/Gamma4.4锐度设置/Sharpness4.4.1相机锐度设置4.4.2SDK锐度设置 4.5白平衡设置/BalanceWhiteAuto4.5.1 自动白平衡4.5.2 手动白平衡 5.数字IO控制/DigitalIOControl5.1IO输出控制5.2IO输出输出事件介绍 6.动作命令控制/ActionControl7.文件访问控制/FileAccessControl8.事件监视/EventControl8.1曝光结束时间 9.数据块控制/ChunkDataControl10.传输层控制/TransportLayerControl10.1心跳时间设置 11.用户集控制/UserSetControl11.1保存参数到相机11.2恢复出厂默认参数 前言 本文简单直接粗糙的介绍下海康工业相机常用的参数的设置方法与获取方法
1.海康工业SDK简介：海康机器人工业相机sdk简介
2.海康工业相机参数设置获取通用方法：海康工业相机参数设置与获取
如果不心急，就先简单阅读上述两篇博客，可以更加熟悉海康的工业相机sdk的整体构成
参数实在是太多，有空慢慢更新啦…
相机属性树 1.设备控制/DeviceControl 1.1相机序列号获取/DeviceSerialNumber MVCC_STRINGVALUE stStrValue; memset(&amp;stStrValue, 0, sizeof(MVCC_STRINGVALUE)); nRet = MV_CC_GetStringValue(handle, "DeviceSerialNumber", &amp;stStrValue); if (MV_OK != nRet) { printf("Get DeviceSerialNumber fail! nRet [0x%x]\n", nRet); } printf("Current DeviceSerialNumber [%s]\n", stStrValue.chCurValue); 结果：
1.2相机自定义命名设置与获取/DeviceUserID nRet = MV_CC_SetStringValue(handle, "DeviceUserID", "UserIDChanged"); if (MV_OK != nRet) { printf("Set DeviceUserID fail! nRet [0x%x]\n", nRet); } MVCC_STRINGVALUE stStrValue; memset(&amp;stStrValue, 0, sizeof(MVCC_STRINGVALUE)); nRet = MV_CC_GetStringValue(handle, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9bb4712e3cc85295dc20b3788b6097c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98461188d3483c816a11640cb7c3814/" rel="bookmark">
			火狐：导入一个相同证书报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		火狐浏览器报错 建立安全连接失败 连接到 www.baidu.com 时发生错误。您正试图导入一个与已存在证书相同颁发者和序列号但却不相同的证书。错误代码SEC_ERROR_REU 解决：
鼠标放在浏览器最上方边框处点击右键，选择菜单栏，选择更多故障排除信息。打开配置文件夹
删除cert9.db和cert8.db文件就成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61377364a6da56764bfde5b1487a975/" rel="bookmark">
			模电_第七章_正弦波振荡电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础组成产生条件起振条件和稳幅原理稳幅措施 RC正弦波振荡电路RC串并联网络的选频特性RC桥式振荡器的工作原理 模拟比较器概述单门限比较器过零比较器应用1:正弦波转换为方波应用2:限幅电路 迟滞比较器单门限比较器存在的问题工作原理滞回特性曲线 方波发生电路电路结构工作原理 三角波发生电路基于波形变换非波形变换 基础 组成 正弦波振荡电路能产生正弦波输出，它是在放大电路的基础上加上正反馈形成的。
为了获得单一频率的正弦波输出，还应该有选频网络：
选频网络往往和正反馈网络或放大电路合二为一；选频网络由R、C和L、C等电抗性元件组成；正弦波振荡器的名称一般由选频网络命名。 正反馈量难以控制，如果反馈过大，容易产生非线性失真，如果反馈过小，易导致停振。所以，必须要有一个稳幅电路。
综上所述，正弦波振荡电路由以下四个基本部分组成：
放大电路正反馈网络选频网络稳幅电路 产生条件 关键点：自己振起来，不需要持续的外部输入。
关于上述表示，需要补充的是：
欧拉公式: e j ϕ = cos ⁡ ϕ + j sin ⁡ ϕ e^{j\phi}=\cos\phi+j\sin\phi ejϕ=cosϕ+jsinϕ，那么 F ˙ = F m ∠ ϕ = F m e j ϕ \dot F=F_m\angle\phi=F_me^{j\phi} F˙=Fm​∠ϕ=Fm​ejϕ。
起振条件和稳幅原理 稳幅措施 被动稳幅：既然环路增益大于1，起振后就要产生增幅振荡，需要靠三极管大信号运用时的非线性特性去限制幅度的增加，这样电路必然产生失真。这就要靠选频网络的作用，选出失真波形的基波分量作为输出信号，以获得正弦波输出。主动稳幅：在反馈网络中加入非线性稳幅环节，用以调节放大电路的增益。 RC正弦波振荡电路 RC串并联网络的选频特性 RC桥式振荡器的工作原理 RC振荡电路在取反馈系数的最大值时，开环增益与反馈系数同相。此外，为了满足稳幅条件，还需要设置合适的电阻。
信号分别交给反馈网络和选频+稳幅网络，输出放大后的正弦波信号。
在这里，输入信号和净输入信号应该是一回事，所以可以用前面闭环增益的公式。
模拟比较器 概述 功能：讲一个模拟电压信号与一参考电压相比较，输出一定的高低电平。
原理：运放组成的电路处于非线性状态，输出与输入的关系 v o = f ( v i ) v_o=f(v_i) vo​=f(vi​)是非线性函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b61377364a6da56764bfde5b1487a975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18e6c04e55f7d31c38341df833144e2d/" rel="bookmark">
			Java开发工程师，每个阶段需要掌握什么重点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文着重介绍一下Java开发工程师各个层次需要掌握的重点，1-3年Java初级工程师-&gt;3-5年Java中高级工程师-&gt;5-8年以上的Java架构师的成长之路。
Java初级工程师技能要求：
工作1-3年
要求：能独立完成分配的模块开发任务
技术要求：
1、掌握最基础的数据结构：数组、链表、堆、栈、队列、Hash表、二叉树等
2、算法：经典排序：插入排序、冒泡排序、快排(分化交换排序)、直接选择排序、堆排序、合并排序等。
3、语言要求：基本的开发基础语言掌握，比如：面向对象，集合类、网络IO。
4、数据库要求：能独立设计数据库表，掌握sql，索引等。
Java初级阶段的重点主要是掌握好编程相关的基础内容，开发框架与数据库的操作比较熟练。
Java中、高级工程师技能要求：
工作3-5年：
要求：能独立设计核心模块，并完成编码工作。
技术要求：
三年及以上使用Java开发的经验，Java基础扎实，理解io、多线程、集合等基础框架，了解JVM原理;
对用过的开源框架，能了解到它的原理和机制;对Spring,ibatis,struts等开源框架熟悉;
熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制;能对分布式常用技术进行合理应用，解决问题;
Java中高级阶段的重点主要是需要对Java高级多线程、框架、JVM等开始能深入了解了，而不是仅仅停留在初级阶段的会使用，而是需要能深入技术原理了，对于分布式相关的也开始接触了。
Java架构师技能要求：
工作5-8年
要求：能独立设计大型网站的架构能力，核心和关键问题的掌握能力
技术要求：
5年及以上使用Java开发的经验，对于你用过的开源框架，能了解到它的原理和机制; 2.精通Mysql、Oracle等关系数据库设计和开发，对数据库性能优化有丰富的经验;
3.精通多线程及高性能的设计与编码及性能调优，有高并发应用开发经验;
具有大型分布式系统研发经验，对常见的中间件如分布式缓存、消息队列、RPC等有丰富的使用经验和深入理解; 5.思路清晰，有良好的业务理解、系统分析和软件设计能力; 具有良好的沟通能力和横向推动能力;
如果到了架构师这个阶段，除了掌握好上面高级的内容，对分布式高并发:缓存、消息队列、RPC等需要能很深入底层的实现，而且架构设计的能力也需要具备了，能独家操盘一个大型项目!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2b0bf6f6cadd7e443c062f798bceda/" rel="bookmark">
			yolov5如何开启和关闭mosaic(马赛克)增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结： 将 hyp.scratch.yaml中的mosaic设置为0，表示关闭马赛克增强
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ca64eda2864719460698df1ccf9867/" rel="bookmark">
			Linux运维面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apache怎么实现负载均衡
答案：
多台机器跑apache，然后其中一台跑nginx，让nginx去代理多台apache实现负载均衡
一台Linux服务器负载高，连接慢，怎么查看
答案：
先用w看负载多少，用top看哪个进程占用cpu高，同时用top按M看哪个进程占用内存多，用iotop看哪个进程读写频发，用sar命令或者nload命令查看网卡流量，是否跑满带宽
现有A文件，编写shell脚本判断A文件中大于5的数字，输出
答案：
for d in sed 's/[^0-9]//g' A; do if [ $d -gt 5 ]; then echo $d;fi; done
怎么判断文件为空的
答案：
[ ! -s filename ]
Linux服务器中程序经常自动停止如何处理
答案：
可以先写监控脚本，当发现进程不存在时自动启动。 然后要查各个日志，看看程序为什么会自动停止，只有找到根本原因，才能真正解决问题
TCP断头最小长度是___字节？ 答案：20字节
简述TCP三次握手的过程？
答案：
在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据
简版：首先A向B发SYN（同步请求），然后B回复SYN+ACK（同步请求应答），最后A回复ACK确认，这样TCP的一次连接（三次握手）的过程就建立了
dmesg命令中看到ip_conntrack: table full， dropping packet.，如何解决？ 答案：
ip_conntrack表的最大值由参数ip_conntrack_max控制，查看当前设置的最大值可通过命令： cat /proc/sys/net/ipv4/ip_conntrack_max
redhat默认大小是65536，这个值的大小是有机器的内存决定的，65536是1G内存的大小，如果你的内存不止1G，那么设置的数值大小就是65536的倍数。2G是131072，4G是262144。数值可以比当前内存可设置的最大值小，但是不能超过最大值，要不然设置之后是不生效的。
要查看当前系统ip_conntrack的大小可以通过命令：
cat /proc/sys/net/ipv4/netfilter/ip_conntrack_count
设置方法如下：
方式一：
echo 131072 &gt;/proc/sys/net/ipv4/ip_conntrack_max
要实现每次开机后都生效的话，要加到开机启动脚本/etc/rc.local里，其他开机自动运行的脚本也行。
方式二：
echo ‘net.ipv4.ip_conntrack_max=131072’ &gt;&gt; /etc/sysctl.conf
sysctl -p
这样每次开机都能自动设置该参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4ca64eda2864719460698df1ccf9867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b595469d82f54b44ebb0e3178ddd35/" rel="bookmark">
			Element-ui中 表格（Table）组件中 toggleRowSelection 方法设置默认多选项 无法选中解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： Element-ui中，表格（Table）的 toggleRowSelection 方法无法默认选中的情况。
需求：对将设置为选中的内容进行部分修改，如：默认选中的内容必须得通过接口或者其他方式来获取，然后再默认选中。
&lt;template&gt; &lt;div class="wrap"&gt; &lt;el-table border ref="multipleTable" :data="tableData" tooltip-effect="dark" style="width: 100%" @selection-change="handleSelectionChange"&gt; &lt;el-table-column type="selection" width="55"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="日期" width="120"&gt; &lt;template slot-scope="scope"&gt;{{ scope.row.date }}&lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="120"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址" show-overflow-tooltip&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;div style="margin-top: 20px"&gt; &lt;el-button @click="toggleSelection([tableData[1], tableData[2]])"&gt;切换第二、第三行的选中状态&lt;/el-button&gt; &lt;el-button @click="toggleSelection()"&gt;取消选择&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { tableData: [{ date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-08', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-06', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-07', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }], multipleSelection: [] } }, methods: { toggleSelection(rows) { if (rows) { rows.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b595469d82f54b44ebb0e3178ddd35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3c5aaa61dbd59aa5cfe831e9b5e4f5/" rel="bookmark">
			armabi armabi-v7a armabi-v8a 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		armabi armabi-v7a armabi-v8a 区别
armeabi默认选项，32位
支持基于 ARM* v5TE 的设备
支持软浮点运算（不支持硬件辅助的浮点计算）
支持所有 ARM* 设备
armeabi-v7a 32位
支持基于 ARM* v7 的设备
支持硬件 FPU 指令
支持硬件浮点运算
armeabi-v8a 64位
支持基于 ARM* v8 的设备
支持硬件 FPU 指令
支持硬件浮点运算
不同手机由于cpu的不同，使用不同的驱动。
ABI:指应用基于哪种指令集来进行编译，ABI总共有四种，分别是armeabi、armeabi-v7a、mips、x86，它们都是表示cpu的类型。
• 为了减小 apk 体积，只保留 armeabi 和 armeabi-v7a 两个文件夹，并保证这两个文件夹中 .so 数量一致
• 对只提供 armeabi 版本的第三方 .so，原样复制一份到 armeabi-v7a 文件夹
早期的Android系统几乎只支持ARMv5的CPU架构，现在支持7种！
Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。
应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android 系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64- v8a，mips64，x86_64。
各版本分析如下：
• mips / mips64: 极少用于手机可以忽略
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c3c5aaa61dbd59aa5cfe831e9b5e4f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18ca3b2dedd9382443b3815413eeb65/" rel="bookmark">
			10个有用的css编辑网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10个有用的css编辑网站 Neumorphism 官方网站：https://neumorphism.io/
此网站不但可以为section或div生成软UI，还可以自定义border-radius、box-shadow等。
Shadows Brumm 官方网站：https://shadows.brumm.af/
可以生成多个分层阴影，提供非常酷的效果，你也可以自定义颜色。
CSS Clip-path Maker 官方网站https://bennettfeely.com/clippy/
可以生成具有各种不同形状的漂亮剪辑路径，非常方便。
Fancy Border Shape Generator 官方网站https://9elements.github.io/fancy-border-radius/
通过操纵border-radius生成各种形状，并且可以在项目的任何地方使用。你还可以更改形状的大小，以便根据项目偏好检查其外观。
Cubic Curve 官方网站https://cubic-bezier.com/
基本上，它的作用是为你在css中的动画生成贝塞尔曲线(cubic-bezier)。我们知道，使用动画的ease-in、ease-out等属性可以告诉浏览器动画的流程是什么。而你则可以在这里自定义这些属性。
CSS Gradient 官方网站https://cssgradient.io/
如果你经常要用到渐变，那么你一点会喜欢CSS Gradient。我已经用了很长时间，非常完美。而且你还可以在CSS Gradient上获得一些工具，比如渐变按钮等等。
CSS波形生成器 7.1 CSS Waves
官方网站https://getwaves.io/
通过一些自定义生成简单的波纹。
7.2 Gradient Multiple Waves
官方网站https://www.softr.io/tools/svg-wave-generator
可以生成多个渐变波，非常棒。
7.3 Multiple Animated Waves
官方网站https://svgwave.in/
可以生成多个渐变波，但主要特点是还能生成实时动画。
CSS网格生成器 8.1 CSS grid
官方网站https://cssgrid-generator.netlify.app/
可以为Grid生成很棒的css，你可以使用div对其进行自定义，它还将为此创建子元素。
8.2 CSS Grid Area
官方网站https://grid.layoutit.com/
生成Grid Area。你可以根据需要命名并自定义该区域。
Loading Animated GIFs/SVGs 官方网站https://loading.io/
在这里你可以生成多个加载动画并将其下载为SVG、GIF、PNG和其他格式，但它最棒的特点是你可以将这些动画自定义到一个新的水平。值得尝试。
免费图标库 10.1 Flaticons
官方网站https://www.flaticon.com/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e18ca3b2dedd9382443b3815413eeb65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8335be46cc52fb6d11b5ec7a26fea68/" rel="bookmark">
			prism RegionContext（区域上下文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 按照《prism项目搭建》搭建prism项目
2 新建用户控件库ModuleA，并为其创建Views，ViewModels，Model目录
3 在Model里面新建类
using Prism.Mvvm; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ModuleA.Model { public class Person:BindableBase { private string _firstName; public string FirstName { get { return _firstName; } set { _firstName = value; SetProperty(ref _firstName, value); } } private string _lastName; public string LastName { get { return _lastName; } set { _lastName = value; SetProperty(ref _lastName, value); } } private int _age; public int Age { get { return _age; } set { _age = value; SetProperty(ref _age, value); } } public override string ToString() { return String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8335be46cc52fb6d11b5ec7a26fea68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f373a02d6887bb284995b9d8cb73f50/" rel="bookmark">
			Debian11 安装Chromium浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 sudo apt-get update
2 sudo apt-get install chromium chromium-driver
3 安装语言包，中文
sudo apt-ger install chromium-l10n
4 查看版本
chromium --version
其他：也可以直接从 新立得软件中心直接搜索 chromium 安装。
设置1：清除历史记录、cookie
设置--隐私设置和安全性--cookie和网站数据--退出Chromium时清除Cookie及网站数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86868c9e499bcd30f64e30dda896a1d1/" rel="bookmark">
			【Matlab基础】数据拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、线性拟合
1. 常用辅助函数
2. 多元线性拟合
例子：
二、多项式拟合
三、lsqcurvefit函数
例子1：
例子2：
四、nlinfit非线性拟合
例子1：
例子2：
五、其他拟合函数
lsqnonlin
fittype
一、线性拟合 1. 常用辅助函数 format：变换数据显示格式
simple：简化符号表达式或矩阵
syms：定义符号变量
pretty：显示为标准印刷格式
roundn(a,-4)：将a的数值保留为4位小数
2. 多元线性拟合 例子： X1=[ones(length(X(:, 1)), 1), X]; %%加值为1的一列，因为拟合方程中有常数项 [beta, bint, r, rint, states]=regress(Y, X1) % 多元线性回归 % y=beta(1)+beta(2)*x1+beta(3)*x2+beta(4)*x3+... % beta—系数估计 % bint—系数估计的上下置信界 % r—残差 % rint—诊断异常值的区间 % states—模型统计信息 rcoplot(r, rint) %%绘制残差图 saveas(gcf,sprintf('线性曲线拟合_残差图.jpg'),'bmp'); %%保存为图片 二、多项式拟合 p=polyfit(x,y,m) 对数据进行m次多项式拟合，返回拟合多项式的系数向量
polyval(p,x0)
将x0带入，求出多项式的值
poly2str（p,'t')
把系数向量转化为多项式的代数表达式
三、lsqcurvefit函数 例子1： xdata=[1,2,3]; ydata=[14,35,67]; fun=@(x,xdata)x^2+sin(x); %%拟合函数？ x0=[0,0,0]; %系统初值 y=lsqcurvefit(fun,xo,xdata,ydata) 例子2： function yy=myfun(beta,x) %自定义拟合函数 yy=beta(1)+beta(2)*x(:, 1)+beta(3)*x(:, 2)+beta(4)*x(:, 3)+beta(5)*(x(:, 1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86868c9e499bcd30f64e30dda896a1d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c601603acb9e77f6d31c61202c939ebc/" rel="bookmark">
			C语言——数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定义
C 语言中给了数组的定义：一组相同类型数据的集合。 例如： int arr [ 10 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; // 定义一个整形数组，最多放 10 个元素 那么这些数有没有什么要求呢，是不是不管什么数组合在一起都是数组呢？
同一数组中存储的数必须满足以下两个条件：
这些数的类型必须相同。这些数在内存中必须是连续存储的。 2.数组的命名方式
类型说明符 数组名[常量表达式];
例如：
int a[5]; 它表示定义了一个整型数组，数组名为 a，定义的数组称为数组 a。数组名 a 除了表示该数组之外，还表示该数组的首地址。
此时数组 a 中有 5 个元素，每个元素都是 int 型变量，而且它们在内存中的地址是连续分配的。也就是说，int 型变量占 4 字节的内存空间，那么 5 个int型变量就占 20 字节的内存空间，而且它们的地址是连续分配的。
这里的元素就是变量的意思，数组中习惯上称为元素。
在定义数组时，需要指定数组中元素的个数。方括号中的常量表达式就是用来指定元素的个数。数组中元素的个数又称数组的长度。
数组中既然有多个元素，那么如何区分这些元素呢？方法是通过给每个元素进行编号。数组元素的编号又叫下标。
3.数组的下标 C 语言规定：数组的每个元素都有一个下标，下标是从 0 开始的。 数组可以通过下标来访问。 数组中的下标是从 0 开始的（而不是 1）。那么，如何通过下标表示每个数组元素的呢？通过“数组名[下标]”的方式。例如“int a[5];”表示定义了有 5 个元素的数组 a，这 5 个元素分别为 a[0]、a[1]、a[2]、a[3]、a[4]。其中 a[0]、a[1]、a[2]、a[3]、a[4] 分别表示这 5 个元素的变量名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c601603acb9e77f6d31c61202c939ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47a627ef7f31f672340b7ccdc8e5198/" rel="bookmark">
			服务器查看配额限制: OSError: [Errno 122] Disk quota exceeded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSError: [Errno 122] Disk quota exceeded 是因为磁盘配额不够了，即磁盘已满或超出了用户所能使用的配额上限。
可以通过如下命令查看配额限制和已经使用的配额：
quota -uvs username 常用的：
只显示总量
du -h -s /dir
显示目录下的每个子目录的大小
du -h --max-depth=1 /dir
win10预装好了 ssh
win7需要安装 openssh client
然后 配置其环境变量，并配置remote-ssh config中的path路径：为openssh/bin/ssh.exe
然后才可以使用 remote-ssh 插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/673c336b5891d821c8707a391ecfb11f/" rel="bookmark">
			QT QStandardItemModel 数据修改时 触发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. QT QStandardItemModel没有直接对应的数据修改信号。而tableWidget的数据修改信号非常容易触发信号循环。
而采用currnetChanged的方法，却可以避免信号循环。但是判断单元是否修改仍然需要自己处理。
2. 以下是处理函数。
void Wells::on_wellCurrentChanged(const QModelIndex &amp;current, const QModelIndex &amp;previous) { //当前选择变换 ui-&gt;label_before-&gt;setText(lastStr); if (previous.isValid()) { //ui-&gt;label_after-&gt;setText(wellModel-&gt;itemFromIndex(previous)-&gt;text()); afterStr = wellModel-&gt;itemFromIndex(previous)-&gt;text(); ui-&gt;label_after-&gt;setText(afterStr); qDebug()&lt;&lt;previous.column(); }; //比较上一项有无修改。其中lastStr中保存的是未修改前上一个的字符。afterStr中保存的是目前状态上一项的字符。 if (lastStr == afterStr) { qDebug()&lt;&lt;"没有修改"; } else { qDebug()&lt;&lt;"上一项【已经】修改。"; }; //在给上一个赋值 if (current.isValid()) { lastStr = wellModel-&gt;itemFromIndex(current)-&gt;text(); }; //这种方式确实可以 对比 数据的前后变化 */ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3051d338b3e7c33ffab3c3da5e4cff8f/" rel="bookmark">
			canvas实现粒子跟随鼠标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var cn; var c; var u = 10; const m = { x: 0, y: 0 }; // 获取鼠标移动的位置 window.onmousemove = function (e) { m.x = e.clientX; m.y = e.clientY; } // 设置随机颜色 function gc() { var s = "0123456789ABCDEF"; var c = "#"; for (var i = 0; i &lt; 6; i++) { c += s[Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3051d338b3e7c33ffab3c3da5e4cff8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314eaa52e9c81069454c228b73cdd8f5/" rel="bookmark">
			C语言初级篇-----循环语句详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 循环语句
一、while循环
二、for循环
三、do...while循环
四、循环语句练习
getchar 与 putchar
总结
循环语句 if 语句：当条件满足的情况下，if语句后的语句执行，否则不执行。但是这个语句只会执行一次。
生活中很多的实际的例子是：同一件事情我们需要完成很多次。
C语言中给我们引入了循环语句。
C语言中有三种循环语句：
while循环for循环do...while循环 一、while循环 1、语法结构
while(表达式)
{
循环语句;
}
2、while循环的执行流程
3、while循环的使用
打印1~100之间的整数
#include&lt;stdio.h&gt; int main() { //打印1~100 int i = 1; while (i &lt;= 100) { printf("%d ", i); //每打印10个数换行 if (i % 10 == 0) { printf("\n"); } i++; } return 0; } 运行结果：
4、while循环中的break和continue
（1）break
break在循环中的作用：
在循环中只要遇到break，就终止循环（跳出循环）。
while循环遇到break
#include&lt;stdio.h&gt; int main() { int i = 1; while (i &lt;= 100) { if (5 == i) break; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/314eaa52e9c81069454c228b73cdd8f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a029f190403e19348bba18286ce8384c/" rel="bookmark">
			图像分割算法（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：在对处理后的图像数据进行分析之前，图像分割是最重要的步骤之一。它的主要目标是将图像化分为与其中含有的真实世界的物体或区域有枪相关性的组成部分。
加助理小姐姐威信领取课件资料，还有200G人工智能大礼包内含：Pytorch、TensorFlow实战框架视频、图像识别、OpenCV、计算机视觉、深度学习与神经网络等视频、代码、PPT以及人工智能书籍，一并可以无套路免费分享给大家！
扫码加V免费咨询学习问题领取资料，大牛答疑、大厂内推
根据目标可将图像分割分为 完全分割 —— 结果是一组唯一对应于输入图像中物体的互不相交的区域。部分分割 —— 区域并不直接对应于图像物体。 其中图像数据的不确定性是主要的分割问题之一，通常伴随着信息噪声。
按照主要特征可以将分割方法分为：
有关图像或部分的全局知识，常用直方图表示。基于边缘的图像分割基于区域的图像分割 一、阈值化 灰度阈值化是最简单的分割处理。很多物体或图像区域表征为不变的反射率或其表面光的吸收率，可以确定一个亮度常量——阈值，从而来分割物体和背景。
方法主要是依据对所有像素的函数值与阈值 T 比较，从而确定是物体像素 or 背景像素。应用举例如下图：
（一） 阈值检测方法 1. pp 率阈值化
需要事先知道经过分割后的图像的某种性质，就可以简化阈值选择的任务，因为阈值可以确保该性质得以满足的条件来选择。
缺点：通常没有关于面积比率的先验信息。
2. 模式方法
二模态阈值检测算法通常首先寻找最大的局部极大值，然后取它们之间的极小值作为阈值，这种技术称为模式方法。
还有一些其他的阈值检测方法，例如：直方图凹度分析、熵方法、松弛法、多阈值方法等。
（二）最优阈值化 将图像的直方图用两个或更多个正态分布的概率密度函数来近似的方法，代表一种被称为最优阈值化的方法。这一方法在图像对比度条件变化很大的范围内性能良好。
将最优化和自适应阈值化结合起来的方法可应用与脑MR图像的分割。这种方法的局部子区域中计算局部直方图，以确定最优灰度分割函数。
（三）多光谱阈值化 许多实际的分割问题需要比单一谱段所含的更多的信息。例如，彩色图像的信息包含在三个谱段中，气象卫星图像可能具有更多的谱段。一种分割方法是在每个谱段中独立确定阈值，然后综合起来形成单一的分割图像。
例如，下图的算法步骤解释：
二、基于边缘的分割 基于边缘的分割代表了一大类基于图像边缘信息的方法。基于边缘的分割依赖于由边缘检测算子找到的图像边缘，这些边缘表示除了图像在灰度、彩色、纹理等方面不连续的位置。
在分割处理中可获得的先验信息越多，能达到的分割效果越好。
（一）边缘图像阈值化 在边缘图像中几乎没有0值像素，但是小的边缘值对应于由量化噪声、弱不规则照明引起的费显著的灰度变化。可以对边缘图像做简单的阈值化处理排除这些小的数值。这种方法是基于图像的边缘幅度由合适的阈值处理实现。
（二）边缘松弛法 由于边缘图像阈值化方法得到边界受图像噪声的影响很大，经常会遗漏重要的部分。通过在它们相互邻域的上下文中考虑边缘的性质能够增加图像的品质。
所有的图像性质包括进一步的边缘存在性在内，都经过迭代评价而精确性提高，直至所有的边缘上下文完全清晰位置。这种评价是基于指定局部邻域内的边缘强度进行的，每个边缘的信度可能被增加 or 被减小。
（三）边缘跟踪 如果区域的边界未知，单区域本身在图像中已经定义了，那么边界可以唯一地检测出来。算法如下：
还有一些其他的搜索方法，eg.基于图的边缘跟踪、作为动态规划的边缘跟踪、Hough变换、使用边界未知信息的边界检测等方法。
三、基于区域的分割 以区域的边界构造区域以及检测存在的区域的边界是容易做到的。但是，通过基于边缘的方法和由区域增长方法得到的分割，通常并不总是相同的。因此引入了基于区域的分割方法。
（一）区域归并 最自然的区域增长方法是原始图像数据上开始增长，每个像素表示一个区域。算法如下：
（二）区域分裂 与区域归并相反，从将整个图像表示为单个区域开始，该区域一般不能满足条件H(Ri)=True,i=1,2,...SH(Ri)=True,i=1,2,...S。
区域分裂方法一般使用与区域归并方法相似的准则，区别仅在于应用的方向上。
（三）分裂与归并 这种方法可以兼有分裂与合并两种方法的优点。分裂与归并方法在金字塔图像表示上进行，区域是方形的与合适的金字塔层元素对应。
算法如下图：
除以上之外，还有分水岭分割、区域增长后处理等方法。
小编整理了有关Python人工智能的资料，有图像处理opencv\自然语言处理、机器学习、数学基础等资源库，想学习人工智能或者转行到高薪资行业的，大学生也非常实用，无任何套路免费提供, 扫码+vx领取，也可以咨询学习问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bedeaae2897ac874df7811081d57d0ad/" rel="bookmark">
			Element implicitly has an ‘any‘ type because expression of type ‘any‘ can‘t be used to index type 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Typescript
let obj = { a: "hey", b: "you", c: "guys" }; for (const k in obj) { console.log(obj[k].toUpperCase()); // error! /* Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ a: string; b: string; c: string; }'. */ } 这里的问题是 TypeScript 中的对象类型是开放的或可扩展的，而不是封闭的或精确的。您可以在 TypeScript 中为对象添加额外的属性，而不会违反其类型。这在某些情况下非常有用：它允许您通过添加属性来扩展接口和子类。但在其他情况下，这是一种痛苦：
编译器将 obj 视为 {a: string, b: string, c: string} 类型的值。由于这种类型并不精确，当你执行 for (const k in obj) 时，编译器知道 k 将采用值“a”、“b”和“c”，但它不知道这些是唯一可能的值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bedeaae2897ac874df7811081d57d0ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869406dd90e7e47a960f3bfcbf18e612/" rel="bookmark">
			1秒钟启动一个下载服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.在电脑上设置（192.168.3.4）：
humanlsj@humanlsj-PC:~/Downloads/downloadDir$ pwd 查看当前目录的位置
/home/humanlsj/Downloads/downloadDir humanlsj@humanlsj-PC:~/Downloads/downloadDir$ ls 查看目录下有些什么
humanlsj@humanlsj-PC:~/Downloads/downloadDir$ touch abc.txt 创建一个abc.txt文件
humanlsj@humanlsj-PC:~/Downloads/downloadDir$ vim abc.txt 在abc文件内写入内容
humanlsj@humanlsj-PC:~/Downloads/downloadDir$ python -m SimpleHTTPServer 启动简单http服务器
端口被占用的报错，因为之前用过8000端口，所以再次启动时要用其它端口。例如：8001
Traceback (most recent call last):
File "/usr/lib/python2.7/runpy.py", line 174, in _run_module_as_main
"__main__", fname, loader, pkg_name)
File "/usr/lib/python2.7/runpy.py", line 72, in _run_code
exec code in run_globals
File "/usr/lib/python2.7/SimpleHTTPServer.py", line 235, in &lt;module&gt;
test()
File "/usr/lib/python2.7/SimpleHTTPServer.py", line 231, in test
BaseHTTPServer.test(HandlerClass, ServerClass)
File "/usr/lib/python2.7/BaseHTTPServer.py", line 606, in test
httpd = ServerClass(server_address, HandlerClass)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869406dd90e7e47a960f3bfcbf18e612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b826d991d260dc0a4c05a6aa7b01388/" rel="bookmark">
			TDL、CDL信道模型简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要参考：3GPP TR 38.811
TDL（Tapped Delay Line）抽头延时线模型 TDL模型主要针对多径时延参数和反映信道时变特性的多普勒参数进行研究，主要有TDL-A、TDL-B、TDL-B、TDL-D、TDL-E五种。其中前三者为NLOS传输的多径信道模拟，后两者为LOS传输的多径信道模拟。
适用频带范围：0.5GHz 到 100GHz 频率范围内最大带宽 2GHz 的地面多径信道
可以参考如图所示的TDL模型示意图，假设接收信号是由不同时延的多径射线叠加，下图里的一个抽头就代表上图里一条多径射线，抽头系数表示射线的增益、时延等参数。
信道的冲激响应可以表示如下：
TDL模型可以由FIR滤波器实现。
TDL是简化模型，本身是为SISO设计的，但是可以通过扩展，比如重复多次加上引入空间相关性来对MIMO信道建模。
CDL（clustered Delay Line）簇延时线模型 主要有CDL-A、CDL-B、CDL-B、CDL-D、CDL-E五种，其中前三者为NLOS传输的多径信道模拟，后两者为LOS传输的多径信道模拟。
CDL模型和TDL模型的主要区别在于：
1.CDL模型中引入了簇的概念，其中，簇就是具有相似到达角、离开角和时延的多径集合。簇的概念可以参考下图。
2.除了时延delay和功率power两个参数以外，CDL模型增加了离开方位角AOD、到达方位角AOA、离开天顶角ZOD、到达天顶角ZOA，用来表征信道模型的空间特性。这也是CDL的特点之一，它是为3D通道设计的，能更好地表征空间相关性。
3.CDL簇的数量最多有24个，可以表征更多的波束。
CDL模型可以对天线阵列建模，具有空间相关性，而且引入了离去角和到达角，能更好得表征空间特性。
TDL信道系数：
（很多。。。）
（TDL可能更适合端到端的建模，CDL更适合径更多、需要考虑空间特性的场景，猜测。。。）
参数调整 TDL、CDL都是可以对参数进行调整，适用于实际仿真需求。
1.均方根时延扩展调整
TDL和CDL支持根据实际仿真需要调整均方根时延扩展：
2.K因子调整
对于CDL/TDL-D和CDL/TDL-E的LOS通道模型，可以调整K因子。
令期望调整后的K因子为Kdesired，那簇功率（CDL）或者抽头功率（TDL）为：
其中Pn,scaled和Pn,model是簇/抽头调整后和调整前的功率，模型的K因子Kmodel为：
调整完功率之后，需要对时延扩展重新计算。
调整K因子本质是调整各个簇/抽头之间的功率，K因子越大，第一个簇/抽头中的视距径部分的功率就越大，在通信过程中视距分量所占比重越大。
3.角度调整
CDL中预定义的角度值可以通过引入角度平移和缩放来推广。通过平移，改变平均角度，通过缩放，改变角度扩展。
以上大概就是自己看到的一些东西，做个记录，关于TDL/CDL A-E具体每种对应什么场景我还不太清楚，也没有实际仿真过，可能还有理解不对、不全的地方。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4766e8d909331536e20f6d3f0a7c36/" rel="bookmark">
			【Tools】机器视觉工业相机客户端安装详解教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00. 目录 文章目录 00. 目录01. 概述02. 机器视觉工业相机客户端下载03. 机器视觉工业相机客户端安装04. 机器视觉工业相机客户端测试05. 附录 01. 概述 MVS V3.3.1是为支持海康机器视觉相机产品而开发的软件应用程序，适用于所有海康机器视觉面阵以及线阵相机产品。 MVS包含了客户端，IP配置工具，固件升级工具，导入/导出属性工具、日志查看工具、网卡配置工具，驱动管理工具，系统信息工具，诊断工具，带宽管理工具，SDK和Demo。
软件版本
MVS3.3.1 build201207
功能特性
1、网口和USB相机可自动搜寻同子网下连接的所有设备，CameraLink相机可手动搜寻所连接设备
2、支持查看和修改相机设备参数、搜索指定参数
3、支持同时连接、采集、预览多个相机
4、支持保存个人喜好参数配置以及整套设备参数方案
5、支持实时预览、图片截取、录像存储
6、网口相机支持修改IP配置方式、IP地址、子码掩码、默认网关
7、支持在线设备升级
8、支持GigE Vision动作指令
更新说明
\1. 【MVS】新增编码方式设置，可设置客户端的字符串编码方式
\2. 【MVS】新增cti默认路径设置，可设置使用GenTL标准搜索相机时加载的cti文件的默认路径
\3. 【MVS】新增导出全部设备信息工具，可一键导出客户端的所有基础信息
\4. 【MVS】网口相机新增GVSP配置功能，可设置相机的超时时间
\5. 【MVS】数字IO控制新增线路防抖时间参数，可对触发信号进行去抖处理
\6. 【MVS】新增设置CCM矩阵参数功能
\7. 【MVS】设置查找表新增支持动态生成LUT曲线
\8. 【MVS】优化用户集控制功能的交互
\9. 【MVS】图像预览窗口新增画面拖拽、锐度指示器和RGB导出功能
10.【SDK】新增LSC（镜头阴影矫正）算法功能
11.【SDK】新增对比度增强和锐化算法功能
12.【SDK】新增Bayer色彩插值下的CLUT功能
13.【SDK】新增色彩校正算法功能（CCM和CLUT）
14.【SDK】新增LSC、空域降噪、图像增强和图像校正等算法的VS/C#示例程序
15.【SDK】新增Python多相机示例程序
16.【SDK】扩展Bayer色彩插值下的CCM功能
17.【SDK】扩展Bayer色彩插值下的Gamma调节功能
18.【SDK】噪声估计和空域降噪算法增加对Mono/RGB的支持
19.【SDK】优化VS、C#和VB的多相机示例程序
20.【SDK】优化GigE驱动的取流效率和稳定性
21.【SDK】修正之前版本遗留缺陷
详细更新说明请见MVS安装路径下的ReleaseNote.txt文件
02. 机器视觉工业相机客户端下载 版本：MVS3.3.1 build201207
下载链接：机器视觉工业相机客户端MVS V3.3.1（Windows）
03. 机器视觉工业相机客户端安装 3.1 解压MVS_WIN_STD_3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a4766e8d909331536e20f6d3f0a7c36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd3a09d97975ff327f116a63305ec9c/" rel="bookmark">
			读取Excel文件中的文件名并按照读取的文件名将指定路径下的文件移动到指定的新路径下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取Excel文件中的文件名并按照读取的文件名将指定路径下的文件移动到指定的新路径下 #!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2021/10/27 10:06:27 # @Author : kevin # @Site : # @File : cop_file.py # @Software: PyCharm # encoding=utf-8 import shutil import openpyxl, os workbook = openpyxl.load_workbook(r'C:\Users\点雨洛山岚\Desktop\matlab结果\607份结果\607份数据筛选前.xlsx') # 需要读取的excel表格（数据名称存在这里） CopPath_1 = r'D:\python 拷贝测试\新建文件夹 (2)' # 需要移动的文件路径 PastePath_1 = r'D:\python 拷贝测试\脚本拷贝路径' # 移动的数据需要放在那个文件夹下 sheet = workbook['Sheet'] # Excel必须将页面名称改为Sheet，且格式为.xlsx i, m, a, b = sheet.max_row, 2, 0, 0 list = os.listdir(CopPath_1) # print(list, len(list)) while i &gt;= 0: File_name = str(sheet['A' + str(m)].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd3a09d97975ff327f116a63305ec9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71b6f224ca56239304a0db0a686e085/" rel="bookmark">
			一文读懂数据中台技术架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数钥数据中台，能够提供面向企业业务场景的一站式大数据分析平台，采用大数据、移动互联网、人工智能等先进技术，支撑企业业务创新，随时随地透视经营，辅助企业科学决策，加速企业数据驱动转型变革。
数钥数据中台，基于Hadoop和Spark体系相关技术，融合数据采集、分析、存储能力，以Spring boot微服务形态对外提供服务。
整体架构：
应用架构：
大规模数据管理的能力：
分析云拥有PB级大规模数据管理能力，支持穿透数据库、Hadoop、大规模MPP集群。可支持：
PB级结构化数据PB级非结构化数据 可实现多样化海量数据的统一存储、管理和分析。
Part1 数据存储 Hadoop技术已经经历了十几年的发展，而数据中台作为第二数据平面最重要的数据存储和计算平台，与Hadoop技术的融合越来越紧密，相辅相成，相得益彰。
HBase可以让数据中台保存海量数据；Spark 使得数据湖可以更快的批量分析海量数据;Storm，Flink，NiFi等使数据湖能够实时接入和处理IOT数据。 Hadoop本身更多的聚焦于数据的处理与应用，但是对于底层的数据存储工作则并未过多的关注。数据中台需要从数据存储、数据治理等方面继续发展。
许多企业通常忽略数据积累的价值，数据需要从企业的各个方面持续的收集、存储，才有可能基于这些数据挖掘出价值信息，指导业务决策，驱动公司发展。
数据中台解决方案实现数据集中存储与共享是基于Hadoop+Spark大数据解决方案和海量对象存储架构，实现万亿级数据可靠存储与高效分析。
使用一套数据存储资源池，可有效解决企业中的数据烟囱问题，提供统一的命名空间，多协议互通访问，实现数据资源的高效共享，减少数据移动。
数据集中存储与共享实际上是将存储资源池化，将计算和数据进行分离。当前仍然有不少人不能接受大数据的计算和数据分离架构，认为一旦采用分离架构，必然会导致性能的降低。
但实际上，分离后可极大降低存储成本，有效提高计算资源利用率，增强计算和存储集群的灵活性。
Part 2 数据集成 数据采集是构建数据平台的核心要素，数钥分析云的数据采集层由日志采集和数据库数据同步两部分组成。
1、日志采集：是通过整合全员行为、流程、组织绩效、流程审批效能等数据埋点规范，建立一套高性能、高可靠性的数据传输体系，完成数据从生产业务端到数据平台的传输。数据传输体系既支持实时流式计算，也支持各种时间窗口的批量计算。
2、数据同步：主要是指数据从业务系统同步进入数据仓库和数据仓库同步进入数据服务或数据应用两个方面。致远分析云支持不同业务系统的各类数据源按批量或实时同步到数据仓库中。
数据不仅要存下来，更要治理好，否则数据中台将变成数据沼泽，浪费大量的IT资源。
平台化的数据中台架构能否驱动企业业务发展，数据治理至关重要。
企业中收集的数据或从其他行业中采集数据种类多样，格式不一，多数以原始格式存储，企业需要不断对这些原始数据进行整合加工，根据各业务组织、场景、需求形成容易分析的干净数据，尽可能多的让更多的人访问分析数据。
数据治理是个一系列复杂的工作，这里重点介绍下元数据的管理。
数钥分析云解决方案为企业中海量的数据集提供了一套集中的元数据管理系统，提供全局的数据资源目录、完整的数据元数据描述、数据血缘关系，方便员工快速查找了解数据，更好的支撑数据分析，元数据管理异步的从数据服务中抽取元数据，尽量不影响原系统的运行。
Part 3 数据应用 第一层是绩效层，即重点关注的KPI指标。
随着企业的发展，每个阶段要解决的问题不同，每个阶段每个管理者所关注的指标也不同，这些指标需要我们时时关注，才能保证整个企业的良好运行。通过绩效层指标最容易发现企业存在的问题。
第二层是运营分析层，这层指标是企业的数据支撑。
对这层的指标我们要进行透视分析，深入分析，只有提前发现运营层指标的异常，才能提前预测到KPI指标的异常。通过经营分析层指标，我们可以找到手游出售平台问题产生的根源，才能对症下药，调整企业的管理。对企业进行调整后，又会反馈到运营指标上来，我们可以持续监控调整是否起到了预期的效果。
第三层是业务优化层。
我们要创新，要探索新的模式，就要有数据支撑。我们也可以尝试一些模拟分析。
数钥数据中台中具有开箱即用的ERP分析模型,也可以借助业务模型设计器定义出更多的领域、行业模型。
系统架构：
基于中国企业大多数中层经理以上人员的计算机实际应用水平，在方案应用设计上，应充分考虑用户的实际情况，可根据这些人员平时看报表的顺序，将各类相关联的报表串起来，形成有序化的分析思路，并加以连续展现，辅之以动态多维查询分析功能。
最终的展现效果为一种固定报表格式和固定路径的初级数据钻探方式和动态报表即席查询与多维分析的高级数据钻探方式的相结合应用。
系统应用架构核心设计思想为基于角色的多维度、多层级应用模型。主要包括：
应用角色：系统可满足总经理、财务总监、营销总监、财务经理、营销主管、供应主管、数据分析员、系统管理员等角色的应用需求；数据类型：财务数据、分销数据、终端数据、采购数据、库存数据、综合数据；数据周期：日、月、季度、半年和年。报表形成时间，可根据企业不同管理需求和资料取数的难易情况而定；数据属性：即数据表现形式，分为静态统计类报表、指标类、监控类、分析类（动态分析类报表，图形报表）、决策类（如定价模型、量本利模型等）。 其中，多维度应用包括：
数据横向探察：是对同一经济活动或业务，从不同的角度进行考察和分析，从中揭示并解决存在的问题。如按产品、按区域、按部门、按客户/供应商、按各种对比基准等不同调度考察。数据纵向探察：是对某项经济活动或业务，由粗到细，由广到微，逐层分解并分析其中存在或发生问题的原因。一般考察与分析的习惯与步骤为：先概览总体指标，再阅读基本报表，由此逐层查询，直到查出产生问题的原因或查询到最原始的业务发生依据为止。 其中，多层级应用包括：
管理层（总经理、财务总监等）：基本上关注一些最关键的指标和报表，以阅读总括指标为主，并使用相关的预决策模型。而在应用的思路上至多为指标—报表两层，进一步的分析大多为通过电话或口头指令下级完成；中层经理（财务经理、营销经理等）：主要查看一些跟其主管业务相关的指标和报表，主要是查看具体内容，并使用相关的预决策模型，关注相关业务的执行进度和完成情况，实时监控主管业务的全过程状态。在分析应用的思路上大多为指标—报表—报表的多层联查。而对于更进一步的深层次原因探查则通过动态即席分析实现；数据分析人员（业务分析员、IT技术人员等）：应用主要集中在各种动态即时分析上，通过灵活的拖拉拽、旋转、切片、切块、下钻、上探等操作，实现比较高级的深度数据钻探方式。IT技术人员和业务分析人员还要配合来共同负责物理数据模型的设计、修改和维护工作。作业层人员（业务人员等）：应用最为基础简单，主要是查看跟自己相关的各类具体的业务报表，以明确自己的工作内容和工作成果，及解答领导的相关询问。系统管理员（系统管理员等）：系统维护，用户管理，信息发布，数据备份等工作。 数钥分析云能提供面向企业业务场景的一站式大数据分析解决方案，基于大数据、移动互联网、人工智能等先进技术，全面支撑企业业务创新，随时随地透视经营，辅助企业科学决策，加速企业数据化转型升级，助力企业进行精准营销、战略管控、风险预警等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326e97bafcad184643444ad1ed6636ab/" rel="bookmark">
			2021-10-26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DML:数据操作语言，主要是操作表中的数据。主要是对数据增、删、改。 插入（insert） 语法：insert into 表名(字段1，字段2，字段3，…) values (值1，值2，值3，…);
- - 向表中字段1,字段2,字段3,…等插入一条数据
DQL limit：限制，作用是限制查询结果展现条数。
语法：limit x,y
x：从哪里开始输出，第一条是0
y：条数
--查询stu表中前两条数据 select * from stu limit 0,2; --在stu表中从第二条开始,查询三条数据 select * from stu limit 1,1; 多表联查：
表和表之间的关系：
一对一两张表内的数据，是一行对应一行一对多两张表内的数据，是一行对应多行多对多两张表内的数据，是多行对多行 合并结果集（联合查询） 将查询到的数据纵向拼接
/* 1.联合的表的列数，类型要对应 2.union 会去除两个表中重复数据 3.union all 会保留重复数据 */ select name,birthday from t1 union select id,name from t2; select id,name from t1 union all select id,name from t2; 函数 IF(expr1,expr2,expr3) 如果expr1是TRUE，则IF()的返回值为expr2；否则返回值则为expr3。IF()的返回值为数字值或字符串值，具体情况视其所在语境而定。
--查询学生姓名和成绩，如果没有参加考试，显示“缺考” select sname,if (score is null,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/326e97bafcad184643444ad1ed6636ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c47e2e7c559ee3a352e90f2536feeec/" rel="bookmark">
			基因组survey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几种做基因组survey的方法
包括jellyfish、genomescope2.0、gce等软件
1.jellyfish计算k-mer频率
jellyfish count -C -m 21 -s 1000000000 -t 10 -o reads.jf *.fastq 注意：jellyfish只支持未压缩的fasta格式和fastq格式 ###################################################### # -s 内存 # -t 线程数 # -m kmer值 如果覆盖率低或者错误率高，需要缩小kmer值 # -C 统计正负链	###################################################### #计算k-mer频率的直方图 生成read.histo文件 $ jellyfish histo -t 10 reads.jf &gt; reads.histo R语言结果可视化
&gt;histo &lt;- read.table("readsSH.histo",header = F, sep = " ", stringsAsFactors = F) &gt;ggplot(histo, aes(x=V1, y=V2))+ &gt;P=geom_line(size=0.8,color="#6495ed")+xlim(0,200)+ ylim(0,58000000)+theme_classic()+xlab("K-mer depth")+ylab("Kmer Freqence")+ theme(axis.title.x=element_text(size=15),axis.title.y=element_text(size=15),axis.text.y=element_text(size=12),axis.text.x=element_text(size=12)) &gt;P #在图中添加一条虚线 &gt;P+geom_vline(aes(xintercept=51), colour="#BB0000", linetype="dashed",size=0.8) #xintercept=51 该值为峰值的位置 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c47e2e7c559ee3a352e90f2536feeec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ddad2e2e7105686a1d66075c7ff996/" rel="bookmark">
			八皇后问题（启发式搜索）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八皇后问题是回溯算法的典型案例，在回溯法中，常常是盲目搜索，耗费过多的搜索时间。在本次实验中，使用了启发式搜索，搜索时不是任取一个分支，而是选择最佳的分支往下搜索。
目录
前言：
一、初始化参数：
二、检测某位置是否可以放置皇后
三、某位置放置皇后的调整
四、删除某位置的皇后
五、计算剩余行所剩可以放置皇后位置的个数
六 、呈现最后的矩阵
七、启发式搜索
八、完整代码：
前言： XDU作业：启发式算法解决八皇后问题。
问题描述：问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
一、初始化参数： n：代表皇后的个数，因为规定每行放置一个皇后，所以也可以理解为行数。
checkboard：代表最后呈现出来的矩阵，这里用‘0’表示该位置为空位，既没有放置皇后；用‘1’代表该位置已经放置皇后了。
queen_position: 代表每一行皇后所在改行的列数，因为题目默认是8行，所以设置了8个元素的数组初始值为-1，如果第一行的元素放在第1列，则queen_position[0] = 1。
available_position: 检测该行的某列是否满足可以放置皇后的条件，为三行十五列的矩阵，available_position[0][i]代表i列是否已经放置过皇后了，available_position[1][i]代表该位置的右对角线是否放置过皇后，available_position[2][i]代表该位置左对角线是否放置过皇后。
fx：代表代价。即若该位置皇后后，后面可以放置皇后的位置还有多少个。
answer: 代表该行是否符合可以放置皇后。
二、检测某位置是否可以放置皇后 输入函数的参数为行数和列数。
如果该位置的左对角线，右对角线，及该位置所在的列数都没有放置过皇后，则满足条件。
返回True，则该位置可以放置皇后，返回False，则该位置不满足放置皇后的条件。
#to test the position of [row, col] could be able to place queen or not def queen_admission(row, col): global available_position global queen_position if(available_position[0][col] and available_position[1][row+col] and available_position[2][row-col+n-1]): return True else: return False 三、某位置放置皇后的调整 输入函数的参数为行数和列数。
在该位置放置皇后，则该列的0要置1，左对角线和右对角线的相应的位置都要置1。
并记录该行皇后所在的位置。
#place the queen into [row,col] def place_queen(row, col): global available_position global queen_position queen_position[row] = col available_position[0][col] = 0 available_position[1][row+col] = 0 available_position[2][row-col+n-1] = 0 return None 四、删除某位置的皇后 输入函数的参数为行数和列数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ddad2e2e7105686a1d66075c7ff996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64dc8cdd58951382e106cdddb9b268d5/" rel="bookmark">
			STM32定时器编码器模式无法做到抗干扰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32定时器编码器模式无法做到抗干扰 STM32定时器编码器模式无法做到抗干扰 STM32定时器编码器模式无法做到抗干扰 当使用定时器编码器模式采集AB相编码器脉冲时，若分频系数不为零，则在某一相有干扰脉冲时，无法滤除。只有在分频系数为零时，才可以做到抗干扰。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50bf9b605f0d7c40e7618d716afa783/" rel="bookmark">
			JavaScript中的逗号操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逗号操作符可以用来在一条语句中执行多个操作，如下所示：
在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助
赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：
在这个例子中，num 将被赋值为 2，因为 2 是表达式中最后一项。逗号操作符的这种使用场景并不 多见，但这种行为的确存在。
二、逗号操作符的拓展用法 逗号操作符还有很多意想不到的操作,例如可以使我们的代码最大程度的进行简写,如下所示：
let arr = [{ id: 1, value: '正式' }, { id: 2, value: '非正式' }]
当我们的需要将arr的值处理成为{1: '正式', 2: '非正式'}的时候
按照我们正常的写法来说,用reduce方法是最合适不过的。
let newArr= arr.reduce((acc,item)=&gt;{ acc[item.id]=item.value return acc },{}) console.log(newArr); 这时我们打印输出newArr得到的值就是 {1: '正式', 2: '非正式'} 可以看出这样也是可以得到我们想要求的值,但是如何让这些代码一行就能达到效果呢?
这里我们就可以用到逗号操作符了
let newArr= arr.reduce((acc,item)=&gt; (acc[item.id]=item.value, acc),{}) console.log(newArr); 这里我们输出打印的值也一样可以得到我们需求的值 {1: '正式', 2: '非正式'} 由此可见逗号操作符可以使我们的代码尽可能的进行压缩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd2e2ff1e268eb6b705a51c43333adf2/" rel="bookmark">
			MYSQL的DDL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDL(Data Definition Language)：数据定义语言，用来定义数据库对象：库、表、列等； 库
mysql dbms，数据库管理系统
database 数据库
table 表
column 列
row 行
Mysql数据库管理系统中可以有很多个库，每个库里面可以有很多个表。表里面可以创建多个列。
查看当前mysql下的所有库：show databases;
创建库：creat database 库名;
删除库：drop database 库名;
修改库编码格式：alter database 库名 character set utf8;
不能修改数据库名字
查询当前使用的库：select database();
切换数据库：use 库名；
表
查看所有表：show tablea;
创建表：create table 名字 (
列名 数据类型(长度) [约束],
列名 数据类型(长度) [约束],
…
);
1.列名任意命名
2.数据类型：
整型int长度固定11浮点型double长度(总长, 其中小数个数)float字符型char定长字符，长度0-255,varchar可变长字符text主要存储大文本数据字节型blob字节类型，适合存储图像等日期型date日期，不需要指定长度time时间，不需要指定长度datetime日期时间，不需要会指定长度timestamp时间戳，时间会自动改变 3.每个数据类型后面要指定长度
int(11)，int后面的长度可以省略；
double(5,2)，小数总长5位，其中包含2位小数；
varchar(10)，最长到255；
date，不需要长度；
4.约束，可选操作；
5.每个列定义之间用 , 隔开，最后一列不需要 , 号。
查看表字段信息：desc 表名;
更新表字段—添加列： alter table 表名 add 列名 数据类型(长度);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd2e2ff1e268eb6b705a51c43333adf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91265c8838cb1b48ffa3c4924036e401/" rel="bookmark">
			C#整合layui实现导出带多张图片的word文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近研究了一下如何实现利用C# webapi方式导出word文档，且文档中包含多张图片，现在给出实现过程。
准备阶段：
开发工具vs2017，在项目引用那里右键点击管理NuGet程序包，查询找到word依赖，如下图所示：
下载版本如下图所示，考虑到有的电脑可能装的word版本比较低，因此不需要下载最新稳定包
然后就是安装此依赖，下面开始代码部分
前端：
前端开发使用了web storm2018,开发思路，提供一份表单，文本域部分给用户输入文字部分，上传按钮提供未来需要插入到word中的图片，上传采用多文件上传方式
html部分
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;导出主题&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="layui/css/layui.css" /&gt; &lt;script type="text/javascript" src="layui/layui.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="scripts/jquery-1.10.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="scripts/bootstrap.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style="padding: 20px" width="90%"&gt; &lt;div class="layui-form" action="" lay-filter="breakForm"&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label" style="text-align: center"&gt;标题&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;input type="text" id="title" name="title" value="XXX案例库" class="layui-input" autocomplete="off" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label" style="text-align: center"&gt;作者及机构&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;input type="text" id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91265c8838cb1b48ffa3c4924036e401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c30b4566025c8b5fe6fed30bdfbde1dc/" rel="bookmark">
			Arthas Logger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arthas 用户文档 — Arthas 3.5.4 文档
1、通过sc命令查看JVM已加载的类信息，拿到classLoaderHash
命令：sc -d [查找类的全路径] | grep classLoaderHash
示例：
sc -d com.github.smallAttr.facade.ResourceFacade | grep classLoaderHash
sc -d com.demo.components.MyTestService | grep classLoaderHash
2、查看指定类中log声明的静态成员变量，确定当前类的日志级别（可省略）
命令：getstatic [查找类的全路径] [log静态成员变量]
示例：
getstatic com.github.smallAttr.facade.ResourceFacade log
getstatic com.demo.components.MyTestService logger 3、通过logger命令查看，执行命令后不会输出任何信息，但是不能省略，logger命令相对不太完善
命令：logger --name [查找类的全路径]
示例：
logger --name com.github.smallAttr.facade.ResourceFacade
4、更新指定类日志级别
命令：logger -c [classLoaderHash的值] --name [查找类的全路径] --level [待更新的日志level]
示例：
logger -c 1c20c684 --name com.github.smallAttr.facade.ResourceFacade --level info
logger -c 14dad5dc --name com.demo.components.MyTestService --level debug 5、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c30b4566025c8b5fe6fed30bdfbde1dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5845abd0f6af08831f7a61fc6f6347b4/" rel="bookmark">
			TypeError: Cannot read properties of null (reading ‘split‘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下图：
将 str.split(’,’)
变成
(str || “”).split(’,’)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bb96d7a45394b40929a88ca931494da/" rel="bookmark">
			公司新来的00后卷王整理的 Java 面试题，横扫所有对手……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天是1024程序员节，咱技术人的大日子。近年来科学技术的快速发展，离不开程序员在众多领域发挥着巨大的创造力，而1024程序员节设立的意义正是在于向那些追求知识、技术和创新的程序员们致敬。
不知道昨天大家是趁着周末在休息呢？还是在加班写代码、改Bug？节日过完了，但技术人的狂欢来了，给大家准备的节日福利虽迟但到。
为了助力程序员朋友们跳槽面试、升职加薪、职业困境，提高自己的技术，本文给大家整了一套涵盖Java架构面试进阶所有技术栈的快速学习方法和资源。
包括各大厂最新面试题以及面经，还有涉及JVM，Mysql，并发，Spring，Mybatis，Redis，MQ，Zookeeper，Netty，Dubbo，Spring Boot，Spring Cloud，数据结构与算法，设计模式，网络与操作系统等相关技术领域的大厂面试题及详解，还有相关面试突击系列视频以及学习路线。
【资料合集】
面试篇：
1.BAT&amp;TMD大厂面经汇总
2.新鲜出炉阿里云P7面试题以及详细解答
3.BAT面试突击系列视频
4.大厂算法面试必备与LeetCode刷题精讲视频
5.大厂面试题/手册/电子书
● 大厂面试题及答案 ● 电子书/手册（JVM相关） ● 分布式缓存相关 ●分布式面试详解
资料篇：
1.阿里双十一内部技术资料汇总
2.Java学习必读经典书单合集
3.架构师进阶路线图
4.283页Java核心知识点
99G资料+视频包，免费领取倒计时
☝本号粉丝专属福利：扫码可领取上面资料。
最后150个名额，送完即止
【技术分享】
双11在即，在承受并发能力这块，不得不说最流行的缓存框架Redis了，最近收集了一些关于Redis大厂面试题和技术资料，整理了技术大牛诸葛老师的一个爆款课程，跟Redis如何抗住高并发以及底层架构原理相关，希望在实战技术上可以帮助到大家。
10月27日晚上20：00开始直播，全程高能
补习Redis，面试突击进大厂
2分钱肝一套Redis高并发架构
☝本号粉丝扫码可领上面资料，仅限前150名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3480a1b84270891326b4bcb2e54808c5/" rel="bookmark">
			input 标签 （详解）如何去除输入时边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去掉input边框：
&lt;input type="text"/&gt; input{ boder:0px; } 去除点击后的边框：
input{ outline:none; } css去掉input边框代码：input {
border: 0; // 去除未选中状态边框
outline: none; // 去除选中状态边框
background-color: rgba(0, 0, 0, 0);// 透明背景
}
border 简写属性在一个声明设置所有的边框属性。
可以按顺序设置如下属性：border-width：规定边框的宽度。
border-style：规定边框的样式。
border-color：规定边框的颜色。
outline (轮廓)是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。
注释：轮廓线不会占据空间，也不一定是矩形。
outline 简写属性在一个声明中设置所有的轮廓属性。
可以按顺序设置如下属性：outline-color：规定边框的颜色。
outline-style：规定边框的样式。
outline-width：规定边框的宽度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb1e4da2063cd7f6dabb606e1d333e6/" rel="bookmark">
			Node学习部分小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node学习部分小结 文章目录 node学习部分小结node是什么？node.js模块系统概要关键知识点梳理核心模块和文件模块模块间函数和变量无法访问到的原因function(exports,require,module,```__filename```,```__dirname```)简要理解exports和module.exports的区别为什么会有这样的差别？ node是什么？ node完整的名字是node.js,顾名思义，以js为后缀名那就多少与javascript有点关系。简单的说，Node.js是运行在服务端的JavaScript。是一个事件驱动I/O服务端JavaScript环境，基于V8引擎执行JS。 node.js模块系统 概要 node.js提供模块系统目的是让node.js的文件可以相互调用简要的说一个node.js文件就是一个模块（模块和文件是一一对应的）文件不一定就是JavaScript代码，也可以是JSON文件或者C/C++扩展（编译过的）模块可以分为核心模块和文件模块模块间的变量和函数在其他模块无法访问到，每个JS文件代码都独立运行在一个函数中 关键知识点梳理 核心模块和文件模块 核心模块与文件模块在来源、标识和导入方式上有所区别： 模块来源标识导入方式（*由标识不同导致*）核心模块有node.js引擎提供的模块模块自身的名字为标识require(“模块名”)文件模块用户自己定义的模块模块所在（绝对/相对）路径为标识require（“路径”） 模块间函数和变量无法访问到的原因 node.js的每一个模块都会包装到一个函数中执行：
function (exports, require, module, __filename, __dirname){ //编写的模块代码 } [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S9LzAfsh-1635046263763)(D:\Documents\MarkDown Files\imgs\image-20210925170152630.png)]
如上：在test模块中编写代码console.log(arguments.callee +'');,在main.js中引入并执行得到上图输出结果，得证被引入模块的变量和函数无法被访问到的原因是模块在执行时会被包装到一个函数中，相当于引入了一个函数，变量为局部变量，故而不能被访问到。
function(exports,require,module,__filename,__dirname)简要理解 exports:用来将变量或函数暴露到外部require：函数，用来引用外部的模块，引入模块后会返回一个对象，改对象代表引入得那个模块module：代表当前模块本身，exports是module的一个属性__filename:当前模块的完整路径__dirname：当前模块所在文件夹路径，（__filename的上一级目录） exports和module.exports的区别 exports和module.exports都可以将变量暴露到外部，但方法上有所不同：
exports暴露：方法为：exports.变量名=值；如：exports.num1=10module.exports: module.exports.变量名=值module.exports={变量1=值，变量2=值} 为什么会有这样的差别？ 首先需要理解什么是引用变量，然后最关键的一句话是：exports其实是module.exports的一个引用即：
var exports = module.exports; module.exports={ 变量1=值， 变量2=值} exports.变量名=值； module.exports.变量名=值 exports 只是一个变量（类似C语言中的指针的概念），在栈中存储。而module.exports则是对象实体，在堆中存在。简单说，好比一个仓库，你要往仓库里放东西，如果你知道仓库在哪直接去放就可以，如果不知道在哪，就可以让exports领着你去仓库。
至于exports为什么不能直接赋予一个对象就显而易见了。
——人家本来放的是去仓库的路线，只是领着你去仓库的，你把东西（对象）交给他就好比你给他说这个就是新仓库的地址（如果可以的话），结果人家就把原来的仓库路线给忘了（因为重新赋了值）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7ef4131736e622b982a40bc6f5099c/" rel="bookmark">
			AndroidMP4视频文件推送rtmp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AndroidMP4视频文件推送rtmp，直播 RTMP介绍传送协议功能实现相关代码 配置 RTMP介绍 RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括Adobe Media Server/Ultrant Media Server/red5等。RTMP与HTTP一样，都属于TCP/IP四层模型的应用层。RTMP和RTSP协议已经成为直播的主流协议，对于安防监控等场景应用广泛。
传送协议 RTMP(Real Time Messaging Protocol)实时消息传送协议是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议。
它有多种变种：
1)RTMP工作在TCP之上，默认使用端口1935；
2)RTMPE在RTMP的基础上增加了加密功能；
3)RTMPT封装在HTTP请求之上，可穿透防火墙；
4)RTMPS类似RTMPT，增加了TLS/SSL的安全功能；
功能实现 分为几个步骤：
1.将本地保存的MP4视频文件，读取进行编码H264.H264格式字节。
2.将编码后的字节帧数组组装
3.通过ffmpeg 进行转化
4.链接RTMP远程地址
5.连接成功后将帧数据ffmpeg写入到RTMP连接中
6.用户就能通过RTMP地址查看视频了
相关代码 package com.onzhou.ffmpeg.streamer; /** * @anchor: andy * @date: 2018-10-29 * @description: */ public class NativeStreamer { static { System.loadLibrary("native-stream"); } public native int startPublish(String mp4Path, String stream); public native void stopPublish(); } package com.onzhou.ffmpeg.main; import android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d7ef4131736e622b982a40bc6f5099c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55488e8efcc9216e906fb817dc93eab2/" rel="bookmark">
			Android 源码分析 - 输入 - Java层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入框架层包含一个服务（位于services目录），一个接口（位于core目录），一个工具（位于cmds目录）。
android.view libinput中的C++类，在jni层都有一个对应的Native开头的类，封装libinput中的对象的指针。在java层有一个类对应，其Ptr成员保存Native类的指针。
java源代码位于：frameworks/base/core/java/android/view。
jni源代码位于：frameworks/base/core/jni。
java
jni
C++
InputChannel
NativeInputChannel
InputChannel
KeyCharacterMap
NativeKeyCharacterMap
KeyCharacterMap
InputDevice
InputDeviceInfo
KeyEvent
KeyEvent
MotionEvent
MotionEvent
InputEventSender
NativeInputEventSender
InputPublisher
InputEventReceiver
NativeInputEventReceiver
InputConsumer
InputChannel（java）的静态native方法nativeOpenInputChannelPair()创建一对InputChannel。NativeInputChannel支持序列化Parcel，是跨进程传递UNIX域套接字句柄的关键。
InputEventReceiver 的jni层对象NativeInputEventReceiver通过MessageQueue处理InputChannel文件描述符上的数据到达，通过InputConsumer读取输入事件，回调java层对象方法。这些都在上层Looper线程中执行。另一方面，将应答写入InputChannel。
InputEventSender的jni层对象NativeInputEventSender通过InputPublisher向InputChannel写入输入事件，并通过MessageQueue等待应答，然后读取应答并回调java层。
ViewRootImpl是应用层接收并处理输入事件的关键。其setView方法中创建了一个然后通过IWindowSession（com.android.server.wm.Session实现）注册该窗口，最终由WindowManagerService打开一对InputChannel，并将读取端返回给ViewRootImpl。
ViewRootImpl通过嵌套类WindowInputEventReceiver（继承InputEventReceiver）读取输入事件，事件在队列中排队处理。
类型说明：
类名
说明
InputChannel
KeyCharacterMap
InputDevice
KeyEvent
MotionEvent
InputEventReceiver
InputEventSender
ViewRootImpl
窗口，管理输入事件，调用会话接口使用窗口服务
InputQueue
提供由应用处理输入事件的机制，在native层使用
InputStage
分发策略，如果没有处理（包括丢弃），本地丢弃或者本地处理（onProcess），然后向前转发（onDeliverToNext）
AsyncInputStage
异步分发，保持顺序向前转发。
ViewRootImpl.WindowInputEventReceiver
继承InputEventReceiver，将收到的输入事件排队处理
FallbackEventHandler
输入事件处理器策略基类，在EarlyPostIme、ViewPostIme阶段被调用
android.hardware.input 源代码位于：frameworks/base/core/java/android/hardware/input。
InputManager转发调用到input服务，分发设备增加、删除、改变事件到注册的InputDeviceListener。
com.android.internal.view 源代码位于：frameworks/base/core/java/com/android/internal/view。
内部实现类：
类名
说明
IInputContext
输入法回调应用的接口方法定义，接口是异步的，通过IInputContextCallback返回Get结果
IInputContextCallback
应用响应输入法返回Get请求的信息。
InputBindResult
输入法管理服务成功绑定了一个输入法后返回的信息
IInputConnectionWrapper
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55488e8efcc9216e906fb817dc93eab2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/165/">«</a>
	<span class="pagination__item pagination__item--current">166/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/167/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>