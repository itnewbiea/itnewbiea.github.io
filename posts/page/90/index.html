<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47744764adf4484ba3fecb66dd82310/" rel="bookmark">
			python批量复制指定txt中的图片到指定文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import os import shutil f = open(r'D:\VOC2007\ImageSets\Main\test.txt', 'r')# 打开保存图片的txt，只有名字，不带jpg lines = f.readlines() root_path = 'D:/VOC2007/JPEGImages' # 待复制图像所在文件夹路径 obj_path = 'E:/dangyuan/mmdetection-2.27.0/data/coco/test2017' # 目标文件夹路径 filelist = os.listdir(root_path) for item in filelist: # 遍历所有图片，找到对应的图片并复制 for line in lines: line = line.replace('\n', '') lineo = str(line) +".jpg" if lineo == item: # 复制图像个数 src = os.path.join(os.path.abspath(root_path), lineo) dst = os.path.join(os.path.abspath(obj_path), item) shutil.copy(src, dst) # 将src复制到dst print('ending...') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26683d14198880bd8aca94917fcf26ec/" rel="bookmark">
			【netron】模型可视化工具netron
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 在实际的项目中，经常会遇到各种网络模型，需要我们快速去了解网络结构。如果单纯的去看模型文件，脑海中很难直观的浮现网络的架构。这时，就可以使用netron可视化工具，可以清晰的看到每一层的输入输出，网络总体的架构，简单好用。
2、使用方式 这里介绍两种使用方式： 1、使用在线版； 2、下载本地版
1）使用在线版 浏览器访问：https://netron.app/
点击 “Open Model” 按钮，选择要可视化的模型文件即可
2）下载本地版 终端进行安装： pip install netron
安装完成后，在脚本中 调用包 import netron
运行程序 netron.start("model.onnx")， 会自动打开浏览器进行可视化 （最后有例子）
3、支持的网络框架 和 模型文件类型 （1）支持的框架及对应的文件
（2）实验式支持，可能不太稳定
我习惯用 pytorch，但是 netron 对 pytorch 的 .pt 和 .pth 文件不是很友好，所以，我都是先转换为 onnx 格式，再进行可视化，下面举例。
另外，netron 可以直接可视化 yolo （DarkNet 框架）的 .cfg文件，很是方便。这篇文章有我可视化出来的 yolov3-spp 网络结构。
4、举例 一般情况下，netron 只展示最初的输入尺寸 和 最后的输出尺寸，中间层的尺寸都是不展示的（如下）。
可以同过 onnx.save(onnx.shape_inference.infer_shapes(onnx.load("model.onnx")), "model.onnx") 进行处理。这样中间的每一层的输入输出就都会推理出 并可视化出来了。 （谁有简便方法，评论区留言）
import torch import torch.nn as nn import netron import onnx from onnx import shape_inference class My_Net(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26683d14198880bd8aca94917fcf26ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55bdec22c93216f84b8b96de31023f77/" rel="bookmark">
			python代码插入断点代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需在需要断点的地方插入：
breakpoint() 即可，运行时到断点处停止运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6458a1b54aaff2e3864de325ec68eb9f/" rel="bookmark">
			elementUI 表格多选框this.$refs.xxx.toggleRowSelection无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在elementUI官方实例中，multipleSelection代表选中的值，toggleRowSelection(row,selection)方法用于原先已选的值传入进行勾选，row传递被勾选行的数据，selected设置是否选中。
需求是每次打开弹窗都会重新获取表格数据，并且要选中对应的数据，但直接使用那个方法并没有效果，因为表格中的数据还没有请求出来。
解决：第一步获取数据后在需要进行勾选操作的外面套一个$nextTick（并没完全实现）
this.$nextTick(() =&gt; { checkedList.forEach((row) =&gt; { this.$refs.multipleTable.toggleRowSelection(row,true); }); }); $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。
但这样任然无法正常显示
解决：这里通过从所有列表tableData中找到需要选中的项来帮助选中，直接使用选中列表来设置会出错
最终代码
this.$nextTick(() =&gt; { checkedLi.forEach((row) =&gt; { this.$refs.multipleTable.toggleRowSelection( this.list.find((item) =&gt; { return row.FIELD_CODE == item.FIELD_CODE; }), true ); }); }); 我的博客主页 ：https://qingmuzhang.gitee.io/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce65559b011ff694898b6ce54b03a469/" rel="bookmark">
			var、let、const三者之间的区别和异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先之间总结一下区别吧
var和let作用都是用作声明变量，const声明一个常量，var的声明是变量提升，能够作用于全局，而let和const作用于局部的var是能够重复声明的而let和const是只能声明一次的var和let的值在声明后是可以改变的，而const声明的常量是只读的不可改变，但对于对象和数据这种引用类型，内存地址不能修改，可以修改里面的值。 1.var
其作用就是声明一个变量，凡是用var声明的变量，都会被提升到该作用域的顶部，也就是作为全局变量。var先调用再声明不会报错但是会显示undefined
console.log(val); //undefined var val =1 当声明在一个函数外部的时候是作为全局变量，在函数内部则作为局部变量，但是 如果在函数内部没有声明,直接定义,也是全局变量。
var a=1; //全局变量 function fn() { var b=2; //局部变量 c=3; //全局变量 } console.log(a); //1 fn(); console.log(c); //3 由于是全局变量 当调用fn函数时存在该变量，不调用fn是无法输出结果的 console.log(b); // 由于是局部变量 b是无定义的 2.let
let是ES6新增的命令，用来声明变量，let声明的变量只在let命令所在的代码块内有效。
// function fn(){ // let a=1 // } // fn(); // console.log(a); // a只作用于函数中 所以输出报错：a is not defined let必须先声明变量再使用否则会报错（也叫暂时性死区）
let b=2 console.log(b); //2 console.log(c); //Cannot access 'c' before initialization let c=3 let不能在相同作用域声明相同变量，但是可以在不同作用域声明相同变量
let d=1 let d=2 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce65559b011ff694898b6ce54b03a469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612b10efe0156ca7c0c5a947ed0c4439/" rel="bookmark">
			带圈数字符号0-100和unicode编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 带圈字符2. 带圈字符背后原理（0-50之后的带圈数字支持）3. unicode字符打印 1. 带圈字符 🄋 （这个是带圈的0，浏览器显示字符和word显示字符会有所差异）
①②③④⑤⑥⑦⑧⑨⑩
⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳
㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚
㉛㉜㉝㉞㉟㊱㊲㊳㊴㊵
㊶㊷㊸㊹㊺㊻㊼㊽㊾㊿
2. 带圈字符背后原理（0-50之后的带圈数字支持） 参考：Unicode Circled Numbers
一开始也是想直接找到0-100的带圈数字，但是感谢百度问答-带圈数字。激发了我这个伪程序员的热情。另，发现word里使用带圈数字复制到网页中，会变成这样○51然后就继续寻找。感谢unicode组织的文档，点击这里
大意就是：
带圈字符0的unicode编码是24EA，带圈字符1-20的unicode编码是2460~2473带圈字符21-35的unicode编码是3251-325F带圈字符36-50的unicode编码是32B1~32BF黑色带圈字符0的unicide编码是24FF黑色带圈字符1-10的unicode编码是2776~277F黑色带圈字符11-20的unicode编码是24EB~24F4 后续对50-100的支持，还是一个提案，而且是5位unicode编码。需要使用\U1F1B0这样的编码，
而目前大部分浏览器和IDE都只支持\u240A这样的字符。因此以图片形式存在的带圈字符是可以的，但是以可编码字符存在的是无法在互联网上传播的（word内置的支持也只在word中有效）
尝试：stackoverflow的回答：How to display 5 digit unicode characters such as a speaker /u1f50a
但是浏览器不支持很多显示，所以即便可以拆解这个字符，也没办法正常显示 3. unicode字符打印 直接用unicode字符打印，把1-100这些数字都给打印出来（🤐 然而带圈数字只有1-20是连续的），后面就是其他字符了。。
start=int('0x2460',16) # 字符串转换成16进制整数 print(start) # 9312 for i in range (100): hex_digit=hex(start) hex2unicode=("\\u"+hex_digit.split('x')[1]).encode().decode('unicode_escape') print(hex2unicode) start+=1 打印出来是这样的
①②③④⑤⑥⑦⑧⑨⑩ ⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳ ⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽ ⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇ ⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑ ⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛ ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥ ⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯ ⒰⒱⒲⒳⒴⒵ⒶⒷⒸⒹ ⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃ 然后我又试探性的往后看了看，还挺好玩的
▌▍▎▏▐░▒▓▔▕ ▖▗▘▙▚▛▜▝▞▟ ■□▢▣▤▥▦▧▨▩ ▪▫▬▭▮▯▰▱▲△ ▴▵▶▷▸▹►▻▼▽ ▾▿◀◁◂◃◄◅◆◇ ◈◉◊○◌◍◎●◐◑ ◒◓◔◕◖◗◘◙◚◛ ◜◝◞◟◠◡◢◣◤◥ ◦◧◨◩◪◫◬◭◮◯ ◰◱◲◳◴◵◶◷◸◹ ◺◻◼◽◾◿☀☁☂☃ ☄★☆☇☈☉☊☋☌☍ ☎☏☐☑☒☓☔☕☖☗ ☘☙☚☛☜☝☞☟☠☡ ☢☣☤☥☦☧☨☩☪☫ ☬☭☮☯☰☱☲☳☴☵ ☶☷☸☹☺☻☼☽☾☿ ♀♁♂♃♄♅♆♇♈♉ ♊♋♌♍♎♏♐♑♒♓ 对于这些unicode字符感兴趣的，可以去看看这里或者这个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612b10efe0156ca7c0c5a947ed0c4439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eadf37af960461fd7cf527b0478e9da/" rel="bookmark">
			07-SpringBoot (七) --- SpringBoot&#43;Vue 实现前后端数据交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 前面刚学完mybatis-plus，我们已经基本掌握了更加方便的数据库操作，那么我们也就该做一个web项目练练手了，按理来说，我们该学习学习thymeleaf，thymeleaf是Spring boot推荐使用的模版引擎。但是，现在更加流行的是 SpringBoot+Vue 形式的前后端分离项目！而前后端分离必然少不了数据交互，那么我们今天就试一试吧！
文章目录 Vue项目的创建项目编写打开Vue项目启动Vue项目之效果展示Vue项目启动失败axios的引入前端页面StudentView后端接口StudentController跨域问题的引入运行项目 element-UI的引入前端页面PageView后端接口的编写 增加登录功能前端页面LoginView后端接口LoginController题外话 Vue项目的创建 首先，我默认你已经安装了node.js以及搭建了vue环境（实在不会的同学百度上面的教程可太多了）
新建文件夹作为项目存放路径，在导航栏直接输入cmd进入doc界面 在doc界面直接输入vue ui，浏览器会自动打开，帮助我们进行图形化界面的创建工作（输入vue ui无反应可以看一下这篇文章） 这就是进入浏览器的效果，下面那个盘符在这里不能选择，你要是想改变项目地址，就按我开头说的在相应的目录打开cmd 点击在此创建新项目后，来到以下界面，把最下行的初始化git仓库我们可以叉掉，当然你选了也没事 我们选择手动创建 按下图选择 这里记得切换一下为vue2.x版本，不然后面axios可能用不了 项目创建完成后直接叉掉就行了，doc界面按两次ctrl+c就可退出 项目编写 打开Vue项目 使用Vscode打开文件夹选择我们的项目路径，打开后就是这个样子
或者使用idea选择我们刚刚创建的vue项目路径然后打开，下图就是打开后的样子
两种方式任意选一种就行,下面提到的前端主要指在Vscode中执行，后端为IDEA中执行
启动Vue项目之效果展示 我们可以在Views下面创建一个StudentView，编写一个表格写一些假数据看看效果
&lt;template&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for="item in students"&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.age}}&lt;/td&gt; &lt;td&gt;{{item.hobby}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; {{msg}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "Student", data(){ return{ msg:"Hello Vue", students:[ { id:"1", name:"tom", age:18, hobby:"篮球" }, { id:"2", name:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eadf37af960461fd7cf527b0478e9da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3f5b449ef9204ce9c8dab45bb84794/" rel="bookmark">
			vue打包时，chunk-vendors.js文件过大怎么优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当 vue 项目打包后，生成的 chunk-vendors.js 文件过大时，可以通过以下几个方式进行优化：
使用 CDN 引入第三方库 将一些体积较大且不经常更新的第三方库（如 Vue、Vuex、Vue Router 等）使用 CDN 引入，这样可以减小 chunk-vendors.js 的体积。
&lt;!-- index.html --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 在 webpack.config.js 中配置 SplitChunksPlugin 插件 将一些重复引用的代码抽离成公共模块，避免代码冗余。
// webpack.config.js module.exports = { optimization: { splitChunks: { chunks: 'all' } } } 按需引入第三方库 使用 babel-plugin-import 将第三方库按需引入，避免将整个库都打包进 chunk-vendors.js 中。
npm install babel-plugin-import -D // babel.config.js plugins: [ ['import', { libraryName: 'vant', libraryDirectory: 'es', style: true }] ] 移除未使用的第三方库 使用工具分析代码，找出未使用的第三方库，并将其移除，从而减小 chunk-vendors.js 的体积。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c3f5b449ef9204ce9c8dab45bb84794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e21399b06852a11450222e8c9a3a710/" rel="bookmark">
			onnxruntime.capi.onnxruntime_pybind11_state.InvalidProtobuf: [ONNXRuntimeError] : 7 : INVALID_PROTOB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加载onnx模型报错：
onnxruntime.capi.onnxruntime_pybind11_state.InvalidProtobuf: [ONNXRuntimeError] : 7 : INVALID_PROTOBUF : Load model from ./insightface_func/models/antelope/glintr100.onnx failed:Protobuf parsing failed.
错误原因：
onnx文件损坏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89258d4fe29ffdb994e54292f88c0071/" rel="bookmark">
			单例模式详细总结（8种实现方式，看完就会）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式 实现单例模式的8种方式： 饿汉式(静态变量) 优点：类装载时完成实例化，避免线程同步
缺点：没有达到Lazy Loading的效果，如果从始至终未使用过这个实例，会造成内存浪费
public class SingletonTest01 { public static void main(String[] args) { // 测试 Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(instance.hashCode()); // 356573597 System.out.println(instance2.hashCode()); // 356573597 } } // 单例模式 // 饿汉式(静态变量) class Singleton { // 1. 构造器私有化 private Singleton() {} // 2. 本类内部创建对象实例 private final static Singleton instance = new Singleton(); // 静态变量 // 3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } jdk源码中的 Runtime 就使用了这种方式实现单例模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89258d4fe29ffdb994e54292f88c0071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca31236791670ff528ba776171589ea1/" rel="bookmark">
			【个人学习】使用torch实现xml文件返回的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人学习使用，若有错误，敬请指正
主要实现 构建数据集类，使用xml的文件信息去提取车牌特征，转换尺寸之后输入神经网络。
因为没有搜索到纯代码实现xml的图片内容，所以自己尝试使用torch框架并实现。
实现代码 导入包和定义文件路径 import os import matplotlib.pyplot as plt from PIL import Image import random import xml.etree.ElementTree as ET import torch import torch.optim as optim from torchvision import transforms, datasets,utils from torch.utils.data import DataLoader, Dataset from skimage import io, transform import glob import torchvision import numpy as np plt.rcParams["font.sans-serif"]=["SimHei"] #设置字体 plt.rcParams["axes.unicode_minus"]=False #该语句解决图像中的缺失中文 # 定义训练集和测试集的路径 trainData_dir = 'Train/images' testData_dir = 'Test/images' # 引入Annotations文件来增强特征提取 trainAnno_dir = 'Train/annotations' testAnno_dir = 'Train/annotations' images= os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca31236791670ff528ba776171589ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ba712a1eea2cf90c9a6145165c9eb6/" rel="bookmark">
			视频生成: 基于Stable Diffusion的微调方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chatGPT带来了几个月的AIGC热度，文本图像生成模型大行其道，但AI在视频生成任务上尚没有较好的开源仓库，并受限于“缺那么几百块A100"的资源问题，大多数人无法展开视频生成的研究。好在目前有不少针对视频生成的相关paper，也有不少开源实现，事实上缺的是一个完整的训练+推理+Pretrained模型，本文要解决的就是这个问题。
1. Stable Diffusion以及其中Unet结构，下图摘自论文: High-Resolution Image Synthesis with Latent Diffusion Models
为了支持视频生成，需要对Unet结构中的部分模块进行改造，包括2d卷积以及Self-Attention和Cross-Attention。在许多的Stable Diffusion开源实现中，Tune A Video这篇论文的代码较为干净简洁，在利用Stable Diffusion V1-4权重作为pretrained，参考Make A Video利用3d伪引入空间信息，并且保留Tune A Video中关于Sparse Cross Attention的修改。
2. 3d伪卷积引入时空相关信息，图片摘自Make A Video
代码实现引用lucidrains的make-a-video-pytorch，并且加入关于时空的Position Embedding部分。
3. Sparse Casual Attention 出于节省运算量的目的，当前帧跟第一帧和当前帧的前一帧做Cross Attention，这个只是运算上的调整，Cross Attention结构并无修改。
4. 3090如何训练
大多数论文，训练视频生成都是采用8张A100做微调，或者利用成百上千的GPU进行大规模训练。对于咱穷人来说，只有两块3090，训练方法分步骤进行:
a. 128x128
b. 256x256，batch size单卡为4，grad accumulation设置为100
5. 数据集
视频数据集webvid, hdvila100m
图片数据集laion400m
我简单实验下来，加上图片数据集混合训练文本生成效果会更好一些。
代码开源于: https://github.com/xuduo35/MakeLongVideo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31db49e91c7cc5bdc11c2c283cbdb617/" rel="bookmark">
			数据库作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为教学数据库中表插入规定的数据。
use teachingdb; insert into student values('11111','马明','计算机','01','女','2000/01/02',null) 将 student 表中所有学生的总学分加2，空值记录也参加计算。
use teachingdb; update student set totalcredit=totalcredit+2.0 将 student 表中马小燕的出生日期修改为’2000-01-22’。
use teachingdb; update student set birthday='2000-01-22' where sname='马小燕' :删除student表中的数据
use teachingdb; delete from student where sno='11111' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a7fcaccc94856e89aab3c4fb693f76/" rel="bookmark">
			Sentinel架构篇 - 流量控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流量控制 用于调整网络包发送的数据。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个适配器，可以根据需要将随机的请求调整成合适的形状，如下：
流量控制有两种统计类型 - 统计线程数、统计 QPS。可以通过如下命令查看实时统计信息：
curl http://localhost:8719/cnode?id=resourceName 输出内容的格式如下：
idx id thread pass blocked success total Rt 1m-pass 1m-block 1m-all exeption 2 abc647 0 46 0 46 46 1 2763 0 2763 0 thread： 代表当前处理该资源的线程数；pass： 代表一秒内到来到的请求；blocked： 代表一秒内被流量控制的请求数量；success： 代表一秒内成功处理完的请求；total： 代表到一秒内到来的请求以及被阻止的请求总和；RT： 代表一秒内该资源的平均响应时间；1m-pass： 代表一分钟内到来的请求；1m-block： 代表一分钟内被阻止的请求；1m-all： 代表一分钟内到来的请求和被阻止的请求的总和；exception： 代表一秒内业务本身异常的总和。 流量规则的定义 实际代码中对应 FlowRule。
同一个资源可以同时有多个流量规则。
Field说明默认值resource资源名称count限流阈值grade流量控制的指标（0 - 线程数、1 - QPS）1 （即 QPS）limitApp流量控制针对的调用来源default（不区分调用来源）strategy资源的调用关系（0 - 直接、1 - 关联、2 - 链路）0（即直接）controlBehavior流量控制的效果（0 - 直接拒绝、1 - 冷启动、2 - 匀速器、3 - 冷启动 + 匀速器）0（即直接拒绝） 流量控制的指标 基于并发线程数 简单统计当前请求上下文的线程个数，如果超过阈值，则新的请求会被拒绝。用于保护业务线程数不被耗尽。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a7fcaccc94856e89aab3c4fb693f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a39c987cb3e63915fb7d410e1d1eca/" rel="bookmark">
			Java中终止线程的3种方法，你是否了解？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、stop 方法终止线程（线程不安全，不推荐） 直接使用thread.stop()来强行终止线程，线程会立即终止执行，可能会产生不可预料的结果。在调用thread.stop()后会导致该线程所持有的所有锁突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。
二、使用退出标志退出线程 public volatile boolean exit=false; public void run() { while (!exit){ //do something } } 通过使用volatile修饰的boolean类型的共享变量，在设置exit等于true时，该运行中的线程会退出while循环，执行完run方法结束
volatile保证了可见性和防止指令重排 三、Interrupt方法结束线程 使用interrupt()方法来中断线程有两种情况：
线程处于阻塞状态：如使用了sleep，wait，await，socket中的receiver，accept等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException异常，通过代码捕获该异常，然后break跳出循环状态，结束这个线程的执行。通常很多人认为只要调用interrupt方法线程就会结束，实际上是错的，一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正常结束run方法。
public void run () { //非阻塞过程中通过判断中断标志来退出 while (!Thread.interrupted()) { try { Thread.sleep(3 * 1000); } catch (InterruptedException e) { //捕获到异常之后，执行 break 跳出循环break; } } } 线程处于非阻塞状态：使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。
Thread.currentThread().isInterrupted()和Thread.interrupted()的区别？ 两者都是判断当前线程是否中断，isInterrupted()不会清除中断标志，interrupted()会清除掉中断标志。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9ba66df6812aa6551b6963551a2c49/" rel="bookmark">
			Nginx 使用中的错误代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		400 Bad Request：请求无效错误，通常是由于请求中包含不正确的语法或参数而导致的。处理方式是检查请求语法和参数，并根据需要进行更正。
401 Unauthorized: 未授权错误，通常是由于请求需要身份验证但未提供有效凭据而导致的。处理方式是提供正确的身份验证凭据，或更改访问权限以允许公共访问。
403 Forbidden: 被禁止访问错误，通常是由于服务器拒绝了请求或请求网址不存在或无权访问而导致的。处理方式是检查请求的 URL 和访问权限，并根据需要更改相应设置。
404 Not Found: 找不到资源错误，通常是由于请求的资源不存在或已被移动而导致的。处理方式是确认请求的 URL 是否正确，并根据需要更改相应设置。
408 Request Timeout: 请求超时错误，通常是由于请求等待时间过长而导致的。处理方式是增加请求等待时间或优化服务器响应速度。
413 Payload Too Large: 请求载荷过大错误，通常是由于请求负载大小超出服务器所允许的限制而导致的。处理方式是增加服务器容量或减少请求负载大小。
414 URI Too Long: URL 过长错误，通常是由于请求的 URL 超出了服务器允许的最大长度而导致的。处理方式是缩短请求的 URL 或增加服务器容量。
415 Unsupported Media Type: 不支持媒体类型错误，通常是由于请求中包含不支持的媒体类型而导致的。处理方式是检查请求中的媒体类型，并根据需要更改相应设置。
500 Internal Server Error: 服务器内部错误，通常是由于服务器无法完成请求或执行操作而导致的。处理方式是检查服务器配置和代码，并根据需要进行修复或更正。
502 Bad Gateway: 错误网关错误，通常是由于代理服务器无法与上游服务器通信而导致的。处理方式是检查代理服务器设置和上游服务器配置，并根据需要进行修复或更正。
503 Service Unavailable: 服务不可用错误，通常是由于服务器暂时无法处理请求或维护而导致的。处理方式是等待服务器恢复或进行临时维护。
504 Gateway Timeout: 网关超时错误，通常是由于代理服务器无法从上游服务器接收响应而导致的。处理方式是检查代理服务器设置和上游服务器配置，并根据需要进行修复或更正。
400 Bad Request: 请求无效错误，通常是由于请求中缺少必要参数或包含无效的参数值而导致的。处理方式是检查请求参数，并根据需要进行更正。
403 Forbidden: 被禁止访问错误，通常是由于服务器拒绝了请求或请求网址不存在或无权访问而导致的。处理方式是检查请求的 URL 和访问权限，并根据需要更改相应设置。
404 Not Found: 找不到资源错误，通常是由于请求的资源不存在或已被移动而导致的。处理方式是确认请求的 URL 是否正确，并根据需要更改相应设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b9ba66df6812aa6551b6963551a2c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aec5cf434682d46be9b22fcfc6e5e38/" rel="bookmark">
			使用RGNN训练和测试EEG公开的SEED数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面所有博客是个人对EEG脑电的探索，项目代码是早期版本不完整，需要完整项目代码和资料请私聊。
主要内容：
1、在EEG(脑电)项目中，使用图神经网络对脑电进行处理，具体包括baseline的GCN图架构、复现baseline论文的RGNN架构、注意力机制图架构、Transformer图架构、注重效率的simple图架构等，进行实验和对比。
2、学习图神经网络相关的资料。是学习图神经网络的一个完整项目；
数据集
1、脑电项目探索和实现(EEG) (上)：研究数据集选取和介绍SEED
相关论文阅读分析：
1、EEG-SEED数据集作者的—基线论文阅读和分析
2、图神经网络EEG论文阅读和分析：《EEG-Based Emotion Recognition Using Regularized Graph Neural Networks》
3、EEG-GNN论文阅读和分析：《EEG Emotion Recognition Using Dynamical Graph Convolutional Neural Networks》
4、论文阅读和分析:Masked Label Prediction: Unified Message Passing Model for Semi-Supervised Classification
5、论文阅读和分析：《DeepGCNs: Can GCNs Go as Deep as CNNs?》
6、论文阅读和分析： “How Attentive are Graph Attention Networks?”
7、论文阅读和分析：Simplifying Graph Convolutional Networks
8、论文阅读和分析：LightGCN: Simplifying and Powering Graph Convolution Network for Recommendation
9、图神经网络汇总和总结
相关实验和代码实现：
1、用于图神经网络的脑电数据处理实现_图神经网络 脑电
2、使用GCN训练和测试EEG的公开SEED数据集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aec5cf434682d46be9b22fcfc6e5e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b879f59f4dd3d54534343400978e7dfd/" rel="bookmark">
			JS 原型与原型链详解 （深度学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 普通对象与函数对象. (万物皆对象) JavaScript 中，分为普通对象和函数对象，Object 、Function 是 JS 自带的函数对象。下面举例说明:
var obj1 = {}; var obj2 = new Object(); var obj3 = new fun1(); function fun1(){}; var fun2 = function(){}; var fun3 = new Function(); console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof obj1); //object console.log(typeof obj2); //object console.log(typeof obj3); //object console.log(typeof fun1); //function console.log(typeof fun2); //function console.log(typeof fun3); //function 在上面的例子中 obj1 obj2 obj3 为普通对象，fun1 fun2 fun3 为函数对象。怎么区分，其实很简单，凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。fun1,fun2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b879f59f4dd3d54534343400978e7dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0368b9079cd320f44db4fd0809e7fd2f/" rel="bookmark">
			将本地项目上传至 gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1：在 gitee 上创建以自己项目名称命名的空项目 2：进入想上传的项目的文件夹，然后右键点击 3：初始化本地环境，把该项目变成可被git管理的仓库 $ git init 4：将本地代码库与远程代码库相关联 $ git remote add origin https://gitee.com/仓库路径 5. Git出现 FETCH_HEAD fatal: refusing to merge unrelated histories解决方法 当执行 git pull origin master 命令时出错
Git Pull Failed From https://gitee.com/stormlong/hero_mall * branch master -&gt; FETCH_HEAD = [up to date] master -&gt; origin/master refusing to merge unrelated histories 解决方法：
pull拉取不下最新的原因是：本地仓库和远程仓库的两个分支是不同的版本，所以拉取不下来，需要解决冲突先
在其代码模块后加上这个参数，强制合并，忽视提交的历史，之后通过代码模块的不同进行合并即可
git pull origin master --allow-unrelated-histories 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e2670ddcb6872d4a4396b81e04d547/" rel="bookmark">
			数据结构——顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇为数据结构系列的第一篇文章，数据结构是一种有效地存储和管理数据的方法，在应对实际问题时的重要性不亚于算法。本系列为我在学习数据结构后对于数据结构的理解，使用的语言为C。这里提几点建议，数据结构最重要的是思想，先有思路再进行代码还原能提高学习效率，在学习时，建议多画图辅助理解，图形能更直观地表达出数据结构。
1 顺序表的基本思路 顺序表，又称线性表，是一种基础的线性数据结构。其基本思路是在一段连续的内存空间上存储数据。
1.1 静态版顺序表 顺序表的基本思路是将数据存储在一段连续的内存空间上，这与C语言数据类型中的数组非常相似，因此我们可以通过数组来实现一个顺序表。
当然，当我们创建一个数组作为顺序表后，需要存储的数据量可能会小于数组的大小，这时数组中就有部分未使用的空间。因此，在顺序表中最好有一个变量来管理顺序表有效空间的大小。如下为一个简单的静态顺序表结构。
struct SeqList { int a[100]; //容量大小为100个整型的顺序表 int size; }; 在这样一个顺序表结构中，结构成员a即顺序表主体，用于存储数据。而变量size则负责管理有效空间，其初始值应该为0，表明初始有效空间为0，即顺序表中的数据量为0。
由于数组大小直接给定，因此这个顺序表的容量已经确定，无法改变，我们把这种无法改变容量的顺序表称为静态顺序表。
下图为静态顺序表的图解（矩形中的数字代表存储在表中的整型数据）。
1.2 动态版顺序表 与静态顺序表相反，动态顺序表的容量大小可以通过动态内存分配来管理。与静态版相比，动态版顺序表使用起来更加灵活，能更好地适应实际情况，提高内存空间的利用率（大部分数据结构基本都使用动态内存管理）。如下为一个简单的动态顺序表结构。
struct SeqList { int* a; int size; int capacity; }; 与静态顺序表相比，动态顺序表结构中的主体a变成了指针类型。其实很好理解，学了数组后我们知道，数组本质上也是通过数组初始位置的指针来管理数组，这里用指针替换主要是方便进行动态内存管理。另外，多出了一个变量capacity，用来管理顺序表的容量，当容量不够大时，可使用realloc函数进行扩容。
下图为动态顺序表的图解。
2 顺序表的实现 2.1 接口 对于比较复杂的项目，我们采用接口，即在一个头文件中包含所有该项目所需要的标识符声明，以便完工后使用，在数据结构中也如此。
在写接口前，我们需要先分析该项目所需具备的功能，并分模块实现。
接下来我们来分析顺序表所需的功能。首先，当我们创建一个顺序表时，需要对顺序表进行初始化，包括为顺序表动态开辟初始空间，设置初始容量，设置初始有效容量为0等。相对的，既然进行了动态内存开辟，那么在空间使用完毕后就要释放空间。其次，就是实现顺序表作为数据结构的基本功能，数据的增删查改。
#pragma once #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; #define SeqListAdd 2 typedef int SLDataType; typedef struct SeqList { SLDataType* a; int size; int capacity; }SeqList; // 对数据的管理:增删查改 void SeqListInit(SeqList* ps); void SeqListDestroy(SeqList* ps); void SeqListPrint(SeqList* ps); void SeqListPushBack(SeqList* ps, SLDataType x); void SeqListPushFront(SeqList* ps, SLDataType x); void SeqListPopFront(SeqList* ps); void SeqListPopBack(SeqList* ps); // 顺序表查找 int SeqListFind(SeqList* ps, SLDataType x); // 顺序表在pos位置插入x void SeqListInsert(SeqList* ps, int pos, SLDataType x); // 顺序表删除pos位置的值 void SeqListErase(SeqList* ps, int pos); 上方为我所用的顺序表接口。其中使用typedef将int重命名为SLDataType是为了后续调用方便。当使用者需要使用该顺序表存储其它数据类型的数据时，仅需将其中的int改为所需类型即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e2670ddcb6872d4a4396b81e04d547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86fe27bfa168233f620cae260c01933/" rel="bookmark">
			WS2812B 驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词：WS2812 ，STM32G030F6
说 明：本代码用于驱动 16 个RGB LED(WS2812 )模块，可以按16个预定颜色的流水显示，
使用RT-Thread RTOS 基于STM32G030F6 最小系统板的 ws2812 驱动工程。
WS2812是一个集控制电路与发光电路于一体的外控LED光源，外形一般为5050封装，每个LED灯珠为一个像素点，支持RGB无极调色，同时每颗灯珠内部集成有数字接口数据锁存信号整形放大驱动电路，还包含有高精度的内部振荡器和可编程定电流控制部分，整个 LED 模组只需要3条线即可驱动，VCC,GND,DATA, LED 模组上的所有LED都串在一条数据线上，所以只需要使用1条IO即可驱动。
驱动效果，彩色渐变循环显示
1.开发板图片 2.开发板与WS2812B 连接图 16位 WS2812 5050 RGB LED 智能全彩RGB灯环开发板
3.附带工程的编译器 RT-Thread Studio 4.驱动代码 /* * Copyright (c) 2006-2020, RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * IO 直接数据输出模式控制 ws2812B * 说明：本代码用于驱动 16 个RGB LED模块，可以按16个预定颜色的流水显示 */ #include "user_cfg.h" #define RGBLED_GPIOX GPIOA /* LED驱动IO */ #define RGBLED_PIN GPIO_PIN_3 /* LED驱动IO */ #define LED_NUM 16 /* LED数量 */ //#define RGBLED GET_PIN(A, 3) /* STM32F103 系列 IO 输出控制，采用直接寄存器操作方法，这样可以做到IO的控制速度最大化 */ /*方式1：（72M主频）BSRR 只写寄存器：既能控制管脚为高电平，也能控制管脚为低电平。对寄存器高 16bit 写1 对应管脚为低电平，对寄存器低16bit写1对应管脚为高电平。写 0 ,无动作*/ //#define LED1(X) X?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e86fe27bfa168233f620cae260c01933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3bf21f8b35573528a2015d15d184941/" rel="bookmark">
			【深度学习】LSTM/CNN&#43;LSTM实现图片分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【深度学习】LSTM/CNN+LSTM实现图片分类 LSTM完整代码实现截图 CNN-LSTM实现代码 毕设实验设计部分：作为对照的单LSTM模型实现模型以及CNN+LSTM模型实现
注意:一般LSTM单模型不会用来实现图片分类，只做教学用途。
LSTM 主要需要注意的是，LSTM单元输入的是(num_timesteps, num_features)
在X = X.reshape(X.shape[0],X.shape[1]*X.shape[2],-1)将图片尺寸转换为可以输入的尺寸
完整代码 import tensorflow as tf import pathlib from tensorflow import keras from tensorflow.keras import layers from tensorflow.keras.models import Sequential import os import numpy as np from sklearn.model_selection import train_test_split from tensorflow.keras.utils import to_categorical import cv2 ''' 使用图片数据作为输入数据集,使用lstm作为网络模型 ''' # 图片文件夹 DATA_PATH = os.path.join() # 自行进行填充 # 定义类别名称 actions = np.array([])# 自行进行填充 no_sequences = 30 # sequence_length = 30 images_path = [] images,labels = [],[] for action in actions: for sequence in range(no_sequences): for frame_num in range(sequence_length): img_path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3bf21f8b35573528a2015d15d184941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2577e44dca04f36ca6bdb458ede4a4b3/" rel="bookmark">
			Linux内核设备驱动设备树概念与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设备树概念以及作用 1.1设备树概念 设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、 IIC 接口上接了哪些设备、 SPI 接口上接了哪些设备等等，如图 所示：
在图中，树的主干就是系统总线， IIC 控制器、 GPIO 控制器、 SPI 控制器等都是接到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02这两个 IIC 设备， IIC2 上只接了 MPU6050 这个设备。 DTS 文件的主要功能就是按照图所示的结构来描述板子上的设备信息， DTS 文件描述设备信息是有相应的语法规则要求的，稍后我们会详细的讲解 DTS 语法规则。
1.2设备树引用以及概念 以LED驱动为例，如果你要更换LED所用的GPIO引脚，需要修改驱动程序源码、重新编译驱动、重新加载驱动。
在内核中，使用同一个芯片的板子，它们所用的外设资源不一样，比如A板用GPIO A，B板用GPIO B。而GPIO的驱动程序既支持GPIO A也支持GPIO B，你需要指定使用哪一个引脚，怎么指定？在c代码中指定。
随着ARM芯片的流行，内核中针对这些ARM板保存有大量的、没有技术含量的文件。
Linus大发雷霆：“this whole ARM thing is a f*cking pain in the ass”。
于是，Linux内核开始引入设备树。设备树并不是重新发明出来的，在Linux内核中其他平台如PowerPC，早就使用设备树来描述硬件了。
Linus发火之后，内核开始全面使用设备树来改造，神人就神人。
/sys/firmware/devicetree目录下是以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2577e44dca04f36ca6bdb458ede4a4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94be91a2d91c27f8f05c96122de8e38/" rel="bookmark">
			如何使用pandas提取含有指定字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 name age state point0 Alice 24 NY 641 Bob 42 CA 922 Charlie 18 CA 70name age state point0 Alice 24 NY 642 Charlie 18 CA 700 False1 True2 TrueName: state, dtype: boolname age state point1 Bob 42 CA 922 Charlie 18 CA 700 True1 False2 TrueName: name, dtype: boolname age state point0 Alice 24 NY 642 Charlie 18 CA 70name age state point0 Alice 24 NY 641 Bob 42 CA 922 NaN 18 CA 700 True1 False2 NaNName: name, dtype: objectprint(df_nan[df_nan['name'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c94be91a2d91c27f8f05c96122de8e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36bbefa94fb8ae69ac721321c5a30393/" rel="bookmark">
			真给科技企业丢脸，在美国亚马逊做普通工人，你会吃不饱肚子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 亚马逊公司（Amazon），成立于1995年，是全球最大的一家科技创新型电子商务公司，是全球电子商务的最老资格。自从2015年底，亚马逊在俄亥俄州哥伦布市运营大型仓库，如今的亚马逊已经成为俄亥俄州最大的雇主之一，将有超过6000名员工和数千名员工即将加入三个大型仓库。可笑的是，与此同时，亚马逊也成为“员工需要领救济金生活”的最大雇主之一。
1.食物补充券的历史
食物补充券始于1939年(Food Stamp)是一项颇有历史渊源的救济手段，是由美国政府通过正式的“补助营养援助计划”(Supplemental Nutrition Association Program) 向低收入人群发放的用于换取食物的凭证。后续中断，1964年，约翰逊总统提请国会通过对食物补充券计划进行永久性立法，自食品补充券计划法实施以来，美国联邦政府一直为穷人提供食品补贴， 至今从未中断。只要是符合低收入标准的美国公民或其他符合条件的人士均可向政府申请。政府规定，申请食物补充券的家庭收入必须不超过所规定的收入上限 ，不得有2000美金以上的存款或者资产。这一标准可以说是美国最低的温饱线了。如果经济情况改善，领取食物补充券的人数就会下降，是一个衡量经济情况的重要指标，也是一项重要扶贫项目（anti-poverty program）。但是补助营养援助计划的数据并不是公开数据，部分美国的州政府并不愿意披露，俄亥俄州州政府是第六个愿意披露的州政府。
2.快速增长掩盖了其对就业的负面贡献
根据美国俄快速增长掩盖了其对就业的负面贡献亥俄州就业与家庭服务部门的数据，截至去年8月，就共有1430名亚马逊员工或家庭成员获得了补充营养补助计划（SNAP）的帮助。平均每个家庭超过2人。8月份之后，又有超过700名亚马逊员工获得了救济金，换句话说，公司雇用的每10名俄亥俄州员工中有超过一位依靠救济生活，虽然兼职人员占多数，但也有部分是全职人员。虽然公司在俄亥俄州运营数据中心，风力发电场和全食超市公司(Whole Foods Market，业务份额见下图)，但用工人数最多的地方还是百货业务下的两个大型仓库。这两个大型仓库归属于2017年6月亚马逊以137亿美元现金收购高端百货商全食超市，这也是亚马逊公司从线上电商开始进攻线下超市产业和庞大的百货业务的开端。这笔大收购之后，受2017全年财报的利好影响，亚马逊股价继续一路上扬，市值已经突破了7000亿美元，现在一个亚马逊的市值已经相当于2.5个沃尔玛。经营的辉煌难以掩饰，底层员工的收入问题，成了亚马逊帝国的最新负面新闻。　亚马逊的快速增长掩盖了其对就业的负面贡献：虽然该公司现在在美国雇用了20万人，但其许多工人收入很低。最近两年，亚马逊的员工前所未有的增长，从2016年至2017年的第三季度，亚马逊将其总员工数量从300,000人增加到541,900人，几乎一倍的增长。2017年下半年，亚马逊在全国范围内召开几十场个招聘会，目标是填补50000个仓库的岗位空缺。
3.许多符合救济金领取资格的人是亚马逊的在职员工
公益组织政策事务研究中心就此事也表明了态度，其总监扎克席勒（Zach Schiller）说的非常悲情：“饥饿的美国人必须依靠救济才能吃饱。“这在富裕的美国听起来好像天方夜谭，但是这是现实。许多符合救济金领取资格的人是亚马逊的在职人员。这一突然引发的问题——亚马逊的员工需要救济金帮助，背后的问题引人深思，为什么这家获得了巨大商业成功的在线购物帝国，向底层员工提供如此微薄的薪水，以致许多员工需要靠救济生活。这一新闻数据发布后，受到美国网民的激烈讨论，沃尔玛也没有幸免，同样也在被指责之列。 也确实没有指责错，沃尔玛在美国三个州都排在榜首，是关于领救济金的员工数量的排行榜。　4.一种新的商业模式——政府补贴式
然而，各州还是在竞争激烈。在过去的一年里，美国各州一直在努力成为下一个亚马逊总部的所在地。去年，新泽西州批准了一项激励计划，如果亚马逊搬到纽沃克市，将提供价值70亿美元的税收减免。费城在过去10年里提供了20亿美元的免税政策，乔治亚州10亿美元，马里兰州则高达85亿美元。不过，尽管州议员们在争夺亚马逊新总部的竞争中继续相互竞争，却让外媒抓住了笑料。嘲笑亚马逊，一方面疯狂获得来自各州的税收优惠，一方面让自己的基层员工在温饱线上挣扎。史上最成功的公司，公司领政府补贴，大批基层员工也在领政府补贴。成为一种新的商业模式——政府补贴式。
图片为新的运营中心
图片为旧的运营中心
在建立物流中心的过程中，从头到尾，亚马逊都尽量最大化其获得的补贴并削弱当地官员们对其发放工资的期望，地方政府当然希望亚马逊帝国能够提高地区居民收入水平，积极给出各类优惠政策。然而，这些政府补贴文件签署后，物流中心建立起来，亚马逊似乎并没有促进当地的整体就业。而且，它提供的工作在现实中并不像之前承诺的那样好。
早在2016年11月，一个美国社区发展公益组织进行了一项研究，分析了超过1300份的工资信息，发现亚马逊的订单履行中心（也可以理解为运营中心）的职位比行业平均工资低9%。当研究人员重点关注了11个主要地区，以解释生活成本的差异时，他们发现亚马逊的工资下降幅度更大:该公司在每个地区支付的工资比同等职位低15%。经济学家使用不同方法进行的2018年1月的研究也得出了类似的结果。部分州对调查做出回应，亚马逊物流中心的全职员工的调查结果也证实了这项研究。起薪从每小时12美元到15美元不等。根据美国劳工统计局的数据，截至2018年1月，从事仓储和仓储工作的普通操作人员的平均时薪为17.53美元（约人民币110.5元）。甚至在除去了那些需要熟练工种的仓库职位之后，例如叉车操作员，支付给该类别中最低收入者，被归类为“劳动者和搬运工人”的人的工资标准，仍然比亚马逊的起薪平均要高，每小时15.12美元（约人民币95元）。
5.那亚马逊如何粉饰自己对就业做出的贡献的呢？
当亚马逊宣布成立新的运营中心，经常鼓吹的事实就是会支付多比地区高30%的平均零售工资。研究员Kasia Tarczysnka揭露了其丑恶嘴脸：“这是错误的等同。“他们喜欢将他们的仓库工作与其他仓库工作进行比较，而不是将其与其他仓库工作进行比较”” “传统上仓库工作比零售工作要多一点。”。看来亚马逊很喜欢跨行业比较工资水平。对此，亚马逊还不服气，努力争辩。声称亚马逊所提供的包装与仓储工作更类似于零售工作。还声称，平均而言，超过90%的物流中心员工是由全职、直接雇佣的员工组成的。一些领救济金的员工可能是兼职员工，这样解释了低收入的合理性。
“美国亚利桑那州三分之一的亚马逊员工需要政府救济金——食物补充券，来养活自己。”这一数据是指责亚马逊系列负面爆料中的最新一出。有媒体爆料，作为著名的政府优惠受益者，亚马逊的基层员工薪酬中位数（median）比行业平均水平低9个百分点，远低于美国的生活水平。数据清楚的显示，作为全球最大的科技创新型电商企业，亚马逊没有做到给员工提供一个基本的温饱生活。日后伴随着生产自动化水平的提升，这一问题只会恶化、很难得到缓解。　6.这么富裕的国家，这么成功的公司。亚马逊产生的社会问题让人匪夷所思。
当然对亚马逊的强烈指责还在后面。有媒体特别提出，亚马逊将在2021年之前垄断美国电子商务，首席执行官杰夫贝佐斯的价值约为112亿美元。反垄断法是科技企业的青天三铡刀，不知道亚马逊创始人贝佐斯将会如何应对。
其实，亚马逊残酷的企业文化早已不是什么秘密，《一网打尽：杰夫贝索斯和亚马逊时代》一书中提到“许多员工都认为，在贝佐斯手下工作并非易事。尽管他拥有招牌式的开怀大笑和乐观的 公众形象，但也会像苹果的前掌门人史蒂夫·乔布斯（Steve Jobs）那样尖酸刻薄，会让和他 同乘电梯的员工感到不安。” 亚马逊的企业文化非常有特色。会议展示时从来不使用 PPT（幻灯片），而是要求员工写长达6页的短文，用散文体来陈述观点” “员工基本上都熟悉他的笑声，这种刺耳的声音能够中断谈话，有时让你连找他谈话的目 的都忘了。有好几位他的同事认为这多少有些故意为之——因为贝佐斯把笑声当成了防御武 器。亚马逊前任首席信息官瑞克·达尔泽尔（Rick Dalzell）说：“你肯定明白，这种笑声可以 让人消除戒心，并让人精疲力竭。他是在惩罚你。”
我们也可以引用传闻中他的口头禅来反问他，“你到底是偷懒还是不称职？”，“我让你负责世界一流的业务，结果事实证明你又让我失望了。”身为一家全球经营的富裕的美国企业，各项坏口碑位居世界强企之列。
2014年在德国柏林举行的第三届国际工会联盟上，亚马逊CEO 杰夫·贝佐斯被选为“全球最差老板”。既然提到一网打尽，不知道贝佐斯的一网打尽包不包括一网打尽贫穷员工、微薄收入、享受政府补贴和提供恶劣工作环境。　
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd54647360ba6650672deff24abbd5ef/" rel="bookmark">
			生产稳定：JVM调优- java进程，JVM频繁GC，导致CPU占用、内存占用过高过高定位和排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java进程，JVM频繁GC，导致CPU占用、内存占用过高过高定位和排查 1、查到耗CPU的线程id，top命令找出最高占用的进程（command为java） top -H ps -mp pid -o THREAD,tid,time 2、使用命令将线程id（tid）转换为十六进制 printf "%x\n" tid 3、通过进程id和线程id查看线程栈内存 jstack pid |grep tid -A 30 4、通过进程id导出堆内存（dump信息） jmap -dump:format=b,file=name.dump pid 5、name.dump文件下载到本地，通过jprofile等工具导入分析 jprofile导入name.dump文件后截图如下：
传送门：
JVM-MySQL-Tomcat-服务调用，调优相关
生产稳定：JVM-MySQL-Tomcat-服务调用，调优相关
学习提高：Idea 使用docker 部署SpringBoot应用并指定JVM参数，jdk8版本
-------------欢迎各位留言交流，如有不正确的地方，请予以指正。【Q:981233589】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898e06f574ae5a2b2275451a4586868c/" rel="bookmark">
			IMX6ULL以太网卡移植与驱动分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、嵌入式以太网硬件基础知识 一般如果说一款SOC支持以太网，那么就是说SOC里集成了MAC芯片。而要想完成网络的通信不仅需要MAC还需要PHY芯片。
MAC与PHY的区别: PHY（物理层）芯片负责将网络数据在物理层面上转换为电子信号或光信号，以便在网络中传输。它处理数据的物理传输，包括电气、光学和无线形式，并且可以处理一些基本的信号调制和解调任务。例如，以太网中的PHY芯片将数字数据转换为模拟信号以进行电气传输，或将数字数据转换为光信号以进行光纤传输。
MAC（媒体访问控制）芯片负责管理数据在网络中的传输和访问。它处理数据的逻辑传输，决定哪个设备可以发送数据、何时发送数据、如何发送数据等。例如，以太网中的MAC芯片负责实现CSMA/CD协议来协调设备之间的传输，防止数据碰撞。
简单的说就是MAC芯片是用于控制数据传输的(它的作用其实与I2C，SPI控制器差不多)，而PHY的作用主要是将数据转化成物理的形式传输出去。
内置MAC与不内置MAC的区别: 内置MAC: ①、内部 MAC 外设会有专用的加速模块，比如专用的 DMA，加速网速数据的处理。
②、网速快，可以支持 10/100/1000M 网速。
③、外接 PHY 可选择性多，成本低。
硬件连接图：
不内置MAC:(如三星平台一般都是不内置的) 它们使用的芯片是MAC+PHY一体的（如：DM9000）
缺点：速度慢，成本高
硬件连接图：
由于我们是IMX6ULL的平台，内部支持了MAC，所以我们现在讨论内置MAC的连接图。
MII(Media Independent Interface) 作用：用于MAC与PHY芯片之间传输数据。
RMII（Reduced Media Independent Interface） 精简的MII(比MII少了9根线)
TX_EN**：**发送使能信号。
**TXD[1:0]****：**发送数据信号线，一共 2 根。
RXD[1:0]：接收数据信号线，一共 2 根。
CRS_DV**：**相当于 MII 接口中的 RX_DV 和 CRS 这两个信号的混合。
REF_CLK**：**参考时钟，由外部时钟源提供， 频率为 50MHz。
现在一般都不使用MII了。（IMX使用的就是RMII）
MDIO(管理数据输入输出接口) 一个简单的两线串行接口，一根 MDIO 数据线，一根 MDC 时钟线。驱动程序可以通过 MDIO 和
MDC 这两根线访问 PHY 芯片的任意一个寄存器。MDIO 接口支持多达 32 个 PHY。同一时刻
内只能对一个 PHY 进行操作，那么如何区分这 32 个 PHY 芯片呢？和 IIC 一样，使用器件地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/898e06f574ae5a2b2275451a4586868c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910d0a3b36805b2f07517e882982ef78/" rel="bookmark">
			深度学习练习1-excel/csv文件数据转成pytorch张量导入代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.1. 需安装库(使用清华源安装速度会提升) pip install openpyxl -i https://pypi.tuna.tsinghua.edu.cn/simple pip install pandas -i https://pypi.tuna.tsinghua.edu.cn/simple pip install tourch torchvision torchaudio -i https://pypi.tuna.tsinghua.edu.cn/simple 2.导入库 import torch from torch.utils.data import Dataset from torch.utils.data import DataLoader import numpy as np import pandas 3.1读取excel方法 class ExcelDataset(Dataset): #excel实现 def __int__(self, filepath="data.xlsx",sheet_name=0): #_int_加载数据；定义属性变量 #传入文件路径；如果有多个sheet，可以加入sheet_name这个参数，默认是0==读的是第一个表单 print(f"reading {filepath},sheet={sheet_name}") #打印日志，显示正在读取的文件和表单 df = pandas.read_excel( #读取excel数据 filepath,header=0,index_col=0, #传入excel文件名，header=0--第0行是标题行，index_col=0--第0列是索引列（如序号等），使其不作为特征使用 names=['feat1','feat2','label'], #以names数组的形式表示要读取三列的数据名称 sheet_name=sheet_name, #读取的表单 dtype={"feat1":np.float32,"feat2":np.float32,"label":np.int32} #names读取后希望转变的数据类型 ) print(f"the shape of dataframe is {df.shape}") #打印日志，显示有多少行多少列 feat = df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/910d0a3b36805b2f07517e882982ef78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f20e4d82e3a2b5b61087caac3d3e54d/" rel="bookmark">
			Vue2&#43;ElementUI存储搜索记录至缓存，搜索框el-input&#43;弹出框el-popover，对历史记录可增删查，聚焦显示历史记录框，回车搜索事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改了需求，记录一下之前的需求代码。
无搜索记录
模糊搜索
代码如下：
HTML
&lt;el-popover placement="bottom" trigger="focus" ref="popover"&gt; &lt;template v-if="showOptions &amp;&amp; showOptions.length"&gt; &lt;div v-for="item in showOptions" :key="item.value" class="option-item" @click="search = item.value"&gt; &lt;div&gt;{{item.value}}&lt;/div&gt; &lt;i class="el-icon-close" @click.stop="deleteItem(item.value)"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;div class="text-grey text-center font-size12"&gt;暂无搜索记录&lt;/div&gt; &lt;/template&gt; &lt;el-input slot="reference" ref="headerSearchSelect" placeholder="请输入应用名称" v-model="search" @keyup.enter.native="handleSearch" @blur="focus = false" @focus="focus = true" clearable prefix-icon="el-icon-search" /&gt; &lt;/el-popover&gt; JS
data(){ return { search:'', focus:false, options:[], timer:null } }, computed:{ showOptions:{ get(){ const filterOptions = this.options.filter(item =&gt; item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f20e4d82e3a2b5b61087caac3d3e54d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6993d1a13a01145bb172e40d6a2f0ad/" rel="bookmark">
			嵌入式Linux-IMX6ULL开发环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式Linux-IMX6ULL开发环境配置 前言平台内容开发环境 虚拟机安装虚拟机下载镜像解压安装alientek虚拟机 编译开发板出厂镜像编译出厂uboot编译出厂内核源码以及设备树uboot烧写与启动 网络挂载出厂镜像虚拟机网络配置开发板网络配置TFTP 加载zImage和设备树如果要加载自己的镜像文件和设备树 NFS 挂载出厂文件系统如果要加载自己的出厂文件系统 前言 正点原子的驱动开发指南所使用的是纯净的Ubuntu16.04平台，用户可以按照驱动开发指南的学习路线，一步一步地亲手把Ubuntu平台搭建完成。
但是学习正点原子Linux开发板，个人还是强烈推荐大家安装正点原子提供的虚拟机平台！！！！
可以快速进行体验或者开发，避免学习周期过长，导致学习没有兴趣，无法建立正反馈。
平台内容 Ubuntu 系统：Ubuntu16.04
GCC 版本：5.4
教程通用交叉编译器：gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf
出厂系统专用交叉编译器：fsl-imx-x11-glibc-x86_64-meta-toolchain-qt5-cortexa7hf-neontoolchain-4.1.15-2.1
QT 环境：开源版本 QT5.12.9、开源版本 QT Creator4.12.2
编辑器软件：Visual Studio Code、vim、gedit
网络工具：TFTP、NFS、Samba
以上软件都是开源版本，仅提供给有需要的用户学习使用，如有需要请自行购买商业版本软件。
开发环境 ​ 软件：VMware Workstation Pro15.5 版本
​ 主机操作系统：WIN10。
​ 虚拟机系统：Ubuntu16.04 版本
虚拟机安装 虚拟机下载 ​ 网盘地址链接提取码：atkq
​ 在网盘里有四个 alientek_Qt.iso.xzp文件，分别以001、002、003、004为后缀，这里要下载这四个文件。
​ 如果链接失效了，可以在正点原子下载中心下载
镜像解压 ​ 因为打包出来的虚拟机太大，百度云限制单个文件最大为4G，因此这里拆成了四个文件上 传到百度云。下载完成后，确保这四个文件都在同一文件夹下，选中这四个文件解压就可以了。下载解压软件7-Zip来进行解压，软件下载地址。将四个压缩文件全部选中右键，使用7-Zip提取到当前位置。
​ 最终得到了一个alientek_Qt.iso镜像文件（大约13G），这个就是我们后面要导入到虚拟机的镜像文件。iso文件可以不用和安装的ubuntu在同一个硬盘分区，也不建议放在移动磁盘或者U盘。
安装alientek虚拟机 ​ 这一步请大家参考正点原子提供的文档手册：I.MX6U虚拟机使用参考手册V1.3
编译开发板出厂镜像 ​ 在alientek进行中包含alientek-alpha和alientek-zzk分别是出厂镜像和教程镜像，需要说明的是，出厂镜像是驱动配置完善的，可以学习Qt和应用。教程镜像是还没怎么添加驱动的，可以用于学习驱动开发，这里以出厂镜像为例哈~
​ 进入到alientek-alpha文件中，请注意：虚拟机自带的Uboot和内核源码版本比较低，如果有需要，请大家更新到最新的版本，前往正点原子下载中心,下载这个-&gt;【正点原子】阿尔法Linux开发板（A盘）-基础资料\01、例程源码\03、正点原子Uboot和Linux出厂源码,下载完成以后直接将文件拖入虚拟机对应文件夹就完成了版本更新
​ 如果有朋友不知道自己是不是最新的版本，请打开正点原子提供的*【正点原子】阿尔法Linux开发板（A盘）-基础资料\10、用户手册\01【正点原子】I.MX6U用户快速体验V2.6.pdf*，第1.2章节有对uboot、内核的历史版本进行说明。
编译出厂uboot ​ 首先去到出厂 uboot 源码路径下，这里以虚拟机自带的为例子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6993d1a13a01145bb172e40d6a2f0ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb65e270ff25195cc56a51d93e8302d/" rel="bookmark">
			【学习记录21】Vue&#43;ElementUI el-upload多文件上传，一次请求上传多个文件！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情回顾说点废话。。。
1、项目当中遇到需要上传多个图片，一次选取多个图片。但是吧el-upload默认只能一个一个传，每次上传成功还的自己去push，一个一个去判断。
2、关键是后台给的接口，要一次性接收一堆，无奈之下只能去网上搜索，大佬们都是给的代码片段无法直接使用。
3、经过各种搬运后实现了效果，闲下来就想着自己写一下我最后在代码中实现方法吧。大家共同学习进步，我也巩固一下知识点！有问题的地方欢迎各位大佬指正！
话不多说直接撸代码！！！
html部分 // :auto-upload="false" 这一句必须加上，阻止默认上传事件 // :http-request="BSuploadFile" 上传到服务器的方法 // :before-upload="beforeUpload" 上传到服务器前校验文件，选择文件的时候不校验，点击“上传到服务器”调用upload()方法的时候执行 // :on-preview="handlePictureCardPreview" 预览图片 // :on-remove="BShandleRemove" 删除图片 // :on-change="changeFileLength" 选择文件后执行 // multiple // :file-list="BSfileList" &lt;el-upload list-type="picture-card" class="upload-demo" action="" ref="upload" :auto-upload="false" :http-request="BSuploadFile" :before-upload="beforeUpload" :on-preview="handlePictureCardPreview" :on-remove="BShandleRemove" :on-change="changeFileLength" multiple :file-list="BSfileList"&gt; &lt;i class="el-icon-plus"&gt;&lt;/i&gt; &lt;div slot="tip" class="el-upload__tip"&gt; 只能上传jpg/png文件，且不超过1Mb &lt;el-button @click="upload" type="success"&gt;上传到服务器&lt;/el-button&gt; &lt;/div&gt; &lt;/el-upload&gt; 喏，没选择文件的时候就是下面的样子
选完文件以后是下面的样子
js部分 // 上传到服务器前的校验 beforeUpload(file) { console.log('上传前：',file) // 打印出来看一下格式，file流有时候在file.raw中 if (file&amp;&amp;file.type) { const isJPG = (file.type === 'image/jpeg' || file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eb65e270ff25195cc56a51d93e8302d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39dad8703afe9936a340ac58e45f1d9/" rel="bookmark">
			Google Chrome 旧版本下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载地址
在度娘中搜索一上午都没找到的东西，分享出来给大家省时间。现在旧版资源越来越少，能下载的就更少，纯净安装exe，就更稀奇了。懂得都懂。。。
下载地址：Google Chrome Older Versions Download (Windows, Linux &amp; Mac)
原文链接：https://blog.csdn.net/piao110liang/article/details/127101169
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6cea4fb4274baa553bf903543ba189/" rel="bookmark">
			写在28岁，回看3年前的自己，庆幸当时入了软件测试这行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么会学习软件测试？ 已经28岁了，算一下快过去3年了，刚毕业那会工作了一年，因为自己当时很迷茫（觉得自己挺废的），所以就没去工作就一直在家，家里固定每个月给点生活费，但还是没钱，但家里给了我一套房子，出门300米左右就是地铁站，自己一个人住，属于没有钱，却又饿不死的状态（就是当个没用的废人）
水费电费，是家人的卡每月自动扣费的，我需要交的仅物业费，但一个月下来还是没钱，有一部分买了游戏，有一部买了网络课程，或看网络小说。
吃饭没什么，毕竟一个人住，饭量又不大，哪怕一顿吃半斤猪肉，我都吃不完，再加上吃点蔬菜水果，实际也吃得不多，菜市场的价格也就那样。我也不去外面前吃，不点外卖，花钱也就很少,在家煮东西吃，顶多就消耗一点点煤气而已。
活着的意义，对于我来说，可能就是等着醒来吧，毕竟自己腿长在自己脚上，理论上想走去哪就去哪。
其实我自己一直感觉自己在等待些什么，可能是自卑或是对外面世界的恐惧，让我没有勇气，一直困在一个房子里，作茧自缚。
但现实跟网络不一样，看着颓废的自己和逐渐老去的父母，我觉得自己不能在堕落下去了。
一直到2020年初，我在网上了解了软件测试这个行业，然后开始了自学之旅，学习了差不多半年的时间。花了一个多月找到了一份8k的工作，有些朋友说25岁能学吗？好找工作吗？个人觉得还是看自己想不想在这个行业扎根，愿不愿意一直学习，提高自己的技术水平，现在我也在学习自动化测试毕竟时代在进步人也也跟着进步不。
软件测试怎么学习？ 相对互联网其他岗位而言，软件测试入门是非常简单的。虽然后期涉及到自动化测试等内容的时候回相对较复杂，但是对于新手而言，入门以及进入这个行业才是第一步。在工作中不断的积累经验以及提升个人能力。那入门阶段我们需要怎么做呢？
1、首先我们可以通过图书或者通过网络公开视频深入了解软件测试的概念以及相关的基础理论知识。这个过程大概一个月内就可以完成，主要是检验自己是否适合能够快速接受理解软件测试相关的知识。
2、有了一定的基础理论知识之后，可以找一个软件自己亲自按照方法检验一下自己学习的效果，从开始写测试计划、测试用例、到自己完成测试、并输出测试报告。在实际动手过程中肯定会遇到各种问题，将这些问题记录下来，可以通过加入社群咨询或者论坛交流的方式解决这些问题。最重要的是发现问题之后，在之后的学习中可以重点去学习相关的内容。一般而言，对于体量比较小的产品需要用1个月左右的时间，而比较复杂的产品则要用2个月，甚至更久。建议从小产品入手比较好。
3、在有了实际的操作经验之后，可以通过招聘网站的招聘要求，对应该公司的产品，再次进行实际测试。（一般情况下，如果去面试的时候能对该公司的产品有一定的了解程度，那面试成功的几率会更大）。
4、有了实战经验，就要开始尝试面试了。软件测试属于技术岗位，所以在面试的时候面试官会问一些关于技术的问题。你可以从网上找一些相关的软件测试面试题，遇到问题迅速查漏补缺，这样再去面试基本就没有任何问题了。
5、以上方法仅仅是介绍通过自学的方式，当然你也可以通过专门的培训机构去学习软件测试知识。课程内容涵盖基础功能测试、接口自动化、Web端自动化、移动自动化、性能测试，通过企业级实战项目，确保你从理论学习到实践，真正掌握中高端的测试技术。这样在学习完成后，你直接可以去面试了。
以上就是为大家介绍的怎样快速学习软件测试？软件测试学习方法！当然建议大家根据自己实际的自学能力来选择相应更加适合自己的方式学习软件测试。
学习路线要顺畅，不然很痛苦 系统知识储备：linux、互联网网络基础、数据库、编程基础。
linux基础：1、linux系统了解和环境熟悉
2、常用的linux命令
3、linux文件属性、权限、用户管理
4、linux环境安装和使用
5、环境变量
互联网网络基础：1、网络架构通讯原理
2、TCP、UDP、HTTP协议
3、session与cookie
数据库：1、mysql、oracle
2、环境搭建与应用
3、sql使用（关联查询、删除修改），存储过程，事务与编程
编程基础：1、java、python
2、开发环境与基本语法，类与对象，面向对象
3、简单的框架
功能测试核心：测试模型，测试流程，用例设计，缺陷管理
自动化测试：web前端开发基础，浏览器调试工具，接口测试工具使用，web自动化测试（selenium），自动化测试框架，自动化测试平台
自动化测试框架：
性能测试：性能需求分析，性能测试工具使用，性能监控分析和调优
安全测试：抓包工具使用，安全漏洞原理，安全漏洞测试方法，漏洞的防范
测试进阶：sell脚本，测试工具的研发，敏捷测试&amp;TestOps，mock，Docker，大数据测试
资源要完整全面 最后基础知识、Linux必备、Shell、互联网程序原理、Mysql数据库、抓包工具专题、接口测试工具、测试进阶-Python编程、Web自动化测试、APP自动化测试、接口自动化测试、测试高级持续集成、测试架构开发测试框架、性能测试、安全测试等配套学习资源【免费】。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ebd419bbbe8cf0fdd81add46667842/" rel="bookmark">
			有用的css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		::before { content: ""; position: absolute; right: calc(100% + 0.3rem); top: 0.32rem; width: 0.8rem; height: 0.05333rem; background: linear-gradient(90deg,hsla(0,0%,100%,0),#fff); }
::after { content: ""; position: absolute; left: calc(100% + 0.3rem); top: 0.32rem; width: 0.8rem; height: 0.05333rem; background: linear-gradient(90deg,#fff,hsla(0,0%,100%,0));
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac637a02c743210eb83f47cc4f3f298/" rel="bookmark">
			Ubuntu18安装搜狗输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装fcitx
sudo apt install fcitx 2.设置系统上与输入法相关的配置
3.安装搜狗输入法
去搜狗官网下载安装包，安装
sudo dpkg -i sogoupinyin_4.2.1.145_amd64.deb 4.检查系统fcitx输入法框架是否识别出搜狗输入法
在输入源出添加汉语
5.重启系统
然后应该好使了，如果无法输入中文，在终端输入以下代码
sudo apt install libgsettings-qt1 或者重启搜狗输入法试试：
sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2 本文参照：https://blog.csdn.net/qq2399431200/article/details/123917194
https://blog.csdn.net/CCCrunner/article/details/127618696
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8519a9306d03cf069b3f06a55f1589f3/" rel="bookmark">
			Java实现PDF在线预览功能(四种方式)！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@RequestMapping("/preview1") public void er(HttpServletResponse response){ File file = new File("G:\\桌面\\Thymeleaf3.0中文翻译文档@www.java1234.com.pdf"); if (file.exists()){ byte[] data = null; try { FileInputStream input = new FileInputStream(file); data = new byte[input.available()]; input.read(data); response.getOutputStream().write(data); input.close(); } catch (Exception e) { System.out.println(e); } }else{ return; } } @ResponseBody @RequestMapping("/preview2") public void findPdf( HttpServletResponse response) throws IOException{ response.setContentType("application/pdf"); FileInputStream in = new FileInputStream(new File("G:\\桌面\\Thymeleaf3.0中文翻译文档@www.java1234.com.pdf")); OutputStream out = response.getOutputStream(); byte[] b = new byte[512]; while ((in.read(b))!=-1) { out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8519a9306d03cf069b3f06a55f1589f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e336619c72d27e46749d43cbe7681b8/" rel="bookmark">
			技术分享：Proxy-Pool代理池搭建IP代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：本章内容仅供参考，不涉及实际使用。
Proxy Pool代理池搭建 前言一、环境准备二、搭建过程1.Redis数据库搭建2.Proxy-Pool代理池搭建 总结 前言 本章内容仅供参考，不涉及实际使用，主要使用Python环境和Redis数据库进行环境搭建，工具网盘存储如下，有问题可以私聊我。
网址：https://wwgn.lanzoul.com/b03w0tvja 密码:am5m
一、环境准备 1、Python3.10/.7
2、Redis5.0.10
3、Proxy-pool2.4.1
二、搭建过程 1.Redis数据库搭建 1、首先确定好环境是否准备好，提前安装好Python3.10.7环境。
2、环境准备好后，首先配置Redis数据库环境，进入到Redis数据库的根目录文件夹，在文件夹中打开cmd窗口，输入命令启动redis服务。
命令：redis-server.exe redis.windows.conf
3、确定能够启动redis服务后，将该窗口关闭，接下来需要将redis服务安装到Windows服务中，新开一个cmd窗口，输入命令将redis安装到Windows服务中，安装完成后，打开运行框输入services.msc打开服务，查看是否成功安装redis服务。
命令：redis-server.exe --service-install redis.windows.conf
4、确定添加成功后，再次通过命令启动redis服务，关闭所有cmd窗口，再打开一个新的cmd窗口，输入命令启动redis服务。(start代表开启，stop代表关闭)
命令：redis-server.exe --service-start
5、接下来测试是否成功开启redis服务，输入命令，如出现下列信息则代表开启成功。
命令：redis-cli.exe -h 127.0.0.1 -p 6379
2.Proxy-Pool代理池搭建 1、首先要安装依赖环境，这里需要注意Python版本问题，由于Proxy-pool代理池是基于Python3.6制作的，所以需要将依赖文件中的版本号进行删除，交给pip进行适应版本下载，打开requirements.txt文件，将后面的版本号连同等于号一起删除，保留如下。
2、修改完毕后，使用PIP安装依赖环境，输入命令。
命令：pip install -r requirements.txt
3、环境依赖安装完毕后，需要将Proxy-pool的配置文件进行修改，打开setting.py文件，修改数据库密码，端口号等信息，根据自己的需求进行修改。
4、配置完毕后启动项目，这里需要启动两个程序，分别是调度程序和代理池的API接口程序。首先启动调度程序，打开cmd输入命令。
命令：python proxyPool.py schedule
5、如图所示开始采集IP地址，等待IP地址采集稳定后，开启API接口程序，新开一个cmd输入命令。
命令：python proxyPool.py server
6、两个程序开启以后，测试API调用是否成功，打开浏览器，输入网址进行查看，发现IP地址每次刷新都会改变，证明API接口调用成功，实验完成。
地址：http://127.0.0.1:5010/get/
7、可使用测试程序测试代理池是否可用，代码如下（引用博客）：
import requests def get_proxy(): #5000：settings中设置的监听端口，不是Redis服务的端口 return requests.get("http://127.0.0.1:5000/get/").json() def delete_proxy(proxy): requests.get("http://127.0.0.1:5000/delete/?proxy={}".format(proxy)) # 主代码 def getHtml(): retry_count = 5 proxy = get_proxy().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e336619c72d27e46749d43cbe7681b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f464ff09e42a5981f9b4ef50d65ef0c/" rel="bookmark">
			大地量子与亚马逊云科技合作，为新能源业务的发展提供更多的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大地量子成立于2017年，致力于打造行业顶尖的时空数据算法体系和计算架构，助力用户实现数据驱动的业务升级。近期，大地量子在新能源功率预测业务中使用了亚马逊云科技，来满足全球天气预报系统对高算力和网络传输的需求。大地量子还使用Amazon SageMaker构建起机器学习运维自动化管理体系，大大提升了管理效率。
联手亚马逊云科技
应对全球天气预报系统超大数据量的挑战
大地量子一直致力于打造行业顶尖的时空数据算法体系和计算架构，基于云原生的全栈时空数据技术自主研发数字地球PaaS平台，率先在业内提供标准化时空数据产品接入服务。例如，在森林砍伐监测、森林碳汇投资和分布式光伏发电等领域，大地量子的产品已经得到用户的认可，大幅降低了空间数据成果使用门槛。然而，在新能源功率预测业务中，大地量子却遇到了挑战。大地量子新能源功率预测服务是为光伏电站和风力场站提供的高精度发电功率预测服务，它是基于端到端的AI气象预报系统与电站SCADA数据，建立的场站级超短期和短期功率预测AI模型，而全球气象预报系统拥有超大的数据量，需要极高的算力和网络基础架构支撑，这对本地数据中心造成了压力。
● 首先，大地量子所使用的公共数据的数据源大多存储在海外，包括存储在亚马逊云科技上，需要传输到本地才能进行模型的推理训练，而超远距离传输速度慢，难以满足大地量子对模型超短期训练的需求。
● 其次，超大数据分析会导致高昂的存储成本和计算成本，而大地量子一直致力于为客户提供“快准易全”的产品，因此更希望通过利用新技术实现自身成本的降低。
● 最后，大地量子在AI模型的训练上，也希望借助更先进的技术来提高运维效率，让人员更专注于业务创新。
因此，在评估了业务需求、成本预算和云服务厂商的能力之后，大地量子选择在气象预报系统的训练与预测、场站级的功率预测两部分业务中使用亚马逊云科技。目前，大地量子的风光功率预测精度已达业内领先，针对未来4小时的超短期预测精度可达到97%。
基于Amazon FSx for Lustre
构建无短板的数据流“木桶”
利用亚马逊云科技的Amazon FSx for Lustre、Amazon Simple Storage Service(Amazon S3)等服务，大地量子快速为其全球天气预报系统构建起高性能计算集群。Amazon FSx for Lustre不仅可以给大地量子PB级数据分析的计算提供支持，而且通过与亚马逊云科技的计算和编排服务原生集成，也为要求最严苛的高性能计算工作负载提供了支持，完全满足大地量子的每4小时和24小时的模型预测更新需求。而且在Amazon S3存储类中存储数据也能实现成本节约，丝毫不会影响性能。
亚马逊云科技全球覆盖，海外数据可以直接在亚马逊云科技上处理，这让数据传输慢的问题迎刃而解，是大地量子数据流处理的最优选择。同时，亚马逊云科技基础设施的构建遵循着计算资源向数据靠拢的原则，从全局来讲效率最优，并且用户使用公开数据场景时，亚马逊云科技还提供了强大的成本优势。
对于大地量子来说，最关键的是打通整个数据流，从数据的传输存储，到读取进入内存，再到计算训练。这整个数据流处理过程就是一个木桶效应，短板决定着这个系统的效率，中间任何一个环节都需要高性能才能实现整个系统的高性能。亚马逊云科技几乎在每个环节都能做到业界领先水平，这让大地量子在大数据处理上可以保持竞争优势。
Amazon SageMaker
帮助大地量子构建完善的MLOps管理体系
在新能源功率预测业务上，每一个场站都有一个模型，甚至是每一个风电厂的一台风机都将是一个模型，而且每个模型还会面临频繁的更新，所以所训练的模型数量众多。因此，大地量子一直期望搭建一套完备的机器学习运维（MLOps）体系，从而减少人员的运维工作量，提升工作效率。
通过测试，大地量子看到Amazon SageMaker可以帮助开发人员快速、轻松地构建和训练机器学习模型，并直接将模型部署到生产就绪的托管环境中。同时，它还提供了一个集成的Jupyter编写Notebook实例，可让使用者轻松访问数据源来探索和分析，不需要管理服务器。
云创计划加持
加速市场拓展进程
亚马逊云科技还提供了针对初创公司的云创计划，旨在为初创公司提供起步云资源和技术服务。这让大地量子可以以更高的性价比使用更先进的技术和产品资源，从而将成本控制在预期的一半左右，同时还可获得近距离的咨询和指导服务，帮助初创企业快速成长。大地量子在第一次使用Amazon SageMaker时，表示自己的理解会出现偏差，完全学习透彻这个产品可能需要两周左右的时间，但通过与亚马逊云科技的解决方案架构师和产品专家团队共同探讨后，只需要花费一天时间，效率大大提升。
更重要的是，在云创计划的加持下，初创企业不仅能够以较低的成本获得对业务运行支撑充足的计算、存储、网络等资源外，亚马逊云科技全球丰富的合作伙伴生态，还可以帮助初创企业快速发掘潜在机遇，加速市场拓展。例如，亚马逊云科技上有众多的能源行业成功实践，积累了大量的能源领域知识和经验。因此，在与大地量子针对新能源领域打造联合解决方案时，亚马逊云科技基于之前帮助新能源企业大幅提升气象研究与预测模型性能的实践，给大地量子提供了不少独到的见解。
目前双方构建的新能源精准功率预测的联合解决方案，已经通过亚马逊云科技的市场平台，在重点客户群体中进行了全面推广，通过测试已获得部分客户认可。未来双方还将继续深度合作，为新能源业务的发展提供更多的最佳实践。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb07877ab2a2d6559bea63c5f8c8dce/" rel="bookmark">
			前言技术之Oauth2全方面介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Oauth2基本概念
1、定义
​
2、场景带入
1、外卖场景
2、互联网场景
3、令牌与密码
二、Oauth2的角色定义
三、Oauth2认证方式
1、Oauth2四种认证方式
2、授权码方式 1、概念： 2、步骤：
3、隐藏式方式 1、概念： 2、步骤： 4、密码式方式 1、概念：
2、步骤： 5、凭证式方式 1、步骤
四、Oauth2与JWT的区别
1、JWT机制
1、定义：
2、JWT的组成部分：
​
3、JWT解决的问题：
​ 4、适用的场景：
5、不适用的场景： 2、Oauth2机制
一、Oauth2基本概念 1、定义 Oauth2是目前最流行的授权机制，用来授权第三方应用，获取用户数据
2、场景带入 1、外卖场景 一户人家住在一个大型居住小区，小区有门禁系统，进入小区需要输入密码，这户人家经常性点外卖，必须让外卖人员进入到小区，如果把密码告诉外卖人员，这样的话，他就和户主拥有了一样的权限，这样安全隐患太大，给了外面人员密码之后，为了安全，必须要进行修改密码，这就很麻烦。
这时候Oauth2就诞生了，外卖人员的职责只是送货，没必要知道小区密码
Oauth2的实现步骤：
1、在门禁系统密码输入器下面，增加一个按钮，叫做“获取授权”，快递员需要首先按这个按钮，去申请授权
2、按下按钮之后，户主的手机就会弹出对话框，有人正在请求授权，系统会显示，该快递员的姓名，工号，和所属的快递公司，户主确认请求属实之后，就点击按钮，告诉门禁系统，户主给与他进入小区的权力
3、门禁系统得到我的确认后吗，向快递员显示一个进去小区的令牌，只在短时间内有效
4、快递员向门禁系统输入令牌，进去小区
2、互联网场景 把以上场景放置到互联网中，就是Oauth2的设计
1、首先，居住小区就是存储用户数据的网络服务，比如微信存储了我的好友信息，获取这些信息，就必须经过微信的"门禁系统"
2、其次，快递员就是第三方应用，想要穿过门禁系统进入小区
3、最后，户主同意第三方应用进入小区，获取户主数据
简单的说，Oauth2就是一种授权机制，数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据，系统从而会产生一个短期的令牌用来代替密码，供第三方应用使用。
3、令牌与密码 令牌和密码的作用是一样的，都可以进入系统，但是有以下三点差异：
1、令牌是短期的，到期就会自动失效，用户自己无法进行修改，但是密码一般长期有效，用户不修改，就不会发生变化
2、令牌可以被所有者立即撤销，会立即失效，但是密码不会
3、令牌有权限范围，比如只能进入小区的几单元就进几单元。
二、Oauth2的角色定义 Oauth2有四种角色，一个是客户端，一个是资源所有者，一个是授权服务器，还有一个是资源服务器
以上述外卖场景为例，
外卖人员-----&gt;客户端
户主-----&gt;资源所有者
保安-----&gt;授权服务器
小区-----&gt;资源服务器
三、Oauth2认证方式 1、Oauth2四种认证方式 注意：
不管是哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后拿到两个身份的识别码，客户端和客户端密钥，这是防止密钥被滥用，没有备案过的第三方的应用，是不会拿到令牌的
2、授权码方式 1、概念： 授权方式：第三方应用先申请一个授权码，然后再用改码获取令牌
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beb07877ab2a2d6559bea63c5f8c8dce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68320e17fbbae126e5d5d6febe734fda/" rel="bookmark">
			程序员最后一款笔记软件：Notion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“芋道源码”，选择“设为星标”
管她前浪，还是后浪？
能浪的浪，才是好浪！
每天 10:33 更新文章，每天掉亿点点头发...
源码精品专栏
原创 | Java 2021 超神之路，很肝~
中文详细注释的开源项目
RPC 框架 Dubbo 源码解析
网络应用框架 Netty 源码解析
消息中间件 RocketMQ 源码解析
数据库中间件 Sharding-JDBC 和 MyCAT 源码解析
作业调度中间件 Elastic-Job 源码解析
分布式事务中间件 TCC-Transaction 源码解析
Eureka 和 Hystrix 源码解析
Java 并发源码
来源：juejin.cn/post/
7039590754754232350
先简单介绍下
使用过的笔记软件
Notion的强大之处
notion的缺点
笔记软件排行榜（野榜~）
市面上笔记软件五花八门，都各有特色。wolai、语雀、飞书、印象笔记、石墨、幕布、为知笔记.....等等，数不胜数，但我最终选择了notion，因为它实在太好用了！！！
如果你之前没使用过，赶紧试试吧，这绝对是一款让你赞不绝口的笔记软件，用了之后只想说: Wow ! 艺术品 ！
先简单介绍下 相当不错的笔记应用，基于block，与wordpress新版编辑器差不多，不过功能更加强大。MarkDown类似Typora那样即时渲染，但功能更为强大！
可用于笔记、记录、收藏、博客发布等等，编辑的内容，可设置为公开，有公开的可浏览的链接；可多人/团队协作。
支持图片、视频、音频等上传，收费版不限容量，个人版是免费的，团队要收费。
支持各个平台，有客户端,有web、Windows、MAC、安卓、IOS等。部署在云端，不用担心备份的问题
支持导出html，markdown，pdf，可以将写好的page转化为link跳转到其他的page。也就是可以实现个人主页或者一个站点
基于 Spring Boot + MyBatis Plus + Vue &amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68320e17fbbae126e5d5d6febe734fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed16a1d9ec8d3d1cc7640a177346a4d3/" rel="bookmark">
			华为模拟器Ensp，virtualbox安装步骤，抓包软件的安装—网络工程师必备软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 virtualbox 安装步骤1. 最新版本的下载 (如果要用到eNSP上就不用安装最新版)2. 点击 Download3. 安装 virtualbox WinPcap 安装步骤1. 打开 [WinPcap](https://www.winpcap.org/default.htm) 官网2. 选择下载版本3. 安装 WinPcap Wireshark1. 点击可执行文件2. Next eNSP1. 点击可执行文件 运行软件出现的问题： 全部的软件分享链接： https://pan.baidu.com/s/1Yq_mVHw994mdCd7NcYO1hw 提取码: b7cj ，下载速度慢可见我另外一篇博文， 看这 注意：所有软件安装路径最好不要作改动，不然会产生一些不必要的麻烦
virtualbox 安装步骤 1. 最新版本的下载 (如果要用到eNSP上就不用安装最新版) 打开链接：http://www.virtualbox.org，进入到官网。
2. 点击 Download 下载最新版的virtualbox，这里就首选前面的Windows版本就行了。
3. 安装 virtualbox 打开我们刚下载好的可执行文件，进入安装向导。
一路下一步。
这里路径可以根据自己的情况进行选择。
点击安装。
点击完成。
好了，virtualbox 最新版就安装完成了。
**注意：**旧版也是一样的操作，这里安装路径最好不要作改动。
WinPcap 安装步骤 1. 打开 WinPcap 官网 点击 download。
2. 选择下载版本 下载即可。
3. 安装 WinPcap 一路下一步。
点击finish。
WinPcap 就安装完成了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed16a1d9ec8d3d1cc7640a177346a4d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd7de1893aac1c21bc7684b167ec03c1/" rel="bookmark">
			制作精良讲解清晰的Lumen原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【老奇】阴差阳错 撼动世界的游戏引擎_哔哩哔哩_bilibili
推荐一个制作精良讲解清晰的Lumen原理视频给大家。这种有营养但又很可口的技术科普视频，来之不易啊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3545236a25de6ab50b761f5aec8631b8/" rel="bookmark">
			看不懂，为什么跑出租车的大战送外卖的，没关系，主要是你不理解大数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		郭德纲老师有一个段子：
内行要是和外行去辩论那就是外行。比如我和火箭科学家说，你那火箭不行，燃料不好，我认为得烧柴，最好是煤，煤还得选精煤，水洗煤不好。如果那科学家要是拿正眼看我一眼，那他就输了。
第一回合：美团赢
众所周知，滴滴和美团最近在局部市场发生了阵地战。美团打车进网约车市场可谓高调。
结果，滴滴接招了，就中招了。
滴滴看了美团一眼。所以第一局，滴滴就输了。只要网上一直在热炒滴美大战，那么美团的赢面就将继续扩大。不过，这只是声势上。
那怎么才算滴滴赢呢，情景如下：
路人在吆喝，有人要攻打滴滴了。
问：谁呀？
答：是谁我倒给忘了。
做一个简单的推断。
已知条件一：
根据2018年3月官网数据显示，作为一站式综合出行平台，滴滴联接了超2100万司机和车主、4.5亿乘客、汽车租赁公司、汽车经销商等生态圈，每天完成超2500万订单。
已知条件二：
根据美团官方公布的数据，在美团打车登陆上海的第二天（3月22日），日完成订单量超25万单。
推论：250000/25000000X100%=1%
打下一个百分之一的市场，全网舆论哗然。又一个传播界的经典案例诞生了。
恭喜这届美团公关！
第二回合 杀敌一万，自损八千
焦灼中，第二个回合开始了。
美团喜报频传，原理上一回合说的很清楚了。
但是我们要分析一下由来。
前几日，媒体老师们的优质文章已经从资金、补贴、司机零抽成等方面介绍的很透彻了。
《靠高补贴和零抽佣，“新司机”美团能撬动网约车市场吗？》 腾讯深网
《美团出战，滴滴出牌》全天候科技
《北京“黄牛”等待美团打车：先注册先吃肉》新京报
乘客端App下载量比对
1%的市场无疑是资金烧出来的。只有当价格战结束，深层次的技术问题才会暴露出来。
既然，美团铁了心要吃出行这块蛋糕。背后强大的资本肯定是点头同意的，大批粮草弹药备足，那我们就从需要从数据科学的角度来分析。
由此引出本文真正的标题：
释放大数据的力量，起底滴滴出行与美团打车在城市交通场景下竞争背后的关键密码
有人可能要问了，一个团购+外卖+酒店+旅游+民宿+电影+到店综合+生鲜的公司为啥要做出行的生意？其他战场还不够忙活的嘛？
对，你说的对，你长得那么美，说什么都对。
我们换个问法？
美团配送调度算法和滴滴出行派单算法本质上是一样的吗？
出租车预订应用程序在全世界都很受欢迎，为用户提供了快速响应时间等方便。关键是出租车预订应用程序的调度系统，其目的是提供乘客和司机之间的最佳匹配
虽然不是同一个算法问题，但是应用场景比较类似，美团在这方面确实是有积累的。
说到底，关键是调度系统，旨在提供A和B之间的最佳匹配。算法解决的是调度问题，也是平衡的问题。
调度系统，派单体系、潮汐管理滴滴有，美团也有。
那么问题又来了。算法哪家强？
先介绍一下滴滴老爷大数据的杀手锏。
大数据预测的关键是有足够多的高质量的数据。大数据日日夜夜、毫不停息的被迅速生产出来，算法和计算平台都被要求越来越快的速度。算法世界犹如一个浩瀚迷人的星空、没有边际，但是我们的视线范围却在不断延伸。算法不能够通用，即使结合风霜雪雨就能幻化出不同的算法，每个具体问题就需要一个特有的算法，必须要结合业务场景找到最合适的算法。
敲黑板划重点拉，请拿笔记录。
算法是无限规模
算法是千变万化
算法是精度优先
这时候数据科学家们，闪亮登场。
滴滴研究院副院长叶杰平介绍，当前滴滴在交通领域的数据量全球第一，每日峰值订单超过2000万单、每日处理数据超过2000TB，覆盖了交通路况、用户叫车信息、司机驾驶行为、车辆数据等多维度，它所掌握的巨大的真实数据除了预测路况，还能进行预测供需，预测的越准，越能解决供需不平衡的问题。
来自滴滴的特有数据：
播单半径
每小时的收入IPH
每小时的订单TPH
空驶率
在滴滴出行的业务场景下，四大特色：
特色一：路径规划
路径规划这项地图技术是实现智能派单的关键。通过海量历史数据，可以对未来路况做预测，实现A点到B点的路径规划，围绕最低的价格、最高的司机效率和最佳交通系统运行效率来做算法。
特色二：机器学习成功应用到预计到达时间（ETA）
指预估任意起终点所需的行驶时间，对时间要求精准性，是解决“订单匹配”和“司机运力调度”的关键技术。当前滴滴ETA可以预测每一单出行的时长以及预估在每一个路口前的等待时长。这项技术支持在更合适的时间对运力进行更好的调度。
特色三：派单-类似于动态打靶
叫车和搜索的逻辑有所不同，从网购的商品到看新闻的网页等都是静态的，也就是挖掘静态信息，而滴滴的算法类似于解决动态打靶问题，在运动的车辆中，给乘客一个最优的选择，不只是距离上的最优，也是时间上的最优。派单对订单量和司机数量进行预测，最后大规模分布式计算来实现撮合。
这时，最优派单需要供需预测、动态调价、路径规划、服务分的算法技术共同发挥作用，最终服务于实现最优派单，在动态环境中最“聪明”的撮合乘客与司机的交易。据悉，目前高峰期滴滴平台每分钟接收超过30000条乘客需求，每2秒钟作1次订单匹配，每1次发单背后，运算次数达到百亿次级别。
特色四：取消判责的算法模型
取消了订单是谁的责任？该算法模型能在取消订单时，综合考虑发单时间、预估接驾时间、车辆实时位置、路况、取消行为等多个维度，实时、自动判定司乘双方的取消责任。
有了该模型，再也不怕取消订单，被无辜扣款了。
美团配送的业务场景下，智能调度技术走上台前。
美团配送团队在机器学习、运筹优化、仿真技术等方面具有优势，还拥有即时配送智能调度系统。
1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3545236a25de6ab50b761f5aec8631b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f193cb240aa84b3d7703bddcbf02839e/" rel="bookmark">
			无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称；无法加载文件 D:\nodejs\node_global\vue.ps1，因为在此系统上禁止运行脚本。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、一开始安装使用并vue create 创建项目时候正常，然而过了一段时间，使用vue create创建项目时候报错显示：无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称
解决方法如下：
运行npm config get prefix显示一段路径地址，把这段路径地址复制在环境变量里的系统变量名为Path的地方编辑新建一个并把复制的地址粘贴上去，关闭创建项目的软件并重新vue create创建项目即可 2、按照以上步骤添加了系统变量后显示：无法加载文件 D:\nodejs\node_global\vue.ps1，因为在此系统上禁止运行脚本
这是因为PowerShell的执行政策阻止了该操作，需要解除受限状态。
解决方法如下：
1. 在Windows系统搜索PowerShell，以管理员身份运行
2. 在命令框输入：set-ExecutionPolicy RemoteSigned， 然后输入A
以上步骤都完成后再重启编辑器执行vue create xxx等命令即可正常完成。 （搞了半天查了半天各种帖子踩的坑分享给大家）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133463cc934067fc9c356a2d2e076629/" rel="bookmark">
			Raspberry(树莓派)安装MQTT服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mosquitto是比较常用的MQTT服务器，它本身也是开源的。这篇文章以mosquitto为例，说明如何在安装了Raspberry的树莓派上安装mosquitto
1. 安装依赖openssl 可以通过命令执行：
sudo apt-get install libssl-dev 如果不安装openssl直接去编译mosquitto，会有下面的错：
fatal error：openssl/opensslconf.h：No such file or directory 2. 安装依赖cjson 这个就通过源码安装吧，去https://github.com/DaveGamble/cJSON下载包导入树莓派中，然后在文件夹中：
make make install 如果不安装cJson直接去编译mosquitto，会有下面的错：
mosquitto_ctrl.h:21:10: fatal error: cjson/cJSON.h: No such file or directory 3. 安装mosquitto 首先执行如下命令(否则mosquitto的make会报错)：
sudo apt-get install xsltproc docbook-xsl docbook-xml 去这个网站http://mosquitto.org/files/source/下载mosquitto的源码并导入树莓派，进入指定文件夹下执行如下命令：
cd mosquitto-2.0.9 make sudo make install 4. 验证是否安装成功 执行命令：
mosquitto -v 出现下面这样的就算是成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91074a4f9bd6aa19822ed033d526ce15/" rel="bookmark">
			Java实现Base64编码以及原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java实现 使用java.util.Base64类来实现Base64编码。
该类是Java8引入的。
String str = "sd"; System.out.println("str:" + str); // 进行Base64编码 byte[] bytes = str.getBytes("utf-8"); String encode = Base64.getEncoder().encodeToString(bytes); System.out.println("encode:" + encode); // 进行Base64解码 byte[] bytes1 = Base64.getDecoder().decode(encode); String decode = new String(bytes1, "utf-8"); System.out.println("decode:" + decode); 输出： str:sd encode:c2Q= decode:sd 上面就是java实现的代码，使用起来是很方便的。下面来说说Base64编码的原理。
Base64编码 Base64编码的作用：将字符串转为由64个特定字符组成的编码，这种编码方式适用于不支持特定编码的情况。
详解 一、 首先来看，原字符串是“sd”。将字符串转为二进制编码形式。这里是采用utf-8。
s的编码：115。二进制展示是：01110011。
d的编码：100。二进制展示是：01100100。
上面的二进制是8个字节的，由于要转换为64个字符展示的字符串，所以需要以6个字节作为一个单位来展示。
我们将两个编码合并起来：0111001101100100
二、 由于现在是16个字节（8+8），如果以6个字节为单位的话，字节数量是不够的。
因此在后面补0：011100110110010000
三、 然后以6个字节为单位分割该编码：011100，110110，010000
再转换为十进制表示：28，54，16
四、 根据下面表格，找到索引对应的字符，得到Base64编码的结果：c2Q
--图片来源base64百度百科
五、 通常，编码结果不满4个字符时，会在后面补上=
因此编码的最终结果是：c2Q=
既然编码方式知道了，那么解码方式也就知道了。这里就不详细再说了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005999f1262241b2286a8ec2ddb5f105/" rel="bookmark">
			进程调度算法的模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加深对进程概念的理解，明确进程和程序的区别
先写一个名为“schedule.c”的文件
内容如下
#include "stdio.h" #include &lt;stdlib.h&gt; #define getpch(type) (type*)malloc(sizeof(type)) struct pcb { /* 定义进程控制块PCB */ char name[10]; //进程名 char state; //进程状态："W"-就绪态，"R"-运行态 int nice; //进程优先级 int ntime; //需要运行时间 int rtime; //已经运行的时间 struct pcb* link; }*ready=NULL,*p; typedef struct pcb PCB; char sort() /* 建立对进程进行优先级排列函数，优先数大者优先*/ { PCB *first, *second; int insert=0; if((ready==NULL)||((p-&gt;nice)&gt;(ready-&gt;nice)))/*优先级最大者,插入队首*/ { p-&gt;link=ready; ready=p; } else /* 进程比较优先级,插入适当的位置中*/ { first=ready; second=first-&gt;link; while(second!=NULL) { if((p-&gt;nice)&gt;(second-&gt;nice)) /*若插入进程比当前进程优先数大,*/ { /*插入到当前进程前面*/ p-&gt;link=second; first-&gt;link=p; second=NULL; insert=1; } else /* 插入进程优先数最低,则插入到队尾*/ { first=first-&gt;link; second=second-&gt;link; } } if(insert==0) first-&gt;link=p; } } char input() /* 建立进程控制块函数*/ { int i,num; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/005999f1262241b2286a8ec2ddb5f105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33eb9d5cb74904d64b19e69a8f9dc01c/" rel="bookmark">
			11.图-有向图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、有向图。 二、拓扑排序。
（1）检测有向图中是否有环。
（2）基于深度优先的顶点排序（拓扑排序）。
（3）拓扑排序。
三、加权有向图。
（1）加权有向边。 （2）加权有向图。
四、最短路径-Dijstra算法。 一、有向图。 package 图的入门.有向图; import 线性表.线性表_队列.Queue; public class Digraph { //顶点数目 private final int V; //边的数目 private int E; //邻接表 private Queue&lt;Integer&gt;[] adj; public Digraph(int V){ //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) { adj[i] = new Queue&lt;&gt;(); } } //获取顶点数目 public int V(){ return V; } //获取边的数目 public int E(){ return E; } //向有向图中添加一条边v-》w public void addEdge(int v,int w){ //只需要让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终顶点v的邻接表中存储的相邻顶点的含义是：v-》其他顶点 adj[v].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33eb9d5cb74904d64b19e69a8f9dc01c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a435eb09890967e20e6571a940cb0641/" rel="bookmark">
			计算机图形学 | 探秘造型技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机图形学 | 探秘造型技术 计算机图形学 | 计算机图形学 | 探秘造型技术5.1 初识造型技术什么是造型技术？图形的构成实体的定义 5.2 样条的魔力样条的概念插值与逼近样条连续性条件样条描述方法实例：Bezier样条曲线和曲面 5.3 规则形体边界表示（BoundaryRepresentation，B-reps）多边形表面模型扫描表示 构造实体几何法（Constructive Solid Geometry）什么是构造实体几何法？CSG树光线投射算法 空间分割表示（Space-Partitioning）空间位置枚举表示八叉树BSP树 5.4 遇见非规则自然的奥秘——分形几何什么是分形几何？分数维造型方法形状语法（shape grammars）分数维造型程序思想：递归 聚沙成塔——粒子系统什么是粒子系统？粒子系统实例 华中科技大学《计算机图形学》课程
MOOC地址：计算机图形学（HUST）
计算机图形学 | 计算机图形学 | 探秘造型技术 5.1 初识造型技术 什么是造型技术？ 造型技术：研究如何在计算机中建立恰当的模型表示不同图形对象的技术。
对象分为两类：
规则对象是指能用欧氏几何进行描述的形体，如点、直线、曲线、平面、曲面或实体等。规则对象的造型又称为几何造型。在几何造型中，所描述的形体都是规则物体，统称为几何模型。不规则对象是指不能用欧氏几何加以描述的对象，如山、水、树、草、云、烟等自然界丰富多彩的对象。在不规则对象的造型系统中，大多采用过程式模拟，即用一个简单的模型以及少量的易于调节的参数来表示一类对象。 图形的构成 基本图形元素按照：体－面－环－边－顶点的层次记录信息。
顶点：0维度几何元素。边：一维几何元素。对正则形体，边是两邻面的交集，对非正则形体，边有可能是多个邻面的交集。边的形状可以是直线，也可以是曲线。环：二维几何元素。有序、有向边（直线段或曲线段）组成的面的封闭边界。外环边通常按逆时针方向排序，内环边通常按顺时针方向排序。面：二维几何元素。可以无内环，但必须有且只有一个外环。面有方向性，一般用其外法线方向作为该面的正向。面的形状可以是平面，也可以是曲面。体：三维几何元素。由封闭表面围成的空间，其边界是有限面的并集。 实体的定义 几何造型：
通过对点、线、面、体等几何元素经平秱、放缩、旋转等几何变换和并、交、差等集合运算，产生实际的或想象的物体模型。
实体的性质：
刚性：必须具有一定的形状；维数的一致性：三维空间中，一个物体的各部分均应是三维的；占据有限的空间：体积有限；边界的确定性：根据物体的边界能区别出物体的内部及外部；封闭性：经过一系列刚体运动及仸意序列的集合运算之后，仍然是有效的物体。 实体的定义：
三维空间中的物体是一个内部连通的三维点集。形象地说，是由其内部的点集及紧紧包着这些点的表皮组成的。
物体表面的性质：
连通性：位于物体表面上的仸意两个点都可用实体表面上的一条路径连接起来；有界性：物体表面可将空间分为互不连通的两部分，其中一部分是有界的；非自相交性：物体的表面不能自相交；可定向性：表面的两侧可明确定义出属于物体的内侧或外侧；闭合性：物体表面的闭合性是由表面上多边形网格各元素的拓扑关系决定的。 实体定义的方法：正则形体+二维流形
正则形体：
从点集拓扑的角度给出定义。
一个开集的闭包指的是该开集不其所有边界点的集合的并集，其本身是一个闭集。组成一个三维物体的点的集合可以分为内部点和边界点两部分。由内部点构成的点集的闭包就是正则集。三维空间中的正则集就是正则形体，也就是上述的三维有效物体。
可以形式化定义内点为点集中的这样一些点，它们具有完全包含于该点集的充分小的领域。而边界点就是指那些b不具备此性质的点集中的点。
定义点集的正则运算r运算为：r · A = c · i · A。
二维流形：
所谓二维流形指的是对于实体表面上的任意一点，都可以找到一个围绕着它的任意小的领域，该领域不平面上的一个圆盘是拓扑等价的。
实体的完整定义：
对于一个占据有限空间的正则形体，如果其表面是二维流形，则该正则形体为实体。该定义条件是可检测的，因此可由计算机来衡量一个形体是否为实体。
欧拉公式对平面多面体的检查
欧拉公式证明简单多面体的顶点数V、边数E和面数F满足如下关系：V-E+F=2。
简单多面体：指的是那些经过连续的几何形变可以变换为一个球的多面体，即不球拓扑等价的那些多面体。
非简单多面体：不满足简单多面体条件的多面体。
此时，V-E+F≠2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a435eb09890967e20e6571a940cb0641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b491b017bdd40f76dd793a3ed5582f72/" rel="bookmark">
			Linux——让程序在后台运行（四种方法&#43;使用推荐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、第一种方法（加“&amp;”符号）
二、第二种方法（nohup命令） 三、第三种方法（screen命令） 四、第四种方法（systemctl命令） 五、总结
六、实用操作（重点）
一、第一种方法（加“&amp;”符号） 如果想让程序在后台运行，执行程序的时候，命令的最后面加“&amp;”符号。
# 执行文件 ./test.py &amp; # 查看是否在后台运行 ps -ef|grep test # 后台的程序 需要关闭时，需要kill命令停止 killall [程序名] 注意：这种方法，查看运行日志很不方便（不推荐） 二、第二种方法（nohup命令） # 不推荐使用 nohup python -u test.py &gt; test.log 2&gt;&amp;1 &amp; 参数说明：
test.py: 你需要后台运行的程序
&gt;: 日志文件追加到文件中
test.log: 运行的日志，或你的文件的输出内容
&amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。
1&gt;&amp;2 意思是把标准输出重定向到标准错误.
2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。
&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中
# 不推荐使用 nohup python run.py &amp; # 1、原因：在run.py的目录默认直接生成了nohup.out文件 # 2、原因：有些系统无法执行 # 权限不足时 加sudo nohup sudo python -u test.py &gt; test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b491b017bdd40f76dd793a3ed5582f72/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/89/">«</a>
	<span class="pagination__item pagination__item--current">90/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/91/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>