<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04edb979134de56f9c35c8d2d5227afe/" rel="bookmark">
			JS —— Object概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Object 是 JavaScript 的一种数据类型。它用于存储各种键值集合和更复杂的实体。可以通过 Object() 构造函数或者使用对象字面量的方式创建对象。
在 JavaScript 中，几乎所有的对象都是 Object 的实例；一个典型的对象从 Object.prototype 继承属性（包括方法），尽管这些属性可能被覆盖（或者说重写）。唯一不从 Object.prototype 继承的对象是那些 null 原型对象，或者是从其他 null 原型对象继承而来的对象。
通过原型链，所有对象都能观察到 Object.prototype 对象的改变，除非这些改变所涉及的属性和方法沿着原型链被进一步重写。尽管有潜在的危险，但这为覆盖或扩展对象的行为提供了一个非常强大的机制。为了使其更加安全，Object.prototype 是核心 JavaScript 语言中唯一具有不可变原型的对象——Object.prototype 的原型始终为 null 且不可更改。
在代码开发中，应该避免调用任何 Object.prototype 方法，特别是那些不打算多态化的方法（即只有其初始行为是合理的，且无法被任何继承的对象以合理的方式重写）。
一. 创建对象 // 1.使用字面量创建对象 const obj1 = { } // 空对象 {} // 2.使用Object()构造函数创建对象 const obj2 = new Object(); // 空对象 {} const obj3 = new Object(undefined); // 空对象 {} const obj4 = new Object(null); // 空对象 {} 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04edb979134de56f9c35c8d2d5227afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbd56017ba6878adcabdba03e74cfe6/" rel="bookmark">
			C# INI配置文件的读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、INI文件 initialization file的缩写，即初始化文件，通常存放的是一个程序的初始化信息，是Windows的系统配置文件所采用的存储格式，统管windows的各项配置。ini文件的后缀名不一定是.ini，也可以是.cfg、.conf、或者是.tx*。
二、ini文件格式 ini文件由若干个 节（section）组成，每个section由若干 键（key）组成，每个 key 可以赋相应的值。读写ini文件实际上就是读写某个 section 中相应的 key 的值，而这只要借助几个函数即可完成。
三、语法规范 参数(Parameter)：最基本元素，包含参数名（name）和参数值（value），
节(section)：所有的参数以节为单位结合在一起。
注释(comments)：用分号；表示，放在注释
之前，；号后直到行尾均为注释。示例如下： [section]
name=value
age=18
;student info
四、C#解析INI文件 c#通过调用系统api接口进行简单读写ini配置文件，从ini文件中获取文件目录，拉起QQ：
用到的ini配置文件内容如下：
调用系统API接口进行读写：
using System; using System.Collections.Generic; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; namespace StartApp { internal class IniConfigHelper { private const int VALUE_MAX_LEN = 1024; //值最大长度 /// &lt;summary&gt; /// 写配置到ini文件 /// &lt;/summary&gt; /// &lt;param name="appName"&gt;节点名&lt;/param&gt; /// &lt;param name="keyName"&gt;要写入的key&lt;/param&gt; /// &lt;param name="value"&gt;要写入的值&lt;/param&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fbd56017ba6878adcabdba03e74cfe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b56ae229d738d4229ffe4eed47ea8d9/" rel="bookmark">
			VS2019&#43;PCL配置（Windows-小白上手版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、文件下载 PCL点云库下载地址： Releases · PointCloudLibrary/pcl · GitHubhttps://github.com/PointCloudLibrary/pcl/releases
下载时需要注意：下载版本必须与你的VS保持一致，我是VS2019，因此选择PCL 1.12.1https://github.com/PointCloudLibrary/pcl/releases/tag/pcl-1.12.1
需要下载的文件有两个:
https://github.com/PointCloudLibrary/pcl/releases/download/pcl-1.12.1/PCL-1.12.1-AllInOne-msvc2019-win64.exehttps://github.com/PointCloudLibrary/pcl/releases/download/pcl-1.12.1/PCL-1.12.1-AllInOne-msvc2019-win64.exehttps://github.com/PointCloudLibrary/pcl/releases/download/pcl-1.12.1/pcl-1.12.1-pdb-msvc2019-win64.ziphttps://github.com/PointCloudLibrary/pcl/releases/download/pcl-1.12.1/pcl-1.12.1-pdb-msvc2019-win64.zip
二、环境配置 以管理员身份运行PCL-1.12.1-AllInOne-msvc2019-win64.exe，部分步骤如下： 安装完成
安装过程中可能会显示：
把pcl-1.12.1-pdb-msvc2019-win64中的文件复制到PCL 1.12.1\bin 检查环境变量 三、VS2019配置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a357b770a0ef1503b8d25949265cfd/" rel="bookmark">
			Go语言关于协程何时退出的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动一个新的协程时，协程的调用会立即返回。与函数不同，程序控制不会去等待 Go 协程执行完毕。在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。在程序启动时，Go程序就会为main()函数创建一个默认的goroutine当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束。因为main函数结束相当于程序结束但是对于除main函数外的普通函数，如果在普通函数里启用了协程，那么该函数退出后协程并不会退出 总结 来源:go中父协程与子协程的生命周期
当父协程是main协程时，父协程退出，父协程下的所有子协程也会跟着退出；当父协程不是main协程时，父协程退出，父协程下的所有子协程并不会跟着退出（子协程直到自己的所有逻辑执行完或者是main协程结束才结束）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e159d5cd6c5d2eae96efe3b4db02c82/" rel="bookmark">
			现在公司都在用的CI/CD框架到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，CI/CD到底是什么？
二，为什么要用CI/CD？
三，CI/CD的优缺点？
四，CI/CD都基于什么服务搭建？
五，CI/CD是否适用于所有类型的软件开发？
一，CI/CD到底是什么？ CICD 是指持续集成与持续交付（Continuous Integration and Continuous Delivery），它是一种软件开发流程和方法论，旨在实现快速、高质量和可靠的软件交付。
持续集成（Continuous Integration，CI）是指通过自动化将开发人员的代码变更频繁地集成到共享代码仓库中，并进行自动化构建、测试和静态代码分析等过程。每次代码变更都会触发构建和测试流程，以确保代码的质量和稳定性。这有助于发现和解决集成问题、减少代码冲突，并促进团队成员之间的协作。
持续交付（Continuous Delivery，CD）是在持续集成的基础上，通过自动化流程将经过测试的代码部署到生产环境中。这意味着开发团队可以频繁地将软件交付给用户或者部署到生产环境，而不需要手动的、耗时的部署过程。持续交付的目标是将软件交付的过程变得可重复、可靠，并减少交付的风险。
CICD 的核心思想是通过自动化和持续反馈来加速软件交付的速度和质量。它涉及使用各种工具和技术来自动化构建、测试、部署和监控软件的过程。这样可以减少人工错误、加快交付速度，同时提高软件的可靠性、可维护性和可扩展性。
CICD 在现代软件开发中被广泛采用，它有助于团队更快地交付新功能、修复问题和响应用户需求，并提供更好的软件质量和用户体验。通过持续集成和持续交付，开发团队可以更加灵活、高效地进行软件开发和交付，从而提升整个开发流程的效率和质量。
二，为什么要用CI/CD？ 使用持续集成和持续交付（CI/CD）的目的是为了实现以下几个重要的好处：
1. 快速交付：CI/CD 自动化流程可以使软件交付过程更快、更频繁，减少了手动操作和人工干预的时间。这样可以更快地将新功能、修复和改进的代码交付给用户，满足市场需求并保持竞争优势。
2. 提高质量：持续集成通过频繁地集成和构建代码，并进行自动化测试和静态代码分析，有助于发现和解决问题。通过尽早发现和修复缺陷，可以提高软件的质量和稳定性。
3. 自动化部署：持续交付将部署过程自动化，从而减少了手动部署的错误和风险。通过自动化部署流程，可以确保软件在不同环境中的一致性，并减少了部署时间和工作量。
4. 可靠性和可重复性：CI/CD 强调自动化和标准化的流程，使软件交付过程变得可靠和可重复。每次构建、测试和部署都是基于相同的流程和环境，减少了人为因素的影响，提高了软件交付的一致性和可靠性。
5. 团队协作与反馈：CI/CD 促进了团队成员之间的协作和沟通。通过频繁地集成和交付，团队成员可以及时了解彼此的工作进展和变更，减少代码冲突和集成问题，并能够更好地合作解决出现的问题。
6. 可追溯性和回滚能力：由于 CI/CD 自动化流程的记录和版本控制，可以轻松追踪每个构建和部署的结果。这样，在出现问题时可以快速定位和回滚到之前的可用版本，减少了故障修复时间和影响范围。
总而言之，CI/CD 提供了一种高效、可靠和可持续的软件交付方法。它可以加速软件开发和交付的速度，提高软件质量和可靠性，并促进团队之间的协作和反馈。通过使用 CI/CD，组织可以更好地适应市场需求，降低软件交付的风险，并实现持续创新和改进。
三，CI/CD的优缺点？ CI/CD（持续集成与持续交付）在软件开发中具有许多优点，但也存在一些潜在的挑战和限制。以下是 CI/CD 的主要优点和缺点：
优点：
1. 快速交付：CI/CD 自动化流程可以加快软件交付的速度，使开发团队能够更快地将新功能、修复和改进的代码交付给用户。
2. 高质量和稳定性：通过持续集成的自动化构建、测试和静态代码分析，可以提前发现和解决问题，从而提高代码的质量和稳定性。
3. 自动化部署：CI/CD 可以自动化软件的部署过程，减少了手动部署的错误和风险，提高了部署的一致性和可靠性。
4. 团队协作和沟通：CI/CD 强调团队成员之间的协作和沟通，通过频繁地集成和交付，团队成员可以及时了解彼此的工作进展和变更，提高团队的协同能力。
5. 可追溯性和回滚能力：CI/CD 记录和版本控制每个构建和部署的结果，使得在出现问题时可以快速定位和回滚到之前的可用版本。
缺点和挑战：
1. 配置和维护成本：实施 CI/CD 需要配置和维护相应的自动化工具和流程，这可能涉及一定的学习曲线和资源投入。
2. 学习和文化变革：CI/CD 需要团队成员适应持续集成和持续交付的理念和工作方式，可能需要进行培训和文化变革，以适应新的开发流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e159d5cd6c5d2eae96efe3b4db02c82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e3b621f79b8df7e1cd09f6d9118a70/" rel="bookmark">
			【游戏引擎架构】6.2 资源管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源管理器可以分为离线部分系统和运行时系统
文章目录 离线资源管理数据库资产管道 运行时资源管理文件结构内存管理文件间引用 离线资源管理 数据库 UE的数据库可以直接浏览、编辑资产，看到运行时的状态；但也存在两个较大的缺点：
版本管理不友好。资产以二进制的大文件存储，无法直接使用版本管理工具比对差异。虽然引擎本身对P4做了diff蓝图的支持，但蓝图以外的内容或者不使用p4进行版本管理的团队还是无法对资产作差移动文件有残留。移动文件时会在原来的位置留下一个重定向文件。虽然这种设计可以使得引用链上游的资产不需要更改指向，但会导致冗余数据的留存。对此UE也设计了删除这个中间文件的按钮（位于右键菜单中），不过目前UE4应该还需要手动清理 资产管道 用于将第三方工具创建出来的资产导入引擎使用
资产管道的处理通常分为导出、编译和链接：
导出
从第三方工具导出成磁盘上存储的内容编译
经过编译的步骤转化为目标引擎可以识别的格式链接
把资产之间的引用关系链接起来 运行时资源管理 文件结构 可以已有的或自定义文件结构存储。但在进行文件结构设计时，进行打包和压缩有助于加速资源 的加载
打包：
建议打包是因为这种存储方式可以加快文件的读取
文件读取的耗时大头可分为三个部分： 寻道时间开启文件的时间读取文件的时间
将n个资源打包成1个 可以减少上述步骤2：开启文件的耗时
可以参考UE将多个资源文件打成一个pak的方式 压缩：
压缩资源文件可以加快资源的传输，由于蓝光光盘/DVD等存储媒介数据传输极慢，压缩的加载提升尤为明显 内存管理 需要考虑如何进行内存管理可以最大化内存利用率、减少内存碎片
内存的分配策略可分为以下几种：
堆分配：最简单粗暴的方式，引擎层完全不考虑内存碎片的存在。依赖操作系统的虚拟分页对内存碎片的映射来解决。但这种方式不适用于虚拟分页做得不太好的主机平台堆栈分配：不会产生内存碎片的分配方式。使用单个或者双栈来进行内存的分配
单栈：内存单向增长，以关卡为单位分配、入栈和出栈。适合以关卡为单位进行的游戏
双栈：分为上下两个栈，上面的栈内存自上而下增长，下面的栈内存自下而上增长。双栈的设计可用于不同的分工，如一个栈存放常驻内存的资源，另一个存放临时资源。或者一个用于当前正在展示的内容，另一个用于即将使用的内容，实现一个缓冲策略等等池分配：设定一个固定的块大小，作为内存分配的基本单位。使用链表串联一个资源的各个块。优点是灵活性和适用度较高；缺点是为了填充成完整块，容易造成资源浪费资源组分配：基于池分配器做了一点改进，解决池分配的缺点。
使用一个链表将所有填充的部分串联起来，需要使用内存的时候从这里查找。但资源组分配的缺点是需要复杂度较高，而且需要考虑生命周期的问题：原资源释放的时候会造成使用其填充内存的资源被部分释放。书中提到了一个解决方案是保证原资源的生命周期&gt;=填充资源的生命周期。比如，一个关卡内部的资源就可以使用这个关卡的填充内存。资源文件分段分配：将资源文件根据生命周期或者使用场景划分为不同的段，分给不同的时机加载。
比如UE4在游戏启动的时候只加载pak文件的头部路径信息，而不真正将所有资源加载到内存。（UE5拆得更彻底，直接将描述信息拆成一个单独的文件.utoc和真正存储资产内容的.uasset）使用到的时候才读取资源部分 文件间引用 存取得时候需要处理引用关系尤其是指针的存取。因为指针实际上只是一个内存地址，程序终止以后这个地址就没有意义了。
但我们需要把内容存储到磁盘上，因此不能直接存此时指针的内容而是需要做一个转换。
转换的方式可以是转为存储GUID或者偏移量
存储GUID
Global Unique Identifier 全局唯一标识符，每个资源管理系统都应该设计的资源唯一标识存储偏移量
如果存储的是偏移量，需要另外存储一个指针转换表来进行映射 此外还需要考虑C++的对象引用。对于此书中提出两个解决方案：1. 二进制文件不使用C++对象 2. 使用一个表来映射C++对象的偏移量和其所属的类
最后由于存在文件之间的交叉引用，读取的时候，先将所有的引用内容全部反序列化回内存，再将所有的指针转回内存地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3202423d2155b1d3aa7c8d2728798be/" rel="bookmark">
			Go语言字符串与其他数据类型的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串与其他数据类型的转换 整数 与 字符串
// 字符串与其他类型的转换 // str 转 int newStr1 := "1" intValue, _ := strconv.Atoi(newStr1) fmt.Printf("%T,%d\n", intValue, intValue) // int,1 // int 转 str intValue2 := 1 strValue := strconv.Itoa(intValue2) fmt.Printf("%T, %s\n", strValue, strValue) Golang 进阶：strconv – 字符串和基本数据类型之间转换
字符串转为整型
关于将字符串转为整型的问题上，strconv 包中提供了三种方法： func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (n uint64, err error) func Atoi(s string) (i int, err error) 我们最常用的应该就是 Atoi() 了，而这个函数时 ParseInt 的一个简易版。在 Atoi 函数的内部，我们可以看到:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3202423d2155b1d3aa7c8d2728798be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/503088649403c97e4f85e7a2df6ea361/" rel="bookmark">
			【算法与数据结构】JavaScript实现十大排序算法（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 关于排序算法快速排序堆排序计数排序桶排序基数排序 关于排序算法 稳定排序： 在排序过程中具有相同键值的元素，在排序之后仍然保持相对的原始顺序。意思就是说，现在有两个元素a和b，a排在b的前面，且a==b，排序之后a仍然在b的前面，这就是稳定排序。
非稳定排序： 在排序过程中具有相同键值的元素，在排序之后可能会改变它们的相对顺序。意思是说，现在有两个元素a和b，在原始序列中a排在b前面，排序之后a可能会出现在b后面，它们的相对位置可能会发生变化。
原地排序： 在排序过程中不需要申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。这意味着在原地排序中，排序操作会直接修改原始数据，而不需要创建新的数据结构来存储排序后的结果。
非原地排序： 在排序过程中需要申请额外的存储空间来存储临时数据或排序结果，而不直接在原始数据上进行修改。
快速排序 基本思路： 通过选取一个基准元素，将数组分为两个子数组，其中一个子数组的元素都小于基准元素，另一个子数组的元素都大于基准元素。然后对这两个子数组分别进行递归排序，最终将它们合并起来，就得到了有序数组。
操作步骤：
选择一个基准元素（通常是数组中的第一个元素），定义两个空数组（左数组和右数组）；遍历数组，将小于基准元素的元素放到左边的数组，将大于基准元素的元素放到右边的数组；对左数组和右数组分别进行递归排序；将左数组、基准元素、右数组合并起来，得到有序数组。 例题：
对 a=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48] 进行从小到大排序。
&lt;script&gt; function QuickSort(arr) { if (arr.length &lt;= 1) return arr // 选择第一个元素作为基准元素 const pivot = arr[0]; let left = [], right = [] // 将数组中比基准元素小的元素放到 left 数组，比基准元素大的元素放到 right 数组 for (let i = 1; i &lt; arr.length; i++) { arr[i] &lt; pivot ? left.push(arr[i]) : right.push(arr[i]) } // 递归地对左右两个数组进行快速排序，然后将结果合并在一起，基准元素在中间 return QuickSort(left).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/503088649403c97e4f85e7a2df6ea361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cae4ccdf6443a602efcaca6a2eef183/" rel="bookmark">
			01_docker镜像管理：80分钟一口气学完docker&#43;k8s！带你掌握docker&#43;k8s所有核心知识点，全程干货，无废话！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker镜像的实际使用学习 开发过程中，需要安装很多三方工具，比如etcd、kafka、mysql、nginx等等
1、下载安装Docker工具。
2、获取该软件的Docker镜像（基本上，都能搜索到核实的镜像），下载镜像nginx镜像，docker、pull nginx。
3、运行该镜像，启动一个容器，这个nginx服务就运行在容器中。
4、停止容器，删除该镜像，你的电脑，好像就没有使用nginx一样。
基于镜像的增删改查维护： 1、获取镜像
1、获取镜像，镜像托管仓库，好比yum源一样 默认的Docker仓库是：Dockerhub,有大量的优质镜像，以及用户自己上传的镜像CentOS容器 Docker search 镜像名：tag tag就是具体的标签版本 Dokcer search CentOS 注：1、查看docker是否启动，若有Client和Server就是启动的。
[root@Hadoop2 ~]# docker version Client: Docker Engine - Community Version: 24.0.6 API version: 1.41 (downgraded from 1.43) Go version: go1.20.7 Git commit: ed223bc Built: Mon Sep 4 12:35:25 2023 OS/Arch: linux/amd64 Context: default Server: Docker Engine - Community Engine: Version: 20.10.6 API version: 1.41 (minimum version 1.12) Go version: go1.13.15 Git commit: 8728dd2 Built: Fri Apr 9 22:43:57 2021 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cae4ccdf6443a602efcaca6a2eef183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff294ff8bc7749222c71eec9e3db8ec/" rel="bookmark">
			数据结构与算法之动态规划算法(DP)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.0-1背包问题1.1 基本概念1.2 具体问题1.3 c代码求解1.4 测试 2.最长公共子序列 前言 前边我们讲过分治法，分治法的核心是将一个问题分解为n个小问题，最后合并结果。而动态规划算法的核心是穷举法,以及要寻找到一个状态方程，需要用一个DP表或者函数来记录穷举的结果，从穷举过程中选择最优的值，最后得到原始问题的解。
1.0-1背包问题 1.1 基本概念 完全背包问题是背包问题的一种变种，与 0-1 背包问题不同的是，每个物品可以无限次选择放入背包，即可重复使用。动态规划是解决完全背包问题的常用方法。
1.2 具体问题 有n个物品，每个物品的价值为Vi,重量为Wi,背包的容量为C，现在需要将n个物品放入背包，总重量不能超过背包的容量，使得装入的物品的价值达到最大。
求解的问题：放入背包的价值最大
约 束 条 件：重量之和不能超过背包的容量。
实际例子： 假设物品的个数为5个，背包的容量为20，物品的价值和重量如下：
物品编号12345价值v45101215重量w347912 简单的例子我们可以穷举下：
1.20=4+7+9 此时的价值为: 5+10+12=27
2.19=7+12 此时的价值为：10+15 =25
…等等
1.3 c代码求解 /** * 0-1 背包问题 * @param n 物品的个数 * @param c 背包的容量 * @param w 物品的重量数组 * @param v 物品的价值数组 * @return dp表 */ int ** KnapsackDp(int n,int c,int *w,int *v,int ** path){ int i,tempc; //定义一个二维的数组dp表 int ** dp = (int **)malloc(sizeof (int*)*(n+1)); for(int i=0;i&lt;=n;i++){ dp[i]= (int *)malloc(sizeof (int )*(c+1)); } //由于下标是从0开始初始化第一行 for(tempc = 0;tempc &lt;= c ;tempc ++){ dp[0][tempc]=0; path[0][tempc]=0; } for(i = 1;i &lt;= n ;i ++){ dp[i][0]=0; path[i][0]=0; //开始动态 for(tempc = 1 ; tempc &lt;= c ; tempc++){ path[i][tempc]=0; if( w[i-1] &lt;= tempc){ //背包的剩余重量大于物品重量 if(v[i-1]+dp[i-1][tempc-w[i-1]] &gt; dp[i-1][tempc]){ //放入背包 dp[i][tempc]=v[i-1]+dp[i-1][tempc-w[i-1]]; path[i][tempc]=1; }else{ dp[i][tempc]=dp[i-1][tempc]; } }else{ dp[i][tempc]=dp[i-1][tempc]; } } } return dp; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ff294ff8bc7749222c71eec9e3db8ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b55d6f2d4b8b55bb2f76809d821ad23/" rel="bookmark">
			开了VPN但是无法访问外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows11系统
1.记得打开自动检测设置
2.将其设置为系统代理
最近遇到的一些其他网络问题：
在代理中，需要把手动设置代理调整为关闭，如果打开了手动代理，会无法打开http://10.253.0.23/，即校园网登录网络
同时，WIFI也会连接成功但无法使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97ae4ed4682cc26d5b997d02d8e71ebc/" rel="bookmark">
			什么是Apollo自动驾驶平台？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apollo项目介绍 阿波罗（Apollo）是百度发布的面向汽车行业及自动驾驶领域的合作伙伴提供的软件平台。发布时间是2017年4月19日，旨在向汽车行业及自动驾驶领域的合作伙伴提供一个开放、完整、安全的软件平台，帮助他们结合车辆和硬件系统，快速搭建一套属于自己的完整的自动驾驶系统。而将这个计划命名为“Apollo”计划，就是借用了阿波罗登月计划的含义。
可以在这里感受一下Apollo的实车驾车体验：CES 2018 百度Apollo 2.0无人车美国桑尼维尔试乘。
SAE Level 对于自动驾驶，SAE（Society of Automotive Engineers，美国汽车工程师学会） International于2014年发布了从全手动系统到全自动系统六个不同级别的分类系统，这6个级别的描述如下：
SAE LevelNameSystem capabilityDriver involvement 阿波罗项目的官网地址如下：http://apollo.auto
在阿波罗项目的官网，介绍了该项目有如下特点：
开放能力：Apollo(阿波罗)是一个开放的、完整的、安全的平台，将帮助汽车行业及自动驾驶领域的合作伙伴结合车辆和硬件系统，快速搭建一套属于自己的自动驾驶系统。共享资源、加速创新：Apollo开放平台，为你提供技术领先、覆盖广、高自动化的高精地图服务；全球唯一开放，拥有海量数据的仿真引擎；全球开放数据量第一，基于深度学习自动驾驶算法End-to-End。持续共赢：Apollo开放平台，你可以更快地研发、测试和部署自动驾驶车辆。参与者越多，积累的行驶数据就越多。与封闭的系统相比，Apollo能以更快的速度成熟，让每个参与者得到更多的受益，同时Apollo平台也将在你的参与之下变得更好！ 目前，其官网上列出的合作伙伴已经接近100家。
阿波罗项目的蓝图如下：
2017-07：封闭场地的自动驾驶能力2017-12：在城市简单路况下的自动驾驶能力2020-12：高速公路和普通城市道路上的全自动驾驶 最新发布的Apollo 2.5版本主要目标是L2级自动驾驶。
详细的Apollo版本演进信息如下图所示：
源码 可以在这里获取到阿波罗项目的源码：https://github.com/ApolloAuto。这个路径中包含了5个开源项目：
apollo：Apollo自动驾驶平台的源码。apollo-platform：Apollo项目基于Robot Operating System (ROS)，这里是相关代码。目前发布的源码基于ROS Indigo。apollo-DuerOS：Apollo-DuerOS是一套与Apollo相关的远程信息处理产品，这其中包含了几个开源产品。关于DuerOS，请看这里：DuerOS。apollo-kernel：Apollo项目的Linux内核。http://ApolloAuto.github.io：Apollo相关文档，可以访通过https://apolloauto.github.io访问这些文档。 编译和运行 关于如何编译和运行阿波罗项目请参见这里：https://apolloauto.github.io。
执行该任务需要Ubuntu和Docker环境。
编译完成之后，可以在电脑上通过该项目提供的Dreamview功能来熟悉环境，Dreamview通过浏览器访问，其界面看起来是这个样子：
关于Dreamview的更多说明，请参见这里： Dreamview Usage Table 开发 阿布罗平台的开发包含下面几个步骤：
了解离线模拟引擎Dreamviewer和ApolloAuto核心软件模块 了解算法如何在汽车上运作不需要使用真正的汽车或硬件，就立即开始开发 核心模块集成 Location模块Perception模块：（支持第三方解决方案，如基于Mobileye ES4芯片的摄像头，用于L2开发）处理来自Lidar的点云数据，并根据请求返回分段对象信息。Planning模块：计算微调路径，为路径服务的路径段提供汽车动态控制信息。Routine模块：通过Navigator接口查找路径段的本地实现。 高清地图。L4级别的自动驾驶需要高清地图。由于自动驾驶汽车需要在系统中重建3D世界，因此参考对象坐标在重新定位地图和现实世界中的自动驾驶方面发挥着重要作用。基于云的在线仿真驱动场景引擎和数据中心。 作为百度的合作伙伴，将被授予Docker证书来提交新图像并重播你在云上开发的算法。创建和管理复杂的场景以模拟真实世界的驾驶体验 Apollo与ROS ROS全称是Robot Operating System。它包含了一套开源的软件库和工具，专门用来构建机器人应用。其官网地址在这里：http://www.ros.org。
在一个ROS系统中，包含了一系列的独立节点（nodes）。这些节点之间，通过发布/订阅的消息模型进行通信。例如，某个传感器的驱动可以实现为一个节点，然后以发布消息的形式对外发送传感器数据。这些数据可以被多个其他节点接收，例如：过滤器，日志系统等等。
ROS系统中的节点可能位于不同的主机上，例如：在一个Arduino设备上发布消息，一台笔记本电脑订阅这些消息，一个Android手机也监测这些消息。
ROS系统中包含了一个主（Master）节点。主节点使得其他节点可以查询彼此以进行通讯。所有节点都需要在主节点上进行注册，然后就可以与其他节点通讯了。如下图所示：
熟悉Android系统的人可能很容易发现，这和Binder中的ServiceManager的作用是类似的。 节点之间通过发布和订阅主题（Topics）进行通讯。例如，在某个机器人系统中，位于机器人上有一个相机模块可以获取图像数据。另外在机器人上有一个图像处理模块需要获取图像数据，与此同时还有另外一个位于个人PC上的模块也需要这些图像数据。那么，相机模块可以发布/image_data这个主题供其他两个模块来订阅。其结构如下图所示：
Apollo项目基于ROS，但是对其进行了改造，主要包括下面三个方面：
通信性能优化去中心化网络拓扑数据兼容性扩展 通信性能优化 自动驾驶车辆中包含了大量的传感器，这些传感器可能以非常高频的速度产生数据，所以整个系统对于数据传输效率要求很高。在ROS系统中，从数据的发布到订阅节点之间需要进行数据的拷贝。在数据量很大的情况下，很显然这会影响数据的传输效率。所以Apollo项目对于ROS第一个改造就是将通过共享内存来减少数据拷贝，以提升通信性能。如下图所示：
去中心化网络拓扑 前文我们提到，ROS系统中包含了一个通信的主节点，所有其他节点都要借助于这个节点来进行通信。所以，很显然的，假如这个节点发生了通信故障，就会影响整个系统的通信。并且，整个结构还缺乏异常恢复机制。
所以Apollo项目对于ROS的第二个改造就是去除这种中心化的网络结构。Apollo使用RTPS（Real-Time Publish-Subscribe）服务发现协议实现完全的P2P网络拓扑。整个通信过程包含下面四个步骤：
关于RTPS详见这里： Real-Time Publish-Subscribe 数据兼容性扩展 Apollo项目对于ROS最后一个较大的改进就是对于数据格式的调整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97ae4ed4682cc26d5b997d02d8e71ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83dccf500c19a7fddd8019acf76fec10/" rel="bookmark">
			插件化基础（一）——加载插件的类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录：
插件化基础（一）——加载插件的类
插件化基础（二）——加载插件资源
插件化基础（三）——启动插件组件
一、插件化概述 1.1 了解插件化 插件化技术最初源于免安装运行 apk 的想法，免安装的 apk 我们称之为插件，支持插件的 app 我们称之为宿主。宿主可以在运行时加载和运行插件，这样便可以将 app 中一些不常用的功能模块做成插件，既减小了安装包的体积，又实现了 app 功能的动态扩展。
插件化解决的问题：
app 的功能模块越来越多，体积越来越大模块之间的耦合度高，协同开发沟通成本越来越大方法数目可能超过 65535，app 占用的内存过大应用之间的互相调用 插件化与组件化的区别：
组件化开发就是将一个 app 分成多个模块，每个模块都是一个组件，开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件统一合并成一个 apk，这就是组件化开发插件化开发和组件化略有不同，插件化开发是将整个 app 拆分成多个模块，这些模块包括一个宿主和多个插件，每个模块都是一个 apk，最终打包的时候宿主 apk 和插件 apk 分开打包 各个插件化框架对比：
插件化成本高，几乎每个源码版本都要适配。
同时，我们需要清楚，反射是插件化的基础，大量使用反射会影响性能，主要是因为：
产生大量的临时对象过程中会进行可见性检查会生成没有优化过的字节码类型转换（基本类型的装箱拆箱） 1.2 插件化的实现思路 想要实现插件化需要解决以下三个问题：
如何加载插件的类？如何加载插件的资源？如何启动插件的四大组件？ 文章也是围绕这三个问题展开的，总体大纲如下：
本篇文章先来看如何加载插件中的类，其实就是各种方式折腾 ClassLoader。
本系列文章所涉及的源码和运行环境默认为 Android 8.0（API 26），部分章节会涉及到对 8.0 以上系统的兼容适配，这部分会特别指出，没特殊说明的就默认为 8.0。
二、Android 的类加载机制 2.1 类的生命周期 先来看类的生命周期：
在加载阶段，虚拟机主要完成三件事：
通过一个类的全类名来获取定义此类的二进制字节流将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构在 Java 堆中生成一个代表这个类的 Class 对象，作为方法区数据的访问入口 2.2 Android 类加载器体系 Android 的类加载器与 Java 的类加载器有不同之处，前者用来加载 dex 文件，后者用来加载 Class 字节码文件。那么 Android 中的类加载器体系是怎样的呢？看下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83dccf500c19a7fddd8019acf76fec10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b17cfedd796aecca4736e37f65482d2/" rel="bookmark">
			vue new Date() 转换为年月日时分秒以及星期几(padStart补零) - 附完整示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		new Date()：用当前日期和时间创建新的日期对象
效果 2022年07月12日 星期二 17:19:29 一、new Date() 在vue2中使用new Date() 转换为年月日时分秒以及星期几(padStart补零)
二、使用步骤 1、data中声明定时器以及在methods中的方法 代码如下（示例）：
data() { return { dateTimer: null, nowTime: '' }; }, methods: { timeFormate (timeStamp) { let y = new Date(timeStamp).getFullYear().toString() let M = (new Date(timeStamp).getMonth() + 1).toString().padStart(2, '0') let d = new Date(timeStamp).getDate().toString().padStart(2, '0') let h = new Date(timeStamp).getHours().toString().padStart(2, '0') let m = new Date(timeStamp).getMinutes().toString().padStart(2, '0') let s = new Date(timeStamp).getSeconds().toString().padStart(2, '0') let w = new Date(timeStamp).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b17cfedd796aecca4736e37f65482d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c773d943d636f81e943d1a5f2ae0a8/" rel="bookmark">
			LLaMa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Problems403 代码文件LLaMA: Open and Efficient Foundation Language Models方法预训练数据结构优化器一些加速的方法 结果Common Sense ReasoningClosed-book Question AnsweringReading ComprehensionMassive Multitask Language Understanding Instruction Finetuning附录Question AnsweringGenerations from LLaMA-65BGenerations from LLaMA-I Llama 2: Open Foundation and Fine-Tuned Chat Modelspretraining methodologyPretraining DataTraining Details fine-tuning methodologySupervised Fine-Tuning(SFT)Reinforcement Learning with Human Feedback (RLHF) Problems 403 reclone and request.
代码文件 两个测试样例:
example_text_completion.py: 文本补全示例;example_chat_completion.py: 对话生成示例. torchrun --nproc_per_node 1 example_text_completion.py \ --ckpt_dir llama-2-7b/ \ --tokenizer_path tokenizer.model \ --max_seq_len 128 --max_batch_size 4 torchrun --nproc_per_node 1 example_chat_completion.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28c773d943d636f81e943d1a5f2ae0a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c41bbefcc31130209aa1a76c2310908/" rel="bookmark">
			C#线程间控件操作--解决错误：线程间操作无效，从不是创建控件的线程访问它
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#中创建线程的几种方法 1. Task private void button1_Click(object sender, EventArgs e) { //方式1 Task.Factory.StartNew(()=&gt;Test()); //方式2 Task task2 = new Task(()=&gt;{ Test(); }); task2.Start(); //方式3 Task.Run(()=&gt;{ Test(); }); } private void Test() { // do something } 2. new Thread() private void button1_Click(object sender, EventArgs e) { //方式1： Thread TestThread = new Thread(Test); TestThread.IsBackground = true; TestThread.Start(); //方式2： Thread thread2 = new Thread(new ThreadStart(Test)) { IsBackground = true }; thread2.Start(); } private void Test() { // do something } 异步委托线程中控件访问 private void button1_Click(object sender, EventArgs e) { Task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c41bbefcc31130209aa1a76c2310908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fef7f0c36baf5c958f4cda00371c7f/" rel="bookmark">
			python 异步任务框架 Celery 入门，速看！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01、简介 Celery 是使用 python 编写的分布式任务调度框架。
它有几个主要的概念：
celery 应用
用户编写的代码脚本，用来定义要执行的任务，然后通过 broker 将任务发送到消息队列中
broker
代理，通过消息队列在客户端和 worker 之间进行协调。
celery 本身并不包含消息队列，它支持一下消息队列
RabbitMQ
Rdis
Amazon SQS
Zookeeper
更多关于 Broker 见官方文档（末尾点击阅读原文）
backend
数据库，用来存储任务返回的结果。
worker
工人，用来执行 broker 分派的任务。
任务
任务，定义的需要执行的任务
版本要求
Celery5.1 要求：
python（3.6，3.7，3.8）
Celery 是一个资金最少的项目，所以我们不支持 Microsoft Windows。
更多更详细的版本要求见官方文档
如果你想学习自动化测试，我这边给你推荐一套视频，这个视频可以说是B站播放全网第一的自动化测试教程，同时在线人数到达1000人，并且还有笔记可以领取及各路大神技术交流：798478386 【已更新】B站讲的最详细的Python接口自动化测试实战教程全集（实战最新版）_哔哩哔哩_bilibili【已更新】B站讲的最详细的Python接口自动化测试实战教程全集（实战最新版）共计200条视频，包括：1、接口自动化之为什么要做接口自动化、2、接口自动化之request全局观、3、接口自动化之接口实战等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV17p4y1B77x/?spm_id_from=333.337&amp;vd_source=488d25e59e6c5b111f7a1a1a16ecbe9a
安装
使用 pip 安装：
pip install -U Celery 捆绑包
Celery 还定义了一组包，用于安装 Celery 和给定的依赖项。
可以在 pip 命令中实现中括号来指定这些依赖项。
pip install "celery[librabbitmq]" pip install "celery[librabbitmq,redis,auth,msgpack]" 02、简单使用 1. 选择一个 broker
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39fef7f0c36baf5c958f4cda00371c7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8289b428952cd5b11b94fd6635ca882/" rel="bookmark">
			JS【filter过滤器】的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中，filter()是一个高阶函数，它是数组(Array)的一部分，可用于创建一个新数组，其中包含通过所提供函数实现的测试的所有元素。
filter()函数的语法如下：
let newArray = arr.filter(callback(element[, index, [array]])[, thisArg]) 参数解释：
callback：一个函数，用来测试每个元素是否满足某种条件。它接受以下参数： element：数组中正在处理的当前元素。index（可选）：数组中正在处理的当前元素的索引。array（可选）：filter被调用的数组。 thisArg（可选）：执行 callback 函数时使用的 this 值。 filter()函数会为数组中的每个元素执行一次 callback 函数，并且创建一个新数组，所有使 callback 返回 true 的元素都会被添加到这个新数组中。原始数组不会被改变。
以下是一个简单的例子，过滤出一个数组中所有的偶数：
let numbers = [1, 2, 3, 4, 5, 6]; let evens = numbers.filter(function(item) { return item % 2 === 0; }); console.log(evens); // [2, 4, 6] //或者 const evens = numbers .filter(e=&gt; e%2 === 0) 在这个例子中，我们将数组 numbers 中的每个元素传递给 filter() 方法。filter() 方法执行的函数检查每个数是否为偶数。如果是，它返回 true，这个数就被添加到 evens 数组中。如果返回 false，则不会被添加。最终，我们将得到一个包含原始数组中所有偶数的新数组。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2211a50f90cb78a6159c0904b40f8df/" rel="bookmark">
			Vue使用样式穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Vue 使用样式穿透对UI组件的样式进行调整
在使用样式穿透需要注意less语言配合/deep/使用，scss语言可以使用::v-deep Less语言使用/deep/ &lt;style lang="less" scoped&gt; /deep/ .el-input--small .el-input__inner{ height: 20px !important; line-height: 20px !important; font-size: 12px !important; } &lt;style&gt; Scss语言使用::v-deep &lt;style lang="scss" scoped&gt; ::v-deep .el-radio-group { .el-radio { margin-right: 20px } } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2ffac3ff5858435f0c5094123e6c27/" rel="bookmark">
			【股票价格走势预测】数据挖掘实验一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I、项目任务要求 任务描述：由于直接的经济利益，股票价格预测一直吸引着有兴趣投资股票市场和股票交易所的人。它也是金融界的一个重要研究课题。然而股票市场收益预测是一个非常复杂的问题，取决于公司财务状况和国家政策等诸多因素。主要任务要求如下： 可选用爬虫工具或其它方法制作数据集 使用Quandl模块，引用其平台数据建立股票价格趋势预测模型(线性回归、支持向量机回归、决策树)以预测精度来评估预测模型的拟合能力结果分析 参考资料网站：基于线性回归的股票预测（scikit-learn） II、数据集描述（10） 数据集包含两支股票（GOOGL、AAPL）的历史股价数据，其中特征属性包括：
‘Adj. Open’: 股票的开盘价格，经过调整后的价格。‘Adj. High’: 股票的最高价格，经过调整后的价格。‘Adj. Low’: 股票的最低价格，经过调整后的价格。‘Adj. Close’: 股票的收盘价格，经过调整后的价格。‘Adj. Volume’: 股票的交易量，经过调整后的交易量。‘Ex-Dividend’: 不带股息（忽略）补充数据（构造新数列）： ‘HL_PCT’: 最高价和收盘价之间的百分比变化‘PCT_change’: 开盘价和收盘价之间的百分比变化‘label’: 待预测的股票价格，是 ‘Adj. Close’ 列向前移动了一定百分比行数的结果。 数据集中的记录数取决于获取的历史数据的时间段，每一行代表一天的数据。
III、主要算法原理及模型评价方法陈述（15分） 项目中涉及的主要算法是线性回归（Linear Regression）和支持向量机回归（Support Vector Machine Regression，SVM Regression）。
以下是算法原理的简要描述：
线性回归：
线性回归是一种监督学习算法，用于建立输入特征和输出目标之间的线性关系模型。在这个项目中，线性回归用于训练模型来预测股票的价格（'label’列），使用历史股价和交易量等特征作为输入。线性回归模型寻找一条最佳拟合直线，使得预测值与实际值之间的平方误差最小化。 支持向量机回归：
支持向量机回归是一种监督学习算法，用于建立输入特征和输出目标之间的非线性关系模型。本项目中，SVM回归也可以用于预测股票价格。它通过将输入数据映射到高维空间，找到一个最佳的超平面，以最小化预测误差。 决策树
决策树模型是一种用于分类和回归任务的机器学习模型，它模仿了人类在面对决策问题时的思维方式，通过一系列的决策规则来进行预测和分类。决策树模型是一种可解释性强的模型，通常用于以下两种情况：
分类问题：决策树可以用于将数据样本划分到不同的类别中。在分类问题中，每个叶子节点代表一个类别，而每个非叶子节点代表一个特征或属性上的决策规则。数据样本从根节点开始，依次按照规则向下移动，最终到达一个叶子节点，从而确定其所属的类别。回归问题：除了用于分类，决策树也可以用于回归任务，即预测连续数值的输出。在这种情况下，每个叶子节点仍然代表一个数值，但是非叶子节点的决策规则会将数据样本分配到不同的子节点，最终产生一个回归值。 决策树的构建过程通常分为以下几个步骤：
特征选择：选择最佳的特征来作为每个非叶子节点的决策规则。通常使用不同的评估指标（如信息增益、基尼不纯度等）来确定哪个特征最适合用于分割数据。数据分割：根据选定的特征，将数据集划分为不同的子集。每个子集对应于不同的特征取值或范围。递归构建：对每个子集递归地应用上述步骤，构建子树，直到达到停止条件。停止条件可以是达到最大深度、样本数不足或其他预定义条件。叶子节点标记：为每个叶子节点分配一个类别（分类问题）或一个数值（回归问题）。剪枝（可选）：决策树可能会过度拟合训练数据，为了提高泛化能力，可以对树进行剪枝，即删除一些分支。 决策树模型的优点包括易于理解和解释、对缺失值不敏感、能够处理数值和分类特征、适用于大规模数据等。然而，它也容易过拟合训练数据，因此通常需要采用剪枝等技术来改进模型的泛化性能。决策树模型的一种常见变体是随机森林，它通过组合多个决策树来提高性能和稳定性。
模型评价方法：
在项目中，使用了以下模型评价方法来评估模型性能：
训练集和测试集拆分：数据集被分成训练集和测试集，以便评估模型的泛化性能。R-squared（R²）：用于衡量模型对实际数据的拟合程度，值范围在0到1之间，越接近1表示拟合越好。可视化分析：通过绘制股票价格和预测结果的图表来可视化分析模型的表现。 IV、代码实现（45分） import quandl from sklearn import preprocessing import math import numpy as np from sklearn import model_selection, svm from sklearn.linear_model import LinearRegression import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f2ffac3ff5858435f0c5094123e6c27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a9a2d5d074313fd46796c518cf283d/" rel="bookmark">
			Unity报错NotSupportedException: Encoding 936 data could not be found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity报错NotSupportedException: Encoding 936 data could not be found.
报错
原因与解决
报错
在Unity3d 编辑器下运行没有任何问题，打包出exe文件执行时，便会出现程序无响应的情况，查看日志文件可以看到如下错误：
NotSupportedException: Encoding 936 data could not be found. Make sure you have correct international codeset assembly installed and enabled.
原因与解决
原因是Unity在发布时并没有包含这些字符集，需要手动加进去，将I18N.DLL和I18N.CJK.DLL从Unity安装目录(Editor\Data\Mono\lib\mono\2.0目录下)拷贝到项目目录的Assets目录下，然后重新编译出包，即可正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93f11706ab3f55877621d09fd62d3ba/" rel="bookmark">
			MegaCli64检查磁盘矩阵坏道情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/opt/zabbix/lldscripts/MegaRAID/MegaCli/MegaCli64 -PDList -aALL|grep -E "Slot|Error" Media Error Count: 0 Other Error Count: 0 这两个数值来确定阵列中磁盘是否有问题；
Medai Error Count 表示磁盘可能错误，可能是磁盘有坏道，这个值不为0值得注意，数值越大，危险系数越高，
Other Error Count 表示磁盘可能存在松动，可能需要重新再插入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df42ccadd0b497be207a16a12a427a92/" rel="bookmark">
			关于数据库死锁的分析以及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库死锁是指两个或多个事务互相等待对方所持有的锁而无法继续执行的状态，这种情况下会导致数据库的性能下降，甚至无法正常工作。以下是一些分析和解决方法：
分析死锁日志：数据库通常会在发生死锁时自动生成死锁日志，可以通过分析该日志来查找死锁的原因和位置。
加强锁机制：在事务进行时，加强锁机制可以避免死锁的发生。例如，使用行级锁代替表级锁，或者使用一次性获取所有需要的锁，而不是一次一次的获取。
设置超时机制：在事务进行时，可以设置超时机制，即当某个事务持有锁的时间超过一定时间后，系统将主动断开该事务的连接，从而避免死锁的发生。
调整事务隔离级别：在数据库的事务隔离级别中，不同的隔离级别对锁的使用方式有所不同，调整隔离级别可以避免死锁的发生。
优化查询语句：查询语句的性能和效率对锁的使用有很大的影响，优化查询语句可以避免锁的持有时间过长，从而避免死锁的发生。
总之，数据库死锁是一种比较常见的问题，需要从多方面进行分析和解决，以确保数据库的正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71b0738bee2e6f2468831bb608a85c7/" rel="bookmark">
			死锁：Transaction (Process ID) was deadlocked on lock resources with another process and has been chose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		死锁：Transaction (Process ID) was deadlocked on lock resources with another process and has been chose
讲故事 最近新开发了一个接口，需要对一个表进行循环增删改查，在进行更新的时候反复报错：Transaction (Process ID) was deadlocked on lock resources with another process and has been chose；
百思不得其解，原来程序都是这么写的，都没有问题，这是为什么呢
真因 未设置索引导致数据库死锁！
代码是根据GUID来进行更新操作的，而GUID又没有索引，汗
解决 将GUID字段加入索引，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746f06b12c2a89f12c6e6869cc91ab65/" rel="bookmark">
			大数据-预计算类引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预计算这种特殊的计算方法也属于在线计算的一种特例。预计算来源于数据仓库建设中的多维分析理论。如数据仓库建设所述，在 ROLAP 类型的数据仓库中，数据以行列表的形式来表示星形模型，计算属于现场计算。而 MOLAP 类型的数据仓库则以 Cube 立方体的形式存储数据，计算就属于预计算＋现场计算了。
在生产实践上，如果 ClickHouse、Impala 属于 ROLAP 类型的计算引擎，Kylin 就属于 HOLAP （MOLAP+ROLAP）类型，即原始数据存储在 ROLAP 中（例如 Hive)，Cube 数据单独计算存储在HBase 中。其在生成 Cube 立方体时不是现场计算的，属于预计算部分。面对终端查询时，利用 Cube 已经存在的“全量、多维”结果可以提供在线秒出终端所需结果的能力。
常见的多维分析有以下操作方式。
1）上卷：维度上的聚合或者直接消除维度，例如剔除时间维度的分析。
2）下钻：维度上的粒度更细划分，例如在时间维度上进一步划分年、月、日维度。类似的还有上钻，即同一维度上的细粒度聚合成粗粒度，例如将日、月聚合成年。
3）切片：固定一个维度的选取，例如只选取时间维度分析。
4）切块：固定多个维度的选取，但只取某个维度或者某些维度的区间上的直，例如时间维度上只选取一年范围内的数据。
5）旋转：维度转换，把分布在列上的数据直接按行显示，例如不同的年分列展示不同的销售总额，转换后直接在多行显示不同的年份及销售总额信息。
如果多维分析模型中，对 Cube 的生成不加以优化，上述的所有操作都会在 Cube 的结果当中，这样造成 Cube “爆炸”，浪费大量空间。
下面具体介绍Kylin。Kylin 是HOLAP 预计算的代表产品，也是国内在业界较出名的产品之一。
其具有以下特性。
1）提供基于 Hadoop 数据集的标准 SQL 查询能力。
2）提供增量构建 Cube 的能力，在秒级延迟下进行实时数据的多维分析。
3）提供 JDBC、ODBC、BI 工具的无缝接入能力。
Kylin 架构图如图7-18所示，按角色解析如下。
(1）数据源
1）支持 Hive 作为数据源，保留schema 元数据信息。
2）支持Kafka 作为流式数据源，保持增量构建 Cube 的能力。
3）支持 JDBC、Sqoop 作为关系型数据库源的导入工具，从而接入 RDBMS数据源的能力。
（2）构建 Cube
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/746f06b12c2a89f12c6e6869cc91ab65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0adfce2b12e2294bcb850c794b7d8f/" rel="bookmark">
			不同层设置不同学习率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用预训练模型时，可能需要将
（1）预训练好的 backbone 的 参数学习率设置为较小值，
（2）而backbone 之外的部分，需要使用较大的学习率。
from collections import OrderedDict import torch.nn as nn import torch.optim as optim net = nn.Sequential(OrderedDict([ ("linear1", nn.Linear(10, 20)), ("linear2", nn.Linear(20, 30)), ("linear3", nn.Linear(30, 40))])) linear3_params = list(map(id, net.linear3.parameters())) base_params = filter(lambda p: id(p) not in linear3_params, net.parameters()) optimizer = optim.SGD([ {'params': base_params}, {'params': net.linear3.parameters(), 'lr': 0.0005}], lr=0.001, momentum=0.9) print(optimizer) print(optimizer.param_groups[0]['lr']) print(optimizer.param_groups[1]['lr']) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e652e31b169bf96a57b14d1edb66f83/" rel="bookmark">
			Android 13 定制化开发--开启相机或麦克风时,去掉状态栏上的绿色图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android 12 或更高版本的设备上，当应用使用麦克风或相机时，图标会出现在状态栏中。如果应用处于沉浸模式，图标会出现在屏幕的右上角。用户可以打开“快捷设置”，并选择图标以查看哪些应用当前正在使用麦克风或摄像头。图 1 显示了包含图标的示例屏幕截图。
需求: 去掉状态栏上的 相机 绿色图标.
核心代码路径: frameworks/base/packages/SystemUI/src/com/android/systemui/privacy/PrivacyConfig.kt
@VisibleForTesting internal companion object { const val TAG = "PrivacyConfig" private const val MIC_CAMERA = SystemUiDeviceConfigFlags.PROPERTY_MIC_CAMERA_ENABLED private const val LOCATION = SystemUiDeviceConfigFlags.PROPERTY_LOCATION_INDICATORS_ENABLED private const val MEDIA_PROJECTION = SystemUiDeviceConfigFlags.PROPERTY_MEDIA_PROJECTION_INDICATORS_ENABLED //默认为true,即显示相机, - private const val DEFAULT_MIC_CAMERA = true + private const val DEFAULT_MIC_CAMERA = false private const val DEFAULT_LOCATION = false private const val DEFAULT_MEDIA_PROJECTION = true } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1669af7786cf88833ca8325eee3dc938/" rel="bookmark">
			vue-＜element-input＞输入的空格和换行进行保存显示，编辑回显时将＜br＞替换为换行符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.应用情景，输入框列可以进行编辑，用户编辑时可以输入空格以及换行，保存后的格式与用户输入格式相同，再次编辑时也是之前会显的格式
二.处理方法：
1.给&lt;element-input&gt;设置样式&lt;element-input type="textarea"&gt;
.textarea {
white-space: pre-wrap;
}
2。回显时利用正则表达式将&lt;br&gt;和&amp;nbsp替换为正常的换行和空格
&lt;div
v-html="scope.row[item.prop].replace(/\n|\r\n/g, '&lt;br&gt;').replace(/ /g, ' &amp;nbsp')"
&lt;/div&gt;
3、
// 编辑回显之前，对之前保存的字符串使用 removeBr()处理，让&lt;br&gt;变成换行
editClick () {
this.tableData.forEach((item, index) =&gt; {
this.tableData[index].progress = removeBr(item.progress, '\n')
})
},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7c5a0c3f289fed2a6c8bd6f149c3af/" rel="bookmark">
			网络智能化/通信AI TOP10 十大研究方向及数据集盘点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，随着人工智能技术的广泛应用和通信领域技术的演化迈进，二者的相互融合发展成为必然趋势，而数据集作为训练模型的基础逐渐走入研究者视野，变得越发重要。业界重磅机构中国移动和中国信息通信研究院也都发布了各自的数据集平台（智慧网络开放创新平台、移动通信开放平台 ）。在本文中，我们将介绍网络智能化领域中TOP 10研究方向和常用的数据集，这些数据集在各自的场景内具有广泛的应用和重要的地位，希望能够为广大研究人员和工程师提供一些参考和帮助。
无线信道建模和预测 信道是物理层的核心之一，它的性能决定了无线通信的传输效率和稳定性。因此，无线信道建模和预测作为无线通信系统设计和优化的基础，是无线通信领域中的重要研究方向以及技术研发的关键环节之一。随着5G无线通信技术的快速发展和应用，无线信道建模和预测数据集的研究越来越受到关注。
无线信道建模和预测数据集用于研究无线信号在传播过程中的衰落特性、多径传播、信道容量等问题，预测无线信号在信道中的传播特性。这些数据集通常包含信号强度、相位、延迟等信息，以及相应的地理位置、天线配置、频率等元数据。数据集可以是实测数据、模拟数据或者公开数据集，被用于训练和测试无线信道模型，评估模型的性能，以及开发新的无线通信技术和算法，从而帮助我们更好地理解和优化无线通信系统的设计和性能。
目前，许多企业和研究机构都在投入大量资源进行无线信道建模和预测的研究，并且一些公开的数据集也不断被发布和更新。 一些著名的公开数据集包括IEEE 802.11ad Channel Measurement Dataset、Channel SENSED等，为研究者提供了宝贵的数据资源，无线信道建模和预测数据集的发展和应用将会推动无线通信技术的进步和发展。
自适应调制与编码 自适应调制与编码（AMC）是一种基于物理层的链路自适应技术，该技术主要通过调整无线链路的调制方式和编码速率来确保链路的传输质量。当信道条件较差时，系统会选择较小的调制方式和编码速率；而当信道条件较好时，系统则选择较大的调制方式，从而最大化传输速率。在调整过程中，系统总是希望传输的数据速率与信道变化的趋势一致，从而最大化地利用无线信道的传输能力。尤其在是5G时代，由于更高的传输速率和更大的频谱利用率需求，自适应调制与编码技术的研究热度进一步增加。
自适应调制与编码数据集通常包括信道质量指示（CQI）、预编码矩阵指示（PMI）和 rank 指示（RI）等信息的测量和反馈。这些信息用于在上行和下行信道中实现自适应调制和编码。通过在不同的信道条件下进行测试，研究人员可以评估和比较各种调制方式和编码速率组合在不同场景下的传输性能，从而为实际应用提供参考。
边缘计算与边缘智能 随着5G技术的逐渐成熟和商用，边缘计算和边缘智能将会成为未来的发展趋势。边缘计算和边缘智能是两个相关的技术领域，为满足各种实时应用的需求，以提高数据处理效率和降低延迟，因此它们都需要大量的数据集来进行测试和评估。
边缘计算是一种将数据在数据来源的节点处进行处理的技术，而边缘智能则是一种将数据分析、机器学习或人工智能应用于边缘计算架构中的工作负载。边缘计算的数据集通常来自于真实世界中各种传感器和设备，如物联网设备、本地终端设备或边缘服务器等，这些数据集需要包含实际应用场景中的各种数据特征和异常情况，主要用于评估边缘计算架构的性能和效率，例如，测试边缘计算设备的数据处理能力、延迟、能耗等方面的指标。然而，在现有技术条件下获取这些信息并进行有效整合仍然存在一定难度。边缘智能的数据集通常需要包含实际应用场景中的各种数据特征和标签，主要用于评估在边缘计算架构中应用人工智能算法和框架的可行性和性能。这些数据集都是为了满足边缘计算和边缘智能的研究和应用需求而设计的，通过对这些数据集的测试和评估，可以不断提高边缘计算和边缘智能的性能和效率。
网络流量分析与拓扑优化 网络流量分析与优化是通信网络的一个重要研究方向，其目的是通过对网络流量的分析和优化，提高网络性能和可靠性。随着信息化技术的快速发展和普及，网络流量分析与优化数据集的研究和应用也呈现出快速发展的趋势，研究热度持续升温。
网络流量分析与优化数据集通常包括网络流量日志、网络流量统计信息、网络流量镜像等，包含了实际网络环境中的各种流量特征和通信行为，如HTTP、FTP、电子邮件、在线视频等。通过对这些数据集进行分析和挖掘，能够获取网络流量的统计特性、通信模式、异常情况等信息，可以实时监测网络性能，发现网络攻击和异常行为，诊断网络故障，提高网络安全性和可靠性。同时，通过对网络流量数据的分析和建模，还可以优化网络规划和资源配置，提高网络效率和利用率。
目前，国内外许多高校、研究机构和企业已经对网络流量分析与优化数据集开展了广泛的研究和应用实践，其发展和应用对于提高网络安全性和可靠性、优化网络规划和资源配置、提升网络性能和传输效率等方面都具有重要意义。
故障感知与故障定位 随着云计算的普及和大数据技术的快速发展，网络规模逐渐扩大，网络行为复杂性逐渐提高，对于网络故障的快速检测和定位需求也越来越迫切。由于网络故障对于用户体验和网络运营都会带来很大的影响，因此，许多企业和组织都投入大量资源和人力进行网络故障感知和定位的研究和应用，这也推动了故障感知与故障定位数据集的火热发展。
故障感知与故障定位数据集通常包括网络设备类型、设备运行状态、故障时间及设备、故障等级及原因等。研究者和一线运维人员可以通过对该类数据集分析和处理，发现异常和故障的规律和特征，从而推断出可能的原因，进一步建立精确、高效、智能的故障感知模型和根因分析算法，来实现快速准确的网络设备或系统故障检测并定位故障原因，保障系统稳定、安全和可靠运行。
网络资源管理/分配优化 网络资源管理/分配优化数据集主要涉及网络通信领域中的资源管理和分配优化问题。这类数据集通常包括网络拓扑结构、节点信息、通信负载、流量特征等数据，用于评估网络资源管理的性能和优化网络资源分配的策略。该类数据集用途非常广泛，例如在网络路由领域中，可用于评估路由算法的性能和优化路由策略；在云计算领域中，可用于优化虚拟机调度和网络拓扑控制策略；在物联网领域中，可用于优化节点协作和网络资源分配策略等。大数据技术的广泛应用也为该类数据集的处理和分析提供了强有力的支持。通过对海量网络数据的采集、存储和分析，可以获得许多有价值的洞察，从而指导网络资源管理和优化策略的制定。
目前，由UC Irvine开发的INCASE数据集就是一个用于网络资源管理/分配优化的开源数据集，包含了各种网络场景和参数配置下的网络性能数据，为研究者提供了很好的研究和实验平台。随着网络智能化技术的不断发展和应用需求的不断增加，网络资源管理/分配优化数据集的研究和应用前景也将更加广阔。
大规模天线（MIMO）预编码和解码 随着无线通信技术的迅速发展，大规模MIMO技术逐渐成为5G通信网络中的关键技术之一，而预编码和解码技术在大规模MIMO系统中起着至关重要的作用，因此，大规模MIMO的预编码和解码数据集的研究和应用受到了广泛关注。此外，由于大规模MIMO系统的复杂性和实际应用的需求，需要处理海量的数据和复杂的信号处理算法，这也推动了相关数据集的发展和研究热度的提升。
大规模MIMO预编码和解码数据集是一类用于大规模多输入多输出无线通信系统预编码和解码算法评估和优化数据集。它们主要用于大规模MIMO系统的预编码和解码算法的评估、测试和比较。除了预编码数据集，大规模MIMO解码数据集也受到了广泛关注。在大规模MIMO系统中，由于信道衰落和噪声的影响，接收端需要采用先进的信号处理算法来恢复出原始信号。因此，大规模MIMO解码数据集主要用于评估和优化各种信号处理算法的性能，如MMSE、 turbo解码、迭代译码等。
总之，大规模MIMO的预编码和解码数据集是5G通信领域中非常重要的数据集之一，其内容涵盖了大规模MIMO技术的理论、实现和原理样机等方面。相关数据集的发展和研究对于推进无线通信技术的进步和应用具有重要的意义。
时空序列预测 时序/时空预测数据集是指包含时间或空间序列数据的集合，通常用于预测未来的趋势或事件。它们包含各种类型的测量数据，例如气温、气压、风速、电力消耗、房价、股票等。例如在气象学领域，可以使用它们来预测未来的天气状况，在交通领域，可以使用它们来预测交通流量情况等。这种广泛的用途使得时序/时空预测数据集成为目前研究的热点之一。这种预测能力对于许多行业和领域来说非常重要，因为它可以帮助人们更好地规划和管理资源，做出更明智的决策。
时序/时空预测数据集是机器学习和深度学习算法的重要应用领域之一，可以使用不同的机器学习算法和深度学习模型进行处理和分析，如LSTM、CNN、RNN等。近年来，研究人员在时序预测数据集的基础上提出了一系列新的模型和技术，如集成学习、生成对抗网络等，以提高预测精度和泛化能力。常见的时序/时空预测数据集包括M4挑战数据集、Energy disaggregation数据集、PGMDC数据集、出租车轨迹数据集、房价预测数据集、电价预测数据集、股票价格预测数据集、气温预测数据集、交通流量预测数据集等。这些数据集具有不同的特点和用途，但都为时序/时空预测领域的研究提供了重要的数据基础和挑战。
CSI信道反馈及压缩 作为5G的关键研究技术，大规模MIMO因其高系统容量和高链路可靠性等优点而备受关注，为了获取大规模MIMO系统更好的空间复用与分集增益，基站需获取精确的下行信道状态信息来进行预编码。随着系统带宽和MIMO天线数的增加，CSI的维度呈指数增大，而常规的基于码本的CSI反馈方法因计算复杂度高和存储开销大等因素严重影响系统的传输效率与能力。因此，行之有效的CSI压缩反馈方法才可以保证大规模MIMO系统的高效运行和系统增益。
最近关于基于AI的CSI压缩反馈技术的研究表明，应用AI技术解决非线性问题与挑战将越来越流行，并且可以提高CSI反馈压缩的质量与反馈传输的精确度，还可以高效缩减CSI的运行时间。常见的CSI压缩反馈算法有基于压缩感知的CSI反馈算法、基于深度学习的CSI反馈算法等。CSI压缩反馈数据集为基于AI的CSI压缩反馈提供了数据基础，数据集的构建可通过仿真构建或现网采集，其中仿真数据集通过信道建模产生理论场景下的信道数据，现网采集数据集则更复杂、更随机、更多样。高质量的数据集应满足多种信道场景、不同发射天线数、不同系统带宽配置等，丰富的数据集可提高AI模型的泛化性。
目前，各大研究机构都致力于开发和应用不同的CSI信道反馈压缩数据集，以推动CSI压缩反馈技术发展和落地。研究者更多是通过仿真方法构建不同场景、不同参数配置下的信道数据，该方法可以验证并不断优化AI算法性能。研究者同时开展基于现网实际场景信道数据的CSI压缩反馈技术的性能验证。
无线资源调度与决策 随着5G技术的普及和未来无线通信技术的发展，无线资源调度与决策成为了关键技术之一。在多用户、多小区、多波段的通信系统中，如何高效地利用有限的无线资源进行调度和决策，直接关系到整个通信系统的性能和效率，例如，如何进行无线信道分配、如何进行用户调度、如何进行速率分配等。这些问题都需要大量的实验数据和算法支持，因此，无线资源调度与决策数据集的研究和应用得到了广泛关注。
无线资源调度与决策数据集通常包含来自实际通信系统的测量数据，例如信道状态信息、用户位置信息、传输速率等信息，包含各种不同的场景和参数配置，以供研究者进行实验和分析，来评估和优化无线通信系统中的无线资源调度与决策算法。通过使用这些数据集，研究者可以开展算法实验，比较不同算法的性能和效率，以寻找更好的调度和决策策略。无线资源调度与决策的目的是为了优化整个通信系统的性能和效率。例如，如何进行无线资源分配和调度，以最大化系统吞吐量、最小化传输时延、最大化用户满意度等。
以上就是网络智能化领域中常用的重磅TOP 10数据集，它们在各自的领域场景中都具有广泛的应用和重要的地位，希望能够为大家提供一些参考和帮助。当然，不同领域的数据集应用场景不同，需要结合具体需求选择合适的数据集。随着网络智能化技术的不断发展，相信会有更多新数据集不断涌现，推动通网络智能化在不同领域中的应用和发展。
进一步了解相关资讯可以关注公众号、小程序。
关于网络智能化相关的问题讨论、资料、论文、数据、研究交流可加助手微信进群交流
网智圈-一起AI赋能网络 | Link3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a190e740d74eef22f45e40bf409af49/" rel="bookmark">
			想买个深度学习的算力设备，TOPs和TFLOPs 啥啥分不清
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TFLOPs和 TOPs都是描述深度学习设备计算能力的单位，1TFLOPS与1TOPS，前者代表是每秒执行1万亿次 浮点 运算次数，后者代表每秒执行1万亿次运算次数，区别FL即float浮点，大多数NPU都是定点运算，故通TOPS来标称算力。它们之间的转换通常可以用1TFLOPS=2*1TOPS来计算，但是需要注意TFLOPS中有单精度FP32 和半精度FP16的区别，默认是FP16。
理论峰值 ＝ GPU芯片数量GPU Boost主频核心数量*单个时钟周期内能处理的浮点计算次数
只不过在GPU里单精度和双精度的浮点计算能力需要分开计算，以最新的Tesla P100为例：
双精度理论峰值 ＝ FP64 Cores ＊ GPU Boost Clock ＊ 2 ＝ 1792 ＊1.48GHz＊2 = 5.3 TFlops
单精度理论峰值 ＝ FP32 cores ＊ GPU Boost Clock ＊ 2 ＝ 3584 ＊ 1.58GHz ＊ 2 ＝ 10.6 TFlop
单精度计算能力的峰值 = 单核单周期计算次数 × 处理核个数 × 主频
算力单位
TOPS（Tera Operations Per Second：）1TOPS处理器每秒钟可进行一万亿次（10^12）操作。
GOPS（Giga Operations Per Second）：1GOPS处理器每秒钟可进行一亿次（10^9）操作。
MOPS（Million Operation Per Second）：1MOPS处理器每秒钟可进行一百万次（10^6）操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31dda59d587201c88759136d3413dc1f/" rel="bookmark">
			Tomcat的启动问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天去打开Tomcat的时候没反应 如下
按之前是到Tomcat目录下的bin目录下的startup.bat文件，双击，就可以启动Tomcat服务器。启动后可以
打开浏览器，在浏览器地址栏中输入以下地址测试：
1、http://localhost:8080
2、http://127.0.0.1:8080
当出现Tomcat界面时，说明Tomcat启动成功。
但现在页面没有任何反应
解决的办法有
重新配置系统的环境
再找系统变量中的Path，添加：
%CATALINA_HOME%\bin
最后在重新启动
解决问题
不过双击startup.bat文件依然没有反应
需要去widow+r输入cmd在窗口输入startup.bat便可以启动了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525db8fa018ae07ee13464fa9e70c95f/" rel="bookmark">
			2028.开发者实用工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 十六进制数据查看器windows 下查找软件文件比较软件 十六进制数据查看器 bes.exe 打开 xx Gb 数据很轻松 .besnew.zip windows 下查找软件 Everything_25482 文件比较软件 BCompare 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca08023632351ecbf51d4e9b9ca6471/" rel="bookmark">
			PWA建快应用，小程序建超级App？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序在特定的平台生态系统中崭露头角，为开发者提供了更深度的集成和用户接触点。通过应用商店的分发和推广机制，小程序能够迅速扩大用户基础，为企业和品牌提供了直接触达用户的机会。尤其是在社交媒体平台上，小程序的分享和使用已成为用户互动和交流的一种重要方式。
PWA代表“渐进式网络应用”（Progressive Web Application）。它是一种结合了网页和移动应用程序功能的技术概念。PWA旨在提供类似于原生应用程序的用户体验，包括离线访问、推送通知、后台同步等功能，同时又具有网页的优势，如跨平台、无需下载安装等。
PWA 这个概念在行业内发展的挺快，基于 Chromium 的浏览器 Chrome 和 Opera 已经完全支持 PWA 了，Firefox 和微软的 Edge 正在开发中，水果公司的 Safari 最近刚刚表达了可能会支持 PWA。从长久的角度看，只要 Google 不断推动一些网站往 PWA 转型，其他的浏览器或者竞争对手也就会自然跟风上船。
PWA建快应用，小程序建超级App？
有的同学会问，为什么会有这么奇怪的联想和对比？这还需要从上述两种技术生态技术支持的方向来讲。
PWA生态系统支持
广泛支持：PWA可以在几乎所有现代浏览器上运行，无需安装和更新，具有广泛的设备和平台支持。 Web技术栈：PWA使用Web标准技术（HTML、CSS和JavaScript），开发者可以充分利用现有的Web开发知识和工具。 开发者社区：PWA拥有庞大的开发者社区，提供丰富的资源、工具和支持。
小程序生态系统支持
流量入口： 小程序可以通过微信、支付宝等主流社交平台作为流量入口，除了这些巨头的流量平台以外，小程序目前也可以运行在企业自有App中了，任何企业的App只需要通过集成小程序运行时SDK,即可获得小程序运行能力，（目前市面上主流的小程序SDK商有FinClip等），让小程序拥有更多分发渠道。
小程序生态：在BAT等巨头的带动下，市场上已经有11大小程序平台，700W+的小程序应用，覆盖200+个细分垂直领域，可见，小程序生态在国内已经具备相当影响力的规模。正因为如此迅猛的发展，互联网系列全球标准的制定者W3C，也正在通过其Mini-Apps工作组制定小程序技术的国际标准。
作为Web 2.0的标志性技术产物，历经互联网蓬勃发展的市场需求的迭代，衍生出许多标准化的、能够降低App开发的插件式SDK：极光推送、声网音视频、第三方登录、第三方支付.....这些插件的发展，进一步的推动了App组装式应用。
开放能力：小程序提供了丰富的开放能力，开发者可以与硬件设备和第三方服务进行集成。
与此同时，两种技术的跨端能力也是有区别的。PWA的跨端是基于Web标准，可以在不同平台和设备上运行，包括桌面、移动和平板设备。 而小程序的跨端能力重点在智能移动终端（App，Pad等），现在基于一些厂商的小程序容器技术（如：FinClip），还可以在各类智能终端上运行（例如：智能车载设备、智慧大屏等等）
PWA和小程序虽然技术实现原理有所不同，但它们共同的目标是扩大智能设备的生态构建。随着智能手机、平板电脑、智能音箱等智能设备的普及，用户的需求也在不断演变，他们期望更灵活、更高效地获取信息和使用应用程序。在这一背景下，PWA和小程序崭露头角，成为了满足这些需求的重要方式。
PWA通过利用Web技术的灵活性和跨平台性，为用户提供了无缝的跨设备体验。用户可以从各种浏览器中访问PWA，无需下载或安装，这为开发者提供了更广泛的覆盖面，同时也降低了用户获得价值内容的门槛。离线访问、推送通知等功能增强了用户粘性，使PWA成为了吸引和保留用户的有力工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/604e731bdb8fef12004f89bffe64d1a3/" rel="bookmark">
			hive 多行转一列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 多行转一列 多行转一列 表 test。同一件商品可能有多个平台属性，表中一行数据代表一个平台属性。表字段：sku_id：‘商品id’，attr_id：‘商品的平台属性id’，value_id：‘商品的平台属性值id’，attr_name：‘商品的平台属性名称’，value_name：‘商品的平台属性值名称’
sku_idattr_idvalue_idattr_namevalue_name1106176手机一级安卓手机1107177二级手机小米12383运行内存8g12482机身内存128g2106176手机一级安卓手机2107177二级手机小米22383运行内存8g224166机身内存256g 题目描述：将商品的每一个平台属性封装成kv类型并整合成json对象，并将多个平台属性，整合到一个数组中，注意去重
代码编写：
1、将商品的每一个平台属性封装成kv类型并整合成json对象
select sku_id, named_struct('attr_id', attr_id, 'value_id', value_id, 'attr_name', attr_name, 'value_name', value_name) from test; sku_id_c11{“attr_id”:“106”,“value_id”:“176”,“attr_name”:“手机一级”,“value_name”:“安卓手机”}1{“attr_id”:“107”,“value_id”:“177”,“attr_name”:“二级手机”,“value_name”:“小米”}1{“attr_id”:“23”,“value_id”:“83”,“attr_name”:“运行内存”,“value_name”:“8g”}1{“attr_id”:“24”,“value_id”:“82”,“attr_name”:“机身内存”,“value_name”:“128g”}2{“attr_id”:“106”,“value_id”:“176”,“attr_name”:“手机一级”,“value_name”:“安卓手机”}2{“attr_id”:“107”,“value_id”:“177”,“attr_name”:“二级手机”,“value_name”:“小米”}2{“attr_id”:“23”,“value_id”:“83”,“attr_name”:“运行内存”,“value_name”:“8g”}2{“attr_id”:“24”,“value_id”:“166”,“attr_name”:“机身内存”,“value_name”:“256g”} 2、将多个平台属性，整合到一个数组中，注意去重
select sku_id, collect_set(named_struct('attr_id', attr_id, 'value_id', value_id, 'attr_name', attr_name, 'value_name', value_name)) attr from test group by sku_id; 结果输出：
sku_idattr1[{“attr_id”:“107”,“value_id”:“177”,“attr_name”:“二级手机”,“value_name”:“小米”},{“attr_id”:“23”,“value_id”:“83”,“attr_name”:“运行内存”,“value_name”:“8g”},{“attr_id”:“106”,“value_id”:“176”,“attr_name”:“手机一级”,“value_name”:“安卓手机”},{“attr_id”:“24”,“value_id”:“82”,“attr_name”:“机身内存”,“value_name”:“128g”}]2[{“attr_id”:“24”,“value_id”:“166”,“attr_name”:“机身内存”,“value_name”:“256g”},{“attr_id”:“106”,“value_id”:“176”,“attr_name”:“手机一级”,“value_name”:“安卓手机”},{“attr_id”:“107”,“value_id”:“177”,“attr_name”:“二级手机”,“value_name”:“小米”},{“attr_id”:“23”,“value_id”:“83”,“attr_name”:“运行内存”,“value_name”:“8g”}] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9a9262dd31e269e21dc6b897002649/" rel="bookmark">
			【Docker】学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. docker基本操作 镜像搜索 // 直接搜索镜像资源 docker search mysql // 搜索过滤 docker search --filter "is-official=true" mysql // 官方发布镜像 拉取镜像 docker pull mysql 查看本地镜像 docker images 删除本地镜像 docker rmi mysql // 强制删除镜像 docker rmi -f mysql 保存加载镜像 docker save 镜像id &gt; 文件名.tar // example: docker save 8da80fe49fcf&gt;./mysql.tar docker load &lt; 文件名.tar // example: docker load &lt; mysql.tar // 加载的镜像会没有名称和TAG，需要重命名 docker tag [镜像id] [新镜像名称]:[新镜像标签] 创建容器 docker create --name=mysqlContainer mysql 创建并运行容器 docker run -itd --name=mysqlContainer mysql 查看容器信息 // 查看运行中的容器信息 docker ps // 查看包括已停止运行的所有容器的信息 docker ps -a 停止运行容器 docker stop mysqlContainer 重新运行容器 docker restart mysqlContainer 删除容器 docker rm mysqlContainer 进入退出容器环境： docker-compose exec -it [容器的name或ID] /bin/bash // 有时候镜像比较精简，没有bash，使用下面的命令 docker-compose exec -it [容器的name或ID] /bin/sh // 退出容器终端界面 exit 提交容器修改 docker commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9a9262dd31e269e21dc6b897002649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf8c5d8c0232b53a85964604e405d6a0/" rel="bookmark">
			python中selenium如何定位shadow-root中的元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近遇到了这个问题，找了好久，终于找到了，参考的是下面这篇文章，但是这篇文章写的比较简单并且有点小问题，对此进行补充，和记录关于shadow-root的查找_#shadow-root_Redamancy又在写BUG的博客-CSDN博客
是以下面这个图片为例，要定位到里面的input需要这么写：
driver.find_element(By.CSS_SELECTOR,'kat-input').shadow_root.find_element(By.CSS_SELECTOR,'input') 后面如果有多个shadow-root可以接多个shadow_root，例如：
t=driver.find_element(By.CSS_SELECTOR,'kat-date-range-picker').shadow_root.find_element(By.CSS_SELECTOR,'kat-date-picker[class=start]').shadow_root.find_element(By.CSS_SELECTOR,'kat-input').shadow_root.find_element(By.CSS_SELECTOR,'input') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85909c5345830da36085fad0f622d00/" rel="bookmark">
			VSCode - PHP/Go开发 - 使用/实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.应用场景
主要用于使用VSCode 基于PHP / Go进行项目开发，熟练使用vscode帮助我们进行高效的开发。
2.学习/操作
环境
Windows 10 64位 专业版 / PHP 7.x / VSCcode
Mac pro 2015 / 2017 / 2019 均有使用
1. VSCcode介绍 VSCode - 学习/使用
https://www.cnblogs.com/liyuchuan/p/12131637.html
2. 实践 进行基于PHP语言的开发, 首先要安装PHP的插件, 从而可以进行PHP代码之间的跳转, 否则你就只能自己找.
一般选择前三个任意一个均可, 这里选择的是第二个
按下alt, 鼠标放在Tag模型类上, 便可以进行代码的跳转, 如果没有安装该插件, 是不会出现任何提示的, 以及代码跳转.
Note:
该扩展，也支持格式化 但是有时要手动做配置，如下：
@ext:sophisticode.php-formatter
3. vscode 在php开发中双击选中变量时不能选中$符号 20200905
解决办法:
打开首选项, 设置, 搜索 word separators , 去掉$即可[即不将$作为单词分隔符]
然后okay～
4. 安装git 相关history 插件，快速查看文件历史记录 可选： git history /local history 等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85909c5345830da36085fad0f622d00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619afd53dd77aad06c4afe91e67b45cb/" rel="bookmark">
			GSAP动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="container"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts"&gt; import { defineComponent, onMounted } from "vue"; import { gsap } from "gsap"; import { ScrollTrigger } from "gsap/ScrollTrigger"; gsap.registerPlugin(ScrollTrigger); export default defineComponent({ setup() { onMounted(() =&gt; { gsap.to(".container", { scrollTrigger: { trigger: ".box", markers: true, scrub: true, }, x: 500, y: 500, backgroundColor: "red", duration: 5, }); }); return {}; }, }); &lt;/script&gt; &lt;style lang="scss" scoped&gt; .container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619afd53dd77aad06c4afe91e67b45cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef91a312cd3e169d9d52c3c47074a268/" rel="bookmark">
			Gradle实用配置笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 两个依赖的assets下有相同文件导致冲突
如高德地图2d和3d下的assets/location_map_gps_locked.png冲突处理： android { packagingOptions { // pickFirsts:当出现重复文件，会使用第一个匹配的文件打包进入apk pickFirst 'assets/location_map_gps_locked.png' } } 如果上面不行，报Entry name 'assets/location_map_gps_locked.png' collided错误，则 packagingOptions { exclude 'assets/*' } 多个依赖版本时强制指定版本
在project 的gradle下： allprojects { repositories { .... } configurations.all { // fix 依赖冲突 resolutionStrategy.force "androidx.recyclerview:recyclerview:1.1.0" } } 全局exclude依赖
在app的gradle下： defaultConfig { configurations.all { // 可选 resolutionStrategy.cacheChangingModulesFor 1, 'seconds' all*.exclude group: 'com.google.guava', module: 'guava' } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d895e6618f3a8ee4bc04f64292d69af/" rel="bookmark">
			微信自带截图工具 截图 黑屏 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信自带截图工具 截图 黑屏 解决办法：
微信快捷键 1）点击右键【属性】--》【兼容性】---》【更改高DPI设置】---》勾选【使用此设备修复此程序的缩放问题，而不是。。。】
2）点击右键【属性】--》【兼容性】---》【更改高DPI设置】---》勾选【替代高DPI缩放行为】
3）点击右键【属性】--》【兼容性】---》勾选【以管理员身份运行此程序】
点击【运行】，输入gpedit.msc，回车
导航到“计算机配置” &gt;“管理模板” &gt;“ Windows组件” &gt;“ 平板电脑” &gt;“附件” &gt;双击 “不允许运行截屏工具”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819dc54cd1cf4a80d4658719e4163110/" rel="bookmark">
			【Linux】如何在Ubuntu下使用网易云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：ubuntu 22. 04.1LTS
时间：2022/11/19
机型：华硕灵耀X双屏Pro，X86 64位系统
本人第一次安装网易云带来了一系列问题，这里给大家整理下全攻略，安装失败的可以在评论区，等待大佬指正。
Step1：官网安装linux版本网易云/使用指令获得deb的安装包。
选择需要的版本，这里我选择ubuntu18.04版本，鉴于我版本超前，所以不得不做一些修改。
（为了写教程，我重新装一遍好了）
Step2：下载完会有这个界面
然后按ctrl+alt+t打开终端
然后输入：sudo dpkg -i 文件路径
文件路径可以直接把刚才下载的软件包拖进终端
然后回车输入用户密码
输入密码没有显示不要害怕，直接输入，因为安全问题是不会显示的。（对于所有的sudo命令都是如此）
然后你有一个网易云图标，但是点了没有反应，这就是因为原来的bash启动和现在不匹配。
进入资源管理器，找到你的网易云所在位置，可以用find也可以直接资源管理器里搜索
网易云是通过bash来启动的，所以我们要修改这个bash，但是你点开发现权限不够怎么办？
我这里就是read only，我们要通过超级管理员权限来修改啦
鼠标右键打开文件夹所在位置
这里感谢这位大佬
Ubuntu修改文件权限_Slwhy的博客-CSDN博客
打开命令终端，输入：
sudo chmod a+w (文件名字）
sudo chmod a+w netease-cloud-music.bash 意思是对所有人开放写入权限，再输入密码就修改成功了。
因为我是为了快速修改才选a+w，修改完我还会把权限改回来，一般不建议对所有人开放。
然后发现那个bash可以修改了
修改成这个代码就可以跑了
代码块在这里
#!/bin/sh HERE="$(dirname "$(readlink -f "${0}")")" export QT_SCALE_FACTOR=2 # 这个是网易云字体大小 export LD_LIBRARY_PATH=/opt/netease/netease-cloud-music/libs export QT_PLUGIN_PATH="${HERE}"/plugins export QT_QPA_PLATFORM_PLUGIN_PATH="${HERE}"/plugins/platforms cd /lib/x86_64-linux-gnu/ # 唯一插入的命令，这个跟着系统修改 exec "${HERE}"/netease-cloud-music $@ 然后点save就可以了，那个字体跟这你的屏幕分辨率修改，我是4k屏幕所以就改称两倍。
祝你们安装成功。
困，溜了溜了。不过有问题可以直接评论区见，看到的也帮忙回答一下，期待大佬们的回答。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f6d12e4c08401b7edcc50e90efd179/" rel="bookmark">
			Java Socket网络编程使用方法及应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于TCP和基于UDP的Java Socket有以下区别： 可靠性： TCP是面向连接的协议，它提供可靠的数据传输。它使用确认和重传机制来确保数据的可靠交付。而UDP是无连接的协议，它不提供可靠性保证，数据包可能会丢失或乱序。
传输效率： 由于TCP提供了可靠的数据传输，它在传输过程中会进行流量控制和拥塞控制，从而可能引起一定的延迟。而UDP没有这些机制，因此在传输效率上更高。
数据量： TCP可以处理任意大小的数据，它会将数据切分成适当大小的数据包进行传输。而UDP则有最大传输单元（MTU）的限制，超过该限制的数据需要进行分片或者应用层进行处理。
连接性： TCP是面向连接的，需要在客户端和服务器之间建立连接。而UDP是无连接的，每个数据包都是独立的，不需要事先建立连接。
适用场景： TCP适用于对数据完整性要求高的场景，如文件传输、电子邮件等。而UDP适用于对实时性要求较高，但数据完整性要求不高的场景，如音视频流传输、实时游戏等。
基于TCP的Socket长连接 客户端 import java.io.*; import java.net.Socket; public class SocketClientTest { public static void main(String[] args) throws InterruptedException { try { // 和服务器创建连接 Socket socket = new Socket("localhost",9000); //实例化 OutputStream os = socket.getOutputStream(); PrintWriter pw = new PrintWriter(os); // 要发送给服务器的信息 pw.write("交易中止，有内鬼!"); pw.flush(); socket.shutdownOutput(); // 实例化 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); // 从服务器接收的信息 String info = null; while((info = br.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f6d12e4c08401b7edcc50e90efd179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82497999abc76356209929e689fa915b/" rel="bookmark">
			我想设计一套游戏的奖励系统，有什么值得注意的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏上： 游戏成就系统的价值
游戏中的成就可以延长游戏时间，让玩家不仅仅是将游戏通关，而是必须完成游戏内所有挑战及发现秘密，这些成就可以与游戏本身的目标一致，也可以独立于游戏的主要或次要目标之外，玩家必须以特别的方式完成游戏才能取得。具体而言：
增加游戏收益：与打BOSS掉装备一样，徽章、坐骑、小宠物和称号等成就奖励，需要玩家花费时间、金钱、操作等来得到一些好处，最终都会直接增加游戏收益。增加游戏寿命：通过成就系统大大丰富游戏玩法，让玩家有了更多的事可以去做，增加游戏寿命。节省开发成本：利用成就系统，让玩家用不同的打法、难度推倒同一个BOSS则会完成不同的成就，得到奖励也不相同。相对设计一个新的BOSS，仅仅增加一个新成就无疑降低了开发成本。增加游戏吸引力：对一个游戏而言，随着版本更新、内容变更，过去的东西一去不复返。而成就系统的出现，则能够记录很多过去的点点滴滴，很多玩家也会被这一点吸引，更容易对游戏产生感情。 游戏成就的两种分类方法
分类方法1
流程成就：是玩家能在流程通关里必然获得的成就，一般流程成就越多的游戏就越白金神作。流程成就的获得难度只与游戏本体难度相关，只要玩家能坚持到通关就不成问题。难度成就：是需要玩家通关游戏内的对应难度才能解锁的成就。难度成就在一定程度上可以归入流程成就范畴内，因为部分游戏的高难度和低难度几乎可以说是两个游戏，只有挑战最高难度才能获得完整的游戏体验。收集成就：玩家要在游戏中完成要素收集才能解锁成就。做得好是收集，做不好是捡垃圾。技巧成就：玩家要在游戏中完成特定的挑战条件才能解锁。与前面的难度成就不同，这些挑战条件往往不存在于游戏本体之内，而是开发者提供的bonus性质的玩法，从某种层面来说，这些成就甚至可以看做游戏的免费附赠DLC。简单粗暴的技巧成就包括但不限于“死亡/重试/受伤次数少于N次”、“通关时间少于N个小时”和“某场/全部战斗达成最高评价”等，这些条件尚且还局限于游戏本身的玩法中；也有些技巧成就的设计更为精妙，跳脱了原本游戏的框架，提出了脑洞大开的挑战条件。刷子成就：指需要付出大量重复劳动才能解锁的成就，包括但不局限于“击杀N个敌人”这种最常见的强行续游戏时间的成就。某种意义上，刷子成就可以算作（最低级的）技巧成就，毕竟它也是“不存在于本体内的附加玩法”，游戏并不强制要求玩家刷到这么多钱或击倒这么多敌人。玩梗成就：其获得难度往往不高，但是解锁条件非常有趣，是开发者玩梗的大好时机。他们玩的梗可能是游戏自身的，也可能是系列前代的，甚至还可能是其他作品的。（友情提示：玩梗虽好玩，可不要贪玩，不然律师函警告送达中） 分类方法2
消极成就：通常情况下，达成某项成就是件无比光荣的事——意味着在某任务、等级或财富等方面达到了显著甚至是显赫的程度。但玩家也会有被喝倒彩的时候，所以就有了一些不是那么光彩的成就——某方面表现差到一“系统认可”的程度的玩家得到这类成就。金钱成就：即获得的成就可以当成虚拟金钱在游戏中通行。这种金钱可以表现为点数、金币或星级等，玩家可以用来购买游戏中的虚拟商品或者现实中的商品。挑战成就：达成条件是玩家完成一连串小任务单元——这些单元任务本身是附属于同一个完整的大任务，只是各个小任务难度递增。超级成就：达成要求是玩家完成不同任务中的一系列成就。竞技成就：达成前提是一个玩家与另一个玩家的直接对抗（PK）或间接对抗（单一任务得分）。这类成就可以是个人达成（单挑），也可以是团队达成（群殴）。合作成就：是玩家要在游戏中通力配合完成一个共同目标。这种类型的成就在多人游戏中最为普遍，因为在多人游戏中，玩家产生互动的时候更多。 现实用于自身学习的实践上： 阶段性反馈机制
反复的告诉自己只有努力达到XXX才能得到XXX，只要努力XXX就一定能得到XXX。每完成一个小目标就给自己一个小小的奖励：看场电影、买一套新衣服、换一个手机、换一个mac、说走就走的旅行，你能想到的自己想要的、能满足自己欲望的，但是平时又不敢或者不舍得且来之不易的东西。将自己的学习量化，公开化。比如在知乎上写写技术文章、发下自己制作成功的作品等在工作中，以每一个问题为目标，每解决一个问题给自己及时反馈，不仅自我提升。 阶段性、强制性计划
制作可行的、短期的计划、具体的计划计划没有完成，熬夜也要完成，不要拖泥带水，这样第二天为了避免熬夜就会更加努力，形成良性循环。如果第二天很努力了还是需要熬夜完成，就需要调整计划了。制作奖励作废时间限制 静下心来，全身心的投入进去，发自内心的喜欢它，热爱它，渴望它，真真切切的享受它。
推荐文章：
游戏奖励如何让玩家投入更多游戏时间-腾讯游戏学堂 (tencent.com)
游戏心理学研究汇总：适用于游戏设计中的72个心理学效应理论（5万字长文慎入！）（完成于2018.1.13） - 知乎 (zhihu.com)
暴雪高人上课：如何设计游戏里的奖励系统？ | 游戏大观 | GameLook.com.cn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb5a5972ee6fbee1e566bfb6f26dec9/" rel="bookmark">
			Centos7 使用Jexus 部署 ASP.NET Core MVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7 使用Jexus 部署 ASP.NET Core MVC
Centos7 使用Jexus 部署 ASP.NET Core MVC 安装.NET Core SDK .NET Core是.NET的跨平台版本，用于构建网站，服务和控制台应用程序。
下载.net core sdk 在微软官网下载安装 https://dotnet.microsoft.com/download
2. 安装 .NET Core SDK
1)复制命令在Linux终端上安装 sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm sudo yum update sudo yum install dotnet-sdk-2.2 2)我们可以使用命令查看是否安装成功
dotnet --V 这个命令我们可以查看到sdk 一些相关信息之类的
3.安装Jexus
1)什么是Jexus?
Jexus是一款Linux平台上的高性能WEB服务器和负载均衡网关，以支持ASP.NET、ASP.NET CORE、PHP为特色，同时具 备反向代理、入侵检测等重要功能。可以这样说，Jexus是.NET、.NET CORE跨平台的最优秀的宿主服务器，如果我们认为它是Linux平台的IIS，这并不为过，因为，Jexus不但非常快，而且拥有IIS和其它Web服务器所不具备的高度的安全性，这是政府机构和重要企业对web服务器最必要也是最重要的品质需求。
2)我们打开Jexus官网 https://jexus.org/
3)安装的话我们安装官网上推荐的安装,我们安装专业版如图
命令如下
curl https://jexus.org/release/x64/install.sh|sudo sh 安装成功如下图
4.接下来就是我们部署ASP.NET Core了
-我们在终端的目录下任意创建一个文件夹
mkdir /你要创建文件的路径/你要创建文件的路径 把程序的压缩包上传到你创建的文件,我这里是文件夹是在/home/core下,我们用rz命令上传如果我们没有rz命令用安装一下命令如下 yum install lrzsz -y 上传如图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fb5a5972ee6fbee1e566bfb6f26dec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ac82ecd9adad4c7f3115417b615582/" rel="bookmark">
			element-ui 中 Cascader 级联选择器同时获取value值和label值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cascader 级联选择器同时获取value值和label值
&lt;el-cascader :options="options" v-model="selectedOptions" :props="props" size="small" ref="cascaderAddr" filterable @change="handleChange" change-on-select placeholder="请选择分类"/&gt; &lt;script&gt; handleChange(e) { //第1种 var thsAreaCode = this.$refs['cascaderAddr'].currentLabels // 获取label值 console.log(thsAreaCode); // 最终结果是个一维数组对象 //第2种 const checkedNodes = this.$refs['cascaderAddr'].getCheckedNodes() // 获取当前点击的节点 console.log(checkedNodes) console.log(checkedNodes[0].data.label) // 获取当前点击的节点的label console.log(checkedNodes[0].pathLabels) // 获取由 label 组成的数组 }, &lt;/script&gt; vue3 &lt;el-form-item label="文件目录" prop="filePath"&gt; &lt;el-cascader ref="cascaderRef" v-model="form.other" :options="deptOptions" :props="{ value: 'id', label: 'fileName', children: 'children' }" :style="{ width: '100%' }" placeholder="请选择级联选择" @change="getArriveListName" clearable /&gt; &lt;/el-form-item&gt; const cascaderRef = ref([]); function getArriveListName() { form.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4ac82ecd9adad4c7f3115417b615582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9f7731f3ae07a380c8f4927dd0bcdd/" rel="bookmark">
			antd vue form表单校验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种校验方式 使用提交按钮 案例常用，参考案例：表单的基本使用 &lt;a-button type="primary" html-type="submit"&gt;Submit&lt;/a-button&gt; 使用formRef 较为常用，参考案例：自定义校验规则&lt;a-form ref="formRef" :model="modal.formQuery"&gt; import type { FormInstance } from 'ant-design-vue' const formRef = ref&lt;FormInstance&gt;() const testForm = () =&gt; { formRef.value ?.validate(['word']) // 不加参数，会校验全部规则 .then((res) =&gt; { console.log('通过', res) }) .catch((err) =&gt; { console.log('失败', err) }) } // 子组件初始化示例 const init = () =&gt; { formRef.value?.resetFields() // 初始化重置表单 } defineExpose({ getLogisticsTemplateHandle }) // 导出该子组件方法 // 父组件监听方法 &lt;Child ref="childInitRef" @init="childInit" /&gt; import { nextTick } from 'vue' type childTemplate = { init: () =&gt; void } const childInitRef = ref&lt;childTemplate&gt;() // 绑定子组件的ref const childInit = () =&gt; { nextTick(() =&gt; { if (childInitRef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9f7731f3ae07a380c8f4927dd0bcdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fe258f5625b5c7c732f0f1be03cf9fc/" rel="bookmark">
			Apollo 配置中心详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。
服务端基于Spring Boot和Spring Cloud开发，打包后可以直接运行，不需要额外安装Tomcat等应用容器。
Java客户端 不依赖任何框架，能够运行于所有Java运行时环境，同时对Spring/Spring Boot环境也有较好的支持。
.Net客户端 不依赖任何框架，能够运行于所有.Net运行时环境。
官方 GitHub： github.com/ctripcorp/a…
官方 Gitee： gitee.com/nobodyiam/a…
二、安装部署 2.1 环境准备 java： JDK 1.8.+ maven： 3.3.9 mysql： 版本要求（5.6.5+） 查看数据库版本：SHOW VARIABLES WHERE Variable_name = 'version'; Apollo服务端： 1.9+ Apollo客户端： 1.7+
2.2 安装包下载 源码下载 从(Apollo-github) 下载最新的源码，也可以通过 git 命令下载到本地
git clone github.com/ctripcorp/a…
下载安装包 地址：github.com/ctripcorp/a…
注意： 本文中使用的方式为 1.源码下载，进行演示。
2.3 创建数据库 Apollo 服务端总共需要两个数据库：ApolloPortalDB和 ApolloConfigDB
我们可以在下载的源码包里面找到，文件目录为：apollo\scripts\sql，路径如下图所示：
或者通过下载地址来获取SQL
ApolloPortalDB
SQL下载地址：github.com/ctripcorp/a… 导入成功后，验证SQL：select * from `ApolloPortalDB`.`ServerConfig`;
ApolloConfigDB
SQL下载地址：github.com/ctripcorp/a… 导入成功后，验证SQL：select * from `ApolloConfigDB`.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fe258f5625b5c7c732f0f1be03cf9fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218b767656d8c0f57f81c918b4a644b5/" rel="bookmark">
			Lostash同步Mysql数据到Elasticsearch（四）通过kibana辅助查看同步情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kibana常用命令查询索引 在数据同步时，我们需要使用一些常用查询，来确认脚本及索引情况，下面的常用命令可以帮到大家
1.查询几条数据来看看数据同步情况 GET idx_znyg_xxx/_search { "size":10, "query": { "match_all": {} } } 2.索引查询相关 GET idx_znyw_data_gkb_logstash/_mapping //查询索引mapping结构 GET /idx_znyg_datanbqseries/_count //统计数量 GET _template/idx_znyg_datanbqseries //获取模板内容 GET /idx_znyg_sysinfo/_settings //查询索引配置相关 GET _cat/indices?pretty //获取所有索引详细情况 3.关闭打开索引 POST /idx_znyg_datanbqseries/_close POST /idx_znyg_datanbqseries/_open 4.更新索引settings(需要先关闭索引) PUT /idx_znyg_datanbqseries/_settings { "index":{ "number_of_replicas": 2, "max_result_window": 65536, "max_inner_result_window": 10000, "translog.durability": "request", "translog.sync_interval": "3s", "auto_expand_replicas": false, "analysis.analyzer.default.type": "ik_max_word", "analysis.search_analyzer.default.type": "ik_smart", "shard.check_on_startup": false, "codec": "default", "store.type": "niofs" } } 5.删除相关操作 DELETE /idx_znyw_data_gkb_logstash //删除索引 DELETE /_template/idx_znyg_datacn //删除模板 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/218b767656d8c0f57f81c918b4a644b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1185eed61a92be8e7947187d95d7e519/" rel="bookmark">
			css主题切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端主题切换方案 提前加载所有主题样式，切换时修改类名 实现 思路：提前将所有样式文件引入，然后在切换主题是给一个公共的元素添加一个类名，通过样式的层级来覆盖原有颜色相关样式
main.js中提前引入样式文件：
import '@/assets/css/dark.css' import '@/assets/css/green.css' green.css绿色主题css文件：
body.green .content { color: #333; background-color: #c7edcc; } 原来的样式：
.content { color: #333; background-color: #fff; } 切换主题时给公共的元素添加相对应类型来覆盖原有颜色样式：
&lt;button @click="changeStyle('dark')"&gt;切换成黑色主题&lt;/button&gt; &lt;button @click="changeStyle('green')"&gt;切换成绿色主题&lt;/button&gt; changeStyle(color) { document.body.className = color } 优缺点 1》优点
不用重新加载样式文件，在样式切换时不会有卡顿
2》缺点：
首次就加载了所有的主题样式文件，牺牲了一点首屏时间来加载样式
一定要注意优先级的问题，主题切换的样式优先级要高于原有的才能覆盖
不是很灵活，没添加一个主题就要添加一个主题样式文件
link标签动态引入 实现 思路：也和前面一样先写好几套主题样式，然后切换时修改link标签的href属性
document.getElementById('#theme').href = 'green.css' 优缺点 1》优点
实现了按需加载，首屏更好
2》缺点
动态加载样式文件，如果文件过大网络情况不佳的情况下可能会有加载延迟，导致样式切换不流畅
一定要注意优先级的问题，主题切换的样式优先级要高于原有的才能覆盖
不是很灵活，没添加一个主题就要添加一个主题样式文件
CSS变量+类名切换 和第一种方案类似，只不过不用写那么多样式，相当于方案1的优化版
CSS定义变量 –两个短横线用于定义CSS变量
&lt;div class="origin"&gt; 祖先元素 &lt;div class="father"&gt; 父亲 &lt;div class="child"&gt; 儿子 &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1185eed61a92be8e7947187d95d7e519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1fbefde91d84a1078ee243d702d8ca/" rel="bookmark">
			node_fs模块常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fs模块 说明 在Node.js中，使用fs模块来实现所有有关文件及目录的创建、写入及删除操作。在fs模块中，所有的方法都分为同步和异步两种实现。具有sync后缀的方法为同步方法，不具有sync后缀的方法为异步方法。异步方法一般最后一个参数都为callback；同步则直接返回。 Node 遵循错误优先回调 回调函数的第一个参数，必须是错误对象error 如果有错误发生，错误将通过第一个参数error返回；第二个参数作为成功响应的数据，如果没有异常，error会被设为null 常用API 创建 fs.writeFile // 异步 / 同步 // fs.writeFile // 若存在该文件，则会覆盖原有数据，若该文件不存在，则会创建该文件，但不能创建文件夹 fs.writeFile('./index.txt', '只要心中花千树，', err =&gt; { if (err) console.log(err) }) fs.writeFileSync('./index2.txt', '执子之手，') fs.appendFile // fs.appendFile // 若该文件不存在，则会创建该文件写入内容，若存在，则在尾部追加内容 fs.appendFile('./index.txt', '人生何处不逢春', err =&gt; { if (err) console.log(err) }) fs.appendFileSync('./index2.txt', '与子偕老') fs.mkdir // fs.mkdir // 创建文件夹，若文件不存在就创建该文件，若存在就报错 fs.mkdir('./dir', err =&gt; { if (err) console.log(err) }) fs.mkdirSync('./dir2') 删 fs.rm // fs.rm // 存在这样的文件，删除成功，若不存在则会报错 fs.rm('./test.txt', err =&gt; { if (err) console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a1fbefde91d84a1078ee243d702d8ca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/53/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>