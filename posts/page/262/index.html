<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36c53448e47e70784e4b87fdb3590d1/" rel="bookmark">
			java多线程学习之二——多线程的优势和风险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优势：
1、 提高系统的吞吐率。多线程编程使得一个进程中可以有多个并发的操作。例如：一个线程因为I/O操作而处于等待时，其他线程仍然可以执行其操作。
2、 提高响应性。使用多线程编程的情况下，对于GUI软件（桌面应用程序）而言，一个慢的操作并不会导致软件的界面出现被“冻住”的现象而无法响应其他用户的其他操作。
3、 充分利用多核CPU资源。避免资源浪费。
4、 最小化对系统资源的使用。一个进程中的多个线程可以共享其所在进程所申请的资源。
5、 简化程序的结构。
6、多线程是异步的。
风险：
1、 线程安全问题。多个线程共享数据的时候，如果没有采取相应的并发访问措施，那么就会产生数据一致性的问题，如读取脏数据（过期的数据）、丢失更新（更新被覆盖）等。
2、 线程的生命特征问题。代码编写不适当可能导致某些线程一直处于等待其他线程释放锁的状态，即产生了死锁。例如：线程T1拥有锁L1，并试图去获得锁L2，而此时线程T2用户拥有锁L2而试图是获得锁L1，这就导致线程T1和T2一直处于等待对方释放锁而一直又得不到的状态。等等。
3、 上下文切换。多线程编程的必然副产物，增加了系统的消耗，不利于系统的吞吐率。
4、 可靠性。一方面有利于可靠性，例如：某个线程意外终止了，但这并不影响其他线程继续其处理。另一方面，线程是进程的一个组件，它总是存在于特定的进程中的，如果这个进程由于某种原因意外提前终止了，比如某个java进程由于内存泄漏导致JVM崩溃，那么该进程中的所有线程也就随之而无法继续运行。
此外，sonar 检查代码有一类错误就是使用线程安全的类引起的：Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used。同步类Vector, Hashtable, Stack和StringBuffer不应该使用。告诉我们，jdk提供的加锁api需要慎用。
多线程有风险，用之需谨慎！
参考：
《java多线程编程实战指南》黄文海
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e89500b0fed1fd5d8922bcc881a12b/" rel="bookmark">
			树学习（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 一颗哈夫曼树的带权路径长度等于其中所有分支结点的权值之和。（错误）
分析：
树的带权路径长度：定义为树中所有叶结点的带权路径长度之和；（即等于所有结点（叶结点+分支结点）的权值之和，而不是分支结点权值之和）。
一棵树的权，也就是根结点的权，等于叶节点的权值之和。
结点带权路径长度：结点到树根之间的路径长度与该结点上权的乘积。
叶节点：度为0；分支结点：度不为0.
2、 树中结点和图中的顶点就是指数据结构中的数据元素。
3、 M阶B-树的任何一个结点的左右子树的高度都相等。
分析：因为B-树都是树高平衡的，所以任何一个结点的左右子树的高度都是相等的。即所有的叶子结点都要出现在同一层，所以树高相等。因为M阶B-树的任一个结点要么有m个孩子，要么没孩子。
B系列树，包括B树，B*树，B+树，所有叶子结点都在同一层，所以左右子树的高度都相等。
设有一颗3阶B树，如下所示。删除关键字78得到一颗新B树，其最右叶节点所含的关键字是（65）
4、 二叉树结点的左子树深度减去其右子树深度称为该结点的平衡因子。平衡二叉树中任意结点的平衡因子只能是-1、0、1.
5、 设只含根结点的二叉树高度为1，现有一颗高度为h(h&gt;1)的二叉树上只有出度为0和出度为2的结点，此二叉树中所包含的结点数至少为 2h-1.
分析：假设高度为2，根据题意，说明叶节点为2，总计3个结点。假设高度为3，根据题意，至少为5. 所以答案为2h-1.
6、 采用二叉链表作为存储结构，树的前序遍历和其相应的二叉树的前序遍历的结果是一样的。
分析：树的前序遍历对应二叉树的前序遍历，树的后续遍历和二叉树的中序遍历一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5fdc640d0bfe8cc4e9eee153333482b/" rel="bookmark">
			zabbix 自定义脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个脚本的思路，自定义一个key，然后就是通过查看文件 /proc/net/dev 里面的数值，来计算实时网卡流量，其实我算的是一个平均值。分为进和出。如果这个脚本每隔1分钟执行一次，那么算出来的流量值就是1分钟的平均值。最终得到网卡流量趋势图。
客户端操作
# vim /etc/zabbix/zabbix_agentd.conf # UnsafeUserParameters=0 取消注释并修改为1，在下面增加一行
UserParameter=my.net.if[*],/usr/local/sbin/zabbix/net.sh $1 $2
my.net.if[相当于命令名字，他是key
其中UserParameter用来自定义键值，（类似于net.if.in)，自己写的脚本往往会有参数，[*] 表示他有自己的参数，所以需要加[*]，这是固定写法，如果脚本压根就没有什么参数，那么这个就省了。逗号后面就是我们写的脚本的路径了，再后面就是要用到的参数，有几个就写几。如果没有参数，后面的 $1 $2 还有前面的 [*] 就都可以省略。
不足之处：
脚本需要工作中不断的进行改进。
并没有针对每个网卡设定单独的文件，所有网卡使用同一个日志文件
# vim /usr/local/sbin/zabbix/net.sh
#!/bin/bash
eth=$1
io=$2
net_file="/proc/net/dev"
if [ $2 == "in" ]
then
n_new=`grep "$eth" $net_file|awk '{print $2}'`
n_old=`tail -1 /tmp/neti.log`
n=`echo "$n_new-$n_old"|bc`
d_new=`date +%s`
d_old=`tail -2 /tmp/neti.log|head -1`
d=`echo "$d_new-$d_old"|bc`
if_net=`echo "$n/$d"|bc`
echo $if_net
date +%s&gt;&gt;/tmp/neti.log
grep "$eth" $net_file|awk '{print $2}'&gt;&gt;/tmp/neti.log
elif [ $2 == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5fdc640d0bfe8cc4e9eee153333482b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bde1e6894640318c6f188b8eaea0b3d/" rel="bookmark">
			shell 练习题  1-10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell 练习题 1-10
1-10题
1、判断用户名文件的行数是否大于25，如果大于25，提示 row above 25. 一行实现
2、截取系统一分钟的平均负载，只取整数部分
3、截取 ip 地址
4、统计连接状态 established 和 listen 的数量
5、判断用户名文件是否是20行，如果是，输出ok
6、统计 logfile 中每个IP的访问量有多少。
7、继续上一题，找出访问量超过15的IP
8、统计所有进程占用的内存大小，并计算总和。
9、删除文件前五行包含字母的行
10、bash for循环打印下面这句话中字母数不大于6的单词。
Bash also interprets a number of multi-characteroptions.
题目来自阿铭论坛 http://ask.apelearn.com/explore/category-65 答案都有自己去写，当然作为新手难免有考虑不周的地方，如有发现，欢迎指正。
1-10答案
1、if [ `wc -l /etc/passwd |awk '{print $1}'` -gt 25 ]; then echo "rowabove 25"; fi
2、uptime |awk '{print $(NF-2)}' |cut -d. -f1 3、ifconfig |head -n2 |grep Mask|awk '{print $2}'|awk -F ':' '{print $2}'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bde1e6894640318c6f188b8eaea0b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0084fd88da731e54794a4020b5c481/" rel="bookmark">
			手把手 教你 打造 Win 10 好用终端（媲美Mac）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从win 10 Linux子系统发布以来，受到广大技术爱好者的欢迎。网上的很多教程已经可以80%的用来当成原生Linux系统来用。好用的命令行为win 10 操作增加了很多力量，方便快捷很多。但是终端由于cmd powershell 的限制，始终不完美。自己琢磨了一个解决方案，基本接近Ubuntu原生体验。
方法如下：
（1）首先我们需要获得Linux子系统，自行百度方法。
（2）sudo apt install gnome-terminal -y
（3）echo "export DISPLAY=:0.0"&gt;&gt;.bashrc
我们要实现开机自动启动terminal 和Ctrl+Alt+T 启动terminal（模仿Ubuntu快捷键）
将 @echo off
bash -c "export DISPLAY=:0.0;gnome-terminal;sleep 1000000;"
写入terminal.bat 文件 将
createobject("wscript.shell").run "terminal.bat",0
写入run_terminal.vbs 文件
然后将这两个文件放入/windows/system32/中
发送run_termial.vbs 到桌面快捷方式 右键属性设置快捷键
然后安装xming，百度自行解决方法
最后一步了，设置任务计划程序
设置登录时启动xming 操作如上图
然后设置任务计划程序，
这样就实现了开机自动启动terminal 终端，和Ctrl+ALT+T 快捷键启动。
使用中有点小问题，期待微软最终解决呀！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e30a527ff07b00c0eb794a89f6ae80/" rel="bookmark">
			Shell 练习题 41-50，内附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		41、写一个猜数字脚本，当用户输入的数字和预设数字（随机生成一个小于100的数字）一样时，直接退出，否则让用户一直输入，并且提示用户的数字比预设数字大或者小。 42、写脚本，用来实现交换两个文件的文件名 43、找出文件中只有数字的行，grep，sed，awk，shell 任选其一 44、假如服务的输出日志是1.log，我要求每天归档一个，1.log第二天就变成1.log.1，第三天1.log.2, 第四天 1.log.3 一直到1.log.5。 45、写一个实时监控网络流量的脚本，提示： /proc/net/dev 文件显示的数字就是网络总流量，单位是B（字节）。 可以用当前时刻的数字减去上一秒的数字来求出每秒的网络流量。单位根据实际情况显示为KB或者MB。 而实时显示，只能使用while 做死循环，而且显示结果要一直在屏幕的第一行，可以使用clear实现。 46、写一个shell脚本，把192.168.0.0/24网段在线的ip列出来。 47、写一个shell脚本，检查指定的shell脚本是否有语法错误，若有错误，首先显示错误信息，然后提示用户输入q或者Q退出脚本，输入其他内容则直接用vim打开该shell脚本。 48、写一个监控网站的脚本。发现不正常发邮件告警。每分钟检测一次。提示： 使用curl命令检测，根据结果判断。 49、三行变一行， 1 2 3 4 5 6 7 1 2 3 4 5 6 7 50、写一个脚本产生随机3位的数字，并且可以根据用户的输入参数来判断输出几组。 比如，脚本名字为 number3.sh。 执行方法： bash number3.sh 直接产生一组3位数字。 bash number3.sh 10 插上10组3位数字。 思路： 可以使用echo $RANDOM获取一个随机数字，然后再除以10，取余获取0-9随机数字，三次运算获得一组。 41、 #!/bin/bash #Auth: Cityzen Wang #Script: Guess number n=15 while : do read -p "please input a number: " m a=`echo $m | sed 's/[0-9]//g'` if [ -n "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e30a527ff07b00c0eb794a89f6ae80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019152b011e14532893c419791327a64/" rel="bookmark">
			maven:Project build error: Non-resolvable parent POM for model:maven01:0.0.1-SNAPSHOT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
创建maven项目的时候，添加parent标签，报错误：
Project build error: Non-resolvable parent POM for model:maven01:0.0.1-SNAPSHOT: Failure to transfer org.springframework.boot:spring-boot-starter-parent:pom:1.5.3.RELEASE from https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced. Original error: Could not transfer artifact org.springframework.boot:spring-boot-starter-parent:pom:1.5.3.RELEASE from/to central (https://repo.maven.apache.org/maven2): connect timed out and 'parent.relativePath' points at wrong local POM
解决：
maven使用国内代理————阿里镜像
参考博客：http://www.cnblogs.com/littleatp/p/6002289.html
&lt;mirror&gt;
&lt;id&gt;alimaven&lt;/id&gt;
&lt;name&gt;aliyun maven&lt;/name&gt;
&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
&lt;!--&lt;mirrorOf&gt;central&lt;/mirrorOf&gt; --&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019152b011e14532893c419791327a64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdaaddec66c29e0ad32d48e564191b2d/" rel="bookmark">
			Cortex-M的M0，M&#43;，M3，M4，M7几种内核的简单区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cortex-M内核M0，M0+，M3，M4，M7之间的区别
图片来自于www.stmcu.com.cn
high-performance 高性能
Mainstream 主流
Ultra-low-power 低功耗
知识补贴：
之所以ARM公司会把Cortex-M分为这么多系列，主要是针对不同的应用领域；下面详细介绍：
Cortex-M分为：M0，M0+，M3，M4，M7
M0，M0+：基础版本，从图中可以看出来，有过于基础，所以生产不出来高性能的STM32的单片机；
M3：目前最主流的设计内核选型，应用范围广；
M4：比较着M3的内核来说，M4处理器添加了DSP的数据（这里可以认为是浮点数）处理的指令；重点解释一下：对于CPU（不是SOC）来说，运算浮点类型的数据是很麻烦的一件事，在选型的时候，如若用应用的领域需要大量浮点数据的运算的时候，那么就要选择M4的内核，M4会大大提高处理器性能和运算速度，而如果要要处理的浮点数据不多，则可以直接选择M3内核处理器；比如项目是平衡车或者平衡器的时候选择M4比较好；
M7：性能好和功耗高兼具，适合追求极致性能项目；
可以认为：数字越大，性能越高；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd99df5a5ebdd69e3121916d3bf34e0/" rel="bookmark">
			windows下配置并启动Nginx并做本地目录映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看nginx进程
tasklist /fi "imagename eq nginx.exe"，如下显示：
映像名称 PID 会话名 会话# 内存使用
========================= ======== ================ =========== ============
nginx.exe 8944 Console 1 5,128 K
nginx.exe 6712 Console 1 5,556 K
2、nginx常用命令
nginx -s stop 强制关闭 nginx -s quit 安全关闭 nginx -s reload 改变配置文件的时候，重启nginx工作进程，来时配置文件生效 nginx -s reopen 打开日志文件
3、其它
可以通过配置文件开启多个nginx工作进程，但同时只有其中一个nginx工作进程在工作，其他的阻塞等待。
一个nginx工作进程最多同时可以处理1024个连接。
nginx中需要共享内存的cache或者模块无法在windows下正常使用。
不过，nginx官方正在改进，将来nginx会以服务的方式运行，使用 I/O completion ports代替select方法，使多个工作进程能并发工作。
要使用nginx配合php-cgi使用，需要修改环境变量，否则，php-cgi运行一定次数就推出，需要重启，设置PHP_FCGI_MAX_REQUESTS这个变量为0即可。
以上在win7上通过。 4、直接贴出整个配置文件了，红色部分是重点： #user nobody;
worker_processes 1;
error_log logs/error.log;
error_log logs/error.log notice;
error_log logs/error.log info;
pid logs/nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fd99df5a5ebdd69e3121916d3bf34e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b82eb18a9ff3080bbeddcd4b64bdffa/" rel="bookmark">
			Markdown编辑器(Atom,Markdownpad2,Typora)初比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。在win10下安装了3种编辑器（Atom,MarkDownpad2,Typora），其中出现了一些问题，因此做一下简单对比，最后推荐使用Typora。
Atom Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持OS X、Windows和Linux操作系统，支持Node.js所写的插件，并内置由Github提供的Git版本控制系统。 主要总结如下： 功能强大，有大量的插件支持下载，包括格式转换，界面渲染等。Atom将文字代码编辑与预览分开，不支持自动实时更新如果需要转换为pdf格式的功能，需要安装插件如：markdown-pdf或者markdown-templet-pdf，安装速度较慢，而且安装完后可能出现无法识别的name属性等问题，并且插件的安装设置也比较容易出现格式问题，这也是我放弃使用Atom的最主要原因。Markdownpad2 MarkdownPad 是 Windows 平台下一款优秀的 Markdown 编辑器。 支持即时更新，所见即所得，将文字代码编写和预览分开缺点主要是普通版本功能受限制，无法自动保存、转换为pdf格式等。升级专业版正常渠道需要收费，而网上提供的破解码基本都已经无法使用，更进一步破解方法又过于繁琐。这是放弃Markdownpad2的主要原因Typora Typora是一款简洁但功能强大的编辑器，拥有 Windows、macOS 客户端，免费。 最大的特点就是没有预览界面，真正做到所见即所得，让你能够专注于编辑的的内容。不需要安装额外的插件就可以实现文本格式的转换，例如常用的pdf，html,docx，LaTex甚至图片格式(jpg,png)的转换，非常的方便。因此基于其免费，没有预览窗口下即时更新，且在不需要安装插件的情况下快速转换为PDF，图片格式等，我推荐使用Typora。 存在的bug:在保存文档但没有关闭软件的情况下，lock了电脑。由于晚上断电的原因，导致最开始撰写的文档内容全部丢失，而最新写的一部分内容还在。真的很无语，这款软件现在也值得怀疑。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe49f7fc8a5509e21d6080970c51920/" rel="bookmark">
			vue2使用animate css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2使用animate css 先上几个链接 vue插件大集合：awesome-vue vue2插件： vue2-animate：vue2-animate vue2插件vue2-animateDEMO： vue2-animatedemo：vue2-animate-demo
我想用过animatecss的都知道这是一个极其简单而又酷炫的css动画库，但是我想在vue2中使用animatecss却是很麻烦的事。 其实vue的官网上在使用过度的时候就说过和animate配合很好什么的bulabula，但是要是用的话也好麻烦，还要自己根据过度类名的写法写css，或者绑定一堆属性， 但是但是，今天翻awesome-vue的时候正好看到有这么个插件：vue2-animate正好符合我们的需求
vue2-animate 这个插件呢是个纯css库，只是简单地将原来的animate的动画类名写成了可以被vue的过渡标签直接使用的类名了。虽然仅仅是如此就极大地方便了我们的使用。
使用vue2-animate 其实直接看他的github就非常快了 这里简单地复述一遍
安装 安装的方式有很多种 1&gt; 在html文件中直接引用从github上下载的资源
&lt;link rel="stylesheet" href="vue2-animate.min.css"&gt; 2&gt;如果使用webpack并且用对了css-loader可以使用npm 安装 npm安装包依赖
npm install --save vue2-animate 在main.js中引用
require('vue2-animate/dist/vue2-animate.min.css') 或者 import 'vue2-animate/dist/vue2-animate.min.css'; 3&gt;使用less
@import "&lt;PATH_TO_SOURCE&gt;/src/vue2-animate.less"; 4&gt;使用构建器编译
git clone https://github.com/asika32764/vue2-animate.git cd vue2-animate npm install npm run build #Compiled .css files go to the dist folder 使用 1&gt;基本的使用就是在过度元素上使用对应的name属性
&lt;transition-group name="fadeLeft" tag="ul"&gt; &lt;li v-for="item in items" v-bind:key="item"&gt; {{ item }} &lt;/li&gt; &lt;/transition-group&gt; 2&gt;使用不同的载入载出动画 》》》第一种：使用custom-classes-transition,需要在不同的载入载出动画上加-enter和-leave后缀
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fe49f7fc8a5509e21d6080970c51920/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa2c33914523b9f4d2b0a7f5f095859/" rel="bookmark">
			阿里云maven镜像库配置（gradle,maven）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常使用maven远程仓库里jar包的同学，最头疼的事情莫过于加了jar包依赖配置之后，需要漫长的下jar包的过程，因为maven仓库网站是国外网站，速度非常的慢。在国内下好jar包放到本地再加载又过于麻烦。
以前有个oschina的国内maven镜像仓库地址，现在应该是弃用了（害得我也等了半天）现在国内的话主要使用阿里云的maven镜像仓库，速度很快~~~
gradle配置：将原来的mavenCentral()直接替换掉或者放到这个的前面（默认是从上往下寻找，所以要放到mavenCentral的前面，如果加在mavenCentral后面，等同于没加）
repositories { maven {url 'http://maven.aliyun.com/nexus/content/groups/public/'} mavenLocal() mavenCentral() } maven配置：
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 嗖~嗖~嗖~飞一般的速度~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c77d0e7ed538ff4cc003d576e61879/" rel="bookmark">
			knn分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 knn（k近邻）是机器学习比较常用的算法，也是一个比较简单的算法，其工作机制非常简单：给定测试样本，基于某种距离度量找出训练集与其最靠近的k个训练样本，然后基于这k个邻居的信息来进行预测。在分类中，选择这k个样本中出现最多的类别标记作为预测结果；而在回归中，则用这k个样本的平均值作为预测结果。也可以基于距离远近进行加权平均和加权投票，距离越近权重越大。这次基于kaggle上的数字识别器讲解其分类用法。
距离度量 knn中使用的距离一般是欧式距离，但也可以使其它距离，比如更一般的 L p L_p Lp​距离
设特征空间 χ \chi χ是 n n n维实数向量空间 R n R^n Rn， x i , x j ∈ χ , x i = ( x i ( 1 ) , x i ( 2 ) , . . . , x i ( n ) ) T , x j = ( x j ( 1 ) , x j ( 2 ) , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2c77d0e7ed538ff4cc003d576e61879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/963f8b4a981136423ca3d1f156979b5e/" rel="bookmark">
			IE8浏览器Silverlight已被阻止解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IE8浏览器Silverlight已被阻止解决办法如下： 1.下载Silverlight插件，保存到本地，win7以上系统要点击右键“以管理员身份运行”安装Silverlight插件。 2.在IE8浏览器右上角中点击“工具”-“Internet选项”-点击“安全”选项卡。 3.在Internet选项窗体点击“可信站点”-“站点” 4.在可信站点窗体点击取消勾选“对该区域中的所有站点要求服务器验证(https:)”-查看网址是否为web系统服务器地址-确认无误点击“添加”-点击“关闭”-回到Internet选项窗体点击“确定”。 5.刷新浏览器，重新输入web系统网址，即可正常访问。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c9d6ccffddafa412af19e987af8ffa/" rel="bookmark">
			ECMAScript 6学习笔记（一）：展开运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript是ECMAScript的实现和扩展，ES6标准的制定也为JavaScript加入了许多新特性。本文主要记录展开运算符。
展开运算符（spread operator）允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。
展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。不过ES7草案当中已经加入了对象展开运算符特性。
函数调用中使用展开运算符 在以前我们会使用apply方法来将一个数组展开成多个参数：
function test(a, b, c) { } var args = [0, 1, 2]; test.apply(null, args); 如上，我们把args数组当作实参传递给了a,b,c，这边正是利用了Function.prototype.apply的特性。
不过有了ES6，我们就可以更加简洁地来传递数组参数：
function test(a,b,c) { } var args = [0,1,2]; test(...args); 我们使用...展开运算符就可以把args直接传递给test()函数。
数组字面量中使用展开运算符 '' 在ES6的世界中，我们可以直接加一个数组直接合并到另外一个数组当中：
var arr1=['a','b','c']; var arr2=[...arr1,'d','e']; //['a','b','c','d','e'] 展开运算符也可以用在push函数中，可以不用再用apply()函数来合并两个数组：
var arr1=['a','b','c']; var arr2=['d','e']; arr1.push(...arr2); //['a','b','c','d','e'] 用于解构赋值 解构赋值也是ES6中的一个特性，而这个展开运算符可以用于部分情景：
let [arg1,arg2,...arg3] = [1, 2, 3, 4]; arg1 //1 arg2 //2 arg3 //['3','4'] 展开运算符在解构赋值中的作用跟之前的作用看上去是相反的，将多个数组项组合成了一个新数组。
不过要注意，解构赋值中展开运算符只能用在最后：
let [arg1,...arg2,arg3] = [1, 2, 3, 4]; //报错 类数组对象变成数组 展开运算符可以将一个类数组对象变成一个真正的数组对象：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73c9d6ccffddafa412af19e987af8ffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d781fc5074ff783fadeff4fa1f22a70/" rel="bookmark">
			JS数组合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##JS数组合并
方法知识点
Array.concat()
Array.push()
Array.unshift()
Array.reduce()Array.reduceRight()func.apply ####concat
var arrA=[1,2,3], arrB=[a,b,c], arrC; arrC=arrA.concat(arrB);//Concat 合并生成新数组 //[1,2,3,a,b,c] concat合并数组最常见 简单 易掌握 合并生成新数组
####push/unshift
var arrA=[1,2,3], arrB=["a","b","c"]; for(var i=0;i&lt;arrB.length;i++){ arrA.push(arrB[i]); } //arrA [1,2,3,"a","b","c"] push //arrA ["c","b","a",1,2,3]	unshift //arrA ["a","b","c",1,2,3] unshift for(var i=arrB.length-1,i&gt;=0,i--) 不生成新数组 但需要写for循环
####reduce+(push/unshift)
//reduce代替for循环 arrA=arrB.reduce(function(acc,val){ acc.push(val); return acc; },arrA);//[1,2,3,"a","b","c"] //reduceRight() unshift(); **不生成新数组 不需要写for循环 数组方法reduce **
####apply+(push/unshift)
arrA.push.apply(arrA,arrB); //arrA.push("a","b","c"); arrA.unshift.apply(arrA,arrB); //arrA.unshift("a","b","c"); **不生成新数组 不需要写for循环 **
apply 改变push/unshift传参方法
使用apply主要作用是数组传参并没有改变作用域
在不改变原数组的情况下 考虑用concat
在原数组修改改变的情况下 使用后面方法
合并数组之前最好判断
数组大小 将小的向大的合并
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6ed83c765db064358627114edcd464/" rel="bookmark">
			详解Mysql分布式事务XA（跨数据库事务）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发中，为了降低单点压力，通常会根据业务情况进行分表分库，将表分布在不同的库中（库可能分布在不同的机器上）。在这种场景下，事务的提交会变得相对复杂，因为多个节点（库）的存在，可能存在部分节点提交失败的情况，即事务的ACID特性需要在各个不同的数据库实例中保证。比如更新db1库的A表时，必须同步更新db2库的B表，两个更新形成一个事务，要么都成功，要么都失败。 那么我们如何利用mysql实现分布式数据库的事务呢？
Mysql 为我们提供了分布式事务解决方案（https://dev.mysql.com/doc/refman/5.7/en/xa.html 这是mysql5.7的文档） 这里先声明两个概念：
资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource manager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识。 mysql在执行分布式事务（外部XA）的时候，mysql服务器相当于xa事务资源管理器，与mysql链接的客户端相当于事务管理器。
分布式事务原理：分段式提交 分布式事务通常采用2PC协议，全称Two Phase Commitment Protocol。该协议主要为了解决在分布式数据库场景下，所有节点间数据一致性的问题。分布式事务通过2PC协议将提交分成两个阶段：
prepare；commit/rollback 阶段一为准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager报告已准备就绪。 阶段二为提交阶段（commit）。当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。 如下图所示： 事务协调者transaction manager 因为XA 事务是基于两阶段提交协议的，所以需要有一个事务协调者（transaction manager）来保证所有的事务参与者都完成了准备工作(第一阶段)。如果事务协调者（transaction manager）收到所有参与者都准备好的消息，就会通知所有的事务都可以提交了（第二阶段）。MySQL 在这个XA事务中扮演的是参与者的角色，而不是事务协调者（transaction manager）。
Mysql的XA事务分为外部XA和内部XA 外部XA用于跨多MySQL实例的分布式事务，需要应用层作为协调者，通俗的说就是比如我们在PHP中写代码，那么PHP书写的逻辑就是协调者。应用层负责决定提交还是回滚，崩溃时的悬挂事务。MySQL数据库外部XA可以用在分布式数据库代理层，实现对MySQL数据库的分布式事务支持，例如开源的代理工具：网易的DDB，淘宝的TDDL等等。内部XA事务用于同一实例下跨多引擎事务，由Binlog作为协调者，比如在一个存储引擎提交时，需要将提交信息写入二进制日志，这就是一个分布式内部XA事务，只不过二进制日志的参与者是MySQL本身。Binlog作为内部XA的协调者，在binlog中出现的内部xid，在crash recover时，由binlog负责提交。(这是因为，binlog不进行prepare，只进行commit，因此在binlog中出现的内部xid，一定能够保证其在底层各存储引擎中已经完成prepare)。 MySQL XA事务基本语法 XA {START|BEGIN} xid [JOIN|RESUME] 启动xid事务 (xid 必须是一个唯一值; 不支持[JOIN|RESUME]子句) XA END xid [SUSPEND [FOR MIGRATE]] 结束xid事务 ( 不支持[SUSPEND [FOR MIGRATE]] 子句) XA PREPARE xid 准备、预提交xid事务 XA COMMIT xid [ONE PHASE] 提交xid事务 XA ROLLBACK xid 回滚xid事务 XA RECOVER 查看处于PREPARE 阶段的所有事务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6ed83c765db064358627114edcd464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c47e4b48ea53b6f45c2df6d124727f6/" rel="bookmark">
			子进程 post-installation script 返回了错误号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ubuntu上使用apt-get安装软件的时候出现如下错误:
正在设置 nfs-common (1:1.2.2-4ubuntu5) ...
dpkg：处理 nfs-common (--configure)时出错：
子进程 已安装 post-installation 脚本 返回了错误号 10
正在设置 samba-common (2:3.5.8~dfsg-1ubuntu2.3) ...
dpkg：处理 samba-common (--configure)时出错：
子进程 已安装 post-installation 脚本 返回了错误号 10
dpkg：依赖关系问题使得 samba 的配置工作不能继续：
samba 依赖于 samba-common (= 2:3.5.8~dfsg-1ubuntu2.3)；然而：
软件包 samba-common 尚未配置。
dpkg：处理 samba (--configure)时出错：
依赖关系问题 - 仍未被配置
dpkg：依赖关系问题使得 smbclient 的配置工作不能继续：
smbclient 依赖于 samba-common (= 2:3.5.8~dfsg-1ubuntu2.3)；然而：
软件包 samba-common 尚未配置。
dpkg：处理 smbclient (--configure)时出错：
依赖关系问题 - 仍未被配置
因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
由于已经达到 MaxReports 限制，没有写入 apport 报告。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c47e4b48ea53b6f45c2df6d124727f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1c578a57aa101632681cb34ae1f4da/" rel="bookmark">
			比较有特色的slogan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MONO：用有趣的方式看世界
陌陌：总有新奇在身边
携程：携程在手，说走就走
今日头条：你关心的才是头条
爱奇艺视频：悦享品质
微博：随时随地，发现新鲜事
京东：多快好省
in：我的生活in记
简书：创造你的创造
下厨房：唯有爱与美食不可辜负
苹果：think different
王老吉：怕上火喝王老吉
M&amp;M巧克力：只溶在口，不溶在手
益达口香糖：关爱牙齿，更关心你
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e02977a6d24a2fc525836e003e55589/" rel="bookmark">
			visual studio fatal error C1083: 无法打开源文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 背景 同事传过来的工程源文件（c++），在我电脑上出现的问题。 环境：win10 vs2017. 2. 解决 原因是源文件引用了第三方文件，在我这里，路径发生了变化，必须设置文件路径才能重新编译。 首先，把引用的文件包含进来。 右键“解决方案工程名字”的“属性”， 如图，更改包含目录，添加第三方文件夹路径。 若编译仍不成功，还是无法打开。下面用记事本（我用的notepad++)打开后缀名.vcxproj的工程文件，该文件记录工程的相关环境配置信息。 如图：包含的文件即是下面带..\..\的，出错原因即在此。 ..\表示相对当前路径的上一级。工程文件是源根路径。 查看第三方文件的路径，手动修改成正确的。我这里就多了一级，去掉一个..\即可。记得把所有的都改成这样的。 再编译，成功。 总结：第三方文件最好放在工程文件夹里，如果放在其他盘，其他电脑就打开就要重新设置环境。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9d260b483e800044d68430b7d50fcc/" rel="bookmark">
			交换机堆叠和集群配置与管理——1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交换机堆叠和集群是两种可解决单台交换机性能不足、容易出现单点故障问题的交换机管理技术。实现堆叠和集群后的各成员交换机一起可看成一台逻辑交换机系统，可通过一个IP地址进行管理，各成员交换机间还可以实现负载均衡和容错。
华为交换机中堆叠技术为iStack（IntelligentStack，智能堆叠）；集群技术称之为CSS（Cluster Switch System，集群交换机系统）。但不同交换机系列所支持的堆叠或集群连接方式有所不同（有通过专门的堆叠卡或集群卡连接的，有通过普通业务口连接的）。这两种交换机管理技术在工作原理、配制方法和功能支持上存在许多相似性，但iStack堆叠中可以支持的成员交换机更多（对多9台），CSS只支持两台交换机的集群。
iStack基础
交换机堆叠是一种提高端口可用背板带宽，扩展交换机端口，提高可靠性，集中管理多台交换机的技术。
一、iStack概述
在iStack堆叠系统建立前，每台成员交换机都是单独的实体，都有自己独立的IP地址和MAC地址，对外体现为多台交换机。在iStack堆叠系统建立后，堆叠中的所有成员交换机对外体现为一个统一的逻辑实体，用户使用一个IP地址就可以对堆叠中的所有交换机进行管理和维护。
1、交换机角色
在iStack中所有的单台交换机都称为成员交换机，按照各自动能的不同分为以下三种角色：
（1）主交换机。主交换机在堆叠配置文件中显示为Master，负责整个读碟系统的管理。一个交换机堆叠只有一台主交换机。
（2）备交换机。备交换机在堆叠配置文件中显示为Standby，是主交换机的备用交换机，用于当原主交换机出现故障时接替主交换机工作，一个交换机堆叠也只有一台备交换机。
（3）从交换机。从交换机在堆叠配置文件中显示为Slave。除了主交换机外的其他所有交换机（包括备交换机）都是从交换机。
2、堆叠ID
为了便于识别和管理交换机堆叠中各成员交换机，为所有成员交换机（包括主交换机和备交换机）都分配了一个堆叠ID，即成员编号（MemberID）。且每个成员交换机的堆叠ID都是唯一的。
3、堆叠优先级
哪台交换机担当主备交换机角色呢？就要用到堆叠优先级属性了，用于堆叠角色选举过程中确定主交换机和备交换机角色。优先级值越大表示优先级越高。
4、堆叠物理成员端口
指采用普通业务口堆叠连接方式时，各成员交换机上用于堆叠连接的物理业务端口，不是指堆叠卡上的专门堆叠接口。
5、堆叠端口
指采用普通业务口堆叠连接方式时用于堆叠连接的逻辑端口，需要和堆叠物理成员端口绑定，即向逻辑堆叠端口中添加物理成员端口。堆叠的每台成员交换机上支持两个堆叠端口：Stack-Portn/1和Stac-Portn/2，其中n为成员交换机的堆叠ID。
二、iStack特性的产品支持
不同型号交换机之间不能混合堆叠。
1、堆叠主、备交换机选举
堆叠建立时，成员交换机之间相互发送堆叠竞争报文，选举出主、从交换机。当从交换机的VRP系统版本号与主交换机不一致时，从交换机将自动同步主交换机的VRP系统软件版本，复位重启后加入堆叠系统。主交换机收集成员信息并计算堆叠拓扑，然后将堆叠拓扑信息同步到所有的成员交换机。
主交换机选举规则：
（1）首先进行运行状态比较，已经运行的堆叠交换机中最先处于启动状态的交换机将被选举为主交换机。
（2）如果有多台成员交换机都已处于启动状态，则再对这些交换机进行堆叠优先级比较，堆叠优先级高的选举为主交换机。
（3）如果某些成员交换机的堆叠优先级一样，则再对这些成员交换机进行MAC地址比较，MAC地址小的交换机优先选举为主交换机。
备交换机选举规则：
（1）除主交换机外其他各成员交换机中最先处于启动状态的交换机成为备份交换机。
（2）如果有多台除主交换机外的其他交换机同时完成启动时，则这些成员交换机中堆叠优先级最高的交换机成为备交换机。
（3）如果以上这些交换机的堆叠优先级相同，则MAC地址最小的选为备交换机。
2、堆叠连接方式
不同S系列交换机的iStack堆叠连接方式不完全一样。S2700和S3700系列主要支持堆叠卡连接方式，是通过专门的堆叠卡中提供的堆叠端口（也可使用复用上行千兆口作为堆叠端口）和专用的SFP高速堆叠电缆连接的。
S5700和S6700系列支持以下两种堆叠连接方式：
（1）堆叠卡连接：各成员交换机之间通过专用的堆叠卡ETPC和专用的PCI-E堆叠电缆连接。
（2）业务口连接：各成员交换机间通过堆叠端口绑定的堆叠物理成员端口和SFP+高速电缆相连。不需要专用的堆叠插卡。
3、堆叠连接拓扑结构
华为S系列交换机iStack堆叠的连接拓扑结构有“链形连接”和“环形连接”。环形连接拓扑结构是堆叠成员交换机通过堆叠端口交叉端口交叉相连形成一个“环”形结构。
链形结构拓扑结构中处于链两端的交换机只使用一个堆叠端口与邻居交换机相连，最终形成一个“链条”形结构（有点像交换机“级联”）。
环形结构拓扑比链形连接拓扑具有更高的可靠性，因为当链形连接拓扑结构中出现链路故障时会引起堆叠分裂；而当环形连接拓扑结构中某条链路故障时会形成链形连接，整体堆叠的业务不会受到影响。
4、堆叠的管理和维护
iStack堆叠建立后，所有的成员交换机形成一台逻辑交换机存在于网络中，所有成员交换机的资源由堆叠主交换机统一管理。用户可以通过任意一台成员交换机的网管接口或串口登录堆叠系统，对整个堆叠系统进行管理和维护。但同一时刻只能由一个网管接口或串口登录。堆叠后的交换机接口编号为：堆叠ID/子卡号/端口号。
5、堆叠成员加入
在iStack堆叠维护和使用过程中会继续进行拓扑收集工作，当发现有新的成员交换机（已配置了堆叠连接和堆叠功能）加入时会根据新加入交换机的状态采取不同的处理。
（1）如果新加入的交换机本身未形成堆叠，则新加入的交换机会被选为从交换机，堆叠系统中原有主、备角色不变。
（2）如果新加入的交换机本身已经形成了堆叠，此时相当于两个堆叠合并。这种情况下，两个堆叠系统的主交换机将选举出一个更优的交换机作为新堆叠系统的主交换机，其中一个堆叠系统（新主交换机所在堆叠系统）将保持不变，业务也不会受到影响；而另一个堆叠系统的所有交换机将重新启动后加入新堆叠，并将同步主交换机的配置，该堆叠的原有业务也将中断。
6、堆叠成员退出
iStack堆叠成员退出是指成员交换机从堆叠系统中离开，断开堆叠连接。此时会因为退出成员的角色不同对堆叠系统的影响有所不同。
（1）主交换机退出：备交换机升级为主交换机，更新堆叠拓扑结构并指定一个新的备交换机。
（2）备交换机退出：主交换机更新堆叠拓扑结构并指定一个新的备交换机。
（3）从交换机退出：主交换机更新堆叠拓扑结构。
7、堆叠主、备切换和堆叠系统MAC地址切换
当iStack堆叠系统成功建立后，如果主交换机故障或脱离堆叠系统，则备交换机自动升级为主交换机，然后由新的主交换机指定新的备交换机，进行主、备交换机数据同步。这里的堆叠主、备切换，以及堆叠系统MAC地址的切换又要区分3种情况：
（1）当堆叠系统第一次成功建立后，此时堆叠系统的MAC地址是主交换机的MAC地址。当主交换机发生故障或脱离堆叠系统时，在去使能堆叠系统MAC地址延时切换功能的情况下，系统MAC地址会立刻切换为新的主交换机的MAC地址。缺省使能堆叠系统延时切换功能，延时时间为10min。
（2）当堆叠系统成功建立之后，如果主交换机故障或脱离堆叠系统，如果堆叠系统配置了系统MAC地址切换时间，且在切换定时器超时时间内旧主交换机还没有重新加入堆叠系统，则新主交换机将堆叠系统的MAC地址切换为自己的MAC，反之，如果在切换定时器超时时间内旧主交换机重新加入堆叠系统，此时系统旧主交换机变为从交换机，但堆叠系统的MAC地址不切换。相当于，此时堆叠系统的MAC地址为从交换机MAC地址。
（3）当堆叠交换机中有从交换机离开时，如果离开的从交换机的MAC地址是堆叠系统的MAC地址，且该交换机在切换定时器超时时间内没有重新加入堆叠，则主交换机将堆叠系统MAC地址切换为自己的MAC地址。
8、堆叠分裂
iStack堆叠分裂是指稳态运行的堆叠系统中带电移出部分成员交换机，或者堆叠系统线缆多点故障导致一个堆叠系统变成多个堆叠系统。
堆叠系统分裂后，可能产生多个有相同配置的堆叠系统，导致网络中IP地址和MAC地址的冲突，引起网络故障。
9、双主检测
双主检测DAD（Dual-ActiveDetection），是一种检测和处理堆叠分裂的协议，可以实现堆叠分裂的检测、冲突处理和故障恢复，降低堆叠分裂对业务的影响，仅S5700和S6700系列支持，且仅支持由两台交换机组成的堆叠系统。
双主检测方式有两种：直连检测方式和Relay代理检测方式。
（1）直连检测方式：如上图，堆叠成员交换机间通过专用直连链路进行双主检测。在直连检测方式中，堆叠系统正常运行时，为了减轻CPU负担不发送DAD报文；堆叠系统分裂后，堆叠成员交换机以1s为周期通过检测链路发送DAD报文。
（2）Relay代理检测方式。如上图，Relay代理检测方式在堆叠系统跨交换机Eth-trunk上启用DAD检测，在代理交换机上启用DAD代理功能。代理交换机必须为支持DAD Relay代理功能的交换机。
在Relay代理检测方式中，堆叠系统正常运行时堆叠成员交换机以30s为周期通过检测链路发送DAD报文。堆叠成员交换机对在正常工作状态下收到的DAD报文不做任何处理；堆叠系统分裂后，堆叠成员交换机以1s为周期通过检测链路发送DAD报文。
堆叠分裂后，分裂成多部分的堆叠系统会在检测链路上相互发送DAD竞争报文。堆叠系统将接收到的报文信息与本部分竞争信息做比较：如本部分竞争为主交换机则不作处理，保持Active状态，正常转发业务报文；如果本部分竞争为备交换机，则需要关闭除保留端口（交换机上不会被关闭的端口）外的所有业务端口，转入Recovery状态，停止转发业务报文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f9d260b483e800044d68430b7d50fcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef737c80407bdba610b4d28c4fa90c4b/" rel="bookmark">
			org.springframework.beans.factor…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到报错，应该先看错误最后面缺啥类：如报错消息所示，其实是缺乏aopalliance： Exception in thread "main" org.springframework.beans.factory.CannotLoadBeanClassException: Error loading class [aop.aspect.SleepHelper] for bean with name 'sleepHelper' defined in class path resource [configuration/beans.xml]: problem with class file or dependent class; nested exception is java.lang.NoClassDefFoundError: org/aopalliance/aop/Advice at org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory. at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory. at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory. at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory. at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory. at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext. at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext. at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext. at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext. at Main.MainClass.main(MainClass. Caused by: java.lang.NoClassDefFoundError: org/aopalliance/aop/Advice at at at at at at at at java.security.AccessController.doPrivileged(Native Method) at at at sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef737c80407bdba610b4d28c4fa90c4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c50c97fd1305f3635fb2bb34c7c3a83/" rel="bookmark">
			MySQL中的锁（表锁、行锁，共享锁，排它锁，间隙锁）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考： http://mysqlpub.com/thread-5383-1-1.html http://blog.csdn.net/c466254931/article/details/53463596 有很多是转载合并过来。
锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。本章我们着重讨论MySQL锁机制 的特点，常见的锁问题，以及解决MySQL锁问题的一些方法或建议。 Mysql用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。这些锁统称为悲观锁(Pessimistic Lock)。
MySQL锁概述 相对其他数据库而言，MySQL的锁机制比较简单，其最 显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。
MyISAM表锁 MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。 对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！根据如表20-2所示的 例子可以知道，当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。
MyISAM存储引擎的写锁阻塞读例子： 当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。 MyISAM存储引擎的读锁阻塞写例子: 一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。 如何加表锁 MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。在示例中，显式加锁基本上都是为了演示而已，并非必须如此。 给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如， 有一个订单表orders，其中记录有各订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条SQL：
Select sum(total) from orders; Select sum(subtotal) from order_detail; 这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：
Lock tables orders read local, order_detail read local; Select sum(total) from orders; Select sum(subtotal) from order_detail; Unlock tables; 要特别说明以下两点内容： 1、上面的例子在LOCK TABLES时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，在后面还会进一步介绍。 2、在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的 情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c50c97fd1305f3635fb2bb34c7c3a83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88dc408c931e33c43eeea044184343d0/" rel="bookmark">
			loadrunner11录制时events为0的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚安装好的11.0，系统环境是：WIN7+IE8+LR11 正准备录制的时候发现，点击录制后，ie8不会自动弹出，并且events始终显示为0，在网上找了很多解决方法， 如下：可以一一对应去检查： 1、ie去掉工具—internet选项中-&gt;高级—&gt;去掉“启用第三方浏览器扩展”，重启ie后发现还不行，继续； 2、我的电脑—属性—系统属性－高级—性能－数据执行保护中，“为除下列制定程序之外的所有程序和服务启用DEP”，添加loadrunner安装目录中的vugen.exe，这里必须要重启电脑，重启后发现也不行，继续； 3、 在录脚本的那个弹出框里（Internet explorer），替换成IE的8的安装路径，还不行，此方法不可行； 4、loadrunner的runntime_setting中浏览器选项，高级中IE版本问题，默认选择IE4，应该是IE8，改为ie8和win7，重启lr，还是不行； 5、防火墙的问题，立马去试，关掉所有防火墙和杀毒软件，再重启lr。
LoadRunner支持的IE版本： 8.0 最高ie6 8.1 最高ie6 9.0 最高ie7 9.5 最高ie8 11.0 最高ie9( win7 32位+LR11+IE10可用，但win7 64位+LR11+IE10不可用，降至IE9可用) 12.0 支持IE11
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613eaa26d4655267ddd907df2cd75449/" rel="bookmark">
			子窗口与父窗口之间传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例讲述了C#简单实现子窗体向父窗体传值的方法。分享给大家供大家参考。具体如下：
击Form1的button1 打开Form2，再点击Form2的button2。
在button2_Click事件中 通过this.Owner将Form2的textBox2的值设置给Form1的textBox1，并关闭Form2。
public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { Form2 frm2 = new Form2(); frm2.Show(this);//或 frm2.ShowDialog(this); 或者 //Form2 frm2 = new Form2(); //frm2.Owner = this; //frm2.Show();//或 frm2.ShowDialog(); } } public partial class Form2 : Form { public Form2() { InitializeComponent(); } private void button2_Click(object sender, EventArgs e) { Form1 frm1 = (Form1)this.Owner; //注意 如果textBox1是放在panel1中的 则先找panel1 再找textBox1 ((TextBox)frm1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/613eaa26d4655267ddd907df2cd75449/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9958e2cd95d6cf8cbb8efbe2b8f315/" rel="bookmark">
			用mqtt.fx 和 wireshark 深入学习MQTT 协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候协议制定者想把协议写的很清楚很明白，但看文档可能看的没有头绪，更好的办法就是结合协议文档和协议内容来学习 ，先看协议文档 https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html
配置maqq.fx 和 wireshark 可以看到已经连接成功， 再看wireshark 的截包内容 这个时候对着具体协议看文档，对协议的理解则会清晰很多 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca737157dab2a098dc953c6e021dcf10/" rel="bookmark">
			cesiumjs学习笔记之三——cesium-navigation插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件源码地址：https://github.com/alberto-acevedo/cesium-navigation
cesium-navigation cesium-navigation是一个cesium的插件，提供指南针、导航仪和距离刻度用户图形界面。
1、为什么你建立cesium-navigation插件？ 首先，所有的Cesiumjs sdk 不包括罗盘，导航仪（放大/缩小）和距离刻度。您可以使用鼠标在地图上导航，但这个导航插件可为用户提供更多的导航控制和功能。其中一些功能是：将罗盘重置为指向北部，重置轨道，并将视图重置为默认边界。
2、怎么建立cesium-navigation插件？ cesium-navigation插件基于优秀的罗盘，导航仪（放大/缩小）和距离terriajs开源库的距离刻度。来自terriajs的导航UI不能在铯中开箱即用，因为cesium使用带有RequireJS的CommonJS模块，terriajs使用commonjs和Browserify，因此您不能将源文件复制到铯和构建中。cesium-navigation插件的工作包括调整代码在cesium作为插件工作如下：
1) 将所有模块从Browserify转换为requirejs；
2)使用gulpjs来编译和缩小较少的文件，捆绑和最小化所有模块，并将源依赖关系打包成一个文件。作为构建过程的一部分，用almondjs替换requirejs，以减少插件中使用的AMD加载器的占用空间。almondjs库也在插件内绑定，使插件像铯中的即插即用一样简单；
3)使用nodejs和requirejs优化器以及almondjs，整个插件被构建并捆绑在单个文件中，甚至CSS样式也放在这个文件中；
4）该插件可以用作独立脚本或通过AMD加载程序（使用requirejs进行测试）。即使在使用AMD而不是cesium的特殊情况下，插件也可以轻松使用。
3、怎么使用cesium-navigation插件？ cesium-navigation插件有两个版本，一个独立版和一个AMD兼容版本：
1）什么时候用什么版本？ a. 如果您正在加载没有requirejs的铯（即，您有全局变量铯），则使用独立版本。如果您使用requirejs（但不适用于铯），此版本也是适用的。
导入脚本：
&lt;head&gt; &lt;!-- other stuff --&gt; &lt;script src="path/to/Cesium.js"&gt;&lt;/script&gt; &lt;!-- IMPORTANT: because the cesium navigation viewer mixin depends on Cesium be sure to load it after Cesium --&gt; &lt;script src="path/to/standalone/viewerCesiumNavigationMixin.js"&gt;&lt;/script&gt; &lt;!-- other stuff ... --&gt; &lt;/head&gt; 然后扩展viewer： // create a viewer assuming there is a DIV element with id 'cesiumContainer' var cesiumViewer = new Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca737157dab2a098dc953c6e021dcf10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e70718d75ab62b8544614946b2b00b/" rel="bookmark">
			JAVA中的System类常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		System类从我们接触JAVA就一直在用。可能你并不没有意识到。。。 这里简单记录一下几个方法，以后可能会用的到
System.in: 这是个用来监听键盘事件的输入流。。
System.gc(): 调用垃圾回收器，注意，这里的调用不是实时生效的，因为它相当于通知了JVM要调用GC回收器去加回收空间，但GC的什么时间去执行，则由JVM来分配。
System.currentTimeMillis()： 获取自1970-01-01以来现在时间的毫秒数，返回值是Long,此功能可以用来计算程序运行时间、对比时间等功能 示例代码如下：
public static void main(String[] args) { int count = 0; Long startTime = System.currentTimeMillis(); //线程休眠100毫秒 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } Long endTime = System.currentTimeMillis(); System.out.println("程序共耗时："+(endTime-startTime)); } 运行结果为;
程序共耗时：113 System.exit(1): 终止JAVA虚拟机的运行，文档说明：“终止当前正在运行的java虚拟机启动的顺序关闭。这种方法通常不返回。该参数作为状态代码；按惯例，一个非零状态码表示异常终止。”
System.arraycopy(src, srcPos, dest, destPos, length)： 复制数组方法，这个方法偶而会使用，下面为使用方法及参数说明：
public static void main(String[] args) { int[] cs = {1,3,5,4,56,56,57,67,87,8,78,9,8989,89,9,89,89,9}; int[] cs1 = {4,45,645,65,6,45,6}; /* * System.arraycopy参数说明： * 参数一：要复制的数组 * 参数二：要复制的数据起始索引 * 参数三：目标数组 * 参数四：目标数组的起始复制位置 * 参数五：要复制的数组的个数 */ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56e70718d75ab62b8544614946b2b00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478628606b7807d4a4ad2d99a35d64c8/" rel="bookmark">
			Abaqus简单部件受力分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ Abaqus简单部件的受力分析
1.创建一个部件，使用扫描的方式创建，比例为200.
槽钢的扫描草图如下：比例为20
2.得到部件如下图：第二步创建材料
(1)材料属性： 力学 弹性 杨氏模量：260Gpa泊松比:0.3
(2)创建截面，然后指派截面，将材料赋给部件。结果如下图：
3.装配。创建一个，默认就好
4.分析步。创建一个，默认就好。
5.载荷。（1）首先创建边界约束，我们创建两个边界约束，创建过程如下第一二图所示：
（2）加载荷，如下图所示，加在那两个红点上，大小为-20000.
加载荷之后可以看见如下图所示的两个小箭头表示所加的力：
6.划分网格。（1）为部件布种，比例我选择0.3；（2）指派网格控制属性，为四面体；（3）为部件实例划分网格。最终效果如下图所示：
7.作业。创建一个自己的job,提交，软件会自动分析，得到最终结果：
下图是总体位移的变化情况：
下图是平均力的情况：
下图为变化前后的位移对比图：
到此结束。更多的分析后续进行！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0009d8bf9019b3107e8dd98e45951433/" rel="bookmark">
			Java 匹配字符串并按匹配度高低排序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
给定一些字符串，请写一个算法，从中搜索出包含您输入的字符序列的那些字符串，按匹配度的高低排序输出。没有任何一个字符串匹配上，输出-1。
字符串源source 如下：
"AB","ABC","ACB","ABCD","ADBCF","ABDCF","ABDC","ABDFCG","ABDFGC","ABDEFG","GABCEFG"
若输入查找的有序字符序列为"ABC"，则运算结果如下（请注意结果的排序规则）。
ABC （匹配 ABC）(完全匹配上，匹配度最大)
ABCD （匹配 ABC.）
ABDC （匹配 AB.C）
ABDCF （匹配 AB.C.）
ABDFCG （匹配 AB..C.）
ABDFGC （匹配 AB...C）
ADBCF （匹配 A.BC.）
GABCEFG（匹配 .ABC...）
看到这个题目我第一想法就是暴力匹配，因为简单粗暴嘛，先把所有的字符串全部匹配出来，然后再想办法进行排序
输入 您需要查找的字符串
样例输入 ABC
输出 按匹配度高低排序输出查找到的结果。没有任何一个字符串匹配上，输出-1。
样例输出 ABC ABCD ABDC ABDCF ABDFCG ABDFGC ADBCF GABCEFG
然后我考试时，只实现了暴力匹配，匹配后的字符串排序一时间没什么头绪
我去网上参考了下C++，想到了一种方式，用二进制来进行排序
ABC 111111111
ABCD 111011111
GABCEFG 011100011
匹配上就置1，没有匹配上就置0；
思路就是这样，上代码：
public class Test_搜索字符串 { /* 请完成下面这个函数，实现题目要求的功能 */ /* 当然，你也可以不按照下面这个模板来作答，完全按照自己的想法来 ^-^ */ /****************************** 开始写代码 ******************************/ static String[] doFilter(String[] source, String filter) { // 输入字符串转字符数组 char[] charArr = filter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0009d8bf9019b3107e8dd98e45951433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef46260cbc605c550351de1bf7e43a9/" rel="bookmark">
			二级域名绑定二级目录的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当用WordPress建站后，WordPress位于二级目录（/var/www/html/）下，进行域名解析时如何把域名解析到二级目录下，网络上一般有两种方法，一是利用接入商的域名解析服务，二是利用Apache的mod_rewrite功能，下面分别做一下介绍。
一、利用接入商的域名解析服务
将二级目录解析到二级域名去（如：将www.cbblog.cn/WordPress/解析到www.cbblog.cn），该方法操作可见下图。
记录类型选择显性URL或隐性URL，主机记录填你想的二级域名，记录值填写www.cbblog.cn/WordPress/即可
二、使用Apache的mod_rewrite功能
开启mod_rewrite功能
STEP1：打开Apache安装目录/etc/httpd/conf下的httpd.conf文件
STEP2：找到 Load Module rewrite_module modules/mod_rewrite.so 这一行，若其前面有“#”，则将其去掉
STEP3：在httpd.conf文件中查找 AllowOverride None，将其改为 AllowOverride All
至此就开启了mod_rewrite功能，下面讲解如何绑定二级域名
STEP4：在httpd.conf文件末尾添加如下代码
RewriteEngine on RewriteMap lowercase int:tolower RewriteMap vhost txt:/etc/httpd/conf/vhost.map RewriteCond ${lowercase:%{SERVER_NAME}} ^(.+)$ RewriteCond ${vhost:%1} ^(/.*)$ RewriteRule ^/(.*)$ %1/$1 STEP5：在/etc/httpd/conf/目录下新建一个 vhost.map 文件进行二级域名配置，配置代码如下： xxx.cbblog.cn(空格)/项目目录的形式绑定，其中xxx为任意字母组合包括www例如： www.cbblog.cn /var/www/html/wordpress STEP6：重启 Apache （centos下操作为service httpd restart），至此二级域名绑定二级目录就设置好了。 注意：记得备份httpd.conf文件
最终效果
更多问题欢迎访问我的博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd10007f4bdf23f2a7a70614e1c7d45/" rel="bookmark">
			java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file &#34;/data/app/com
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.cj.qv-2/base.apk"],nativeLibraryDirectories=[/data/app/com.cj.qv-2/lib/arm64, /system/fake-libs64, /data/app/com.cj.qv-2/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64, /system/vendor/lib64, /product/lib64]]] couldn't find "libdfs.so" 这个问题困扰了我一上午啊，就是找不到.SO文件,最后才解决 解决一： 首先把在armeabi的同目录下建一个文件夹armeabi-v7a,把armeabi的文件copy一份到armeabi-v7a，build一下项目。 如果还不行把armeabi文件删了，删了还不行如下 解决二： 在build.gradle加了下面的代码 defaultConfig { 。。。 ndk { abiFilters "armeabi", "armeabi-v7a", "x86", "mips" } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05fda7900f4317a3faf9f9fd236cb3a/" rel="bookmark">
			Android FDE 加密过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Full Disk EncryptionSettings中加密入口调用关系加密实现参考 Vold propertiesinit propertiesinit actions Android Full Disk Encryption FDE是android设备全盘加密的简称；主要用于对Android设备userdata分区数据的加密，以实现数据保护的目的
FDE是什么 FDE是Full Disk Encrypt的缩写 保护/data 分区数据参考google的官方介绍(需要访问google网络） encryption一种保护user data的机制。例如：联系人，图片，视频等等截止当前，Android支持加密userdata分区的数据以及不可移除sdcard的数据不支持其他分区的加密FDE如何工作 基于android kernel的dm-crypt feature 实现128 Advanced Encryption Standard(AES) with cipher-block chaining(CBD)and ESSIV:SHA256Android5.0之后，首次开机会加密加密之后，将/data挂在到dm的虚拟节点上首次启动 fstab.qcom 标志 encryptable manually encryptfoeceencrypted encrypt in fist boot使用默认的密码获得master key 默认密码是”default_password”Keymaster(HW/SW) general key blob,存储在footer中default_password_salt(random)–&gt;scrypt–&gt;derived keyDerived+keypair–&gt;sign–&gt;intermedia key(ikey)salt,keybob,derived key stored in footerset ikey to TZHardware Crypto TZ generates an encrypt key derived from new password,set to crypto engineeSoftware Crypto Call APU to set key with ikey(security_hw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a05fda7900f4317a3faf9f9fd236cb3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4cb98783b57c989aa0b22910bf80fb5/" rel="bookmark">
			几张图轻松理解String.intern()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在翻《深入理解Java虚拟机》的书时，又看到了2-7的 String.intern()返回引用的测试。 其实要搞明白String.intern()，我总结了下面几条规则： 一、new String都是在堆上创建字符串对象。当调用 intern() 方法时，编译器会将字符串添加到常量池中（stringTable维护），并返回指向该常量的引用。 二、通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。 三、常量字符串的“+”操作，编译阶段直接会合成为一个字符串。如string str=”JA”+”VA”，在编译阶段会直接合并成语句String str=”JAVA”，于是会去常量池中查找是否存在”JAVA”,从而进行创建或引用。
四、对于final字段，编译期直接进行了常量替换（而对于非final字段则是在运行期进行赋值处理的）。 final String str1=”ja”; final String str2=”va”; String str3=str1+str2; 在编译时，直接替换成了String str3=”ja”+”va”，根据第三条规则，再次替换成String str3=”JAVA”
五、常量字符串和变量拼接时（如：String str3=baseStr + “01”;）会调用stringBuilder.append()在堆上创建新的对象。
六、JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。 举例说明：
String str2 = new String("str")+new String("01"); str2.intern(); String str1 = "str01"; System.out.println(str2==str1); 在JDK 1.7下，当执行str2.intern();时，因为常量池中没有“str01”这个字符串，所以会在常量池中生成一个对堆中的“str01”的引用(注意这里是引用 ，就是这个区别于JDK 1.6的地方。在JDK1.6下是生成原字符串的拷贝)，而在进行String str1 = “str01”;字面量赋值的时候，常量池中已经存在一个引用，所以直接返回了该引用，因此str1和str2都指向堆中的同一个字符串，返回true。
String str2 = new String("str")+new String("01"); String str1 = "str01"; str2.intern(); System.out.println(str2==str1); 将中间两行调换位置以后，因为在进行字面量赋值（String str1 = “str01″）的时候，常量池中不存在，所以str1指向的常量池中的位置，而str2指向的是堆中的对象，再进行intern方法时，对str1和str2已经没有影响了，所以返回false。
常见试题解答 有了对以上的知识的了解，我们现在再来看常见的面试或笔试题就很简单了： Q：下列程序的输出结果： String s1 = “abc”; String s2 = “abc”; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4cb98783b57c989aa0b22910bf80fb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1640a51ea4d8bf316225aeabd60972f7/" rel="bookmark">
			EventBus3.0源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述： 在项目中，我们大多数开发者可能都使用过EventBus,即使没有使用过但我可以确定Android开发者也听说过这个牛X的库，从诞生到目前EventBus已经更新到3.X版本，可见生命力极强呀。那么这篇博文就从EventBus3.0源码的角度分析一下其内部处理流程。
使用流程： 注册：
EventBus.getDefault().register(obj) 订阅(消息接收)： @Subscribe public void receive(Object event){ } 发布消息： EventBus.getDefault().post(event) 注销： EventBus.getDefault().unregister(obj) 源码分析： 注册： EventBus.getDefault().register(obj) 这段代码做了两件事情：① EventBus.getDefault() 创建EventBus对象；② register(obj) 方法为obj该类对象注册EventBus。 那这两个方法究竟在EventBus中究竟做了哪些工作呢？我们打开EventBus的源码看一下:
1、EventBus.getDefault() 源码如下： public static EventBus getDefault() { if (defaultInstance == null) { synchronized (EventBus.class) { if (defaultInstance == null) { defaultInstance = new EventBus(); } } } return defaultInstance; } 看到了吧，EventBus采用单例模式创建EventBus对象，接下来它在构造方法中又做了什么事情呢？ public EventBus() { this(DEFAULT_BUILDER); } 在构造方法中其调用了有参构造方法：EventBus(EventBusBuilder builder )，我们再跟进去看一看： EventBus(EventBusBuilder builder) { subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1640a51ea4d8bf316225aeabd60972f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af61622dfde079fbc5e3d8e356e65fd7/" rel="bookmark">
			计算一张100px*100px的图片在内存中会占用多大内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际开发当中我们经常会忽视如题问题，只是知道图片越小越好，甚至根本不知道如何计算，今天笔者就抛砖引玉一把！
Android中一张图片（Bitmap）占用的内存主要和以下几个因数有关：图片长度，图片宽度，单位像素占用的字节数。 计算方法：一张图片（Bitmap）占用的内存=图片长度*图片宽度*单位像素占用的字节数 长度和宽度不用多做解释 ，单位是像素；关键是单位像素占用的字节数如何获得呢？ 这里不得不提一下Bitmap创建的API Bitmap bitmap = BitmapFactory.decodeResource(Resources res,int id, BitmapFactory.Options opts); 单位像素占用的字节数由其参数BitmapFactory.Options的inPreferredConfig变量决定,默认为Bitmap.Config.ARGB_8888 inPreferredConfig为Bitmap.Config类型， Bitmap.Config 类是个枚举类型，它可以为以下值 ALPHA_8Each pixel is stored as a single translucency (alpha) channel. This is very useful to efficiently store masks for instance. No color information is stored. With this configuration, each pixel requires 1 byte of memory.此时图片只有alpha值，没有RGB值，一个像素占用1个字节ARGB_4444This field is deprecated. Because of the poor quality of this configuration, it is advised to use ARGB_8888instead.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af61622dfde079fbc5e3d8e356e65fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afe9f3a27290439cc1fc4f3d12e500b/" rel="bookmark">
			Altium Designer 16 导线、焊盘报错 Clearance Constraint、Short-Circuit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个产品升级改造的项目，需要把老产品的51换成STM32。在更改电路设计时遇到一个奇怪的报错现象。采用的绘图软件是最新版的Altium Designer16.1。在更改完善原理图后，把原理图的更改导入到PCB文件中后，把生成的ROOM删除后， PCB中几乎所有焊盘、过孔和导线还是呈现报错的亮绿色。如下图所示，一个焊盘竟然还显示ClearanceConstraint的错误。这太匪夷所思了。
刚开始以为是布线的影响，把所有的布线全部Un-Route之后，还是满屏绿油油。接着进行规则检查，吓了一跳，一点布线都没有，竟然出现10839处Short-Circuit以及12528处ClearanceConstraint。真是太奇怪了。
把鼠标静置在一个固定孔上，竟然出现满屏的错误。
直觉告诉我，这些焊盘、过孔全部都粉身碎骨然后还上下层全部黏连在一起，不然仅仅一个没布线的固定孔能够出现这么多错误。而造成这一现象的原因很可能是文件内容损坏，或者文件格式冲突。由于之前PCB采用protel 99se设计，而我采用的是Altium Designer16.1，之间隔着N多版本，以前的PCB文件就像穿越一样，和现在的版本格格不入。
针对上边的分析，新建了一个PCB文件。由于个人比较懒，不想完全重新设计，于是把老版本PCB文件全选之后复制粘贴到新建的PCB文件里。然后上边的报错问题就解决了。
按道理讲新版本软件应该兼容老版本软件设计的文件，以前采用的 DXP2004以及Altium Designer 6.9等均能很好的支持protel 99se版本的文件。但是这次却出现了了这样的问题，不知道是偶然现象，还是说Altium Designer16.1和protel 99se确实相差太多版本，导致兼容性不好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d61bba1c47af7f238dab3e081e2c7df/" rel="bookmark">
			Python中操作mysql的pymysql模块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
pymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。但目前pymysql支持python3.x而后者不支持3.x版本。
本文测试python版本：2.7.11。mysql版本：5.6.24
一、安装
pip3 install pymysql 二、使用操作
1、执行SQL
#!/usr/bin/env pytho # -*- coding:utf-8 -*- import pymysql # 创建连接 conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1', charset='utf8') # 创建游标 cursor = conn.cursor() # 执行SQL，并返回收影响行数 effect_row = cursor.execute("select * from tb7") # 执行SQL，并返回受影响行数 #effect_row = cursor.execute("update tb7 set pass = '123' where nid = %s", (11,)) # 执行SQL，并返回受影响行数,执行多次 #effect_row = cursor.executemany("insert into tb7(user,pass,licnese)values(%s,%s,%s)", [("u1","u1pass","11111"),("u2","u2pass","22222")]) # 提交，不然无法保存新建或者修改的数据 conn.commit() # 关闭游标 cursor.close() # 关闭连接 conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d61bba1c47af7f238dab3e081e2c7df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e13db6f6b502a65df17cdd0c066fa41/" rel="bookmark">
			微信素材上传返回提示 &#34;errcode&#34;:41005的原因以及以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：个人的php自学视频
来源：微信素材上传返回提示 "errcode":41005的原因以及以及解决方案
【原因】：由于不同php版本导致curl方法用法有所改变导致的， 【解决方案】：将自己即将要进行微信请求的数据适当处理一下，如下： 例如未处理的数据如下
$data=array( 'media'=&gt;'@'.'自己的文件路径' ); 上面的格式微信官方文档也是这样的写的，但是如果你php版本&gt;=5.6后，这种写法就会导致文件无法进行上传到微信服务器 最保险的做法如下(兼容所有php版本)，将上面的数组作如下处理 if (class_exists('\CURLFile')) { $data['media'] = new \CURLFile(realpath($file_path)); } else { $data['media'] = '@'.realpath($file_path); } 【为什么要这么做？】: 详细原因见这：微信素材上传返回提示 "errcode":41005的原因以及以及解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c54747d531a2790f9c3724ffc6b5bb/" rel="bookmark">
			node.js之基础加密算法模块crypto
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密算法crypto 我很难想象在php里面md5加密只是三个字符的一个方法而已，在node.js中没封装前竟然那么长！！
无法反编译的加密方式 话不多说直接上代码品鉴吧
onst crypto = require('crypto'); function l(param) { console.log(param); } const md5 = crypto.createHash('md5');//创建一个md5 hash算法 md5.update('aa');//添加要转化的值 md5.update('cc');//与前面的要转化的值进行拼接 l(md5.digest('hex'));//打印16进制的密文， const sha1 = crypto.createHash('sha1');//创建一个sh1 hash算法 sha1.update('bbbb'); l(sha1.digest('hex')); const hmac = crypto.createHmac('md5', 'key');//创建一个带秘钥的sha1或者md5算法 hmac.update('aacc'); l(hmac.digest('hex')); 最后的输出为 aa794f68b4f6ae5e590e9ed34e94d639 8aed1322e5450badb078e1fb60a817a1df25a2ca b03d8471e2c5f212289c3e2dcb95bd47 真真的输出了一堆16进制的字符但是简单生成个密文看来是很麻烦了。 一般用于密码的存储和登录注册之类的业务
可以反编译的加密算法 //AES 对称加密算法的一种。 //创建加密算法 function aesEncode(data, key) { const cipher = crypto.createCipher('aes192', key); var crypted = cipher.update(data, 'utf8', 'hex'); crypted += cipher.final('hex'); return crypted; } //创建解密算法 function aesDecode(encrypted, key) { const decipher = crypto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c54747d531a2790f9c3724ffc6b5bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e68ff36037e0817bcb4270d647d87a/" rel="bookmark">
			linux下还原oracle数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需要切换到oracle用户
命令：su – oracle
2.输入连接数据库命令：sqlplus /nolog
SQL&gt;conn /as sysdba
Connected
SQL&gt; 3.删除重复无用的表空间及用户
（1）查看用户和默认表空间的关系。 select username,default_tablespace from dba_users;
（2）删除用户名 SQL&gt;drop user megaeyes cascade;
（3）删除表空间
SQL&gt;drop tablespace megaeyes including contents and datafiles cascade constraints;
SQL&gt;exit
4.再创建一个表空间（如：表空间名称为megaeyes;用户名megaeyes;密码megaeyes步骤省略）
注意：创建表空间时表空间名称要与现网数据库表空间名称一致，若不一致还原数据库时会失败
4.将deyangexp-15_07_21.dmp文件放到/home目录下
切换到oracle用户
执行命令还原数据命令： imp megaeyes/megaeyes file=/home/deyangexp-15_07_21.dmp fromuser=megaeyes touser=megaeyes constraints=y rows=y buffer=10240000 log=/home/oracle/EHOMEMOBILE_20140612_exp.dmp
megaeyes/megaeyes：为表空间的用户名/密码
deyangexp-15_07_21.dmp：为文件名称
fromuser=megaeyes：为deyangexp-15_07_21.dmp文件中表空间名称
touser=megaeyes：为表空间名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98f086cd0eb375e59db9f7327158759/" rel="bookmark">
			OpenCV入门十：静态图片人脸检测和摄像头人脸检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好
void CascadeClassifier::detectMultiScale(InputArray image, vector&lt;Rect&gt;&amp; objects, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size()) 总共有7个参数，分别是
第一个参数image: 要检测的图片，一般为灰度图
第二个参数objects: Rect型的容器，存放所有检测出的人脸，每个人脸是一个矩形
第三个参数scaleFactor: 缩放因子，对图片进行缩放，默认为1.1
第四个参数minNeighbors： 最小邻居数，默认为3
第五个参数flags: 兼容老版本的一个参数，在3.0版本中没用处。默认为0
第六个参数minSize: 最小尺寸，检测出的人脸最小尺寸
第七个参数maxSize： 最大尺寸，检测出的人脸最大尺寸
（1）静态图片上的人脸检测
#include "opencv2/core/core.hpp" #include "opencv2/objdetect/objdetect.hpp" #include "opencv2/highgui/highgui.hpp" #include "opencv2/imgproc/imgproc.hpp" #include &lt;iostream&gt; #include &lt;stdio.h&gt; using namespace std; using namespace cv; string face_cascade_name = "D:\\Program Files\\opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_default.xml"; CascadeClassifier face_cascade; void detectAndDisplay( Mat frame ); int main( int argc, char** argv ){ Mat image; image =imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98f086cd0eb375e59db9f7327158759/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c602aac3bd093033605d7c3db66828/" rel="bookmark">
			Unity中不用自带重力实现跳跃的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码分为三部分：
Update()中的输入判定代码LateUpdate()中的跳跃实现部分OnCollisionEnter()与OnCollisionExit()的落地&amp;离地检测部分 当玩家按下跳跃键时进入跳跃状态并判断当前的水平速度
//跳跃判定 if (Input.GetButtonDown("Jump") &amp;&amp;nextJump) //不能在落地前跳跃 if (currentBaseState.fullPathHash == walkingState|| currentBaseState.fullPathHash == runningState|| currentBaseState.fullPathHash == standingState)//不能在动画完成前跳跃 { nextJump = false;//落地前无法再次起跳 GameManager.isJumping = true;//进入跳跃状态 if (GameManager.isStanding) { jumpV_x = 0;//处于站立状态时水平初速度为0 GameManager.isStanding = false;//改变当前状态由站立到跳跃，下同 } if (GameManager.isWalking) { jumpV_x = Haxis * moveSpeed; GameManager.isWalking = false; } if (GameManager.isRunning) //加速跳跃 { jumpV_x = Haxis * moveSpeed; jumpVelocity = GameManager.jumpVelocity * GameManager.jumpMultiple;//加速跳跃时竖向分速度也提高 GameManager.isRunning = false; } } 当跳跃状态==true时每帧移动相应的竖向，水平距离
private void LateUpdate() { transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c602aac3bd093033605d7c3db66828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f7b091c50eb0a534b600b4bfdf26e9/" rel="bookmark">
			【解决】CentOS7 安装 jkd1.8 报错-bash: /usr/local/jdk1.8.0_121/bin/java: /lib/ld-linux.so.2: bad ELF interpr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CentOS 7 尝试安装 jkd 1.8.0_121
#java -version 操作报错
-bash: /usr/local/jdk1.8.0_121/bin/java: /lib/ld-linux.so.2: bad ELF interpr
原因：下载jkd版本不对，centos7 只有64位的，所以jdk 也要下载相应的版本。
http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
下载 Linuxx64 的 tar.gz 版本即可解决。
Linux x64174.76 MB jdk-8u121-linux-x64.tar.gz 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0193e873e53d17928f2857cc271d91/" rel="bookmark">
			Html5使用history对象history.pushState()和history.replaceState()方法添加和修改浏览历史记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：https://www.studyscript.com/Post/index/id/3018.html?page=3
正文~
概述
浏览器窗口有一个history对象，用来保存浏览历史。
如果当前窗口先后访问了三个网址，那么history对象就包括三项，history.length属性等于3。
history.length // 3
history对象提供了一系列方法，允许在浏览历史之间移动。
back()：移动到上一个访问页面，等同于浏览器的后退键。
forward()：移动到下一个访问页面，等同于浏览器的前进键。
go()：接受一个整数作为参数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1)相当于back()。
history.back();
history.forward();
history.go(-2);
如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是默默的失败。
history.go(0)相当于刷新当前页面。
history.go(0);
常见的“返回上一页”链接，代码如下。
document.getElementById('backLink').onclick = function () {
window.history.back();
}
注意，返回上一页时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。
history.pushState()
HTML5为history对象添加了两个新方法，history.pushState()和history.replaceState()，用来在浏览历史中添加和修改记录。
if (!!(window.history &amp;&amp; history.pushState)){
// 支持History API
} else {
// 不支持
}
上面代码可以用来检查，当前浏览器是否支持History API。如果不支持的话，可以考虑使用Polyfill库History.js。
history.pushState方法接受三个参数，依次为：
state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。
title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。
url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。
假定当前网址是example.com/1.html，我们使用pushState方法在浏览记录（history对象）中添加一个新记录。
var stateObj = { foo: 'bar' };
history.pushState(stateObj, 'page 2', '2.html');
添加上面这个新记录后，浏览器地址栏立刻显示example.com/2.html，但并不会跳转到2.html，甚至也不会检查2.html是否存在，它只是成为浏览历史中的最新记录。假定这时你访问了google.com，然后点击了倒退按钮，页面的url将显示2.html，但是内容还是原来的1.html。你再点击一次倒退按钮，url将显示1.html，内容不变。
总之，pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应。
如果pushState的url参数，设置了一个新的锚点值（即hash），并不会触发hashchange事件。如果设置了一个跨域网址，则会报错。
// 报错
history.pushState(null, null, 'https://twitter.com/hello');
上面代码中，pushState想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f0193e873e53d17928f2857cc271d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d14ab22e62ea201d54c23b623c196b/" rel="bookmark">
			后缀自动机详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原论文（俄文）地址：suffix_automata
后缀自动机
后缀自动机（单词的有向无环图）——是一种强有力的数据结构，让你能够解决许多字符串问题。
例如，使用后缀自动机可以在某一字符串中搜索另一字符串的所有出现位置，或者计算不同子串的个数——这都能在线性
时间内解决。
直觉上，后缀自动机可以被理解为所有子串的简明信息。一个重要的事实是，后缀自动机以压缩后的形式包含了一个长度
为n的字符串的所有信息，仅需要O(n)的空间。并且，它能在O(n)时间内被构造（如果我们将字母表的大小k视作常数，否则就
是O(n*logk)）。
历史上，Blumer等人于1983年首次提出了后缀自动机的线性规模，然后在1985-1986年，人们提出了首个线性时间内构建
后缀自动机的算法（Crochemore，Blumer等）。在文末链接处查看更多细节。
后缀自动机在英文中被称作“suffix automaton”（复数形式：suffix automata），单词的有向无环图——"direcged acyclic
word graph"（简写为“DAWG”）。
后缀自动机的定义
定义.对给定字符串s的后缀自动机是一个最小化确定有限状态自动机，它能够接收字符串s的所有后缀。
下面解释这一定义：
· 后缀自动机是一张有向无环图，其中顶点是状态，而边代表了状态之间的转移。
· 某一状态t_0被称作初始状态，由它能够到达其余所有状态。
· 自动机中的所有转移——即有向边——都被某种符号标记。从某一状态出发的诸转移必须拥有不同的标记。（另一方面，
状态转移不能在任何字符上）。
· 一个或多个状态被标记为终止状态。如果我们从初始状态t_0经由任意路径走到某一终止状态，并顺序写出所有经过边的
标记，你得到的字符串必然是s的某一后缀。
· 在符合上述诸条件的所有自动机中，后缀自动机有这最少的顶点数。（后缀自动机并不被要求拥有最少的边数）
后缀自动机的最简性质
最简性——后缀自动机的最重要性质是：它包含了所有s的子串的信息。换言之，对于任意从初始状态t_0出发的路径，如果我们
写出所经过边上的标记，形成的子串必须是s的子串。相应地，s的任意子串都对应一条从初始状态t_0出发的路径。
为了简化说明，我们称子串“匹配”了从初始状态出发的路径，如果该路径上的边标记组成了这一子串。相应地，我们称任意路径
“匹配”某一子串，该子串由路径中边的标记组成。
后缀自动机的每个状态都引领一条或多条从初始状态出发的路径。我们称这个状态有若干匹配这些路径的方法。
构建后缀自动机的实例
下面给出一些对简单的字符串构建后缀自动机的例子。
初始状态被记作t0，终止状态用星号(*)标记。
s=""
s="a"
s="aa"
s="ab"
s="aba"
s="abb"
s="abbb"
一个线性时间构建后缀自动机的算法
在我们描述构建算法之前，有必要介绍一些新的概念和简要的证明，它们对理解后缀自动机的概念十分重要。
结束位置endpos，它们的性质及与后缀自动机的联系：
考虑字符串s的任意非空子串t。我们称终点集合endpos(t)为：s中所有是t出现位置终点的集合。
我们称两个子串t_1和t_2“终点等价”，如果它们的终点集合一致：endpos(t_1)=endpos(t_2)。因此，所有s的非空子串可
以根据终点等价性分成若干类。
事实上对后缀自动机，终点等价字符串仍然保持相同性质。换句话说，后缀自动机中状态数等价于所有子串的终点等价类
个数，加上初始状态。每个状态对应一个或多个拥有相同终点集合的子串。
我们将这一陈述作为假定，然后描述一个基于此假设的，线性时间构建后缀自动机的算法——正如我们不久后将会看到的，
所有后缀自动机的必须性质，除最小性（即最少顶点数），都将被满足（最小性由Nerode产生，见参考文献）。
关于终点集合，我们给出一些简单但重要的事实。
引理1.两个非空子串u和v（length(u)&lt;=length(v)）是终点等价的，当且仅当u在字符串s中仅作为v的后缀出现。
证明是显然的。
引理2.考虑两个非空子集u,w（length(u)&lt;=length(w)）。它们的终点集合不相交，或者endpos(w)是endpos(u)的子集。进一
步地，这取决于u是否是w的后缀：
证明.假设两个集合endpos(u)和endpos(w)有至少一个公共元素，这就意味着字符串w和u在同一位置结束，即u是w的后缀。
因此，在字符串w的每次出现的终点u都会出现，这就意味着endpos(w)包含于endpos(u)。
引理3.考虑一个终点等价类。将该等价类中的子串按长度递减排序。排序后的序列中，每个子串将比上一个子串短，从而是
上一个字串的后缀。换句话说，某一终点等价类中的字符串互为后缀，它们的长度依次取区间[x,y]内的所有数。
证明.考虑这个终点等价类。如果它只包含一个子串，那么引理3的正确性显然。假设现在子串的个数多于一个。
根据引理1，两个不同的终点等价子串总满足一个是另一个的严格后缀。因此，在同一终点等价类中的子串不可能有相同的长
度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d14ab22e62ea201d54c23b623c196b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a18888198cd4f44012d0d206bc35613/" rel="bookmark">
			范围搜索 (Range Query)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		范围搜索
Author: Subhash Suri
译者：Koala++ / 屈伟
引 前一阵把搜索引擎的RangeQuery的逻辑重新写了一遍，我写的时候就感觉很不对劲，我们的搜索引擎采用的是一种非常怪异的实现，至少我没在别的搜索引擎里见过，或是在资料中看到过。我要解决的是二维坐标查询，比如你想知道你周围五公里内的医院在什么地方，蛮力解决方法就是把所有医院坐标得到，把x坐标循环过滤一遍，再把y坐标循环过滤一遍。其实这还好，因为一个城市一共也没多少医院，但如果调用方把坐标查询写前面，也就是先过滤x和y坐标，再过滤医院，那就悲剧了。
简单点的办法就是把x和y坐标有序地保存，那用二分查找定位到x-2.5km, x+2.5km, y-2.5km, y+2.5km，然后取x-2.5km到x+2.5km的posting list和y-2.5km到y+2.5km的posting list做and操作就可以了。
但是还能不能再快呢？这个问题我想了想也没什么头绪，偶然发现了RTree这个数据结构，我感觉这才是正道。
下面是Range Searching的翻译。原文地址：http://www.cs.ucsb.edu/~suri/cs235/RangeSearching.pdf
Range Search 我们这里讨论Range Search是希望能找到一个好的数据结构，它能高效地对对象(点，矩形，多边形)的集合进行范围查询。
我们要做的是根据对象的类型和查询的类型，来寻找一个能在多种应用场景下使用的基本数据结构。
时间-空间的平衡：我们在预处理和存储上耗费地越多，那我们就可以更快地完成一次查询。
这里主要考虑使用(近似)线性空间的数据结构。
Orthogonal Range Search 对于一个有n个点的集合P。它有2n个子集。对于一个几何的查询，它会有多少个可能的结果呢？
效率能提高的原因是在查询结果中只会有子集中的一部分。
正交范围搜索只处理与坐标轴平行的矩形空间中的点集合。(译注，也就是不能用查询像圆形，五角形这样的范围)。
接下来，我们先讨论一维空间中的排序和搜索问题，然后将一维空间的数据结构推广到多维空间。
1-Dimensional Search 令一维空间的点集合为P={p1, p2, …,pn}。
查询是一个区间：
如果这个区间包含k个点，我们想在时间复杂度为O(log n + k)的情况下解决这个问题。
Hashing可以做到吗？为什么不能？(译注：Hash的查询时间复杂度为O(1+a),a是负载因子，hash在查询时只能依次查找，它的时间复杂度是O(n+an))。
一个排序后的数组可以得到这个时间复杂度边界，但是它无法推广到多维空间。
我们采用一种替代方案，用一个二叉平衡树。
Tree Search 在一个排序后的点(key)数组上建立一个平衡二叉树。
叶子结点对应的是点，中间结点是分支结点。
给定一个区间[xl0,xhi]，在树上搜索xl0和xhi。
搜索得到的两个叶子结点中的叶子结点就是搜索的结果。
树搜索部分的时间复杂度是2log n，将叶子结点放入结果集的时间复杂度为O(k)，这里假设叶子结点是被链在一起的。
Canonical subsets S1, S1… Sk是Canonical子集，Si属于P。如果范围查询的结果可以写成几个Si的并集。(译注：canonical子集的解释http://en.wikipedia.org/wiki/Canonical，不必深究，就认为是子集就行了)。
Canonical子集有可能会重叠。
键(Key)是用来确定正确的Si，和高效地确定对于一个给定的查询，使用哪个Si。
在一维空间问题上，树中每一个结点都有一个Canonical子集：Sv是以v的根结点的子树的Canonical子集，它其中的元素是这个子树所有根结点中的点。
1D Range Query 给定查询[xl0,xhi]，查询树中满足u&gt;= xl0的最左叶子结点，和满足v&gt;= xhi的最左叶子结点。
所有在u和v之间的叶子结点都在所查询范围之内。
如果u= xl0或是v= xhi，那么u, v的canonical子集也包含在范围中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a18888198cd4f44012d0d206bc35613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc9c2d4730c89af7f8d829a53fac731e/" rel="bookmark">
			混合式APP开发问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、如何在APP和H5中，集成快递查询的功能？
解决方案： 可以使用快递100的接口。详情参见网址：https://www.kuaidi100.com/openapi/mobileapi.shtml
使用中，可以不需要type参数，直接 https://m.kuaidi100.com/index_all.html?postid=123456 即可。
传入快递单号，直接跳转到相关快递页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5769c568652339e3e4b03cdddf7fc85b/" rel="bookmark">
			MongoDB实现日志自动切割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编写js脚本
db.runCommand({logRotate:1}) 2、编写windows批处理
mongo -u root -p root -authenticationDatabase admin localhost/admin "D:\Program Files\MongoDB\Server\3.2\data\backup\logRotate.js" 3、建立计划任务，定时执行
注：如果是linux系统下编写sh脚本即可
转载于:https://www.cnblogs.com/seastar1989/p/6594176.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ba23db284b1cb59702962db35cb6ab/" rel="bookmark">
			hdu 5895
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stdlib.h&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;stack&gt; #define clr(x) memset(x,0,sizeof(x)) #define clr2(x) memset(x,INF,sizeof(x)) #define clr3(x) memset(x,-INF,sizeof(x)) #define INF 0x3f3f3f3f #define MAXN 100010 #define MAXM 100010 #define pb(x) push_back(x) #define ll long long #define ull unsigned long long #define MAXS 100000010 using namespace std; struct Martix { ll a[3][3]; }; ll p; ll mul2(ll y, ll cnt); Martix mul(Martix a,Martix b) //&amp;#190;&amp;#216;&amp;#213;ó3&amp;#203;·¨ { Martix c; clr(c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ba23db284b1cb59702962db35cb6ab/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/261/">«</a>
	<span class="pagination__item pagination__item--current">262/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/263/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>