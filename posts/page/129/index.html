<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e2554bf0ef5a7f0773c5817504ffe6a/" rel="bookmark">
			ESP32烧写Arduino编译的固件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		镜像文件路径 ESP32烧写工具一般都需要烧写这些文件。
文件路径 首先我们来记住几个文件的路径，这个是本博客最重要的内容了：
bootloader_dio_40m.bin：
~\AppData\Local\Arduino15\packages\esp32\hardware\esp32\1.0.6\tools\sdk\bin\bootloader_dio_40m.bin
boot_app0.bin
~\AppData\Local\Arduino15\packages\esp32\hardware\esp32\1.0.6\tools\partitions\boot_app0.bin
上面是2个文件了，下面是固件，是在Arduino中生成的
文件位置：两个路径，一个为编译工程的原路径；一个为C盘缓存路径（我的“C:\Users\admin\AppData\Local\Temp\arduino_build_537377”）
烧写 烧写地址就这么抄：
boot_app0.bin 0xe000
bootloader_dio_40m.bin 0x1000
xxx.ino.bin(Arduino固件) 0x10000
xxxxx.ino.partitions.bin 0x8000
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4b500a5051640e5c2d542a5381b5d8/" rel="bookmark">
			mysql group_concat 长度限制自动截取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql的group_concat函数查询结果默认长度1024，超出部门将自动截取，只保留前半部分
解决方法一：
在mysql的配置文件“my.ini”或“my.conf”加上以下语句，然后重启mysql服务即可：
group_concat_max_len=102400
如果这个值设为-1，表示为最大值（4294967295）
解决方法二：
执行以下sql语句：
SET GLOBAL group_concat_max_len=102400;
SET SESSION group_concat_max_len=102400;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c2b01cc1fc84d00a96d00e0051f8fb/" rel="bookmark">
			XLSX工作表日期转文本变为数字问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由日期格式转为文本格式的时候数据发生了变化，变化如下：
那么如何让日期格式的数据转为文本之后，数据不发生变化呢？
1.找到数据中的分列
2.选择固定宽度，然后下一步
3，生成分割线之后点击下一步
4，将日期转为文本，并选择目标区域
5，日期转为文本成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a296097ad5f3b5a107f7c03bc2a8a8/" rel="bookmark">
			将一个文件夹里面的图片的名称打印成一个txt文件，里面包含各个图片的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding:utf-8 -*- # @Time : 2022-08-23 16:10 # @Author : DaFuChen # @File : make_txt.py # @software: PyCharm import os import numpy as np def writ_txt_fuction(file_path): file_name = [] file_list = os.listdir(file_path) # 下面的一部分代码是循环一个文件夹里面的多个子文件夹 就是一个文件夹里面包括多个子文件夹，子文件夹里面包含了一类的图片 # for item in file_list: # items_path = os.path.join(file_path, item) # for items_name in os.listdir(items_path): # file_name.append(file_path + '\\' + items_name + '\t' + item) # 写一个只对一个文件夹进行图片分类 for item in file_list: # print(item) file_name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6a296097ad5f3b5a107f7c03bc2a8a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f83330f8a4ba2444467f693488ed894/" rel="bookmark">
			Vue&#43;element_Table树形数据与懒加载报错Error in render: “RangeError: Maximum call stack size exceeded“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue+element_Table树形数据与懒加载 报错信息：
1.Error in render: “RangeError: Maximum call stack size exceeded”
2.vue.esm.js?efeb:1906 RangeError: Maximum call stack size exceeded
支持树类型的数据的显示。当 row 中包含 children 字段时，被视为树形数据。渲染树形数据时，必须要指定 row-key。支持子节点数据异步加载。设置 Table 的 lazy 属性为 true 与加载函数 load 。通过指定 row 中的 hasChildren 字段来指定哪些行是包含子节点。children 与 hasChildren 都可以通过 tree-props 配置。
使用树形结构+懒加载需要的属性：
row-key=“id” 需要指定，不指定就不会出现 右侧朝向小箭头 就没有懒加载的情况
tree-props配置树表格懒加载标识
load方法，用于点击小箭头加载数据
lazy开启懒加载以后，就可以把load来的数据追加到表格中去了
&lt;el-table :lazy="lazy" :load="load" :tree-props="treeProps" :row-key="rowKey" ref="multipleTable" border class="table" :data="tableData" tooltip-effect="light" style="width: 100%" @selection-change="handleSelectionChange" &gt; load methods: // 懒加载表格子级 lazyLoad(tree, treeNode, resolve) { const { id } = tree; api .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f83330f8a4ba2444467f693488ed894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1606ca1f4acfc3af6b6291f001c424/" rel="bookmark">
			SODA10M 数据集下载记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方下载链接 SODA10M官网数据集下载链接
解压后的数据组织如下：
"SODA10M": { |---SSLAD-2D |---Labeled |---train |---val |---test |---annotations |---instance_train.json |---instance_val.json |---instance_test.json |---Unlabel |---images |---images_* |---annotations |---instance_unlabel_*.json } 官网打不开的，可以直接通过下方网盘链接下载，我就是把官网的下载链接复制到了下面。
标记数据 总文件约5.6GB，百度云盘提取码为1234。
SODA10M Trainval 下载链接：百度云盘
SODA10M 测试下载链接：百度云盘
官网上还有2TB的未标注数据，需要请前往官网下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63cd8e42c8acb0c27ec3b6bd9d7c4c50/" rel="bookmark">
			loadrunner12录制事件一直卡在11就不动了，大佬们，求助啊！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习loadrunner基础使用，结果把百度的URL一贴上去，点击开始录制，浏览器弹出没问题，但是打开百度后，录制事件就停了如下图
，搜索操作都没有反应，点击停止录制后也啥也没有
求助啊，大佬们
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78d98e5ecf173ecc9670023d14b5432/" rel="bookmark">
			Vue_06 快速入门 vue-cli搭建SPA项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 什么是vue-cli?
二、 安装vue-cli
三、 使用脚手架vue-cli(2.X版)来构建项目
步骤一：使用脚手架创建项目骨架
步骤二：运行完上面的命令后，我们需要将当前路径改变到SPA这个文件夹内，然后安装需要的模块
步骤三：启动并访问项目
步骤四：停止项目添加element-ui模块
四、 package.json详解
五、 npm install/npm install xxx -S/npm install xxx -D/npm install xxx -g的区别
六、 vue项目结构说明
main.js文件详解： ​编辑 vue项目启动流程图： 八、综合案例
一、 什么是vue-cli? vue-cli是vue.js的脚手架，用于自动生成vue.js+webpack的项目模板，创建命令如下： vue init webpack xxx 注1：xxx 为自己创建项目的名称
注2：必须先安装vue,vue-cli，webpack，node等一些必要的环境
解释：使用vue.cli就相当于使用Eclipse搭建项目，相当于搭建了一个项目的框子。
二、 安装vue-cli 以下指令均在com命令黑窗口中使用“管理员”执行
0. 前提：搭建好NodeJS环境 node -v
npm -v
当这些都能成功出现版本号，就代表成功搭建好了Node.js环境，如果不会的可单击node.js安装教程
安装vue-cli指令： npm install -g vue-cli （-g:node_global）
如图所示就是安装成功了，注意需要指定node.js安装的路径 注1：安装成功后，会出现如下文件
d:\tools\node ==&gt; 根据自行安装的目录来操作
node-v10.15.3-win-x64
node_global
vue
vue.cmd vue-init
vue-init.cmd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a78d98e5ecf173ecc9670023d14b5432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f360114eaa83bc6acfd610883ba4c6/" rel="bookmark">
			uni-popup is-mask-click无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uni-popup is-mask-click设置无效
原来是这样
:maskClick="false" :isMaskClick="false" 两个都的写才可以 &lt;uni-popup id="popup" ref="popup" type="center" :maskClick="false" :isMaskClick="false"&gt; 内容 &lt;/uni-popup&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b033cc4f873e3578a0bef0630de7ddc/" rel="bookmark">
			Could not set property ‘id‘ of ‘class com.twk.pojo.Book
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Could not set property 'id' of 'class com.twk.pojo.Book with value '1562779476339879937' Cause: java.lang.IllegalArgumentException: argument type mismatch
原因是pojo中实体类，id自增，没有添加注解@TableId(value="id",type=IdType.AUTO)
注解有：
IdType.AUTO 数据库ID自增
IdType.INPUT 用户输入ID
IdType.ID_WORKER 全局唯一ID，内容为空自动填充（默认配置）
IdType.UUID 全局唯一ID，内容为空自动填充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ece48501c8e2cce814951b4d02e77bf/" rel="bookmark">
			SQL-按各科成绩进行排序，并显示排名(清晰解法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按各科成绩进行排序，并显示排名（定义变量set @rank）
CREATE TABLE Score ( s_id VARCHAR(20), #学号 c_id VARCHAR(20), #课程编号 s_score INT(3), #成绩 PRIMARY KEY(s_id,c_id) ); 解：
#1.排列各科成绩
select * from Score where c_id = '01' order by s_score desc; select * from Score where c_id = '02' order by s_score desc; select * from Score where c_id = '03' order by s_score desc; #2.定义rank排名
set @rank_01 = 0; select *,@rank_01 := @rank_01 + 1 from Score sc where c_id = '01' order by s_score desc; set @rank_02 = 0; select *,@rank_02 := @rank_02 + 1 from Score sc where c_id = '02' order by s_score desc; set @rank_03 = 0; select *,@rank_03 := @rank_03 + 1 from Score sc where c_id = '03' order by s_score desc; #3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ece48501c8e2cce814951b4d02e77bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f27b3962a7dbb6cdb631db65aeecf23/" rel="bookmark">
			CAD图纸导入REVIT内并精准建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体原理逻辑： 1、CAD图纸(原点至原点）导入，作为建模参考底图，此刻测量点、项目基点位置都与CAD图纸原点重合。
2、测量点位置不动（目的是为了保障明确参考坐标系原点的坐标），挪动项目基点位置至CAD图纸附近，定义项目基点此时的位置为参考坐标系原点位置。
3、基于CAD图纸建模
4、使用参考坐标系原点CAD坐标+CAD图纸投影参数导出模型即可。
一、CAD图纸导入REVIT 1、CAD图纸导入 （1）插入-导入CAD
（2）弹出导入CAD格式窗口，我们找到图纸所在文件夹，点击图纸，看到下方选项，将最左侧“仅当前视图”前面勾选上（当模型中楼层较多的时候就不会显得很乱），然后颜色选择保留，“图层/标高”选择全部，“导入单位”选择毫米，定位选择自动-原点到原点，点击打开。CAD图纸就导入Revit啦。
（3）成果
2、CAD图纸链接 还可以通过链接CAD导入CAD图纸，跟导入CAD不同的是，链接的CAD图纸源文件被修改了，修改的部分可以同步到Revit，而导入CAD图纸则不能更新。另外通过”链接CAD”制作的REVIT模型拷贝个别人时，连同CAD文件也要拷贝
点击”插入“选项卡下方的“链接CAD”功能。
二、REVIT内精准建模 1、将项目基点挪动至参考坐标点 项目基点的坐标是参考测量点的坐标位置，可以发现，当项目基点与测量点重合时，项目几点坐标为（0，0，0），如下图所示：
关闭项目基点的回形针，挪动项目基点，会发现CAD图纸位置不变，项目基点的坐标变了，坐标为相对测量点的坐标位置（X，Y，Z），如下图所示：
将项目基点挪动至导入的CAD图纸附近（必须关闭回形针。不然会发现图纸会随着项目基点的位置相对移动），设定此时的项目基点为参考坐标系的原点，其坐标为参考坐标系原点CAD坐标。
2、基于图纸建模 此刻项目基点位置已经在模型主体位置附近，基于CAD图纸建模即可。
3、导出模型 投影参数设定为CAD图纸的参数
本地坐标偏移填写参考坐标系原点坐标。
结果验证，流程走通。
从下图CAD软件中获取的（464315.3，669542.5）点中可发现，参考系坐标原点位置与CAD内点位置一致，位置正确。
三、问题 1、测量点位置能否挪动？ 答案：可以挪动。
但我们需要了解小标签打开与不打开的区别：
（1）原始测量点坐标与项目基点坐标：
（2）基于（1）的数据，打开测量点标签，挪动测量点位置后的测量点坐标与项目基点坐标：
测量点坐标没有变化，项目基点位置有变化
（3）基于（1）的数据，关闭测量点标签，挪动测量点位置后的测量点坐标与项目基点坐标：
测量点坐标有变化，项目基点位置无变化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf01f67723310492488a5e6078f493d2/" rel="bookmark">
			js表单验证确认密码输入一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;form action="../01-自动轮播图片/图片自动轮播.html" onsubmit="return checkForm()" &gt; 用户名:&lt;input type="text" id="username" onfocus="showTips('span_username','用户名长度不能小于6')" onblur="checkUsername()" onkeyup="checkUsername()" /&gt;&lt;span id="span_username"&gt;&lt;/span&gt;&lt;br /&gt; 密码:&lt;input type="password" id="password" onfocus="showTips('span_password','密码长度不能小于6')" onblur="checkPassword()" onkeyup="checkPassword()"/&gt;&lt;span id="span_password"&gt;&lt;/span&gt;&lt;br /&gt; 确认密码:&lt;input type="password" id="repassword" onfocus="showTips('span_repassword','两次密码必须一致')" onblur="checkRePassword()" onkeyup="checkRePassword()" /&gt;&lt;span id="span_repassword"&gt;&lt;/span&gt;&lt;br /&gt; 邮箱:&lt;input type="text" id="email" onfocus="showTips('span_email','邮箱格式必须正确')" onblur="checkMail()" /&gt;&lt;span id="span_email"&gt;&lt;/span&gt;&lt;br /&gt; 手机号:&lt;input type="text" id="text" /&gt;&lt;br /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; /*确认密码校验* */ function checkRePassword(){ //获取密码输入 var uPass = document.getElementById("password").value; //获取确认密码输入 var uRePass = document.getElementById("repassword").value; var span = document.getElementById("span_repassword"); //对密码输入进行校验 if(uPass !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf01f67723310492488a5e6078f493d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de66d0487bc817ecb11ee5aff5fefd2/" rel="bookmark">
			Vue_05 快速入门 ElementUI&amp;node.js下载配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、ElementUI简介
二、Vue+ElementUI安装
2.1 CDN方式（然后引用elementUI）
2.2 NPM(需要配置NodeJs环境) 1. Node.js是什么
2. npm是什么
3. Node.js环境搭建
4. 如何运行下载的Node.js项目
一、ElementUI简介 我们学习VUE,知道它的核心思想式组件和数据驱动,但是每一个组件都需要自己编写模板,样式,添加事件,数据等是非常麻烦的,所以饿了吗推出了基于VUE2.0的组件库,它的名称叫做element-ui,提供了丰富的PC端组件
ElementUI官网：Element - The world's most popular Vue UI framework
注1：类似前端框架还有iview
二、Vue+ElementUI安装 2.1 CDN方式（然后引用elementUI） &lt;!-- 1. 导入css --&gt; &lt;link href="https://cdn.bootcss.com/element-ui/2.8.2/theme-chalk/index.css" rel="stylesheet"&gt; &lt;!-- 2. 引入vue和vue-router--&gt; &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.js"&gt;&lt;/script&gt; &lt;!-- 未使用vue路由功能可不导入 --&gt; &lt;script src="https://cdn.bootcss.com/vue-router/3.0.6/vue-router.js"&gt;&lt;/script&gt; &lt;!-- 3. 引入ElementUI组件 --&gt; &lt;script src="https://cdn.bootcss.com/element-ui/2.8.2/index.js"&gt;&lt;/script&gt; 示例(注：由于是外部式引入，因此需要联网)：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;elementUI演示&lt;/title&gt; &lt;!-- 1. 导入css --&gt; &lt;link href="https://cdn.bootcss.com/element-ui/2.8.2/theme-chalk/index.css" rel="stylesheet"&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0de66d0487bc817ecb11ee5aff5fefd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a630679729e10e6b77db15c04bbaf353/" rel="bookmark">
			vue汉字转拼音-pinyin.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求:用户在输入姓和名字的时候,由于姓(拼音)和名(拼音)为字母,容易输错,于是就有了自动生成拼音这个需求 npm install安装的四种用法-save和-save-dev npm install xxx： 安装项目到项目目录下，不会将模块依赖写入devDependencies或dependencies。
npm install -g xxx: -g的意思是将模块安装到全局，不是安装到当前目录的项目下
npm install -save xxx: -save的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。
npm install -save-dev xxx:
-save-dev的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。
一:安装 npm install js-pinyin --save 二:使用&lt;script&gt;&lt;/script&gt;标签引入 let pinyin = require('js-pinyin'); pinyin.setOptions({checkPolyphone: false, charCase: 0}); 三:使用示例 &lt;template&gt; &lt;div class="demo"&gt; &lt;input v-model="surname" type="text" placeholder="姓(中文)"&gt; &lt;input v-model="surnamePinyin.toUpperCase()" type="text" placeholder="姓(拼音)"&gt; &lt;input v-model="givenName" type="text" placeholder="名(中文)"&gt; &lt;input v-model="givenNamePinyin" type="text" placeholder="名(拼音)"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; let pinyin = require('js-pinyin'); pinyin.setOptions({checkPolyphone: false, charCase: 0}); ​ console.log(pinyin.getFullChars('徐').toUpperCase()); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a630679729e10e6b77db15c04bbaf353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed853b2e67b7e379a4aa8eaa99908ea/" rel="bookmark">
			python之pandas索引、DataFrame数据选取及filter介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.数据筛选1.1 单条件筛选1.2 多条件筛选1.3 索引筛选1.3.1 切片操作1.3.2 loc函数1.3.3 iloc函数1.3.4 ix函数1.3.5 at函数1.3.6 iat函数 2.filter 1.数据筛选 a b c 0 0 2 4 1 6 8 10 2 12 14 16 3 18 20 22 4 24 26 28 5 30 32 34 6 36 38 40 1.1 单条件筛选 df[df['a']&gt;30] # 筛选a列的取值大于30的记录,但只显示满足条件的b，c列的值 df[['b','c']][df['a']&gt;30] # 使用isin函数根据特定值筛选记录。筛选a值等于30或者54的记录 df[df.a.isin([30, 54])] # 选择时间小于10秒的行 time_series = time_series[time_series.index &lt; timedelta(seconds=10)] c2 = c1[c1.values == class_num] #过滤掉为 0 的行 data = df[df[self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed853b2e67b7e379a4aa8eaa99908ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07288ef33d546c567839329638362df/" rel="bookmark">
			npm install报错npm ERR Could not resolve dependency: npm ERR peer...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cyol_wenchunyu@wenchunyudeiMac admin % npm install npm ERR! code ERESOLVE npm ERR! ERESOLVE unable to resolve dependency tree npm ERR! npm ERR! While resolving: admin@0.1.0 npm ERR! Found: eslint@7.32.0 npm ERR! node_modules/eslint npm ERR! dev eslint@"^7.32.0" from the root project npm ERR! npm ERR! Could not resolve dependency: npm ERR! peer eslint@"&gt;= 1.6.0 &lt; 7.0.0" from @vue/cli-plugin-eslint@4.5.19 npm ERR! node_modules/@vue/cli-plugin-eslint npm ERR! dev @vue/cli-plugin-eslint@"~4.5.0" from the root project npm ERR! npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07288ef33d546c567839329638362df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb6789b57fd50dd95be07eeac2a6904/" rel="bookmark">
			是时候来点现代c&#43;&#43;了 c&#43;&#43;17重要新特性解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于stl的使用 他真的这么好用嘛？他性能真的那么高效嘛？ 是的 google 都在使用c++17的新特性 google是对性能精益求精的公司 连头部大手子都在使用的c++17新特性 你有什么理由不去使用他？性能就不用多说了 在优化拉满 release版的情况下 性能无限接近纯原生系统调用 你有啥理由不使用 下面让我们来看看c++17增加哪些新东西 为什么要增加这些新东西 他解决了什么问题 以及如何使用他
Tips:本人观点:光是去关注c++标准委员会和Google的动向 你都能学到很多东西 你能大概知道目前大家遇到的问题是啥 以及c++标准委员 Google 会如何解决他 比如c++23将要推出的协程 Google的grpc 等等
前言 关于c++14的新特性 个人觉得和c++11差距并不是太大 也就不细说了 也许日后会专门写篇文章来写c++14的新特性
c++17之string_view 为什么要有string_view string有一个最大的缺点 就是他必须拥有字符串资源的所有权 这是什么意思呢 当下段代码发生的时候其实是发生了拷贝 如下图所示
std::string mystring = "this is play"; "this is play"这个字符串是放在常量区的 但是在构造string的时候 他会把这个字符串复制到堆区或者是栈区来自己管理 c++程序员是很讨厌拷贝的 为了解决这个问题 所以c++17推出了string_view 他就是不会去拷贝常量区资源 而是直接指向他 相当于就是普通的const char*和一个记录字符串大小的字段size 什么情况下使用string_view 当我们不想去拷贝常量区资源 也就是我们并不想拥有字符串资源的所有权的时候
怎样使用string_view 当我们使用string_view的时候 就可以这么玩 非常的简单 下图并没有发生拷贝
std::string_view mystring = "this is play"; 并不想发生拷贝的场景有点多哦 具体怎么玩就要看自己的选择咯 这个是确实能够优化性能的东西 c++17之any 为什么要有any？ 在c++17之前我们想用一种类型来表示任何一种资源的时候 常用的方法如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb6789b57fd50dd95be07eeac2a6904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f593b0f8c6dd880ebdf663b4e7b64cf9/" rel="bookmark">
			【STM32学习4】STM32CubeIDE功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 STM32CubeIDE是ST公司官方推出的用于STM32开发的IDE，集成了芯片选择、代码初始化、C/C++程序编写、编译、烧录、调试等功能，无需繁琐的环境配置，资源包配置，软件之间切来切去，真正做到了一个软件完成开发。
可能现在最主流的IDE还是ARM公司的Keil，网上的资料更多，大家也都比较熟练，但STM32CubeIDE有着更高的集成度，并且基于Elipse开发，界面都几乎与Elipse一模一样，所以说使用起来也比较容易。使用方法可以主要参考官方的教程，写的还算是十分的详尽。可以从软件的Help-&gt;Information Center找到。
一、主要功能 下图完整地总结了STM32CubeIDE的结构以及包含的所有功能。
支持WIn、Mac与Linux多平台，基于Eclipse平台，集成了Eclipse的C/C++开发工具（CDT）以及众多的插件。硬件支持方面集成了ST公司官方的MCU-Finder（芯片查找与选择）与STM32CubeMX（芯片基础配置与代码初始化）；调试方面集成了Atollic公司的TrueSTUDIO开发工具以及众多的灵活的调试方式。支持ST-LINK、OpenOCD、SEGGER J-Link三种GDB Server（调试程序）进行调试，对应不同的仿真器硬件。
部分功能列举如下：
集成了STM32CubeMX进行代码初始化进行代码的编译（Build）并运行（Running）或调试（Debugging）Build Analyzer（编译分析器）：分析RAM与FLASH的占用情况，并可以显示使用细节
Static Stack Analyzer（静态栈分析器）：分析栈的使用情况SWV（Serial Wire Viewer，串行线显示）：这是一个使用串行线接口调试时的工具集，包括以下7个功能： SWV Trace log：采样系统运行时发生的各种事件
SWV Exception Trace log：采样系统运行时的异常事件SWV Exception Timeline Graph：以时间轴图像的方式显示系统运行时发生的异常SWV Data Trace：实时显示系统运行时的某个变量值SWV Data Trace Timeline Graph：以时间轴图像的方式实时显示某个变量值SWV ITM Data Console：可以通过一系列的配置，将单片机串口输出到上位机的值转到STM32CubeIDE软件中的ITM Console控制台显示
SWV Statistical Profiling：可以统计不同函数占用系统总用时的比例 6. SFRs View（Special Function Registers View）：查看特殊功能寄存器的状态
7. Live Expressions view：实时变量查看，可以在调试过程中实时查看某个变量值的变化
8. Fault Analyzer：错误诊断，用于查找系统运行过程中的错误
9. RTOS-aware debugging：实时操作系统相关调试，目前支持实时操作系统包括微软的Azure® RTOS ThreadX以及FreeRTOS。以FreeRTOS为例，支持在调试过程中实时查看任务（Task）、队列（Queue）、信号量（Semaphores）以及软件计时器的运行情况（Timers）。
总结 STM32CubeIDE是一个功能完整而强大的软件，大多数的STM32工程都可以用这一个软件就开发并调试完成。上面只是列举了一些基本的功能，功能具体的使用以及其他功能的发掘还有待后续的学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffcf2de43566e874afbf3efb2dbf0d4e/" rel="bookmark">
			vue中的element-ui和react的element-ui
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先分享一个使用vue做的后台管理系统网站的示例，里面的控件都是用element-ui做的。
https://cangdu.org/manage/#/
读了一下它的源代码，深感有了element-ui 做UI太方便了，Android里做UI是多么的麻烦。
这里记录一下element-ui的官方地址，方便以后需要的时候查看。
vue里使用的element-ui地址： https://element.eleme.cn/#/zh-CN/component/button
react里使用的element-ui地址： https://elemefe.github.io/element-react/#/zh-CN/button
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c908d97a9e4acb3e5a62fdab6216fa/" rel="bookmark">
			前馈神经网络（Feedforward neural network）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前馈神经网络（FNN）是一种人工神经网络，其中节点之间的连接不形成循环。因此，它不同于它的后代：递归神经网络。
在前馈网络中，信息总是向一个方向移动；它从不倒退。
前馈神经网络是设计的第一种也是最简单的人工神经网络。在该网络中，信息仅在一个方向上从输入节点向前移动，通过隐藏节点（如果有）并到达输出节点。网络中没有循环或环路。
单层感知器
最简单的神经网络是单层感知器网络，由单层输出节点组成；输入通过一系列权重直接馈给输出。在每个节点中计算权重和输入的乘积之和，如果该值高于某个阈值（通常为0），则神经元触发并取激活值（通常为1）；否则，它将取停用的值（通常为-1）。具有这种激活功能的神经元也称为人工神经元或线性阈值单元。在文献中，术语感知机通常指仅由这些单元之一组成的网络。沃伦·麦卡洛赫和沃尔特·皮茨在20世纪40年代描述了类似的神经元。
可以使用激活和停用状态的任何值来创建感知器，只要阈值介于两者之间。
感知器可以通过一种简单的学习算法来训练，该算法通常称为delta规则。它计算计算出的输出和样本输出数据之间的误差，并使用该误差对权重进行调整，从而实现一种梯度下降形式。
单层感知器只能学习线性可分离模式；1969年，Marvin Minsky和Seymour Papert在一篇名为《感知器》的著名专著中指出，单层感知器网络不可能学习异或函数（尽管如此，众所周知，多层感知器能够产生任何可能的布尔函数）。
虽然单个阈值单元的计算能力非常有限，但已经表明，并行阈值单元网络可以将任何连续函数从实数的紧凑区间近似为区间[-1,1]。这一结果可以在Peter Auer、Harald Burgsteiner和Wolfgang Maas的《由单层感知器组成的非常简单的通用近似器的学习规则》中找到。
单层神经网络可以计算连续输出而不是阶跃函数。一种常见的选择是所谓的逻辑函数：
通过这种选择，单层网络与广泛用于统计建模的逻辑回归模型相同。逻辑函数是称为S形函数的函数族之一，因为它们的S形图类似于希腊字母Sigma的最后一个字母小写。它具有连续导数，这允许它用于反向传播。该函数也是优选的，因为其导数易于计算：
（事实上f满足上述微分方程，可通过应用链式法则轻松表示。）
如果单层神经网络激活函数为模1，则该网络可以解决单个神经元的异或问题。
神经网络多层感知器
能够计算异或的两层神经网络。神经元内的数字表示每个神经元的显式阈值（可以将其分解，以便所有神经元具有相同的阈值，通常为1）。注释箭头的数字表示输入的权重。该网络假设如果未达到阈值，则输出零（非-1）。注意，输入的底层并不总是被视为真正的神经网络层
这类网络由多层计算单元组成，通常以前馈方式互连。一层中的每个神经元都与下一层的神经元有直接连接。在许多应用中，这些网络的单元应用S形函数作为激活函数。然而，S形激活函数在小范围外具有非常小的导数值，并且由于消失梯度问题，在深度神经网络中不能很好地工作。已经提出了S形激活函数的替代方案，以缓解消失梯度问题并允许训练深度网络。
神经网络的通用逼近定理表明，将实数区间映射到某个实数输出区间的每个连续函数都可以由一个只有一个隐藏层的多层感知器任意逼近。这一结果适用于广泛的激活函数，例如S形函数。
多层网络使用多种学习技术，最流行的是反向传播。这里，将输出值与正确答案进行比较，以计算某个预定义误差函数的值。通过各种技术，误差然后通过网络反馈。使用该信息，该算法调整每个连接的权重，以便将误差函数的值减小一小部分。在对足够多的训练周期重复该过程之后，网络通常将收敛到计算误差较小的某个状态。在这种情况下，可以说网络已经学习了某个目标函数。为了适当地调整权重，可以应用一种称为梯度下降的非线性优化的一般方法。为此，网络计算误差函数相对于网络权重的导数，并改变权重，使得误差减小（从而在误差函数的表面上向下）。因此，反向传播只能应用于具有可微激活函数的网络。
一般来说，教一个网络表现良好的问题，即使是在没有用作训练样本的样本上，也是一个相当微妙的问题，需要额外的技术。这对于只有非常有限数量的训练样本可用的情况尤为重要。[7] 危险在于网络过度拟合训练数据，无法捕获生成数据的真实统计过程。计算学习理论关注的是在有限的数据量上训练分类器。在神经网络的上下文中，一种简单的启发式方法，称为早期停止，通常可以确保网络能够很好地推广到不在训练集中的示例。
反向传播算法的其他典型问题是收敛速度和最终导致误差函数局部最小的可能性。今天，有一些实用的方法使多层感知器中的反向传播成为许多机器学习任务的首选工具。
人们还可以使用一系列由某种中介调节的独立神经网络，类似于大脑中发生的行为。这些神经元可以独立地执行和处理大型任务，最终可以将结果组合起来。
其他前馈网络
更一般地，任何有向无环图都可以用于前馈网络，其中一些节点（没有父节点）被指定为输入，而一些节点（无子节点）被设置为输出。这些可以被视为多层网络，其中一些边缘跳过层，从输出向后或从输入向前计数层。可以使用各种激活函数，并且权重之间可以存在关系，如在卷积神经网络中。
其他前馈网络的示例包括使用不同激活函数的径向基函数网络。
有时，多层感知器被松散地用于指代任何前馈神经网络，而在其他情况下，它仅限于特定的前馈神经网络（例如，具有特定的激活函数，或具有完全连接的层，或由感知器算法训练）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e303d54e899f73e8e0be2d63889d3e1/" rel="bookmark">
			截图神器Snipaste，错过真的太可惜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截图是我们平时常用的功能，能快速方便地保存需要的图片内容。
小葱以前一直用QQ截图，每次都要在电脑上登录QQ账号才能用，直到我发现了这款宝藏截图软件Snipaste，免费、小巧、不连网也能用，实在太赞了！
首先，这款截图软件无需连网就能使用，和QQ截屏比起来方便了许多。
我们只要按下截图快捷键【F1】就能截图，自由选择截图区域，截图后可以对图片进行绘画、打马赛克、添加文字等。
接着，是Snipaste特别好用的贴图功能。当我们按【F1】截图后，接着点击图钉的按钮（或者按快捷键【F3】），就可以把刚刚的截图贴在桌面上了。
那这个功能是用来做什么的呢？
例如，我们需要看文献资料的时候，常常会有这样的情况，一段文字被分隔在了两页，或是插图和文字被分隔在了两页，阅读的时候，我们就得在两页之间不断的上下拖动。
阅读效率效率实在是太低了，但是如果用了Snipaste的贴图功能，我们只需要截个图，把后半部分的内容贴在旁边，就能轻松解决这个问题，双击贴图就能关闭啦！
除了截图和贴图功能，这款软件使用起来也是非常的人性化，可以通过快捷键操控移动鼠标指针和截屏区域，还能继续使用上一次截屏的区域和回溯截屏历史。如果我们不想在图片中显示鼠标指针的话，也可以将它隐藏起来哦！
如果有朋友是美术生或是设计师，那么接下来小葱要介绍的这个功能你应该会喜欢！那就是取色功能！
如果我们遇到了一眼心动的颜色，想记录下来参数，只需按下【F1】键截图，接着再把鼠标对准你要吸取的颜色，并按下【C】键，这时颜色的参数就已经被记录下来了，然后按下【F3】键，桌面上就会出现这个颜色的各种格式的色值，右击方框，我们可以复制上面的信息，是不是非常方便呢？
好用的截图软件有了，那如果我们想录制视频应该用什么呢？
野葱和Snipaste一样，都是不花钱就能用的良心软件，轻量无广，绿色安全。
简单3步就能轻松搞定视频录制，像截图一样简单。
它支持人像+屏幕同时录制，录制过程中还能用画笔强调重点。
录制完成的视频自动保存到云端个人空间，不占用电脑内存，如果想分享给朋友，一键复制链接即可，对方点击链接就能在线观看。野葱还为用户提供了剪辑功能哦，轻松裁剪掉你不满意的部分~
今天的分享内容到这就结束啦，希望能帮助大家更加便捷的截图和录屏，提高工作学习效率！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68040b4d60528c393c2af7fb8ece6411/" rel="bookmark">
			js动态渲染html 给html绑定点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景：渲染一个表格 根据当前行的数据作为参数，通过ajax请求到后台返回的数据,再根据返回的结果动态生成HTML页面 给动态生成的页面添加点击事件 // 推荐商家点击标题展开与收起 $('.toggle-tag').on('click', function(){ var ele = $(this).parents('tr').next().find('.pro-details'); if(ele.is(':hidden')){ $('.pro-details').slideUp(); ele.slideDown(); }else{ ele.slideUp(); } }); // 推荐商家点击收起 $('.toggle').on('click', function(){ $(this).parents('.pro-details').slideUp(); }); 点击事件无效
原因:代码的执行顺序不同 代码先执行js/css再执行的渲染html 在浏览器解析到图一的页面元素时， 解析到js的这些绑定标签事件的js代码（上面的JS代码）的时候，这些绑定事件的标签元素还没有生成，
（因为js代码加载完后，才会有这些绑定事件的标签），所以这些JS 代码的绑定的事件，根本就没有绑定到这些动态加载的标签上，所以哪些事件不会触发。
解决方案：
类似动态加载的HTML元素需要绑定事件可以用 jQuery 事件 - delegate() 方法
定义和用法 delegate() 方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。
使用 delegate() 方法的事件处理程序适用于当前或未来的元素（比如由脚本创建的新元素）。
语法 $(selector).delegate(childSelector,event,data,function) 参数描述childSelector必需。规定要附加事件处理程序的一个或多个子元素。event 必需。规定附加到元素的一个或多个事件。
由空格分隔多个事件值。必须是有效的事件。
data可选。规定传递到函数的额外数据。function必需。规定当事件发生时运行的函数。 // 推荐商家点击收起 $("body").delegate(".toggle","click", function(){ $(this).parents('.pro-details').slideUp(); $(this).parents('tr').hide(); }); 就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/793432365b75d67a6c2d7ca40a12b6bf/" rel="bookmark">
			时序预测 | MATLAB实现HMM隐马尔可夫模型时间序列预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时序预测 | MATLAB实现HMM隐马尔可夫模型时间序列预测 目录 时序预测 | MATLAB实现HMM隐马尔可夫模型时间序列预测预测效果基本介绍模型描述程序设计学习总结参考资料 预测效果 基本介绍 ＨＭＭ 是一个双重随机的模型，以隐层状态序列组成的马尔科夫链为基础，对观测序列进行描述。隐马尔科夫模型开始于一个有限的状态集，由状态转移概率矩阵确定下一个状态值，由混淆概率矩阵确定从一个特定状态产生的观测值，因此具有学习时间序列信息的能力。
模型描述 程序设计 完整程序：MATLAB实现HMM(隐马尔科夫)时间序列预测（完整源码和数据） % 前向概率 ntime = size(Closing,2); alpha = zeros(ntime,num_States); beta = zeros(ntime,num_States); % 尺度因子 S_alpha = zeros(ntime,1); %本函数需要预测值与观测值 %nnR - R^2 value %style - options for display of figures (1 or 2) %titleN - title to be included (string) clear title xlabel ylabel %set figure number n = get(gcf,'Number'); ylimMax1 = max(dataSim); ylimMax2 = max(dataObs); ylimMax = max(ylimMax1,ylimMax2); ylimMin1 = min(dataSim); ylimMin2 = min(dataObs); ylimMin = min(ylimMin1,ylimMin2); figure(n) plot(dataObs) title(' 曲线'); ylabel('数据'); xlabel('样本'); set(gca,'FontSize',12) 学习总结 马尔可夫链是一种研究事物转移规律与状态变化情况的理论，不仅能够应用在时间序列的分析中，也可以应用在空间序列的分析中，马尔可夫链系统在每一个阶段的状态都有着随机性的特征，其时期状态是按照概率来进行转移的，下一时期状态只由本时期转移概率与状态来决定，不会受到其他因素的影响．本文提出了一种基于ＨＭＭ 时间序列预测模型，利用隐马尔科夫模型的时序特性，克服了现有基于机器学习算法的局限性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/793432365b75d67a6c2d7ca40a12b6bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c6ddd4a615d5f3f619694f8f65b125/" rel="bookmark">
			javafx乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用低版本的jdk（如jdk11），运行javafx，容易出现上述乱码问题
可以插入下列代码 ：
scene.getRoot().setStyle("-fx-font-family: 'serif'"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c745c859359a7c2c8032cea588e9cf/" rel="bookmark">
			yarn代理设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置proxy yarn config set https-proxy http://127.0.0.1:7890 yarn config set proxy http://127.0.0.1:7890 查看proxy yarn config get https-proxy yarn config get proxy 参考： proxy配下でのyarn実行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c880723c135ca5e02f3304c10c13ac4/" rel="bookmark">
			Spring AOP统一处理日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP统一处理日志 注：日志记录是系统非业务功能的重要一环，而日志中比较重要的是Controller层的请求日志，需要记录的信息包括登录用户、访问时间，访问接口，请求参数，响应结果等。本文基于Spring AOP、logback，在统一的切面对象中实现请求日志的统一处理。
依赖 &lt;!-- Aspect AOP--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 登录用户持有器 @Component public class HostHolder { private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;(); public UserLoginResp getUser() { return users.get(); } public void setUser(UserLoginResp user) { users.set(user); } public void clear() { users.remove(); } } 切面类实现一 @Component @Aspect public class ApiLogAspect { private static final Logger logger = LoggerFactory.getLogger(ApiLogAspect.class); /** * 指定切面对象，Controller层所有暴露给前端的接口方法 */ @Pointcut("execution(public * com.itcampus.controller.*.*(..))") public void pointcut() {} /** * 记录接口入参日志 */ @Before(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c880723c135ca5e02f3304c10c13ac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502e6d7979f00a3b5acb34de5341f7e7/" rel="bookmark">
			Java8 中新增的 Stream 流操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献：
Java8 中新增的 Stream 流操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c7469af4b722e660ef4f512333aba5/" rel="bookmark">
			C&#43;&#43;程序设计基础实验-实验二 函数的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 实验目的 了解C++开发工具并学习使用
理解函数的形参、函数原型、内联函数；学会编制重载函数和递归函数。
二、实验内容 编写函数实现递归方式求取整数n的阶乘，要求在主函数中输入整数n，通过调用输出结果，例如输入5,得到5！=120。
编写函数求两个整数的最大公约数和最小公倍数。
编写函数输出指定行数的星星等腰三角形。例如输入：5，得到以下图形。
编写函数实现从键盘输入一个正整数，将其按照二进制进行输出。例如，将135打印成10000111.
编写函数实现输出从1 开始的整数矩阵。例如输入4，5,则能够输出4x5的矩阵：
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20
编写函数输出能够整除某数的所有因子，能够实现从键盘输入两个整数，例如，输入6，则输出1，2，3，6。
编写函数输出指定范围内的质数。例如输入100，200，则能够实现求出100-200之间的质数。
编写函数求平面中两个点坐标（x1,y1）与(x2,y2)的距离。例如输入：0 0 3 4，则得到坐标（0，0）与（3，4）两个点之间的距离为5。
编写三个同名的函数：函数返回类型 Area(…),它们之间形成重载，分别用于求圆的面积，矩形的面积，三角形面积。
理解下面的程序，并在IDE中运行，查看结果，回答程序后面的问题。
#include &lt;iostream&gt; using namespace std; void swap(int a, int b) { int temp = a; a = b; b = temp; } void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } int main() { int i = 5; int j = 10; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20c7469af4b722e660ef4f512333aba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/304a8313f078fc436d1c72d5a949bf69/" rel="bookmark">
			【云原生--Kubernetes】ingress详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. Ingress简介1.1 service暴露方式1.2 ingress组件1.2.1 ingress1.2.2 ingress-controller 1.3 Ingress 工作原理 二. ingress 暴露服务的方式2.1 Deployment+LoadBalancer2.2 DaemonSet+HostNetwork+nodeSelector2.3 Deployment+NodePort 三. ingress-nginx3.1 Nginx Ingress Controller工作流程3.2 部署 nginx-ingress-controller3.3 DaemonSet+HostNetwork+nodeselector3.3 部署Deployment+NodePort 四. ingress-nginx 反向代理4.1 ingress http代理访问虚拟主机4.2 ingress HTTPS 代理访问4.3 Nginx 重写跳转 五. 总结 一. Ingress简介 1.1 service暴露方式 service的作用体现在两个方面，对集群内部，它不断跟踪pod的变化，更新endpoint中对应pod的对象，提供了ip不断变化的pod的服务发现机制；对集群外部，他类似负载均衡器，可以在集群内外部对pod进行访问。
在Kubernetes中，Pod的IP地址和service的ClusterIP仅可以在集群网络内部使用，对于集群外的应用是不可见的。为了使外部的应用能够访问集群内的服务，Kubernetes目前提供了以下几种方案：
NodePort：将service暴露在节点网络上，NodePort背后就是Kube-Proxy，Kube-Proxy是沟通service网络、Pod网络和节点网络的桥梁。
测试环境使用还行，当有几十上百的服务在集群中运行时，NodePort的端口管理就是个灾难。因为每个端口只能是一种服务，端口范围只能是 30000-32767。
LoadBalancer：通过设置LoadBalancer映射到云服务商提供的LoadBalancer地址。这种用法仅用于在公有云服务提供商的云平台上设置 Service 的场景。受限于云平台，且通常在云平台部署LoadBalancer还需要额外的费用。
在service提交后，Kubernetes就会调用CloudProvider在公有云上为你创建一个负载均衡服务，并且把被代理的Pod的IP地址配置给负载均衡服务做后端。
externalIPs：service允许为其分配外部IP，如果外部IP路由到集群中一个或多个Node上，Service会被暴露给这些externalIPs。通过外部IP进入到集群的流量，将会被路由到Service的Endpoint上。
Ingress：只需一个或者少量的公网IP和LB，即可同时将多个HTTP服务暴露到外网，七层反向代理。
可以简单理解为service的service，它其实就是一组基于域名和URL路径，把用户的请求转发到一个或多个service的规则。
1.2 ingress组件 1.2.1 ingress ingress是一个API对象，通过yaml文件来配置，ingress对象的作用是定义请求如何转发到service的规则，可以理解为配置模板。
ingress通过http或https暴露集群内部service，给service提供外部URL、负载均衡、SSL/TLS能力以及基于域名的反向代理。ingress要依靠 ingress-controller 来具体实现以上功能。
1.2.2 ingress-controller ingress-controller是具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发。
ingress-controller并不是k8s自带的组件，实际上ingress-controller只是一个统称，用户可以选择不同的ingress-controller实现，目前，由k8s维护的ingress-controller只有google云的GCE与ingress-nginx两个，其他还有很多第三方维护的ingress-controller，具体可以参考官方文档。但是不管哪一种ingress-controller，实现的机制都大同小异，只是在具体配置上有差异。
一般来说**，ingress-controller的形式都是一个pod**，里面跑着daemon程序和反向代理程序。daemon负责不断监控集群的变化，根据 ingress对象生成配置并应用新配置到反向代理，比如ingress-nginx就是动态生成nginx配置，动态更新upstream，并在需要的时候reload程序应用新配置。为了方便，后面的例子都以k8s官方维护的ingress-nginx为例。
Ingress-Nginx github 地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/304a8313f078fc436d1c72d5a949bf69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c1b546afb619d1279579a5cad3dbc7/" rel="bookmark">
			高德地图API 前端调用 搜索定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高德地图API 前端调用 搜索定位 1.申请web的KEY和密钥
2.使用 地图 JS API v2.0
地图 JS API v2.0 3.前端代码
安装
npm i @amap/amap-jsapi-loader --save main.js中加入代码
window._AMapSecurityConfig = { //将http://1.1.1.1:80替换为实际代理地址 securityJsCode:'申请的安全密钥', } MapContainer,vue 子组件
&lt;template&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import AMapLoader from "@amap/amap-jsapi-loader"; export default { data() { return { map: null, marker: null, circle: null }; }, mounted() { //DOM初始化完成进行地图初始化 this.initMap(); }, methods: { initMap() { AMapLoader.load({ key: "", //设置您的key version: "2.0", plugins: ["AMap.ToolBar", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c1b546afb619d1279579a5cad3dbc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f43a870547f13f2450697c983631f7/" rel="bookmark">
			路由跳转方式与路由参数传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、路由跳转方式
1、声明式导航
vue Router中的声明式导航就是 &lt;router-link&gt; 标签，那么router-link怎么带我们去我们要到的组件呢，是通过router-link的to属性到达对应的组件中。
&lt;router-link to="/login"&gt;登录&lt;/router-link&gt; 2、编程式导航
在Vue里，可以通过vm的$router对象来进行路由的管理
&lt;button type="button" @click="goSearch"&gt; goSearch() { this.$router.push("/search"); } 二、路由传参方式的三种写法
传递的两种参数
params参数：属于路径中的一部分，需注意，在配置路由时，要先进行占位
query参数：不属于路径中的一部分，不需占位，类似ajax中的querystring，形如/search?k=&amp;kv=
1、字符串的方式 首先在路径中要进行params参数占位
{ path: "/search/:keyword", component: Search, meta: { show: true }, }, 同时传递params参数和query参数
goSearch() { // 第一种：字符串的形式 this.$router.push( "/search/" + this.keyword + "?k=" + this.keyword.toUpperCase() ); } 2、模板字符串
同时传递params参数和query参数
goSearch() { // 第二种：模板字符串 this.$router.push( `/search/${this.keyword}/?k=${this.keyword.toUpperCase()}` ); } 3、对象方式
此种方式必须加上name属性才可
{ path: "/search/:keyword", component: Search, meta: { show: true }, name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f43a870547f13f2450697c983631f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c78414e527371ce93ed2d988182563a/" rel="bookmark">
			excel多sheet导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * excel多sheet导出 */ public void exportSheetUsers () { List &lt;GysuserAndagentVo&gt; users=new ArrayList &lt;&gt; (); List &lt;GysexcelAgents&gt; agents=new ArrayList &lt;&gt; (); //功能描述：把同一个表格多个sheet测试结果重新输出， Workbook workBook=null; try { // 创建参数对象（用来设定excel的sheet1内容等信息） ExportParams userExportParams=new ExportParams ( ); // 设置sheet得名称 userExportParams.setSheetName ( "用户表" ); // 设置sheet表头名称 userExportParams.setTitle ( "用户列表" ); // 创建sheet1使用得map Map &lt;String, Object&gt; userExportMap=new HashMap &lt;&gt; ( ); // title的参数为ExportParams类型，目前仅仅在ExportParams中设置了sheetName userExportMap.put ( "title", userExportParams ); // 模版导出对应得实体类型 userExportMap.put ( "entity", GysuserAndagentVo.class ); // sheet1中要填充得数据 userExportMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c78414e527371ce93ed2d988182563a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30200be3fab84cace26e7eb5795ded8/" rel="bookmark">
			导入根据表头注解自动获取响应数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import com.picc.claimsource.excel.annotation.Excel; import io.swagger.annotations.ApiModelProperty; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; @Data @NoArgsConstructor @AllArgsConstructor @Builder public class ExcelDaoVo implements Serializable { private static final long serialVersionUID = 1L; /** 对应字段：id,备注：主键id */ @ApiModelProperty("主键id") @JsonSerialize(using= ToStringSerializer.class) private Long userid; /** 对应字段：grade,备注：角色 */ @ApiModelProperty("角色") @Excel( name="角色", width=15 ) private String grade; /** 对应字段：user_name,备注：用户姓名 */ @ApiModelProperty("用户姓名") @Excel( name="姓名", width=15 ) private String username; /** 对应字段：password,备注：用户密码 */ @ApiModelProperty("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d30200be3fab84cace26e7eb5795ded8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c88addc51ae405a4108f74d9874b27e/" rel="bookmark">
			cesium 使用entities、primitives添加的模型并且改变模型颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		entities方式绘制模型：【线条】
var gltf = viewer.entities.add({ guid: crossguid, name: 'gltf', polyline: { width: 1, material: Cesium.Color.WHITE, show: true, positions: Cesium.Cartesian3.fromDegreesArrayHeights(nodePositionArr), distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 10000) }, }); primitives方式添加模型：
viewer.scene.primitives.add( Cesium.Model.fromGltf({ id: feature.towerguid, url: '/model/' + _that.fileglb + '/' + feature.modelname + '.glb', // 本地文件 modelMatrix: towerMt4Tower, scale: 1, // 放大倍数 }), ) 通过鼠标右键点击模型使模型变颜色成选中状态：
// 鼠标右键获取属性 const handler = new Cesium.ScreenSpaceEventHandler(canvas); const canvas = Winviewer.scene.canvas; const ellipsoid = Winviewer.scene.globe.ellipsoid; handler.setInputAction(function (click) { // 禁止浏览器鼠标右键菜单 document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c88addc51ae405a4108f74d9874b27e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4284a76ad8bd3a8043826de2eef8bfdf/" rel="bookmark">
			如何录制微课？教师必看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几年微课已经在教育领域中逐渐普及，制作微课视频现在几乎是老师们的必备技能了，新手教师们看过来！
“微课”，是指基于教学设计思想，使用多媒体技术在五分钟以内就一个知识点进行针对性讲解的一段视频。
虽然视频只有5分钟，但是其中涵盖的知识点是非常重要的，它们可以是教材解读、题型精讲、考点归纳，也可以是教学经验等技能方面的展示。
微课录制的流程主要包括以下六个部分，让我们一个一个来分析。
选题教案编写制作课件教学实施与拍摄后期制作教学评价反思 选题 微课的选题是非常关键的开端，一个优秀的选题可以让讲解、录制更加轻松，不适合的选题也可能会让微课变得平凡乃至平庸。
我们选题时可以从这两个角度出发，一是抓住教学中的重点和难点，二是内容要适合用多媒体表达，也就是以视频/动画的形式表现出来。
教案编写 下一步，到了教学设计这一块。
虽然微课时间短，但是我们也不能小看了教学设计呀，良好的微课应该是循序渐进的，并且不同年龄段的学生认知方式和反应时间不同，也需要做一些调整。
并且，整个教学设计要能有效解决实际教学问题，调动学生的学习主动性，有针对性地解惑和启惑。
制作课件 PPT是老师们常用的一种内容展现形式，因为它可以图文结合，动画播放。但是PPT上不能堆砌所有微课的内容和知识点，我们只要挑选住核心内容即可，照本宣科的方式不可取！
如果是自己制作PPT的话，我们可以从这三点考虑。
PPT内容设计要有启发性；PPT内容设计要有悬念性；PPT需要给学生布置反思。 现在老师们做PPT是越来越卷了，不光内容要好，精致有趣也是非常重要的！所以我们可以充分利用网络资源，寻找合适的PPT教案模板，例如一块办公、第一PPT、优品PPT等。
教学实施与拍摄 接着，到了整个过程中最关键的一步，熟悉录屏软件并进行微课录制。
软件市场上有很多录屏工具。但是要说更适合教师录制微课的工具，野葱是个不错的选择，基本满足录制微课的所有要求，还自带剪辑功能哦
我们挑选录屏软件时，一定要注意这几点：
能同时录制屏幕和摄像头；能同时录制系统声音和麦克风声音；操作简单，可以随时暂停；视频清晰。 挑选好了，我们就能开始录制微课啦，将摄像头开启，放置在PPT左下角或右下角的位置，不要遮挡PPT内容，调整麦克风声音大小。
后期制作 录制好了视频，我们可以通过后期剪辑来让它更加精美一些，添加字幕，背景音乐，特效等等。最基础的要求就是整个视频要流畅，连贯，语速中等。
常用的剪辑软件有剪映、快影、快剪辑等等，老师们可以按需选择。
教学评价反思 微课的制作结束了，但是我们的工作还没有完全结束哦。
及时的教学反思是非常重要的，这样才能不断进步，制作出更加优秀的微课视频。我们也要积极听取其他教师和学生们的评价和反馈，思考这节微课的优点和缺点。
今天的分享到这就结束啦，希望能帮助各位老师，轻松完成微课录制！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4fa65acf9137367cb51eccb93999fd/" rel="bookmark">
			onnx模型 获取中间节点数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import onnx
import onnxruntime
model = onnx.load('simplenet.onnx')
#整个模型node添加到输出
#for node in model.graph.node:
# for output in node.output:
# model.graph.output.extend([onnx.ValueInfoProto(name=output)])
#指定node添加到输出
model.graph.output.extend([onnx.ValueInfoProto(name='288')])
sess = onnxruntime.InferenceSession(model.SerializeToString())
input_name = sess.get_inputs()[0].name
output_name = sess.get_outputs()[0].name
output1_name = sess.get_outputs()[1].name
#构造输入数据并推理
outputs = sess.run([output1_name], {input_name: input_data})
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8581476f998d766533289717365d27/" rel="bookmark">
			idea导入web项目教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea导入web项目教程 导入web工程
直接选择要打开的工程，new window
file—&gt;Project Setting—&gt;Project 注意选择jdk（我的是1.8版本）
file—&gt;Project Setting—&gt;Modules 配置工程的框架结构的。由于是web工程 把web.xml配置到Modules中
下一步添加web和spring
file—&gt;Project Setting—&gt;Modules 点击 + --&gt; Web Application:Exploded --&gt; From Modules，则建立了工程的部署WAR包。
下一步导入jar包
主要配置完成，将工程部署在web容器中（以tomcat为例）
到此启动成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf051eb4138a44879bcf2e721907e479/" rel="bookmark">
			使用Altium Designer进行钢网文件的生成和制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Altium Designer进行钢网文件的生成和制作 因为个人原因好久没有更新了，现在使用Altium Designer20进行讲解钢网文件的生成和制作。
这里我介绍的钢网文件就两种，一种是生成Gerber文件直接打包给厂家（可以参考往期生成Gerber文件的方法），由厂家判断哪些是贴片元器件哪些是插件元器件，他们会用焊盘层作为钢网开孔的大小； 另一种是用Mechanical 1（机械层1）作为钢网层，这样就可以直接区分贴片和插件元器件，现在要介绍的就是这种方法，这种方法可以根据元器件的实际引脚进行钢网开孔，可以提高焊接寿命。
一 不用焊盘层作为钢网层的原因 有些公司会对焊接好的PCB板进行冷热冲击实验，我公司是从-40℃到100℃循环，高低温各半小时，保证800个循环没有裂纹，或者性能没有太大变化。
如果焊盘加大焊锡量，能够有效增加焊接寿命，因此可以使用更厚的钢网增加厚度，也可以扩大焊盘，增加刷锡的面积，如下图钢网的开孔面积比焊盘要大一些，焊盘可以充分刷上锡膏。
注：
锡膏钢网的厚度0.1mm-0.15mm ，常规有0.1mm 0.12mm 0.13mm 0.15mm；
红胶钢网的厚度有0.18mm。
二 钢网层的制作 2.1 以贴片电阻为例，打开PCB封装库，找到电阻封装，可以直接复制焊盘然后改为Mechanical 1（机械层1），相应参数和位置进行更改，如下图更改前后对比；
2.2把改好的封装更新到PCB中，找到修改好的封装 》右击 》 Updata PCB With _____；
注：
Update PCB With All 针对所有元器件更新，尽量不要用！
2.3出现Component(s) / Attributes to Updata 对话框，点击OK；
2.4同样方法，更新其他元器件。
三 钢网文件的Gerber资料生成 3.1 打开PCB文件，File》Fabrication Outputs 》Gerber Files ，出现 GerberSetup对话框；
3.2 选择 General，点击 Millimeters 》4:4；
3.3 选择Layers，点击 Mirror Layers 》All off,选择 Mechanical 1和Keep-Out Layer；
3.3 选择 Layers，点击 Mirror Layers 》All off,选择 Mechanical 1和Keep-Out Layer；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf051eb4138a44879bcf2e721907e479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/840c4afed836eb7dc1de761619786393/" rel="bookmark">
			C&#43;&#43;程序设计基础实验-实验一 C&#43;&#43;简单程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验一 C++简单程序设计 一、实验目的 了解C++开发工具并学习使用。熟悉C语言、C++开发环境，使用VC 6.0 或 DEV C++等集成开发环境编写程序练习用C++编写基本顺序、选择和循环三种结构； 二、实验内容 编写程序判定给定年份是否为闰年。年份由键盘输入。有三个数整数x, y, z，从键盘输入，求三个数中的最大值。出一百分制成绩，要求输出成绩等级‘A’，‘B’，‘C’，‘D’，‘E’。90分以上为‘A’，80-89为‘B’，70-79分为‘C’，60-69分为‘D’，60分以下为‘E’。给出a,b 两个数的值，从键盘输入，将两个变量的值进行交换输出。给一个不多于5位和正整数，要求： 1）求出它是几位数 2）分别输出每一位数字 3）按逆序输出各位数字，例如原数为321，应输出123用do {…} while(); while() {…}; for () {…}三种循环求1+2+…+99+100的和。利用循环输出下列三个图形：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aXA8XtLi-1661240417734)(https://dn-simplecloud.shiyanlou.com/courses/uid1760929-20211002-1633160814109)]找出0-200之间的所有素数（素数又叫质数，是指在大于1的自然数中，除了1和它本身以外，不能被其他自然数整除的数。比1大但不是素数的数称为合数，1和0既非素数也非合数。）。编写程序，求解百钱买百鸡问题,母鸡3元一只 ,公鸡2元,小鸡 0.5元。编写程序，求两个整数的最大公约数和最小公倍数。 三、实验步骤及结果 编写程序判定给定年份是否为闰年。年份由键盘输入。
运行结果
有三个数整数x, y, z，从键盘输入，求三个数中的最大值。
运行结果
出一百分制成绩，要求输出成绩等级‘A’，‘B’，‘C’，‘D’，‘E’。90分以上为‘A’，80-89为‘B’，70-79分为‘C’，60-69分为‘D’，60分以下为‘E’。
运行结果
给出a,b 两个数的值，从键盘输入，将两个变量的值进行交换输出。
运行结果
给一个不多于5位和正整数，要求： 1）求出它是几位数 2）分别输出每一位数字 3）按逆序输出各位数字，例如原数为321，应输出123
运行结果
用do {…} while(); while() {…}; for () {…}三种循环求1+2+…+99+100的和。
运行结果
利用循环输出下列三个图形：
运行结果
找出0-200之间的所有素数（素数又叫质数，是指在大于1的自然数中，除了1和它本身以外，不能被其他自然数整除的数。比1大但不是素数的数称为合数，1和0既非素数也非合数。）。
运行结果
编写程序，求解百钱买百鸡问题,母鸡3元一只 ,公鸡2元,小鸡 0.5元。
运行结果
编写程序，求两个整数的最大公约数和最小公倍数。
运行结果
四、实验小结 问题与解决办法 编译出错，提示“ [Error] expected ‘;’ before ‘)’ token”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/840c4afed836eb7dc1de761619786393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d966ce4cacf9bdee59ee13b2923cdf/" rel="bookmark">
			手眼标定学习总结：原理、Tsai方法和Matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅用于记录自己学习手眼标定过程的一些总结。
目录 手眼标定基本原理求解AX=XBTsai方法Tsai的Matlab代码实现后记参考文献 手眼标定基本原理 符号统一：
T x y T_x^y Txy​或T_y_x表示将一个点从x系的坐标转移到y系的坐标，后面一律用T_y_x形式，方便编辑。
T_c_t：从target（棋盘格）坐标系到camera坐标系，从图像计算得到
T_g_c：从camera到gripper（机械臂末端坐标系），这是手眼标定需要求的参数
T_b_g：从gripper到base（机械臂基底坐标系），从机械臂运动学方程得到
T_b_t：从target到base，一般是未知无法计算的
计算时，由于T_b_t未知，所以无法直接求出T_g_c。但如果考虑增量（见下图），图中Hgij为G_ij，即gripper从第 i 个位置到 j 个位置，Hcij为C_ij，相机位置的增量（此图来自于参考文献[1]，H表示的是Homogeneous Transformation Matrix。且图中的Hcg为从camera到gripper，对应本文中的T_g_c）。红色和黄色最终表示同一个变换，所以此时有等式： G i j ∗ T g c = T g c ∗ C i j G_{ij} * T_g^c=T_g^c*C_{ij} Gij​∗Tgc​=Tgc​∗Cij​
最终camera和gripper达到多个位置后，得到多组 ij 对应关系，得到终极表达式： A X = X B AX=XB AX=XB
需要注意的是，X的含义与给的A和B有关。本文中，X为：T_g_c，A/B分别为G和C组成的 4 ∗ ( 4 ∗ N ) 4*(4*N) 4∗(4∗N)二维矩阵，即每4列为一个ij对应： G i = G ( 1 : 4 , i ∗ 4 − 3 : i ∗ 4 ) G_i = G(1:4, i*4-3:i*4) Gi​=G(1:4,i∗4−3:i∗4)（matlab写法）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d966ce4cacf9bdee59ee13b2923cdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6398c906a775b98db04a60b2995781c0/" rel="bookmark">
			Unity Resources.LoadAsync 优雅的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统写法中 Resources.LoadAsync("path")，保存回调ResourceRequest 开启一个协程或者定时器，每帧去判断一下 ResourceRequest.isDone是否完成，这样每写一句Resources.LoadAsync就得新增一个定时器，如果使用Resources.Load同步加载很大预制体时会卡顿掉帧，所以我们的程序员宗旨就是能躺着绝不站着。
经过我的修改，使用起来相当舒服，有以下特点：
1、减少后续繁琐的代码，减少重复代码，使用异步编程方式，一目了然，优雅实在是太优雅了。
2、还没想好。。。。。。。。。。。。。
缺陷：
1、如果是需要显示加载进度条的还是老老实实增加一个协程每帧获取进度吧。
首先是新建一个全局文件工具类：（可以直接复制）
using UnityEngine; using System.Threading.Tasks; using System.Runtime.CompilerServices; using System; public static class ExtensionsResources { public static ResourceRequestAwaiter GetAwaiter(this ResourceRequest request) =&gt; new ResourceRequestAwaiter(request); public static async Task&lt;T&gt; LoadResourcesAsync&lt;T&gt;(string path) where T : UnityEngine.Object { var gres = Resources.LoadAsync(path); await gres; return gres.asset as T; } } public class ResourceRequestAwaiter : INotifyCompletion { public Action Continuation; public ResourceRequest resourceRequest; public bool IsCompleted =&gt; resourceRequest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6398c906a775b98db04a60b2995781c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a76e04093a50ada06dcf1c964834863/" rel="bookmark">
			组件（模糊查询数据select下拉表单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;el-form ref="Ref" :model="Form" :rules="rulesForm" :disabled="zjdisabled" label-width="100px"&gt; &lt;el-row&gt; &lt;el-col :span="8"&gt; &lt;el-form-item prop="mzh" label="门诊号："&gt; &lt;el-select @change="(value) =&gt; handleSelect(value, 'mzh')" v-model="Form.mzh" filterable remote placeholder="请选择门诊号" :remote-method="(query) =&gt; remoteMethod(query, 'mzh')" :loading="loading"&gt; &lt;el-option v-for="item in options" :key="item" :label="item" :value="item" /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span="8"&gt; &lt;el-form-item prop="zyh" label="住院号："&gt; &lt;el-select @change="(value) =&gt; handleSelect(value, 'zyh')" v-model="Form.zyh" filterable remote placeholder="请输入住院号" :remote-method="(query) =&gt; remoteMethod(query, 'zyh')" :loading="loading"&gt; &lt;el-option v-for="item in zyhoptions" :key="item" :label="item" :value="item" /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a76e04093a50ada06dcf1c964834863/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e6dab4241371af4ad223e48781a373/" rel="bookmark">
			Mysql存储过程批量修改数据库中的表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 判断是否有相同的存储过程,有则删除
DROP PROCEDURE IF EXISTS test;
// 创建存储过程
CREATE PROCEDURE test()
//存储过程开始
BEGIN
//定义一个标记,初始默认值是0,目的是为了循序list
DECLARE flag INT DEFAULT 0;
//定义一个变量,后面在拼接SQL时使用
DECLARE id VARCHAR(100);
//前半部分是创建一个list集合,把后面select出来的数据放到集合中去循环
//我这边是查出来所有的表中含有某个字段的表名
DECLARE idList CURSOR FOR SELECT table_name FROM information_schema.columns WHERE TABLE_SCHEMA = ‘zwpan_mes’ AND COLUMN_NAME=‘project_name’;
//相当于hasNext 找到下一个标记
DECLARE CONTINUE HANDLER FOR NOT FOUND SET flag = 1;
//打开游标 开始循环
OPEN idList;
//取出游标中的值,放在变量里
FETCH idList INTO id;
//开始循环
WHILE flag != 1 DO
//拼接SQL
SET @execSql = CONCAT(‘UPDATE ‘,id,’ SET project_name = “测试12345” WHERE project_id = 544’);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63e6dab4241371af4ad223e48781a373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa8c2891a35e085dd5c97b068e3fe30/" rel="bookmark">
			linux--用户、组、权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
系统用户文件
1、创建用户
2、修改用户权限
3、设置密码
4、删除用户
5、文件内容详解
6、查看用户ID
系统组文件
1、创建组
2、修改组
3、删除组
4、管理组成员
系统文件权限
系统文件权限属组
1、修改文件的属组
2、修改文件归属者
3、修改文件权限
4、文件acl
系统文件特殊权限
1、SetUID
2、SetGID
3、SBIT
🍤：好好复习，不整花里胡哨的了。
说到用户组权限，可以想像成windows操作系统一样，同样都是基于用户身份来控制对资源的访问，每个用户账户都有唯一的用户名与密码，只是个别细节方面存在一些差异。
系统用户文件 系统文件路径：
/etc/passwd 用户信息文件
/etc/shadow 用户密码文件
1、创建用户 格式如下：
useradd [选项] 用户名 -u 指定用户的uid
-g 指定用户的基本组
-G 指定附属组，可以有多个， 但是这些附属组必须是系统内已经存在的
-c 指定描述
-d 指定家目录
-M 不建立家目录
-s 指定shell
-e 指定用户过期时间， 日期
-f 指定用户过期时间， 天数
2、修改用户权限 针对已有用户修改属性（和创建用户相同），格式如下：
usermod [选项] 用户名 -u 指定用户的uid
-g 指定用户的基本组
-G 指定附属组，可以有多个， 但是这些附属组必须是系统内已经存在的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa8c2891a35e085dd5c97b068e3fe30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aff569361fc6cf253b00b41507e41726/" rel="bookmark">
			CSS伪类选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我们之前的介绍中提到了CSS中的几种选择器其中就有伪类选择器，那么这篇文章就给大家介绍一下这种独特的选择器。
在学习过程中总觉得基础巩固不好，那有可能就是理论没有得到很好的实践，亲自将代码实现出来才能更容易掌握所学，比如刷题就是一个很好的选择，边学边练，学完即练！
牛客网
https://www.nowcoder.com/exam/oj?page=1&amp;tab=HTML/CSS&amp;topicId=260&amp;fromPut=pc_csdncpt_wlxfd_qianduan
静态伪类选择器 该选择器只能用于链接，它的属性有link和visited，其中link属性表示连接被访问之前，visited表示连接被访问之后。
举个栗子~
我们访问两个网站，对比一下网站在被访问之前和被访问之后在浏览器中默认情况下呈现的样子：
我们可以看到访问前后的链接颜色发生改变，那么如何把链接在被访问之前和被访问之后的颜色设定一个指定的颜色呢，这就需要用到静态伪类了。
&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;静态伪类选择器&lt;/title&gt; &lt;style type="text/css"&gt; a:link{ color:green; }/*链接被访问之前的样子*/ a:visited{ color: #00BFFF; }/*链接被访问后的样子*/ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt; &lt;a href="https://www.bilibili.com/"&gt;B站&lt;/a&gt; &lt;/body&gt; 这样就把颜色指定了。
可能这时候就有疑问了，既然可以更改链接被访问前后的颜色，那么字体可以改变吗？我们再举个栗子，上代码：
a:visited{ color: #00BFFF; font-size: 20px； } 运行结果：
假如我们想要将链接被访问后的字体大小做更改，发现是没有任何变化的，这是因为保护隐私。如果我们要改变链接被访问之前的字体大小，会出现什么呢？
a:link{ color:green; font-size: 50px; /*链接访问之前的样子*/ } 我们发现无论是访问前的还是访问后的链接，字体都发生改变。
动态伪类选择器 动态伪类的取值有：
:hover “悬停”：鼠标放到标签上的时候
:active “激活”： 鼠标点击标签，但是不松手时。
&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;动态伪类&lt;/title&gt; &lt;style type="text/css"&gt; h1:hover{ color: #00BFFF;font-size: 50px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;百度&lt;/h1&gt; &lt;h2&gt;百度&lt;/h2&gt; &lt;/body&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aff569361fc6cf253b00b41507e41726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d22270773319782bc1db855aa2ef18/" rel="bookmark">
			10万字208道Java经典面试题总结(附答案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍅 作者简介：哪吒，CSDN2021博客之星亚军🏆、新星计划导师✌、博客专家💪
🍅 哪吒多年工作总结：Java学习路线总结，搬砖工逆袭Java架构师
🍅 技术交流：定期更新Java硬核干货，不定期送书活动
🍅 关注公众号【哪吒编程】，回复 面试题 ，获取《10万字208道Java经典面试题总结(附答案)》pdf，背题更方便，一文在手，面试我有
前言 最近有很多粉丝问我，有什么方法能够快速提升自己，通过阿里、腾讯、字节跳动、京东等互联网大厂的面试，我觉得短时间提升自己最快的手段就是背面试题，最近总结了Java常用的面试题，分享给大家，希望大家都能圆梦大厂，加油，我命由我不由天。
目录
1、JDK 和 JRE 有什么区别？
2、== 和 equals 的区别是什么？
3、final 在 java 中有什么作用？
4、java 中的 Math.round(-1.5) 等于多少？
5、String 属于基础的数据类型吗？
6、String str="i"与 String str=new String(“i”)一样吗？
7、如何将字符串反转？
8、String 类的常用方法都有那些？
9、new String("a") + new String("b") 会创建几个对象？
10、如何将字符串反转？
11、String 类的常用方法都有那些？
12、普通类和抽象类有哪些区别？
13、接口和抽象类有什么区别？
14、java 中 IO 流分为几种？
15、BIO、NIO、AIO 有什么区别？
16、Files的常用方法都有哪些？
17、什么是反射？
18、什么是 java 序列化？什么情况下需要序列化？
19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？
20、throw 和 throws 的区别？
21、final、finally、finalize 有什么区别？
22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d22270773319782bc1db855aa2ef18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ccf76daf0b46390e35ea08719fbd312/" rel="bookmark">
			.NET/C#获取十五日天气预报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来为大家提供一个获取天气的一个接口方法并且返还到页面上，通过前端代码显示出来本次的代码量不多，完全可以直接复制粘贴如果除了什么问题大家可以在下方评论留言！ 1、首先我们要获取到天气的AP链接地址，链接地址如下，我们可以去这个网站去拿： 免费天气API，天气JSON API，不限次数获取十五天的天气预报 —技术博客
上方这个网站会会有天气的API地址并且会初步的教您如何使用 ↑
2、在上方我们拿到天气的api后，网站里还会给我们提供哥哥城市的一个ID我们查找是通过ID来查找的，当然也可以转换成名字大家可以自己转换。下面这个链接是上面那个网站里面给咱提供的城市数据：大家可以通过方法把数据添加到数据库中，也可以只用自己需要城市的按需求用： 城市数据： 请在百度网盘下载：链接: https://pan.baidu.com/s/1JFAwnH2MRLc5OD3hsJZwGQ 提取码: u8sk 3、我们在获取上面两个东西后我们就可以开始进行项目的编写了，下面我来教大家如何获取天气并显示：首先我们需要新建一个.net的项目。新建一个控制器咋里面添加一个index页面：index页面的内容我给大家贴在下方直接复制： @{ ViewBag.Title = "天气"; Layout = "~/Views/Shared/_Layout.cshtml"; } &lt;style&gt; .laytable-cell-1-ImgUrl { height: 100%; max-width: 100%; } .xm-form-select { width: 180px; } &lt;/style&gt; &lt;div class="container mt-3"&gt; &lt;h2&gt;天气&lt;/h2&gt; &lt;form action="" id="form1" runat="server"&gt; &lt;div class="mb-3 mt-3" id="bbb"&gt; &lt;label class="form-label"&gt;城市编号:&lt;/label&gt; &lt;label class="form-label"&gt;&lt;/label&gt; &lt;input type="text" class="form-control" id="city" placeholder="Enter city number" value="101030100" name="CityNumber"&gt; &lt;/div&gt; &lt;button type="button" id="obtain" class="btn btn-primary" &gt;获取&lt;/button&gt; &lt;/form&gt;&lt;br /&gt; &lt;table class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ccf76daf0b46390e35ea08719fbd312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c05449cee032522879ebc9adeed72cc/" rel="bookmark">
			docker之仓库原理6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 docker之仓库原理6 docker 系列文章目录docker公有仓库docker私有仓库registry docker公有仓库 默认使用的是官方的仓库,官方仓库的网址：https://hub.docker.com
可以在docker官方的公共仓库上面注册自己的账号并且分享自己的封装好的镜像
docker私有仓库registry 从私有仓库拉取以及上传的原理：
docker客户端通过Indx认证后，index给docker拉取仓库位置（仓库有很多个），以及token，docker访问仓库并给仓库token，仓库用docker客户端的token与index校验，校验成功后同意docker客户端拉取。
从私有仓库拉取以及上传的原理流程图
删除完镜像后，registry还要告诉indx要同步信息，在索引里面删掉该镜像。
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f62dc68484d4ac97f94898a4459866a/" rel="bookmark">
			小程序分享给好友以及分享到朋友圈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：小程序分享给好友或者朋友圈仅需我们使用微信自带的API，分享到朋友圈的前提是需要我们允许分享给好友，其次才可以分享到朋友圈，功能简单话不多说直接上官方API链接和代码。 一、分享给好友 wx.onShareAppMessage(function callback) | 微信开放文档 (qq.com)
我们直接使用官方API：onShareAppMessage onShareAppMessage: function(res) { if (res.from === 'button') { // 来自页面内转发按钮 console.log(res); } return { title: '现在注册还送全场8折优惠劵，无消费门槛', imageUrl: 'https://guacheng.fanwan.net.cn/applet/tools/newSharePic.png', path: '/pages/startPage/startIndex?userInviteCode=' + this.userQRcode, } }, 其中的参数需要我们使用return，title是分享给好友的标题，imageUrl是我们分享内容图片的链接，path是我们的分享点入的页面路径，其中path是可以带参数的。 这时我们分享给好友功能已经完成，如果需要通过页面的button按钮来进行分享给好友需求，则直接使用特定的button如下open-type="share"即可，样式可以自行覆盖编写：
&lt;button type="default" open-type="share"&gt;分享给好友&lt;/button&gt; 面对面扫码功能也不难，后台生成带参数的二维码后，我们可以使用微信开发者工具通过二维码编译，（我们需要注意的是扫码二维码的时候是直接进入我们线上发布的正式服的，所以就无法进行测试，因此我们可以在生成二维码的时候通过开发工具的二维码编译，就可以根据我们开发的代码进行编译了） 然后正常的在onload（）生命周期中获取参数，小程序应用级别的生命周期的onLaunch（）中也可以获取到 二、分享到朋友圈 Page(Object object) | 微信开放文档 (qq.com)
​ onShareTimeline: function(res){ return { title: '现在注册还送全场8折优惠劵，无消费门槛', //字符串 自定义标题 query: 'id=1', //页面携带参数 imageUrl:'https://guacheng.fanwan.net.cn/applet/tools/newSharePic.png' //图片地址 } ​ 这里我们也是用官方API：onShareTimeline，但是需要注意分享到朋友圈需要我们先允许分享给好友，并且值得注意的是分享到朋友圈是不能自定义路径的，并且限制较多，不建议将交互复杂的界面进行分享，官方文档的说明亦是如此。 同时分享到朋友圈的功能不支持我们使用自定义按钮，只能通过点击小程序右上方的胶囊位（个人反正是没有找到能够直接分享到朋友圈的按钮实现方式） ，至于分享的界面也和小程序内部有所不同，详情见下图（找了一个拼多多的案例），点击右下角的前往小程序则会前往当前浏览的小程序界面，（例如浏览的商品详情页则直接跳转到详情页，对应的参数是支持我们带参的）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/128/">«</a>
	<span class="pagination__item pagination__item--current">129/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/130/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>