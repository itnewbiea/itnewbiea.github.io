<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447d46a8199e78a269122fc1b6fec926/" rel="bookmark">
			otsu阈值分割算法原理_大津法---OTSU算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
大津法(OTSU)是一种确定图像二值化分割阈值的算法，由日本学者大津于1979年提出。从大津法的原理上来讲，该方法又称作最大类间方差法，因为按照大津法求得的阈值进行图像二值化分割后，前景与背景图像的类间方差最大(何为类间方差？原理中有介绍)。
OTSU算法
OTSU算法也称最大类间差法，有时也称之为大津算法，由大津于1979年提出，被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。它是按图像的灰度特性,将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量,背景和前景之间的类间方差越大,说明构成图像的两部分的差别越大,当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。
原理：
对于图像I(x,y)，前景(即目标)和背景的分割阈值记作T，属于前景的像素点数占整幅图像的比例记为ω0，其平均灰度μ0；背景像素点数占整幅图像的比例为ω1，其平均灰度为μ1。图像的总平均灰度记为μ，类间方差记为g。
假设图像的背景较暗，并且图像的大小为M×N，图像中像素的灰度值小于阈值T的像素个数记作N0，像素灰度大于阈值T的像素个数记作N1，则有：
ω0=N0/ M×N (1)
ω1=N1/ M×N (2)
N0+N1=M×N (3)
ω0+ω1=1　(4)
μ=ω0*μ0+ω1*μ1 (5)
g=ω0(μ0-μ)^2+ω1(μ1-μ)^2 (6)
将式(5)代入式(6),得到等价公式:
g=ω0ω1(μ0-μ1)^2 (7)　这就是类间方差
采用遍历的方法得到使类间方差g最大的阈值T,即为所求。
matlab函数：
matlab中函数graythresh既是使用大津法求得分割阈值Ｔ。用法如下：
T = graythresh(img);
BW = im2bw(img,T);
大津法的形象理解：
对于直方图有两个峰值的图像，大津法求得的Ｔ近似等于两个峰值之间的低谷。
imhist(img);
T = graythresh(img);
如下图为图像的直方图，使大津法求得的Ｔ＝0.5294，转换在［0,255］之间为134.9970，只好是两个峰值之间低谷的位置。
OpenCV的二值化操作中，有一种“大津阈值处理”的方法，使用函数cvThreshold(image,image2,0,255,CV_THRESH_OTSU) 实现，该函数就会使用大律法OTSU得到的全局自适应阈值来进行二值化图片，而参数中的threshold不再起作用。
以下是一段在OpenCV中实现的C语言程序，即一个使用OTSU算法提取图像阈值的函数，输入参数为一个图像指针，返回分割该图像的最佳阈值。
其中的变量说明：当分割的阈值为t时
w0为背景像素点占整幅图像的比例
u0为w0平均灰度
w1为前景像素点占整幅图像的比例
u1为w1平均灰度
u为整幅图像的平均灰度
公式:g = w0*pow((u-u0),2) + w1*pow((u-u1),2)
int MyAutoFocusDll::otsuThreshold(IplImage *frame)
{const int GrayScale = 256;int width = frame-&gt;width;int height = frame-&gt;height;intpixelCount[GrayScale];floatpixelPro[GrayScale];int i, j, pixelSum = width * height, threshold = 0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447d46a8199e78a269122fc1b6fec926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42fb6ef56e7c9c7776b373945eea83cc/" rel="bookmark">
			vue如何输出一个值_怎么在控制台打印出来data里想要的数据？  Vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qq_心疼_1
2018-07-11 14:42
function userSave(){
var forms=document.getElementById("forms");
var ipts=document.getElementsByTagName('input')
var arr = [];
for(var i=0;i
if(!ipts[i].value){
alert("您有信息未填写")
return false
}else{
var arr={};
for(var i=0;i
arr[i]=ipts[i].value
}
}
}
console.log(arr)
$.ajax({
type : "POST", //提交方式
url : "table.php",//路径,www根目录下
data: {
"json":arr
},
DataType:"json",
success : function() {
alert("提交成功");
console.log(this.data);
}
});
for(var j=0;j
ipts[j].value=""
}
return false
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2876dc6d0019259ed7a0b0c82eef6212/" rel="bookmark">
			LC串联谐振的意义-MOS管栅极G串联电阻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B站对应视频：
LC串联谐振的意义-LC滤波器-MOS管G极串联电阻作用
我一直有一个感觉：咱们硬件工程师，会遇到各种各样的问题，亦或是各种各样的现象，总会有一个非常简单的解释，一句话或者是几句话，我们见多了这个解释，就自以为明白了，当别人再问起我们的时候，我们也会拿这句话去给别人解释。
比如说，寄生电感这个字眼就经常出现，特别是引线电感。我们解释一些问题的时候都是直接套用的，默认它的存在。可实际上是，我在很长一段时间内并不理解它到底是怎么来的，因为我印象中电感都是线圈，而直导线并不是。直到之前不久我才思索了一番，算是有一些了解，也写了下面一篇文章。
寄生电感怎么来的
最近一直在看电感和磁珠的内容，也有看LC滤波器，自然会有LC谐振的问题。LC串联谐振，单独拿出来说的话，可能会觉得太简单了，这有啥好说的。自然是因为实际应用中会出现各种各样的场景，尽管都是谐振，但是表现各不相同。
先来思考下这么几个问题：
电路中不必要的LC串联谐振要绝对杜绝吗？
MOS管G极经常串联一个小电阻，说是可以抑制振荡，啥原理呢？这个电阻阻值怎么取呢？
电源上面加上磁珠，结果纹波变大了，只能换0Ω电阻来解决吗？有没有其它的解决方法？
这几个问题，如果你明白了LC串联谐振的分析方法，那么自然都不在话下了。
LC串联谐振电路
尽管LC串联谐振电路非常简单，我们还是来看下，这样一步一步深入会更好的理解。
一个电感和一个电容串联，在某个特定的频率，就会发生谐振，这个频率就是谐振频率。串联谐振电路有如下特点：
谐振时整个电路阻抗呈电阻性，阻抗最小，电流达到最大；
谐振时电感和电容两端的电压达到最大。
上面这些理论都是非常基础的，就不赘述。实际电路的场景要远比这个要复杂，搞清楚那些才是我们的目的。那么我们下面就来结合具体的场景。
LC滤波器
LC滤波器经常用，但有一个比较坑的问题就是，有时候使用LC滤波器之后，效果反而更差了，还不如不用。
原因我们当然可以说是在噪声在此处谐振啦，噪声被放大了之类的。曾经的我也会这么说原因，不过并不是真的明白，对于这种会起反效果的东西，我会惧怕，会担心它出问题。这种惧怕，来源于对未知的恐惧，因为没有懂。现在下面来具体分析下
首先，我们需要明白，噪声是如何被放大的?也就是说输出比输入幅度要大？
先来看最简单的模型，也就是理想器件模型的情况。
我们列出输出与输入的比值，也就是增益，如果增益大于1，那么说明被放大了。很容易列出增益的公式，我们画下这个曲线。
上图的曲线，是1uH电感，1uF电容的增益。可以看到，在低频时，增益基本就是1，也就是不放大不衰减。而在谐振频率处，有一个非常高的尖峰，因为这里设定的器件为理想器件，所理论上尖峰为穷大，谐振频率旁边的增益也是非常高的，而在频率比较高的时候，随着频率的升高，增益下降，也就是衰减了输入信号。
如果我们能把谐振频率处的增益降到0.707左右，那就是完美的低通滤波器了。很显然，电感和电容都是非耗能器件，没有电阻器件的引入，在谐振频率处，增益总是等于无穷大的。我们从增益Av的公式就可以得出来，因为谐振频率时的分母为0。
幸运的是，我们的滤波电路总是要接负载的，我们把信号滤波之后总是要给负载用的，接入了负载，那增益又不一样了。
不同负载的LC滤波器
现实中的电路各种各样，负载的阻抗也就差别很大了，下面是加入负载的模型。
我们看看负载是1Ω，10Ω，100Ω的增益曲线，如下图：
我们可以看到，负载电阻越小，谐振处的增益越小，谐振引起的噪声变大越不会发生。当然了，实际电路中的负载各种各样，有低阻的，有高阻的。相对来说，低阻负载的更不容易发生加入滤波器效果更差的事情。因此，如果你发现同样的LC滤波器，加入不同的电路，有的效果好，有的效果变差，很有可能就是因为负载的不同。
所以说，负载阻抗越低，越不容易产生尖峰，也就是说不容易恶化。
噪声源内阻的影响
除了负载阻抗的影响，还有噪声源内阻的影响，实际的噪声信号肯定是有一定的内阻的。根据内阻的不同，我们构建下面的模型，加入内阻的参量。
分别画出Rs=0.1Ω，Rs=1Ω，Rs=10Ω的情况，为了排除负载电阻的影响，宁其为高阻态，统一RL=1MΩ。
可以看到，内阻越大，越不容易产生尖峰，也就是说不容易恶化，反之，内阻越小，越容易恶化。
L、C的值的影响
除了内阻和负载大小，电感和电容值的大小有没有影响呢？
电容变化：电容分别为1uF，10uF，100uF，内阻，负载，电感都为Rs=0.1，RL=1MΩ，L=1uH。
可以看到，电容增大，尖峰变小，也就是说，在遇到谐振引起噪声增大的情况，可以尝试增大电容是可以降低噪声。不过需要注意，尖峰变小，只是说最高点变小了，但是引起了谐振频率降低，新的谐振点可能还是要比原来的增益更高，也就是说如果噪声正好是这个频率段，那么改变之后效果变更差了。当然了，如果我们加更大的电容，即使是谐振点都没有放大作用，比如如果电容加到100uF，整个频段基本都没有放大作用了。
实际电路具体加到多大的电容，完全不会出现尖峰呢？这个跟信号源内阻Rs，负载阻抗RL，电感值L都有关系。实际上，如果内阻Rs从0.1提升到1，电容不用增大到100uF，即使是原来的1uf也不会有尖峰，曲线就不画了。
电感变化：电感分别为0.01uH，0.1uH，1uH，内阻，负载，电容都为Rs=0.1，RL=1MΩ，C=1uF
可以看到，减小电感，可以降低尖峰的高度。我们如果继续减小电感到0.01uH，尖峰也会消失。同样的，电感变化会造成谐振频率移动，具体是使噪声变大还是变小也是要依情况而定，与内阻，负载，电容都有关系。
总的来说，大部分电路增大电容，或者减小电感，都可以降低尖峰。如果LC滤波器用于电源滤波发生噪声变大，可以增大电容，或者减少电感。
这里之所以说大部分电路，是因为如果满足一定的Rs，RL的条件，可能结果是相反的，这个可以自己修改Matlab代码（后文分享出来）里面的参量，执行下就知道了。
MOS管G极串联电阻如何抑制谐振
有了以上的基础，我们来看实际的问题：MOS管G极串联电阻如何抑制谐振？
这个问题，我们首先要明白，问题是如何产生的，即为什么会振荡？其实通过前面的铺垫，也就很明白了。
这个是典型的MOS管驱动电路，串联了10Ω电阻。
尽管从电路图上看去，上面既没有电感，也没有电容。但实际上是，我们PCB总要将线从驱动芯片拉到MOS管，我查了一下，线宽12mil，长度10mm的走线寄生电感是9.17nH。实际电路中10mm走线太正常了，所以寄生电感肯定是存在的。
电感有了，电容呢？功率MOS管都有输入电容存在，并且还不小，小的几百pF，大点的几nF。我们只是为了说明道理，那取电容1nF吧。
一般来说，左边驱动管子发出开关信号，它的内阻一般不会很大，尽管现在不知道它到底是多大，那就按照比较恶劣的情况来看，就让Rs=0.1Ω。
那么负载电阻是多大呢？负载是MOS管，那阻抗就很大了，就取RL=1MΩ。
看看现在的等效电路：
从前面内容知道，源内阻越小，负载阻抗越大，就越容易产生谐振尖峰。我们画出此时曲线。
可以看到，谐振频率52Mhz处增益达到了好几十倍。而MOS管驱动信号可以看作是一个阶跃信号，频率分量非常丰富，肯定有52Mhz附近的频率。
所以说确实会发生谐振。
现在分别串联1Ω，10Ω，100Ω电阻，这个电阻可以等效到内阻里面去，相当于等效电路变成了Rs=1.1Ω，Rs=10.1Ω，Rs=100.1Ω，其它参数不变。我们再看看曲线。
可以看到，串联1Ω电阻，还是放大，最大到3倍，说明电阻稍小。而10Ω电阻就能完全消除振荡了。100Ω电阻也能完全消除振荡，但是其截止频率更低，会造成驱动信号的高频分量丢失，最终上升沿变缓，也就是MOS管开启的时间变长。
相信到这里，对于这个串联电阻的作用，已经怎么取值应该就比较清楚了。G极走线越长，寄生电感越大，越容易引起问题，电阻就要选得更大些。
从文章开头，一路看下来，这也太费劲了，确实，明白这些也不是很容易，很多时候，我们都是拿着厂家的原理图来抄抄，也不会有问题。等到有新人问到“这个电阻干什么用的？”老员工答曰“抑制振荡”，是啊，这四个字，每个字都认识，是不是总有一种模模糊糊的感觉呢？希望看完此文之后不再模糊。
Matlab源码
上面所有的曲线图，Matlab源码都在这个里面了，我已经把每个图对应的代码分开来了，有7部分，全部复制过去可以一次执行得到7个图。也可以把其中的一个复制出去执行，都是可以的。代码里面的注释写得也比较清楚，可以自行去修改Rs，RL，L，C的值。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %---理想LC低通滤波器增益 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% f=[1000:100:100000000]; %频率：范围1Khz-10Mhz w=(f.*pi*2); %角频率 C=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2876dc6d0019259ed7a0b0c82eef6212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714b9a1ada8b037b0e7472d0c5d91573/" rel="bookmark">
			cv::Mat与unsigned char*相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. cv::Mat转unsigned char* cv::Mat image = cv::imread("1.jpg"); unsigned char *data = image.data; 2. unsigned char*转cv::Mat 说明：nBandNum表示图像buffer是几通道的，例如四通道的rgba，三通道的rgb；
nBPB表示图像的位深是8位还是16位的，默认为8位；
cv::Mat bufferToMat(unsigned char* pBuffer, int nWidth, int nHeight, int nBandNum, int nBPB) { cv::Mat mDst; if (nBandNum == 4) { if (nBPB == 1) { mDst = cv::Mat::zeros(cv::Size(nWidth, nHeight), CV_8UC4); } else if (nBPB == 2) { mDst = cv::Mat::zeros(cv::Size(nWidth, nHeight), CV_16UC4); } } else if (nBandNum == 3) { if (nBPB == 1) { mDst = cv::Mat::zeros(cv::Size(nWidth, nHeight), CV_8UC3); } else if (nBPB == 2) { mDst = cv::Mat::zeros(cv::Size(nWidth, nHeight), CV_16UC3); } } else if (nBandNum == 1) { if (nBPB == 1) { mDst = cv::Mat::zeros(cv::Size(nWidth, nHeight), CV_8UC1); } else if (nBPB == 2) { mDst = cv::Mat::zeros(cv::Size(nWidth, nHeight), CV_16UC1); } } for (int j = 0; j &lt; nHeight; ++j) { unsigned char* data = mDst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714b9a1ada8b037b0e7472d0c5d91573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542138fe552fc9554c68517f089dfec6/" rel="bookmark">
			matlab中rand函数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rand作用：产生(0,1)之间均匀分布的随机数和矩阵。主要由输入的参数决定。
randn作用：生成标准正态分布的伪随机数（均值为0，方差为1）.语法和rand一样
语法作用x=rand返回区间（0，1）内均匀分布的随机数rand(n)返回n*n的随机矩阵rand(m,n) 或rand([m,n]返回m*n的随机矩阵rand(sz1,sz2,szN)返回由随机数组成的sz1*sz2*…*sz维数组rand(size(A))返回和A由相同尺寸的随机矩阵x=rand(__,typename)返回由typename数据类型的随机生成的数据 .typename可以是‘single’或’double’rand(___,‘like’,p)返回由P等随机数组组成的数组；也就是p统一对象类型。可指定typename或‘like’，但不能同是指定两者 PS:公式：r=a+(b-a).*rand(N,1)生成区间（a,b）内的N个随机数
&gt;&gt; x=rand x = 0.9058 &gt;&gt; x=rand(2,3) x = 0.1270 0.6324 0.2785 0.9134 0.0975 0.5469 &gt;&gt; x=rand(2,3,4) x(:,:,1) = 0.9575 0.1576 0.9572 0.9649 0.9706 0.4854 x(:,:,2) = 0.8003 0.4218 0.7922 0.1419 0.9157 0.9595 x(:,:,3) = 0.6557 0.8491 0.6787 0.0357 0.9340 0.7577 x(:,:,4) = 0.7431 0.6555 0.7060 0.3922 0.1712 0.0318 &gt;&gt; rand(1,4,'single') ans = 1×4 single 行矢量 0.2769 0.0462 0.0971 0.8235 &gt;&gt; a=-5+(5+5)*rand(10,1) %产生（-5，5）之间的随机数 a = -3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542138fe552fc9554c68517f089dfec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37995fc5e2a24166a8139e7803f52935/" rel="bookmark">
			联想拯救者y7000加内存条_【详细教程】联想拯救者Y7000p内存条升级、安装教程...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【详细教程】联想拯救者Y7000p内存条升级、安装教程
https://www.zhihu.com/video/1175128704178704384 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67187ab4e7da3e361f44f9472326fa65/" rel="bookmark">
			二叉查找树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉查找树 定义基本实现查找插入删除返回特定位置的键 分析代码 定义 二叉查找树是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。二叉查找树得以广泛应用的一个重要原因是它能够保持键的有序性，因此它可以作为实现有序符号表 API 中众多方法的基础，这是计算机科学中最重要的算法之一。
一棵二叉查找树（BST）是一棵二叉树，其中每个节点都含有一个 Comparable 的键（以及相关联的值），且每个节点的键都大于其左子树中的任意节点的键而小于右子树的任意节点的键
基本实现 和链表一样，在类中定义一个私有结构体来表示二叉查找树的一个节点，每个节点都含有一个键、一个值、一条左链接、一条右链接和一个节点计数器。左链接指向一棵由小于该节点的所有键组成的二叉查找树，右链接指向一棵由大于该节点的所有键组成的二叉查找树。
一棵二叉查找树代表了一组键（及其相应的值）的集合，而同一个集合可以用多棵不同二点二叉查找树表示。
struct Node { Key key; Value val; Node *left = nullptr, *right = nullptr; int N; Node(Key key, Value val, int N) : key(key), val(val), N(N) {} }; 查找 我们很容易想到用递归的形式来进行查找。一般来说，在符号表中查找一个键可能得到两种结果，如果含有该键的节点在表中，就命中，然后返回相应的值。否则查找未命中，返回 nullptr。如果树是空的，则查找未命中，如果被查找的键和根节点的键相等，查找命中，如果被查找的键较小，选择左子树，较大选择右子树。
Value get(Node *x, Key key) { if (x == nullptr) return " "; if (x-&gt;key &gt; key) return get(x-&gt;left, key); else if (x-&gt;key &lt; key) return get(x-&gt;right, key); else return x-&gt;val; } 插入 如果树是空的，就返回一个含有该键值对的新节点，如果被查找的键小于根节点的键，我们会继续在左子树中插入该键，如果被查找的键大于根节点的键，就在右子树中插入该键，如果相等，则更新值。并增加路径上每个节点中计数器的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67187ab4e7da3e361f44f9472326fa65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160b8f8ed9086f99e50e88102382f637/" rel="bookmark">
			html 设置两个标签的相对距离_如何给两个div之间设置一个间距？html
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
设置两个div之间的间距32313133353236313431303231363533e59b9ee7ad9431333431353432的方法：先定义两个div，div里面分别有一段话。
2.分别给两个div加上不同的背景色，方便看到div的位置。
3.设置div的margin；使两个div之间的间距扩大。
这样让两个div之间的间距扩大的问题就解决了。
扩展资料：
div常用属性
1.Height:设置DIV的高度；Width:设置DIV的宽度。
2.margin:用于设置DIV的外延边距，也就是到父容器的距离。margin:后面跟有四个距离分别为到父容器的上-右-下-左边的距离；margin: [top][right][bottom][left]
3.padding:用于设置DIV的内边距(内如子元素与DIV边界的距离)。padding:后面跟有四个距离分别为到父容器的上-右-下-左边的距离；
4.border:设置DIV的边框样式；
5.background:设置DIV的背景样式；background后可直接跟背景的颜色、背景图片、平铺方式等样式。
6.position:设置DIV的定位方式。position的属性中有static、fixed、relative、absolute四个属性。常用relative和absolute。
7.display:设置显示属性。其值有block、none；
8.float:设置DIV在页面上的流向，其值有left(靠左显示)、right(靠右显示)、none；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2de6efd04fec2077b3f68e211694873/" rel="bookmark">
			transform导致溢出_保持溢出：will-change之后的隐藏行为：transform
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I have a parent and a child elements:
.parent {
will-change: transform;
overflow: hidden;
position: absolute;
}
.child {
position: fixed;
top: 80px;
left: 80px;
}
without will-change:transform style, .child element regardless of parent's position and overflow:hidden will be positioned based on window.
Now that the .parent has this style, not only top and left of .child calculate from .parent, but also overflow:hidden applies on .child too.
It seems that position:fixed will be totally ignored if we add will-change:transform
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2de6efd04fec2077b3f68e211694873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447b113447642e0bfa6372ef62e59305/" rel="bookmark">
			发那科机器人圆弧指令怎么用_发那科机器人应用-运动指令入门（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看懂机器人运动指令
1.运动类型
J：Joint----关节
L: Linear---直线
C: Clrcular---圆弧
A: Clrcle Arc--- C圆弧
2.位置数据
P[ ]：一般位置
Eg： J P[1] 100% FINE
PR[ ]：位置寄存器
Eg： J PR[1] 100% FINE
3. 速度单位
对应不同的动作类型速度单位不同：
J：%，sec，msec
L、C、A：mm/sec，cm/min，inch/min，deg/sec，sec，msec
4. 定位类型
定位类型总共有两种：
精确定位 FINE
连续定位 CNT(0-100)
4.1 精确定位 FINE
机器人在目标位置停止后，向着下一个目标位置移动
图9：定位类型为FINE 图示
4.2 连续定位 CNT
根据CNT定位类型，机器人靠近目标位置，但是不该在该位置做停顿，机器人走CNT定位类型的点位的时候近似走了一个倒角。
当机器人速度一定，CNT值越大，倒角越大。
图10：速度一定，CNT值影响轨迹变化
注意：
1. 在指定了CNT的动作语句后，如有等待指令等，机器人会在拐角部分的轨迹上停止，执行该指令。
2. 在CNT方式下连续执行距离短而速度快的多个动作的情况下，即使CNT的值为100，也会导致机器人减速。
关注并私信我，发送文字“电气工程师”即可获取精品电气工程师全套考试学习资料链接：https://pan.baidu.com/s/1IYUzDxCRmwj1R3mVl3opwg
提取码：reen
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8c6dd0a3eee445b6ae0e88645a62ea/" rel="bookmark">
			Lager输出成html格式的日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 lager是erlang和exlir的一个日志库，输出格式支持自定义，可以通过额外插件扩展将日志输出成html格式，这样异常日志从颜色上就可以明显的看出来，方便调试
使用 库已经上传了hex库，可以通过以下3种方式中任一使用
mix 中加入{:lager_html, "~&gt; 0.0.1"}rebar.config 的deps 中加入 {lager_html, "0.0.1"}erlang.mk 中加入 dep_lager_html = hex 0.0.1 如果hex下载失败，按照rebar.config中的deps格式从github上直接下载
GitHub链接
配置了依赖后，需要修改一些环境变量配置
可以选择直接将以下内容加入到src/lager.app.src 的env字段中
也可以加入到自己项目的 env文件中
[ {log_root, "./log"}, {handlers, [ {lager_file_backend, [ %% 日志文件前缀，全名是 File++Date.html {file, "error_log"}, %%debug=128, info=64, notice=32, warning=16, error=8, critical=4, alert=2, emergency=1, none=0 {level, info}, {formatter, lager_log_html_formatter}, %% 字符串格式，可选值，使用lager_log_html_formatter后默认模板会改成以下内容 %% {formatter_config, ["&lt;div&gt;&lt;font size=\"2\" color=", html_color, "&gt;\n== ", date, " ", %% time, " ===", sev, "(", pid, module, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8c6dd0a3eee445b6ae0e88645a62ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36533472c5456c758b4c3572d5a217bc/" rel="bookmark">
			iphone图片编辑画笔_苹果手机截屏后怎么编辑，这么实用你可一定要知道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在使用iPhone手机的小伙伴的越来越多了，不少小伙伴都因为iPhone手机的好用而成为了iPhone手机的粉丝。我们在用iPhone手机的时候，少不了要用其进行截图，但是大家可能不知道，我们用iPhone手机截完图以后，还可以直接对图片进行编辑呢。今天就让我们一起来看看iPhone手机截屏后怎么编辑吧，保证你用就停不下来~
一、手机截屏
1.物理键截屏
我们在使用iPhone手机截屏的时候，很多小伙伴都会使用最简单的手机物理按键组合进行截屏。同时按下【home键】和【电源键】，我们就可以快速完成iPhone手机的截屏操作。
2.小白点截屏
除了用手机组合键进行截屏之外，我们也可以通过小白点进行截屏。我们只需要在手机【设置】-【通用】中，点击【辅助功能】，在里面找到【辅助触控】，然后在【自定顶层菜单】中将【屏幕快照】添加进去。这样的话，我们在需要截屏的时候，就可以打开小白点，然后选择里面的【屏幕快照】就可以立即截屏了。
二、截屏编辑
当我们将手机屏幕截下来以后，就可以直接使用iPhone手机提供的编辑功能，对图片进行涂鸦、添加签名等等的操作。
1.涂鸦
我们在截完屏以后，如果有小伙伴需要对图片进行涂鸦操作的话，我们就可以利用iPhone手机中提供的【画笔工具】对图片进行涂鸦，颜色、画笔粗细都是可以自己选择的。
2.添加签名水印
有的时候，如果我们想要给截下来的图片添加一些水印、签名之类的内容的话，我们就可以直接在图片编辑功能中点击【+】，然后选择里面的【签名】选项，接着我们就可以直接手写下签名，在确定以后，签名水印就会出现在图片中，我们根据自己的需要进行位置的调整就可以了。
3.放大器
如果我们的截屏照片中有自己想要突出的元素部分的话，我们还可以通过iPhone手机截屏编辑功能中的【放大器】功能来帮我们进行这样的操作。点击【+】-【放大器】，这样我们就可以根据自己的需要对图片中的某一个部分进行放大，放大多少我们也是可以直接调节的。
好啦，以上就是iPhone手机截屏后怎么编辑的操作方法了，相信大家都有所了解了吧，有需要的小伙伴就去试一试吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c33b0f40249306e07b0990767541541/" rel="bookmark">
			iphone图片编辑画笔_iPhone手机最好的图片编辑软件有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		895675713
2019-07-20 17:16
1046
随着Dennis强势入手iPhone之后，编辑部群里面每天增加了一项固定话题——关于iPhone的种种讨论。虽然iPhone拍照能力的确赶不上现在的卡片相机，但在各种各样强大的软件支持下，iPhone能够变成一个非常有趣的随拍武器。而且有些效果是卡片机无法达到的！
如果您对上述说法持疑态度的话，那么接下来我们所给您介绍的这十款软件必定让您彻底折服。但在您安装上这些软件之后，我相信您会非常喜欢iPhone的拍照功能。可能再让您拿着卡片相机的时候，您会发现原来卡片机拍的照片是那样无趣啊！
iPhone图片处理软件之一：Color Splash
iTunes Store售价：1.99美元
选择一张您喜欢的照片，通过这款软件可以轻松地将整个画面变成灰色，接下来就可以根据您自己的喜好和想象力来给部分区域填充颜色了——天空整个一遍火烧云、海水颜色由蓝变绿，这些您都可以Touch一下来实现。如果您想让照片看起来更富有艺术效果，Color Splash同样可以办到。当然，整个过程都相当简单，只需要动手点一点就完成。您可以在这里下载此款软件。
iPhone图片处理软件之二：Camera Bag
iTunes Store售价：2.99美元
如果您喜爱复古风格的话，在iPhone中安装Camera Bag简直就太对啦。因为Camera Bag所具有的1962和1974等年代风格能很容易地将照片染上复古的元素。另外，如果手上没有Polaroid SX-70相机但又喜欢其风格的话，Camera Bag同样能行。您可以在这里下载此款软件。
iPhone图片处理软件之三：TiltShift
iTunes Store售价：2.99美元
在手中没有昂贵的移轴镜头情况下，我们多多少少都会借助于Photoshop强大的处理能力来模拟出虚景照片。如果您使用过Photoshop模拟移轴镜摄影效果的话，肯定会对繁琐的操作记忆犹新。但TiltShift软件则让这一切操作变成“娱乐”，通过多点触摸画出圆圈，而圆圈以外的场景就会模糊化。移轴镜摄影效果是不是出现在眼前呢。您可以在这里下载此款软件。
iPhone图片处理软件之四：Photo fx
iTunes Store售价：2.99美元
假如您是一位不折不扣的器材控，那么没有理由不熟知美国Tiffen的众多败家滤镜产品。当然，我们可不是让您也给iPhone装上一片Tiffen所出品的滤镜。只是想告诉您，经过一番对Photo fx软件的精心调整，您的照片也能够呈现出像加装了Tiffen滤镜一样的效果。更重要的是，您只需要花费2.99美元甚至于根本不需要一分钱，就能将多种滤镜纳入包中。您可以在这里下载此款软件。
iPhone图片处理软件之五：Magic Touch
iTunes Store售价：0.99美元
Magic Touch是一款功能上最接近于Photoshop的软件，通过Magic Touch可以方便地对照片的颜色、对比度和饱和度等参数进行简单调整。并能够给照片添置一些令人难以忘记的效果。试想一下，手指在iPhone触摸屏上轻盈地舞动一番，一片阳光明媚的天空就突然变得乌云密布是一件多么有趣的事儿。
iPhone图片处理软件之六：Oil Canvas
iTunes Store售价：免费
如果您长时间使用Camera Bag，肯定要不了多久就会对复古的照片风格产生厌倦感。这时候，不妨考虑一下油画这种充满艺术气息的表现方式。当然，在处理之前您也要有一定心理准备。那就是图案可能比较抽象，有可能导致您一眼认不出照片中的美眉竟是自己女友。您可以通过iTunes方便下载此软件。
iPhone图片处理软件之七：Stachetastic
iTunes Store售价：0.99美元
好吧，我承认Stachetastic是一款恶搞类型软件。不过，您不觉得生活中就是要有那么一点适当的恶搞才会更加充满生机与活力吗？Stachetastic软件允许您将打扮的干干净净的男子变成一位从来不修边幅的旷世奇才。当然，您完全可以在他头上弄上两个犄角。不过，在您发出“改造”成果之前一定考虑一下朋友心理素质如何。
iPhone图片处理软件之八：Pano
iTunes Store售价：2.99美元
当眼前出现一幕美丽的景象时，您可能会为iPhone不能将其尽收眼底而感到苦恼。不过，这只是在没有安装Pano软件之前的烦恼。当安装上Pano之后，您可以将六张照片拼接成一张像素高达3,600X600的全景照片。而且Pano使用过程也相当容易，完成第一张照片拍摄后您便可以接着拍摄第二张，以此类推。而Pano会在取景屏左边的一小块儿区域中显示前一张照片内容，以方便拍摄者调整取景范围来对齐这两张照片。您可以在这里下载此款软件。
iPhone图片处理软件之九：PanoLab
iTunes Store售价：免费
我可以拍着胸口告诉大家，Pano和PanoLab绝对不是同一款软件的不同称呼！虽然两者有着极为近似的名字，但在功能方面有着不同的侧重点。PanoLab能够让使用者轻松实现Picasa 3中的拼贴功能——将“无数张”(因为还没有发现其上限数)有关或无关的照片以各种各样原生态方式拼凑在一起，这其实是件蛮有意思的事儿。此外，PanoLab还能像Pano一样，实现多张相关联照片的无缝拼接。您可以通过iTunes方便下载此软件。
iPhone图片处理软件之十：PhotoKeys Photoshop Remote
iTunes Store售价：3.99美元
就在本文即将结束之时，如果您仍旧没有找到一款能令您满意的处理软件，那我只能说您的要求太高了，还是直接用Photoshop吧。不过，这并不意味着用Photoshop处理图片就不干iPhone事儿了。在PhotoKeys Photoshop Remote软件帮助下，iPhone摇身一变成了Photoshop好伴侣。当您iPhone添置上这款软件并在PC或Mac安装上对应服务器端的话，就可方便地通过iPhone快捷键盘调用Photoshop工具。帮助您更加高效快捷的用Photoshop来处理图片。PC/Mac服务器端程序下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e96f33816def2fb2eb1cb8d75d66f9a/" rel="bookmark">
			虚拟机开机出现dracut_安装CentOS 7的时候出现dracut:/#求解决方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
安装CentOS 7的时候出现“dracut:/#”解决方法：62616964757a686964616fe59b9ee7ad9431333365643661
1，这是因为安装程序未能找到安装文件，无法加载所致。
2，可以在随后出现的 dracut:/# 输入命令 cd /dev后找到安装文件所在的位置，重启后修改(在启动引导的地方输入 e 进入编辑状态)启动配置，将vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet 改为：vmlinuz initrd=initrd.imginst.stage2=hd:/dev/sda quiet其中 /dev/sda 是安装文件所在U盘在系统中的设备号。然后继续回车，即可正常进入安装过程。
CentOS(Community Enterprise Operating System，中文意思是:
社区企业操作系统)是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6fbf3f8a37e4fd307323bd5ed98ae84/" rel="bookmark">
			C&#43;&#43;版本OpenCv教程(六)namedWindow函数&amp;imshow函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 图像窗口函数namedWindow图像显示函数imshow 图像窗口函数namedWindow 在我们之前的程序中并没有见到窗口函数，因为我们在显示图像时如果没有主动定义图像窗口，程序会自动生成一个窗口用于显示图像，然而有时我们需要在显示图像之前对图像窗口进行操作，例如添加滑动条，此时就需要提前创建图像窗口。创建窗口函数的原型。
void cv::namedWindow(const String &amp; winname,int flags = WINDOW_AUTOSIZE) winname：窗口名称，用作窗口的标识符flags：窗口属性设置标志 该函数会创建一个窗口变量，用于显示图像和滑动条，通过窗口的名称引用该窗口，如果在创建窗口时已经存在具有相同名称的窗口，则该函数不会执行任何操作。创建一个窗口需要占用部分内存资源，因此通过该函数创建窗口后，在不需要窗口时需要关闭窗口来释放内存资源。OpenCV提供了两个关闭窗口资源的函数，分别是cv::destroyWindow()函数和cv :: destroyAllWindows()，通过名称我们可以知道前一个函数是用于关闭一个指定名称的窗口，即在括号内输入窗口名称的字符串即可将对应窗口关闭，后一个函数是关闭程序中所有的窗口，一般用于程序的最后。不过事实上，在一个简单的程序里，我们并不需要调用这些函数，因为程序退出时会自动关闭应用程序的所有资源和窗口。虽然不主动释放窗口也会在程序结束时释放窗口资源，但是OpenCV 4.0版本在结束时会报出没有释放窗口的错误，而OpenCV 4.1版本则不会报错。
该函数的第一个参数是声明窗口的名称，用于窗口的唯一识别，第二个参数是声明窗口的属性，主要用于设置窗口的大小是否可调、显示的图像是否填充满窗口等，具体可选择的参数及含义在表2-4中给出，默认情况下，函数加载的标志参数为“WINDOW_AUTOSIZE | WINDOW_KEEPRATIO | WINDOW_GUI_EXPANDED”。
图像显示函数imshow 我们在前面已经见过了图像显示函数imshow()的调用方式，这里我们给出函数的原型。
void cv::imshow(const String &amp; winname,InputArray mat) winname：要显示图像的窗口的名字，用字符串形式赋值mat：要显示的图像矩阵 该函数会在指定的窗口中显示图像，如果在此函数之前没有创建同名的图像窗口，就会以WINDOW_AUTOSIZE标志创建一个窗口，显示图像的原始大小，如果创建了图像窗口，则会缩放图像以适应窗口属性。该函数会根据图像的深度将其缩放，具体缩放规则为：
如果图像是8位无符号类型，则按照原样显示如果图像是16位无符号类型或者32位整数类型，则会将像素除以256，将范围由[0,255*256]映射到[0,255]如果图像时32位或64位浮点类型，则将像素乘以255，即将范围由[0,1]映射到[0,255] 函数中第一个参数为图像显示窗口的名称，第二个参数是需要显示的图像Mat类矩阵。这里需要特殊说明的是，我们看到第二个参数并不是常见的Mat类，而是InputArray，这个是OpenCV定义的一个类型声明引用，用作输入参数的标识，我们在遇到它时可以认为是需要输入一个Mat类数据。同样，OpenCV对输出也定义了OutputArray类型，我们同样可以认为是输出一个Mat类数据。
注意 此函数运行后会继续执行后面程序，如果后面程序执行完直接退出的话，那么显示的图像有可能闪一下就消失了，因此在需要显示图像的程序中，往往会在imshow()函数后跟有cv::waitKey()函数，用于将程序暂停一段时间。waitKey()函数是以毫秒计的等待时长，如果参数缺省或者为“0”表示等待用户按键结束该函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a0f06fec45c2fa41dfcd75222547fe/" rel="bookmark">
			【2020.12】Aspose.words 20.12最新版Crack，word转pdf去水印方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个需求是提供word文档预览和转PDF的功能，预览计划是先word转图片做预览，试了几款软件，最终选用Aspose.words工具，但是试用版会自动加水印，下附去水印教程，仅提供思路参考。
先在官网下载最新版20.12的jar包，选择jdk17的后缀。在项目中使用maven导入aspose.words转PDF有水印。
&lt;dependency&gt; &lt;groupId&gt;com.aspose&lt;/groupId&gt; &lt;artifactId&gt;aspose-words&lt;/artifactId&gt; &lt;version&gt;20.12&lt;/version&gt; &lt;classifier&gt;jdk17&lt;/classifier&gt; &lt;/dependency&gt; 测试代码为
然后加入设置License的代码找到关键逻辑，在License.class中发现最终都会调用com.aspose.words.zzZDZ#zzV这个方法，进到这个类，把zzV方法下方的com.aspose.words.zzZDZ#zzZ4n和com.aspose.words.zzZDZ#zzZ4m通过javassist反编译把返回值改成1再重新打包回jar就可以去水印了
项目中引入javassis
&lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.27.0-GA&lt;/version&gt; &lt;/dependency&gt; 破解代码
@Test void crackAsposeWords() throws Exception { ClassPool.getDefault().insertClassPath("C:\\Users\\coder\\Downloads\\aspose-words-20.12-jdk17.jar"); CtClass zzZJJClass = ClassPool.getDefault().getCtClass("com.aspose.words.zzZDZ"); CtMethod zzZ4u = zzZJJClass.getDeclaredMethod("zzZ4n"); CtMethod zzZ4t = zzZJJClass.getDeclaredMethod("zzZ4m"); zzZ4u.setBody("{return 1;}"); zzZ4t.setBody("{return 1;}"); zzZJJClass.writeFile("C:\\Users\\coder\\Desktop\\"); } 运行后会生成一个com的文件夹，里面就包含了修改过的字节码
解压aspose-words-20.12-jdk17.jar，把上述生成的文件夹覆盖到解压出的com文件夹，再把META-INF文件夹里的.RSA和.SF文件删除即可
最后把破解后的字节码文件重新打包为jar，取名为aspose-words-20.12-jdk17-crack.jar(取名随意)
进到解压后的文件夹根目录执行下述命令
jar cvfm aspose-words-20.12-jdk17-crack.jar META-INF/MANIFEST.MF com/ 把生成的破解包引入项目中，发现jar包中的那两个方法的返回值确实已经被修改了，再进行转PDF发现水印不存在，亲测可用。记录一下，后续最新版也按照这个方法破解以支持word版本升级引起的兼容性问题。
对了，如果是放在Linux服务器上运行，需要在服务器上安装Windows中文字体库，否则会有中文乱码问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7953b02b207d724c5888fac46aa6944/" rel="bookmark">
			斯特拉森(Strassen)算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		斯特拉森(Strassen)算法简介 先借用一下百度百科：
简单解释 通俗的说，斯特拉森算法把原先普通二阶矩阵相乘需要的8次乘法压缩到7次乘法，而在计算机，乘法运算的耗时远远高于加减运算，所以斯特拉森算法可以将O(d^ 3) 压缩到O(d^2.8)。
需要知道的是，斯特拉森算法只是对矩阵分治的算法而不是单独的乘法算法，分治完成时最后使用的还是普通矩阵乘法，在阶数小于等于32（或者64？看过不同的实验结果）时普通的矩阵乘法会有更快的速度，而随着矩阵的阶不断增加，斯特拉森可以提供更快的速度。
一些拓展 在这里，提供另外一种形式的斯特拉森：
同样是通过代数的分解与合并，我们构造出另外一种看起来更复杂的算法。这次我们分解出的项数更多，意味着拓展性更高，于是我们在求矩阵平方时有了新的改进。
矩阵的平方-斯特拉森 我们只需要沿用之前图中的2.s。然后7次乘法使用上图方法，便可以减少一部分的预运算，而上图中，我们依然有P1P2P3可以递归入经过平方优化的斯特拉森算法，获得更快的速度。
C语言描述斯特拉森标准模板 第一个部分我们先来写核心思路。
int Strassen(int N, int **MatrixA, int **MatrixB, int **MatrixC) {int HalfSize = N/2; int newSize = N/2; int nsize=N/2; int i=0,j=0; int newLength=0; newLength = newSize; if ( N &lt;= 32)//choosing the threshold is extremely important, try N&lt;=2 to see the result { MUL(MatrixA,MatrixB,MatrixC,N); } else {int** A11; int** A12; int** A21; int** A22; int** B11; int** B12; int** B21; int** B22; int** C11; int** C12; int** C21; int** C22; int** M1; int** M2; int** M3; int** M4; int** M5; int** M6; int** M7; int** AResult; int** BResult; }//此处省略动态内存的申请，最后也省略了内存的释放 for (i = 0; i &lt; N / 2; i++) { for (j = 0; j &lt; N / 2; j++) { A11[i][j] = MatrixA[i][j]; A12[i][j] = MatrixA[i][j + N / 2]; A21[i][j] = MatrixA[i + N / 2][j]; A22[i][j] = MatrixA[i + N / 2][j + N / 2]; B11[i][j] = MatrixB[i][j]; B12[i][j] = MatrixB[i][j + N / 2]; B21[i][j] = MatrixB[i + N / 2][j]; B22[i][j] = MatrixB[i + N / 2][j + N / 2]; } } //here we calculate M1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7953b02b207d724c5888fac46aa6944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d836df9269d24c1cc6502db7a382266b/" rel="bookmark">
			激光雷达——目标识别（滤波、分割、聚类，包围盒）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		激光雷达——目标识别（滤波、分割、聚类，包围盒）
参考地址：https://github.com/williamhyin/SFND_Lidar_Obstacle_Detection
压缩包SFND_Lidar_Obstacle_Detection-master.zip在百度网盘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b83b48a9d1c3cbd42f8f2a78fb5c3056/" rel="bookmark">
			幅值与峰峰值的计算_峰峰值定义_示波器峰峰值怎么看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		峰峰值定义
峰峰值是指一个周期内信号最高值和最低值之间差的值，就是最大和最小之间的范围。它描述了信号值的变化范围的大小。峰值是以0刻度为基准的最大值，有正有负。而峰峰值是最大值和最小值的差值，只有正的。
正弦波峰峰值计算
峰峰电压Vpp=垂直偏转因数(V/div) &amp;TImes;信号波形在垂直方向所占格数。
示波器峰峰值怎么看
一、对于模拟示波器：
用示波器测量信号的电压峰-峰值和周期时，把波形峰-峰值高度调到显示屏高度的80%左右，把一个周期的宽度调到显示屏宽度的80%左右。再通过垂直位移使时间轴落在水平中心刻度线上，并微调到波峰和波谷落在水平刻度线上；通过水平位移使一个周期波形的起点落在垂直刻度的零刻度线上，并微调到一个周期波形的终点落在垂直刻度线上。
二、对于数字示波器：
1、自动测量：
自动测量最简单，可以说是傻瓜式的，按一下自动测量键，全都搞定。
数字示波器显示的波形都是峰峰波形；如果是其测量参数，那就可以按“MEASURE”/“测量键”，示波器屏侧或下方会有软键，按“幅度”参数，翻页找“峰峰电压”即可。
2、手动测量：
先按上述第一点调节，然后开启捕捉功能。
(1)选择垂直测量，把两条光标线分别移到波峰和波谷，可自动读取峰-峰值。
(2)选择水平测量，把两条光标线分别移到一个周期波形的起点和终点上，即可自动读取周期数据。
对数字示波器测量不是很熟练者，建议选用自动测量功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414827180a53e336701cbaea013ac4d4/" rel="bookmark">
			java笔试完一般多久给通知_笔试之后多久收到面试通知？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔试之后3-15天收到面试通知是正常的。不过不同分行安排进度不同，也有可能考完试第二天就收到面试通知啦！像2019农行春招的深圳分行就是在笔试完第二天发送面试通知的，这点小伙伴们要特别注意哦~
等待面试通知时该做什么？
知道大概的面试通知时间你就放心了？可千万不要大意！等面试通知时你就应该开始着手准备啦！机会永远留给有准备的人！该提前准备些什么呢？
1、提前准备面试物品，调整好心态
首先，你得有一套得体的西服，最好自己去实体店上身试一下！小姐姐们也要想一想面试当天的妆容搭配哦~俗话说，颜值即正义！一个得体的穿搭和妆容，会在无形当中为你加很多分~
今年受疫情影响，很多银行会选择线上面试，此时的设备也非常重要！大部分的银行招聘考试都需要摄像头进行身份验证，所以如果你的电脑没有摄像头，哪怕它跟了你四五年，也是时候说再见啦！
心态上则要戒骄戒躁，切忌过分紧张！凡事放平常心，也许还会有意外的收获呢~
2、了解面试的大概流程，多加练习
银行面试不同于其他企业的面试，它有一套相对固定的面试形式和流程：半结构化面试和无领导小组讨论(这个不许不知道哦！)有一点相同的是，它们都需要自我介绍！一个好的自我介绍是面试成功的第一步！在准备时不如好好想一想怎么让自己的自我介绍更出彩哦~
Q
请你谈谈管理与领导的区别
专业解析：
第一,管理侧重于处理复杂的问题,优秀的管理者通过制定详细的步骤或时间表及监督计划实施的结果而确保目标的达成.领导主要处理变化的问题,领导者开发未来前景,发展出达到前景的变化战略,并与员工进行有效地沟通,激励他们克服困难实现目标.
第二,管理的计划与预算强调微观方面,覆盖的时间范围约为几个月到几年,希望降低甚至排除风险,追求的是合理性.领导注重宏观方面,着重于更长的时间范围,不排斥带有一定风险性的战略。
第三,管理行为的从业人员强调专业化,领导行为的从业人员注重于综合素质和整体能力。
第四,领导与管理的根本区别体现在它们的功用上,管理行为通常具有很强的可预测性,以有效地维持秩序为目标;领导行为则具有较大的可变性,能带来有益的变革。
重中之重！面试还要注意学练兼备！除了了解之外，你还需要练习，比如对镜练习自我介绍的语气呀、找好朋友一起模拟面试呀，都能更快地帮你掌握面试技巧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6c77ad74f18cf44ff6022fa85ad1b6/" rel="bookmark">
			es6 嵌套数组循环_在与ES6深度嵌套的对象的javascript数组中寻找价值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在对象数组中，我需要找到value-- key是activity：但是，activity key可以将其深深地嵌套在数组中，如下所示：
const activityItems = [
{
name: 'Sunday',
items: [
{
name: 'Gym',
activity: 'weights',
},
],
},
{
name: 'Monday',
items: [
{
name: 'Track',
activity: 'race',
},
{
name: 'Work',
activity: 'meeting',
},
{
name: 'Swim',
items: [
{
name: 'Beach',
activity: 'scuba diving',
},
{
name: 'Pool',
activity: 'back stroke',
},
],
},
],
},
{} ...
{} ...
];
因此，我编写了一个递归算法来确定数组中是否存在某个活动：
let match = false;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be6c77ad74f18cf44ff6022fa85ad1b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152a458bee838a772f9947ea887a1cc0/" rel="bookmark">
			大一微积分笔记整理_大一微积分知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微积分知识是高等数学的一个重要知识点，本文就来分享一篇大一微积分知识点总结，希望对大家能有所帮助！
微积分定理：---
若函数f(x)在[a,b]上连续，且存在原函数F(x)，则f(x)在[a,b]上可积，且
b(上限)∫a(下限)f(x)dx=F(b)-F(a)
这即为牛顿—莱布尼茨公式。
牛顿-莱布尼茨公式的意义就在于把不定积分与定积分联系了起来，也让定积分的运算有了一个完善、令人满意的方法。
微积分常用公式：---
熟练的运用积分公式，就要熟练运用导数，这是互逆的运算，下满提供给大家一些可能用到的三角公式。
微积分基本定理：---
(1)微积分基本定理揭示了导数与定积分之间的联系，同时它也提供了计算定积分的一种有效方法．
(2)根据定积分的定义求定积分往往比较困难，而利用微积分基本定理求定积分比较方便．
题型：
已知f(x)为二次函数，且f(-1)=2，f′(0)=0，f(x)dx=-2，
(1)求f(x)的解析式；
(2)求f(x)在[-1，1]上的最大值与最小值．
解：
(1)设f(x)=ax2+bx+c(a≠0)，
则f′(x)=2ax+b，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099168bef445a60de5258f286b5624dc/" rel="bookmark">
			C语言 扫雷游戏地雷数计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 扫雷游戏是一款十分经典的单机小游戏。它的精髓在于，通过已翻开格子所提示的周围格地雷数，来判断未翻开格子里是否是地雷。
现在给出n行m列的雷区中的地雷分布，要求计算出每个非地雷格的周围格地雷数。
注：每个格子周围格有八个：上、下、左、右、左上、右上、左下、右下。
Input 第一行包含两个整数n和m，分别表示雷区的行数和列数。1 &lt;= n &lt;= 100, 1 &lt;= m &lt;= 100。
接下来n行，每行m个字符，‘*’表示相应格子中是地雷，‘？’表示相应格子中无地雷。字符之间无任何分隔符。
Output n行，每行m个字符，描述整个雷区。若相应格中是地雷，则用‘*’表示，否则用相应的周围格地雷数表示。字符之间无任何分隔符。
Sample Input 3 3 *?? ??? ?*? Sample Output *10 221 1*1 Source Code #include&lt;stdio.h&gt; int b[101][101]={0}; char a[101][101],t; int main() { int n,m; int i,j,i1,i2,j1,j2; scanf("%d %d",&amp;n,&amp;m); scanf("%c",&amp;t);	//先输入一个字符，正好把后面敲的空格给填上 for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=m;j++) { scanf("%c",&amp;a[i][j]); if(a[i][j]=='*') { //有*在b数组中对应相邻八个位置各加1 i1=i-1; i2=i+1; j1=j-1; j2=j+1; b[i1][j1]++; b[i1][j2]++; b[i1][j]++; b[i2][j1]++; b[i2][j2]++; b[i2][j]++; b[i][j1]++; b[i][j2]++; } } scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/099168bef445a60de5258f286b5624dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7473d265eec6160177f61a24df77ec3d/" rel="bookmark">
			mac建立sftp连接_Mac连接服务器及对文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mac下连接服务器可使用两种方法：
1.输入命令：ssh @，例如：ssh root@139.196.1.1即可
2.打开终端，选择新建远程连接：
选择 安全Shell(ssh)，然后输入ip地址及配置信息
二：下载和上传文件
1:scp
下载：scp root@139.196.1.1:/data/a.java /documents
上传：scp /documents/a.java root@139.196.1.1:/data
下载和上传文件夹，在scp后加 -r，如 scp -r /documents root@139.196.1.1/data
注意，本地文件路径和服务器文件路径之间由空格区分
2:sftp(ftp)
打开shell，并且选择新建远程连接，选择安全文件传输(sftp)，选择服务器地址，输入密码
下载：get /data/a.java /documents　(前为服务器路径，后为本地下载路径)
上传：put /documents/a.java /data　(与上面相反)
scp和sftp方式并无太大的区别，scp较为轻便，功能单一，sftp支持传输中断后继续传输，一般传输大文件，使用sftp较多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd317e85151dc97190e26c0ac404fd79/" rel="bookmark">
			引用账户锁定无法登录_锁定电脑后重登录，出现“引用账户当前已锁定，且可能无法登录”提示。是怎么回事？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
解决方法1：
出现提示错误后62616964757a686964616fe58685e5aeb931333431343063不要再继续操作，也不用关机，等30分钟后再输入原来密码，就可以登录进入系统了。若提示密码错误，而不是“引用的帐户当前已锁定”，那就是密码错误问题，就需要另外解决不要再尝试了。若30分钟后输入密码仍出现锁定提示，或者你等不及30分钟，那么可用第2种解决方法。
解决方法2：(若系统登录界面可以切换别的帐户，比如管理员帐户，则用别的帐户登录进入，则跳过步骤1，或可视为直接解决了问题。)
步骤1：系统重新启动，按F8进入安全模式，在安全模式下输入密码，可正常进入系统，不受锁定限制。
步骤2：进入“控制面板”-》“管理工具”-》“本地安全策略”，在左侧栏“安全设置”中，选择“帐户策略”-》“帐户锁定策略”，右侧栏出现“帐户锁定时间【默认30分钟】”、“帐户锁定阈值【默认5次无效登录】”、“重置帐户锁定计数器【默认30分钟】”三种策略(三种策略的含义可双击后查看其说明)。双击“帐户锁定阈值”，将默认的“5次无效登录”改为“0”次。确定退出界面。
重启系统，输入正确密码登录进入，解决问题。为安全考虑，正常登录系统后，最好将“帐户锁定阈值”再改回默认的“5次无效登录”(另两项相应自动改为默认值)。
出现“引用的帐户当前已锁定”的原因：
通过“解决方法2”可以清楚知道出现锁定问题的原因，是因为自己误操作(或其他人操作)在30分钟内连续5次输入错误密码造成的，而你在锁定后等30分钟以上再输入正确密码，则自行解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b254c977cfec2d7c7296c3f35aa668ce/" rel="bookmark">
			catia v56r与v5r21区别_caita V5 R21 新增功能概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		造型
CATIA V5R21带给汽车工业车身设计顶级品质的曲面，CATIA Imagine &amp; Shape带来超级的用户体验
CATIA Imagine &amp; Shape(想像与造型)，基于细分曲面技术的虚拟粘土建模器，提供世界级的曲面工具满足车身造型细节的需要，如面向设计人员的切割面更高级的可用性工具。设计人员还能够在创建阶段利用实时渲染视觉反馈。这使得CATIA Imagine &amp; Shape完全适用于汽车工业中的车身设计。
CATIA V5R21实现功能完备性和V5-V6特征等同: CATIA Icem产品CATIA V5R21扩展在A级建模领域里的高级而强大的自由形式曲面建模、修改和分析功能。V5R21具备更高效的验证造型品质的工具，能够提高制作的曲面的品质。由于提供嵌入一个合适的用户界面的专门的建模环境，用户的效率以及工作流也得到改善。这对V5R19、V5R21和V6R2012特征集的对齐提供了补充
CATIA V5R21具备Loft命令增强持续提高机械曲面划分设计技术Loft命令得到增强，用于定义弯曲里的连续性(G2)，具备截面支持或向导支持，而之前仅有切线连续得到支持。这个新的功能提高Loft的品质，因为您能够精确定义您想要哪一个连续性用于截面和向导。另一个改进是使您能够创建一个曲面并一下子就搞好端点。在Loft命令中，一个截面和在一个端点两条彼此交会的向导曲线就足以创建造型，这能够提高生产效率。
机械
CATIA V5R21增强CATIA Sketcher以获得上下文设计的更高的精确度由于现在存在于反射线或内剖面与产品造型之间的新的关联性，CATIA Part Design(零件设计)能够节省概念设计阶段的时间。您然后可以利用来自3D面/特征的关联轮廓的二维几何细节精确地精制一个设计。这个视图中包含的区域还能够被用于显示一个特殊的治理区域。投影和交叉曲线带给用户相同的能力。
CATIA V5R21通过外部的二维格式增强概念研究数据的交换概念研究可以从二维遗留数据开始，具备DXF和DWG文件的直接输入，将每一个二维层的内容处理纳入一个特殊的表格中。然后可以利用叠加的表格研究概念，以及任何相关3D数据。将所有这些数据转化至一个单一的图表能够确保当需要时时使用二维外部格式共享数据。
CATIA V5R21带来更大的柔性用于设计图模式标注CATIA V5R21在穿孔模式公差和标注定义方面给用户带来更大的柔性。每一个要求能够得到它自己的语义学标注。距离和位置标注能够在模式创建步骤中被自动建议给用户，因此带来显著的生产效率的提高。
设备
CATIA V5R21帮助线束生产企业增强线束展平工效学设计及牢固性 这个版本带来工效学方面的增强，在用户手动制图步骤期间通过一个全新的三维标签选择流程提高用户生产效率。共时命令由于具备更优的分支管理得到丰富，并且现在完全能够处理混合(支持 + 机械零件)零件组件。
加工
CATIA V5R21提供一流的机加工战略并继续增强机加工仿真以提高生产效率这个版本提供专门用于难加工材料的切削的新的加工战略，目的在于提高刀具寿命。多轮廓凹坑端平面铣削方面具有许多增强，如转角时进给率减少或者用于精准的刀具路径的控制命令重叠，带来无与伦比的程序编制并能够缩短加工时间。
界面
CATIA V5R21通过支持全新的CAD格式增强它的开放性新的格式支持包含ProE WF5、UG NX6、SolidWorks 2009、SolidWorks 2010、ACIS V19和Parasolid V21。
向Version 6过渡
从CATIA V5向CATIA V6过渡 为了确保我们的客户能够成功地从V5向V6过渡，就向从一个版本过渡到一个新的版本一样，DS提供CATIA V5和V6数据之间向上的和向下的兼容性，等同于V5的两个版本之间的数据兼容性。为了获得企业当中或者订货商和供货商之间无与伦比的协同作业，V6考虑了支持所有CATIA V5版本和V6之间关联设计方面的协同作业。为了保护客户在已有的V5项目上的投资，DS计划继续V5的开发和支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad3f2a2157acd7c3047012cba5f067b/" rel="bookmark">
			picker多选 vant_vant 的picker如何绑定多级联动？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我自己写了一下，只不过这种不太通用，就是改变的时候没有让他一级一级往下获取，这个你们可以自行解决
`弹窗
`
`
var pickerData=[{
id:1,
name:'A区',
child:[{
id:11,
name:"1-11列",
},{
id:12,
name:"1-12列",
}]
},{
id:2,
name:'B区',
child:[{
id:21,
name:"2-21列",
},{
id:24,
name:"2-24列",
}]
}]
var vm = new Vue({
el: '#app',
data(){
return {
show:false,
address:[],//当前选中的盘点位置
columns:[{
values: [],
className: 'column1'
},{
values: [],
className: 'column2',
defaultIndex: 0
}],
}
},
created(){
for(var i in pickerData){
var obj = {
text:pickerData[i].name,
id:pickerData[i].id
}
this.columns[0].values.push(obj)
}
for(var i in pickerData[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad3f2a2157acd7c3047012cba5f067b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86125fd1e4cdb236b0b6bf192c4771b0/" rel="bookmark">
			均值滤波器类型_[数字图像处理]图像去噪初步(1)--均值滤波器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.图像去噪的前言
上一篇博文中，我对噪声的类型进行了介绍，也使用的Matlab对各种噪声进行了实现。旧话重提，一幅图像，甚至是一个信号的老化，能够使用下面模型来表示。
能够使用下面算式来表示
这里，因为退化函数
的作用，使得原图像
产生退化(比方，运动模糊)，然后在加上一个加性噪声项
。
本博文，主要对去除加性噪声的线性滤波器的性能进行了比較。对于退化函数的去除(称为去卷积或者逆滤波)，将放在稍后的博文。
1.1 实验用图像
1.2 实验结果的评价
实验的步骤为，将实验用图像加上加性噪声，然后使用滤波器进行去噪，比較所得到的图像的画质。这里，就涉及到画质的评价方法。一般的，去噪图像的评价一般使用PSNR(峰值信噪比)。
对于8-bit的图片而言，这里的MAX为255。PSNR越大，其画质就越好。可是，有些时候，使用PSNR来进行评价，也有不太合理的时候。
请对照方下三张图片，a)是使用平均滤波器进行了处理，使其有些模糊；b)是使用高斯噪声污染原图；c)是使用椒盐噪声污染的图像。
问题来了，这三张图像哪张画质最好，哪张最差。普遍的，画质从好到差排列，大家的答案应该是
a) &gt; c) &gt; b)
这种(很多其它实际样例，请參考https://ece.uwaterloo.ca/~z70wang/research/ssim/)。那么，我们求其的PSNR是这种。
这明显不科学，三幅图像的PSNR是一样的。反观PSNR的计算式，PSNR计算的时候，使用了MSE这个量。而MSE只表现了两幅图像的灰度值的差，而对于图像的结构，却没有进行不论什么分析。
这里使用一种比較好的图像画质评价的方法：SSIM(念做：艾斯-希姆)。这是一种由两张图像的灰度差异，构造差异和对照度去推断两张图的接近程度的方法。详情请參考[文献1]，这里仅仅做简单的介绍一下啦。
SSIM从图像亮度(Luminance)，图像对照度(Contrast)和图像构造(Structure)去推断处理过的图像与原图的差异。这里，使用了某个区域的内的平均值作为亮度度量，使用方差作为对照度度量，使用协方差作为构造度量，来进行推断。这样，SSIM就比仅使用灰度去推断的PSNR更加准确。一样的，使用SSIM求取上面三幅图象的类似度。
从上表能够看出来，通过使用SSIM进行推断的结果，更加符合人眼的主观感受。本文余下的实验，所有使用SSIM去推断画质。
2.几个均值滤波器---线性处理
2.1 算术均值滤波器
算术均值滤波器非常easy，就是求某个区域内的全部像素的算术均值，可用下式子表示。
从式子上能够看出来，这就是一个低通滤波器，会使得画面模糊，有些许去噪能力。略微做个实验看看。
将实验用图像加噪，噪声均值为0、方差为0.0298的噪声。
以下，使用算术均值滤波器，看看去噪效果。
被去掉了些许，仅仅是些许。再看频率域内的图像，果然是一个低通滤波器，我们都能够脑补出这个滤波器的振幅特性了，对吧？
2.2 几何均值滤波器
接下来是几何均值滤波器，求某个区域内的几何平均值。
对于这个滤波器，书(《Digital Image Processing》 Rafael C. Gonzalez / Richard E. Woods)上说了，这个滤波器产生的去噪效果能够与算术平均值滤波器基本一样，可是能够更少的丢失细节。
相同的，将实验用图像加噪，噪声均值为0、方差为0.17的噪声。
有结果可见，其去噪效果也不是太理想，可是原本芯片的pin脚什么的，比算术均值滤波器略微好要一些的。当然，几何滤波器有一个致命的缺点，一旦有0值出现，那么这个像素的值马上被决定为0，这也就意味着，几何滤波器不能够去除胡椒噪声。
2.3 算术均值滤波器与几何均值滤波器的比較
为了对照几何均值滤波器与算术均值滤波器，我们进行了例如以下几组实验。因为篇幅问题，我就不贴出图来了。看数据就能够了。
1. 噪声：高斯噪声，均值0，方差为0.17
2.噪声：高斯噪声，均值0.2，方差为0.17
3.噪声：椒盐噪声，胡椒密度0，盐粒密度0.1
这个还是想把结果贴上，几何平均滤波器的实验结果还是具有一定的欣赏性的。
4.噪声：椒盐噪声，胡椒密度0.1，盐粒密度0
就如同实验结果一样，因为包括了大量了胡椒噪声，几何滤波器坏掉了。得到的结果非常糟糕。
实验结论：实验4的数据说明，因为包括了0值，几何滤波器去噪效果并不太好。可是实验3，几何滤波器的去噪效果真的是非常不错。简单而言，算术均值滤波器泛用性比較好，而几何滤波器则擅长于去除盐粒噪声。
================
拓展运用：既然几何滤波器对于去除盐粒噪声，那么，对于只函数胡椒噪声的图像取反，将胡椒噪声转换为盐粒噪声去处理，所得结果再返回来，那么，几何均值滤波器还是能够去除胡椒噪声的。
================
2.4 谐波均值滤波器
其表达式例如以下所看到的，
注意式子的分母，这个滤波器不但不能去除椒盐噪声，对于灰度过黑的图像而言，也是要坏事的。书(《Digital Image Processing》 Rafael C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86125fd1e4cdb236b0b6bf192c4771b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a06b0167e70b9b2262052ae6177f13/" rel="bookmark">
			阅读笔记--Protein PreTrain
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读笔记--Pre-training Protein Language Models withLabel-Agnostic Binding Pairs Enhances Performancein Downstream Tasks 1、预备知识1.1 Longformer1.2 BPE介绍 2、相关工作3、方法3.1 方法概述3.2 BPE压缩表示3.3 数据集3.4 Fine-tuning任务3.4 Fine-tuning数据集 4、实验结果4.1 具有蛋白质结合对的MLM预训练优于单个序列4.2 序列对预训练模型在微调任务方面优于单个序列模型未来的工作 1、预备知识 1.1 Longformer Longformer是一种可高效处理长文本的模型，传统Transformer-based模型在处理长文本时存在一些问题，因为它们均采用"我全都要看"型的attention机制，即每一个token都要与其他所有token进行交互，无论是空间还是时间复杂度都很高。Longformer则改进了Transformer传统的self-attention机制。具体来说，每一个token只对固定窗口大小附近的token进行local attention（局部注意力）。并且Longformer针对具体任务，在原有local attention的基础上增加了一种global attention（全局注意力）
三种注意力机制：
滑窗机制：对于每一个token，只对其附近 n n n个token计算attention。作者认为根据应用任务的不同，可以对Transformer每一层施以不同的窗口大小。
空洞滑窗机制：对每一个token进行编码时，普通的滑窗机制只能考虑到长度为 n n n的上下文。作者进一步提出空洞滑窗机制（实际上空洞滑窗是CV领域中很早就有的一项技术,比如空洞卷积），在不增加计算负荷的前提下，拓宽视野范围。在滑动窗口中，被attented到的两个相邻token之间会存在大小为 d d d的间隙，因此每个token的视野范围便增大了。实验表明，由于考虑了更加全面的上下文信息，空洞滑窗机制比普通的滑窗机制表现更佳。融合全局信息的滑窗机制 (Global+sliding window)
我们知道BERT类的语言模型在fine-tune时，实现方式略有不同。比如，对于文本分类任务，我们会在整个输入的前面加上[CLS]这个token；而对于QA任务，我们则会将问题与文本进行拼接后进行输入。在Longformer中，作者也希望能够根据具体任务的不同，在原本local attention的基础上添加少量的global attention。例如，在分类任务中会在[CLS]初添加一个global attention（对应下图第一行第一列全蓝）；而在QA任务上会对question中的所有token添加global attention。如下图所示，对于添加了global attention的token，我们对其编码时要对整个序列做attention，并且编码其它token时，也都要attend到它
1.2 BPE介绍 BPE(byte pair encoder)字节对编码，也可以叫做digram coding双字母组合编码，主要目的是为了数据压缩。
作者准备了两个来自STRING的蛋白质序列对的预训练数据集，其中一半是强结合对（以0-1,000的置信度表示，结合相互作用评分至少为700），另一半是随机对。
2、相关工作 U n i r R e p UnirRep UnirRep是第一个应用深度学习从未标记序列中获取蛋白质表示的研究。它以自回归的方式对两千两百多万个Pfam序列进行了乘法LSTM的预训练，来学习每个氨基酸1900维的表示。Bepler等人的工作，根据蛋白质序列对预测蛋白质的二级结构，同时通过预测这些序列对内蛋白质序列的相似性以及单个序列内氨基酸之间是否接触的关系来共同预训练双向LSTM模型。最近的蛋白质语言模型致力于利用上下文相关的语言模型架构：ELMO与Bert。与ELMO相关的工作有：P-ELMO,SeqVec,PLUS-RNN。与BERT相关的工作是ESM,TAPE,ProtTrans。与本文的工作类似，ProBerta也是以BPE子词表示来进行训练的。并且BPE子词表的大小都为10K。但本文所用于预训练的数据集以及模型都更大。 3、方法 3.1 方法概述 作者以Transformer为架构，训练了两种蛋白质序列预训练的策略：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a06b0167e70b9b2262052ae6177f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d37b5a464f6f54892ec3d62eeac256/" rel="bookmark">
			怎么看rx580是不是470刷的_什么是舔狗？怎么看自己是不是舔狗？舔狗终结篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于舔狗的文章，我写了有两个，今天是第三篇，也是最后一篇，因为再写关于舔狗的，我发现我就要吐了。
很多人对舔狗都抱着同情，但实际上我在前两篇文章里面其实已经说得很明白了，舔狗其实是不值得被同情的，为什么他不值得被同情？
到底什么样的人才被称之为舔狗？他们的结局为什么都很惨？今天我们就一点一点的剖析出来。
首先我们来说，第一个就是什么样的人才可以被称之为舔狗？
说白了就是对方对自己没有意思，可能自己已经感觉出来了，或者已经明确告知了，但是依然契而不舍，而且还舍弃了自己的自尊，要不怎么可能被称之为狗。
他也不会管是否会给对方造成一些困扰，就是拼命的在用自己的方式嘘寒问暖，拼命用自己的方式对对方好。
这么一分析，会发现我们身边有太多人是舔狗了，不分男女，都在用自己的方式对一个不喜欢自己的人拼命的好，然后对方还理所应当的接受，最后落得个感觉自己受伤，抑郁的情绪当中。
舔狗是深情吗？其实二者是有本质性区别的。
什么本质区别？深情是能够接受自己得不到这件事，即使得不到也不会去打扰对方。
而舔狗就是为了得到。而且在得到的这个过程当中，一步一步的去合理化自己的行为，即使给对方造成困扰也不自知。
这里面我们要重点说说不自知这个环节，因为真的很多舔狗是真的不自知，在他们的心里就是认为对方可能喜欢自己，要不怎么会有一系列的细节行为都指向喜欢，从不喜欢里面找喜欢，是他们最常愿意做的事情！
我们用一种情境去把它演绎出来，很多时候，舔狗在给喜欢的人发信息的时候，每次发，对方也会回复，他不会回复的那么及时，为什么？
因为对方不喜欢你啊，就这么简单。
那他每次回复，你就感觉，可能对你有意思。
然后你就频繁的各种早安，晚安，吃了吗，在干嘛，聊聊人生，说说理想，找各种话题。
时不时的你有可能会给他发一些红包，节日送个礼物，对方也是坦然接受，然后就会想，他还是喜欢我的，要不怎么不拒绝我，也愿意收我的礼物，也愿意收我的红包，还没拒绝，对吧？
你说礼物也收了，红包也收了，也没有表现出明显的拒绝，但是真实情况真是这样吗？
在对方心里，他很困扰，他知道你对他有好感，没有人会拒绝一个喜欢自己的人，你喜欢我是你的事，但是我不喜欢你，我的态度已经很明显了，是你自己感觉不到而已，这跟我没关系。
很多人就不理解了，既然不喜欢你就应该不回我的信息，或者不搭理我，为什么还回复我的信息呢？
对方也很无辜，我回复你信息仅仅是出于礼貌，并不是因为别的，别人发的信息，只要不讨厌，我也会回复，这根本说明不了什么？除非你是把我烦的实在受不了了，那可能我会拉黑删除，因为本身你在我这里就不重要，留着你也没意义，不到最后阶段，肯定是不会走这一步的。
为什么要收礼物？其实你送的礼物吧，也不想收。但是感觉要退回去，有点太不给面子了，你说回赠又感觉好像有点暧昧，那只能是勉强收下。
红包为什么也收呢？那你白给的钱谁不要？
看了是不是感觉挺扎心的？但这就是事实，真正喜欢一个人，是不会晚回消息的，即使晚回复，会说明原因，是会对话框置顶的，是会主动给喜欢的人买东西的，是时时刻刻想着对方的，是不愿意对方为自己多花钱的。
请问，你占了哪一条？哪一条都没占，你怎么就那么确信他对你有点意思呢？
而且在这个阶段，舔狗们还会频繁的被自己衍生出的各种情绪所左右，因为对方对自己的态度时好时坏，有些时候感觉特别好，有些时候感觉又特别不好，所以就弄的患得患失，时间长了抑郁，失眠，厌食，焦虑，因为所有的注意力全部放在了这件事上。
还会感觉自己被吊着，其实完全是自己在给自己导演琼瑶式爱情连续剧，要是把大脑中的画面演绎出来，我估计收视率肯定特别高。
舔狗可怜吗？不可怜，可恨吗？其实也不可恨，喜欢一个人有错吗？喜欢一个人没错，但是喜欢一个不喜欢你的人就错了。
你付出的喜欢对方全盘接受，好点的，不厌恶你的可能会给你来一句，你是一个好人的称号，对于讨厌你的，可能会在心里骂你一句，傻逼，然后还会非常鄙夷的感觉你贱，做人到这个地步，又何必？
又有哪个人值得你不图任何回报，没有任何回报的付出呢？
当你知道对方不喜欢你的人，做的最正确的事情就是挥手转身，然后互道珍重，这样体面又完美多好，未来还会在彼此心中留下美好的回忆，因为互相都被尊重了。
怕就怕舔狗们一直死缠烂打，直到把对方烦的不堪其扰，最后选择拉黑删除，才作罢，舔狗们才真正明白，原来他是真不喜欢我，一切都是我自以为是，自作多情，自我感动罢了。
最后埃莫大于心死，其实哪有那么严重，你只是喜欢上了一个不喜欢你的人而已，在未来的某一个阶段，或者很快，你就会遇到一个你喜欢，而且也喜欢你的人，然后你们幸福的生活在了一起。
也不要诅咒或者期望对方就会过的很惨，对方不喜欢你，这是正常的，爱情本身就是两情相悦，凭什么你喜欢他，他就要喜欢你，爱而不得的事情多了去了，何苦为难别人，还为难自己。
他也会遇到一个他喜欢，然后也喜欢他的人，然后一起幸福的生活在一起，他也没有刻意的想要伤害你，他所表现出来的行为只是因为他不爱你，仅此而已！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60342ef9a01af924a5fe958764f72299/" rel="bookmark">
			Latex中插入图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Latex的插图 在Latex中使用插图一般有两种方式，一种是插入事先准备好的图片，另一种是使用Latex代码直接在文档中画图。我们一般常见的使用都是第一种，准备好图片，然后直接插入在我们文档当中。只有一些特殊情况需要用大量代码作图。
插图功能不是由Latex的内核直接提供的，而是需要由宏包graphicx提供的。因此要使用宏包的话，我们就需要在引言区插入我们的宏包。当然咯，插图的宏包我们还可以选择性的使用graphics这个宏包，这两个宏包在功能上并没有什么差别，只是graphicx宏包支持&lt;项目&gt;=&lt;值&gt;的语法，使用起来更方便。
注意：引言区就是指的从\documentclass 开始到\begin[document]的这个部分的区域。代码如下所示：
\documentclass{article} %导言区 \usepackage{graphicx} % ... ... %导言区 \begin{document} 导入宏包之后我们就可以使用\includegraphics命令进行插图。
\includegraphics[scale=0.6]{fullscreen.png} \includegraphics这里有两个参数：
第一个参数是可选的，一般要插入的图片是提前选好的，那么有可能就存在着和文档的规格有一些不符合的情况，这个样子的话我们就需要对图片做一些适当的调整。比如说设定图片的高度和宽度或者是按比例缩放。eg: width=3cm[缩放因子], height=8 cm[缩放因子] scale=0.4[缩放因子]。 % 导言区用这个引入宏包: \usepackage{graphicx} % 调用展示图片的方法: \includegraphics[&lt;opt&gt;]{&lt;filename&gt;} % 图片的几种格式: EPS,PDF,PNG,JPEG,BMP % 导言区 \documentclass{ctexart} \usepackage{graphicx} \graphicspath{{figures/},{pics/}} % file path: ./figures {}分组 % 正文区 \begin{document}	% 原图 \includegraphics{test} % \includegraphics[可选参数]{文件名} \includegraphics{logo} % \includegraphics[可选参数]{文件名} % 指定缩放 \includegraphics[scale=0.3]{test} \includegraphics[scale=0.03]{logo} % 指定高度 宽度自动调整 \includegraphics[height=2cm]{test} \includegraphics[height=2cm]{logo} % 指定高度比例 宽度自动调整 \includegraphics[height=0.01\textheight]{test} \includegraphics[height=0.01\textheight]{logo} % 指定宽度 高度自动调整 \includegraphics[width=2cm]{test} \includegraphics[width=2cm]{logo} % 指定宽度比例 高度自动调整 \includegraphics[width=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60342ef9a01af924a5fe958764f72299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ac1be3c182cb3904cad9e51f9a02d55/" rel="bookmark">
			Unity学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间主要加强unity的学习。
花了两天时间做了个小游戏，对unity加强了解。
游戏玩法：
通过方块反弹小球。
右键发射小球
左键方块跳跃
游戏由 Ball、Floor、Launcher三个游戏对象组成。
学到的经验：(1) 对预制体理解更加深入。
(2) 对各种组件的整理。
学习到功能性脚本：
刚体跳跃
第一种方式，只要求跳跃
public class Jump : MonoBehaviour { private Rigidbody m_rigidbody; void Start() { m_rigidbody = gameObject.GetComponent&lt;Rigidbody&gt;(); } void Update() { if (Input.GetMouseButtonDown(0)) { m_rigidbody.velocity = new Vector3(0, 10, 0); } } } 深化跳跃，不让方块在没有接触地面时跳跃。
public class player : MonoBehaviour { public float jump_speed = 10; public bool is_landing = false; void Start() { this.is_landing = false; } void Update() { if(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ac1be3c182cb3904cad9e51f9a02d55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3074c0fe6c02ab28d4423842d97ccaa9/" rel="bookmark">
			GitHub使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.相应的仓库创建文件
2.创建文件内容
3.提交完成后，会调到仓库主页
4.修改文件内容，
5.上传文件
6.搜索仓库文件（快捷键“”t“”）
7.下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce4a10f83e8f5c05d7873cfbec75129/" rel="bookmark">
			hash hashcode变化_面试官问我：hashcode 是什么？和equals是兄弟吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		秋招的时候还记得面试官问过我hashcode是什么，对于int、long、string类型的hashcode有什么区别，和equals一起是怎么使用的，为什么重写hashcode的同时也要重写equals.八股文背多了，也只是会表面，有空的时候还是整理一下，顺便写了几个例子加深下印象。
hashcode 是什么？ hash 一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。hash 是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个 hash 值。每个对象都有 hashcode，对象的 hashcode 怎么得来的呢？
首先一个对象肯定有物理地址，对象的物理地址跟这个 hashcode 地址不一样，hashcode 代表对象的地址说的是对象在 hash 表中的位置，通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过 hash 函数的算法就得到了 hashcode。所以，hashcode 就是在 hash 表中对应的位置。
所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。
两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。
常见的 Hash 函数有以下几个：
直接定址法：直接以关键字 k 或者 k 加上某个常数（k+c）作为哈希地址。
数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。
除留余数法：用关键字 k 除以某个不大于哈希表长度 m 的数 p，将所得余数作为哈希表地址。
分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。
平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。
伪随机数法：采用一个伪随机数当作哈希函数。
定义 以下是关于 HashCode 的官方文档定义：
hashcode 方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。
hashCode 的常规协定是：在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。
如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。
以下情况不是必需的：
如果根据 equals(java.lang.Object)方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能
实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 当 equals 方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ce4a10f83e8f5c05d7873cfbec75129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0d0d94993e4c882228eecfc74399e8/" rel="bookmark">
			js 排序—— sort() 对普通数组、对象数组（单属性/多属性）排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
普通数组排序
获取最大值
对象数组排序——单属性排序
获取最大值——对象数组中的指定属性
对象数组排序——多属性
不传参数，默认按照字符编码的顺序进行排序（数字不会按大小排序！！！）
var arr = ['General','Tom','Bob','John','Army']; var resArr = arr.sort(); console.log(resArr);//输出 ["Army", "Bob", "General", "John", "Tom"] var arr2 = [30,10,111,35,1899,50,45]; var resArr2 = arr2.sort(); console.log(resArr2);//输出 [10, 111, 1899, 30, 35, 45, 50] 普通数组排序 升序（从小到大）
var arr3 = [30,10,111,35,1899,50,45]; arr3.sort(function(a,b){ return a - b; }) console.log(arr3);//输出 [10, 30, 35, 45, 50, 111, 1899] 降序（从大到小）
var arr4 = [30,10,111,35,1899,50,45]; arr4.sort(function(a,b){ return b - a; }) console.log(arr4);//输出 [1899, 111, 50, 45, 35, 30, 10] 获取最大值 function getMax(arr) { if (arr !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b0d0d94993e4c882228eecfc74399e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d3bfedd78efa333fd5e0ce3d023623/" rel="bookmark">
			qmenubar 添加按钮_PyQt5-菜单栏工具栏状态栏的使用（QMenuBar、QToolBar、QStatusBar）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、QMenuBar
窗体标题下方QMenuBar作为窗体菜单栏；QMenu对象提供了一个可以添加菜单栏的控件，也可以用于创建上下文菜单和弹出菜单选项；
每个QMenu对象都可以包含一个或者多个QAction对象或者级联的QMenu对象；
createPopupMenu()方法用于弹出一个菜单；
menuBar()方法用于返回主窗口的QMenuBar对象；
addMenu()方法可以将菜单添加到菜单栏；
addAction() 方法可以在菜单中进行添加某些操作；
常用方法：
例如：
1 #QMenuBar/QMenu/QAction的使用(菜单栏)
2 from PyQt5.QtWidgets importQMenuBar,QMenu,QAction,QLineEdit,QStyle,QFormLayout, QVBoxLayout,QWidget,QApplication ,QHBoxLayout, QPushButton,QMainWindow,QGridLayout,QLabel3 from PyQt5.QtCore importQDir4 from PyQt5.QtGui importQIcon,QPixmap,QFont5 from PyQt5.QtCore importQDate6
7 importsys8
9 classWindowClass(QMainWindow):10
11 def __init__(self,parent=None):12
13 super(WindowClass, self).__init__(parent)14 self.layout=QHBoxLayout()15 self.menubar=self.menuBar()#获取窗体的菜单栏
16
17 self.file=self.menubar.addMenu("系统菜单")18 self.file.addAction("New File")19
20 self.save=QAction("Save",self)21 self.save.setShortcut("Ctrl+S")#设置快捷键
22 self.file.addAction(self.save)23
24 self.edit=self.file.addMenu("Edit")25 self.edit.addAction("copy")#Edit下这是copy子项
26 self.edit.addAction("paste")#Edit下设置paste子项
27
28 self.quit=QAction("Quit",self)#注意如果改为：self.file.addMenu("Quit") 则表示该菜单下必须柚子菜单项；会有&gt;箭头
29 self.file.addAction(self.quit)30 self.file.triggered[QAction].connect(self.processtrigger)31 self.setLayout(self.layout)32 self.setWindowTitle("Menu Demo")33
34 defprocesstrigger(self,qaction):35 print(qaction.text()+"is triggered!")36
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d3bfedd78efa333fd5e0ce3d023623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76211d15f6908c51ec2d59c96ee8a509/" rel="bookmark">
			c#先进行uri解码_c# –  HttpClient解码编码的Url？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我试图弄清楚HttpClient如何处理URL的一些不一致.
我有以下测试代码：
public async Task TestHttpClient()
{
var baseUrl = "https://api.twitter.com/1.1/search/tweets.json";
//var query = "(cafe OR boulangerie)";
var query = "(café OR boulangerie)";
var url = baseUrl + $"?q={Uri.EscapeDataString(query)}";
var httpClient = new HttpClient();
var response = await httpClient.GetAsync(url);
await response.Content.ReadAsStringAsync();
}
代码实际上不起作用,因为我们需要身份验证和Twitter搜索的其他东西.但它证明了我的问题.
变量url将具有以下值：
https://api.twitter.com/1.1/search/tweets.json?q=(caféORboulangerie)
但是,看着Fiddler的请求,我可以看到实际发送的是：https：//api.twitter.com/1.1/search/tweets.json？q =(caféORboulangerie)
所以突然间,括号不再被编码.这在我的情况下很重要,因为我使用编码的查询字符串来计算我用来对twitter进行身份验证的签名.所以我的签名将包含百分比编码的括号而请求不会,因此Twitter会抛出错误并告诉我验证失败.
有趣的是,如果我使用常规e而不是é发送查询,则括号将在请求中进行编码！像这样：https：//api.twitter.com/1.1/search/tweets.json？q =(cafe OR boulangerie)
我想这是HttpClient的某种错误？我可以以某种方式解决这个问题吗？
解决方法:
我的解决方案是解析Uri.AbsoluteUri的内容(以相同,不一致的方式对url进行编码),并在计算身份验证的签名时使用它.而不是像我之前使用的那样使用Uri.EscapeDataString.
标签：c,encoding,url-encoding,dotnet-httpclient,net-core
来源： https://codeday.me/bug/20190706/1392410.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d0b7d8beddfc8ed98efdaa14b8aa8d8/" rel="bookmark">
			万网绑定二级域名_万网虚拟主机绑定多个子域名的操作方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用.htaccess绑定域名到子目录,前提你的空间服务器必须支持apache的rewrite功能，只有这样才能使用.htaccess。如果你的空间是Linux服务器 一般默认都开启了的。
绑定域名
登陆域名管理台(如DNSPod) 把需要绑定的域名 解析到你的空间；
登陆虚拟主机/空间管理台(如万网) 绑定域名到空间;
首先在本地建个txt文件，复制下面的代码修改替换你要绑的域名和目录，并传到网站主目录下再改成为.htaccess。
下面是以 music.xmgho.com 绑定到子目录music为例的.htaccess代码.
RewriteEngine On
RewriteBase /
# 绑定music.xmgho.com 到子目录music
RewriteCond %{HTTP_HOST} ^music\.xmgho\.com$ [NC]
RewriteCond %{REQUEST_URI} !^/music/
RewriteRule ^(.*)$ music/$1?Rewrite [L,QSA]
#可以绑定多个 只需重复上三行代码并更改一下域名、目录名 就好了
如果你以完成上面的步骤
你的子域名应该可以访问了 但你会发现在浏览器上访问 主域名+绑定的域名目录 也可以访问，可这并不是我们想要的 接下来我们完成最后一步;在每一个绑定的目录中 如music目录中 也增加一个 .htaccess 文件
.htaccess代码如下：
RewriteEngine On
RewriteBase /
#只许绑定的域名访问
RewriteCond %{HTTP_HOST} !^music\.xmgho\.com$ [NC]
RewriteRule (.*) http://music.xmgho.com/$1 [L,R=301]
#对绑定目录下与 同名的目录的处理
RewriteCond %{REQUEST_URI} ^\/music\/ [NC]
RewriteCond %{QUERY_STRING} !^(.*)?Rewrite
RewriteRule ^(.*)$ /%{REQUEST_URI}/%{REQUEST_URI}/$1?Rewrite [L,QSA]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d0b7d8beddfc8ed98efdaa14b8aa8d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef03d09230ced57a236a032924f9b43/" rel="bookmark">
			win10wifi间歇性断网重启后恢复_Win10系统无线网络自动断网需重启才能正常连接的解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在Win10系统上，连接网络的方式有很多种，其中最方便就是连接无线网络了，但是有用户在Win10系统，连接好无线网络后，老是会自动断网，然后无法再连接，只能重启Win10系统后，才能再连接无线网络，因此有很多用户在本站问小编，怎么解决这个问题，那么，小编就给大家详细讲解，Win10系统连接无线网络会自动断网，需要重启才能正常连接的解决方法。
win10无线网自动断网 重启后才能正常使用的解决方法：
1、按下win+x打开超级菜单，点击【设备管理器】；
2、在设备管理器中展开【网络适配器】，在下面应该能看到 LAN 802.11的字眼，这个就是无线网卡，在这个设备上单击右键，选择【属性】；
3、切换到【电源管理】，在下面将【允许计算机关闭此设备以解决电源】的勾去掉，点击确定保存设置即可！
以上内容，就是在Win10系统上连接无线网络，出现自动断网，得重启才能正常连接的解决方法，还有碰到此类问题的用户，可以按照小编的方法进行解决，希望对大家能有所帮助，了解其他教程，请继续支持系统族。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6160c725220b7d663e514e1cfc02b44/" rel="bookmark">
			XAML命名空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XAML命名空间 WPF（Windows Presentation Foundation）是（微软推出的）基于Windows的用户界面框架，属于.NET Framework 3.0的一部分。WPF提供了统一的编程模型，语言和框架，做到了分离界面设计人员与开发人员的工作。
WPF中文译名为“Windows呈现基础”，原来的代号为“Avalon”。从.NET Framework 3.0开始引入。（所以.NET Framework 3.0以下版本没有WPF，.NET Framework 3.0及其之后的版本才支持WPF）
如下图，WPF在默认情况下带有三个命名空间。第一个通过链接的方式将命名空间加进来，是矢量的命名空间；第二个命名空间带有x的前缀，是xaml的命名空间。一个完整的XAML页面必须带有这两个命名空间。三个命名空间带有local的前缀，local代表着应用程序，加载的是本地的命名空间。
而WPF（Windows Presentation Foundation）使用对象描述语言是XAML语言。（XAML语言和HTML语言都是由XML语言延申而来的。）
XAML语言和.Net其他语言一样是通过命名空间有效组织起XAML内部的相关元素类。
但是XAML命名空间与.Net命名空间不是一一对应的，而是一对多，它们的功能都不一样。
并且XAML命名空间是通过链接和属性“clr-namespace”引入，通过链接引入的是内部封装好的命名空间，通过属性“clr-namespace”引入的是自定义封装的命名空间。
下图显示.Net命名空间与XAML命名空间的区别：
.Net命名空间
XAML命名空间
XAML命名空间的命名遵守XAML解析器标准的命名规则。XAML命名空间的名字和网址非常相似，但并不是真正的网址，所以在IE浏览器中是打不开的。
XAML命名空间是通过前缀来区分的，在默认情况下，只有系统的一个默认命名空间是不带前缀的，所以要使用命名空间里面的资源（样式、模板、动画等），就必须在属性前面加上该命名空间的前缀。（如下图）
XAML命名空间的语法：xmlns[:可选映射前缀]=“命名空间描述”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9273cef9e761ab449e6247b8ddd513e1/" rel="bookmark">
			WPF命名空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF命名空间 如下图，WPF在默认情况下带有三个命名空间。第一个通过链接的方式将命名空间加进来，是矢量的命名空间；第二个命名空间带有x的前缀，是xaml的命名空间。一个完整的XAML页面必须带有这两个命名空间。三个命名空间带有local的前缀，local代表着应用程序，加载的是本地的命名空间。
WPF命名空间里面的样式、模板、动画等资源。那么WPF命名空间里面的样式、模板、动画等资源要如何使用呢？是与Html那样使用Css或者Style标签吗？
当然不是。既然是资源，就要通过资源引入命名空间里面的资源，WPF里面有专门的标签“Resources”用来引入命名空间里面的资源。
如下图
WPF的样式不是如图HTML那样通过类或者id来指定，而是通过标签的属性来指定要操控的是哪个控件的样式。
如下图：
上图中“TargetType”是Properties的一个属性，后面对应的值是控件。
在WPF中，除了在App.xaml页面的“Application.Resources” 里面写的样式是给整个应用程序的所有页面的，其他页面的样式都是仅供一个页面使用，例如在MainWindow.xaml页面的“Window.Resources”里面写的样式是只有MainWindow.xaml页面能使用的样式。
App.xaml页面：
但是如果只想让这个样式操控这一个控件，就要用“key”这个属性把“Resources”里面的样式私有化。然后把给到控件里面。
如下例:
代码图：
效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea02c515d404bf46e4f68306002b97d9/" rel="bookmark">
			仿ios桌面vivo_vivo精仿ios11主题包专属版下载-vivo精仿ios11主题包自定义版v2.9.9安卓版-007游戏网...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vivo精仿ios11主题包自定义版，这是一款非常热门的安卓仿ios的主题应用软件，这款软件提供最新最全的ios11所有的主题应用和壁纸，还有各种图标免费使用，让你体验安卓和苹果并存的感觉，喜欢的话就来下载吧！
vivo精仿ios11主题包自定义版介绍：
vivo精仿ios11主题包应用程序为您提供的功能来调整大小，设置位置，面板快捷的设置可见。
vivo精仿ios11主题包自定义版特色：
修改负一屏效果
修改dock栏模糊度
修改日历字体(太粗了的话软件设置里把日历字体设置为细体)
修改为ios9字体并加粗来模仿ios11字体(虽然我感受不不来，但不服拆包看字体)
修改部分ios11上的新图标
还有安装包名就叫文件，你没下错
vivo精仿ios11主题包自定义版功能：
亮度控制
音量控制，包括媒体，闹铃，铃声。
WIFI控制
屏幕方向
相机：决不会错过捕捉难忘的时刻
手电筒
时钟
蓝牙控制
运动数据控制
喜爱的应用程序
飞行模式
vivo精仿ios11主题包自定义版优势：
超平滑滚动，就像iPhone。
图标的圆角和光泽的效果。
长按图标进行移动。
在主屏幕卸载应用。
按返回按钮退出编辑模式。
可以改变每个应用程序的名称和图标，通过触摸的应用程序，在短期内轻摇模式。
vivo精仿ios11主题包自定义版说明：
功能强大的手机桌面启动器应用程序选项
简易和快速的风格主题和壁纸体验
炫酷的图标风格主屏幕，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c7e616ddeaee26af5de4425b5c767a/" rel="bookmark">
			airpods pro是按压还是触摸_AirPods Pro个人使用体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我不是什么专业的测评，我只是把我个人真实的主观感受记录下来，希望对有关注此耳机的大爷有帮助，不正确不到位请轻喷。
几年前买了一个SONY MDR-1ABT头戴式耳麦，说实话没用过几次，因为在家里有音响，出门带着又不方便，外出一直使用苹果有线耳机，但是每次拿出来线绕的乱七八糟要解开也是一个烦人的事情。所以一度想买一个蓝牙耳机，也考虑过降噪耳机，看了网上说的比较多那个SONY的和BOSE的，正好我同事都有这两个耳机，我试一下，我对那种入耳式的不喜欢，感觉异物感有些强，脖子上还有一个项圈一样的东西，也不方便放到平时上下班的包里面，所以后来就买了AirPods 2代，用着感觉挺好的，方便，戴着很舒适，有时候甚至忘记了这个耳机的存在。
新的AirPods Pro出来，看介绍是入耳式，其实心里是有一些犹豫的，但是还是报着试试的态度订了，昨天晚上我收到了AirPods Pro，摸清楚了功能，今天一天都在各种场景使用Pro这个耳机，先说结论：这个耳机超出了我的预期。
这耳机有三个模式：降噪-关闭-透明模式。
降噪：这个很容易理解，就开启降噪
关闭：这个是把降噪给关了，但是因为是入耳式的，所以外面的声音还是被挡了一部分，还是有些听不清，这个时候和别人聊天还是会受影响，而且耳朵感觉被堵住了感觉，不舒服。
透明模式：此时这个耳机是通过外面的麦克风接收外界声音，然后通过耳朵内侧耳机播放出来，这个时候就可以清晰的听到外面声音了，但是毕竟是通过耳机处理过的声音，所以还是与摘下耳机的自然声音有一点点不一样，但是基本上可以忽略。
今天早上我开车出门，在车上我仔细试了下，降噪效果非常的好，在行车状态下，降噪模式开启后，基本上听不到任何声音，只能感受到车辆在行驶过程中的地面振动，发动机声音，路噪等噪声基本上都被很好的过滤，开启透明模式后，又可以很好的听到外界的声音了。
然后到了医院，医院里面全是人，就是那种嘈杂的声音，开启降噪模式，效果还是很明显的，在不开启音乐情况下虽然还是可以听到外面的声音，但是确实已经小了很多，当把音乐开启后，外面的声音感受又小很多，还是可以很好的欣赏音乐。
在马路上，小朋友放学去接他，在学校门口的马路边，来往车辆，还有等接小朋友的家长还比较多，降噪效果也挺好的。
所以降噪我觉得挺满意的，还有一点超出了我的预期，本来我觉得这么小的耳机降噪可能不一定会很好的。
再讲一下舒适度，我以前是比较排斥入耳式耳机的，因为感觉整个耳朵被堵到了，耳朵被膨胀起来了，很难受，所以我之前试了很多同事的各种入耳式耳机，但是我最终都没有买。AirPods Pro耳机与耳朵的贴合很好，感觉耳机主要重量部分是“躺”在耳廓中，所以感觉很牢固，不会有会掉的感觉，入耳的部分刚开始确实是有一些不适应，时刻提醒你他的存在，不像AirPods感觉不到存在，但是经过一天的适应，现在已经基本上适应了，耳机的“存在感”已经没有刚开始那么强了，特别是当听听音乐的时候，有时候也会忘记耳机的存在，但是毕竟还是有的，做不到普通AirPods那样，但是对我个人来说已经不是什么问题了。
控制部分，原来AirPods普通版本，通过触摸控制，而且也没有什么反馈，我经常搞不清楚，我的触摸到底有没有效果，有没有触摸到对的位置，到现在我还是搞不清楚，感觉每一次触摸就是撞撞运气。而新版AirPods Pro是通过在左耳机尾部有一个压力传感器，而且每次按压在耳机里都会有一个轻微的声音反馈，所以可以很清楚知道有没有操作成功。
防水，昨天收到后一直戴着，洗脸也戴着，一不小心有一些被洗到水中了，捞起来，用吹风机吹干后，今天又用了一天，没有什么问题。不像iPhoneX，有一次旅行掉到海里，手机就挂了。
另外还支持无线充电，这个功能其实对我来说无所谓的，体积方面比原来的AirPods普通版本大一点点，还是比较小巧的。
到现在我还没有讲音质，因为我分辨不出来，各种耳机我感觉都差不多，哈哈，我对音质也没有太高的要求，差不多就行了，所以这部分让请各位大爷自己去感受吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c30a9a16bcc49dde65c035ee5038e9/" rel="bookmark">
			office套件_5年了，微软终于公布全新Office图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5月10日，微软透露了Office重新设计的文件类型图标。这次的流畅设计语言由5大元素组成：光感、深度、动效、材质、缩放。
微软采用格式塔原则进一步强调主要的产品变革。简单、和谐是关键的视觉元素，用以体现Office办公软件的无缝连通与直观性能。
每个图标都有一个极具辨识度的唯一标志性图案，而各个应用的标志性图案与套件之间又存在着丝丝缕缕的联系。
从下图中可以看出，新图标看起来干净简洁。
而微软上一次修改 Office 图标还是在五年前。
在Build 2019大会期间，新的Office文件图标也出现了新变化， 更加简洁、直观和扁平化。
早在2018年11月的时候，微软(Microsoft)今天公布了一组全新的 Office 图标，新图标的设计更加简洁和现代化。
看着Office应用程序图标演进，采用扁平化、大色块这样的Fluent Design设计语言，缩小字母“W”“P”的大小。
目前微软 Office已经覆盖 Windows、macOS、iOS、Android 多个平台，微软还建立了一个单一核心的代码库，帮助快速改进应用程序。
除了 常见 Office 应用程序外， OneDrive、Skype 的图标也发生了一些变化。新的 OneDrive 图标将继续是一个云，Skype 则更凸显一个带有“S”字母的按钮。
微软现在正在向iOS用户推出这些图标，Outlook for iOS的用户已经可以尝鲜新图标素材。不久之后，安卓版Outlook、OneDrvie等也将开始部署呈现。
你如何看待这些新图标？
‍
‍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83e011955155668af866852e711523c/" rel="bookmark">
			QTableView::setSpan: single cell span won‘t be added
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用QTableWidget的 setSpan(row,column,rowCount,columnCount) 合并单元格时有时会遇到应用程序输出：
QTableView::setSpan: single cell span won’t be added
这个既不是报错也不是警告，算是一个提示。
意思是：setSpan 不能合并单个单元格，也就是说setSpan中，rowCount &gt; 1 || columnCount &gt; 1,必须是2个单元格以上的单元格相合并。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a93aee489e4e720be11104e7d8774da/" rel="bookmark">
			QTableWidget合并单元格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		void tabWidget_3::slot_showTable(QMap&lt;QString,QList&lt;QString&gt;*&gt; map,int count) { ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setVisible(false);	//列表头不可见 ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);	//表格不可编辑 ui-&gt;tableWidget-&gt;setRowCount(count);	//表格行数 ui-&gt;tableWidget-&gt;setColumnCount(3);	//表格列数 ui-&gt;tableWidget-&gt;setHorizontalHeaderItem(0,new QTableWidgetItem("列车线号"));	//修改行表头文字 ui-&gt;tableWidget-&gt;horizontalHeaderItem(0)-&gt;setTextColor(QColor(200,111,30));	//文字颜色 ui-&gt;tableWidget-&gt;setHorizontalHeaderItem(1,new QTableWidgetItem("LCU配置属性文件")); ui-&gt;tableWidget-&gt;horizontalHeaderItem(1)-&gt;setTextColor(QColor(200,111,30)); ui-&gt;tableWidget-&gt;setHorizontalHeaderItem(2,new QTableWidgetItem("操作")); ui-&gt;tableWidget-&gt;horizontalHeaderItem(2)-&gt;setTextColor(QColor(200,111,30)); if(count &lt;= 0) return; int row = 0; for (QMap&lt;QString,QList&lt;QString&gt;*&gt;::iterator i = map.begin(); i != map.end(); i++) { if(i.value()-&gt;size() &gt; 1)	// i中元素项数大于1 才合并单元格 ui-&gt;tableWidget-&gt;setSpan(row,0,i.value()-&gt;size(),1);	//合并单元格 ui-&gt;tableWidget-&gt;setItem(row,0,new QTableWidgetItem(i.key())); //将数据添加到单元格中 int index = 0; for (QList&lt;QString&gt;::iterator j = i.value()-&gt;begin(); j != i.value()-&gt;end(); j++) { ui-&gt;tableWidget-&gt;setItem(row,1,new QTableWidgetItem(*j)); QTableWidgetItem* del = new QTableWidgetItem("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a93aee489e4e720be11104e7d8774da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5802cf22c81161ac93d611c4e9030242/" rel="bookmark">
			前馈神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前馈神经网络（全连接神经网络） 1、 概念及组成 前馈神经网络：每层神经元与下层神经元相互连接，神经元之间不存在同层连接，也不存在跨层连接。
组成：输入层、隐藏层、输出层
常用神经元：M-P神经元
图中f函数为激活函数， θ \theta θ为阈值， w T x w^Tx wTx的值超过阈值，激活函数被激活，通过激活函数处理产生神经元的输出。
2、 常见的激活函数 Sigmoid函数、tanh函数、ReLu函数
激活函数常有的性质：
非线性可微性单调性 f ( x ) ≈ x f(x)\approx x f(x)≈x输出值范围计算简单归一化 ：要把你需要处理的数据经过处理后（通过某种算法）限制在你需要的一定范围内 sigmoid函数 双曲正切函数（tanh函数） ReLU函数 3、训练 没有隐藏层的神经网络，称为感知机。感知机的训练过程见下：
给定训练数据集，权重 w i ( i = 1 , 2 , 3 , . . . n ) w_i(i=1,2,3,...n) wi​(i=1,2,3,...n)、阈值 θ \theta θ可以通过学习得到。通常情况下阈值作为一个固定的输入 归并到权重中，所以对应的连接权重为 w n + 1 w_{n+1} wn+1​。则，问题转化为通过训练数据集得到权重的过程。对于训练样例 ( x , y ) (x,y) (x,y)，假定模型的输出值为 y ^ \hat{y} y^​,那么在学习的过程中权重则这样调整：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5802cf22c81161ac93d611c4e9030242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f31fce50cc974dd4e413e0d87f43c0/" rel="bookmark">
			Shell命令行执行Redis批量操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、批量删除Redis的key $ redis-cli -h ip地址 -p 端口 -a '密码' -n 库号 keys "mobile:sys:user:unionId*" | xargs redis-cli -h ip地址 -p 端口 -a '密码' -n 库号 del 二、批量修改Redis中key的过期时间 1、redis中设置过期时间命令
expire &lt;key&gt; &lt;ttl&gt; 命令用于将键key 的生存时间设置为ttl 秒。 pexpire &lt;key&gt; &lt;ttl&gt; 命令用于将键key 的生存时间设置为ttl 毫秒。 expireat &lt;key&gt; &lt; timestamp&gt; 命令用于将键key 的过期时间设置为timestamp所指定的秒数时间戳。 pexpireat &lt;key&gt; &lt; timestamp &gt; 命令用于将键key 的过期时间设置为timestamp所指定的毫秒数时间戳。 扩展：
① ttl 命令以秒为单位返回键的剩余生存时间， 而 pttl 命令则以毫秒为单位返回键的剩余生存时间
② ttl 和pttl 两个命令都是通过计算键的过期时间和当前时间之间的差来实现的
2、批量设置key的过期时间
$ redis-cli -h ip地址 -p 端口 -a '密码' -n 库号 --scan --pattern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97f31fce50cc974dd4e413e0d87f43c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aafa57eef615d12b825d722f00e5416f/" rel="bookmark">
			DGM: A deep learning algorithm for solving partial differential equations
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文信息 题目：
DGM: A deep learning algorithm for solving partial differential equations
作者及单位：
Justin Sirignano∗ and Konstantinos Spiliopoulos
期刊、会议：
时间：18
论文地址：论文链接
代码：
基础 论文动机 High-dimensional partial differential equations (PDEs) are used in physics, engineering, and finance. Their numerical solution has been a longstanding challengeThis quickly becomes computationally intractable when the dimension d becomes even moderately large. We propose to solve high-dimensional PDEs using a meshfree deep learning algorithm.The method is similar in spirit to the Galerkin method, but with several key changes using ideas from machine learning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aafa57eef615d12b825d722f00e5416f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af43b6c52fc81aa181caac5b4f755180/" rel="bookmark">
			利用开源jol-core 包计算jvm运行时候的对象占用内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt; &lt;/dependency&gt; 利用开源jol-core 包计算jvm运行时候的对象占用内存
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/197/">«</a>
	<span class="pagination__item pagination__item--current">198/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/199/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>