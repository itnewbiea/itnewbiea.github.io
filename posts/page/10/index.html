<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5be8bf1972cce128fd34997368c95f/" rel="bookmark">
			RabbitMQ（七）ACK 消息确认机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简介1.1 背景1.2 定义1.3 如何查看确认/未确认的消息数？ 二、消息确认机制的分类2.1 消息发送确认1）ConfirmCallback方法2）ReturnCallback方法3）代码实现方式一：统一配置a.配置类a.生产者c.消费者d.测试结果 4）代码实现方式二：单独配置 2.2 消息接收确认1）basicAck() 方法2）basicReject() 方法3）basicNack() 方法4）代码实现a.配置方式一：代码配置b.配置方式二：配置文件c.生产者d.消费者e.测试结果 当我们在项目中引入了新的中间件之后，数据的风险性就要多一层考虑。那么，RabbitMQ 的消息是怎么知道有没有被消费者消费的呢？生产者又怎么确保自己发送成功了呢？这些问题将在文章中进行解答。
一、简介 1.1 背景 在 MQ 中，消费者和生产者并不直接进行通信，生产者只负责把消息发送到队列，消费者只负责从队列获取消息。
消费者从队列 获取到消息后，这条消息就不在队列中了。如果此时消费者所在的信道 因为网络中断没有消费到，那这条消息就 被永远地丢失了。所以，我们希望等待消费者 成功消费掉这条消息之后再删除消息。生产者向交换机 发送消息后，也 不能保证消息准确发送过去了，消息就像 石沉大海 一样，所以 发送消息也需要进行消息确认。 1.2 定义 为了保证消息从队列可靠地到达消费者，RabbitMQ 提供了 消息确认机制（Message Acknowledgement）。
消费者在订阅队列时，可以指定 autoAck 参数：
autoAck=false：RabbitMQ 会 等待消费者显式地回复确认信号 后才从内存（或磁盘）中移除消息（实际上时先打上删除标记，之后再删除）。autoAck=true：RabbitMQ 会 自动把发送出去的消息置为确认，然后内存（或磁盘）中删除，而 不管消费者是否真正地消费到了这些消息。 采用消息确认机制后，只要设置 autoAck 参数为 false，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为 RabbitMQ 会一直等待持有消息知道消费者显式调用 Basic.Ack 命令为止。
对于 RabbitMQ 服务器端而言，当 autoAck 参数为 false 时，队列中的消息分成了两部分：
一部分是 等待投递给消费者的消息；另一部分是 已经投递给消费者，但是还没有收到消费者确认信号的消息。 如果 RabbitMQ 服务器端 一直没有收到消费者的确认信息，并且 消费此消息的消费者已经断开连接，则服务器端会安排 该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac5be8bf1972cce128fd34997368c95f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90895d32404253725033b5931e691251/" rel="bookmark">
			User Friendly大会 | 每日互动刘宇分享AIGC时代的数智营销变革
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，第十九届暨2023年User Friendly国际用户体验大会在深圳召开。本次大会以“开智启能，体验无界”为主题，邀请了各行业领袖精英齐聚，分享前沿新观点，碰撞体验新思潮。每日互动高级副总裁刘宇作为业内资深专家，受邀出席大会并在数据智能论坛发表主题演讲，分享AIGC时代的数智营销变革及发展机遇。
▲每日互动高级副总裁刘宇现场发表主题演讲
1
AIGC带来全新用户体验变革
以AIGC和大模型为代表的新一代技术浪潮，给很多行业和领域都带了巨大变革。以用户的人机交互体验举例，历经点击时代、触摸时代，现在我们已经进入到了全新的自然语言时代。我们能够和Siri等AI应用以及chatGPT等大模型产品直接进行自然语言对话，开启智能、高效的人机协作模式。
同样，AIGC和大模型也给营销行业带来了深刻的体验变革。AI创意生成、数字人直播、AI智能外呼……这些创新应用使得整个营销行业的生产效率有了质的飞跃。刘宇表示，“虽然AI生成的创意素材可能是快餐式的，内容的质量目前还比不上专业的设计师和创意人员，但是AI生成的创意内容是真正意义上的‘数字原生’内容，这个意义是巨大的”。
刘宇讲到，“以前，我们要探究某个广告创意为什么点击率很高，需要投入非常复杂的工作，首先需要对该广告创意进行标签化，通过OCR技术、识图软件等进行模式识别，分析该广告创意在相应的维度上具备哪些属性，根据这些属性构建出一个数据空间，然后我们再从这个数据空间中挖掘规律，分析原因，根据这些规律指导后续广告创意的优化和制作。而现在AI生成的创意内容由于其本身是‘数字原生’的，因此我们能够非常容易地使用算法、模型等数据化的方式来分析其点击率高低背后的原因，再加上AIGC带来的指数级效率提升，都有力驱动着数智营销行业的深层次变革”。
2
AI不止GC，更有TA
“AIGC和大模型给数智营销行业带来的红利，不仅体现在广告创意的生成方面”。活动现场，刘宇表示，“每日互动最新推出的一款叫做“AITA智选人群”的大模型应用产品，让AI不仅能够GC，还能TA”。
“TA即Targeting Audience”。刘宇介绍，在品牌营销领域，人群定向一直是备受关注的课题。如何从茫茫人海中定向找到目标消费者，把广告投给对的TA？针对品牌主的切实需求，每日互动发挥自身能力优势，从2019年起就面向品牌主提供第三方DMP数智营销服务。依托海量的三方数据积累，每日互动帮助品牌广告主进行人群洞察和广告投放的前验，通过标签、联合建模等方式，帮助品牌主智能圈选和定向目标TA。
但是，在具体的实施过程中，这两种人群定向的方式都存在一定门槛。“标签定向”方式，需要由品牌营销人员根据自己对消费者的认知以及对每日互动数据的理解，来进行标签的勾选、组合，对于营销人员的专业性有一定要求，而且还可能涉及到较多与咨询团队、数据分析团队的人工沟通。
另一种“联合建模”的方式则需要品牌提供一方种子数据作为前提，每日互动通过机器学习为其进行分析并扩量。然而在新品推广等一些特定的营销场景下，品牌主通常缺少种子用户，也并不清楚自己的目标消费人群。
“AITA就能够很好地解决这一问题”。刘宇介绍，在AITA这款产品中，每日互动使用了大模型去赋予它对自然语义的理解，并使用了数据编织技术去实现数据空间的语义化，让市场营销等领域从业者的奇思妙想，都能够通过与大模型对话的方式，转化到数据空间的数据实体、数据标签，进而对应到目标人群，实现了“无种子洞察”和“对话式提人”等创新功能。
刘宇介绍，“与AI大模型的使用体验类似，用户通过自然语言对话就可以快速上手，通过AITA进入到数据智能的世界。AITA同时也融入了更为严谨的人群定义和预估功能，让客户在使用AITA时，既有轻松活泼的对话过程，也有严谨高效的定量部分，能够更为丝滑地完成市场分析、洞察和媒体对接等过程，也让营销领域能够更早地享受到AI大模型带来的红利”。
刘宇讲到，“因此，不仅仅是在产品和体验本身，用户体验设计从更大的社会层面和人文层面来讲，都有重大意义”。如今，数据成为重要的生产要素，AI极大提升了社会生产力，而用户体验更加关注人本身，三者的有机融合将更加有效地促进经济社会发展，帮助企业赢得商业成功。每日互动也将持续探索AI大模型和数据智能在行业里的应用落地，用数据和技术的力量推动社会持续进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f293952624da055563cb314bfa4b66/" rel="bookmark">
			为什么会去华为 OD？网传的 OD 转华为正编，真的假的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 专栏导读一、为什么会去华为 OD二、华为 OD 的工作内容三、OD 与华为自有员工的对比四、那，到底要不要去华为 OD？五、网传的 OD 转华为正编，真的假的？1、连续两次绩效 A2、通过可信专业级认证 六、最后，真的感谢 OD，也感谢华为七、华为OD，冲了，如何刷题呢？ 华为OD机试 2023B卷题库疯狂收录中，刷题点这里
专栏导读 本专栏收录于《华为OD机试（JAVA）真题（A卷+B卷）》。
刷的越多，抽中的概率越大，每一题都有详细的答题思路、详细的代码注释、样例测试，订阅后，专栏内的文章都可看，可加入华为OD刷题群（私信即可），发现新题目，随时更新，全天CSDN在线答疑。
一、为什么会去华为 OD 在平安产险（正式员工）只待了3个月，就跳去华为 OD，朋友们都是很不理解的 —— 好好的正编不做，去什么外包啊
但那个时候，我铁了心要去做大数据，不想和没完没了的 CRUD 打交道。刚好面试通过的岗位是华为 Cloud BU 的大数据部门，做的是国内政企中使用率绝对领先的大数据平台……
平台和工作内容都不错，这么好的机会，说啥也要去啊。
二、华为 OD 的工作内容 带着无限的期待，火急火燎地去华为报到了。
和招聘的 HR 说的一样，和华为自有员工一起办公，工作内容和他们完全一样：
主管根据你的能力水平分配工作，逐渐增加难度，能者多劳；试用期6个月，有导师带你，一般都是高你2个 Level 的华为自有员工，基本都是部门大牛。 所以，不存在外包做的都是基础的、流程性的、没有技术含量的工作 —— 顾虑这个的完全不用担心，你只需要打听清楚要去的部门/小组具体做什么，能接受就再考虑其他的。
感触很深的一点是：华为是有着近20万员工的巨头，内部有很多流程和制度。好处是：能接触到大公司的产品从开发、测试，到发布、运维等一系列的流程，比如提交代码的时候，会由经验资深、经过内部认证的大牛给你 Review，在拉会检视的时候，可以学习他们考虑问题的角度，还有对整个产品全局的把控。
但同时，个人觉得这也有不好的地方：流程繁琐会导致工作效率变低，比如改动几行代码，就需要跑完整个 CI（有些耗时比较久），还要提供自验和 VT 的报告。
三、OD 与华为自有员工的对比 什么是 OD？Outstanding Dispatcher，人员派遣，官方强调说，OD 和常说的“外包”是不一样的。
说说我了解的 OD：
参考华为的薪酬框架，OD 人员的薪酬体系有一定的市场竞争力 —— 的确是这样，貌似会稍微倒挂同级别的自有员工；可以参与华为主力产品的研发 —— 是的，这也是和某软等“供应商”的兄弟们不一样的地方；外网权限也可以申请打开（对，就是梯子），部门内部的大多数文档都是可以看的；工号是单独的300号段，其他供应商员工的工号是8开头，或着 WX 开头；工卡带是红色的，和自有员工一样，但是工卡内容不同，OD 的明确标注：办公区通行证，并有德科公司的备注： 还听到一些内部的说法：
没股票，没TUP，年终奖少，只有工资可能比我司高一点点而已；不能借针对HW的消费贷，也不能买公司提供的优惠保险…… 四、那，到底要不要去华为 OD？ 我想，搜到我这篇文字的你，心里其实是有偏向的，只是缺最后一片雪花❄️，让自己下决心。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24f293952624da055563cb314bfa4b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23290a61a36ebba7772d62f04a4fd84/" rel="bookmark">
			算法逆袭之路（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11.29 开始跟进算法题进度!
每天刷4题左右 ,一周之内一定要是统一类型
而且一定稍作总结, 了解他们的内在思路究竟是怎样的!!
12.24 一定要每天早中晚都要复习一下
早中午每段一两道, 而且一定要是同一个类型, 不然刷起来都没有意义
12.26/27： 斐波那契数
爬楼梯
最小花费爬楼梯
不同路径1/2
12.28： 整数拆分
重点思路：一个正整数可以分为两个，或者多个，多个可以用dp[i-j]代替，一定不能直接分为乘以dp的情况，因为这就默认了必须拆分为三个以上
不同的二叉搜索树
重点思路： 把左右子树所有情况乘起来，递归子树的问题。注意左右节点个数的边界
12.29 01背包理论
12.30 分割等和子集
很难看出来是01背包。满足的条件有
每个元素只有取和不取两个状态
结果要满足，某一部分和，刚好等于什么什么value，而背包问题是在限制的重量内计算他们价值最大值， 这里只需把求最大值改成求刚好 == sum即可
此题的weight和value都是nums【i】，因为是一个一个数字要求刚好和为sum
dp【i】代表在i内之和最大为多少 本题要求刚好等于sum所以结束条件是dp[ sum ] == sum ，即总量为sum之内刚好最大为sum！
581. 最短无序连续子数组
12.31 209. 长度最小的子数组
思路：滑动窗口，先不断右移直到sum&gt;=target ， 然后左指针左移直到小于target，记录暂时的最小长度，然后继续右移右移直到sum&gt;=target ， 左指针左移直到小于target，不断迭代最小长度
和为 K 的子数组
使用前缀和，核心是
map.containskey(sum-k); map.put(sum,map.getOrDefault(sum,0)+1); 滑动窗口 按照这题为模板
这种题的特征是 "子串" "子数组" 这种需要连续元素的
有一个窗口在扫描，使用两个变量left限制左范围：right用于for遍历计数
tmp,max用于记录最终数据
从0处开始滑动区间 ，right每加一次，就判断right这个元素和窗口内的元素是否满足某种条件
如果不满足了就进入处理块, 不断把left向右推进直到他满足条件, 在外层循环记录tmp和最大的max即可.(此题判断的条件是是否有重复元素，有就把left推进到重复的位置)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e23290a61a36ebba7772d62f04a4fd84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fbbea34b5f617970fb339795bd4dc3/" rel="bookmark">
			内联函数的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 主要为了提升程序运行速度。
分析 当程序调用一个函数时，程序暂停执行当前指令，跳到函数体处执行，在函数执行完后，返回原来的位置继续执行。如果该函数为内联函数，则不需跳，是因为该内联函数直接插入在被调用的位置，减少了调用函数时的时间开销。
扩展概念-虚拟内存 1、一种技术，管理计算机内存空间；
2、使得一个程序认为自己拥有连续的内存空间（一个完整、连续的空间）；
3、实际是分隔为多个内存碎片，还有部分存储在磁盘，在需要时进行数据交换；
4、每个进程创建时，内核为进程分配虚拟内存， 这时数据、代码还在硬盘上，当运行到对应的程序时，进程寻找页表，如果页表中的地址没有存放在物理内存上，而在硬盘上，会发生缺页异常，于是将磁盘上数据拷贝到物理内存中、并更新页表，下次再访问该虚拟地址时就能找到了；
5、每个进程都有独立的虚拟地址空间，不同进程的虚拟空间互不干扰；
6、每个进程独享自己的内存空间，当内存不够是，可以将不常用的内存快换出到磁盘中，下次使用时再换入内存；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669ed35880e8b22576b6d05c8bcc3156/" rel="bookmark">
			C&#43;&#43;上位软件通过LibModbus开源库和西门子S7-1200/S7-1500/S7-200 PLC进行ModbusTcp 和ModbusRTU 通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 一直以来上位软件比如C++等和西门子等其他品牌PLC之间的数据交换都是大家比较头疼的问题，尤其是C++上位软件程序员。传统的方法一般有OPC、Socket 等，直到LibModbus 开源库出现后这种途径对程序袁来说又有了新的选择。 Modbus简介 Modbus特点 1 ）使用简单，利用MUDBUS库文件简单的几条指令就能实现与智能仪表，变频器，打印机等设备进行通讯，且无需加其他硬件上的成本MODBUS总线广泛应用于仪器仪表、智能高低压电器、变送器、可编程控制器、人机界面、变频器、现场智能设备等诸多领域。MODBUS与其他的现场总线和工业网络相比有以下几个显著特点。 2）标准、开放:用户可以免费放心的使用 MODBUS协议，不用缴纳许可费用，不会涉及侵犯知识产权。目前支持MODBUS的厂一家超过400家，支持MODBUS的产品超过600种。在中国，MODBUS已经成为国家标准GB/T19582-2008。据不完全统 计：截止到2007年MODBUS的节点安装数量已经超过了1000万个。 3）应用广泛：凡MODBUS协议设备具有RS232/485接口的都可以使用本产品实现与现场总线PROFIBUS的互连。如：具有MODBUS协议接口的变频器、智能高低压电器、电机启动保护装置、电量测量装置、智能现场测量设备、各种变送器及仪表等。 4）MODBUS可以支持较多类型的电气接口：MODBUS 总线协议采用主站查询从站的方式，物理接口可以是RS232、RS485、RS422、RJ45，还可以在各种介质上传送，如双绞线、光纤、无线射频等。 5）MODBUS的帧格式较为简单、紧凑，格式规范，易于传输，通俗易懂。用户使用容易，厂商开发简单。用户不必了解PROFIBUS和MODBUS技术细节，只需参考说明手册及提供的应用实例，按要求完成配置，不需要复杂的编程，即可在短时间内实现设备间的连接通信。 6）透明通信：用户可以依照PROFIBUS通信数据区和MODBUS通信数据区的映射关系，实现PROFIBUS到MODBUS之间的数据透明通信。 LibModbus库下载 https://libmodbus.org/https://libmodbus.org/
https://gitcode.com/stephane/libmodbus/overview?utm_source=csdn_github_accelerator&amp;isLogin=1https://gitcode.com/stephane/libmodbus/overview?utm_source=csdn_github_accelerator&amp;isLogin=1https://github.com/stephane/libmodbushttps://github.com/stephane/libmodbushttps://download.csdn.net/download/lzc881012/88695801https://download.csdn.net/download/lzc881012/88695801
LibModbus库Windows版本的编译 1、进入到libmodbus\src\win32文件夹下。
2、双击configure.js文件进行编译,成功后会弹出编译完成窗口,点击关闭。
3、然后在双击modbus-9.sln通过VS打开项目,打开项目完成后编译即可。
4、编译完成后libmodbus\src\win32文件夹下就会出现modbus.dll和modbus.lib两个文件。 将上述步骤中生成的modbus.lib文件和libmodbus\src中所有的.h文件通过VS包含到自己的项目中即可。 在程序中包含libModbus/modbus.h一个头文件即可。 将上述步骤在生成的modbus.dll放到你的项目生成目录下,例如Debug/Release目录下。 LibModbus库modbus.h头文件 /* * Copyright © 2001-2013 Stéphane Raimbault &lt;stephane.raimbault@gmail.com&gt; * * SPDX-License-Identifier: LGPL-2.1+ */ #ifndef MODBUS_H #define MODBUS_H /* Add this for macros that defined unix flavor */ #if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG) #include &lt;sys/param.h&gt; #endif #ifndef _MSC_VER #include &lt;stdint.h&gt; #else #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/669ed35880e8b22576b6d05c8bcc3156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78859c6ddf8d70c43e8318fb3ae7e1b/" rel="bookmark">
			Flutter中的StatelessWidget和StatefulWidget简介与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter是一款流行的跨平台移动应用开发框架，它使用Dart语言编写。在Flutter中，StatelessWidget和StatefulWidget是两个重要的概念，用于构建用户界面。
1. StatelessWidget 什么是StatelessWidget？ StatelessWidget是Flutter中的一个基础类，用于构建不可变的用户界面。这意味着一旦创建，StatelessWidget的状态就不会再改变。通常，StatelessWidget用于展示静态内容，如显示文本、图像或图标。
如何使用StatelessWidget？ 在Flutter中，创建StatelessWidget非常简单。以下是一个简单的例子：
import 'package:flutter/material.dart'; class MyWidget extends StatelessWidget { @override Widget build(BuildContext context) { return Container( child: Text('Hello, Flutter!'), ); } } void main() { runApp(MyApp()); } 在这个例子中，MyWidget是一个继承自StatelessWidget的类，通过build方法返回一个包含文本的Container。
2. StatefulWidget 什么是StatefulWidget？ 与StatelessWidget不同，StatefulWidget是一个有状态的小部件，其状态可以在运行时发生变化。这使得StatefulWidget非常适用于需要动态更新的用户界面，如用户输入、网络请求等。
如何使用StatefulWidget？ 以下是一个简单的StatefulWidget的例子：
import 'package:flutter/material.dart'; class MyStatefulWidget extends StatefulWidget { @override _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState(); } class _MyStatefulWidgetState extends State&lt;MyStatefulWidget&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('StatefulWidget Example'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a78859c6ddf8d70c43e8318fb3ae7e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de87f11335d34498444fc0d65bd82533/" rel="bookmark">
			Spring MVC接口数据加密传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 假设现在有个需求，要实现接口请求体参数和响应数据的加密传输，换作是你会如何实现呢？
最容易想到的方案就是，在接口方法里直接接收加密后的密文字符串，手动解密成明文，再转换成对应的参数类型，伪代码如下所示：
@PostMapping("api") public Object api(@RequestBody String encryptedData) { String decryptedData = decrypt(encryptedData); Params params = JSON.parseObject(decryptedData); ..... } 这个方案的缺点是代码侵入性太强，接口方法更应该专注于业务。另外就是处理起来太麻烦，会产生很多冗余代码。
有没有更优雅的处理方式呢？
RequestResponseBodyAdviceChain 通过阅读 Spring MVC 的源码，我们发现它提供了两个很有用的接口：RequestBodyAdvice、ResponseBodyAdvice。从名字就可以看出来，它们分别是对请求体和响应体的增强接口。
实现 RequestBodyAdvice 接口，允许开发者在 Spring MVC 把请求体转换为方法参数前后做一些拦截处理。
public interface RequestBodyAdvice { // 是否支持给定参数？ boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType); // 读取请求体前置拦截，可以在这里修改请求体，例如数据解密 HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException; // 读取请求体后置拦截 Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de87f11335d34498444fc0d65bd82533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24ab2cbf93b1e5b2d1afcf82bd06a9b/" rel="bookmark">
			微信小程序控制元素显示隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一个示例代码，通过按钮的点击事件来控制元素的显示和隐藏：
// wxml文件 &lt;view&gt; &lt;button bindtap="toggleElement"&gt;点击切换元素显示与隐藏&lt;/button&gt; &lt;view wx:if="{{showElement}}"&gt; &lt;text&gt;这是要显示的元素&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; // js文件 Page({ data: { showElement: false }, toggleElement: function() { this.setData({ showElement: !this.data.showElement }); } }); 另一种方法 在微信小程序中，可以通过设置元素的 wx:if 或 wx:show 属性来控制元素的显示和隐藏。
使用 wx:if 属性：在需要控制显示隐藏的元素上添加 wx:if 属性，并绑定一个变量。当该变量为真时，元素显示；当该变量为假时，元素隐藏。 &lt;view wx:if="{{isShow}}"&gt;我是要显示的元素&lt;/view&gt; 在对应的 js 文件中，设置 isShow 变量的值，来控制元素的显示和隐藏。
data: { isShow: true // 默认显示 }, toggleShow: function() { // 点击按钮切换显示隐藏 this.setData({ isShow: !this.data.isShow }) } 使用 wx:show 属性：在需要控制显示隐藏的元素上添加 wx:show 属性，并绑定一个变量。当该变量为真时，元素显示；当该变量为假时，元素隐藏。 &lt;view wx:show="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24ab2cbf93b1e5b2d1afcf82bd06a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b3a786f04cfb05eed2f2f15bb160df/" rel="bookmark">
			抽象工厂模式？就是分门别类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 3、4节分别介绍了简单工厂方法与工厂方法，前两节分别学习了简单工厂模式与工厂方法模式，其中，工厂方法模式是为了解决简单工厂模式的扩展问题而出现的，但随之而来的就是其只能够“生产”同一类产品（产品族），如果要增加新的产品族，就比较麻烦，抽象工厂模式就是为解决“如何选择生成多个产品类”的问题而出现的。
什么是抽象工厂模式？ 我们首先来看一下抽象工厂模式的定义：**抽象工厂模式(Abstract Factory)，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。**它的UML类图表述如下：
应用 为了能够更好的区分工厂方法模式和抽象工厂模式，我们假定一个应用场景 ：“由于不同的客户要求，网站使用的数据库是不一样的，如何设计系统使得可以维护使用Access和使用SQL Server的数据库呢？注意，之后的数据库种类可能会继续增加”。
工厂方法模式 **假设现在系统只有一个User表，**基于工厂方法模式，可以设计系统的UML类图如下：
上图中，IFactory是一个接口，所有的数据库类都需要实现该接口；IUser表示操作User表的接口，现在给出了两种方法：新增yoghurt与插入用户。通过这种方式，实现了具体业务对象（User）与底层数据库类型的解耦。如果将具体的业务对象与数据库耦合，系统整体的移植性将大大降低。
User类
User类只有id和name两个字段，实现如下：
public class User { private int _id; private String name; public int getId() { return _id; } public void setId(int id) { this._id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } IUser接口
因为不同数据库的SQL语句是不一样的，因此该接口是为了解耦客户端与底层数据库。为简易代码，以插入/获取User为例：
public interface IUser { public void insert(User user); public User getUser(int id); } SqlserverUser类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b3a786f04cfb05eed2f2f15bb160df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8699082ab316f905ace8688e6f3396/" rel="bookmark">
			（附源码）SSM智慧旅游系统 毕业设计040929
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSM智慧旅游系统
摘要
随着社会的发展，社会的各行各业都在利用信息化时代的优势。计算机的优势和普及使得各种信息系统的开发成为必需。
智慧旅游系统设计，主要的模块包括查看首页、站点内容（轮播图、公告栏）系统用户（管理员、注册用户、导游）公共内容（旅游资讯、资讯分类）模块管理（地区管理、景点信息、景点购票、导游介绍、导游预约）等功能。系统中管理员主要是为了安全有效地存储和管理各类信息，还可以对系统进行管理与更新维护等操作，并且对后台有相应的操作权限。
要想实现智慧旅游系统的各项功能，需要后台数据库的大力支持。管理员验证注册信息，收集的用户信息，并由此分析得出的关联信息等大量的数据都由数据库管理用户咨询管理。本文中数据库服务器端采用了Mysql作为后台数据库，使Web与数据库紧密联系起来。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
本系统的开发使获取智慧旅游系统管理信息能够更加方便快捷，同时也使智慧旅游系统管理信息变的更加系统化、有序化。系统界面较友好，易于操作。
关键词：智慧旅游系统 ；Java；Mysql
Smart tourism system
Abstract
With the development of society, all walks of life are making use of the advantages of the information age. The advantages and popularity of computers make it necessary to develop various information systems.
In the design of smart tourism system, the main modules include the functions of viewing the home page, site content (carousel map, bulletin board), system users (administrators, registered users, Guides), public content (tourism information, information classification), module management (regional management, scenic spot information, scenic spot ticket purchase, guide introduction, guide reservation), etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8699082ab316f905ace8688e6f3396/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c37adc47f2eaff3d9c8aca289b620a/" rel="bookmark">
			postman使用-05新建测试集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 两种方式新建测试集测试集：允许用户以项目或模块的方式对多个接口进行分类和管理。每一个测试请求都可以被看作是一个独立的测试用例，而collections则可以同时管理多个测试用例的执行。方法一：点击左上角直接创建测试方法二：保存请求时候创建测试集 总结 两种方式新建测试集 测试集：允许用户以项目或模块的方式对多个接口进行分类和管理。每一个测试请求都可以被看作是一个独立的测试用例，而collections则可以同时管理多个测试用例的执行。 方法一：点击左上角直接创建测试 新建完成后通过rename修改名字
方法二：保存请求时候创建测试集 总结 两种方式新建测试集
测试集：允许用户以项目或模块的方式对多个接口进行分类和管理。每一个测试请求都可以被看作是一个独立的测试用例，而collections则可以同时管理多个测试用例的执行。
方法一：点击左上角直接创建测试
方法二：保存请求时候创建测试集
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5493ea471ee4e70bf06299c073244ed/" rel="bookmark">
			【Android】分层架构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 是一种基于 Linux 的开放源代码软件栈，主要应用于ARM平台，但不仅限于ARM，通过编译控制，在X86等体系结构的机器上同样可以运行。
与其他操作系统一样，Android也采用分层的架构设计，从高到低分别是系统应用层（System Apps），Java API 框架层（Java API Framework），Android系统运行层（包括Android Runtime和原生态的C/C++库 Native C/C++ Libraries）、硬件抽象层（Hardware Abstraction Layer）、Linux内核层（Linux Kernel）。如下图所示：
下面由下至上分别介绍各层
1、Linux内核层
Android是基于Linux内核的（Linux内核提供了安全性、内存管理、进程管理、网络协议和驱动模型等核心系统服务），Linux内核层为各种硬件提供了驱动程序，如显示驱动、相机驱动、蓝牙驱动、电池管理等等。
2、硬件抽象层（Hardware Abstraction Layer）
Android的硬件抽象层，简单来说，就是对Linux内核驱动程序的封装，向上提供接口，屏蔽低层的实现细节。HAL 可定义一个标准接口以供硬件供应商实现，这可让 Android 忽略较低级别的驱动程序实现。
3、Android系统运行层
这一层包括Android Runtime和原生态的C/C++库。
通过C或者C++库为Android系统提供主要的特性支持，例如Surface Manager管理访问显示子系统和从多模块应用中无缝整合2D和3D的图形，WebKit提供了浏览器支持等。可以使用 Android NDK 直接从访问某些原生态库。
Android运行时，其中包括了ART虚拟机（Android 5.0之前是Dalvik虚拟机，ART模式与Dalvik模式最大的不同在于，在启用ART模式后，系统在安装应用的时候会进行一次预编译，在安装应用程序时会先将代码转换为机器语言存储在本地，这样在运行程序时就不会每次都进行一次编译了，执行效率也大大提升。如果您的应用在 ART 上运行效果很好，那么它应该也可在 Dalvik 上运行，但反过来不一定。），每个Java程序都运行在ART虚拟机上，该虚拟机专门针对移动设备进行了定制，每个应用都有其自己的 Android Runtime (ART) 实例。此外，Android运行时还包含一套核心运行时库，可提供 Java API 框架使用的 Java 编程语言大部分功能，包括一些 Java 8 语言功能。
4、Java API 框架层
这一层主要提供了构建应用程序时可能用到的各种API，开发者通过这一层的API构建自己的APP，这一层也是APP开发人员必须要掌握的内容。
5、系统应用层
所有安装在手机上的系统应用都属于这一层，用户自己开发的应用也属于这一层。
最后分享一套由阿里高级架构师编写的《Android八大模块进阶资料》，帮助大家将杂乱、零散、碎片化的知识进行体系化的整理，让大家系统而高效地掌握Android开发的各个知识点。
由于文章内容比较多，篇幅有限，资料已经被整理成了PDF文档，有需要《Android八大模块进阶资料》完整文档的可以加微信 即可免费领取!
PS:（文末还有使用ChatGPT机器人小福利哦！！大家不要错过）
《Android八大模块进阶笔记》 相对于我们平时看的碎片化内容，这份笔记的知识点更系统化，更容易理解和记忆，是严格按照知识体系编排的。
一、源码解析合集 二、开源框架合集 同时这里还搭建了一个基于chatGPT的微信群聊机器人，24小时为大家解答疑难技术问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62861457c3cbc2ecf14f66d02f742a43/" rel="bookmark">
			解决Android开发中的痛点问题用Kotlin Flow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文旨在通过实际业务场景阐述如何使用Kotlin Flow解决Android开发中的痛点问题，进而研究如何优雅地使用Flow以及纠正部分典型的使用误区。有关Flow的介绍及其操作符用法可以参考：异步流 - Kotlin 语言中文站，本文不做赘述。基于LiveData+ViewModel的MVVM架构在某些场景下（以横竖屏为典型）存在局限性，本文会顺势介绍适合Android开发的基于Flow/Channel的MVI架构。
背景 大力智能客户端团队在平板端大力一起学App上深度适配了横竖屏场景，将原先基于Rxjava的MVP架构重构成基于LiveData+ViewModel+Kotlin协程的MVVM架构。随着业务场景的复杂度提升，LiveData作为数据的唯一载体似乎渐渐无法担此重任，其中一个痛点就是由于模糊了“状态”和“事件”的界限。LiveData的粘性机制会带来副作用，但这本身并不是LiveData的设计缺陷，而是对它的过度使用。
Kotlin Flow是基于kotlin协程的一套异步数据流框架，可以用于异步返回多个值。kotlin 1.4.0正式版发布时推出了StateFlow和SharedFlow，两者拥有Channel的很多特性，可以看作是将Flow推向台前，将Channel雪藏幕后的一手重要操作。对于新技术新框架，我们不会盲目接入，在经过调研试用一阶段后，发现Flow确实可以为业务开发止痛提效，下文分享这个探索的过程。
痛点一：蹩脚地处理ViewModel和View层通信 发现问题 当屏幕可旋转后，LiveData不好用了？ 项目由MVP过渡到MVVM时，其中一个典型的重构手段就是将Presenter中的回调写法改写成在ViewModel中持有LiveData由View层订阅，比如以下场景：
在大力自习室中，当老师切换至互动模式时，页面需要更改的同时还会弹出Toast提示模式已切换。
RoomViewModel.kt class RoomViewModel : ViewModel() { private val _modeLiveData = MutableLiveData&lt;Int&gt;(-1) private val modeLiveData : LiveData&lt;Int&gt; = _mode fun switchMode(modeSpec : Int) { _modeLiveData.postValue(modeSpec) } } RoomActivity.kt class RoomActivity : BaseActivity() { ... override fun initObserver() { roomViewModel.modeLiveData.observe(this, Observer { updateUI() showToast(it) }) } } 这样的写法乍一看没有毛病，但没有考虑到横竖屏切换如果伴随页面销毁重建的话，会导致在当前页面每次屏幕旋转都会重新执行observe，也就导致了每次旋转后都会弹一遍Toast。
LiveData会保证订阅者总能在值变化的时候观察到最新的值，并且每个初次订阅的观察者都会执行一次回调方法。这样的特性对于维持 UI 和数据的一致性没有任何问题，但想要观察LiveData来发射一次性的事件就超出了其能力范围。
当然，有一种解法通过保证LiveData同一个值只会触发一次onChanged回调，封装了MutableLiveData的SingleLiveEvent。先不谈它有没有其他问题，但就其对LiveData的魔改包装给我的第一感受是强扭的瓜不甜，违背了LiveData的设计思想，其次它就没有别的问题了吗？
ViewModel和View层的通信只依赖LiveData足够吗？ 在使用MVVM架构时，数据变化驱动UI更新。对于UI来说只需关心最终状态，但对于一些事件，并不全是希望按照LiveData的合并策略将最新一条之前的事件全部丢弃。绝大部分情况是希望每条事件都能被执行，而LiveData并非为此设计。
在大力自习室中，老师会给表现好的同学点赞，收到点赞的同学会根据点赞类型弹出不同样式的点赞弹窗。为了防止横竖屏或者配置变化导致的重复弹窗，使用了上面提到的SingleLiveEvent
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62861457c3cbc2ecf14f66d02f742a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e029bf98a80dda014f977d60266a2716/" rel="bookmark">
			8~15W | 项目需求：开发7自由度机械臂高效、精准的控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目来源：3D视觉从入门到精通知识星球
需求内容：
开发适用于7自由度机械臂的高效控制器，以实现精确的位置控制和姿态控制。
优化控制算法，提高机械臂的运动性能和响应速度。
确保控制器能够适应不同的工作环境和任务需求，具备良好的稳定性和鲁棒性。
在项目周期内完成控制器的开发与测试，提交可演示的demo，并准备相关的技术文档和使用说明。
工作环境：室内工作环境，光源稳定，识别的工作距离为1-3m。
项目经费：8~15万人民币
项目周期：6个月（从签订合同之日起）
项目阶段：项目资金已到位，需求调研已完成，开发阶段开始实施。
联系方式：公众号「3DCV」后台回复「机械臂」，获取项目方联系方式，星球成员可直接在星球内获取。
下载 在公众号「3D视觉工坊」后台，回复「3dcv」,即可获取工业3D视觉、SLAM、自动驾驶、三维重建、事件相机、无人机等近千余篇最新顶会论文；巴塞罗那自治大学和慕尼黑工业大学3D视觉和视觉导航精品课件；相机标定、结构光、三维重建、SLAM，深度估计、模型部署、3D目标检测等学习资料。
3D视觉方向交流群成立啦 目前工坊已经建立了3D视觉方向多个社群，包括SLAM、工业3D视觉、自动驾驶、三维重建、无人机方向，细分群包括：
[工业3D视觉]相机标定、立体匹配、三维点云、结构光、机械臂抓取、缺陷检测、6D位姿估计、相位偏折术、Halcon、摄影测量、阵列相机、光度立体视觉等。
[SLAM]视觉SLAM、激光SLAM、语义SLAM、滤波算法、多传感器融合、多传感器标定、动态SLAM、MOT SLAM、NeRF SLAM、机器人导航等。
[自动驾驶]深度估计、Transformer、毫米波|激光雷达|视觉摄像头传感器、多传感器标定、多传感器融合、自动驾驶综合群等、3D目标检测、路径规划、轨迹预测、3D点云分割、模型部署、车道线检测、Occupancy、目标跟踪等。
[三维重建]NeRF、多视图几何、OpenMVS、MVSNet、colmap、纹理贴图等
[无人机]四旋翼建模、无人机飞控等
除了这些，还有求职、硬件选型、视觉产品落地、最新论文、3D视觉最新产品、3D视觉行业新闻等交流群
大家可以添加小助理微信: dddvisiona，备注：加群+方向+学校|公司, 小助理会拉你入群。
添加小助理微信：dddvisiona，加群+方向+学校|公司，拉你入群 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5aaf61c9881aa198f4d832e9b4cbd20/" rel="bookmark">
			哈佛大学校长辞职
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 来源：小木虫
据央视新闻消息，当地时间1月2日，据多家美国媒体报道，美国哈佛大学校长克劳丁·盖伊（Claudine Gay）于当日宣布辞职。
盖伊在声明中说，她近几个月来目睹学校的紧张和分裂削弱了信任的纽带，人们对她反对仇恨和维护学术严谨的承诺产生怀疑。在与哈佛大学校董委员会成员沟通后，她决定辞去校长一职，这符合哈佛大学的最佳利益。
哈佛大学校董委员会当天在一份声明中说，哈佛大学和美国高等教育近期面临一系列前所未有的挑战和不断升级的争议与冲突。盖伊和有关方面一直寻求以哈佛大学最佳利益为指导共同应对挑战。在经过综合考量后，校方接受盖伊的辞职，哈佛大学教务长艾伦·加伯将担任临时校长。
这是1月2日拍摄的有盖伊照片的哈佛大学官网校长办公室页面。图源：新华社
克劳丁·盖伊去年7月出任哈佛大学校长，是哈佛大学历史上任职时间最短的校长。在哈佛大学387年的历史上，她不仅是哈佛历史上第二位女校长，更是第一位黑人校长。
不过，这位正式就职还不到半年的校长却麻烦缠身，不仅深陷“反犹”风波被众多校友攻击和指责，而且还在国会听证时表现糟糕，被要求下台。
2023年12月初，哈佛大学校长盖伊、麻省理工大学校长科恩布卢思以及宾夕法尼亚大学校长马吉尔三位顶级大学校长就校园反犹问题出席该委员会听证，这场听证会持续了5个小时。在接受美政客质询时，双方火药味十足。
12月8日，超70名美国两党议员发出联名信，要求这三大美国名校立即罢免学校校长，理由是他们对校长们在听证会上的证词感到不满。
随后， 在巨大压力下，当地时间12月9日，宾夕法尼亚大学校长马吉尔宣布辞职，盖伊和科恩布卢思进行了官方道歉，但这些行动都未能平息外界的批评声浪。
宾夕法尼亚大学校长利兹·马吉尔。图源：VCG
2023年12月11日，美国知名记者克里斯托弗·鲁福在个人网站发布调查结果，认为盖伊的论文涉嫌严重抄袭。而在此前，斯坦福大学已经有过校长因“学术不端”辞职的先例，这让盖伊站到了舆论的火山口。
12月20日，美国会众院教育和劳工委员会宣布，对哈佛大学是否妥善处理针对其校长克劳丁·盖伊的抄袭指控展开调查，并要求在12月29日前就一系列问题做出答复，包括哈佛大学是否对教员和学生一视同仁。
来源：综合央视新闻、新华社、观察者网、金融时报等。内容仅做学术分享之用，版权归原作者所有，若涉及侵权等行为，请联系我们删除，万分感谢！
下载 在公众号「3D视觉工坊」后台，回复「 3dcv」,即可获取工业3D视觉、SLAM、自动驾驶、三维重建、事件相机、无人机等近千余篇最新顶会论文；巴塞罗那自治大学和慕尼黑工业大学3D视觉和视觉导航精品课件；相机标定、结构光、三维重建、SLAM，深度估计、模型部署、3D目标检测等学习资料。
3D视觉方向交流群成立啦 目前工坊已经建立了3D视觉方向多个社群，包括SLAM、工业3D视觉、自动驾驶、三维重建、无人机方向，细分群包括：
[工业3D视觉]相机标定、立体匹配、三维点云、结构光、机械臂抓取、缺陷检测、6D位姿估计、相位偏折术、Halcon、摄影测量、阵列相机、光度立体视觉等。
[SLAM]视觉SLAM、激光SLAM、语义SLAM、滤波算法、多传感器融合、多传感器标定、动态SLAM、MOT SLAM、NeRF SLAM、机器人导航等。
[自动驾驶]深度估计、Transformer、毫米波|激光雷达|视觉摄像头传感器、多传感器标定、多传感器融合、自动驾驶综合群等、3D目标检测、路径规划、轨迹预测、3D点云分割、模型部署、车道线检测、Occupancy、目标跟踪等。
[三维重建]NeRF、多视图几何、OpenMVS、MVSNet、colmap、纹理贴图等
[无人机]四旋翼建模、无人机飞控等
除了这些，还有求职、硬件选型、视觉产品落地、最新论文、3D视觉最新产品、3D视觉行业新闻等交流群
大家可以添加小助理微信：dddvisiona，备注：加群+方向+学校|公司, 小助理会拉你入群。
添加小助理微信：dddvisiona，加群+方向+学校|公司，拉你入群 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eca47d04134031b5f9b18a1742d157e/" rel="bookmark">
			最新DAU-FI Net，突破多类缺陷分割性能边界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作者：小张Tt | 来源：3D视觉工坊
在公众号「3D视觉工坊」后台，回复「原论文」可获取论文pdf
添加微信：dddvision，备注：缺陷检测，拉你入群。文末附行业细分群
本文提出的DAU-FI Net架构通过整合多尺度空间-通道注意力机制和特征注入，解决了语义分割中多类别不平衡、样本有限的挑战。其核心是多尺度深度可分离卷积块，配合空间-通道压缩与激励（scSE）注意力单元，增强了物体定位的精度。通过添加注意力门连接编码器-解码器路径，进一步优化了分割效果。工程化特征使用Gabor滤波器进行纹理分析，Sobel和Canny滤波器进行边缘检测，受语义掩模指导的注入扩展了特征空间。实验证明了DAU-FI Net在污水管道和涵洞缺陷数据集以及基准数据集上的卓越表现，达到了95.6%和98.8%的交并比（IoU），分别超过先前方法8.9%和12.6%。该架构为解决具有挑战性的语义分割问题提供了鲁棒的解决方案，为基于深度学习的技术在基础设施检测领域的自动化提供了可靠性和效率。同时，像素级别的缺陷数据集也为未来研究提供了新的方向。
读者理解： DAU-FI Net 在多尺度空间通道注意力 (MSCA) 模块和特征注入 (FI) 模块两个方面都具有创新性。
MSCA 模块可以有效地捕捉不同尺度和通道之间的相互依赖关系，提高物体定位的精度。
FI 模块可以有效地扩展特征空间，提高分割性能。
DAU-FI Net 在两个数据集上都取得了 state-of-the-art 的结果，表明其具有良好的泛化能力。
1 引言 本文提出了一种新颖的双重注意力U-Net架构（DAU-FI Net），它集成了定制的多尺度空间-通道注意力机制，并巧妙地注入工程化图像特征，以增强在训练数据有限的多类别分割中的精度。它引入了一个双重注意力块，融合了多尺度卷积和同时进行的空间-通道压缩和激励建模，以捕获局部模式和全局上下文。我们在一个具有挑战性的现实世界污水管道-涵洞缺陷分割数据集上实现了最先进的性能，并且明确超越了先前方法，并在细胞核分割基准上验证了泛化能力。详细的消融研究分析了关键组件的渐进益处。我们提供了一个具有像素级注释的污水管道-涵洞缺陷数据集，涵盖了多种缺陷类型，以推进这一安全关键领域的未来研究。
2 方法 U-Net架构及其扩展：
文章首先回顾了全卷积网络（FCN）和U-Net等语义分割的基本概念。U-Net以其编码器-解码器结构和跳跃连接在语义分割中取得显著成果。文章指出U-Net在医学成像等领域表现出色，尤其是在处理数据稀缺情况下表现突出。
先前工作的基础：
在之前的工作中，作者们提出了改进的U-Net架构，引入了一个多尺度深度可分离卷积块，以捕获多尺度的特征信息。然而，这个模型仍需要应对多类别数据集、样本不平衡以及相似类别之间的挑战。
DAU-FI Net模型架构：
U-Net编码器-解码器骨干架构与注意力跳跃连接：DAU-FI Net采用了关注机制和跳跃连接，增强了分割的精度和重建保真度。特别是引入了注意力门，选择性地强调和抑制编码器特征图中的结构。
双重注意力块：核心是DAB，将多尺度深度可分离卷积块与修改后的空间通道压缩和激励（scSE）注意力机制相结合。这种融合机制极大地提高了分割的效果，有效地融合了局部模式、上下文关系和尺度动态。
战略性特征增强：通过引入手工设计的特征，如Gabor滤波器、边缘检测器、梯度方向直方图（HOG）和颜色/强度分析，扩展了模型的特征空间。这种特征融合能够有效地克服数据限制，提升了模型的分割性能。
特征融合：在特征融合方面，文章介绍了对这些工程特征进行提取和注入模型的方法，包括对特征注入位置和方式的深入研究，以优化模型的性能。
模型评估：
文章提出了一种针对污水管道和横管缺陷的数据集，并对模型进行了全面的评估和分析。作者们展示了模型在多类别分割任务上的优越性能，以及注意力机制和特征增强在提升模型性能方面的显著作用。
总的来说，这篇文章通过双重注意力机制和特征融合的创新方法，对于解决语义分割中的样本有限和多类别不平衡问题取得了显著进展，为在实际管道检测中提高分割准确性和性能提供了关键思路和方法。
3 总结 该研究的结论突显了在多类别语义分割领域中的重要进展。DAU-FI Net架构作为该研究的核心，创新地融合了多尺度深度可分卷积与先进的并发空间通道压缩与激励注意力单元，有效地解决了有限训练数据下的分割挑战。在对污水管道和横管缺陷数据集以及基准数据集的严格测试中，DAU-FI Net表现出了稳健性，并通过消融研究证实了其关注机制和战略特征注入对提高性能的重要性。
该研究的方法不仅提升了分割的准确性，而且并未引入显著的计算负担。尤其值得注意的是，本研究彰显了如何将领域特定的工程化特征有效地融入深度学习框架，为数据稀缺情况下的应用提供了有益的见解。
通过对特征注入和空间通道注意力的创新方法，该研究为解决复杂分割任务提供了新的视角。使用污水管道和横管缺陷数据集的应用为未来研究探索开辟了新的方向。虽然在两个数据集上进行测试，但DAU-FI Net显示出在各种分割任务中的潜在潜力。
下载 在公众号「3D视觉工坊」后台，回复「3dcv」,即可获取工业3D视觉、SLAM、自动驾驶、三维重建、事件相机、无人机等近千余篇最新顶会论文；巴塞罗那自治大学和慕尼黑工业大学3D视觉和视觉导航精品课件；相机标定、结构光、三维重建、SLAM，深度估计、模型部署、3D目标检测等学习资料。
3D视觉方向交流群成立啦 目前工坊已经建立了3D视觉方向多个社群，包括SLAM、工业3D视觉、自动驾驶、三维重建、无人机方向，细分群包括：
[工业3D视觉]相机标定、立体匹配、三维点云、结构光、机械臂抓取、缺陷检测、6D位姿估计、相位偏折术、Halcon、摄影测量、阵列相机、光度立体视觉等。
[SLAM]视觉SLAM、激光SLAM、语义SLAM、滤波算法、多传感器融合、多传感器标定、动态SLAM、MOT SLAM、NeRF SLAM、机器人导航等。
[自动驾驶]深度估计、Transformer、毫米波|激光雷达|视觉摄像头传感器、多传感器标定、多传感器融合、自动驾驶综合群等、3D目标检测、路径规划、轨迹预测、3D点云分割、模型部署、车道线检测、Occupancy、目标跟踪等。
[三维重建]NeRF、多视图几何、OpenMVS、MVSNet、colmap、纹理贴图等
[无人机]四旋翼建模、无人机飞控等
除了这些，还有求职、硬件选型、视觉产品落地、最新论文、3D视觉最新产品、3D视觉行业新闻等交流群
大家可以添加小助理微信: dddvisiona，备注：加群+方向+学校|公司, 小助理会拉你入群。
添加小助理微信：dddvisiona，加群+方向+学校|公司，拉你入群 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbfa15165a102c52d24dfa3414d1b222/" rel="bookmark">
			通用性和精度全拉满！谷歌最新发布最强零样本深度估计！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 来源：3D视觉工坊
在公众号「3D视觉工坊」后台，回复「原论文」可获取论文pdf、主页链接
这里给大家推荐下深度估计微信群，扫码入群，方便大家沟通交流：
1. 笔者个人体会 由于室内和室外场景之间的RGB和深度的巨大变化，以及未知的相机固有特性导致的深度尺度模糊，zero-shot度量深度估计非常难。
今天笔者将为大家分享谷歌最新发布的工作DMD，是单目绝对深度估计的最新SOTA扩散模型。DMD在室内zero-shot数据集上实现了25%的相对误差(REL)减少，在室外zero-shot数据集上实现了33%的相对误差减少。
下面一起来阅读一下这项工作~
2. 效果展示 对比方案主要是之前的ZoeDepth，在室内室外都取得了非常好的定性效果。
DMD相对于ZoeDepth在所有zero-shot基准上都有大幅度的提高，可惜没开源。这里也推荐工坊推出的新课程《单目深度估计方法：算法梳理与代码实现》。
3. 具体原理是什么？ DMD做了很多创新，例如使用对数尺度深度参数化来实现室内和室外场景的联合建模，调节视野(FOV)来处理尺度模糊性，并在训练期间综合增强FOV，以概括训练数据集中有限的相机固有特性。具体贡献如下：
1、室内外联合建模：不是将深度线性映射到[ - 1 , 1]，而是在对数尺度上对深度进行参数化，以更公平地分配室内外场景之间的表示能力。
2、处理不同的相机内参：为了避免对训练相机内参的过拟合，提出通过裁剪和未裁剪(用噪声填充)来增加训练数据，以模拟不同的视野( FOV )。进一步对垂直FOV进行条件限制，消除深度尺度的歧义。
3、多样化的训练数据：使用了多样化的微调混合，这在单独使用NYU和KITTI数据集的微调上显著提高了性能。
4、推理延迟：使用扩散的v参数化而不是通常使用的e参数化，这使得在推理过程中使用最少1个去噪步骤。
4. 和其他SOTA方法对比如何？ 在室内(第一张表)和室外(第二张表)场景下，定量比较DMD和当前SOTA的零样本度量深度估计。DMD在两个领域上都大幅度地提高了性能。
对更多实验结果和文章细节感兴趣的读者，可以阅读一下论文原文~
下载 在公众号「3D视觉工坊」后台，回复「 3dcv」,即可获取工业3D视觉、SLAM、自动驾驶、三维重建、事件相机、无人机等近千余篇最新顶会论文；巴塞罗那自治大学和慕尼黑工业大学3D视觉和视觉导航精品课件；相机标定、结构光、三维重建、SLAM，深度估计、模型部署、3D目标检测等学习资料。
3D视觉方向交流群成立啦
目前工坊已经建立了3D视觉方向多个社群，包括SLAM、工业3D视觉、自动驾驶、三维重建、无人机方向，细分群包括：
[工业3D视觉]相机标定、立体匹配、三维点云、结构光、机械臂抓取、缺陷检测、6D位姿估计、相位偏折术、Halcon、摄影测量、阵列相机、光度立体视觉等。
[SLAM]视觉SLAM、激光SLAM、语义SLAM、滤波算法、多传感器融合、多传感器标定、动态SLAM、MOT SLAM、NeRF SLAM、机器人导航等。
[自动驾驶]深度估计、Transformer、毫米波|激光雷达|视觉摄像头传感器、多传感器标定、多传感器融合、自动驾驶综合群等、3D目标检测、路径规划、轨迹预测、3D点云分割、模型部署、车道线检测、Occupancy、目标跟踪等。
[三维重建]NeRF、多视图几何、OpenMVS、MVSNet、colmap、纹理贴图等
[无人机]四旋翼建模、无人机飞控等
除了这些，还有求职、硬件选型、视觉产品落地、最新论文、3D视觉最新产品、3D视觉行业新闻等交流群
大家可以添加小助理微信：dddvisiona，备注：加群+方向+学校|公司, 小助理会拉你入群。
添加小助理微信：dddvisiona，加群+方向+学校|公司，拉你入群 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be163f3a46a51a12011f11a256415061/" rel="bookmark">
			【二叉树】654.最大二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
法1：递归 class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { TreeNode root = build(nums, 0, nums.length - 1); return root; } public TreeNode build(int[] nums, int start, int end) { if (start &gt; end) { return null; } if (start == end) { return new TreeNode(nums[start]); } int maxInx = start; int maxVal = nums[start]; for (int i = start; i &lt;= end; ++i) { if (nums[i] &gt; nums[maxInx]) { maxInx = i; maxVal = nums[i]; } } TreeNode root = new TreeNode(maxVal); root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be163f3a46a51a12011f11a256415061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5503e41dfdaf659e8dedc176e64099/" rel="bookmark">
			一文通透Text Embedding模型：从text2vec、openai-ada-002到m3e、bge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文已经是今年的第31篇大模型相关的技术文章了，如果说
半年之前写博客，更多是出于个人兴趣 + 读者需要那自我司于23年Q3组建LLM项目团队之后，写博客就成了：个人兴趣 + 读者需要 + 项目需要
如此兼备三者，实在是写博客之幸运矣 我和我司更非常高兴通过博客、课程、内训、项目，与大家共同探讨如何把先进的大模型技术更好、更快的落地到各个行业的业务场景中，赋能千千万万公司的实际业务
而本文一开始是属于：因我司第三项目组「知识库问答项目」而起的此文《知识库问答LangChain+LLM的二次开发：商用时的典型问题及其改进方案》中的1.2节(该1.2节初稿来自我司LLM项目团队第三项目组的bingo)，但为把Text Embedding模型阐述的更为精准、全面，特把那部分的内容抽取出来，不断完善成此文
最终尽可能相比网上已有的其他资料都更细致化
第一部分 衡量文本向量表示效果的榜单：MTEB、C-MTEB 1.2 《MTEB: Massive Text Embedding Benchmark(海量文本嵌入基准)》 判断哪些文本嵌入模型效果较好，通常需要一个评估指标来进行比较，《MTEB: Massive Text Embedding Benchmark(海量文本嵌入基准)》就是一个海量文本嵌入模型的评估基准
论文地址：https://arxiv.org/abs/2210.07316
MTEB包含8个语义向量任务，涵盖58个数据集和112种语言。通过在MTEB上对33个模型进行基准测试，建立了迄今为止最全面的文本嵌入基准。我们发现没有特定的文本嵌入方法在所有任务中都占主导地位。这表明该领域尚未集中在一个通用的文本嵌入方法上，并将其扩展到足以在所有嵌入任务上提供最先进的结果github地址：https://github.com/embeddings-benchmark/mteb#leaderboard 榜单地址：https://huggingface.co/spaces/mteb/leaderboard
1.2 中文海量文本embedding任务排行榜：C-MTEB 从Chinese Massive Text Embedding Benchmark中可以看到目前最新的针对中文海量文本embedding的各项任务的排行榜，针对不同的任务场景均有单独的排行榜。
任务榜单包括：
RetrievalSTSPairClassificationClassificationRerankingClustering 其中，在本地知识库任务中，主要是根据问题query的embedding表示到向量数据库中检索相似的本地知识文本片段。因此，该场景主要是Retrieval检索任务。检索任务榜单如下：
目前检索任务榜单下效果最好的是bge系列的bge-large-zh模型，langchain-chatchat项目中默认的m3e-base也处于比较靠前的位置
第二部分 text-embedding-ada-002 2.1 模型简介 text-embedding-ada-002是OpenAI提供的一个embedding模型，但需要调用接口付费使用。其具有如下特点：
统一能力：OpenAI通过将五个独立的模型(文本相似性、文本搜索-查询、文本搜索-文档、代码搜索-文本和代码搜索-代码)合并为一个新的模型
在一系列不同的文本搜索、句子相似性和代码搜索基准中，这个单一的表述比以前的嵌入模型表现得更好上下文：上下文长度为8192，使得它在处理长文档时更加方便嵌入尺寸：只有1536个维度，是davinci-001嵌入尺寸的八分之一，使新的嵌入在处理矢量数据库时更具成本效益 2.2 模型使用 以下是OpenAI官方文档中给出的用于文本搜索的代码实例
from openai.embeddings_utils import get_embedding, cosine_similarity def search_reviews(df, product_description, n=3, pprint=True): embedding = get_embedding(product_description, model='text-embedding-ada-002') df['similarities'] = df.ada_embedding.apply(lambda x: cosine_similarity(x, embedding)) res = df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a5503e41dfdaf659e8dedc176e64099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ce19ece66740f36d541fe3ef13b9a9/" rel="bookmark">
			pytorch深度学习笔记（共计169页，基于本人听完B站小土堆PyTorch深度学习快速入门教程所写）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、笔记视频 pytorch深度学习（共计169页，基于本人听完B站小土堆PyTorch深度学习快速入门教程所写）
二、获取方式 方式一：
点击下面的链接
pytorch深度学习笔记
如果链接无法打开
直接复制下方链接即可
https://mall.bilibili.com/neul-next/index.html?page=mall-up_itemDetail&amp;noTitleBar=1&amp;itemsId=1105223075&amp;from=items_share&amp;msource=items_share
方式二：
扫码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258b765f55a65a3287bb8ae31cea0d6e/" rel="bookmark">
			人机之间的联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人机之间的联系指的是人类和机器之间的交互和合作关系。人机联系的目的是通过利用机器的计算能力和人类的智能能力来实现更高效、更准确的工作和决策。
人机之间的看得见的链接，是指人与机器之间通过视觉、听觉等感官传递信息的方式，如人与电脑之间通过显示器、键盘、鼠标等硬件设备进行交互，通过屏幕上的图像和文字、鼠标的移动和点击来进行操作。人机之间的看不见的链接，则是指人与机器之间通过软件、网络等方式传递信息的联系，如人与电脑之间通过软件应用进行数据交互，通过互联网或局域网进行通信传输数据。这些看不见的链接包括了操作系统、应用程序、编程语言、网络协议等技术，使人与机器能够有效地进行交互和通信。
人机之间的因果联系既包括我们可以直接观察和理解的因果联系，也包括我们无法直接观察和理解的因果联系。这些因果联系一起构成了人机交互的复杂性。看得见的因果联系是指人们可以直接观察和理解的人机交互过程中的因果关系。例如，当我们在键盘上输入字母时，电脑会根据我们的输入显示相应的字符，这是因为我们的输入引起了电脑软件的响应。另一方面，看不见的因果联系是指人们无法直接观察和理解的人机交互过程中的因果关系。例如，在机器学习中，我们可以训练一个机器学习模型来根据输入的图片识别物体。然而，我们无法准确地知道模型是如何通过计算来得出识别结果的，这种因果联系是看不见的。
人机之间的联系既有事实性的关联，也有价值性的关联。这种联系使得计算机成为人类生活中不可或缺的工具和资源。事实性的联系指的是人机之间基于真实和可量化数据的相互关联。人类使用计算机进行各种任务和活动时，需要输入真实的数据来获得计算机的输出结果。计算机则根据输入的数据进行计算和处理，提供相应的输出。这种联系确保了人机之间的信息流动和相互依赖。价值性的联系指的是人机之间基于人类的需求和价值观念的关联。人类使用计算机往往是出于解决问题、提高效率、娱乐等目的。计算机的存在和发展使得人类能够更好地满足自身的需求和实现自身的价值。例如，人类使用计算机编写代码来开发应用程序，利用计算机进行科学研究，或者使用计算机来进行在线购物等活动。人机之间的价值性联系体现了计算机在人类生活中的重要作用。人机之间有事实性的计算和价值性的算计。在事实性计算方面，机器可以进行大规模的数据处理和分析，从而帮助人们快速获取和处理大量的信息。例如，机器学习算法可以通过分析大量的数据来预测未来的趋势和结果，帮助企业做出决策。此外，机器还可以通过计算模拟和预测天气、地震、流行病等自然现象，提供重要的预警和决策支持。在价值性的算计方面，机器可以根据人们的需求和偏好，进行推荐和优化。例如，在电商平台上，机器可以根据用户的浏览和购买记录，推荐符合其兴趣和需求的商品。在个人金融领域，机器可以根据用户的风险承受能力和投资目标，进行资产配置和投资建议。然而，虽然人机之间可以进行计算和算计，但是在某些情况下，机器仍然无法完全替代人类。例如，在伦理、道德和情感等领域，机器难以做出准确的判断和决策。因此，在人机合作中，人类的专业知识、判断力和道德观念仍然起到重要的作用。
人机之间的联系既有逻辑性的关联，也有非逻辑性的关联。人机之间的联系既有逻辑性的关联，也有非逻辑性的关联。逻辑性的关联是指人机之间的交互和合作是基于一定的规则和逻辑性进行的，比如人通过输入指令或操作，机器按照程序或算法进行处理和响应。这种关联主要体现在人机界面的设计、人机交互的规范、程序逻辑的实现等方面。非逻辑性的关联则是指人机之间的联系不仅仅局限于逻辑性的规则，还包括了直觉、情感和非语言的交流等。人类在与机器交互的过程中往往会产生一种情感上的联系，比如对机器的喜爱、信任或者依赖。此外，机器也可以通过感知人类的情感和非语言信号来做出相应的回应，比如语音识别、情感分析等技术的运用。总而言之，人机之间的联系不仅仅是一种机械的逻辑关系，还包括了情感、直觉和非语言的交流等非逻辑性的关联。这种联系的多样性和复杂性使得人机交互更加丰富和灵活。
人机之间的协同是整体性的、关系性的、情境性的。人机协同强调整体合作，人和机器互补，共同完成任务。人类提供思考、决策、创造等高级能力，而机器提供计算、存储、自动化等能力，二者相互协同，形成整体的工作效能。人机协同强调人与机器之间的关系，不仅限于简单的指令和执行，而是建立起一种互动和合作的关系，人和机器需要相互理解、信任和支持，才能更好地合作。人机协同的方式和效果受到情境的影响，不同的任务和环境需要不同的人机协同方式和策略，人机协同需要根据具体情境的要求来调整和优化合作模式，以达到更好的效果。
人机协同可以调动出人本身不同的特性，既有显性的也有隐性的特性。首先，人机协同可以调动出人的智力特性。人类具有思考、分析和判断等高级智力能力，而机器则能提供大量的数据和计算能力，可以帮助人类更快、更准确地进行决策和解决问题。其次，人机协同可以调动出人的创造力特性。人类拥有独特的想象力和创造能力，而机器则可以模拟和生成各种创意和设计，可以为人类提供新的灵感和创意方向。此外，人机协同还可以调动出人的情感特性。人类具有情感、情绪和社交能力，而机器可以通过语音识别、情感分析等技术来感知和理解人类的情感状态，从而提供更好的沟通和交互体验。最后，人机协同还可以调动出人的体力特性。机器人和自动化设备可以为人类提供物质力量和劳动力，可以在重复、繁重的工作中代替人类，从而释放人类的体力和时间，让人们能够更专注于需要人类特性的工作和活动。总的来说，人机协同可以调动出人类不同的特性，充分发挥人类的智力、创造力、情感和体力等优势，同时结合机器的计算能力和物质力量，实现更高效、更全面的工作和生活方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728e3d3f606347d12cf32911b4f6b381/" rel="bookmark">
			APPnium 自动化实践 ：第一步adb 连接手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载安装 adb ,添加到环境变量。
ADB Download - Get the latest version of ADB and fastboot
2. 手机开启开发者模式 https://developer.huawei.com/consumer/cn/doc/quickApp-Guides/quickapp-open-developer-option-0000001137005543
3. adb 连接设备 【Andriod】adb调试安卓手机时连接真机或模拟器的3种方法，你知道么？_adb连接手机-CSDN博客
adb devices： 获取设备和设备的状态列表
adb devices -l 查看已连接的设备
adb get-serialno 设备号
adb get-state： 获取设备的状态（设备的状态有三种：device，设备连接正常；offline，连接出现异常，设备无响应；unknown，设备未连接；）
adb connect [ip:port]： 远程连接设备（用于在同一网络下adb无线连接设备）
adb disconnect [ip:port]： 断开设备连接（用于在同一网络下adb无线连接设备）
adb reboot： 重启设备
注：连接不成功，检查以下问题
确保网络和端口都没有问题，使用的是原装数据线
请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect 那一步
通过adb kill-server重新启动 adb 然后从头再来一次试试
重启设备 adb shell 登录设备
【Andriod】adb调试安卓手机时连接真机或模拟器的3种方法，你知道么？_adb连接手机-CSDN博客
建立连接
基本命令
adb -d：如果同时连了usb，又开了模拟器，连接当前唯一通过usb连接的安卓设备
adb -e shell：指定当前连接此电脑的唯一的一个模拟器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728e3d3f606347d12cf32911b4f6b381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ed8c17bfcee80489f24424fd69fdd2/" rel="bookmark">
			jwt工具类（配置即用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jwtUtil.class
package com.huang.springsecuritydemo.Utils; import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; import java.util.Date; import java.util.UUID; public class JwtUtil { //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文, 注意长度必须大于等于6位 public static final String JWT_KEY = "huanfqc"; public static String getUUID(){ String token = UUID.randomUUID().toString().replaceAll("-", ""); return token; } /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) { JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ed8c17bfcee80489f24424fd69fdd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a965e8dfc6f25de1c7cb2aa1459ed2/" rel="bookmark">
			Django 7 实现Web便签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效果图 二、会用到的知识 目录结构与URL路由注册request与response对象模板基础与模板继承ORM查询后台管理 三、实现步骤 1. terminal 输入 django-admin startapp the_10回车
2. 注册， 在 tutorial子文件夹settings.py INSTALLED_APPS 中括号添加 "the_10"
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', "the_3", "the_5", "the_6", "the_7", "the_8", "the_9", "the_10", ] 3. 路由 tutorial子文件夹 urls.py urlpatterns = [ path('admin/', admin.site.urls), path('the_3/', include('the_3.urls')), path('the_4/', include('the_4.urls')), path('the_5/', include('the_5.urls')), path('the_7/', include('the_7.urls')), path('the_10/', include('the_10.urls')), ] 4. the_10文件夹新建子文件夹 urls.py
from django.urls import path from .views import index urlpatterns = [ path('index/', index), ] 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25a965e8dfc6f25de1c7cb2aa1459ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6beeab9b33321a5310bd59717c5686e/" rel="bookmark">
			数据结构 第八章节 排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：1.数据结构C语言版|第2版；2.力扣；3.2024年数据结构考研复习指导。三个参考分别依次对应文章三个部分。
文章目录 第一部分基本概念插入排序直接插入排序折半插入排序希尔排序(缩小增量排序) 交换排序冒泡排序快速排序 选择排序简单选择排序堆排序 归并排序 第二部分268. 丢失的数字448. 找到所有数组中消失的数字506. 相对名次645. 错误的集合953. 验证外星语词典1051. 高度检查器75. 颜色分类215. 数组中的第K个最大元素229. 多数元素II41. 缺失的第一个正数 第三部分 第一部分 基本概念 排序定义：排序是按关键字的非递减或非递增的顺序重新排列记录序列。排序的稳定性：当两个记录的关键字相同并且排序没有改变这两个记录的原有顺序，那我们就说排序是稳定的，反之，排序是不稳定的。内部排序和外部排序：内部排序：完全在内存中完成的排序；外部排序：不完全在内存中完成的排序。
插入排序 插入排序的基本思想是：每一次排序将一个新的记录插入到已经排序好的子序列当中。
直接插入排序 稳定排序
时间复杂度：O ( n 2 ) \left(n^2\right) (n2)
空间复杂度：O ( 1 ) \left(1\right) (1)
#include&lt;iostream&gt; using namespace std; void InsertSort(int *,int); void print(int *,int); int main() { int n;cin&gt;&gt;n; int * lb=new int [n]; for (int i=0;i&lt;n;i++) cin&gt;&gt;lb[i]; InsertSort(lb,n); print(lb,n); delete [] lb; return 0; } void InsertSort(int * lb,int len) { for (int i=1;i&lt;len;i++) { if (lb[i]&gt;=lb[i-1]) continue; int temp=lb[i],j=i-1; for (;j&gt;=0 and temp&lt;lb[j];j--) lb[j+1]=lb[j]; lb[j+1]=temp; } } void print(int * lb,int len) { for (int i=0;i&lt;len;i++) cout&lt;&lt;lb[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6beeab9b33321a5310bd59717c5686e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ce72862fd8e0228ff077d4adc072c0/" rel="bookmark">
			Python电能质量扰动信号分类(四)基于CNN-BiLSTM的一维信号分类模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		往期精彩内容：
引言
1 数据集制作与加载
1.1 导入数据
1.2 制作数据集
2 CNN-BiLSTM分类模型和超参数选取
2.1定义CNN-BiLSTM分类模型
2.2 设置参数，训练模型
3 模型评估
3.1 准确率、精确率、召回率、F1 Score
3.2 十分类混淆矩阵：
代码、数据如下：
往期精彩内容： 电能质量扰动信号数据介绍与分类-Python实现-CSDN博客
Python电能质量扰动信号分类(一)基于LSTM模型的一维信号分类-CSDN博客
Python电能质量扰动信号分类(二)基于CNN模型的一维信号分类-CSDN博客
Python电能质量扰动信号分类(三)基于Transformer的一维信号分类模型-CSDN博客
引言 本文基于Python仿真的电能质量扰动信号，先经过数据预处理进行数据集的制作和加载，然后通过Pytorch实现CNN-BiLSTM模型对扰动信号的分类。
​
Python仿真电能质量扰动信号的详细介绍可以参考下文（文末附10分类数据集）：
电能质量扰动信号数据介绍与分类-Python实现_电磁信号分类python-CSDN博客
部分扰动信号类型波形图如下所示：
​
1 数据集制作与加载 1.1 导入数据 在参考IEEE Std1159-2019电能质量检测标准与相关文献的基础上构建了扰动信号的模型，生成包括正常信号在内的10中单一信号和多种复合扰动信号。参考之前的文章，进行扰动信号10分类的预处理：
第一步，按照公式模型生成单一信号
​
单一扰动信号可视化：
​
第二步，导入十分类数据
import pandas as pd import numpy as np # 样本时长0.2s 样本步长1024 每个信号生成500个样本 噪声0DB window_step = 1024 samples = 500 noise = 0 split_rate = [0.7, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ce72862fd8e0228ff077d4adc072c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d613f4130e24f3bfc9ec8853c2e5ec1a/" rel="bookmark">
			注意：C语言结构体里不能赋初始值！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建结构体只是开辟了一块内存空间，而不赋初始值，赋初始值有的编译器不支持的!
啥时候能赋初始值呢，c++11
可见：C++ 之设置struct 属性的默认值
C++ 11结构体内直接赋初始值
20230816
文章目录 C语言结构体无法赋初始值的解析一、C语言结构体概述二、C语言结构体不能赋初始值的原因三、C语言结构体初始化方法四、总结参考资料 C语言结构体无法赋初始值的解析 在本文中，我们将详细讨论C语言结构体为何无法赋予初始值。这是一个比较基础但又至关重要的话题，因为理解此问题有助于深入理解C语言以及内存管理的工作方式。
一、C语言结构体概述 首先，我们需要理解C语言中的结构体（struct）。结构体是一种可以储存不同类型数据的复合数据类型1。例如：
struct student { char name[50]; int roll; float marks; }; 上面的代码定义了一个名为student的结构体，其中包含了三个不同类型的字段：一个字符数组name，一个整数roll和一个浮点数marks。
二、C语言结构体不能赋初始值的原因 在C语言中，我们不能直接在结构体定义时为其成员变量赋予初始值。以下是一个尝试为结构体成员赋初始值的例子：
struct student { char name[50] = "John"; // 错误！ int roll = 100; // 错误！ float marks = 90.5; // 错误！ }; 这段代码会引发编译错误，原因如下：
内存分配时间：C语言对于全局变量、静态变量和数组（数组长度在编译时已知），以及函数内部的局部变量，内存空间是在编译时分配的（指编译器计算出这些变量在内存中的偏移量，并在生成的可执行文件中保留这些信息），而非运行时。由于结构体可能被多次实例化，所以编译器不允许在定义结构体时为其成员变量赋初值2。
语法限制：C语言的语法规定，在定义数据类型时（包括结构体），只能指定数据类型，不能进行初始化3。
三、C语言结构体初始化方法 尽管不能在定义结构体时为其成员赋初始值，但我们可以在创建结构体变量时进行初始化。例如：
struct student s1 = {"John", 100, 90.5}; 或者，我们也可以在创建结构体变量后，单独为每个成员赋值：
struct student s1; strcpy(s1.name, "John"); s1.roll = 100; s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d613f4130e24f3bfc9ec8853c2e5ec1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c4c75a8ec58af9a1b8cf6bc7d8bd3f/" rel="bookmark">
			docker小白第十一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker小白第十一天 dockerfile分析 Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。即构建新镜像时会用到。
构建三步骤：编写dockerfile文件-docker build命令构建镜像-docker run镜像 运行容器实例。即一层一层的包装形成新镜像。
dockerfile内容基础知识 1:每条保留字（关键字）指令都必须为大写字母且后面要跟随至少一个参数。
2:指令按照从上到下，顺序执行。
3:#表示注释。
4:每条指令都会创建一个新的镜像层并对镜像进行提交。
docker执行dockerfile的大致流程 (1） docker从基础镜像运行一个容器
(2）执行一条指令并对容器作出修改
(3）执行类似docker commit的操作提交一个新的镜像层
(4) docker再基于刚提交的镜像运行一个新容器
(5）在执行一条执行对容器做出修改
(6）执行类似docker commit的操作提交一个新的镜像层
(7) docker再基于刚提交的镜像运行一个新容器
(6）循环通过以上步骤执行dockerfile中的下一条指令直到所有指令都执行完成。
1、Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程。(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;
2、Docker镜像，在用Dockerfile定义一个文件之后，docker buildi时会产生一个Docker镜像，当运行Docker镜像时会真正开始提供服务;
3、Docker容器，容器是直接提供服务的。
dockerfile常用保留字指令 FROM #基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from MAINTAINER # 镜像维护者的姓名和邮箱地址 RUN &lt;命令行指令&gt; # 容器构建时需要运行的命令，命令行指令等于在终端操作的shell指令。在构建镜像docker build时运行 EXPOSE # 当前容器对外暴露出的端口 WORKDIR # 指定在创建容器后，终端默认登陆进容器时的工作目录 USER # 指定该镜像以什么样的用户去执行，如果都不指定，则默认是root ENV # 用来在构建镜像过程中设置环境变量 ADD # 将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包 COPY # 类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置 VOLUME CMD # 指定容器启动后要做的事情。Dockerfile 中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换。在运行容器docker run时运行该命令 ENTRYPOINT # 也是用来指定一个容器启动时要运行的命令 类似于CMD指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序 dockerfile案例实践 自定义一个镜像mycentosjava8。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c4c75a8ec58af9a1b8cf6bc7d8bd3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c879a398f0fb960c49d4665f297dfce8/" rel="bookmark">
			GAMES101：作业3记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 总览使用框架代码说明运行与结果代码实现rasterize_triangle(const Triangle&amp; t)的实现get_projection_matrix()的实现phong_fragment_shader()的实现texture_fragment_shader()的实现bump_fragment_shader()的实现displacement_fragment_shader()的实现尝试其他的obj模型双线性插值 总览 在这次编程任务中，我们会进一步模拟现代图形技术。我们在代码中添加了Object Loader(用于加载三维模型), Vertex Shader 与 Fragment Shader，并且支持了纹理映射。
而在本次实验中，你需要完成的任务是:
修改函数 rasterize_triangle(const Triangle&amp; t) in rasterizer.cpp: 在此处实现与作业 2 类似的插值算法，实现法向量、颜色、纹理颜色的插值。修改函数 get_projection_matrix() in main.cpp: 将你自己在之前的实验中实现的投影矩阵填到此处，此时你可以运行 ./Rasterizer output.png normal来观察法向量实现结果。修改函数 phong_fragment_shader() in main.cpp: 实现 Blinn-Phong 模型计算 Fragment Color.修改函数 texture_fragment_shader() in main.cpp: 在实现 Blinn-Phong的基础上，将纹理颜色视为公式中的 kd，实现 TextureShading Fragment Shader.修改函数 bump_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的基础上，仔细阅读该函数中的注释，实现 Bump mapping.修改函数 displacement_fragment_shader() in main.cpp: 在实现 Bump mapping 的基础上，实现 displacement mapping
这将会生成命名为 Rasterizer 的可执行文件。使用该可执行文件时，你传入的第二个参数将会是生成的图片文件名，而第三个参数可以是如下内容： 使用 texture: 使用代码中的 texture shader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c879a398f0fb960c49d4665f297dfce8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9741ca4d68d82d417407e987ab99a17a/" rel="bookmark">
			Hi5 2.0 虚拟手与追踪器（Tracker）的位置修正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 使用环境与工具：Unity 2022.3.4fc1，steam VR(2.7.3)，steamvrSDK（1.14.15），HTC vive pro专业版，Hi5 2.0数据手套
首先按照Hi5 2.0的使用说明（可参考：HI5 2.0 交互 SDK 用户手册—— HTC Vive 系列），进行了环境配置。并搭建了一个简单的示例场景（白色cube位于空间原点（0,0,0））。
现将TableScence_Vive场景的Hi5_Thread_MonoBehaviour、[CmaeraRig]_Hi5、HI5 Menu复制粘贴到示例场景中，并把[CmaeraRig]_Hi5移动到Plane处（偏离原点）。
然后运行发现，虚拟手一直在原点处的活动范围，并与手部Tracker相对位置出现偏差。
问题解决 1.搜索到脚本HI5_InertiaInstance.cs，编辑器打开。
2.添加superObject变量：
public GameObject superObject; 3.找到ApplyHandMotion_Pose方法，在HandBones[m_INDEX_Hand].position = position;上方添加如下代码：
if (superObject != null) { position += superObject.transform.position; } 4.保存代码，回到Unity，找到两个手部模型（Hi5_Left_Hand、Hi5_Right_Hand），将其HI5_InertiaInstance.cs脚本的 Super Object变量选择为[CameraRig]_Hi52。
5.重新运行，即可。 备注：
问题：手指传感器连接不上
需要将手指传感器与接收器的频段调为一致（不同颜色代表不同频段）。建议均调为蓝色频段。
参考链接 / 特别感谢：
Unity学习 HTC Vive &amp; Hi5 2.0_noitom inertia-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452f7e3c634f3964927147ba04fee5a7/" rel="bookmark">
			李沐机器学习系列3---深度学习计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 层和块 1.1 定义块 用class表示层，并只需要实现构造函数和前向传播函数
class MLP(nn.Module): # 用模型参数声明层。这里，我们声明两个全连接的层 def __init__(self): # 调用MLP的父类Module的构造函数来执行必要的初始化。 # 这样，在类实例化时也可以指定其他函数参数，例如模型参数params（稍后将介绍） super().__init__() self.hidden = nn.Linear(20, 256) # 隐藏层 self.out = nn.Linear(256, 10) # 输出层 # 定义模型的前向传播，即如何根据输入X返回所需的模型输出 def forward(self, X): # 注意，这里我们使用ReLU的函数版本，其在nn.functional模块中定义。 return self.out(F.relu(self.hidden(X))) 1.2 顺序块 class MySequential(nn.Module): def __init__(self, *args): super().__init__() for idx, module in enumerate(args): # 这里，module是Module子类的一个实例。我们把它保存在'Module'类的成员 # 变量_modules中。_module的类型是OrderedDict self._modules[str(idx)] = module def forward(self, X): # OrderedDict保证了按照成员添加的顺序遍历它们 for block in self._modules.values(): X = block(X) return X 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452f7e3c634f3964927147ba04fee5a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162a7b92352be611b5c10788a5cd3c06/" rel="bookmark">
			大模型实战营第二期——1. 书生·浦语大模型全链路开源开放体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 实战营介绍2. 书生·浦语大模型介绍2.1 数据2.2 预训练2.3 微调2.4 评测2.5 部署2.6 智能体(应用) 1. 实战营介绍 github链接：https://github.com/internLM/tutorialInternLM：https://github.com/InternLM书生浦语官网：https://intern-ai.org.cn/home 2. 书生·浦语大模型介绍 视频链接：B站-书生·浦语大模型全链路开源体系 数据：汇聚 5400+ 数据集，涵盖多种模态与任务，更多数据集预训练：并行训练，极致优化，速度达到 3600 tokens/sec/gpu微调：全面的微调能力，支持SFT，RLHF和通用工具调用部署：全链路部署，性能领先，每秒生成 2000+ tokens评测：全方位评测，性能可复现，50 套评测集，30 万道题目 2.1 数据 OpenDataLab的知乎文章：多模态语料库 “书生·万卷” 1.0 详细解读 | 附下载地址
也是来自论文的
https://opendatalab.com/home
2.2 预训练 预训练与微调使用教程
2.3 微调 SFT(ScalableFine-Tuning) 是一种用于自然语言处理的技术,它通过对预训练的语言模型进行微调,使其适应特定任务
https://github.com/InternLM/xtuner
预训练与微调使用教程
2.4 评测 https://crfm.stanford.edu/helm/lite/latest/#/leaderboardhttps://github.com/stanford-crfm/helmhttps://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboardhttps://llm-leaderboard.streamlit.app/https://github.com/terryyz/llm-benchmark https://opencompass.org.cn/
2.5 部署 https://github.com/InternLM/lmdeploy
2.6 智能体(应用) https://github.com/InternLM/lagent
https://github.com/InternLM/agentlego
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af665524ef9f6b7acb7051a08d895b5/" rel="bookmark">
			单片机相关知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在STM32上运行FreeRTOS，十分简练的小文章FreeRTOS（STM32CubeMX）_cubemx freertos-CSDN博客
STM32CubeMX转Keil
使用STM32CubeMX生成Keil工程并完成流水灯-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a8c1d8d79a684902ead81c755fe915c/" rel="bookmark">
			外包干了5个月，技术退步明显.......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说一下自己的情况，大专生，18年通过校招进入武汉某软件公司，干了接近4年的功能测试，今年年初，感觉自己不能够在这样下去了，长时间呆在一个舒适的环境会让一个人堕落!
而我已经在一个企业干了四年的功能测试，已经让我变得不思进取，谈了2年的女朋友也因为我的心态和工资和我分手了。
于是，我决定要改变现状，冲击下大厂。
刚开始准备时，自己都蒙了，四年的功能测试让我的技术没有一丝的进步，提升的只有我的年龄…
没办法，我找到了我在腾讯的老哥，作为他的小老表，在他了解了我的情况后(几乎就是软件测试基础开始)，直接甩给我一个网盘，说到：“去吧，这里有你需要的所有东西，不要来找我了，我都嫌丢人!”。
盘里头是一整套软件测试面试必备文档PDF，看完之后直接给我老哥给跪了…这下面试稳了。
内容涵盖：包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等… 质量非常高，需要的可自行领取！！
全网首发-涵盖16个技术栈 第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础 软件测试的步骤是什么?
如何录制测试脚本?
应该考虑进行如何测试的测试方法
怎样估计测试工作量?
测试设计的问题
当测试过程发生错误时，有哪几种解决办法?
测试执行的问题
测试评估的目标
如何提高测试?
C/S模式的优点和缺点
B/S模式的优点和缺点
…
Linux grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a8c1d8d79a684902ead81c755fe915c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c498eed906a9d5a6235296b5a5e206f3/" rel="bookmark">
			Vue 中的 ref 与 reactive：让你的应用更具响应性（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤍 前端开发工程师（主业）、技术博主（副业）、已过CET6
🍨 阿珊和她的猫_CSDN个人主页
🕠 牛客高级专题作者、在牛客打造高质量专栏《前端面试必备》
🍚 蓝桥云课签约作者、已在蓝桥云课上架的前后端实战课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 六、最佳实践和常见陷阱分享一些使用 ref 和 reactive 的最佳实践讨论一些常见的陷阱和错误，并提供解决方法 七、总结总结 ref 和 reactive 的重要概念和用法强调它们在 Vue 应用中的重要性 六、最佳实践和常见陷阱 分享一些使用 ref 和 reactive 的最佳实践 以下是一些使用 ref 和 reactive 的最佳实践：
使用 reactive 处理复杂的数据结构：当处理复杂的数据结构（如对象、数组）时，使用 reactive 可以确保数据的变更能够被响应式系统检测到，并自动触发组件的更新。
使用计算属性优化性能：对于需要根据响应式数据进行计算的场景，可以使用计算属性（Computed Properties）。计算属性只会在其依赖的响应式数据发生变化时重新计算，避免了不必要的计算。
避免在模板中直接修改响应式数据：尽量避免在模板中直接修改响应式数据，因为这可能导致意外的副作用和不可预测的行为。如果需要修改响应式数据，可以使用 Vue.set 或 reactive 的 update 方法。
使用 ref 引用特定的 DOM 元素：当需要直接操作 DOM 元素时，可以使用 ref 来引用特定的元素。通过 ref，你可以在组件的方法中访问和操作该元素。
合理使用生命周期钩子：根据具体需求，在适当的生命周期钩子（如 created、mounted、updated 等）中进行数据的初始化、获取或更新操作。
避免过度使用 reactive：虽然使用 reactive 可以创建响应式数据，但也要避免过度使用。只对需要响应式的数据使用 reactive，对于一些静态数据或不需要实时更新的数据，可以直接使用普通的对象或数组。
命名规范：给 ref 和 reactive 创建的变量命名时，遵循良好的命名规范，使其具有清晰的可读性和可维护性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c498eed906a9d5a6235296b5a5e206f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ee9e7aea89398f2680d5616225c3ff/" rel="bookmark">
			李沐机器学习系列1--- 线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Introduction 1.1 线性回归函数 典型的线性回归函数
f ( x ) = w ⃗ ⋅ x ⃗ f(x)=\vec{w} \cdot \vec{x} f(x)=w ⋅x 现实生活中，简单的线性回归问题很少，这里有一个简单的线性回归问题。房子的价格和房子的面积以及房子的年龄假设成线性关系。
p r i c e = w a r e a ∗ a r e a + w a g e + b price = w_{area}*area + w_{age}+b price=warea​∗area+wage​+b
1.2 损失函数 确定了变量和结果之间的大致关系以后，我们需要通过优化的方法进行迭代优化求解。
让我们从优化的角度来看这个问题。
c o s t = 0.5 ∑ i n ( w ⃗ ∗ x − y i ) T Q ( w ⃗ ∗ x − y i ) cost = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ee9e7aea89398f2680d5616225c3ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0922b932941f3bc1160a44d51fb515/" rel="bookmark">
			[Android]RadioButton控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RadioButton控件
RadioButton控件是单选按钮控件，它继承自Button控件，可以直接使用Button控件支持的各种属性和方法。
与普通按钮不同的是，RadioButton控件多了一个可以选中的功能，能额外指定一个android：checked属性，该属性可以指定初始状态是否被选中。其实也可以不用指定，默认初始状态都不被选中。
RadioButton控件必须和单选框RedioGroup控件一起使用。
RadioButton控件的使用
&lt;RadioGroup android:id="@+id/radiogroup" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;RadioButton android:id="@+id/one" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="一年级" android:checked="true" /&gt; &lt;RadioButton android:id="@+id/two" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="二年级" /&gt; &lt;RadioButton android:id="@+id/three" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="三年级" /&gt; &lt;/RadioGroup&gt; RadioButton控件的选中监听器
//为RadioGroup设置一个事件监听器 val radioGroup:RadioGroup=findViewById(R.id.radiogroup) radioGroup.setOnCheckedChangeListener { group, checkedId -&gt; val check:RadioButton=findViewById(checkedId) Toast.makeText(this,"${check.text}",Toast.LENGTH_SHORT).show() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b473e5c6ee14ac46322bed9f7b498cc/" rel="bookmark">
			Vue 中的 ref 与 reactive：让你的应用更具响应性（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤍 前端开发工程师（主业）、技术博主（副业）、已过CET6
🍨 阿珊和她的猫_CSDN个人主页
🕠 牛客高级专题作者、在牛客打造高质量专栏《前端面试必备》
🍚 蓝桥云课签约作者、已在蓝桥云课上架的前后端实战课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 四、 ref 与 reactive 的比较比较 ref 和 reactive 的相似之处和不同之处分析在不同场景下使用 ref 或 reactive 的优势 五、结合使用 ref 与 reactive介绍如何将 ref 和 reactive 结合使用展示一些常见的结合使用场景 四、 ref 与 reactive 的比较 比较 ref 和 reactive 的相似之处和不同之处 下面是对 ref 和 reactive 的相似之处和不同之处的详细比较：
refreactive用法创建单一响应式数据创建复杂的响应式对象响应式绑定值通过 value 属性访问直接访问和修改对象的属性自动解包不会自动解包会自动解包，可以直接访问和修改内部的属性更新触发使用 .value 属性赋值直接修改对象的属性来触发更新嵌套响应式对象需要手动创建嵌套的响应式对象可以自动追踪和处理嵌套的响应式对象监听器需要通过监听 .value 属性变化可以通过 watch API 或 effect 进行监听和响应变化组件中的使用可作为单个值响应式数据使用通常用于创建组件的响应式数据和响应式副作用 需要注意的是，ref 和 reactive 都是用于创建响应式数据的 API，在不同的应用场景下使用。ref 适用于单个响应式值的简单情况，而 reactive 则更适合处理复杂的响应式对象和嵌套数据结构。根据具体的需求和场景，选择合适的 API 进行使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b473e5c6ee14ac46322bed9f7b498cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e059fda1dd335e7c64a4293527119b/" rel="bookmark">
			床垫选得好孩子睡得香！康姿百德学生床垫让孩子拥有甜美梦乡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		睡眠与健康密切相关,而床垫的选购则直接关系到人们睡眠质量的好坏。而孩子的床垫选择更是重中之重,青少年儿童正处于生长发育的重要时期,床垫选不好很容易导致孩子睡眠不足,影响孩子的学习,甚至会影响孩子的脊椎发育。所以,给孩子挑张好用又合适的床垫十分重要,现在让我们来看看怎么挑选孩子床垫吧!
青少年的骨骼生长发育还未完全定型,需要床垫提供更加有力的支撑,并具备一定的硬度,才能保证孩子在睡觉时睡姿端正,防止脊椎弯曲等。康姿百德学生床垫由柔软的上下层,结实牢固、富有弹性的中间层组成,既可以为身体提供恰到好处的支撑,又可以紧密贴合身体曲线,能够根据人的身体曲线产生不同的支撑力度,避免身体的某一部位受到过于多的压力影响,使身体能够充分受力达到适宜的支撑度,让我们的身体的各个部位得到良好的休息状态。
包裹性是最影响睡感的特征。包裹性好的床垫,能让你有安全感,能让你更快入睡。儿童不仅身体较弱,其实心灵也较脆弱。我们都知道,小时候被父母关爱而长大的孩子,长大了就更自信,也更能承受挫折。而一张包裹性好的床垫,就是代替父母在夜间关爱孩子。康姿百德学生床垫能顺应孩子生理曲线,腰部得到承托,臀部适度下陷,脊椎保持正常的生理弯曲,使身体各部位处于放松状态,获得健康舒适的睡眠体验。
孩子夜间睡眠普遍体温较高容易出汗,透气也是床垫不可或缺的要素。青春期孩子们最烦恼的就是青春痘,其实螨虫也是痘痘的一大成因,如果床垫透气性不好,身体散发的湿气床垫不能及时排出,湿润的环境很容易滋生螨虫和细菌,影响孩子的睡眠,甚至会引发过敏等疾病。康姿百德学生床垫内部设有大量蜂窝状通风透气孔道,全方位循环透气,吸湿排热由表及里,一步解决睡眠时散发的湿热气,破坏细菌螨虫的生存环境。能够给孩子营造一个干爽舒适的睡眠环境,可以更好守护孩子们的睡眠。
众所周知睡眠十分重要,对孩子来说更是如此。康姿百德学生床垫是专为青少年打造的床垫,父母们可以放心购买。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8a8ab0dc47ce83c9b3f420ec57c45a/" rel="bookmark">
			利用腐蚀去除图像噪声、利用膨胀填充两个字符中的空隙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用腐蚀去除图像噪声 import cv2 """ 1. 利用腐蚀去除图片中原始的噪声 注意不同的图片kernel和iteration均有不同，建议尝试多个图片 """ img = cv2.imread("js.png") # 腐蚀 img2 = cv2.erode(img, kernel=(3, 3), iterations=30) cv2.imshow("result", img2) cv2.waitKey(0) 利用膨胀填充两个字符中的空隙 import cv2 """ 1. 利用膨胀填充js两个字符中的空隙 注意不同的图片kernel和iteration均有不同，建议尝试多个图片 """ img = cv2.imread("js.png") # 膨胀 img2 = cv2.dilate(img, kernel=(10, 10), iterations=100) cv2.imshow("result", img2) cv2.waitKey(0) 去除图片中的噪点，同时填充两个字符的空隙 import cv2 """ 去除图片中的噪点，同时填充js两个字符的空隙 1. 利用腐蚀去除图片中原始的噪声 2. 利用膨胀填充js两个字符中的空隙 注意不同的图片kernel和iteration均有不同，建议尝试多个图片 """ img = cv2.imread("js.png") # 先腐蚀，去除噪点 img2 = cv2.erode(img, kernel=(3, 3), iterations=30) # 后膨胀，填充空隙 img2 = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8a8ab0dc47ce83c9b3f420ec57c45a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90f7b978768e96189dc466cda7d2980/" rel="bookmark">
			Pandas教程（五）—— 数据重塑透视及批量处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据重塑 重塑数据主要有两种方式，分别是 stack（堆叠）和 unstack（拆堆），他们两个是互逆的操作
函数作用 data.stack（ ）
堆叠
会“旋转”或将列中的数据透视到行
列 一一&gt; 行
data.unstack（ ）
拆堆
将行中的数据透视到列 行 一一&gt; 列
参数说明：
level：要堆叠的列 / 行的层级，默认为-1（最内层）
dropna：是否排除缺失的组合。默认为 True
import pandas as pd import numpy as np data = pd.DataFrame(np.arange(12).reshape(6,2), index = pd.MultiIndex.from_product([["Ohio","Colorado"],["one","two","three"]],names = ["state","number"]), columns = pd.Index(["left","right"],name = "side")) print(data) print("-"*35) # 拆堆 行透视为列 chai = data.unstack("state") # 传入要拆分的层级 print(chai) print("-"*35) # 堆叠 列透视为行 dui = chai.stack("side") print(dui) 上述代码示意图 2.数据透视表 透视表是一种可以对数据动态排布并且分类汇总的表格格式
可以让我们从不同的角度去分析一个大数据库，有点类似于分类筛选的高阶版操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c90f7b978768e96189dc466cda7d2980/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d044bd3b6d222cb3e1b4f32c79dde6/" rel="bookmark">
			使用C#发送邮箱验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用C#发送邮箱验证码 在很多应用程序中，我们需要使用邮箱来进行用户身份验证。其中一种常见的方式是通过发送验证码到用户的邮箱，然后要求用户输入该验证码进行验证。本文将介绍如何使用 C# 发送邮箱验证码。
声明 验证码登录没有用任何的工具（redis等）
步骤一：获取QQ或者网易邮箱的授权码 可以看本人上一篇获取QQ邮箱的授权码（可代发邮件验证码）的获取QQ的授权码。
public string EmailSend(string email) { try { // 模拟随机验证码 生成随机六位数 Random random = new Random(); int randomNum = random.Next(100000, 999999); string randomNumber = randomNum.ToString(); // 邮件发送设置 using (var mailMessage = new MailMessage()) { mailMessage.From = new MailAddress("用于发送验证码的邮箱"); //接受验证码的邮箱 一般是登录时用户登录的邮箱 mailMessage.To.Add(new MailAddress(email)); mailMessage.Subject = "用户的验证码"; mailMessage.IsBodyHtml = true; // 使用内联 CSS 样式 mailMessage.Body = @"&lt;html&gt; &lt;head&gt; &lt;style&gt; h1 { color: #333; font-family: Arial, sans-serif; } p { color: #555; font-family: Arial, sans-serif; } strong { color: #f00; font-weight: bold; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;验证码&lt;/h1&gt; &lt;p&gt;您的验证码为：&lt;strong&gt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44d044bd3b6d222cb3e1b4f32c79dde6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eae2365b4e0fc44227b67631835e4a3/" rel="bookmark">
			cnPuTTY 0.80.0.1—PuTTY Release 0.80中文版本简单说明~~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023-12-18 官方发布了PuTTY 0.80
本次发布主要是针对Terrapin攻击(CVE-2023-48795)的修改发布。
更多详细的内容请查看PuTTY Change Log。
有关Terrapin攻击可用简单参考：警告！！！Terrapin攻击(CVE-2023-48795)~~~
为了缓解此漏洞，需要启用OpenSSH项目定义的名为'strict KEX'的SSH扩展，PuTTY 0.80中已有实现。并且这个漏洞是双向的，所以需要服务器与客户端同时实现这个扩展。已经实现这一扩展的相关应用可以简单参考：list of SSH implementations。在没有缓解措施的情况下，该漏洞也只能是在使用某些加密算法时被利用。在PuTTY支持的算法中受影响的包括：ChaCha20-Poly1305(PuTTY中的名称为ChaCha20)以及AES-CBC(AES系列中的一种模式)。可以通过设置避免使用ChaCha20，AES-CBC更多的依赖服务器的设置选择，PuTTY不能完全主导。
其它关于Terrapin攻击的更多信息请自行查找了解，强烈建议更新相关软件到最新版本以避免这个问题。PuTTY 0.79 及其之前的版本都会受到它的影响，如果可能的话强烈建议使用PuTTY 0.80或者之后的版本，当然这由你自己决定。
基于上述原因，此次同步更新cnPuTTY 0.80.0.1发布。其中包含对cnPuTTY本身问题的简单修正。详细的内容如下：
1.Windows系统下的相关说明 在连接中没有实现'strict KEX'扩展并且使用了易受攻击的算法时，PuTTY将弹出Terrapin攻击风险的报警信息如下：
如果继续进行连接，连接建立后的事件日志如下：
存在Terrapin攻击隐患的日志输出 2023-12-25 23:45:30	查找主机 "192.168.44.137" 来自 SSH连接 2023-12-25 23:45:30	连接到 192.168.44.137 端口 22 2023-12-25 23:45:30	我们声明的版本：SSH-2.0-PuTTY_Release_0.80 2023-12-25 23:45:30	连接到 192.168.44.137 2023-12-25 23:45:30	远程版本：SSH-2.0-OpenSSH_9.2p1 Debian-2 2023-12-25 23:45:30	使用SSH协议版本 2 2023-12-25 23:45:30	没有GSSAPI安全可用的使用条件 2023-12-25 23:45:30	当前SSH连接容易受到'Terrapin'攻击(别名CVE-2023-48795) 2023-12-25 23:46:43	尽管存在'Terrapin'漏洞，但用户仍旧要求继续进行连接 2023-12-25 23:46:43	执行 NTRU Prime / Curve25519 hybrid key exchange,使用哈希 SHA-512 (unaccelerated) 2023-12-25 23:46:43	服务器也有ecdsa-sha2-nistp256/rsa-sha2-512/rsa-sha2-256主机密钥,但我们未存储它们 2023-12-25 23:46:43	主机密钥指纹是： 2023-12-25 23:46:43	ssh-ed25519 255 SHA256:yAU3FBTxrgwp4RtC/IyqtoKx9jXYOPPa8zMKDIa6Q00 2023-12-25 23:46:43	已初始化 ChaCha20 出站加密 2023-12-25 23:46:43	已初始化 Poly1305 出站MAC算法(在ETM模式)(加密要求) 2023-12-25 23:46:43	已初始化 ChaCha20 入站加密 2023-12-25 23:46:43	已初始化 Poly1305 入站MAC算法(在ETM模式)(加密要求) 2023-12-25 23:47:22	发送密码 2023-12-25 23:47:22	授予访问权限 2023-12-25 23:47:22	打开主会话通道 2023-12-25 23:47:22	已开通主通道 2023-12-25 23:47:22	已分配 pty 2023-12-25 23:47:22	已启动 shell/command 在连接中实现'strict KEX'扩展时，无论算法如何，都能避免漏洞的使用。这需要服务器与客户端共同支持。建立连接后，事件日志中会提示“启用严格的密钥交换规则”，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eae2365b4e0fc44227b67631835e4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489f0fb28d5b1fd1e343df86c072dbf8/" rel="bookmark">
			C&#43;&#43; string用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::string 是 C++ 标准库提供的字符串类，提供了一系列方法用于处理字符串。以下是一些 std::string 的基本用法总结：
包含头文件 #include &lt;string&gt; 声明和初始化 std::string str; // 创建一个空字符串 std::string str1 = "Hello, "; // 使用字符串字面值初始化 std::string str2("world!"); // 使用构造函数初始化 std::string str3 = str1 + str2; // 字符串拼接 获取字符串长度 str.length(); // 获取字符串长度 str.size(); // 获取字符串长度 访问字符串中的字符 char ch = str[0]; // 获取字符串中的第一个字符 字符串的迭代器遍历 for (auto it = str.begin(); it != str.end(); ++it) { // 使用迭代器访问字符 } 字符串连接和拼接 str.append(" Additional Text"); // 在字符串末尾追加文本 str += "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489f0fb28d5b1fd1e343df86c072dbf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862ff9e676f579570da7fae150cbd91b/" rel="bookmark">
			03 decision tree（决策树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、decision tree（决策树） 1. classification problems（纯度） i . entropy （熵） ​ 作用：衡量一组数据的纯度是否很纯 ，当五五开时他的熵都是最高的，当全是或者都不是时熵为 0
i i . information gain （信息增益） ​ 父节点到子节点的熵的减少称为信息增益，处理分支熵的时候，选择使用熵的加权平均值来衡量熵值的高低，计算信息增益是为了看两阶之间如果增益太小的话则不需要分了
i i i . 多个&amp;连续特征 a)one hot coding(独热编码) ​ **使用：**如果一个特征有多个可能取值，我们可以将多个取值都变为一种特征，然后取值变为0，1是否
b) 连续特征 ​ **解决：**如果一个特征有连续的取值，类似体重，可以按照信息熵来划分一个界限
2、regression tree（回归树） i. how to choosing a spilt a). 根据方差选择回归树 ​ 先计算出根节点的方差，然后计算不同特征分类以后的方差，选择方差差值较大的一个作为划分条件
i i. weaknesses of desicion tree ​ 改变数据集中的一个数据就会对最后的树造成很大的影响，形成一个根据不同条件划分的树
​ 解决：多构建几个树，使用树的合集来共同决策最后的结果，来投票最后的结果
二、决策森林 i. Sampling with replacement（有放回抽样） ​ **作用：**通过有放回的多次抽样，得到多个和原始训练集大小一样的训练集，与原始的相似但不同的新训练集
i i . Random forest algorithm a) 袋装决策树 ​ 使用 : 使用放回抽样来生成新的dataset，用生成的新的dataset来训练模型，得到新的decision tree，一共重复m次，m 的取值一般为64-228，一般是100往后可能会收益递减。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/862ff9e676f579570da7fae150cbd91b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8565deb64b97a7485b0ffd36c6abe3/" rel="bookmark">
			SpringMVC-域对象共享数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、request域对象共享数据 1.1 通过ServletAPI共享数据 @RequestMapping("/servletAPI") public String servletAPI(HttpServletRequest request){ request.setAttribute("requestAttribute","helloworld"); return "servletAPI"; } &lt;!--通过thymeleaf语法来获取request域对象中的数据，获取request属性时，不需要使用request. 直接通过属性名获得数据即可--&gt; &lt;p th:text="${requestAttribute}"&gt;&lt;/p&gt; 1.2 通过ModelAndView共享数据 /** * ModelAndView有model和view的功能 * @return 返回值为ModelAndView对象，交给前端处理器处理 */ @RequestMapping("/testModelAndView") public ModelAndView testModelAndView(){ //new一个ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); //向请求域中共享数据 modelAndView.addObject("requestAttribute","helloworld,modelandview"); //设置视图名称，由thymeleaf解析 modelAndView.setViewName("testModelAndView"); return modelAndView; } 1.3 通过Model共享数据 /** * * @param model 传入Model对象，以便向request中共享数据 * @return 返回视图名称 */ @RequestMapping("/testModel") public String testModel(Model model){ //向request中共享数据 model.addAttribute("requestAttribute","helloworld,Model"); return "testModel"; } 1.4 通过map共享数据 @RequestMapping("/testMap") public String testMap(Map&lt;String,Object&gt; map){ map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b8565deb64b97a7485b0ffd36c6abe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f6055b508bd24079b51dd96c50d3927/" rel="bookmark">
			小白也能看得懂的Jmeter性能测试中服务端资源监控技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作步骤：
1、安装插件管理器 插件管理器的作用：可以提供扩展插件的在线安装升级和卸载。因为我们需要在线安装监控插件，首先我们就要先安装插件管理器。
插件管理器的下载地址：https://jmeter-plugins.org/install/Install/
如下图所示下载“ plugins-manager.jar ”，下载后放到“jmeter\lib\ext”目录下，重启jmeter。
2、安装资源监控扩展插件 点击“选项”\“Plugins Manager”，打开插件管理器对话框；
切换到“Available Plugins Upgrades”标签页，选择“PerMon(Servers Performance Monitoring)”，点击“Apply Changes and Restart JMeter”；
观察下载安装进度，安装完成后，自动重启JMeter。
注：也可以将下载的jar包直接放到“jmeter\lib\ext”目录下，重启jmeter。
3、安装服务端监控代理 下载“ServerAgent-2.2.3”，解压到复制到要监控的服务器上，windows和linux通用，使用这个代理服务之前要JDK已经安装配置成功。我这边以centos为例。图片
4、启动监控代理 切换到“ServerAgent-2.2.3”，输入./startAgent.sh；
[root@localhost ServerAgent-2.2.3]# ./startAgent.sh
bash: ./startAgent.sh: Permission denied
如果报权限不够，通过chmod增加权限；
[root@localhost ServerAgent-2.2.3]# chmod 775 startAgent.sh
然后再次启动代理服务，出现如下提示证明成功了，默认端口4444。
[root@localhost ServerAgent-2.2.3]# ./startAgent.sh
Java HotSpot™ Client VM warning: You have loaded library /usr/local/ServerAgent-2.2.3/ServerAgent-2.2.3/lib/libsigar-x86-linux.so which might have disabled stack guard. The VM will try to fix the stack guard now.
It’s highly recommended that you fix the library with ‘execstack -c ’, or link it with ‘-z noexecstack’.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f6055b508bd24079b51dd96c50d3927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb91e1e87f8555c936ea28bcdd559d1/" rel="bookmark">
			深入了解SoapUI - 从入门到精通的指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SoapUI
是一个免费的开源测试工具，它能够通过 soap/http 协议来检查、调用和实现 Web Service 的功能、负载和符合性测试。
除了能够独立地使用作为一个测试软件外，SoapUI 还可以通过插件集成到 Eclipse、maven2.X、Netbeans 和 intellij 等开发环境中。这让开发人员在开发过程中更方便地进行 Web Service 的测试。
SoapUI 提供了 TestSuite（测试套件）和 TestCase（测试用例）两个概念。 TestSuite 可以用来组织一个或多个 TestCase，并且可以在一起成为一个项目。 TestCase 包含一个或多个测试步骤，包括发送请求、接收响应、分析结果以及改变测试执行流程等。
SoapUI 的特点 支持 soap /http 协议，能够执行基于 SOAP 和 REST 的 Web Service 测试；提供了丰富的测试步骤，包括 groovy 脚本、数据库测试、HTTP 身份验证、加密、解密、压缩等；内置了 MockService，方便在开发阶段进行服务模拟；支持测试结果的导出和分析，例如通过 JUnit 和 HTML 报告等。 SoapUI 的使用 下载和安装 SoapUI 是一款跨平台的软件，可以在 Windows、macOS 和 Linux 上使用。需要到官网下载对应的版本，并安装到本地环境中。
详细下载地址 ：SoapUI下载指南：获取最新版本的方法
创建 TestCase 在 SoapUI 中创建 TestCase 非常简单，只需要在项目中选择“新建”-&gt;“TestCase”，然后按着提示进行创建即可。
添加测试步骤 在 TestCase 中，从左侧工具栏中点击“添加步骤”，然后选择“测试步骤”即可添加一个新的测试步骤。根据实际需求，可以选择 HTTP 请求、groovy 脚本、数据库测试等不同类型的测试步骤。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb91e1e87f8555c936ea28bcdd559d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06719259bcec073dd4c20565a403f492/" rel="bookmark">
			轻松上手：Postman Interceptor 插件使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Postman？ Postman 是一种用于测试和开发 API 的工具，让开发者可以轻松地构建、发送、调试 HTTP 请求，并检查响应结果。通过Postman，开发者可以在不编写代码的情况下快速测试 API 的正确性和可靠性。Postman 还支持协作和自动化测试，可以通过脚本来执行测试用例并生成测试报告，帮助开发者创建和维护 API 文档，包括生成 API 参考文档、示例代码等。使开发者更加高效地工作，并减少 API 开发周期。
下载 Postman Postman 是一款常用的 API 测试工具，它可以让开发者更加方便地测试和调试 API，可以通过以下步骤下载 Postman：
打开浏览器，进入 Postman官网。选择适合自己操作系统的版本，比如 Windows、Mac 或 Linux 系统。点击“Download”按钮进行下载，下载完成后进行安装。 安装 Postman 安装 Postman 也很简单，只需按照以下步骤进行操作：
双击下载好的安装文件，打开安装程序。选择语言、路径等相关选项。点击“安装”按钮，等待安装程序自动安装完成即可。 详细教程：Postman 下载及安装教程
什么是 Postman Interceptor？ 为了进一步增强 Postman 工具的功能，Postman 公司推出了一个浏览器插件 —— Postman Interceptor，它可以拦截客户端和服务器之间的 HTTP/HTTPS 请求，并将其发送到 Postman 工具进行进一步处理和调试；能直接使用 Chrome 浏览器的 cookie 等信息。它是一个浏览器扩展程序，需要安装才能使用。该扩展程序与 Chrome 和 Firefox 浏览器兼容。安装后，它与 Postman 应用程序一起工作，捕获网络流量。
下载 Postman Interceptor Postman Interceptor 是 Postman的一个插件，可以帮助用户在Postman中拦截和修改浏览器的请求，用户可以通过以下步骤下载Postman Interceptor：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06719259bcec073dd4c20565a403f492/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/9/">«</a>
	<span class="pagination__item pagination__item--current">10/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/11/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>