<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6973741874a731a96f763f36eee96f/" rel="bookmark">
			BUUCTF——Web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、[极客大挑战 2019]EasySQL 启动靶机，出现这个用户登录页面
随便输入一个用户名和密码，通过网址可以判断出该请求方式
使用万能密码测试是否存在SQL注入漏洞
username=admin'or'1=1&amp;password=admin'or'1=1
登录后便可查看到flag
flag为：
flag{5d3cac62-7357-493e-bc2a-6d9030c2a22b}
二、 [极客大挑战 2019]Havefun 启动靶机，出现以下页面 查看源代码
尝试在网址后面加上?cat=dog
http://2414a278-f293-41f0-9adc-2490774e8790.node4.buuoj.cn:81/?cat=dog
出现以下存在flag的页面
flag为：
flag{4de413d7-e7df-4ef8-a068-d384f81ae6b4}
三、[HCTF 2018]WarmUp 启动靶机，出现以下页面
查看源代码
source.php 应该是后端的源码，这题代码审计了
源码中 给出了 两个文件，还有一个 hint.php，这里给出了flag的位置
# ! empty($_REQUEST['file']) 第一次判断，file参数是不是空的，非空为True
# is_string($_REQUEST['file']) 第二次判断，file参数是不是字符串，是字符串True
# emmm::checkFile($_REQUEST['file']) ) 第三次，检查 file 的值(file中包含 $whilelist 存在的值)
# 由于 不知道 ffffllllaaaagggg 的位置，所以可以用 ../../../../../../ 目录穿越的方式进行访问（目录穿越建议6-10个../）
# payload
file=source.php?../../../../../ffffllllaaaagggg
file=hint.php?../../../../../ffffllllaaaagggg
得到flag
flag为：
flag{639456e1-1aef-4df2-b922-879cce4c3ec0} 四、[ACTF2020 新生赛]Include 启动靶机，出现以下界面
点击tips跳转到flag.php，flag应该就在这个php文件中
文件名为flag.php，那么flag应该就存在于此文件中，但是我们f12并没有查看到flag
猜测flag应该是在flag.php的源代码当中，我们可以利用php://filter伪协议来查看flag.php的源代码，构造payload：
?file=php://filter/convert.base64-encode/resource=flag.php
成功获取到flag.php加密后到源代码内容：
PD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7ZmQyZTRjYWItZTRiZi00ZDM4LTk1YjAtZTNkMTk0Y2NmMjMxfQo=
解密后得到 &lt;?php
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6973741874a731a96f763f36eee96f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5583735aa5597916b22f3385cdc73057/" rel="bookmark">
			BUUCTF——Web1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、[极客大挑战 2019]Http 打开靶机，出现以下页面
查看源代码
发现Secret.php，访问后出现以下页面
接着我们使用bp进行抓包
在请求头中添加
Referer:https://Sycsecret.buuoj.cn
字段发送请求，出现以下页面 根据提示更改User-Agent为
User-Agent: Syclover
发送请求，出现以下页面 提示要是来自本地的访问请求，联想到127.0.0.1，需要
X-Forwarded-For: 127.0.0.1 X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。
出现flag
flag为
flag{8121414c-8ed4-490e-9d34-351f08b4504b}
二、[极客大挑战 2019]Knife 打开靶机，出现以下页面
使用菜刀进行连接
连接成功后，在/flag目录下获得flag
flag为
flag{b8b99cdb-fdac-4ce1-bec1-d647e1ee47bb}
同理可得，也可用蚁剑进行此操作 三、[极客大挑战 2019]Upload 打开靶机，出现以下页面
首先我们尝试上传木马文件
&lt;?php @eval($_POST['yy']); ?&gt; 我们先将一句话木马写在记事本后，将后缀名改为.jpg 提交后出现以下页面，不能含有&lt;?，看来是被过滤了
我们尝试换个一句话木马上传
GIF89a
&lt;script language="php"&gt;eval($_POST['shell']);&lt;/script&gt; 再次上传后出现以下页面，说明上传成功
接着我们进行抓包
经过多次尝试我们发现，文件的后缀不能为php，文件绕过的格式也有很多格式php,php3,php4,php5,phtml，但是经过尝试后发现只有.phtml此后缀名可绕过，其余均无法绕过，所以我们将上传文件yy.jpg的后缀改为phtml
查看/upload
找到我们上传的文件yy.phtml
查看/upload/yy.phtml
使用蚁剑进行连接，连接成功后
在/flag目录下找到flag
flag为
flag{27541e51-6965-4231-89b8-e9071b3b8b46} 四、[护网杯 2018]easy_tornado 打开靶机，出现以下页面
挨着点击三个文件查看
/flag.txt
/welcome.txt render（）是tornado里的函数，可以生成html模板。是一个渲染函数 ，就是一个公式，能输出前端页面的公式。 tornado是用Python编写的Web服务器兼Web应用框架
/hints.txt
/file?filename=/fllllllllllllag&amp;filehash={{1}}
模板注入必须通过传输型如{{xxx}}的执行命令
通过msg拿到cookie_secret的值
/error?msg={{handler.settings}}
提示信息，得到cookie_secret:750eeb79-5711-4775-8086-ed342d0f6b67
然后结合md5(cookie_secret+md5(filename))
即md5('750eeb79-5711-4775-8086-ed342d0f6b67'+md5('/fllllllllllllag'))
filename=/fllllllllllllag的md5：3bf9f6cf685a6dd8defadabfb41a03a1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5583735aa5597916b22f3385cdc73057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80ac2f7840592905bbf373a672901d9/" rel="bookmark">
			VMware 17密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 密钥：MC60H-DWHD5-H80U9-6V85M-8280D
从大神的博客里面找来的.能用. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b858471f96ec898bd89c1bacd3bf690/" rel="bookmark">
			Java处理doc类型的Word文档转换成html(按顺序保留格式&#43;图片)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新有个新需求，就是doc文档转换html内容倒不是很难，给大家分享一下，总体思路就是按doc转html的思路来走，唯一缺点是不会自动转换图片，图片是要手动转成base64，默认是有html、body、head、meta等等标签，我这里都用正则处理掉了。
需要注意的是：
.docx 格式的 Word 文档是一种基于 XML 和 ZIP 压缩技术的文件格式，其文件结构相对固定并且较为简单，可以通过一些开源的 JavaScript 库进行解析和转换(推荐使用mammoth.js在前端即可完成Word转换html的操作，但是目前的mammoth版本只支持docx，后续可能会支持解析doc的功能)。
·
.doc 格式的 Word 文档是一种相对来说版本比较老一点并且是二进制格式的文件，文件结构比较复杂，具有较高的私有性和细节，需要专用微软 Office 应用程序才能完整读取，所以一般如果要对doc文档进行转换内容时，最好是使用java处理，比较容易一些。
具体引用jar包如下，一共6个： 1、poi-4.1.2.jar 2、poi-ooxml-4.1.2.jar 3、poi-scratchpad-4.1.2.jar poi的版本必须一致，不然会有问题，一般情况下如果用到poi互相依赖，最好是要做到poi版本一致，不仅针对这个转换html中，其他地方也是一样。
4、fr.opensagres.poi.xwpf.converter.xhtml-2.0.2.jar 5、commons-math3-3.6.1.jar 6、commons-collections4-4.4.jar jar包下载如果本地没有可以去中央仓库下载，直接搜索就行，比较方便，有pom也有jar
总体流程和思路：
1、创建 File 对象，将要转换的 Word 文档的路径传入文件对象中。 2、使用 FileInputStream 对象读取 Word 文档文件。 3、构建 HWPFDocument 对象，该对象是 Apache POI 库中的类，用于读取 .doc 格式的 Word 文档。 4、构建 WordToHtmlConverter 对象，并将 DocumentBuilderFactory、DocumentBuilder 和 Document 对象传递给构造函数。 5、解析 Word 文档并将解析结果存储到 Document 对象中。 6、创建 Transformer 对象，用于将 Document 对象转换为 HTML 格式，并设置输出格式、字符编码等。 7、使用 DOMSource 对象将 Document 对象中的内容提供给 Transformer 对象。 8、创建 ByteArrayOutputStream 对象，并将结果存储到该流中。 9、使用 StreamResult 指定输出流，将转换后的结果写入到 ByteArrayOutputStream 中。 10、将 ByteArrayOutputStream 对象转换为字符串并输出。 需要注意的是，此示例中使用的是 HWPFDocument 类，而不是 XWPFDocument 类 这意味着该示例只能处理 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b858471f96ec898bd89c1bacd3bf690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556c1ee02e328d5ab03d4e0d1fb411dd/" rel="bookmark">
			ITDR何以成为IAM的最佳搭档？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
❖随着零信任方案的逐渐落地，身份成为企业的新边界。同时，身份基础设施成为了攻击焦点。
❖最近的身份攻击变得更加巧妙和复杂，甚至可以绕过MFA。
❖当前的IAM解决方案只能起到预防作用。
❖企业更需要一个能够检测和响应身份威胁的 ITDR 解决方案。
❖ITDR 供应商目前被收购和整合发展迅速。
❖选择 ITDR 解决方案时需要考虑两点：
(1) 能够接入多场景，不限于AD。
(2) 从不同的供应商处分别购买 IAM 和 ITDR，以避免锁定的风险。
零信任时代到来，身份是新的边界和漏洞 零信任作为新安全框架，在日本推广进度迅猛，其核心思想是基于传统身份边界的身份验证和授权的转变。
另一方面，随着组织转向零信任并越来越依赖以身份基础设施为中心的环境，意味着身份基础设施成为攻击者的最佳目标。事实上，我们还发现，凭据滥用这一攻击手段正在被黑客广泛利用。
近年来不断增加的身份威胁和攻击是什么？ 特定的身份威胁会潜入目录服务器（如 Active Directory）、基于云的标识和访问管理 (IAM) 解决方案（如 Okta 和 Azure AD）以及身份基础设施（如证书颁发机构）。它是指通过跟踪易受攻击的设置来获取特权身份等凭据信息并进行渗透的网络攻击。
由于它在没有像过去那样使用恶意软件进行远程控制的情况下入侵，因此无法被 EDR 等恶意软件检测引擎检测到。
近来，安全研究人员发现即便启用了多因素身份认证保护措施，用户仍可能收到钓鱼攻击的侵害，并且针对身份的攻击变得越来越复杂。
现有的身份管理方案（IGA、PAM、CIEM）只是预防 那么，是否有可能使用我们目前使用的各种身份和访问管理工具（如IAM，IGA，PAM和CIEM）来应对这些攻击？
像Savyint这样的IGA（身份治理和管理）和像CyberArk这样的PAM（特权访问管理）也具有防止不必要的特权身份过度配置的功能。对于 AWS 和 Azure 等云基础设施环境，使用以CIEM为代表的云基础设施授权管理功能，可以发现并防止过多的云身份权限颁发和脆弱的IAM设置。
此外，通过在云上或者本地应用IAM 提供的 MFA（多因素认证），可以最大程度地减少管理员权限被利用的机会（例如，更改为每次执行 SSH 或 RDP 时都需要 MFA 的定时设置）。
但是，如上所述的身份管理解决方案本身所提供的功能，只是预防身份攻击，并不能在IAM基础设施被入侵后进行相应的检测与阻断。
ITDR——身份威胁检测与响应 即使您能够使用IAM等尽可能适当地设置公司的身份基础设施环境，毫不夸张地说，想要完全阻止攻击者通过巧妙的方法入侵您的身份基础设施是不可能的。基于身份基础设施将受到威胁的假设，有必要单独考虑在其遭到入侵后如何检测和响应对身份基础设施的威胁。
我们可以通过新的解决方案——ITDR（身份威胁检测与响应）来实现。
ITDR 是一种与EDR（端点检测和响应）、NDR（网络威胁检测和响应 ）相邻的新解决方案。具体而言，正如 EDR 对端点设备的行为进行分析，ITDR通过AI 和机器学习技术，对以Active Directory 和 Okta为代表的身份基础设施上交换的身份验证流量的行为进行分析。
ITDR能够检测与异常行为或威胁情报相一致的可疑身份，并实现各种“响应”，例如阻止来自相应ID 的身份验证以及与IAM一起请求额外的 MFA，例如 Okta。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/556c1ee02e328d5ab03d4e0d1fb411dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07882500fa0bda53b22d3cf6dc432c5d/" rel="bookmark">
			STM32 ws2812b多屏驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、ws2812b的数据传输以及屏幕的组合二、代码ws2812screen.c文件ws2812screen.h文件主函数 前言 在上篇文章中使用了stm32的dma+tim的方式点亮了ws2812b的灯
但是我的需求不仅仅是点亮他，我需要他像屏幕一样显示某一些东西，ws2812显示有一个开源库AWTRIX
这个库需要使用上位机不是很符合我的需求。
所以自己写了一个屏幕的驱动，后续会不断在此基础上改进。
例如我使用的是一个5*5的小ws2812b的屏幕
但是我需要把多个屏幕组合起来。当点亮某个屏幕的时候不能总是一个个按照他的数据方向一个个数。所以我们就需要对每个灯珠进行重映射–也就是通过【x】【y】的方式来点亮屏幕。
2023/7/17 可以多块屏幕组合进行显示，可以设置数据流动方向
一、ws2812b的数据传输以及屏幕的组合 ws2812b的数据传输是有方向的以我买的屏幕为例.
绿色的是板子的第一个灯，按照这个数据流向。
当把多个板子组合在一起的时候
数据就是这样子流向
再有多行板子的时候
当弄清楚了数据的流向以后就需要明确板子的行列关系.
二、代码 ws2812screen.c文件 本代码段分别有initializeLedMapping(int boardRows, int boardCols, int rows, int cols)
其中的几个参数需要根据上面的自己填写。
void setLedColor(int x, int y, uint32_t colorValue) 是给点设置颜色的。设置完以后还要调用上篇文章的中
的void WS2812_Send (void)进行发送。
你还可以调用void drawDigit(int digit, int startX, int startY, uint32_t colorValueOn, uint32_t colorValueOff) 这个函数来显示阿拉伯数字
void drawColon(int x, int y, uint8_t on,uint32_t colorValueOn) 函数是显示冒号的，为后续做时钟做准备。
显示3x5的阿拉伯数字的二维布尔数组的定义
显示一个阿拉伯数字最少需要3*5的灯珠
效果
#include "ws2812screen.h" #include "stdio.h" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07882500fa0bda53b22d3cf6dc432c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b55fcce6eb345d7e889f8144a50ef7/" rel="bookmark">
			Windows安装jdk并配置环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载jdk
到Oracle官网下载jdkJava Downloads | Oracle
选择Windows --&gt; x64 installer 后面的连接进行下载
2. 安装jdk
下一步下一步就行
可以更改路径（我的是D:\Java\jdk17）
3. 配置环境变量
（1）设置 -- 系统 -- 系统信息 -- 高级系统设置
（2）在系统变量中点新建
在变量名中输入JAVA_HOME 变量值中输入绝对路径（我的是D:\Java\jdk17）
（3）在系统变量中点新建
在变量名中输入CLASSPATH 变量值中输入
.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
（4）修改系统变量中的Path变量
%JAVA_HOME%\bin %JAVA_HOME%\jre\bin 4. 验证是否配置成功
（1）打开cmd（win+r）
输入java
输入javac
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758bbc37d129124f29f0508487890962/" rel="bookmark">
			K8S安全风险及防护建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes（K8S）是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。一个Kubernetes集群通常包含跨多台计算机运行的控制平面和多个工作节点（node），控制平面用于管理集群中的node，node用于运行工作负载。
Kubernetes架构图
自从2014年首次发布以来，Kubernetes受到了越来越多的关注和广泛的应用。目前，它已成为云原生应用程序开发和部署的标准之一，被许多大型企业和组织广泛采用，如谷歌、微软、亚马逊、IBM、阿里巴巴、腾讯等。根据CNCF的调查显示，截至2021年11月，全球有超过90%的企业和组织正在使用Kubernetes进行容器编排和管理。
一、针对Kubernetes的攻击愈演愈烈 近年来，针对K8S的攻击事件逐渐增加，成为了安全领域的一个重要话题。根据一些安全厂商和研究机构的报告，K8S的攻击事件占比情况如下：
Trend Micro发布的《2021年1-6月全球云安全报告》显示，2021年上半年，云容器和Kubernetes攻击的比例达到了43%。攻击者的目的是获取敏感信息、窃取凭据、传播恶意软件等。
Aqua Security发布的《2020年云原生安全报告》中指出，针对Kubernetes的攻击事件在2020年增长了26%。其中，最常见的攻击包括未经身份验证的访问、挖矿、拒绝服务、数据泄露等。
CNCF（Cloud Native Computing Foundation）发布的《2021年技术调查报告》中指出，65%的受访者认为容器和Kubernetes面临的安全风险是他们使用云原生技术时最大的担忧之一。另外，55%的受访者认为Kubernetes容易受到攻击。
综合来看，K8S的攻击案例验证了未来的主流攻击趋势，那就是‍集权设施将会成为未来攻击者的主要攻击对象。集权安全值得企业安全负责人们重点关注。
二、常见的Kubernetes威胁来源 在针对K8S的攻击日益激烈的情况下，攻击来源也表现出了多样化，根据调研目前它正面临着来自供应链、恶意攻击者、内部成员的攻击以及黑客组织等的威胁。
1、供应链风险
供应链包含构成最终产品的任何元素，从组件到用于管理集群的第三方服务或软件，这些风险有很多来源，而且通常很难解决。
在 2019 年，Harbor作为一个Kubernetes基础架构下的开源仓库，其曾遭受到了供应链攻击。攻击者通过Harbor的供应链漏洞，注入恶意Docker镜像，这些镜像被部署在Kubernetes集群中，最终导致Kubernetes集群的安全受到威胁。
2、恶意攻击者
恶意攻击者可以利用Kubernetes架构组件中的漏洞和错误配置，例如控制平面、工作节点或容器化应用程序。
2018年，黑客入侵了Tesla公司的Kubernetes集群，并利用集群中的计算资源进行加密货币挖掘。这次攻击的原因是由于Tesla在使用Kubernetes时未采取适当的安全措施。
3、内部威胁
内部威胁可以是管理员、用户，甚至是云服务提供商。对组织的Kubernetes基础设施具有特殊访问权限的内部人员可能会滥用这些特权。
2019年，加拿大的电商平台Shopify遭受了内部员工的K8S攻击。该员工修改了K8S配置文件，使得攻击者能够在Shopify的K8S集群中创建新的管理用户，并窃取用户数据。
三、Kubernetes攻击面 K8S作为一种开源的容器编排平台，已经成为了云原生应用开发和部署的重要基础设施之一。但同时，K8S也因其高度复杂的架构和众多组件，成为了攻击者攻击的目标之一。那么，攻击者采用何种方式攻击K8S？
以下是微软官方在2021年给出的K8S威胁矩阵图，详细地呈现了攻击者在每个阶段使用的技术，从左到右通过执行每个阶段的攻击方式也呈现了成果扩大的过程。
随着攻击技术的发展，每个攻击阶段的攻击技术也更加丰富。接下来对K8S攻击过程中的一些重要攻击阶段进行详细介绍。
初始访问（Initial Access）
初始访问是指攻击者在进入系统前获得的第一步访问权限。在Kubernetes中，攻击者可以通过多种方式进行初始访问。其中，一种常见的方式是通过针对公网暴露的Kubernetes API Server进行攻击。
另外攻击者还常用容器内漏洞入侵、kubeconfig file泄露、etcd未授权访问、恶意镜像等方式，进行前期的信息收集工作，以获得初始权限。
命令执行（Execution）
在Kubernetes中，命令执行通常是指攻击者通过各种手段在容器或节点上执行任意命令。比如攻击者可通过容器中运行的SSH服务执行命令，如果攻击者通过暴力破解或者其他方法获得了容器的有效凭证，他们就可以通过SSH获得对容器的远程访问。
另外，如果容器自身存在漏洞，那么攻击者也会通过漏洞执行命令。命令执行方式多种多样，常见的执行命令的攻击还有创建后门Pod、利用API Server执行命令、通过Sidecar注入执行命令、通过curl执行容器命令等。
权限维持（Persistence）
在Kubernetes中，攻击者利用权限维持来获取对系统的长期控制。例如，攻击者可以通过向容器镜像中添加恶意代码来创建一个具有相同标签的deployment或ReplicaSet。这样，当新的Pod创建时，它将自动更新为攻击者的容器镜像。攻击者可以在该容器中添加后门或其他恶意代码，以确保他们在以后的访问中能够维持其权限。
针对权限维持的其它利用方式包括挂载主机路径、K8s cronjob、Shadow API Server等，这些攻击方式常常被攻击者使用。
权限提升（Privilege Escalation）
Kubernetes中的权限提升攻击是指攻击者通过各种手段提升其在集群中的权限。一旦攻击者成功地提升了其权限，就可以对整个集群进行更多的攻击，比如访问其他资源、执行恶意代码等。例如，攻击者可以创建一个特权容器，该容器可以访问宿主机上的资源，并在该容器内执行命令，从而使其获得更高的权限。
另外，挂载根目录逃逸、容器内访问Docker.sock逃逸、docker漏洞逃逸、篡改ServiceAccount等方式也被经常使用。
横向移动（Lateral Movement）
横向移动是指攻击者利用已经获得的某个系统或账户的权限，在整个网络中移动并寻找其他系统或账户，以便进一步扩大攻击面和获取更高的权限。在Kubernetes中，攻击者可以利用各种漏洞和配置错误来获取对一个或多个节点的访问权限，然后通过控制这些节点来进行横向移动。
例如，攻击者可以通过利用kubelet的漏洞或未经授权的凭据访问节点，并在这些节点上启动恶意容器或修改已有容器的配置。一旦攻击者获得了节点的访问权限，他们可以扫描网络并寻找其他容器或节点，以便进一步扩大攻击范围。其它的横向攻击方式有通过容器逃逸进行横向、Cluster内网渗透、窃取凭证攻击云服务等。
总的来说，攻击者可以通过利用K8S集群内各组件的漏洞或者未经适当保护的访问权限来进一步深入攻击，这可能会导致敏感数据泄露、服务中断、系统崩溃等严重后果。
四、ITDR保护K8S集群 针对K8S的攻击日益激烈，如何避免K8S不被攻击值得大家思考，保护K8S中的敏感数据意义重大。为了保护您的K8S集群，可采用中安网星的ITDR平台进行全方位的保护。
ITDR（身份威胁检测与响应）平台是中安网星推出的针对身份威胁检测与响应高级威胁分析平台。主要围绕Identity及Infrastructure为核心进行防护，涵盖主流身份基础设施及集权设施，围绕从攻击的事前加固、事中监测，事后阻断出发，产品的设计思路覆盖攻击者活动的全生命周期。
事前，利用ITDR内置引擎对K8S集群中的不合理配置项、K8S相关的历史漏洞进行主动发现，在遭受恶意攻击之前，提前加固K8S集群，不给攻击者以可乘之机。
事中，通过融合图计算、身份欺骗等技术，对K8S进行全方位的监测，及时发现针对K8S的漏洞利用、身份窃取等风险，在遭受攻击的第一时间及时发现攻击者，对攻击行为进行阻断。结合威胁狩猎思想，将身份蜜罐技术应用于ITDR平台中，为反制攻击者提供保证。
事后，对攻击事件进行取证调查，禁用不合理的用户，清理危险的凭据，根据基线事件对K8S进行加固。
All in one：中安网星ITDR平台能力持续演进与突破
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d8d65478707f18fdc05c1b38e2d240/" rel="bookmark">
			CentOS7系统MBR、GRUB2、内核启动流程报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🥩Linux启动流程
🥩MBR修复
🍭1、模拟损坏
🍭2、重启测试
🍭3、修复MBR
🍭4、测试系统
🥩GRUB2修复
🍭1、模拟损坏
🍭2、修复GRUB2
🍭3、测试系统
🥩内核修复
🍭1、模拟损坏
🍭2、修复内核
🍭3、测试系统
🦐博客主页：大虾好吃吗的博客
🦐专栏地址：服务器管理
Linux启动流程 在生产环境中系统出现bug，作为一个运维需要知道问题出在哪，查看系统日志/使用测试工具/使用top等系统资源命令查看。另一种情况系统直接崩了，开机无法打开。那我们就需要看下面Linux（CentOS7）启动系统的顺序。根据系统给出的提示修复系统。
来自GPT给出的Linux启动流程可以大致分为以下几个阶段：
BIOS/UEFI阶段：计算机通电后，会首先执行计算机的基本输入输出系统（BIOS）或统一固件接口（UEFI）。在这个阶段，固件会进行硬件自检和初始化工作，并加载引导设备的Master Boot Record（MBR）或EFI系统分区的启动程序。
Bootloader阶段：引导设备的MBR或EFI系统分区的启动程序会加载操作系统的引导加载器，例如Grub或Syslinux。引导加载器会提供一个菜单，让用户选择加载哪个操作系统或启动选项。
内核加载阶段：一旦用户选择了启动选项，引导加载器会加载Linux内核（通常是一个压缩的镜像文件，如vmlinuz）。加载内核时，引导加载器还会传递一些附加的启动参数，用于配置内核的行为。
内核初始化阶段：内核被加载后，它会进行一系列的初始化操作，包括检测和配置硬件设备、初始化内存管理、挂载文件系统等。内核还会启动第一个用户空间进程（init进程），该进程负责系统的进一步初始化和启动其它进程。
用户空间初始化阶段：在内核初始化完毕后，init进程会按照配置文件（通常是/etc/inittab）中的指示，启动一系列的用户空间服务和进程。这些进程包括系统服务（如网络服务、时间服务等）和用户登录界面（如图形界面或命令行界面）等。
用户登录阶段：一旦用户空间初始化完成，系统会提供一个用户登录界面，用户可以输入用户名和密码来登录系统。一旦登录成功，用户就可以开始使用操作系统提供的各种功能和进行各种操作。
总结：开机BIOS自动检测系统，通过MBR引导通过BRU2菜单选择哪个系统（如双系统），选择启动选项后加载内核文件，systemd初始化。
通过上面我们简单了解了下Linux的启动进程，我们下面模拟损坏并修复。
MBR修复 Linux MBR（Master Boot Record）是系统引导时非常重要的一个数据块，引导环境通常安装在磁盘的第一个扇区。
1、模拟损坏 我们这里使用虚拟环境模拟MBR损坏，MBR损坏通常有两种情况，MBR文件损坏或grub目录被误删。我们现在模拟损坏只需要把磁盘的第一个扇区前446个字节破坏掉，就可以起到MBR损坏的作用。
打开虚拟机，使用漏洞命令模拟损坏。
[root@daxia ~]# dd if=/dev/zero of=/dev/sda bs=100 count=1 记录了1+0 的读入 记录了1+0 的写出 100字节(100 B)已复制，0.00072338 秒，138 kB/秒 [root@daxia ~]# sync 2、重启测试 重启后，发现系统自动使用PXE寻找网络中的系统，说明MBR引导找不到系统了。
3、修复MBR 下面我们就开始修复MBR，关闭服务器，挂载系统光盘，进入急救模式。注意：我这里直接关闭了虚拟机，选择iso文件后，默认是启动时连接。开启虚拟机后进入第三选项(急救模式)。
在开启服务器后的操作如下：
Troubleshooting→Rescue a CentOS system→ 1 (注意这有个1表示选择继续)
在急救模式修复，执行下面命令。默认进入的系统可以称为伪系统，而执行chroot /mnt/sysimage 后看到的才能称之为真正的系统。重启（先exit退出再再执行reboot重启）测试系统是否正常使用，我这是虚拟环境，你的系统如果有服务或文件，测试起来更好一些。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3d8d65478707f18fdc05c1b38e2d240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edf2176a88b5c3c8c5bb68d8b7c1716/" rel="bookmark">
			SQL SERVER的字段类型说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MS的SQL Server主要是由五种常常用到的字段，字符型，文本型，数值型，逻辑型，和日期型！许多朋友苦于在一些BBS中ACCESS转换成SQL后字段类型不匹配而不知所措，下面我们就来介绍一些这五种数据类型各自的特性吧！ [1] 字符型数据Varchar，Char型 程序当中当大家需要存储比较短的字符串信息时我们就要用到字符型数据了，SQL中的字符型数据又有两种型！VARCHAR和CHAR型，正两种类型的数据差别是很细微的，但是却很重要！ 比如当你像一个长度为40个字符的VARCHAR型字段中输入一个长度为4的字符串TOL8后你再取出的数据的时候，数据的长度为4个字符，而你把VARCHAR换成CHAR型，你取出的将会是40各字符长度的数据，字符串后会被附加多余的空格，比如TOL8只有4个字符那么从CHAR中取出的数据是TOL8加上36个空格！具体的程序设计中我个人还是推荐VARCHAR类型，因为从一些参考资料中我发现上面说VARCHAR型要比CHAR占用更少的硬盘很内存！ VARCHAR存储最长255个字符，超过这个长度就要用到我们下面将要讲到的文本型数据了。 [2] 文本型数据Text 文本型数据中你可以存储超过20亿个字符串，怎么样，这个够大了吧？但是也不是任何时候都是和使用文本型数据，因为他非常占空间，也非常消耗服务器，随处乱用后果不堪设想！因为即使你像一个文本型字段输入了一个空值他都会占用2K的空间！而当这时除了删除该数据没有别的办法收回空间！ [3] 数据型数据 Int，Tinying，Numeric SQL支持多种不同的数据类型，让你可以存储整数，小数，和钱数！ INT（整型数据）表示范围是从-2，147，483，647 到 2，147，483，647 的整数 如果你的数值没有那么长，为了节省内存空间你可以使用SMALLINT它的表示范围是-32768到32768整数！二者的使用方法完全相同！ 如果你还想再节省空间你可以选择使用TINYINT他只能存储0到255的整数注意TINYINT不能存储负数，一个TINYINT占用一个字节，而一个INT型数据占用4个字节！ [4] 数据型数据 Bit 网页复选框搜集信息存入数据库，是BIT型最常见的用法了！他只有两个值：0或1 [5] 数据型数据 Datetime，Samlldatetime DATETIME的存储范围是从1753年1月1日第一毫秒到9999年12月31日最后一毫秒，如果你不需要覆盖面这么大的日期范围，可选使用SMALLDATETIME型它的存储范围是从1900年1月1日到2079年6月6日，但是只能精确到秒！ [6] 特殊型数据 Cursor 这里包括些2进制数据类型和一些其他不常用到的数据类型
来源：微点阅读 https://www.weidianyuedu.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e39f61193de0adce832ab914db28b57/" rel="bookmark">
			【vue2】纯前端实现本地的pdf/word/epub文件预览（包括pdf选中文字，epub高亮等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 需求是预览本地的pdf/word/epub格式的文件，但是搜索后发现没有可以直接使用的，格式不同，显示的方式和效果也都略有不同。
最后还是分别实现预览的功能。
如果只需要预览pdf/word等格式的话，可以使用的方案：vue-office，支持多种文件(docx、excel、pdf)预览的vue组件库，支持vue2/3。也支持非Vue框架的预览。补充功能：pdf选中文字，epub高亮（我的需求是选中pdf/epub的文字后进行收藏） 实现 pdf预览和选中文字高亮 方案：pdfjs+iframe
因为这样可以使用浏览器自带的pdf阅读器，不需要再自己实现小图预览等功能。
pdf.js实现pdf的预览与下载（vue+springboot+pdf.js） 有demo,比较基础的功能。也是本地引入pdf.js的用法
扩展：web打开在线的pdf文件，禁用打印和下载功能
VUE预览PDF文件并利用pdf.js获取鼠标选中的文字和搜索，在iframe中获取选中文字，监听鼠标事件，右键菜单
直接本地引入pdf.js的方法也可以参考上面这篇文章，写的很详细。
主要参考的还是获取选中文字的部分：
getSelectText() { let _this = this; let iframe = document.getElementsByClassName("pdf-viewer-local")[0]; let x = ""; let y = ""; let _x = ""; let _y = ""; // iframe 加载完成后执行并将双击事件过滤掉，因为双击事件可能也触发滑选，所以为了不误操作，将其剔除 iframe.onload = function () { // 鼠标点击监听 iframe.contentDocument.addEventListener( "mousedown", function (e) { x = e.pageX; y = e.pageY; _this.isShowNotePop = false; }, true ); // 鼠标抬起监听 iframe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e39f61193de0adce832ab914db28b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0088537bc4ac72e2608b3c47645915a/" rel="bookmark">
			linux实现定时备份文件到百度网盘详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备工作
（1）写在文章之前
（2）环境
（3）查看配置信息
二、执行流程
（1）安装pip
需要注意的是 （2）安装bypy，requests包
（4）授权登录
（5）创建目录和脚本文件
1.创建目录：
2.创建脚本文件代码如下（书写代码要规范）：
3.如果遇到脚本无法执行可以进行如图操作，参考菜鸟教程
（6）使用crontab实现定时备份数据
1. crontab是什么？
2. 怎样使用？
3.使用流程
三、百度网盘中的效果
四、在文章最后
一、准备工作 （1）写在文章之前 作为一个程序员，数据备份尤为重要，本文主要介绍的是将服务器上的某文件定时备份到百度网盘中。主要实现思路是：安装pip、byp --&gt; 百度网盘进行授权登陆 --&gt; 使用crontab+bypy实现定时自动数据备份。 （2）环境 Centos7+python2.7.5下利用crontab+bypy实现自动备份数据到百度网盘。笔者在制作过程中使用的是Xshell7软件连接linux服务器，当然你也可以使用宝塔面板上的终端来进行相关命令的操作，不过宝塔面板上的终端在输入一些命令时更容易出现问题，有时也有一定的局限性，比如点击宝塔其他页面之后终端上输入的命令将被清屏，有时连接失败后也会被清屏，不方便查看之前的命令执行结果。
（3）查看配置信息 成功连接linux服务器后可以使用如下命令查看自己的环境配置信息：
1.查看centos版本信息
cat /etc/redhat-release 2.查看linux版本
cat /proc/version 3.查看python版本
查看系统是否有python环境（一般系统自带python2.7），此命令查看过后用Ctrl-D退出或输入quit()退出。
python 二、执行流程 （1）安装pip 进入到服务器对应的项目文件根目录下，可以使用cd命令 #使用cd命令进入到项目根目录中 [root@iZ85173om7p5tdZ ~]# cd /www/wwwroot/zx.wiyp.top sudo yum -y install epel-release #这是安装pip是要用到的东西 sudo yum -y install python-pip sudo yum clean all sudo pip install --upgrade pip #更新 #如果无法更新可以使用命令：sudo python -m pip install --upgrade pip 依次执行上面的代码，执行效果如下： 需要注意的是 这里在执行更新语句时出现了报错，无法更新时改命令用：sudo python -m pip install --upgrade pip，改用此命令时还是出现了一个错误：更新pip包时报错（ “Python‘ setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0088537bc4ac72e2608b3c47645915a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c4986e82ebcdc80b9b8615a1938c6d/" rel="bookmark">
			Cilium核心技术-eBPF XDP&amp;TC介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eBPF 是一项革命性技术，它能在内核中运行沙箱程序（sandbox programs）， 而无需修改内核源码或者加载内核模块。
eBPF的一个重要特性是能够使用高级语言(如C)来实现程序。LLVM有一个eBPF后端，用于编辑包含eBPF指令的ELF文件，前端(如clang)可以用于生成程序。
在一个后端转换为字节码后，使用bpf()系统调用加载bpf程序，并校验安全性。JIT会将字节码编译进CPU架构中，并将该程序附加到内核对象上，当这些对象发生事件时会触发程序的执行(例如，当从一个网络接口发送报文时)。
eBPF work flow eBPF MAP eBPF map是用户空间和内核空间之间的数据交换、信息传递的桥梁。本质上是以「键/值」方式存储在内核中的数据结构，它们可以被任何知道它们的BPF程序访问。在内核空间的程序创建BPF Map并返回对应的文件描述符，在用户空间运行的程序就可以通过这个文件描述符来访问并操作BPF Map，这就是为什么BPF Map在BPF世界中是桥梁的存在了。
网络数据收发原理 1.数据包达到物理网卡（RX FIFO），通过DMA到内存中。内存指的是网卡的接收的Ring Buffer。 2.并且拷贝成一个一个的sk_buffer. 3.触发硬中断，通知CPU，已经有数据来了，CPU根据注册的中断函数，中断函数调用驱动程序，驱动先禁用网卡的中断，目的下次再来数据就直接处理就可以，就不再通知CPU的硬中断。 4.弥补硬中断处理时间问题，需要启用一个软中断。（主要是弥补硬中断处理时间不及的问题） 5.数据单元的sk_buffer然后再交给我们的协议栈处理。实际上就是交给网络层和传输层来处理。[被ip层协议和传输层协议处理] 6.去处掉网络层和传输层的头以后，CPU就把数据Copy到用户空间的应用程序。 内核单元层级关系 网络相关的（子系统），但对于存储和其他系统，问题都是类似的。图中列出了对这些子系统进行操作所需的工具。例如: 配置以太网驱动或者网络设备需要使用 ethtool 命令; 配置路由使用 ip 命令; 配置过滤使用 seccom 命令; 配置 IP 防火墙使用 iptables 命令，但如果你使用的是 raw sockets，那有很多地方都 会 bypass，因此这并不是一个完整的防火墙; 配置流量整形使用 tc 命令; 抓包使用 tcpdump 命令，但同样的，它并没有展示出全部信息，因为它只关注了一层; 如果有虚拟交换机，那使用 brctl 或 ovsctl; 所以我们看到，每个子系统都有自己的 API，这意味着如果要自动化这些东西，必须单独的使用这些工具。有一些工具这样做了，但这种方式意味着我们需要了解其中的每一层。 eBPF work point 需要弄清楚netfilter所处的位置:
BPF XDP ---&gt; sk_buffer ---&gt; TC[network stack Dividing Line] ---&gt; IPv4 And IPv6 ---&gt; Netfilter ---&gt; TCP UDP RAW XDP (eXpress Data Path) XDP 代表 eXpress Data Path，提供了 BPF 框架，可在 Linux 内核中实现高性能可编程数据包处理。它在软件中尽早运行 BPF 程序，即在网络驱动程序收到数据包时。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c4986e82ebcdc80b9b8615a1938c6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b17b50d4f310dd0224eceb7cb605a08/" rel="bookmark">
			算法详解：可视化冒泡排序算法及其优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
在计算机科学中，排序算法是一种基本的算法，常被用于对一组数据进行排序。冒泡排序是一种简单的排序算法，它通过不断交换相邻元素的位置来实现排序。虽然冒泡排序的时间复杂度较高，但由于它实现简单、思路清晰，常被用于教学和面试等场合。本文将详细介绍冒泡排序算法及其优化。
一、冒泡排序算法简介
冒泡排序（Bubble Sort）是一种基本的排序算法，它的基本思想是通过不断交换相邻元素的位置，将待排序的元素按照从小到大（或从大到小）的顺序逐步排列。冒泡排序的实现过程如下：
比较相邻的元素。如果第一个元素比第二个元素大，就交换它们的位置。
对每一对相邻元素重复以上步骤，从开始的第一对元素到最后一对元素。这一步完成后，最后的元素会是数组中的最大值（或最小值）。
针对所有的元素重复以上步骤，除了最后一个元素。重复以上步骤直至排序完成。
以下是冒泡排序的C++代码实现：
void bubbleSort(int arr[], int n) { for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; n - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { swap(arr[j], arr[j + 1]); } } } } 在上述代码中，我们使用了两个循环嵌套来实现冒泡排序。外层循环控制排序的轮数，内层循环控制每一轮排序中相邻元素的比较和交换。
二、冒泡排序算法的时间复杂度
冒泡排序算法的时间复杂度为O(n^2)，其中n是待排序数组的长度。这是因为，冒泡排序算法需要进行n-1轮排序，每轮排序需要比较n-i-1次相邻元素并可能进行交换。因此，总的比较次数为(n-1)+(n-2)+...+1=n*(n-1)/2，即O(n^2)。
三、冒泡排序算法的优化
尽管冒泡排序算法的时间复杂度较高，但由于其实现简单、思路清晰，仍然常被用于教学和面试等场合。在实际应用中，我们可以对冒泡排序算法进行一些优化，以提高效率。以下是一些常见的冒泡排序算法优化方式：
如果在一轮排序中没有进行任何元素交换，说明数组已经有序，可以直接跳出循环。
在每一轮排序中，记录最后一次进行元素交换的位置lastExchangeIndex。由于lastExchangeIndex之后的元素已经有序，下一轮排序只需比较到lastExchangeIndex即可。
在排序过程中，设置一个标志位isSorted，如果在一轮排序中没有进行任何元素交换，说明数组已经有序，可以直接跳出循环。
以下是经过优化后的冒泡排序算法C++代码实现：
void bubbleSort(int arr[], int n) { bool isSorted = false; int lastExchangeIndex = 0; for (int i = 0; i &lt; n - 1 &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b17b50d4f310dd0224eceb7cb605a08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83703e9f0e8239a23eaa2e822c3001f3/" rel="bookmark">
			kali修改root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.启动kali，打开终端，输入 sudo passwd root
2.要求输入原来的密码
3.输入新密码 ，然后再次输入新密码
passwd updated successfully 密码修改成功
4. su root 即可进入root模式下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b781cc8515fbb3e13830cfeef013bd1/" rel="bookmark">
			STM32Cube中调试接口的设置及仿真器（ST-Link、J-Link）连接调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32Cube中调试接口的设置及仿真器（ST-Link、J-Link）连接调试 STM32CubeMX文件配置 首先，打开STM32CubeMX，新建文件。
第二步，选择相应的芯片，并双击，效果如下。这里我以STM32F405为例，如果不知道芯片型号，可以去看自己芯片上的小字。
将进入该芯片的配置界面。
第三步，查看单片机控制板原理图，寻找数据线(SWDIO)和时钟线（SWCLK）对应的引脚。（原理图可以找商城客服或者自行查找，但一定要注意单片机型号）
由上图可以确定SWDIO和SWCLK的接口分别为PA13和PA14。硬件中的接口为J1插排。
第四步，STM32CubeMX文件系统配置。分别将PA13和PA14引脚选为SYS_JIMS-SWDIO和SYS_JIMS-SWCLK，点击鼠标右键选择Enter User Label，将标签分别改为SWDIO和SWCLK。
接下来，将系统（SYS）选项卡中Debug选为Serial Wire，如图。
复位及时钟控制（RCC）选项卡中的高速外部时钟信号（HSE）设为晶振（Crystal/Ceramic Resonator），如图。
第五步，配置时钟树，具体按照自己所需进行配置。只需要修改下图红色部分后回车就行，系统会自动计算。本例中时钟设为了168。
第六步，选择编译环境并生成代码。Project中要设置文件名字，文件位置，编译器，如图。该例中使用的是STM32CubeIDE，如果使用的编译器是Keil，则需选择MDK-ARM，并选择对应的版本，小编建议大家使用IDE编程，其是一款较新且简单的编译器。
Code Generator中选择如下两个选项。
至此，点击右上角的GENERATE CODE按钮，生成IDE文件。生成后点击Open Project就生成并打开文件了。
点击打开的文件中的“🔨”标识，进行编程，发现无错误，无警告。
仿真器连接调试 使用到的仿真器一般有J-lLINK和ST-LINK（首次使用需要安装相应的驱动）。使用四根杜邦线进行连接仿真器和单片机。需要接的线有VCC（3.3V）,GND,SWDIO,CWDCLK。
J-LINK 接线实物图如下。
打开Run Configuration将调试探头选择为J-LINK。
ST-LINK（以下是两款的接线方式） 接线实物图如下。
（注：这里接2、4、6、8引脚）
同样，打开Run Configuration将调试探头选择为ST-LINK。
烧录代码 在代码编译无错误情况下，点击烧录按钮，当调试会话框结尾出现shutting down时说明烧录完成。
完成以上配置后生成代码链接：源代码
小结 该文章主要讲述了在STM32Cube中调试接口的设置及仿真器连接调试，完成这些我们就可以对stm32系列的单片机进行编程和烧录了。
这也是小编写的第一篇关于stm32相关的博客，如有正确的地方，希望大家指正。下一期小编将带来GPIO相关的讲解，小编和大家一起学习一起前进，希望大家多多关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdbe6fd3ff799f54d7c8ac69ac48010/" rel="bookmark">
			Java如何将字符串转为数字int(三种方式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将java字符串转换为数字 对知识永远只有学无止境。
第一种 String str = "123456"; Integer num = new Integer(str);//转换成对象 第二种 String str = "123456"; int num = Integer.parseInt(str); 第三种 String str = "123456"; int num = Integer.valueOf(str); 注意：这三种的转换区别在哪里呢？对知识应该敬畏。
第一种是将字符串，转换成一个数字的对象，两个相同的数字进行转换。
Integer num = new Integer("1");//转换成对象 Integer num1 = new Integer("2");//转换成对象 if (num == num1) { System.out.println("相等"); }else{ System.out.println("不相等"); } 结果：不相等
第二种：多次的解析，最终的得到结果，可以用 “==”进行判断相等
String s = "123456"; if (Integer.parseInt(s) == Integer.parseInt(s)) { //结果true System.out.println("两者相等"); } 结果：两者相等
第三种：多次解析会存在不相等的时候，具体请看需要看转换的字符整体大小决定的。
例子1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cdbe6fd3ff799f54d7c8ac69ac48010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d0cdda92ddcd150ca9924e8ef346af/" rel="bookmark">
			ASP.net GridView控件(编辑功能下拉列表填充数据)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前台添加
&lt;Columns&gt; &lt;asp:TemplateField HeaderText="职位" SortExpression="categoryID"&gt; &lt;%--编辑列(编辑模板)--%&gt; &lt;EditItemTemplate&gt; &lt;%--设置下拉列表的数据源,为自定义方法所返回的对象 DataSource:数据源 DataTextField:前端显示数据值 DataValueField:后台关联数据 id主键 SelectedValue:当前下拉列表所选中单条数据(bind()方法的值,及源数据表所选的值) --%&gt; &lt;asp:DropDownList ID="dropList1" runat="server" DataSource='&lt;%# ddlBind() %&gt;' DataTextField="names" DataValueField="id" SelectedValue='&lt;%# Bind("postid") %&gt;'&gt;&lt;/asp:DropDownList&gt; &lt;/EditItemTemplate&gt; &lt;%--常规显示列(显示模板)--%&gt; &lt;ItemTemplate&gt; &lt;/Columns&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/651cee5706f8f29c3f80f4810418c3d4/" rel="bookmark">
			给 ASP.Net 中 DropDownList 的使用（设置值，读取数据源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置数据源
DropDownListWCustomerinfo.DataSource = MaintenanceRepair.BLL.Customer.GetInfo();
DropDownListWCustomerinfo.DataTextField = "CustomerName";
DropDownListWCustomerinfo.DataValueField = "ID";
DropDownListWCustomerinfo.DataBind();
取值：
this.DropDownList1.SelectedItem.Text //取文字 既是否
this.DropDownList1.SelectedValue.ToString() //取编号 设置默认值
this.DropDownList1.SelectedValue = 3; // 3是编号
this.DropDownList1.Items.FindByText(cm.WCustomerinfo).Selected = true; //cm.WCustomerinfo是文字
this.DropDownList1.Items.FindByValue("3").Selected = true; // 3是编号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8754ac96341cbc49f240adcc2355c419/" rel="bookmark">
			aspx页面怎么直接打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 aspx页面如何直接打印
点击A打开B页面，B的内容是A的部分内容，只是用于打印，
如何让当点击A按钮时，直接打印B页面中的内容，而不跳出显示B页面：
------解决方案--------------------
Graphics类提供一个截图的方法CopyFromScreen，我们可以利用这个方法来截取屏幕：
g.CopyFromScreen(new Point(0, 0), new Point(100, 100), sz); ------解决方案--------------------
&lt;script language=javascript&gt; function doPrint() { bdhtml=window.document.body.innerHTML; sprnstr="&lt;!--startprint--&gt;"; eprnstr="&lt;!--endprint--&gt;"; prnhtml=bdhtml.substr(bdhtml.indexOf(sprnstr)+17); prnhtml=prnhtml.substring(0,prnhtml.indexOf(eprnstr)); window.document.body.innerHTML=prnhtml; window.print(); } &lt;/script&gt; 2：打印内容放在 &lt;!--startprint--&gt;和&lt;!--endprint--&gt;之间//打印页面的部分内容（当然也可以是全部）（如：B页面内容）。 3. &lt;a href="javascript:;" onClick="doPrint()"&gt;【打印内容页】&lt;/a&gt;//A页面中的打印 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a8906993a10048c3d8cde190756278/" rel="bookmark">
			fastadmin框架中如何添加一个自定义按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单介绍
具体效果：
使用fastadmin框架添加一个按钮并给按钮绑定相应的事件指向控制器中的方法，在fastadmin框架的二次开发中非常的常见，接下来本篇就来介绍一下创建按钮的具体流程。
二、具体流程
（1）首先在fastadmin框架中创建相应模块的视图、模型、控制器模块。
（2）在对应的public/assets静态资源目录下找到backend后台目录下的js文件。
（3）在文件的初始化表格参数中添加URL地址，这个地址指向你的控制器方法。
注意，我这里控制器的目录如图所示：
具体添URL的代码如下：
// 初始化表格参数配置 Table.api.init({ extend: { index_url: 'download/download/index', add_url: 'download/download/add', edit_url: 'download/download/edit', del_url: 'download/download/del', multi_url: 'download/download/multi', download_url: 'download/download/download', table: 'files', } }); （4）在初始化表格中添加按钮事件。其中URL指向控制器对应的方法
具体的代码如下：
field: 'operate', title: __('Operate'), table: table, buttons: [{ name: "download", text: "导出",//按钮名称 classname: 'btn btn-xs btn-success btn-magic ', // classname: 'btn btn-xs btn-success btn-magic btn-dialog', icon: 'fa fa-magic', url: 'download/download/download',//指向控制器对应方法 confirm: '导出当前用户的文件信息', visible: function (row) { //返回true时按钮显示,返回false隐藏 return true; } }], events: Table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a8906993a10048c3d8cde190756278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a048891271029bf52e6f415c1d020b3b/" rel="bookmark">
			用Python画一个星空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题
如何用Python画一个简单的星空？
2 方法
在Python中有着各种各样的工具包，比如math、pillow、requests等等，每个包有着自己专门的功能。要用python画星空，在绘制星空的过程中一般需要运用到turtle工具，它是属于Python的标准库，当然也可以将其称之为海龟库，它能够用于描绘绘图的轨迹，并且操作也比较简单、便捷。
代码清单 1
from turtle import *
from random import random,randint
screen = Screen()
width ,height = 800,600
screen.setup(width,height)
screen.title("模拟3D星空")
screen.bgcolor("black")
screen.mode("logo")
screen.delay(0)#这里要设为0，否则很卡
t = Turtle(visible = False,shape='circle')
t.pencolor("white")
t.fillcolor("white")
t.penup()
t.setheading(-90)
t.goto(width/2,randint(-height/2,height/2))
stars = []
for i in range(200):
star = t.clone()
s =random() /3
star.shapesize(s,s)
star.speed(int(s*10))
star.setx(width/2 + randint(1,width))
star.sety( randint(-height/2,height/2))
star.showturtle()
stars.append(star)
while True:
for star in stars:
star.setx(star.xcor() - 3 * star.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a048891271029bf52e6f415c1d020b3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d99383d565b2ef6c0cbcef8df45023/" rel="bookmark">
			[fix] libc10_cuda.so: undefined symbol: cudaMemPoolSetAttribute, version libcudart.so.11.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 问题描述解决办法 问题描述 conda clone一个环境后, import torch的时候报错:
torch/lib/libc10_cuda.so: undefined symbol: cudaMemPoolSetAttribute, version libcudart.so.11.0
解决办法 首先找到libcudart.so.11.0的位置, 发现在ENV/lib/libcudart.so.11.0里,
和原始环境的so文件不一致, so连接在clone的时候出错了
修改回去就可以,
unlink libcudart.so.11.0 ln -s libcudart.so.11.8.89 libcudart.so.11.0 同理对libcusparse.so.11也修改下连接
unlink libcusparse.so.11 ln -s libcusparse.so.11.7.5.86 libcusparse.so.11 之后就能import torch了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa7ed12a67da8c3f74348af72e1b787a/" rel="bookmark">
			a-range-picker时间范围查询前后端代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.前端form表单
2.触发函数赋值，将选择的时间范围赋值给请求参数中的属性
3.创建对应的属性
4.后端接收实体中添加字段
5.添加MP查询条件
场景：根据选择的时间范围查询在此范围内创建的数据
1.前端form表单 注：千万注意v-model不要写接口请求体的属性，单独写一个，不然会报错，这里绑定一个是为了重置按钮能够清空数据
&lt;a-form-model-item label="创建时间"&gt; &lt;a-range-picker show-time picker="month" v-model = "createValue" @change="onChange" format="YYYY-MM-DD HH:mm:ss" /&gt; &lt;/a-form-model-item&gt; 2.触发函数赋值，将选择的时间范围赋值给请求参数中的属性 onChange(date, dateString) { this.formSearch.startTime = dateString[0]; this.formSearch.endTime2 = dateString[1]; } 3.创建对应的属性 formSearch:{ startTime:'', endTime2:'', }, createValue:[], 4.后端接收实体中添加字段 @TableField(exist = false) @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") private LocalDateTime startTime; @TableField(exist = false) @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") private LocalDateTime endTime2; 5.添加MP查询条件 if (task.getEndTime2()!=null &amp;&amp; task.getStartTime()!=null){ queryWrapper.between("create_time",task.getStartTime(),task.getEndTime2()); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb51937d540bf7d7dd7539f0ce287ad/" rel="bookmark">
			mysql8允许所有的ip访问配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本机上安装完mysql8,别的机器不能访问，在本机器上进入mysql #进入mysql mysql -uroot -p #用mysql表 mysql&gt; use mysql; #设置允许任意IP访问，执行语句： update user set host = '%' where user = 'root'; #给root授予所有权限和授权选项，让它可以访问和管理所有数据库和表。%表示允许所有ip， GRANT ALL ON *.* TO 'root'@'%'; #更新用户加密方式，mysql8默认的加密方式为caching_sha2_password 与mysql5的加密方式mysql_native_password 不同 ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'qwer123'; #刷新权限 flush privileges; 如果是mysql容器，也需要执行下上面的步骤，让jar包能去访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765de5c3a6ee7a1ce80b0adeb49ea517/" rel="bookmark">
			redis-cli指定host和密码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以通过如下方式登录：
redis-cli -h 127.0.0.1 -a 123456 或者先进入客户端：
redis-cli -h 127.0.0.1 j进入客户端后，输命令：
auth 123456 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36da6df26992409e5532017881dcdab/" rel="bookmark">
			C#___语法概念部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 快速入门 文章内容来源C#的起源console.readline \writeline关键字refpubulic private staticpartial 继承objectinterfaceabstructvirtual泛型 变量类型与C不同的变量类型：string、char.class 和 struct 的区别堆和栈中的变量CLASS 容器函数指针运算符异常索引器C#应用场景C# 的任务调度原理如何调试C#代码如何对C#代码增删改查如何用C#实现一个界面应用C#界面应用常用的函数？C# 如何实现多线程，如何构思？如何实现？C# 的优势C#与.NET的关系？C#的常用控件C#的技巧 文章内容来源 文章是B站UP游戏谭的视频内容笔记。如有侵权立即删除。
链接: [link]https://www.bilibili.com/video/BV1sy4y1u7cw/?p=5&amp;spm_id_from=pageDriver&amp;vd_source=bef58c6219c539b73b93f44bae68c923)
C#的起源 console.readline \writeline 作用：在控制台输入或者输出一段字符；
Q：“Console” 控制台是什么？
A：在 Windows操作系统中，控制台称为"命令提示符"窗口并接受 MS-DOS 命令。
关键字 ref 作用：地址传递。区别于值传递。
示例：
C# 是没有指针的概念的。所以想实现地址传递，就得使用"ref"关键字.
pubulic private static 作用：定义作用范围；pubulic 表示可以在Class之外访问。 private 表示只能在class之内访问。
static概念：静态声明。可以声明属于类型本身而不属于特定对象的成员。不需要实例化就可以直接使用的变量。
partial 概念：部分的。是一部分类的定义。在大型项目中，在不同的独立文件中均有同一个类的部分定义，实现多程序员共同开发。
public partial class Employee { public void DoWork() { } } public partial class Employee { public void GoToLunch() { } } 继承 概念：子类继承父类的属性。class b: a{}; 是一个由普通到特殊的类型定义的过程。比如“人"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a36da6df26992409e5532017881dcdab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e1c30d01c1acb6667da20f10f13839/" rel="bookmark">
			Ubuntu 下进行系统备份与迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 经常一个项目做到一半，结果系统崩溃了，每次都得重装系统，因此，就在想怎么才能够直接在ubuntu系统备份现有的系统呢?找了很多教程，发现都需要安装软件，这些方法都比较复杂，后来终于找到一种简单的方法，记录一下。
1、查看磁盘号
sudo parted -l 或者 sudo fdisk -u -l 2、进入根用户目录
sudo -i 3、将正在使用的系统备份到指定目录（此处说明一下，我系统文件在dev/sda）
sudo dd if=/dev/sda | gzip&gt;/home/why/workspace/ubuntu20.img.gz 其中/home/why/workspace是保存的文件路径， ubuntu20.img.gz是文件名。
4、查看写入进度
sudo watch -n 3 pkill -USR1 -n -x dd #每秒打印3次 5、在ubuntu烧录打包好的镜像，先准备一个空硬盘或者 sd卡
5.1 查看空盘的盘符
sudo parted -l 5.2 将镜像烧录到该硬盘中
sudo gzip -dc /home/why/workspace/ubuntu20.img.gz|sudo dd of=/dev/sdc /dev/sdc是我准备的空盘
5.3 查看进度，等待烧录完成。
sudo watch -n 3 pkill -USR1 -n -x dd #每秒打印3次 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ca58da087010c665730c2946455ddd/" rel="bookmark">
			Cortex-M0内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Cortex-M0处理器的优势NMI 输入。寄存器和特殊寄存器程序映像启动流程嵌入式程序设计难点：并发任务的处理 RAM 空间组织Cortex-M 处理器的差别 Cortex-M0处理器的优势 能耗效率：处理器规模大小差不多，但是代码执行效率更高。所以能降能耗。
存储器容量限制
概念：32位能访问的空间肯定比16位，8位访问的空间多。这里不讨论16位的使用分页等操作来扩展存储空间。
代码密度高：Cortex-M0具备多种寻址方式，提高了代码密度。
关键字：高性能，程序执行速度快。0.9DMIPS/MHz;
关键字：高代码密度。高代码密度意味着单位代码实现更多功能。
关键字：确定的中断响应时间。最短16个时钟周期。16*1/48MHz = 500ns 左右。
NMI 输入。 概念：不可屏蔽中断。
作用：当系统发生致命故障时，使用该中断。
关键字：请求管理调用。SVC异常和PendSV。
关键字：Cortex-M0 向上兼容Cortex-M3, Cortex-M4;
寄存器和特殊寄存器 概念：数据在存储器中和寄存器中反复加载、存储，实现数据处理，称为加载-存储架构。使用内部寄存器操作，对存储器的操作也会减少。如果数据访问涉及到FLASH那么就会减少时间。
栈指针
概念：R13，栈指针（SP）; 在不同的物理位置上存在两个栈指针。主堆栈指针（MSP）和进程堆栈指针（PSP）；使用CONTROL来切换。
应用场景：栈一般是程序进中断的时候，会使用栈。或者在线程模式时，临时变量太多，内部寄存器不够用了，那么会使用栈。
主堆栈指针和进程栈指针的切换场景：一般不用切换。操作系统会涉及到切换，这是因为系统内核的占空间和线程级的栈空间是相互独立的。
xPSR，组合程序状态寄存器
概念：提供了程序执行信息和ALU(算术逻辑单元)标志。该寄存器由三个程序状态寄存器组成。APSR、IPSR、EPSR。
作用：指示的东西比较少，一般不用去看。涉及到程序跳转控制，数学计算。
PRIMASK 中断屏蔽特殊寄存器
概念：置位后，除了NMI和Hardfault之外的中断都会被屏蔽掉。实际上，此时当前的中断优先级被置为了0，这也是可以配置的最高等级。
与此类似的还有：faultmask,连fault都关闭。basepri; 控制屏蔽的中断优先级，rtos中常用。
本质：改变当前中断优先级为最高，导致其他中断优先级不回被响应了。
程序映像 概念：程序映像就是程序的执行地址。从0x0000000开始，获取向量表。向量表关键的是前两个地址，0x0000000和0x00000004，存储MSP栈地址和复位向量地址。
启动流程 嵌入式程序设计 常见的程序结构：轮询、中断、轮询中断混合，RTOS；
难点：并发任务的处理 场景：多个任务同时需要执行，其中一个任务过长，执行时间很长，导致其他几个任务不能得到及时响应而后程序失败。
解决办法：1、大任务切片划分。2、RTOS；
1、大任务切片划分，如果应用程序非常复杂的时候，手动拆分任务就不切实际了。
2、RTOS会有时间片的概念，自动在时间片结束后执行任务切换。在Freertos中需要手动打开。
RAM 空间组织 数据区域：包含全局变量和静态变量。
栈区域 ：用于临时数据存储、局部变量的存储空间、函数调用参数传递和异常处理处理的寄存器备份。突出一个临时。
Q：函数传参是怎么实现的？A：函数参数太多了，内部寄存器不够用了，也就放到栈里了。
堆区域 ： C函数自动分配存储器区域，例如malloc。
Cortex-M 处理器的差别 M3比M0多：
支持MPU(存储器保护单元)；
指令集更丰富；如除法器；
NVIC更灵活，优先级可变换。
调试方面，断点更多，支持跟踪特性；
架构
Cortex-M0是冯诺依曼架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06ca58da087010c665730c2946455ddd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71554f2e000a6f818b67bd8842766b5c/" rel="bookmark">
			Linux 离线安装软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 0.注意1.防火墙操作2.安装jdk1.上传jdk安装包2.安装3.配置环境变量 3.安装redis1.上传tar包2.安装命令3.项目连接时报错4.问题一保存信息解决 4.安装rabbitMq1.查看erlang与mq对应版本2.下载软件2.1下载erlang2.2下载rabbitMq 3.将文件拖放到linux4.安装5.开放端口6.启动rabbitMq7.安装web插件8.访问浏览器9.创建新用户 5.安装nginx1.安装依赖2.下载nginx3.上传到服务器4.解压5.安装6.检查是否安装成功7.正常输出8.如果报错9.启动nginx 0.注意 # 查看ip方式一 ip addr # 查看ip方式二 可能没有，执行命令安装 (sudo yum install net-tools) ipconfig # 下载wget命令 yum -y install wget 1.防火墙操作 tomcat：8080 ，redis：6379，nginx：80 mysql:3306，等端口
firewall-cmd --zone=public --add-port=80/tcp --permanent 添加端口 firewall-cmd --reload	防火墙重新加载 firewall-cmd --zone=public --query-port=80/tcp	查询80端口是否开启 firewall-cmd --zone=public --list-ports	查询所有能够穿透防火墙的端口 firewall-cmd --zone=public --remove-port=80/tcp --permanent 删除端口 2.安装jdk 1.上传jdk安装包 将软件==(jdk-8u201-linux-x64.tar.gz)==上传到 root/usr/local/src目录下
2.安装 # 1.解压到/usr/local目录下(解压就是安装) tar -zxvf /usr/local/src/jdk-8u201-linux-x64.tar.gz -C /usr/local/ # 2.测试安装是否成功 /usr/local/jdk1.8.0_201/bin/java -version 3.配置环境变量 3.配置环境变量：在任意目录下可以执行java命令（类似window下配置path环境变量） Linux操作系统的系统环境变量存在/etc/profile文件中的，我们只需要编辑一下，在文件的最后加上java变量的有关配置（其他内容不要动） 命令： vim /etc/profile (到最底部 按i即可编辑) 在最后面添加以下环境变量配置 export JAVA_HOME=/usr/local/jdk1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71554f2e000a6f818b67bd8842766b5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dbd9b683cc61f2992f09bbe0eaaca77/" rel="bookmark">
			HTTP-java模拟GET/POST请求（忽略/不忽略证书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、请求的形式
GET请求：把请求的数据放在URL上，用？分割URL和传输的数据，多个参数的话用&amp;符号连接。POST请求：把请求的数据放在HTTP请求包的包体中（requrest body）。 POST请求包含两个部分：请求头（header）和请求体（body）
1.Java发送post请求： 代码示例如下:
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.URL; import java.net.URLConnection; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLSession; import org.apache.log4j.Logger; import com.xwtech.parser.PostRequestHtmlParser; /** * Post请求类——得到HTML响应 */ public class PostRequest extends Thread { private String url = "https://b2b.10086.cn/b2b/main/listVendorNoticeResult.html?noticeBean.noticeType="; private String params; private Logger logger; public PostRequest(int noticeType, int perPageSize) { logger = Logger.getLogger(PostRequest.class); this.url = this.url + noticeType; //拼接URL请求，不包含参数 params = "page.currentPage=" + currentPage + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dbd9b683cc61f2992f09bbe0eaaca77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d38b041d66299b7e2b14b54d149efa5a/" rel="bookmark">
			Python3.10新增的match语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Python 3.10中引入了一种新的模式匹配（Pattern Matching）语法，它使用match关键字来进行模式匹配。这个新的模式匹配功能可以用于简化条件语句的编写，并提供了一种更直观、更简洁的方式来处理多个可能的匹配情况。
相当于其他语言中的switch...case语句
match data: case 0: print("数据为零") case 1: print("数据为一") case _: print("数据为其他值") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365530e9bd1e8a651e8f09f4e82cf373/" rel="bookmark">
			配置PCL1.13.0报错：Could NOT find Boost: missing: system filesystem date_time iostreams serialization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用cmake构建pcl库报错：
Could NOT find Boost: missing: system filesystem date_time iostreams serialization (found C:/Program Files/PCL 1.13.0/3rdParty/Boost/lib/cmake/Boost-1.80.0/BoostConfig.cmake (found suitable version "1.80.0", minimum required is "1.65.0")) CMake Error at C:/Program Files/PCL 1.13.0/cmake/PCLConfig.cmake:59 (message): common is required but boost was not found 错误 原因 pcl1.13.0版本对应vs2022，vs2019不兼容，所以报错
在下载pcl1.13.0的文件上可以看到
解决方法 换成vs2022
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf38707673354b15994c33e35a6511e/" rel="bookmark">
			vs2019&#43;pcl1.11.1库安装与环境配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 下载安装包注意安装解压vs2019中配置pcl附加依赖项提取附加依赖项lib文件C:\deeplearning\PCL 1.11.1\libC:\deeplearning\PCL 1.11.1\3rdParty\VTK\lib 其他版本lib快速提取方法测试pcl库是否安装成功 下载安装包 官网下载链接：https://github.com/PointCloudLibrary/pcl/releases
下载两个文件： PCL-1.11.1-AllInOne-msvc2019-win64.exe pcl-1.11.1-pdb-msvc2019-win64.zip 或到百度网盘获取：
链接：https://pan.baidu.com/s/13FSltPDSBemyxd4yRlJaNg?pwd=2tad
提取码：2tad 注意 最新的pcl1.13.0以上版本，需要使用VS2022，用vs2019会不兼容，会导致一些库加载不了，例如BOOST库会加载不了。
安装 双击“PCL-1.11.1-AllInOne-msvc2019-win64.exe”进行安装，点击下一步，出现下图界面时，选择“Add PCL to the system PATH for all users”，自动把路径添加到系统环境变量中。
选择安装路径的时候默认C盘，别改，就放C盘。
安装到最后的时候会弹出安装OpenNI的提示，此时也会选择安装路径，默认是C盘。C:\Program Files\OpenNI2。就放这位置，别乱换。 解压 解压“pcl-1.11.1-pdb-msvc2019-win64.zip”，将解压得到的文件夹中的内容添加“…\PCL 1.11.0\bin”中。
pcl库安装完成，接下来配置环境变量，在系统环境变量中，由于勾选了自动添加路径，可以看到已经有两个路径已经添加了进来，其他的没有自己补全，配置完环境变量后，重启电脑即可生效。
vs2019中配置pcl 视图-&gt;其他窗口-&gt;属性管理器
保存属性表
设置包含目录和库目录
vc++目录-&gt;包含目录中手动添加以下7个目录：
vc++目录-&gt;库目录中手动添加以下6个目录：
C/C++—&gt;预处理器—&gt;预处理器定义 BOOST_USE_WINDOWS_H NOMINMAX _CRT_SECURE_NO_DEPRECATE C/C++ -&gt;所有选项-&gt;SDL检查 改为否。
上面这个是在属性页里改的，最好在项目属性里，也把SDL检查改为“否”，不加下面这一步有的时候会报错。
项目-&gt;属性-&gt;C/C++ -&gt;所有选项-&gt;SDL检查
附加依赖项 链接器—&gt;输入—&gt;附加的依赖项
将PCL 1.11.1\3rdParty\VTK\lib和PCL 1.11.1\lib这两个文件夹下的lib文件的release版本添加到附加依赖项中
这个对于每个版本的pcl对应都不一样，需要根据自己的版本进行添加，我这是pcl1.11.1,如果是这个版本则直接复制下面的relase的lib文件到附加依赖项中即可。否则需要自己提取对应的文件。
提取附加依赖项lib文件 C:\deeplearning\PCL 1.11.1\lib 提取目录C:\deeplearning\PCL 1.11.1\lib下的lib文件
release版本(pcl1.11.1)
pcl_common.lib pcl_features.lib pcl_filters.lib pcl_io.lib pcl_io_ply.lib pcl_kdtree.lib pcl_keypoints.lib pcl_ml.lib pcl_octree.lib pcl_outofcore.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecf38707673354b15994c33e35a6511e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a67fc03937aedae5d02dbfb17645fcad/" rel="bookmark">
			目标检测：RCNN、Fast RCNN、 Faster RCNN 基本思想和网络结构介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、目标检测的基本介绍1.1 什么是目标检测？1.2 目标检测算法的分类 二、RCNN2.1 RCNN简介2.2 RCNN算法流程2.3 RCNN流程图2.4 RCNN框架2.5 RCNN的缺点 三、Fast RCNN3.1 Fast RCNN简介3.2 Fast RCNN算法流程3.3 Fast RCNN流程图3.3.1 总体流程3.3.2 softmax 分类器3.3.3 边界框回归器（bbox regressor ） 3.3 Fast RCNN 中 loss 的计算3.4 Fast RCNN框架3.5 Fast RCNN的缺点 四、Faster RCNN4.1 Faster RCNN简介4.2 Faster RCNN算法流程4.2 RPN网络4.2.1 RPN网络结构4.2.2 anchor的定义4.2.3 RPN生成proposal的过程 4.3 Faster RCNN框架 五、三者的比较：RCNN、Fast RCNN、 Faster RCN六、参考资料 一、目标检测的基本介绍 1.1 什么是目标检测？ 所谓目标检测就是在一张图像中找到我们关注的目标，并确定它的类别和位置，这是计算机视觉领域最核心的问题之一。由于各类目标不同的外观，颜色，大小以及在成像时光照，遮挡等具有挑战性的问题，目标检测一直处于不断的优化和研究中。
1.2 目标检测算法的分类 传统的目标检测算法有：SIFT（尺度不变特征变换）、HOG（方向梯度直方图）、DPM（一种基于组件的图像检测算法）等。
基于深度学习的目标检测算法可以分为两类：二阶算法（Two Stage）和一阶算法（One Stage）
二阶算法：先生成区域候选框，再通过卷积神经网络进行分类和回归修正。常见算法有 RCNN、SPPNet、Fast RCNN，Faster RCNN 和 RFCN 等。二阶算法检测结果更精确。一阶算法：不生成候选框，直接在网络中提取特征来预测物体的分类和位置。常见算法有 SSD、YOLO系列 和 RetinaNet 等。一阶算法检测速度与更快。 二、RCNN 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a67fc03937aedae5d02dbfb17645fcad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64377b7063656b087184860e2081ab55/" rel="bookmark">
			Python 教学 | Pandas 妙不可言的条件数据筛选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Part 1 前言
Part 2 Excel 的数据筛选与分布统计
Part 3 Pandas 条件数据筛选
1、条件数据筛选的不同维度
(1) 比较数据值
(2) 是否为空值
(3) 文本内容筛选
(4) 数据值长度
(5) 日期筛选
(6) 其他
2、复合条件筛选
Part 4 总结
Part 5 Python教程
Part 1 前言 在 Python 中，第三方库 Pandas 是数据清洗、处理、分析中的主力工具，几乎所有基于表格数据的需求都能在 Pandas 中得到实现，这也是 Python 语言在数据分析领域独占鳌头的一大因素。在上期技术文章中，我们介绍了 Pandas 中的数据选取功能，这为我们未来批量处理数据打下了良好的基础，本期文章我们将继续介绍 Pandas ，学习处理表格数据十分常用的数据筛选功能。在 Excel / WPS 等 office 软件中，数据筛选经常被使用到，而Pandas 自然也具备数据筛选功能，不仅如此，由于 Pandas 背靠 Python 语言，使得它在字符处理方面具备天然的优势，延伸到数据筛选中来，Pandas 则可以凭借正则表达式对数据进行随心所欲、妙不可言的筛选操作，那么究竟妙在哪里呢？下面我们一起来学习。
本教程基于 pandas 1.5.3 版本书写
本文中所有 Python 代码均在集成开发环境 Visual Studio Code (VScode) 中使用交互式开发环境 Jupyter Notebook 中编写，本文分享的代码请使用 VScode 打开。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64377b7063656b087184860e2081ab55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fc474b2bb978d6ae0b6c3efcfd44f2b/" rel="bookmark">
			开发笔记1：C#如何将两个字符串去掉重复部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串str1="45500A123F00000125000X"， 字符串str2="45500A123F00100025000X"。两个字符串代表的是一个条码范围，绿色部分代表的是条码的流水（1~1000）。在不清楚流水截取规则，可以通过下面算法自动去重，获取到条码流水。
代码如下：
#region 去掉两者相同的部分 public static void RemoveLike(string str1, string str2, ref string str1Result, ref string str2Result) { //从左往右去重 for (int index = 0; index &lt; str1.Length; index++) //从左往右逐位截取 { if (index == (str1.Length - 1)) //无重复的情况下，进行截取 { str1Result = str1.Substring(index, str1.Length - index); str2Result = str2.Substring(index, str2.Length - index); break; } else if (str1.Substring(index, 1) == str2.Substring(index, 1)) //重复自动跳过 { continue; } else //存在重复情况下，从左截取 { str1Result = str1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fc474b2bb978d6ae0b6c3efcfd44f2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8f8523be92c56c78a5c2b617f641bb/" rel="bookmark">
			在Vue中，如何让created中的某个函数最后执行？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用setTimeout函数：在created钩子内部将需要最后执行的函数使用setTimeout函数包裹，确保他是最后执行的：
created() { // 其他代码... setTimeout(() =&gt; { // 需要最后执行的函数 }, 0); } 通过将延迟时间设置为0，是函数异步执行，并将其防止啊在任务队列的末尾，从而在其他代码执行完毕后再执行。（setTimeout属于异步宏任务，具体可查看EventLoop事件循环机制）
2.使用Promise.then方法：将需要最后执行的函数包装在一个Promise对象中，并使用then方法将其放在最后执行：
created() { // 其他代码... Promise.resolve().then(() =&gt; { // 需要最后执行的函数 }); } Promise会创建一个已解析的Promise对象，通过then方法将需要最后执行的函数放置在Promise链的最后
！请注意：尽管这些方法可以将函数放置在created钩子中其他代码的后面执行，但他们仍然是异步的。因此，在执行完成之前，created钩子之后的代码可能会执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea8987c03def952725a957fbc12770f/" rel="bookmark">
			银行业100个名词解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在中国，银行、证券、保险和信托并称为金融业的四大支柱。
图片
银行业的概念
银行业在我国是指中国人民银行、监管机构、自律组织，以及在中华人民共和国境内设立的商业银行、城市信用合作社、农村信用合作社等吸收公众存款的金融机构、非银行金融机构以及政策性银行。
现代资本主义国家的银行结构和组织形式种类繁多。按其职能划分，具体包括中央银行、商业银行、投资银行、储蓄银行和各种专业信用机构。
证券业的概念
证券业指从事证券发行和交易服务的专门行业，是证券市场的基本组成要素之一，主要由证券交易所、证券公司、证券协会及金融机构组成。
保险业的概念
保险业是指将通过契约形式集中起来的资金，用以补偿被保险人的经济利益业务的行业。
信托业的概念
信托是一种理财方式，也是一种特殊的财产管理制度和法律行为，同时又是一种金融制度。
信托其本来含义是“受人之托、代人理财”。按照《中华人民共和国信托法》对信托的定义，“信托是指委托人基于对受托人的信任，将其财产权委托给受托人，由受托人按委托人的意愿以自己的名义，为受益人的利益或者特定目的，进行管理或者处分的行为。”
本篇文章旨在分享银行业务名词解释，收集的资料有限，不足之处，欢迎指正，喜欢的可以图片点赞+收藏+分享！
图片
1.央行、中国人民银行、中国银行有何区别？
中央银行，是一国最高货币金融管理机构，在国家金融体系中居于主导地位。中央银行职能是制定和执行货币政策、维护金融稳定、提供金融服务，央行业务是非营利的，我国的中央银行是中国人民银行(简称央行或人行)。
中国银行(简称中行)是国有商业银行之一，与建行、农行、工商等类似。
2.商业银行
商业银行是以追求利润最大化为目标,以多种金融负债筹集资金，以多种金融资产为其经营对象，能利用负债进行信用创造，并向客户提供多种功能、综合性服务的金融企业。
3.影子银行
一般是指那些有着部分银行功能，却不受监管或少受监管的非银行金融机构。简单理解，影子银行是那些可提供信贷，但是不属于银行的金融机构。中国影子银行主要包括信托公司、担保公司、典当行、货币市场基金、各类私募基金、小额贷款公司以及各类金融机构理财等表外业务等。特征：机构众多、规模较小、杠杆化水平较低但发展较快。
4.政策性银行
政策性银行，一般是指由政府设立，以贯彻国家产业政策、区域发展政策为目的的，不以盈利为目标的金融机构。1994年，我国组建了三家政策性银行——国家开发银行、中国进出口银行和中国农业发展银行。国家开发银行已于2008年12月16日转为商业银行。
5.直销银行
直销银行是互联网时代应运而生的一种新型银行运作模式，这一经营模式下，银行没有营业网点，不发放实体银行卡，客户主要通过电脑、电子邮件、手机、电话等远程渠道获取银行产品和服务，因没有网点经营费用，直销银行可以为客户提供更有竞争力的存贷款价格及更低的手续费率。
6.储蓄银行
是指通过吸收储蓄存款获取资金从事金融业务的银行。储蓄银行是一种较为古老的金融机构，大多是由互助性质的合作金融组织演变而来。互助性的储蓄银行就是存款人将资金存入银行，银行以优惠的形式向存款人提供贷款。
7.总分行制
在总行之下,可以在本地或外地设有若干分支机构，并都可以从事银行业务的商业银行。这种商业银行的总部一般都设在大都市，下属所有分支行须由总行领导指挥。
8.银行的表内业务与银行的表外业务
表内业务指资产负债表中，资产和负债栏目可以揭示的业务换句话说就是：指在资产负债表上反映的业务，一般认为贷款和存款涉及银行资产和负债为表内业务。比如银行的存款、贷款等；例如贷款、贸易融资、票据融资、融资租赁、透支、各项垫款等。
表外业务主要以各类中间业务为主，不是简单资产或者负债可以刻画的，可以看成是表内业务的衍生品。表外业务是不在资产负债表中反映，但是在一定时期可以转化成资产负债表上的内容的或有负债业务。比如，担保业务、承诺业务。表外业务也称为中间业务。
9.巴塞尔委员会(Basel Committee)
巴塞尔委员会是当今国际银行业监管领域最具影响力的组织，其全称为“巴塞尔银行监管委员会”"，自1975年2月成立以来一直致力于国际银行业有效监管的研究、协调工作，并遵循两项基本原则没有任何境外银行机构可以逃避监管;监管必须是充分有效的。该委员会对国际银行业监管的贡献突出体现为一个协定（《巴塞尔协定》)、一个协议（《巴塞尔协议》）和一系列的监管文献。
10.合规风险
根据巴塞尔协议的定义，合规风险指的是：银行因未能遵循法律法规、监管要求、规则、自律性组织制定的有关准则、以及适用于银行自身业务活动的行为准则，而可能遭受法律制裁或监管处罚、重大财务损失或声誉损失的风险。从内涵上看，合规风险主要是强调银行因为各种自身原因而遭受的经济或声誉的损失。这种风险性质更严重、造成的损失也更大。
11.信用中介
商业银行通过负债业务，把社会上各种闲散资金集中到银行，通过资产业务，把它投向需要资金的各部门，充当有闲置资金者和资金短缺者之间的中介人，实现资金的融通。
12.支付中介
商业银行利用活期存款账户，为客户办理各种货币结算、货币收付、货币兑换和转移存款等业务活动。
13.价值尺度(unit of account)
价值尺度是指货币是衡量和表现其他一切商品和劳务价值大小的工具。价值尺度是货币最基本、最重要的职能。（1）价值尺度的特点：①货币执行价值尺度时不需要现实的货币；②价值尺度职能的 技术规定-价格标准。（2）价值尺度的作用：①减少了商品交换中的价格数目，提高了交换的效率；②使商品内在价值外在地表现为价格，从而出现了“购买力”这一概念。
14.公允价值(fair value)
公允价值又称为公允市价、公允价格。熟悉市场情况的买卖双方在公平交易的条件下和自愿的情况下所确定的价格，或无关联的双方在公平交易的条件下一项资产可以被买卖或者一项负债可以被清偿的成交价格。
在公允价值计量下，资产和负债按照在公平交易中，熟悉市场情况的交易双方自愿进行资产交换或者债务清偿的金额计量。购买企业对合并业务的记录需要运用公允价值的信息，通常由资产评估机构对并企业净资产进行评估。
15.狭义货币
狭义货币 M1=C+D。其中，C（currency）表示通货，即流通中的货币，包括纸币和硬币，是指存款类金融机构以外的现金，也就是公众手中的现金；D（demand deposits） 表示活期存款或支票存款，是指非银行客户在存款类金融机构账户上可以签发支票的活期存款类别。M1 是狭义货币供应量，它代表了现实购买力，反映了居民和企业资金的松紧变化，是经济周期波动的先行指标。所以，M1 是一国中央银行调控的主要指标之一。
16.广义货币
广义货币 M2=M1+S+T。其中，S（savings）表示居民储蓄存款；T（time deposits） 表示单位定期存款。广义货币 M2 扩大了货币的范围，不仅反映现实购买力，还反映潜在购买力。M2 流动性偏弱，但反应的是社会总需求的变化和未来通货膨胀的压力状况。因此，M2 也成为一国中央银行关注的指标之一。
17.准货币
广义货币与狭义货币之差即居民储蓄存款和单位定期存款，相对于现金和支票存款而言，其流动性较差，但经过一段时间也能转化为现金或支票存款，可看作一种潜在的购买力。因此，国际货币基金组织（IMF）称其为“准货币”（quasi money）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea8987c03def952725a957fbc12770f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b9407a89e9798fbef0249195e14f4a/" rel="bookmark">
			超级简单的数据自动滚动el-table表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看到一个需求：
库存预警滚动表格，表格中每行数据由编号、物料及物料名称、仓库及仓库名称、当前库存及库存数量、状态（包括正常（黑色）、不足（绿色）、溢出（红色））构成，表格数据会自动滚动。
先来看一下成果：
直接上代码：
&lt;template&gt; &lt;div class="th"&gt; &lt;el-table class="th" border&gt; &lt;!-- 手动固定一个表头 --&gt; &lt;el-table-column label="编号" align="center" /&gt; &lt;el-table-column label="物料" align="center" /&gt; &lt;el-table-column label="仓库" align="center" /&gt; &lt;el-table-column label="当前库存" align="center" /&gt; &lt;el-table-column label="状态" align="center" /&gt; &lt;/el-table&gt; &lt;!--设置鼠标移入移出，悬浮时表格暂停动画--&gt; &lt;div class="box" @mouseover="pauseAnimation" @mouseout="resumeAnimation"&gt; &lt;el-table :data="data" class="table" border stripe :show-header="false" &gt; &lt;el-table-column align="center" label="" prop="id" /&gt; &lt;el-table-column align="center" label="" prop="matrial" /&gt; &lt;el-table-column align="center" label="" prop="store" /&gt; &lt;el-table-column align="center" label="" prop="stock" /&gt; &lt;el-table-column align="center" label="" prop="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b9407a89e9798fbef0249195e14f4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70900cc950fefa498306f0b923e27c28/" rel="bookmark">
			什么是 API 安全？详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着 API 技术的普及，API 安全成为了一个越来越重要的问题。本文将介绍什么是 API 安全，以及目前 API 面临的安全问题和相应的解决方案。
在开始，不熟悉 API 的同学们前我们可以先了解下：什么是 API？深入了解 API 的概念和应用
什么是 API 安全 API 安全是指保护 API 免受恶意攻击和滥用的安全措施。API 安全通常包括以下几个方面：
认证和授权：API 需要对请求进行身份验证和授权，以确保只有授权用户才能访问受保护的资源。加密和传输安全：API 通常需要使用 SSL/TLS 或其他加密协议，以确保请求和响应数据在传输过程中得到保护。输入验证和防止注入攻击：API 需要对输入数据进行验证和过滤，以防止 SQL 注入、跨站点脚本攻击（XSS）等攻击。防止拒绝服务攻击：API 需要对请求进行限制和过滤，以防止恶意攻击者对 API 进行过度使用和占用资源。 目前 API 面临的安全问题 目前 API 面临的安全问题主要包括以下几个方面：
1、未经授权的访问
未经授权的访问是 API 安全中最常见的问题之一。攻击者可以使用未经授权的凭据或者伪造请求，获取对受保护的资源的访问权限。这种攻击可能导致敏感信息泄露、恶意操作等风险。
以下是一个未经授权的访问示例，攻击者使用伪造的请求头部信息获取了对资源的访问权限：
GET /api/resources/1 HTTP/1.1 Host: api.example.com Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 2、SQL 注入和其他注入攻击
SQL 注入是一种常见的攻击方式，攻击者通过在请求参数中注入恶意的 SQL 语句，获取敏感信息或者修改数据库记录。其他注入攻击包括跨站点脚本攻击（XSS）等，攻击者可以在请求参数中注入恶意的脚本代码，获取敏感信息或者执行恶意操作。
以下是一个 SQL 注入攻击的示例，攻击者在请求参数中注入恶意的 SQL 语句，获取了数据库中的敏感信息：
GET /api/resources?id=1;SELECT * FROM users WHERE username='admin'-- HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70900cc950fefa498306f0b923e27c28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da372902fbbc191a100ae06a53c85ca2/" rel="bookmark">
			【HTB系列】Bastard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hackthebox上的靶机Bastard
内容比较多不想又重复粘贴，可以直接访问下面的地址阅读原文
https://note.youdao.com/s/IxYyCpqT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f3868d9496c141fbf91720f6277ef9/" rel="bookmark">
			动手学ROS2-2节点通信-话题之RCLCPP实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：本文基于ubuntu22.04和ros2 humble版本
目录
一、话题入门
1.节点通信
2.话题基础概念
2.1话题通信采取的是订阅发布模型
2.2消息接口，同一个话题，所有的发布者和接收者必须使用相同消息接口。
2.3GUI-RQT工具
2.4CLI工具
二、话题之RCLCPP实现
1. 创建节点
2.编写发布者
2.1导入消息接口
2.2确定话题名称和服务质量Qos
2.3使用定时器定时发布数据
2.4运行测试
3编写订阅者
3.1创建订阅节点
​编辑
3.2查看订阅者API文档
3.3编写修改相关文件
3.4运行测试
4订阅发布测试
一、话题入门 1.节点通信 通信的目的是在计算机系统中实现不同组件、进程或设备之间的信息和数据传递。
通信的原理涉及两个主要方面：通信协议和通信方式。
通信协议定义了数据的格式、传输方式、错误检测和纠正等规则，以确保可靠的数据传输。
通信方式涉及了不同的通信介质和技术，包括网络通信和进程间通信（IPC）。
基于TCP/UDP的网络通信方式：通过计算机网络进行信息交换。
基于共享内存的进程间通信(IPC)方式：通过共享内存区域在同一计算机系统内的不同进程之间进行通信。
ROS 2用于通讯的默认中间件是DDS。在DDS中，不同逻辑网络共享物理网络的主要机制称为域(Domain) ID。同一域上的ROS 2节点可以自由地相互发现并发送消息，而不同域上的ROS 2节点则不能。所有ROS 2节点默认使用域ID为0。为了避免在同一网络上运行ROS 2的不同计算机组之间互相干扰，应为每组设置不同的域ID。
2.话题基础概念 2.1话题通信采取的是订阅发布模型 节点发布数据到某个话题上，节点就可以通过订阅话题拿到数据。
​
2.2消息接口，同一个话题，所有的发布者和接收者必须使用相同消息接口。 为了方便发送者和接收者进行数据的交换，ROS2帮我们在数据传递时做好了消息的序列化和反序列化。
2.3GUI-RQT工具 终端输入命令，可以显示节点间通信模型
rqt_graph
​
2.4CLI工具 ros2 topic -h
ros2 topic list 返回系统中当前活动的所有主题的列表
ros2 topic list -t 返回系统中当前活动的所有主题的列表时，增加消息类型
ros2 topic echo &lt;话题&gt; 打印实时话题内容
ros2 topic info &lt;话题&gt; 查看话题属性信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19f3868d9496c141fbf91720f6277ef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bfb28049e7f1794fe03191f8d5697e8/" rel="bookmark">
			python3.9，PyQt5，anaconda虚拟环境，jupyter notebook——的环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7a941a8c4031d92b4ccf79b2304196/" rel="bookmark">
			js 获取当前时间yyy-mm-dd hh:mm:ss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接在控制台运行 输出当前时间2023-07-13 09:51:15
let time = new Date().toLocaleString().split('/'); let time1 = time[1] &gt; 10 ? time[1] : 0 + time[1]; let time2 = time[2].split(' '); let time3 = time2[0] &gt; 10 ? time2[0] : 0 + time2[0]; let date = time[0] + '-' + time1 + '-' + time3 + ' ' + time2[1]; console.log(date); // 2023-07-13 09:51:15 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b61e7c8c8488e48b217cf7caed0453/" rel="bookmark">
			前端常见的事件，案例源码html&#43;css&#43;js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 点击事件
1. onclick：单击事件
2. ondblclick：双击事件
二. 焦点事件
1. onblur：失去焦点
2. onfocus:元素获得焦点。
三. 加载事件
1. onload：一张页面或一幅图像完成加载。
四. 鼠标事件
1. onmousedown 鼠标按钮被按下。
2. onmouseup 鼠标按键被松开。
3. onmousemove 鼠标被移动。
4. onmouseover 鼠标移到某元素之上。
5. onmouseout 鼠标从某元素移开。
五. 键盘事件
1. onkeydown 某个键盘按键被按下。 2. onkeyup 某个键盘按键被松开。
3. onkeypress 某个键盘按键被按下并松开。
六. 选择和改变
1. onchange 域的内容被改变。
2. onselect 文本被选中。
七. 表单事件
1. onsubmit 确认按钮被点击。
2. onreset 重置按钮被点击。 一. 点击事件
1. onclick：单击事件
html+css+js
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b61e7c8c8488e48b217cf7caed0453/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80344186a8d352bf454d14d5f76290fc/" rel="bookmark">
			truenas rsync
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		truenas生成ssh-keygen后，将公钥传到源服务器时耍-i xxx.pub
ssh-keygen
cd /root/.ssh
ls -a
ssh-copy-id *.pub -p 22 root@192.168.1.3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2658031e427147407f36030850ceeb8f/" rel="bookmark">
			手把手教你在gitcode创建项目，并上传项目，完成项目的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要安装与配置git下载git安装git 注册、登录gitcode注册账号并新建项目新建项目命令指引 生成SSH密钥上传文件到仓库中 摘要 GitCode 是 CSDN 为开发者提供的开源项目创新服务平台，秉承“创新、开放、协作、共享”的开源价值观，致力于为大规模开源开放协同创新助力赋能，打造创新成果孵化和新时代开发者培养的开源创新生态！支持公有云使用、私有化部署以及软硬一体化私有部署。
项目地址：https://gitcode.net/explore/welcome
这篇文章向大家展示如何从零开始使用gitcode完成项目的搭建。
安装与配置git 下载git 下载地址:
https://git-scm.com/downloads 点击链接后，根据系统选择，我的电脑是Win11，所以选择Windows。
点击红框的位置就可以下载git了。当然，下面的链接还提供其他的版本，有兴趣的可以试试！
速度感人！！！！！！
终于下载完了，接下来开始安装
安装git 双击下载好的exe，如下图：
点击Next.
安装的位置，可以选默认路径，也可以自定义路径。喜欢安装到哪里就安装到哪里。
选择安装的项目，简单的标注了几个，如果没有特殊需求，默认即可！！！！！！
方框内 Git 可改为其他名字，也可点击 “Browse…” 选择其他文件夹或者给"Don’t create a Start Menu folder" 打勾不要文件夹，点击 Next。
选择 Git 默认编辑器。Git 安装程序里面内置了 10 种编辑器供你挑选，比如 Atom、Notepad、Notepad++、Sublime Text、Visual Studio Code、Vim 等等，默认的是 Vim。
如果你不想用 Vim 当默认编辑器，换一个，比如 Notepad++ ，那么你者需要点击下面的蓝色字体 " Notepad++ "。
去其官网下载安装。安装后才能进行Next。
第一种是让 Git 自己选择，名字是 master ，但是未来也有可能会改为其他名字；第二种是我们自行决定，默认是 main，当然，你也可以改为其他的名字。一般默认第一种，点击 Next。
第一种是仅从 Git Bash 使用 Git。这个的意思就是你只能通过 Git 安装后的 Git Bash 来使用 Git ，其他的什么命令提示符啊等第三方软件都不行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2658031e427147407f36030850ceeb8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac33c5ffde20644c92930028768e917/" rel="bookmark">
			【学习记录】小车配置Livox雷达记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅用于记录自己配置小车Livox雷达遇到的问题，和一些注意事项。
1. Livox-SDK2安装 https://github.com/Livox-SDK/Livox-SDK2
mid360使用的是SDK2，因此下载安装SDK2，并按照官方说明进行编译与安装。
2. livox-ros-driver 驱动 livox-ros-driver: https://github.com/Livox-SDK/livox_ros_driver
livox-ros-driver2: https://github.com/Livox-SDK/livox_ros_driver2
官方说2是1的更新。一开始安装了2，但后面配置 lio-livox 时用到了1，因此也把1也装上了。
安装后，
需要修改PC的IP为：192.168.1.50，掩码 255.255.255.0，网关默认为空或192.168.1.1livox的IP为：192.168.1.1xx，其中xx为livox的产品号最后两位。我的是 192.168.1.199运行ros时，需要先修改/livox_ros_driver2/config/MID360_config.json文件：中的所有ip，为对应的IP。运行指令，有两个：启动rviz可视化的，和仅发布数据的： roslaunch livox_ros_driver2 rviz_MID360.launch	# 打开rviz roslaunch livox_ros_driver2 msg_MID360.launch	# 仅发布数据的 3. LIO-Livox 里程计 3.1 安装依赖项 https://github.com/Livox-SDK/LIO-Livox
需要安装的依赖项包括：ceres，cmake等，参考官方的readme
cmake
由于安装ceres依赖 CMake 3.16，同依赖的 gflag/glog 等也依赖cmake版本。因此首先更新cmake，这里安装了 cmake 3.20版本。比较漫长。
ceres-solver
安装ceres需要先后安装gflag，glog，eigen等。
同时编译时报错：No rule to make target '/usr/local/cuda‘，因为工控机安装了cuda但没找到对应的编译。
后面虽然export了环境变量，但编译时出现了一堆cuda的报错。因此在cmake时取消了对cuda的依赖：cmake .. -DUSE_CUDA=OFF
其他安装
还需要eigen,PCL等，但工控机之前已经装过了，所以没有重装。
3.2 编译LIO-Livox 修改ceres改版后Manifold的语法
否则编译时报错：error: ‘LocalParameterization’ is not a member of ‘ceres’
ceres::LocalParameterization *quatParam = new ceres::QuaternionParameterization(); // 将上述的内容替换为下面的。这是ceres最近一次更新更换的名称； ceres::Manifold *quatParam = new ceres::QuaternionManifold(); 修改CMakeLists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac33c5ffde20644c92930028768e917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771c5388256182c16c3757427bcec66f/" rel="bookmark">
			Bringing HLSL Ray Tracing to Vulkan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This post was revised March 2020 to reflect newly added support in DXC for targeting the SPV_KHR_ray_tracing multi-vendor extension.
Vulkan logo
DirectX Ray Tracing (DXR) allows you to render graphics using ray tracing instead of the traditional method of rasterization. This API was created by NVIDIA and Microsoft back in 2018.
A few months later, NVIDIA unveiled its Turing GPU architecture with native support in hardware to accelerate ray tracing workloads.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/771c5388256182c16c3757427bcec66f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/65/">«</a>
	<span class="pagination__item pagination__item--current">66/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/67/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>