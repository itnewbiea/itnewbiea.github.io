<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2586d89f368b16522ac9fc03a59c78cf/" rel="bookmark">
			微信小程序实现转发给好友以及朋友圈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小趴菜上线！！！，想来想去还是记录一下这里吧，刚开始也是一脸懵。
这里的分享（转发）有两种途径：
1、通过button去触发：
i: 通过给button 设置 open-type="share"属性，可以在点击按钮后触发onShareAppMessage事件
ii：只能发送给好友，不能转发朋友圈
2、通过右上角"..."
需要注意的是如果你需要“分享好友”与“分享朋友圈”两个功能需要开启分享菜单中的“分享到朋友圈”按钮：
onLoad() { wx.showShareMenu({ menus: ['shareAppMessage', 'shareTimeline'], }); }, 不然你可能会看到分享朋友圈的功能是灰色的，如图：
开启之后呢，通过就可以正常的分享了
具体可查看：Page(Object object) | 微信开放文档
/* “分享到朋友圈” */ onShareTimeline: function () { let videoPath = this.data.videoPath return { title: '我的相册', query: 'videoPath=' + videoPath , imageUrl:"", } }, /** * 用户点击右上角分享 */ onShareAppMessage() { let videoPath = this.data.videoPath return { title: '相册', path: '/modulePages/pages/albumMake/albumMake?videoPath=' + videoPath , imageUrl: '', } }, 代码中需要注意的是，我的onShareAppMessage中的path路径，因为页面位置在分包中，所以需要写成"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2586d89f368b16522ac9fc03a59c78cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7dbc41e03a86016de9bf412324d127/" rel="bookmark">
			Uniapp小程序 时间段选择限制（开始日期 结束日期相互限制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果图：
1. 在这里我使用的是uview中的日期时间选择器，初始话的时候将可选的最小时间设置为当前时间的时间戳，并将开始时间的可选的最大时间初始化为10年后（方便之后做限制操作）
&lt;!-- 日期选择-开始 --&gt; &lt;u-datetime-picker ref="refStart" :show="showStrTimePic" :minDate="minStartTime" :maxDate="maxStartTime" v-model="startPicDate" @confirm="confirmStart" @cancel="cancelStart"&gt; &lt;/u-datetime-picker&gt; &lt;!-- 日期选择-结束 --&gt; &lt;u-datetime-picker ref="refEnd" :show="showEndTimePic" :minDate="minEndTime" v-model="endPicDate" @confirm="confirmEnd" @cancel="cancelEnd"&gt; &lt;/u-datetime-picker&gt; 2. 在确定选择开始时间的时候 将结束时间可选的最小时间设置为所选开始时间的时间戳
// 确认选择开始日期 confirmStart(val) { this.startDate = this.DateFormatNumG(val.value, 'Y-M-D H:I') this.showStrTimePic = false this.minEndTime = val.value } 3. 在确定选择结束时间的时候 将开始时间可选的最小时间设置为所选结束时间的时间戳
// 确认选择结束日期 confirmEnd(val) { this.endDate = this.DateFormatNumG(val.value, 'Y-M-D H:I') this.showEndTimePic = false this.maxStartTime = val.value } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f97a67aac9cf20667b1d4946c69194/" rel="bookmark">
			C# 优雅的解决TCP Socket粘包、分包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、探索问题2.1 源码位置2.3 说明文档 三、解决思路四、实现方式五、普通Socket如何实现 一、概述 TCP是流性质数据的发送与接收，就像是一条河流，我们不能依靠它本身来区分哪部分水来自哪条山沟。但是往往，数据的解析就必须清楚的知道哪里是解析界限，不然发送的数据则像臭婆娘的烂线裤，难以把握。
二、探索问题 2.1 源码位置 GiteeGithub 2.3 说明文档 文档首页
三、解决思路 实际上，解决粘包、分包问题的思路有很多，例如：
Http：使用“\r\n”分割header，然后读取contentLength的Body。WebSocket：采用特殊数据帧，用可变头表示载荷数据。等等。 而当我们自己搭建TCP服务器或客户端以后，如何优雅的解决这个问题呢？
常规思路其实也就三种：
固定包头：以前几个固定字节作为包头，然后标识后续字节数量。固定长度：不管发送多少数据，客户端和服务器以固定长度接收。终止因子分割：约定数据以某种特定组合结束，可以理解为汉语的“句号”。 四、实现方式 要实现上述的算法，我们需要引入TouchSocket的Nuget包。然后服务器和客户端选择对应的适配器即可。
例如：
【服务器】
使用固定包头数据处理适配器(FixedHeaderPackageAdapter)，然后设置包头由int标识，也就是4+n的数据格式。
TcpService service = new TcpService(); service.Connecting = (client, e) =&gt; { client.SetDataHandlingAdapter(new FixedHeaderPackageAdapter() { FixedHeaderType= FixedHeaderType.Int }); }; service.Received = (client, byteBlock, requestInfo) =&gt; { //从客户端收到信息 string mes = byteBlock.ToString(); Console.WriteLine($"已从{client.IP}:{client.Port}接收到信息：{mes}");//Name即IP+Port client.Send(byteBlock); }; var config = new RRQMConfig(); config.SetListenIPHosts(new IPHost[] { new IPHost("127.0.0.1:7789"), new IPHost(7790) });//同时监听两个地址 service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29f97a67aac9cf20667b1d4946c69194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859ee19ea4421f95eb44634f53f25971/" rel="bookmark">
			2023年05月青少年软件编程（Python）等级考试试卷（一级） 试题解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【单选题】（每题2分）
1、可以对Python代码进行多行注释的是？（　）
A、#
B、" "
C、''' '''
D、' '
正确答案：C
试题解析：#是单行注释，三引号，包括单三引号和双三引号可以用于多行注释，所以选C。
2、下列可以作为Python变量名的是？（　）
A、and
B、an-d
C、1_and
D、and1
正确答案：D
试题解析：本题考查变量的命名。变量名只能以字母开头，其他字符可以是字母数字和下划线，and是Pyhton的保留字，不可作为变量名。
3、下列选项中不符合Python语言变量命名规则的是？（　）
A、s
B、2_5
C、_AI
D、CountNum
正确答案：B
试题解析：根据Python语言变量命名规则数字不能作为变量名的首字符。所以选B。
4、使用变量age表示小明的年龄，使用变量sage表示小明哥哥的年龄，假设小明在4岁时哥哥的年龄是小明年龄的2倍，下列哪段代码可以正确计算出再过6年小明和哥哥的年龄？（ ）
A、
&gt;&gt;&gt; age=4 &gt;&gt;&gt; sage=4*2 &gt;&gt;&gt; print(age+6,sage+6) B、
&gt;&gt;&gt; age=4 &gt;&gt;&gt; sage=4*2 &gt;&gt;&gt; print(age,sage+6) C、
&gt;&gt;&gt; age=4 &gt;&gt;&gt; sage=4*2 &gt;&gt;&gt; print(age+6,sage) D、
&gt;&gt;&gt; age=4 &gt;&gt;&gt; sage=4*2 &gt;&gt;&gt; print(age,sage) 正确答案：A
试题解析：根据题意，需要先算出哥哥的现在年龄，然后给两人现在的年龄各加6就是6年后的年龄。所以选择A。
5、在turtle中可以用setup()设置画布的大小和起始位置。已知画布的设置参数为turtle.setup(120,120,20,20)，若只想更改画布的高度为150，下列指令设置正确的是？（　）
A、turtle.setup(150,120,20,20)
B、turtle.setup(120,150,20,20)
C、turtle.setup(120,120,150,20)
D、turtle.setup(120,120,20,150)
正确答案：B
试题解析：turtle.setup(120,120,20,20)的四个参数，第一个代表画布宽度，第二个代表画布高度，第三个代表起始位置的X坐标，第四个代表起始位置的Y坐标；
要想改变高度，需要改第二个参数，即：turtle.setup(120,150,20,20)，选B。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/859ee19ea4421f95eb44634f53f25971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c1fbcc75f31e3068e831805fbb85d1/" rel="bookmark">
			【Shell 命令集合 系统管理 】Linux 添加新的用户账户 adduser 命令 使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录标题 描述语法格式参数说明错误情况 注意事项底层实现示例示例一示例二示例三示例四示例五示例六示例七 用c语言实现结语 Shell 命令专栏：Linux Shell 命令全解析
描述 adduser命令用于在Linux系统中添加新的用户账户。它的作用包括以下几个方面：
创建用户账户：adduser命令可以创建一个新的用户账户，并为该用户分配一个唯一的用户ID（UID）。每个用户账户都有一个唯一的用户名和对应的密码。
分配用户主目录：在创建用户账户时，adduser命令会自动为该用户分配一个用户主目录。用户主目录是用户在登录系统后的默认工作目录，用户可以在该目录下存储自己的文件和配置信息。
设置用户登录Shell：adduser命令可以指定用户登录时使用的Shell。Shell是用户与操作系统交互的界面，不同的Shell提供不同的功能和命令。
创建用户组：在创建用户账户时，adduser命令可以选择将用户加入一个或多个用户组。用户组是一组具有相同权限和访问权限的用户的集合。
设置用户密码：adduser命令可以设置用户的登录密码。密码是用户登录系统时进行身份验证的凭证。
分配用户权限：adduser命令可以为用户设置不同的权限和访问控制。通过将用户加入不同的用户组或设置特定的权限，可以限制用户对系统资源的访问和操作。
总而言之，adduser命令是在Linux系统中创建新用户账户的工具，它可以为用户分配唯一的用户ID、分配用户主目录、设置登录Shell、创建用户组、设置密码和分配权限等。这些功能使得系统管理员可以方便地管理和控制用户账户。
语法格式 adduser [选项] 用户名 参数说明 -c, --comment COMMENT：为新用户添加注释，可以是用户的全名或其他相关信息。-d, --home HOME_DIR：指定新用户的主目录路径。-g, --gid GROUP：指定新用户所属的初始用户组。-s, --shell SHELL：指定新用户的登录Shell。-p, --password PASSWORD：为新用户设置密码。-m, --create-home：如果主目录不存在，则创建新用户的主目录。-k, --skel SKEL_DIR：指定骨架目录，用于初始化新用户的主目录。-r, --system：创建一个系统用户。-u, --uid UID：指定新用户的用户ID。-e, --expiredate EXPIRE_DATE：设置新用户的账户过期日期。 错误情况 如果没有足够的权限执行adduser命令，则会显示"adduser: Only root may add a user or group to the system."的错误提示。如果指定的用户名已经存在，则会显示"adduser: The user ‘username’ already exists."的错误提示。如果指定的主目录已经存在，则会显示"adduser: The home directory ‘/home/username’ already exists."的错误提示。 注意事项 在使用Linux Shell的adduser命令时，有一些注意事项需要注意：
需要root权限：adduser命令需要root权限才能执行，因为创建用户账户需要对系统进行修改。因此，在使用adduser命令之前，确保以root用户身份登录或者具备sudo权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38c1fbcc75f31e3068e831805fbb85d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2957564e3ab8311f2ebaff04631833ca/" rel="bookmark">
			JS数组常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.map
map方法执行调用方法后返回一个新的数组，新数组中的每一项是调用方法处理后的新值，但并不会改变原数组，并且新数组的长度与原数组相等。
let arr = [1, 2, 3] let newArr = arr.map(item =&gt; return { item * 2 }) newArr = [2, 4, 6] 2.forEach
forEach方法用于遍历数组，没有返回值。
let arr = [{id: 1, name: 'xiaoming', age: 21}, {id: 2, name: 'xiaohong', age: 19},{id: 3, name: 'xiaoqiang', age: 22}] arr.forEach(item =&gt; { console.log(item) }) 打印结果：[{id: 1, name: 'xiaoming', age: 21}, {id: 2, name: 'xiaohong', age: 19},{id: 3, name: 'xiaoqiang', age: 22}] 3.filter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2957564e3ab8311f2ebaff04631833ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee61f7dde1f01338b7dd71645aa671ef/" rel="bookmark">
			Python操作mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库分类
关系型数据库：采用了关系模型来组织数据的数据库，如MySQL、PostgreSQL、Oracle数据库。
非关系型数据库：以键值对存储，且结构不固定，可以减少一些时间和空间的开销，如MongoDB、Redis。
二、Python操作MySQL环境安装
1、Docker部署MySQL：
1)创建数据库目录(略)
mkdir -p /opt/mysql/data 2)创建并运行MySQL容器
# -d 守护进程后台运行# -v 目录映射——挂载;作用是为了持久化# -e 环境变量# root用户密码设置为hl# -p 映射端口 端口默认3306# root账号的密码为hldocker run -d --name mysql -v /opt/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=hl -p 3306:3306 registry.cn-hangzhou.aliyuncs.com/sqqdcl/waimai-db 如果你想学习接口自动化测试，我这边给你推荐一套视频，这个视频可以说是B站播放全网第一的接口自动化测试教程，同时在线人数到达1000人，并且还有笔记可以领取及各路大神技术交流：798478386 https://www.bilibili.com/video/BV17p4y1B77x/?spm_id_from=333.337.search-card.all.clickhttps://www.bilibili.com/video/BV17p4y1B77x/?spm_id_from=333.337.search-card.all.click
2、安装pymysql库
#python访问MySQL，需要安装pymysql库pip install pymysql 3、Navicat配置连接数据库
三、Python操作MySQL
Python操作数据库的过程：创建连接-&gt;获取游标-&gt;执行命令-&gt;关闭游标-&gt;关闭连接
1、创建连接，连接数据库的参数按照实际情况添加
​​
import pymysql #定义一个函数，用来创建连接数据库 def mysql_db(): con = pymysql.connect( host='192.168.223.130', port=3306, database='mysql', charset='utf8', user='root', password='hl' ) if __name__ == '__main__': mysql_db() 2、获取游标，执行Sql，查询操作
import pymysql #定义一个函数，用来操作数据库 def mysql_db(): con = pymysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee61f7dde1f01338b7dd71645aa671ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca8b9599e25cf293970de8d08ad56a3/" rel="bookmark">
			spark外置external shuffle service使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shuffle是什么 shuffle是Hadoop大数据计算中，一个必不可少的环节，通过shuffle可以将不同节点上的同类数据给移动到一起，这在分组，排序，聚合的场景中非常常见，简单图示如下：
MapReduce数据处理模型假设数据以分布式方式存储在多台机器上，并以一些记录的形式组织起来。数据处理分 3 个阶段进行：
shuffle的三个阶段 Map阶段 使用用户自定义的映射函数，来对数据进行处理，这个阶段的主要目标是预处理和过滤数据，map函数会逐条处理数据集中的每一条数据，然后输出一组（K，V）集合，这里可以有三种情况：
不产生任何数据，也就是说数据被全部过滤掉或者数据源为空生成一个 （K，V）对，如果count，max，min，avg，sum等聚合函数生成多个 （K，V）对，如查询，去重，处理转换后的数据 Shuffle阶段 这个阶段所有的（K，V）对，也就是 map 阶段产生的所有键值对都按键排序并分布在集群中的机器上
Reduce阶段 对每个节点上的数据按照 K % (reduce number) 进行横跨节点的分发， reduce 函数计算每组具有相同键的键值对的最终结果。这样 K 相同的数据都会被 shuffle 到同一个节点，形成节点内局部有序的状态。如果想要全局有序，还需要在加一个 reduce 阶段，从而完成最终的排序
Spark中的shuffle 默认情况下，MR任务shuffle都是由当前任务内部完成的，也就是启动了一个spark job，这个job在内部就可完成整个shuffle流程，也就是实时对接的模式，类似快递小哥送快递给你，到你家楼下打电话给你，不见你面他就一直等着你，直到你来了之后，他把快递亲自交到你的手中，他才可以去干下一件快递的排送，这种模式就是默认shuffle的工作原理。
但缺点比较明显，就是资源利用率低，因为等你的途中，快递小哥什么都不能干，所以才有了快递代收点这种产物，在spark里面，可以专门部署一个内置或外置的独立的shuffle服务来处理shuffle数据，这样可以有几个优点：
1，提高资源利用率，
2，增加动态资源调度的弹性，避免开启了动态资源调度时，因为shuffle数据的占用，导致executor无法回收的问题，或者因为executor被回收了，造成shuffle数据被销毁，从而触发该子任务的重算流程
3，减少executor内部之间网络带宽和本地带宽的占用
外部独立的shuffle服务的存储可以不占用YARN内部的本地磁盘，使用独立的SSD磁盘或者SSD的云存储再配上100G的网络带宽来加速shuffle处理性能。
shuffle数据的存储 此外提交spark任务默认shuffle的存储目录为/tmp目录，如果worker节点上这个默认的存储目录的大小比较小，可以在
spark-defaults.conf中配置默认目录：
spark.local.dir /path/local/dir1,/path/local/dir1 或者在应用提交时增加参数：
spark-submit --conf "spark.local.dir=/path/to/local/dir" ... shuffle数据的回收 shuffle 数据的回收与应用的生命周期有关，当应用结束时一般会自动清理，当前某些情况下shuffle数据可能并不会被清理掉，这个时候我们需要编写脚本或程序来周期性的清理，spark中shuffle的清理的配置参数如下：
参数
默认值
解释
版本支持
spark.cleaner.periodicGC.interval
30min
控制触发垃圾收集的频率。
仅当弱引用被垃圾收集时，此上下文清理器才会触发清理。在具有大型驱动程序 JVM 的长时间运行的应用程序中，驱动程序几乎没有内存压力，这种情况可能偶尔会发生或根本不会发生。根本不清理可能会导致执行器在一段时间后耗尽磁盘空间
1.6.0
spark.cleaner.referenceTracking
true
启用或禁用上下文清理
1.0.0
spark.cleaner.referenceTracking.blocking
true
控制清理线程是否应阻塞清理任务（shuffle 除外，这是由 Spark.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fca8b9599e25cf293970de8d08ad56a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6ae3da277cc65a6c2eeee44db8c787/" rel="bookmark">
			intent.setAction功能及类别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用android系统自带功能时，我们要告诉android，我们要调用哪个功能，如何告诉呢，通过intent（意图）对象。
Intent it=new Intent();
it.setAction("android.intent.action.CALL");
it.setData(Uri.parse("tel:"+s_num));
startActivity(it);
下面把android中，常用的功能列出来。
1.从google搜索内容 Intent intent = new Intent(); intent.setAction(Intent.ACTION_WEB_SEARCH); intent.putExtra(SearchManager.QUERY,"searchString") startActivity(intent); 2.浏览网页 Uri uri = Uri.parse("http://www.google.com"); Intent it = new Intent(Intent.ACTION_VIEW,uri); startActivity(it); 3.显示地图 Uri uri = Uri.parse("geo:38.899533,-77.036476"); Intent it = new Intent(Intent.Action_VIEW,uri); startActivity(it); 4.路径规划 Uri uri = Uri.parse("http://maps.google.com/maps?f=dsaddr=startLat startLng&amp;daddr=endLat endLng&amp;hl=en"); Intent it = new Intent(Intent.ACTION_VIEW,URI); startActivity(it); 5.拨打电话 Uri uri = Uri.parse("tel:xxxxxx"); Intent it = new Intent(Intent.ACTION_DIAL, uri); startActivity(it); 6.调用发短信的程序 Intent it = new Intent(Intent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b6ae3da277cc65a6c2eeee44db8c787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a20fe2af1c0db7a44b0a26514256a1/" rel="bookmark">
			《深入浅出SSD：固态存储核心技术、原理与实战》----学习记录(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 传统数据存储介质有磁带、光盘等，但更多的是硬盘(HDD)。随着数据呈爆炸式增长，对数据存储介质在速度上、容量上有更高的要求。时势造英雄，固态硬盘(Solid State Disk，SSD)横空出世。SSD使用电子芯片存储数据，没有HDD的机械式部件，因此在速度、时延、功耗、抗震等方面，与HDD相比有碾压式优势。无论是个人存储，还是企业存储，都在逐渐用SSD取代HDD。大数据时代，SSD必将是主角。
第1章 SSD综述 SSD(Solid State Drive)，即固态硬盘，是一种以半导体闪存(NAND Flash)作为介质的存储设备。和传统机械硬盘(Hard Disk Drive，HDD)不同，SSD以半导体存储数据，用纯电子电路实现，没有任何机械设备，这就决定了它在性能、功耗、可靠性等方面和HDD有很大不同。
1.1 引子 SSD是一种以半导体为主要存储介质、外形和数据传输接口与传统的HDD相同的存储产品。目前主流SSD使用一种叫闪存的存储介质，未来随着存储半导体芯片技术的发展，它也可以使用更快、更可靠、更省电的新介质，例如3D XPoint、MRAM等。当前业界主要使用的还是闪存。
外观上，加上铝盒的2.5寸的SSD，和2.5寸HDD外观基本相同。除了有传统HDD的2.5寸和3.5寸的外观外，SSD还可以有更小的封装和尺寸，图1-2所示为M.2接口的SSD。
图1-2　SSD外观(左：2.5寸盘；右：M.2SSD) 图片来源于《深入浅出SSD：固态存储核心技术、原理与实战》
SSD是用固态电子存储芯片阵列制成的硬盘，主要部件为控制器和存储芯片，内部构造十分简单。详细来看，SSD硬件包括几大组成部分：主控、闪存、缓存芯片DRAM(可选，有些SSD上可能只有SRAM，并没有配置DRAM)、PCB(电源芯片、电阻、电容等)、接口(SATA、SAS、PCIe等)，其主体就是一块PCB，如图1-3所示。软件角度，SSD内部运行固件(Firmware，FW)负责调度数据从接口端到介质端的读写，还包括嵌入核心的闪存介质寿命和可靠性管理调度算法，以及其他一些SSD内部算法。SSD控制器、闪存和固件是SSD的三大技术核心。
图1-3　SSD结构 图片来源于《深入浅出SSD：固态存储核心技术、原理与实战》
存储介质按物理材料的不同可分为三大类：光学存储介质、半导体存储介质和磁性存储介质。光学存储介质，就是大家之前都使用过的DVD、CD等光盘介质，靠光驱等主机读取或写入。在SSD出现之前，个人和企业的数据存储还是HDD的天下，HDD是以磁性存储介质来存储数据的；SSD出现以后，采取的是半导体芯片作为存储介质。现在及未来技术变革最快和主要方向还是半导体存储，从图1-4可以看出，半导体存储介质五花八门，目前可以看得出的主要方向还是闪存、3D XPoint、MRAM、RRAM等
图1-4　存储介质分类 图片来源于《深入浅出SSD：固态存储核心技术、原理与实战》
1.2 SSD vs HDD 传统的HDD是“马达+磁头+磁盘”的机械结构，SSD则变成了“闪存介质+主控”的半导体存储芯片结构，两者有完全不同的数据存储介质和读写方式。对比如表1-1所示
表1-1　HDD vs SSD结构对比 表格来源于《深入浅出SSD：固态存储核心技术、原理与实战》
SSD和HDD物理结构的不同，如图1-5所示
图1-5　SSD vs HDD结构 图片来源于《深入浅出SSD：固态存储核心技术、原理与实战》
SSD与HDD相比具有如下优点
性能好：表1-2所示某两款SSD和HDD的对比，读写速度有从几倍到几百倍的差异，随机读写性能差异最为明显功耗低：工作功耗HDD为6～8W，SATA SSD为5W，待机功耗SSD可降低到毫瓦(mW)级别。关于功耗，业界定义有几类：峰值功耗(Peak Power)、读写功耗(Active Power)、空闲功耗(Idle Power)、省电功耗(启动SSD内部休眠，尽可能多地关掉不工作的硬件模块，专业上定义为Standby/Sleep Power和DevSleep Power)。HDD与SSD的功耗对比如表1-3所示，从SSD功耗分解来看，读写功耗主要消耗在闪存上。数据读取和写入并发在后端的闪存，闪存的单位读写功耗是决定性的抗震防摔：SSD内部不存在任何机械部件，相比HDD更加抗震。HDD是机械式结构，磁头和磁片之间发生跌落时接触碰撞会产生物理损坏，无法复原。SSD是电子和PCB结构，PCB加半导体芯片，跌落时不存在机械损伤问题，因此更加抗震和可靠。另外SSD对环境的要求没有HDD那么苛刻，更适合作为便携式笔记本、平板电脑的存储设备。从可靠性角度来看，物理上的损伤以及带来数据损坏的概率，SSD比HDD更低噪声：客观上，由于结构上没有马达的高速运转，SSD是静音的身形小巧百变：HDD一般只有3.5寸和2.5寸两种形式，SSD除了这两种，还有更小的可以贴放在主板上的M.2形式，甚至可以小到芯片级，例如BGA SSD的大小只有16mm×30mm，甚至可做得更小 表1-2　HDD与SSD性能对比 表格来源于《深入浅出SSD：固态存储核心技术、原理与实战》
表1-3　HDD与SSD功耗对比 表格来源于《深入浅出SSD：固态存储核心技术、原理与实战》
1.3 固态存储及SSD技术发展史 StorageSearch是一家专门讲述各大固态存储公司产品的网站，本节中SSD发展史大部分内容来自于该网站的一篇文章：http://www.storagesearch.com/chartingtheriseofssds.html
1 昂贵的RAM SSD时代 1976年，Dataram公司开始出售叫作Bulk Core的SSD，容量是2MB，使用了8块大电路板，每个板子有18个256KB的RAM。RAM的优点是可以随机寻址，就是每次可以只读写一个字节的数据，速度很快；缺点也很明显，掉电数据就没了，价格还巨贵。在以后的20多年时间里，TMS(Texas Memory Systems)、EMC、DEC等玩家不断推出各种RAM SSD
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78a20fe2af1c0db7a44b0a26514256a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4756f969434be4bbefaee0ea1a335038/" rel="bookmark">
			认证授权：OAuth2简介及四种授权模型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc]简介一、OAuth2 授权总体流程1.认证流程2.四种角色：3.四种授权模式 二、授权码模式（Authorization Code Grant）1.Client Side2.Server Side3.Check Access Token 三、隐式授权模式（Implicit Grant）Client SideCheck Access Token 四、密码模式（Resource Owner Password Credentials Grant）Client SideCheck Access Token 五、客户端模式（Client Credentials Grant）1.Server Side2. Check Access Token 六、授权模式的选型其他 简介 如今很多互联网应用中，OAuth2 是一个非常重要的认证协议，很多场景下都会用到它，Spring Security 对 OAuth2 协议提供了相应的支持。开发者非常方便的使用 OAuth2 协议
OAuth 是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源 （如头像、照片、视频等），并且在这个过程中无须将用户名和密码提供给第三方应用。通过令牌 （token） 可以实现这一功能。每一个令牌授权一个特定的网站在特定的时间段内允许可访问特定的资源。OAuth 让用户可以授权第三方网站灵活访问它们存储在另外一些资源服务器上的特定信息，而非所有的内容。对于用户而言，我们在互联网应用中最常见的 OAuth 应用就是各种第三方登录，例如 QQ授权登录、微信授权登录、微博授权登录、GitHub 授权登录等。
例如用户想登录 Ruby China ，传统方式是使用用户名和密码但是这样并不安全，因为网站会存储你的用户名密码，这样可能会导致密码泄露。这种授权方式安全隐患很大如果使用 OAuth 协议就能很好地解决这一问题。
oAuth2协议解决了多个网站登录问题，账号密码不安全的问题，比如一些小众的网站就可以不用注册登录，使用 oAuth2，也就是通过第三方向要访问的网站发送请求获取Token，第三方网站每次请求写到Token就可以访问到内容。
注意：OAuth2 是 OAuth 协议的下一个版本，但不兼容 OAth 1.0 ，OAth2 关注客户端开发者的简易性，同时为 Web 应用、桌面应用、移动设备、 IOT 设备提供专门的认证流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4756f969434be4bbefaee0ea1a335038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d592a8d34fe516bb016b655536af3104/" rel="bookmark">
			SQL死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
分析：
死锁产生的原因：
sql死锁
模拟：
解决办法： (本质：快速筛选或高效处理、以此减少锁冲突)
①大事务拆成小事务，尽可能缩小事务范围
大事务:将多个操作放在一个事务中执行
小事务：将多个操作分成多个小事务，
②业务中存在更新前和更新后一模一样的不再执行更新
3、 调整表修改的顺序
4. 索引不当导致的死锁
为什么建索引能有效避免死锁呢？
5、降低并发 6、重试机制
前言： 使用脚本刷数据时，开多线程经常遇到死锁现象，面试也经常问到，故开此篇
日志错误示例：
### Error updating database. Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction ### The error may exist in com/patpat/product/mapper/SaleProductSkuMapper.java (best guess) ### The error may involve com.patpat.product.mapper.SaleProductSkuMapper.updateById-Inline ### The error occurred while setting parameters ### SQL: UPDATE ps_sale_product_sku_XXXXX_30002 SET sku_id=?, product_id=?, sku_code=?, image=? WHERE id=?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d592a8d34fe516bb016b655536af3104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9118a75723b4489a6a0157107207819/" rel="bookmark">
			js 根据id取出数组中的对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var arr=[
{
id: 1,
name: 'a'
},
{
id: 2,
name: 'b'
},
]
var obj=arr.find(function (x) {
return x.id === 1
})
console.log(obj);//打印出来是{id:1,name:a }，之后根据自己的需求点出来就可以了。
也可能获取的是proxy包裹的
可以通过此方法转。
const Data = JSON.parse(JSON.stringify(record)); console.log(Data); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5338cef16e5f747a0d6caeb24f4bcf2/" rel="bookmark">
			【Paper】复现VideoMAE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复现VideoMAE 论文信息环境准备数据集准备Kinetics 400（152GB，不推荐）Something-Something-V2（19.4GB）UCF101 （约6.5GB） 论文信息 论文全名VideoMAE: Masked Autoencoders are Data-Efficient Learners for Self-Supervised Video Pre-Training
发表在NeurIPS 2022
论文链接 https://arxiv.org/abs/2203.12602v3
论文官方代码https://github.com/MCG-NJU/VideoMAE
paperwithcode链接https://paperswithcode.com/paper/videomae-masked-autoencoders-are-data-1
他们还在CVPR 2023上发表了最新的VideoMAE V2: Scaling Video Masked Autoencoders with Dual Masking，如果有时间我也会复现
环境准备 Python 3.6 or higher
PyTorch and torchvision.
We can successfully reproduce the main results under two settings below:
Tesla A100 (40G): CUDA 11.1 + PyTorch 1.8.0 + torchvision 0.9.0
Tesla V100 (32G): CUDA 10.1 + PyTorch 1.6.0 + torchvision 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5338cef16e5f747a0d6caeb24f4bcf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66bef497da75a00ca912a5e4b6d7a2f/" rel="bookmark">
			Helm 部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装前准备 官网：https://helm.sh/
想成功和正确地使用Helm，需要以下前置条件：
一个 Kubernetes 集群确定你安装版本的安全配置安装和配置Helm。Helm版本支持策略 ：https://helm.sh/zh/docs/topics/version_skew/ 使用Helm，需要一个Kubernetes集群。对于Helm的最新版本，我们建议使用Kubernetes的最新稳定版， 在大多数情况下，它是倒数第二个次版本。
您也应该有一个本地的 kubectl
开始安装Helm 用二进制版本安装 下载地址：https://get.helm.sh/helm-v3.12.1-linux-amd64.tar.gz
安装方法
tar -zxvf helm-v3.12.1-linux-amd64.tar.gz mv linux-amd64/helm /usr/local/bin/helm ## 安装还以后查看版本 helm version # version.BuildInfo{Version:"v3.12.1", GitCommit:"f32a527a060157990e2aa86bf45010dfb3cc8b8d", GitTreeState:"clean", GoVersion:"go1.20.4"} 常用命令 官网推荐的源：https://artifacthub.io/packages/search?kind=0
仓库管理 添加helm源
helm repo add bitnami https://charts.bitnami.com/bitnami 删除 helm 源
helm repo update 当添加完成，您将可以看到可以被您安装的charts列表：
helm search repo bitnami 查看所有添加过的源
helm repo list 更新源
helm repo update Helm的基本操作命令 查看helm的版本
helm version 查看环境变量
helm env 查看某一个chart 的所有版本
## 不加 -l 就是查询 helm search repo ingress -l 据关键字检索 chart 包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66bef497da75a00ca912a5e4b6d7a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290a9c5cf1a41dac2c13fdb626b73e0f/" rel="bookmark">
			关于C#BinaryReader类内部实现方法（扩展）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单了解内存流第一步（不懂可以翻我另一篇文章有解释） 假设目前我有一个数组A = {11，22，33}
我将他写入内存流中，
此时内存流内部存储的数据实际上是
3 // 数组的长度 11 // 第一个整数值 22 // 第二个整数值 33 // 第三个整数值 然后我们调用的时候binaryReader.ReadInt32()
第一次我们会获取的是3(长度)
然后我们再调用binaryReader.ReadInt32()
这就是第二次调用了，获取的就是11（相当于数组[0]）
下面是实际获取方法
int length = binaryReader.ReadInt32(); // 读取数组的长度 int[] intArray = new int[length]; // 创建一个长度为 length 的整数数组 for (int i = 0; i &lt; length; i++) { intArray[i] = binaryReader.ReadInt32(); // 读取数组中的每个整数值 } 扩展了解内存流第二步 假设目前我有一个数组A = {11，22，33}，数组B = {55，66，77}写入”内存流“中
此时我第一次调用获取方法的时候，只能获取A数组
binaryReader会记录获取的位置（下标）
这么说把，内存流内部实际存储的是3，11，22，33，3，55，66，77
我们在用上面的方法int length = binaryReader.ReadInt32(); // 读取数组的长度这样就不会读到第二个数组的了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/290a9c5cf1a41dac2c13fdb626b73e0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76a944fb54e027ad22cb27957ce40213/" rel="bookmark">
			实体类中Date 时间格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、第一种
@JSONField(format = "yyyy-MM-dd HH:mm:ss") private Date createTime; 直接获取插入数据库 ，获取方法：
(select now()::timestamp) String todayDate = DateUtil.format(new Date(),"yyyy-MM-dd"); 2、第二种
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8") private Date createTime; 获取时间方法：
Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String createTime = simpleDateFormat.format(date); Timestamp timestamp = Timestamp.valueOf(createTime); topicInfo.setCreateTime(timestamp); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff3d0d333c5037bc1c89f0547cf1a1a/" rel="bookmark">
			Python爬虫基础知识与项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Requests库
二、爬虫的Robots.txt
三、Beautiful Soup库
四、正则表达式
五、项目实战（佛系更新...)
一、Requests库 Requests库介绍：提交爬取请求并爬取html网页，返回可供解析的对象。http（hypertext transfer protocol）：超文本传输协议 ，采用url作为定位网络资源。 http://host[:port][path]
host：合法的Internet主机域名或IP地址
port：端口号，缺省端口为80
path：所请求资源的路径
http协议中对url的操作方法与requests库中的六个方法一致（获取、头信息、修改、删除）
3.Requests的七个主要方法
方法说明requests.request()构造爬虫请求，以下六个方法均自该方法基础上发展而来requests.get() 获取html页面
requests.head()获取html页面头信息requests.post()添加资源，重复执行，效果累加requests.put()更改资源，重复执行，覆盖重复字段requests.patch()向html页面提交局部修改请求，会更新原有资源requests.delete()向html页面提交删除请求 4.部分方法详解
4.1 requests.get()
r=requests.get(url,params=None, **kwargs) 返回url链接对应的内容，为Response对象，**kwargs是可选参数，可以是header等
Response对象的属性 属性说明r.status_code请求返回的状态，200表示链接成功r.text http响应内容的字符串形式，即url对应的内容
r.contenthttp响应内容的二进制形式r.encoding从http header中猜测的响应内容编码方式r.apparent_encodeing从http内容中分析出的响应内容编码方式 4.2post Vs put方法
二者都可以更改指定url的语义，但PUT被定义为idempotent的方法，即重复执行多次，产生的效果是一样的；POST则不是：
PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）
Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）
4.3 requests.request(method,url,**kwargs)
requests库的基础方法，其他皆由此发展而来
method：请求方式，对应七种方法get/head/post/put/patch/delete/options
**kwargs：控制访问的参数，13个，在方法中一致
参数数据类型功能params字典或字节作为参数增加到url中data字典或字节或文件对象作为Requests的内容反馈到服务器jsonJSON格式的数据作为Requests的内容反馈到服务器headers字典HTTP定制头信息，可用于更改用户（Mozilla/5.0），易于简单爬取cokkies字典或cokkie JarRequests中的cookieauth元组支持http的认证功能files字典 用于向服务器传输文件
ex：fs={‘file’：open('data.txt','rb')}
r=requests.request('POST',url,files=fs)
timeout数字，单位s设置超时时间，防止时间过长的无效爬取prixies字典设定访问代理服务器，可以增加登录认证（防止爬虫逆追踪）allow_redirects布尔默认True，重定向开关stream布尔默认True，获取内容后立即下载verify布尔默认True，认证SSL证书开关cert保证本地证书 路径 二、爬虫的Robots.txt 1.网络爬虫的限制
来源审查：检查来访http协议头的User-Agent域，只响应浏览器或友好爬虫访问，常可定义为
Mozilla/5.0 发布公告：Robots协议 ，建议遵守的爬取策略（哪些可以爬，哪些不能），一般位于网站根目录的robots.txt下。
2.在Robots协议中，#表示注释，*代表所有，/代表根目录
3.建议在进行 较大访问且访问频繁的爬虫时，遵守robots协议
三、Beautiful Soup库 from bs4 import BeautifulSoup（注意大小写），从bs4中引入BeautifulSoup类
Beautiful Soup库（bs4）是解析、遍历、维护“标签树”的功能库
BeautifulSoup类对应html/xml文档的全部内容，解析html如下：
soup=BeautifulSoup（r，’html.parser'）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff3d0d333c5037bc1c89f0547cf1a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c6d2d0d5b6121988d807b4d25d727f/" rel="bookmark">
			微信小程序获取用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在微信小程序中获取用户信息，你可以按照以下步骤进行操作：
1. 在小程序的app.json文件中添加"scope.userinfo"权限，例如：
```
"permission": {
"scope.userinfo": {
"desc": "你的个人信息"
}
}
```
2. 在小程序的某个页面中，使用wx.login方法获取用户登录凭证code，例如：
```
wx.login({
success: res =&gt; {
if (res.code) {
// 获取用户信息
} else {
console.error('获取用户登录态失败！' + res.errMsg)
}
}
})
```
3. 在获取用户登录凭证后，可以通过wx.getUserInfo方法获取用户信息，例如：
```
wx.getUserInfo({
success: res =&gt; {
const userInfo = res.userInfo;
console.log(userInfo)
},
fail: res =&gt; {
console.error('获取用户信息失败！' + res.errMsg)
}
})
```
在成功获取用户信息后，你可以将其保存到本地或发送给服务器进行处理。
需要注意的是，从2021年5月1日起，微信小程序要求使用用户信息需要进行用户授权，否则将无法获取到用户信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad143170b6508473b773afb89f50ec9/" rel="bookmark">
			使用el-tree实现不同区域的拖拽功能时遇到的坑点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题再现 利用el-tree实现在两个区域的拖拽，1.树上的拖拽排序，2.将树上节点拖拽到画布上。
在将节点拖拽到画布上的时候，只要在树上移动过，松开鼠标的时候，树上的拖拽排序功能也生效了，那么如何使这两个拖拽功能互斥呢？
解决思路1（不推荐） 拖拽到画布的时候，手动撤销树上上一次的排序，嫌麻烦（^^），不推荐
解决思路2（推荐） 鼠标落在那里就实现哪里的拖拽功能。
落在画布区域，就实现画布的拖拽；落在树上，就实现树上的排序功能。
那么问题来了，由于el-tree会记录最后一次的拖拽位置，那么移动到画布上松开鼠标的时候，树上的排序功能依旧会生效！！
解决方案：通过查看源码发现，el-tree里会有一个dragState变量来存储拖拽状态，拖拽到画布，松开鼠标的时候，把drag的状态值清空，那么树上的排序功能便被强制无法生效。
// 画布里的drop方法 // treeModel 是左侧的树形 onDrop(e) { ...... this.dragging = false; this.treeModel.dragState.dropNode = null; this.treeModel.dragState.draggingNode = null; this.treeModel.$el.querySelectorAll('.is-drop-inner').forEach(d =&gt; { d.classList.remove('is-drop-inner'); }); ..... } 至此，问题解决~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06efa86da2c8a2b957a5cf9240508f83/" rel="bookmark">
			【Linux基础及shell脚本】查看、安装、卸载软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. RPM方式2. Yum方式3. 源码编译方式4. 二进制安装方式 Linux系统下有多种方法来查看、安装和卸载软件，其中包括使用rpm、yum命令，通过源码编译安装以及使用二进制文件安装。每种方法都有其独特的优点和缺点，适用于不同的应用场景。
1. RPM方式 优点：可以在离线环境下安装软件。
缺点：无法自动解决软件依赖问题。
以下是一些常用的rpm命令：
安装软件：rpm -ivh升级安装，如果软件未装则新安装：rpm -Uvh更新安装，如果软件未装则不安装：rpm -Fvh卸载软件（使用--nodeps选项可以忽略依赖，强制卸载）：rpm -e查看软件是否安装：rpm -q查看软件的安装文件列表：rpm -ql查看软件的配置文件：rpm -qc查看命令文件由哪个软件安装的：rpm -qf 2. Yum方式 优点：可以自动解决软件依赖问题。
缺点：无法定制化安装。
Yum命令主要分为以下几个部分：
安装软件： 安装所有软件：yum install安装指定软件包：yum install package1安装程序组：yum groupinstall group1 更新和升级软件： 更新所有软件：yum update更新指定软件包：yum update package1检查可更新的程序：yum check-update升级指定软件包：yum upgrade package1升级程序组：yum groupupdate group1 查找和显示软件信息： 显示安装包信息：yum info package1显示所有已经安装和可以安装的程序包：yum list显示指定程序包安装情况：yum list package1显示程序组信息：yum groupinfo group1根据关键字查找安装包：yum search string 卸载软件： 删除程序包：yum remove | erase package1删除程序组：yum groupremove group1查看程序包依赖情况：yum deplist package1 清除缓存： 清除缓存目录下的软件包：yum clean packages清除缓存目录下的 headers：yum clean headers清除缓存目录下旧的 headers：yum clean oldheaders清除缓存目录下的软件包及旧 的headers：yum clean all
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06efa86da2c8a2b957a5cf9240508f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b81d59437b9820547880e1419ac2b5/" rel="bookmark">
			centos7解决update-grub无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 升级内核
yum install -y epel-release elrepo-release yum --enablerepo=elrepo-kernel -y install kernel-ml 设置默认启动内核报错
idx=$(awk -F "'" '$1=="menuentry " {print i++ " : " $2}' /etc/grub2.cfg | grep -iv Rescue | head -n 1 | cut -d' ' -f1) grub2-set-default $idx ​ cannot open file `/etc/grub2.cfg' for reading (No such file or directory) 概念 GNU GRUB（GRand Unified Bootloader简称“GRUB”）是一个来自GNU项目的多操作系统启动程序。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。
尝试 网上各种方法都尝试了，55555 都想放弃了 T_T
update-grub 在centos7下的update-grub命令等同效果的是：grub2-mkconfig -o /boot/grub2/grub.cfg 这个命令。
grub2-mkconfig grub2-tools-minimal 内核切换成功 解决步骤 https://mp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b81d59437b9820547880e1419ac2b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d9dc1914c28f573224b202f921d237/" rel="bookmark">
			UI还不错的视频播放器：GOMPlayerPlus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前给各位小伙伴们测试过一款叫【完美解码】开源的播放器，今天给各位同学测试了一款小编认为不错的UI视频播放器，大家也可以测试学习下，顺便也可以对比下看看是【完美解码】好用还是【GOMPlayerPlus】好用。
一、简单介绍 这款影音播放器是一款非常实用的软件，它内置了视频播放所需的解码器，并且占用系统资源很少。它通过查找解码功能来支持所有视频的播放，并且利用独特的技术来支持在线传输中的文件、传送中断的文件以及索引损坏的AVI文件的播放。
该播放器具有高度的定制性，用户可以自定义播放器的外观和功能。它还内置了强大的音视频解码器，可以解码各种视频和音频文件。即使遇到未知的媒体文件，该播放器也能自动查找并使用所需的解码器进行播放。这使得它成为一款非常强大的多媒体播放器，非常适合用户使用。
二、测试演示参数 演示操作系统：Windows 11
系统类型：64位
演示版本：v2.3.88.5358
三、基础演示 1、文件预览 截至目前的最新版本
​
2、解压学习 双击绿化处理开始学习
由于小编有常用的播放器，所以这里便选择不关联直接关闭了
​
完成后会在桌面创建一个快捷方式
​
3、页面预览 打开快捷图标，我们可以看到主页面，UI颜值开始可以的
​
4、查看设置 所有功能按钮，【鼠标悬停】都会显示按钮功能名称
​
设置界面的UI也感觉挺不错的
​
5、查看详细信息 和“完美解码”播放器一样，按【TAB键】可以查看视频详细信息
6、透明度演示 通过右上角的滑块可以调整视频窗口的透明度
7、最大音量测试 底部有个音量调节的滑块，通过测试发现最大支持调整的音量是150%
​
8、控制面板 通过右下角的按钮可以调出控制面板的设置窗口
​
9、菜单栏演示 第一种打开菜单栏的方法：通过点击左上角的logo图标打开
​第二种打开菜单栏的方法：右键视频任意区域即可打开
​
四、学习完之后卸载 学习完成之后我们需要卸载可以先【右键】找到【文件所在位置】，双击【!)卸载移除】彻底卸载工具
​
选择2的选项即可
​
五、下载学习 传送门1： http://ai95.microsoft-cloud.cn/d/9289114-56666788-4e914e?p=ai95
传送门2： https://jmj.cc/g/HuQZ0YqJ
（统一访问密码：ai95）持续更新......
--
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6b7d1ce7ec90df13222d589992c9b9/" rel="bookmark">
			LLDP 协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是LLDP LLDP（Link Layer Discovery Protocol，链路层发现协议）.它可以将本端的设备管理的地址 设备标识 接口标识等构成不同的TLV(Type/Length/Value，类型/长度/值)将其封装在LLDPDU（Link Layer Discovery Protocol Data Unit，链路层发现协议数据单元）中发给与自己直连的邻居，邻居收到这些信息后将其以标准MIB（Management Information Base，管理信息库）的形式保存起来，以供网络管理系统查询及判断链路的通信状况。
2. switch LLDP的四种工作模式 TxRx ：既发送也接收LLDPDU
Tx ：只发送不接收LLDPDU
Rx ：只接收不发送LLDPDU
Disable：既不发送也不接收LLDPDU
3. LLDP的报文格式（两种） Destination MAC address目的 MAC 地址，为固定的组播 MAC 地址 0x0180-C200-000ESource MAC address源 MAC 地址，为端口 MAC 地址或设备桥 MAC 地址（如果有端口地址则使用端口 MAC 地址，否则使用设备桥 MAC 地址）Type0x88CC（EthernetII） or 0xAAAA-0300-0000-88CC(SNAP)LLDPDULLDP数据是一组TLV,每个TLV都代表一个信息FCS（Frame Check Sequence） 帧校验序列。
4. LLDPDU 组成LLDPDU之前，设备先将本地信息封装成TLV（Type-Length-Value）格式，再由若干个TLV组合成一个LLDPDU封装在LLDP报文的数据部分进行传送。
LLDP协议规定每个LLDPDU共可携带28种TLV，且每个LLDPDU固定以Chassis ID
TLV、Port ID TLV和Time to Live TLV开始，以End of LLDPDU TLV为结束，这四个
TLV为必选的TLV，其他则为可选TLV.
5. TLV TLV是组成LLDPDU的最小单元，表示一个对象的类型、长度和信息。每个TLV代表设
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6b7d1ce7ec90df13222d589992c9b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea09b8df089edd77581d9f97d7bc0a9f/" rel="bookmark">
			js懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		懒加载的目的就是为了提高用户体验 降低服务器压力 有时候我们的内容很长很多 但是屏幕只有那么大一点 一次加载出来全部显然是不合适的 懒加载就是为了让页面显示在屏幕可视区域内再加载当前的数据 像大型购物网站都有这个操作
下面以图片懒加载举例说明懒加载的过程
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul { width: 1200px; list-style: none; margin: 0 auto; } .clearfix::after { content: ""; display: block; clear: both; } li { width: 23%; height: 200px; float: left; border: 1px solid #ccc; margin-bottom: 10px; margin-left: 10px; } img { width: 100%; height: 100%; } * { margin: 0; padding: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea09b8df089edd77581d9f97d7bc0a9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dfb619b11e4c77d56ce02027db093e1/" rel="bookmark">
			原生js分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近工作好忙 工作中也遇到了很多问题 也很久没有更新博客了 闲下来继续更新吧 大家一块学习
项目中要对数据进行分页处理 一般分页我们都用插件 比如elementui bootstrap之类的 但其实原生的我们也应该理解思路 理解思路有点代码功底自己也能调试出来
先看效果
上代码
样式
&lt;style&gt; .pager { padding: 0; margin: 0; white-space: nowrap; text-align: center; } .pager li { list-style: none; font-family: arial; font-size: 14px; padding: 2px; margin: 5px; border: #333 1px solid; text-align: center; border-radius: 5px; max-width: 80px; width: 25px; height: 22px; line-height: 22px; cursor: pointer; background: #fff; display: inline-block } .pager li:hover { border: #a11418 1px solid; color: #a11418; opacity: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dfb619b11e4c77d56ce02027db093e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6bf90e90b701465b8c8541927d2dcac/" rel="bookmark">
			Pythonnet：Python与.NET的无缝集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pythonnet是一个包，提供了与 .NET 公共语言运行时 (CLR) 近乎无缝的集成，为 Python 程序员和 .NET 开发人员提供了强大的应用程序脚本工具。它支持 Windows、Linux 和 macOS 上的 .NET Framework 和 .NET Core。Pythonnet允许将 .NET 程序集和命名空间导入为 Python 模块和包，以及从 Python 代码调用 .NET 方法和属性，反之亦然。它还支持 .NET 对象的动态类型和关键字参数，并与流行的 Python 库（如 numpy、pandas、matplotlib 等）良好集成。
其中，Pythonnet在网络爬虫领域具有广泛的应用场景。网络爬行是使用自动化程序从网站提取数据的过程。Python 是一种流行的网络爬行语言，但某些网站可能需要与 .NET 组件交互或访问 .NET API 来检索数据。在这种情况下，Pythonnet可以弥合 Python 和 .NET 之间的差距，使网络爬虫能够从 Python 代码访问 .NET 功能。例如，通过使用 Pythonnet，网络爬虫可以加载提供 Web 服务客户端或 Web 浏览器控件的 .NET 程序集，并与网站进行通信或呈现其内容。这样，Pythonnet可以利用 .NET 的强大功能来增强网络爬虫的功能和性能。
2023年高考分数已经公布，下面用程序采集各地录取分数线，首先需安装Python、Pythonnet和openpyxl库用于操作Excel文件，示例如下：
import clr import openpyxl import requests # 加载Pythonnet的clr模块 clr.AddReference("System") from System.Net import WebRequest, WebProxy # 亿牛云代理 # 设置爬虫代理加强版IP proxy_host = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6bf90e90b701465b8c8541927d2dcac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242b57901633eb9e1e3a2dd07ec938c0/" rel="bookmark">
			文本聚类之Supporting Clustering with Contrastive Learning（SCCL）论文复现【代码纠错及完善】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本聚类之Supporting Clustering with Contrastive Learning（SCCL）论文复现 前言一、论文介绍二、复现步骤1. 数据集下载及处理2. 数据预处理3. 安装依赖库3. 代码修改4. 运行结果 前言 近期想探索一些自己研究方向相关的领域，因而有了这篇文章，从图像的聚类到文本的聚类。本文的文本聚类更确切地说是短文本聚类（short text clustering），这是一个并不火热的方向，可以看到这篇论文是两年前发表的，SCCL是一篇很不错的工作。文本数据这块比较火热的是基于自监督、对比学习的NLP，聚类常被作为一个下游子任务，文本数据方面的主要任务还是学习文本的语义表征。不过，这个方向也未尝不是一个值得探索的方向（有着训练时间短，对显卡资源要求低的优点，算法稳定性强），没准哪天也像对比学习那样迎来一个春天。
一、论文介绍 论文名称：Supporting Clustering with Contrastive Learning，发表在NAACL会议上，在NLP领域也算是顶会吧。
论文链接：https://arxiv.org/abs/2103.12953
github地址：https://github.com/amazon-science/sccl
摘要：无监督聚类的目的是根据在表征(representation)中度量的距离发现数据的语义类别空间。然而，在学习过程的开始阶段，不同的类别往往在表征空间中相互重叠，这对基于距离的聚类在实现不同类别之间的良好分离提出了重大挑战。为此，本文提出了基于对比学习的支持聚类(SCCL)——一个利用对比学习来促进更好分离的新框架。并评估了SCCL在短文本聚类(short text clustering)上的性能，表明SCCL在大多数基准数据集上显著提高了达到SOTA的结果，准确率(ACC)提高了3% ~ 11%，规范化互信息(NMI)提高了4% ~ 15%。此外，定量分析证明了SCCL在利用自下而上的实例判别(instance discrimination)和自上而下的聚类优势方面的有效性，从而在使用ground truth聚类标签进行评估时获得更好的聚类内和聚类间距离。
二、复现步骤 本人复现代码已发布到github：https://github.com/Regan-Zhang/SCCL-EXEC
复现过程可参考sccl的github项目中的README.md文档，一般没有什么问题的话即可完成本节如下的第1步数据集下载及处理、第2步数据预处理、第3步依赖库的安装。
1. 数据集下载及处理 上图是SCCL原论文对数据集的数据集情况表一览。基于运行时间考虑，选取数据量适中的AgNews文本数据，余下部分本人也以AgNews为例进行讲解。
⋅ \huge · ⋅ 进入数据集网址:
https://github.com/rashadulrakib/short-text-clustering-enhancement/tree/master/data
然后点击红框处下载就可以啦。这些下载下来的都是原始文本数据，并没有经过处理和数据增强。
⋅ \huge · ⋅ 下载下来后文件名为agnewsdataraw-8000.txt，将其后缀名改成csv，当然这里我是改成了agnewsdataraw.csv，命名看读者喜好可以自己定义但是后缀名一定要为csv！
⋅ \huge · ⋅ 用WPS或者Excel打开csv文件，不出意外的话只有一列数据，label标签和text文本数据糊成一片。不过不要紧，这是因为直接打开csv文件而没有通过源导入定义格式导致的。只要重新导入文件即可。导入过程都在下面（其实也可以新建一个空的csv文件再导入源）：
如果不新建的话在原来csv文件操作就需要把光标放到第一个单元。
⋅ \huge · ⋅ 点击“数据”–&gt;“导入数据”–&gt;“导入数据”–&gt;选择“直接打开数据文件”–&gt;“选择数据源”，选中我们的agnewsdataraw.csv进行导入。
⋅ \huge · ⋅ 选择编码，没有尝试过其他，最常见编码是GBK和UTF-8，此处我选择UTF-8，这样不容易出错。
⋅ \huge · ⋅ 选择分隔符号，下一步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242b57901633eb9e1e3a2dd07ec938c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5a5536059ee6ade019f6343f2b45c8/" rel="bookmark">
			对模型进行量化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置模型计算精度：
weight_dtype = torch.float32 model.to(device, dtype=weight_dtype) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4126a71146ef0a7338814b0f1deebbd2/" rel="bookmark">
			使用Python进行逻辑回归建立评分卡的完整示例代码，包括数据预处理、分箱、特征工程、共线性剔除、模型评估和信用评分规则制定的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说直接上代码：
import pandas as pd import numpy as np from sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score, roc_auc_score from statsmodels.stats.outliers_influence import variance_inflation_factor # 1. 数据准备和预处理 data = pd.read_csv('credit_data.csv') # 读取数据集，假设包含特征变量和目标变量 data.dropna(inplace=True) # 处理缺失值 X = data.drop('default', axis=1) # 特征变量 y = data['default'] # 目标变量 # 2. 分箱（Binning） # 对连续型特征进行分箱操作，将其转化为离散型变量。 # 这里以年龄（age）为例，将其分为5个箱子（bins）。 # 可以根据实际业务需求和统计分析来确定分箱方案。 X['age_bin'] = pd.cut(X['age'], bins=[0, 18, 30, 40, 50, float('inf')]) # 3. 特征工程 # 根据业务需求选择合适的特征变量，并进行编码等处理。 # 例如，对性别（gender）进行二值化编码 X['gender'] = X['gender'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4126a71146ef0a7338814b0f1deebbd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027323040ebf8147d6c8528aab6fb3cd/" rel="bookmark">
			UE5 与 C&#43;&#43; 入门教程·第一课：角色与 Enhanced Input
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要围绕 UE5 新的输入系统，手把手从 0 搭建 Unreal 项目，实现角色的基础移动。
重要提示：众所周知，C++ 属于编译型语言，因此动态灵活性不足，不过执行效率高，而蓝图简单灵活，却执行效率低。因此推荐一种开发方式—— 用 C++ 创建基类，蓝图继承 C++ 的基类 ，获得一种折衷的优势。
开发工具：Visual Studio 2022Unreal 版本：5.2.1 创建项目 新建一个基于 C++ 的空项目。File -&gt; New Level（或者 Ctrl + N），建立一个 Basic 关卡，保存到新建的 Levels 文件夹中；Edit -&gt; Project Settings… -&gt; Project -&gt; Maps &amp; Modes 里将 Editor Startup Map 和 Game Default Map 设置为新建的关卡。 角色资产 这里选用的 Epic 商城里的免费资产，Paragon: Lt. Belica。目前用的版本是（写的时候的最新的版本） 5.2.1，目前 Belica 还不支持这个版本，选一个最近的版本 5.1 添加到项目中。
创建一个 Character 类 正如开头所说，我们希望获得一种相对优势，因此会用 C++ 作为父类，项目中实际使用的时候用创建蓝图类继承自 C++。对于简单的参数和功能就可以在蓝图上定制，对于通用或核心的功能或方法则可以在上级 C++ 类中实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/027323040ebf8147d6c8528aab6fb3cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d12323e468ad4d6de067097627fe592c/" rel="bookmark">
			usb转8路串口模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源USB转8路串口PCB设计 文章目录 开源USB转8路串口PCB设计1. 简介2. 说明3. 一种跨电脑跨USB口的端口号自动识别方法4.开源地址 今天给大家介绍一款USB转8路串口的PCB设计，并提供一种跨电脑跨USB口的端口号自动识别方法。 1. 简介 芯片采用沁恒的CH348Q，不需要写程序，其中4路串口支持流控，另外的4路不支持。
开发板设计如下：
原理图：
pcb图：
3d图：
2. 说明 基于沁恒的CH348Q芯片设计的usb转8路串口模块，不需要额外的程序，同时支持win系统和linux系统，驱动已经放到立创附件中。每一路串口都有指示灯，增加使用的方便性。因为我平时就是用这个工具调程序，因此我usb接口使用的TYPE-B接口，这样的接口更耐用也跟那个稳定。开发板每路串口都带有TX、RX指示灯，这样在调试的时候就会非常方便。开发板另外还有两颗指示灯，一个是power，用来指示设备上电，另一个是ACT，用来指示CH348q可以正常工作，当驱动未安装，ACT不会亮，表明CH348q不可以正常工作，当驱动安装好，ACT会亮起，表示设备可以正常工作。 产品实物图如下：
3. 一种跨电脑跨USB口的端口号自动识别方法 在平时我们使用的usb转串口模块，按照更换usb口串口号是否会改变分为usb口改变设备和usb口不改变设备(其实根本原因是支持)。
比如我们常使用的ch340，它就是一款更换usb口后，会重新生成COM口编号的设备，这种设备的优点是对于大部分PC是免驱的, 缺点是当电脑同时接入多个串口，需要挨个插拔来确定端口号。
比如我们常用的cp21xx，它就是一款更换usb口后，依旧会沿用上一次端口号的设备，这种设备的优点是在更换usb口后不需要在从新确认端口号，方便了，缺点是需要驱动，因此在linux上使用的时候，一定要确保有驱动。
但是不管上面的哪一种，当跨PC来接入的时候，谁也保证不了COM不会发生改变。这样其实就有一个问题，当我们写了一个上位机程序的时候，我们必须留出一个可以设置COM口的地方，因为当存在多个COM的时候，程序无法自动识别，需要用户指定,那这样对于那些自动化测试、无人值守项目就会很崩溃。下面我们讲解使用CH348完美解决这个问题的方法。
我们先分析一下实现的原理，我们将设备插入电脑，然后打开的猫猫串口助手(推荐使用的一个串口助手)，下载链接，当点击串口号的时候，在输出测输出了这8个串口，如下：
我们会发现这8个串口都有对应的名字，如WCH USB-SERIAL Ch B (COM26)中，COM26就是com口，前面那一段就是串口的名字，巧合的是在不同的电脑上，com口可能不同，但是名字是相同的，如：这WCH USB-SERIAL Ch A、B、C、D、E、F、G、H对应的就是8个串口的名字，这些名字和开发板上面的串口一一对应，正如我画的pcb那样，我画的PCB，不是写的串口1、串口2，而是以ABCDEFGH来定义串口的，现在我们使用python来自动找到A串口对应的端口号：
# 通过串口的名称找到对应的串口，并打开 # pip install pyserial import serial import serial.tools.list_ports # 举例：比如我们要查找WCH USB-SERIAL Ch A对应的端口号 my_serial_1 = "WCH USB-SERIAL Ch A" if __name__ == "__main__": pass # 判断存在用户输入的串口 ports = list(serial.tools.list_ports.comports(include_links=False)) # 打印所有的port if not ports: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d12323e468ad4d6de067097627fe592c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ffa6e3088a1323f0d93c1ead25453d7/" rel="bookmark">
			专业CPU信息检测工具：CPU-Z
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天小编为大家测试了一款轻量级的CPU处理器的测试工具，可以查看CPU的详细信息，以供各位同学们学习。
一、简单介绍 CPU-Z是一款非常流行的CPU检测软件，被广大用户所熟知。它是目前最受欢迎的CPU检测软件之一，除了Intel和AMD自带的检测工具外，我们最常使用的就是它了。它支持几乎所有类型的CPU，而且启动和检测速度都非常快。此外，它还能提供主板和内存的相关信息，其中包括我们常用的内存双通道检测功能。
二、测试演示参数 演示操作系统：Windows 10
系统类型：64位
演示版本：v2.06.0
演示显卡：Intel Core i7-9700K CPU 3.60GHz
三、开始测试学习 1、文件详情 从文件详情可以看出学习工具非常小巧
2、主页面 这是打开后的显卡信息主界面
​
3、处理器 很遗憾，CPU-Z没有像GPU-Z那样鼠标悬停显示详细内容
在次选项卡中可以看到cpu的详细信息
规格中可以看出主频是3.6GHz的，而超频后达到了4598.90MHz
​
4、内存 内存信息选项卡可以看出我们是否组了双通道，以及规格类型和频率等
​
5、SPD 这个选项卡中可以看到内存条的详细信息
6、显卡 在显卡选项卡中，可以看到显卡的基础信息
​
7、测试 在测试选项卡中，我们可以把自己的CPU处理器和其它处理器比较进行参考，以下便是小编把自己的处理和I9-13900K进行比较的结果
​
8、关于 这里可以看到工具作者和版本等信息
四、下载学习 传送门1：http://ai95.microsoft-cloud.cn/d/9289114-56661118-8f2968?p=ai95
传送门2：https://jmj.cc/s/tllgxn
（统一访问密码：ai95）持续更新......
--
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dbff87c0d95165c626e6b9187dfe68e/" rel="bookmark">
			如何与西门子200 PLC建立连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更多关于西门子S7-200PLC内容请查看：西门子200系列PLC学习课程大纲
与西门子200 PLC建立连接很简单，分为以下几步：
1.给S7-200PLC通电 按下图1-1所示连接PLC端口，然后给PLC供电，有直流24V和交流220V两种供电方式，注意：进行连接时一定要断开电源再操作，避免身体受到电击。
图 1-1 PLC供电图
2.连接RS-232/PPI多主站电缆 如图2-1所示，通过PPI电缆将PLC端口1或0连接到电脑的串口或者USB口。
图 2-1 PPI电缆连接
3.打开STEP 7-Micro/WIN软件 如下图3-1所示，打开STEP 7-Micro/WIN软件的界面，可以点击左边红框里的通信图标来设置PLC的通信参数。
图 3-1 STEP 7-Micro/WIN软件的界面
4.设置STEP 7-Micro/WIN与PLC的通信参数 5.与S7-200建立通信 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06b5486b966eb0d31f2867c75a28622/" rel="bookmark">
			Redis为什么快？（面试常问）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis是一个开源的高性能内存数据库，特点是数据存储在内存中，操作时性能更高；还支持多种数据结构，String、Hash、list、set、zset等，key还支持自动过期。Redis的好处是因为数据存在内存中所以性能更高，还有因为是单线程操作，所以天然具有线程安全的特性，单线程又能避免多线程的频繁上下文切换问题。 Redis的坏处也是因为数据存储在内存中，内存在重启后就会消失，所以会有数据丢失的问题。 Redis本身提供了两种备份策略，一种是RDB，每5min进行一次全量的快照备份，另一种是AOF，每1s进行一次增量备份，在实际使用时是结合使用，就是使用RDB每5分钟进行一次快照备份，然后在两次快照之间使用AOF进行备份。这样做的好处是可以避免AOF文件过大。虽然Redis提供了备份策略保障不丢失，但是在实际业务中我们也还会在Mysql中保存一份数据做持久化的存储，因为Mysql的好处就是数据存储在磁盘上服务重启也不会丢失。
总结来讲就是：
1.Redis（内存操作）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。
2.（单线程，省去线程切换、锁竞争的开销）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
3.（NIO 的 IO 多路复用模型）使用多路 I/O 复用模型，非阻塞 IO；这里“多路”指 的是多个网络连接，“复用”指的是复用同一个线程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b104671034eeb456ffaac5114cfdc9b1/" rel="bookmark">
			多模态大模型系列论文（ALBEF、BLIP、BLIP-2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ALBEF: ALign the image and text BEfore Fusing 1.1 论文与代码链接： ​​​​​​https://arxiv.org/abs/2107.07651 GitHub - salesforce/ALBEF: Code for ALBEF: a new vision-language pre-training method 1.2 目标任务： 视觉-文本 融合任务，如图文检索、视觉问答、NLVR （natural language vision reasoning）等
1.3 当前方法问题： 1）没有对齐视觉的 tokens 和 文字的 tokens, 因此给 多模编码器进行图文交互学习时带来挑战
2）训练多模模型，利用到了互联网上爬取的数据，这些数据中往往存在大量噪声，传统的图文特征融合训练模式（如 MLM, masked language modeling） 可能过拟合到噪声文本上，从而影响模型的泛化性能。
1.4 本文解决方案： 1） 通过跨模态 attention 的方式引入对比损失，在图文特征融合前对齐图像和文本表征，相对与大多数传统方案来说，不需要在高清图片上进行框级别的标注。
2）提出一种 动量蒸馏 （momentum distillation） 的方案，即通过自训练(self-training)的方式从动量模型提供的伪标签中进行学习。
在训练过程中，通过参数移动平均的方式更新动量模型，并利用动量模型生成伪标签(pseudo-targets) 作为额外的监督信息。利用动量蒸馏的方式，模型将不在惩罚模型合理的输出，即使这个输出与网络标签不一致，提升从网络噪声数据中学习的能力。
1.5 实验结果： 1）在图文检索任务中，本方案优于在大规模数据集中预训练的方案（CLIP &amp; ALIGN）
2) 在 VQA 和 NLVR 任务中，本方案相对 SOTA 算法（VILIA）分别获得了 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b104671034eeb456ffaac5114cfdc9b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a97a239fbf8907b6199b672f7577b7/" rel="bookmark">
			【MySql】用户管理——用户管理|权限管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 用户管理用户信息创建用户删除用户修改用户密码 数据库的权限给用户授权回收权限 用户管理 如果我们只能使用root用户，这样存在安全隐患。这时，就需要使用MySQL的用户管理。 比如张三只能操作mytest这个数据库，李四只能操作msg这个数据库，而root可以操作所有的库，如果给他们root账户，风险太大了，数据库都能操作，所以我们需要对用户进行管理。
用户信息 MySQL中的用户，都存储在系统数据库mysql的user表中，我们来查看一下：
**对于上面字段所代表的意思如下：**我们来看一看👇
host： 表示这个用户可以从哪个主机登陆，如果是localhost，表示只能从本机登陆
user： 用户名
authentication_string： 用户密码通过password函数加密后的
*_priv： 用户拥有的权限
创建用户 创建用户的语法如下：
create user '用户名'@'登陆主机/ip' identified by '密码'; 我们可以来举个例子：我们来创建用户hwc并且设置密码为123456，sql语句如下：
create user 'hwc'@'localhost' identified by '123456'; **此时大概率是创建失败的，因为mysql本身的认证等级比较高，一些简单的密码无法设置，所以我们需要去设置密码等级：**对于mysql密码等级的设置我们可以看一看一些文档介绍，这里就不多做阐述了。
**最终创建成功，实际上，创建的用户其实就是在user表中插入数据：**我们来看一看user表中多了一条数据：
此时便可以使用新账号新密码进行登陆啦 ，登陆前先flush privileges;此时就登录成功了
创建一个可以远端登录的账号 %表示所有地方可以登陆的用户 create user 'zhangsan'@'%' identified by '123456'; 进行远程登录：登录成功
注意：如果连接失败了，建议查看一下默认端口3306是否能够连接：
telnet +ip 3306 如果不能连接，关掉防火墙即可以远程登录：
删除用户 drop user '用户名'@'主机名' 举个例子：
drop user hwc@localhost; 修改用户密码 自己改自己密码：
set password=password('新的密码'); root用户修改指定用户的密码
set password for '用户名'@'主机名'=password('新的密码'); 举个例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a97a239fbf8907b6199b672f7577b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000a08c6e26f524c803d7bb13b70d053/" rel="bookmark">
			服务器内部服务器错误的原因和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是内部服务器错误？内部服务器错误是服务器无法完成请求时生成的响应代码。它表明服务器出现问题，无法满足请求。此错误消息以网页形式显示给用户，显示“500 Internal Server Error”或类似内容。
内部服务器错误的原因服务器上发生内部服务器错误的原因有多种。一些最常见的原因包括：
脚本错误：脚本中的错误，例如语法错误或不正确的文件权限，可能会导致内部服务器错误。
资源耗尽：当服务器耗尽资源（例如内存或处理能力）时，可能会导致内部服务器错误。
配置问题：配置问题，例如不正确的设置或配置错误的软件，可能会导致内部服务器错误。
服务器软件错误：服务器软件中的错误可能导致内部服务器错误。
DDoS攻击：分布式拒绝服务(DDoS)攻击会使服务器过载，导致其崩溃并显示内部服务器错误。
内部服务器错误的解决方案要解决内部服务器错误，您可以采取以下几个步骤：
检查错误日志：解决内部服务器错误的第一步是检查错误日志。这将提供有关错误原因的信息，并可以帮助您确定最佳操作方案。
重新加载页面：有时，只需重新加载页面即可解决问题。这是因为服务器可能暂时不堪重负，无法完成请求。
增加服务器资源：如果服务器内部错误是由资源耗尽引起的，增加服务器可用资源可以解决问题。
更新服务器软件：将服务器软件更新到最新版本可以解决可能导致内部服务器错误的任何错误。
检查配置：如果内部服务器错误是由配置问题引起的，请检查配置设置以确保它们正确无误。
缓解DDoS攻击：如果内部服务器错误是由DDoS攻击引起的，您可以实施安全措施来缓解攻击并防止其再次发生。
结论对于网站或应用程序来说，内部服务器错误可能是一个令人沮丧和破坏性的问题。但是，通过了解错误的原因并采取必要的步骤来解决它，您可以将影响降到最低并防止它在将来再次发生。无论是增加服务器资源、更新软件还是缓解DDoS攻击，都有多种解决方案可帮助解决内部服务器错误并保持您的网站或应用程序顺畅运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6705c2de31f6a06a3f51769cf19bc031/" rel="bookmark">
			深度学习-大模型LLM-微调经验分享&amp;总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大型语言模型横行，之前非常焦虑，现在全面拥抱。目前也有很多开源项目进行大模型微调等，笔者也做了一阵子大模型了，特此来介绍一下ChatGLM-6B模型微调经验，并汇总了一下目前开源项目&amp;数据。笔者与很多人微调结论不同，本人在采用单指令上进行模型微调，发现模型微调之后，「并没有出现灾难性遗忘现象」。
项目地址：https://github.com/liucongg/ChatGLM-Finetuning
ChatGLM-6B模型微调 模型越大对显卡的要求越高，目前主流对大模型进行微调方法有三种：Freeze方法、P-Tuning方法和Lora方法。笔者也通过这三种方法，在信息抽取任务上，对ChatGLM-6B大模型进行模型微调。为了防止大模型的数据泄露，采用一个领域比赛数据集-汽车工业故障模式关系抽取(https://www.datafountain.cn/competitions/584)，随机抽取50条作为测试集。
详细代码见上面的GitHub链接，并且也被ChatGLM官方收录。
Freeze方法 Freeze方法，即参数冻结，对原始模型部分参数进行冻结操作，仅训练部分参数，以达到在单卡或不进行TP或PP操作，就可以对大模型进行训练。
微调代码，见finetuning_freeze.py，核心部分如下：
for name, param in model.named_parameters(): if not any(nd in name for nd in ["layers.27", "layers.26", "layers.25", "layers.24", "layers.23"]): param.requires_grad = False 针对模型不同层进行修改，可以自行修改。训练代码均采用DeepSpeed进行训练，可设置参数包含train_path、model_dir、num_train_epochs、train_batch_size、gradient_accumulation_steps、output_dir、prompt_text等，可根据自己的任务配置。
CUDA_VISIBLE_DEVICES=0 deepspeed finetuning_freeze.py --num_train_epochs 5 --train_batch_size 2 三元组抽取的推理代码，见predict_freeze.py，其他任务可以根据自己的评价标准进行推理预测。
PT方法 PT方法，即P-Tuning方法，参考ChatGLM官方代码(https://github.com/THUDM/ChatGLM-6B/blob/main/ptuning/README.md) ，是一种针对于大模型的soft-prompt方法。
P-Tuning(https://arxiv.org/abs/2103.10385)，仅对大模型的Embedding加入新的参数。
P-Tuning-V2(https://arxiv.org/abs/2110.07602)，将大模型的Embedding和每一层前都加上新的参数。
微调代码，见finetuning_pt.py，核心部分如下：
config = ChatGLMConfig.from_pretrained(args.model_dir) config.pre_seq_len = args.pre_seq_len config.prefix_projection = args.prefix_projection model = ChatGLMForConditionalGeneration.from_pretrained(args.model_dir, config=config) for name, param in model.named_parameters(): if not any(nd in name for nd in ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6705c2de31f6a06a3f51769cf19bc031/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/babcf2a1c12a3c69f56d41a553323955/" rel="bookmark">
			docker内使用nvidia-smi命令提示No devices were found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.关闭容器
2.运行systemctl stop docker
3.运行systemctl start docker
不要使用systemctl restart docker，没效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de858db246aeaa5d4f82868c3d9cc6ad/" rel="bookmark">
			简单分享在微信上怎么实现分销功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序分销开发怎么做？在如今的电商市场中，小程序分销成为了一种新兴的销售模式，通过分销模式，商家能够借助分销商的力量提高销售额，同时分销商也能不用投入大量资金和时间，就能在小程序上进行销售。那么，小程序分销开发怎么做呢？如果你也想知道的话，就跟着小编一起来探讨吧！
1、什么是小程序分销
小程序分销是一种新型的移动端分销方式，它可以帮助企业快速开发小程序，并通过分销渠道将小程序推广给更多的用户。小程序分销具有许多优势，例如：
1. 快速开发。可以使用现有的小程序开发工具快速开发一个小程序。
2. 推广方便。通过分销渠道，可以将小程序推广给更多的用户。
3. 成本低廉。由于小程序开发成本相对较低，因此可以节省开发成本。
4. 易于维护。小程序的代码相对简单，因此可以轻松维护小程序。
2，怎么做小程序分销功能
市面上通常会采用代码开发以及在线商城搭建平台两种方式来完成对于小程序分销的开发制作，在设计的自由度上，代码开发的方式更胜一筹，但与此同时开发周期长且费用高，相对来说更适合大型企业，如果对于小程序分销开发的要求不是特别高的同时希望能有一些自己的特色，也可以通过在线商城搭建平台的方式进行小程序分销的创建，相比于其他方式，它所需花费的资金少且开发周期短，通过对平台上的模板进行选择后进行具体内容的修改并对功能进行增添就可以实现快速搭建。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd24ac2d93b87872491c923518ae09cb/" rel="bookmark">
			如何利用微信小程序生成小程序码实现分销功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序申请配置之类的就不多做赘述了,今天主要介绍一下实现分销的核心内容。
该功能的核心地方就在于，使用微信小程序生成小程序码。而该小程序码中就是带有用户标识参数的，接下来一起来揭开生成带参小程序码的面纱吧。
具体代码如下：
public function getWxAcCode() { $wx = new WxAction(); $token = $wx-&gt;getAccessToken();//获取accesstoken //整理post请求参数 $post_data = [ 'scene' =&gt; '用户id',//场景值 可以理解成用户标识 但是存在限制(文档中有说明) 'page' =&gt; '页面路径 path',//小程序的页面路径 特别注意该路径要与小程序内定义的路径一致测试时不要添加否则会生成不了 最最重要的是路径之前不要有斜杠/ 直接以pages开头否则会提示41030 'is_hyaline' =&gt; true //生成的小程序码图片背景是否为透明的 ]; $data = json_encode($post_data, true); //请求地址 $url = 'https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token='.$token; $accode = $wx-&gt;sendPost($url,$data);//获取小程序二维码 返回的就是图片流信息 $img = $this-&gt;cutPictureCircular('微信头像地址');//获取圆形头像流信息 $qrcode = $this-&gt;mergeImages($accode,$img);//加上头像的小程序码图片流信息 $qrcode = imagecreatefromstring($qrcode); // 读取背景图的信息 $tmp = file_get_contents('./bg.png'); $bg = imagecreatefromstring($tmp); // 将小程序码合并到海报图上 imagecopyresampled($bg, $qrcode, 225, 630, 0, 0, 285, 285, imagesx($qrcode), imagesy($qrcode)); header("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd24ac2d93b87872491c923518ae09cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1d87cf52931437311986e45a14ae65/" rel="bookmark">
			Jmeter压测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、登陆压测 1、首选查看登记接口，查看网址、请求方式、请求参数格式 等等
2、根据接口信息，在Jmeter中设置http请求
如果使用文件上传的，需要勾选“对POST使用multipart/form-data”
3、添加监听器，查看结果数。
code 200 表明请求成功
4、设置线程数
线程数：虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个线程数。
Ramp-Up Period(in seconds)准备时长：设置的虚拟用户数需要多长时间全部启动。如果线程数为 10，准备时长为 2，那么需要 2 秒钟启动 10 个线程，也就是每秒钟启动5 个线程。
循环次数：每个线程发送请求的次数。如果线程数为 10，循环次数为100，那么每个线程发送 100 次请求。总请求数为 10*100=1000 。如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。
Delay Thread creation until needed：直到需要时延迟线程的创建。
调度器：设置线程组启动的开始时间和结束时间(配置调度器时，需要勾选循环次数为永远)
持续时间（秒）：测试持续时间，会覆盖结束时间
启动延迟（秒）：测试延迟启动时间，会覆盖启动时间
启动时间：测试启动时间，启动延迟会覆盖它。当启动时间已过，手动只需测试时当前时间也会覆盖它。
结束时间：测试结束时间，持续时间会覆盖它。
5、启动压测，查看分析结果
上图执行了10的并发数，循环执行2次，汇总报告如下：
样本数总共为20次请求，每秒10的并发数，平均请求耗时198毫秒，最小请求耗时148毫秒，最大请求耗时259毫秒，异常请求为0，吞吐量可达到每秒15.6次请求，平均每秒能接收服务器响应数据10.38KB，平均每秒向服务器发送数据680KB.
二、CSV 数据文件设置 1、设置用户定义的变量
2、配置元件中，添加CSV数据文件
3、新建txt文件，参数之间用逗号隔开
4、设置csv
文件名：csv文件路径
文件编码：utf-8
编码名称：设置的变量名
5、执行，查看结果。 三、报错异常处理： 如果发现如下报错：
需要在信息头管理器中，设置请求参数格式：
如果发现如下报错：
检查是否在JSON格式下勾选了文件/form表单格式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9271db8fd02a05cd58b676fc9f9b3946/" rel="bookmark">
			转行做TA（技术美术），需要掌握哪些基础知识？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TA的岗位职责 负责美术与程序之间的沟通，配合实现美术效果，提高画面整体表现力制定美术资源规范，提高导出资源的可用性和规范性快速跟进研发最新的游戏引擎与渲染技术；在性能优化的同时，提高游戏画面表现；通过工具大量减少或杜绝资源出错概率；减少程序与美术沟通成本，疑难杂症快速解决定位。 TA分类 在这里，根据技术美术的方向分为以下类：
（技术美术分类）
基础知识 技术美术需要掌握一些基础知识，包括但不限于以下内容：
（技术美术的基础知识）
熟悉3D建模软件和工作流程，例如Maya、3ds Max、Blender等，了解建模、UV展开、材质贴图等技能。 建模：技术美术师需要掌握建模技巧，例如使用多边形（polygon）、NURBS曲线和曲面等技术来创建模型。此外，他们还需要了解如何使用布尔运算、切割和变形等工具来修改模型。UV展开：在3D建模中，UV展开是将一个3D模型表面的纹理坐标映射到一个2D纹理图像上的过程。技术美术师需要掌握如何正确和高效地展开UV，以便在制作纹理时得到更好的结果。材质贴图：技术美术师需要了解如何使用纹理来给模型赋予颜色和纹理。这包括了解不同类型的纹理（如漫反射、高光、法线、置换等），以及如何使用图像编辑软件（如Photoshop）来创建和编辑纹理。 总之，掌握3D建模技能是技术美术师的基本要求之一。通过不断的练习和实践，技术美术师可以提高自己的建模技能，并创造出更加精细、逼真的游戏模型。掌握纹理制作技术，例如Photoshop等软件的使用，了解基本的纹理制作技巧以及贴图优化等知识。 纹理的类型和格式：包括普通纹理、法线纹理、高光纹理等。此外，在选择纹理格式时，需要考虑到系统的存储、加载和渲染等方面的性能。图像处理软件的使用：例如Photoshop等软件，掌握基本的图像编辑技术，包括色彩调整、选择、涂抹、滤镜等操作。纹理制作技巧：这包括纹理应用的基本原理和技巧，例如平铺、拉伸、旋转、投射等。在纹理制作过程中，预处理步骤是非常关键的，例如纹理的平滑、压缩、消除锯齿等操作，都能够有效地提高纹理质量。贴图优化技术：这包括优化纹理的内存占用和加载速度等方面。例如纹理压缩技术、纹理合批技术、纹理缓存技术等，都能够有效地提高渲染效率。了解基本的渲染知识，例如灯光设置、相机设置、渲染器的使用等。 灯光设置：了解不同类型的灯光（如点光源、聚光灯、方向光等）以及它们如何影响场景中的物体。学习如何设置灯光的亮度、颜色、投射阴影等属性，以获得所需的照明效果。相机设置：掌握如何调整相机的焦距、拍摄角度、景深等参数，以确保渲染出的图像清晰、逼真且符合要求。渲染器的使用：了解不同类型的渲染器（如Arnold、V-Ray、Mental Ray等）以及它们在渲染图像时的不同特点和优缺点。学习如何使用渲染器的不同功能和参数，以获得所需的渲染效果。材质设置：学习如何为场景中的物体设置不同的材质（如金属、玻璃、布料等），以获得更逼真的渲染效果。纹理贴图：学习如何将不同的纹理（如木纹、石纹、皮革纹等）应用到场景中的物体上，以增加细节和真实感。掌握基本的编程和脚本语言，例如Python、MEL、MaxScript等，能够编写简单的脚本程序提高工作效率。对计算机图形学有一定的了解，包括3D数学、计算机图形学基础知识等。 对于3D数学，主要包括以下几个方面的知识： 3D坐标系：通常采用右手坐标系，x轴向右，y轴向上，z轴向外。向量运算：包括向量加减、点积、叉积等操作。矩阵运算：包括矩阵加减、矩阵乘法、矩阵变换等操作。三角函数：包括正弦、余弦、正切等常见函数的计算。在了解以上3D数学知识的基础上，在计算机图形学中还需要掌握以下基础知识： 二维图形学：包括图形的表示、绘制、变换等操作。三维图形学：包括三维图形的建模、变换、投影、光照模型等操作。图像处理：包括图像的处理、增强、滤波、边缘检测等操作。渲染技术：包括光线追踪、光栅化、阴影计算、反射和折射等操作。熟悉游戏引擎，例如Unity、Unreal等，了解游戏引擎的工作原理和基本操作。对美术设计有一定的认知，例如色彩、构图、造型等基础知识。 其他能力 除了基础能力之外，技术美术还需要具备以下这些能力：
产品理解和分析能力：对项目有一个全面的理解和分析，才能更好的把控项目的技术实现；
项目管理和协调能力：与团队成员和产品经理有良好的沟通能力，保证项目能够高效完成；
沟通能力：能够与其他技术人员和艺术人员进行沟通合作，并能够听懂和准确传达需求。
学习资源 总结一些TA（技术美术）学习的网站：总结一些TA（技术美术）学习的网站 - 知乎浅墨的游戏编程：浅墨的游戏编程 - 知乎CatlikeCoding——Jasper大神的Unity系列教程：https://catlikecoding.com/unity/tutorials/【教程】TA技术美术学习体系框架 （别再买垃圾教程了）：https://www.bilibili.com/video/av77755500/?vd_source=22ac463724c2768d793a58cdf02a8153《Unity Shader 入门精要》 书籍购买链接：当当网源代码： GitHub - candycat1992/Unity_Shaders_Book: 书籍《Unity Shader入门精要》源代码
Unity ShaderLab 官方文档： Unity - Manual: ShaderLab: defining a Shader object (unity3d.com)
结语
以上就是关于 TA的一些基础知识，TA的知识多而杂，建议先找到某个重心进行深度学习，切勿贪多嚼不烂。技术美术需要掌握一系列技术和美术方面的知识，需要有不断学习和提升的意识。通过不断学习和实践，可以逐渐提高自己的技术水平和创作能力。
“愿你以渺小启程，以伟大结束”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd2b80146f53b0bc63d499cef261d06/" rel="bookmark">
			【MySql】MySql视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 视图概念基本使用创建视图修改视图对基表有影响修改基表对视图有影响删除视图 视图规则和限制OJ题目 视图概念 视图就是一张虚拟表，其内容由查询定义。与真实的表一样，视图包含一系列带有名称的列和行数据。视图的数据变化影响到基表，基表的数据变化也会影响到视图。
基表就是数据库中实际存储数据的表，它是视图的数据来源。
基本使用 创建视图 create view 视图名 as select语句； 举例子：内连接emp表与dept表，然后创建视图myview，sql语句如下：
create view myview as select ename,dname from emp inner join dept on emp.deptno=dept.deptno; 进行查看：此时表myview的数据如下
myview说白了就是把select查出来的东西变成了临时表结构，放在表之中，这个表就是视图。好处就是获取一些高频访问的数据时，不用在做多表查询了，直接以视图的方式查看即可。
修改视图对基表有影响 举个例子：
update myview set ename='smith' where ename='SMITH'; 此时查看基表如下：
修改基表对视图有影响 举个例子：修改基表dept
update dept set dname='HWC' where deptno=30; 此时查看视图myview:也被修改了
删除视图 drop view 视图名； 举个例子：删除myview的视图
drop view myview; 视图规则和限制 与表一样，必须唯一命名（不能出现同名视图或表名）
创建视图数目无限制，但要考虑复杂查询创建为视图之后的性能影响
视图不能添加索引，也不能有关联的触发器或者默认值
视图可以提高安全性，必须具有足够的访问权限
order by 可以用在视图中，但是如果从该视图检索数据 select 中也含有 order by ,那么该视图中的 order by 将被覆盖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd2b80146f53b0bc63d499cef261d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e41f5372eb6c52834741f42c91bac9/" rel="bookmark">
			【VulnHub系列】BrokenGallery
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为是从PDF转换过来偶尔可能会出现内容缺少，可以看原版PDF：有道云笔记 实验信息 Broken：192.168.10.111
Kali：192.168.10.106
实验过程 sudo arp-scan --interface eth0 192.168.10.1/24 然后对靶机进行端口探测 nmap -sT -p- --min-rate 1000 192.168.10.111 -oA ./Broken_result 再对端口进行详细扫描和漏洞扫描
cat Broken_result.nmap | grep "open" | awk -F '/' '{print $1}' | paste -sd ',' sudo nmap -sT -sC -sV -p 22,80 192.168.10.111 -oA ./detail 详细扫描发现80端口有几个文件
后台挂着gobuster来跑目录
sudo gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 20 -u http://192.168.10.111/ -x txt,rar,zip,tar,sql,php 打开80端口，发现文件都wget保存到本地,查看网页源码以及文件来收集信息
xdg-open img_forest.jpg 查看REAMD.md的文件类型，是txt类型
用cat发现都是十六进制的字节码
-r选项用于将十六进制格式转换回二进制格式 -p表示输出纯粹的十六进制编码，而不包括其他信息 -s选项用于跳过文件的前N个字节 通过strings来读二进制文件，通过head来读取前几行内容来确定文件类型
-r选项用于将十六进制格式转换回二进制格式 -p表示输出纯粹的十六进制编码，而不包括其他信息 -s选项用于跳过文件的前N个字节 xxd -r -ps README.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e41f5372eb6c52834741f42c91bac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20de647d45a6e100dc25d877cfd3555c/" rel="bookmark">
			springboot&#43;mysql核酸检测信息管理系统-计算机毕业设计源码19832
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着社会的发展，社会的各行各业都在利用信息化时代的优势。计算机的优势和普及使得各种信息系统的开发成为必需。
核酸检测信息管理系统，主要的模块包括查看首页、站点管理（轮播图、公告栏）用户管理（管理员、注册用户）内容管理（健康资讯、资讯分类）更多管理（疫苗分类、疫苗信息、疫苗预约、核酸信息、接种疫苗、核酸预约、检测结果、留言反馈、用户信息）等功能。系统中管理员主要是为了安全有效地存储和管理各类信息，还可以对系统进行管理与更新维护等操作，并且对后台有相应的操作权限。
要想实现核酸检测信息管理系统的各项功能，需要后台数据库的大力支持。管理员验证注册信息，收集的用户信息，并由此分析得出的关联信息等大量的数据都由数据库管理系统管理。本文中数据库服务器端采用了Mysql作为后台数据库，使Web与数据库紧密联系起来。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
本系统的开发使获取核酸检测信息管理系统信息能够更加方便快捷，同时也使核酸检测信息管理系统管理信息变的更加系统化、有序化。系统界面较友好，易于操作。
关键词：核酸检测信息管理系统；springboot；Mysql
Spring boot nucleic acid vaccine reservation system
Abstract
With the development of society, all walks of life in society are taking advantage of the advantages of the information age. The advantages and popularity of computers make the development of various information systems necessary.
The main modules of nucleic acid testing information management system include viewing the home page, site management (rotation chart, bulletin board), user management (administrator, registered user), content management (health information, information classification), more management (vaccine classification, vaccine information, vaccine reservation, nucleic acid information, vaccination, nucleic acid reservation, testing results, message feedback, user information), and other functions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20de647d45a6e100dc25d877cfd3555c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3042e6487c98fc32d778703d894d8b/" rel="bookmark">
			基于Vue2.X对WangEditor 5富文本编辑器进行封装与使用，支持单个或多个图片点击、粘贴、拖拽上传，Vue3.X项目也可直接使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直想要一个神奇多功能的富文本编辑器，经同事介绍这个 WangEditor 富文本编辑器，发现挺好用的。
传送门：wangEditor
于是用Vue2.X语法自行封装一下，这样在复用组件时，可以少写一些代码，直接组件引用即可。另外，Vue3.X项目也可直接使用，因为Vue3.X是兼容Vue2.X语法的。
注意：如果反复创建与销毁该组件，记得用上v-if
&lt;WangEditor ref="wangEditorRef" v-if="isShowWangEditor" :disabled="editorParams.isDisabled" :editorParams="editorParams"&gt; &lt;/WangEditor&gt; 导入依赖包，注意Vue2.X和Vue3.X项目导入的依赖包版本会有所不同
// 查看 @wangeditor/editor 版本列表 npm view @wangeditor/editor versions --json // 导入 @wangeditor/editor 依赖包 npm i --save @wangeditor/editor@5.1.15 // 查看 @wangeditor/editor-for-vue 版本列表 npm view @wangeditor/editor-for-vue versions --json // 导入 @wangeditor/editor-for-vue 依赖包 npm i --save @wangeditor/editor-for-vue@5.1.12 父组件：index.vue
&lt;template&gt; &lt;div style="padding: 100px"&gt; &lt;WangEditor ref="wangEditorRef1" :disabled="editorParams1.isDisabled" :editorParams="editorParams1"&gt; &lt;/WangEditor&gt; &lt;br/&gt; &lt;WangEditor ref="wangEditorRef2" :disabled="editorParams2.isDisabled" :editorParams="editorParams2"&gt; &lt;/WangEditor&gt; &lt;br/&gt; &lt;p align="center"&gt; &lt;el-button type="primary" @click="handleSubmitClick"&gt;完成&lt;/el-button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import WangEditor from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3042e6487c98fc32d778703d894d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9584ee8a3f131c22b1bce8a96feb9414/" rel="bookmark">
			显卡检测工具：GPU-Z
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天小编为大家测试了一款轻量级的GPU显卡的测试工具，可以查看GPU的详细信息，以供各位同学们学习。
一、简单介绍 GPU-Z是一款方便实用的软件工具，专门为用户提供视频卡和GPU的详尽信息。它具有轻巧的特点，不需要安装即可使用，并且可以一键自动查询当前电脑的显卡参数。通过GPU-Z，用户可以轻松了解显卡的各种信息参数，而且结果页面简洁明了，让用户更加容易掌握显卡的相关信息。
二、测试演示参数 演示操作系统：Windows 10
系统类型：64位
演示版本：v2.54.0
演示显卡：NVIDIA GeForce RTX 2060 SUPER
三、开始测试学习 1、文件详情 从文件详情可以看出学习工具非常小巧
​
2、启动界面 这是启动中的界面
​
3、主页面 这是打开后的显卡信息主界面
​
把鼠标【悬停在名词信息框内】可以【查看名词详细信息】
4、传感器 可以在此选项卡中查看显卡频率、温度、风扇速度等信息
​
和上文中讲到的一样，把鼠标【悬停在名词信息框内】可以【查看名词详细信息】
​
5、高级选项卡 高级选项卡点击下拉菜单可以查看更多的详细信息
​
可以选择我们想要了解的信息
​
6、截图功能 右上角的【相机】按钮是截图功能
​
7、刷新功能 右上角【旋转】按钮是刷新功能
​
8、设置界面 右上角【三横杠】是设置界面
​
一般设置中可以设置开机自启、语言、更新等功能
​
传感器中可以设置活动监测等功能
​
好了，同学们有兴趣也可以试试学习下哦
四、下载学习 传送门1：
http://ai95.microsoft-cloud.cn/d/9289114-56647672-e231e6?p=ai95
传送门2：
https://jmj.cc/s/3uqlu0
（统一访问密码：ai95）持续更新......
--
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a08ee7a2a2958c910b8a42946e1b9dbd/" rel="bookmark">
			【Twitter爬虫】Twitter网络爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用selenium爬取Twitter 从2月9日起，Twitter不再支持免费访问Twitter API，继续使用Twitter API支付较高的费用。下面将介绍一种绕过Twitter API爬取推文的方式
Selenium Webdriver框架 首先介绍一下Selenium Webdriver，这是一款web自动化测试框架，可以利用它在web浏览器上模拟。下面演示下在python中如何引入selenium模块
from selenium import webdriver 实例化配置对象
options = webdriver.ChromeOptions() 配置对象开启无界面模式
options.add_argument("--headless") 实例化带有配置对象的driver对象
driver = webdriver.Chrome('chromedriver', options=options) 进入Twitter页面 Twitter首页 Twitter首页
driver.get('https://twitter.com/home') 登陆Twitter 先在网页上登陆自己的twitter账号，然后把cookies取出来并
cookies=[] #你的cookies for cookie in cookies: driver.add_cookie(cookie) 接下来就可以自由访问twitter啦
爬取Twitter url = f"https://twitter.com/search?q=hello&amp;src=typed_query" driver.get(url) 利用BeautifulSoup对网页进行分析
from bs4 import BeautifulSoup html = driver.page_source soup = BeautifulSoup(html, "html.parser") F12查看网页源码，可以看到每条推文的内容都写在红框标出来的区域里面
因此，我们先找出所有为这个属性的元素
tweets = soup.find_all("div", {'data-testid': "cellInnerDiv"}) 然后我们再继续找推文内容的属性
提取推文内容
for tweet in tweets: content = container.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a08ee7a2a2958c910b8a42946e1b9dbd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/70/">«</a>
	<span class="pagination__item pagination__item--current">71/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/72/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>