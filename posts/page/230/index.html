<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec76a2f6b25f3a5ff3e0d53dbc745e22/" rel="bookmark">
			移动端适配第二弹！Flexible实现H5页面的终端适配！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/doseoer/p/5545546.html
头部文件
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="yes" name="apple-touch-fullscreen"&gt; &lt;meta content="telephone=no,email=no" name="format-detection"&gt; &lt;script src="http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js"&gt;&lt;/script&gt; /*使用阿里CDN*/ &lt;link rel="apple-touch-icon" href="favicon.png"&gt; &lt;link rel="Shortcut Icon" href="favicon.png" type="image/x-icon"&gt; &lt;title&gt;H5适配头部&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 页面结构写在这里 --&gt; &lt;/body&gt; &lt;/html&gt; css(px)-&gt;(rem) sublime插件
CSSREM
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62408fa4d443f0089be7b4a895f43b87/" rel="bookmark">
			springmvc 利用AOP实现多数据源动态切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多数据源说白了就是项目里连接多个数据库；常见于分库查询(主从库)，分库操作-增删改查(多库多表)等。
下面说下具体步骤：
1.配置db.properties文件 pay.jdbc.url=jdbc:mysql://192.168.0.2:3306/pay?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC pay.jdbc.password=root pay.jdbc.username=root model.jdbc.url=jdbc:mysql://192.168.0.2:3306/model?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC model.jdbc.password=root model.jdbc.username=root 2.1在spring配置文件中配置多个数据源 &lt;!-- 配置数据源 使用的是Druid数据源 --&gt; &lt;bean name="dsPay" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="${pay.jdbc.url}" /&gt; &lt;property name="username" value="${pay.jdbc.username}" /&gt; &lt;property name="password" value="${pay.jdbc.password}" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="${pool.initialSize}" /&gt; &lt;!-- 连接池最大使用连接数量 --&gt; &lt;property name="maxActive" value="${pool.maxActive}" /&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="${pool.minIdle}" /&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="${pool.maxWait}" /&gt; &lt;property name="poolPreparedStatements" value="${pool.poolPreparedStatements}" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="${pool.maxPoolPreparedStatementPerConnectionSize}" /&gt; &lt;!-- 用来检测有效sql --&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62408fa4d443f0089be7b4a895f43b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acfd5d6818ff4d02820804ac81daa513/" rel="bookmark">
			Python 单引号、双引号和三引号混用时一定要注意！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 单引号、双引号和三引号混用时一定要注意！！！ 写在前面一、都是正则表达式惹二、在代码中理解吧（很简单的，看看就知道了）（1）单引号 （2）双引号 （3）三单引号和三双引号 三、总结 写在前面 在练习爬虫时，单引号和双引号在一起使用，结果就出问题了，特此去深入解了一下单引号、双引号和三引号的用法。
一、都是正则表达式惹 正则表达式： 用 r'&lt;li class=" j_thread_list clearfix"(.*?)=".*?' 去匹配 &lt;li class=" j_thread_list clearfix" data-field="{&amp;quot;id&amp;quot;:6244983838,&amp;quot;author_name&amp;quot;:&amp;quot;AOTEMAN\u51f9\u51f8\u6f2b&amp;quot;,&amp;quot;author_nickname&amp;quot;:null,&amp;quot;author_portrait&amp;quot;:&amp;quot;6bd6414f54454d414ee587b9e587b8e6bcabdeb3&amp;quot;,&amp;quot;first_post_id&amp;quot;:127388914159,&amp;quot;reply_num&amp;quot;:44,&amp;quot;is_bakan&amp;quot;:null,&amp;quot;vid&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;is_good&amp;quot;:null,&amp;quot;is_top&amp;quot;:null,&amp;quot;is_protal&amp;quot;:null,&amp;quot;is_membertop&amp;quot;:null,&amp;quot;is_multi_forum&amp;quot;:null,&amp;quot;frs_tpoint&amp;quot;:null}" data-tid="6244983838" data-thread-type="0" data-floor="1" '=""&gt; 时，匹配结果： data-field='{&amp;quot;id&amp;quot;:6244983838,&amp;quot;author_name&amp;quot;:&amp;quot;AOTEMAN\u51f9\u51f8\u6f2b&amp;quot;,&amp;quot;author_nickname&amp;quot;:null,&amp;quot;author_portrait&amp;quot;:&amp;quot;6bd6414f54454d414ee587b9e587b8e6bcabdeb3&amp;quot;,&amp;quot;first_post_id&amp;quot;:127388914159,&amp;quot;reply_num&amp;quot;:44,&amp;quot;is_bakan&amp;quot;:null,&amp;quot;vid&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;is_good&amp;quot;:null,&amp;quot;is_top&amp;quot;:null,&amp;quot;is_protal&amp;quot;:null,&amp;quot;is_membertop&amp;quot;:null,&amp;quot;is_multi_forum&amp;quot;:null,&amp;quot;frs_tpoint&amp;quot;:null}' data-tid='6244983838' data-thread-type 问题：为什么不在之前的“ =" ”就停下来呢？ 由此走上了疯狂搜索单引号和双引号区别的不归路。。。。。。其实挺简单。 二、在代码中理解吧（很简单的，看看就知道了） （1）单引号 代码食用：.
# -*- coding:utf-8 -*- import re # 单引号中有单引号和双引号，即 'AAA"BBB"\'CCC"DDD"' # str1 是单引号（'）包裹的一个字符串，其里面有3个双引号（"），其中有1个单引号（'），但由于最外层是单引号，所以此时该单引号需要用到转义字符（\）转义 str1 = 'a="aaa" b="bbb" \' c="ccc"' pattern1 = re.compile('="',re.S) pattern2 = re.compile('=\"',re.S) pattern3 = re.compile("='",re.S) pattern4 = re.compile("=\'",re.S) result1 = re.findall(pattern1,str1) result2 = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acfd5d6818ff4d02820804ac81daa513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b476da4dbda159906df30023055481/" rel="bookmark">
			Oracle中的insert/insert all/insert first
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle中的insert/insert all/insert first
1、概念
Oracle 中insert all 是指把 同一批 数据插入到 不同的表 中。
假如，现在有个需求，把表 t 的中数据分别插入到 t1、t2，如果你不知道 insert all， 你可能会使用 insert 插入 2 次，例如：
INSERT INTO t1(object_id, object_name) SELECT * FROM t;
INSERT INTO t2(object_id, object_name) SELECT * FROM t;
COMMIT;
其实，以上这样的写法，不一定正确。在 两次 insert 过程中， 有可能 t 表的数据发生了改变，从而导致 t1、t2 表得到的数据不一样，正确的写法是用 insert all
INSERT ALL
INTO t1(object_id, object_name)
INTO t2(object_id, object_name)
SELECT * FROM t;
COMMIT;
1.1 思维导图
1.2 基础数据
DROP TABLE stu; -- if exists
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b476da4dbda159906df30023055481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afd487cee8d8c5eeccbfb916d36cb01/" rel="bookmark">
			Unet简明代码实现眼底图像血管分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unet是一种自编码器网络结构，常用于医学图像分割任务，比如眼底图像血管分割。这位大佬已经开源了非常棒的代码，但是这套代码比较复杂，我初学菜鸟硬是啃了好几天才啃下来。现在我代码进行重写，仅保留最必要的部分，并尽量简明，全部代码不到100行，便于初学者快速看懂能用。
1.任务简介 本任务基于DRIVE数据集，将眼底图像中的血管树给分离出来。DRIVE数据集包含40张眼底图像，尺寸为565×584，其中20张为训练集，20张测试集，40张图片都给出了专家标注结果。数据集下载可自行百度，或者官网下载。
本代码包含以下几个部分：
数据加载及预处理：把图片分割成若干48×48的小图片，由于原图尺寸不能被48整除，这里先把原图尺寸resize为576×576。和大佬开源代码不同，这里没有使用随机选取的方式，而只使用原图分割出来的全部小图，相当于没有用数据增强，这样总共得到训练集2880个，训练精度比原作者使用190000个稍低一些，但训练速度会快很多，便于快速运行和调参。如果需要提高精度，可自行设计数据增强方法。
Unet模型：模型输入的张量形状为（？,1,48,48），输出为（？,2340,2）。？表示训练集的样本数，本例中为2880。
训练：把原作者代码中的SGD改为Adam，效果有提升。
推理：也需要先把待预测图像分割成48×48的小图，输入模型，然后把结果整理还原为完整图像，再和专家标注结果进行对比。代码中以测试集第一张图片为例，可自行修改为其他眼底图片路径。
2.完整代码 import numpy as np import cv2 from PIL import Image import matplotlib.pyplot as plt import os from keras.models import Model from keras.layers import Input, concatenate, Conv2D, MaxPooling2D, UpSampling2D, Reshape, core, Dropout from keras.optimizers import Adam, SGD from keras.callbacks import ModelCheckpoint, LearningRateScheduler from keras import backend as K img_x, img_y = (576, 576) dx = 48 filelst = os.listdir('DRIVE/training/images/') filelst = ['DRIVE/training/images/'+v for v in filelst] imgs = [cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7afd487cee8d8c5eeccbfb916d36cb01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed50244df2627f716799a4d969223f6/" rel="bookmark">
			java.net.SocketException: Broken pipe (Write failed)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果程序不重启，到第二天就会报这个错，根据网上说的，调整mysql的连接时间，我们数据库连接的mycat，mysql的间隔时间已经调整到了24个小时，还是报错：
[2019-09-04 15:33:06,196] (BaseJdbcLogger.java:142) DEBUG [pool-1-thread-2] jdbc.BaseJdbcLogger (BaseJdbcLogger.java:142) - ==&gt; Prep aring: select workorder_number as workorderNumber, sp_code as spCode, create_date as createDate from CONSISTENCY_WORK_SP_RANGE WHERE workorder_number=? [2019-09-04 15:33:06,196] (BaseJdbcLogger.java:142) DEBUG [pool-1-thread-2] jdbc.BaseJdbcLogger (BaseJdbcLogger.java:142) - ==&gt; Param eters: 2(Integer) org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: The last packet successfully received f rom the server was 169,794,818 milliseconds ago. The last packet sent successfully to the server was 169,795,024 milliseconds ago.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ed50244df2627f716799a4d969223f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4b1c5d958fd1be42501e79d936010c/" rel="bookmark">
			一条SQL语句在MySQL中如何执行的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章会分析一个 sql 语句在 MySQL 中的执行流程，包括 sql 的查询在 MySQL 内部会怎么流转，sql 语句的更新是怎么完成的。
在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。
MySQL 基础架构分析 MySQL 基本架构概览 下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。
简单来说 MySQL 主要分为 Server 层和存储引擎层：
Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
连接器： 身份认证和权限相关(登录 MySQL 的时候)。
连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。
主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。查询缓存: 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。 连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。
MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。
所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。
MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。
分析器: 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb4b1c5d958fd1be42501e79d936010c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94120923a7f455ec51fbfed77800ae98/" rel="bookmark">
			数组也是对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组是什么？ 数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引（下标）来访问它们。
数组的四个基本特点：
长度是确定的。数组一旦被创建，它的大小就是不可以改变的。其元素的类型必须是相同类型，不允许出现混合类型。数组类型可以是任何数据类型，包括基本类型和引用类型。数组变量属于引用类型，数组也是对象。 对象是什么？ 首先什么是对象呢？可谓是万物皆对象，对象是客观存在的事物，可以说任何客观存在的都是可以成为对象，一台电脑，一直钢笔，一个人，一辆轿车等等，都是可以成为对象。
对象：对象是人们要进行研究的任何事物，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。对象具有状态，一个对象用数据值来描述它的状态。对象还有操作，用于改变对象的状态，对象及其操作就是对象的行为。对象实现了数据和操作的结合，使数据和操作封装于对象的统一体中。
为什么数组是对象？ 数组变量属于引用类型，数组也是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f639507f5c6ed752df3b7b456526aa/" rel="bookmark">
			vue学习中遇到的错误 Duplicate keys detected: &#39;[object Object]&#39;. This may cause an update error.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端入门自学，说错的请大神指点。
Avoid using non-primitive value as key, use string/number value instead.
Duplicate keys detected: ‘[object Object]’. This may cause an update error.
运行后出现这些警告，意思是检测到重复的键值。
把:key里 的值改成以下两种情况之一就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df5da7e140d720a548295d2cd2fc00d/" rel="bookmark">
			Qt：正确判断文件、文件夹是否存在的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QFileInfo fi("C:/123"); // 目录存在 qDebug() &lt;&lt; fi.isFile(); // false qDebug() &lt;&lt; fi.isDir(); // true qDebug() &lt;&lt; fi.exists(); // true qDebug() &lt;&lt; fi.isRoot(); // false qDebug() &lt;&lt; QFile::exists("C:/123"); // true qDebug() &lt;&lt; QDir("C:/123").exists(); // true fi.setFile("C:/ABC"); // 目录不存在 qDebug() &lt;&lt; fi.isFile(); // false qDebug() &lt;&lt; fi.isDir(); // false qDebug() &lt;&lt; fi.exists(); // false qDebug() &lt;&lt; fi.isRoot(); // false qDebug() &lt;&lt; QFile::exists("C:/ABC"); // false qDebug() &lt;&lt; QDir("C:/ABC").exists(); // false fi.setFile("C:/"); // 存在的驱动器 qDebug() &lt;&lt; fi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1df5da7e140d720a548295d2cd2fc00d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5259011f23b97987bbc4774679c759d/" rel="bookmark">
			面相对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象 表格结构和类结构：“表格思维”就是一种典型的面向对象思维。
“表格思维”就是一种典型的面向对象思维。在面向对象编程中，下面三句话大家记住：
表结构对应：类结构一行数据对应：一个对象表中所有数据对应：这个类的所有对象
面向对象：对应面向对象就分别称为面向对象分析（OOA）、面向对象设计（OOD）和面向对象编程（OOP）。面向对象(Oriented-Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？” 面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。
“将相关数据和相关方法封装到一个独立的实体”，于是“对象”产生了。
 对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。
 在内存上，对象就是一个内存块，存放了相关的数据集合！
对象的本质就一种数据的组织方式！
面向过程：
面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。 面向对象和面向过程：  都是解决问题的思维方式，都是代码组织的方式。
 面向过程是一种“执行者思维”，解决简单问题可以使用面向过程。
 面向对象是一种“设计者思维”，解决复杂、需要协作的问题可以使用面向对象。
 面向对象离不开面向过程：
 宏观上：通过面向对象进行整体设计
 微观上：执行和处理数据，仍然是面向过程。。
对象和类： 类就是对象的抽象。
类：我们叫做class。 对象：我们叫做Object,instance(实例)
 类可以看成一类对象的模板，对象可以看成该类的一个具体实例。
类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。
对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。
属性（field 成员变量）
属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。
在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。
[修饰符] 属性类型 属性名 = [默认值] ;
方法
方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。
[修饰符] 方法返回值类型 方法名(形参列表) {
// n条语句
}
构造方法(构造器 constructor) 构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。
[修饰符] 类名(形参列表){
//n条语句
}
 构造器通过new关键字调用！！
 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。
 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加！
 构造器的方法名必须和类名一致！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5259011f23b97987bbc4774679c759d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f1fc8a37d5816f8cefcba611bafbac/" rel="bookmark">
			RestTemplate使用JSON发送Post请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RestTemplate使用JSON发送Post请求 本文我们说下如何使用Spring的 RestTemplate调用post请求，发送json内容。
1. 定义服务端web接口 1.1. 定义业务接口 先定义Person实体类表示post请求的数据：
public class Person { private Integer id; private String name; // standard constructor, getters, setters } 再定义PersonService接口并实现两个方法，关联使用Person类：
public interface PersonService { public Person saveUpdatePerson(Person person); public Person findPersonById(Integer id); } 这些方法的实现仅返回对象，不再具体讨论，让我们聚焦web层。
1.2. 定义业务REST API 下面我们为Person类定义简单的Rest api：
@PostMapping(value = "/createPerson", consumes = "application/json", produces = "application/json") public Person createPerson(@RequestBody Person person) { return personService.saveUpdatePerson(person); } @PostMapping(value = "/updatePerson", consumes = "application/json", produces = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f1fc8a37d5816f8cefcba611bafbac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e9023b62dcee5602472859b501a91d/" rel="bookmark">
			java解析并计算字符串算式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解析并计算，字符串形式的加减乘除算式，我亲测可行的，有以下两种方法：
1. Java自带的，eval方法 代码如下：
import javax.script.ScriptEngine; import javax.script.ScriptEngineManager; import javax.script.ScriptException; /** * 使用java eval 计算字符串表达式 * @param str 字符串表达式 * @return double 类型的结果 */ public static Double eval(String str) { ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine se = manager.getEngineByName("js"); Double result = null; try { result = Double.valueOf(se.eval(str).toString()); if (result == null) { result = new Double(0); } } catch (ScriptException e) { e.printStackTrace(); } return result; } 2. 递归，手动解析 核心代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e9023b62dcee5602472859b501a91d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a2130769d2e1f0fbaa6aabe68ebcd5/" rel="bookmark">
			基于深度学习SSD的跌倒检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统方法检测跌倒，主要是识别行人并跟踪，判断人的位置状态
跟踪的时候，遇到人跌倒时，很可能会丢失目标，所以，采用深度学习的跌倒检测比传统方法效果更好
有研究的大神可以一起交流，Q 2830025146
初步效果见 https://download.csdn.net/download/hnsdgxylh/11646018
改进版本见https://download.csdn.net/download/hnsdgxylh/11693526速度比以前快一倍，加速
采用OPENCL加速https://download.csdn.net/download/hnsdgxylh/11845585，在有英特尔graphics显卡上每帧35ms，达到实时性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9c9819179425f5e0584b0f365dae7e/" rel="bookmark">
			PHP实现网站唯一登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,
设置一个唯一值, session_id()就可以
当用户登录的时候, 将这个值记录到缓存 或者数据库中
每次刷新页面 判断session_id == 缓存中的值
若不等, 清空登录状态值
if(session_id() != $sessionid ){ unset($_SESSION); } 2,
如果同账号多用户频繁使用, 会造成用户频频掉线的不好体验
所以若有人在线, 可以提示下一用户账号使用中, 是否继续登录
这时候需要多设置两个值
isline 用来记录当前用户是否在线状态 lastlogin_time 和上一次登录时间 当用户登录时候, 将isline设为1, 并记录登录时间, 退出登录时将isline改为0
这样下一用户登录时, 先判断isline的值, 在执行是否可以 直接登录, 或是
alert('提示在线中, 继续登录');
为避免用户不正常退出, 直接关闭浏览器, 或者浏览器崩溃等, 所以需要用到lastlogin_time
若用户登录时, 查询缓存中
isline为在线状态, 可查看lastlogin_time的值, 如果距现在时间比较长, 可以判断为非正常退出, 当前用户可以登录
若isline在线, lastlogin_time 时间较短, 不是正常session失效时间, 可判断用户在线中, 提示账户在线中
if($isline){ if( (time()-$alstlogijn_time)&gt;3600*24 ){ //距离上次登录已超过24小时, 当前用户可以直接登录 }else{ //上一个用户在线中, //当前用户提示alert('提示在线中, 继续登录'); } } 当前如果当前用户session_id 与缓存中记录一致的话, 可以无需判断isline lastlogin_time等值, 可以直接登录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d05c2863438152605b80f8e8e874f73/" rel="bookmark">
			一次BeanUtils引发的血案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于公司业务条例要求，在传参时以Map形式JSON字符串传参
而在使用apache.commons.BeanUtils工具类将Map转为javaBean时，出现了将javaBean中的Integer 类型的属性转为了0而不是null的情况
通过断点调试后发现 BeanUtils工具类在将""转为Integer时，默认值为0
解决方案：1、如果字段为""时不传该字段,
2：设置一下 默认Converter
使用 ConvertUtils.register(new IntegerConvert(null),Integer.class)
此时该问题可解决，以此记录，也给自己长个记性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9198090d8ccdd6f5c7e878dfff2fd3/" rel="bookmark">
			DOM0级与DOM2级的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DOM0级和DOM2级的共同优点： 能添加多个事件处理程序，按顺序执行，HTML事件处理程序无法做到~ 2、关于dom0级和dom2级的区别 DOM0级事件处理：同时绑定几个不同的事件，例如在绑定onclick的基础上再绑定一个onmouseover为按钮2设置背景颜色（这里注意不能onclick、onmouseover事件都设为alert弹出哦，可能有冲突，dom0和dom2都不能成功）；但是不能同时绑定多个相同的事件，比如onclick；会覆盖，只会执行最后一个的函数； DOM2级事件处理：优点：同时绑定几个事件（相同或不同），然后顺序执行，不会覆盖。缺点：不具有跨浏览器优势. 另外，IE9能兼容dom2 转载于:https://www.cnblogs.com/hy96/p/11433063.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb99651f4c6161d706680ea94949276f/" rel="bookmark">
			STM32Cube的串口设置（二）一个串口接收另一个串口发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口系列
STM32Cube的串口设置（一）即学即用
通过串口设置第一部分大家应该基本会使用单个串口进行收发了
所以本次介绍通过串口进行转发
【适合情景为一个串口设备波特率为38400，但是接收模块仅支持115200波特率】
一、基本思路 在以上情况下，我们就需要两个串口和一个存储位置，在一个串口接收一个信号之后通过MCU转发到另一个串口以不同的波特率输出。
二、操作步骤 要求：通过串口向PC发送一段字符
1、根据自己的stm32的芯片型号来选择，我这里是STM32F767IGTx 2、选好芯片之后照旧设置RCC为外部时钟 3、使能串口1、3（usart1、usart3），如图： 模式设为异步（Asynchronous）其他默认，波特率可以自己改，USART1为115200Bits/s，USART3为38400Bits/s。
之后再使能串口1、3中断
4、设置中断优先级，如图： 设置中断优先级
5、看原理图，找到串口对应引脚，如图： 我这里是
PA10——&gt;USART1_RX PA9——&gt;USART1_TX PB11——&gt;USART3_RX PB10——&gt;USART3_TX 6、根据对应引脚设置串口引脚，如图： 找到PA9、PA10引脚左键点击分别选择USART1_TX和USART1_RX
（不用担心选错选反，针脚的功能是ST公司已经定义好了的）
7、设置时钟树，如图： 这里会搞的按自己习惯搞，不会搞的默认就好，但是不能有里面是红色的框（红色框就是错了意思）
8、项目设置，如图： 红框里的按照自己的Keil版本来
个人喜欢把.c/.h文件分开
9、点击右上角的‘GENERATE CODE’直接生成代码，如图： 10、生成代码后用Keil打开项目并在Application/User中找到usart.c并在/USER CODE BEGIN 0/后添加如下代码，如图： #include &lt;stdio.h&gt; struct __FILE { int handle; }; FILE __stdout; void _sys_exit(int x) { x = x; } int fputc(int ch, FILE *f) { while((USART3-&gt;ISR&amp;0X40)==0); USART3-&gt;TDR=(uint8_t)ch; return ch; } uint16_t USART3_RX_STA=0; uint8_t USART3_RX_BUF[800];//串口转存空间 11、生成代码后用Keil打开项目并在Application/User中找到main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb99651f4c6161d706680ea94949276f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c1b71434b9e5edacf3368f886bfd3a/" rel="bookmark">
			phpStudy &#43; PhpStorm &#43; XDebug调试【绝对能用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体参照的是这篇文章：https://blog.csdn.net/weixin_40418199/article/details/79088365
文章有些地方说的不是很详细想重写整理下。
【PHPStudy演示的版本为：PHP5.4.45-Apache】
1.PHPStudy配置
PHPStudy自带了XDebug的扩展，不需要下载
phpStudy -&gt; 其它选项菜单-&gt; PHP扩展及设置-&gt; PHP扩展 -&gt; Xdebug
2.然后修改php.ini
增加如下内容
[XDebug] xdebug.profiler_append = 0 ;效能监测的设置开关 xdebug.profiler_enable = 1 xdebug.profiler_enable_trigger = 0 ;profiler_enable设置为1的时候，效能监测信息写入文件所在的目录 xdebug.profiler_output_dir="D:\phpstudy\tmp\xdebug" ;设置的函数调用监测信息的输出路径 xdebug.trace_output_dir="D:\phpstudy\tmp\xdebug" ;生成的效能监测文件的名字 xdebug.profiler_output_name ="cache.out.%t-%s" ; IDE与XDebug协作 xdebug.remote_enable = 1 xdebug.remote_handler = "dbgp" xdebug.remote_host = "127.0.0.1" xdebug.remote_port = 9000 xdebug.idekey = phpstorm-xdebug ;.dll文件的路径 zend_extension="D:\phpstudy\PHPTutorial\php\php-5.4.45\ext\php_xdebug.dll" 3.phpStudy配置
1）选择PHP版本
File -&gt;Settings –&gt;languages &amp; Frameworks –&gt; PHP
2）Debug端口
“Debug port”与php.ini中xdebug.remote_port值一致
4）设置服务器
3）配置host端口
IDE key与 php.ini中xdebug. idekey值一致
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c1b71434b9e5edacf3368f886bfd3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4762b17e0cae8773638054be0cd41613/" rel="bookmark">
			关于M0内核MCU的Bootloader编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用MCU的时候如果要使用程序下载、程序升级或程序备份，那么都需要自己编写Bootloader。那么编写Bootloader使首先应该完成的是什么呢？没错，就是中断向量表。那如果操作中断向量表呢？这里就详细说一下：
要操作中断向量表，首先要知道中断向量表是什么，它的作用是什么？在编写MCU程序的时候都会用到中断，然后会有中断回调函数。MCU是如何通过中断而转到中断回调函数呢？这就需要中断向量表了，可以简单的理解，中断向量表就是连接中断事件和中断回调函数的桥梁。当有中断产生的时候，MCU会到中断会向量表中找回调函数，进而去执行。如果想了解更多的可以看M0和M3内核手册。
那知道了中断向量表是什么，现在要编写Bootloader的时候需要对中断向量表进行处理。在我的另一篇文章《STM32 IAP下载》篇中有介绍M3内核的相关操作，这里就不做过多介绍了，有兴趣的可以去看一下，附上链接：https://blog.csdn.net/qq_26226375/article/details/80158869 这篇文章还是以一个特定的MCU来解释，因为最近都在玩Nordic的51822芯片，所以，就以51822为例来介绍。51822是一款可以跑蓝牙协议栈的芯片，这里并没有使用协议栈，用的裸机。言归正传，如何操作中断向量表，M0和M3内核有一定的区别，使用M3内核的STM32F1XX可以直接对中断向量表进行映射，而且这个操作只需要配置一个寄存器就好了。而使用M0的51822芯片却不能这么做，有兴趣的可以试一下，如果写两个工程，一个Boot程序，一个应用程序，两个工程的起始地址不一样。如果可以完成从Boot程序成功跳转到应用程序，那么恭喜，已经成功了四分之一了。如果这时候在应用程序中进入了中断回调函数，会发现好像中断回调函数的执行结果和自己在应用程序中写的中断回调函数结果不一样，但是却好像跟Boot的中断回调函数一样，这就很气了。这是为什么呢？这是因为所有程序的起始地址都是从0x00000000开始，从起始地址向后偏移一定的位置是中断向量表，MCU都是根据这个中断向量表来找到中断回调函数。虽然在应用程序中也定义了中断向量表，但是如果不做处理，这个向量表不能被MCU检测到。所以当在应用程序中调用回调函数的时候，程序会回到Boot的中断回调函数位置，然后调用Boot的回调函数。那么我们最关键的就是让应用程序能调用应用程序的回调函数。
这里顺便介绍一下M0的启动流程。通常M0处理器都是从0x00000000开始的，内容如下图：
0x00000000的地址有个0x20008000的地址，这个地址就是(MSP)主栈指针的初始值，在往上的4个字节是复位后的程序执行的起始地址（会先执行复位）。从图上可以看到是0x000000c1，也就是说，程序在复位后，会从0x000000c1的位置开始。而0x00000000-0x000000c0的内容都被称之为“向量表”。那之后的是什么呢？见下图：
这个图就可以详细的看到向量表中存储的是什么。复位向量后是NMI向量，之后是硬件错误。。bulabula。。。这些看起来是不是有点眼熟。没错，这些就是在启动文件里的向量表内容。一般都会在.s文件里。这里依旧以51822为例：
可以看到这个启动文件里的东西，跟我们上边说的是对应的。我们看到的都是异常中断的中断回调函数，当程序出现异常的时候就会进入这些异常回调函数中。同样，图片下方的POWER_CLOCK_IRQHandler 、RADIO_IRQHandler..bulabula 也都是中断回调函数。既然M0内核没有办法进行中断向量表映射，那我们就需要让程序在boot和应用程序分别调用自己的中断回调函数。但是每次中断，程序都会回到0x00000008的位置开始寻找，所以必须在0x00000008的位置开始就区分开。
因为中断回调函数也是函数，也是调用一个地址的内容，所以我们可以把中断回调函数的内容都换成有序的、可以被我们控制的地址。那么当调用中断回调函数的时候，程序就会调用我们希望其调用的地址。可以这样做，如下附上代码：
/*
中断向量表重映射，映射到0x20000000的位置
*/
uint32_t my_vectors[48] __attribute__((at(0x20000000)));
void NMI_Handler()
{
(*(void(*)(void))my_vectors[2])();
}
void HardFault_Handler()
{
//(*(void(*)(void))my_vectors[3])();
}
void SVC_Handler()
{
(*(void(*)(void))my_vectors[11])();
}
void PendSV_Handler()
{
(*(void(*)(void))my_vectors[14])();
}
。。。。
这样，所有的中断回调函数全都会去调用my_vectors这个数组的内容的地址位置。我们把这个数组的地址定义到Boot程序和应用程序都能调用到的RAM区域，当然，这个地址要保护起来（Boot程序和应用程序都不会使用该地址）。然后我们在boot里将从0x00000000-0x000000c0的内容（向量表）拷贝到my_vectors数组中，这样就完成了boot向量表的拷贝。当程序在Boot区执行完成后，要跳转到应用程序之前，将应用程序的前0xc0的内容拷贝到my_vectors数组中，这样也就完成了应用程序的向量表重定义。这样，每次在执行boot程序的时候，执行的是boot的中断回调函数，而执行应用程序的时候，执行的是应用程序的中断回调函数。
起始，方法还有很多，这个只是其中的一种而已。欢迎留言评论，如果有说的不对的地方，也欢迎大佬指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99cccf387c28efa6b822685b30434544/" rel="bookmark">
			Oracle timeStamp时间类型相减，单位为毫秒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于时间日期的相减的知识有很多，但是大部分是以秒为单位的，由于项目指标的要求，统计平均交易时间（毫秒级别），自己总结如下：
1.计算时间首先将时间类型转为为字符类型；
2.然后将时间类型转换为对应的时间类型相减；
3.接着截取毫秒范围内的字符串；
4.将结果转换为数字类型进行相应的统计计算。
例如：
计算某统计区间内最大的交易时间？
--统计时间区域内的最大交易时间 select max( to_number( substr( ( to_timestamp(to_char(结束字段,'yyyy-mm-dd hh24:mi:ss.ff6'),'yyyy-mm-dd hh24:mi:ss.ff6') - to_timestamp(to_char(开始字段,'yyyy-mm-dd hh24:mi:ss.ff6'),'yyyy-mm-dd hh24:mi:ss.ff6') ) *86400000,2,9) ) ) from 表 a where a.开始字段 &gt; 左区间 and a.结束字段 &lt; 右区间 注意：
1.格式化'yyyy-mm-dd hh24:mi:ss.ff6'是直接格式化到毫秒级别，默认为6位；
2.86400000代表“时”转换为“毫秒”的转换量；
3.substr(a,2,9)是将正确截取对应的毫秒差，因为一般to_timestamp相减之后的格式为：+000000001 00:00:00:000000000，这时我们需要的是“＋”后面，第一个“空格”前面的。
小提示：
to_date只能处理秒及以上的时间，不能处理毫秒级别的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd56f13ced9792a0a3e2e3a1241c5b97/" rel="bookmark">
			查资料说明“数据就是一个个表格组成的”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查资料说明“数据就是一个个表格组成的”查了半天资料发现，还是老高说的最有道理，做的课件内容基本已经概括了所有内容了，所以在这里我就引用一下高老师的课件哈哈！
表格结构和类结我们在现实生活中，思考问题、发现问题、处理问题，往往都会用“表格”作为工具。实际上，“表格思维”就是一种典型的面向对象思维。 实际上，互联网上所有的数据本质上都是“表格”。我们在这里通过从表格表示数据开始，引入对象和类。大家就会神奇的发现，原来“表格就是对象”。
以公司雇员表为例：
上面这个雇员表，可以将公司所有员工信息“结构化”、“标准化”，让管理者可以方便的进行统计和管理。
我们也经常将表中的“列”，叫做“字段”，英文中统一叫做“field”。显然，field定义了表的结构。我们可以通过增加新的field(列)，让表中所有的行增加数据
面向对象编程中，类对应表的结构（表的field），我们可以定义出“雇员类”：
通过上图，可以看到，雇员类和雇员表的结构完全一样。只不过，雇员类增加了数据的类型而已。
表格的动作和类的方法每个公司的雇员都要有相关的动作。
比如：所有雇员每天的工作标准动作有：
1. 参加晨会，领取当天任务
2. 午休
3. 提交工作日志
我们可以在雇员表中将动作信息也包含进去：
新增的列“雇员动作说明”，显然是对所有的雇员都有用，每个雇员都有这个动作。 在类中就是定义成方法：
当然，我们也可以根据需求，为雇员定义多个动作。比如：午休、提交工作日志、领取工资等等。
对象对应“表中的行数据”下面三句话大家记住：
1. 表结构对应：类结构
2. 一行数据对应：一个对象
3. 表中所有数据对应：这个类的所有对象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd7b4ea0e55c92b5d8bb9152f235ae4/" rel="bookmark">
			iOS 12.4 越狱后修复 Cydia 不能联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近 iOS 12.4 越狱的出现，给各位技术爱好者带来了福音，因为 iOS 12.4 是目前苹果最新的正式版系统，没有关闭验证，可以随便刷机和升级。
国行手机越狱之后，一直有一个烦人的问题，就是 Cydia 不能联网，不仅是 Cydia，安装其他越狱版的软件也会遇到不能联网的问题。Cydia 不能联网的原因，我之前写了一篇文章《Cydia 不能上网的终极解决方法》有提到过，也讲解了修复的方法，不过那篇文章的方法只适合在 iOS 10及以下的系统上使用，主要是 MobileTerminal 对 iOS 11 和 12 系统的兼容性不好，导致有些读者安装 MobileTerminal 会失败。
今天我们来说一下 iOS 12 上的修复方法，这个方法很简单，支持目前所有的机型和 iOS 8-12 系统。下面是修复步骤：
(1) 越狱成功之后，在爱思助手上搜索乐网并安装。请注意不要在 App Store 下载乐网，App Store 上的乐网和爱思上的乐网功能不一样。
(2) 打开乐网，开启全局拦截，这时手机相当于会连接一个V.P.N，再打开 Cydia 发现可以联网
(3) 然后在 Cydia 搜索下载 Filza 或者下载 OpenSSH，反正只要可以管理文件就行。找到这个三个文件并删除，联网的问题就解决了。这时乐网的全局拦截也可以关闭了。
/var/preferences/com.apple.networkextension.plist
/var/preferences/com.apple.networkextension.cache.plist
/var/preferences/com.apple.networkextension.necp.plist
原文地址：https://www.ioshacker.net/thread-141-1-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff57640a29512b633fdd853f3d6a634a/" rel="bookmark">
			在广联达GTJ2018中怎么画线型预埋铁件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题GTJ2018中怎么画线型预埋铁件，能快速计算出预埋铁件重量？（比如电缆沟中的预埋角钢、预埋扁铁等）
处理方案：
1、用自定义线画线型预埋铁件，在定义自定义线时属性备注中先手动计算好每种预埋铁件的单位重量。（如下图）
2、汇总计算工程量。然后在报表页面将自定义线结果显示内容中的“备注”勾选起。（这一步很重要）
3、查看工程量。自定义线工程量结果中各种线型预埋件长度及单位重量都汇总统计出来了。（如下图）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0102ba5c54319a53129798c9ce0fe879/" rel="bookmark">
			用十步天才模型深度剖析对“方法”这一概念的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是方法 方法(method)就是一段用来完成特定功能的代码片段，类似于其它语言的函数(function)。
学习方法的目的 可以将一组逻辑关系的代码放在一起，实现某一个业务逻辑或者只是为了复用
如何使用方法  形式参数：在方法声明时用于接收外界传入的数据。
 实参：调用方法时实际传给方法的数据。
 返回值：方法在执行完毕后返还给调用它的环境的数据。
 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。
 实参的数目、数据类型和次序必须和所调用的方法声明的形式参数列表匹配。
 return 语句终止方法的运行并指定要返回的数据。
 Java中进行方法调用中传递参数时，遵循值传递的原则(传递的都是数据的副本)：
 基本类型传递的是该数据值的copy值。
 引用类型传递的是该对象引用的copy值，但指向的是同一个对象。
广度思维，类比生活中的例子 电风扇，（电源，1挡2挡3挡，摆头）相当于参数，执行按动这些按键，相当于调用这些参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a58168368bd522f07fec06ac8dbe6a/" rel="bookmark">
			数据是一个个表格组成的。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据就是一个个表格组成的： 1.我是一个小白，今天老师讲了引用了一个概念，就是 数据是一个个表格组成的，我学的还不够透彻，所以在网上查了点资料，通常我们在在数据库中,表头被称为:字段， 栏目称为:记录
数据清单就是由字段和记录来组成的， 下面给大家例一个例子，这是一个程序员在网上提问：
如何把表格里的数据转变成json格式传送到后台数据库？
现在，我遇到了一个难题，想请各位高手来帮忙解答。 以下是我的表格截图，
我需要做的是把表格里的数据全部转变为json格式，用ajax传送到后台数据库。
json格式：
var riditemsList = [{“Code”:“08”,“secCode”:“10”,“seName”:“化妆品”,“itemNo”:“00001”,“itemName”:“曼秀雷敦润唇膏”},{“Code”:“08”,“seCode”:“10”,“seName”:“化妆品”,“itemNo”:“00002”,“itemName”:“曼秀雷敦香皂”},{“Code”:“08”,“seCode”:“10”,“seName”:“化妆品”,“itemNo”:“00003”,“itemName”:“曼秀雷敦指甲油”},{“Code”:“08”,“seCode”:“10”,“secName”:“化妆品”,“itemNo”:“00004”,“itemName”:“曼秀雷敦润肤乳”}]
我原来用的是js生成一个item的对象，然后，new一个数组，把表格的每一行遍历，然后遍历每一行中的子元素，把每一个子元素赋值给每一个item对象的属性Code, seCode, seName, itemNo, itemName。可是，不知道如何写好这段代码。以下是我的草稿，似乎还是没实现我的想法，请高手帮忙。
function saveTable(){
debugger;
var saveData={};//新建对象，用来存储所有数据
var subSaveDataArr={};//存储每一行数据
var tableData={};
var dcCode, sectionCode, sectionName, itemNo, itemName;
$("#div1 table tr").each(function(trindex,tritem){//遍历每一行
tableData[trindex]=new Array(); $(tritem).find(“td”).each(function(tdindex,tditem){
//如果第一行的input值是Yes,就把这一行的每一列的有值的单元格存入 tableData[trindex][tdindex]=$(tditem).text();//遍历每一个数据，并存入 subSaveDataArr[trindex]=tableData[trindex];//将每一行的数据存入 });
});
for(var key in subSaveDataArr)
{
saveData[key]=subSaveDataArr[key]; ///将每一行存入对象
}
这样，实现的json格式是：
{[’’,’’,’’]}，里面缺少对应的name，请高手指教。
这是运行不了代码 ，这里很明显，他需要做的是把表格里的数据全部转变为json格式，用ajax传送到后台数据库。。 下面是一个位大神敲出来的正确的代码，无聊的大家可以试一试：
function saveTable(){
debugger;
var saveData=[];//新建对象，用来存储所有数据
var dcCode, sectionCode, sectionName, itemNo, itemName; $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18a58168368bd522f07fec06ac8dbe6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979b1fbd5a592f5f4b6a9aba08c63041/" rel="bookmark">
			Install opencv 4.1.1 on Raspberry pi3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python2上安装opencv sudo apt-get install libopencv-dev sudo apt-get install python-opencv 进入python，进行测试
import cv2 在Python3上安装opencv 目前没有pip3 install opencv-python 或者apt install opencv 这样直接简单的方法直接安装，需要自己在github上下载opencv4.1.1，使用cmake来自己编译安装
首先增加交换空间以避免因内存问题导致的编译挂起 sudo nano /etc/dphys-swapfile //将 CONF_SWAPSIZE 值从默认值更改 100 为 1024 ： CONF_SWAPSIZE=1024 保存文件并运行以下命令以使更改生效：
sudo /etc/init.d/dphys-swapfile restart 更新包索引并安装构建工具和所需的依赖项： sudo apt update sudo apt install build-essential cmake git pkg-config libgtk-3-dev libcanberra-gtk* sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libxvidcore-dev libx264-dev sudo apt install libjpeg-dev libpng-dev libtiff-dev gfortran openexr libatlas-base-dev opencl-headers sudo apt install python3-dev python3-numpy libtbb2 libtbb-dev libdc1394-22-dev 创建一个新目录并从 Github 克隆 OpenCV 和 OpenCV contrib 存储库： mkdir ~/opencv_build &amp;&amp; cd ~/opencv_build clone 可能非常的慢，我们可以用wget 直接下载archive再解压，速度可观
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979b1fbd5a592f5f4b6a9aba08c63041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea8675f2988e0cbc983f28011bb96521/" rel="bookmark">
			数据是由一个个表格组成的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据是由一个个表格组成的 我们在现实生活中，思考问题、发现问题、处理问题，往往都会用“表格”作为工具。实际上，“表格思维”就是一种典型的面向对象思维。互联网上所有的数据本质上都是“表格”。
什么数据 数据(data)是事实或观察的结果，是对客观事物的逻辑归纳，是用于表示客观事物的未经加工的的原始素材。
表格的定义 表格，又称为表，既是一种可视化交流模式，又是一种组织整理数据的手段。人们在通讯交流、科学研究以及数据分析活动当中广泛采用着形形色色的表格。
从类和对象的角度看数据和表格 就相当于水果包括苹果、香蕉、橘子、梨。那么水果就相当于一个类或者一个数据，而苹果、香蕉、橘子就是对象了和数据的内容。苹果、香蕉、橘子有各自的属性，方法。苹果的各种信息需要表格的形式记录，苹果的大小，产地，年份，品种等等，形成一种数据。香蕉、和橘子同上产生各自的数据。而相对于水果来说，苹果、橘子、香蕉，等等就形成一组对于水果的数据，这些都需要以表格的形式来承载。类是对具体对象的抽象。数据是由表格的组成。
因此，可以说，数据是由一个个表格组成的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6656ce64a5461ba8518a326c98fa69e/" rel="bookmark">
			计算机中数据就是一个个表格组成的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据就是数值，也就是我们通过观察、实验或计算得出的结果。数据有很多种，最简单的就是数字。数据也可以是文字、图像、声音等。数据可以用于科学研究、设计、查证等。
生活中常见的数据和表格
我们在现实生活中，思考问题、发现问题、处理问题，往往都会用“表格”作为工具。数据是对客观事物的逻辑归纳，是用于表示客观事物的未经加工的的原始素材。数据可以是连续的值，比如声音、图像，称为模拟数据。也可以是离散的，如符号、文字，称为数字数据。
数据和数据之间也有结构
数据存储对象包括数据流在加工过程中产生的临时文件或加工过程中需要查找的信息。数据以某种格式记录在计算机内部或外部存储介质上，类似于Excel如果把工作簿比作数据库，工作表就好比数据库中的表。也就是说一个数据库中包含了若干张表，各个表中存放了各种数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc49ff4a2615a975fafa3725e2060733/" rel="bookmark">
			/lib64/libstdc&#43;&#43;.so.6: version `CXXABI_1.3.8’ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终极一战 libstdc++.so.6 版本过低导致的编译GCC 绝命一击 ImportError: /lib64/libstdc++.so.6: version `CXXABI_1.3.8’ not found
libstdc++.so.6 版本过低导致的 看看自己的 libstdc++.so.6 里是否包含了 CXXABI_1.3.8
# strings /usr/lib64/libstdc++.so.6 | grep CXXABI CXXABI_1.3 CXXABI_1.3.1 CXXABI_1.3.2 CXXABI_1.3.3 CXXABI_1.3.4 CXXABI_1.3.5 CXXABI_1.3.6 CXXABI_1.3.7 CXXABI_TM_1 果然没有。
注意，不一定是GCC版本过低，用SCL(关于scl https://linux.cn/article-6776-1.html ) 升级GCC毛用都没有，根本不能升级 libstdc++.so.6
所以我们要升级 libstdc++.so.6 ，顺便升级GCC。如果只升级GCC（通过scl）是无效的，因为gcc的版本高了，但是他的libstdc++是 require的 原来的 libstdc++.so.6。
不信你看
# cat /opt/rh/devtoolset-7/root/usr/lib/gcc/x86_64-redhat-linux/7/libstdc++.so /* GNU ld script Use the shared library, but some functions are only in the static library, so try that secondarily. */ OUTPUT_FORMAT(elf64-x86-64) INPUT ( /usr/lib64/libstdc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc49ff4a2615a975fafa3725e2060733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd40642c31a45205d83a73b2255ca8f/" rel="bookmark">
			数据是一个个表格组成的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在很多编程人员的潜意识里总是觉得数据结构知识似乎没什么用，因为工作中似乎从来都没有涉及到数据结构的什么内容。我对这样的认识只能报以呵呵~ 也难怪，其实有这些想法的同行在工作中的大部分都是如此走过来的：掌握几种常用Web框架，比如SSH，然后不停的堆砌已有的API做一些对数据库的增删改查之类的简单代码设计，最后反正功能是实现了，是否设计无误，效率又优，就几乎没有人去管了。也是，这样的工作也基本涉及不到有用到数据结构知识去解决问题的地方。其实，有这样想法人算不上真正的软件开发者，或者层次还不深，因为数据结构是软件开发中最基础最重要的理论基础。1. 为什么数据结构很重要 首先为什么要开发各种各样的软件，目的只有一个：就是利用计算机来为人们处理各种数据并以一定的形式展现出来供用户使用。随着计算机的应用范围的不断扩大，计算机所需要处理的数据越来越复杂，并且规模越来越大，计算机所处理的数据已不再是单纯的数值数据，而更多的是非数值数据。 另一方面，现实中需要处理的数据并不是杂乱无章的，它们一定有内在的各种联系，但这需要算法设计人员去总结、归纳、建模、然后抽象出一个具体的模型来表示—，我们将这个模型成为数据的逻辑结构。然后聪明的设计师再围绕这个创建的逻辑结构总结设计出一套处理方法，这样，数据有了，模型有了，算法有了，在理论上问题就可以解决了。剩下的就应该交给计算机去做了，但以上都是基于逻辑上的设计，计算机才不懂这些。所以接下来还需要对应的存储结构来将要处理的数据先存储到计算机中，再将那些处理逻辑（算法）用相应的代码实现，计算机才能对数据进行有效的处理。 2. 什么是数据结构数据结构：即人们抽象出来的描述现实世界实体的数学模型（非数值计算）及其上的操作（运算），在计算机上的表示和实现。数据结构就是指按一定的逻辑结构组成的一批数据，使用某种存储结构将这批数据存储于计算机中，并在这些数据上定义了一个运算集合。3. 数据类型数据类型：定义该类型涵盖的数据的性质、取值范围以及对数据所能进行的各种操作。程序中的每一个数据都属于一种数据类型，决定了数据的类型也就决定了数据的性质以及对数据进行的各种运算和操作，同时数据也受到类型的保护，确保对数据不能进行非法操作。高级程序设计语言通常预定义一些基本数据类型和构造数据类型。基本数据类型的值是单个的、不可分解的，它可以直接参与该类型所允许的运算。构造数据类型是使用已有的基本数据类型和已定义的构造数据类型按照一定的语法规则组织起来的较复杂的数据类型。构造数据类型的值由若干元素组合而成，这些元素按某种结构组织在一起。Java语言的基本数据类型有整数类型、浮点数类型、字符类型、布尔类型，构造数据类型（称为引用类型）有数组、类和接口。抽象数据类型（Abstract Data Type ,ADT）：是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型和数据类型本质上是一个概念，它们都表现数据的抽象特征。数据抽象是指“定义和实现相分离”，即将一个类型上的数据及操作的逻辑含义与具体的实现分离。程序设计语言提供的数据类型是抽象的，仅描述数据的特征和对数据操作的语法规则，并没有说明这些数据类型是如何实现的。程序设计语言实现了它预定义数据类型的各种操作，编程人员按照语言提供的规则使用数据类型，只考虑对数据执行什么操作（做什么），而不必考虑怎样实现这些操作（怎样做）。对于使用数据类型的用户来说，数据类型实现了信息的隐蔽，即将一切用户不必了解的细节都封装在类型中。例如Java语言的类型-整数类型即是一个抽象数据类型，编程人员在使用整型时，并不需要知道其是如何实现的。另一方面，抽象数据类型的范畴更广，它不再局限于程序语言已定义并实现的数据类型（也可称这类数据类型为固有数据类型），还包括编程人员在设计软件系统时自己定义的数据类型。如前所述，抽象数据类型的定义是由一个值域和定义在该值域上的一组操作组成，算法设计时，编程人员通常需要为一些抽象出来的逻辑结构来自定义一个抽象数据类型，比如：为线性表，栈，队列，串，广义表，二叉树，树，图等自定义抽象类型。一种抽象数据类型描述一种数据结构的逻辑特性和操作，与该数据结构在计算机内存储及实现无关。抽象数据类型的三要素：数据对象，数据关系，基本操作。在实际应用中，编程人员在使用自定义的抽象数据类型之前，必须实现这些抽象数据类型（在实现之前，还应该为属于数据类型的数据元素定义结点），才能使用它们。而实现抽象数据类型依赖于数据存储结构。例如，线性表可分别采用顺序存储结构或链式存储结构来实现。 在Java语言设计中，通常使用接口描述抽象数据类型，使用类实现借接口，即实现抽象数据类型中描述的操作。4. 数据的逻辑结构数据的逻辑结构是指数据元素之间的逻辑关系，用一个数据元素的集合（包括n&gt;=0个数据元素）和定义在此集合上的若干关系来表示，常被简称为数据结构。数据的逻辑结构是独立于计算机的，它与数据在计算机中的存储无关。数据的逻辑结构指数据元素之间的逻辑关系，分四种：集合，线性结构、树形结构、图状结构。再具体一些：线性表，栈，队列，串，广义表，树，图等都是对现实实体的抽象出来的逻辑结构。 数据元素：是数据的基本单位，在计算机程序中通常做为一个整体进行考虑和处理。数据元素可以是一个不可分割的原子项，也可以由多个数据项组成。数据项是数据元素中有独立含义的、不可分割的最小标示单位。例如，一个整数、一个字符都是原子项；一个学生的数据元素由学号、姓名、性别和出生日期等多个数据项组成。在计算机存储时，我们可以用一个由若干位组合起来形成的一个位串标示一个数据元素（如用一个字长的位串表示一个整数，用8位二进制数表示一个字符等），通常呈这个位串为元素（element）或结点（node）。当数据元素由若干数据项组成时，位串中对应与各个数据项的子位串称为数据域。在编程语言中，比如Java，一个数据元素通常由一个类来描述。我们知道在C语言和C＋＋语言中是用指针来实现链表结构的，由于Java语言不提供指针，所以有人认为在Java语言中不能实现链表，其实不然，Java语言比C和C＋＋更容易实现链表结构。Java语言中的对象引用实际上是一个指针（本文中的指针均为概念上的意义，而非语言提供的数据类型），所以我们可以编写这样的类来实现链表中的结点。 class Node
{
Object data;
Node next;//指向下一个结点
}　将数据域定义成Object类是因为Object类是广义超类，任何类对象都可以给其赋值，增加了代码的通用性。为了使链表可以被访问还需要定义一个表头，表头必须包含指向第一个结点的指针和指向当前结点的指针。为了便于在链表尾部增加结点，还可以增加一指向链表尾部的指针，另外还可以用一个域来表示链表的大小，当调用者想得到链表的大小时，不必遍历整个链表。 5. 数据的存储结构但要对数据进行处理，就必须将数据存储在计算机中。如果将数据在计算机中无规律地存储，那么在处理时是非常糟的，是没有用的。试想一下，如果一本英汉字典中的单词是随意编排的，这本字典谁会用！ 数据结构在计算机中的表示（又称映像）成为数据的物理结构，又称存储结构。它包括数据元素在计算机中的表示和关系的表示。5.1 数据的基本存储结构主要有4种：(1) 顺序存储：将逻辑上相邻的结点存储在一组连续的内存单元中，使得逻辑相邻的结点一定是物理位置相邻，元素在内存中的存储次序与它们的逻辑次序相同。顺序存储通常用于存储具有线性结构的数据，在高级程序设计语言中通常使用数组来实现。(2) 链式存储：即使用若干地址分散的存储单元存储数据元素，逻辑上相邻的数据元素在物理位置上不一定相邻，数据元素之间的关系需要采用附加信息特别指定。通常，采用指针变量记载前驱或后继元素的存储地址，由数据域和地址域组成的一个结点表示一个数据元素，通过地址域把相互直接关联的结点链接起来，结点间的链接关系提仔数据元素间的逻辑关系。(3) 索引存储：在线性结构中，设开始结点的索引号为1，其它结点的索引号等于其前继结点的索引号加1，则每一个结点都有唯一的索引号，索引号就是根据结点的索引号确定该结点的存储地址。(4) 散列（哈希）存储：散列存储的思想是构造一个从集合K到存储区域M的一个函数h，该函数的定义域为K，值域为M，K中的每个结点ki在计算机中的存储地址由h(ki)确定。其中，顺序存储结构和链式存储结构是两种最基本、最常用的存储结构。除此之外，将顺序存储结构和链式存储结构进行组合，还可以构造出一些更加复杂的存储结构。5.2 一些常见的数据结构（即逻辑结构）对应的存储结构线性表的存储：线性表可以采用顺序存储结构和链式存储结构。采用顺序存储结构的链表称为顺序表，顺序表通常使用采用数组存储其数据元素，将线性表的数据元素顺序存放在数组中，数据元素在数组中的物理顺序与线性表中的元素的顺序关系完全相同。采用链式存储的线性表成为链表。栈的存储：顺序存储和链式存储两种，分别成为顺序栈和链栈；队列的存储：队列一般采用链式存储，其中循环队列可采用顺序存储；数组的存储结构：顺序存储，其中二维数组包括以行序为主序存储和以以列序为主序存储； 数组是顺序存储的随机存储结构，占用一组连续的存储单元，通过下标识别元素，元素地址是下标的线性函数。在程序设计语言中，数组已被实现为一种构造数据类型，程序语言中的整数类型，字符类型等都是基本数据类型，通过一个变量表示一个数据，这种变量称为简单变量。在实际应用中，经常需要处理具有相同性质的一批数据。例如要处理100个学生的考试成绩，如果要使用简单变量，将需要100个不同的变量，极为不便，为此，比如在java中，可以使用数组来存储着一批具有相同性质的数据。数组一旦占用一片存储空间，这片存储空间的地址和长度就是确定的，不能更改。因此，数组只能进行赋值、取值两种随机存取操作，不能进行插入、删除操作。字符串的存储结构： 1. 定长顺序存储：类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列（比如使用一维数组存储）。 2. 堆分配存储：仍以一组地址连续的存储单元存储串值的字符序列，但它们的存储空间是在程序执行过程中动态分配而得。 3. 串的块链存储：可用链表的方式存储串值。掌握：数组，字符数组，字符串数组，ArrayList(动态数组)、LinkedList类、String类 、StringBuffer类 、StringBuilder类的区别和使用方法。矩阵的存储结构：高级语言编程时，通常都是用二位数组来存储矩阵元。矩阵存储时，我们感兴趣的不是矩阵本身，而是如何存储矩阵的元，从而使矩阵的各种运算能够有效的进行。矩阵式很多科学与工程计算问题中经常研究的数学对象。广义表的存储结构：通常采用链式存储结构。树的常用存储结构有：双亲表示法存储、孩子链表存储、孩子兄弟表示法（又称二叉链表表示法）存储等，这几种存储方法都属于链式存储的不同方式。二叉树的常用存储结构：适用于完全二叉树的顺序存储结构、二叉链表存储、三叉链表存储法两种链式存储结构。图的常用存储结构有：邻接矩阵表示法存储（数组表示法）、邻接表法、十字链表法、邻接多重表；其中邻接表法和十字链表法、邻接多重表都是图的不同链式存储方法。5.3数据的操作（运算集合）数据操作指对一种数据结构中的数据元素进行各种运算或处理。每种数据结构都有一组数据操作。对于一批数据，数据的运算是定义在数据的逻辑结构之上的，而运算的具体实现就依赖于数据的存储结构。数据的运算集合要视情况而定，一般而言，数据的运算包括插入、删除、更新、检索、遍历、排序等。初始化、判断是否为空状态、统计数据元素个数插入：在一个结构中增加一个新的结点。删除：在一个结构删除一个结点。更新：更新一个结构中制定位置的结点。检索：在一个结构中查找满足条件的结点。输出：将一个结构中所有结点的值打印、输出。排序：将一个结构中所有结点按某种顺序重新排列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac6560d48fde933c941dc3eda783e2c/" rel="bookmark">
			Nginx代理及Vue报Uncaught SyntaxError: Unexpected token 错误等汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试环境虚拟机周五下午5点左右突然遭遇文件夹漂移事故，虽然是运维的事情，可是项目管理是自己的，周一还需要业务验收，真是头疼死了。
先后碰到若干问题，就不一一详细描述了，本博客只为自己留存备份，若是有人看到博客能顺便解决自己的问题也是举手之劳，若是不对症请不要恶语相向。
问题一、所有请求均报404错误，查看配置都是对的，结果发现是因为Nginx用户启动是nobody引起的，修改nobody之后解决问题。
修改配置nginx.conf，将user从nobody修改为root
user root; worker_processes 1; PS：此问题还有可能是Nginx对访问的目录没有访问权限引起的，注意排查。
问题二、注意alias和root配置的正确用法。
root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。
root的处理结果是：root路径＋location路径
alias的处理结果是：使用alias路径替换location路径
alias是一个目录别名的定义，root则是最上层目录的定义。
还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的。。。
root实例：
location ^~ /t/ { root /www/root/html/; } 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/t/a.html的文件。
alias实例：
location ^~ /t/ { alias /www/root/html/new_t/; } 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/new_t/a.html的文件。注意这里是new_t，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。
问题三、因为前端是使用的vue，结果在加载资源的时候碰到浏览器报错：Uncaught SyntaxError: Unexpected token &lt;
具体现象是js文件夹下的所有js变成了文件夹，js目录下的所有js都变成了index.html文件。
try_files $uri $uri/ /index.html; Nginx里面这段代码引起的。当出错的时候会强制跳转到 index.html 页面，而js文件是不会识别html，因此报Uncaught SyntaxError: Unexpected token &lt; 错误
访问了不存在的js，然后这个404错误又重新指向了一个提示的自定义页面，由于脚本里面不允许出现标签因为标签带了&lt;&gt;符号，所以，就会抛出这个异常 从而报错。
加入如下配置，专门处理js等静态资源文件
location ~ ^/(images|img|javascript|js|css|flash|media|static)/ { alias /external/product/; autoindex on; } 最后修改以后的conf文件配置如下：
user root; worker_processes 1; #error_log logs/error.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eac6560d48fde933c941dc3eda783e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff94e12414f0016ea144e43e958219d/" rel="bookmark">
			数据就是一个个表格组成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用表格思想来理解Java类和对象，那么，对于表格中的数据如何对应到Java中的类和对象呢？那么，首先让大家对类和对象有一个大概的印象和概念。
关于类和对象，可以理解为表结构对应着类，而一行数据对应着对象。所谓表结构就是字段，根据这些字段，我们可以不断地添加新的记录，比如在eclipse中就可以新建一个类，就可以在其中加入字段，可以是汉字，但在前面要加上字符类型，这样就吧类的基本结构定义好了。当然，除了字段以外还可以添加方法。所以说，类适合表结构对应的。
在有了类的模板之后就可以建对象了，就相当于新加一行记录。对应的在eclipse增加一个构造方法，类除了字段以外，还有方法。尚学堂百战程序员陈老师指出在实际应用中，数据库中的数据会通过程序来进行读取，同样，也可以将外部录入的数据写入到表格里，这样，就是实现了与数据库的交互操作。以后大家建立的所有项目都有数据库。这样就明白了表结构对应类结构，一行数据对应一个对象。
表格是用来存储数据的，对象也是用来存储数据的，所以表格与对象存在对应关系，不过，需要注意的是，对象里可以新增方法，而表格是没有方法的，表格只能够存储固定的数据。对象可以新增方法，方法可以将数据“活起来”。这就是对象更加强大的功能所在。大家在后续学编程的过程中会逐步深入理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f99cfa39a9d33925d5eb42f2897f76/" rel="bookmark">
			img标签的alt和title有何异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		img标签的alt和title有何异同？ img标签其中的两个属性alt和title有相似的地方，但是在不同的情况下要使用不同的属性的。
alt属性和title属性相同点：
它们都会出现浮层，显示自己设置的图片相关的内容。
alt属性和title属性不同点：
alt属性:1.当图片加载不出来的时候，就会在图片未显示的地方出现一段alt设置的属性内容。这个属性的作用是为了给未加载的图片显示提示信息，即使在网络比较差的时候，用户也可以知道图片的内容，方便用户浏览网页。同时在程序员对网站维护的时候也能更快的查找到问题。2.浏览器的搜索引擎可以通过alt属性的文字描述来获取图片。
title属性：title属性可以用在任何的元素上，当用户把鼠标移动到元素上时，就会显示预先设置的title的内容，起到对图片说明的作用，实质上就是对图片的解释和备注。
img标签中引用的图片不论是否能够正常的显示，图片只设置了title属性后，当鼠标经过或者悬停在图片区域时，就能看到图片的文字的描述。当图片仅仅设置alt属性的时候啊，当鼠标悬停或者经过图片区域的时候，可以看到该图片设置的alt的属性的文字内容。如果图片设置了title属性和alt属性，鼠标悬停或者经过图片区域的时候，只会显示title属性设置的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584e8fef506ec8e75115f0490691265b/" rel="bookmark">
			Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内
语法 element.scrollIntoView(); // 等同于element.scrollIntoView(true) element.scrollIntoView(alignToTop); // Boolean型参数 element.scrollIntoView(scrollIntoViewOptions); // Object型参数 参数 alignToTop (Boolean型参数)
1.如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 2.如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。 scrollIntoViewOptions (Object型参数)
{ behavior: "auto" | "instant" | "smooth", block: "start" | "end", } 1.如果是一个boolean，true 相当于{block: "start"}，false 相当于{block: "end"} 2.behavior这个选项决定页面是如何滚动的，实测auto与instant都是瞬间跳到相应的位置，而smooth就是有动画的过程 示例 var element = document.getElementById("box"); element.scrollIntoView(); element.scrollIntoView(false); element.scrollIntoView({block: "end"}); element.scrollIntoView({block: "end", behavior: "smooth"}); 注意 取决于其它元素的布局情况，此元素可能不会完全滚动到顶端或底端。
转载于:https://www.cnblogs.com/hy96/p/11408642.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4e673c37e7fe88d434f24cd03d89a5/" rel="bookmark">
			利用VBA快速整合多个excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		心得(一)：关于VBA如何把同一个文件下的所有文件的内容合并到同一个excel文件下 问题：如何把多个格式相同的excel整合到一个excel上，起初想的是可以直接用复制粘贴……但是文件有几百个将近一千个，这么做的话有点暴躁…
解决：首先把所有要整合的excel文件放在一个路径不含有中文名的目录下，然后新建一个excel文件右键sheet点击查看代码，这时候你的画面上会出现一个编辑器，你这这上面利用VBA编写语言，最后点击F5直接运行即可
正常解决思路：
打开一个excel文件，并将需要的内容复制，然后粘贴到整合excel文件上，并不断重复这样的操作。
利用VBA操作：
利用VBA打开文件，代码如下：
括号内的是打开文件的绝对地址
复制选定区域的内容：
粘贴复制的内容到指定的文件
利用VBA的dir函数打开下一个文件，这个函数会根据一定规律打开文件内的文件，但是具体是什么规律暂时还不知道，
这个函数如果是这个方式：
第首次使用就要输入绝对地址，但是后面就不需要了
源码如下：
Sub 合并当前目录下所有工作簿的全部工作表() '表示当前的过程的名称 '定义对应的变量名称 Dim mypath, myname, awbname Dim wb As Workbook, wbn As String Dim g As Long Dim num As Long Dim box As String Dim count As Long Dim place As Long Dim temp As Long '关闭excel的刷新 Application.ScreenUpdating = False '禁止弹出对话框 Application.DisplayAlerts = False '得到本文件的相对地址 mypath = ActiveWorkbook.Path '得到这个文件夹下的某个文件的文件名 myname = Dir(mypath &amp; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a4e673c37e7fe88d434f24cd03d89a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261d925ef818d90603e1230433b21602/" rel="bookmark">
			Android Q 不叫 Q，正式命名为 Android 10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据官方博文，谷歌已经公布了 Android Q 的名称，它并不像以前一样，以甜食命名，也不是以任何以字母 Q 开头来命名，而是简单称它为 Android 10。
该公司表示，正在改变其发布版本的命名方式。该公司写道：
这些年来，我们听到的很多反馈，我们的命名并不总是被全球社会中的每个人所理解。
谷歌说，改变命名的实际原因并不是 Q 很难找到实际的甜点名称，而是甜点不是很具包容性，比如馅饼并不总是甜点，棒棒糖在某些地区很难发音。棉花糖在很多地方甚至都不算甜点。
换句话说，以前的一些 Android 版本的名字虽然名字很有趣，但它们并不能与全部用户产生共鸣，该公司认为“是时候做出这种改变了”。
谷歌表示它将在几周内正式发布，除了对 Android 命名做改动之外，Android 10 中还增加了新的功能，不只是在 5 月份的谷歌 I/O 上发布的内容。它更新了移动平台的标志，它将文本从绿色改为黑色，以便于阅读，转换字体，并使用特写的机器人，现在是一种新的绿色。
Brand
Bubbles
正如下面的截图中所看到的，通过主动呼叫触发 Bubbles，一个小圆圈就会显示联系人的照片。在拖动 Bubbles 时，屏幕底部可以看到两个选项：Hide 和 End Call，只要将图标拖到任意一个选项都会触发该操作发生。点击一下 Bubbles，还会出现几个选项，比如启用扬声器或静音通话。
Wi-Fi 和 QR Code
Android 10 有一个新功能，允许您为 Wi-Fi 网络创建一个 QR 码，或者扫描一个 QR 码，就直接在设备的 Wi-Fi 设置中加入 Wi-Fi 网络。若要使用此新功能，需转到 Wi-Fi 设置，然后选择您的家庭网络，然后是共享按钮，上面有一个小 QR 码。这样避免了与人分享密码或询问别人密码的尴尬。
Undo app removal
使用 Android 10，在应用程序被删除几秒钟后，您还可以撤销更改，在屏幕底部找到“撤消”按钮，点击即可恢复应用程序。
隐私设置
Android 10，在设置应用程序有一个专门的隐私模块，打开它会显示应用程序对日历、位置、相机、联系人和麦克风等各种权限的要求，使找到和撤销特定应用程序的权限变得更加容易。
通知控制
选择 Alerting 将允许应用程序每一个新的通知发出声音，而 Silent 不会发出声音或手机振动。通过进入 Settings &gt; Apps &amp; notifications &gt; Notifications.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/261d925ef818d90603e1230433b21602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d60b782012864a903b1e4753b5385de1/" rel="bookmark">
			MySQL元数据获取基础笔记day05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多表连接查询 1、作用 业务需要的数据来自多张表时 2、多表连接查询基本语法 ??内连接
? 外链接
全链接
笛卡尔
3、内连接的类型 传统连接 where
自连接
join ming
join on ? ? ? ? ?
4、join on的语法 select xxx
from A
join B
on A.xxx=B.yyy
where
group
having
order by
limit
把原来的两张表按照一定的逻辑条件并成了一张表。
select a.name,b.addr from a join b on a.id=b.id where a.name='zhongsan';
如果是3张表 A B C
那么先A join C
on A.xx=C.yy
join B
on C.aa=B.bb
5、多表连接的套路： 1.根据需求找到关联表。
2.找到表与表的关联列。
3.列名调用时，需要添加表前缀，例如a.id ,b.name之类
多表连接案例 world表为例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d60b782012864a903b1e4753b5385de1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58b7ce7f322409fae78cf8ab6e7773d/" rel="bookmark">
			logback 日志压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		logback 日志压缩
最近服务器日志量 越来越大,一个小时就1G了，得想办法压缩一下。查看百度发现logback有压缩功能了。
使用很简单，直接在日志文件名称后面添加 “.gz”即可，如 logback.%d{yyyy-MM-dd.HH}.log.gz
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration debug="false"&gt; &lt;!--定义日志文件的存储地址--&gt; &lt;property name="LOG_HOME" value="./logs" /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 日志文件 --&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--文件的路径与名称,{yyyy-MM-dd.HH}精确到小时,则按小时分割保存--&gt; &lt;FileNamePattern&gt; ${LOG_HOME}/logback.%d{yyyy-MM-dd.HH}.log.gz &lt;/FileNamePattern&gt; &lt;!-- 如果当前是按小时保存，则保存72小时(=3天)内的日志 --&gt; &lt;MaxHistory&gt;72&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;Pattern&gt; %d{yyyy-MM-dd HH:mm:ss} -%msg%n &lt;/Pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!--myibatis log configure--&gt; &lt;logger name="com.winshang.xuanzhi.dao" level="DEBUG"&gt;&lt;/logger&gt; &lt;logger name="com.apache.ibatis" level="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58b7ce7f322409fae78cf8ab6e7773d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5473cc9c95bae9a489eb075ae093fc/" rel="bookmark">
			babel-plugin-import 插件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		babel-plugin-import是一款babel插件,在编译过程中将import的写法自动转换成按需引入的方式.
今天在使用react 的组件库ant-ui时候,想要引入babel-plugin-import插件实现按需加载,按照官网教程发现样式怎么都引入不进去.
记录一下自己的过程.
安装插件 npm install babel-plugin-import --save-dev ant-ui 上说我们可以在.babelrc or babel-loader option设置,这里我的配置是写在.babelrc里面的. 官网的写法是: { "plugins": [ ["import", { "libraryName": "antd", "libraryDirectory": "es", "style": "css" // `style: true` 会加载 less 文件 }] ] } 我按照这个写法配置在.babelrc之后,发现样式始终引不进去.查看官网发现原来是"libraryDirectory":"es"这里的问题,这里面默认是lib,我们需要把"es"换成"lib"即可. 下面给大家附上我.babelrc里面的代码,供大家参考.
{ "presets": ["react","es2015"], "plugins": [ [ "import", { "libraryName": "antd", "libraryDirectory": "lib", "style": "css" } ] ] } 另外给大家贴出babel-plugin-import插件的地址
https://github.com/ant-design/babel-plugin-import
这是官网上的截图
还有大家修改完配置文件记得一定要npm start重启一下哈,不重启的话配置不会生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd371c833134f3dea1c128aadbc7d0c1/" rel="bookmark">
			C#  常用控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、checkBox 复选框 属性 checkBox.Checked = true;
2、RadioButton 单选框 具有两个状态: true 或 false。RadioButton 是否已选择取决于其 Checked 属性的状态。在一个板块中的单选钮，只能选中一个
3、listbox 列表框 ，列表，所以只能一行一行的加入 滚动条 添加到列表框中，listBox.Items.Add(ans);
（1）跨线程添加 AddRemind（ans）；
private void AddRemind(string value) { if (this.InvokeRequired) { AddRemindDelegate d = new AddRemindDelegate(AddRemind); this.Invoke(d, value); } else { listBox_remind.Items.Add(value); listBox_remind.SelectedIndex = listBox_remind.Items.Count - 1; listBox_remind.ClearSelected(); } } （2）在listbox中的改变一行的字体颜色 和 显示 水平滚动条时，出现的问题
改变一行的字体颜色 ，首先这个属性设置为 ，然后再加增加一个事件进行每一行的绘制
private void listBox_TestInfo_DrawItem(object sender, DrawItemEventArgs e) { if (e.Index &gt;= 0) { e.DrawBackground(); Brush mybsh = Brushes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd371c833134f3dea1c128aadbc7d0c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67924e22febcdb5bb6da9e5e65d87905/" rel="bookmark">
			Linux初学者基本必备指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apt命令： apt-get install 安装包的名字（下载+安装）
apt-get remove 安装包的名字（移除）
apt-get purge 安装包的名字 （移除安装包和配置文件）
apt-get upgrade 安装包的名字 检查安装包是否有升级文件有则升级软件包
apt-get autoremove 自动删除不需要的包
如何安装ssh? sudo apt-get install openssh-server
查看服务是否启动：
ps -aux| grep ssh
服务启动 重启 关闭 sudo service ssh start
sudo service ssh stop
sudo service ssh restart
远程连接： 命令：port 端口
ssh-p 22 用户名@ip地址
软件连接： xshell,finalshell,putty…
linux的目录结构: home 普通用户的家
cd home 进入home目录
home：
cd 用户名
~：当前用户的家
/：根目录
pwd：查看当前所在位置
root：超级管理员目录
bin：常用命令
boot：启动文件和操作系统的核心文件
cdrom：光驱
dev：存放设备的目录
etc：系统的配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67924e22febcdb5bb6da9e5e65d87905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66195b657ca1abbf12580c1effd6918a/" rel="bookmark">
			（十) 循环神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 循环神经网络简介 循环神经网络为了刻画一个序列当前的输出与之前信息的隐藏层之间存在连接，隐藏层的输入来自于输入层的数据以及上一时刻隐藏层的输出。这样的结构使得循环神经网络会对之前的信息有所记忆，同时利用之前的信息影响后面节点的输出，所以循环神经网络不需要分别学习句子每个位置的所有语言特征规则。
如图展示了循环神经网络的一种典型结构，相比之前的网络，循环神经网络更加注重“时刻”的概念。途中 O 表示循环神经网络在时刻 t 给出的一个输出， x 表示在时刻 t 循环神经网络的输入， H 是循环神经网络的主体结构，循环的过程就是 H 的不断被执行。
在 t 时刻，H 会读取输入层的 输入 x, 并输出一个值 o ，同时 H 的形态值会从当前步传递到下一步。也就是说， H 的输入除了来自输入层的输入数据 x ，还来自于上一时刻 H 的输出。
2 循环神经网络的前向传播程序设计 卷积神经网络中也存在着参数共享，这和循环神经网络是类似的。循环神经网络可以看作是某一神经网络结构 在时间序列伤被执行多次的结果。使用循环神经网络解决实际问题时，关键就是如何合理地设计循环体的网络结构。
以下代码使用numpy实现了上述简单循环神经网络前向传播的计算过程：
import numpy as np #定义相关参数,init_state是输入到t1的t0时刻输出状态 x = [0.8, 0.1] init_state = [0.3, 0.6] W = np.asarray([[0.2, 0.4], [0.7, 0.3]]) U = np.asarray([0.8, 0.1]) b_h = np.asarray([0.2, 0.1]) V = np.asarray([[0.5], [0.5]]) b_o = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66195b657ca1abbf12580c1effd6918a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316342318fe7b57bcf9e2707c0ef5b61/" rel="bookmark">
			利用 Math.random() 实现通过随机数产生随机的颜色，一秒钟切换一个颜色最简单的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;随机产生颜色&lt;/title&gt; &lt;style&gt; div { width: 200px; height: 200px; border-radius:50%; left: 0; right:0; top:0; bottom: 0; margin: auto; position: absolute; } &lt;/style&gt; &lt;script&gt; function getColor() { var str = "#"; //定义一个十六进制的值的数组 let arr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]; // 遍历循环产生 6 个数 for (var i = 0; i &lt; 6; i++) { //随机产生 0~15 的个索引数,然后根据该索引找到数组中对应的值,拼接到一起 let lut = parseInt(Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316342318fe7b57bcf9e2707c0ef5b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33fcee40b343d3331a166af945009cfd/" rel="bookmark">
			GitHub博客地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub博客地址 GitHub博客地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec3ee756cdcfa8b363fd6c8ba09d71b/" rel="bookmark">
			JLink 警告：The connected J-Link is defective,Proper operation cannot be guaranteed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 安装j-link较新版本（JLink_Windows_V632b.exe）的驱动，每烧录一次程序报一次警告，警告如下：“The connected J-Link is defective, Proper operation cannot be guaranteed.”参考网友的博客和使用方法，卸载新版本的驱动，采用低版本的驱动（JLink_Windows_V502f.exe)解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8698dbb1dbbd20c76188a0e8a06b56f3/" rel="bookmark">
			手把手教你脑电波采集及信号处理分析 - 知乎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分两个PART，第一个讲采集，第二个讲处理。
Part one:
脑电，心电，肌电，眼电等，都是身体上两点的电压差，和我们测电池的电压本质上没有区别。
随便在头上两个位置放两个电极，一正一负，放大uV信号（其他脑电信号特征，如频段，干扰源等感兴趣可自行百度）,测量其电势差。
但我们通常需要加一个右腿驱动电极，比如在乳突，这是为什么呢？先用专业的话：
共模输入电压会影响输入差分对的偏置点。由于输入电路固有的不匹配，偏置点的改变会引起输入失调典雅的改变，进而引起输出电压的改变。不要心里MMP，这就说人话。请看下面这张图：以心电为例，脑电原理一样。
假设共模干扰是图中的A，有用的ECG信号为B，则我们很有可能采到的是A+B,所以我们要把A抵消掉，反馈到身体上一个负A的信号。这样我们抑制了大部分的共模信号，就得到B了。
右腿驱动详细电路及仿真：参考TI Matthew Hann 的文章：(温馨提醒：为保证后续阅读，手机用户长按松开拷贝地址到浏览器打开为宜)
http://www.cnblogs.com/myohao/p/8538685.html
另外附上采集电路的框图：
附开源电路图：
这个电路难者不会，会者不难。搞算法的可以不做了解。实在想自己做，可以去买专门脑电模块，名字我就不说了，广告嫌疑。我当时买的几十块钱一片，挺划来。
Part two:
采集完的数据保存下来，形成数据库。
以下放上外国人研究常用的数据库
(温馨提醒：为保证后续阅读，手机用户长按松开拷贝地址到浏览器打开为宜)
http://www.cnblogs.com/myohao/p/8538740.html
生理信号数据常用的格式为edf，而matlab常用的是mat,txt。
假设聪明的你已经在数据库里下载了edf格式的数据。不妨先了解下EDF格式具体内容：
HEADER RECORD
8 ascii : 数据格式的版本
80 ascii : 被试ID
80 ascii : 数据记录编号
8 ascii : 开始记录的日期 (dd.mm.yy) 8 ascii : 开始记录的时间 (hh.mm.ss) 8 ascii : 头比特数
44 ascii :保留给EDF+
8 ascii : 初始值-1，结束时被赋其他值
8 ascii : 数据持续记录时间，s 4 ascii : 记录几种信号种类
ns * 16 ascii : 电极位置，体温等信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8698dbb1dbbd20c76188a0e8a06b56f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800290e572c264e8042b5ccb610c3e87/" rel="bookmark">
			请求报错net::ERR_ABORTED 404 (Not Found)，并且报跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天系统在使用过程中，突然请求报错net::ERR_ABORTED 404 (Not Found)
并且报错No 'Access-Control-Allow-Origin' header is present on the requested resource
之前是没有出现过这种情况的，
然后在本地测试，发现没有问题，
又想到原来使用的是http，现在改成https的原因所以报的跨域，但是请求只是涉及数据的返回
后来又想会不会是请求超时报的404，因为这是个图片模型测试功能，涉及文件的处理，并且只有在多文件上传的时候会发生错误，
又问了一下部署的同事，线上版本部署使用了nginx，所以让加大一下nginx的 keepalive_timeout的时间
========
是因为看到这个博客才想到是不是nginx超时：
https://www.cnblogs.com/wujf-myblog/p/10836954.html
使用nginx服务器如果遇到timeou情况时可以如下设置参数，使用fastcgi：
fastcgi_connect_timeout 75; 链接
fastcgi_read_timeout 600; 读取
fastcgi_send_timeout 600; 发请求
这两个选项.
fastcgi_read_timeout是指fastcgi进程向nginx进程发送response的整个过程的超时时间
fastcgi_send_timeout是指nginx进程向fastcgi进程发送request的整个过程的超时时间
然后加大
keepalive_timeout 600; 连接超时时间，1分钟，具体时间可以根据请求（如后台导入等场景）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ba2823b1eb8cf18d0fb02e743c18d78/" rel="bookmark">
			CommonJS模块和ES6模块的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CommonJS
1.对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。
2.对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。
3.当使用require命令加载某个模块时，就会运行整个模块的代码。
4.当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。
5.循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。
ES6模块
1.ES6模块中的值属于【动态只读引用】。
2.对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
3.对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。
4.循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。
上面说了一些重要区别。现在举一些例子来说明每一点吧
CommonJS
对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。
// b.js let count = 1 let plusCount = () =&gt; { count++ } setTimeout(() =&gt; { console.log('b.js-1', count) }, 1000) module.exports = { count, plusCount } // a.js let mod = require('./b.js') console.log('a.js-1', mod.count) mod.plusCount() console.log('a.js-2', mod.count) setTimeout(() =&gt; { mod.count = 3 console.log('a.js-3', mod.count) }, 2000) node a.js a.js-1 1 a.js-2 1 b.js-1 2 // 1秒后 a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ba2823b1eb8cf18d0fb02e743c18d78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02fdc0348de5a4c35cc8df13e8e572aa/" rel="bookmark">
			iOS 12.4 越狱 unc0ver 已经支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天 unc0ver 3.5.0 发布，支持 iOS 12.4 越狱。12.4 目前为最新版的系统。
下载地址：https://github.com/pwn20wndstuff/Undecimus/releases/tag/v3.5.0
Last updated at: 08/18/2019
08/18/2019 - v3.5.0 was released for production with the following changes:
Add iOS 12.4 support to the Sock Puppet (A8-A11) and Sock Port (A7-A7X) exploits
越狱方法可以参考：https://www.ioshacker.net/thread-13-1-1.html
原文地址：https://www.ioshacker.net/thread-137-1-1.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/229/">«</a>
	<span class="pagination__item pagination__item--current">230/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/231/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>