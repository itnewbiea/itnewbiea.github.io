<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182cabbb153dcc57713868c97e550dda/" rel="bookmark">
			django related_query_name和related_name的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Django中，related_name 和 related_query_name 都用于自定义反向查询时使用的名称，但它们的作用和使用场景有所不同：
related_name
作用：当一个模型通过 ForeignKey、ManyToManyField 或其他关联字段引用另一个模型时，Django会自动创建一个反向查询器属性。例如，如果模型A有一个指向模型B的外键，那么默认情况下，可以从模型B的对象上通过类似 &lt;model_A&gt;_set 的方式来访问所有与之关联的模型A对象。related_name 就是用来重命名这个反向查询器属性。示例： class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=200) author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books') 在这个例子中，可以通过 author.books.all() 来获取某个作者的所有书籍，而不再是默认的 author.book_set.all()。
related_query_name
作用：主要应用于 ManyToManyField 的情况，并且是在生成查询表达式（query expression）时使用的别名。related_query_name 用来指定在关联查询时，作为查询表达式一部分的字段名称。示例： class Tag(models.Model): name = models.CharField(max_length=50) class Article(models.Model): title = models.CharField(max_length=200) tags = models.ManyToManyField(Tag, related_name='articles', related_query_name='tagged_articles') 在这个例子中，虽然可以通过 tag.articles.all() 访问到给定标签关联的所有文章，但当我们使用查询表达式时，比如在过滤Article时，可以这样写： Article.objects.filter(tagged_articles__name='my_tag') 这里，tagged_articles 是由 related_query_name 指定的查询表达式中的字段名。 总结来说，related_name 更侧重于直接的反向关系查询，而 related_query_name 则更多地关注于查询表达式构建以及在查询语句中更自然地表示这种关联关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5edd3fd900aedaf3bffa77eb66ec2c5d/" rel="bookmark">
			Flutter computer 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系统 API：computer 函数:
我们自己 new 一个 Isoalte 并实现通讯，多少有点麻烦，从封装的角度看其中代码基本是重复的，所以 Google 就提供了一个 API 来干这事：compute 方法
compute 方法是 Flutter 提供给我们的(记住不是 Dart)，compute 内部会创建一个 Isolate 并返回计算结果，体验上和一次性线程一样，性能多少有些浪费，但是也有使用范围
compute(function，value) compute 函数接受2个参数，第一个就是新线程的核心执行方法，第二个是传递过新线程的参数，可以是任何类型的数据，几个也可以，但是要注意，function 函数的参数设计要和 value 匹配
compute 方法在 import ‘package:flutter/foundation.dart’ 这个包里面.
看例子：
import 'dart:io'; import 'dart:isolate'; import 'package:flutter/foundation.dart'; void newTask() async { print("开始耗时计算，当前 isolate = ${Isolate.current.toString()}"); var result = await compute(getName, "name"); print(result); } String getName(String name) { print("正在获取结果中...,当前 isolate = ${Isolate.current.toString()}"); sleep(Duration(seconds: 2)); return "Name"; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b621a5cc09375c0fec15b2c8830cd347/" rel="bookmark">
			讲解机器学习中的 K-均值聚类算法及其优缺点。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K-均值聚类算法是一种常见的无监督学习算法，用于将数据集中的观测点分成 K 个不同的组或簇。它是一种迭代算法，通过计算每个观测点与 K 个中心点的距离，并将每个观测点分配到距离最近的中心点所属的簇中。
算法步骤如下：
初始化 K 个中心点，可以是数据集中的随机点或通过其他方式选择。将每个观测点分配给离它最近的中心点所属的簇。对每个簇，重新计算中心点，将其设为簇中所有观测点的平均值。重复步骤 2 和步骤 3，直到簇分配稳定或达到预定的迭代次数。 K-均值聚类算法的优点包括：
简单易实现：算法简单直观，易于理解和实现。可扩展性：算法的时间复杂度为 O(n K d)，其中 n 是数据点的数量，K 是簇的数量，d 是数据点的特征维度。因此，算法在处理大规模数据时具有良好的可扩展性。可解释性：算法结果是一组划分好的簇，每个簇都有一个中心点，可以帮助我们理解数据的内在结构。 然而，K-均值聚类算法也有一些缺点：
对初始聚类中心点的选择敏感：不同的初始聚类中心点可能会导致不同的最终结果，因此，算法对初始聚类中心点的选择非常敏感。对异常值敏感：算法的结果受到异常值的影响，异常值可能会被错误地分配到某个簇中，导致簇的质量下降。需要指定簇的数量：算法需要预先指定簇的数量 K，但实际应用中很难事先确定一个合适的 K 值。对数据分布的假设：算法假设所有簇具有相同的方差，并且簇的形状是球形的。如果数据的分布不符合这些假设，算法的效果可能会下降。 综上所述，K-均值聚类算法是一种简单、易于理解和实现的聚类算法，适用于大规模数据集。但它对初始聚类中心点的选择敏感，对异常值敏感，并且需要预先指定簇的数量。因此，在应用时需要谨慎选择合适的参数和输入数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5217286f8aa82384a72cc5e8950d0ccf/" rel="bookmark">
			Android studio报错误提示 Some Kotlin libraries attached to this project 问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个蛮有意思的人工智能学习网站,8个字形容一下"通俗易懂，风趣幽默"，感觉非常有意思,忍不住分享一下给大家。
👉点击跳转到教程
Android新建项目后，报以下错误
错误提示内容为：
这个项目附带的一些Kotlin库是用更新的Kotlin编译器编译的，无法读取。请更新Kotlin插件。
根目录的build.gradle内容为：
// Top-level build file where you can add configuration options common to all sub-projects/modules. buildscript { ext.kotlin_version = "1.4.32" repositories { google() jcenter() } dependencies { classpath "com.android.tools.build:gradle:4.1.3" classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version" // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { google() jcenter() } } task clean(type: Delete) { delete rootProject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5217286f8aa82384a72cc5e8950d0ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc6d2b49c83392bd65256b24be4fe2d/" rel="bookmark">
			C&#43;&#43;中string的库函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		山再高，往上攀，总能登顶！
路再长，走下去，定能到达！
🎥烟雨长虹，孤鹜齐飞的个人主页
🔥个人专栏c++
期待小伙伴们的支持与关注！！！
目录
前言：
string的简介
​编辑
string的组成
string的功能
string的基本用法
string的声明与初始化
声明一个空字符串：
字符串的初始化：
运行效果：
string的库函数
主要的功能：
&lt;1&gt;length函数：
函数声明#
函数使用#
&lt;2&gt;find函数：
函数声明#
函数使用#
&lt;3&gt;append函数：
函数声明#
函数使用#
&lt;4&gt;replace函数：
函数原型#
函数声明#
函数使用#
&lt;5&gt;substr函数：
函数原型#
函数声明#
函数使用#
&lt;6&gt;compare函数：
函数声明#
函数使用#
扩展#
遍历string的方法 string的插入和删除
insert函数：
函数原型#
函数使用#
push_back函数：
函数使用#
erase函数：
函数原型#
函数使用#
总结：
前言： 为什么学习 string ？ （1）C 语言中，字符串是以 ' \0 ' 结尾的一些字符的集合，为了操作方便， C 标准库中提供了一些 str 系列的库函数， 但是这些库函数与字符串是分离开的，不太符合OOP 的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。 （2） 在 OJ 中，有关字符串的题目基本以 string 的形式出现，而且在常规工作中，为了简单、方便、快捷，基本都使用string ，很少有人去使用 C 库中的字符串操作函数。 string的简介 string的组成 &lt;1&gt;string是C++标准库的重要组成部分，主要用于字符串处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc6d2b49c83392bd65256b24be4fe2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/012e33a42bccef1704bdee70c53a09c4/" rel="bookmark">
			华为欧拉安装部署：Oracle11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 1、下载安装低版本的libaio包；libaio版本太高，会造成编译错误 查看libaio1库版本不能大于0.3.109
[oracle@s3 install]$ rpm -qa libaio libaio-0.3.110-12.el8.x86_64 # 查看欧拉操作系统版本 [oracle@localhost bin]$ cat /etc/os-release NAME="openEuler" VERSION="22.03 (LTS-SP1)" ID="openEuler" VERSION_ID="22.03" PRETTY_NAME="openEuler 22.03 (LTS-SP1)" ANSI_COLOR="0;31" # 下载 wget http://mirrors.ustc.edu.cn/centos/7.9.2009/os/x86_64/Packages/libaio-0.3.109-13.el7.x86_64.rpm # 备份原来的libaio.so.1 mv /usr/lib64/libaio.so.1.0.1 /usr/lib64/libaio.so.1.0.120240103 # 解压 rpm2cpio libaio-0.3.109-13.el7.x86_64.rpm |cpio -idmv # 把解压后的文件拷贝到/usr/lib64下 cp -r /root/lib64/libaio.so.1 /usr/lib64 mv /root/lib64/libaio.so.1.0.1 /usr/lib64 2、修改系统时间 [root@localhost ~]# date -s “2022-05-09 09:11:40” [root@localhost ~]# hwclock -w 3、修改host，绑定主机名 修改 vim /etc/hosts文件
[root@localhost ~]# hostname localhost.localdomain [root@localhost ~]# vim /etc/hosts 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/012e33a42bccef1704bdee70c53a09c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96cf51ea057ab05ec369a70e971aa80b/" rel="bookmark">
			shell脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell注释 链接
shell文件中编程的作用 就是linux操作命令，运行.sh文件相当于执行linux命令。
.sh就是命令集文件。
shell文件的建立 vi xxx.sh
shell脚本执行四种方式 1，bash xxx.sh 在当前终端启动一个进程去执行脚本
2，./xxxx.sh 新建的文件是没有执行权限的
需要文件有执行权限(x),同样会启动一个子进程执行shell脚本
chmod u+x xxx.sh
3，source xxx.sh 不会启动子进程执行脚本，当前进程终端执行脚本
4，. xxx.sh 不会启动子进程执行脚本，当前进程终端执行脚本
3,4会影响当前终端进程
因为以上原因，使用不同方法操作$0，会得出两种结果。
linux删除键，上下左右变字母 没有vim，下载vim就行
字符串 判断字符串是否为整数 shell命令如果有问题，会提示，但是不会退出脚本的执行。
&amp;&gt; /dev/null------表示不保留任何输出 expre length 字符串----计算字符串长短 shell中的true和false true和false是shell中的命令。
执行true-----返回成功状态码0
执行false-----返回失败状态码1
数值和退出状态码 数值就是状态码吗 不是
在 Shell 中，作为数字，任何值都是真；作为状态码，0 表示真，非 0 表示假。
变量 定义：name=wu
等号两遍不能有空格
变量三种赋值方法 变量名=value #＜==赋值时不加引号
变量名='value' #＜==赋值时加单引号
变量名="value" #＜==赋值时加双引号
字符串中不适用引号，使用单引号，双引号的区别 主要是对字符串中变量和命令的操作不同
字符串中有变量 字符串如果有空格，必须使用引号
不适用引号和使用双引号-----会解析出变量的值
使用单引号-----不会解析变量值，原样输出
变量解析出字符串需不需要加引号的问题 如果字符串中含有空格，那么对变量解析就需要加上引号
如上，如果变量不加引号，解析出来的变量含有空格，就变量了两个字符串。
字符串中有命令替换 字符串如果有空格，必须使用引号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96cf51ea057ab05ec369a70e971aa80b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74430c24dbf05b0296827c448e40b8df/" rel="bookmark">
			原生小程序自定义导航及状态栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		app.json 组件 "usingComponents": { "page": "./component/page/index", "paging": "./component/paging/index", "t-nav-bar": "./itriton/nav-bar/index", "t-divider": "./itriton/divider/index" }, nav-bar/index.wxml &lt;view style='height:{{navHeight + status}}px;'&gt; &lt;cover-view class='nav-bar-wrap' style='padding-top:{{ status }}px;{{containerStyle}}'&gt; &lt;cover-view class='nav-bar' style='height:{{navHeight}}px;{{containerStyle}};'&gt; &lt;cover-view class='{{"nav-bar-btn_icon_"+type}}' style='height:32px;width:81px;background:{{btnColor}}' wx:if='{{visible}}'&gt; &lt;cover-view class='nav-bar-go_back' catchtap='bindToBack'&gt; &lt;cover-image src='{{"./icons/back-"+type+".png"}}' class='nav-bar-img'&gt;&lt;/cover-image&gt; &lt;/cover-view&gt; &lt;cover-view class='{{"nav-bar-mid_line_"+type}}'&gt;&lt;/cover-view&gt; &lt;cover-view class='nav-bar-go_home' catchtap='bindToHome'&gt; &lt;cover-image src='{{"./icons/home-"+type+".png"}}' class='nav-bar-img'&gt;&lt;/cover-image&gt; &lt;/cover-view&gt; &lt;/cover-view&gt; &lt;cover-view class="nav-bar_left" style="height:32px;width:81px;" wx:if="{{left}}"&gt; &lt;cover-image class="nav-bar__img" src="{{left}}" bindtap="leftClick"&gt;&lt;/cover-image&gt; &lt;/cover-view&gt; &lt;cover-view class='nav-bar-title absolute' style='line-height:{{navHeight}}px;{{textStyle}}'&gt;{{title}}&lt;/cover-view&gt; &lt;/cover-view&gt; &lt;/cover-view&gt; &lt;/view&gt; index.js // pages/nav-bar/nav-bar.js Component({ options: { multipleSlots: true }, properties: { background: { type: String, value: 'rgba(255, 255, 255, 1)' }, type: { type: String, value: 'light' }, btnColor: { type: String, value: 'rgba(255, 255, 255, 1)' }, textColor: { type: String, value: 'rgba(0, 0, 0, 1)' }, title: { type: String, value: '' }, visible: { type: Boolean, value: true }, left: { type: String, value: '' } }, lifetimes:{ ready() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74430c24dbf05b0296827c448e40b8df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dddadfc80383e43c43022369eed0729/" rel="bookmark">
			K8S POD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pod是k8s中最小的资源管理组件
pod也是最小运行容器化的应用的资源管理对象
pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合
在一个pod当中运行一个容器是最常用的方式。
在一个pod当中可以同时运行多个容器，在一个pod当中可以同时封装几个需要耦合的互相协作的容器
这些多个容器共享资源，也可以互相协作组成一个service单位
不论运行一个容器还是多个容器，K8S管理的都是pod而不是容器
一个pod内的容器，必须都运行在同一节点上。基于现代容器技术的要求，一个pod运行一个容器，一个容器只运行一个进程。
横向扩展，方便扩缩容
解耦，一个pod内运行多个容器，耦合度太高，一旦一个进程失败，整个pod将全部失败。实现解耦，基于pod可以创建多个副本，实现高可用，负载均衡
管理方便，简单直观
pod内的容器共享资源。共享机制：pause底层基础容器来提供共享资源的机制
pause是基础容器，也可以称为父容器。管理pod内容器的共享操作
pause还可以管理容器的生命周期
k8s提供了pause容器
1、为pod内的所有容器提供一个统一的命名空间
2、启动容器的pid命名空间，每个pod中都作为pid为1的进程（init进程），回收僵尸进程
3、创建pod时，先创建pause容器，然后拉取镜像，生成容器，最后形成pod
pod里面是容器，容器运行的是进程 pid
pause父进程 1 在pod内部管理容器进程
pause容器共享两种资源
网络：每个pod都会被分配一个集群内部的唯一ip地址，pod内的容器共享网络，POD在集群内部的ip地址和端口
pod内部的容器可以使用localhost互相通信，pod中的容器与外部通信时，从共享的资源当中进行分配。宿主机的端口映射
存储
pod可以指定多个共享的volume,pod内的容器共享这些vloume。
vloume可以实现数据的持久化
防止pod重新构建之后文件消失
总结：
每个pod都有一个基础容器pause容器
pause容器对应的镜像属于k8s集群的一部分。创建集群就会有pause这个基础镜像
pod里面包含了一个或者多个相关的容器（应用）
pod外再设置一个基础镜像：
pod内部有一组容器，挂了一个，就算这个pod失效了么？引入pause禁止，代表整个容器的组的状态
可以解决对pod内部容器整体状态的判断
pod内的容器共享IP，共享volume，解决了容器内网络通信的问题，解决了容器内部文件共享的问题
pod的分类：
自主式pod：pod不会自我修复，pod内容器的进程终止，被删除，缺少资源被驱逐，这个pod没有办法自愈
deployment daemanset
控制器管理pod：滚动升级，可以自愈（自动重启），可以管理pod的数量以及pod的扩缩容
pod的生命周期：
1、pending 挂起状态
pod已被创建，但是尚未分配到运行他的node节点 （节点资源不够，需要等待其他pod的调度）
2、running 运行中 pod已经被分配到了运行节点 ，pod内部所有的容器都已经启动，运行状态正常，稳定
3、complete：容器内部的进程已经运行完毕，正常退出，未发生错误
successded:
4、faild：pod中的容器非正常退出。发生了错误，需要通过查看详情和日志来定位问题
5、UNkown:由于某些原因，k8s集群无法获取pod的状态，APIserver出了问题
6、terminating：终止中 正在被终止，还未终止 pod正在被删除，里面的容器正在终止，终止过程中，资源回收，垃圾清理，以及你终止过程中需要执行的一些命令
7、
存活探针和流量探针会伴随整个pod的生命周期，如果容器出了问题，pod将不再是ready状态
创建pod的容器分类：
1、基础容器：pause
2、init容器(初始化容器)：init c
1和2这个过程中.pod的状态就叫init：0/3 1/3 2/3 3/3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dddadfc80383e43c43022369eed0729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e5db487223f4cce73fa56726e6d9d6/" rel="bookmark">
			域名流量被劫持怎么办？如何避免域名流量劫持？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网不断发展，流量成为线上世界的巨大财富。然而一种叫做域名流量劫持的网络攻击，将会在不经授权的情况下控制或重定向一个域名的DNS记录，导致用户在访问一个网站时，被引导到另一个不相关的网站，从而劫持走原网站的流量。域名流量劫持不仅会对企业造成形象受损及交易下降的影响，对用户也有可能带来隐私数据泄露和财产损失的后果。那么什么是域名流量劫持呢？如何避免域名流量劫持？下文为你揭晓。
域名流量劫持是什么？
域名流量劫持是一种常见的网络攻击方式，包括完全重定向，部分重定向和解析欺骗。攻击者通过修改DNS解析或者本地hosts文件等方式，把目标服务器网站域名解析到错误地方，让用户无法正常访问真正的地址。通过这种方式，攻击者可以获取用户的敏感信息，例如账号密码、信用卡信息等。同时，他们也可能会将用户引导到包含恶意代码的网站上，使用户的计算机感染病毒或者恶意软件。
如何避免域名流量劫持呢？
想要避免域名流量劫持，除去通过使用安全的域名注册商来保护DNS记录，还可以采取以下措施：
使用可信赖的DNS服务器
建议使用ISP或者网络运营商提供的DNS服务器。
定期检查hosts文件
如果您发现hosts文件中有不明条目或者异常信息，请将其删除或者禁用。
避免使用公共Wi-Fi热点
攻击者可以通过Wi-Fi热点来劫持流量，因此建议使用密码保护的Wi-Fi热点或者使用VPN等加密通信方式来保护数据传输的安全性。
使用HTTPS协议
HTTPS协议可以提供数据传输的加密和认证功能，能有效防止数据被篡改和窃取。
尽管域名流量劫持这种攻击方式已经十分常见，但是一旦中招，不论是对于用户还是企业，都将造成严重的后果。因此采取恰当的预防措施以确保域名和网站安全非常重要。如您还有其他疑问和需求，请联系我们获得支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1319f5baf5eb80d8890cf465c7b61564/" rel="bookmark">
			JavaScript排序算法大解密 - 冒泡、选择、插入、快速排序全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢 鸿蒙专栏：想学鸿蒙的，冲
📢 C语言专栏：想学C语言的，冲
📢 VUE专栏：想学VUE的，冲这里
📢 CSS专栏：想学CSS的，冲这里
📢 Krpano专栏：想学VUE的，冲这里
🔔 上述专栏，都在不定期持续更新中！！！！
目录
✨ 前言
冒泡排序
选择排序
插入排序
快速排序
✨ 结语
✨ 前言 排序是计算机科学中一个经典的问题。良好的排序算法可以大大提高程序的性能。本文将全面解析几种JavaScript中的经典排序算法实现,包括冒泡排序、选择排序、插入排序和快速排序。通过示例代码和逻辑说明,你将学会这些排序算法的基本思路,时间和空间复杂度,以及如何在JavaScript中实现。排序算法的精妙之处在于充分利用数据结构,通过巧妙的交换与比较来完成排序,值得每一位计算机从业者细细品读。本文将由浅入深,从排序原理说明到具体代码实现,帮你深入掌握这些精巧的算法。相信通过学习本文,你将可以熟练掌握各类排序算法的JS实现,在未来的编程工作中运用自如,对于提升你的数据结构与算法能力大有裨益。那么,让我们开始JavaScript排序算法的奥秘之旅吧!
冒泡排序 function bubbleSort(arr) { for (let i = 0; i &lt; arr.length; i++) { for (let j = 0; j &lt; arr.length - i - 1; j++) { if (arr[j] &gt; arr[j+1]) { let temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } return arr; } let arr = [5, 2, 4, 6, 1, 3]; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1319f5baf5eb80d8890cf465c7b61564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a3189fc1769fa59408ef931b69311cd/" rel="bookmark">
			在Uniapp中使用Echarts创建可视化图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在uniapp中可以引入echarts创建数据可视化图表。
1. 安装Echarts 使用npm安装echarts插件，命令如下：
npm install echarts --save 2. 引入Eharts 在需要使用Echarts的页面引入：
import *as echarts from 'echarts' 3. 创建实例 创建画布元素：
&lt;view id="chart" style="width: 100%;height: 300px;"&gt;&lt;/view&gt; 配置图表：
&lt;script&gt; import * as echarts from 'echarts'; export default { data() { return { }; }, onReady() { this.initChart(); }, methods: { initChart() { let chartDom = document.getElementById("chart"); let myChart = echarts.init(chartDom); const option = this.getChartOption(); option &amp;&amp; myChart.setOption(option); }, getChartOption() { const dataList = [{ name: '周一', value: '120' }, { name: '周二', value: '200' }, { name: '周三', value: '150' }, { name: '周四', value: '80' }, { name: '周五', value: '70' }, { name: '周六', value: '110' }, { name: '周天', value: '130' } ] const option = { xAxis: { type: 'category', data: dataList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a3189fc1769fa59408ef931b69311cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e44ead90ecedc77c6638ec429bc380/" rel="bookmark">
			ARCGIS PRO SDK Geoprocessing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用原型： Dim gpResult AS IGPResult = await Geoprocessing.ExecuteToolAsync(调用工具名称, GPValue数组, environment, null, null, executeFlags) 一、调用工具名称：地理处理工具名称。如面转线：management.PolygonToLine，而非PolygonToLine_management 确认要传入的工具名称就要借助ArcGIS Pro桌面软件、帮助甚至ArcObjects SDK中对应工具的定义。可以先在ArcGIS Pro桌面软件上找到该工具，并打开，如下图所示。 ​ 点击右上角？号，可以进入该工具的帮助页面，如下图所示。
​ 其中红框中的内容就是工具的名称，我们通过ArcGIS Pro sdk调用的时候，传入该名即可。
二、GPValue数组：MakeValueArray方法用于创建一个GPValue数组，传递多个参数给地理处理工具。 Dim GPValue As IReadOnlyList(Of String) GPValue = Geoprocessing.MakeValueArray(inputPath, outputPath, "IDENTIFY_NEIGHBORS") 三、environment：重点关注输出是否覆盖。 Dim environments = Geoprocessing.MakeEnvironmentArray(overwriteoutput:=True) '允许输出时同名文件覆盖 五、executeFlags：重点关注输出时是否添加到地图中。 Dim executeFlags As GPExecuteToolFlags = GPExecuteToolFlags.AddOutputsToMap 六、IGPResult 接口 Geoprocessing.ExecuteToolAsync 返回的地理处理工具结果对象 公共属性： 名字描述Environments在工具执行中本地使用的地理处理环境。Tuple.Item1 - 名称Tuple.Item2 - 数据类型Tuple.Item3 - 值ErrorCode工具执行结果错误码：0 ： 成功（工具执行时没有任何错误）not 0 ：工具失败或被取消。ErrorMessages返回错误消息 - 请参阅下面的代码示例：HasWarnings如果工具在执行时出现任何警告，则为 True。IsCanceled如果工具执行在完成之前被取消，则为 True。IsFailed当工具失败或取消时为 True。Messages所有输出消息。 若要仅筛选一种类型的消息，请使用 GPMessageType （Warning， Error） - 请参阅下面的代码示例。ParametersTuple.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e44ead90ecedc77c6638ec429bc380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a1f57251ebd61ec5a2c160a0a8fcb1/" rel="bookmark">
			怎样找回电脑回收站已清空的文件？3招轻松恢复！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“由于我电脑总是空间不足，我会定期对回收站进行清空操作，但是今天突然发现有些重要的文件放入回收站中并且被清空了，这可怎么办呢？有什么方法可以找回这些重要的数据吗？” 在Windows系统中，回收站是一个用于存储被删除文件的文件夹。在文件被误删时，回收站可以帮助我们快速恢复文件。但是如果回收站也被清空了呢？
怎样找回电脑回收站已清空的文件呢？有几个比较简单有效的方法，有需要的用户快来试试吧！
方法一：借助快捷键撤销删除 电脑回收站被清空了还能找回吗？如果在清空回收站后，用户突然就意识到了有重要的文件也被删除了，此时建议先停止一切操作，并迅速按下快捷键【Ctrl＋z】，看看是否能撤销上一步的操作。但要注意，如在清空回收站后还进行了其他操作，是无法通过该方法完成重要文件恢复的。
方法二：借助备份恢复文件 不小心把回收站清空了怎么恢复？如果用户有备份的习惯，在文件删除之前曾对重要的文件进行过备份，那么，借助备份恢复回收站数据是比较有效且方便的。
第1步：找到备份文件所在的设备或云端；
第2步：将需要恢复的文件重新保存在电脑上，并检查文件是否能正常查看。
方法三：借助专业软件恢复数据 对于大部分用户来说，在没有备份且回收站被清空的情况下，数据恢复或许比较困难。那么这时候，怎样找回电脑回收站已清空的文件比较好呢？建议大家使用专业的数据恢复软件。比如 数 据 蛙 恢 复 专 家 。借助软件专业的扫描和恢复功能，用户有更多的机会找回重要的文件。
并且，该软件支持多种类型数据的扫描和恢复，如果不确定是否能找到需要恢复的文件，还可以先进行免费扫描。软件的操作比较简单，用户可以下载软件后，按照下方的步骤进行操作。
操作环境： 演示机型：华硕TUF Dash FX516PM 系统版本：Windows10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 第1步：运行软件后，新用户点击【免费试用】即可进入软件中；
第2步：在软件中对需要扫描的文件类型进行选择（首次扫描的用户建议全选），并勾选上【回收站】，然后点击【扫描】；
第3步：等待首次扫描结束，用户可以点击按【类型】或【路径】对结果进行查看和选择，如果这次扫描只呈现了少部分数据，可以点击【深度扫描】；
第4步：等待深度扫描结束，软件会将所有有机会恢复的文件都呈现出来，此时用户可点击【筛选器】，输入相应的条件后可快速定位到需要恢复的文件；
第5步：完成选择后，点击【导出】，并选择一个与扫描磁盘不同的磁盘作为文件恢复后文件的保存位置。
回收站为用户找回误删的数据提供了很大的方便，当然不可否认的是，它也会占用我们电脑的内存。如果需要对回收站进行清空操作，建议用户先确认好文件是可以删除的，否则容易误删重要文件。怎样找回电脑回收站已清空的文件呢？上文已经为大家总结了详细的方法啦！快去试试吧！
往期推荐：
如何查看电脑使用记录？分享4个可行方法！https://blog.csdn.net/datarecover/article/details/135378882?spm=1001.2014.3001.5501
U盘数据恢复软件，高效恢复数据记好这2款！https://blog.csdn.net/datarecover/article/details/135379670?spm=1001.2014.3001.5501
找回删除文件如何操作？记得收藏好这3个有效方法！https://blog.csdn.net/datarecover/article/details/135378265?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27773082fce0c2938decb800286655c3/" rel="bookmark">
			Weblogic安全漫谈（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑名单机制必然会推动两种研究方向的发展：一是挖掘不在黑名单的新组件，是为绕过规则；二是发掘检查的盲区，是为绕过逻辑。
CVE-2020-14756 二次反序列化具有对抗检查逻辑的天生丽质，在CVE-2018-2893中就有利用字节数组和反射重建类两种方式。找找还有没有readObject到Class.forName的路子：
readUnsignedByte读到的nType为9或10时会进入readXmlSerializable或readExternalizableLite分支。
上述两个方法均通过自身loadClass方法加载类，最终由Class.forName获取类并返回。
readXmlSerializable方法获取类后继续进行XML解析，是另一个XXE漏洞。
readExternalizableLite方法获取类后继续调用readExternal反序列化，不受黑名单限制，进而引出两个问题：
ExternalizableHelper自身没有实现Serializable接口，一定有什么地方调用它的readObject
loadClass加载后强转为了ExternalizableLite类型，它哪些满足readExternal参数要求的子类可以被用作sink
找到PermissionInfo#readExternal会调用ExternalizableHelper#readCollection进而调用readObject作为链首。
继续找到TopNAggregator$PartialResult及其父类SortedBag：
readExternal方法会调用父类的instantiateInternalMap方法将comparator封装进TreeMap，随后在add方法中调用map.put时就会触发compare，进而连上以前的链尾。与PriorityQueue的作用相同，只是绕这么一圈过掉了黑名单。
重写PermissionInfo#writeExternal按照以前的套路一步步构造payload打出去就行。
extract:95, MvelExtractor (com.tangosol.coherence.rest.util.extractor) extract:112, ReflectionExtractor (com.tangosol.util.extractor) extract:105, ChainedExtractor (com.tangosol.util.extractor) // extract:96, MultiExtractor (com.tangosol.util.extractor) compare:143, AbstractExtractor (com.tangosol.util.extractor) compare:416, SortedBag$WrapperComparator (com.tangosol.util) compare:1295, TreeMap (java.util) put:538, TreeMap (java.util) add:152, SortedBag (com.tangosol.util) add:270, TopNAggregator$PartialResult (com.tangosol.util.aggregator) readExternal:299, TopNAggregator$PartialResult (com.tangosol.util.aggregator) readExternalizableLite:2345, ExternalizableHelper (com.tangosol.util) readObjectInternal:2661, ExternalizableHelper (com.tangosol.util) readObject:2606, ExternalizableHelper (com.tangosol.util) readCollection:2131, ExternalizableHelper (com.tangosol.util) readExternal:190, PermissionInfo (com.tangosol.net.security) readExternalData:2118, ObjectInputStream (java.io) readOrdinaryObject:2067, ObjectInputStream (java.io) readObject0:1573, ObjectInputStream (java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27773082fce0c2938decb800286655c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8085d68ab542aae1769092e43cebc7d3/" rel="bookmark">
			6 网关和配置服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网关模式Spring Cloud网关Spring Cloud网关微服务其他项目的变更运行和测试小结 运行状况Spring Boot Actuator在微服务中包含Actuator 服务发现和负载均衡ConsulSpring Cloud ConsulSpring Cloud负载均衡器网关中的服务发现和负载均衡使用服务发现和负载均衡 环境配置使用Consul进行配置Spring Cloud Consul Config实现集中式配置集中配置实践 小结 前面的文章： 1、 1 一个测试驱动的Spring Boot应用程序开发 2、 2 使用React构造前端应用 3、 3 试驱动的Spring Boot应用程序开发数据层示例 4、 4 向微服务架构转变 5、 5 转向事件驱动的架构 后续文章：
7、7 集中式日志和分布式跟踪
8、8 容器化微服务
示例代码
通过消息代理可实现事件驱动架构的开发，使用RabbitMQ能够解决消费端处理事件的松耦合，实现消费端的负载均衡，便于扩展系统，提供弹性解决方案，但前端和微服务之间的负载均衡问题还没有解决。
网关模式 网关模式可以解决一些问题：
React应用程序需要指向多个后端微服务来与API进行交互。这是不正确的，因为前端应该将后端视为具有多个API的单独服务器，之后，不会公开架构，从而更灵活，便于进行变更。如果引入了后端服务的多个实例，前端就不知道如何平衡它们之间的负载。万一某个实例不可用，也不知道如何将请求重定向到另外的实例。尽管从技术角度看，可以在Web客户端中实现负载均衡和弹性模式，但也应该放在后端逻辑中，只实现一次，对任何客户端都有效，保持前端逻辑尽可能简单。当前情况下，如果向系统添加用户身份验证，就需要验证每个后端服务中的安全凭证。将这个放在后端的边缘，在那里验证API调用，然后将简单的请求传递给其他微服务，会更合理。只要保证其余的后端微服务无法从外部访问，就不必担心安全问题。 这些问题可通过网关微服务来解决。网关模式可集中HTTP访问，负责将请求代理到其他服务。网关会根据配置的规则来决定将请求路由到何处，另外，路由服务可以过滤器来修改请求和响应通过时的状态。如图所示：
-发送尝试
-获取用户别名
-获取排行榜
8000 -发送尝试
-获取用户别名
8080 -获取排行榜
8081 Gateway 过滤器 路由 浏览器 Multiplication Gamification 尝试
（主题交换） Gamification
队列 有时会将网关称为边缘服务，因为其他系统必须通过网关来访问后端，且网关将外部流量路由到相应的内部微服务，网关的引入通常会限制对其他后端服务的访问。
Spring Cloud网关 Spring Cloud是Spring系列中的一组独立项目，提供技术来快速构建分布式系统（如微服务等）所需的通用模式。这些模式称为云模式，即使在服务器中部署微服务，也适用。它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。Spring Cloud不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。换句话说：Spring Cloud 提供了构建分布式系统所需的“全家桶”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8085d68ab542aae1769092e43cebc7d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87b5a3a7914e74ee4bf3232796e2e22/" rel="bookmark">
			LiveGBS流媒体平台GB/T28181常见问题-国标编号是什么设备编号和通道国标编号标记唯一的摄像头|视频|镜头通道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LiveGBS国标GB28181中国标编号是什么设备编号和通道国标编号标记唯一的摄像头|视频|镜头通道 1、什么是国标编号？2、国标设备ID和通道ID3、ID 统一编码规则4、搭建GB28181视频直播平台 1、什么是国标编号？ 国标GB28181对接过程中，可能有的小伙伴会疑惑编号的问题。比如设备ID、视频通道ID、镜头ID、语音通道ID、报警通道ID等。这么多编号什么意思？为啥有这么多。
只要理解了，视频平台如何查找到资源，就可以很好的理解。比如，一台NVR硬件录像机，里面挂载了3个摄像头。视频平台如果要播放这个摄像头，是不是得知道是哪个NVR硬件，再找到对应的摄像头。那么这里至少知道2个ID， 设备的ID 和 通道ID，才可以标记唯一资源，找到它。
那什么是国标编号？ 按个人理解，就是按照GB28181协议中定义的ID编码规则，定义的数字编号，就是国标编号 或是 国标ID
2、国标设备ID和通道ID 国标设备编号和通道国标编号标记唯一资源
设备：海康摄像头|大华摄像头|宇视摄像头、4G执法仪、硬件NVR、下级视频平台通道：摄像头视频通道|报警通道|语音通道，镜头ID，NVR中通道ID，下视频平台共享的通道ID 3、ID 统一编码规则 联网系统应对前端设备、监控中心设备、用户终端ID进行统一编码,该编码具有全局唯一性。编码
应采用编码规则A(20位十进制数字字符编码)
编码规则A 由中心编码(8位)、行业编码(2位)、类型编码(3位)和序号(7位)四个码段共20位十进制数字字符构成,即系统编码=中心编码+ 行业编码+ 类型编码+ 序号。编码规则A 的详细说明见表D.1。其中,中心编码指用户或设备所归属的监控中心的编码,按照监控中心所在地的行政区划代码确定,当不是基层单位时空余位为0。行政区划代码采用GB/T2260—2007规定的行政区划代码表示。行业编码是指用户或设备所归属的行业,行业编码对照表见D.3。类型编码指定了设备或用户的具体类型,其中的前端设备包含公安系统和非公安系统的前端设备,终端用户包含公安系统和非公安系统的终端用户。
具体见如下截图：
4、搭建GB28181视频直播平台 支持 Windows Linux 及其它CPU架构（国产、嵌入式…）操作系统安装包下载 、 安装使用说明、 WEB前端源码更多常见问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834d349ed11be6c52e7ea203ac25baec/" rel="bookmark">
			java 使用 jtransforms 傅里叶库通过时域转频域实现wav 音频的加速与变慢效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入 maven 依赖： &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.jtransforms&lt;/groupId&gt; &lt;artifactId&gt;jtransforms&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;/dependency&gt; FourierTransformTest.java： import edu.emory.mathcs.jtransforms.fft.DoubleFFT_1D; import javax.sound.sampled.UnsupportedAudioFileException; import java.io.File; import java.io.IOException; import java.util.Arrays; public class FourierTransformTest { public static void main(String[] args) throws UnsupportedAudioFileException, IOException { fastTest(); // slowTest(); } public static void fastTest() throws UnsupportedAudioFileException, IOException { double[] audio_src = AudioUtils.wavToDoubleArray( new File("C:\\E\\素材\\音频\\wav\\audio.wav") ); // 将 audio_src 进行 时域转频域 new DoubleFFT_1D(audio_src.length).realForward(audio_src); // 截取转换成频域以后得 audio_src 的前半部分 作为 audio_target // 这里拷贝频域模式下的 audio_src 的前半部分，因为是频域模式，所以前半部分和后半部分其实都包含 "完整" 的时域信息( 只是失真严重 )，如果是时域模式下直接砍一半，肯定会丢失一半的时域信息( 但是未丢失的时域信息的音质没有任何丢失 ) // 所以频域下的double[]砍一半其实是音质砍一半( 即频率信息丢失一半 ) // 这里 除以2实现了2x加速效果 double[] audio_target = Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/834d349ed11be6c52e7ea203ac25baec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3efb0c214cb8cfa1fed0e0ef5844f5ad/" rel="bookmark">
			ASP.NETCore WebAPI 入门 杨中科
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASP.NETCore WebAPI入门1 回顾 mvc开发模式 前端代码和后端代码是混在一个项目之中
WEB API 1、什么是结构化的Http接口。Json。
2、Web API项目的搭建。
3、Web API项目没有Views文件夹。
4、运行项目，解读代码结构。
5、【启用OpenAPI支持】→&gt;swagger,在界面上进行接口的测试。
web api 项目搭建 选择 web api
默认一定要勾选上 启用OpenAPI支持
设置默认浏览器 运行项目 swagger swagger
是我们勾选上OpenAPI 所提供的
webapi 只对外提供数据，不提供界面，为了方便调试，所以swagger为我们提供了可视化的调试界面
直接向浏览器发请求，也会得到json格式数据
使用swagger发请求
点击Try it out
点击Execute
以更简单直接的方式获得请求结果
底层原理还是相同的
关键词讲解 [ApiController] :代表这是一个webapi的controller
[Route(“controller”)]:路径 代表请求的时候 使用下面的方法名前缀WeatherForecast
:controllerBase webapi里面的controller 一般是继承自它
mvc 是继承Controller
Controller 是继承自ControllerBase – mvc使用
webapi 是直接继承自ControllerBase – webapi 使用
[HttpGet(Name=“GetWeatherForecast”)] 向这个路径发送get请求的时候，由这个特性标注的方法来处理请求
自定义修改 在原始路径上添加 haha
此时运行项目：请求路径就发生了变化
也可以手动输入路径测试
ASP.NET Core WEB API 2 新建控制器 选择api控制器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3efb0c214cb8cfa1fed0e0ef5844f5ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef7417ae9ed61c26943f84111ddf0b5/" rel="bookmark">
			Spark内核解析-部署模式解析8(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、部署模式解析 1.1部署模式概述 Spark支持的主要的三种分布式部署方式分别是standalone、spark on mesos和 spark on YARN。standalone模式，即独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统。它是Spark实现的资源调度框架，其主要的节点有Client节点、Master节点和Worker节点。而yarn是统一的资源管理机制，在上面可以运行多套计算框架，如map reduce、storm等根据driver在集群中的位置不同，分为yarn client和yarn cluster。而mesos是一个更强大的分布式资源管理框架，它允许多种不同的框架部署在其上，包括yarn。基本上，Spark的运行模式取决于传递给SparkContext的MASTER环境变量的值，个别模式还需要辅助的程序接口来配合使用，目前支持的Master字符串及URL包括：
用户在提交任务给Spark处理时，以下两个参数共同决定了Spark的运行方式。
· –master MASTER_URL ：决定了Spark任务提交给哪种集群处理。
· –deploy-mode DEPLOY_MODE：决定了Driver的运行方式，可选值为Client或者Cluster。
1.2standalone框架 standalone集群由三个不同级别的节点组成，分别是
1)Master 主控节点，可以类比为董事长或总舵主，在整个集群之中，最多只有一个Master处在Active状态
2)Worker 工作节点 ，这个是manager,是分舵主， 在整个集群中，可以有多个worker，如果worker为零，什么事也做不了
3)Executor 干苦力活的，直接受worker掌控，一个worker可以启动多个executor,启动的个数受限于机器中的cpu核数
这三种不同类型的节点各自运行于自己的JVM进程之中。
Standalone模式下，集群启动时包括Master与Worker，其中Master负责接收客户端提交的作业，管理Worker。根据作业提交的方式不同，分为driver on client 和drvier on worker。如下图7所示，上图为driver on work模式，下图为driver on client模式。两种模式的主要不同点在于driver所在的位置。
在standalone部署模式下又分为client模式和cluster模式，其中client模式下，driver和client运行于同一JVM中，不由worker启动，该JVM进程直到spark application计算完成返回结果后才退出。如下图所示。
而在cluster模式下，driver由worker启动，client在确认spark application成功提交给cluster后直接退出，并不等待spark application运行结果返回。如下图所示
从部署图来进行分析，每个JVM进程在启动时的文件依赖如何得到满足。
1)Master进程最为简单，除了spark jar包之外，不存在第三方库依赖
2)Driver和Executor在运行的时候都有可能存在第三方包依赖，分开来讲
3)Driver比较简单，spark-submit在提交的时候会指定所要依赖的jar文件从哪里读取
4)Executor由worker来启动，worker需要下载Executor启动时所需要的jar文件，那么从哪里下载呢。
Spark Standalone模式，即独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖其他资源管理系统。在该模式下，用户可以通过手动启动Master和Worker来启动一个独立的集群。其中，Master充当了资源管理的角色，Workder充当了计算节点的角色。在该模式下，Spark Driver程序在客户端(Client)运行，而Executor则在Worker节点上运行。
以下是一个运行在Standalone模式下，包含一个Master节点，两个Worker节点的Spark任务调度交互部署架构图。
从上面的Spark任务调度过程可以看到:
1)整个集群分为Master节点和Worker节点，其中Driver程序运行在客户端。Master节点负责为任务分配Worker节点上的计算资源，两者会通过相互通信来同步资源状态，见途中红色双向箭头。
2)客户端启动任务后会运行Driver程序，Driver程序中会完成SparkContext对象的初始化，并向Master进行注册。
3)每个Workder节点上会存在一个或者多个ExecutorBackend进程。每个进程包含一个Executor对象，该对象持有一个线程池，每个线程池可以执行一个任务(task)。ExecutorBackend进程还负责跟客户端节点上的Driver程序进行通信，上报任务状态。
1.2.1Standalone模式下任务运行过程 ​上面的过程反映了Spark在standalone模式下，整体上客户端、Master和Workder节点之间的交互。对于一个任务的具体运行过程需要更细致的分解，分解运行过程见图中的小字。
1.用户通过bin/spark-submit部署工具或者bin/spark-class启动应用程序的Driver进程，Driver进程会初始化SparkContext对象，并向Master节点进行注册。
1.Master节点接受Driver程序的注册，检查它所管理的Worker节点，为该Driver程序分配需要的计算资源Executor。Worker节点完成Executor的分配后，向Master报告Executor的状态。
2.Worker节点上的ExecutorBackend进程启动后，向Driver进程注册。
2.Driver进程内部通过DAG Schaduler，Stage Schaduler，Task Schaduler等过程完成任务的划分后，向Worker节点上的ExecutorBackend分配TASK。
1.ExecutorBackend进行TASK计算，并向Driver报告TASK状态，直至结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef7417ae9ed61c26943f84111ddf0b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b4ddb6a50dcbc148c602ca5131dab0/" rel="bookmark">
			Python办公自动化 – 操控远程桌面和文件版本控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python办公自动化 – 操控远程桌面和文件版本控制 以下是往期的文章目录，需要可以查看哦。
Python办公自动化 – Excel和Word的操作运用
Python办公自动化 – Python发送电子邮件和Outlook的集成
Python办公自动化 – 对PDF文档和PPT文档的处理
Python办公自动化 – 对Excel文档和数据库的操作运用、设置计划任务
Python办公自动化 – 对CSV文件运用和管理文件 / 文件夹
Python办公自动化 – 对数据进行分析和制作图表数据
Python办公自动化 – 对图片处理和文件的加密解密
Python办公自动化 – 语音识别和文本到语音的转换
Python办公自动化 – 日志分析和自动化FTP操作
Python办公自动化 – 进行网络监控和处理压缩文件
Python办公自动化 – 文件的比较合并和操作xml文件
Python办公自动化 – 定时邮件提醒和音视频文件处理
Python办公自动化 – 处理JSOM数据和操作SQL Server数据库
Python办公自动化 – 人脸识别和自动化测试
文章目录 Python办公自动化 – 操控远程桌面和文件版本控制前言一、使用Python进行远程桌面操作1、 安装 pyautogui 和 pyperclip 库2、编写Python脚本 二、Python如何进行文件的版本控制1、安装Git2、初始化仓库3、添加文件4、提交更改5、查看历史记录6、切换版本7、创建分⽀8、合并分支9、克隆远程仓库 总结 前言 Python办公自动化是利用Python编程语⾔来创建脚本和程序，以简化、加速和自动化日常办公任务和工作流程的过程。它基于Python的强大功能和丰富的第三方库，使得能够处理各种办公任务，如⽂档处理、数据分析、电子邮件管理、网络通信等等。
这里打个广告！！！优惠快递寄件可搜索 [寄小牛]，全国5折起。。。
一、使用Python进行远程桌面操作 使用Python进行远程桌面操作通常需要使用第三方库，以便与远程桌⾯协议进行通信。以下是使用pyautogui 和 pyperclip 库进行基本远程桌⾯操作（模拟⿏标和键盘输⼊）的示例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b4ddb6a50dcbc148c602ca5131dab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ad648e5c6f713c305d3a6fc963e50e/" rel="bookmark">
			乘号在键盘上怎么打？速来学习这4个方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我在用电脑编辑文档时，需要输入一些数学公式，现在我不知道乘号怎么打，有朋友可以教教我吗？” 乘号是数学中常用的符号，用于表示两个数的相乘关系。很多用户在使用电脑办公时可能需要输入乘号。但是却发现键盘上没有明确的键可以快速输入该符号。
那么，乘号在键盘上怎么打呢？别着急，小编特意准备了几个简单有效的输入方法，有需要的用户可以进行尝试啦！
方法一：使用电脑键盘输入乘号 电脑上的乘号怎么输入？在使用电脑时，如果需要输入乘号，可以借助电脑键盘输入。用户只需要按下键盘上的【shift】键，再按下带有【*】的键。
提示：通常该键是数字 【8】键。这种方法适用于大多数Windows和Mac电脑。 方法二：使用智能输入法输入乘号 在电脑上进行文字输入时，很多用户或许都会安装某些智能的输入法。乘号在键盘上怎么打？简单又有效的方法是借助输入法完成输入。用户只需用拼音直接打出【chenghao】，找到相应的符号即可快速输入。
方法三：使用特殊符号输入乘号 电脑打出乘号怎么操作？在Word等文本编辑软件中，可以使用特殊符号输入法输入乘号。以Word为例，按下【插入】菜单中的【符号】或【特殊字符】选项，然后在弹出的菜单中选择乘号即可。
方法四：使用手写输入乘号 对于一些没有标准键盘布局的设备，如平板电脑或手机，怎么输入乘号？可以使用手写输入法输入乘号。具体来说，在手写输入法界面中写出【×】字即可识别并打出乘号。
乘号的应用在各种工作中也是比较常见的。乘号在键盘上怎么打？上文给大家分享了比较有效的四个简单方法，这些方法操作起来都比较方便。如果想要输入乘号，可以按照上文分享的方法操作啦！
往期推荐：
蓝牙鼠标连接不上电脑？盘点4个有效解决方法！https://blog.csdn.net/datarecover/article/details/135333944?spm=1001.2014.3001.5501
键盘数字键打不出来怎么解锁？收藏好这4个简单方法！https://blog.csdn.net/datarecover/article/details/135356145?spm=1001.2014.3001.5501
内存卡格式化后能恢复数据吗？正确答案分享！https://blog.csdn.net/datarecover/article/details/135355431?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff378808941b657b94bbd3abf4eb21c/" rel="bookmark">
			科技稳田心：地震频发，珈和科技领跑农险业务全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，日本能登半岛发生7.6级地震，13年以来首次触发“大海啸警报”。据估算，上一次的“3.11日本大地震”，导致了农林水产业损失约1200亿元。
自然灾害正严重影响着农业生产和可持续发展，提高农民抗风险能力，健全落实农业保险机制至关重要。面对传统农险效率低、成本高，技术支持不足等难题，珈和科技对农业保险业务流程进行拆解，提供精准承保、风险减量与防灾减灾全服务流程，围绕落户到图、作物分布、长势监测、作物估产、勘灾定损的全业务流程提供技术保障。
影像预处理与地块分割技术，让承保验标更“精准” 由于目前我国土地流转机制尚未建立完全，耕地基础数据质量差，耕地碎片化，土地量化难。为了提高耕地基础数据的准确性，帮助保险公司承保验标业务顺利进行，珈和科技利用高分辨率卫星影像完成地块分割，收集承保数据，提取承保地块面积和作物类型，与承保资料对比，出具验标结果，由保险公司验证。
在地块采集环节，珈和云平台集成超100种卫星专有算法，参照地信国标、全自动化清洗和结构化处理遥感影像，可实现影像快速预处理和交付；地块分割技术，用于识别地块的内部边界和自然边界，可为基于田块的监测应用提供更加精细的基础数据支持，田块面积精度和便捷精度均优于85%，平原区精度可达95%。
AI模型赋能作物过程监测环节，预警能力大提升 精准、及时地评估农田状况，为精准定损和理赔提供依据，为农事指导提供预警支撑，是作物过程监测工作开展的首要目的。
珈和科技基于自研的长势监测评价模型、农作物估产模型和灾害预测模型为保险公司提供作物长势过程监测、作物产量动态预估、气象及病虫害风险预警等服务，助力保险公司从单一赔付向全流程农业风险管理转变。
长势监测方面，利用遥感技术，实现作物的长势状况监测，提供作物生长过程的状况及相关指数信息，结合气象、墒情等因素提供长势评价；
灾害预警方面，利用遥感数据分析算法对目标作物的气象环境（包括土壤墒情、降水量、地表温度等信息）进行监测，及时预测气象灾害发生的风险概率，提供灾害预警信息服务报告，降低作物受灾风险；
作物产量预估方面，利用遥感技术，结合长势、气象数据、历史产量数据等信息提供承包区域内作物单产和总产估算，在每年作物收获期提供产量预估报告。
智能化灾害评估，实现精准定损与理赔 灾害发生后，对受损面积和受损程度的评估一直是农业保险定损理赔的难题，珈和科技与保险公司合作，收集灾害评估前期所需资料，覆盖灾害、评估精度、影像源、行政边界、地块数据等多个维度信息。
灾害评估开始实施后，珈和科技利用遥感技术、无人机航拍迅速获取灾前灾后的遥感影像，结合地面调查数据、气象数据和承保信息，确定承保区域及该区域范围内的承保农作物正常样本和受灾样本，构建农作物受灾等级回归模型，划分农作物受灾等级，提供受灾情况空间分布图、统计表及专题报告等遥感监测服务，实现及时、大范围快速勘灾，最大程度地提高灾害评估的准确性。
在过去的一年中，面对农险行业追求的“精准承保、快速理赔”的战略目标，珈和科技全情投入，利用先进技术优化业务流程。其中，研发的农险通标准化产品成功助推了多家保险公司农险业务的转型升级，帮助其完成了千万亩级不同农作物的定损评估工作，覆盖玉米、水稻、葵花、小麦、马铃薯、甜菜等各类型作物。
展望未来，珈和科技将持续以技术创新为核心，进一步深化行业解决方案，致力于让科技和智慧成为农险领域的新引擎，为保险公司提供更全面，更高效的服务，以数据服务驱动风险管理，推动农业保险服务的普及和精细化发展，携手开启智能农险新篇章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867d79c7ebbb64ce469cb24d5115db3c/" rel="bookmark">
			AI视频何时才能跑出一个“Midjourney ”?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文｜郝 鑫
编｜刘雨琦
AI视频一跃成为“明日之星”，大厂和创业公司们打得热火朝天。
去年12月，Pika的出现仿佛点燃了AI视频赛道的引线，一个月之内冒出了近十家公司，谷歌、阿里、字节、腾讯竞相下场，不断将战事推向了高潮。
“AI视频的Midjourney V5时刻就要到了”，即将迎来成为生产力的关键时刻。
2022年～2023年，文生图的技术以肉眼可见的速度迭代进化。Midjourney平均3个月一个版本，一路从V1狂奔到了V6，实现了从“面目全非”到“细腻逼真”的里程碑式的巨变。文生图技术以月为单位的进化速度，像一把节奏紧凑的小锤，不停提醒所有AI视频的公司们，留给他们成长的时间，不多了。
（图：网友制作的V1-V6的生成效果对比图，来源X）
如今AI视频的发展轨迹也正在慢慢向文生图靠拢，“Midjourney V5”成为了一个关键性的临界点：一旦突破，用户将大规模涌入，数据飞轮开始转动，效果日新月异，一步步推动着文生视频从“玩具”蜕变为“生产力”。
从文字到图片、视频的发展一脉相承，从文生图的进化历程中，也可以找寻到AI视频的影子。
当AI视频成为生产力后，才是产业链齿轮开始转动的开端。只有能用起来，才能诞生目标用户群体；只有能留存住用户，产生持续性的付费，才能构建起清晰的商业模式；也只有跑通了商业模式，池子里的企业才能存活下来，用消费端推动供给端，才能盘活整个AI视频产业。
“AI视频行业的生产力”——这恰恰才是现在各路玩家争夺的价值所在。
梦工厂创始人Jeffrey Katzenberg在近期预测，“生成式AI将使动画电影的成本，在未来3年内降低90%，该技术将给媒体和娱乐行业带来彻底的颠覆”。
“未来可能实现以每秒30帧的高分辨率实时生成内容，并且到2030年，可能会实现整个视频游戏的生成 ”，Midjourney首席执行官DaVid Holz判断道。
V5赛点已至，新一轮的排位赛正式打响，何时才能诞生下一个Midjourney？
AI视频迎来“生产力”时刻 实际上，AI视频几乎与文生图同一时期进入到人们视野中。
2023年初，Midjourney带火了文生图，Runway则激起了“人人制作电影大片”的无限遐想。
彼时，看到文生图领域在效果上大放异彩的Runway创始人曾表示：“希望 Gen-1 能像 Stable Diffusion 在图像上所做的那样为视频服务。我们已经看到了图像生成模型的爆发，我相信2023年将会是视频之年。”
但显然这个论断下得有点过早。2月，RunwayAI视频编辑Gen-1发布，功能类似于AI版的PS，可通过文字输入进行视频的风格转化和修改；3月，发布文生视频模型Gen-2，支持文生视频、文本+图像生成视频。
宣传视频很酷炫，但具体使用效果却差强人意，出现了时长短、生成画面不稳定、指令理解出错、没有音频、动作不连贯和不合理等等种种问题。
Runway打响AI视频第一枪后，虽未停下脚步，但却在视频编辑工具的道路越走越远，运动笔刷、文字转语音、视频合成等功能，只能算“锦上添花”。Gen-2迟迟没有根本性的突破，也让AI视频沉寂了一段时间。
就在大家快要失去对AI视频耐心的时候，去年12月，Pika、Genmo、Moonvalley、NeverEnds、谷歌VideoPoet、阿里Animate Anyone、字节Magic Animate，踏着希望之光来了。
在Pika的官方宣传片中，仅需一句话，就生成了动画版的马斯克，不但神形兼备，而且背景和动作都非常合理连贯，面部一致性也惊人得完美。
（图：Pika 1.0宣传视频动图，源自X）
在其官方展示的第一个视频中，生成效果几乎可以达到迪士尼等动画电影公司的质感。
（图：Pika 1.0宣传视频动图，源自X）
据使用过Pika 1.0产品的用户反映，Pika 1.0 支持3种方式生成视频：文生视频、图生视频、视频转视频。3D和2D效果确实上了一个全新的台阶，逼真度、稳定性、光影效果都可以吊打Gen-2。
“Pika 1.0和Gen-2仿佛不是一个时代的产品”，不少网友都在使用后给出了这样的评价。
Pika们的爆火，要归根于背后基建技术的成熟。其中最重要的就是AnimateDiff。这是一种基于Stable Diffusion文生图模型所搭建起来的动画框架，可让生成的图片直接动起来，字节、腾讯、阿里便是在这个框架的基础上推出了自己的AI视频模型。
当然，除了AnimateDiff的广泛应用，也与大模型多模态的发展，息息相关。
Pika们的出现开启了AI视频的新篇章，AI视频即将迎来“Midjourney V5”时刻。
这里面有两层重要的变化，首先体现在生成层面。
V5阶段，可达到更好的生成效果，在几秒的生成时间内能够达到动作、表情、叙事逻辑的连贯性；更有效的控制方式，对输入指令的理解、遵从，镜头、转场 、风格转化的控制都有了新的提升；更低的资源消耗，能够以更短的时间、更少的算力调用，生成更高分辨率和优质的视频，几秒的视频也可以达到几十秒的效果。
更重要的体现在生产力的突破上。
以Midjourney为例，在V5阶段，成为了UI设计师的设计工具，游戏原画师的助手，跨境电商的商品展示、广告营销的素材库。同样在这个阶段，AI视频也将有可能生成广告、短视频、电影、游戏，成为可以替代编导、导演、演员、设计师的生产力工具。
大模型、扩散模型 两条技术路径的殊途同归 AI视频就像一部电影大片，卖不卖座、叫不叫好，取决于剧本和特效两个重要元素。其中，剧本对应着AI视频生成过程中的“逻辑”，特效则对应着“效果”。
为了实现“逻辑”和“效果”，在AI视频行业中，分化出了两条技术路径扩散模型和大模型。
（图：光锥智能自制）
AIGC火了以后，扩散模型长期占据了图像生成领域的主导位置，这背后要归功于Stability AI的不断开源，一方面让更多的开发者加入到了精进模型的队伍中，另一方面也一手将扩散模型捧到了文生图领域的“王位”上。
如今，AI视频自然也被深深地打上了扩散模型的烙印。大厂和初创公司或多或少都在采访和论文中提到过扩散模型的思路，Pika一批新崛起的公司取扩散模型之长，打造自身的新模型；英伟达、阿里、字节、腾讯等公司在其基础之上，进一步提升模型能力。
在大模型技术路线上，经历过一次改变。大模型面世的初期，AI视频的主要思路是用训练大模型的那套方法，靠大参数、大数据来从头构建一个文生视频的模型，比如2022年就问世的CogVideo就是这类代表。
但随着大模型从单一文本迈向多模态，视频就像之前文字、图像生成一样，成为了从大模型根上长出来的一项功能。从很早的时候，谷歌、微软就在尝试用大模型中Transformer的方法训练和增强现有的扩散模型，但直到谷歌发布多模态大模型Gemini和VideoPoet视频大模型后，大模型生视频这条路才终于看到了曙光。
（谷歌VideoPoet视频生成效果演示）
两条技术路径无好坏，但侧重点不同，扩散模型的核心在于“还原呈现”，重效果；而大模型核心在于“接收理解”，重逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867d79c7ebbb64ce469cb24d5115db3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe9056bfaff7f3f4459054ad29764e0/" rel="bookmark">
			【自学笔记】01Java基础-07面向对象基础-02继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录学习Java基础中有关继承、方法重写、构造器调用的基础知识，学习继承之前建议学习static关键字的内容【自学笔记】01Java基础-09Java关键字详解
1 继承概述 1.1 什么是继承？ 1.2 继承的特点 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。Java是单继承模式：一个类只能继承一个直接父类。Java不支持多继承、但是支持多层继承。Java中所有的类都是Object类的子类。 1.3 继承的重要问题 1.3.1 子类是否可以继承父类的构造器？ 不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。
1.3.2 子类是否可以继承父类的私有成员（方法，变量）？ 可以的，只是不能直接访问。
具体表现如下：
子类不能直接引用父类的私有字段（成员变量）。子类不能覆盖（override）父类的私有方法。子类可以通过调用父类提供的公共（public）或受保护（protected）方法来间接访问或者修改私有字段的值，前提是父类提供了这样的接口。 例如，在父类中有一个私有变量，并且提供了一个公共的getter和setter方法，那么子类就可以通过调用这些方法来读取和设置该私有变量的值。
1.3.3 子类是否可以继承父类的静态成员？ 有争议的知识点。
子类可以直接使用父类的静态成员（共享）
但个人认为：子类不能继承父类的静态成员。（共享并非继承）
Java中，静态成员（包括静态变量和静态方法）是与类关联的，而不是与对象实例关联。因此子类可以直接访问父类的静态成员，但不会重新创建或覆盖这些成员。
public class Parent { public static int count = 0; // 静态方法 public static void incrementCount() { count++; } } public class Child extends Parent { // 子类无需定义count，直接可以使用Parent.count public static void main(String[] args) { // 直接通过类名访问父类的静态成员 System.out.println(Parent.count); // 输出：0 Parent.incrementCount(); System.out.println(Parent.count); // 输出：1 System.out.println(Child.count); // 输出：1，因为Child和Parent共享同一个静态变量count } } 在这个例子中，Child 类和 Parent 类共享同一个 count 变量。同样，Child 类也可以调用 Parent 中的public静态方法 incrementCount()。但是，子类不能重写父类的静态方法，只能重新声明一个同名的静态方法，这将被视为一个新的方法而非覆盖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe9056bfaff7f3f4459054ad29764e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6de3e7914007ca24b6663d24a1c2644/" rel="bookmark">
			2024年最新51单片机&#43;Proteus嵌入式开发入门实战完整版教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们为什么要学嵌入式开发？ 嵌入式系统是一种专为特定任务或特定应用设计的计算机系统。与通用计算机系统不同，嵌入式系统通常具有更小的体积、更低的功耗和更强的可靠性。由于这些特点，嵌入式系统广泛应用于工业控制、医疗设备、智能家居、自动驾驶等领域。万物互联时代正在进行，随着物联网、人工智能等技术的不断发展，嵌入式系统将会在更多的领域得到应用和发展。因此，学习嵌入式系统可以帮助我们紧跟行业发展趋势，为未来的职业发展做好准备。
51单片机+Proteus嵌入式开发入门实战系列教程-视频 课件 源码 免费下载
学习51单片机嵌入式开发之前必须具备哪些基础呢? 无论是学51单片机还是学ARM系列的STM32芯片，都需要具备C语言基础和集成电路基础，所以学习单片机之前我们必须首先会C语言和集成电路基础。
如果大家没有这些基础，可以先学学我们前面课程讲的C语言教程和集成电路教程。
《嵌入式开发必备C语言零基础入门精通》系列教程
《嵌入式开发必备集成电路 数字 模拟电路》系列教程
2024年最新51单片机嵌入式开发视频教程目录结构介绍： 一、如何学习51单片机、开发环境配置、点亮LED灯
1、学习单片机之前必备的基础
2、学习什么类型的单片机
3、学习单片机的最佳方法
4、51单片机开发环境配置
5、51单片机点亮LED灯
二、 Proteus仿真工具的安装使用
1、Proteus介绍
2、Proteus安装
三、51单片机最小系统组成 以及Proteus仿真、程序点亮led灯
1、51单片机最小系统组成
2、Proteus仿真51单片机最小系统
3、程序点亮led灯 四、STC89C52真实芯片最小系统介绍、下载器配置、程序烧录、点亮LED灯
1、STC89C52真实芯片最小系统介绍
2、STC89C52下载器配置
3、程序烧录
4、真实芯片点亮LED灯
五、点亮LED灯的几种方法以及使用51单片机实现流水灯
六、 数码管介绍仿真以及真实芯片驱动真实数码管显示1~9
1、数码管介绍
2、Proteus仿真数码
3、真实芯片驱动真实数码管显示1~9
七、多位数码管的动态扫描
八、51单片机结合38译码器74ls138 驱动多位数码管
1、38译码器74ls138介绍
2、74ls138 驱动多位数码管
九、键盘按键介绍以及独立按键改变数码管显示数据
1、键盘按键介绍
2、独立按键使用
3、Proteus仿真独立按键驱动数码管
4、真实芯片结合独立按键 数码管显示
十、 矩阵式按键以及矩阵式按键结合上拉电阻数码管详解
1、LED数码管详解
2、Proteus仿真74ls48显示译码器
3、Proteus仿真4-1 8-1数据选择器
十一、定时器 定时中断系统详解
1、定时器介绍
2、中断介绍
3、定时器结合中断
十二、计数器 8位自动重载以及16位计数器模式详解
1、计数器介绍
2、计数器结合中断
十三、外部中断详解
十四、串口通信详解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6de3e7914007ca24b6663d24a1c2644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59696498346ac82afabb0848a38d112/" rel="bookmark">
			pytest安装失败，报错Could not find a version that satisfies the requirement pytest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 安装pytest失败，尝试使用的命令有
pip install pytest pip3 install pytest pip install -U pytest pip install pytest -i https://pypi.tuna.tsinghua.edu.cn/simple 但是都会报同样的错：
解决方案 发现可能是挂了梯子的原因，关掉梯子再pip install pytest就可以了
如果你不是因为梯子才报错的，可以看看其他原因，可能有pip没更新、网络不太好等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49bf0b0aa52153644246e03f3ca3b34b/" rel="bookmark">
			被替换的文件怎么找回？3个高效方法分享！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我在对电脑进行清理时，删除了一些比较重要的文件，为了恢复它们，我重新复制了一些文件，这导致我原先的文件被替换了，这怎么办呢？被替换的文件还能恢复吗？” 在信息化时代，用户的电脑里或许都是各种各样的文件。有时候在使用电脑时，我们可能会不小心替换或误删掉某些重要的文件，这会给我们的工作带来各种不便。
被替换的文件怎么找回呢？本文给大家总结了几个实用的操作方法，希望能帮大家找回重要的文件！
方法一：从回收站恢复被替换的文件 电脑如何恢复被替换的文件？当我们在电脑上删除某个文件后又重新写入了新的文件，那么之前的文件可能会先被收入回收站中。此时建议用户先到回收站中看看是否有需要恢复的文件，操作如下。
步骤1：点击进入电脑中，找到【回收站】；
步骤2：在回收站中查看是否有被替换的文件，找到后，点击【还原】；
步骤3：当文件被还原后，检查文件中的内容是否正确。
方法二：借助以前的版本恢复被替换的文件 不小心替换的文件怎么找回？在使用电脑时，部分用户可能是不小心就对某些数据进行了删除操作。其实，借助以前的版本功能也有较大机会恢复这部分文件。操作如下
步骤1：点击被替换掉的文件删除前所在的文件夹；
步骤2：点击右键进入其【属性】；
步骤3：切换选项卡至【以前的版本】，找到文件未被替换之前的版本；
步骤4：选择相应的版本后点击【确定】。
提示：部分电脑如果没有提前开启该功能，是无法显示以前的版本的。 方法三：借助专业软件恢复被替换的文件 如果文件彻底被替换了，用户无法在电脑上找到相应的文件。那么被替换的文件怎么找回比较有效呢？由于被替换的文件可能在磁盘的深处，用户无法轻易找到，但是通过软件的全面扫描，或许可以找回重要的数据。因此建议用户借助专业的恢复软件完成文件的找回。
比较推荐的软件是 数 据 蛙 恢 复 专 家 。用户借助软件的双重扫描功能更有可能扫描到相关的数据，并且软件支持免费扫描，用户可先看看文件是否能扫描到，软件的详细操作如下。
操作环境： 演示机型：华硕无畏1414s 系统版本：Windows 10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 步骤1：将软件下载到电脑空间足够的磁盘中，运行软件后，先点击【免费扫描】；
步骤2：用户根据需要恢复的文件类型和文件删除前所在的磁盘进行勾选，选择完毕后点击【扫描】；
步骤3：第一次扫描是快速扫描，扫描完成后，用户可以先查看部分扫描到的结果，扫描结果中没有找到相关文件时，点击【深度扫描】；
提示：查看时，可以根据个人喜好选择查看方式。 步骤4：深度扫描将对所选磁盘进行深入的扫描，用户应耐心等待，扫描完毕后，用户可对所有查找到的结果进行选择，由于文件或许被同名文件替换，在选择时，应核对所需恢复的文件的大小、时间等，勾选完成后，点击【导出】。
提示：在选择时，如果文件比较多，建议直接在【 筛选器】中限定条件。 在使用电脑时，用户应该提前对保存在电脑里的文件做好备份，这样更有利于避免文件丢失或损坏。如果文件不小心被替换或删除，建议立即采取恢复行动。被替换的文件怎么找回？相信通过上文的分享，大家也有答案了，如果需要进行相关操作的，现在就可以行动起来啦！
往期推荐：
如何查看电脑使用记录？分享4个可行方法！https://blog.csdn.net/datarecover/article/details/135378882?spm=1001.2014.3001.5501
U盘数据恢复软件，高效恢复数据记好这2款！https://blog.csdn.net/datarecover/article/details/135379670?spm=1001.2014.3001.5501
找回删除文件如何操作？记得收藏好这3个有效方法！https://blog.csdn.net/datarecover/article/details/135378265?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c582ac7aa2104ad27ba846d7534da5/" rel="bookmark">
			视频号掀起内容新风向，这几类账号为何爆红？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12月初，视频号就迎来了好消息，官方发布消息称，视频号作者加入互选的门槛由10000粉调整为5000粉，其他条件不变。此举旨在激励更多创作者积极投入视频内容创作，从而获得更多商业合作的机会和收益。 为帮助大家更好地洞察视频号平台的内容趋势及创作风向，新视推出「12月月榜」，为从业者提供参考。
据「新视」统计，视频号12月TOP500账号中各类别竞争激烈，影视娱乐、民生、生活类账号数量占比相对居多，但也仅占36%。对比11月，影视娱乐、音乐、旅行摄影类上榜账号数量有小幅增长，而生活类账号数量有明显下降。
▲ 制图：新视
为帮助各位更好地洞察视频号平台的内容趋势及创作风向，新视将解读「12月月榜」，给到大家一些参考。
*如需直接查看视频号的『12月总榜』，可以拉至文章最后。
欢乐与温馨并存
泛生活内容更受大众喜爱
12月搞笑榜出现黑马，@无敌灏克666上升51位，排名第二，@快乐D怡宝和@郑奕森..稳定发挥，分别稳居榜首和榜三。
*下拉滑动查看完整榜单
▲&amp;nbsp;制图：新视
不同于纯剧情演绎向的搞笑类博主，@恩少的生活是在日常生活的基础上，巧妙地将搞笑元素融合进温馨的家庭互动之中，这种贴近生活又充满趣味的内容风格，让观众在欢笑中感受到了生活的美好。
12月，@恩少的生活最火的一条视频是其在12月13日发布的作品《自从奶奶有了孙子，都轮不到我们抱》中，展现了奶奶和儿子、儿媳抢着抱孙子，抱到孙子后眉开眼笑的场景，传递出家庭的温暖和幸福。该作品喜欢和推荐总数均获10w+。
纵览其作品，@恩少的生活虽没有华丽的剪辑和特效，但在音效方面，选取的大多是欢乐、轻快的音乐，与剧情相得益彰，营造出轻松愉快的氛围，音乐与剧情的搭配也是创作者们在打造爆款作品中非常重要的一环。
师生日常引人关注
趣味知识竞答别具一格
12月教育榜，分享孩子家庭教育的@临泉开心三姐妹蝉联第一，分享校园生活的@zcx-morningstar位列第二，以学生知识问答为创作素材的@方飞老师排名第三。
*下拉滑动查看完整榜单
▲&amp;nbsp;制图：新视
据新视数据统计，@方飞老师已经连续三月稳居榜单前三，12月共发布25个作品，累计获得推荐数68.6w、转发数29.17w、喜欢数41.91w。
▲ 新视-视频号详情页-作品概览
观察其作品特征，可以发现@方飞老师的拍摄场景非常简单，以教室为拍摄背景，学生们在教室里站成一列，依次回答问题，再将学生答题的过程拍成短视频上传，答题内容包括百科知识、古诗词飞花令、成语接龙、歇后语等，视频内容丰富，这种寓教于乐的教学模式获得不少观众喜爱。
@方飞老师在传统的语文教学中注入了娱乐元素，视频中，学生们精彩的表现和幽默的回答也为视频增添了不少趣味性，师生之间的互动问答也提高了观众参与互动与讨论的机会，拉近与观众的距离。
吃百家饭，品百位人生
用美食感悟人生百态
12月美食赛道竞争激烈，TOP20账号更替率达70%，排名榜首的是@乡村小表弟B，@2米饭桶和@辰小厨美食教程分别位于第二和第三。
*下拉滑动查看完整榜单
▲&amp;nbsp;制图：新视
其中@2米饭桶凭“全国百家饭体验”系列，获得推荐数85.07w、喜欢数55.38w、转发数26.64w，单月有4个作品获推10w+。
▲ 新视-视频号详情页-作品概览
@2米饭桶的视频虽然是以美食为主题，但作者关注的焦点并非美食本身，而是美食背后的人物和故事。长达5分钟的视频不仅是对美食的探索，更是对人情世故、文化底蕴和生活哲学的感悟。
作者通过记录自己在全国各地体验百家饭的过程，挖掘着平凡人物身上不平凡的故事。在其12月5日发布的《2米百家饭体验——有人抛弃，有人捡起，这次一起听听郭姨和她300只毛孩子的故事》中记录了郭姨独自照顾流浪狗的故事，让网友不禁感叹郭姨的善良和伟大，视频背后的含义是在呼吁人们对宠物负责，不能随意抛弃它们，传递着社会正能量。
@2米饭桶用文字和影像诉说着人生百态，让人们在品味美食的同时，也品味生活的美好，这种真挚和深入的表达方式引起观众的共鸣和喜爱。
以上就是12月细分领域榜单中，值得关注的部分优秀创作者，想要了解整体的榜单详情，可以查看下面的「12月月榜-总榜」排名：
*下拉滑动查看完整榜单
▲&amp;nbsp;制图：新视
重点内容
#&amp;nbsp; 与11月相比，12月影视娱乐、音乐、旅行摄影类上榜账号数量有小幅增长，而生活类账号数量有明显下降；
#&amp;nbsp; 以生活为基础，传递温馨家庭氛围的搞笑内容受到大众喜爱；
# &amp;nbsp;教育赛道呈多元化发展，教育与娱乐并重的内容更具吸引力；
# &amp;nbsp;美食赛道竞争激烈，将美食与人生百态相结合，更易引发观众情感共鸣。
文中仅展示部分榜单内容，如需查看更多视频号行业榜单，欢迎在PC端前往新视官网（‍xs.newrank.cn‍）体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a973a00ef8a01fe5fb5d3473f2d18a25/" rel="bookmark">
			单月涨粉突破千万，80&#43;主播带货突破亿元，揭晓抖音12月榜单看点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12月，抖音商城的双12好物节和双旦好礼季接踵而至，开启了平台商家年末销售的最后冲刺。 在两个营销节点的加持下，12月有哪些亮眼主播、热卖商品和出圈达人呢？通过新抖统计的12月1日-12月31日的月榜数据，一起来了解看看吧。
*获取完整榜单数据，可进入新抖官网查看
主播带货榜
84位主播带货破亿
据新抖［主播带货榜］的数据显示，12月带货销售额破亿的主播共计84位，数量超过了11月的78位，销售额区间在7500w-1亿的主播则有37位。
本次榜单，@东方甄选重回榜首，@新疆和田玉老郑和@董先生则分别上升1位，排名第二、第三。
下面是「主播带货榜」TOP30的排名情况：
*向上滑动阅览*
▲ 制图：新抖
其中，东方甄选抖音主号@东方甄选和旗下账号@东方甄选美丽生活，在12月的直播销售额均破亿。
虽然带货表现依旧不俗，但“小作文”风波还是带来了影响。
12月10日，原定在下午3点30分至6点30分直播的董宇辉，未按时出现在直播间。12月11日，@东方甄选直播间观看人次824.89万，相较近10场场均数据下降了117.71%，而此前三天的观看人次均在1200w以上，相应的，直播间的销量和销售额也都明显下降。
▲ 新抖-账号详情页-直播分析
12月16日，在东方甄选停播一天、发布人事任免通知、董宇辉亮相老俞闲话直播间合体回应此次事件，这一系列的操作之后，东方甄选“小作文”风波终于尘埃落定。
紧接着的两场带货直播，均达到了销售额破亿的成绩。
▲ 新抖-账号详情页-直播分析
综合带货榜单之外，在各垂直带货领域中，也有表现突出的主播，本次新抖选取5个「带货领域榜」，并展示TOP10的主播，包括美妆护肤、服饰鞋帽、食品饮料、家居生活及3C数码，下面是榜单详情：
*滑动查看下一张图片*
▲ 制图：新抖
热门商品榜
南美白虾单品销售额破亿
就平台商品带货趋势来说，「直播带货风向-品类带货分析」按直播销售额排序发现，畅销品类仍是服饰鞋帽，销售额占比达整体的49.08%，其次是食品饮料、家居生活、母婴用品。
▲ 新抖-直播-直播带货风向
热销商品方面，新抖统计的12月「热门商品榜」显示，排名前3的分别是南美白虾、贝母、爱媛果冻橙。
▲ 新抖-商品-热门商品排行
其中，东方甄选带货的南美白虾近30天的价格范围为59.9-128元，最常出现的价格为88元，相较于往期榜单中排名靠前的低价引流商品，东方甄选南美白虾的价格并不具备优势，但其销售额依旧突破了亿元，这主要是因为其品质较高，消费者的认可度较高。
▲ 新抖-商品详情页
下面是销量TOP30商品的排名情况：
*向上滑动阅览*
▲ 制图：新抖
粉丝飙升榜
40+位达人涨粉破100万
12月，共有46位达人涨粉破100万。
「」显示，@董宇辉涨粉1079.5w，排在榜一；@张大仙涨粉756.81w，排名第二；@户外发（东方阿保）涨粉557.61w，位列第三。
下面是涨粉榜TOP30的排名情况：
*向上滑动阅览*
▲ 制图：新抖
12月，董宇辉在“小作文”风波中，展现出了强大的影响力和号召力，他在抖音的粉丝数飙升，老账号@董宇辉涨粉1079.5w，新账号@与辉同行涨粉163.46w。
▲ 新抖-账号详情页
董宇辉的成功并非偶然，他凭借独特的个人魅力和深厚的文化底蕴，成功吸引了大量关注。这不仅为东方甄选带来了商业机会，也为抖音平台带来了巨大的流量价值。
以上就是12月部分月榜的内容，我们可以看到：
#&amp;nbsp;营销节点的加持下，单月带货销售额破亿的主播数量持续增长；
#&amp;nbsp;直播间中高品质的产品，即使价格偏高也能受到消费者认可；
#&amp;nbsp;单月涨粉破1000w，顶流主播难复制。
更多抖音达人/直播/商品/品牌/小店数据，欢迎PC端前往新抖（xd.newrank.cn）查看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdef8b7b84317222ead5c7119d91fbb/" rel="bookmark">
			asp.net core使用gb2312编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nuget包 安装System.Text.Encoding.CodePages
使用 //将byte[]转化为gb2312的字符串，要确保byte[]是存储的gb2312的字符串，要不然会乱码 string ToGb213(byte[] str) { //首先需要注册 Encoding.RegisterProvider(CodePagesEncodingProvider.Instance); Encoding gb2312; gb2312 = Encoding.GetEncoding("GB2312"); return gb2312.GetString(str); } //utf-8编码的字符串转化为gb2312编码的字符串 string LanChange(string str) { Encoding.RegisterProvider(CodePagesEncodingProvider.Instance); Encoding utf8; Encoding gb2312; utf8 = Encoding.GetEncoding("UTF-8"); gb2312 = Encoding.GetEncoding("GB2312"); byte[] gb = gb2312.GetBytes(str); gb = Encoding.Convert(gb2312, utf8, gb); return utf8.GetString(gb); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/573028f06e4678cfa9f87c7d29d28469/" rel="bookmark">
			GAMES101：作业5记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总览 在这部分的课程中,我们将专注于使用光线追踪来渲染图像。在光线追踪中最重要的操作之一就是找到光线与物体的交点。一旦找到光线与物体的交点,就可以执行着色并返回像素颜色。在这次作业中,我们需要实现两个部分:光线的生成和光线与三角的相交。本次代码框架的工作流程为:
从 main 函数开始。我们定义场景的参数,添加物体(球体或三角形)到场景中,并设置其材质,然后将光源添加到场景中。
调用 Render(scene) 函数。在遍历所有像素的循环里,生成对应的光线并将返回的颜色保存在帧缓冲区(framebuffer)中。在渲染过程结束后,帧缓冲区中的信息将被保存为图像。
在生成像素对应的光线后,我们调用 CastRay 函数,该函数调用 trace 来查询光线与场景中最近的对象的交点。
然后,我们在此交点执行着色。我们设置了三种不同的着色情况,并且已经为你提供了代码。
你需要修改的函数是:
• Renderer.cpp 中的 Render():这里你需要为每个像素生成一条对应的光线,然后调用函数 castRay() 来得到颜色,最后将颜色存储在帧缓冲区的相应像素中。
• Triangle.hpp 中的 rayTriangleIntersect(): v0, v1, v2 是三角形的三个顶点,orig 是光线的起点,dir 是光线单位化的方向向量。tnear, u, v 是你需要使用我们课上推导的 Moller-Trumbore 算法来更新的参数。
实现 Renderer.cpp-&gt;Render()的实现 建议先把这个文章看一下：
Ray-Tracing: Generating Camera Rays
在作业3里我们的坐标变换是正向的，从世界坐标到相机坐标到NDC坐标到渲染的像素坐标，而在光线追踪里我们要把光线从相机原点发射光线到屏幕上的每一个像素（知道的是像素坐标），我们需要做逆向的操作从渲染的像素坐标（注意左上角为原点）到NDC坐标到世界坐标，因为我们计算交点比较深度都是在世界坐标系里计算的。
渲染像素坐标-&gt;NDC坐标（[0,1]的正方形）
NDC坐标-&gt;屏幕像素坐标（[-1,1]的正方形【原点在左下角】） 因为原点在左上角，所以第二个式子需要乘一个负号：
我们的渲染图像的纵横比不一定是1，考虑到这一点我们需要对公式进行校正（这样使得每个分隔的方格都是正方形）
屏幕像素坐标-&gt;相机坐标
这里第二行和第三行右边应该是 P i x e l N D C x PixelNDC_x PixelNDCx​和 P i x e l N D C y PixelNDC_y PixelNDCy​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/573028f06e4678cfa9f87c7d29d28469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154ea86c0a140626391e3105055669cd/" rel="bookmark">
			【51单片机】LED灯的进阶操作（闪烁、流水）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章我们讲到了Keil5与STC的使用方式点亮第一个LED灯
这篇将继续进行一些LED灯的进阶操作
目录 LED灯闪烁：LED流水灯普通LED流水灯LED流水灯PLUS LED灯闪烁： 上文我们说只要通过P2这个寄存器就可以控制LED亮灭，现在我们要将其变为闪烁状态，故：
void main() { while(1) { P2 = 0xFE; P2 = 0xFF; } } 但由于寄存器的速度是非常快的，达到MHz（每秒100次）的等级，就导致这两句代码执行的特别快，最后的结果就是整体变暗一点
故我们需要进行一定的延时
这里说一下我们的STC软件中有一个下图的软件延时计算器
我们可以通过设置系统频率（与你的开发板有关，我们使用的是STC89C52，用的是12MHz的频率）与定时长度，得到一段延时你目标秒数的代码，我们复制粘贴就可以使用
---------------------生成的代码-------------------
void Delay500ms()	//@12.000MHz { unsigned char i, j, k; _nop_(); i = 4; j = 205; k = 187; do { do { while (--k); } while (--j); } while (--i); } 这段代码中_nop_的含义是
出自丿Zero
---------------------生成的代码-------------------
我们将其引用在C程序中
#include &lt;REGX52.H&gt; #include &lt;intrins.h&gt; void Delay500ms()	//@12.000MHz { unsigned char i, j, k; _nop_(); i = 4; j = 205; k = 187; do { do { while (--k); } while (--j); } while (--i); } void main() { while(1) { P2 = 0xFE; Delay500ms(); P2 = 0xFF; Delay500ms(); } } 这样就可以得到一个闪烁的LED灯了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154ea86c0a140626391e3105055669cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b24f1bddee351da149ea6f6a96cb62/" rel="bookmark">
			GPT/GPT4科研应用与AI绘图技术及论文高效写作教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详情点击链接：GPT/GPT4科研实践应用与AI绘图技术及论文高效写作教程
一OpenAI
1.最新大模型GPT-4 Turbo
2.最新发布的高级数据分析，AI画图，图像识别，文档API
3.GPT Store
4.从0到1创建自己的GPT应用
5. 模型Gemini以及大模型Claude2
二定制自己的GPTs
1.自定义GPTs使用
2.聊天交流的方式制作自己的GPTs
3.自定义的方式制作自己的GPTs
4.GPTs的3种分发方式
5.GPTs的action功能
6.论文改进专家（GTPs）
7.论文搜索（GTPs）
8.论文写作（GTPs）
三AIGC基础
1.深度学习常用架构
2.GPT1-4模型
3.AIGC技术
4.大语言模型的评估标准
5.LLM与搜索引擎：差异与联系
四提示词工程高级技巧
1.提示词工程
2.如何写好一篇论文的提示词
3.初识LLM：角色扮演的艺术
4.调整LLM的语调与表达方式
5.定义LLM的具体任务与目标
6.探索LLM与上下文的密切关系
7.零样本：强化逻辑推理
8.多样本：模型模仿能力提升
9.自洽性检验：数学能力加强
10.知识生成：提高模型的信息处理能力
五GPT/GPT4
1.GPT/GPT4是最好用的翻译软件
2.AI助力高效表格数据创建
3.AI在数据处理中的实际操作
4.苏格拉底式教学法在AI中的运用
5.如何与AI交流科研问题
6.AI助力文本数据整理与分析
7.AI在用户评论分析中的应用
8.AI撰写专业报告的技巧
9.让AI根据知识点出题
10.使用AI工具快速产出高端PPT的4种方法
11.使用AI工具快速产出短视频
12.快速制作流程图和思维导图
六GPT/GPT4成为你的论文助手
1.论文搜索和论文关联
2.分析论文得出审稿意见
3.进行论文内容问答
4.生成论文摘要
5.写论文综述并标注内容来源
6.中/英文论文润色的4种方法
7.进行论文降重的技巧
8.查找某个观点或内容相关的论文
9.对多篇论文进行分析对比
10.如何防止AI生成的内容被检测
11.生成完整长篇论文的技巧
12.让AI结合试验数据进行写作
七python基础
1.python的应用场景
2.python环境安装配置
3.print使用
4.运算符和变量
5.循环
6.列表元组字典
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b24f1bddee351da149ea6f6a96cb62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1527c52802697d2bab9414859deb8d0b/" rel="bookmark">
			如何从格式化的 Windows 和 Mac 电脑硬盘恢复文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格式化硬盘可为您提供全新的体验。它可以是硬盘驱动器定期维护的一部分，是清除不再使用的文件的一种方法，在某些情况下，它是处理逻辑损坏的万福玛利亚。但是，许多用户发现自己格式化了错误的分区或驱动器，或者后来意识到他们需要格式化过程中丢失的一些文件。
幸运的是，即使在格式化硬盘后也可以恢复数据。在下面的部分中，我们将了解可以从格式化硬盘恢复数据的情况以及如何进行。
如何在 Windows 或 Mac 上恢复格式化的驱动器 为了提高成功恢复的可能性，您可以做的最重要的事情就是立即停止使用该设备。格式化磁盘时，操作系统会删除对数据的逻辑访问，但数据在物理上仍然存在于设备上，直到被新信息覆盖。
一、使用专业数据恢复软件 奇客数据恢复软件是一种可靠且用户友好的解决方案，可以从格式化的驱动器或分区恢复数据。Windows 用户可以使用该工具免费扫描查看待恢复数据，并且此商业数据恢复解决方案的所有试用版都可以让您预览可以恢复的数据。
我们将分别查看该工具的 Windows 和 Mac 版本的过程，因为它们有一些细微的差异。在这两种情况下，请勿使用格式化磁盘来下载或安装应用程序。将数据恢复到不同的设备，以防止意外覆盖您要恢复的数据。
奇客数据恢复: 支持1000+数据格式恢复免费下载软件扫描数据，支持文件、照片、视频、邮件、音频等1000+种文件的格式恢复更有电脑/笔记本、回收站、U盘、硬盘等各类存储设备数据丢失恢复https://www.geekersoft.cn/geekersoft-data-recovery.htmlWindows系统：
1、下载并安装适用于 Windows 的 奇客数据恢复。
2、连接格式化的外部硬盘驱动器。
3、启动该程序并从应用程序的显示屏中选择磁盘或分区。单击搜索丢失的数据按钮以启动扫描过程。
4、预览找到的文件并选择要恢复的文件。
5、单击“恢复”按钮并为恢复的文件选择一个新位置。如前所述，不要使用原始磁盘来保存恢复的数据。
MacOS系统：
1、下载并安装 Mac 版 Disk Drill。
2、如有必要，连接意外格式化的外部硬盘驱动器。
3、启动应用程序并从应用程序列表中选择磁盘或分区。单击搜索丢失的数据按钮以扫描已删除的数据。
4、预览找到的文件并做出恢复选择。
5、单击恢复按钮执行恢复。在不同的驱动器上选择新的存储位置。然后单击“下一步”。
二、从备份恢复数据 从格式化驱动器恢复文件的唯一可靠方法是使用执行操作之前所做的备份。意外格式化的驱动器是您需要经常备份系统的一个典型例子。
macOS 和 Windows 都提供免费的备份和恢复工具，您应该定期使用它们来保护您的宝贵数据。以下是如何在使用备份格式化硬盘后恢复文件。
macOS 系统 Mac 用户可以使用内置的 Time Machine 备份和恢复应用程序通过备份来保护其数据。如果需要使用备份存储介质从格式化的驱动器恢复文件，请执行以下步骤。
将包含 Time Machine 备份的存储介质连接到您的 Mac。在上次存储所需文件的文件夹中打开 Finder 窗口。单击菜单栏上的时钟图标打开时间机器。使用 Time Machine 的屏幕导航查找您要恢复的文件。 按空格键预览文件。选择您要恢复的文件。单击“恢复”以恢复该项目。 Windows系统 根据您计算机上安装的操作系统版本，Windows 有不同的备份和恢复程序。以下是在 Windows 系统上从备份恢复时要使用的步骤。
Windows 10
打开文件资源管理器，然后打开包含要还原的项目的文件夹。单击文件夹顶部功能区上的“主页”选项卡。单击“历史记录”按钮将启动“文件历史记录”程序。选择您要恢复的项目。您可以选择文件夹、单个文件或多个文件。使用导航窗格找到您要恢复的数据的版本。单击恢复按钮。选择您希望如何处理命名冲突。完成文件恢复后关闭窗口。 早期的 Windows 版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1527c52802697d2bab9414859deb8d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1bb426dd3cbd9e3ad1d134031f703d9/" rel="bookmark">
			华为od机考 Python【A卷&#43;B卷&#43;C卷&#43;D卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本专栏使用Python解题 常见问题 1：进入机考网页之后如果链接上写着【C卷】，就表示是C卷题库。在2023年11月之后，大多数同学收到的应该是B卷+C卷题库题库。
2：旧的题库已经废弃，如果时间紧迫，建议直接刷最新的题库。
3：如果机试挂了，6个月之后可以再考。
4：订阅专栏后，后面更新的答案都可以查看。以后更新的题目也会放到这个专栏里。
5：如果对题解有问题，私信我解答。 最新B卷+C卷+D卷目录 题目考点时间分值计算数组中心位置（免费试读）逻辑推理华为OD统一考试C卷100区间交叠（免费试读）贪心算法华为OD统一考试C卷200BOSS的收入深度优先搜索华为OD统一考试C卷200编码能力的提升二分法华为OD统一考试C卷200对采样进行过滤逻辑分析华为OD统一考试C卷200寻找最接近数滑动窗口华为OD统一考试C卷100颜色统计方法滑动窗口华为OD统一考试C卷100URL的拼接方法正则匹配华为OD统一考试C卷100计算报文回路逻辑推理华为OD统一考试C卷100分割字符串前缀和华为OD统一考试C卷100选修课自定义排序华为OD统一考试C卷100拷贝文件01背包问题华为OD统一考试C卷200报数规则数学推理华为OD统一考试C卷100数字谜题前缀和华为OD统一考试C卷100喊七游戏数学问题华为OD统一考试C卷100报数问题约瑟夫环华为OD统一考试C卷100跳房子逻辑推理华为OD统一考试C卷100字符化繁为简字符串处理华为OD统一考试C卷100同时出现的整数逻辑推理华为OD统一考试C卷200整数编码进制转化华为OD统一考试C卷200优先队列问题set的应用华为OD统一考试C卷200寻找宝箱的位置逻辑推理华为OD统一考试C卷200创建二叉树二叉树华为OD统一考试C卷100数组最大差值空间换时间华为OD统一考试C卷200最小步数找规律华为OD统一考试C卷200拔河比赛自定义排序华为OD统一考试C卷200文件目录大小深度优先搜索华为OD统一考试C卷200黄金宝箱（五）滑动窗口华为OD统一考试C卷100最大可靠设备动态规划华为OD统一考试C卷100回文字符串字符串处理华为OD统一考试C卷100最快方法逻辑推理华为OD统一考试C卷200服务中心地址逻辑推理华为OD统一考试C卷200平均值最大的子数组二分法华为OD统一考试C卷200最多的直角三角形回溯法华为OD统一考试C卷200限载货物最小值二分法华为OD统一考试C卷200最佳对手逻辑推理华为OD统一考试C卷100文件目录大小dfs华为OD统一考试C卷200单词加密正则匹配华为OD统一考试C卷200分奖金深度优先搜索华为OD统一考试C卷200最接近的数滑动窗口华为OD统一考试C卷100最小延迟（二）最短路径华为OD统一考试C卷100内存分配逻辑推理华为OD统一考试C卷100TLV解析逻辑推理华为OD统一考试C卷200机房布局动态规划华为OD统一考试C卷100统计非1元素广度优先搜索华为OD统一考试C卷100静态扫描贪心算法华为OD统一考试C卷100座位调整动态规划华为OD统一考试C卷100模拟消息队列逻辑推理华为OD统一考试C卷200黄金宝箱（一）逻辑推理华为OD统一考试C卷200最佳植树距离二分法华为OD统一考试C卷100插队优先队列华为OD统一考试C卷100稀疏矩阵数组扫描华为OD统一考试C卷200监视器的数量深度优先搜索华为OD统一考试C卷200猜数字枚举华为OD统一考试C卷100称砝码动态规划华为OD统一考试C卷100堆积木子集问题华为OD统一考试C卷100人数最多的站点优先队列华为OD统一考试C卷200快递投放逻辑推理华为OD统一考试C卷200单词加密正则匹配华为OD统一考试B卷100比大小正则匹配华为OD统一考试B卷100优先级队列字典的应用华为OD统一考试B卷200最长公共后缀逻辑推理华为OD统一考试B卷100最节约的备份方法二分法华为OD统一考试B卷100恢复数字序列滑动窗口华为OD统一考试B卷100代表团坐车动态规划华为OD统一考试B卷200IPV4转化为整数字符串处理华为OD统一考试B卷200报文回路逻辑推理华为OD统一考试B卷200告警抑制送分题华为OD统一考试B卷100冠亚季军自定义排序华为OD统一考试B卷100响应报文的时间字符串处理华为OD统一考试B卷200食堂供餐二分法华为OD统一考试B卷200报文重排序字符串处理华为OD统一考试B卷100最小步数规律归纳华为OD统一考试B卷100分割数组最大值空间换时间华为OD统一考试B卷200乘坐保密电梯深度优先搜索华为OD统一考试B卷200五子棋爱好者双指针华为OD统一考试B卷100火星改造广度优先搜索华为OD统一考试B卷200周末爬山深度优先搜索华为OD统一考试B卷200战场索敌广度优先搜索华为OD统一考试B卷200最小循环子数组KMP算法华为OD统一考试B卷200小朋友的数量逻辑推理华为OD统一考试B卷100黄金宝箱（四）逻辑推理华为OD统一考试B卷100跳房子（二）双指针华为OD统一考试B卷200符合要求元组的个数分治法华为OD统一考试B卷200代码编辑器逻辑推理华为OD统一考试B卷100生日礼物二分查找华为OD统一考试B卷200优秀学员统计自定义排序华为OD统一考试B卷100查找人名字符串处理华为OD统一考试B卷100观看表演贪心算法华为OD统一考试B卷200扩散矩阵广度优先搜索华为OD统一考试B卷200二叉树的中序遍历二叉树的遍历华为OD统一考试B卷100异常的打卡记录逻辑推理华为OD统一考试B卷100不相交的子序列动态规划华为OD统一考试B卷100猜字谜逻辑推理华为OD统一考试B卷100去除多余的空格字符串处理华为OD统一考试B卷100优雅子数组双指针华为OD统一考试B卷200计算快递主站点并查集华为OD统一考试B卷200跳房子（二）排序+双指针华为OD统一考试B卷200最长公共后缀字符串处理华为OD统一考试B卷200恢复数字序列滑动窗口华为OD统一考试B卷200查字典字符串处理华为OD统一考试B卷100数字整除数学推理华为OD统一考试B卷100计算误码率字符串处理华为OD统一考试B卷100最大价值的矿堆深度优先搜索华为OD统一考试B卷200玩牌获得的最大分动态规划华为OD统一考试B卷200最佳的出牌方法逻辑推理华为OD统一考试B卷100 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b072a97b7846abb772873b5590d073a/" rel="bookmark">
			微信小程序：selectComponent返回null的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当小程序自带的组件无法满足所有需求的时候，我们可以参考很多自定义组件。我们这次排查问题就拿比较常用的vant-weapp作为示例：使用selectComponent获取自定义组件对象时，返回null的问题
1、json引入组件 "usingComponents": { "van-button": "@vant/weapp/button/index", "van-count-down": "@vant/weapp/count-down/index" } 2、看看wxml文件里面的选择器是否设置选择器 &lt;view&gt; &lt;van-button plain hairline type="primary" wx:if="{{isShowCountDown}}" &gt; &lt;view&gt;获取验证码&lt;/view&gt; &lt;/van-button&gt; &lt;van-button plain hairline type="primary" wx:if="{{!isShowCountDown}}" &gt; &lt;view class="flex-start"&gt; &lt;view&gt; &lt;van-count-down class="control-count-down" millisecond time="{{ time }}" auto-start="{{ false }}" format="ss"/&gt; &lt;view&gt; &lt;view&gt;秒后重新获取验证码&lt;/view&gt; &lt;/view&gt; &lt;/van-button&gt; &lt;/view&gt; 3、看看在页面的js文件里面引用的代码 let _this = this; const countDown = _this .selectComponent('.control-count-down'); console.log("countDown &gt;&gt; " + countDown ); 注意这个selectComponent方法里面的参数要与wxml里面设置的class选择器的值相对应，比如我的用的class选择器就用点+class名称
如果检查过后上面说的，全都没问题的话，那多半就是wxml中自定义组件的那段代码还没渲染到就使用selectComponent引用了组件，这个时候的返回值null。产生这种大致就下面两种情况
1、wx:if属性使用不当。 这里不得不提一下wx:if与hidden属性的区别，这两个属性我想大家都比较熟悉，都是用来控制显示与隐藏的。要说有什么区别，有些可爱的同学就会脱口而出：“wx:if条件为true就显示，反之则隐藏；hidden条件为true就隐藏，反之则显示！”。嗯，说的没错，这确实是最直观最明显的区别。但是说的并不全！他们还有一个区别，就是如果你用wx:if包裹了一段代码，界面在渲染的时候，当wx:if的条件为false的时候是不会渲染这段代码的，只有wx:if的条件为true才会渲染这段代码；而用hidden包裹的代码无论条件是为true还是false都会渲染它包裹的代码，只不过为true时将这段布局隐藏了而已。
2.自定义组件所在层级太深 如果你的自定义组件嵌套的非常深，而这个时候你在页面还未渲染完成的时候就开始使用selectComponent引用组件，获取到的对象也有可能是会为null，这个情况不会太稳定，有时候渲染的速度不一样，出现偶尔引用成功，偶尔引用失败的情况
以上情况分析，我们将我们代码优化了下
&lt;view class="flex-start"&gt; &lt;view hidden="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b072a97b7846abb772873b5590d073a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea4fa64accf7d51384c966507b727bff/" rel="bookmark">
			【期末不挂科-考前速过系列P1】单片机[接口与总线]——经典例题盘点【选择题＆判断题＆填空题】（带图解析）（第一章：27题搞定单片机＆其工作原理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
大家好吖，欢迎来到 YY 滴期末不挂科系列 ，热烈欢迎！ 本章主要内容面向接触过C++的老铁
主要内容含：
欢迎订阅 YY滴C++专栏！更多干货持续更新！以下是传送门！
YY的《C++》专栏YY的《C++11》专栏YY的《Linux》专栏YY的《数据结构》专栏YY的《C语言基础》专栏YY的《初学者易错点》专栏YY的《小小知识点》专栏 目录 一.单片机结构＆基本原理二.单片机引脚＆功能三.单片机存储器四.单片机的时钟电路和复位电路 一.单片机结构＆基本原理 1.一旦单片机处于混乱状态，哪个信号有效可以让它瞬间由混乱回复到最初的和谐？D
A.时钟信号B.中断系统C.定时器D.复位信号 2.CPU中的哪一部分是负责算术逻辑运算的呢？B
A.控制器B.运算器C.寄存器D.存储器
解析：CPU由两部分组成 3.下面哪个部件是用于处理单片机远距离通信的呢？B
A.并行I/0端口B.串行I/0端口C.存储器D.中断系统
解析：单片机中，并行端口负责近距离，串行负责远距离
AT89C51有 个 位的并行I/O端口(用数字填空)。（4）（8）
解析：如图所示，其分别有p0p1p2p34个8位的并行端口
判断发光二极管的正负极的方法是 。
解析与答：有标记或者长的一端是负极 AT89C51的CPU的字长 位，他们直接运算的数据范围是 位二进制数。
解析与答：8，8 AT89C51的第40引脚是 ，第20引脚是 。（）
解析：如图所示，单片机引脚自左向右逆时针，20号接地GND（ground），40号VCC（40）
定时器/计数器 部件是帮助CPU处理突发事件的部件(中断系统)
解析与答：中断系统有这个功能 二.单片机引脚＆功能 单片机的4个并行I/O端口各占几个引脚？C A.4B.32C.8D.16
解析：
如图所示并行I/0接口一共占32个引脚，每个P口占8个 单片机的哪个并行I/O端口引脚定义了第二功能呢？D A.P0B.P1C.P2D.P3
解析：单片机P3并行I/O端口引脚定义了第二功能 单片机的复位引脚是以下哪个呢？A A.RSTB.XTAL1C.XTAL2D.RXD
解析：顾名思义reset 单片机能够直接识别的语言是哪一个呢？C A.高级语言B.汇编语言C.二进制语言D.C语言
解析：C语言属于机器语言，其能被人看懂也是高级语言；通过一些软件编程变成汇编语言，最后给到计算机的是二进制语言 程序是以什么形式存放在程序存储器中？ A.C语言源程序B.汇编程序C.二进制编码D.BCD码
解析：根据12题，我们可以记忆，给到计算机的是二进制语言，那也是以二进制编码的形式存放在程序存储器中 单片机的XTAL1和XTAL2引脚是时钟信号引脚吗？（）是的
解析：如图所示，其与“振荡器”“晶振”相关
三.单片机存储器 下载程序后，程序的第一条指令都是存放在ROM的哪个地址单元？A A.0000HB.0001HC.0100HD.1000H
解析：如图所示，除了并行I/0端口P0~P3以及SP（堆栈指针，在CPU控制寄存器中）特殊外，其他的基本都是000…H/000B
具有只读不能写，掉电后数据不会丢失的存储器是什么？C A.CPUB.RAMC.ROMD.ALU
解析：如图所示，顾名思义ROM（read only memory），因为数据不会丢失，掉电后数据不会丢失；在51单片机中大小是4KB
具有可读可写功能，掉电后数据丢失的存储器是以下哪一个?B A.CPUB.RAMC.ROMD.ALU
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea4fa64accf7d51384c966507b727bff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e13fbcc2e0fae2a4ab811aef5767b89/" rel="bookmark">
			vs2019 C&#43;&#43; cin函数在运行调试cmd窗口里无法输入 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：未知，猜测可能是系统不支持cin函数在调试状态下控制台的输入
解决办法：vs菜单栏-&gt;生成-&gt;生成“你的工程名”，在你的项目路径下找到Debug文件，运行你的程序即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd9faa3425261cc8576eb751cea60cd/" rel="bookmark">
			Matlab 求阴影部分面积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clear all close all image = imread('pic.png'); imageGray = rgb2gray(image); S=size(imageGray); r1=84; r2=704; imageGrayMid=imageGray(r1:r2,:); threshold=(max(imageGrayMid(:))-min(imageGrayMid(:)))*0.5; label=imageGrayMid&lt;=threshold; labelAdd=zeros(S); labelAdd(r1:r2,:)=label; Area=sum(label(:))/prod(S); AreasStr=sprintf('S=%f',Area); %% 均值滤波 Fsize = [3, 3]; imageGrayMid_2 = imfilter(imageGrayMid, fspecial('average', Fsize)); threshold_2=(max(imageGrayMid_2(:))-min(imageGrayMid_2(:)))*0.5; label_2=imageGrayMid_2&lt;=threshold_2; labelAdd_2=zeros(S); labelAdd_2(r1:r2,:)=label_2; Area_2=sum(label_2(:))/prod(S); AreasStr_2=sprintf('S=%f',Area_2); %% 显示 figure subplot(221) imshow(imageGray) title('S=1') subplot(222) imshow(1-labelAdd) title(AreasStr) subplot(223) imageGrayMid_2_Add=[imageGray(1:r1-1,:); imageGrayMid_2; imageGray(r2+1:end,:)]; imshow(imageGrayMid_2_Add) title('S=1,均值滤波后') subplot(224) imshow(1-labelAdd_2) title(AreasStr_2) 纠正一下
clear all close all image = imread('pic.png'); imageGray = rgb2gray(image); S=size(imageGray); r1=84; r2=704; imageGrayMid=imageGray(r1:r2,:); threshold=(max(imageGrayMid(:))-min(imageGrayMid(:)))*0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd9faa3425261cc8576eb751cea60cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aba294ab8dad77ed3636356d3584793/" rel="bookmark">
			嵌入式（三）中断解析 | 中断基本概念 CC2530中断系统 中断编程全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1中断的概念和作用1.1 概念1.2 作用1.3 中断 其他概念 2. CC2530的中断系统3 中断编程3.1 中断配置3.1.1 使能端口组的中断功能3.1.2 使能当前端口组有哪些端口引脚中断3.1.3 设置中断触发方式 3.2 中断处理函数编写3.2.1 基本编写格式3.2.2 识别触发外部中断的端口Port3.2.3 识别触发外部中断的引脚（Pin） 注意一般是 不同端口上有不同引脚
1中断的概念和作用 1.1 概念 指CPU在执行当前程序的时候，由于系统中出现某种急需要处理的情况，CPU暂停正在执行的程序，转而执行别的一段特殊处理程序来处理出现的紧急事物，处理结束后，CPU自动返回原先暂停的程序中断继续
1.2 作用 1 提高工作效率
2 具备应对突发状况的能力
1.3 中断 其他概念 主程序 在发生中断前，CPU正常执行的处理程序。
中断源 引起中断的原因，或发生中断申请的来源
中断请求 中断源要求CPU提供服务的请求
断点 CPU响应中断后，主程序被打断的位置
中断处理函数 CPU响应中断后所执行的相应处理程序
中断向量 中断处理函数的入口地址，当CPU响应中断请求时，会跳转到该地址去 执行代码
CC2530的中断源如下
中断是有优先级的,按照不同优先级可以看到如下的系统
2. CC2530的中断系统 CC2530将18个中断源划分成6个中断优先级组IPG0～IPG5， 每组包括3个中断源
用户可以指定这6个中断优先组的优先级 （称作用户指定优先级）可以设置0～3级
其中0级属于最低优先级，3级为最高优先级。
为了保证中断系统的正常工作 还存在（自然优先级）的一些规则
1 如果多个组被设置成相同级别，则组号小的要比组 号大的优先级高。
2 同一组中包括的3个中断源，最左侧的优先级最高， 最右侧的优先级最低。
如何设置中断优先级？
通过IP1和IP0两个寄存器
由于每个组可能的情况一共是0，1，2三种情况，所以每个组需要2位来代表不同的优先级，那么至少需要两个寄存器，IP1是高位，IP0是低位，每个寄存器最高的2位空置不使用
从右到左，依次为0.1.2.3.4.5组
具体来说，比如我要设置0组优先级为3
IP0的[0]设置为0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aba294ab8dad77ed3636356d3584793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28115b1782b71c2989842818fb5af7f/" rel="bookmark">
			【重点】【BFS】542.01矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
法1：经典BFS 下图中就展示了我们方法：
class Solution { public int[][] updateMatrix(int[][] mat) { int m = mat.length, n = mat[0].length; int[][] dist = new int[m][n]; boolean[][] used = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (mat[i][j] == 0) { queue.offer(new int[]{i, j}); used[i][j] = true; } } } int[] xMove = new int[]{-1, 1, 0, 0}; int[] yMove = new int[]{0, 0, -1, 1}; while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28115b1782b71c2989842818fb5af7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42a0d349990a01df34d1fa1d3563026/" rel="bookmark">
			一文掌握文本语义分割：从朴素切分、Cross-Segment到阿里SeqModel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之所以写本文，源于以下两点
在此文《基于LangChain+LLM的本地知识库问答：从企业单文档问答到批量文档问答》的3.5节中，我们曾分析过langchain-chatchat项目中文本分割相关的代码，当时曾提到该项目中的文档语义分割模型为达摩院开源的：nlp_bert_document-segmentation_chinese-base (这是其论文)在此文《知识库问答LangChain+LLM的二次开发：商用时的典型问题及其改进方案》中，我们再次提到，langchain-chatchat的默认分块大小是chunk_size：250 (详见configs/model_config.py，但该系统也有个可选项，可以选择达摩院开源的语义分割模型：nlp_bert_document-segmentation_chinese-base) 考虑到在RAG中，embedding和文档语义分割、段落分割都是绕不开的关键点，故本文重点梳理下各类典型的语义分割模型
一方面，更好的促进我司第三项目组知识库问答项目的进度二方面，把我司在这个方向上的探索、经验一定程度的通过博客分享给大家(更多深入细节则见我司的大模型项目开发线上营) 第一部分 基于Cross Segment Attention的文本分割 RAG场景下，目前比较常用的文本切块方法还都是基于策略的，例如大模型应用开发框架提供的RecursiveCharacterTextSplitter方法，定义多级分割符，用上一级切割符分割后的文本块如果还是超过最大长度限制，再用第二级切割符进一步切割
Lukasik等人在论文《Text Segmentation by Cross Segment Attention》提出了三种基于transformer的分割模型架构。其中一种仅利用每个候选断点(candidate break)周围的局部上下文，而另外两种则利用来自输入的完整上下文(所谓候选断点指任何潜在的段边界，即any potential segment boundary)
1.1 Cross-segment BERT 分割模型旨在完成文档分割任务，以预测每个句子是否是文本分段的边界。
在 Cross-segment BERT模型中，我们将围绕潜在段落断点的局部上下文输入到模型中：左边k个标记和右边k个标记。
啥意思呢，其实很简单
在预训练BERT模型过程中，为了让模型学到两个句子之间的关系，设计了一个二分类任务，即
同时向BERT中输入两个句子，预测第二个句子是否是第一个句子的下一句。基于这个原理，我们可以设计一种最朴素的文本切分方法，其中最小的切分单位是句子 (下图：图源) 在完整的文本上，用滑动窗口的方式分别将相邻的两个句子输入到BERT模型中做二分类，如果预测分值较小，说明这两个句子之间的语义关系比较弱，可以作为一个文本切分点，示意图如下然而，这种方法判断是否是文本切分点时只考虑了前后各一个句子，没有利用到距离更远位置的文本信息。此外，该方法的预测效率也相对较低 1.2 BERT+Bi-LSTM 在BERT+Bi-LSTM模型中，我们首先使用BERT对每个句子进行编码，然后将句子表示输入到Bi-LSTM中，具体而言
当用BERT编码每个句子时，所有序列都以[CLS]标记开始
如果分割决定是在句子级别sentence level做出的(例如，文档分割document segmentation)，我们使用[CLS]token作为LSTM的输入
在分词决策是在词级word level做出的情况下(例如，话语分词discourse segmentation)，我们获得BERT的完整序列输出，并使用每个词的最左边的词段作为LSTM的输入(use the left-most word-piece of each word as an input to LSTM)
需要注意的是，在话语分割(discourse segmentation)任务中，由于上下文较短，可以仅使用一次BERT进行完全编码(Note that,due to the context being short for the discourse seg-mentation task, it is fully encoded in a single passusing BERT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42a0d349990a01df34d1fa1d3563026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31cb444ed0f0ef71f60e6486aec2c351/" rel="bookmark">
			EI级 | TCN-BiGRU-Multihead-Attention多头注意力机制多变量时间序列预测Matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，
代码获取、论文复现及科研仿真合作可私信。 🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab完整代码及仿真定制内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机
🔥 内容介绍 ​摘要 本文提出了一种基于多头注意力机制的时间卷积网络-双向门控循环单元（TCN-BIGRU-Multihead Attention）模型，用于数据回归预测。该模型结合了时间卷积网络和双向门控循环单元的优势，并引入多头注意力机制来增强模型对长期依赖关系的建模能力。实验结果表明，该模型在多个数据集上取得了优异的性能，优于传统的时间序列预测模型。
1. 引言 时间序列预测是机器学习领域的一个重要课题，广泛应用于金融、气象、交通等领域。传统的时间序列预测模型，如自回归模型（AR）、移动平均模型（MA）和自回归滑动平均模型（ARMA），虽然简单易用，但在处理复杂的时间序列数据时往往效果不佳。
近年来，深度学习模型在时间序列预测领域取得了很大的进展。时间卷积网络（TCN）是一种专门为时间序列数据设计的深度学习模型，它可以有效地捕捉时间序列数据中的局部依赖关系。双向门控循环单元（BIGRU）是一种循环神经网络，它可以有效地捕捉时间序列数据中的长期依赖关系。
为了进一步提高时间序列预测的准确性，本文提出了一种基于多头注意力机制的时间卷积网络-双向门控循环单元（TCN-BIGRU-Multihead Attention）模型。该模型结合了时间卷积网络和双向门控循环单元的优势，并引入多头注意力机制来增强模型对长期依赖关系的建模能力。
2. 模型结构 TCN-BIGRU-Multihead Attention模型的结构如图1所示。该模型主要由以下几个部分组成：
时间卷积层：该层由多个时间卷积核组成，用于捕捉时间序列数据中的局部依赖关系。
双向门控循环层：该层由多个双向门控循环单元组成，用于捕捉时间序列数据中的长期依赖关系。
多头注意力层：该层由多个注意力头组成，用于增强模型对长期依赖关系的建模能力。
输出层：该层由一个全连接层组成，用于输出预测结果。
📣 部分代码 %% 清空环境变量warning off % 关闭报警信息close all % 关闭开启的图窗clear % 清空变量clc % 清空命令行​%% 导入数据res = xlsread('数据集.xlsx');​%% 划分训练集和测试集temp = randperm(357);​P_train = res(temp(1: 240), 1: 12)';T_train = res(temp(1: 240), 13)';M = size(P_train, 2);​P_test = res(temp(241: end), 1: 12)';T_test = res(temp(241: end), 13)';N = size(P_test, 2);​%% 数据归一化[p_train, ps_input] = mapminmax(P_train, 0, 1);p_test = mapminmax('apply', P_test, ps_input);t_train = ind2vec(T_train);t_test = ind2vec(T_test ); ⛳️ 运行结果 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31cb444ed0f0ef71f60e6486aec2c351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d7b5490427fa8d92f8bcde60d2ce89/" rel="bookmark">
			123基于matlab的差分优化算法优化极限学习机，DE-ELM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于matlab的差分优化算法优化极限学习机，DE-ELM。输出分类识别结果和准确率。数据可更换自己的，程序已调通，可直接运行。
123差分优化算法极限学习机 (xiaohongshu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc809c0198f655cea2aa1c529586cda/" rel="bookmark">
			关于“Python”的核心知识点整理大全61
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
注意
20.1.4 使用 jumbotron 设置主页的样式
index.html
20.1.5 设置登录页面的样式
login.html
20.1.6 设置 new_topic 页面的样式
new_topic.html
20.1.7 设置 topics 页面的样式
topics.html
元素，让它们在页面上显得大些（见2）；对于添加新主题的链接，也做了同样的处 理（见3）。
20.1.8 设置 topic 页面中条目的样式
topic.html
元素，而对于编辑条目的链接，还使用了标签，使其比时间戳小些（见5）。
6处是面板主体div，其中包含条目的实际文本。注意，只修改了影响页面外观的元素，对在 页面中包含信息的Django代码未做任何修改。 图20-3显示了修改后的topic页面。“学习笔记”的功能没有任何变化，但显得更专业了，对 用户会更有吸引力。
注意
20.2 部署“学习笔记”
20.2.1 建立 Heroku 账户
注意
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
--snip-- &lt;/nav&gt; 1 &lt;div class="container"&gt; &lt;div class="page-header"&gt; 2 {% block header %}{% endblock header %} &lt;/div&gt; &lt;div&gt; 3 {% block content %}{% endblock content %} &lt;/div&gt; &lt;/div&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc809c0198f655cea2aa1c529586cda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca064039e2bfe5520e7448bcb5e8fd6/" rel="bookmark">
			Linux入门基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 什么是操作系统？2. 什么是服务器？3. 什么是节点？4. 什么是虚拟机？5. Linux的组成6. 网络连接的几种模式7. Linux的目录结构7. Linux指令vi和vimLinux关闭及重启方式用户登录/注销用户管理Linux的运行级别linux找回root密码帮助指令文件目录文件目录1文件目录-输出重定向文件目录-软连接和历史命令 1. 什么是操作系统？ 正式定义：负责管理计算机的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统的系统软件。
通俗定义：是一个系统软件，拥有资源管理和用户接口功能，表现为不同程序模块的集合。
操作系统介绍
2. 什么是服务器？ 服务器英文名称为“Server”，指的是网络环境下为客户机(Client)提供某种服务的专用计算机。
服务器介绍
3. 什么是节点？ 节点是一个术语，代指一类设备。他们可以是主机（pc）,服务器,也可以是构成传输网络的交换机,路由器,防火墙等等。
在网络中，节点是指一台电脑或其他设备与一个有独立地址和具有传送或接收数据功能的网络相连。节点可以是工作站、客户、网络用户或个人计算机，还可以是服务器、打印机和其他网络连接的设备。每一个工作站﹑服务器、终端设备、网络设备，即拥有自己唯一网络地址的设备都是网络节点。整个网络就是由这许许多多的网络节点组成的，把许多的网络节点用通信线路连接起来，形成一定的几何关系，这就是计算机网络拓扑。
节点与服务器的关系？
在一个集群里，一个服务器就是一个节点。单个服务器没必要叫做节点。
4. 什么是虚拟机？ 通过虚拟化技术，在电脑内，虚拟出计算机硬件，并给虚拟的硬件安装操作系统，即可得到一台虚拟的电脑，称之为虚拟机。
我们可以通过提供虚拟化的软件来获得虚拟机，如VMWare。
5. Linux的组成 Linux系统的组成如下：Linux系统内核、系统级应用程序
内核提供了Linux系统的主要功能，如硬件调度管理的能力，如：调度CPU、调度内存、调度文件系统、调度网络通讯、调度IO等。Linux内核是免费开源的，任何人都可以查看内核的源代码，甚至是贡献源代码。系统级应用程序，可以理解为出厂自带程序，可供用户快速上手操作系统，如： 文件管理器、任务管理器、图片查看、音乐播放等。 内核无法被用户直接使用，需要配合应用程序才能被用户使用。在内核之上，封装系统级应用程序，组合在一起就称之为Linux发行版。
6. 网络连接的几种模式 1.（bridged）桥接模式
简介：虚拟主机的ip和本地主机ip可以互相访问，虚拟机也可以访问互联网，虚拟机相当于互联网中的一台主机,
详解：什么是桥接模式？桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致.如下图所示：
不适用：如果你的网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了
2.NAT（地址转换模式）模式
简介：虚拟机可以访问互联网和本地（物理）主机，但本地主机不可以访问虚拟机。
详解：NET模式借用虚拟NET设备和虚拟DHCP服务器是虚拟机可以访问互联网（联网）
如下图：
在NET模式下主机网卡与虚拟net设备连接，然后net设备和DHCP服务器连接虚拟Vmnet8交换机实现虚拟机连接网络,连接网络不是通过vmnet网卡VMnet网卡是实现主机与虚拟机通信
3.主机（host-only）模式：
简介：虚拟机不可以访问本地主机互联网，发现虚拟机和本地（物理）主机网络是隔离的
详解：Host模式就是去除net设备的net模式，虚拟交换机通过虚拟vmnet1网卡与主机网卡连接进行通信，host-only模式就是将虚拟机与外网隔离使虚拟机成为一个独立的系统，只和主机进行通信如图所示：
7. Linux的目录结构 Windows 系统可以拥有多个盘符, 如 C盘、D盘、E盘
Linux的目录结构是一个层级式的树型结构，Linux没有盘符这个概念, 只有一个根目录 /, 所有文件都在它下面
7. Linux指令 vi和vim vim的三种模式：
一般命令模式（Command mode）编辑模式（Insert mode）命令行模式（Command-line mode） vi/vim的操作指令
Linux关闭及重启方式 Linux关闭及重启方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca064039e2bfe5520e7448bcb5e8fd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea57a04481fe970c750594f58283599f/" rel="bookmark">
			SSA-CNN-BiGRU-Attention分类预测 | MATLAB实现数据分类预测（SE注意力机制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，
代码获取、论文复现及科研仿真合作可私信。 🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab完整代码及仿真定制内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机
🔥 内容介绍 摘要 本文提出了一种基于麻雀算法优化注意力机制卷积神经网络结合门控循环单元（SSA-Attention-CNN-GRU）的数据多维输入分类预测模型。该模型首先利用麻雀算法优化注意力机制卷积神经网络（Attention-CNN）的权重，以提高Attention-CNN的分类精度。然后，将优化后的Attention-CNN与门控循环单元（GRU）相结合，形成SSA-Attention-CNN-GRU模型。SSA-Attention-CNN-GRU模型能够同时提取数据的时间和空间特征，并对提取到的特征进行分类。实验结果表明，SSA-Attention-CNN-GRU模型在多个数据集上均取得了较好的分类精度，优于其他对比模型。
1. 引言 随着工业4.0时代的到来，数据采集和处理技术得到了快速发展。在工业生产过程中，会产生大量的数据，这些数据包含了丰富的故障信息。故障识别是工业生产中一项重要的任务，故障识别模型可以帮助企业及时发现故障，并采取措施进行故障排除，从而提高生产效率和安全性。
传统的故障识别模型大多采用手工特征提取的方法，这些方法需要专家对数据进行深入的分析，才能提取出有效的故障特征。然而，手工特征提取方法的效率较低，并且容易受到专家主观因素的影响。
近年来，深度学习技术在故障识别领域得到了广泛的应用。深度学习技术可以自动从数据中提取故障特征，并且具有较高的分类精度。然而，传统的深度学习模型大多只考虑了数据的时间特征或空间特征，而没有同时考虑数据的时间和空间特征。
为了解决上述问题，本文提出了一种基于麻雀算法优化注意力机制卷积神经网络结合门控循环单元（SSA-Attention-CNN-GRU）的数据多维输入分类预测模型。该模型首先利用麻雀算法优化注意力机制卷积神经网络（Attention-CNN）的权重，以提高Attention-CNN的分类精度。然后，将优化后的Attention-CNN与门控循环单元（GRU）相结合，形成SSA-Attention-CNN-GRU模型。SSA-Attention-CNN-GRU模型能够同时提取数据的时间和空间特征，并对提取到的特征进行分类。
2. 模型结构 SSA-Attention-CNN-GRU模型的结构如图1所示。该模型主要由三个部分组成：麻雀算法优化注意力机制卷积神经网络（SSA-Attention-CNN）、门控循环单元（GRU）和分类层。
2.1 麻雀算法优化注意力机制卷积神经网络（SSA-Attention-CNN） 注意力机制卷积神经网络（Attention-CNN）是一种能够自动学习数据中重要特征的卷积神经网络。Attention-CNN的结构如图2所示。
Attention-CNN由多个卷积层、池化层和注意力机制层组成。卷积层负责提取数据中的局部特征，池化层负责降低数据的维度，注意力机制层负责学习数据中重要特征的权重。
麻雀算法是一种受麻雀觅食行为启发的优化算法。麻雀算法具有较强的全局搜索能力和局部搜索能力，能够快速找到最优解。
本文利用麻雀算法优化Attention-CNN的权重。麻雀算法优化Attention-CNN的步骤如下：
初始化麻雀种群。
计算每个麻雀的适应度。
根据适应度选择麻雀。
对选出的麻雀进行变异操作。
重复步骤2-4，直到达到终止条件。
输出最优的麻雀。
2.2 门控循环单元（GRU） 门控循环单元（GRU）是一种循环神经网络，能够学习数据中的时间序列特征。GRU的结构如图3所示。
GRU由一个更新门和一个重置门组成。更新门负责控制信息在GRU中的流动，重置门负责控制GRU对历史信息的遗忘程度。
2.3 分类层 分类层负责对提取到的特征进行分类。分类层通常由一个全连接层和一个softmax层组成。全连接层负责将提取到的特征映射到分类空间，softmax层负责计算每个类别的概率
📣 部分代码 %% 清空环境变量warning off % 关闭报警信息close all % 关闭开启的图窗clear % 清空变量clc % 清空命令行​%% 导入数据res = xlsread('数据集.xlsx');​%% 划分训练集和测试集temp = randperm(357);​P_train = res(temp(1: 240), 1: 12)';T_train = res(temp(1: 240), 13)';M = size(P_train, 2);​P_test = res(temp(241: end), 1: 12)';T_test = res(temp(241: end), 13)';N = size(P_test, 2);​%% 数据归一化[p_train, ps_input] = mapminmax(P_train, 0, 1);p_test = mapminmax('apply', P_test, ps_input);t_train = ind2vec(T_train);t_test = ind2vec(T_test ); ⛳️ 运行结果 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea57a04481fe970c750594f58283599f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd2504e48ea2a86d31d2c6483001039/" rel="bookmark">
			KOA-CNN-BiLSTM-selfAttention分类预测 | Matlab实现自注意力机制多特征分类预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，
代码获取、论文复现及科研仿真合作可私信。 🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab完整代码及仿真定制内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机
🔥 内容介绍 摘要 本文提出了一种基于开普勒算法优化注意力机制的卷积神经网络结合长短记忆神经网络（KOA-CNN-LSTM-attention）模型，用于数据分类任务。该模型将开普勒算法应用于注意力机制中，以提高注意力机制的效率和准确性。同时，该模型还结合了卷积神经网络和长短记忆神经网络，以充分利用数据中的局部特征和时序信息。实验结果表明，该模型在多个数据集上的分类精度均优于其他现有模型。
1. 介绍 数据分类是机器学习领域中的一项重要任务，其目标是将数据样本划分为不同的类别。近年来，随着深度学习技术的快速发展，基于深度学习的数据分类模型取得了巨大的成功。其中，卷积神经网络（CNN）和长短记忆神经网络（LSTM）是两种最常用的深度学习模型。
CNN是一种擅长处理空间数据的深度学习模型，其主要特点是能够自动提取数据中的局部特征。LSTM是一种擅长处理时序数据的深度学习模型，其主要特点是能够记忆长期依赖关系。
为了充分利用数据中的局部特征和时序信息，本文提出了一种基于开普勒算法优化注意力机制的卷积神经网络结合长短记忆神经网络（KOA-CNN-LSTM-attention）模型。该模型将开普勒算法应用于注意力机制中，以提高注意力机制的效率和准确性。同时，该模型还结合了卷积神经网络和长短记忆神经网络，以充分利用数据中的局部特征和时序信息。
2. 模型结构 该模型主要由以下几个部分组成：
卷积层：卷积层用于提取数据中的局部特征。
池化层：池化层用于减少卷积层的输出尺寸。
LSTM层：LSTM层用于记忆长期依赖关系。
注意力机制：注意力机制用于选择性地关注数据中的重要部分。
全连接层：全连接层用于将LSTM层的输出映射到分类结果。
3. 开普勒算法优化注意力机制 在传统的注意力机制中，注意力权重是通过一个softmax函数计算得到的。softmax函数是一种非线性函数，其计算复杂度较高。为了提高注意力机制的效率，本文将开普勒算法应用于注意力机制中。
开普勒算法是一种迭代算法，其可以快速收敛到softmax函数的解。因此，使用开普勒算法可以大大降低注意力机制的计算复杂度。
📣 部分代码 %% 清空环境变量warning off % 关闭报警信息close all % 关闭开启的图窗clear % 清空变量clc % 清空命令行​%% 导入数据res = xlsread('数据集.xlsx');​%% 划分训练集和测试集temp = randperm(357);​P_train = res(temp(1: 240), 1: 12)';T_train = res(temp(1: 240), 13)';M = size(P_train, 2);​P_test = res(temp(241: end), 1: 12)';T_test = res(temp(241: end), 13)';N = size(P_test, 2);​%% 数据归一化[p_train, ps_input] = mapminmax(P_train, 0, 1);p_test = mapminmax('apply', P_test, ps_input);t_train = ind2vec(T_train);t_test = ind2vec(T_test ); ⛳️ 运行结果 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd2504e48ea2a86d31d2c6483001039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8028ca829c1662121e43ab28c6e8ff0a/" rel="bookmark">
			程序员面试、算法研究、编程艺术、机器学习、大模型/ChatGPT等6大系列集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：July，七月在线创始人兼CEO、结构之法算法之道blog之博主
时间：2010年10月-2023年7月，一直在不断更新中..
出处：http://blog.csdn.net/v_JULY_v 前言 开博10年有余，回首这10余年，自己一开始侧重编程、面试、数据结构/算法，中途侧重数据挖掘、机器学习，近期则专攻AIGC/ChatGPT，而自己在本blog上也着实花费了巨大的时间和精力，写的东西可能也够几本书的内容了。然不管怎样，希望我能真真正正的为读者提供实实在在的价值与帮助。
下面，敬请观赏。有任何问题，欢迎随时不吝指正(同时，若你也能帮助回复blog内留言的任何朋友的问题，欢迎你随时不吝分享&amp;回复，我们一起讨论，互帮互助，谢谢)。
无私分享，造福天下 以下是本blog内的微软面试100题系列、经典算法研究系列、程序员编程艺术系列、红黑树系列、机器学习十大算法系列、AIGC/ChatGPT等6大经典原创系列作品与一些重要文章的集锦：
一、微软面试100题系列 横空出世，席卷Csdn--评微软等数据结构+算法面试100题 （微软面试100题系列原题+答案索引）微软100题 （微软面试完整第1-100题）微软面试100题2010年版全部答案集锦（含下载地址）全新整理：微软、谷歌、百度等公司经典面试100题[第101-160题]全新整理：微软、Google等公司的面试题及解答[第161-170题] 十道海量数据处理面试题与十个方法大总结 （十道海量数据处理面试题）海量数据处理面试题集锦与Bit-map详解 （十七道海量数据处理面试题）教你如何迅速秒杀掉：99%的海量数据处理面试题 （海量数据处理PDF）九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题） （2011年度九月最新面试三十题）十月上旬百度，阿里巴巴，迅雷搜狗最新面试七十题（第201-270题） （2011年度十月上旬七十题）十月下旬腾讯，网易游戏，百度最新校园招聘笔试题集锦(第271-330题) （2011年度十月下旬校招）九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题) （2012年度笔试面试八十题）九月百度，迅雷，华为，阿里巴巴，最新校招笔试面试十(第411-470题) （2013年度校招笔试面试十题） 上述微软面试100题系列(共计11篇文章，300多道面试题)的PDF文档近期已经制作出来，其下载地址为：微软面试100题系列之高清完整版PDF文档[带目录+标签]by_July_pdf-C++文档类资源-CSDN下载
二、十五个经典算法研究与总结、目录+索引 一、A*搜索算法一（续）、A*，Dijkstra，BFS算法性能比较及A*算法的应用二、Dijkstra 算法初探 （Dijkstra算法系列4篇文章）二（续）、彻底理解Dijkstra算法二（再续）、Dijkstra 算法+fibonacci堆的逐步c实现二（三续）、Dijkstra 算法+Heap堆的完整c实现源码通俗理解动态规划：由浅入深DP并解决LCS问题(23年修订版)如何通透理解：BFS和DFS优先搜索算法(23年修订版)五、教你透彻了解红黑树 （红黑树系列6篇文章之其中两篇）五（续）、红黑树算法的实现与剖析六、教你初步了解KMP算法六（续）、从KMP算法一步一步谈到BM算法六（三续）、从头到尾彻底理解KMP （KMP的PDF）七、遗传算法 透析GA本质八、再谈启发式搜索算法九、图像特征提取与匹配之SIFT算法 (sift算法系列五篇文章)九（续）、sift算法的编译与实现九（再续）、教你一步一步用c语言实现sift算法、上九（再续）、教你一步一步用c语言实现sift算法、下九（三续）：SIFT算法的应用--目标识别之Bag-of-words模型九（四续）、SIFT + KD_BBF算法 （此文第3部分）十、从头到尾彻底理解傅里叶变换算法、上十、从头到尾彻底理解傅里叶变换算法、下十一、从头到尾彻底解析Hash表算法十一（续）、倒排索引关键词Hash不重复编码实践十二、快速排序算法 （快速排序算法3篇文章）十二（续）、快速排序算法的深入分析十二（再续）：快速排序算法之所有版本的c/c++实现十三、通过浙大上机复试试题学SPFA 算法十四、快速选择SELECT算法的深入分析与实现十五、多项式乘法与快速傅里叶变换 最新的十五个经典算法研究的PDF文档0积分下载地址如下(1个月5000+人次下载)
三、程序员编程艺术第一~四十章集锦与总结 第一章、左旋转字符串第二章、字符串是否包含问题第三章、寻找最小的k个数第三章续、Top K算法问题的实现第三章再续：快速选择SELECT算法的深入分析与实现三之三续、求数组中给定下标区间内的第K小（大）元素第四章、现场编写类似strstr/strcpy/strpbrk的函数第五章、寻找满足条件的两个或多个数第六章、求解500万以内的亲和数第七章、求连续子数组的最大和第八章、从头至尾漫谈虚函数第九章、闲话链表追赶问题第十章、如何给10^7个数据量的磁盘文件排序第十一章、最长公共子序列（LCS）问题第十二~十五章：数的判断，中签概率，IP访问次数，回文问题（初稿） 第十六~第二十章：全排列/跳台阶/奇偶调序，及一致性hash算法
第二十一~二十二章：出现次数超过一半的数字，最短摘要的生成
第二十三、四章：杨氏矩阵查找，倒排索引关键词Hash不重复编码实践
第二十五章：Jon Bentley：90%无法正确实现二分查找
第二十六章：基于给定的文档生成倒排索引的编码与实践第二十七章：不改变正负数之间相对顺序重新排列数组第二十八~二十九章：最大连续乘积子串、字符串编辑距离第三十~三十一章：字符串转换成整数，字符串匹配问题第三十二~三十三章：最小操作数，木块砌墙问题第三十四~三十五章：格子取数问题，完美洗牌算法第三十六~三十七章、搜索智能提示suggestion，附近地点搜索第三十八章：Hero在线编程判题、出题系统的演进与优化第三十九~四十章：最近公共祖先LCA问题、打印螺旋矩阵第四十一章~四十二章：荷兰国旗、矩阵相乘Strassen算法... 程序员编程艺术第1~37章带标签的最新PDF下载地址为（3天3000人下载）
编程艺术github优化版阅读地址：https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd
重大消息：经过反复修改、优化，编程艺术系列最终成书出版，并改名为《编程之法：面试和算法心得》，目前京东、当当、亚马逊等各大网店均已有现货销售。京东抢购地址：《编程之法：面试和算法心得(异步图书出品)》(July)【摘要 书评 试读】- 京东图书，且23年Q4将上市第二版
四、红黑树、B树、R树、Trie树 教你初步了解红黑树 （红黑树系列）红黑树算法的实现与剖析红黑树的C实现完整源码一步一图一代码，R-B Tree红黑树插入和删除结点的全程演示红黑树的C++完整实现源码从2-3-4树谈到Red-Black Tree（红黑树）从B树、B+树、B*树谈到R 树 （B树的PDF）B树的C 实现从Trie树（字典树）谈到后缀树 （其余树结构）从LSM-Tree、COLA-Tree谈到StackOverflow、OSQA 五、机器学习十大算法系列 5.1 AI数学基础 概率统计极简入门：通俗理解微积分/期望方差/正态分布前世今生(23修订版)一文通透优化算法：从随机梯度、随机梯度下降法到牛顿法、共轭梯度.. 5.2 AI工程实践 一文读懂特征工程教你从头到尾利用DL学梵高作画：GTX 1070 cuda 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8028ca829c1662121e43ab28c6e8ff0a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/7/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>