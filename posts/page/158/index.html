<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c1089961ab78ddb47cd931e441f658/" rel="bookmark">
			【PointRCNN深度解读【详尽版】--原理和代码结合】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PointRCNN深度解读【详尽版】 前言网络结构*a. Bottom-up 3D Proposal Generation*Point Cloud Encoder-DecoderForeground Point SegmentationBin-based 3D Box Generation从代码角度来解读 *b. Canonical 3D Box Refinement*Point Cloud Region PoolingCanonical TransformationMerged FeaturesBin-based 3D box Refinement and Confidence Prediction代码部分 总结参考 前言 这周终于接触3D目标检测的内容，以前的PointNet和PointNet++都是讲述的分类和分割的问题。从PointRCNN开始难度好像一下子升级了，网络结构比较复杂，代码量巨大，花费了差不多一周的时间才理解了个大概，不敢说多，所以做个笔记再回顾下其内容，避免遗忘。还是老规矩结合代码从论文的网络结构一步步的解析。
论文： PointRCNN
代码: 点开它
网络结构 整体的思路主要分为两步：
前景点的分割以及3D预测框的生成对框的微调优化 具体的细化过程如下：
a. Bottom-up 3D Proposal Generation 这个阶段的主要目的就是利用主干网络提取特征，分割原始点云同时从分割的前景点生成3D Proposal，基于这种自底向上的策略，可避免在3D空间中使用大量预定义的3D框，并且显著限制了生成的3D提案的搜索空间。
Point Cloud Encoder-Decoder 主干网络提取特征，作者用了PointNet++(不了解的可以点进去看我另一篇博客)，另外主干网络也可以采用其他如VoxelNet等。
Foreground Point Segmentation 提取特征后分割原始点云，生成所需要的前景点，包含了预测目标位置和方向的丰富信息。另外由于前景点远比背景少，故使用Fcoal loss 来区分前景与背景，Focal loss本身是为了减少容易分类的样本的权重，将权重尽量集中于难分类样本上。
论文中 αt= 0.25，γ= 2。
Bin-based 3D Box Generation 作者在论文中提出了一种基于Bin的方法，使模型训练的时候能够更快的收敛。如下图：
可以看到，作者采用鸟瞰的方式，设定一个在X-Z平面的搜索范围S，每个搜索范围被划分成等长δ 的bins来表示不同的物体在X-Z平面的中心( x , z )。在论文中发现，对X- Z轴使用基于bin的交叉熵损失比直接使用smooth L1 loss 回归能够更加精准得出定位结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c1089961ab78ddb47cd931e441f658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976ba5f5447b8470f693d2030ceec179/" rel="bookmark">
			Java中代码块的执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码块的格式： {执行的语句}
代码块的主要用途 当我们定义了代码块之后，我们每一次调用构造器，代码块的语句都会被执行一次。我们可以看出代码块在构造器的第一列就被调用执行了。如果有多个代码块则会按照顺序进行调用
public class Test { public static void main(String[] args) { aa b= new aa("小明"); aa c= new aa("小明",99); } } class aa{ public String name; public int age; { System.out.println("我是代码块"); } public aa(String name){ this.name=name; System.out.println(name+age); } public aa(String name,int age){ this.name=name; this.age=age; System.out.println(name+age); } } 注意事项 static代码块叫做静态代码块，作用时对类进行初始化，而且他随着类的加载而执行，并且只会执行一次。如果时普通代码块，每创建一个对象，就会执行。那么类什么时候会被加载那？？？①创建对象实例时（new）②创建子类对象实例，父类也会被加载③使用类的静态成员（静态方法，静态变量） 对于第一种情况我们已经演示过，我们来看第二种情况，当我们创建aa的子类bb，并且实例化bb，会调用父类的代码块
public class Test { public static void main(String[] args) { bb b=new bb(); } } class aa{ public static String name; public int age; static { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/976ba5f5447b8470f693d2030ceec179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62f2ce0ef21202393bba38c3400e3ef/" rel="bookmark">
			Android Studio中如何新建Activity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Activity是Android应用中最重要的核心组件，每一个应用屏幕就是一个Activity
1.我们需要新建一个类继承Activity类（AppCompatActivity），而且必须实现OnCreate()回调方法，创建Activity时自动调用，相当于构造方法。也可以在Android Studio中直接比较快捷地建Activity，如下图
2.为新的Activity绑定视图页面。在res/layout/目录下建立新的xml布局文件，通过setContentView()方法为Activity绑定该视图文件（如果是快捷生成Activity的话在建Activity时就可以建出layout布局文件，如下图）
3.在AndroidManifest.xml文件中注册Activity。新的Activity，必须在AndroidManifest.xml文件中注册，否则此Activity不可使用。当然，在快捷生成Activity时会自动注册。代码如下样式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc00113b182eab9eee137ad36b8cc1a8/" rel="bookmark">
			使用group by后为什么要用聚合含函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信小伙伴写sql语句时，如果用到了group by分组后，那么其他未分组的 字段一定会用聚合函数，不然的话sql就会报错，下面就来看下为什么要这么使用
一、聚合函数是什么？ 聚合函数：对一组值执行计算并返回单一的值。除 COUNT 以外，聚合函数忽略空值，如果COUNT函数的应用对象是一个确定列名，并且该列存在空值，此时COUNT仍会忽略空值。
意思就是说，使用聚合函数时，给它传入多个值，而它把这些值通过计算给你返回唯一的一个。
二、为什么使用了group by后用需要用聚合函数 因为group by是用来分组的，比如在一个user表中，有id、name、number三个字段
idnamenumber1张三1232张三4563李四7894王五159 那么此时根据name分组后的结果便是：
idnamenumber1、2张三123、4563李四7894王五159 这个时候便会发现id、和number被放在了同一列上，而相同名字的name被放到了同一列上。如果这个时候你再使用select语句时候肯定会报呀，毕竟一个列里面只能有一个值。所以这时我们就需要对id、number字段使用聚合函数。那么得到的结果就是只要一个值了，查询起来才不会报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45604711dca981b9870d39381931e80/" rel="bookmark">
			Obsidian基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 设置中文1. 主题1.1 自定义主题1.2 社区主题 2. 关于插件2.1 核心插件标签模板大纲星标日记 2.2 第三方插件 其他编辑器设置（折叠功能）导出 其他参考 参考： 玩转 Obsidian | 基础设置篇 不会介绍很多花里胡哨的功能，专注于最基本的笔记整理，插件有兴趣可以自己去了解，我应该不会太常用。 官方提供了帮助文档：https://publish.obsidian.md/help/Index
软件内也有帮助手册，如果设置为中文，手册就也是中文的，就是侧边栏下方那个圆圈问号。
这里有个小问题需要注意：这个帮助手册也是一个vault（库），需要打开其他的库，点击圆圈问号上面那个图标，来切换库
0. 设置中文 设置-setting→about-关于→语言-language，选择好语言后，按钮旁边会出现relaunch（重新启动），自己关掉重开是不行的，必须是按relauch让软件自己重启才行。
1. 主题 关于外观显示的主题，obsidian其实有三种，
基础颜色是自带的两种主题，就是黑暗和明亮两种。使用自定义主题，实行个性化最好的方式更换主题（可以从网上下载一些主题），查看社区主题，这个是懒人推荐。 1.1 自定义主题 这里的社区很好，有一个专门的模块是分享Common CSS Hacks（小技巧）：https://forum.obsidian.md/c/share-showcase/9
官方文档关于自定义主题的介绍：
当该功能启用，Obsidian 将会自动在你的库根目录中搜索 obsidian.css 文件，若文件存在，则软件将会按照该文件定义的外观进行显示。
Obsidian 组织已经提供了一系列的主题，其中的某些，已经成为了软件的标志。如果自定义主题功能启用，则设置中将会多出一个 社区主题 的选项。点击下方的使用 按钮即可应用该主题。在基本主题的右方，有一个主题模式的切换按钮，可以自主选择明亮主题还是黑暗主题。
如果你正在构建或者修改你的自定义样式，你可以使用 Ctrl+Shfit+I （Windows/Linux）或 Cmd+Opt+I （macOS）来打开开发者工具，以获取你需要修改的元素的信息。任何 obsidain.css 文件的修改都将被自动检测并且应用。你不需要重启app。请注意，从社区主题中应用一个主题将会覆盖你的 obsidian.css 文件，所以如果你想要保留样式文件的话，确保提前移动或者重命名该文件。
这里注意，在obsidian软件中按 Ctrl+Shfit+I 就可以打开类似谷歌浏览器的开发者工具，所以obsidian也是用electron写的，类似的，typora中使用F12也可以打开开发者工具。
关于typora，如果想借鉴typora的样式，可以去安装目录Typora\resources\app\style，如下：
直接从github下下来的主题css文件，或者自定义的css文件，都被以同一种方式对待了。
如果没有themes这个文件夹，就自己新建一个，然后把主题css文件放进去
选择之后，会立马生效，都不需要重启。。。
1.2 社区主题 点击那个浏览，可以看到如下显示，显示速度和网速相关，如果打不开，这里放一些主题的github地址，其实最关键的就是一个.css文件
https://github.com/kognise/obsidian-atom
https://github.com/cotemaxime/obsidian-amethyst
https://github.com/insanum/obsidian_gruvbox
https://github.com/kmaasrud/clean-theme-obsidian
https://github.com/chad-bennett/warmth-obsidian-theme 配色好看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45604711dca981b9870d39381931e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f028e1a5fa1b80dde0cba5381c04c7/" rel="bookmark">
			C&#43;&#43;分文件调用自己写的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤： 1.创建.h的头文件
2.创建.cpp的源文件
3.在头文件写函数的声明
4.在源文件中写函数的定义（内容）
1.创建.h的头文件 在头文件内编写：
#include &lt;iostream&gt; using namespace std; int F_max(int a, int b); 2.创建.cpp的源文件 在源文件被编写：先要与头文件关联起来加入 ”xxx.h“
#include "FindMax.h" int F_max(int a, int b) { return a &gt; b ? a : b; } 3.在头文件写函数的声明 4.在源文件中写函数的定义（内容） 5.在任意文件调用 调用的时候只需要加上头文件就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07b77385912d19edabb327697d3843e/" rel="bookmark">
			032. 沉默是金
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冥冥中都早注定你富或贫
是错永不对真永是真
任你怎说安守我本份
始终相信沉默是金
一首经典歌曲，导出了很多为人处事的模式，沉默是金，在很多场合下，真的非常适用。世界上很多事情都是相对的，没有绝对的对与错，所以，沉默是金不是永远都适用于所有场景。很多时候，沉默是金，言多必失，但也很多时候，我们并不能沉默，“不在沉默中爆发，就是在沉默中死亡”。言多必失没毛病，沉默是金待商榷。因此，这里讨论沉默是金的时候。
曾经有一句很经典的话语：人用两年时间学会说话，再用一辈子的时间学会不说话。
在现今社会，人与人之间的相处比以往更复杂，要知道古时候已经充斥着各种尔虞我诈，更何况如今互联网时代？所以很多父母都会告知自己的子女：逢人只说三分话,未可全抛一片心。除了父母和年的爱人以外，与其他人交流时，不要把自己人所有个人情感都告知给别人，因为永远不知道谁会在背后捅你一刀。所以，很多时候，沉默是金。
虽然这样，也不是说永远都这样，这些都是建立在未了解对方的前提下，别轻易透漏自己的事情而已。无论古今，还是有很多真挚的情谊在的。无论是现实还是各种小说的主人公，不也都有出生入死的好兄弟吗？只不过这些极为稀有而已。物以稀为贵，所以这些很难得，既然难得，因此不能轻易就相信别人。服父母的告诫也是出于对自己子女的保护，怕子女受到伤害。
就算如金世遗这样愤世嫉俗的人，不也有江南，沁敏妹妹，冰川天女等朋友吗？所以日久见人心，还是可以遇到可信可依的朋友噶。只不过遇到前，沉默是金。
至于在职场，很多场景之下，真的是沉默是金。职场如古时候的官场，充斥着各种勾心斗角，尔虞我诈，在这样的氛围下，既要保有自己的饭碗，也要在群体中生存下来，我们肯定要少说话，多做事，沉默是需要的。因为很多时候，并不知道你可以说什么，不能说什么，所以，在刚入职场时，一定少说话，多做事。
因而，换个形式来表达的话，可以毫不夸张地说，沉默是金是一种高级说话技巧。实在有太多场合起到很大的作用，是一种降维的行为技巧。所以，这个也是需要锻炼的一种能力，因为人在愤怒的时候或者受到不公对待的时候，并不容易控制自己的情绪的，因此，真的需要好好锻炼让自己拥有这种能力，做到适当时沉默，适当时而言，真正的理解沉默是金。
沉默是金，为人低调。不争不抢，做好自己。不骄不燥，默默努力。相信总有出头天。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02fc465d1a80f4854aa82b85f8beef6e/" rel="bookmark">
			2021年终总结——工作第四年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年的主色调是#add367，焦虑！缺钱！
前几年的年终总结链接
先验收下2020年终总结的期望吧 关于年终总结传统项目——减肥 ❌ 今年不但没有瘦下来，还胖了2斤，去年153，现在155
5-8月份的时候赶项目，持续996，那时候感觉身体被掏空，上个楼梯大喘气，手心经常出汗，然后晚上下班到家接近9点的样子，会跑半个小时回家洗澡睡觉，坚持了大概三个星期的样子减到150。
后来上海持续下了一周的雨给我习惯打乱之后再也没去跑过，不过减肥嘛起起伏伏，小问题小问题。。。
关于学位考、英语四级和申请学位 ❌ 下半年的时候报了两门学位考考试，连英语四级也报名了，准备下狠心，四个月时间背水一战。
然后哼哧哼哧复习了两个月学位考的知识，在考前一周学校通知由于疫情问题，学位考取消了，后续考试时间另行通知！我人都傻了好吧！特喵的没日没夜的复习了两个月，我每天下班回去肝，周六周末也天天肝，考前临门一脚了，突然不考了!
就像打仗的时候，士兵没日没夜操练，想着上战场能奋勇杀敌，立大功升迁走向人生巅峰。结果马上就要开战了，将军突然告诉你，这场仗暂时不打了，后面什么时候打另行通知？？？？？？？
一鼓作气再而衰三而竭好嘛，我直接就泄气了，后面的英语四级备考也直接放弃了，拉倒吧，天天紧绷着的日子我受够了！谁知道四级会不会也取消了呢！
结果四级如期举行，下周如常开考，淦！
关于订婚 ✅ 今年五一，跟媳妇儿去她家见了家长，本来想抢两瓶飞天茅台的，结果愣是抢不到，就买了两瓶五粮液，因为平时不怎么吸烟也不是太懂，就把烟钱折现给了。
晚上7点多还是8点到的她家，当晚就安排上了，叔叔阿姨啥的来了一桌人，入席的时候紧张到手抖…好在一杯酒下肚，酒壮怂人胆哈哈哈哈哈。好在媳妇儿一直跟家里人说我不太会喝，所以也没人给我灌酒，整体还算顺利。
准备出发回上海的最后一天，在我媳妇儿家里（她家开饭店的），有两个叔叔来吃饭，叫我过去陪两杯，结果不知道他们带的啥酒，两杯给我干翻了，喝完人就傻了，晕晕乎乎的上了返程的车。由于要从武汉换乘去上海，在武汉住了一晚，当晚胃疼的浑身冒冷汗，吐了一夜，最后吐到浑身没有力气，索性搬了个椅子坐在马桶边上吐。
酒这个东西还是少喝为好
关于今年要成为高级前端开发工程师这件事 ✅ 今年年初跑路入职了一家外企，解决方案部门的开发组，主要负责为公司做一个类MES的系统，从下单到生产到物流等等等等，平台客户供应商三端，涵盖全流程生产。
团队很小，加上leader5个人的配置，两个后端，两个前端，leader同时担任产品和项目经理。开发团队执行大小周！且日常加班不计调休时间，美其名曰弹性时间，打卡再晚也不影响薪资发放。
为什么在这种情况下我还是入职了呢
离我住处实在是太近了，园区有公交车可以接送，坐公交的话，出门到公司也就是30分钟的样子。后面自己买了个小电驴，20分钟就到公司了。团队氛围比较开放，可以尝试任何自己喜欢的技术，我本身是很爱鼓捣的，而且项目刚起步，一个从0开始搭建架构的经历很可贵。前端框架里我只深入使用过ng，刚转前端心理要求上限较低。大饼，转营利部门、扩招、然后自己带前端团队或者转做产品经理。 先说下成果吧，4月份开始做，9月份上线开始给公司各个部门使用。期间一个人从0开始搭建前端项目，项目基于vue2 + ts + class component的写法，ui框架本来想用antd for vue的，但由于之前v2版本用的element，为了保持风格统一，还是妥协了。最后基于饿了么ui，自己搭建一套私有组件库，发布到公司的npm私服了。
为啥是我一个人从0开始搭建项目呢，因为从项目开始一直招到项目结束都没招到第二个！
招聘期间我负责一面，leader二面。从刚开始想招个大佬进来，招到最后想着招个能搬砖的就行，就这样还愣是没招到。期间也有一两个合适的，人家都不乐意来，估计是听说我们实行大小周太肝了吧，不过大小周最近也终于取消了。
回到问题本身，今年究竟有没有达到高级开发工程师呢？我的答案是达到了，也没达到。
如果以去年我对高级开发工程师的认知来说，我是肯定达到要求了的，以我今年认知来讲，还有一些差距，毕竟对我这种后端出身半路转前端的人很多前端相关的基础还是不扎实，尤其css太难搞了。
不过今年的高强度实战下，对架构和CICD流水线搭建终于有了亲自操刀上手的体验，另外ts高级用法，单元测试、私有组件库搭建，打包、代码重构等等方面也都有了更深刻的体会！
关于交房 ✅ 交房通知已经收到了，趁着双12买了点生活必须的家具家电，家电基本都选的小米的，后面考虑上小米的智能家居。
万科的精装修就还行吧，没遇到什么大问题，但也没有惊艳到，有个大量用水时水表啸叫的问题最后也算解决掉了。
这里必须要夸一点万科，交付当天有房管的工作人员驻场，现场就可以办房产证，但是因为急着入住买了家具家电，而且要留钱订婚，钱不够缴契税了，就没去办房产证，准备等订完婚再去办。顺利的话，今年就在武汉过年了。
这几天看到业主群里好多家都在装修了，挺羡慕的。
关于自己未来的路 ❌ 今年是极度蕉绿的一年，幸福感极低，房贷、订婚、彩礼、买车、结婚，这些小boss关卡马上就要到了，我的面板还是稀烂！
有时候就在想别人的23岁是什么样的，会像我这样吗？不能按自己喜欢的方式活着其实挺折磨的，但自己又没有勇气放弃当前这种看似安稳的生活。
一直都认为自己已经看清了30岁前的生活，认清了自己大概的上限和下限！未来的主线任务一个一个就摆在那等着去通关，但我压根就不想去做这个任务怎么办。
媳妇儿说的原话是这样的
规划那么多你累不累啊！就不能走一步算一步吗
问题是我做不到啊，活该我幸福感低，活该我焦虑！
关于去旅游 ❌ 和按摩 ✅ 本来想着一定要去云南或者茶卡盐湖旅游的，但没有钱，计划顺延到明年四月份订完婚去。
今年跟媳妇儿一起去大桶大体验了下，并没有想象中的舒缓，可能去的店不行吧。
今年发生的其他事 今年好像没什么特别的事发生，基本上是按部就班，按去年的计划在走，平平淡淡。
皮蛋这个童养夫不太给力，一直没配上，都被我带去绝育了，现在两个人成了姐妹hhh。
自身技术提升上来讲，去年看了很多理论，有很多想法，在今年都实现了。
从支付宝、微信、银行卡余额和信用卡待还来看，今年又是白干的一年，明年订婚还要一大笔钱，好耶！
2022.1.29日更
今年由于种种原因，没法回去过年，在公司坚持到最后一天，这是我在上海过的第二个年，中午我姥姥跟我开视频时候说，最近村里修的很有牌面，大马路都加宽了，铺的沥青路，不过可惜的是门口的菜园被毁了，不让弄了。那时突然想到自己居然两年没有回家看看了，不知道家里的老黄狗还认不认识，我家的破平房漏水是不是更严重了。
最近一次回家应该是2020年去武汉落户，去乡里派出所把我的户口转出去，那时候家门口一大片槐树林，还有从小时候记事起就在那的杨树都被砍了。那时候房子后面那排杨树还在，后面听我爸说买房的时候凑首付也砍掉卖了。一时百感交集。
我们这代人，90后幸运就幸运在还有个美好的童年，不管小时候家里有多穷，起码上得起学，吃得起饭。村里同岁的小伙伴有很多，那时候还没有手机，一放假村里的小孩都在我邻居家门口那块大空地上玩，玩到天黑被各自父母拉长腔喊 xxx，回家吃饭了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02fc465d1a80f4854aa82b85f8beef6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b84268b1595aebd9a41c8a41d9f812d/" rel="bookmark">
			连续变量离散化类别变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R内置函数实现数组变量转为因子变量有：cut、split、quantile、bincode，本文主要介绍ggplot提供的几个分组函数。
*cut_interval()*按照相同范围分为n组；, cut_number() 按照相同数量(近似)观测值分为n组； cut_width() 按照参数 width指定的宽度进行分组。
语法如下：
# cut_interval(x, n = NULL, length = NULL, ...) # # cut_number(x, n = NULL, ...) # # cut_width( # x, # width, # center = NULL, # boundary = NULL, # closed = c("right", "left"), # ... # ) cut_interval举例 按照相同范围分为6组，使用table进行统计分组数据进行验证：
table(cut_interval(1:10, 6)) # [1,2.5] (2.5,4] (4,5.5] (5.5,7] (7,8.5] (8.5,10] # 2 2 1 2 1 2 table(cut_interval(1:10, 5)) # [1,2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b84268b1595aebd9a41c8a41d9f812d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5acdede9f0b8853357b772c5d2ddf75/" rel="bookmark">
			Excel如何批量删除空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图B列单元格中含有一些空格，现在想要批量删除这些空格。
为了方便演示我将B列数据复制一份到C列中。
选中C2:C12单元格区域
点击下图选项（Excel插件，百度即可了解详细的下载安装方法，本文这里不作详细叙述）
选择【删除空格】
选择【删除所有空格】即可完成
完成效果如下图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba4fce89359ea52f36916cc2f5a125e/" rel="bookmark">
			Makefile基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源地址：https://zhuanlan.zhihu.com/p/56946817?utm_source=qq
前言 通过之前章节的学习，我们对Makefile有个基础的认识，现在开始自己动手写Makefile。
目前网络上有不少可以自动生成Makefile的工具，但很多项目其实没必要那么复杂，完全可以自己动手写出来。
而且对于初学者来说，自己动手写一遍Makefile可以顶看十遍高手写的Makefile，也可以加深对Makefile的理解，将来公司的Makefile有需要修改的时候自己就可以动手搞定，不需要依靠他人，何乐而不为？
源代码介绍 在本教程中用于示例的代码很简单，仅仅是在main函数中调用了fun1及fun2函数，而fun1及fun2独立写在fun1.c及fun2.c里。代码如下：
//main.c
int main()
{
printf(“hello world\n”);
fun1();
fun2();
}
//fun1.c
void fun1()
{
printf(“this is fun1\n”);
}
//fun2.c
void fun2()
{
printf(“this is fun2\n”);
}
3. 第一版Makefile
对于我们的示例代码，不通过Makefile编译其实也很简单：
gcc main.c fun1.c fun2.c -o app
我们知道，Makefile其实就是按规则一条条的执行。所以，我们完全可以把上面那条命令写成Makefile的一个规则。我们的目标是app，按此写法依赖是main.c fun1.c fun2.c，则最终的Makefile如下：
app: main.c fun1.c fun2.c
gcc main.c fun1.c fun2.c -o app
但这个版本的Makefile有两个很重要的不足：
对于简单代码还好，而对于大型项目，具有成千上万代码来说，仅用一行规则是完全不够的，即使够的话也需要写很长的一条规则；
任何文件只要稍微做了修改就需要整个项目完整的重要编译。
基于此，我们在第一版的基础上优化出第二版。
第二版Makefile 在第二版Makefile中，为了避免改动任何代码就需要重新编译整个项目的问题，我们将主规则的各个依赖替换成各自的中间文件，即main.c --&gt; main.o，fun1.c --&gt; fun1.o，fun2.c --&gt; fun2.o，再对每个中间文件的生成各自写条规则比如对于main.o，规则为：
main.o: main.c
​ gcc -c main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fba4fce89359ea52f36916cc2f5a125e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57154b55999173c8741b6a55df87cb32/" rel="bookmark">
			python&#43;OpenCV笔记（三十）：人脸检测与识别（二）——在静态图像与视频上进行人脸检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在静态图像上进行人脸检测 基本流程：
加载图片检测人脸绘制矩形 代码编写 import cv2 import matplotlib.pyplot as plt # 创建CascadeClassifier对象face_cascade，用于加载人脸级联检测 face_cascade = cv2.CascadeClassifier( 'C:/MyOpenCV/cascades/haarcascade_frontalface_default.xml') # 读取图片并转换为灰度图像（CascadeClassifier需要灰度图像） src = cv2.imread('C:/MyOpenCV/cascades/woodcutters.jpg') img = src.copy() gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 进行实际的人脸检测 faces = face_cascade.detectMultiScale(gray, 1.08, 5) for (x, y, w, h) in faces: img = cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2) # 显示图像 fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 8), dpi=100) axes[0].imshow(src[:, :, ::-1]) axes[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57154b55999173c8741b6a55df87cb32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4947a01a93d07239490267b0f9df12a6/" rel="bookmark">
			Vim编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通模式（命令模式）：操作文件(保存，撤销。。)
插入模式：编辑的时候（写的时候）
打开一个文件：
vim 文件名 如果不在同一个目录下，要加路径。
开启编辑模式 i，退出esc，保存并退出:wq，保存不退出:w，:q!不保存退出
开启命令模式，退出esc
H：向左
L：向右
J：向下
K：向上
Ctrl f 向下翻页 forward
Ctrl b 向上翻页 back
G 翻到最后一行
gg 翻到开头
i 光标前插入
a 光标后插入
o 直接另起一行
x 删除光标所在字符
dd 删除一行 p 剪切 联合使用
u 撤销
dw 移除光标往后的单词
b 跳到首字母
e 跳到单词最后
w 跳跃单词
^ 移到开头
$ 移到末尾
yw 复制一个单词
y$ 从当前开始，复制到行末尾
v 可视化模式，选择复制的内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2972186396330211e00a7bce481a2587/" rel="bookmark">
			ES6的常用特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、let关键字 let关键字用来声明变量，使用let声明的变量有几个特点：
不允许重复声明块儿级作用域不存在变量提升 二、const关键字 const 关键字用来声明常量，const声明有以下特点
声明一定要赋初始值不允许重复声明值不允许修改块儿级作用域 声明对象类型使用const，非对象类型声明选择let
三、变量的解构赋值 ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。
//数组的解构赋值 const arr = ['张学友', '刘德华', '黎明', '郭富城']; let [zhang, liu, li, guo] = arr; //对象的解构赋值 const lin = { name: '林志颖', tags: ['车手', '歌手', '小旋风', '演员'] }; let {name, tags} = lin; //复杂解构 let wangfei = { name: '王菲', age: 18, songs: ['红豆', '流年', '暧昧', '传奇'], history: [ {name: '窦唯'}, {name: '李亚鹏'}, {name: '谢霆锋'} ] }; let {songs: [one, two, three], history: [first, second, third]} = wangfei; 注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2972186396330211e00a7bce481a2587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52687a9683757c29aad7efc446fe92ad/" rel="bookmark">
			Promise，async/await JavaScript中的期约和异步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、为什么需要异步二、异步的过程三、promise（期约）1.期约状态2.期约的注意点3.微任务 四、await/async总结 前言 这一部分的理解在JavaScript的中也是比较复杂的东西，虽然对我来说，现阶段还没有什么大的影响，但实际上已经隐隐约约对我解决问题看待的思路和学习中有影响了。外加上一个师妹对这一部分很是迷惑，作为师兄证明能不挺身而出，手把手教学~~~~加上快要国庆了，上班摸鱼的时间多了，怎么能错过整理学习，铲除心中的迷惑的好机会呢
一、为什么需要异步 首先我们的JavaScript是单线程的。这必然导致很多的不便利，我们总不能等着前面的人慢慢的处理完它的事情才轮到我们，这样带浪费资源了、
举个例子：有客人来你家做客了，你爸叫你去泡茶，你需要洗杯子(3min)，烧开水(15min)，冲茶叶(1min)，准备点心(2min)。那么要是单线程下来，是不是需要（3+15+1+2=21min）但实际上我们只需要16min，这就是在数学上的统筹，我们在一开始就烧开水，这个时间里，我们就可以做其他的事情，等到开水好了，其他的也就做完了，也就剩下冲茶叶了。
这就是我们需要对JavaScript进行优化调整的地方，也就是用到异步的思想。
再有个例子就是我们向服务器请求数据，我们不可能说等他好了才执行下面的操作，我们对请求的接口，往往会使用到ansyc 和 awite 来处理。
二、异步的过程 首先，我们来了一个任务，我们会先判断他是同步还是异步，同步的会直接进入到主线程执行，异步的会进入到任务队列，等待主线程的全部执行完后，再把任务队列的任务加载到主线程进行处理
如下：
function load (src, resolve) { let script = document.createElement('script') script.src = src; script.onload = resolve; document.body.appendChild(script); } //a(); //b(); load("a.js", () =&gt; { a(); }) load('b.js', () =&gt; { b(); }) console.log('-------&gt;666666'); 我们创建加载脚本，脚本是“异步”调用的，因为它从现在开始加载，但是在这个加载函数执行完成后才运行。
所以这里会优先执行输出666666，再来执行js的，因为后两者属于异步，同时我们会发现这里a和b的输出顺序会有时不同，这是应为他们是按照谁先加载完成，谁就先加入到任务队列中的。同时我们不能直接调用脚本里面的方法，因为我们不知道脚本什么时候加载完成，我们需要把调用写到回调函数里面去。
那么我们要是想先输出a再来输出b呢，或者说a的值依赖于b的返回值呢？这里就要嵌套回调，那么要把b写到a的回调函数里面了。这样我们可想而知，当只是一两个的时候，我们还比较好处理，但是当我们在b中还需要调用一个c呢？c中再调用一个d呢？…这时候，非常的不便于维护，代码的层次也变得很深，回调地狱就出现了~~~
为了解决上面的问题，我们就有了promise（期约）的出现
三、promise（期约） 1.期约状态 首先期约有是三个状态
待定（pending）兑现（fulfilled）拒绝（rejected） console.log(new Promise((resolve, reject) =&gt; {})); console.log(new Promise((resolve, reject) =&gt; { resolve('成功') })); console.log(new Promise((resolve, reject) =&gt; { reject('失败') })); 结果如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52687a9683757c29aad7efc446fe92ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/672521d667dd883879302cab7dbbb3b6/" rel="bookmark">
			[护网杯 2018]easy_tornado 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考点： 1、SSTI（务器端模板注入） 2、模板中的Handler 做之前先全点一遍看看里面有啥
flag.txt:
看到一个fllllllllllllag，正好有个filename参数，带进去看看：
好吧，我想多了。。
再看一下第二个文件：welcome.txt
它提示了一个单词：render，题目中也告诉了我们是tornado，所以想到SSTI，但想到了是一回事，会不会做又是另一回事，=_=，咱先不着急，先把第三个文件看完：hints.txt
这玩意应该就是filehash的参数了，filename知道，但里面这个cookie_secret是个啥，应该需要我们找出来。
第一步先找一下注入点在哪？
回想一下我们在flag.txt中有一个报错页面，在里面试试有没有注入点
我们传了个2，它返回了个2，说明这边应该有注入点。
但这cookie_secret在哪呢，不清楚那就上网查查呗：cookie.、Tornado小记 – 模板中的Handler.
最后一连串下来大概就是cookie_secret在项目的Application中，而handler 指向RequestHandler
且RequestHandler.settings又指向self.application.settings
所有handler.settings就指向RequestHandler.application.settings了,
我们在handler.settings中就能找到cookie_secret了。
在把他们加密一下：
md5(cookie_secret+md5(filename)) 参考：
wow小华
Tornado小记 – 模板中的Handler
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76808a3d9e9b5e83a4d56b7b005bc138/" rel="bookmark">
			C语言小项目--扫雷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷游戏 一.game.h二.test.c🍑1.菜单🍑2.主函数三.game.c🍑1.统计周围雷的个数🍑2.初始化数组🍑3.打印界面🍑4.存放地雷🍑5.用户输入以及胜利判断🍅&lt;1&gt;标记功能🍅&lt;2&gt;踩雷🍅&lt;3&gt;胜利 🍑6.显示周围的地雷数并递归实现大片扫 第一次写c，发篇博客纪念一下。
一.game.h #pragma once #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;windows.h&gt; //定义数组 #define ROWS 11 #define COLS 11 //实际数组 #define ROW (ROWS - 2) #define COL (COLS - 2) #define EASY 10 //难度 //声明函数 void InitBoard(char board[ROWS][COLS], int rows, int cols, char ret); void Disaplay(char board[ROWS][COLS], int row, int col); void MineBoard(char board[ROWS][COLS], int row, int col); void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); void CountBoard(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y) 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76808a3d9e9b5e83a4d56b7b005bc138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a9f660f3c1e6be440e9713618c85e3/" rel="bookmark">
			在EXCEL中进行趋势拟合与预测的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在跟踪目标达成时，可以根据已经发生的多个周期的目标实际数据，进行趋势拟合，预测目标达成的情况，对趋势拟合常用的有如下6种方式：
例如：某项目4周一个迭代周期，画了燃尽图如下:
序号
剩余估算人时
理想剩余人时
1
120
114.0
2
115
108.0
3
112
102.0
4
110
96.0
5
108
90.0
6
104
84.0
7
98
78.0
8
85
72.0
9
80
66.0
10
65
60.0
11
53
54.0
12
40
48.0
13
42.0
14
36.0
15
30.0
16
24.0
17
18.0
18
12.0
19
6.0
20
0.0
、
如果想预测一下该迭代是否可以按期交付所有的需求，则可以在燃尽图上进行趋势分析。在EXCEL中选中燃尽图，在图表设计菜单下添加图表元素，选择添加趋势线如下图所示：
EXCEL中对上述的6种趋势预测都支持，其中多项式拟合可以选择是2阶，3阶或更高阶，移动平均拟合可以选择周期。对每种趋势预测可以显示出来公式与R平方值，R平方值越大说明拟合效果越好，可以对6种拟合结果都尝试一下，选择拟合效果最好的一种。显示出公式后可以根据该公式计算自己需要的某个时间点的预测值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb19c8d16dda0dc230c332ae070087c/" rel="bookmark">
			Python Django学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境搭建 VM上面安装 centos7虚拟机
win10环境
VScode
为了操作方便，将django环境部署在centos7,写代码在VSCOde中写
环境部署：
centos7 安装samba ，将代码目录影射出来
8.Samba 安装samba操作： CentOS安装Samba 检查虚拟机是否安装samba服务 执行rpm -qa | grep samba 未安装结果为空 已安装结果可能如下： samba-3.5.10-114.el6.x86_64 samba-common-3.5.10-114.el6.x86_64 samba-winbind-clients-3.5.10-114.el6.x86_64 安装samba服务 yum install samba 创建samba用户 可以新增用户，或者直接用root smbpasswd -a root 根据提示设置密码 修改samba配置文件 vim /etc/samba/smb.conf 添加 [root] path=/root browseable=yes writable=yes 设置开机自启动samba chkconfig --level 35 smb on 启动samba服务 service smb start Windows下映射网络驱动 输入目录\\172.24.160.226\root //地址和用户根据自己实际情况填写 用户名和密码： ----------------------------------------安装完成--------------------------------------------------- 注意：映射代码时遇到以下问题：
Win10访问不了Samba网络共享的原因以及解决办法 Win10访问不了Samba网络共享的原因以及解决办法_我爱吃烧饼-CSDN博客_win10 连接smb
开启samba权限，或者看是文件夹权限和用户权限不符合
firewall-cmd --permanent --zone=public --add-service=samba
firewall-cmd --reload
samba共享成功，但是只有文件夹，里面没有文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb19c8d16dda0dc230c332ae070087c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f8d343ee0b992948989b1716f592e2/" rel="bookmark">
			[RoarCTF 2019]Easy Calc 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考点： 1、PHP的字符串解析特性 2、文件读取 3、WAF绕过 4、http请求走私 法1
查看源代码：提示有WAF
访问calc.php:发现可传一个参数num
尝试：
发现num为字母时报错，所以WAF可能是拦截num为字母的情况。所以我们要绕过WAF才能做我们想要的操作，而calc.php的黑名单限制了我们直接文件读取。
所以我们只要做两个操作： 1、过WAF 2、过黑名单 在做第一个操作时：要先了解PHP的字符串解析特性，（网上大佬的解释.）
php把URL参数转换为变量的过程中，它会做两件事： 1.删除空白符 2.将某些字符转换为下划线（包括空格） 所以我们可以这样写
calc.php?%20num=.... //在num前面加个空格这样在过WAF时，WAF接受到的是%20num 而%20num并不等于num，所以并不会触发WAF的规则，在过WAF后PHP再把URL参数转换为变量的过程中，会删除空白符，就变为num=... 做第二个操作，可以用chr(47)来代替’/’，然后构造payload：
calc.php?%20num=var_dump(scandir(chr(47))) 或 print_r(.....) 找到flag所在，读取/f1agg中的内容
calc.php?%20num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)); //file_get_contents() 把整个文件读入一个字符串中。 另一种payload.（注：&lt;?='aa';?&gt;等同于&lt;?php echo 'aa';?&gt;。）
法2
请求走私网上的解释：HTTP请求走私
我的理解是：前后端服务器不是同时接收请求，并且前后端对请求头结束 的位置理解不统一，形成请求走私 CL-CL式
前端发生错误，get请求完整发送到后端
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f77477845187165af5fe2c416ec6746/" rel="bookmark">
			动画的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		—— animation调用
目录
定义及语法
动画的调用
重点注意
常用属性
调用速写
典型例子
波点效果
放映图标效果
打字机及循环移动效果
定义及语法 使用：用@keyframes定义动画，属于CSS3范畴；
格式：
@keyframes 动画名称 { from / 0% { 起始态； } n% { 中间态（可多个）； } to / 100% { 末尾态； } } 动画的调用 调用：用animation属性调用，属于CSS语法；
格式：
在对应的div内部填写：
div{ animation-name:动画名称； animation-duration：持续时间（s）； } 重点注意 定义时，百分比要为整数；对应百分比就是 总时间的划分 。运用多组动画时，由于层叠性，在调用下要用逗号隔开。 常用属性 @keyframes —— 规定动画；animation-name —— 动画名称；animation-timing-function —— 速度曲线 — — 默认：ease、匀速：linear、间隔步长：steps（n）,可制作打字机、动图效果;animation-duration —— 动画一个周期花费时间；animation-delay —— 动画何时开始 — — 默认：0s；animation-iteration-count —— 动画播放次数 — — 默认：1次、无限次：infinite；animation-direction —— 动画下一周期播放方向 — — 默认：normal、逆播放：alternate；animation-play-state —— 规定动画运行或停止 — — 默认：running、暂停：paused，通常与hover共用；animation-fill-mode —— 动画结束后状态 — — 默认：backwards、停此处：forwards。 调用速写 （重点）animation : name duration timing-function （linear匀速） delay（延迟几秒） iteration-count（循环次数） direction（结束时方向）fill-mode（结束后位置）;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f77477845187165af5fe2c416ec6746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dd7f3b36107a8899ada7810d1a43a16/" rel="bookmark">
			H3C交换机堆叠（IRF）配置实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例概述 近期刚做完一个IDC项目正好有两台H3C作为存储交换机提供10Gb iSCSI的挂载，H3C堆叠之前接触不多，本次正好作为记录，包括配置中间容易撞上的坑
IRF简介 IRF不同于传统的物理堆叠，为逻辑堆叠，与思科的vPC逻辑不同，使用和对应场景上更为接近传统的堆叠模式，比较容易理解和使用
下面引用下官方的介绍：
IRF（ Intelligent Resilient Framework，智能弹性架构）是 H3C 自主研发的软件虚拟化技术。它的核心思想是将多台设备通过 IRF 物理端口连接在一起，进行必要的配置后，虚拟化成一台“分布式设备”。使用这种虚拟化技术可以集合多台设备的硬件资源和软件处理能力，实现多台设备的协同工作、统一管理和不间断维护。为了便于描述，这个“虚拟设备”也称为 IRF。所以，本文中的 IRF 有两层意思，一个是指 IRF 技术，一个是指 IRF 设备。
IRF 主要具有以下优点：
• 简化管理： IRF 形成之后，用户通过任意成员设备的任意端口都可以登录 IRF 系统，对 IRF内所有成员设备进行统一管理。
• 高可靠性：IRF 的高可靠性体现在多个方面，例如： IRF 由多台成员设备组成， Master 设备负责 IRF 的运行、管理和维护， Slave 设备在作为备份的同时也可以处理业务。一旦 Master 设备故障，系统会迅速自动选举新的 Master，以保证业务中断，从而实现了设备的 1:N 备份；此外，成员设备之间的 IRF 链路支持聚合功能， IRF 和上、下层设备之间的物理链路也支持聚合功能，多条链路之间可以互为备份也可以进行负载分担，从而进一步提高了 IRF 的可靠性。
• 强大的网络扩展能力：通过增加成员设备，可以轻松自如的扩展 IRF 的端口数、带宽。因为各成员设备都有 CPU，能够独立处理协议报文、进行报文转发，所以 IRF 还能够轻松自如的扩展处理能力。
设备清单 下面清单直接从合同里拉的，2台全万兆光6520，40Gb上行，2根40Gb带模块的线缆，直接用来做IRF
配置思路及注意事项 配置前需要先理解两个概念：
IRF成员角色：
分为Master和Slave，其中Master负责管理整个 IRF，Slave作为 Master 的备份设备运行。当 Master 故障时，系统会自动从 Slave 中选举一个新的 Master 接替原 Master 工作。Master和Slave均由角色选举产生。一个IRF中同时只能存在一台Master，其它成员设备都是Slave。Master与Slave通过设备本身的成员优先级进行选举，优先级越高当选为 Master 的可能性越大
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dd7f3b36107a8899ada7810d1a43a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905141fdbd0ab623e7eaae7683d248f5/" rel="bookmark">
			vue3 数学公式使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		index.html引入
&lt;script type="text/javascript" async src="http://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt; 组件mathJax：
components/mathJax/MathJax.js
// MathJax.js let isMathjaxConfig = false// 用于标识是否配置 const initMathjaxConfig = () =&gt; { if (!window.MathJax) { return } window.MathJax.Hub.Config({ showProcessingMessages: false, // 关闭js加载过程信息 messageStyle: 'none', // 不显示信息 jax: ['input/TeX', 'output/HTML-CSS'], tex2jax: { inlineMath: [['$', '$'], ['\\(', '\\)']], // 行内公式选择符 displayMath: [['$$', '$$'], ['\\[', '\\]']], // 段内公式选择符 skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a'] // 避开某些标签 }, 'HTML-CSS': { availableFonts: ['STIX', 'TeX'], // 可选字体 showMathMenu: false // 关闭右击菜单显示 } }) isMathjaxConfig = true // 配置完成，改为true } const MathQueue = function (elementId) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905141fdbd0ab623e7eaae7683d248f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a93344a294f968e0effa5feeddc5029/" rel="bookmark">
			智能无线麦克风我选塞宾智麦，满足你直播、访谈、vlog的所有录音需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今在抖音、B站、快手等各大短视频平台上活跃着大量的视频创作者，他们用心分享自己精彩的vlog生活，免费制作各种科普教程，组建团队拍摄搞笑段子，给无数网民带来了知识和欢乐。
但细心的朋友会发现，这些视频中有的音质很好，结合视频画面搭配上动情的音乐，刷视频的人瞬间就破防了。而有的视频拍的很好但音质很差，导致精心拍摄的视频没有达到预期的播放效果，很多人看两眼就划走了。
因此好的短视频不仅需要精致的画面，吸引人的剧情，更需要好的音质来诠释所要表达的情感。这个时候就需要一个收音效果很好的麦克风，满足在直播、访谈、vlog、剧情等拍摄过程中的收音效果。
通过多方面综合分析，好的麦克风需要具备以下特点：降噪功能好、便于携带、收音音质好、连接快。今天就给大家推荐一款性价比很高的智能麦克风——塞宾智麦小搬2号，它不仅具备以上所有特点，价格还适中，关键是颜值还杠杠滴。
1、品牌优势
塞宾既是美国著名科学家，也是中国声学科技品牌。塞宾的名字来源于美国物理学家华莱士-克莱门特-塞宾，他不仅创建了声学领域，更是发表了著名论文《混响》，并得出了计算混响的公式——塞宾公式。塞宾科技的创建是为了向塞宾致敬，并注重产品质量投入研发费用，荣获多项国际专利和国家发明专利。其产品塞宾智麦-塞宾小搬荣获CES大奖。
2、整体外观
智麦小搬2号长5.9cm，宽1.5cm，与一节5号电池大小差不多，整体重量16g，有黑白两种颜色。配置3.5mm接口，可以连接耳机、手机、相机等设备。底部留有充电孔，下面的指示灯可以展示工作状态。领夹夹子也方便录音时轻松夹在合适的地方。
3、产品特点
1）、解决降噪差的问题。不同于其他产品降噪处理只是下调音量的“伪降噪”，塞宾小搬2号采用了硬件主动降噪+算法智能降噪的模式，可以在直播拍摄过程中减少环境噪音。
2）、解决不便携带的问题。塞宾智麦小搬2号体积小、重量轻、佩戴方便、可通过蓝牙连接，整体使用非常便捷。
3）、解决音质差的问题。塞宾智麦采用SWISS蓝牙协议核心专利技术，应用了芯基全频降噪技术、芯基双向双通道全频带传技术，加上全指向高保真咪头，可实现360度环绕收音，确保声音真实清澈。
4）、解决操作复杂的问题。塞宾智麦操作简单，蓝牙轻松连接，可适配苹果、安卓手机上大数短视频、直播、唱歌APP。
5）、解决后期难的问题。配备强大的智麦APP，支持全球120多种语言识别并能转换成可编辑的字幕文档，还可以轻松添加背景音乐，视频后期剪辑更轻松高效。
塞宾智麦绝对是一款出色的麦克风，结合其智麦APP（又名塞宾元音），可实现收音、录制视频、采访、接打电话、听音乐等多种场景。如果你正在为拍视频找不到合适的麦克风而烦恼，不妨用塞宾智麦试试效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a1c6fa1c2b3ecb31abe4f77e8592f4/" rel="bookmark">
			正则表达式：基础详解以及在Java中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、正则表达式1.1 正则表达式中的特殊字符1.2 正则表达式所支持的合法字符1.3 方括号表达式1.4 边界匹配符1.5 三种模式的数量表示符 二、应用2.1 String 类2.2 Pattern 类和 Matcher 类 一、正则表达式 1.1 正则表达式中的特殊字符 特殊字符说明$匹配一行的结尾。要匹配 $ 字符本身，请使用\$^匹配一行的开头。要匹配 ^ 字符本身，请使用\^()标记子表达式的开始和结束位置。要匹配这些字符，请使用\(和\)。将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。[]用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\[和\]{}用于标记前面子表达式的出现频度。要匹配这些字符，请使用\{和\}{n}n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。{n,}n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。{n,m}m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。*指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用\*。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于{0,}。+指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用\+。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。?指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用\?。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。.匹配除换行符\n和\r之外的任何单字符。要匹配包括“\n”和"\r"在内的任何字符，请使用像“[\s\S]”的模式。要匹配.字符本身，请使用\.。\用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\字符，请用\\|指定两项之间任选一项。如果要匹配丨字符本身，请使用\| ((A)(B(C)))：第一组 ((A)(B©)) 第二组 (A) 第三组(B©) 第四组©
1.2 正则表达式所支持的合法字符 字符解释\d匹配 0~9 的所有数字\D匹配非数字\s匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等\S匹配所有的非空白字符\w匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线_\W匹配所有的非单词字符\0mnn八进制数 0mnn 所表示的字符\xhh十六进制值 0xhh 所表示的字符\uhhhh十六进制值 0xhhhh 所表示的 Unicode 字符\t制表符（“\u0009”）\n新行（换行）符（‘\u000A’）\r回车符（‘\u000D’)\f换页符（‘\u000C’）\a报警（bell）符（‘\u0007’）\eEscape 符（‘\u001B’）\cxx 对应的的控制符。例如，\cM匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一。 d 是 digit 的意思，代表数字。s 是 space 的意思，代表空白。w 是 word 的意思，代表单词。d、s、w 的大写形式恰好匹配与之相反的字符。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a1c6fa1c2b3ecb31abe4f77e8592f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ea2e4b899dbc899aad75ee636f04f3/" rel="bookmark">
			Git操作失败并提示Another git process seems to be running in this......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git操作的过程中突然显示Another git process semms to be running in this repository, e.g. an editor opened by ‘git commit’. Please make sure all processes are terminated then try again. If it still fails, a git process remove the file manually to continue…
翻译过来就是git被另外一个程序占用，重启机器也不能够解决。
原因在于Git在使用过程中遭遇了奔溃，部分被上锁资源没有被释放导致的。
解决方案： 进入项目文件夹下的 .git文件中（显示隐藏文件夹或rm .git/index.lock）删除index.lock文件即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ecd924863e7a63b6bfbd9e17819298a/" rel="bookmark">
			git相关命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git将本地项目推送到远程仓库 github提示：手动创建一个空项【my-pro-ui】目如何将本地项目my-pro-ui同步进来
echo “# my-pro-ui” &gt;&gt; README.md
git init
git add README.md
git commit -m “first commit”
git remote add origin git@github.com:Share-web/my-pro-ui.git
git push -u origin master
git remote add origin git@github.com:Share-web/my-pro-ui.git
git push -u origin master
一、三个基本配置： Git全局设置
git config --global user.name “账户名称”
git config --global user.email “邮箱地址”
git config --global credential.helper store //本地记住账户
创建一个新的版本库 git clone git@git.远程git地址
cd vue-todos
touch README.md
git add README.md
git commit -m “add README”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ecd924863e7a63b6bfbd9e17819298a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4206ffda78fbc9273943be044e2c52/" rel="bookmark">
			Prometheus的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Prometheus的安装:
1.下载地址：Download | Prometheus
2.解压
3.启动Prometheus
4.访问prometheus界面：通过浏览器访问http://服务器IP:9090就可以访问到prometheus的主界面
5.可以查看监控本机信息（http://11.164.3.125:9090/targets）,也可以查看其他机器的信息但其他机器要安装插件node_porter，以及配置Prometheus的Prometheus.yml的文件
注意：更改Prometheus.yml文件后要重启Prometheus才能生效
[root@server ~]# tar xf prometheus-2.5.0.linuxamd64.tar.gz -C /usr/local/（解压到的路径）
[root@server ~]# mv /usr/local/prometheus-2.5.0.linuxamd64/ /usr/local/prometheus（改名字）
#直接使用默认配置文件启动
[root@server ~]# /usr/local/prometheus/prometheus（你的存放路径） --
config.file="/usr/local/prometheus/prometheus.yml" &amp;
#确认端口(9090)
[root@server ~]# lsof -i:9090
2.node_porter的安装
1.下载地址：Download | Prometheus
2.解压
3.启动node_porter服务
4.访问界面：通过浏览器访问http://服务器IP:9100
[root@agent ~]# tar xf node_exporter-0.16.0.linuxamd64.tar.gz -C /usr/local/
[root@agent ~]# mv /usr/local/node_exporter-0.16.0.linuxamd64/ /usr/local/node_exporter
#里面就一个启动命令node_exporter,可以直接使用此命令启动
[root@agent1 ~]# ls /usr/local/node_exporter/
LICENSE node_exporter NOTICE
[root@agent1 ~]# nohup /usr/local/node_exporter/node_exporter &amp;
#确认端口(9100)
[root@agent1 ~]# lsof -i:9100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4206ffda78fbc9273943be044e2c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c94a9d5fba9a8df19076e94b81e96f8/" rel="bookmark">
			HTML&#43;CSS实现百叶窗效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;style&gt; /* 清除默认边距 */ *{ margin: 0; padding: 0; } /* 去除li的默认样式 */ li{ list-style: none; } /* 去除a的下划线 */ a{ text-decoration: none; } /* 清除img撑大3像素问题 */ img{ display: block; } body{ overflow: hidden; background-color: white; } ul{ margin: auto; margin-top: 100px; width: 805px; height: 320px; /* 溢出隐藏 */ overflow: hidden; display: flex; /* 盒子阴影 */ box-shadow: 2px 2px 5px 5px ; } ul li { /* 关键点一：当没有鼠标悬停时，正常宽度为160px */ width: 160px; border-left: 1px solid black; position: relative; /* 过渡动画，不会的详见我的博客 css3过渡属性*/ transition: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c94a9d5fba9a8df19076e94b81e96f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619d6ea15a471b1ee739ae8fc86e59b4/" rel="bookmark">
			vue--ssr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 什么是服务器端渲染？
1.1 初始化项目
1.2 服务端渲染小案例
1.3 右键查看源代码
二、什么是客户端渲染？
2.1 初始化项目
2.2 查看源代码
三、客户端渲染vs服务端渲染
3.1 运行架构对比
3.2 开发模式对比
四、vue框架中的服务端渲染
4.1 初始化项目
4.2 vue服务端渲染最小demo
4.3 遗留问题
五、理解同构理念
六、Nuxt.js框架使用
6.1. 使用nuxt.js创建一个ssr项目
6.2 启动项目
6.3 查看源代码
6.4 搭建首页
6.5 异步数据获取
七、总结
7.1 服务端渲染和客户端渲染各自指什么？有什么特点？
7.2 同构的本质是什么？
7.3 Nuxt.js中如何实现异步数据获取（asyncData方法）？
一、 什么是服务器端渲染？ server side render 前端页面的产生是由服务器端生成的，我们就称之为服务端渲染
1.1 初始化项目 首先，在 ssr 根目录下新建 server 文件夹
其次，在 server 文件夹里通过 npm init -y 命令初始化一个 node 项目
然后，通过 npm install express --save 命令安装 express 框架（express官方文档）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619d6ea15a471b1ee739ae8fc86e59b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03a9f758d303ba550222c8ae6f643d0/" rel="bookmark">
			2.配置Swaggger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger
@Bean public Docket docket(){ return new Docket(DocumentationType.SWAGGER_2); } 通过apiInfo()属性配置文档信息
private ApiInfo apiInfo(){ Contact contact = new Contact("张三","https://www.baidu.com/","123456789@qq.com"); return new ApiInfo( "张三的SwaggerApi文档", "学习如何配置Swagger", "v1.0", "https://www.baidu.com/", contact, "apache 2.0许可", "https://httpd.apache.org/", new ArrayList&lt;&gt;() ); } Docket 实例关联 apiInfo()
@Bean public Docket docket(){ return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()); } 通过select()方法配置扫描接口的方式
@Bean public Docket docket(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.dream.springboot04.controller")) .build(); } any() // 扫描所有，项目中的所有接口都会被扫描到 none() // 不扫描接口 // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求 withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation) // 通过类上的注解扫描，如.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03a9f758d303ba550222c8ae6f643d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9094166701842070487dd60128b5618f/" rel="bookmark">
			表格纵向表头展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue页面
&lt;template&gt; &lt;div&gt; &lt;table style="width: 100%" class="myTable"&gt; &lt;tr v-for="(item,i) in tableData" :key="i"&gt; &lt;td class="column" align='left'&gt;{{ item.key }}&lt;/td&gt; &lt;td class="column"&gt;{{ item.value }}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/template&gt; 要展示的数据
tableData: [ {key: '名称', value: '1001'}, {key: '工称', value: '篮球'}, {key: '编号', value: '120.00'}, ] 表格样式
&lt;style scoped&gt; .myTable { border-collapse: collapse; margin: 0 auto; text-align: center; } .myTable td, .myTable th { border: 1px solid #cad9ea; color: #666; height: 35px; } &lt;/style&gt; 效果图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9094166701842070487dd60128b5618f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27edd3642da8954820043aeeb460c79f/" rel="bookmark">
			Sphinx在Ubuntu与CtenOS中的安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文搜索，它可以提供比数据库本身更专业的搜索功能，使得应用程序更容易实现专业化的全文检索。Sphinx特别为一些脚本语言设计搜索API接口，如PHP,Python,Perl,Ruby等，同时为MySQL也设计了一个存储引擎插件。
Sphinx 单一索引最大可包含1亿条记录，在1千万条记录情况下的查询速度为0.x秒（毫秒级）。Sphinx创建索引的速度为：创建100万条记录的索引只需 3～4分钟，创建1000万条记录的索引可以在50分钟内完成，而只包含最新10万条记录的增量索引，重建一次只需几十秒。
Sphinx的主要特性包括
高速索引 （在新款CPU上，近10 MB/秒）; 高速搜索 (2-4G的文本量中平均查询速度不到0.1秒); 高可用性 （单CPU上最大可支持100 GB的文本，100M文档）; 提供良好的相关性排名 支持分布式搜索； 提供文档摘要生成； 提供从MySQL内部的插件式存储引擎上搜索 支持布尔，短语， 和近义词查询； 支持每个文档多个全文检索域（默认最大32个）; 支持每个文档多属性； 支持断词； 支持单字节编码与UTF-8编码；
Ubuntu中安装
1，下载适合你服务器版本的Sphinx包，地址：http://sphinxsearch.com/downloads/release/
2，运行安装命令
1
2
3
4
$ sudo apt-get install mysql-client unixodbc libpq5 //安装所依赖的包
$ sudo dpkg -i sphinxsearch_2.2.11-dev-0ubuntu12~trusty_amd64.deb //安装.deb包
$ sudo service sphinxsearch start //启动Sphinx
start: Job is already running: sphinxsearch
3，安装完成，官方文档地址：http://sphinxsearch.com/docs/current.html#installing-debian
CtenOS中安装
1，下载适合你服务器版本的Sphinx包，地址：http://sphinxsearch.com/downloads/release/
2，运行安装命令
1
2
3
4
$ yum install postgresql-libs unixODBC //安装所依赖的包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27edd3642da8954820043aeeb460c79f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d58d80946cba1f55a3c3f82f612d96a/" rel="bookmark">
			element-ui中的table分页多选功能-记住上一页勾选数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue中使用el-table,切换分页常需要记住上一页所勾选的数据。
步骤：
在el-table中添加:row-key=“getRowKeys” &lt;el-table ref="form" :model="form" :row-key="getRowKeys" ........ 然后第一列，即有多选框的一列，添加:reserve-selection=“true” &lt;el-table-column type="selection" :reserve-selection="true"&gt;&lt;/el-table-column&gt; 然后在methods中添加函数： getRowKeys(row) { return row.id }, 完成后需要清空选中,不然会在下一个批量操作中记录上一次选中的数据，
但如果你接下来的工作是跳转/刷新页面，那么这一步也可以省略，看你需求了： this.$refs.form.clearSelection(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b468dd444af6e3122b3dc9f6287d01e/" rel="bookmark">
			Cmder的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cmder的安装与配置 一、下载地址二、配置三、Cmder鼠标右键快捷点打开设置四、修改默认命令提示符 λ 一、下载地址 地址：https://cmder.net/
鼠标滚轮转到下边可以看到 Download，在这里选择 完整版 Download FULL
点击下载成功压缩包，放到自己选择的路径解压就可以
解压完后，运行文件夹中的cmder.exe这个程序，便打开了我们的cmder了。
二、配置 1）、汉化，点击窗口右下角的如下图，选择settings。
在通用中，我们设置语言为中文，这里会有一个BUG，发现关闭后，又会变成英文，我这里测试了二次，第一次设置好后，会恢复成英文。关闭后，再打开，再设置一次，就会起效果了。这可能是这个工具的BUG。
大小&amp;位置中，我们可以设置窗口的大小，宽度和高度，我们可以设置百分比，自己想设多少设多少。
点击启动，我们设置启动的bash,我们最好使用bash::bash,因为这个和我们linux命令就很接近了。
设置快捷键，在过滤热键中，我们搜索分屏.便 可以对分屏设置快捷键，我设置的上下分屏为alt + d, 在右分屏为 all + s
设置成功后，点击保存设置。
分屏后的效果如图：
三、Cmder鼠标右键快捷点打开设置 样式图：
命令：以管理员的身份打开Cmder.exe,
输入命令: Cmder.exe /REGISTER ALL
执行完之后回到桌面，点击鼠标右键就可以看到显示了。
四、修改默认命令提示符 λ 打开Cmder所在的文件位置，进入到vendor文件夹下，打开 clink.lua 文件，找到第 51 行
修改成 $ 符，保存退出就可以了
再重新打开就看到修改成功了
OK，Cmder安装配置就到这，大家一起加油！
Fighter_ma： 弱小和无知不是生存的障碍，傲慢才是~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faaf6b5ec93d5999be807f46e2ab4805/" rel="bookmark">
			编译原理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.编译程序的基本概念、结构
2.文法（描述词法规则和语法规则的工具）：文法G可以定义成四元组（VN，VT,S,P）
VN是一个有限集合，称为非终结符集，其中的每个元素称为非终结符;VT是一个有限集合，称为终结符集，其中的每个元素称为终结符;S∈VN是一个特殊的非终结符，称为文法起始符号;Р是一个有限的集合，其中每个元素是形如α→β的产生式规则，α，β都是由非终结符和终结符构成的符号串，包括空串，且α中至少含有一个非终结符。（产生式集合） 在描述词法规则时，终结符是字母表上的字母，非终结符是为区分不同类型单词符号引入的文法符号。在描述语法规则时，终结符是单词符号，非终结符表示各种语法范畴(表达式、语句、分程序、程序)。
0型文法（短语文法）等价于图灵机，产生式规则没有限制。
1型文法（上下文有关文法）产生式规则α→β必须满足|αl≤|βl，只有S→ε例外，|αl，|βl表示长度。
2型文法（上下文无关文法）产生式规则A→β形式，其中 A∈VN，β为由终结符和非终结符构成的符号串，包括空串。
3型文法（正则文法）等价于有限自动机，产生式规则具有A→αB或者A→α的形式,其中A和B都是文法非终结符,α是由文法终结符构成的符号串，包括空串。
3.推导：所谓推导，是对于一个含非终结符A的符号串，利用规则A→α，把A替换成α得新符号串的过程。（最左推导：符号串最左边的非终结符进行替换与最右推导）
4.语法树：推导过程用一棵树的形式表示出来，每一步推导对应一步树的增长，开始时树中只有用文法起始符号标示的根节点，在推导的每一步，当利用规则A→A1A2...An替换当前符号串中的A时，其中A为非终结符，A1,A2...A为任意的终结符或者非终结符，则产生以A为父节点的节点A1,A2...An，这样的树称为语法树。
句型:从文法起始符号出发，经过有限步推导能够推导出来的符号串称为句型。
句子:只由终结符构成的句型称为句子。
语言:所有句子的集合构成该文法描述的语言。
存在两个不同的语法树，或文法存在句子或者句型，该句子或者句型按照文法有两种不同的最左或最右推导称为二义文法。
5.短语、直接短语、句柄、素短语、最左素短语
参考(8条消息) 编译原理 —— 短语、直接短语、素短语和句柄_starter_____的博客-CSDN博客_直接短语
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c04cb9de6951ec7632ac37919d5918/" rel="bookmark">
			解决iframe标签嵌入一个现有的网站无法登录的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以iframe标签嵌入一个现有的网站到项目中，嵌入的网站无法正常登录，直接在浏览器地址栏输入url并登录是正常的。于是开始探索…
问题分析
由于后续接口提示401，判断是登录接口鉴权失败导致的，于是观察登录接口的请求响应，发现了端倪：
翻译为大白话就是：写入Cookie失败。原因是没有显式设置cookie的samesite属性，导致被默认为Lax，又因为响应的接口属于非顶层导航的跨站请求，浏览器将其屏蔽了！
这个提示包含了两个信息：
设置cookie时有个连带的SameSite属性
top-level-navigation(顶层导航)
接下来细说！
SameSite属性
该属性一般是随着Set-Cookie响应头设置的，语法为response.setHeader(“Set-Cookie”,“CookieName=CookieValue;SameSite=propValue”)，表示该cookie是否可以携带在跨站请求中，可以取三个值：
Strict，表示完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。
Lax，大多数情况下不发送第三方 Cookie，但是导航到目标网址的 Get 等请求除外
None，表示关闭跨站限制，但是需要显式设置Secure属性并配置https
如果不设置，浏览器会默认为Lax。正如上文所提到的。
顶层导航（top-level navigation)
什么是顶层导航？
使用浏览器地址栏输入www.baidu.com，打开百度首页，打开控制台可以看到当前页面除了百度的应用之外还有三个应用（Google翻译、Grammarly，UserTesting），其他三个是我安装的插件。
对浏览器而言，百度是top-level-navigation，其他三个则不是，因为地址栏里输入的是百度的网址。
解决问题
汇总一下就是：
登录接口是一个来自非顶层导航的接口（iframe嵌套），该接口默认的SameSite属性值Lax要求iframe里应用的网址与顶层导航应用的网址保持一致。
方案有三个：
保证两者的网址一样（域名，测试发现同一主域名下不同的子域名也是可以的）。
主动设置SameSite为Set-Cookie:Key=Value;SameSite=None;Secure,确保协议为安全协议https
禁用浏览器对SameSite的默认配置（只会对未设置的SameSite属性有效），方式如下：
第一种最为简单直接。
第二种需要修改服务端代码。
第三种在用户层面非常不现实。
果断采用了第一种方案。
原文链接：https://blog.csdn.net/qq_40882724/article/details/115605160
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5182c74fdf916cec14c5f9e10c7bc07/" rel="bookmark">
			【信号与系统】学习记录2——1.2基本信号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零.前言 按照PPT的分章来决定每篇的内容长度与分节。
一.阶跃函数ε 1.1 定义 1.2 性质 阶跃函数的积分是斜坡函数，即：
二.冲激函数δ 2.1 定义 其推导过程为：
2.2 关系 2.3 作用 冲击函数可以描述间断点的导数
三.冲激函数的广义函数定义 3.1 函数的定义 3.1.1 普通函数的定义 就我们学的那种 映射的概念。
3.1.2 广义函数的定义 很类似于普通函数，但是广义函数的自变量换成了检验函数：φ(t)
当然，定义式不唯一。
3.2 冲激函数的广义函数定义 我再简言之：也就是说，一个冲激函数作用于一个检验函数（其实就是被作用的函数），两个函数的积的积分刚好能等于检验函数t=0的值。
也就是说，满足这个定义式，且对任意检验函数都有用的函数，就可以叫冲激函数了。
如果还有不懂可以看后面的一节内容
四.冲激函数的取样性质 4.1 零点取样 f ( t ) δ ( t ) = f ( 0 ) ⋅ δ ( t ) ∫ − ∞ + ∞ f ( t ) ⋅ δ ( t ) d t = f ( 0 ) ⋅ ∫ − ∞ + ∞ δ ( t ) d t = f ( 0 ) f(t)δ(t)=f(0) \cdot δ(t) \\ \\ \\ \int_{-∞}^{+∞} f(t) \cdot δ(t)dt = f(0) \cdot \int_{-∞}^{+∞} δ(t) dt = f(0) f(t)δ(t)=f(0)⋅δ(t)∫−∞+∞​f(t)⋅δ(t)dt=f(0)⋅∫−∞+∞​δ(t)dt=f(0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5182c74fdf916cec14c5f9e10c7bc07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517211137eef0bd4ba6422d0246a01ef/" rel="bookmark">
			moment.js 常用用法及时区转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间戳转换 const nowTime = moment().format(); console.log('获取当前时间', nowTime); const nowSecondTimestamp = moment(nowTime).unix(); console.log('当前时间转换为秒级时间戳', nowSecondTimestamp); const nowMillisecondTimestamp = moment(nowTime).valueOf(); console.log('当前时间转换为毫秒级时间戳', nowMillisecondTimestamp); 年份操作 const thisYear = moment(nowTime).format('YYYY'); console.log('获取当前年份', thisYear); const preYear = moment(nowTime).subtract(1, 'year').format('YYYY'); console.log('获取现在时间的上一个年份', preYear); const targetPreYear = moment(preYear).subtract(1, 'year').format('YYYY'); console.log('获取指定年份的上一年', targetPreYear); 月份操作 const thisMonth = moment(nowTime).format('MM'); console.log('获取当前月份', thisMonth); const preMonth = moment(nowTime).subtract(1, 'month').format('MM'); console.log('获取上个月份', preMonth); const thisMonthDays = moment(nowTime).daysInMonth(); console.log('获取当天月份天数', thisMonthDays); const preMonthDays = moment(nowTime).subtract(1, 'month').daysInMonth(); console.log('获取上个月份天数', preMonthDays); const targetMonthDays = moment(preMonth).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/517211137eef0bd4ba6422d0246a01ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e3074434e2f59f06de975fbeb205135/" rel="bookmark">
			CSSG：Cobalt Strike Shellcode生成工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSSG
CSSG是一款功能强大的Cobalt Strike Shellcode生成工具。本质上来说，CSSG是一个具备攻击性的Python脚本，广大研究人员可以使用它来轻松生成并格式化信标Shellcode。
该工具支持生成无阶段信标Shellcode，并带有暴露的退出方法、额外的格式化、加密、编码、压缩和多行输出等功能。
注意：Shellcode的转换通常需要按菜单顺序降序执行。
执行要求
可选的AES加密选项使用/assets文件夹中的python脚本实现。
具体取决于要安装的pycryptodome包来执行AES加密。
在使用pip命令安装pycryptodome包时，具体取决于你的Python环境：
python -m pip install pycryptodome
python3 -m pip install pycryptodome
py -3 -m pip install pycryptodome
py -2 -m pip install pycryptodome
我们可以在pip安装执行完成之后检测pycryptodome包的安装情况，使用命令如下：
python -m pip list | grep crypto
生成器将会使用系统默认的“python”命令来启动AES加密脚本。
工具下载
广大研究人员可以使用下列命令将该项目源码克隆至本地并使用：
git clone https://github.com/RCStep/CSSG.git
Shellcode生成器选项
监听器：
使用"…"按钮选择一个有效的监听器。Shellcode将会根据选择的监听器来生成。
发送器：
无阶段（CSSG是一款不支持阶段操作的Shellcode生尘器）。
退出方法：
进程：当信标关闭之后，退出整个进程；
线程：当信标关闭之后，退出运行信标的线程；
本地Shellcode选项：
如果要从现有信标执行Shellcode，则可以使用该选项。
生成一个信标Shellcode Payload，该Payload可以从同一架构父信标继承关键函数指针。
现有会话：
Shellcode会将会话元数据提取至父Beacon会话中。
Shellcode将会在此信标会话中执行。
x86选项：
生成x86 Shellcode，默认生成x64 Shellcode。
使用Shellcode文件：
使用外部生成的原始Shellcode文件代替生成信标Shellcode。
这将允许我们使用以前导出的Shellcode文件或其他工具（Donut、msfvenom等）的输出。
格式化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e3074434e2f59f06de975fbeb205135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4a688ee3fb0f6ea5f78d6e58d5bbb8/" rel="bookmark">
			直接利用pycharm打包python的一些经验总结：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python打包的一些经验总结：
项目场景： 利用pycharm打包python，先从手动打包开始，逐步完成了pycharm集成环境打包，一键式打包py文件，爽！！！ 做了一个非常简易的学生图书管理系统，是用pyqt5开发的UI，mysql做的数据库，想把这个小程序打包一下，其中涉及到一些问题需要总结。
问题描述： 1、打包过程提示：The ‘enum34’ package is an obsolete backport of a standard library
2、打包过程中被杀毒软件中断
3、anaconda中查找pyqt5的安装路径
4、cd命令一直没有掌握 -_-||
5、下一步把它集成到pycharm中（已经解决，详见文章后段！！！）
解决方案： 1、需要通过命令行：pip uninstall enum34先卸载。 2、打包过程中关闭杀毒软件和安全卫士
3、C:\Users\SZ-MP\anaconda3\Lib\site-packages\PyQt5\Qt5\bin 这是我电脑上面的Anconada安装位置。这个和没有安装anconda的情况不太一样。
4、在anconda命令行中输入（cd命令转到需要打包文件位置。cd C:\Users\SZ-MP\Desktop\Student achievement management system******这是我自己的打包目录）
5、具体执行 pyinstaller --paths C:/Users/SZ-MP/anaconda3/Lib/site-packages/PyQt5/Qt5/bin -F -w DB_DIS_TBW.py 其中–paths C:/Users/SZ-MP/anaconda3/Lib/site-packages/PyQt5/Qt5/bin 是指定pyqt5的安装位置。
在pycharm集成环境中添加pyinstaller的功能。我们分为两个部分1、不带UI界面的.py 2、带UI界面的pyqt5及相关sql处理的.py文件。
其中对第一种如下图来设置pycharm的ExternalTools：
注：name是可以随便起的。
program-------是pyinstaller的安装位置
argument-------是打包命令格式 -F 外加.py
workingdirectory------是文件在目录-----工作目录
这是完成了普通打包
下面的是含有UI界面的打包设置
这里只有打包命令方面不一致，需要指明pyqt5的安装路径。详见前面的。
经过测试，本方法可以很好地和pycharm结合起来！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9313ffafcf11a6fccbcece2b31d7f7f7/" rel="bookmark">
			Unity 机器学习(ML-Agents) 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity 机器学习 ML-Agents 基础 Unity 官方示例下载ML-Agents 部分Python 下载 AnacondaAnaconda 环境变量Anaconda 基础环境Anaconda 虚拟环境构建 ML-Agents安装 ML-Agents Python 包安装 ML-Agents 包 ML-Agents 入门指南Unity Hub 部分虚拟环境 训练虚拟环境 训练运行：虚拟环境 开始训练：虚拟环境 观察训练进度：虚拟环境 停止训练虚拟环境 恢复训练虚拟环境 训练模型 ML-Agents 打造新的学习环境ML-Agents 资产导入Unity 场景创建Unity 代码部分 Anaconda 执行rollerball_config.yaml 机器学习逻辑处理代码Anaconda 虚拟环境 地址合集虚拟环境命令小结虚拟环境安装虚拟环境 训练命令 Unity 官方示例下载 Unity 中国 地址 : Unity 中国 ML-Agents 示例下载 进入官方网站 点击机器学习代理 ML-Agents 部分 ML_Agents: 下载GitHub 项目.
下载 机器学习项目 选择想要下载的版本 当然你也可以在主页自主点击文档。 Unity ML-Agents 工具包文档地址
Python 下载 Python 下载地址
使用 ML-Agents Toolkit 的条件： 重要的是：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9313ffafcf11a6fccbcece2b31d7f7f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e2e5982ac862eb910463957a833e726/" rel="bookmark">
			切片、迭代、列表生成式、生成器和迭代器-python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于切片相关
1、读取元素
（1）较为笨拙的方法
&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] &gt;&gt;&gt; r = [] &gt;&gt;&gt; n = 3 &gt;&gt;&gt; for i in range(n): ... r.append(L[i]) ... &gt;&gt;&gt; r ['Michael', 'Sarah', 'Tracy'] （2）经典方法
通过切片的方式获取元素值
&gt;&gt;&gt; L[0:3] ['Michael', 'Sarah', 'Tracy'] &gt;&gt;&gt; L[:3] ['Michael', 'Sarah', 'Tracy'] &gt;&gt;&gt; L[1:3] ['Sarah', 'Tracy'] ###倒数切片 &gt;&gt;&gt; L[-2:] ['Bob', 'Jack'] &gt;&gt;&gt; L[-2:-1] ['Bob'] （3）其他操作
跳数值选择数据。
&gt;&gt;&gt; L = list(range(100)) &gt;&gt;&gt; L [0, 1, 2, 3, ..., 99] &gt;&gt;&gt; L[:10:2] [0, 2, 4, 6, 8] ###所有数，每5个取一个： &gt;&gt;&gt; L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] （4）元组和字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e2e5982ac862eb910463957a833e726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60992924e0d9a0827d576a1079dcfeb/" rel="bookmark">
			Qt信号槽进阶及误区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lambda写法 Qt 中信号槽lambda表达式优缺点：
好处
代码更加紧凑,不用特意费力去定义一个常规的函数; 坏处
一旦写的过长,臃肿,代码可读性会变差; C++ 中lambda表达式构成
[capture](parameters) mutable -&gt;return-type { statement } [函数捕获列表](操作符重载函数参数)mutable -&gt;返回值{函数体} [capture]：函数捕获列表。始终出现在Lambda函数的开始处。[]是Lambda引出符。编译器根据该引出符来分析后续代码是否是Lambda函数。函数捕获列表能够捕捉上下文中的变量以供匿名函数使用;(parameters)：操作符重载函数参数。和普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略;mutable：mutable修饰符。默认情况下，Lambda函数是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）;-&gt;return-type：返回类型。我们可以在不需要返回值，则可以连同符号”-&gt;”一起省略。并且，在返回类型明确的情况下，也可以省略该部分，编译器会根据返回类型进行推导;{statement}：函数体。内容与普通函数一致，除了可以使用参数之外，还可以使用捕获列表中的变量 捕获列表[]的几种情况
[this]捕捉当前对象的this指针,让 Lambda 表达式拥有和当前类成员同样的访问权限;[=]表示值传递方式捕捉所有父作用域的变量(包括this);[&amp;]表示引用传递方式捕捉所有父作用域的变量(包括this);[var]表示值传递方式捕捉变量var,函数体内不能修改传递进来的var的拷贝,如果想修改必须加上mutable;[&amp;var]表示引用传递捕捉变量var;[vara,&amp;varb]值传递方式捕捉变量vara,引用传递捕捉变量varb;[this,&amp;varb]捕捉当前对象的this指针,varb则按引用传递捕捉变量;[=,&amp;vara,&amp;varb] vara和varb按引用进行传递外，其他参数按值进行传递 lambda 常见错误
当省略调接收者时，lambda中无法捕获发送者是谁
connect(ui.pushButton, &amp;QPushButton::clicked, [this]() { QPushButton* btn_ptr = qobject_cast&lt;QPushButton*&gt;(QObject::sender()); qDebug() &lt;&lt; __FUNCTION__ &lt;&lt; btn_ptr; /* TestMoc::{ctor}::&lt;lambda_c4543731355bcb6d7c92b1afa67262ef&gt;::operator () QWidget(0x0) */ }); 使用QTimer::singleShot，可能会导致崩溃
void TestMoc::testMocSlot() { //方式1 ,正确 QTimer::singleShot(5000, this, [this]() { //访问类成员 }); //方式2，可能错误 QTimer::singleShot(5000, [this]() { //访问类成员 }); } 以上区别在于第二个参数，为了访问类成员，lambda都捕获this指针。
方式1：第二个参数接受对象传入this指针，若Qobject对象在超时前销毁，超时后也无法调用lambda，所以不会奔溃。
方式2：如果QObject对象在超时前已经销毁，则超时时仍会调用lambda，而lambda捕获了this指针，当访问成员变量或函数时，这时导致奔溃。
队列连接 引用传递问题 当在主线程和子线程中，通过信号与槽发送QString，遇到以下问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a60992924e0d9a0827d576a1079dcfeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723843aedd80037bb768e93c8e69197b/" rel="bookmark">
			GithubDesktop提交代码问题--上传空文件夹和OpenSSL、Failed to connect to github.com port 443: Timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空文件夹问题 上传文件夹要确保文件夹内没有.git文件夹，否则会上传空文件
上传中
提交后上传失败OpenSSL或Failed to connect443之类的错误终极解决方案 检查自己hosts路径C:\Windows\System32\drivers\etc路径下的hosts文件里github网站域名ip对不对（github.com一般不会变，github.global.ssl.fastly.net是寻找最快网络，会随时变化），没有的需要添加：
#github #20.205.243.166 github.com #103.214.168.106 github.global.ssl.fastly.net 可以上ip地址查询网站去查询最新的ip地址
点击查询会跳到新的网页
更换到最新的就行，保存。
如果没有权限，可以右键文件属性–&gt;安全–&gt;编辑，给当前用户增加修改写入权限
查看自己的github，发现已经上传成功
参考链接：
https://www.cnblogs.com/jxd283465/p/14280675.html
https://blog.csdn.net/qq_34817440/article/details/106420689
https://www.zhihu.com/question/278431031/answer/486857507
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b6915e1aaeacd7c7af1b35a4d67ad5/" rel="bookmark">
			R 计算时间序列的交叉相关性教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍两个时间序列的交叉相关性，并通过示例说明R的计算过程。
时间序列交叉相关性 交叉相关性是衡量一个时间序列与另一个时间序列的延迟版本的相似程度。这种类型相关性可以用于预测另一个时间序列的未来值，也就是说，当前时间序列是另一个时间序列的先行指标。
这种类型相关性常用在很多领域，包括：
经济领域
consumer confidence index (CCI) 消费者信心指数一般认为是gross domestic product (GDP) 的先行指标。举例：如果CCI在给定月份较高，则GDP在x月之后也会升高。
商业领域
营销支出通常被认为是企业未来收入的先行指标。例如，如果企业在某个季度的市场营销花费较常高，那么在接下来的x个季度中，总收益将会提高。
生物领域
海洋污染情况被认为是某种海龟数量的先行指标。例如，如果某一年的污染更严重，那么预计x年后海龟的总数会更少。
下面我们通过示例来计算两个时间序列的交叉相关性。
R计算示例 假设我们有市场营销费用与连续12月销售收入的数据(单位：千元)。我们可以利用ccf()函数计算两个时间序列的交叉相关性：
#define data marketing &lt;- c(3, 4, 5, 5, 7, 9, 13, 15, 12, 10, 8, 8) revenue &lt;- c(21, 19, 22, 24, 25, 29, 30, 34, 37, 40, 35, 30) ccf(marketing, revenue) 上图现实两个时间序列在不同滞后期间下的相关性。要查看实际相关性值，可以使用下面语法：
#display cross correlation values print(ccf(marketing, revenue, plot = FALSE)) # Autocorrelations of series ‘X’, by lag # # -7 -6 -5 -4 -3 -2 -1 0 1 2 3 # -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b6915e1aaeacd7c7af1b35a4d67ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db233e0624972d8d37519a26a6d5e4dc/" rel="bookmark">
			解决：adobe界面模糊且pdf文件模糊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，打开程序的exe文件所在位置
2，右击exe文件------属性------兼容性------更改高DPI设置------打勾
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d448c4352489a27f705d8e3d683f069c/" rel="bookmark">
			C语言简单的代码让你的期末设计系统界面更加亮眼（中国人不骗中国人)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言简单代码让你的毕设系统界面更加亮眼（中国人不骗中国人) 我在做大一期末设计（订餐管理信息系统）时，看到主菜单输入a\b\c再按回车进入各个功能界面感觉太拉了，于是想出了以下效果：
就是简单的按a左移选中框，按d右移选中框，按空格进入的效果，但比之前输入字母选择更加美观。
具体实现思路如下： 先附上完整代码
int n = 0; int i = 1; printf("\033[32m按任意键进入系统..."); while (1) { if (kbhit()) { i = getch(); if (i == 'd') { n++; } else if (i == 'a') { n--; } else if (i == 'g') { if (n == 1) { enter(&amp;count); } else if (n == 2) { display(count); } ...后面还有5个n的情况没写完 } if (n == 8) { n--; } if (n == 0) { n++; } } if (n == 1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d448c4352489a27f705d8e3d683f069c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b68ad977c2a814fd21842414a0969dd1/" rel="bookmark">
			QT中TextBrowser插入文本后，内容显示自动滚动与不滚动控制实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动滚动效果：
不刷新效果：
QTextBrowser插入文本的方式有三种：
insertHtml：用html方式插入文本，不会自动换行，不会自动刷新光标
insertPlainText：纯文本方式插入，不会自动换行，也不会自动刷新光标
append:在新行插入文本，支持html语言，自动刷新光标
所以要做到内容是否自动滚动，可以选择insertHtml方式，然后手动控制内容显示滚动或者不滚动，参考代码：
ui.ser_mess_browser-&gt;insertHtml(QString("&lt; font color = \"#00BFFF\"&gt;RECV: %1&lt;/font&gt;&lt;br&gt;").arg(data_s)); if (ui.auto_fresh_falg-&gt;isChecked()) { ui.ser_mess_browser-&gt;moveCursor(ui.ser_mess_browser-&gt;textCursor().End); } ser_mess_browser是QTextBrowser的名称，插入的内容根据自己的需要改变，需要注意的是插入html需要手动换行，使用的是&lt;br&gt;标签
auto_fresh_falg是上图中“自动刷新屏幕”的选择框（QCheckBox)，通过检查他的状态，判断是否需要控制显示内容滚动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc18422d14445e3d585dfaa5b9abd13/" rel="bookmark">
			colmap 已知pose 重建 kitti数据尝试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Frequently Asked Questions — COLMAP 3.7 documentation
COLMAP已知相机内外参数重建稀疏/稠密模型 - thronsbird - 博客园
Colmap根据相机内外参数重建稀疏模型_m0_47677188的博客-CSDN博客_colmap 命令行
准备 images.txt
现利用 colmap的script 提取database中的 id-name 对应关系
colmap/scripts/python/database_slz.py python /colmap/scripts/python/database_slz.py --database_path 04/model/database.db 然后 通过 home_move/dataset_home/kitti/colmap0109/kitti_pose2colmap_images.py 创建images.txt
python kitti_pose2colmap_images.py ../04/04.txt id-name.txt 代码为
from scipy.spatial.transform import Rotation as R import numpy as np import sys path_cam= sys.argv[1] path_idname= sys.argv[2] f= open(path_cam, 'r') lines = f.readlines() f_id_name= open(path_idname, 'r') f_id_name_lines= f_id_name.readlines() f_w= open('04/model/images.txt', 'w') id_name= {} for l in f_id_name_lines: l= l.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc18422d14445e3d585dfaa5b9abd13/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/157/">«</a>
	<span class="pagination__item pagination__item--current">158/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/159/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>