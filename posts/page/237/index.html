<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0880652989d63f8d5f1aae0fac1fc63/" rel="bookmark">
			【常规版本】SIS-OAS 1.53.0(2019/5/23发布)版本 --需求评审 ---模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; @珏哥、劲松哥、波哥
请帮忙进行邮件评审，此次评审材料如下：
1.部署文档，已更新到conf上：http://conf-stock.paic.com.cn:8080/pages/viewpage.action?pageId=28689177&amp;sortBy=date&amp;sortOrder=descending
2. SIS-OAS_证券移动开户系统1.53.0常规版本JIRA地址： http://jira-stock.paic.com.cn:8080/issues/?filter=14111
3.本版本计划周四（5/23）发布生产；
4.评审角色列表
角色
人员
职责与分工
评审资料作者
杨琼
对产出质量负责，评审的组织与记录
评审组成员
陈智旭
评审关联版本影响
陈劲松/陈珏/陈波
评审运维需求（包括关联系统影响、防火墙、部署说明等）
杨琼
测试要求（测试范围、测试数据、测试用例等）
需求列表：
关键字
概要
开发人员
测试人员
状态
产品经理
组件信息
计划上线时间
产品验证方式
OAS-1062
雪球开户前端后台服务迁移SIS-OAS
金德志
梁传兢
开始
任园园
SIS-OAS-JTC-APP-OPENACC　2019/5/23
发布后验证
OAS-1071
优化anychat坐席挂断的弹框
张富龙
颜丽
开始
任园园
SIS-OAS-JTC-APP-OPENACC　2019/5/23
发布后验证
OAS-1072
后管平台主题调整及优化细节
汪顺昌, 于瑞
梁传兢
开始
任园园　SIS-OAS-JTC-APP-WEB-ADMIN
2019/5/23
发布后验证
需求及修正说明：
JIRA编号需求(跟JIRA主题一致)涉及组件修改点（包括脚本列表） OAS-1062雪球开户前端后台服务迁移SIS-OASSIS-OAS-JTC-APP-OPENACC oas_core_openacc：增加雪球发送短信入口，雪球kh-service组件的接口对应迁移至开户oas_xueqiu_openacc中，接口逻辑基本保持不变 JIRA编号
需求(跟JIRA主题一致)
涉及组件
修改点（包括脚本列表）
OAS-1062
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0880652989d63f8d5f1aae0fac1fc63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515d113a99f27dd03bf88892b01c0d29/" rel="bookmark">
			Android实现从底部弹出Dialog(和PopWindow实现的效果一样)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局文件:dialog_custom_layout.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#fff"&gt; &lt;TextView android:id="@+id/tv_take_photo" android:layout_width="match_parent" android:layout_height="50dp" android:text="拍摄" android:gravity="center" android:textSize="16sp" android:textColor="@android:color/background_dark"/&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="@android:color/darker_gray"/&gt; &lt;TextView android:id="@+id/tv_take_pic" android:layout_width="match_parent" android:layout_height="50dp" android:text="从手机相册选择" android:gravity="center" android:textSize="16sp" android:textColor="@android:color/background_dark"/&gt; &lt;View android:layout_width="match_parent" android:layout_height="5dp" android:background="@android:color/darker_gray"/&gt; &lt;TextView android:id="@+id/tv_cancel" android:layout_width="match_parent" android:layout_height="50dp" android:text="取消" android:gravity="center" android:textSize="16sp" android:textColor="@android:color/background_dark"/&gt; &lt;/LinearLayout&gt; 封装的dialog方法:
private void showBottomDialog(){ //1、使用Dialog、设置style final Dialog dialog = new Dialog(this,R.style.DialogTheme); //2、设置布局 View view = View.inflate(this,R.layout.dialog_custom_layout,null); dialog.setContentView(view); Window window = dialog.getWindow(); //设置弹出位置 window.setGravity(Gravity.BOTTOM); //设置弹出动画 window.setWindowAnimations(R.style.main_menu_animStyle); //设置对话框大小 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/515d113a99f27dd03bf88892b01c0d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee522f012e8781b0081f654b7bf06df1/" rel="bookmark">
			Git使用出现git@github.com: Permission denied (publickey).  处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入git bash界面然后：
第一步，git config --global --list 验证邮箱与GitHub注册时输入的是否一致
第二步，通过git config --global user.name “yourname”，git config --global user.email “email@email.com ”（这里得名字和邮箱都是注册github时用的）设置全局用户名和邮箱。
第三步，ssh-keygen -t rsa -C “这里换上你的邮箱”，一路回车，在出现选择时输入Y，再一路回车直到生成密钥。会在/Users/***/路径下生成一个.ssh文件夹，密钥就存储在其中。
第四步，到git仓库，添加秘钥，
点击Add SSH key
第五部，ssh -T git@github.com 测试一下通不通，通了显示如下
即可正常使用。
不通就是
ssh-agent -s
ssh-add ~/.ssh/id_rsa 操作这两步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e7a523f381e2d44153bbf94bf183f4/" rel="bookmark">
			QCustomPlot系列(6)-在图中插入文本框/直线箭头/图片/矩形/椭圆/游标等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图如下：
QCustomPlot已经为我们提供了文字框QCPItemText、直线(可设置带箭头)类QCPItemLine。
一、QCPItemText的基本用法：
textLabel = new QCPItemText(this);//在QCustomplot中新建文字框 textLabel-&gt;setPositionAlignment(Qt::AlignTop|Qt::AlignLeft);//文字布局：顶、左对齐 textLabel-&gt;position-&gt;setType(QCPItemPosition::ptAxisRectRatio);//位置类型（当前轴范围的比例为单位/实际坐标为单位） textLabel-&gt;position-&gt;setCoords(0.5, 0); //把文字框放在X轴的中间，Y轴的最顶部 textLabel-&gt;setText("Text Item Demo"); textLabel-&gt;setFont(QFont(font().family(), 16)); //字体大小 textLabel-&gt;setPen(QPen(Qt::black)); //字体颜色 textLabel-&gt;setPadding(QMargins(2,2,2,2));//文字距离边框几个像素 美中不足的是，官方没有提供设置QCPItemText背景色的方法，默认背景是透明的。不过好在有源码，我们改改官方源码，使他支持设置背景色。修改步骤如下：
跳转到QCPItemText类的virtual void draw(QCPPainter *painter) Q_DECL_OVERRIDE函数里来看一下，
QCPItemText绘制边框、绘制文字都是在这个函数里干的，上面红色框的那一句是我自己加的，我把背景设置成了绿色（原理就是在绘制方框、文字之前，先绘制一个绿色矩形面）。知道了这一点，我们就可以添加一个private的QColor变量，然后通过public接口操作这个颜色就可以随时修改文字框的背景了。
二、下面再看看QCustomPlot的直线类QCPItemLine
基本用法如下：
arrow = new QCPItemLine(this); arrow-&gt;start-&gt;setParentAnchor(textLabel-&gt;bottom); //设置该直线的起点为文字框的下锚点 arrow-&gt;end-&gt;setCoords(4, 1.6); //设置直线终点为坐标系中的点 arrow-&gt;setHead(QCPLineEnding::esSpikeArrow);//设置箭头类型（三角形、菱形、方形等） arrow-&gt;setVisible(false); 较为简单，不再赘述。
三、设置跟随锚定点
setParentAnchor(QCPItemAnchor *)、
setParentAnchorX(QCPItemAnchor *) 、
setParentAnchorY(QCPItemAnchor *)
设置锚定点的作用是什么？
举2个例子：
（1）我们在plot中画了一个箭头，箭头的起点位于某文本框的底部中心，如本文的第一张图所示，我们希望当文本框发生移动时，箭头的起点能够总是保持在文本框的底部中心，实现这一功能，只需把箭头的起始点设置为锚定到文本框的底部锚上即可：arrow-&gt;start-&gt;setParentAnchor(textLabel-&gt;bottom);
（2）我们在plot中添加了一个游标和文本框，我们希望游标能跟随鼠标实时移动，然后文本框紧贴plot的左边沿，文本框的Y位置总是等于游标的Y位置。由于游标、文本框都继承了QCPAbstractItem，都具备锚定功能，只需把文本框的Y位置锚定在游标锚的Y位置上即可。
图形元素中的QCPItemAnchor 或QCPItemPosition类型的成员就是锚定点（见上图），QCustomplot中的QCPAbstractItem类型的图形元素（见下图）都有锚定点，
文本框类QCPItemText含有4个锚点成员变量：上下左右，锚点坐标就是文本框四边的正中心。如果设置了某个QCPAbstractItem对象的锚点锚定（也可以设置只锚定X值或Y值）在文本框的某个锚点上，那么QCPAbstractItem对象的锚点（或者X坐标/Y坐标）就会总是等于文本框的锚点坐标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1cf9fb5a24225543b3413cc99a361b/" rel="bookmark">
			申请者评分模型(A卡)开发（基于逻辑回归）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		申请者评分模型(A卡)开发（基于逻辑回归） 1项目背景 申请者评分模型应用在信贷场景中的贷款申请环节，主要是以申请者的历史信息为基础，预测未来放款后逾期或者违约的概率，为银行客户关系管理提供数据依据，从而有效的控制违约风险。
2开发流程 本次建模基本流程：
1.数据准备：收集并整合在库客户的数据，定义目标变量，排除特定样本。
2.探索性数据分析：评估每个变量的值分布情况，处理异常值和缺失值。
3.数据预处理：变量筛选，变量分箱，WOE转换、分割训练集测试集。
4.模型开发：逻辑回归拟合模型。
5.模型评估：常见几种评估方法，ROC、KS等。
6.生成评分卡
标准评分卡开发流程如下图所示（基于逻辑回归）：
3数据准备 3.1样本选取 首先根据准入规则(如年龄、在网时长等)、行内黑名单过滤客户，再通过反欺诈模型过滤客户，得到用于建立信用评分卡的样本。
3.2数据说明 本次建模数据一共用到三个表：
“CreditFirstUse”：客户首次使用信用卡时间信息表
“CreditSampleWindow”：客户历史违约信息表（基于客户编号）
“Data_Whole”:客户基本信息表
3.3定义目标变量 申请者评分模型需要解决的问题是未来一段时间（如12个月）客户出现违约（如至少一次90天或90天以上逾期）的概率。在这里“12个月”为“观察时间窗口”，“至少一次90天或90天以上逾期”为表现时间窗口即违约日期时长，那么我们如何确定观察时间窗口和违约日期时长（如M2算违约，还是M3算违约）呢？
3.3.1定义违约日期时长（表现时间窗口） sample_window=pd.read_csv("CreditSampleWindow.csv") sample_window.head() sample_window.shape #查看缺失值所占比例 sample_window.isnull().sum()/sample_window.shape[0] # 选取某一个ID查看数据结构 sample_record = sample_window[sample_window.CID == sample_window.iat[4,0]] sample_record.sort_values('START_DATE') #去掉重复值 sample_window.drop_duplicates(inplace=True) #去掉没有逾期阶段记录的信息 sample_window.dropna(subset=['STAGE_BEF','STAGE_AFT'],inplace=True) sample_window.shape #取每个 ID 每个月份的最高逾期记录也就是STAGE_AFT作为该月份的逾期指标 sample_window['START_MONTH']=sample_window.START_DATE.apply(lambda x: int(x//100)) #取年月 sample_window['CLOSE_MONTH']=sample_window.CLOSE_DATE.apply(lambda x: int(x//100)) sample_window['AFT_FLAG']=sample_window.STAGE_AFT.apply(lambda x:int(x[-1])) #取数字 sample_window.head() #因为选取数据的时间是有一个节点的，由于系统原因，截至时间节点为0了 #所以将 CLOSE_DATE 为0的数据填补为 201806（根据缺失的业务背景确定） sample_window.loc[sample_window.CLOSE_MONTH==0,'CLOSE_MONTH']=201806 # 提取 ID、月份、月份对应状态作为新的数据 overdue = sample_window.loc[:,["CID","START_MONTH","AFT_FLAG"]]\ .rename(columns={"START_MONTH":"CLOSE_MONTH"})\ .append(sample_window.loc[:,["CID","CLOSE_MONTH","AFT_FLAG"]],ignore_index=True) # 生成每个订单的逾期信息，以表格形式。提取当月最差的状态 overdue = overdue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1cf9fb5a24225543b3413cc99a361b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b00bd7ca2df3281702a1669b674364c/" rel="bookmark">
			使用Hive处理敏感字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用regexp_replace格式：
regexp_replace(address,"正则表达式","替代字符") (1)匹配所有字符：
select regexp_replace(address, '.*', '***') from table; (2)匹配指定字符：
select regexp_replace('2016-06-05', '-', '') from table; (3)匹配特殊字符（换行符）：
select regexp_replace(name,'\\\\n','') from table; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f583d477a5d44237da537c6c3893e973/" rel="bookmark">
			【动态规划】查找最长公共子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是最长公共子序列（lcs）
定义：一个数列S,如果分别是另个或多个已知数列的子序列，且是所有匹配此条件中最长的，则称S是已知数列的最长公共子序列；
需要注意的是：子序列不需要在原序列中占用连续的位置。
ege:
x序列：A B C B D A B
y序列：B D C A B A
他们的最长公共子序列为：B C A B,B D A B,B C B A
那么我们是如何查找出这个公共子序列？
（1）穷举法
一个一个找，容易理解，但是解法很麻烦，所占用的时间复杂度很大，为O(n*2^m)，一般不推荐。
（2）简化：a.查找最长公共子序列的长度
b.找子序列
如：
法1：（递归）
package 查找最长公共子序列; public class 递归 { public static int lcs(char[] a, char[] b, int i, int j) { if (i == 0 || j == 0) { return 0; } else if (a[i] == b[j]) { return lcs(a, b, i - 1, j - 1) + 1; } else { return max(lcs(a, b, i - 1, j), lcs(a, b, i, j - 1)); } } private static int max(int x, int y) { if (x &gt; y) { return y; } else { return y; } } public static void main(String[] args) { String s1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f583d477a5d44237da537c6c3893e973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5e542e244e5d98ca01331374faea90/" rel="bookmark">
			利用git执行gradle项目（图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先，创建初始化项目文件 gradle-spring-boot-project：
二、进入项目文件，初始化(在git里面执行)：
gradle init --type java-application 三、Spring提供了一个独立的Spring Boot Gradle插件，它增加了一些任务和配置，以简化基于Spring Boot的项目的工作。首先，我们需要应用插件。为此，打开build.gradle文件并调整plugin块
build.gradle
plugins { id 'java' id 'com.gradle.build-scan' version '2.0.2' id 'org.springframework.boot' version '2.0.5.RELEASE' id 'io.spring.dependency-management' version '1.0.7.RELEASE'} 之后重建dependencies
dependencies { implementation 'org.springframework.boot:spring-boot-dependencies:2.0.5.RELEASE' implementation 'org.springframework.boot:spring-boot-starter-web' testImplementation 'org.springframework.boot:spring-boot-starter-test' components { withModule('org.springframework:spring-beans') { allVariants { withDependencyConstraints { // Need to patch constraints because snakeyaml is an optional dependency it.findAll { it.name == 'snakeyaml' }.each { it.version { strictly '1.19' } } } } } }} 【注】：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f5e542e244e5d98ca01331374faea90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ae1ac80f57b19d4a73714e65675576/" rel="bookmark">
			Pytorch(笔记3)--MaxPool2d&amp;AdaptiveAvgPool2d
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一节中我们详细的阐述了Conv2d的计算原理，今天我们来讲述下Pytorch中其他比较常见的操作！
在lenet5的时候，受限于计算能力和存储能力，通常采用downsample来降维
在pytorch中使用Pooling操作来实现采样，常见的pool操作包含Max_pool，Avg_pool等
Max_pool x = t.rand(1,3,7,7) out = nn.MaxPool2d(kernel_size=2,stride=2) out.forward(x).shape torch.Size([1, 3, 3, 3]) 启动kernel代表的是观察角度，如下图kernel就是2*2，stride和Conv操作中一样代表每次移动的步长。
下图操作，在每次观察区域内取最大值作为采样数据进行降维操作，这样做的优点是可以使显性特征更明显，降维操作并没有更改输出和输出的channel_num Avg_pool 对于Avg_pool来说，参数和Max_pool是完全相同的，主要区别就是在kernel中取的是平均值操作。
AdaptiveAvgPool2d&amp;AdaptiveMaxPool2d 和之前的运算方法不同，torch.nn提供了自适应size的函数样例如下：
可以看出，输出结果的size是按照我们给丁的结果进行运算的，一个参数代表H和W相同，也可以自定义（H，W），底层是对F.adaptive_avg_pool2d的封装，一般在类中的是大写小写的是函数，在Function中。
class AdaptiveAvgPool2d(_AdaptiveAvgPoolNd): r"""Applies a 2D adaptive average pooling over an input signal composed of several input planes. The output is of size H x W, for any input size. The number of output features is equal to the number of input planes. Args: output_size: the target output size of the image of the form H x W.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2ae1ac80f57b19d4a73714e65675576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc2f681eb829a3b17232995379164c4/" rel="bookmark">
			gojs去水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gojs去水印 在gojs文件夹的release文件夹下，go.js和go-debug.js文件中搜索关键字：“7eba17a4ca3b1a8346”
替换：
把类似a.Kv=d[w.Jg(“7eba17a4ca3b1a8346”)]w.Jg(“78a118b7”);替换为a.Kv =function(){return true;}即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff26e73c20ad6ecb124b6f45bacda0a/" rel="bookmark">
			Rtidyverse包安装报错/lib64/libstdc&#43;&#43;.so.6: version `CXXABI_1.3.9&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 /lib64/libstdc++.so.6 目录文件, 没有CXXABI_1.3.9这个版本而这个版本是需要的, 因为tidyr.so需要调用它 Error: package or namespace load failed for ‘tidyverse’ in dyn.load(file, DLLpath = DLLpath, ...): unable to load shared object '/home/dengfei/anaconda3/lib/R/library/tidyr/libs/tidyr.so': /lib64/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by /home/dengfei/anaconda3/lib/R/library/tidyr/libs/tidyr.so) 解决思路 查看/lib64/libstdc++.so.6的拥有的版本号, 一般来说是版本太老在服务器上找到这个动态库(肯定有新的)将新的动态库copy到路径下将软链接libstdc++.so.6关联新的文件 1. 查看/lib64/libstdc++.so.6版本号
(base) [root@localhost bin]# strings /lib64/libstdc++.so.6 |grep CXXABI CXXABI_1.3 CXXABI_1.3.1 CXXABI_1.3.2 CXXABI_1.3.3 CXXABI_1.3.4 CXXABI_1.3.5 CXXABI_1.3.6 CXXABI_1.3.7 CXXABI_TM_1 可以看到, 里面没有CXXABI_1.3.9这个版本
2. 查看服务器上, 还有没有其它的libstdc++.so.6库, 并查看他的版本是否有CXXABI_1.3.9
find / -name 'libstdc++.so' /root/anaconda3/pkgs/libstdcxx-ng-8.2.0-hdf63c60_1/lib/libstdc++.so /root/anaconda3/pkgs/libstdcxx-ng-8.2.0-hdf63c60_1/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so /root/anaconda3/pkgs/gxx_impl_linux-64-7.3.0-hdf63c60_1/x86_64-conda_cos6-linux-gnu/lib/libstdc++.so 可以看到, 我的anaconda中已经有这个库了, 查看一下是否有版本CXXABI_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ff26e73c20ad6ecb124b6f45bacda0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95acb0c6581483754819908f71510a41/" rel="bookmark">
			链路聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.链路聚合介绍二 .工作模式bond 网络利用 nmcli 命令管理 bond Team : 一.链路聚合介绍 以太网链路聚合简称链路聚合，它通过将多条以太网物理链路捆绑在一起成为一条逻辑链路，从而实现增加链路带宽的目的。同时，这些捆绑在一起的链路通过相互间的动态备份，可以有效的提高链路的可靠性。
链路聚合的功能：
1.增加了带宽–将多个链路的容量组合到一个逻辑链路中。2.自动故障转移/故障修复–将来自故障链路的通信转移到聚合中的工作链路。3.负载均衡–传入和外发通信都是根据用户选择的负载均衡策略（如源和目标）
链路聚合指将多个物理端口汇聚在一起，形成一个逻辑端口，以实现出/入流量吞吐量在各成员端口的负荷分担，交换机根据用户配置的端口负荷分担策略决定网络封包从哪个成员端口发送到对端的交换机。
在linux中，链路聚合有bind和team两种方式。
bind
要实现分担访问压力需要至少两块网卡，一个用来备用，当主网卡损坏时，备用网卡开始工作，也就是选择active-backup模式。
使用cat /proc/net/bonding/bond0 查看接口状态信息 ifconfig eth0 down 模拟工作的网卡损坏
二 .工作模式 1.roundrobin平衡轮询模式
两块网卡轮流接收数据包。由于两块网卡都是正常工作，它能提供两倍的带宽，在这种情况下，出现一块网卡失效，仅仅会是服务器出口带宽下降，不会影响网络使用。
2.activebackup主动备份模式
只有主网卡eth0工作，eth1作为备份网卡是不工作的，只有当一个网络接口失效时，为了不会出现网络中断，系统会按照配置指定的网卡顺序启动工作，保证机器仍能对外服务，起到了失效保护的功能。
3.broadcast广播容错模式
所有数据包都通过接口广播。
bond 网络 Red Hat Enterprise Linux 允许管理员使用 bonding 内核模块和称为通道绑定接口的特殊网络接口将多个网络接口绑定到一个通道。根据选择的绑定模式 , 通道绑定使两个或更多个网络接口作为一个网络接口 , 从而增加带宽和 / 提供冗余性
bond最少添加2块网卡。
选择 Linux 以太网绑定模式
模式 0 ( 平衡轮循(轮叫机制) ) - 轮循策略 , 所有接口都使用采用轮循方式，在所有 Slave 中传输封包 ; 任何 Slave 都可以接收
模式 1 ( 主动备份 ) - 容错。一次只能使用一个 Slave 接口, 但是如果该接口出现故障 , 另一个 Slave 将 接替它
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95acb0c6581483754819908f71510a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d62814e24e2b80d03fa28c0fe772c7/" rel="bookmark">
			DDNS动态域名解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：DDNS的基本概念
DDNS（Dynamic Domain Name Server）是动态域名服务的缩写。
DDNS是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。
原理：动态域名服务的对象是指IP是动态的，是变动的。普通的DNS都是基于静态IP的，有可能是一对多或多对多，IP都是固定的一个或多个。但DDNS的IP是变动的、随机的。简单来说就是通过DHCP服务器分配的IP地址可以动态更新到DNS服务上，免除了手动指定的麻烦。
DDNS原理：DNS + DHCP =DDNS DHCP负责ip解析，和分配给客户机ip，ip为随机数。 DNS负责域名解析，A记录里记录了每个ip对应的域名。 二：DDNS的搭建：
我们现在有一台主机，是用来在这个meng.com域里面来收集新闻的，但是这个主机的ip是个DHCP,也就是动态的，我们这个获得动态ip的主机去访问域名的时候，需要将这个动态ip与域名对应起来（解析的DNS服务器ip是固定的，主机的ip是不固定的），步骤如下：
第一步：
这个实验需要两个虚拟机来完成，一个是我们前面做过主服务器的desktop，一台是做从服务器的server，此时为了测试环境的纯净，我们需要将最好将server这台虚拟机reset
恢复数据文件
将数据文件修改为如图下所示：
第二步：搭建DHCP（可以参照前面的博客，大体相同）
安装dhcp软件包
安装完成
复制DHCP配置文件模板到我们的配置文件
编辑DHCP配置文件
第三步：重启服务
这里重启named服务是因为我们刚才修改了named的数据文件
在server进行测试
首先，我们修改server的主机名为news.meng.com（用这个模拟访问这个news.meng.com）,在将其ip获取方式改为动态获取，重启网络服务，会获取到一个动态ip。
如图所示：
此时我们去dig，发现ip也是172.25.254.60
为了实验的准确性，我们去修改这个主机可以获取到的ip，再去测试
如图所示:
编辑DHCP配置文件
将其可以获取的ip改为从172.25.254.75开始
重启DHCP服务
在server重启网络，发现获取到的ip改变
再去dig，发现news.meng.com的ip也变为了172.25.254.75，说明我们实现了DDNS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0141ca8baa8c7fe822088ca4f53fd39e/" rel="bookmark">
			Win 10 下 android studio显示 Intel haxm无法安装，以及VT-X和Hyper-V的冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		坑1：首先要先确定一下你的电脑是否支持虚拟化技术，这个要到BIOS里面去设置，进入BIOS 的方式不同的电脑有区别，我的是按F2，进去之后的差别也很大，应该是和主板不同影响的，有的在configuration中，有的在advanced中； 将选项 virtuallazation 或者 virtualation techonology 改成enabled, 保存退出
坑2：vt-x 和 Hyper-V 是不能共存的
解决：1： 要禁用掉win10的Hyper-V 可以在应用程序和功能中，关闭掉Hyper-V
2: 这可能还不够，还需要在Windows服务中关闭服务自启动 Win+R， 输入 services.msc，将Hyper-V相关的所有服务关闭，并设置为手动启动或者禁用
3：你以为这样就结束了？ 实力踩坑：这样做可能也并不能成功禁用掉Hyper-V
以管理员身份打开cmd
执行 bcdedit /enum
如果上面的不是off
那么你就需要执行
bcdedit /set hypervisorlaunchtype off 之后重启电脑，这时候你再去安装haxm就可以了
重启hyper-v bcdedit / set hypervisorlaunchtype auto
坑3：由于本人之前并没有执行上面的第3步，导致踩了后面的坑；我以为曲线能救国，所以，我想既然Android studio自带的模拟器不能用了，那我装个第三方的总可以吧，于是，我选择了Genymotion， 这个软件推荐下载含virtualbox的版本安装；安装完成之后，满心欢喜以为可以用了，结果依然是无法创建虚拟机，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40837d150b037e3a222965ebab9e3498/" rel="bookmark">
			记一次post请求参数为json格式时，HTTPServletRequest拿不到请求参数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据业务需求需要在满足条件的post请求前，做一些处理，因此想到用 HandlerInterceptor 来拦截请求以做进一步处理，便如图所示获取参数
但是，这种获取参数的形式可以获取表单形式（header），是拿不到参数为json格式的post请求参数的，
于是便又有了一下方式获取json格式的参数
这种方法可以再拦截器找那个拿到参数，
但是！！！这样在controller中使用@RequestBody注解 是不能自动注入对象的，因为，request中的流只读取一次，原因看这：https://www.cnblogs.com/yepei/p/7011081.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf549ba2ace8c0a44ca19f63d6bc4d2/" rel="bookmark">
			C&#43;&#43;通过匿名对象调用成员函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 通过匿名对象调用成员函数 刚开始写第一个 leetcode 程序就看到了之前没见到过的东西。首先，框架定义了一个Solution类，我们把方法写在成员函数twoSum(int,int)内，main()函数直接通过构造一个匿名的对象调用该成员函数。
vector&lt;int&gt; ret = Solution().twoSum(nums, target); 进一步总结，如果想要调用成员函数，其实是有三种方法的： 1、设置成静态成员函数，可以直接通过类名调用 Class::fun();
2、创建一个对象 object，使用object.fun()方法调用;
3、创建一个匿名的对象，使用匿名对象调用 Class().fun();
参考：http://www.cnblogs.com/gossiplee/p/4612929.html 《C++临时匿名对象》
#include "iostream" using namespace std; class A { public: A (int _a=0, int _b=0) { this-&gt;a1 = _a; this-&gt;b1 = _b; cout &lt;&lt; "construct function called！" &lt;&lt; endl; } A (A &amp;obj) { cout &lt;&lt; "copy_constructor function called!" &lt;&lt; endl; } ~A() { cout &lt;&lt; "objext destory function called!" &lt;&lt; endl; } void printf() { cout &lt;&lt; this-&gt;a1 &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecf549ba2ace8c0a44ca19f63d6bc4d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9667ff32b042c325e728bc160cd7395c/" rel="bookmark">
			CentOS7 中MySQL的安装以及MySQL密码的修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS系统中会默认安装有MariaDB，可能根据需要我们要安装MySQL，在MySQL安装完毕后会直接替换到系统中自带的MariaDB，以下操作均在Terminal中操作：
1、首先下载并安装MySQL官方需要的 yum repository
1.1 先使用下面的命令切换到 root 用户
[parallels@centos-linux-7 ~]$ sudo su [sudo] password for parallels: 自己电脑的开机密码 [root@centos-linux-7 parallels]# [root@centos-linux-7 parallels]# sudo wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 执行命令后的画面：
2、直接用下载好的 yum 进行安装
[root@centos-linux-7 parallels]# sudo yum -y install mysql57-community-release-el7-10.noarch.rpm 执行命令后的画面：
3、直接用 yum 安装 MySQL 服务器
[root@centos-linux-7 parallels]# sudo yum -y install mysql-community-server 执行命令后的画面，这一步可能需要点时间需要我们耐心等待下，网速快的话很快就会好，而且在这一步我们会发现我们安装的 MySQL 会 替换 掉原来的 MariaDB，如果不出意外一切会很顺利 4、启动 MySQL 服务器
[root@centos-linux-7 parallels]# systemctl start mysqld.service 这一步我们是看不到画面，但是我们可以使用下面的命令来查看 MySQL 服务器的运行状态
看到上面画面的中两个红色框框中的内容，我们会发现 MySQL 服务器已经正常启动，卧槽，这么简单
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9667ff32b042c325e728bc160cd7395c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3499cd6dfcae351734bbb3313cd6dab8/" rel="bookmark">
			androidQ系统新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Android Q是什么Android Q发布日期Android Q新的特性1.黑暗模式2.桌面模式3.隐私增强4.超级锁定模式5.屏幕录制6.移除 Android Beam7.运营商锁定8.面部识别9.不允许从后台读取剪贴板信息10.降级应用程序更新11.新字体、图标形状和提示颜色 Android Q行为更改针对Q版的应用1.非SDK接口限制2.共享内存3.ART只接受系统生成的OAT文件4.在ART中强制执行A​​OT正确性5.Fullscreen intent的权限变化6.支持折叠式 针对所有的应用1.非SDK接口限制2.Wi-Fi 直连广播3.系统悬浮窗权限（在Go版本上）4.针对低版本的target警告5.删除了SHA-2 CBC密码套件6.应用使用情况 Android Q是什么 Android Q 是Google在2019年推出的新一代操作系统Android10，适用于手机、平板电脑等移动终端设备。
Android Q发布日期 3月13日：第一款Android 10开发者测试版推出
4月3日： Android Q beta 2给了我们错误修复和app泡泡
5月7日： Android Q beta 3在Google IO 2019上发布
6月初：最终的增量更新，beta 4，应该在6月份登陆
7月：Beta 5和beta 6，发布候选人，可能会在本月登陆
8月：最终版本定期发生在八月份
Android Q新的特性 1.黑暗模式 Android Q 的暗黑模式和 Android Pie 的暗黑模式不同，在 Android Q 中，暗黑模式适用于任何地方，如果应用不支持暗黑模式，那么系统将自动设置一个暗黑模式。
2.桌面模式 Android Q 将支持桌面模式，类似三星 Dex 和华为的投影模式。它提供类似一个类似于 PC 的体验，但是远远不能代替 PC。
3.隐私增强 Android Q 还将更多地使用 Android Pie 中推出的隐私功能。 在 Android Q中，您可以选择应用程序在后台运行时是否可以访问该位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3499cd6dfcae351734bbb3313cd6dab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b73d9c0e042ec07405049e1e36b8635/" rel="bookmark">
			jupyter_notebook_config.py的配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# Configuration file for jupyter-notebook. #------------------------------------------------------------------------------ # Application(SingletonConfigurable) configuration #------------------------------------------------------------------------------ ## This is an application. ## The date format used by logging formatters for %(asctime)s #c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S' ## The Logging format template #c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s' ## Set the log level by value or name. #c.Application.log_level = 30 #------------------------------------------------------------------------------ # JupyterApp(Application) configuration #------------------------------------------------------------------------------ ## Base class for Jupyter applications ## Answer yes to any prompts. #c.JupyterApp.answer_yes = False ## Full path of a config file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b73d9c0e042ec07405049e1e36b8635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3a4a7e5675f1e944f4b7b5c7207bb8/" rel="bookmark">
			解决layui弹出层关闭后，在列表下面还出现弹出层的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：
//页面层 layer.open({ type: 1, skin: 'layui-layer-rim', //加上边框 area: ['98%', '98%'], //宽高 content: $("#test_oe"), end:function (res) { $("#test_oe").css("display",'none'); } }); end - 层销毁后触发的回调
类型：Function，默认：null
无论是确认还是取消，只要层被销毁了，end都会执行，不携带任何参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826dc10b1fa2998b2af65270b17791e5/" rel="bookmark">
			JSCH连接sftp，Invalid private key和algorithm negotiation fail异常解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天项目有个功能涉及sftp，甲方提供了一个xxx.ppk，这个ppk文件是通过PuTTYgen创建的，用来加密的。程序里面是java代码，用jsch插件来建立sftp连接。
一顿操作之后连接测试，报异常：
com.jcraft.jsch.JSchException: invalid privatekey
查询资料得知，使用jsch连接sftp的话，JSch期望私钥是OpenSSH格式，所以需要用PuTTY工具 把.ppk文件转成OpenSSH key
搞完之后再测试一遍，又有一个异常：
com.jcraft.jsch.JSchException: USERAUTH fail
这个错误百度竟然没找到，最后在外国网站stackoverflow找到一点提示：SFTP的证书有密钥的，java代码需要修改。
设置证书原来的代码是这样：
jsch.addIdentity(privateKey); 现在要改成：
jsch.addIdentity(privateKey,"123456"); 改完后继续往下测，还来异常：
com.jcraft.jsch.JSchException: Algorithm negotiation fail
再查询资料得知，jsch版本过低导致。之前用的是0.1.48，升级成0.1.55。
嗖嗖嗖地替换jar包之后继续测试，继续异常：
com.jcraft.jsch.JSchException: Session.connect: java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 1024 (inclusive)
这问题资料很多，是密码算法问题。最简单的解决办法就是jdk升级到1.8，不想升级的话需要修改openSSH配置文件，有些jsch版本还需要改代码。这里直接升级jdk好了。
问题解决了，世界恢复和平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb611a3a719c3201889fb575256f1ce/" rel="bookmark">
			Cydia无法联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载“爱思助手”，一键越yu。 Cydia无法联网？ 方式1. iphone5s 以上下载 乐网 ,根据教程操作。（https://www.i4.cn/news_detail_18849.html） 方式2. Cydia 不能联网的终极解决方法。（https://blog.csdn.net/sysprogram/article/details/86558683）
首先，安装 MobileTerminal (手机终端)，根据教程制作ipa安装包。（参考文章）
具体操作如下（windows步骤）：
(1)下载 CydiaImpactor、MobileTerminal.deb、爱思助手、7zip、winrar。
(2) 使用 7zip 打开 MobileTerminal.deb，点击提取将文件提取出来。
(3) 提取的文件里有 data.tar，解压之后，里面有一个 Applications 目录，进去后会看到 MobileTerminal.app，新建 Payload 目录，将 MobileTerminal.app 放入 Payload 目录里，然后选择 Payload 打包成 zip 格式，重命名为 MobileTerminal.ipa
相关工具下载
MobileTerminal
链接: https://pan.baidu.com/s/10f4HDMv3OxQKNt3uZSRG6g密码: rwvu
lib.zip
链接: https://pan.baidu.com/s/1adz9onORQpuff_AEUQOlOQ密码: f6ce
CydiaImpactor
链接: https://pan.baidu.com/s/1DlHTWMPVuCJHOU72dK-aIA密码: u95k
然后，在手机上安装ipa。
具体步骤（接上述）：
(4) 打开 CydiaImpactor，将 MobileTerminal.ipa 拖到 CydiaImpactor 上，输入你的 Apple ID 账号和密码，将 MobileTerminal 安装到手机上。
(5) 打开爱思助手，将准备好的 lib 文件上传到 books 目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb611a3a719c3201889fb575256f1ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba76bace075282c8bbcefaf467d064ea/" rel="bookmark">
			汇编语言的应用（用途）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早期在编程时，大多数应用程序部分或全部用汇编语言编写。它们不得不适应小内存，并尽可能在慢速处理器上有效运行。随着内存容量越来越大，以及处理器速度急速提高，程序变得越来越复杂。
程序员也转向高级语言如 C语言、FORTRAN COBOL，这些语言具有很多结构化能力。最近，Python、C++、C# 和 Java 等面向对象语言已经能够编写含数百万行代码的复杂程序了。
很少能看到完全用汇编语言编写的大型应用程序，因为它们需要花费大量的时间进行编写和维护。不过，汇编语言可以用于优化应用程序的部分代码来提升速度，或用于访问计算机硬件。
下表比较了汇编语言和高级语言对各种应用类型的适应性。
应用类型高级语言汇编语言商业或科学应用程序，为单一的中型或大型平台编写规范结构使其易于组织和维护大量代码最小规范结构，因此必须由具有不同程度经验的程序员来维护结构。这导致对已有代码的维护困难硬件设备驱动程序语言不一定提供对硬件的直接访问。 即使提供了，可能也需要难以控制的编码技术，这导致维护困难对硬件的访问直接且简单。当程序较短且文档良好时易于维护为多个平台（不同的操作系统）编写的商业或科学应用程序通常可移植。在每个目标操作系统上， 源程序只做少量修改就能重新编译需要为每个平台单独重新编写代码， 每个汇编器都使用不同的语法。维护困难需要直接访问硬件的嵌入式系统和电脑游戏可能生成很大的可执行文件，以至于超出设备的内存容量理想，因为可执行代码小，运行速度快 C 和 C++ 语言具有一个独特的特性，能够在高级结构和底层细节之间进行平衡。直接访问硬件是可能的，但是完全不可移植。大多数 C 和 C++ 编译器都允许在其代码中嵌入汇编语句，以提供对硬件细节的访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ae7f7be3c65a79623fe20bb4dea592/" rel="bookmark">
			IP组播配置与管理实战——3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PIM-SM（IPv4）配置与管理
PIM-SM属于稀疏模式的域内组播路由协议。与PIM-DM不同的是，PIM-SM不会将组播数据扩散到全网，而只将组播数据传输到有组成员的网络，一般用于规模较大、组成员分布稀疏的组播网络，且PIM-SM同时适用于ASM模型和SSM模型。
与PIM-DM ASM以组播源为转发中心和SPT路径起点不同的是，在PIM-SM ASM模型中，RP是网络的转发中心和SPT路径的起点，网络中所有PIM路由器都知道RP的位置。当网络中出现组成员时，连接组成员的最后一跳PIM路由器向RP方向发送Join信息，然后沿着到达RP单播路由逆向路径向组成员端传递，并逐跳创建（*，G）表项，生成一棵以RP为根的RPT，所以它采用“拉”（Pull）模式来转发组播报文，即由组成员主动申请。当网络中出现活跃的组播源时，第一跳PIM路由器将组播信息封装在Register报文中发往RP，在RP上创建（S,G）表项，注册源信息。然后，RP会将注册信息中的组播信息解封装，沿着RPT转发到有组成员的网段。
——所谓“推”（Push）和“拉”（pull），我的理解是主要区别在于PIM路由器上路由表项的建立不同，push推是由组播源发起的，即组播源加入组播组时，将组播路由表项推到各PIM路由器上，而拉pull是由主机发起的，从主机侧开始，即从最后一跳路由器向上游发起加入报文，在沿途PIM路由器上建立组播路由表项。
如果当前RP、RPT负担较重，可通过以下DPT切换方式减轻压力。
（1）RP向组播源方向发送Join信息，构建“源-RP”的SPT。
（2）组成员端DR向组播源方向发送Join信息，构建“源-组成员”的SPT。
如上图为一个SPT切换示例，最终所有组播成员都采用以RP为核心的SPT路径进行数据转发（左图所示，SwitchB为RP），后面SwitchC经过向源方向的SPT切换，最终为HostA生成了另一条不经过RP的新路径（如右图所示），减轻了RP的压力。
在SSM模型中，网络用户能够预先知道组播源的具体位置。因此用户在加入组播组时，可以明确指定从哪些源接收信息。所以在SSM模型中，与ASM模型的最大区别就是SSM模型中无需维护RP、无需构建RPT（汇集点树）、无需注册组播源，可以直接在源与组成员之间建立SPT。组成员端DR了解到用户的需求后，直接向组播源方向发送Join信息。Join信息按照到达组播源的单播路由路径逐跳向上传输，在源与组成员之间建立SPT。
如下图，HostA、HostB都已经加入了组播组G，HostA需要接收S1的组播数据，HostB需要接收S2的组播数据，各自的组成员端DR向各自源方向发送Join信息，构建SPT。
一、PIM-SM（IPv4）特性的产品支持
在PIM-SM（IPv4）中支持的产品特性有PIM-SM for ASM、PIM-SM for SSM、调整PIM-SM控制参数、PIM BFD、PIM GR、PIM Silent。
1、PIM-SM forASM
ASM模型中，设备支持的PIM-SM基本特性如下：
●静态/动态RP（S2700/3700系列交换机不支持动态RP）。
●BSR管理域（S2700/3700系列交换机不支持）。
●SPT切换条件的配置。
●源注册控制参数的调整。
●C-RP/C-BSR参数的调整（S2700/3700系列交换机不支持动态RP）。
2、PIM-SM for SSM
在SSM模型中，设备支持通过配置SSM组策略来指定SSM组地址范围。
3、调整PIM-SM控制参数
在配置ASM或SSM的PIM-SM基本功能后，通过设备提供的缺省值，PIM-SM域就可以正常工作，将组播源发出的组播数据分发到组成员网段。同时可以根据实际需要，对下表所示的PIM-SM控制参数进行调整，多数参数与PIM-DM控制参数一样，只是在PIM-SM网络中多了“DR竞选控制参数”和“组成员加入控制参数”，而少了PIM-DM网络中的“嫁接控制参数”和“状态刷新控制参数”。
4、PIM BFD
正常情况下，如果共享网段上的当前DR（每个网段都会选举一个DR的）出现故障，其他PIM邻居会等到邻居关系超时才触发新一轮的DR竞选过程，这样组播数据传输中断的时间会比较长（不小于邻居关系的超时时间，通常是秒级）。当使能BFD功能后，其故障检测可达毫秒级，可大大缩短因DR出现故障而使组播数据传输中断的时间。因为BFD功能可快速地检测共享网段上PIM邻居的状态，当检测到对端故障后立即上报PIM模块，然后立即出发新一轮的DR竞选过程，而不是等到邻居关系超时。
PIM BFD功能也适用于共享网段上Assert（断言）竞选过程，以快速检测Assert Winner接口故障。
5、PIM GR
在堆叠系统中有时候会进行主备倒换。如果堆叠系统中有组播业务在运行，在主交换机和备交换机进行倒换后，新的主交换机将重新学习PIM路由表及组播转发表，这样会造成组播流量在学习期间的断流。在堆叠系统中配置PIM GR（Gracefule Restart）功能后，主交换机会向备交换机备份PIM路由表项、组播转发表以及需要向上游发送的Join/Prune信息。这样在主备倒换后，新的主交换机就可以主动快速地向上游发送Join信息，维持上游的加入状态。同时，PIM协议向所有使能了PIM-SM的交换机发送携带新Generation ID的Hello报文，当下游交换机发现其邻居的Generation ID发生了变化，便向邻居发送Join/Prune报文以帮助其重建路由表项，从而保证转发平面组播数据的不间断转发。
在堆叠系统中配置PIM GR功能后，如果网络中使用的是动态RP，在网络中的DR或次DR收到Generation ID改变的Hello报文后，会向发生主备倒换的堆叠系统单播发送Bootstrap报文（自举报文），堆叠系统可从该自举报文中学习并恢复RP信息。如果堆叠系统未能从自举报文中学习到网络中的RP信息，则还可从下游发送的Join/Prune报文中获取RP信息，重新创建组播路由表。
6、PIM Silent
PIM Silent功能用来禁止用户侧组播设备接口接收和转发任何PIM协议报文，并删除该接口上的所有PIM邻居以及PIM状态机，以防止恶意的PIM Hello报文攻击。
二、ASM模型PIM-SM的配置任务
在配置ASM模型的PIM-SM之前也需要配置单播路由协议，保证网络内单播路由畅通。
ASM模型的PIM-SM配置如下，“使能PIM-SM”和“配置RP”为必选配置任务，其他均为可选配置。
1、使能PIM-SM
在PIM-SM网络中，在使能了组播路由功能后，首先要使能的就是PIM-SM功能，但设备上不能同时使能PIM-SM和PIM-DM。建议将处于PIM-SM域内的所有接口都使能PIM-SM，以确保与相连PIM设备都能建立邻居关系。
如果接口上需要同时使能PIM-SM和IGMP，必须先使能PIM-SM，再使能IGMP。
2、配置RP
配置RP有手工静态配置和BSR机制动态选举两种方式。手工方式静态配置RP可以避免C-RP与BSR之间频繁的信息交互而占用带宽。通过BSR机制动态选举RP，可以避免手工配置的繁琐；同时配置多台C-RP可以保证组播数据转发的可靠性。
静态RP和动态RP可同时配置，但此时静态RP由于缺省优先级较低而被当作备份RP。同时配置时需要确保各组播设备间的RP信息一致，否则容易导致网络故障。
3、（可选）配置BSR管理域
为更有效管理PIM-SM域，可将PIM-SM域划分为多个BSR（自举路由器）管理域和一个Global域。每个BSR管理域都维护一个BSR，服务于自己特定地址范围的组播组；Global域也维护一个BSR，为剩余不属于任何BSR管理域的组播组服务。由于一台设备只能加入一个管理域，因此，各个管理域转发组播报文互不干涉；Global可以通过任意管理域内的设备进行报文转发。
BSR管理域可服务的最大组地址范围为239.0.0.0~239.255.255.255。该段地址可重复使用，相当于每个BSR管理域的私有组地址。
4、（可选）配置RPT不向SPT切换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ae7f7be3c65a79623fe20bb4dea592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb9b4dd8ab818d78991524d01c5e819/" rel="bookmark">
			微信电子发票--“自建平台模式”--小程序开票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：小程序开发票在官方文档（https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=21518166863ccFdP）的第四节
项目说明 1.我有一个小程序，是交通行业的。用户买完票之后，可以在电子票页面申请开电子发票；
2. 小程序开发票用的是公众号的access_token，发送到用户卡包也是通过公众号发的，小程序要做的是申请电子发票和完成授权。
3. 虽然买完票就能申请发票，但是为了减少后续的冲红操作，在用户乘车之后才会去申请第三方平台开发票；
4. 代码用的是PHP。
项目大概逻辑 1. 商户获取获取access_token。（方法：getAccessToken()）
2. 提前获取开票平台标识s_pappid（方法：getInvoiceUrl()）
3. 设置商户联系方式（方法：setContact()）
4. 商户获取授权页（方法：getTicket()）；
5. 商户获取授权页url（方法：getAuthUrl()）；
6. 根据第5步的结果，在小程序开票按钮的点击事件上部署跳转到小程序授权页的逻辑；
7. 获取用户填写的抬头信息有两种办法：1）主动查询授权状态（方法：getAuthData()）、2）根据授权回调获取授权状态（方法：getAuthDataWxAccount()）；
8. 创建发票卡券模板（方法：getInvoiceCardId()）；
9. 在自建发票平台开具电子发票（意思是，自己去开发票，比如通过第三方开票平台，然后把开票返回的发票号码、发票代码、发票pdf文件等保存下来；最后再用这些信息调用微信的PDF上传接口和下发到用户卡包的接口）；
10. 上传发票PDF文件（方法：setPDF()）；
11. 将电子发票添加到用户微信卡包（方法：sendInvoice()）。
注：具体的使用方法请看“调用示例”
代码与说明 说明：域名空间下面引用的类，基本上都是数据库操作，大家可以不用看，主要是所取到的要用的字段含义。
AppIdModel用的表是zc2_ticket_appid，请求微信接口用到的字段基本都在这张表了：
CREATE TABLE `zc2_ticket_appid` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(50) NOT NULL COMMENT '调用方名称', `desc` varchar(100) NOT NULL COMMENT '调用方描述', `appid` varchar(50) NOT NULL COMMENT '调用方APPID', `appsecret` varchar(50) DEFAULT NULL COMMENT '调用方秘钥', `wx_appid` varchar(50) NOT NULL DEFAULT '' COMMENT '微信APPID', `wx_appsecret` varchar(125) NOT NULL DEFAULT '' COMMENT '微信APPSECRET', `wx_mch_id` varchar(50) NOT NULL DEFAULT '' COMMENT '商户ID，多商户小程序在zc2_sale_address表配置', `pay_acid` int(11) NOT NULL DEFAULT '0' COMMENT '支付商户ID，多商户小程序在zc2_sale_address表配置', `access_token` varchar(1000) NOT NULL DEFAULT '' COMMENT '小程序access_token', `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1:有效 2：无效', `createtime` int(10) DEFAULT '0', `createuser` int(10) DEFAULT '0', `updatetime` int(10) DEFAULT '0', `updateuser` int(10) DEFAULT '0', `bonus_insurance` tinyint(1) NOT NULL DEFAULT '2' COMMENT '赠送保险开关：1 开，2 关', `type` tinyint(1) NOT NULL DEFAULT '1' COMMENT '渠道类别：1前端；2管理后台；3设备接口', `auth_ticket` varchar(1000) NOT NULL DEFAULT '' COMMENT '授权页ticket凭证', `invoice_url` varchar(512) NOT NULL DEFAULT '' COMMENT '开票平台链接', `invoice_card_id` varchar(512) NOT NULL DEFAULT '' COMMENT '发票卡券模板', `phone` varchar(20) NOT NULL DEFAULT '' COMMENT '商户联系手机', `wx_account_appid` varchar(50) NOT NULL DEFAULT '' COMMENT '小程序关联的微信公众号APPID', `wx_account_appsecret` varchar(125) NOT NULL DEFAULT '' COMMENT '小程序关联的微信公众号APPSECRET', `wx_account_access_token` varchar(1000) NOT NULL DEFAULT '' COMMENT '小程序关联的微信公众号access_token', PRIMARY KEY (`id`), UNIQUE KEY `appid` (`appid`) ) ENGINE=MyISAM AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COMMENT='接口调用方appid表'; &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb9b4dd8ab818d78991524d01c5e819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de29cd78280b2a579e3cc88f76df61f9/" rel="bookmark">
			css怎么设置页面缩放最小宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 html, body { min-width: 1500px;} @media only screen and (min-width: 1500px) { html, body { min-width: 1500px; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/010fcb8c75a956328570972d3e87205b/" rel="bookmark">
			DNS的正向、反向、双向解析（正向解析内含CNAME，MX）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：DNS解析层次结构
如图所示（图片来自网络）：DNS是逐级查询
域名后缀一般分为国际域名和国内域名，常见的域名后缀有.com（商业组织）、.org（非盈利组织）、.gov（政府部门）、.net（网络服务商）、.edu（教研机构）、.pub（公共大众）、.cn（中国国家顶级域名）等。
解析答案：
肯定答案： 否定答案：请求的条目不存在等原因导致无法返回结果 权威答案：你请求的dns服务器正好是负责这个链接域的dns 非权威答案：dns服务器问别人，别人告诉它的，有时候会是假的，比如国外某些网站访问不了，就是dns告诉给你一个错误的答案，不让你访问（DNS的污染，信息篡改了） 备注：名字解析成不成功和能不能上网是两码事
做实验所需的配置文件：
/etc/named.conf 主配置文件 服务器主要运行参数 /etc/named.rfc1912.zones 区域文件，主要指定要解析哪个域名 /var/named 数据目录 /var/named/xxx.xx 数据文件，用来对应域名和ip关系 二.DNS的 正向解析
在DNS域名解析服务中，正向解析是指根据域名（主机名）查找到对应的IP地址。
实验如下：
&lt;1&gt;正向解析
步骤一：调整实验环境
将提供解析的ip在/etc/resolv.conf里修改为服务器的ip，并将之前网络配置里面DNS1=114.114.114.114删掉
步骤二：编辑区域文件
我们可以在主配置文件里面看见，它可以读取区域文件 /etc/named.rfc1912.zones
我们此时有一个域meng.com需要进行管理，所以需要去编辑区域文件（其实也可以将要管理的域写在主配置文件里，但这样会使主配置文件变得很长，为了方便与整齐，我们统一将其写在区域文件里）
vim /etc/named.rfc1912.zones 在里面写入以下内容
步骤三：编辑数据文件
因为我们自定义的这个数据文件格式与/var/named/named.localhost（模版文件）格式相同，所以我们将其复制过来（记得要将权限一起复制过来，否则named服务起不来）
cp -p named.localhost meng.com.zone 复制并保留原始文件的权限 vim meng.com.zone 编辑数据文件 在里面写入以下内容（不能忘记写.否则服务起不来）
步骤四：重启服务
systemctl restart named 测试
&lt;2&gt;CNAME(名称到“规范名称“，（包括A/AAAA记录的另一个名称）)
其实上面的话通俗一点来说就是域名转换（相当于一个域名对应两个ip，进行轮循）
实验如下：
在数据文件为meng.come.zone里写入以下内容
重启DNS服务，总体如下图所示：
测试：
dig www.baidu.com
如果ip不变化，可以多试着dig几次，因为进行交替也需要时间。
&lt;3&gt;MX(邮件解析)
邮件交换记录 (MX record)是域名系统（DNS）中的一种资源记录类型，用于指定负责处理发往收件人域名的邮件服务器。MX记录允许设置一个优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器。简单邮件传输协议（SMTP）会根据MX记录的值来决定邮件的路由过程。
例如：此时我要发送一封邮件给163.com，但我自己是qq.com，这个时候MX的作用就是识别这封发送邮件的域名163.com，将其解析出来，会得到一个值，然后简单邮件传输协议（SMTP）会根据MX的值来决定邮件的发送。
实验如下：
前提：
此时我们去发送一封邮件，系统会告诉我们这个域名不存在，这说明是我们的DNS的问题
我们查看这个错误，发现是域名不存在
此时为了解决这个问题，我们需要去配置我们的DNS，步骤如下：
在数据文件为meng.come.zone里写入以下内容（注意写.）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/010fcb8c75a956328570972d3e87205b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a807e186891ec2c6bab9cdb2379b3483/" rel="bookmark">
			信用评分卡（A卡/B卡/C卡）的模型简介及开发流程｜干货
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：https://blog.csdn.net/varyall/article/details/81173326
零、什么是信用评分卡 如今在银行、消费金融公司等各种贷款业务机构，普遍使用信用评分，对客户实行打分制，以期对客户有一个优质与否的评判。信用评分卡多分为A,B,C卡三类：
A卡（Application score card）申请评分卡B卡（Behavior score card）行为评分卡C卡（Collection score card）催收评分卡 其评分机制的区别在于：
使用的时间不同。分别侧重贷前、贷中、贷后；数据要求不同。A卡一般可做贷款0-1年的信用分析，B卡则是在申请人有了一定行为后，有了较大数据进行的分析，一般为3-5年，C卡则对数据要求更大，需加入催收后客户反应等属性数据；每种评分卡的模型会不一样。在A卡中常用的有逻辑回归，AHP等，而在后面两种卡中，常使用多因素逻辑回归，精度等方面更好。 信用评分是指根据银行客户的各种历史信用资料，利用一定的信用评分模型，得到不同等级的信用分数，根据客户的信用分数，授信者可以通过分析客户按时还款的可能性，据此决定是否给予授信以及授信的额度和利率。
虽然授信者通过人工分析客户的历史信用资料，同样可以得到这样的分析结果，但利用信用评分却更加快速、更加客观、更具有一致性。
一、引进信用评分卡的目的及意义 由于零售信贷业务具有笔数多、单笔金额小、数据丰富的特征，决定了需要对其进行智能化、概率化的管理模式。信用评分模型运用现代的数理统计模型技术，通过对借款人信用历史记录和业务活动记录的深度数据挖掘、分析和提炼，发现蕴藏在纷繁复杂数据中、反映消费者风险特征和预期信贷表现的知识和规律，并通过评分的方式总结出来，作为管理决策的科学依据。目前国内大多数银行信用卡部门采取人工审批作业形式，审批依据是审批政策、客户提供的资料及审批人员的个人经验进行审批判断，存在以下问题： (1) 信审人员对申请人所提交申请资料真实性的认定基本依赖于受理申请资料的信贷业务员的职业操守和业务素质，审批人员对申请人资料的核实手段基本依赖于电话核查，对申请核准与否基本依赖于自己的信审业务经验，授信审查成本高、效率低而又面临很大的欺诈风险，这种状况很难应对年末所谓的“行业旺季”中大规模集中的小额贷款业务需要。
(2) 审批决策容易受主观因素影响、审批结果不一致，审批政策调控能力相对薄弱。
(3) 不利于量化风险级别，无法进行风险分级管理，影响风险控制的能力及灵活度，难以在风险与市场之间寻求合适的平衡点。
(4) 审批效率还有较大提升空间。
信用评分卡具有客观性，它是根据从大量数据中提炼出来的预测信息和行为模式制定的，反映了借款人信用表现的普遍性规律，在实施过程中不会因审批人员的主观感受、个人偏见、个人好恶和情绪等改变，减少了审批员过去单凭人工经验进行审批的随意性和不合理性。信用评分卡具有一致性，在实施过程中前后一致，无论是哪个审批员，只要用同一个评分卡，其评估和决策的标准都是一样的。信用评分卡具有准确性，它是依据大数原理、运用统计技术科学地发展出来的，预测了客户各方面表现的概率，使银行能比较准确地衡量风险、收益等各方面的交换关系，找出适合自己的风险和收益的最佳平衡点。运用信用评分卡可以极大地提高审批效率。由于信用评分卡是在申请处理系统中自动实施，只要输入相关信息，就可以在几秒中内自动评估新客户的信用风险程度，给出推荐意见，帮助审批部门更好地管理申请表的批核工作，对于业务批量巨大、单笔业务金额较小的产品特别适合。 二、信用评分模型的简介 信用评分模型的类型较多，比较常使用的3个如下：
在客户获取期，建立信用局风险评分，预测客户带来违约风险的概率大小；在客户申请处理期，建立申请风险评分模型，预测客户开户后一定时期内违约拖欠的风险概率，有效排除了信用不良客户和非目标客户的申请；在帐户管理期，建立催收评分模型，对逾期帐户预测催收策略反应的概率，从而采取相应的催收措施。 三、信用评分卡的开发 信用评分模型开发流程包括模型的设计与规划、样本的选择、预测变量的选择和确定、模型的制定、模型效果的评估和检验、模型的实施、模型表现的跟踪和监控等。
1. 建立开发目标、方法及业务问题的定义 开发目标：
1、确保决策的一致性，减少人工干预，提高信贷政策的执行力；
2、准确反映并量化客户的风险级别，用科学的方法管理风险以控制和减少信贷损失；
3、提高市场竞争能力，在控制可接受的风险水平的同时争取更多优质客户，有效地提高市场占有率；
4、实现审批流程自动化，减少运营成本。
模型建立方法：建立模型可采用的方法很多，业内通常使用逻辑回归方法建立贷款申请评分模型。
好、坏客户定义：好、坏客户的定义必须与银行总体政策、管理目标一致，综合考虑风控策略、催收策略、业务历史、样本数量的需要，如定义曾经有90天以上逾期不良记录的客户为坏客户；定义满12个月，未出现90天以上逾期记录的客户为好客户。
2. 确定数据源，选取样本 数据来源：内部信用卡核心系统数据库和其它相关业务系统；
样本总数量：选取某地区从2014年1月开始2016年6月的所有申请人，总数120，000人（包括好、坏客户及拒绝的申请客户）；
样本空间：
1、坏客户样本空间：2014年8月至2016年2月之间开户的客户；
2、好客户样本空间：2014年6月至2015年5月之间开户的客户；
3、被拒绝客户样本空间：2015年7月至2016年6月之间申请被拒绝的客户。
3. 数据抽取、清理和整理，建立数据集 这一步是开发申请评分模型中最重要、最耗时的步骤之一。数据质量好坏是决定开发的模型成功的关键因素。在确定数据来源后，由于需要采集的数据资料来源不一，数据量大，抽取时耗时较多，就需要在原始数据的基础上，根据业务需求、数据性质、结构及内在逻辑，对数据进行归类、合并、分组，最终建立数据集（或数据仓库）。
4. 数据分析、变量选择及转换 数据经过整理后下一步进行数据资料的分析，找出其内在关联性，并经过对样本变量的分组、合并和转换，选择符合建模条件、具有较强预测能力的变量。
如果是连续变量，就是要寻找合适的切割点把变量分为几个区间段以使其具有最强的预测能力。例如客户年龄就是连续变量，在这一步就是要研究分成几组、每组切割点在哪里预测能力是最强的。这一步是评分模型非常重要也是最耗费时间的步骤。如果是离散变量，每个变量值都有一定的预测能力，但是考虑到可能几个变量值有相近的预测能力，因此分组就是不可避免而且十分必要的。
通过对变量的分割、分组和合并转换，最终剔除掉预测能力较弱的变量，筛选出符合小额贷款实际业务需求、具有较强预测能力的变量，使建立的模型更加有效。
5. 创建评分模型 利用上面分组后形成的最新数据集进行逻辑回归运算得到初始回归模型。在回归模型的基础上，通过概率与分数之间的转换算法把概率转换成分数进而得到初始评分卡。下一步要将初始评分卡经过拒绝推论，所谓拒绝推论，即申请被拒绝的客户数据未纳入评分系统，导致样本选取的非随机性，整体信用情况因此被扭曲，信用评分模型的有效性降低。
因为申请风险评分模型是用来评估未来所有借款申请人的信用，其样本必须代表所有的借款申请群体，而不仅代表信用质量较好、被批准的那部分客户的信用状况，所以样本必须包括历史上申请被拒绝的申请人，否则，样本空间本身就会出现系统性偏差。因为样本排除了较高信用风险的申请人群体（即历史上申请被拒绝的客户）。如果仅仅依靠被批准申请人群体的样本开发评分模型，并将其运用到整个申请人群体中去，而被批准和被拒绝群体的行为特征和“坏”的比例往往大相径庭，那么这种以被批准群体代表被拒绝群体的做法将必然在很大程度上弱化模型的预测精度。
进行拒绝推论时，由于这部分被拒绝申请人的好坏表现是不可知的，必须以一定的统计手段来推测。推测的方法有很多，可以利用初始评分卡对这部分被拒绝客户进行评分，从而得出每个被拒绝客户如果被审批成为好客户的概率和坏客户的概率，再按其权重放入模型样本中，这样会尽量减少样本的偏差，同时兼顾拒绝样本的不确定性。我们利用拒绝推论后形成的样本（包括核准和拒绝的）重新对每个变量进行分组，其原理和方法与初始分组相同。然后对第二次分组形成的数据集建立逻辑回归模型。最后在第二次回归模型的基础上，通过概率与分数之间的转换算法把概率转换成分数，进而得到最终评分卡。
6. 模型检验 模型建立后，需要对模型的预测能力、稳定性进行检验后才能运用到实际业务中去。申请评分模型的检验方法和标准通常有：交换曲线、K-S指标、Gini数、AR值等。一般来说，如果模型的K-S值达到30%，则该模型是有效的，超过30%以上则模型区分度越高，本例中模型的K-S值达到40%以上，已经可以上线使用。
7. 建立MIS报表，模型的实施、监控及调整 模型实施后，要建立多种报表对模型的有效性、稳定性进行监测，如：稳定性监控报表，比较新申请客户与开发样本客户的分值分布，监控模型有效性；特征分析报表，比较当前和开发期间的每个记分卡特征的分布，监控模型有效性；不良贷款分析报表，评估不同分数段的不良贷款，并且与开发时的预测进行比较，监控客户信贷质量；最后分值分析报表，分析不同分数段的申请人、批准/拒绝以及分数调整的客户分布，监控政策执行情况等。
另外，随着时间的推移，申请评分卡的预测力会减弱，因为经济环境、市场状况和申请者、持卡者的构成在不断变化，同时，银行整体策略和信贷政策的变化也要求评分模型适时调整，所以，申请评分卡在建立后需要持续监控，在应用一段时间（一般2-3年）以后必须适当重新调整或重建。
四、运用信用评分卡需要注意的问题 1. 开展贷款业务的历史要长。 评分卡的发展必须以历史数据为依据，如果公司开展小贷业务的历史太短，数据不充分，则不具备开发评分卡的条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a807e186891ec2c6bab9cdb2379b3483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52757f7453a42f3ad48c38c91ddb4e28/" rel="bookmark">
			Java：变量的作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量的作用域 规定了变量所能使用的范围，只有在作用域范围内变量才能被使用。根据变量声明地点的不同，变量的作用域也不同。
根据作用域的不同，一般将变量分为不同的类型：类变量、局部变量、方法参数变量及异常处理参数变量。下面对这几种变量进行详细说明。
类变量 类变量也称为成员变量，声明在类中，不属于任何一个方法，作用域是整个类。
例 1：假设在一个类中声明了 3 个变量，下面编写一个测试类输出引起变量的值改变的示例代码。变量声明，实现代码如下所示：
public class DataClass{int price=100; //定义类变量 priceprice String name; //定义类变量 namename int num; //定义类变量 num} 测试类代码如下所示：
public class Test{public static void main(String[] args){DataClass dc=new DataCLass();System.out.println("name="+dc.name);System.out.println("num="+dc.num);System.out.println("price="+dc.price);}} 运行结果如下：
name=null
num=0
price=100
在第一段代码中3 个成员变量，并对其中第一个变量 price 进行了初始化，而第二个 name 变量和第三个变量 num 没有进行初始化。由输出结果可以看出，第一个变量的值为显示初始化的值，第二个和第三个变量的值则为系统默认初始化的值。
局部变量 局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。
例 2：声明两个局部变量并输出其值，实现代码如下：
public class Test2{public static void main(String[] args){int a=7;if(5&gt;3){int s=3; //声明一个int类型的局部变量System.out.println("s="+s);System.out.println("a="+a);}System.out.println("a="+a);}} 上述实例中定义了 a 和 s 两个局部变量，其中 int 类型的 a 的作用域是整个 main() 方法，而 int 类型的变量 s 的作用域是 if 语句的代码块内，运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52757f7453a42f3ad48c38c91ddb4e28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f1b535d2dea127d85f7d77862d8b93/" rel="bookmark">
			Android build.gradle 获取Git 仓库数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取 Git commit number def gitGitVersionCode() { try { return 'git rev-list HEAD --first-parent --count'.execute().text.trim().toInteger() } catch (ignored) { return 1 } } 复制代码 可以作为 app 的Version Code
defaultConfig { versionCode rootProject.gitGitVersionCode() } 复制代码 读取 Git Tag def getGitVersionName() { try { def stdout = new ByteArrayOutputStream() exec { commandLine 'git', 'describe', '--tags' standardOutput = stdout } return stdout.toString().trim() } catch (ignored) { return "1.0.0" } } 复制代码 可以作为 app 的 Version Name
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f1b535d2dea127d85f7d77862d8b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b8e0e73168ecf8a92a343cf0548f07/" rel="bookmark">
			Vue学习（v-for的使用以及普通数据排序、数组对象排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-for：循环渲染data的一组数据组，v-for指令需要以item in items形式的特殊语法
显示索引值 （item，index）in items
完整代码示例：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script type="text/javascript" src="../assets/js/vue.js"&gt;&lt;/script&gt; &lt;title&gt;v-for&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-for&lt;/h1&gt; &lt;hr&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in tidis"&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;ul&gt; &lt;!-- index是索引值 --&gt; &lt;li v-for="(student,index) in sortStudent"&gt; {{index+1}}:{{student.name}} - {{student.age}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var app = new Vue({ el: '#app', data: { items: [66, 90, 146, 189, 124, 78, 44, 119], students: [{ name: 'limeng', age: 25 }, { name: 'lili', age: 23 }, { name: 'yuyue', age: 20 }, { name: 'linlin', age: 33 } ] }, // computed计算属性，是在渲染数据之前进行的操作，在这里我们进行排序 computed: { // 在computed里新声明一个对象，如果不重新声明会污染原来的数据源，这是vue不允许的，所以需要重新声明一个对象，但是在上面循环的时候，要改变循环的对象 tidis: function () { // 在sort函数中传入自己的自己编写的数据排序的函数 return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b8e0e73168ecf8a92a343cf0548f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00742fd9832f4bac4e6b2064e1629a5/" rel="bookmark">
			RS422-485接口电路设计要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 典型的RS422接口电路
图1 典型的RS422接口电路
2 典型的RS485接口电路
图2 典型的RS485接口电路
图3 全双工RS485接口电路拓扑
3 设计要点
(1)接口保护用途的TVS管D1-8，通常选择最大反向工作电压VRWM为5.0V的双向TVS管，如Diodes SMBJ5.0CA。
(2)DI和RO引脚都使用10k电阻上拉，是为防止误触发，产生误动作，因为“UART以一个前导“0”触发一次接收动作”。
(3)图 1所示，差分接收器的端接电阻一般取值120 Ω，来源于通常RS422/485传输线所用的特征阻抗约为120 Ω。图 3所示的RS485多点应用中，若在SCH&amp;PCB设计时不清楚后期现场布线中哪两个设备距离最远，可在所有差分接收端都预留120 Ω端接电阻，以便后期现场应用时通过拨码开关选择性接入。
(4)由于RS422/485差分接收器的特性是，VIA - VIB的绝对值必须大于200 mV，否则无法正确识别高低电平。所以，图 1所示，当使用3.3V电源时，故障安全偏置电阻R5和R6最大取值为930 Ω；当使用5.0V电源时，R5和R6最大取值为1440 Ω。
说明：故障安全偏置电阻，是为了解决“总线空闲、开路或短路”情况下，接收端状态不确定的问题。由于RS422只支持点对点应用，且故障安全偏置电阻只需要在接收端使用，所以图 1和图 2电路，R3-4不是必要的，R5-6和R12-15是必要的。
(5)图 1所示，在RS422点对点应用中，两端的差分接收器都需要120 Ω并联端接电阻。图 3所示，在RS485多点应用中，只需在最远的两点接收端使用120 Ω并联端接电阻，中间各支路不需要。
(6)图 2和图 3所示，各支路的A&amp;B引脚和Z&amp;Y引脚都串联0R电阻，当某路故障时将RS485总线拉低时，逐一断开电阻，方便排查故障。
(7)SCH&amp;PCB设计时，两个设备间的RS422/485通信线，除了两对差分线外，至少需要一根地线，防止共模电压超出规定的范围而导致通信故障。
(8)有选择的情况下，RS422/485通信电缆中，信号线不应与电源线并行或尽量远离电源线，若无法避免，信号线最好使用带屏蔽的双绞线。且现场布线，采用菊花链拓扑，不采用星形或环形拓扑，以免因反射等因素导致通信错误。
[ 原创文章，转载请注明来源；Kingson_20190511 ]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68d3860384c9eab3ef93207ec619fbc/" rel="bookmark">
			64位win10下notepad&#43;&#43; jsonviewer插件安装失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照网上常见的方式安装了很多次不成功，以为是jsonviewer不支持win10。后来百度到notepad++可以通过【设置】--》【导入】--》【导入插件】的方式加载插件成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1bd375047fb5d8d101c083f0d6588f3/" rel="bookmark">
			DBHelper.CurrentSession   Fetch(SelectMode.Fetch,p=&gt;p.)    Get
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		table
public partial class Travelexpense { public virtual int Id { get; set; } public virtual Maindoc MainDoc { get; set; } public virtual IList&lt;Travelexpensedetails&gt; Details { get; set; } } public partial class Travelexpensedetails { public virtual int Id { get; set; } public virtual int? PID { get; set; } } map
public partial class TravelexpenseMap : ClassMap&lt;Travelexpense&gt; { public TravelexpenseMap() { Table("Tb_TravelExpense"); LazyLoad(); Id(x =&gt; x.Id).GeneratedBy.Identity().Column("ID"); References(x =&gt; x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1bd375047fb5d8d101c083f0d6588f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b0c5a72088fcd595675483c96a40da/" rel="bookmark">
			MVC   ajax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var options = { url: "@Url.Action("Save")", //controller名称 type: "POST", data: $("#Form").serialize(), //data success: function (data) { if (data == "success") { parent.layer.msg("保存成功", { icon: 1 }, function () { parent.layer.close(index); //关闭layer.open window.parent.location.reload(); //刷新父页面 }); } else { parent.layer.msg("保存失败"); } }, error: function (data) { alert(data); } } $.ajax(options); //不能忘记这个 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632a1cbfc9d27b4c3bec02e28c7d02cf/" rel="bookmark">
			MVC   ViewBag.xxxx   后端传值到前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Controller
public ActionResult Index() { ViewBag.Ccuser = xxxx; return View(); } cshtml 将值付给input
@using Lead.Objects.Domain @using Lead.OA.Utils @{ Layout = "~/Views/Shared/_List.cshtml"; } &lt;input id="test"/&gt; @section scripts{ $(function () { $("#test").val(ViewBag.Ccuser); }); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9444baecfa3ef7b4a80604b2a7c7be4/" rel="bookmark">
			跳出误区：Java程序员进阶架构师真的没你想象的那么简单......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小团队一般 10 人左右，其中常常是技术最牛的人做架构师（或TL）。所以，架构师在广大码农中的占比大概平均不到 10%。而架构师也可以分为初级、中级、高级三档，江湖上真正高水平的软件架构师就更少了。
所以，大部分（超过九成的）码农干上许多年，还是做不了架构师，这是什么原因造成的呢？
1：码农分为真的能写代码的，以及自认为能写代码的。
2：真的能写代码的码农又分为自认为写的不错的，以及真的还不错的。
3：真的能写不错代码的码农又分为会钻研会不断优化的，以及安于现状的。
4：会钻研的码农又分为喜欢广度了解新技术蜻蜓点水的，以及深入钻研用到知识的。
了解广度的码农又有少部分愿意深入某些技术，喜欢深入研究的又往往缺乏广度知识。
5：极少深度广度都关注的码农又分为为技术而技术和为业务而技术的。
纯为技术而技术的码农在国内的软件行业需求太少，且需求的往往不是应用软件领域了。
6：为业务而技术的深度广度都了解的码农，又需要有良好的沟通能力。
7：而沟通好的，又有一部分当PM去了。
8：然后剩下的，又有一部分慢慢脱离实际开发（不再做任何实现）或者开始依靠拿各种中间件搭积木来作为“架构”手段。
9：除去这些，剩下对业务有一定了解，对技术广度上有多种涉猎，深度上对部分技术研究彻底，还有很重要的一点，考虑问题足够细致全面。
10：细致全面善于沟通，技术上深度广度都没问题， 又喜欢这个工作，还会不时做底层实现，从业务和开发两个角度出发，搭出“架构”来是为了开发效率，为了运行效率，为了开发质量，为了业务灵活和运行稳定，为了维护方便等等这样的人，个人认为可以称为“架构师”。
而真能满足这种需求的，别说10%的比例，1%能不能达到我也持怀疑态度。其实现在的“架构师”大多数都停留在8这个层次，甚至很多在5这个层次就当上title上的架构师了。
总之，成为架构师，不仅仅是工作上的简单积累，更需要主动接纳工作外的大量知识，同时，对性格上对于非技术能力上也有一定的要求，不仅如此连思维方式都很重要，要不断找准自己定位，不断思考如何搭建架构师知识体系？
学会如何分析源码？
大部分程序员都会「写」代码，或者至少会抄代码和改代码。但是，会读代码的并不在多数，会读代码又真正读懂一些大项目的源码的，少之又少。因为它是两个原因造成的:
1：我们所有的教育和培训都在强调怎么写代码，并没有教大家如何读代码
2：大多数工作场景都是一个萝卜一个坑，我们只需要了解一个系统的局部便能开展工作，读不相干的代码，似乎没用
所以，要养成源码三问的习惯：
“为什么要有这样的架构”“他是什么样子的”“他是怎么工作的” 为什么是分布式？
首先需要说明的是，分布式系统是一个复杂且宽泛的研究领域，学习一两门在线课程，看一两本书可能都是不能完全覆盖其所有内容的。
微服务为什么会这么火?
相信大家都了解业务越来越复杂，服务分层，微服务架构是架构升级的必由之路，而对于微服务的优点相信大家都不陌生。
比如：易于开发与维护 / 微服务相对小，易于理解 / 启动时间短，开发效率高 / 独立部署 / 伸缩性强 / 每个服务都可以在横向和纵向上扩展 / 微服务架构可以更好将架构和组织相匹配 / 每个团队独立负责某些服务，获得更高的生产力 / 降低尝试新技术的成本......
程序员到底要不要学习JVM？
总有人问这个东西好像用不上,于是要不要学这样的问题，然后又总有人担心一直搬砖成天做些重复没提升的东西。
如果你这辈子只甘心做一个平庸的Java码农，那么你完全没有必要去学习JVM相关的知识。
话不多说，附上学习体系图：
被我们忽略掉的工程化专题
在IT产业中，寡头化出现代表着创业公司减少--没人再去用声势浩大的发布会讲故事、没人再去宣传自己拿了多少融资。
这一代中国人自小的教育不比欧美的STEAM，而是重学术、轻手艺。我们往往会为工科和产能过剩画上等号。强大的资本和技术门槛为这些产业蒙上了一层神秘的面纱，让普通人很难真正了解到其中技术和工艺的复杂程度，也就更难明白其中的价值。可正是因为中国的工程化能力，才让我们有机会走到AI时代的第一梯队，而不仅仅是靠学术研究能力。
附上思维脑图：
没有高并发经验，想进大公司该怎么办?
假如没有靠谱的公司,接触不到高并发的业务场景怎么办?你永远解决的是小问题，工作10年技术也未必提升多少。
很多程序员也经常找我说，没有经验就没有靠谱的公司收，没有靠谱的公司也就没有经验，我看了无数的书，自己做了无数的实验拼命想找个靠谱公司去深入，但是感觉好难，简直是个死循环
大家都比较关注高并发，原因很简单，想去BAT这样的大公司，你必须要有高并发的经验。今天普及下高并发的知识，希望大家对高并发有一个正确的认识。
学习千遍，不如项目实战成功一次
有人说：项目实战相信很多程序员都多少会有的，可是我们这个还要学习什么呢?
我的回答是：那就要看你想不想成为一个架构师了，为什么98%的程序员工作10年，一辈子还只是一个开发者，程序员们都要想一想这个问题，我是不是需要提升了。
我认为，学习项目实战最重要的还是学习项目管理，作为程序员，都应该学点项目管理。
凡事皆为“项目”项目的两类属性(复杂的逻辑，庞大的信息量)
这才是我们学习“项目实战”的终极意义。
现在作为程序员的你，或许想提升自己，却找不到突破口，公司没人带。又或许你已经工作6年了，却还是很迷茫，很多知识都还是不懂，也没有达到自己期望的一个职位，薪资。
相信大家，在学习的路上也遇到了不少的坑，有人放弃，有人坚持，但是我相信作为程序员的你不会想终其一生也只是一个开发，到年龄就会被公司辞退。
所以，大家如果想往技术路上走的，想成为架构师的，一定要保持终生学习的态度，让学习力成为核心竞争力，才能不被时代所淘汰，这里我也分享自己收集的系统的学习资料，和几套学习路径图给大家，真心的希望能帮助到大家。
资料获取方式：加入Java架构学习交流Qqun：1017599436，管理员处免费领取资料。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9444baecfa3ef7b4a80604b2a7c7be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83daf17d479ab5609fd39070b90ba623/" rel="bookmark">
			Visual Studio 2015安装教程（附激活码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装步骤：
安装前先关闭杀毒软件和360卫士，注意安装路径不能有中文，安装包路径也不要有中文。
试装系统：win10 64bit
安装前请确认，IE浏览器是否为10以上的版本，Visual Studio 2015只有IE为10以上版本才能安装成功。
1.解压安装包，运行安装程序。
2.安装程序正在运行。
3.选择安装路径，注意不要有中文，“默认”选项包括C#/VB 等，如果需要安装其它功能，选择“自定义”，我这里仅以安装C++环境为例。
4.仅以安装C++环境为例，大家需要安装什么环境请选择相应选项。
5.点击“安装”。
6.安装的过程可能比较就，大家耐心等待安装完成。
7.如出现如下警告一般不用管，直接点击启动。
8.如有账户可以选择“登陆”，没有的话选择“以后再说”。
9.点击启动Visual Studio。
10.点击菜单栏–帮助–注册产品–试用产品密钥解锁–复制安装包中的密钥到输入栏，点击应用，显示“已应用产品密钥”，点击关闭。
11.安装完成后的界面如下。
如需软件如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae4e00f984f65fd531764d778041f0c/" rel="bookmark">
			编码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		url时会导致乱码问题：
%252016%25E8%25BF%259B%25E5%2588%25B6%25E8%25BD%25AC%25E4%25B8%25AD%25E6%2596%2587
解决方式：
decodeURI()进行转换为中文
python抓取数据时也会导致数据乱码：
固安华电天仁控制设备有限公司风电变桨2019年上半年国产低压电机【二次挂网】招标公告
解决方式：
Unicode转Native
安装：pip install HTMLParser
1.from HTMLParser import HTMLParser
2.3.0版本需修改修改：
找到安装python的目录下：HTMLParser（引入后调用会报错，报错时会将地址输出出来）
import markupbase为import _markupbase as markupbase (在源码的第11行)
修改return unichr©为return chr© python3中没有unichr，用chr即可（在源码的456行
使用：HTMLParser().unescape(“字符”) by：本方法学自我是大伟
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7bcf7adf2f83b031f7817d54847f51/" rel="bookmark">
			jmeter实现接口AES加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目背景：
1.接口请求参数需加密，不是单个参数加密，而是多个参数整串加密。
2.接口返回的数据也是加密过的，不是整个返回结果加密，而是部分数据加密。
需求：
为方便测试，需要实现在发起请求时自动加密，得到返回结果后自动解密。
需准备的资源：
开发的加密解密方法以及密钥，可以是Java文件也可以是jar包（本次主要记录java文件的实现方式）
使用到的元件：
beanshell preprocessor用于加密请求参数
beanshell postprocessor用于解密返回结果
user parameters用于存放jmeter变量
csv data set config用于存放测试数据
debug sampler用于查看变量值
实现步骤：
1.在线程组下新建一个http请求，新建user parameters，添加变量body存放需要加密的请求参数
2.新建一个beanshell preprocessor写入加密方法后（如果是jar包直接引入即可），添加如下代码
System.out.println("**加密**");//打印 String password="1234567812345678";//加密密钥 System.out.println("Get my originaldata: " + vars.get("body"));//打印查看数据，body为需要加密的串 String encode=AESUtil.encrypt(vars.get("body"),password);//使用加密密钥对body加密赋给encode vars.put("body",encode);//将加密过的参数放入jmeter变量body中 3.添加 beanshell postprocessor，输入解密方法（或引入jar包），并添加如下代码，使用如下代码需要引入fastjson的jar包，将下载的fastjson-1.2.58.jar放入jmeter的lib目录下
import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.JSON;	System.out.println("**解密**");//打印 String password="1234567812345678";//解密密钥 String response_data = prev.getResponseDataAsString();//获取接口返回结果 JSONObject obj = JSON.parseObject(response_data);//将返回结果转换为json对象 String body = obj.getString("body");//提取要解密的参数body String decryptbody=AESUtil.decrypt(body,password);//使用解密密钥对body进行解密 obj.put("body",JSON.parseObject(decryptbody));//将解密后的body转为json对象赋给变量body prev.setResponseData(obj.toJSONString(),"UTF-8");//设置返回结果 4.添加csv data set config，将body中需要参数化的数据参数化
如{"data":{"version":"200","account":"${account}","password":"${password}"}}
5.添加View Results Tree查看结果，可以看到请求参数已加密，返回结果已解密
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c7bcf7adf2f83b031f7817d54847f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc1b2e9f2fca806529c5b239efe91a8/" rel="bookmark">
			String字符串截取方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接：java 字符串截取的几种方式
1.split()+正则表达式来进行截取。
将正则传入split()。返回的是一个字符串数组类型。不过通过这种方式截取会有很大的性能损耗，因为分析正则非常耗时。
String str = "abc,12,3yy98,0"; String[] strs=str.split(","); for(int i=0,len=strs.length;i&lt;len;i++){ System.out.println(strs[i].toString()); } 运行结果如下：
abc 12 3yy98 0 **2.通过subString()方法来进行字符串截取。 **
subString通过不同的参数来提供不同的截取方式
2.1只传一个参数
例如：将字符串从索引号为2开始截取，一直到字符串末尾。（索引值从0开始）；
String sb = "bbbdsajjds"; sb.substring(2); 运行结果如下：
bdsajjds 2.2传入2个索引值：
String sb = "bbbdsajjds"; sb.substring(2, 4); 从索引号2开始到索引好4结束（并且不包含索引4截取在内，也就是说实际截取的是2和3号字符）。运行结果如下：
bd 3.通过StringUtils提供的方法
3.1这里是以第一个”e”，为标准。
StringUtils.substringBefore(“dskeabcee”, “e”); 运行结果如下：
dsk 3.2这里以最后一个“e”为准。
StringUtils.substringBeforeLast(“dskeabcee”, “e”) ; 运行结果如下：
dskeabce 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb6782059b154dfc43ceee4d1a65917/" rel="bookmark">
			IP组播配置与管理实战——2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PIM-DM（IPv4）配置与管理
在PIM-DM模式中使用“推”（Push）模式转发组播报文，就是由PIM路由器向组播成员主动推送组播数据，PIM-DM网络仅适用于ASM模型，组播源是任意的，组播成员和组播路由器都不关心组播源的位置。当网络中有活跃的组播源出现，即有组播源需要向某组播组发送组播数据时，会将组播数据扩散到全网，借助RPF检查机制创建组播路由表项，实现组播数据转发。PIM-DM的关键工作机制包括邻居发现、扩散、剪枝、嫁接、断言和状态刷新这几个过程。
如上图，PIM-DM网络中出现了活跃的组播源Source后，通过组成员管理协议IGMP，SwitchD、SwitchE了解到与其相连的HostB、HostC为组播组成员，便将接收到的组播数据分别向组成员所在网段转发。由于与SwitchC相连网段没有组成员，它会逐跳向上游发起剪枝操作。组播源的最后一跳PIM组播路由器SwitchA接收到剪枝报文后，就会将与SwitchC相连的下游接口从PIM路由表项的下游接口列表中删除，抑制组播数据向该接口的网段转发。PIM-DM网络就是这样通过这种周期性的“扩散-剪枝”来构建并维护一棵单向无环的SPT（Source Specific Shortest Path Tree，源指定最短路径树）。整个SPT路径是以组播源为起点的，同时组播源也是组播的中心。——这里对上面的描述有一个不同点，上面的说法应该改成组播源第一跳PIM组播源路由器SwitchA接收到剪枝报文后，就会将与SwitchC相连的下游接口从PIM路由表项的下游接口列表中删除，这里SwitchC是最后一跳路由器（叶子路由器）。
一、PIM-DM（IPv4）特性的产品支持
PIM-DM可配置的主要特性包括基本功能的配置、PIM-DM控制参数的调整和PIM Silent。
1、PIM-DM基本功能
PIM-DM基本功能就是对对应的VLAN或者Loopback接口上使能PIM-DM功能。在接口上使能了PIM-DM功能之后，系统采用PIM-DM的缺省值就可以正常工作，将组播源发出的组播数据分发到组成员网段。
2、PIM-DM控制参数
有时为了提高网络安全性，增强组播报文转发的控制能力，根据实际需要设备支持调整PIM-DM控制参数：
3、PIM Silent
在直连用户主机的接口上需要使能PIM协议，以便在该接口上可以建立PIM邻居，处理各类PIM协议报文。存在一个问题，如果有恶意主机模拟向PIM路由器发送PIM Hello报文时，有可能导致设备瘫痪。为了避免这样的情况发生，可以将该接口设置为PIM Silent状态（即PIM消极状态），可禁止该接口接收和转发任何PIM协议报文，删除该接口上的所有PIM邻居以及PIM状态机。但该接口上的IGMP功能不受影响。
该功能仅适用于与用户主机网段直连的PIM设备接口。且该用户网段只与这一台PIM设备相连。配置了该功能后，接口将不再接收和转发任何PIM协议报文，但这样配置后，该接口配置的其他PIM功能将失效，需谨慎使用。如果用户网段与多台PIM设备相连，且如果在多个PIM设备接口上配置PIM Silent，则这些接口都成为了静态DR，会导致该网段中同时存在多个DR，从而引发组播故障。
——是不是说，配置了PIM Silent功能后，接口自动成为静态DR？
二、配置PIM-DM基本功能
在配置PIM-DM前需要先配置好单播路由协议，保证网络内单播路由畅通。且设备上不能同时使能PIM-DM和PIM-SM，如果接口上需要同时使能PIM-DM和IGMP，必须先使能PIM-DM，再使能IGMP。——配置对命令的使用顺序有要求。
PIM-DM基本功能的配置很简单，主要就是两项基本任务：一是全局使能组播路由功能（如果在配置其他组播功能时已使能，则无需再使能），二是在对应的VLAN接口或Loopback接口上使能PIM-DM功能。
三、调整组播源控制参数
每当PIM设备在接收到源S发往组播组G的组播报文后，就会启动该（S,G）表项的定时器，即源生存时间（缺省值为210s）。下次如果超时前接收到该组播源发来的报文，则重置定时器；如果超时后没有接收到该组播源发来的报文，则认为该（S,G）表项失效，将其删除。通过这种方法可以及时地更新PIM路由器上的组播转发表项。
另外，如果希望控制组播流量或者保证组播成员所接收的组播数据的安全性，还可在PIM设备上配置源地址过滤策略，只接收该策略允许范围内组播源发送的组播数据，拒绝非法的组播数据。缺省情况下，没有过滤策略，即接收任何组播源发来的组播数据。通过基本或高级ACL可对组播源地址或组地址进行过滤，还可对组播源生存时间进行控制，提高数据安全性、控制网络流量。在调整组播源控制参数前，需配置好PIM-DM基本功能。
示例1：使用数字型ACL配置接收组播源地址为10.10.1.2的组播数据包，丢弃组播源地址为10.10.1.1的组播数据包。
示例2：使用命名型ACL配置接收组播源地址为10.10.1.2的组播数据包，丢弃组播源地址为10.10.1.1的组播数据包。
示例3：使用数字型ACL配置接收组播源地址为10.10.1.2，组播组地址为225.1.1.3的组播数据包。
四、调整邻居控制参数
通过调整邻居控制参数，控制邻居间Hello报文的交互，可以防止非法邻居关系的建立，保证PIM-DM网络的安全。调整邻居控制参数前，也需完成PIM-DM基本功能配置。
1、调整Hello报文的时间控制参数
PIM设备通过周期性地发送Hello报文来维护PIM邻居关系，就像RIP、OSPF这些动态路由协议中的邻居维护一样。当PIM设备收到邻居发来Hello报文后会启动定时器，时间设为该Hello报文的保持时间。如果超时后没有收到邻居发来的Hello报文则认为该邻居失效或不可达。为了避免多个PIM设备同时发送Hello报文而导致冲突，当PIM设备接收到Hello报文时将延迟一段时间再发送Hello报文。该段时间的值为一个随机值，并且小于触发Hello报文的最大延迟。
发送Hello报文的时间间隔（缺省为30s）、Hello报文的保持时间（缺省为105s）在全局PIM视图下和接口视图下都可配置。如果同时配置，接口视图上的配置生效。但触发Hello报文的最大延迟时间（缺省为5s）只能在接口上配置。
2、配置邻居过滤策略
设备支持以下两种邻居过滤策略，来保证PIM-DM网络的安全和畅通。
（1）限定合法的邻居地址范围，防止非法邻居入侵等。
（2）拒绝接收无GenerationID的Hello报文，保证与设备相连的都是正常工作的PIM邻居。
PIMv2报文的格式如下：所谓调整邻居控制参数，主要是调整Hello报文中相应字段的值
字段 长度 说明
Version 4 比特 PIM 版本，值为 2。
Type 4 比特 消息类型，值为 0。
Reserved 8 比特 保留字段，发送时设置为 0，接收时忽略此值。
Checksum 16 比特 校验和。
Hello Option
[1]...[N]
16 比特 采用 Type-Length-Value（TLV）格式，其中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eb6782059b154dfc43ceee4d1a65917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7d0bead2bfe55cbfc3c3692176838f/" rel="bookmark">
			org.springframework.beans.factory.UnsatisfiedDependencyException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat启动SSM项目的时候出现如下错误：
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘org.springframework.web.servlet.handler.MappedInterceptor#2’: Unsatisfied dependency expressed through constructor argument with index 2 of type (类型为2的构造函数参数表示的不满意的依赖关系)[org.springframework.web.servlet.HandlerInterceptor]: Could not convert constructor argument value of type(无法转换类型的构造函数参数值) [com.akaiqi.interceptor.Interceptor1] to required type [org.springframework.web.servlet.HandlerInterceptor]: Failed to convert value of type [com.akaiqi.interceptor.Interceptor1] to required type [org.springframework.web.servlet.HandlerInterceptor]; nested exception is java.lang.IllegalStateException: Cannot convert value of type [com.akaiqi.interceptor.Interceptor1] to required type [org.springframework.web.servlet.HandlerInterceptor]: no matching editors or conversion strategy found
Error：无法将类型 [com.akaiqi.interceptor.Interceptor1] 的值转换为必需的类型[org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb7d0bead2bfe55cbfc3c3692176838f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7a4c7ef8c2d902fd4be145e2d9d11c/" rel="bookmark">
			字符串转化的最小操作数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 Given two words word1 and word2, find the minimum number of operations required to convert word1to word2.
You have the following 3 operations permitted on a word:
Insert a characterDelete a characterReplace a character Example 1:
Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:
horse -&gt; rorse (replace 'h' with 'r') rorse -&gt; rose (remove 'r') rose -&gt; ros (remove 'e') Example 2:
Input: word1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b7a4c7ef8c2d902fd4be145e2d9d11c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ace472caf1ef16e20b3a40a8d98200/" rel="bookmark">
			IP组播配置与管理实战——1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IGMP配置与管理
IGMP（InternetGroup Management Protocol，因特网组管理协议）是TCP/IP协议族中负责IPv4组播成员管理的协议，需要在组播组成员主机和与之相连的组播路由器上运行，用来在组播组成员主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。
IGMP有3个版本：IGMPv1版本（由RFC1112定义）、IGMPv2版本（由RFC2236定义）和IGMPv3（由RFC3376定义）版本。所有IGMP版本都支持ASM（任意源组播）。运行IGMPv3的主机可以直接应用于SSM（指定源组播）模型，而运行IGMPv1和IGMPv2的主机则需要与在IGMP交换机上运行的SSM Mapping结合才能应用于SSM模型中。
组播配置中，凡同时支持全局配置（即IGMP配置）和接口配置，则最终的配置生效原则如下：
（1）在IGMP视图下的配置全局有效，在接口视图下的配置只对该接口有效。
（2）如果接口视图和IGMP视图下都配置了命令，则优先选择接口视图下配置的值。接口视图下没有配置时，IGMP视图下配置的值有效。
（3）如果IGMP视图下配置非缺省值，则接口视图下配置的缺省值无效。
一、IGMP特性的产品支持
在交换机上配置IGMP协议时，可以配置的功能特性包括IGMP基本功能、IGMP性能调整（包括Router-Alert选项、IGMP查询控制器、快速离开和IGMP报文过滤等）、SSM-Mapping、IGMP组成员关系个数限制等。
IGMP是三层组播协议，需要运行在配置了IP地址的三层接口上，但华为S系列交换机的物理以太网端口是不能直接配置IP地址的，所有在配置IGMP协议时只能选择可以配置IP地址的VLANIF接口或Loopback接口（在S9300/9300E/9700中还支持POS接口和IP-Trunk接口）。本配置中，接口的配置一般选择VLANIF接口，但需要事先将对应的物理接口加入到该VLAN中。
1、IGMP基本功能
华为S系列交换机中的IGMP基本功能配置包括以下几个方面：
（1）IGMP版本配置：支持IGMPv1、IGMPv2和IGMPv3，版本可配置。交换机侧的高版本可以兼容主机侧的低版本。
（2）配置静态加入组播组：当网络中存在稳定的组播成员时，通过配置交换机用户侧接口静态加入指定的组播组，可以实现组播数据的快速、稳定转发。
（3）配置接口允许加入的组播组范围：通过在交换机用户侧对应接口上设置一个ACL规则作为过滤器，就可以限制该接口所服务的组播组范围，从而控制组播数据的安全发送。
2、IGMP性能调整
在IGMP性能调整方面，可配置以下功能：
（1）Router-Alert选项：配置设备仅接收包含Router-Alert选项的IGMP报文，提高安全性。
（2）查询器：对IGMP查询器的参数进行合理配置，既可以使成员关系得到及时的更新维护，又可以避免报文发送过多造成网络拥塞。
（3）快速离开：使IGMP协议可以快速响应成员主机的Leave（离开）报文。
（4）IGMPOn-Demand：可根据组播成员的实际需求维护组成员之间的关系，减少了报文交互，降低网络流量。
（5）IGMP报文过滤：可根据组播报文中源IP地址来过滤用户侧IGMP接口收到的IGMP报文，提高安全性。
3、SSM Mapping
SSM是一种在IGMPv3协议支持的情况下，能够在用户侧IGMP接口上指定组播源的传输服务。但有时组播组成员主机却只能运行IGMPv1或IGMPv2，这时就可以通过在交换机上配置SSM Mapping功能，向运行IGMPv1或IGMPv2的组成员提供SSM服务。
4、IGMP Limit
IGMP协议规定，成员可以在任意时间、任意位置、成员总数不受限制的加入或退出组播组。但是当大量用户同时收看多套节目时，需要占用组播设备的大量带宽，可能会造成组播性能下降。为避免这种情况的发生，交换机支持IGMP Limit功能，通过限制全局和用户侧IGMP接口下的组播组个数，使加入组播组的用户收看更加清晰稳定的节目。
二、配置IGMP基本功能
在成员主机和与之相连的交换机上配置IGMP，“使能IGMP功能”和“配置IGMP版本”为必选配置。
1、IGMP配置任务
通过在与用户网段相连的组播设备接口上使能IGMP基本功能，用户主机可以接入组播网络，接收组播报文。但在配置IGMP基本功能之前，需配置单播路由协议，使各节点间IP路由可达。主要配置任务如下：
（1）使能IGMP功能。配置IGMP协议之前，必须先使能IP组播路由功能，因为它是配置一切组播功能的前提。IGMP应该配置在与组成员相连的接口上。
（2）配置IGMP版本。运行IGMP高版本的交换机可以识别低版本的成员报告，但低版本的交换机不能识别高版本的成员报告。为了保证IGMP的正常运行，建议在交换机上配置与组播组成员主机上运行相同，或高于组播组成员主机的版本。
如果在主机侧共享网段上有多个交换机，由于不同版本的IGMP协议报文结构不同，为了保证IGMP的正常运行，必须在所有交换机接口配置相同的IGMP版本。
此项配置同时支持全局配置（即IGMP视图）和接口配置。
（3）（可选）配置静态组播组。在以下应用场景中，可在交换机的用户侧接口上配置静态组播组。
①网络中存在稳定的组播组成员。
②某网段内没有组播组成员或组播组成员主机无法发送Report报文，但是又需要将组播数据转发到该网段，可以在接口上配置静态组播组，将组播数据“拉”到接口上。
在接口上配置静态组播组后，交换机就认为此接口网段上一直存在该组播组的成员，从而转发改组的组播数据。
（4）（可选）配置接口加入的组播组范围。为了让IGMP接口所在网段的组播组成员主机加入指定的组播组，并接收这些组的报文，可以在该接口上设置ACL规则，对收到的成员Report报文进行过滤，使交换机只对该规则中允许的组播组维护组成员关系。
2、配置步骤
示例1：在与用户相连的VLANIF100接口（先要把对应物理接口加入VLAN100中）配置静态组播组224.1.1.1。
示例2：配置VLANIF100接口加入组播源IP地址为192.168.10.1，组播组IP地址为232.1.1.1的组播组（192.168.10.1,232.1.1.1）中。
示例3：配置VLANIF100接口加入以225.1.1.1位起始组播组IP地址，组播组地址递增掩码长度为8（相当于组播组子网掩码为255.255.255.0），组播组地址数量限制为10的批量组播组中。
示例4：配置VLANIF100接口加入以232.1.1.1位起始组播组IP地址，组播源IP地址为192.168.11.1，组播组地址递增掩码为0.0.255.255，组地址数量限制为10的批量组播组中。
示例5：创建编号为2005的ACL，允许主机接收来自组播组225.1.1.1的数据，然后在VLANIF100接口应用过滤策略，以限定该接口下的主机只能加入组播组225.1.1.1。
三、调整IGMP性能
使能IGMP后，缺省情况下可以正常工作。也可根据安全性和网络性能优化的要求适当调整相关参数。可以调整的IGMP性能参数包括以下几个方面
1、配置Router-Alert选项
通常情况下，网络设备收到报文时，只有目的IP地址为本设备接口地址的报文才会上送给相应的协议模块处理。这样就会存在一个问题，如果协议报文的目的地址不为本设备的接口地址，比如IGMP协议报文，由于其目的地址为组播地址，这种情况下就无法上送给IGMP协议模块处理，导致正常的组成员关系不能维护。为解决此类问题，Router-Alert选项应运而生。如果IP报文头携带Router-Alert选项，设备在接收到此类报文后会直接上送给相应的协议模块处理，而不检查目的地址。
缺省情况下，出于兼容性考虑，当前交换机在收到IGMP报文后，无论其IP报文头是否包含Router-Alert选项都会上送给IGMP协议模块处理。交换机在发送IGMP报文时，也可以选择是否需要携带Router-Alert选项。缺省情况下，组播设备发送的IGMP报文中携带Router-Alert选项。
——这里提到一个只有目的IP地址为本设备接口地址的报文才会上送给相应的协议模块处理，对于普通的IP报文，在经过路由器时，报文的目的地址应该不是设备接口的地址，难道不送给IP协议模块处理？
2、配置IGMP查询器参数
IGMP通过查询/响应报文维护组成员关系。当同一网段上有多台组播设备时，是由IGMP查询器负责发送IGMP查询报文，这时就需要指定IGMP查询器（在IGMPv1中，查询器是由PIM协议指定的，IGMPv2和IGMPv3可以手工配置）。
在实际配置中，要确保“IGMP查询报文最大响应时间”&lt;“IGMP普遍组查询报文发送间隔”&lt;“其他IGMP查询器存活时间”。在共享网段内，如果多台设备的用户侧接口都使能了IGMP，应确保设备上配置的查询器参数一致，否则有可能导致IGMP协议无法正常运行。
3、配置IGMP快速离开
在某些应用中，IGMP查询器的一个接口下只能连接着一台成员主机（这是前提条件），当主机需要在多个组播组间频繁切换时，为了快速响应主机的离开组报文，可以在IGMP查询器上配置IGMP快速离开功能。这样，当查询器收到来自主机的Leave（离开）报文时，不再发送特定组查询报文，而是直接向上游发送离开通告。这样可减小响应延迟，也节省网络带宽。
IGMP快速离开功能仅适用于IGMPv2和IGMPv3版本。
4、配置IGMP On-Demand
在标准的IGMP工作机制中，查询器通过周期性发送查询报文并接收成员反馈的Report和Leave报文来了解组播组成员信息，组成员收到查询时都会进行回应。为了减少这个过程中的报文交互，降低网络流量，可以在查询器上配置IGMP On-Demand功能。使能了IGMP On-Demand功能后，查询器可根据组播组成员的要求来维护成员关系，不再主动发送查询报文来收集成员状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ace472caf1ef16e20b3a40a8d98200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320d9d7455eebd91462d3699d08b0a16/" rel="bookmark">
			js-xlsx，table_to_book导出数据取消自动加工
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用如下方式导出时，由于js-xlsx提供了自动加工功能，会识别数据格式，然后进行加工。
XLSX.utils.table_to_book(document.getElementById('dataTable')), 这会导致导出的Excel数据和table显示数据不完全一致。
为了保证数据一致，我们添加如下参数即可。
XLSX.utils.table_to_book(document.getElementById('dataTable'),{raw:true}), raw：表示导出数据是否是未加工的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d12b3ced2462dfd3b45e520d9b04fec7/" rel="bookmark">
			vue添加animate.css动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue添加animate.css动画 1、首先在vue的index.html引入在线cdn的animate.css文件（第一种） animate.css
&lt;head&gt; &lt;link rel="stylesheet" href="animate.min.css"&gt; &lt;/head&gt; 或自己下载后放到vue项目的静态文件夹中
辅助类
给你想添加动画效果的元素添加一个 animated 类（必需）。如果需要动画循环运动，你还需要给这个元素追加 infinite 类，又或者自己另外定义一个类似于 infinite 的类。
效果添加
bounce flash pulse rubberBand shake headShake swing tada wobble jello bounceIn bounceInDown bounceInLeft bounceInRight bounceInUp bounceOut bounceOutDown bounceOutLeft bounceOutRight bounceOutUp fadeIn fadeInDown fadeInDownBig fadeInLeft fadeInLeftBig fadeInRight fadeInRightBig fadeInUp fadeInUpBig fadeOut fadeOutDown fadeOutDownBig fadeOutLeft fadeOutLeftBig fadeOutRight fadeOutRightBig fadeOutUp fadeOutUpBig flipInX flipInY flipOutX flipOutY lightSpeedIn lightSpeedOut rotateIn rotateInDownLeft rotateInDownRight rotateInUpLeft rotateInUpRight rotateOut rotateOutDownLeft rotateOutDownRight rotateOutUpLeft rotateOutUpRight hinge rollIn rollOut zoomIn zoomInDown zoomInLeft zoomInRight zoomInUp zoomOut zoomOutDown zoomOutLeft zoomOutRight zoomOutUp slideInDown slideInLeft slideInRight slideInUp slideOutDown slideOutLeft slideOutRight slideOutUp 示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d12b3ced2462dfd3b45e520d9b04fec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516744ce8ff85e3a574c8362a9ab69ca/" rel="bookmark">
			Office Tool 四月份问题反馈汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Office Tool 四月份问题反馈汇总 问题 1：Office 无法安装问题 2：Office 无法激活问题 3：Office 无法启动，Office 使用异常问题 4：Office Tool 无法正常启动问题 5：无法更改更新通道问题 6：如何更改 Office 的安装位置小小的总结 本文转载自： https://www.landiannews.com/archives/58229.html 在过去的四月份里面，Office Tool 总共有 18 万人次的使用量，感谢大家对 Office Tool 的支持。
当然了，在这么多用户里面，难免也会有部分用于遇到这样或者那样的问题。
此次发文是对四月份的问题反馈的一个汇总，将所有的问题罗列出来，附带上相应的解释，以便用户们能更容易理解这些问题的出现原因以及解决办法。
问题 1：Office 无法安装 在用户们反馈的问题中，Office 无法安装主要包括以下几点：
点击开始安装后，卡在 We’re getting things ready.点击开始安装后，弹出提示框，无法继续安装，提示内容为：Is your Internet working? Do you have enough space in your main drive?点击开始安装后，弹出提示框，无法继续安装，提示内容为：because you have the Windows Installer based of Office installed on your computer.点击开始安装后，弹出提示框，无法继续安装，提示内容为：because you have the 32 bit (or 64 bit) installed on your computer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516744ce8ff85e3a574c8362a9ab69ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6047b494c073c80a2aa701b124eb1cc/" rel="bookmark">
			APM 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 APM 全称 Application Performance Management &amp; Monitoring (应用性能管理/监控)
原理
Android APM 的原理其实非常简单，用一句话总结就是：
依据打包原理，在 class 转换为 dex 的过程中，调用 gradle transform api 遍历 class 文件，借助 Javassist、ASM 等框架修改字节码，插入我们自己的代码实现性能数据的统计。
以上所有过程都是在编译期完成的。
其实 Android 上的无痕埋点也是同样的原理，区别只不过是我们 hook 的点不同，采集的数据不同，因此掌握了 APM 的实现原理同样可以实现无痕埋点系统。
成熟APM
通用
稳定,经过多家产品的验证
自建APM
能够个性化定制
外部APM与内部系统系统难打通,带来的时间成本
数据需要掌握在自己手里
优秀的平台化实践
crash手机平台
bugly:native奔溃手机
APM
博睿、听云、OneAPM、云智慧
听云:数据采集完善,方便接入
自建APM:
美团 携程 360
工作流程:
首先在客户端（Android、iOS、Web等）采集数据；接着将采集到的数据整理上报到服务器；服务器接收到数据后建模、存储、挖掘分析，让后将数据可视化，供用户使用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd23131d2f22cedba2263ff01ac54788/" rel="bookmark">
			c&#43;&#43;/opencv利用相机位姿估计实现2D图像像素坐标到3D世界坐标的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做自动泊车项目中的车位线检测，用到了将图像像素坐标转换为真实世界坐标的过程，该过程可以通过世界坐标到图像像素坐标之间的关系进行求解，在我的一篇博文中已经详细讲解了它们之间的数学关系，不清楚的童鞋们可参考:相机标定：从世界坐标系到图像像素坐标系转换过程解析
推导过程如下：
一般情况下，摄像头的内参是我们事先标定好的，具体标定方法可以参考这篇博文：张正友相机标定Opencv实现以及标定流程&amp;&amp;标定结果评价&amp;&amp;图像矫正流程解析（附标定程序和棋盘图）
其次，用到了相机位姿估计中求解PNP的问题，相机位姿估计就是通过几个已知坐标的特征点，以及他们在相机照片中的成像，从而得到相机坐标系关于世界坐标系的旋转矩阵R与平移矩阵T，可以直接调用opencv::solvePnP函数求解，详细讲解可以参考这篇博文：相机位姿估计
具体标定方法如下：
1.以车身中心投影到地面的位置为世界坐标系的原点，垂直于地面朝上为z轴正向，车头方向为x轴的正向，y轴方向满足右手法则。
2.车位线识别中只用到了右侧摄像头，在水平地面上放置标定板，不要共线，记录出标定板的世界坐标（至少需要4个点）以及在图像中的像素坐标。
3.调用opencv::solvePnP求解相机坐标系关于世界坐标系的旋转矩阵R与平移矩阵T。
4.根据上面公式的推倒求解出图像中车位线在世界坐标中的真实位置。
下面是实现该过程的c++/opencv的代码：
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; #include &lt;ctype.h&gt; using namespace cv; using namespace std; int main() { // 首先通过标定板的图像像素坐标以及对应的世界坐标，通过PnP求解相机的R&amp;T// Point2f point; vector&lt;Point2f&gt; boxPoints; //存入像素坐标 // Loading image Mat sourceImage = imread("2.bmp"); namedWindow("Source", 1); / Setting box corners in image //one Point point = Point2f((float) 558, (float) 259); //640X480 boxPoints.push_back(point); circle(sourceImage, boxPoints[0], 3, Scalar(0, 255, 0), -1, 8); two Point point = Point2f((float) 629, (float) 212); //640X480 boxPoints.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd23131d2f22cedba2263ff01ac54788/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/236/">«</a>
	<span class="pagination__item pagination__item--current">237/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/238/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>