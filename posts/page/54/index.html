<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead2dc37feddca6df79dfc25c9c25084/" rel="bookmark">
			使用mediasoup-demo搭建多人音视频聊天室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 环境搭建 安装 nodejs，npm，尽量使用较新的 nodejs 版本，最好 &gt;= node 16
curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -
sudo apt install nodejs
安装 gulp：sudo npm install -g gulp-cli
安装 build-essential：sudo apt install build-essential
二. mediasoup-demo部署 1. 下载 mediasoup-demo 代码
git clone https://github.com/versatica/mediasoup-demo.git
2. 进入 mediasoup-demo/server 目录，安装所需依赖（这个过程可能会久一点，请耐心等待）
cd mediasoup-demo/server
npm install
3. 在 mediasoup-demo/server 目录下从 config.example.js 拷贝出一个新文件 config.js
cp config.example.js config.js
4. 在 mediasoup-demo/server 目录下新建 certs 目录，进入 certs 目录后使用 openssl 生成自签名证书
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead2dc37feddca6df79dfc25c9c25084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665bbfe23e264407079c3a942f199947/" rel="bookmark">
			第七版教材下的PMP考试有多难？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		难度没有上升多少的，毕竟新考纲已经考过几轮考试了，如果报了培训班，那是没多大难度，如果自学，也只是难在理解第七版教材，会比第六版难以理解很多，而且第六版的知识也仍然有用，只是相对来说过于教条式，比较生硬。
第七版教材转向注重原则性的内容，整体具有普适性，也不受项目类型或交付方式的影响。 考试的内容是按考纲而来，学透考纲，再把第七版指南的重要内容理解，最后在学习一下敏捷内容，就可以了。重点就是预测+敏捷。
第七版主要内容：
敏捷主要内容：
来分享一下PMP备考经验，可以借鉴下： 1、《PMBOK指南》一定要看！ 虽然强调这个有点傻，哪个考试不读教材的，考试的点都在教材里，但是我看了知乎上一些问题，还有朋友问过我读不读的问题，我还是有必要强调一遍，《PMBOK®指南》一定要读！无论是第六版还是第七版。
《PMBOK®指南》要完整的看上至少一遍，明白一些基本的知识点、考试的重点，例如项目、项目管理等；
考纲也要看，现在的考纲和教材不一样了，多了的内容是敏捷管理的内容，要去看相关的知识书籍，例如《敏捷实践指南》；
考纲的每个知识点都要搞清楚，结合教材，可以在网上买一些课程去学习，还没懂的，可以去网上去看大佬的考纲分析，每个点在哪本书里，再去理解记忆；
如果有时间的话，最好将《PMBOK®指南》多看几遍，加深印象。
2、教学视频 我在课前预习的时候，自己预习内容，两眼茫然，压根看不懂，听老师讲完才茅塞顿开。老师会讲重点难点，会结合例子来理解知识点，比自己来一点一点的弄懂，不仅要快的多，也更能吸收知识。
课前预习，不懂的地方或者自己有额外的问题都写下来，课上去解决，直播课可以提出自己的疑惑；
记笔记，好记性不如烂笔头，建议每一节课都将老师讲的重点难点记录下来，增加熟悉度，做题时可以用来参考；
做思维导图或者ITTO，可以上完一节课就做思维导图，也可以按章节、按重点做思维导图，主要是为梳理逻辑，整理思维，ITTO要注意输入、工具和技术、输出。
需要第七版和第六版思维导图可留言：
3、刷题 题目一定要做，不管是模拟题还是一般的练习题，都要大量的做，关看和背书上的知识点是不能够通过考试的，除非你运气逆天了。
PMP考题关注的是应用层面，而不是背诵。应用场景的方式，比如在那个当下，如果你是项目经理，你会怎么做？
最开始刷题时，不要着急对错，要去找题干的重点，是考的哪个知识点，再去每个答案的对错，看不出来可以先看解析，慢慢的去学习去找；
考察知识点的掌握情况，是不记得？还是记混了？还是没有见过？要解决这些问题；
要重点分析错题，为什么会错？是粗心还是不会？错题要及时记录下来，以后要时不时的去做一做；
对于确定不了正确答案的题不能放过，因为题是外国人出的缘故，有些题，答案不全是错的，但一定有个最优解，这样的题就需要去分析题目的逻辑和答案的优先级关系；
模拟题当真正的考题来做，考试有将近4个小时，如果不提前体验和适应一下，可能无法正常发挥。
考试注意 1、提前找好考场附近的酒店，为了休息好，可以优先找安静点的地段；
2、该带的身份证、准考证、健康码、行程码、7天内核酸检测阴性证明等等，都要准备好；
3、考前记得吃一些高热量的食物，例如巧克力之类的，考试时间长，避免因为饥饿发挥失常；
4、建议做20-30题就涂一次答题卡，题目数量多，最后涂怕来不及，还要记得留时间检查。
我的分享就到这里了，考试加油~
pmp干货：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd76cbf17356136d56804cd4cf8cec1/" rel="bookmark">
			Flink时间窗口和水位线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink时间窗口和水位线 一、 Flink中的时间和窗口1.窗口（Window）2.窗口API 二、窗口函数(Window Functions)1.增量聚合函数2.全窗口函数3. 增量聚合和全窗口函数的结合使用4.窗口的生命周期 三、时间语义和水位线1.时间语义的选择1.水位线（Watermark）3.水位线和窗口的工作原理4.生成水位线5.水位线的传递6.迟到数据的处理 四、双流结合1.基于时间的合流——双流联结（Join）2.间隔联结（Interval Join） 一、 Flink中的时间和窗口 在批处理统计中，我们可以等待一批数据都到齐后，统一处理。但是在实时处理统计中，我们是来一条就得处理一条，那么我们怎么统计最近一段时间内的数据呢？
引入“窗口”。所谓的“窗口”，一般就是划定的一段时间范围，也就是“时间窗”；对在这范围内的数据进行处理，就是所谓的窗口计算。所以窗口和时间往往是分不开的。接下来我们就深入了解一下Flink中的时间语义和窗口的应用。
1.窗口（Window） Flink是一种流式计算引擎，主要是来处理无界数据流的，数据源源不断、无穷无尽。想要更加方便高效地处理无界流，一种方式就是将无限数据切割成有限的“数据块”进行处理，这就是所谓的“窗口”（Window）。
注意：Flink中窗口并不是静态准备好的，而是动态创建——当有落在这个窗口区间范围的数据达到时，才创建对应的窗口。另外，这里我们认为到达窗口结束时间时，窗口就触发计算并关闭，事实上“触发计算”和“窗口关闭”两个行为也可以分开。
1）按照驱动类型分
2）按照窗口分配数据的规则分类
根据分配数据的规则，窗口的具体实现可以分为4类：滚动窗口（Tumbling Window）、滑动窗口（Sliding Window）、会话窗口（Session Window），以及全局窗口（Global Window）。
滚动窗口（Tumbling Window）
滚动窗口可以基于时间也可以基于数据长度进行滚动，滚动窗口统计的数据是没有重复的
滑动窗口（Sliding Window）
滑动窗口基于时间进行滑动，两个窗口有可能会包含相同的数据。
会话窗口(Session Windows)
当在规定的时间间隔内，会话都没有收到数据，那么将开始下一个会话
全局窗口(Global Windows)
2.窗口API （1）按键分区窗口（Keyed Windows）
经过按键分区keyBy操作后，数据流会按照key被分为多条逻辑流（logical streams），这就是KeyedStream。基于KeyedStream进行窗口操作时，窗口计算会在多个并行子任务上同时执行。相同key的数据会被发送到同一个并行子任务，而窗口操作会基于每个key进行单独的处理。所以可以认为，每个key上都定义了一组窗口，各自独立地进行统计计算。
（2）非按键分区（Non-Keyed Windows）
如果没有进行keyBy，那么原始的DataStream就不会分成多条逻辑流。这时窗口逻辑只能在一个任务（task）上执行，就相当于并行度变成了1。
非按键分区的流使用AllWindowedStream进行开窗。
SingleOutputStreamOperator&lt;WaterSensor&gt; source = env.socketTextStream("localhost", 7777) .map(new WaterSensorMapFunction()); KeyedStream&lt;WaterSensor, String&gt; sensorKS = source.keyBy(sensor -&gt; sensor.id); //todo 基于时间的窗口 //滚动窗口,窗口长度10s sensorKS.window(TumblingEventTimeWindows.of(Time.seconds(10))); //滑动窗口,窗口长度10s,步长2s sensorKS.window(SlidingProcessingTimeWindows.of(Time.seconds(10),Time.seconds(2))); //会话窗口,超时间隔5s sensorKS.window(ProcessingTimeSessionWindows.withGap(Time.seconds(5))); //todo 基于计数的窗口 //滚动窗口 累计5条数据进行滚动 sensorKS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cd76cbf17356136d56804cd4cf8cec1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025d95b0be4611758bbb075a416f7f73/" rel="bookmark">
			如何更加完善的封装axios请求：防抖拦截、无感刷新token、各环境baseUrl配置等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 先看下常见的封装请求及使用方法：
1.新建request.js，内容为：
import axios from 'axios' const service = axios.create({ baseURL: '', timeout: 3000, headers: {} }) service.interceptors.request.use( config =&gt; { // 这里是添加token、判断登录权限等等一些处理逻辑 return config }, error =&gt; { Promise.reject(error) } ) service.interceptors.response.use( res =&gt; { // 这里是一些处理逻辑 return res.data }, error =&gt; { return Promise.reject(error) } ) export default service 2.新建一些api文件如 /api/user.js，内容为：
import request from '@/utils/request' // 用户登录 export function userLogin(data) { return request({ url: '/api/user/login', method: 'POST', // post请求 data }) } // 获取列表信息 export function userList(id) { return request({ url: '/api/user/list?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/025d95b0be4611758bbb075a416f7f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ade283b92b17c03ffc8176259f97b6/" rel="bookmark">
			【含面试】解锁MySQL group_concat的无限可能性：解决长度限制并实现高效查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI绘画关于SD,MJ,GPT,SDXL百科全书 面试题分享点我直达 2023Python面试题 2023最新面试合集链接 2023大厂面试题PDF 面试题PDF版本 java、python面试题 项目实战:AI文本 OCR识别最佳实践 AI Gamma一键生成PPT工具直达链接 玩转cloud Studio 在线编码神器 玩转 GPU AI绘画、AI讲话、翻译,GPU点亮AI想象空间 史上最全文档AI绘画stablediffusion资料分享 AI绘画 stable diffusion Midjourney 官方GPT文档 AIGC百科全书资料收集 AIGC资料包 在数据库应用程序中，我们经常需要将多个行合并为一个字符串，以满足特定的业务需求。MySQL提供了一个非常强大的函数来执行这项任务 - GROUP_CONCAT。然而，GROUP_CONCAT也存在长度限制，这可能会在某些情况下限制我们的应用程序功能。本文将深入探讨如何使用GROUP_CONCAT，并提供解决GROUP_CONCAT长度限制的方法，以及一个Java代码示例，帮助你的数据库应用程序更高效地执行字符串合并操作。
第一部分：MySQL的GROUP_CONCAT函数 1.1 GROUP_CONCAT简介 MySQL的GROUP_CONCAT函数是一种强大的聚合函数，通常用于将多个行合并为一个字符串。它的一般语法如下：
SELECT GROUP_CONCAT(column_name SEPARATOR separator) FROM table_name WHERE condition; column_name：需要合并的列名。separator：用于分隔合并后的值的分隔符。table_name：表名。condition：可选的筛选条件。 1.2 GROUP_CONCAT的应用场景 GROUP_CONCAT的应用场景非常广泛，包括但不限于：
将某个用户的所有订单号以逗号分隔显示。列出一个论坛帖子的所有回复。在报告中显示某个部门的所有员工名字。 第二部分：解决GROUP_CONCAT长度限制 虽然GROUP_CONCAT是一个非常强大的函数，但默认情况下，它有一个长度限制，通常为1024或者更小。这个限制可能会在处理大量数据时成为问题。那么，如何解决这个问题呢？
2.1 修改GROUP_CONCAT的长度限制 MySQL允许我们通过修改group_concat_max_len系统变量来更改GROUP_CONCAT的长度限制。这可以通过以下命令来实现：
SET SESSION group_concat_max_len = new_max_len; 其中，new_max_len是你希望设置的新的长度限制值。请注意，这只会在当前会话中生效，一旦会话结束，限制将会恢复为默认值。
2.2 全局修改GROUP_CONCAT的长度限制 如果你希望对整个MySQL服务器进行全局的修改，可以修改MySQL配置文件（通常是my.cnf或my.ini）。在配置文件中添加以下行：
[mysqld] group_concat_max_len = new_max_len 然后重启MySQL服务器以使更改生效。
2.3 注意事项 修改GROUP_CONCAT的长度限制时需要谨慎，特别是在生产环境中。设置一个过大的值可能会导致内存问题和性能下降。建议根据实际需求来调整长度限制。
第三部分：Java代码示例 现在，让我们通过一个Java代码示例来演示如何使用GROUP_CONCAT以及如何解决长度限制问题。假设我们有一个订单表，我们想要列出每个客户的所有订单号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15ade283b92b17c03ffc8176259f97b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcda895ac3dfdd0dd8f776b530b10628/" rel="bookmark">
			MySQL 8 复制（一）——异步复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、MySQL异步复制介绍
1. 复制的用途
2. 复制如何工作
3. 两阶段提交
二、复制实验环境
三、安装mysql-8.0.16
四、配置异步复制
1. 空库
2. 脱机
3. 联机
一、MySQL异步复制介绍 简单说，复制就是将来自一个MySQL数据库服务器（主库）的数据复制到一个或多个MySQL数据库服务器（从库）。传统的MySQL复制提供了一种简单的Primary-Secondary复制方法，默认情况下，复制是单向异步的。MySQL支持两种复制方式：基于行的复制和基于语句的复制。这两种方式都是通过在主库上记录二进制日志（binlog）、在从库重放中继日志（relylog）的方式来实现异步的数据复制。二进制日志或中继日志中的记录被称为事件。所谓异步包含两层含义，一是主库的二进制日志写入与将其发送到从库是异步进行的，二是从库获取与重放日志事件是异步进行的。这意味着，在同一时间点从库上的数据更新可能落后于主库，并且无法保证主从之间的延迟间隔。
复制给主库增加的开销主要体现在启用二进制日志带来的I/O，但是开销并不大，MySQL官方文档中称开启二进制日志会产生1%的性能损耗。出于对历史事务备份以及从介质失败中恢复的目的，这点开销是非常必要的。除此之外，每个从库也会对主库产生一些负载，例如网络和I/O开销。当从库读取主库的二进制日志时，可能会造成一定的I/O开销。如果从一个主库上复制到多个从库，唤醒多个复制线程发送二进制日志内容的开销将会累加。但所有这些复制带来的额外开销相对于应用对MySQL服务器造成的高负载来说是很小的。
1. 复制的用途 （1）横向扩展
通过复制可以将读操作指向从库来获得更好的读扩展。所有写入和更新都在主库上进行，但读取可能发生在一个或多个从库上。在这种读写分离模型中，主库专用于更新，显然比同时进行读写操作会有更好的写性能。需要注意的是，对于写操作并不适合通过复制来扩展。在一主多从架构中，写操作会被执行多次，这时整个系统的写性能取决于写入最慢的那部分。
（2）负载均衡
通过MySQL复制可以将读操作分不到多个服务器上，实现对读密集型应用的优化。对于小规模的应用，可以简单地对机器名做硬编码或者使用DNS轮询（将一个机器名指向多个IP地址）。当然也可以使用复杂的方法，例如使用LVS网络负载均衡器等，能够很好地将负载分配到不同的MySQL服务器上。
（3）提高数据安全性
提高数据安全性可以从两方面来理解。其一，因为数据被复制到从库，并且从库可以暂停复制过程，所以可以在从库上运行备份服务而不会影响相应的主库。其二，当主库出现问题，还有从库的数据可以被访问。但是，对备份来说，复制仅是一项有意义的技术补充，它既不是备份也不能够取代备份。例如，当用户误删除一个表，而且此操作已经在从库上被复制执行，这种情况下只能用备份来恢复。
（4）提高高可用性
复制能够帮助应用程序避免MySQL单点失败，一个包含复制的设计良好的故障切换系统能够显著缩短宕机时间。
（5）滚动升级
比较普遍的做法是，使用一个高版本MySQL作为从库，保证在升级全部实例前，查询能够在从库上按照预期执行。测试没有问题后，将高版本的MySQL切换为主库，并将应用连接至该主库，然后重新搭建高版本的从库。
2. 复制如何工作 如前所述，MySQL复制依赖二进制日志，所以要理解复制如何工作，先要了解MySQL的二进制日志。
（1）二进制日志
二进制日志包含描述数据库更改的事件，如建表操作或对表数据的更改等。开启二进制日志有两个重要目的：
用于复制。主库上的二进制日志提供要发送到从库的数据更改记录。主库将其二进制日志中包含的事件发送到从库，从库执行这些事件以对主服务器上的数据进行相同的更改。用于恢复。当出现介质错误（如磁盘故障）时，数据恢复操作需要使用二进制日志。还原备份后，将重新执行备份后记录的二进制日志中的事件。 不难看出，MySQL二进制日志所起的作用与Oracle的归档日志类似。二进制日志只记录更新数据的事件，不用于SELECT或SHOW等语句。通过设置log-bin系统变量开启二进制日志，MySQL 8中缺省是开启的。
二进制日志有STATEMENT、ROW、MIXED三种格式，通过binlog-format系统变量设置：
STATMENT格式，基于SQL语句的复制（statement-based replication，SBR）。每一条会修改数据的SQL语句会记录到binlog中。这种格式的优点是不需要记录每行的数据变化，这样二进制日志会比较少，减少磁盘I/O，提高性能。缺点是在某些情况下会导致主库与从库中的数据不一致，例如last_insert_id()、now()等非确定性函数，以及用户自定义函数（user-defined functions，udf）等易出现问题。ROW格式，基于行的复制（row-based replication，RBR）。不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子，能清楚记录每一行数据的修改细节。其优点是不会出现某些特定情况下的存储过程、函数或触发器的调用和触发无法被正确复制的问题。缺点是通常会产生大量的日志，尤其像大表上执行alter table操作时候会让日志暴涨。MIXED格式，混合复制（mixed-based replication，MBR）。是语句和行两种格式的混合使用，默认使用STATEMENT模式保存二进制日志，对于STATEMENT模式无法正确复制的操作，会自动切换到基于行的格式，MySQL会根据执行的SQL语句选择日志保存方式。 MySQL 8缺省使用ROW格式。二进制日志的存放位置最好设置到与MySQL数据目录不同的磁盘分区，以降低磁盘I/O的竞争，提升性能，并且在数据磁盘故障的时候还可以利用备份和二进制日志恢复数据。
（2）复制步骤
总的来说，MySQL复制有五个步骤：
在主库上把数据更改事件记录到二进制日志中。从库上的I/O线程向主库询问二进制日志中的事件。主库上的binlog dump线程向I/O线程发送二进制事件。从库上的I/O线程将二进制日志事件复制到自己的中继日志中。从库上的SQL线程读取中继日志中的事件，并将其重放到从库上。 图1更详细地描述了复制的细节。
图1 复制如何工作 第一步是在主库上记录二进制日志。在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。在记录二进制日志后，主库会告诉存储引擎可以提交事务了。
下一步，从库将主库的二进制日志复制到其本地的中继日志中。首先，从库会启动一个工作线程，称为I/O线程，I/O线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制日志转储（binlog dump）线程，它会读取主库上二进制日志中的事件，但不会对事件进行轮询。如果该线程追赶上了主库，它将进入睡眠状态，直到主库发送信号通知其有新的事件时才会被唤醒，从库I/O线程会将接收到的事件记录到中继日志中。
从库的SQL线程执行最后一步，该线程从中继日志中读取事件并在从库上执行，从而实现从库数据的更新。当SQL线程追赶I/O线程时，中继日志通常已经在系统缓存中，所以重放中继日志的开销很低。SQL线程执行的事件也可以通过log_slave_updates系统变量来决定是否写入其自己的二进制日志中，这可以用于级联复制的场景。
这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。也就是说I/O线程能够独立于SQL线程之外工作。但这种架构也限制了复制的过程，其中最重要的一点是在主库上并发更新的查询在从库上通常只能串行化执行，因为缺省只有一个SQL线程来重放中继日志中的事件。在MySQL 5.6以后已经可以通过配置slave_parallel_workers等系统变量进行并行复制，在后面讨论与复制相关的性能问题时会介绍并行复制的相关细节。
现在我们已经了解了MySQL复制是以二进制日志为基础的，但是像Innodb这样的事务引擎有自己的事务日志，如ib_logfile，这些事务日志通常被称为重做日志（redo log）。作为背景知识，简单介绍下Innodb重做日志的作用。
对Innodb的任何修改操作都会首先在称为缓冲池（innodb buffer pool）的内存页面上进行，然后这样的页面将被标记为脏页，并被放到专门的刷新列表上，后续将由master thread或专门的刷脏线程阶段性的将这些页面写入磁盘。这样的好处是避免每次写操作都操作磁盘导致大量的随机I/O，阶段性的刷脏可以将多次对页面的修改合并成一次I/O操作，同时异步写入也降低了访问时延。然而，如果在脏页还未刷入磁盘时，服务器非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行实例恢复操作，这个文件就是重做日志文件。每当有更新操作时，在数据页变更之前将操作写入重做日志，这样当发生掉电之类的情况时系统可以在重启后继续操作。这就是所谓的预写日志（Write-ahead logging，WAL）。这样的技术推迟了缓冲区页面的刷新，从而提升了数据库的吞吐量。同时由于重做日志的写操作是顺序I/O，相对于写数据文件的随机I/O要快得多。大多数数据库系统都采用类似的技术实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcda895ac3dfdd0dd8f776b530b10628/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d92f333ca7e5a0259d0142f2c4b5195/" rel="bookmark">
			AWK快速入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到安装开源软件的相关脚本，其中大量用到AWK相关内容。本文介绍AWK的基础知识及典型用法、结合示例进行说明，方便备忘查询。了解awk基础知识将大大提高命令行上操作文本文件的能力。awk有几种不同的实现。我们将使用awk的GNU实现，它被称为gawk。在大多数Linux系统上，awk解释器只是gawk的符号链接。
记录和字段 Awk可以处理文本数据文件和流。输入数据分为记录和字段。Awk每次操作一条记录，直到到达输入的末尾。记录由一个称为记录分隔符的字符分隔。默认的记录分隔符是换行符，这意味着文本数据中的每一行都是一条记录。可以使用RS变量设置新的记录分隔符。
记录由字段分隔符分隔的字段组成。默认情况下，字段由空格分隔，包括一个或多个制表符、空格和换行符。
每个记录中的字段由美元符号($)引用，后面跟着以1开头的字段号。第一个字段用$1表示，第二个字段用 2 表示，以此类推。最后一个字段也可以用特殊变量 2表示，以此类推。最后一个字段也可以用特殊变量 2表示，以此类推。最后一个字段也可以用特殊变量NF来引用。可以用$0引用整个记录。
下面是如何引用记录和字段的可视化表示:
tmpfs 788M 1.8M 786M 1% /run/lock /dev/sda1 234G 191G 31G 87% / |-------| |--| |--| |--| |-| |--------| $1 $2 $3 $4 $5 $6 ($NF) --&gt; fields |-----------------------------------------| $0 --&gt; record AWK 程序 要用awk处理文本，需要编写一个程序，告诉命令该做什么。该程序由一系列规则和用户定义的函数组成。每个规则包含一个模式和操作对。规则之间用换行符或分号(;)分隔。通常，awk程序是这样的:
pattern { action } pattern { action } ... 当awk处理数据时，如果模式与记录匹配，它就对该记录执行指定的操作。当规则没有模式时，匹配所有记录(行)。
awk动作用大括号({})括起来，由语句组成。每个语句指定要执行的动作。一个动作可以有多个语句，用换行符或分号(;)分隔。如果规则没有动作，则默认打印整个记录。
Awk支持不同类型的语句，包括表达式、条件、输入、输出语句等等。最常见的awk语句有:
exit - 停止执行整个程序并结束.next - 停止处理当前记录并移至输入数据的下一条记录.print - 打印记录、字段、变量以及自定义文本.printf - 对输出格式进行更多的控制，类似C语言的 printf . 在编写awk程序时，在井号(#)之后直到行尾的所有内容都被认为是注释。可以使用延续字符反斜杠()将长行分成多行。
执行AWK程序 awk程序可以以几种方式运行。如果程序很短很简单，可以直接在命令行上传递给awk解释器:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d92f333ca7e5a0259d0142f2c4b5195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ec96a77d5e3bb1d8f70ecaa65802d8/" rel="bookmark">
			嵌入式开发基础01：Ubuntu系统下简单C程序的编译和运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：本文主要讲解Ubuntu系统下，运用vim、gcc、makefile工具编译、运行简单的C程序（输出“hello ,world”）及
返回两整型参数的求和）。
一、开发工具 1、 开发工具简介 （1）vim文本编辑器 vim拥有各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用，比那些没有模式的编辑器更加高效的进行文本编辑。同时VIM与很多快捷键设置和正则表达式类似,可以辅助记忆。
Vim具有三种模式：命令模式、插入模式、低行模式。运用vim命令直接打开文件默认是在命令模式下。
命令模式：不能直接编辑文本，输入的字母会被当作命令执行。
插入模式：在命令模式下输入字母i可切换到插入模式，在当前光标前输入，插入模式下按Esc可以返回命令模式。
低行模式：在此模式下可进行保存、字符替换等操作，低行模式命令以回车结束，或者以Esc返回命令模式。
vim编辑器进入指令
vim 文件名（带后缀）
编辑器打开文件在低行模式下
q!+回车 不保存退出
wq+回车 保存退出
命令模式下光标移动：
h 左移
l 右移
k 上移
j 下移
H 当前屏幕第一行
M 当前屏幕中间
L 当前屏幕最后一行
插入文本或行：
a 在当前光标位置的右边添加文本
i 在当前光标位置的左边添加文本
A 在当前行的末尾位置添加文本
I 在当前行的开始处添加文本(非空字符的行首)
O 在当前行的上面新建一行
o 在当前行的下面新建一行
R 替换(覆盖)当前光标位置及后面的若干文本\nJ 合并光标所在行及下一行为一行(依然在命令模式)
（2）gcc编译器 GCC即GUN Compiler Collection，是由GUN开发的编程语言编译器经拓展后，由只能处理C语言拓展为能够支持C++、java、Go以及各类处理器架构上的汇编语言等。现已被大多数类Unix操作系统（如Linux、BSD、MacOS X等）采纳为标准的编译器
在本文中，使用gcc编译C程序操作如下：
在hello.c文件保存后，在文件目录下打开命令窗口，输入命令：
gcc hello.c -o hello可以将hello.c文件编译链接为可执行文件hello.
然后通过命令./hello来运行可执行文件。（如果不指定文件名，如hello,gcc将生成名为a.out的文件，.out文件是用以区分编译后的文件，Linux下的可执行文件并没有标准的后缀，一般可执行文件没有后缀名。）
2、开发工具安装 在命令行中，执行以下命令完成开发工具的安装
sudo apt-get install vim sudo apt-get install gcc 二、运行hello world程序 1、建立文件 使用vim建立一个新文件的命令格式为“vim 文件名”。使用命令建立一个hello.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76ec96a77d5e3bb1d8f70ecaa65802d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbf7e4fca09a57db43556d259c94ac0c/" rel="bookmark">
			使用Jquery实现轮播图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然轮播图已经有很多第三方库，但是手动实现一个还是能够对javascript有一个更深的理解。
今天就讲一讲如何使用Jquery实现轮播图
首先html结构如下： &lt;div class="scroll"&gt;
// 结合下面的css样式可以知道： 下面是五张轮播图片一开始重叠在
// 父级元素的左上角，轮播图在JS中是通过opacity透明度来控制是否显示的
&lt;ul id="scroll"&gt; &lt;li&gt;&lt;a href="plus5.html"&gt;&lt;img src="img/scroll_01.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="plus5.html"&gt;&lt;img src="img/scroll_02.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="plus5.html"&gt;&lt;img src="img/scroll_03.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="plus5.html"&gt;&lt;img src="img/scroll_04.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="plus5.html"&gt;&lt;img src="img/scroll_05.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="plus5.html"&gt;&lt;img src="img/scroll_06.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="scroll_dot"&gt;
&lt;!-- 以下是六个圆点的占位 --&gt;
&lt;span class="scroll_dot_span"&gt;&lt;/span&gt;
&lt;span&gt;&lt;/span&gt;
&lt;span&gt;&lt;/span&gt;
&lt;span&gt;&lt;/span&gt;
&lt;span&gt;&lt;/span&gt;
&lt;span&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="scroll_arrows"&gt;
&lt;a href="javascript:void(0);"&gt;&lt;span class="left scroll_arrows_back"&gt;〈&lt;/span&gt;&lt;/a&gt;
&lt;a href="javascript:void(0);"&gt;&lt;span class="right scroll_arrows_back"&gt;〉&lt;/span&gt; &lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
CSS样式如下：
.scroll #scroll img {
width: 1226px;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbf7e4fca09a57db43556d259c94ac0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aab2657ca7d00640d0ba7cc1145f8d7/" rel="bookmark">
			【mars3d学习】淹没分析，计算最高最低值出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一：淹没分析（地形分析） Mars3d淹没分析的示例 - 功能示例(Vue版) | Mars3D三维可视化平台 | 火星科技
初始化一个polygon面的时候，使用 mars3d.PolyUtil.interPolygonByDepth 直接计算淹没的最大最小高度值；
但是打印出来的值却是这样的；值应该不对，且淹没的时候分析效果也不对；
但是使用startDraw的时候是正常计算值的，而且将这段代码原原本本的复制到 “绘制矩形”’ 按钮的方法中，也是正常计算值的；
原因： 因此我猜测应该是地图没有加载导致，
解决： 加个 load 事件，在加载淹没代码；
果然在 load 事件下，正常计算出最大最小值；
问题二：淹没分析（矢量面） Mars3d淹没分析的示例 - 功能示例(Vue版) | Mars3D三维可视化平台 | 火星科技
因为需求原因，又切换成这种加载方式，矢量面的淹没分析，又遇到了计算失败的问题；
这次是在 load 事件下面呀，但是加载的还是无限数字；
原因： 我觉得应该和地形分析的淹没分析一样，是地形没有加载完全导致的；毕竟这个是按照当前视域进行加载的；
也就是说我的视角刚跳到那块，那块的地形刚刚开始加载，还没有加载好，我就开始计算了
解决： 那就使用 setCameraView 跳转视角，的成功事件里加载淹没分析计算
在 complete (跳转完成后执行) 里就可以正常计算；
tips:问题二中跳转过去之后计算的值有时候不一致；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/172843069a4762000f59ea2a8b63eebc/" rel="bookmark">
			微信小程序获取用户信息流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在微信小程序中获取用户信息，通常需要经过以下流程：
此外，还需要在小程序的 app.json 文件中配置 scope.userInfo 以确保可以请求用户信息授权。例如：
需要注意的是，从微信 7.0.0 开始，用户信息授权不再是全量授权，而是分为两部分：基本信息和用户敏感信息。基本信息（如头像、昵称）可以在用户未授权的情况下获取，但用户敏感信息（如手机号码、地理位置）需要用户明确授权。因此，在获取用户信息时，需要根据实际需求来选择获取哪些信息，以及如何处理用户未授权的情况。
引导用户授权： 首先，你需要在小程序中创建一个按钮或其他触发用户授权的交互元素，以便用户点击后授权获取其信息。例如，可以在按钮上添加一个点击事件，当用户点击时触发获取用户信息的操作。
示例代码：
// 页面的 WXML 文件 &lt;button bindtap="getUserInfo"&gt;获取用户信息&lt;/button&gt; 获取用户授权： 在点击事件的处理函数中，调用 wx.getUserInfo 方法来获取用户信息，并请求用户授权。如果用户未授权，会弹出授权弹窗让用户确认是否授权。
示例代码：
// 页面的 JS 文件 Page({ getUserInfo: function(e) { wx.getUserInfo({ success: function(res) { // 用户授权成功，可以获取用户信息 var userInfo = res.userInfo; console.log(userInfo); }, fail: function(res) { // 用户拒绝授权或其他错误情况 console.log('获取用户信息失败', res); } }); } }); 处理用户授权结果： 在 wx.getUserInfo 的回调函数中，根据用户的授权结果进行处理。如果用户同意授权，可以获取到用户的基本信息，包括头像、昵称等，这些信息将存储在 res.userInfo 中。
使用用户信息： 一旦获取到用户信息，你可以将其用于小程序的业务逻辑，例如显示用户头像和昵称，或者将用户信息上传到服务器进行进一步处理。
//页面json中 { "permission": { "scope.userLocation": { "desc": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/172843069a4762000f59ea2a8b63eebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ccc701e7f3ac6e931dc31ba47231a06/" rel="bookmark">
			解决java.nio.file.AccessDeniedException: Permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决java.nio.file.AccessDeniedException: Permission denied 摘要引言正文1. 理解异常的根本原因2. 检查文件权限3. 处理文件被锁定4. 提升权限或更改文件所有者5. 异常处理 总结参考资料 博主 默语带您 Go to New World.
✍ 个人主页—— 默语 的博客👦🏻
《java 面试题大全》 🍩惟余辈才疏学浅，临摹之作或有不妥之处，还请读者海涵指正。☕🍭
《MYSQL从入门到精通》数据库是开发者必会基础之一~
🪁 吾期望此文有资助于尔，即使粗浅难及深广，亦备添少许微薄之助。苟未尽善尽美，敬请批评指正，以资改进。！💻⌨
🪁🍁 希望本文能够给您带来一定的帮助🌸文章粗浅，敬请批评指正！🍁🐥
如果你在Java编程中曾经遭遇过java.nio.file.AccessDeniedException: Permission denied异常，那么你一定知道这是一种令人头疼的问题。本文将深入研究这个异常的起因以及如何高效地解决它。我们将提供详尽的代码示例，以帮助你更好地理解和应对这一异常。此外，我们还会为你生成摘要、引言、正文、总结和参考资料，以确保你获得全面的信息。
摘要 在Java编程中，java.nio.file.AccessDeniedException: Permission denied异常通常表示你尝试执行一个文件或目录操作，但没有足够的权限来执行该操作。这可能导致程序中断或无法正常工作。在本文中，我们将深入探讨这个异常的各种原因，并提供解决方案，以帮助你避免和解决这个问题。
引言 Java是一种广泛使用的编程语言，但在处理文件和目录时，经常会遇到各种异常情况，其中之一就是java.nio.file.AccessDeniedException。这个异常表示你没有足够的权限来执行所需的文件或目录操作。这可能发生在文件读取、写入、删除等各种场景中。在接下来的内容中，我们将深入研究这个异常，分析它的常见原因，并提供解决方案，以确保你能够更加流畅地进行Java文件操作。
正文 1. 理解异常的根本原因 要解决java.nio.file.AccessDeniedException: Permission denied异常，首先需要了解它的根本原因。这个异常通常发生在尝试执行文件或目录操作时，但操作者没有足够的权限来执行这些操作。这可能是由于文件权限设置、操作系统限制或其他原因导致的。
2. 检查文件权限 一个常见的引发异常的原因是文件或目录的权限设置不正确。在进行文件操作之前，务必确保你有足够的权限来执行该操作。你可以使用操作系统的文件权限设置或Java的文件权限检查方法来验证权限是否足够。
javaCopy codePath filePath = Paths.get("example.txt"); try { Files.readAllLines(filePath); // 执行文件读取操作 } catch (AccessDeniedException e) { // 处理权限不足的情况 } 3. 处理文件被锁定 另一个可能导致异常的情况是文件被其他进程锁定。在这种情况下，你需要等待其他进程释放文件锁定或采取适当的措施来协调文件访问。
javaCopy codeFile file = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ccc701e7f3ac6e931dc31ba47231a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6049957f7d02375ab4f3f069014ce7/" rel="bookmark">
			MySQL优化第二篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL优化第二篇 性能分析小表驱动大表慢查询日志日志分析工具mysqldumpslow Show Profile进行SQL分析（重中之重） 七种JOIN
1、inner join ：可以简写为join，表示的是交集，也就是两张表的共同数据
sql语句：select * from tbl_emp e inner join tbl_dept d on e.deptId=d.id
2、left join （左外连接）：从集合上看就是A 、B 的交集加上A的私有，即左表的所有数据加上 左右表中相交的数据
sql 语句：select * from tbl_emp e left join tbl_dept d on e.deptId=d.id
前七条共有数据；第八条a表独有数据，b表补null
3、right join（右外连接，全B）：前七条共有数据；第八条b表独有数据，a表补null
4、左join独A：就是A表独有的部分，在left join的基础上加上where条件
sql语句：select * from tbl_emp e left join tbl_dept d on e.deptId=d.id where d.id is null
5、右join独B：就是B表的独有部分，同理可知在right join的基础上加上where条件
6、full join （全外连接）：MySQL不支持使用full join 如果想要实现全A+B可以使用union去重中间部分（union关键字可以合并 并且 去重）
sql语句：
select * from tbl_emp a left join tbl_dept b on a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6049957f7d02375ab4f3f069014ce7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d31f6ddc08806a8cea1f2e44d0426d61/" rel="bookmark">
			高通 Android 12 framework添加自定义按键上报应用层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android下添加新的自定义键值和按键处理流程
首先分析下Android下怎么添加新的自定义键值。在Android的原生系统中键值默认情况下是92个，从0-91；一般情况下，这些键值是够用的，但是如果想扩充的话，还是需要添加新的键值的，那么如何将一个新的键值从驱动的设置映射到上层，使应用可以对我们自定义的键值进行相应的处理呢？
在介绍Android怎么添加新的键值以前先介绍下Android下INPUT子系统FLOW的流程，下面就是精简的流程图示意图：
1.添加按键及其映射
1)如果系统有新的按键需要添加，是怎么添加并上报到系统上层去的呢(这里的上层主要指的是Android应用层)，首先要确定的是我们的遥控设备是通过/dev/input目录下那个event调用那个kl文件，这里可以通过如下命令查看cat /proc/bus/input/devices,下面是在Window终端下的打印信息
2)getevent -p得到以下数据信息 3）命令查看如下 通过getevent查看驱动调节的按键值是否上传ok。adb shell getevent 驱动上报O按键键值 如下图所示 0259是16进制数 对应10进制601 1，0: 是指按下和弹起的动作。
Kernel修改
2、在qssi11/LINUX/android/vendor/qcom/proprietary/devicetree-4.19/qcom/kona-pinctrl.dtsi 中增加相关内容[key]: 添加方向键（上、下、左、右）、X/O 键、确认键、主页键、菜单键
diff --git a/LINUX/android/vendor/qcom/proprietary/devicetree-4.19/qcom/kona-pinctrl.dtsi b/LINUX/android/vendor/qcom/proprietary/devicetree-4.19/qcom/kona-pinctrl.dtsi index a6398b6..9de20ea 100755 --- a/LINUX/android/vendor/qcom/proprietary/devicetree-4.19/qcom/kona-pinctrl.dtsi +++ b/LINUX/android/vendor/qcom/proprietary/devicetree-4.19/qcom/kona-pinctrl.dtsi @@ -148,6 +148,31 @@ }; }; */ + tlmm_gpio_key { + gpio_key_em_active: gpio_key_em_active { + mux { + pins = "gpio160", "gpio161", "gpio164", "gpio165", "gpio166", "gpio167", "gpio168", "gpio169"; + function = "gpio"; + }; + config { + pins = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d31f6ddc08806a8cea1f2e44d0426d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d771443cf47e8f7ec79b273070a1ca/" rel="bookmark">
			Android 12(S) IPV4优先IPV6(优先使用IPv4地址)的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据RFC 6724中 规定 android 会优先选择IPv6 地址而不是 IPv4 地址，当整个网络中，同时支持IPv4和IPv6 地址时，设备中的应用请求服务器DNS时，会优先返回IPv6地址。
假如IPv6服务器支持内容不够完善，则应用显示内容会与IPv4服务器不一致，甚至有问题。
因此有需求是定制设备平台，使得 IPV4优先IPV6，主要修改2个地方：
1. 当设备或平台连接网络时，原来是先请求ipv6地址，再请求ipv4地址，这样会使用应用会先拿到ipv6地址，所以需要调整顺序，让ipv4先请求dhcp地址，再请求ipv6。
2. DNS域名解析时，调整解析DNS的优先顺序，即先解析IPv4地址，再解析IPv6地址，注：android 12在DnsResolver代码中。
接下来对这2个修改点进行逐一修改并说明。
1. 当设备或平台连接网络时，原来是先请求ipv6地址，再请求ipv4地址，这样会使用应用会先拿到ipv6地址，所以需要调整顺序，让ipv4先请求dhcp地址，再请求ipv6。
文件：packages/modules/NetworkStack/src/android/net/ip/IpClient.java
修改差异如下：
--- a/modules/NetworkStack/src/android/net/ip/IpClient.java +++ b/modules/NetworkStack/src/android/net/ip/IpClient.java @@ -161,6 +161,8 @@ private final NetworkInformationShim mShim = NetworkInformationShimImpl.newInstance(); private final IpProvisioningMetrics mIpProvisioningMetrics = new IpProvisioningMetrics(); private final NetworkQuirkMetrics mNetworkQuirkMetrics; + //CN project let get ipv4 first and then ipv6, tiangui.tang @2023.9.7 //用于区别自定义code与AOSP + private final boolean bStartIPv6AfterIPv4 = true; /** * Dump all state machine and connectivity packet logs to the specified writer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51d771443cf47e8f7ec79b273070a1ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67244d066860e0de5404ecf16e97b072/" rel="bookmark">
			华为云云耀云服务器L实例评测 | 源码安装 Redis，进行远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、购买云耀云服务器L实例
1.1 选择云耀云服务器L实例配置
2.2 云耀云服务器L实例
二、下载 redis 安装包
三、编译源码
四、运行 Redis
五、设置开机自启动
六、远程连接Redis
6.1 安装 redis 客户端
6.2 远程连接
七、总结
最近使用了⌈云耀云服务器L实例⌋ 发现非常好用，⌈云耀云服务器L实例⌋ 智能不卡顿、价优随心用、上手更简单、管理特省心。本篇文章主要介绍如何使用⌈云耀云服务器L实例⌋ ，以及在⌈云耀云服务器L实例⌋ 中通过源码安装 Redis 数据库，设置开机自启动，并进行远程连接，赶紧来看下吧。
一、购买云耀云服务器L实例 1.1 选择云耀云服务器L实例配置 通过点击如下链接进入 ⌈云耀云服务器L实例⌋ 购买页面。
https://console.huaweicloud.com/smb/?region=cn-east-3&amp;locale=zh-cn#/create/hecs-light?period=month_1&amp;plan=basic_v1
页面如下所示。
这里区域和应用镜像都选择默认方式，当然，你可以根据自己的需要选择应用镜像以及系统镜像等。
如上所示，实例规格选择 2核|2G，当然，可以根据自己需要选择合适的配置，根据自己的需要选择不同的内存大小，2G、4G、8G 都有，也可以增加数据盘 EVS，开启主机安全HSS，开启云备份等。
如上所示，选择购买时长，选择好配置后，点击⌈立即购买⌋即可。
如上所示，需要勾选协议许可，再点击⌈去支付⌋，进入如下页面。
如上所示，显示具体的订单信息，选择华为云代金券，点击去在线支付。支付成功后进入如下界面。
2.2 云耀云服务器L实例 支付成功会进行创建⌈云耀云服务器L实例⌋ ，页面如下所示。
如上所示，显示 ⌈云耀云服务器L实例⌋ 创建完成，可以看到运行状态为运行中，可以点击远程登录进行登录。
点击远程登录右边 ... 显示续费、开通自动续费、重置密码、退订等操作。这里先重置下密码，登录后如下所示。
也可以通过 CloudShell 登录，如下所示。
进入后就可以在终端中进行操作了。
二、下载 redis 安装包 首先，需要到Redis官网去下载Redis源码包，点击进入官网，点击 Download 7.0.10 下载即可，如下图红框所示。
​
或者执行如下命令直接下载，如下所示。
​
上面可以看到下载速度非常快。下载完成后执行如下命令解压源码包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67244d066860e0de5404ecf16e97b072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f7327ba4acf5eb2303f9e2ecdd9f27/" rel="bookmark">
			Scikit-Learn快速生成分类数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如你学习了新的分类算法并想进一步探索研究、尝试不同的超参数评估模型性能，但问题是你找不到好的数据集用于实验。幸运的是Scikit-Learn 提供的 make_classification() 方法可以创建不同类型的数据集，它可以生成不同类型的数据集：二分类、多分类、平衡或不平衡数据集、难以分类的数据集等。本文通过示例详细说明，并结合随机森林分类算法进行验证。
make_classification函数 首先我们介绍该函数参数，以及常用参数及默认值：
n_samples: 生成多少条样本数据，缺省100条.n_features: 有几个数值类型特征，缺省为20.n_informative: 有用特征的个数，仅这些特征承载对分类信号.，缺省为2.n_classes: 分类标签的数量，缺省为2. 该函数返回包含函数Numpy 数组的tuple，分别为特征X，以及标签y。其他参数用到时再作说明。
生成二分类数据集 下面生成二分类数据集，即标签仅有两个可能的值：0 、1.
因此需要设置n_classes参数为2。我们需要生成1000条样本，包括5个特征，其中三个为有用特征，另外两个为冗余特征。
from sklearn.datasets import make_classification X, y = make_classification( n_samples=1000, # 1000 observations n_features=5, # 5 total features n_informative=3, # 3 'useful' features n_classes=2, # binary target/label random_state=999 # if you want the same results as mine ) 下面需转换 make_classification 函数返回值为 padas 数据框。padas 数据框比Numpy数组更易分析。
import pandas as pd # Create DataFrame with features as columns dataset = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f7327ba4acf5eb2303f9e2ecdd9f27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6303d42e84ea0254e2558ad26a72c5b/" rel="bookmark">
			数据结构与算法之分治法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.递归解决阶乘函数2.归并排序算法2.1 归并排序的概念2.2 分治法的三步曲2.3 归并排序的动画2.4 归并排序算法(C语言代码) 3.最大子序列和问题3.1 问题的定义3.2 分治的思路3.3 简单的分解下代码的结果3.4 算法代码3.5 测试结果 前言 分治法首先需要明白递归的概念:
递归： 是指子程序直接调用自己或者通过一系列调用语句间接调用自己，是一种描述问题和解决问题的常用方法。递归的两个基本要素：
1.边界条件:也就是递归终止调用的条件。
2.递归出口:递归表达式，大问题分解为小问题。
分治算法的一般有几个步骤：
分解 ：分析原来的问题，将原问题分解成一系列子问题。求解：递归求解各个子问题。若子问题足够小，则直接求解。合并：将子问题的解合并成原问题的解。 以下将分析几个典型例子。
1.递归解决阶乘函数 阶乘函数的定义大家都知道。
1）边界条件 n=0,n!=1
2) 递归体 n&gt;0,n!=n*(n-1)
C语言代码：
/** 1. 阶乘的算法 2. @param n 3. @return */ int Fac(int n){ if(n==0) return 1; else return n* Fac(n-1); } 2.归并排序算法 2.1 归并排序的概念 归并排序是将待排序的元素分成两个大致相同的两个子序列，分别对子序列进行排序，最终将排好序的子序列合并为排序的序列。
2.2 分治法的三步曲 大致分为以下几步：
分解。将n个元素分成n/2个元素的子序列。求解。用归并排序对两个子序列递归排序。合并。合并两个排序好的子序列得到排序结果。 2.3 归并排序的动画 2.4 归并排序算法(C语言代码) /** * 归并排序 * @param a 待排序的数组 * @param l 左边的 * @param r 右端 */ void MergeSort(int a[],int l, int r){ //计算分组的中间位置 int m; if (l &lt; r){ //计算中间的位置 m = (l+r)/2; //递归左边 MergeSort(a,l,m); //递归右边 MergeSort(a,m+1,r); //合并结果 Merge(a,l,m,r); } } /** * 合并排序的结果 * @param a * @param l * @param m * @param r */ void Merge(int a[], int l, int m, int r) { //左边的长度，定义右边的长度 int lLen=m-l+1 ,rLen=r-m; //定义临时数组存放左边的排序结果以及右边的排序结果 int L[50],R[50]; //取出左边的元素 for(int i=0 ; i &lt; lLen ; i++){ L[i]=a[l+i]; } //取出右边的元素 for(int j = 0 ; j &lt; rLen; j++){ R[j]=a[m+j+1]; } //很关键，这个值一定要设置为最大 L[lLen] = INT_MAX; R[rLen] = INT_MAX; //开始比较大小 int i=0,j=0; for(int k = l; k &lt; r+1 ; k++){ if(L[i] &lt; R[j]){ a[k]=L[i]; i++; }else{ a[k]=R[j]; j++; } } } 测试代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6303d42e84ea0254e2558ad26a72c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8d854c03668a5af780ffdb8adb81c1/" rel="bookmark">
			如何在arcgis中制作栅格动图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的： 直接在arcgis中制作按照时间变化的动图，此处是针对栅格类数据动态变化，还有矢量类动态变化图，可能本方法不适用，不知道，没验证。
方法： Data management tools→Raster→Mosaic dataset
过程：
一、创建镶嵌栅格数据集
二、设置参数及注意问题
步骤4及以后的方法均参考以下链接中的方法：
https://blog.csdn.net/solototoro/article/details/90896107
三、以上步骤完成之后会出现时间图标，设置好导出即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c2b27a302c26553da635daee6a2800/" rel="bookmark">
			openstack基础平台部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		openstack基础平台部署目录 OpenStack基础平台部署案例准备1.规划节点2.基础准备 案例实施1.环境配置(1)配置主机名(2)配置域名解析(3)关闭防火墙和Seinux(4)配置yum环境(5)划分分区 2.Openstack云平台部署(1)配置环境变量(2)部署OpenStack云平台基础环境(3)部署Mariadb数据库及Rabbit消息队列服务(4)部署Keystone服务(5)部署Glance服务(6)部署Nova服务(7)部署Neutron服务(8)部署Dashboard服务(9)部署Cinder服务(10)部署Swift服务 3.创建cirros云主机(1)上传镜像(2)创建网络(3)创建云主机类型(4)创建云主机(5)cirros虚拟机运行 OpenStack基础平台部署 案例准备 1.规划节点 IP主机名节点192.168.100.10Controller控制节点192.168.100.20Compute计算节点 2.基础准备 使用VMware创建两台云主机(使用Centos7.9镜像)，云主机类型为4cpu，8G内存，100G磁盘及20G临时磁盘；需要给云主机两个网络接口，网络接口1为外部网络，作为云主机通信和管理使用，网络接口2设置为内部网络，作为一个网卡设备。
案例实施 1.环境配置 (1)配置主机名 [root@localhost ~]# hostnamectl set-hostname controller [root@localhost ~]# bash bash [root@controller ~]# [root@localhost ~]# hostnamectl set-hostname compute [root@localhost ~]# bash [root@compute ~]# (2)配置域名解析 [root@controller ~]# cat /etc/hosts ... 192.168.100.10 controller 192.168.100.20 compute [root@compute ~]# cat /etc/hosts ... 192.168.100.10 controller 192.168.100.20 compute (3)关闭防火墙和Seinux controller和compute都关闭
[root@controller ~]# systemctl stop firewalld &amp;&amp; systemctl disable firewalld Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed symlink /etc/systemd/system/dbus-org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c2b27a302c26553da635daee6a2800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e64f4ef2804773254328202be3f19b/" rel="bookmark">
			使用域名的方式连接Elasticsearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置nginx location /elastic/ { rewrite ^/elastic/(.*)$ /$1 break; proxy_pass http://172.21.31.2:9200; proxy_read_timeout 300s; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; } 配置pom文件 &lt;elasticsearch-rest-high-level-client.version&gt;7.17.10&lt;/elasticsearch-rest-high-level-client.version&gt; &lt;elasticsearch.version&gt;7.17.10&lt;/elasticsearch.version&gt; &lt;!-- Elasticsearch REST High Level --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;${elasticsearch-rest-high-level-client.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;${elasticsearch.version}&lt;/version&gt; &lt;/dependency&gt; 配置文件 elasticsearch: host: 域名 prefix: 前缀 port: -1 protocol: http username: username password: password 创建RestHighLevelClient连接 import cn.hutool.extra.spring.SpringUtil; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpHost; import org.apache.http.auth.AuthScope; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09e64f4ef2804773254328202be3f19b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0aab0b6450bd654851ae23972700b71/" rel="bookmark">
			解决vscode编写go代码时提示过慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode的自动代码提示，发现太慢了，隔3，4秒才会出提示，所以换为Google推荐的 gopls来代替。
下载过程
方案一
打开 VS Code 的setting, 搜索 go.useLanguageServe, 并勾选上.
默认情况下, 会提示叫你reload，重新打开之后，右下角会自动弹出下载的框框，点击 install即可。
如果下载时间过长，不成功，可以看方案二
方案二
直接上 github 下载，下载下来 之后go install github.com/golang/tools/cmd/gopls 安装
方案三
go get golang.org/x/tools/gopls@latest，不需要加u
可以去github上看看文档是怎么说的
github
配置过程
在github文档里有提示 Use the VSCode-Go plugin, with the following configuration:
"go.useLanguageServer": true, "[go]": {"editor.snippetSuggestions": "none","editor.formatOnSave": true,"editor.codeActionsOnSave": {"source.organizeImports": true,} }, "gopls": {"usePlaceholders": true, // add parameter placeholders when completing a function// Experimental settings"completeUnimported": true, // autocomplete unimported packages"watchFileChanges": true, // watch file changes outside of the editor"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0aab0b6450bd654851ae23972700b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a977f4aec4b40d8e78f09cbe7277eea6/" rel="bookmark">
			处理字符串公式转换为数学公式计算得到结果---无任何依赖版本----使用栈完成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理字符串公式转换为数学公式计算得到结果： 如何将字符串转换为数学公式？
1. 需要引入依赖 **JEP (Java Math Expression Parser)**库：EP 是一个功能强大的Java库，用于解析和计算数学表达式。它支持变量、函数、常量等，并且可以处理各种数学运算。你可以通过 JEP 将字符串转换为数学表达式，然后计算其值。
import org.lsmp.djep.djep.DJep; import org.nfunk.jep.Node; public class MathParser { public static void main(String[] args) throws Exception { DJep jep = new DJep(); jep.addStandardFunctions(); jep.addStandardConstants(); jep.addVariable("x", 10.0); // 设置变量的值 String expression = "2*x + sin(x)"; Node node = jep.parse(expression); double result = (Double)jep.evaluate(node); System.out.println("Result: " + result); } } Apache Commons Math：Apache Commons Math库也提供了一些数学表达式解析的功能。它支持不同的数学函数和运算，可以将字符串转换为数学表达式并进行计算。
Apache Commons Math库的使用示例：
import org.apache.commons.math3.analysis.function.Sin; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a977f4aec4b40d8e78f09cbe7277eea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907c7ef0d9a6869417a9a6882bd54487/" rel="bookmark">
			【Vue】实现当前页面刷新的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言方法一：location.reload方法二：$router.go(0)方法三：provide、inject和$nextTick方法四：创建空白页 前言 这两周在写一个后台管理，每次调用接口实现增删改查的过程中，都需要刷新当前页面或者刷新数据。如果手动点击浏览器的小圈圈不仅麻烦、用户体验感极差，而且不会真的有人让用户手动刷新叭。。。这个问题可以称得上是前端的bug了。那么，顺着这个问题，一通搜寻下来，整理了几个刷新当前页面的方法，如下：
方法一：location.reload 学习JS的过程中，大家应该都了解过Browser 对象，其中Location 对象是 window 对象的一部分。Location 对象中有一个方法，也就是reload()方法，用于刷新当前文档，类似于浏览器上的刷新页面按钮。
代码测试：
&lt;template&gt; &lt;div class="hello"&gt; &lt;img src="../imgs/01.jpg" alt="" /&gt; &lt;button @click="refresh"&gt;点击刷新页面&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "HelloWorld", methods: { refresh() { location.reload(); }, }, }; &lt;/script&gt; &lt;style scoped&gt; .hello img { width: 800px; display: block; margin-bottom: 20px; } &lt;/style&gt; 效果展示：
缺点： 想必大家都能看出来了叭，一闪一闪亮晶晶~
方法二：$router.go(0) 这种方法大家应该比较熟悉了，学过vue路由跳转的都知道$router.go()的作用：
&gt; this.$router.go(-1)：后退+刷新； &gt; this.$router.go(0)：刷新； &gt; this.$router.go(n) ：前进n个页面 这个方法等同于上面的location.reload，也是利用浏览器的刷新功能，疯狂按F5刷新。。。
代码测试：
&lt;template&gt; &lt;div class="hello"&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/907c7ef0d9a6869417a9a6882bd54487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74610c7e793446f954648777a0969a9d/" rel="bookmark">
			uniapp h5 echarts 打包后图表点击失效/及其他失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 期望效果实际效果环境引入echarts方式解决方法：注意 原因多说一句在h5打包的时候将 history 改为 hash 不然在浏览器打开后刷新会404 期望效果 实际效果 环境 pc端 window11
hbuilderx版本 3.8.12
echarts版本 5.4.3
引入echarts方式 npm install echarts 解决方法： 在main.js 加上
window.wx = undefined 注意 window.wx = {} // 开发正常 打包后 图表点击等也会失效
window.wx = null 会报错
原因 打包后自动检测环境，会优先走到 wx里去。进去就不出来了。拉都拉不出来那种。所以重写一下wx
多说一句在h5打包的时候将 history 改为 hash 不然在浏览器打开后刷新会404 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a704e667a058635888a1342f5b97ba9/" rel="bookmark">
			python能开发app吗？python开发的App有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人对于python开发的软件的印象都只有它能用来开发网站，编写爬虫程序等。那么python能不能开发手机上的App呢，使用python开发的App有哪些呢？
一、Python能开发App吗
python可以开发App，但是对于安卓平台来说，并不原生支持python进行开发。这时候就需要用到其他的中间件或者库来进行开发了。
1.kivy开源框架：kivy是一个跨平台的python开发框架，使用python进行编写。提供了对于多点触控的支持，支持代码重用和部署，还可以使用项目打包工具buildozer将python代码打包成各个平台可执行的程序。
2.使用PythonForAndroid、CLE、Wrapandroid三个组件搭建一个可以在安卓平台上使用python开发界面的应用程序，提供了一个交互的通用接口，还可以调用安卓的类使用。
二、使用Python开发的app
（1）Uber：优步的名称大家应该都不陌生，前段时间还进入了国内和滴滴竞争的如火如荼。它在国外的行业位置就等于是国内的滴滴，它的app程序是用python开发的。
（2）Spotify：一款提供声乐服务的音乐流服务软件，是目前全球最大音乐流服务商Sweden推出的软件。常听欧美音乐的小伙伴应该对此很熟悉，它也是用python开发的。
（3）Instagram：国外最大的在线图片及视频分享社交应用软件，功能基本上等同于微博，它的关键功能和逻辑处理是使用python完成的。
以上就是python能开发app吗，python开发的app有哪些的全部内容了，希望对你有所帮助。
关于Python技术储备
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
三、Python视频合集
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
四、实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、Python练习题
检查学习结果。
六、面试资料
我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
最后祝大家天天进步！！
上面这份完整版的Python全套学习资料已经上传至CSDN官方，朋友如果需要可以直接微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/119cc77aae132917cbf24db0ef673125/" rel="bookmark">
			YOLOv5/v7/v8 的改进点合集导航页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目地址：Yolov5_Magic
分享一些改进YOLO系列算法的技巧，不同的数据集效果肯定是不同的，有算力的话还是要多尝试。
🌟想了解YOLO系列算法更多教程欢迎订阅我的专栏🌟 对于基础薄弱的同学来说，推荐阅读《目标检测蓝皮书》📘，里面涵盖了丰富的目标检测实用知识，是你迅速掌握目标检测的理想选择！
如果想了解 YOLOv5 和 YOLOv7 系列算法的训练和改进，可以关注专栏《YOLOv5/v7 改进实战》🌟。该专栏涵盖了丰富的YOLO实用教程，专门为改进YOLO的同学而设计。该专栏阅读量已经突破60w+🚀，被誉为全网最经典的教程！所有的改进方法都提供了详细的手把手教学！
《YOLOv5/v7 进阶实战》🏅专栏是在《YOLOv5/v7 改进实战》🌟专栏上进一步推出的更加有难度的专栏，除大量的最新最前沿改进外，还包含多种手把手的部署压缩教程，内容不仅可以用于小论文，也可用于大论文！
想了解 YOLOv8 系列算法教程的同学可以关注这个专栏《YOLOv8改进实战》🍀，这个专栏为博主精心设计的最新专栏，随 YOLOv8 官方项目实时更新，内容以最新最前沿的改进为主，专栏内容包含【检测】【分类】【分割】【关键点】任务！
YOLOv5/v7改进实战 手把手带你调参YOLOv5 (v5.0-v7.0)（推理）🌟强烈推荐
手把手带你调参YOLOv5 (v5.0-v7.0)（训练）🚀
手把手带你调参YOLOv5 (v5.0-v7.0)（验证）
简单三步 用YOLOv5快速训练自己的数据集
YOLOv5/v7 数据增强方式解析
手把手带你YOLOv5/v7 (v5.0-v7.0)添加注意力机制(一)（并附上30多种顶会Attention原理图）🌟
手把手带你YOLOv5/v7 (v5.0-v7.0)添加注意力机制(二)（在C3模块中加入注意力机制）
YOLOv5/v7 如何更换激活函数？
YOLOv5 如何更换BiFPN? YOLOv7 如何更换BiFPN?
YOLOv5/v7 更换上采样方式( 最近邻 / 双线性 / 双立方 / 三线性 / 转置卷积)
YOLOv5/v7 应用轻量级通用上采样算子CARAFE
空间金字塔池化改进 SPP / SPPF / SimSPPF / ASPP / RFB / SPPCSPC / SPPFCSPC🚀
改进YOLOv5/v7 | 用于低分辨率图像和小物体的模块SPD-Conv
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/119cc77aae132917cbf24db0ef673125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a2f8ef8349c5df1ebe68b38449dfb2/" rel="bookmark">
			HTML实现移动端布局与页面自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们所说的布局方式，这里我们通常指的是width和height在不同页面情况下面的改变。 常见页面的布局方式有 静态布局 （px布局，就是固定其高宽，不论页面怎样放大缩小，其占领的依旧是，使用px固定了的高宽）流式布局（Liquid Layout） 主要的划分区域的尺寸使用百分数（100%）（搭配min-*、max-*属性使用）自适应布局（Adaptive Layout-媒体查询布局） 即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围响应式布局（Responsive Layout） 检测窗口大小利用bootstrap布局弹性布局（rem/em布局）css3 rem 一、静态布局（Static Layout） 即传统Web设计，网页上的所有元素的尺寸一律使用px作为单位。
1- 布局特点如下：
不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见与pc端。
2-设计方法：
（1）PC端：固定了网页的宽高大小，不管在那个浏览器上，显示的都是开发人员在css中写的大小，当页面窗口变小时，遮住的部分，会通过滚动条的滚动显示出来，使用横向和竖向的滚动条来查阅被遮掩部分；。
（2）移动端的静态布局：另外建立网站，单独设计一个布局，使用不同的域名。
这里我们移动端的静态布局主要有两种方式：【流式布局；响应式布局】
1.在viewport meta标签上设置width = 320，页面的各个元素也采用px作为单位，通过js动态修改标签的initial-scale使得页面整体等缩放，从而刚好占满整个屏幕
2.在viewport meta标签上设置content“width=640，user-scalable=no”，页面的各个元素也采用px作为单位，由于640px超出了手机宽度，浏览器会自动缩小到页面全屏
优点：这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。 缺点：显而易见，即不能根据用户的屏幕尺寸做出不同的表现。 当前，大部分门户网站、大部分企业的PC宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。
二、流式布局（Liquid Layout） 流式布局的特点，就是页面元素的宽度按照屏幕分辨率进行适度的调整，但整体布局不变，主要就是对页面的主要区域的尺寸使用百分数，使用百分比；代表作栅栏系统（网格系统）。
网页中主要的划分区域的尺寸使用百分数（搭配min-*、max-*属性使用），例如，设置网页主体的宽度为80%，min-width为960px。图片也作类似处理（width:100%, max-width一般设定为图片本身的尺寸，防止被拉伸而失真）。
1、布局特点：屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示】
2、设计方法：使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。
这种布局方式在Web前端开发的早期历史上，用来应对不同尺寸的PC屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式，但缺点明显：主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。
也就是通过对宽度一百分的形式展现，这样在不同的屏幕分辨下就可以实现，就可以用过实现布局的大小改变。
三、自适应布局 自适应的特点是分别为不同的屏幕分辨率定义布局，及创建多个静态布局，每个静态布局都对应一个屏幕分辨率，也就在屏幕宽度不同的时候，为其展现对应的静态布局，这样页面的元素不随着窗口大小的改变，而是改变其所处的位置。
就是左列固定，右边自适应，或者左右固定中间自适应，使用float：left方法，计算没有固定的宽高时，使用calc（）计算
1、布局特点：屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。
2、设计方法：使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。
随着CSS3出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出令人满意的效果，对CSS编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。
四、响应式布局（Responsive Layout））【也叫媒体查询布局】 响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出令人满意的效果，对CSS编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。
响应式几乎已经成为优秀页面布局的标准。
1、布局特点：每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。
2、设计方法：媒体查询+流式布局。通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。
优点：适应pc和移动端，如果足够耐心，效果完美
缺点：（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。
栗子：以下试举一段相关的CSS媒体查询代码
html { font-size : 20px; } @media only screen and (min-width: 401px){ html { font-size: 25px !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3a2f8ef8349c5df1ebe68b38449dfb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cafec73cc2b417bd4f807be0ca502b1/" rel="bookmark">
			信号与系统复习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考视频慕课《信号与线性系统分析》 吴大正 郭宝龙
1.1 信号的基本概念和分类 分类1
1.确定信号：可以用确定时间函数表示的信号
2.随机信号：不可以用确定函数表示，一般都是使用其统计特征进行研究
分类2 连续信号–离散信号
分类3 周期信号与非周期信号
在一定区间内，每隔一定时间T（整数N），按相同规律重复便的信号为周期信号，不满足条件的称为非周期信号
角频率的分类
模拟角频率Ω=2πf，过去我们常将ω作为模拟角频率，写成cos(ωt)，这种写法实际上是不正确的，应该写成cos(Ωt)来描述模拟余弦函数。此时Ω的取值也是从0到∞，这体现出模拟（角）频率没有周期性的特点。
数字角频率ω则是完全颠覆了我们过往对于频率的认识，首先要明确的是数字信号的获得是通过对模拟信号采样的方式。它的引入可以从cos(Ωt)开始。cos(Ωt)中相位变化一个周期(2π)所需的时间为T，那么模拟角频率定义成Ω=2π/T。对于该余弦信号，采样之后变成了一个离散的数字序列，此时再谈论过了多少时间走完一个周期已经没有意义，而是过了间隔N相位刚好变化一个周期。因此数字角频率推导出为ω=2π/N，余弦信号则为cos(ωn)。既然N是由对应一段时间T采样而来，那么N=T*Fs (Fs为采样率)，自然而然，ω=Ω/Fs。简单来说，数字角频率ω是模拟角频率Ω对于采样率Fs的归一化，这是数字角频率ω的核心要义
分类4 能量信号与功率信号
分类5 因果与反因果
信号发生之后都有信号，发生之前无信号为因果信号。反之为反因果信号
1.2 基本信号 信号与系统的3个基本问题
1、基本信号与基本响应
2、任意信号的分析
3、LTI系统的分析
1.2.1 阶跃函数 积分为斜坡函数
1.2.2 冲激函数 阶跃函数求导为冲激函数，冲激函数有取样特性
现实中可以用以下两种函数实现冲激函数的效果
例如:
1.2.2.1 冲激偶 从冲激函数的一种定义方式去看，冲激偶呈现的是一种正负都有冲激的情况，冲激偶的积分自然是0；从奇偶函数去看，冲激函数为偶函数，导数自然为奇函数，奇函数在对称区间求积分为0.
冲激偶拓展到高阶
1.2.2.2 冲激函数的尺度变换 1.2.3 单位脉冲序列 1.2.4 单位阶跃序列 1.3 系统 状态：输出是由输入和系统状态（代表了系统过去的情况）决定的
1.3.1 线性系统与非线性系统 举例：
1.3.2 时变系统与时不变系统 记住：输入延迟的情况与零状态响应一样才可以，先分开看在进行比较，输入输出关系中有变量的都是时变的。
1.3.3 LTI系统 1.3.4 因果与非因果系统 下面这个例题用到了线性时不变系统的基本性质
2.1 LTI连续系统的响应—微分方程的模拟框图 整个框图是不变的，但是根据输入输出的不同，中间的所写的函数可以变动，具体需要看输入输出
几个基本框图表示：积分器，数乘器，相加器
直接画整个系统的话框图中会出现3个积分器，系统是二阶的并不符合要求，所以用辅助函数去代替表达y(t)
2.2 零输入与零状态响应 2.2.1 系统的初始值 需要根据初始值和初始状态求出响应
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cafec73cc2b417bd4f807be0ca502b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fd85d7574710daef4fe21efb60711c/" rel="bookmark">
			mysql分组排序取第一条数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： mysql 根据某一个字段分组，然后组内排序，最后每组取排序后的第一条数据
1. 先使用（分组字段+排序字段）排序 相当于实现了分组和排序，只是没有根据分组字段聚合，此时每个分组的第一条数据就是我们需要的目标数据。
2. 再按分组字段分组，取第一条即可 实例如下：
with t_picture as( SELECT npi_product_id,is_default_one,update_time, uri FROM datahub_product_attachment where type=1 ORDER BY npi_product_id,is_default_one DESC,update_time DESC ) SELECT npi_product_id, (ARRAY_AGG(uri))[1] as uri FROM t_picture group by npi_product_id 必须在分组前排序，分组后排序是对分组字段和聚合字段排序。
3. postgreSQL 现成函数 row_number() over(partition by field_1,field_2 order by field_a desc,field_b desc )
此函数会根据 partition by 后字段分组，再根据 order by 后字段进行组内排序，最后，生成一个排序字段，实列如下：
with t_marked as( select row_number() over(partition by dpa.npi_product_id order by dpa.is_default_one desc,dpa.update_time desc ) as group_idx ,dpa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fd85d7574710daef4fe21efb60711c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea21bf443e2a1c30ccf1f54f4aa43d4/" rel="bookmark">
			unity入门学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇以unity官方课堂教程为参照，主要以2D游戏开发并分享自己的经验。
我自己使用的编译器版本为：2021.3.27f1c2
本篇文章不会专门去写关于unity基本界面的介绍和编程语法上，而是重点在组件和应用上。
Ruby's Adventure: 2D 本篇文章依据此处来说下自己的学习心得
https://learn.u3d.cn/tutorial/unity-ruby-adventure
根据要求在Asset Store下载相关资源包，然后就让我们开始吧！
下载好资源包后将人物角色图片拖入到Hierachy目录中，就可以发现我们的任务出现在Scene视图中了。
可通过拉伸来确定合适的大小，这里就不多说明了。
此时我们可以看到右边的组件栏好像多出来了什么东西。
Transform组件 在Transform组件中有Position、Rotation、Scale这三个属性。（这是最基础且不可隐藏的组件）
Position：表示现在人物的位置。X(水平)、Y(垂直)、Z(深度)。这个游戏是2D游戏所以Z轴为0。
Rotation：表示人物的旋转方向。XYZ分别表示方向上的旋转。
Scale：表示人物大小的缩放。可以向不同方向进行拉伸。
OK！我们先了解这一个组件，开始写脚本吧，编译器，启动！
在Project中创建一个文件夹，命名为Scripts（要养成好习惯！），之后进入该文件夹，创建一个C# Script的脚本。
启动脚本的时候我们的编译器将会被打开，我们先把目光放到两个函数上面。
Start函数与Update函数 Start函数：Unity仅在游戏开始的时候执行一次Start函数中的代码。
Update函数：Unity在每帧执行Update函数的代码。Update函数可以编写游戏中连续发生的操作（例如读取玩家的输入，移动游戏对象或者计算经过的时间。）
刚好我们现在想让我们的人物随着时间发生移动，那我们根据上面的组件看，与位置相关的一个组件是Position，我们想可以不可以通过改变Position的XYZ三个参数来实现角色的移动。
试试就逝世。对比两个函数，我们应该在Update函数中写入代码。
void Update() { Vector2 position = transform.position; position.x = position.x + 0.1f; transform.position = position; } 我们对游戏对象运动的代码就写出来了，在这里我们的思路：
声明一个变量来存储Position的XY轴的参数。对变量中的一个坐标轴进行修改。将改变后的变量传回到Position之中。 Vector2变量 我们可以看到在代码中出现Vector2的关键字，这个是一个数据类型，不同的数据类型用来存放不同的数据，Vector2是存储两个数字的数据类型，因为此游戏为2D游戏，所以我们不需要储存Z轴的位置信息，移动游戏对象的第二行代码我们加上了0.1f表示0.1个单位，这样每一帧都会向右移动0.1个单位（正值游戏对象将向右移动，负值则向左）。
在这里我们可以注意到，我们可以直接使用Transform组件，并且这个组件是可视化的，在之后的添加其他组件中也可以直接使用，大大方便了我们游戏的制作。
最后我们将编写的脚本直接拖拽到游戏对象的Inspector之中。
此时我们可以注意到在最下面多出来我们的脚本组件，表示脚本添加完毕，此时我们让Unity运行我们的程序吧！
不好！被我们放入脚本的角色瞬间飞出这个屏幕，虽然是实现了物体的移动，但是怎么感觉怪怪的。由于是每帧移动0.1个单位，在游戏中通常在一秒内就移动了30-60帧，所以才会移动得很快。
但是在游戏中我们通常需要自己去操控角色，所以我们要重新修改我们的代码了。
角色控制器和键盘输入 为了实现对角色的控制，我们将使用Unity输入系统。该系统包含输入设置和输入代码
查看默认输入设置，这些设置可以定义游戏中的输入类型。
找到Edit &gt; Project Setting，然后选择Setting窗口中Input Manager页面 Input 页面列出所有玩家输入控件（例如，游戏手柄上的一个按键）的 Axes 值。值的范围从 -1 到 1（具体值取决于玩家执行的操作）。例如，对于游戏手柄上的控制杆，可以将水平轴设置为：
-1（控制杆在左侧时）0（控制杆在中间时）1（控制杆在右侧时） 对于键盘按键，以 2 个键来定义轴：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea21bf443e2a1c30ccf1f54f4aa43d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f07f04d302977c2ffc1ddf2b610afa0/" rel="bookmark">
			Java 文件 &amp; 文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 文件 &amp; 文件操作 一、文件重要概念1、文件概述2、文件元信息3、文件的系统管理4、文件路径5、文本文件和二进制文件6、快捷方式 二、文件操作1、文件系统操作2、文件IO（1）InputStream（2）InputStream 搭配 Scanner 使用（3）OutputStream（4）字符流 Reader &amp; Writer 三、文件操作小项目：查找指定文件 一、文件重要概念 1、文件概述 针对硬盘这种持久化存储的I/O设备，当我们想要进行数据保存时，往往不是保存成一个整体，而是独立成一个个的单位进行保存，这个独立的单位就被抽象成文件的概念，就类似办公桌上的一份份真实的文件一般。
2、文件元信息 文件除了有数据内容之外，还有一部分信息，例如文件名、文件类型、文件大小等并不作为文件的数据而存在，我们把这部分信息可以视为文件的元信息。
3、文件的系统管理 随着文件越来越多，对文件的系统管理也被提上了日程，如何进行文件的组织呢，一种合乎自然的想法出现了，就是按照层级结构进行组织 —— 也就是我们学习过的树形结构。这样，一种专门用来存放管理信息的特殊文件诞生了，也就是我们平时所谓文件夹(folder)或者目录(directory)的概念。这里提到的的管理信息一般指文件的元信息。通过一个个的目录/文件夹，我们就可以将文件组织起来，从而更方便的使用了。
4、文件路径 文件路径是用来定位文件系统中文件的，主要分为绝对路径和相对路径。实际表示路径是通过一个字符串来表示，每个目录之间用斜杠-/或反斜杠-\来分割（-反斜杠只是在Windows中适用，代码中要写成\，所以一般建议适用斜杠-/进行分割）
绝对路径：指的是文件系统上一个文件的具体位置，从盘符开始，一层一层往下找，这个过程中得到的路径就是绝对路径。
相对路径：从给定的某个基准目录出发，一层一层往下找，这个过程中得到的路径就是相对路径。在表示相对路径中，需要明确的是基准目录是什么。
相比之下，绝对路径，可以理解成是以“此电脑”为工作路径的相对路径。
📝举个例子：
上面我们提到，计算机的目录是有层级结构的，是以 N 叉树的结构来组织的，Windows一般都是从“此电脑”开始，所以表示绝对路径的时候可以把“此电脑”省略，直接从盘幅（A、B、C……）开始表示。例如上图绝对路径C:\Program Files\Java 就表示从 C 盘出发 --&gt;ProgramFiles --&gt;Java 的绝对路径。如果从C:\Program Files\Java目录出发到 jdk1.8.0_192，相对路径可以表示为：./jdk1.8.0_192
注意：.在相对路径中，是一个特殊符号，表示当前目录。..在相对路径中表示当前目录的上机目录。
5、文本文件和二进制文件 文本文件：是基于字符编码的文件，一般采用定长编码方式，比如 ASCII 编码、UNICODE 编码。其中 ASCII编码采用 8 个特定的比特来表示每一个字符，而 UNICODE 编码采用 16 比特。文件里存储的数据需要遵守编码标准。
二进制文件：直接由二进制数字0和1组成，不存在统一的字符编码，也就是说由你来决定多少个比特表示一个什么值，你可以根据具体的应用来指定这些比特的含义，类似于自定义编码，而且是不定长度的编码。文件内容没有字符集的限制，可以存任何数据。
Tips: 如何判定一个文件是文本文件还是二进制文件？
简单粗暴的方式：用记事本打开某个文件，如果内容能看得懂，就是文本文件，反之是二进制文件。
6、快捷方式 Windows 操作系统上，还有一类文件比较特殊，就是平时我们看到的快捷方式（shortcut），这种文件只是对真实文件的一种引用而已。其他操作系统上也有类似的概念，例如，软链接（soft link）等。
二、文件操作 文件操作主要分为以下两部分：
文件系统操作：创建文件、删除文件、重命名文件、创建目录等操作。文件内容操作：针对文件内容进行IO操作（读和写）。下面将分别进行展开。 1、文件系统操作 文件是存储在硬盘上的，如果想要操作文件，需要通过在内存中创建一个对应的对象，通过操作这个对象可以间接影响到硬盘上的文件。Java 中通过 java.io.File 类来对一个文件（包括目录）进行抽象的描述。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f07f04d302977c2ffc1ddf2b610afa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d747afd9604e74e9690617b60a22142/" rel="bookmark">
			SSH连接调试：逐行解读SSH -vvv的输出信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 SSH是我们在远程连接服务器时经常使用的协议。ssh -vvv命令能提供大量的调试信息，帮助我们理解SSH连接过程中到底发生了什么。但是，这些信息常常让人感到困惑。在这篇博文中，我们将一步一步地解读ssh -vvv输出的日志信息。
示例信息： ssh -vvv user@10.0.0.1 OpenSSH_8.2p1, OpenSSL 1.1.1f 31 Mar 2020 debug1: Reading configuration data /etc/ssh/ssh_config debug3: /etc/ssh/ssh_config line 51: Including file /etc/ssh/ssh_config.d/05-redhat.conf depth 0 debug1: Reading configuration data /etc/ssh/ssh_config.d/05-redhat.conf debug2: checking match for 'final all' host 10.0.0.1 originally 10.0.0.1 debug3: /etc/ssh/ssh_config.d/05-redhat.conf line 3: not matched 'final' debug2: match not found debug3: /etc/ssh/ssh_config.d/05-redhat.conf line 5: Including file /etc/crypto-policies/back-ends/openssh.config depth 1 (parse only) debug1: Reading configuration data /etc/crypto-policies/back-ends/openssh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d747afd9604e74e9690617b60a22142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96bde813522bc37b708c0aeec1d3eb5/" rel="bookmark">
			Welcome to emergency mode! centOS7服务器重启后进入紧急模式解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、踩坑 物理机手动重启，进入紧急模式：
输入root密码，进入后先是发现网络断了，于是启动网络，结果又退回了紧急模式的界面，重新登入，结果网络还是断的：
查看报错，polkit服务没有启动，于是尝试启动polkit服务：
查看polkit服务状态inactive，没有启动成功：
网上搜了一下，说要重新安装一下polkit服务yum reinstall polkit结果又绕回了没有网络上。
紧接着按照网上教的方法，输入命令​lsmod | grep i2c​​得到两个以i2c开头的文件，​vi /etc/modprobe.d/blacklist.conf​创建文件（该文件本身不存在），在该文件中加入两行：
blacklist i2c_xxx1 blacklist i2c_xxx2 保存reboot，没有解决。
登入，查看linux版本：
拿着去请教了大神，大神让进入修复模式执行mount -o remount,rw /等命令，仍然没法修复。
二、问题突破口 于是再次reboot之后，登入，journalctl -xb 查看日志：
发现是/home目录没有挂载成功。
三、解决 Contos7进入紧急模式 Failed to mount /home
# 备份fstab自动挂载文件 cd /etc cp ./fstab ./fstab_bak vi fstab # 将/home那行注释掉： #/dev/mapper/centos-home /home xfs efaults 0 0 vi /etc/sysctl.conf # 在sysctl.conf中加入以下两行： vm.dirty_background_ratio = 5 vm.dirty_ratio = 10 # 保存 reboot # 查看到/home 是 -a ，说明是激活状态 lvs -a -o +devices # 修复 xfs_repair /dev/mapper/centos-home # 然后报错，因为/home下面是空的，想先备份，但是无法识别，于是直接强制修复 xfs_repair -L /dev/mapper/centos-home # 修复完成，将自动挂载重新开启 cd /etc mv fstab fstab_bak_home mv fstab_bak fstab reboot # 重启之后，cd /home看到正常了 四、文件系统备份 因为/home目录放了比较重要的文件，差点就重装系统了，所以打算备份一下文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c96bde813522bc37b708c0aeec1d3eb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32abb7495034deda52d4dd9b73c96eca/" rel="bookmark">
			MySQL 在线模式迁移工具gh-ost用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gh-ost 是 GitHub 开源的一款 MySQL 在线模式迁移工具。它允许你在数据库仍在运行并处理事务的同时，执行非阻塞的 ALTER TABLE 操作。
以下是 gh-ost 的基本用法：
首先，安装 gh-ost。你可以从 GitHub Release 页面 下载最新版本的二进制文件，或者如果你有 Go 环境，你也可以使用 go get 来安装：
go get github.com/github/gh-ost 然后，你可以使用 gh-ost 命令来进行在线模式迁移。以下是一个基本的示例：
gh-ost \ --max-load=Threads_running=25 \ --critical-load=Threads_running=1000 \ --chunk-size=1000 \ --throttle-control-replicas="mysql1,mysql2" \ --max-lag-millis=1500 \ --user="db_user" \ --password="db_password" \ --host=localhost \ --database="my_database" \ --table="my_table" \ --verbose \ --alter="ADD COLUMN my_column TIMESTAMP NOT NULL" \ --execute 在这个例子中，我们对 "my_table" 表添加了一个新的列 "my_column"。参数 --max-load 和 --critical-load 用于控制负载阈值，在超过设定阈值时会暂停和停止迁移操作。--chunk-size 控制每次复制的行数。--throttle-control-replicas 列出了用于监控复制延迟的从库。--max-lag-millis 设置了允许的最大复制延迟。--alter 指定了要执行的 ALTER TABLE 语句。最后，--execute 表示开始执行迁移。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32abb7495034deda52d4dd9b73c96eca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6f40c865489ae5055ef749f2b18a42/" rel="bookmark">
			适合小白ctfshow-web入门—sql注入175-248超详细解析！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web 175 将数据输出到一个文件中，然后访问对应文件
-1' union select username,password from ctfshow_user5 into outfile "/var/www/html/1.txt"--+ 1）union select username, password from ctfshow_user5: 这是一个UNION查询，它将原始查询的结果与从表 ctfshow_user5 中选择的用户名和密码进行合并。
2）into outfile "/var/www/html/1.txt": 这部分似乎是将查询结果导出到文件。路径 /var/www/html/1.txt 表示要将查询结果写入到位于网页根目录下的名为 1.txt 的文件中。
（路径 /var/www/html/ 是一个常见的用于存放网页文件的目录，通常被称为网页根目录。在许多Web服务器中，这个目录被设置为存放网站的主要文件，因此可以通过浏览器访问。）
web176 过滤了select，通过大小写即可绕过 1'union sElect 1,2,group_concat(password) from ctfshow_user--+
解法二 万能密码：
1' or 1=1--+ web 177——/**/绕过空格 解法一：万能密码 1'or/**/1=1%23
解法二：正常查询 1'/**/union/**/select/**/1,2,password/**/from/**/ctfshow_user/**/where/**/username='flag'%23
%23: 这是URL编码中表示字符 # 的方式。在SQL查询中，%23 后的内容将被视为注释，从而忽略后续的内容。这种写法可能是为了防止后续内容被执行。 web 178 解法一 过滤了空格与*号等用%09绕过
1'%09union%09select%091,2,3%23
之后一把梭得到flag 1'%09union%09select%091,2,password%09from%09ctfshow_user%23
%09 是URL编码中表示水平制表符（Tab键）的方式。URL编码是一种将特殊字符转换为URL安全格式的方法，以便在URL中传输这些字符而不会造成歧义或错误。
%09 被用来表示水平制表符。在SQL注入攻击中，攻击者有时会使用各种编码方式来试图绕过输入过滤或检测，从而执行恶意操作。在这个特定的查询中，使用 %09 作为空格的替代，可能是为了试图混淆代码，使得检测和防御机制更难识别和阻止注入攻击。
解法二 id=1'or'1'='1'%23 web179 解法一 一句话梭哈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d6f40c865489ae5055ef749f2b18a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43791500e49b6895306add2f3840699d/" rel="bookmark">
			AI项目六：基于YOLOV5的CPU版本部署openvino
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若该文为原创文章，转载请注明原文出处。
一、CPU版本DEMO测试 1、创建一个新的虚拟环境 conda create -n course_torch_openvino python=3.8 2、激活环境 conda activate course_torch_openvino 3、安装pytorch cpu版本 pip install torch torchvision torchaudio -i https://pypi.tuna.tsinghua.edu.cn/simple 4、安装 使用的是yolov5-5版本，github上下载。
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 5、运行demo python demo.py 完整代码 import cv2 import numpy as np import torch import time # model = torch.hub.load('./yolov5', 'custom', path='./weights/ppe_yolo_n.pt',source='local') # local repo model = torch.hub.load('./yolov5', 'custom', 'weights/poker_n.pt',source='local') model.conf = 0.4 cap = cv2.VideoCapture(0) fps_time = time.time() while True: ret,frame = cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43791500e49b6895306add2f3840699d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971abcf109b34b0d94b79b3e637f2fa9/" rel="bookmark">
			获取阿里云OSS图片url的InputStream输入流403
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做百度ocr图片识别的需求，需要把oss中图片的url转成base64后调用百度ocr的接口，在url转换base64中报错403，发现有些图片正常，有些不正常;在debug中发现postmain传的url和后端接收到的url不一致，是在传输过url自动转义了，经过转义后可能会把oss url上的秘钥解析错误。所以将url反编译后不在报403
public static String urlEncoder(String urlPath){ // 解码URL try { String[] parts = urlPath.split("Signature="); if (parts.length == 2) { String decodedSignature = URLEncoder.encode(parts[1], StandardCharsets.UTF_8.toString()); // 重新拼接URL urlPath = parts[0] + "Signature=" + decodedSignature; return urlPath; } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return null; } 参考这篇文章：https://blog.csdn.net/zyw0101/article/details/81188084
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c45903e778646d800a6653a3521c444/" rel="bookmark">
			Idea启动报错start failed闪退， RestfulToolkit-fix插件问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一天下班时还在正常使用的Idea，早上再次启动就报错闪退，报错信息非常的快的闪退也没有看清楚。做过的唯一更改就是前一天安装了 RestfulToolkit-fix 插件。
1、先查看报错的日志 在Idea安装路径的bin/ idea.bat文件中末尾处添加pause语句
保存后双击idea.bat文件启动，看报错信息
明白了确实是这个插件的问题
2、根据报错日志处理 C:\Users\XXX用户\AppData\Roaming\JetBrains\IntelliJIdea2021.2\plugins的目录下，找到RestfulToolkit-fix相关然后删除。
不要忘记删除第一个步骤中添加的pause语句，再重启Idea。
记录可以在 idea.bat文件中添加语句查看报错日志的方式，以后遇到此类问题也可以使用这个方式查看报错，根据报错再去解决，不至于觉得莫名其妙。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85ee955fe4e38c5066fb39896d8803b/" rel="bookmark">
			双系统ubuntu20.04(neotic版本)从0实现Gazebo仿真slam建图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双系统ubuntu20.04(neotic版本)从0实现Gazebo仿真slam建图 昨晚完成了ROS的多机通讯，还没来得及整理相关操作步骤，在进行实际小车的实验之前，还是先打算在仿真环境中进行测试，熟悉相关的操作步骤，计划通过虚拟机（笔记本）来操纵双系统（台式机）完成在仿真环境中的地图构建，导航等功能。
ps:别问为什么不直接通过向日葵远程操控，后面要进行实际环境中多机器人编队的测试，多机器人编队功能已经被写好了，但是需要安装在远程PC的工作空间中进行多机器人的控制
1、安装ROS（neotic）版本依赖
sudo apt-get install ros-noetic-joy ros-noetic-teleop-twist-joy \ ros-noetic-teleop-twist-keyboard ros-noetic-laser-proc \ ros-noetic-rgbd-launch ros-noetic-rosserial-arduino \ ros-noetic-rosserial-python ros-noetic-rosserial-client \ ros-noetic-rosserial-msgs ros-noetic-amcl ros-noetic-map-server \ ros-noetic-move-base ros-noetic-urdf ros-noetic-xacro \ ros-noetic-compressed-image-transport ros-noetic-rqt* ros-noetic-rviz \ ros-noetic-gmapping ros-noetic-navigation ros-noetic-interactive-markers ROS1和ROS2其他版本安装相关依赖参考网址（ROS1&amp;ROS2依赖包）注意☝的是一行指令，分行输入会报错的。
2、安装turtlebot3软件包
Install TurtleBot3 via Debian Packages.
sudo apt install ros-noetic-dynamixel-sdk sudo apt install ros-noetic-turtlebot3-msgs sudo apt install ros-noetic-turtlebot3 3、设置环境变量
source ~/.bashrc 4、创建工作空间安装TB3功能包
mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src/ git clone -b noetic-devel http://ghproxy.com/https://github.com/ROBOTIS-GIT/DynamixelSDK.git git clone -b noetic-devel http://ghproxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b85ee955fe4e38c5066fb39896d8803b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d2a88b7e2ac53279f88ea160057b7ee/" rel="bookmark">
			React 之 Hooks解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 1. class组件的优势 class组件可以定义自己的state，用来保存组件自己内部的状态 函数式组件不可以，因为函数每次调用都会产生新的临时变量class组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑，比如在componentDidMount中发送网络请求，并且该生命周期函数只会执行一次 函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求class组件可以在状态改变时只会重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等 函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次 2. Class组件存在的问题 复杂组件变得难以理解 随着业务的增多，我们的class组件会变得越来越复杂比如componentDidMount中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在componentWillUnmount中移除）这样的class实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度组件复用状态很难 在前面为了一些状态的复用需要通过高阶组件像之前学习的redux中connect或者react-router中的withRouter，这些高阶组件设计的目的就是为了状态的复用或者类似于Provider、Consumer来共享一些状态，但是多次使用Consumer时，代码就会存在很多嵌套这些代码让我们不管是编写和设计上来说，都变得非常困难 3. 为什么需要Hook Hook 是 React 16.8 的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）
hooks：
它可以让我们在不编写class的情况下使用state以及其他的React特性但是我们可以由此延伸出非常多的用法，来让我们前面所提到的问题得到解决完全可选的：你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook100% 向后兼容的：Hook 不包含任何破坏性改动现在可用：Hook 已发布于 v16.8.0 Hook的使用场景：
Hook的出现基本可以代替我们之前所有使用class组件的地方但是如果是一个旧的项目，你并不需要直接将所有的代码重构为Hooks，因为它完全向下兼容，你可以渐进式的来使用它Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用 4. 计数器案例 函数式组件结合hooks让整个代码变得非常简洁并且再也不用考虑this相关的问题 类组件实现 // 快捷键 =&gt; rpce import React, { PureComponent } from 'react'; export class CountClass extends PureComponent { constructor(props) { super(props); this.state = { counter: 0 }; } counterChange(num) { this.setState({ counter: this.state.counter + num }); } render() { // 快捷键 =&gt; dob const { counter } = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d2a88b7e2ac53279f88ea160057b7ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ddfd96f42bb1d70acbd7ccaa094793/" rel="bookmark">
			【Maya】Unreal5 Livelink for Maya的安装记录和UE5.0中的Maya livelink使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行动画绑定以及动画制作的过程中，一般的流程是在Maya中绑定、蒙皮、K帧做好之后导入到UE中去进行渲染以及查看效果。当UE中的效果不尽人意的时候，往往就需要在Maya中重新再制作再导入，比较麻烦。如果使用过ROKOKO或者UE中的livelink就会知道，如果有一款插件可以同时使用一个软件里面的运动数据驱动另一个软件里面的骨骼就好了，因UE livelink for Maya应运而生。
当我们在搜索界面搜索如何安装这个插件的时候，你会发现弹出来的第一个链接就是UE官方的文档：
https://docs.unrealengine.com/5.0/zh-CN/live-link-in-unreal-engine/
但是问题来了，官方文档里面无论是live link还是Unreal live link for maya都是针对虚幻4开发的，
甚至官网都会说自己没有针对虚幻5改这部分的内容哈哈哈哈。
而当我们试图按照文档的教程，去到虚幻商城中下载这个插件的时候，会发现假如没有下载虚幻4，我们是没有办法下载这个插件直接用到虚幻5上面去的。
但是，笔者在网上冲浪的过程中发现，虽然虚幻商城中没有可供虚幻5下载的插件，但是Autodesk官方有提供关于UE5的插件，而livelink下载的官方教程中可以看到其实在两方安装的插件是一样的内容，只不过是一个安装在UE中一个安装在Maya中罢了。所以猜想：下载这个Autodesk的插件再转移到UE中也是可行的。
笔者第一次下载的时候下载了livelink for UE5.1的版本，也就是这一版：
但是这一版livelink安装的过程中，会提示你需要现在UE中有相关的插件，这款插件才能安装，但是，我们根本还没安装好这个插件，怎么迁移到UE啊，显然，这会陷入了死循环的过程中。
于是尝试使用另外一个版本：
而当下载另外一个版本的livelink插件之前，需要先把之前还没安装好的上一个版本的livelink插件卸载干净，因为forUE5.1的插件是比version2的插件更新的，因此如果UE5.1的插件没有卸载干净的话安装程序是会提醒你已经有更新的版本并阻止你下载version2。如果你已经不小心下载了UE5.1版本的livelink，千万不要直接删除安装了的插件去卸载，而是需要重新点击安装程序，然后点击“remove”进行清除。
清除好之后就可以安装version2了（废话太多了2333，其实就是如果你的引擎版本是UE5.0的话，就直接用version2就好了）。
需要注意的是，这个插件需要安装到默认地址：
也就是这个默认地址，然后一直点next到install即可。
下载成功啦！然后我们点进提示的这个文件位置，会发现这里面已经躺好了一个livelink的下载程序，然后我们运行这个下载程序即可。
然后我们打开Maya，点击左上角的“文件”菜单栏，就会看见有一栏绿色的字显示Unreal livelink，这就显示我们的livelink安装成功了。
然后我们打开“窗口”-&gt;“设置/首选项”-&gt;“插件管理器”-&gt;搜索livelink，然后把这两个勾选上：
会提示需要重新build我们下载了这个插件的项目。
我们先需要在Maya中打开Unreal live link，也就是刚刚说的“文件”-&gt;"Unreal live link“，然后选择场景中的一个内容进行数据的传送：
然后在UE中打开livelink插件即可。
接着我们在”窗口“-&gt;“虚拟制片”中打开livelink，然后添加“源”选择Maya livelink，可以开始我们的livelink数据传送啦~
2023/9/12更新：今天看到UE的插件列表中以及可以直接添加MayaLivelink了，直接在工程中添加即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b9b71a3d185b8aa1babb2f21453326/" rel="bookmark">
			《android ScrollView嵌套RecycleView滑动禁止》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景 ScrollView嵌套多个RecycleView，导致垂直滑动的时候，ScrollView与RecycleView垂直滑动冲突问题。滑动时，造成屏幕卡顿的情况。
解决思路 禁止掉RecycleView的滑动功能
LinearLayoutManager layoutManager = new LinearLayoutManager(this) { @Override public boolean canScrollVertically() { // 直接禁止垂直滑动 return false; } }; 或者
GridLayoutManager mGridLayoutManager = new GridLayoutManager(this, 2){ @Override public boolean canScrollVertically() { return false; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88d3715882598f46422f392380a38d4/" rel="bookmark">
			关于this
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考阮一峰老师对于this的原理理解
一：this的定义 在严格模式下和非严格模式下，this的在全局中会有差别
来自阮一峰老师对于this的由来的理解
由于函数可以在不同的运行环境中运行，所以需要一种机制，能够在函数的内部获取当前运行环境，因此this就出现来，this的设计目的就是为了在函数的内部，指代函数当前的运行环境
所以在绝大多数的情况下，函数当前的运行环境决定了this的值
例如：
var obj = { foo: function () { console.log(this.bar) }, bar: 1 }; var foo = obj.foo; var bar = 2; obj.foo() // 1 foo() // 2 对于obj.foo()来说，是通过obj这个对象来找到foo()，所以foo()的运行环境obj对象，因此this的值就是Obj对象对于foo()来说，foo()函数的运行环境是window，因此this的值就是window 二：绑定规则 根据不同的使用场合，this有不同的值，主要分为下面几种情况：
默认绑定隐式绑定new绑定显示绑定 1. 默认绑定 默认绑定的意思就是，当函数独立执行，不作为一个对象的方法调用时，this绑定到全局对象中，但在严格模式下，this会绑定到undefined
function foo () { console.log(this); // 在浏览器中通常指向 window 对象 } foo(); 2. 隐式绑定 当函数作为对象的方法调用时，this 绑定到调用该方法的对象
var obj = { foo: function () { console.log(this) }, bar: 1 }; var foo = obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d88d3715882598f46422f392380a38d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c4c476cbf33e29e6c1c2523b09866c/" rel="bookmark">
			hive常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MONTH: MONTH函数是一个用于提取日期中的月份的函数。它接受一个日期作为参数，并返回一个整数值，表示该日期的月份。月份从1开始计数（即1表示一月），到12结束（即12表示十二月）。SELECT * FROM orders WHERE month(order_date) = 3;
YEAR: YEAR函数来提取日期中的年份;SELECT * FROM orders WHERE year(order_date) = 2023;
DAY: DAY将返回所有日期中的天数 SELECT * FROM orders WHERE day(order_date) = 17;
HOUR(date) : 返回日期的小时部分。
RANK(): 排序相同时会重复，总数不会变
DENSE_RANK(): 排序相同时会重复，总数会减少
ROW_NUMBER(): 会根据顺序计算
SUBSTRING:SUBSTRING函数是用于从字符串中提取子字符串的函数。它接受三个参数：待提取子字符串的字符串、子字符串的起始位置和要提取的长度。如果只提供两个参数，则第二个参数将被视为起始位置，而长度将默认为从起始位置到字符串的末尾。
窗口函数OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化.
行转列
CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串;
CONCAT_WS(separator, str1, str2,...)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;
COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。
COLLECT_LIST(col) : 不去除重复.
COUNT(*) 和count(1)有区别吗?
COUNT(*)会计算表中的总行数，并返回该值。如果表中有100行数据，COUNT()将返回100。 COUNT(1)也会计算表中的行数，并返回该值。但是，它实际上是在计算一个固定值1的行数，而不是计算所有行的数量。
case when : CASE函数用于执行条件逻辑，它根据给定的条件表达式返回不同的结果。
SELECT name, age, CASE WHEN age &lt; 18 THEN 'Child' WHEN age &gt;= 18 AND age &lt; 60 THEN 'Adult' ELSE 'Senior' END AS age_group FROM users; sum 与case when结合使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c4c476cbf33e29e6c1c2523b09866c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972b9af3e288c1eed19dc641eab61798/" rel="bookmark">
			Deep Learning Debug记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deep Learning Debug记录 1 、numpy读.npy格式数据报错2、unzip时出现问题3、pytorch版本问题4、模型加载权重报错5、模型测试时需要扩充维度6、端口问题 1 、numpy读.npy格式数据报错 ValueError: Object arrays cannot be loaded when allow_pickle=False 原因：
numpy版本的问题，在1.16.3版本后，allow_pickle的值默认设为False。
解决方案：
1、降低numpy的版本
2、在numpy.load()函数调用的地方将allow_pickle值设置为True np.load(src, allow_pickle=True)
2、unzip时出现问题 Archive: GoPro_large9G.zip End-of-central-directory signature not found. Either this file is not a zipfile, or it constitutes one disk of a multi-part archive. In the latter case the central directory and zipfile comment will be found on the last disk(s) of this archive. 原因：参考其它博客
在window主机上尝试解压，发现正常解压，说明源文件正常，百度说 “一般在linux下解压zip文件，直接用系统默认的extract here进行解压(默认使用的是 unzip)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/972b9af3e288c1eed19dc641eab61798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bf906fbeb52998bbfbcccd3e969b6e/" rel="bookmark">
			LEFT JOIN与WHERE同时用，带给我的重灾难！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 表信息 1.1 用户表 1.2 用户兴趣爱好表 2. left join 语句【本文论点】 SELECT * FROM d_user u LEFT JOIN d_hobby h ON u.id = h.userId WHERE h.hobby != '睡觉' 思考一下这段SQL的查询结果是什么？（思考完看评论区，有结果）
SELECT * FROM d_user u LEFT JOIN d_hobby h ON u.id = h.userId AND h.hobby != '睡觉' 再思考一下这段SQL的查询结果又是什么？（思考完看评论区，有结果）
3. left join总结 3.1 我的错误论据： 我一直以为上面第一段SQL语句的结果是用户表中所有的数据，不管有没有where！！
3.2 客观论据： 1. 先将left join的左表的所有符合结果查询出来；
2. 查询完left join的关联数据后，再用where语句对其进行过滤（先后关系，涉及where语句要注意一下）。
4. 提问 第二段SQL中为什么d_hobby表中为NULL的数据也被过滤掉了？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4ce96bbc02559d520903f6402acfc5/" rel="bookmark">
			在 VSCode 中配置 PHP 开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 VSCode 中配置 PHP 开发环境 1 PHP 官网地址：PHP
界面：
2 下载 官网下载地址：Download PHP
3 安装 ① 按照下图指示下载 php zip包。
② 解压到想要安装 php 的位置（注意先双击打开压缩包，看下有没有根目录）。
如下图，打开后没有根目录，不要直接解压，不然文件就混在一起了。
这里建议新建一个根目录再解压（或者直接右键选择“解压到xxx”），如下图所示。
4 配置环境变量 ① 打开 php 安装目录，按下图复制地址。
② 右击“我的电脑” →“属性” →“高级系统设置”→“环境变量” （或者 直接按 win + s 搜索“高级系统设置” ，然后点击“查看高级系统设置”→“环境变量”），打开“环境变量”对话框，如下图所示。
③ 在第②步打开的“环境变量”对话框中双击修改“系统变量”中的 path，添加第 ① 步所复制的路径。
注意：环境变量配置完别忘记点击确定（一路点击“确定”直到“系统属性”对话框消失）。
④ 测试：在 cmd 中输入
php -v 5 在 VSCode 中配置 PHP ① 安装插件 PHP Server（如下图所示），这个插件可以让 .php 文件直接右击运行于浏览器中，不需要借助于 xampp 的 Apache。
注意：该插件用于个人测试及小网站的开发是没有任何问题的，不过大型应用还是要配合 Nginx 或 Apache 以达到最高效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb4ce96bbc02559d520903f6402acfc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648bcb1a46ddc67c961d62b62ee389f1/" rel="bookmark">
			做游戏开发需要读研吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主观建议版 【是否要读研再工作——不建议】
游戏行业不太看重研究生上学就是为了更好的进入工作，许多人考研就是为了拿到工作的敲门砖。而你现在已经一脚迈入门里面了。对于游戏开发从业者而言，走企业路线的，工作中的经验远比课堂上的知识重要（当然走研究路线的不一样）。就游戏行业而言，大厂在国内的实力是数的上的，从大厂这个大门进入游戏行业，你选择了一个不错的平台。中国传媒大学主要对口的岗位是游戏策划，题主是偏向于ue的动画和物理且游戏开发方向的研究生颇有难度，还没转正率高，故中传读研可行价值不高。目前国内读研大多数是挂着游戏开发的牌子，干着其他的事情。读研相较于工作唯一优势仅仅为学历。 客观建议版 归根，题主纠结的是：“研究生学历”和“2~3年的工作经验”哪个对游戏行业后期发展更有利。这个问题不仅对题主，对大部分准入行人都是一个纠结点。
本科阶段就能找到心仪的公司入行——先入行。互联网发展速度快，现在的情况与读完研后的情况大概率不尽相同。本科阶段入行困难/不能找到满意的公司且读研院校学历比本科强——读研。 升迁、涨薪，到底看不看学历 学历VS能力：能力居多，工作时间越久，能力因素占比越大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879918374e1b0b99103b4c6542646e91/" rel="bookmark">
			扩散模型 DDPM 核心代码梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考内容：
大白话AI | 图像生成模型DDPM | 扩散模型 | 生成模型 | 概率扩散去噪生成模型
AIGC 基础，从VAE到DDPM 原理、代码详解
全网最简单的扩散模型DDPM教程
The Annotated Diffusion Model
How does Stable Diffusion work?
LaTeX公式编辑器
pytorch-beginner
强烈推荐：
大白话AI | 图像生成模型DDPM | 扩散模型 | 生成模型 | 概率扩散去噪生成模型，特别透彻的讲清楚了前向扩散和反向去噪的公式推导pytorch-beginner代码仓库，里面包含了AE、VAE的pytorch代码实现AIGC 基础，从VAE到DDPM 原理、代码详解知乎文章，其中包含了详细完整的公式推导，并且用tensorflow框架实现了AE、VAE、Conditional VAE、DDPM、Conditional DDPM的简化版代码实现
备注： 具体公式的推导请查看参考链接，本文只记录核心步骤的几个核心公式。
什么是扩散模型？ 与Normalizing Flows、GAN或VAEs等生成模型一样，它们都将噪声从一些简单分布转换为数据样本。这也是使用神经网络学习从纯噪声开始逐渐去噪进行内容生成的过程。扩散模型主要包括以下两个过程：
前向加噪： 前向加噪过程是一个固定的、预定义的过程，通过逐步的往一张真实图像上添加高斯噪声，最终得到一个完全的高斯噪声图像反向去噪： 反向去噪过程通过训练学习一个神经网络模型，模型的输入是一张带有噪声的图像，模型的输出是预测得到的噪声，逐步减去预测的噪声，最终得到一张真实的图像
加噪、去噪、训练、推理阶段相关的数学公式 前向加噪 在前向加噪过程中，逐步的往真实图片上添加高斯噪声，每一步添加高斯噪声的公式表示如下：
x t = 1 − β t x t − 1 + β t ϵ t \begin{equation}x_{t} = \sqrt{1-\beta_{t}}x_{t-1} + \sqrt{\beta_{t}}\epsilon_{t}\end{equation} xt​=1−βt​ ​xt−1​+βt​ ​ϵt​​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/879918374e1b0b99103b4c6542646e91/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/53/">«</a>
	<span class="pagination__item pagination__item--current">54/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/55/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>