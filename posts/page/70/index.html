<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed359c3a9ccf0d2968ba4f5bea4bf622/" rel="bookmark">
			ChatGPT 有什么新奇的使用方式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来看看ChatGPT对此问题如何作答
ChatGPT对此问题如何作答
ChatGPT是什么 ChatGPT是一种基于自然语言处理的语言模型，由OpenAI开发。它是建立在GPT（Generative Pre-trained Transformer）架构的基础上的，采用了深度学习技术。GPT模型的目标是理解和生成人类语言，使其能够进行语义理解、自然语言生成和对话交互。
ChatGPT的训练过程基于大规模的语料库，其中包含了来自互联网的文本数据。通过对这些文本数据进行预训练，ChatGPT可以学习到词汇、语法、语义以及常见的上下文关系。这使得ChatGPT具备了理解和生成自然语言的能力。
引言 随着人工智能和自然语言处理技术的不断发展，ChatGPT作为一种强大的语言模型，正以令人惊叹的方式改变着我们与计算机交互和利用语言的方式。下面是ChatGPT在各个领域的使用方式。
GPT 学术优化 网页地址：GitHub - binary-husky/gpt_academic: 为ChatGPT/GLM提供图形交互界面，特别优化论文阅读润色体验，模块化设计支持自定义快捷按钮&amp;函数插件，支持代码块表格显示，Tex公式双显示，支持Python和C++等项目剖析&amp;自译解功能，PDF/LaTex论文翻译&amp;总结功能，支持并行问询多种LLM模型，支持清华chatglm等本地模型。兼容复旦MOSS, llama, rwkv, 盘古, newbing, claude等
GPT 学术优化
此插件可以为ChatGPT/GLM提供图形交互界面，特别优化论文阅读润色体验，模块化设计支持自定义快捷按钮&amp;函数插件，支持代码块表格显示，Tex公式双显示，支持Python和C++等项目剖析&amp;自译解功能，PDF/LaTex论文翻译&amp;总结功能，支持并行问询多种LLM模型，支持清华chatglm等本地模型。兼容复旦MOSS, llama, rwkv, 盘古, newbing, claude等。
ChatGPT在游戏制作上 （ChatGPT接入unity实现AI对话）
学习地址：Unity接入ChatGPT：实现游戏AI对话系统_哔哩哔哩_bilibili
对话系统：ChatGPT可以用于开发逼真的游戏对话系统。它可以扮演非玩家角色（NPC），与玩家进行对话并提供有意义的响应。这可以增加游戏的互动性和沉浸感，使玩家感觉与游戏世界中的角色有真实的交流。剧情生成：ChatGPT可以用于生成游戏的剧情和故事情节。开发者可以与ChatGPT进行对话，提供故事元素、角色设定和情节要素，然后ChatGPT可以生成新的剧情和情节方向。这可以为游戏开发人员提供创意灵感，节省故事编写的时间和精力。游戏助手：ChatGPT可以作为游戏中的助手角色存在。它可以提供提示、答疑解惑，帮助玩家在游戏中更好地理解规则、解决难题或克服挑战。这样的游戏助手可以通过对话的方式与玩家进行互动，提供个性化的指导和支持。NPC行为模拟：ChatGPT可以用于模拟非玩家角色（NPC）的行为和决策。通过与ChatGPT的对话，NPC可以根据玩家的行为和对话内容作出适当的反应，使其行为更加智能化和真实化。这可以增强游戏的人工智能元素，使NPC具有更多的自主性和个性化。关卡设计：ChatGPT可以与开发者进行关卡设计的对话。开发者可以向ChatGPT提供关卡设计的概念、难度设置和关卡要素，然后ChatGPT可以提供反馈和建议，帮助开发者优化关卡设计和平衡游戏难度。游戏测试：ChatGPT可以在游戏测试中扮演玩家的角色，提供多样化的游戏测试场景和反馈。测试人员可以与ChatGPT进行对话，测试游戏的不同方面，如功能性、用户体验和故事连贯性，从而发现和修复潜在的问题。 ChatGPT集成到浏览器上 Midjourney By ChatGPT ​ 网页地址：免费AI创作/绘图 - JourneyDraw Midjourney By ChatGPT - Chrome 应用商店 (google.com)
Midjourney By ChatGPT
使用 ChatGPT 对任何网页进行总结 ​ 网页地址：ChatGPT 总结助手 - Chrome 应用商店 (google.com)
使用 ChatGPT 对任何网页进行总结
在搜索引擎结果中同时显示 ChatGPT 的回答 ​ 网页地址：ChatGPT for Google - Chrome 应用商店
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed359c3a9ccf0d2968ba4f5bea4bf622/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0b97901709efd579495afcaadbeea3/" rel="bookmark">
			CentOS同时安装mysql8.0（替换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统里已经有mysql5.7，但是由于特殊要求需要再安装一个8.0版本
1、下载包
注意：安装包要匹配linux系统的cglib版本！！！否则初始化会报错
./mysqld: /lib64/libstdc++.so.6: version `CXXABI_1.3.11' not found (required by ./mysqld) ./mysqld: /lib64/libstdc++.so.6: version `CXXABI_1.3.8' not found (required by ./mysqld) ./mysqld: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.22' not found (required by ./mysqld) ./mysqld: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.20' not found (required by ./mysqld) ./mysqld: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by ./mysqld) ./mysqld: /lib64/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by ./mysqld) ./mysqld: /lib64/libc.so.6: version `GLIBC_2.28' not found (required by ./mysqld) ./mysqld: /lib64/libc.so.6: version `GLIBC_2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0b97901709efd579495afcaadbeea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7ca36e4372485f17fedf6bb35ab5fb/" rel="bookmark">
			数据结构与算法学习笔记 5.串（字符串）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.串（字符串） 5.1 串的定义 ​ 串（string）是由零个或多个字符组成的有限序列，叉叫字符串。
​ 一般般记为S＝“a1a2…an″ (n ≥) ，其中， s是串的名称，用双引号（有些书中也用单引号）括起来的字符序列是串的值，注意引号不属于串的内容。ai（1≤i≤n）可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称为串的长度，定义中谈到“有限”是指长度″是一个有限的数值。零个字符的串称为空串（null string），它的长度为零，可以直接用两个双引号“＂＂”表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。
​ 空格串，是只包含空格的串。注意它与空串的区别。空格串是有内容有长度的，而且可以不止一个空格。 子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地包含子串的串称为主串。子串在主串中的位置就是子串的第—个字符在主串中的序号。
5.2 串的比较 ​ 两个数字，很容易比较大小。2比1大，这完全正确，可是两个字符串如何比较？比如“silly",“stupid"这样的同样表达“愚蠢的”的单词字符串，它们在计算机中的大小其实取决于它们挨个字母的前后顺序。它们的第一个字母都是”s“，我们认为不存在大小差异，而第二个字母，由于”i“字母比”t“字母要靠前，所以”i“&lt;“t” ，于是我们说"silly”&lt;“stupid”。
​ 事实上，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码值得是字符在对应字符集中的序号。
​ 计算机中常用的字符是使用标准的ASCII编码，更准确一点，由7位二进制数表示一个字符，总共可以表示128个字符。后来发现—些特殊符号的出现128个不够用，于是扩展ASCII码由8位二进制数表示一个字符，总共可以表示256个字符，这已经足够满足以英语为主的语言和特殊符号进行输入、存储、输出等操作的字符需要了。可是单我们国家就有除汉族外的满、回、藏、蒙古、维吾尔等多个少数民族文字，换作全世界估计要有成百上千种语言与文字，显然这256个字符是不够的，因此后来就有了Unicode 编码，比较常用的是由16位的二进制数表示一个字符，这样总共就可以表示216个字符， 约是65万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和ASCII码兼容，Unicode的前256个字符与ASCII码完全相同。
​ 所以如果我们要在C语言中比较两个串是否相等，必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等。即给定两个串: s＝＂a1a2…an＂, t＝"b1b2…bn＂, 当且仅当n＝m，且a1＝b1，a2＝b2，…an＝bn时，我们认为s＝t。
​ 那么对干两个串不相等时,如何判定它们的大小呢?我们这样定义:
给定两个串: s＝＂a1a2…an＂, t＝"b1b2…bn＂,当满足以下条件之一时，s&lt;t.
(1) n&lt;m,且ai&lt;bi(i=1,2,···,n)。
(2) 存在某个k&lt;=min(m, n)，使得ai=bi(i=1,2···,k-1),ak&lt;bk。
5.3 串的抽象数据类型 ​ 串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素 是字符，哪怕串中的字符是由“123”这样的数字组成，或者是由“2010-10-10”这样的日期组成，它们都只能理解为长度为3和长度为10的字符串，每个元素都是字符而已。 因此，对于串的基本操作与线性表是有很大差别的。线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作。
​ 下面是串的抽象数据结构：
ADT 串(string) Data 串中元素仅有一个字符组成，相邻元素具有钱去和后继关系 Operation StrAssign(T, *chars):生成一个其值等于字符串常量chars的串T StrCopy(T,S):串S存在,由串S复制得串T ClearString(S):串S存在,将串清空 StringEmpty(S):若串S为空,返回true，否则返回False StrLength(S):返回串S的元素个数,即串的长度 StrCompare(S, T):若S&gt;T,返回值&gt;0,若S=T,返回0,若&lt;T,返回值&lt;0 Concat(T, S1, S2):用T返回由S1和S2联接而成的新串 SubString(Sub, S, pos ,len):串S存在，1&lt;=pos&lt;=StrLength(S),且0&lt;=len&lt;=StrLength(S)-Pos+1,用Sub返回串S的第pos个字符串起长度为len的字串 Index(S, T, pos):串S和T存在，T是非空串，1&lt;=pos&lt;=StrLength(S),若子串S中存在和串T值相同的子串,则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0 Replace(S, T, V):串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。 StrInserrt(S, pos, T):串S和T均存在，1&lt;=pos&lt;=StrLength(S)+1。在串S的第pos个字符之前插入串T StrDelete(S, pos, len):串S存在，1&lt;=pos&lt;=StrLength(S)-len+1。从串S中删除第pos个字符长度为len的子串 endADT 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7ca36e4372485f17fedf6bb35ab5fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2601aab505381b2d7fecf391abadfa/" rel="bookmark">
			你真的知道各个程序员网站的优缺点吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息技术的快速发展，程序员网站作为程序员们获取资源、学习交流的重要平台，逐渐成为技术人员必备的工具。本文以CSDN、开源中国、GitHub、掘金、程序员客栈和博客园这六个广为人知的程序员网站为研究对象，对其优缺点进行综合分析，并提供一些建议和展望。
一、CSDN 优点：
内容丰富：CSDN汇集了众多IT领域的技术文章、教程和解决方案，方便程序员们学习和解决问题。社区互动：CSDN提供了活跃的社区，程序员们可以在这里互相交流、提问和回答问题。就业信息：CSDN不仅提供技术资源，还有大量的招聘信息，为程序员们提供了就业和发展的机会。 缺点：
广告过多：CSDN页面的广告频率较高，有时影响用户体验。文章质量参差不齐：由于CSDN允许任何人发布文章，因此文章质量参差不齐，真伪难辨。 二、开源中国 优点：
开源项目：开源中国是国内优秀的开源项目托管平台，提供了大量优秀的开源项目供程序员学习和使用。技术问答：开源中国社区提供了一个活跃的技术问答交流平台，程序员们可以在这里提问和解答问题。技术资讯：开源中国提供了及时的技术资讯和行业动态，帮助程序员们紧跟技术潮流。 缺点：
界面设计较旧：开源中国的界面设计相对落后，不够美观和便捷。部分功能不完善：某些功能模块还需要继续完善，用户体验有待提升。 三、GitHub 优点：
开源项目托管：GitHub是全球最大的开源项目托管平台，程序员可以在这里共享和协作开发项目。版本控制：GitHub的版本控制功能非常强大，方便程序员进行源代码管理和团队协作。社交互动：GitHub社区活跃，程序员可以与其他开发者互动、学习和贡献。 缺点：
学习门槛较高：GitHub对于新手来说上手比较困难，需要一定的学习和实践时间。部分功能付费：GitHub的部分高级功能需要付费才能使用，限制了一部分用户的体验。 四、掘金 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7yEbBoj0-1688098697661)(https://ts1.cn.mm.bing.net/th/id/R-C.4d9530a2ef46e92c042d62c1127353f2?rik=nwZnQmCtzJYP9A&amp;riu=http://logoju.cn/wp-content/uploads/2018/10/logoju.cn_2018-10-13_03-28-59.png&amp;ehk=FOHI4K0dKfP7uKH1i1ACApThl4GtdR78XOCmuB6atO0=&amp;risl=&amp;pid=ImgRaw&amp;r=0#pic_center)]
优点：
精选文章：掘金的编辑团队对文章进行精选，提供高质量的技术文章给程序员们阅读。社区互动：掘金社区活跃，程序员们可以在这里互相交流、分享经验和解答问题。资源丰富：掘金提供了很多优秀的技术资源和工具，帮助程序员们提高工作效率。 缺点：
平台封闭性：掘金相对封闭，不太容易形成开放和多元化的技术氛围。部分内容重复：程序员客栈 缺点。 五、程序员客栈 优点：
技术服务交易平台：程序员客栈为程序员们提供了一个交易平台，可以接外包项目或者提供技术服务，为程序员们提供了赚钱的机会。管理工具：程序员客栈提供了项目管理、交流沟通、工时统计等工具，方便程序员进行项目管理和团队协作。资源共享：程序员客栈的资源库中有各类技术资源和教程，帮助程序员们学习和解决问题。 缺点：
交易费用较高：程序员客栈为提供交易平台和工具，收取一定的服务费用，这对于一些低收入的程序员来说可能不太划算。资源质量不一：由于开放上传资源的权限，程序员客栈的资源质量参差不齐，需要用户自行甄别。 六、博客园 优点：
个人博客平台：博客园是一个提供个人博客搭建的平台，程序员们可以在这里记录和分享自己的技术经验和成果。多元化内容：博客园的内容涵盖了各类技术、软件开发、互联网等领域，用户可以根据自己的兴趣选择阅读。评论互动：博客园提供了评论功能，读者可以对博文进行评论和讨论，与博主和其他读者互动交流。 缺点：
资源分散：博客园的博客内容分散在不同用户的个人页面，搜索和归类相对不便。可信度参差不齐：博客园上的博客质量参差不齐，有些博客内容存在错误或者不准确的情况。 综合分析： 从以上分析可见，每个程序员网站都有其独特的优点和缺点。CSDN和开源中国提供了丰富的技术资源和活跃的社区互动；GitHub和程序员客栈则具备强大的项目托管和管理工具；掘金则注重发布高质量技术文章；而博客园则提供了个人技术博客平台。
为了充分利用这些网站的优点，程序员们可以根据自身需求选择使用。对于学习和解决问题，可以参考CSDN和开源中国的资源；若在开源项目合作或源代码管理方面，GitHub是较好的选择；需要寻找博文和分享经验，可以关注掘金和博客园；而对于寻找项目或提供技术服务的需求，则可以考虑使用程序员客栈。
未来，随着技术的发展，这些程序员网站也将不断改进和创新，提供更好的服务和体验，为广大程序员们创造更有价值的学习和交流平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a60518e977312fee0f63b30f9fb64c/" rel="bookmark">
			mysql5.6 linux 安装设置密码和远程登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql 设置跳过登陆验证： vim /etc/my.cnf文件；
在[mysqld]后添加skip-grant-tables（登录时跳过权限检查)
[mysqld]
skip-grant-tables
port = 3306
socket = /tmp/mysql.sock
datadir = /www/server/data
default_storage_engine = InnoDB
performance_schema_max_table_instances = 400
table_definition_cache = 400
skip-external-locking
key_buffer_size = 64M
max_allowed_packet = 100G
table_open_cache = 256
sort_buffer_size = 1M
net_buffer_length = 4K
重启systemctl restart mysqld
mysql 设置密码： 登录mysql，输入mysql -h localhost -u root -P 3306 -p；直接回车（Enter）
use mysql;
set password for 'root'@'localhost'=password('1234!@#$qwerQWER');
如果报：ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85a60518e977312fee0f63b30f9fb64c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef7568a713333d1a3660a6fdfd0f82c/" rel="bookmark">
			强化学习从基础到进阶–案例与实践[11]：AlphaStar论文解读、监督学习、强化学习、模仿学习、多智能体学习、消融实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【强化学习原理+项目专栏】必看系列：单智能体、多智能体算法原理+项目实战、相关技巧（调参、画图等、趣味项目实现、学术应用项目实现
专栏详细介绍：【强化学习原理+项目专栏】必看系列：单智能体、多智能体算法原理+项目实战、相关技巧（调参、画图等、趣味项目实现、学术应用项目实现
对于深度强化学习这块规划为：
基础单智能算法教学（gym环境为主）主流多智能算法教学（gym环境为主） 主流算法：DDPG、DQN、TD3、SAC、PPO、RainbowDQN、QLearning、A2C等算法项目实战 一些趣味项目（超级玛丽、下五子棋、斗地主、各种游戏上应用）单智能多智能题实战（论文复现偏业务如：无人机优化调度、电力资源调度等项目应用） 本专栏主要方便入门同学快速掌握强化学习单智能体|多智能体算法原理+项目实战。后续会持续把深度学习涉及知识原理分析给大家，让大家在项目实操的同时也能知识储备，知其然、知其所以然、知何由以知其所以然。
声明：部分项目为网络经典项目方便大家快速学习，后续会不断增添实战环节（比赛、论文、现实应用等）
专栏订阅（个性化选择）：
强化学习原理+项目专栏大合集-《推荐订阅☆☆☆☆☆》
强化学习单智能体算法原理+项目实战《推荐订阅☆☆☆☆》
强化学习多智能体原理+项目实战《推荐订阅☆☆☆☆☆》
强化学习相关技巧（调参、画图等《推荐订阅☆☆☆》）
tensorflow_gym-强化学习:免费《推荐订阅☆☆☆☆》
强化学习从基础到进阶-案例与实践：免费《推荐订阅☆☆☆☆☆》
强化学习从基础到进阶–案例与实践含面试必知必答[11]：AlphaStar论文解读 AlphaStar及背景简介 相比于之前的深蓝和AlphaGo，对于《星际争霸Ⅱ》等策略对战型游戏，使用AI与人类对战的难度更大。比如在《星际争霸Ⅱ》中，要想在玩家对战玩家的模式中击败对方，就要学会各种战术，各种微操和掌握时机。在游戏中玩家还需要对对方阵容的更新实时地做出正确判断以及行动，甚至要欺骗对方以达到战术目的。总而言之，想要让AI上手这款游戏是非常困难的。但是DeepMind做到了。
AlphaStar是DeepMind与暴雪使用深度强化学习技术实现的计算机与《星际争霸Ⅱ》人类玩家对战的产品，其因为近些年在《星际争霸Ⅱ》比赛中打败了职业选手以及99.8%的欧服玩家而被人所熟知。北京时间2019年1月25日凌晨2点，暴雪公司与DeepMind合作研发的AlphaStar正式通过直播亮相。按照直播安排，AlphaStar与两位《星际争霸Ⅱ》人类职业选手进行了5场比赛对决演示。加上并未在直播中演示的对决，在人类对阵AlphaStar的共计11场比赛中，人类仅取得了1场胜利。DeepMind也将研究工作发表在了2019年10月的 Nature 杂志上。本章将对这篇论文进行深入的分析，有兴趣的读者可以阅读原文。
1 AlphaStar的模型输入和输出是什么呢？————环境设计 构建深度强化学习模型的第一步就是构建模型的输入和输出，对于《星际争霸Ⅱ》这一个复杂的环境，文章第一步就是将游戏的环境抽象成众多独立的数据信息。
1.1 状态（网络的输入） AlphaStar将《星际争霸Ⅱ》的环境状态分为4部分，分别为实体（entities）信息、地图（map）信息、玩家数据（player data）信息、游戏统计（game statistics）信息，如图11.1所示。
图 11.1 环境状态的构成 第一部分————实体信息，例如当前时刻环境中有什么建筑、兵种等，并且我们将每一个实体的属性信息使用向量表示。例如对于一个建筑，其当前时刻的向量中包含此建筑的血量、等级、位置以及冷却时间等信息。所以对于当前帧的全部实体信息，环境会给神经网络 N N N 个长度为 K K K 的向量，分别表示此刻智能体能够看见的 N N N 个实体的具体信息（向量信息）。
第二部分————地图信息，这部分比较好理解，即将地图中的信息以矩阵的形式输入神经网络中，来表示当前状态全局地图的信息（向量信息或图像信息）。
第三部分————玩家数据信息，也就是当前状态下，玩家的等级和种族等信息（标量信息）。
第四部分————游戏统计信息，视野的位置（小窗口的位置，区别于第二部分的全局地图信息），还有当前游戏的开始时间等信息（标量信息）。
1.2 动作（网络的输出） AlphaStar的动作信息主要分为6个部分，如图11.2所示，分别为动作类型（action type）、选中的单元（selected units）、目标（target）、执行动作的队列（queued）、是否重复（repeat）以及延时（delay），各个部分间是有关联的。
图 11.2 动作信息的构成 第一部分————动作类型，即下一次要进行的动作的类型是移动小兵、升级建筑还是移动小窗口的位置等。
第二部分————选中的单元，承接第一部分，例如我们要进行的动作类型是移动小兵，那么我们就应该选择具体移动哪一个小兵。
第三部分————目标，承接第二部分，我们移动小兵A后，是要去地图的某一个位置还是去攻击对手的哪一个目标等，即选择目的地或攻击的对象。
第四部分————执行动作的队列，即是否立即执行动作，对于小兵A，是到达目的地后直接进行攻击还是原地待命。
第五部分————是否重复，如果需要小兵A持续攻击，那么就不需要再通过网络计算得到下一个动作，直接重复上一个动作即可。
第六部分————延时，即等候多久后再接收网络的输入，可以理解为一个操作的延迟。
2 AlphaStar的计算模型是什么呢？————网络结构 我们在11.2节说明了AlphaStar网络的输入和输出，即状态和动作，那么从状态怎么得到动作呢？这里我们先给出其网络结构的总览，如图11.3所示，后面对此详细讨论。
图 11.3 AlphaStar网络结构总览 2.1 输入部分 图 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef7568a713333d1a3660a6fdfd0f82c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297498260f49085a845352dda9f5226b/" rel="bookmark">
			使用Elasticsearch进行word，excel，PDF的全文检索 windows实现 超完整（ingest-attachment实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要明确的一点就是Elasticsearch的版本要和ingest-attachment的版本一致，要不然没办法安装。然后还有一点JAVA版本要在11以上
先说说原理吧，其实就是将文件base64编码，然后再用插件读取文件内容并保存到es中。
1.如果你的版本是JAVA1.8的话，最好换成JDK11 安装完jdk之后用cmd查看一下java -version看看是否已经从1.8修改为了11
如果没有边的话则需要修改环境变量
可以在开始菜单输入env快速打开环境变量配置
首先修改JAVA_HOME
然后还是和配置jdk一样修改path 但是这里有一个坑点，那就是除了你自己配置的jdk path之外可能还有一个oracle的path，记得把他给删了，要不java -version后还是1.8
2.安装Elasticsearch 7.9.0 我的es是在这个链接下载的：
https://rjxcvbn.tianjiuda.com/20211206/elasticsearch_v7.9.0_xitongcheng.zip
下载完毕之后解压
进入bin目录 双击elasticsearch.bat即可运行es
运行完成后可以访问http://127.0.0.1:9200/ 查看是否正常运行
3.下载配置ingest-attachment-7.9.0 这里一定要下载和上面一样的版本，否则无法安装
下载地址：https://artifacts.elastic.co/downloads/elasticsearch-plugins/ingest-attachment/ingest-attachment-7.9.0.zip
比如说ingest-attachment-5.4.2.zip 在D盘根目录，那我们就可以在elastics的根目录下运行下面的命令
bin\elasticsearch-plugin install file:///D:\ingest-attachment-5.4.2.zip 这样他就会将ingest-attachment的插件安装到elasticsearch上了。这里就不放截图了，因为我已经安装好了。
安装好之后可以通过PowerShell查看是否安装完成 首先切换目录到ES根目录：
输入 .\bin\elasticsearch-plugin list如果有ingest-attachment则代表安装成功
然后我们可以重启es。重启方式就是关闭cmd然后重新打开步骤1的.bat
3.POSTMAN ES基础使用教程 如果已经会使用es请跳过该步骤
先偷一张图
我就以mysql数据库举例吧，比如说mysql中的表在es里应该叫索引，我就直接叫表吧，毕竟不跳过这里的估计也没太看过es的教程。我这里就是简单的说一说，想要具体了解请看其他的文章。。
es新建表可以通过postman来建立
用PUT请求发送127.0.0.1:9200/test 其中test可以理解为表的名称 然后我们可以向表中添加数据，因为es类似于Mongodb，存储的数据为json类型，是非关系型数据库，不存在字段这一说，所以数据我们可以随便存。
插入数据：127.0.0.1:9200/test/_doc/1002
请求体：
{ "title":"小米手机1", "category":"小米1", "image":"www.yy.com", "price":3999.00 } 这里需要注意，还是要用put请求，test相当于表名，_doc可以理解为固定写法，最后的1002可以不写，写了就是指定这个数据的id为1002，不写则是随机生成的字符串
返回结果：
如果不写ID的话返回结果：
（不写的话得用post请求，上面我说的可能有点问题，因为我也是项目上需要所以也没深入了解，只看了半天，就随便写了个小demo） 可以看见这里的id是nFez2IgBadwYgUd60r2A，这个是自动生成的。
然后我们可以根据id去查询。
127.0.0.1:9200/test/_doc/nFez2IgBadwYgUd60r2A
这里是get请求，需要注意一定不要选成post，否则会直接对数据进行更新。
返回值：
{ "_index": "test", "_type": "_doc", "_id": "nFez2IgBadwYgUd60r2A", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297498260f49085a845352dda9f5226b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c161ee530e9d003d023df7bda16be1/" rel="bookmark">
			交换机 – 华为CloudEngine S3735S配置入门喂饭级教程（仅用一根网线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、恢复出厂配置（如果忘记密码） 长按前面板右下角PNP键（6秒以上），使设备恢复出厂配置并自动重新启动。
提示：通过命令行进行恢复出厂配置，在用户视图下，执行命令reset factory-configuration。
2、通过网线连接交换机的ETH和电脑的网口。 3、确认电脑网口IP 与交换机连接的网口IP为192.168.1.XXX（XXX不能是1、253、255），掩码是255.255.255.0
4、电脑上打开浏览器 地址栏输入：https://192.168.1.253
回车后，将显示如下登录网页。
输入缺省用户名：admin 密码：admin@huawei.com
点GO
5、修改密码 新密码改成：admin@huawei
6、在网页中配置交换机 使用新密码登录网页，在监控页面上可以看到设备名称、系统软件版本
在“维护-&gt;系统管理”页面，将Telnet、STelnet设为ON。点应用
在“维护-&gt;管理员”页面，勾选“接入类型”中的Telnet、SSH。
在“SSH用户配置”中勾选“Password认证”、Stelnet。
点确定
提示：在网页上也可以恢复出厂配置。
7、在Putty中使用telnet连接交换机 保持电脑通过网线连接交换机的ETH口。
打开Putty软件。
输入交换机的IP：192.168.1.253，端口：23（telnet默认端口）。
“Connection Type”选“Other”，下拉框选“Telnet”。
点“Open”。
输入用户名：admin
密码：admin@huawei
看到&lt;HUAWEI&gt;，可以输入命令进行控制了。
8、在Putty中使用SSH连接交换机 保持电脑通过网线连接交换机的ETH口。
打开Putty软件。
输入交换机的IP：192.168.1.253，端口：22（SSH默认端口）。
“Connection Type”选“SSH”。
点“Open”。
在弹出的警告框中点Accept。
输入用户名：admin
密码：admin@huawei
看到&lt;HUAWEI&gt;，可以输入命令进行控制了。
备用方法：使用Console线+USB转串口线 注意：当使用Console进行配置时，会中断通过ETH的配置。
1、将Console线(一端是网口RJ45水晶头，另一端是9孔串口)的网口插入交换机的CONSOLE口，另一端接USB转串口的串口端。
2、将USB转串口线的USB口插入电脑，安装相关驱动，使电脑识别出串口的COM号。
3、打开Putty软件，“Connection Type”选“Serial”。
“Serial line”填电脑识别出的COM号。
点Open
4、输入缺省用户名：admin 密码：admin@huawei
看到&lt;HUAWEI&gt;，可以输入命令进行控制了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedbe1e4a50d9d4aa13af6d499dbde6d/" rel="bookmark">
			OAuth2.0到底是什么？看完你就明白了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oauth2介绍 OAuth2是一种开放授权协议，是一种用于授权的规范。它提供了一种灵活的授权方式，允许用户在第三方应用中安全地授权访问其受保护的资源，而无需共享其用户名和密码。OAuth2协议定义了客户端如何请求授权、用户如何在客户端和应用之间进行授权，以及如何交换授权信息以获取Access Token。Access Token是第三方应用访问用户资源的凭证，具有一定的有效期限。OAuth2的引入解决了传统授权方式中存在的安全性和可维护性问题，使得用户可以更加灵活和安全地授权第三方应用访问其资源。
OAuth2协议常用的授权方式包括：
授权码模式（Authorization Code Flow）：这是OAuth2中最常用的授权方式，适用于Web应用。在这种模式下，用户在客户端上登录，客户端通过用户授权后获取Access Token。简化模式（Implicit Flow）：适用于基于浏览器的移动应用。在这种模式下，客户端通过浏览器重定向到用户进行授权，然后获取Access Token。密码模式（Resource Owner Password Flow）：适用于某些特殊场景下的桌面应用和服务器端应用。在这种模式下，用户直接在客户端上输入其用户名和密码，然后客户端通过这些信息获取Access Token。客户端凭证模式（Client Credentials Flow）：适用于机器对机器之间的通信。在这种模式下，客户端提供其Client ID和Client Secret获取Access Token，然后使用该Token访问受保护的资源。 授权码模式 OAuth2授权码模式是一种最完整、流程最严密的授权模式。它主要分为四个步骤：授权请求、用户授权、获取授权码、获取AccessToken。下面我们将通过图文、代码相互结合的方式来说明OAuth2授权码模式的整个流程。
1、客户端发送授权请求
客户端（Client）首先向资源服务器（Resource Server）发送授权请求，请求中需要包含以下信息：
响应类型（Response Type）：指定请求的类型为"code"。客户端ID（Client ID）：客户端的唯一标识符。回调URL（Redirect URL）：用户授权后，资源服务器将重定向回调URL，并将授权码作为参数传递给它。 示例代码：
GET /authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI HTTP/1.1 Host: server.example.com 2、用户授权
资源服务器收到请求后，会跳转到客户端的回调URL，并将授权码作为参数传递给它。此时，用户需要在客户端的页面上输入自己的用户名和密码进行认证。客户端将用户名和密码发送给资源服务器，资源服务器验证用户身份后，将根据客户端的请求，决定是否授权给客户端。
3、获取授权码
如果资源服务器成功验证了用户身份并授权给客户端，它会将授权码（Code）作为参数传递给客户端的回调URL。客户端收到授权码后，将其保存到本地。
示例代码：
http://example.com/callback#code=AUTHORIZATION_CODE&amp;state=STATE 4、获取AccessToken
客户端将授权码发送给授权服务器（Authorization Server），请求获取AccessToken。请求需要包含以下信息：
授权码（Code）：通过资源服务器获取的授权码。客户端ID（Client ID）：客户端的唯一标识符。客户端秘钥（Client Secret）：客户端的秘钥，用于加密请求。认证服务器URL（Token URL）：授权服务器的访问令牌（Access Token）URL。 示例代码：
POST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded code=AUTHORIZATION_CODE&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=REDIRECT_URI 授权服务器收到请求后，将验证授权码的有效性，并生成一个Access Token返回给客户端。客户端收到Access Token后，就可以使用它来访问受保护的资源
简化模式 OAuth2简化模式是一种较为简单的授权模式，适用于公开的浏览器单页应用。相较于OAuth2授权码模式，简化模式少了获取code的步骤，是直接获取令牌token的。由于没有code安全保证，令牌容易因为被拦截窃听而泄露。
下面是OAuth2简化模式的详细步骤：
1、客户端发送授权请求
客户端（Client）向资源服务器（Resource Server）发送授权请求，请求中需要包含以下信息：
响应类型（Response Type）：指定请求的类型为"token"。客户端ID（Client ID）：客户端的唯一标识符。用户名（Username）：用户的用户名。密码（Password）：用户的密码。回调URL（Redirect URL）：用户授权后，资源服务器将重定向回调URL，并将令牌作为参数传递给它。 示例代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aedbe1e4a50d9d4aa13af6d499dbde6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e717a09a178b2d7a8b7a90ba91421d1c/" rel="bookmark">
			split()方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		split（）方法详解
1.split()主要是用于对一个字符串进行分割成多个字符串数组。标准形式为String [] strings = str.split(“”);
2.split()方法中括号中的参数可以为一个也可以为多个，每个参数之间用|隔开。并且每个参数之间要紧挨着|。
如：String [] strings = string.split(" |,|\?“);这里有三个参数：空格、逗号、问号。
3.像？.(点)（（正括弧））（反括弧）*（星号）|（竖线）等特殊符号都要在其前面加上\。
4.str.split(”");使用默认的情况下，split（）方法对每个字符进行分割。
5.当遇到连续的分隔符的时候
String s = “a,b,###c”
String[] ss = s.split(“,|#”);
system.out.println(ss.length);
打印的结果是：6
ss = {{“a”},{“b”},{“”},{“”},{“”},{“c”}};
为什么会出现3个空字符串呢？因为split当遇到分隔符的时候，就一直读取下一个字符直到遇到不是分隔符的字符为止。
这里当遇到b后面的“，”的时候，会接着读取后面的3个“#”知道遇到c为止。它会把第一个“，”去掉，然后用三个“”去
代替3个“#”。
注意：这里在程序中要把ss字符串数组中的“”去掉不能用==来判断而要用equals（）来判断。因为这里的字符串数组是在运行时产生的，他存放在堆区，不是在常量池中。
6.System.out.println(“🆎cd:ef::”.split(“:”).length);//末尾分隔符全部忽略
System.out.println(“🆎cd:ef::”.split(“:”,-1).length);//不忽略任何一个分隔符
System.out.println(StringUtils.split(“🆎cd:ef::”,“:”).length);//最前面的和末尾的分隔符全部都忽略,apache commons
System.out.println(StringUtils.splitPreserveAllTokens(“🆎cd:ef::”,“:”).length);//不忽略任何一个分隔符 apache commons
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/246a0e42e9f8393d6670b84db2729e67/" rel="bookmark">
			模型微调微调：了解如何将
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：禅与计算机程序设计艺术 模型微调微调：了解如何将机器学习模型优化到更高的性能 作为一名人工智能专家，模型微调微调是一个非常重要的技术，它可以帮助我们构建更高效的机器学习模型，从而提高我们的预测准确性和数据处理速度。在本文中，我们将深入探讨模型微调微调的原理、实现步骤以及优化与改进方法。
模型微调微调：技术原理及概念 2.1 基本概念解释 模型微调微调是一种对机器学习模型的调整和优化技术，通过调整模型参数、结构或权重分布，可以改善模型的性能和泛化能力。它可以帮助我们发现模型中可能存在的问题，并解决这些问题，从而提高模型的准确性和效率。
2.2 技术原理介绍：算法原理，操作步骤，数学公式等 模型微调微调可以分为以下几个步骤：
选择适当的优化算法：根据模型的特点和需求，选择适当的优化算法，如梯度下降、共轭梯度、Adam等。调整模型参数：根据模型的训练结果和优化算法的选择，调整模型参数，如学习率、激活函数、损失函数等。优化模型结构：根据模型的特点和需求，优化模型的结构，如网络结构、激活函数等。训练模型：使用优化后的模型进行训练，并记录模型的损失函数值和训练结果。评估模型：使用训练后的模型进行测试，评估模型的性能和泛化能力。调整模型参数：根据模型的训练结果和评估结果，调整模型参数，以提高模型的性能和泛化能力。 2.3 相关技术比较 常见的模型微调微调技术包括：
梯度下降（GD）：梯度下降是一种最基本的优化算法，它的核心思想是利用梯度来更新模型参数，以最小化模型的损失函数。然而，梯度下降存在一些问题，如全局最优点、陷入局部最优点等。共轭梯度（CDG）：共轭梯度是一种比梯度下降更快速的优化算法，它的核心思想是利用共轭梯度来更新模型参数，以最小化模型的损失函数。共轭梯度的主要优点是能够更快地找到模型的最优解，但仍然存在一些问题，如局部最优点等。Adam：Adam是一种新型的优化算法，结合了梯度和共轭梯度的思想，它能够在保证模型性能的同时，快速地更新模型参数。 实现步骤与流程 3.1 准备工作：环境配置与依赖安装 在实现模型微调微调之前，我们需要先准备环境，并安装相关的依赖库。
准备好环境之后，我们可以安装以下依赖库：
![image.png](https://github.com/tensorflow/tensorflow/raw/master/tensorflow/kernels/reference/python/tensorflow/python.py) ![image-2.png](https://github.com/tensorflow/tensorflow/raw/master/tensorflow/kernels/reference/python/tensorflow/python_model_selection.py) ![image-3.png](https://github.com/tensorflow/models/blob/master/research/slim/slim.h) ![image-4.png](https://github.com/ultralytics/轻量级深度学习/blob/master/experimental/pyod_imports.py) 3.2 核心模块实现 在实现模型微调微调的核心模块时，我们需要根据模型的需求和特点，编写相应的代码，以完成模型的微调工作。
以一个简单的神经网络模型为例，我们可以编写以下代码：
import tensorflow as tf from tensorflow.keras.layers import Dense # 定义模型结构 model = tf.keras.models.Sequential([ tf.keras.layers.Dense(0.1, activation='tanh', input_shape=(10,)), tf.keras.layers.Dense(0.01, activation='relu'), tf.keras.layers.Dense(1) ]) # 编译模型 model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy']) 3.3 集成与测试 在集成模型时，我们需要将模型集成到一起，并使用测试数据集对模型进行测试，以评估模型的性能和泛化能力。
以一个简单的神经网络模型为例，我们可以编写以下代码：
# 准备测试数据集 test_data = tf.keras.preprocessing.data.Dataset.from_tensor_slices((100, 0.1, 0.01)) # 测试模型 test_loss, test_acc = model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/246a0e42e9f8393d6670b84db2729e67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca42b498b87d164c856f420736262fbe/" rel="bookmark">
			1.天气预报数据爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要通过接口返回的数据得到各个城市的气象站码，并保存csv文件。实现代码如下：
#获取城市气象站信息（编码，名称，经纬度，该函数只需要执行一次即可） import csv import json from datetime import time import requests def main(): url = "https://weather.cma.cn/api/map/weather/1?t=1679576188443" res = requests.get(url) res.encoding = 'utf-8' data = res.text data = json.loads(data) code = open(f"data/city_code.csv", mode="w", newline='', encoding="utf-8") city_code = csv.writer(code) for city in data["data"]["city"]: cityCode = city[0] pro = city[1] latitude = city[4] longitude = city[5] city_code.writerow([cityCode,pro,latitude,longitude]) #获取城市气象站信息（编码，名称，经纬度，该函数只需要执行一次即可） if __name__ == '__main__': main() 然后通过读取保存的csv文件的内容，通过气象站码获取返回的html文件，使用BeautifulSoup来进行解析，并将得到的结果保存csv文件，随后读取csv文件，将结果存储进mysql中，使用定时调度来进行定时执行。完整代码如下：
# coding=gbk # 获取小时数据以及实时数据 import csv from datetime import datetime import json import re import time import pandas as pd import mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca42b498b87d164c856f420736262fbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3f14b4ac3ea6bb5a69e3ecd416ea90/" rel="bookmark">
			【C语言】计算机是如何存储整数和小数的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、正整数和0二、负整数三、小数1、定点数（1）什么是定点数（2）表示精度（3）表示范围（4）优缺点 2、浮点数（1）什么是浮点数（2）将小数转为浮点数（3）浮点数在计算机中的存储格式（4）浮点数中的指数部分如何存入计算机（5）表示精度（6）表示范围（7）优缺点 四、答疑1、定点数表示法已经被淘汰了吗？2、为什么说整数的存储其实也是用定点数存储格式？3、硬件FPU单元 参考资料 前言 一条数轴上的数可以分为整数和小数，整数包括正整数、负整数和0，小数也包括正小数和负小数。
人类借助"+“、”-“、”."、"0~9"等符号以及约定俗成的摆放顺序来表示和存储不同的数字。
但计算机只认识0和1，要想在计算机中表示和存储不同的数字，就需要借助一套完整的存储规则。
对于不同类型的数字，存储规则也是不一样的。
一、正整数和0 正整数和0在计算机中的表示方法最为简单，就是转化的二进制数本身。
如3在计算机中就表示为0000_0011。
二、负整数 先说答案，负整数在计算机中采用补码表示。
转化过程：
先取得负整数绝对值的二进制形式（注意符号位为1），得到原码，按位取反（符号位不用管）得到反码，再加1即可得到补码。
举一个例子：
-7的原码为1000_0111，反码为1111_1000，补码为1111_1001。
问：为什么负数要以这样的形式存储在计算机中呢？
答：为了方便进行数值运算。如要实现-7+3 = -4，
在计算机中是这样进行的：
1111_1001 + 0000_0011 = 1111_1100
而-4的原码为1000_0100，反码为1111_1011，补码为1111_1100，这样就跟上面的计算结果相吻合了。
而如果不用补码，假设用1000_0111表示-7，其中左边第一位为符号位，那进行如下计算：
1000_0111 + 0000_0011 = 1000_1010，结果并不能表示-4。
这里涉及补码向十进制的转换，反过来就行：
-4的补码为1111_1100，先减一，为1111_1011，按位取反为1000_0100，即-4的原码。
三、小数 先说答案，现代计算机采用浮点数的方式保存小数。
但早期的计算机使用定点数的方式保存小数。
1、定点数 （1）什么是定点数 注意：定点数不是指一类数字，而是指一种小数在计算机中的存储方法。
定点数就是指小数点位置不动的小数存储方式。
定点数存储法其实就是将小数直接转化为二进制存储在计算机中。这跟正整数和0的存储方法是一样的，其实正整数和0也是按照定点数的方式存储的，只是此时小数部分全为0省略了而已。
如用8bit空间存储定点数，约定前4位为整数部分，后4位为小数部分。很显然这样小数点的位置就固定在了第3位和第4位之间。
这样做的好处就在于能一眼看出所要表示的数字。
比如这里就能一眼看出所要表达的小数为1011.0111
转化为十进制就是：
现在我们来分析定点数表示法的精度和范围。
（2）表示精度 首先精度在这里就是表示数学上的准确数值与计算机中实际存储的数值的误差。
为了说明这个误差有时候是不可避免的，我举一个例子：
数学上的π是一个无限不循环小数，要存储它理论上需要一块无限大的空间，但这是不可能的，计算机的存储空间是有限的，因此只能存储π的近似值，由此误差就产生了。
以上面的8bit空间为例，其中4位表示小数，因此这种情况下精度是1/16，即0.0625。
这里结合之前写的博文【科普】精度和分辨率的区别与联系
可以知道，由于没有系统误差，因此这里的精度等价于分辨率。
这样就好理解了，4位小数的分辨率就是1/16。
（3）表示范围 如上所述的8bit空间可以存储的最大数字为1111_1111=8+4+2+1+1/2+1/4+1/8+1/16=15.9375
最小可以表示的正数为0000_0001=1/16=0.0625。
（4）优缺点 优点：
——简单易懂：定点数表示法相对于其他复杂的表示方法（如浮点数）来说更加简单和直观，易于理解和实现。
——固定精度：定点数具有固定的位数来表示整数和小数部分，因此精度是固定的。这在某些应用中可能是有益的，可以保持一致的精度。
——运算速度快：相比于浮点数运算，定点数运算通常更加高效，因为定点数的运算只涉及整数运算，无需处理浮点数的特殊规则。
缺点：
——固定精度：虽然固定精度是定点数的一个优点，但在某些情况下也可能成为缺点。当处理非常大或非常小的数值时，固定的精度可能不足以保持所需的准确性，导致舍入误差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc3f14b4ac3ea6bb5a69e3ecd416ea90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7f792d69c7199d7958d47237e2c44f/" rel="bookmark">
			在Android Studio 中运行React Native 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目根目录执行命令安装开发依赖
yarn 检查项目SDK、NDK、JDK否配置正确
点击 Android Studio 里点击大象
全部下载完毕，点击运行按钮，编译项目
连接真机的两种方式 无线连接
adb devices adb tcpip 5555 #连接端口默认5555 adb connect 192.168.0.102:5555	#要连接的真机的IP地址 adb -s 192.168.0.102:5555 reverse tcp:8081 tcp:8081 npx react-native start USB连接
adb reverse tcp:8081 tcp:8081 npx react-native start 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f30e172009818cb08a086dd6bd38824/" rel="bookmark">
			request请求封装参考 重复提交 导出excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若依
import axios from 'axios'
import { Notification, MessageBox, Message, Loading } from 'element-ui'
import store from '@/store'
import { getToken } from '@/utils/auth'
import errorCode from '@/utils/errorCode'
import { tansParams, blobValidate } from "@/utils/ruoyi";
import cache from '@/plugins/cache'
import { saveAs } from 'file-saver'
let downloadLoadingInstance; // 是否显示重新登录 export let isRelogin = { show: false }; axios.defaults.headers['Content-Type'] = 'application/json;charset=utf-8' // 创建axios实例 const service = axios.create({ // axios中请求配置有baseURL选项，表示请求URL公共部分 baseURL: process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f30e172009818cb08a086dd6bd38824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba1549862e9e1bb057fa316a149deb9/" rel="bookmark">
			Navicat for MongoDB 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、连接
二、终端启动 mongod，再打开连接
三、项目中使用 - 记账本案例
（1）创建 config 、db、models 文件
参照：https://blog.csdn.net/LQS000/article/details/131447972
按需修改模型文件： AccountModel.js
（2）导入 db 函数
（3）操作数据
按需安装 moment 转时间格式： npm i moment
新增数据
读取数据库
删除数据
删除弹窗示例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8540ac4ea5f193782870f3026749d198/" rel="bookmark">
			教你一步步创建属于自己的Python爬虫代理IP池（含代码示例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在进行网络数据采集时，遇到反爬虫限制是常见的问题。使用代理IP可以帮助我们绕过这些限制，保护自己的爬虫程序。本文将教您如何使用Python创建属于自己的代理IP池，以便获取可用的代理IP并应用于 Python爬虫程序。同时，我们将提供代码示例，帮助您一步步实现一个完整的代理IP池。
步骤一：获取代理IP
首先，我们需要从可信赖的代理IP供应商或免费代理IP网站获取代理IP列表。以下是一个示例代码，使用Requests库从代理IP网站上获取代理IP：
import requests def get_proxy_ips(): url = 'https://example.com/proxy-ips' # 替换为代理IP网站的URL response = requests.get(url) if response.status_code == 200: proxy_ips = response.json() # 假设返回的是JSON格式数据 return proxy_ips else: return [] proxy_ips = get_proxy_ips() 步骤二：验证代理IP的有效性
接下来，我们需要验证获取的代理IP的有效性。以下是一个示例代码，使用Requests库对代理IP进行连通性测试：
import requests def test_proxy_ip(proxy_ip): url = 'https://example.com' # 替换为需要测试的目标网站URL proxies = { 'http': f'http://{proxy_ip}', 'https': f'https://{proxy_ip}' } try: response = requests.get(url, proxies=proxies, timeout=10) if response.status_code == 200: return True except: pass return False valid_proxy_ips = [] for proxy_ip in proxy_ips: if test_proxy_ip(proxy_ip): valid_proxy_ips.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8540ac4ea5f193782870f3026749d198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d6c3b6606c64636eb552826ee4a0b5/" rel="bookmark">
			OpenStack架构中核心的组件及其作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）Nova——又被称为OpenStack Compute，主要作用是控制虚拟机的创建，以及改变虚拟机的容量和配置，还可以做虚拟机的销毁，虚拟机的整个生命周期都是由Nova来控制的。一般将Nova部署到计算节点上，在实验环境中也可部署在Controller节点上运行。
（2）Cinder——Cinder组件主要的用途是提供块存储服务，最核心的两个部分是Scheduler和Cinder Volume。当有读/写存储服务请求时，Scheduler决定请求通过哪个Cinder Volume进行读取操作，Cinder Volume是实际控制存储的设备。
（3）Neutron——管理网络资源，提供一组应用编程接口（API），用户可以调用它们来定义网络（如VLAN ），并把定义好的网络附加给租户。Networking是一个插件式结构，支持当前主流的网络设备和最新网铬技术。
（4）Swift——从OpenStack诞生就有Swift组件，NoSQL数据库为虚拟机提供非结构化数据存储，它把相同的数据存储在多台计算机上，以确保数据不会丢失。用户可通过RESTful和HTTP类型的API来与它通信。
（5）Glance——存取虚拟机磁盘镜像文件，Compute服务在启动虚拟机时需要从Glance获取镜像文件。这个组件不同于上面的Swift和Cinder，这两者提供的存储是在虚拟机中使用的。
（6）Keystone——为其他服务提供身份验证、权限管理、令牌管理及服务名册管理。若要使用云计算的所有用户事先需要在Keystone中建立账号、设置密码，并定义权限。另外，OpenStack服务（如Nova、Neutron、Swift、Cinder等）包括Keystone也要在里面注册，并且登记具体的API。
Openstack基础八大核心组件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6644c852e43ca083306c89f21a395604/" rel="bookmark">
			操作系统4：进程通信类型和通信实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、进程通信的类型
（1）共享存储器系统(Shared-Memory System)
（2）管道(pipe)通信系统
（3）消息传递系统(Message passing system)
（4）客户机-服务器系统(Client-Server system)
4.1 - 套接字(Socket)
4.2 - 远程过程调用和远程方法调用
2、消息传递通信的实现方式
（1）直接消息传递系统
1.1 - 直接通信原语
1.2 - 消息的格式
1.3 - 进程的同步方式
1.4 - 通信链路
（2）信箱通信
2.1 - 信箱的结构
2.2 - 信箱通信原语
3.3 - 信箱的类型
3、直接消息传递系统实例
（1）消息缓冲队列通信机制中的数据结构
（2）发送原语
（3）接收原语
进程通信是指进程之间的信息交换。由于进程的互斥与同步，需要在进程间交换一定的信息，所以它们也是一种进程通信，但只是一种低级的进程通信。比如信号量机制，该机制通信低级的原因在于：
效率低：生产者每次只能向缓冲池投放一个产品(消息)，消费者每次只能从缓冲区中取得一个消息。//数据量少通信对用户不透明：OS 只为进程之间的通信提供了共享存储器。而关于进程之间通信所需之共享数据结构的设置、数据的传送、进程的互斥与同步，都必须由程序员去实现，显然，对于用户而言，这是非常不方便的。//过程繁琐 在进程之间要传送大量数据时，应当利用 OS 提供的高级通信工具，该工具最主要的特点是：
高效地传送大量数据。用户可直接利用高级通信命令(原语)高效地传送大量的数据。//数据量大使用方便。OS 隐藏了实现进程通信的具体细节，向用户提供了一组用于实现高级通信的命令(原语)，用户可方便地直接利用它实现进程之间的通信。或者说，通信过程对用户是透明的。这样就大大减少了通信程序编制上的复杂性。//使用简单 1、进程通信的类型 随着 OS 的发展，用于进程之间实现通信的机制也在发展，并已由早期的低级进程通信机制发展为能传送大量数据的高级通信工具机制。目前，高级通信机制可归结为四大类：共享存储器系统、管道通信系统、消息传递系统以及客户机-服务器系统。
（1）共享存储器系统(Shared-Memory System) 在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。据此，又可把它们分成以下两种类型：//共享存储
基于共享数据结构的通信方式。在这种通信方式中，要求诸进程共用某些数据结构，借以实现诸进程间的信息交换，如在生产者-消费者问题中的有界缓冲区。操作系统仅提供共享存储器，由程序员负责对公用数据结构的设置及对进程间同步的处理。这种通信方式仅适于传递相对少量的数据，通信效率低下，属于低级通信。//数据量少-&gt;使用共享存储器基于共享存储区的通信方式。为了传输大量数据，在内存中划出了一块共享存储区域，诸进程可通过对该共享区的读或写交换信息，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是 OS。这种通信方式属于高级通信。需要通信的进程在通信前，先向系统申请获得共享存储区中的一个分区，并将其附加到自己的地址空间中，便可对其中的数据进行正常读、写，读写完成或不再需要时，将其归还给共享存储区。//数据量大-&gt;使用内存 （2）管道(pipe)通信系统 所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件。
向管道(共享文件)提供输入的发送进程(即写进程)以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)则从管道中接收(读)数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。//管道通信原理
这种方式首创于 UNIX 系统，由于它能有效地传送大量数据，因而又被引入到许多其它操作系统中。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6644c852e43ca083306c89f21a395604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ff774cd58e54f71eb34852d13065962/" rel="bookmark">
			js前端获取用户位置及ip属地信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面尝试一：navigator.geolocation尝试二：sohu 的接口尝试三：百度地图的接口写在后面 写在前面 想要像一些平台那样显示用户的位置信息，例如某省市那样。那么这是如何做到的， 据说这个位置信息的准确性在通信网络运营商那里？先不管，先实践尝试下能不能获取。
尝试一：navigator.geolocation 尝试了使用 navigator.geolocation，但未能成功拿到信息。
getGeolocation(){ if ('geolocation' in navigator) { /* 地理位置服务可用 */ console.log('地理位置服务可用') navigator.geolocation.getCurrentPosition(function (position) { console.dir('回调成功') console.dir(position) // 没有输出 console.dir(position.coords.latitude, position.coords.longitude) }, function (error) { console.error(error) }) } else { /* 地理位置服务不可用 */ console.error('地理位置服务可用') } } 尝试二：sohu 的接口 尝试使用 pv.sohu.com/cityjson?ie… 获取用户位置信息， 成功获取到信息，信息样本如下：
{"cip": "14.11.11.11", "cid": "440000", "cname": "广东省"}
// 需要做跨域处理 getIpAndAddressSohu(){ // config 是配置对象，可按需设置，例如 responseType，headers 中设置 token 等 const config = { headers: { Accept: 'application/json', 'Content-Type': 'application/json;charset=UTF-8', }, } axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ff774cd58e54f71eb34852d13065962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925124181d504c2f6ffbd51fc27d7da2/" rel="bookmark">
			gin框架：微信公众号-服务器配置（token验证）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导入包
import ( "github.com/gin-gonic/gin" "net/http" ) 2.设置路由。
// 处理微信公众号校验服务器地址 r.GET("/wechat/verify", verifyHandler) // 处理微信公众号消息接收地址 r.POST("/wechat/receive", receiveHandler) 3.需要根据微信公众号开发文档提供的规则进行签名校验，并返回echostr给微信服务器。
func verifyHandler(c *gin.Context) { token := "your_wechat_token" // 替换成你自己的token signature := c.Query("signature") timestamp := c.Query("timestamp") nonce := c.Query("nonce") echostr := c.Query("echostr") if checkSignature(token, signature, timestamp, nonce) { c.String(http.StatusOK, echostr) } else { c.String(http.StatusBadRequest, "Invalid request") } } func checkSignature(token, signature, timestamp, nonce string) bool { // 根据微信公众号开发文档提供的规则进行签名校验 // 返回 true 或 false return true // 在这里替换成你的签名校验逻辑 } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/925124181d504c2f6ffbd51fc27d7da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293b636e6447d8a6e5c8a3015be2a9f1/" rel="bookmark">
			PolicyGradient算法玩CartPole和MountainCar代码Pytorch版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接 代码参考了莫烦python的policy gradient算法，特别感谢！！！
库版本号 gym0.26.2
gym-notices 0.0.8
pytorch 1.11.0 + cu115
python 3.8.12
gym0.26.2版本用法略有不同，涉及到step函数、render函数渲染图像方法，我会额外开一篇帖子介绍
PolicyGradient决策代码 玩CartPole倒立摆和玩MountainCar的PolicyGradient算法决策代码是一样的，也就是下面的RL_brain.py文件
import torch import torch.nn as nn import torch.nn.functional as F import numpy as np np.random.seed(1) torch.manual_seed(1) class NetWork(nn.Module): """ 神经网络结构 # 全连接1 # 全连接2 # ReLU """ def __init__(self, n_actions, n_features, n_neuron=10): super(NetWork, self).__init__() self.net = nn.Sequential( nn.Linear(in_features=n_features, out_features=n_neuron, bias=True), nn.Linear(in_features=n_neuron, out_features=n_actions, bias=True), nn.ReLU() ) def forward(self, x): return self.net(x) class PolicyGradient: """ PolicyGradient算法 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/293b636e6447d8a6e5c8a3015be2a9f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5543fbb97eb798de1e33394c5eac6d/" rel="bookmark">
			SQL多列合并成一列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、拼接多列数据的基本概念 在SQL中，拼接多个列数据成为一列数据是很常见的问题。要将多列合并成一列，在SQL语言中需要使用concat函数。concat函数可以将多个字符串拼接成为一个字符串输出。concat函数的格式为concat(string1,string2,...)。
其中，string1，string2，…为需要拼接的字符串。concat函数将按照所填写的参数顺序，将各个参数字符串按照顺序拼接成为一个大字符串。例如，若输入concat(‘Hello’,‘World’)，那么输出为HelloWorld。
SELECT CONCAT(‘Hello’, ‘World’); 二、使用concat函数拼接多列数据 在SQL语言中，如果需要将多列数据合并为一列数据，只需要将多个列名称作为参数填入concat函数中即可。以下是一个简单的示例：
SELECT CONCAT(First_Name,‘ ’,Last_Name) AS Name FROM Employees; 以上代码将First_Name和Last_Name两列数据用空格隔开并拼接成为一列标记为Name的新数据列。此时，新的数据列Name的每一行数据均为拼接后的数据。如果想要添加分隔符，可以在需要添加分隔符的参数中加入分隔符：
SELECT CONCAT(First_Name,‘-’,Last_Name) AS Name FROM Employees; 三、使用concat_ws函数拼接多列数据 SQL还提供了一个特殊的函数——concat_ws。与普通的concat函数不同的是，concat_ws函数可以使用指定的分隔符拼接多个参数，并在输出值中使用该分隔符分割。以下是一个简单的示例：
SELECT CONCAT_WS(' ',First_Name,Last_Name) AS Name FROM Employees; 以上代码将使用空格作为分隔符，将First_Name和Last_Name两列数据拼接成为一个新的数据列Name。新的数据列中各行的名称均由空格隔开。
四、使用CASE函数拼接多列数据 除了concat函数和concat_ws函数以外，SQL还提供了一种更为灵活的拼接多个数据列的方式——使用CASE函数。
CASE函数可以帮助我们为每一行数据自定义生成一个新的数据列。如果需要将多列数据中的一个或多个列拼接起来，可以使用CASE函数将数据列进行分组，然后使用concat函数或concat_ws函数将分组后的数据列拼接成一个新的数据列。以下是使用CASE函数拼接多列数据的示例：
SELECT CASE WHEN Gender = 'M' THEN CONCAT_WS(' ', First_Name, Middle_Initial, Last_Name) ELSE CONCAT_WS(' ', Last_Name, First_Name, Middle_Initial) END AS FullName FROM Employees; 以上代码用于在Employees表中生成一个FullName数据列。如果Gender列的值为M，那么FullName数据列将包含First_Name、Middle_Initial和Last_​​Name三个数据列用空格拼接而成的字符串；如果Gender列的值不是M，那么FullName数据列将包含Last_Name、First_Name和Middle_Initial三个数据列用空格拼接而成的字符串。
五、使用COALESCE函数拼接多列数据 在使用上述的拼接函数时，如果有某个列的值为NULL，那么会导致整个拼接字符串的输出结果也为NULL。如果想要避免这种情况，可以使用COALESCE函数。
COALESCE函数可以将参数列表中的第一个非NULL值返回。以下是一个简单的示例：
SELECT COALESCE(NULL, ‘Hello’, ‘World’); 以上代码将输出Hello。
在使用COALESCE函数拼接多列数据时，如果某些列的值为空，则可以通过使用COALESCE函数，将空值替换为默认值。以下是一个使用COALESCE函数拼接多列数据的示例：
SELECT CONCAT_WS(' ', COALESCE(First_Name,''), COALESCE(Middle_Initial,''), COALESCE(Last_Name,'')) AS FullName FROM Employees; 以上代码将使用空值替换任何为NULL的列值，并将FirstName、Middle_Initial和Last_​​Name三列数据用空格隔开，并拼接成一个称为FullName的新数据列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab5543fbb97eb798de1e33394c5eac6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663b92e67090e41662262b993c9e1804/" rel="bookmark">
			img标签上title与alt属性的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的img标签中有title和alt两个属性，那么他们分别是什么呢？又有哪些区别呢？
一、什么是title属性？
title属性是global attribute之一，作用是提供建议性的信息，通常是鼠标滑动到元素上是显示。
title属性可以用在除了base，basefont，head，html，meta，param，script和title之外的所有标签。title属性可以为链接添加描述性文字，来更加清楚的表达链接的目的。
效果如下：
&lt;img src="~assets/images/svg/record_noData.svg" title="暂无数据记录" /&gt; 二、什么是alt属性？
alt属性，是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示或读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。
作用是当无法显示文档中的图片是，可以为浏览者提供文字说明，是用来替代图片的，而不是提供额外说明文字的。
效果如下：
&lt;img src="assets/images/svg/record_noData.svg" alt="图片未显示出来" /&gt; 三、两者的区别
替换文字（alt text）并不是用来做提示（tool tip），或者更加确切的说，它并不是为图片提供额外说明信息的。相反地，title属性才应该用来为元素提供额外说明信息。
人生海海，码途徐徐，在每一段经历中，留下成长的印记，爱自己爱生活爱思考！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e650b3afb572f3e32f2e41218bc7b7/" rel="bookmark">
			Mac 错误zsh: command not found: brew解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用如下命令： /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"
敲击完毕后输入 1 然后 yes 并 属于自己的密码 后 等待安装即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a78bf6e124952d2dfadf0cc1a30da7/" rel="bookmark">
			vue集成海康威视H5视频播放器（H5player）开发包 V2.1.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康开放平台地址：https://open.hikvision.com/download/5c67f20bb254d61550c2f63e?type=10 1.首先下载开发包
2.将开发包bin目录下的文件放入public目录下（我这里是放入了public/static目录下）
3.在public/index.html文件下引入
&lt;script src="static/h5player.min.js"&gt;&lt;/script&gt; 4.html标签给一个id
&lt;div id="player"&gt;&lt;/div&gt; 5.在src/utils下也放入一个h5player.min.js，方便后面引用。在使用页面引入js
import '@/utils/h5player.min.js' 6.在data声明初始变量player
data() { return { // 播放器对象 player: null } }, 7.初始化播放器，事件初始化，实现播放
&lt;div id="player"&gt;&lt;/div&gt; &lt;script&gt; import '@/utils/h5player.min.js' export default { data() { return { // 播放器对象 player: null } } mounted() { this.$nextTick(() =&gt; { this.initPlayer() }) } methods: { /** * 初始化播放器 */ initPlayer() { this.player = new window.JSPlugin({ // 需要英文字母开头 必填 szId: 'player', // 必填,引用H5player.min.js的js相对路径 szBasePath: '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58a78bf6e124952d2dfadf0cc1a30da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60b508eeef5c55e70e46ceedf91e6eb/" rel="bookmark">
			【探索 Kubernetes|作业管理篇 系列 15】DaemonSet 的”过人之处“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，我是秋意零。
在上一篇中，我们讲解了 StatefulSet 的存储状态；我们发现，它的存储状态，就是利用了 PV 与 PVC 的设计。StatefulSet 自动为我们创建 PVC 并且以 &lt;pvc-name&gt;-&lt;pod-name&gt;-&lt;编号&gt;命名，从而始终与 Pod 编号名一致的绑定。
需要注意的是：StatefulSet 的“滚动更新”是从最后一个 Pod 开始的，为了不破坏拓扑状态。如：主从数据库，主的 Pod 编号是 0，后面是从，如果先更新主数据库 0 编号，那么后面的从数据库就会出现问题。
StatefulSet 的“滚动更新”还允许我们进行更精细的控制，比如：金丝雀发布（Canary Deploy）或者灰度发布，这意味着应用的多个实例中被指定的一部分不会被更新到最新的版本。
StatefulSet 的 partition 字段设置为 2，那么编号小于 2 的 Pod 是不会进行镜像更新的。
$ kubectl patch statefulset mysql -p '{"spec":{"updateStrategy":{"type":"RollingUpdate","rollingUpdate":{"partition":2}}}}' statefulset.apps/mysql patched 今天的内容是 DaemonSet 控制器。
👿 简介
🏠 个人主页： 秋意零🧑 个人介绍：在校期间参与众多云计算相关比赛，如：🌟 “省赛”、“国赛”，并斩获多项奖项荣誉证书🎉 目前状况：24 届毕业生，拿到一家私有云（IAAS）公司 offer，暑假开始实习🔥 账号：各个平台， 秋意零 账号创作者、 云社区 创建者💕欢迎大家：欢迎大家一起学习云计算，走向年薪 30 万 系列文章目录 【云原生|探索 Kubernetes-1】容器的本质是进程
【云原生|探索 Kubernetes-2】容器 Linux Cgroups 限制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b60b508eeef5c55e70e46ceedf91e6eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa91830d15116ff17c5839eeb6a2de2/" rel="bookmark">
			中安网星版大模型来了！三大关键能力，不输专业红队攻击手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的快速发展，网络规模的不断扩大，互联网边界日趋模糊，网络安全问题给日常办公和企业运营等带来了严重挑战。网络安全事件报警也日趋增多，所以亟需一种集合关联分析、安全信息收集、报警信息预处理、安全事件验证和攻击场景重构、攻击过程推演等功能的大模型来约减冗余警报、剔除虚假警报。
为此中安网星在安全领域大模型进行研发，以国产开源大模型为蓝本，以中安网星在AD、IAM等身份领域积累的100tb的攻击数据为基石，以参数量级达到60亿的模型为基础，以高质量网络安全知识和丰富网络安全事件为训练数据。通过对大模型量化、剪枝，蒸馏开发出netstar GPT，并深度融合至中安网星ITDR平台中。在保证其功能的前提下实现本地化部署，实现数据不出网、不上云、0新增攻击面，并实现以下功能：
一、告警降噪
该功能旨在为企业提供全面的安全解决方案，涵盖了告警数据分析、风险提示和后续攻击预警功能。依靠强大的模型计算与推理能力，帮助企业应对不断变化的安全威胁，并保护其关键资产和敏感信息。
1.告警数据分析
首先，融合了GPT的ITDR平台能够进行告警数据分析。可以有效地处理大量的告警信息，并利用其经过海量数据训练的算法和态势感知技术，从中提取出潜在的安全风险。通过分析告警的级别、趋势和关联性，模型能够快速准确地识别出真正需要关注的事件，帮助运营人员判断误报和提高响应效率。
2.风险提示
其次，ITDR提供了风险提示功能。一旦模型识别出风险事件，它将对其进行评估和分类，并生成详细的风险预警。这些预警将包含风险的严重程度、可能的影响以及推荐的应对措施和建议。通过及时的预警提示，运营人员能够快速采取相应的措施来应对潜在的威胁，最大程度地降低损失和风险。
3.后续攻击预警
最后，ITDR平台还能够进行后续攻击预警。它基于历史攻击数据和实时数据分析，能够识别出可能的攻击趋势和攻击者的行为模式。通过已经识别到的攻击对即将发生的攻击进行预警，企业可以提前做好准备，加强系统和网络的安全防护措施，阻止潜在的攻击行为，并保护重要的业务和敏感数据。
二、基线检查，攻击推演
netstar GPT具备基线检查的功能。它能够对域内环境、网络和主机等关键基础设施进行全面的安全检查。通过与预先设定的基线进行比对，模型能够及时发现与正常状态有所偏离的设置，从而识别出潜在的安全漏洞和风险点。
同时凭借自身强大的算力以及庞大的攻击数据样本可以就当前基线配置，进行攻击推演拟合出攻击线路，运营人员可以采取针对性的措施来加固安全防护，斩断攻击路径中的关键节点，保护其关键资产免受攻击的同时避免对业务的流畅性造成影响。
三、权限分析，风险预知
netstar GPT具备自动权限分析的功能。它能够对域内所有用户、计算机、OU等权限进行实时分析，凭借GPT多层数据深度分析的能力，及时预知域内权限配置中的不合理权限及隐藏的后门风险，保护域内对象权限免受高级的攻击威胁。
四、智能应答
netstar GPT可以结合本地挂载的知识库实现安全领域相关的智能应答。得益于中安网星深耕身份领域的积累，当前本地知识储备已达到专业红队攻击手的水平，融合了GPT的ITDR平台相当于一个具备多年安全攻防领域经验的安全专家为您提供7×24小时的专业驻场服务，随时为您解决所有的安全问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c0283f5e985ae3a9de812c0610bbd9/" rel="bookmark">
			【计算机视觉 | 目标检测】Open-Vocabulary DETR with Conditional Matching论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、导读二、介绍三、Open-Vocabulary DETR3.1 重新审视DETR中的闭集匹配3.2 最优二部匹配 四、Conditional Matching for Open-Vocabulary Detection4.1 Conditional Inputs4.2 Conditional Matching 五、Inference六、实验 一、导读 论文题目：具有条件匹配的开放词汇表DETR
开放词汇对象检测是指在自然语言的引导下对新对象进行检测的问题，越来越受到社会的关注。理想情况下，我们希望扩展一个开放词汇表检测器，这样它就可以基于自然语言或范例图像形式的用户输入生成边界框预测。这为人机交互提供了极大的灵活性和用户体验。为此，我们提出了一种新的基于DETR的开放词汇检测器，因此命名为OV-DETR，一旦训练，它可以检测任何给定其类名或样本图像的对象。
将DETR转变为开放词汇检测器的最大挑战是，如果不访问新类的标记图像，就不可能计算新类的分类成本矩阵。为了克服这一挑战，我们将学习目标制定为输入查询(类名或示例图像)与相应对象之间的二进制匹配目标，从而学习有用的对应关系，以便在测试期间推广到未见过的查询。对于训练，我们选择将Transformer解码器设置在从预训练的视觉语言模型(如CLIP)获得的输入嵌入上，以便对文本和图像查询进行匹配。通过在LVIS和COCO数据集上的大量实验，我们证明了OV-DETR—第一个端到端基于变压器的开放词汇检测器——比目前的技术水平取得了重大改进。
在计算机视觉中，“binary matching”（二进制匹配）通常指的是一种图像特征匹配的方法，用于比较两幅图像之间的相似性。
具体来说，二进制匹配常用于描述二进制特征描述符，例如二进制局部二进制模式（Local Binary Patterns, LBP）或二进制描述子（Binary Descriptors）。这些特征描述符将图像中的局部区域编码为二进制形式，以表示该区域的纹理、形状或其他重要特征。
在二进制匹配的过程中，首先需要提取图像中的特征描述符，然后将其转换为二进制形式。对于每个描述符，会将其与其他描述符进行比较，以计算它们之间的相似性。通常使用一种距离度量（如汉明距离）来衡量两个二进制描述符之间的差异。如果二进制描述符之间的差异小于某个阈值，则认为它们匹配成功。
通过进行二进制匹配，可以在图像中找到相似的局部特征或对象，例如在目标检测、图像配准、物体识别和图像检索等领域中。二进制匹配方法通常具有计算效率高、鲁棒性好等特点，使其在实际应用中具有广泛的应用前景。
二、介绍 目标检测是一项基本的计算机视觉任务，旨在定位图像中具有紧密边界框的对象，由于深度学习的出现，在过去十年中取得了显著进展。然而，大多数目标检测算法在词汇量方面是不可扩展的，即它们仅限于检测数据集中定义的一组固定的目标类别。例如，在COCO上训练的对象检测器只能检测80个类，并且无法处理超出训练类的新类。
检测新类的一种直接方法是收集它们的训练图像并将其添加到原始数据集中，然后重新训练或微调检测模型。然而，由于数据收集和模型训练的巨大成本，这既不切实际又效率低下。
最近，开放词汇检测(open-vocabulary detection)，一种利用大型预训练语言模型的新公式，越来越受到社区的关注。现有工作的中心思想是将检测器的特征与在CLIP等大规模图像-文本对上预训练的模型提供的嵌入对齐。通过这种方式，我们可以使用对齐的分类器仅从描述文本中识别新类。
使用 conditional queries 的基于rpn的检测器和基于OpenVocabulary transformer的检测器(OV-DETR)之间的比较。在闭集对象类上训练的RPN很容易忽略新类(例如，“猫”区域接收到的响应很少)。因此，这个例子中的猫在很大程度上被忽略了，几乎没有建议。相比之下，我们的OV-DETR被训练来执行条件查询与其对应框之间的匹配，这有助于学习可以推广到来自未见类的查询的对应关系。注意，我们可以以文本(类名)或范例图像的形式接受输入查询，这为开放词汇表对象检测提供了更大的灵活性。
现有开放词汇检测器的一个主要问题是，它们依赖于region proposals，由于缺乏训练数据，通常不可靠地覆盖图像中的所有新类别，参见图1(A)。最近的一项研究也发现了这个问题，该研究表明，区域建议网络(RPN)的二值性很容易导致对已知类别的过拟合(从而无法推广到新的类别)。
在本文中，我们提出在Transformer框架下训练端到端的开放词汇检测器，目的是在不使用中间RPN的情况下，提高新类别的泛化能力。为此，我们提出了一种新的基于DETR的开放词汇检测器—因此被命名为OV-DETR—它被训练来检测给定类名或样本图像的任何对象。这将比仅从自然语言中进行传统的开放词汇检测提供更大的灵活性。
尽管端到端DETR训练很简单，但将其转换为开放词汇表检测器并非易事。最大的挑战是无法计算没有训练标签的新类的分类成本。为了克服这一挑战，我们将学习目标重新定义为输入查询(类名或样本图像)与相应对象之间的二元匹配。这种对不同训练对的匹配损失允许学习有用的对应关系，可以在测试期间推广到看不见的查询。对于训练，我们扩展了DETR的Transformer解码器以接受条件输入查询。
具体来说，我们根据预训练的视觉语言模型CLIP获得的查询嵌入来调整Transformer解码器，以便对文本或图像查询执行条件匹配。图1显示了这个高级思想，它在检测新类方面比基于rpn的闭集检测器更好。
我们在两个具有挑战性的开放词汇目标检测数据集上进行了全面的实验，并显示出性能的一致改进。具体而言，我们的OV-DETR方法在开放词汇LVIS数据集上实现了17.4个新类的mask mAP，在开放词汇COCO数据集上实现了29.4个新类的box mAP，分别比SOTA方法高出1.3 mAP和1.8 mAP。
三、Open-Vocabulary DETR 我们的目标是设计一个简单而有效的开放词汇对象检测器，它可以检测由任意文本输入或示例图像描述的对象。我们以DETR的成功为基础，将对象检测作为端到端集合匹配问题(在封闭类之间)，从而消除了对锚生成和非最大值抑制等手工组件的需求。这个管道使其成为构建端到端开放词汇表对象检测器的合适框架。
然而，将具有闭集匹配的标准DETR改造为开放词汇表检测器(需要对未见过的类进行匹配)是非常重要的。对于这种开集匹配，一种直观的方法是学习一个与类别无关的模块(例如，ViLD)来处理所有的类。但是，这仍然无法匹配那些没有标记图像的开放词汇表类。
引导我们将固定的集合匹配目标重新表述为条件输入(文本或图像查询)和检测输出之间的条件二进制匹配目标。
我们的开放词汇表DETR概述如下图所示。在高层次上，DETR首先将 query embeddings (文本或图像)作为从预训练的CLIP模型中获得的条件输入，然后对检测结果施加二值匹配损失来衡量它们的匹配性。
OV-DETR概述。与标准的DETR不同，我们的方法不会为一组封闭的类分离“对象”和“非对象”。相反，OV-DETR通过测量一些条件输入(来自CLIP的文本或示例图像嵌入)与检测结果之间的匹配性(“匹配”与“不匹配”)来执行开放词汇检测。我们展示了这种管道可以灵活地检测具有任意文本或图像输入的开放词汇表类。
3.1 重新审视DETR中的闭集匹配 对于输入图像 x x x，一个标准的 DETR 推断出 N N N 个对象预测 y y y，其中 N N N 由作为可学习位置编码的 object queries q q q 的固定大小决定。DETR 管道的单次传递由两个主要步骤组成：(i)集预测，(ii)最优二部匹配。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c0283f5e985ae3a9de812c0610bbd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2032b00d4e04890f59d138a5fb844d9d/" rel="bookmark">
			【计算机视觉 | 目标检测】术语理解7：二值匹配（Binary Matching），DETR中的Object query的理解，匈牙利算法，DETR中的二分图匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、二值匹配（Binary Matching）二、DETR中的Object query的理解三、匈牙利算法四、DETR中的二分图匹配 一、二值匹配（Binary Matching） 当涉及到计算机视觉中的二值匹配（Binary Matching），它是一种用于比较和匹配二值图像的技术。二值图像由黑色和白色像素组成，每个像素只有两种可能的取值。二值匹配的目标是确定两个二值图像之间的相似度或匹配度。
以下是几种常见的二值匹配方法：
汉明距离：通过逐像素比较两个二值图像，计算它们之间的汉明距离。汉明距离是指两个等长字符串之间对应位置不同字符的个数。对于二值图像，可以将每个像素看作一个字符，并计算不同像素的个数。结构化匹配：将二值图像分割成小的区域或块，并比较它们之间的结构和特征。常见的结构化匹配方法包括形态学操作（如腐蚀、膨胀、开运算、闭运算等）、连通区域分析和轮廓匹配。特征描述子匹配：通过提取图像中的特征描述子，如局部二进制模式（Local Binary Patterns，LBP）、方向梯度直方图（Histogram of Oriented Gradients，HOG）等，并使用相应的匹配算法进行比较。这些特征描述子能够捕捉图像的局部纹理和形状信息，用于匹配和识别。模板匹配：将一个小的二值模板图像与待匹配图像进行滑动窗口的方式进行比较。通过计算模板与图像区域之间的相似度来确定匹配位置。常见的模板匹配方法包括平方差匹配、归一化互相关匹配和相位相关匹配。 这些方法的选择取决于具体的应用场景和任务需求。在实际应用中，可能需要根据图像的特征、噪声水平、计算效率等因素进行权衡和选择合适的匹配方法。
二值匹配在计算机视觉中有多种具体的作用和应用。下面列举了其中几个常见的应用场景：
对象识别与分类：二值匹配可以用于对象识别和分类任务。通过比较待识别对象与已知模板或参考对象的二值表示，可以判断它们是否相似或匹配。这在图像检索、目标跟踪、物体识别等任务中都有应用。特征匹配与配准：在图像配准和特征匹配中，二值匹配常常用于检测两个图像中相同或相似的特征点。通过比较两幅图像的二值表示，可以找到相似的特征区域，并进行配准或匹配。这在图像拼接、摄像头标定、姿态估计等任务中被广泛应用。目标检测与边界框匹配：在目标检测中，二值匹配可以用于检测和匹配目标物体的边界框。通过比较待检测区域与预定义的二值模板或模式，可以确定是否存在目标物体，并找到其位置和边界框。形状识别与轮廓匹配：二值匹配在形状识别和轮廓匹配中也发挥着重要作用。通过比较图像的二值轮廓或形状描述子，可以判断两个图像之间的形状相似度，并进行形状识别和匹配。 总的来说，二值匹配在计算机视觉中用于比较和匹配二值图像，以实现对象识别、特征匹配、目标检测、形状识别等多种任务。它提供了一种有效的方式来量化图像之间的相似度，并帮助计算机理解和分析图像内容。
二、DETR中的Object query的理解 在DETR（Detection Transformer）模型中，“Object query” 是指一组特殊的可学习参数，用于在目标检测任务中查询和定位目标物体。它是通过Transformer的自注意力机制（self-attention mechanism）来实现的。
DETR模型的整体结构包括编码器（Encoder）和解码器（Decoder）。编码器将输入图像转换为一系列特征向量，而解码器则使用这些特征向量来生成目标检测的结果。
在解码器中，“Object query” 扮演着关键的角色。它们是一组可学习的向量，每个向量代表一个潜在的目标物体或目标类别。这些向量通常初始化为随机值，然后在训练过程中通过反向传播进行优化。
在解码器的每个解码层，“Object query” 与编码器的特征向量进行自注意力操作，以便将其关联到输入图像中的特定位置和目标物体。这种自注意力机制可以帮助模型学习目标物体在图像中的位置和特征表示。
通过在每个解码层使用多头自注意力机制，DETR模型可以将输入图像的不同区域和目标物体与对应的 “Object query” 进行交互。这样，模型可以同时对整个图像和特定目标物体进行全局和局部的注意力聚焦，从而实现目标的检测和定位。
总的来说，“Object query” 在DETR模型中用于查询和定位目标物体，通过自注意力机制与输入图像的特征进行交互，以实现目标检测任务。它们在解码器的每个解码层起到关键的作用，帮助模型关注特定目标并生成相应的检测结果。
更多理解，详细看我的博客：
https://blog.csdn.net/wzk4869/article/details/129908100 三、匈牙利算法 匈牙利算法（Hungarian algorithm），也称为Kuhn-Munkres算法，是一种经典的最优匹配算法，用于解决指派问题（Assignment Problem），特别是在二分图中求解最佳的完美匹配（Perfect Matching）问题。
指派问题是在给定的两组元素之间建立最佳的对应关系，其中每个元素必须恰好与另一组中的一个元素匹配。匈牙利算法解决的是一个特殊情况，即每个元素的匹配权重已知，目标是找到一种匹配方式，使得总权重最小。
匈牙利算法的基本思想是通过增广路径（Augmenting Path）的方式逐步构建匹配，直到找到最优解。它的核心步骤如下：
初始化：对于给定的二分图，首先将匹配设置为空，同时为每个顶点和边分配初始标记（通常为0）。寻找增广路径：通过寻找增广路径的方式来改善当前的匹配。增广路径是指从未匹配顶点出发，依次经过匹配边和非匹配边，最终达到另一个未匹配顶点的路径。修改标记：根据找到的增广路径，调整顶点和边的标记，以使得已匹配的顶点的标记增加，未匹配的顶点的标记减小。更新匹配：根据修改后的标记，更新当前的匹配。对于每个未匹配的顶点，如果它有相等的标记，就将它与相等标记的匹配边关联起来，从而形成更大的匹配。重复步骤2-4：重复执行步骤2-4，直到无法找到增广路径为止，此时得到的匹配即为最优解。 匈牙利算法的时间复杂度为O(n^3)，其中n是顶点的数量。它在解决最优匹配问题上具有较高的效率和准确性，被广泛应用于任务分配、资源分配、航线规划、机器学习中的最大权匹配等领域。
四、DETR中的二分图匹配 整个DETR的正负样本分配的重点就是使用了二分图匹配，来对预测框与gorund truth进行了一个最佳匹配。那么解决这两个集合之间的一个最佳匹配的方式，使得cost代价最少的问题，就被称为二分图匹配问题。
举一个二分图匹配的例子，如何分配一些工人干一些活，从而能让最后的支出最小。因为每个工人有各自的长处与短处，所以他们干不同活所需要的回报不同，那么最后每个工人对应每个任务就形成了一个n工人与n任务的一个nxn矩阵，这个矩阵称为cost matric。最优二分图匹配的意思就是最后能够找到一个唯一解，能够给每个人都能分配其最擅长的一份工作，使得把这三个工作完成最后的价钱最低。匈牙利算法就是解决二分图匹配问题中一个比较有名的算法。
那么，在目标检测中，这里的工人就可以看成是集合预测出来的预测框。因为这里有100个，所以就是有100个预测框，而这里的不同任务就对应着ground truth（同样设定为100，如果没有100则用∅填充），最后工人的价钱就是每个预测框与每个ground truth的匹配损失（一般是分类损失与回归损失），这里是损失计算为是：
L m a t c h ( y i , y σ ( i ) ^ ) = − 1 { c i ≠ ϕ } p σ i ^ ( c i ) + 1 { c i ≠ ϕ } L b o x ( b i , b σ ( i ) ^ ) L_{match}(y_i, \hat{y_{\sigma}(i)}) = -1_{\{c_i \neq \phi\}}\hat{p_{\sigma_i}}(c_i)+1_{\{c_i \neq \phi\}}L_{box}(b_i, \hat{b_{\sigma(i)}}) Lmatch​(yi​,yσ​(i)^​)=−1{ci​=ϕ}​pσi​​^​(ci​)+1{ci​=ϕ}​Lbox​(bi​,bσ(i)​^​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2032b00d4e04890f59d138a5fb844d9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b803a630329d30489616e3fdaf9af14/" rel="bookmark">
			常用自定义规则校验方法和git 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用自定义校验规则（手机号码、空、身份证、邮箱、日期格式2008-08-08） 去除首尾空格手机号码规则校验输入框输入不能为空校验判断字符串是否是https?:|mailto:|tal: 开头的校验日期格式是否是'yyyy-mm-dd身份证校验邮箱校验密码规则校验（长度）密码规则校验（复杂度+长度） git常用命令分支操作 1创建一个校验规则的js文件，命名为validate.js，在文件中定义各种规则方法。
去除首尾空格 export function trimSpace (str) { try { return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '') } catch (e) { return str } } 手机号码规则校验 // 手机号码校验 export function validateMobile(str) { if (!String(str &amp;&amp; str.trim() || '')) return true; // 手机号码为空不校验 const reg = /^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$/ return reg.test(str) 输入框输入不能为空校验 /** * 不能为空校验 */ export function validateEmpty(str) { const reg = /^\s*$/ return reg.test(str) } 判断字符串是否是https?:|mailto:|tal: 开头的 /** * @description 判断字符串是否是https?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b803a630329d30489616e3fdaf9af14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe2c64d4eebb934054744eb35af172b/" rel="bookmark">
			人工智能在物流数据分析中的应用：基于人工智能的物流智能监控与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：禅与计算机程序设计艺术 人工智能在物流数据分析中的应用：基于人工智能的物流智能监控与分析 引言 1.1. 背景介绍
随着全球经济的快速发展和物流行业的不断壮大，对物流管理的效率与质量的要求也越来越高。传统的物流管理手段已经难以满足现代物流行业的需要，人工智能技术在物流管理中的应用显得尤为重要。
1.2. 文章目的
本文旨在讨论人工智能在物流数据分析中的应用，以及如何基于人工智能实现物流智能监控与分析。通过对人工智能技术的了解，探讨如何在物流管理中运用大数据分析、机器学习等技术，提高物流管理的效率与质量。
1.3. 目标受众
本文主要面向具有一定技术基础的读者，特别是那些致力于物流行业发展的技术人员和管理者。此外，对希望通过了解人工智能技术提高物流管理效率与质量的读者也有一定的帮助。
技术原理及概念 2.1. 基本概念解释
物流智能监控与分析是指利用现代信息技术、大数据分析以及人工智能技术对物流管理过程进行数据收集、实时监控和分析，从而提高物流管理效率和质量的一种方式。
2.2. 技术原理介绍:算法原理，操作步骤，数学公式等
人工智能在物流管理中的应用主要涉及以下技术原理：
（1）数据收集：通过收集与物流管理相关的各类数据，如运输订单、物流运输信息、库存数据等，对数据进行清洗、整合和分析。
（2）数据预处理：对收集到的原始数据进行去重、去噪、格式化等处理，为后续分析做准备。
（3）数据挖掘：通过机器学习算法，挖掘数据中潜在的规律和关系，提取出有用的信息。
（4）模型训练：根据提取出的信息，建立相应的模型，如线性回归、逻辑回归、决策树等。
（5）模型评估：通过实际数据的测试，评估模型的准确性和稳定性，并对模型进行优化。
（6）模型应用：利用训练好的模型，对新的数据进行预测和分析，为物流管理提供决策依据。
2.3. 相关技术比较
人工智能在物流管理中的应用涉及到的技术原理较多，主要包括数据收集、数据预处理、数据挖掘、模型训练、模型评估和模型应用等环节。下面是对这些技术原理的简要比较：
（1）数据收集：传统的数据收集方法主要是通过人工操作，如查阅相关文献、调查问卷等方式。而人工智能可以通过自然语言处理（NLP）、机器翻译等技术实现自动化采集。
（2）数据预处理：传统的数据预处理方法主要包括数据清洗、去重、去噪等。而人工智能可以通过自然语言处理（NLP）、机器翻译等技术实现自动化清洗、去重、去噪。
（3）数据挖掘：传统的数据挖掘方法主要包括关联规则挖掘、分类挖掘、聚类挖掘等。而人工智能可以通过机器学习算法实现各种挖掘算法的自动化应用。
（4）模型训练：传统的模型训练方法主要包括手动调参、交叉验证等。而人工智能可以通过自动调参、自动交叉验证等技术实现模型的自动化训练。
（5）模型评估：传统的模型评估方法主要包括肉眼观察、统计方法等。而人工智能可以通过各种评估指标对模型进行评估，如准确率、召回率、F1 值等。
（6）模型应用：传统的模型应用方法主要依赖于人工操作，而人工智能可以通过自然语言处理（NLP）技术实现模型的自动化应用，如自动回复邮件、自动电话拨号等。
实现步骤与流程 3.1. 准备工作：环境配置与依赖安装
首先，确保读者具备一定的编程基础，熟悉常见的编程语言（如 Python、Java 等）。其次，需要安装相关的依赖库，如 pandas、numpy、 matplotlib 等。
3.2. 核心模块实现
根据文章的目的和需求，实现数据收集、数据预处理、数据挖掘、模型训练和模型应用等核心模块。在实现这些模块时，可以考虑采用 Python 等编程语言，并利用相关库完成数据处理、模型训练和应用等操作。
3.3. 集成与测试
完成核心模块后，需要对整个程序进行集成测试，确保各个模块之间的协同作用。此外，还可以对程序进行性能测试，以评估其在实际应用中的效率。
应用示例与代码实现讲解 4.1. 应用场景介绍
假设有一家物流公司，需要对运输订单进行智能监控和管理。我们可以通过实现物流智能监控与分析，实时监控运输订单，提高物流管理效率和质量。
4.2. 应用实例分析
假设有一家物流公司，需要对运输订单进行智能监控和管理。我们可以通过实现物流智能监控与分析，实时监控运输订单，提高物流管理效率和质量。
具体实现步骤如下：
（1）数据收集:收集与物流管理相关的各类数据，如运输订单、物流运输信息、库存数据等。
（2）数据预处理:对收集到的原始数据进行去重、去噪、格式化等处理，为后续分析做准备。
（3）数据挖掘:通过机器学习算法，挖掘数据中潜在的规律和关系，提取出有用的信息。
（4）模型训练:根据提取出的信息，建立相应的模型，如线性回归、逻辑回归、决策树等。
（5）模型评估:通过实际数据的测试，评估模型的准确性和稳定性，并对模型进行优化。
（6）模型应用:利用训练好的模型，对新的数据进行预测和分析，为物流管理提供决策依据。
4.3. 核心代码实现
import pandas as pd import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe2c64d4eebb934054744eb35af172b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e3036431a6964e4b98aa95e4cb11eb/" rel="bookmark">
			【C&#43;&#43;】stack、queue和priority_queue的使用及模拟实现（包括deque、仿函数、反向迭代器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.stack1.1 介绍1.2 stack的OJ1.3 stack的模拟实现 2.queue2.1 queue简介2.2 queue模拟实现 3.deque3.1 deque的介绍3.2 deque的缺陷3.3 为什么选择deque作为stack和queue的底层默认容器 4.仿函数5.priority_queue5.1 priority_queue的介绍5.2 priority_queue的使用5.3 priority_queue的模拟实现 6.反向迭代器 1.stack 1.1 介绍 我们通过学习数据结构时知道栈和队列是特殊的线性表，可以通过顺序表或链表来实现，在C++中把这种模式称为适配器模式，用已有的东西封装成你想要的东西。
容器适配器即是对特定类封装作为其底层的容器，并提供一组特定
的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。stack的默认底层容器是deque。
1.2 stack的OJ 对于这道题，我们可以用两个栈来解决，一个普通栈用来入所有的数据，另一个minst用来入小于等于上次入栈元素的元素。出栈时，普通栈一定出栈，minst只有当其栈顶元素等于普通栈的栈顶元素才出栈。此时minst的栈顶元素就是普通栈中最小的元素。
class MinStack { public: MinStack() {} void push(int val) { _st.push(val); if (_minst.empty() || val &lt;= _minst.top()) { _minst.push(val); } } void pop() { if (_st.top() == _minst.top()) { _minst.pop(); } _st.pop(); } int top() { return _st.top(); } int getMin() { return _minst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75e3036431a6964e4b98aa95e4cb11eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b349c1b04fc21bbc819f0ee36b3066/" rel="bookmark">
			VRRP协议是什么？详解它的工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Insist--
个人主页：insist--个人主页
作者会持续更新网络知识和python基础知识，期待你的关注
前言
本文将讲解VRRP是什么，以及它的工作原理，优点以及基本概念。
目录
一、VRRP协议是什么？
二、VRRP协议的工作原理
1、在抢占方式下
2、在非抢占方式下
三、VRRP的优点
1、简化网络管理
2、适应性强
3、网络开销小
四、VRRP基本概念
1、虚拟路由器
2、Master路由器
3、Backup路由器
4、Priority
5、vrid
6、虚拟IP地址
7、IP地址拥有者
8、虚拟MAC地址
一、VRRP协议是什么？ VRRP（虚拟路由器冗余协议）是一种实现路由器冗余的协议，通常被用于保证网络的高可用性。当出现主路由器故障时，备用路由器会自动接管主路由器的工作，从而确保网络仍能够顺畅工作。
VRRP协议主要用于解决单点故障问题，即当网络中的某台路由器发生故障时，其他路由器可以自动接管该路由器的功能，从而保证网络的连通性。VRRP协议通过将多个路由器配置为一个组，其中一台路由器被选举为虚拟路由器，其他路由器则作为备份路由器，同时监控虚拟路由器的状态。当虚拟路由器发生故障时，备份路由器会自动接管其功能，从而保证网络的连通性。
二、VRRP协议的工作原理 路由器开启VRRP功能后，会根据优先级确定自己在备份组中的角色。优先级高的路由器成为主用路由器，优先级低的成为备用路由器。主用路由器定期发送VRRP通告报文，通知备份组内的其他路由器自己工作正常；备用路由器则启动定时器等待通告报文的到来。
VRRP在不同的主用抢占方式下，主用角色的替换方式不同:
1、在抢占方式下 当备用路由器收到VRRP通告报文后，会将自己的优先级与通告报文中的优先级进行比较。如果大于通告报文中的优先级，则成为主用路由器否则将保持备用状态。
2、在非抢占方式下 只要主用路由器没有出现故障，备份组中的路由器始终保持主用或备用状态，备份组中的路由器即使随后被配置了更高的优先级也不会成为主用路由器。
如果备用路由器的定时器超时后仍未收到主用路由器发送来的VRRP通告报文，则认为主用路由器已经无法正常工作，此时备用路由器会认为自己是主用路由器，并对外发送VRRP通告报文。备份组内的路由器根据优先级选举出主用路由器，承担报文的转发功能。
三、VRRP的优点 1、简化网络管理 在具有多播或广播能力的局域网（如以太网）中，借助VRRP能在某台设备出现故障时仍然提供高可靠的缺省链路，有效避免单一链路发生故障后网络中断的问题，而无需修改动态路由协议、路由发现协议等配置信息，也无需修改主机的默认网关配置。
2、适应性强 VRRP报文封装在IP报文中，支持各种上层协议。
3、网络开销小 VRRP只定义了一种报文，那就是VRRP通告报文，并且只有处于Master状态的路由器可以发送VRRP报文。
四、VRRP基本概念 1、虚拟路由器 由一个Master设备和多个Backup设备组成，被当作一个共享局域网内主机的缺省网关。如RouterA和RouterB共同组成了一个虚拟路由器。
2、Master路由器 承担转发报文任务的VRRP设备，如RouterA。
3、Backup路由器 一组没有承担转发任务的VRRP设备，当Master设备出现故障时，它们将通过竞选成为新的Master设备，如RouterB。
4、Priority 设备在备份组中的优先级，取值范围是0~255。
0表示设备停止参与VRRP备份组，用来使备份设备尽快成为Master设备，而不必等到计时器超时
255则保留给IP地址拥有者，无法手工配置；设备缺省优先级值是100。
5、vrid 虚拟路由器的标识，如图中RouterA和RouterB组成的虚拟路由器的vrid为1，需手工指定，范围1-255。
6、虚拟IP地址 虚拟路由器的IP地址，一个虚拟路由器可以有一个或多个IP地址，由用户配置。如RouterA和RouterB组成的虚拟路由器的虚拟IP地址为10.1.1.254/24。
7、IP地址拥有者 如果一个VRRP设备将真实的接口IP地址配置为虚拟路由器IP地址，则该设备被称为IP地址拥有者。如果IP地址拥有者是可用的，则它将一直成为Master。
8、虚拟MAC地址 虚拟路由器根据vrid生成的MAC地址。一个虚拟路由器拥有一个虚拟MAC地址。当虚拟路由器回应ARP请求时，使用虚拟MAC地址，而不是接口的真实MAC地址。如RouterA和RouterB组成的虚拟路由器的vrid为1，因此这个VRRP备份组的MAC地址为00-00-5E-00-01-01。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/932e945dab41065934bb89116feb0e42/" rel="bookmark">
			数据中台架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据中台总体架构图
1、数据汇聚
2、数据开发
3、数据体系
4、数据资产管理
5、数据服务体系
6、数据运营体系
7、数据安全管理
二、数据中台 四字箴言
1、采
2、存
3、通
4、用
数据中台总体架构图前面我们通过理论层面对数据中台有了一定的了解，下面我们通过架构层面来详细看一下数据中台的设计。数据中台是位于底层存储计算平台与上层的数据应用之间的一整套体系。数据中台屏蔽掉底层存储平台的计算技术复杂性，降低对技术人才的需求，让数据的使用成本更低。通过数据中台的数据汇聚、数据开发模块建立企业数据资产。通过数据体系对数据进行分层存储通过资产管理、数据服务，把数据资产变为数据服务能
一、数据中台总体架构图 前面我们通过理论层面对数据中台有了一定的了解，下面我们通过架构层面来详细看一下数据中台的设计。
数据中台是位于底层存储计算平台与上层的数据应用之间的一整套体系。
数据中台屏蔽掉底层存储平台的计算技术复杂性，降低对技术人才的需求，让数据的使用成本更低。
通过数据中台的数据汇聚、数据开发模块建立企业数据资产。
通过数据体系对数据进行分层存储
通过资产管理、数据服务，把数据资产变为数据服务能力，服务于企业业务。
数据安全管理、数据运营体系，保障数据中台可以长期健康、持续运转。
1、数据汇聚 数据汇聚是数据中台数据接入的入口，数据中台本身不产生数据，所有的数据来自于业务系统，数据库、日志、文件等，这些数据分散在不同的网络环境和存储平台中，难以利用，很难产生业务价值，所以需要统一汇聚。
2、数据开发 数据开发是一整套数据加工以及处理的工具，因为通过数据汇聚模块汇聚到中台的数据没有经过处理，基本是按照数据的原始状态堆砌在一起的，这样业务是很难直接使用的。所以需要通过数据开发模块实现对数据的加工处理，形成有价值的数据，提供给业务部门使用。
3、数据体系 通过数据汇聚、数据开发，中台就具备了构建数仓平台的基本能力，这一块其实就是将采集过来的各种数据按照数仓的标准进行建设。
4、数据资产管理 通过数仓建立起来的数据资产比较偏向于技术，业务人员比较难理解，资产管理是以业务人员更好理解的方式，把数据资产展现给企业的业务人员。
5、数据服务体系 数据服务体系就是把数据变为一种服务能力，通过数据服务让数据参与到业务，激活整个数据中台，数据服务体系是数据中台存在的价值所在。
6、数据运营体系 是数据中台得以健康、持续运转的基础
7、数据安全管理 是为了保证数据中台中的数据安全。
这是一个典型的数据中台总体架构设计。
二、数据中台 四字箴言 如果大家之前没有工作过的话，可能对数据中台还是不好理解，所以在这我将数据中台的功能总结为四个字：采、存、通、用
下面我们来详细分析一下这四字箴言
1、采 采：表示采集的意思，就是采集企业中的所有数据。
随着互联网、移动互联网、物联网等技术的兴起，企业的业务形态开始多元化，数据的产生形式也是多样化的，对应的就需要有多种采集形式。
埋点采集、硬件采集、爬虫采集、数据库采集、日志采集。
埋点采集：一般是采集用户行为信息，例如用户在平台上的浏览、点击、停留等行为。
硬件采集：指的是物联网数据采集，例如通过无人机传感器来采集空气质量指标。
爬虫采集：指的是采集互联网上的公开数据，例如：电商平台竞品价格采集。
数据库采集：一般是采集企业内的业务数据，例如：用户交易数据、用户个人信息数据等。
日志采集：一般是采集软件运行时产生的日志。
这些是常见的采集形式。
从数据组织形式可以分为：结构化数据、半结构化数据、非结构化数据。
结构化数据：数据规则、完整、能够通过二维逻辑来表现的数据，严格遵守数据格式与长度规范，常见的有数据库中的数据、excel中的数据。
半结构化数据：数据规则、完整，同样严格遵守数据格式与长度规范，但无法通过二维关系来表现，常见的有JSON、XML等格式的数据。
非结构化数据：数据结构不规则或不完整，不方便用二维逻辑表来表现，需要经过复杂的逻辑处理才能提取其中的信息内容，常见的有word文档、图片、视频、音频等数据。
从数据的时效性上来划分，可以分为：离线数据、实时数据。
离线数据：主要用于大批量数据的周期性迁移，对时效性要求不高，一般采用分布式批量数据同步的形式，通过连接读取数据，读取数据过程中可以有全量、增量的方式，经过统一处理后写入到目标存储。
实时数据：主要面向低延时的数据应用场景，一般通过实时监控的方式实现，例如通过读取数据库的binlog日志来实现数据库的实时数据采集。
前面我们针对数据的采集形式、数据的组织形式、数据的时效性进行了分析，那这些数据在采集的时候具体应该使用什么类型的工具呢？
常见的采集工具有：Flume、FileBeat、Logstash、Sqoop、Canal、DataX等。
其中Flume、FileBeat、Logstash适合采集日志数据，这三个组件的特性在前面项目课程中已经详细分析过了，在这不再赘述。
sqoop是在结构化数据和HDFS之间进行批量数据迁移的工具，适合批量采集数据库中的数据，它的主要优势是，在特定场景下，数据交换过程会有很大的性能提升。主要缺点是处理过程定制程度较高，需要在脚本中调整配置参数实现，在用户的一些自定义逻辑和数据同步链路监控方面比较薄弱。
DataX是阿里开源的一套数据采集工具，提供数据采集全链路的流量监控，将作业本身的状态，数据流量，数据速度，执行速度等信息进行展示，提供脏数据探测功能，支持传输过程中对传输报错进行策略化处理。
由于它是基于进程内读写直连的方式，高并发数据采集场景下对机器内存要求比较高。
不过DataX不支持非结构化数据的采集。
这些单个工具都无法很好的满足企业复杂的数据采集场景，所以我们需要对已有的采集工具进行二次开发，以可视化配置的方式提供给用户，屏蔽底层工具的复杂性，要支持常见的数据源采集：关系型数据库、NoSQL数据库、MQ、文件系统等，并且支持增量同步、全量同步等方式。
2、存 将数据采集过来之后，就需要考虑数据存储了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/932e945dab41065934bb89116feb0e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cab22679eda61ee81832ced1fddc54c/" rel="bookmark">
			js 实现图片压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var images = new Image() images.src = result // result base64图片 images.onload = () =&gt; { let width = images.width // 图片宽度 let height = images.height // 图片高度 let dataUrl = compress(images, width, height, 0.1) console.log(dataUrl); // 压缩后的base64图片 } /* * 图片压缩 * img 原始图片 * width 压缩后的宽度 * height 压缩后的高度 * ratio 压缩比率 */ function compress(img, width, height, ratio) { var canvas, ctx, img64; canvas = document.createElement('canvas'); canvas.width = width; canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cab22679eda61ee81832ced1fddc54c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355d62f013a6a919af00bdcfaff1e596/" rel="bookmark">
			ClickHouse学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ClickHouse 一.概述1.特点2.安装2.1 安装前准备2.2 正式安装 3.数据类型4.引擎1.TinyLog2.Memory3.MergeTree4.ReplacingMergeTree5.SummingMergeTree 二.SQL操作1.insert2.update 和 delete3.select 三.副本1.配置步骤2.副本测试四.Java API 一.概述 1.特点 ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的列式存储数据库（DBMS），使用
C++语言编写，主要用于在线分析处理查询（OLAP），能够使用 SQL 查询实时生成分析
数据报告
OLAP适合一次写入，多次读取
OLTP可以增删改查，因为有事务支持
1.列式存储
2.DBMS 的功能
几乎覆盖了标准 SQL 的大部分语法，包括 DDL 和 DML，以及配套的各种函数，用户管理及权限管理，数据的备份与恢复
3.多样化引擎
ClickHouse 和 MySQL 类似，把表级的存储引擎插件化，根据表的不同需求可以设定不同的存储引擎。目前包括合并树、日志、接口和其他四大类 20 多种引擎
4.高吞吐写入能力
ClickHouse 采用类 LSM Tree 的结构，数据写入后定期在后台 Compaction。通过类LSM tree 的结构，ClickHouse 在数据导入时全部是顺序 append 写，写入后数据段不可更改，在后台 compaction 时也是多个段 merge sort 后顺序写回磁盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在 HDD 上也有着优异的写入性能。官方公开 benchmark 测试显示能够达到 50MB-200MB/s 的写入吞吐能力，按照每行 100Byte 估算，大约相当于 50W-200W 条/s 的写入速度
5.数据分区与线程级并行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/355d62f013a6a919af00bdcfaff1e596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7411c4a5478c091269e8ef346d8bea6a/" rel="bookmark">
			Flink（九）CEP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink（八）CEP 1.概述2.快速入门3.模式API3.1 个体模式3.2 组合模式3.3 匹配后跳过策略 4.模式的检测处理4.1 模式应用到数据流4.2 处理匹配事件4.3 处理超时事件 1.概述 所谓 CEP，其实就是“复杂事件处理（Complex Event Processing）”的缩写；而 Flink CEP，就是 Flink 实现的一个用于复杂事件处理的库（library）。那到底什么是“复杂事件处理”呢？就是可以在事件流里，检测到特定的事件组合并进行处理，比如说“连续登录失败”，或者“订单支付超时”等等
具体的处理过程是，把事件流中的一个个简单事件，通过一定的规则匹配组合起来，这就是“复杂事件”；然后基于这些满足规则的一组组复杂事件进行转换处理，得到想要的结果进行输出
总结起来，复杂事件处理（CEP）的流程可以分成三个步骤：
（1）定义一个匹配规则，匹配规则就是模式，主要由两部分组成，每个简单事件的特征 和 简单事件之间的组合关系
（2）将匹配规则应用到事件流上，检测满足规则的复杂事件
（3）对检测到的复杂事件进行处理，得到结果进行输出
CEP 主要用于实时流数据的分析处理。CEP 可以帮助在复杂的、看似不相关的事件流中找出那些有意义的事件组合，进而可以接近实时地进行分析判断、输出通知信息或报警。这在企业项目的风控管理、用户画像和运维监控中，都有非常重要的应用
风险控制
当一个用户行为符合了异常行为模式，比如短时间内频繁登录并失败、大量下单却不支付（刷单），就可以向用户发送通知信息，或是进行报警提示、由人工进一步判定用户是否有违规操作的嫌疑。这样就可以有效地控制用户个人和平台的风险
用户画像
利用 CEP 可以用预先定义好的规则，对用户的行为轨迹进行实时跟踪，从而检测出具有特定行为习惯的一些用户，做出相应的用户画像。基于用户画像可以进行精准营销，即对行为匹配预定义规则的用户实时发送相应的营销推广；这与目前很多企业所做的精准推荐原理是一样的
运维监控
对于企业服务的运维管理，可以利用 CEP 灵活配置多指标、多依赖来实现更复杂的监控模式
CEP 的应用场景非常丰富。很多大数据框架，如 Spark、Samza、Beam 等都提供了不同的CEP 解决方案，但没有专门的库（library）。而 Flink 提供了专门的 CEP 库用于复杂事件处理，可以说是目前 CEP 的最佳解决方案
2.快速入门 需要引入的依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-cep_${scala.binary.version}&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; 接下来我们考虑一个具体的需求：检测用户行为，如果连续三次登录失败，就输出报警信息。很显然，这是一个复杂事件的检测处理，我们可以使用 Flink CEP 来实现。我们首先定义数据的类型。这里的用户行为不再是之前的访问事件 Event 了，所以应该单独定义一个登录事件 POJO 类。具体实现如下：
public class LoginEvent { // 用户id public String userId; // 用户ip地址 public String ipAddress; // 用户登录成功与否 public Boolean eventType; // 登录时间戳 public Long timestamp; public LoginEvent() {} // 省略toString 有参构造 } public class LoginDetectExample { public static void main(String[] args) throws Exception { // 创建一个表执行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7411c4a5478c091269e8ef346d8bea6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d24f7d7f2b30b1326dd2ab46112f60/" rel="bookmark">
			openCV上图片显示中文c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备材料：
1、中文汉字库
2、中文显示扩展类
cvxFont.h
#ifndef OPENCVUNICODE_CVXFONT_H #define OPENCVUNICODE_CVXFONT_H #include &lt;ft2build.h&gt; #include FT_FREETYPE_H #include &lt;opencv2/opencv.hpp&gt; #include &lt;typeinfo&gt; #include &lt;codecvt&gt; #include &lt;string&gt; #include &lt;locale&gt; namespace cvx { struct FontProperty { int fontSize; // font size (pixel) double spaceRatio; // ratio of distance when meet a space, base on font size double fontRatio; // ratio of distance between each character, base on font size double fontRotateAngle; // rotate angle double fontDiaphaneity; // merge ratio bool fontIsUnderline; // underline bool fontIsVertical; // put text in vertical }; class CvxFont { public: explicit CvxFont(const cv::String&amp; fontType); virtual ~CvxFont(); void setFontSize(int fontSize); void setSpaceRatio(const double spaceRatio) { m_font-&gt;spaceRatio = spaceRatio; } void setFontRatio(const double fontRatio) { m_font-&gt;fontRatio = fontRatio; } void setRotateAngle(const double angle) { m_font-&gt;fontRotateAngle = angle; } void setUnderline(const bool isUnderline) { m_font-&gt;fontIsUnderline = isUnderline; } void setDiaphaneity(const double diaphaneity) { m_font-&gt;fontDiaphaneity = diaphaneity; } void setVertical(const bool vertical) { m_font-&gt;fontIsVertical = vertical; } [[nodiscard]] int getFontSize() const { return m_font-&gt;fontSize; } [[nodiscard]] double getSpaceRatio() const { return m_font-&gt;spaceRatio; } [[nodiscard]] double getFontRatio() const { return m_font-&gt;fontRatio; } [[nodiscard]] double getAngle() const { return m_font-&gt;fontRotateAngle; } [[nodiscard]] bool getUnderline() const { return m_font-&gt;fontIsUnderline; } [[nodiscard]] double getDiaphaneity() const { return m_font-&gt;fontDiaphaneity; } [[nodiscard]] bool getVertical() const { return m_font-&gt;fontIsVertical; } private: void initFont(); void rotateFont(double angle); void putTextStr(cv::Mat&amp; img, const cv::String&amp; text, cv::Point pos, const cv::Scalar&amp; color); void putWChar(cv::Mat&amp; img, uint32_t wc, cv::Point&amp; pos, const cv::Scalar&amp; color); friend void putText(cv::Mat&amp;, const std::string&amp;, cv::Point, cvx::CvxFont&amp;, int, const cv::Scalar&amp;); FT_Library m_library{}; // font library FT_Face m_face{}; // font type FT_Matrix m_matrix{}; FT_Vector m_pen{}; FT_Error m_error; FontProperty* m_font; long m_maxDiffHeight{ 0 }; }; void putText(cv::Mat&amp; img, const std::string&amp; text, cv::Point pos, cvx::CvxFont&amp; fontFace, int fontSize, const cv::Scalar&amp; color); void putSymbols(cv::Mat&amp; img, std::vector&lt;uint32_t&gt;&amp; symbols, cv::Point pos, cvx::CvxFont&amp; fontFace, int fontSize, const cv::Scalar&amp; color); void putOneSymbol(cv::Mat&amp; img, uint32_t symbol, cv::Point pos, cvx::CvxFont&amp; fontFace, int fontSize, const cv::Scalar&amp; color); } #endif //OPENCVUNICODE_CVXFONT_H cvxFont.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12d24f7d7f2b30b1326dd2ab46112f60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9854bdae98248b329a2c065f077e0b24/" rel="bookmark">
			年轻人储蓄难题：平衡生活与未来规划的挑战​​​​​​​
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年轻人存款难是一个复杂的问题，涉及到经济压力、消费观念、生活方式等多个方面。在现代社会中，年轻人面临着许多经济压力和挑战。高房价、高学费以及生活成本的不断上涨，都给年轻人的储蓄带来了很大的压力。同时，年轻人通常刚刚步入职场，收入相对较低，很难有足够的资金进行储蓄。
除了经济压力，年轻人的消费观念和生活方式也对存款造成了影响。现代社会，消费观念日益多元化，年轻人更注重享受当下的生活，追求个性化和体验式消费。这种消费观念导致了年轻人更倾向于将资金用于满足短期需求，而不是长期储蓄。此外，社交媒体的兴起也加剧了年轻人的消费压力，他们可能会受到来自朋友圈和社交媒体的影响，追求高消费的生活方式。
然而，尽管年轻人存款难，我们也不能一概而论。还是有一部分年轻人能够做到积极储蓄并有一定的存款。他们可能通过良好的理财规划、控制消费欲望以及寻找额外的收入来源来实现储蓄目标。此外，一些年轻人也可能因为家庭背景、教育背景或者职业选择等因素，拥有更多的储蓄机会。
对于年轻人来说，储蓄的重要性不容忽视。储蓄不仅可以为年轻人提供应急资金，还可以为未来的大额支出做准备，如购房、创业或者养老。年轻人应该树立正确的消费观念，合理规划自己的财务状况，并努力寻找储蓄的机会。可以通过制定预算、控制消费、寻找理财产品等方式来实现储蓄目标。
此外，政府和社会也应该为年轻人提供更多的支持和机会。政府可以加大对年轻人的就业培训和创业支持，提高年轻人的收入水平。同时，社会可以提供更多的教育和指导，帮助年轻人提升理财能力和储蓄意识。
在解决年轻人存款难题的过程中，需要各方共同努力。政府、金融机构、教育机构以及家庭都应该发挥作用。政府可以通过制定更加友好的金融政策和就业政策来支持年轻人的储蓄。金融机构可以提供更加灵活多样的理财产品，满足年轻人的不同需求。教育机构可以加强对年轻人的理财教育，提高他们的财务素养。家庭可以从小培养孩子的储蓄意识，教导他们正确的消费观念和理财观念。
总的来说，年轻人存款难是一个复杂的问题，但并非不可解决。通过合理规划和努力储蓄，年轻人仍然可以实现自己的储蓄目标。同时，政府和社会也应该为年轻人提供更多的支持和机会，帮助他们应对储蓄难题。只有通过共同努力，我们才能为年轻人创造更好的储蓄环境，帮助他们实现财务自由和未来的梦想。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98915ca0dee6111d0c78f1ef5f2fb001/" rel="bookmark">
			【MySql】C语言连接mysql|图形化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Connector/C 使用mysql接口介绍Navicat远程连接数据库 Connector/C 使用 说完了mysql的基础,后面我们只关心使用，要使用C语言连接mysql，需要使用mysql官网提供的库，前往官网下载即可。
但是实际上我们并不需要这样去做，我们之前用yum安装mysql的时候就已经包含了，我们前往lib64/mysql/下查看即可：直接用就行了
现在，我们直接来对相关的API进行调用即可。
我们来通过 mysql_get_client_info() 函数，来验证我们的引入是否成功
#include &lt;iostream&gt; #include &lt;mysql/mysql.h&gt; int main() { std::cout&lt;&lt;"mysql cilent version: "&lt;&lt;mysql_get_client_info()&lt;&lt;std::endl; return 0; } 进行编译：记得带上-L库的位置与-l库的名称
测试运行：运行成功，结果如下
mysql接口介绍 我们可以先看一看官方文档：
初始化mysql_init() 要使用库，必须先进行初始化！
MYSQL *mysql_init(MYSQL *mysql); 关闭mysql链接mysql_close void mysql_close(MYSQL *sock); 初始化与关闭是最基础的操作：
#include &lt;iostream&gt; #include &lt;mysql/mysql.h&gt; int main() { MYSQL* my = mysql_init(nullptr); if(nullptr == my) { std::cerr&lt;&lt;"init MySQL error"&lt;&lt;std::endl; return 1; } mysql_close(my); return 0; } 链接数据库mysql_real_connect 初始化完毕之后，必须先链接数据库，在进行后续操作。（mysql网络部分是基于TCP/IP的)
MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long clientflag); //建立好链接之后，获取英文没有问题，如果获取中文是乱码： //设置链接的默认字符集是utf8，原始默认是latin1 mysql_set_character_set(myfd, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98915ca0dee6111d0c78f1ef5f2fb001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acfb23265026800269132d9581a6530f/" rel="bookmark">
			解决Selenium爬取数据写入csv文件中文乱码的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 方法：
f= open('boss.csv', mode='a', encoding='utf-8', newline='') 改成
f= open('boss.csv', mode='a', encoding='utf-8-sig', newline='') 解析：
“utf-8”会将全部内容视作无标签文本处理
"uft-8-sig"中sig全拼为 signature 也就是"带有签名的utf-8", 因此"utf-8-sig"读取带有BOM的"utf-8文件时"会把BOM单独处理,与文本内容隔离开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e14f58b6e2965305c55cf77b323522d/" rel="bookmark">
			Linux安装Matlab Runtime环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 进入待安装文件目录
安装命令 ./MyAppInstaller_mcr.install -mode silent -agreeToLicense yes 过程 配置环境变量（临时）：
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/MATLAB/MATLAB_Runtime/v911/runtime/glnxa64:/usr/local/MATLAB/MATLAB_Runtime/v911/bin/glnxa64:/usr/local/MATLAB/MATLAB_Runtime/v911/sys/os/glnxa64:/usr/local/MATLAB/MATLAB_Runtime/v911/extern/bin/glnxa64 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34cfad9b603d137a094ad03cdd9a5415/" rel="bookmark">
			【项目实战】基于Vue3&#43;TypeScript&#43;Pinia的后台管理系统（coderwhy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Vue3+TypeScript+Pinia的后台管理系统 是基于Vue3、Pinia、VueRouter、Vite、ElementPlus、TypeScript、Echarts等后台系统
接口地址 https://documenter.getpostman.com/view/12387168/TzzDKb12
baseURL = ‘http://codercba.com:5000’
postman详细使用可以自己搜 也可以使用其他接口管理的工具
给项目添加
环境变量 baseURL
项目地址 https://gitee.com/yangyang993/vue3_ts_cms_admin.git
超级管理员 登录 系统总览 侧边栏是动态形成的：动态路由加载。路由地址路径和菜单相匹配。
注意：路由地址和侧边栏菜单的选中状态不匹配（通过判断当前路由来解决）
核心技术 商品统计 echarts5.x 设计：饼图、玫瑰图、柱状图、折线图、中国地图核心：封装一下echarts 设计一个baseEcharts ，将echarts的初始化，和setOtion封装在这里；将每一种图形都封装成组件，引用baseEcharts设置个性化的option，通过props，将option传递给baseEcharts， 系统管理 这个部分，主要是对数据的增删改查。展示的布局和形式相似，通过抽取相同的部分，形成三个部分的公共组件（pageSearch、pageContent、pageModal）。
个性化的部分，使用具名插槽页面的搭建使用配置文件，快速搭建（注意：配置的时候，把url也要写上）编辑和新增是同一个公共组件，注意一些回显问题表格时间需要格式化，通过utils分页注意：在第1页之后的任何一页上时，添加或者修改数据，点击确定要刷新，当前页要定位到第1页 用户管理 部门管理 菜单管理 角色管理 商品中心 商品类别 商品类别 随便聊聊 故事列表 其他身份角色 根据用户 coderdemo的角色，获取的动态路由权限
项目结构 vue3_ts_cms ├── LICENSE ├── README.md ├── auto-imports.d.ts ├── components.d.ts ├── env.d.ts ├── index.html ├── package-lock.json ├── package.json ├── public │ └── favicon.ico ├── src │ ├── App.vue │ ├── assets │ │ ├── img │ │ │ ├── login-bg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34cfad9b603d137a094ad03cdd9a5415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3bd7f6fa48cb386d428448644223e4a/" rel="bookmark">
			开源虚拟化工具VirtualBox安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Virtualbox VirtualBox是一款由Oracle开发和维护的免费开源虚拟化软件，用于在一台计算机上创建和管理多个虚拟机。它允许用户在单个物理计算机上运行多个操作系统，例如Windows、Linux、macOS等。VirtualBox提供了一个虚拟化环境，使用户可以在虚拟机中安装和运行不同的操作系统，并在它们之间进行快速切换。 VirtualBox提供了一系列功能，包括虚拟机快照、网络配置和共享、虚拟硬盘管理、剪贴板共享等。用户可以根据自己的需求调整虚拟机的硬件资源分配，例如内存、处理器核心数量、网络适配器等。虚拟机的运行和控制可以通过VirtualBox的图形用户界面（GUI）进行操作，也可以通过命令行界面进行管理。 通过VirtualBox，用户可以进行多种用途，包括软件开发和测试、操作系统学习和实验、应用程序兼容性测试等。它还可以用于创建隔离的测试环境、快速部署虚拟机、远程访问虚拟机等。 总的来说，VirtualBox是一个功能强大、易于使用的虚拟化软件，可以帮助用户轻松地创建和管理多个虚拟机，并在不同操作系统之间进行无缝切换和交互。
VirtualBox是完全免费的虚拟化软件。Oracle以GNU通用公共许可证（GPL）版本2的条款将VirtualBox发布为开源软件，这意味着任何人都可以免费下载、使用和修改VirtualBox的源代码。您可以从VirtualBox官方网站上获取免费版本，并在个人或商业环境中使用它。虽然VirtualBox提供了一些高级功能的付费版本，但免费版本已经非常强大且功能齐全，适合大多数用户的需求。 VirtualBox下载网站： Oracle VM VirtualBox
windows版本：
https://download.virtualbox.org/virtualbox/7.0.8/VirtualBox-7.0.8-156879-Win.exe
后面没什么要注意的地方，一直点下一步即可，直到安装完成，然后打开virtualbox
修改虚拟机默认位置，不修改默认会放在C盘下面。
新建一台虚拟机，配置名字，镜像。 然后按照正常流程去安装一个centos7的系统就ok了
热键设置： virtualbox用起来挺简单，但是这里会有一个鼠标抢占的问题，即鼠标点入虚拟机以后，就会被虚拟机抢占，除非关闭虚拟机，不然鼠标就无法退出来了，所以有一个热键功能，使用快捷键以后就会自动退出虚拟机，我这里设置的是F1自动退出。
快照设置 virtualbox也提供了快照功能，可以迅速的对系统当前状态进行一个备份，并在需要的时候返回至系统备份前的状态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed9110a306aaf88e8c5f99620778b635/" rel="bookmark">
			Selenium爬虫报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码功能：第一次使用selenium模仿浏览器操作，爬取Boss直聘的招聘信息（requests容易被反爬虫）
Error：
selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home
Error分析：
使用selenium打开浏览器部分报错，显示chromedriver驱动需要在路径下，即需要对驱动做操作，错误部分为：
Error解决：
先说下背景：由于本人使用的是Microsoft Edge浏览器，电脑本身并没有安装谷歌浏览器，selenium版本为3.141.0
因此解决错误的思路从edge浏览器入手，具体过程有三步：
1.查看浏览器版本:
方法一：直接在浏览器查询
方法二 ：浏览器&gt;设置&gt;
2. 下载edge浏览器驱动（驱动的版本与电脑中edge版本对应，以本人114.0.1823.58 (正式版本) (64 位)为例 ）
下载链接：Microsoft Edge WebDriver - Microsoft Edge Developer
下载后解压，为以下文件
3.将文件放入Python目录下，并重命名为MicrosoftWebDriver.exe
测试是否解决
from time import sleep from selenium import webdriver driver = webdriver.Edge()##注意，报错的.Chromedriver()改成.Edge(),因为用的Edge浏览器 driver.get(r'https://www.baidu.com/') sleep(5) driver.close() 运行结果：成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c113801052f9c7beda98659bf3b0548/" rel="bookmark">
			搜索组件之a-range-picker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件：
&lt;template&gt; &lt;div class="searchComponent"&gt; &lt;a-form :model="form" ref="formRef" layout="inline" :label-col="labelCol" :wrapper-col="wrapperCol" &gt; &lt;a-row :gutter="12" style="width: 100%"&gt; &lt;a-col v-for="(item, index) in searchitemList" :key="index" :xs="xs ? xs : 12" :sm="sm ? sm : 12" :md="md ? md : 12" :lg="lg ? lg : 12" :xl="xl ? xl : item.type == 'rangeDate' ? 10 : 8" :xxl="xxl ? xxl : item.type == 'rangeDate' ? 8 : 6" &gt; &lt;a-form-item :rules=" item.rules ? [ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c113801052f9c7beda98659bf3b0548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7034e60adf7d7544b8856fd40c1245b/" rel="bookmark">
			python离线安装软件包，常用pip安装软件源网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip离线安装 使用背景 我们平时遇到很多pip安装软件的软件源的问题，一会儿这慢一会儿那慢，常见的软件源如下：
豆瓣:http://pypi.douban.com/simple/
清华大学:https://pypi.tuna.tsinghua.edu.cn/simple/
中国科技大学:https://pypi.mirrors.ustc.edu.cn/simple/
阿里云:https://mirrors.aliyun.com/pypi/simple/
百度：https://mirror.baidu.com/pypi/simple
但！有时我们也会遇到不能使用源的情况，这个时候就需要下面的方法了。
新思路 新思路：其实我们的可以离线下载完整的软件包，然后本地离线安装。单独下载的包一般都是以（.whl）为后缀的。所以，我们需要找到一个可以离线下载这些包的地方。这个网站是 python三方库官网： https://pypi.org/
情况一：单独下载单个python软件离线包 1.我们从python三方库官网里，输入需要的软件名字 2.在搜索到的软件列表中，点开你需要的软件 打开后，界面如下图，直接点击Download files，找到你的软件版本，cp38代表软件包对应的python版本3.8，win_x86_64对应windows 64位操作系统。
3.软件包下载完毕就可以，到windows对应的本地环境里面，使用命令安装： pip install 文件路径 比如：
pip install aiohttp-3.7.4.post0-cp37-cp37m-win_amd64.whl 情况二：多个python包离线批量安装 其实离线多个软件包安装才是实际的，很少遇到只是安装一个包的情况，多个包之间相互，这才是依赖环境的常态。但是，要安装多个包时，轮流单独安装包会遇到并行依赖问题，所以得一次性批量安装多个python包离线批量安装，方法如下：
首先，新建一个文档requirements.txt 在requirements.txt里面写入你的安装包的名字，以及版本（建议）比如我的内容如下：
frozenlist==1.3.3 aiosignal==1.3.1 asynctest==0.13.0 chardet==5.1.0 async-timeout==4.0.2 typing-extensions==4.5.0 aiohttp==3.8.4 yarl==1.8.2 multidict==6.0.4 attrs==22.2.0 openai==0.27.2 然后，使用命令批量安装 运行命令：
pip install --find-links=./ -r requirements.txt 上面的命令 find-links参数 就是文件路径。
这里，因为我将requirements.txt与批量离线Python软件包放在同一文件夹。所以路径是“./”
运行命令之后，就能看到结果。
再然后，初次安装多半会报错 多个软件包依赖的时候，我们是不知道要依赖那些包的，所以只能失败提示寻找依赖。
如果你看到类似这样的报错：
ERROR: Could not find a version that satisfies the requirement AAA&gt;=1.1.0 (from BBB) (from versions: none) ERROR: No matching distribution found for AAA&gt;=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7034e60adf7d7544b8856fd40c1245b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f7fe60c248769116536f56df8f3a62/" rel="bookmark">
			校园网的开机自动连接拨号以及检测断网再次连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先在C:\Users\l用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs目录下创建新文件夹（这里命名为1）
在改文件夹里创建文件reconnect.txt，把下面代码复制进去
@echo off chcp 65001 &gt; nul :Ping echo 正在检测网络连接状态... Ping -n 5 127.0.0.1&gt;nul ping -n 3 www.hao123.com &gt;nul IF ERRORLEVEL 1 goto Start2 IF ERRORLEVEL 0 goto Start1 :Start1 echo 网络连接正常。 goto Ping :Start2 echo 网络连接已断开，正在尝试重新拨号... REM 拨号命令（请替换为适用于你的拨号方式的命令） rasdial "拨号的名称" 账号 密码 REM 检查拨号连接是否成功 if %errorlevel%==0 ( echo 重新拨号成功！ ) else ( echo 重新拨号失败，请检查拨号设置。 ) goto Ping 再将文件名后缀改成.bat
然在C:\Users\l用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup目录下（或win+R运行shell:startup）创建文件reconnectHidden.txt，把下面代码复制进去
Set objShell = CreateObject("WScript.Shell") objShell.Run """C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\1\reconnect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9f7fe60c248769116536f56df8f3a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6153999a94b0e6dff978f268e7acd49/" rel="bookmark">
			vs2022配置pcl1.13.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载 打开GitHub网站，搜索pcl，选择第一个结果打开，按照下图步骤操作
下载PCL预编译安装程序PCL-1.13.1-AllInOne-msvc2022-win64.exe
和要安装的PCL组件（例如pcl-1.13.1-pdb-msvc2022-win64.zip）
2、安装 双击 PCL-1.13.1-AllInOne-msvc2022-win64.exe进行安装。到图1的步骤时，选择第二项。
图1 下一步， 安装路径可以自行修改（我的安装路径D:\PCL 1.13.1），之后点击安装即可。
一段时间之后，会弹出来一个OpenNI2的安装窗口，此时将OpenNI2放在3rdparty文件夹里，即D:\PCL 1.13.1\3rdParty\OpenNI2。由于点云在安装的过程中会把所有的第三方库全部安装在点云安装目录下的3rdparty文件夹里。因此，为了保持文件夹的整洁，把OpenNI2放在3rdparty文件夹里。
如果3rdParty文件夹下的OpenNI2内容为空，可以将其移除：在PCL安装路径下的3rdParty/OpenNI2文件夹内可以看到安装包OpenNI-Windows-x64-2.2.msi，双击运行，选择Remove移除安装再重新安装即可。
配置PDB文件
将下载得到的压缩包pcl-1.13.1-pdb-msvc2022-win64.zip解压缩后将里面的文件复制到PCL安装目录下bin文件夹
至此点云库安装完成，安装目录和3rdparty文件夹如下表所示：
3、配置环境变量 首先确认OpenNI2的环境变量是否设置正确
然后打开Path，添加如下
%OPENNI2_REDIST64% %OPENNI2_LIB64% %OPENNI2_INCLUDE64% 4、VS 环境配置 4.1 创建项目 新建一个控制台应用（目录可以放在pcl的安装路径下），建立一个项目属性表（目的：以后新建一个PCL项目文件直接调用配置好的属性表，一劳永逸）
debug和release配置大体相同，不同的地方后面会提及。 之后新建项目时就可以加载配置好的属性表。
打开vs建立了一个pcl项目的前提下，再次新建项目并导入.props文件，运行该pcl项目可能会失败。可以重启vs。
4.2 配置包含目录 打开属性表，配置VC++目录中的包含目录。在配置 PCL 包含目录路径时，连接符应该使用分号（;），注意路径之间不要有空格，并且最后一个路径不需要加分号。
D:\PCL 1.13.1\3rdParty\Boost\include\boost-1_82;D:\PCL 1.13.1\3rdParty\Eigen\eigen3;D:\PCL 1.13.1\3rdParty\FLANN\include;D:\PCL 1.13.1\3rdParty\OpenNI2\Include;D:\PCL 1.13.1\3rdParty\Qhull\include;D:\PCL 1.13.1\3rdParty\VTK\include\vtk-9.2;D:\PCL 1.13.1\include\pcl-1.13 4.3 配置库目录 D:\PCL 1.13.1\3rdParty\Boost\lib;D:\PCL 1.13.1\3rdParty\FLANN\lib;D:\PCL 1.13.1\3rdParty\OpenNI2\Lib;D:\PCL 1.13.1\3rdParty\Qhull\lib;D:\PCL 1.13.1\3rdParty\VTK\lib;D:\PCL 1.13.1\lib 4.4 配置预处理器 debug模式可以如下配置，release模式只添加后面三项即可
_DEBUG _CONSOLE _CRT_SECURE_NO_WARNINGS BOOST_USE_WINDOWS_H NOMINMAX _CRT_SECURE_NO_DEPRECATE debug模式release模式 4.5 附加依赖项配置 需要对Boost（92）、VTK（284）、PCL（40）几个文件夹内lib文件夹内的.lib文件进行提取。Debug是 **d.lib 类型，Release是 *.lib 类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6153999a94b0e6dff978f268e7acd49/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/69/">«</a>
	<span class="pagination__item pagination__item--current">70/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/71/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>