<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4297a4117a99e7c6b0f21f7d40b67ef/" rel="bookmark">
			C指针详解(经典,非常详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要了解指针,多多少少会出现一些比较复杂的类型,所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单,一个类型里会出现很多运算符,他们也像普通的表达式一样,有优先级,其优先级和运算优先级一样,所以我总结了一下其原则:从变量名处起,根据运算符优先级结合,一步一步分析.下面让我们先从简单的类型开始慢慢分析吧: [cpp] view plain copy int p; //这是一个普通的整型变量 int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针 int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组 int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组 int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针 int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针. int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针 int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 说到这里也就差不多了,我们的任务也就这么多,理解了这几个类型,其它的类型对我们来说也是小菜了,不过我们一般不会用太复杂的类型,那样会大大减小程序的可读性,请慎用,这上面的几种类型已经足够我们用了. 一、细说指针 指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。 先声明几个指针放着做例子： 例一： [cpp] view plain copy (1)int*ptr; (2)char*ptr; (3)int**ptr; (4)int(*ptr)[3]; (5)int*(*ptr)[4]; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4297a4117a99e7c6b0f21f7d40b67ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6efdec5412f699ea2efe93eb18382f/" rel="bookmark">
			C#导出excel引发COMException (0x80040154)异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在维护一个测试软件，导出excel时发生System.Runtime.InteropServices.COMException (0x80040154)异常，判断应该是COM调用出现问题。
尝试了以下两种方法：
（1）使用regsvr32 dll路径 命令注册组件，弹出找不到入口点 DllRegisterServer点错误对话框，失败。
（2）安装WPS，问题解决，异常也没有弹出。
结论：
如果程序调用office或wps的相关组件，而客户机上没有安装office或wps 的办公软件，很可能出现COM组件引用失败的情况，可以采用一些第三方库如spire.office或NPOI库来脱离office的依赖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b8137cf0b7dd7d94245d08f603e15c/" rel="bookmark">
			时间加减快速get
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
有一天小白凑到同事的电脑桌前，尼玛就看到了【select system-6/24/60 from dual】，才疏学浅的小白羞愧了，看不懂哇，来来来，迅速get！
----------------------------------------------------------------------------------------------------------------------
加法 select sysdate,add_months(sysdate,12) from dual; --加1年
select sysdate,add_months(sysdate,1) from dual; --加1月
select sysdate,to_char(sysdate+7,'yyyy-mm-dd HH24:MI:SS') from dual; --加1星期
select sysdate,to_char(sysdate+1,'yyyy-mm-dd HH24:MI:SS') from dual; --加1天
select sysdate,to_char(sysdate+1/24,'yyyy-mm-dd HH24:MI:SS') from dual; --加1小时
select sysdate,to_char(sysdate+1/24/60,'yyyy-mm-dd HH24:MI:SS') from dual; --加1分钟
select sysdate,to_char(sysdate+1/24/60/60,'yyyy-mm-dd HH24:MI:SS') from dual; --加1秒
减法
select sysdate,add_months(sysdate,-12) from dual; --减1年
select sysdate,add_months(sysdate,-1) from dual; --减1月
select sysdate,to_char(sysdate-7,'yyyy-mm-dd HH24:MI:SS') from dual; --减1星期
select sysdate,to_char(sysdate-1,'yyyy-mm-dd HH24:MI:SS') from dual; --减1天
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b8137cf0b7dd7d94245d08f603e15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc2f00eb0ce3df5ff7d60c01d877ae47/" rel="bookmark">
			kubernetes实践之十四：Service Account与Secret
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：Service Account与Secret数据结构 二：Service Account与Secret运行机制 1.kubernetes的master节点由三部分组成kube-apiserver,kube-scheduler和kube-controller-manager。其中controller manager会根据apiserver的配置信息(--admission-control和--service-account-private-key-file)，生成ServiceAccount controller 和token controller. 2.ServiceAccount controller一直监听Service Account和Namespace事件。如果一个Namespace中没有default Service Account，那么Service Account Controller就会为该Namespace创建一个默认的（default）的Service Account。 3.Token Controller也监听Service Account的事件，如果发现新建的Service Account里没有对应的Service Account Secret，则会用API Server私钥（--service-account-private-key-file指定的文件）创建一个Token（JWT Token），并用该Token、CA证书(这个是API Server的CA公钥证书，来源于controller-manager配置文件中的root-ca-file),Namespace名称等三个信息产生一个新的Secret对象，然后放入刚才的Service Account中；如果监听到的事件是删除Service Account事件，则自动删除与该Service Account相关的所有Secret。此外，Token Controller对象同时监听Secret的创建、修改和删除事件，并根据事件的不同做不同的处理。
4.API Server收到Token以后，采用自己的私钥（实际是使用apiserver配置文件中的参数service-account-key-file指定的私钥，如果此参数没有设置，则默认采用tls-private-key-file指定的参数，即自己的私钥）对Token进行合法验证。 三：Service Account相关概念 1. Service Account概念的引入是基于这样的使用场景：运行在pod里的进程需要调用Kubernetes API以及非Kubernetes API的其它服务。Service Account它并不是给kubernetes集群的用户使用的，而是给pod里面的进程使用的，它为pod提供必要的身份认证。 2. 如果kubernetes开启了ServiceAccount(apiserver配置文件)那么会在每个namespace下面都会创建一个默认的default的service account。
3.ServiceAccount详情
4.当创建pod的时候，如果没有指定一个service account,系统会自动在该pod所在的namespace下为其指派一个default service account. a. 如果spec.serviceAccount域没有被设置，则Kubernetes默认为其制定名字为default的Serviceaccount； b. 如果Pod的spec.serviceAccount域指定了default以外的ServiceAccount，而该ServiceAccount没有事先被创建，则该Pod操作失败； c. 如果在Pod中没有指定“ImagePullSecrets”，那么该sec.serviceAccount域指定的ServiceAccount的“ImagePullSecrets”会被加入该Pod； d. 给Pod添加一个新的Volume，在该Volume中包含ServiceAccountSecret中的Token，并将Volume挂载到Pod中所有容器的指定目录下（/var/run/secrets/kubernetes.io/serviceaccount）;
四：Secret相关概念
1. Secret解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者Pod Spec中。Secret可以以Volume或者环境变量的方式使用。
2. Secret有三种类型：
·Service Account：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中；
·Opaque：base64编码格式的Secret，用来存储密码、密钥等；
·kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息。
我们可以通过Secret保管其它系统的敏感信息，并以Mount的方式将Secret挂载到Container中，然后通过访问目录中文件的方式获取该敏感信息。当Pod被API Server创建时，API Server不会校验该Pod引用的Secret是否存在。一旦这个Pod被调用，则kubelet将试着获取Secret的值，如果Secret不存在或者暂时无法连接到API Server,则kubelet将按一定的时间间隔定期重试获取Secret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc2f00eb0ce3df5ff7d60c01d877ae47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3edca204ca2eba69dc00cd2c377da9/" rel="bookmark">
			VirtualBox虚拟机几种网络连接方式介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了学习和使用Linux，多数人选择了使用VirtualBox虚拟机的方式来安装Linux系统。VirtualBox提供了多种网络连接方式，不同的网络连接方式决定了虚拟机是否可以联网，以及是否可以和宿主机互相ping通。本文将主要介绍常用的桥接、NAT和host-only三种网络连接方式的区别，以减少大家在使用中的困扰。
一、不同网络连接方式对网络网络影响简介：
桥接NAThost-only虚拟机与宿主机彼此互通，处于同一网段虚拟机能访问宿主机；宿主机不能访问虚拟机虚拟机不能访问宿主机；宿主机能访问虚拟机虚拟机与虚拟机彼此互通，处于同一网段彼此不通彼此互通，处于同一网段虚拟机与其他主机彼此互通，处于同一网段虚拟机能访问其他主机；其他主机不能访问虚拟机彼此不通；需要设置虚拟机与互联网虚拟机可以上网虚拟机可以上网彼此不通；需要设置 二、三种网络连接方式详细介绍：
我本机宿主机使用win10系统，IP地址为：19.168.1.117。
1、桥接方式
桥接方式下，虚拟机和宿主机处于同一网段，真实存在于网络中，像是一台真实的主机。虚拟机和宿主机彼此互通，且网络中的其他主机也可以互通。就像是连接在hub中的主机一样。获取的IP地址网段为：192.168.1.X，实际获取的为192.168.1.220。
优点：可以轻松实现上网，同网段中的主机任意互通。
缺点：占用网段中的IP地址。
2、NAT方式
NAT方式全称Network Address Translation，即借助网络地址转换功能，通过宿主机所在的网络实现访问互联网。此种方式下，虚拟机并不真实的存在于网络中，所以宿主机无法ping通虚拟机，虚拟机彼此间也不通。但是通过nat虚拟机可以访问互联网，且可以访问宿主机以及宿主机同网络中的其他主机。
NAT方式默认的IP段为10.0.2.X，首台虚拟机IP为10.0.2.15，网关为：10.0.2.2，DNS为：10.0.2.3。
优点：轻松实现上网，不占用网段中的IP地址。
缺点：宿主机不能访问虚拟机，同网段中的主机无法找到虚拟机。
3、host-only方式
host-only方式下，虚拟机和真实的网络是互相隔离的，不过所有的虚拟机彼此是可以互通的，可是访问不了互联网。宿主机可以访问虚拟机。虚拟机IP地址段为：192.168.65.X，实际分配到的IP地址为：192.168.65.3。
优点：可以和真实的网络环境隔离，宿主机可以访问虚拟机。
缺点：虚拟机无法上网。
综上所述，大家可以根据需要设置虚拟机的网络连接模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49a353fb09133f49ef57199a7718ea2f/" rel="bookmark">
			C/C&#43;&#43;中scanf和cin的读取回车、空格等分隔符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入流cin无论什么情况下都会忽略tab、空格、回车等分隔符，包括但不限于cin&gt;&gt;int,cin&gt;&gt;char,cin&gt;&gt;string等情况。
scanf函数在除scanf("%c",&amp;char)之外的所有情况都不会把回车符作为输入字符在输入缓存中读取，但scanf("%c",&amp;char)也不会读取tab、空格，而是把他们作为分隔符在输入缓存中忽略。
那么怎么输入带空格的字符串呢？ C++：
（1）getline(istream &amp;is , string &amp;str , char delim)
其中，istream &amp;is 表示一个输入流，譬如cin；
string&amp;str表示把从输入流读入的字符串存放在这个字符串中（可以自己随便命名，str什么的都可以）；
char delim表示遇到这个字符停止读入，在不设置的情况下系统默认该字符为’\n’，也就是回车换行符（遇到回车停止读入）。
（2）cin.getline(字符指针(char*),字符个数N(int),结束符(char));
此函数会一次读取多个字符(包括空白字符）。它以指定的地址为存放第一个读取的字符的位置，依次向后存放读取的字符，直到读满N-1个，或者遇到指定的结束符为止。若不指定结束符，则默认结束符为’\n’。
getline()将换行符丢弃，而get()将换行符保留在输入序列里
C：
（1）利用格式符“%[]”它的作用为扫描字符集合。scanf(“%[^c]”,str); 其中“c”是一个具体的字符常量（包括控制字符）。当输入字符串时，字符“c”将被当作当前输入的结束符。利用此格式符就可以由编程者自己指定一个输入结束符。
void main() { char* msg = NULL; msg = (char *)malloc(100 * sizeof(char)); scanf("%[^\n]", msg); // \n作为字符串输入的结束符 printf("%s", msg); return 0; } （2）使用gets函数，gets函数是以回车作为结束符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041e47f2f4088b0aebae90c9f32b901c/" rel="bookmark">
			Android-计算器的实现（界面布局，计算逻辑处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码下载
闲来无事，用android做一个计算器玩玩，想着做一个私密空间，表面是计算器，按下原先设定的算式后可以跳转到私密界面，当想想有些费事，以后若还有闲散时间，再来实现。
我实现了更完善的计算器，功能更多，逻辑更完善，欢迎访问！点击这里 界面是这样的，采用了GridLayout布局，很容易实现。代码如下
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;GridLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content" android:layout_height="wrap_content" android:columnCount="4" android:layout_gravity="center" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/contentText" android:textSize="16sp" android:text="@string/defaultText" android:layout_gravity="fill" android:maxLines="1" android:layout_marginTop="55sp" android:paddingRight="15sp" android:layout_columnSpan="4" android:gravity="right"/&gt; &lt;Button android:id="@+id/bt1" android:text="@string/bt1" android:textSize="15sp" android:layout_gravity="fill" android:layout_marginTop="25sp" android:layout_marginRight="5sp" android:layout_marginBottom="5sp" /&gt; &lt;Button android:id="@+id/bt2" android:text="@string/bt2" android:textSize="15sp" android:layout_gravity="fill" android:layout_marginTop="25sp" android:layout_marginBottom="5sp" android:layout_marginRight="5sp" android:layout_columnSpan="2" /&gt; &lt;Button android:id="@+id/bt18" android:text="@string/bt18" android:textSize="15sp" android:layout_marginTop="25sp" android:layout_marginBottom="5sp" /&gt; &lt;Button android:id="@+id/bt3" android:text="@string/bt3" android:textSize="15sp" android:layout_marginRight="5sp" android:layout_marginBottom="5sp" /&gt; &lt;Button android:id="@+id/bt4" android:text="@string/bt4" android:textSize="15sp" android:layout_marginRight="5sp" android:layout_marginBottom="5sp" /&gt; &lt;Button android:id="@+id/bt5" android:text="@string/bt5" android:textSize="15sp" android:layout_marginRight="5sp" android:layout_marginBottom="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041e47f2f4088b0aebae90c9f32b901c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d30253ac439351dae74148f022c042/" rel="bookmark">
			VMware搭建CentOS，使用普通用户切换ROOt登入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.想要使用VMware搭建CentOs（Lunix）的朋友，可以评论给邮箱，我把文件+操作发你。
进入系统初始是Hadoop用户，我们要切换Root用户
1.如果你的用户在sudoers file中可以下面设置Root密码
sudo passwd root 回车
(输入密码,但不会在屏幕显示出*)
(再输入一次密码)
然后 root 登陆
2.如果报错hadoop is not in the sudoers file.this incident will be reported 时。解决:
1. su - //切换到root权限，横线‘‘-’’的作用是将环境变量也切换到root，如果不加横线“-”，则只切换到root权限，但环境变量还是当前用户的环境变量。 2. 执行visudo命令，代开visudo文件 3.在文件中找到如下两行： 普通用户执行sudo报hadoop is not in the sudoers file. This incident will be reported.解决方法 ## Allow root to run any commands anywhere root ALL=(ALL) ALL 4. 在这两行后面添加一行，比如你的用户名是Dylan，就这样写： Dylan ALL=(ALL) ALL 5. ESC键进入命令模式，输入 :wq 保存退出。 3.此时在来设置ROOT密码
sudo passwd root 回车
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d30253ac439351dae74148f022c042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f3ecb7da17d16f6374961cc1a629a3/" rel="bookmark">
			C语言实现顺序链表的创建和删除插入元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #define LEN sizeof(struct student) /* 顺序链表的创建、删除、插入操作 */ struct student{ int num; float score; struct	student *next; }; int n; struct student *creat(){//创建链表; struct student *head;//头结点 struct student *p1,*p2; p1=p2=(struct student *)malloc(LEN);//分配内存 printf("\n请输入学号\n"); scanf("%d",&amp;p1-&gt;num); printf("\n请输入分数\n"); scanf("%f",&amp;p1-&gt;score); head=NULL; n=0; while(p1-&gt;num){ n++; if(n==1){ head=p1; }else{ p2-&gt;next=p1; } p2=p1; p1=(struct student *)malloc(LEN); printf("\n请输入学号"); scanf("%d",&amp;p1-&gt;num);//输入为0则条件为0停止循环 printf("\n请输入分数"); scanf("%f",&amp;p1-&gt;score); } p2-&gt;next=NULL; return head; } void print(struct student *head){//输出链表 struct student *p;//定义指针 p=head;//指针传递 if(head){ do{ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12f3ecb7da17d16f6374961cc1a629a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409f41154bc458c15e2430ebab90cdd9/" rel="bookmark">
			spark踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spark、spark调优、spark streaming常见问题总结
1.server.TransportChannelHandler: Exception in connection from xxxxxx。java.io.IOException: Connection reset by peer
增加内存后解决了问题
2.集群模式下spark应用ID应该是local开头，如果是application开头，则要看下代码里setMaster方法是否写死了local模式
3.参数优化最终参数
spark-submit \
--master yarn \
--num-executors 50 \
--executor-memory 4G \
--executor-cores 2 \
--driver-memory 8G \
--conf spark.default.parallelism=200 \
--conf spark.yarn.executor.memoryOverhead=2048 \
--conf spark.storage.memoryFraction=0.5 \
--conf spark.shuffle.memoryFraction=0.3 \
--class com.xxx.rc.enginetask.service.article.ArticleHBaseALS
4.Error:(18, 31) type arguments [String,String,io.netty.handler.codec.string.StringDecoder,io.netty.handler.codec.string.StringDecoder] conform to the bounds of none of the overloaded alternatives of
value createDirectStream: [K, V, KD &lt;: kafka.serializer.Decoder[K], VD &lt;: kafka.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409f41154bc458c15e2430ebab90cdd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61b7386660692d8adad32314e59a2d94/" rel="bookmark">
			IntelliJ IDEA如何运行单个程序？跳过错误项目中的错误JAVA类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目前在使用IDEA学习JAVA，遇到了一个奇怪的问题，我想运行当前单个程序，但是运行完总是弹出其他程序的错误，这怎么解决？
一个迅速的解决方法：
Run - Edit Configurations - Before launch 里面，把 Build 换成 Build, no error check ， Apply之后按往常一样运行就可以啦。当然，前提是你这个main函数所依赖的所有class都没有错误
这样就跟eclipse里面一样了，如下图
&amp;amp;lt;img src=&amp;quot;https://pic2.zhimg.com/50/v2-dcfd767b834cd2f9eaaadbcf95cb62e2_hd.jpg&amp;quot; data-rawwidth=&amp;quot;1221&amp;quot; data-rawheight=&amp;quot;885&amp;quot; class=&amp;quot;origin_image zh-lightbox-thumb&amp;quot; width=&amp;quot;1221&amp;quot; data-original=&amp;quot;https://pic2.zhimg.com/v2-dcfd767b834cd2f9eaaadbcf95cb62e2_r.jpg&amp;quot;&amp;amp;gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40850ccab8cdabc6868888fd85808d0e/" rel="bookmark">
			神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络可以解决当特征太多,计算负荷过大的问题.比如在处理图像问题时,一张图片每一个像素都是一个特征,用神经网络就比较合适. 神经网络起源于80~90年代,但是在90年代后期就减少了.而现在神经网络又再次兴起,原因是计算机运行速度变快,解决了神经网络计算量偏大的问题. 每个神经元都可以被认为是一个处理单元/神经核(processing unit/ Nucleus),它含有许多输入/树突(input/Dendrite),并且有一个输出/轴突(output/Axon) 神经网络模型建立在很多神经元上,每一个神经元又是一个学习模型,也称为激活单元(activation unit),在神经网络中参数 θ θ 由被称为权重(weight). 其中 x1,x2,x3 x 1 , x 2 , x 3 是输入单元(input units),这个是原始的特征 a1,a2,a3 a 1 , a 2 , a 3 是中间单元, 最后是输出单元,计算 hθ(x) h θ ( x ) . 每一层的输出变量都是下一层的输入变量.第一城(layer1)是输入层(input layer),最后一层(layer3)称为输出层(output layer),中间一层称为隐藏层(hidden layers).每一层都增加一个偏差单元(bias unit) a(j)i a i ( j ) 代表第j层的第i个激活单元. θ(j) θ ( j ) 代表从第j层映射到第j+1层时的权重的矩阵,例如 θ(1) θ ( 1 ) 代表从第一层映射到第二层的权重的矩阵.其尺寸为以j+1层激活单元数量为行数,以第j层的激活单元数加1为列的矩阵.例如,上图所示矩阵 θ(1) θ ( 1 ) 的尺寸为3*4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40850ccab8cdabc6868888fd85808d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2647341dd0174f526fa088063058ea/" rel="bookmark">
			gradle升到4.4后，报Unable to resolve dependency for &#39;:app@debug/compileClasspath&#39;:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android studio可以升级到3.1了，默认用的是gradle4.4
修改为
distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip buildscript { repositories { jcenter() google() maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'} } dependencies { classpath 'com.android.tools.build:gradle:3.1.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'} maven { url "https://jitpack.io" } google() } } 再把所有的依赖包改成，implementation.
build后就开始报各个依赖包 Unable to resolve dependency for ':app@debug/compileClasspath': Could not resolve com.xxx.
查了半天，所有配置都是对的，离线模式(offline work)也关了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c2647341dd0174f526fa088063058ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9274ea812382f040b34284c3fd1ae42/" rel="bookmark">
			win10美化工具全套详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1， 任务栏透明工具StartllsBack 1， 首先安装，选第一个为当前用户安装。（这个选哪个都可以的）
2，然后就是设置这个任务栏透明了，右键“开始“菜单找到”属性“打开。
图中标红色的设置成图中一样的就行了。然后点击应用-&gt;确定，任务栏就变成透明了
二，弹出软件设置RocketDock 1，打开软件之后在图标上右键，选择程序设置。然后照着下图设置一遍。
3， 现在可以添加软件了，右键选择添加项目，选择文件，找到桌面，把程序拖进去就行了。设置完成。
三，雨滴设置 1， 安装Rainmeter。
2， 下载插件，把插件放到C:\Users\Merry\Documents\Rainmeter\Skins文件夹里。
3， 打开软件，如果没出现插件，先刷新一下。
4， 然后选择加载就好了。完成
四，动态壁纸获取，就一个软件。UPUPOO。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c177c16ff104597ff92c0babbb871276/" rel="bookmark">
			第一个例子：使用 Sorter 接口排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 一个很好的例子是来自标准库的 sort 包，要对一组数字或字符串排序，只需要实现三个方法：反映元素个数的 Len()方法、比较第 i 和 j 个元素的 Less(i, j) 方法以及交换第 i 和 j 个元素的 Swap(i, j) 方法。 排序函数的算法只会使用到这三个方法（可以使用任何排序算法来实现，此处我们使用冒泡排序）：
func Sort(data Sorter) { for pass := 1; pass &lt; data.Len(); pass++ { for i := 0;i &lt; data.Len() - pass; i++ { if data.Less(i+1, i) { data.Swap(i, i + 1) } } } } Sort 函数接收一个接口类型参数：Sorter ，它声明了这些方法：
type Sorter interface { Len() int Less(i, j int) bool Swap(i, j int) } 参数中的 int 是待排序序列长度的类型，而不是说要排序的对象一定要是一组 int。i 和 j 表示元素的整型索引，长度也是整型的。 现在如果我们想对一个 int 数组进行排序，所有必须做的事情就是：为数组定一个类型并在它上面实现 Sorter 接口的方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c177c16ff104597ff92c0babbb871276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6919639f31bf5f14ba4af23b4d0dc8b4/" rel="bookmark">
			一道全排列算法题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 牛客网题目链接
解题思路：用set保存中间结果集，确保唯一性，先举出一个元素的全排列，再往里面逐个添加元素，每次增加一个元素，该元素在之前结果集的每一个排列，假设该排列的字符串长度为k, 那么该元素有k+1个位置可以插入，形成新的排列，再将新的排列保存，下次再添加新元素，拿新的排列集合去做同样的操作，直到所有元素加入完成，用优先队列排字典序，再将结果返回。
class Solution { public: set&lt;string&gt; solve(char a, set&lt;string&gt; tt){ set&lt;string&gt; ans; if(tt.empty()){ string s = ""; s += a; ans.insert(s); }else{ set&lt;string&gt;::iterator it; for(it = tt.begin();it != tt.end(); ++it){ string s = (*it); ans.insert(a + s); int len = s.length(); for(int j = 1;j &lt; len;++j){ string news = s.substr(0,j) + a + s.substr(j,len-1); ans.insert(news); } ans.insert(s + a); } } return ans; } vector&lt;string&gt; Permutation(string str) { //A-Z a-z //init int len = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6919639f31bf5f14ba4af23b4d0dc8b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112dbf6fcc8998bee1cdf146fdbc7ee1/" rel="bookmark">
			react-native 学习笔记1---创建与运行项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习这件事就是一件不停的踩坑、填坑的过程。
最近开始学习react-native，从创建项目开始，本以为有前辈们的提醒，可以少踩坑，如履平地的往前走，但是有些坑如果不去踩一下人生是不完整的。。。
接下来我也记录下自己踩过的坑吧
首先是搭建环境，这个官方文档已经说的很详细了，pass
其次是构建项目，此处按照命令行一步步走是没错的
react-native init yourapp // 这里需要注意：直接用该命令默认新建的最新版本，而最新版本直接运行会报错，需要引入第三方库 cd yourapp react-native run-ios 如果不想引第三方库，就创建0.45之前的版本，使用以下命令：
react-native init --version=0.44.3 yourapp 构建完成之后会提示你如何运行项目，此处列举ios的，有两种方法：
1、在命令行cd到你刚建的目录下，然后 react-native run-ios
2、直接找到项目目录下ios文件夹，用xcode打开其中的xcode文件，然后点击xcode左上角run按钮
运行成功后会自动打开ios模拟器，如下图
虽说过程看起来很容易，实际我是创建好几次才成功的，主要的原因就是版本的问题，如果遇到版本问题，可以手动改一下package.json文件，将其中的react和react-native版本改为下面这样，试一下吧，不能百分百好使。
然后删掉node moudles文件夹，重新npm install一下，最后重新运行（重复以上步骤）。
goodluck！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7876a65e791482b45195d6ab4989a8a7/" rel="bookmark">
			JAVA中的终结类、终结方法 和 抽象类、抽象方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.终结类与终结方法：用final修饰的类和方法
1.终结类不能被继承
2.终结方法不能被子类覆盖
栗子：终结类
final class A {.....} //声明A类 为final类
class B extends A {....} //编译器将会报错
栗子：终结方法
class Parent { public Parent() { } //构造方法 final int getPI() { return Math.PI} //终结方法 } Class Child extends Parent { public Child() {} int getPI() { return 3.14;} //错误！,不允许在子类中覆盖超类中的终结方法 } 二.抽象类：类名前加修饰符abstract
1.可包含常规类能包含的任何成员，包括非抽象方法；
2.也可包含抽象方法：用abstract修饰，只有方法原型，没有方法的实现；
3.没有具体实例对象的类，不能使用new方法进行实例化，只能用做超类；
4.只有当子类实现了抽象超类中的所有抽象方法，子类才不是抽象类，才能产生实例。（若子类中扔有抽象放方法未实现，则子类也只能是抽象类）
三.抽象方法： public abstrac &lt;returnType&gt; &lt;methodName&gt; (...);
1.仅有方法原型，而没有方法体；
2.抽象方法的具体实现由子类在它们各自的类声明中完成；
3.只有抽象类可以包含抽象方法。
四.抽象方法的优点
1.隐藏具体的细节信息，所有的子类使用的都是相同的方法原型，其中包含了调用改方法时需要了解的全部信息；
2.强迫子类完成指定的行为，规定所有子类的“标准”行为。
栗子：抽象的绘图类和抽象方法
//各种图形都需要实现绘图方法，可以在它们的抽象超类中声明一个draw抽象方法 abstract class GraphicObject{ int x,y; abstract void draw(); //希望在所有的图形类中,都能有一个统一的绘图接口,于是定了抽象draw类,而没有具体实现 } //然后在每个子类中覆盖draw方法,给出自己的具体实现 class Circle extends GraphicObject { void draw(){.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7876a65e791482b45195d6ab4989a8a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67aa4271cb6cfa8f0fa082033665cf79/" rel="bookmark">
			SQL中LAG和OVER函数的意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做BI查询时，有时会需要看上一条纪录的情况，那么需要怎么做呢？现代的数据仓库系统或者RDBMS系统一般都会提供一个一个函数来供你分析上几条或下几条的数据。比如LAG和LEAD。
LAG( shorten_url IGNORE NULLS ) OVER ( PARTITION BY hit_day, session_id ORDER BY click_id ) Oracle从8.1.6开始提供分析函数，分析函数用于计算基于组的某种聚合值，它和聚合函数的不同之处是：对于每个组返回多行，而聚合函数对于每个组只返回一行。
Parttion by 关键字是Oracle中分析性函数的一部分，它和聚合函数不同的地方在于它能够返回一个分组中的多条记录，儿聚合函数一般只有一条反映统计值的结果。
lead(列名,n,m): 当前记录后面第n行记录的&lt;列名&gt;的值，没有则默认值为m；如果不带参数n,m，则查找当前记录后面第一行的记录&lt;列名&gt;的值，没有则默认值为null。
lag(列名,n,m): 当前记录前面第n行记录的&lt;列名&gt;的值，没有则默认值为m；如果不带参数n,m，则查找当前记录前面第一行的记录&lt;列名&gt;的值，没有则默认值为null。
LAG的意思Lag()就是取当前顺序的上一行记录。结合over就是分组统计数据。
很多时候查询结果上下行其实是相同事物不同发展状态下的结果，比较两种结果最简单的方法就是加减乘除，但是上下两行在数据表格中不好操作，利用Lag函数将其下移就可以同行相减等。所以与Lag常常合起来用的partition by就是分组按你的条件将你规定相同的东西分成同类。
详细文档：https://docs.microsoft.com/en-us/sql/t-sql/functions/lag-transact-sql
原文:http://blog.csdn.net/hongchangfirst/article/details/79752881
作者:hongchangfirst
hongchangfirst的主页:http://blog.csdn.net/hongchangfirst
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19739794c07bf81aad3c494e3d3d436/" rel="bookmark">
			微信小程序的三级分销-项目表格设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目的三级分销功能 表格设计（1）
1.每一个用户只有一个上级
分销系统
Distribution 分销表格
Id
userid
oid
time
邀请人
被邀请人id
时间
distridetail 用户购买分销得钱
Id
uid
sid
time
ordernumber
money
用户的id
得到钱的id
时间
订单
得到的钱
Distrimoney 分销的比例
Id
stair
second
status
一级得钱的比例
二级得钱比例
状态
2. 对程序的要求是
0.1：注册之后的用户才可以邀请另外的人；
0.2：被邀请人点开始之后，可以在被邀请人的程序端拿到两人的唯一标识
0.3：定义一下，是消费之后才算是邀请成功，还是注册之后
3.后台的逻辑人
每一个用户只可能有一个上级
当用户产生消费的时候拿着自己的id(过被邀请的人)去查邀请人的id，拿到邀请人的id还需要再次去查邀请人
这一步就是一个循环查询两次的事件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2891c668298648dca1c8cb305449049a/" rel="bookmark">
			机器学习 线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梯度下降实现线性回归 求导 最终算法: 多变量线性回归 基础知识 n 代表特征数量 x(i) x ( i ) 代表第i个训练实例,是特征矩阵中的第i行,是一个向量(vector) x(i)j x j ( i ) 代表特征矩阵中第i行的第j个特征,也就是第i个训练实例的第j个特征.
多变量假设模型 hθ(x) h θ ( x ) 也可以用向量表示为 代价函数为 优化目标 多项式回归* 线性回归并不适用于所有数据,有时需要用曲线来适应数据,比如:二次方或者三次方模型 另外我们也可以令 x2=x22,x3=x23 x 2 = x 2 2 , x 3 = x 3 2 将模型转换为线性模型.
正规方程 就只直接令代价函数为0,而不使用梯度下降方法来求代价函数的最小值.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218a5039cdb5aec7bb4f5baade763126/" rel="bookmark">
			机器学习 基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		m 代表训练集(training set)中实例的数量 x 代表特征(feature)/输入(input) 变量 y 代表目标(target)/输出(output) 变量 (x,y) 代表训练集中的实例 (x(i),y(i)) ( x ( i ) , y ( i ) ) 代表第i个观察实例 h代表学习算法的模型,也称假设(hypothesis), hθ(x)=θ0θ1x h θ ( x ) = θ 0 θ 1 x θ θ 被称为参数(parameters) 模型预测值和训练集中实际值之间的差距就是建模误差(modeling error) 代价函数 学习的过程就是使代价函数(cost function)最小 梯度下降 梯度下降是用来求函数最小值的算法,同样也适用于代价函数. 代价函数的梯度下降思想是:随机选择一个参数的组合 (θ0,θ1,...,θn) ( θ 0 , θ 1 , . . . , θ n ) ,计算代价函数,接着找一个能让代价函数值下降最多的参数组合,不断迭代.直到直到局部最小值(local minimum),因为没有尝试所有组合所以不能确定最小值是否是全局最小(global minimum). 这个就是批量梯度下降的计算公式(batch gradient descent),其中 α α 是学习速率(learn rate),学习速率随着越接近最小值,而变小(如果学习速率太大,则有可能越过最小值,使得代价函数发散)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/218a5039cdb5aec7bb4f5baade763126/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca2f2d2a18c92872527882e0dabd26f/" rel="bookmark">
			STM32之SPI读写FLASH(W25Q64)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 名称:STM32之SPI读写FLASH(W25Q64) 说明: 1.对于SPI读写FLASH和I2C读写EEPROM很相似，都是通过一定的通信协议来操纵外部存储设备。我们需要按照对应的通信协议发送存储设备所支持的指令（如读指令、写指令等），然后等待存储设备根据主机所接收到的指令进行相应的动作。
2.再来说说不同点吧：对于通信协议来说，I2C相对来说要简单些，通信速度也稍微较慢些。而SPI串行通信协议则要相对复杂的多，当然其通信速度也要高不少。对于存储设备来说，EEPROM属于小容量的存储设备，支持字节擦除、页写入，现在一般用于存储小容量的数据；而FLASH属于大容量的存储设备，不支持字节擦除，只支持扇区擦除、块擦除和整片擦除，要注意的是在对FLASH进行写入的时候一般都需要先进行擦除，否则可能会导致数据出错。
3.这里介绍一个连续多字节写入函数。无论是对于EEPROM和FLASH来说，其都有“写入回滚”的现象（就是达到页边界的话，会重新从一页的开始出重新进行写入）。所以，这样的话连续多字节写入就要考虑是否达到页边界的问题。对于页写入函数一般的思路：是按照所给的地址是否正好是页首处、要写入的字节数是否大于一页等等进行讨论。在本驱动程序中写了一个函数，不用考虑是否达到边界的问题，写入字节数也没有限制（当然要小于FLASH容量）。其基本的思路是：采用页偏移的概念，即到达下一个页边界还需要多少字节，每次写入的字节数就是这个页偏移和待写入剩余字节的最小值。具体的代码见： SPI_Write_Datas(uint32_t addr,uint8_t *writeBuff,uint32_t numByteToWrite)；
注:本驱动程序大部分来自STM32指南者配套代码 */
驱动程序源文件：
#include "./flash/bsp_spi_flash.h" #include "./usart/bsp_usart.h" static __IO uint32_t SPITimeout = SPIT_LONG_TIMEOUT; static uint32_t SPI_TIMEOUT_UserCallback(uint8_t errorCode); /** * @brief SPII/O配置 * @param 无 * @retval 无 */ static void SPI_GPIO_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; /* 使能与SPI 有关的时钟 */ FLASH_SPI_APBxClock_FUN ( FLASH_SPI_CLK, ENABLE ); FLASH_SPI_GPIO_APBxClock_FUN ( FLASH_SPI_GPIO_CLK, ENABLE ); /* MISO MOSI SCK*/ GPIO_InitStructure.GPIO_Pin = FLASH_SPI_SCK_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(FLASH_SPI_SCK_PORT, &amp;GPIO_InitStructure); GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca2f2d2a18c92872527882e0dabd26f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf3856e1d1828c23018d3ddb6a6dadb/" rel="bookmark">
			SimpleHostRoutingFilter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; /*
* Copyright 2013-2017 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf3856e1d1828c23018d3ddb6a6dadb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a8be19cd9c761b4b3d58b28bd0cb0c/" rel="bookmark">
			numpy矩阵遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、遍历一个numpy类型的矩阵
我原来一直以为[][]和[,]这两种写法没有区别，其实两种效果完全不一样，对比之后一般不建议[][]这样写！
#coding:utf-8 import numpy as np a=np.array([[1,2,3],[4,5,6]]) print(a.shape) #(2,3) print(a[:][0]) #这样写，无论前后，只遍历第一行 print(a[0][:]) print(a[:][1]) print(a[1][:]) ############################ print(a[:,0]) #这样写才是遍历第一列，前后有区别 print(a[0,:]) print(a[:,1]) print(a[1,:]) print(a[:,2]) ############################ print(a[0:3][0]) #[:]范围明明是3个，拆开写就不对，要符合实际情况 print(a[0][0]) print(a[1][0]) #总结遍历是最好不要写成[][]的形式,合成写与拆开写不一致2、 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e8020daf19654241a58fee9b6c8e46/" rel="bookmark">
			2018最新版本的spark面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark是一个围绕速度、易用性和复杂分析构建的大数据处理框架，Spark提供了一个全面、统一的框架用于管理各种有着不同性质(文本数据、图表数据等)的数据集和数据源(批量数据或实时的流数据)的大数据处理的需求。成为大数据核心技术之一，自然也成为了众多企业面试的核心专业问题，小编针对spark整理了一套相关的面试题，正在学习大数据和正在面试大数据岗位的小伙伴可以参考使用了!
1、SDD,DAG,Stage怎么理解?
2、宽依赖 窄依赖怎么理解?
3、Stage是基于什么原理分割task的?
4、血统的概念
5、任务的概念
6、容错方法
7、粗粒度和细粒度
8、Spark优越性
9、Spark为什么快
10、Transformation和action是什么?区别?举几个常用方法
11、SDD怎么理解
12、spark 作业提交流程是怎么样的，client和 cluster 有什么区别，各有什么作用
13、spark on yarn 作业执行流程，yarn-client 和 yarn cluster 有什么区别
14、spark streamning 工作流程是怎么样的，和 storm 比有什么区别
15、spark sql 你使用过没有，在哪个项目里面使用的
16、spark 机器学习和 spark 图计算接触过没，，能举例说明你用它做过什么吗?
17、spark sdd 是怎么容错的，基本原理是什么?
以上就是小编整理的大数据技术之spark的面试参考题(相信对于学过大数据技术的同学应该不是难题吧，当然了有需要解析的也可以给小编留言滴)，也是讲师在讲课过程中反复给大家强调的重点，学习大数据并不是一朝一夕的事情，而是要付出很多的时间和精力。不是一套大数据面试题就能搞定你面试官的，技术岗位就需要一定的真材实料才能胜任，尤其是对于大数据技术人才的要求更是如此。
想想一个企业花重金聘请的大数据技术人才，如果技术不扎实或者没有一定的项目经验基础，怎么可能将这样的核心岗位交给你呢?!透过面试题，看自己的实力是否能够撑起大数据工程师的岗位!也让自己明白学习大数据的重点应该放在哪些方面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24df83507705a566675528065a62aff/" rel="bookmark">
			2018最新版spark面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark是一个围绕速度、易用性和复杂分析构建的大数据处理框架，Spark提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。成为大数据核心技术之一，自然也成为了众多企业面试的核心专业问题，小编针对spark整理了一套相关的面试题，正在学习大数据和正在面试大数据岗位的小伙伴可以参考使用了！
1、SDD,DAG,Stage怎么理解？
2、宽依赖 窄依赖怎么理解？
3、Stage是基于什么原理分割task的？
4、血统的概念
5、任务的概念
6、容错方法
7、粗粒度和细粒度
8、Spark优越性
9、Spark为什么快
10、Transformation和action是什么？区别？举几个常用方法
11、SDD怎么理解
12、spark 作业提交流程是怎么样的，client和 cluster 有什么区别，各有什么作用
13、spark on yarn 作业执行流程，yarn-client 和 yarn cluster 有什么区别
14、spark streamning 工作流程是怎么样的，和 storm 比有什么区别
15、spark sql 你使用过没有，在哪个项目里面使用的
16、spark 机器学习和 spark 图计算接触过没，，能举例说明你用它做过什么吗？
17、spark sdd 是怎么容错的，基本原理是什么？
以上就是千锋就业讲师整理的大数据技术之spark的面试参考题（相信对于学过大数据技术的同学应该不是难题吧，当然了有需要解析的也可以给小编留言滴），也是讲师在讲课过程中反复给大家强调的重点，学习大数据并不是一朝一夕的事情，而是要付出很多的时间和精力。不是一套大数据面试题就能搞定你面试官的，技术岗位就需要一定的真材实料才能胜任，尤其是对于大数据技术人才的要求更是如此。
想想一个企业花重金聘请的大数据技术人才，如果技术不扎实或者没有一定的项目经验基础，怎么可能将这样的核心岗位交给你呢？！透过面试题，看自己的实力是否能够撑起大数据工程师的岗位！也让自己明白学习大数据的重点应该放在哪些方面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa4f4ddc013e39d178cba277b7d72f2/" rel="bookmark">
			#1079 : 离散化&#43;线段树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间限制: 10000ms 单点时限: 1000ms 内存限制: 256MB 描述 小Hi和小Ho在回国之后，重新过起了朝7晚5的学生生活，当然了，他们还是在一直学习着各种算法~
这天小Hi和小Ho所在的学校举办社团文化节，各大社团都在宣传栏上贴起了海报，但是贴来贴去，有些海报就会被其他社团的海报所遮挡住。看到这个场景，小Hi便产生了这样的一个疑问——最后到底能有几张海报还能被看见呢？
于是小Ho肩负起了解决这个问题的责任：因为宣传栏和海报的高度都是一样的，所以宣传栏可以被视作长度为L的一段区间，且有N张海报按照顺序依次贴在了宣传栏上，其中第i张海报贴住的范围可以用一段区间[a_i, b_i]表示，其中a_i, b_i均为属于[0, L]的整数，而一张海报能被看到当且仅当存在长度大于0的一部分没有被后来贴的海报所遮挡住。那么问题就来了：究竟有几张海报能被看到呢？
提示一：正确的认识信息量
提示二：小Hi大讲堂之线段树的节点意义
输入 每个测试点（输入文件）有且仅有一组测试数据。
每组测试数据的第1行为两个整数N和L，分别表示总共贴上的海报数量和宣传栏的宽度。
每组测试数据的第2-N+1行，按照贴上去的先后顺序，每行描述一张海报，其中第i+1行为两个整数a_i, b_i，表示第i张海报所贴的区间为[a_i, b_i]。
对于100%的数据，满足N&lt;=10^5，L&lt;=10^9，0&lt;=a_i&lt;b_i&lt;=L。
输出 对于每组测试数据，输出一个整数Ans，表示总共有多少张海报能被看到。
样例输入 5 10 4 10 0 2 1 6 5 9 3 4样例输出 5 离散化+线段树。线段树的经典应用题（染色）。离散化的处理也是关键。
重点是建树是要注意叶子节点是（l,l+1）而不是（l,l）
模板是用的是上篇
#include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; #include &lt;set&gt; #include &lt;math.h&gt; using namespace std; #define pow2(x) (1&lt;&lt;x) #define lg2(x) (log(x*1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fa4f4ddc013e39d178cba277b7d72f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f80b86d31b6b8fb2b12ae643d8b8f1c9/" rel="bookmark">
			Redis（9.2）—— 哨兵的安装和部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节介绍了Redis Sentinel的基本架构，本节将介绍如何安装和部署Redis Sentinel。
9.2.1 部署拓扑结构 下面将以3个Sentinel节点、1个主节点、2个从节点组成一个Redis Sentinel进行说明，拓扑结构如图9-13所示。 具体的物理部署如表9-2所示。 9.2.2 部署Redis数据节点 9.1节提到过，Redis Sentinel中Redis数据节点没有做任何特殊配置，按照之前章节介绍的方法启动就可以，下面以一个比较简单的配置进行说明。 1.启动主节点 配置： redis-6379.conf port 6379 daemonize yes logfile "6379.log" dbfilename "dump-6379.rdb" dir "/opt/soft/redis/data/" 启动主节点： redis-server redis-6379.conf 确认是否启动。一般来说只需要ping命令检测一下就可以，确认Redis数据节点是否已经启动。 $ redis-cli -h 127.0.0.1 -p 6379 ping PONG 此时拓扑结构如图9-14所示。 图9-14 启动主节点
2.启动两个从节点 配置： 两个从节点的配置是完全一样的，下面以一个从节点为例子进行说明，和主节点的配置不一样的是添加了slaveof配置。 redis-6380.conf port 6380 daemonize yes logfile "6380.log" dbfilename "dump-6380.rdb" dir "/opt/soft/redis/data/" slaveof 127.0.0.1 6379 启动两个从节点： redis-server redis-6380.conf redis-server redis-6381.conf 验证： $ redis-cli -h 127.0.0.1 -p 6380 ping PONG $ redis-cli -h 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f80b86d31b6b8fb2b12ae643d8b8f1c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823fee621a4ffaaa135e000301647023/" rel="bookmark">
			多haar车辆检测&#43;KCF跟踪（企业级项目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多haar车辆检测+KCF跟踪（企业级项目）的原理：
1，采用haar特征检测车辆
2，采用KCF跟踪检测到的车辆，压入容器里面
3，过线判断
4，清除超出图像范围的跟踪器
效果测试见多HAAR+KCF企业级车流量统计
有一起研究的大神，可以加Q 2830025146，效果图如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420bb92cac5c51fb04377f8f455086a5/" rel="bookmark">
			java中输出格式控制详解（System.out.printf用法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		除了System.out.print(ln),java中还有一种输出命令，而且比以上两种更为复杂、强大，那就是System.out.printf
样例：
输出结果：
倘若不用System.out.printf ，而是用System.out.print(ln）格式就出现了明显错误，如下：
好了，开始System.out.printf 详细学习吧
基本格式：格式控制符以一个%开始，一个字母结束，字母规定了方法按照何种方式打印这个值，例如d表示十进制整数（int）,f表示浮点数（double）.
例如：int x=12,y=10;
System.out.printf("(%d,%d)",x,y);
输出结果：
%d代替后面的参数，格式字符串中的格式控制字符的个数必须与后面提供的参数个数相匹配。
常用格式控制符
string同理，只是将d换成s.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14977aa109c691d71f4e84d8718f6f4b/" rel="bookmark">
			搭建 Github Pages 个人博客网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章出自个人博客https://knightyun.github.io/2018/04/01/github-pages-blog#1.1. 转载请申明
目录 引言 关于博客关于Github创建Github账号创建仓库 填充仓库配置Github Pages功能博客的书写与上传 Git基础git配置git Desktop版创建本地仓库安装Jekyll 关于Jekyll安装步骤开启jekyll写博客与上传 Markdown基础工具介绍图床介绍关于图片尺寸域名配置 引言 关于博客 写博客对于程序猿来说，应该是个优秀的习惯，个人也觉得蛮高大上的 ^_^。网上的博客论坛网站也多种多样，个人觉得在长久以来的不断竞争淘汰中，各大网站的功能等可能都相差无几了，选择自己稍微偏好的就可以了。
我的个人情况就是结合CSDN博客和Github Pages的独立个人博客网页，因为听说拥有自己的Github主页也是一件蛮高大上的事 -_- 。
关于Github 然后简单介绍一下Github以及其Github Pages功能。
GitHub是一个面向开源及私有软件项目的托管平台，也是一个分布式版本控制系统，详情见百度百科。说到分布式，自然也有另外一种集中式版本控制系统：SVN，有兴趣小伙伴可以了解百度百科。GIt是SVN的发展版，而且现在主流也是GIt，但某些大公司依然在使用SVN，二者各有优劣，自行体会，此处不做详解，用一张图简单说明：
GIthub Pages则是github上的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，但现在大多用来开发制作个人博客网站。接下来就一步步按照我曾经的步骤来搭建个人博客，顺便讲讲沿途遇到过的坑，如没有的提及请自行百度。
创建Github账号 github pages 功能依赖于github账号，没有的话先去官网注册一个： 然后好像要邮箱验证，就是填写的那个，点击那个验证链接就注册成功了。
创建仓库 有了自己的账号后，可以跟着官网的引导，创建自己的第一个仓库，就是 repository： 填好信息 创建完成 到这里就创建好了自己的仓库，可以上传文件到这个目录下，接下我们用这个仓库来使用github pages功能。 填充仓库 仓库建好了，接下来就是往里面装东西了，就是支撑博客首页的一些网页文件和配置文件，对于新手来说要自己编写这些文件就有点开玩笑了，所以可以选择使用已有的主题，你可以选择复制我的https://github.com/knightyun/knightyun.github.io，然后选择自己仓库，网页基础好的同学以后修改网页内容就行了。
嫌修改麻烦可以跳过这一步，到后面的步骤选择喜欢的主题 配置Github Pages功能 然后我们来配置github pages
重命名，注意格式 把上面的页面向下滑，现在就可以访问了 当然github也提供了一些主题供选择，点击上面的“choose a theme”按钮进行选择 这个网站有更多主题工选择：http://jekyllthemes.org/，如有选择困难症请绕路 -_-
博客的书写与上传 Git基础 前面说到向自己的github仓库上传文件，我们使用“git”这个工具，进行拉取、克隆、提交等一系列操作，Linux系统应该是自带，官网下载地址：https://git-scm.com/。 并且需要掌握一些git基本操作，如 git commit , git push, git clone 等，这里有很完整的教程：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000.
git配置 安装好后cmd输入 git 有反应则安装成功： 进行如下配置：
git config --global user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14977aa109c691d71f4e84d8718f6f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad688b45a96e3be0b33247594a32cf8/" rel="bookmark">
			编程小练~一元二次方程求解问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何考虑一元二次方程求解问题：
求解思想：
首先考虑a是否为0，若为0，则直接判断该方程不为一元二次方程。若不为0，则判断b*b-4ac和0的关系，若为0，判断该方程只有一个解并直接输出解为-b/2a若大于0，判断该方程有两个解并输出解为（-b+sqrt(b*b-4ac)/2a,(-b-sqrt(b*b-4ac))/2a若小于0，判断该方程无解。 注意：浮点型和零之间的比较
由于浮点数在内存中的存储方式，使得有些浮点数在内存中无法精确的存储，这样就会造成精度的缺失，就有可能导致计算的不准确性，因此不能够使用==去直接判断两个浮点数。这样就必须自己定义一个精度，保证误差在精度的范围内就可以了 .
程序如下：
#define EXP 0.00000000001//设置一个能接受的精度，保证误差在精度范围内就可以了 #include&lt;math.h&gt; #include&lt;stdio.h&gt; int main() { double a=0.0,b=0.0,c=0.0; scanf("%lf%lf%lf",&amp;a,&amp;b,&amp;c); //意味着a是无限接近于0的数字，约等于0 if(a&gt;-EXP&amp;&amp;a&lt;EXP) printf("\n该方程不是一元二次方程\n"); else { double disc=b*b-4*a*c; printf("\n该方程是一元二次方程"); if(disc&gt;-EXP&amp;&amp;disc&lt;EXP) { printf("且只有一个唯一解为：%lf\n",(-b)/2*a); } else if(disc&gt;=EXP) printf("且两个解分别为：%lf %lf\n",(-b+sqrt(disc)/2*a),(-b-sqrt(disc)/2*a)); else printf("但无解\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf2d3252085ac825d5833706bd92224/" rel="bookmark">
			NOMA简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NOMA即非正交多址接入技术，是非常有希望的5G技术。其优点是可以提高频谱效率（rate/bandwigth）和接入量，这恰好符合了即将到来的5G时代的爆炸性的数据增长和接入需求，因此吸引了众多研究者的注意。
NOMA的核心理念是在发送端使用叠加编码（superposition coding），而在接收端使用SIC（successive interference cancelation),借此，在相同的时频资源块上，通过不同的功率级级在功率域实现多址接入。这个是主流的NOMA方案。关于码域的NOMA方案包括LDS-CDMA(low-density spreading CDMA)，Low-density spreading OFDM，SCMA(sparse codemultiple access)，PDMA(pattern-divisionmultiple access),BDM(bit-division multiplexing),IDMA(interleave-divisionmultiple access)不再介绍。
功率域NOMA的实现方法：
考虑单小区下行场景，一个基站，N个用户Ui，i=1,2,3…………N,所有的终端都配备单天线。（注意，相似的上行场景是类似的。）基站以功率P向所有用户发消息。假设信道为独立同分布的瑞利衰落与AWGN。信道以瑞利衰落的功率大小排序。对于信道状况不好的用户，发送信息时分配较大的功率，而信道状况较好的用户则反之。在发送端，基站通过相同的时频资源与所有用户通信，即通过SC技术。在接收端，通过SIC进行接收，首先，先将所有信号中功率较大的作为有用信号，将其他信号作为干扰，进行解调，然后将解调出的有用信号减去，依次类推，直到解调出该用户的信息。
对于两用户场景：
叠加后的信号
接收端接收到的信号：
解调后分别达到的速率：
同种条件下的OMA:
NOMA的优点：
1. 相比于OMA，有更高的频谱效率。
2. 可以实现大量的接入
3. 低延时与低信令花费
4. 较强的鲁棒性，抵抗衰落与小区间干扰
5. 高的边缘吞吐率
6. 宽松的信道反馈，只需要接收信号的强度，不需要具体的CSI。
7. 相比于OMA在准同步传输中的灵活性。
现阶段做过的研究：
1. Cooperative NOMA（C-NOMA）：
Cooperative communication：分配中继节点以协助信源将信息转发到不同的目的地。与NOMA结合后可以进一步提高容量和可靠性。在这一方案中，信道条件好的用户为其他用户译码信息，因此，这些用户担任基站的中继的角色，提高了链接差的用户的可靠性。信道条件好的用户可以使用短程通信技术。
C-NOMA包含两个阶段：传输阶段与合作阶段。
缺点：这一技术因为额外的时隙分配而比较昂贵。但是使用user pairing可以相应减少复杂度。
仿真结果：C-NOMA相比于non-cooperaticveNOMA在相同的信噪比下有更小的中断概率。这是因为它能实现更高的分集增益。
2. NOMA with MIMO and Beamforming
MIMO中的Multi-user BF是一种容量提升技术。在Multi-user BF系统中，每一个用户都被分配了一个BF矢量，彼此正交。而NOMA-BF允许两个用户分享同一个BF矢量。NOMA-BF提高了和容量，同时保证了弱用户的容量以保证用户公平。
无论发送端拥有完全的CSI，还是统计的CSI，都可以证明MIMO NOMA优于传统的MIMO OMA。
仿真结果表明：MIMONOMA与MIMO OMA有相同的分集增益，但是MIMONOMA有更高的频谱效率
3. NOMA in a Coordnated System
小区边缘的用户相较于基站附近的用户一般有较低的数据速率。Coordinated multipoint(CoMP)传输技术是多个基站支持边缘用户，可以用以增加边缘用户的传输许率。但是随着用户的增加，系统的频谱效率会降低。将该技术与NOMA结合后，基站可以同时传送时空码信号给边缘用户与接近基站的用户。这样就可以增加频谱效率且不减少附近用户的速率。
仿真结果证明：CSC-based 系统的和速率随着SNR指数增长，要比non-CSC-based 系统高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf2d3252085ac825d5833706bd92224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3822845ba9fd39b9a892f0b293eb49a/" rel="bookmark">
			使用MATLABD数值法计算定积分或反常积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		trapz是用梯形法求积分，要求输入一个数列，或两个一样长的数列，而最后输出积分值。
cumtrapz输入与trapz一样，但是最后输出的是与输入等长的数列，其最后一个值为积分值，如果计算二重积分，而输入一个矩阵，那么cumtrapz是按照列进行计算的，最后输出矩阵的最后一行为内积分的值。此外，cumtrapz默认的积分步长为1，若要修改，只需在使用这个函数时乘以积分步长即可
例
dg=0.01;
x=1:0.01:2;
fun=1./x;
func=dg*cumtrapz(fun);
result=func(end);
而计算积分限为无穷时，可以将积分区间进行划分，然后将每个积分区间的计算结果相加，当某个积分区间的结果小于某个值时，停止计算。
例：
D=1；
T=1;
I=0；
a=0;
dg=0.01;
pre=10^(-5);
while T&gt;pre
b=a+D;
x=a:0.01:(b-0.01);
fun=exp(-x);
func=dg*cumtrapz(fun);
T=func(end);
I=I+T;
a=b;
D=2*D;
end
result=I
注意：其中dg与pre决定了运算的速度，与所使用的设备有关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/236af1ad8ec011b49e8fd04f830109a5/" rel="bookmark">
			使用泊松点过程建模基站或用户的MATLAB程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 lambda1：用户或基站的密度
radius：用户或基站分布的平面半径
APmXary：用户或基站的横坐标
APmYary：用户或基站的纵坐标
APmnum=poissrnd(lambda1*pi*radius^2);
APmlen=radius.*sqrt(rand(1,APmnum)); APmang=2*pi*rand(1,APmnum); APmXary=APmlen.*cos(APmang); APmYary=APmlen.*sin(APmang); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58fcfb5baa88a51362561b25ae662f10/" rel="bookmark">
			阿里云ECS ubuntu16.04安装桌面图形界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头次租阿里的ubuntu16.04服务器,想搞个图形界面玩玩,各种教程试了几个小时无果.
不过收到一个文章启发,apt list到一个包ubuntu-desktop
感觉是找到了关键,遂apt install ubuntu-desktop,安装完成,reboot,成功进入桌面,
==================================================
如若碰到不成功者,就尝试安装一下lightdm这个包,
开始由redhat经验以为开启图形是startx,后查到ubuntu是lightdm来控制,所以安装了lightdm的包
安装后有个点状背景的登录框,
但是只有guest session界面,和login选项,
故搜百度,通过禁用guest session
vi /usr/share/lightdm/lightdm.conf.d/50-unity-greeter.conf
(评论中YoungHappyGIS说是这个路径/usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf 未解决的朋友可以尝试一下)
在其中添加allow-guest=false
故如果碰到上述两个报错,可尝试添加后面两个方法进行尝试
由于服务器最终是不需要图形界面的,只是一个玩具,终归是要卸载掉,故没有对后续两个方法进行验证.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdfc268eb3e3405efb032499edc1875/" rel="bookmark">
			C标准库与嵌入式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stddef.h，其中包括size_t，sizeof函数返回值，不同平台的大小不一致
Size and pointer difference types[edit] The C language specification includes the typedefs size_t and ptrdiff_t to represent memory-related quantities. Their size is defined according to the target processor's arithmetic capabilities, not the memory capabilities, such as available address space. Both of these types are defined in the &lt;stddef.h&gt; header (cstddef header in C++).
size_t is an unsigned integer type used to represent the size of any object (including arrays) in the particular implementation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bdfc268eb3e3405efb032499edc1875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7371d2e822a1c25c9f539adf5fad3ec/" rel="bookmark">
			mysql中，如何查看数据库元数据(metadata)的字符集？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述：
mysql中，数据库的元数据也是有字符集的。
操作过程：
1.查看mysql数据库元数据的字符集
mysql&gt; show variables like 'character_set_system'; +----------------------+-------+ | Variable_name | Value | +----------------------+-------+ | character_set_system | utf8 | +----------------------+-------+ 1 row in set (0.00 sec) 备注：通过查看系统变量character_set_system来查看元数据的字符集。这些元数据的字符集，比如说，version(),database()函数返回的结果是什么字符集的。
文档创建时间：2018年3月28日18:11:00
转载于:https://www.cnblogs.com/chuanzhang053/p/8665444.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d03d5c9c0de1da779bdeb30189d7e7/" rel="bookmark">
			Java开发 — 将JavaWeb项目部署到Tomcat之后报错org.springframework.beans.factory.CannotLoadBean：Error loading class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近将自己的JavaWeb项目部署在阿里云服务器之后，发现访问404，然后跑去找老师研究了好一阵才找出具体原因，首先展示一下报错内容：
ERROR [localhost-startStop-1] - Context initialization failed
org.springframework.beans.factory.CannotLoadBeanClassException: Error loading class [com.service.impl.CategoryServiceImpl] for bean with name ‘categoryServiceImpl’ defined in file [C:\ProgramData\Devlop\Tomcat-Package\apache-tomcat-8.5.27\webapps\tmall_ssm\WEB-INF\classes\com\service\impl\CategoryServiceImpl.class]: problem with class file or dependent class; nested exception is java.lang.UnsupportedClassVersionError: com/service/impl/CategoryServiceImpl : Unsupported major.minor version 52.0 (unable to load class [com.service.impl.CategoryServiceImpl])
简单说一下，造成这个错的原因是jdk版本问题，如果你项目在编译时的jdk版本高过你在配置环境变量时的jdk版本，那么就极大可能出现以上错误，所以，解决方法也很简单：
1、重新配置环境变量中的jdk版本，使其与编译项目中的jdk版本相同或大过编译项目的版本。
2、更改编译项目的jdk版本，即在开发工具中更换jdk版本，如Eclipse、MyEclipse、IDEA等。具体更换方法我就贴一个IDEA的吧，其它的大家可自行百度。
还有，如果你是部署在Linux服务器上的，那么tomcat极有可能不会报错，所以你需要先进入tomcat的bin目录下，然后输入以下指令去查看错误信息：
./catalina.sh run 访问tomcat错误日志 IDEA更换jdk版本：
1、可以设置默认jdk版本：菜单栏找到File =&gt; Other Settings =&gt; Default Project Structure
在Project设置中选择你需要的jdk版本然后点下方的Apply按钮应用：
再点击SDKs，选择你需要的jdk版本，之后应用再OK：
2、修改Project Structure中的jdk版本，菜单栏选择
File =》 Project Structure
然后如下图所示，更改下图右侧圈中的页面中的jdk版本（自己所需）：
3、修改代码中的jdk版本，如果大家是做的Maven项目，那么pom.xml配置中应该会有如下配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d03d5c9c0de1da779bdeb30189d7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55796b56f3cd591fc27c65ef80f98f0c/" rel="bookmark">
			浏览器特性与安全策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同源策略 同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对象的资源。
同源和异源 不同域
协议不同(HTTP与HTTPS)域名不同(顶级域，www域和子域)端口不同(比如80端口和81端口) 同域
多了目录，符号协议，域名，端口都相同 网页授权 通过HTTP响应头返回字段设置的，设置字段如下：Access-Controll-Allow-Origin: http://www.demo.com
沙盒框架(Sandboxed frame) 是对常规&lt;iframe&gt;表现行为的扩展，它能让顶级页面对其嵌入的子页面及这些子页面的子资源设置一些额外的限制
通过&lt;iframe&gt;的参数实现限制
Allow-scripts ：是否允许执行javascript脚本，没有则不允许Allow-forms ： 是否允许使用form表单，没有则不允许Allow-top-navigation : 是否允许嵌入子页面控制顶级窗口的地址跳转，没有则不允许Allow-same-origin : 是否允许访问同源数据，没有则不允许 Flash安全沙箱 分为本地沙箱与远程沙箱类似同源策略，在同一域内的资源会被放到一个安全组下，称为安全沙箱Web站点通过crossdomain.xml文件配置可以提供允许的跨域访问本域上内容的权限(放置于站点根目录)
&lt;cross-domain-policy&gt; &lt;allow-access-form domain=".youku.com" /&gt; &lt;/cross-domain-policy&gt; Cookie的安全策略 Domain 用于指定Cookie的有效域Path 用于指定Cookie的有效URL路径Secure 如果设置该属性，仅在HTTPS请求中提交CookieHttp 其实是HttpOnly, 如果设置该属性，客户端javascript无法获取Cookie的值 内容安全策略 (Content Security Polity, CSP) 通过编码在HTTP响应头中的指令来实施策略
Content-Security-Polity:script-src 'self' https://baidu.comCSP的一些指令
default-src : 该指令在某种资源类型指定指令没有被定义的情况下制定了所有资源类型的加载策略(即默认的资源加载策略)script-src : 该指令指定了Web应用程序可以加载的脚本的域或URLobject-src : 该指令制定了Web应用程序可以加载的插件，如Falshstyle-src : 该指令制定了Web应用程序可以加载的CSS样式表的域或URLimg-src : 该指令指定了Web应用程序可以加载的图片的域或URLmedia-src : 该指令指定了Web应用程序可以加载的音视频的域或URL
frame-src : 该指令指定了Web应用程序可以加载的框架的域或URL
font-src : 该指令指定了Web应用程序可以加载的字体的域或URL
connect-src : 该指令指定了Web应用程序可以加载的像XHR, WebSockets, 以及EventSource等脚本接口的域或URL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55796b56f3cd591fc27c65ef80f98f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d14ee059d643557dad7eb83a93f352/" rel="bookmark">
			MATLAB在信号与系统中的应用（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.阶跃函数的绘制几种图像的区别 t=0:0.01:3; ft1=t.*(t&gt;=0 &amp; t&lt;=1); ft2=t.*(t&gt;=0); ft3=t.*(t&gt;=0 &amp; t&lt;=1)+(t&gt;=1); ft4=(t-1).*(t&gt;=1); ft5=-(t-1).*(t&gt;=0 &amp; t&lt;=1); ft6=t.*(t&gt;=2 &amp; t&lt;=3); ft7=(t-2).*(t&gt;=2 &amp; t&lt;=3); &gt;&gt; subplot(241),plot(t,ft1),title('t[u(t)-u(t-1)]'); &gt;&gt; subplot(242),plot(t,ft2),title('tu(t-1)'); &gt;&gt; ft3=t.*(t&gt;=0 &amp; t&lt;=1)+(t&gt;1); &gt;&gt; subplot(243),plot(t,ft3),title('t[u(t)-u(t-1)]+u(t-1)'); &gt;&gt; axis([0 6 0 2]); &gt;&gt; subplot(244),plot(t,ft4),title('(t-1)u(t)'); &gt;&gt; axis([0 6 -1 2]); &gt;&gt; subplot(245),plot(t,ft5),title('-(t-1)[u(t)-u(t-1)]'); &gt;&gt; subplot(246),plot(t,ft6),title('t[u(t-2)-u(t-3)]'); &gt;&gt; subplot(247),plot(t,ft7),title('(t-2)[u(t-2)-u(t-3)]'); 实验图： 实验
2.使用MATLAB实现卷积 符号法求解卷积 syms tao; &gt;&gt; t=sym('t','positive'); &gt;&gt; xt1=sym('heaviside(t)-heaviside(t-1)'); &gt;&gt; xt_tao=subs(xt1,t,tao)*subs(xt1,t,t-tao); &gt;&gt; yt=int(xt_tao,tao,0,t); &gt;&gt; yt=simplify(yt); &gt;&gt; ezplot(yt,[0,2]);grid on f(t)=u(t)-u(t-1),求s(t)=f(t)*f(t)： 数值法求解卷积 t=0:dt:3; f=(t&gt;=1)-(t&gt;=2); f1=conv(f,f)*dt; n=length(f1); tt=(0:n-1)*dt+2; subplot(121),plot(t,f),grid on title('f(t)=u(t-1)-u(t-2)') subplot(122),plot(tt,f1),grid on title('s(t)=f(t)*f(t)') dt=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d14ee059d643557dad7eb83a93f352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d26bc89eedecc4014cb33f2e94b8e33/" rel="bookmark">
			Mac实用软件及功能吐血总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人一年半来跟踪Mac志（http://www.isofts.org/category/software-for-mac-os-x/ ）、MacGG( http ://www.macgg.com/archives/category/mac软件)，潜心测试，用心总结出以下mac实用软件列表，尤其适合程序员…… 软件介绍多摘自以上两个网站，在此表示感谢。 以下条目按照如下格式编排： 软件名称 分类 简介 需要说明的是 并不是一个条目对应一个软件，一个软件安装后是可能对应多个部件的。 首先介绍所有分类（搜索类别名快速定位）： Image Processing - 图像处理，比如水印、全景拼接、滤镜等 Image Design - 图像设计、海报设计、相册幻灯片 Video - 视频编辑、格式转换 Audio - 音频编辑、格式转换 Adobe CS6 - Adobe CS6系列 Adobe CC - Adobe CC系列 Statistics - 统计类软件及作图工具 Apple Development - 苹果开发工具 IDE - eclipse等较大的开发环境 Development Assist - 开发辅助，比如API浏览、Git、SVN、文件比较、JSON与XML生成器等 Web Assist - 网页开发辅助，比如站点性能测试、原型设计、取色器等 Server &amp; Remote - FTP、Apache、Mysql、远程桌面等 Documents - iWork、Office、iBooks、教程制作，CAJ、DJVU、CHM等各类文档阅读编辑器 Latex - MacTex Internet - 浏览器及网络性能测试工具 Social - 社交网络软件 Entertainment - 影音及流媒体播放工具 Resources - 笔记、词典等 Efficiency - 效率办公类，GTD、项目管理等 Document Assist - 文档编辑器的模板、PDF与PPT体积压缩等 Storage - 网盘 System 系统自带软件 Optimization - 系统优化软件 Mostly Used - 本人常用软件，强烈推荐 Userful Tools - 系统自带的小工具 Other Tools - 其它个人常用软件 Games - 游戏，不用看了，只有纸牌 Mobile - 移动客户端配套软件，比如清理垃圾、安装app、屏幕投射等 Others - 安装其它软件附带产生的，都是些没用的东西 Web IDE - 网络编程IDE Flow Chart - 流程图、思维导图、UML工具等 Record - 摄像头相关软件、屏幕截图及录制 Development Light - 轻量级程序开发软件 以下为软件详细介绍。XML格式的文件在 此处，简单的txt文件在 此处，SQL文件在 此处。 =线为类别分界线 =============================================================== Photo Effect Studio Pro Image Processing Photo Effect Studio 是一个强大的照片效果的集合，它是由图像编辑的专业摄影师和图形设计师精心开发的应用程序，它简化了任务，并提供一些当今最激动人心的过滤器。 iCollage Pro Image Processing iCollage Pro 以把多张照片巧妙的安排在一起，轻松创作拼贴照片。选择好想要拼贴画的图片之后再选择编辑包括横向或纵向方向的大小、 拼贴画背景颜色、 旋转、 缩放等选项。 BatchInpaint Image Processing BatchInpaint 是一款简单实用的图片去水印软件，能够对指定的图片进行水印去除。当然你也可以去除不需要的任何一个图片区域，包括文字，人物，线条等等。 PicSketch Image Processing PicSketch 是Mac平台的一款能够将普通图片转换成素描图片的图像处理工具，通过使用这款图像处理软件，我们可以将一张普通的照片转换成一张非常有艺术感的素描画。 Photo Samurai Image Processing Photo Samurai 是一款Mac平台的切片式图片效果处理工具，可以把任意一张图片进行切片是效果处理，让照片看起来更加有趣，将一张图片切成几片、切片之间的位置调整、可以输出为多种格式的图片。 Wordify Image Processing Wordify 可以将普通的照片使用文字或者符号来代替，变成一张有文字或符合组成的照片。 官方网站：http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d26bc89eedecc4014cb33f2e94b8e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898b42ebe42e633949916687c575e9dd/" rel="bookmark">
			2018.3.25编程遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、全局变量最好不要在头文件定义，容易引起重复定义的问题； 2、文件的读写：fread、getline、ifstream和ofstream的用法； 3、ifstream cin(str); 变量str不能为CString、string。 涉及CString、string、char[]等的转换； CString cstr = "ABCDF"; string str = CStringA(cstr); str.c_str(); 4、关于浮点数， 例如2.99999，小数点后5个9，输出为2.99999； 例如2.999999，小数点后6个9，输出则变为3。 5、关于多个文件中需要用到的公共变量 建议新建公共头文件common.h，并在需要用到的cpp中引用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5094cd0ed82822b2ba1008d0d5c5378/" rel="bookmark">
			IEEE754和规格化数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机组成原理这一章中讲到了浮点数，其中有浮点数的IEEE754标准和浮点数规格化的内容。有些概念比较模糊不清，我讲一讲我自己认为的它们之间的区别。 1.IEEE754标准是浮点数在计算机中存储的一种标准，而浮点数规格化主要用于浮点数的计算和提升精度（IEEE754标准也有提升精度的作用）。 2.在IEEE754标准中只有一位数符和一位阶符，而浮点数规格化则可以根据题意有两位符号位。 3.IEEE754标准有一位隐藏位，即最高有效位隐藏。而浮点数规格化没有隐藏位，因为它主要用于计算，不能隐藏最高有效位。 4.有的时候会把IEEE754和浮点数规格化的概念混合起来，它们之间可以相互转化，要注意区分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef36949b66746fc7e3a10df0bd3d9553/" rel="bookmark">
			JS_03_类型_正则_异常_保留字_JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了去掉console.log()的因为无返回值导致输出的undefined,我们可以自定义一个函数
代码如下:
function NSLog(loli) {console.log(loli);return 'Copyright © 2018 Powered by beyond';}; 效果如下:
JavaScript 类型转换 Number() 转换为数字， String() 转换为字符串， Boolean() 转化为布尔值。
JavaScript 数据类型 ECMAScript中 7种原生构造器
1. Boolean
2. Number
3. String 4. Array
5. Function
6. Object
7. Symbol (新增)
在 JavaScript 中有 5 种不同的数据类型,
用typeof()可以返回下面5个字符串,
注意下面5个只是不同的字符串而已：
boolean (只有true和false两个值)number (NaN是number类型的一个值)
stringobject (null 使用typeof()检测,返回的也是object)function 2 个不包含任何值的数据类型：
null == undefined 为true,
但是null === undefined为false
null typeof(null) 为 objectundefined typeof(undefined)为undefined, 没有赋值的变量就是undefined 3 种对象类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef36949b66746fc7e3a10df0bd3d9553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e6b6eaa7753be52da4274142d9a44b/" rel="bookmark">
			MATLAB绘制图像以及基本运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Sa(t)函数的画法（代码与图如下）：
t =-4*pi:0.01:4*pi; ft=sin(t)./t; plot(t,ft); 2.信号的平移，尺度变换，反褶等
t=-2:0.01:1; y=1*(t&gt;=(-2) &amp; t&lt;=(0))+(-1*t+1).*(t&gt;(0) &amp; t&lt;=(1)); plot(t,y); axis([-2 1 -1 2]) t1=t+2; t2=t/3; t3=-t; t4=-(t+2)./3; subplot(321),plot(t,y),axis([-2 1 -1 2]),xlabel('f(t)'); subplot(322),plot(t1,y),axis([0 3 -1 2]),xlabel('f(t-2)'); subplot(323),plot(t2,y),axis([-1 1 -1 2]),xlabel('f(3t)'); subplot(324),plot(t3,y),axis([-1 2 -1 2]),xlabel('f(-t)'); subplot(325),plot(t4,y),axis([-1 1 -1 2]),xlabel('f(-3t-2)'); 3.信号运算之求导以及积分
syms x a; A=diff(x*sin(x)*log(x),'x',1); b=int(x.^5-a*x.^2+sqrt(x)./2,'x'); c=int(x*exp(x)./(1+x).^2,'x',0,1); 结果分别为： A=sin(x) + log(x)*sin(x) + x*cos(x)*log(x)
b=x^(3/2)/3 - (a*x^3)/3 + x^6/6
c=exp(1)/2 - 1 4.信号的卷积之符号运算法：
syms tao; t=sym('t','positive'); xt1=sym('heaviside(t)-heaviside(t-1)'); xt2=sym('heaviside(t)-heaviside(t-3)'); xt_tao=subs(xt1,t,tao)*subs(xt2,t,t-tao); yt=int(xt_tao,tao,0,t); yt=simplify(yt); ezplot(yt,[0,2]);grid on; 注意：此处是门函数的卷积 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e6b6eaa7753be52da4274142d9a44b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dffaf7b6324f56d355f3b1e7bff7283/" rel="bookmark">
			MATLAB在连续时间系统的时域分析中的应用（信号与系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.符号求解求解微分方程，信号的零输入与零状态： 实验代码如下： 2.符号求解求解微分方程，信号的零输入与零状态以及完全响应：
eq= 'D2y+3*Dy+2*y=0'; cond= 'y(0)=0,Dy(0)=2'; yzi=dsolve(eq,cond);yzi=simplify(yzi); eq1='D2y+3*Dy+2*y=Dx+3*x'; eq2='x=exp(-3*t)*heaviside(t)'; cond1='y(-0.001)=0,Dy(-0.001)=0'; yzs=dsolve(eq1,eq2,cond1);yzs=simplify(yzs.y); yt=simplify(yzi+yzs); subplot(221),ezplot(yzi,[0,8]),grid on,title('零输入响应'); subplot(222),ezplot(yzs,[0,8]),grid on,title('零状态响应'); subplot(223),ezplot(yt,[0,8]),grid on,title('完全响应'); 3.连续时间系统零状态响应的数值求解1：
ts=0;te=5;dt=0.01; sys=tf([6],[1,5,6]); t=ts:dt:te; &gt;&gt; f=10*sin(2*pi*t).*(t&gt;=0); &gt;&gt; y=lsim(sys,f,t); &gt;&gt; plot(t,y),grid on &gt;&gt; xlabel('Times(sec)'),ylabel('y(t)'),title('零状态响应') 绘制图像如下： 4.连续时间系统零状态响应的数值求解2：
ts=0;te=8;dt=0.01; &gt;&gt; sys=tf([1,3],[1,3,2]); &gt;&gt; t=ts:dt:te; &gt;&gt; f=exp(-3*t).*(t&gt;=0); &gt;&gt; y=lsim(sys,f,t); &gt;&gt; plot(t,y); &gt;&gt; grid on &gt;&gt; axis([0 8 -0.02 0.27]); &gt;&gt; xlabel('Times(sec)'),ylabel('y(t)'); &gt;&gt; title('零状态响应') 实验结果如下图： 5. 连续时间系统冲激响应与阶跃响应的求解：
t=0:0.01:4; sys=tf([1,16],[1,2,32]); h=impulse(sys,t);%冲激响应 g=step(sys,t);%阶跃响应 &gt;&gt; subplot(221),plot(t,h),grid on,xlabel('Time(sec)'),ylabel('h(t)'),title('冲激响应'); &gt;&gt; subplot(222),plot(t,g),grid on,xlabel('Time(sec)'),ylabel('g(t)'),title('阶跃响应'); 实验图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1196d43a1f5ffa5bb1bddf009ff526ff/" rel="bookmark">
			Mybatis的mapper xml文件中的常用标签。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis的mapper xml文件中的常用标签
一、SQL语句标签：
1、&lt;!--查询语句--&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.String" &gt;
select &lt;/select&gt; 2、&lt;!--插入语句--&gt; &lt;insert id="insert" parameterType="pojo.OrderTable" &gt; insert into ordertable (order_id, cid, address, create_date, orderitem_id) values (#{orderId,jdbcType=VARCHAR},#{cid,jdbcType=VARCHAR}, #{address,jdbcType=VARCHAR}, #{createDate,jdbcType=TIMESTAMP}, #{orderitemId,jdbcType=VARCHAR})
&lt;/insert&gt; 3、&lt;!--删除语句--&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.String" &gt;
delete from ordertable where order_id = #{orderId,jdbcType=VARCHAR} &lt;/delete&gt; 4、&lt;!--修改语句--&gt; &lt;update id="updateByPrimaryKey" parameterType="pojo.OrderTable" &gt; update ordertable set cid = #{cid,jdbcType=VARCHAR}, address = #{address,jdbcType=VARCHAR}, create_date = #{createDate,jdbcType=TIMESTAMP}, orderitem_id = #{orderitemId,jdbcType=VARCHAR} where order_id = #{orderId,jdbcType=VARCHAR} &lt;/update&gt; 1》需要配置的属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1196d43a1f5ffa5bb1bddf009ff526ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721624710439726f3b72ad7f4d30810a/" rel="bookmark">
			判断一个变量是数组还是对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript中如何准确判断一个变量是什么，面试中这是考一个人基本功扎不扎实必定会问的一个问题。如果你还不是很清楚，相信这篇文章会对你有所帮助。
一，判断方法 1.typeof 我们能够使用typeof判断变量的身份，判断字符串得到string，数字和NaN得到number，函数会得到function等，但是判断数组，对象和null时都会得到object，详细请看js数据类型，这就是typeof的局限性，并不能准确的判断该变量的"真实身份"。那如何判断一个变量是数组还是对象？
2.instanceof 使用instanceof可以用来判断一个变量是数组还是对象，原理如下： 数组也是对象的一种，使用instanceof都会返回true var arr = new Array(); var arr = ['aa','bb','cc']; var obj = { a: 'aa', b: 'bb', c: 'cc' }; console.log(arr instanceof Array); //true console.log(arr instanceof Object); //true console.log(obj instanceof Array); //false console.log(obj instanceof Object); //true 明确说一下instanceof是如何判断的：
instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，意思就是该变量通过原型链上能否找到构造函数的prototype 属性，还不清楚原型链的请看原型链
所以就能明白为什么instanceof判断一个变量可以分清楚它到底是数组还是对象：
Array.prototype === arr.__proto__ Object.prototype === arr.__proto__.__proto__ 因为arr的原型链上存在Array.prototype和Object.prototype
只有Array类型的变量才会满足arr instanceof Array和arr instanceof Object都返回true，
也只有Object类型变量才满足obj instanceof Array返回false，obj instanceof Object返回true 3.constructor var arr = ['aa','bb','cc']; var obj = { 'a': 'aa', 'b': 'bb', 'c': 'cc' }; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/721624710439726f3b72ad7f4d30810a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/253/">«</a>
	<span class="pagination__item pagination__item--current">254/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/255/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>