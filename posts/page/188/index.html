<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4536e689d6f4acb60b7f9240f43e0de/" rel="bookmark">
			oracle 连接报-3114,求助，ora-03114的产生原因及解决思路？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ora-03114这个问题产生的原因是什么呢？
我的库是11.2.0.1 64位 ，操作系统是server 2008 64位https://www.cndba.cn/tianxiadishi/article/3177
https://www.cndba.cn/tianxiadishi/article/3177https://www.cndba.cn/tianxiadishi/article/3177
现在应用程序界面偶尔会报ora-03114错误，但此时，使用sqlplus是可以连接到数据库的，
https://www.cndba.cn/tianxiadishi/article/3177https://www.cndba.cn/tianxiadishi/article/3177
oracle警告日志中没有出现3114错误，只有一个ORA-03137: TTC 协议内部错误，百度查可能和绑定变量或者jdbc驱动有关，
现在目前ora-03114我能想到的方法有以下几点
1.检查警告日志，没有ora-03114的错误记录；
2.网络，但是数据库和应用服务器在同一台服务器上，应该可以排除；
3.检查profile, 没有定义超时断开参数
4.sqlnet.ora中只有SQLNET.EXPIRE_TIME，这个参数，它用来清除client和服务器之间的僵死连接的。
5.会不会是程序本身有问题？
https://www.cndba.cn/tianxiadishi/article/3177
https://www.cndba.cn/tianxiadishi/article/3177
这个从哪几个方面查起呢？出现问题的时候，软件重新上线应用程序，听说能解决，但软件说是数据库或者网络的问题，https://www.cndba.cn/tianxiadishi/article/3177
版权声明：本文为博主原创文章，未经博主允许不得转载。
排错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9635ac8ba6eef47c86db195f6a0f338a/" rel="bookmark">
			memset()函数的用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近做题时突然想到用memset给数组的元素赋值100，但是发现结果和想象中的不一样
通过debug看到数组中的元素的值都为1684300900，而明明给它的是100，这是为什么呢，于是查阅了一下memset函数的用法和原理
memset()函数介绍 首先来看函数原型
void *memset(void *str, int c, size_t n) 解释：复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。作用：是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法头文件：C中#include&lt;string.h&gt;，C++中#include&lt;cstring&gt; 看着介绍其实函数作用非常简单，就是用于初始化，但是需要注意的是memset赋值的时候是按字节赋值，是将参数化成二进制之后填入一个字节。就比如前面的例子中，想要通过memset(a,100,sizeof a)给int类型的数组赋值，你给第一个字节的是一百，转成二进制就是0110 0100，而int有四个字节，也就是说，一个int被赋值为
0110 0100,0110 0100,0110 0100,0110 0100，对应的十进制是1684300900，根本不是你想要赋的值100，这也就解释了为什么数组中的元素的值都为1684300900。
memset赋值时只能赋值为0？ 答案肯定不是，比如任意字符都是可以的，初始化成0是最常用的。int类型的一般都是赋值0或-1，其他的值都不行。
结论
为地址str开始的n个字节赋值c，注意：是逐个字节赋值，str开始的n个字节中的每个字节都赋值为c。
（1） 若str指向char型地址，value可为任意字符值；
（2） 若str指向非char型，如int型地址，要想赋值正确，value的值只能是-1或0，因为-1和0转化成二进制后每一位都是一样的，设int型占4个字节，则-1=0XFFFFFFFF, 0=0X00000000。
举例：给数组赋值-1
int A[2]; memset(A, -1, sizeof A); memset初始化为无穷大 memset(a , 0x3f , sizeof a); 通过memset函数的介绍，上述初始化是将数组a的每个元素赋值为0x3f3f3f3f。0x3f3f3f3f 真的是个非常精巧的常量
他的十进制是 1061109567也就是109级别的，和0x7fffffff一个数量级，0x7fffffff是int类型的最大值，即231-1=2,147,483,647。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8d0c1fb9174e3ad49a9b33f71c91ba/" rel="bookmark">
			oracle数据库的还原步骤,oracle还原数据库步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建表空间
create tablespace data logging datafile 'e:/data/data.dbf' size 9000m autoextend on next 32m maxsize unlimited extent management local;
注:'e:/data/data.dbf' 本地的表空间可自定义路径
2.创建用户和密码
create user user_name identified by user_password default tablespace data temporary tablespace temp;
注:user_name :用户 user_password:密码
3.授权
① 按角色授权
grant connect,resource,dba to user_name;
注：
connect 角色：是授予最终用户的典型权利，最基本的权利，能够连接到ORACLE数据库中，并在对其他用户的表有访问权限时，做select、update、insert等操作
resource 角色，是授予开发人员的，能在自己的方案中创建表、序列、视图等。
dba角色，是授予系统管理员的，拥有该角色的用户就能成为系统管理员了，它拥有所有的系统权限。
②按功能授权
grant
create user,
drop user,
alter user ,
create any view ,
drop any view,
exp_full_database,
imp_full_database
to user_name;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e8d0c1fb9174e3ad49a9b33f71c91ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5c57ffa6ccc349b95c7dc878cc0169/" rel="bookmark">
			arcgis oracle srid,查询oracle srid 对应的EPSG代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用下面的oracle spatial函数可以查询srid 对应的EPSG代码
SDO_CS.MAP_ORACLE_SRID_TO_EPSG
Format
SDO_CS.MAP_ORACLE_SRID_TO_EPSG(
legacy_srid IN NUMBER) RETURN NUMBER;
Description
Returns the EPSG SRID value corresponding to the specified Oracle Spatial SRID value.
Parameters
legacy_srid
Oracle Spatial SRID value. Must match a value in the LEGACY_CODE column of the SDO_COORD_REF_SYS table (see Section
6.7.9).
Usage Notes
This function returns the SRID of an EPSG coordinate reference system. The EPSG SRID value for a coordinate reference system is indicated in the COORD_REF_SYS_CODE field in the EPSG Coordinate Reference System table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d5c57ffa6ccc349b95c7dc878cc0169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e83e0c2124cbf36f8e047b0346a0161/" rel="bookmark">
			linux系统php源码包安装教程,Linux软件源码包的安装（Tarball的安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件源码包安装背景
接触过Linux的人都知道要在Linux上安装软件通常使用rpm或yum，这两种工具的出现确实大大减少我们在Linux系统上安装软件的工作量，但是rpm及yum的安装的软件都是基于某种平台事先编译好的成品，这个成品中制作者考虑种种因素可能会对这个软件的功能进行一定程度的剪裁，也就是说现成的rpm包或yum包不是最全的软件包。而如果我们想要添加这个软件的rpm或yum中未包含的功能该怎么办？为了解决这个问题，我们就要使用软件源码包进行安装。
什么是软件源码包？
Linux软件的源代码分发是指提供了该软件所有程序源代码的发布形式，需要用户自己编译成可执行的二进制码并进行安装。其优点是配置灵活，可以随意去掉或保留某些功能/模
块，适应多种硬件/操作系统平台及编译环境；缺点是难度较大，一般不适合初学者使用
源码包格式有两种：
1．*.src.rpm形式的源代码软件包
2．*.tar.gz/*.xz/*.bz2形式的源代码软件包
软件源码包的安装
1．*.src.rpm形式的源代码软件包
(该类型由于还是以rpm功能实现的软件安装，这里只是简单介绍下其方法，具体如何实验就不再演示。)
假设此*.src.rpm文件在/usr/local/src下，在该目录下执行rpmbuild --rebuild *.src.rpm，若命令顺利执行则会在/usr/src/dist/RPMS下出现*.rpm
大致过程如下：
安装：
rpm -rebuild *.src.rpm(会自动根据所在平台转换成相应的平台rpm包)
cd /usr/src/dist/RPMS
rpm -ivh *.rpm
卸载：
rpm -e packagename
2．*.tar.gz/*.xz/*.bz2形式的源代码软件包
以tar.gz或tgz或tar.bz2等格式结尾的软件包一般都是以源代码方式发布的软件，安装这类软件首先需要对软件进行解压：
# tar -zxvf filename.tar.gz
# tar -Jxvf filename.tar.xz
# tar -jxvf filename.tar.bz2
解压以后，就可以进入解压后的目录：
# cd filename/
对于这类文档，常见的安装步骤是：配置、编译和安装3步，其中最麻烦的就是配置，因为所有和软件安装相关的配置都是在这一步指定的：比如软件安装位置等。
配置：./configure
编译：make
安装：make install
卸载：make uninstall 或手动删除
说明：建议解压后先阅读说明文件(ReadMe和Install)，了解安装的需求，有必要时还需改动编译配置。有些软件包的源代码在编译安装后可以用make uninstall命令来进行卸载，如果不提供此功能，则软件的卸载必须手动进行。由于软件可能将文件分散地安装在系统的多个目录中，往往很难把它删除干净，那你应该在编译前进行配置，指定软件将要安装到目标路径：./configure --prefix=目录名，这样可以使用“rm -rf 软件目录名”命令来进行干净彻底的卸载。
Tarball形式的源代码软件包安装实验详解
该实验以httpd-2.2.29.tar.bz2为例进行实验
实验环境
实验准备：
1、确认httpd-2.2.29.tar.bz2已下载，通常会把源码包保存在/usr/local/src路径下
2、确认make工具存在,rpm -q make检查即可，若不存在安装之。
3、为确保编译环境没有问题，我们最好使用yum groupinstall "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e83e0c2124cbf36f8e047b0346a0161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e852f91f5e97fae0b93fbdbe7b366c63/" rel="bookmark">
			HTTP状态 500 - 内部服务器错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用tomcat 10和jdk8时，出现问题，这是由于tomcat 10和jdk8版本不匹配的问题导致的，换用tomcat 9可以解决此问题：
HTTP状态 500 - 内部服务器错误 类型 异常报告 消息 实例化Servlet类[com.sunrise.java.HelloServlet]异常 描述 服务器遇到一个意外的情况，阻止它完成请求。 例外情况 jakarta.servlet.ServletException: 实例化Servlet类[com.sunrise.java.HelloServlet]异常 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:543) org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:690) org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:353) org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:870) org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1696) org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) java.lang.Thread.run(Thread.java:748) 根本原因。 java.lang.NoClassDefFoundError: javax/servlet/http/HttpServlet java.lang.ClassLoader.defineClass1(Native Method) java.lang.ClassLoader.defineClass(ClassLoader.java:763) java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) org.apache.catalina.loader.WebappClassLoaderBase.findClassInternal(WebappClassLoaderBase.java:2470) org.apache.catalina.loader.WebappClassLoaderBase.findClass(WebappClassLoaderBase.java:866) org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1370) org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1224) org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:543) org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:690) org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:353) org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:870) org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1696) org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) java.lang.Thread.run(Thread.java:748) 根本原因。 java.lang.ClassNotFoundException: javax.servlet.http.HttpServlet org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1401) org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1224) java.lang.ClassLoader.defineClass1(Native Method) java.lang.ClassLoader.defineClass(ClassLoader.java:763) java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) org.apache.catalina.loader.WebappClassLoaderBase.findClassInternal(WebappClassLoaderBase.java:2470) org.apache.catalina.loader.WebappClassLoaderBase.findClass(WebappClassLoaderBase.java:866) org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1370) org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1224) org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:543) org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e852f91f5e97fae0b93fbdbe7b366c63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4740229c6bf3c8bb15ac1974f50a1dfa/" rel="bookmark">
			nodemcu使用mqtt连接onenet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下折腾nodemcu的经过。
本文主要讲述如何使用nodemcu开发板上报数据到onenet云平台
硬件连接 如图所示，黑线为地线，红线为接3.3V，蓝色的线为数据线。
软件代码 有关与温湿度数据的获取请查看本人撰写的这篇《基于nodemcu开发板与DHT11温湿度传感器》
【https://blog.csdn.net/Lozenyi/article/details/115409547】
首先是相关的头文件
#include &lt;DHT.h&gt;//温湿度传感器库 #include &lt;ESP8266WiFi.h&gt;//WiFi头文件 #include &lt;PubSubClient.h&gt;//mqtt库头文件 WIFI与MQTT协议的相关连接参数的设置
//接入WiFi参数 #define wifi_ssid "youwifissid" #define wifi_passwd "youwifipawssd" //MQTT协议接入参数 const char* mqtt_server = "mqtt.heclouds.com";//mqtt服务器网址【这是onenet的mqtt服务器】 const char* mqtt_com="6002";//mqtt服务器端口 const char* mqtt_ID="*********";//设备ID const char* mqtt_CID="*******";//产品ID const char* mqtt_key="********";//鉴权信息【密码】 实例化
WiFiClient wifiClient;//建立WiFiClient对象 PubSubClient mqttClient(wifiClient);//建立mqttClient对象 WiFi初始化
//WiFi初始化【连接WiFi】 void WiFiInit(){ WiFi.mode(WIFI_STA);//设置为客户端模式 WiFi.begin(wifi_ssid,wifi_passwd);//输入WiFi参数 while(WiFi.status() != WL_CONNECTED){//判断连接状态，后面的是个库里定义的常量 delay(2000); Serial.println("WIFI not Connect"); } Serial.println("Connected to AP"); Serial.print("IP address is "); Serial.println(WiFi.localIP()); } mqtt连接函数，【用于重连服务】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4740229c6bf3c8bb15ac1974f50a1dfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083940f2b1b1486d60cd680cd80b31d3/" rel="bookmark">
			oracle计算数据环比sql,用分析函数计算环比、同比oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.普及一下概念
环比 = 2018年10月/2018年09月(同一时期内不同时间段的比较)
同比 = 2018年10月/2017年10月(不同时期内相同时间段的比较)
环比增长率 = (2018年10月-2018年09月)/2018年09月
同比增长率 = (2018年10月-2017年10月)/2017年10月
2.关键sql 解释
(1)分析函数
lead(params,m,n) 以params为目标向下m位取数，当取不到时默认为 n,
lag(params,m,n) 以params为目标向上m位取数，当取不到时默认为 n
over(order by...) 相当于 order by...
partition by ... 根据参数最为分割，将相同的先分割到一块
3.具体sql例子
//按月统计发票的总金额、总税额、总票数、月同比、月环比 、同比增长率、环比增长率
select a.sumquantity,
nvl(round(a.sumquantity /lag(a.sumquantity) over( order by a.yearmonth)*100, 2), '0') ||'%' sumquantityHB,
nvl(round((a.sumquantity-a.lagAHB)/lag(a.sumquantity) over( order by a.yearmonth)*100, 2), '0') ||'%' sumquantityHBG,//计算环比(按月) 关键代码lag()over(partition by 月份/年份 order by 排序条件)
nvl(round(a.sumquantity/lag(a.sumquantity) over(partition by to_char((to_date(a.yearmonth, 'yyyy/MM')), 'MM') order by a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/083940f2b1b1486d60cd680cd80b31d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386ad075f2e435ab266354b145815abb/" rel="bookmark">
			matlab怎么改变程序字体大小,matlab怎么把程序字体变大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 如何改变matlab中的字体大小
方法/步骤1打开MATLAB R2012b软件，点击主界面上方的菜单栏的“Preferences”按钮。
2然后在左栏找到“Fronts”，点击它左边的“+”展开它的子项。3点击“Custom”，接下来就可以设置了。
现在就以命令窗口为例介绍字体设置。在右边的Desktop tools里选择“Command Windows”，在Font to use选第三个，即“Custom”，然后在三个可选的项目里选择自己想要的字体、字号和样式，本例中直接将字号从原先的10号改为14号，其他两项不变。
同样操作也可以为代码编辑窗口设置字体。4然后点击下方的“Apply”按钮，再点击“Ok”以确认。
或有些版本可以直接点击“Ok”如MATLAB R2012b软件。5最后我们来体验一下设置前后的变化。
左图是设置前的字体，右图是设置后的字体。。
2. matlab 帮助文件怎么改字体大小
matlab2012b
help中字体太小，不方便查阅，而preference&gt;&gt;font中也没有相应设置选项，用ctrl-+和ctrl--可以实现放大和缩小，但重新打开help页面时字体又恢复了原来的大小。找到安装目录下相关配置文件即可更改页面比例的初始设置，D:\Program
Files\MATLAB\R2012b\help\includes\product\css\site5.css 文件，更改文中的font-size后的62.5%为合适的数值即可。
/* Page Globals */
html { min-height:100%; margin-bottom:1px; }
html body { height:100%; padding:0px; margin:0px;
font-family:Arial, Helvetica, sans-serif;
font-size:62.5%
; color:#000; line-height:140%; background:#fff; overflow-
y:scroll; }
html body td { vertical-align:top; text-align:left; }
img { border:none }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e40267046b326f82b8b9c0c56dec44/" rel="bookmark">
			灰度直方图均衡化（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 直方图均衡化的引入：
在日常生活中我们经常碰到非常亮或者非常暗的图片，导致整张图片的对比度明显，说的专业一点就是整张灰度图的灰度在低灰度或者高灰度区过于集中。那么怎么解决这个问题呢？我们很自然地可以想到把这个灰度图的灰度区间拉大。对比度不就清晰了嘛~
2. 本质特性
其实灰度直方图均衡化就是把聚集在一起的各个灰度跨度拉宽，一对一（其实严格来讲是多对一）地把一个灰度映射到一个灰度上。我们并不能说新生成的灰度是真实信息，它只是我们为了增强对比度变化得来的灰度。
3. 映射函数
那么该怎么选择映射函数呢？
应当有如下几个特点：
其一，不应当破坏原有灰度的顺序，不能说原来相对亮的区域变得特别暗了，原来相对暗的区域变得特别亮了。打个比方，你不可以在变换后把天空太阳的灰度图变成“白纸上的黑洞”。
其二，变换后的灰度图要差不多波及0到255的灰度，这是作为直方图均衡化所要达到最基本的条件。
借鉴于概率统计的内容，我们可以很自然地想到一个概念：累计分布函数，这个函数是什么样的呢？
这样：F(x)=P(X&lt;=x),我们来看看他是否满足以上条件，当x=0时，F（x)为0；当x=1时，F(x)为1，且F（x)单调递增，与此同时，由于F（x)遍布0到1，将其值乘以255，则理论上可以遍布0到255的灰度值。
到目前为止，我们已经选好了映射函数，接下来我们可以正式处理灰度直方图的均衡化问题了。
4. 实际操作
（作业要求对四张图像处理因此可以说是同一段代码复制了四遍）
H= imread('1.Dark.tif'); [m,n]=size(H); p=zeros(1,256); for i=0:255 p(i+1)=length(find(H==i))/(m*n); end figure(1); subplot(3,2,1); imshow(H); title('原图'); subplot(3,2,2); bar(0:255,p,'b'); title('原图直方图'); c=zeros(1,256); for i=1:256 for j=1:i c(i)=p(j)+c(i); end end s=round(c*255); b=H; for i=0:255 b(find(H==i))=s(i+1); end subplot(3,2,3); imshow(b) title('均衡化后图像'); for i=0:255 k = find(s==i) GPeq(i+1)= sum(p(k)); end subplot(3,2,4); bar(0:255,GPeq,'b'); title('均衡化后的直方图'); subplot(3,2,5); x=0:1:255; plot(x,s,'b'); axis([0 255 0 255]); H= imread('2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55e40267046b326f82b8b9c0c56dec44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/188e7115ca1c29a96db3b2007a48cdef/" rel="bookmark">
			通过 git 实现微前端公共资源共享方案（subtree）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过 git 实现微前端公共资源共享方案（subtree） 公共资源工程机构：
|-----------web-portal | |------src | |------library |-----------web-sub1 | |------src | |------library |-----------web-sub2 | |------src | |-----library | web-common（library） （公共资源仓库） 下面就使用 git subtree 为每个应用引入 library
将 library 仓库添加至应用仓库的 src/library 位置: 在项目仓库根路径执行以下命令 git subtree add --prefix=src/library git@gitlab.XXX.com:XXX/web-common.git dev --squash 执行完毕，每个子应用仓库 src/ 路径下会出现 library 文件夹，–prefix=后面即是路径
拉取公共仓库代码（如果公共仓库有更新） git subtree pull --prefix=src/library git@gitlab.XXX.com:XXX/web-common.git dev --squash git@gitlab.XXX.com:XXX/web-common.git 是 gitlab 仓库地址。
将src/library 下的内容改动推送至公共资源仓库 git subtree push --prefix=src/library git@gitlab.XXX.com:XXX/web-common.git dev 注意，你的项目代码正常推送即可，src/library 作为项目下的一个文件夹无需特殊处理（方便！）
说到方便，每次命令都需要写公共资源仓库git@gitlab.XXX.com:XXX/web-common.git 地址是很不方便，可以将先将公共资源仓库地址添加为 remote： git remote add -f library git@gitlab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/188e7115ca1c29a96db3b2007a48cdef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f92d82ed2fe68d41b8a04df4c44152/" rel="bookmark">
			【五】AI Studio 项目详解【VisualDL工具、环境使用说明、脚本任务、图形化任务、(五)在线部署及预测】PARL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章
【一】-环境配置+python入门教学
【二】-Parl基础命令
【三】-Notebook、&amp;pdb、ipdb 调试
【四】-强化学习入门简介
【五】-Sarsa&amp;Qlearing详细讲解
【六】-DQN
【七】-Policy Gradient
【八】-DDPG
【九】-四轴飞行器仿真
飞桨PARL_2.0&amp;1.8.5（遇到bug调试修正）
一、AI Studio 项目详解【VisualDL工具】
二、AI Studio 项目详解【环境使用说明、脚本任务】
三、AI Studio 项目详解【分布式训练-单机多机】
四、AI Studio 项目详解【图形化任务】
五、AI Studio 项目详解【在线部署及预测】
【五】AI Studio 项目详解【在线部署及预测---生成沙盒】 在线部署与预测为开发者提供训练模型向应用化API转换的功能. 开发者在AI Studio平台通过NoteBook项目完成模型训练后, 在Notebook详情页通过创建一个在线服务, 应用模型生成在线API, 使用该API可以直接检验模型效果或实际应用到开发者的私有项目中.目前, 该功能暂时仅对Notebook项目开放。
通过训练任务生成模型文件 在训练任务过程中, 通过调用paddle.fluid.io.save_inference_model`实现模型的保存，保存后的目录需要可以被在线服务使用. 我们以房价预测的线性回归任务为例, 具体代码如下 import paddle import paddle.fluid as fluid import numpy import math import sys from __future__ import print_function BATCH_SIZE = 20 train_reader = paddle.batch( paddle.reader.shuffle( paddle.dataset.uci_housing.train(), buf_size=500), batch_size=BATCH_SIZE) test_reader = paddle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f92d82ed2fe68d41b8a04df4c44152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10b76ed8295e1255c55cb38563a5025/" rel="bookmark">
			创建自定义ingress报错：Internal error occurred: failed calling webhook “validate.nginx.ingress.kubernetes.io
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 当我使用ingress-demo.yaml文件创建自定义的ingress时
使用命令创建：kubectl apply -f ingress-demo.yaml
报如下错误：
Internal error occurred: failed calling webhook "validate.nginx.ingress.kubernetes.io": Post https://ingress-nginx-controller-admission.kube-system.svc:443/networking/v1beta1/ingresses? timeout=10s: dial tcp 10.0.0.5:8443: connect: connection refused 这里的ingress-demo.yaml文件的内容如下：
apiVersion: extensions/v1beta1 kind: Ingress metadata: name: ingress-demo namespace: test spec: rules: - host: test.test.test http: paths: - path: / backend: serviceName: test-service servicePort: 80 原因分析： 我刚开始使用yaml的方式创建nginx-ingress，之后删除了它创建的命名空间以及 clusterrole and clusterrolebinding ，但是没有删除ValidatingWebhookConfiguration ingress-nginx-admission，这个ingress-nginx-admission是在yaml文件中安装的。当我再次使用helm安装nginx-ingress之后，创建自定义的ingress就会报这个错误。
解决方案： 最后参考下面的文章解决此问题
使用下面的命令查看 webhook kubectl get validatingwebhookconfigurations ingress-nginx-admission 删除ingress-nginx-admission kubectl delete -A ValidatingWebhookConfiguration ingress-nginx-admission 参考文章：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e10b76ed8295e1255c55cb38563a5025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11fc7a853d89d46687771e79bba97456/" rel="bookmark">
			Hologres笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hologres笔记 一、常用命令 -- 创建内部表 begin; create table [if not exists] [schema_name.]table_name( id bigint primary key, b text, ds text, ) partition by list(ds); commit; -- 创建子表 create table if not exists table_name_date_202101 partition of table_name for values in ('202101'); -- 创建外部表 CREATE FOREIGN TABLE odps_students ( id bigint, b text, ds text, ) SERVER odps_server OPTIONS (project_name 'public_data', table_name 'oracle2odps_cust'); -- 删除表	DROP TABLE [ IF EXISTS ] table_name [, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11fc7a853d89d46687771e79bba97456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e900f2f55f3e17596c156d8e9366709/" rel="bookmark">
			Visual Studio安装时，不能更改共享组件、工具和SDK的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前安装的时候把安装路径改了，之后卸载不干净，注册表还留有缓存，不能更改位置，如下图
微软官方提供的卸载工具：TotalUninstaller（卸载不干净可以用这个工具）
解决办法：更改注册表 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\Setup下的SharedInstallationPath项为所要的路径。或者直接删除。我这里是把两个缓存路径都删除掉了，打开vs installer就可以更改安装位置了。（打开注册表编辑器方法：WIN + R --&gt; regedit ）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a003b125ceebd74a6c7f0eaab5f6889f/" rel="bookmark">
			ctf题php反序列化,从一道CTF题中学习php反序列化与伪协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直有想写关于反序列化的东西，可是一直拖拖拖，拖到了现在。
本文尝试从ZJCTF2019中的例题来了解何为php反序列，以及php伪协议。
原题：逆转思维1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20$text = $_GET["text"];
$file = $_GET["file"];
$password = $_GET["password"];
if(isset($text)&amp;&amp;(file_get_contents($text,'r')==="welcome to the zjctf")){
echo "
".file_get_contents($text,'r').""; if(preg_match("/flag/",$file)){
echo "Not now!";
exit();
}else{
include($file);
$password = unserialize($password);
echo $password;
}
}
else{
highlight_file(__FILE__);
}
?&gt;
给text传值
从代码来看，当给text传入“welcome to the zjctf”时可以进入到If语句。直接传值会被file_get_contents过滤掉，所以这里利用php伪协议来给text传值。1payload为text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=
官网资料：
file_get_contents 函数是用于把文件的内容读入到一个字符串中的首选方法
打印date内容 echo file_get_contents(‘data://text/plain;base64,SSBsb3ZlIFBIUAo=’);
读取useless.php文件
从源码中可以看出不能直接读取flag.php文件，根据提示我们先要读取useless.php文件。1payload为file=php://filter/read=convert.base64-encode/resource=useless.php
解码得到：1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a003b125ceebd74a6c7f0eaab5f6889f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cefd2646d6d2501cd43a68f1768ff1d2/" rel="bookmark">
			layui的使用（table/form）——layui踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司之前的老系统是前后端不分离的MVC模式，是基于Layui开发的。
1.引入layui 引入文件的具体路径需要根据实际项目来。
&lt;link href="~/Content/plugins/layui-v2.4.3/layui/css/layui.css" rel="stylesheet" /&gt; &lt;script src="~/Content/plugins/layui-v2.4.3/layui/layui.js"&gt;&lt;/script&gt; 2. 页面功能分析 页面结构如上图所示：
可以看到页面中有button input select table等。
button的使用 &lt;button class="layui-btn check" onclick="refresh()"&gt;刷新&lt;/button&gt;
刷新页面功能实现：
//刷新 function refresh() { window.location.reload(); } input的使用 &lt;input type="text" style="width:300px;margin-right:10px;" name="name" id="name" class="sinput" placeholder="请输入供应商全称" autofocus="" maxlength="50" /&gt;
获取input中的内容可以通过$('#name').val()的方式来获取
select的使用 &lt;select name="type" lay-filter="aihao" id="type"&gt; &lt;option value=""&gt;请选择供应商类型&lt;/option&gt; &lt;option value="1"&gt;原厂&lt;/option&gt; &lt;option value="2"&gt;代理&lt;/option&gt; &lt;option value="4"&gt;贸易&lt;/option&gt; &lt;/select&gt; 获取select中选择的内容可以通过$('#type').val()的方式来获取
如果是需要通过接口获取select中的选项，然后动态渲染到页面中的话，则需要下面的方式：
layui.use(['form'], function () { var form = layui.form; //调用接口获取数据 //$.get(接口地址，函数回调) $.get(url + "Brand", function (res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cefd2646d6d2501cd43a68f1768ff1d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8e0e23d4cf294ea1fc0b9bef36a72f/" rel="bookmark">
			Android Studio 3.0 Profiler 性能分析利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:Android Profiler的是使用流程： 1.点击工具栏的图标即可打开
在Android Profiler窗口的顶部，如图所示，选择设备 ①和你想要配置的app进程 ②当我们连接一个设备后，打开Android Profiles运行我们的应用程序时，它会默认选中我们的程序，Android Profiler显示如图1（图片来自官网）： 如果我们连接了多个设备可以在按钮 ①的位置选择设备，通过按钮 ②的位置选择想要的app进程，工具最底部显示了一个时间轴，其中包含了CPU、内存和网络使用的实时图。该窗口还包括时间轴缩放控制按钮 ③，一个跳转到实时更新的按钮 ④，以及显示活动状态、用户输入事件和屏幕旋转事件 ⑤的事件时间轴。
我们想要查看对应工具详细的分析工具，只要单击性能数据相对应的图即可。下看看对应工具详细的使用。
2:内存工具 2.1内存工具简述（Memory Profiler）
我们打开Memory Profiler后界面如下图（图片来自官网）
如图所示，内存剖析器的默认视图包括以下内容: ①:强制执行垃圾收集事件的按钮 ②:捕获堆转储的按钮 ③:一个记录内存分配的按钮,当连接到运行Android7.1或更低的设备时，该按钮才会出现 ④:放大/退出时间线按钮 ⑤:可以跳转到实时内存数据的按钮。 ⑥:事件时间轴，显示活动状态、用户输入事件和屏幕旋转事件。 ⑦:内存使用时间线，包括以下内容:一个堆叠图，显示每个内存类别的内存大小，如左侧的y轴和顶部的颜色键。虚线表示已分配对象的数量，如右侧的y轴所示。每个垃圾收集事件的图标
2.2:内存计算指标
根据Android系统，你在内存分析器的顶部看到的数字(如下图)基于你的应用所提交的所有私有内存页面。此计数不包括与系统或其他应用程序共享的页。
内存类别如下:
Java:从Java或Kotlin代码中分配的对象的内存Native:从C或c++代码中分配的对象的内存，即使你没有在app中使用c++，你可能会看到一些本地内存，因为Android框架使用Native内存来处理各种任务，比如处理图像资产和其他图形——即使你写的代码是Java或KotlinGraphics:用于图形缓冲区队列的内存用于显示屏幕上的像素，包括GL表面、GL纹理等。(注意，这是与CPU共享的内存，而不是专用的GPU内存)Stack:在你的应用程序中，Native和Java栈使用的内存。这通常与你的应用程序运行的线程数有关Code:您的应用程序用于代码和资源的内存，如dex字节码，优化或编译的dex代码。所以库和字体Other:应用程序使用的内存，系统不确定如何分类Allocated:应用程序分配的Java/Kotlin对象的数量。这并不计算用C或c++分配的对象 注意:当前应用程序中，native内存统计值可能会偏大，因为分析工具的一部内存也被算进去了，多达10MB的内存被添加到~100k对象，在未来版本的工具中，这些数字将从您的数据中过滤出来。
2.3:查看内存分配情况
单击工具栏记录内存分配在内存分析器我们想要查看某一时刻程序的内存分配情况也很简单，如下图：
最后的界面如下图： 2.4 捕获heap dump
heap dump显示在你捕获heap dump时应用程序中的哪些对象正在使用内存,特别是在扩展的用户会话之后，heap dump可以通过显示仍在内存中的对象来帮助识别内存泄漏。一旦捕获heap dump，可以查看以下内容：
应用分配了哪些类型的对象，以及每个对象的数量每个对象使用多少内存。每个对象的引用都被保存在你的代码中。调用堆栈分配对象的位置,（当您在录制分配时捕获heap dump 时，调用堆栈当前仅在Android 7.1中使用堆转储时才可用。 要捕获heap dump，在Memory Profiler工具栏中单击Dump Java heap按钮即可在转储堆时，Java内存量可能会暂时增加，因为堆转储发生在和你的应用程序相同的进程，并需要一些内存来收集数据，heap dump出现在内存时间线下方，显示了堆中的所有类型，如图下图所示：
在图中可以看到Class Name列表，，在列表中可以看到以下信息：
Alloc Count：堆中的分配数量。Native Size：此对象类型使用的Native内存总量（以字节为单位），此列仅适用于Android 7.0及更高版本。你会在这里看到一些在Java中分配的对象的内存，因为Android为一些框架类（比如Bitmap）使用本地内存。Shallow Size：此对象类型使用的Java内存总量（以字节为单位）Retained Size：由于此类的所有实例而保留的内存总大小（以字节为单位）在class 列表顶部，可以使用左侧的下拉列表在下列堆转储之间切换Default heap：当系统没有指定堆时。App heap：你的应用程序分配内存的主要堆。Image heap：系统引导映像，包含在引导期间预加载的类，这里的分配保证不会移动或消失，Zygote heap：Android系统中的应用程序进程分支的写入时复制堆。 2.5 将 heap dump 保存为 HPROF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8e0e23d4cf294ea1fc0b9bef36a72f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1776a829b0ebda1a2b4f0f480a49cabe/" rel="bookmark">
			QT:从外部拖拽文件到QWidget中，获取其文件的路径（单文件和多文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
程序运行实例
实现步骤
完整示例代码
程序运行实例 实现步骤 1、启用拖放事件
setAcceptDrops(true); 2、重写 dragEnterEvent 和 dropEvent 事件
//拖动进入事件 void Widget::dragEnterEvent(QDragEnterEvent *ev) { if(ev-&gt;mimeData()-&gt;hasUrls())//是否是文件路径 { ev-&gt;accept();//接收拖动进入事件 } //ev-&gt;ignore();//若忽略该事件，则不会发生之后的事件，拖放到此结束 } //拖动放下事件 void Widget::dropEvent(QDropEvent *ev) { if(ev-&gt;mimeData()-&gt;hasUrls()) { QList&lt;QUrl&gt; urls = ev-&gt;mimeData()-&gt;urls(); //单个文件路径 //QString fileName = urls.at(0).toLocalFile(); //qDebug()&lt;&lt;fileName; //多个文件路径 for(int i=0; i&lt;urls.size(); i++) { qDebug()&lt;&lt;urls.at(i).toLocalFile(); } } } 完整示例代码 #ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; namespace Ui { class Widget; } class Widget : public QWidget { Q_OBJECT public: explicit Widget(QWidget *parent = 0); ~Widget(); protected: void dragEnterEvent(QDragEnterEvent* ev) override; void dropEvent(QDropEvent* ev) override; private: Ui::Widget *ui; }; #endif // WIDGET_H #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1776a829b0ebda1a2b4f0f480a49cabe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551242a82a935026b528886da87df9f0/" rel="bookmark">
			抓取视频的任意一帧保存为图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java：使用第三方工具 compile 'org.bytedeco:javacv-platform:1.5.2' package io.vertx.starter.util; import java.awt.Dimension; import java.awt.Graphics2D; import java.awt.Rectangle; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import javax.imageio.ImageIO; import org.bytedeco.javacv.FFmpegFrameGrabber; import org.bytedeco.javacv.Frame; import org.bytedeco.javacv.FrameGrabber; import org.bytedeco.javacv.Java2DFrameConverter; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * 视频文件处理工具类 */ public class VideoGraber { private static final Logger logger = LoggerFactory.getLogger(VideoGraber.class); private static final String ROTATE = "rotate"; /** * 生成的图片的类型 */ private static final String IMAGE_FORMAT = "jpg"; public static void main(String[] args) { createScreenShot("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551242a82a935026b528886da87df9f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff5e0e2b4b816756f23c3ef801bd4747/" rel="bookmark">
			二叉排序树的删除&#43;图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图解 第一种情况 第二种情况 第三种情况 代码实现 package com.atguigu.binarysorttree; import com.sun.javafx.sg.prism.NGImageView; import javafx.scene.transform.Rotate; import java.io.InputStream; import java.util.Timer; /** * @创建人 wdl * @创建时间 2021/3/29 * @描述 */ public class BinarySortTreeDemo { public static void main(String[] args) { int arr[]={7,3,10,12,5,1,9,0}; BinarySortTree binarySortTree = new BinarySortTree(); //循环的添加节点到二叉排序树 for (int i = 0; i &lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } //中序遍历二叉排序树 System.out.println("中序遍历二叉排序树"); binarySortTree.infixOrder(); //测试一下删除叶子节点 // binarySortTree.delNode(2); // System.out.println("删除节点后"); // binarySortTree.infixOrder(); // binarySortTree.delNode(1); // System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff5e0e2b4b816756f23c3ef801bd4747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfc06eb094a51219c5bf29ce602e558/" rel="bookmark">
			排障集锦：九九八十一难之第二十八难！安装docker时glibc-common版本冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 报错如下
执行yum-complete-transaction
发现 glibc-common版本冲突问题
二、问题解决 1.查看当前rpm包的版本： rpm -qa|grep 包名
2.发现有两个版本，选择卸载高版本
rpm -e 文件名
3、卸载完成后再次执行yum-complete-transaction 还是有问题 报错字段如下
trying remove systemd
trying remove yum
4、执行如下命令
yum-complete-transaction --cleanup-only
5、再次执行
yum-complete-transaction 发现没有报错了
造成这个原因是因为多次执行了安装任务，造成安装的glibc-common事务被挂起，进而影响到后面的再次执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b2fcc3d12860c25edd8ac1bc079162/" rel="bookmark">
			Improved Variational Inference with Inverse Autoregressive Flow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概主要内容代码 Kingma D., Salimans T., Jozefowicz R., Chen X., Sutskever I. and Welling M. Improved Variational Inference with Inverse Autoregressive Flow. NIPS, 2016.
概 一种较为复杂normalizing flow.
主要内容 IAF的流程是这样的:
由encoder 得到 μ , σ , h \mu, \sigma, h μ,σ,h, 采样 ϵ \epsilon ϵ, 则
z 0 = μ 0 + σ 0 ⊙ ϵ ; z_0 = \mu_0 + \sigma_0 \odot \epsilon; z0​=μ0​+σ0​⊙ϵ;由自回归模型得到 μ 1 , σ 1 \mu_1, \sigma_1 μ1​,σ1​, 则
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69b2fcc3d12860c25edd8ac1bc079162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a088a1e7af0bcc5afc37901bf2a2e42d/" rel="bookmark">
			Linux基础入门和文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Linux基础入门1、Linux系统默认提示符2、执行命令3、查看硬件信息4、查看系统版本信息5、 日期和时间6、 关机和重启7、用户登录信息查看命令8、会话管理9、命令行扩展和被括起来的集合 一、Linux基础入门 1、Linux系统默认提示符 安装好linux系统后 默认的系统命令提示符没有个性 并不醒目 无法明显辨别生产和测试环境，可能会导致误操作 所以我们可以通过修改PS1变量实现个性的提示符格式，避免在生产环境中出现误操作的低级错误
示例：默认的系统提示符
#CentOS默认提示符 [root@localhost ~]# #Ubuntu默认提示符 root@ubuntu1804:~# 其中
#代表管理员用户
$代表普通用户
查看提示符格式
[root@centos8 ~]#echo $PS1 \[\e[1;35m\][\u@\h \W]\$\[\e[0m\] 修改提示符格式
[19:45:41 root@centos8 ~]# PS1="\[\e[1;5;41;33m\][\u@\h \W]\\$\[\e[0m\]" PS1="\[\e[1;32m\][\t \[\e[1;33m\]\u\[\e[35m\]@\h\[\e[1;31m\] \W\[\e[1;32m\]]\ [\e[0m\]\\$" 提示符格式说明：
提示符含义\e控制符\033\u当前用户\h主机名简称\H主机名\w当前工作目录\W当前工作目录基名\t24小时时间格式\T12小时时间格式!命令历史数#开机后命令历史数 在CentOS系统实现持久保存提示符格式
[root@centos8 ~]# echo 'PS1="\[\e[1;32m\][\t \[\e[1;33m\]\u\[\e[35m\]@\h\ [\e[1;31m\] \W\[\e[1;32m\]]\[\e[0m\]\\$"' &gt; /etc/profile.d/env.sh [root@centos8 ~]#cat /etc/profile.d/env.sh PS1="\[\e[1;32m\][\t \[\e[1;33m\]\u\[\e[35m\]@\h\[\e[1;31m\] \W\[\e[1;32m\]]\ [\e[0m\]\\$ 实现Ubuntu系统持久保存提示符格式
[root@ubuntu2004 ~]#echo "PS1='\[\e[1;35m\][\u@\h \W]\\$\[\e[0m\]'" &gt;&gt; .bashrc [root@ubuntu2004 ~]#tail -1 .bashrc PS1='\[\e[1;35m\][\u@\h \W]\$\[\e[0m\]' 2、执行命令 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a088a1e7af0bcc5afc37901bf2a2e42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf339627b513cce4c61b117ff2e09ca0/" rel="bookmark">
			【BUUCTF刷题】Web解题方法总结（一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言信息搜集SQL缺省代码审计SQL注入常规流程BUUCTF HardSQL堆叠注入使用MD5函数实现sql注入例题BUUCTF WEB [CISCN2019 华北赛区 Day2 Web1]Hack World(SQL盲注，PHP）[GYCTF2020]Blacklist [堆叠注入] Ping命令nc tornado文件上传解法 [MRCTF]你传你🐎呢 HTTPPHP序列化和反序列化buu NiZhuanSiWeiBUUCTF [网鼎杯 2020 青龙组]AreUSerialz SSRF 前言 边刷题边总结些知识点，还在更新，冲！ 信息搜集 1.dirsearch使用
下载地址：https://github.com/maurosoria/dirsearch
切换到安装目录
py dirsearch.py -u 网址 -e 语言（一般用*） -u 指定url
-e 指定网站语言
SQL缺省 payload：*,1
查询语句：select *,1||flag from Flag
解题思路2：
payload:1;set sql_mode=PIPES_AS_CONCAT;select 1
解析：
在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接。
但在mysql 缺省不支持。需要调整mysql 的sql_mode
模式：pipes_as_concat 来实现oracle 的一些功能。
代码审计 1.使用php伪协议读文件内容。使用filter过滤器
?file=php://filter/convert.base64-encode/resource=flag.php 例题：BUUCTFweb Secret File
抓包
phpmyadmin 4.8.1的一个远程文件包含的漏洞(CVE) 白名单验证：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf339627b513cce4c61b117ff2e09ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d22fe784eac9271665520bedf9e0dd4/" rel="bookmark">
			ROS中将话题数据保存到txt文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以前面的PID参数整定数据为例，将机器人的电机速度数据输出到文档中，方便后续使用
1、创建a.txt文档
touch a.txt 2、查看话题
rostopic list 3、输出数据
rostopic echo /robot/MotorEncoder/data[0]&gt;a.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ccbbd522e051ec3433378e01612d89/" rel="bookmark">
			Element 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Element 官方文档： https://element.eleme.cn/#/zh-CN/component/installation
Vue 官方文档： https://cn.vuejs.org/v2/guide/
第一步： 引入相关资源
&lt;!-- 引入vue.js --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- 引入element-ui样式 --&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;!-- 引入element-ui组件库 --&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; 第二步： 使用 Message 消息提示组件
调用 Message 或 this.$message 会返回当前 Message 的实例。常用的参数有：message 表示消息文字内容；type 表示主题，其它参数可查阅 Message官方文档
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Element 快速入门&lt;/title&gt; &lt;!-- 引入vue.js --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- 引入element-ui样式 --&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;!-- 引入element-ui组件库 --&gt; &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ccbbd522e051ec3433378e01612d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6ab004c37c40dede210e6f09df2465/" rel="bookmark">
			高效VolumeLighting的实现及说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VolumeLighting的本质就是模拟丁达尔效应，即光线在空气中的散射效果。对于游戏渲染，远景可以直接使用大气散射实现，而近景则使用RayMatching的VolumeLighting实现。
具体可以看我做的Unity实现 https://gitee.com/alienity/srp-volume-lighting，有兴趣的同学可以看每次的提交记录，基本都记录了我每次提交的改进
实现原理 VolumeLighting原理很简单，就是使用RayMatching对每一小段的光照进行积分，最后把积分的结果加到最终渲染的纹理上。
我们做的完善的点
做了半分辨率的VolumeLighting纹理的RayMatching积分用Dither对RayMatching的起点做偏移，可以达到空间上对阶梯型的纹理做一次滤波使用BilateralUpSampling基于Depth做了上采样做RayMatching的时候使用3DTexture累计每一步得到的Volume积分强度，最后在绘制Transparent物体的时候直接从这张3DTexture中采样 废话不多说，我们看看代码实现
float4 RayMarch(float2 screenUV, float3 rayStart, float3 rayDir, float rayLength) { int stepCount = _SampleCount; float stepDifference = 1.0f / stepCount; float stepSize = rayLength * stepDifference; float3 step = rayDir * stepSize; int accVolumeWidth; int accVolumeHeight; int accVolumeDepth; _3DVolumeAccumulateTexture.GetDimensions(accVolumeWidth, accVolumeHeight, accVolumeDepth); int2 relativeXY = int2(accVolumeWidth, accVolumeHeight) * screenUV; // 因为这里使用了半分辨率，所以计算dither的时候也手动使用半分辨率计算 uint2 screenPos = uint2(screenUV * _ScreenParams.xy * 0.5f); uint2 ditherPos = fmod(screenPos, 4); float offset = _dither4x4[ditherPos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6ab004c37c40dede210e6f09df2465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9e9f01f3caf990d223516b5831a98b/" rel="bookmark">
			安装H3C Cloud Lab（HCL）时遇到的问题及解决办法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装HCL H3C Cloud Lab （HCL）时遇到的问题及解决办法汇总 安装HCL有感遇到的问题汇总1，see the logfile...for details2，请检查Virtual Box API是否安装正确解决方法 3，当前系统用户名中包含非ASCLL字符，hcl启动失败解决过程中的各种试错解决方法 4，HCL设备命令行输入没反应解决方法设备内存内存问题处理器是否支持硬件虚拟化360晶核防护引擎 结语 安装HCL有感 (这篇是以前写的，由于当时不熟悉这种文本编辑方式，又因安装时出现了太多错误，花费了大量的时间，导致积累实验作业较多，当时只写了一半，一直在草稿箱放着，最后不了了之。)原文如下：
由于课程学习的需求，需要在笔记本上安装HCL，本以为安个软件有什么难的，可是现实很残酷，从安装到能正常使用，我重装了软件n次，还更改了用户名，添加了新用户，还学会了安装虚拟机，删除注册表（中间还搞蓝屏了），一顿无用的骚操作之后，深深的认识到我是一个废物，而且运气超好，人家顶多遇到一个两个错误，而我能把错误快给收集齐了。内容较多且有些杂乱，可直接查看问题对应解决方法。
遇到的问题汇总 1，see the logfile…for details 如图：
解决方法：
右键HCL-属性-兼容性；把HCL和VB设置为以Windows7兼容模式进行。
2，请检查Virtual Box API是否安装正确 解决方法 出现此情况是由于HCL与当前系统安装的virtual box不兼容造成的；解决方式为完全卸载当前的virtual Box，重新安装，建议版本为Virtual Box 4.2.4。注意要卸载干净，否则会出现安装失败的情况。
3，当前系统用户名中包含非ASCLL字符，hcl启动失败 解决过程中的各种试错 出现此种问题的原因一般是当前系统的用户名出现了中文或其他的不合法字符；解决方法核心为更改系统用户名，通过百度收集有以下两种方式（我运气太好两种都尝试失败，有兴趣可以自行尝试）：
可能是我电脑系统版本的原因（Windows 10 家庭中文版），这个地方就开始麻烦了。提示用户名不合法就去查询怎么改用户名，发现了两种方式：
第一种成功修改用户名，但依然弹出此提示。
怎么样修改win10账户名称 如何更改系统用户名.如何更改电脑账户名称 .
第二种方法由于我的电脑操作系统版本为家庭中文版，功能受限无法进行相关操作。所以我使用了方法一进行修改。 根据方法1修改完账户名后进入HCL界面依旧显示“系统用户名中包含非ASCLL字符，hcl启动失败。”启动失败后，继续查找原因，然后发现C盘用户文件夹下依然存在未修改前的文件夹，考虑是否是这个地方出现了问题。然后继续各种搜索…
经过多次疯狂搜索后，在知乎上找到了我需要的解决方法：
win10如何更改c盘下的用户名？
这一个帖子的前两个回答，刚好解决了我想继续更改C盘下用户名的问题。附上链接：
win10如何更改c盘下的用户名？ - Gdeer的回答 - 知乎
win10如何更改c盘下的用户名？ - 知乎用户的回答 - 知乎
巧合的是第二位博主是参考第一位博主提供的方式下继续完善的，两相参考下应该可以解决。然而我在这个地方的操作就比较下饭了。。
可能是花费的时间太久，有些烦躁，两位博主的方式基本一致就是步骤前后上有差别，我急于设置，没有太过注意以至于把中间一步的注销切换用户给省略了，，然后一通操作，在当前用户下修改当前用户的文件名（请勿尝试一定要记得注销后登录）。电脑禁不住我的魔幻操作以致崩溃，喜提蓝屏。。
最后怎么改过来的怎么改了回去。蓝屏解决后重新老老实实按步骤操作，仍然弹出提示“当前系统用户名中包含非ASCLL字符，hcl启动失败”，
解决方法 由于又尝试几次依旧如此，在各种帖子里面翻也没有找到更好的办法，很是自闭。就在电脑前重新梳理了一下思路 ：当前系统用户名中包含非ASCLL字符，hcl启动失败 那换个系统怎么样呢？怎么换一个系统呢？换一台电脑吗？ 好像没那个实力，，那换一个操作系统呢？装一个双系统？或者安装一个虚拟机？
想到这里，便准备安装一个Windows 7 版本的虚拟机，于是开始下载Windows7操作系统的镜像文件，在下载等待的过程中，忽然想到是系统用户名非法，既然更改系统用户名失败，可以重新创建一个用户啊！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9e9f01f3caf990d223516b5831a98b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f54870c50fb43ff1a91893a6fe13d2/" rel="bookmark">
			Android加密之全盘加密(FDE)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全盘加密
注意：搭载 Android 7.0 - 9 的设备支持全盘加密。搭载 Android 10 及更高版本的新设备必须使用文件级加密。
全盘加密是使用密钥（密钥本身也经过加密）对 Android 设备上的所有用户数据进行编码的过程。设备经过加密后，所有由用户创建的数据在存入磁盘之前都会自动加密，并且所有读取操作都会在将数据返回给调用进程之前自动解密数据。
全盘加密是在 Android 4.4 版中引入的，不过 Android 5.0 中又引入了以下新功能：
新增了快速加密方式，这种加密方式只会对数据分区中已使用的分块进行加密，以免首次启动用时过长。目前只有 EXT4 和 F2FS 文件系统支持快速加密。添加了 forceencrypt fstab 标记，以便在首次启动时进行加密。添加了对解锁图案和无密码加密的支持。添加了由硬件支持的加密密钥存储空间，该空间使用可信执行环境（TEE，例如 TrustZone）的签名功能。如需了解详情，请参阅存储已加密的密钥。 注意：对于升级到 Android 5.0 的设备，如果升级之后进行了加密，则可以通过恢复出厂设置还原到未加密状态。在首次启动时加密的新 Android 5.0 设备无法还原到未加密状态。
Android 5.0 版中有以下 4 种加密状态：
默认PIN 码密码解锁图案 首次启动时，设备会创建一个随机生成的 128 位主密钥，然后会使用默认密码和存储的盐对其进行哈希处理。默认密码是“default_password”。不过，设备还会通过 TEE（例如 TrustZone）为生成的哈希签名。TEE 会使用相应签名的哈希来加密主密钥。
您可以在 Android 开源项目的 cryptfs.cpp 文件中找到定义的默认密码。
当用户在设备上设置 PIN 码/通行码或密码时，只有 128 位的密钥会被重新加密并存储起来（也就是说，更改用户 PIN 码/通行码/解锁图案不会导致重新加密用户数据）。请注意，受管理的设备可能有 PIN 码、解锁图案或密码限制。
使用 forceencrypt 加密新设备
这是 Android 5.0 设备首次启动时的普通流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5f54870c50fb43ff1a91893a6fe13d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb75b4d73c6686947e5066269a38b2d/" rel="bookmark">
			php 微信公众号 41005,php 微信公众平台上传多媒体接口 41005错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文链接: http://www.maoyupeng.com/wechart-upload-image-errorcode-41005.html
PHP的cURL支持通过给CURL_POSTFIELDS传递关联数组(而不是字符串)来生成multipart/form-data的POST请求。
传统上，PHP的cURL支持通过在数组数据中，使用“@+文件全路径”的语法附加文件，供cURL读取上传。这与命令行直接调用cURL程序的语法是一致的：
curl_setopt(ch, CURLOPT_POSTFIELDS, array(
‘file‘ =&gt; [email protected](‘image.png‘),
));
equals
$ curl -F "file=@/absolute/path/to/image.png" 但PHP从5.5开始引入了新的CURLFile类用来指向文件。CURLFile类也可以详细定义MIME类型、文件名等可能出现在multipart/form-data数据中的附加信息。PHP推荐使用CURLFile替代旧的@语法：
curl_setopt(ch, CURLOPT_POSTFIELDS, [
‘file‘ =&gt; new CURLFile(realpath(‘image.png‘)),
]);
PHP 5.5另外引入了CURL_SAFE_UPLOAD选项，可以强制PHP的cURL模块拒绝旧的@语法，仅接受CURLFile式的文件。5.5的默认值为false，5.6的默认值为true。
微信公众号多媒体上传接口返回码出现41005的原因就是不能识别文件.
归根到底,可能开发者没有太在乎php版本之间的更新和差异,所以导致在低版本的php环境开发的,然后部署到高版本的环境中.
需要注意的是php5.4 php5.5 php5.6三个版本都有所不同.下面我贴出一段上传图片代码,供大家参考(能兼容三个版本):
$filepath = dirname ( __FILE__ ) . "/a.jpg";
if (class_exists ( ‘\CURLFile‘ )) {//关键是判断curlfile,官网推荐php5.5或更高的版本使用curlfile来实例文件
$filedata = array (
‘fieldname‘ =&gt; new \CURLFile ( realpath ( $filepath ), ‘image/jpeg‘ )
);
} else {
$filedata = array (
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb75b4d73c6686947e5066269a38b2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae836ab5d0c7d90736bf626159d65968/" rel="bookmark">
			SpringSecurity 流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f2e5ff2ada1c6cb19da1e411eea589/" rel="bookmark">
			SpringSecurity 跨域问题 Cors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SpringBoot中只需要在Controller上添加@CrossOrigin,而在导入SpringSecurity后将会失效,所以需要我们在SpringSecurity中再进行配置
public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.cors(); } @Bean CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.addAllowedOrigin("*"); configuration.addAllowedMethod("*"); configuration.addAllowedHeader("*"); configuration.setAllowCredentials(true); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", configuration); return source; } } 此外,即使我们不配置CorsConfigurationSource而仅仅配置http.cors(),加上SpringBoot的@CrossOrigin,也可以实现除了/login之外的跨域问题.
前端代码 &lt;script&gt; axios.defaults.withCredentials=true;//一定要带登录后,springsecurity自动设定,否则无法访问受限制的网址 const params = new URLSearchParams();//将Json请求转换为Form请求 params.append('username', 'admin'); params.append('password', '123'); axios.post('http://localhost:8080/login', params) .then(res =&gt; console.log(res)); &lt;/script&gt; 参考:
https://zhuanlan.zhihu.com/p/95119912
https://www.jianshu.com/p/596157f3c93c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbacf3955f9475a96721644fadc46654/" rel="bookmark">
			半导体材料参数介绍-很有用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上期文章我们最后提到了半导体参数，之所以专门挑一篇文章来说，因为它确实比较重要，可以让我们明白当前各种半导体材料的优势与劣势的原因。
不仅如此，还可以让我们明白一些东西，特别是二极管和三极管的一些特性。
其实这些问题，如果明白了下面参数的含义，那么也就理解得差不多了。
禁带宽度
首先来看禁带宽度，这个参数是从能带模型里面来的。
固体中电子的能量是不可以连续取值的，而是一些不连续的能带，要导电就要有自由电子或者空穴存在，自由电子存在的能带称为导带（能导电）。被束缚的电子要成为自由电子，就必须获得足够能量从价带跃迁到导带，这个能量的最小值就是禁带宽度。
这段文字不好理解，那我们就以硅晶体来举例吧。
硅原子最外层含有4个电子，硅原子与硅原子之前通过共享电子形成晶体，这个“共享电子”也可以叫做形成化学键。形成化学键后，电子不能自由移动，所以不能导电。
这些形成的化学键的电子的能量是各不相同的，但他们有个特点，都处于一个范围，这个范围就叫价带。
如果这些化学键的电子获得了能量，从里面跑出来了，那它就成了自由电子。电子离开的地方形成了一个空位，所以构成了空穴，这两者都是可以导电的。同样的，所有这些自由电子的能量也各不相同，但是它们都处于一个范围，这个范围就叫导带。
可以看到，这个导带和价带中间是有间隔的，这个间隔就是禁带。禁带宽度的大小实际上是反映了价电子被束缚强弱程度的一个物理量。
禁带宽度越大，价电子必须获得比较高的能量，才能从化合键里面出来成为自由电子。所以禁带宽度越大，能够因为分子热运动成为自由电子的数量越少，导电性能越差。
等等，扯了半天这个有什么用？没发现禁带宽度大有什么用？
别急，才到问题的一半，汗。。。
在这之前，我们来复习一下PN结，因为做晶体管必然少不了PN结。
我们知道，PN结反偏是有漏电流的，这个漏电流是由少子的扩散形成的，虽然很少，但是会有。
也就是说，会有电子从中间的内建电场区经过。并且，电子会在这个区域被加速。
如果电压足够大，场强足够高，那么电子会被加速到较高的能量与原子相撞，原本在化学键里的电子会被撞出来成为自由电子。这个新产生的自由电子又受到电场力加速，去撞击其它的原子产生新的自由电子。
这样“一生二，二生四，子子孙孙无穷尽也”，大量的自由电子产生，电流急剧增大，这也就是“雪崩击穿”。
如果说禁带宽度比较大，价电子被束缚的比较紧，那么就不容易被撞出来了。
所以呢，禁带宽度大，能抗住的场强也就越高，耐压也就越高。同等耐压的器件，PN结就可以做得更薄，器件也能更小，又会带来寄生电容小的好处，器件也就能在更高的频率工作。
当温度上升，电子更容易获得能量。当温度上升到一定程度的时候，会有很多化学键里面的电子获得足够的能量变成自由电子，这样就破坏了半导体的特性。
试想一下，温度上升，自己产生的载流子比掺杂产生的载流子数量还多，那掺杂也就失去了意义，晶体管的功能也就失效了。
禁带宽度越大，需要升到更高的温度才能使化学键里面的电子变成自由电子，也就是说能工作在更高的温度。
硅的禁带宽度是1.12eV，而碳化硅是3.26eV。所以碳化硅器件比硅器件更耐温，可以到200℃，而硅只能到150℃，传闻金刚石可以工作在500℃。
第三代半导体的特点就是禁带宽度大，所以主要应用于高温，大功率器件场合。
电子/空穴迁移率
电子迁移率，指的是电子在电场力作用下运动快慢的物理量。
这个不好理解，我们可以这么看。
电子浓度相同的两种半导体材料，在两端施加相同的电压，那个迁移率更大的半导体材料，它里面的电子运动速度越快，单位时间通过的电子数不就越多吗？也就是说，电流越大。
这就说明了电子迁移率越高的半导体材料，电阻率越低，通过相同的电流，损耗越小。
空穴迁移率与电子迁移率一样，空穴迁移率越高，损耗越小。但是一般说来，电子的迁移率是要比空穴要高，因为空穴是电子的空位，空穴的运动，本质上是电子从一个空穴移动到另外一个空穴。
从上表可以看到，硅材料的电子迁移率要比空穴迁移率高几倍，这也是为什么NMOS管比PMOS管用得多的主要原因。
NMOS管在导通时，形成的是N型导电沟道，也就是说用来导电的是电子。而PMOS管导通，形成的是P型导电沟道，用来导电的是空穴。因为电子比空穴的迁移率要高，所以，同体积大小，同掺杂的情况下，NMOS管的损耗要比PMOS管小不少。
除了功耗之外，电子/空穴迁移率还影响什么呢？器件的速度
这是NMOS管的截止频率（输入/输出=1时的频率）
从最终的结果可以看到，截止频率与电子迁移率成正比。也就是说，电子迁移率越高，做出的NMOS管可以工作在更高的频率。
这个推导过程挺复杂的，我就不列了。那么有没有通俗的理解呢？
我的想法是这样的，仅供参考。
NMOS管的工作原理，是通过控制导电沟道，以此来控制源漏电流。在栅极加上正电压Vgs，衬底的电子会被带正电的栅极吸引，电子充斥在源端和漏端之间，形成了导电沟道，两边就可以通了。
当Vgs电压以高频率变化的时候，形成的导电沟道的厚薄也会变化。这个导电沟道的变化是通过电子的移动来形成的，电子移动速度越快（电子迁移率越高），那么导电沟道就能更快的响应Vgs的变化。所以说，电子迁移率越高，器件的工作频率越高。
同样的，PMOS管的工作速度，应该与空穴迁移率的大小正相关。
总的来说，电子迁移率越高，晶体管的功耗越小，速度越快。
从表中看出，二代半导体GaAs的电子迁移率是8500，InP的电子迁移率是4600，都是比Si的1350大很多。所以二代半导体的特点就是用在高频，大功率场合。
饱和电子漂移速率
在电场比较低的时候，整体电子的漂移速度与电场大小成正比。当电场大到一定值，电子整体的漂移速度不会再增加，达到饱和，这个速度就叫电子的饱和漂移速率。
这个参数像是决定了电子漂移速率的上限。
具体影响晶体管的什么性能，我也是不清楚。倒是多了个疑问。。。？
除此之外，还有一个问题。。。
欢迎大神们留言区答疑解惑！
结尾
以上就是我最近学习到的，结合自己的理解，分享给大家。没法保证我的理解都对，如有错漏，底下留言区交流，感谢!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a940cb66e94fbd27d046da6d52f1f0/" rel="bookmark">
			php.ini 只读,disabled by the php.ini setting phar.readonly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,最近看了一下phar模块，就是php自己的打包打包结果和java的jar类似
但是我就简单执行一行 new Phar('my-demo.phar');
报错啦:
报错信息：Uncaught exception 'UnexpectedValueException' with message 'creating archive "my-demo.phar" disabled by the php.ini setting phar.readonly' in
原来要把php.ini中phar.readonly 设置0
我就想我用 $r = ini_set("phar.readonly", 0);
不就行啦 可是返回结果为false
我就纳闷啦就php官网看看 varname不是所有有效的选项都能够用 ini_set() 来改变的。 这里有个有效选项的清单附录。
哦，原来 ini_set能设置不是所有的php.ini
看来只能再php.ini中加啦 [Phar]; http://php.net/phar.readonlyphar.readonly = Off
问题解决啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdbe158372c9eba0b16afa7a0f918216/" rel="bookmark">
			设置 Matlab的colorbar的宽度与位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab的colorbar默认宽度太宽，同时设置colorbar与图像的宽度。
设置如下：
c = colorbar;
ax = gca;
axpos = ax.Position;
c.Position(3) = 0.3*c.Position(3); % 改变系数0.3（设置合适的宽度） ax.Position = axpos;
ax.Position(3) = 0.78; %控制坐标轴的位置，以及长宽比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f5a8c3697abeba3899056bda4f66bb/" rel="bookmark">
			instanceof运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义
instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
语法
object instanceof constructor instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。
简单来说
既然是运算符，是不是就有比较的作用，比如大于、小于、等于。
没错instanceof也可以这样来理解，instance运算符前的某个实例对象，是否和instance后的某个构造函数相等。
简单代码分析
//定义构造函数Car function Car(make, model, year) { this.make = make; this.model = model; this.year = year; } //定义构造函数Bike function Bike(make, model, year) { this.make = make; this.model = model; this.year = year; } //Car的prototype存在与参数auto的原型链上 const auto = new Car('Honda', 'Accord', 1998); // output: true console.log(auto instanceof Car); // output: false console.log(auto instanceof Bike); 项目中的应用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45f5a8c3697abeba3899056bda4f66bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fddcc07bca37b0724265932d4524991b/" rel="bookmark">
			面试官：大文件上传如何做断点续传？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、是什么 不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂
文件上传简单，文件变大就复杂
上传大文件时，以下几个变量会影响我们的用户体验
服务器处理数据的能力
请求超时
网络波动
上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等
为了解决上述问题，我们需要对大文件上传单独处理
这里涉及到分片上传及断点续传两个概念
分片上传 分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传
如下图
上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件
大致流程如下：
将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；
初始化一个分片上传任务，返回本次分片上传唯一标识；
按照一定的策略（串行或并行）发送各个分片数据块；
发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件
断点续传 断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分
每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度
一般实现方式有两种：
服务器端返回，告知从哪开始
浏览器端自行处理
上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可
如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可
二、实现思路 整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕
下面的内容都是伪代码
读取文件内容：
const input = document.querySelector('input'); input.addEventListener('change', function() { var file = this.files[0]; }); 可以使用md5实现文件的唯一性
const md5code = md5(file); 然后开始对文件进行分割
var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.addEventListener("load", function(e) { //每10M切割一段,这里只做一个切割演示，实际切割需要循环切割， var slice = e.target.result.slice(0, 10*1024*1024); }); h5上传一个（一片）
const formdata = new FormData(); formdata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fddcc07bca37b0724265932d4524991b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04832097f435b68cbdef200639f90de3/" rel="bookmark">
			Linux系统基础安装和基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、按系列罗列Linux的发行版，并描述不同发行版之间的联系与区别。1.Linux的发行版主要分类Debianslackwaveredhat其他发行版 2.各发行版之间的联系3.各发行版之间的区别 二、安装Centos7.6操作系统，创建一个自己名字的用户名，并可以正常登录，将主要步骤截图。三、配置环境变量，实现执行history的时候可以看到执行命令的时间四、总结Linux哲学思想。五、总结Linux常用命令使用格式，并用实例说明。例如echo、screen、date、ifconfig、export等命令 一、按系列罗列Linux的发行版，并描述不同发行版之间的联系与区别。 1.Linux的发行版主要分类 Debian 1、Ubuntu 针对桌面和服务器
2、knopix 以安全著称
3、mint 桌面
slackwave 1、S.u.S.E 也是针对于桌面和服务器
2、 SLES-SuSE Linux Enterprise 服务器
3、OpenSuSE 桌面
redhat 1、RHEL-RedHat Enterprise Linux redhat公司发布的linux操作系统，每18个月发布一次
2、CentOS-Community ENTerprise 基于redhat提供的可自由使用源代码的linux版本，相当于RHEL的山寨版本
3、Fedora redhat测试版本，每6个月发行一次
其他发行版 1、Gentoo 极致性能，下载源代码在本机上直接编译软件
2、ArchLinux 轻量简介，遵循K.I.S.S 原则
2.各发行版之间的联系 1、所有的发行版都使用linux内核;
2、所有的linux发行版都需要遵循GNU的GPL协定；
3、所有的发行版都有自己的版本号，版本格式约定基本一样，主版本号.次版本号.发行号或修正号。
3.各发行版之间的区别 1、只有debian以社区的方式运作;
2、各个发行版的本质区别，在于集成了不同版本的内核、库、程序的组合；
3、不同发行商发行版之间无法有效进行版本的对比；
4、不同发行版几乎采用了不同的包管理器
(a). Debian:包管理器dpkg(deb格式),apt-get
(b). RedHat:包管理器rpm，前端包管理器叫yum
©. S.U.S.E:包管理器rpm，zypper
二、安装Centos7.6操作系统，创建一个自己名字的用户名，并可以正常登录，将主要步骤截图。 1.选择Install CentOS 7开始安装系统
设置安装语言和键盘为English
3.设置时区 亚洲上海
4、选择桌面安装GNOME Desktop
5、配置分区，设置文件类型XFS，分区方案为LVM
6、开始安装，创建普通用户wangmingwang并设置密码，设置root密码
7、使用wangmingwang账号成功登入系统
三、配置环境变量，实现执行history的时候可以看到执行命令的时间 执行history显示执行时间 vim ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04832097f435b68cbdef200639f90de3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1694bc26e68da528e12f63c7d6d29d8/" rel="bookmark">
			Linux运维小白的第一篇博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 选择马哥教育培训的理由短期个人成长学习计划 选择马哥教育培训的理由 之前工作太忙 没时间学习网课 而且知识体系不完整 比较凌乱 基础不稳 所以辞职静下心来学习六个月 争取六个月后可以找到一份符合自己期望的岗位工作
短期个人成长学习计划 1. 每天上课之前预习一遍当天上课视频
2. 前期主要针对shell脚本内容作为主要学习
3. 上完课当天晚上利用自习时间对当天上课的内容进行复习总结
4. 每天写一篇总结笔记 第二天 针对前天上课的总结笔记进行复习和实验操作***
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d307aefe0f27d12be5162bee5bd4fd/" rel="bookmark">
			【点云学习】pcl中PointCloud和PointCloud::Ptr的复制与函数传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文用于记录在使用PointCloud和PointCloud::Ptr时，等号复制、函数传参以及copyPointCloud复制，这几种方法复制后，旧的变量修改是否会影响所复制的变量。仅用于记录，不保证准确。【转载请注明出处】
1. 函数调用 测试了四种函数参数，分别是Ptr类型，PointCloud类型，PointCloud的引用，以及const引用：
void func_ptr(MyPointCloud::Ptr pc){ pc-&gt;resize(0); } void func_pointcloud(MyPointCloud pc){ pc.resize(0); } void func_ref(MyPointCloud&amp; pc){ pc.resize(10); } void func_pointcloud_ref(const MyPointCloud&amp; pc){ // pc.resize(0); // Error! cannot change size. } 测试方法和结果如下：
MyPointCloud::Ptr pc (new MyPointCloud()), pc2(new MyPointCloud()); MyPointCloud pc3, pc4; cout&lt;&lt;"================ Function test ================" &lt;&lt;endl; string filename = "mesh.pcd"; pcl::io::loadPCDFile&lt;MyPoint&gt;(filename, *pc); cout &lt;&lt; "------- Test 1. Using Ptr" &lt;&lt; endl; func_ptr(pc); cout &lt;&lt; "after: " &lt;&lt; (*pc).size() &lt;&lt; endl;	// 被修改了，为0 pcl::io::loadPCDFile&lt;MyPoint&gt;(filename, *pc); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82d307aefe0f27d12be5162bee5bd4fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c2290f4ef8446db66a68bc3b8d8b7e/" rel="bookmark">
			Visio中输入特殊符号和带下标的符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Visio中需要输入一些特殊符号或者带（上）下表的符号
1.设置上下标的时候，选中称为下标的文字，然后按对应的快捷键。
快捷键：ctrl+shift+"="（上标）ctrl+"="（下标）
2.当在Visio中需要输入一些特殊符号，打不出或不好找，直接复制下方的特殊符号进行粘贴。
⊥ ∥ ∠ ⌒ ⊙ ≡ ≌ △
∝ ∧ ∨ ～ ∫ ≠ ≤ ≥ ≈ ∞ ∶
＋－（×或·）（÷或／），∪，（∩），（√），积分（∫），曲线积分（∮）∪ ∩ ∈
∑ π |a| ⊥ ∽ △ ∠ ∩ ∪ ≠ ≡ ± ≥ ≤ ∈ ←
↑ → ↓ ↖ ↗ ↘ ↙ ∥ ∧ ∨ §
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩
Γ Δ Θ Λ Ξ Ο Π Σ Φ Χ Ψ Ω
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25c2290f4ef8446db66a68bc3b8d8b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64eab15b608948ff5be8cd5ddaad8f52/" rel="bookmark">
			再也不怕面试官问const关键字了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const关键字 const即constan的缩写，即不变的，被const修饰之后，相当于程序员告诉编译器：这个值是不变的，你处理的时候注意着点儿。
const可以修饰内置类型变量、自定义的类对象、类的成员函数、函数的返回值、函数的参数。
const修饰普通变量 const int a = 8; int b = a; //Correct a = 9; //Fault 编译器会把a认定为常量，其值不可被改变，所以对它赋值是错误的。
const修饰指针变量 const修饰指针变量有三种情况：
const修饰指针指向的内容，即指针所指地址中的内容不可变。const修饰指针本身，即指针所指向的地址不可变。const同时修饰指针和指针指向的内容，即二者皆不可变。 const int *p = 8; 由内向外看，*表示p是一个指针；const int表示p指针指向一个int型常量，综合起来就是p是一个常量指针。即p指针指向的这个地址存的是个8，这个值不能变，但是p可以指向其他的地址。
int a = 8; int* const p = &amp;a; 由内而外看，const表示p是一个常量，这已经说明它自身的值是不变的；int*表示p是一个指向int型变量的指针；所以，综合起来，p是一个指向int型变量的指针常量。即p指向的地址是不可变的，但这段地址存放的内容是可以变的。
int a = 8; const int* const p = &amp;a; 依旧由内而外看，const表示p是一个常量；const int*表示p是一个指向int型常量的指针；综合起来，p是一个指向int型常量的指针常量。即p指向的地址以及它指向的地址中存放的内容均为不可变的。
总结：*左边的const表示内容不变；*右边的const表示地址不变。
常量指针：指向常量的指针，即其指向的地址中的内容不变。
指针常量：指针本身是常量，即其指向地址不变。
const修饰函数参数 const修饰函数参数也分三种情况：
对于值传递的函数，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。
include &lt;iostream&gt; void ValueTransfer(const int a){ ++a; std::cout &lt;&lt; a &lt;&lt; std::endl; } int main(){ ValueTransfer(8); return 0; } 上边这段程序用g++编译时报错：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64eab15b608948ff5be8cd5ddaad8f52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9685d39b7952bc609a8c9cd8ec2d1e81/" rel="bookmark">
			卷积神经网络（CNN）超详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转自：https://blog.csdn.net/jiaoyangwm/article/details/80011656
文章目录 1、卷积神经网络的概念2、 发展过程3、如何利用CNN实现图像识别的任务4、CNN的特征5、CNN的求解6、卷积神经网络注意事项7、CNN发展综合介绍8、LeNet-5结构分析9、AlexNet10、ZFNet 10.1 意义10.2 实现方法10.3 训练细节10.4 卷积网络可视化10.6 总结 11、VGGNet 11.1 结构11.2 网络特点：11.3 分类框架： 12、GoogLeNet 12.1 GoogLeNet Inception V1——22层12.2 GoogLeNet12.3 GoogleNet Inception V212.4 GoogLeNet Inception V3 12.4.1 简介12.4.2 一般情况的设计准则12.4.3 利用大尺度滤波器进行图像的卷积 13、ResNet 13.1 ResNet的提出13.2 ResNet的意义13.3 ResNet结构13.4 ResNet50和ResNet10113.5 基于ResNet101的Faster RCNN 14、区域 CNN：R-CNN(2013年)、Fast R-CNN(2015年)、Faster R-CNN(2015年)15、生成式对抗网络16、深度学习在计算机视觉上的应用17、深度有监督学习在计算机视觉领域的进展 17.1 图像分类17.2 图像检测（Image Dection）17.4 图像标注–看图说话（Image Captioning） 18、强化学习（Reinforcement Learning） 1、卷积神经网络的概念 计算机视觉和 CNN 发展十一座里程碑
上世纪60年代，Hubel等人通过对猫视觉皮层细胞的研究，提出了感受野这个概念，到80年代，Fukushima在感受野概念的基础之上提出了神经认知机的概念，可以看作是卷积神经网络的第一个实现网络，神经认知机将一个视觉模式分解成许多子模式（特征），然后进入分层递阶式相连的特征平面进行处理，它试图将视觉系统模型化，使其能够在即使物体有位移或轻微变形的时候，也能完成识别。
卷积神经网络是多层感知机（MLP）的变种，由生物学家休博尔和维瑟尔在早期关于猫视觉皮层的研究发展而来，视觉皮层的细胞存在一个复杂的构造，这些细胞对视觉输入空间的子区域非常敏感，称之为感受野。
CNN由纽约大学的Yann Lecun于1998年提出，其本质是一个多层感知机，成功的原因在于其所采用的局部连接和权值共享的方式：
一方面减少了权值的数量使得网络易于优化
另一方面降低了模型的复杂度，也就是减小了过拟合的风险
该优点在网络的输入是图像时表现的更为明显，使得图像可以直接作为网络的输入，避免了传统识别算法中复杂的特征提取和数据重建的过程，在二维图像的处理过程中有很大的优势，如网络能够自行抽取图像的特征包括颜色、纹理、形状及图像的拓扑结构，在处理二维图像的问题上，特别是识别位移、缩放及其他形式扭曲不变性的应用上具有良好的鲁棒性和运算效率等。
名称特点LeNet5没啥特点-不过是第一个CNN应该要知道AlexNet引入了ReLU和dropout，引入数据增强、池化相互之间有覆盖，三个卷积一个最大池化+三个全连接层VGGNet采用11和33的卷积核以及2*2的最大池化使得层数变得更深。常用VGGNet-16和VGGNet19Google Inception Net这个在控制了计算量和参数量的同时，获得了比较好的分类性能，和上面相比有几个大的改进：1、去除了最后的全连接层，而是用一个全局的平均池化来取代它； 2、引入Inception Module，这是一个4个分支结合的结构。所有的分支都用到了11的卷积，这是因为11性价比很高，可以用很少的参数达到非线性和特征变换。3、Inception V2第二版将所有的55变成2个33，而且提出来著名的Batch Normalization；4、Inception V3第三版就更变态了，把较大的二维卷积拆成了两个较小的一维卷积，加速运算、减少过拟合，同时还更改了Inception Module的结构。微软ResNet残差神经网络(Residual Neural Network)1、引入高速公路结构，可以让神经网络变得非常深2、ResNet第二个版本将ReLU激活函数变成y=x的线性函数 2、 发展过程 1986年Rumelhart等人提出了人工神经网络的反向传播算法，掀起了神经网络在机器学习中的热潮，神经网络中存在大量的参数，存在容易发生过拟合、训练时间长的缺点，但是对比Boosting、Logistic回归、SVM等基于统计学习理论的方法（也可以看做具有一层隐层节点或不含隐层节点的学习模型，被称为浅层模型）来说，具有较大的优越性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9685d39b7952bc609a8c9cd8ec2d1e81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b1bf99704f6ee9489a043c410e377d0/" rel="bookmark">
			使用KEPServerv6进行OPC_UA的服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. KEPServerv6软件的下载 链接：https://pan.baidu.com/s/1ZZg2qCWEPQNcjAWN4d15fg 提取码：oo92 2.KEPServerv6软件安装 1.解压
2.单击安装，按提示安装完即可，中间记住所设置的密码即可。
3.安装完成后，出现下图(windows 10系统)
4.点击KEPServerEX 6 Administration，配置服务器用户
5.弹出如下窗口，输入自己的用户名和密码即可
6.成功后进入配置界面如下
7.双击红色线部分
8.弹出如下窗口，按所示设置即可，如果自己要加密则可以选择加密
9.上述操作完成，如下点击设置
10.添加OPC_UA服务器用户，我的是my_opc_ua，设置密码后，点击确定和应用
11.选择KEPServerEX 6 Configuration进入配置界面
12.右击项目点击弹出的属性如下，按图示设置OPC_UA的匿名链接
13.按上面设置完毕，则允许匿名登陆和用户名密码登录的OPC_UA服务器搭建完毕。
有疑问的可以加我微信聊X241602。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69980310f73ca1e411fa4a68bd24fc98/" rel="bookmark">
			数据结构：树基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一章 树1.1、树的定义1.2、树的术语 第二章 二叉树2.1、二叉树的定义2.2、二叉树的术语2.3、二叉树的性质 第三章 二叉查找树3.1、BST的定义3.2、BST的结构3.3、BST的添加3.4、BST的获取3.4.1、获取指定值3.4.2、获取最小键3.4.3、获取最大键3.4.4、获取树深度 3.5、BST的删除3.5.1、删除最小结点3.5.2、删除最大结点3.5.3、删除指定结点 3.6、BST的遍历3.6.1、前序遍历3.6.2、中序遍历3.6.3、后序遍历3.6.4、层序遍历 3.7、BST的问题 第四章 红黑树4.1、2-3-4树的定义4.2、2-3-4树的插入4.3、2-3-4树转RBT4.4、RBT的定义4.5、RBT的性质4.6、RBT的结构4.7、RBT的操作4.7.1、左旋操作4.7.2、右旋操作4.7.3、变色操作 4.8、RBT的添加4.8.1、添加操作4.8.2、如何修正4.8.3、修正操作4.8.4、添加测试 4.9、RBT的获取4.9.1、获取指定结点4.9.2、获取最小结点4.9.3、获取最大结点4.9.4、获取前驱结点4.9.5、获取后继结点 4.10、RBT的删除4.10.1、删除操作4.10.2、如何修正4.10.3、修正操作4.10.4、删除测试 第五章 AVL树5.1、AVL树的定义5.2、AVL树的性质5.3、AVL树的结构5.4、AVL树的操作5.4.1、左旋操作（RR）5.4.2、右旋操作（LL）5.4.3、左右双旋（LR）5.4.4、右左双旋（RL） 5.5、AVL树的添加5.5.1、添加操作5.5.2、如何修正5.5.3、修正操作5.5.4、添加测试 5.6、AVL树的获取5.6.1、获取指定结点5.6.2、获取最小结点5.6.3、获取最大结点5.6.4、获取前驱结点5.6.5、获取后继结点 5.7、AVL树的删除5.7.1、删除操作5.7.2、如何删除5.7.3、修正操作5.7.4、删除测试 项目地址：https://gitee.com/caochenlei/data-structures
第一章 树 1.1、树的定义 树（Tree）是一种数据结构，他是由n(n&gt;=1)个有限结点组成一个具有层次关系的集合。
把他叫做“树”是因为他看起来像一棵倒挂的树，也就是说他是根朝上，而叶朝下的。
他具有以下的特点：
每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树。 1.2、树的术语 度数（Degree）： 每个结点所拥有子树的个数。结点B的度数为2，结点C的度数为1，结点D的度数为3，结点K、L、F、G、M、I、J等的度数为0。
层数（Level）： 树的层数。假设树根A为第一层，结点B、C、D等所在层数为第二层，然后依次向下累加。
高度（Height）： 树的最大层数。 上图树的高度为4。
终端结点（Terminal Nodes）： 度数为零的结点就是树叶（叶子结点）也叫做终端结点。结点K、L、F、G、M、I、J等都是终端结点。
非终端结点（Nonterminal Nodes）： 终端结点以外的所有结点都是非终端结点。结点A、B、C、D、E、H等都是非终端结点。
祖先结点（Ancestor Nodes）： 祖先结点是指从树根到该结点路径上所包含的结点。结点B就是结点K的祖先结点之一。
子孙结点（Descendent Nodes）： 子孙结点是指该结点往下追溯子树中的任意一个结点。结点K、L就是结点B的子孙结点。
父亲结点（Parent Nodes）： 每个结点所指向的上一层结点就是父结点。结点B的父结点就是A结点。
儿子结点（Children Nodes）： 每个结点所指向的下一层结点就是子结点。结点B、C、D都是结点A的子结点。
兄弟结点（Siblings Nodes）： 有共同父结点的结点为兄弟结点。结点B、C、D的父结点都是A结点，因此，他们三个结点就是兄弟结点。
叔叔结点（Uncle Nodes）： 父亲结点的兄弟结点就是叔叔结点。结点K的叔叔结点就是结点F。
同代结点（Generation Nodes）： 在同一棵树中具有相同层数的结点。结点E、F的层数相同，因此，他们两个结点就是同代结点。
森林（Forest）： 0个或多个不相交的树组成。对森林加上一个根，森林即成为树。删去根，树即成为森林。
第二章 二叉树 2.1、二叉树的定义 二叉树（Binary Tree）就是度不超过2的树，也就是每个结点最多有两个子结点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69980310f73ca1e411fa4a68bd24fc98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c8a40a52193b7433d3e9f58d07d78a/" rel="bookmark">
			解决代理服务关闭后，无法联网的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		退出代理后无法联网 问题描述：很多小伙伴在使用代理结束之后，退出代理软件无法联网。
解决方法：
（1）打开ie浏览器；
（2）选择设置；
（3）选择“internet”选项；
（4）“连接”–“局域网设置”；
（5）取消勾选，保存退出；
转载请注明：Daniel的博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1f3704f9921da5971f0f30afbbba74/" rel="bookmark">
			vue  生成随机颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		getColor() {
var str = “#”;
//一个十六进制的值的数组
var arr = [“0”,“1”,“2”,“3”,“4”,“5”,“6”,“7”,“8”,“9”,“a”,“b”,“c”,“d”,“e”,“f”];
for (var i=0;i&lt;6;i++){
var num = parseInt(Math.random()*16); //随机产生0-15之间的一个数
str += arr[num]; //产生的每个随机数都是一个索引,根据索引找到数组中对应的值,拼接到一起
}
console.log(str)
return str;
},
this.color = this.getColor()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c60dc47d96e4a8a1a15a36bf103573/" rel="bookmark">
			基于python可视化的拉勾网招聘岗位分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于python可视化的拉勾网招聘岗位分析 论文第一作者，原创，侵权必究
import requests import pandas as pd import numpy as np import matplotlib.pyplot as plt import xlwt def base(jos, page): urls='https://www.lagou.com/jobs/list_python?isSchoolJob=1' url='https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false&amp;isSchoolJob=1' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36', 'Referer': 'https://www.lagou.com/jobs/list_python?labelWords=sug&amp;fromSearch=true&amp;suginput=p', 'Accept': 'application/json, text/javascript, */*; q=0.01' } url_info(url,urls,headers,jos,page) return def url_info(url,urls,headers,jos,page): info_list=[] for i in range(1,page+1): data = { 'first': 'false', 'kd': jos, 'pn': i } s=requests.session() s.get(urls,headers=headers,timeout=2) cookie=s.cookies result=s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c60dc47d96e4a8a1a15a36bf103573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bba5c07b3feaa78ea25b2b5fd2af795/" rel="bookmark">
			线性代数matlab的心得体会,线性代数的学习心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习是如同人生一样需要一步一个台阶的走向高处的，小学的学习范围只是自然数，初中便扩充到实数范围，高中又进一步扩充到复数单位。小学初中视觉是二维平面的，高中则进化成三维立体的。进入大学线性代数则为我们构建一个多维的，抽象的世界。我们在学习线性代数的过程中不断得扩大自己的眼界。
如同任何知识一样，都是从最基础的一点，一点点的扩充，从已知向未知发展的，所以老师从解多元一次方程组开始引进行列式，这便是从已知开始将只是往未知方面发展。老实说，刚开始真心觉得用行列式及克拉默法则去解三元一次方程组太过繁杂。用中学已知的消元法解起来既熟练又快捷，但这只是一个引入，将矩阵行列式这个概念与我们已知的东西挂上钩，方便以后的学习，当碰到元的个数超过了人解的能力的话，纯人工消元就够麻烦。任何事物的发展都有其必然规律的，矩阵的引入本就是为了数学的发展的，为了更好的解决数学上的一些问题的。
线性代数，顾其自然有着代数学的根源，就像代数里ac=bc不能推及a=b一样，在线代里面AC=BC也不能推出A=B。老师在讲解这个问题也是从这个方面解释的，所以一下子将本来悬在空中的知识点一下子就落在了原有的基础上，让人恍然大悟。这样的例子有很多很多，又比如由矩阵推方程的解一样。在中学就知道，当有效方程的个数等于未知量个数时，方程组一定有解且唯一;方有效方程的个数多余未知量个数时一定是有矛盾的，一定无解;反之，有效方程的个数少于未知量个数时则一定有未知量不能确定，有无穷解。在线代里面，矩阵的秩就是有效方程的个数，矩阵的行线性变换其实就是高斯消元。故而可推r与n的关系就可知方程的解的问题，又可知基础解系的n-r的含义其实就是不确定的未知量的个数，假设了谢谢未知量便可推出其他的未知量。这是从已知推未知的学习方法，不仅能更快的学习学习新知识，更能巩固旧知识，将新旧知识紧紧关联起来，故而在理解学习过程中也是十分轻松的。
但线性代数之所以特立独行成一门课程是因为他不仅只是简单的代数升级版，更牵涉到几何学。几何学的一大特征就是形象。将矩阵几何化则其很多内容就更好理解了。
在第一章便引进了行列式与几何的运用举例，二阶行列式可求平面面积，三阶行列式则求空间体积。所以可以利用几何图形之间的关系来确定方程的解的问题。乃至学到后面又将矩阵向量化，将我们的思维推向了一个n维的空间，由n维向量组的线性相关问题，我们又可以从已知关联到新知识了。很显然，n维空间内至多有n个线性无关的向量组，就像每个维度一个坐标系一样(这又可以关联到n维向量组中正交向量个数了)，当向量的个数m大于维度n时，则其必然存在向量与其他向量相关，换而言之，该向量一定是可由这个空间的系来表示的，这种的例子在线性代数的学习中不胜枚举。
其实与其说是学习了线性代数这个课程，不如说是扩充了自己的思想，将已知的东西相互紧紧关联结合起来。在学习线代的过程中，不仅是将代数与几何的紧紧相扣，更是学习到了一种非常好的学习方法。正如化学中的定理一样“溶是绝对的，不溶是相对的”，在科学知识这方面，很多道理是互通的，需要你想办法将其串通起来。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/187/">«</a>
	<span class="pagination__item pagination__item--current">188/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/189/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>