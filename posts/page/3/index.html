<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c8b6e37f86a787744752be3eb610ad/" rel="bookmark">
			算法基础之合并果子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 合并果子 核心思想： 贪心
Huffman树(算法):
每次将两个最小的堆合并 然后不断向上合并
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; //用小根堆实现找最小堆 using namespace std; int main() { int n; cin&gt;&gt;n; priority_queue&lt;int ,vector&lt;int&gt; , greater&lt;int&gt;&gt; heap; for(int i=0;i&lt;n;i++) { int x; cin&gt;&gt;x; heap.push(x); } int res=0; while(heap.size()&gt;1) { int a = heap.top();heap.pop(); //取出最小的两个堆 int b = heap.top();heap.pop(); res += a+b; heap.push(a+b); } cout&lt;&lt;res&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbfaeb099cdd9fc60d3a54e140fbbd61/" rel="bookmark">
			群晖Docker部署HomeAssistant容器结合内网穿透远程控制家中智能设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载HomeAssistant镜像
二、内网穿透HomeAssistant，实现异地控制智能家居
三、使用固定域名访问HomeAssistant
前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。 点击跳转到网站
HomeAssistant是一个可以控制苹果、小米、MQTT等设备的智能家居平台。本文首先介绍如何使用群晖NAS的Docker套件来安装HomeAssistant平台，安装成功后，如何结合cpolar内网穿透工具实现公网访问。
基本条件：
有正版群晖或黑群辉，可以装docker。 一、下载HomeAssistant镜像 打开群晖 容器 管理 套件（较旧系统版本对应的套件为群辉Docker）
注册表 中搜 home-assistant ，右击下图中的 homeassistant/home-assistant 项目下载镜像。
FileStation进入 /docker文件夹 新建Homeassistant文件夹
等待下载完毕：
双击此映像并打开
输入随便什么名称，勾选自启动功能，下一步
存储空间设置: 选择/dokcer/homeassistant 这个刚才新建的路径
在 路径 中填入 /home，给读写权限
环境中添加 variable = TZ 和 value = Asia/Shanghai
网络 选择 host
检查上述修改事项，完成
可见 容器启动成功
此时，自行查找群晖局域网地址，后边加上:8123就是homeassistant局域网地址
http://X.X.X.X:8123
此处我建议使用群晖助手 查找群晖ip：
本地浏览器 输入 http://192.168.50.31:8123/，进入homeassistant初始化流程：
注册账户——选择家庭地区
成功进入，现在我们就能尽情安装插件，绑定智能家居设备啦！
二、内网穿透HomeAssistant，实现异地控制智能家居 想要在户外访问本地Docker容器部署的项目，就需要内网穿透软件，这里我们使用的是免费不限流量的cpolar，如何在群晖NAS安装cpolar请参考：
如何在群晖系统中安装cpolar（群晖7.X版） – cpolar 极点云
安装完毕后，打开cpolar套件，点击右下角 ：9200的局域网地址：
​ 登录进去后,点击左侧仪表盘的隧道管理——创建隧道，我们来创建一条用于映射HomeAssistant的局域网地址到公网的隧道。
隧道名称：可自定义协议：http本地地址：X.X.X.X:8123域名类型：随机域名（cpolar免费版）地区：选择China（cpolar免费版选择China，付费版可选择china vip） 点击创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbfaeb099cdd9fc60d3a54e140fbbd61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c463961f690c7c8e52d2871e58b3095/" rel="bookmark">
			krpano官网文档翻译-------krpano动作/脚本参考【krpano Actions / Scripting Reference】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🧑‍🎓 个人主页：《爱蹦跶的大A阿》
🔥当前正在更新专栏：《VUE》 、《JavaScript保姆级教程》、《krpano》
​ ​
✨ 前言 Krpano有一个小而简单的动态脚本语言。有了它，krpano可以通过多种方式进行定制。命令或函数在krpano中称为“action”。可以使用现有的操作，也可以定义新的操作。脚本语言是动态的，默认情况下是无类型的，只有一些预定义的变量是类型的，但这通常是不相关的，因为在脚本中所有类型转换都将自动完成。
关于本文档
本文档是关于全局krpano变量和对象，关于操作调用语法和所有预定义的krpano操作/函数。
文档的主题:
全局变量的引用动作/功能参考语法和用法表达式/函数数组 关于静态xml代码和对象属性的文档，请查看:
👉 krpano XML Reference
​
语法和用法 基本语法
krpano操作代码是命令列表。每个命令都需要以分号结束，除了最后一个命令，分号是可选的。命令之间的空白字符或换行符将被忽略。例子: command1; command2; command3; ... 命令可以是变量赋值: variable=expression; 或者一个动作调用: action(parameters); 变量赋值
语法 variable=expression; 通过变量赋值，可以创建新变量或更改现有变量的值。表达式可以是一个简单的值，也可以是另一个变量或更复杂的表达式。以下是变量赋值操作符: = -只设置/复制该值。+= -添加值。-= -减去该值。*= -将变量与给定值相乘。/= -将变量除以给定值。 例子: a = 1 + 2; // a will be 3 b = a + 3; // b will be 6 trace(b); // output '6' b *= 2; trace(b); // output '12' str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c463961f690c7c8e52d2871e58b3095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e3bb6319517b2390b0c3de468d722c0/" rel="bookmark">
			springboot整合mongodb批量修改和添加索引，与设置mongodb保存更新超时时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：创建字段索引 collection 是集合名称，keys 是一个包含一个或多个字段名，options是排序方向，1正序，-1倒叙 db.collection.createIndex(keys, options) #单字段 db.collection.createIndex(name: 1) #多字段 db.collection.createIndex{name: 1, age: -1} 2：mongodb批量修改 BulkOperations bulkOperations = mongoTemplate.bulkOps(BulkMode.UNORDERED, RealtimeEntity.class); updateList.forEach(realtimeEntity -&gt; { Query query = new Query(Criteria.where("pn").is(realtimeEntity.getPn())); Update update = new Update() .set("pnVal", realtimeEntity.getPnVal()) .set("tm", realtimeEntity.getTm()) .set("rm", realtimeEntity.getRm()); bulkOperations.updateOne(query, update); }); bulkOperations.execute(); 注意：必须创建索引这样更新的效率快 3：mongodb保存的时候最好设置一个保存超时时间，因为mongodb本身没有设置保存或者更新超时抛出异常 public void saveWithTimeout(Object objectToSave, String collectionName) { CompletableFuture&lt;Void&gt; completableFuture = new CompletableFuture&lt;&gt;(); mongoTemplate.insert(objectToSave, collectionName).addCallback( result -&gt; completableFuture.complete(null), ex -&gt; completableFuture.completeExceptionally(ex) ); try { completableFuture.get(10, TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e3bb6319517b2390b0c3de468d722c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38843a6406ff5f7f668f1e140177aae5/" rel="bookmark">
			Mac 安装Nginx教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Nginx官网 Nginx官网英文 1.在终端输入brew search nginx 命令检查nginx是否安装了 2. 安装命令：brew install nginx 3. 查看Nginx信息命令brew info nginx 4. 启动 nginx方式：在终端里输入 nginx 5.查看 nginx 是否启动成功 在浏览器中访问http://localhost:8080，打开的页面如下图表示启动成功
6.查看配置文件nginx.conf路径 方式一：在终端输入 open /usr/local/etc/nginx/
方式二：打开在访达 按住command + shift + G 快捷键 输入 /usr/local/etc/nginx
配置文件三大模块：
7.查看启动程序路径 方式一：在终端输入 open /usr/local/Cellar/nginx
方式二：打开在访达 按住command + shift + G 快捷键 输入 /usr/local/Cellar/nginx
/usr/local/Cellar/nginx/1.25.3/bin/nginx为启动命令
常用命令 查看 nginx 版本: nginx -v优雅关闭nginx：nginx -s quit关闭nginx：nginx -s stop重新加载nginx：nginx -s reload检查配置文件正确性：nginx -t查询nginx主进程号：ps -ef | grep nginx 参考文献 Mac 安装 NginxMac 安装和使用Nginx教程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249185ef86ff860f4ff601906f356a7b/" rel="bookmark">
			Python爬虫——简单网页抓取（实战案例）小白篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在着手写爬虫抓取网页之前，要先把其需要的知识线路理清楚。
首先：了解相关的Http协议知识；其次：熟悉Urllib、Requests库；再者：开发工具的掌握 PyCharm、Fiddler；最后：网页爬取案例； 下面就按这个路线逐一讲讲各部分的内容；
一、Http协议
HTTP协议是一个应用层面向对象协议，也叫超文本传输协议。
是基于TCP协议的可靠传输，采用客户端/服务器端模式，指定了客户端可能发送给服务器什么样的消息，以及服务端给出什么样的响应。
1）HTTP协议组成
HTTP协议请求由状态行、请求头和请求正文三部分组成；
请求端的HTTP报文叫做请求报文，响应端的叫做响应报文，通常，并不一定要有报文主体。
状态行：包括请求方式Method、资源路径URL、协议版本Version；请求头：包括一些访问的域名、用户代理、Cookie等信息；请求正文：就是HTTP请求的数据，允许为空字符串； 2）HTTP 请求方法
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。
以上是HTTP所有的方法，但常见的方法有以下：
3）HTTP的请求响应模型
HTTP协议永远都是客户端发起请求，服务器回送响应。
这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。
注意：HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。
4）HTTP的状态码
Http状态码能告诉我们当前请求响应的状态，通过状态码判断和分析服务器的运行状态，以便更好的进行下一步的操作。
5）工作流程
一次HTTP操作称为一个事务，其工作过程可分为四步：
首先客户机与服务器需要建立连接，只要单击某个超级链接，HTTP的工作开始。建立连接后，客户机发送一个请求给服务器；请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。服务器接到请求后，给予相应的响应信息；其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。
这些过程由HTTP自己完成，我们等待信息显示就可以了。
二、Urllib、Requests库
这两个库都建议新手能够熟练掌握，在Python爬虫中使用频率非常高。
下方也有分享安装教程资源，有需要的点击进群找群管理获取即可↓↓
&lt;Python学习交流群 安装教程资源获取&gt;
Urllib库
Urllib是Python中请求url连接的官方标准库，在Python2中主要为urllib和urllib2，在Python3中整合成了urllib。
1）主要包含以下4个模块
urllib.request：用于打开和阅读URLurllib.error：包含由引发的异常urllib.requesturllib.parse：用于解析URLurllib.robotparser：用于解析robot.txt文件 2）urllib.request.urlopen()
模块定义了有助于在复杂环境中打开URL（主要是HTTP）的函数和类-基本身份验证和摘要身份验证，重构定向，Cookie等。
语法结构
urllib.request.urlopen（url，data = None，[ timeout，] *，cafile = None，capath = None，cadefault = False，context = None） 语法详解
url：传入的对象可以是url也可以是一个request的对象；data：data必须是一个直接要发送搭服务器的其他数据的对象，如果没有data数据的话可以为None，也可以不写。timeout：以秒为单位制定用于组织链接尝试之类的操作超时； 3）urllib.openurl：返回对象的方法
# 设置一个url对象 url = "百度一下，你就知道" #发送请求，打开url up = urllib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249185ef86ff860f4ff601906f356a7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4c240569beef68db1b5213fcb88b50/" rel="bookmark">
			状态机（有限状态机（Finite State Machine, FSM）、推进自动机（Pushdown Automata）、并发状态机、分层状态机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 状态机（State Machine）定义与组成定义组成状态（States）事件（Events）转换（Transitions）初始状态（Initial State） 状态机的类型有限状态机（Finite State Machine, FSM）推进自动机（Pushdown Automata） 状态机的应用协议设计游戏开发硬件设计用户界面设计软件工程 如何实现一个状态机例子与代码展示 状态机的优缺点疑难问题与解决方案如何处理并发状态？如何处理复杂的条件逻辑？如何优化状态机的存储空间？ 状态机（State Machine） 状态机，也被称为有限状态机(Finite State Machine, FSM)，是一种用于模拟和表示系统行为的抽象计算模型。它由一组状态、一个初始状态、一组输入事件以及一组转换规则组成。系统可以在不同的状态之间进行转换，而每次转换都是由一个特定的事件触发。
定义与组成 定义 状态机是一个抽象概念，主要用来描述对象或系统的行为。在任何给定的时刻，状态机只能处于有限个状态中的一个。当某些条件满足或者某些事件发生时，状态机会从一个状态变为另一个状态，这种变化被称为状态转移。
组成 一个状态机主要由以下几部分构成：
状态（States） 描述了系统可能存在的所有情况。
事件（Events） 触发状态转换的动作或者条件。
转换（Transitions） 描述了系统从一个状态到另一个状态的变化过程。
初始状态（Initial State） 系统在开始时的状态。
状态机的类型 状态机主要有两种类型：
有限状态机（Finite State Machine, FSM） 这是最基本的状态机，它只能处于有限个状态中的一个。每当事件发生，状态机就会根据当前状态和事件类型进行状态转换。
推进自动机（Pushdown Automata） 这是一种更复杂的状态机，它可以使用一个堆栈来存储额外的信息。这种状态机可以用于解析某些类型的语法，例如编程语言的语法。
状态机的应用 状态机在计算机科学和工程中有着广泛的应用，例如：
协议设计 许多网络和通信协议都使用状态机来描述其工作流程。
游戏开发 在游戏开发中，状态机常用来描述角色的行为和状态转换。
硬件设计 硬件电路，如CPU，也可以看作是一个状态机。
用户界面设计 用户界面的交互逻辑也可以通过状态机来表示。
软件工程 在软件开发过程中，状态机被用来描述对象的生命周期或者工作流程。
如何实现一个状态机 状态机的实现方式主要有两种：
表驱动方法：使用二维数组或者哈希表来存储所有的状态和转换规则。这种方法的优点是代码简洁明了，易于理解和修改；缺点是可能会浪费一些空间，因为并非所有的状态组合都是有效的。
代码驱动方法：使用条件语句（如if-else或switch-case）来描述状态转换。这种方法的优点是更加灵活，可以处理复杂的逻辑；缺点是代码可能会变得冗长和复杂。
下面将通过例子与代码展示如何实现一个状态机。
例子与代码展示 为了说明如何实现一个状态机，这里将以一个简单的在线购物系统为例。在这个系统中，订单可能有以下三种状态：
已创建已支付已发货 事件包括：
支付发货 下面是一个使用Python语言和表驱动方法实现的状态机：
#!/usr/bin/env python3 # -*- coding: utf-8 -*- class Order: def __init__(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4c240569beef68db1b5213fcb88b50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f76b9fd368bddd0b3749c6fcec1021/" rel="bookmark">
			防抖节流的应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.防抖： 表单验证：当用户在输入框中输入内容时，可以使用防抖来延迟验证用户输入的内容，减少验证的频率。按钮点击：当用户频繁点击按钮时，可以使用防抖来确保只有最后一次点击生效，避免重复提交或触发不必要的操作。搜索框自动补全：当用户在搜索框中输入关键字时，可以使用防抖来延迟发送请求，减少请求的次数。 2.节流： 页面滚动：当用户滚动页面时，可以使用节流来控制触发事件的频率，减少滚动事件的处理次数，提高页面的性能。鼠标移动：当用户移动鼠标时，可以使用节流来控制触发事件的频率，减少事件的处理次数，提高页面的响应速度。懒加载：当页面需要加载大量图片或内容时，可以使用节流来延迟加载，减少网络请求的次数，提高页面加载速度。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd25dbed04b7e1159b14a5dbda3cba04/" rel="bookmark">
			案例094:基于微信小程序的图书馆自习室座位预约管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
管理员服务端功能模块
学生微信端功能模块
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着电子商务快速发展世界各地区,各个高校对图书馆也起来越重视.图书馆代表着一间学校或者地区的文化标志，因为图书馆丰富的图书资源能够带给我们重要的信息资源，图书馆管理系统是学校管理机制重要的一环，,面对这一世界性的新动向和新问题,图书馆如何适应新的时代和新的潮流,开展有效的信息服务工作,完成时代赋予的新使命?本文就这一问题谈谈几点粗浅的看法.扩大业务范围,更新服务内容.信息社会的到来已经向图书馆传统的服务方式提出了新的挑战;图书馆已经不是,也不可能是 传统观念的图书馆,而将成为社会公用信息，本系统包含了2个学生，即管理员和学生
管理员权限主要实现了管理员服务端；首页、个人中心、学生管理、座位信息管理、自习室分类管理、座位预约管理、学院分类管理、专业分类管理、留言板管理、系统管理，学生微信端；首页、座位信息、座位预约、我的等功能，基本上实现了整个图书馆自习室座位预约小程序信息管理的过程。本系统在一般图书馆自习室座位预约的基础上增加了最新信息的功能方便学生快速浏览，是一个高效的、动态的、相互友好的图书馆自习室座位预约小程序。
该系统里充分综合应用Mysql数据库、JAVA等相关知识。网页界面的构成，具备简单易懂、便捷等特征。设计过程中，第一，静态页面的制作需要应用语言，以及APP的美工，在这些方面均收获了较好的成绩。第二，针对微信开发者等技术动态编程以及数据库进行努力学习和大量实践，并运用到了APP的建设中。
系统展示 管理员服务端功能模块 管理员登录，管理员通过输入学生名，密码，角色等信息即可进行系统登录
首页，管理员登录进入图书馆自习室座位预约小程序可以查看首页、个人中心、学生管理、座位信息管理、自习室分类管理、座位预约管理、学院分类管理、专业分类管理、留言板管理、系统管理等内容
学生管理，管理员在学生信息页面通过查看学号、姓名、性别、年龄、学院、专业、手机、邮箱、照片等信息进行添加、修改、删除、查询操作
座位信息管理，管理员在座位信息页面可以查看座位编号、自习室、座位状态、图片、备注等信息，并可根据需要进行查询、详情、删除，修改等操作
座位预约管理，管理员在座位预约管理可以查看座位编号、自习室、座位状态、图片、学号、姓名、预约时间等信息，管理员进行审核、并可根据需要进行详情、修改、删除操作
留言板管理，管理员在留言板管理页面可以用户留言，管理员进行回复，并可根据需要进行详情、删除，修改等操作
学生微信端功能模块 学生注册通过注册窗口，进行在线填写自己的学号、密码、姓名、性别、年龄、学院、专业、手机、邮箱、姓名、性别、年龄、学院、专业、手机、邮箱等，信息编辑完成后核对信息无误后进行选择注册，系统核对学生所输入的学号信息是否准确，核对信息准确无误后系统进入到登陆操作界面。 登陆，学生登录通过填写学号、密码行页面，进入到图书馆自习室座位预约小程序主界面，进入到操作界面，进行相对应操作
首页，学生首页页面可以查看首页、座位信息、座位预约、我的等信息，进行提交操作
座位信息，学生进入座位信息页面可以查看座位编号、自习室、座位状态、图片、备注，可进行预约操作，点击预约查看座位编号、自习室、座位状态、图片、学号、姓名、预约时间进行提交，管理员审核后预约成功
我的，学生进入我的页面可以查看用户信息、座位信息、座位预约、留言板等信息 代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd25dbed04b7e1159b14a5dbda3cba04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b9ffa9e7da2594594ff5b59c30f40f/" rel="bookmark">
			案例093:基于微信小程序的南宁周边乡村游设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
微信端功能实现
服务端功能实现
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着我国经济迅速发展，人们对手机的需求越来越大，各种手机软件也都在被广泛应用，但是对于手机进行数据信息管理，对于手机的各种软件也是备受游客的喜爱，南宁周边乡村游被游客普遍使用，为方便游客能够可以随时进行南宁周边乡村游的数据信息管理，特开发了基于南宁周边乡村游的管理系统。
南宁周边乡村游的设计主要是对系统所要实现的功能进行详细考虑，确定所要实现的功能后进行界面的设计，在这中间还要考虑如何可以更好的将功能及页面进行很好的结合，方便游客可以很容易明了的找到自己所需要的信息，还有系统平台后期的可操作性，通过对信息内容的详细了解进行技术的开发。
南宁周边乡村游的开发利用现有的成熟技术参考，以源代码为模板，分析功能调整与南宁周边乡村游的实际需求相结合，讨论了基于南宁周边乡村游的使用。 系统展示 微信端功能实现 游客注册通过注册窗口，进行在线填写自己的账号、密码、姓名、年龄、手机、邮箱等，信息编辑完成后核对信息无误后进行选择注册，系统核对游客所输入的账号信息是否准确，核对信息准确无误后系统进入到操作界面。
游客登录通过账号、密码行页面，进入到南宁周边乡村游主界面，进入到操作界面，进行相对应操作
游客首页页面可以查看首页、景点信息、景点美食、特产信息、我的等信息，进行提交操作
游客进入景点信息页面可以查看景点名称、景点类型、景点图片、景点星级、景点地址、营业时间、注意事项、价格等信息，进行加入购物车、立即订购操作
游客进入景点美食页面可以查看美食名称、美食类型、美食图片、美食介绍、价格等信息，进行加入购物车、立即订购操作
游客进入景点攻略页面可以查看攻略标题、景点名称、出发城市、行程天数、行程距离、交通工具、行程路线、景点封面等信息，进行点我收藏操作
服务端功能实现 管理员通过南宁周边乡村游进行确认，管理员进入到南宁周边乡村游主界面，管理员进入到操作界面，通过登录窗口进行在线填写自己的用户名和密码、角色进行登录，登录成功后进入到系统操作界面进行相应信息的获取
管理员进入到界面，通过界面的任务大厅，登录成功后进入到系统可以进行查看首页、个人中心、游客管理、景点信息管理、景点美食管理、美食类型管理、景点攻略管理、特产信息管理、特产类型管理、留言板管理、系统管理、订单管理等功能模块，进行相对应操作
管理员点击景点信息管理进入页面可以查看景点名称、景点类型、景点图片、景点星级、景点地址、营业时间、注意事项、价格等信息，进行详情、修改、删除操作
管理员进入景点美食管理界面，通过界面的任务大厅，登录成功后进入到系统可以查看美食名称、美食类型、美食图片、美食介绍、价格等信息，进行相对应操作
管理员进入到景点攻略管理界面，通过界面的任务大厅，登录成功后进入到系统可以查看攻略标题、景点名称、出发城市、行程天数、行程距离、交通工具、行程路线、景点封面等信息，进行相对应操作 管理员进入到特产信息管理界面，通过界面的任务大厅，登录成功后进入到系统可以查看特产名称、特产类型、图片、生产日期、保质期、价格等信息，进行相对应操作
管理员进入到订单管理界面，通过界面的任务大厅，登录成功后进入到系统可以查看订单编号、商品名称、商品图片、购买数量、价格/积分、折扣价格、总价格/总积分、折扣总价格、支付类型、状态、地址等信息，进行相对应操作
轮播图；该页面为轮播图管理界面。管理员可以在此页面进行首页轮播图的管理，通过新建操作可在轮播图中加入新的图片，还可以对以上传的图片进行修改操作，以及图片的删除操作
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b9ffa9e7da2594594ff5b59c30f40f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f770eb7c2eba4860ccdd309877f5690/" rel="bookmark">
			案例092:基于微信小程序的二手闲置交易市场系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
微信端功能模块的实现
管理员功能模块的实现
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着计算机技术的成熟，互联网的建立，如今，PC平台上有许多关于二手闲置交易方面的应用程序，但由于使用时间和地点上的限制，用户在使用上存在着种种不方便，而开发一款基于微信小程序的二手闲置交易市场系统，能够有效地解决这个问题。
本基于微信小程序的二手闲置交易市场系统是针对二手闲置交易而开发，采用微信开发者工具进行微信端开发，使用MYSQL数据库进行系统数据的储存，系统满足用户通过微信客户端进行二手闲置交易的需求。本小程序是以微信为入口的，可以说是在自带接近10亿的流量人口。整个系统不仅操作简单、便捷，而且节约用户的时间及资源成本等，仅需通过一部手机和微信号即可满足用户们的需求。
论文首先阐述了基于微信小程序的二手闲置交易市场系统的开发背景，并对开发基于微信小程序的二手闲置交易市场系统所采用的相关技术进行了详细的介绍，然后对此应用软件进行了需求分析、设计，最后对系统进行测试、维护，保证系统的正常运行。
系统展示 微信端功能模块的实现 没有账号的用户可进行注册操作，注册时可选择注册类型进入对应角色的注册界面，注册后可进行登录系统
所有用户登录后均可进入首页查看首页信息 用户登录后可查看商品信息，并可根据条件快速查询所需商品，可选择商品进行查看详情操作，卖家登录后可管理商品信息，能够新增商品 卖家和用户登录后均可查看系统公告信息 用户可选择商品查看详情，并可进行咨询和购买 卖家登录后可发布商品信息
管理员功能模块的实现 管理员要想进入系统后台对系统进行管理操作，必须登录系统后台
管理员登录后可添加、修改和删除用户信息
管理员在卖家管理界面可查看所有卖家信息，对已有卖家信息可进行编辑和删除操作，同时也可添加卖家信息
管理员可管理商品信息，对已有商品信息可进行编辑和删除
管理员可进入商品购买管理界面查看所有购买信息
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f770eb7c2eba4860ccdd309877f5690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b45865de4ecebefeb27b592032903095/" rel="bookmark">
			ROS执行命令发现找不到python2.7解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ros链接的python是2.7的，如果链接到python3就会报错module找不到
第一步：执行：ls -n /usr/bin/python
发现python软链接到了python3.7
第二步删除软链接：sudo rm -rf /usr/bin/python
第三步：然后再重新建立到python2.7的软链接：
sudo ln -s /usr/bin/python2.7 /usr/bin/python
参考：https://blog.csdn.net/m0_46345373/article/details/110304764
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e721598a4d62a8edf5f70d8b1f587c0/" rel="bookmark">
			ERROR：SyntaxError: Non-ASCII character ‘\xc3‘ in file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错信息： SyntaxError: Non-ASCII character ‘\xc3’ in file /home/user/ROSpy-LeaderFollower/src/follow_/src/scripts/tb3_flw.py on line 46, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details
解决办法： python开头加
#!/usr/bin/env python2 #-*- coding:utf-8 -*- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f0a5be675baefc057854bdf81f6fea/" rel="bookmark">
			Python爬虫江西南昌二手房源数据可视化分析大屏全屏系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 博主介绍：黄菊华老师《Vue.js入门与商城开发实战》《微信小程序商城开发》图书作者，CSDN博客专家，在线教育专家，CSDN钻石讲师；专注大学生毕业设计教育和辅导。
所有项目都配有从入门到精通的基础知识视频课程，免费
项目配有对应开发文档、开题报告、任务书、PPT、论文模版等
项目都录了发布和功能操作演示视频；项目的界面和功能都可以定制，包安装运行！！！
如果需要联系我，可以在CSDN网站查询黄菊华老师
在文章末尾可以获取联系方式
研究背景和意义 Python江西南昌二手房源爬虫数据可视化分析大屏全屏系统的研究背景与意义如下：
研究背景：
江西南昌房地产市场的发展：南昌作为江西省的省会城市，近年来房地产市场不断壮大，二手房交易日益活跃。
数据驱动的决策趋势：在各行各业，利用大数据进行决策已经成为趋势。对于房地产市场，通过数据分析可以更准确地掌握市场动态，辅助投资者和购房者做出决策。
Python技术的广泛应用：Python作为一种编程语言，在数据科学、机器学习等领域得到了广泛应用。其强大的数据处理和可视化能力为房地产市场研究提供了新的方法。
研究意义：
市场分析与决策支持：通过Python爬虫技术获取江西南昌的二手房源数据，结合数据可视化分析，可以为投资者、购房者、中介机构等提供全面的市场分析，辅助决策制定。
市场透明与公平：通过公开的数据展示，可以增加市场的透明度，减少信息的不对称，促进市场的公平交易。
技术创新与推动：通过研究和应用Python爬虫数据可视化分析大屏全屏系统，可以推动相关领域的技术创新，为其他城市或地区的二手房市场研究提供技术参考。
政策效果评估与参考：政府部门可以通过该系统获取的数据和分析结果，对政策效果进行评估，为未来的政策制定提供参考。
总的来说，Python江西南昌二手房源爬虫数据可视化分析大屏全屏系统的研究将有助于提升江西南昌二手房市场的信息化水平，推动市场的健康、稳定和可持续发展。同时，也为Python技术和数据可视化在房地产领域的研究和应用提供有益的探索和实践。
国内外现状 Python江西南昌二手房源爬虫数据可视化分析大屏全屏系统的国内外研究现状如下：
国内研究现状：
在江西南昌，针对二手房源的数据分析和可视化研究正在逐渐兴起。一些国内的研究团队和房地产科技公司已经开始利用Python技术开发二手房源爬虫系统，以获取和分析江西南昌地区的二手房源数据。这些系统通常用于数据的抓取、清洗和存储，为后续的数据分析和可视化提供基础。
在数据可视化方面，国内的研究团队通常使用常见的可视化工具和库，如Matplotlib和Seaborn，来生成各类图表和图形，以展示二手房市场的关键指标和趋势。这些可视化结果通常通过大屏全屏系统进行展示，以提供更直观、清晰的数据呈现。
国外研究现状：
与国内相比，国外在Python爬虫数据可视化分析方面的研究更为深入和广泛。国外的研究团队在二手房源爬虫系统的开发和数据可视化方面积累了丰富的经验和技术。他们注重数据的实时性和准确性，并尝试运用先进的机器学习和深度学习技术对数据进行更深层次的分析和预测。
此外，国外的数据可视化工具和技术也更加多样化和成熟。他们不仅使用传统的图表和图形，还积极探索使用交互式可视化和虚拟现实等先进技术，以提升用户体验和数据理解的便捷性。
需要注意的是，尽管国外在相关技术和工具的研究上相对领先，但针对江西南昌地区的二手房市场研究仍然较少。因此，结合江西南昌地区的实际情况，开展Python江西南昌二手房源爬虫数据可视化分析大屏全屏系统的研究具有重要的现实意义和应用价值。
功能清单 我们这里以我们打算实现的系统内容，分析如下，数据来源链家
大屏全屏可视化展示：
二手房基础数据：房源总数多少套，小区总数多少个，房源平均面积，房源平均价格各个区域二手房均价销售数据（柱形图）各个区域房源平均面积（折线图）创新点，在区域地区，按各个区域显示房源数目各个区域的小区数量和房源数量，双柱形图显示各个面积户型占比分析：89方以下，90到149方，150-199方，200方以上最新房源数据，滚动显示最新10个房源信息 后台内容：
管理员登录、密码修改、退出系统展示所有房源数据，可以链接到原始地址区域数据列表：显示各区的销售数据，包含房源数，平均面积，平均价格等小区数据列表：显示各个小区所在区域，小区的房源数，小区房源的平均价格和面积等 界面效果图 后台功能 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f927026f78da6775fb1670b757aba8f/" rel="bookmark">
			基于vue.js在线考试刷题系统设计与实现(uni-app框架&#43;PHP后台) 研究背景和意义、国内外现状
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：黄菊华老师《Vue.js入门与商城开发实战》《微信小程序商城开发》图书作者，CSDN博客专家，在线教育专家，CSDN钻石讲师；专注大学生毕业设计教育和辅导。
所有项目都配有从入门到精通的基础知识视频课程，免费
项目配有对应开发文档、开题报告、任务书、PPT、论文模版等
项目都录了发布和功能操作演示视频；项目的界面和功能都可以定制，包安装运行！！！
如果需要联系我，可以在CSDN网站查询黄菊华老师
在文章末尾可以获取联系方式
一、研究背景和意义 研究背景 随着信息技术的发展和互联网应用的普及，线上教育逐渐成为教育领域的重要组成部分。在线考试刷题系统作为线上教育的重要工具之一，能够为学生提供便捷、高效的学习和测评平台。Vue.js作为一种流行的前端框架，结合uni-app的跨平台特性和PHP稳定的后端支持，为在线考试刷题系统的设计与实现提供了有力的技术支持。
研究意义 基于Vue.js、uni-app框架和PHP后台开发在线考试刷题系统，具有以下重要意义：
提高学习效率：系统可以为学生提供大量、多样化的题库资源，支持在线刷题、模拟考试等功能，帮助学生高效备考，提升学习效果。优化学习体验：通过友好的用户界面和交互设计，系统能够为学生提供更加便捷、舒适的学习体验，激发学生的学习兴趣和动力。促进教育公平：在线考试刷题系统打破了地域限制，使得不同地区、不同学校的学生都能够享受到优质的教育资源，促进了教育公平。推动教育信息化发展：该系统的成功实施将有助于推动教育信息化进程，提升教育行业的整体效率和创新水平。 二、国内外现状 国内现状 在国内，随着在线教育市场的快速发展和政策支持力度的加大，越来越多的企业和机构开始涉足在线考试刷题系统领域。目前，市场上已经存在一些知名的在线教育平台，如腾讯课堂、网易云课堂等，它们提供了丰富的题库资源和便捷的在线学习服务。然而，这些平台在用户体验、功能完善性、数据安全性等方面仍存在一定的提升空间。同时，随着市场竞争的加剧和用户需求的不断升级，现有的在线考试刷题系统仍需要不断进行技术创新和功能完善。
国外现状 在国外，尤其是欧美等发达国家，在线教育已经相当成熟和普及。一些知名的在线教育平台，如Coursera、edX等，不仅提供了丰富的在线课程资源，还通过引入人工智能技术、大数据分析等先进技术手段优化学习体验和教学效果。在考试刷题系统方面，国外一些先进的平台注重个性化推荐、智能错题本等功能的开发与应用，为学生提供更加智能化和个性化的学习服务。相比之下，国内在线考试刷题系统在技术创新和服务升级方面仍有较大的提升空间。
研究背景和意义: 随着互联网技术的发展，在线教育越来越受到人们的关注。考试是教育中的重要环节，考试刷题系统可以提供给学生进行自我测试和学习的机会，帮助学生提升学习成绩。基于vue.js的在线考试刷题系统在教育领域具有广阔的应用前景。
国内外现状: 在国内，随着高校的大规模招生和普及教育的推动，对于在线考试刷题系统的需求日益增加。目前，一些知名的在线教育平台如中国大学MOOC、网易云课堂等已经推出了在线考试刷题系统，为学生提供了大量的试题资源和考试模拟环境。然而，这些平台大多数只是提供了简单的刷题功能，还需要进一步优化和改进。
在国外，许多国际知名的在线教育平台如Coursera、edX等也提供了在线考试刷题系统，这些系统通常结合了一些互动式学习元素，为学生提供了更加丰富的学习体验。
总的来说，目前国内外对于基于vue.js的在线考试刷题系统的研究和实现还相对较少，存在着较大的发展空间和需求。开展相关研究和实践可以为教育行业的发展提供借鉴和推动作用，为学生提供更好的学习和测试平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/077c45d7e5f4de62521f3a77993282b3/" rel="bookmark">
			基于Python爬虫山东省岗位招聘信息数据可视化和岗位查询系统(Django框架) 研究背景和意义、国内外现状
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：黄菊华老师《Vue.js入门与商城开发实战》《微信小程序商城开发》图书作者，CSDN博客专家，在线教育专家，CSDN钻石讲师；专注大学生毕业设计教育和辅导。
所有项目都配有从入门到精通的基础知识视频课程，免费
项目配有对应开发文档、开题报告、任务书、PPT、论文模版等
项目都录了发布和功能操作演示视频；项目的界面和功能都可以定制，包安装运行！！！
如果需要联系我，可以在CSDN网站查询黄菊华老师
在文章末尾可以获取联系方式
一、研究背景和意义
研究背景：
随着互联网技术的迅猛发展和普及，网络招聘已成为企业寻找合适人才、求职者搜索心仪岗位的主要渠道。山东省作为我国东部沿海的重要经济省份，其企业数量众多、经济活跃，人才需求与流动均十分频繁。然而，目前山东省内的招聘信息分散于各大招聘网站和平台，求职者难以快速、准确地获取全面、及时的岗位信息。因此，基于Python爬虫技术抓取山东省岗位招聘信息，并通过数据可视化和Django框架构建岗位查询系统，具有重要的现实意义和应用价值。
研究意义：
提升求职效率与体验：通过爬虫技术聚合多平台招聘信息，求职者无需逐一访问各个网站，即可在一个平台上获取全面的岗位信息，极大提升了求职效率和用户体验。增强数据洞察能力：数据可视化技术能够将庞杂的招聘信息转化为直观、易理解的图表和图形，帮助求职者快速把握市场动态和岗位趋势，做出更明智的求职决策。优化资源配置与决策支持：对招聘信息的深度分析，可以为政府、教育机构等提供决策依据，优化人才资源配置，促进区域经济的协调发展。推动技术应用与创新：本研究结合Python爬虫、数据可视化和Django框架等先进技术，不仅是对这些技术的综合应用，更是对招聘行业信息化、智能化升级的有益探索。 二、国内外现状
国内现状：
在国内，随着大数据和人工智能技术的不断渗透，网络招聘行业正经历着深刻的变革。一些领先的招聘平台已经开始利用爬虫和数据分析技术优化信息服务，提高匹配精度。然而，针对特定地区如山东省的定制化招聘信息服务仍然较少，市场存在较大的发展空间。此外，现有平台在数据更新速度、信息准确性和用户友好性等方面仍有待提升。因此，本研究具有较大的市场潜力和实际应用价值。
国外现状：
在国外，尤其是发达国家或地区，网络招聘市场已经相当成熟。一些国际知名的招聘网站如Monster、Glassdoor等不仅提供全球范围内的岗位信息搜索服务，还利用先进的数据分析技术为用户提供个性化的职业规划和推荐服务。在数据可视化方面，国外的一些招聘平台已经取得了显著成果，通过图表、图形等多种方式展示招聘信息和市场趋势，为用户提供更加直观、便捷的信息查询服务。
然而，由于国内外市场环境、法律法规和文化差异等因素的影响，直接引进国外技术和模式可能面临一定的挑战和局限性。同时，国外的研究机构和企业也在积极探索基于爬虫技术的招聘信息抓取和分析方法，但针对特定地区或国家的定制化研究仍然较少。因此，针对山东省的实际情况进行定制化的研究和开发具有重要的现实意义和市场需求。
研究背景和意义： 随着互联网技术的不断发展，人们越来越依赖于网络获取信息。在就业方面，求职者需要及时了解岗位招聘信息，以便选择合适的岗位和更好地规划自己的职业发展。而岗位招聘信息的爬取和处理是一个繁琐且耗时的工作，因此，开发一个基于Python爬虫的岗位招聘信息数据可视化和岗位查询系统，可以极大地提高求职者获取招聘信息的效率，同时也为招聘企业提供一个更好的展示平台，促进人才的匹配。
国内外现状： 在国内，近年来岗位招聘网站如雨后春笋般涌现，包括智联招聘、前程无忧、拉钩网等众多知名的招聘平台。这些平台通过不同的方式收集、整理和展示岗位招聘信息，帮助求职者和招聘企业实现有效的信息交流。然而，由于岗位招聘信息的多样性和分散性，求职者在查找和筛选合适岗位时仍然面临一定的困难。
在国外，也出现了许多类似的岗位招聘信息网站和系统，比如LinkedIn、Indeed等。这些平台通过引入机器学习和人工智能等技术来提高搜索和匹配的准确性，同时也提供了一定的数据分析和可视化功能，帮助用户更好地了解岗位招聘市场的动态。
然而，目前还缺乏一个基于Python爬虫的岗位招聘信息数据可视化和岗位查询系统，在国内尤为如此。因此，开发这样一个系统具有重要的研究意义和实际应用价值。通过爬取山东省岗位招聘信息，并利用Django框架进行数据处理和展示，可以为求职者提供一个更便捷、准确的岗位查询和分析工具，帮助他们更好地了解岗位市场的需求和走向，为个人职业规划提供参考依据。同时，这也可以为招聘企业提供一个更直观、全面的展示平台，吸引更多的求职者关注和申请。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/106dc7448bae23889a3f517f231bba28/" rel="bookmark">
			css、js、vue常考部分面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css css盒子水平垂直居中方法 方法一：定位
.child{ height: 100px; position: absolute;//父元素相对定位 top:50%; left:50%; transform: translate(-50%,-50%); } 方法二：定位
.child{ width: 100px; height: 100px; position: absolute; top:50%; left:50%; margin-top: -50px; margin-left: -50px; } 方法三：定位
child { width: 100px; height: 100px; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto } 方法四：弹性盒子
father{ width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; } 方法五：表格
father{ width: 500px; height: 500px; border: 1px solid red; /* 将元素转成表格单元格显示 */ display: table-cell; vertical-align: middle; text-align: center; } 子元素需设置{ display: inline-block; vertical-align: middle;//消除行内块元素三像素问题 } css盒子模型的理解 将一个内容放在页面合适的位置，需要考虑到这个内容大小，位置，形状，就相当于，买一个家具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/106dc7448bae23889a3f517f231bba28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d28f2d0a6684f58ef42bf56dc3022a8/" rel="bookmark">
			Python&#43;Appium自动化测试的使用步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了Python+Appium实现自动化测试的使用步骤，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧
一、环境准备 1.脚本语言：Python3.x IDE：安装Pycharm
2.安装Java JDK 、Android SDK
3.adb环境，path添加E:\Software\Android_SDK\platform-tools
4.安装Appium for windows，官网地址http://appium.io/
点击下载按钮会到GitHub的下载页面，选择对应平台下载
安装完成后，启动Appium，host和port默认的即可，然后设置Android SDk和Java JDK
然后点下边那个保存并重启的按钮，然后点第一个Start Server按钮，将会看到
二、真机测试 1.连接手机
打开开发者模式，USB线连接手机和电脑，并且在开发者选项当中，开启USB调试
测试是否连接成功，可执行命令adb devices
出现上图就证明手机和电脑连接成功。。。
2.点击Start Inspector Session,
按如下配置Desired Capabilities
platformName：声明是ios还是Android系统
platformVersion： Android内核版本号，可通过命令adb shell getprop ro.build.version.release查看
deviceName：连接的设备名称，通过命令adb devices -l中model查看
appPackage：apk的包名
appActivity：apk的launcherActivity，通过命令adb shell dumpsys activity | findstr “mResume”查看（需先打开手机应用）
注意：Android 8.1之前应使用adb shell dumpsys activity | findstr “mFocus”
3.运行Start Session，选择元素
右侧 Selected Element 区域有三个按钮
Tap：执行选中元素的点击事件Send Keys：为文本框等对象传值如果是文本输入元素，就清除文本
4.录制脚本
录制生成的python代码如下：
# This sample code uses the Appium python client # pip install Appium-Python-Client # Then you can paste this into a file and simply run with Python from appium import webdriver caps = {} caps["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d28f2d0a6684f58ef42bf56dc3022a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54dd70d2d469ae9704415d41db90cc5/" rel="bookmark">
			原生JS和jQuery请求接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生JS请求接口 get请求 //步骤一:创建异步对象 var ajax = new XMLHttpRequest(); //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端 ajax.open('get','getStar.php?starName='+name); //步骤三:发送请求 ajax.send(); //步骤四:注册事件 onreadystatechange 状态改变就会调用 ajax.onreadystatechange = function () { if (ajax.readyState==4 &amp;&amp;ajax.status==200) { //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 console.log(ajax.responseText);//输入相应的内容 } } post请求 //创建异步对象 var xhr = new XMLHttpRequest(); //设置请求的类型及url //post请求一定要添加请求头才行不然会报错 xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded"); xhr.open('post', '02.post.php' ); //发送请求 xhr.send('name=fox&amp;age=18'); xhr.onreadystatechange = function () { // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { console.log(xhr.responseText); } }; jQuery ajax &lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54dd70d2d469ae9704415d41db90cc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b0e5339150c978f0a774831fc4035e0/" rel="bookmark">
			2024打开怎样的AI时空之门？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝字
关注我们
AI TIME欢迎每一位AI爱好者的加入！
关于AI TIME AI TIME源起于2019年，旨在发扬科学思辨精神，邀请各界人士对人工智能理论、算法和场景应用的本质问题进行探索，加强思想碰撞，链接全球AI学者、行业专家和爱好者，希望以辩论的形式，探讨人工智能和人类未来之间的矛盾，探索人工智能领域的未来。
迄今为止，AI TIME已经邀请了1600多位海内外讲者，举办了逾600场活动，超700万人次观看。
我知道你
在看
哦
~
点击 阅读原文 查看回放
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdfed371a3488301760f3adc50275e4/" rel="bookmark">
			杨中科 ASP.NETCore Rest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Rest RPC 1、Web API两种风格: 面向过程(RPC) 、面向REST (REST)
2、RPC:“控制器/操作方法“的形式把服务器端的代码当成方法去调用。把HTTP当成传输数据的通道，不关心HTTP谓词。通过QueryString请求报文体给服务器传递数据。状态码。比如/Persons/GetAll、/Persons/GetBvld?id=8./Persons/Update、/Persons/DeleteByld/8
REST REST: 按照HTTP的语义来使用HTTP协议
1、URL用于资源的定位: /user/888、/user/888/orders)
2、HTTP谓词: GET、POST (新增) 、PUT (整体更新)DELETE、PATCH (局部更新) 等
3、什么是“幂等”，举例? DELETE（删除id=1的数据，多次删除都是一样的）、PUT、GET是幂等的POST不幂等（幂等：执行一次和执行多次的结果是一致的）
4、GET的响应可以被缓存
5、服务器端要通过状态码来反映资源获取的结果: 404、403(没有权限) 、201 (新增成功)
RPC:业务驱动，自然
REST: 要求开发人员对REST原则更了解、并且有更多的设计能力。
没有绝对的好与坏，根据业务需求选择适合自己的方式。
REST的优缺点 REST的优点 1、通过URL对资源定位，语义更清晰
2、通过HTTP谓词表示不同的操作，接口自描
3、可以对GET、PUT、DELETE请求进行重试
4、可以用GET请求做缓存
5、通过HTTP状态码反映服务器端的处理结果统一错误处理机制。
6、网关等可以分析请求处理结果
REST的缺点 1、真实系统中的资源非常复杂，很难清晰地进行资源的划分，对技术人员的业务和技术水平要求高。
2、不是所有的操作都能简单地对应到确定的HTTP谓词力
3、系统的进化可能会改变幂等性.
4、通过URL进行资源定位不符合中文用户的习惯
5、HTTP状态码个数有限。
6、有些环节会篡改非200响应码的响应报文
7、有的客户端不支持PUT、DELETE请求。
选择 1、REST是学术化的概念，仅供参考。为什么AWS、ES等比较RESTful。为什么阿里、腾讯等很多系统不RESTful?
2、根据公司情况，进行REST的选择和裁剪
Asp.NET Core Restful中如何传递参数 HTTP传递参数的三种方式 URL: 适合定位;长度限制
QueryString: 灵活，长度限制
请求报文体:灵活，长度不限制；不支持GET、Delete
三种方式的不同语义 URL: 资源定位
Querstring URL之外的额外数据
请求报文体: 供PUT、POST提供数据
实施指南 1、完全按照HTTP语义要求高
2、我的建议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bdfed371a3488301760f3adc50275e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c2b6218802db16dce0810490868c84e/" rel="bookmark">
			ubuntu docker离线安装docker（.deb包方式）（成功）（附卸载方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：Install Docker Engine on Ubuntu
文章目录 安装步骤下载安装包拷贝到目标主机并执行安装命令 验证拉取运行容器测试build dockerfile测试持久运行容器测试主机重启后，docker各服务是否正常自启 卸载方法附：各安装包作用说明（以及插件）1. `containerd.io_&lt;version&gt;_&lt;arch&gt;.deb`2. `docker-ce_&lt;version&gt;_&lt;arch&gt;.deb`3. `docker-ce-cli_&lt;version&gt;_&lt;arch&gt;.deb`4. `docker-buildx-plugin_&lt;version&gt;_&lt;arch&gt;.deb`5. `docker-compose-plugin_&lt;version&gt;_&lt;arch&gt;.deb` 附：`docker-ce-rootless-extras_&lt;version&gt;_&lt;arch&gt;.deb`和`docker-scan-plugin_&lt;version&gt;_&lt;arch&gt;.deb `是什么？ https://docs.docker.com/desktop/install/ubuntu/
https://docs.docker.com/engine/install/ubuntu/#install-from-a-package
说明：这个安装方式是下载.deb包安装，最终效果几乎与用apt install docker.io完全相同。不仅安装方便，卸载起来也十分方便，不会破环系统环境。
安装步骤 下载安装包 https://download.docker.com/linux/ubuntu/dists/
我是ubuntu20.04，选择focal：
选择pool（官网让选这的）：
解释：
目录说明：
edge/：包含一些实验性或开发中的软件包，可能不稳定或不适合生产环境使用。nightly/：包含每日构建的软件包，用于测试和开发目的。pool/：存放软件包的目录。stable/：包含稳定版本的软件包，适合生产环境使用。test/：包含一些测试相关的软件包。 文件说明：
InRelease：包含软件包的元数据和数字签名，用于验证软件包的完整性和真实性。Release：包含软件包的元数据，如软件包列表、版本信息等。Release.gpg：包含对Release文件的数字签名，用于验证Release文件的真实性。 选择stable：
选择amd64（根据系统来，我的目前是amd64）：
将下列文件全下载下来：
containerd.io_&lt;version&gt;_&lt;arch&gt;.deb docker-ce_&lt;version&gt;_&lt;arch&gt;.deb docker-ce-cli_&lt;version&gt;_&lt;arch&gt;.deb docker-buildx-plugin_&lt;version&gt;_&lt;arch&gt;.deb docker-compose-plugin_&lt;version&gt;_&lt;arch&gt;.deb 关于下载什么版本的，我就根据我ubuntu20.04虚拟机上之前用apt install docker.io的来吧：
这是我们ubuntu20.04arm盒子的，我也备份下：
root@ubuntu:~# docker version Client: Version: 20.10.21 API version: 1.41 Go version: go1.18.1 Git commit: 20.10.21-0ubuntu1~20.04.2 Built: Thu Apr 27 05:56:44 2023 OS/Arch: linux/arm64 Context: default Experimental: true Server: Engine: Version: 20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c2b6218802db16dce0810490868c84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0ddc1ed9b35808356520f751899d09/" rel="bookmark">
			第三章 前端发起HTTP请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. XMLHttpRequest API 回顾与使用案例 XMLHttpRequest (XHR) 是一个较早的、由浏览器提供的API，用于在后台（异步）与服务器交换数据。它允许网页从服务器请求新的数据并在不重新加载整个网页的情况下更新部分网页内容。
// 创建一个新的XMLHttpRequest对象实例 var xhr = new XMLHttpRequest(); // 设置请求方法和URL xhr.open('GET', 'https://api.example.com/data'); // 设置请求完成后的回调函数 xhr.onload = function() { if (xhr.status === 200) { // HTTP状态码为200表示成功 var data = JSON.parse(xhr.responseText); // 解析返回的数据 console.log(data); } else { console.error(xhr.statusText); // 输出错误信息 } }; // 发送请求 xhr.send(); // 可以设置请求头和其他选项 xhr.setRequestHeader('Content-Type', 'application/json'); xhr.timeout = 3000; // 设置超时时间（毫秒） 2. Fetch API 的现代应用实践 Fetch API 是对 XMLHttpRequest 的更现代且基于 Promise 的替代方案，提供了一种更简洁的语法结构，并支持更多的高级功能，如更好的错误处理和流式读取响应体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f0ddc1ed9b35808356520f751899d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53879dc26063bbd4f327df6a65a6f547/" rel="bookmark">
			手把手教你安装Jupyter Notebook(保姆级教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jupyter Notebook介绍 什么是Jupyter Notebook Jupyter Notebook 是一个基于 Web 的交互式计算环境，支持多种编程语言，包括 Python、R、Julia 等。它的主要功能是将代码、文本、数学方程式、可视化和其他相关元素组合在一起，创建一个动态文档，用于数据分析、机器学习、科学计算和数据可视化等方面。Jupyter Notebook 提供了一个交互式的界面，使用户能够以增量和可视化的方式构建和执行代码，同时支持 Markdown 格式的文本和 LaTeX 数学符号。
Jupyter Notebook安装方法 在安装Jupyter Notebook之前，可以选择先安装Anaconda，Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项，其中包括了Jupyter Notebook。
当然也可以通过命令行pip来安装（必须确保已安装python）Jupyter Notebook,下文会为大家介绍这两种方法。
情况一：利用Anaconda安装Jupyter Notebook windows 系统安装Anaconda 1.在 Anaconda 官网下载适用于 Windows 的 Anaconda 安装包。
2.双击安装包进行安装，选择 “Add Anaconda to my PATH environment variable”，然后单击 “Install”。
点击next
点击agree
点击Just Me
设置安装的目录(建议放在除c盘外的磁盘，最好创建一个新文件夹)
勾选前三个，第二个勾选表示加入环境变量，后面再设置会很麻烦
点击install,后面一路next并等待安装。
这两个都别勾，点finish就完成啦
此时打开命令行，输入
conda --version 若显示版本信息，说明安装成功啦
3.配置国内镜像源
继续在cmd里，通过输入下面命令配置为清华源：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53879dc26063bbd4f327df6a65a6f547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9ffa6e6b5c8696bef02e3f7bc6d9e0/" rel="bookmark">
			Python课程设计 | 实现学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了一个简单的学生信息管理系统，包括管理员登录、重置学生密码、添加、删除和修改学生信息、查询学生信息以及对学生成绩进行排序等功能。该系统使用Python编写，基于控制台交互
实现思路 该系统分为两个部分，管理员登录和学生信息管理。在管理员登录时，程序会要求用户输入用户名和密码进行身份验证；验证通过后，进入到学生信息管理界面。学生信息管理界面提供了多种操作方式，包括重置学生密码、添加、删除和修改学生信息、查询学生信息以及对学生成绩进行排序等功能。
在实现过程中，我们使用了文件存储学生信息，其中每一行代表一个学生的信息，各字段之间以逗号分隔。在对学生成绩进行排序时，我们计算每个学生的平均分，并将其作为排序依据。
代码实现 登录界面 # 登录界面 def login(): print("欢迎使用学生信息管理系统") # 打印欢迎信息 while True: # 一直循环直到输入正确的角色类型 role = input("请输入登录角色（1-学生，2-管理员）：") # 输入角色类型 if role == '1': # 如果输入是学生 student_login() # 转到学生登录函数 break # 结束循环 elif role == '2': # 如果输入是管理员 admin_login() # 转到管理员登录函数 break # 结束循环 else: print("输入有误，请重新输入") # 提示输入错误，重新输入 执行效果 学生登录 # 学生登录 def student_login(): while True: # 一直循环直到输入正确的账号和密码 account = input("请输入账号：") # 输入账号 password = input("请输入密码：") # 输入密码 with open('xs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9ffa6e6b5c8696bef02e3f7bc6d9e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67612db5a99da4d29bb2eae94d3933e8/" rel="bookmark">
			VSCode使用 - 搭建python运行调试环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode是一个优秀的编辑工具，适合代码阅读，代码编辑，甚至配置好之后，可以编译与调试代码。
为了方便编辑，运行python程序，本文就聊聊如何将VSCode搭建为一个python的IDE吧，具备运行与调试python程序的能力。
1、安装python程序 首先，安装python程序，这样才能进行python开发，我这里安装了python-3.7.4和python-2.7.16，都是目前的最新版本了。具体的安装过程这里就不说明了，很简单的。
不会的可以看一下这个：Python小白入门安装教程
2、安装VSCode 3、安装python扩展 VSCode的python扩展对python有着很好的支持，比较突出的功能有：智能提示，代码调试，代码导航，代码格式化等。
在VSCode编辑器的扩展页面中，搜索python，安装Python扩展（我这里已经安装好了）：
4、创建工程 首先在电脑中创建一个python文件夹，然后在python文件夹中创建一个test.py文件：
将python文件夹添加到VSCode的工作区中，File -&gt; Add Folder to Workspace：
test.py文件中的代码如下：
print ("hello 111") print ("hello 222") print ("hello 333") print ("hello 444") 5、选择python解释器 当打开python文件之后，VSCode会自动选择系统中配置好的Python解释器，显示在VSCode的左下角（我的系统安装了python-3.7.4和python-2.7.16）：
如果想要切换Python解释器，那么点击下左下角当前已选的Python解释器，然后选择想要切换的版本即可（我这里使用python-3.7.4进行演示了）：
6、运行Python程序 这里有2种方法来全速运行python文件。
（1）、在python文件中，鼠标右键，然后选择Run Python File in Terminal：
（2）、在工作区的test.py文件上点击鼠标右键，然后选择Run Python File in Terminal：
7、调试Python程序 Python扩展能够调试python脚本，web apps，远程或多线程程序。
（1）、设置调试器 首先切换到调试界面，接着点击调试器的设置按钮：
在弹出的界面中选择Python File这个调试器：
在选择好python调试器之后，VSCode会自动的在工作区的.vscode目录下建立launch.json文件：
如果想要在启动调试后，自动停止在程序入口，那么在launch.json中添加下面设置：
"stopOnEntry": true （2）、设置断点与调试 打开想要调试的python文件，然后将鼠标移动到行号的左侧（我这里选的是第3行），可以看到一个断点的标志，点击即可在该行设置断点：
按F5或者点击Debug -&gt; Start Debugging来启动调试，启动调试之后，程序停在了刚才设置的断点处：
接着可以使用调试面板中的调试按钮来调试我们的程序了，调试面板中的按钮从左到右依次是：
按钮1：移动按钮，拖住后可以移动调试控制面板；
按钮2：继续运行，对应快捷键F5；
按钮3：单步跳过，对应快捷键F10；
按钮4：单步调试，对应快捷键F11；
按钮5：单步跳出，对应快捷键Shift+F11；
按钮6：重新运行，对应快捷键Ctrl+Shift+F5；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67612db5a99da4d29bb2eae94d3933e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7888a7d2bec14d1a40ec6403fecba0ef/" rel="bookmark">
			IntelliJ IDEA 下载安装教程，超详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要永久使用权限的可以添加获取，还剩50个名额
1. IDEA 下载 1、打开浏览器输入https://www.jetbrains.com/，进入
Jetbrains官网，点击 Developer Tools，再点击 Intellij IDEA
2、点击中间的 Download，进入IDEA下载界面
3、选择左边的 Ultimate 版本进行下载安装。Ultimate 版本为旗舰版，需要付费，包括完整的功能Community
版本为社区版，免费，只支持部分功能。这里我们选择左边 Ultimate 版本进行下载，然后进行激活
2. IDEA 安装 1、下载完后在本地找到该文件，双击运行 idea 安装程序
2、点击 Next
3、选择安装路径，Next
4、按需求选择，点击 Next
5、默认，不用改，直接点 Install，安装
6、安装完成后，点击 Finish，也可勾选Run Intellij IDEA 再点击 Finish，会自动打开安装好的 IDEA
3. IDEA 使用 1、打开 IDEA，Don’t Send
2、点击 Start trial
点击开始试用
3、点击 New Project，新建一个项目
4、可以选择不同的项目类型，输入项目名，选择项目创建路径，Create
5、进入 IDEA 的主界面，进行项目编写
需要永久使用权限的可以添加获取，还剩50个名额
说句题外话
人生苦短，我用Python！Python在语言编程排行榜持续第一，在过去的 5 年时间里，Python已经 3 次获得Tiobe指数年度大奖！毋庸置疑，Python已成为目前最受欢迎的编程语言。
它可应用于爬虫、web开发、后端开发、数据分析、人工智能、自动化测试等领域。就业前景好，薪资待遇高，即使你不想出去上班，也可以利用Python在家做兼职赚钱（比如爬取客户需要的数据、量化交易、代写程序等）
是不是非常不错呢？
学习资源推荐 除了上述分享，如果你也喜欢编程，想通过学习Python获取更高薪资，这里给大家分享一份Python学习资料。
这里给大家展示一下我进的最近接单的截图
😝朋友们如果有需要的话，可以V扫描下方二维码联系领取，也可以内推兼职群哦~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7888a7d2bec14d1a40ec6403fecba0ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295a9a20ee5540c55baaec45a258359c/" rel="bookmark">
			Python安装教程超详细，看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将介绍以下几部分内容：
下载 python安装 python配置环境变量python 多版本共存配置python 编程工具推荐 一、下载 python 下载 python 点击这里进入 python 下载页面
在下载页面可以看到很多不同版本的下载链接。其中，标记 x86 的为 32 位安装包，x86-64 为 64 位安装包。executable installer为完整的安装包，下载完即可安装；web-based installer 体积更小，但安装时仍需联网下载其他部分。一般网络不好时选择 executable installer，以保证安装过程不会中断。
python下载官网 操作系统的位数可通过以下操作确定：右击此电脑 -&gt; 点击属性 -&gt; 查看位数；一般是64位
查看操作系统位数（1） 查看操作系统位数（2） python 版本简介 python 包括 python2、python3 两个大版本，其中 python3 改进了 python2 的一些不足，但由于以前很多应用是用 python2 开发的，维护这些应用还需用到 python2，故 python2 尚未被完全淘汰。
此外，版本也不是越高越好，因为有的模块（库）不支持太高版本的 python。
二、安装 python 1.打开安装包所在文件夹，双击开始安装。
2.勾选 “Add Python to PATH” 复选框，点击 “Customize installaion”。
3.保持默认设置，点击 “next”。
4.修改安装路径（记住此路径，后面可能会用到），可以是任意空间充足的盘（这里直接将 C 改为 D） -&gt; 点击 “Install” 开始安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/295a9a20ee5540c55baaec45a258359c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3838d0d1aa1dbf35e68e7fc92fc4bf35/" rel="bookmark">
			isEmpty 和 isBlank 的用法区别，居然一半的人答不上来.....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		isEmpty 和 isBlank 的用法区别 isEmpty系列isBank系列 hi！我是沁禹～ 也许你两个都不知道,也许你除了isEmpty/isNotEmpty/isNotBlank/isBlank外,并不知道还有isAnyEmpty/isNoneEmpty/isAnyBlank/isNoneBlank的存在, come on ,让我们一起来探索org.apache.commons.lang3.StringUtils;这个工具类.
isEmpty系列 StringUtils.isEmpty()
是否为空. 可以看到 " " 空格是会绕过这种空判断,因为是一个空格,并不是严格的空值,会导致 isEmpty(" ")=false
StringUtils.isEmpty(null) = trueStringUtils.isEmpty(“”) = trueStringUtils.isEmpty(" ") = falseStringUtils.isEmpty(“bob”) = falseStringUtils.isEmpty(" bob ") = false /** * * &lt;p&gt;NOTE: This method changed in Lang version 2.0. * It no longer trims the CharSequence. * That functionality is available in isBlank().&lt;/p&gt; * * @param cs the CharSequence to check, may be null * @return {@code true} if the CharSequence is empty or null * @since 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3838d0d1aa1dbf35e68e7fc92fc4bf35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a5b851d572a1281db39bff06e6c53c/" rel="bookmark">
			Python join()方法：合并字符串及 dir()和help()帮助函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python dir()和help()帮助函数 join() 方法也是非常重要的字符串方法，它是 split() 方法的逆方法，用来将列表（或元组）中包含的多个字符串连接成一个字符串。
使用 join() 方法合并字符串时，它会将列表（或元组）中多个字符串采用固定的分隔符连接在一起。例如，字符串“c.biancheng.net”就可以看做是通过分隔符“.”将 ['c','biancheng','net'] 列表合并为一个字符串的结果。
join() 方法的语法格式如下：
newstr = str.join(iterable) 此方法中各参数的含义如下：
newstr：表示合并后生成的新字符串；
str：用于指定合并时的分隔符；
iterable：做合并操作的源字符串数据，允许以列表、元组等形式提供。
【例 1】将列表中的字符串合并成一个字符串。
&gt;&gt;&gt; list = ['c','biancheng','net'] &gt;&gt;&gt; '.'.join(list) 'c.biancheng.net' 【例 2】将元组中的字符串合并成一个字符串。
&gt;&gt;&gt; dir = '','usr','bin','env' &gt;&gt;&gt; type(dir) &lt;class 'tuple'&gt; &gt;&gt;&gt; '/'.join(dir) '/usr/bin/env' Python dir()和help()帮助函数 我们已经学习了很多字符串变量提供的方法，如 split()、join()、find()、index() 等，但这远远不是它的全部方法。今天给大家列举一些最常用的方法。
Python 非常方便，它不需要用户查询文档，只需掌握如下两个帮助函数，即可查看 Python 中的所有函数（方法）以及它们的用法和功能：dir()：列出指定类或模块包含的全部内容（包括函数、方法、类、变量等）。help()：查看某个函数或方法的帮助文档。
例如，要查看字符串变量（它的类型是 str 类型）所能调用的全部内容，可以在交互式解释器中输入如下命令：
&gt;&gt;&gt; dir(str) ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] &gt;&gt;&gt; 上面列出了字符串类型（str）提供的所有方法，其中以“_”开头、“_”结尾的方法被约定成私有方法，不希望被外部直接调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5a5b851d572a1281db39bff06e6c53c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0727d11e9654ee729c5edc48bf1c0e3/" rel="bookmark">
			【Latex】如何调整论文里面的多个子图？如何解决对齐问题？子图如何移动？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、包含多个子图二、对齐问题三、子图的移动 一、包含多个子图 要实现多个子图（subfigures）排列，我们需要使用浮动环境（如figure），并在其中放置子图。
浮动环境会自动管理页面的布局，并在需要时将内容移到新的页面上。
下面是一个示例代码，展示如何在LaTeX文档中创建多个子图：
\documentclass{article} \usepackage{graphicx} \usepackage{subcaption} \begin{document} \begin{figure}[!htb] \centering \begin{subfigure}{.5\textwidth} \centering \includegraphics[width=\linewidth]{example-image-a} \caption{First Subfigure} \end{subfigure}% \begin{subfigure}{.5\textwidth} \centering \includegraphics[width=\linewidth]{example-image-b} \caption{Second Subfigure} \end{subfigure} % 重复以上代码块来添加更多的子图 \caption{Multiple Subfigures} \end{figure} \end{document} 在这个示例中，figure 环境包含了多个 subfigure，每个 subfigure 包含一个图像和一个标题。
如果所有子图无法放在同一页上，LaTeX 会自动将它们分散到新的页面上。我们可以根据需要调整子图的数量和布局。
如图所示：
二、对齐问题 LaTeX中的对齐问题通常是由于环境设置、图像本身的尺寸，或者是插入图像时周围的空白造成的。
要解决对齐问题，我们需要确保：
在所有的 subfigure 中使用相同的宽度设置。确保图像的尺寸相匹配。确保图像没有额外的边缘空白。 以下是一些建议修改，以解决对齐问题：
\begin{figure*}[!htb] \centering % 确保所有子图的宽度设置相同 \includegraphics[width=\textwidth]{images/15.png} \includegraphics[width=\textwidth]{images/16.png} \includegraphics[width=\textwidth]{images/17.png} \includegraphics[width=\textwidth]{images/18.png} \includegraphics[width=\textwidth]{images/19.png} \includegraphics[width=\textwidth]{images/20.png} % 如果希望有子图的标题，每个includegraphics命令都应放在subfigure环境中，并且提供caption和label \end{figure*} \begin{figure*}[!htb] \centering % 使用相同的宽度设置 \includegraphics[width=\textwidth]{images/21.png} \includegraphics[width=\textwidth]{images/22.png} \includegraphics[width=\textwidth]{images/23.png} \includegraphics[width=\textwidth]{images/24.png} \includegraphics[width=\textwidth]{images/25.png} \includegraphics[width=\textwidth]{images/26.png} % 如果希望有子图的标题，每个includegraphics命令都应放在subfigure环境中，并且提供caption和label \end{figure*} 如果希望在图像下方添加子标题和标签，需要为每个 \includegraphics 命令包裹一个 subfigure 环境，并提供 \caption 和 \label。这里我移除了 subfigure 环境因为我们没有在原始代码中为它们添加标题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0727d11e9654ee729c5edc48bf1c0e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effe7d9cafbf84112f370e2f3d72ed59/" rel="bookmark">
			MySQL中FLUSH TABLES命令语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中，FLUSH TABLES 命令的作用是刷新表。当你使用 FLUSH TABLES 命令的具体选项时（例如 FLUSH TABLES WITH READ LOCK），该选项必须是在 FLUSH 语句中唯一指定的命令。即，在一个 FLUSH 语句中，你只能使用单一的 FLUSH TABLES 选项。此外，FLUSH TABLE 是 FLUSH TABLES 等价的。
注意： 对于描述中提到的刷新操作，InnoDB引擎的行为与其他存储引擎不同。在InnoDB下，执行刷新操作会将表的内容写入磁盘，但表本身仍然保持打开状态。因此，即使表处于打开状态，只要没有其他写入操作发生，也可以复制表文件。
FLUSH TABLES 命令的使用： FLUSH TABLES： 此命令关闭所有已打开的表，强制所有正在使用的表关闭，并清空预处理语句缓存。该操作需要用户拥有 FLUSH_TABLES 或 RELOAD 权限。如果存在活跃的 LOCK TABLES ... READ，则不允许使用 FLUSH TABLES。若需刷新表并加上读锁，则应使用 FLUSH TABLES tbl_name ... WITH READ LOCK 替代。
FLUSH TABLES tbl_name [, tbl_name] ...： 通过列出一个或多个逗号分隔的表名，此操作只会刷新指定的表。类似于没有表名的 FLUSH TABLES，但服务器仅针对特定表进行刷新。如果所指定的表不存在，命令不会报错。该命令同样需要 FLUSH_TABLES 或 RELOAD 权限。
FLUSH TABLES WITH READ LOCK： 该命令关闭所有打开的表，并对所有数据库的所有表施加全局读锁。适合在拥有如Veritas或ZFS等能够快速创建快照的文件系统时，作为获取备份的便利方式。使用 UNLOCK TABLES 来释放读锁。此命令获取的是全局读锁而非表锁，因此其行为不受 LOCK TABLES 和 UNLOCK TABLES 对表锁定和隐式提交的相同规则约束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effe7d9cafbf84112f370e2f3d72ed59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c863b4f91005ffcf0a74b7e147672d1/" rel="bookmark">
			还在用 System.currentTimeMillis() 统计代码耗时？太 Low 啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 有时我们在做开发的时候需要记录每个任务执行时间，或者记录一段代码执行时间，最简单的方法就是打印当前时间与执行完时间的差值，然后这样如果执行大量测试的话就很麻烦，并且不直观，如果想对执行的时间做进一步控制，则需要在程序中很多地方修改，目前spring-framework提供了一个StopWatch类可以做类似任务执行时间控制，也就是封装了一个对开始时间，结束时间记录工具
2、示例 我们来看几个示例
统计输出总耗时
import org.springframework.util.StopWatch; public class SpringStopWatchExample { public static void main (String[] args) throws InterruptedException { StopWatch sw = new StopWatch(); sw.start(); //long task simulation Thread.sleep(1000); sw.stop(); System.out.println(sw.getTotalTimeMillis()); } } 输出
1013 输出最后一个任务的耗时
public class SpringStopWatchExample2 { public static void main (String[] args) throws InterruptedException { StopWatch sw = new StopWatch(); sw.start("A");//setting a task name //long task simulation Thread.sleep(1000); sw.stop(); System.out.println(sw.getLastTaskTimeMillis()); } } 输出
1009 以优雅的格式打出所有任务的耗时以及占比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c863b4f91005ffcf0a74b7e147672d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e069e16f23747fe0538362c165e89080/" rel="bookmark">
			AOP（面向切面编程）的基本概念和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP（面向切面编程）的基本概念和原理 什么是AOP？ 面向切面编程（AOP）是一种软件开发范式，旨在通过横切关注点（cross-cutting concerns）的方式来解耦系统中的各个模块。横切关注点指的是那些不属于业务逻辑本身，但是会影响多个模块的代码，比如日志记录、事务管理、安全性等。
AOP的核心思想是将这些横切关注点从业务逻辑中分离出来，形成独立的切面（Aspect）。切面包含了横切关注点的代码，当程序执行到特定的点（切点）时，切面的代码就会被执行，从而实现了与业务逻辑的解耦。
AOP的基本原理 AOP通过在程序执行的不同阶段织入切面代码来实现其功能。织入（weaving）是指将切面代码与目标代码合并的过程。
有两种主要的织入方式：编译时织入和运行时织入。编译时织入是在程序编译的时候将切面代码织入目标代码中，而运行时织入则是在程序运行的时候动态地将切面代码织入目标代码中。
在AOP中，常见的概念还包括切点（Pointcut）、通知（Advice）、连接点（Joinpoint）等。切点定义了在何处执行切面代码，通知定义了切面代码的具体行为，连接点则是在程序执行过程中能够插入切面代码的点。
AOP的优势 解耦性：AOP可以将横切关注点从业务逻辑中抽离出来，提高代码的模块化程度，降低模块间的耦合度。
可维护性：由于横切关注点被集中到切面中，因此对于这部分代码的维护变得更加容易，不需要在各个模块中进行重复的修改。
可重用性：切面是一种独立的代码单元，可以在不同的模块或项目中被重用，提高了代码的可重用性。
可扩展性：通过添加新的切面，可以方便地扩展系统的功能，而不需要修改已有的业务逻辑代码。
提高代码清晰度：将横切关注点与业务逻辑分离，使得业务逻辑更加清晰，易于理解和维护。
AOP在日志记录中的应用场景 介绍 日志记录是软件开发中一项重要的工作，它帮助开发人员了解系统的运行状态、排查问题以及进行性能分析。然而，将日志记录与业务逻辑混合在一起可能导致代码的臃肿，降低了代码的可读性和可维护性。在这种情况下，AOP可以提供一种优雅的解决方案。
AOP在日志记录中的应用 1. 切面定义 首先，我们需要定义一个日志记录的切面。这个切面包含了在业务逻辑执行前后记录日志的代码。
public aspect LoggingAspect { pointcut executionOfBusinessLogic(): execution(* com.example.businesslogic.*.*(..)); before(): executionOfBusinessLogic() { // 在业务逻辑执行前记录日志 System.out.println("Before executing business logic..."); } after(): executionOfBusinessLogic() { // 在业务逻辑执行后记录日志 System.out.println("After executing business logic..."); } } 2. 应用场景 假设我们有一个简单的业务逻辑类：
public class BusinessLogicService { public void performTask() { // 业务逻辑代码 System.out.println("Performing business logic task..."); } } 通过AOP，我们无需在业务逻辑代码中插入日志记录的代码。而是，通过切面的方式，实现了业务逻辑与日志记录的解耦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e069e16f23747fe0538362c165e89080/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1910436b698daef9825d2ae12acdc27d/" rel="bookmark">
			vue封装组件(一)标签和下拉框组合实现添加数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景: 最近接入短剧内容，需要添加短剧合作方。在详情页需要支持添加组件 方案一：标签tag加上输入框实现添加数据。图片见下 这个是刚开始做的，后来产品觉得这样会造成随意修改数据，需要改成下拉框形式添加 方案二：标签tag加上下拉框以及添加按钮实现。 这个就避免了乱添加数据，添加合作方名字需要在一个管理页面添加，然后下拉框请求自然就请求到数据了
方案一效果图：第一行 流程：点击新增后，填入数据，后台会自动检查是否存在，存在返回数据，否则保存然后返回数据。 这样做有个问题，一不小心填错数据，后台也保存下来了 方案二效果图：第二行 流程：下拉框中是已经存在的数据，然后选择添加就行。合作方需要在另外的一个管理页面增删查改。 接下来是代码实现。 注意：这两个都是封装的组件，直接掉用即可，既然是封装的组件，那么就要支持已经存在的合作方数据填入。
方案一 &lt;template&gt; &lt;div&gt; &lt;!-- {{shortPlays}}--&gt; &lt;el-tag style="margin-right: 5px" v-for="(tag,index) in shortPlaysFilter" :key="index" closable @close="close(index,tag.shortPlayName)"&gt; {{tag.shortPlayName}} &lt;/el-tag&gt; &lt;el-input v-if="inputVisible" v-model="inputValue" ref="ref" class="input-new-tag" size="small" style="width: 100px" @keyup.enter.native="inputConfirm" @blur="inputConfirm" &gt;&lt;/el-input&gt; &lt;el-button v-else size="small" style="margin-left: 5px;" @click="btnClick"&gt;新增合作方&lt;/el-button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import * as mapRequest from "@/api/map"; export default { name: "ag_album_short_play_partner", props:{//这里外部的数据传入 shortPlays:{ required:true, default:()=&gt;{ return []; } } }, data() { return { inputVisible:false, inputValue:'', } }, created() { }, methods: { close(index,name){ // 注意：这里的index 不能直接拿到删除 因为这个index 是过滤后的 所以通过name找下标 然后删除 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1910436b698daef9825d2ae12acdc27d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6718f4d2f39551595f609d6171647de/" rel="bookmark">
			【Latex】Reference `tab:4‘ on page * undefined on input line *如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 Latex中，编译好表格中，尝试引用，发现问题：
无法有效的引用！
我们查到对应的定义的位置，内容如下所示：
说我们的tab:4没有被定义。
\begin{table*}[h] \centering \setlength{\tabcolsep}{5pt} \begin{tabular}{lcccccccc} \hline \\[3pt] CSAM &amp; STRCSM &amp; Lean-neck &amp; AP &amp; $\text{AP}_{\text{s}}$ &amp; $\text{AP}_{\text{m}}$ &amp; $\text{AP}_{\text{l}}$ &amp; Params (M) &amp; FLOPs (G) \\[3pt] \hline \\[3pt] \multicolumn{9}{c}{STRAMNet} \\[5pt] \hline \\[5pt] \checkmark &amp; \checkmark &amp; &amp; 30.2 &amp; 19.8 &amp; 41.7 &amp; 52.1 &amp; 45.58 &amp; 260.7 \\[5pt] \checkmark &amp; &amp; \checkmark &amp; 30.0 &amp; 19.5 &amp; 41.6 &amp; 53.2 &amp; 44.29 &amp; 131.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6718f4d2f39551595f609d6171647de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07400f5fa04b4d3d50c9cd50ac91a145/" rel="bookmark">
			BEV&#43;Transformer感知架构共识下，传感器「火药味」再升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高阶智能驾驶战火愈演愈烈，正带动感知方案卷入新一轮军备竞赛。
根据高工智能汽车研究院最新发布数据显示，2023年1-9月，中国市场（不含进出口）乘用车前装标配（软硬件）NOA交付新车37.73万辆，同比上年同期增长151.20%。未来几年内，NOA（从高速到城区）的普及化将是高阶智能驾驶市场的主旋律。
叠加技术、市场和政策等多方因素，智能驾驶质变加速。大模型算法的应用，不断突破自动驾驶ODD的上限，从感知到决策控制端到端的自动驾驶模型有望成为未来发展方向。
具体到感知端，传感器配置持续“内卷”，多传感器信息融合成为关键课题。基于BEV+Transformer做特征融合，有利于解决图像尺度问题和遮挡问题，更好地实现向量空间的构建，逐渐成为智能驾驶感知的主流范式。
另外，在AI大模型的助力下，通过算法提前融合摄像头、激光雷达、毫米波雷达、超声波雷达等不同传感器的数据信息特征，进一步提升了智能驾驶的感知能力。同时，借助大模型优化CornerCase的处理，以及动态语义地图，可减少对高精地图依赖。
有业内专家表示，基于Transformer模型，智能驾驶有望实现感知与决策一体化，实现端到端的大模型，即模型输入传感器数据、直接输出控制信号，以避免智能驾驶开发架构现存的累计错误或任务协调不足等问题。
而上述智能驾驶趋势，也驱动着摄像头、超声波雷达、毫米波雷达、激光雷达等传感器的变革。有关各细分传感器的应用痛点、成本问题、市场增量机会等话题，热度有增无减。
在元橡科技冠名的2023（第七届）高工智能汽车年会专场一，来自德赛西威、毫末智行、元橡科技、睿创微纳、元视芯、哆来目、晟泰克、魔视智能、复睿智行、亮道智能、禾赛科技、威孚高科等行业专家，围绕车载摄像头、超声波雷达、毫米波雷达、激光雷达等传感器的新变革、新趋势，发表了精彩的主题演讲。
其中，德赛西威智能驾驶事业部产品负责人赵洋发表了《车载摄像头未来趋势的思考》主题演讲。
德赛西威智能驾驶事业部产品负责人赵洋
他表示，作为智能驾驶系统不可或缺的核心传感器之一，摄像头的性能在不断升级，具体表现在技术成熟、性价比高、采集信息丰富，同时单车用量大幅提升。
随着新结构设计、新材料应用，以及芯片、产品制造工艺流程升级，摄像头向着高像素、小Pixel Size方向发展。且随着单车传感器配置数量不断攀升，降本压力持续下放，高像素、散热快，高效的自清洁和多场景覆盖、多功能复用，是摄像头的三大技术需求新变革。
具体表现在，大算力芯片快速发展、大模型算法的应用，以及“大屏”时代，高像素摄像头可以提供极致的用户体验价值；L3/L4级自动驾驶商业化加速，摄像头高效的自清洁功能产品竞争力的核心；Transfer + BEV视觉算法架构的快速迭代以及产品内卷，功能下沉，摄像头复用是必然趋势。
毫末智行上海研发中心负责人孙宣峰发表了《自动驾驶 3.0 时代，大模型重塑汽车智能化技术路线》主题演讲。
毫末智行上海研发中心负责人孙宣峰
根据介绍，毫末智行此前已发布第二代三款HPilot 智能驾驶产品：HP170、HP370和HP570，可满足高、中、低不同价位的市场需求，并且均会在2023-2024年先后量产上车。毫末智行的目标是把“极致性价比”’打出来，依托近年积累的工程经验和对用户使用数据的深入挖掘”，让中阶智驾便宜更好用，让高阶智驾好用更便宜。
孙宣峰表示，支持毫末HPilot智驾产品实现快速进化的关键，就是毫末始终坚定智能驾驶基础设施的持续投入，以大数据、大模型、大算力为技术方向，以数据驱动为核心，重视产品能力与用户体验的统一，坚持海量多模态数据的持续反哺，坚持迈向从感知到认知、端到端自动驾驶大模型的技术路线，坚持超级智算中心的持续扩容与不断升级。
元橡科技联合创始人&amp;CTO 任杰发表了《高精双目3D点云驱动高阶智驾规模化量产落地》主题演讲。
元橡科技联合创始人&amp;CTO 任杰
智能驾驶功能场景从简单封闭走向复杂开放和高频，高速NOA向城市NOA演进，以及主机厂对魔毯舒适类功能体验的关注提升，双目立体视觉技术的优势被明显释放。尤其是在具备魔毯和城市NOA的高阶智驾方案中，双目将成为重要的感知方案。
比如，针对鬼探头/快速切入场景，双目具备低延时和高稠密度特点，可以快速发现异常，极大缩短车辆反应时间，降低鬼探头/快速切入障碍物的风险。而在城市道路复杂路面，双目可精准识别任意凹坑凸起，可提供“安全性”+“舒适性”双重保障。
具体到细分功能，借助双目高精稠密3D点云优势，可以实现增强型LCC。双目方案能在车身完整出现更早检测出加塞车辆，可精准判断对方车辆姿态、距离从而更好判断对方意图，LCC控制更安全、更舒适。
元橡科技的双目立体视觉系统结合Meto NET神经网络及DeepFusion技术架构，可以对车辆前方行驶路面的平整度和凹凸异物进行检测，输出高可靠高精度的方位、尺寸和高程信息，将相关结构化结果数据输出给车辆底盘主动悬架控制系统，从而实现减震和驾驶模式自动调节功能，实现了L2+和魔毯的高度集成，车辆的驾乘舒适性和底盘安全性得到了全面提升。
睿创微纳产品负责人肖航发表了《红外传感器为 ADAS 主动安全助力》主题演讲。
睿创微纳产品负责人肖航
面向高阶智驾市场，主动安全能力和智驾功能的稳定性成为各家短期的核心竞争力，但目前主流传感器在光线影响、天气影响和活体识别上的缺陷，给智驾功能带来了极高的不稳定因素，而红外传感器可以提供稳定的感知数据，弥补现存感知缺陷。
据其介绍，针对夜视、雨天、大雪天、眩光、雾天、烟/扬尘等痛点场景，借助红外AI算法，红外传感器表现优异。比如在雾天，红外传感器受干扰较小，能够比较清晰的看到道路结构、车辆、路灯等物体，尤其是进隧道时能够提前观测到隧道内道路情况。
睿创微纳作为国内少有的红外方案供应商，拥有行业领先的红外图像处理算法、行业创新突破AI算法，具备长波、中波、短波红外以及激光、微波、太赫兹等多光谱传感研发能力，发布了全球首款8μm 1920×1080非制冷红外探测器芯片。
围绕《新智能时代的汽车CIS创新》主题，元视芯创始人&amp;CTO郑健华发表了演讲。
元视芯创始人&amp;CTO郑健华
辅助驾驶系统的迭代需求呈多样化，推动了CIS向着低光成像更好、低功耗、高动态、高帧率等方向发展。
在感知层面，无论是纯视觉路线，还是由摄像头、激光雷达、超声波雷达与毫米波雷达等多传感器组成的融合方案，视觉感知都居主要地位，而车载CIS的成熟度相对较高，不仅具备成本优势，还可借助CIS+ISP二合一方案，解决对算法的依赖问题。
元视芯的自研ISP算法，覆盖ISP图像处理全链路（ISP Pipeline）RAW域、YUV域，通过先进的片上ISP功能实现AGC、AEC、降噪、边缘增强等功能，全面提升低照成像效果，对用户使用的痛点做有针对性的改善。
哆来目CPO张启航分享了《人眼仿生技术赋能AEB》主题演讲。
哆来目CPO张启航
他首先介绍了运动信息对环境感知的作用，人眼仿生技术赋能AEB具备高安全、低成本两大优势。
一方面，搭载了人眼仿生技术，可对于任意角度的车辆、无保护左转、鬼探头、近距离加塞等场景进行检测；另一方面，通过双通道感知融合，人眼仿生技术可释放硬件潜能，实现低算力低成本嵌入式平台部署。
值得一提的是，基于人眼的双通道感知机制，哆来目团队研发出了对应的物体识别算法和运动感知算法，并将两种算法深度融合，最后形成了独具特色的视觉仿生技术，可以让搭载其视觉仿生技术的汽车具有人类一样的感知能力。
晟泰克副总经理曹丽松发表了《超声波雷达应用新探索》主题演讲。
晟泰克副总经理曹丽松
随着智能驾驶的发展，2021年-2023年，超声波雷达的单车平均安装数量从4.9颗增加到5.6颗，预计2025年超声波雷达单车平均安装数量将增至7颗，超声波雷达市场进入高速增长期。
不过，随着智能驾驶传感器性能不断集成和提升，也驱动着车载超声波雷达需要寻求新的应用突破。目前，晟泰克围绕毫米波雷达的技术、成本优势，开发出了低速前后向F/RAEB、涉水感应系统、隐藏式超声传感器、后排提醒功能Rear Occupant Alert、电动尾门感应传感器、声波手势识别等新应用。
比如，针对低速F/RAEB，超声波雷达弥补了毫米波雷达在低速和近距离处感知能力下降的问题，提高了防撞系统的可靠性，并且随着AK2超声波传感器的成熟和量产，超声波雷达探测性能已经达到到5.5m。
以《行泊一体感知融合方案演进及落地》为题，魔视智能乘用车产品负责人王淳发表了演讲。
魔视智能乘用车产品负责人王淳
他表示，电子电气架构的集成化趋势明显，其中域融合已然大势所趋，行泊一体必将成为未来市场主流。
其中，魔视智能的一体化域控制器高算力行泊一体方案，能够充分运用算力资源应对自动驾驶任务中多传感器，多模态输入，多任务处理，多尺度分析的底层特性。同时运用自适应的网络设计空间，增加网络模型的大小，提升算法的表现性能，并将深度学习运用于跟踪及预测甚至决策规划和控制，以获取卓越的精度、普适性以及泛化性。
具体到行车视觉感知，魔视智能的深度学习算法能够支持2百万/8百万摄像头输入；而在泊车环视感知，魔视智能的深度学习算法能够支持1百万/2百万摄像头输入，可精准输出停车位地锁、移动障碍物、车辆、行人、交通指示、挡轮杆、可行使区域等全自动泊车系统所必须的感知结果。
复睿智行研发总监李臣云发表了《复睿智行毫米波雷达破局之路》主题演讲。
复睿智行研发总监李臣云
他表示，业界热议的激光雷达与4D毫米波雷达之争，本质上是激光雷达成本下探与4D毫米波雷达的性能提升的竞速。
目前来看，4D雷达需要达到更高的探测灵敏度、更好的俯仰探测能力，以及更远的探测距离，且第“4D”在实际量产应用中还有待推进。而复睿智行通过使用创新超分辨算法，使雷达能够将目标与地面多径分离开，同时准确测出目标高度与地面多径引起的假目表高度，实测数据结果显示，目标轨迹清晰。
相比以往的传感器融合，复睿智行所使用的高性能4D雷达及前融合方案，可提供更真实、更丰富的环境探测信息，可降低逆光和低光照等环境因素对感知结果的影响，以及大幅减少训练所需的样本数据量，降低系统成本，加速智驾功能升级。
亮道智能CMO江南逸带来了《亮道数据工厂解决方案，应对大规模数据真值生产的技术挑战》主题演讲。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07400f5fa04b4d3d50c9cd50ac91a145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35119d2d9ada220ed6c772525ae118cd/" rel="bookmark">
			【思考】技术复合型人才使用之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：1-前言 2-复合型人才用人之道 3-技术复合型人才在智能装备研发领域的优势（BingChat撰写功能）
1. 前言
很多用人单位并不会使用技术复合型人才或者创新复合型人才，或者说用不好这类人才，最终导致了人才流失。首先这类人才有一两个精通专业，多个入门专业。 如果让这类人才同时做两个或者多个专业底层的工作（这不叫重用），他们往往不能胜任入门专业的岗位，不能发挥他们的多专业复合能力。假如把这类人才放在一个技术/项目leader或者产品leader的岗位角色上，他们可以提出一些创新的复合方案，并且带领团队做出创新的产品或者服务。本文将借助AI工具，探索技术复合型人才的用人之道以及这类人才在装备研发领域的优势。
2. 复合型人才用人之道
2.1 如果让一个技术复合型人才同时做多个专业岗位的底层工作会怎么样
2.2 技术复合型人才的用人之道
BingChat 平衡模式
BingChat 精确模式
BingChat 创造力模式-联网
2.3 如何充分发挥技术复合型人才的潜力
2.4 有没有一些具体的例子可以分享？
2.5 技术复合型人才的优势
3. 技术复合型人才在智能装备研发领域的优势（BingChat撰写功能）
智能装备是指能够感知、分析、决策和执行的高端装备，是工业4.0、智能制造和数字化转型的重要支撑。智能装备的研发需要集成多种技术，如机械、电子、控制、软件、人工智能、大数据、云计算等，因此对人才的要求也非常高。技术复合型人才是指具有多种技术领域的知识和能力，能够跨界协作和创新的人才。本文将从以下三个方面分析技术复合型人才在智能装备研发领域的优势。
一、技术复合型人才能够提高智能装备研发的效率和质量
智能装备研发是一个复杂的系统工程，涉及多个技术模块和环节，需要多个专业领域的人才协同配合。如果每个人只懂自己的专业，而不了解其他领域的技术原理和接口规范，就会导致沟通障碍、信息不对称和资源浪费，降低研发效率和质量。而技术复合型人才由于具有多种技术领域的知识和能力，能够理解不同模块之间的功能需求和技术特点，有效地协调和整合各方资源，提高智能装备研发的效率和质量。
二、技术复合型人才能够增强智能装备研发的创新性和竞争力
智能装备是一个快速发展和变化的领域，需要不断地进行技术创新和产品升级，以适应市场需求和用户体验。单一专业领域的人才往往受限于自己的知识范围和思维模式，难以突破现有的技术框架和产品形态。而技术复合型人才由于具有多种技术领域的知识和能力，能够跨界思考和创新，结合不同领域的技术优势和创新点，设计出更加先进和适用的智能装备产品，增强智能装备研发的创新性和竞争力。
三、技术复合型人才能够拓展智能装备研发的应用场景和价值
智能装备是一个广泛应用和高附加值的领域，涵盖了制造业、医疗健康、农业环保、交通物流等多个行业和领域。单一专业领域的人才往往只关注自己所在的行业或领域，而忽视了其他行业或领域的需求和特点，难以将智能装备应用到更多的场景中，提升其社会价值和经济效益。而技术复合型人才由于具有多种技术领域的知识和能力，能够跨界探索和应用，结合不同行业或领域的特征和需求，开发出更加适配和满足用户需求的智能装备产品，拓展智能装备研发的应用场景和价值。
综上所述，技术复合型人才在智能装备研发领域具有明显的优势，能够提高智能装备研发的效率和质量，增强智能装备研发的创新性和竞争力，拓展智能装备研发的应用场景和价值。因此，培养和引进技术复合型人才是智能装备研发领域的重要战略和任务，也是提升我国智能装备产业的核心竞争力和国际影响力的关键因素。
The End
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9997eccc5cf8ebf4e7fee39a825cf573/" rel="bookmark">
			路由器静态IP地址怎么设置？静态独享IP如何让网速更加稳定？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在互联网时代，路由器已经成为了家庭和企业中必不可少的网络设备。而对于一些用户来说，他们可能拥有静态IP地址，希望将其配置到路由器上以获得更稳定的网速。本文将详细介绍如何为路由器设置静态IP地址，以及如何通过静态独享IP让网速更加稳定。
一、路由器静态IP地址的设置
为路由器设置静态IP地址的步骤因路由器的品牌和型号而有所不同，但大体上可以分为以下几个步骤：
1.连接路由器
使用电脑连接到路由器的LAN口，进入路由器的管理界面。
2.找到LAN口设置
在路由器的管理界面中找到“网络参数”或“LAN口设置”选项。
3.修改IP地址
在LAN口设置中，找到“IP地址”或“局域网IP”选项，将其修改为所需的静态IP地址。确保该IP地址与上级网络设备（如光猫、交换机等）的IP地址在同一网段内。
4.保存设置
完成IP地址的设置后，保存设置并退出管理界面。
需要注意的是，在设置静态IP地址时，需要确保该IP地址没有被上级网络设备所使用，以免造成IP地址冲突。另外，不同品牌的路由器可能会有略微不同的设置步骤，具体操作请参考路由器的说明书。
二、通过静态独享IP让网速更加稳定
拥有静态独享IP地址可以让用户的网络更加稳定，从而提高网速。以下是一些建议，帮助用户更好地利用静态独享IP地址来提高网速稳定性：
1.选择可靠的服务商
选择一家可靠的网络服务商，可以确保网络连接的稳定性和速度。建议选择知名的大型网络服务商，以确保服务的品质。
2.合理规划网络布局
在家庭或企业网络中，合理的规划网络布局可以减少网络拥堵和干扰，从而提高网速稳定性。例如，合理布置路由器的位置，以及合理分配各设备的带宽需求。
3.定期维护网络设备
定期对路由器、交换机等网络设备进行维护，可以确保设备的正常运行，避免因设备故障导致的网络不稳定问题。维护内容包括清理灰尘、检查连接线等。
4.使用支持静态IP地址的路由器
选择一款支持静态IP地址的路由器，可以更好地管理和规划网络环境，提高网络连接的稳定性和速度。
5.及时更新软件和固件
及时更新路由器、交换机等网络设备的软件和固件，可以修复可能存在的漏洞和问题，流冠提高设备的性能和稳定性。
总之，通过为路由器设置静态IP地址并合理规划网络布局，用户可以获得更稳定的网络连接和更高的网速。同时，选择可靠的服务商、定期维护网络设备和及时更新软件和固件等措施也可以帮助用户更好地管理和维护自己的网络环境。在使用静态独享IP时，用户需注意保护自己的隐私和安全，防止个人信息泄露和网络攻击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18eeb01928e39174261ce085fd8240c/" rel="bookmark">
			Kubernetes（K8s）命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes（简称K8s）是一种开源的容器编排平台，用于自动化应用程序的部署、扩展和管理。通过Kubernetes，您可以轻松地管理容器化应用，实现高可用性、弹性伸缩以及简化的部署和维护。以下是一份Kubernetes常用命令的大全，以便您更好地理解和操作K8s集群。
1. 集群信息 查看集群节点信息
kubectl get nodes 查看集群组件状态
kubectl get componentstatuses 查看集群事件
kubectl get events 2. 命名空间操作 查看命名空间
kubectl get namespaces 创建命名空间
kubectl create namespace &lt;namespace-name&gt; 切换命名空间
kubectl config set-context --current --namespace=&lt;namespace-name&gt; 3. Pod 操作 查看Pod
kubectl get pods 查看Pod详细信息
kubectl describe pod &lt;pod-name&gt; 创建Pod
kubectl apply -f &lt;pod-definition.yaml&gt; 删除Pod
kubectl delete pod &lt;pod-name&gt; 4. Deployment 操作 查看Deployments
kubectl get deployments 查看Deployment详细信息
kubectl describe deployment &lt;deployment-name&gt; 扩展Deployment副本数
kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;replica-count&gt; 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c18eeb01928e39174261ce085fd8240c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84091893546f3505e2715fe1a4b5af07/" rel="bookmark">
			RFC3261: SIP:12对话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12 Dialogs 12对话 A key concept for a user agent is that of a dialog. A dialog represents a peer-to-peer SIP relationship between two user agents that persists for some time. The dialog facilitates sequencing of messages between the user agents and proper routing of requests between both of them. The dialog represents a context in which to interpret SIP messages. Section 8 discussed method independent UA processing for requests and responses outside of a dialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84091893546f3505e2715fe1a4b5af07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70cfaaa09b97d76754071715d788eab/" rel="bookmark">
			2024最新Java基础面试题大全（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、Session 和 Cookie 有何区别1.1、Session1.2、Cookie1.3、cookie 和 session 的区别 2、equals 和 == 的区别3、netty 和 WebSocket 区别4、WebService5、B/S C/S 什么意思5.1、 什么是B/S ？5.1.1、 B/S的优点和缺点5.2、 什么是C/S呢？5.2.1、 C/S的优点和缺点 6、连接池是什么，有什么作用7、所了解的数据源8、日志级别有几个9、日志是什么？ 有什么作用？9.1日志是什么9.2日志的作用 1、Session 和 Cookie 有何区别 1.1、Session 会话，当用户打开某个web应用时，便与 web 服务器产生了一次 session。服务器使用 session 把用户的信息临时保存在服务器上，用户离开网站后，session 就会被销毁。这种用户信息存储方式相对 cookie 来说，更安全，可是 session 有一个缺陷，如果 web 服务器做了负载均衡，那么下个请求到另一台服务器的时候，session 会丢失
1.2、Cookie cookie是保存在本地终端的数据，cookie 由服务器生成，发送给浏览器，浏览器把 cookie 以 kv 形式保存到某个目录下的文本内，下一次请求网站，会把 cookie 发给服务器，由于 cookie 是存在客户端上，所以浏览器加入了一些限制取保 cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的 cookie 都是有限的。
1.3、cookie 和 session 的区别 cookie 数据存放在客户的浏览器上，session 数据放在服务器上cookie 不是很安全，别人可以分析存放在本地 COOKIE 进行 COOKIE 欺骗，考虑安全应当使用 sessionsession 会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器性能，考虑到减轻服务器性能方面，应当使用COOKIE单个 cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存 20 个 cookie。建议： 将登陆信息等重要的信息存放在 session 中其他信息如果需要保留，可以放在 cookie 中 2、equals 和 == 的区别 初步认识 equals 和 == 的区别 == 是判断两个变量或实例是不是指向同一个内存空间，equals 是判断两个变量或实例指向的内存空间中的值 是不是相同的== 是指对内存地址进行比较，equals() 是对字符串的内容进行比较== 指引用是否相同，equals() 指的是值是否相同 详解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e70cfaaa09b97d76754071715d788eab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b62278dddba9c760a208a26dd400bd3/" rel="bookmark">
			一起来看看Solr全量更新和增量更新的那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Solr全量更新和增量更新 1.背景2. 概述3.同步方式3.1 全量3.2 增量3.2.1.首先要弄懂几个必要的属性，以及数据库建表事项，和dataimporter.properties 、data-config.xml里面的数据3.2.2.数据库配置注意事项3.2.3.dataimporter.properties3.2.4.增量更新就是在全量更新的基础上加上一些配置，data-config.xml配置如下：3.2.5.通过后台管理手动增量更新和通过浏览器手动更新 3.3.1 确定更新点 1.背景 数据如果保留多份，就会存在一致性问题，就需要同步，同步分为两大类：全量和增量
2. 概述 数据如果要保留副本，要么同时写（就是多写），或者进行复制：异步写（即从主数据拷贝到副本）；
同时写（多写），引出一个问题，写多少节点算成功（场景：分布式系统）？全部写成功才算成功，还是写大多数成功算成功，还是写指定几个节点算成功？
异步写的话，如果采用异步复制，那么实时性需要考量的话，就需要采用性能优先的架构。
3.同步方式 数据同步一般分为两种方式：全量和增量。
3.1 全量 全量，这个很好理解。就是每天定时（避开业务高峰期）或者周期性全量把数据从一个地方拷贝到另外一个地方；
全量的话，可以采用直接全部覆盖（使用“新”数据覆盖“旧”数据）；或者走更新逻辑（覆盖前判断下，如果新旧不一致，就更新）；
这里面有一个隐藏的问题：如果采用异步写，主数据物理删除了，怎么直接通过全量数据同步？这就需要借助一些中间操作日志文件，或者其他手段，把这些“看不到”的数据记录起来。
下图便是全量更新：
3.2 增量 增量的基础是全量，就是你要使用某种方式先把全量数据拷贝过来，然后再采用增量方式同步更新。
增量的话，就是指抓取某个时刻（更新时间）或者检查点（checkpoint）以后的数据来同步，不是无规律的全量同步。这里引入一个关键性的前提：副本一端要记录或者知道（通过查询更新日志或者订阅更新）哪些更新了。
3.2.1.首先要弄懂几个必要的属性，以及数据库建表事项，和dataimporter.properties 、data-config.xml里面的数据 &lt;!-- transformer 格式转化：HTMLStripTransformer 索引中忽略HTML标签 ---&gt; &lt;!-- query:查询数据库表符合记录数据 ---&gt; &lt;!-- deltaQuery:增量索引查询主键ID ---&gt; 注意这个只能返回ID字段 &lt;!-- deltaImportQuery:增量索引查询导入数据 ---&gt; &lt;!-- deletedPkQuery:增量索引删除主键ID查询 ---&gt; 注意这个只能返回ID字段 3.2.2.数据库配置注意事项 1.如果只涉及添加，与修改业务，那么数据库里只需额外有一个timpstamp字段 就可以了，默认值为当前系统时间，CURRENT_TIMESTAMP 2.如果还涉及删除业务，那么数据里就需额外再多添加一个字段isdelete，int类型的 用0,1来标识，此条记录是否被删除 3.2.3.dataimporter.properties 这个配置文件很重要，它是用来记录当前时间与上一次修改时间的，通过它能够找出，那些，新添加的，修改的，或删除的记录标识，此条记录是否被删除的记录 3.2.4.增量更新就是在全量更新的基础上加上一些配置，data-config.xml配置如下： 原配置：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;dataConfig&gt; &lt;!-- mysql mydb --&gt; &lt;dataSource type="JdbcDataSource" name="mydb" driver="com.mysql.jdbc.Driver" url="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b62278dddba9c760a208a26dd400bd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd947b6896fdc6ff35344316c846c5e/" rel="bookmark">
			STM32时钟树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、四个时钟源 二、时钟树 各类时钟简括：
1.HSE时钟（高速外部时钟）：来源为外部无源晶振，通常速度8M。
2.HSI时钟（高速内部时钟）：来源为芯片内部，大小为8M，当HSE故障时，系统时钟会自动切换到HSI，知道HSE启动成功，相当于HSE的替补。
3.PLLCLK（锁相环时钟）：来源为HSI/2、HSE经过倍频所得。
4.SYSCLK（系统时钟）：来源为HSI、HSE、PLLCLK，最高速度为72M。
5.HCLK（AHB高速总线时钟）：来源由系统时钟分频得到，速度最高为72M。
6.PCLK1（APB1低总线时钟）：来源为HCLK分频得到，速度最高为36M ，为APB1总线上的外设提供时钟。
7.PCLK2（APB2高总线时钟）：来源为HCLK分频得到，速度最高为72M，为APB2总线上的外设提供时钟。
8.RTC时钟：来源为HSE_RTC（HSE分频得到）、LSE、LSI，为芯片内部的RTC外设提供时钟。
9.MCO时钟输出 ：来源为PLLCLK/2、HSE、HSI、SYSCLK，微控制器时钟输出引脚，由PA8复用所得。
三、系统配置时钟 图中序号1~7对应着系统设置配置的流程
四、HAL库直接使用cubemx软件图形化界面配置 五、常见英文缩写意思 RCC： Reset and Clock Control，即复位和时钟控制。HSE： High Speed External Clock signal，高速外部时钟信号，即是OSC_IN和OSC_OUT接口所接的4~16MHz的晶振，一般接8MHz。LSE： Low Speed External Clock signal，低速外部时钟信号，即是OSC32_IN和OSC32_OUT接口，指外部用于RTC的32.768KHz晶振。HSI： High Speed Internal Clock signal，高速内部时钟信号，出厂校准的8MHz内部RC振荡器。LSI： Low Speed Internal Clock signal，高速内部时钟信号，带有校准功能的40KHz的内部RC振荡器。RTC： Real Time Clock实时时钟，用于带有年、月、日、小时、分钟、秒钟的计时器。PLL：锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。SYSCLK：系统时钟，最高72MHz。AHB：高级高性能总线，这是一种“系统总线”AHB主要用于高性能模块(如CPU、DMA和DSP等)之间的连接。AHB 系统由主模块、从模块和基础结构(Infrastructure)3部分组成，整个AHB总线上的传输都由主模块发出，由从模块负责回应。APB：一种外围总线。APB主要用于低带宽的周边外设之间的连接，例如UART等，它的总线架构不像 AHB支持多个主模块，在APB里面唯一的主模块就是APB 桥。OSC：晶振 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e05748333d417209c8661ab68113399/" rel="bookmark">
			安装阿里云CLI之配置阿里云凭证信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候需要再主机上通过 OpenAPI 的调用访问阿里云，并完成控制，此时就需要在服务器上安装阿里云CLI，并完成账号的设置。
1. 登录阿里云创建账号 1.1 点击阿里云头像 ——》 控制访问 ——》创建一个拥有DNS权限的用户 这个用户不用太多权限，所以有 OpenAPI 的调用访问即可
1.2创建完成后，在用户界面能看到 用户对应的AccessKey ID和AccessKey Secret了（注意，记得保存这两个值，界面更新AccessKey Secret会消失） 1.2.1 如果没有保存导致这两个值消失，点击新创建的用户名称，进入详情页，创建新的来替代 1.3 刷新界面后，可为用户添加权限 1.3.1权限只需要有 阿里云的DNS 操作权限即可 2.进入阿里云主机控制台 2.1 安装 aliyun cli 工具 wget https://aliyuncli.alicdn.com/aliyun-cli-linux-latest-amd64.tgz tar xzvf aliyun-cli-linux-latest-amd64.tgz sudo cp aliyun /usr/local/bin rm aliyun 2.2 将拥有 DNS 权限的角色配置到云服务器中 cd aliyun /usr/local/bin aliyun configure --profile akProfile 配置会进入交互式内容，如下输入完成配置：
Configuring profile 'akProfile' in '' authenticate mode... Access Key Id []: 在这里输入刚新建角色的 Access Key 然后回车进入下一项 Access Key Secret []: 在这里输入刚新建角色的 Access Key Secret 然后回车进入下一项 Default Region Id []: cn-hangzhou Default Output Format [json]: json (Only support json)) Default Language [zh|en] en: Saving profile[akProfile] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e05748333d417209c8661ab68113399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1140d42e74d468c7969ceb2778a329/" rel="bookmark">
			【PHP】TP5 使用模型一对一关联查询，条件筛选及字段过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
方法一：使用Eloquent ORM的with关联查询
方法二：使用JOIN进行查询
方法一：使用Eloquent ORM的with关联查询 在 ThinkPHP5 中，可以使用模型关联和条件查询来实现一对一关联查询。以下是一个示例：
假设有两个表，一个是 users 表，一个是 profiles 表。users 表中有一个 profile_id 字段，用于关联 profiles 表中的 id 字段。
首先，在 User 模型中定义一个 profile 方法，用于关联 Profile 模型：
// User.php public function profile() { return $this-&gt;hasOne('Profile', 'id', 'profile_id'); } 然后，在控制器中使用模型关联查询，并添加条件：
// UserController.php public function index() { // 查询 users 表中的所有记录 $users = User::with(['profile' =&gt; function($query) { $query-&gt;where('address', 'like', '%北京%'); $query-&gt;field('profile_id,title'); }]) -&gt;where('status', '=', 1) -&gt;field('id,nickname') -&gt;select(); // 输出查询结果 foreach ($users as $user) { if ($user-&gt;profile) { echo $user-&gt;name .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1140d42e74d468c7969ceb2778a329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cffc232a9f909a7c86d7fb62bfa439ad/" rel="bookmark">
			Java集合-LinkedList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java集合-LinkedList 特性 public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 1、继承于 AbstractSequentialList ，本质上面与继承 AbstractList 没有什么区别，AbstractSequentialList 完善了 AbstractList 中没有实现的方法。
2、Serializable：成员变量 Node 使用 transient 修饰，通过重写read/writeObject 方法实现序列化。
3、Cloneable：重写clone（）方法，通过创建新的LinkedList 对象，遍历拷贝数据进行对象拷贝。
4、Deque：实现了Collection 大家庭中的队列接口，说明他拥有作为双端队列的功能。
LinkedList与ArrayList最大的区别就是LinkedList中实现了Collection中的 Queue（Deque）接口 拥有作为双端队列的功能
基本属性 链表没有长度限制，他的内存地址不需要分配固定长度进行存储，只需要记录下一个节点的存储地址即可完成整个链表的连续。
//当前有多少个结点，元素个数 transient int size = 0; //第一个结点 transient Node&lt;E&gt; first; //最后一个结点 transient Node&lt;E&gt; last; //Node的数据结构 private static class Node&lt;E&gt; { E item;//存储元素 Node&lt;E&gt; next;//后继 Node&lt;E&gt; prev;//前驱 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cffc232a9f909a7c86d7fb62bfa439ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291f6e91443ea405502777ee8be6f10e/" rel="bookmark">
			Linux系统安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、账号安全基本措施 1.1 系统账号清理 将用户设置为无法登陆
锁定账户
删除账户
锁定账户密码 本地锁定
1.1.1 将用户设置为无法登陆 方法1：chsh -s修改
方法2：usermod -s
1.1.2 锁定用户 usermod -L lisi	#锁定账户 usermod -U lisi	#解锁账户 passwd -l lisi	#锁定账户方 passwd -u lisi	#解锁账户 1.1.3 删除账户 userdel 用户名 #删除用户 1.1.4 chattr 锁定重要配置文件（passwd 、shadow、fstab等） lsattr /etc/passwd /etc/shadow	#查看文件的状态 chattr +i /etc/passwd /etc/shadow	#锁定文件 chattr -i /etc/passwd /etc/shadow	#解锁文件 1.2 密码安全控制 1.2.1 设置密码规则 1.适用于新建用户 vim /etc/login.defs #修改配置文件 -----此处省略部分注释及配置------- PASS_MAX_DAYS 30	#修改密码有效期为30天 2.适用于已有用户 chage -M 30 zhangsan	#修改密码有效期 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291f6e91443ea405502777ee8be6f10e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe70678ad24eb974fa0003b390493c9/" rel="bookmark">
			Electron中调用dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截止目前Electron的官方稳定版本已经更新到了28.1.1。我在创建Electron项目时用的28.0.0版本，后面在项目中有用到调用dll方法的需求，大致的实现就是将后端给的dll文件引入到项目中，安装ffi-napi依赖，然后进行使用。但是在ElectronV21+的时候，官方引入了V8内存隔离区，当再使用ffi-napi这个库的时候就会报错，用尽了一切办法，都未果（如果读者有解决办法可私聊）。最终还是将Electron版本降到了20.3.8。当然ffi-napi这个依赖库官方也没有及时进行维护更新，最近上一次更新已经是三年前了。
所以本篇教程是在Electron版本为20.3.8的情况下完成的，如果读者想找更高版本的教程，那可以不用读了。
一、准备阶段 你需要安装以下内容：
python2npm i node-gypnpm i ffi-napinpm i -g --production windows-build-tools@electron/rebuild 如果在安装windows-build-tools时报错了，请根据报错提示信息找到对应文件夹的exe文件，手动进行安装。
在安装完@electron/rebuild之后，需要到node_modules/ffi-napi目录下 跑rebuild命令 重新编译一下。
至此，准备工作结束。
二、封装ffi-napi模块 注：调用封装好的Dll方法是在主进程中使用，通过渲染进程与主进程通信从而达到调用dll方法的效果。
新建ffi-core.js
const ffi = require('ffi-napi'); const path = require('path'); let binPath = path.join(__dirname, '../binary/core_x64.dll') const bin = ffi.Library(binPath, { Client: ['string', ['string', 'string']] }) module.exports = bin 另新建 api.js
const bin = require('./ffi-core') const { Init, Login } = require('./core') // 此文件根据自己的业务编写 module.exports = { initApp: function() { return Init.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe70678ad24eb974fa0003b390493c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9cf40cfa6dd05582ce752d9496620d/" rel="bookmark">
			maven pom.xml 加载本地.jar库文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般我们使用的jar包,都是从maven仓库中加载的, 那如果是从本地该如何加载呢?
本文介绍maven加载本地jar的方法
在 pom.xml 的 dependencies 节点内增加以下配置即可
&lt;dependency&gt; &lt;groupId&gt;cn.tekin&lt;/groupId&gt; &lt;artifactId&gt;mylib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/lib/mylib_v1.0.0.jar&lt;/systemPath&gt; &lt;/dependency&gt; groupId , artifactId 这个根据你的项目来填写 systemPath 为你的jar文件的本地路径 ${project.basedir}/ 这个为当前项目的根目录路径 变量 完整pom.xml示例
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.tekin&lt;/groupId&gt; &lt;artifactId&gt;demo-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.tekin&lt;/groupId&gt; &lt;artifactId&gt;mylib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/lib/mylib_v1.0.0.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/4/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>