<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660fedf36f71465942ecf50a27a3d087/" rel="bookmark">
			Markdown 使用语法（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要学习Markdown，这篇文章就够了。
Markdow简介 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。
由于 Markdown 的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 如 GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。
工具 这里我们使用 VSCode 编辑器进行 Markdown 的编辑和预览。
实时预览方法：
创建一个测试文件 TEST.md
# Markdown Test ## Hello World! 右键选择“命令面板”
选择／输入 Markdown: Open Preview to the Side 命令：
预览效果：
我们也可以在 VSCode 下安装 Markdown Preview Enhanced 插件来实现更强大的功能。
安装完成后重启 VSCode。
右键选择 MPE:打开侧边预览
效果如下：
在预览框中右击鼠标还提供了各种导出功能
一、Markdown标题 Markdown标题有两格式。
第一种：
一级标题 ======== 二级标题 --------- 第二种：
# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 预览效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/660fedf36f71465942ecf50a27a3d087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc2d18c81fb0c2b2229b1415cdb6e94/" rel="bookmark">
			使用matlab画频数直方图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好的。要在MATLAB中画频数直方图，首先需要准备数据。这些数据可以是一个数组或一个表格。然后，可以使用函数 histogram 来绘制直方图。
例如，假设你有一个名为 data 的数组，包含你想要在直方图中统计的数据。你可以使用以下代码来绘制频数直方图：
histogram(data) 这将绘制一个频数直方图，其中包含数据 data 中的所有值。
您还可以通过指定参数来自定义直方图。例如，您可以使用 'BinWidth' 参数指定直方图中每个 bin 的宽度，或使用 'BinLimits' 参数指定 bin 的范围。您还可以使用 'Normalization' 参数指定是对数据进行归一化(即相对频率)还是绘制原始频数。
例如，下面的代码将绘制一个频率直方图，其中 bin 的宽度为 2，并限制在数据的最小值和最大值之间：
histogram(data, 'BinWidth', 2, 'BinLimits', [min(data) max(data)], 'Normalization', 'probability') 希望这可以帮助你。如果你有更多关于 MATLAB 中绘制直方图的问题，请随时问我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f23d9718fe8177efb0b27486f16b29/" rel="bookmark">
			HAVING的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HAVING子句用于过滤分组之后的数据。
1、如果过滤条件中使用了聚合函数，或行已经被分组，则必须使用HAVING来替换WHERE。否则，报错。
2、HAVING 必须声明在 GROUP BY 的后面。
# 查询各个部门中最高工资大于10000的部门信息 SELECT department_id, MAX(salary) max_salary FROM employees GROUP BY department_id # 对分组后的数据进行筛选，选出部门中最高工资大于10000的部门 HAVING max_salary &gt; 10000; 开发中，我们使用HAVING的前提是SQL中使用了GROUP BY。 如果没有使用GROUP BY，使用HAVING，则整个表中的所有记录会被当成一组，然后对这一组记录根据HAVING中的条件进行筛选。
SELECT department_id, MAX(salary) max_salary FROM employees HAVING max_salary &gt; 10000; HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。 1、当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中。
2、当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以。但是，建议大家声明在WHERE中。 上述两种方式，方式一的执行效率高于方式二，即WHERE的效率会高于HAVING。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d903743512118e9f9b7c024154d48e75/" rel="bookmark">
			报错原因：Not Found The requested URL was not found on the server. If you entered the URL manually please...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误的意思是请求的 URL 没有在服务器上找到。这通常是因为你手动输入了错误的 URL，或者你请求的网页已经被删除或移动到了其他地方。建议检查一下你输入的 URL 是否正确，如果问题仍然存在，建议联系网站管理员或者网络管理员获取帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54aca35a6c954b6acf920f8f63ecf0e8/" rel="bookmark">
			DOTA数据集制作——and_训练train.py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按官方搭建处理环境
https://github.com/CAPTAIN-WHU/DOTA_devkit
https://github.com/hukaixuan19970627/DOTA_devkit_YOLO
问题
ERROR: pip's dependency resolver does not currently take into account all the packages that are installed #3383 解决
Before you install your extension, just follow the prompts pip install h5py pip install typing-extensions pip install wheel and then install your extension 问题
(virtual) juniper@D:~/yolov5_poly/DOTA_devkit_YOLO$ python ImgSplit_multi_process.py Traceback (most recent call last): File "ImgSplit_multi_process.py", line 10, in &lt;module&gt; from dota_utils import GetFileFromThisRootDir File "/home/juniper/yolov5_poly/DOTA_devkit_YOLO/dota_utils.py", line 6, in &lt;module&gt; import shapely.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54aca35a6c954b6acf920f8f63ecf0e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c58bed6b1a8c42d84d827c78b2dd94/" rel="bookmark">
			告诉上述代码报错的原因onnxruntime.capi.onnxruntime_pybind11_state.InvalidArgument: [ONNXRuntimeError] : 2 : INV...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误的原因是输入的数据类型和预期的数据类型不匹配。根据错误信息，实际输入的数据类型是 unsigned 8-bit integer (tensor(uint8))，而预期的数据类型是浮点数 (tensor(float))。这意味着模型期望输入浮点数，但实际上输入的是无符号 8 位整数。因此，需要确保输入的数据类型与模型期望的数据类型相匹配，才能避免这个错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05089fa6f9807683f0fac12ffc21f160/" rel="bookmark">
			ceph集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 1.1、服务器准备 操作系统服务器IP服务器规格centos7.6192.168.161.114C/8Gcentos7.6192.168.161.124C/8Gcentos7.6192.168.161.134C/8G 1.2、服务器环境准备 1.2.1 更改主机名并添加映射 更改主机名 [root@localhost ~]# hostnamectl set-hostname ceph01 ##或者临时更改hostname ceph01 [root@localhost ~]# su 添加映射关系 [root@ceph01 ~]# vim /etc/hosts 192.168.161.11 ceph01 192.168.161.12 ceph02 192.168.161.13 ceph03 1.2.2 更改，关闭防火墙规则，并且制作免密登录 关闭增强 [root@ceph01 ~]# vim /etc/sysconfig/selinux ##永久关闭 SELINUX=disabled [root@ceph01 ~]# setenforce 0 ##临时关闭 关闭防火墙 [root@ceph01 ~]# systemctl disable firewalld --now Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. [root@ceph01 ~]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05089fa6f9807683f0fac12ffc21f160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e763c1a67735a77f9c6c5786a57e19b/" rel="bookmark">
			毕业设计-基于机器车辆行人闯红灯检测系统 -YOLO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
课题背景和意义
实现技术思路
基于 YOLO 的车辆行人闯红灯检测系统设计
1、数据集的制作
2、基于 YOLO 目标检测算法的软件设计
实现效果图样例
最后
前言 📅大四是整个大学期间最忙碌的时光,一边要忙着备考或实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。近几年各个学校要求的毕设项目越来越难,有不少课题是研究生级别难度的,对本科同学来说是充满挑战。为帮助大家顺利通过和节省时间与精力投入到更重要的就业和考试中去,学长分享优质的选题经验和毕设项目与技术思路。
🚀对毕设有任何疑问都可以问学长哦!
选题指导: https://blog.csdn.net/qq_37340229/article/details/128243277
大家好,这里是海浪学长毕设专题,本次分享的课题是
🎯基于机器车辆行人闯红灯检测系统 -YOLO
课题背景和意义 深度学习技术凭借其卓越的特征提取能力，在目标检测、图像分类等领域取得了良好的表现，在很多情况下甚至超越了人类的判别能力，掀起了一波深度学习技术的浪潮。深度学习技术在目标检测领域的发展进一步推动了智能交通技术的发展，这些技术的应用给人们的生活带来很多的便利。目前应用最为广泛的闯红灯抓拍系统的主要原理是，电子眼采用感应线来感应路面上的汽车传来的压力，通过传感器将信号采集到中央处理器，送寄存器暂存（该数据在一个红灯周期内有效）。如果在同一个时间间隔内（红灯周期内），同时产生两个脉冲信号，即视为“有效抓拍”。 这种检测方式虽然简单有效，但在对交通管理更加严格的今天，其弊端也十分明显。受传统闯红灯抓拍系统工作原理的限制，交通路口的感应线主要是通过压力感应判断是否有机动车越线，在一个红灯周期内，当路口两边的感应线先后感应到车辆通过，且两边的电子眼抓拍到的为同一车辆时，即认为该车辆闯红灯。虽然该方案具有高效、精确的特点，但面对重量较轻的非机动车辆和行人时，很难有效发挥作用，所以基于深度学习研究车辆行人闯红灯检测系统是什么有必要的。 实现技术思路 基于 YOLO 的车辆行人闯红灯检测系统设计 设计一套采用微计算机 Jetson Nano 为核心的硬件的检测系统，通过将 YOLO 算法训练的模型部署到微计算机上，对 CSI 摄像头实时采集的图片进行处理，实现对车辆和行人目标的识别检测。 硬件设计 为了实现该系统的功能，充分结合交通路口的复杂环境， 文中选用了：微计算机 Jetson Nano 、电源供电模块和 CSI 摄像头。此外，在系统设计中还运用了一些辅助硬件，这些辅助硬件虽然没有直接构成系统，但也发挥了重要作用。 微计算机 Jetson Nano 微计算机是整个系统的核心和大脑，系统所有的软件算法都是在该硬件上运行。Jetson Nano 是英伟达公司出品的一款人工智能开发板，对比其他同价位微计算机，具有低成本，高 AI 算力的优点，在运行深度学习模型上有很大的优势，并且具有丰富的接口，包括以太网口、CSI 接口和 GPIO 接口，可以进行扩展和连接其他设备。 电源供电模块与 CSI 摄像头 在只具备 220V 交流电市井电压的交通路口，为了给额定输入为 5V4A 直流电的 Jetson Nano 供电，设计了一个体积小、成本低、稳定性高的电源供电模块。 辅助硬件设备 对于模型的训练，需要大量的数据集和大算力的 GPU 平台。因此，在系统设计的过程中，为了采集足够多的路口实景图像做数据集，采用了星瞳科技的OpenMV4 视觉传感器进行定时连拍，以获取大量路口图像。 1、数据集的制作 训练模型需要含有大量图像及其标注的数据集，包括训练集、验证集和测试集，因此，在系统设计的过程中采用了三种方法采集图像。一是通过算法筛选出现有的 MS COCO 数据集中具有较多行人、交通灯与车辆目标的图像作为数据集。二是通过 python 爬虫从网络上爬取相关图片。三是通过一些视觉传感器。 2、基于 YOLO 目标检测算法的软件设计 1）YOLOv5s 网络结构与损失函数 鉴于微计算机所配置的硬件、运算能力有限，难以为车辆行人检测提供较大算力的情况，而且从节约成本各方面考虑， 采用轻量级的 YOLOv5s 网络算法结构。 YOLOv5s 网络结构由四个部分组成：Input、Backbone、 Neck 和Head ，其中 Backbone 和 Neck 部分是重点部分。在 Backbone部分中，主要使用 Focus+CSP 结构。 YOLOv5 的损失函数由分类损失（classification loss）、定位损失（localization loss）和置信度损失（ confidence loss ）三部分构成，总的损失函数为三类损失之和。YOLOv5 采用了 BE- CLogits 损失函数计算 objectness score 的损失，而 class prob-ability score采用了交叉熵损失函数(BCEclsloss)，bounding box采用了 GIOU Loss 计算损失，GIOU 直接把 IoU 作为回归的损 失，可表示为： 2）闯红灯检测区域设计算法 在闯红灯检测中，只有在路口确定是红灯，且存在车辆或行人通过路口，才能视其为闯红灯 通过 OpenCV 库设计相应算法检测出交通灯为红灯，并规划出相应区域，配合 YOLO 网络模型对区域内进行目标检测，即可完成对闯红灯的车辆与行人目标的检测 。 实现效果图样例 在对模型的训练完成后，首先分别测试了其对行人与交通灯等小目标的检测能力和对车辆等大目标的检测效果，得出结果precision 为 81.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e763c1a67735a77f9c6c5786a57e19b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10328f4a9ced004c32be04ab846bb5f3/" rel="bookmark">
			微信小程序框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		框架 小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。
整个小程序框架系统分为两部分：逻辑层（App Service）和 视图层（View）。小程序提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。
响应的数据绑定 框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。
通过这个简单的例子来看：
在开发者工具中预览效果
&lt;!-- This is our View --&gt; &lt;view&gt; Hello {{name}}! &lt;/view&gt; &lt;button bindtap="changeName"&gt; Click me! &lt;/button&gt; // This is our App Service. // This is our data. var helloData = { name: 'Weixin' } ​ // Register a Page. Page({ data: helloData, changeName: function(e) { // sent data change to view this.setData({ name: 'MINA' }) } }) 开发者通过框架将逻辑层数据中的 name 与视图层的 name 进行了绑定，所以在页面一打开的时候会显示 Hello Weixin!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10328f4a9ced004c32be04ab846bb5f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8df595e66686e0bccbfb0deeb747609/" rel="bookmark">
			RabbitMQ延迟列队的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 延迟队列使用场景
2. RabbitMQ中的延迟队列实现思路
3. 实现示例
3。运行项目测试
1. 延迟队列使用场景 延迟队列一般可用于具有时间限制的任务，例如：限时优惠，超时的订单处理等。
对于这种场景，传统的处理方式是任务轮询：通过一个后台任务不断的扫描订单信息，发现有超时订单则进行处理，这种处理方式的优点是实现思路简单，容易把握，缺点是对服务器及数据的压力比较大（因为通常需要扫描大量的数据）。
处理这种场景的第二种方式就是通过延迟队列。消息生产者生成消息并放入队列后，要经过指定的延时时间后消息的消费者才能消费消息。
2. RabbitMQ中的延迟队列实现思路 在RabbitMQ中并没有直接支持延迟队列，没有对应的属性可以设置，在RabbitMQ中实现延迟队列的基本思路是：通过死信队列（DXL）和过期时间（TTL）来实现延迟队列。
即：给队列设置一个过期时间并指定一个死信交换机与其关联，消息生产者的消息发送给队列，但不指定消息消费者，等待消息过期，消息过期后会被转发到相关联的死信队列中，而消息消费者则从死信队列中消费消息。
3. 实现示例 总体思路：
声明死信交换机，队列， 并将队列绑定到死信交换机。声明发送消息的交换机，队列（按照业务需求设置队列的过期时间，但该队列不需要消息消费者），并将队列与交换机关联。编写业务代码通过第2步创建的交换机发送消息到队列。（ 观察消息过期后将过期的消息转存到死信队列中）编写消息消费者，消费死信队列中的消息。（在实际项目中该消息消费者就是延迟任务的处理程序） 具体步骤
准备工作
首先准配RabbitMQ服务器 具体步骤
有道云笔记
springboot 版本2.7.7
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; application.properties 配置文件
server.port=8081 ## rabbitmq config spring.rabbitmq.host=192.168.164.128 spring.rabbitmq.port=5672 spring.rabbitmq.username=xhz spring.rabbitmq.password=123 spring.rabbitmq.virtual-host=my_vhost ## 消费者数量 spring.rabbitmq.listener.simple.concurrency=10 spring.rabbitmq.listener.simple.max-concurrency=10 #消费者每次从队列中获取的消息数量 spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8df595e66686e0bccbfb0deeb747609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79808447805f5c19dc52d4e32b066cf/" rel="bookmark">
			搭建Mybatis核心配置文件和mapper接口和映射文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心配置文件 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。
将来整合Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息 核心配置文件存放的位置是src/main/resources目录下
核心配置文件的内容，去官方文档可以找到相关的内容复制。
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!--xml约束规定当前配置文件中使用哪些标签--&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!-- 配置连接数据库的环境 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 事务管理器 --&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!-- 数据源：管理数据库连接 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ssm?serverTimezon=UTC"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 通过读取核心配置文件，获取操作数据库对象，就可以直接执行sql，sql语句在映射文件中， 所以一定要把当前映射文件配置到核心配置文件中，才可以加载核心配置文件找到相对应映射文件中的sql去执行，所以要引入mybatis的映射文件。 --&gt; &lt;mappers&gt; &lt;mapper resource="映射文件"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 创建mapper接口 MyBatis中的mapper接口相当于以前的dao。
但是区别在于，mapper仅仅是接口，不需要 提供实现类，
可以通过mybatis一些功能为它创建代理式实现类，当我们去调用接口中的方法，
就可以直接帮助我们对应一个sql语句来执行这个sql语句。 接口起名：例如：一个表名t_user，当前对应实体类叫做User类，mapper接口叫做UserMapper。
创建MyBatis的映射文件 一个mapper接口对应一个映射文件中的sql语句 映射文件命名规则：和mapper接口最好同名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79808447805f5c19dc52d4e32b066cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe8dd3f5783ed23eae3e5f3a936a2778/" rel="bookmark">
			基于CNN-Lstm负荷预测（Python代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓个人主页：研学社的博客 💥💥💞💞欢迎来到本博客❤️❤️💥💥
🏆博主优势：🌞🌞🌞博客内容尽量做到思维缜密，逻辑清晰，为了方便读者。
⛳️座右铭：行百里者，半于九十。
📋📋📋本文目录如下：🎁🎁🎁
目录
💥1 概述
📚2 运行结果
🎉3 参考文献
🌈4 python代码、数据
💥1 概述 利用cnn-Lstm提取深层特征，concatenate进行特征融合，进入attention机制，最终输出负荷数值
input.py为读取原始数据，输入的数据为校园综合能源系统数据
attention_model.py输入冷、热、电负荷，提取深层特征，加入attention机制，观察结果，模型流程图保存在attention_model.png
multi_attention_model.py分别利用cnn-Lstm提取冷、热、电负荷深层特征，concatenate进行特征融合，进入attention机制，最终输出负荷数值，模型流程图保存在multi_attention_model.png，bar_1.png为权重柱状图。
📚2 运行结果 部分代码：
# # 单独训练电负荷模型，提取电负荷深层特征 # model, middle = elec_model() # model = load_model("./elec.h5") # model.summary() # middle = load_model("./elec_feature.h5") # elec_feature = middle.predict(X_test[0, :, 0].reshape((1, 24, 1))) # print("------------------------") # print("elec_feature.shape: ", elec_feature.shape) # (712, 24, 48) # print(elec_feature) # # # weight_Dense_1 = model.get_layer('elec_feature').get_weights() # # weight_Dense_1 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe8dd3f5783ed23eae3e5f3a936a2778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1361069c214b87ffd01c35e146ad4ca/" rel="bookmark">
			FCN网络详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考视频：FCN网络结构详解(语义分割)_哔哩哔哩_bilibili
FCN是首个端对端的针对像素级预测的全卷积网络 这是作者提出的网络中的输出对比图，可以看到当FCN-8s效果接近真实分割图。
普通卷积分类网络与FCN对比 在这个模型提出之前，我们来看一下普通的卷积分类网络模型结构如下图。
图片中的数字表示的是输出图片的通道数，网络通过卷积下采样得到图片特征，从4096那层开始为全连接层，21是因为使用的PASCAL VOC数据集有20个种类，加上背景一共21个分类，再对这个输出进行上采样，得到与原图相同大小的图片，对它进行softmax处理，输出每一个像素的最大概率分类。
这个网络在当时有一个弊端就是输入图片大小必须相同。有人就想用卷积层去替代后面的三层全连接层，FCN也就是这样产生的。
FCN
如图，将全连接层替换为卷积层后，实际上最后一层4096那一层输出特征会是1000通道的二维图片，高和宽大于1，这样对于每一个通道的数据实际就是2D的数据，这样就能对其可视化了。
为了说明白是如何替换成卷积层的，我们先来看4096通道前面那部分模型结构，也就是VGG16模型，如下图：这里的VGG16指D的配置
分析：从224*224到7*7图片下采样了32倍
全连接层如何转化为卷积层 第一个全连接层转化为卷积层
为了方便连接我们忽略偏执：
如图上面为全连接层，有4096个结点，当上一层展平时得到7*7*512=25088个参数
下面为卷积层，使用的是7*7*4096的卷积核，这样得到1*1*4096的输出，对于一个卷积，参数也为25088
因为参数相同，所以我们可以对上面全连接层的参数进行reshape处理，这样就能构建卷积层，同时因为这样，卷积层处理过的特征相比全连接层保留了高和宽。
（注：图片中的padding可调是指可以对7*7*512输出图片进行处理，一般这个padding为3是为了防止全连接层之前的输出为1*1，这样padding后也能继续处理了。）
接下来的第二个第三个全连接层的处理一样。
FCN-32s、FCN-16s、FCN-8s模型详细讲解 我们先看一张原论文中的一张表如下：
从表中可以看到从FCN-32s到FCN-8s模型，准确率是逐渐提高的。
下图为一张FCN-32s、FCN-16s、FCN-8s的模型整体结构图
图中的FCN-32s其实是对输出的图片进行上采样32倍得到的，因此成为FCN-32s，其他同理也是上采样16倍和上采样8倍。
FCN-32s 分析：图中VGG16Backbone指7 * 7 * 512那一层包括那一层之前的网络结构，经过前面的网络我们得到的是下采样了32倍的特征图。FC6为全连接层改成的第一个卷积层，这一层会padding = 3，所以经过这层图像大小还是h/32,w/32,又采用了4096个卷积所以又4096个通道，然后经过1 * 1的卷积层，输出特征图大小不变，再输入一层大小为1*1卷积核为要分类个数大小的卷积层，接下来用转置卷积上采样32倍，这里括号里面有双线性插值（双线性插值_太阳花的小绿豆的博客-CSDN博客_双线性插值）来初始化转置卷积。
FCN-16s 分析：前面基本和FCN-32s一样，只是上面输出时先对其上采样2倍得到[h/16,w/16,num_cls]大小的特征图，下面Maxpool4（这是VGG16 14 * 14 *512那一层的输入特征图）的输出经过一个1*1num_cls大小的卷积层，得到[h/16,w/16, num_cls]大小的特征图，最后将上面和下面的输出相加进行16的上采样得到最后的heatmap。
FCN-8s 分析：前面基本与FCN-8s和FCN-16s基本相同，基本类似。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae737ef9bdab7ed21cdbdf4cff30a40b/" rel="bookmark">
			vscode下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先在官网下载 vscode：Download Visual Studio Code - Mac, Linux, Windows 一般选择windows，User Installer x64（注意哦，x64是说64位的，x86是32位的）
不过下载的很慢，解决办法，用IDM，免费试用30天 ，注意到下面官网
安装这个软件不能到d盘只能下载到c盘，点击是
安装成功后，浏览器会自动出现图标
此时再到官网去下载vscode，点击下载，会出现下列界面
安装
把这些都选上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857ddaa70deed375302fb2f8bad87651/" rel="bookmark">
			Android 权限管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android权限管理分为两种：
SDK&lt;23:在manifest中声明，安装时赋予所有声明权限，不同意则不安装；
SDK&gt;=23:
1、普通权限、声明即可直接赋予，不会在设置中显示给用户；
2、危险权限和特殊权限，需要声明且发送请求用户授权的intent，可自由开关每个权限；
系统中的定义权限位置在：
framework/base/core/res/AndroidManifest.xml
framework/base/data/etc/platform.xml
一、权限级别(ProtectionLevel) 1.1 Normal android:protectionLevel="normal"
对用户隐私或者安全都不会带来影响
1.2 Dangerous android:protectionLevel="dangerous"
需要在mainifest中声明且发送请求用户授权的intent，赋予某个组中的其中一个权限，自动赋予组内其他所有权限；
可用命令adb shell pm list permissions -d -g查看
1.3 Signature android:protectionLevel="signature"
两类应用可使用
1.只有和定义了这个权限的apk用相同的私钥签名的应用才可以申请该权限
2.与系统签名相同的system app，即与厂商签名（厂商ROM中的系统app签名）相同的app
1.4 SignatureOrSystem android:protectionLevel="signature|privileged"
三类应用可使用
1.只有和定义了这个权限的apk用相同的私钥签名的应用才可以申请该权限
2.与系统签名相同的app，即与厂商签名（厂商ROM中的系统app签名）相同的app
3.任意app只要标记了privileged(可暂理解为放到了/system/priv-app)就可以使用signatureOrSystem级别的权限
1.5 install权限和runtime权限 install权限：
安装时权限，是指在安装app的时候，赋予app的权限。normal和signature级别(包括SignatureOrSystem)的权限都是安装时权限。不会给用户提示界面，系统自动决定权限的赋予或拒绝。
runtime权限：
运行时权限，是指在app运行过程中，赋予app的权限。这个过程中，会显示明显的权限授予界面，让用户决定是否授予权限。dangerous权限就是运行时权限。(以下主要针对SDK&lt;23时dangerous权限就变成了install权限)
二、app种类 1、system app (有ApplicationInfo.FLAG_SYSTEM标记)
2、privileged app (有ApplicationInfo.FLAG_SYSTEM和ApplicationInfo.PRIVATE_FLAG_PRIVILEGE两个标记)
2.1 system app system app 定义很明了，就是在PMS初始化安装app的时候赋予了ApplicationInfo.FLAG_SYSTEM这个标记
1、特定shareUID的app
代码在PMS的构造函数中
mSettings.addSharedUserLPw("android.uid.system", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw("android.uid.phone", RADIO_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw("android.uid.log", LOG_UID, ApplicationInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/857ddaa70deed375302fb2f8bad87651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313b56b722cf933bea7d59ff826c251f/" rel="bookmark">
			EasyClick IOS 脱机版脚本自动化测试工具发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档地址:https://ieasyclick.com/iostjdocs
开发工具:idea
iOS 脱机版本产品介绍 苹果手机免越狱免硬件自动化脚本编程软件，适合游戏自动化、办公自动化、自动化测试等一系列需要自动处理的事项
相对于市面上其他的产品，EasyClick iOS脱机版是免越狱的，免硬件的，无需越狱和外置硬件即可运行脚本
支持H5网页模式做出漂亮的UI
iOS 脱机版产品特性 简单易编程
丰富的API,图像识别,免费OCR
可打包独立的ipa进行安装到手机
支持免越狱、免硬件运行
智能IDE编程支持
支持 免越狱、免硬件 iOS 14.6+ ~ 16.0+
支持所有点击动作在坐标区域内随机
支持色块、颜色查找
支持控件查找，非找坐标模式，更加智能
支持OpenCV图像匹配识别技术，图像识别率95%以上
...
工具特性 使用JavaScript语言开发，更容易上手
所有Java的类库都适用，无需重复编写代码
智能IDE支持，屏幕实时同步
自带日志查看功能，实时查看运行结果
......
EasyClick iOS脱机版能做什么 App爬虫等
自动化测试App
数据提取
营销软件开发
...
EasyClick iOS脱机版适合人群 有意学习自动化测试脚本的人员
希望用自动操作代替手动的人员
企业App测试团队及测试人员
从事爬虫行业的研发人员
技术交流群 Q群1: 777164022 Q群2: 922739785 Q群3：647082990
Q群4: 772810035 Q群5: 484379843 Q群6：435253761
老冷编程学院 http://bbs.laoleng.vip
EC 安卓VIP教程 http://bbs.laoleng.vip/forum.php?mod=viewthread&amp;tid=34
EC IOS 脱机版 VIP教程 http://bbs.laoleng.vip/forum.php?mod=viewthread&amp;tid=275
EC IOS USB版 VIP教程 http://bbs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/313b56b722cf933bea7d59ff826c251f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e48a550342e4705f29f92554ff93d3/" rel="bookmark">
			InputStream转byte[]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InputStream转byte[]其实是比较简单的，直接使用IOUtils就可以了：
byte[] bytes = IOUtils.toByteArray(inputStream); 又或者说这样：
public static byte[] toByteArray(InputStream input) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream(); byte[] buffer = new byte[1024*4]; int n = 0; while (-1 != (n = input.read(buffer))) { output.write(buffer, 0, n); } return output.toByteArray(); } 但是需要注意的是，将InputStream粗暴地转成byte[]，只适用于文件较小的时候，当如果文件有好几个G，再这样转，内存就要溢出了。
如果我们需要把InputStream保存到本地，在遇见较大的文件时可以试试使用IOUtils.copy，它会一点点搬，默认一次性应该是读8k左右：
InputStream is = downloadClient.download(downloadDTO); if(is == null){ LOGGER.info("is == null"); } //文件下载路径 String tempDirPath = PathTool.absolutePath(); LOGGER.info("file download path:"+tempDirPath); File tmpDir = new File(tempDirPath); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e48a550342e4705f29f92554ff93d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000438563832d5fd5978802d1b46d2ee/" rel="bookmark">
			十六进制转ASCII码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		`/十六进制转成ASCII码/
u8 HexToAscill(u16 *hex, u8 *ascillbuf, u8 buflenth)
{
u16 phex=*hex;
u8 i=1;
for(i=0;i&lt;buflenth;i++)
{
ascillbuf[i] = 0;
}
i = 1;
if(&amp;ascillbuf[buflenth-1] == NULL || phex==NULL)
{
for(i=0;i&lt;buflenth;i++)
{
if(ascillbuf[i]==0)
{
ascillbuf[i] = 0 + ‘0’;
}
}
return 0;
}
while(phex!=0)
{
if((phex)%16&lt;=9)
{
ascillbuf[buflenth-i] = (phex)%16 + ‘0’;
}
else
{
ascillbuf[buflenth-i] = (phex)%16 + ‘7’;//将10进制的phex转换成16进制取其个位+'7’ASSCII
}
phex = (phex)/16;
i++;
if(buflenth&lt;i)
{
break;
}
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000438563832d5fd5978802d1b46d2ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b3c26359156821b80fe8fd9d9f98b5/" rel="bookmark">
			Intellij IDEA导入eclipse web项目详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图解eclipse web项目如何导入到Intellij IDEA中
工具版本说明：
Intellij IDEA2018.2tomcat7JDK1.7 1.项目导入 | 打开idea，选择import Project；或者在以及打开的Idea项目界面选择File - New - Project from Existing Source...;
2.项目导入 | 在弹出的Select File or Directory to import框里选择你要导入的eclipse web项目源文件（这里要导入的是DataExchangeCenter）
3.项目导入 | 下面无需更多的操作，一路 Next 就可以了
这里是选择导入的此项目运行的环境，这里JDK版本默认选择1.7，指定jdk路径
最后点击 Finish,这个项目到此就已导入完成
4.项目配置 | 打开File - Project Strunture 或者点击图1 处，选择Artifacts,点击上面的“+”号
5.项目配置 | 按照图示选择Archive - For"**********"
6.Tomcat配置 | 选择Add Configuration... - "+" - Tomcat Server - Local 进行tomcat配置（如图）。
7.Tomcat配置 | 进入配置页面首页选择Deployment - 下面 “+”号，然后选择Artifacet （指定tomcat编译项目）
在这里选择第一个编译文件，这两者的区别在这里先不做解释
右侧Application context 中填写的是运行项目后，访问项目是否需要在连接中填写项目名称，这里默认是不填写的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7b3c26359156821b80fe8fd9d9f98b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2764b9833b2f06385de76b2b38c25fb2/" rel="bookmark">
			怎么从git上clone项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开终端 cmd 2、输入 git clone + 项目地址 3、cd 到克隆下来的项目文件夹 4、安装依赖（npm install) 5、运行项目 （npm run serve)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cae2664f7d91317bf299a3bd8898925/" rel="bookmark">
			Oracle ORA-01861: 文字与格式字符串不匹配 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Oracle ORA-01861: 文字与格式字符串不匹配 解决方法 解决方式
注意：请根据自己在oracle插入的格式进行选择
--把添加的时间格式换成使用todate进行格式化 to_date('2023-01-01','yyyy-mm-dd') to_date('2023-01-01 10:10:10' , 'yyyy-mm-dd hh24:mi:ss') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d0c4220e717298c59786d2e2bca1b5/" rel="bookmark">
			事件相机（event camera）概述与应用（随笔）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、事件相机的相关概念 事件相机是具有微秒反应时间的仿生传感器，可记录每像素亮度变化的异步流，称为“事件”。事件相机通过检测每个像素的亮度变化来生成一个事件，相比于传统相机，更适合在高动态和高速度的环境下使用，具有高动态范围 (HDR)、高时间分辨率和无运动模糊的优势。因此，事件相机在机器人技术和计算机视觉方面具有巨大潜力，可用于传统相机具有挑战性的场景，例如高速和高动态范围，以及快速机器人定位和可穿戴应用（如 AR/VR 和游戏）的理想传感器
如何通俗的解释事件相机？ 在人的眼睛中，有一部分视觉神经对动态的目标很敏感，比如说在一个处于静态的房间中，如果有一个东西发生运动，那么视线会立刻被运动的物体所吸引，事件相机也一样，它能够很迅速的捕捉到运动中的物体，并且仅仅对运动的物体感兴趣。事件相机回传的信息我们称为事件。
二、事件相机的优势 1. 高动态范围：对于传统相机来说，在黑暗的情况下，传统的相机几乎没有办法使用，但对于事件相机来说，只检测正在运动的物体，所以无论是黑暗情况还是有光亮的情况，事件相机都可以发挥作用。
2. 低延时:相邻事件之间的时间可以小于1毫秒
3. 无运动模糊：即使是高速运动的物体，事件相机也可以捕获到
事件相机在机器人技术、计算机摄影和计算机视觉领域得到了极大的关注。它们对运动模糊，低延迟和高动态范围的固有鲁棒性，对于机器人应用是有吸引力的。这些特性有利于电力线检查任务，以防无人机需要执行敏捷操作，例如避免电力线桅杆。然而，由于其非传统的输出，事件摄像机也提出了新的挑战。
三、事件相机的应用： 1. 基于事件的相机产生稀疏的事件流，延迟更低，从而实现超快的视觉驱动控制
2 .用事件相机来跟踪电力线
3 .想法是把传统相机和事件相机结合起来，但是传统的循环神经网络 (RNN) 不是为来自附加传感器的异步和不规则数据而设计的，因此引入了循环异步多模态网络（RAM）结合事件和帧进行单目深度预测，该方法比最先进的方法提高了30%。
4 .从事件中学习单目密集深度，由于大多数现有方法使用标准的前馈架构来生成网络预测，而不利用事件流中存在的时间一致性，就提出了一个循环架构来解决此问题。
5. 基于事件的异步稀疏卷积网络，模式识别算法通过将事件转换成同步密集、类似图像的表示，在事件相机方面取得很大进展，但也有缺点，因此提出了一个通用框架，用于在类似图像的同步事件表示上训练的模型转换为具有相同输出的异步模型，从而可以直接利用事件数据的内在异步和稀疏的特性，从而降低神经网络的复杂性和延迟
6. 带有事件相机的四旋翼飞行器的动态避障
7. 基于事件的角速度回归与尖锋神经网络SNN，SNN可以处理来自基于事件的异步传感器的输出
8. 使用事件相机实现四旋翼的低延迟高带宽控制
9. 带有事件摄像机的高速和高动态范围
10. 带有事件相机的无人机进行避障
11. 基于事件的视觉的损失函数
12. 使用立体事件相机进行半密集 3D 重建
13. 事件相机的连续时间视觉惯性里程计
四、其他 1. 本人在调查与运用事件相机时，主要研究的是DAVIS（DAVIS346），将传统动态像素传感器APS(Active Pixel Sensor)和DVS做到一个像素，由DVS进行触发。DAVIS就是在回传事件的同时还可以回传灰度图。
2. 事件相机输出的事件流是一个四元组的序列：，像素点坐标、时间戳、事件极性包含了一个事件的所有信息，其中像素坐标告诉了我们事件发生的位置，时间戳则是指明了事件发生的事件，事件极性表示了事件的性质，有+1和-1，+1为变亮事件，-1为变暗事件。（引用的别人的一句话，我觉得写的很好，侵权删除）
3.　事件相机的一些资料
下载事件相机的网页Get Started · DV事件相机的官网，如何使用，下载视频：Visualize and Record · DV事件相机的一个论坛https://groups.google.com/g/dv-users事件相机CVPR：CVPR 2021 Workshop on Event-based Vision 本人是刚刚学习事件相机的小白，正在做目标检测方向，现在已经完成了将事件相机生成的文件格式（.ａｅｄａｔ4）转化成图片（.ｂｍｐ）以及视频（.ａｖｉ）的格式，并用YOLOV5进行了检测。希望能与诸多大神一起交流事件相机的应用和发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ebd57da4d53f86a872a91043896153/" rel="bookmark">
			Centos7安装mysql（超简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装命令（一条一条执行）
sudo yum remove mariadb-libs.x86_64 #移除mariadb
Wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm #下载mysql源
yum localinstall mysql57-community-release-el7-8.noarch.rpm #安装mysql源
yum search mysql #可以查看mysql的源
yum install mysql-community-server #安装mysql
service mysqld start / restart #启动mysql服务
ps -ef | grep mysql #查看mysql的进程
==========================================================
安装完成后，需要重置密码才能对mysql进行使用。因为mysql的密码初始是随机生成的。
进入数据库 mysql - uroot -p
此时会提示输入密码
查看原始密码的命令 ，以下两条均可
grep "password" /var/log/mysqld.log cat /var/log/mysqld.log | grep password
登录进去也不可操作，提示需重新安装。执行如下命令
set PASSWORD = PASSWORD('123456'); //123456是密码
Exit退出再登录即可操作数据库。
mysql - uroot -p123456
show databases;
use table;
然后就可以使用表了。命令跟在windows一致。
20221227--------------------
参考地址 阿里云服务器安装mysql_程序猿二鍋頭的博客-CSDN博客_云服务器安装mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ebd57da4d53f86a872a91043896153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834230dab277d8c18db92c9ba7ecc69d/" rel="bookmark">
			GitHub上有哪些适合新手跟进的优质项目？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日分享5种语言功共15个GitHub的项目，包括：C项目、C#项目、C++项目、Go项目、Java项目、JavaScript项目，GitHub上适合新手入来学习的优质项目。
一、C项目 smartdns 地址：https://github.com/pymumu/smartdns 这是一个运行在本地的DNS服务器，能够提高网络访问速度等，架构图如下：
xmake 地址：https://github.com/xmake-io/xmake 一个基于 Lua 的轻量级跨平台自动构建工具。支持在各种主流平台上构建项目，主要用于解决 C/C++ 项目的跨平台构建，同时支持与其他语言的混合编译。工程配置语法简单易读，对初学者友好、上手方便
add_requires("libuv master", "ffmpeg", "zlib 1.20.*", "tbox &gt;1.6.1") target("test") set_kind("shared") add_files("src/*.c") add_packages("libuv", "ffmpeg", "tbox", "zlib") 二、C#项目 gui.cs 地址：https://github.com/gui-cs/Terminal.Gui 支持Windows和Linux/Unix的.NET终端UI工具库。方便实现终端GUI工具，并且可以实现终端中用鼠标。
Blog.Core 地址：https://github.com/anjoy8/Blog.Core 基于http://ASP.NET Core和Vue从零开始搭建前后端分离项目教程+实战项目。该项目从.Net Core基础讲，内容很完整、系统，对初学者和有一定基础的同学都非常有学习价值。
三、C++项目 ThreadPool 地址：https://github.com/progschj/ThreadPool C++11线程池实现，代码加起来不过100行。
xournalpp 地址：https://github.com/xournalpp/xournalpp/releases 一款支持PDF手写注释的笔记软件，支持Linux、Windows、macOS平台，大家喜欢手写笔记的，不要错过这款工具。
pika 地址：https://github.com/Qihoo360/pika 一个企业级开源的可持久化的大容量redis存储服务，兼容redis的绝大部分接口，解决redis由于存储数据量巨大而导致内存不够用的容量瓶颈。可以像redis一样，通过slaveof命令进行主从备份，支持全同步和部分同步。
四、Go项目 http框架 gin 地址：github.com/gin-gonic/gi 用Go（Golang）编写得HTTP web框架，拥有更好性能得API框架，文档非常完全，很多微服务也很方便集成。Gin绝对优秀~
touch example.go package main import "github.com/gin-gonic/gin" func main() { r := gin.Default() r.GET("/ping", func(c *gin.Context) { c.JSON(200, gin.H{ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/834230dab277d8c18db92c9ba7ecc69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c6df11d59690efdfe4101cac66c94c/" rel="bookmark">
			初始化git仓库(已存在项目)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 初始化git仓库【已存在项目】 1.创建git仓库，获取仓库git地址
2.进入已存在项目根目录，打开git bash，执行命令，初始化仓库
$ git init Initialized empty Git repository in D:/IdeaProjects/spb-wuyc-project/.git/ 3.添加文件
$ git add . 4.配置gitignore文件，排除部分文件
5.提交到本地
$ git commit -m "初始化提交" 6.配置远端仓库
$ git remote add origin https://gitee.com/hj_boys/spb-wuyc-project.git 7.push到远程仓库某分支，完成代码上传
$ git push -u origin "master" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14aa238a31d072ca0d24169e0e986d43/" rel="bookmark">
			终极.NET混淆器丨.NET Reactor产品介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无与伦比的 .NET 代码保护系统，可完全阻止任何人反编译您的代码。
产品优势
01、混淆技术
.NET Reactor通过向 .NET 程序集添加不同的保护层来防止逆向工程。除了标准的混淆技术之外，它还包括NecroBit、虚拟化、x86代码生成或防篡改等特殊功能。NET Reactor 是唯一为Windows、Linux和OSX提供代码加密的工具。
02、许可
.NET Reactor为.NET应用程序和库提供完全托管的许可解决方案。您可以直接将试用版应用到已编译的程序集和硬件锁定许可证文件。如果需要，可以使用SDK以编程方式加载许可证文件并检查许可证状态。
03、构架
.NET Reactor支持所有dotnet实现，包括.NET Framework、.NET5.0、.NET Core和ASP.NET Core。这样就可以为Xamarin、Unity和Blazor程序集提供全面的保护支持。
04、一体化
您可以通过直观的GUI或命令行使用.NET Reactor。我们的命令行生成器使在脚本中使用.NET Reactor变得非常容易。Visual Studio插件和DevOps任务可帮助您将Reactor集成到您的构建环境中。
05、安全性
.NET Reactor以强大而可靠的方式保护您的知识产权。它完成了混淆器所做的一切，但将您的知识产权包裹在更多的保护层中，拒绝那些决心窃取您的辛勤工作的人访问您的源代码。
产品特征
一、应用程序、库和Windows服务
无论您的.NET产品是什么，.NET Reactor都会保护它。
1、Windows
Windows窗体应用程序和库、WPF应用程序和库、控制台应用程序、Windows服务、控件和类库、通用Windows程序集、WinRT/Metro应用程序和库
2、Web
ASP.NET/ ASP.NET Core应用程序和库、Blazor、ASP.NET服务、WCF服务、Sharepoint WebParts
3、Silverlight
Silverlight应用程序和库
4、Smart Device
Xamarin Android、Xamarin iOS、Windows Phone、Compact Framework和PCL程序集
5、其它
.NET 5.0/6.0、NET Core和.NET标准程序集、SQL Server CLR程序集、Mono应用程序和库、Unity程序集
二、.NET Framework实现
.NET Reactor支持所有.NET Framework实现，包括.NET 6.0、.NET Core、Xamarin (Forms)和Mono：
.NET 5.0/6.0
NET Framework 1.1/2.0/3.0/3.5/4.x
.NET Core 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14aa238a31d072ca0d24169e0e986d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5e43c728c099696764b2665039a864/" rel="bookmark">
			IPV6 | 华为思科配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 前言：为什么需要IPV6地址
二. IPV4 与IPV6地址
1.IPV4地址
2.IPV6地址
三．IPV6地址的分类
1.单播地址
2.组播地址
3.任意播地址
四．NDP（邻居发现协议）
1.什么是邻居发现协议NDP？
2.ICMPv6（Internet控制报文协议）
3.IPV6 MAC地址解析
4.跟踪邻居状态（邻居可达性检测）
5.重复地址检测DAD
6.路由器发现
7.重定向
一. 前言：为什么需要IPV6地址 IPV4地址短缺
IPV6（Internet Protocol Version 6）是IPV4的升级版本。
世界上的每一粒沙子都能分配到一个IPV6地址，有趣故事：棋盘上的麦粒
二. IPV4 与IPV6地址 1.IPV4地址 (1) IPV4地址总长度为32bit，每8bit为一组，分为4组，采用点分十进制表示
(2）IPV4地址分为网络位和主机位部分，例如：192.168.1.1/24
（3）IPV4的报文格式
2.IPV6地址 （1）IPV6地址长度为128bit，每16bit为一组，分为8组，采用冒号十六进制表示
（2）IPV6提供了压缩格式，书写方便
每组的前导0都可以省略地址中包含的连续两个或多个均为0的组，可以用双冒号“：：”来代替，但只能使用一次 习题：
缩写
2001:FE00:0014:0000:0000:0000:0101:1000
解：2001:FE00:14::101:1000
FCC0:0000:0000:0010:0000:0000:0001:0002
解：FCC0::10:0:0:1:2
复原
2003::3030:1:2
解：2003:0000:0000:0000:0000:3030:0001:0002
FF00:99::10:101:1110
解：FF00:0099:0000:0000:0000:0010:0101:1110
（3）IPV6地址由网络前缀，接口标识组成
例如：FC00:0000:130F:0000:0000:09C0:876A:130B/96
96/16=6 前6组为网络前缀，后两组为接口标识
网络前缀不动，接口标识的取值从0到F
该IPV6地址的取值范围为:
FC00:0000:130F:0000:0000:09C0: 0000 0000 0000 0000 ：0000 0000 0000 0000
~
FC00:0000:130F:0000:0000:09C0: 1111 1111 1111 1111 ：1111 1111 1111 1111
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa5e43c728c099696764b2665039a864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df612ed5ffd9b2cbc5b34cd4033637f/" rel="bookmark">
			【OpenStack实战—keystone04】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、创建keystone数据库并授权 二、安装keystone及依赖软件
二、使用admin账户登录openstack
三、创建项目（project）、用户（user）、角色（role）
Keystone——身份认证组件
Keystone (OpenStack Identity Service)是OpenStack中的一个独立的提供安全认证的模块，主要负责openstack用户的身份认证、令牌管理、提供访问资源的服务目录、以及基于用户角色的访问控制。
Keystone类似一个服务总线，或者说是整 个Openstack框架的注册表,其他服务通过keystone来注册其服务的Endpoint (服务访问的URL)，任何服务之间相互的调用，需要经过Keystone的身份验证，来获得目标服务的Endpoint来找到目标服务。
openstack中各个组件相互访问都需要keystone进行认证
openstack各组件都要创建相应的用户，这些用户信息存放在MySQL里，但由keystone统一管理。
每一个组件还要创建相关的role，service，endpoint，这些信息也存放在MySQL里，由keystone统一管理（catalog）。
一、创建keystone数据库并授权 mysql -uroot -pxyz123 MariaDB [(none)]&gt; create database keystone; MariaDB [(none)]&gt; grant all privileges on keystone.* to 'keystone'@'localhost' identified by 'xyz123'; MariaDB [(none)]&gt; grant all privileges on keystone.* to 'keystone'@'%' identified by 'xyz123'; MariaDB [(none)]&gt; show databases; MariaDB [(none)]&gt; quit #输入数据库密码 mysql -uroot -pxyz123 #创建名为keystone的数据库。 MariaDB [(none)]&gt; create database keystone; #赋予用户keystone对数据库keystone的所有操作权限权限。“keystone.*”代表数据库keystone的所有表。 MariaDB [(none)]&gt; grant all privileges on keystone.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df612ed5ffd9b2cbc5b34cd4033637f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93099f9b449e62d647bd5065e0740c87/" rel="bookmark">
			WebSocket的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
为何使用websocket
1.后端搭建
2.搭建webSocket前后分离
1.配置跨域过滤器与初始化websocket
2.定义websocket服务
3.定义控制器进行测试webSocket向前端发送消息
2.前端准备
3.进行测试
向后端发送消息测试
后端向前端发送消息测试
为何使用websocket 在浏览器与服务器通信间，传统的 HTTP 请求在某些场景下并不理想，比如实时聊天、实时性的小游戏等等，
其面临主要两个缺点：
无法做到消息的「实时性」；服务端无法主动推送信息； 其基于 HTTP 的主要解决方案有：
基于 ajax 的轮询：客户端定时或者动态相隔短时间内不断向服务端请求接口，询问服务端是否有新信息；其缺点也很明显：多余的空请求（浪费资源）、数据获取有延时；Long Poll：其采用的是阻塞性的方案，客户端向服务端发起 ajax 请求，服务端挂起该请求不返回数据直到有新的数据，客户端接收到数据之后再次执行 Long Poll；该方案中每个请求都挂起了服务器资源，在大量连接的场景下是不可接受的； 可以看到，基于 HTTP 协议的方案都包含一个本质缺陷 —— 「被动性」，服务端无法下推消息，仅能由客户端发起请求不断询问是否有新的消息，同时对于客户端与服务端都存在性能消耗。
WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket 通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI 被 W3C 定为标准。 在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。
WebSocket 是 HTML5 中提出的新的网络协议标准，其包含几个特点：
建立于 TCP 协议之上的应用层；一旦建立连接（直到断开或者出错），服务端与客户端握手后则一直保持连接状态，是持久化连接；服务端可通过实时通道主动下发消息；数据接收的「实时性（相对）」与「时序性」；较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等） 实践
1.后端搭建 准配工作
所需要架包 注意：springboot环境 版本2.7.7
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93099f9b449e62d647bd5065e0740c87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b89f769ced0b6fb9b3e12ce7407ed91/" rel="bookmark">
			Shell脚本练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Shell基础知识
1.Shell的脚本组成部分
2.脚本的执行方式
3.脚本的退出状态码
4.一些符号
二、脚本练习
1.在当前主机编写脚本文件history_max.sh显示主机中执行频率最高的前5个命令。
2.判断主机是否存在rhel用户，如果存在则设置密码为redhat,如果不存在则创建用户并设置密
码。
3.通过设置变量HISTTIMEFORMAT，使得当执行history命令时，输出格式如下：
4.编写一个 Shell脚本，程序执行时从键盘读入一个目录名，如果用户输入的目录不存在，则 提示file does not exist；如果用户输入的不是目录则提示用户必须输入目录名；如果用户输
入的是目录则显示这个目录下所有文件的信息。
5.写一个脚本，完成以下要求：让用户输入用户名，如果其UID为0，就显示此为管理员；否
则，就显示其为普通用户。
6.写一个脚本，给定一个用户，判断其UID与GID号码是否一样，如果一样，就显示此用户为
“good guy”；否则，就显示此用户为“bad guy”。
7.写一个脚本，给定一个文件，比如/etc/inittab，判断这个文件中是否有空白行；如果有，则
显示其空白行数；否则，显示没有空白。
一、Shell基础知识 1.Shell的脚本组成部分 （1）第一行，指定解释器
#!/bin/bash （2）注释，#开头的行为注释
编辑.sh文件时自动生成关于脚本文件说明的注释
[root@localhost ~]# cat /root/.vimrc autocmd BufNewFile *.py,*.cc,*.sh,*.java exec ":call SetTitle()" func SetTitle() if expand("%:e") == 'sh' call setline(1,"#!/bin/bash") call setline(2,"#########################") call setline(3,"#File name:".expand("%")) call setline(4,"#Version:v1.0") call setline(5,"#Email:admin@test.com") call setline(6,"#Created time:".strftime("%F %T")) call setline(7,"#Description:") call setline(8,"#########################") call setline(9,"") endif endfunc 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b89f769ced0b6fb9b3e12ce7407ed91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35d2a45474132175d2a0e83054dc90e/" rel="bookmark">
			Vue2中 定时器 clearInterval()，结束定时器无效，已解决！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：
在vue中，我在某个页面加载后，开启了一个定时器，但是当我，通过路由，离开页面后，我进行了销毁组件停止计时器 的操作，乍一看，这样的操作没有任何问题，但是当我去到新页面后，计时器却依然在调用，解决了很久，才发现问题所在并解决！
解决前有问题的代码
mounted() { this.timer = setInterval(() =&gt; { // 在页面加载后开启一个定时器 this.totalreq(); console.log("定时器调用"); }, 5000) }, methods: { cliak(){ this.$destroy() //触发beforeDestroy 钩子函数 this.$router.push({ path: "/staff", }); } } beforeDestroy() { clearInterval（this.timer） //结束定时器， console.log(this.timer, "销毁组件"); } 解决
采用监听事件 vm.$once
问题原因是 setInterval 计时器本身是由全局window 调用，所以 计时器的事件 不能绑定在 组件的的 this 身上，只能 绑定在 普通变量身上
mounted() { this.totalreq(); const timer = setInterval(() =&gt; { //绑定在 const 普通变量身上，不要绑定在 this上 this.totalreq(); console.log("继续调用"); }, 5000) this.$once('hook:beforeDestroy', () =&gt; { //再通过事件监听，监听到 组件销毁 后，再执行关闭计时器。 clearInterval(timer); }) }, 解决完成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3474aebf6c817b544765b76aa6f5f451/" rel="bookmark">
			Vue2中给已定义数据，动态添加属性并赋值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果我需要在某个方法流程中，给data中已经定义好的from，对象中，动态的再添加一个属性，并赋值，并且需要页面视图响应式更新。
export default { data() { return { from：{ name：“数据”， type：“String” } } } } methods:{ // 如果直接这样写： this.from.value = 123; //在原生中，这样写可行，没有的属性的话，就会去自动添加新属性。，但是在这里，vue实例身上就不行，因为vue（2.0版本）无法监听到对象以及数组的数据动态新增或删除，也就是说，这里添加了，但是vue的视图层，并不会动态更新。 //这里就需要用到下面这个方法： this.$set(this.from, "value", 123);//实现响应式添加数据 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfa38db056cfbde2761de519c75b763/" rel="bookmark">
			vue3 antd table表格的增删改查（三）实现删除的数据的行样式修改【后台管理系统 纯前端rowClassName更改行样式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据数据属性值添加table表格行样式（rowClassName） 知识调用场景复现利用rowClassName编写行样式编写行样式函数➕筛选条件编写特定的行样式取消相应的斑马纹样式 知识调用 文章中可能会用到的知识链接vue3+ant design vue+ts实战【ant-design-vue组件库引入】🔥🔥vue3 antd table表格的样式修改（二）利用rowClassName给table添加行样式🔥🔥vue3 antd项目实战——table表格（一文带你快速实现后台管理系统最常用的table表格）🔥🔥 场景复现 在 vue3➕antd➕ts 的项目开发中，table表格无处不在，而对于table表格的操作有很多，比如 根据表格数据的属性显示不同的样式（颜色）。本期文章将以此为实例，提供详细方案实现需求。
表格初始状态：（如下图）
含表格自带的斑马纹所有行样式一致，没有根据表格数据属性区分样式 未根据表格数据的属性进行区分👇👇👇
未根据表格数据属性对应去除斑马纹👇👇👇
表格样式需求：
根据表格数据的属性渲染不同的颜色样式根据表格数据的属性去除相应数据的斑马纹样式 解决方案：
rowClassName ➕ 筛选条件 ➕ 样式函数pointer-events: none; 取消斑马纹 利用rowClassName编写行样式 表格部分：（点击了解表格是如何实现的🔥🔥）
如上图，绑定rowclass属性，调用rowclassname函数。（此函数即为样式函数，用于调用新的行样式）
&lt;a-table :data-source="data" :columns="columns" style="width:100%" :rowClassName="rowclassname" &gt; &lt;!-- 表格内的一些组件--&gt; &lt;/table&gt; 编写行样式函数➕筛选条件 样式函数部分：
如上图所示，返回新的行样式。这里使用了一个三目表达式，根据表格传递的数据的属性对应相应的行样式。
const rowclassname = (record:tableInt) =&gt; { // console.log("777",toRaw(record).deleted) return toRaw(record).deleted === 1 ? 'row-color' : '' } ps：
这里的record是表格里的删除按钮传过来的值点击删除则会改变deleted属性的值toRaw是vue3里的一个函数方法，主要作用是取消数据的跟踪，UI界面不会随之更新。 // 三目运算符在这里也可以用if语句替换 const rowclassname = (record:tableInt) =&gt; { if (record.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcfa38db056cfbde2761de519c75b763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/036b1bd28b15a732f33e0357f6372fd0/" rel="bookmark">
			redis:从入门到入土:8.RDB和AOF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis学习 一.RDB持久化1.定义2.执行时机3.RDB原理4.RDB 的优缺点5.小结 二.RDB持久化1.AOF原理2.AOF配置3.AOF文件重写3.1 定义3.2 步骤3.3 问题 4.AOF优缺点5.RDB与AOF对比 三:RDB和AOF混合方式四:数据恢复五:性能与实践六.总结 众所周知,Redis有两种持久化方案: RDB持久化,AOF持久化;
一.RDB持久化 1.定义 RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。即在指定目录下生成一个dump.rdb文件, 当Redis实例故障重启后，从磁盘读取快照文件，恢复数据.快照文件称为RDB文件，默认是保存在当前运行目录。
将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可恢复数据。
2.执行时机 RDB持久化在四种情况下会执行：
执行save命令执行bgsave命令Redis停机时触发RDB条件时 1）save命令
执行下面的命令，可以立即执行一次RDB：
save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。
2）bgsave命令
下面的命令可以异步执行RDB：
这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。
3）停机时
Redis停机时会执行一次save命令，实现RDB持久化。
4）触发RDB条件
Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：
# 900秒内，如果至少有1个key被修改，则执行bgsave ， # 如果是save "" 则表示禁用RDB save 900 1 save 300 10 save 60 10000 RDB的其它配置也可以在redis.conf文件中设置：
# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径目录 dir ./ 3.RDB原理 bgsave开始时会异步fork主进程得到子进程，这个过程对主进程几乎是零阻塞,子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。
异步fork过程中,主进程不会直接操作物理内存,操作虚拟内存,维护一个页表的映射关系,类似map来进行操作,fork 复制页表,实现内存共享;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/036b1bd28b15a732f33e0357f6372fd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8c0364e235e9202460d2f8d7520b3e/" rel="bookmark">
			日期正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		校验yyyy年MM月dd日、yyyy年MM月dd日 HH:mm:ss、yyyy年M月d日、yyyy年M月d日 HH:mm:ss
(^([1-9]\d{3}年)(([0]{0,1}[1-9]月)|([1][0-2]月))([0-3]{0,1}[0-9]日)((\s+([0-1]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]))?)) 校验yyyy-MM-dd、yyyy-MM-dd HH:mm:ss、yyyy-M-d、yyyy-M-d HH:mm:ss
(^([1-9]\d{3}-)(([0]{0,1}[1-9]-)|([1][0-2]-))([0-3]{0,1}[0-9])((\s+([0-1]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]))?)) 校验yyyy/MM/dd、yyyy/MM/dd HH:mm:ss、yyyy/M/d、yyyy/M/d HH:mm:ss
(^([1-9]\d{3}/)(([0]{0,1}[1-9]/)|([1][0-2]/))([0-3]{0,1}[0-9])((\s+([0-1]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]))?)) 校验yyyMMdd、yyyyMMddHHmmss
^([1-9]\d{3})(([0]{0,1}[1-9])|([1][0-2])){2}([0-3]{0,1}[0-9])((([0-1]?[0-9]|2[0-3])([0-5][0-9])([0-5][0-9]))?) yyyy年MM月dd日、yyyy年MM月dd日 HH:mm:ss、yyyy年M月d日、yyyy年M月d日 HH:mm:ss、yyyy-MM-dd、yyyy-MM-dd HH:mm:ss、yyyy-M-d、yyyy-M-d HH:mm:ss、yyyy/MM/dd、yyyy/MM/dd HH:mm:ss、yyyy/M/d、yyyy/M/d HH:mm:ss、yyyMMdd、yyyyMMddHHmmss字符串（基本涵盖日常开发中所有的日期格式）进行日期格式化（可直接转LocalDateTime类型）
private static final Pattern DATE_PATTRN = Pattern.compile("(^([1-9]\\d{3}年)(([0]{0,1}[1-9]月)|([1][0-2]月))([0-3]{0,1}[0-9]日)((\\s+([0-1]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]))?))|(^([1-9]\\d{3}-)(([0]{0,1}[1-9]-)|([1][0-2]-))([0-3]{0,1}[0-9])((\\s+([0-1]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]))?))|(^([1-9]\\d{3}/)(([0]{0,1}[1-9]/)|([1][0-2]/))([0-3]{0,1}[0-9])((\\s+([0-1]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]))?))$"); private static final Pattern NUMBER_DATE_PATTRN = Pattern.compile("(^([1-9]\\d{3})(([0]{0,1}[1-9])|([1][0-2]))([0-3]{0,1}[0-9])((([0-1]?[0-9]|2[0-3])([0-5][0-9])([0-5][0-9]))?))$"); private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); private static String formatDate(Object value){ if (value == null){ return null; }else { String valueString = String.valueOf(value); int year = 0; int month = 0; int day = 0; int hour = 0; int minute = 0; int seceond = 0; if (NUMBER_DATE_PATTRN.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a8c0364e235e9202460d2f8d7520b3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e02b474511a07b4e87ade02aa8cebc4/" rel="bookmark">
			asp.net 网站开发，word导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 曾经有一个word导出案例：
web保存word资源
后来发现可以使用MVC的File方法保存成相应的文件，特别做个记录。
1 前端 //网页 &lt;form method="post" action="/Home/WordExport" id="wordTmp"&gt; &lt;input type="text" name="wordContent" id="wordContent"/&gt; &lt;input type="submit" id="wordTmpBtn"/&gt; &lt;/form&gt; &lt;div class="layui-btn"&gt;我要导出&lt;/div&gt; &lt;div class="word-Container"&gt;……&lt;/div&gt; //js $('.layui-btn').on('click', function () { let bContent = $(".word-Container").html(); $("#wordContent").val(encodeURI(bContent)); $("#wordTmpBtn").click(); }); 2 后台方法 [HttpPost] public ActionResult WordExport(string wordContent) { StringBuilder sb = new StringBuilder(); sb.Append("&lt;!DOCTYPE html&gt;"); sb.Append("&lt;body&gt;"); sb.Append(HttpUtility.UrlDecode(wordContent)); sb.Append("&lt;/body&gt;"); var byteArray = System.Text.Encoding.Default.GetBytes(sb.ToString()); Response.ContentEncoding = System.Text.Encoding.GetEncoding("gb2312"); return File(byteArray, "application/ms-word", "test" + ".doc"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1279443242c789f75171e5a3f42594ab/" rel="bookmark">
			npm ERR! notsup Unsupported platform for n@9.0.1: wanted {“os“:“!win32“,“arch“:“any“} (current: {“os
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 node版本更新，需要安装一个 n 模块，但使用 npm install -g n会报错。
报错信息：
原因：主要是因为n模块不适配windows系统
解决方法：后面加force强力安装
npm install -g n --force 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d697ed411a4577344362ea6c82428bd9/" rel="bookmark">
			【JavaScript】——javascript牛客专项练习错题合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答：
var b = function(){ alert(this.a); }, obj = { a:1, b:b // 把函数独立出来 }; var fun = obj.b;// 存储的是内存中的地址 fun(); 虽然fun是obj.b的一个引用，但是实际上，它引用的是b函数本身，因此此时的fun()其实 是一个不带任何修饰的函数调用，所以this指向window。
赋值语句右侧的表达式含有关系运算符、逻辑运算符，其运算符的优先级是：
关系运算符&gt;逻辑运算符（先&amp;&amp;后||）。
因此，先执行关系运算：4 &gt;= 6，返回结果为false，
再执行逻辑运算的&amp;&amp;：true &amp;&amp; 1，返回结果为1，
最后执行逻辑运算的||: false || 1 || false，
false || 1的结果为1,1 || false的结果也为1，所以变量a的值为1，C选项正确。
变量可以使用短名称，如x，y；也可以是长名称，如information,construction
变量命名规则如下：
1、变量命名必须以字母、下划线”_”或者”$”为开头。其他字符可以是字母、_、美元符号或数字。
2、变量名中不允许使用空格和其他标点符号，首个字不能为数字。
3、变量名长度不能超过255个字符。
4、变量名区分大小写。(javascript是区分大小写的语言)
5、变量名必须放在同一行中
6、不能使用脚本语言中保留的关键字、保留字、true、false 和 null 作为标识符。
截止到目前为止JS描述了一组具有特定用途的关键字，一般用于控制语句的开始或结束,或者用于执行特定的操作等。关键字也是语言保留的，不能用作标识符。if for switch case break continue while var function alert($(window).height()); //浏览器当前窗口可视区域高度
alert($(document).height()); //浏览器当前窗口文档的高度
alert($(document.body).height());//浏览器当前窗口文档body的高度 alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d697ed411a4577344362ea6c82428bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba93489fda450b9788d64b182f61336e/" rel="bookmark">
			Field error in object ‘xxx‘ on field ‘xxx‘: rejected value [xx]；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误解释： 字段上对象“xxx”中的field错误，拒绝了值[xxx]。意思是：在Springboot等其他框架中编写程序时，前端传入的数据例如
前端代码如下 &lt;!-- 来自与前端表单的输入内容 --&gt; &lt;input type="text" name="phone"&gt; 这个phone从客户端接收的值与后端entity中定义的属性值不匹配（与数据库定义的值的类型不匹配）时，就发生接收值类型错误。
解决办法：
看是否将基本数据类型int、double、long等转换为其对应的对象类型Integer、Double、Long等（即实体类中定义的属性类型用其对应的对象类型，Integer）修改客户端的值，重新输入正确类型的值。 如果还是报错，查看程序内的该属性类型是否都一致（包括数据库，实体类，前端页面）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1984b97a5d792f794af2ac754683fcce/" rel="bookmark">
			Docker之Nacos的持久化和集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注1：小插曲
由于虚拟机分配的内存为1G，开到第四个容器时，由于内存不够导致容器启动失败，重新设置4G内存后启动成功
ok，正式进入主题！
一、Docker mysql:5.7的持久化存储及远程连接 1、拉取相关镜像【目前网络模式为：bridge】 ①mysql镜像（docker mysql:5.7的持久化存储及远程连接）
docker pull mysql/mysql-server:5.7
注：后面的mysql标签是版本号，可选择，有：5.5/5.6/5.7/8.0
2、在宿主机中相关目录，用于挂载容器的相关数据 mkdir -p /data/mysql/{conf,data}
建立目录用来放置mysql数据的
3、添加my.cnf文件就相当于安装客户端mysql时需要添加的my.ini文件 添加到mysql中的conf目录下（conf就是前面我们自己创建的）
4、创建mysql5.7容器（同时启动） docker run -p 3306:3306 \
--name mysql \
-v /data/mysql/conf/my.cnf:/etc/my.cnf \
-v /data/mysql/data:/var/lib/mysql \
--privileged=true \
--restart=always \
-e MYSQL_ROOT_PASSWORD=123456 \
-d mysql/mysql-server:5.7 以上参数的解析如下：
-p 3306:3306：宿主机端口:容器端口
--name mysql：容器名字
-v：挂载宿主机的一个目录, 持久化存储的关键所在，将主机目录挂载到容器对应目录，分别是：配置文件、日志文件、数据文件
-v /data/mysql/conf:/etc/mysql/conf.d
-v /data/mysql/logs:/logs
-v /data/mysql/data:/var/lib/mysq
--privileged=true：使用该参数，container内的root拥有真正的root权限, 否则，container内的root只是外部的一个普通用户权限
--restart=always：容器自动启动参数，其值可以为[no,on-failure,always]
no为默认值，表示容器退出时，docker不自动重启容器
on-failure表示，若容器的退出状态非0，则docker自动重启容器,还可以指定重启次数，若超过指定次数未能启动容器则放弃
always表示，只要容器退出，则docker将自动重启容器
-e MYSQL_ROOT_PASSWORD=123456：设置root的密码
-d mysql/mysql-server:5.7：后台启动模式及使用的镜像
注意：
最好把没用的容器都清除掉，以防出现问题
清除所有容器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1984b97a5d792f794af2ac754683fcce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52346509732f0b66eae8f1c33713b269/" rel="bookmark">
			从数据分布的角度提高对抗样本的可迁移性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言 对抗迁移性攻击一般是先通过代理模型生成对抗样本，然后将该样本迁移到其它黑盒模型中进行攻击，对抗迁移性的根本原因目前仍有待于探究。以前的工作主要从模型的角度探讨原因，例如决策边界、模型架构和模型容量等。在该论文中，作者从数据分布的角度研究对抗样本的可迁移性，其核心思想是针对于无目标攻击，将图像移出其原始分布会使不同的模型很难对图像进行正确分类。针对于有目标攻击，则是将图像拖入目标分布会误导模型将图像分类为目标类。因此作者提出了一种通过操纵图像的分布来生成对抗样本的新方法。实验结果证明了所提出方法的有效性。
论文链接：https://arxiv.org/abs/2210.04213
论文代码：https://github.com/alibaba/easyrobust
2 预备知识 给定一个参数 θ \theta θ的代理模型 f θ f_\theta fθ​，图像 x \boldsymbol{x} x，标签 y y y，其中共 n n n类， f θ ( x ) [ k ] f_\theta(x)[k] fθ​(x)[k]表示神经网络最后一层第 k k k类输出，则条件概率 p θ ( y ∣ x ) p_\theta(y|\boldsymbol{x}) pθ​(y∣x)表示为
p θ ( y ∣ x ) = exp ⁡ ( f θ ( x ) [ y ] ) ∑ k = 1 n exp ⁡ ( f θ ( x ) [ k ] ) p_\theta(y|\boldsymbol{x})=\frac{\exp(f_\theta(\boldsymbol{x})[y])}{\sum\limits_{k=1}^n \exp(f_\theta(\boldsymbol{x})[k])} pθ​(y∣x)=k=1∑n​exp(fθ​(x)[k])exp(fθ​(x)[y])​对抗扰动通常是损失函数 L \mathcal{L} L关于样本 x \boldsymbol{x} x的梯度，无目标攻击可以表示为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52346509732f0b66eae8f1c33713b269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5578bd69d8f046c8e6f99ebea6e5202b/" rel="bookmark">
			Android开发中如何获得正确的layout资源（layout-sw480dp layout-sw600dp-land layout-sw720dp-port）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章转载于：Android开发中如何获得正确的layout资源（layout-sw480dp layout-sw600dp-land layout-sw720dp-port）_Felix.Ma的博客-CSDN博客
Android应用里，大家一定饱受各种layout-sw480dp layout-sw600dp-land layout-sw720dp-port之苦，往往不知道自己的平板加载的是哪个Layout而不得不一个个尝试，网上一大堆说不清的教程。本人查阅很多资料，给大家分享一种计算方法确定自己平板所加载哪个dp的资源。
事实上,SW全称是Smallest Width，表示最小宽度。注意：这里的最小绝对宽度是指手机的实际宽度，即与手机是否横屏没关系，也就是手机较小的边的长度。
屏幕的分辨率可以通过如下命令获取：
adb shell wm size
比如：
home@ubuntu:~$ adb shell wm size Physical size: 2160x1440 那么sw值就是：1440
比如 1280*800, sw 是800
480*800， sw 是480
dpi值 的可以通过 adb shell getprop ro.sf.lcd_density 获得。
sw-xxxx-dp的计算公式是 sw *160/dpi 机型 分辨率swdpi= ro.sf.lcd_density sw *160/dpi dpH7(Android5.1) 1280*720 720213 720*160/213=540.84 sw480dpH7(Android4.4) 1280*720 720160 720*160/160=720 sw720dp平板A1920*120012003201200*160/320=600 sw600dp平板B1920*108010802401080*160/240=720 sw720dp平板C2000*120012003201200*160/320=600 sw600dp 通过公式 sw*160/dpi 计算出结果之后，选择一个比这个结果小，而又最接近这个值的dp。
比如，范例中H7(Android 5.1)算出来是540.84，如果你的layout下存在一个 sw480dp，那这里dp肯定是sw480dp，如果没有sw480dp，只能找到sw340dp.
land是横屏，port是竖屏。
做了几个移动端的项目之后，深感移动端尺寸换算的必要性，在此做个总结。
先介绍下各自的定义：
px： pixel，像素，电子屏幕上组成一幅图画或照片的最基本单元
pt: point，点，印刷行业常用单位，等于1/72英寸
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5578bd69d8f046c8e6f99ebea6e5202b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0ce430da994835ab99d21153606350/" rel="bookmark">
			tar 解压缩命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		勿以恶小而为之，勿以善小而不为---- 刘备
打包: tar 命令参数 要打包后的文件 打包的原目录
tar -cvf test.tar test 仅打包，不压缩
tar -zcvf test.tar.gz test 打包后，以gzip压缩 在参数f后面的压缩文件名是自己取的，
习惯上用tar来做，如果加z参数，则以tar.gz 或tgz来代表gzip压缩过的tar file文件
解压操作 tar 命令参数 要解压的文件
tar -zxvf /usr/local/test.tar.gz
tar 解压缩命令详解 1 -c: 建立压缩档案
2 -x：解压
3 -t：查看内容
4 -r：向压缩归档文件末尾追加文件
5 -u：更新原压缩包中的文件
这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。
-z：有gzip属性的
-j：有bz2属性的
-J：具有xz属性的（注3）
-Z：有compress属性的
-v：显示所有过程
-O：将文件解开到标准输出
下面的参数-f是必须的
-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。
tar -cf all.tar *.jpg
tar -rf all.tar *.gif
这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。
这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -uf all.tar logo.gif 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 tar -tf all.tar 这条命令是列出all.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f0ce430da994835ab99d21153606350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15922f61314ab377b3f991ec335826a3/" rel="bookmark">
			微信小程序接入易云章（H5）人脸识别 uniApp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开人脸识别页面
&lt;template&gt; &lt;view&gt; &lt;web-view @message="getMessage" v-if="isWedView" :src="wedViewSrc"&gt;&lt;/web-view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default{ data(){ return{ isWedView:false, id:0, wedViewSrc:'', type:1 } }, onLoad(parameter) { console.log(parameter) uni.showLoading({ title: '加载中' }); this.id = parameter.id; this.type = parameter.type; //1考试人脸识别2看视频人脸识别 this.$http(this.$api.faceSwiping,{ api_token:uni.getStorageSync('token'), url:'https://sheke.test03.qcw800.com/xxxx.html' //人脸识别成功后的回调地址 }).then(res=&gt;{ console.log(res,'刷脸') if(res.data.code == 0){ uni.hideLoading(); this.isWedView = true; this.wedViewSrc = `https://sheke.test03.qcw800.com/xxxx.html?url=${res.data.data.url}`; }else{ this.$toast(res.data.msg,'获取人脸识别url失败'); } }) }, methods:{ getMessage(e) { //接收web-view传过来的参数 console.log(e.detail.data[0].options,'webView传回的参数'); this.$http(this.$api.faceResult,{ api_token:uni.getStorageSync('token'), orderNo:e.detail.data[0].options }).then(res=&gt;{ console.log(res,'人脸扫面结果') if (res.data.code == 0) { if(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15922f61314ab377b3f991ec335826a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f454bd531bb3a7a26a2052633955740f/" rel="bookmark">
			获取微信小程序版本号，uni
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //uniapp方法获取版本号 uni.getSystemInfo({ success: function (res) { console.log(res,'---------') } }); //微信小程序方法获取版本号 const accountInfo = wx.getAccountInfoSync(); this.version_number = accountInfo.miniProgram.version; // 小程序 版本号 console.log(res,'---------') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8d4f8d084bda04323ab1b6fd1f091e/" rel="bookmark">
			Python生日代码、生日快乐代码、生日祝福代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Python画一个生日蛋糕并写上生日祝福对象及生日祝福语。画一个双层蛋糕并点上蜡烛。代码运行时间较长，请静待惊喜出现，代码运行截图：
另外怕大家不会使用，直接给大家准备了写好的，直接下载打开即可使用！
源码放在百度云盘上了， 需要可以微信扫描下方CSDN官方认证二维码免费领取
完整程序代码：
import turtle as t import math as m import random as r def drawX(a, i): angle = m.radians(i) return a * m.cos(angle) def drawY(b, i): angle = m.radians(i) return b * m.sin(angle) # 设置背景颜色，窗口位置以及大小 t.bgcolor("#d3dae8") t.setup(width=900, height=600, startx=0, starty=0) t.title("好友，祝你生日快乐！") t.speed(2) t.penup() t.goto(150, 0) t.pendown() # 1 t.pencolor("white") t.begin_fill() for i in range(360): x = drawX(150, i) y = drawY(60, i) t.goto(x, y) t.fillcolor("#fef5f7") t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8d4f8d084bda04323ab1b6fd1f091e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f0580bd93150b5cdd8ac4c87edac06/" rel="bookmark">
			JavaScript 对象的长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问： 我有一个 JavaScript 对象。是否有内置或公认的最佳实践方法来获取此对象的长度？
const myObject = new Object(); myObject["firstname"] = "Gareth"; myObject["lastname"] = "Simpson"; myObject["age"] = 21; 答1: 保持自己快人一步,享受全网独家提供的一站式外包任务、远程工作、创意产品订阅服务–huntsbot.com
更新的答案
这是 2016 年和 widespread deployment of ES5 及以后的更新。 对于 IE9+ 和所有其他支持 ES5+ 的现代浏览器，您可以使用 Object.keys()，因此上述代码变为：
var size = Object.keys(myObj).length; 由于 Object.keys() 现在是内置的，因此不必修改任何现有原型。
编辑：对象可以具有无法通过 Object.key 方法返回的符号属性。因此，如果不提及它们，答案将是不完整的。
符号类型被添加到语言中以创建对象属性的唯一标识符。 Symbol 类型的主要好处是防止覆盖。
Object.keys 或 Object.getOwnPropertyNames 不适用于符号属性。要退回它们，您需要使用 Object.getOwnPropertySymbols。
var person = { [Symbol(‘name’)]: ‘John Doe’, [Symbol(‘age’)]: 33, “职业”: “程序员” }; const propOwn = Object.getOwnPropertyNames(person);控制台.log(propOwn.length); // 1 let propSymb = Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97f0580bd93150b5cdd8ac4c87edac06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907279e1ec27570ad638a55af9a3f365/" rel="bookmark">
			RS-232/RS-485/RS-422通信协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、RS-232 (1) 基本概念
RS-232接口符合美国电子工业联盟(EIA)制定的串行数据通信的接口标准，被广泛用于计算机串行接口外设连接，像有些老式PC机上就配置有RS232接口。RS232的工作方式是单端工作方式，这是一种不平衡的传输方式，收发端信号的逻辑电平都是相对于信号地而言的，RS232最初是DTE(数字终端设备)和DCE(数据通信设备)一对一通信，也就是点对点，一般是用于全双工传送，也可以用于半双工传送。
采用负逻辑传送，规定逻辑“1”的电平为-5V~-15 V，逻辑“0”的电平为+5 V～+15 V。选用该电气标准的目的在于提高抗干扰能力，增大通信距离。RS -232的噪声容限为2V，接收器将能识别高至+3V的信号作为逻辑“0”，将低到-3 V的信号作为逻辑“1”。
传输距离短，只有15米，实际应用可以达到50米，再长的距离就须加调制了。
RS232标准物理接口是25个引脚的，因为常用的是9个引脚，后来基本采用DB9连接器了。
RS-232标准主要规定了信号用途、通讯接口和信号电平标准。如下图为常见的设备间串口通讯结构图。
如上图所示，每个设备都有一个DB9接口，通过DB9接口连接RS-232标准的串口线进行数据传输。由于通过RS-232标准传输的电平信号到达设备后，不能直接被识别，所以会通过电平转换芯片（例如MAX3232、SP3232芯片等）转换成能识别的TTL电平信号，实现通讯。
相互通讯的两个设备间，一个设备发送数据，一个设备接收数据。一般情况下，发送数据的设备称为DTE，如计算机；接收数据的设备称为DCE，如调制解调器。
下面介绍下DB9接口。如下图为DB9标准的公头、母头接法（接线口以针式引出信号线为公头，以孔式引出信号线为母头）。
如上图，以公头为例，有9条信号线，其中，
RXD：用于接收DCE发来的数据信号，即输入；TXD：用于发送DTE的信号，即输出。公头和母头的RXD和TXD应交叉连接；GND：用于平衡设备双方的地电位，即共地。 其他信号线如DCD、DTR、DSR、RTS、CTS等，使用逻辑1表示有效信号，逻辑0表示无效信号。如DTE端的RTS信号线置1时，是为了告知DCE设备本机已准备好 接收数据，而置0则表示未准备就绪。
（2）通信方式
RS232 可做到双向传输，全双工通讯，最高传输速率 20kbps。
（3）与UART异同点
逻辑电平不同：UART是TTL电平，RS232是RS232电平，不能直接相连，需要电平转换芯片(MAX3232等)。
协议层完全相同：UART和RS232的协议层可以共享，没有较大区别。
（4）缺点
接口电平值较高，易损坏接口电路的芯片；又因为与TTL电平不兼容故需使用电平转换电路方能与TTL电路连接。
传输速率较低，大约为20Kbps；传输距离较短，大约为15米左右。
接口由三根线TX、RX、GND组成，没有构成差分线形式，容易产生共地共模干扰，抗干扰能力弱。
2、RS-485 （1）基本概念
RS485总线传输协议是一种串行总线通信协议标准，RS485总线采用平衡发送，差分接收的结构设计，因此具有抑制共模干扰的能力。RS485总线的数据传输速率最高可达10Mbps，最远传输距离可达1000米左右。RS485不是点对点式的总线结构，而是分布式架构，其总线能够连接多达128个收发器。
RS-485采用平衡发送和差分接收，因此具有抑制共模干扰的能力。RS-485采用半双工工作方式，任何时候只能有一点处于发送状态，因此，发送电路须由使能信号加以控制。RS-485用于多点互连时非常方便，可以省掉许多信号线。应用RS-485可以联网构成分布式系统，其允许最多并联32台驱动器和32台接收器。在RS232或RS485设备联成的设备网中，如果设备数量超过2台，就必须使用RS485做通讯介质，RS485网的设备间要想互通信息只有通过“主（Master）”设备中转才能实现，这个主设备通常是PC，而这种设备网中只允许存在一个主设备，其余全部是从（Slave）设备。
RS-485 （ EIA-485 标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。出色抗噪和多设备能力，在工业应用中建立连向PC机的分布式设备网络、其他 数据收集 控制器、HMI或者其他操作时，串行连接会选择RS-485。RS-485是RS-422的超集，因此所有的RS-422设备可以被RS-485控制。RS-485可以用超过4000英尺的线进行串行通行。
为改进RS232通信距离短、速率低的缺点，EIA在基于RS422的基础上制定了RS485接口标准。RS485是平衡发送和差分接收，因此具有抑制共模干扰的能力，它的最大传输距离为1200米，实际可达3000米，传输速率最高可达10Mbit/s。所以，一般在要求通信距离为几十米到上千米时，会广泛采用RS-485串行通信。
RS-485采用半双工工作方式，允许在简单的一对屏蔽双绞线上进行多点、双向通信，不过任何时候只能有一点处于发送状态，因此，发送电路须由使能信号加以控制。
与RS232不同的是，RS485的工作方式是差分工作方式，所谓差分工作方式，是指在一堆双绞线中，一条定义为A，一条定义为B。RS485采用差分信号负逻辑，+2V～+6V表示“0”，- 6V～- 2V表示“1”。RS485有两线制和四线制两种接线，四线制是全双工通讯方式，两线制是半双工通讯方式。
RS485和RS232一样都是基于串口的通讯接口，数据收发的操作是一致的，但是它们在实际应用中通讯模式却有着很大的区别，RS232接口为全双工数据通讯模式，而RS485接口为半双工数据通讯模式，数据的收发不能同时进行，为了保证数据收发的不冲突，在RS485中还有一个使能端，使能端是用于控制发送驱动器与传输线的切断与连接，可以认为是一个开关。当开关即使能端信号为1时，信号就输出，当使能端信号是0时，信号就无法输出。相应也要求软件上必须将收发的过程严格地分开。
RS-485与RS-422的不同还在于其共模输出电压是不同的，RS-485是-7V至+12V之间，而RS-422在-7V至+7V之间；RS-485满足所有RS-422的规范，所以RS-485的驱动器可以用在RS-422网络中应用。RS-485与RS-422一样，其最大传输距离约为1219米，最大传输速率为10Mbps。平衡双绞线的长度与传输速率成反比，在100Kbps速率以下，才可能使用规定最长的电缆长度。只有在很短的距离下才能获得最高速率传输。一般100米长双绞线最大传输速率仅为1Mbps。
RS485接口组成的半双工网络，一般是两线制（以前有四线制接法，只能实现点对点的通信方式，现很少采用），多采用屏蔽双绞线传输。这种接线方式为总线式拓扑结构在同一总线上最多可以挂接32个结点。在RS485通信网络中一般采用的是主从通信方式，即一个主机带多个从机。很多情况下，连接RS-485通信链路时只是简单地用一对双绞线将各个接口的“A”、“B”端连接起来。RS485接口连接器采用DB-9的9芯插头座，与智能终端RS485接口采用DB-9（孔），与键盘连接的键盘接口RS485采用DB-9（针）
(2) RS-485引脚定义
RS-485的两线制引脚定义：
序号名称作用备注1Data-/B/485-发送正必连2Data/B/485+接收正必连5GND地线不连9+9V电源不连 RS-485的四线制引脚定义：
序号名称作用备注1TDA-/Y发送ATXD+/A，必连2TDB+/Z发送BTXD-/B，必连3RDA-/A接收ARXD-，必连4RDB+/B接收BRXD+，必连5GND地线不连 RS485标准物理接口也是9个引脚的，对于引脚定义有不同的标识：
英式标识为 TDA(-) 、TDB(+) 、RDA(-) 、RDB(+) 、GND美式标识为 Y 、Z 、 A 、 B 、 GND中式标识为 TXD(+)/A 、TXD(-)/B 、RXD(-) 、RXD(+)、GNDRS485两线一般定义为： “A、B"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/907279e1ec27570ad638a55af9a3f365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45359c5f706836fe9eb1f7500cb98036/" rel="bookmark">
			AndroidQ兼容性适配指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AndroidQ Android 10 中的隐私权变更
隐私权变更受影响的应用缓解策略✅分区存储 针对外部存储的过滤视图，可提供对特定于应用的文件和媒体集合的访问权限访问和共享外部存储中的文件的应用使用特定于应用的目录和媒体集合目录 了解详情✅增强了用户对位置权限的控制力 仅限前台权限，可让用户更好地控制应用对设备位置信息的访问权限在后台时请求访问用户位置信息的应用确保在没有后台位置信息更新的情况下优雅降级 使用 Android 10 中引入的权限在后台获取位置信息 了解详情✅系统执行后台 Activity 针对从后台启动 Activity 实施了限制不需要用户互动就启动 Activity 的应用使用通知触发的 Activity 了解详情✅不可重置的硬件标识符 针对访问设备序列号和 IMEI 实施了限制访问设备序列号或 IMEI 的应用使用用户可以重置的标识符 了解详情✅无线扫描权限 访问某些 WLAN、WLAN 感知和蓝牙扫描方法需要获得精确位置权限使用 WLAN API 和蓝牙 API 的应用针对相关使用场景请求 ACCESS_FINE_LOCATION 权限 了解详情 上面是官网的AndroidQ的隐私权变更链接，本文章只针对部分重大隐私权限变更做出解释说明。
从后台启动 Activity 的限制 创建高优先级通知
Android10中, 当App无前台显示的Activity时,其启动Activity会被系统拦截, 导致启动无效。
对此官方给予的折中方案是使用全屏Intent(full-screen intent), 既创建通知栏通知时, 加入full-screen intent 设置, 示例代码如下(基于官方文档修改):
Intent fullScreenIntent = new Intent(this, CallActivity.class); PendingIntent fullScreenPendingIntent = PendingIntent.getActivity(this, 0, fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT); NotificationCompat.Builder notificationBuilder = new NotificationCompat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45359c5f706836fe9eb1f7500cb98036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3c6381bc969da706542b6d705588e4/" rel="bookmark">
			网络靶场实战-MQTT协议分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本环境是蛇矛实验室基于"火天网演攻防演训靶场"进行搭建，通过火天网演中的环境构建模块，可以灵活的对目标网络进行设计和配置，并且可以快速进行场景搭建和复现验证工作。
自 2005年国际电信联盟正式提出“物联网（IoT）”这一概念以来，物联网在全球范围内迅速获得认可，并成为信息产业革命第三次浪潮和第四次工业革命的核心支撑。同时，数以亿计的设备接入物联网，这些设备如今已渗透到我们生活的方方面面，从家居到工厂无处不在。一方面物联网设备使我们的生活更加便捷，而另一方面物联网安全事件频发，全球物联网安全支出不断增加。 当前，大量物联网设备及云服务端直接暴露于互联网，这些设备和云服务端存在的漏洞一旦被利用，可导致设备被控制、用户隐私泄露、云服务端数据被窃取等安全风险，甚至会对基础通信网络造成严重影响。从2018年全球统计数据来看，路由器、视频监控设备暴漏数量占比较高。路由器暴漏数量超过3000万台，视频监控设备暴露数量超过1700万台，并且这些设备往后几年会一年比一年多，物联网安全的事件也会越来越多。由此，物联网安全行业需要大力发展，物联网安全人才的培养也刻不容缓。
蛇矛实验室在后续将利用火天网境系列靶场中的相关目标仿真和环境构建的特性，将持续发布关于“物联网安全-CVE实战分析”系列的文章来帮助大家入门物联网安全。
关于MQTT MQTT是一个基于客户端-服务器消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。
MQTT介绍 MQTT的几个要素： 1. 客户端（Client）：使用MQTT的程序或设备，一般分为发布者和订阅者 2. 服务端（Server）：发布者和订阅者之间的Broker 3. 主题（Topic）：附加在消息上的一个标签，Broker会将该消息发送给所有订阅该主题的订阅者 4. 主题过滤器（Topic Filter）：订阅者订阅时可使用通配符同时订阅一个或多个主题 MQTT基于发布和订阅模型，MQTT 协议的订阅与发布是基于主题的（Topic），MQTT工作在 TCP/IP协议族上。一个典型的 MQTT 消息发送与接收的流程如下：
1. Publisher 连接 Broker； 2. Suscriber连接 Broker，并订阅主题 Topic； 3. Publisher 发送一条消息给 Broker，主题为 Topic； 4. Broker 收到 Publisher 的消息，查出 Suscriber 订阅了 Topic，然后将消息转发到 Suscriber； 我们可以简单理解，将MQTT理解为微博工作模式，当你(Suscriber)点击关注一个博主(Publisher)后，你就订阅了博主(连接到了Broker)，当博主发微博消息时(Publish message)，微博的服务器(Broker)会将你订阅博主的微博消息转发给你(Subcribe message)，这样就完成了消息传递。
MQTT服务器搭 Eclipse Mosquitto是一个开源消息代理，实现了MQTT协议版本3.1和3.1.1。Mosquitto轻量，适用于低功耗单板计算机到完整服务器的所有设备。Mosquitto项目还提供了用于实现MQTT客户端的C库，以及非常受欢迎的mosquitto_pub和mosquitto_sub命令行的MQTT客户端(来自于翻译)。
安装Mosquitto的过程，首先添加mosquitto的ppa源：
sudo apt-add-repository ppa:mosquitto-dev/mosquitto-ppa 安装mosquitto程序和mosquitto-clients客户端程序
sudo apt install mosquitto sudo apt install mosquitto-clients 我们接下来就可以启动mosquitto服务了，启动可以查看一下mosquitto进程是否启动。这里可以看到mosquitto -c参数后运行配置文件的路径
sudo service mosquitto start ps -aux | grep mosquitto 或者 sudo service mosquitto status 接下来，我们就可以测试mqtt协议的工作流程了，首先启动一个终端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c3c6381bc969da706542b6d705588e4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/108/">«</a>
	<span class="pagination__item pagination__item--current">109/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/110/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>