<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc07e35f8039dd741246db651c55a021/" rel="bookmark">
			Python入门自学进阶——1--装饰器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解装饰器，先要理解函数和高阶函数。
首先要明白，函数名就是一个变量，如下图，定义一个变量名和定义一个函数，函数名与变量名是等价的。
既然函数名就是一个变量名，那么在定义函数时，函数的参数就可以是函数名，即可以传递一个函数给另一个函数。同样，函数可以返回一个变量，如return x，那么，这个x既可以是一个变量名，也就可以是一个函数名。
对于foo1，返回的是inner这个函数对象，如果是return inner（），那就是返回8，函数名()，即函数名加上括号，就是对函数对象的调用，返回的是调用对象的返回值。
当函数的参数中包含函数名，或者作为返回值返回时，这个函数就叫做高阶函数，如上面的foo函数和foo1函数。
其次要理解变量的作用域，即LEGB
L——Local，局部变量，E——Enclosing，嵌套的父级函数局部变量，G——Global，全局变量，B——Build-in，系统模块固定的变量。
变量的查找顺序是L——&gt;E——&gt;G——&gt;B.
第三要理解闭包的概念。
对于上面的函数，外层outer()函数内定义了一个内部函数inner()，outer返回的是inner，对于返回的inner函数来说，按照前面的作用域LEGB原则，f，即返回的inner函数是无法访问outer函数的局部变量x的，但是，这种写法inner就能访问，这叫做闭包。即返回的内部函数能够访问一个外部变量。闭包=函数块+定义函数时的环境
装饰器的引入
有很多开发完毕的函数，已经被大量使用，如有一个函数：
def foo():
print('foo func...')
现在想给这个函数加一个功能，计算这个函数的运行时间，一个办法是直接修改foo函数：
import time
def foo():
start = time.time()
print('foo func...')
end = timt.time()
print('执行时间 %s' % (end-start))
这种方法虽然实现了功能，但是对于已经发布大量使用的函数，是不能这样的修改的。一个原则：开放封闭原则，对修改源代码封闭，对在不修改源代码的前提下对扩展开放。因为原函数已经大量在生产环境应用，直接修改源代码增加功能，代价太大，无法承受。另一方面，如果多个函数都要增加这个功能，如还有一个函数bar，也要增加一个计算运行时间的功能，按上面的写法;
import time
def bar():
start = time.time()
print('bar func...')
end = timt.time()
print('执行时间 %s' % (end-start))
代码会大量重复。解决重复的方法，就是重复的代码再写成一个函数。
def showtime():
start = time.time()
foo()
end = timt.time()
print('执行时间 %s' % (end-start))
这样，就实现了功能。但是这只能测试一个foo函数，要测试任意函数，修改如下：
def showtime(func):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc07e35f8039dd741246db651c55a021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ad21267a79dcf8a1244aa3218294ca/" rel="bookmark">
			echarts 饼状图 调整位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过调整 center 按照百分比调整位置
series: [{ name: '圆环图系列名称', // 系列名称 type: 'pie', // 系列类型 left: '0%', center: ['24%', '50%'], // 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。[ default: ['50%', '50%'] ] radius: ['30%', '40%'], // 饼图的半径，数组的第一项是内半径，第二项是外半径。[ default: [0, '75%'] ] hoverAnimation: true, // 是否开启 hover 在扇区上的放大动画效果。[ default: true ] color: color, // 圆环图的颜色 label: { // 饼图图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等. normal: { show: false, // 是否显示标签[ default: false ] position: 'outside', // 标签的位置。'outside'饼图扇区外侧，通过视觉引导线连到相应的扇区。'inside','inner' 同 'inside',饼图扇区内部。'center'在饼图中心位置。 formatter: '{b} : {c}次' // 标签内容 } }, labelLine: { // 标签的视觉引导线样式,在 label 位置 设置为'outside'的时候会显示视觉引导线。 normal: { show: false, // 是否显示视觉引导线。 length: 15, // 在 label 位置 设置为'outside'的时候会显示视觉引导线。 length2: 10, // 视觉引导项第二段的长度。 lineStyle: { // 视觉引导线的样式 //color: '#000', //width: 1 } } }, data: data // 系列中的数据内容数组。 }], 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d46c49b8c03463a90c47674ca38447/" rel="bookmark">
			小样本学习(Few-Shot Learning)（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 本文讲解小样本学习问题的Pretraining+Fine Tuning解法。
小样本学习(Few-Shot Learning)（一）讲解了小样本学习问题的基本概念及基本思路，并介绍了使用孪生网络解决小样本学习问题的方法。
小样本学习(Few-Shot Learning)（三）使用飞桨（PaddlePaddle）基于paddle.vision.datasets.Flowers数据集实践小样本学习问题的Pretraining+Fine Tuning解法。
本人全部文章请参见：博客文章导航目录
本文归属于：元学习系列
2. 预训练（Pretraining） 在小样本学习问题中，测试样本及其类别均不在训练集中，但是Support Set包含的类别是固定不变的。使用孪生网络解决小样本学习问题，会训练一个可以用来衡量图片之间相似度的神经网络，逐一比较Query图片和Support Set中各图片的相似度，并返回相似度最高的图片类别作为预测结果。这种小样本学习问题的解法显然没有利用Support Set中包含的类别固定不变的性质，因此并不是小样本学习问题最好的解决方法。
小样本学习问题的Pretraining+Fine Tuning解法的基本想法是在大规模数据集上预训练模型，然后在小规模的Support Set上做Fine Tuning。这种解决方法非常简单，但是准确率基本与小样本学习领域最好的方法相当。相较之下，许多非常复杂的方法的准确率没有显著高于这种非常简单的Pretraining+Fine Tuning方法。
由于小样本学习问题中Support Set包含的样本数量非常少，因此小样本学习问题的Pretraining+Fine Tuning解法与传统迁移学习中的Pretraining+Fine Tuning方法有所不同。
Pretraining阶段，搭建一个卷积神经网络用于从图片中提取特征，在大规模数据集上通过以下两个步骤训练该卷积神经网络：
基于 S o f t m a x + C r o s s E n t r o p y Softmax+CrossEntropy Softmax+CrossEntropy损失，使用标准的分类监督学习方法训练卷积神经网络；使用孪生网络中提到的方法，继续训练第1步中训练好的卷积神经网络。 深度学习实践证明，先使用交叉熵损失，基于传统的分类监督学习方法训练模型，而不是直接使用孪生网络相关方法训练模型，可以使得模型更快收敛；
使用孪生网络相关方法继续训练模型，可以使用余弦相似度（Cosine Similarity）作为损失函数，本文后续Fine Tuning阶段及预测时候会基于余弦相似度来进行小样本分类；
不同网络结构和训练方法会对最终结果产生影响。
2.1 使用预训练模型进行小样本分类 模型预训练完成后，已经可用来解决小样本分类问题了。如图一所示，给定一个3-Way 2-Shot Support Set，解决该小样本学习问题首先要用预训练好的神经网络提取特征，将所有图片全部变成特征向量。对每个类别所有图片的特征向量做平均，得到可以表征该类别的特征向量。进一步对得到的三个特征向量做归一化，形成 μ 1 , μ 2 , μ 3 \mu_1,\mu_2,\mu_3 μ1​,μ2​,μ3​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00d46c49b8c03463a90c47674ca38447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196cf2dd26ec1f4dca60450bdd261d42/" rel="bookmark">
			IDEA搭建Spring Boot项目（整合Mybatis Plus）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、点击文件—》新建—》项目
2、设置文件名称、路径等
3、点击下一步—》完成
4、在pom文件中添加依赖
&lt;!-- Mybatis Plus整合--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Web支持（Spring Mvc）--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--模板引擎thymeleaf整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 假如在如下这个地方出现了’org.springframework.boot:spring-boot-maven-plugin:’ 报错
将该行复制到报错的那一行下面再刷新maven依赖就好了
5、修改配置文件
在resources目录下新建yml文件（也可不新建，直接在application.properties中配置，但是yml文件可以使用缩进的形式省略重复的内容，语法比properties简洁）
spring: thymeleaf: cache: false # 关闭缓存,默认开启 # prefix: classpath:/pages/ #修改默认路径 classpath:/templates/ datasource: url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=CTT username: root password: driver-class-name: com.mysql.cj.jdbc.Driver # mybatis-plus配置 mybatis-plus: configuration: # 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射 map-underscore-to-camel-case: true # 这个配置会将执行的sql打印出来，在开发或测试的时候可以用 log-impl: org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/196cf2dd26ec1f4dca60450bdd261d42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46a60475b149243e6e3d9bce5612fc1/" rel="bookmark">
			波士顿房价预测(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		波士顿房价预测(一) 导语： 开始学习机器学习相关知识。波士顿房价预测，也是很经典的一个案例，我会陆续把自己完成整个项目的过程记录下来，还有就是可能会出现一定的差错，或者数据分析库使用的不是很熟练的情况，也希望大佬指出。另外，我是会一步步完善这个程序，但是只是从流程上完善，最后的结果因为数据集的原因可能不是会很准确。这篇文章更多是记录自己的学习情况，可能可借鉴度不高，如果是纯小白的话可以看一看，说不定会出现相同的问题，大佬请绕开把！！！
1.准备工作 该项目中我使用到了一下相关库
import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import random from sklearn.datasets import load_boston 大家可以自行检查用pip下载一下(这里就不说怎么用了哈！)，然后就是数据集的话，在sklearn库中有提供数据集，所以我就不提供了。
这里我是用的是：python3.8.3 、jupyter1.0.0、vscode
2.数据准备 导入相关库 ------------------- datasets = load_boston() #导入数据集 datasets.keys() &gt;&gt;&gt; dict_keys(['data', 'target', 'feature_names', 'DESCR', 'filename']) 可以看到存储类型与字典相似，所以使用keys()的方法打印出它的键，有五个参数在这里我们只需要用到前三个。
data = datasets['data'] #这是数据集 target = datasets['target'] #目标，也就是结果 column = datasets['feature_names'] #这是参数的索引 #将上述的数据转化成pandas的Dataframe Dataframe = pd.DataFrame(data,columns=column) Dataframe['price'] = target 运行结果如下：
在这里呢，我并没有选择用全部的数据(不是不会，而是我发现，我用全部的数据的时候，训练效果不是很好，还没找到原因)，所以我只挑选了两个对价格影响最高的参数。pandas中提供了相关系数的计算方法。
相关系数：值为（-1，1）越接近于1，就说明正相关性越强，越接近于-1，负相关性越强，0就是不想关，具体概念在《概率论与数理统计》中协方差那一节。
plt.figure(figsize=(12,8),dpi=80) sns.heatmap(Dataframe.corr()) #使用热力图观察更直观 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46a60475b149243e6e3d9bce5612fc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee2055318d08eae47b7a825703b5784/" rel="bookmark">
			路由器交换机（VRP系统）常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常用命令 #1 查看设备版本信息 &lt;Router1&gt;display version #2 用户视图 -&gt; 系统视图 &lt;Router1&gt;system-view [Router1] #3 为设备命名 [Router1]sysname Datacom-Router [Datacom-Router] #4 进入接口视图 [Datacom-Router]inter	//输入TAB补全命令 [Datacom-Router]interface //“interface”是唯一可选的关键字 [Datacom-Router]interface g //输入TAB补全命令	[Datacom-Router]interface GigabitEthernet //“GigabitEthernet”是唯一可选的关键字 [Datacom-Router]interface GigabitEthernet 0/0/1 //手动补全命令 #5 ?罗列出可选命令 [Datacom-Router-GigabitEthernet0/0/1]i? icmp &lt;Group&gt; icmp command group igmp Specify parameters for IGMP ip &lt;Group&gt; ip command group ipsec Specify IPSec(IP Security) configuration information ipv6 &lt;Group&gt; ipv6 command group isis Configure interface parameters for ISIS [Datacom-Router-GigabitEthernet0/0/1]ip ? accounting &lt;Group&gt; accounting command group address &lt;Group&gt; address command group binding Enable binding of an interface with a VPN instance fast-forwarding Enable fast forwarding forward-broadcast Specify IP directed broadcast information netstream IP netstream feature verify IP verify [Datacom-Router-GigabitEthernet0/0/1]ip address ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee2055318d08eae47b7a825703b5784/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5538cd30fcb68f61bbaacedc8854d04/" rel="bookmark">
			protobuf反序列化（protobuf报文解码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、建立test.txt，写入十六进制报文：
2、执行cat test.txt | xxd -r -p | protoc --decode_raw
3、或者先转格式：
xxd -r -p test.txt test1.txt
protoc --decode_raw&lt;test1.txt
4、显示字段名
protoc -I D:/codeGo/src/xxx/model/zzz D:/codeGo/src/xxx/model/zzz/zzz.proto --decode=zzz.Message&lt;data1.txt
–decode后参数为包名.结构体
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c85f12cb4c60317287300091c13dd909/" rel="bookmark">
			运筹学—最大流模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上两篇文章，我介绍了最短路径中的两种算法：
最短路径算法——清晰简单的弗洛伊德算法(Floyd)
最短路径算法——简单明了的迪杰斯特拉算法(Dijkstra)
这篇文章，我来简单介绍一下最大流模型！
最大流模型 \qquad 很多的数学模型往往来源于生活问题，本文介绍其中一个问题借此引出最大流模型，让读者能够更好地了解模型的背景以及应用。
\qquad 现有一管道网络用于运输原油，将原油从油井运输到提炼厂，为了在网络中顺畅地输运原油，需要在中间合适的距离安装增压泵站，每一段管道有一个有限的最大原油流量（容量），每段管道可以是单向，也可以是双向，取决于它的原始设计。那么如何确定从油井到提炼厂原油的最大流量？
\qquad 下面给定双向弧的相关概念：
\qquad 给定弧 ( i , j ) (i,j) (i,j)，其中 i &lt; j i&lt;j i&lt;j，用符号 ( C ‾ i j , C ‾ j i ) (\overline{C}_{ij},\overline{C}_{ji}) (Cij​,Cji​)表示两个方向 i → j ， j → i i→j，j→i i→j，j→i弧上的容量。为了更清晰地描述，把 C ‾ i j \overline{C}_{ij} Cij​放在靠近节点 i i i的一边，把 C ‾ j i \overline{C}_{ji} Cji​放在靠近节点 j j j的一边，如下图所示。
C ‾ i j 表 示 从 i → j 的 弧 上 的 容 量 ， C ‾ j i 表 示 从 j → i 的 弧 上 的 容 量 \overline{C}_{ij}表示从i→j的弧上的容量，\overline{C}_{ji}表示从j→i的弧上的容量 Cij​表示从i→j的弧上的容量，Cji​表示从j→i的弧上的容量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c85f12cb4c60317287300091c13dd909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c38def8f213f0c69eb6a2368fdc88e2/" rel="bookmark">
			js获取当前毫秒数（&#43;new date()）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js获取当前毫秒数（+new date()） 前言 在看视频的时候发现老师获取当前日期的毫秒表示时使用了let t1 = +new date()的写法，起初没有明白代码的含义，经过测试发现为日期的毫秒表示；
详情 代码： &lt;script&gt; let d1 = +new Date(); //1630316745222 let d2 = new Date(); //Mon Aug 30 2021 17:46:28 GMT+0800 (中国标准时间) console.log(typeof d1 +':'+ d1 ) console.log(typeof d1 +':'+ d2) &lt;/script&gt; 解释： 经测试和查阅后得知**+new Date ()**相当于调用 Date.prototype.valueOf ()方法，返回的是当下的时间距离1970年1月1日0时0分0秒的毫秒数
获取当前时间毫秒数的方法 +new Date()new Date().valueOf()new Date().getTime()Date.parse(new Date()) 注意：精确到秒，会将后三位舍弃为0 &lt;script&gt; //new Date().valueOf() let d1= new Date().valueOf(); console.log(d1) //1630318883445 // new Date().getTime() let d2= new Date().getTime(); console.log(d2) //1630318883445 //Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c38def8f213f0c69eb6a2368fdc88e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481110d0ebe4dbf0ecfe9b02517c9575/" rel="bookmark">
			数据库表连接之左连接(LEFT JOIN)、右连接(RIGHT JOIN)和内连接(INNER JOIN)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在有两张表，计算机学院学生表和选课表，表的结构如图所示：
Student
SCourse
为了更加直观的解释，先以上述两张表为基础执行相应的SQL语句，再进行解释。 左连接(LEFT JOIN)
SQL语句
SELECT * FROM Student LEFT JOIN SCourse ON Student.SNumber = SCourse.SID 执行结果 详细解释 LEFT JOIN首先取出的是主表的所有记录，在这个例子中也就是Student表的所有记录，然后按ON后面的条件进行连接，满足条件则把附表的相应记录加到主表的相应记录中，若没有满足条件的则相应字段为Null，也就是上图的结果。 右连接(RIGHT JOIN)
SQL语句
SELECT * FROM Student RIGHT JOIN SCourse ON Student.SNumber = SCourse.SID 执行结果 详细解释 RIGHT JOIN首先取出的是也是主表的所有记录，在这个例子中是SCourse表的所有记录，然后按ON后面的条件进行连接，满足条件则把附表的相应记录加到主表的相应记录中，若没有满足条件的则相应字段为Null，也就是上图的结果。 内连接(INNER JOIN)
SQL语句
SELECT * FROM Student INNER JOIN SCourse ON Student.SNumber = SCourse.SID 执行结果 详细解释 INNER JOIN不以哪个表为主表，只连接满足条件的记录。它就等价于： SELECT * FROM Student, SCourse WHERE Student.SNumber = SCourse.SID ————————————————
版权声明：本文为CSDN博主「初心不忘」的原创文章，遵循CC 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481110d0ebe4dbf0ecfe9b02517c9575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fb5205759399c0e2fd976e38c4670f/" rel="bookmark">
			S7-1200的指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常开触点与常闭触点 打开项目“位逻辑指令应用”，常开触点在指定的位为1状态时闭合，为0状态时断开。常闭触点反之。两个触点串联将进行“与”运算，两个触点并联将进行“或”运算。
2.取反RLO触点 RLO是逻辑运算结果的简称（能流流到哪，哪就是RLO），中间有“NOT”的触点为取反RLO触点，如果没有能流流入取反RLO触点，则有能流流出。如果有能流流入取反RLO触点，则没有能流流出。
3.线圈 线圈将输入的逻辑运算结果（RLO）的信号状态写入指定的地址，线圈通电时写入1，断电时写入0。
4.置位、复位输出指令 S（置位输出）、R（复位输出）指令将指定的位操作数置位和复位。
如果同一操作数的S线圈和R线圈同时断电，指定操作数的信号状态不变。
置位输出指令与复位输出指令最主要的特点是有记忆和保持功能。如果I0.4的常开触点闭合，Q0.5变为1状态并保持该状态。即使I0.4的常开触点断开，Q0.5也仍然保持1状态。在程序状态中，用Q0.5的S和R线圈连续的绿色圆弧和绿色的字母表示Q0.5为1状态，用间断的蓝色圆弧和蓝色的字母表示0状态。
5.置位位域指令与复位位域指令 “置位位域”指令SET_BF将指定的地址开始的连续的若干个位地址置位，“复位位域”指令RESET_BF将指定的地址开始的连续的若干个位地址复位。
6.扫描操作数信号边沿的指令 中间有P的触点的名称为“扫描操作数的信号上升沿”，在I0.6的上升沿，该触点接通一个扫描周期。M4.3为边沿存储位，用来存储上一次扫描循环时I0.6的状态。通过比较I0.6前后两次循环的状态，来检测信号的边沿。边沿存储位的地址只能在程序中使用一次。不能用代码块的临时局部数据或I/O变量来作边沿存储位。
中间有N的触点的名称为“扫描操作数的信号下降沿”，在M4.4的下降沿，RESET_BF的线圈“通电”一个扫描周期。该触点下面的M4.5为边沿存储位。
7.置位/复位触发器与复位/置位触发器 SR方框是置位/复位（复位优先）触发器，在置位（S）和复位（R1）信号同时为1时，方框上的输出位M7.2被复位为0。可选的输出Q反映了M7.2的状态。
RS方框是复位/置位（置位优先）触发器，在置位（S1）和复位（R）信号同时为1时，方框上的M7.6为置位为1。可选的输出Q反映了M7.6的状态。
8.在信号边沿置位（置1）操作数的指令 中间有P的线圈是“在信号上升沿置位操作数”指令，仅在流进该线圈的能流的上升沿，该指令的输出位M6.1为1状态（一个扫描周期）。其他情况下M6.1均为0状态，M6.2为保存P线圈输入端的RLO的边沿存储位。
中间有N的线圈是“在信号下降沿置位操作数”指令，仅在流进该线圈的能流的下降沿，该指令的输出位M6.3为1状态（一个扫描周期） 。其他情况下M6.3均为0状态，M6.4为边沿存储位。
上述两条线圈格式的指令对能流是畅通无阻的，这两条指令可以放置在程序段的中间或最右边。在运行时改变I0.7的状态，可以使M6.6置位和复位。
9.扫描RLO的信号边沿指令 在流进“扫描RLO的信号上升沿”指令（P_TRIG指令）的CLK输入端的能流（即RLO）的上升沿，Q端输出脉冲宽度为一个扫描周期的能流，方框下面的M8.0是脉冲存储位。
在流进“扫描RLO的信号下降沿”指令（N_TRIG指令）的CLK输入端的能流的下降沿，Q端输出一个扫描周期的能流。方框下面的M8.2是脉冲存储器位。P_TRIG
指令与N_TRIG 指令不能放在电路的开始处和结束处。
10.检测信号边沿指令 R_TRIG是“检测信号上升沿”指令，F_TRIG是“检测信号下降沿”指令。它们是函数块，在调用时应为它们指定背景数据块。这两条指令将输入CLK的当前状态与背景数据块中的边沿存储位保存的上一个扫描周期的CLK的状态进行比较。如果指令检测到CLK的上升沿或下降沿，将会通过Q端输出一个扫描周期的脉冲。
在输入CLK输入端的电路时，选中左侧的垂直“电源”线，双击收藏夹中的“打开分支”按钮，生成一个串联电路。用鼠标将串联电路右端的双箭头拖拽到CLK端。松开鼠标左键，串联电路被连接到CLK端。
11.边沿检测指令的比较 以上升沿检测为例，P触点用于检测触点上面的地址的上升沿，并且直接输出上升沿脉冲。其他3种指令都是用来检测RLO（流入它们的能流）的上升沿。
P线圈用于检测能流的上升沿，并用线圈上面的地址来输出上升沿脉冲。其他指令都是直接输出检测结果。
R_TRIG指令与P_TRIG指令都是用于检测流入它们的CLK端的能流的上升沿，并直接输出检测结果。其区别在于R_TRIG指令用背景数据块保存上一次扫描循环CLK端信号的状态，而P_TRIG指令用边沿存储位来保存它。
总结 视频链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015b5f80c7751343bd0d64375e1043c9/" rel="bookmark">
			Sharding-Proxy实战(水平分表、水平分库、垂直分表、读写分离)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sharding-Proxy实战 基本概述 使用过Sharding-JDBC都知道需要为每一个运用到Sharding-JDBC的项目编写一大片配置文件，Sharding-Proxy就可以解决Sharding-JDBC上遇到问题，Sharding-Proxy定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持，简单来说分库分表的工作都由Sharding-Proxy服务端去完成，Sharding-Proxy是Webapp服务端，你只管发增删改查不有管你要操作什么库，Sharding-Proxy受到你的消息后会自己安排去操作那个数据库然后把结果给回你
Sharding-Proxy有以下几个特定
Sharding-Proxy是一个独立的服务，需要安装安装，并且做好分库分表配置目前只支持MySQL/PostgreSQL协议的的客户端 服务安装 安装包下载 这里我下载4.0.1的版本，Sharding-Proxy下载地址
解压安装包 使用命令解压压缩包，解压压缩包后进入到bin目录可以看到有几个启动脚本win下使用bat脚本，liunx使用sh脚本即可
# tar命令解压压缩包 tar -xvf apache-shardingsphere-incubating-4.0.1-sharding-proxy-bin.tar.gz 解压后的坑 注意这里有一个坑，解压压缩包后要检查一下lib下的文件是否完整，有时候解压完成后lib解压处理的文件会少了后缀名的，正常情况应该都是.jar后缀，如图这是异常情况，解决这个问题办法就是重新解压或者手动把那些文件名修改一下都不上.jar后缀，不让等一下启动服务时会提示找不到jar包
分表配置 修改server.yaml 进入到conf目录下，修改server.yaml文件
server.yaml修改很简单，只需要将这部分内容的注释去掉即可
修改config-sharding.yaml 进入到conf目录下，修改config-sharding.yaml文件，里面有一些模板，配置其实和JDBC是一模一样的，在本地数据库中创建一个demo_ds_0，当然也可以使用已有的数据库
使用注意 在配置文件中，可以那么一句话如果你要连接msyql那么需要手动的把mysql驱动的jar包放到lib目录下否则程序无法运行
服务启动 执行start.bat服务启动(liunx下执行sh文件)有2种方式带端口和不带端口
不带端口：默认使用3307端口带端口：使用你指定的端口 start.bat 8888 看到如下内容表示启动成功
连接客户端 最好使用cmd命令行去连接，虽然如Navicat、DataGrip等这些客户端也是可以的，当时有时又不可以好奇怪的，所以这里使用cmd的mysql命令去连接Sharding-Proxy，就和连接数据库一样使用mysql -P3307 -uroot -p即可连接
注意不要搞混了哦这里连接的是Sharding-Proxy不是Mysql数据库，只是连接Sharding-Proxy方式和数据库一样
使用sql命令操作 查看本地数据库 查看我们本机的实际数据库中发生的变化，可以发现我们只执行了一条建表语句，Sharding-Proxy根据配置文件配置的规则给我们创建了t_order_0和t_order_1，并且我执行插入order_id是奇数所以数据被插入在t_order_1表中
分库配置 修改config-sharding.yaml 服务启动 执行start.bat服务启动(liunx下执行sh文件)有2种方式带端口和不带端口
不带端口：默认使用3307端口带端口：使用你指定的端口 start.bat 8888 看到如下内容表示启动成功
连接客户端 最好使用cmd命令行去连接，虽然如Navicat、DataGrip等这些客户端也是可以的，当时有时又不可以好奇怪的，所以这里使用cmd的mysql命令去连接Sharding-Proxy，就和连接数据库一样使用mysql -P3307 -uroot -p即可连接
注意不要搞混了哦这里连接的是Sharding-Proxy不是Mysql数据库，只是连接Sharding-Proxy方式和数据库一样
使用sql命令操作 查看本地数据库 查看我们本机的实际数据库中发生的变化，可以发现我们只执行了一条建表语句，Sharding-Proxy根据配置文件配置的规则给我们创建了t_order_0和t_order_1，并且也根据相应的规则插入了数据
读写分离 读写分离也是一种很好的提升数据库性能的解决方案，在了解如何使用Sharding-Proxy之前首先需学会如何部署Mysql主从配置，如果还没部署过的前阅读以下文章
Sharding-Proxy是不做主从复制数据同步的，主从复制需要通过配置Mysql实现，而Sharding-Proxy只是根据语义(CRUD)判断你是做增删改查的那种操作，并且给你路由到主库/从库
Mysql-主从配置与读写分离
修改config-master_slave.yaml 进入到conf目录下，修改config-master_slave.yaml文件
服务启动 执行start.bat服务启动(liunx下执行sh文件)有2种方式带端口和不带端口
不带端口：默认使用3307端口带端口：使用你指定的端口 start.bat 8888 看到如下内容表示启动成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015b5f80c7751343bd0d64375e1043c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc87c081d22b08c4666e620abb1afb41/" rel="bookmark">
			最短路径算法——清晰简单的弗洛伊德算法(Floyd)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		弗洛伊德算法(Floyd) \qquad 上一篇文章介绍了迪杰斯特拉算法(Dijkstra)。具体请看：最短路径算法——简单明了的迪杰斯特拉算法(Dijkstra)。Dijkstra适用于非负权图，并且一次只能从网络中找源点到任何一个节点的最短路径，而Floyd算法的应用更加广泛，可以求网络中任意两点之间的最短路径，而且弗洛伊德算法适用于负权图，这篇文章就用图和表的形式来介绍一下弗洛伊德算法！
1 思想（原理） \qquad Floyd算法可以给出网络中任意两个节点之间的最短路径，因此它是比Dijkstra更一般的算法。Floyd算法的思想是将 n n n个节点的网络表示为 n n n行 n n n列的矩阵，而矩阵中的元素 ( i , j ) (i,j) (i,j)表示从节点 i i i到节点 j j j的距离 d i j d_{ij} dij​，如果两点直接没有边相连，则相应的元素就是无穷 ( ∞ ) (\infty) (∞).
2 步骤 &lt;1&gt; 第0步：定义初始距离矩阵 D 0 D_0 D0​、节点序列矩阵 S 0 S_0 S0​，如下表。对角线上用”—“表示不需要从自身到自身。
\qquad 这里的节点序列矩阵相当于路线表，如下表， S i j = j S_{ij}={j} Sij​=j表示，从节点 i i i到节点 j j j只需经过节点 j j j即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc87c081d22b08c4666e620abb1afb41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9eebc6552ec3393664522cddcd73c05/" rel="bookmark">
			在el-tree中显示数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树形组件中的data绑定的数据必须是树形格式的数据，如下所示
&lt;el-tree :data="data" :props="defaultProps" @node-click="handleNodeClick"&gt;&lt;/el-tree&gt; &lt;script&gt; export default { data() { return { data: [{ label: '一级 1', children: [{ label: '二级 1-1', children: [{ label: '三级 1-1-1' }] }] } }], defaultProps: { children: 'children', label: 'label' } }; }, methods: { handleNodeClick(data) { console.log(data); } } }; &lt;/script&gt; 而我们后台拿到的数据一般都是平铺的，所以我们要将其转换为树形结构，具体如何转换可以看我前面的文章。
&lt;!-- 树形结构数据展示 --&gt; &lt;el-tree :data="permissionData" // :props="{ label: 'name' }"这样写是因为树形组件只识别label来当作名称， //不识别name所以我们要把data中的name属性替换为label :props="{ label: 'name' }" /&gt; 属性配置 想去官网看的这有链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9eebc6552ec3393664522cddcd73c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67877ec086da1cfa3408ee17597ddb38/" rel="bookmark">
			SpringBoot 之使用 Jackson 统一配置日期格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Jackson 统一配置日期转换格式使用 @ResponseBody 时 忽略 json 中值为null的属性Json序列化时忽略某个属性，序列化和反序列化都受影响Jackson 中对null的处理 Jackson 统一配置日期转换格式 方案一：
#jackson相关配置 spring.jackson.date-format = yyyy-MM-dd HH:mm:ss #时区必须要设置 spring.jackson.time-zone= GMT+8 #ALWAYS的意思是即时属性为null，仍然也会输出这个key spring.jackson.default-property-inclusion=ALWAYS spring: jackson: default-property-inclusion: ALWAYS time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss 针对form表单格式，加下面这句配置就可以：
spring.mvc.dateFormat = yyyy-MM-dd HH:mm:ss 方案二：
如果个别实体需要使用其他格式的 pattern，在实体上加入注解即可。
@JsonFormat(timezone = "GMT+8",pattern = "yyyy-MM-dd HH:mm:ss") 使用 @ResponseBody 时 忽略 json 中值为null的属性 统一配置：
spring.jackson.default-property-inclusion=non-null 类单独配置：
import java.io.Serializable; import com.fasterxml.jackson.annotation.JsonInclude; @JsonInclude(JsonInclude.Include.NON_NULL)//该注解配合jackson，序列化时忽略 null属性 public class AjaxResult implements Serializable { } Json序列化时忽略某个属性，序列化和反序列化都受影响 @JsonIgnore Jackson 中对null的处理 在实际项目中，难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67877ec086da1cfa3408ee17597ddb38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b58de7d5785bc36dcfc7bde279ce28/" rel="bookmark">
			Serverless 2021 最新调查报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据更新于 2021年 5月，数据来源于国外 DATADOG 的调查报告
近两年以来 Serverless 已经获得了极大的关注，从云原生初创公司到大型公司。借助于 Serverless，开发团队可以更专注得将想法推向市场化，只需为他们的使用量付费即可，不必关心相关基础设施。
在这份调查报告中，我们调查了数千家公司运行的数百万个函数，以了解 Serverless 在生产环境中的实际使用情况。
其中 Serverless 应用场景广泛，从短任务到面向用户的应用程序。AWS Lambda 是最成熟，使用最广泛的 Faas 产品，同时也可以看到 Azure Functions 和 Google Cloud Functions 的使用率也增长惊人。当前 Serverless 的生态系统已经不局限于 Faas，还包括其他数十种服务，可以帮助开发者更快得构建应用。四分之一的 Amazon CloudFront( CDN 产品)用户已经接受了 Serverless 边缘计算，同时也有不少组织开始利用 AWS Step Functions 用来管理各种分布式应用。
Lambda 函数的调用频率是两年前的 3.5 倍 AWS Lambda 通过构建高度可扩展的应用程序使开发人员可以更快地进行创新，无需担心基础设施。如今，团队不仅在试验 Serverless 产品，而且 将其作为其软件系统的关键部分。事实上，我们的研究表明，自 2019 年以来一直在使用 Lambda 的公司已经显著增加了 Lambda 的使用率。平均而言，在 2021年初，函数每天被调用的频率是两年前的 3.5 倍。此外，在同一组 Lambda 用户中，每个组织的 Lambda 函数 平均每天运行 900 小时。
Azure Functions 和 Google Cloud Functions 势头强劲 AWS Lambda 率先发起了 Serverless 热潮，但并不是唯一的游戏参与者。Azure Functions 和 Google Cloud Functions 在各自的云平台中的使用率都在增长。在过去的一年中，运行 Azure Functions 的 Azure 的组织的份额从 20% 攀升至 36%。在 Google Cloud 上，近四分之一的组织现在使用 Cloud Functions。尽管 Cloud Functions 是推出的三个 FaaS 产品中的最后一个，但 Serverless 在 Google Cloud 中并不是一个新概念——云平台早在 2008 年就推出了 Google App Engine，这是它的第一个完全无服务器的计算服务。但今天，我们看到了势头的转变转向谷歌较新的无服务器产品，即 Cloud Functions 和 Cloud Run。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b58de7d5785bc36dcfc7bde279ce28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551d3de3884ddd056e27ab509ea71ada/" rel="bookmark">
			Type-c PD QC AFC取电芯片 快充芯片LDR6328S
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些年，Type-c接口强大的功能，造就了Type-C接口的大量普及，日常生活中到处可以看到消费者使用的支持Type-c接口的电子产品，如手机，笔记本，筋膜枪，蓝牙音箱等等。那么，像筋膜枪，蓝牙音箱，四轴飞行器，小风扇，台灯等这样的用电器，想要支持Type-c PD的快充功能，就需要内置一颗USB Type-C PD取电（诱骗，诱电，SINK）芯片。
LDR6328S是一款兼容 USB PD、QC 和 AFC 协议的USB Type-C PD取电（诱骗，诱电，SINK）芯片，从支持 USB PD、QC 和 AFC 协议的适配器取电，然后供电给设备。比如可以配置适配器输出需要的功率，给筋膜枪，蓝牙音箱，四轴飞行器，小风扇，台灯等这样的用电器设备供电。
USB PD受电端取电芯片（乐得瑞取电受电)LDR6328S 支持多协议快充取电！
1、概述
LDR6328S 是乐得瑞科技有限公司开发的一款兼容 USB PD、QC 和 AFC 协议的 Sink 控制器。
USB PD受电端取电芯片LDR6328S 从支持 USB PD、QC 和 AFC 协议的适配器取电，然后供电给设备。比如可以配置适配器输
出需要的功率，给无线充电器设备供电。LDR6328S 也兼容传统 USB 电源适配器。
USB PD受电端取电芯片（乐得瑞取电受电)LDR6328S 支持多协议快充取电！
2、特点
◇ 采用 SOP-8 封装，封装小。
◇ 兼容 USB PD 3.0 规范，支持 USB PD 2.0
◇ 兼容 QC 3.0 规范，支持 QC 2.0
◇ 支持 三星AFC 协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551d3de3884ddd056e27ab509ea71ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e73d2b8c6df1406e0d57259bb63dd10/" rel="bookmark">
			OD(Ollydbg)简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ollydbg简介：
Ollydbg 通常称作OD，是反汇编工作的常用工具，OD附带了200脱壳脚本和各类插件，功能非常强大，可以过SE，VMP3.0，深受逆向圈内人士的喜爱
OD，是一个反汇编工具，又叫OllyDebug，一个新的动态追踪工具，将IDA与SoftICE结合起来的思想，Ring 3 级的调试器，己代替SoftICE成为当今最为流行的调试解密工具了。同时还支持插件扩展功能，是目前最强大的调试工具。基本上，调试自己的程序因为有源码，一般用vc，破解别人的程序用OllyDebug。
这里面地址即为程序的内存地址,hex即为hex数据，反汇编就是程序的汇编代码，注释即为od分析出来的，双击即可编辑，信息窗口能对操作进行更加详细的查看。
1.寄存器窗口:
这里就简单介绍几个通用寄存器
ESP:指向堆栈栈顶
EBP:大部分用来定位局部变量和参数
其余的就各自拆开来用
另外, 点击标签寄存器 (FPU) 可以切换显示寄存器的方式
2.数据窗口:
数据窗口主要的即为程序或者内存的数据,右键可以切换显示方式
3.堆栈窗口:
主要存放线程的临时数据,可以用于动态调试.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ebeb45699c312ce8668fd3a8d00fb0/" rel="bookmark">
			基于RT Thread的ETH应用(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于RTT的ETH应用（一） 实现目的：通过ETH实现互联网访问
1.CubeMX配置相关参数 1.1配置时钟参数 1.2配置ETH 本文采用正点原子F4探索者，故相关配置引脚不能使用cubemx默认，根据原理图进行配置
1.3 Rt thread Studio设置 1.3.1进入board.h查看说明 /** if you want to use eth you can use the following instructions. * * STEP 1, define macro related to the eth * such as BSP_USING_ETH * * STEP 2, copy your eth init function from stm32xxxx_hal_msp.c generated by stm32cubemx to the end if board.c file * such as void HAL_ETH_MspInit(ETH_HandleTypeDef* heth) * * STEP 3, modify your stm32xxxx_hal_config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ebeb45699c312ce8668fd3a8d00fb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d23d3563698a349f3114eef4bd0ea4/" rel="bookmark">
			php框架hyperf增加验证场景，仿thinkphp框架，可增加自定义方法，可根据场景增删 验证规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：php8，centos7.2
hyperf版本：2.2
由于hyperf框架 没有自带验证场景，所以本人参考thinkphp框架写了一个，并非完全实现了thinkphp框架的验证层，只是根据本人使用，简单化实现，如果写得不好，大佬们请轻喷
验证器基础类：
namespace App\Validate\Api; use Hyperf\Di\Annotation\Inject; use App\Exception\ErrorMessageException; use Hyperf\Validation\Contract\ValidatorFactoryInterface; abstract class BaseValidate { /** * @Inject() * @var ValidatorFactoryInterface */ protected $validationFactory; protected $rule = []; protected $message = []; protected $parameters = []; /** * 规则 * @return array */ protected abstract function rule(): array; /** * 自定义，提示语 * @return array */ protected abstract function message(): array; /** * 自定义方法，以匿名方式命名 * @return array */ protected abstract function callBack(): array; public function __construct() { $rules = $this-&gt;rule(); foreach ($rules as $key =&gt; $rule) { if (is_string($rule)) { $rules[$key] = explode("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d23d3563698a349f3114eef4bd0ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9980a5b272c2b1acb4cc525c46d0951a/" rel="bookmark">
			最短路径算法——简单明了的迪杰斯特拉算法(Dijkstra)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最短路径算法——迪杰斯特拉算法(Dijkstra) \qquad 最短路径问题是在一个网络中求一条从出发点到目的点的最短路径。
\qquad 这里会介绍求解有圈网络和无圈网络的2个算法：迪杰斯特拉算法(Dijkstra)、弗洛伊德算法(Floyd)。Dijkstra算法可以求网络中从源点到任何一个节点的最短路径，而Floyd算法的应用更加广泛，可以求网络中任意两点之间的最短路径。
1迪杰斯特拉算法(Dijkstra) 1.1 各种定义 \qquad s i s_i si​表示从源点到节点 i i i的最短距离， d i j d_{ij} dij​(≥0)表示弧 ( i , j ) (i,j) (i,j)的长度。
\qquad 根据上述两个定义给出某一节点 j j j的标号（标号–通过数据对某一节点进行表示）：
[ s j , i ] = [ s i + d i j , i ] ， d i j ≥ 0 [s_j,i]=[s_i + d_{ij}, i]，d_{ij}≥0 [sj​,i]=[si​+dij​,i]，dij​≥0
\qquad 用该式表示节点 j j j， [ s j , i ] [s_j,i] [sj​,i]中的 s j s_j sj​表示源点到节点 j j j的最短距离， i i i表示节点 j j j的“父节点”（来源节点）为 i i i，即节点 j j j的上一个节点是节点 i i i； [ s i + d i j , i ] [s_i + d_{ij}, i] [si​+dij​,i]中的 s i + d i j s_i + d_{ij} si​+dij​表示源点到节点 j j j的最短距离=源点到节点 i i i的最短距离+弧 ( i , j ) (i,j) (i,j)的长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9980a5b272c2b1acb4cc525c46d0951a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ff5c4d099779c35dc3c148f7292e39/" rel="bookmark">
			WPF（自适应圆）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在WPF中可以实现椭圆，利用Ellipse或者Border。但是要实现圆，就必须设定固定的长宽，然后根据长宽设置对应的倒角才可以实现圆。如果这样设计，就固定了长宽，不能根据界面自适应调整。所以我们可以根据绑定和转换器将实际的长宽转换为对应的倒角。
using System; using System.Globalization; using System.Windows.Data; [ValueConversion(typeof(double), typeof(double[]))] public class RoundMathConverter : IMultiValueConverter { public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture) { if (values.Length &lt; 2) { throw new NotImplementedException(); } double.TryParse(values[0].ToString(), out double d1); double.TryParse(values[1].ToString(), out double d2); if (d1 * d2 == 0) { return double.NaN; } return Math.Min(d1, d2); } public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture) { throw new NotImplementedException(); } } [ValueConversion(typeof(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81ff5c4d099779c35dc3c148f7292e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b08d542057f0c564c35ec7576bf1c3/" rel="bookmark">
			单元测试，报java.lang.NoClassDefFoundError:org/springframework/test/content/TestContesxtAnnotationUtils
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里写目录标题 一级目录1.问题:单元测试，报java.lang.NoClassDefFoundError:org/springframework/test/content/TestContesxtAnnotationUtilsspring/spring-boot相关的版本不一致也会影响2.加油，面向百度编程人！正所谓:念念不忘,必有回响 一级目录 1.问题:单元测试，报java.lang.NoClassDefFoundError:org/springframework/test/content/TestContesxtAnnotationUtils 搜索了很多，发现都说的的spring版本和junit版本不同。
我们可以去maven仓库:https://mvnrepository.com/
看下我们spring依赖那个版本。
下翻有很多，如果test相关的版本低于改下就好了。
spring/spring-boot相关的版本不一致也会影响 这个怎么说呢，就是spring-boot 包含的spring-boot-test的版本，
和spring-boot-autoconfigure 版本是否和spring-boot的主版本一致，有时候你在其他模块引用的时候可能会引用到期maven jar包里面的依赖。
还有一个你得特别注意org.springfranmework.spring-test 的版本。
最好org.springfranmework.spring-xxx的版本都保持一致。比较容易排查问题。
花了半天解决的问题，很焦躁的。
解决这些依赖问题的时候脑子一定要清晰:
有以下几点供参考:
1.maven jar包是否有冲突
2.引用的jar包版本是否是你所想要的，因为你在导包的时候可能会导入其他jar包依赖的版本去了
3.有依赖关系的不同的jar包，版本是否符合要求，比如A的第一版不一定能支持B的第二版。
4.一定要看报错信息，基本上报错会告诉你原因。比如说:
有个mapper应该是有某某jar包去注入，但xxxjia包不存在，另一个jar试图去读取，违背单一注册实例… jar包冲突
在比如说：本文的org/springframework/test/content/TestContesxtAnnotationUtils 很明显得告诉我了是spring的test相关的jia包有问题。
尽量定位为题发生的范围，逐渐缩小范围，问题就会找到并解决
2.加油，面向百度编程人！ 当你心烦意燥的时候，做点其他事转移下注意力，心情好了，再来解决问题，没事多想想，有时候灵感就这么来了。
正所谓:念念不忘,必有回响 .
正所谓:念念不忘,必有回响 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf9aeab7bc2e118dec7e79ae7aa0200/" rel="bookmark">
			【事件相机与计算机视觉】论文分享--End-to-End Learning of Representations for Asynchronous Event-Based Data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 .前言 事件相机作为一种新型的图像数据形式，由于其时间分辨率高、高动态范围、低功耗的优点，在许多CV问题上有着比传统相机更好的表现，但要想将其产生的数据流用于现有深度网络中，需要将数据转化为网络可以处理的形式。笔者在之前的综述分享中介绍了许多事件相机的数据转化方式，但是由于它们都压缩了某个维度，造成了信息丢失，因此都具有一定缺陷。
本次笔者分享的是一篇ICCV的论文，作者提出了一种综合了所有信息的事件数据表示方式EST。在这种方式下，压缩某个维度即可得到例如Event-frame、Voxel等目前常见的表达方式，EST因此可以说是事件数据表示的集大成者。同时，作者更是在变换中提出了一种可训练的核函数，使得数据表示可以通过端对端训练来更加“适应”任务。
论文原文：
End-to-End Learning of Representations for Asynchronous Event-Based Data
若不了解事件相机，关于事件相机的综述导读可以阅读笔者的文章：
Event-based Vision: A Survey——从这篇综述开始了解事件相机（一）
1. 论文总览 本篇论文解决了事件相机用于深度学习的一个最基本但也是最关键的问题：将事件流数据处理为深度网络可以接收的“网格”数据。目前，常用的事件流表示法有Event-Frame（Single or Two Channel）、Voxel、Time Surface等，它们已经在许多领域大放异彩，表现出超越传统相机的训练结果；哪怕是最简单的Event-Frame形式，在汽车转角预测、图像重建、视频去模糊等问题上也能有优于传统灰度图的结果。但正如笔者多次提到的那样，这几种数据表示法可以说都“浪费”了一部分事件流的信息，在一些问题上也许够用，但还是有很大提升的空间以获得更精确的结果。
因此文中提出了上图所示的Event Spike Tensor（简称EST）的事件数据表示方法，对于一个四元组事件，EST能够涵盖其位置、时间、极性等所有信息，因此能够充分利用事件流的时间分辨率、动态范围、运动捕捉等优势。同时，比起笔者经常处理事件流的方式（对事件的极性进行简单的叠加、用极性来表示每个像素点的值），作者还增加了测量函数、核变换等流程，使得生成的EST能够包含更多信息，并且更具有“意义”（笔者认为此处的“意义”在于合理的核变换能够使得事件的信息更加充分地体现，即变换后网络更能提取出某些特征），甚至该核函数可以用多层感知机（MLP）替代，作为学习的一部分，让网络自己去选择核。
本文的亮点在于：
1）：提出了一种综合的事件数据表示法EST。包含了事件流所有的信息，同时处理过程中引入了测量函数和核函数的变换，使得事件流的信息能被更有效地提取；
2）：提出了一种端到端学习的事件表示方法。用MLP取代核函数，使得EST具有可学习型，实现事件流—&gt;网络输出的端到端学习。
2. 数学模型 2.1 Event Spike Tensor —EST 建立 事件相机中DVS模块输出四元组事件流：
上述事件流表示了四元空间中的点，引入Event Field这一概念，通过狄拉克脉冲函数将这些事件进行整合，Event Field表示了特定像素点、时间戳处，事件产生的不同极性的脉冲（可以理解为原本事件是点集，现在用函数将其表达出来）：
深度卷积网络显然处理不了这样的脉冲（SNN专门处理这种脉冲），因此作者引入了一个定义在事件域的、连续的测量函数来具体化每个事件。这个可以是事件极性（），可以是事件数，也可以是平均时间戳，或者是其他任何包含事件流某种信息的值。（该部分笔者这样理解：在事件域这一包含空间像素和时间戳的坐标系中，每个事件原本都是脉冲，通过来将脉冲替换为一个具体的量，若是极性，便是Voxel、若是时间戳再压缩，便是Time Surface）
为了让事件表示方式更加具有“意义”，作者对上述S与一个核变换函数进行了卷积操作，只要核函数选取得合适，那么得到的事件表示就有可能让卷积网络学到更多特征。核函数内是包含狄拉克脉冲函数的，可以看作它是针对狄拉克函数的一种变化，得到一种有“意义”的函数来将事件具体化。常用的核函数有：指数核函数；alpha核函数：
；三元线性投票核函数：。当然，核函数没有绝对的优劣，对于特定的问题，有的核函数能使事件数据表现出更多可学习的特征。核函数变换表达式如下：
最后，为了使数据“网格化”，以便输入进卷积网络（卷积网络接受数据可以看作以像素为单位的网格），作者对核变换后的事件进行了取样，取样是在时间维度进行的，根据事件密度通过选取一个合适的时间间隔，将连续的事件离散化，最终得到EST模型：
其实笔者对上述数学模型理解并不是很透彻，仅仅是理解了一个大意。笔者看来，事件一直都存在于上图所示的三维空间中，极性这第四维可以看作是空间中每个点的标记；测试函数为空间中的事件点赋予有意义的值；核函数卷积（可以看作是对3D图像进行3D卷积操作）对整个空间进行某种运算得到另一个三维空间（依然是坐标和时间三维，但是每个点的值因卷积运算改变了）；最后再将连续的三维空间离散化变为网格得到EST模型。
对EST的某个维度进行叠加，即可得到我们常见的几种事件表示（笔者认为对于Voxel这些表达方式来说，可以不加核变换），在此不再展示具体公式。
2.2 端对端学习 本篇论文另一个精妙之处在于实现了可端对端学习的事件表示方法。对于核函数，与其费尽心思去寻找一个合适的，不如直接引入一个充满参数的卷积核，让网络自己决定自己想要什么样的数据。这就好比卷积网络中，卷积操作实为一种特征提取器，而卷积神经网络则是将特征提取器全设为参数，让网络自己学习需要提取的特征。 因此，作者选择采用多层感知机（MLP）来替代核函数，事件的坐标和时间戳作为输入，以此生成激活映射（取代核变换的作用）。
笔者自己绘制的学习流程如上。作者实现了事件流到输出的端对端学习系统，根据系统得到的输出与目标值的损失，进行反向传播，其中MLP的参数也是需要进行梯度下降更新的，这使得任务本身对事件的表示方式也有了选择权，自然也能有比人工选择核函数更好的训练效果。
3. 实验结果 作者在物体识别和光流估计这两个具体问题上进行了实验分析，选用了多种事件表示方式进行了对比。同时对于不同的事件表示方式，作者还对比了测量函数与核函数对结果的影响（端对端学习属于不同核函数的选取），最终都能发现选用MLP进行端对端学习的方式表现得更为出色。由于笔者对光流计算了解甚少，此处只展示物体识别的结果，望读者见谅。
作者分别在N-Cars以及N-Caltech101这两个开放数据集上进行了测试，采用了Resnet-34的网络结构，先在ImageNet上进行了预训练，选用了交叉熵损失函数和ADAM优化算法，初始学习率为1e-5，每10000次迭代就减少2倍，N-Cars与N-Caltech101采用的batch分别为60和100。识别任务结果如下：
从上表可以看出，采用时间戳作为测量函数效果最好，这也不难理解，毕竟这样事件信息更加丰富（即便是EST也压缩了部分时间，时间戳作为测量函数能够补充一定的时间信息）；而在核函数选取方面，对于固定的核函数来说，三元线性投票函数的效果最佳，但也比不上端对端学习的方式。综合来看，采用时间戳作为测量函数，将核变换替换为MLP进行端对端学习的事件表示方式，在物体识别这个任务上表现得最佳，即便不引入MLP，EST相较于其他常用表示方法来说也具有优势，这也证明了这篇论文提出的EST的有效性。
4. 小结 本篇论文可谓是所有事件数据表示方法的集大成者，给出了一种综合的事件表示模型EST，构建了一种事件数据转化的通用框架，涵盖了事件流几乎所有的有用信息，同时还能经过叠加转化为Voxel等我们常用的类型，更不用说引入MLP实现了端对端学习。
当然，本文对笔者来说，最大的意义在于充分了解了每一种事件数据的表示方法，以便针对不同问题去使用，毕竟即便是效果最差的Event Frame，相较于传统灰度图来说都是极具优势的，因此没必要在每个问题上都要采取EST进行端对端学习（EST数据量较大，使得训练消耗的时间更多）。但作者提出的数据表示框架还是极具价值的，如果能够正确复现并广泛使用，那么将节省很多数据处理的功夫，我认为这也是事件相机领域发展成熟的关键一步。
最后，谢谢大家读到最后，文中许多细节笔者未作太多阐述，若想复现该篇论文，读者还需更加深入阅读，请见谅。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811d02b22616456174040bb8ceec2e9e/" rel="bookmark">
			常考基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.const：定义常量，修饰形参，修饰返回值（指针）
2.static：静态变量调用维持值不变，限制变量作用域，限制函数作用域
3.static全局与普通全局区别：static变量值初始化一次，防止在其他文件中被引用；static函数在内存中只有一份
4.C++类的静态成员、方法不属于类的实例，属于类的本身并在所有实例间共享。
5.字节对齐原则：
1.结构体变量首地址能被最宽基本类型成员大小所整除。2.结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍。 3.结构体总大小为结构体最宽基本类型成员大小的整数倍。
6.class中，普通函数不占用内存，虚函数占用一个指针大小的内存
7.sizeof用途：动态分配对象时，可让系统知道要分配多少内存
8. 类的内联函数会检查参数，也可做为成员函数。
9.内联函数和宏的区别：1.内联函数在编译时展开，宏在预编译时；编译时内联函数直接镶嵌到代码中，宏是简单的替换；内联函数可进行类型检查、语句是否正确等；宏定义时参数加（），避免出现二义性
10.指针和引用的区别：
1.初始化不同：引用在创建时必须初始化，即引用到一个有效对象，指针不必初始化
2.引用一旦初始化被指向一个对象后，就不能再指向其他对象；指针可改变指向
3.不存在NULL引用，引用不能为空
4.引用不需要测试合法性，指针需要
11.引用安全，不存在空引用，指针可能时野指针
12.常量指针：指向常量的指针，指向的地址的内容不能修改。char const * p2
指针常量：指针的常量，不可改变地址的指针，但是可对指向的内容改变 char * const p1 13.指针数组：数组中每个元素都是指针 int *a[10] 数组指针：指向数组的指针 int *a=int[10]
14.函数指针：指向函数地址的指针 int(*arr)(int,int) 指针函数：返回指针类型的函数。int *fun()
15.malloc/free new/delete的区别
malloc/free库函数，对非内部数据类型的对象而言，对象在消亡前要自动执行析构函数，但malloc/free不在编译器控制权限内，不能执行构造函数和析构函数；new/delete运算符
16.内存分配方式：
1.静态存储区：在编译时已经分配好，全局变量
2.栈：函数内部变量，函数结束时被释放。效率高，但分配的内存容量有限。
3.堆：动态分配，自己决定生存期
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a711f6ee24843c14397aa188822ec15/" rel="bookmark">
			C&#43;&#43;独有的特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL容器
序列容器：vector,string list
vector和list的区别：
vector:和数组类似，有连续的内存空间且起始地址不变，内存空间不够要重新申请内存。
list:双向链表实现，空间不连续，指针访问。
关联容器：set map
map:红黑树，二叉查找树，可自动按键值排序。是标准的一部分。
hashmap:哈希表，各项操作的评价时间复杂度近常数。
适配容器：stack queue dequeue(动态数组，双向队列实现)
STL智能指针：auto_ptr，当出现异常时，分配的对象能被自动销毁，内存自动释放。
多态 封装 继承
继承
私有继承：编译器不会将派生类对象转换成基类对象。从私有基类继承来的成员都成为了派生类的私有对象。
多重继承：优点：可调用多个基类中的接口 缺点：容易出现继承向上的二义性，解决办法，改为虚拟继承，不会出现重复拷贝现象。
多重继承中的构造函数顺序：
1.虚拟基类的构造函数按照它们被继承的顺序构造
2.非虚基类的构造函数按照被构造的顺序
3.成员对象的构造按照声明顺序调用
4.类自身构造函数
多态
1.编译时多态：通过重载实现，对非虚成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现哪种操作
2.运行时多态：虚成员。运行时才根据具体情况决定实现何种操作。
虚函数
1.系统会为类分配一个指针成员指向一个虚函数表，表中每项指向一个虚函数的地址，即函数指针数组。
2.虚函数表一继承性和多态性。
3.构造函数不能调用虚函数
虚函数和纯虚函数的区别：
1.虚函数在类中可以实现，作用是为了让这个函数在子类里可以被覆盖，实现多态。纯虚函数只是一个接口，函数声明，在子类中实现
2.虚函数在子类中可以不重载，纯虚函数必须在子类中实现
3.虚函数的类用于'实作继承'：继承接口的同时也继承了父类的实现。纯虚函数‘介面继承’：关注的是接口的统一性。
4.带纯虚函数的类叫虚基类，不能直接生成对象(实例化)，只有被继承并重写起虚函数后才能使用。
抽象基类/虚基类：含有纯虚函数的基类，
1.方便使用多态性 2.纯虚函数相当于接口，能把派生类的共同特征提取出来。
1.class和struct的区别
class继承是private，可表示模板类型。struct是Public。
2.静态成员对每个类的类型只有一个复制品，有所有对象共享访问，当作该类型的全局变量。非静态成员每个类对象都有自己的复制品。静态成员函数不属于类的对象，没有this指针。
3.静态数据成员与全局变量相比的优势：1.没有进入程序的全局名字空间，不存在命名冲突。2.可设private隐藏信息。3.必须在类外面初始化。
4.空类默认会产生：默认构造函数、复制构造函数、析构函数、赋值函数、取值运算
5.构造函数可以被重载，可以有好几个，可带参。析构函数只有一个不能被重载，且不能带参。
6.只有基类才会把析构函数写成虚函数，避免内存泄漏。
7.复制构造函数被调用的情况：1.对象以值传递的方式传入函数体。2.以值传递的方式从函数返回。3.需要通过另外一个对象进行初始化。
深复制：为新对象制作了外部对象的独立复制 浅复制：新旧对象指向同一个外部内容。
8.函数重载是用来描述同名函数具有相同或相似功能，但数据类型或参数不同的函数。
9.重载和覆写的区别：
重载：子类改写了父类的方法，一种语法规则，在编译阶段完成，不属于面向对象编程 特征：1.方法名必须相同 2.参数列表必须不同 3.返回值可以不同
覆写：派生类重写基类的虚函数，运行阶段决定，是面向对象编程的重要特征
特征：1.只有虚方法和抽象方法才能被覆写 2.相同函数名 参数列表 返回值
1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4094709a079ac56f21f341acd8407fad/" rel="bookmark">
			遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket粘包处理
socket超时处理
完全二叉树
最优路径
堆和栈的区别
static
const
类 多态 继承 虚函数
析构的几种方式
指针与引用
class struct区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e636c0d5ebd5e665b3ccd3d7c46e8ad/" rel="bookmark">
			可编辑的div黏贴图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黏贴图片主要分为2个情况，第一个是直接截图或者打开图片后点击复制，第二个是直接使用ctrl+c复制电脑本地图片，今天主要是写一下ctrl+c复制电脑本地图片的方法
通过使用ctrl+c复制电脑本地图片 在粘贴板里面是保存的file文件类型 所以直接ctrl+v 是无法复制出来，这就需要我们将file类型的img 转化成blob类型，具体方法如下。将此函数绑定到 onPaste 黏贴事件
const getItem = async (event) =&gt; { let items = event.clipboardData &amp;&amp; event.clipboardData.items; let file = null; const selection = window.getSelection(); let paste = (event.clipboardData || window.clipboardData).getData('text'); selection.deleteFromDocument(); if (items &amp;&amp; items.length) { let filterItem = items; // 检索剪切板items for (let i = 0; i &lt; filterItem.length; i++) { if (filterItem[i].type.indexOf('image') !== -1) { file = filterItem[i].getAsFile(); let blob = new Blob([file], { type: 'image/png' || 'application/*' }); document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e636c0d5ebd5e665b3ccd3d7c46e8ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5911f54b6b73a3d3f034bdec9e312908/" rel="bookmark">
			翼边几何存储结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Winged-Edge Data Structure Perhaps the oldest data structure for a B-rep is Baumgart's winged-edge data structure. It is quite different from that of a wireframe model, because the winged-edge data structure uses edges to keep track almost everything. In what follows, we shall assume there is no holes in each face and later extend it to cope with holes. Moreover, we shall assume edges and faces are line segments and polygons.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5911f54b6b73a3d3f034bdec9e312908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5733f138a088470ad4652c47465bff58/" rel="bookmark">
			Duplicate keys detected: ‘***‘. This may cause an update error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在开发vue项目时遇到 Duplicate keys detected: '13'. This may cause an update error错误，这个错不会影响页面显示，但是会一直在控制台上打印。如图 错误原因：v-for循环时设置的key值不是唯一的。如图 解决方案
设置v-for循环的key是唯一的。如图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e2399ea68e07358f55f784023593c6/" rel="bookmark">
			Python 使用requests发送post&#43;form-data数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python 使用requests发送post+form-data数据 import requests url = "http://10.51.4.1:20200/api/v1/fs/file" # form-data参数要写成如下格式，注意有None data = { "file_name": "测试视频.mp4" } files = { "file": open("/Users/yyl/Desktop/测试视频.mp4", "rb") } response = requests.request("POST", url, data=data, files=files) print(response.json()) 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06c3d2c9192031181703eecaa2b4d23/" rel="bookmark">
			C# TextBox LostFocus找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vs里面选择TextBox在事件栏里面是找不到LostFocus事件的，但是在代码里面可以找到 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace Test210825 { public partial class Form1 : Form { public Form1() { InitializeComponent(); textBox1.LostFocus += TextBox1_LostFocus; } int i = 0; private void TextBox1_LostFocus(object sender, EventArgs e) { i++; textBox2.Text = i.ToString(); } private void textBox1_KeyUp(object sender, KeyEventArgs e) { if (e.KeyCode == Keys.Enter) { TextBox1_LostFocus(sender, e); } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7945000c6105b212fad85c6d35b159fb/" rel="bookmark">
			win10 安装MySQL 无管理员权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、找到下载的安装文件，按住Shift键，同时在安装文件上点击鼠标右键，选择复制为路径
2、打开C:\Windows\System32，找打cmd.exe，点击右键选择以管理员方式运行。
3、在打开的界面点击鼠标右键将路径粘贴
4、回车运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fcd67478171b91a08591cc1e5f7791c/" rel="bookmark">
			Candence学习篇(5)使用Padstack Editor制作贴片焊盘和通孔焊盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、尺寸的确定1.1封装尺寸与封装的对应关系1.2立创商城 二、使用padstack Edit制作焊盘2.1表贴焊盘2.2表贴圆弧跑道焊盘 三、使用Padstack Editor制作通孔焊盘总结 前言 前面我们讲了
Candence学习篇(1) Candence原理图工程以及原理图库的创建
Candence学习篇(2) 电阻等器件原理图symbol绘制
Candence学习篇(3)Stm32元器件绘制和原理图绘制
Candence学习篇(4)allegro软件中class 和subclass的概念
今天我们来学习allegro软件中使用padstack Editor制作贴片焊盘和通孔焊盘 Padstack Editor也是candence系列的产品，长这样
当然我们的EDA设计三件套肯定是这三个
一、尺寸的确定 焊盘我们都知道是啥，有不同形状的，不同尺寸的，那么我们一般怎么确定尺寸呢
通常以下途径获得通孔或者焊盘的尺寸
1.芯片的数据手册
2.LP wizard(一个软件)
3.立创商城搜索(主要是免费)下载PDF或者尺寸测量
4.0402电阻表贴焊盘的尺寸为20mil*20mil
1.1封装尺寸与封装的对应关系 1.2立创商城 比如说我们搜索stm32f411ceu6,我们就可以知道具体的尺寸了
我们可以选择立即使用，然后使用尺寸测量
二、使用padstack Edit制作焊盘 2.1表贴焊盘 因为我们的表贴焊盘SMD一般是方的，所以我们选rectangle，我们要做一个 20mil*20mil的
然后我们切换到下一个选项卡，design layer ，然后把我们的尺寸标注好
然后我们再跳到mask layer，然后我们可以看到我们的预览
一个是俯视图，一个是侧视图，然后第一个是阻焊层，第三个是助焊层，因为是表贴器件，所以只有一层。那就是top层
助焊层我们和焊盘的尺寸一样大，阻焊层我们要比助焊层大那么一丢丢
到这里我们的贴片焊盘就设置完成了，然后我们点击保存，注意，命名要规范~
前面是类型，后面是尺寸
2.2表贴圆弧跑道焊盘 这个名字是我自己起的，非常的生动形象
现在我们以此类推，对于表贴焊盘，我们可以制作STM32引脚的这个焊盘
首先我们看芯片手册，得出长为1.1mm=43.3mil,我们要留有余量所以我们选择48mil
宽是0.3mm=11.8mil,那么我们可以选择12mil
在pad 中我们选择圆弧的
同理和上面的步骤一致
阻焊层我们要选择大一点
助焊层不变，然后点击保存，注意命名规范
三、使用Padstack Editor制作通孔焊盘 接下来我们制作这个2.54mm间距的这个排针（插针）的焊盘
起个名字叫thr就是通孔的意思thr1r6_0r9,意思是焊盘直径1.6mm,通孔直径0.9mm,同时我们要注意单位，这次我们使用的是mm
选择通孔直径
然后我们还可以添加字符进行显示
设置坐标，默认的就是在中心，我们不用动
我们这个焊盘是有顶层和底层的，所以必须要设置，中间这个是内建层，默认的，很有必要
第一列代表焊盘大小
第二列代表热封焊盘，我们一般设置得稍微比焊盘大一点
第三列是隔离焊盘，我们一般也是设置得稍微比焊盘大一点
我们把这三个都设置好，然后在左边看到我们的预览界面了
然后再分别设置阻焊层和助焊层就可以了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fcd67478171b91a08591cc1e5f7791c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4524d13a79598538d589629d16783e4/" rel="bookmark">
			京训钉自动播放下一章(2021版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var buttons = document.getElementsByClassName("next_button___YGZWZ"); setInterval(function() { var button = buttons[0]; if(typeof(button) != 'undefined'){ console.log("next chapter!!!") button.click(); } },5000); var outters = document.getElementsByClassName("outter"); setInterval(function() { var playing = document.getElementsByClassName("prism-big-play-btn"); var attr = playing[0].getAttribute('class'); if(attr.indexOf('playing') &lt; 0){ var outter = outters[0]; if(typeof(outter) != 'undefined'){ console.log("video start!!!") outter.click(); } } },5000); setInterval(function() { var ant = document.getElementsByClassName("ant-btn-primary"); if(ant.length != 0){ ant[0].click(); } },5000); 使用方法：打开谷歌浏览器 --&gt; 按F12 --&gt; 找到console控制台 —&gt; 复制粘贴 --&gt; 回车
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3541d6a07aafed063a344e5d37e05686/" rel="bookmark">
			卷积和反卷积输出的计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://zhuanlan.zhihu.com/p/39240159
推荐：一个可视化卷积和反卷积的项目：https://github.com/vdumoulin/conv_arithmetic
1 反卷积计算 pytorch中反卷积的函数为：
class torch.nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=1, padding=0,output_padding=0,groups=1,bias=True, dilation=1) # 一般为以下 nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride, padding) 参数的含义如下：
in_channels(int) – 输入信号的通道数out_channels(int) – 卷积产生的通道数kernel_size(int or tuple) - 卷积核的大小stride(int or tuple,optional) - 卷积步长，即要将输入扩大的倍数。padding(int or tuple, optional) - 输入的每一条边补充0的层数，高宽都增加2*paddingoutput_padding(int or tuple, optional) - 输出边补充0的层数，高宽都增加paddinggroups(int, optional) – 从输入通道到输出通道的阻塞连接数bias(bool, optional) - 如果bias=True，添加偏置dilation(int or tuple, optional) – 卷积核元素之间的间距 而对于输入输出的计算，首先参数out_channels指定输出的通道数，即一定是output_size*output_size*out_channels，故主要计算输出的output_size，公式如下：
一般来说用以下公式：
例子：
# Generator Code # 生成器 反卷积 class Generator(nn.Module): def __init__(self, ngpu): super(Generator, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3541d6a07aafed063a344e5d37e05686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124701e4a1259979d9e8a81e912748a2/" rel="bookmark">
			如何完成一个三维引导项目:第一步 手眼标定（眼在手外）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何完成一个三维引导项目:第一步 手眼标定（眼在手外） 主要使用算子:
*从点对应近似一个三维变换 vector_to_hom_mat3d *对点应用任意仿射3D变换 affine_trans_point_3d 目录 如何完成一个三维引导项目:第一步 手眼标定（眼在手外）前言前期准备整体代码总结 前言 今天分享的是空间N点标定法：
该方法无论是理论还是实践都是简单暴力的。
基础知识：对于两个三维坐标系A和B，空间中有N个点，已知这些点在坐标系A下的三维坐标，并知这些点在坐标系B下的三维坐标。则可以建立N组P_A=T_C^A 〖*P〗_C方程。那么，就可以直接求取T_C^A了。
在实际操作中，一种方式是使用标记物标记机械臂末端点，则空间坐标点在机械臂基座坐标系下的位置已知（读取机械臂末端坐标），在相机三维坐标系下的位置可以通过在图像中定位该标记物，并基于图像坐标映射，获取该点在相机三维坐标系下的三维位置。这些点必须保证是非共面的，且这些点应尽可能散布在工作区域下。
前期准备 halcon任一版本（我使用19.11）、相机坐标系与机器人坐标系下对应点坐标值。
整体代码 所有的代码：
*相机坐标系与机器人坐标系下对应点坐标值 inputImageX:=[1,2,3] inputImageY:=[1,2,3] inputImageZ:=[1,1,1] inputRobotX:=[3,4,5] inputRobotY:=[3,4,5] inputRobotZ:=[1,1,1] inputTransformationType:='rigid' *List of values: 'affine', 'projective', 'rigid', 'similarity' *'rigid':刚性的3D变换(一个旋转和一个平移) 3组数据 *'affine':通用的仿射3D变换 4组数据 *'projective':投影3D变换 5组数据 *'similarity':3D相似变换(统一缩放、旋转和平移) 3组数据 *从点对应近似一个三维变换，获得变换矩阵 vector_to_hom_mat3d (inputTransformationType, inputImageX, inputImageY, inputImageZ, inputRobotX, inputRobotY, inputRobotZ, outputHomMat3D) *通过变换矩阵 准备计算重投影误差数据 affine_trans_point_3d (outputHomMat3D, inputImageX, inputImageY, inputImageZ, robotPointsX, robotPointsY,robotPointsZ) *计算重投影误差 err2 := [] for Index := 0 to |robotPointsX|-1 by 1 *空间中点欧氏距离 err2 := [err2, sqrt(pow(robotPointsX[Index]-inputRobotX[Index], 2) + pow(robotPointsY[Index]-robotPointsY[Index],2)) +pow(robotPointsZ[Index]-robotPointsZ[Index],2)] endfor outputErrMean := mean(err2) outputErrMax := max(err2) *保存 write_tuple (outputHomMat3D, 'outputHomMat3D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124701e4a1259979d9e8a81e912748a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90fa8f9e2d720e32a876033edf853ad/" rel="bookmark">
			RS485串口转MQTT协议快速接入华为云阿里云的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能仪表变送器快速接入华为云阿里云的解决方案 阿里云与华为云是被大部分用户推荐以及认可的云平台服务商，很多私有云平台都是基于它们的基础去搭建自己的应用，从而实现私有云的物联网解决方案。
在整个物联网云平台解决方案中，各种智能仪表、变送器的数据采集到云平台是第一步，选好合适的网关则可以快速顺利的把前端的智能仪表、电表、以及变送器等设备的数据快速采集到云平台。把前端数据采集的工作交给BL100 Modbus转MQTT网关。
MQTT网关BL100会自动根据Modbus协议与MQTT协议进行内部计算，把不需要的数据丢弃，把有效的数据上传。如下图：
前端的变送器、仪表等都在BL100内部计算转换好了。因此，对于云平台开发工程师而言，采用Modbus网关转MQTT网关BL100，不需要关注智能仪表与变送器的Modbus协议，只需要按照阿里云、华为云的MQTT协议格式开发云平台及应用即可，如下图：
因为BL100支持一键接入华为云与阿里云，在BL100的配置软件中，直接选择接入华为云或者阿里云即可，BL100会自动按照对应的MQTT协议进行数据处理，从而可以快速实现智能仪表变送器接入华为云阿里云的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dff9041f52321fedf0a601726286189/" rel="bookmark">
			IIS错误:不能在此路径中使用此配置节。如果在父级别上锁定了该节，便会出现这种情况。锁定是默认设置的(overrideModeDefault=“Deny“)......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上图 IIS 访问的时候出现以下异常：
不能在此路径中使用此配置节。如果在父级别上锁定了该节，便会出现这种情况。锁定是默认设置的(overrideModeDefault="Deny")......
解决方案：
因为 IIS 采用了更安全的 web.config 管理机制，默认情况下会锁住配置项不允许更改。
运行命令行 C:\windows\system32\inetsrv\appcmd unlock config -section:system.webServer/handlers
其中的 handlers 是错误信息中红字显示的节点名称。
如果modules也被锁定，可以运行
C:\windows\system32\inetsrv\appcmd unlock config -section:system.webServer/modules
注意：cmd.exe要以管理员身份启动，在c:\windows\system32下找到cmd.exe，右键管理员启动，输入上面的命令即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d8a659e96abc7ff861cfd2513d72cb/" rel="bookmark">
			Redis 请求的一次网络旅程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 请求的一次网络旅程 Redis 不必多说，可以说是目前互联网使用最广泛的内存数据库，源于其丰富的数据结构、支持数据持久化、集群、高性能的这些特性。
本文从 Redis 单线程模式，对于 Redis 客户端从登录到发送消息和收到消息的连续的行为，以 Redis 源码的角度做出解释，详细分析一个 Redis 连接的完整旅程，也作为我在 Redis 学习过程中的一个深入思考的过程。
要解释 Redis 连接的完整过程，事实上主要是对 Redis 网络模型进行分析，因此会分为这几个部分（服务端角度）：注册事件、建立连接、接收请求、解析请求、 执行请求、响应请求等。
注册事件 Redis Server 首先会在 initServer() 函数中注册自身的 listenfd。
在 IO 多路复用模型中，如果要监听事件，需要将服务端的 listenfd 注册到 IO 多路复用模型中，这个行为在启动 aeMain 之前通过 createSocketAcceptHandler 已经注册到事件循环器中，这里忽略监听套接字 listenfd 的生成过程，直接进入注册监听事件的流程。
createSocketAcceptHandler 为服务端注册 listenfd 和 accept 事件，也就是接收客户端连接的处理事件，代码如下：
int createSocketAcceptHandler(socketFds *sfd, aeFileProc *accept_handler) { int j; for (j = 0; j &lt; sfd-&gt;count; j++) { // 注册可读事件 if (aeCreateFileEvent(server.el, sfd-&gt;fd[j], AE_READABLE, accept_handler,NULL) == AE_ERR) { /* Rollback */ for (j = j-1; j &gt;= 0; j--) aeDeleteFileEvent(server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00d8a659e96abc7ff861cfd2513d72cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7463f4be6c158b63a8bf0bcc07b2a2e0/" rel="bookmark">
			微信小程序云开发笔记：2.代码结构初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、云开发开通与控制台 二、云开发环境设置 三、基本结构： cloudfunctions：云开发中云函数的部分miniprograms: 前端部分pages页面 如:index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页。
微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。
app.js是小程序的脚本代码。 我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。
ps：js文件存储着交互用的数据
.app.json 是对整个小程序的全局配置。 我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。
app.wxss 是整个小程序的公共样式表。 我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。
README.md：一些说明project.config.json 是当前项目的配置说明 四、初始配置 五、代码规范 以上内容是基于慕课谢成老师的微信小程序云开发－从0打造云音乐全栈小程序，欢迎支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f33528517420e56b6481d59ec739ffb/" rel="bookmark">
			a-popover的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a-popover的使用
&lt;template&gt; &lt;div id="popoverUsing"&gt; &lt;a-popover autoAdjustOverflow overlayClassName="myPopClass" v-model="visible" trigger="click" placement="bottomLeft" @visibleChange="afterCloseDo" &gt; &lt;!-- 触发popover的元素 --&gt; &lt;div class="openPop"&gt;&lt;/div&gt; &lt;!-- 弹框内容区域 --&gt; &lt;template slot="content"&gt; &lt;section&gt; &lt;p&gt;Content&lt;/p&gt; &lt;p&gt;Content&lt;/p&gt; &lt;/section&gt; &lt;div&gt; &lt;a-button type="primary" style="margin-right:10px" @click="sure" &gt;确然&lt;/a-button &gt; &lt;a-button type="primary" @click="cancel"&gt;取消&lt;/a-button&gt; &lt;/div&gt; &lt;/template&gt; &lt;/a-popover&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { visible: false } }, methods: { sure() { console.log('确认') this.visible = false }, cancel() { console.log('取消') this.visible = false }, afterCloseDo() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f33528517420e56b6481d59ec739ffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23502160440c41bd1619c91dd4213b8/" rel="bookmark">
			os.popen()函数用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 os.popen()函数与cmd命令窗口之间建立一个双向通道，可以从cmd窗口和程序间相互读取信息
同一文件夹中hello.py文件入下:
pritn("hello world") 如果在cmd中执行命令
python hello.py cmd命令窗口中会输出
hello world main.py文件如下：
import os f = os.popen(r"hello.py", "r") result = f.read() print(result) 则输出hello world，此时程序通过os.poenp函数将命令行中的输出读入到变量result中。
当执行可执行文件时候命令形式如下：
p=os.popen(r"metro.exe hammer.obj hammer-qem.obj", "r").read() p保存的为cmd命令行的输出。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856dc6c192c677654e2d5ff56bf02d9d/" rel="bookmark">
			OpenStack(一)简介＋T版部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云计算服务模型 IaaS（基础架构即服务）
提供底层 IT 基础设施服务，包括处理能力、存储空间、网络资源等
面向对象一般是 IT 管理人员
PaaS（平台即服务）
把安装好开发环境的系统平台作为一种服务通过互联网提供给用户
面向对象一般是开发人员
SaaS（软件即服务）
直接通过互联网为用户提供软件和应用程序等服务
面向对象一般是普通用户
OpenStack 简介 1、NASA （美国国家航空航天局）和 Rackspace（是一家全球领先的托管服务器及云计算提供商）共同发起
2、以 Apache 许可证（Apache 软件基金会发布的一个自由软件许可证）授权的自由软件和开放源代码项目，不只是一个软件，这个项目由几个主要的组件组合起来完成一些具体的工作
3、为公有云及私有云的建设与管理提供可扩展的弹性的云计算服务（开源项目）
4、覆盖了网络、虚拟化、操作系统、服务器等各个方面
Openstack得服务 简单理解总结
计算 nova 管理实例生命周期
镜像 glance 管理镜像快照服务
认证 keystone 全局认证、授权
块存储 cinder 为实例提供持久化功能
对象存储 swift 对象存储，存储镜像加快照
度量、监控 ceilometer 计费、监控
网络 neutron 为实例提供网络支持(拓扑结构)
控制台 horizon 用户登陆、使用的控制台界面
OpenStack 的优势 1、控制性
完全开源的平台，开源的平台意味着不会被某个特定的厂商绑定和限制
提供 API 接口，模块化的设计能把遗留的和第三方的技术进行集成，从而来满足自身业务需要
2、兼容性
OpenStack 兼容其他公有云，方便用户（企业）很容易的将数据和应用迁移
3、可扩展性
模块化设计，可以通过横向扩展来增加节点、添加资源
4、灵活性
用户可以根据自己的需要建立基础设施，也可以轻松地为自己的集群增加规模
5、行业标准
众多行业领军企业已经加入到OpenStack项目
OpenStack设计基本原则 Openstack的部署和运维之前，应当熟悉其架构和运行机制，OpenStack作为开源、可扩展、富有弹性(资源弹性，抗压能力的弹性）的云操作系统，其设计基本原则如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856dc6c192c677654e2d5ff56bf02d9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31140ff24709cd966b121f0385d8e9f/" rel="bookmark">
			k8s中Pod重启方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
一、有yaml文件的重启方式
二、没有yaml文件的重启方式
使用scale命令
直接删除Pod进行重启
使用“-o yaml”参数导出Pod模板并重建Pod【推荐】
总结
在使用 docker 的过程中，我们可以使用docker restart {container_id}来重启容器，但是在 kubernetes 中并没有重启命令（没有 kubectl restart {podname}），有时候我们的 Pod 出现 Bug意外终止，导致我们需要重启 Pod ，却没有一个很好的方式，特别是没有 yaml 文件的情况下，所以我总结了以下几种重启 Pod 的方式。
一、有yaml文件的重启方式
在有 yaml 文件的情况下可以直接使用 kubectl replace --force -f xxx.yaml 来强制替换Pod 的 API 对象，从而达到重启的目的。如下图：
二、没有yaml文件的重启方式
使用scale命令
没有 yaml 文件，但是使用的是 Deployment 对象。可以使用以下方式重启
kubectl scale deployment esb-admin --replicas=0 -n {namespace}
kubectl scale deployment esb-admin --replicas=1 -n {namespace}
1
2
由于 Deployment 对象并不是直接操控的 Pod 对象，而是操控的 ReplicaSet 对象，而 ReplicaSet 对象就是由副本的数目的定义和Pod 模板组成的。所以这条命令分别是将ReplicaSet 的数量 scale 到 0，然后又 scale 到 1，那么 Pod 也就重启了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c31140ff24709cd966b121f0385d8e9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7b27aa7d875785db37dae022abcf5f/" rel="bookmark">
			pod探针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、资源限制1、Pod 和 容器 的资源请求和限制2、CPU 资源单位3、内存 资源单位 二、重启策略三、健康检查：又称为探针（Probe） 一、资源限制 当定义 Pod 时可以选择性地为每个容器设定所需要的资源数量。 最常见的可设定资源是 CPU 和内存大小，以及其他类型的资源。当为 Pod 中的容器指定了 request 资源时，调度器就使用该信息来决定将 Pod 调度到哪个节点上。当还为容器指定了 limit 资源时，kubelet 就会确保运行的容器不会使用超出所设的 limit 资源量。kubelet 还会为容器预留所设的 request 资源量， 供该容器使用。如果 Pod 运行所在的节点具有足够的可用资源，容器可以使用超出所设置的 request 资源量。不过，容器不可以使用超出所设置的 limit 资源量。如果给容器设置了内存的 limit 值，但未设置内存的 request 值，Kubernetes 会自动为其设置与内存 limit 相匹配的 request 值。类似的，如果给容器设置了 CPU 的 limit 值但未设置 CPU 的 request 值，则 Kubernetes 自动为其设置 CPU 的 request 值 并使之与 CPU 的 limit 值匹配。 详解大家可以看官网
https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ 1、Pod 和 容器 的资源请求和限制 模块含义spec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e7b27aa7d875785db37dae022abcf5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0acb293e6542a904219e0fe6a646593f/" rel="bookmark">
			java多线程按照时间段切割视频流片段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.chinaunicom.zwboy.controller; import cn.hutool.core.io.FileUtil; import cn.hutool.json.JSONUtil; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.chinaunicom.common.base.convert.BaseConvert; import com.chinaunicom.common.base.feign.RemoteUserGbCodeService; import com.chinaunicom.common.base.feign.model.DeviceCommandPtzReqBaseDto; import com.chinaunicom.common.core.constant.SecurityConstants; import com.chinaunicom.video.entity.Lives; import com.chinaunicom.video.entity.SvAircraftVideoRecord; import com.chinaunicom.video.service.LivesService; import com.chinaunicom.video.util.RedisUtil; import com.chinaunicom.video.util.WoYunOssUtils; import com.chinaunicom.zwboy.model.PushData; import com.chinaunicom.zwboy.model.PushTask; import com.chinaunicom.zwboy.service.*; import com.chinaunicom.zwboy.service.impl.SaveRecordThreadManagerImpl; import com.chinaunicom.zwboy.util.FileOperUtils; import com.lh.service.SaveRecord; import com.lh.service.SliceType; import com.lh.service.impl.SaveRecordImpl; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0acb293e6542a904219e0fe6a646593f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d35cf418d44d2a37062c484e0371e6/" rel="bookmark">
			[前端css-3] 实现图片卷帘效果，以及动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[前端css-3] 实现图片卷帘效果，以及动画 1.效果展示： 效果预览
2.知识点： 1.position（相对定位/绝对定位） 2.伪类（:after/:before） 3.animation（动画） 3.源代码: &lt;!-- * @Description: 文件描述： * @Autor: hwf * @Date: 2021-08-13 15:25:04 * @LastEditors: Seven * @LastEditTime: 2021-08-13 15:36:54 --&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;层叠图片拖动卷帘式动画特效原图细节对比原生js插件&lt;/title&gt; &lt;meta name="keywords" content="层叠图片,拖动,卷帘式,动画特效,原图细节对比,原生js插件"&gt; &lt;meta name="description" content="层叠图片拖动卷帘式动画特效原图细节对比原生js插件代码下载。一款很实用的jQuery图片插件，它可以帮助你实现原图和经过处理的图片进行对比，拖动中间的分割线来进行两张图片的细节对比。"&gt; &lt;style&gt; #page { width: 100%; height: 100%; position: absolute; } * { margin: 0; box-sizing: border-box; } .wrapper { width: 900px; height: 600px; position: absolute; left: 50%; top: 50%; transform: translate3d(-50%, -50%, 0); overflow: hidden; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62d35cf418d44d2a37062c484e0371e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218827c05b2458bc24c4ffa9b5b0e3f2/" rel="bookmark">
			Win10系统自带的SSH2服务怎么启动?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：https://www.jb51.net/os/win10/737306.html
1、进入到Windows10系统，选择"开始菜单"-&gt;"设置"选项。
2、打开"Windows设置"对话框，选择"应用"菜单选项。
3、会弹出"应用和功能"对话框，再选择"可选功能"菜单项。
4、再选择"添加功能"按钮菜单。
5、在"添加可选功能"操作窗口，勾选中"OpenSSH服务器"前面的复选框，再点击"安装"按钮。
6、稍等片刻，等待"OpenSSH"服务器组件的安装完成。
7、再打开Windows10系统的"系统服务"，将"OpenSSH Authentication agent"和"OpenSSH SSH Server"服务设置为"启动"状态。
8、在cmd窗口，执行"netstat -an|findstr ":22""指令，可查看默认的SSH2服务的TCP 22端口正在运行。
完！SSH已经启动了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5288cf6f86582ca5d253dd6889335811/" rel="bookmark">
			高通QCAP解析dump：GCC_RESET_STATUS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GCC_RESET_STATUS寄存器用于在触发看门狗后保存复位状态：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/169/">«</a>
	<span class="pagination__item pagination__item--current">170/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/171/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>