<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4dc24822a7e57ce41db986e1edfe329/" rel="bookmark">
			oracle dat文件导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在执行dat文件导入的时候，由于很久没执行过这种操作了，因此又变得生疏了，花了比较长的时间才弄好。然后看到网上关于oracle dat文件的导入介绍的都是一部分，所以特在这里总结一下。 一、dmp文件和dat文件的区别 1、dmp文件包含的信息有数据库的版本信息、数据文件的字符集、数据文件导出路径信息、数据库用户信息、数据库导出的表的信息、索引信息、表空间信息等数据库的详细信息。dat文件只是导入的表的数据信息。 2、oracle可以一次性导入多张表到dmp文件中，但是只能导一张表到dat文件中。 3、dmp文件可以包括表空间、索引、用户、表、序列、存储过程、视图等数据库的所有信息，并可以用这些信息还原整个数据库，但是dat文件只是用来存放表的数据信息，只能还原表的数据信息。 4、对于单张表的数据导入（即不需要创建表、创建表索引等信息）时，dat文件的导入要比dmp文件导入快很多，由其是对于数据量非常大的表。 5、dmp文件主要用于数据库备份、数据迁移等需要多张表操作或需要创建表信息的操作。dat文件主要用于纯数据的迁移和备份。 二、dat文件转换为控制文件（.ctl文件） 1、control文件 ------------------------------------------------------------------------ --SQL --程序功能： 在命令行用sqlplue自动生成sql*load控制文件 --输入参数： --&amp;1 表名 --&amp;2 数据文件名 --&amp;3 目录名 --返回值结果：生成文件为：目录名＋表名＋.ctl --调用: sqlplus PAS/pas123 @d:\control.sql jksj_ll 20091231_005_LL.dat d:\ --created by hqx 2010-03-26 --修改记录： ------------------------------------------------------------------------ set echo off set heading off set verify off set feedback off set show off set trim off set pages 0 set concat on set lines 300 set trimspool on set trimout on spool &amp;3&amp;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4dc24822a7e57ce41db986e1edfe329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d3a45ca6c52689ea011e2ae5d1f88a7/" rel="bookmark">
			QT  用户界面美工
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在涉及到Qt 部件美工变成的时候首先要掌握CSS 级联样式表
级联样式表 (CSS) 包含应用于网页中的元素的样式规则。CSS 样式定义元素的显示方式以及元素在页中的放置位置。可以创建一个通用规则，只要 Web 浏览器遇到一个元素实例，或遇到一个分配给某个特定样式类的元素，该规则就立刻应用属性，而不是将属性逐个分配给页中的每个元素。
CSS 样式可以通过内联方式放置在单个 HTML 元素内，也可以在网页 head 部分的 style 块内加以分组，或从单独的样式表中导入。如果样式是在单独的样式表中创建的，则可以将多个网页链接到该样式表，从而为整个网站提供一个通用的外观。如果使用 CSS 设置 Web 控件的样式，则应使用 CssClass 属性来定义要与控件或控件元素关联的 CSS 类名，然后在样式表中为这些控件或控件元素指定样式时引用该类名。
下面将通过几个例子来介绍一下怎样使用Qt中的部件类型设计。自定义的前台背景与后台背景的颜色：
如果需要样一个文本编辑器的背景变为黄色， 下面是代码行：
qApp-&gt;setStyleSheet("QLineEdit { background-color: yellow }"); 针对一个对话框的内容中使用QLineEdit以及QLineEdit的子类的背景都变成黄色， 下面是代码：
myDialog-&gt;setStyleSheet("QLineEdit { background-color: yellow }"); 如果只需要制定一个QLineEdit的内容， 将使用QObject::setObjectName() 下面是一个实例：
myDialog-&gt;setStyleSheet("QLineEdit#nameEdit { background-color: yellow }"); 同时也可以针对每一个指定的部件做直接的类型设置， 下面是一个实例：
nameEdit-&gt;setStyleSheet("background-color: yellow"); 为了做一个鲜明的对比， 将要为文本设置合适的颜色。
nameEdit-&gt;setStyleSheet("color: blue; background-color: yellow"); 当然最好的办法还有针对选择的文本来进行设置， 下面设置了一个选择文本的类型属性：
nameEdit-&gt;setStyleSheet("color: blue;" "background-color: yellow;" "selection-color: yellow;" "selection-background-color: blue;"); 在有一些情况下， 不需要用户参与， 而有软件设计人员来自己制定样式， 即使这些是有违审美角度。 下面就从应用程序开发角度来设计样式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d3a45ca6c52689ea011e2ae5d1f88a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1400e970487f8ad27735f4c90228bed8/" rel="bookmark">
			IIS_7.0_为宿主的网站时出现错误消息：“HTTP_Error_500.19_-_内部服务器错误”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您具有以 Internet 信息服务(IIS) 7.0 为宿主的网站.当您访问 Web 浏览器中的网站时，可能会收到类似以下内容之一的错误消息：
错误消息 1
应用程序“应用程序名称”中的服务器错误
HTTP Error 500.19 - 内部服务器错误 HRESULT:0x8007000d
对 HRESULT 的说明
由于此页相关的配置数据无效，则无法访问所请求的页。
错误消息 2
应用程序“应用程序名称”中的服务器错误
HTTP Error 500.19 - 内部服务器错误 HRESULT:0x80070005
对 HRESULT 的说明
由于此页相关的配置数据无效，则无法访问所请求的页。
错误消息 3
应用程序“应用程序名称”中的服务器错误
HTTP Error 500.19 - 内部服务器错误 HRESULT:0x800700b7
对 HResult 的说明
由于此页相关的配置数据无效，则无法访问所请求的页。
错误消息 4
应用程序“应用程序名称”中的服务器错误 HTTP Error 500.19 - 内部服务器错误 HRESULT:0x8007007e 对 HResult 的说明 由于此页相关的配置数据无效，则无法访问所请求的页。
错误消息 5
应用程序“应用程序名称”中的服务器错误
HTTP Error 500.19 - 内部服务器错误 HRESULT:0x800700c1
对 HRESULT 的说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1400e970487f8ad27735f4c90228bed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2c541a084cc14dcdcb1e14799df02d/" rel="bookmark">
			win8 64位&#43;Oracle 11g 64位下使用PL/SQL Developer 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1）安装Oracle 11g 64位 2）安装32位的Oracle客户端（ instantclient-basic-win32-11.2.0.1.0） 下载 instantclient-basic-win32-11.2.0.1.0.zip (一定得是32位的，不要下错了版本，Oracle官网有下载），将其解压至Oracle安装目录的Product下（本机命名为：instantclient_11_2）：D:\Oracle\app\YM\product\instantclient_11_2。 拷贝数据库安装根目录下的一个目录D:\Oracle\app\YM\product\11.2.0\dbhome_1\NETWORK到Oracle客户端目录下D:\Oracle\app\YM\product\instantclient_11_2（其实只需要 NETWORK\ADMIN\tnsnames.ora，最好是直接拷贝这个文件到D:\Oracle\app\YM\product\instantclient_11_2目录下） 3）安装PL/SQL Developer 安装 PL/SQL Developer，在perference-&gt;Connection里面设置OCI Library和Oracle_Home，例如本机设置为： Oracle Home ：D:\Oracle\app\YM\product\instantclient_11_2 OCI Library ： D:\Oracle\app\YM\product\instantclient_11_2\oci.dll 4) 设置环境变量(修改PATH和TNS_ADMIN环境变量) 对于NLS_LANG环境变量, 最好设置成和数据库端一致, 首先从数据库端查询字符集信息: SQL&gt; select userenv('language') nls_lang from dual; NLS_LANG ---------------------------------------------------- SIMPLIFIED CHINESE_CHINA.ZHS16GBK 右击"我的电脑" - "属性" - "高级" - "环境变量" - "系统环境变量": 1&gt;.选择"Path" - 点击"编辑", 把 "D:\Oracle\app\YM\product\instantclient_11_2;" 加入; 2&gt;.点击"新建", 变量名设置为"TNS_ADMIN", 变量值设置为"D:\Oracle\app\YM\product\instantclient_11_2;", 点击"确定"; 3&gt;.点击"新建", 变量名设置为"NLS_LANG", 变量值设置为"SIMPLIFIED CHINESE_CHINA.ZHS16GBK", 点击"确定"; 最后点击"确定"退出. 启动 PL/SQL Developer ，运行无问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e318a981e076c93caa182815e58c12/" rel="bookmark">
			ORACLE数据库文件系统简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、数据库文件类型 与实例相关联的文件： 1 、参数文件：这些文件告诉Oracle实例在哪里寻找控制文件。例如，某个内存结构有多大等等。 组成数据库的文件： 2、数据文件：用于数据库（这些文件存储包含表、索引以及其他的部分的信息及数据）。 3、重做日志文件：记录事务日志 4、控制文件：它告诉我们这些数据文件存放在什么地方，以及其他关于其状态的信息。 5、临时文件：用于磁盘上的分类和临时的存储。 6、密码文件：用于在网络上执行管理活动的用户进行身份验证。 二、参数文件 1、数据库的参数文件通常称为init文件，或init.ora文件。这是因为它的默认名是init&lt;ORACLE_SID&gt;.ora。如果没有参数文件，你就不能启动数据库。这使它成为相当重要的文件。然而，由于它是一个纯文本文件，可以由任何一个文本编辑器创建，所以它不是必须特别注意的文件。参数文件的作用至少是获取数据库的名字，以及控制文件的位置。控制文件告诉Oracle其他每个文件的位置。所以它对启动数据库实例是非常重要的。 2、在通常的配置文件中，有许多其他的配置设置。参数的数量和名称随着版本的不同而不同。例如：在Oracle8.1.5中，有一个参数文件是plsql_load_without_compile。在此之前的版本中则没有，在此之后的版本中也没有。在版本8.1.5、版本8.1.6以及版本8.1.7数据库中，分别有199、201、203个不同的参数，可以分别进行配置。在Oracle提供的个版本的Reference手册中，详细回顾了每一个已记录的参数。 3、除了已记录的参数，还有在文档资料中没有记录的参数。区分出已记录的参数和没有记录的参数。没有记录的参数以下划线开始。这些参数并不被人所熟知，基本上没有被使用。实际上大部分不被记录的参数更烦人，它们代表着不被接受的功能和向后兼容性标志。在配置文件中没有理由使用那些没有被记录的参数。许多这样的参数有毁坏性的副作用。一般使用的没有记录的参数【_TRACE_FILES_PUBLIC=TRUE】,这使得所有开发人员都可读跟踪文件。而不是只有DBA用户可以读。 4、参数文件不是必须在某个特殊位置的。启动一个数据库实例时，可以使用startup pfile=filename。当你想观察在不同设置下的影响时，而在数据库上尝试不同的init.ora参数时，这最为有用。 三、数据文件 1、每个数据库至少有一个与之相关的数据文件。其实除了最简单的“测试”数据库会只有一个数据文件以外，任何一个真正的数据库至少有两个文件（一个是“系统（SYSTEM）”数据文件，一个是“用户（USER） ”数据文件）。为了理解ORACLE是如何组织这些文件以及数据在它们内部是如何组织的，必须先理解什么是表空间（Tablespace）、段（Segment）、盘区（Extent）、块（Block）。这些都是Oracle用于保存数据库对象的分配单元。 2、段就是数据库对象，它消耗存储空间（对象），如表、索引、回滚段等等。当你创建一个表的时候，将创建一个表段。当你创建一个分区表时，即在每个分区创建一个表段。当你创建一个索引时，将创建一个索引段，等等。每一个消耗存储空间的对象最终被存储在一个单一的段中。有回滚段、索引段、临时段、聚族段等。段本身是由一个或多个盘区组成。 3、盘区是在文件中一个连续的分配空间。每个段至少开始于一个盘区，一些对象可能至少需要两个盘区（回滚段是一个至少需要两个盘区的例子）。在文件中，盘区中的空间总是连续的。盘区的容量范围是从一个块到2GB。盘区有块组成。 4、一个块是在Oracle中空间分配的最小单元。块是存储数据行、索引项、临时排序结果的地方。块是Oracle读写磁盘的对象。Oracle中的块通常有3个常见的大小（2KB、4KB、8KB）。当然更大大小也是允许的。段、盘区、块之间的关系如下图： 5、一个段由一个或多个盘区组成，一些连续分配的块组成一个盘区。数据库块的大小在数据库创建的时候就固定下来了，数据库中，每个块的容量是相同的，所有的块有相同的通用格式。块头包含关于块类型（表块、索引块等等）的信息、关于块上活动和过时的事务信息、磁盘上块的地址（位置）的信息。表目录，包含此块中存储各行的表的信息。行目录包含着在块中发现的描述行的信息。块头、表目录、行目录统称为块开销（block overhead），即在块上使用的不能提供给存储数据的空间，用来管理块本身。块剩下的两部分为：空闲空间和已用空间。 6、表空间是一个容器，用来保存段。每一个段恰好属于一个表空间，而一个表空间可以有多个段。表空间本身有一个或多个相关联的数据文件。表空间中给定的任何一个段的盘区完全包含在一个数据文件中。然而，一个段可以拥有来自许多不同数据文件中的盘区。 表空间在oracle中是一个逻辑存储容器。 在Oracle中存储的层次结构是： (1)、数据库由一个或多个表空间组成； (2)、表空间由一个或多个数据文件组成，一个表空间包含一个或多个数据库段。 (3)、段（表、索引等等）由一个或多个盘区组成。段存在于表空间中且只能属于一个表空间，但是一个段可以存储在表空间所属的多个数据文件当中。 (4)、盘区是在磁盘上一组连续的块。盘区存在于段中，一个盘区在一个段（表空间）中，但一个盘区只能存在所属表空间的单一数据文件中。 (5)、块是数据库中最小的分配单元，块是数据库使用的最小的I/O单元。 7、在Oracle8.1.5之前的版本中，管理在表空间中分配盘区的方法只有一种。这一方法称为表空间字典管理（directionary-managed tablespace）。即在数据字典中管理表空间的空间。当一个对象需要另一个盘区时，它就会请求系统来获得一个盘区。Oracle会随后到它的数据字典中，运行一些请求，发现空间（或没有发现空间），随后更新一个表中的行（或将之全部删除），并在另一个表中插入一行。Oracle管理空间的方法类非常类似于通过修改数据并四处移动来修改应用程序的方法。为了获取附加空间，运行在后台的SQL称为递归SQL。SQL INSERT语句使其它的递归SQL运行以获得更多的空间。如果频繁使用递归SQL，将是十分昂贵的，因此对数据字典的更新必须串行化。它们不能同时处理。 8、在Oracle8.1.5之后的版本中，引入了一个本地管理表空间的概念，这个概念与字典管理的概念相反。使用本地管理的表空间，在每个数据文件中存储的位图用来管理盘区。现在，要获得盘区，全部的系统需要做的就是在位图中一个位置设为1。要释放表空间，则将它恢复为0。 四、临时文件 Oracle中的临时数据文件是一个特殊的数据文件类型。当内存不足以在RAM中保存一个大规模排序操作的中间结果或结果集时，Oracle将使用临时文件来存储它们。永久数据对象，如表或一个索引，是不会存储到临时文件中的，但临时表或临时索引的内容则可能存储到临时文件中。所以，不能在临时文件中创建自己的应用程序表，但可以使用临时表存储临时数据。临时文件从不生成重做日志，但生成撤销日志，当用于全局临时表时，如果准备回滚一些事务，就可以在自己的会话中完成。 五、控制文件 控制文件是一个相当小的文件（最大为64MB），它包含Oracle需要的其他文件的目录或路径。参数文件告诉我们控制文件的位置，而控制文件则把数据库和联机重做日志文件的位置告诉实例。控制文件也给Oracle提供其他信息，例如关于已经发生的检查点的信息、数据库的名称、数据库创建时的时间戳、归档重做日志历史等等。控制文件应该由硬件或Oracle（RAID）当RAID或镜像不可用时多路服用的，且应该分别保存在分开的磁盘上，以避免万一出现磁盘故障时造成控制文件丢失。 六、重做日志文件 1、重做日志文件对Oracle数据库是至关重要的，它们是数据库的事务日志，仅在数据库恢复时使用（它们的唯一作用就是在实例或介质失败时使用，或作为维护用于数据库故障恢复的后备数据库的方法）。如果关掉数据库所在机器的电源，造成实例失败，Oracle将使用联机重做日志，以将数据库恢复到电源停止之前的那一刹那。如果包含数据文件的磁盘驱动器发生永久性故障，Oracle数据库将使用归档重做日志，与使用联机重做日志一样，将驱动器的备份及时恢复到那一时间点。另外，如果“意外地”丢失了一个表，或删除了一些关键信息，并提交了操作，可以通过这些联机和备份的重做日志来恢复备份，并使Oracle立即将它恢复到事故发生前的时刻。 2、事实上，在Oracle执行的每一个操作都生成一定数量的重做日志，它们被写入联机重做日志中。一些操作可能以生成尽可能少的重做日志的方式来执行。例如，可以用NOLOGGING属性创建一个索引。这意味着日志中将不记录那个索引的初始创建。 联机重做日志： 1、每一个Oracle数据库至少有两个联机重做日志文件，这些联机重做日志文件在大小上是固定的，并以循环的方式使用。重做日志首先写入日志文件1，当日志文件写到末尾时，切换至日志文件2，以此类推，直到写到最后一个日志文件，当最后一个日志文件写到末尾时，将自动切换回日志文件1。 2、从一个日志文件切换到另一个日志文件的动作称为日志切换。日志切换可能在一个优化效果不是很好的数据库中引起临时的“挂起”。因为重做日志是用来在操作失败时进行恢复处理用的，必须保证在重用之前，不需要在失败时重做日志的内容。如果Oracle不确定它需要一个日志文件的内容，它将暂时悬挂数据库的操作，并保证这个重做所“保护”的数据在磁盘上本身是安全的。一旦此事确定，将重新开始处理，重做日志将被重用。 3、数据库缓冲区高速缓存是数据库临时存储数据的地方。这是Oracle的SGA的结构。缓冲区高速缓存是第一个也是最重要的性能优化设备，它单独存在，以便使非常慢的I/O进程显得更快一些。只要高速缓存了修改的块，且没有写到磁盘上，就不能使用那个重做日志文件。 4、检查点是从缓冲区高速缓存到磁盘上脏（被修改过的）块的刷新。DBWn是Oracle的后台进程，负责在缓冲区高速缓存溢出的时候创造空间，更重要的是执行检查点。Oracle在后台做这件事，许多操作会导致检查点的发生，最通常的事情就是重做日志切换。当填满日志文件1，并切换到日志文件2时，Oracle初始化了一个检查点。在这时，启动DBWn，将由日志文件1保护的所有修改块刷新到磁盘上。在DBWn将那个日志文件保护的所有块刷新之前，Oracle 不能重用它。如果在DBWn完成检查点之前试图使用它，将获得如下信息： ... Thread I cannot allocate new log,sequence 66 Checkpoint not complete Current log#2 seq#65 mem# 0:C:\ORACLE\ORADATA\TKYTE816\REDO02.LOG ... 在数据库中，有报警（ALERT）日志（报警日志是服务器上的一个文件，它包含来自服务器的丰富消息，如启动和关闭消息和异常事件，如未完成的检查点）。所以，在此时，当此消息出现时，在数据库中的处理被悬挂，这时DBWn在匆忙地完成它的检查点。Oracle尽其所能地给DBWn提供全部处理能力，以期在那时它可以更快地完成。 5、这时一个在优化得很好的数据库实例中不会看到的信息。如果确实看到了这样的消息，那么就为最终客户引入了人为是、不必要的等待。这时可以避免的。方法是只要分配足够多的联机重做日志文件，以便于不会在检查点完成初始化之前试图重用日志文件。如果这个消息频繁出现，这意味着DBA还没有为应用程序分配足够的联机重做日志，或者需要对DBWn优化得更有效。 6、不同的应用程序将生产不同数量的重做日志。DSS（决策支持系统，Decision Support System）将自然地生成重要的联机重做日志，但它比OLTP（事务处理 Transcation Processing）系统生成得少。数据库中二进制大对象（Binary Large Object，BLOB）中进行很多图像操作的系统，与简单的订单输入系统相比，可以生成多得多的重做日志。 7、在设置联机重做日志的大小和数量的时候，必须考虑各种因素，如下： （1）备用数据库，如果你正在使用备用数据库特性，在此重做日志在它们填满以后发送到另一台机器，并应用到数据库的一个副本上， 你最有可能想要许多小的重做日志文件。这将有助于保证备用数据库与主服务器的异步不会太明显。 （2）许多用户修改相同的块，这里你可能想要大的重做日志文件。因为每个人都在修改相同是块，那么希望在将他们写入磁盘之前，尽可能多的更新它们。每一个日志切换将触发一个检查点，所以希望日志切换不要太频繁。 （3）恢复的平均时间，如果必须保证恢复需要尽可能少的时间。那么可能需要较小的重做日志文件。在恢复上，处理一个或两个小的重做日志文件所花费的时间比处理一个巨大的重做日志文件所花费的时间少。 归档重做日志 Oracle数据库可以在两种模式之中的一种下运行-----非归档模式和归档模式。如果不用归档模式的话，系统不会是一个实用系统。非归档模式的数据库迟早将在某一天丢失数据，这是不可避免的。如果不使用归档模式的话，必将丢失数据。只有测试系统或开发系统才可以运行在非归档模式下。这两种模式之间的区别就是Oracle在重用重做日志文件时，对其做了哪些工作。在包含着有价值数据的系统上，必须使用归档模式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c63e16e788ce4c962facddeee28927e/" rel="bookmark">
			sqlite 实现top
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//实现Top1功能
//limit n1,n2,跳过n1行读取n2行数据
select * from alarm limit 0,1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a339077b3eeb020f8c85797000b6727b/" rel="bookmark">
			【LaTeX入门】15、在文章中添加脚注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引言 脚注在写论文的时候还是比较常用的，比如本文中会介绍一个很实际的例子，即在一篇论文写完后，会在论文的首页的脚注位置写上作者的一些相关信息。 脚注的应用 一般我们使用脚注时不需要额外使用宏包，只需要在该插入脚注的地方插入\footnote{脚注内容}即可，这样的脚注： 自动编号。首行缩进。 但是一般论文首页脚注位置不需要首行缩进，因此我们引入footmisc宏包，并使用marginal使得不首行缩进。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \documentclass[11pt,a4paper]{article} \usepackage{CJK} \usepackage{type1cm} \usepackage{times} \usepackage[marginal]{footmisc} \renewcommand{\thefootnote}{} \begin{document} \begin{CJK*}{GBK}{song} 这段文章\footnote{\noindent \textbf{收稿日期}：2000-06-30；\textbf{修回日期}：2000-11-16\\ \textbf{基金项目}：``九五''国家科技攻关资助项目(96-B02-03-05)\\ \textbf{作者简介}： 陆峰(1970-)，男，新疆维吾尔自治区乌鲁木齐市人，中国科学院资源与环境信息系统国家重点实验室博士后， 主要从事交通网络的地理信息系统数据模型和网络分析相关算法研究。}. \end{CJK*} \end{document} 第5行：引入宏包，使得脚注首行不缩进。 第6行：设置脚注不编号。 第9行：设置脚注内容。 显示效果如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba78d42df28366fef2e23f5c042d484b/" rel="bookmark">
			HDU3790--最短路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem Description 给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。 Input 输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点。n和m为0时输入结束。 (1&lt;n&lt;=1000, 0&lt;m&lt;100000, s != t) Output 输出 一行有两个数， 最短距离及其花费。 Sample Input 3 2 1 2 5 6 2 3 4 5 1 3 0 0 Sample Output 9 11 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; #define maxn 1008 int W[maxn][maxn]; int Wc[maxn][maxn]; int dis[maxn]; int cost[maxn]; inline int min(int a,int b) { return a&gt;b?b:a; } int main() { int n,m; while(scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba78d42df28366fef2e23f5c042d484b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd07ca64e52cca6b89fc6a9fd9afb645/" rel="bookmark">
			HDU1301--Jungle Roads
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem Description The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd07ca64e52cca6b89fc6a9fd9afb645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce86f0a12af8f219f5cfbd8822b50150/" rel="bookmark">
			IMB的Zest文档学习 代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个程序：
public class FirstZest { public static void main(String[] args) { // SWT Display display = new Display(); Shell shell = new Shell(display); shell.setText("First Zest Program Demo"); shell.setLayout(new FillLayout()); shell.setSize(300, 300); // 创建 Graph Graph graph = new Graph(shell, SWT.NONE); // 创建一个图形节点 GraphNode startNode = new GraphNode(graph, SWT.NONE, "Start"); // 创建另外一个图形节点 GraphNode endNode = new GraphNode(graph, SWT.NONE, "End"); // 创建节点关联 new GraphConnection(graph, SWT.NONE, startNode, endNode); // 设置布局管理器 graph.setLayoutAlgorithm(new SpringLayoutAlgorithm( LayoutStyles.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce86f0a12af8f219f5cfbd8822b50150/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004d099aebfcc1e416c104668b6514bb/" rel="bookmark">
			background-size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		background-size: auto || &lt;length&gt; || &lt;percentage&gt; || cover || contain 取值说明：
1、auto:此值为默认值，保持背景图片的原始高度和宽度；
2、&lt;length&gt;此值设置具体的值，可以改变背景图片的大小；
3、&lt;percentage&gt;此值为百分值，可以是0％〜100％之间任何值，但此值只能应用在块元素上，所设置百分值将使用背景图片大小根据所在元素的宽度的百分比来计算。
4、cover：此值是将图片放大，以适合铺满整个容器，这个主要运用在，当图片小于容器时，又无法使用background-repeat来实现时，我们就可以采用cover;将背景图片放大到适合容器的大小，但这种方法会使用背景图片失真；
5、contain:此值刚好与cover相反，其主要是将背景图片缩小，以适合铺满整个容器，这个主要运用在，当背景图片大于元素容器时，而又需要将背景图片全部显示出来，此时我们就可以使用contain将图片缩小到适合容器大小为止，这种方法同样会使用图片失真。
当background-size取值为&lt;length&gt;和&lt;percentage&gt;时可以设置两个值，也可以设置一个值，当只取一个值时，第二个值相当于auto，但这里的auto并不会使背景图片的高度保持自己原始高度，而会与第一个值相同。
兼容的浏览器
background-size和其他的一些CSS3属性一样，需要加上自己的别名，
/*Ｍozilla*/ -moz-background-size: auto || &lt;length&gt; || &lt;percentage&gt; || cover || contain /*Webkit*/ -webkit-background-size: auto || &lt;length&gt; || &lt;percentage&gt; || cover || contain /*Presto*/ -o-background-size: auto || &lt;length&gt; || &lt;percentage&gt; || cover || contain /*W3c标准*/ background-size: auto || &lt;length&gt; || &lt;percentage&gt; || cover || contain 上面主要针对性介绍了background-size的理论知识，下面我们分别来看看其在各种值怕显示效果：
为了说明效效果，先给出一个ＤＥＭＯ结构和一张背景图：
HTML Code:
&lt;div class="demo"&gt;&lt;/div&gt; 先初步为其加上一些效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004d099aebfcc1e416c104668b6514bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395d37417593712c9f1eb3f591881ad9/" rel="bookmark">
			[draw2d] ZoomIn and ZoomOut 放大缩小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
package com.iteye.xmind.draw2d.version2; import org.eclipse.draw2d.Button; import org.eclipse.draw2d.LightweightSystem; import org.eclipse.draw2d.ScalableFreeformLayeredPane; import org.eclipse.draw2d.geometry.Rectangle; import org.eclipse.swt.SWT; import org.eclipse.swt.events.KeyEvent; import org.eclipse.swt.events.KeyListener; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; public class ZoomInZoomOut { private static ScalableFreeformLayeredPane chart; public static void main(String args[]) { Shell shell = new Shell(); shell.setSize(300,200); shell.open(); shell.setText("F5 ZoomIn, F6 ZoomOut!"); shell.addKeyListener(new KeyListener() { public void keyPressed(KeyEvent e) { } public void keyReleased(KeyEvent e) { if(e.keyCode == SWT.F5) { double scale = chart.getScale(); chart.setScale(scale+0.2); } if(e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/395d37417593712c9f1eb3f591881ad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2a6866f7b34641b188f9b946ded1a4e/" rel="bookmark">
			c#,.net 微软开发者的福音--手机跨平台开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 长期以来 微软在移动端的发展明显不如他PC端发展的那么顺利，导致我们这些活在微软阵营下的屌丝们开发移动端的软件是如此的步履维艰，你要写android的你学学java,eclipse,要开发iphone的学学 c.倒不是说我们懒 ，程序员都是勤奋的，但是用自己的短处去比别人的长处总是感觉没啥竞争力。其他平台的程序员开发mobile端的程序也是如此的吃力，一般至少要写2套。一套用java跑android 一套用c或者c++跑apple的产品。
难道就没有一种可以真正实现跨平台的产品吗？
本人在做了些许的调查后 发现如果要写一个one for all 的产品 对于c#程序员有2种选择，现在我把这两种选择的优点和缺点大概描述下
1 JQUERY MOBILE+ WEB SERVICE+ Phone Gap
Advantage: one for all, not need consider type of mobile
Disadvantage: could not write code on server side, need write new web services
Suitable for use: Low interaction
2 mono
Advantage: could use the code now we have, can write code on server side
Disadvantage: need 3 type of UI for (windows, apple, android) 在经过比较后 ，我选择了第一种 ，这个真的就跟开发者说的一样 write one and run everywhere,目前为止 他支持7种mobile平台，主流的平台都支持，唯一的缺点就是你不能写后台代码 ，所以对于交互比较强的软件可能不太适用，但是对于查询展示类的是不错的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2a6866f7b34641b188f9b946ded1a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e231ef0274078986a1dfb86fb508ff/" rel="bookmark">
			【转】应届生学C好还是学JAVA好，做什么更挣钱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老师： 你好。 我是一名09界刚毕业工作不久的java菜鸟级程序员。本人对java水平可以混口饭了，现在可以在工作中开发一般的小项目，都是B/S的。 本人基础很烂，基本上：算法 、数据结构、计算机组成原理、操作系统、编译原理可以说从来没有学过。目前我工作的环境是：开发b/s 架构的项目，不考虑性能，实际上实现需求就可以了。我可以跟客户打交道，可以自己分析需求，可以自己跟其他人合作一些10万以下的小项目。基本上都是对数据库的增删改查。来来去去都是那些表非常无聊。 虽然工作不久，但是目前已经感觉到在这样下去，顶多只是熟悉一下业务而言。就本身编程水平基本上没多少提高。因为公司追求效益，只要写出来的东西能用就完事，没时间考虑代码，而且java没有指针，也不用的算法，工作中的设计模式也就常用的几个。剩下的几乎没什么可以提高的了( 项目管理学了一些，已经其他 )。 目前非常希望转C方面发展，我C语言可以认为0水平。但是由于有了java功底。虽然已经体会到语言只不过是解决方案的工具而已。但是就算我在java里面花再多时间感觉自己只是在浪费青春，我绝不是小看java，因为我也是用这门语言的，java没有内存管理，用java或者类似的语言，我永远只看到上层的东西。我希望自己成为一名技术非常强悍的程序员。可以写出一些经典的开源工具。因为以前大学都是逃课，睡觉，打游戏。所以基础很差，实际上我相当于一个0基础的高中生学了半年java的人。目前自己每天在学数据结构。但是不知道路在哪里。我想换一份 C 的工作，不知道从哪里开始学。我选C有几个原因的：C的工作环境可以迫使你使用算法，然后进一步的慢慢深入，可以接触操作系统，然后慢慢使自己进入高层次的开发。因为C涉及面广，所以迫使自己学得到很多东西。进而提升自己水平而已。与其说选C语言，不如所选C语言所涉及的范围而已！因为在java环境，不可能到达我理想高度！ 大环境很浮躁，这是我切身的体会。但是我有耐心和毅力。我第一步的想法是 先转到涉及算法的环境。实在不行，只要开发上用到C就行了。 因为我对C的工作环境不了解，可能理解上有误，希望你指点一下。如果像我这种水平的人，想要找到C的工作，大概怎么起步。 我说一下自己的java起步 当初我是这样的： 1、学习java 语法(j2se)。 2、用java 做一个 俄罗斯游戏。 3、学习 jsp 做一个MVC的留言板， 学习 流行框架（SSH）， 做一个 管理系统。 就这样 我就找到 JAVA EE 应用开发的工作了。当时进公司不用适应期就直接上项目了。 我当初是在没有老师（ 老师重来不把一个年年补考，每次都垫底的学生当人看），同学鄙视（最后一个学期每个人都找工作，打游戏。而我每天都在疯狂的学习 一直到毕业前夕 )，没有人管的情况下过来的。靠google, baidu, 买经典教材，网络视频，Q群 的情况下，终于用一张合同在毕业前证明了自己的能力！ 这段辛酸的经历给了我很多东西，特别是自制力、自学能力、毅力。 现在我已经打算辞职回家，再次进入疯狂的学习状态，虽然现在每天下班回来也在学习。但是每天4个小时远远比不上 原先每天12个小时的自学效率。而且自学可以连续学半年，现在每天还要工作，非常不合适。 我希望用半年 至少补上 大学的 数据结构，基本算法，计算机组成原理，操作系统、 同时复习数学知识（ 主要是 离散数学、线性代数 ）这些基础。 如果半年内时间紧的 Linux、汇编和编译原理可否先暂时缓缓。 工作意向：优先 游戏编程, 然后其他的用C的也可以( 曾经非常想考虑 C的嵌入式，但是发现涉及知识有点广，而且工具也不便宜 ）其实我非常希望向网络发展，只是不知道代价多大（ TCP/IP 和其它网络知识不懂，这个要多久，1个月内可以达到工作要求可以接受 ）。 然而C的路子怎么走呢？ 原先这样思考的 ： 1 C语法 2、用一个小游戏（ 俄罗斯方块、或者是 五指棋 ）来巩固前面C语言基本知识。 掌握这些后我不知道干嘛了。 第三步：？？？？（ MFC？ 不学它行不行，如果工作普遍需要我非常乐意学 ） 目前本人的水平基本（资质普通）就这样了。你看通过半年 每天12个小时的高强度的学习，怎么才可以到达目前 找到 使用 C语言 开发 的工作。 希望您指点一下。最好可以列出来几条路子 ， 比如 游戏编程的、网络的、然后其它的。 非常感谢你看完我的邮件， 静候佳音。 2009-10-12 专家回答： 这位同学你好，从这封信看得出来你的心情还是很急迫的，你这种心情我完全能够理解。我把问题分几点说，尽量说细一点，希望能对你有所帮助。 首先，你说你是09年毕业的大学生，那么算下来，你应该上班才几个月而已，就这一点，你能在新的单位几个月时间就把工作拿上手，首先恭喜你，这说明你是真的很有实力，当年我转行游戏编程，用了差不多两年才真正想清楚程序设计的真意，我觉得你比我强。呵呵。 你说Java基本上都是做B/S数据库，觉得没有意思，其实这个我也很理解，不过，我觉得你可能不是很了解实际情况。这里我需要给你讲清楚，其实不仅仅是Java程序员，只要到企业中做应用开发，或多或少都和数据库沾点边。当年我用VC还写报表系统呢，你能说这不是数据库？ 其实有个问题可能大家都没有关注到，至少，我到学生大本营半年，发现大家都没有讨论过。那就是，做什么最赚钱？无可否认，软件可以实现各方面应用，不过，就我的观察，在现实生活中，有两种软件最赚钱，一种是数据库，一种就是嵌入式底层的东东，嗯，随着互联网的发展，目前做网络程序也很赚钱。 其实原因很简单，就是因为软件的盗版问题。我想看到我这篇文章的每个人，或多或少都用过盗版软件，包括我自己，呵呵，咱们中国人穷啊，动辄几百上千的软件费用，咱们买不起的，所以电脑城的光盘市场才这么火爆。 但是，这带来了另外一个问题，就是当有一天，我们自己成为软件开发者的时候，才发现，盗版导致我们自己的收入降低，无法维系生活。这时候，恐怕再来大声疾呼，杜绝盗版，已经晚了，你说是不？ 其实我们可能对市场不敏感，反正每个月发薪水，收入基本上旱涝保收，但是公司的老总们对这个很敏感，软件卖不出钱，公司就亏本，亏多了，就垮掉了，最终程序员还是没有收入。 因此，公司里面做软件，一般都做上面的软件，即数据库应用，嵌入式应用，控制类应用，网络服务应用较多。因为这几种应用，不容易被盗版，能卖到钱。通用性的应用，比如操作系统，比如很多工具软件，比如PC游戏，其实很难卖钱的。 数据库应用，一般数据库本身是使用成熟的商用系统，如MySQL，SQL Server，Oracle等，我们小公司拿来，再根据具体应用需求，做二次定制开发，这是一大类市场，其实这个市场的真正名字叫做“企业数据应用定制市场”。由于是定制的，自然没有通用性，也就不会有盗版了。 控制类，嵌入式类，很多都和具体硬件设备相关，换个硬件平台就不通用了，大家知道，中国的东东，要防盗版，最好和硬件相关，只要绑定硬件，软件一般不好到，以前出的防病毒卡，汉卡什么的，其实利用的就是这个市场规律。 服务应用呢，就更好说了，由于主要程序逻辑都在服务器端，基于B/S的模型，客户端连个软件都没有，服务器的管理自然比卖出去的软件好管理，不容易盗版。因此，这类企业也活得长，比如各个网站，各种网游什么的。所以我一直觉得，以后云计算发展起来后，很多软件可能会把零售制改为租用制，比如photoshop，大家买套软件几千，但一般人就是处理一下自家照片，自然不划算，因此盗版很多，但以后假如软件公司把它做成服务器版，大家把照片上传，处理，最后再存回来，这个过程每次租金1毛钱，每个人都花得起的话，我看以后就没那么多盗版了。另外，服务器应用其实大多数也是数据库应用。 所以，我首先要说，不管你是不是换工作，以后你恐怕会一直遇到数据库类的应用，不管你喜欢不喜欢，但这是社会的现实，你必须承认。你说对吧？ 在这个共识下，我们再来看，其实我们会发现，三大主流应用中，只有嵌入式不适合Java，其他的数据库和服务器应用，其实Java比C和C++方便得多，因此，我建议你就在Java这条路上走下去，不一定非要转C和C++。本来你的强项就是Java，而且这也是主流的可以卖钱的市场，为啥不坚持呢？ 从另外一个角度说，我也认为你应该坚持，你毕竟毕业不到半年，对社会，对公司，对本职工作其实了解并不深入，你认为Java就那么几个设计模式，没有挑战性，这个我能理解，但是，我觉得你说的不全面。起码我做程序做了这么多年，到底有多少种设计模式，我也说不清楚，我相信很多人都说不清楚。需要具体应用具体分析。 我不是Java程序员，不过我觉得，如果要做一个合格的程序员，首先不应该是程序设计的大师，而应该是理解客户需求，并迅速拿出解决方案的专家，这个，不管用什么语言，不管在哪里工作，都是必须的，同时，这也需要很长时间的积累。 准确的讲，我认为，一个人不在一门语言，一种业务领域努力3年、5年乃至10年，是很难成为专家的。因此，我建议你完全没有必要这山望着那山高，轻易就决定跳槽，建议你就这个环境，先锻炼自己，我这里放句话，你可以试着验证一下，两三年以后，你再看Java语言和数据库开发，都还是会找到自己不会，值得学习和钻研的东西的。因为最起码，客户的需求是千变万化，永无止境的。 当然，话分两说，如果你真的喜欢C，很想做嵌入式应用，就是不想做Java，那也无可厚非，因为毕竟每个人都有选择的权利。 不过，我仍然不建议你辞职回家学习。我以前有句话，大学毕业，才是学习的开始，不过，这个大学毕业后的学习，和学校中的学习，有很大差别，突出的几点：没有老师，没有教材，都是自己主动学，针对自己的需求来学习，学技巧多，学原理少，并且一般都是干中学，而不是学完了再干，我总结就是“用以致学”，而不是“学以致用”，这是我总结的学习经验。 同时，毕业了，总不好意思再向家里面父母要钱，总得自己赚钱养活自己。你说是吧？你说辞职半年，专心学习，那你没有收入吃啥？还不是吃父母的？这样不是很好。 C语言没有那么神圣的，也没有太高的门槛的，不要想太复杂了。另外，指针，内存什么的，学习C语言确实能接触到，但是，我还是要说，C语言并不是因为有了指针和内存的直接访问，才牛叉，C语言是因为大量的程序员用它解决了很多具体应用，才牛叉的。请你注意不要学偏了，不要为学指针而学指针。指针就是指针，仅仅是个访问工具而已，不是用来显得很酷的，需要了才用它。 Java语言用个数组，其实也能模拟指针的大部分功能的。其实我作为C程序员，我们平时工作时对指针是很谨慎的，能不用都不用，尽量用引用来代替，为啥，因为危险，容易出错。 数据结构，计算机组成原理，算法语言，编译原理，嗯，还有个图论，这几门应该算最经典的计算机理论了，但是，也没那么神秘的，书店里面有，自己没事买几本回来看看就好了，生活是没有考试的，不需要你必须考够100分才能找到工作，了解，理解就好了，背书是背不出好程序员的。你说对吧？ 其实这几门，不用C和C++语言，用Java语言一样可以学习的。嗯，编译原理可能够呛，需要理解一点C。 另外，我再给你透露一点点，其实真正实际应用中，我们对于上述基础知识用得很少，用得最多的，其实就是数据结构里面的队列了，其他，包括栈都很少用，C程序员也不是每天都从底层，从0做起的，还是有很多工具套用的。这和Java语言从框架开发是一个道理。 反而有一门课程建议你好好学，就是概率和统计学，这门知识是我现在应用最多的，很多时候，我们评估软件系统性能，瓶颈优化，都是在用这个学问。程序员做久了，可能大多数时候都是和这个在打交道，建议买本好好看。 总结一下吧，建议你目前暂时不要辞职，既然选择了Java和数据库应用开发，选择了B/S模型，你耐心做3年再看，也许3年后，你自己的想法就变了。 C可以学，你说的课程都可以学，不过，不要辞职专门学，先赚钱养活自己，再利用时间学习，你这么大的决心，每天晚上就不要看电视了，那你每天晚上，19：00~24：00，至少有5个小时来学习，利用好了，我敢说比你在大学里面效率高。 看书学习不是什么神秘，神圣的事情的，也不需要什么斋戒沐浴，念几天经才能学习，我觉得就和我们吃饭喝水一样，随时都可以学的，找几本书，就在床头放着，每天晚上看看，几个月也就看完了，又有多难嘛？ 关键是，养成习惯。 你说对不？呵呵，先说到这里，有问题再问哈。 最后补充一点，如果学习C，并且有一定基础的话，等我书出来看看吧，里面的跨平台开发工程库，可以帮助你迅速掌握嵌入式底层的一些技巧。不过，要有基础哈，一点不会C看不明白的。 ======================================================== 昨天又收到这位同学的回信，这里将回复再次附在这里。 原文：我意已决 老师： 你好！，非常感谢你的回信，但是我还是问题希望向你请教。 首先阐述自己几点情况：我目前对赚钱不感冒，即使我薪水很低（月光那种)。虽然自己技术不强，但是靠JAVA养活自己是绝对没有问题的！ 我没有小看数据库。也知道需求的重要性。但是我不自己精通“xx”的业务。因为我继续呆在上层，我只是更加熟悉“xx”的业务而已。 只是更喜欢跟代码和底层打交道（虽然我没接触过底层），如果要成为专家，打比方我希望成为游戏引擎的专家，而不是开发ERP，开发银行系统这种类型的专家。 我知道设计模式有很多，但是java一般开发常用的就几种。目前我非常坚决的放弃JAVA了，我知道这个风险很大，但是如果连这个决心都没有的话，以后不会有很高的成就的。目前身体处于巅峰状态，每一年都非常宝贵。 我不想浪费。 我曾说过，我只是在大学最后半年努力而已，那半年的环境是：没有任何人管的，而且宿舍里面，整个专业基本都在打游戏，或者是找工作，或者是其他。那种环境下，我一个最差的学生在忍受别人假正经眼光，慢慢一个人摸索，恐怕你无法想象的。我一直忍到到毕业前1个星期才开发网投简历。我进公司是经过笔试，机试，面试的。没有任何内部关系和运气的挤到竞争者。我也深知这个行业的竞争非常激烈。很多普通大学计算机专业的学生 都被迫转其他。 我目前不是被迫学，是我自己想去学，而且我非常开心的每天回来看数据结构的书（目前就那种水平了) 我开始努力的时候，就已经不打游戏，不看电视。基本出来每天只是看点体育新闻而已(每天不超过15分）。每天下班回来都学3-4( 20:00-24：00)个小时，双休 每天都是10小时至少。每天上网去的都是去 CSDN、JAVAeye、mashibing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e231ef0274078986a1dfb86fb508ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092da09417cb4c4d3e4e1748c0b8798a/" rel="bookmark">
			黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于开发人员来说，往往对各种测试方法感到疑惑。特别是在整合代码的时候，我们就能深刻感觉受到测试的重要性。很多开发人员只注重写代码，轻视测试的重要性。总是代码一写完提交然后就交给测试组测试了，没多久测试组发回测试报告。然后又苦恼的修改自己代码的bug，慢慢地就开始讨厌测试组人员。没有经过自己细心测试的代码，不仅浪费了别人时间更影响到了自己的心情。
企业级项目实战(带源码)地址： http://zz563143188.iteye.com/blog/1825168
收集五年的开发资料下载地址： http://pan.baidu.com/share/home?uk=4076915866&amp;view=share 接下来为大家细心讲述一下各种测试应用的环境及作用
一、测试环境和角色
黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试 ：
这些测试的范围正好是逐步递增的关系，但是测试的人员角色是不同。
黑盒测试、白盒测试、单元测试：开发人员分在不同的开发阶段要做的事情
黑盒测试、集成测试、系统测试：测试人员在测试周期内级层做的工作
验收测试：一般是在用户方做的工作 二、根据不同的范围
测试可以分为单元测试、集成测试、系统测试和验收测试。 体现了测试由小到大、又内至外、循序渐进的测试过程和分而治之的思想。
三、测试的功能
1.单元测试 粒度最小，一般由开发小组采用白盒方式来测试，主要测试单元是否符合“设计”。
单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。
2.集成测试 界于单元测试和系统测试之间，起到“桥梁作用”，一般由开发小组采用白盒加黑盒的方式来测试，既验证“设计”，又验证“需求”。 主要用来测试模块与模块之间的接口，同时还要测试一些主要业务功能。集成测试（也叫组装测试，联合测试）是单元测试的逻辑扩展。它最简单的形式是：把两个已经测试过的单元组合成一个组件，测试它们之间的接口。从这一层意义上讲，组件是指多个单元的集成聚合。在现实方案中，许多单元组合成组件，而这些组件又聚合为程序的更大部分。方法是测试片段的组合，并最终扩展成进程，将模块与其他组的模块一起测试。最后，将构成进程的所有模块一起测试。此外，如果程序由多个进程组成，应该成对测试它们，而不是同时测试所有
集成测试进程。
3.系统测试 粒度最大，一般由独立测试小组采用黑盒方式来测试，主要测试系统是否符合“需求规格说明书”。在经过以上各阶段测试确认之后，把系统完整地模拟客户环境来进行的测试。系统测试是将已经确认的软件、计算机硬件、外设、网络等其他元素结合在一起，进行信息系统的各种组装测试和确认测试，其目的是通过与系统的需求相比较，发现所开发的系统与用户需求不符或矛盾的地方，从而提出更加完善的方案.。它的的任务是尽可能彻底地检查出程序中的错误，提高软件系统的可靠性，其目的是检验系统"做得怎样？"。这阶段又可分为三个步骤：模块测试，测试每个模块的程序是否有错误；组装测试，测试模块之间的接口是否正确；确认测试，测试整个软件系统是否满足用户功能和性能的要求。该阶段结束应交付测试报告，说明测试数据的选择，测试用例以及测试结果是否符合预期结果。测试发现问题之后要经过调试找出错误原因和位置，然后进行改正。是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。
系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试
4.验收测试与系统测试相似，主要区别是测试人员不同，验收测试由用户执行。
5.黑盒测试：不考虑程序内部结构和逻辑结构，主要是用来测试系统的功能是否满足需求规格说明书。 一般会有一个输入值，一个输入值，和期望值做比较。黑盒测试也称功能测试，它是通过测试来检测 每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序 内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。
6.白盒测试：主要应用在单元测试阶段，主要是对代码级的测试，针对程序内部逻辑构，测试手段有：语句覆盖、判定覆盖、条件覆盖、路径覆盖、条件组合覆盖。白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。 这一方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。
系统测试和集成测试的区别【转】 一般的小系统区分不是很大的 1.计划和用例编制的先后顺序 从V模型来讲，在需求阶段就要制定系统测试计划和用例，HLD的时候做集成测试计划和用例，有些公司的具体实践不一样，但是顺 序肯定是先做系统测试计划用例，再做集成 2.用例的粒度 系统测试用例相对很接近用户接受测试用例 集成测试用例比系统测试用例更详细，而且对于接口部分要重点写，毕竟要集成各个模块或者子系统 3.执行测试的顺序 先执行集成测试，待集成测试出的问题修复之后，（配置管理，基线化），再做系统测试。 4.用例的数量 系统测试的用例数量一般比集成测试的用例数量少，具体的数量要根据各个公司的性能基线来确定，一般写不到这个数量的测试用例还通不过审计
系统测试这个称呼往往被用于压力测试、容量测试、性能测试、安全测试等方面。 而集成测试这个称呼往往被用于细节化的功能测试的超集——从用户需求来设计和组织较大颗粒度的功能测试。
系统测试最主要的就是功能测试，测试软件《需求规格说明书》中提到的功能是否有遗漏，是否正确的实现。做系统测试要严格按照《需求规格说明书》，以它为标准。测试方法一般都使用黑盒测试法； 集成测试在系统测试之前，单元测试完成之后系统集成的时候进行测试。集成测试主要是针对程序内部结构进行测试，特别是对程序之间的接口进行测试。集成测试对测试人员的编写脚本能力要求比较高。测试方法一般选用黑盒测试和白盒测试相结合。
集成测试：是在软件系统集成过程中所进行的测试，其主要目的是检查软件单位之间的借口是否正确。它根据集成测试计划 ，一边将模块或其他年间单位组合成越来越大的系统，一边运行该系统，以分析所组成的系统是否正确，各个组成部分是否合拍。集成测试的策略主要有自顶向下和自底向上两种。也可以理解为在软件设计单元、功能模块组装、集成为系统时，对应用系统的各个部件（软件单元、功能模块接口、链接等）进行的联合测试，以决定他们能否在一起共同工作，部件可以是代码块、独立的应用、网络上的客户端或服务器端程序。 系统测试：系统测试是基于软件需求说明书的黑盒测试，是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等满足其规约所指定的要求，检查软件的行为和输出是否正确，并非一项简单的任务，被称为测试的“先知者问题”。因此，系统测试应该按照测试计划进行，其输入、输出和其他的动态运行行为应该与软件规约进行对比。软件系统测试的方法很多，主要有功能测试，性能测试，随机测试等。
通俗的讲，一个产品从研发到出厂的工程中，测试分为三个阶段：单元测试、集成测试、系统测试； 单元测试：一个模块的功能及常规错误测试； 集成测试：完成单元测试后，各模块联调测试；集中在各模块的接口是否一致、各模块间的数据流和控制硫是否按照设计实现其功能、以及结果的正确性验证等等；可以使整个产品的集成测试，也可以使大模块的集成测试； 系统测试：针对整个产品的全面测试，既包含各模块的验证性测试（验证前两个阶段测试的正确性）和功能性（产品提交个用户的功能）测试，又包括对整个产品的健壮性、安全性、可维护性及各种性能参数的测试
转自http://blog.csdn.net/zll01/article/details/4555406
功能测试 定义 Functional testing（ 功能测试），也称为behavioral testing（行为测试），根据产品特性、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。本地化 软件的 功能测试，用于验证 应用程序或网站对目标用户能正确工作。使用适当的平台、 浏览器和 测试脚本，以保证目标用户的体验将足够好，就像 应用程序是专门为该市场开发的一样。 功能测试是为了确保 程序以期望的方式运行而按功能要求对 软件进行的测试，通过对一个系统的所有的特性和功能都进行测试确保符合需求和规范。 功能测试也叫 黑盒子测试或 数据驱动测试，只需考虑各个功能，不需要考虑整个 软件的内部结构及代码.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092da09417cb4c4d3e4e1748c0b8798a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/028e8493c136a5d275e84bcd1e392f21/" rel="bookmark">
			【图形-OpenCascade】OpenCascade使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GeomConvert------- BSpline曲线、曲面拆分，Handle(Geom_Curve)转BSpline曲线
BRepExtrema_DistShapeShape------求两个TopoDS_Shape（TopoDS_Face、TopoDS_Vertex、TopoDS_Edge、TopoDS_Wire...）的最近距离，得到这个距离所对应的点【在TopoDS_Shape1上的和TopoDS_Shape2上的都可以得到】、最近距离的值、最近距离点的个数
GeomAPI_IntCS----求Geom_Curve和Geom_Surface的交点、交点，得到交点的个数和对应的交点、曲线段的条数、对应的曲线（Geom_Curve）
GeomAPI_IntSS----求Geom_Surface和Geom_Surface的交线，得到交线的条数和对应的交线
BRepAlgoAPI_Section---求TopoDS_Shape和TopoDS_Shape、Geom_Surface和TopoDS_Shape、TopoDS_Shape和gp_Pln相交后的数据，得到TopoDS_Shape【包含相交部分的数据，BRepAlgoAPI_Section继承于BRepBuilderAPI_MakeShape】
BRep_Tool---TopoDS_Face转Geom_Surface、TopoDS_Edge转Geom_Curve（转完后可以得到曲线U值范围）、TopoDS_Vertex转gp_Pnt
StlTransfer---TopoDS_Shape转StlMesh_Mesh
StlMesh_MeshExplorer---StlMesh_Mesh的遍历器、获得三角面片的三个顶点的x、y、z值
遍历示例：
TopoDS_Shape TrimNurbsToSTL( const TopoDS_Face&amp; aTrimTopFace,Standard_Real precision ) { TopoDS_Face TopoFace = BRepBuilderAPI_MakeFace(aTrimTopFace).Face(); Handle_StlMesh_Mesh aSTLMesh = new StlMesh_Mesh(); StlTransfer::BuildIncrementalMesh(TopoFace, precision, Standard_False, aSTLMesh); Standard_Integer NumberDomains = aSTLMesh-&gt;NbDomains(); Standard_Integer iND; gp_XYZ p1, p2, p3; TopoDS_Vertex Vertex1, Vertex2, Vertex3; TopoDS_Face AktFace; TopoDS_Wire AktWire; BRepBuilderAPI_Sewing aSewingTool; Standard_Real x1, y1, z1; Standard_Real x2, y2, z2; Standard_Real x3, y3, z3; aSewingTool.Init(CAD_NURBS_STL_TOLERANCE,Standard_True); TopoDS_Compound aComp; BRep_Builder BuildTool; BuildTool.MakeCompound( aComp ); StlMesh_MeshExplorer aMExp (aSTLMesh); for (iND=1;iND&lt;=NumberDomains;iND++) { for (aMExp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/028e8493c136a5d275e84bcd1e392f21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481f338a7916e9e18b19683a746c1023/" rel="bookmark">
			多长时间可以成长为一个架构师？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个程序员，多长时间可以成为一个架构师？5年？10年？相信这个也是很多程序员所关心的，包括我自己。很多人都说5年，是程序员的一道坎，迈过去了，前途光明，否则..... 就我个人见解来说，成为一个架构师，必须具备五点：第一必须要有丰富的编程经验；第二丰富的知识面；第三是否具备对已有复杂系统的快速分析能力；第四面对新的技术是否能够快速适应并应用；第五是否能够根据实际资源，拿出可行性的方案？多少时间可以确定？ 对于第一条，第二条，相信很多人都很容易满足，但是第三条，就不是轻易能够做到的，这里面是对前面两条知识面的综合运用；对于第四点这里提几个问题，看看自己是否能够做到？a.对于新的技术，如果有足够的文档，自己多长时间可以上手？1个星期？2个星期？或者是更多？b.对于新技术，如果现在可读可参考的的文档比较少，自已多长时间可以上手？ 这里面其实还有一点：一个人是否有丰富的行业经验？是否有人同意把它作为一个架构师所必备的？这个问题就交由各位同仁思考了........ 原文链接：http://www.software8.co/wzjs/cxyyg/3403.html 转载于:https://www.cnblogs.com/wwwroot/archive/2013/03/18/2965349.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c749da8138ec62b7b747bec3f215cb9e/" rel="bookmark">
			如何设置npm包管理工具的下载代理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I solved this problem this way:
I run this command: npm config set strict-ssl falseThen set npm to run with http, instead of https: npm config set registry "http://registry.npmjs.org/"Then I install packages using this syntax: npm --proxy http://username:password@cacheaddress.com.br:80 install packagename http://howtonode.org
转载于:https://www.cnblogs.com/vyvi/archive/2013/03/13/2958522.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15517b9620b515ffa20d67a021d83306/" rel="bookmark">
			Linunx的sleep,usleep,select,nonasleep对比与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 时钟换算:
1秒(s) = 1000 毫秒(ms) = 1,000,000 微秒(μs) = 1,000,000,000 纳秒(ns) = 1,000,000,000,000 皮秒(ps)
程序挂起主要有以下几种:
sleep, usleep, select, pselect, nanosleep;
它们的精度不同，在不同的应用场景下需要不同的函数；
一、用法 1.1 函数名: sleep 头文件:
#include &lt;unistd.h&gt; // 在gcc编译器中，使用的头文件因gcc版本的不同而不同
功 能: 执行挂起指定的秒数
语 法: unsigned sleep(unsigned seconds);
示例:
#include&lt;stdio.h&gt;
int main()
{
int a;
a=1;
printf("hello");
sleep(a); printf("world"); return 0;
}
1.2 函数名: usleep 功 能: usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）；
头文件: #include &lt;unistd.h&gt;
语 法:
void usleep(int micro_seconds);
返回值: 无
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15517b9620b515ffa20d67a021d83306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad7dd8e4ad55587fd7d3eb6fbd0fc15/" rel="bookmark">
			rsyslog - filter by program name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 有些系统软件如Nagios, Ganglia将错误日志通过syslog写到了/var/log/messages中了。 2. 好处： 可以统一进行查看系统中出了什么问题。坏处： 当错误信息太多时，各种信息交错在一起，难于查看。 3. syslog有一个过滤功能，可以根据过滤条件，将各种不同的日志分离到不同的文件中。 4. 如果要根据不同的应用来分离日志，需要使用rsyslog. 5. 举例如下，在/etc/rsyslog.conf的文件开头加上如下几行，可以将nagios和gmetad的日志分离出来： :programname,contains,"nagios" /var/log/messages.nagios &amp; ~ :programname,contains,"gmetad" /var/log/messages.gmetad &amp; ~ 6. 不知道什么原因，有时候用programname这个属性不是很管用，可以尝试使用syslogtag：
:syslogtag,contains,"nagios" /var/log/messages.nagios &amp; ~ :syslogtag,contains,"gmetad" /var/log/messages.gmetad &amp; ~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aee0979fd29c10c32b4da05058d627fe/" rel="bookmark">
			httpclient返回值中文乱码问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天，在抓取某网站的信息时(http://www.99sj.com/Price/Price/Default.aspx)，第一次碰到了这种应用下的乱码问题。于是上网查了一下，提供的解决办法大致有两种： １&gt;　private static final String CONTENT_CHARSET = "GBK"; httpClient.getParams().setContentCharset("UTF-8"); or httpClient.getParams().setParameter(HttpMethodParams.HTTP_CONTENT_CHARSET,ＣONTENT_CHARSET); 2&gt;　private static final String CONTENTTYPE = " text/html;charset=GBK"; getMethod.setRequestHeader("Content-Type", CONTENTTYPE); 测试了，没有任何效果（换成UTF-8也不行）。也用了String result = newString(pageSrc.getBytes("UTF-8"),"GBK")，依然无效。 在焦头烂额时想到了以前在学校时经常用的一句话：找问题要会追根溯源。仔细想想，字符串里面的文本内容也是通过文件流获取的，既然转换字符串字符编码不起作用，那可以设置文件流的默认编码吗？查了jdk，是可行的。 private static final String CHARSET = "UTF-8"; InputStream ins = getMethod.getResponseBodyAsStream(); //按指定的字符集构建文件流 BufferedReader br = new BufferedReader(newInputStreamReader(ins,CHARSET)); StringBuffer sbf = new StringBuffer(); String line = null; while ((line = br.readLine()) != null) { sbf.append(line); } br.close(); 问题解决，^_^。这里的CHARSET要根据实际情况设置
http://blog.sina.com.cn/s/blog_a1b205bb0101aer6.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe03e11f3f57e1ef65c90e9c4472561/" rel="bookmark">
			数据库模糊搜索时，关键字中处理特殊字符（%,_）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库模糊搜索时，都知道应该用通配符%号来模糊匹配。如：select *from table where content like '%key%'。但当关键字key中也包含有%号时，应该怎么办？
数据库中有关键字：escape就是用来转换的。使用escape关键字定义转义符时，当转义符置于通配符之前时，该通配符就解释为普通字符。用法：ESCAPE 'escape_character' 其允许在字符串中搜索通配符而不将其作为通配符使用。'escape_character'通常用'/'或'\'做为转义符，其它如‘!'等也可以做为转义符。
示例：
select *from table where content like '%/%%' escape '/'
/为转义字符，第二个%为普通字符，第一、三个%为通配符。
select *from table where content like '%/%//%' escape '/'
/为转义字符，第二个%为普通字符，第一、三个%为通配符，第二个/为转义字符，第三个/为普通字符。
----------转载http://www.cnblogs.com/joinclear/archive/2013/02/25/2932842.html
if(StringUtils.isNotEmpty(param.getCode())){ hql.append("and node.code like ? escape ? "); params.put(String.valueOf(params.size()), "%" + Common.getSqlLikeEscapeStr(param.getCode()) + "%"); params.put(String.valueOf(params.size()), Constants.CON_SQL_LIKE_ESCAPE); } public static String getSqlLikeEscapeStr(String str){ str = str.replaceAll("/", "//"); str = str.replaceAll("%", "/%"); str = str.replaceAll("_", "/_"); return str; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1dbec9aa1c555e91548890c888d1fc0/" rel="bookmark">
			MySQL中varchar最大长度是多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被问到一个问题：MySQL中varchar最大长度是多少？这不是一个固定的数字。本文简要说明一下限制规则。
1、限制规则
字段的限制在字段定义的时候有以下规则：
a) 存储限制
varchar 字段是将实际内容单独存储在聚簇索引之外，内容开头用1到2个字节表示实际长度（长度超过255时需要2个字节），因此最大长度不能超过65535。
b) 编码长度限制
字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766;
字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。
若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。
c) 行长度限制
导致实际应用中varchar长度限制的是一个行定义的长度。 MySQL要求一个行的定义长度不能超过65535。若定义的表长度超过这个值，则提示
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs。
2、计算例子
举两个例说明一下实际长度的计算。
a) 若一个表只有一个varchar类型，如定义为
create table t4(c varchar(N)) charset=gbk;
则此处N的最大值为(65535-1-2)/2= 32766。
减1的原因是实际行存储从第二个字节开始’;
减2的原因是varchar头部的2个字节表示长度;
除2的原因是字符编码是gbk。
b) 若一个表定义为
create table t4(c int, c2 char(30), c3 varchar(N)) charset=utf8;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1dbec9aa1c555e91548890c888d1fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c3e4d6d74187974349978e0c49ee16/" rel="bookmark">
			varchar和Nvarchar区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示
如果还为了这个纠结，就直接看看后面的解说，做决定吧。
一般如果用到中文或者其它特殊字符，我就会使用n开头的类型，否则的话直接使用var开头的。 sql server中的varchar和Nvarchar有什么区别？
答： varchar(n) 长度为 n 个字节的可变长度且非 Unicode 的字符数据。n 必须是一个介于 1 和 8,000 之间的数值。存储大小为输入数据的字节的实际长度，而不是 n 个字节。 nvarchar(n) 包含 n 个字符的可变长度 Unicode 字符数据。n 的值必须介于 1 与 4,000 之间。字节的存储大小是所输入字符个数的两倍。 两字段分别有字段值：我和coffee
那么varchar字段占2×2+6=10个字节的存储空间，而nvarchar字段占8×2=16个字节的存储空间。
如字段值只是英文可选择varchar，而字段值存在较多的双字节（中文、韩文等）字符时用nvarchar char varchar nvarchar区别 联机帮助上的：
char(n) 定长 索引效率高 程序里面使用trim去除多余的空白 n 必须是一个介于 1 和 8,000 之间的数值,存储大小为 n 个字节 varchar(n) 变长 效率没char高 灵活 n 必须是一个介于 1 和 8,000 之间的数值。存储大小为输入数据的字节的实际长度，而不是 n 个字节 text(n) 变长 非Unicode数据 nchar(n) 定长 处理unicode数据类型(所有的字符使用两个字节表示) n 的值必须介于 1 与 4,000 之间。存储大小为 n 字节的两倍 nvarchar(n) 变长 处理unicode数据类型(所有的字符使用两个字节表示) n 的值必须介于 1 与 4,000 之间。字节的存储大小是所输入字符个数的两倍。所输入的数据字符长度可以为零 ntext(n) 变长 处理unicode数据类型(所有的字符使用两个字节表示) 出处： http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c3e4d6d74187974349978e0c49ee16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86eda8e7cc59b7b51828fbc4ce64400a/" rel="bookmark">
			POJ2031--Building a Space Station--最小生成树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description
You are a member of the space station engineering team, and are assigned a task in the construction process of the station. You are expected to write a computer program to complete the task. The space station is made up with a number of units, called cells. All cells are sphere-shaped, but their sizes are not necessarily uniform. Each cell is fixed at its predetermined position shortly after the station is successfully put into its orbit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86eda8e7cc59b7b51828fbc4ce64400a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471c2098f59bfbfa7e8bbfb4a4931034/" rel="bookmark">
			Konig定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Konig定理：最少覆盖数==最大匹配数
例题：
有两台机器A和B及N个需要运行的任务，每台机器有M种不同的模式，而每个任务i都恰好在一台机器上运行，如果他在机器A上运行，则机器A需要设置为模式ai,如果他在机器B上运行，则机器B需要设置为模式bi，每台机器上的任务可以按照任意顺序执行，但是每台机器每转换一次模式需要重新启动一次，请合理为每个任务安排一台机器并合理安排顺序，使得机器重启次数尽量少。
分析：
本题的建模需要一点技巧。显然，机器重启次数是两台机器需要使用的不同的模式个数，但是如果把每个任务看成一个X节点，把每台机器的每个模式看成一个Y节点，则此模型没有任何意义。应该把每个任务看成一条边，即A机器的每个模式看成一个X节点，B机器的每个模式看成一个Y节点，任务i为边（a,b),本题即为求最少的点让每条边都至少和其中的一个点关联。
根据Koing定理，最少覆盖数==最大匹配数M。证明如下：
设最少覆盖数为m.
1.M&gt;=m.反证法证明：如果存在M&lt;m.也就是说存在一个任务（一条边）aibi.没有边和ai关联，同时没有边和bi关联。显然这两个未覆盖点可以相连，显然此M并非最大匹配。
2.在1的证明下，m==M.考虑最大匹配的这M条边，由于他们两两个无公共点，因此至少需要M个点才能把他们覆盖。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad559fc3d4428427760b636d004a0fe/" rel="bookmark">
			用net use 发生系统错误1219
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 察看客户端服务项发现：computer browser 服务和　netlogin 服务停止并且无法启动，系统提示：这两个服务是无用的服务，启动后又被停止。 此种情况只出现在客户端是XP的机器上，其它系统都能正常访问。 临时解决办法： 1、net use \\服务器ip\ipc$ 服务器密码　/user:administrator(注释：此命令是建立ipc空连接) XP运行完提示：发生系统错误 1219，不允许一个用户使用一个以上用户名与一个服务器或共享资源的多重连接。中断与此服务器 或共享资源的所有连接，然后再试一次... 然后运行：　2、　net use 提示：C:\Documents and Settings\Administrator&gt;net use(注释：显示已经建立的连接) 会记录新的网络连接。 状态 本地 远程 网络 ------------------------------------------------------------------------------ OK \\192.168.200.2\ipc$ Microsoft Windows Network 命令成功完成。 ……显示连接已经建立，但是但是为什么不能访问呢?……问题正在解决中……. 3、net use \\服务器ip\ipc$ /del 4、服务器恢复正常访问 5、重新启动后故障依旧 如此发现：正常访问服务器建立的连接，并不能实现真正的访问。此时不能建立空连接，但是只要能建立一个空连接，服务器即恢复正常访问。所以写一个批处理文件放到启动项里，故障排除。 批处理文件内容： echo net use \\服务器\ipc$ /del net use \\服务器\ipc$ 密码　/user:administrator echo 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e03078d723545225224fb024efc91af/" rel="bookmark">
			XSLT &lt;xsl:if&gt; 元素 判断属性等于某个值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;xsl:if test="./@clientType = 'companyInfo'"&gt;text&lt;/xsl:if&gt;
./@clientType 表示取当前节点的clientType属性。注意：判断等于用“=”号，判断大于用“&gt;”号，判断小于则用"&amp;lt;"。
欢迎加入我的QQ交流群425783133
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878af25f12b3f02fd0dc4d306f1ac49f/" rel="bookmark">
			FileStream,StreamWriter,StreamReader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FileStream对象表示在磁盘或网络路径上指向文件的流。这个类提供了在文件中读写字节的方法，但经常使用StreamReader或StreamWriter执行这些功能。这是因为FileStream类操作的是字节和字节数组，而Stream类操作的是字符数据。字符数据易于使用，但是有些操作，比如随机文件访问(访问文件中间某点的数据)，就必须由FileStream对象执行，稍后对此进行介绍。
还有几种方法可以创建FileStream对象。构造函数具有许多不同的重载版本，最简单的构造函数仅仅带有两个参数，即文件名和FileMode枚举值。
FileStream aFile = new FileStream(filename, FileMode.Member); FileMode枚举有几个成员，规定了如何打开或创建文件。稍后介绍这些枚举成员。另一个常用的构造函数如下： FileStream aFile = new FileStream(filename, FileMode.Member, FileAccess. Member); 第三个参数是FileAccess枚举的一个成员，它指定了流的作用。FileAccess枚举的成员如表22-6所示。
表 22-6
成 员
说 明
Read
打开文件，用于只读
Write
打开文件，用于只写
ReadWrite
打开文件，用于读写
对文件进行不是FileAccess枚举成员指定的操作会导致抛出异常。此属性的作用是，基于用户的身份验证级别改变用户对文件的访问权限。
在FileStream构造函数不使用FileAccess枚举参数的版本中，使用默认值FileAccess. ReadWrite。
FileMode枚举成员如表22-7所示。使用每个值会发生什么，取决于指定的文件名是否表示已有的文件。注意这个表中的项表示创建流时该流指向文件中的位置，下一节将详细讨论这个主题。除非特别说明，否则流就指向文件的开头。
表 22-7
成 员
文 件 存 在
文件不存在
Append
打开文件，流指向文件的末尾，只能与枚举FileAccess.Write联合使用
创建一个新文件。只能与枚举FileAccess.Write联合使用 Create
删除该文件，然后创建新文件
创建新文件 CreateNew
抛出异常
创建新文件 Open
打开现有的文件，流指向文件的开头
抛出异常
OpenOrCreate
打开文件，流指向文件的开头
创建新文件
Truncate
打开现有文件，清除其内容。流指向文件的开头，保留文件的初始创建日期
抛出异常
File和FileInfo类都提供了OpenRead()和OpenWrite()方法，更易于创建FileStream对象。前者打开了只读访问的文件，后者只允许写入文件。这些都提供了快捷方式，因此不必以FileStream构造函数的参数形式提供前面所有的信息。例如，下面的代码行打开了用于只读访问的Data.txt文件：
FileStream aFile = File.OpenRead("Data.txt"); 注意下面的代码执行同样的功能： FileInfo aFileInfo = new FileInfo("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878af25f12b3f02fd0dc4d306f1ac49f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f86115c0bf685631a66e2e8c696cf6b3/" rel="bookmark">
			Chr表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chr对应Ascii码：
Chr("0") Nul Chr("1") Chr("2") Chr("3") Chr("4") Chr("5") Chr("6") Chr("7") Chr("8") 退格 Chr("9") Tab Chr("10") 换行 Chr("11") （一个很特殊的字符） Chr("12") 换页 Chr("13") 回车 Chr("14") Chr("15") Chr("16") Chr("17") Chr("18") Chr("19") Chr("20") Chr("21") Chr("22") 粘贴 Chr("23") Chr("24") Chr("25") Chr("26") 撤销 Chr("27") Esc Chr("28") 文件分割符 Chr("29") 分组符 Chr("30") 记录分离符 Chr("31") 单元分隔符 Chr("32") 空格 SPACE Chr("33") ! Chr("34") " Chr("35") # Chr("36") $ Chr("37") % Chr("38") &amp; Chr("39") ' Chr("40") ( Chr("41") ) Chr("42") * Chr("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f86115c0bf685631a66e2e8c696cf6b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca208623b99c9e452040f5d2053f7104/" rel="bookmark">
			笔记本&#43;显示器组建扩展屏幕分辨率问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我笔记本屏幕的最高分辨率是1366*768，外接显示器最高分辨率是1920*1080。但是将显示器连接上笔记本并且将显示器设置为扩展屏幕后，通过控制面板调节扩展屏幕的分辨率时只有两个选项：1280*768 和 800*600 实在是太蛋疼了，网上找不到解决方案。今晚觉得显示器颜色不太舒服，就调了一下，结果屏幕一闪，哎居然恢复正常，扩展屏幕的分辨率能够调到1920*1080了，看到被拉扁的图标和文字恢复正常，实在是太爽了。应该有人遇到这种烦恼，分享一下步骤（直接看看最后面的一张图在看步骤吧，免得浪费时间）：
1 右键单击选择“屏幕分辨率”（注意：我是windows 7 系统）
2 选择“高级设置”
3 选择“颜色管理”选项卡
4 单击“颜色管理”按钮会弹出“颜色管理”窗口
5 选择“高级”选项卡
6 单击”校准显示器“按钮
校准过程中会有 一个 cleartype 文本调谐器，这个估计才是真正起作用的过程：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2201d7763dcd47313a79076ae2c86544/" rel="bookmark">
			c#中操作xml(最简单的介绍)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单介绍
using System.Xml;
//初始化一个xml实例
XmlDocument xml=new XmlDocument();
//导入指定xml文件
xml.Load(path);
xml.Load(HttpContext.Current.Server.MapPath("~/file/bookstore.xml"));
//指定一个节点
XmlNode root=xml.SelectSingleNode("/root");
//获取节点下所有直接子节点
XmlNodeList childlist=root.ChildNodes;
//判断该节点下是否有子节点
root.HasChildNodes;
//获取同名同级节点集合
XmlNodeList nodelist=xml.SelectNodes("/Root/News");
//生成一个新节点
XmlElement node=xml.CreateElement("News");
//将节点加到指定节点下，作为其子节点
root.AppendChild(node);
//将节点加到指定节点下某个子节点前
root.InsertBefore(node,root.ChildeNodes[i]);
//为指定节点的新建属性并赋值
node.SetAttribute("id","11111");
//为指定节点添加子节点
root.AppendChild(node);
//获取指定节点的指定属性值
string id=node.Attributes["id"].Value;
//获取指定节点中的文本
string content=node.InnerText;
//保存XML文件
string path=Server.MapPath("~/file/bookstore.xml");
xml.Save(path);
//or use :xml.Save(HttpContext.Current.Server.MapPath("~/file/bookstore.xml")); 二、具体实例
在C#.net中如何操作XML
需要添加的命名空间：
using System.Xml;
定义几个公共对象：
XmlDocument xmldoc ;
XmlNode xmlnode ;
XmlElement xmlelem ;
1，创建到服务器同名目录下的xml文件：
方法一：
xmldoc = new XmlDocument ( ) ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2201d7763dcd47313a79076ae2c86544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e662eccb394ddb2bf30f3eca90ae513/" rel="bookmark">
			Firefox OS 架构简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		女神、壁虎和娃娃
Firefox OS 从架构上来讲具有了三个层面：
Gaia（盖亚，大地女神）：Firefox OS 的用户界面，包含了在开机之后所有用户能看到部分，比如锁屏、主屏幕、应用程序启动器、拨号器、短信、相机等等作为智能手机必须具备的。Gaia 完全使用 HTML、CSS 和 JavaScript 编写，使用成为标准的 Web API 的接口和底层设备关联。因此，Gaia 可以在任何实现了 Web API 的设备上运行，比如桌面浏览器。Firefox OS 上的第三方程序也是以类似的方式运行并与 Gaia 共存的。
Gecko（壁虎）：Firefox OS 的应用程序运行时环境，用 C++（不知道后期是否会转用Rust ）实现了 Web API，供包括 Gaia 在内的应用程序使用，同时保证 Web API 可以在 Firefox OS 的目标硬件平台上运行。于是乎 Gecko 包含了必要的网络层，图像层、布局管理和 JavaScript 虚拟机以及移植层。
Gonk（蛋形娃娃）：Firefox OS 的操作系统底层，也是 Gecko 的一个目标移植平台，包含 Linux 内核和用户态的硬件抽象层，这一部分和 Android 以及嵌入式 Linux 共享了很多组件和驱动，比如 bluez, libusb 等。说是一个目标移植平台，是由于 Gecko 抽象层在理论上也可以运行在 Android 或者桌面操作系统上，不过由于 Firefox OS 项目主导了 Gonk 开发，可以提供一些其他系统上不具备的接口给 Gecko 使用，比如完整的电话通讯层。
光、信号和起源
和绝大多数 Android 手机一样，预装 Firefox OS 的手机在开机后也会首先由极小化的 bootloader 实现最初的引导操作，然后链式引导更高级别更复杂的引导器，最终实现内核的加载。这个过程具体如何与设备制造商有关，相应的 bootloader 操作很有可能重用现在各个厂商在 Android 设备上所用的私有fastboot 协议实现。意味着只要适当调整 Firefox OS 所用的引导器，在 Android 手机上使用现有刷机工具刷入 Firefox OS 在技术上没有障碍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e662eccb394ddb2bf30f3eca90ae513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee967d8259d700c2fba48b3a5caffdab/" rel="bookmark">
			继承时显示调用父类的构造函数（浅）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ddeaf3bab251c928094bd3624d433fa/" rel="bookmark">
			override和 new（简单介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# override重写，是指对父类中的虚方法（标记virtual）或抽象方法（标记为abstract）进行重写，实现新的功能，它必须与父类方法的签名完全一致，而且与父类方法的可访问性也必须一致 new隐藏，是指在子类中重新定义一个签名与父类的方法相同的方法，这个方法可以不用new修饰，只是编译时会弹出一个警告信息：如果是有意隐藏，请使用关键字new。
using System; public class Test { public static void Main(String[] args){ A a=new B(); Console.Write(a.getVal()); // 输出:A 虽然实例是B，但是执行的却是A的方法 （new后，调用父类的方法） a=new C(); Console.Write(a.getVal()); // 输出:C 实例是C，而且C重写的A的方法，所以执行C的方法 （override后，调用子类方法） B b=new B(); Console.Write(b.getVal()); // 输出:B 只有定义和实例都是B，才执行B的方法 } } class A { // 要允许子类重写，方法必须标识为virtual 或 abstract public virtual String getVal(){ return "A"; } } class B : A { // 隐藏父类方法 用new标识，不标识时会出现编译警告，不影响使用 public new String getVal(){ return "B"; } } class C : A { // 重写方法 必须用override标识 public override String getVal(){ return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ddeaf3bab251c928094bd3624d433fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d169b7165ad3a501ab6eddd18465130/" rel="bookmark">
			是如何利用LoadRunner判断HTTP服务器的返回状态.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种方法是利用LR的内置函数web_get_int_property, 如下是一个简单的例子: Action.c { int HttpRetCode; web_url(”my_home”, “URL=http://my_home”, “TargetFrame=_TOP”, LAST); HttpRetCode = web_get_int_property(HTTP_INFO_RETURN_CODE); if (HttpRetCode == 200) lr_log_message(”The script. successfully accessed the My_home home page”); else lr_log_message(”The script. failed to access the My_home home page “); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a03168ea7fa6f9f9709467d5342ebed/" rel="bookmark">
			byte数据的常用操作函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/// &lt;summary&gt; /// 本类提供了对byte数据的常用操作函数 /// &lt;/summary&gt; public class ByteUtil { private static char[] HEX_CHARS = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}; private static byte[] BITS = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80}; /// &lt;summary&gt; /// 将字节数组转换为HEX形式的字符串, 使用指定的间隔符 /// &lt;/summary&gt; public static string ByteToHex(byte[] buf, string separator) { System.Text.StringBuilder sb = new System.Text.StringBuilder(); for(int i = 0;i &lt; buf.Length;i++) { if (i &gt; 0) { sb.Append(separator); } sb.Append(HEX_CHARS[buf[i] &gt;&gt; 4]).Append(HEX_CHARS[buf[i] &amp; 0x0F]); } return sb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a03168ea7fa6f9f9709467d5342ebed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1fcd7dc89f776cb1632a43c8095dd3a/" rel="bookmark">
			实用网址（永久更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 文学
国学论坛 http://bbs.guoxue.com
2 计算机相关
数学知识 http://williamstallings.com/StudentSupport.html
操作系统资源点 http://www.nondot.org/sabre/os/articles
操作系统开发入门教程 http://en.skelix.org/skelixos/
操作系统开发论坛 http://forum.osdev.org/index.php
国外x86汇编课程 http://www.cs.usfca.edu/~cruse/cs630f06/
NES http://nesdev.parodius.com
GTK+2.0开发资源 在http://www.gtkforums.com/viewtopic.php?f=11&amp;t=988
3 杂
六维空间 http://bt.neu6.edu.cn
未为不可论坛 www.vwill.cn
关于翻墙的一篇文章http://keepee.blog.sohu.com/154777865.html#
导出latex的公式为图片的方法http://blogold.chinaunix.net/u2/63591/showart_654153.html
latex常用数学符号http://zjw1777.blog.163.com/blog/static/47865129201032895850924/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d18b96a7c0e15d7486e509d72986d6/" rel="bookmark">
			关于利用xstl将xml转换成xml或html
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目上用到了xstl，看了几天小有收获。XSTL(extensiblestyling language transformation )：最主要的功能是将xml转换为html或其他格式的文件，其是一种格式制定工具。以下是个小例子，将xml转换成需要格式的xml，代码如下：
p1.xml 文件内容： &lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;list&gt;
&lt;lqx&gt;
&lt;name&gt;lqx&lt;/name&gt;
&lt;age&gt;20&lt;/age&gt;
&lt;borth&gt;2012-11-30 13:22:09.78 CST&lt;/borth&gt;
&lt;/lqx&gt;
&lt;lqx&gt;
&lt;name&gt;yl&lt;/name&gt;
&lt;/lqx&gt;
&lt;/list&gt;
d1.xstl内容 &lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:template match="/"&gt;
&lt;EMPS&gt;
&lt;EMP&gt;
&lt;xsl:for-each select="//lqx"&gt;
&lt;EMP__NAME&gt;&lt;xsl:value-of select="name"/&gt;&lt;/EMP__NAME&gt;
&lt;EMP__AGE&gt;&lt;xsl:value-of select="age"/&gt;&lt;/EMP__AGE&gt;
&lt;EMP__BORTH&gt;&lt;xsl:value-of select="borth"/&gt;&lt;/EMP__BORTH&gt;
&lt;/xsl:for-each&gt;
&lt;/EMP&gt;
&lt;/EMPS&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt; 需要用到的java程序如下 ： public void convert(){ StreamSource xml=new StreamSource(new File("d:/p1.xml"));//源文件
StreamSource xsl=new StreamSource(new File("d:/d1.xsl"));//xsl
StreamResult result=new StreamResult(new File("d:/h.xml"));//目标文件
TransformerFactory tFactoy=TransformerFactory.newInstance();
Transformer transformer=tFactoy.newTransformer(xsl);
transformer.transform(xml,result);
} 经过转换得到所需格式的xml，但很乱，全部连在一起，在网上查到用&lt;xsl:text&gt; &amp;#x0A;&lt;/xsl:text&gt;可在显示xml时达到换行的效果，所以改xstl如下：&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d18b96a7c0e15d7486e509d72986d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83729dff48e974f64e55dce178a5fe4/" rel="bookmark">
			ORA-06512 DBMS_LOB.LOADCLOBFROMFILE处理经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在执行一个用来返回CLOB对象的函数的时候，报ORA-06512错误，现在就把错误的原因及解决办法记录一下： create or replace function getClobDocument(filename in varchar2,charset in varchar2 default NULL) return CLOB deterministic is file bfile := bfilename('XMLDIR',filename); charContent CLOB := ' '; targetFile bfile; lang_ctx number := DBMS_LOB.default_lang_ctx; charset_id number := 0; src_offset number := 1 ; dst_offset number := 1 ; warning number; begin if charset is not null then charset_id := NLS_CHARSET_ID(charset); end if; targetFile := file; DBMS_LOB.fileopen(targetFile, DBMS_LOB.file_readonly); DBMS_LOB.LOADCLOBFROMFILE(charContent, targetFile,DBMS_LOB.getLength(targetFile), src_offset, dst_offset,charset_id, lang_ctx,warning); DBMS_LOB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a83729dff48e974f64e55dce178a5fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa631120beb1dceae65bb475cfc6a02e/" rel="bookmark">
			python学习笔记之三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中的装饰函数（面向切面编程AOP）
AOP:　主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。
1、装饰函数简化了函数的调用方式，在没有有装饰函数前，这类函数的调用有点类似于数学中复合函数的调用，如
设y=f(u），u=g(x），f(u)=f[g(x)]
使用装饰器的例子：
def foo(func):
print 'i am a decoration'
return func
@foo
def foo1():
print 'foo'
2、装饰器可以增加计时逻辑来检测性能
例子（摘自于：http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html）
#-*- coding: UTF-8 -*- import time def foo(): print 'in foo()' # 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法 def timeit(func): # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装 def wrapper(): start = time.clock() func() end =time.clock() print 'used:', end - start # 将包装后的函数返回 return wrapper foo = timeit(foo) foo() 注释：其中func是一个全局变量，自己认为在用到装饰函数时，这个func是默认的参数，代表了函数的参数也是一个函数 eg： &gt;&gt;&gt; def foo(x): ... print 'i am a decoration' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa631120beb1dceae65bb475cfc6a02e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695535c02842243a48b4c5540a5c0cc6/" rel="bookmark">
			C#获取网页内容的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载http://www.cnblogs.com/ceachy/articles/CSharp_Retrive_Page_Document.html 搜索网络，发现C#通常有三种方法获取网页内容，使用WebClient、WebBrowser或者HttpWebRequest/HttpWebResponse。。。
方法一：使用WebClient （引用自：http://fbljava.blog.163.com/blog/static/265211742008712105145244/）
static void Main(string[] args)
{
try {
WebClient MyWebClient = new WebClient();
MyWebClient.Credentials = CredentialCache.DefaultCredentials;//获取或设置用于向Internet资源的请求进行身份验证的网络凭据
Byte[] pageData = MyWebClient.DownloadData(“http://www.163.com”); //从指定网站下载数据
string pageHtml = Encoding.Default.GetString(pageData); //如果获取网站页面采用的是GB2312，则使用这句 //string pageHtml = Encoding.UTF8.GetString(pageData); //如果获取网站页面采用的是UTF-8，则使用这句
Console.WriteLine(pageHtml);//在控制台输入获取的内容
using (StreamWriter sw = new StreamWriter("c:\\test\\ouput.html"))//将获取的内容写入文本
{
sw.Write(pageHtml);
}
Console.ReadLine(); //让控制台暂停,否则一闪而过了 }
catch(WebException webEx) {
Console.WriteLine(webEx.Message.ToString());
}
}
方法二：使用WebBrowser （引用自：http://topic.csdn.net/u/20091225/14/4ea221cd-4c1e-4931-a6db-1fd4ee7398ef.html）
WebBrowser web = new WebBrowser(); web.Navigate("http://www.xjflcp.com/ssc/"); web.DocumentCompleted += new WebBrowserDocumentCompletedEventHandler(web_DocumentCompleted); void web_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e) { WebBrowser web = (WebBrowser)sender; HtmlElementCollection ElementCollection = web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/695535c02842243a48b4c5540a5c0cc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014d17c164a6f7491865cb47def653c0/" rel="bookmark">
			ajax返回值传给js全局变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ajax返回值传给js全局变量 2011-03-13 10:14:01| 分类： js | 标签：ajax 全局变量 async 值传 js |字号大中小订阅
程序代码如下： 默认使用ajax时，async选项为true,也就是异部请求，这种情况下， 异步请求不能将返回值传给全局变量 将async设为同步请求，就可以了，也就是async=false; &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;script src="http://blog.163.com/qzw881130@126/blog/./jquery-1.5.1.min.js" language="javascript"&gt; &lt;/script&gt; &lt;script language="javascript"&gt; var t="" function request_ajax(){ $.ajax({ async:false, //使用同步请求，因为异步请求不能将返回值传给全局变量； type: "POST", url: "server.php", data: "", success: function(msg){ t=msg; } }); $("#txt").val(t); } &lt;/script&gt; &lt;body&gt; &lt;input type="text" value="" id="txt" /&gt; &lt;button οnclick="request_ajax()"&gt;ajax返回&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 转载于:https://www.cnblogs.com/tabcdt/archive/2012/11/19/2777322.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06e1c09fd7d3b1137d094b4613347f8/" rel="bookmark">
			使用VLC搭建视频直播服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 去年我们信息之夜我们进行过视频直播服务，当时我们使用了WMS（Windows Media Server）实现了这个服务，但是编码是微软的WMV，因而像iPhone/Android这样的智能手机无法观看，今天我给大家带来一种更简便的实现方式，并帮助所有平台用户都可以观看。
首先介绍一下，今天我们的工具VLC Player。
VLC主页：http://www.videolan.org VLC is a free and open source cross-platform multimedia player and framework that plays most multimedia files as well as DVD, Audio CD, VCD, and various streaming protocols.
VLC不仅仅是个播放器，也可以作为流媒体服务器使用。这个网上有相关的资料，我就不多说了。
声明下本文用的VLC版本：2.0.3
服务端操作
打开“媒体——流”选项，如图所示：
点击“捕获设备（D）”选项卡，选择“捕获模式”——“DirectShow”，“适配设备名称”——“Integrated Webcam”（或者你的摄像头、摄像机），“音频设备名称”——“内置式麦克风（IDT High Definition）”（或者是你的外置麦克风），然后点击“串流”按钮。
点击“下一个”后，在“目标设置”界面选择“HTTP”，然后点击添加按钮
填上目标ip地址，并在“转码选项”中选择相应的编码类型
客户端操作
点击“媒体——打开网络串流”，在弹出的框中输入“http://127.0.0.1:8080/xxzy”，点击“播放”按钮即可。
命令行操作方式
服务端：
vlc :sout=#transcode{vcodec=h264,vb=800,scale=1,acodec=mpga,ab=128,channels=2,samplerate=44100}:http{mux=ts,dst=:8080/xxzy} :sout-keep 客户端 vlc http://127.0.0.1:8080/xxzy VLC除了可以使用HTTP协议发布，还可以使用RTP、RTSP、UDP发布，大家可以自己尝试。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa0c799c859bfd08812ad983d5d0267/" rel="bookmark">
			hdu 4347 【KD-TREE】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KD-TREE
#include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N=55555,K=5; const int inf=0x3f3f3f3f; #define sqr(x) (x)*(x) int k,n,idx; //k为维数,n为点数 struct point { int x[K]; bool operator &lt; (const point &amp;u) const { return x[idx]&lt;u.x[idx]; } }po[N]; typedef pair&lt;double,point&gt;tp; priority_queue&lt;tp&gt;nq; struct kdTree { point pt[N&lt;&lt;2]; int son[N&lt;&lt;2]; void build(int l,int r,int rt=1,int dep=0) { if(l&gt;r) return; son[rt]=r-l; son[rt*2]=son[rt*2+1]=-1; idx=dep%k; int mid=(l+r)/2; nth_element(po+l,po+mid,po+r+1); pt[rt]=po[mid]; build(l,mid-1,rt*2,dep+1); build(mid+1,r,rt*2+1,dep+1); } void query(point p,int m,int rt=1,int dep=0) { if(son[rt]==-1) return; tp nd(0,pt[rt]); for(int i=0;i&lt;k;i++) nd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fa0c799c859bfd08812ad983d5d0267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3356ea02c35a0bbf706ccf2b79a068f/" rel="bookmark">
			xss之用户提交脚本攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个低级的防范：
对用户提交的内容进行html.Encode()处理，就是html编码
比如，用户在提交评论区，故意提交一段JS代码
&lt;script&gt;alert("你的QQ号码中奖了，欢迎拨打1008611231领奖")&lt;/script&gt;
那么评论在加载页面加载的时候就会弹出这个消息对话框
如何阻住用户提交这样的脚本，就可以使用Html编码HttpUtility.HtmlEncode(s),这样就可以把s里面的"&lt;","&gt;"等转化为&amp;lt,&amp;gt,这样就不会在把&lt;script&gt;当作脚本标签了。
浏览器会自动解析成正常显示内容，这样就显示出你提交的原内容了。&lt;script&gt;alert("你的QQ号码中奖了，欢迎拨打1008611231领奖")&lt;/script&gt;不会弹出，而是显示原样了。
当然，ASP.NET已经自动对这些脚本攻击做了防范，在页面顶端page中默认是ValidateRequest="ture",可以防范类似的脚本攻击，如果你要做一个类似技术论坛需要可以提交HTML代码的地方关闭它就可以了ValidateRequest="false".
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f2b73b3400c7484eb428f77eaaf7693/" rel="bookmark">
			asp.net cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是关于asp.net中cookie的一些相关用法
一、没有子健写入cookie
1、（写）
Response.Cookies["username"].value="xiaomengjie";//设置cookie的值
Response.Cookies["username"].Expires=DateTime.Now.AddDays(1); //设置cookie的过期时间
（读）
Request.Cookies["username"].Value;
2、（写）
HttpCookie mycookie = new HttpCookie("secondcookie");//创建一个cookie
mycookie.Value = "chengshubo";//给cookie添加值
mycookie.Expires = DateTime.Now.AddDays(1);//给cookie设置过期时间
Response.AppendCookie(mycookie);//把这个cookie添加到response的cookies集合中
（读）
Request.Cookies["secondcookie"].Value;
二、带子健的写入cookie
1、（写）
HttpCookie cookie = new HttpCookie("people"); //创建一个cookie
cookie["cheng"] = "chengshubo"; //给cookie添加子健
cookie["xiao"] = "xiaomengjie";
cookie["ta"] = "tamen";
cookie.Expires = DateTime.Now.AddDays(1); //给cookie设置过期时间
Response.Cookies.Add(cookie); //把这个cookie添加到response的cookies集合中
（读）
if (Request.Cookies["people"] != null)
｛
Request.Cookies["people"]["cheng"];
Request.Cookies["people"]["xiao"];
Request.Cookies["people"]["ta"];
｝
HttpCookie peoplecookies = Request.Cookies["people"];
if (peoplecookies != null)
{
Response.Write("子健ta" + peoplecookies["ta"]);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f2b73b3400c7484eb428f77eaaf7693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60896c1a5166daa049673afb2bee0ce6/" rel="bookmark">
			asp.net viewstate原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于http协议是无状态性的
客户端浏览器在与服务器端进行交互的时候，客户端向服务器端发送请求，服务器响应并处理请求，但由于http无状态性，所以服务器端并不知道上次给了客户端浏览器什么，所以客户端浏览器需要“记住”上次服务器端给予的值（如：input表单元素就是“记忆”到value中，而对于其他的值就要放到隐藏字段中，比如viewstate）,下次客户端浏览器再提交请求给服务器的时候（如：请在我原先的宽度基础上再增加10，就要把上次存到隐藏字段中的中再提交给服务器，让服务器“想起”上次给予客户端的值，并再此基础上增加10）。
如果要知道上一次的状态，一个方法是在对浏览器响应结束之前将状态信息保存到页面表单中，下次页面再向服务器发出请求的时候带上这些状态信息，这样服务器就能根据这些状态信息还原上次的状态了，类似于去看病时的病例本。
但是，状态信息保存到隐藏字段中有缺点：加大网站的流量，降低了访问的速度，机密数据保存到表单中会有数据欺骗等安全性问题。
下面举个例子：
Label文本值的自增,和TextBox值的自增，在这两个控件中值的自增就提现出来viewstate的作用
很简单的点击按钮加1的代码
我们查看源文件，发现html源文件里面有个hidden 元素，它的name 属性是“__VIEWSTATE,这里面就是一个viewstate的隐藏元素，里面使用序列化算法将隐藏内容存放到一个字符串中，我们使用ViewStateDecoder工具查看这个viewstate字符串，发现它存储的是label的值，而没有textbox的值
当我们禁用了viewstate之后（enableviewstate="false"），我们发现，label的自增失败了，而textbox的自增不受任何影响，这说明，label需要将值存放到viewstate中，而textbox不需要将值存放到viewstate中。
就想上面我们所说的，viewstate是存储非表单域，非value值的容器，由于textbox解析成Html后就是一个input type=“text” value="",它是有value属性的，所以它的值存放到了value中，不需要用到viewstate 而label解析成html后它实际上是一个span 标签，是没有value属性来给它存放值的，所以它需要使用viewstate来存放它的值，在上述自增的例子中，label需要使用viewstate记住上次服务器返回给它的值，好让下次提交请求给服务器的时候，服务器能够“记忆”起它的值，然后再它的基础上+1，
当然，即使是textbox(input)也只有存放到value中，才能够让服务器“记起”，要传递其它值，比如宽度，大小等，这也需要使用viewstate了。
在讲解viewstate原理中，input（textbox）版本值的自增和div(label)版本值的自增，能很好的阐述这个道理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a53a701685951f700e1b835667fea1/" rel="bookmark">
			c#中的@符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@符号的意思是说，告诉编译器，这里面的字符不需要转义
通常来说，在字符串里面的特殊符号比如 ",\ 等都要转义
比如使用“\”时，有这么一个字符串
c:\Document\1.aspx在定义的时候就要这样写string path="c:\\Document\\1.aspx"，只有这样定义才可以正常识别，否则单个“\”号会和后面的字符成转义符，如果恰好是无法识别的转义，那么就会抛出异常
而我们使用@就告诉编译器，这里我不需要转义，应该这样定义：
string path=@"c:\Document\1.aspx", 原先该怎定定义这里面就怎么定义。
在就是当一个字符串很长有换行的时候， 如有常量中有换行符时， 在字符串前添加一个@就可以解决了。
当然还有其他含义，这里不一一指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290453e9f4e671250e958693ace4f3f7/" rel="bookmark">
			H2 数据库引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中有用H2做嵌入式数据库 感觉很不错像大家介绍一下
H2特点:
非常快的，开放的源代码，JDBC API 嵌入式和服务器模式，内存数据库， 基于浏览器的控制台应用程序 占地面积小：约1 MB jar文件的大小 需求 要运行该数据库，软件协议栈是众所周知的工作。其他软件最有可能也可以工作，但还没有测试一样多。
数据库引擎 Windows XP或Vista，Mac OS X中，或Linux Sun的JDK 1.5或更高版本（使用了Retroweaver转换为JDK 1.4应该工作，但没有定期测试） 推荐的Windows文件系统：NTFS（FAT32只支持到4 GB的文件） H2控制台 Mozilla Firefox浏览器 支持的平台 这个数据库是用Java编写的，它可以运行在许多不同的平台上。它与Java 1.5和1.6进行测试，但也可以使用GCJ编译为本地代码。源代码不使用的Java 1.6的功能。目前，该数据库的开发和测试Windows XP和Mac OS X上使用Sun JDK 1.6，但它也可以在许多其他的操作系统，并使用其他的Java运行时环境。支持所有主要的操作系统（Windows XP中，Windows Vista中，Windows 7中，MAC OS，Ubuntu的，...）。
安装软件 要安装该软件，运行安装程序，或将其解压缩到您选择的目录。 目录结构 安装完成后，你应该得到如下的目录结构： 目录内容binJAR文件和批处理文件docs文档docs/htmlHTML页面docs/javadocJavadoc文件ext外部的依赖关系（在编译时下载）service作为Windows服务运行数据库的工具src源文件src/docsrc文档来源src/installer安装，外壳，并释放构建脚本src/main数据库引擎的源代码src/test测试源代码src/tools 添加数据库驱动程序 要注册的JDBC驱动程序（支持MySQL，PostgreSQL，HSQLDB，...），添加的jar文件名的环境变量 H2DRIVERS 或 CLASSPATH。例：添加HSQLDB JDBC驱动程序（Windows）中C:\Programs\hsqldb\lib\hsqldb.jar设置环境变量 H2DRIVERS 对 C:\Programs\hsqldb\lib\hsqldb.jar。 可以设置多个驱动程序条目需要分开 ; （Windows）或 :（其他操作系统）。支持的路径名中的空格。这些设置必须没有被引用。
使用H2控制台 H2控制台应用程序有三个主要的面板顶部的工具栏上，在左边的树，面板右侧的查询/结果。在左边列出的数据库对象（例如表）。在查询面板，并点击[运行]，输入一个SQL命令。结果出现下面的命令。
将表名或列名 要插入到脚本中的表名和列名，单击树中的项目。如果你点击了一个表，而查询是空的，然后SELECT * FROM ...被添加。键入查询时，所使用的表，在树中展开。例如，如果您键入SELECT * FROM TEST T WHERE T. 然后对表TEST扩大。 断开并停止应用程序 要登录的数据库，在工具栏面板中单击[断开]。然而，服务器仍然在运行，随时准备接受新的会话。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/290453e9f4e671250e958693ace4f3f7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/273/">«</a>
	<span class="pagination__item pagination__item--current">274/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/275/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>