<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e8ecc3522fb535b2f5d15683243850/" rel="bookmark">
			【Linux碎知识点4】Linux自带的crontab定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux定时任务crontab（1）检查系统是否安装crontab（2）启停命令（3）系统定时调度和用户定时调度（4）crontab格式（5）用户定时常用命令（6）注意事项（7）经典案例 Linux定时任务crontab crontab的服务进程名为crond，英文意为周期任务。顾名思义，crontab在Linux主要用于周期定时任务管理。类似crontab的工具还有at和anacrontab，但具体使用场景不同。
允许用户提交、编辑或删除相应的作业。每一个用户都可以有一个crontab文件来保存调度信息。系统管理员可以通过==/etc/cron.deny== 和 /etc/cron.allow这两个文件来禁止或允许用户拥有自己的crontab文件。
当系统中有 /etc/cron.allow 文件时，只有写入此文件的用户可以使用 crontab 命令，没有写入的用户不能使用 crontab 命令。同样，如果有此文件，/etc/cron.deny 文件会被忽略，因为 /etc/cron.allow 文件的优先级更高。当系统中只有 /etc/cron.deny 文件时，写入此文件的用户不能使用 crontab 命令，没有写入文件的用户可以使用 crontab 命令。这个规则基本和 at 命令的规则一致，同样是 /etc/cron.allow 文件比 /etc/cron.deny 文件的优先级高，Linux 系统中默认只有 /etc/cron.deny 文件。 cron 系统调度进程，通常安装操作系统后，默认已启动crond服务。 可以使用它在每天的非高峰负荷时间段运行作业，或在一周或一月中的不同时段运行。cron是系统主要的调度进程，可以在无需人工干预的情况下运行作业。root用户进程。
关于crontab的用途很多，如
定时系统检测；定时数据采集；定时日志备份；定时更新数据缓存；定时生成报表；
… 当然，更多使用场景是要以视具体情况而定了。毕竟是工具通常都是常用规则总结而成的产物。
（1）检查系统是否安装crontab 检验是否安装 [root@hadoop04 ~]# rpm -qa | grep crontab crontabs-1.11-6.20121102git.el7.noarch [root@hadoop04 ~]# rpm -qa | grep cron cronie-anacron-1.4.11-19.el7.x86_64 crontabs-1.11-6.20121102git.el7.noarch cronie-1.4.11-19.el7.x86_64 安装（没操作） yum -y install vixie-cron yum -y install crontabs （2）启停命令 Centos7：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32e8ecc3522fb535b2f5d15683243850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581edcf2170ba60c7e23772ce5976a5e/" rel="bookmark">
			信息技术-简答汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块一 计算机基础
1.信息的特征
信息的特征包括：普遍性、载体依附性、共享性、传递性、价值性、时效性、真伪性。
（1）普遍性：信息是不以人的意志为转移的客观存在。信息是无处不在，无时不有的。
（2）载体依附性：信息必须依附一定的载体才能够表现出来，为人们所接收。
（3）价值性：信息本身是有价值的，能够满足人们的需要，一是精神上的满足，二是可以促进物质、能量的生产和使用。
（4）时效性：信息具有生命周期，其价值随着时间的推移而变化，因此信息的效用以信息价值为前提，信息需要不断更新。
（5）共享性：信息本身可传递，具有扩散性，它可以被多个信息接收者接收并且多次使用。
（6）传递性：无论在空间还是时间上，信息都具有可传递性。
（7）真伪性：信息有真伪之分，而衡量信息准确与否的标准是信息客观反映现实世界事物的程度。
2.信息传递的过程
编码：编码是信息从一种形式或格式转换为另一种形式的过程，在此过程中规定了表示信息的信号，这个过程就是编码。
解码：是编码的逆过程，在此过程中将信号变成了信息。
信息传递的过程：信息在空间上的传递，即通信的过程，可以用下图表示：
信源→编码→信道→解码→信宿
同样，信息在时间上的传递，即信息存储的过程也需要编码。
3.信息技术的分类
信息技术（Information Technology，IT）指的是用来扩展人们信息器官功能、协助人们进行信息处理的一类技术。人们的信息器官主要有感觉器官、神经网络、思维器官及效能器官，它们分别用于获取信息、传递信息、处理并再生信息，以及使用信息使之产生实际效用。因此，基本的信息技术包括：
（1）感测技术：扩展感觉器官的功能，如传感器技术、感测信息处理技术；
（2）通信技术：扩展传导神经的功能，如物联网技术、无线局域网技术；
（3）计算机技术：扩展思维器官的功能，信息的处理和存储技术，如虚拟现实技术、云计算技术；
（4）控制技术：扩展效应器官的功能，信息的使用技术，如预测恢复技术、神经网络控制技术。
4.信息技术的发展5个阶段
信息技术的发展共经历了5次革命。
5次革命
标志
说明
第一次
语言的使用
语言的使用是人类从猿进化到人的重要标志。
第二次
文字的创造
文字的创造第一次打破时间、空间的限制。
第三次
印刷术的发明
我国是最早开始使用活字印刷术的。
第四次
电报、电话、广播电视的发明
电报、电话和广播电视的发明、电磁波的发现，实现了以金属导线上的电脉冲来传递信息以及通过电磁波来进行无线通信。
第五次
计算机和网络的普及应用
1946年，美国宾夕法尼亚大学研制的第一台电子计算机ENIAC诞生了；计算机联网实现了计算机的数据通信、数据共享。
5.信息技术的影响（积极、消极）
信息技术对社会发展、科技进步及个人生活与学习有两方面的影响。
（1）积极影响。可以促进社会发展，推动科技进步，改善人们的生活与学习等。
（2）消极影响。引起信息泛滥、信息污染、信息犯罪、危害人们的身心健康等。
6.信息获取的主要途径
信息获取：信息获取指围绕一定目标，在一定范围内，通过一定的技术手段和方式方法获得原始信息的活动和过程。信息获取的途径不是单一的，而是多渠道的。在实际生活中我们获取信息选择的方式要因地制宜、取长补短。在不同的时间，应选择不同的、适当的、高效的方法来获取信息。具体途径如下：
（1）利用人力直接获取信息
（2）利用设备来获取信息
（3）通过阅读书籍报刊获取信息
（4）从广播电视节目中获取信息
（5）通过光盘等电子出版物获取信息
（6）通过计算机网络获取信息
（7）通过遥感遥测获取信息
7.信息获取的过程
信息获取的过程是指，从实际问题出发，分析问题中所包含的信息，确定解决问题所需要的信息，进而确定这些信息的来源，然后选择适当的方法来获取信息，并将这些信息存储下来。具体过程如下：
（1）定位信息需求：定位信息需求即需要什么信息。表现在时间范围、地域范围和内容范围三个方面，即“获取什么时间什么地点的什么信息”。
（2）选择信息来源：确定信息需求后，接着就要确定哪里有这些信息，哪里方便寻找所要的信息。不同的信息来源需要相互结合、相互补充、共同发展。
（3）确定信息获取方法：由于信息来源的多样性，同样也决定了信息获取方法的多样性。常用的方法有：现场观察法、问卷调查法、访谈法、检索法（卡片式、计算机）阅读法和视听法等。
（4）保存信息：可以将信息整理、分类，也可以输入计算机进行保存。
（5）评价信息：评价信息是指以先前所确定的信息需求为依据，对获取的信息进行评价。这是有效获取信息非常重要的一个步骤，它直接涉及信息获取的效益。其实在获取信息的过程就一直在评价及挑选，即评价贯穿整个信息获取过程，如不符合需要就需要重新作调整。
（6）反馈信息：信息获取是一个循环往复的过程，当反馈信息后，又可根据新产生的信息需求重新定位信息。由于事物是发展的，因此信息需求也是发展的，人们对信息的获取也是没有止境的。
8.搜索引擎的分类及特点
搜索引擎可以看作是一个为人们提供信息检索服务的平台，按其工作方式可划分为：全文搜索引擎、目录搜索引擎和元搜索引擎。
种类
原理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/581edcf2170ba60c7e23772ce5976a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15237f662197152bfc960afb406a307d/" rel="bookmark">
			（STM32笔记5）ws2812驱动开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ws2812
需要开发的外设：ws2812
开发环境：MDK
开发板：stm32最小系统板
杜邦线无数
一、原理阐述 （一）这个ws2812有很多种，一个小灯、灯带，矩形像素屏等等。
这些都是DIN连接输入,DOUT连接输出，另外两个引脚是GNE和VCC
（二）数据传输原理：
第1个WS2812B灯珠接收到了第1个24bit的数据，做出响应（发光）；
第N个WS2812B灯珠接收到了第N个24bit的数据，
再收到第二个24bit的数据后，直接转发给第二个WS2812B灯珠，由第二个WS2812B灯珠做出响应；依次类推。
每次给一个灯一个24位的数据，顺序是GRB-green red bule
（三）数据编码
编码时序是低高电平占位大小来区分的，分别是高比低比例位 1/2--&gt;0 code
2/1--&gt;1 code
（四）定时器配置
根据WS2812的最大传输速率800kbps，设置定时器不分频和计数周期为89+1，这样下来波形的频率为 72M /（89+1） = 800K ，并且一个波形的周期为 1 / 800 = 1.25us
我用的最大是72M，不同板子不同配置，自行选择。
二、代码展示 main.h
#include "sys.h" #include "delay.h" #include "usart.h" #include "led.h" #include "ws2812b.h" uint8_t rgb0[][3] = {0,0,0}; uint8_t rgb1[212][3] = {{0,0,0},{10,0,0},{20,0,0},{30,0,0},{40,0,0},{50,0,0},{60,0,0},{70,0,0},{80,0,0},{90,0,0}, {100,0,0},{110,0,0},{120,0,0},{130,0,0},{140,0,0},{150,0,0},{160,0,0},{170,0,0},{180,0,0},{190,0,0}, {200,0,0},{210,0,0},{220,0,0},{230,0,0},{240,0,0},{250,0,0},{10,10,0},{20,20,0},{30,30,0}, {40,40,0},{50,50,0},{60,60,0},{70,70,0},{80,80,0},{90,90,0},{100,100,0},{110,110,0},{120,120,0},{130,130,0},{140,140,0}, {150,150,0},{160,160,0},{170,170,0},{180,180,0},{190,190,0},{200,200,0},{210,210,0},{220,220,0},{230,230,0},{240,240,0}, {250,250,0},{10,0,10},{20,0,20},{30,0,30},{40,0,40},{50,0,50},{60,0,60},{70,0,70},{80,0,80},{90,0,90},{100,0,100},{110,0,110},{120,0,120}, {130,0,130},{140,0,140},{150,0,150},{160,0,160},{170,0,170},{180,0,180},{190,0,190},{200,0,200},{210,0,210},{220,0,220}, {230,0,230},{240,0,240},{250,0,250},{0,10,10},{0,20,20},{0,30,30},{0,40,40},{0,50,50},{0,60,60},{0,70,70}, {0,80,80},{0,90,90},{0,100,100},{0,110,110},{0,120,120},{0,130,130},{0,140,140},{0,150,150},{0,160,160},{0,170,170}, {0,180,180},{0,190,190},{0,200,200},{0,210,210},{0,220,220},{0,230,230},{0,240,240},{0,250,250},{10,10,10},{30,30,30}, {90,90,90},{140,140,140},{200,200,200},{0,0,0},{10,0,0},{20,0,0},{30,0,0},{40,0,0},{50,0,0},{60,0,0},{70,0,0},{80,0,0},{90,0,0}, {100,0,0},{110,0,0},{120,0,0},{130,0,0},{140,0,0},{150,0,0},{160,0,0},{170,0,0},{180,0,0},{190,0,0}, {200,0,0},{210,0,0},{220,0,0},{230,0,0},{240,0,0},{250,0,0},{10,10,0},{20,20,0},{30,30,0}, {40,40,0},{50,50,0},{60,60,0},{70,70,0},{80,80,0},{90,90,0},{100,100,0},{110,110,0},{120,120,0},{130,130,0},{140,140,0}, {150,150,0},{160,160,0},{170,170,0},{180,180,0},{190,190,0},{200,200,0},{210,210,0},{220,220,0},{230,230,0},{240,240,0}, {250,250,0},{10,0,10},{20,0,20},{30,0,30},{40,0,40},{50,0,50},{60,0,60},{70,0,70},{80,0,80},{90,0,90},{100,0,100},{110,0,110},{120,0,120}, {130,0,130},{140,0,140},{150,0,150},{160,0,160},{170,0,170},{180,0,180},{190,0,190},{200,0,200},{210,0,210},{220,0,220}, {230,0,230},{240,0,240},{250,0,250},{0,10,10},{0,20,20},{0,30,30},{0,40,40},{0,50,50},{0,60,60},{0,70,70}, {0,80,80},{0,90,90},{0,100,100},{0,110,110},{0,120,120},{0,130,130},{0,140,140},{0,150,150},{0,160,160},{0,170,170}, {0,180,180},{0,190,190},{0,200,200},{0,210,210},{0,220,220},{0,230,230},{0,240,240},{0,250,250},{10,10,10},{30,30,30}, {90,90,90},{140,140,140},{200,200,200}}; uint8_t rgb2[109][3] = {{0,0,0},{0,5,0},{0,10,0},{0,15,0},{0,20,0},{0,25,0},{0,30,0},{0,35,0},{0,40,0},{0,45,0},{0,50,0},{0,55,0},{0,60,0},{0,65,0},{0,70,0},{0,75,0},{0,80,0},{0,85,0},{0,90,0}, {0,95,0},{0,100,0},{0,105,0},{0,110,0},{0,115,0},{0,120,0},{0,125,0},{0,130,0},{0,135,0},{0,140,0},{0,145,0},{0,150,0},{0,155,0},{0,160,0},{0,165,0},{0,170,0},{0,175,0},{0,180,0},{0,185,0},{0,190,0}, {0,195,0},{0,200,0},{0,205,0},{0,210,0},{0,215,0},{0,220,0},{0,225,0},{0,230,0},{0,235,0},{0,240,0},{0,245,0},{0,250,0},{0,255,0},{0,250,0},{0,245,0},{0,240,0},{0,235,0},{0,230,0}, {0,225,0},{0,220,0},{0,215,0},{0,210,0},{0,205,0},{0,200,0},{0,195,0},{0,190,0},{0,185,0},{0,180,0},{0,175,0},{0,170,0},{0,165,0},{0,160,0},{0,155,0},{0,150,0},{0,145,0},{0,140,0},{0,135,0},{0,130,0}, {0,125,0},{0,120,0},{0,115,0},{0,110,0},{0,105,0},{0,100,0},{0,95,0},{0,90,0},{0,85,0},{0,80,0},{0,75,0},{0,70,0},{0,65,0},{0,60,0},{0,55,0},{0,50,0},{0,45,0},{0,40,0},{0,35,0},{0,30,0}, {0,25,0},{0,20,0},{0,15,0},{0,10,0},{0,5,0},{0,0,0}}; uint8_t rgb3[53][3] = {{0,0,0},{0,0,10},{0,0,20},{0,0,30},{0,0,40},{0,0,50},{0,0,60},{0,0,70},{0,0,80},{0,0,90}, {0,0,100},{0,0,110},{0,0,120},{0,0,130},{0,0,140},{0,0,150},{0,0,160},{0,0,170},{0,0,180},{0,0,190}, {0,0,200},{0,0,210},{0,0,220},{0,0,230},{0,0,240},{0,0,250},{0,0,255},{0,0,250},{0,0,240},{0,0,230}, {0,0,220},{0,0,210},{0,0,200},{0,0,190},{0,0,180},{0,0,170},{0,0,160},{0,0,150},{0,0,140},{0,0,130}, {0,0,120},{0,0,110},{0,0,100},{0,0,90},{0,0,80},{0,0,70},{0,0,60},{0,0,50},{0,0,40},{0,0,30}, {0,0,20},{0,0,10},{0,0,0}}; uint8_t rgb5[200][3] = {{0,0,0},{100,0,0}, {100,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,100,0},{0,100,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,100},{0,0,100},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{10,100,0},{10,100,0}, {0,0,0},{0,0,0},{0,0,0},{0,0,0},{10,0,100},{10,0,100},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,10,100},{0,10,100},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{100,0,10},{100,0,10},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, {0,0,100},{0,0,100},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,100,0},{0,100,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{100,0,0},{100,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{100,0,100},{0,100,100}, {0,0,0},{0,0,0},{0,0,0},{0,0,0},{100,0,100},{100,100,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{90,0,100},{0,100,0}}; uint8_t rgb4[53][3] = {{0,0,0},{10,0,0},{20,0,0},{30,0,0},{40,0,0},{50,0,0},{60,0,0},{70,0,0},{80,0,0},{90,0,0}, {100,0,0},{110,0,0},{120,0,0},{130,0,0},{140,0,0},{150,0,0},{160,0,0},{170,0,0},{180,0,0},{190,0,0}, {200,0,0},{210,0,0},{220,0,0},{230,0,0},{240,0,0},{250,0,0},{255,0,0},{250,0,0},{240,0,0},{230,0,0}, {220,0,0},{210,0,0},{200,0,0},{190,0,0},{180,0,0},{170,0,0},{160,0,0},{150,0,0},{140,0,0},{130,0,0}, {120,0,0},{110,0,0},{100,0,0},{90,0,0},{80,0,0},{70,0,0},{60,0,0},{50,0,0},{40,0,0},{30,0,0},{20,0,0},{10,0,0},{0,0,0}}; //每个三位数，每一个位位一个不同颜色，数字大小表明亮度大小，最大256，通过将这个三个灯亮不同种类、大小程度进行调制不同量的颜色 u16 i,j; int main(void) {	delay_init();	LED_Init();	Timer2_init(); while(1) { for(i=0;i&lt;110;i++) { WS2812_send(&amp;rgb2[i],50,0); delay_ms(50); } for(i=0;i&lt;77;i++) { WS2812_send(&amp;rgb5[i],50,0); delay_ms(50); }	for(i=0;i&lt;212;i++) { WS2812_send(&amp;rgb1[i],50,1); delay_ms(50); } } } 每个三位数，每一个位位一个不同颜色，数字大小表明亮度大小，最大256，通过将这个三个灯亮不同种类、大小程度进行调制不同量的颜色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15237f662197152bfc960afb406a307d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4829cf3ffed7c9ed9c59245a2c4286/" rel="bookmark">
			jssip&#43;webrtc&#43;freeswitch实现电话网页及遇到的488状态码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先粘贴前端代码，里面引用的jssip的js可以从以下 链接下载jssip下载https://jssip.net/download/releases/
网上的许多demo无法使用，下面是从网上找得demo后，做了更改的前端代码（亲测可用）：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JsSIP + WebRTC + freeSWITCH&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta name="Author" content="foruok" /&gt; &lt;meta name="description" content="JsSIP based example web application." /&gt; &lt;!--&lt;script src="./js/jssip-3.3.11.min.js" type="text/javascript"&gt;&lt;/script&gt;--&gt; &lt;script src="./js/jssip-3.3.11.js" type="text/javascript"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;/head&gt; &lt;style type="text/css"&gt; /* 遮罩层 */ #overlay { position: fixed; left: 0px; top: 0px; width: 100%; height: 100%; font-size: 16px; /* IE9以下不支持rgba模式 */ background-color: rgba(0, 0, 0, 0.5); /* 兼容IE8及以下 */ filter: progid:DXImageTransform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f4829cf3ffed7c9ed9c59245a2c4286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb04fae397f441b154c9eb3fb129ff64/" rel="bookmark">
			JAVA基础：Spring的BeanUtils.copyProperties的使用(深拷贝，浅拷贝)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeanUtils.copyProperties的使用(深拷贝，浅拷贝) - 小知的文章 - 知乎
https://zhuanlan.zhihu.com/p/398232699
这里说的是spring的BeanUtils.copyProperties。想看相对详细具体的JAVA知识点-BeanUtils.copyProperties() 用法，可以点击跳转我另一篇总结的文章，里面有代码举例。
首先
使用场景：开发中经常遇到，把父类的属性拷贝到子类中。通常有2种方法：
1、属性值一个一个set。
AEntity.setYyy(BEntity.getYyy()); AEntity.setFff(BEntity.getFff()); AEntity.setTtt(BEntity.getTtt()); 2、org.springframework.beans.BeanUtils:　copyProperties(sourceDemo, targetDemo)
BeanUtils.copyProperties(AEntity,BEntity); 很显然用BeanUtils.copyProperties更加方便，也美观很多。
那么任何情况都能使用BeanUtils么，当然不是。要先了解他。
1、BeanUtils是深拷贝，还是浅拷贝? 是浅拷贝。
浅拷贝：只是调用子对象的set方法，并没有将所有属性拷贝。(也就是说，引用的一个内存地址) 。
深拷贝：将子对象的属性也拷贝过去。
2、什么情况适合用BeanUtils？ 如果都是单一的属性，那么不涉及到深拷贝的问题，适合用BeanUtils。
3、有子对象就一定不能用BeanUtils么？ 并不绝对，这个要区分考虑：
1、子对象还要改动。
2、子对象不怎么改动。
虽然有子对象，但是子对象并不怎么改动，那么用BeanUtils也是没问题的。
代码例子 下面用代码说明下。
翠山有个儿子无忌，儿子继承了他的face和height。 但是life应该是自己的。
后来翠山自刎而死，无忌也变成dead状态了。这就是浅拷贝，无忌用的life引用的翠山的life对象。
Father类：
@Data public class Father { private String face; // 长相 private String height; // 身高 private Life life; // 生命 } Life 类：
@Data public class Life { private String status; } Son类和main方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb04fae397f441b154c9eb3fb129ff64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3374b4e50f2b5b077be8ea351eb478ca/" rel="bookmark">
			CSDN Markdown写博客插入空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Markdown 文档中，可以直接采用 HTML 标记插入空格（blank space），而且无需任何其他前缀或分隔符。
1、插入一个空格 (non-breaking space)：
&amp;nbsp; 或 &amp;#160; 或 #xA0;
2、插入两个空格 (en space)：
&amp;ensp; 或 &amp;#8194; 或 &amp;#x2002;
3、插入四个空格 (em space)：
&amp;emsp; 或 &amp;#8195; 或 &amp;#x2003;
4、插入细空格 (thin space)
&amp;thinsp; 或 &amp;#8201; 或 &amp;#x2009;
注意：不要漏掉分号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce560ce5356924d1d3395a96df12409f/" rel="bookmark">
			Vue3.0的新特性（7）Teleport
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Teleport翻译过来就是传送、远距离传送的意思；顾名思义，它可以将插槽中的元素或者组件传送到页面的其他位置：
在React中可以通过createPortal函数来创建需要传送的节点；本来尤大大想起名叫Portal，但是H5原生的Portal标签也在计划中，虽然有一些安全问题，但是为了避免重名，因此改成Teleport。
Teleport一个常见的使用场景，就是在一些嵌套比较深的组件来转移模态框的位置。虽然在逻辑上模态框是属于该组件的，但是在样式和DOM结构上，嵌套层级后较深后不利于进行维护（z-index等问题）；因此我们需要将其进行剥离出来：
&lt;template&gt; &lt;button @click="showDialog = true"&gt;打开模态框&lt;/button&gt; &lt;teleport to="body"&gt; &lt;div class="modal" v-if="showDialog" style="position: fixed"&gt; 我是一个模态框 &lt;button @click="showDialog = false"&gt;关闭&lt;/button&gt; &lt;child-component :msg="msg"&gt;&lt;/child-component&gt; &lt;/div&gt; &lt;/teleport&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { showDialog: false, msg: "hello" }; }, }; &lt;/script&gt; 这里的Teleport中的modal div就被传送到了body的底部；虽然在不同的地方进行渲染，但是Teleport中的元素和组件还是属于父组件的逻辑子组件，还是可以和父组件进行数据通信。Teleport接收两个参数to和disabled：
○ to - string：必须是有效的查询选择器或 HTMLElement，可以id或者class选择器等。
○ disabled - boolean：如果是true表示禁用teleport的功能，其插槽内容将不会移动到任何位置，默认false不禁用。
vue官方链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11723203d1f6d32d36823f0733b0b11/" rel="bookmark">
			有哪些值得学习的大型 React 开源项目？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前有很多小伙伴问过我，通过文档或者视频学习 React 已经有一段时间了，想学习一些好的开源项目来获得一些实战经验。我之前也没有很好的答案，确实很难找，因为一般企业级应用都是不开源的，Github 上大部分都是很简单的 DEMO 项目，很难挑选。
今天就给大家梳理了几个我觉得还不错的 React 开源项目。
Jira Clone 仓库：https://github.com/oldboyxx/jira_clone
Github Star：8.6K
这是一个基于 React 开发的模仿 Jira 的项目，前端全部使用 React Hooks 实现 。另外还有一些其他亮点：
后端是基于 TypeScript 的 TypeORM，和 Postgres 进行通信
在前端使用自定义 Webpack 配置
基于 Cypress 进行端到端测试
作者还使用 styled-components 和全局样式进行混合开发，使他看起来和 Jira 非常像。
RealWorld aka Conduit 仓库：https://github.com/gothinkster/react-redux-realworld-example-app
Github Star：5.3K
预览：https://react-redux.realworld.io/
Thinkster 的 RealWorld 以超过 24 种不同的语言和框架重新实现了一个相同的应用程序（一个名为 Conduit 的仿 Medium.com 程序），这是它的 React/Redux 版本。
它基于 create-react-app 创建，用 react-router 实现路由，用 Redux 实现状态管理，基于 classNames 编写样式，基于 superagent 请求远程数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11723203d1f6d32d36823f0733b0b11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbee8977d8ff8c6925de7d4e58eb2d25/" rel="bookmark">
			Print.js javascript库 实现页面打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网地址：https://printjs.crabbly.com/
您可以从GitHub版本下载最新版本的Print.js：https://github.com/crabbly/Print.js/releases
npm 安装
npm install print-js --save npm安装时将库导入项目
import print from 'print-js' 首先，我们需要在页面上包含Print.js库和样式
&lt;script src="print.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="print.css"&gt; 下面主要介绍一下我们要用的打印方法printJS();将接受一个对象作为参数，下面表格的参数则为该对象的属性,通过控制属性值来控制打印：
参数默认值说明printable:null文档来源：pdf或图像的url，html元素的id或json数据的对象type:PDF可打印类型。可用的打印选项包括：pdf，html，image，json和raw-html。header:null用于HTML，Image或JSON打印的可选标头。它将放在页面顶部。此属性将接受文本或原始HTMLheaderStyle:'font-weight：300;'要应用于标题文本的可选标题样式maxWidth:800最大文档宽度（像素）。根据需要更改此项。在打印HTML，图像或JSON时使用。css:null这允许我们传递一个或多个应该应用于正在打印的html的css文件URL。值可以是包含单个URL的字符串，也可以是包含多个URL的数组。style:null这允许我们传递一个字符串，该字符串应该应用于正在打印的html。scanStyles:true设置为false时，库不会处理应用于正在打印的html的样式。使用css参数时很有用。targetStyle:null默认情况下，在打印HTML元素时，库仅处理某些样式。此选项允许您传递要处理的样式数组。例如：['padding-top'，'border-bottom']targetStyles:null 与targetStyle相同，这将处理任何一系列样式。例如：['border'，'padding']，将包括'border-bottom'，'border-top'，'border-left'，'border-right'，'padding-top'等。你也可以传递['*']来处理所有样式
ignoreElements:[]接受打印父html元素时应忽略的html的id数组。properties:null在打印JSON时使用。这些是对象属性名称。gridHeaderStyle:'font-weight：bold;'打印JSON数据时网格标题的可选样式。gridStyle:'border: 1px solid lightgray; margin-bottom: -1px;'打印JSON数据时网格行的可选样式repeatTableHeader:true在打印JSON数据时使用。设置为时false，数据表标题仅显示在第一页中。showModal:null启用此选项可在检索或处理大型PDF文件时显示用户反馈modalMessage:'Retrieving Document...'当向用户显示的消息showModal被设定为true。onLoadingStart:null加载PDF时要执行的功能onLoadingEnd:null加载PDF后要执行的功能documentTitle:'Document'打印html，image或json时，它将显示为文档标题。如果用户尝试将打印作业保存为pdf文件，它也将是文档的名称。fallbackPrintable:null 打印pdf时，如果浏览器不兼容（检查浏览器兼容性表），库将在新选项卡中打开pdf。这允许您传递要打开的不同pdf文档，而不是传递给printable的原始文档。如果您在备用pdf文件中注入javascript，这可能很有用。
onPdfOpen :null打印pdf时，如果浏览器不兼容（检查浏览器兼容性表），库将在新选项卡中打开pdf。可以在此处传递回调函数，这将在发生这种情况时执行。在您想要处理打印流程，更新用户界面等的某些情况下，它可能很有用。onPrintDialogClose:null关闭浏览器打印对话框后执行回调功能onError:error =&gt; throw error发生错误时要执行的回调函数。base64:false在打印作为base64数据传递的PDF文档时使用honorMarginPadding(不建议使用):true这用于保留或删除正在打印的元素的填充和边距。有时这些样式设置在屏幕上很棒，但在打印时看起来很糟糕。您可以通过将其设置为false来删除它。honorColor(不建议使用) :false要以彩色打印文本，请将此属性设置为true。默认情况下，所有文本都将以黑色打印。ont(不建议使用):'TimesNewRoman'打印HTML或JSON时使用的字体font_size(不建议使用):'12pt'打印HTML或JSON时使用的字体大小imageStyle (不建议使用):'width:100%;'打印图像时使用。接受包含要应用于每个图像的自定义样式的字符串。frameId:null print.js会将要打印的内容复制到一个新的Frame中,此参数是frame的id值
示例 HTML打印
有时我们只想打印HTML页面的选定部分，这可能很棘手。使用Print.js，我们可以轻松传递我们要打印的元素的id。该元素可以是任何标记，只要它具有唯一ID即可。该库将尝试将其打印得非常接近它在屏幕上的外观，同时，它将为它创建一个打印机友好的格式。
&lt;form method="post" action="#" id="printJS-form"&gt; ... &lt;/form&gt; &lt;button type="button" onclick="printJS('printJS-form', 'html')"&gt; Print Form &lt;/button&gt; 向表单添加标题
&lt;button type="button" onclick="printJS({ printable: 'printJS-form', type: 'html', header: '这是标题内容' })"&gt; 打印 &lt;/button&gt; html时候需要注意的事项:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbee8977d8ff8c6925de7d4e58eb2d25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff98386ba52fc1dfff9ea1952025dafa/" rel="bookmark">
			mybatis中返回对象包含其他对象情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.xxx.server.mapper.AdminMapper"&gt; &lt;!-- 通用查询映射结果 --&gt; &lt;resultMap id="BaseResultMap" type="com.xxx.server.pojo.Admin"&gt; &lt;!-- --&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="phone" property="phone"/&gt; &lt;result column="telephone" property="telephone"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="enabled" property="enabled"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="password" property="password"/&gt; &lt;result column="user_face" property="userFace"/&gt; &lt;result column="remark" property="remark"/&gt; &lt;/resultMap&gt; &lt;resultMap id="AdminWithRole" type="com.xxx.server.pojo.Admin" extends="BaseResultMap"&gt; &lt;collection property="roles" ofType="com.xxx.server.pojo.Role"&gt; &lt;id column="rid" property="id"/&gt; &lt;result column="rname" property="name"/&gt; &lt;result column="rnameZh" property="nameZh"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff98386ba52fc1dfff9ea1952025dafa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ae2503b0375ec48de254562056f9b3/" rel="bookmark">
			Kubernetes（k8s）安全机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、kubernetes安全机制
二、Authentication认证
1、用户分类
1.1、需要被认证的访问类型
1.2、安全性说明
1.3、证书颁发
1.4、Service Account
1.5、Secret 与 SA 的关系
1.6、Service Account （SA）中包含三个部分
2、kubeconfig文件
三、Authorization授权
3.1、RBAC
3.2、示例
3.3、Resources
四、准入控制（Admission Control）
4.1、ServiceAccount访问案例
4.2、创建pod验证其sa与secret
4.3、创建一个sa
4.4、创建pod并自定义sa
Kubernetes 作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。API Server 是集群内部各个组件通信的中介， 也是外部控制的入口。
所以 Kubernetes 的安全机制基本就是围绕保护 API Server 来设计的。
比如 kubectl 如果想向 API Server 请求资源，需要过三关，第一关是认证（Authentication），第二关是建权（Authorization）， 第三关是准入控制（Admission Control），只有通过这三关才可能会被 K8S 创建资源。
一、kubernetes安全机制 api server是k8s集群的入口，默认有两个端口:
本地端口8080: 用于接收HTTP请求, 不对外服务, 非认证或授权的HTTP请求通过该端口访问API Server安全端口6443: 用于接收认证授权的HTTPS请求，对外服务。 用户通过安全端口访问k8s的api server需要过三关：认证、授权、准入控制
Authentication认证: 用于识别用户身份, 方式有: SSL证书，token, 用户名+密码等Authorization授权: 确认是否对资源具有相关的权限Admission Control准入控制: 判断操作是否符合集群的要求 无论kubectl客户端命令或api或ui，在创建或访问资源时，一定要有apiServer所对应的资源版本，只要资源版本与kind能够正确匹配才能进行继续操作，否侧操作会被终止。
二、Authentication认证 Authentication认证: 用于识别用户身份, 验证方式有:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32ae2503b0375ec48de254562056f9b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f87b0e02540435fb9d9616dc1f85ca2c/" rel="bookmark">
			ubuntu20.04下turtlebot3与cartographer结合使用–建图与定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu20.04下turtlebot3与cartographer结合使用–建图与定位 目录 ubuntu20.04下turtlebot3与cartographer结合使用--建图与定位参考链接turtlebot3安装Cartographer安装 2D建图仿真1.启动Gazebo仿真2.启动slam3. 将地图保存.pbstream文件4. 可以通过cartographer提供的ros包，将后缀名为.pbstream的地图信息，转化成ros地图信息，用于其他方式的定位，如AMCL5. 基于已有地图定位 参考链接 turtlebot3安装 turtlebot3
turtlebot3_msgs
turtlebot3_simulations
以上3个功能包都需安装编译
Cartographer安装 GitHub
https://github.com/cartographer-project/cartographerhttps://github.com/cartographer-project/cartographer_ros Google文档–强力推荐
Cartographer ROS CSDN
cartographer探秘第一章之安装编译与参数配置 2D建图仿真 1.启动Gazebo仿真 roslaunch turtlebot3_gazebo turtlebot3_stage_4.launch 2.启动slam turtlebot3已包含与cartographer相关的启动配置文件，故只需安装好cartographer，便可通过以下命令启动cartographer的slam建图，包含move_base节点
roslaucn turtlebot3_slam turtlebot3_slam.launch slam_methods:=cartographer 注：
turtlebot3_slam/config文件目录下已有turtlebot3_lds_2d.lua，也可以自定义新建.lua文件
同样保存在turtlebot3_slam/config文件目录下，方便后续动态调用
参考古月居的文档
turtlebot3_carto.lua
include "map_builder.lua" include "trajectory_builder.lua" options = { map_builder = MAP_BUILDER, trajectory_builder = TRAJECTORY_BUILDER, map_frame = "map", tracking_frame = "base_footprint", published_frame = "odom", odom_frame = "odom", provide_odom_frame = false, --算法内部提供里程计 publish_frame_projected_to_2d = false, use_odometry = true, --使用里程计 use_nav_sat = false, use_landmarks = false, num_laser_scans = 1, num_multi_echo_laser_scans = 0, num_subdivisions_per_laser_scan = 1, num_point_clouds = 0, lookup_transform_timeout_sec = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f87b0e02540435fb9d9616dc1f85ca2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d143d9af7aae4a86955773197b3eae/" rel="bookmark">
			MySQL sql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户管理：
1、新建用户：
&gt;CREATE USER name IDENTIFIED BY 'ssapdrow';
2、更改密码：
&gt;SET PASSWORD FOR name=PASSWORD('fdddfd');
3、权限管理
&gt;SHOW GRANTS FOR name; //查看name用户权限
&gt;GRANT SELECT ON db_name.* TO name;　//给name用户db_name数据库的所有权限
&gt;REVOKE SELECT ON db_name.* TO name;　//GRANT的反操作，去除权限；
一、数据库操作：　1、查看数据库：
&gt;SHOW DATABASES;
2、创建数据库：
&gt;CREATE DATABASE db_name;　//db_name为数据库名
3、使用数据库：
&gt;USE db_name;
4、删除数据库：
&gt;DROP DATABASE db_name;
二、创建表：
1、创建表：
&gt;CREATE TABLE table_name(
&gt;id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT,　//id值，无符号、非空、递增——唯一性，可做主键。
&gt;name VARCHAR(60) NOT NULL
&gt;score TINYINT UNSIGNED NOT NULL DEFAULT 0,　//设置默认列值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d143d9af7aae4a86955773197b3eae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a467a85f480be1ce2f20a014a8baac8b/" rel="bookmark">
			展开运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(...)展开运算符又叫剩余运算符。
展开运算符（spread operator）允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。
展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。不过ES7草案当中已经加入了对象展开运算符特性。
数据构造
（1）两个对象连接返回新的对象。
let x = { name:'tom' }; let y = { age:19 } let z = {...x,...y}; console.log(z); 预览效果
（2）两两个数组连接返回新的数组。在ES6的世界中，我们可以直接加一个数组直接合并到另外一个数组当中。
let x = [100,20,500] let y = ['lili','jerry'] let z = [...x,...y] console.log(z); 预览效果
（3）数组加上对象返回新的数组
let x = [{ uname:'lili' }]; let y = { age:19 }; let z = [...x,y]; console.log(z); 预览效果
类数组对象变成数组
当你对dom中（页面中）标签元素进行抓取的时候，这些标签元素会形成一个集合，这个集合我们称之为类数组对象。
展开运算符可以将一个类数组对象变成一个真正的数组对象。
&lt;body&gt; &lt;div&gt;盒子1&lt;/div&gt; &lt;div&gt;盒子2&lt;/div&gt; &lt;script&gt; // 抓取元素 let divObj = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a467a85f480be1ce2f20a014a8baac8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579f4a7e3a99a687c1655b8f03e809e1/" rel="bookmark">
			前端开发中，实现动态改变css样式的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jquery 方法 addClass()-向被选元素添加一个或多个类 removeClass()-从被选元素删除一个或多个元素 toggleClass()-对被选元素进行添加/删除类的切换操作 css()-设置或返回样式属性 例如下面两个样式 .color1 { color:red; } .color2 { color:blue; } 实例 1、jQuery addClass()方法 下面的例子展示如何向不同的元素添加class属性. 当然在添加类时,您可以选取多个元素 $("#btn1").click(function(){ $("h1,h2,p").addClass("color1"); $("div").addClass("color1"); }); 2、jQuery removeClass()方法 下面的例子演示如何在不同的元素中时删除指定的class属性 $("#btn2").click(function(){ $("h1,h2,p").removeClass("color1"); }); }); 3、jQuery toggleClass()方法 下面的例子将展示如何使用jQuery toggleClass()方法,点击被选元素进行添加color1，再次点击删除color1类 $("#btn3").click(function(){ $("h1,h2,p").toggleClass("color1"); }); vue &lt;div :class={color1：ifshow==true} /&gt; .color1 { color:red; } 在Vue中我们可以动态的设置类名，如上个实例所示，color1是我们写好的样式，我们在data中定义ifshow，通过控制ifshow的true或者false来决定是否展示类名。
以此为基础，如果我们想在不展示color1时展示color2，那么我们可以这样做
&lt;div :class={color1：ifshow==true , color2：ifshow==false} /&gt; .color1 { color:red; } .color2 { color:blue; } 这样来看我们可以通过控制ifshow的值来决定展示哪个样式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becaa87895d65df728be86844d9cd07c/" rel="bookmark">
			文字末尾加图片按钮，点击按钮打开折叠文字，设置文字显示指定行数TextApp,textview结尾图片折叠文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文字末尾加图片按钮，点击按钮打开折叠文字，设置文字显示指定行数TextApp,textview结尾图片折叠文字， 实现效果 把长文字 折叠成1行或者指定行显示，末尾加... + 图片，点击图片展开全部文字显示或者折叠成1行（或者指定行）显示。
上代码：
1、MainActivity.java
package com.android.textapp; import android.content.Context; import android.graphics.drawable.Drawable; import android.os.Bundle; import android.text.Spannable; import android.text.SpannableString; import android.text.TextPaint; import android.text.TextUtils; import android.text.method.LinkMovementMethod; import android.text.style.ClickableSpan; import android.text.style.ImageSpan; import android.util.DisplayMetrics; import android.util.Log; import android.view.View; import android.view.ViewTreeObserver; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.content.ContextCompat; public class MainActivity extends AppCompatActivity { private String resourceStr; private String shortStr; private TextView textView; // 默认显示2行 private int defaultLine = 2; private boolean expored = false; @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/becaa87895d65df728be86844d9cd07c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72507698544633b5209c43fcea99de0d/" rel="bookmark">
			Android 解析JSON数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种使用JSONObject解析JSON数据，这是Android中最基本的数据解析方式
fromJson("{'status':200," + "'message':'ok'," + "'people':{" + "'username':'LiLy'," + "'phone':'13189720413'," + "'headerImg':'https://img0.baidu.com/it/u=1521420901,2700109129&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=313'}}"); private void fromJson(String s) { Me me=new Me(); JSONObject jsonObject= null; try { jsonObject = new JSONObject(s); int status=jsonObject.optInt("status"); me.setStatus(status); String message=jsonObject.optString("message"); me.setMessage(message); JSONObject uesrJson=jsonObject.optJSONObject("people"); String username=uesrJson.optString("username"); String phone=uesrJson.optString("phone"); String headerImg=uesrJson.optString("headerImg"); me.setPeople(new People(username,phone,headerImg)); Log.d("","Json======"+status+"\t"+message+"\t"+username+"\t"+phone+"\t"+headerImg); } catch (JSONException e) { e.printStackTrace(); } } 第二种方式通过GSON去解析JSON数据
同样的数据格式
objectFromJson("{'status':200," + "'message':'ok'," + "'people':{" + "'username':'LiLy'," + "'phone':'13189720413'," + "'headerImg':'https://img0.baidu.com/it/u=1521420901,2700109129&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=313'}}"); private void objectFromJson(String s) { Gson gson=new Gson(); Me me = gson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72507698544633b5209c43fcea99de0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1560d29d596d84bbbf43d6fd7c42448/" rel="bookmark">
			Unity中物体半透明显示——e.g.让指定的构件从所有构件中脱颖而地展示自我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、要达到的效果 用户点击【走廊】菜单的时候，其他部件穿透显示，只有走廊正常显示，并高亮闪烁。
二、思路 1、读取材质信息：读取各个部件的材质信息并存储，恢复材质的时候用2、设置物体为透明：把物体原来的材质换成透明材质3、取消物体的透明：把物体的透明材质换成原来的材质 三、关键步骤的代码 只列了关键的方法 1、提取物体的材质生成一个字典 /// &lt;summary&gt; /// 给定一个设备（3d物体root），遍历该物体的所有子部件（子部件的root名字包含[#]，命名格式如【#部件名字】），读取子部件物体的材质信息，返回一个字典： /// Dictionary&lt;string-部件的物体名字, List&lt;(GameObject, Material[])-物体和它的材质数组&gt;&gt; /// key用物体名字是用来快速提取某个子部件的材质信息，用于更换材质或者恢复材质 /// /// 层级关系及命名 /// root /// #部件1 /// gameobject1 /// gameobject2 /// ... /// gameobjectn /// ... /// #部件n /// /// &lt;/summary&gt; /// &lt;param name="root"&gt;3d物体——部件的root&lt;/param&gt; /// &lt;returns&gt; Dictionary&lt;string-子部件名字, List&lt;(GameObject -- 子部件的子物体, Material[] -- 物体对应的材质数组)&gt;&gt; &lt;/returns&gt; static Dictionary&lt;string, List&lt;(GameObject, Material[])&gt;&gt; GetMaterialsDict(GameObject root) { //提前生成空的返回值 var partsMaterialDict = new Dictionary&lt;string, List&lt;(GameObject, Material[])&gt;&gt;(); //获取所有的零件 var parts = root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1560d29d596d84bbbf43d6fd7c42448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015d00eccf753c0b214d9ace421f8b14/" rel="bookmark">
			Python给图片加水印（非常简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来分享可以给图片添加水印的方法，十分的简单实用，大家在看了之后也可以私底下去自己试试。
# encoding=utf8 ''' Python给图片加水印（非常简单） ''' # 导入包 from watermarker.marker import add_mark if __name__ == '__main__': # 需要加水印的图片目录 srcpath = r'D:\Test\image\\' # 加水印后保存目录 retpath = r'D:\Test\square' '''add_mark是图片加水印的方法，共有8个参数''' # file：图片文件或图片文件夹路径 # out：添加水印后的结果保存位置，默认生成到 output 文件夹 # mark：要添加的水印内容 # opacity：水印的透明度，默认 0.15 # angle：水印旋转角度，默认 30 度 # space：水印直接的间隔, 默认 75 个空格 # size：水印字体的大小，默认 50 # color：文字水印颜色设置 16进制 # 水印测试一 add_mark(file = srcpath + '1.jpg', out = retpath, mark = "我是小蜘蛛", opacity = 0.7, angle = 35, space = 30, size = 35, color = '#00ff00') # 水印测试二 add_mark(file = srcpath + '2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015d00eccf753c0b214d9ace421f8b14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111008b25583c81b84974b2e5d4f571f/" rel="bookmark">
			windows中搭建maven环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，下载maven，下载地址 http://maven.apache.org/download.cgi，点击 apache-maven-*.*.*-bin.zip 进行下载
2，解压到对应目录中
3，配置环境变量：
1
2
M2_HOME = E:\Program Files\Java\apache-maven-3.5.0
path = .....;%M2_HOME%\bin
4，测试安装，打开cmd，输入 mvn -v
1
2
3
4
5
6
7
Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T0
6+08:00)
Maven home: E:\Program Files\Java\apache-maven-3.5.0\bin\..
Java version: 1.8.0_131, vendor: Oracle Corporation
Java home: E:\Program Files\Java\jdk1.8.0_131\jre
Default locale: zh_CN, platform encoding: GBK
OS name: "windows 7", version: "6.1", arch: "amd64", family: "windows"
输出以上信息，说明配置成功
5，自定义Maven的本地库路径，可以去修改Maven的配置文件，位置在： 你的路径\apache-maven-*.*.*\conf\setting.xml，如下：
1
2
3
4
5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/111008b25583c81b84974b2e5d4f571f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fa5e03017c59cb1c6dcc33ba17553a/" rel="bookmark">
			jsp中使用JDBC连接mysql的方法与实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：本实例讲解命名用 mysql-connector-java-*.*.*-bin.jar ,链接mysql 并查询 表中的数据，表中的id,title,content字段，表名为 article
1，新建一个 Web Project ，这个不多说了
2，下载 mysql-connector-java-*.*.*-bin.jar ，下载地址：https://pan.baidu.com/s/1i5mTlyd
3，将下载好的 jar包放到项目WEB-INF\lib 目录中
4，创建DBHelper类，代码如下：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
package cn.form1;
import java.sql.Connection;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07fa5e03017c59cb1c6dcc33ba17553a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74e3d925bdaf5669959ede9bbe9aa06/" rel="bookmark">
			Linux内核：设备树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设备树API函数：利用of_函数读取设备树结点/属性信息 ​ 设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息。
​ Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 。这些 OF原型都定义在include/linux/of.h 文件中。
判断根节点兼容性OF函数 在Linux内核中，常常使用如下OF函数来判断根节点的兼容性：
int of_machine_is_compatible(const char *compat); DT设备的.dt_compat可能包含多个电路板，通过该函数可以判断根节点compatible的属性，当该函数的compat参数与根据点的compatible匹配时，返回一个正整数。
用法，例如：
of_machine_is_compatible("samsung,exynos4"); 查找节点的 OF ​ 设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。 Linux 内核使用 device_node 结构体来描述一个节点，此结构体定义在文件 include/linux/of.h 中，代码如下：
struct device_node { const char *name; /*节点的名字*/ const char *type; /*设备类型，来自节点中的device_type属性, 如果没有该属性, 则设为"NULL"*/ phandle phandle; const char *full_name; /*节点的全名，node-name[@unit-address]*/ struct fwnode_handle fwnode; struct	property *properties; /*节点的属性*/ struct	property *deadprops;	/* removed properties */ struct	device_node *parent; /*父节点*/ struct	device_node *child; /*子节点*/ struct	device_node *sibling; /*节点的兄弟，即同级节点*/ #if defined(CONFIG_OF_KOBJ) struct	kobject kobj; #endif unsigned long _flags; void	*data; #if defined(CONFIG_SPARC) const char *path_component_name; unsigned int unique_id; struct of_irq_controller *irq_trans; #endif }; 与查找节点相关的，有如下函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a74e3d925bdaf5669959ede9bbe9aa06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1818f04951ece3877d7c6b61a2fed0e/" rel="bookmark">
			(十二) findContours函数的hierarchy详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎访问个人网络日志🌹🌹知行空间🌹🌹
文章目录 1.基本用法2.轮廓提取模式2.1 RETR_LIST2.2 RETR_EXTERNAL2.3 RETR_CCOMP2.4 RETR_TREE3.测试代码参考资料 1.基本用法 获取对象的轮廓，一般最好先对图像进行灰度化再进行阈值处理，然后用来检测轮廓。
void cv::findContours( InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset = Point() ) image: 8位单通道图像contours: 检测到的轮廓，vector&lt;vector&lt;cv::Point&gt;&gt;hierarchy: 检测到的轮廓之间的嵌套和邻近关系，vector&lt;cv::Vec4i&gt;mode: 不同的轮廓检测算法，常用的有RETR_EXTERNAL/RETR_LIST/RETR_CCOMP/RETR_TREE四种method: 轮廓逼近方法，见，可使用更少的点表示轮廓，减少内存占用。offset: 轮廓点应该偏移的量，当在roi上提取轮廓后想还原到原图上时比较有用。 2.轮廓提取模式 第四个参数mode,可以选择不同的轮廓提取算法，常用的有RETR_EXTERNAL/RETR_LIST/RETR_CCOMP/RETR_TREE四种。下面分别进行介绍。在findContours函数中，其第3个参数hierarchy表示的轮廓之间的层级关系，对于不同mode的轮廓提取算法，其返回的值是不同的。如下图【来自于OpenCV Doc】：
图中不同的轮廓有层级嵌入关系，我们将外部的轮廓称为父，内部的轮廓称为子，hierarchy就是表示轮廓的父子和邻近关系的矩阵。上图中有0/1/2/3/4/5/2a/3a 8 个轮廓，其中0,1,2是最外侧的轮廓，可记为它们在层级0hierarchy-0。而2a是轮廓2的子轮廓，记为其在层级1hierarchy 1。同样轮廓3是轮廓2a的子轮廓，记为其在层级2hierarchy 2。同样轮廓3a是轮廓3的子轮廓，记为其在层级3hierarchy 3。4/5是3a的子轮廓，其构成层级4hierarchy 4。 属于每个层的轮廓都有其自己的信息，如它的子轮廓是什么，父轮廓是什么，OpenCV通过一个四个元素的数组来表示每个轮廓与其他轮廓的关系，这个四维数组中的值分别表示**[Next, Previous, First_Child, Parent], Next表示属于同一个层级hierarchy的下一个轮廓，以上图轮廓0为例，0,1,2属于同个层级hierarchy-0的轮廓，因此0的Next是1,1的Next是2。同一个层级中轮廓2已经是最后一个了，因此其Next是-1。同样对于上图的轮廓4，与其同属于层级4hierarchy-4的轮廓是5,因此4的Next=5,而5的Next=-1。Previous表示同一层级中之前的的那个轮廓**，如上图，1的Previous=0, 2的Previous=1,0的Previous=-1。First_Child表示当前轮廓的第一个子轮廓，如上图，0的First_Child=-1,2的First_Child=2a,3a的First_Child=4。Parent表示当前轮廓的父轮廓，如上图，4和5的父轮廓都是3a，3a的父轮廓是3,3的父轮廓是2a,2的Parent=-1。
findContours方法中的mode参数会返回不同的hierarchy信息，因为有些算法会找出轮廓间的嵌套和邻近关系，有些则只是把轮廓找出来而不会解析轮廓之间的信息。
2.1 RETR_LIST RETR_LIST算法只会返回轮廓信息，而没有轮廓间的嵌套信息。因此，所有的轮廓都属于同个层级hierarchy没有父子关系, hierarchy返回值中只有Next和Previous，Parent和First_Child都为-1。四维数组的第3和第4个元素都是-1。如上图运行findContours后的输出：
findContours(image, contours, hierarchy, cv::RETR_LIST, cv::CHAIN_APPROX_SIMPLE); &gt;&gt;&gt; hierarchy [1, -1, -1, -1] [2, 0, -1, -1] [3, 1, -1, -1] [4, 2, -1, -1] [5, 3, -1, -1] [6, 4, -1, -1] [7, 5, -1, -1] [-1, 6, -1, -1] 这里的0/1/2/3/4/5/6/7对应的是轮廓在contours中的下标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1818f04951ece3877d7c6b61a2fed0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f311abeecfdeda96a41c9ee7ecef3c25/" rel="bookmark">
			u盘格式化后数据能恢复吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		u盘是我们主要的便携式的数据存储工具，如果把U盘格式化就意味着用户可能失去原本存放在U盘中的所有数据。如果重要数据没有备份，就可能造成不可估量的损失。
U盘数据恢复的方法主要有两种：
一、从备份中恢复
即通过计算机硬盘或云存储中的备份文件恢复原始数据。这种方法非常简单，用户可以完全自主操作，而且十分快捷有效，基本上不会失败。但它有一个非常苛刻的前提，就是用户需要将U盘中的文件提前备份至计算机硬盘或云端。如果没有这份细心的准备，这个方法就完全不可能成立。
二、使用专业的U盘数据恢复工具
对于没有提前备份的用户，格式化U盘中的数据也并非不可恢复。还有一个绝妙的方法可以帮助找回因格式化而丢失的数据，那就是通过使用专业的数据恢复来进行U盘数据恢复。
下面我们直接借助失易得数据恢复来介绍一下具体的步骤。
第一步：将格式化的U盘连接到电脑上。
注意：当误格式化U盘后，切记不要再对U盘进行任何新的读写操作，以免造成数据破坏。
第二步：运行软件，选择“误格式化磁盘”功能进入，然后选择我们连接到电脑U盘
第三步：选择自己需要恢复的文件类型，选择完后点击扫描。
第四步：扫描完成后，有很多数据，找到自己认为比较重要和一定要恢复的文件，进行预览，能正常预览就说明文件可以恢复过来，确认自己要恢复的文件之后，勾选起来，点击下方的恢复按键，这样数据就可以全部恢复到电脑上。
格式化的u盘如何恢复?以上就是关于如何恢复数据的具体操作了。学会了这个办法以后格式化也不用担心了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1877d5c70ab94945f08f53fdc4e719/" rel="bookmark">
			JavaScript 面向对象详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我肯定是需要你告诉我，什么是面向对象，面向对象有哪些特点，以及这些特点的解释。
JavaScript 如何实现这些特点，比如封装、继承、多态。如果关于上述三点，你能够解释到有多少种实现方式、优缺点是什么。以及近几年流行的解决方案是什么。这就是「加分」 ，比如对于继承吧。类式继承、构造函数继承、组合继承、原型继承、寄生组合继承等等，说出大概的实现思路和优缺点，再介绍下 extends 或者 mixin 的实现甚至你可以衍生到 JavaScript 的模块化发展甚至到为什么现在 TS 如此流行。那么可以说到这一环节解答的就非常棒了。
回答完 JavaScript 的面向对象，是不是可以从此衍生下为什么需要面向对象。以及当先对于软件设计的高内聚、低耦合的思考？来个对此题一个提纲挈领的总结？
综上所述，其实不难看出，越是这种基础且开放的题目，可以是一个陷阱，更可以是一个机会。因为一道题真的可以全方面的感受到应聘的基础是否扎实。
JavaScript 面向对象详解(一) ES6 之前的 JavaScript 面向对象比较不好理解，涉及到很多知识和思想。
ES6 增加了 class 和 extends 来实现类的封装和继承，但是通过 babel 转换成 ES5 之后还是之前的一套逻辑。
这里，我打算用四篇文章，来讲解一下关于 ES5 中面向对象的知识体系，一起学习一下吧！
一. JavaScript 的对象 1.1. 传统对象 vs JavaScript 对象 传统的面向对象
面向对象语言的一个标志就是类类是所有对象的统称, 是更高意义上的一种抽象. 对象是类的实例.通过类我们可以创建任意多个具体的对象.在学习 C++/OC/Java/Python 等编程语言的时候, 都可以按照这种方式去创建类和对象. JavaScript 的面向对象
JavaScript 中没有类的概念（ES6 之前），因此我们通常称为基于对象，而不是面向对象.虽然 JavaScript 中的基于对象也可以实现类似于类的封装、继承、甚至是多态。但是和传统意义的面向对象还是稍微有一些差异(后面我们会讲解它是如何实现的)ECMA 中定义对象是这样: 无序属性的集合, 属性可以包含基本值, 对象或者函数.也就是对象是一组没有顺序的值组成的集合而已.对象的每个属性或者方法都有一个名字, 而名字对应一个值. 有没有觉得非常熟悉?没错, 其实就是我们经常看到和使用的映射(或者有些语言称为字典, 通常会使用哈希表来实现). 1.2. 简单的方式创建对象 创建自定义对象最简单的方式就是创建一个 Object 实例, 然后添加属性和方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1877d5c70ab94945f08f53fdc4e719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26214c65b525ccfbdaf9435c0639448/" rel="bookmark">
			【JavaSE】继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
super关键字
1.访问父类成员变量
2.调用父类成员方法
3.super()调用父类构造方法
构造方法 代码块执行顺序
final关键字
1.修饰成员变量
2.修饰成员方法
3.修饰类
super关键字 1.访问父类成员变量 2.调用父类成员方法 class Animal{ //方便后续操作，把成员变量都设置成public public String name; public int age; public void eat(){ System.out.println(name+"吃饭"); } } class Dog extends Animal{ public boolean loyal; //通过构造方法初始化 public Dog(){ //通过super关键字对父类当中的成员变量赋值 super.name = "旺财"; super.age = 4; super.eat(); //通过this关键字对子类当中的成员变量赋值 this.loyal = true; } public void gradHouse(){ System.out.println(name+"守护房子！"); } } class Cat extends Animal{ public boolean lazy; public Cat(){ super.name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f26214c65b525ccfbdaf9435c0639448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07aa2df7ea4646d5f0022847b1c927a5/" rel="bookmark">
			svg图片调整大小和颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：设计给的SVG图片在开发中尺寸不合适或者颜色不合适，需要修改尺寸和颜色
1.修改尺寸
在svg标签中修改width、height 属性（默认单位是px）
2.修改颜色
在path标签中修改fill 属性,要是要修改线条颜色就修改stroke属性
一些属性：
fill属性设置对象内部的颜色，stroke属性设置绘制对象的线条的颜色。
fill: 填充色
fill-opacity：填充的透明度
stroke：边框，即线条，设置其颜色
stroke-width：设置描边的宽度。注意，描边是以路径为中心线绘制的
stroke-opacity： 边框透明度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc724e29914ca49a2173546de03e345/" rel="bookmark">
			js中使用getElementsByClassName获取class对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端开发一般不需要过多考虑性能问题，但你想在性能上追求极致的话，一定要知道jQuery性能很差。原生API选择器相比jQuery丰富很多，如document.getElementsByClassName性是$(classSelector)的50多倍。
getElementsByClassName() 方法返回文档中所有指定类名的元素集合，作为 NodeList 对象。
NodeList 对象代表一个有顺序的节点列表。NodeList 对象 我们可通过节点列表中的节点索引号来访问列表中的节点(索引号由0开始)。
提示： 你可以使用 NodeList 对象的 length 属性来确定指定类名的元素个数，并循环各个元素来获取你需要的那个元素。
1
var x = document.getElementsByClassName("example");
实例
获取包含 "example" 和 "color" 类名的所有元素:
1
var x = document.getElementsByClassName("example color");
查看文档中有多少个样式 class="example" 的元素 (使用 NodeList 对的 length 属性):
1
var x = document.getElementsByClassName("example").length;
修改所有样式 class="example" 元素的背景颜色：
1
2
3
4
5
var x = document.getElementsByClassName("example");
var i;
for (i = 0; i &lt; x.length; i++) {
x[i].style.backgroundColor = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc724e29914ca49a2173546de03e345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1e2f3597bde65c9fefdd2aee9a498b/" rel="bookmark">
			程序员老王在办公室炫富...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇漫画故事改编自知乎高赞回答
作者：ze ran
链接：https://www.zhihu.com/question/30692237/answer/49837138 漫画原创公众号：不会笑青年，授权转载请联系微信(laughyouth369)，授权后，请在原创发表48小时后转载。
&lt; END &gt;
作者：不会笑青年
漫画师：Ys
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0beff49a510e12fa1521b67281c2a9/" rel="bookmark">
			Mysql的group_concat函数长度限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql版本 mysql5.7
MySQL5.7及以上版本有GROUP_CONCAT函数，
其作用是返回一个组合所有值的字符串。
使用演示
select group_concat(xxx order by aa asc/desc reparator - ) from table;
GROUP_CONCAT其他语法
GROUP_CONCAT还可以对字段属性进行排序、去重、自定义拼接分隔符。
去重、降序、使用逗号分割查询
select name group_concat(distinct xxx order by aa asc/desc reparator - ) from table group by name；
去重、升序、使用&amp;符号分割查询
select name,GROUP_CONCAT(DISTINCT age order by age asc SEPARATOR '&amp;') from t1 GROUP BY name;
GROUP_CONCAT超长截断问题 GROUP_CONCAT拼接的最大长度默认为1024字节，超过这个长度则会被截断，可以通过SET [GLOBAL | SESSION] group_concat_max_len = val;进行修改。
比如修改GROUP_CONCAT长度为1个字节。
SET SESSION group_concat_max_len = 1;
当再查询时，拼接的结果被截断
select name group_concat(distinct xxx order by aa asc/desc reparator - ) from table group by name；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0beff49a510e12fa1521b67281c2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979576bbb28cb55353c55c8bcf7ba97f/" rel="bookmark">
			模糊查询除了like&#43; % 还能用什么方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道 InnoDB 在模糊查询数据时使用 “%xx” 会导致索引失效，但有时需求就是如此，类似这样的需求还有很多，例如，搜索引擎需要根基用户数据的关键字进行全文查找，电子商务网站需要根据用户的查询条件，在可能需要在商品的详细介绍中进行查找，这些都不是B+树索引能很好完成的工作。
通过数值比较，范围过滤等就可以完成绝大多数我们需要的查询了。但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较，全文索引就是为这种场景设计的。
全文索引（Full-Text Search）是将存储于数据库中的整本书或整篇文章中的任意信息查找出来的技术。它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。
在早期的 MySQL 中，InnoDB 并不支持全文检索技术，从 MySQL 5.6 开始，InnoDB 开始支持全文检索。
有没有感觉全文索引在什么地方出现过，论文查重说不定就是全文索引时用的方式呢。
倒排索引 全文检索通常使用倒排索引（inverted index）来实现，倒排索引同 B+Tree 一样，也是一种索引结构。它在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射，这通常利用关联数组实现，拥有两种表现形式：
inverted file index：{单词，单词所在文档的id}
full inverted index：{单词，（单词所在文档的id，再具体文档中的位置）}
对于 inverted file index 的关联数组
上图为 inverted file index 关联数组，可以看到其中单词"code"存在于文档1,4中，这样存储再进行全文查询就简单了，可以直接根据 Documents 得到包含查询关键字的文档；而 full inverted index 存储的是对，即（DocumentId,Position），因此其存储的倒排索引如下图，如关键字"code"存在于文档1的第6个单词和文档4的第8个单词。相比之下，full inverted index 占用了更多的空间，但是能更好的定位数据，并扩充一些其他搜索特性。
全文检索 创建全文索引 1、创建表时创建全文索引语法如下： CREATE TABLE table_name ( id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY, author VARCHAR(200), title VARCHAR(200), content TEXT(500), FULLTEXT full_index_name (col_name) ) ENGINE=InnoDB; 输入查询语句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979576bbb28cb55353c55c8bcf7ba97f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ca56f26e3667e1f7957b4494e75307/" rel="bookmark">
			IEEE RAL投初稿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IEEE RAL投初稿 1 RAL注册2 ORCID ID 绑定RAL账号PIN码3 提交参考 完整提交流程 https://www.ieee-ras.org/publications/ra-l/submission-procedures
1 RAL注册 https://ras.papercept.net/journals/ral
先注册获得一个PIN码（填完信息之后，会出现一个名单，这个名单与你填的信息有部分相同，目的是确认自己有没有注册过）再设置密码（验证码会发到注册设置的邮箱）。登陆后，要补充个人信息。
RAL对提交论文的说明（这个页面就在登录进去的那个页面，或者home界面点PIN选项卡）
2 ORCID ID 绑定RAL账号PIN码 ORCID ID 即 Open Researcher and Contributor ID 什么是orcid？
注册 https://orcid.org/ 。关联。也就是上述图片的最后6条。链接在RAL登录界面，然后点击授权。然后会回到一个RAS的登录界面，点击登录，即完成关联。
3 提交 提交链接位置http://ras.papercept.net/journals/ral/scripts/login.pl
提交步骤
注意
作者，一作，通信等确认关键字，最少可以输入 2 个，最多 5 个（推荐）关键字；前两个关键字必须从RA-L 学科领域列表中选择；最多可自由输入三个关键词，（实际上，只能输入三个列表里的关键字，然后按关键字分配审稿人）写一个cover note，内含对主编说的话，指出创新点，→模板IEEE投稿报错解决方法“Page n has margin impositions” 在\maketitle后面加上 \pagestyle{empty} % no page number for the second and the later pages \thispagestyle{empty} % no page number for the first page 参考 RAL(Robotics and Automation Letters)投稿指南汇总「 论文投稿 」《IEEE Robotics and Automation Letters》录用经历 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4eb2b292d894cd8967dd4cb44ad9d8/" rel="bookmark">
			【系统篇 / 安装】❀ 02. 制作安装 U 盘 ❀ Windows Server 2016
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【简介】网上下载的ISO镜像文件，传统上是刻录成DVD光盘，通过光驱进行安装，也可以刻录到U盘上，通过U盘启动并进行安装。U盘安装具有速度快、更加方便等特性。
安装条件
Windows Server 2016 ISO 镜像文件下载后，通常我们会用 UltraISO 工具制作成U盘安装盘。
但是由于 ISO 文件大于4G，UltraISO 并不支持，刻录出来的 U 盘容量只有1.7G。这里推荐使用 PowerISO 软件。
PowerISO 下载
PowerISO 是收费软件，但是我们可以用它的试用功能。
① 浏览器打开地址 www.poweriso.com/cn/，登录 PowerISO 中文官网，首页就有 PoserISO 的介绍，点击【DOWNLOAD NOW】。
② PowerISO 分为32位和64位版本，现在系统以64位版居多，这里点击【下载 PowerISO v6.9 (64位版本)】。
③ 选择文件保存目录，点击【保存文件】。
④ 下载OK，文件大小约为3M。
PowerISO 安装
双击安装文件，启动安装。
① 首先显示软件的许可证协议，点击【我接受】。
② 然后显示安装目录，这里保留默认，点击【安装】。
③ 文件不大，很快安装完成，点击【下一步】。
④ 默认会建立一个虚拟光驱，并且自动运行，保留默认设置，点击【关闭】，安装完成。
PowerISO 刻录U盘
PowerISO安装完成后，就可以开始刻录U盘了。
① 在桌面上双击PowserISO 图标启动软件。
② 因为下载的是试用版，首先会弹出提示，等待几秒钟后，点击【继续试用】。
③ 点击【打开】图标。
④ 找到并选择 Windows Server 2016 的 ISO 镜像文件，点击【打开】。
⑤ 可以看到ISO文件内容了，然后选择菜单【工具】-【制作可启动U盘】。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4eb2b292d894cd8967dd4cb44ad9d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba8f53d345935749ab389057345a86b/" rel="bookmark">
			解决deep freeze冰点还原软件无法冻结的问题：计算机正在完成Deep Freeze冰点检测到的待定Windows更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决deep freeze冰点还原软件无法冻结的问题：计算机正在完成Deep Freeze冰点检测到的待定Windows更新 问题描述解决方法 问题描述 deepfreeze无法冻结，提示“计算机正在完成Deep Freeze冰点检测到的待定Windows更新”。
解决方法 在“Windows更新”中，更新成为 最新版本。
删除windows更新记录。（参考资料）
步骤如下：
Win + S 键搜索栏输入 CMD 找到 “命令提示符”，右键以管理员身份打开，小心一次一行复制及粘贴执行以下命令：
net stop wuauserv
net stop cryptSvc
net stop bits
net stop msiserver
ren C:\Windows\SoftwareDistribution SoftwareDistribution.old
ren C:\Windows\System32\catroot2 Catroot2.old
3.卸载deepfreeze。步骤见以下网址：https://xinzhi.wenda.so.com/a/1521966664208805
4. 重启系统 ，重新安装冰点。问题就解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f11e0fb8308db4b5d2c49b68bc213e/" rel="bookmark">
			mysql根据日周月分组计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql根据日周月分组计算 一、mysql生成默认当前日前往前的日期 1、按月份默认生成
(SELECT DATE_FORMAT( @cdate := date_add( @cdate, INTERVAL - 1 MONTH ), '%Y-%m' ) date FROM ( SELECT @cdate := date_add( CURDATE(), INTERVAL 1 MONTH ) FROM `mysql`.`help_topic` LIMIT 14) a) 生成结果
2、按天默认生成
(select (curdate() + interval (cast(`mysql`.`help_topic`.`help_topic_id` as signed) - 10) day) AS date from `mysql`.`help_topic` having (date &lt;= date_format(curdate(),'%Y-%m-%d'))) 生成结果
二、mysql按日周月分组统计 1、获取原始数据
SELECT wgwl_date_event_volume,date_processing_capacity,date_unprocessed_volume,zjg_date_event_volume,date_case_volume, overView_time FROM task_status_statistics 获取结果
2、按日统计默认最近10天的数据
SELECT SUM(b.zjg_date_event_volume)zjg_date_event_volume,SUM(b.date_case_volume)date_case_volume,temp.date overView_time FROM (select (curdate() + interval (cast(`mysql`.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37f11e0fb8308db4b5d2c49b68bc213e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158eb6b34e40bd2ab48764866a2da134/" rel="bookmark">
			​stp文件转ply
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是一 .stp 文件？
STP 文件是用于在 CAD 和 CAM 应用程序之间交换产品数据的 3D CAD 文件。它包含有关 3D 对象的信息，并以类似于STEP文件格式的方式保存。STP 文件根据STEP应用程序协议 ISO 10303-2xx 促进应用程序之间的数据交换。该 ISO 定义了 EXPRESS 数据建模语言中数据表示的编码机制。
STP 文件以纯 ASCII 文件格式保存到光盘。这些包含 3D 模型信息作为纯文本，CAD/CAM 应用程序可以读取这些信息以加载这些模型。
STP 文件也以 .step 扩展名保存，由一系列记录组成。这些文件的显着特点包括：
字符集定义为 ISO 10646 的代码点。
“ISO-10303-21；” 是第一条记录中的第一个字符。
注释由“/ ”和“ /”字符包围。
最后一条记录包含“END-ISO-10303-21;” 如果 STEP 文件符合 2002 版本。
如果符合2016版，“END-ISO-10303-21”后面可能有一个或多个数字签名；终结者。
换行符用“\N”表示，分页符用“\F”表示。
STP 文件保存为纯文本文件。这使得使用文本编辑器打开 STP 文件成为可能。Windows 操作系统上的 Notepad 和 Notepad++ 等流行的文本编辑器，以及 MacOS 上的 Apple TextEdit 都可以打开 STP 文件。在文本编辑器中打开后，用户可以编辑 STP 文件的属性。但是，如果更新属性不正确，可能会导致文件损坏。
如何转换 STP 文件为ply格式？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158eb6b34e40bd2ab48764866a2da134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0151cd27b8d9782a7c4864ea4f255488/" rel="bookmark">
			​stp文件转wrl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是一 .stp 文件？
STP 文件是用于在 CAD 和 CAM 应用程序之间交换产品数据的 3D CAD 文件。它包含有关 3D 对象的信息，并以类似于STEP文件格式的方式保存。STP 文件根据STEP应用程序协议 ISO 10303-2xx 促进应用程序之间的数据交换。该 ISO 定义了 EXPRESS 数据建模语言中数据表示的编码机制。
STP 文件以纯 ASCII 文件格式保存到光盘。这些包含 3D 模型信息作为纯文本，CAD/CAM 应用程序可以读取这些信息以加载这些模型。
STP 文件也以 .step 扩展名保存，由一系列记录组成。这些文件的显着特点包括：
字符集定义为 ISO 10646 的代码点。
“ISO-10303-21；” 是第一条记录中的第一个字符。
注释由“/ ”和“ /”字符包围。
最后一条记录包含“END-ISO-10303-21;” 如果 STEP 文件符合 2002 版本。
如果符合2016版，“END-ISO-10303-21”后面可能有一个或多个数字签名；终结者。
换行符用“\N”表示，分页符用“\F”表示。
STP 文件保存为纯文本文件。这使得使用文本编辑器打开 STP 文件成为可能。Windows 操作系统上的 Notepad 和 Notepad++ 等流行的文本编辑器，以及 MacOS 上的 Apple TextEdit 都可以打开 STP 文件。在文本编辑器中打开后，用户可以编辑 STP 文件的属性。但是，如果更新属性不正确，可能会导致文件损坏。
如何转换 STP 文件为wrl格式？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b085c0717d13494e45a6b13089bbe149/" rel="bookmark">
			​stp文件转gltf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是一 .stp 文件？
STP 文件是用于在 CAD 和 CAM 应用程序之间交换产品数据的 3D CAD 文件。它包含有关 3D 对象的信息，并以类似于STEP文件格式的方式保存。STP 文件根据STEP应用程序协议 ISO 10303-2xx 促进应用程序之间的数据交换。该 ISO 定义了 EXPRESS 数据建模语言中数据表示的编码机制。
STP 文件以纯 ASCII 文件格式保存到光盘。这些包含 3D 模型信息作为纯文本，CAD/CAM 应用程序可以读取这些信息以加载这些模型。
STP 文件也以 .step 扩展名保存，由一系列记录组成。这些文件的显着特点包括：
字符集定义为 ISO 10646 的代码点。
“ISO-10303-21；” 是第一条记录中的第一个字符。
注释由“/ ”和“ /”字符包围。
最后一条记录包含“END-ISO-10303-21;” 如果 STEP 文件符合 2002 版本。
如果符合2016版，“END-ISO-10303-21”后面可能有一个或多个数字签名；终结者。
换行符用“\N”表示，分页符用“\F”表示。
STP 文件保存为纯文本文件。这使得使用文本编辑器打开 STP 文件成为可能。Windows 操作系统上的 Notepad 和 Notepad++ 等流行的文本编辑器，以及 MacOS 上的 Apple TextEdit 都可以打开 STP 文件。在文本编辑器中打开后，用户可以编辑 STP 文件的属性。但是，如果更新属性不正确，可能会导致文件损坏。
如何转换 STP 文件为gltf格式？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c9794930a34629886a7c4a4db7ed76/" rel="bookmark">
			stp文件转stl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是一 .stp 文件？ STP 文件是用于在 CAD 和 CAM 应用程序之间交换产品数据的 3D CAD 文件。它包含有关 3D 对象的信息，并以类似于STEP文件格式的方式保存。STP 文件根据STEP应用程序协议 ISO 10303-2xx 促进应用程序之间的数据交换。该 ISO 定义了 EXPRESS 数据建模语言中数据表示的编码机制。
STP 文件以纯 ASCII 文件格式保存到光盘。这些包含 3D 模型信息作为纯文本，CAD/CAM 应用程序可以读取这些信息以加载这些模型。
STP 文件也以 .step 扩展名保存，由一系列记录组成。这些文件的显着特点包括：
字符集定义为 ISO 10646 的代码点。“ISO-10303-21；” 是第一条记录中的第一个字符。注释由“/ ”和“ /”字符包围。最后一条记录包含“END-ISO-10303-21;” 如果 STEP 文件符合 2002 版本。如果符合2016版，“END-ISO-10303-21”后面可能有一个或多个数字签名；终结者。换行符用“\N”表示，分页符用“\F”表示。STP 文件保存为纯文本文件。这使得使用文本编辑器打开 STP 文件成为可能。Windows 操作系统上的 Notepad 和 Notepad++ 等流行的文本编辑器，以及 MacOS 上的 Apple TextEdit 都可以打开 STP 文件。在文本编辑器中打开后，用户可以编辑 STP 文件的属性。但是，如果更新属性不正确，可能会导致文件损坏。 如何转换 STP 文件为stl格式？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f354d45c5dc52f9c9aa50d48b3b32102/" rel="bookmark">
			vue2 双向数据绑定实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2 双向数据绑定实现 1. html 文件 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;vue2双向数据绑定实现&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="name.firstName" placeholder="姓氏"&gt;&lt;span&gt;姓氏：{{name.firstName}}&lt;/span&gt;&lt;br&gt; &lt;input type="text" v-model="name.lastName" placeholder="名称"&gt;&lt;span&gt;名称：{{name.lastName}}&lt;/span&gt;&lt;br&gt; &lt;input type="text" v-model="phone" placeholder="手机号"&gt;&lt;span&gt;手机号：{{phone}}&lt;/span&gt; &lt;/div&gt; &lt;!-- 自定义 vue.js 文件 --&gt; &lt;script src="./vue.js"&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue({ el: '#app', data: { name: { firstName: '张', lastName: '三' }, phone: '12312' } }) console.log(vm); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f354d45c5dc52f9c9aa50d48b3b32102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10787651a33c8b3cb4e773e2c4fbd716/" rel="bookmark">
			2D转换和3D转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css 中通过 transform 属性实现对元素进行移动、缩放、旋转等变换。IE10、Firefox 以及 Opera 支持 transform 属性。为了兼容 Chrome 和 Safari 需要添加前缀 -webkit- ，IE9 需要添加前缀 -ms-。transform 属性的属性值是一系列的转换函数。用法如下：
transform: transform-function1() transform-function2() …;
注意：转换不影响到其他元素的布局。
2D转换 移动 translate(x,y)：定义 2D 移动转换，沿着 X 轴和 Y 轴移动元素。translateX(n)：定义 2D 移动转换，沿着 X 轴移动元素。translateY(n)：定义 2D 移动转换，沿着 Y 轴移动元素。 缩放 scale(x,y)：定义 2D 缩放转换，改变元素的宽度和高度。scaleX(n)：定义 2D 缩放转换，改变元素的宽度。scaleY(n)：定义 2D 缩放转换，改变元素的高度。 旋转 rotate(angle)：定义2D旋转，在参数中规定旋转的角度（正值为顺时针，负值为逆时针）。 倾斜 skew(x-angle,y-angle)：定义 2D 倾斜转换，沿着 X 轴和 Y 轴。skewX(angle)：定义 2D 倾斜转换，沿着 X 轴。skewY(angle)：定义 2D 倾斜转换，沿着 Y 轴。 以上需要两个参数的变换函数如果只传入一个参数则默认第二个为 0，为了代码的可读性尽量使用单个参数的变换函数代替。缩放中值大于 1 表示放大，小于 1 表示缩小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10787651a33c8b3cb4e773e2c4fbd716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/010781db8b1f058b1c737680b03ab429/" rel="bookmark">
			Mac显示隐藏文件目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用mac本，配了ssh，找不到
再说我git呢，也找不到。一 which git ，出来什么usr目录
寻思也没看见这目录呀，于是估计它是被隐藏了，那么如何查看呢
command+shift+. 就可以看到啦，再操作一次的话就隐藏
之前：
之后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc986259e67219594e8d5f6015eee57/" rel="bookmark">
			JavaWeb快速入门 EL和JSTL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、思维导图（深度了解EL和JSTL）
二、域对象（在JSTL中有控制作用域的作用）
四大作用域对象：
三、EL 表达式
1. 概述
2. 基本语法格式：
3. 示例代码
4. "."与"[ ]"的相同点和差别
5. EL表达式中的操作符
6.EL关系运算符有以下六个运算符
四、JSTL库
五、JSP中的3496：
一、思维导图（深度了解EL和JSTL） 二、域对象（在JSTL中有控制作用域的作用） 四大作用域对象： 1. page 域（pageContext）：只能作用于当前页面，既不能用来做做转发的数据分享，也不能做重定向的数据分享。
2. request 域：只能作用于同一个请求的数据共享，所以只能在请求的转发中使用。
3. session 域：只能作用于一次对话中共享数据（一次对话：用户打开浏览器，浏览多个web站点后，关闭该浏览器），转发和重定向都可以使用
4. context 域（application）：只能在同一个web应用中使用。（全局的） 三、EL 表达式 1. 概述 EL 是 JSP 表达式语言，全称是 ExpressionLanguage，使用 EL 的目的是简化在 JSP 中访问变量的方式，简单静态 HTML 与 Java 代码的耦合。
2. 基本语法格式： ${ EL Expression}
3. 示例代码 ${ "Helloworld" } // 输出字符串常量
${ str } // 输出字符串变量 str 的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfc986259e67219594e8d5f6015eee57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd2673e31babea2056eeb67e81805f29/" rel="bookmark">
			linux：将进程切换到后台且不退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 如果需要在后台执行且关闭shell不退出，在程序启动命令中加入 &amp;如果开始没有加入 &amp;，发现命令执行时间很长，可以参考本文 将进程切换到后台且不退出 将进程切换到后台（Ctrl + Z）让进程在后台继续执行（bg x）使用exit命令退出当前shell，进程不退出 将进程暂停且切换到后台 使用Ctrl + Z将命令暂停切换到后台。Ctrl + Z 是将任务中止（暂停的意思）,但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态
shell&gt; wget https://download.filezilla-project.org/client/FileZilla_3.60.2_win64_sponsored-setup.exe --2022-08-06 10:56:21-- https://download.filezilla-project.org/client/FileZilla_3.60.2_win64_sponsored-setup.exe Resolving download.filezilla-project.org (download.filezilla-project.org)... 49.12.121.47, 2a01:4f8:242:52d0::2 Connecting to download.filezilla-project.org (download.filezilla-project.org)|49.12.121.47|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 11854128 (11M) [application/x-msdos-program] Saving to: ‘FileZilla_3.60.2_win64_sponsored-setup.exe.2’ 1% [&gt; ] 122,880 30.2KB/s eta 6m 19s ^Z (输入Ctrl + Z) [1]+ Stopped wget https://download.filezilla-project.org/client/FileZilla_3.60.2_win64_sponsored-setup.exe 查看后台的进程 shell&gt; jobs -l [1]+ Stopped wget https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd2673e31babea2056eeb67e81805f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01fa87a949b9f038d35bf914974c9484/" rel="bookmark">
			微积分 Calculus 学习笔记（周更）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微积分 Calculus（周更） 一、单变量微积分 One Variable CalculusPart 1 导数 derivativeUnit1 导数 极限 连续1 导数的一般定义2 极限 limits3 连续 continuity4 求导 Unit2 导数的应用1 线性近似2 曲线构图问题 环在绳上的位置3 牛顿迭代法4 中值定理 Mean Value Theorem Part 2 积分 integrationUnit3 微分 differentials1 无穷小量与不定积分2 微分方程与分离变量 单词 MIT公开课
学习目的：回顾相关知识点。
一、单变量微积分 One Variable Calculus Part 1 导数 derivative Unit1 导数 极限 连续 1 导数的一般定义 单变量微积分并不指问题中变量唯一，而是求导的只对某一个变量几何解释：割线两点，固定一点，移动另一点，当两点无限接近时，割线即为切线，其斜率也即该点的导数
2 极限 limits left-hand limitright-hand limit 特殊函数求极限
3 连续 continuity 连续的条件 左右极限存在且相等函数值存在极限与函数值相等 不连续的四种情况 跳跃间断 jump discontinuities可去间断 removable discontinuities无穷间断 infinite discontinuities其他间断典型的分段函数，左右极限不等连续的曲线上，某点不存在，或不在线上比如双曲线振荡型的，如sin(1/x) 可导必连续 differentable implies continuous
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01fa87a949b9f038d35bf914974c9484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36411bdd46c057278edf8f437316ae3a/" rel="bookmark">
			leetcode-数组系列算法总结-java版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[仅个人学习使用]
文章目录 题目所属分类一、leetcode 704二分查找原题链接题解 二、leetcode 35. 搜索插入位置原题题解1第二种解法2 三、[leetcode27. 移除元素](https://leetcode.cn/problems/remove-element/)题解 四、 [leetcode 977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)题解 五、[leetcode 209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)题解解法1 O（n)解法2 前缀和 + 双指针 时间复杂度 O(n)解法3 前缀和 + 二分 时间复杂度 O(nlogn) 六、leetcode 76. 最小覆盖子串题解 七、leetocde 904. 水果成篮题解 八、leetocde 59. 螺旋矩阵 II题解 九、[leetcode 3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)题解 题目所属分类 摘抄代码随想录中的算法总结 从leetcode中截取部分为数组一类的算法题合集 此部分为数组系列
包括动态窗口 双指针加哈希表 二分查找模板 共九道题
一、leetcode 704二分查找 原题链接 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
代码案例1：输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36411bdd46c057278edf8f437316ae3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd219d0ef4261df23313f20a1a2ccf4f/" rel="bookmark">
			TRACE32——AMP多核调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TRACE32——AMP多核调试 之前有一篇文章介绍过芯片的SMP多核调试，适用于同架构的内核运行同一套操作系统的场景。例如英飞凌的TC275TF芯片的三个TriCore核以SMP的方式运行着AutoSar操作系统。
但随着芯片的使用场景越来越复杂，芯片厂商推出的SoC可能会同时集成不同架构的内核用于不同的功能。
例如TI公司推出的TDA4VM芯片含有Cortex-M3、Cortex-R5、Cortex-A72、C66x DSP、C7x DSP等不同架构的内核。
不同架构的内核有不同的指令集、有不同的代码空间、运行不同的操作系统，所以也需要不同的TRACE32窗口（GUI）来进行调试。但此时TRACE32 GUI之间共享一个劳特巴赫设备以及一个JTAG调试接口：
传统方式调试AMP
如果是在Windows PC机上，我们可以使用TRACE32 Start程序进行配置AMP调试环境。根据需要调试的内核架构，添加相应的配置项即可。
配置好后，只需在Configuration名字处（图中是TDA4的位置）或者1:PodBus Device Chain处右键，点击Start，便会自动打开所有核的调试窗口。
关于TRACE32 Start的使用方法可以参考app_t32start.pdf
由于AMP多核调试时，可能会使用Trace（跟踪）功能，为了便于TRACE32更好地处理多核之间的Trace数据，建议在各个GUI中，执行如下命令
System.config 在每个GUI中修改此处的参数：
对于绝大部分情况，此处参数的配置原则为：
core：任意数字，各个GUI之间不重复即可。
推荐按窗口顺序填写：
即第一个GUI的值写1. 第二个GUI的值写2.以此类推
chip：各个GUI之间保持为相同值
推荐都写1.
有时候，AMP多核调试时，可能会希望主核开始运行时，其他从核也能同步运行起来。此时，可以执行Synch命令进行相应的同步配置：
注意：使用Synch功能的前提是，每个GUI都打开了InterCom Port。具体操作方法可以参考文档：
general_ref_s.pdf的Synch章节ide_ref.pdf的InterCom章节 新方法调试AMP
如果在Linux PC上使用TRACE32，可能没有TRACE32 Start。因此TRACE32推出了更高效更通用的方法（需要2020年以后的TRACE32版本），主要为下面两个命令组
//用于打开新的GUI、查看已经打开的GUI TargetSystem //用于GUI之间的通信、跨GUI之间执行命令 InterCom 以TI芯片TDA4VM为例，AMP相关调试方法如下：
按照正常方式启动第一个TRACE32 GUI用于第一个内核/子系统的调试。
例如，TDA4VM的MCU域的R5 SMP 多核子系统
在调试过程中，如果需要同时调试其他内核/子系统，可以使用这条命令再启一个TRACE32 GUI：
TargetSystem.NewInstance &lt;新窗口名字&gt; /ARCH &lt;新窗口架构&gt; // 其中新窗口名字，可以任意取名 // 架构名可选的有： // - ARM：所有ARM核 // - ARM64：2022年开始的TRACE32版本不区分ARM和ARM64，任选一个即可 // - Tricore: 英飞凌Tricore核 // - C6000 // - C7000 // - 等等，更多的架构可以在TRACE32命令行下方的提示栏中进行选取 例如希望调试TDA4VM MAIN0域的R5 SMP子系统，新打开的GUI调试的架构，和当前GUI调试的架构一样时，/ARCH参数可省略：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd219d0ef4261df23313f20a1a2ccf4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa63f659224539101db3438e1fc03c39/" rel="bookmark">
			牛客网——序列中删除指定数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动地址：CSDN21天学习挑战赛
目录
前言
一、序列中删除指定数字
二、解题步骤
1.分析问题
2.错误代码如下
3、修改之后：
总结
前言 今天笔者学了有序序列插入一个数组，和各位分享一下。
一、序列中删除指定数字 题目来源：
序列中删除指定数字_牛客题霸_牛客网
二、解题步骤 1.分析问题 本道题主要是在一个有序序列里删去一个指定数字，这就要我们去比对了。
2.错误代码如下 我最开始的思路：
我想先顺序查找，找到一样的了交换到下一位，最后输出的时候我输出少一位把最后那个给去掉
#include&lt;stdio.h&gt; int main(){ int n=0,a=0,b=0; int arr[51]={0}; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++){ scanf("%d ",&amp;arr[i]); //循环输入构成数组 } scanf("%d",&amp;a); for(int j=0;j&lt;n;j++){ if(a==arr[j]){ //找出输入整数a的位置 b=arr[j]; //接下来的步骤是交换位置 arr[j]=arr[j+1]; arr[j+1]=b; } } for(int k=0;k&lt;n-1;k++){ //n-1是为了少输出一位，达到删去效果 printf("%d ",arr[k]); } return 0; } 以上就是我自以为完美的过程。
但是它有一个问题：
它只能去掉一个需要去掉的数字！！只能比对一个！
因为我们只抓住了第一个就有放开，一直抓着它往后面推，其他的不管一不一样都不管了。
3、修改之后： 其实很简单。
#include&lt;stdio.h&gt; int main(){ int n=0,a=0,b=0; int arr[51]={0}; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++){ scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa63f659224539101db3438e1fc03c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422f32fd0be59a3f586fe6db6d7a9465/" rel="bookmark">
			【收藏向】LaTeX 符号大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 你想找的LaTeX符号，这里都有🥰
目录
一、希腊字母
二、古希腊字母
三、单目运算符
四、双目运算符 五、二进制运算符
六、集合符号 七、逻辑符号
八、几何符号
九、分隔符
十、箭头 十一、三角函数
一、希腊字母 二、古希腊字母 三、单目运算符 四、双目运算符 五、二进制运算符 六、集合符号 七、逻辑符号 八、几何符号 九、分隔符 十、箭头 十一、三角函数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d811385b08012b8779dd648f8a6d379/" rel="bookmark">
			极大似然估计和交叉熵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、极大似然估计三、交叉熵1. 信息论2. 交叉熵损失函数 四、总结 一、前言 对于一个多分类问题 (假设为 K K K 类), 有数据集 D = { ( x i , y i ) ∣ i } D = \{ \ (x_i,y_i \ ) \mid i \} D={ (xi​,yi​ )∣i}. 我们希望建立模型去建模概率分布 p θ ( y ∣ x ) p_{\theta}(y \mid x) pθ​(y∣x), 模型参数为 θ \theta θ.
我们使用损失函数评价模型的好坏, 可以采用两种方式来导出.
二、极大似然估计 由于是多分类问题, 在样本空间上的 p ( y ∣ x ) p(y \mid x) p(y∣x) 满足某个分类分布.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d811385b08012b8779dd648f8a6d379/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/130/">«</a>
	<span class="pagination__item pagination__item--current">131/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/132/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>