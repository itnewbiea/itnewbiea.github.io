<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282d2a6e31c7054d5f8f24ae5e250897/" rel="bookmark">
			Linux各目录及每个目录的详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux各目录及每个目录的详细介绍
【常见目录说明】
目录
/bin
存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。
/etc
存放系统管理和配置文件
/home
存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
/usr
用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。
/usr/x11r6 存放x window的目录
/usr/bin 众多的应用程序 /usr/sbin 超级用户的一些管理程序 /usr/doc linux文档 /usr/include linux下开发和编译应用程序所需要的头文件 /usr/lib 常用的动态链接库和软件包的配置文件 /usr/man 帮助文档 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里 /usr/local/bin 本地增加的命令 /usr/local/lib 本地增加的库
/opt
额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。
/proc
虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。
/root
超级用户（系统管理员）的主目录（特权阶级^o^）
/sbin
存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。
/dev
用于存放设备文件。
/mnt
系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。
/boot
存放用于系统引导时使用的各种文件
/lib
存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。
/tmp
用于存放各种临时文件，是公用的临时文件存储点。
/var
用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。
/lost+found
这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里
Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录，如下图：
/bin 二进制可执行命令
/dev 设备特殊文件
/etc 系统管理和配置文件
/etc/rc.d 启动的配置文件和脚本
/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件
/sbin 超级管理命令，这里存放的是系统管理员使用的管理程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/282d2a6e31c7054d5f8f24ae5e250897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13f916e7cce51884b2379d7f061a7f67/" rel="bookmark">
			scroll-view去掉滚动条属性（个人笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ::-webkit-scrollbar { width: 0; height: 0; color: transparent; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c02d2a48450d92faa2c4bf13a4e3796/" rel="bookmark">
			常见Linux命令（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、常见Linux命令 cat /etc/issue 查看版本cat /etc/redhat-release 查看CentOS版本cat /proc/versionuname -a 显示如下uname -rls -lht会列出当前目录下每个文件的大小，同时也会给出当前目录下所有文件大小总和du -sh 也会列出当前文件夹下所有文件对应的大小【把替换为具体的文件名，会给出具体文件的大小】cat /proc/sys/kernel/hostname 放置hostname对应的位置lsblk 查看的是block device,也就是逻辑磁盘大小。df查看的是file system, 也就是文件系统层的磁盘大小。fdisk -l 显示的是各个块设备的大小os.chmod(path, 0o644) 给文件加权限os.unlink(filename) 删除某个文件win+R 之后两个反斜线+对应的ip地址，可以实现远程文件共享ps -ef | grep -c “ssh” 显示的是与ssh相关进程的总的个数journalctl -xe 查看系统日志grep -q /file 看文件中是否有匹配，若有，立即返回0grep -o ‘haha’ file | wc -l | wc -l (匹配到的个数)grep -c ‘haha’ filegrep -n ‘the’ a.txt //-n为显示匹配行以及行号w 查看最近对本电脑操作的记录du -h --max-depth=1 ./ 查看当前文件夹大小grep --col -r -n JobOneView /etc/httpd/ 查看文件中是否有匹配到的东西关闭防火墙setenforce 0 | systemctl stop firewalld | systemctl disable firewalld | systemctl stop NetworkManager | systemctl disable NetworkManager
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c02d2a48450d92faa2c4bf13a4e3796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded11f65e65b54e21571271778e87642/" rel="bookmark">
			Mysql 增加rownum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql 增加rownum 实现（极度推荐） mysql本身不像oracle那样使用 rownum 来显示行号的功能.但是可以使用设置变量的方式来实现这一功能.mysql使用 @ 定义用户变量, @@ 定义系统变量.查询显示的具体代码 SELECT @rownum:=@rownum+1 AS rownum, frutas.*
FROM (SELECT @rownum:=0) r, frutas;
转载于:https://www.cnblogs.com/liqu/p/9921916.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9e3806a2bd9cbdf1968980749ccacd/" rel="bookmark">
			C语言中常用的几个头文件及库函数 (stdio.h ,string.h ,math.h ,stdlib.h)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（参考：https://www.jb51.net/article/124594.htm）
#include&lt;stdio.h&gt; 或 #include"stdio.h"
用#include&lt;stdio.h&gt;形式时，编译系统从存放C编译系统的子目录中去找所包含的文件stdio.h，这称为标准方式。
用#include"stdio.h"形式时，编译系统先在用户的当前目录(用户存放源程序文件的子目录)中寻找stdio.h，若找不到，再按标准方式查找。如果该头文件不在当前目录，可加入路径如（#include "C:\temp\file1.h"）。
不完全统计，C语言标准库中的头文件有15个之多，所以我主要介绍常用的这四个头文件stdio.h ,string.h ,math.h ,stdlib.h ，以后用到其他的再做补充。下面上干货：
1.&lt;stdio.h&gt;：定义了（standard input &amp; output的缩写）输入输出函数、类型以及宏，函数几乎占了标准库的1/3。 （1）文件访问。
1
FILE *fopen（“filename”，“mode”）：
以mode模式打开地址为'filename'的文件，并返回文件指针。
访问模式主要是“r”：只读； “w” ：只写，并删除已有内容； “a”：追加，在末尾追加；
“r+”， “w+”：读写； “a+”追加，上述结尾加“b”：二进制文件操作。
注意：其中r是打开文件，而w会创建（如果文件不存在）； w会覆盖原有内容，a则是在原有文件末尾追加。
FILE *fp ; / 定义一个指向文件的指针变量fp fp = fopen("a1","r"); / 将fopen函数的返回值(a1文件信息区的起始地址)赋给指针变量fp 表示要打开名字为“a1”的文件，使用文件方式为"r"读入。 2
int fclose（FILE *f）：
fclose(文件指针); 释放缓冲区数据，关闭流。如：fclose(fp); 前面曾把打开文件(用fopen函数)时函数返回的指针赋给了fp，现在把fp指向的文件关闭，此后fp不再指向该文件。当成功执行操作，则返回值为0，否则返回EOF(-1)。
下面两个没太用过：
1
FILE *freopen（“filename”，“mode”，FILE * f）：
以mode模式打开地址为'filename'的文件，并将该文件与流f2关联。
1
int fflush（FILE *f）：
将已写到缓冲区但未写入文件中的所有数据写入文件中。
（2）二进制输入/输出
1
fread（*ptr，size，n，FILE* f）：
从f中读取n个长度为size的对象，并放入ptr指向的数组中。
1
fwrite（*ptr，size，n，FILE* f）：
从ptr指向数组中读取n个长度为size的对象，并写入f中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9e3806a2bd9cbdf1968980749ccacd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad86a04b45cccb5e7295490f1ada2b13/" rel="bookmark">
			解决linux部署tomcat 报错不支持java.lang.NoClassDefFoundError: com/sun/image/codec/jpeg/JPEGCodec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于新版本jdk1.8不再支持JPEGCodec，导致报错，需要修改方法
1.----------------------------------------------------
JPEGImageDecoder jpegDecoder = JPEGCodec.createJPEGDecoder(is);
BufferedImage buffImg = jpegDecoder.decodeAsBufferedImage();
换成新方法
BufferedImage buffImg=ImageIO.read(is);
2.-----------------------------------------------------
JPEGImageEncoder en = JPEGCodec.createJPEGEncoder(os);
en.encode(buffImg);
换成新方法
ImageIO.write(buffImg, "jpeg", os);
--------------------------end-------------------------------
如果启动还报错，说明tomcat下面没有设置缓存目录
1、在tomcat下新建temp目录; 2、与方法1相似，通过ImageIO.setCacheDirectory(cacheDirectory);设置任意的、存在的缓存目录
3、ImageIO默认是使用缓存目录，可以通过ImageIO.setUseCache(false)来设置，更改缓存策略，不使用文件目录缓存，使用内存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf0c6cea80d28c562838af869356ce2/" rel="bookmark">
			boostrap 弹出确认框（删除确认）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将以下代码拷贝到引入boostrap的页面上即可。
&lt;button type="button" class="btn btn-danger" data-toggle="modal" data-target="#deleteModal"&gt;删除&lt;/button&gt; &lt;div class="modal fade" id="deleteModal" tabindex="-1" role="dialog" aria-labelledby="deleteModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;×&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="deleteModalLabel"&gt;确认框&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;form&gt; &lt;div class="form-group"&gt; &lt;label class="control-label"&gt;确定要删除吗？&lt;/label&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;返回&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;确认&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6156ff7ad860bfde5e4aacccbc7bdd22/" rel="bookmark">
			RocketMq 本地学习时遇到的客户端重启会重复消费的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本地学习RocketMq 时，即使在消费端设置了
consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
在重启消费端时，还是会重新读取队列中已经消费过的消息，后来发现是由于 rocketmq-client 客户端版本和服务端版本不一样导致，经更换客户端版本使其与服务端版本保持一致后，重启重复消费的问题也解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d266d93b48aede28eef02b01601a090/" rel="bookmark">
			自相关函数与互相关函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/denghecsdn/article/details/78848046
1、概念
相关函数是描述信号X(s),Y(t)（这两个信号可以是随机的，也可以是确定的）在任意两个不同时刻s、t的取值之间的相关程度。两个信号之间的相似性大小用相关系数来衡量。定义：
称为变量 X 和 Y 的相关系数。若相关系数 = 0，则称 X与Y 不相关。相关系数越大，相关性越大，但肯定小于或者等于1.。相关函数分为自相关和互相关。下面一一介绍
（1）、自相关函数
自相关函数是描述随机信号 x(t) 在任意不同时刻 t1,t2的取值之间的相关程度。自相关函数，是对信号自身的互相关,表示同一序列不同时刻的相关程度。是用寻找重复模式的数字工具，就如一个存在被覆盖噪声的周期信号，或识别丢失的基频。它经常被用于信号处理中的分析函数或序列，如时域信号 。定义式：
主要性质如下：
（1）自相关函数为偶函数，其图形对称于纵轴。
（2）当s=t 时，自相关函数具有最大值，且等于信号的均方值，即
（3）周期信号的自相关函数仍为同频率的周期信号。
（2）、互相关函数
自相关是互相关的一种特殊情况.。互相关函数是描述随机信号 x(t)、y(t) 在任意两个不同时刻s，t的取值之间的相关程度,其定义为：
对于连续函数，有定义：
对于离散的，有定义：
从定义式中可以看到，互相关函数和卷积运算类似，也是两个序列滑动相乘，但是区别在于：互相关的两个序列都不翻转，直接滑动相乘，求和；卷积的其中一个序列需要先翻转，然后滑动相乘，求和。所以，f(t)和g(t) 做相关等于 f*(-t) 与 g(t) 做卷积。
在图象处理中，自相关和互相关函数的定义如下：设原函数是f(t)，则自相关函数定义为 R(u)=f(t)*f(-t)，其中*表示卷积；设两个函数分别是f(t)和g(t)，则互相关函数定义为R(u)=f(t)*g(-t)，它反映的是两个函数在不同的相对位置上互相匹配的程度。
2、物理意义
两个相关函数都是对相关性，即相似性的度量。如果进行归一化，会看的更清楚。
自相关就是函数和函数本身的相关性，当函数中有周期性分量的时候，自相关函数的极大值能够很好的体现这种周期性。互相关就是两个函数之间的相似性，当两个函数都具有相同周期分量的时候，它的极大值同样能体现这种周期性的分量。
相关运算从线性空间的角度看其实是内积运算，而两个向量的内积在线性空间中表示一个向量向另一个向量的投影，表示两个向量的相似程度，所以相关运算就体现了这种相似程度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dec2e880fc6da59672a6a8f0b9577b1/" rel="bookmark">
			Nvidia的Xavier片上系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://tech.sina.com.cn/roll/2018-01-10/doc-ifyqptqv6797875.shtml
https://baijiahao.baidu.com/s?id=1606141898402543334&amp;wfr=spider&amp;for=pc
来自拉斯维加斯的消息——显卡芯片巨头Nvidia周日推出由Xavier驱动的下一代自动驾驶堆栈，此堆栈是Nvidia在砸在汽车AI上20亿美元的研发结果。
Nvidia称Xavier 是“世界上最强大的SoC（片上系统）”，Xavier可处理来自车辆雷达、摄像头、激光雷达和超声波系统的5级自主驾驶数据，能效比市场上同类产品更高，体积更小。
Xavier的内置晶体管超过90亿个，含一颗定制的8核CPU、一颗512核Volta GPU、一个8K HDR视频处理器、一个深度学习加速器、数个新型计算机视觉加速器以及30瓦功率下每秒可执行30万亿次操作的能力。
Xavier曾于一年前在新闻里出现过，但Nvidia表示Xavier现在已经成了两个软件平台（Drive IX和刚刚宣布的Drive AR）的根基，Drive IX和Drive AR均为Nvidia旗下Pegasus AI计算平台的一部分。Nvidia首席执行官Jensen Huang周日晚间在CES上做主题演讲时宣布了推出该新平台的消息。
Nvidia的Xavier片上系统。
Drive IX属于人工智能层，Nvidia表示，汽车制造商利用Drive IX可以将汽车数据整合到汽车用户体验和操作控制里。Drive IX系统可分析汽车内部和外部的传感器数据，继而为司机和乘客提供智能助理技术，可识别司机和乘客的脸部、声音和手势。
对于Nvidia而言，自主驾驶和领导地位意味着更多用于高性能计算以及云计算的GPU使用案例。
Nvidia也在大力推动Drive IX的使用，希望Drive IX成为车辆安全性和便利性的终极SDK。例如，利用面部识别和视线跟踪，Drive IX系统可以在手握驾驶盘、昏昏欲睡的司机睡着以前发警报提醒他们，或是根据脸部识别在满载一袋袋生活用品的车辆到来时自动打开出入口的门。
而Drive AR则是面向信息娱乐应用，Drive AR基本上会掀起计算机视觉、计算机图形、人机交互、AI的热潮并将成为车内增强现实接口的强大动力。Nvidia还推出了AutoSim，AutoSim是个模拟虚拟驾驶环境，用户利用该虚拟驾驶环境可在生产前配置车辆上的摄像头。
Huang表示，“增强现实将定义用户界面。”
一切都与Drive Pegasus AI计算平台相关，Nvidia称Drive Pegasus AI “可将一整车个人电脑的性能放在自动级别外形规格里交付，这些外形规格只有车牌照那么大“，而处理能力可达每秒320万亿次操作。对于Nvidia的客户来说，Pegasus主板据称将是生产完全自动驾驶汽车之路。
Huang表示，“我们开发了整套自主车辆软件。我们现在有超过300个客户在开发Nvidia Drive。”
其他涉及客户的新闻，Nvidia日前透露，德国汽车制造商大众汽车（Volkswagon）计划在Drive IX平台上开发下一代智能大众汽车。大众汽车首席执行官赫伯特·迪斯（Herbert Diess）登台介绍了新的大众汽车I.D. Buzz。大众汽车I.D. Buzz为一电动汽车原型，大众汽车希望大众汽车I.D. Buzz将巩固自己在汽车AI计算市场的霸主地位。
优步（Uber）也出柜成为Nvidia的客户，坊间消息称拼车巨头优步已经在旗下的自动驾驶汽车和卡车车队中用上了基于Nvidia GPU的AI计算系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f25433708c1c19546f0e786e1ecae05/" rel="bookmark">
			double型比较大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于两个double类型的数，我们一般不直接比较他们的大小，因为计算机在表示小数时都有误差，我们一般认为偏差在一个较小的范围内则两个数据是相等的。 一般我们是这样做的：通过设定一个允许的误差值，对待判断是否相等的两个double类型数据做差求绝对值再和允许的误差做比较来判断是否相等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c62b154407cafa2c91b33a36cdb16b/" rel="bookmark">
			前端解决传入后台的中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 判断是否是中文: function Chinese(temp) { let re = /[^\u4e00-\u9fa5]/; if (re.test(temp)) return false; return true; } 如下: 传入后台的中文如果是乱码的格式,可以以如下方式处理,会把中文转换为16进制的形式:
let name = "小可爱"; name = encodeURI(name); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fbf63b3da245011a2bf5cee77d6e67/" rel="bookmark">
			poj-2031
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C - Building a Space Station 题意：在一个三维空间里建造球形的小室，若小室相邻或部分重叠，或者间接有走廊间接相连，则两个小室相连通，给出ｎ个小室，下面ｎ行每行分别是ｎ个小室的球形空间坐标，和球形小室的半径长度。找出让所有球形小室联通所需要建造长廊的最短距离。
思路：相邻两球的距离用球心坐标，和两个球心半径比较。二维数组邻接矩阵存图，两个小室之间所需要长廊的距离为两点之间的权值，若相邻，或重叠，权值为０，最小生成树，找出最短路径。
反思：struct 里x,y,ｚ都要是double型，ｍinn存ｄis数组，也是double型
//
// Created by xrm on 18-11-2.
//
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
using namespace std;
const int maxn=105;
const int inf=0x3f3f3f3f;
double Graph[maxn][maxn];
double dis[maxn];
bool vis[maxn];
struct node{
double x,y,z,r;
}p[maxn];
int N;
double length(node a,node b){
double l;
l=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z);
l=sqrt(l);
if(l-a.r-b.r&lt;0)
return 0;
else{
return l-a.r-b.r;
}
}
double prim(){
double ans=0;
for(int i=0;i&lt;N;i++){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2fbf63b3da245011a2bf5cee77d6e67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db3dfdc2704cfc4d4027337cf963bc9/" rel="bookmark">
			UltraSoC全新集成化多核调试、可视化和数据科学/分析套件扩展其工具产品线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UltraSoC日前宣布推出完整的集成开发环境（IDE）UltraDevelop 2，它为系统级芯片（SoC）开发团队提供了将全面的调试、运行控制和性能调整与先进的可视化和数据科学功能相结合的能力。通过融合UltraSoC合作伙伴Imperas和Percepio的技术，UltraDevelop 2释放出了UltraSoC系统级片上监控和分析基础架构的潜力，通过提供可操作的内在信息来大幅降低开发成本和缩短达成收入的时间，并提高产品的质量。
新的UltraDevelop工具套件为SoC开发和调试提供了一种全面的、系统级的方法，从而支持工程师在任何抽象级别上去查看和分析硬件、固件和软件间的相互关联行为，并根据当前的任务在视图和工具之间去进行交互性地切换。UltraSoC新开发的数据分析扩展项提供了诸如异常检测、热点图分析和根本原因分析等先进功能。基于Percepio Tracealyzer工具的可视化功能可为工程师提供硬件操作和高阶软件执行的集成化可视性。而加入Imperas的MPD调试器，则可为当今的多核、多线程平台提供支持，包括那些将基于不同CPU架构的内核组合到复杂异构系统之中的器件。
基于行业标准的Eclipse平台，UltraDevelop 2提供了一个其中包含单步和断点代码执行状态的集成化可视环境，可用于SoC内硬件结构上的多个处理器、指令跟踪、以及实时和协议自适应的总线监控。工程师可以同时查看诸如内存控制器和互连/ NoC等硬件结构行为，以及所有通过多个不同内核的、甚至是不同架构的软件执行。简单单核调试的设计人员可以访问相同的集成化调试功能，同时使用开源GDB调试器。
UltraDevelop 2的架构可为SoC设计人员在选择开发平台时提供平衡功能和灵活性的最优方案。它包括一个调试适配器库，它可以对来自多家供应商的20多种处理器内核架构进行实时运行控制，这些供应商包括Arm、MIPS和RISC-V（由Andes、Esperanto和SiFive开发）等。在统一的Eclipse环境中，工程师团队可以从诸如Lauterbach等UltraSoC现有合作伙伴中选择去部署第三方工具，这些合作伙伴从底层就支持UltraSoC硬件功能，或者他们也可以选择UltraSoC提供的预集成配置。
通过添加新的分析和数据科学功能，UltraSoC独立于供应商的、系统级的硬件/软件调试方法得到了显著增强。UltraDevelop 2提供了一套可以对片上行为进行详细大数据分析的模块，可实现包括异常检测、热图分析和根本原因分析。这些包括案例应用和配置，例如用于诸如ISO26262和其他标准中强制实施的严格验证和确认等功能安全性、检测漏洞或不必要的互动的网络安全、以及诸如识别多线程软件栈中的低效率和在高性能计算环境中导致“长尾”错误的、难以发现的状态等性能优化。
UltraDevelop 2用户可以通过一系列脚本（Python）化模组来扩展这些功能、自定义框架和配置测试系统，这些模组可以直接访问UltraSoC片上监视器提供的数据。这些也提供了诸如终端服务等配置选项和更高级别的功能。
在UltraDevelop 2中加入的Percepio的Tracealyzer工具，为UltraDevelop套件带来了强大的数据分析和可视化功能，这使得硬件和软件开发两者相互结合。Tracealyzer工具“了解”软件或实时操作系统（RTOS）中高级事件的含义，连接相关事件和可视环境，并通过对系统级操作进行高度直观的、视觉化的展望，补充了UltraSoC硬件监视器收集的信息。它集成了一个非常快速和小巧的数据库，可以有效地显示、过滤或分析TB级的Trace文件。
通过集成Imperas的MPD，可允许UltraDevelop 2用户在一个平台中同时对多个应用处理器进行调试，包括单核、多核和多线程变量。外设可以同时与应用一起调试，让开发人员看到运行在平台和应用代码的上下文中的外设，并进一步扩展UltraDevelop 2的硬件/软件协同开发能力。这项集成是两家公司于2018年6月宣布建立广泛合作伙伴关系中的一部分，这将把嵌入式分析和虚拟平台技术结合在一起形成强大的合力，并推动统一的系统级流片前和流片后硅开发流程。
为了进一步实现为开发人员带来更高选择性和灵活性的目标，并为了支持可扩展性，UltraDevelop 2利用了行业标准接口，如Eclipse目标通信框架（TCF）、GDB远程串行协议（RSP）和压缩类型格式（ CTF），以及MI这种通常用于在调试器后端和IDE前端之间进行通信的机器接口层。 此外，UltraSoC利用OpenOCD项目并添加自定义扩展，以通过其片上监控和分析硬件来提供调试支持，并将结果发布回开源社区以支持下一步的开发。
UltraDevelop 2将于2019年第一季度向个别客户提供，不久后将全面上市。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6362076683964ee5bd1ee0de7ceed5ff/" rel="bookmark">
			windows窗口命令——(copy/b)文件无缝拼接隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你浏览到这里的时候，想必会有一些小秘密或者私人文件需要隐藏但是又逃不过别人的多层“扫描”，那么今天我做了一个小例子，可能大家都听说过，我这里想再细细说一下。
首先介绍一下这个命令：copy /b 文件名1+文件名2+......文件名N 合并后的文件名
这里的文件名是带有后缀的文件名
例如：在我的盘符里的两个文件：
我现在想把那个压缩包文件隐藏，但是图片又能够正常浏览，
那么就可以用这个命令：copy /b 文件名1+文件名2+......文件名N(空一个格 )合并后的文件名
因为想正常浏览图片,那么就可以把合并后的文件名字的文件格式保存为第一个文件的格式(也就是你想要正常浏览的那个文件格式)
这个命令可以这样写：copy/b 1.jpg+2.zip 3.jpg
然后我们打开我们的命令行窗口:
输入cmd,回车进入。如图：
因为我的文件在E盘，所以切换一下盘符，把刚才的命令输入。如图
然后按一下回车，会发现文件已经提示被复制：
但是，那个文件被复制到哪里了，我们会发现，在我原来存的那两个文件的同一目录下多出了一个文件——3.jpg
当然，这个文件从打开方式上是图片，
那么，原来的那个文件从哪里找到呢，因为这个文件是copy，所以，我们只要把这个文件的后缀名改成刚才的zip的后缀就可以了，如图：
打开之后，文件还是那个文件：
这就是这个命令。可能这个命令很老了，但是这也是基础，希望对大家有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5caa2a7dd360eee238300b6b5205a55/" rel="bookmark">
			点击div块进行文本编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作需要，需要实现如下一个需求，点击模板div块，跳出文本编辑器对div文本内容进行编辑。实现效果图如下：
实现思路如下：
1.给每个需要编辑的div加上contenteditable="false"属性，表示暂不可编辑，之后写一个点击事件，点击当前div将当前div的contenteditable属性改为true，其他div都改为false。
2.第二步点击右侧文本编辑时，对contenteditable属性为true的div进行样式修改。
代码如下。
&lt;link href="assets/css/vendor/bootstrap/bootstrap.min.css" rel="stylesheet"&gt; &lt;link rel="stylesheet" href="assets/js/vendor/colorpicker/css/bootstrap-colorpicker.css"&gt; &lt;body&gt; &lt;!--需要编辑的div块--&gt; &lt;div class='editable' contenteditable="false"&gt;公司使命&lt;/div&gt; &lt;div class='editable' contenteditable="false"&gt;通过互联网服务提升生活品质&lt;/div&gt; &lt;!--文本编辑器--&gt; &lt;div class="writingsize"&gt; &lt;label for="input01"&gt;字号:&lt;/label&gt; &lt;div class="writingsize-input"&gt; &lt;select class="chosen-select chosen-transparent form-control" id="input01"&gt; &lt;option value="10px"&gt;10px&lt;/option&gt; &lt;option value="12px"&gt;12px&lt;/option&gt; &lt;option value="13px" selected = "selected"&gt;13px&lt;/option&gt; &lt;option value="15px"&gt;15px&lt;/option&gt; &lt;option value="18px"&gt;18px&lt;/option&gt; &lt;option value="20px"&gt;20px&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="writingsize"&gt; &lt;label for="colorpicker"&gt;设置:&lt;/label&gt; &lt;div class="colorpicker-input"&gt; &lt;div class="jz-colorpicker" id="colorpicker"&gt;&lt;/div&gt; &lt;div class="overstriking ziti" id="overstriking"&gt;B&lt;/div&gt; &lt;div class="italicsty ziti" id="italicsty"&gt;I&lt;/div&gt; &lt;div class="underlinesty ziti" id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5caa2a7dd360eee238300b6b5205a55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ac13d873a335dfdf2c556c7d28c6a7/" rel="bookmark">
			小白用Python3.7实现CNN（非框架）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.填充
填充的目的是避免弱边缘化，且填充之后还可以保证在使用卷积计算前后卷的高和宽不变化。
1)代码
import numpy as np import h5py import matplotlib.pyplot as plt plt.rcParams['figure.figsize'] = (5.0, 4.0) plt.rcParams['image.interpolation'] = 'nearest' plt.rcParams['image.cmap'] = 'gray' np.random.seed(1) def zero_pad(X, pad): X_pad = np.pad(X, ((0, 0), (pad, pad), (pad, pad), (0, 0)), 'constant') return X_pad x = np.random.randn(4,3,3,2) x_pad = zero_pad(x, 2) print('x.shape=',x.shape) print('x_pad.shape=',x_pad.shape) print('x[1,1]=',x[1,1]) print('x_pad[1,1]=',x_pad[1,1]) fig, axarr = plt.subplots(1,2) axarr[0].set_title('x') axarr[0].imshow(x[0,:,:,0]) axarr[1].set_title('x_pad') axarr[1].imshow(x_pad[0,:,:,0]) plt.show() 2)结果图
2.单步卷积
#单步卷积 只有一个过滤器 def conv_single_step(a_slice_prev, W, b): s = a_slice_prev * W Z = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ac13d873a335dfdf2c556c7d28c6a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf0ac46c2d8d14bbff56e1592b41d1d/" rel="bookmark">
			使用element UI 快速制作一个列表页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用element制作一个列表页面，并且当点击“查看调查问卷”时弹出弹框。
（图一）
（图二）
（图三）
1. 制作一个名叫DataListTable
&lt;DataListTable v-show="showTable" :list="list" :total-num="totalNum" class="book-manage-table" @pageTurn="getSurveyList"/&gt; 2- 明确该组件里面的参数是父组件里面的值，并进行设置
data() { //data里面的值 return { showTable: true, list: [], totalNum: 0, number: 20, page: 1, }, getSurveyList(index, name) { //父组件传递给子组件的函数 const data = { //这里是获取列表数据的入参 page: 1, pagesize: 20, XX: XX, XX: XX, XX:XX, XX,XX }; DataResearch.questionList(data) //调用接口获取列表数据 .then(res =&gt; { if (res.code === 1) { if (res.data.length !== 0) { //获得列表数据处理 this.showTable = true; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccf0ac46c2d8d14bbff56e1592b41d1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabbd8d3f282d2cc80176b6721e97da1/" rel="bookmark">
			Linux网络安全技术与实现第2章之原理及实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.2 何谓netfilter netfilter的四个表是filter、nat、mangle及raw表。
filter:filter是Netfilter中最重要的机制，其任务是执行数据包的过滤操作，也就是起到防火墙的作用。nat:nat(Network Address Translation,NAT)也是防火墙上一个不可或缺的重要机制，比较通俗的方式来说，其功能就是IP分享器，只不过其所执行的功能，比一般市场上的IP分享器功能强大得多。mangle：mangle是一个很特殊的机制，我们可以通过mangle机制来修改经过防火墙内数据包内容。raw:负责加快数据包穿过防火墙机制的速度，由此提高防火墙的性能。 不同的表有属于独立的几个不同的链，而这个链的空间就是我们存放“规则”的地方。当然，不同的链其功能及用途也是不一样的。
使用filter机制来构建网关式防火墙
假设192.168.31.10是因特网上的一台主机，运行了smtp,pop3,http服务。
192.168.10.20只能访问外网192.168.31.10的smtp和pop3服务。内网主机192.168.10.0/24网段上的其它主机可以访问因特网上的DNS、SMTP、POP3，http,及sshd服务。因特网上的主机不得访问企业内的任何主机。 1 #/bin/bash 2 #===============&lt; Set Variable &gt;===================================== 3 IPT=/sbin/iptables 4 SRV=192.168.31.10 5 ACC_PC=192.168.10.20 6 #=======================&lt; Set Default Policy &gt;======================= 7 $IPT -t filter -P INPUT DROP 8 $IPT -t filter -P FORWARD DROP 9 #===============&lt; Clear Original Rule &gt;&gt; ============================= 10 $IPT -t filter -F 11 #==============&lt; Set-INPUt RULE&gt;&gt;====================================== 12 $IPT -A INPUT -p tcp -m state --state INVALID -j DROP 13 $IPT -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT 14 $IPT -t filter -A INPUT -p tcp -s 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabbd8d3f282d2cc80176b6721e97da1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c3f46a3f4a129fcc527af44466ce3c/" rel="bookmark">
			Knative 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文作者来自蚂蚁金服系统部之芥
什么是 Knative？ knative 是谷歌开源的 serverless 架构方案，旨在提供一套简单易用的 serverless 方案，把 serverless 标准化。目前参与的公司主要是 Google、Pivotal、IBM、Red Hat，2018年7月24日才刚刚对外发布，当前还处于快速发展的阶段。
这是 Google Cloud Platform 宣布 knative 时给出的介绍：
Developed in close partnership with Pivotal, IBM, Red Hat, and SAP, Knative pushes Kubernetes-based computing forward by providing the building blocks you need to build and deploy modern, container-based serverless applications. 可以看出，knative 是为了解决容器为核心的 serverless 应用的构建、部署和运行的问题。
serverless 的概念已经出现蛮久了，为了理解 serverless 可以从应用开发者的角度来看，使用 serverless 框架之后，应用开发者的整个操作流程就变成了：
~ # 编写 code 和 configuration 文件 ~ # faascli build ~ # faascli deploy ~ # curl http://myapp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56c3f46a3f4a129fcc527af44466ce3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ddac6f86952c7521f5908038802181/" rel="bookmark">
			【题解】洛谷P2296 [NOIP2014TG] 寻找道路（SPFA&#43;DFS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源：洛谷P2296
思路 一开始看还以为是一道水题 虽然本来就挺水的
本道题的难点在于如何判断是否路径上的点都会直接或者间接连着终点
我们需要在一开始多建一个反向图
然后从终点DFS回去 把路径上的点标记
DFS完之后遍历所有的点 如果当前点没有被标记 说明其不会直接或者间接连着终点
那么我们只需要把没有被标记的点在反向图中到达的点（也就是正向图中到达这个点的前一个点）标记为不计算在图内
PS：这里的标记数组要另外再建一个 如果直接改前面的数组会因为没有更新完就修改而多删除有用的点
这样我们就把所有的不需要遍历的点删除了
最后就是SPFA解决
代码 #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; #define maxn 100010 queue &lt;int&gt; q; int n,m,cnt2,cnt1,t,w,start,end; int h1[maxn],h2[maxn],dis[maxn]; bool f[maxn],vis[maxn],vis1[maxn];//f为spfa的判断 vis为反向图的判断 vis1删除点的判断 struct Edge { int to; int next; }e1[maxn*20],e2[maxn*20]; void add1(int u,int v) { e1[++cnt1].to=v; e1[cnt1].next=h1[u]; h1[u]=cnt1; } void add2(int u,int v) { e2[++cnt2].to=v; e2[cnt2].next=h2[u]; h2[u]=cnt2; } void dfs(int u) { vis[u]=1; for(int i=h2[u];i;i=e2[i].next) { int v=e2[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ddac6f86952c7521f5908038802181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2224179547e016d6a58ca172c1c36abd/" rel="bookmark">
			java通过身份证前17位计算出身份证最后一位    加权因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static void main(String[] args) {
//身份证号
String id_num = "123";
//权数数组
int[] weightArray = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};//权数数组
String vCode = "10X98765432";
int s = 0 ;
for (int i = 0; i &lt; 17; i++) {
s+= Integer.parseInt(String.valueOf(id_num.charAt(i)))*weightArray[i];
}
System.out.println(vCode.charAt(s % 11)); }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9956551e78becad909349acafdd693a3/" rel="bookmark">
			ArcGIS等高线转DEM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS实现等高线转DEM有两种方案：
1、构建TIN，由TIN生成DEM
2、直接使用地形转栅格工具
具体实现：
1、构建TIN，由TIN生成DEM 创建TIN
打开ArcToolBox
点击3D Analyst工具|数据管理|创建TIN
在弹窗中输入向相关参数，注意选择高程字段
TIN生成DEM
点击3D Analyst|转换|由TIN转出|TIN转栅格
输入相关参数
最终生成结果：
2、直接使用地形转栅格工具 使用该方法时，如果线要素较为复杂，如包含样条曲线或是点数过多，常常要使用简化线。
简化线
打开ArcToolBox
右键点击制图工具|制图综合|简化线
右键后，选择批处理
在批处理中输入要素和简化容差
点击确定，生成简化线
使用插值，地形转栅格
点击Spatial Analyst|插值分析|地形转栅格
在弹窗中输入参数，注意选择高程字段
最终生成结果：
对比以上结果，TIN转化的方法结果与普通DEM无异，而在显示时，地形转栅格工具将自动将结果分类显示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c3c0fbfc54f34772417098be99818a/" rel="bookmark">
			TypeError: Descriptors should not be created directly, but only retrieved retrieved from theirparent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：将caffepb.py改为caffe_pb2.py即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f792c182650b65de3a103c44ab0950/" rel="bookmark">
			$.ajax()参数及标准写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。
2.type: 要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。
3.timeout: 要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。
4.async: 要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。
5.cache: 要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。
6.data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　processData选项。对象必须为key/value格式，例如{foo1:"bar1",foo2:"bar2"}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:["bar1","bar2"]}转换为&amp;foo=bar1&amp;foo=bar2。
7.dataType: 要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：
xml：返回XML文档，可用JQuery处理。
html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。
script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。
json：返回JSON数据。
jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。
text：返回纯文本字符串。
8.beforeSend：
要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。
function(XMLHttpRequest){
this; //调用本次ajax请求时传递的options参数
}
9.complete：
要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。
function(XMLHttpRequest, textStatus){
this; //调用本次ajax请求时传递的options参数
}
10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。
(1)由服务器返回，并根据dataType参数进行处理后的数据。
(2)描述状态的字符串。
function(data, textStatus){
//data可能是xmlDoc、jsonObj、html、text等等
this; //调用本次ajax请求时传递的options参数
}
11.error:
要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：
function(XMLHttpRequest, textStatus, errorThrown){
//通常情况下textStatus和errorThrown只有其中一个包含信息
this; //调用本次ajax请求时传递的options参数
}
12.contentType：
要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为"application/x-www-form-urlencoded"。该默认值适合大多数应用场合。
13.dataFilter：
要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。
function(data, type){
//返回处理后的数据
return data;
}
14.dataFilter：
要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。
function(data, type){
//返回处理后的数据
return data;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75f792c182650b65de3a103c44ab0950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84750ef9827537d9a42b2f720b8bcd60/" rel="bookmark">
			eslint 禁用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* eslint-disable */ ESLint 在校验的时候就会跳过后面的代码 还可以在注释后加入详细规则，这样就能避开指定的校验规则了 /* eslint-disable no-new */ 常用：
'rules': { "comma-dangle": ["error", "never"], //是否允许对象中出现结尾逗号 "no-cond-assign": 2, //条件语句的条件中不允许出现赋值运算符 "no-console": 2, //不允许出现console语句 "no-constant-condition": 2, //条件语句的条件中不允许出现恒定不变的量 "no-control-regex": 2, //正则表达式中不允许出现控制字符 "no-debugger": 2, //不允许出现debugger语句 "no-dupe-args": 2, //函数定义的时候不允许出现重复的参数 "no-dupe-keys": 2, //对象中不允许出现重复的键 "no-duplicate-case": 2, //switch语句中不允许出现重复的case标签 "no-empty": 2, //不允许出现空的代码块 "no-empty-character-class": 2, //正则表达式中不允许出现空的字符组 "no-ex-assign": 2, //在try catch语句中不允许重新分配异常变量 "no-extra-boolean-cast": 2, //不允许出现不必要的布尔值转换 "no-extra-parens": 0, //不允许出现不必要的圆括号 "no-extra-semi": 2, //不允许出现不必要的分号 "no-func-assign": 2, //不允许重新分配函数声明 "no-inner-declarations": ["error", "functions"], //不允许在嵌套代码块里声明函数 "no-invalid-regexp": 2, //不允许在RegExp构造函数里出现无效的正则表达式 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84750ef9827537d9a42b2f720b8bcd60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5fbbe3ead7354e287bce911a74f2ce4/" rel="bookmark">
			python字典顺序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：
import collections d = collections.OrderedDict([('a',1),('b',2),('c',3)]) ''' 或者把上面的那一行改成： d = collections.OrderedDict() d['a'] = 1 d['b'] = 2 d['c'] = 3 ''' for k,v in d.items(): print(k,v) 输出结果： a 1 b 2 c 3 第二种方法：
from collections import OrderedDict d = OrderedDict([('a', 1), ('b', 2), ('c', 3)]) for k,v in d.items(): print(k,v) 输出结果： a 1 b 2 c 3 第三种方法：
d = {'a':1, 'b':2, 'c':3} e = ['a', 'b', 'c'] for i in range(3): print( str(e[i]) + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5fbbe3ead7354e287bce911a74f2ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37fbcc917364b28f04c26a8b73ffdc34/" rel="bookmark">
			简单聊一聊python3中多线程的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		threading库 threading库是python3内置的线程库，可以使用threading库创建多个线程
创建多线程的两种方法 继承Thread类（推荐使用） 直接看代码，注意看注释讲解
import re, requests, threading class MyThread(threading.Thread): """ 定义一个线程 用于获取一个页面的文章内容 """ def __init__(self, per_link): # 这里需要调用父类的构造函数 # 因为Thread类在定义线程的时候就是通过构造函数使用的run函数（个人猜测...） super().__init__() self.link = per_link self.content = '' # 空字符串 self.contents = [] def run(self): # 修改run函数的内容 # 改为要执行的线程的程序代码	res = requests.get(self.link) res.encoding = 'gbk' self.contents = re.findall('&lt;p&gt;(.*?)&lt;/p&gt;', res.text, re.S) # print(self.contents[0]) self.content = self.contents[0].replace('&lt;br /&gt;', '') # 通过类继承的方法定义多线程时有个有点就是可以添加函数用作其他功能 # 例如，添加一个函数用于返回线程的执行结果返回值 def get_result(self): print(self.content) return self.content class MultiCrawler(): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37fbcc917364b28f04c26a8b73ffdc34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a6f0cb473770383ad5dfac2fb810be/" rel="bookmark">
			ArcGIS矢量数据重分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，我们通常只对栅格数据进行重分类，例如将DEM数据按照高程分层设色，将坡向数据按照光照重分类以研究光照信息。
但有些时候，矢量数据也会遇到需要“重分类”的情况，例如将某个字段按照范围重新赋值，将矢量数据与栅格数据叠加计算等。
矢量数据的重分类可以使用矢量转栅格，然后再对栅格数据进行重分类来实现。
操作步骤：
打开ArcToolBox, 点击 转换工具|转为栅格|要素转栅格输入面要素并选择保存的字段打开 SpatialAnalyst|重分类|重分类，对数据重分类即可 如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bbb1502b75ef55ec0f7e29784c1f73/" rel="bookmark">
			JS控制网页滑动顶部导航条变色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!--引入jQuery--&gt; &lt;script src="http://apps.bdimg.com/libs/jquery/1.8.3/jquery.js"&gt;&lt;/script&gt; &lt;title&gt;Js控制网页滑动的时候顶部导航条变成半透明&lt;/title&gt; &lt;style type="text/css"&gt; .main { width: 100%; height: 2000px; background: gray; } .nav { width: 100%; height: 100px; background: black; position: fixed; top: 0; } .content { position: f; top: 0; right: 0; left: 0; bottom: 2.5rem; } .place { width: 100%; height: 300px; margin-top: 300px; background: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="nav"&gt;&lt;/div&gt; &lt;div class="main"&gt; &lt;div class="place"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; function scroll() { var top = $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44bbb1502b75ef55ec0f7e29784c1f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f4a32f9c1fa27e699ace75fb0574fb5/" rel="bookmark">
			could not resolve all dependencies for configuration &#39;:app:debugruntimeclasspath&#39;. 无法解决配置&#39;:app:调试器&#39;的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		could not resolve all dependencies for configuration ':app:debugruntimeclasspath'.
无法解决配置':app:调试器'的所有依赖关系。
最后在项目的build.gradle 的buildscript 和 allprojects同时加上了
mavenCentral(
google()
就编译成功，特此记录下！如果对于大家有帮助就更好了！
转载https://blog.csdn.net/android_LvQi/article/details/82589531
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a81e875acb94252ea0742ebcacb76ef5/" rel="bookmark">
			微信小程序map组件拖拽地图获取经纬度，地址，带定位点范围（中心点固定）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序map组件之移动map选取位置，效果图如下：
微信小程序map组件，实现拖拽定位，获取定位位置，点击cover-image回到定位原点
手机效果相同。
废话不多说，上代码
wxml代码：
&lt;view class="container"&gt; &lt;map id="map4select" longitude="{{longitude}}" latitude="{{latitude}}" scale="14" controls="{{controls}}" markers="{{markers}}" show-location bindcontroltap="controltap" polyline="{{polyline}}" bindmarkertap="markertap" circles="{{circles}}" bindregionchange="regionchange" &gt; &lt;cover-image class="cover-image" bindtap="my_location" src="/imgs/my_location.png" /&gt; &lt;cover-image class="cover-image_confirm" bindtap="confirm_bag" src="/imgs/confirm.png" /&gt; &lt;/map&gt; &lt;/view&gt; regionchange(e) { console.log(e) // 地图发生变化的时候，获取中间点，也就是用户选择的位置toFixed if (e.type == 'end' &amp;&amp; (e.causedBy == 'scale' || e.causedBy == 'drag')) { console.log(e) var that = this; this.mapCtx = wx.createMapContext("map4select"); this.mapCtx.getCenterLocation({ type: 'gcj02', success: function(res) { console.log(res) that.setData({ latitude: res.latitude, longitude: res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a81e875acb94252ea0742ebcacb76ef5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757ef0906b274fa302e4b0f57a965f5f/" rel="bookmark">
			ArcGIS检查线要素是否闭合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查线要素闭合是的ArcGIS的中十分常用的操作，在绘制等高线时，一般要求等高线必须闭合。在线要素转面要素时，也要求线要素是闭合的线，否则会导致转出面的丢失数据。
ArcGIS中使用拓扑工具检查线要素闭合
具体做法：
创建拓扑，检查错误 在ArcMap中中中，将要素放入要素类数据集。
在要素类数据集中创建拓扑
在拓扑中添加线要素
添加拓扑规则为不能有悬挂点
线要素不闭合的地方即显示红色。
修改拓扑错误 打开拓扑工具条
点击拓扑编辑工具选中要修改的边
点击修改边工具进行修改
修改完成后，点击验证拓扑错误按钮进行检查。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b846e699fe65fa83f32eee75c40d9849/" rel="bookmark">
			Jquery.ajax()访问接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jquery.ajax()访问接口 Jquery在异步提交方面封装的很好，直接用AJAX非常麻烦，Jquery大大简化了我们的操作，不用考虑浏览器的诧异了。
推荐一篇不错的jQuery Ajax 实例文章，忘记了可以去看看，地址为：http://www.cnblogs.com/yeer/archive/2009/07/23/1529460.html 和 http://www.w3school.com.cn/jquery/
$.post、$.get是一些简单的方法，如果要处理复杂的逻辑，还是需要用到jQuery.ajax()
一、$.ajax的一般格式
$.ajax({
type: 'POST',
url: url ,
data: data ,
success: success ,
dataType: dataType
});
二、$.ajax的参数描述
参数 描述 url必需。规定把请求发送到哪个 URL。data可选。映射或字符串值。规定连同请求发送到服务器的数据。success(data, textStatus, jqXHR)可选。请求成功时执行的回调函数。dataType 可选。规定预期的服务器响应的数据类型。
默认执行智能判断（xml、json、script 或 html）。
三、$.ajax需要注意的一些地方：
1.data主要方式有三种，html拼接的，json数组，form表单经serialize()序列化的；通过dataType指定，不指定智能判断。
2.$.ajax只提交form以文本方式，如果异步提交包含&lt;file&gt;上传是传过不过去,需要使用jquery.form.js的$.ajaxSubmit
四、$.ajax我的实际应用例子
Js代码 //1.$.ajax带json数据的异步请求 var aj = $.ajax( { url:'productManager_reverseUpdate',// 跳转到 action data:{ selRollBack : selRollBack, selOperatorsCode : selOperatorsCode, PROVINCECODE : PROVINCECODE, pass2 : pass2 }, type:'post', cache:false, dataType:'json', success:function(data) { if(data.msg =="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b846e699fe65fa83f32eee75c40d9849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f499dd71038c0b74c570f89d560b61d/" rel="bookmark">
			android屏幕分辨率适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分辨率高度宽度宽高比(宽/高)1920x1080192010800.56252094x1080209410800.51575931232220x1080222010800.48648648651280x72012807200.56252392x1440239214400.6020066892560x1440256014400.56251776x1080177610800.60810810812030x1080203010800.53201970442118x1080211810800.50991501422076x1080207610800.5202312139568x3205683200.5633802817800x4808004800.6854x4808544800.5620608899960x5409605400.56251184x72011847200.60810810811208x72012087200.59602649011280x80012808000.6251280x76812807680.61176x1080117610800.91836734691800x1080180010800.61812x1080181210800.59602649011920x1152192011520.61920x1200192012000.6252160x1080216010800.52208x1080220810800.48913043482240x1080224010800.48214285712244x1080224410800.48128342252280x1080228010800.47368421052560x1312256013120.51252560x1600256016000.6252960x1400296014000.472972973 图一，完美的阐述了安卓分辨率之多，且宽高比率不一致的问题，
图二，完美的阐述了安卓分辨率的适配方案。
关于安卓手机分辨率尺寸各有不同，为了支持多种屏幕，给大家推荐三种适配方案：
1.googe开源百分比布局
2.动态适配各个屏幕分辨率 3.静态适配各个屏幕分辨率（XML自动生成工具）
（以上三种方案可以根据项目实际情况相结合使用）
这里主要说下第二种方案和第三种方案的原理：
第二种方案，其实就是通过一系列算法去计算每个view在用户手机屏幕中应该的宽高，从而达到一个适配效果；
第三种方案，原理大致简单的说一下吧，每个公司都有自己的UI设计师，通常设计师会在一个屏幕尺寸上作图，例如设计师在1280x720上作图，那么我们在android项目工程的res目录下新建文件夹values-1208x720，另外再新建两个文件dimens_width.xml和dimens_height.xml用来存放宽度和高度。
我们可以看到，name-value的一一对应关系，所以UI设计师在1280x720尺寸上作图时，如果效果图上标注控件的宽是4px，高是2px，那么我们引用 android:layout_width="@dimen/width4px" android:layout_height="@dimen/height2px" 就可以达到完美的适配效果。那么问题来了，它在1920x1080分辨率上的尺寸怎么办呢？使用“静态xml适配各个屏幕分辨率”来解决此问题，它会自动生成相对应的尺寸大小至values-1920x1080目录下。
上图中我们可以看到，在values-1920x1080中，width4px对应的是6px，而height2px对应的是3px，是因为在生成静态xml的时候就根据你的UI效果图的基础尺寸把其他分辨率上的尺寸给适配好了，所以，还是那句话，我们引用 android:layout_width="@dimen/width4px" android:layout_height="@dimen/height2px" 就可以达到完美的适配效果。
为了帮助大家更好的理解，我再举个栗子，假设UI设计师有时候在720x1280上做效果图，有时候在1080x1920上做效果图，那该怎么应用呢？UI设计师在哪个屏幕分辨率上做标注，你就传入哪个屏幕分辨率目录下跟UI设计师标注的相对应宽高的值所对应的资源名称即可。
安卓设备有数不尽的各种奇葩分辨率，我们需要每个屏幕分辨率都生成xml文件吗？不需要，你可以选取你们app用户量排名前30的设备来做分辨率适配，然后另外也可以选取一些特定的分辨率就可以了，因为即使用户的设备找不到与之相匹配的大小时，它还会向下寻找与它相近的文件夹分辨率来取值，但是这里要注意了，如果找不到与之匹配的大小时，向下也没有声明比这更小的分辨率文件夹时，并且也没有设置默认的分辨率文件时，它可能会无情的向你报一个错：
Caused by: android.view.InflateException: Binary XML file line #13: Binary XML file line #13: You must supply a layout_width attribute
Caused by: java.lang.UnsupportedOperationException: Binary XML file line #13: You must supply a layout_width attribute.
以防万一，我们还可以选择在res/values目录下新建默认分辨率。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e04aed88590e1cc87a403544d5adcc1/" rel="bookmark">
			redis(五)-缓存三大问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存的设计包含很多技巧，设计不当将会导致严重的后果。本文将介绍缓存使用中常见的三大问题，并给出相应的解决方案。
缓存穿透缓存雪崩缓存击穿 1. 缓存穿透 在大多数互联网应用中，缓存的使用方式如下图所示：
当业务系统发起某一个查询请求时，首先判断缓存中是否有该数据；如果缓存中存在，则直接返回数据；如果缓存中不存在，则再查询数据库，然后返回数据。 了解了上述过程后，下面说说缓存穿透。
1.1 什么是缓存穿透？ 业务系统要查询的数据根本就存在！当业务系统发起查询时，按照上述流程，首先会前往缓存中查询，由于缓存中不存在，然后再前往数据库中查询。由于该数据压根就不存在，因此数据库也返回空。这就是缓存穿透。
综上所述：业务系统访问压根就不存在的数据，就称为缓存穿透。
1.2 缓存穿透的危害 如果存在海量请求查询压根就不存在的数据，那么这些海量请求都会落到数据库中，数据库压力剧增，可能会导致系统崩溃（你要知道，目前业务系统中最脆弱的就是IO，稍微来点压力它就会崩溃，所以我们要想种种办法保护它）。
1.3 为什么会发生缓存穿透？ 发生缓存穿透的原因有很多，一般为如下两种：
恶意攻击，故意营造大量不存在的数据请求我们的服务，由于缓存中并不存在这些数据，因此海量请求均落在数据库中，从而可能会导致数据库崩溃。代码逻辑错误。这是程序员的锅，没啥好讲的，开发中一定要避免！ 1.4 缓存穿透的解决方案 下面来介绍两种防止缓存穿透的手段。
1.4.1 缓存空数据 之所以发生缓存穿透，是因为缓存中没有存储这些空数据的key，导致这些请求全都打到数据库上。
那么，我们可以稍微修改一下业务系统的代码，将数据库查询结果为空的key也存储在缓存中。当后续又出现该key的查询请求时，缓存直接返回null，而无需查询数据库。
缓存空对象会有两个问题： 第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。
1.4.2 BloomFilter 第二种避免缓存穿透的方式即为使用BloomFilter。
它需要在缓存之前再加一道屏障，里面存储目前数据库中存在的所有key，如下图所示：
当业务系统有查询请求的时候，首先去BloomFilter中查询该key是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。
这种方法适用于数据命中不高，数据相对固定实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。 1.4.3 两种方案的比较 这两种方案都能解决缓存穿透的问题，但使用场景却各不相同。
对于一些恶意攻击，查询的key往往各不相同，而且数据贼多。此时，第一种方案就显得提襟见肘了。因为它需要存储所有空数据的key，而这些恶意攻击的key往往各不相同，而且同一个key往往只请求一次。因此即使缓存了这些空数据的key，由于不再使用第二次，因此也起不了保护数据库的作用。
因此，对于空数据的key各不相同、key重复请求概率低的场景而言，应该选择第二种方案。而对于空数据的key数量有限、key重复请求概率较高的场景而言，应该选择第一种方案。
2. 缓存雪崩 2.1 什么是缓存雪崩？ 通过上文可知，缓存其实扮演了一个保护数据库的角色。它帮数据库抵挡大量的查询请求，从而避免脆弱的数据库受到伤害。
如果缓存因某种原因发生了宕机，那么原本被缓存抵挡的海量查询请求就会像疯狗一样涌向数据库。此时数据库如果抵挡不了这巨大的压力，它就会崩溃。
这就是缓存雪崩。
2.2 如何避免缓存雪崩？ 2.2.1 使用缓存集群，保证缓存高可用 和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 Redis Sentinel 和 Redis Cluster 都实现了高可用。 2.2.2 使用Hystrix Hystrix是一款开源的“防雪崩工具”，它通过 熔断、降级、限流三个手段来降低雪崩发生后的损失。
Hystrix就是一个Java类库，它采用命令模式，每一项服务处理请求都有各自的处理器。所有的请求都要经过各自的处理器。处理器会记录当前服务的请求失败率。一旦发现当前服务的请求失败率达到预设的值，Hystrix将会拒绝随后该服务的所有请求，直接返回一个预设的结果。这就是所谓的“熔断”。当经过一段时间后，Hystrix会放行该服务的一部分请求，再次统计它的请求失败率。如果此时请求失败率符合预设值，则完全打开限流开关；如果请求失败率仍然很高，那么继续拒绝该服务的所有请求。这就是所谓的“限流”。而Hystrix向那些被拒绝的请求直接返回一个预设结果，被称为“降级”。
3. 缓存击穿（热点数据集中失效） 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e04aed88590e1cc87a403544d5adcc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082b15bd9b45a713c9698c12df273c84/" rel="bookmark">
			常见链表操作-两个有序表的合并（JAVA实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 将两个有序单链表A和B，合并成C，如下图。
解决思路 同时从两个链表的头节点开始遍历，比较当前节点大小，将小的节点添加到C链表中，然后遍历。
非递归写法 /** * 链表ADT * * @author wangtao * @param &lt;T&gt; */ public class LinkADT&lt;T&gt; { /** * 单链表节点 * * @author wangtao * @param &lt;T&gt; */ private static class SingleNode&lt;T&gt; { public SingleNode&lt;T&gt; next; public T data; public SingleNode(T data) { this.data = data; } public T getNextNodeData() { return next != null ? next.data : null; } } /** * 有序链表合并，非递归 * * @param nodeA * @param nodeB * @return */ public static SingleNode&lt;Integer&gt; mergeV1(SingleNode&lt;Integer&gt; nodeA, SingleNode&lt;Integer&gt; nodeB) { if (nodeA == null) { return nodeB; } else if (nodeB == null) { return nodeA; } // 初始化nodeC SingleNode&lt;Integer&gt; nodeC = new SingleNode&lt;Integer&gt;(null); // 定义当前节点 SingleNode&lt;Integer&gt; currentNode = nodeC; // 遍历A和B，直到末尾 while (nodeA !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082b15bd9b45a713c9698c12df273c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1110f5bc7d65d14f5f480c17536bf6b1/" rel="bookmark">
			ArcGIS将两个分离面要素合并与拆分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据：居民地数据
图中每个面表示一个居民地。
面要素合并： 按住shift键，同时选中两个或多个要素。
在编辑器下拉菜单中找到“合并”，点击执行。
面要素拆分： 选中要拆分的要素。
在编辑器下拉菜单中找到“更多编辑工具”，点击，打开其中的“高级编辑”。
点击高级编辑工具中的“拆分多部件要素”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcdab913b14d1ff2d8d81a1105b3850/" rel="bookmark">
			C&#43;&#43;——复制构造函数和赋值运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Point类
显然是将b的坐标值赋值给a的坐标
Point a,b; a = b; 看下一个demo：
TextFile a, b; a.Open( "FILE1.DAT" ); b.Open( "FILE2.DAT" ); b = a; 前面的代码可能表示“将 FILE1.DAT 的内容复制到 FILE2.DAT”，也可能表示“忽略 FILE2.DAT 并使 b 成为 FILE1.DAT 的另一个句柄”。 这里的歧义需要自己去实现 复制构造函数和复制赋值运算符 来达到想要的效果。
一般的：
复制构造函数：T(const T&amp; x);
复制赋值运算符：T &amp; operator=(const T &amp; x);
如果不声明复制构造函数，编译器将为你生成 member-wise 复制构造函数。 如果不声明复制赋值运算符，编译器将为你生成 member-wise 复制赋值运算符。
对于复制构造函数，需要知道：何时调用和有何功能 何时调用：
新建一个对象并将其初始化为同类现有对象
表现形式有：
other是一个T类的对象
①T x(other);
②T x = other;
③T x = T(other);
④T *x = new T(other);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dcdab913b14d1ff2d8d81a1105b3850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf388e5e35a8c3f298abbda983ac47c/" rel="bookmark">
			斯坦福大学-自然语言处理入门 笔记 第九课 信息抽取（information extraction）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 1、信息抽取（information extraction） 信息抽取（IE）系统 找到并理解文本中的有限的相关性从很多的文档之中收集信息产生一个相关信息的结构化的表征目的： 进行信息的组织使之对人有用以相对精确的语义形式存放信息方便计算机算法后续的查找 信息抽取（IE）系统一般会抽取清晰的实际的信息（谁对谁做了什么在什么时候）
低程度的信息抽取 一般被用在苹果或者是谷歌的邮件上，或者是web索引。通常是基于正则表达和名字列表。
2、命名实体识别（named entity recognition） 这是在信息抽取中十分重要的一个分支：找到并识别文档中的名字
主要用途： 命名实体的索引（index）和链接(link off）分析情感指向的公司或者产品很多信息抽取的关系都是和命名实体相关在问题回答（question answer）领域，答案往往是命名实体。 二、命名实体识别的评估 正确识别一个命名实体，需要包含两个方面，一方面需要找到表示命名实体的词组，另一方面对命名实体正确归类，如果下图所示：
对命名实体识别（NER）或者信息抽取（IE）而言，用之前介绍的recall和precision来进行评估会存在一个问题：没有办法定义边界错误（boundary error）。举例子而言：
对于句子：First Bank of Chicago announced earnings…而言，机器识别Bank of Chicago作为实体，但实际First Bank of Chicago才是命名实体。对于这样的错误，我们在归类的时候即可以归到FN也可以归到FP。所以，基于这样的度量标准，实际上边界错误比无法识别（只会归类到FN）更严重。其他度量，比如MUC得分会好一些 三、命名实体识别的序列模型（sequence model） 1、命名实体识别（NER）的机器学习序列模型 训练 收集一系列有代表性的训练文档给每个token标注它的类别，如果不是命名实体的话就标注other（O)设计适合文档和类别的特征抽取机制训练一个序列分类来预测数据的类别 测试 一系列的测试文档运行序列模型来给每个token进行标注输出识别出的实体 2、对序列标注进行类别编码 这里有两种可以使用的编码方式：
IO编码，只标记每个词的类别。这里需要的标注个数是C＋１。IOB编码，除了标记每个词的类别之外，标记还会表示出这个类别的开始和结束，如下图B－PER表示Person类别的开始，I－PER表示person类别的结束。这样的话，当几个相同的命名实体是连在一起的时候，我们可以区分出有几个命名实体。这里需要的标注个数是２C＋１。
在实际应用中，IO编码效果可能会更好。（在Stanford的姓名粗识别中使用IO编码） 一方面是IO编码的速度更快，标注数量更少另一方面，几个相同的命名实体是连在一起的情况很少，而且在这个情况下IOB编码也很难正确识别出命名实体的开始和结束。 3、序列标记的特征 单词 目前的单词前一个/后一个单词（上下文） 其他推论型的语言分类 词类标记 上下文的标签（label） 前一个（或者后一个）词的标签 单词的子字符串：我们可以利用单词中的某些字符来进行判别，比如含有oxa子字符串的单词都是drug。
单词的形状：包括单词的长度、大小写、是否含有数字、是否含有希腊字母、连词符。利用下面的规则，我们将其抽取成特征。 A，B，C…→Xa,b,c→x1，2，3…→d- → -. → .对于长过四个字母的单词，我们取前两个和后两个；如果单词小于四个的话，我们就按照原来的长度转化。例子如下：
四、最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型 很多在NLP领域的问题的数据都是序列数据（单词序列，方块字序列，行序列，句子序列等等）。而我们的任务则是对每一项都进行标注。
1、最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型 最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型，这两个分类器都是每次做一个决定，基于目前的观测和过去的决定（decision）。每一次进行分类，目的是对目前的单词进行标注，该分类器的计算和标准分类器是类似的。所使用的特征包括单词（之前，目前，之后），标注（之前的单词），还有其他的单词特征（单词类型、后缀、-等等）
整体的推断系统如下
2、三种推断 贪婪推断（greedy inference） 从左边开始，用分类器依次给每个位置标记（label），分类器可以依靠之前的标记结果以及观测数据。优点： 快，没有额外的空间存储要求非常容易实施当特征很多的时候效果很好 缺点 因为使用的是贪婪算法，所以可能会发生标记错误 束推断（beam inference） 这个方法不会简单标记每个单词，相反它会保留下一些可能，在每个位置都保持前k个序列（束），每次完成一个标记就滑动前进一个序列。优点 快，3-5个单词的束就可以得到比较好的效果很容易实施（不需要进行动态规划） 缺点 对有些标记而言，可能在表现出比较好的概率之前，就已经离开波束了 维特比推断（Viterbi Inference） 动态规划，需要关于状态影响的滑动窗口（比如，过去的两个状态是相关的）优点：精确缺点：对长距离的单词与单词之间的影响很难应用（束推断也不允许长距离的序列）。 3、条件随机场（CRFs) 这也是一个整个序列的条件模型，而不是链式的模型（local model）。模型形如下图，只不过c和d是序列。但是如果特征f是当前（local）的，条件序列似然可以用动态规划来计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bf388e5e35a8c3f298abbda983ac47c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72dca9887751120a831dfe98289205d0/" rel="bookmark">
			linux中文件名有英文括号的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件名包含“（）”的文件，输入“(“后按TAB键无法补全，手动输入文件全名也删除不了；提示bash: syntax error near unexpected token `('错误。
在linux中，如果文件名中带括号，应先对括号处理，在“(”和“）”前加上“\”。
()、(())、[]、[[]]、{}是shell脚本中的保留字符。用shell脚本处理文件名包含英文括号的文件，也会报错。
也要先对文件名进行处理，中文的括号是没问题的。
转载于:https://www.cnblogs.com/lnlvinso/p/9813696.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5caedf69959242e0d4c25088a2a4160/" rel="bookmark">
			Spring项目启动报错org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find classs分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错大致信息：org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [XXXXX] for bean with name 'XXX' defined in class path resource [springmvc-config.xml]; nested exception is java.lang.ClassNotFoundException:...
可以看出来，项目启动时找不到对应的.class文件。
那么为什么没有找到呢？个人觉得原因可以简单归结为两点：
1.对应的文件没有编译出来；
2.配置文件路径有误。
解决办法：
1.首先在对应路径下找，看看有没有这个class文件，注意仔细对照查看路径是否正确（包括单词拼写，这个坑我曾踩过o(╥﹏╥)o），如果文件存在且拼写无误，请检查配置文件。
2.如果第一步中找不到对应的class文件，那就应该检查为什么没有编译出.class文件。
①myeclipse或eclipse--&gt;Project--&gt;Build Automatically,把勾打上，再次修改对应java文件，看看是否能编译出来class；
②若按照上述方法还是不行，很有可能是所需要的jar包导入或者jar包有问题，请检查jar包；
③再不行可重新建工作空间或者重建项目工程再试试。
如有错误之处，欢迎批评指正，万分感谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a90a291a1444610e444368074d9cf7/" rel="bookmark">
			oracle 时间函数 TO_DATE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions183.htm
TO_DATE(char [, fmt [, 'nlsparam' ] ]) 参数 该TO_DATE()函数接受三个参数：
1） char
是一个字符串值，它被转换为一个DATE值。它可以是任何数据类型CHAR，VARCHAR2，NCHAR或NVARCHAR2的值。
2） fmt
是的日期和时间格式string。
该fmt 参数是可选。如果忽略则取决于默认日期格式
默认日期格式由NLS_TERRITORY初始化参数隐式确定，或者可以由NLS_DATE_FORMAT参数显式设置。
该'nlsparam'函数在此函数中的TO_CHAR作用与日期转换函数中的作用相同。
fmt的理解请参考上一篇https://blog.csdn.net/uotail/article/details/83150030
3） 'nlsparam'
是一个表达式，用于指定日期和月份名称的语言string。该nls_language参数具有以下形式：
1
NLS_DATE_LANGUAGE = language
这个'nlsparam'参数是可选的。如果省略它，该TO_DATE()函数将使用会话的默认语言。
返回值 该TO_DATE()函数返回一个DATE与输入字符串对应的值。
以下示例将字符串转换为日期：
SELECT TO_DATE('January 15, 1989, 11:00 A.M.','Month dd, YYYY, HH:MI A.M.','NLS_DATE_LANGUAGE = American') FROM DUAL; 如果NLS_TERRITORY参数设置为' AMERICA'，则返回的值反映默认日期格式。不同的NLS_TERRITORY值会导致不同的默认日期格式：
ALTER SESSION SET NLS_TERRITORY = 'KOREAN'; SELECT TO_DATE( 'January 15, 1989, 11:00 A.M.','Month dd, YYYY, HH:MI A.M.','NLS_DATE_LANGUAGE = American') FROM DUAL; 例子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a90a291a1444610e444368074d9cf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e9f0092d2737214e0518fd88020d3b/" rel="bookmark">
			c&#43;&#43;——左值、右值、左值引用、右值引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、左值和右值 左值（left-values），缩写：lvalues
右值（right-values），缩写：rvalues
直接上官网查，我一向倡导自己去懂得原理，而原理都是老外写的，当然我只是针对c++编程语言这样说。
https://msdn.microsoft.com/en-us/library/f90831hc.aspx
翻译：所有的c++表达，不是左值就是右值。
lvalues是指存在于单个表达式之外的对象。你可以把左值当成有名字的对象。
所有的变量，包括常变量，都是左值。
rvalues是一个暂时存在的值存在于单个表达式之内的对象。
有点拗口（难理解），通俗来说就是，左值的生存期不只是这句话，后面还能用到它。
而右值呢，出了这句话就挂了，所以也叫（将亡值）。
它举了一个栗子：
#include &lt;iostream&gt; using namespace std; int main() { int x = 3 + 4; cout &lt;&lt; x &lt;&lt; endl; } 在以上实例中，很显然，x是左值，3 + 4是右值。
它又举了一个栗子，来说明错误的使用和正确的使用
// lvalues_and_rvalues2.cpp int main() { int i, j, *p; // 正确的使用: 变量是左值 i = 7; // 错误的使用: 左边的操作 必须是 左值 (C2106) 7 = i; // C2106 j * 4 = 7; // C2106 // 正确的使用: 被间接引用的指针是左值 *p = i; const int ci = 7; // 错误的使用: 左边的操作 是 常量左值 (C3892) ci = 9; // C3892 // 正确的使用: 条件操作 返回了左值 ((i &lt; 3) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4e9f0092d2737214e0518fd88020d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef8c9a30534f97c408d1ad82258550f/" rel="bookmark">
			测试Web应用程序中的竞争条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://www.freebuf.com/articles/network/107077.html
此篇文章主要介绍了一下什么是“竞争条件”漏洞以及介绍了一下如何使用Burp来实现该漏洞的利用。
在对一个应用程序进行黑盒/灰盒安全测试时，我们一般都把精力集中在OWASP TOP10上，而很少去测试“竞争条件”（race condition）问题。有一个共识是使用黑盒/灰盒方法进行“竞争条件”漏洞的挖掘是非常不靠谱的，一般都会通过对代码进行审计来发现此类问题。但是话又说回来了，随着技术的发展和工具的日趋先进，使用黑盒/灰盒测试方法来实现“竞争条件”漏洞的挖掘的可能性大大增加。
在本篇文章中我们将会对“竞争条件”漏洞是什么和该类漏洞可能出现的场景进行讨论，并且会使用Burp来模拟整个流程。
“竞争条件”是什么 “竞争条件”发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。
——Wikipedia-computer_science
开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。
线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，也被称之为临界区（critical section），如果没有应用好同步技术则会发生“竞争条件”问题。下图为3个进程同时访问一个程序段。
Java Web应用程序内部 在传统的客户端-服务器模型中，浏览器会将http请求发送至web服务器，然后呈现从服务器接收到的数据。当用户尝试通过浏览器向web应用程序发起多个并发请求时，浏览器并不会如实照做，下图为servlets中的多线程处理。
设想一个基于Java的web应用运行在Apache Tomcat上，该应用包含一个与Java servlet进行交互的容器组件，这个组件负责servlet的生命周期管理，并且负责将url映射到对应的servlet。当web服务器接收到请求时，它会将该请求转发给对应的容器，容器将会创建一个线程来处理该请求，创建一个HTTP请求和响应对象，并将这些对象传递给一个线程。
在我们假设的场景中，该容器并没有顾及到线程安全（当一段代码能够在多个线程同时访问时还能保证自由竞争条件，我们就说它是线程安全的，线程安全应该由开发人员来处理）。
攻击者使用自动化脚本同时向服务器发起多个请求，这会导致容器生成多个线程，而且这些线程是并行执行的，开发人员在进行代码开发时是很难考虑到这些并行执行的线程将会导致结果的复杂性，所以说线程安全是一个应用必须要满足的。（在多线程环境下，容器不会创建一个servlet的多个实例，这些servlet成员会共享所有运行的并发的线程。如果开发人员使用servlet成员来执行操作，则会造成“竞争条件”问题。）
案例分析 假设一个银行应用的场景：一笔交易需要从ACC_Form转移到ACC_TO。如下为实现转账功能的伪代码。
在这段伪代码中，钱从账户ACC_From转移到ACC_TO，应用程序会验证账户是否有足够的资金用于转账。但是通过发送多个并发请求（使用自动化脚本），攻击者可以实现向ACC_TO转超过自己余额的金钱。
这种行为发生的原因是服务器上的多个线程同时执行，if的判断条件被多次判定为真，导致代码多次执行，这也就导致了“竞争条件”问题，因为转账的钱可能超过了可用余额。需要注意的是，这种行为非常依赖于网络延迟、程序负载等环境变量。
在进行渗透测试时，安全研究人员需要分析整个应用程序并找出应用程序做了哪些限制，以及是否能够通过同时发送多个请求来绕过这些限制。
使用Burp来找出“竞争条件”问题 渗透测试人员可以使用Burp的intruder功能来实现发送多个并发请求，我们利用上面的伪代码搭建了一个演示的应用程序。
假设一个客户将钱从账户888转移到账户999：
源账户 888 ，余额：1美元。
目标账户 999 ，余额：29,999美元。
现在我们尝试给账户999转账2美元，但是实际上我们只有1美元。
程序返回“Transaction Failed”（转账失败），因为要转账的金额超出了我们的余额。
我们将转账的金额改成1美元，然后发起转账请求。正常情况下，源账户888的余额会变成0，目标账户999的余额会变成30,000美金。
漏洞利用 1、截断转账的请求，并发送至intruder中。
2、进入到“Options”选项中，将线程设置成25（默认为5），因为我们要发送很多并发请求。
3、在“Payloads”选项中选择“Null payloads” ，因为我们只需要重复发包即可。
4、开始发起攻击并观察结果，我们可以看到源账户的余额变成了负数：
源账户余额：-2美元
目标账户金额：30,002美元
挑战 “竞争条件”漏洞有时很难通过黑盒/灰盒的方法来进行挖掘，因为这个漏洞很受环境因素的影响。比如网络延迟、服务器的处理能力等。
参考文献 https://en.wikipedia.org/wiki/Race_condition#Computing
https://en.wikipedia.org/wiki/Thread_safety
https://en.wikipedia.org/wiki/Synchronization_(computer_science)
http://roberto.greyhats.it/pubs/dimva08-web.pdf
http://www.slideshare.net/timtowtdi/1-java-servlets-and-jsp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2bcbdbffb5709aead2f2f6e276e8377/" rel="bookmark">
			关于javascript的数组与二维数组、关联数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组： 什么是：内存中连续保存多个数据的内存空间 为什么：便于批量管理和操作多个相关的数据 创建数组： 有3种创建方法；
（1）创建一个空数组：
var arr=[]; var arr=new Array();
（2）创建数组时就初始化值：var arr=[45,12,34,56]; var arr=new Array(45,12,34,56)
（3）创建n个空元素的数组：
var arr=new Array(n);
访问数组：
下标（index）：数组中唯一标识一个元素位置的序号，从0开始，连续且不重复
索引数组：下标都是数字序号的数组
arr[index]：
使用每个数组的每个元素相当于使用变量数组其实就是连续的变量集合，统一起个名字
特殊：
（1）数组不限制元素的数据类型
（2）js数组不限制下标越界
赋值：下标越界，不会报错，会在新的位置创建新元素并保存数据 稀疏数组：下标不连续的数组 （3）js数组不限制元素的个数
length属性：记录了数组理论上的元素的个数 修改元素的个数：arr.length--,相当于数组容量-1 length始终是数组的最后一个元素下标+1 数组的一些固定套路：
（1）向数组的末尾追加一位元素：
arr[arr.length]=新值
（2）如何获取数组的最后一位元素：
arr[arr.length-1]; 倒数第n个元素 arr[arr.length];
（3）删除数组末尾n个元素：
arr.length-=n
遍历数组：
for(var i=0;i&lt;arr.length;i++){ arr[i]; //当前正在遍历的元素}
关联数组： 什么是：下标可以自定义名称的数组 如何var arr=[]; arr[“name”]=“zhangsan”; arr[“age”]=23;
遍历时：length失效，因为下标是自定义的名称,要用以下方法遍历
for(var key in arr){ //in:会自动一次取出数组中每隔元素的下标名称
//key：变量
arr[key] }
二维数组： 在一个数组中又是一个数组，也可以称为数组中的数组 var arr=[[1,2,3,4],[5,6,8,9]]; arr[1][0];//取出来的值就是5
二维数组遍历：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2bcbdbffb5709aead2f2f6e276e8377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9022f53a85b240a121b5a832010752/" rel="bookmark">
			Jupyter notebook 查看Markdown .md文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jupyter Notebook 可以说是很好用了,但是使用的过程中我发现查看 MarkDown的文件不是很方便,不能够直接转换为能够直接阅读的样式,于是上网查询了一番,发现可以使用notedown插件拓展查看markdown文件的功能,效果还是比较不错的,这里介绍给大家.
首先 安装 notedown插件
pip install https://github.com/mli/notedown/tarball/master 安装完成之后你有两种选择:
1. 每次启动Jupyter Notebook的时候在命令后面加参数 jupyter notebook --NotebookApp.contents_manager_class='notedown.NotedownContentsManager' 这样启动开之后直接点击打开md文件就可以查看,可以看到已经被转换为Notebook的样子了,比较方便直观,图片啥的也都能显示了.
2.修改配置文件,每次正常启动Jupyter Notebook就好 如果没有生成过配置文件 "jupyter_notebook_config.py " (Linux/Unix用户在~/.jupyter/jupyter_notebook_config.py, windows用户在C:\user\用户名.jupyter\jupyter_notebook_config.py )
则使用如下命令生成配置文件:
jupyter notebook --generate-config 然后编辑配置文件,在文件的第一行加入如下代码:
c.NotebookApp.contents_manager_class = 'notedown.NotedownContentsManager' 保存退出.
然后就使用命令
jupyter notebook 普通启动Jupyter Notebook就可以阅读MarkDown文件
关于Jupyter的安装配置可以查看下面的文章~~
https://blog.csdn.net/tuzixini/article/details/79105482
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725670433ad821af14102d1921651f4a/" rel="bookmark">
			斯坦福大学-自然语言处理入门 笔记 第七课 情感分析（sentiment analysis）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、情感分析简述 情感分析（sentiment analysis），又叫意见抽取（opinion extraction），意见挖掘（opinion mining）,情感挖掘（sentiment mining）以及主观分析（subjectivity analysis）。
情感分析的应用领域非常广泛
情感分析是对态度的研究，具体可以分解为：
按照复杂程度，可以把情感分类分为三类 简单任务：判断文本的任务是消极的还是积极的更复杂：把对文本的态度按1-5打分进阶：研究来源（source）、对象（target）以及复杂的态度类型 二、一个基本算法 1、一个情感分类任务 判断IMDB的电影评论是积极的还是消极的数据：Polarity Data 2.0 http://www.cs.cornell.edu/people/pabo/movie-review-data基本步骤 分词（tokenizaiton）特征抽取利用分类模型分类（朴素贝叶斯，SVM，MaxEnt) 2、情感分词（tokenizaiton）问题 处理HTML和XML的标记Twitter的标记（名字，tags）大写（保留全部大写的单词）电话和日期表情（下面是一些正则表达）
一些有用的代码
http://sentiment.christopherpotts.net/code-data/happyfuntokenizing.py 3、特征抽取 否定的抽取： I didn‘ t like this movie vs I really like this movie 解决方案：在否定词和接下来的标点之间的每个词都加上NOT_,形如下面
抽取哪些单词？ 只使用形容词还是使用全部单词？ 全部的单词表现更好，至少在这个数据集上是这样 4、分类：二值化（binarized (Boolean feature)）多元朴素贝叶斯 基本思想：主要针对情感（或者可能是其他文本分类领域）。单词是否出现比单词出现的频率更为重要，所以这个算法的特别之处在于对出现的单词都记为1。具体算法和朴素贝叶斯一致，唯一的变动是在计算P（w|c）的时候，先删除每篇文档里的重复的单词，只保留一个。
这种算法会比原来的朴素贝叶斯效果更好（这个算法和Mutivariate Bernoulli Naive Bayes是不一样的，后者在文本问题上效果不好)也可以使用其他的改进：log(freq(w))(单词的count取对数以后就会小很多） 5、交叉检验（cross-validation） 把数据集分成十份fold（每一份中类别比例相同）对每一份（fold），选择这一份作为临时的测试集，在另外九份上训练模型，并在测试集上计算模型效果。给出十份效果的平均数 6、评论难以分类的原因 三、情感词典（sentiment Lexicons） 1、一些可用的情感词典 根据相关的研究，我们发现除了sentiword，其他情感词典的相似度都很高。
2、 分析IMDB中每个词的极性（polarity） 比较单词和电影打分之间的相关性，考虑到可比性，计算的公式如下：
3、逻辑否定词 根据pott的研究，更多的否定词会出现在消极情绪中
四、情感词典训练 1、利用半监督学习词典 使用少量的信息，包括一些标注的样本和一些人工建立的模式（pattern），通过bootstrap的方法来训练词典。
2、Hatzivassiloglou和Mckeown的算法（用于单词词典的构造） 关键思想：用and相连的两个词，极性相同；用but相连的两个词，则反之。第一步：标记种子集（seed set） 1336个形容词，657个正向词，679个负向词 第二步：利用关键思想拓展种子集
第三步：利用监督分类算法计算单词对的极性相似程度（polarity similarity），结果如下图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725670433ad821af14102d1921651f4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59aa0eb10c949c8acba365a3c6205dd9/" rel="bookmark">
			C#.NET调用jar包（java环境配置及ikvm安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ASP.NET(C#)项目中需要调用java中的方法，在VS平台中简单调用jar包的方法就是将jar包转换成dll库，之后 通过引用dll库，就可以直接使用java中的类了。C#语言和Java语言有着很多相似之处，其中的jar包和dll库就是非常相似的。
java se 6环境配置
注意：java环境需要安装 java SE 6 版本 ，否则会出现源码格式无法识别的问题
简单说下java 安装：
1.去官方网站下载jdk JAVA SE 6 ：http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html
2.下载安装包后直接安装即可，然后需要对环境变量进行配置
新建 CLASSPATH(最前面需要加 【.;】点号和分号表示在所有目录下都可以使用java类)
.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar
新建 JAVA_HOME (设置为安装jdk的目录)
C:\Program Files (x86)\Java\jdk1.6.0_43
PATH变量中添加
;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
3.运行cmd命令进行测试 4.编译一个java文件进行测试 5.编译后并将创建的该类打包为jar文件
IKVM.NET使用
Java环境配置后，需要下载一个IKVM.NET的工具 IKVM.NET ：http://www.ikvm.net/
去Download页面，下载 ikvmbin-7.2.4630.5 包，之后将其解压，并在【环境变量】-&gt;【系统变量】中设置path路径，路径为解压的目录
;D:\ikvm\bin
安装完成后，可以开始将jar包转为dll库，使用一个命令即可
ikvmc -out:ikDllName.dll TestHw.jar //将jar文件转换成dll类库
从java源码到dll库用到的cmd命令如下图 javac HwJavaClass.java
jar cvf HwJarName.jar HwJavaClass.class
ikvmc -out:HwDllname.dll HwJarName.jar
在VS中使用jar转换后的dll库
这里直接在ASP.NET项目中新建web窗体；引用IKVM创建的dll库（除了自己创建的还需要引用另外三个IKVM自身的dll库,在解压目录的bin文件下） HwDllname.dll IKVM.OpenJDK.Core.dll IKVM.Runtime.dll IKVM.Runtime.JNI.dll
之后，可看到dll库中存在命名空间和类方法 代码如下：
using System;
using nameSpaceH; //package nameSpaceH
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59aa0eb10c949c8acba365a3c6205dd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef37800174ca48bf171cca4ac5394b8/" rel="bookmark">
			nvme-cli常用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVMe management command line interface
1.下载地址
https://github.com/linux-nvme/nvme-cli
2.安装
unzip nvme-cli-master.zip
cd nvme-cli-master.zip make &amp;&amp; make install
/dev/nvme1 nvme1为主控
/dev/nvme1n1 nvme1n1为NVMe硬盘名称
/dev/nvme1n1p1 硬盘nvme1n1的分区
3.常用指令
1）nvme format -s 1 /dev/nvme1n1 格式化硬盘（secure erase drives）
nvme format /dev/nvme1n1 -n 1 -l 1 4k对齐
nvme format /dev/nvme1n1 -n 1 -l 0 恢复初始状态512
nvme format /dev/nvme1n1 -l 0 Optane device Units512
参数详情请参考：http://www.pudn.com/Download/item/id/3180638.html
2）nvme smart-log /dev/nvme0n1 读取硬盘nvme0n1的smart信息
部分其他参数详解参考：https://www.percona.com/blog/2017/02/09/using-nvme-command-line-tools-to-check-nvme-flash-health/
3）nvme升/降固件版本
nvme reset /dev/nvme1 重置硬盘（NVMe硬盘固件版本进行upgrade/downgrading后要进行reset后才能effective，如果不重置主控需reboot 系统）
4)OP(Over-Provisioning)
为什么要进行OP，请参考：https://blog.csdn.net/weixin_40343504/article/details/83145713
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef37800174ca48bf171cca4ac5394b8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/245/">«</a>
	<span class="pagination__item pagination__item--current">246/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/247/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>