<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5393f3a31fa3957a130178c8a8977a/" rel="bookmark">
			算法进阶——求二叉树的层序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）。
例如：
给定的二叉树是{3,9,20,#,#,15,7},
该二叉树层序遍历的结果是
[
[3],
[9,20],
[15,7]
]
提示:
0 &lt;= 二叉树的结点数 &lt;= 1500
示例1
输入： {1,2} 返回值： [[1],[2]] 示例2
输入： {1,2,3,4,#,#,5} 返回值： [[1],[2,3],[4,5]] 思路 利用辅助队列，通过bfs（广度优先）算法遍历二叉树，按层次顺序记录节点。
我的解答代码还有一个可以优化的点是，每层的节点数其实就是当前辅助队列的大小，这样其实不需要next_level_num和to_be_handle这2个辅助变量。
解答代码 /** * struct TreeNode { *	int val; *	struct TreeNode *left; *	struct TreeNode *right; *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */ #include &lt;queue&gt; class Solution { public: /** * @param root TreeNode类 * @return int整型vector&lt;vector&lt;&gt;&gt; */ vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode* root) { // write code here vector&lt;vector&lt;int&gt; &gt; res; if (root == nullptr) { return res; } // bfs queue&lt;TreeNode*&gt; nodes; nodes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5393f3a31fa3957a130178c8a8977a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d5e093d4d3f1e1ae2a0cd3ca176eb9/" rel="bookmark">
			(js)循环判断找到满足条件的单项后结束循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(js)循环判断找到满足条件的单项后结束循环 forEach结束循环正确用法：运用抛出异常（try catch） if (newVal != "") { try { this.gxList.forEach((ele) =&gt; { if (this.processId === ele.id) { this.gxDisabled = false;//自己的逻辑 throw "StopIteration"; } else { this.gxDisabled = true;//自己的逻辑 } }); } catch (e) { if (e !== "StopIteration") throw e; } } 1.中断forEach:https://blog.csdn.net/lwf3115841/article/details/131103069
2.https://blog.csdn.net/qq_37899792/article/details/97117010
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5209c0648f13759d1f55a069f1e2c6c/" rel="bookmark">
			【JVM】内存模型（调参调优、GC、对象池、内存泄漏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jvm内存模型 JVM 内存模型是 Java 虚拟机规范中定义的一种内存模型，用于规范 Java 程序在不同线程之间的共享内存访问行为。
在 JVM 内存模型中，将内存分为主内存和工作内存。主内存是所有线程共享的内存区域，包括 Java 堆、方法区等。而工作内存则是每个线程私有的内存区域，用于存储线程执行过程中的局部变量、临时变量等。
在 Java 程序中，当一个线程执行时，它会将主内存中的共享变量拷贝一份到自己的工作内存中，然后在工作内存中进行操作。当线程需要将修改后的共享变量写回主内存时，需要通过内存同步机制（如锁）来保证线程安全。
JVM 内存模型还定义了一些规则，如可见性、顺序性等，用于保证线程之间的内存访问行为是正确和安全的。
总之，JVM 内存模型是 Java 多线程编程中的重要概念，它定义了线程之间共享内存的访问规则，保证了程序的正确性和线程安全性。
工作内存是如何分配和回收的？ 工作内存是指每个线程私有的内存区域，用于存储线程执行过程中的局部变量、临时变量等。在 Java 中，工作内存的分配和回收是由 JVM 自动管理的。
当一个线程创建时，JVM 会为该线程分配一定大小的工作内存。工作内存的大小是由 JVM 实现决定的，可以通过 -Xmx 和 -Xms 等参数来设置。一般情况下，工作内存的大小是根据程序的需求动态调整的。
当线程执行完毕后，工作内存会被自动回收。如果线程在执行过程中产生了大量的垃圾对象，导致工作内存不足，那么 JVM 会触发垃圾回收机制，回收不再使用的对象，释放工作内存空间。
总之，工作内存的分配和回收是由 JVM 自动管理的，不需要程序员手动干预。但在编写程序时，需要注意避免产生大量的垃圾对象，以免导致工作内存不足。
如果工作内存不足，会有什么后果？ 如果工作内存不足，会导致以下后果：
内存溢出：当工作内存不足时，线程无法再创建新的对象或分配更多的内存空间，这会导致程序出现内存溢出异常，从而终止程序的执行。
性能下降：当工作内存不足时，JVM 会频繁地触发垃圾回收机制，以回收不再使用的对象，释放内存空间。垃圾回收会暂停线程的执行，这会导致程序的性能下降。
不稳定：当工作内存不足时，线程可能会出现竞态条件或其他不稳定的情况，这会导致程序出现意外的行为或结果。
为了避免工作内存不足的问题，程序员可以采取以下措施：
优化程序代码，减少对象的创建和内存的使用。调整 JVM 的内存参数，增加工作内存的大小。使用合适的数据结构和算法，提高内存的使用效率。避免使用大量的线程，减少线程之间的竞争。 总之，工作内存不足会导致程序出现各种问题，因此需要程序员在编写程序时注意优化内存使用，避免出现内存不足的情况。
如何调整JVM的内存参数以增加工作内存的大小？ 要增加 JVM 的工作内存大小，可以通过调整 JVM 的内存参数来实现。以下是一些常见的调整方法：
使用 -Xmx 参数：-Xmx 参数用于指定 JVM 最大可用内存大小。例如，如果你希望将 JVM 的最大可用内存设置为 2GB，可以使用以下命令： java -Xmx2g your_program 使用 -XX:MaxHeapSize 参数：-XX:MaxHeapSize 参数也可以用于指定 JVM 的最大堆大小，与 -Xmx 参数类似。例如： java -XX:MaxHeapSize=2g your_program 使用 -Xms 参数：-Xms 参数用于指定 JVM 初始堆大小。将 -Xms 参数设置为与 -Xmx 参数相同或相近的值，可以减少内存调整的开销。例如： java -Xmx2g -Xms2g your_program 请注意，具体的命令可能因操作系统和 Java 版本而有所不同。在调整内存参数之前，建议先了解你正在使用的 Java 版本和操作系统的相关文档，以确保正确设置参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5209c0648f13759d1f55a069f1e2c6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4fa52d7b7fdf946413b3b32d2191c82/" rel="bookmark">
			个推消息推送“智能文案推荐算法”获评中国信通院2023年“数据&#43;”行业应用优秀案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12月27日，2024中国信通院ICT深度观察报告会“用户权益保护分论坛”在北京开幕。来自工信部、信通院、泰尔终端实验室、电信终端产业协会等主管部门和行业协会机构的专家领导，以及产业上下游的企业代表共聚一堂，深度交流和探讨个人信息安全、用户权益保护以及数据要素价值流通等相关热点话题。
论坛现场还重磅发布了用户权益保护系列标准以及“智御”个人信息保护大模型，为产业健康发展注入新力量。每日互动（个推）、阿里云、百度等头部企业共同参与了“智御”大模型的共建共享仪式。同时，每日互动高级副总裁刘宇也受邀出席本次活动，并发表主题演讲，分享了公司在数据安全合规、数据要素价值提取等方面的最新探索与实践。
▲每日互动高级副总裁金岩（左一）上台参与个人信息保护“智御”大模型共建共享仪式
▲每日互动高级副总裁刘宇现场发表主题演讲
随着“互联网+”与各行业的深度融合及数字经济的快速发展，个人信息保护已经成为用户最关心最直接最现实的利益问题之一。如何在保障个人信息安全、切实维护好用户合法权益的同时，充分挖掘和释放数据要素价值，成为当前数字经济高质量发展亟需解决的难题。
针对此问题，刘宇在现场演讲中表示，“个人信息保护和数字经济产业的健康发展需要行业各方协同发力。每日互动一直高度重视个人信息保护和数据安全。我们建立了全链路的数据安全防护机制，不断夯实产品和服务的安全合规能力，同时还结合新技术和新模式，对如何高效提取和释放数据价值、让数据价值安全流转等课题进行了大量的研究、探索。尤其是在数据匿名化和多方数据的联合计算方向，我们和行业伙伴一起进行了深度共创，在具体的业务场景中对相关技术和模式进行了充分验证，取得了一定的实践成果”。
1
采用数据匿名化技术和中立国模式，
护航数据安全
“数据匿名化能够防止数据被追踪，是数据安全使用的核心基础，而完善的标识体系则是实现数据匿名化的可行路径”。刘宇介绍，为了进一步落实“数安法”“个保法”等相关法律法规要求，每日互动已经在使用新一代的标识体系开展业务，“这种全新的标识体系由权威机构提供服务，它设置了严格的受控机制、过期机制和匿名机制，实现了数据的匿名化和模糊化，能够防止数据被追踪，符合个人信息保护规范，使用户隐私权益得到有效保护，也进一步提升了公司业务的合规水平”
同时，标识体系也是数据价值流通的载体。为了实现数据价值提取和流通过程中的安全、合规，“我们还采用了一种叫做‘大数据联合计算（中立国）’的模式，在可信的中立计算环境中生成匿名化ID，与行业客户开展多方数据的融合计算，让‘数据价值流转而数据不流转’”。刘宇强调，这其中监管方、业务方、技术方之间做到了“三隔离”，在可信环境中生成的匿名化ID也只适用当前计算场景，模型、算法等数据计算结果经严格审核后输出，原始数据消除，让“数据可用不可拥”，使得数据价值提取和流通的整个链路做到了边界清晰、高度可控。
2
创新数据场景应用，让数好用，把数用好
刘宇还对整个数据要素市场和产业链进行了全局分析，他表示，“在从数据资源到数据资产再到数据要素的大循环当中，数据经历了从采集到加工、处理、流通再到分析、应用等各个环节，包括数据源方、数据处理方、数据应用方等在内的产业链上下游企业均参与其中。因此，要释放数据要素价值，需要各方力量从各个层面、各个环节共同发力”。
数据智能服务商每日互动作为产业链中的重要角色，一方面通过数据匿名化技术和“中立国”模式提供的可信计算环境，与其他数据源方实现数据融合；另一方面也打造数据智能操作系统，输出数据治理、加工能力和数据应用经验、Domain Know-how，帮助相关政府部门和行业客户等数据需求方更加便捷、高效地进行数据治理和挖掘，加速数据应用创新。
刘宇介绍，“目前，我们已经与互联网、品牌营销、智慧交通等行业的众多客户和伙伴合作，基于数据匿名化技术和中立国模式等，在安全、合规的前提下实现‘让数好用，把数用好’，推动数据要素价值释放和数字经济产业发展。”
比如，在品牌营销行业，每日互动在筑牢安全基石的前提下，携手快消、美妆、母婴等行业客户，开展多方画像联合统计、联合建模、多触点投放归因分析等数智营销实践。“每日互动拥有海量的三方数据，和品牌广告主的一方数据安全融合后，进行联合建模，搭建购买预测模型，从而帮助品牌主从茫茫人海中找到高潜力购买人群；同时，通过与媒体投放回流数据等进行融合计算、多方验证，还可以帮助品牌主更加清晰、透明地量化投放效果。另外，在每日互动数据能力的加持下，品牌广告主能够从更多的维度深入洞察细分人群的兴趣偏好和内在需求，制定出更加有效的营销策略，有数可依地科学改进产品体验、优化广告创意，帮助提升品牌营销效能的同时，切实保障好消费者权益”。
值得一提的是，2024中国信通院ICT深度观察报告会·深圳分会场也同期举办。分会场上发布了“2023年‘数据+’行业应用优秀案例”，每日互动申报的「智能文案推荐算法」「大数据赋能蒙牛乳制品品牌精准投放」两个案例双双获评“2023年‘数据+’行业应用优秀案例”。
▲案例获奖证书
这两个案例正是每日互动结合数据匿名化等新技术和大数据联合计算（中立国）等新模式，让数好用，把数用好，安全提取、充分释放数据要素价值，增能垂直行业发展的生动实践。
“大数据有大责任”。每日互动深知个人信息保护和数据安全责任重大，未来公司将持续落实相关法律法规要求，同时加强技术研究和创新，积极与生态伙伴展开交流合作，在充分保障用户权益与数据安全合规的前提下，进一步发挥出数据要素乘数效应，推动数字经济高质量发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4c44f5d902da436e3aa6323314bc78/" rel="bookmark">
			C&#43;&#43;连接数据库（DataBase）之加载外部依赖项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 在VS中进行配置一、 先找到VS的解决方案资源管理器：二、 找到“属性”，进行附加项配置三、 移植libmysql.dll目录 在VSCode中进行配置依赖文件的移动库文件的移动可能遇到的问题 重点！！！！！！！（必看！！！！） C++在语言层面上没有提供数据库操作，我们需要使用Orcle公司对MySQL提供的接口对其进行操作，这就需要使用外部依赖项，因此我们需要进行一些配置。 在VS中进行配置 一、 先找到VS的解决方案资源管理器： 可能新手在关闭了它之后就找不到了，如果我们需要再次找到它，首先需要找到视图：
然后在其下拉菜单中找到解决方案资源管理器，单击它就好了：
二、 找到“属性”，进行附加项配置 找到属性之后，单击进入；
到这里，就要正式开始进行附加项配置了：
找到：“C/C++” =&gt; “常规” =&gt; “附加包含目录”：
然后就开始”编辑附加包含目录“：
按照下图步骤选择，就会成功进入”系统文件资源管理器“：
然后找到本机中MySQL的安装文件夹，其中能够找到：MySQL Server 8.0（或类似这种），我们所需要的头文件和库文件都在其中：
此处我们找到MySQL Server 8.0/include，将其加入到附加包含目录中：
完成后应该就是上图那样。
接下来，找到：“链接器” =&gt; “常规”：
选择MySQL Server 8.0/lib，这一步的操作和刚才加载include的操作类似，只是这是加载lib目录，也就是库目录：
然后就是跟刚刚类似的编辑操作：添加附加依赖项"libmysql.lib"
这样大致就好了。
三、 移植libmysql.dll目录 只是完成刚刚的操作还是没法进行数据库连接的，当我们运行程序的时候会报错，显示：”无法找到libmysql.dll文件，我们需要在刚刚的MySQL Server 8.0/lib文件夹中找到这个文件：
将其复制粘贴到本项目的Debug文件夹中，这样就行了，在这里，我这个文件的存放路径即为：“C:\Users\Lenovo\Desktop\demo\connectMysql\x64\Debug\libmysql.dll”。
这样就完成了外部依赖项的配置。
在VSCode中进行配置 VSCode我觉得是不太适合用来进行项目编写的，因此在写项目的时候我一般使用VS，但是VSCode的轻量级又是让我爱不释手的地方，在VSCode中连接数据库我一般是直接将需要使用到的文件进行一个复制操作，放在项目文件下。
我一般喜欢使用不同的文件夹来包含不同的文件：bin（存放源文件），include（存放包含文件），lib（存放库文件），output（存放二进制输出文件），例如这样：
依赖文件的移动 在连接数据库的时候，我们使用到了mysql.h文件，因此我们需要将MySQL Server 8.0/include完全拷贝进我们的项目文件中（不能只将mysql.h拷贝，我试验过了，mysql.h中还使用了大量的其他文件，一个个复制黏贴搞起来会很麻烦），这个文件夹就可以放在一个叫做include的文件夹中，并且这么做也是合乎规范的。这步做完后应该是这样的：
库文件的移动 完成了上面这步，我们的文件中就已经能够找到mysql.h文件了，但是我们仍然不能正常编译运行文件，因为我们只是引用了头文件，而mysql.h的实现代码都在库文件中，即：mysql.dll和mysql.lib，这两个文件肯定已经不陌生了，一个是动态库一个是静态库，我们需要在MySQL Server 8.0/lib中找到这两个文件，并将其放在我们项目的lib文件中，除此之外还要找到mysqlclient.lib，这个文件负责与MySQL服务器进行通信，就像这样：
我们也可以只是用dll和lib中的其中一个，这个道理也很简单我相信大家都能理解，如果不能理解就去看看什么是动态库什么是静态库了吧。
可能遇到的问题 在这么做完之后，我们在bin中编写我们的源文件，按照道理来说就是能够正常运行的了，但是我们照常点击运行却会报错：
这是因为在vscode中，它实际上是通过终端进行操作的，跟我们在Linux系统中使用命令行是一样的，这一点我们通过C++插件的配置就能看出来（tasks.json）：
因此，如果不想重写tasks.json中的配置的话，我们就需要使用命令行，像在Linux中编译C++程序一样：
g++ ./bin/main.cpp -Llib -lmysql -Iinclude -o ./output/main.exe 当然，我们也可以使用makefile，但是这似乎需要一些额外的配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f4c44f5d902da436e3aa6323314bc78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a651d98603de9f1a46954ad2d7bb2694/" rel="bookmark">
			Java8 新的日期/时间API操作和示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Java8 新的日期/时间API操作
（1）LocalDate、LocalTime 和 LocalDateTime 时间类
（2）Instant、Duration 和 Period 时间间隔类
（3）Temporal、TemporalField 和 ChronoField
（4）时间、日期设置和修改
（5）时间、日期解析和格式化
（6）不同时区的时间处理
2、日期/时间 API 使用示例
（1）通过 Java 的基本语法来实现万年历
（2）Java 获取一年中所有的周六和周日
1、Java8 新的日期/时间API操作 Java 旧的日期时间类 java.util.Date 和 java.util.Calendar 存在可变性，导致在多线程环境下使用时会存在线程安全问题。在新的 API 中，几乎所有的类都是不可变的，从而保证了线程安全性。此外，旧的 API 命名不清晰，使得日期时间处理相对困难。新的 API 使用了更清晰和直观的命名，使得代码更易读、更易写。
（1）LocalDate、LocalTime 和 LocalDateTime 时间类 LocalDate 和 LocalTime 是 Java 中 java.time 包下的两个日期时间类，用于分别表示日期和时间，它们不包含时区信息，仅仅表示日期或时间部分。//时间和日期可以进行分开
LocalDate：用于表示日期，包含年、月、日，但不包含时、分、秒和时区信息，可以使用 now() 方法获取当前日期，或者使用 of() 方法指定特定的年、月、日创建实例。
// 获取当前日期 LocalDate currentDate = LocalDate.now(); // 创建特定日期 LocalDate specificDate = LocalDate.of(2023, 12, 31); // 获取年、月、日 int year = currentDate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a651d98603de9f1a46954ad2d7bb2694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa7e7fd0cba5802fea41aee4d9d9c0bf/" rel="bookmark">
			Oracle 查询某个时间之内的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //一月之内 SELECT * FROM ESS.E_LOG WHERE E_LOG."ETime" BETWEEN sysdate-interval '7' month AND SYSDATE; SELECT * FROM ESS.E_LOG WHERE to_char(E_LOG."ETime",'yyyy-mm-dd hh24:mi:ss') between to_char(sysdate-225,'yyyy-mm-dd hh24:mi:ss') and to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'); //一周之内 select * from ESS.E_LOG where E_LOG."ETime" &gt; sysdate - interval '7' day; //一年之内 select count(*) from ESS.E_LOG WHERE E_LOG."ETime" BETWEEN sysdate-interval '1' year AND SYSDATE; //sysdate获取的时间是Oracle数据库系统时间 select sysdate from dual; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88599e9a4416527dbe0de98402e419c3/" rel="bookmark">
			什么叫一个“模块”？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块（Module）：可以编译的、独立存在的软件实体，对应一个动态链接库（.dll）、可执行文件（.exe）、静态库（.lib）、控件（.ocx）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d952db4b5b000144f91ca03e5f9e410/" rel="bookmark">
			【Netty】基于Netty实现RPC框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 分布式架构网络通信基本原理什么是RPCRMI 基于Netty实现RPC框架需求介绍代码实现 分布式架构网络通信 在分布式服务框架中，一个最基础的问题就是远程服务是怎么通讯的，在Java领域中有很多可实现远程通讯的技术，例如：RMI、Hessian、SOAP、ESB和JMS等，它们背后到底是基于什么原理实现的呢?
基本原理 要实现网络机器间的通讯，首先得来看看计算机系统网络通信的基本原理，在底层层面去看，网络通信需要做的就是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、aio三种方式，所有的分布式应用通讯都基于这个原理而实现。
什么是RPC RPC全称为remote procedure call，即远程过程调用。借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式。
比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。
RPC架构
一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及ServerStub，这个Stub可以理解为存根。
客户端(Client)，服务的调用方。客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。服务端(Server)，真正的服务提供者。服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法 过程如下：
客户端（client）以本地调用方式（即以接口的方式）调用服务；客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；客户端通过socket将消息发送到服务端；服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）；服务端存根( server stub）根据解码结果调用本地的服务；服务处理本地服务执行并将结果返回给服务端存根( server stub）；服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；服务端（server）通过socket将消息发送到客户端；客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；客户端（client）得到最终结果 RPC的目标是要把2、3、4、5、7、8、9、10这些步骤都封装起来。只剩下1、6、11。
注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。
在java中RPC框架比较多，常见的有Hessian、gRPC、Dubbo 等，其实对 于RPC框架而言，核心模块就是通讯和序列化
RMI Java RMI，即远程方法调用(Remote Method Invocation)，一种用于实现远程过程调用(RPCRemote procedure call)的Java API， 能直接传输序列化后的Java对象。它的实现依赖于Java虚拟机，因此它仅支持从一个JVM到另一个JVM的调用。
过程如下：
客户端从远程服务器的注册表中查询并获取远程对象引用。桩对象与远程对象具有相同的接口和方法列表（在远程引用层），当客户端调用远程对象时，实际上是由相应的桩对象代理完成的。远程引用层在将桩的本地引用转换为服务器上对象的远程引用后，再将调用传递给传输层(Transport)，由传输层通过TCP协议发送调用；在服务器端，传输层监听入站连接，它一旦接收到客户端远程调用后，就将这个引用转发给其上层的远程引用层； 5）服务器端的远程引用层将客户端发送的远程应用转换为本地虚拟机的引用后，再将请求传递给骨架(Skeleton)； 6）骨架读取参数，又将请求传递给服务器，最后由服务器进行实际的方法调用。如果远程方法调用后有返回值，则服务器将这些结果又沿着“骨架-&gt;远程引用层-&gt;传输层”向下传递；客户端的传输层接收到返回值后，又沿着“传输层-&gt;远程引用层-&gt;桩”向上传递，然后由桩来反序列化这些返回值，并将最终的结果传递给客户端程序。 需求分析:
服务端提供根据ID查询用户的方法
客户端调用服务端方法, 并返回用户对象
要求使用RMI进行远程通信
代码实现:
服务端 import com.lagou.rmi.service.IUserService; import com.lagou.rmi.service.UserServiceImpl; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; /** * 服务端 */ public class RMIServer { public static void main(String[] args) { try { //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d952db4b5b000144f91ca03e5f9e410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9128100d6076019192e0b310a3a0c2d/" rel="bookmark">
			flutter学习-day22-使用GestureDetector识别手势事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 介绍2. 使用2-1. 单击双击和长按2-2. 拖动和滑动2-3. 缩放 3. 注意点 1. 介绍 在 flutter 中，GestureDetector 是手势识别的组件，可以识别点击、双击、长按、拖动、缩放等手势事件，并且可以与子组件进行交互，构造函数属性如下：
(new) GestureDetector GestureDetector({ // 可选的Key属性，用于标识该组件 Key? key, // 可选的子组件，将被包裹在GestureDetector中 Widget? child, // 当用户按下手指时触发的事件处理函数 void Function(TapDownDetails)? onTapDown, // 当用户抬起手指时触发的事件处理函数 void Function(TapUpDetails)? onTapUp, // 当用户轻触屏幕时触发的事件处理函数 void Function()? onTap, // 当用户取消触摸屏幕时触发的事件处理函数 void Function()? onTapCancel, // 当用户轻触屏幕的次级区域时触发的事件处理函数 void Function()? onSecondaryTap, // 当用户按下次级区域的手指时触发的事件处理函数 void Function(TapDownDetails)? onSecondaryTapDown, // 当用户抬起次级区域的手指时触发的事件处理函数 void Function(TapUpDetails)? onSecondaryTapUp, // 当用户取消触摸次级区域的屏幕时触发的事件处理函数 void Function()? onSecondaryTapCancel, // 当用户轻触屏幕的三级区域时触发的事件处理函数 void Function()?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9128100d6076019192e0b310a3a0c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f109e5c6a5a19f652f2411c9f2e22a8/" rel="bookmark">
			Amazon Q | 融会贯通的 AI 开发助手来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为亚马逊云科技最大的年度活动， re:Invent 总是能为我们带来各种惊喜。在 re:Invent 2023 上发布的 Amazon Q（预览版）更是吸引了开发者的眼球。
亚马逊云科技开发者社区为开发者们提供全球的开发技术资源。这里有技术文档、开发案例、技术专栏、培训视频、活动与竞赛等。帮助中国开发者对接世界最前沿技术，观点，和项目，并将中国优秀开发者或技术推荐给全球云社区。如果你还没有关注/收藏，看到这里请一定不要匆匆划过，点 这里让它成为你的技术宝库！ 我对这个全新的 AI 产品也非常感兴趣，所以抽出时间了解了 Amazon Q 的功能及应用场景。它真是解决开发者工作效率问题的利器！
Amazon Q 是开发者的技术专家，是组织的业务专家，同时它还是亚马逊云科技的云专家。 Amazon Q 是个技术专家 Amazon Q 是一个基于自然语言交互的 AI 智能助手。对于开发者来说，最关键的特点是可以覆盖开发、业务分析以及云应用建设的全流程。
Amazon Q 可以解读代码逻辑，还可以帮助开发人员完成日常的软件开发任务。只需点击几下，就能从问题中的一个想法转变为经过完整测试、准备合并、运行的应用代码，并且可以使用自然语言输入。
要求 Amazon Q 描述源代码文件 Amazon Q 可以在支持的集成开发环境中使用。通过与 Amazon Q 聊天或在聊天框中键入 / 来调用操作，在集成开发环境中提出问题并获得帮助。
通过 Amazon Q 加快功能开发 通过 Amazon CodeCatalyst 中集成 Amazon Q(预览版) ，帮助开发者加快软件开发任务的实施，如添加注释和 README、完善问题描述、生成小类和单元测试以及更新 CodeCatalyst 工作流等占用开发人员时间的乏味且无差异的任务。
开发人员只需点击几下鼠标，就能从问题中的一个想法变成经过全面测试、可合并运行的代码。人工智能可以完成以下繁重的工作：将人工提示转换为可执行的计划，汇总源代码库，生成代码、单元测试和工作流程，并在拉取请求中汇总任何变更，然后将其分配给开发人员。
开发者还可以直接就已发布的拉取请求向 Amazon Q 提供反馈，并要求它生成新的修订版。如果代码更改未达到预期，还可以直接从拉动请求中创建一个开发环境，手动进行任何必要的调整，发布一个新的修订版，并在获得批准后进行合并。
一个具体的例子：在现有应用程序中更改 API。
在导航窗格中选择 Issues, 然后选择 Create Issue, 将 issue 命名为 “Change the get_all_mysfits() API to return mysfits sorted by the Age attribute”（更改 get_all_mysfits() API 以返回按年龄属性排序的 mysfits）将此 issue 分配给 Amazon Q，并选择 Create Issue。 Amazon Q 会自动将问题转入 in progress 中状态，同时分析问题标题和描述，并制定解决方法。如果开发者已经对 issue 进行了相应的处理，则应在描述中进行总结，以帮助 Q 了解需要做什么。Amazon Q 在工作过程中，会跟进每个阶段并对 issue 发表评论，报告进展情况。它将根据自己对版本库中已有代码的理解和解决方法尝试创建解决方案。当 Amazon Q 生成一个解决方案，它就会创建一个 branch，并将代码提交到该 branch。然后，Amazon Q 会创建一个拉取请求，一旦获得批准，就会将更改合并到默认分支中。拉取请求发布后，Amazon Q 会将问题状态更改为 in review 中，以便开发团队知道代码已准备好供审核。 记录变更 拉取请求的开发者可以要求 Amazon Q 记录所有发布的供审核的变更，来节省时间。我们常见的方式，拉取请求的开发者必须自己手动编写描述，或者嫌麻烦不编写描述。如果不提供说明，审核人员就很难了解正在进行哪些更改以及更改的原因，从而延误审核流程，减慢软件交付速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f109e5c6a5a19f652f2411c9f2e22a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887bede5002b74d1ea739f156d9509b5/" rel="bookmark">
			vite 查看项目依赖资源打包后的占比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vite 打包的时候发现 dist 包挺大的；可以查看相应依赖资源的所占比例去压缩对应资源或按需导入对应资源；
使用的是 rollup-plugin-visualizer ；一个打包体积分析插件，对应webpack中的webpack-bundle-analyzer。配置好后运行构建命令会生成一个 stats.html。
1、安装资源
npm i rollup-plugin-visualizer -D
2、添加 vite.config.ts 配置
import { visualizer } from "rollup-plugin-visualizer"
plugins: [ visualizer({ open: true }) ]
3、打包
npm run build
就出现了对应的html页面，打开后会出现这样的一个页面；可以查看依赖资源所占份额；
这样就可以看到各个资源的占比；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b33c79d53bc1752a003ee7570930f0/" rel="bookmark">
			17-网络安全框架及模型-信息流模型（FM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
信息流模型（FM）
1 背景概述
2 基本概念
3 基本原理
4 应用领域
5 信息流分析方法
6 优势和局限性
7 应用场景
8 挑战和机遇
信息流模型（FM） 1 背景概述 在当今数字化时代，信息的传输和交换变得越来越重要。然而，随之而来的是信息泄露和安全威胁的风险。因此，构建安全的信息传输体系成为了亟待解决的问题。
信息流模型（简称FM）作为一种访问控制模型的变形，强调信息传输过程中的安全性。该模型不检查主体对客户的存取，而是根据两个客体的安全属性来控制从一个客体到另一个客体的信息传输。信息流模型可以用于分析系统的隐蔽通道，防止敏感信息通过隐蔽通道泄露。隐蔽通道通常表现为低安全等级主体对于高安全等级主体所产生信息的间接读取，通过信息流分析以发现隐蔽通道，阻止信息泄露途径。
2 基本概念 在介绍信息流模型之前，我们首先需要了解传统的访问控制模型，包括基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）等。RBAC强调用户角色和资源之间的关系，而ABAC则强调用户属性和资源之间的关系。这些传统的访问控制模型主要关注用户对数据的访问权限，而忽视了信息传输过程中的安全性。
3 基本原理 信息流模型与传统访问控制模型的区别：
信息流模型注重信息传输过程中的安全性，将用户、对象和信息流三者结合起来进行访问控制，而传统访问控制模型更注重用户对数据的访问权限。通过引入信息流的概念，信息流模型能够更全面地把握信息的安全性。
客体的安全属性及其在信息流控制中的作用：
客体指受到访问控制保护的对象，如文件、数据库等。在信息流控制中，客体的安全属性决定了对象能否被传输、传输的方式以及哪些主体有权访问它。通过定义客体的安全属性，信息流模型可以确保信息的传输符合安全策略。
主体的角色和限制：
主体指对客体进行访问的实体，如用户、进程、系统等。在信息流模型中，主体受到一定的限制，如访问控制策略、访问控制列表（ACL）和访问控制矩阵等。这些限制确保只有经过授权的主体才能进行信息的传输和访问。
信息传输的规则和约束：
信息传输遵循的规则和约束包括非干扰规则、无泄露规则和可信度规则等，旨在确保信息传输过程中的安全性和完整性。非干扰规则保证了信息传输不会对系统的正常运行造成干扰，无泄露规则确保信息不会被未经授权的主体访问，可信度规则用于判断信息的可靠程度。
4 应用领域 隐蔽通道的定义和特征：
隐蔽通道是指利用计算机系统的非正常通信路径，将信息传递给未经授权的主体。隐蔽通道通常难以被检测和阻断，其特征包括低带宽、低时延、低可控性和高隐蔽性等。隐蔽通道的存在给信息安全带来了严重的威胁。
分析系统中的隐蔽通道：
利用信息流模型可以发现系统中的隐蔽通道，并采取相应的防范措施。这些措施包括限制主体的访问权限、监测和过滤数据流量、加密和验证数据等。通过分析系统中的隐蔽通道，可以发现系统中潜在的安全漏洞，并加以修补。
防止敏感信息泄露的重要性：
敏感信息泄露可能会导致严重的后果，如个人隐私泄露、商业机密泄露和国家安全受损等。利用信息流模型可以有效防止敏感信息泄露，例如通过数据分类和标记、限制数据流向和访问权限等方式。信息流模型能够确保敏感信息只传输给经过授权的主体，从而降低信息泄露的风险。
如何利用信息流模型阻止信息泄露途径：
信息泄露途径包括隐蔽通道、窃听攻击、篡改攻击等。利用信息流模型可以识别和阻止可能导致信息泄露的途径，包括强化访问控制、加密和认证数据等。通过采用信息流模型，可以在信息传输过程中对数据进行全面的安全性检测和控制，从而避免信息泄露的风险。
5 信息流分析方法 定义信息流分析：信息流分析是对信息传输过程中的安全问题进行检测和分析的过程，旨在识别隐蔽通道和其他安全漏洞。信息流分析可以采用静态分析和动态分析等技术。静态分析主要关注程序的源代码和静态特征，而动态分析则通过运行时状态来分析信息流。
常用的信息流分析技术和工具：静态分析技术包括源代码分析、污点分析和模型检测等。源代码分析通过分析程序的源代码来检测安全问题。污点分析通过追踪数据流中的敏感信息来检测潜在的泄露风险。模型检测则通过建立模型来验证系统的安全性。动态分析技术包括跟踪分析、动态符号执行和模糊测试等。跟踪分析通过监视程序的执行来检测异常行为。动态符号执行通过对程序进行符号执行来发现潜在的漏洞。模糊测试则通过向程序输入随机数据来发现输入错误导致的安全漏洞。常用的信息流分析工具包括Flint、IFDS/IDE和Oski等。
如何发现和识别隐蔽通道：发现和识别隐蔽通道需要采用信息流分析技术和工具，例如检测数据流量、分析协议和检测异常行为等。通过对系统中的数据流进行检测和分析，可以发现潜在的隐蔽通道。在实际应用中，还需要结合其他安全措施，如数据分类和标记、访问控制和加密等，以提高隐蔽通道的识别率和阻断能力。
信息流分析在系统安全中的价值：信息流分析是提高系统安全性的重要手段之一，可以有效识别和防范隐蔽通道和其他安全漏洞。在实际应用中，信息流分析可以结合其他安全措施，如访问控制、加密和认证等，构建完整的系统安全架构。通过采用信息流分析方法，可以提高系统对安全威胁的识别和应对能力，保障信息的安全传输和存储。
6 优势和局限性 信息流模型作为一种强调信息传输安全的访问控制模型，有其独特的优势和局限性。
优势：
精细的访问控制：信息流模型可以对信息传输过程进行精细控制，包括数据的传输、传输方式和访问控制等方面。通过对客体的安全属性、主体的角色和限制以及信息传输的规则和约束等进行定义和配置，可以确保信息传输的安全性和完整性。
防止隐蔽通道：隐蔽通道是指利用计算机系统的非正常通信路径，将信息传递给未经授权的主体。隐蔽通道通常难以被检测和阻断，需要采用信息流模型的方法和技术进行发现和识别。通过限制主体的访问权限、监测和过滤数据流量、加密和验证数据等方式，可以有效防止隐蔽通道的产生和传播。
防止敏感信息泄露：敏感信息泄露可能会导致严重的后果，如个人隐私泄露、商业机密泄露和国家安全受损等。信息流模型可以有效防止敏感信息泄露，例如通过数据分类和标记、限制数据流向和访问权限等方式。
灵活的配置和调整：信息流模型可以根据不同的场景和需求进行灵活的配置和调整。可以通过修改客体的安全属性、主体的角色和限制以及信息传输的规则和约束等方面，来满足不同的安全需求。
局限性：
数据分类和标记的复杂性：信息流模型需要对数据进行分类和标记，以便于进行访问控制和信息流分析。但是，数据的分类和标记可能会比较复杂，需要考虑到数据的类型、级别、来源和用途等因素。
访问控制策略的复杂性：信息流模型中的访问控制策略需要考虑到多个因素，如客体的安全属性、主体的角色和限制以及信息传输的规则和约束等。访问控制策略的复杂性可能会导致配置和管理的难度增加。
信息流分析技术的局限性：信息流模型需要采用信息流分析技术和工具，以识别和防范隐蔽通道和其他安全漏洞。但是，信息流分析技术和工具可能存在一些局限性，如对复杂协议和数据格式的支持不足等。
7 应用场景 场景一：金融行业中的信息流控制
金融行业中涉及大量的敏感数据和交易信息，需要采取严格的信息流控制措施。例如，在银行系统中可以通过对客户信息、交易记录和资金流向等进行分类和标记，以及限制访问权限和加密传输等方式，来确保信息传输的安全性和完整性。
场景二：医疗保密数据的信息流管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b33c79d53bc1752a003ee7570930f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de99c6862279ed417e085d221281dc3/" rel="bookmark">
			C语言——小细节和小知识7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、逆序字符串 1、递归1 #include &lt;stdio.h&gt; #include &lt;string.h&gt; void ReverseArray(char *str) { char temp = *str;//1 int len = (int)strlen(str); *str = *(str + len - 1);//2 *(str + len - 1) = '\0';//3 if(strlen(str + 1) &gt;= 2)//只要字符串还大于2，就接着递归，接着交换 { ReverseArray(str + 1);//改变字符串的长度 } *(str + len - 1) = temp;//4 } int main() { char arr[10] = "abcdef"; ReverseArray(arr); printf("%s", arr); return 0; } 递进
这时字符串长度为0，小于2。
开始回归，回归过程是之前的临时变量从前往后依次放。
最终，递归完成，字符串反转完成。
2、递归2 #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2de99c6862279ed417e085d221281dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec56794433e269d05ad6db5f32f70da/" rel="bookmark">
			12.28
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的遍历（前序，中序，后序） 思路 递归是二叉树遍历情况下思路有点绕，但是代码最简洁的一种。
总结 简单熟悉了下语法。
递归三要素：
确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 代码 //前序 public static List&lt;Integer&gt; preorderTraversal(TreeNode root){ List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); preorder(root,res); return res; } public static void preorder(TreeNode root,List&lt;Integer&gt; res){ if (root!=null){ res.add(root.val); preorder(root.left,res); preorder(root.right,res); } } //中序 public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); postorder(root,res); return res; } public void postorder(TreeNode root,List&lt;Integer&gt; res){ if (root!=null){ postorder(root.left,res); postorder(root.right,res); res.add(root.val); } } //后序 public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); inorder(root,res); return res; } public void inorder(TreeNode root,List&lt;Integer&gt; res){ if (root!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fec56794433e269d05ad6db5f32f70da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210d041e63fd6a35f4cf1b74b3f13f20/" rel="bookmark">
			在matlab中对hsv进行均匀量化和非均匀量化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，进行非均匀量化，H,S,V三通道分别量化为16,4,4级，返回一个向量。量化依据如下表：
function vec = getHsvHist(Image) [M,N,O] = size(Image); if O~= 3 error('3 components are needed for histogram'); end [h,s,v] = rgb2hsv(Image); H = h; S = s; V = v; h = h*360; %将hsv空间非等间隔量化： % h量化成16级； % s量化成4级； % v量化成4级； for i = 1:M for j = 1:N if h(i,j)&lt;=15||h(i,j)&gt;345 H(i,j) = 0; end if h(i,j)&lt;=25&amp;&amp;h(i,j)&gt;15 H(i,j) = 1; end if h(i,j)&lt;=45&amp;&amp;h(i,j)&gt;25 H(i,j) = 2; end if h(i,j)&lt;=55&amp;&amp;h(i,j)&gt;45 H(i,j) = 3; end if h(i,j)&lt;=80&amp;&amp;h(i,j)&gt;55 H(i,j) = 4; end if h(i,j)&lt;=108&amp;&amp;h(i,j)&gt;80 H(i,j) = 5; end if h(i,j)&lt;=140&amp;&amp;h(i,j)&gt;108 H(i,j) = 6; end if h(i,j)&lt;=165&amp;&amp;h(i,j)&gt;140 H(i,j) = 7; end if h(i,j)&lt;=190&amp;&amp;h(i,j)&gt;165 H(i,j) = 8; end if h(i,j)&lt;=220&amp;&amp;h(i,j)&gt;190 H(i,j) = 9; end if h(i,j)&lt;=255&amp;&amp;h(i,j)&gt;220 H(i,j) = 10; end if h(i,j)&lt;=275&amp;&amp;h(i,j)&gt;255 H(i,j) = 11; end if h(i,j)&lt;=290&amp;&amp;h(i,j)&gt;275 H(i,j) = 12; end if h(i,j)&lt;=316&amp;&amp;h(i,j)&gt;290 H(i,j) = 13; end if h(i,j)&lt;=330&amp;&amp;h(i,j)&gt;316 H(i,j) = 14; end if h(i,j)&lt;=345&amp;&amp;h(i,j)&gt;330 H(i,j) = 15; end end end for i = 1:M for j = 1:N if s(i,j)&lt;=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/210d041e63fd6a35f4cf1b74b3f13f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182cc2d0481f5913e6dd8bfc73de92dd/" rel="bookmark">
			基于element ui封装table组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
1.封装表格代码如下
&lt;template&gt; &lt;div&gt; &lt;div class="TableList"&gt; &lt;el-table v-loading="loading" @selection-change="selectionChange" class="table" :data="tableData" :border="hasBorder" :row-class-name="tableRowClassName" ref="multipleTable" :header-cell-style="{ background: 'rgb(245 247 250)', color: 'rgb(51, 51, 51)', }" &gt; &lt;el-table-column type="selection" width="50" v-if="selectionShow"&gt; &lt;/el-table-column&gt; &lt;!-- 序号 --&gt; &lt;el-table-column v-if="hasIndex" type="index" label="序号" header-align="center" align="center" width="80"&gt; &lt;/el-table-column&gt; &lt;!-- 其他 --&gt; &lt;template v-for="item in tableColumnOptions"&gt; &lt;!-- 插槽列 --&gt; &lt;el-table-column v-if="item.columnType" :key="item.label" :prop="item.prop" :label="item.label" :width="item.width" :header-align="item.headerAlign || 'center'" :align="item.align || 'center'" &gt; &lt;template slot-scope="{ row }"&gt; &lt;slot :name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/182cc2d0481f5913e6dd8bfc73de92dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0634d22c860f42f950780878784da7c/" rel="bookmark">
			轻松实现ESP01S下载HTTP文件的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 文章使用ESP01S模块为例，直接访问HTTP链接下载文件并保存到Flash中，可扩展完成网络资源获取、WIFI OTA升级等操作，文章以ESP01S通过WIFI下载BIN文件为例。
实现方法：
方法1：串口AT指令获取方法2：Arduino IDE编程获取 硬件准备：
ESP01S模块（必需）W25Q32（仅用于ArduinoIDE开发时保存文件） 二、ESP01S 1. 简介 ESP01S是一款基于ESP8266的紧凑型通信模块，集成 Wi-Fi MAC/ BB/RF/PA/LNA。支持标准的 IEEE802.11 b/g/n 协议，完整的 TCP/IP 协议栈，可以使设备接入网络平台，实现WIFI或4G通信等功能，淘宝售价5-8元不等。
2.HTTP文件 首先确保浏览器可以访问地址：www.funiot.xyz/upload/test.bin
访问上述链接后能够下载文件，如下所示：
三、下载文件 1. AT指令下载 (1) AT 发送AT测试，收到响应OK
(2) AT+CWMODE=1 配置Station模式，即作为客户端连接到wifi
(3) AT+CWJAP=“funiot”,“funiot.xyz” 连接wifi，wifi名称：funiot，wifi密码：funiot.xyz
(4) AT+CIPSTART=“TCP”,“www.funiot.xyz”,80 建立www.funiot.xyz地址80端口的TCP连接
(5) AT+CIPMODE=1 设置传输模式，1为透传
(6) AT+CIPSEND 进入透传指令传输
(7) HEAD 请求 直接发送：
HEAD /upload/test.bin HTTP/1.1 Host: www.funiot.xyz 注意按照上述换行格式，HTTP的分隔符为两个换行，在编辑框中添加一个新行并勾选“发送新行”，请求成功的话可以看到下图：
这是我们文件下载的请求头，上面我们比较关注的是Content-Length:4672，这个指明了文件的大小。
(8) Get请求 直接发送：
GET /upload/test.bin HTTP/1.1 Host: www.funiot.xyz 这个就是实际的文件内容，我们可以打开之前下载的文件：
(9) Get请求文件的部分数据 可以给GET请求添加限制范围：
GET /upload/test.bin HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0634d22c860f42f950780878784da7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f7b18b7faf032ebd1802d32fd78c30/" rel="bookmark">
			搭建简单的GPT聊天机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一步
进行语料库读取、文本预处理，完成data_utls.py
第二步
进行Seq2Seq模型的构建，完成Seq2Seq.py
第三步
进行模型参数设置、加载词典和数据、数据准备、GPU设置、构建优化器和损失函数，进行模型的训练和测试，完成execute.py。
第四步
通过给出的前端代码，调用flask前端进行测试，完成app.py文件，使用网页端聊天机器人聊天对话。
有问题后台私信 第一步 进行语料库读取、文本预处理，完成data_utls.py data_utls.py
''' 数据处理器 ''' import os import jieba from tkinter import _flatten import json # 读取语料库文件 def read_corpus(corpus_path='../data/dialog/'): ''' corpus_path:读取文件的路径 ''' corpus_files = os.listdir(corpus_path) # 列出文件路径下所有文件 corpus = [] for corpus_file in corpus_files: # 循环读取各个文件内容 with open(os.path.join(corpus_path, corpus_file), 'r', encoding='utf-8') as f: corpus.extend(f.readlines()) corpus = [i.replace('\n', '') for i in corpus] return corpus # 返回语料库的列表数据 print('语料库读取完成！'.center(30, '=')) corpus = read_corpus(corpus_path='.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f7b18b7faf032ebd1802d32fd78c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2395303636651b12680675569dbe88f7/" rel="bookmark">
			10个超级实用的Python模块，建议收藏！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python标准库有超过200个模块，程序员可以在他们的程序中导入和使用，虽然普通程序员对其中许多模块都有一些经验，但很可能有一些好用的模块他们仍然没有注意到。
今天小编就来给大家推荐几个特别好用的Python模块，其中有一部分是在Pandas当中的，方便大家使用了之后更加高效地来进行数据分析。
xmltodict 首先给大家介绍的第三方模块叫做xmltodict，我们从名字上就可以非常直观地看出，该模块的作用在于将xml格式的数据转换成字典，要是没有安装该模块的童鞋，可以通过pip命令来进行安装
pip install xmltodict 假设有如下所示的xml格式的数据
&lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;mydocument has="an attribute"&gt; &lt;and&gt; &lt;many&gt;elements&lt;/many&gt; &lt;many&gt;more elements&lt;/many&gt; &lt;/and&gt; &lt;plus a="complex" b="hello"&gt; element as well &lt;/plus&gt; &lt;/mydocument&gt; 我们尝试来读取当中的数据，用到xmltodict模块，代码如下
xml_result = open('testdb.xml', 'r') xml_dict = xmltodict.parse(xml_result.read()) print(type(xml_dict)) print(xml_dict) output
&lt;class 'dict'&gt; {'mydocument': {'@has': 'an attribute', 'and': {'many': ['elements', 'more elements']}, 'plus': {'@a': 'complex', '@b': 'hello', '#text': 'element as well'}}} 我们也可以尝试来读取当中的一些数据，代码如下
xml_dict.get("mydocument").get("and") output
{'many': ['elements', 'more elements']} 当然我们还可以转换回去，转换成xml格式的数据，这里需要用到的是unparse()方法，代码如下
dict_xml = xmltodict.unparse(xml_dict, pretty=True) UltraJSON ultrajson的底层是用C来编写的，因此作为一个超高速的json编码器和解码器，可以用作是其他大多数json解析器的替换，我们先用pip命令来将其安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2395303636651b12680675569dbe88f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad25f7aeaa866fb9c8d98d318e399d9/" rel="bookmark">
			C(C&#43;&#43;)数组越界但能正常运行？关于数组越界和变量内存地址的一点研究：何时地址连续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C(C++)数组越界但能正常运行？关于数组越界和变量内存地址的一点研究：何时地址连续 前言 今天美丽的本科同班同学xyy问了我一个问题：
她出了一道C++基础题：
第一行输入一个正整数 n n n（ 1 ≤ n ≤ 100 1\leq n\leq 100 1≤n≤100），第二行输入空格隔开的 n n n个正整数（ 1 1 1到 10000 10000 10000），第三行输入空格隔开的两个正整数 x x x和 y y y（ 1 ≤ x , y ≤ n 1\leq x, y\leq n 1≤x,y≤n），按顺序输出这 n n n个数中将第 x x x个数修改为 y y y后的结果（输出一行且用空格隔开）
出这道题的目的之一是考察C++等编程语言的数组越界问题。 n n n的最大值是 100 100 100，如果开辟一个大小为 100 100 100的数组 a a a，并且从下标 1 1 1开始存数据，则 a [ 100 ] a[100] a[100]会发生数组越界。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad25f7aeaa866fb9c8d98d318e399d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb55dcfe9c9d899395e3f5a59a8a3c6/" rel="bookmark">
			Java8中list转map方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在最近的工作开发之中，慢慢习惯了很多Java8中的Stream的用法，很方便而且也可以并行的去执行这个流，这边去写一下昨天遇到的一个list转map的场景。 list转map在Java8中stream的应用 常用方式 1.利用Collectors.toMap方法进行转换
public Map&lt;Long, String&gt; getIdNameMap(List&lt;Account&gt; accounts) { return accounts.stream().collect(Collectors.toMap(Account::getId, Account::getUsername)); }123 其中第一个参数就是可以，第二个参数就是value的值。
2.收集对象实体本身
- 在开发过程中我们也需要有时候对自己的list中的实体按照其中的一个字段进行分组（比如 id -&gt;List），这时候要设置map的value值是实体本身。
public Map&lt;Long, Account&gt; getIdAccountMap(List&lt;Account&gt; accounts) { return accounts.stream().collect(Collectors.toMap(Account::getId, account -&gt; account)); }123 account -&gt; account是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法 Function.identity()，这个方法返回自身对象，更加简洁
重复key的情况。 在list转为map时，作为key的值有可能重复，这时候流的处理会抛出个异常：Java.lang.IllegalStateException:Duplicate key。这时候就要在toMap方法中指定当key冲突时key的选择。(这里是选择第二个key覆盖第一个key) public Map&lt;String, Account&gt; getNameAccountMap(List&lt;Account&gt; accounts) { return accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2)); }123 用groupingBy 或者 partitioningBy进行分组 根据一个字段或者属性分组也可以直接用groupingBy方法，很方便。 Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge)); Iterator it = personGroups.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abb55dcfe9c9d899395e3f5a59a8a3c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e3a28026b60d174891cd72bfa5f765/" rel="bookmark">
			Apache Jackrabbit漏洞浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Jackrabbit是一个Java开源内容存储库，1.0.0 &lt;= 版本 &lt; 2.20.11、2.21.0 &lt;= 版本 &lt; 2.21.18存在RMI功能导致的远程代码执行漏洞。
补丁分析 对比补丁前后两个版本（https://github.com/apache/jackrabbit/compare/jackrabbit-2.20.10...jackrabbit-2.20.11），基本只是删掉了CB库。
从官方文档（https://jackrabbit.apache.org/archive/wiki/JCR/RemoteAccess_115513494.html）可以知道存在RMI-over-HTTP的默认监听路径为/rmi。
在jackrabbit-standalone-components/src/main/resources/WEB-INF/web.xml中找到/rmi对应类：
&lt;servlet-mapping&gt; &lt;servlet-name&gt;RMI&lt;/servlet-name&gt; &lt;url-pattern&gt;/rmi&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;RMI&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jackrabbit.servlet.remote.RemoteBindingServlet&lt;/servlet-class&gt; &lt;/servlet&gt; 参考官方示例用URLRemoteRepository("http://localhost:8080/rmi");把Stub接下来，接口里的方法并不多，最接近Object的自然是Credentials。
Credentials是一个继承Serializable的空接口，我们看到4个实现之一的SimpleCredentials：
其中attributes属性是一个HashMap，有Object相关的setter/getter，要素齐全对接RMI反序列化CB的PriorityQueue就行，不需要知道用户密码。
newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect) newInstance:62, NativeConstructorAccessorImpl (sun.reflect) newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect) newInstance:423, Constructor (java.lang.reflect) newInstance:442, Class (java.lang) getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax) newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax) getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invokeMethod:2128, PropertyUtilsBean (org.apache.commons.beanutils) getSimpleProperty:1279, PropertyUtilsBean (org.apache.commons.beanutils) getNestedProperty:809, PropertyUtilsBean (org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7e3a28026b60d174891cd72bfa5f765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03770eb70870bbf068982e616ff7632e/" rel="bookmark">
			停用多路径设备 mpatha
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT NAME SIZE FSTYPE TYPE MOUNTPOINT nvme1n1 1.9T mpath_member disk └─mpatha 1.9T mpath nvme2n1 1.9T mpath_member disk └─mpatha 1.9T mpath nvme3n1 1.9T mpath_member disk └─mpatha 1.9T mpath nvme4n1 1.9T mpath_member disk └─mpatha 1.9T mpath # lsblk nvme1n1 259:5 0 1.9T 0 disk └─mpatha 253:0 0 1.9T 0 mpath nvme2n1 259:6 0 1.9T 0 disk └─mpatha 253:0 0 1.9T 0 mpath nvme3n1 259:7 0 1.9T 0 disk └─mpatha 253:0 0 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03770eb70870bbf068982e616ff7632e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a007e738441058fc37b5ec79f4edb51/" rel="bookmark">
			沃通SSL国密RSA双证书应用，全球信任、国密合规
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国产密码算法（国密算法）是国家密码局认定的国产商用密码算法，国家在大力推进商用密码应用，先后出台多项法律法规强化密码技术在信息系统及关键信息基础设施中的应用和管理要求。
目前仍有很多关键领域信息系统、Web管理平台和网站，在HTTPS加密认证的应用中，仍然没有实现国密算法的升级改造，推动国密算法应用于HTTPS加密认证，必须兼顾国密算法合规性及全球通用性，只有建立一个完整的全生态支持体系，才能真正达到实用的水平。
沃通SSL国密/RSA双证书解决方案是解决国密SSL证书兼容性的成熟解决方案，通过配置国密网关或国密模块，实现服务器端国密算法兼容及国密/RSA双证书部署。部署双证书方案后，服务器端可自动识别浏览器，与国密浏览器采用国密HTTPS加密、与国际通用浏览器采用RSA HTTPS加密，自适应兼容所有浏览器，兼顾国密合规性和全球通用性，有效解决国密SSL证书浏览器兼容性问题，适用于满足等保、关保、密评等测评中，对网络与通信安全的技术要求以及商用密码合规应用要求。
目前，沃通SSL国密/RSA双证书解决方案已经在政府、金融、医疗、教育等各类领域得到广泛应用。下图所示案例为政府机构，选购沃通超快SSL通配型（国密/RSA双证书）应用于政府机构官方网站。网站部署双证书后，与国密浏览器自动采用国密HTTPS加密，与全球通用浏览器自动采用RSA HTTPS加密，低成本实现双算法自适应加密，兼容所有浏览器和移动终端。
沃通CA是依法设立的第三方电子认证服务机构及综合密码服务提供商，获得《电子认证服务许可证》、《电子认证服务使用密码许可证》、获批电子政务电子认证服务资质。沃通CA深耕数字证书及PKI密码技术领域二十余年，提供全球信任的数字证书产品以及基于国密算法的数字证书产品，以数字证书产品结合时间戳、电子签章、签名验签、服务器密码机、安全网关等软硬件产品以及PKI服务设施，打造面向国密改造、数据安全、可信身份认证、电子签名等应用需求的整体应用解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df93b027c41daf7a84dd8df26d18582e/" rel="bookmark">
			海外软文发稿：海外媒体软文发稿的重要性与优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息技术的蓬勃发展催生了海外发稿的蓬勃发展，这不仅促进了国际交流，更加深了人们对世界各领域的了解。海外发稿通过传递多样信息，将人们引向政治事件、文化现象、科技突破和社会变革等多个领域，使人们对这些领域的发展有了更为深入的洞察。
这种信息传递的重要性在于它能够打破国界限制，使来自不同国家的人们能够分享彼此的观点和经验。这种跨文化的交流不仅仅促进了社会的进步，也为各国合作提供了更多的机会。
海外媒体发稿为什么重要？
提升全球知名度： 通过在国际媒体上发表软文，企业的声音可以穿越国界，触达全球受众。这不仅提高了品牌的知名度，还能在全球范围内建立更广泛的关注。海外媒体软文发稿就像是在世界的大广场上高声宣扬，让更多人知道你的品牌。
扩展市场边界： 海外媒体软文发稿就像一把打开国际市场大门的钥匙。通过在国际媒体平台上展示企业实力和独特之处，能够吸引更多潜在客户，拓宽市场边界。它为企业提供了一种突破地域限制的有效途径，促进业务的全球化发展。
赢得国际合作机会： 在国际舞台上展示品牌实力，为企业赢得更多国际合作的机会。国际媒体软文发稿就像是一张推荐信，让合作伙伴更愿意选择与之合作。这种展示形式有助于企业树立在国际市场上的可信度和合作价值，为合作伙伴提供更多信心。
树立国际形象：
发布软文不仅仅是在传递信息，更是在建构品牌国际形象。它能够使品牌看起来更有深度、更有亲和力，赢得国际受众的喜爱。通过在国际媒体上传播正面信息，企业能够在全球市场树立积极向上的形象，吸引更多目光。
吸引全球目光：
在国际媒体上发表软文，就如同在繁华都市的霓虹灯下张贴广告，能够吸引更多关注。这有助于让品牌的声音在全球范围内传播，形成更广泛的品牌认知。软文作为一种有趣且引人注目的信息传递形式，能够在全球范围内吸引目光，使品牌脱颖而出。
提高搜索引擎排名：
在国际媒体上发表的软文，有助于提高品牌在搜索引擎上的排名，增加被发现的机会。搜索引擎通常对于在知名媒体平台上发布的内容给予更高的权重，因此，通过在国际媒体上发表软文，企业有机会在搜索结果中获得更显眼的位置，增加品牌的曝光度。
推动全球化发展：
软文作为一种国际传播的方式，有助于企业在全球范围内建立品牌影响力，推动全球化发展。通过在国际媒体上展示企业的实力、成就和价值观，有助于企业在全球范围内树立统一的品牌形象，推动全球化战略的实施。
建立良好企业形象：
在国际媒体上发表正面的软文有助于建立企业的良好形象。国际社会对企业的认知往往通过媒体来获取，通过在国际媒体上发布积极向上的软文，企业能够在全球范围内传递正面形象，建立良好的企业声誉。
海外发稿为人们提供了更多选择，让他们能够获得更广泛和多元化的信息。信息的传播在国际间扮演着关键的角色，不仅在国内具有重要意义。通过海外发稿，人们得以了解全球范围内的动态，促进了不同文化之间的相互理解。在这个数字时代，海外发稿成为了连接世界各地的桥梁，推动着人类共同体的发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ebe4c7e45b5c88fe633ba582d07cfd2/" rel="bookmark">
			边缘计算网关：在智慧储能系统中做好储能通信管家
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
目前储能系统主要由储能单元和监控与调度管理单元组成，储能单元包含储能电池组(BA)、电池管理系统(BMS)、储能变流器(PCS)等；监控与调度管理单元包括中央控制系统(MGCC)、能量管理系统(EMS)等。
2021年8月，国家发改委发布《电化学储能电子安全管理暂行办法》：“住建部要加强储能电子设计管理，组织开展储能电站设计与建筑安全相关标准制修订。建立储能电站安全监管平台，定期开展反事故工作”。电化学储能安全问题始终牵动着公众及用户的神经。
问题
锂离子电池安全性问题的本质是电池的“热失控”，即到达一定的温度极限后，电池温度出现直线上升，进而发生燃烧爆炸的现象。电池过热、过充、内短路、碰撞等是引发电池“热失控”的几个关键因素，此外电池的过充、过放、过流、短路及超高温充放电等还会严重影响电池的性能。因此大规模的锂电池运行中，电池保护及电池管理系统（BMS）的应用是必不可少。
原理
BMS通过Modbus TCP通信协议与边缘网关设备通信，进行功率控制、分合闸、获取运行数据、读取电芯数据、温度数据、告警保护、功率限制等，可对电池组提供过充、过放、过流、过温、欠温、短路及限流保护功能，还可提供充电过程中的电压均衡功能，以及通过后台软件进行参数配置和数据监控。
通过自身边缘计算能力对前端数据信息进行分析、预处理，并对接第三方物联网/云平台，实现本地化与云端远程协同管理与控制。
产品介绍
边缘计算网关R40B拥有丰富的接口，包括2路DI、2路DO、4路AI、USB口、4个网口以及RS232/RS485串口，在智慧储能物联网中发挥着强大的连接能力。R40B不仅具备串口透传功能，还支持MQTT协议和Modbus协议。R40B协助完成储能系统内的BMS、PCS、动环、消防、空调、开关保护、HMI等设备信息的统一采集、预处理。
重要性
在BMS系统中，边缘计算网关扮演着重要的角色。它们不仅负责连接设备，还承担着数据传输和管理任务，帮助提高系统的效率和可靠性。边缘计算网关是BMS系统中的关键组件，主要负责将设备连接到网络，并处理和管理数据。储能系统通过边缘计算网关物联网技术来实现对储能电池等设备的在线监控和远程管理。
边缘计算网关R40支持主流工业协议，如Modbus TCP/Modbus RTU/MQTT。同时R40还具备低时延、高带宽、高可靠性、海量连接以及本地安全和隐私保护等特点。
适用严苛的工业场景；硬件采用无风扇、低功耗、宽温宽压设计，通过符合行业标准的严格测试，能够适应对EMC有严酷要求的工业现场环境，可广泛应用于储能、智慧杆、智慧管廊、智慧水务、智慧照明、智能电网、智能楼宇、公共安全、智能交通、智能物流、智能医疗、智能工厂、智能制造等智能领域。
智慧储能通过边缘计算网关R40B实现了储能设备的智能管理和数据监控。借助物联网技术，储能电池等设备可以通过互联网进行远程管理，大大提高了储能系统的效率和可靠性。此外通过将储能数据转化为可用信息，储能系统可以进行优化与调度，以更好地满足能源需求，并提供可靠的电力支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8a62f3efa02e448cfd3718fa6bcd3c/" rel="bookmark">
			Transform环境搭建与代码调试——Attention Is All Y ou Need
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、源代码 2、环境搭建 conda create -n transform python=3.8 -y conda activate transform cd /media/lhy/Transforms/annotatedtransformer pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple # # Uncomment for colab pip install -q torchdata==0.3.0 torchtext==0.12 spacy==3.2 altair GPUtil -i https://pypi.tuna.tsinghua.edu.cn/simple python -m spacy download de_core_news_sm python -m spacy download en_core_web_sm #或者离线下载 pip install de_core_news_sm-3.2.0-py3-none-any.whl pip install en_core_web_sm-3.2.0-py3-none-any.whl 3、构建Teamsform模型（Model Architecture） 1、编码器、解码器以及预测部分 class EncoderDecoder(nn.Module): """ A standard Encoder-Decoder architecture. Base for this and many other models. """ def __init__(self, encoder, decoder, src_embed, tgt_embed, generator): super(EncoderDecoder, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8a62f3efa02e448cfd3718fa6bcd3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de82738060baf930fa5f32a53666e30c/" rel="bookmark">
			迁移到Office365教程系列——部署DirSync
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DirSync可以帮助您同步本地和Azure云端AD信息。
DirSync安装需求 软件环境要求 DirSync需要Windows Server 2003功能级别以上版本的on-premises Active Directory。您可以通过下属步骤验证您的AD版本：
打开Active Directory Domains And Trusts控制台；选择Active Directory Domains And Trusts node；在Action菜单点击Raise Forest Functional Level；对话框会显示当前功能级别，如图所示。 DirSync可以安装一下版本的操作系统上：
Windows Server 2003 with Service Pack 1 (x86 and x64)Windows Server 2003 R2 (x86 and x64)Windows Server 2008 (x86 and x64)Windows Server 2008 R2 (x64)Windows Server 2012 (x64)Windows Server 2012 R2 (x64) 在安装DirSync前，需要安装下列组件：
Microsoft .NET Framework 3.5 SP1Microsoft .NET Framework 4.0Azure Active Directory module for Windows PowerShell 运行DirSync的计算机必须是您想同步的域成员，并且保证下列端口与可读的域控可以通信：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de82738060baf930fa5f32a53666e30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145929182902ab918fa4f0cc753607e5/" rel="bookmark">
			边缘计算网关在温室大棚智能控制系统应用，开启农业新篇章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需求
●目前大棚主要通过人为手动控温度、控水、控光照、控风，希望通过物联网技术在保障产量的前提下，提高作业效率，降低大棚总和管理成本。
●释放部分劳动力，让农户有精力管理更多大棚，进而增加农户收入。
●地方管理部门，通过“大棚管理平台”可以随时查看大棚运行数据、作物长势情况(实时视频)，对经济作物产量进行评估和潜在风险预警。
项目介绍
温室大棚智能控制系统包括钡铼云平台云和钡铼边缘计算网关R40B，通过云端下发采集传感器指令、执行策略，可实现网关采集外接温湿度、二氧化碳、土壤PH、EC值、光照度、开关量计数值等各类传感器参数，根据采集传感器参数和策略可执行：自动喷淋、自动滴灌、自动施肥、自动排风、自动卷帘等各类开关任务。同时农业物联云可根据用户设定阈值进行预警提示，历史数据保存、数据图表导出、管理员权限操作等，为农业生产过程提供数据分析服务，助力农业丰产增收。
云平台端可由用户编辑执行策略如：空气温度等参数在某区间、风速超过某阈值时闭合卷帘等设备。策略可编辑多条，不同条件任意选择，下发至网关，网关根据策略和当前采集数据自动执行动作，后期无需人为干预，策略及采集指令存储在网关，无惧断网，更加安全。
网关可同时采集RS485接口Modbus协议传感器（传感器无需特定型号，符合Modbus协议即可），2路开关量输入可外接带有开关量输出的传感器，如风速、雨量等；也可采集低速脉冲信号实现计数采集。2路开关量输出接口可分别接不同设备控制开关卷帘机、轴流风机、喷淋、水肥机等任意设备；4路模拟量输入可接压力，电流，PH值等变送器，可设置上下限值，支持告警触发。执行策略时可实现多路开关输出根据任意输入计数或传感器数值动作，实现智能联动。
产品介绍
钡铼技术R40B是一种多协议、多接口的综合网关，具有综合数据（含视频）采集、数据处理、数据告警、数据联动、数据推送为一体的边缘计算网关。
其特点概括为：
※ 采用高性能工业级处理器，提供强有力的边缘计算能力；
※ 支持RS485采集；支持DI采集；支持AI采集；支持DO输出；
※ WiFi支持AP和客户端模式(2.4GHz);1路WAN/LAN口，3路LAN口，RJ45接口类型，10M/100Mbps,自适应MDI/MDIX;
※ 支持4G、Ethernet WAN、WLAN WAN链路切换和ICMP检测；
※ 支持PPP、PPPOE、TCP、UDP、DHCP、ICMP、NAT、HTTP、HTTPS、DNS、ARP、NTP、SMTP、SSH2、DDNS、SNMP等多种通信协议，支持采集通信协议二次开发；
应用场景：应用于物联网产业链中需要数据采集、数据处理、数据上云的场景，R40B可支持视频和数据的融合采集，特别适合综合类数据采集场景。
网关边缘计算功能介绍
平台下发采集指令可以选择数据自动计算功能，对于采集到的温湿度二氧化碳等传感器数据，可在原始数据基础上进行计算后上传和显示，用户可轻松实现对传感器数据的校正，减轻数据量大时平台压力。断网情况下也可自动执行采集命令和策略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b23a5edb51e0cf29c83639e894e67041/" rel="bookmark">
			【react实现递归编辑树】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import React, {useState} from 'react'; import {Input} from 'antd'; import { DeleteOutlined, PlusCircleOutlined, CaretDownOutlined, } from '@ant-design/icons'; function findAndUpdateObjectById(id, arr, changeObj, type = '') { console.log('arguments', arguments) function findAndModify(currentArray) { for (let i = 0; i &lt; currentArray.length; i++) { const currentItem = currentArray[i]; if (currentItem.id === id) { const updatedItem = {...currentItem, ...changeObj}; if (type === 'subtract') { return [ ...currentArray.slice(0, i), ...currentArray.slice(i + 1) ]; } if (changeObj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b23a5edb51e0cf29c83639e894e67041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19480f48a82c7022f3a884452c2c1c46/" rel="bookmark">
			STM32CubeMX OLED驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、一次IIC通信过程
起始条件（Start Condition）:
通信开始时，主设备发送一个起始条件信号。起始条件是SCL（时钟线）保持高电平时，SDA（数据线）从高电平切换到低电平。 发送地址和读/写位（Address and Read/Write Bit）:
主设备发送目标设备的7位地址，加上一个读/写位，用于指示是读操作还是写操作。读操作时，读/写位为1；写操作时，读/写位为0。 从设备应答（Acknowledge）:
主设备发送地址后，等待从设备的应答。从设备在下一个时钟周期内拉低SDA表示应答。 数据传输（Data Transfer）:
在设备的应答后，可以开始传输数据。数据传输是8位的数据字节，每个字节的传输都会在一个时钟周期内完成。数据传输时，SDA的每个位都在SCL的时钟脉冲上升沿之前被设置或读取。 停止条件（Stop Condition）:
数据传输完成后，主设备发送停止条件信号。停止条件是SCL保持高电平时，SDA从低电平切换到高电平。 二、CubeMX配置
用到的函数
HAL_I2C_Master_Transmit(&amp;hi2c1, DevAddress, pData, Size, Timeout); HAL_I2C_Master_Receive(&amp;hi2c1, DevAddress, pData, Size, Timeout); 在之前pwm的基础上打开IIC1，选择高速传输，400000HZ
直接生成工程，然后新建txt文件将代码复制进去更改后缀，添加以下路径
三、代码
oled.c
#include "oled.h" #include "i2c.h" #include "oledfont.h" //头文件 uint8_t CMD_Data[]={ 0xAE, 0x00, 0x10, 0x40, 0xB0, 0x81, 0xFF, 0xA1, 0xA6, 0xA8, 0x3F, 0xC8, 0xD3, 0x00, 0xD5, 0x80, 0xD8, 0x05, 0xD9, 0xF1, 0xDA, 0x12, 0xD8, 0x30, 0x8D, 0x14, 0xAF}; //初始化命令 void WriteCmd(void) { uint8_t i = 0; for(i=0; i&lt;27; i++) { HAL_I2C_Mem_Write(&amp;hi2c1 ,0x78,0x00,I2C_MEMADD_SIZE_8BIT,CMD_Data+i,1,0x100); } } //向设备写控制命令 void OLED_WR_CMD(uint8_t cmd) { HAL_I2C_Mem_Write(&amp;hi2c1 ,0x78,0x00,I2C_MEMADD_SIZE_8BIT,&amp;cmd,1,0x100); } //向设备写数据 void OLED_WR_DATA(uint8_t data) { HAL_I2C_Mem_Write(&amp;hi2c1 ,0x78,0x40,I2C_MEMADD_SIZE_8BIT,&amp;data,1,0x100); } //初始化oled屏幕 void OLED_Init(void) { HAL_Delay(200); WriteCmd(); } //清屏 void OLED_Clear(void) { uint8_t i,n;	for(i=0;i&lt;8;i++) { OLED_WR_CMD(0xb0+i); OLED_WR_CMD (0x00); OLED_WR_CMD (0x10); for(n=0;n&lt;128;n++) OLED_WR_DATA(0); } } //开启OLED显示 void OLED_Display_On(void) { OLED_WR_CMD(0X8D); //SET DCDC命令 OLED_WR_CMD(0X14); //DCDC ON OLED_WR_CMD(0XAF); //DISPLAY ON } //关闭OLED显示 void OLED_Display_Off(void) { OLED_WR_CMD(0X8D); //SET DCDC命令 OLED_WR_CMD(0X10); //DCDC OFF OLED_WR_CMD(0XAE); //DISPLAY OFF }	void OLED_Set_Pos(uint8_t x, uint8_t y) { OLED_WR_CMD(0xb0+y); OLED_WR_CMD(((x&amp;0xf0)&gt;&gt;4)|0x10); OLED_WR_CMD(x&amp;0x0f); } void OLED_On(void) { uint8_t i,n;	for(i=0;i&lt;8;i++) { OLED_WR_CMD(0xb0+i); //设置页地址（0~7） OLED_WR_CMD(0x00); //设置显示位置—列低地址 OLED_WR_CMD(0x10); //设置显示位置—列高地址 for(n=0;n&lt;128;n++) OLED_WR_DATA(1); } //更新显示 } unsigned int oled_pow(uint8_t m,uint8_t n) { unsigned int result=1;	while(n--)result*=m; return result; } //显示2个数字 //x,y :起点坐标	//len :数字的位数 //size:字体大小 //mode:模式	0,填充模式;1,叠加模式 //num:数值(0~4294967295);	void OLED_ShowNum(uint8_t x,uint8_t y,unsigned int num,uint8_t len,uint8_t size2) { uint8_t t,temp; uint8_t enshow=0;	for(t=0;t&lt;len;t++) { temp=(num/oled_pow(10,len-t-1))%10; if(enshow==0&amp;&amp;t&lt;(len-1)) { if(temp==0) { OLED_ShowChar(x+(size2/2)*t,y,' ',size2); continue; }else enshow=1; } OLED_ShowChar(x+(size2/2)*t,y,temp+'0',size2); } } //在指定位置显示一个字符,包括部分字符 //x:0~127 //y:0~63 //mode:0,反白显示;1,正常显示	//size:选择字体 16/12 void OLED_ShowChar(uint8_t x,uint8_t y,uint8_t chr,uint8_t Char_Size) { unsigned char c=0,i=0;	c=chr-' ';//得到偏移后的值	if(x&gt;128-1){x=0;y=y+2;} if(Char_Size ==16) { OLED_Set_Pos(x,y);	for(i=0;i&lt;8;i++) OLED_WR_DATA(F8X16[c*16+i]); OLED_Set_Pos(x,y+1); for(i=0;i&lt;8;i++) OLED_WR_DATA(F8X16[c*16+i+8]); } else {	OLED_Set_Pos(x,y); for(i=0;i&lt;6;i++) OLED_WR_DATA(F6x8[c][i]); } } //显示一个字符号串 void OLED_ShowString(uint8_t x,uint8_t y,uint8_t *chr,uint8_t Char_Size) { unsigned char j=0; while (chr[j]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19480f48a82c7022f3a884452c2c1c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4055f24a2a9aa8bf7f4f37960c119bf8/" rel="bookmark">
			flutter学习-day1-环境搭建和启动第一个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. SDK下载2. 配置环境变量3. 安装flutter4. 搭建Android环境5. SDK和依赖升级6. IDE配置与使用6-1. AndroidStudio配置与使用6-2. VSCode配置与使用 7. 真机调试 本文学习和引用自《Flutter实战·第二版》：作者：杜文
1. SDK下载 前置需要操作系统 window 7 或更高版本，且安装了 Git 命令行工具
首先去 flutter 官网下载其最新可用的安装包，下载地址：传送门将安装包 zip 解压到你想安装 flutter SDK 的路径（如：D:\flutter。注意，不要将 flutter 安装到需要一些高权限的路径如 C:\Program Files\） 2. 配置环境变量 如果你想在 Windows 系统自带命令行运行 flutter 命令，需要添加以下环境变量到用户 PATH
在开始菜单的搜索功能键入env，然后选择编辑系统环境变量在用户变量下检查是否有名为Path的条目在Path中添加flutter\bin的全路径，使用;作为分隔符，比如：D:\flutter\bin保存更改 3. 安装flutter 打开命令行，执行flutter doctor命令，查看是否还需要安装其他依赖，如果需要，安装它们第一次运行 flutter 命令时，它会下载它自己的依赖项并自行编译。以后再运行就会快得多 4. 搭建Android环境 flutter 依赖于 Android Studio 的全量安装。Android Studio 不仅可以管理 Android 平台依赖、SDK 版本等，而且它也是 flutter 开发推荐的 IDE 之一
下载安装 Android Studio，下载地址：传送门启动 Android Studio，然后跟着安装向导操作。勾选安装最新的 Android SDK、Android SDK 平台工具和 Android SDK 构建工具 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4055f24a2a9aa8bf7f4f37960c119bf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40038939542724cce648044ced4d2854/" rel="bookmark">
			flutter学习-day12-可滚动组件和监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介2. 可滚动组件2-1 SingleChildScrollView2-2. ListView2-2-1. separated分割线2-2-2. 无限加载列表 2-2-3. 带标题列表 3. 滚动监听和控制3-1. ScrollController滚动监听3-2. NotificationListener滚动监听 4. AnimatedList动画列表5. 滚动网格布局GridView5-1. 横轴子元素为固定数量5-2. 横轴子元素为固定最大长度5-3. 动态创建 6. PageView页面切换和缓存6-1. PageState缓存 7. TabBarView8. CustomScrollView和Slivers8-1. 常用的Slivers 本文学习和引用自《Flutter实战·第二版》：作者：杜文
1. 简介 通常可滚动组件的子组件可能会非常多、占用的总高度也会非常大；如果要一次性将子组件全部构建出将会非常昂贵！为此，Flutter中提出一个Sliver（中文为“薄片”的意思）概念，Sliver 可以包含一个或多个子组件。Sliver 的主要作用是配合：加载子组件并确定每一个子组件的布局和绘制信息，如果 Sliver 可以包含多个子组件时，通常会实现按需加载模型。只有当 Sliver 出现在视口中时才会去构建它，这种模型也称为“基于Sliver的列表按需加载模型”。可滚动组件中有很多都支持基于Sliver的按需加载模型，如ListView、GridView，但是也有不支持该模型的，如SingleChildScrollView。
Flutter 中的可滚动组件主要由三个角色组成：
Scrollable ：用于处理滑动手势，确定滑动偏移，滑动偏移变化时构建 Viewport。 方法值描述axisDirection-滚动方向physicsClampingScrollPhysics、BouncingScrollPhysics决定可滚动组件如何响应用户操作controller-控制滚动位置和监听滚动事件viewportBuilder-当用户滑动时，Scrollable 会调用此回调构建新的 Viewport，同时传递一个 ViewportOffset 类型的 offset 参数，该参数描述 Viewport 应该显示那一部分内容 Viewport：显示的视窗，即列表的可视区域。 方法值描述axisDirection-滚动方向offset-用户的滚动偏移cacheExtent-预渲染区域CacheExtentStyle-用于配合解释cacheExtent的含义，也可以为主轴长度的乘数slivers-需要显示的 Sliver 列表 Sliver：视窗里显示的元素，对子组件进行构建和布局。 如果要给可滚动组件添加滚动条，只需将Scrollbar作为可滚动组件的任意一个父级组件即可
2. 可滚动组件 本节讲一下SingleChildScrollView和ListView。
2-1 SingleChildScrollView SingleChildScrollView类似于Android中的ScrollView，它只能接收一个子组件。通常SingleChildScrollView只应在期望的内容不会超过屏幕太多时使用，因为不支持基于 Sliver 的延迟加载模型，可能性能差。
方法值描述scrollDirection-滚动方向reverse-padding-内边距primary-是否使用 widget 树中默认的PrimaryScrollControllephysics-决定可滚动组件如何响应用户操作controller-控制器child-子组件 竖向排列的字母表例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40038939542724cce648044ced4d2854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae9b6990bb6a40abefbc0d6713d789a/" rel="bookmark">
			MySQL 核心模块揭秘 |《发刊词》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 为什么要写专栏？ 我还在做业务系统研发的时候，有一段时间，系统不稳定，慢 SQL 很多。我们团队花了很长时间持续优化 SQL。
我们有一个表格，从慢查询日志里整理出了很多慢 SQL。其中一些 SQL，按照我们的理解，根本不应该出现在表格里，但是它们却经常出现。
我对这些 SQL 印象深刻，它们是：
update xxx set xxx where id = xxxcommittruncate table xxx 以我们当时对 MySQL 有限的了解，这些 SQL 执行起来都很快，不应该出现在慢查询日志里。
我们不了解这些 SQL 执行过程中都干了些什么，不理解它们是怎么执行的，想要优化也就无处下手了。
随着逐渐深入研究 MySQL 源码，我已经能解释这些 SQL 为什么会出现在慢查询日志里了。
对 SQL 执行过程不了解，这是我曾经的痛点，相信也是很多业务系统研发和 DBA 的痛点。
我投入了很多时间研究 MySQL 源码，正在逐步解决这些痛点。
现在，我把这些内容写出来，分享给需要的各位读者，希望也能帮助大家解决工作过程中遇到的痛点。
2. 专栏包含哪些内容？ 我正在研究 InnoDB 的几个模块，专栏内容都来源于这些模块：
事务锁（InnoDB 的记录锁和表锁，不包含 server 层的元数据锁）RedoUndoMVCC 3. 专栏内容怎么呈现？ 关于专栏的内容，我考虑过 3 种呈现方式。
① 源码详细分析。
以讲解源码为主，在讲解源码的过程中，顺便介绍原理。
之前写过几篇 MySQL 功能实现的源码分析文章、也结合源码写了几篇分析线上问题的文章，有读者反馈看不懂源码，对于这样的文章，他们会直接跳过源码，只看原理介绍。
② 源码关键节点 + 原理介绍：
用 SQL 执行过程中经历的关键节点的源码把原理串起来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae9b6990bb6a40abefbc0d6713d789a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1629619bf85372f477a2117766fb2e/" rel="bookmark">
			【28】Kotlin语法进阶——使用协程编写高效的并发程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：此文章仅作为本人记录日常学习使用，若有存在错误或者不严谨得地方欢迎指正。
文章目录 一、Kotlin中的协程1.1 协程的基本用法1.1.1协程与协程作用域1.1.2 使用launch函数创建子协程1.1.3 通过suspend关键声明挂起函数1.1.4 coroutineScope函数 1.2 更多的作用域构建器1.2.1 项目中创建协程的常用方法1.2.2 获取协程的返回值1.2.3 withContext函数 一、Kotlin中的协程 协程是Kotlin语言中很有代表性的一种并发设计模式，用于简化异步执行的代码。协程和线程有点类似，可以简单地将它理解成一种轻量级的线程。我们前面学习的线程是属于重量级的，这是因为线程需要依靠操作系统的调度来实现不同线程之间的切换。而协程仅在编程语言的层面就能实现不同协程之间的切换，无需操作系统的介入，从而极大提高了并发编程的运行效率。
举一个具体的例子，例如我们有foo()和bar()这两个方法：
fun foo(){ a() b() c() } fun bar(){ x() y() z() } 在没有开启线程的情况下，先调用foo()方法后调用bar()方法，理论上结果一定是a()、b()、c()执行完了以后，x()、y()、z()才能够得到执行。而如果在协程A中调用foo()方法，在协程B中调用bar()方法。虽然它们仍运行在同一个线程中，但在执行foo()方法时随时都有可能被挂起而去执行bar()方法；同理在执行bar()方法时也随时都有可能被挂起转而继续执行foo()方法，这就使得最终输出的结果变得不确定了。
可以看出，协程允许我们在单线程模式下模拟多线程编程的效果，代码执行时的挂起与恢复完全是由编程语言来控制的，和操作系统无关。
1.1 协程的基本用法 如果我们需要在项目中使用协程功能，需要在build.gradle.kts(:app)中添加以下依赖：
dependencies { · · · implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9") // 适用于Android项目 implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9") // 适用于非Android项目 } 创建一个CoroutinesTest.kt文件并在其中定义一个main()函数，然后在main()函数中使用GlobalScope.launch函数：
fun main() { GlobalScope.launch { println("codes run in coroutine scope") } } GlobalScope.launch函数可以创建一个协程的作用域，这样代码块中的代码就是在协程中运行的了。按照我们的理解，现在运行main()函数，应该会打印一句话才对。可是当你运行main()函数后却发现控制台中没有任何日志输出：
这是因为GlobalScope.launch函数每次创建的都是一个顶层协程，当应用程序运行结束时顶层协程也会跟着一起结束。刚才的日志之所以无法打印出来，正是因为代码块中的代码还没来得及运行，应用程序就结束了。为了解决这个问题，我们让程序延迟一段时间再结束就行了：
fun main() { GlobalScope.launch { println("codes run in coroutine scope") } // 让主线程休眠1s(1s后再关闭应用程序) Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c1629619bf85372f477a2117766fb2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0adace642e236e6561b173b16dd17f42/" rel="bookmark">
			使用Microsoft托管密钥的Azure信息保护云退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于各种原因，一些组织需要一个明确定义的流程来停止使用 Azure 信息保护以及对云服务的任何依赖，而不会在采用之前失去对其数据的访问权限 - 以便在出现需要时做好准备。
Azure 信息保护 (AIP) 为使用自带密钥 (BYOK) 的客户和使用 Microsoft 托管密钥 (MMK) 的客户提供了此类功能。本文将讨论如何使用 Microsoft 托管密钥为组织进行云退出。
配置 AIP 租户时会自动创建 Microsoft 托管密钥 (MMK)。该密钥基于软件，Microsoft 对整个密钥生命周期负责。
使用 MMK 的客户可以在开始使用服务后随时被动地执行该流程，无需任何特殊准备。当需要执行云退出时，他们要求 Microsoft 技术支持以受信任的发布域 (TPD) 的形式导出组织的 MMK 和所有关联的工件。这可以在需要云退出之前主动完成，但 Microsoft 提供的 TPD 在收到后需要以非常安全的形式存储，因为它包含解密所有组织受保护内容的密钥。 （请注意，TPD 导出后在 AIP 中创建的标签不会反映在存储的 TPD 中；受这些新标签保护的内容只能通过 AD RMS 超级用户权限进行访问。）
然后可以在 Active Directory Rights Management Services 的全新安装中导入此类 TPD 文件。此后，此（本地）AD RMS 群集可用于从任何在注册表中配置了特殊重定向的 Windows 客户端通过 AIP 服务来许可受 MMK 保护的内容。
此设置允许具有 AD RMS 超级用户权限的管理员访问任何内容并可选择取消保护任何内容。常规最终用户能够使用为他们明确保护的内容以及标有预定义权限以授予他们访问权限的内容。
以下端到端流程为使用 MMK 的组织提供了云退出解决方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0adace642e236e6561b173b16dd17f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f38e0cd5d7a42a7bf2823d4f0a5b98/" rel="bookmark">
			Elasticsearch中复制一个索引数据到新的索引中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 我有时候，需要调试一个已经存在的ES索引，需要从已有的索引复制数据到新的索引中去。
解决 这里我借助一个GUI工具，来解决这个问题，底层它是使用Reindex的API实现索引数据复制的。利用Reindex API搞不定这个事情，原索引mapping结构不会被复制。
# 步骤
选中已存在的redix菜单，准备开始负责索引数据，如下图：
输入将要新建的索引名，开始索引复制，如下图：
开始索引数据复制，如下图：
等待一段时间，就可以完成索引复制了。
# 检查
利用count的api检查一下文档的数量，看看是否都复制完了。如下图：
通过检查新旧两个索引的文档总数，可以知道我们复制基本成功了。
总结 有个Elasticsearch的GUI程序还是挺方便的。虽然，利用Elasticvue工具看似是把数据复制过来了，但是，新生的索引，与旧的索引的mapping结构并不一致，后面利用clone API进行索引复制。
Clone API进行索引复制 PUT old_index/_settings { "settings": { "index.blocks.write": false } } 阻塞旧索引写,准备开始克隆旧索引：
POST old_index/_clone/new_index 这样利用clone api，不仅把文档数据复制了一份，而且，还把旧索引mapping结构复制一份给新索引。
参考： elasticvueReindex APICount APIClone index API 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1936d5aec556935b9bde8e7d35875234/" rel="bookmark">
			Object.entries()方法使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script&gt; var obj = { 'aa': '11', 'bb': '22', 'cc': '33', 'dd': '44' }; // 使用Object.entries()方法遍历对象属性 for (const [key, value] of Object.entries(obj)) { console.log('Object.entries:', `${key}: ${value}`); } // 使用for...in循环遍历对象属性 for (const key in obj) { if (obj.hasOwnProperty(key)) { console.log('for...in:', `${ key }: ${ obj[key] }`); } } // 使用Object.values()方法获取对象属性值 const values = Object.values(obj); console.log('values:', values) const keys = Object.keys(obj); console.log('keys:', keys) // 使用for...of循环遍历属性值 for (const value of values) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1936d5aec556935b9bde8e7d35875234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b47891a68d77e02d9ebda8b14bed9bcc/" rel="bookmark">
			VxeTable3合并固定列-更新2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用官方的vxeTable做复杂的合并表格的时候，官方支持自定义合并规则，但是没有给固定的通用模板手搓了一个以此记录一下，可以封装成全局公共工具方法
/** *vxeTable计算固定合并列 * @param FixedColumnIndex 固定列索引 */ computedCheckBox(FixedColumnIndex = 0) { const arr = this.tableData.map(item =&gt; item.age)//所有数据-过滤出所需字段 let start = 0; let end = 0; for (let i = 1; i &lt; arr.length; i++) { if (arr[i] !== arr[i - 1]) { this.mergeCells.push({ row: start, col: FixedColumnIndex, rowspan: end - start + 1, colspan: FixedColumnIndex }); start = i; } end = i; } this.mergeCells.push({ row: start, col: FixedColumnIndex, rowspan: end - start + 1, colspan: FixedColumnIndex }); } 今天又来更新了，上次写的这个版本小编发现还是有些bug，比如空字符也会一起合并，但是这是不合理的。经过正式环境的检测，我优化一版，性能高，通用逻辑性强。 更新时间：2023年12月28日 10 :11 :52
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b47891a68d77e02d9ebda8b14bed9bcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee1c272a120858babf08417374b522c/" rel="bookmark">
			在Adobe Acrobat上如何做PDF文档签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Adobe Acrobat如何做PDF文档签名？PDF文档签名是指对PDF文档进行基于证书的数字签名，类似于传统的手写签名，可标识签名文档的人员。与手写签名不同，数字签名难以伪造，因为其包含签名者唯一的加密信息。为PDF文档进行基于证书的数字签名，不仅能保护文档不被篡改，同时验证文档签名者真实身份，数字签名易于验证、应用方便，是保护PDF文档完整性、签署不可抵赖的成熟技术手段，可用于电子合同、电子公文、数字版权、取证固证等应用场景。通过第三方证书颁发机构（如: 沃通CA）申请Adobe信任的文档签名证书后，即可通过Adobe Acrobat对PDF文档进行基于证书的数字签名。
一、获取文档签名证书 要使用基于证书的签名来签名文档，必须获得可信的数字身份认证，可通过第三方证书颁发机构（如: 沃通CA）申请获取验证个人或单位主体身份的可信文档签名证书。
沃通PDF文档签名证书用于对电子文档进行数字签名，保护文档完整性、验证签署主体身份真实性、确保签署行为不可抵赖，使电子文档具有不可篡改及标识合法身份等特性。沃通PDF文档签名证书遵循国际标准验证签发，根证书已预置到Adobe可信认证列表，受Adobe全球信任，支持Adobe Acrobat等Adobe PDF系列软件；沃通CA是依法设立的第三方电子认证服务机构，签发的PDF文档签名证书可用于签署符合我国《电子签名法》要求的可靠电子签名，具备与纸质盖章和手写签名同等法律效力。
二、基于证书的文档签名 将基于证书的数字签名添加到PDF文档中的步骤：
1、在 Acrobat 中打开 PDF，然后在全局栏中选择所有工具 &gt; 更多 &gt; 使用证书。或者，从 Acrobat 主页中，选择查看所有工具。在“保护”部分中，选择使用证书，然后选择文件（即您要验证的文件）。
2、随后会在左侧窗格中打开使用证书工具。
选择验证（可见签名）以使用可见数字签名进行验证，然后在出现的对话框中选择拖动新签名矩形。
如果您希望不使用可见签名验证文档，请选择验证（不可见签名）。
3、在“另存为已验证的文档”对话框中选择确定。
4、如果您在步骤 2 中选择了“验证（可见签名）”，请使用鼠标拖动并在想要显示签名的地方绘制一个矩形区域。
5、在“使用数字身份证进行签名”对话框中，选择要用于验证文档的数字身份证并选择继续，或者选择配置新数字身份证以创建新的身份证。
6、选择审阅以在签名前审阅文档内容，然后选择签名。在提示时，保存 PDF。您的文档现已通过验证。
三、为基于证书的签名创建外观 在“首选项”对话框的“签名”面板中选择相应选项，可以确定基于证书的签名外观。例如，可以包括您的手写签名图像、公司徽标或照片。您还可以创建不同的签名，以用于不同目的。对于某些情况，您可以提供更高级别的详细信息。签名也可以包括帮助他人验证您的 签名 的信息，例如签名原因、联系信息等。
签名格式：A.文本签名B.图形签名
1、（可选）如果要在基于证书的签名中包含手写签名的图像，请扫描您的签名，然后另存为图像文件。将图像放进文档，并将文档转换为 PDF。
2、右键单击签名域，然后选择签名文档或使用可见签名验证。
3、从“签名”对话框的“外观”菜单中，选择创建新外观。
4、在“配置签名外观”对话框中，为正在创建的签名键入名称。在签名时，请按照此名称选择签名。因此，请使用简短的描述性标题。
5、对于“配置图形”，选择一个选项：
无图形：仅显示默认图标和在“配置文本”部分中指定的其它信息。
导入的图形：显示基于证书的签名的图像。选择本选项来包括您手写签名的图像。要导入图像文件，依次选择“文件”、“浏览”，然后选择图像文件。
名称：仅显示默认签名图标和您的数字身份证文件中显示的名称。
6、对于“配置文本”，选择您想要在签名中显示的选项。“辨别名”用来显示您的数字身份证中定义的用户属性，包括您的姓名、单位和国家/地区。
7、对于“文本属性”，指定使用的书写方向和数字类型，然后单击确定。
8、（可选）如果对话框包含“附加签名信息”部分，指定签署文档的原因、位置和您的联系信息。仅当您在“创建和外观”首选项对话框（“首选项”&gt;“签名”&gt;“创建及外观”&gt;“更多”）中将这些选项设为首选项时，这些选项才可用。
四、向基于证书的签名中添加时间戳 Adobe Acrobat可以添加文档的签名日期和时间作为基于证书的签名的一部分。时间戳很容易确认它们与可信任的时间戳颁发机构证书关联的时间。时间戳有助于确定签名文档的时间，并减少出现无效签名的可能性。您可以从第三方时间戳颁发机构或颁发您的数字身份证的证书颁发机构（如：沃通CA）获得时间戳。
时间戳显示在签名属性对话框的签名域中。如果配置了时间戳服务器，时间戳将显示在签名属性对话框的“日期/时间”选项卡中。如果没有配置时间戳服务器，则签名域显示签名时计算机的本地时间。
如果签署文档时未嵌入时间戳，以后可在签名中加入时间戳。使用时间戳服务器提供的时间为文档签名后，即会应用时间戳。
五、签名类型及适用标准 通过使用证书工具，您可以应用两种类型的基于证书的签名。您可以使用数字签名选项验证文档，证实其内容可靠或批准文档。
数字签名当您使用证书进行数字签名时，签名将视为批准签名。
验证（可见签名或不可见签名）验证选项与数字签名相比，可提供更高级别的文档控制。对于需要证书的文档，您必须在其他人签名文档之前对其进行验证。如果文档已签名，“验证”选项将处于停用状态。在验证文档时，您可以控制其他人可以执行的更改类型。您可以通过显示或不显示签名来进行验证。
使用验证或数字签名选项生成的签名符合欧洲电信标准化协会 (ETSI) 指定的数据保护标准。此外，两种签名类型还都符合 PDF Advanced Electronic Signature (PAdES) 标准。Acrobat 和 Acrobat Reader 提供用于将默认签名格式更改为 CAdES 格式的选项；该选项符合 PAdES 标准的第 3 部分。对长期验证签名的时间戳功能和本机支持符合 PAdES 标准的第 4 部分。在进行相应设置之后，默认签名格式符合 PAdES 标准的第 2 部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee1c272a120858babf08417374b522c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48522e316735d62dc60b7b0cec026839/" rel="bookmark">
			抬头举手阅读YOLOV8NANO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先用YOLOV8NANO得到PT模型，转换成ONNX,OPENCV调用，PYTHON,C++,ANDROID都可以举手写字阅读YOLOV8NANO
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d26ad71590ff1150cf16c60b4086543/" rel="bookmark">
			为什么选择数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析是当今科技进步和信息时代的核心驱动力之一。在如此数据爆炸的时代，数据分析的重要性愈发凸显出来。它不仅是企业决策的基础，也是市场营销的利器。所以，为什么选择数据分析呢？下面数聚就来具体分析原因所在，方便企业做出决策。
首先，数据分析能够揭示隐藏在海量数据中的有价值信息。在过去，我们往往依靠直觉和经验来做决策。但是，这种方式往往带来风险和不确定性。而数据分析可以通过全面收集、整理和分析数据，帮助我们发现隐藏的规律和趋势，从而做出更加明智的决策。
其次，数据分析可以帮助我们更好地了解目标受众。在竞争激烈的市场中，了解消费者需求和偏好是成功的关键。通过数据分析，我们可以深入挖掘用户行为模式、消费趋势、产品偏好等信息，从而精准定位目标受众，并提供更加符合其需求的产品和服务。
此外，数据分析能够帮助我们实现精确营销。传统的广告投放往往是盲目的，无法有效地将广告传达给潜在客户。而数据分析可以通过对用户数据的分析，精确识别目标受众，从而将广告信息传达给潜在客户的同时，最大化提高广告的转化率。
另外，数据分析可以帮助我们发现业务中的瓶颈和问题。通过对数据的分析，我们可以找出业务运行中的问题和瓶颈，从而及时优化和改进业务流程，提高运营效率和业务质量。数据分析还可以帮助企业发现新的机会和趋势，为企业的持续发展提供重要的决策依据。
在数聚看来，选择数据分析是明智的选择。它能够揭示数据中的有价值信息，帮助我们更好地了解目标受众，实现精确营销，发现业务中的问题和瓶颈，以及抓住新的机会和趋势。在这个充满挑战和竞争的时代，只有通过数据分析才能在激烈的商业竞争中脱颖而出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a33003e7b7b2e10843144429ee8b250/" rel="bookmark">
			如何在无公网IP环境使用Windows远程桌面Ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 同个局域网内远程桌面Ubuntu二、使用Windows远程桌面连接三、公网环境系统远程桌面Ubuntu1. 注册cpolar账号并安装2. 创建隧道，映射3389端口3. Windows远程桌面Ubuntu 四、 配置固定公网地址远程Ubuntu1. 保留固定TCP地址2. 配置固定的TCP地址3. 使用固定TCP地址远程Ubuntu 本篇文章主要介绍在Ubuntu上安装XRDP远程桌面，实现同个局域网内远程桌面Ubuntu，同时解决远程桌面登录蓝屏的问题。并做内网穿透，使用cpolar内网穿透映射3389端口，生成公网TCP端口地址，实现在公网环境下，远程桌面Ubuntu系统。
【cpolar内网穿透支持http/https/tcp协议，支持永久免费使用，不限制流量，无需公网IP，也不用进入路由器设置，操作简单。】
一、 同个局域网内远程桌面Ubuntu 本篇教程适用Ubuntu版本：
Ubuntu 20.04.xUbuntu 22.04.xUbuntu 23.04.xUbuntu 23.10.x 下载xrdp脚本
wget https://www.c-nergy.be/downloads/xRDP/xrdp-installer-1.4.8.zip 解压缩文件
unzip xrdp-installer-1.4.8.zip 将脚本下载到本机系统，提取内容并标记为可执行文件
chmod +x xrdp-installer-1.4.8.sh 运行服务
./xrdp-installer-1.4.8.sh 查看IP地址
ifconfig 如图：本例中，获取Ubuntu主机IP为192.168.149.135
注意：重启一下Ubuntu主机，不要登陆账户
二、使用Windows远程桌面连接 在局域网，找到另一台Windows主机，打开远程桌面连接，输入Ubuntu主机的IP地址，点击连接。
输入Ubuntu主机的IP地址，以及用户名密码。
点击 OK 按钮进行远程连接。
现在，已经远程桌面连接成功了。
三、公网环境系统远程桌面Ubuntu 在没有公网IP的环境下，要实现远程桌面连接，可以通过cpolar内网穿透来实现，映射3389端口。
1. 注册cpolar账号并安装 cpolar官网地址: https://www.cpolar.com
使用一键脚本安装命令 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar cpolar安装成功后，在外部浏览器上访问Linux 的9200端口 即:【http://局域网ip:9200】，使用cpolar账号登录(如没有账号,可以点击下面免费注册),登录后即可看到cpolar web 配置界面,结下来在web 管理界面配置即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a33003e7b7b2e10843144429ee8b250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7404e3fb6422fa9de314383c4da6413/" rel="bookmark">
			《HelloGitHub》第 93 期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		兴趣是最好的老师，HelloGitHub 让你对编程感兴趣！
简介 HelloGitHub 分享 GitHub 上有趣、入门级的开源项目。
这里有实战项目、入门教程、黑科技、开源书籍、大厂开源项目等，涵盖多种编程语言 Python、Java、Go、C/C++、Swift...让你在短时间内感受到开源的魅力，对编程产生兴趣！
以下为本期内容｜每个月 28 号更新
C 项目 1、rsync：Linux 远程同步文件的工具。该项目提供了一种快速、增量的文件传输方式，即仅传输有变动的部分，可用于远程同步和备份文件。
地址：https://github.com/WayneD/rsync
C# 项目 2、Kavita：一款功能丰富的在线阅读平台。该项目可以在本地架设一个阅读漫画和电子书的 Web 平台，在手机、平板、台式机等设备上都有着出色的访问体验。
地址：https://github.com/Kareadita/Kavita
3、LittleBigMouse：Windows 多显示器鼠标平滑移动的工具。在 Windows 多显示器、分辨率不一致的情况下，鼠标在屏幕间移动会出现跳跃，比如外接了一台 4k 屏幕的和一台 2k 的屏幕，从 4k 屏幕中间挪到 2k 屏幕，鼠标就出现在底部了。该项目可以完美解决这个鼠标跳跃的问题，实现 Windows 多显示器鼠标平滑移动。来自 @Wu Zheng 的分享
地址：https://github.com/mgth/LittleBigMouse
C++ 项目 4、Modern-CPP-Programming：现代 C++ 编程课程。该教程面向有一定编程基础的人，内容涵盖 C++ 编程的基础知识、高级 C++ 语义和概念。
地址：https://github.com/federico-busato/Modern-CPP-Programming
5、WechatExporter：微信聊天记录迁移和备份工具。这是一个用于导出微信聊天记录的工具，支持以 HTML、PDF 或文本格式保存聊天内容，适用于 Windows 和 macOS 系统。
地址：https://github.com/BlueMatthew/WechatExporter
Go 项目 6、mailpit：带 API 的电子邮件测试工具。这是一个小型、快速、多平台的电子邮件测试工具，它可以充当一个 SMTP 服务器，自带 Web 界面，支持模拟电子邮件接收、切换不同设备查看邮件等功能，还提供了可用于自动集成测试的接口。
地址：https://github.com/axllent/mailpit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7404e3fb6422fa9de314383c4da6413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37376c17e4df0a2636c94254b405ecd8/" rel="bookmark">
			postman使用-04响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 响应响应界面说明Pretty：格式化显示，以便查看Raw：不进行任何处理，显示响应数据的原始格式Preview：预览响应体，会自动换行，不会格式化（有时候是数据，有时候是页面）Visualize：可视化响应体“Pretty”,“Raw”，“Preview”对比 响应数据保存到本地文件清空响应数据响应另存为模板 总结 响应 响应界面说明 Pretty：格式化显示，以便查看
Raw：不进行任何处理，显示响应数据的原始格式
Preview：预览响应体，会自动换行，不会格式化（有时候是数据，有时候是页面）
Visualize：可视化响应体
Pretty：格式化显示，以便查看 pretty格式化成什么，是依据响应头中的content-type,一般postman工具会自动判断
Raw：不进行任何处理，显示响应数据的原始格式 Preview：预览响应体，会自动换行，不会格式化（有时候是数据，有时候是页面） 预览模式的显示内容取决于接口返回的数据类型。如果返回的数据是JSON格式，且数据中包含图片的base64编码，那么预览模式将展示这张图片。同样的，如果返回的数据是HTML格式，预览模式将会渲染并展示这个HTML页面。
Visualize：可视化响应体 “Pretty”,“Raw”，“Preview”对比 "Pretty"模式是将返回的Body数据格式化后进行展示，格式化后的数据看起来更加直观，而且响应数据内容中的链接还会被高亮显示并可以点击去发送请求。默认情况下，Postman会以这种方式展示响应数据。
"Raw"模式是以纯文本的方式展示响应，它可以是多种格式，例如JSON、XML、HTML或普通文本。
"Preview"模式则提供响应结果的预览效果。
因此，这三种模式各有其特点和用途："Pretty"模式则侧重于数据的可视化展示，使结构更清晰；"Raw"模式更注重数据的原始形式；而"Preview"模式则提供了响应内容的预览。
响应数据保存到本地文件 清空响应数据 响应另存为模板 Postman的"Save as file"功能允许用户将API接口的响应数据保存到本地。这种功能对于需要长期或重复使用的数据非常有用，因为它可以避免反复进行相同的请求操作。
当我们请求一个接口，请求的参数不同或者是请求Headers不同，响应数据也不同，为了不每次都手动修改请求参数，，我们可以将该请求保存为示例。
生成并保存后的请求模板，会在原请求下二级目录。修改原请求的参数，不会影响保存的模板的参数
总结 响应界面说明
Pretty：格式化显示，以便查看
Raw：不进行任何处理，显示响应数据的原始格式
Preview：预览响应体，会自动换行，不会格式化（有时候是数据，有时候是页面）
Visualize：可视化响应体
“Pretty”,“Raw”，“Preview”对比
响应数据保存到本地文件
清空响应数据
响应另存为模板
1.Pretty：格式化显示，以便查看
2.Raw：不进行任何处理，显示响应数据的原始格式
3.Preview：预览响应体，会自动换行，不会格式化（有时候是数据，有时候是页面）
预览模式的显示内容取决于接口返回的数据类型。如果返回的数据是JSON格式，且数据中包含图片的base64编码，那么预览模式将展示这张图片。同样的，如果返回的数据是HTML格式，预览模式将会渲染并展示这个HTML页面。
4.Visualize：可视化响应体
5.“Pretty”,“Raw”，“Preview”对比
"Pretty"模式是将返回的Body数据格式化后进行展示，格式化后的数据看起来更加直观，而且响应数据内容中的链接还会被高亮显示并可以点击去发送请求。默认情况下，Postman会以这种方式展示响应数据。
"Raw"模式是以纯文本的方式展示响应，它可以是多种格式，例如JSON、XML、HTML或普通文本。
"Preview"模式则提供响应结果的预览效果。
因此，这三种模式各有其特点和用途："Pretty"模式则侧重于数据的可视化展示，使结构更清晰；"Raw"模式更注重数据的原始形式；而"Preview"模式则提供了响应内容的预览。
响应另存为模板
当我们请求一个接口，请求的参数不同或者是请求Headers不同，响应数据也不同，为了不每次都手动修改请求参数，，我们可以将该请求保存为示例。
生成并保存后的请求模板，会在原请求下二级目录。修改原请求的参数，不会影响保存的模板的参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d069550cfc06280accefb7be9e302a2/" rel="bookmark">
			插入排序可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 结果1.1 动画图 2. 代码2.1 排序代码2.2 绘图代码 1. 结果 1.1 动画图 2. 代码 2.1 排序代码 public void insertSort(List&lt;Integer&gt; list) { for (int i = 1; 1 &lt; list.size(); i++) { int ele = list.get(i); int k = i - 1; while (k &gt;= 0 &amp;&amp; list.get(k) &gt; ele) { list.set(k + 1, list.get(k)); k--; } list.set(k + 1, ele); } } 2.2 绘图代码 参照 冒泡排序可视化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88dc2f26e488c80e316dee6eb72c451e/" rel="bookmark">
			54. 螺旋矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://leetcode.cn/problems/spiral-matrix/description/
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
class Solution { private List&lt;int[]&gt; vector = Arrays.asList( new int[]{0,1}, new int[]{1, 0}, new int[]{0,-1}, new int[]{-1, 0} ); private boolean over(int x, int y, int m, int n) { return x &lt; 0 || y &lt; 0 || x &gt;= m || y&gt;= n; } public List&lt;Integer&gt; spiralOrder(int[][] matrix) { int d = 0; int m = matrix.length; int n = matrix[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88dc2f26e488c80e316dee6eb72c451e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a730b21201f934830b8e459735e4ae5/" rel="bookmark">
			PPT右键保存图像为指定分辨率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们会用PPT来快速绘制和生成图像，以方便在程序中使用。在这种应用场景中，图像的分辨率需要着重考虑。本篇文章中，我们将介绍如何实现PPT右键保存图像为指定分辨率，为上述场景给出助攻。
该操作具体如下：
选中要保存为图片的对象→复制空白处右键→粘贴选项→图片双击该图片，可以看到右上方的功能区中有图片的宽和高修改图像的宽和高到指定值（后面解释该值怎么算）右键刚刚粘贴的图像→另存为图片 这时保存的图片分辨率为：图像在PPT中的大小×DPI÷2.54
其中图像大小在PPT中是以厘米表示的，而PPT中右键粘贴为图像的DPI为150（这个值研究了也不知道怎么修改），因为DPI的含义为每英寸包含像素点个数，一英寸约为2.54厘米，因此最后需要除以2.54将单位转为厘米。
有了上面的公式，就可以算出上面第4点提到的指定值的计算公式为：目标分辨率×2.54÷DPI
到此，我们就把所有细节讲完啦。该操作要是熟练的话是蛮方便的，不过如果遇到需要出比较专业的图像的情况，还是选择Adobe Illustrator 这种专业的工具靠谱一些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0dbf9fe153bc53b3dc1f25159876a2e/" rel="bookmark">
			纹理格式及资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近项目接触到这块比较多，做了一个整理（逐步更新中…)
Format 首先以R8G8B8A8为例，代表使用了R、G、B、Alpha四个通道，每个通道使用了8个bit,总共使用了32个bit，所以也称BPP/BitCount/BPE(叫法来自DXSPEC)为32
还有一种R8G8B8X8，其中X8代表忽略的透明度信息。
有时候8位最多代表256种颜色，我们需要更多，因此还会有R32G32B32A32这种format，有时候不需要Alpha信息，会有R32G32B32这种format
在DirectX中，每一种format后面还有一个格式修饰符，下面详细解释这些
_UNORM:无符号的归一化整数，即没有负数，在资源中解释为无符号整数，在着色器中解释为 [0,1] 范围内的无符号归一化浮点值，比如，2位(指的每一个通道bit)UNORM表示0.0f,1/3, 2/3和1.0f。归一化即指将0，1，2，3表示为[0,1.0f]这个过程
_FLOAT:浮点数，DX是有符号浮点数，在SPEC中规定:32位浮点数使用 IEEE 754 单精度 的标准：1位符号、8位指数偏移、23位数值部分；16位的浮点数使用半精度（s10e5）的格式：1位符号、5位指数偏移、10位数值部分。还有特殊的，比如DXGI_FORMAT_R11G11B10_FLOAT，
_SNORM：带符号的归一化整数，在着色器中解释为[-1,1]中的有符号归一化浮点数，(5 位值 01111 映射到 1.0f，10000 映射到 -1.0f）
_UINT：无符号整数，3位的UINT即表示01234567
_BC：压缩纹理格式，详情见下表，注意在所有尺寸上创建的块压缩纹理必须是大小 4 的倍数，且不能用作管道的输出。（来自微软文档）
_ASTC:ARM开发的纹理压缩格式，DXGI Format好像没有这种？
_TYPELESS：无类型数据，但是有已经定义的bit数，也就是说，可以创建一个无类型资源，但当资源绑定到着色器时，就必须应用或着色器解析这个类型，即CreateSRV/RT/UAV时，比如R8G8B8A8_TYPELESS，在Create View时必须用R8G8B8A8_UNORM/SINT等其中一种去解释这个。(也有例外，raw buffer(注意这里的resource dimeason必须是BufferEX,BufferEX才可以指定raw的flag)可以指定成R32_Typeless,但是struct buffer只能指定 unknown format
_SRGB:标准的RGB数据，
资源 buffer Structured Buffer Structured Buffer即结构化缓冲区，也只有Buffer才能被创建成结构化，Structured意思是将resource标识成单个连续的内存块，每个内存块的大小即Stride，没有mipmap,也没有array slice,可以理解成的结构数组，因为是在内存上连续的固定结构，所以有很多优势。
…
RawBuffer 访问Buffer最方便的方法是将其视为一个巨大的bit组成的包，RawBuffer就类似这样，它允许以32位对齐寻址来访问Buffer,
Texture 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/25/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>