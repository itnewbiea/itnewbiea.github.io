<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcc30ba37dd9734f018a0804f1338d2/" rel="bookmark">
			C&#43;&#43;引用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️ 引用(&amp;) 文章目录 ❤️ 引用(&amp;)💟 1、引用🖊 1.1 概念🖊 1.2 书写形式✏️ 1.3 注意事项 🖤 2、引用特性💛 3、常引用💘 4、引用使用的场景🐒 4.1 引用做参数🐷 4.2 引用做返回值 💚 5、引用和指针的区别 💟 1、引用 🖊 1.1 概念 引用变量是一个别名，也就是说，它是某个已存在变量的名字。一旦把引用初始化为某个变量，就可以使用该引用名称或者变量名称来指向变量。
🖊 1.2 书写形式 ​ 类型&amp; 引用变量名(对象名)=引用实体
int main() { int a = 10; int&amp; ra = a; // ra为a的引用 return 0; } ✏️ 1.3 注意事项 1、引用不是新定义一个变量，而是给已存在变量取一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。
在vs编译器调试下我们可以看到，a和ra的值相同，并且他们的地址也相同。如图：
2、引用类型必须和引用实体类型是同种类型的。
int类型的数据必须使用相应类型的引用，否则编译器会报错！！！
🖤 2、引用特性 1、引用在定义时必须初始化
2、一个变量可以有多个引用
3、引用一旦引用一个实体，再不能引用其他实体
执行ra = b这条语句后，并不是改变了ra这个引用，ra仍为a的引用，从图中可以看到ra的地址仍为a的地址。
💛 3、常引用 int main() { const int a = 10; int&amp; ra = a; //权限放大，不行 const int&amp; rra = a; //权限平移可以 int b = 20; const int&amp; rb = b; //权限缩小，可以 const int&amp; rc = 10; //权限平移，必须加上const return 0; } 小结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dcc30ba37dd9734f018a0804f1338d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9ca465113694ecb65452ec3aa4c89f7/" rel="bookmark">
			C语言的简单运用——扫雷(基础篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信大家小时候在windows游戏菜单里都看到过扫雷，大部分人应该都玩过扫雷。我们在学习了C语言后，也可以自己编写一个C语言的扫雷游戏，让我们来看看如何实现吧！
游戏规则介绍 我们以经典的9*9雷盘，10个雷的布局为例。9*9雷盘即盘面上有9*9=81个格子，10个雷即计算机随机在十个格子上生成雷，如果玩家成功找到并打开非雷的71个格子则获得胜利，如果玩家打开了含雷的格子，则失败。这是游戏的基本规则，接下来是打开非雷格子后出现的数字的含义，打开后数字为n，则代表该格周围的8个格子中存在n个雷，例如
我们看到，图片正中间的格子数字为2，那么它周围的八个格子中一定有两个格子是含雷格(即图中用旗子标出的两格)。那么如果一个格子周围没有含雷格，则该格显示为空格。
准备 由于代码较长，我们采用分装不同函数实现不同功能的方式完成，这里我分为两个源文件和一个头文件进行编写
把所有的函数都在头文件中声明，然后再源文件中包含头文件即可调用函数。我们先来看看库函数头文件"stdio.h"用于调用printf函数和scanf函数，"stdlib.h"用于调用srand函数，rand函数(用于生成随机数)，system函数(用于优化界面，使用方法可以在我的三子棋&lt;http://t.csdn.cn/8I9Op&gt;界面优化方法中找到)，"time.h"用于调用time函数(用于生成随机数)。接下来看宏常量，由于我以9*9雷盘10雷布局为例，故“COL”和“ROW”为9，“MINE”为雷数10，而“COLS”和“ROWS”为雷盘宽度加2，即11，具体作用在下文中详细解释。
一、游戏菜单 1.菜单界面 菜单界面的设计可以仿照三子棋菜单，用多行printf函数打印出一个菜单，如图 2.开始或退出游戏 这里我们分装一个函数，使玩家选择开始或退出游戏，为了在一局游戏结束后玩家能在不重启程序的情况下再次开始游戏，我们使用一个循环语句使玩家能重复游玩。
对应到游戏菜单，我们可以将玩家输入的值分成三种，若为“1”，则开始游戏，进入game函数(即游戏本体)；若为“2”，则跳出循环，退出游戏；若不为“1”也不为“2”，则输入错误，让玩家重新输入。
二、游戏内容 1.雷盘设计 设计思路 首先我们来分析雷池(以9*9雷盘10雷为例)，我们可以把雷池分为两个部分，第一部分是计算机随机生成的一个确定的雷池，这部分是玩家看不到的，相当于真实埋在地里的雷；第二部分则是玩家所看到的雷盘，会有数字提示其周围的含雷格数。那么在这里，我们可以定义两个二维数组，分别对应雷池的两个部分，如图中的数组mine和数组show
这里需要注意的是，9*9的雷盘，我创建的数组大小为11*11(比雷盘多2行2列)，即图中“COLS”和“ROWS”的值为11，这涉及到后期的扫雷判断，这里先留下一个小小的悬念。
初始化雷池 有了设计思路后，我们就可以开始制作了，首先我们需要做的就是初始化雷池。因为我们要初始化的是两个大小相同的数组，所以我们只需要分装一个init函数，接收所需要初始化的数组和初始化内容，即可分别初始化这两个数组
由于mine数组代表的是雷的真实位置，那么这个数组里就会存在两种元素，一种是代表非雷的元素，另一种则是代表含雷的元素，这里我用字符'0'代表非雷，字符'1'代表含雷(后期判断方便)，那么我只要将mine数组和字符'0'传入init函数即可完成初始化。同理，show数组为中的元素为玩家所看到的字符，我用'*'初始化show数组，那么游戏开始时玩家看到的即为9*9个'*'。
打印雷池 初始化后我们要做的就是将游戏画面展示给玩家，由于mine数组为雷的具体位置，当然不能展示给玩家，所以我们只需要打印show数组即可，打印思路也很简单，使用嵌套循环打印数组中的每个元素即可(注意:由于我创建的数组大小为11*11，而雷盘大小为9*9，故应打印的元素下标范围应该在1~9之间)
void print_board(char arr[COLS][ROWS]) { int i = 0; int j = 0; int col = COL; int row = ROW; int cols = COLS; int rows = ROWS; for (j = 1; j &lt; (rows + 1); j++) { if (j != rows) { printf("****"); } else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9ca465113694ecb65452ec3aa4c89f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9e6d5f5c312b59c922f8c8048eb856/" rel="bookmark">
			OpenPCDet环境配置&amp;&amp;HVPR代码复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 **
显卡 3090
nvidia-smi 11.4
Ubuntu 18.04
CUDA 11.3
python 3.8
pytorch 1.7.0
cmake 3.25.0
gcc 7.5.0
spconv 2.1.25
1 HVPR环境配置 1.1 克隆仓库 进入存放HVPR的上级目录，使用如下命令
$ git clone https://github.com/cvlab-yonsei/HVPR.git $ cd HVPR 1.2 创建虚拟环境 $ conda create -n hvpr python=3.8 -y 1.3 安装pytorch 根据参考博客中的PyTorch、torchvision和python对应关系以及PyTorch和CUDA关系组合选择合适的PyTorch版本
#更新pip $ python -m pip install --upgrade pip #使用pip 安装pytorch1.8.0,建议用pip，conda容易失败 # CUDA 11.0 $ conda install pytorch==1.7.0 torchvision==0.8.0 torchaudio==0.7.0 cudatoolkit=11.0 -c pytorch 测试pytorch是否安装成功
$ python &gt;&gt;&gt; import torch &gt;&gt;&gt; torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a9e6d5f5c312b59c922f8c8048eb856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd96ec677dee2c9fe1f6312f656e0547/" rel="bookmark">
			环形进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环形进度条 本文主要使用Qt Designer设计并使用其转换Python代码功能将其转换成了代码。
通过Python调用，将设计的代码进行显示。
splash_screen.py Ui文件,可在Qt Designer加载
Ui文件：https://download.csdn.net/download/hyd_csdn/87038253
# -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'splash_screen.ui' # # Created by: PyQt5 UI code generator 5.15.4 # # WARNING: Any manual changes made to this file will be lost when pyuic5 is # run again. Do not edit this file unless you know what you are doing. from PySide6 import QtCore, QtGui, QtWidgets class Ui_SplashScreen(object): def setupUi(self, SplashScreen): SplashScreen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd96ec677dee2c9fe1f6312f656e0547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a9d29a07fd2b832bc5d9bf7c9d4da5/" rel="bookmark">
			python 图片与二进制之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：PIL格式图片转成二进制 先读取为PIL格式，再转为二进制
import io import base64 from PIL import Image def image2byte(image): ''' 图片转byte image: 必须是PIL格式 image_bytes: 二进制 ''' # 创建一个字节流管道 img_bytes = io.BytesIO() #把PNG格式转换成的四通道转成RGB的三通道，然后再保存成jpg格式 image = image.convert("RGB") # 将图片数据存入字节流管道， format可以按照具体文件的格式填写 image.save(img_bytes, format="JPEG") # 从字节流管道中获取二进制 image_bytes = img_bytes.getvalue() return image_bytes def byte2image(byte_data): ''' byte转为图片 byte_data: 二进制 ''' image = Image.open(io.BytesIO(byte_data)) return image 调用代码：
image_path = "img/3.jpg" image = Image.open(image_path) byte_data = image2byte(image) #把图片转换成二进制 image2 = byte2image(byte_data)。#把二进制转成图片 二：数组转二进制 先用opencv读取为数组格式，再转为二进制
def numpy2byte(image): ''' 数组转二进制 image : numpy矩阵/cv格式图片 byte_data：二进制数据 ''' #对数组的图片格式进行编码 success,encoded_image = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a9d29a07fd2b832bc5d9bf7c9d4da5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f7c2b8a61b142be4d63efdc5bcb9a80/" rel="bookmark">
			python Clickhouse 分布式表介绍和创建、插入和查询数据，以及解决遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、分布式表和本地表
原理解析：
二、Clickhouse创建分布式表结构
三、python代码实现（亲测有效）
四、解决遇到的问题
解决 DB::Exception: Missing columns: 'wefgrgrfew' while processing query: 'wefgrgrfew', required columns: 'wefgrgrfew' 'wefgrgrfew': While executing ValuesBlockInputFormat. Stack trace:
一、分布式表和本地表 clickhouse中的表可以分为分布式表和本地表。
分布表包括逻辑表和物理表,，逻辑表就是表机构用于查询，物理表是实际存储数据的。
（1）分布式表：逻辑存在的表,自身不存储数据，可以理解为数据库中的视图, 一般建议使用分布式表做查询操作，分布式表引擎会将我们的查询请求路由本地表进行查询, 然后进行汇总最终返回给用户。
（2）本地表:真正存储数据的表。
原理解析： 分布式（Distributed）表引擎是分布式表的代名词，它⾃身不存储任何数据，⽽是作为数据分⽚的透明代理，能够⾃动的路由数据⾄集群中的各个节点，即分布式表需要和其他数据表⼀起协同⼯作。分布式表会将接收到的读写任务，分发到各个本地表，而实际上数据的存储也是保存在各个节点的本地表中。原理如下图：
二、Clickhouse创建分布式表结构 分布式表创建规则：
使用on cluster语句在集群的某台机器上执行以下代码，即可在每台机器上创建本地表和分布式表，其中⼀张本地表对应着⼀个数据分⽚，分布式表通常以本地表加“_all”命名。它与本地表形成⼀对多的映射关系，之后可以通过分布式表代理操作多张本地表。
这里有个要注意的点，就是分布式表的表结构尽量和本地表的结构一致。如果不一致，在建表时不会报错，但在查询或者插入时可能会抛出异常。
在集群中使用，我们要加上on cluster &lt;cluster_name&gt;的ddl，这样我们的建表语句在某一台clickhouse实例上执行一次即可分发到集群中所有实例上执行。
（1）先在每一个分片上创建本地表：
-- auto-generated definition 物理表 CREATE TABLE IF NOT EXISTS test.test_log ON CLUSTER '{cluster}' ( ts_date Date, ts_date_time DateTime, user_id Int64, event_type String, site_id Int64, groupon_id Int64, category_id Int64, merchandise_id Int64, search_text String -- A lot more columns.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f7c2b8a61b142be4d63efdc5bcb9a80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84ee88ddb050e394242f4e415948fea/" rel="bookmark">
			【毕业设计】深度学习行人车辆流量计数系统 - 目标检测 python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1. 目标检测概况1.1 什么是目标检测？1.2 发展阶段 2. 行人检测2.1 行人检测简介2.2 行人检测技术难点2.3 行人检测实现效果2.4 关键代码-训练过程 3 最后 0 前言 🔥 Hi，大家好，这里是丹成学长的毕设系列文章！
🔥 对毕设有任何疑问都可以问学长哦!
这两年开始，各个学校对毕设的要求越来越高，难度也越来越大… 毕业设计耗费时间，耗费精力，甚至有些题目即使是专业的老师或者硕士生也需要很长时间，所以一旦发现问题，一定要提前准备，避免到后面措手不及，草草了事。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的新项目是
🚩 目标检测-行人车辆检测流量计数
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：4分工作量：4分创新点：3分 🧿 选题指导, 项目分享：
https://gitee.com/yaa-dc/BJH/blob/master/gg/cc/README.md
1. 目标检测概况 1.1 什么是目标检测？ 目标检测，粗略来说就是：输入图片/视频，经过处理，得到：目标的位置信息（比如左上角和右下角的坐标）、目标的预测类别、目标的预测置信度（confidence）。
1.2 发展阶段 手工特征提取算法，如VJ、HOG、DPM
R-CNN算法（2014），最早的基于深度学习的目标检测器之一，其结构是两级网络：
1）首先需要诸如选择性搜索之类的算法来提出可能包含对象的候选边界框；2）然后将这些区域传递到CNN算法进行分类； R-CNN算法存在的问题是其仿真很慢，并且不是完整的端到端的目标检测器。
Fast R-CNN算法（2014末），对原始R-CNN进行了相当大的改进：提高准确度，并减少执行正向传递所花费的时间。
是，该模型仍然依赖于外部区域搜索算法。
faster R-CNN算法（2015），真正的端到端深度学习目标检测器。删除了选择性搜索的要求，而是依赖于
（1）完全卷积的区域提议网络（RPN, Region Purpose Network），可以预测对象边界框和“对象”分数（量化它是一个区域的可能性的分数）。（2）然后将RPN的输出传递到R-CNN组件以进行最终分类和标记。 R-CNN系列算法，都采取了two-stage策略。特点是：虽然检测结果一般都非常准确，但仿真速度非常慢，即使是在GPU上也仅获得5 FPS。
one-stage方法有：yolo（2015）、SSD（2015末），以及在这两个算法基础上改进的各论文提出的算法。这些算法的基本思路是：均匀地在图片的不同位置进行密集抽样，抽样时可以采用不同尺度和长宽比，然后利用CNN提取特征后直接进行分类与回归。
整个过程只需要一步，所以其优势是速度快，但是训练比较困难。
yolov3（2018）是yolo作者提出的第三个版本（之前还提过yolov2和它们的tinny版本，tinny版本经过压缩更快但是也降低了准确率）。
2. 行人检测 这里学长以行人检测作为例子来讲解目标检测。
2.1 行人检测简介 行人检测( Pedestrian Detection)一直是计算机视觉研究中的热点和难点。行人检测要解决的问题是：找出图像或视频帧中所有的行人，包括位置和大小，一般用矩形框表示，和人脸检测类似，这也是典型的目标检测问题。
行人检测技术有很强的使用价值，它可以与行人跟踪，行人重识别等技术结合，应用于汽车无人驾驶系统(ADAS)，智能机器人，智能视频监控，人体行为分析，客流统计系统，智能交通等领域。
2.2 行人检测技术难点 由于人体具有相当的柔性，因此会有各种姿态和形状，其外观受穿着，姿态，视角等影响非常大，另外还面临着遮挡 、光照等因素的影响，这使得行人检测成为计算机视觉领域中一个极具挑战性的课题。行人检测要解决的主要难题是:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a84ee88ddb050e394242f4e415948fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f980377cee1748e279ac766d90cb2ef5/" rel="bookmark">
			前端刷新当前页面的方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在做编辑的时候遇到这样的问题：修改完数据之后需要刷新页面获取最新数据 前端刷新当前页面的方法总结：
1、this.$router.go(0)
2、location.reload()
以上两种刷新页面都会出现白屏，影响用户体验
3、provide / inject（推荐使用）
使用方法跟provide / inject组件传值一样
//父组件 provide(){ return{ reload: this.getPortData //获取接口的方法 } }, //子组件 inject:['reload'] 在编辑完成之后调this.reload()方法就行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c89330e7350ed14f6ed43c475fd854/" rel="bookmark">
			【Bellhop】画图教程-对于平整海底画出海底部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bellhop对平整海底进行画图时，一般我们的计算是只显示海水部分（如下图），有时候为了与不平整海底形成对比，需要画出平整海底。总之，一个很鸡肋的东西，但是需要的时候十分折磨人
对此，我们可以在env文件中进行一个简单的设置： -1.对于海深、声速梯度、接收传感器分布深度都设置到包含海底的最深，即海底底部；
-2、将计算范围设置成海水底部，即海底开始部分；
env文件实例如图： 以下为不显示海底env文件
‘Munk profile/Sea Mountain/Coherent transmission loss’
1000.0
1
‘SVW’
51 0 3600
0.0 1545.67 /
11.0 1545.98 /
21.0 1546.03 /
31.0 1546.15 /
41.0 1545.79 /
51.0 1539.53 /
61.0 1534.8 /
71.0 1531.13 /
81.0 1528.13 /
91.0 1524.08 /
101.0 1523.56 /
111.0 1522.38 /
121.0 1520.19 /
131.0 1516.97 /
141.0 1515.44 /
151.0 1514.02 /
161.0 1512.19 /
171.0 1510.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c89330e7350ed14f6ed43c475fd854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12c852173d710a57d5f423975b865fb/" rel="bookmark">
			char 字符变量和字符数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		char name = 'a';
char name[]='sbc';
char name[]='白'
char name='白' 这种表达是错误的
字符变量不能直接赋值汉字，因为编码规则不同，汉字占的字节不同。 ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节等等。
所以 char name='白' 是不对的。应该使用字符数组。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1721d74cc604ac14b8b956d9fd41b8b9/" rel="bookmark">
			Bellhop-复杂海底地形仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于同事最近出差，需要接手他的工作，所以趁机进修了一下他的bellhop。今天内容背景是，在实际海底模型基础上进行仿真。（当然，由于海底的数据比较敏感，真实海底数据不能提供，大家可以根据介绍自行创建海底文件） 导入海底数据 load long_bs load lat_bs load dep_bs %注意这里的海底深度不是真实深度，由于真实深度文件敏感，这里为我自己设置的sinc函数 %%%%%%%%%海底参数画图%%%%%%%%%%% figure mesh(longitude,latitude,depth) colormap(jet) colorbar; shading flat 如图，分别导入经度、纬度、深度三个数组，他们分别存储了经纬度信息和对应点的深度信息，使用mesh函数画成三维图像查看整个研究区域海底地形。
导入声速梯度
声速梯度存储在SSP.mat文件中，需要根据所需深度选择行数 load SSP ssp=ssp(1:59,:); %注意！！！！这里的59是对应的深度行，根据所选区域最深的深度以下确定声速梯度范围。 %例如，如果所选区域最大深度是5000m，打开SSP.mat文件，看到包含5000的在5200m，选到第62行才能完全包含海深 %%%%%%画声速梯度示意图%%%%%% figure plot(ssp(:,2),ssp(:,1)); set(gca,'YDir','reverse')%对Y方向反转 env文件设置
如图可知，如果需要修改海底为不平整的海底，或者说自己设置的海底，需要准备.bty文件，该文件由插值类型，点数和所计算截面海底深度随距离变化的矩阵组成。
（1） 插值类型：参数“ 插值类型” 是一个字符，等于‘L’（ 用于对表面进行线性插值）或‘C’（用于对表面进行曲线插值）。
（2） 点数：设置的深度点数。
（3） 海底深度随距离变化的矩阵：第一列为距离，距离单位为km；第二列为深度，深度单位为m。
运行结果
在选定点的0°，90°，180°，270°四个方向各选取40km计算传播损失，计算结果依次如图：
完整代码和数据文件：
完整代码和数据文件已经上传复杂海洋环境下不同角度使用Bellhop计算传播损失
其中包括，主程序mainfuction.m，运行它即可得到结果，其他的.m文件为所需要的函数，.mat文件为所需要的数据。bellhop.m和bellhop.exe为保证运行bellhop工具包的。
我将《Bellhop射线追踪程序概述(2008年6月发布).pdf》放入了资源中，大家可以自行查阅。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2543cb0f9cfcbc03f360a40ef3ba79a/" rel="bookmark">
			解决mysql不支持中文([HY000][1366] Incorrect string value ‘xE5xBCxA0xE4xB8x89‘ for column ‘xxxxx‘ at row 1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决mysql不支持中文([HY000][1366] Incorrect string value: '\xE5\xBC\xA0\xE4\xB8\x89' for column 'xxxxx' at row 1) 本教程环境： Ubuntu20.04(server版) + mysql5.7
报错内容： mysql&gt; insert into XXX values ('张三');
ERROR 1366 (HY000): Incorrect string value: ‘\xE5\xB0\x8F\xE6\x98\x8E’ for column ‘XXX’ at row 1
验证错误情况： 登录MySQL数据库，通过show variables like 'character%'; 查看编码格式 如果显示的内容与此图一样，则可通过本教程解决该错误
解决方案： sudo vim /etc/mysql/conf.d/mysql.cnf 在[mysql]的下方加入如下语句:(注：这个文件下没有配置，只有【mysql】) no-auto-rehash default-character-set=utf8 sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 在[mysqld]下加入 socket = /var/run/mysqld/mysqld.sock port = 3306 character-set-server=utf8 sudo /etc/init.d/mysql restart 重启MySQL 验证是否解决问题： 登录MySQL数据库，通过show variables like 'character%'; 查看编码格式 大功告成~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2543cb0f9cfcbc03f360a40ef3ba79a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e0ccc746f9f94a4b2546fe1bd0a700/" rel="bookmark">
			配置maven报错The JAVA_HOME environment variable is not defined correctly的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：其实也很明显，主要还是JAVA_HOME的配置影响了MAVEN_HOME的配置报错
文章目录 一、检查JAVA_HOME配置以及Path路径配置二、检查是否有其他配置影响总结 一、检查JAVA_HOME配置以及Path路径配置 1.检查JAVA_HOME的配置路径，是否为jdk安装目录，检查是否结尾有空格。
2.检查path中JAVA_HOME配置是否为%JAVA_HOME%\bin，检查是否结尾有空格。
3.如果还是不行就把JAVA_HOME删除保存后重新配置，把path中%JAVA_HOME%\bin删除保存后重新配置。
二、检查是否有其他配置影响 之前是添加了CLASSPATH配置导致报错，但是查询JAVA的版本确实也是安装配置没问题的，所以最后选择中CLASSPATH删除保存一下，然后maven安装配置就没问题了。
建议先保存一下CLASSPATH原有的路径，然后再进行修改或者删除。
总结 1.细心检查任何可能出现错漏的地方，加以吸取经验下次就不会再犯错了。
能够帮助你们解决问题是博主的荣幸，你们的支持是我创作的最大动力！:)欢迎关注点赞
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b11f80f428f8a484a6f24a3a736a6c/" rel="bookmark">
			如何实现基于场景的接口自动化测试用例？来看看大佬的方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动化本身是为了提高工作效率，不论选择何种框架，何种开发语言，我们最终想实现的效果，就是让大家用最少的代码，最小的投入，完成自动化测试的工作。
基于这个想法，我们的接口自动化测试思路如下：
1.不变的内容全部通过配置化来实现，比如：脚本执行的环境、请求的 HOST、URL 路径、测试数据等；
2.环境和数据关联变更：依据不同的环境，选择不同的配置及对应的测试数据；
3.抽取公共方法，避免冗余代码；
4.场景化的用例，实现可配置化；
5.数据驱动。
1.问题 在做自动化的过程中，不能只考虑单接口的脚本，也要考虑场景化的用例。场景化的用例 不需要每个步骤都去校验所有的数据，可能 更多看重串联后的最终效果。
那什么是场景用例？
其实就是多个接口组成的业务场景，常规写代码的做法是，先调用接口1，验证结果， 再调用接口2，再继续接口3，… 等等；在测试场景中，可能只是各个接口的入参不一样，或者是调用的接口不一样。这样代码写起来就会冗余。
比如：
def test_01(self): # step 01 result1 = PackDemo().getTest() assert result1 == 4 # step02 result2 = PackDemo2().getTest2("name") assert result2 == 'name' # step03 result3 = DemoApi().getTest() assert result3 == 2 这样的用例，对于简单的接口没什么问题，但是对于复杂的接口，校验逻辑比较多，或者入参比较多，实现的方式就过于单一了。且不同场景的话，每个都要更改调用的步骤和返回值，场景越多冗余越多。
如果使用配置化的方式，每次从配置文件中动态加载配置的场景用例， 而且能够做到加载后做对应的断言，那该多好。
怎么做呢？咱们看看一些核心的实现。
2.方案 2.1 项目结构 项目结构如下：
img
采用当前比较流行的 Python + Pytest + Allure 来实现，具体结构不做展开。
2.2 场景用例的配置数据 test_scenario.json { "test_01": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0b11f80f428f8a484a6f24a3a736a6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08aace71b49f1efc84e0f3a9097cc18/" rel="bookmark">
			springBoot自动装配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 作用
2. 注解
2.1 元注解
2.2 @Import
2.3 @Configuration
2.4 @ConditionalXXX
2.5 EnableConfigurationProperties
3. 配置文件
4. 结构
4.1 启动器
4.2 自动配置
5. 开发示例
5.1 创建工程
5.2 创建模块
5.3 开发自动配置模块
5.3.1 HelloProperties
5.3.2 IHelloService
5.3.3 HelloService
5.3.4 HelloServiceAutoConfigration
5.3.5 spring.factories
​编辑
5.3.6 安装到本地仓库
6. 使用自动装配模块
1. 作用 为了简化配置，使spring的使用更加方便，例如：可以回忆一下springboot中是如何继承redis的。
spring配置方式的进化过程：
xml的方式配置java config的方式配置，使用@configuration注解在java中配置自动装配 springboot starter作用：
引入模块所需的相关jar包自动配置各自模块所需的属性 使用springboot后集成常用的第三方框架变得非常简单了。
springboot starter带来的问题
starter使SpringBoot集成第三方框架变得简单，但对刚刚上手SpringBoot的人来说，可能只知道配置属性是在application.xml或application.yml中添加，但他们各自的属性都有哪些，具体怎么配置，却无从下手
2. 注解 自动装配相关的注解示例： 2.1 元注解 为更好的理解装配过程，复习一下元注解。
@Target： 自定义注解的使用范围，比如类，方法，属性等@Retention： 保留策略，如源码中保存（@Override），class中保存（@SupperWarning），运行时保存等@Docmented： 为javadoc使用的。@Inherited： 被其修饰的自定义注解可以被子类继承 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08aace71b49f1efc84e0f3a9097cc18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cad7c789b348829ce88f53b4f94564e/" rel="bookmark">
			BScroll warn 】EventEmitter has used unknown event type: “pullingUp“解决方法：看bs文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导致错误的代码如下 这是老版本之前的使用方法，会报错上拉控制台不显示上拉加载更多 import BScroll from "@better-scroll/core"; this.scroll = BScroll(document.querySelector(".wrapper"), { probeType: 3, //默认pullUpLoad为flase pullUpLoad: true, }); this.scroll.on("pullingUp", () =&gt; { console.log("上拉加载更多"); setTimeout(() =&gt; { this.scroll.finishPullUp(); // 2s之后下拉加载更多 }, 2000); }); 如图所示 解决方法 看文档
上拉https://better-scroll.github.io/docs/en-US/plugins/pullup.html#usage代码需要修改为
首先，通过静态方法安装插件BScroll.use() import BScroll from '@better-scroll/core' import PullUp from '@better-scroll/pull-up' BScroll.use(PullUp) this.scroll = BScroll(document.querySelector(".wrapper"), { pullUpLoad: true }); this.scroll.on("pullingUp", () =&gt; { console.log("上拉加载更多"); }); 但是 下拉两次后出现bug，让调试，后来在看文档需要修改
bscroll.refresh() 将其改为
this.bscroll.refresh() 最后代码为
import BScroll from '@better-scroll/core' import PullUp from '@better-scroll/pull-up' BScroll.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cad7c789b348829ce88f53b4f94564e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb98f618a19724eeed87a74d4adee2a9/" rel="bookmark">
			ubuntu20.04&#43;python3编译gnss_ins_sim报错问题解决(多传感器融合定位第6章)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行功能包时出现如下问题：
RLException: Roslaunch got a 'No such file or directory' error while attempting to run: /home/hb/ws/sensor_fusion_ws/src/gnss_ins_sim/src/recorder_node_sim.py __name:=gnss_ins_sim_recorder_node __log:=/home/hb/.ros/log/5faa6140-30e9-11ed-a211-c1c0f221f6f2/gnss_ins_sim_recorder_node-2.log Please make sure that all the executables in this command exist and have executable permission. This is often caused by a bad launch-prefix. The traceback for the exception was written to the log file 在gnss_ins_sim/src中找到recorder_node_sim.py，修改第一行代码
#!/usr/bin/python改为#!/usr/bin/python3 然后继续roslaunch gnss_ins_sim recorder_gnss_ins_sim.launch，又出现如下问题， Traceback (most recent call last): File "/home/hb/ws/sensor_fusion_ws/src/gnss_ins_sim/src/recorder_node_sim.py", line 13, in &lt;module&gt; from gnss_ins_sim.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb98f618a19724eeed87a74d4adee2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d7feff34e09dc0582f9e5b4c9e40ae/" rel="bookmark">
			nvm安装注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.下载地址：
2.设置淘宝镜像：
3.附录
1.下载地址： Releases · coreybutler/nvm-windows · GitHub（尽量下载最新版本的nvm,以免出现升级高版本node时，npm无法使用的情况）
2.设置淘宝镜像： 在安装完成之后，建议在根路径中的setting.json文件中，设置淘宝镜像，这样查看、下载node版本比较快，淘宝镜像如下：
root: C:\Users\userName\AppData\Roaming\nvm arch: 64 proxy: none originalpath: . originalversion: # 淘宝镜像 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 3.附录 nvm常用命令
nvm list 查看已经安装的版本 nvm list installed 查看已经安装的版本 nvm list available 查看网络可以安装的版本 nvm version 查看当前的版本 nvm install 安装最新版本nvm nvm use &lt;version&gt; ## 切换使用指定的版本node nvm ls 列出所有版本 nvm current显示当前版本 nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名 nvm unalias &lt;name&gt; ## 删除已定义的别名 nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包 nvm on 打开nodejs控制 nvm off 关闭nodejs控制 nvm proxy 查看设置与代理 nvm node_mirror [url] 设置或者查看setting.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d7feff34e09dc0582f9e5b4c9e40ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b06caed8f414883689b0fd55e97730/" rel="bookmark">
			Maven打包同一个jar有不同的：版本&#43;时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图,
没有时间戳的jar包是最新版本的jar包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17433e213c91bd7c1636c0ba82bcd47e/" rel="bookmark">
			解决错误syntax error near unexpected token `(‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言
今天想要编译一个简单的C文件看看结果，结果总是报错
2.解决方法
看看我都做了什么糊涂事吧
这是enum.c文件
好家伙我保存好了该文件后就直接把它运行了...
然后就开始报错
我想啊这不就是代码中出现了中文嘛，直接把括号该成英文下的括号就行了嘛，结果kuakuakua一顿操作后还是报这个错
我一整个懵逼，咋回事呢，百思不得其解。结果我无意间看见了gcc，灵光一闪，我这才发现我都没有编译生成二进制文件，所以它当然执行不了。
正确操作应该是这样：
咱就是说，它报的这个错是真的好有迷惑性，我一度以为我输入法坏掉了.......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0e9491b8542bce5a1a3a7f8631d53a/" rel="bookmark">
			React中的useEffect(副作用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
useEffect(副作用)介绍
useEffect(副作用)各种写法的调用时刻
1.写法一：没有依赖项时
父组件给子组件传值：
2.写法二:依赖项中有监听的值时
3.写法三：依赖项为空数组时
4.写法4：清除副作用写法(假如副作用是一个定时器,清除定时器,如果不清的话，会出现内存泄漏)
5.写法五：依赖项是一个函数的时候
注意点
useEffect(副作用)介绍 useEffect是用来使函数组件也可以进行副作用操作的。那么什么是副作用呢？
函数的副作用就是函数除了返回值外对外界环境造成的其它影响。举个例子，假如我们每次执行一个函数，该函数都会操作全局的一个变量，那么对全局变量的操作就是这个函数的副作用。而在React的世界里，我们的副作用大体可以分为两类，一类是调用浏览器的API，例如使用addEventListener来添加事件监听函数等，另外一类是发起获取服务器数据的请求，例如当用户组件挂载的时候去异步获取用户的信息等。
react官方的原话：
如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。
componentDidMount 组件挂载
componentDidUpdate 组件更新
componentWillUnmount 组件将要摧毁
语法：
import {useEffect} from "react" useEffect(() =&gt; { /** 执行逻辑 */ }, dependencies) //dependencies是一个数组，是可选的 //或者： useEffect(effect?=&gt;clean?, dependencies?) useEffect的第一个参数 effect 是要执行的副作用函数，它可以是任意的用户自定义函数，用户可以在这个函数里面操作一些浏览器的API或者和外部环境进行交互,网络请求等，这个函数会在每次组件渲染完成之后被调用。useEffect可以有一个返回值,返回一个函数,系统在组件重新渲染之前调用,用于清除副作用(比如说副作用是定时器，return里面就可以写清除定时器的代码)。它第二个参数dependencies(依赖项)来限制该副作用的执行条件 useEffect(副作用)各种写法的调用时刻 1.写法一：没有依赖项时 useEffect所在组件每次渲染(包括首次)时都要调用:组件中任何变化都会执行(eg:useState解构出的state改了就会引发组件重新渲染，父组件给子组件传递属性的值改变,子组件中的useEffect就会执行)
//没有依赖项 useEffect(()=&gt;{ console.log('组件每次渲染时都要调用(页面每次刷新)'); }) 组件生命周期里面有一种生命周期父组件给子组件传新的属性就会调用的生命周期函数，useEffect写法一就可以替代。
组件自身状态变化会调用beforeupdate和updated,useEffect写法一就可以替代。
父组件给子组件传值： 2.写法二:依赖项中有监听的值时 根据依赖项中监听的变量是否变化决定是否执行副作用，变了就执行，不变就不执行。
//依赖项中有值时 //页面首次渲染和父组件给子组件传的属性值和子组件自身的值改变(依赖项改变才会打印) useEffect(() =&gt; { console.log('页面首次渲染和依赖项改变的时候才会打印'); },[num,props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa0e9491b8542bce5a1a3a7f8631d53a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d38bca71fdf4a342e97b7f0cd85c8d/" rel="bookmark">
			多种动态绑定class和style
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.三元表达式 &lt;h3 :class="italic ? 'italic' : '' " &gt;111&lt;/h3&gt; &lt;h3 :style="italic ? 'color:red' : '' " &gt;111&lt;/h3&gt; &lt;div :style="{color:(index == 1 ? conFontColor:'#000')}"&gt;&lt;/div&gt; &lt;div :style="[{color:(index == 1 ? conFontColor:'#000')},{fontSize:'18px'}]"&gt;&lt;/div&gt; &lt;div :style="item.layerName === activeLayerName?'font-weight:700' : 'font-weight:400'"&gt;&lt;/div&gt; &lt;!-- 写法一 --&gt; &lt;div :style="[{float: id === '12' ? 'left:'right}]"&gt;&lt;/div &lt;!-- 写法二 --&gt; &lt;div :style="float: nameList.length === 20 ? 'height:64px' : 'height:32px' "&gt;&lt;/div&gt; &lt;!-- 写法三 --&gt; &lt;div :style="{border:( nameId ===item.id ?'2px solid #4C78FF': 'red')}"&gt;&lt;/div&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19d38bca71fdf4a342e97b7f0cd85c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015da1be84784da8b53ba811735ac60e/" rel="bookmark">
			resulttype和resultMap区别详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、对象不同
1. resultMap
2. resultType
3. 分析
二、描述不同
1、resultMap
2、resulTtype
三、类型适用不同
一、对象不同 1. resultMap 如果查询出来的结果的列名和实体属性不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系（示例代码如下）。
&lt;!--结果返回类型采用resultMap定义--&gt; &lt;select id="findCardById" parameterType="int" resultMap="findCard"&gt; select * from card where id=#{id} &lt;/select&gt; &lt;!--对上述resultMap进行自定义映射--&gt; &lt;resultMap id="findCard" type="card"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="number" column="number"/&gt; &lt;/resultMap&gt; 2. resultType resultType使用resultType进行输出映射，只有查询结果显示的列名和实体的属性名一致时，该列才可以映射成功。
&lt;!--结果返回类型采用resultType定义--&gt; &lt;select id="findCardById" parameterType="int" resultType="card"&gt; select * from card where id=#{id} &lt;/select&gt; 3. 分析 从上述的实例代码可以看出，针对相同的类的映射，resultType和resultMap均可实现。
对于resultMap而言，除了需要在&lt;select&gt;标签中进行申明外，还需要单独使用&lt;resultMap&gt;&lt;/resultMap&gt;实现实体属性与数据库表列名之间的自定义映射，适合多表查询。对于resultType而言，仅需在&lt;select&gt;标签中用resultType属性申明结果返回类型即可，适合单表查询。 二、描述不同 1、resultMap 对于一对一表连接的处理方式通常为在主表A的实体中添加嵌套另一个表B的实体，然后在mapper.xml中采用&lt;association&gt;元素进行对另一个表B的连接处理，其中&lt;association&gt;元素中的select的值为表B对应的SQL语句的唯一标识，一般为namespace+SQL语句的id。
在下述例子中，person实体与card实体是一对一的关系，查询要求是：根据person表中id的值查询用户的id,name,age,sex以及卡号number，但是在person表中只有number对应的card表的id值，故需要采用resulMap。
1.1 Cad类
package com.chen.pojo; public class Card { private int id; private String number; //toString方法、set以及get方法省略 } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015da1be84784da8b53ba811735ac60e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eddfd2c2e9232b9c71d660d27ed0173b/" rel="bookmark">
			jquery ajax post请求下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次用ajax post请求下载文件 ，之前一直用vue的写，今天用同样方式发现是乱码，走了不少弯路，特此记录下方法
var outData = getData() //传参数据 var url = baseUrl + "/golivepm/reconcByZsd/download"; //接口 var xhr = new XMLHttpRequest(); xhr.open('POST', url, true); xhr.responseType = "blob"; // 返回类型blob xhr.setRequestHeader("Content-type", "application/json;charset=utf-8"); //这个看后端接口情况决定要不要写 // 定义请求完成的处理函数，请求前也可以增加加载框/禁用下载按钮逻辑 xhr.onload = function () { // 请求完成 if (this.status === 200) { // 返回200 var blob = this.response; var reader = new FileReader(); reader.readAsDataURL(blob); // 转换为base64，可以直接放入a表情href reader.onload = function (e) { // 转换完成，创建一个a标签用于下载 var a = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eddfd2c2e9232b9c71d660d27ed0173b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e68cd3f5b579c165b2350d93426f177f/" rel="bookmark">
			解决npm 下载工具包太慢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm对应的地址是国外的 需要海底电缆传输 受各种因素影响 传输到国内的速度确实受到影响 我们可以把下载源换成国内的淘宝镜像 这样速度会快很多
以下有三种方法可以参考
1 用npm下载cnpm 把地址换成淘宝镜像
npm install -g cnpm --registry=https://registry.npm.taobao.org // 查看版本 cnpm -v // 之后下载东西就用cnpm代替npm下载 2 设置改变默认下载地址 还是用npm下载
// 查看当前下载地址 npm config get registry // 设置淘宝镜像的地址 npm config set registry http://registry.npm.taobao.org // 查看当前的下载地址 npm config get registry 3 自己按需求切换下载地址
// nrm安装 npm install -g nrm // 查看可选源 星号代表当前使用源 nrm ls // 切换为taobao源 nrm use taobao // 还有其他操作可以自行百度，上面是最常用的，足够了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2af4a64482192a2e1c156a925f0a0fa8/" rel="bookmark">
			MATLAB可视化&#43;多图共用corlorbar设置&#43;axes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多子图加入colorbar导致子图大小和位置变化，解决办法的：直接用cb=colorbar('position',[0.94,0.1,0.02,0.85]); 单独设置colorbar的位置和大小。 Matlab多子图绘制的时候加入colorbar会影响子图的大小（加colorbar的子图会自动缩放），其他大多是用新的TileLayout等，但是前面已经用axes等设置了很多参数了，发现这个很有用，也最简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677a37fce91e45b2f829f344aac700f3/" rel="bookmark">
			vue在history mode模式下页面刷新出现了Cannot GET
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法简单粗暴
就是在webpackconfigjs中新增一个这段代码,这时候刷新就不会出现Cannot GET
... devServer:{ historyApiFallback: true } ... 原因
在History mode下，如果直接通过地址栏访问路径，那么会出现404错误，这是因为这是单页应用（废话）…其实是因为调用了history.pushState API 所以所有的跳转之类的操作都是通过router来实现的，解决这个问题很简单，只需要在后台配置如果URL匹配不到任何静态资源，就跳转到默认的index.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ff48f52a4054ee0103764516ff0070/" rel="bookmark">
			WPF使用Microsoft.Toolkit.Mvvm框架记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
为了解决WPF UI与程序逻辑之间得到解耦，所以使用Microsoft.Toolkit.Mvvm框架来实现，说真的开发逻辑真的有些不适应，不过理解就好。框架大体支持ICommand、IMessenger等。
什么是MVVM? MVVM是Model-View-ViewModel的简写。它本质上就是MVC （Model-View- Controller）的改进版。即模型-视图-视图模型。分别定义如下：
【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向： 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。 MVVM示意图如下所示
一、导入包
二、使用框架实现
&lt;Window x:Class="myMVVM.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:myMVVM" mc:Ignorable="d" Title="MainWindow" Height="450" Width="800"&gt; &lt;Grid&gt; &lt;TextBox HorizontalAlignment="Left" Margin="145,52,0,0" TextWrapping="Wrap" Text="{Binding Name}" VerticalAlignment="Top" Width="517" Height="189"/&gt; &lt;Button Content="Button" HorizontalAlignment="Left" Margin="245,294,0,0" VerticalAlignment="Top" Height="72" Width="278" Command="{Binding ShowCommand}"/&gt; &lt;/Grid&gt; &lt;/Window&gt; using Microsoft.Toolkit.Mvvm.Messaging; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using System.Windows.Data; using System.Windows.Documents; using System.Windows.Input; using System.Windows.Media; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ff48f52a4054ee0103764516ff0070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d130b61af72c172ce79d75e40c4583f1/" rel="bookmark">
			git删除远程仓库上已提交的文件/文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景 由于给本地项目配置远程库，误提交很多不应该提交的文件或文件夹，比如 .idea .settings .project .iml 以及日志等文件。以及由于 .gitignore 文件配置不正确很有可能导致某些不需要的目录上传到 git 远程仓库上了。除了注意配置 .gitignore 文件外，以下是解决办法。
提交了文件到自己的远程分支上，但还没有合并到远程主分支，现需要删除
git如何删除已经提交的文件夹 （1）查看有哪些文件夹 dir （2）预览将要删除的文件（如果不清楚该目录下是否存在不应该删除的文件） git rm -r -n --cached 文件/文件夹名称 加上 -n 这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览
（3）确定无误后删除文件（不会删除本地的文件或文件夹） git rm -r --cached 文件/文件夹名称 （4）提交到本地并推送到远程服务器 git commit -m "提交说明" git push 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215578b437b1f98aadc601be9a606b71/" rel="bookmark">
			matlab 小数据法求liyapunov指数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、内容简介
略
625-可以交流、咨询、答疑
2、内容说明
摘 要：从 Lyapunov 指数的定义出发：在常用计算最大 Lyapunov 指数的基础上，将自相关法和 G-P 法应用于小数 据量法中，得到了一种计算最大 Lyapunov 指数的改进小数据量法。并通过 MATLAB 对几种已知动力学模型的数值 模拟表明：该新方法比原来常用的小数据量法在计算准确度和重构相空间的参数选择上更加优越。 关键词：小数据量法；最大 Lyapunov 指数；时间序列；
混沌研究复杂非线性动力系统与混沌的一个主要问题之一是对混沌的判断，而目前在表征混沌运动方面，显示出重大意义的统计特征值之一就是Lya－punov指数,它是相空间中相近轨道的平均收敛性或平均发散性的一种度量.自1985年Wolf[1]提出根据观测时间序列计算Lyapunov指数的方法以来，至今在这方面比较成熟的算法还有Jacobian方法、p范数方法与Rosenstein和Kantz[2]等人提出的小数据量法.小数据量算法相对于其他方法更具有对相空间的嵌入维数、延迟时间、观测噪声等鲁棒性，计算Lyapunov指数的同时,还可以得到关联维数等其他混沌系统的重要特征量.但通常的小数据量算法在计算时间延迟时采用的都是快速傅里叶变换,而这样计算出的结果误差较大.本文采用自相关函数法来求时间延迟,然后选用G-P法来计算嵌入维数,从而得到了计算最大Lyapunov指数的小数据量法的改进算法.并通过MATLAB对几种已知动力学模型的数值模拟表明：该新方法比原来常用的小数据量法在计算准确度和重构相空间的参数选择上更加优越,特别对嵌入维数在一定的范围具有稳定性，且可靠性很好.
3、仿真分析
tau=12 ;
m=5 ;
fs=1/0.01;
%调用函数mean_cycle求出序列的平均周期
t_p=mean_cycle(data,fs);%fs为时间序列采样频率
t_p=50;
%采用小数据量法计算李亚普诺夫指数，主函数
data_chonggou=PhaSpaRecon(data,tau,m);
data_chonggou=data_chonggou';
[hang,lie]=size(data_chonggou);
4、参考论文
一种计算最大Lyapunov指数的改进小数据量法及其实现.pdf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b383701f689a0567e6b58346d775331/" rel="bookmark">
			26.gateway的IP 认证拦截，gateway做token验证 流程图（springcloud）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 创建 IPGlobalFilter package com.it.filter; import com.fasterxml.jackson.databind.ObjectMapper; import lombok.SneakyThrows; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.core.annotation.Order; import org.springframework.core.io.buffer.DataBuffer; import org.springframework.http.HttpStatus; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; /** * 网关里面 通过设置过滤器进行ip拦截 * ip拦截： * 请求都有一个来源 * 请求--&gt;gateway--&gt;service * 黑名单：具体的业务服务用黑名单 * 白名单：访问数据库用白名单，防止别人恶意访问 */ public class IPCheckFilter implements GlobalFilter, Ordered { /** * 网关的并发量比较高，不要在网关里面直接操作mysql * 后台的系统可以查询数据库 用户量 并发量不大 * 如果并发量大 可以查看redis 或则在内存中写好 */ public static final List&lt;String&gt; BACK_LIST= Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b383701f689a0567e6b58346d775331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71986fb0cf63862668b8258a59ffd867/" rel="bookmark">
			elementUi--＜el-select＞样式渲染问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.一定要在 &lt;el-select&gt; 里添加 :popper-append-to-body="false" 属性；
2.若未加入 :popper-append-to-body="false" 属性，那么此时渲染后的 DOM 元素不在 #app 元素内部；
3.原因: el-select 里面的 select-popper 元素渲染后会脱离 #app ,因此使用深度选择器也无法定位该元素;
//加入该属性后，对需要修改的部分 /deep/.类名{ } //es6中格式为 :deep(.类名){ } 认真看文档啊亲，哭死。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c717a3ead435744b5be6cfe4e58cb0/" rel="bookmark">
			yolov5（6.1）学习历险记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov5整体结构可以分成backbone（骨干网），neck（颈部），head（检测头）三个部分，其中在yolov5.yaml配置文件中neck和head写在了一个部分。
backbone：进行特征提取。常用的骨干网络有VGG，ResNet，DenseNet，MobileNet，EfficientNet，CSPDarknet 53，Swin Transformer等。（其中yolov5s采用CSPDarknet 53作为骨干网）应用到不同场景时，可以对模型进行微调，使其更适用于特定的场景。
neck：neck的设计是为了更好的利用backbone提取的特征，在不同阶段对backbone提取的特征图进行在加工和合理利用。常用的结构有FPN，PANet，NAS-FPN，BiFPN，ASFF，SFAM等。（其中yolov5采用PAN结构）共同点是反复使用各种上下采样，拼接，点和和点积来设计聚合策略。
Head：骨干网作为一个分类网络，无法完成定位任务，Head通过骨干网提取的特征图来检测目标的位置和类别。
再说PANet之前就得说到FPN，这应该也是看文献中反复会提到的一个词语---特征金字塔
（一）特征金字塔（Feature Pyramid Network， FPN）
总所周知，图像中存在不同尺寸的目标，不同的目标具有不用的特征。其中浅层特征更关注细节信息，对目标的定位十分关键。而深层特征更关注语义信息，对目标对象的分类十分重要。大多数通用检测器只采用末层输出进行检测，其中包含丰富的语义信息却忽略其他层的特征。（如SSD） 为了利用多层特征信息，有研究者提出图像金字塔，在图像金字塔的每一层所提出的不同特征，分别进行相应的预测。尽管精度上有一定的提升，但计算量大，需要大量的内存，并且这个点经常会成为整个网络模型优化的瓶颈，所以一般不会采用这个方法。
为了改进图像金字塔，有研究者提出减少预测的特征图，同时利用高层和低层特征进行预测（在不同的层级上）。在一定程度上不同层级对应不同输出，加速了运算，但是！所获得的特征不具有鲁棒性，都是一些弱特征（毕竟没有经过那么多网络的“筛选”）。
为解决上述问题，特征金字塔能够在速度和准确率之间进行权衡，获得更加鲁棒的语义信息！
首先对输入图像进行深度卷积，然后对2上面的特征进行降维操作（即添加一个1*1的卷积层）然后对4上的特征进行上采样使得其具有相同的尺寸，然后对于处理好的2，4进行加法操作，将获得的结果输入到5中，以此获得更强的语义信息。（其中1-3为bottom-up，4-6为top-down）
FPN可以很好处理小目标的原因：
1.FPN可以利用经过top-down模块后的那些上下文信息（高层语义信息）。
2.对于小目标而言，FPN增加了特征映射的分辨率。（即在更大的Feature map上操作，可以获得更多关于小目标的信息）
（二）路径聚合网络（Path Aggregation Network，PANet）
相较于FPN的改进点如下：
1.提出一个自顶向下和自顶向上的双向融合骨干网络 2.在最底层和最高层之间添加了一条“short cut”用于缩短层之间的路径 3.为恢复每个建议区域和所有特征层级之间被破坏的关系，提出自适应特征池化（adaptive feature pooling ） 4.全连接融合层：使用一个小型FC层用于补充mask预测
在FPN中，依据候选框区域大小分配不同特征层次，小的分配到low-level，大的分配到high-level。所以提出池化来自所有层的特征，然后融合他们做预测。---自适应特征池化
（三）Bidirectional Feature Pyramid Network 加权双向（自顶向下 + 自低向上）特征金字塔网络
与PAN相比改进点：
增加残差链接：通过简单的残差操作，增强特征的表示能力（紫色路线）
移除单输入边的结点：因为但输入边的结点没有进行特征融合，故具有的信息比较少，对于最后的融合没有什么贡献度，相反，移除还能减少计算量。
权值融合：简单来说，就是针对融合的各个尺度特征增加一个权重，调节每个尺度的贡献度，其中，做个提出了Fast-softmax，提高检测速度。其实就是注意力机制与FPN的碰撞。
BiFPN = 加强版的PANet(重复双向跨尺度连接) + 带权重的特征融合机制
yolov5采用PAN作为颈部网络
其中C3模块换成了不带有残差连接的模块，因为认为在neck部分不需要再一味的加深网络。通过上采样（upsample）来调整特征图的尺寸方便进行拼接操作。针对yolov5neck部分改进也有很多，比如替换PAN为BiFPN，ASFF等。不同应用场景效果不同！
总之还有好多好多要学习的....慢慢来吧！加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cccad385b6615d404ac9fd3a0b59cd2/" rel="bookmark">
			彻底搞懂javascript中的replace函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript这门语言一直就像一位带着面纱的美女，总是看不清，摸不透，一直专注服务器端，也从来没有特别重视过，直到最近几年，javascript越来越重要，越来越通用。最近和前端走的比较近，借此机会，好好巩固一下相关知识点。链接：彻底搞懂javascript中的replace函数_慕课手记
1.初识replace
在js中有两个replace函数 一个是location.replace(url) 跳转到一个新的url
一个string.replace("xx","yy") 替换字符串 返回一个新的字符串，该方法并不改变字符串本身
location.replace(url) 无痕跳转(将当前链接导航到一个新的url 并不保存历史记录)
与之相对的是location.href="url" 有痕跳转(将当前链接导航到一个新的url 且保存历史记录) 这个没有比较清晰
string.replace函数 很多初学者，会认为这个跟C#中的Replace一样，但并不相同，js中replace更灵活。
最基本的用法 就是简单替换字符串。来看一个例子：
var str = "abcd-abcd-abcd";var result = str.replace("a", "");console.log(result);//输出 bcd-abcd-abcd//当第一个参数是一个简单字符串时，仅替换第一个匹配项 2.走进replace之正则表达式
参数一：正则表达式对象或字面量(支持gi模式) g全局匹配 i忽略大小写
参数二：要替换的字符串或一个function
可以使用正则表达式的相关引用
如果是function，则替换为function的返回值
此function的参数：
match 匹配的子串。（对应于上述的$&amp;。）
p1,p2, ... 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）
offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）
string 被匹配的原字符串。
正则表达的引用
$$ 插入一个 "$"。
$&amp; 插入匹配的子串。
$` 插入当前匹配的子串左边的内容。
$' 插入当前匹配的子串右边的内容。
$n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。
3.来一轮带注释的demo，彻底搞懂javascript中的replace函数：
全局匹配：
var str = "abcd-abcd-abcd";var result = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cccad385b6615d404ac9fd3a0b59cd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e69e9c11a554b968ee795e8701a507/" rel="bookmark">
			Leetcode2467-树上最大得分和路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两遍dfs：
第一遍dfs把所有结点的父节点跑出来，然后预处理bob回到根结点的路径上的amount值。
第二遍dfs把所有子节点的得分算出来取最大值即可。
class Solution { public: vector&lt;vector&lt;int&gt;&gt; e; vector&lt;int&gt; fa; vector&lt;int&gt; pre; int ans=-10000000; int n; void dfs1(int x,int p){ fa[x]=p; for(auto u:e[x]){ if(u==p) continue; dfs1(u,x); } } void dfs2(int x,int cur,vector&lt;int&gt;&amp; amount){ cur+=amount[x]; if(e[x].size()==1&amp;&amp;e[x][0]==fa[x]){ ans=max(ans,cur); } for(auto ed:e[x]){ if(ed!=fa[x]) dfs2(ed,cur,amount); } } int mostProfitablePath(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int bob, vector&lt;int&gt;&amp; amount) { n=edges.size()+1; e.resize(n); fa.resize(n); for(auto p:edges){ e[p[0]].push_back(p[1]); e[p[1]].push_back(p[0]); } dfs1(0,-1); for(;~bob;bob=fa[bob]){ pre.push_back(bob); } for(int i=0;i&lt;pre.size()/2;i++){ amount[pre[i]]=0; } if(pre.size()&amp;1) amount[pre[pre.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e69e9c11a554b968ee795e8701a507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1dc72c28d0218ce0646a4bcd7f76c6/" rel="bookmark">
			FBE 与FDE学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本文档简述 1.1、定义:
Full-disk encryption (FDE) 全盘加密android4.0引入
File-based encryption (FBE) 文件级加密 android7.0引入
1.2、学习目标: 1、熟悉 linux 加密/解密，挂载流程，工具使用
2、熟悉android加密/解密，挂载流程。
2、预备知识 2.1、加密技术 https://www.cnblogs.com/redcoatjk/p/3822585.html 按作用不同，文件加密和数字签名技术主要分为数据传输、数据存储、数据完整性的鉴别以及密钥管理技术4种。
1、数据传输加密技术是对传输中的数据流加密，常用的方法有线路加密和端对端加密两种。
2、数据存储加密技术目的是防止在存储环节上的数据失密，可分为密文存储和存取控制两种。
3、数据完整性鉴别技术是对介入信息的传送、存取、处理的人的身份和相关数据内容进行验证，达到保密的要求。
4、密钥管理技术是数据的加密技术通常是运用密钥对数据进行加密，这就涉及到了密钥的管理问题。
2.2、典型加密算法 2.2.1、基于“消息摘要”的主要算法
MD5、sha.1，主要特点密文固定长度、稍有改变密文完全不同、无法数据还原。所以用于验证数据的完整性。android中的使用例子OTA包传输使用的MD5，OTA差分升级使用的SHA256，DM-verity使用的HASH算法。
MD5算法原理https://blog.csdn.net/sinat_27933301/article/details/79538169
2.2.2、“对称/非对称密钥”加密算法
对称算法：DES算法，RC算法，AES算法，主要特点加密可逆，加密解密使用相同密钥。全盘加密，文件级加密使用的一般是AES算法。
非对称算法：RSA算法，主要特点是加密解密使用不同密钥。
公钥加密，私钥解密（加密传输）；私钥签名，公钥验签（确认发送方，也可验证完整性，可以用于OTA包签名，secure boot，Verify boot，应用签名）。
https://www.jianshu.com/p/3331467d139f
签名、加密、证书的基本原理和理解 https://www.cnblogs.com/Caersi/p/6720789.html
AES算法原理https://blog.csdn.net/gulang03/article/details/81175854
RSA算法原理https://blog.csdn.net/u014044812/article/details/80866759
2.3、Linux加密工具 2.3.1对称算法
全盘加密
全盘加密工具使用https://blog.csdn.net/zhongbeida_xue/article/details/78550712#t18
示例
fallocate -l 1G ./luks.vol //创建大文件 cryptsetup --cipher aes-xts-plain64 --key-size 512 --hash sha512 --iter-time 10000 luksFormat ./luks.vol //加密 cryptsetup luksOpen ./luks.vol yectest //创建解密映射连接 ls /dev/mapper/ mkfs.ext4 /dev/mapper/yectest //给该块/文件创建文件系统 mkdir /mnt/yectest mount /dev/mapper/yectest /mnt/yectest//挂载文件系统 df -hT 修改文件 umount /mnt/yectest //卸载 cryptsetup close yectest //关闭映射连接 文件系统加密
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1dc72c28d0218ce0646a4bcd7f76c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f3d4704a4cfb4e84f1580907723ccac/" rel="bookmark">
			C语言的简单运用——三子棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习新知识固然重要，但如何运用所学的知识解决生活中的问题更为重要。只会学而不会用，何异于纸上谈兵。那么就让我们来看看如何用C语言来实现一个简单的三子棋吧！
目录
前言
一点建议
一、游戏菜单
1.菜单界面
2.开始或退出游戏
二、游戏内容
1.棋盘
2.走子过程
3.判断结果
4.游戏内容拼接
三、界面优化
1. 棋盘界面
2.文字提示和过场停顿 3.清屏
四、拓展内容
1.双人游戏
2.简易AI
一点建议 由于实现三子棋的代码相比我们学习时所用的代码要长得多，因此我们最好把不同的游戏功能分装到不同函数中分别实现，并且可以分装多个源文件和头文件，方便调用函数，这样我们的代码就不会显得很杂乱，也方便后续对代码的维护和更新。
如图，当我在一个自定义头文件中包含了所需的所有头文件并声明了所有所需的函数时，我只需要在源文件中包含该自定义头文件，即可调用我需要的所有函数。
一、游戏菜单 1.菜单界面 我们知道，当我们打开游戏，映入眼帘的应该是游戏菜单，在菜单里可以选择进行游戏或者退出游戏，那么我们就需要用C语言写一个简易的菜单界面。
如图，用printf函数打印出一个简易的菜单界面。
2.开始或退出游戏 如菜单所展示的，我们如何使玩家选择开始或退出游戏呢？这时我们可以分装一个函数，专门用于控制游戏的开始与退出，例如test函数
test函数中含有一个循环体，其实很好理解，当我们玩完一把游戏后就会回到菜单重新选择开始或者退出游戏，写成循环就可以使玩家在不退出游戏的情况下连续开始游戏。那么我们来分析循环内容，首先，调用menu函数，打印一个菜单，然后用scanf函数让玩家选择开始或者结束，这时候我们可以分为三种情况，例如，当玩家输入1时，说明他想开始游戏，那么判断input等于1则进入game函数(game函数为游戏内容，如图中“游戏开始”)；还有可能input等于2，说明玩家想退出游戏，那么我们用break跳出循环，游戏结束；最后一种情况，input既不等于1，也不等于2，说明输入错误，那么程序应该给出反馈并让玩家重新选择。
这样一来，三子棋小游戏的菜单就做好了。
二、游戏内容 1.棋盘 初始化棋盘
三子棋的棋盘相信大家都很熟悉，一个九宫格和两种不同的棋子，那么在C语言中实现的三子棋大致如下图
由于下棋是一个动态过程，我们并不能只考虑打印棋盘，还要考虑如何将棋子放上棋盘。我们看到，没放棋子的地方都是空格，而棋子可以用字符来代表，那么我们可以定义一个字符数组来代表棋子， 而棋盘为三行三列，正好可以用一个三行三列的二维数组来代表棋子。那么我们创建一个二维数组。由于游戏开始时棋盘的九个位置均为' '(空格)，所以我们应该将数组的所有元素初始化为' '。我们在函数init中实现
打印棋盘
当我们完成初始化后，就需要把棋盘呈现在玩家面前了，我们可以用一个print_board函数实现。这里我们有两种方式来打印棋盘，一种是像打印目录一样，用多行printf函数实现，另一种是我提倡的，用循环来打印，如图
图中的COL和ROW均为宏常量，值为3，用宏常量的好处在于，当我们需要调整棋盘大小时，仅需调整宏常量的值即可。我们来看循环体，变量i控制行数，变量j控制列数，嵌套循环体中的if else语句用于判断是否为最后一列，若为最后一列，则不打印|。下方的if语句同理，打印|和---主要是为了优化界面，方便玩家观察。而棋子的打印才是这套循环的重点，我们可以看到printf函数中有格式符%c用于打印数组元素arr[i][j]，而这个二维数组正好对应了棋盘的九个位置。在前面我们已经用init函数初始化了棋盘，那么此时数组的九个元素均为' '(空格)，所以我们打印出来的棋盘就是这个效果
2.走子过程 玩家走子
棋盘已经制作完成，接下来就该下棋了，这里我们设计一个player_move函数，当玩家输入一个坐标时，我们将该坐标对应的数组元素替换成玩家的棋子，这样便可以实现落子。当然，我们需要做一个简单的判断，如果玩家输入的坐标在棋盘外，或者该坐标上已有棋子，那么当然不能成功落子，需要重新输入坐标下棋，我们用以下逻辑实现
当玩家输入坐标时，判断坐标是否合法，如果合法，则将该坐标上的数组元素(空格)替换为玩家的棋子(图中为'X')，并跳出循环，若坐标非法，则循环重新输入坐标。
电脑走子
玩家走子后轮到电脑走子，电脑走子的逻辑跟玩家走子差不多，但是要让电脑选择一个坐标落子，我们可以用基础的随机数让电脑随机落子，如下图
使用srand函数，rand函数和time函数生成随机数，并生成随机坐标，按照玩家走子的逻辑判断该坐标是否合法，若合法则将该坐标对应的数组元素(空格)替换为电脑的棋子(图中为'O')。
3.判断结果 玩家和电脑交替走子，总不可能一直走下去，需要判断对局结果。我们可以把结果分成三种，第一种是玩家赢，第二种是电脑赢，第三种是平局。判断玩家赢和电脑赢的逻辑可以说完全相同，当一方的棋子连成三个则获胜，我们可以用以下函数实现
首先判断赢，分成三种情况，第一种为一行连成三子，那么在相同的行数上，即图中i相等的情况，判断同一行上第一列的元素等于第二列的元素，第二列的元素等于第三列的元素，且均为玩家棋子('X')那么判断玩家胜利，同理，第二、三种情况分别是一列连成三子和对角线连成三子，判断方法基本相同。而电脑胜利的判断方法和玩家胜利相同，可以看到图中函数的参数中有一个字符参数，这是用来区分玩家和电脑的，若传入的字符为'X'则该函数判断玩家是否获胜，若传入的字符为'O'则该函数判断电脑是否获胜。
接下来是判断平局，我们知道，当三子棋九个格子全部下满时，若还无人获胜，则判断为平局，要实现这个逻辑就很简单了，我们只需要定义一个变量，每次玩家或电脑下完棋后让这个变量的值加一，当这个变量值等于9时，判断为平局
如图， 创建变量turn，指针变量p指向turn，把指针p传给player_move函数，当玩家成功落子后，令*p的值加一即可。
4.游戏内容拼接 主要的游戏功能已经分装完成，那么接下来我们就要把这些功能组合起来编成一个完整的游戏了。这里我分享我的实现方法，方法不唯一，还有更高效、更简洁的实现方式欢迎在评论区讨论
首先，进入游戏后，我们初始化并打印棋盘，此时打印出来的为空棋盘
接着用循环结构让玩家和电脑的走子步骤重复发生，首先进入player_move函数玩家走子，然后判断judge函数的返回值(注意，这里的judge函数为整型函数，可回判断结果步骤查看返回值)，若为1则判断玩家胜利并跳出循环，若为0则执行后方语句。接下来判断是否平局，这里先判断平局是因为三子棋的第九颗棋子一定是由先手方下，在这里就是玩家下出第九颗棋，所以在palyer_move函数结束后直接判断是否胜利，平局。若将平局判断放至电脑走子后，则会出现电脑无法找到地方落子而导致程序无限循环，无法结束。判断完非平局后，则轮到电脑走子，并判断电脑是否获胜。若游戏未结束，则打印新棋盘(玩家和电脑走子后的棋盘)，进入下一轮走子。
至此，三子棋的主要结构就已经编译完成了，快去试试看吧!
三、界面优化 作为一个游戏，界面优化必不可少，良好的界面可以提高玩家的游戏体验。我们制作的三子棋当然也可以做界面优化。
1. 棋盘界面 棋盘为游戏的主要界面，当然需要美化，首先就是我在print_board函数中所写的|和---，用于分割棋盘，让棋盘看起来更加简洁、工整。另外就是一些外包装和文字修饰之类的，我这里做了一点简单的优化，来看看效果吧
2.文字提示和过场停顿 在游戏菜单界面和棋盘界面，我们可以加入以下文字提示，以提示玩家进行操作 当游戏结束时，我们可以做一个过场停顿，将棋盘展示出来，等玩家下达指令后再返回菜单
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f3d4704a4cfb4e84f1580907723ccac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a164be2e9d7e70f546ee641cb0c90ad/" rel="bookmark">
			Linux基础学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LInux学习 文章目录 LInux学习1. Linux快捷键2. Shell基本命令”*“，”？“，”[]“：通配符pwd：显示当前目录cd：改变目录ls：列出目录内容cat和more：查看文本文件catmore head和tail：阅读文件的开头和结尾grep：查找文件内容find：查找文件locate：更快速地定位文件whereis：查找特定的程序用户版本信息查看whowhoamiuname man：寻求帮助whatis和aproposwhatisapropos 3. 文件目录管理Linux文件系统的架构文件或目录颜色的一般情况mkdir：建立目录touch：建立一个空文件mv：移动和重命名cp：复制文件和目录rmdir和rm：删除目录和文件 4. 软件包管理简述dpkg：管理.deb软件包rpm：管理RPM软件包APT：高级软件包工具下载和安装软件包查询软件包 5. Internet上的LInux资源 1. Linux快捷键 date：显示当前的时间
history：显示历史打过的命令
ctrl+p：向上调用历史命令
ctrl+n：向下调用历史命令
ctrl+b：光标向左移动
ctrl+f：光标向右移动
ctrl+a：光标迅速移动到当前行的头部
ctrl+e：光标移动到行尾
Linux系统中的光标很宽，会盖住一个字符，这个字符前面的字符表示光标前面的字符，被光标盖住的字符称为光标后面的字符。
ctrl+h：删除光标前面的字符
ctrl+d：删除光标后面的字符（被光标覆盖的字符）
ctrl+u：删除光标前面所有的字符
ctrl+l：清除屏幕（相当于clear）
2. Shell基本命令 Shell即命令解释器，从本质上讲，Shell是一个程序，它在用户和操作系统之间提供了一个面向行的可交互接口。用户在命令行中输入命令，运行在后台的Shell吧命令转换成指令代码发送给操作系统。
常用的Shell有Bourne Again Shell（BASH）、TCSH Shell、Z-Shell等。
以下命令均为BASH。
xal1@xal1-virtual-machine:~$
xal1：表示用户名@：表示在xal1-virtual-machine：表示在设置虚拟机的时候设置的主机名~：表示用户主目录。用户主目录是/home下的一个子目录，而不是home目录。 xal1@xal1-virtual-machine:~$ pwd /home/xal1 $：表示命令提示符，也表示当前用户为普通用户。如果提示符为#，则表示当前用户为root用户。 ###Tab键：命令补全
1.按一次Tab键：在输入文件名的时候，只需要输入开头几个字符，然后按下Tab键，Shell就会自动把文件名自动补全。
2.按两次Tab键：如果以已键入字符开头的文件不止一个，那么可以连续按两次Tab，Shell会以列表形式给出所有以键入字符开头的文件。
”*“，”？“，”[]“：通配符 “*”：用于匹配文件名中任意长度长度的字符串。
## *.py 即可以列出当前目录下所有的py文件 root@xal1-virtual-machine:/bin# ls *.py mesa-overlay-control.py ”？“：类似于”*“通配符，但是它只匹配一个字符。
## test? 用于匹配文件名以test开头而后跟一个字符的文件 xal1@xal1-virtual-machine:~/study$ ls test? test1 test2 test3 testA testB testC ”[]“：用于匹配所有出现在方括号内的字符。
也可使用短线”-“来指定一个范围，所有包含在上下界之间的字符都会被匹配，数字和字母都可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a164be2e9d7e70f546ee641cb0c90ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7fa4afcbfa642845ae521e414dee2e3/" rel="bookmark">
			桥接模式、NAT模式和仅主机模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、虚拟机的网络
二、桥接模式、NAT模式、仅主机模式
1、bridged（桥接模式）
2、NAT（网络地址转换模式）
3、host-only（仅主机模式）
三、使用 DHCP 自动分配地址
在 VMware 中，虚拟机的网络连接主要是由 VMware 创建的虚拟交换机（也叫做虚拟网络）负责实现的，VMware 可以根据需要创建多个虚拟网络。
在 Windows 系统的主机上，VMware 最多可以创建 20 个虚拟网络，每个虚拟网络可以连接任意数量的虚拟机网络设备；在 Linux 系统的主机上，VMware 最多可以创建 255 个虚拟网络，但每个虚拟网络仅能连接 32个 虚拟机网络设备。VMware 的虚拟网络都是以 "VMnet+数字" 的形式来命名的，例如 VMnet0、VMnet1、VMnet2……以此类推（在 Linux 系统的主机上，虚拟网络的名称均采用小写形式，例如 vmnet0 )。
当我们安装 VMware 时，VMware 会自动为 3 种网络连接模式各自创建 1 个虚拟机网络：VMnet0 (桥接模式)、VMnet8 (NAT模式)、VMnet1 (仅主机模式)。此外，我们也可以根据需要自行创建更多的虚拟网络。
一、虚拟机的网络 虚拟机上的网络连接图示：
虚拟机上创建的两个网段 VMnet1 和 VMnet2 在物理机上对应的网卡的位置，如图：
我们在虚拟机上配置的网段，网卡会默认使用该网段的第一个 IP 地址作为此网卡的 IP 地址。
二、桥接模式、NAT模式、仅主机模式 1、bridged（桥接模式） VMware 桥接模式，也就是将虚拟机的虚拟网络适配器与主机的物理网络适配器进行交接，虚拟机中的虚拟网络适配器可通过主机中的物理网络适配器直接访问到外部网络。简而言之，这就好像在局域网中添加了一台新的、独立的计算机一样。因此，虚拟机也会占用局域网中的一个 IP 地址，并且可以和其他终端进行相互访问。
桥接模式网络连接支持有线和无线主机网络适配器。如果你想把虚拟机当做一台完全独立的计算机看待，并且允许它和其他终端一样的进行网络通信，那么桥接模式通常是虚拟机访问网络的最简单途径。
桥接模式配置示例
桥接模式，虚拟机网段必须和物理机网段保持一致，另外虚拟机在网络配置的时候，一定不要忘了加入对应 VMnet
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7fa4afcbfa642845ae521e414dee2e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1083ad4a6342c366757c1f30653c78aa/" rel="bookmark">
			linux命令之hdparm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、介绍
二、常用命令
1.用法
2.选项
3.用法举例
3.1显示硬盘相关信息
3.2测试硬盘读取速度
3.3测试硬盘缓存读取速度
3.4查看电源管理模式
总结
一、介绍 hdparm是linux下用来浏览和修改IDE驱动器参数的shell工具，hdparm也就是hard disk parameters，用于显示与设定硬盘的参数。该命令用来获取或设置SATA/IDE设备的参数。
二、常用命令 1.用法 hdparm - get/set hard disk parameters - version v9.48, by Mark Lord.
Usage: hdparm [options] [device ...]
2.选项 Options:
-a Get/set fs readahead
-A Get/set the drive look-ahead flag (0/1)
-b Get/set bus state (0 == off, 1 == on, 2 == tristate)
-B Set Advanced Power Management setting (1-255)
-c Get/set IDE 32-bit IO setting
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1083ad4a6342c366757c1f30653c78aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5fc512762f614ab974a82e5b974b78d/" rel="bookmark">
			vue中tinymce的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载
npm i tinymce@5.10.3 @tinymce/tinymce-vue@3.2.8 -S 2.在node_modules中找到
（我这里是vue2，vue3不是写在public下，具体的可以搜搜 看看）
3.在public中新建 tinymce 文件夹
把三个文件复制进去
4.在components文件夹中新建tinymce.vue
&lt;template&gt; &lt;div class="tinymce-editor"&gt; &lt;editor v-model="myValue" :init="init" :api-key="apiKey" :disabled="disabled" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // import { fileUpload } from '@/api/cms' import tinymce from "tinymce/tinymce"; import Editor from "@tinymce/tinymce-vue"; // import 'tinymce/themes/modern/theme' import "tinymce/themes/silver/theme"; import "tinymce/icons/default/icons"; import "tinymce/plugins/image"; // 插入上传图片插件 import "tinymce/plugins/media"; // 插入视频插件 import "tinymce/plugins/table"; // 插入表格插件 import "tinymce/plugins/link"; // 超链接插件 import "tinymce/plugins/code"; // 代码块插件 import "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5fc512762f614ab974a82e5b974b78d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382687b83e91511bac09ed6f3e2eb3ee/" rel="bookmark">
			YOLOv5（v6.1）学习历险记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个记录自己学习的心酸博客，第一次写博客也不知道要注意什么，反正是给我自己看的，就碎碎念吧。这个主要是记录一下自己学习内容，以及从一个纯小白的角度去理解学习。不求高端有操作，但求通俗易懂。哎导师放养的后果就是万事CSDN、知乎、B站。这三位才是我的学术导师！
先来个最最基础的学习！yolov5的配置文件！以yolov5s.yaml为例！
！在这里要注意这俩个参数的使用！因为在接下来的backbone和head里面计算通道数和个数会用到！真的让人十分头痛！
这里主要就是定义了三个尺寸的anchor（锚框），分别对应大、中、小目标进行计算。
第一行在最大的特征图上--小数值检测大目标；
第二行在第二大的特征图上--中数值检测中目标；
第三行在最小的特征图上--大数值检测小目标
yolov5还加入了autoanchor计算，当他觉得你数据集不符合这个规定的锚框人家会自己重新计算~
backbone用来干嘛的呢：特征提取！人家还继承了Yolov4的CSP思想，对于CSP我通俗的理解啊（不一定对）就是分流。一部分继续原操作，另一部分呢直接与该阶段尾部concat拼接相连，从而既能保证该模块特征复用，又能截断梯度流，避免大量重复运算（类似与resnet的残差思想，就你给人家分开成俩部分一部分啥也不做，另一部分继续原来工作即可）
好的！下面最难的（我认为的）开始了！我把参数意思看懂了咋还对不上嘞！反正我是十分困惑
对于我们第0层来说，[[-1,1,Conv,[64,6,2,2]]我们主要看args部分参数，它会被程序解析为[3,32,6,2,2]---为啥多个3呢，这边会增加个输入通道，因为输入的图像是彩色RGB3通道的所以输入为3.那输出咋又从64--32呢！因为输出通道（卷积核数量）要乘以width_multiple即64*0.5=32。6表示kernel卷积核的大小，2表示stride是卷积核的步长。其他没写的参数就默认为1，有的会省略卷积核大小步长之类的就代表为1！
那同理，对于我们第一层来说，输入来自第0层的输出，那么就会解析成[32,64,3,2]
yolov5没有区分neck和head都写在一个head里。其实人家neck部分用的是FPN+PAN结构，啥是FPN呢：自底向上，反正就是从下往上把backbone提取的特征信息整合，PAN呢就是自顶向下，反正就是一个从下往上一个再从上往下，术语叫做多尺度特征融合（咋也不懂反正行就完事）
那这里基本和backbone计算规则一样，那么Concat主要是个Concat操作（拼接通道数相加），那么在from那里[-1,6]就代表上一层和第六层相连接（注意人家是从第0层开始的），args参数里的None就代表默认值，Upsample代表上采样，'nearest'代表采样方式~
[[17,20,23],1,Detect,[nc,anchors]],代表指定第17层，20层，23层为输出~接到Head检测头去!
那么整体的网络配置文件就over了！后续相对yolov5进行修改一个重要的修改内容就是对yaml文件的修改，跟搭积木一样，通过调用不同的模块去对应不同的结构！PS：祝我研究生顺利毕业！！最后放一张yolov5s的网络结构图！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c581c3eacfa478bc0a5bd50e96cc7aab/" rel="bookmark">
			如何学好编程？黄金四步走
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于编程学习的最佳方法就是：重复地阅读代码和编写代码（读&gt;写代码&gt;读&gt;写代码），阅读书籍、博客文章、开源代码，了解语言或系统，自己实际去写代码。
下面分为四步走给大家说下！
第一步：观摩学习，找到方法 编程学习需要很多的知识，不同的语言还有不同的语法，不同的应用环境。学习编程的第一步，就是我们各种编程的基础知识，这里还包括数据结构、基础语法，网络知识概念等。然后通过别人写的例子进行更好地学习，快速理解各种语法规则等。
例如：每一种编程语言都包含内功（算法、数据结构）和招式（变量、条件判断、循环、函数、模块、文件、并发）这些招数不管你学C还是Java，C++都是会有的，只是语法不一样而已。
第二步：多敲代码，尝试项目 “学习编程的唯一方式就是编程”。编程学习往往需要大量实践，理论再好不动手也是不行的，从第一个“Hello word”开始。从看别人的代码、模仿别人的代码，再到写出自己的代码，这都需要经过大量的练习。
一开始你可能知识写一个函数，再后来就是写一个小程序，再者就是参与小项目开发了，很多项目都是具有相似性的，经过不断地练习之后，可能不到半年你的实战经验就足以丰富到尝试大项目了。
第三步：构建项目，系统学习 通过项目实践，找到完成增项目的整体思维，培养大局观意识，把知识系统地链接起来。遇到问题及时记录下来，然后针对性地区学习相关的知识，如此循环，通过一个知识点然后不断地向外延伸，这样的学习更加高效实用。
例如，你正在做某个项目，需要用到B，而学B的时候，发现又要去学C才能更好地理解，C当中又包含D，这样一步步去推导学习，性价比更高，更节省时间，效果也更好。
第四步：费曼学习法，强制输出 简单来说就是以教促学，每当你认为学会或者掌握一个知识后，去给别人讲明白，通过这种方式对自己做一个检验。
以此作为参考，编程的学习也可以分为三个环节：
1、学：就是学习模仿优秀的项目，阅读优秀的源码2、练：就是练习，找 demo、小型项目、开源项目，大量重复的敲代 码3、教：就是教练，通过写教程或者视频的方式给其他人讲明白一个项目 1、2 两点属于被动学习，吸收效率在 10% 至 30% 之间，而 3 属于主动学习，也就是费曼学习，吸收效率高达 90% 。
也就是大家可以通过强制输出带动输入，为了提高学习效率，可以主动地分享和教其他人，在这个过程中也是对自己学到内容的一种复习和检验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0b3a07fa55cb74f093e00f7f740083/" rel="bookmark">
			xrandr命令用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.常用命令 2.获取其他用法
3.参数选择
1.常用命令 xrandr 作用：显示当前显示器可以支持的分辨率
xrandr -q 也可以使用 -q 参数来查看屏幕目前支持的分辨率
root@ubuntu:/home/samba# xrandr Screen 0: minimum 1 x 1, current 840 x 674, maximum 8192 x 8192 Virtual1 connected primary 840x674+0+0 (normal left inverted right x axis y axis) 0mm x 0mm 840x674 60.00*+ 2560x1600 59.99 1920x1440 60.00 1856x1392 60.00 1792x1344 60.00 1920x1200 59.88 1600x1200 60.00 1680x1050 59.95 1400x1050 59.98 1280x1024 60.02 1440x900 59.89 1280x960 60.00 1360x768 60.02 1280x800 59.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f0b3a07fa55cb74f093e00f7f740083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f49d807f0c09f19f8172359f2ce4597d/" rel="bookmark">
			分布式事物-- MySQL XA 协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 从5.0.3开始支持XA分布式事务，且只有InnoDB存储引擎支持。MySQL Connector/J 从5.0.0版本之后开始直接提供对XA的支持。
分布式事物XA协议规范：
AP：应用程序，AP定义事务边界（定义事务开始和结束）并访问事务边界内的资源
RM：资源管理器，管理计算机共享的资源，许多软件都可以去访问这些资源，资源包含比如数据库、文件系统、打印机服务器等。
TM：事物管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。
Xa主要规定了RM与TM之间的交互，下面来看下XA规范中定义的RM 和 TM交互的接口：
xa_start负责开启或者恢复一个事务分支，并且管理XID到调用线程
xa_end 负责取消当前线程与事务分支的关联
xa_prepare负责询问RM 是否准备好了提交事务分支
xa_commit通知RM提交事务分支
xa_rollback 通知RM回滚事务分支
XA协议是使用了二阶段协议的，其中：
第一阶段TM要求所有的RM准备提交对应的事务分支，询问RM是否有能力保证成功的提交事务分支，RM根据自己的情况，如果判断自己进行的工作可以被提交，那就就对工作内容进行持久化，并给TM回执OK；否者给TM的回执NO。RM在发送了否定答复并回滚了已经的工作后，就可以丢弃这个事务分支信息了。
第二阶段TM根据阶段1各个RM prepare的结果，决定是提交还是回滚事务。如果所有的RM都prepare成功，那么TM通知所有的RM进行提交；如果有RM prepare回执NO的话，则TM通知所有RM回滚自己的事务分支。
XA协议二阶段提交的一个流程示意图：
也就是TM与RM之间是通过两阶段提交协议进行交互的。
内部XA事务 MySQL本身的插件式架构导致在其内部需要使用XA事务，此时MySQL即是协调者，也是参与者。例如，不同的存储引擎之间是完全独立的，因此当一个事务涉及两个不同的存储引擎时，就必须使用内部XA事务。需要特别注意的是，如果将二进制日志看做一个独立的“存储引擎”,就不难理解为什么即使是一个存储引擎参与的事务也需要使用XA事务了。在向存储引擎提交数据时，同时需要将提交的信息写入二进制日志，这就是一个分布式事务。
外部XA事务
1、分析：
MySQL数据库外部XA可以用在分布式数据库代理层，实现对MySQL数据库的分布式事务支持，例如开源的代理工具：ameoba[4]，网易的DDB，淘宝的TDDL，B2B的Cobar等等。
通过MySQL数据库外部XA，这些工具可以提供跨库的分布式事务。当然，这些工具也就成了外部XA事务的协调者角色。在crash recover时控制悬挂事务是全局commit，或者rollback。
在crash recover之后，外部应用程序可能会遇到以下几种情况：
情况一：分布式事务对应的MySQL数据库实例，部分完成prepare，部分未完成prepare。此时直接回滚完成prepare的实例即可。n_prepared &lt; Total Nodes (处于prepare状态的节点数量要小于参与分布式事务的所有节点总数)。
情况二：分布式事务对应的MySQL实例，全部完成prepare，未开始进行commit。此时即可提交此事务，也可回滚此事务(根据分布式事务原理，所有节点都完成prepare，应该提交)。n_prepared = Total Nodes。
情况三：分布式事务对应的MySQL实例，全部完成prepare，并且部分节点已经完成commit。此时应该提交该事务处于prepare状态的节点。n_prepared &lt; Total Nodes。对比情况三与情况一，仅仅通过prepare节点的数量无法区分，因此应用程序需要在prepare完成之后记录日志(此时，应用程序起着事务协调者(Transcaction Coordinator)的角色，而根据MariaDB WorkLog#132[5]的说法，TC角色是可以进行”middle engine”优化的，不需要prepare过程，所有MySQL节点xa prepare返回之后，应用程序直接写commit标识即可，然后再对每个MySQL节点进行xa commit操作。)，从而用于区分情况一与情况三。
情况四：分布式事务对应的MySQL实例，全部完成commit。此时事务已经提交成功，xid不会出现在执行xa recover的任一个节点。不需要特殊处理。
情况五：未记录任何prepare日志。那么所有的事务，在各个存储引擎的crash recover时，都会被回滚，不需要外部特殊处理。
2、不足
通过前面的分析，可知应用程序配合MySQL的XA事务功能，能够较好的支持分布式环境下的事务。但是，这个支持并不完美，根据我的分析，有可能会出现以下几个问题：
问题一：主备数据库的数据不一致。
MySQL数据库的主备数据库的同步，通过Binlog的复制完成。而Binlog是MySQL数据库内部XA事务的协调者，并且MySQL数据库为binlog做了优化——binlog不写prepare日志，只写commit日志。
考虑前面提到的情况二，所有的参与节点prepare完成，在进行xa commit前crash。crash recover如果选择commit此事务。由于binlog在prepare阶段未写，因此主库中看来，此分布式事务最终提交了，但是此事务的操作并未写到binlog中，因此也就未能成功复制到备库，从而导致主备库数据不一致的情况出现。
在MySQL 5.5.16版本中做过测试，这个问题实际存在。crash recover之后，对xa recover返回的事务运行xa commit，对应事务提交，但是操作并未写入binlog，因此无法复制到备库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f49d807f0c09f19f8172359f2ce4597d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b68efb48badf961b69bba2198492277/" rel="bookmark">
			【UE5】虚幻项目浏览器，固定加载上次打开的项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚幻项目浏览器，固定加载上次打开的项目 选择关卡，点击【文件】
选择【打开项目】
取消勾选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf47a5ea91536ff40e12bc46999bb44/" rel="bookmark">
			银河麒麟下安装sshd服务（联网）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、sshd是什么？
二、使用步骤
1.检查 ssh 进程是否存在
2.安装客户端
3.安装服务端
4.重启
5. 修改端口
6.设置服务状态命令
总结
前言 银河麒麟下配置sshd服务方法。（需要联网）
一、sshd是什么？ Linux中的sshd服务，主要用于pst终端，远程连接到linux服务中。
二、使用步骤 1.检查 ssh 进程是否存在 ps -e|grep ssh ps ：显示进程信息
| ：管道符，表示ps 和 grep 命令同时执行
grep ：查找
-e : 显示所有进程 2.安装客户端 sudo apt-get install openssh-client=1:8.2p1-4kylin2k1 3.安装服务端 sudo apt-get install openssh-server 4.重启 reboot 重启后一般sshd服务就配置好了。
5. 修改端口 sshd的默认是端口是22 ，可以通过修改 /etc/ssh/sshd_config文件，修改默认端口
改Port 后的数字为需要的端口，然后去掉#号即可 6.设置服务状态命令 查看服务状态： systemctl status sshd 打开服务: systemctl start sshd 关闭服务:systemctl stop sshd 重新开启服务:systemctl restart sshd 设定开机启动:systemctl enable sshd 设定开机不启动：systemctl disable sshd 重新加载配置文件：systemctl reload sshd 列出已开启服务的当前状态：systemctl list-units 总结 实现银河麒麟下安装sshd，实现用sftp传输文件到kylin系统下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7fdd2389800e71646ba08a58d4528c/" rel="bookmark">
			【Git】报错处理：fatal: detected dubious ownership in repository at .....Set the environment variable GIT_T
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Git】报错处理：fatal: detected dubious ownership in repository at ..... 异常信息解决 异常信息 Windows PowerShell 版权所有 (C) Microsoft Corporation。保留所有权利。 尝试新的跨平台 PowerShell https://aka.ms/pscore6 PS C:\Users\Administrator\Desktop\she_qu_tuan_gou\_work\drivers&gt; PS C:\Users\Administrator\Desktop\she_qu_tuan_gou\_work\drivers&gt; PS C:\Users\Administrator\Desktop\she_qu_tuan_gou\_work\drivers&gt; git pull fatal: detected dubious ownership in repository at 'C:/Users/Administrator/Desktop/she_qu_tuan_gou/_work/drivers' To add an exception for this directory, call: git config --global --add safe.directory C:/Users/Administrator/Desktop/she_qu_tuan_gou/_work/drivers Set the environment variable GIT_TEST_DEBUG_UNSAFE_DIRECTORIES=true and run again for more information. PS C:\Users\Administrator\Desktop\she_qu_tuan_gou\_work\drivers&gt; PS C:\Users\Administrator\Desktop\she_qu_tuan_gou\_work\drivers&gt; PS C:\Users\Administrator\Desktop\she_qu_tuan_gou\_work\drivers&gt; git config --global --add safe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7fdd2389800e71646ba08a58d4528c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4d79fcbc42aa70037145eafe3d93e8/" rel="bookmark">
			java家庭理财收支管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1 绪论 1
1.1 引言 1
1.2 研究内容 2
1.3 可行性分析 2
1.3.1 技术可行性 2
1.3.2 经济可行性 2
1.3.3 操作可行性 3
1.4 研究现状 3
2 开发技术介绍 4
2.1 Jsp技术 4
2.2 Mysql 5
2.3 tomcat简介 5
2.4 JDBC 6
3 需求分析 7
3.1 用户需求 7
3.2 功能需求 8
3.3 系统对软硬件要求 8
3.4 开发技术 9
4 概要设计 9
4.1 流程设计 9
4.2 数据库设计 12
4.2.1 数据项设计 12
4.2.2 数据表设计 12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4d79fcbc42aa70037145eafe3d93e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c06e5c295d082cf5198b6776231cdb/" rel="bookmark">
			前端学习——css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内部样式、外部样式、行内样式 1.link和import的区别： 2.样式表的优先级 行内式&gt;内部式&gt;外部式 但是注意，在属性后面加上“!important”时，该属性的优先级最高。 优先级只适用于同一个属性类型，不同属性类型则保留下来。 3.标签选择器 1.元素选择符/类型选择符（element选择器） 如：div{width:100px;……} 2.class选择器/类选择器 语法：.class{属性:属性值;} 注意：同一个标签可以使用多个class类属性值；使用多个类选择器时遵循就近原则（在样式文件中的“近”，最近定义的） 3.id选择器 唯一选择 语法：#id名{属性:属性值;} 4.通配符选择器 语法：*{属性:属性值;} 作用于所有元素 5.群组选择器 语法：选择符1，选择符2，选择符3…… 如：#top1,#nav1,h1{width:100px;} 当几个选择器控制的元素需要的样式一样时使用，节约代码量 6.后代（包含）选择器 语法：选择符1 选择符2 选择符3…… 选择符1&gt;选择符2：一代子元素选择器，只选择亲儿子元素 7.伪类选择器 只是对超链接起作用 语法：a:link{属性:属性值;}超链接的初始状态 a:visited{属性:属性值;}超链接被访问后的状态 a:hover{属性:属性值;}鼠标悬停，即鼠标滑过超链接时的状态 a:active{属性:属性值;}超链接被激活时的状态，即鼠标按下时超链接的状态 4.选择器的权重 !important&gt;内联样式&gt;包含选择符&gt;id选择器&gt;类选择器&gt;元素选择器 5.css文本属性 1.font-size 字体大小 浏览器默认16px，设计图常用字号是12px 2.font-family 字体 当字体是中文字体、英文字体中有空格时，需加引号；多个字体中间用逗号链接，先解析第一个字体，如果没有解析第二个字体，以此类推 3.color 颜色 red；rgb(255,255,255)；#ffffff 4.font-weight 加粗 bolder（更粗的）/bold（加粗）/normal（常规）/lighter（细体）；font-weight:100~900;100~500不加粗，600~900加粗 (100细体；400正常；700粗体；900更粗体) 5.font-style 倾斜 italic（斜体字）/oblique（倾斜的文字）/normal（常规显示） 6.text-align 文本水平对齐 left/right/center/justify（水平两端对齐，但是只对多行起作用） 7.line-height 行高 line-height=height时，可以实现单行文本垂直居中 8.text-indent 首行缩进 可以取负值；只对第一行起作用 首行缩进2字符：2em 9.letter-spacing 字间距；word-spacing 词间距 10.text-decoration 文本修饰 none（没有）/underline（下划线）/overline（上划线）/line-through（删除线） 11.font 文字简写 将多个属性写到这一个中 注意：顺序为font-style font-weight font-size/line-height font-family;其中，前两个可以省略不写，但是后面的必须要写！！ 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c06e5c295d082cf5198b6776231cdb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/115/">«</a>
	<span class="pagination__item pagination__item--current">116/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/117/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>