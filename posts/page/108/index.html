<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735eed76e07d3bd2e1ff52266fbd5e30/" rel="bookmark">
			Set集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Set集合 Set集合与Collection基本上完全一样，它没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。
Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add方法返回false，且新元素不会被加入。
Set判断两个对象相同不是使用==运算符，而是根据equals方法。
public class SetTest { public static void main(String[] args) { Set books = new HashSet(); //添加一个字符串对象 books.add(new String("疯狂Java讲义")); //再次添加一个字符串对象 //因为两个字符串对象通过equals方法比较相等 //所以添加失败，返回false boolean result = books.add(new String("疯狂Java讲义")); //从下面输出看到集合只有一个元素 System.out.println(result + "——&gt;" + books); } } false——&gt;[疯狂Java讲义] HashSet类 HashSet是Set接口的典型实现，大多数时候使用Set集合就是使用这个实现类。HashSet按Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。
HashSet具有以下特点
不能保证元素的排列顺序，顺序有可能发生变化HashSet不是同步的，如果多个线程同时访问一个HashSet，假设有两个或者两个线程同时修改了HashSet集合时，则必须通过代码来保证其同步集合元素值可以是null 当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该hashCode值决定该对象在HashSet中的存储位置。如果有两个元素通过equals()方法比较返回true，但它们的hashCode()方法返回值不相等，HashSet将会把它们存储在不同的位置，依然可以添加成功。
也就是说HashSet添加元素能否添加成功取决于该元素的hashCode()方法和equals()方法
简单地说，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法返回值也相等。
public class HashSetTest { public static void main(String[] args) { Set books = new HashSet(); //分别向books集合中添加两个A对象、两个B对象、两个C对象 books.add(new A()); books.add(new A()); books.add(new B()); books.add(new B()); books.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/735eed76e07d3bd2e1ff52266fbd5e30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe487abf1744d677b02cc7437fe9977b/" rel="bookmark">
			VS配置永久OpenGL环境------GLUT、GLFW
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、论述
二、GLUT---NuGet程序包下载教程（不永久）
三、GFLW包配置（永久）
四、总结
一、论述 由于最近又突发奇想想要学习OpenGL的课程，然后呢，在配置GLFW环境的时候浪费了一点时间，于是准备分享一下配置教程，实力不够，也只能做到这些，一般情况，如果你想要学习利用VS学习OpenGL仅仅需要在NuGet程序包里面下载，是一种很简单的方法，后面会说明，还有就是下载GLFW包，目前就了解这两种方法。安装你想要学习的思路来。
二、GLUT---NuGet程序包下载教程（不永久） 这个只是之前学习的时候注意到的
第一步:找到你创建文件的项目目录，并且点击管理NuGet程序包
第二步：在选择浏览，在搜索框输入nupengl，选择第一个，然后点击安装
第三部：测试代码 输入一下代码没有报错并且能运行就可以了
#include &lt;gl/glut.h&gt; #include &lt;iostream&gt; using namespace std; void renderPreFrame(); int main(int argc, char** argv) { glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); glutInitWindowPosition(100, 100); glutInitWindowSize(400, 400); glutCreateWindow("First Window"); glutDisplayFunc(renderPreFrame); glClearColor(0.0f, 0.0f, 0.0f, 0.0f); glutMainLoop(); return 0; } void renderPreFrame() { glClear(GL_COLOR_BUFFER_BIT); glutSwapBuffers(); } 三、GFLW包配置（永久） 第一步：登录GLFW官网GLFW下载链接 这边建议下滑选择Windows--32位版本 vs就使用x86编译了
第二步：解压下载的安装包
第三步：复制include包和你vs所处版本的包，我的vs是2019所以选择的是2019版本
第四步：新建一个文件夹用于存储这个两个包（位置随意）
第五步：打开VS新建C++空项目——》选择视图——》其他窗口——》属性管理器
第六步：在属性窗口选择Debug|Win32右键添加新项目属性表
第七步：命名，并且选择位置，建议与第四步放在同一个文件夹里
第八步：在属性管理器窗口选择创建好的文件双击
第九步：分别编辑在VC++目录中的包含目录和库目录----包含目录是步骤四中的include文件位置，库目录是第四步中lib-2019文件的位置 选择好后记得点击确定
第十步：链接器——》输入——》附加依赖项输入一下命令 最后点击确定 就完成了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe487abf1744d677b02cc7437fe9977b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bcea00e66cd868d96d5c9c31539313e/" rel="bookmark">
			vue中string如何转为json对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue中string转为json对象的方法： Json字符串转换为json对象
1、使用eval
result = eval('(' + jsonstr + ')'); // jsonstr是json字符串 2、使用JSON.parse()
result = JSON.parse(jsonstr); // jsonstr是json字符串 eval和JSON.parse的区别： eval 是javascript支持的方式，不需要严格的json格式的数据也可以转化
JSON.parse 是浏览器支持的转换方式，必须要标准的json格式才可以转换
举例：
res.data.details:"{\"charge_account\":\"加油卡卡号\",\"right_des\":\"加油卡直充充值说明产品使用说明：①充值方式：购买时输入需要充值的加油卡卡号，付款成功后，1-10分钟自动充值到账，个别情况下会有延迟，请耐心等待；\",\"right_addr\":\"\",\"notice\":\"温馨提示：充值前请您仔细核对充值卡号和金额，充值成功到账的，平台无法返销或退款，号码输入错误造成的损失由用户自行承担。注意事项：①本产品为加油卡充值，需要客户持有加油卡，没有加油卡请勿兑换哦！②本产品支持IC卡充值。只能为加油卡主卡充值，不能充值副卡。\"}" let result = eval(‘(’ + res.data.details + ‘)’);
result 值为：
{"charge_account":"加油卡卡号", "right_des":"加油卡直充充值说明产品使用说明：①充值方式：购买时输入需要充值的加油卡卡号，付款成功后，1-10分钟自动充值到账，个别情况下会有延迟，请耐心等待；", "right_addr":" "} this.goods_details = result.right_des;//商品内容介绍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc51b30d7c7ffd0826349568bb76eda9/" rel="bookmark">
			串口发送命令控制led灯的状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uart4.h
#ifndef __UART4_H__ #define __UART4_H__ #include "stm32mp1xx_rcc.h" #include "stm32mp1xx_gpio.h" #include "stm32mp1xx_uart.h" //uart4初始化 void hal_uart4_init(); //发送一个字符 void put_char(const char str); //发送一个字符串 void put_string(const char* string); //接收一个字符 char get_char(); //接收一个字符串 char* get_string(); #endif gpio.h
#ifndef __GPIO_H__ #define __GPIO_H__ //寄存器封装 typedef struct{ volatile unsigned int MODER; volatile unsigned int OTYPER; volatile unsigned int OSPEEDR; volatile unsigned int PUPDR; volatile unsigned int IDR; volatile unsigned int ODR; }gpio_t1; #define GPIOE1 ((gpio_t1*)0x50006000) #define GPIOF1 ((gpio_t1*)0x50007000) #define RCC_AHB4_ENSETR (*(volatile unsigned int*)0x50000A28) //封装引脚 #define GPIO_PIN_0 0 #define GPIO_PIN_1 1 #define GPIO_PIN_2 2 #define GPIO_PIN_3 3 #define GPIO_PIN_4 4 #define GPIO_PIN_5 5 #define GPIO_PIN_6 6 #define GPIO_PIN_7 7 #define GPIO_PIN_8 8 #define GPIO_PIN_9 9 #define GPIO_PIN_10 10 #define GPIO_PIN_11 11 #define GPIO_PIN_12 12 #define GPIO_PIN_13 13 #define GPIO_PIN_14 14 #define GPIO_PIN_15 15 //模式寄存器封装 typedef enum{ INPUT, OUTPUT, ALT, ANALOG }gpio_moder_t; //输出类型寄存器封装 typedef enum{ PP, OD }gpio_otyper_t; //输出速率寄存器封装 typedef enum{ LOW, MED, HIGH, VERY_HIGH }gpio_ospeedr_t; //是否需要上下拉电阻封装 typedef enum{ NO_PUPD, PU, PD }gpio_pupdr_t; //输出高低电平寄存器封装 typedef enum{ GPIO_RESET, GPIO_SET }gpio_status_t; //封装初始化结构体 typedef struct{ gpio_moder_t moder; //模式 gpio_otyper_t otyper; //输出类型 gpio_ospeedr_t speed;//速率 gpio_pupdr_t pupdr; //是否需要上下拉电阻 }gpio_init_t; //封装灯的种类 typedef enum { LED1, LED2, LED3 }leds; //函数功能：初始化GPIO //函数参数： //第一个参数：gpio组编号 //第二个参数：初始化gpio结构体 //第三个参数：引脚编号初始化 void hal_gpio_init(gpio_t1* gpiox,gpio_init_t* init,unsigned int pin); //函数功能：操作GPIO引脚,实现LED灯亮灭 //函数参数： //第一个参数：gpio组编号 //第二个参数：引脚编号初始化 //第三个参数：LED灯状态 void hal_gpio_write(gpio_t1* gpiox,unsigned int pin,gpio_status_t status); #endif uart4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc51b30d7c7ffd0826349568bb76eda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b34ff26d24ab7309709644146ad5a1/" rel="bookmark">
			End-to-End Object Detection with Transformers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考：端到端目标检测DETR
论文：DETR
代码：代码
目录
DETR
1.1 前言
1.1.1 研究动机：端到端目标检测的意义
1.1.2 简介
1.2 相关工作
1.3 算法
1.3.1 目标函数
1.3.2 模型结构
1.3.3 代码
1.4 实验
1.1 前言
1.1.1 研究动机：端到端目标检测的意义
DETR（DEtection TRansformer）是2020.5发布在Arxiv上的一篇论文，可以说是近年来目标检测领域的一个里程碑式的工作。从论文题目就可以看出，DETR其最大创新点有两个：end-to-end（端到端）和 引入Transformer。
目标检测任务，一直都是比图片分类复杂很多，因为需要预测出图片中物体的位置和类别。以往的主流的目标检测方法都不是端到端的目标检测，因为：会加入很多的先验知识，预先生成一些锚框。比如one-stage方法（YOLO系列）中的Anchor模板；two-stage（R-CNN系列）中的proposal。这些方法都不是直接预测物体，而是利用anchor/proposal去做近似，最后都会生成大大小小很多的预测框，必须在后处理时使用NMS去除这些冗余的框。
正是因为需要很多的人工干预、先验知识（Anchor）还有NMS，所以整个检测框架非常复杂，难调参难优化，并且部署困难（NMS需要的算子普通的库不一定支持，即不是所有硬件都支持）。所以说，一个端到端的目标检测是大家一直以来梦寐以求的。
1.1.2 简介
1.DETR如何做到end-to-end
DETR利用Transformer这种全局建模的能力，直接把目标检测视为集合预测问题（即给定一张图像，预测图像中感兴趣物体的集合）。然后使用可学习的object query替代了生成anchor的机制；使用了新的目标函数，并利用二分图匹配的方式，强制模型对每个物体只生成一个预测框，从而替代了NMS这一步。
DETR把之前不可学习的东西（anchor、NMS）变成可学的东西，删掉了这些依赖先验知识的部分，从而得到了一个简单有效的端到端的网络。所以DETR不需要费尽心思的设计anchor，不需要NMS后处理，也就没有那么多超参需要调，也不需要复杂的算子。
除了端到端这一点，DETR使用了 Transformer Encoder-Decoder 的架构。相比于原始的 Transformer，DETR是并行预测的（in parallel），即所有预测框是一起出框的。
2.简单架构
整个模型前向流程如上，训练分四个步骤：
（1）使用CNN网络提取图片特征
（2）全局建模：图片特征拉成一维，输入Transformer Encoder中进行全局建模，进一步通过自注意力学习全局特征。 之所以使用Transformer Encoder，是因为Transformer中的自注意力机制，使得图片中的每个点（特征）都能和图片中所有其他特征做交互了，这样模型就能大致知道哪块区域是一个物体，哪块区域又是另一个物体，从而能够尽量保证每个物体只出一个预测框。所以说这种全局特征非常有利于移除冗余的框。
（3）通过Transformer Decoder 生成N个预测框set of box prediction（默认取N=100，也就是一张图固定生成100个预测框）。
（4）计算二分图匹配损失（bipartite matching loss），选出最优预测框，然后计算最优框的损失。 计算N个预测框与所有GT box（真实框）的matching
loss，然后通过二分图匹配算法来选出与每个物体最匹配的预测框。比如上图中有两个物体，那么最后只有两个框和它们是最匹配的，归为前景；剩下98个都被标记为背景（no object）。最后和之前的目标检测算法一样，计算这两个框的分类损失和回归损失。
推理时，前三步是一样的。通过decoder生成N个预测框后，设置一个置信度阈值进行过滤，得到最终的预测框。（比如设阈值=0.7，表示只输出置信度大于0.7的预测框，剩下都当做背景框）。
总的来说，Transformer Encoder全局建模，用于区分物体；Transformer Decoder用于描绘物体边界，将物体位置补充的更完整。
3.性能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b34ff26d24ab7309709644146ad5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396eb12437420010f0db1689885d10ab/" rel="bookmark">
			Pytorch—模型微调（fine-tune）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着深度学习的发展，在大模型的训练上都是在一些较大数据集上进行训练的，比如Imagenet-1k，Imagenet-11k,甚至是ImageNet-21k等。但我们在实际应用中，我们自己的数据集可能比较小，只有几千张照片，这时从头训练具有几千万参数的大型神经网络是不现实的，因为越大的模型对数据量的要求越高，过拟合无法避免。
因为适用于ImageNet数据集的复杂模型，在一些小的数据集上可能会过拟合，同时因为数据量有限，最终训练得到的模型的精度也可能达不到实用要求。
解决上述问题的方法：
收集更多数据集，当然这对于研究成本会大大增加应用迁移学习（transfer learning）：从源数据集中学到知识迁移到目标数据集上。 1、模型微调（fine-tune） 微调(fine-tune)通过使用在大数据上得到的预训练好的模型来初始化自己的模型权重，从而提升精度。这就要求预训练模型质量要有保证。微调通常速度更快、精度更高。当然，自己训练好的模型也可以当做预训练模型，然后再在自己的数据集上进行训练，来使模型适用于自己的场景、自己的任务。
先引入迁移学习（Transfer Learning）的概念：
当我们训练好了一个模型之后，如果想应用到其他任务中，可以在这个模型的基础上进行训练，来作微调网络。这也是迁移学习的概念，可以节省训练的资源以及训练的时间。
迁移学习的一大应用场景就是模型微调，简单的来说就是把在别人训练好的基础上，换成自己的数据集继续训练，来调整参数。Pytorch中提供很多预训练模型，学习如何进行模型微调，可以大大提升自己任务的质量和速度。
假设我们要识别的图片类别是椅子，尽管ImageNet数据集中的大多数图像与椅子无关，但在ImageNet数据集上训练的模型可能会提取更通用的图像特征，这有助于识别边缘、纹理、形状和对象组合。 这些类似的特征对于识别椅子也可能同样有效。
为什么需要迁移学习：
1) 大数据与少标注的矛盾
虽然有大量的数据，但往往都是没有标注的，无法训练机器学习模型。人工进行数据标定太耗时。
2) 大数据与弱计算的矛盾
普通人无法拥有庞大的数据量与计算资源。因此需要借助于模型的迁移。
3) 普适化模型与个性化需求的矛盾
即使是在同一个任务上，一个模型也往往难以满足每个人的个性化需求，比如特定的隐私设置。这就需要在不同人之间做模型的适配。
4) 特定应用（如冷启动）的需求
迁移学习可以初步初始化网络，因为对一些比较类似的任务，其实模型参数的值基本上相同，而且这些参数经过大量的训练，已经有很好的特征提取能力，将backbone参数使用这类模型进行权重的初始化，后面做training的时候，模型收敛速度会更快。
负迁移问题：
​​​​​​​负迁移(Negative Transfer)指的是，在源域上学习到的知识，对于目标域上的学习产生负面作用。
产生负迁移的原因主要有：
1、数据问题：源域和目标域压根不相似，谈何迁移？
2、方法问题：源域和目标域是相似的，但是，迁移学习方法不够好，没找到可迁移的成分。
负迁移给迁移学习的研究和应用带来了负面影响。在实际应用中，找到合理的相似性，并且选择或开发合理的迁移学习方法，能够避免负迁移现象。
2.1、为什么要微调 因为预训练模型用了大量数据做训练，已经具备了提取浅层基础特征和深层抽象特征的能力。
对于图片来说，我们CNN的前几层学习到的都是低级的特征，比如，点、线、面，这些低级的特征对于任何图片来说都是可以抽象出来的，所以我们将他作为通用数据，只微调这些低级特征组合起来的高级特征即可，例如，这些点、线、面，组成的是园还是椭圆，还是正方形，这些代表的含义是我们需要后面训练出来的。
如果我们自己的数据不够多，泛化性不够强，那么可能存在模型不收敛，准确率低，模型泛化能力差，过拟合等问题，所以这时就需要使用预训练模型来做微调了。注意的是，进行微调时，应该使用较小的学习率。因为预训练模型的权重相对于随机初始化的权重来说已经很不错了，所以不希望使用太大的学习率来破坏原本的权重。通常用于微调的初始学习率会比从头开始训练的学习率小10倍。
总结：对于不同的层可以设置不同的学习率，一般情况下建议，对于使用的原始数据做初始化的层设置的学习率要小于（一般可设置小于10倍）初始化的学习率，这样保证对于已经初始化的数据不会扭曲的过快，而使用初始化学习率的新层可以快速的收敛。
2.2、需要微调的情况 其中微调的方法又要根据自身数据集和预训练模型数据集的相似程度，以及自己数据集的大小来抉择。
不同情况下的微调：
数据少，数据类似程度高：可以只修改最后几层或者最后一层进行微调。数据少，数据类似程度低：冻结预训练模型的前几层，训练剩余的层。因为数据集之间的相似度较低，所以根据自身的数据集对较高层进行重新训练会比较有效。数据多，数据类似程度高：这是最理想的情况。使用预训练的权重来初始化模型，然后重新训练整个模型。这也是最简单的微调方式，因为不涉及修改、冻结模型的层。数据多，数据类似程度低：微调的效果估计不好，可以考虑直接重新训练整个模型。如果你用的预训练模型的数据集是ImageNet，而你要做的是文字识别，那么预训练模型自然不会起到太大作用，因为它们的场景特征相差太大了。 注意：
如果自己的模型中有fc层，则新数据集的大小一定要与原始数据集相同，比如CNN中输入的图片大小一定要相同，才不会报错。如果包含fc层但是数据集大小不同的话，可以在最后的fc层之前添加卷积或者pool层，使得最后的输出与fc层一致，但这样会导致准确度大幅下降，所以不建议这样做 2.3、 模型微调的流程 微调的步骤有很多，看你自身数据和计算资源的情况而定。虽然各有不同，但是总体的流程大同小异。
步骤示例1：
1、在源数据集（如ImageNet数据集）上预训练一个神经网络模型，即源模型。
2、创建一个新的神经网络模型，即目标模型。它复制了源模型上除了输出层外的所有模型设计及其参数。
我们假设这些模型参数包含了源数据集上学习到的知识，且这些知识同样适用于目标数据集。我们还假设源模型的输出层跟源数据集的标签紧密相关，因此在目标模型中不予采用。 3、为目标模型添加一个输出大小为目标数据集类别个数的输出层，并随机初始化该层的模型参数。
4、在目标数据集（如椅子数据集）上训练目标模型。可以从头训练输出层，而其余层的参数都是基于源模型的参数微调得到的。
步骤示例2：
在已经训练好的网络上进行修改；冻结网络的原来那一部分；训练新添加的部分；解冻原来网络的部分层；联合训练解冻的层和新添加的部分。 2.4、参数冻结---指定训练模型的部分层 我们所提到的冻结模型、冻结部分层，其实归根结底都是对参数进行冻结。冻结训练可以加快训练速度。在这里，有两种方式：全程冻结与非全程冻结。
非全程冻结比全程冻结多了一个步骤：解冻，因此这里就讲解非全程冻结。看完非全程冻结之后，就明白全程冻结是如何进行的了。
非全程冻结训练分为两个阶段，分别是冻结阶段和解冻阶段。当处于冻结阶段时，被冻结的参数就不会被更新，在这个阶段，可以看做是全程冻结；而处于解冻阶段时，就和普通的训练一样了，所有参数都会被更新。
当进行冻结训练时，占用的显存较小，因为仅对部分网络进行微调。如果计算资源不够，也可以通过冻结训练的方式来减少训练时资源的占用。
因为一般需要保留Features Extractor的结构和参数，提出了两种训练方法：
固定预训练的参数：requires_grad = False 或者 lr = 0，即不更新参数；将Features Extractor部分设置很小的学习率，这里用到参数组（params_group）的概念，分组设置优化器的参数。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/396eb12437420010f0db1689885d10ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9981795da8a8af9e6f0eccbef040b53/" rel="bookmark">
			Keil C系列之编译器介绍（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Cx51编译器的介绍 C编程语言是一种通用编程语言，它提供了代码效率、结构化编程元素和丰富的操作符集。C语言不是一门很大的语言，也不是为任何特定的应用领域而设计的。C语言的通用性和它的无限制相结合，使得C语言方便而有效地解决了各种各样的软件任务。与其他更专业的语言相比，使用c语言可以更容易、更有效地解决许多应用程序。 Cx51优化C编译器是C语言美国国家标准协会(nSI)标准的完整实现。Cx51编译器不是一个适用于os目标的通用C编译器。它是一个基础实现，致力于为8051微处理器生成极其快速和紧凑的代码。Cx5编译器为您提供了C语言编程的灵活性以及汇编语言的代码效率和速度。c语言本身不能执行通常需要操作系统干预的操作(例如输入和输出)。相反，这些功能是作为标准库的一部分提供的。因为这些函数与语言本身是分离的，所以c特别适合于生成可在各种平台上移植的代码。由于Cx51编译器是一个交叉编译器，因此C编程语言和标准库的某些方面被修改或增强，以解决嵌入式目标处理器的特性。 1）如下为介绍C语言的书籍：
The C Programming Language, Second Edition
Kernighan &amp; Ritchie
Prentice-Hall, Inc.
ISBN 0-13-110370-9
C: A Reference Manual, Second Edition
Harbison &amp; Steel
Prentice-Hall Software Series
ISBN 0-13-109810-1
C and the 8051: Programming and Multitasking
Schultz
P T R Prentice-Hall, Inc.
ISBN 0-13-753815-4
2）编译器支持的8051单片机及其衍生的器件
8051系列是发展最快的微控制器架构之一。目前有超过500种来自各种芯片供应商的器件变体可供选择。新的扩展8051芯片，如Phlips ocsMx架构，专门用于具有几兆字节代码和数据空间的大型应用程序。为了对8051内核衍生产品提供最佳支持，Keil提供了几个开发工具，如下表所示。一种新的输出文件格式(**OMF2**)允许直接支持多达16M的代码和数据空间。Cx51编译器是C51的一个变体，这是为新的飞利浦80C51MX架构设计的编译器。 2 程序编译 本章将讨论编译器指令的使用和如何进行C 源码的编译。将分为三部分内容进行介绍： 1、指示Cx51编译器生成 listing file 2、控制对象文件中包含的信息量。 3、指定优化级别和内存模型。 1）环境设置
如果使用命令行运行编译器，需要先配置好环境变量才能正常使用，配置内容如下：
2）命令提示符格式
C51 sourcefile 〚directives...〛 C51 @commandfile 或者 CX51 sourcefile 〚directives.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9981795da8a8af9e6f0eccbef040b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4d652447a0f53d7731155bb19ee1e3/" rel="bookmark">
			u盘格式化后数据能恢复吗？当然可以，5步恢复U盘数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人都知道格式化U盘会清空里面的数据，虽然可以进行备份，但是一般我们都不会轻易格式化自己的U盘。但是遇到一些特殊情况，我们必须格式化U盘。u盘格式化后数据能恢复吗？当然可以。
只要你的原始数据没有被覆盖，没有被彻底删除，我们就可以通过下面的方法来帮助你恢复数据。一起来看看下面关于U盘格式化的原因，以及它的数据恢复过程。
一、U盘格式化的原因 有时U盘与电脑连接，为什么一打开u盘就让格式化？原因主要有以下4个方面：
原因1：U盘变为RAW格式、无法打开、提示格式化等。一些用户可能会根据系统提示格式化U盘；
原因2：U盘中病毒，通过格式化操作来清理病毒；
原因3：想要改变U盘的文件系统类型。比如，U盘的默认文件系统类型大多是FAT32，为了存储大于4GB的单个文件，则需要将FAT32转换为exFAT或NTFS类型；
原因4：在运行U盘的时候，误操作把U盘给格式化了。
二、U盘格式化后如何恢复数据 U盘格式化后，想要恢复里面的重要数据。移动u盘格式化后数据能恢复吗？可以的。我们可以通过专业的软件，或者专业人员来维修。但是，专业人员维修的费用一般是比较高的。
U盘数据恢复软件可以很好地代替人工，不仅支持恢复移动硬盘、硬盘、内存卡、虚拟磁盘等存储设备，在操作过程中不会对丢失的数据和设备造成任何损坏。这款软件可以免费扫描和预览，恢复的成功率高！
三、U盘格式化后数据恢复过程 遇到特殊情况，U盘格式化后数据怎么恢复？来看看下面5个操作步骤：
步骤1：在官方网站上下载软件的最新版本，安装并双击打开它。该软件提供免费试用版本，用户可以在不注册的情况下扫描并预览文件相关信息，找到要恢复的数据，再选择购买注册码激活软件。
步骤2：关闭注册页面后，先选择要扫描的文件类型，这里建议全选，可以让扫描的结果更加全面。然后选择U盘（U盘要提前插入电脑，连接好）。最后开始【扫描】。
步骤3：之后到了查看文件的步骤。在界面左侧找到按【类型】或者按【路径】来查看文件，根据你的需要来选择。在之后出现的各种文件类型，如果没有找到或者找齐数据，一定要点击界面上方的【深度扫描】。
步骤4：查找更多后，就会出现更多深层次的数据。鼠标箭头放在文件上，就可以查看文件的相关信息。确认是你要恢复的数据，就勾选上它，点击【恢复】。
PS：除了在界面左侧按【类型】或者【路径】查看文件，还可以按界面上方的【筛选器】来精准寻找。
步骤5：到了最后一步，就是选择好文件要保存的位置。软件会弹出一个保存窗口，选择好后，就可以打开恢复后的文件来查看。
最后，小编提醒大家，U盘被格式化后，应该立即停止对它的写入操作，防止原本的数据被覆盖，造成数据没有办法完整恢复的问题。u盘格式化后数据能恢复吗？当然可以。以上5步就可以轻松恢复你丢失的U盘数据！
往期推荐：
怎么找回笔记本的数据？笔记本数据恢复，6个教程https://mp.csdn.net/mp_blog/creation/editor/128558306u盘有病毒怎么办？修复U盘，3个方法解决https://mp.csdn.net/mp_blog/creation/editor/128573581免费数据恢复方法有哪些？分享这几种简单又实用的恢复方法（2023年最新）https://mp.csdn.net/mp_blog/creation/editor/128574270
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aaaa7b5bb866bfbb2da5b75dc098d23/" rel="bookmark">
			解决hutool工具包导出多个sheet，会产生默认空sheet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景：EXCEL导出多个sheet产生默认空sheet 问题描述 导出多个sheet会出现以下情况，空sheet
解决方案： 使用 writer.renameSheet()方法;默认修改第一个名字，再创建sheet
if(m==0){ writer.renameSheet(privice[m]); }else { writer.setSheet(privice[m]); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7951b7c51898d93fc8d83a80711f2bb3/" rel="bookmark">
			System.Reflection.ReflectionTypeLoadException: 无法加载一个或多个请求的类型。有关更多信息，请检索 LoaderExceptions 属性。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错网上说的挺多，就是不告诉怎么分析。将出错的代码用try catch 包起来
try { //代码 }catch(Expetion ex) { } vs 打断点展开ex 下的 LoaderExceptions 节点，就可以看到哪些库加载出错。我的问题是VS2019 创建的工程，vs 2022编译就有问题，直接升级blc包就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2310d1a315f0e9ace140fa74563af169/" rel="bookmark">
			卷积层输出大小尺寸计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 卷积之后的尺寸大小计算公式为：
输入图片大小 W×W
Filter大小 F×F
步长strides S
padding的像素数 P
输出大小为NxN
我们可以得出
（公式1）
长宽不等时，卷积之后的计算公式也是如此，只需分别计算即可。
在实际操作时，我们还会碰到 padding的两种方式 “SAME” 和 “VALID”，padding = “SAME”时，会在图像的周围填 “0”，padding = “VALID”则不需要，即 P=0。一般会选“SAME”，以来减缓图像变小的速度，二来防止边界信息丢失（即有些图像边界的信息发挥作用较少）。
注意！！！
此时可能会发现，按照这两中方式，按照上面的公式怎么不对呀
其实公式是没有问题的，
padding = “VALID”： P=0
padding = “SAME”： kernel_size=1时，P=0；kernel_size=3时，P=1；kernel_size=5时，P=2，以此类推。
问题可能也就出在上面
tensorflow官网给出了另一种计算方式，也是正确的：
padding = “SAME”时：
（ 解释：输入w / 步长s 之后向上取整） （公式2）
padding = “VALID”时：
（也是向上取整） （公式3）
举例说明 当
输入是5*5，
卷积核是3*3，
步长S = 2
padding= “SAME”时：
根据公式1：
根据公式2：
padding= “VALID”时：
根据公式1：
根据公式3：
编程结果 如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab6fe323a42a95de52758de24c115c6/" rel="bookmark">
			有适合comsol multiphysics的python脚本吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是的，COMSOL Multiphysics 可以使用 Python 脚本。你可以使用 Python 脚本来自动化模拟过程，或者将 Python 用作 COMSOL Multiphysics 的扩展语言。你可以在 COMSOL Multiphysics 中使用 Python 做很多事情，包括但不限于：
在脚本中创建和操作 COMSOL Multiphysics 模型对象在脚本中设置模型参数和材料属性在脚本中运行模拟并处理结果在脚本中将 COMSOL Multiphysics 与其他 Python 库集成，如 NumPy、SciPy 和 matplotlib 你可以使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9154216424b05d2efa48cbe664f03678/" rel="bookmark">
			C语言丨字符加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 请编写程序将一串5个字符组成的英文字符串译成密码
规则为：例如，将“China”译成密码，密码规律是：用原来的字母后面第4个字母代替原来的字母。例如，字母'A'后面第4个字母是“E”，用“E”代替“A”。因此，“China”应译为“Glmre”。请编写一程序，用赋初值的方法使c1,c2,c3,c4,c5这5个变量的值分别为'C','h','i','n','a'，经过运算，使c1,c2,c3,c4,c5分别变为'G','l','m','r','e'。请输出这5个字符。
#include &lt;stdio.h&gt; int main() { char c1,c2,c3,c4,c5; scanf("%c%c%c%c%c",&amp;c1,&amp;c2,&amp;c3,&amp;c4,&amp;c5); if(c1&gt;119) { printf("%c%c%c%c%c",c1-22,c2-22,c3-22,c4+4,c5+4); } else printf("%c%c%c%c%c",c1+4,c2+4,c3+4,c4+4,c5+4); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7ceb56f8030cb1a0c20fec34f34cee/" rel="bookmark">
			Echarts graph关系图的使用（入门级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.1.7今天我学习了如何使用echarts graph关系图，效果如：
首先是给容器设置id，宽高
然后是
var graphTwoChart = echarts.init(document.getElementById('graph')); graphTwoChart.setOption({ title: { text: '当前校企合作关系', textStyle: { color: 'white', }, left: "30px", top: "20px" }, tooltip: { show: true }, legend: { show: false, }, xAxis: { show: false }, yAxis: { show: false }, grid: { top: '80px' }, series: [{ type: "graph", // 是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启 roam: true, // 是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点。[ default: false ] focusNodeAdjacency: true, // 力引导布局相关的配置项，力引导布局是模拟弹簧电荷模型在每两个节点之间添加一个斥力，每条边的两个节点之间添加一个引力，每次迭代节点会在各个斥力和引力的作用下移动位置，多次迭代后节点会静止在一个受力平衡的位置，达到整个模型的能量最小化。 force: { // 力引导布局的结果有良好的对称性和局部聚合性，也比较美观。 // [ default: 50 ]节点之间的斥力因子(关系对象之间的距离)。支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大 repulsion: 200, // [ default: 30 ]边的两个节点之间的距离(关系对象连接线两端对象的距离,会根据关系对象值得大小来判断距离的大小)， edgeLength: [120, 100] // 这个距离也会受 repulsion。支持设置成数组表达边长的范围，此时不同大小的值会线性映射到不同的长度。值越小则长度越长。如下示例: // 值最大的边长度会趋向于 10，值最小的边长度会趋向于 50 edgeLength: [10, 50] }, // 图的布局。[ default: 'none' ] layout: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7ceb56f8030cb1a0c20fec34f34cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/829754059df714cdd62af495b89c8bf7/" rel="bookmark">
			相机标定中的战斗机--张氏标定法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		张正友标定法--相机标定中的灭霸！
在上学期接触过calibration以后，下定决心要学一下张正友标定法的，然后没来的及学，寒假弥补一下。
参考博客：https://zhuanlan.zhihu.com/p/136827980
编辑切换为居中
添加图片注释，不超过 140 字（可选）
上面那3个矩阵相乘以后，得到单应矩阵H。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
就是说要想发挥出相机的高精度测量的能力，必须要进行标定。虽然相机在出厂的时候有标定的参数，但是这个出厂内参在实际使用过程中还是存在误差的，因此需要我们自行标定。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
张氏标定法的地位，上图所示。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
张正友标定法的简明流程，就是通过自行打印的棋盘格，然后从不同角度获取照片。然后一顿计算，便得到了我们想要的内参。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
标定说白了还是在提高相机的精度。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
这四个坐标系算是老朋友了，其中图像坐标系和像素坐标系是在一个平面上的，只不过两个坐标系的坐标原点不同，然后图像坐标系用xy表示，像素坐标系用uv表示。通常在写代码的时候我们一般默认uv就是像素坐标系上的点。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
上图就是4个坐标系之间的关系。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
基元矩阵：就是绕着一个轴进行旋转的旋转矩阵，比如只绕着x轴旋转，那么这个旋转矩阵就叫做基元矩阵。(这个我第一次见)
编辑切换为居中
添加图片注释，不超过 140 字（可选）
正交矩阵和旋转矩阵之间的关系，首先正交矩阵的行列式的绝对值为1，当正交矩阵的行列式为1时，此矩阵为旋转矩阵。如果正交矩阵的行列式为-1，那么这个矩阵称为镜面反射矩阵。
镜面反射变换：当xyz三维空间时，镜面反射变换就是 x=x’ y=y’ z=-z’ 就是沿着z轴对折了一下，当然这里是举个例子，也可能沿x轴或者y轴对折。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
编辑切换为居中
添加图片注释，不超过 140 字（可选）
对乘法封闭。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
径向畸变的相关内容。
编辑切换为居中
添加图片注释，不超过 140 字（可选）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/829754059df714cdd62af495b89c8bf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a603d52129eee47795c1819eace017c/" rel="bookmark">
			FLV格式分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.FLV封装格式简介 FLV(Flash Video)是Adobe公司推出的⼀种流媒体格式，由于其封装后的⾳视频⽂件体积小、封装简单等特点，⾮常适合于互联⽹上使⽤。⽬前主流的视频⽹站基本都⽀持FLV。采⽤ FLV格式封装的⽂件后缀为.flv。
2.FLV封装格式分析 FLV封装格式是由**⼀个⽂件头(file header)**和 **⽂件体(file Body)**组成：
FLV body由⼀对对的(Previous Tag Size字段 + tag)组成，Previous Tag Size字段排列在Tag之前，占⽤ 4个字节。**Previous Tag Size记录了前⾯⼀个Tag的大小，⽤于逆向读取处理。**FLV header 后的第⼀个Pervious Tag Size的值为0。
Tag⼀般可以分为3种类型：
脚本(帧)数据类型⾳频数据类型视频数据 FLV数据以⼤端序进⾏存储，在解析时需要注意。
⼀个标准FLV⽂件结构如下图：
FLV⽂件的详细内容结构如下图：
3.FLV封装格式详细解析 3.1.FLV解析流程 3.2.FLV header FLV头的结构如下：
FieldTypeComment签名UI8F’(0x46)签名UI8‘L’(0x4C)签名UI8‘V’(0x56)版本UI8FLV的版本。0x01表示FLV版本为1保留字段UB5前五位都为0⾳频流标识UB1是否存在⾳频流保留字段UB1为0视频流标识UB1是否存在视频流⽂件头⼤⼩UI32FLV版本1时填写9，表明的是FLV头的⼤小 数据type中，UI表示⽆符号整形，后⾯跟的数字表示其⻓度是多少位，比如：UI8，表示⽆符号整形，⻓度⼀个字节UI24是三个字节,UI[8*n]表示多个字节。UB表示位域，UB5表示⼀个字节的5位。可以参考c中的位域结构体。
FLV头占9个字节，⽤来标识⽂件为FLV类型，以及后续存储的⾳视频流，⼀个FLV⽂件，每种类型的tag都属于⼀个流，也就是⼀个flv⽂件最多只有⼀个⾳频流，⼀个视频流，不存在多个 独立的音视频流在⼀个文件的情况。
3.3.FLV Body FLV Header之后，就是FLV File Body。FLV File Body是由⼀连串的back-pointers + tags构成。 Back-pointer表示Previous Tag Size(前⼀个tag的字节数据⻓度)，占4个字节。
3.4.FLV Tag tag header 每⼀个Tag也是由两部分组成:tag header和tag data。Tag Header⾥存放的是当前tag的类型、数据区(tag data)的⻓度等信息。
tag header⼀般占11个字节的内存空间。FLV tag header结构如下：
FieldTypeCommentTag类型 TypeUI88:audio 9:video 18:Script data(脚本数据) all Others:reserved 其他所有值未使⽤数据区⼤小UI24当前tag的数据域的⼤⼩，不包含tag header。 Length of the data in the Data field时间戳TimestampUI24当前帧时戳，单位是毫秒。相对值，第⼀个tag的时戳总是为0时戳扩展字段 TimestampExtendedUI8如果时戳⼤于0xFFFFFF，将会使⽤这个字节。这个字节是 时戳的⾼8位，上⾯的三个字节是低24位。StreamIDUI24总是为0数据域UI[8*n]数据域数据 １．flv⽂件中Timestamp和TimestampExtended拼出来的是dts。也就是解码时间。 Timestamp和TimestampExtended拼出来dts单位为ms。(如果不存在B帧，当然dts等于 pts)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a603d52129eee47795c1819eace017c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5423fcb2dee1a3f0954969e00317c69e/" rel="bookmark">
			20.04安装carla0.9.13记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经多次在不同版本的系统18.04、20.04安装carla不同源码版本0.9.11，0.9.12，0.9.13了，发现每次安装总是会遇到那么几个问题，现在新配了主机又要重新安装carla，这次准备详细的记录一下，方便未来安装时又遇到类似问题，减少安装时间。
一、安装carla的准备工作 在我第一次安装源码版本的carla，那时候还是2022年3月，啥都不明白，按照官网的步骤安装遇到了问题在网上资料也找不到，最后是遇到了一位好心的工程师远程帮我看了下，最后才安装成功了，记得前前后后花了快一个月，在这里祝这位工程师未来年薪百万，身体健康。现在在这里记录一下为认为在正式安装之前需要做的准备工作，也是为第一次遇到了血泪教训。共有两个：
1.检查显卡的驱动是否成功安装
一般安装好ubuntu系统后，它是会默认使用它自己写的显卡驱动好像叫nov什么什么的倒霉玩意，应该切换安装到适合自己显卡的驱动，一般来说在这里切换。
切换完成后看一下nvidia-smi显示和系统设置那里的显示：
这样显卡驱动部分就安装好了。
2.检查自己的swap分区的大小
这真是一个血泪教训，我第一次安装就是在这里卡到吐血，安装ue4成功，make PythonAPI成功，最后在make launch这里卡了很久很久，快一个星期吧。最后在外网的一个网站上面看都有人说可能是自己的swap和内存太小了，然后为自己的是设置了20g好像不行，又增加了20g最后才安装成功。检查自己的swap分区大小命令：
很奇怪，当时安装的时候明明分配了40g这里只显示了2g？
下面开始正式安装，参考官方文档：
官方文档0.9.13https://carla.readthedocs.io/en/0.9.13/build_linux/注意自己所看的官方文档是哪个版本的，一般默认显示的是最新版本的，后面包括github上默认下载的也是最新版本的，我第一次装的是0.9.10，这个默认版本也卡了快一周。
二、运行所必须第三方库安装 安装第三方库比如cmake, clang, different versions of Python, etc.
使用doc上提供的命令：
sudo apt-get update &amp;&amp; sudo apt-get install wget software-properties-common &amp;&amp; sudo add-apt-repository ppa:ubuntu-toolchain-r/test &amp;&amp; wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - &amp;&amp; sudo apt-add-repository "deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-8 main" &amp;&amp; sudo apt-get update ubuntu各个系统针对clang的要求不一样，doc写的很仔细，注意找不到ubuntu20.04的就去lastest看看，里面写的很全。
ubuntu20.04：
sudo apt-add-repository "deb http://apt.llvm.org/focal/ llvm-toolchain-focal main" sudo apt-get install build-essential clang-10 lld-10 g++-7 cmake ninja-build libvulkan1 python python-dev python3-dev python3-pip libpng-dev libtiff5-dev libjpeg-dev tzdata sed curl unzip autoconf libtool rsync libxml2-dev git sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/lib/llvm-10/bin/clang++ 180 &amp;&amp; sudo update-alternatives --install /usr/bin/clang clang /usr/lib/llvm-10/bin/clang 180 最好一行一行的输入，&amp;&amp;也分开，有时候会因为网络问题说有几个包没有下载好，直接多下载几次就好了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5423fcb2dee1a3f0954969e00317c69e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c791bcef76ee9e0640cfd11d9ea635/" rel="bookmark">
			Java中Map接口的默认方法computerIfAbsent、computeIfPresent、getOrDefault、merge、putIfAbsent、replaceAll以及常用示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 Java8新特性-Stream对集合进行操作的常用API：
Java8新特性-Stream对集合进行操作的常用API_霸道流氓气质的博客-CSDN博客_streamapi对集合修改
如果 Map 中包含元素，用户希望替换元素；如果 Map 中没有元素，用户希望添加元素；
此外，用户还希望执行其他相关操作。
Java 8 为 Map 接口引入了不少新方法，某些方法能为开发提供极大的便利。
注：
博客：
霸道流氓气质的博客_CSDN博客-C#,架构之路,SpringBoot领域博主
实现 1、computerIfAbsent
如果键存在，返回对应的值，否则通过提供的函数计算新的值并保存
V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt;mappingFunction)
以经典的斐波那契数递归计算为例进行讨论。
//效率极低的算法 int fib(int n){ if (n&lt;2) { return n; } else { return fib(n-1) + fib(n-2); } } 代码的问题在于需要进行大量重复的计算，（如 fib(5) =fib(4) + fib(3) = fib(3) + fib(2) + fib(2)+fib(1) = ...），
导致程序效率极低。可以利用缓存解决这个问题，函数式编程将这种技术称为记忆化。
BigInteger fibCache(long i){ if(i == 0) return BigInteger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c791bcef76ee9e0640cfd11d9ea635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/734223c5e60187d21b760d1c6bc8e872/" rel="bookmark">
			二叉搜索树详解--实现插入和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 BST树概念BST树操作BST树的查找BST树的插入BST树的删除 实现一个自己的BST树BSTNode类和BSTree类查找操作;插入操作:删除操作: 应用：二叉搜索树性能分析 对于普通的二叉树来说，能延伸出许多好用的数据结构，二叉搜索树(BST树)就是其中一个;
学习二叉搜索树，将为后续的AVL树与红黑树和map，set等STL容器打下坚实的基础;
BST树概念 二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树 BST树操作 BST树的查找 可以看到每步查找都能筛掉一般不符合的元素，有点类似于数组中的二分查找;
这也是二叉搜索树名字的由来，他的查找效率很高;
注意，不难发现，中序遍历BST树，就是一个升序的结构!;
BST树的插入 插入的具体过程如下:
按照二叉搜索树的性质，找到某个val合适的插入点;
BST树的删除 首先查找元素是否在二叉搜索树中，如果不存在，则返回,
否则要删除的结点可能分下面四种情况：
要删除的结点无孩子结点 --&gt;直接删除要删除的结点只有左孩子 --&gt;左孩子直接与他的父亲连接(左or右)，然后删掉它要删除的结点只有右孩子 --&gt;右孩子直接与他的父亲连接(左or右)，然后删掉它要删除的结点左右孩子都有;–&gt;去它的右子树找最左节点，替换它的位置 用替代法删除结点! 实现一个自己的BST树 由于一般具有k-v结构的数据结构底层是BST树，那么我们这里也实现一个K-V结构的BST树;
K模型：K模型即只有key作为关键码，结构中只需要存储Key即可，关键码即为需要搜索到的值。 比如：给一个单词word，判断该单词是否拼写正确，具体方式如下： 以单词集合中的每个单词作为key，构建一棵二叉搜索树,
在二叉搜索树中检索该单词是否存在，存在则拼写正确，不存在则拼写错误。
KV模型：每一个关键码key，**都有与之对应的值Value，**即的键值对。该种方式在现实生 活中非常常见：
比如英汉词典就是英文与中文的对应关系，通过英文可以快速找到与其对应的中文，英 文单词与其对应的中文就构成一种键值对；
再比如统计单词次数，统计成功后，给定 单词就可快速找到其出现的次数，单词与其出现次数就是就构成一种键值对。
&lt;单词，中文含义&gt;为键值对构造二叉搜索树，注意：二叉搜索树需要比较，键值对比较时只比较Key
查询英文单词时，只需给出英文单词，就可快速找到与其对应的key
BSTNode类和BSTree类 基本框架:
template&lt;class K,class V&gt; struct BSTNode { BSTNode(const K&amp; key = K(), const V&amp; value = V()) : _pLeft(nullptr), _pRight(nullptr), _key(key), _Value(value) {} BSTNode&lt;T&gt;* _pLeft; BSTNode&lt;T&gt;* _pRight; K _key; V _value }; template&lt;class K, class V&gt; class BSTree { typedef BSTNode&lt;K, V&gt; Node; private: Node* _root; } 查找操作; Node* Find(const K&amp; key) { //根据BST树的特性来find; if (_root == nullptr) return nullptr; Node* cur = _root; //原则上来说 是没有重复key存在的 while (cur) { if (key &gt; cur-&gt;_key) { cur = cur-&gt;_pRight; } else if (key &lt; cur-&gt;_key) { cur = cur-&gt;_pLeft; } else return cur; } return nullptr; } 插入操作: bool Insert(const K&amp; key, const V&amp; value) { if (_root == nullptr) { _root = new Node({ key,value }); return true; } Node* cur = _root; Node* prev = _root; //原则上来说 是没有重复key存在的 while (cur) { if (key &gt; cur-&gt;_key) { prev = cur; cur = cur-&gt;_pRight; } else if (key &lt; cur-&gt;_key) { prev = cur; cur = cur-&gt;_pLeft; } else return false; //数据冗余,不插入;map，set的普通版本不允许key重复！ } Node* newnode = new Node({ key,value }); if (prev-&gt;_key &lt; key) { prev-&gt;_pRight = newnode; } else { prev-&gt;_pLeft = newnode; } return true; } 删除操作: bool Erase(const K&amp; key) { Node* cur = _root; Node* father = nullptr; while (cur) { if (key &gt; cur-&gt;_key) { father = cur; cur = cur-&gt;_pRight; } else if (key &lt; cur-&gt;_key) { father = cur; cur = cur-&gt;_pLeft; } else break; } if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/734223c5e60187d21b760d1c6bc8e872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96dee29fcb789c3900641030962354e0/" rel="bookmark">
			这名员工是组内唯一的开发人员，在 Q3 季度独立处理完成了 48 个 DTS 问题单，这使得问题单处理效率提高了将近 1.5 倍。他还参与解决了大原 HDP35E 的 ISM 界面无法显示的网络问题，...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这名员工是组内唯一的开发人员，他在 Q3 季度独立解决了 48 个 DTS 问题单，使问题单处理效率提高了大约 1.5 倍。他还帮助解决了大原 HDP35E 的 ISM 界面无法显示的网络问题，为一线服务人员的网络问题处理提供了有效支持，避免了客户将问题升级，获得了一线工程师的赞赏。在与 ToolKit 工具同事讨论 T3 日志收集工具方案时，他确定了设备添加与工具上传与巡检保持一致的方案，优化了方案思路，为后续方案实施优化，并减少了大约 4 人天的人力。他还参与了解决 ISM 的 apache tomcat 和 struts 库问题升级的工作，主动联系 ISM 方面的人员，协调资源，为 IS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a2d319e94eeb37186bacb4c59a3429/" rel="bookmark">
			antd的ProColumns设置不可编辑状态的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法 1、editable: false方法
const columns: ProColumns&lt;any&gt;[] = [ { title: '数量', dataIndex: 'number', editable: false, }, ]; 2、readonly: true方法
const columns: ProColumns&lt;any&gt;[] = [ { title: '数量', dataIndex: 'number', readonly: true, }, ]; 3、renderFormItem方法
const columns: ProColumns&lt;any&gt;[] = [ { title: '数量', dataIndex: 'number', renderFormItem: () =&gt; { return &lt;Input disabled/&gt; } }, ]; 效果 前两种方法：
第三种方法：
未设置前效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e12b87f288fd481fc1f7525b76c09a/" rel="bookmark">
			前端刷新页面的五种方法（含原生js、vue和react）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原生JS 1、window.history.go(0)方法
window.history.go(0) 2、location.reload()方法
location.reload() 3、location.href=location.href方法
location.href=location.href vue 4、vue-router方法
const router = useRouter() router.go(0) react 5、react-router方法
import { createBrowserHistory, createHashHistory } from 'history'; const history = createBrowserHistory() // history模式 const history = createHashHistory() // hash模式 history.go(0) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b562f0334155427b5f271aa8f4c802b/" rel="bookmark">
			教你简单搞定webSocket前端代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在我们使用一个技术前我们先了解这个技术是什么?有什么用? webSocket和socket的区别？
webSock的通信原理
webSocket前端实现代码 &lt;script&gt; var websocket = null; if('Websocket' in window){ websock = new WebSocket('ws://'); }else{ alert('浏览器不支持webscket!'); } websocket.onopen = function(event){ console.log('建立连接'); } websocket.onclose = function(event){ console.log('连接关闭'); } websocket.onmessage = function(event){ console.log('收到消息：' + event.data); //可以做你想做的任何事，比如弹窗提醒，播放音乐 等等 } websocket.onerror = function(event){ alert('websocket通信发生错误！'); } window.onbeforunload = function(){ //窗口关闭时把websocket关闭掉 websocket.close(); } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9ec9dc245429558e4cf0e2d34d77e6/" rel="bookmark">
			js操作shadow-root内的DOM元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 项目中在DOM结构里遇到了shadow-root(open)，用JS方法无法直接获取其内的DOM元素
二、shadow DOM Web components 的一个重要属性是封装——可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。其中，Shadow DOM 接口是关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。shadow-root包裹下的对象，不在全局的DOM树中，因此getElementById 等方法，获取不到包裹中的对象。
Shadow DOM 这款工具旨在构建基于组件的应用。因此，可为网络开发中的常见问题提供解决方案：隔离 DOM：组件的 DOM 是独立的（例如，document.querySelector() 不会返回组件 shadow DOM 中的节点）。作用域 CSS：shadow DOM 内部定义的 CSS 在其作用域内。样式规则不会泄漏，页面样式也不会渗入。组合：为组件设计一个声明性、基于标记的 API。简化 CSS - 作用域 DOM 意味着您可以使用简单的 CSS 选择器，更通用的 id/类名称，而无需担心命名冲突。效率 - 将应用看成是多个 DOM 块，而不是一个大的（全局性）页面。 Shadow DOM 与普通 DOM 相同，但有两点区别：
创建/使用的方式；与页面其他部分有关的行为方式。 通常，您创建 DOM 节点并将其附加至其他元素作为子项。 借助于 shadow DOM，您可以创建作用域 DOM 树，该 DOM 树附加至该元素上，但与其自身真正的子项分离开来。这一作用域子树称为影子树。被附着的元素称为影子宿主。
简单的意思就是可以用来独立建立一块渲染块，不受外层样式的影响，内层的样式也不影响外层的显示。
三、操作shadow-root内的元素 1.先获取shadow-root的父级节点，然后用shadowRoot取得这个父级节点的shadow块，然后就可以进行操作了
document.querySelector('#root').shadowRoot.querySelector('.chakra-portal') 2.在shadow块下面创建style标签，在里面添加样式
let gtx = document.querySelector("#root"); let style = document.createElement("style"); style.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd9ec9dc245429558e4cf0e2d34d77e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/230a12300236b13329ae110873887da9/" rel="bookmark">
			linux启动流程及救援模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux启动流程及救援模式 1、系统服务管理 1.1 管理命令 命令注释systemctl start sshd开启此服务systemctl enable sshd开机自启动systemctl restart sshd重启此服务systemctl stop sshd关闭此服务systemctl disable sshd关闭开机自启systemctl status sshd查看这个服务的状态systemctl list-units查看所有服务运行的情况systemctl list-units-files查看所有服务的开机自启状态 1.2 status状态 Centos7之前版本需要使用service命令-&gt;service sshd start
部分服务无法使用systemctl管理时，可以使用用/etc/rc.local文件。
第1次使用需要授予执行权限 chmod +x /etc/rc.d/rc.local
2、Linux运行级别 指的是Linux的不同状态，比如命令行模式，图形化界面 2.1 不同的级别的含义 运行级别含义C7含义C60关机关机1救援模式 secure单用户模式,找回root密码2多用户模式无网络的多用户模式3多用户模式 multiuser命令行模式,文本模式,工作默认模式4多用户模式未使用,待开发待使用5图形化界面模式,桌面模式. X11 graphical图形化界面模式,桌面模式. X116重启重启 2.2 Centos运行级别 ll /usr/lib/systemd/system/runlevel*.target /usr/lib/systemd/system/runlevel0.target -&gt; poweroff.target /usr/lib/systemd/system/runlevel1.target -&gt; rescue.target /usr/lib/systemd/system/runlevel2.target -&gt; multi-user.target /usr/lib/systemd/system/runlevel3.target -&gt; multi-user.target /usr/lib/systemd/system/runlevel4.target -&gt; multi-user.target /usr/lib/systemd/system/runlevel5.target -&gt; graphical.target /usr/lib/systemd/system/runlevel6.target -&gt; reboot.target #查看当前系统的运行级别 systemctl get-default #修改运行界别 systemctl set-default 级别 #生产环境中不修改 3、Linux开机启动流程 图解 图解二 4、Linux忘记root密码怎么办？ 重启Linux进入grub菜单（先不要继续）选择第1个（目前使用中的Linux内核），按e，编辑内核配置 找到Linux16的行，修改这一行的内容ro改为rw，按END键到这一行的最后，输入init=/bin/bash 修改完成，执行ctrl+x启动系统，进入救援模式（此时无法远程连接）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/230a12300236b13329ae110873887da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b4a9183f7a8a5e5e1bb19affdf2c39/" rel="bookmark">
			python利用xlwt库实现选择保存excel文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 好的，首先你需要安装xlwt库，如果你还没有安装的话。你可以在命令行输入 pip install xlwt 来安装这个库。
然后，你可以使用以下代码来实现选择保存Excel文件的路径：
import tkinter as tk from tkinter import filedialog import xlwt # 创建一个Tkinter窗口 root = tk.Tk() root.withdraw() # 调用filedialog.asksaveasfilename函数弹出保存文件对话框 file_path = filedialog.asksaveasfile 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e67a18db0c9dcc28e5831e5b0beb1c/" rel="bookmark">
			VMware之windows 2016安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要以下材料： VMwaer
Windows2016镜像文件
材料下载地址： https://msdn.itellyou.cn/
重点：需要迅雷下载复制一下ed2k就能直接创建下载
操作步骤： 直接看图看操作吧
重点：选择刚刚下载的win2016的镜像文件
支持正版
行了这就安装完成了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b2974d840edeb556fc1cdad28fedc3/" rel="bookmark">
			简单易懂的隐马尔可夫模型（HMM）讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标：
了解什么是马尔科夫链知道什么是HMM模型知道前向后向算法评估观察序列概率知道维特比算法解码隐藏状态序列了解鲍姆-韦尔奇算法知道HMM模型API的使用 一、马尔科夫链 在机器学习算法中，马尔可夫链(Markov chain)是个很重要的概念。马尔可夫链（Markov chain），又称离散时间马尔可夫链（discrete-time Markov chain），因俄国数学家安德烈·马尔可夫（俄语：Андрей Андреевич Марков）得名。
1.1 简介 马尔科夫链即为状态空间中从一个状态到另一个状态转换的随机过程。
该过程要求具备“无记忆”的性质：
下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆”称作马尔可夫性质。 马尔科夫链作为实际过程的统计模型具有许多应用。
在马尔可夫链的每一步，系统根据概率分布，可以从个状态变到另一个状态，也可以保持当前状一态。
状态的改变叫做转移，与不同的状态改变相关的概率叫做转移概率。
马尔可夫链的数学表示为：
既然某一时刻状态转移的概率只依赖前一个状态，那么只要求出系统中任意两个状态之间的转移概率，这个马尔科夫链的模型就定了。
1.2 经典举例 下图中的马尔科夫链是用来表示股市模型，共有三种状态：牛市（Bull market）, 熊市（Bear market）和横盘 （Stagnant market）。
每一个状态都以一定的概率转化到下一个状态。如，牛市以0.025的概率转化到横盘的状态。
这个状态概率转化图可以以矩阵的形式表示。如果我们定义矩阵阵P某一位置P(i, j)的值为P(j|i)，即从状态i变为状态j的概率。另外定义牛市、熊市、横盘的状态分别为0、1、2，这样我们得到了马尔科夫链模型的状态转移矩阵为： 当这个状态转移矩阵P确定以后，整个股市模型就已经确定！
二、HMM简介 隐马尔可夫模型（Hidden Markov Model，HMM）是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。
其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别。
2.1 简单案例 下面我们一起用一个简单的例子来阐述：
假设我手里有三个不同的骰子
第一个骰子是我们平常见的骰子（称这个骰子为D6），6个面，每个面（1，2，3，4，5，6）出现的概率是1/6。第二个骰字是个四面体（称这个骰子为D4），每个面（1，2，3，4）出现的概率是1/4。第三个骰子有八个面（称这个骰子为D8），每个子（1，2，3，4，5，6，7，8）出现的概率是1/8。 我们开始掷骰子，我们先从三个骰子里挑一个，挑到每一个骰子的概率都是1/3。然后我们掷骰子，得到一个数字，1，2，3，4，5，6，7，8中的一个。不停的重复上述过程，我们会得到一串数字，每个数字都是1，2，3，4，5，6，7，8中的一个。例如我们可能得到这么一串数字（掷骰子10次）：1 6 3 5 2 7 3 5 2 4这串数字叫做可见状态链。 但是在隐马尔可夫模型中，我们不仅仅有这么一串可见状态链，还有一串隐含状态链。
在这个例子里，这串隐含状态链就是你用的骰子的序列。
比如，隐含状态链有可能是：D6 D8 D8 D6 D4 D8 D6 D6 D4 D8 一般来说，HMM中说到的马尔可夫链其实是指隐含状态链，因为隐含状态（骰子）之间存在转换概率（transition probability）。
在我们这个例子里，D6的下一个状态是D4，D6，D8的概率都是1/3。D4，D8的下一个状态是D4，D6，D8的转换
概率也都一样是1/3。
这样设定是为了最开始容易说清楚，但是我们其实是可以随意设定转换概率的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b2974d840edeb556fc1cdad28fedc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/479585cb2981d2aac4aa3c07abf41409/" rel="bookmark">
			一个 Qml MenuBar 的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本情况 使用 QQuick.Control 中的 MenuBar 实现主菜单栏。菜单栏包括 File、Edit、View、Help 菜单项。点击菜单项，会弹出对应的菜单。
ApplicationWindow { id: window width: 320 height: 260 visible: true menuBar: MenuBar { Menu { title: qsTr("&amp;File") Action { text: qsTr("&amp;New...") } Action { text: qsTr("&amp;Open...") } Action { text: qsTr("&amp;Save") } Action { text: qsTr("Save &amp;As...") } MenuSeparator { } Action { text: qsTr("&amp;Quit") } } Menu { title: qsTr("&amp;Edit") Action { text: qsTr("Cu&amp;t") } Action { text: qsTr("&amp;Copy") } Action { text: qsTr("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/479585cb2981d2aac4aa3c07abf41409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88e99f96f28a3474db71a058f74dff8/" rel="bookmark">
			GitHub 2022 的趋势和见解（JavaScript 连续四年摘得桂冠，Python 成为后端最常用的语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转载： https://blog.csdn.net/csdnnews/article/details/128543592?spm=1000.2115.3001.5927
整理 | 屠敏
出品 | CSDN（ID：CSDNnews）
过去一年，在开源驱动的下，科技的发展迎来了巨大的变化，而当论及其所影响的具体领域、技术时，近日，TiDB 通过全面的开源软件洞察工具 OSS Insight 分析了超过 5,000,000,000 行 GitHub 事件数据，最终发布了《GitHub 2022 的趋势和见解》报告，给出了重要的见解与回答。
在这份报告中，我们获得了有关 2022 年 GitHub 上开源软件的有趣发现，包括：
Python 虽然过去一年问鼎行业开发者最受欢迎的编程语言，但是它并不是开源世界中最受欢迎的。过去四年开源世界的顶级编程语言第一名是 JavaScript；
中国开发者过去一年在 GitHub 上，PullRequestEvent 占比 4.8%，WatchEvent 占 17.23%，ForkEvent 占 2.7%；
低代码、Web3、数据库、AI 是过去一年 GitHub 上最活跃的几大领域；
每年排名前 20 位的活跃存储库中，微软公司的占比最高。
接下来，我们将与大家一起快速了解报告的完整内容。
JavaScript 连续四年摘得桂冠，Python 成为后端最常用的语言 过去四年开源世界的顶级语言：JavaScript 位居第一，TypeScript 涨幅较高
该图表根据使用这些语言的新存储库与所有新存储库的比率，对 2019 年至 2022 年的编程语言进行了年度排名。
其中，JavaScript 和 HTML 连续四年排名第一位和第二位。Python 在 2021 年超越 Java 并升至第 3 位。
TypeScript 从四年前的第 10 位上升到了第 6 位，增幅最为明显。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88e99f96f28a3474db71a058f74dff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52852074f38a8cf200d17aa6b6bdd6a2/" rel="bookmark">
			HelloGitHub 最受欢迎的开源项目 Top10（2022年）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		再见 2022，你好 2023！
HelloGitHub 也随着 2023 年的到来，更新到了第 81 期开始迈向第 7 个年头啦。
在过去的 2022 年，我们一共发布了 12 期月刊、分享了 502 个开源项目，HelloGitHub 能够分享这么多有趣、好玩的开源项目，离不开开源爱好者的推荐、项目作者的自荐以及团队成员的贡献。在 2022 年发布过的众多开源项目中，你最喜欢哪个开源项目呢？哪些开源项目让你印象深刻？
下面就让我们一起来看看 2022 年《HelloGitHub 月刊》最受欢迎的 10 个开源项目，为了尽量涵盖较多的类别，就从 C++、Python、Java、JavaScript、Go、C#、C、Rust、CSS 每个类别挑选一个组成了 Top10 开源项目。排名并不重要，重要是的是不能让你错过这些好玩的开源项目。
话不多说，开始今年的 HelloGitHub 年度盘点！
1、《金庸群侠传》C++ 复刻版 Star 数：1.9K｜编程语言：C++
这是一款基于 SDL2 开发的 2D 游戏，作为《金庸群侠传》C++ 复刻版，它的资源大部分来自《金庸群侠传》DOS 版本，复刻版除了经典的回合制战斗系统，还在加入了受《黑帝斯》启发的即时战斗系统。或许大佬们的重温经典，就是用自己擅长的编程语言把游戏重新实现一遍吧。
地址：https://github.com/scarsty/kys-cpp
2、异步的 Python 聊天机器人框架 Star 数：3.2K｜编程语言：Python
它是基于 Python 的异步特性构建的聊天机器人框架，可以轻松处理大量的消息。还提供了命令行脚手架，仅用几条命令就可以完成项目搭建。支持多种 IM 平台，有效地帮助开发人员快速构建聊天机器人、消息通知等项目。该项目代码质量高、社区活跃，它上得了生产环境，下能搞定一次性脚本。
地址：https://github.com/nonebot/nonebot2
3、JVM 沙箱容器 Star 数：5.5K｜编程语言：Java
这是一种 JVM 的非侵入式运行期 AOP 解决方案。简单地说就是如果线上 Java 服务出现故障，需要加一条日志定位问题，通过该项目就可以在不重启服务的情况下，完成增加日志的操作。它还支持线上故障模拟、请求录制和结果回放等功能。
地址：https://github.com/alibaba/jvm-sandbox
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52852074f38a8cf200d17aa6b6bdd6a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22157dc3c7f42134571e11419ec6fa9a/" rel="bookmark">
			优化改进YOLOv5算法之添加SE、CBAM、CA模块(超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 SENet
1.1 SENet原理
1.2 SENet代码(Pytorch)
1.3 YOLOv5中加入SE模块 1.3.1 common.py配置
1.3.2 yolo.py配置
1.3.3 创建添加RepVGG模块的YOLOv5的yaml配置文件
2 CBAM
2.1 CBAM原理
2.2 CBAM代码(Pytorch)
2.3 YOLOv5中加入CBAM模块 2.3.1 common.py配置
2.3.2 yolo.py配置
2.3.3 创建添加CBAM模块的YOLOv5的yaml配置文件
3 CA
3.1 CA原理
3.2 CA代码(Pytorch)
3.3 YOLOv5中加入CA模块 3.3.1 common.py配置
3.3.2 yolo.py配置
3.3.3 创建添加CA模块的YOLOv5的yaml配置文件
4、实验效果对比
4.1 口罩检测数据集
4.2 效果对比
参考文章
在前面的文章中已经详细介绍了在本机上安装YOLOv5的教程，安装YOLOv5可参考前面的文章YOLOv5训练自己的数据集(超详细)https://blog.csdn.net/qq_40716944/article/details/118188085
1 SENet 论文名称：Squeeze-and-Excitation Networks
论文链接：https://arxiv.org/pdf/1709.01507.pdf
论文代码： GitHub - hujie-frank/SENet: Squeeze-and-Excitation Networks
1.1 SENet原理 对于卷积操作，很大一部分工作是提高感受野，即空间上融合更多特征融合，或者是提取多尺度空间信息，如Inception网络的多分支结构。对于channel维度的特征融合，卷积操作基本上默认对输入特征图的所有channel进行融合。而MobileNet网络中的组卷积（Group Convolution）和深度可分离卷积（Depthwise Separable Convolution）对channel进行分组也主要是为了使模型更加轻量级，减少计算量。而SENet网络的创新点在于关注channel之间的关系，希望模型可以自动学习到不同channel特征的重要程度。为此，SENet提出了Squeeze-and-Excitation (SE)模块，如图1所示。
图1 SEBlock结构图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22157dc3c7f42134571e11419ec6fa9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9919f4cd9da6480f6ebf5887de016fff/" rel="bookmark">
			面试官：如何用Excel进行预测分析？这操作绝了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【面试题】
一个社交APP, 它的新增用户次日留存、7日留存、30日留存分别是52%、25%、14%。
请模拟出来，每天如果日新增6万用户，那么第30天，它的日活数会达到多少？请使用Excel进行分析。
【分析思路】
第1日(次日)留存用户数=第1日新增用户数*次日留存率
第2日活跃用户数=第2日新增用户数+第1日留存用户数
第3日活跃用户数=第3日新增用户数+第2日留存用户数（第2日新增用户数*第2日留存率）+第1日留存用户数
...
第30日活跃用户数=第30日新增用户数+第29日留存用户数+第28日留存用户数+...+第1日留存用户数
也就是，
第30日活跃用户数=1-29日每天的留存用户数（第1日留存用户数+第2日留存用户数+...+第29日留存用户数）+第30日新增用户数
现在只需要计算出1-29日每天的留存用户数就可以了，而第N日的留存用户数=第N日新增用户数（6万）*第N日留存率。所以现在的问题是需要知道每天的留存率是多少。
那么，问题就来了。题目只有3个留存率（新增用户次日留存、7日留存、30日留存分别是52%、25%、14%）。
如何根据已有的几个留存率去预测剩下那些天的留存率呢？
很简单，用excel 1分钟就能搞定。
1.用现有的数据做散点图
2.对散点图添加趋势线
趋势线有以下几种类型，应该添加哪一类型的趋势线呢？
一般来说，正常的留存曲线是一开始快速下降，然后开始缓慢下降，最后逐步平稳的曲线。
所以，留存曲线的形状会类似于下图：初始在震荡期快速下降；选择期开始缓慢下降；过了选择期就是平稳期，留存率会进入一个相对稳定的阶段。
这种留存曲线的形状和乘幂函数十分接近，所以，在这里我们用乘幂函数来对留存曲线进行拟合。同时勾选“显示公式”和“显示R平方值”。最终得到了如下曲线，函数公式为y = 0.5227x^-0.385，R² = 0.9997，可以看到拟合后的幂函数的形状和上图的留存曲线的形状几乎一样。
拓展：
你肯定想知道这个趋势线的可靠性有多大？
这就涉及到趋势线的 R 平方值。R 平方值是介于 0 和 1 之间的数值。当趋势线的 R 平方值为 1 或者接近 1 时，趋势线最可靠。如案例演示中，R的平方值达到了0.9997，因此可以说这条趋势线可靠性非常大。
要获得最精确的预测，为数据选择最合适的趋势线非常重要。
那么，什么情况下选用什么样的趋势线呢？
指数：指数趋势线适用于速度增加越来越快的数据。
线性：线性趋势线是适用于简单线性数据集合的最佳拟合直线。如果数据点的构成的趋势接近于一条直线，则数据应该接近于线性。线性趋势线通常表示事件以恒定的比率增加或减少。
对数：如果数据一开始的增加或减小的速度很快，但又迅速趋于平稳，那么对数趋势线则是最佳的拟合曲线。
多项式:多项式趋势线是数据波动较大时使用的曲线。
乘幂：乘幂趋势线是一种适用于以特定速度增加的曲线。但是如果数据中有零或负数，则无法创建乘幂趋势线。
移动平均：移动平均趋势线用于平滑处理数据中的微小波动，从而更加清晰地显示了数据的变化的趋势。（在股票、基金、汇率等技术分析中常用）
3.计算第n天留存率
拟合出留存曲线后， 我们就可以根据拟合的函数公式（y = 0.5227x^-0.385）去计算次日到30日的留存率。
也就是把x=1,x=2…x=30,分别代入函数公式，这里可以借助Excel的power幂函数，求出结果。如下图，可以看到按照模型函数公式计算出来的留存率，即模型留存率与给定的留存率几乎完全一致（黄色的行）。
4.计算30天后日活数
通过上面的步骤，我们已经得到了每天的留存率。接下来我们就可以计算第30天的日活用户数有多少。
第1日(次日)留存用户数=第1日新增用户数*次日留存率
第2日活跃用户数=第2日新增用户数+第1日留存用户数
第3日活跃用户数=第3日新增用户数+第2日留存用户数（第2日新增用户数*第2日留存率）+第1日留存用户数
...
第30日活跃用户数=第30日新增用户数+第29日留存用户数+第28日留存用户数+...+第1日留存用户数
也就是，
第30日活跃用户数=1-29日每天的留存用户数（第1日留存用户数+第2日留存用户数+...+第29日留存用户数）+第30日新增用户数
（1）在下图Excel步骤1的地方是题目的设定，每天固定新增用户数为6万
在下图步骤2的地方算出1-29日每天的留存用户数，也就是第N日新增用户数（6万）*第N日留存率（F列对应的留存率）。
（3）下图步骤3将这一列的值求和，就是第30日活跃用户数=1日-29日每天的留存用户数+第30日新增用户数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9919f4cd9da6480f6ebf5887de016fff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167e8a873c99407cb5f5de21d8dfead5/" rel="bookmark">
			Linux服务器常见运维性能测试（1）综合跑分unixbench、superbench
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux服务器常见运维性能测试及压力测试拷机稳定性系列（1）综合跑分unixbench、superbench 常见性能测试软件综合测试：1.UnixBench测试项安装及使用 综合测试：2.superbench 最近需要测试一批服务器的相关硬件性能，以及在常规环境下的硬件运行稳定情况，需要持续拷机测试稳定性。所以找了一些测试用例。本次测试包括在服务器的高低温下性能记录及压力测试，高低电压下性能记录及压力测试，常规环境下CPU满载稳定运行的功率记录。
这个系列是根据这次测试项目的相关测试总结，关于各种常见性能测试及拷机软件的整理。
本章为系列1，主要介绍两款综合测试软件，一个是常用的综合跑分软件UnixBench，一个是测试脚本superbench。
常见性能测试软件 综合测试：UnixBench（综合跑分），superbench（快速脚本）
内存测试：stream
CPU测试：super_pi
网络测试：netperf
IO测试：FIO、iometer
辅助监测：sensors、top、iostat等
综合测试：1.UnixBench UnixBench 是测试类 Unix 系统性能的老牌工具，也是常用的基准测试工具。UnixBench会会执行 11 个单项测试，根据每个测试结果与一个基线系统测试结果比较得到的索引值，这样比原始值更容易得到参考价值。所有测试项目的索引值结合在一起形成一个测试分数值，得到一个指数值。指数值越高，性能越好。
测试项 Dhrystone测试
测试聚焦在字符串处理，没有浮点运算操作。这个测试用于测试链接器编译、代码优化、内存缓存、等待状态、整数数据类型等，硬件和软件设计都会非常大的影响测试结果。
Whetstone 测试
这项测试项目用于测试浮点运算效率和速度。这项测试项目包含若干个科学计算的典型性能模块，包含大量的C语言函数,sin cos sqrt exp和日志以及使用整数和浮点的数学操作。包含数组访问、条件分支和过程调用。
Execl Throughput测试
这项测试测试每秒execl函数调用次数。本身execl.c编译出来后的执行文件是execl的二进制文件，execl函数执行的时候记录参数：开始时间，执行次数，耗时（一般都是10秒）。
File Copy测试
这项测试衡量文件数据从一个文件被传输到另外一个，使用大量的缓存。包括文件的读、写、复制测试，测试指标是一定时间内（默认是10秒）被重写、读、复制的字符数量。
Pipe Throughput（管道吞吐）测试
pipe是简单的进程之间的通讯。管道吞吐测试是测试在一秒钟一个进程写512比特到一个管道中并且读回来的次数。管道吞吐测试和实际编程有差距。
Pipe-based Context Switching （基于管道的上下文交互）测试
这项测试衡量两个进程通过管道交换和整数倍的增加吞吐的次数。基于管道的上下文切换和真实程序很类似。打开两个管道，开启两个进程，其中一个进程往管道1写，往管道2读，另一个进程往管道2写，往管道2读，一个进程完成一次读写。测试程序产生一个双向管道通讯的子线程。
Process Creation(进程创建)测试
这项测试衡量一个进程能产生子线程并且立即退出的次数。新进程真的创建进程阻塞和内存占用，所以测试程序直接使用内存带宽。这项测试用于典型的比较大量的操作系统进程创建操作。
Shell Scripts测试
shell脚本测试用于衡量在一分钟内，一个进程可以启动并停止shell脚本的次数，通常会测试1，2， 3， 4， 8 个shell脚本的共同拷贝，shell脚本是一套转化数据文件的脚本。
System Call Overhead （系统调用消耗）测试
这项测试衡量进入和离开系统内核的消耗，例如，系统调用的消耗。程序简单重复的执行getpid调用（返回调用的进程id）。消耗的指标是调用进入和离开内核的执行时间。
安装及使用 v5.1.3版本下载地址：https://github.com/kdlucas/byte-unixbench/archive/v5.1.3.tar.gz
上传后解压压缩包
tar -zxvf byte-unixbench-5.1.3.tar.gz 因为原Makefile 设定图形化截面显示测试结果，我们直接命令行输出结果，编译安装前需要注释掉 GRAPHIC_TESTS = defined。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/167e8a873c99407cb5f5de21d8dfead5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce4a01c93fc41b4a93f5f4178ba9cb3/" rel="bookmark">
			Linux_用户账号权限的设定教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一.用户和组账号概述二.用户账号文件/etc/passwd三.用户账号文件/etc/shadow四.添加用户账号useradd五.设置/更改用户口令 passwd六.修改用户账号的属性 usermod七.删除用户账号userdel八.用户账号的初始配置文件九.PATH 变量十.组账号文件十一.添加组账号 groupadd十二.添加删除组成员gpasswd十三.删除组账号groupdel十四.查询账号信息十五.查询账号信息 finger命令十六.tty终端切换十七.文件/目录的权限和归属十八.设置文件和目录的权限 chmod十九.设置文件和目录的归属 chown二十.设置目录和文件的默认权限 umask 一.用户和组账号概述 1.linux基于用户身份对资源访问进行控制
用户账号：
超级用户、普通用户、程序用户
超级用户：root用户是Linux操作系统中默认的超级用户账号，对本主机拥有最高的权限，系统中超级用户是唯一的
普通用户：由root用户或其他管理员用户创建，拥有者的权限会收到限制，一般只在用户自己的宿主目录中拥有完整数据
程序用户：在安装Linux操作系统及部分应用时，会添加一些特定的低权限用户账号，这些用户一般不允许登录到系统，仅用于维持系统或某个程序的正常运行，如bin、daemon、ftp、mail等
组账号：
基本组（私有组）——用户创建自带的组
附加组（公共组）——给用户额外添加的组
基本组（私有组）：基本组账号只有一个，一般为创建用户时指定的组。在/etc/passwd文件中第4字段记录的即为该用户的基本组GID号
附加组（公共组）：用户除了基本组以外，额外添加指定的组
UID和GID：
UID：用户标识号
GID：组标识号
root用户账户的UID和GID号固定值为0.
程序用户账号的UID和GID号默认为1-499
普通用户的UID和GID号默认为500-60000
二.用户账号文件/etc/passwd 基于系统运行和管理需要，所有用户都可以访问passwd文件内容，只有root用户才能更改
保存用户名称、宿主目录、登录shell等基本信息
文件位置：/etc/passwd
每一行对应一个用户的账号记录
[root@localhost ~]# head -2 /etc/passwd
root: x:0:0:root:/root:/bin/bash
root: x:0:0:root: /root:/bin/bash
字段1:用户帐号的名称
字段2:用户密码占位符“x”
字段3:用户帐号的UID号
字段4:所属基本组帐号的GID号
字段5: 用户全名
字段6:宿主目录
字段7: 登录She1l信 息( /bin/bash为可登陆系统，/sbin/ nologin和/bin/false为禁止用户登陆系统)
三.用户账号文件/etc/shadow ■保存用户的密码、账号有效期等信息
●文件位置: /etc/shadow
●每一-行对应一一个用户的密码记录
[root@localhost ~]# head -2 /etc/shadow
[root@localhost ~]# tail -1 /etc/shadow
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce4a01c93fc41b4a93f5f4178ba9cb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b5224e81c79e8a5c50ecd47b7d860b/" rel="bookmark">
			Pytorch调用GPU训练两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 .cuda() 我们可以通过对网络模型，数据，损失函数这三种变量调用 .cuda() 来在GPU上进行训练。
# 将网络模型在gpu上训练 model = Model() if torch.cuda.is_available(): model = model.cuda() # 损失函数在gpu上训练 loss_fn = nn.CrossEntropyLoss() if torch.cuda.is_available():	loss_fn = loss_fn.cuda() # 数据在gpu上训练 for data in dataloader: imgs, targets = data if torch.cuda.is_available(): imgs = imgs.cuda() targets = targets.cuda() 方法二 .to(device) 指定 训练的设备
device = torch.device("cpu")	# 使用cpu训练 device = torch.device("cuda")	# 使用gpu训练 device = torch.device("cuda:0")	# 当电脑中有多张显卡时，使用第一张显卡 device = torch.device("cuda:1")	# 当电脑中有多张显卡时，使用第二张显卡 #单卡推荐 device = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b5224e81c79e8a5c50ecd47b7d860b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca3971fa5d8850f5245d45b5cd2296e/" rel="bookmark">
			1、opencv相机畸变矫正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv相机畸变矫正 opencv相机畸变矫正1、畸变矫正保存加载 C++2、畸变矫正保存加载 python2.1保存矩阵2.1直接使用保存的矩阵 3、效果 opencv相机畸变矫正 1、畸变矫正保存加载 C++ #include &lt;opencv2\imgproc\types_c.h&gt; #include&lt;opencv2/opencv.hpp&gt; #include&lt;iostream&gt; using namespace cv; using namespace std; Mat image, img_gray; int BOARDSIZE[2]{ 8,11 };//棋盘格每行每列角点个数 int main() { vector&lt;vector&lt;Point3f&gt;&gt; object_points;//保存棋盘格上角点的三维坐标 vector&lt;Point3f&gt; obj_world_pts;//三维世界坐标 vector&lt;vector&lt;Point2f&gt;&gt; images_points;//保存所有角点 vector&lt;Point2f&gt; img_corner_points;//保存每张图检测到的角点 vector&lt;String&gt; images_path;//创建容器存放读取图像路径 string image_path = "./pic/chess118/*.png";//待处理图路径	F:/Works/C++/openCV/opencv study/Revise/Revise/Project1/ //vector&lt;int&gt; point_counts; //每幅图像中的角点的数量 glob(image_path, images_path);//读取指定文件夹下图像 //转世界坐标系 for (int i = 0; i &lt; BOARDSIZE[1]; i++) { for (int j = 0; j &lt; BOARDSIZE[0]; j++) { obj_world_pts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca3971fa5d8850f5245d45b5cd2296e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83639a4325e19ca052bc6fe07dd2419/" rel="bookmark">
			黑马Hive&#43;Spark离线数仓工业项目--项目总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Grafana集成MySQL监控 目标：实现Grafana集成MySQL监控
实施
选择模板
导入报表
项目总结：背景需求 目标：掌握一站制造的项目背景及项目需求
路径
- step1：行业背景
- step2：项目需求
实施
项目行业：工业互联网大数据：物联网
项目名称：加油站服务商数据运营管理平台 - 参考别的项目：商业化大数据分析平台：神策
公司产品：加油机设备服务
公司客户：中石化，中石油，中海油、壳牌，道达尔……
整体需求
需求一：通过数据分析提高公司产品的服务质量**
- 基于加油站的设备安装、维修、巡检、改造等数据进行统计分析
- 支撑加油站站点的设备维护需求以及售后服务的呼叫中心数据分析
需求二：通过数据分析支撑公司的成本运营核算**
- 保障零部件的仓储物流及供应链的需求
- 实现服务过程中的所有成本运营核算
需求三：为未来自动化加油机设备做数据准备
- 获取所有用户和车辆的信息来实现自动化加油的管理
具体需求
- 运营分析：呼叫中心服务单数、设备工单数、参与服务工程师个数、零部件消耗与供应指标等
- 设备分析：设备油量监控、设备运行状态监控、安装个数、巡检次数、维修次数、改造次数
- 呼叫中心：呼叫次数、工单总数、派单总数、完工总数、核单次数
- 员工分析：人员个数、接单次数、评价次数、出差次数
- 费用分析：仓库物料管理分析、用户分析
项目总结：数据来源 目标：掌握一站制造的项目的业务流程和数据来源
路径
- step1：业务流程
- step2：数据来源
实施
业务流程
step1：加油站服务商联系呼叫中心，**申请服务**：安装/巡检/维修/改造加油机
- 呼叫中心会记录这个申请信息：来电受理事务事实表
- step2：呼叫中心联系对应服务站点，**分派工单**：联系站点主管，站点主管分配服务人员
- 工单信息记录在：服务单信息表、工单信息表
- step3：服务人员**确认工单**和加油站点信息
- 具体工单信息表：安装单、维修单
- step4：服务人员在指定日期到达加油站，进行**设备检修**
- step5：如果为安装或者巡检服务，安装或者巡检成功，则服务完成
- step6：如果为维修或者改造服务，需要向服务站点**申请物料**，物料到达，实施结束，则**服务完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e83639a4325e19ca052bc6fe07dd2419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a81f4306dfc62e8b61b8d1bf43336595/" rel="bookmark">
			[Vue篇]vue动态添加行/删除行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue动态添加行 页面效果代码：data部分methods部分 页面效果 点击相应的添加后，每个 el-table 增加一行
代码：
&lt;el-card&gt; &lt;div class="titleitem"&gt; &lt;span &gt;工作/学习经历&lt;/span&gt; &lt;/div&gt; &lt;el-table :data="experienceData" stripe style="width: 100%"&gt; &lt;el-table-column prop="starttime" label="开始时间" width="260"&gt; &lt;template slot-scope="scope"&gt; &lt;el-date-picker type="month" size="small" placeholder="选择年月" v-model="scope.row.starttime"&gt; &lt;/el-date-picker&gt; &lt;!-- &lt;el-input&gt;&lt;/el-input&gt; --&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="endtime" label="结束时间" width="260"&gt; &lt;template slot-scope="scope"&gt; &lt;el-date-picker type="month" size="small" placeholder="选择年月" v-model="scope.row.endtime"&gt; &lt;/el-date-picker&gt; &lt;!-- &lt;el-input v-model="scope.row.endtime"&gt;&lt;/el-input&gt; --&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="resume" label="简历" width="380"&gt; &lt;template slot-scope="scope"&gt; &lt;el-input v-model="scope.row.resume"&gt;&lt;/el-input&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="operate" label="操作"&gt; &lt;template slot-scope="scope"&gt; &lt;el-button size="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a81f4306dfc62e8b61b8d1bf43336595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaab7b4d8752ea4e79e024ca9ef5bd79/" rel="bookmark">
			输入一个十进制数 N，将它转换成 R 进制数输出。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入一个十进制数 N，将它转换成 R 进制数输出。 要求： 为每个测试实例输出转换后的数，每个输出占一行。如果 R 大于 10，则对应 的数字规则参考 16 进制（比如，10 用 A 表示，等等）。 注：以输入 0 0 代表结束 输入样例: 7 2 23 12 -4 3 0 0 输出: 111 1B -11 #include"stdio.h" #include"stdlib.h" int main() { int num[50],base[50],r[50]; char n[128]; int i = 0,j = 0,a; for(i=0;i&gt;=0;i++) { scanf("%d",&amp;num[i]);//输入任意的十进制 scanf("%d",&amp;base[i]);//输入想要转的进制 if((num[i]==0)&amp;&amp;(base[i]==0)) break; } a=i; for(i=0;i&lt;a;i++) { r[i]=num[i]; while(num[i] != 0) { if(num[i]&lt;0) num[i]=-num[i];//取绝对值 n[j] = num[i] % base[i];//取余 num[i] = num[i] / base[i]; j++; } if(r[i]&lt;0) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaab7b4d8752ea4e79e024ca9ef5bd79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d505119ddabd8fc415cb8939dfc84f90/" rel="bookmark">
			自然语言处理 第十章 信息抽取 复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息抽取 信息抽取复习重点：信息抽取概述从任务内容分为：从处理文档类型分为：从发展时间和处理文档分为： 实体识别与抽取限定域命名实体识别基于规则或字典的方法 ：规则模版（字典）+匹配统计学习方法 ：特征工程+算法（PRanking / margin/ SVM/LR……）神经网络的方法： 开放域命名实体识别开放式命名实体抽取方法（实例扩展方法）：开放式命名实体抽取过程：开放域实体抽取存在的问题： 实体消歧实体消歧任务：实体消歧的难点实体消歧方法基于聚类的实体消歧基于实体链接的实体消歧 关系抽取(重点)限定域关系抽取规则方法：基于统计的抽取方法基于神经网络的抽取方法 非限定域关系抽取(重点)利用知识库(远程监督的方法)远程监督的优势与问题 非限定域关系抽取(生成式抽取)无监督开放式中文实体关系抽取 事件抽取事件抽取相关概念：传统事件抽取 信息抽取复习重点： 实体关系抽取，和事件抽取
掌握实体关系抽取的基本过程
限定域的抽取方法
非限定域的抽取过程：
【弱监督的抽取过程，无监督的抽取过程，感知监督的抽取过程，远程监督的方法(优势，局限) 基本技术思路，改进后可以解决哪些问题？】
事件抽取： 基本的元概念，基本的过程就可以了。过程包含哪些要素
信息抽取概述 信息抽取：从自然语言文本中抽取指定类型的实体、 关系、 事件等事实信息，并形成结构化数据输出的文本处理技术
从任务内容分为： 实体识别和抽取（Named Entity Recognition，NER）实体消歧（entity resolution）关系抽取（Relation Extraction，RE）事件抽取（Event Extraction，EE） 从处理文档类型分为： 结构化数据(Structured Data)：一般指带有严格格式信息的数据，如:数据库中的表格，以及XML数据等等。半结构化数据(Semi.-structured Data)：指带有一定格式信息，但又不
很明确的数据，如网页、论文、邮件等无结构数据(Un-structured Data): 主要指完全没有结构信息的自由文本
(Free Text) 从发展时间和处理文档分为： 限定域信息抽取：处理的文档给定（无结构信息的自由文本），抽取
的实体，实体关系，事件类型给定。开放域信息抽取: 针对互联网范围，实体，关系和事件的类型不确定 实体识别与抽取 限定域命名实体识别任务：
限定实体类别：限定识别七类命名实体
（人名、 机构名、 地名、 时间、日期、 货币和百分比）限定目标文本：封闭文本语料（有标注） 开放域实体抽取任务：
不限定实体类别：可以是任何类型的实体。如 维基百科条目等不限定目标文本：大规模开放语料。如 Web页面，真实世界信息（无标注） 限定域命名实体识别 限定实体类别：限定识别七类命名实体
（人名、 机构名、 地名、 时间、日期、 货币和百分比）限定目标文本：封闭文本语料（有标注） NER可以分成两个子任务：
（1）发现命名实体（实体边界识别）（2）分类命名实体（确定实体类别 ） 基于规则或字典的方法 ：规则模版（字典）+匹配 选用特征包括统计信息、标点符号、关键字、指示词和方向词、位置词(如尾字)、中心词等方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d505119ddabd8fc415cb8939dfc84f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b279ffc1679c982542325bf7d5ffc22b/" rel="bookmark">
			自然语言处理重点 第11章 机器阅读理解 复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器阅读理解复习 机器阅读理解概述机器阅读(MRC)理解与问答系统(QA)的区别:本章内容： MRC 任务分类：完形填空形式（cloze-style）选项形式片段抽取形式（span extraction）文本生成形式（free-answer/generation）阅读理解实现方法传统特征工程深层语义图匹配深度神经网络 神经网络机器阅读理解基本框架嵌入编码：特征提取：文章-问题交互：答案预测： 神经网络机器阅读理解典型模型 本章复习重点： 阅读理解的方法，和问答系统的方法 基本过程上有哪些典型的区别，它的基本过程是什么样的，和问答系统的核心区别是什么，大致的技术思路概念就可以 机器阅读理解概述 机器阅读理解其实和人阅读理解面临的问题是类似的，不过为了降低任务难度，很多目前研究的机器阅读理解都将世界知识排除在外，采用人工构造的比较简单的数据集，在给定的文本或相关内容(事实)的基础上，要求机器根据文本的内容，对相应的问题作出回答；一般回答的是一些非事实性的、高度抽象的需要对语言理解的问题 。
机器阅读(MRC)理解与问答系统(QA)的区别: 问答系统(QA)考察系统的文本匹配、信息抽取能力；MRC考察系统对于文本细致化的语言理解能力和推理能力；
机器阅读理解核心问题：理解和推理，并不是简单的文本匹配或者相似度计算机器阅读理解研究特点： 任务导向 + 数据驱动
在机器阅读理解任务当中，问题的答案是给定的，是有监督学习任务 本章内容： 任务分类及评价指标数据集实现方法主要挑战 MRC 任务分类： 传统的MRC任务可以分为四种类型：完形填空、多项选择、片段抽取、自由回答
考虑到目前方法的局限性，MRC出现了新的任务，如，knowledge-based MRC, MRC with unanswerable questions, multi-passage MRC，conversational question answering
完形填空形式（cloze-style） 提供：文本C，且一个词或实体 a ( a∈C ) 被移除任务：使用正确的词或实体进行填空（最大化条件概率 P(a |C - {a} )数据集：CNN &amp; Daily Mail 、 Children’s Book Test （CBT）、LAMBADA、Who-did-What、CLOTH答案类型： 客观
评价指标： Accuracy 准确率：衡量正确预测出答案占测试集合的比例
A c c u r a c y = 预测答案正确的个数 测试集合的大小 Accuracy=\frac{预测答案正确的个数}{测试集合的大小} Accuracy=测试集合的大小预测答案正确的个数​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b279ffc1679c982542325bf7d5ffc22b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f631f42536afa4cc1be44805a450e5/" rel="bookmark">
			架构师考试终章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周六，也就是11月5号，是2022年的架构师考试的考试日。这段时间疫情很严重，河南郑州取消了考试、广东部分地方也取消了考试、上海好像也取消了考试、北京部分考生因弹窗也不能参加考试，好在我比较幸运，最终走进了考场。
考试科目：综合题、案例分析、论文题。考完结束后对答案，综合题的选择题好几道自己应该会、准备过的结果都选错了，反而蒙的几道都对了，还有最后的英文选择，5道题都对了，选择题估了两遍，估了48分，如果不出啥意外就是这个分了；
案例分析题答得比较好，主要是考前两天请假复习的内容正好遇到到类似的。
论文是我感觉最悬的，考前一篇都没写过，就看了几篇范文，考试时时间把握的也不够好，最后一个字和打铃声一同结束。并且「基于构件的软件开发」这个知识点我回答的也不够完善。不知道论文的评分标准是什么，现在就希望阅卷老师能给个46分。
考试这天有一个小插曲，就是考完试当天晚上，群里有人转发，上午11点50时，某培训班把下午论文的前两道题论文题目泄露了。我看群里有人说要去举报之类，我倒是异常平静，可能是最近几年社会上的各种事情接触多了，知道自己也不能改变什么，唯有努力把自己能控制的事情做好。
再回头看看《架构师考试周报》，每周的任务基本都没有按时完成，并且在更新了5周后停止了。反思原因，唯一的原因就是工作太累了，每天早上8点起床，洗漱去公司，晚上9点到10点多下班，到家就很累了，真的没有精力去学习。
复习进度最快的几段时间就是国庆节最后几天；再加国庆节后的居家办公期间；再加非常非常重要的考前请了两天假专门复习。
国庆节最后几天一直在APP刷题，刷到了APP给我预估分达到及格，这时候算是度过了“任何事情的入门困难期”。
国庆节后因为疫情居家办公，没有那么多会议，没有那么多人找，工作做完后晚上就刷题，这时候也开始刷案例分析题，有了选择题的基础，发现案例分析题并没有那么难。
考试前两天请了假，这两天主要做了4套历年的综合选择题的真题，同时看了看案例分析以及论文范文，这两天的自由时间真的太重要了。如果我能通过，这两天的复习成果能占50%。
「架构师考试周报」的记录暂时告一段落，希望我的经历能给后来人做一些参考。共勉。
再更新：
说一下成绩：选择39分，综合53分，论文48分，没过。
复盘一下，还是选择题练的太少了，投入的时间也不够。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d5b593fb8a9016955fd9509173fcc0/" rel="bookmark">
			Window下安装oracle12C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Window下安装oracle12C
官网下载地址：
Database Software Downloads | Oracle
页面顶部选择 “接受许可协议” 后，我想选择下载 12c 版的企业版，文件1和文件2都需要下载。（如果提示登录 Oracle，则需要先登录才能下载）
下载后对两个文件进行解压，它会解压到同一个目录 database
2.Oracle 12c 安装
选中database 目录下的 "setup.exe" 文件，右键以管理员身份开始安装。
黑框等待一会就会开始正式安装。
取消结束安全更新选项 管理员账号密码不符合标准规则，想继续使用设置的密码，如下图所示，选择是
检查安装信息没有问题，就可进行安装
3.登录Oracle
打开命令提示符（Win键+R键），输入cmd，进入命令行黑窗口。执行命令：sqlplus / as sysdba（以超级管理员身份登录），或者执行命令：conn system/密码@orcl as sysdba（以system用户登录）
4.Oracle常规设置
由于oracle默认在命令窗口查看的结果是竖的，不方便查看，可以执行下面的命令，修改显示结果
SQL&gt; set linesize 800;
1)修改oarcle的密码文件不过期
SQL&gt; Select * FROM dba_profiles s Where s.PROFILE='DEFAULT' AND RESOURCE_NAME='PASSWORD_LIFE_TIME';
SQL&gt;alter profile default limit password_life_time unlimited;
5.创建账号
创建用户：create user oracle identified by 123456;
据说生产环境下，只是connect resource这样的角色就可以了。
GRANT "CONNECT" TO "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8d5b593fb8a9016955fd9509173fcc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775403f74bd8ca65d56118698123ee5d/" rel="bookmark">
			在文件上传中防止Xss注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 之前在《Xss过滤器（Java）》使用OWASP库了，不过当时只能防止一般rest接口，对于上传流就有点搞不定了。这里继续使用OWASP库来防止xss注入。
步骤 Maven &lt;properties&gt; &lt;esapi.version&gt;2.5.1.0&lt;/esapi.version&gt; &lt;antisamy.version&gt;1.7.2&lt;/antisamy.version&gt; &lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;org.owasp.esapi&lt;/groupId&gt; &lt;artifactId&gt;esapi&lt;/artifactId&gt; &lt;version&gt;${esapi.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.owasp.antisamy&lt;/groupId&gt; &lt;artifactId&gt;antisamy&lt;/artifactId&gt; &lt;version&gt;${antisamy.version}&lt;/version&gt; &lt;/dependency&gt; Spring 过滤器 ReplaceRequestBodyFilter.java
import org.springframework.stereotype.Component; import org.springframework.web.filter.OncePerRequestFilter; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @Component public class ReplaceRequestBodyFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String contentType = request.getContentType(); if (null != contentType &amp;&amp; contentType.contains("multipart/")) {//说明是文件上传 XSSCommonsMultipartResolver commonsMultipartResolver = new XSSCommonsMultipartResolver(); XSSMultipartHttpServletRequest resolveMultipart = (XSSMultipartHttpServletRequest) commonsMultipartResolver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/775403f74bd8ca65d56118698123ee5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a496164f589bfae9ecba3fd86ec75b/" rel="bookmark">
			gradle中自动生成git提交信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven有一个git-commit-id插件，可以在打包的时候自动生成git commit相关的信息。对于查看版本是否发布正常非常有意义。
很遗憾gradle却没有。只有自己动手了。
首先编写一个gradle文件version-commit.gradle，定义一个gradle的task用于生成git信息，使用默认任务的方式defaultTasks或者在processResources任务之后执行。因为processResources就是专门处理资源文件的，所以生成git信息的文件在processResources之后生成就很合理。 import java.text.SimpleDateFormat //使用默认task的方式嵌入 //defaultTasks 'versionCommit' task("versionCommit"){ versionCommit() } //在processResources之后执行 processResources.finalizedBy versionCommit static def versionCommit() { Properties p = new Properties() p.put("branch", getGitBranch()) p.put("commitId", getGitCommit()) p.put("commitAuthor", getGitCommitAuthor()) p.put("commitTime", getGitCommitTime()) p.put("packageTime", getCurrentTime()) p.store(new FileWriter("src/main/resources/version-commit.properties"), "generated by gradle git info plugin") } static def getGitCommit() { return 'git rev-parse --short HEAD'.execute().text.trim() } static def getGitCommitAuthor() { String commitId = getGitCommit(); String cmd = "git log --pretty=format:%an $commitId -1"; return cmd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a496164f589bfae9ecba3fd86ec75b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feaa9458dab38cc6d491106aba2127a0/" rel="bookmark">
			win10，win11下面一行任务栏设置 小部件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在下面这一栏空白处右击 ，显示任务栏设置，进入点击取消小部件即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d675ae23a033efefdb9eca07a648c220/" rel="bookmark">
			js将Object类型转为集合类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 中的 Object 类型可以通过调用内置的 Object.values() 或者 Object.entries() 函数将其转换为集合类型。
Object.values() 函数会返回一个数组，数组中包含对象中所有可枚举属性的值。
Object.entries() 函数会返回一个数组，数组中包含对象中所有可枚举属性的键值对。
例如：
constobject = { a: 1, b: 2, c: 3 }; console.log(Object.values(object)); // [1, 2, 3] console.log(Object.entries(object)); // [['a', 1], ['b', 2], ['c', 3]] 请注意，Object.values() 和 Object.entries() 函数是在 ECMAScript 2017 中引入的，所以可能不在所有浏览器中都可用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66e1fd49429931794565518c77491a7/" rel="bookmark">
			专利局专利审查协作湖北中心（笔试&#43;一面&#43;未进复面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9月底投递——10月29日笔试——11月5日面试
笔试3h，双机位，一共5道题，4篇英译汉，第5题是写一篇800字的文章。
面试10min，半结构化面试，有4个面试官1个记录员，双机位。
先是给15min看一篇专利申请，因为要排队，实际上给了半个多小时看。那篇文章有20页的样子然后面试官问了3个关于专利的问题。
1.站着自我介绍1min左右。
2.这个专利解决了什么问题？要简略回答，一两句就行，不然会被打断。
3.怎么判断可信度的？（根据那篇专利来的）
4.情感极度怎么计算的？（根据那篇专利来的）
5.有没有男朋友
6.有没有其他offer
7.怎么选择offer？职业规划是什么
8.工作中不开心怎么办？
9.对于薪资的要求
10.如何看待加班，经常要加班怎么办
感受：看了官网全国所有中心加起来收1500人，看进入了面试的名单至少有2.5w人报名，湖北中心进面600人左右，我哥在通信领域，说去年他们这边没招人，前年招了4个，竞争有点大。笔试面试有点严格，都是双机位，自我介绍需要站立答，回答专利问题也需要站立答。资料审查时候，大家学历都好高，硕士起步，双211普遍，985硕扎堆。稳定是真的稳定，钱不多不少，案子审的多，工资自然就高。每年有案子指标，业务熟练，案子审的快，过的自然轻松，不熟练基本天天加班。
11.18日更新
没进复试。也是大大小小面试参加过几十场的人，应该不是面试原因挂。估计还是本科太差。
心态崩了，如果再来一次我会选择复读。想去一些稳定的公司，总会在最后一轮把我刷掉，好好准备了也只是多陪跑几轮，差不多能力的，如果我是老板也会选择学历更好的吧。
唉，研究生学历只够我进门槛。试图抵抗社会这个大筛子，筛来筛去还是外包，我的秋招结束了，乖乖去外包了，已经能想象到自己的未来了，因为有外包背景社招再继续陪跑。就这样吧，做个学会知足的npc。
大家加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3712d49cbeb6321f603a1ff1a9131f19/" rel="bookmark">
			【WSL】[02] windows subsytem linux 配置和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第【2】章前言： 上一篇我们已经安装好了ubuntu在WSL下的GUI的桌面：我们现在继续进一步进行配置工作。同时也把，运用WSL的流程摸一把，以备后用。
补充1： 彻底的关闭WSL的方法： WSL使用后，原来Windows安装的传统虚拟机是用不了的，会报错：Vmware虚拟机报错的原因，其中WSL2是重要的一条，所以，我们先要学会WSL的关闭方法，以免之前的Vmware的资源都不能用了。
如，下图勾选掉这两项，就能够关闭WSL2的功能了 补充2 关闭WSL中某一个启动的Linxu子系统： 先查询一下： (base) PS C:\Users\frank_sj&gt; wsl --list --verbose NAME STATE VERSION * Ubuntu Running 2 Ubuntu-20.04 Running 2 命令：wsl --list --verbose 可以简写为： wsl -l
(base) PS C:\Users\frank_sj&gt; wsl -l -v NAME STATE VERSION * Ubuntu Running 2 Ubuntu-20.04 Running 2 然后用： wsl -t Ubuntu 去停掉其中的Ubuntu的子系统
(base) PS C:\Users\frank_sj&gt; wsl -t Ubuntu (base) PS C:\Users\frank_sj&gt; wsl --list --verbose NAME STATE VERSION * Ubuntu Stopped 2 Ubuntu-20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3712d49cbeb6321f603a1ff1a9131f19/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/107/">«</a>
	<span class="pagination__item pagination__item--current">108/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/109/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>