<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e55a52049814301ab5070260f22994/" rel="bookmark">
			基于java植物大全智能识别系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户注册：填写手机账号和密码，注册新用户
登录功能：注册普通账号登录；登录后可以修改用户的基本信息，也可以退出。
关于我们：关于我们、联系我们、加入我们、法律声明
轮播广告：后台设置首页轮播广告图，可以连接到广告页面。
留言反馈：用户填写李哭咽的主题、联系人、电话、邮箱、留言内容；后台管理可以查看留言列表，可以删除留言。
植物智能识别：上传本地图片，通过百度AI智能图片识别，返回结果并显示
资讯阅读：游客和用户都可以进行资讯的阅读。
资讯收藏：阅读到有兴趣的资讯，注册登录的用户可以进行收藏操作。
资讯评论：阅读资讯的时候，登录的用户，可以发表评论；后台审核后显示。
植物阅读：游客和用户都可以进行植物信息的阅读。
植物收藏：阅读到有兴趣的植物信息，注册登录的用户可以进行收藏操作。
植物评论：阅读植物信息的时候，登录的用户，可以发表评论；后台审核后显示。
资讯浏览：记录用户所有浏览过的资讯信息
资讯收藏：收藏的感兴趣的资讯文章，可以直接点击去阅读，支持删除。
资讯评论：列出参与评论的文章、评论内容、审核状态。
植物浏览：记录用户所有浏览过的植物信息
植物收藏：收藏的感兴趣的植物信息，可以直接点击去阅读，支持删除。
植物评论：列出参与评论的植物信息、评论内容、审核状态。
用户信息：姓名、联系方式、邮箱、头像、简介、介绍等，支持随时修改；用户注册的信息后台管理员可见；后台管理员可以删除。
密码修改：修改注册的密码。
退出登录：清除登录的cookie，返回到首页。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca792dce09e6b6d2fe19b99181540f82/" rel="bookmark">
			C语言条件分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
语句
1.if语句
2.switch语句
语句 简单语句是只有一个 ; 的空语句
复杂语句是由 { } 框起来的语句，括号中如果为空则等于空语句
1.if语句 if语句的一般格式：if...else
if（表达式）{ 语句组 } else{ 语句组 } if（表达式）{ 语句组 } else if（表达式）{ 语句组 } 条件：关系运算符
运算符 意义 = = 相等 ！= 不相等 &gt; 大于 &gt; = 大于或等于 &lt; 小于 &lt; = 小于或等于 注意：1.关系运算符的优先级比算术运算低，但比赋值运算高。
2.else后不接条件
3.if语句不接 ;
4.在一条if语句的语句组里仍然可以接if语句
5.else和离它最近的if配对
举例：
if (age&gt;18) { // 如果已经成年 } else if(age&lt;18) { // 如果仍未成年 } else { // 上面的都不成立 } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca792dce09e6b6d2fe19b99181540f82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f13ab6ea8d3c86ceb9a2698bfc5a28a/" rel="bookmark">
			vue使用讯飞语音webapi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、新建公用文件夹内放入以下两个文件（IatRecorder.js，transcode.worker.js）IatRecorder.jstranscode.worker.js 二、在main.js中引入文件三、在页面中使用 前言 项目要求实现语音转文字，决定使用讯飞语音的webapi，在网上找了很多方法，修修改改，经过了一些坑，终于实现了想要的效果
一、新建公用文件夹内放入以下两个文件（IatRecorder.js，transcode.worker.js） IatRecorder.js /* eslint-disable no-undef */ const APPID = '6d1b5e69' const API_SECRET = ' ' const API_KEY = ' ' import store from '@/store' import CryptoJS from 'crypto-js' import Worker from './transcode.worker.js' const transWorker = new Worker() let startTime = '' let endTime = '' function getWebSocketUrl() { return new Promise((resolve, reject) =&gt; { // 请求地址根据语种不同变化 let url = 'wss://iat-api.xfyun.cn/v2/iat' const host = 'iat-api.xfyun.cn' const apiKey = API_KEY const apiSecret = API_SECRET const date = new Date().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f13ab6ea8d3c86ceb9a2698bfc5a28a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582c1c054b516d227b51dbe629df0463/" rel="bookmark">
			Vscode调试Python代码没有任何反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因是：自己在anaconda里面的虚拟环境的python版本是3.6的，然后可能不小心更新了python插件，导致调试不了了，还以为是配置文件的问题，但其实配置文件用默认的就行，不会影响你调试代码，后来 参考Vscode运行Python代码没有任何反应 - 知乎
解决了问题，就是重新安装另外一个版本的python插件（版本稍微老一点的就行），因为几个月前我还是能调试的，所以我就重新装了几个月前的python插件
参考博文如下：
自己几个星期没在自己电脑上运行Python程序，今天想跑一个简单的测试程序，结果发现点击下图运行按钮，vscode竟然没有任何反应。
试了很多次都是如此，重启vscode、电脑，都不行，以前从来没有出现过这种问题。
自己又单独启动 Python IDLE, 并运行刚刚的python程序，发现一切正常。
这说明不是python本身的问题，于是自己怀疑是Python解释器没设置对，于是 Ctrl+p 重新选一下解释器。
从上图可以看到vscode能够识别到电脑上安装的 Python。
可惜设置完以后，还是无法运行和Debug。
那么，剩下的唯一可能就是vscode的python插件出了问题。
通过如下方式安装另一个比较旧一点的版本。
我这里选择的是2022.4.0的版本。
安装好以后，重新启动vscode。
运行之前的代码，问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d4473c219a565d413c7ab114f45875/" rel="bookmark">
			010基于CNN-LSTM的EEG-fNIRS混合图像构建与分类-2022
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EEG-fNIRS-based hybrid image construction and classification using CNN-LSTM 社会技术系统中不断发展的人机交互和进步使得通过监测大脑状态来分析重要的人类因素，如脑力劳动、警觉、疲劳和压力，以实现最佳性能和人类安全是至关重要的。同样，在脑机接口(BCI)和神经障碍和运动障碍的闭环神经调节等领域，脑信号已经成为康复和辅助目的的首要目标。脑信号的复杂性、非平稳性和低信噪比给研究人员设计健壮可靠的BCI系统带来了巨大的挑战，以准确地检测实验室环境以外的大脑状态的有意义的变化。在混合环境中使用不同的神经成像模式来提高准确性，增加控制命令，并减少大脑活动检测所需的时间。功能近红外光谱(FNIRS)和脑电(EEG)分别以良好的空间分辨率和时间分辨率测量大脑的血液动力学和电活动。然而，在混合环境中，这两种模式都增强了BCI的输出性能，由于它们的采样率和通道数量之间的巨大差异，它们的数据兼容性仍然是实时BCI应用的挑战。传统的方法，如下采样和信道选择，在使两种模式兼容的同时会导致重要的信息丢失。在这项研究中，我们提出了一种新的基于递归图(RP)的时间分布式卷积神经网络和长短期记忆(CNN-LSTM)算法(CNN-LSTM)用于混合脑机接口应用中的fNIRS脑电信号的综合分类。获取的脑信号首先用RPS投影到非线性维度，然后馈入CNN提取基本特征，而不执行任何下采样。然后，使用LSTM学习时间特征和时间依赖关系来检测大脑活动。该模型的平均准确率分别为78.44%、86.24%和88.41%。最高准确率分别为85.9%、88.1%和92.4%。实验结果证实了基于RP的深度学习算法在成功的脑-机接口系统中的可行性。
脑机接口(BCI)已经成为残障人士不可或缺的要素。它们已成为新的医疗应用的组成部分，并越来越多地应用于通信系统、人机界面(Bai等人，2020年)和神经反馈应用(Mercado等人，2021年)。BCI使人类大脑和外部计算机/设备之间能够通过产生的大脑命令进行通信，从而避免周围神经系统(Antonietti等人，2021年)。此外，脑机接口是一种神经反馈方法，可以提高因四肢瘫痪(Benaroch等人，2021年)、中风(Mane等人，2020年)和其他脊髓损伤(Al-Taleb等人，2019年)而患有严重运动障碍的患者的生活质量。BCI还应用于神经康复、通信和控制、运动治疗和康复、脑监测和神经人体工程学(Asgher等人，2020a，b；Mughal等人，2021)。
BCI分析来自健康受试者的生物信号，以预测他们认知状态的一些无形方面。这一过程通常包括三个主要步骤：根据所选的应用和模式从大脑获取数据，将数据解释或预处理为命令，并输出到计算机以生成命令。在反应性、主动性和被动性脑机接口(PBCI)的三种类型中，pBCI是一个重要的研究领域，它根据大脑对不同情景产生的反应来估计人类的情绪、认知、意图和行为。
随着神经成像方法的进步，对改进传统脑-机接口实践的需求也在增加。BCI的主要非侵入性神经成像方法包括功能磁共振成像(FMRI)、脑电(EEG)、脑磁图和功能近红外光谱(FNIRS)。其中，EEG和fNIR在成本和可管理性方面是最重要的模式(Rahman等人，2020年；Rashid等人，2020年)。EEG通过根据神经元的动作电位计算电压波动来测量大脑活动，而fNIRS则检测与血流动力学反应变化相关的大脑活动(Hong和Zafar，2018；Liu等人，2021)。尽管有创技术提供的数据比非有创技术更准确，但非有创技术更常见，也更受重视在研究领域。脑活动的非侵入性记录技术提高了安全性并减少了伦理问题(Burwell等人，2017；Pham等人，2018)。随着时间的推移，各种非侵入性技术被用于研究。最常用的是EEG、fNIRS、眼电图术和fMRI(Choi等人，2017年)。选择非侵入性医疗器械取决于许多因素。通常，会根据应用程序的需要考虑以下参数：成本、易用性以及时间和空间分辨率。每种模式都比其他模式提供了一些优势，而且总是有一些相关的取舍；一种模式的优点弥补了另一种模式的缺点。因此，混合方法已被证明是更有效的。混合神经成像模式提高了准确性，并提供了更大程度的合理控制(Hong和Khan，2017；Khan和Hong，2017；Hong等人，2018)。
研究人员喜欢使用低成本的神经成像手段(Hong等人，2020)。为非实验室设置提供便利的模式也是令人感兴趣的选择。在这方面，脑电和fNIR是最常用的。与其他选择相比，两者都是便携的，而且价格便宜。
电极捕获脑电信号，因为突触后活动引起神经元产生的电流变化(Sazgar和Young，2019年)。几个电极被放置在受试者的头皮上，用于脑电数据的采集。虽然脑电提供了更好的时间分辨率，范围高达∼0.05s，但它只提供了∼10 mm的空间分辨率(Puce和Hämäläinen，2017年；Fu等人，2020年)。时间和空间分辨率的对比比较显示了使用脑电模式时的权衡。与脑电不同，fNIRS是一种光学成像技术，它通过测量光的吸光度来计算大脑内氧合血红蛋白和脱氧血红蛋白的浓度变化。与EEG类似，fNIRS具有成本效益和便携性。然而，与脑电不同的是，fNIRS提供了更好的空间分辨率。此外，fNIR受电噪声的影响较小(Hasan等人，2020；Ghafoor等人，2022)。通过比较证明，fNIR可以补偿EEG的权衡。因此，EEG和fNIRS混合方法在理论上是神经成像方面的突破(Ahn和Jun，2017)。
当fNIRS测量血流动力学反应时，测量中存在先天延迟(Saeed等人，2020)。
已经提出了各种方法来补偿这种缓慢的命令生成。在这方面，可以使用包括EEG和fNIRS技术的混合方法，该方法通过测量初始DIP[即在神经放电开始时，氧合血红蛋白(HBO)水平首先下降]而不是实际的血流动力学反应来进行(Hong和Khan，2017；Kamran等人，2018)。这两种模式之间的另一个对比差异是数据采样的速度。脑电数据采集速率是∼的10-100倍。当使用EEG和fNIRS混合数据时，通常对EEG数据进行下采样，以使其处理与fNIRS数据的处理兼容(Khan和Hasan，2020；Ortega等人，2020)。
下采样可能会丢弃一些有价值的数据段。
由于EEG信号容易受到电噪声的影响，fNIR会受到生理噪声、仪器和实验误差的影响。
实验误差可能是自发的、无意的偏离预定方案的，例如运动伪影或环境中光线强度的变化。通过基于维纳滤波的方法(酱等人，2019年)或基于小波分析的方法(伊斯拉姆等人，2021年)，可以显著减少数据中存在的运动伪影。检测还会在数据中引入噪声，例如来自硬件的噪声。然而，这些噪声信号是高频分量；因此，可以使用低通滤波器来消除它们。呼吸活动或心跳会产生生理噪音。虽然这些噪声是不可避免的，但已有许多方法被报道来对抗这些噪声；常用的技术包括带通滤波器、参数映射和独立分量分析(Rejer和Cieszy‘nski，2019；Vourvopoulos等人，2019；Wankhade和Chorage，2021)。对数据进行去噪进一步去除了数据区域；因此，处理后的数据在大小上甚至比原始数据更小。因此，在对脑电数据进行预处理以匹配fNIRS数据之后，对EEG数据的下采样去除了大量关于大脑活动的有价值的信息。
RP的递归量化分析(RQA)是近年来用于分析脑活动的一种流行方法，因为大脑信号既是递归的又是动态的。一般说来，RP是一种针对周期性和动态信号的非线性评估方法。它是显示时间信号的状态x(N)在相空间中反复出现的可视化。RQA是一种分析技术，用于量化所构建的RP的特征。在文献中，RQA特征分析已被用于癫痫和阿尔茨海默病的脑电信号检测，癫痫放电脑电的耦合和同步等。利用RP特征分析不同睡眠阶段的大脑皮质功能。RQA分析表明，不同睡眠阶段提取了独特的RP(Parro and V Aldo，2018)。一些研究还使用人工神经网络(ANN)(Torse等人，2019年)和支持向量机(SVMs)(Houshyariar和Amirani，2017；赵等人，2021)对提取的RQA特征进行分类。一项研究使用了四层人工神经网络使用RQA措施预测癫痫发作的不同脑电渠道(Torse等人，2019年)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2caf587f01bbb2b03a4bc51412aa3a/" rel="bookmark">
			动态规划算法05-KSum问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KSum问题 简述 CCF、LeetCode这类程序设计竞赛的常见题型。
问题描述 给定一个n个数字的序列（均为整数），求k个数字的和为target的情况有多少种？注意，这里是依据下标选数，也就是说两种情况三个数字一样但是有一个数字的下标在两个情况中不一样，那么算作两种情况。这种题目只要一个最后结果可以使用递归迅速解答，本质上是在填一个二维表；如果要输出所有情况，本质上是填一个三维表。
问题分析 F(n,k,target)表示n个数里面选k个数和为target的情况数目。n个数字里面k个数的和是否为target，可以分为两种情况：第n个数字被选了=F(n-1,k-1,target-nums[n])；第n个数字没有选=F(n-1,k,target)。结果是这两种情况的和。可以依次类推下去。得到边界和状态转移函数为 F(n,k,target)=0;n&lt;kF(n,k,target)=0;n=0 or k = 0F(n,k,target)=m; k=1(m为从0到n的元素中值为target的元素个数）F(n,k,target)=F(n-1,k-1,target-nums[n])+F(n-1,k,target);n&gt;=k 代码 def dp(n, k, target, nums_list, rst): number_list = nums_list if k &gt; n: return 0 if n == 0 or k == 0: return 0 if k == 1: for i in range(n): if number_list[i] == target: rst += 1 return rst if n &gt;= k: return dp(n-1, k-1, target-number_list[n-1], number_list, rst) + dp(n-1, k, target, number_list, rst) if __name__ == '__main__': nums = [1, -1, 0, 1] n = len(nums) k = 3 target = 0 out = 0 # 对这个题目而言就是填写dp[n][[k]的表格 print(dp(len(nums), 3, 0, nums, out)) 补充说明 这种递归做法虽然可以迅速解答，但是不利于填表去回溯查找每种情况的具体取值，后面会使用循环填表来完成这一题。具体代码和更多算法类问题见我的Github，欢迎Star或者fork。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d07f6d8a11810921e1e5c1bf8f58f2a/" rel="bookmark">
			【软件测试学习】MongoDB入门（基于Navicat）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入：电商平台商品信息存储
Mysql：针对不同商品创建不同的表；建一张打表，所有商品存储到表里；公共属性提取出来建表，特有属性各自建表；
MongoDB：没有表结构概念（无需建表），文档内容可以非常灵活地去定制。
与Mysql相比优势在于速度快、操作简单、使用便捷、灵活；
劣势：安全性、数据的一致性、稳定性不够
基本概念 一款流行的文档数据库。
主要特点：高性能（处理请求速度快）、高可用性（大多数时间都能正常运行）、自动扩展（有应对快速负载的能力）、免费开源
MongoDB三元素：数据库、集合（collection）、文档（document）
注解：一个数据库(书)可以包含多个集合(章)，一个集合又可以包含多个文档(每一页)；
MongoDB将数据存储为一个文档，文档数据由键值对组成。
键值对：键：属性/字段；值：属性/字段的取值；（放在一起叫键值对）
文档格式：{key1:value1,key2:value2,kye3:value3…}
键：字符串类型
值：的类型多种多样（数字，字符串、数组、文档等）
环境搭建 安装教程
安装成功
掌握全部操作 常见操作 围绕mongodb三元素----数据库、集合、文档（重点）
查看所有数据库列表
show dbs;建库
use 数据库名;（两重含义：如果use后面跟的数据库名在当前连接下没有，这创建数据库，并选择该数据库；如果当前连接下有该数据库，则直接选择该数据库。）
举例：
use test1;
显示当前连接的是哪个数据库
db;
查看当前数据库下有那些集合
show collections;
创建集合插入文档
db.collection_name.insert()
insert()两种含义:执行插入操作时会去检查collection_name在当前数据库下有没有，如果有则往该集合下插入数据；如果没有则会创建该集合并插入数据。
举例：db.a.insert({x:1});
_id为做文档插入时系统给每个文档分配的一个编号，这个编号在每次数据插入时都会自动生成有别于其他文档的编号作为这个文档的标识。 文档的操作 数据的增删改查
文档的插入
1.插入单个文档
db.a.insert({x:1,y:2,z:3}) ;
并实际没有按表的方式存储
2. 一次性往集合插入多个文档
多个文档以数组的方式插入
数组：一组数据；格式：[data1,data2,…datan]
db.a.insert([{},{},{}]);
当给同一个键赋多个值的时候，取最后一个值
db.a.insert({m:1,m:2,m:3});
允许重复插入多次相同的文档，因为系统每次给文档分配不同的编号（_id）不同的编号代表着不同的文档
允许用户自定义_id，但不可两次取值相同
db.a.insert({_id:编号,键:值});
文档的查询 运算符 算术运算符
$eq equal =
$ne not equal !=
$gt greater than &gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d07f6d8a11810921e1e5c1bf8f58f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e02159ccf39be0bc75019539a6bc4715/" rel="bookmark">
			windows中copy /B 实现文件里藏文件（文件隐写的实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0x01. 问题背景 最近研究图片的图片数字水印技术，发现很简单的两个文件合并成一个文件功能，然而还不影响原始文件的内容，我们将其称为图片文件的隐写。当然，小秘密或者私人文件需要隐藏但是又逃不过别人的多层“扫描”，那也可以通过简单的几行命令实现隐藏。一起来试试吧~~~
0x02. 命令说明 copy 是一个基础的DOS命令，也许在今天已经很少有人使用，但它仍然很实用。我们先看看文档说明，如图：
于是，我们基本的命令格式如下：
copy /B 文件名1+文件名2 合并后的文件名 0x03. 玩转copy 0x03_1. 素材准备 如图，一张res.jpg图片，一个要被隐藏的secret.py文件。
0x03_2. 把文件藏进图片里 打开cmd命令框， 一定处于当前文件目录下，使用如下命令：
copy /B res.jpg+secret.py out.jpg 如图：
表示成功，我们对比一下，左图res.jpg是原图，out.jpg是生成图。
是不是看不出什么差别！再也不担心我的种子被兄弟们要走啦~~~
我们细心求证，真的隐藏了嘛？再看看细节：
out藏入的信息后，内容确实变大了！
0x03_3. 此处有坑 什么坑？那就是如何还原的坑，如果没有专业的工具，我们还是将要隐藏的secret.py转换成zip文件，一方面能再次减小合并后的文件大小，另一方面恢复隐藏内容只需要手动提取即可。因此，我们合并时候命令改变如下：
copy /B res.jpg+secret.zip out.jpg 产生同样的结果，但是我们对比一下文件属性，如图：
右边输出的out.jpg文件大小是不是变小了~~~
0x04. 文件恢复 我们如何将隐藏的文件恢复呢？很简单，只需要将out.jpg改成out.zip，如图：
直接解压即可得到被隐藏的文件secret.py.
0x05. 探索原理 我们将合并后的文件，使用winhex打开，如图：
发现原始文件的前面部分一点不变化，我们拖到最后面，查找十六进制FFD9，它是jpg文件的结束标识，如图：
那后面的一堆内容是什么呢，我们将其复制出来，创建新的文件，发现是一个名为secret.zip的文件，里面包含secret.py。
那么很容易解释原理了，copy /B命令其实就是将两个文件的二进制结合即可，形成了一个新的二进制文件，但是window环境下，jpg文件只识别到文件末尾的FFD9标识符后即不再往后识别展示。因此后面添加什么只要不是FFD9,都是可以正常解析出来看到。
0x06. 写在最后 如果各位看官熟悉kali，当然这种问题也属于CTF杂项中的隐写问题，那么可以直接使用工具：
binwalk查看是否隐写，foremost进行文件的分离即可。又或者用StegSolve去分析文件信息又或者使用winhex查看文件的表示段字符方式进行分离。（想到这里，我感觉我也可以出题去了哈哈哈哈~~~）
上述方法对于MP3文件的组合也可以起到作用，实现音乐的大串烧，如果想用java实现，详细代码请戳：传送门
如果觉得写的不错，麻烦给个关注吧！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03759f71c91175cb0c59034521f6913/" rel="bookmark">
			基于echarts 数据可视化大屏展示全国热点分布高亮地图特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 🚀 基于 Echarts 实现可视化数据大屏响应式展示效果的源码,，基于html+css+javascript+echarts制作， 可以在此基础上重新开发。
本项目中使用的是echarts图表库，ECharts 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。
​
文章目录 ​​前言​​​​一、Echart是什么​​​​二、ECharts入门教程​​​​三、作品演示​​​​四、代码实现​​ ​​1.HTML​​ ​​五、更多干货​​ 一、Echart是什么 ECharts是一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器(IE8/9/10/11，Chrome，Firefox，Safari等)，底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。
二、ECharts入门教程 ​​5 分钟上手ECharts​​
三、作品演示 四、代码实现 1.HTML &lt;!DOCTYPE html&gt;
&lt;html style="height:"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;饼图百分比&lt;/title&gt;
&lt;/head&gt;
&lt;body style="height: 100%; margin:"&gt;
&lt;div id="container" style="height:"&gt;&lt;/div&gt;.
&lt;script type="text/javascript" src="js/echarts.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="js/echarts-liquidfill.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;var value = 0.3;
var data = [value, value, value, ];
var dom = document.getElementById("container");
// dom.style.height=window.innerHeight+'px';
var myChart = echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c03759f71c91175cb0c59034521f6913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b78b985682c12995089886bda3f80b/" rel="bookmark">
			从txt文件中读取复制图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding: utf-8 -*- import shutil import os def objFileName(): local_file_name_list = r"E:\1\test.txt" obj_name_list = [] for i in open(local_file_name_list, 'r'): obj_name_list.append(i.strip().split(' ')) print(obj_name_list) return obj_name_list def copy_img(): # 指定要复制的图片路径 path = r'E:\1\img' # 指定存放图片的目录 for i in objFileName(): new_obj_name = i dir = os.path.split(new_obj_name[0])[1] #['images/71.jpg', 'annotations/71.png']取'images/71.jpg'的71.jpg # file = os.path.split(new_obj_name[1])[1].replace('png','jpg') #取'annotations/71.png'的71.png，再把png换成jpg print(dir) picpath = r'E:\1\JPEGImages' + '\\' + dir #已有图片路径 # shutil.copy(picpath, path + '\\' + file) shutil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b78b985682c12995089886bda3f80b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256cd50c369ea7a766ebdb586482956c/" rel="bookmark">
			[1166]CDH集群删除主机节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CM 集群下线节点，主要参考官方文档：
操作前调优文档： https://docs.cloudera.com/documentation/enterprise/6/latest/topics/cm_mc_decomm_host.html#concept_urw_wyw_cy操作文档：https://docs.cloudera.com/documentation/enterprise/6/latest/topics/cm_mc_host_maint.html#cm_mc_host_maint 具体步骤如下：
1、开始下线前的自检
# 自检 hdfs 文件是否有损坏 hdfs fsck / -list-corruptfileblocks -openforwrite -files -blocks -locations # 如果文件有损坏，需要进行修复 hdfs fsck file_name -move 2、选择需要下线的主机，开始下线。为了避免下线过程中出现数据丢失的风险，一次下线的主机数量要小于 hdfs block 的副本数量。
3、选择迁移时是否要同步迁移数据，一般时要选择同步迁移数据。然后开始下线节点
4、接着会显示节点下线的进度。同时在NameNode web ui 上会显示 hdfs block 文件向其他节点的同步进度（主要看 Number of Under-Replicated Blocks）。
在 NameNode Summary 页面，可以看到正在下线的节点数量和待迁移的 hdfs block 数量。
5、下线结束后，可以去集群后台使用命令查看各个节点在迁移后的磁盘使用率
hdfs dfsadmin -report 在下线过程中，可能存在以下情况：
参数调优时，设置参数过大，同步速度快但是集群负载高，导致失败；
网络波动导致 NameNode 主备切换，web界面显示下线过程结束了，但后台还在进行；这时会出现block还未迁移完的情况（Under-replicated blocks显示不为0），可以等hdfs自动修复(推荐)，也可以手动修复（速度也很慢）。 手动修复执行脚本如下：
hdfs fsck / | grep 'Under replicated' | awk -F':' '{print $1}' &gt;&gt; /tmp/under_replicated_files 然后循环修复： for hdfsfile in `cat /tmp/under_replicated_files`; do echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/256cd50c369ea7a766ebdb586482956c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2baf74a0327cdbad7cf4aabe99b8fe6a/" rel="bookmark">
			Required Long parameter ‘xx‘ is not present,请求的Long类型参数不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一次测试第二次测试第三次测试第四次测试第五次尝试第六 直接看这里,没有废话本次涉及到的两个注解@RequestParam和@RequestBody 关于前后端交互中传参的问题
起因是前端需要给后端传递两个long类型的id,如果是get请求那没问题,可我需要的是post请求,现在我就来一一复现我出错的原因,直接看第六
第一次测试 前端是用postman传json(就是这让我入坑,坑死我了)
这个json很有问题,后面再说
{ "id1":64, "id2":919 } 后端代码
public ResponseData focus(long id1, long id2){} 然后运行出错
//可选的长参数“id1”存在，但由于被声明为基元类型，因此无法转换为空值。考虑将其声明为对应基元类型的对象包装器 java.lang.IllegalStateException: Optional long parameter 'id1' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type. 我就改成包装类Long继续测试
第二次测试 最大的bug来了,类型改为了包装类
public ResponseData focus(Long id1, Long id2){} 但是后端根本就取不到这个Long类型的id,这怎么行呢,get请求都没问题,一度想让我放弃post改用get
第三次测试 然后我就再改
//注意@RequestParam注解要有默认值或者@RequestParam(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2baf74a0327cdbad7cf4aabe99b8fe6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08558e997a69d5122edf76991f138f24/" rel="bookmark">
			【配置文件】Redis - redis.conf - 学习/实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.应用场景
主要用于学习和配置redis，合理准确高效进行项目开发。 2.学习/操作
1.文档阅读 Redis configuration | Redis -- 官方所有的redis.conf配置文件都在这里
https://raw.githubusercontent.com/redis/redis/6.2/redis.conf
2.整理输出 配置内容还是比较多的，但是多看多去实践，总能掌握，会很熟悉。
推荐学习方法：「同样适用于其他的软件/服务」 用到的时候，就认真阅读那一块的配置内容。
没必要将所有的配置都全部弄清楚「比较花时间，还有比较枯燥」
2.1 6.2 版本 # Redis configuration file example. # # Note that in order to read the configuration file, Redis must be # started with the file path as first argument: # # ./redis-server /path/to/redis.conf # Note on units: when memory size is needed, it is possible to specify # it in the usual form of 1k 5GB 4M and so forth: # # 1k =&gt; 1000 bytes # 1kb =&gt; 1024 bytes # 1m =&gt; 1000000 bytes # 1mb =&gt; 1024*1024 bytes # 1g =&gt; 1000000000 bytes # 1gb =&gt; 1024*1024*1024 bytes # # units are case insensitive so 1GB 1Gb 1gB are all the same.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08558e997a69d5122edf76991f138f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bddd216dfd48682b7ae1cd2db9cdbe9/" rel="bookmark">
			sqli-labs靶场安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqli-labs靶场安装 一、环境准备二、工具及靶场介绍1.Phpstudy介绍2.sqlilabs靶场介绍 三、安装步骤1.phpstudy安装2.sqlilabs靶场安装1）下载sqlilabs2）解压sqlilabs3）放入服务器中4）配置sqlilabs5）访问sqlilab6）靶场默认配置7）安装成功 四、其他问题1.环回地址抓不到包2.关卡乱码/BUG3.第7关文件上传导入不进去 一、环境准备 服务器环境：phpstudy
下载链接：https://www.xp.cn/
Sqlilabs靶场：sqlilabs
下载链接：https://github.com/Audi-1/sqli-labs
二、工具及靶场介绍 1.Phpstudy介绍 PhpStudy国内12年老牌公益软件，集安全，高效，功能与一体，已获得全球用户认可安装，运维也高效。
支持一键LAMP,LNMP,集群,监控,网站,FTP,数据库,JAVA等100多项服务器管理功能。
2.sqlilabs靶场介绍 Sqlilabs是一个学习sql注入的平台，GET和POST场景包括了许多基本的实验内容，例如：基于错误的注入、盲注、更新查询注入、插入查询注入、Header注入、二次注入、Bypass WAF、堆叠注入等等。
三、安装步骤 1.phpstudy安装 Phpstudy安装比较简单，这里的过程我就不演示了，我这里是安装的是phpstudy2018，感觉小巧一点。具体的功能可以自己研究一下，通常来说不遇到特殊情况都不需要改动什么内容。Phpstudy默认的数据库账号密码：root/root，建议也别改。
2.sqlilabs靶场安装 1）下载sqlilabs 下载压缩包，由于是国外网站可能存在有些人加载不进去或者很慢的情况，需要耐心点，不过这个好像CSDN有加速。
2）解压sqlilabs 解压的时候会出现弹窗让你选择是否进行文件替换，这时候一定要选择全部选是，负责24关可能会存在BUG，如果24关出现BUG可以重新解压一次，依旧选择全部选是，即可解决。
3）放入服务器中 打开phpstudy界面选择右下角其他选项菜单，然后选择里面的网站根路径。由于我是虚拟机，不好截图。
将解压的sqlilabs放入phpstudy的www文件夹中。由于默认的sqlilabs的文件夹名太长，可以自行进行修改。
4）配置sqlilabs 进入sqlilabs文件夹中找到sql-connections文件夹，打开db-creds.inc配置文件夹，在$dbpass后面引号中加入数据库密码，phpstudy默认的数据库账号密码：root/root。
5）访问sqlilab 若安装在虚拟机，请访问虚拟机地址+文件夹名称如：192.168.10.150/sqli-labs。
若是实体机，请访问环回地址+文件夹名称，如：127.0.0.1/sqli-labs。
6）靶场默认配置 访问成功后，点击setup/reset database for labs，让sqlilabs靶场自动配置数据库内容。
配置过程画面，全程无需手动配置，靶场自动执行。
7）安装成功 此时重新访问链接即可进入相关的关卡。
四、其他问题 1.环回地址抓不到包 使用127.0.0.1在某些关卡会抓不到包，这时候访问sqlilabs靶场时，使用自己电脑的IP地址即可解决。但是还是不建议把靶场安装在自己的实体机上。个人感觉乱，而且若出问题的话来回重置也不好。
2.关卡乱码/BUG 在某些关卡会出现乱码或者bug等情况，这时候需要调整phpstudy的配置版本。
3.第7关文件上传导入不进去 搭建的靶场会出现导入不进去的情况，这里需要找到mysql数据库下的my.ini,在里面添加secure_file_priv=""并重启服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be53c1756a0a100c7b5bc602ea509bee/" rel="bookmark">
			如何安装centos详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部：打开VMware Workstations
第二步：点击创建新的虚拟机
第三步： 推荐初学者点击推荐 （没有太大区别。自定义字面理解 就是自己定义，除非非常了解Linux，否则不推荐）
第四步：下一步后，我们点击稍后安装 ，先给centos分配个空间 第五步：下一步后 点击 Linux 和 我们下载的镜像centos7
第六步：下一步后，我们更改主机名，同时自定义安装路径，不建议安装到C盘
第七步：
第八步 ：下一步后 编辑 自定义硬件 点击关闭 查看配置信息，确认后点击完成。
第九步：安装centos 空间已经设置好。
————————————————————————————安装开始安装centos
第一步：
第二步：将鼠标点击到黑色板块中，用键盘的上下键移动光标到最上边 回车enter
第三步：接着回车 此时需要时间等待安装
等待后：
出现页面需等待 红框中的三角消失
以上三种都可以。都可以 桌面话更适合基础学习，但建议直接用小黑框
以上自动配置就可以，如果 对分许有要求可以自己分配 引导区、交换区、内存等
以上比较难，网络配置的关键一定要点击应用
设置好root用户密码。等待右下角出现完成。点击完成。等待 点击重启
最后：登录执行命令 查询IP
可能会出现IP出现的不一样。
把自动分配IP关掉 进入网络配置文件命令
重启网络
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42b599a613e3d99edc51ca2f4a4e3f9/" rel="bookmark">
			win10/win11自带的截图和剪贴板快捷键，摆脱第三方截图工具的烦恼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自带截图快捷键：win+shift+s
截图后屏幕右下角会显示截图缩略图，点击“截图工具”可对截图进行编辑
截图工具里面的功能很丰富，可根据需要进行编辑
2、截图之后如何粘贴，查看剪贴板快捷键：win+v
将鼠标光标放入需要插入图片的位置，win+v唤出剪贴板，选中截图的图片，图片就自动粘贴进来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0182dd4288745ef0b6b4c2165809a5a/" rel="bookmark">
			Android studio接真机调试 logcat框突然不打印日志了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以尝试：
1，重启Android studio
2，把USB重新插拔一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1c7159d01fd6c2fad4f4f522afd560/" rel="bookmark">
			java 求一组数据的各自所占百分比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：
计算比例时，每个数据除以数据之和，很有可能除不尽，导致最终比例之和不等于1，所以将最后一个数据的比例设定为 1-前面数据比例之和；
本次比例保留两位小数，并以小数展示，如果想展示样式为40.50%，请自行×100后再进行保留两位小数。
/** * 计算数组中数字的比例 * * @param arr * @return */ public static List&lt;Double&gt; getDoubleRatio(double[] arr) { List&lt;Double&gt; ratioList = new ArrayList&lt;&gt;(); NumberFormat instance = NumberFormat.getInstance(); // 保留小数点后两位（四舍五入）， instance.setMaximumFractionDigits(2); double sum = 0; // 求和 for (int i = 0; i &lt; arr.length; i++) { sum += arr[i]; } // 计算各自所占百分比 double ratioSum = 0; for (int i = 0; i &lt; arr.length; i++) { if (arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1c7159d01fd6c2fad4f4f522afd560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49baf647ee7eb1f4dc2543f6aee6947/" rel="bookmark">
			bash: line 5: bgzip: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息：
bash: line 5: bgzip: command not found
解决方式：
conda install tabix
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f92810d933ecd186bf7fe6abe8d595/" rel="bookmark">
			Android 小部件播放视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在对小组件进行迭代, 之前已经解决过一些问题, 例如:
图片的圆角怎么在小组件上展示并兼容多个系统版本小组件后台怎么更新,如何将小组件拆分成单独模块 对于小组件播放视频, 找不到直接可以调用的api, 因为android对于小组件又很多限制,比如:
RemoteViews 对象（因而应用微件）可以支持以下布局类：
FrameLayoutLinearLayoutRelativeLayoutGridLayout 以及以下微件类：
AnalogClockButtonChronometerImageButtonImageViewProgressBarTextViewViewFlipperListViewGridViewStackViewAdapterViewFlipper 不支持这些类的后代。
RemoteViews 还支持 ViewStub，它是一个大小为零的不可见视图，您可以使用它在运行时以懒散的方式扩充布局资源。
详细参考:
https://developer.android.com/guide/topics/appwidgets?hl=zh-cn
简单来说就是, 只支持特定的几种布局,不支持ConstraintLayout等, 不支持自定义view; 如果你使用了, 那么显示小组件时候就会出现类似 “载入小部件出错”的信息;
陌陌的一款贴贴实现了小组件播放视频, 经过一番吐血调研和研究, 我实现了类似的效果, 包括显示视频并缓存,显示图片, 小组件后台实时更新整理成了一套Demo;
demo示例效果 ​​​​​​​
方案已在线上验证，欢迎大佬们来找我探讨
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7462e06b0df62ff5f5edea1e98c6c9ea/" rel="bookmark">
			C语言基本语法——循环篇（三种常见的循环）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、什么是循环？二、常见的几种循环 1.while循环2.for循环3.do while 循环总结 前言 对于新手小白来说，他们会困惑于循环是什么？循环可以用来做什么，C语言中有哪些循环，这些循环又该怎么使用呢？因此，本文总结了C语言中常见的循环类型，专门为小白解决循环这个难题。
一、什么是循环？ 循环是程序设计语言中反复执行某些代码的一种计算机处理过程，常见的有按照次数循环和按照条件循环。
循环体被重复执行的次数由循环条件控制，称为控制表达式（controlling expression）。这是一个标量类型的表达式，也就是说，它属于一个算术表达式或指针表达式。如果控制表达式的值不等于 0，循环条件为 true，反之，循环条件为 false。
语句 break 和 continue 用于在一次循环还未执行完时，跳转出循环或返回到循环头部。
二、常见的循环 1.while循环 代码如下：
int main() { int i = 1; while (i &lt; 10) { if (i == 5) { break; } printf("%d ", i); i = i + 1; } return 0; } 这里的i&lt;10就是循环进行的判断条件，每一次进行循环时，首先进行判断，如果i&lt;10，则进入循环，否则跳出，恰当的使用判断条件可以更好的运行程序，避免出现死循环的情况。
该程序的输出结果：1 2 3 4
原因：break存在，跳出了循环，停止后期的所有循环，直接终止循环。
break在while循环中的作用：
用来永久终止循环。
2.for循环 代码如下： int main() { int i = 0; for (i = 0; i &lt; 10; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7462e06b0df62ff5f5edea1e98c6c9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ee77db43c8ecdf1abb06da65608433/" rel="bookmark">
			【Java】PriorityQueue优先级队列（堆）&#43;比较器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
铺垫
堆
建堆
基本公式
调整为大(小)根堆
堆的增加
堆的删除 正文：
比较
重写基类的equals()比较方法：
内部比较器——Comparable.compareTo(E o)：
外部比较器——Comparator.compare(T o1, T o2)：
源码粗略分析
常用构造方法
实现Comparable接口 实现Comparator接口
改为大根堆
对于基本类型：
对于引用类型：
比较器快速写法
铺垫 堆 优先级队列的底层是一个数组，但这个数组又比较特殊——二叉树通过层序遍历存放到该数组的数据。这样存放的方式就是堆这种数据结构。
大根堆：如果在堆中，每个根结点的值大于两个孩子结点的值。（对左右孩子无要求）
小根堆：如果在堆中，每个根结点的值小于两个孩子结点的值。（对左右孩子无要求）
建堆 基本公式 调整为大(小)根堆 在一个一维数组中：
1.对于每一个根结点都要调整为大小根堆。
2.调整时，先要找到较大的孩子
3.然后二者交换，继续向下调整该根结点下面的结点。
4.调整时可能会存在越界的情况，孩子结点可能会越界。
public void createHeap() { //建大根堆 //对每一个根节点使用向下调整算法 //最后一个孩子 c = length - 1 //c = 2 * p +1 //p = (c - 1)/2 for (int parent = (array.length - 1 -1) / 2; parent &gt;= 0; parent--) { shiftDown(parent, usedSize); } } //向下调整 private void shiftDown(int parent, int length) { int child = 2 * parent + 1; while (child &lt; length) { //先判断孩子是否越界 if (child &lt; length - 1 &amp;&amp; array[child] &lt; array[child + 1]) { child++; } if (array[parent] &lt; array[child]) { swap(array, parent, child); parent = child; child = 2 * parent + 1; } else { break; } } } private void swap(int[] array, int x, int y) { int tmp = array[x]; array[x] = array[y]; array[y] = tmp; } 堆的增加 在堆里添加完数据后，应该还要保证堆为大(小)根堆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ee77db43c8ecdf1abb06da65608433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27c0a2c4b2d108e004fea3f14d6975e/" rel="bookmark">
			Epoll图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图解 | Epoll怎么实现的-51CTO.COM
epoll详解_Ineffable__的博客-CSDN博客_epoll详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd74f76aa666d44e2192bb419b68fe7/" rel="bookmark">
			springboot打包分离lib和配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：每次上传都几百兆的文件，太慢了，而且配置文件改一下就要重新打包比较麻烦。就修改了打包方式，每次只需要上传代码的jar包就行了。
修改pom文件
&lt;build&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/lib&lt;/outputDirectory&gt; &lt;excludeTransitive&gt;false&lt;/excludeTransitive&gt; &lt;stripVersion&gt;false&lt;/stripVersion&gt; &lt;includeScope&gt;runtime&lt;/includeScope&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;includes&gt; &lt;include&gt; &lt;groupId&gt;cn.jstars&lt;/groupId&gt; &lt;artifactId&gt;datatocloud&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;*.yml&lt;/exclude&gt; &lt;exclude&gt;*.xml&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 最后把 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd74f76aa666d44e2192bb419b68fe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b81483502c6e67aa967ffa23a9ec9d7/" rel="bookmark">
			HiveQL常用参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、并行参数二、小表数据内存运行参数三、数据倾斜时负载均衡参数四、调整内存参数五、调整占用CPU数量参数六、调整map和reduce的数量参数七、动态分区参数八、物化with as九、本地模式十、显示表头十一、大数据集报错Java heap space 一、并行参数 （一）允许不同的job并行执行。当脚本中使用较多个UNION ALL或者不相关联的临时表时，使用并行参数将明显提高执行速度，但同时会占用更多资源。
SET hive.exec.parallel = true; （二）并行数默认为8，可以根据需要调高。
SET hive.exec.parallel.thread.number = 32; 二、小表数据内存运行参数 （一）自动对比表数据，将小表放内存执行。利用mapjoin的方式，直接在map阶段进行join操作，省去reduce过程，提高性能。
SET hive.auto.convert.join = true; （二）设置小表的大小（单位是字节）。结合这两个参数，关联维度时，可以把左联结的维表先根据过滤条件做成小数据量的临时表再关联，以此来提高性能。
SET hive.mapjoin.smalltable.filesize = 25000000 三、数据倾斜时负载均衡参数 （一）当脚本运行时长时间停留在reduce=99%，reduce执行缓慢。
SET hive.groupby.skewindata = true; 四、调整内存参数 （一）调整每个Map Task需要的内存量
SET mapreduce.map.memory.mb = 4096; （二）调整每个Reduce Task需要的内存量
SET mapreduce.reduce.memory.mb = 4096; （三）调整每个Map Task的JVM最大使用内存
SET mapreduce.map.java.opts = Xmx3276M -Djava.net.preferIPv4stack = true; （四）调整每个Reduce Task的JVM最大使用内存
SET mapreduce.reduce.java.opts = Xmx3276M -Djava.net.preferIPv4stack = true; 五、调整占用CPU数量参数 （一）调整每个Map Task可用最多CPU Core数量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b81483502c6e67aa967ffa23a9ec9d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b525768c54ac1290d3af27b73c842497/" rel="bookmark">
			Java终止线程的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：Java终止线程的三种方式
停止一个线程通常意味着在线程处理任务完成之前停掉正在做的操作，也就是放弃当前的操作。
在 Java 中有以下 3 种方法可以终止正在运行的线程：
使用退出标志，使线程正常退出，也就是当 run() 方法完成后线程中止。使用 stop() 方法强行终止线程，但是不推荐使用这个方法，该方法已被弃用。使用 interrupt 方法中断线程。 1. 使用标志位终止线程 在 run() 方法执行完毕后，该线程就终止了。但是在某些特殊的情况下，run() 方法会被一直执行；比如在服务端程序中可能会使用 while(true) { ... } 这样的循环结构来不断的接收来自客户端的请求。此时就可以用修改标志位的方式来结束 run() 方法。
public class ServerThread extends Thread { //volatile修饰符用来保证其它线程读取的总是该变量的最新的值 public volatile boolean exit = false; @Override public void run() { ServerSocket serverSocket = new ServerSocket(8080); while(!exit){ serverSocket.accept(); //阻塞等待客户端消息 ... } } public static void main(String[] args) { ServerThread t = new ServerThread(); t.start(); ... t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b525768c54ac1290d3af27b73c842497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b55e9c10231f182b31cf0d67d2fa0e25/" rel="bookmark">
			node.js 安装教程 (Windows zip 版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js 安装教程 (Windows zip 版) 1 官网 地址：Node.js (nodejs.org)
界面：
2 下载 地址：下载 | Node.js (nodejs.org)
自行选择安装版本，这里我选择 Windows 二进制文件 (.zip) 64位
3 安装 将文件解压到要安装的位置，并创建 node_global 和 node_cache 两个文件夹。
4 配置 ① 环境变量
将 node.exe 所在的目录添加到 系统变量 =&gt; path 环境变量，这样我们在使用命令行时就可以在任意路径使用 node 命令了，同时该目录下有一个 npm.cmd 文件，打开文件其实就是将我们的 npm 命令映射到 node.exe npm-cli.js，由于存在该映射所以只要把 node.exe 所在的目录添加到 path 环境变量，就可以在任何目录下执行 npm install 了。
在命令框中输入以下命令进行测试：
node -v npm -v 到这里 node 就安装好了，但为了我们更方便使用 node，建议进行如下配置。
② 使用 npm 安装模块分为本地安装和全局安装。
本地安装：npm install express 会安装到当前项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b55e9c10231f182b31cf0d67d2fa0e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1a6763858cc3b0a3126ca91c9035163/" rel="bookmark">
			win10&#43;pcl1.8.1&#43;vs2017,debug、release配置成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 VS2015中自由切换debug和release编译模式的配置方法：https://www.bilibili.com/video/BV1gF411E7Ly?spm_id_from=333.999.0.0点云法向量显示 LNK2001无法解析的外部符号 __imp_xxx这样的错误，有可能是附加依赖库中缺少opengl32.lib，在库中添加 “opengl32.lib”即可，也可以在头上添加#pragma comment(lib,“opengl32.lib”)解决网址：https://blog.csdn.net/weixin_50514372/article/details/116993173?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-9-116993173-blog-116330260.pc_relevant_3mothn_strategy_and_data_recovery&amp;spm=1001.2101.3001.4242.6&amp;utm_relevant_index=12 常规引用 包含目录
C:\Program Files\OpenNI2\Include;C:\Program Files\PCL 1.8.1\3rdParty\VTK\include;C:\Program Files\PCL 1.8.1\3rdParty\Qhull\include;C:\Program Files\PCL 1.8.1\3rdParty\FLANN\include;C:\Program Files\PCL 1.8.1\3rdParty\Eigen\eigen3;C:\Program Files\PCL 1.8.1\3rdParty\Boost\include\boost-1_64;$(PCL_ROOT)\include\pcl-1.8
库目录
C:\Program Files\OpenNI2\Lib;C:\Program Files\PCL 1.8.1\3rdParty\VTK\lib;C:\Program Files\PCL 1.8.1\3rdParty\Qhull\lib;C:\Program Files\PCL 1.8.1\3rdParty\FLANN\lib;C:\Program Files\PCL 1.8.1\3rdParty\Boost\lib;C:\Program Files\PCL 1.8.1\lib
附加依赖项 [属性管理器]，添加[属性页]，设置[链接器]--[输入]--[附加依赖项]。
debug版本：
vtknetcdf_c++-gd.lib pcl_common_debug.lib pcl_features_debug.lib pcl_filters_debug.lib pcl_io_ply_debug.lib pcl_io_debug.lib pcl_kdtree_debug.lib pcl_keypoints_debug.lib pcl_ml_debug.lib pcl_octree_debug.lib pcl_outofcore_debug.lib pcl_people_debug.lib pcl_recognition_debug.lib pcl_registration_debug.lib pcl_sample_consensus_debug.lib pcl_search_debug.lib pcl_segmentation_debug.lib pcl_stereo_debug.lib pcl_surface_debug.lib pcl_tracking_debug.lib pcl_visualization_debug.lib libboost_atomic-vc141-mt-gd-1_64.lib libboost_bzip2-vc141-mt-gd-1_64.lib libboost_chrono-vc141-mt-gd-1_64.lib libboost_container-vc141-mt-gd-1_64.lib libboost_context-vc141-mt-gd-1_64.lib libboost_coroutine-vc141-mt-gd-1_64.lib libboost_date_time-vc141-mt-gd-1_64.lib libboost_exception-vc141-mt-gd-1_64.lib libboost_fiber-vc141-mt-gd-1_64.lib libboost_filesystem-vc141-mt-gd-1_64.lib libboost_graph-vc141-mt-gd-1_64.lib libboost_graph_parallel-vc141-mt-gd-1_64.lib libboost_iostreams-vc141-mt-gd-1_64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1a6763858cc3b0a3126ca91c9035163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdb84ba5b2bff77b1bb307b1c41a790/" rel="bookmark">
			Mybatis使用IN()查询出现的错误解决记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 使用IN进行多个Id查询时，在数据库管理工具中测试时没问题的，后来放到项目里面，发现查的总是不对，项目中使用的是@Select注解，需要替换的部分是IN(#{ids})这样写的。
原代码如下：
@Select("select oc_material_variable.id as material_variable_id,oc_material_variable.name,oc_material_variable.descr,oc_material_variable.example,oc_material_variable.min_length,oc_material_variable.max_length from oc_scan_variable,oc_material_variable\n" + "where oc_scan_variable.material_variable_id=oc_material_variable.id\n" + "and oc_scan_variable.material_id in (#{ids}) group by oc_scan_variable.material_variable_id") List&lt;HashMap&lt;String,Object&gt;&gt; getNeedValueByIds(String ids); 问题分析 查询很多博客说通过映射文件里for标签进行解决，其实不用这么麻烦，问题根本是占位符的书写问题，之前一直用的是#{}，这种写法Mybatis会自动在需要替换的地方加上“”，假如我们这里的ids是1,2,3，那么使用#{}最后生成的代码就是IN("1,2,3")，显然会出现问题。
问题解决 解决办法就是使用${}，占位符即可解决，这个占位符不会添加任何东西。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f268d7786b14777761493f0d8ef6b4/" rel="bookmark">
			深度学习3—用三层全连接神经网络训练MNIST手写数字字符集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章：深度学习2—任意结点数的三层全连接神经网络
距离上篇文章过去了快四个月了，真是时光飞逝，之前因为要考博所以耽误了更新，谁知道考完博后之前落下的接近半个学期的工作是如此之多，以至于弄到现在才算基本填完坑，实在是疲惫至极。
另外在这段期间，发现了一本非常好的神经网络入门书籍，本篇的很多细节问题本人就是在这本书上找到的答案，强烈推荐一下：
上篇文章介绍了如何实现一个任意结点数的三层全连接神经网络。本篇，我们将利用已经写好的代码，搭建一个输入层、隐含层、输出层分别为784、100、10的三层全连接神经网络来训练闻名已久的mnist手写数字字符集，然后自己手写一个数字来看看网络是否能比较给力的工作。
在正式做之前，还是按照惯例讲几个会用到的知识点。
mnist数字字符集的结构解析，这个我单独写了一篇文章来做介绍了，如有需要了解请先移步：深度学习3番外篇—mnist数据集格式及转换我们之前都是直接放入几个数作为输入，然后给网络几个数作为目标来训练网络的，而mnist手写字符集给我们的是一堆手写的28*28像素的图片还有图片对应的手写数字标签，我们怎么对它进行转换？
转换是这样的，我们把图片的所有像素当做输入，也就是28*28=784个像素直接作为输入，然后用0~9总共十个数作为输出目标的指引(当标签是“5”，则目标输出为0.01、0.01、0.01、0.01、0.01、0.99、0.01、0.01、0.01、0.01，依次类推)。
这里有一点比较有意思，为什么要用0.01而不是0，用0.99而不是1？
答案是我们用的激活函数永远不能输出0，1这两个数，因此如果取了这两个数则网络永远无法达到预期，会有训练过度的可能。
另外，细心的你可能也想到了，我们之前输入的数都是在0-1的范围内的，而像素的灰度取值范围在0-255，因此我们需要先对灰度值做一个归一化处理然后再放入网络中。
这里归一化处理的方式也比较有意思，假设X为输入，我们的处理公式如下：
X ÷ 255 × 0.99 + 0.01 X÷255×0.99+0.01 X÷255×0.99+0.01
为什么要乘0.99再加0.01？
答案是我们不希望输入取到0值，因为0有个小学生都知道的特点，任何数乘以它都等于0，因此无论输入层到隐含层的权值是多少，在输入等于0的时候都是一样的，这会影响权值的更新。我们前面只确定了输入和输出层的节点个数，隐含层的节点个数还不知道，那我们怎么选取呢？答案可能让人难过，没有绝对正确的公式，只有几个经验公式(似乎有优化算法可以确定隐含层节点个数，后面如有需要开一篇专门讨论)：
m = n + l + α m=\sqrt{n+l}+\alpha m=n+l ​+α m = l o g 2 n m=log_{2}n m=log2​n m = n l m=\sqrt{nl} m=nl ​
其中， m m m是隐含层节点数， n n n是输入层节点数， l l l是输出层节点数， α \alpha α是 0 0 0~ 10 10 10之间的常数
本篇取第三个，最后因为比较接近100，就直接取了100(怎么感觉好随意。。。)。因为这次的输入节点有784个，算是比较多的，要十分注意在初始化网络参数的时候要避免参数与输入节点的积之和过大的情况出现。因为我们用的是sigmod函数作为激活函数，它的波形如下图所示：
可以看到，如果输入的数值过大或过小，波形会趋于平缓，也就是通常所说的“梯度消失”，我们要避免这种情况的出现。当然这也是用sigmod函数作为激活函数的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f268d7786b14777761493f0d8ef6b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a85b8b3306436793bce8fc1520ffb1fb/" rel="bookmark">
			C语言数据结构之链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的文章我们就一直说，学一个新东西之前一定要弄明白它的作用是什么，我们为什么要用它。之前讲C语言时我们讲到数组，数组的实质是一种顺序储存、随机访问、存储单元连续的线性表，既然存储单元连续，那么对其进行插入和删除操作时需要移动大量的数组元素，这时我们便需要用到链表。
链表是由结构体和指针配合使用构成的一种动态数据结构（大家要是对C语言的指针和结构体不熟练的话可以去看看我之前的文章—嵌入式开发之C语言基础五（指针详解）和嵌入式开发之C语言基础七（结构体详解）），实质是链式存储、顺序访问的线性表，用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的。
链表中的每个元素称为一个节点，每个节点都可以存储在内存中的不同位置，每个节点都包括两部分：第一部分为数据域，用于存储元素本身的数据信息；第二部分为指针域，其是结构体指针，用于存储其直接后继的节点信息。
创建节点和链表
创建一个结构体，其成员包括用户数据即data和用于指向下一个结构体的结构体指针*next，这里我们所说的结构体就是节点，在main函数里我们对其data进行了赋值，对next进行了下一个节点的指向，这样一个节点就创建了，通过next给链接在了一起形成了链表。 再通过打印函数把链表打印出来：
既然有了链表，那么我们就可以对其进行增删查改等一系列操作：
获得节点数
上面这段代码就获得一个链表中的节点数，逻辑应该很简单，当p != NULL时就一直遍历，同时count一直++。
查询节点
上面这段代码就是查询一个链表中是否有某个节点，逻辑也很简单，一直遍历，同时一直与要查询的data进行判断。
从某个节点后面插入新节点
实现插入节点功能重点就在于能否把新节点与旧节点进行链接，上面代码的实现逻辑就是：找到要被插入的节点后将其指向后一个节点的结构体指针指向要插入节点，要插入的节点再将其指向后一个节点的结构体指针指向被插入的节点原本指向的下一个的节点。这里看代码比看文字讲解要容易理解一点，大家可以多看看代码。
从某个节点前面插入新节点
从某个节点前面插入新节点比从后面插入要多进行一次判断，判断是否为头节点，另一个要注意的地方就是while里的判断条件是用p-&gt;next来判断的，这是因为我们可以通过p来找到p的后一个，但是找不到p的前一个，所以这里我们灵活变换一下，代码实现逻辑和从后面插入大同小异。
删除节点 删除一个节点实现逻辑也很好理解，肯定也是要不断遍历，找到对应节点后把原本指向它的结构体指针指向它的下一个，然后按道理我们要把它free掉，但是经过测试和查找资料发现只有是malloc出来的空间才能使用free，不然运行会出现段错误。
从头插入节点
这段代码实现了从头节点开始插入新节点，所以这样出来的链表中节点的顺序要注意一下：第一个插入的节点是尾节点。 我们分析这段代码可以看到只有我们不输入0就可以不断创建新节点，而且把每个新malloc出来的新节点的next指向上一个malloc出来的节点，这里要注意每次malloc一个新节点一定要把其next指向NULL，因为我之前是在虚拟机里写得代码，会默认malloc后节点的next会指向NULL，这也导致我把代码拷贝到windows中的编译器中运行会出现错误。
创建链表（头插法）
大家仔细看代码就可以发现这个所谓的创建链表就是把上段代码给拆分了，在函数creatLink中调用函数insertFromHead，当然这一定程度上是为了代码的实用性。
创建链表（尾插法） 上面的代码就是实现尾插法创建链表，这种方式创建出链表中节点的顺序也就是我们正常所认为的顺序，最先的就是头。和头插法不一样的是尾插法要先遍历的最后一个节点，再用最后一个节点的next指向新创建的节点 。
以上就是数据结构中关于链表的基础知识，希望大家自己也去实现一下这几个链表功能，整个代码我会放到下面，最后希望大家学业有成，共勉。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Test { int data; struct Test *next; }; void print_Link(struct Test *head) { struct Test *p = head; while(p != NULL) { printf("%d ",p-&gt;data); p = p-&gt;next; } printf("\n"); } int getNodeNum(struct Test *head) { int count = 0; struct Test *p = head; while(p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a85b8b3306436793bce8fc1520ffb1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608ce270db8428a9e609fff947772fc4/" rel="bookmark">
			Arcgis主页面字体太小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
1、右击桌面Arcmap图标，选择属性。
2、选择兼容性＞更改高DPI设置。
3、勾选替代高DPI缩放行为，以后选择系统（增强）。
4、重新打开软件字号正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/762b592b3104d38ec07c1021fbeb093b/" rel="bookmark">
			数字孪生全要素场景介绍（L0-L5级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 全要素场景概述 全要素场景，基于真实的地理信息，集合物理世界各种要素，通过计算机实时渲染而生成的可交互三维仿真场景，可以广泛应用于各行业数字孪生应用构建。
全要素场景是构建数字孪生应用的核心，根据数据源、使用环境和场景精细度，从宏观到微观，划分为L0-L5六个级别，基于全要素场景，可以便捷高效地进行二次开发、构建行业数字孪生应用。
级别场景主要内容L0地块级包括地形、区域边界、卫星影像，不区分世界、国家、省、市等级别。L1城市级包含地形、主要建筑、路网（精确到县道）、水系的低精度模型，包含下一级行政区划分界线和下一级行政区划地名散点标牌。L2城区级包含地形、主要建筑、路网（精确到1级道路）、水系、主要植被的低精度模型，包含下一级行政区划分界线和行政区划地名散点标牌。L3园区级大面积城市由设计资产自动生成摆放，包含地形地貌、主要建筑、路网、水系、植被、城市基础设施的高精度模型建模，重点建筑进行手工建模超高精度还原。L4建筑级基于模型资产进行超高拟真建模，精确还原建筑/设备外观材质、纹理细节、复杂结构，包含建筑外围设施、植被、部件、车道线、车辆、行人、楼体结构、地面、墙面、栏杆、窗框等要素的超高精度模型和贴图效果。L5设备/室内精模超高精细度、拟真建模还原，可高精度还原室内建筑/设备外观材质、纹理细节、复杂结构、内部零部件、管线等细节，准确还原要素对象材质质感。 二、 场景级别划分介绍 1. L0地块级 场景描述：包括地形、区域边界、卫星影像，不区分世界、国家、省、市等级别
最小观看距离：10000m
模型标准：根据GIS区域Shp信息、高程信息、卫星影像信息生成模型，不包含建筑物
贴图标准：卫星影像图
2. L1城市级 场景描述：大约500平方公里以内，包含地形、主要建筑、路网（精确到县道）、水系的低精度模型，包含下一级行政区划分界线和下一级行政区划地名散点标牌
最小观看距离：3000m
建筑模型标准：根据GIS建筑轮廓和建筑层高信息生成模型
建筑贴图标准：随机贴图
3. L2城区级 场景描述：大约25平方公里以内，包含地形、主要建筑、路网（精确到1级道路）、水系、主要植被的低精度模型，包含下一级行政区划分界线和下一级行政区划地名散点标牌
最小观看距离：1000m
建筑模型标准：根据GIS建筑轮廓和建筑层高信息生成模型
建筑贴图标准：随机贴图
4. L3园区级 场景描述：大面积城市由设计资产自动生成摆放，包含地形地貌、主要建筑、路网、水系、植被、城市基础设施的高精度模型建模，重点建筑进行手工建模超高精度还原。
最小观看距离：200m
建筑模型标准：形状接近
建筑贴图标准：颜色接近
5. L4建筑级 场景描述：基于模型资产进行超高拟真建模，精确还原建筑/设备外观材质、纹理细节、复杂结构，包含建筑外围设施、植被、部件、车道线、车辆、行人、楼体结构、地面、墙面、栏杆、窗框等要素的超高精度模型和贴图效果。
建筑模型标准：精度0.1米
建筑贴图标准：拟真度&gt;90%
6. L5设备/室内精模 场景描述：超高精细度、拟真建模还原，可高精度还原室内建筑/设备外观材质、纹理细节、复杂结构、内部零部件、管线等细节，准确还原要素对象材质质感。
建筑模型标准：形状拟真
建筑贴图标准：颜色拟真
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78d6e31fe457a666aa03618bb349dee1/" rel="bookmark">
			具体代码学习C&#43;&#43;(01)--HelloWorld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 Hello World注释 Hello World /* * 这是第一个C++程序，打印输出"HelloWorld" * 体现了C++基本的代码结构 * */ #include&lt;iostream&gt; // 头文件iostream:输入输出流。下面代码中的cout是该头文件的内容，必须引入这个头文件才能使用cout using namespace std; // 使用命名空间std int main() { cout &lt;&lt; "HelloWorld" &lt;&lt; endl; // 输出"HelloWorld" return 0; } main：一个程序的入口，每个程序都必须有一个main函数，有且仅有一个
注释 单行注释：// 注释内容 多行注释：
/* 注释内容，编译器会忽略注释内容 */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d654b98e8c91faec6e9f60855ccc7a/" rel="bookmark">
			链路聚合（华为）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、链路聚合技术
随着我们网络的不断拓展，业务流量也随之增多，那么我们就开始需要多链路进行通信
故研究出一个技术==Eth-Trunk（链路捆绑）
作用：
可以把多个独立的物理端口绑定在一起，当做一个大带宽逻辑接口去使用，这样的方法既不用替换端口也不必浪费IP地址资源
组建网络遇到的问题：
1. 网络需求大，单链路无法完成，增加链路又浪费IP地址，更换高带宽接口（E口换G口）又会增加维护设备的成本
2. 如果链路发生故障，又会影响通信和办公
解决：
两个问题均可以用eth-trunk来解决，将多个e口绑定为一起带宽转发就会增加（不必使用G口）由于是多个端口绑定故即便发生端口故障或者是单条链路故障也没有关系，因为其他端口也会进行转发（如果物理端口断掉，带宽转发也会稍微影响：比如，我用四条链路组成了一个链路捆绑（4000M）那么断开一个的话（-1000M），转发就会变成3000M）
Eth-Trunk链路聚合模式：
静态配置模式（手工负载分担）
动态配置模式（LACP）
Eth-trunk接口负载分担：
可以选择IP地址或者包作为负载分担依据
设置成员接口的负载分担分配
如果一个成员的分配权重值越大，承担的负载就越大
逐流负载分担：
当源地址、目标地址都相同或者报文的源MAC地址、目标MAC地址都相同时，就会在一条链路上传输
逐包负载分担：
以报文为单位分别从不同的成员链路上发送
手工负载分担模式：
当两台设备其中一个不支持LACP时，可以用手工负载方式来增加设备间的带宽和可靠性
Eth-Trunk接口配置流程：
Eth-Trunk接口配置流程：
[Huawei]interface eth-trunk 1
[Huawei-Eth-trunk1]mode manual load-balan//设置为手工负载分担
[Huawei-Eth-trunk1]trunkport g 0/0/X//加入端口
[Huawei-Eth-trunk1]port link-t access/trunk//设置端口模式，这里根据拓扑要求来设置即可
实验一 配置手工负载分担模式
S1交换机的初始配置
&lt;Huawei&gt;u t m &lt;Huawei&gt;system-view
[S1]sysname S1
创建vlan并将接口加入vlan设置接口的模式为acess:
[S1]vlan batch 10 20 \\创建vlan 10 20
[S1]interface g0/0/1\\进入接口0/0/1
[S1-GigabitEthernet0/0/1]port link-type access \\设置接口模式为接入链路
[S1-GigabitEthernet0/0/1]port default vlan 10 \\将接口加入vlan10
[S1]interface g0/0/2\\进入接口0/0/2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d654b98e8c91faec6e9f60855ccc7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f3bd3e80b352d792f7ba7823040bd6/" rel="bookmark">
			SQLSERVER目录LOG文件夹SQLDump*.mdmp大量日志 log文件夹占用磁盘爆满 删除了没几天又满了 文件一直生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL目录LOG文件夹SQLDump*.mdmp大量日志 log文件夹占用磁盘 删除了没几天又占满了 。
300多GB 。
分析：
1.导致的原因，并非电脑中病毒，或者SQL环境有损坏，或者操作系统有故障。。。
2.导致的原因是，您的数据库内某一个数据库，有严重的系统表架构性错误，当数据库引擎读写到改错误的位置，导致了死循环，从而写入大量的转存错误日志。
解决：
1.SQL SERVER 的LOG文件夹里面所有文件都可以删除，里面的文件主要用于分析数据库故障。如果非专业人士，看不懂日志内容，可以忽略，直接删除，腾出来磁盘空间。
2.排除法，排查每个数据库，建议运行DBCC CHECKDB('数据库名称') 自检查每一个数据库，如果发现某一个数据库有错误，需要进行修复。
3.如果DBCC CHECKDB 发现有损坏的数据库，可以先进行脱机或者分离，采用排除法，看看LOG文件是否还有 SQLDump 生成。
如果分离损坏的数据库后，就不生成了，那么就可以肯定是这个数据库导致的。
从而定向对该数据库彻底的修复。
注意事项：
1.请务必做好备份，备份了数据库，在操作，保证数据绝对安全。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79ac4dc98a228ce3b016c82e0fd37e75/" rel="bookmark">
			idea的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.项目结构：idea里只有一个project，该projet下有很多module。
2.新建project:点击菜单栏file–new–Project–java—next–输入project name如project01,选择项目位置—finish
3.新建module:选中project，可右键new module
4.新建包：鼠标点击相应的module下的src，new —package
4.新建java类：鼠标点击相应的package，可右键new Java Class
5.main方法快捷写法：写出main后按tab键可自动生成main方法
6.注意System,首字母是大写。单词输入一半后可按tab键自动补齐。
7.保存：java代码不用ctrl+s手动保存，idea会实时帮助保存。
8.运行：右键–点击绿色的三角Run …即可运行。或者在代码编辑页面点击main前面的绿色三角，或者点击上方工具栏的绿色三角。
8.删除module:右键点相应的module,—Open Module Settings—module上方有个减号，点击即可删除相应的module，此时仅仅是module不可用了，退出重新右键点击相应的module,右键选择remove Module ,再次重新右键点击module，右键选择delete，即可删除磁盘上相应的module文件。
9.删除java类：选择相应java类，右键–delete，就可删除了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8d0a90fe57e7025fd163c3d9eef3a8/" rel="bookmark">
			vscode返回上一级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode返回上一级 alt+&lt;- 返回上一级
alt±&gt; 回到下一级
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613c7ae625e334abe44b1528e6885534/" rel="bookmark">
			Transformer-M：一个能理解2D和3D分子的Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ONE TRANSFORMER CAN UNDERSTAND BOTH 2D &amp; 3D MOLECULAR DATA 目录
总结
一、Introduction
二、Transformer-M
三、Experiment
1. PCQM4Mv2 performance (2D)
2. PDBBIND performance (2D&amp;3D)
3. QM9 performance (3D)
4. Ablation study
Impact of the pre-training tasks：
Impact of mode distribution：
四、Conclusion
参考（具体细节见原文）
总结 今天给大家介绍的是来自北京大学贺笛团队和微软在arXiv发表的预印本《ONE TRANSFORMER CAN UNDERSTAND BOTH 2D &amp; 3D MOLECULAR DATA》。为了实现跨模态处理分子任务，作者开发了一种新的基于Transformer的分子模型Transformer-M。它可以将2D或3D格式的分子数据作为输入，并生成有意义的语义表示。通过对2D和3D分子数据进行训练，Transformer-M学习来自不同数据模式的知识并正确捕获表征。Transformer-M可以同时在2D和3D任务中实现较强的性能，表明其具有广泛的适用性。
一、Introduction 化学与视觉和语言等传统领域的一个关键区别是数据的多模态。在视觉和语言中，数据通常以特定的形式进行描述。例如，图像被定义为像素网格中的RGB值，而句子被定义为句子中的字词。与视觉和语言数据通常具有固定的格式不同，分子可以使用不同的化学方法进行表征。比如，可以将分子视为2D图，也可以将其定义为位于3D空间中的原子集合。然而，以往的工作大多集中于设计2D或3D结构的神经网络模型，导致一种形式的模型无法应用到另一种形式的任务中。因此作者开发了Transformer-M，一个基于Transformer的多功能分子模型，它在2D和3D分子表征学习中都表现良好。
二、Transformer-M 如图1所示，Transformer-M的主干网络是由标准的Transformer块组成的。作者开发了两个单独的通道来编码2D和3D结构信息。2D通道使用度编码、最短路径距离编码和从2D图结构中提取的边编码。最短路径距离编码和边编码反映了一对原子之间的空间关系和键的特征，在softmax注意中用作偏置项。度编码被添加到输入层的原子特征中。
对于3D通道，作者使用3D距离编码对3D几何结构中原子之间的空间距离进行编码。每个原子对的欧氏距离通过高斯核函数编码，并将在softmax注意中用作偏置项。对于每个原子，我们将其与所有其他原子之间的3D距离编码相加，并将其添加到输入层的原子特征中。
除了两个结构通道中的参数外，Transformer-M中的所有其他参数（例如，自注意和前馈网络）对于不同的数据模式是共享的。在训练过程中，当batch中的数据是2D图时，2D通道将被激活，3D通道将被禁用。类似地，当batch中的数据是3D几何结构时，3D通道将被激活，而2D通道将被禁用。当二维和三维信息同时给出时，两个通道都将被激活。
图1：Transformer-M模型架构。在经典主干Transformer上建立了两个通道。红色通道对2D Graph的数据激活，包含度、最短路径距离和边缘信息。紫色通道对3D几何结构的数据激活，利用欧氏距离信息。不同的编码位于适当的模块中。
三、Experiment 作者研究了三个具有代表性的任务：PCQM4Mv2 (2D)、PDBBind (2D&amp;3D)和QM9 (3D)。使用OGBLSC（包含340万个2D和3D形式的分子）中的PCQM4Mv2数据集来预训练Transformer-M。预训练任务有两个，一个是训练模型预测2D和3D格式分子的HOMO-LUMO能级，另一个是专门设计针对3D数据的3D位置去噪任务。
1. PCQM4Mv2 performance (2D) 在预训练之后，使用PCQM4Mv2的验证集上评估Transformer-M。PCQM4Mv2的验证集只包含2D分子数据。因此，可以用它来评估Transformer-M在2D分子数据上的表现。该任务的目标是预测HOMU-LUMO能级，评价指标是平均绝对误差（MAE）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/613c7ae625e334abe44b1528e6885534/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056ca313ee96a68d9454210c8c74991b/" rel="bookmark">
			【HTML&#43;CSS】高级、简约的移动端登录注册界面，HR看了直呼里面请
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、静态页面index.html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;【HTML+CSS】实现移动端高级简约的登录注册界面&lt;/title&gt; &lt;link rel="stylesheet" href="css/index.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;!-- 登录 --&gt; &lt;div class="login"&gt; &lt;div class="login_top"&gt; &lt;img src="img/favicon.png" alt="头像"&gt; &lt;h2&gt;Welcome to Login&lt;/h2&gt; &lt;/div&gt; &lt;div class="login_bottom"&gt; &lt;form&gt; &lt;!-- 邮箱/手机号输入框 --&gt; &lt;input type="text" class="input" placeholder="Email or Phone" /&gt; &lt;!-- 密码输入框 --&gt; &lt;input type="Password" class="input" placeholder="Password" /&gt; &lt;/form&gt; &lt;!-- 确认框/忘记密码 --&gt; &lt;p&gt; &lt;input type="checkbox"&gt; &lt;span&gt;I agree to follow the rules.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/056ca313ee96a68d9454210c8c74991b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750ce133ffa139ebd3bc63a01fed2fd1/" rel="bookmark">
			N个字符或数字的全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Itertools.permutation()
1、对字符串
2、对元组
3、对列表
4、对字典
二、N个字符或数字的全排列
1、python代码
三、（后面的补充）两道例题
1、第一道例题
（1）上链接
（2）python代码——permutations秒杀
2、第二道例题
（1）上链接
（2）python代码——permutations+去重秒杀
一、Itertools.permutation() 参考：python——permutations()函数_xiaochuhe.的博客-CSDN博客_permutations函数
无例题，笔者只是想说明 Itertools.permutation() 的使用。
Itertools.permutation() 功能属于组合发电机。用于简化组合结构(例如排列，组合和笛卡尔积)的递归生成器称为组合迭代器。
如单词“Permutation”所理解的，它指的是可以对集合或字符串进行排序或排列的所有可能的组合。
同样在这里 itertools.permutations() 方法为我们提供了迭代器可能存在的所有可能的安排，并且所有元素均根据该位置而不是根据其值或类别被假定为唯一。所有这些排列都是按字典顺序提供的。
功能 itertools.permutations() 接受一个迭代器和 “r” (需要排列的长度)作为输入，并假设 “r” 作为迭代器的默认长度(如果未提及)，并分别返回所有可能的长度为 “r” 的排列。Permutations(iterator, r)
格式：
permutations(iterator, r)
举例（查看类型）：
a=['1','2','3'] from itertools import permutations #permutations(a,3) print (permutations(a,3)) print (type(permutations(a,3))) 输出类型：
显然 permutations(iterator, r) 返回了一个迭代器，需要用循环来依次解析。
1、对字符串 from itertools import permutations a = 'abc' #对字符串进行permutations排列组合 for i in permutations(a,3): x = ''.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750ce133ffa139ebd3bc63a01fed2fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8c3f5549a83034546551c519b2b1fae/" rel="bookmark">
			Vue做项目环境搭配流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
项目搭建
1.安装Vue脚手架
2.创建项目
3.按需引入Element-UI
推荐写法：在跟src同级创建一个 plugins/element.js文件
4.CSS预处理器SCSS
5.reset.css文件 (去掉默认样式)
6.图标库安装使用
7.axios的安装使用
8.路由vue-router的安装使用
9.路由懒加载和异步组件
路由懒加载：
​编辑 异步组件:
项目搭建 整个项目用的是Vue2，然后脚手架是 @vue/cli 5.0.8(5版本的)
1.安装Vue脚手架 01.npm install -g @vue/cli 安装脚手架(应该都是安装好了的)
02.vue -V 查询脚手架版本
2.创建项目 vue create 项目名称
注意：项目名称不要用中文名
3.按需引入Element-UI 网址:https://element.eleme.cn/#/zh-CN/component/installation
01:npm 安装Element-UI
npm i element-ui -S
02: npm install babel-plugin-component -D 注意点：npm i xx -D：npm install xx --save-dev的简写，对模块进行局部安装，模块写入到 devDependencies 对象。将依赖安装在开发环境下。
03.在babel.config.js 文件中
module.exports = { presets: [ '@vue/cli-plugin-babel/preset', // ["es2015", { "modules": false }] 原来是这样写，但是在最新版的脚手架下要向下面这种写 ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8c3f5549a83034546551c519b2b1fae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe70e98724e7636b44a63b6bf322eee9/" rel="bookmark">
			Flask数据库迁移时保留数据库原有表及数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在flask db init生成migrations文件后，修改里面的env.py文件
在run_migrations_offline和run_migrations_online函数中各添加一个钩子函数include_object，之后在context.configure(）添加一行参数 include_object=include_object使其忽略已有的数据库，代码如下
from __future__ import with_statement import logging from logging.config import fileConfig from flask import current_app from alembic import context # this is the Alembic Config object, which provides # access to the values within the .ini file in use. config = context.config # Interpret the config file for Python logging. # This line sets up loggers basically. fileConfig(config.config_file_name) logger = logging.getLogger('alembic.env') # add your model's MetaData object here # for 'autogenerate' support # from myapp import mymodel # target_metadata = mymodel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe70e98724e7636b44a63b6bf322eee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834446e7a615f3abdbeb3b9b1b95fa51/" rel="bookmark">
			postgressql数据库timestamp转字符串，包含毫秒级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //秒级 to_char(time,'YYYY-MM-DD hh24:mi:ss') //毫秒级 to_char(time, 'yyyy-mm-dd hh24:mi:ss.ms') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666eae8f4aea5fe8f61ad0d941fbafe2/" rel="bookmark">
			使用kepware配置opcua服务端，并使用UaExpert作为opc客户端进行连接（匿名和用户名密码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.在kepserverEx配置OPCUA服务端
2. 安装opcua客户端进行测试验证
3. 使用账户密码接入opcua服务端
1.在kepserverEx配置OPCUA服务端 （1）安装kepwareEx，然后在任务栏kepware应用右键找到OPC UA 配置
（2）单击添加，选择网络适配器，安全策略无，得到opc.tcp://192.168.31.88:49320，单击确认就可以
(3)配置完后显示已启用，关闭此窗口
（4）.在kepServerEx单击项目，在属性编辑器里的OPCUA选项里，允许匿名登录选择“是”
（5）点击任务栏的kepware，选择重新初始化
2. 安装opcua客户端进行测试验证 （1）下载UaExpert进行安装
（2）在UaExpert里输入组织和单位，随便输入即可，单击确认。
（3）去掉自动更新的勾选
（3）新建连接，输入名称kepware，在Advanced选项里输入opcServer的地址，也就是前面创建的opc.tcp://192.168.31.88:49320，选择Anonymous匿名访问方式，然后单击确认按钮。
（4）在UaExpert双击kepware ，选择connect
（5）弹出证书确认对话框，选择接受勾选，然后信任证书
（6）证书信任后，单击continue
（7）左侧出现opcserver的内容，说明连接成功
(8)将_System中的_Time_Second拖到中间，中间就显示出来随机数值，在右侧nodeId就能看到地址
3. 使用账户密码接入opcua服务端 （1）在kepware设置里添加新用户
（2） 单击项目，在opcua的允许匿名登录选择“否”
（3）重新初始化
（4）在UaExpert里输入用户名和密码重新连接即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad4e3ab6c5b69107838216668ffc5c8/" rel="bookmark">
			mac下mysql修改密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步：关闭mysql
苹果-&gt;系统偏好设置-&gt;最下面点MySQL，关闭mysql服务
第二步：进入终端设置
进入终端输入 cd /usr/local/mysql/bin/ 回车
cd /usr/local/mysql/bin/
输入 sudo su 回车以获取管理员权限
sudo su
这里你要注意，当你输入sudo su时，你需要输入的你自己电脑的管理员密码（开机密码）
输入 ./mysqld_safe --skip-grant-tables &amp; 回车以禁止mysql验证功能，mysql会自动重启，偏好设置中的mysql状态会变成running。
./mysqld_safe --skip-grant-tables &amp;
输入命令 ./mysql 回车
./mysql
输入命令 flush privileges; 分号别忘记输了
flush privileges;
重置密码：ALTER USER 'root'@'localhost' IDENTIFIED BY '12345678';
ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘12345678’;
7、执行 quit 退出mysql
8、执行 exit 退出sudo
9、密码重置已完毕，可以试试登陆mysql。
mysql -u root -p
tips
网友回复：haohui_H 建议标注mysql数据库版本，mysql8修改密码那句变成了 SET PASSWORD FOR root@localhost = 'root'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ace546076ab9ab8198299b215eebabf/" rel="bookmark">
			unity urp 实现丝绸渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看一下实际上真实的效果
再来一张
这是专门去找的。
可以看到丝绸渲染使用了各向异性的GGX去实现，有点仿头发的感觉，接下来看一下怎么实现的。
首先，准备实现双向反射率分布函数（BRDF）的DVF项。
D项使用UE里面的各项异性GGX：
// [Burley 2012, "Physically-Based Shading at Disney"] float D_GGXaniso(float ax, float ay, float NoH, float XoH, float YoH) { float a2 = ax * ay; float3 V = float3(ay * XoH, ax * YoH, a2 * NoH); float S = dot(V, V); return(1.0f / PI) * a2 * Square(a2 / S); } V项使用配合D项的Vis_SmithJointAniso
// [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"] float Vis_SmithJointAniso(float ax, float ay, float NoV, float NoL, float XoV, float XoL, float YoV, float YoL) { float Vis_SmithV = NoL * length(float3(ax * XoV, ay * YoV, NoV)); float Vis_SmithL = NoV * length(float3(ax * XoL, ay * YoL, NoL)); return 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ace546076ab9ab8198299b215eebabf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541306a596facb971f194c8a531df560/" rel="bookmark">
			较YOLOv7精度提升1.9%，54.7mAP的PP-YOLOE&#43;强势登场！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		精度54.7mAP，相较YOLOv7提升1.9%
L版本端到端推理速度42.2FPS
训练速度提升3.75倍
COCO数据集仅需20epoch即可达到50.0mAP
下游任务泛化性最高提升8%
10+即开即用多端部署Demo
这究竟是什么模型，竟可达到以上效果？
答案是：PP-YOLOE+
PP-YOLOE+是基于飞桨云边一体高精度模型PP-YOLOE迭代优化升级的版本，具备以下特点：
超强性能
表格1：PP-YOLOE+与PP-YOLOE性能对比
*备注：以上速度为端到端推理速度，包含数据解码+数据预处理+模型预测+后处理计算；均在v100上测试所得，V100 + CUDA11.2 + cudnn8.2.0 + TRT8.0.1.6
训练收敛加速：使用Objects365预训练模型，减少训练轮数，训练收敛速度提升3.75倍。
下游任务泛化性显著提升：在农业、夜间安防、工业等不同场景数据集上验证，精度最高提升8.1%。
高性能部署能力：本次升级PP-YOLOE+支持多种部署方式，包括Python/C++、Serving、ONNX Runtime、ONNX-TRT、INT8量化等部署能力。
超强性能与超高泛化性使得PP-YOLOE+助力开发者在最短时间、最少量数据上能得到最优效果。
模型下载与完整教程请见PP-YOLOE+：
https://github.com/PaddlePaddle/PaddleDetection/tree/release/2.5/configs/ppyoloe 回顾：PP-YOLOE
经典网络结构剖析
图1：PP-YOLOE网络结构
PP-YOLOE是一款高精度推理速度快的检测模型，包含骨干网络CSPRepResNet、特征融合CSPPAN、轻量级ET-Head和改进的动态匹配算法TAL（Task Alignment Learning）等模块， 并且根据不同的应用场景设计了一系列模型，即s/m/l/x。
PP-YOLOE的全系列模型从精度速度性价比来看达到工业界最优。具体来说，PP-YOLOE-l在COCO test-dev上AP可达51.4，在V100上速度可达78.1 FPS，使用TensorRT FP16进行推理，在V100上速度可达149FPS。
PP-YOLOE-l相较于PP-YOLOv2精度提升1.9AP、速度提升13.35%，相对于YOLOX-l精度提升1.3AP、速度提升24.96%。
此外，PP-YOLOE还避免使用诸如可变形卷积或者Matrix NMS之类的特殊算子，使PP-YOLOE全系列模型能轻松地部署在NVIDIA V100和T4这样的云端GPU架构、Jetson系列的移动端GPU和高性能的FPGA开发板上。
具体的结构包括以下三大部分：
可扩展的backbone和neck
我们设计了CSPRepResNet作为backbone, neck部分也采用了新设计的CSPPAN结构，backbone和neck均以我们提出的CSPRepResStage为基础模块。新的backbone和neck在增强模型表征能力的同时提升了模型的推理速度，并且可以通过width multiplier和depth multiplier灵活地配置模型的大小。
TAL（Task Alignment Learning）
为了进一步提升模型的精度，我们选用了TOOD [1]中的动态匹配算法策略TAL。TAL同时考虑分类和回归，使得匹配结果同时获得了最优的分类和定位精度。
Efficient Task-aligned head
检测head方面，我们在TOOD的T-head基础上进行改进。
首先，使用ESE block替换掉了原文中比较耗时的layer attention，使得模型在保证精度不变的同时提升了速度。
其次，由于T-head使用了可变形卷积算子，对硬件部署不友好，我们在分类分支使用shortcut替换cls-align模块，回归分支使用积分层替换掉含有可变形卷积的reg-align模块，以上两个改进使得head变得更为高效、简洁且易部署。
最终，我们进一步使用VFL（VariFocal Loss）替换BCE作为分类分支Loss，达到了速度精度双高的目的。
PP-YOLOE+
算法升级深度解读
本次PP-YOLOE+升级主要内容：
升级一：强大的Objects365预训练模型、升级版backbone等改动大幅提升PP-YOLOE系列模型的精度；
升级二：优化预处理，提升模型端到端推理速度，更贴近用户使用的真实场景；
升级三：完善多种环境下的推理部署能力。
精度
首先，我们使用Objects365大规模数据集对模型进行了预训练。Objects365数据集含有的数据量可达百万级，在大数据量下的训练可以使模型获得更强大的特征提取能力、更好的泛化能力，在下游任务上的训练可以达到更好的效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/541306a596facb971f194c8a531df560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be107537ff4559c8c715e6ada673e67d/" rel="bookmark">
			双系统卸载ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅浅的记录一下本小白的第一条博客
因为我们实验室的师兄去实习啦，我们新一届的就会用原来的电脑，我用这个电脑的时候师兄已经装了16.04的双系统ubuntu，但是作为一个小白，根据视频进行操作的时候我发现不是很方便（sudoer用户，存放的文件也比较杂乱，就直接卸载重装吧~~~）
okk开始了
1 删除ubuntu的分区 ①右击此电脑，选择管理 ②选择磁盘管理 ③接下来就是删除分区了，首先先知道删除哪个分区： 如果你像我刚开始一样不知道Ubuntu是哪几个分区也没有关系，排除法用起来~
！最基本的\C \D \E 肯定是不能动的！！
！恢复分区不能动！！
！保留分区不能动！！！
！EFI系统分区也不要动！！
除此之外，其余的都是ubuntu的分区了
排除后剩下的就是ubuntu系统所使用的分区，选中分区右键的删除卷，
比如图中我的磁盘状态是已安装完ubuntu的状态，磁盘分区11，12，13就是当时分配给ubuntu系统的分区，将其删除即可。删除后的空闲空间刚好可以用来留给将要安装的系统使用，无需重新再分配。
④排出后就真的可以选择删除咯 选中分区，右击删除卷，磁盘会自动回到未分配的状态
双系统安装ubuntu的时候可能有多个分区，需要逐一删除，辨别出来，重复操作就好啦
删除后磁盘会自动回到未分配的状态。删除完毕后ubuntu就完全从电脑中卸载了。
因为我是已经操作了一次，没有遇到什么问题，就想着记录一下历程，所以没有办法举例子哪些是我当时的分区，就只能讲一下的我分辨分区的方法。
2 删除开机引导项 删除完分区后不要着急进行开关机操作！ 会出现grub页面，输入exit会进入windows页面。
如果不删除ubuntu的开机引导项，上面的页面会一直出现
①win+r，打开命令行，输入下面命令 diskpart list disk ② 选择windows的安装磁盘，选择启动项所在的那个磁盘,查看磁盘的分区信息 （启动项在刚刚的磁盘管理和分区那里可以看到！点击电脑的磁盘管理，看一下c盘在哪就选择哪个！)
我的启动项是磁盘1 ，是哪个就选择哪个，不要跟别的博主瞎选啊~~
select disk 1 list partition 上面就是分别输入两行命令得到的结果
③确定windows的EFI分区，然后为它分配盘符 如果不知道就返回去点击，此电脑，右击管理，磁盘管理，看看是哪个分区就选哪个，就是下面这样子 select partition 2 输入上面的命令行，选择分区（我是磁盘一分区2，第二步②选择磁盘一，现在选择分区2）
④为它分配盘符 你的电脑上应该已经有了CDE 盘，因为盘符不可与盘符重复，所以尽可能选择字母排名靠后的字母，
assign letter=J ⑤ 打开电脑就能看到你分配的盘符 ⑥权限不够，没有办法直接打开这个磁盘，可以用记事本间接打开 左下角查找功能，输入记事本，右击选择以管理员身份运行
⑦左上角选择文件，打开 ⑧选择刚刚创建的磁盘，点击进去，会找到一个Ubuntu文件夹 我记得我当时好像有三个文件夹，不用管，直接删除ubuntu就行了，右击删除
⑨返回刚刚的命令行，再删除刚刚分配的盘符 remove letter=J 就是下面这样子 再返回查看电脑，就发现刚刚的盘符没有啦
okk删除完成！！！
可以重启检查一下什么都没啦，光秃秃的非常棒~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ddf5ac1903ef438fc7f885a576b357/" rel="bookmark">
			python写入csv中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用python写入csv文件打开发现中文乱码。查找资料发现需要修改编码格式，我原来的写法是：
f = open('51招聘数据-金融分析2.csv',mode='a',encoding='utf-8',newline='') 试了一下网上的修改encoding为'utf-8-sig'和'gbk'，最终发现’gbk’格式的编码是可行的。建议大家可以都试一下，可能不同版本的csv它支持的编码格式不一样。
f = open('51招聘数据-金融分析2.csv',mode='a',encoding='gbk',newline='') 三种编码格式：
utf-8
utf-8-sig
gbk
成功解决！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/120/">«</a>
	<span class="pagination__item pagination__item--current">121/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/122/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>