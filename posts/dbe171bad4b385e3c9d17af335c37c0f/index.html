<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 算法篇-深入理解递归（递归实现：青蛙爬楼梯） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 算法篇-深入理解递归（递归实现：青蛙爬楼梯）" />
<meta property="og:description" content="🔥博客主页： 小扳_-CSDN博客
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 递归的说明
2.0 用递归来实现相关问题
2.1 递归 - 阶乘
2.2 递归 - 反向打印字符串
2.3 递归 - 二分查找
2.4 递归 - 冒泡排序
2.5 递归 - 冒泡排序2.0
2.6 递归 - 插入排序
2.7 递归 - 斐波那契
2.8 递归 - 兔子问题
2.9 递归 - 青蛙爬楼梯
1.0 递归的说明 递归就是在一个函数中调用自身。这样做可以让我们解决一些问题，比如计算斐波那契数列、阶乘等。
递归函数一般包括两部分：基本情况和递归情况。基本情况是指当问题变得很小，可以直接得到答案时，递归就可以停止了。递归情况是指在解决问题的过程中，需要不断地调用自身来解决更小规模的问题。
对于递归这个算法，简单的来说，方法自身调用自身的时候，需要有终止的条件，在运行过程中不断的趋向终止条件。还有递归总的来说有两个动作：第一个动作是递出，方法不断的在栈区中创建出来，直到达到了条件就会停止。第二个动作，达到条件停止了，就会回归，指方法在栈区中依次执行完后就销毁。
2.0 用递归来实现相关问题 以下的问题都较为简单，采取直接用代码来演示。
2.1 递归 - 阶乘 代码如下：
//阶乘 public static void main(String[] args) { System.out.println(fun(5)); } public static int fun(int n) { if (n == 1) { return 1; } return n * fun(n-1); } } 运行结果为：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/dbe171bad4b385e3c9d17af335c37c0f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-10T11:58:17+08:00" />
<meta property="article:modified_time" content="2023-11-10T11:58:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 算法篇-深入理解递归（递归实现：青蛙爬楼梯）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： <strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客">小扳_-CSDN博客</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong> </p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" height="436" src="https://images2.imgbox.com/7c/94/7djMtXW0_o.jpg" width="400"></p> 
<p style="text-align:center;"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6b/31/80rQBh6I_o.gif"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%80%92%E5%BD%92%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%80%92%E5%BD%92%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">        1.0 递归的说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98" rel="nofollow">        2.0 用递归来实现相关问题</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E9%80%92%E5%BD%92%20-%20%E9%98%B6%E4%B9%98-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E9%80%92%E5%BD%92%20-%20%E9%98%B6%E4%B9%98" rel="nofollow">        2.1 递归 - 阶乘</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E9%80%92%E5%BD%92%20-%20%E5%8F%8D%E5%90%91%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E9%80%92%E5%BD%92%20-%20%E5%8F%8D%E5%90%91%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">        2.2 递归 - 反向打印字符串</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E9%80%92%E5%BD%92%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E9%80%92%E5%BD%92%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" rel="nofollow">        2.3 递归 - 二分查找</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E9%80%92%E5%BD%92%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E9%80%92%E5%BD%92%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">        2.4 递归 - 冒泡排序</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E9%80%92%E5%BD%92%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F2.0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E9%80%92%E5%BD%92%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F2.0" rel="nofollow">        2.5 递归 - 冒泡排序2.0</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E9%80%92%E5%BD%92%20-%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E9%80%92%E5%BD%92%20-%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">        2.6 递归 - 插入排序</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E9%80%92%E5%BD%92%20-%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E9%80%92%E5%BD%92%20-%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91" rel="nofollow">        2.7 递归 - 斐波那契</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.8%20%E9%80%92%E5%BD%92%20-%20%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.8%20%E9%80%92%E5%BD%92%20-%20%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98" rel="nofollow">        2.8 递归 - 兔子问题</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.9%20%E9%80%92%E5%BD%92%20-%20%E9%9D%92%E8%9B%99%E7%88%AC%E6%A5%BC%E6%A2%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.9%20%E9%80%92%E5%BD%92%20-%20%E9%9D%92%E8%9B%99%E7%88%AC%E6%A5%BC%E6%A2%AF" rel="nofollow">        2.9 递归 - 青蛙爬楼梯</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%80%92%E5%BD%92%E7%9A%84%E8%AF%B4%E6%98%8E">        1.0 递归的说明</h2> 
<p>        <strong>递归就是在一个函数中调用自身。这样做可以让我们解决一些问题，比如计算斐波那契数列、阶乘等。</strong></p> 
<p><strong>        递归函数一般包括两部分：基本情况和递归情况。基本情况是指当问题变得很小，可以直接得到答案时，递归就可以停止了。递归情况是指在解决问题的过程中，需要不断地调用自身来解决更小规模的问题。</strong></p> 
<p><strong>        对于递归这个算法，简单的来说，方法自身调用自身的时候，需要有<span style="color:#fe2c24;">终止的条件</span>，在运行过程中不断的趋向终止条件。还有递归总的来说有两个动作：第一个动作是<span style="color:#fe2c24;">递出</span>，方法不断的在栈区中创建出来，直到达到了条件就会停止。第二个动作，达到条件停止了，就会<span style="color:#fe2c24;">回归</span>，指方法在栈区中依次执行完后就销毁。</strong></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">        2.0 用递归来实现相关问题</h2> 
<p>        <strong>以下的问题都较为简单，采取直接用代码来演示。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E9%80%92%E5%BD%92%20-%20%E9%98%B6%E4%B9%98">        2.1 递归 - 阶乘</h3> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //阶乘
    public static void main(String[] args) {
        System.out.println(fun(5));
    }
    
    public static int fun(int n) {
        if (n == 1) {
            return 1;
        }
        return n * fun(n-1);
    }
}</code></pre> 
 <p><strong>运行结果为：</strong></p> 
 <p><img alt="" class="left" height="114" src="https://images2.imgbox.com/d4/88/lU5mmeSA_o.png" width="214"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E9%80%92%E5%BD%92%20-%20%E5%8F%8D%E5%90%91%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2">        2.2 递归 - 反向打印字符串</h3> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //反向打印字符串
    public static void main(String[] args) {
        String str = "lisi";
        fun2(str,0);
    }

    public static void fun2 (String s, int n) {

        if (n == s.length()) {
            return;
        }
        fun2(s,n + 1);
        System.out.println(s.charAt(n));
    }</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p><img alt="" class="left" height="189" src="https://images2.imgbox.com/a5/6c/M6phvkCb_o.png" width="214"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E9%80%92%E5%BD%92%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">        2.3 递归 - 二分查找</h3> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //二分查找
    public static void main(String[] args) {
        int[] arr = {1,3,5,7,9,10,13};
        System.out.println(fun3(arr, 0, arr.length - 1, 4));
    }

    public static int fun3 (int[] arr, int left, int right, int target) {
        int mid = (left + right) &gt;&gt;&gt; 1;
        if (left &gt; right) {
            return -1;
        }
        if(arr[mid] &lt; target) {
            return fun3(arr, mid + 1,right,target);
        } else if (target &lt; arr[mid]) {
            return fun3(arr,left,right - 1,target);
        }else {
            return mid;
        }
    }</code></pre> 
 <p><strong>  运行结果如下：</strong></p> 
 <p><img alt="" height="120" src="https://images2.imgbox.com/a1/03/QKLYuKI0_o.png" width="230"></p> 
 <p><strong>        没有找到就返回 - 1</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E9%80%92%E5%BD%92%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">        2.4 递归 - 冒泡排序</h3> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //冒泡排序
    public static void main(String[] args) {
        int[] arr = {1,5,2,4,9,1,3};
        fun4(arr, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }
    public static void fun4 (int[] arr, int n) {
        if (n == 0) {
            return;
        }
        for (int i = 0; i &lt; n; i++) {
            if (arr[i] &gt; arr[i + 1]) {
                int temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }
        fun4(arr,n-1);
    }</code></pre> 
 <p><strong>运行结果如下：</strong></p> 
 <p><img alt="" class="left" height="110" src="https://images2.imgbox.com/d1/7d/QCye3liE_o.png" width="235"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E9%80%92%E5%BD%92%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F2.0">        2.5 递归 - 冒泡排序2.0</h3> 
<p>        <strong>对冒泡排序进行升级，假如 int[] arr = {2,1,1,3,4,5,9}，这种只需要遍历一遍即可，但是对与已经用递归实现的冒泡不止遍历一次。因此，需要得到升级版冒泡排序。</strong></p> 
<p><strong>        思路为：<span style="color:#fe2c24;">对于后续的元素已经是排好序了，就不用再遍历了。每一次交换完元素之后记下来 i 索引，i 之后的元素已经是排好序的，i 之前的元素还需要继续遍历，看是否还需要交换。</span></strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //冒泡排序升级版
    public static void main(String[] args) {
        int[] arr = {1,3,2,4,9,10,13};
        fun4(arr, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }
    public static void fun4 (int[] arr, int n) {
        if (n == 0) {
            return;
        }
        int j = 0;
        for (int i = 0; i &lt; n; i++) {
            if (arr[i] &gt; arr[i + 1]) {
                int temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
                j = i;
            }
        }
        fun4(arr,j);
    }</code></pre> 
 <p>        <strong>如果还不是很清晰的话，可以一步步来调试一下，来对比两种冒泡的执行过程。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E9%80%92%E5%BD%92%20-%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">        2.6 递归 - 插入排序</h3> 
<p>        <strong>思路：<span style="color:#fe2c24;">假设第一个元素已经排序好了的，在已经排好的元素的后一个元素记录为 low，这个 low 索引对应的元素需要用临时变量来接受，只要找到比这个索引对应的元素小的值，就可以插入到比它小的值的后一个索引位置了，当然，每一次对比之后，都需要往后移一个位置，以便直接插入。当 low 一直每一个加 1 ，当 low 等于数组的长度时，就该停止了继续递归下去了。</span></strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class Recursion {
    // 插入排序
    public static void main(String[] args) {
        int[] arr = {1,3,2,4,9,10,13};
        fun5(arr,1);
        System.out.println(Arrays.toString(arr));
    }

    public static void fun5 (int[] arr,int low) {
        if (low == arr.length) {
            return;
        }
        int temp = arr[low];
        int i = low - 1;
        while (arr[i] &gt; temp) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = temp;
        fun5(arr,low + 1);
    }</code></pre> 
 <p><strong>运行结果如下：</strong></p> 
 <p><img alt="" class="left" height="120" src="https://images2.imgbox.com/c2/e2/7Q0ig1vB_o.png" width="292"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E9%80%92%E5%BD%92%20-%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91">        2.7 递归 - 斐波那契</h3> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //斐波那契
    public static void main(String[] args) {
        System.out.print(fun6(1) +" ");
        System.out.print(fun6(2) +" ");
        System.out.print(fun6(3) +" ");
        System.out.print(fun6(4) +" ");
        System.out.print(fun6(5) +" ");
        System.out.print(fun6(6) +" ");
    }

    public static int fun6 (int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1 || n == 2) {
            return 1;
        }

        return fun6(n-1) + fun6(n - 2);
    }</code></pre> 
 <p><strong>运行结果如下：</strong></p> 
 <p><img alt="" class="left" height="89" src="https://images2.imgbox.com/8d/31/U889BDii_o.png" width="220"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.8%20%E9%80%92%E5%BD%92%20-%20%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98">        2.8 递归 - 兔子问题</h3> 
<p> <strong>       一个斐波那契的变体问题。</strong></p> 
<p><strong>        思路：<span style="color:#fe2c24;">观察第六个月的兔子个数，是否等于第四个月的兔子的总数加上第五个月的兔子总数；类推，第五个月的兔子个数，是否等于第四个月的兔子的总数加上第三个月的兔子总数</span>；以此类推，是符合斐波那契逻辑的。</strong></p> 
<blockquote> 
 <p><img alt="" class="left" height="780" src="https://images2.imgbox.com/d8/c1/n8PIfYqx_o.png" width="965"></p> 
</blockquote> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //兔子问题
    public static void main(String[] args) {
        System.out.print(fun7(1) + " ");
        System.out.print(fun7(2) + " ");
        System.out.print(fun7(3) + " ");
        System.out.print(fun7(4) + " ");
        System.out.print(fun7(5) + " ");
    }
    
    public static int fun7 (int n) {
        if (n == 1) {
            return 1;
        }
        if (n == 0) {
            return 0;
        }
        return fun7(n -1) + fun7(n - 2);
    }</code></pre> 
 <p><strong>运行结果如下：</strong></p> 
 <p><img alt="" class="left" height="89" src="https://images2.imgbox.com/d8/a0/vlixLEI0_o.png" width="200"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.9%20%E9%80%92%E5%BD%92%20-%20%E9%9D%92%E8%9B%99%E7%88%AC%E6%A5%BC%E6%A2%AF">        2.9 递归 - 青蛙爬楼梯</h3> 
<p><strong>        一个斐波那契的变体问题。</strong></p> 
<p><strong>题目如下：</strong></p> 
<blockquote> 
 <p><img alt="" class="left" height="139" src="https://images2.imgbox.com/3e/79/WKFIdChM_o.png" width="664"></p> 
 <p><strong>列举一下：</strong></p> 
 <p><img alt="" class="left" height="389" src="https://images2.imgbox.com/d3/77/Bih3AgI8_o.png" width="604"></p> 
</blockquote> 
<p>        <strong>实现思路： 一<span style="color:#fe2c24;">个阶梯一种跳法，两个阶梯两种跳法。重点，如果有四个阶梯，从后往前分析，分两种情况；第一种，从第二个台阶直接一下子跳两阶上来。第二种，从第三个台阶跳一阶上来。那么从考虑第一种情况，前面两阶是不是就是只有两种方法。考虑第二种情况，前面的三个台阶是不是就是前面已经算出来的方式跳法个数了</span>。因此，这就是一个斐波那契的变体问题。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //青蛙问题
    public static void main(String[] args) {
        System.out.print(fun8(1) + " ");
        System.out.print(fun8(2) + " ");
        System.out.print(fun8(3) + " ");
        System.out.print(fun8(4) + " ");
        System.out.print(fun8(5) + " ");
        System.out.print(fun8(6) + " ");
    }

    public static int fun8 (int n) {
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 2;
        }
        return fun8(n-1) +fun8(n-2);
    }</code></pre> 
 <p><strong>运行结果如下：</strong></p> 
 <p><img alt="" height="96" src="https://images2.imgbox.com/93/86/jUUZZnta_o.png" width="235"></p> 
</blockquote> 
<p style="text-align:center;"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9e/29/wxXkE3hd_o.gif"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62f298f7266c3e1122b7bc6154478433/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python实现图片与PDF互相转换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52fbb535e9e2cd24f81e87bf39da44fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Node.js Express框架</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>