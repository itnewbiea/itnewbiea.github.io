<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java乱码总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java乱码总结" />
<meta property="og:description" content="昨天项目遇到了乱码问题，在自己电脑上是没问题的然而在服务器上就出现的乱码的问题，所以就以乱码为点来仔细的了解一下Java中的乱码。
先简单了解一下java的字符串的编码到存储的过程： java在字符串中统一用Unicode表示。
对于任意一个字符串：String string = “测试字符串”;
如果源文件是GBK编码，操作系统默认环境编码也为GBK，那么编译的时候，JVM将按照GBK编码将字节数组解析为字符，然后将字符转换为Unicode格式的字节数组，作为内部存储(字节数组→字符→Unicode字节数组)。当打印这个字符串时，JVM根据操作系统本地的语言环境，将Unicode转换为GBK，然后操作系统将GBK格式的内容显示出来。
当源码文件是UTF-8, 我们需要通知编译器源码的格式，javac -encoding utf-8 … , 编译时，JVM按照utf-8 解析成字符，然后转换为unicode格式的字节数组， 那么不论源码文件是什么格式，同样的字符串，最后得到的unicode字节数组是完全一致的，显示的时候，也是转成GBK来显示（跟OS环境有关）
一、Java常见的编码方式 ASCII码：众所周知，这是最简单的编码。它总共可以表示128个字符，0~31是控制字符如换行、回车、删除等，32~126是打印字符，可以通过键盘输入并且能够显示出来的。
ISO-8859-1：它是基于ASCII码基础上扩展的，它总共能表示256个字符，涵盖了大多数西欧语言字符。详见　ISO-8859-1 编码 该编码不支持中文，举个中文编码栗子 :字符串“I am 君山”用 ISO-8859-1 编码，下面是编码结果　由于ISO-8859-1 是单字节编码且不支持中文，直接将中文字符转成‘3f’, 3f也就是常见的&#34;?&#34;字符
GB2312： 它是双字节编码，共包含6763个汉字。
GBK：汉字内码扩展规范，是基于GB2312上拓展的，加入了更多的汉字，能表示21003个汉字。它的编码是和GB2312兼容的。也就是说用GB2312编码的汉字可以用GBK来解码，并且不会乱码。倒过来就不完全可以了，因为GB2312描述的汉字比GBK少。
UTF-16：UTF-16是基于Unicode上定义的， 用两个字节来表示Unicode的转换格式，它采用定长的表示方法，即不能什么字符都可以用两个字节表示。两个字节是16个bit，所以就做UTF-16。（Unicode 囊括了世界上所有语言，所有语言均可通过Unicode来相互翻译，详解 Unicode 编码）
UTF-8：由于UTF-16统一采用两个字节来表示一个字符， 有很多字符用一个字节表示即可。所以存储空间放大了一倍，还会增加网络传输的流量,所以推出了UTF-8。 UTF-8采用了一种变长技术，每个编码区域有不同的字码长度。
二、常见乱码问题分析 乱码指的是程序显示出来的字符文本无法用任何语言去解读。一般情况下会包含大量的?。本质上都是由于字符串原本的编码格式与读取时解析用的编码格式不一致导致的。
中文变成看不懂的字符：如果一串中文字符变成了一串看不懂的字符如：&#34;Ì Ô £ ¡Î Ò Ï²»¶ £ ¡&#34;，这种情况通常是编码字符集与解码时所用的字符集不一致所造成的。比如使用GBK编码，如果使用ISO-8859-1解码的话结果就是这样。一个汉字变成了一个问号：如果编码和解码的字符集都是一致的，那么可以确定该字符编码不支持中文，例如：ISO-8859-1一个汉字变成了两个问号：中文经过多次编码且其中有一次编码或者解码使用了不支持中文的字符集　三、常见案例分析 参数传输乱码
背景：从jsp中传参数（包括中文）请求后台数据，在后台获取到的请求参数乱码。
1、前端编码设置，先讲解下jsp中编码的配置：
a、其中contentType中charset用来设置服务器发送给客户端时的内容编码；pageEncoding 用来设置JSP源文件本身和响应正文中的字符编码。通俗的说pageEncoding是jsp文件本身的编码，如果pageEncoding设置为ISO-8859-1,则jsp页面中不能保存中文字符，会自动提示你是否要设置为UTF-8.
b、jsp文件编码字符集默认为ISO-8859-1, JSP源文件字符集时,优先级为pageEncoding&gt;contentType。如果都没有设置，默认ISO-8859-1。
c、设置响应输出的字符集时,优先级为contentType&gt;pageEncoding。如果都没有设置，默认ISO-8859-1。
&lt;%@ page language=&#34;java&#34; contentType=&#34;text/html; charset=UTF-8&#34; pageEncoding=&#34;UTF-8&#34;%&gt; 综上所述，解决该问题乱码的第一步要设置jsp中的编码，最好统一为UTF-8。 exmaple（乱码示例）: 页面效果如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8fd7141dc9719091d5663d11de5a83b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-12T14:10:06+08:00" />
<meta property="article:modified_time" content="2019-03-12T14:10:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java乱码总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>昨天项目遇到了乱码问题，在自己电脑上是没问题的然而在服务器上就出现的乱码的问题，所以就以乱码为点来仔细的了解一下Java中的乱码。</p> 
<h4>先<strong>简单了解一下java的字符串的编码到存储的过程：</strong></h4> 
<p>java在字符串中统一用<strong>Unicode</strong>表示。</p> 
<p>对于任意一个字符串：String string = “测试字符串”;</p> 
<p>如果源文件是GBK编码，操作系统默认环境编码也为GBK，那么编译的时候，JVM将按照GBK编码将字节数组解析为字符，然后将字符转换为Unicode格式的字节数组，作为内部存储(字节数组→字符→Unicode字节数组)。当打印这个字符串时，JVM根据操作系统本地的语言环境，将Unicode转换为GBK，然后操作系统将GBK格式的内容显示出来。</p> 
<p>当源码文件是UTF-8, 我们需要通知编译器源码的格式，javac -encoding utf-8 … , 编译时，JVM按照utf-8 解析成字符，然后转换为unicode格式的字节数组， 那么不论源码文件是什么格式，同样的字符串，最后得到的unicode字节数组是完全一致的，显示的时候，也是转成GBK来显示（跟OS环境有关）</p> 
<h4><strong>一、Java常见的编码方式</strong></h4> 
<ol><li> <p><strong>ASCII码</strong><strong>：</strong>众所周知，这是最简单的编码。它总共可以表示128个字符，0~31是控制字符如换行、回车、删除等，32~126是打印字符，可以通过键盘输入并且能够显示出来的。</p> </li><li> <p><strong>ISO-8859-1</strong><strong>：</strong>它是基于ASCII码基础上扩展的，它总共能表示256个字符，涵盖了大多数西欧语言字符。详见　<a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1?cm_mc_uid=33452963067114953496310&amp;cm_mc_sid_50200000=1496479743" rel="nofollow">ISO-8859-1 编码</a>  该编码不支持中文，举个中文编码栗子 :字符串“I am 君山”用 ISO-8859-1 编码，下面是编码结果　　</p> </li></ol> 
<p style="text-align:center;"><img alt="" class="has" height="143" src="https://images2.imgbox.com/2b/d5/LQuVHnae_o.png" width="523"></p> 
<p>                    </p> 
<p>     由于ISO-8859-1 是单字节编码且不支持中文，直接将中文字符转成‘3f’, 3f也就是常见的"?"字符</p> 
<ol><li> <p><strong>GB2312</strong><strong>：</strong> 它是双字节编码，共包含6763个汉字。</p> </li><li> <p><strong>GBK：</strong>汉字内码扩展规范，是基于GB2312上拓展的，加入了更多的汉字，能表示21003个汉字。它的编码是和GB2312兼容的。也就是说用GB2312编码的汉字可以用GBK来解码，并且不会乱码。倒过来就不完全可以了，因为GB2312描述的汉字比GBK少。</p> </li><li> <p><strong>UTF-16：</strong>UTF-16是基于Unicode上定义的， 用两个字节来表示Unicode的转换格式，它采用定长的表示方法，即不能什么字符都可以用两个字节表示。两个字节是16个bit，所以就做UTF-16。（Unicode 囊括了世界上所有语言，所有语言均可通过Unicode来相互翻译，详解<a href="http://www.unicode.org/charts/?cm_mc_uid=33452963067114953496310&amp;cm_mc_sid_50200000=1496479743" rel="nofollow"> Unicode 编码</a>）</p> </li><li> <p><strong>UTF-8：</strong>由于UTF-16统一采用两个字节来表示一个字符， 有很多字符用一个字节表示即可。所以存储空间放大了一倍，还会增加网络传输的流量,所以推出了UTF-8。 UTF-8采用了一种变长技术，每个编码区域有不同的字码长度。</p> </li></ol> 
<h4><strong>二、常见乱码问题分析</strong></h4> 
<p>乱码指的是程序显示出来的字符文本无法用任何语言去解读。一般情况下会包含大量的?。本质上都是<strong>由于字符串原本的编码格式与读取时解析用的编码格式不一致导致的</strong>。</p> 
<ol><li><strong>中文变成看不懂的字符：</strong>如果一串中文字符变成了一串看不懂的字符如："Ì Ô £ ¡Î Ò Ï²»¶ £ ¡"，这种情况通常是编码字符集与解码时所用的字符集不一致所造成的。比如使用GBK编码，如果使用ISO-8859-1解码的话结果就是这样。</li><li><strong>一个汉字变成了一个问号：</strong>如果编码和解码的字符集都是一致的，那么可以确定该字符编码不支持中文，例如：ISO-8859-1</li><li><strong>一个汉字变成了两个问号：</strong>中文经过多次编码且其中有一次编码或者解码使用了不支持中文的字符集　</li></ol> 
<h4><strong>三、常见案例分析</strong></h4> 
<p><strong>参数传输乱码</strong></p> 
<p><strong>　</strong>背景：从jsp中传参数（包括中文）请求后台数据，在后台获取到的请求参数乱码。</p> 
<p><strong>1、前端编码设置，先讲解下jsp中编码的配置：</strong></p> 
<p>　　a、其中contentType中charset用来设置服务器发送给客户端时的内容编码；pageEncoding 用来设置JSP源文件本身和响应正文中的字符编码。通俗的说pageEncoding是jsp文件本身的编码，如果pageEncoding设置为ISO-8859-1,则jsp页面中不能保存中文字符，会自动提示你是否要设置为UTF-8.</p> 
<p>　　b、jsp文件编码字符集默认为ISO-8859-1, JSP源文件字符集时,<a href="http://wenwen.soso.com/z/Search.e?sp=S%E4%BC%98%E5%85%88%E7%BA%A7&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" rel="nofollow">优先级</a>为pageEncoding&gt;contentType。如果都没有设置，默认ISO-8859-1。</p> 
<p>　　c、设置响应输出的字符集时,优先级为contentType&gt;pageEncoding。如果都没有设置，默认ISO-8859-1。</p> 
<pre class="has"><code class="language-html">&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;
综上所述，解决该问题乱码的第一步要设置jsp中的编码，最好统一为UTF-8。  
   
    exmaple（乱码示例）:
</code></pre> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/28/65/UIqFNmWQ_o.png"></p> 
<p>　页面效果如下：</p> 
<p style="text-align:center;"><img alt="" class="has" height="111" src="https://images2.imgbox.com/ed/9e/Eu4phBnz_o.png" width="551"></p> 
<p><strong>2、后端编码设置</strong></p> 
<p>　首先要设置tomcat编码，其中要了解两个参数（conf/server.xml）：URIEncoding和useBodyEncodingForURI，可以查看官方文档说明<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/http.html" rel="nofollow">http://tomcat.apache.org/tomcat-7.0-doc/config/http.html</a>， 以下是我理解：</p> 
<ul><li> <p>URIEncoding是对所有GET方式的请求的数据进行统一的重新编码，默认编码 ISO-8859-1（针对URI上的请求参数）</p> </li><li> <p>useBodyEncodingForURI：此设置仅适用于请求的查询字符串（针对请求体中内容）。 与URIEncoding不同，它不影响请求URI的路径部分。如果不知道请求字符编码（浏览器不提供，并且SetCharacterEncodingFilter不设置或使用Request.setCharacterEncoding方法的类似过滤器），默认编码始终为“ISO-8859-1”。URIEncoding设置对此默认值没有影响。该参数为false。通俗的说：true表示get和post的编码保持一致，post方式的编码是什么，get方式的编码就是什么。false表示get和post的字符编码各自设置，互相没有关系。</p> </li><li> <p><strong>example1（只设置URIEncoding）:     </strong></p> </li></ul> 
<p><strong>        </strong>server.xml：</p> 
<pre class="has"><code class="language-java">&lt;Connector connectionTimeout="20000" port="9080" protocol="HTTP/1.1"  
　　　　　　　　redirectPort="443" URIEncoding="UTF-8" /&gt;</code></pre> 
<p>       controller:</p> 
<pre class="has"><code class="language-java">   　　　　@RequestMapping(value = "/testURI", method=RequestMethod.POST)
    　　　　@ResponseBody
    　　　　public String testURI(HttpServletRequest request){
        　　　　String username = request.getParameter("username");
        　　　　String nickname = request.getParameter("nickname");
        　　　　System.out.println("姓名：" + username + ", 昵称：" + nickname);
       　　 　　return "姓名：" + username + ", 性别：" + nickname;
    　　　　}</code></pre> 
<p>　    jsp:</p> 
<pre class="has"><code class="language-java">&lt;form action="${pageContext.request.contextPath }/testURI.html?username=张三" method="post"&gt;
        　　&lt;input type="text" name="nickname" value="老张三"/&gt;
        　　&lt;input type="submit" value="提交"/&gt;
    　　&lt;/form&gt;</code></pre> 
<p>　 输出结果：   姓名：张三, 昵称：èå¼ ä¸</p> 
<p>　　　　从结果中可以看出， URIEncoding只对URI中的参数进行编码。　</p> 
<ul><li><strong>example2：只修改controller中代码，就都会显示正常</strong></li></ul> 
<pre class="has"><code class="language-java">　@RequestMapping(value = "/testURI", method=RequestMethod.POST)
    　　@ResponseBody
    　　public String testURI(HttpServletRequest request) throws UnsupportedEncodingException{
        　　request.setCharacterEncoding("UTF-8");
        　　String username = request.getParameter("username");
       　　 String nickname = request.getParameter("nickname");
        　　System.out.println("姓名：" + username + ", 昵称：" + nickname);
        　　return "姓名：" + username + ", 性别：" + nickname;
    　　}</code></pre> 
<p>其实第二种做法并不是很方便，一般通过设置URIEncoding+encodingFilter即可解决。</p> 
<ul><li><strong>example3（通常做法）：  </strong></li></ul> 
<p><strong>              </strong>web.xml代码如下，其余跟example1一样即可。</p> 
<pre class="has"><code class="language-java">　&lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</code></pre> 
<ul><li><strong>　example4：</strong></li></ul> 
<pre class="has"><code class="language-java"> 　　@RequestMapping(value = "/testURI", method=RequestMethod.POST)
    　　@ResponseBody
    　　public String testURI(HttpServletRequest request) throws UnsupportedEncodingException{
        　　request.setCharacterEncoding("UTF-8");
        　　String username = request.getParameter("username");
       　　 String nickname = request.getParameter("nickname");
        　　System.out.println("姓名：" + username + ", 昵称：" + nickname);
        　　return "姓名：" + username + ", 性别：" + nickname;
    　　}    </code></pre> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/79/f9/4R5KWKzI_o.png"></p> 
<p>如果只设置URIEncoding=ISO-8859-1，request.setCharacterEncoding("UTF-8");只会对请求体中的参数进行编码，所以username是乱码的。</p> 
<ul><li><strong>example5: 在example4的基础上设置useBodyEncodingForURI="true"，</strong>设置<strong>useBodyEncodingForURI=true</strong>时，就会将请求参数和请求体中的参数根据request.setCharacterEncoding或者contentType中的字符集编码。</li></ul> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/fe/1d/DwmRG2PG_o.png"></p> 
<ul><li><strong> request乱码：</strong></li></ul> 
<ol><li><strong>POST请求：</strong>request.setCharacterEncoding();---&gt;只对post请求有效。</li><li><strong>GET请求：</strong></li></ol> 
<p>问题本质是get方式传递的参数内容默认编码方式问ISO8859-1，而且使用request.setCharacterEncoding("utf-8")也无法解决问题</p> 
<p>法一：要解决这个问题，修改tomcat服务器的配置文件。修改tomcat目录下的conf/server.xml文件也就是上面<strong>example1</strong>所说的设置<strong>URIEncoding</strong></p> 
<p>法二：<strong>下文的  new String(s.getBytes(“iso-8859-1”) ,”UTF-8”);</strong></p> 
<ul><li>response乱码：</li></ul> 
<p>法一：response.setCharacterEncoding("UTF-8"); 目的是用于response.getWriter()输出的字符流的乱码问题。如果是response.getOutputStream()是不需要此种解决方案的，因为这句话的意思是为了将response对象中的数据以UTF-8解码后的字节流发向浏览器；</p> 
<p>法二：response.setContentType("text/html;charset=utf-8"); 目的是为了控制浏览器的行为，即控制浏览器用UTF-8进行解码；</p> 
<p>      response.setHeader("content-type","text/html;charset=UTF-8");告诉浏览器用utf-8解析(setHeader是HttpServletResponse的方法。如果想在拦截器Filter中设置字符编码，则无此方法，因为Filter的doFilter方法的参数类型是ServletResponse)</p> 
<p> </p> 
<p> </p> 
<h4><strong>四、终极武器</strong>即通过平台默认字符集进行编码getBytes()</h4> 
<p><strong>new String(s.getBytes(“iso-8859-1”) ,”UTF-8”);</strong></p> 
<p><strong>new String(s.getBytes(“iso-8859-1”) ,”GBK”)</strong></p> 
<ul><li><strong>GBK&lt;-----&gt;UTF-8</strong></li></ul> 
<p>          先来看几个例子：</p> 
<pre class="has"><code class="language-java">例如：String str = “java乱码问题”;
//错误，因为getBytes()默认使用GBK编码， 而解析时使用UTF-8编码，肯定出错。
System.out.println( new String(str.getBytes(),"UTF-8")); 
//错误，因为getBytes 的编码与 UTF-8 不一致，肯定是乱码
System.out.println( new String( s.getBytes("GBK") , "UTF-8));  
//结果都是正确的，因为它们的源内容编码和解析用的编码是一致
System.out.println( new String(s.getBytes(),"GBK"));
System.out.println( new String(s.getBytes("UTF-8"),"UTF-8"));</code></pre> 
<p>其中getBytes()是将Unicode转换为操作系统默认格式的字节数组，即“java乱码问题”的GBK格式，new String (bytes, Charset) 中的charset 是指定读取byte的方式，这里指定为UTF-8，即把bytes的内容当做UTF-8来读取。</p> 
<p>原理：利用getBytes将unicode字符串转成UTF-8格式的字节数组，然后用utf-8 对这个字节数组解码成新的字符串，转GBK也是   同理。</p> 
<pre class="has"><code class="language-java">//GBK转UTF-8
new String( s.getBytes("utf-8") , "utf-8");

UTF-8 转GBK
new String( s.getBytes("GBK") , "GBK");
</code></pre> 
<p>其实核心工作都由getBytes(charset)做了。getBytes的JDK描述：Encoding this String into a sequence of bytes using the named charset,storing the result into a new byte array.</p> 
<pre class="has"><code class="language-java">OutputStreamWriter w1 = new OutputStreamWriter(new FileOutputStream("D:\\file1.txt"),"UTF-8");
InputStreamReader( stream, charset)</code></pre> 
<p>可以帮助我们轻松的按照指定编码读写文件。</p> 
<ul><li>为什么在tomcat 下使用new String(s.getBytes(“iso-8859-1”) ,”GBK”)可以呢？</li></ul> 
<p>tomcat 默认使用iso-8859-1编码， 也就是说，如果原本字符串是GBK的，tomcat传输过程中，将GBK转成iso-8859-1了，默认情况下，使用iso-8859-1读取中文肯定是有问题的，那么我们需要将iso-8859-1 再转成GBK， 而iso-8859-1 是单字节编码的，即他认为一个字节是一个字符， 那么这种转换不会对原来的字节数组做任何改变，因为字节数组本来就是由单个字节组成的，如果之前用GBK编码，那么转成iso-8859-1后编码内容完全没变， 则 s.getBytes(“iso-8859-1”) 实际上还是原来GBK的编码内容则 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 就可以正确解码了。 所以说这是一种巧合。<br>  </p> 
<p>参考链接：<a href="https://blog.csdn.net/lmb55/article/details/78857024">https://blog.csdn.net/lmb55/article/details/78857024</a></p> 
<p>参考链接：<a href="https://www.cnblogs.com/yuanfy008/p/6937803.html" rel="nofollow">https://www.cnblogs.com/yuanfy008/p/6937803.html</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d77865306347dde1c4b106d7256237a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ViewModel源码分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b8ebe0a0cb59cfbd466f76a9acebeaa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">zabbix-server配置文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>