<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>读书笔记：推荐系统实践-第二章-利用用户行为数据 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="读书笔记：推荐系统实践-第二章-利用用户行为数据" />
<meta property="og:description" content="1、用户行为数据简介 用户行为在个性化推荐系统一般会分为两种：显性反馈行为和隐性反馈行为。
如何用统一的方式表示这些所有的行为？
不同行为的不同数据集
无上下文信息的隐性反馈数据集 每一条行为记录仅仅包含用户ID和物品ID。无上下文信息的显性反馈数据集 每一条记录包含用户ID、物品ID和用户对物品的评分。有上下文信息的隐性反馈数据集 每一条记录包含用户ID、物品ID和用户对物品产生行。有上下文信息的显性反馈数据集 每一条记录包含用户ID、物品ID、用户对物品的评分和评分行为发生的时间戳。 2、用户行为分析 2.1 用户活跃度和物品流行度的分布 用户的行为数据是满足长尾分布的，下面两者都满足长尾分布
fu(k)为对k个物品产生过行为的用户数fi(k)为被k个用户产生过行为的物品数
2.2 用户活跃度和物品流行度的关系 一般认为，新用户倾向于浏览热门的物品，而老用户会之间开始浏览冷门的物品
基于用户行为数据设计的推荐算法一本称为协同过滤算法，该算法又可以分为：
基于邻域的方法（neighborhood-based） 基于用户的协同过滤算法基于物品的协同过滤算法 隐语义模型（latent factor model）基于图的随机游走算法（random walk on graph） 3、实验设计和算法测评 数据集：MovieLens研究问题：TopN推荐问题训练集与测试集：N折交叉验证测评指标 准确率 召回率覆盖率：最终的推荐列表中包含多大比例的物品新颖度：推荐列表中物品的平均流行度 在计算平均流行度时对每个物品的流行度取对数。因为物品的流行度分布满足长尾分布，取对数之中，流行度的平均值更加稳定。 4、基于邻域的算法 4.1 基于用户的协同过滤算法 基本的两个步骤 找到和目标用户兴趣相似的用户合集找到和这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给用户目标 计算相似度的两个方法： 给定用户u和用户v，令N(u)表示用户u曾经有过正反馈的物品集合，令N(v)为用户v曾经有过正反馈的物品集合。Jaccard公式
余弦相似度
计算余弦相似度的方法（降低计算复杂度版）：原有的余弦相似度计算方法是直接两两进行计算，每次计算分子和分母。这样计算和节约计算两者都为0的计算，以及分母的重复计算。
计算结果和超参 只有一个超参K，即为每个用户选取K个和他兴趣最相似的用户准确率和召回率：适合的K会影响到模型的精度，但是精度对K不是特别敏感流行度：K越大，推荐结果越热门覆盖率：K越大，推荐结果覆盖率越低 用户相似度计算的改进User-IIF 主要思想：两个用户对冷门物品采取过同样的行为更能说明兴趣的相似度所以将相似度计算改进为如下，从而惩罚了共同的热门物品的影响：
4.2 基于物品的协同过滤算法 计算步骤 计算物品之间的相似程度根据物品的相似度和用户的历史行为给用户生成推荐列表 相似度计算公式 计算公式如下，分母表示喜欢物品i的用户数，分子表示同时喜欢物品i和物品j的用户
哈利波特问题：当j是很热门的物品时，会导致Wij计算出来很大，也就是热门物品和任何物品都会有很大的相似度，为了防止这个问题对公式进行修正。
为了解决哈利波特问题，进一步可以加大分母上对热门物品的惩罚
具体计算的方法 建立用户-物品倒排表对每个用户建立一个包含他喜欢的物品的列表，将他物品列表中的物品构建单用户的共现矩阵将这些矩阵相加可以得到C矩阵，将之归一化可以得到余弦相似度矩阵
得到物品相似度以后，用下面的公式计算用户u对物品j的兴趣：这里N(u)是用户喜欢的物品的集合，S(j,K)是和物品j最相似的K个物品的集合，wji是物品j和i的相似度，rui是用户u对物品i的兴趣。（对于隐反馈数据集，如果用户u对物品i有过行为，即可令 rui=1。）该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名
效果与超参 精度：选择合适的K对获得最高精度是很重要的流行度：随着K的增加流行度会提高，但是当增加到一定程度，流行度就不会有明显的变化覆盖率：K增加会降低系统的覆盖率 用户活跃度对物品相似度的影响-ItemCF-IUF 活跃用户对物品相似度的贡献应该小于不活跃的用户，应该增加IUF（inverse user frequence）参数来修正物品相似度的计算公式
可以提升覆盖率，降低流行度 物品相似度的归一化 热门的类其类内相似度一般比较大，如果不进行归一化，就会推荐比较热门的类里面的物品，而这些物品是比较热门的。从而，降低推荐的覆盖率。
作用：增加推荐的准确度，提高推荐的覆盖率和多样性 4.3 UserCF和ItemCF的综合比较 5 隐语义模型 5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/544ca5ec57d5fa01e8b56a7b92f13f0e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-23T16:51:14+08:00" />
<meta property="article:modified_time" content="2019-04-23T16:51:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">读书笔记：推荐系统实践-第二章-利用用户行为数据</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1、用户行为数据简介</h2> 
<p>用户行为在个性化推荐系统一般会分为两种：显性反馈行为和隐性反馈行为。<br> <img src="https://images2.imgbox.com/b7/67/UUWYLnUu_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/17/d5/uBwaQtJy_o.png" alt="在这里插入图片描述"><br> 如何用统一的方式表示这些所有的行为？<br> <img src="https://images2.imgbox.com/91/e6/fIUSoTBq_o.png" alt="在这里插入图片描述"><br> 不同行为的不同数据集</p> 
<ul><li>无上下文信息的隐性反馈数据集 每一条行为记录仅仅包含用户ID和物品ID。</li><li>无上下文信息的显性反馈数据集 每一条记录包含用户ID、物品ID和用户对物品的评分。</li><li>有上下文信息的隐性反馈数据集 每一条记录包含用户ID、物品ID和用户对物品产生行。</li><li>有上下文信息的显性反馈数据集 每一条记录包含用户ID、物品ID、用户对物品的评分和评分行为发生的时间戳。</li></ul> 
<h2><a id="2_12"></a>2、用户行为分析</h2> 
<h3><a id="21__13"></a>2.1 用户活跃度和物品流行度的分布</h3> 
<p>用户的行为数据是满足长尾分布的，下面两者都满足长尾分布</p> 
<ul><li>fu(k)为对k个物品产生过行为的用户数</li><li>fi(k)为被k个用户产生过行为的物品数<br> <img src="https://images2.imgbox.com/ea/13/mtRRpvmY_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="22__18"></a>2.2 用户活跃度和物品流行度的关系</h3> 
<p>一般认为，新用户倾向于浏览热门的物品，而老用户会之间开始浏览冷门的物品<br> <img src="https://images2.imgbox.com/bb/e9/YcIzVrkg_o.png" alt="在这里插入图片描述"><br> 基于用户行为数据设计的推荐算法一本称为协同过滤算法，该算法又可以分为：</p> 
<ul><li>基于邻域的方法（neighborhood-based） 
  <ul><li>基于用户的协同过滤算法</li><li>基于物品的协同过滤算法</li></ul> </li><li>隐语义模型（latent factor model）</li><li>基于图的随机游走算法（random walk on graph）</li></ul> 
<h2><a id="3_28"></a>3、实验设计和算法测评</h2> 
<ul><li>数据集：MovieLens</li><li>研究问题：TopN推荐问题</li><li>训练集与测试集：N折交叉验证</li><li>测评指标 
  <ul><li>准确率 召回率</li><li>覆盖率：最终的推荐列表中包含多大比例的物品</li><li>新颖度：推荐列表中物品的平均流行度</li></ul> </li><li>在计算平均流行度时对每个物品的流行度取对数。因为物品的流行度分布满足长尾分布，取对数之中，流行度的平均值更加稳定。</li></ul> 
<h2><a id="4_38"></a>4、基于邻域的算法</h2> 
<h3><a id="41__39"></a>4.1 基于用户的协同过滤算法</h3> 
<h5><a id="_40"></a>基本的两个步骤</h5> 
<ul><li>找到和目标用户兴趣相似的用户合集</li><li>找到和这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给用户目标</li></ul> 
<h5><a id="_44"></a>计算相似度的两个方法：</h5> 
<ul><li>给定用户u和用户v，令N(u)表示用户u曾经有过正反馈的物品集合，令N(v)为用户v曾经有过正反馈的物品集合。</li><li>Jaccard公式<br> <img src="https://images2.imgbox.com/32/1c/ZJl6c13V_o.png" alt="在这里插入图片描述"></li><li>余弦相似度<br> <img src="https://images2.imgbox.com/27/9a/jLSzIKbA_o.png" alt="在这里插入图片描述"><br> 计算余弦相似度的方法（降低计算复杂度版）：原有的余弦相似度计算方法是直接两两进行计算，每次计算分子和分母。这样计算和节约计算两者都为0的计算，以及分母的重复计算。<br> <img src="https://images2.imgbox.com/9e/7c/8XRn5yuz_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="_52"></a>计算结果和超参</h5> 
<ul><li>只有一个超参K，即为每个用户选取K个和他兴趣最相似的用户</li><li>准确率和召回率：适合的K会影响到模型的精度，但是精度对K不是特别敏感</li><li>流行度：K越大，推荐结果越热门</li><li>覆盖率：K越大，推荐结果覆盖率越低</li></ul> 
<h5><a id="UserIIF_57"></a>用户相似度计算的改进User-IIF</h5> 
<ul><li>主要思想：两个用户对冷门物品采取过同样的行为更能说明兴趣的相似度</li><li>所以将相似度计算改进为如下，从而惩罚了共同的热门物品的影响：<br> <img src="https://images2.imgbox.com/fe/c2/Znc62z6G_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="42__62"></a>4.2 基于物品的协同过滤算法</h3> 
<h5><a id="_63"></a>计算步骤</h5> 
<ul><li>计算物品之间的相似程度</li><li>根据物品的相似度和用户的历史行为给用户生成推荐列表</li></ul> 
<h5><a id="_67"></a>相似度计算公式</h5> 
<ul><li>计算公式如下，分母表示喜欢物品i的用户数，分子表示同时喜欢物品i和物品j的用户<br> <img src="https://images2.imgbox.com/56/12/Rauuja4N_o.png" alt="在这里插入图片描述"></li><li>哈利波特问题：当j是很热门的物品时，会导致Wij计算出来很大，也就是热门物品和任何物品都会有很大的相似度，为了防止这个问题对公式进行修正。<br> <img src="https://images2.imgbox.com/3f/45/G8LYcc3g_o.png" alt="在这里插入图片描述"></li><li>为了解决哈利波特问题，进一步可以加大分母上对热门物品的惩罚<br> <img src="https://images2.imgbox.com/d2/30/a6wFxwhx_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="_74"></a>具体计算的方法</h4> 
<ul><li>建立用户-物品倒排表</li><li>对每个用户建立一个包含他喜欢的物品的列表，将他物品列表中的物品构建单用户的共现矩阵</li><li>将这些矩阵相加可以得到C矩阵，将之归一化可以得到余弦相似度矩阵<br> <img src="https://images2.imgbox.com/bc/68/Sey2c194_o.png" alt="在这里插入图片描述"></li><li>得到物品相似度以后，用下面的公式计算用户u对物品j的兴趣：这里N(u)是用户喜欢的物品的集合，S(j,K)是和物品j最相似的K个物品的集合，wji是物品j和i的相似度，rui是用户u对物品i的兴趣。（对于隐反馈数据集，如果用户u对物品i有过行为，即可令 rui=1。）该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名<br> <img src="https://images2.imgbox.com/09/57/JlfVoGrp_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="_81"></a>效果与超参</h5> 
<ul><li>精度：选择合适的K对获得最高精度是很重要的</li><li>流行度：随着K的增加流行度会提高，但是当增加到一定程度，流行度就不会有明显的变化</li><li>覆盖率：K增加会降低系统的覆盖率</li></ul> 
<h5><a id="ItemCFIUF_86"></a>用户活跃度对物品相似度的影响-ItemCF-IUF</h5> 
<ul><li>活跃用户对物品相似度的贡献应该小于不活跃的用户，应该增加IUF（inverse user frequence）参数来修正物品相似度的计算公式<br> <img src="https://images2.imgbox.com/87/95/mM66vyTi_o.png" alt="在这里插入图片描述"></li><li>可以提升覆盖率，降低流行度</li></ul> 
<h5><a id="_91"></a>物品相似度的归一化</h5> 
<ul><li>热门的类其类内相似度一般比较大，如果不进行归一化，就会推荐比较热门的类里面的物品，而这些物品是比较热门的。从而，降低推荐的覆盖率。<br> <img src="https://images2.imgbox.com/70/b4/ujztcqVn_o.png" alt="在这里插入图片描述"></li><li>作用：增加推荐的准确度，提高推荐的覆盖率和多样性</li></ul> 
<h3><a id="43_UserCFItemCF_96"></a>4.3 UserCF和ItemCF的综合比较</h3> 
<p><img src="https://images2.imgbox.com/b1/35/z7DYERAa_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5__99"></a>5 隐语义模型</h2> 
<h3><a id="51__100"></a>5.1 基础算法</h3> 
<ul><li> <p>主要思想：对书和物品的兴趣分类，对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品</p> </li><li> <p>LFM通过如下公式计算用户u对物品i的兴趣<br> <img src="https://images2.imgbox.com/7b/17/3h1sfwnk_o.png" alt="在这里插入图片描述"><br> 这个公式中 ,pu,k和qi,k 是模型的参数，其中 ,pu,k度量了用户u的兴趣和第k个隐类的关系，而qi,k 度量了第k个隐类和物品i之间的关系</p> </li><li> <p>在隐性反馈数据集上的第一个问题：如何给每个用户生成负样本</p> 
  <ul><li>每个用户要保证正负样本均衡</li><li>负样本采样时，需要选取很热门而用户没有行为的物品</li></ul> </li><li> <p>利用随机梯度下降法来迭代求得参数的值，损失函数如下：<br> <img src="https://images2.imgbox.com/2b/65/rGusg6Z6_o.png" alt="在这里插入图片描述"></p> </li><li> <p>超参</p> 
  <ul><li>隐特征的个数F</li><li>学习速率alpha</li><li>正则化参数lambda</li><li>负样本/正样本比例ratio：对性能影响最大<br> <img src="https://images2.imgbox.com/6d/8e/YdquYTJR_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h3><a id="52_LFM_118"></a>5.2 基于LFM的实际系统的例子</h3> 
<ul><li>应用场景：雅虎首页个性化设计方案，以CTR为优化目标，利用LFM来预测用户是否会单击一个链接</li><li>主要问题：对新闻而言，实时性很重要，LFM很难实现实时推荐，如何对新文章冷启动是个问题</li><li>解决方案：<br> <img src="https://images2.imgbox.com/2c/61/kqhzM7QD_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="53__123"></a>5.3 与基于邻域的方法的比较</h3> 
<p>理论基础：</p> 
<table><thead><tr><th></th><th>基于邻域的方法</th><th>LFM</th></tr></thead><tbody><tr><td>理论基础</td><td>基于统计，没有学习过程</td><td>一种学习方法</td></tr><tr><td>离线计算的空间复杂度</td><td>用户相关表，需要O(M<em>M)的空间；物品相关表，需要O(N</em>N)的空间</td><td>如果是F个隐类，那么它需要的存储空间是O(F*(M+N))</td></tr><tr><td>离线计算的时间复杂度</td><td>UserCF是O(N * (K/N)^2)，而ItemCF是O(M*(K/M)^2)</td><td>如果用F个隐类，迭代S次，那么它的计算复杂度 是O(K * F * S)</td></tr><tr><td>在线实时推荐</td><td>UserCF对新物品实时，ItemCF对新用户实时</td><td>不能实时</td></tr><tr><td>推荐解释</td><td>ItemCF可以</td><td>不能</td></tr></tbody></table> 
<h2><a id="6_133"></a>6、基于图的模型</h2> 
<h3><a id="61__134"></a>6.1 用户行为数据的二分图表示</h3> 
<p><img src="https://images2.imgbox.com/c1/fc/REW6OI6V_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="62__136"></a>6.2 基于图的推荐算法</h3> 
<ul><li> <p>度量用户顶点 vu和与vu没有边直接相连的物品节点在图上的相关性，相关性越高的物品在推荐列表中的权重就越高</p> </li><li> <p>顶点的相关性的影响因素</p> 
  <ul><li>两个顶点之间的路径数</li><li>两个顶点之间路径的长度</li><li>两个顶点之间的路径经过的顶点</li></ul> </li><li> <p>相关性高的一对顶点一般具有如下特征：</p> 
  <ul><li>两个顶点之间有很多路径相连；</li><li>连接两个顶点之间的路径长度都比较短；</li><li>连接两个顶点之间的路径不会经过出度比较大的顶点</li></ul> </li></ul> 
<h5><a id="PersonalRank_149"></a>PersonalRank算法</h5> 
<p>假设要给用户u进行个性化推荐，可以从用户u对应的节点vu开始在用户物品二分图上进行随机游走。游走到任何一个节点时，首先按照概率 α 决定：</p> 
<ul><li>停止这次游走并从vu节点开始重新游走。</li><li>继续游走，那么就从当前节点指向的节点中按照均匀分布随机选择一 个节点作为游走下次经过的节点。</li></ul> 
<p>这样，经过很多次随机游走后，每个物品节点被访问到的概率 会收敛到一个数。最终的推荐列表中物品的权重就是物品节点的访问概率。<br> 公式如下：<br> <img src="https://images2.imgbox.com/27/50/hWgmvpPA_o.png" alt="在这里插入图片描述"><br> 算法的缺点，在时间复杂度上有明显的缺点，无法生成实时推荐，而且计算一次推荐结果也很耗时。<br> 改进方案：减少迭代次数；从矩阵论出发，重新设计算法。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c84be3adb63259d1162abb406bc849dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java使用代理请求https</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd6a0a3787c153f161c39b406152ea63/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OHEM的pytorch代码实现细节</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>