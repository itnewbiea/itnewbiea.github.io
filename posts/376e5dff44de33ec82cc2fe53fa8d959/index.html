<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>leetcode  部分题解(python) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="leetcode  部分题解(python)" />
<meta property="og:description" content="leetcode 部分题解(python) 215. Kth Largest Element in an Array 题目链接：https://leetcode.com/problems/kth-largest-element-in-an-array/#/description
思路_第k大的数 利用快速排序的思想；从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况： 1. Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数； 2. Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)
class Solution(object): def findKthLargest(self, nums, k): &#34;&#34;&#34; :type nums: List[int] :type k: int :rtype: int &#34;&#34;&#34; if len(nums)==1: return nums[0] target = nums[0] i,j = 0,len(nums)-1 while i&lt;j: while i&lt;j and nums[j]&gt;=target: j -= 1 nums[i] = nums[j] while i&lt;j and nums[i]&lt;=target: i &#43;= 1 nums[j] = nums[i] nums[i] = target right = len(nums)-j # print(right) if right==k: return nums[j] elif right&gt;k: return self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/376e5dff44de33ec82cc2fe53fa8d959/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-26T12:27:13+08:00" />
<meta property="article:modified_time" content="2016-12-26T12:27:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">leetcode  部分题解(python)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="leetcode-部分题解python">leetcode 部分题解(python)</h2> 
<h3 id="215-kth-largest-element-in-an-array">215. Kth Largest Element in an Array</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/#/description" rel="nofollow">https://leetcode.com/problems/kth-largest-element-in-an-array/#/description</a></p> 
<h4 id="思路第k大的数">思路_第k大的数</h4> 
<p>利用快速排序的思想；从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况： <br> 1. Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数； <br> 2. Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(self, nums, k)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
        target = nums[<span class="hljs-number">0</span>]
        i,j  = <span class="hljs-number">0</span>,len(nums)-<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> i&lt;j:
            <span class="hljs-keyword">while</span> i&lt;j <span class="hljs-keyword">and</span> nums[j]&gt;=target:
                j -= <span class="hljs-number">1</span>
            nums[i] = nums[j]
            <span class="hljs-keyword">while</span> i&lt;j <span class="hljs-keyword">and</span> nums[i]&lt;=target:
                i += <span class="hljs-number">1</span>
            nums[j] = nums[i]
        nums[i] = target
        right = len(nums)-j
        <span class="hljs-comment"># print(right)</span>
        <span class="hljs-keyword">if</span> right==k:
            <span class="hljs-keyword">return</span> nums[j]
        <span class="hljs-keyword">elif</span> right&gt;k:
            <span class="hljs-keyword">return</span> self.findKthLargest(nums[j+<span class="hljs-number">1</span>:],k)
        <span class="hljs-keyword">else</span>:
            print(j)
            <span class="hljs-keyword">return</span> self.findKthLargest(nums[:j],k-right)</code></pre> 
<h3 id="57-insert-interval">57. Insert Interval</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/insert-interval/?tab=Description" rel="nofollow">https://leetcode.com/problems/insert-interval/?tab=Description</a></p> 
<h3 id="思路链表insert">思路_链表insert</h3> 
<p>代码:</p> 
<pre class="prettyprint"><code class=" hljs python"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, intervals, newInterval)</span>:</span>
        <span class="hljs-string">"""
        :type intervals: List[Interval]
        :type newInterval: Interval
        :rtype: List[Interval]
        """</span>
        ans =[]
        <span class="hljs-keyword">if</span> len(intervals)==<span class="hljs-number">0</span>:
            ans.append(newInterval)
            <span class="hljs-keyword">return</span> ans
        pos = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> inte <span class="hljs-keyword">in</span> intervals:
            <span class="hljs-keyword">if</span> inte.start&gt;newInterval.end:
                ans.append(inte)
            <span class="hljs-keyword">elif</span> inte.end&lt;newInterval.start:
                ans.append(inte)
                pos+=<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                newInterval.start = min(newInterval.start,inte.start)
                newInterval.end = max(newInterval.end,inte.end)

        ans.insert(pos,newInterval) 
        <span class="hljs-keyword">return</span> ans</code></pre> 
<h3 id="56-merge-intervals">56. Merge Intervals</h3> 
<p>题目链接：<a href="http://write.blog.csdn.net/mdeditor#!postId=53885139" rel="nofollow">http://write.blog.csdn.net/mdeditor#!postId=53885139</a></p> 
<h4 id="lambda排序">lambda排序</h4> 
<p>参考网址：<a href="http://www.cnblogs.com/zuoyuan/p/3782028.html" rel="nofollow">http://www.cnblogs.com/zuoyuan/p/3782028.html</a></p> 
<p>通过 operator 模块提供的函数还可以实现多重排序的功能。比如，先按 grade 排序再按 age 排序：</p> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>sorted(student_tuples, key=itemgetter(1,2)) <br> [(‘john’, ‘A’, 15), (‘dave’, ‘B’, 10), (‘jane’, ‘B’, 12)]</p> 
   <p>sorted(student_objects, key=attrgetter(‘grade’, ‘age’)) <br> [(‘john’, ‘A’, 15), (‘dave’, ‘B’, 10), (‘jane’, ‘B’, 12)]</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<hr> 
<h3 id="28-implement-strstr">28. Implement strStr()</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/implement-strstr/?tab=Description" rel="nofollow">https://leetcode.com/problems/implement-strstr/?tab=Description</a></p> 
<h4 id="思路查找子串">思路：查找子串</h4> 
<p>在一个序列中找到子串并且返回下标索引位置 <br> 代码：</p> 
<pre class="prettyprint"><code class=" hljs python"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strStr</span><span class="hljs-params">(self, haystack, needle)</span>:</span>
        <span class="hljs-string">"""
        :type haystack: str
        :type needle: str
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> haystack==<span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> needle==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        hlen = len(haystack)
        nlen = len(needle)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,hlen-nlen+<span class="hljs-number">1</span>):
            j = <span class="hljs-number">0</span>
            <span class="hljs-keyword">while</span> j&lt;nlen:
                <span class="hljs-keyword">if</span> needle[j]==haystack[j+i]:
                    j+=<span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> j==nlen:
                <span class="hljs-keyword">return</span> i
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></code></pre> 
<h3 id="1-two-sum">1. Two Sum</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/two-sum/?tab=Description" rel="nofollow">https://leetcode.com/problems/two-sum/?tab=Description</a></p> 
<h4 id="思路哈希">思路:哈希</h4> 
<p>在一个序列里面找到两个数使得和为目标值，并且返回两个数的下标 <br> 代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums, target)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, num, target)</span>:</span>
        dict = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(num)):
            x = num[i]
            <span class="hljs-keyword">if</span> target-x <span class="hljs-keyword">in</span> dict:
                <span class="hljs-keyword">return</span> (dict[target-x]+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>)
            dict[x] = i</code></pre> 
<h3 id="92-reverse-linked-list-ii">92. Reverse Linked List II</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/reverse-linked-list-ii/?tab=Description" rel="nofollow">https://leetcode.com/problems/reverse-linked-list-ii/?tab=Description</a></p> 
<h4 id="思路子链表翻转烧脑">思路_子链表翻转烧脑</h4> 
<p>代码：</p> 
<pre class="prettyprint"><code class=" hljs python"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(self, head, m, n)</span>:</span>
        <span class="hljs-string">"""
        :type head: ListNode
        :type m: int
        :type n: int
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> head==<span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> head.next==<span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> m==n:
            <span class="hljs-keyword">return</span> head
        L = ListNode(<span class="hljs-number">0</span>)
        L.next = head
        cur = L
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m-<span class="hljs-number">1</span>):
            cur = cur.next
        p = cur.next
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n-m):
            tem = cur.next
            cur.next = p.next
            p.next = p.next.next
            cur.next.next = tem
        <span class="hljs-keyword">return</span> L.next</code></pre> 
<hr> 
<h3 id="279-perfect-squares">279. Perfect Squares</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/perfect-squares/?tab=Description" rel="nofollow">https://leetcode.com/problems/perfect-squares/?tab=Description</a> <br> 题意：计算当前数字最少可以由多少个平方数相加得到</p> 
<h4 id="思路动态规划">思路_动态规划</h4> 
<p>维护一个数组d[n],d[i]表示数字i最少可以由多少个平方数相加得到，初始化d[0]=0,其余为max，动态更新方程可表示为:d[i+j*j] = max(d[i+j*j]，d[i]+1) <br> 代码:</p> 
<pre class="prettyprint"><code class=" hljs python"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        d = [<span class="hljs-number">100</span>]*(n+<span class="hljs-number">1</span>)
        d[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
        d[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,n+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,n):
                <span class="hljs-keyword">if</span> i+j*j&lt;=n:
                    d[i+j*j] = min(d[i+j*j],d[i]+<span class="hljs-number">1</span>)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> d[n]</code></pre> 
<p>————</p> 
<h3 id="129-sum-root-to-leaf-numbers">129. Sum Root to Leaf Numbers</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/?tab=Description" rel="nofollow">https://leetcode.com/problems/sum-root-to-leaf-numbers/?tab=Description</a> <br> 题意：找到根节点到叶节点的所有路径组成的数字，求和之</p> 
<h4 id="思路二叉树-dfs">思路_二叉树-DFS</h4> 
<p>代码同:<a href="https://leetcode.com/problems/binary-tree-paths/?tab=Description" rel="nofollow">https://leetcode.com/problems/binary-tree-paths/?tab=Description</a></p> 
<h3 id="257-binary-tree-paths">257. Binary Tree Paths</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/binary-tree-paths/?tab=Description" rel="nofollow">https://leetcode.com/problems/binary-tree-paths/?tab=Description</a> <br> 题意：输出根节点到叶节点的所有路径</p> 
<h4 id="思路二叉树-dfs-1">思路_二叉树-DFS</h4> 
<p>代码:</p> 
<pre class="prettyprint"><code class=" hljs python">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[str]
        """</span>
        self.ans = []
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> self.ans
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root,path)</span>:</span>
            <span class="hljs-keyword">if</span> root.left==<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root.right==<span class="hljs-keyword">None</span>:
                self.ans.append(path)
            <span class="hljs-keyword">if</span> root.left:
                dfs(root.left,path+<span class="hljs-string">"-&gt;"</span>+str(root.left.val))
            <span class="hljs-keyword">if</span> root.right:
                dfs(root.right,path+<span class="hljs-string">"-&gt;"</span>+str(root.right.val))
        dfs(root,str(root.val))
        <span class="hljs-keyword">return</span> self.ans</code></pre> 
<hr> 
<h3 id="110-balanced-binary-tree">110. Balanced Binary Tree</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/balanced-binary-tree/?tab=Description" rel="nofollow">https://leetcode.com/problems/balanced-binary-tree/?tab=Description</a> <br> 题意：验证是否是二叉平衡树(任意节点的两个子树高度差最多为1)</p> 
<h4 id="思路二叉树深度">思路_二叉树深度</h4> 
<p>代码：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> root == <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> abs((self.depth(root.left)-self.depth(root.right)))&gt;<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self.isBalanced(root.left) <span class="hljs-keyword">and</span> self.isBalanced(root.right)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depth</span><span class="hljs-params">(self, r)</span>:</span>
        <span class="hljs-keyword">if</span> r==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> max(self.depth(r.left), self.depth(r.right))+<span class="hljs-number">1</span></code></pre> 
<hr> 
<h3 id="24-swap-nodes-in-pairs">24. Swap Nodes in Pairs</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/swap-nodes-in-pairs/?tab=Description" rel="nofollow">https://leetcode.com/problems/swap-nodes-in-pairs/?tab=Description</a> <br> 题意:交换链表里面相邻的两个节点，空间恒定</p> 
<h4 id="思路链表递归">思路<em>链表</em>递归</h4> 
<p>代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(self, head)</span>:</span>
        <span class="hljs-string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> head==<span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> head.next==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> head
        nex = head.next
        tem = nex.next
        nex.next = head
        head.next = self.swapPairs(tem)
        <span class="hljs-keyword">return</span> nex</code></pre> 
<h3 id="342-power-of-four">342. Power of Four</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/power-of-four/?tab=Solutions" rel="nofollow">https://leetcode.com/problems/power-of-four/?tab=Solutions</a> <br> 题意:判断一个数是否是4的幂</p> 
<h4 id="思路二进制">思路_二进制</h4> 
<p>The basic idea is from power of 2, We can use “n&amp;(n-1) == 0” to determine if n is power of 2. For power of 4, the additional restriction is that in binary form, the only “1” should always located at the odd position. For example, 4^0 = 1, 4^1 = 100, 4^2 = 10000. So we can use “num &amp; 0x55555555==num” to check if “1” is located at the odd position.</p> 
<p>代码:</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-constant">return</span> (<span class="hljs-built_in">num</span> &gt; <span class="hljs-number">0</span>) &amp;&amp; ((<span class="hljs-built_in">num</span> &amp; (<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) &amp;&amp; ((<span class="hljs-built_in">num</span> &amp; <span class="hljs-number">0x55555555</span>) == <span class="hljs-built_in">num</span>)</code></pre> 
<hr> 
<h3 id="416-partition-equal-subset-sum">416. Partition Equal Subset Sum</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/partition-equal-subset-sum/" rel="nofollow">https://leetcode.com/problems/partition-equal-subset-sum/</a> <br> 题意:验证一个数组是否存在两个子集，使得两个子集的和相等。</p> 
<h4 id="思路01背包问题">思路:_01背包问题</h4> 
<p>参照背包的博文 <br> 代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: bool
        """</span>
        n = len(nums)
        sum_num = sum(nums)
        <span class="hljs-keyword">if</span> sum_num%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-comment"># print(sum_num)</span>
        result = [[<span class="hljs-number">0</span>]*sum_num <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(nums[i-<span class="hljs-number">1</span>],int(sum_num/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>):
                result[i][j] = max([result[i-<span class="hljs-number">1</span>][j],result[i-<span class="hljs-number">1</span>][j-nums[i-<span class="hljs-number">1</span>]]+nums[i-<span class="hljs-number">1</span>]])
        <span class="hljs-keyword">if</span> result[n][int(sum_num/<span class="hljs-number">2</span>)]==sum_num/<span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></code></pre> 
<hr> 
<h3 id="334-increasing-triplet-subsequence">334. Increasing Triplet Subsequence</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/increasing-triplet-subsequence/" rel="nofollow">https://leetcode.com/problems/increasing-triplet-subsequence/</a> <br> 题意:在一个无序的序列中找到一个长度为3的递增子序列。</p> 
<h4 id="思路-ifelifelse">思路: if_elif_else</h4> 
<p>我特么已经蠢到这种题都不会了，维护一个最小数a和次小数b，遍历到第三个数c满足c&gt;b 返回Ture <br> 代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> len(nums)&lt;<span class="hljs-number">3</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        max_num = max(nums)
        c1 = max_num
        c2 = max_num
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            <span class="hljs-keyword">if</span> i &lt;= c1:
                c1 = i
            <span class="hljs-keyword">elif</span> i&lt;=c2:
                c2 = i
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></code></pre> 
<hr> 
<h3 id="binary-tree-level-order-traversal-ii">Binary Tree Level Order Traversal II</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" rel="nofollow">https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</a></p> 
<h4 id="思路queue层次遍历">思路<em>queue</em>层次遍历</h4> 
<p>题意，就是层次遍历，不过是从bottom to up <br> 代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[List[int]]
        """</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> []
        results = []
        queue = [root]
        <span class="hljs-keyword">while</span> queue:
            cur_li = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(queue)):
                cur = queue.pop(<span class="hljs-number">0</span>)
                cur_li.append(cur.val)
                <span class="hljs-keyword">if</span> cur.left!=<span class="hljs-keyword">None</span>:
                    queue.append(cur.left)
                <span class="hljs-keyword">if</span> cur.right!=<span class="hljs-keyword">None</span>:
                    queue.append(cur.right)
            results.append(cur_li)
        <span class="hljs-keyword">return</span> [results[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(results)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)]</code></pre> 
<hr> 
<h3 id="search-a-2d-matrix-ii">Search a 2D Matrix II</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" rel="nofollow">https://leetcode.com/problems/search-a-2d-matrix-ii/</a></p> 
<h5 id="思路面试题">思路_面试题</h5> 
<p>题意:给一个n*m的矩阵，每一行，每一列都从小到大的排列，然后查找target这个数是否存在矩阵中。 <br> 脑子不灵活，对每一行二分查找，时间复杂度也要nlogn，，，面试题怎么会这么做呢？（我简直蠢到家） <br> <em>从右上角开始, 比较target 和 matrix[i][j]的值. 如果小于target, 则该行不可能有此数, 所以i++; 如果大于target, 则该列不可能有此数, 所以j–. 遇到边界则表明该矩阵不含target.</em> <br> 代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(self, matrix, target)</span>:</span>
        <span class="hljs-string">"""
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """</span>
        n = len(matrix)
        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        m = len(matrix[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> m==-<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> m&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> i&lt;n:
            <span class="hljs-keyword">if</span> matrix[i][m]&gt;target:
                m -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">elif</span> matrix[i][m]&lt;target:
                i +=<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></code></pre> 
<hr> 
<h3 id="53-maximum-subarray">53. Maximum Subarray</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/maximum-subarray/" rel="nofollow">https://leetcode.com/problems/maximum-subarray/</a></p> 
<h4 id="思路经典的dp问题">思路_经典的DP问题：</h4> 
<p>题意：给定一个序列，要找到和最大的那个子序列，并且返回该子序列之和。 <br> 维护两个列表，local[i]即包含当前元素的局部最大和值，DP求local[i]时，local[i] = max(local[i-1]+nums[i],nums[i]) ； <br> 全局最优值globa[i] = max(globa[i-1],local[i])，即先找到包含当前值的局部最优值local[i]，当前的全局最优值globa[i]即为不包含当前值的全局最优与当前局部最优的最大值。 <br> 代码：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        local = [<span class="hljs-number">0</span>]*len(nums)
        globa = [<span class="hljs-number">0</span>]*len(nums)
        local[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]
        globa[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)):
            local[i] = max(local[i-<span class="hljs-number">1</span>]+nums[i],nums[i])
            globa[i] = max(globa[i-<span class="hljs-number">1</span>],local[i])
        <span class="hljs-keyword">return</span> max(local[-<span class="hljs-number">1</span>],globa[-<span class="hljs-number">1</span>])</code></pre> 
<hr> 
<h3 id="235-lowest-common-ancestor-of-a-binary-search-tree">235. Lowest Common Ancestor of a Binary Search Tree</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="nofollow">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p> 
<h4 id="思路二叉搜索树递归">思路<em>二叉搜索树</em>递归：</h4> 
<p>题意：求二叉搜索树（！）任意两个节点的最低共有祖先。 <br> 对于二叉搜索树，公共祖先的值一定大于等于较小的节点，小于等于较大的节点。换言之，在遍历树的时候，如果当前结点大于两个节点，则结果在当前结点的左子树里，如果当前结点小于两个节点，则结果在当前节点的右子树里。 <br> 代码：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(self, root, p, q)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> root.val&gt;p.val <span class="hljs-keyword">and</span> root.val&gt;q.val:
            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.left, p, q)
        <span class="hljs-keyword">if</span> root.val&lt;p.val <span class="hljs-keyword">and</span> root.val&lt;q.val:
            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.right, p, q)
        <span class="hljs-keyword">return</span> root</code></pre> 
<hr> 
<h3 id="202-happy-number">202. Happy Number</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/happy-number/" rel="nofollow">https://leetcode.com/problems/happy-number/</a></p> 
<h4 id="思路智力题">思路_智力题：</h4> 
<p>给定一个数，判断这个数是不是happy number；即循环的做每一位的平方和，直到最后得到1这个数。 <br> 基本方法就是维护一个列表，每次出现一个新的数，则加到列表里面，如果当前这个已经存在列表中了则返回false； 如果不存在列表中则添加，若得到1则返回true。 </p> 
<p>代码：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: bool
        """</span>
        resulst = [n]
        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:
            s = <span class="hljs-number">0</span>
            n = resulst[-<span class="hljs-number">1</span>]
            <span class="hljs-keyword">while</span> n:
                cur = n%<span class="hljs-number">10</span>
                n /=<span class="hljs-number">10</span>
                s += cur**<span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> s <span class="hljs-keyword">in</span> resulst <span class="hljs-keyword">and</span> s!=<span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">elif</span> s <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> resulst <span class="hljs-keyword">and</span> s!=<span class="hljs-number">1</span>:
                resulst.append(s)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span></code></pre> 
<hr> 
<h3 id="sum-of-two-integers">Sum of Two Integers</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/sum-of-two-integers/" rel="nofollow">https://leetcode.com/problems/sum-of-two-integers/</a> <br> 题目翻译： <br> 计算两个整数a和b的和，但是不能使用运算符加号和减号。 <br> 比如：给定a=1，b=2，返回3。</p> 
<h4 id="思路位操作">思路_（位操作）：</h4> 
<p>既然不能使用加法和减法，那么就用位操作。下面以计算5+4的例子说明如何用位操作实现加法： <br> 1. 用二进制表示两个加数，a=5=0101，b=4=0100； <br> 2. 用and（&amp;）操作得到所有位上的进位carry=0100; <br> 3. 用xor（^）操作找到a和b不同的位，赋值给a，a=0001； <br> 4. 将进位carry左移一位，赋值给b，b=1000； <br> 5. 循环直到进位carry为0，此时得到a=1001，即最后的sum。</p> 
<p>上面思路还算正常，然而对于Python就有点麻烦了。因为Python的整数不是固定的32位，所以需要做一些特殊的处理，具体见代码吧。 <br> 代码里的将一个数对0x100000000取模（注意：Python的取模运算结果恒为非负数），是希望该数的二进制表示从第32位开始到更高的位都同是0（最低位是第0位），以在0-31位上模拟一个32位的int。</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getSum</span><span class="hljs-params">(self, a, b)</span>:</span>
        <span class="hljs-string">"""
        :type a: int
        :type b: int
        :rtype: int
        """</span>
        <span class="hljs-keyword">while</span> b != <span class="hljs-number">0</span>:
            carry = a &amp; b
            a = (a ^ b) % <span class="hljs-number">0x100000000</span>
            b = (carry &lt;&lt; <span class="hljs-number">1</span>) % <span class="hljs-number">0x100000000</span>
        <span class="hljs-keyword">return</span> a <span class="hljs-keyword">if</span> a &lt;= <span class="hljs-number">0x7FFFFFFF</span> <span class="hljs-keyword">else</span> a | (~<span class="hljs-number">0x100000000</span>+<span class="hljs-number">1</span>)

</code></pre> 
<hr> 
<h3 id="roman-to-integer">Roman to Integer</h3> 
<p>题目链接：<a href="https://oj.leetcode.com/problems/roman-to-integer/" rel="nofollow">https://oj.leetcode.com/problems/roman-to-integer/</a></p> 
<h4 id="思路-1">思路:</h4> 
<p>罗马数字是最古老的数字表示方式，比阿拉伯数组早2000多年，起源于罗马</p> 
<p>罗马数字有如下符号：</p> 
<p>基本字符IVXLCDM对应阿拉伯数字1510501005001000 <br> 计数规则：</p> 
<pre><code>1. 相同的数字连写，所表示的数等于这些数字相加得到的数，例如：III = 3
2. 小的数字在大的数字右边，所表示的数等于这些数字相加得到的数，例如：VIII = 8
3. 小的数字，限于（I、X和C）在大的数字左边，所表示的数等于大数减去小数所得的数，例如：IV = 4
4. 正常使用时，连续的数字重复不得超过三次
5. 在一个数的上面画横线，表示这个数扩大1000倍（本题只考虑3999以内的数，所以用不到这条规则）
</code></pre> 
<p>其次，罗马数字转阿拉伯数字规则（仅限于3999以内）：</p> 
<p>从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数。反之，减去前一个数的两倍然后加上该数</p> 
<hr> 
<h3 id="house-robber-iii">House Robber III</h3> 
<p>题目连接:<a href="https://leetcode.com/problems/house-robber-iii/" rel="nofollow">https://leetcode.com/problems/house-robber-iii/</a></p> 
<h4 id="思路dp">思路_（DP）：</h4> 
<p>动态规划，因为当前的计算需要依赖之前的结果，那么我们对于某一个节点a，如果其左子节点b存在，我们通过递归调用函数，算出不包含左子节点b返回的值，同理，如果右子节点c存在，算出不包含右子节点c返回的值，那么此节点的最大值可能有两种情况，一种是该节点a值加上不包含左子节点b和右子节点c的返回值之和，另一种是左右子节点返回值之和而不包含当期节点值，</p> 
<pre><code>class Solution(object):
def rob(self, root):
    """
    :type root: TreeNode
    :rtype: int
    """
    def dsf(root):
        if not root:
            return [0,0]
        leftr = dsf(root.left)
        rightr = dsf(root.right)
        nocurr = leftr[1]+rightr[1]
        cur =  leftr[0]+rightr[0] + root.val
        maxval = max(cur,nocurr)
        return [nocurr,maxval]
    return dsf(root)[1]
</code></pre> 
<hr> 
<h3 id="serialize-and-deserialize-bst">Serialize and Deserialize BST</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/serialize-and-deserialize-bst/#" rel="nofollow">https://leetcode.com/problems/serialize-and-deserialize-bst/#</a></p> 
<h4 id="思路序列化queuebfs">思路_（序列化、queue_BFS）：</h4> 
<p>序列化就是将一个数据结构或物体转化为一个位序列，可以存进一个文件或者内存缓冲器中，然后通过网络连接在相同的或者另一个电脑环境中被还原，还原的过程叫做去序列化。 <br> <strong>层序遍历的非递归解法：借助queue来做，本质是BFS算法</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'{}'</span>
        val = root.val
        index = <span class="hljs-number">0</span>
        queue = [root]
        <span class="hljs-keyword">while</span> index &lt;len(queue):
            <span class="hljs-keyword">if</span> queue[index] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
                queue.append(queue[index].left)
                queue.append(queue[index].right)
            index +=<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> queue[-<span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            queue.pop()
        re = <span class="hljs-string">''</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(queue)-<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> queue[i] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
                re += str(queue[i].val) + <span class="hljs-string">','</span>
            <span class="hljs-keyword">else</span>:
                re +=<span class="hljs-string">'#,'</span>
        re=<span class="hljs-string">'{'</span>+re+str(queue[-<span class="hljs-number">1</span>].val)+<span class="hljs-string">'}'</span>
        <span class="hljs-keyword">return</span> re       

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(self, data)</span>:</span>
        <span class="hljs-string">"""Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """</span>
        data = data.strip(<span class="hljs-string">'\n'</span>)

        <span class="hljs-keyword">if</span> data == <span class="hljs-string">'{}'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>

        vals = data[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].split(<span class="hljs-string">','</span>)
        root = TreeNode(int(vals[<span class="hljs-number">0</span>]))
        queue = [root]
        isLeftChild = <span class="hljs-keyword">True</span>
        index = <span class="hljs-number">0</span>

        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> vals[<span class="hljs-number">1</span>:]:
            <span class="hljs-keyword">if</span> val <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-string">'#'</span>:
                node = TreeNode(int(val))
                <span class="hljs-keyword">if</span> isLeftChild:
                    queue[index].left = node
                <span class="hljs-keyword">else</span>:
                    queue[index].right = node
                queue.append(node)

            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isLeftChild:
                index += <span class="hljs-number">1</span>
            isLeftChild = <span class="hljs-keyword">not</span> isLeftChild

        <span class="hljs-keyword">return</span> root</code></pre> 
<h3 id="459-repeated-substring-pattern">459. Repeated Substring Pattern</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/repeated-substring-pattern/" rel="nofollow">https://leetcode.com/problems/repeated-substring-pattern/</a></p> 
<h4 id="思路kmpnext数组">思路_（KMP_next数组）：</h4> 
<p>题意：给定一个非空字符串，判断它是否可以通过自身的子串重复若干次构成。你可以假设字符串只包含小写英文字母，并且长度不会超过10000 <br> 记字符串长度为size，利用KMP算法求next数组，记next数组的最后一个元素为p <br> 若p &gt; 0 并且 size % (size - p) == 0，返回True <br> code:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(self, str)</span>:</span>
        <span class="hljs-string">"""
        :type str: str
        :rtype: bool
        """</span>
        k=-<span class="hljs-number">1</span>
        j=<span class="hljs-number">0</span>
        next = [<span class="hljs-number">0</span>]*(len(str)+<span class="hljs-number">1</span>)
        next[<span class="hljs-number">0</span>]=-<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> (j&lt;len(str)):
            <span class="hljs-keyword">if</span> k==-<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> str[j]==str[k]:
                j+=<span class="hljs-number">1</span>
                k+=<span class="hljs-number">1</span>
                next[j]=k
            <span class="hljs-keyword">else</span>:
                k = next[k]
        l = next[-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span>  len(str)%(len(str)-l)==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> l&gt;<span class="hljs-number">0</span></code></pre> 
<pre><code>关于next数组很多代码里面求解的是当前字符的前面所有字符的最长前后匹配子串；该解题部分求取了当前位字符的最长匹配子串，只需要将next数组右移一位即可。关于next数组的具体求法参考：http://blog.csdn.net/v_july_v/article/details/7041827
</code></pre> 
<hr> 
<h3 id="46-permutations">46. Permutations</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/permutations/" rel="nofollow">https://leetcode.com/problems/permutations/</a></p> 
<h4 id="思路递归全排列">思路_（递归全排列）:</h4> 
<p>可以将这个排列问题画成图形表示，即排列枚举树，比如下图为{1,2,3}的排列枚举树，此树和我们这里介绍的算法完全一致；</p> 
<p><img src="https://images2.imgbox.com/08/8a/pz9GEPF9_o.png" alt="这里写图片描述" title=""></p> 
<p>不断将每个元素放作第一个元素，然后将这个元素作为前缀，并将其余元素继续全排列（递归调用即可）</p> 
<p>代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permute</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[List[int]]
        """</span>
        re = []
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perm</span><span class="hljs-params">(num,k,l)</span>:</span>
            <span class="hljs-keyword">if</span> k==l:
                re.append(list(num))
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k,l):
                    num[i],num[k]=num[k],num[i]
                    perm(num,k+<span class="hljs-number">1</span>,l)
                    num[i],num[k]=num[k],num[i]
        perm(nums,<span class="hljs-number">0</span>,len(nums))
        <span class="hljs-keyword">return</span> re</code></pre> 
<hr> 
<h3 id="405-convert-a-number-to-hexadecimal">405. Convert a Number to Hexadecimal</h3> 
<p>题目链接:<a href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/" rel="nofollow">https://leetcode.com/problems/convert-a-number-to-hexadecimal/</a></p> 
<h4 id="思路进制数转化">思路_（进制数转化）:</h4> 
<p>将数字转化为16进制字符串，负数采用补码表示。 <br> 只需要将负数转换为无符号短整型即可，即负数本身+100000000000000000000000000000000（0x100000000 <br> ）</p> 
<p>代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toHex</span><span class="hljs-params">(self, num)</span>:</span>
        <span class="hljs-string">"""
        :type num: int
        :rtype: str
        """</span>
        ans = []
        hexs = <span class="hljs-string">'0123456789abcdef'</span>
        <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span>: num += <span class="hljs-number">0x100000000</span>
        <span class="hljs-keyword">while</span> num:
            ans.append(hexs[num % <span class="hljs-number">16</span>])
            num /= <span class="hljs-number">16</span>
        t=<span class="hljs-string">''</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(ans)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            t+=str(ans[i])
        <span class="hljs-keyword">return</span> t <span class="hljs-keyword">if</span> ans <span class="hljs-keyword">else</span> <span class="hljs-string">'0'</span></code></pre> 
<hr> 
<h3 id="96-unique-binary-search-trees">96. Unique Binary Search Trees</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/unique-binary-search-trees/" rel="nofollow">https://leetcode.com/problems/unique-binary-search-trees/</a></p> 
<h4 id="思路dp-1">思路_（DP）：</h4> 
<p>n个点中每个点都可以作为root，当 i 作为root时，小于 i 的点都只能放在其左子树中，大于 i 的点只能放在右子树中，此时只需求出左、右子树各有多少种，二者相乘即为以 i 作为root时BST的总数。</p> 
<p>利用动态规划的思想，维护数组results, results[i]表示含有i个数的BST总数 <br> 代码：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        results = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)
        results[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>
        results[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,i):
                results[i] += results[j]*results[i-j-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> results[n]</code></pre> 
<hr> 
<h3 id="153-find-minimum-in-rotated-sorted-array">153. Find Minimum in Rotated Sorted Array</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" rel="nofollow">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/</a></p> 
<h4 id="思路二分查找">思路_（二分查找）：</h4> 
<p>大概题意就是说当前的序列是一个有序的序列从某个节点打乱后的结果，比如[3,4,5,1,2] 要从这个序列中找到最小值。 <br> 看了别人的解题思路以后才懂了，利用二分查找（logn） <br> (1) A[mid] &lt; A[end]：A[mid : end] sorted =&gt; min不在A[mid+1 : end]中 <br> 搜索A[start : mid] <br> (2) A[mid] &gt; A[end]：A[start : mid] sorted且又因为该情况下A[end]</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMin</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        start, end = <span class="hljs-number">0</span>, len(nums)-<span class="hljs-number">1</span>
        target = nums[end]
        <span class="hljs-keyword">while</span> start&lt;end:
            mid = (start+end)/<span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[mid]&lt;target:
                end = mid
            <span class="hljs-keyword">else</span>:
                start = mid+<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> min(nums[start],nums[end])</code></pre> 
<hr> 
<h3 id="70-climbing-stairs">70. Climbing Stairs</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/climbing-stairs/" rel="nofollow">https://leetcode.com/problems/climbing-stairs/</a></p> 
<h4 id="思路dp-2">思路_(DP)：</h4> 
<p>题意：给定一个有n个台阶的梯子，每次可以走1步或者2步，问一共有多少种走法,典型的动态规划问题，当前阶梯数n的路径数量=n-1阶梯数的路径数量+n-1阶梯数的路径数量 <br> 代码：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        results = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)
        results[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>
        results[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):
            results[i] = results[i-<span class="hljs-number">1</span>]+results[i-<span class="hljs-number">2</span>]
        <span class="hljs-keyword">return</span> results[n]</code></pre> 
<hr> 
<h3 id="binary-tree-right-side-view">Binary Tree Right Side View</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/binary-tree-right-side-view/" rel="nofollow">https://leetcode.com/problems/binary-tree-right-side-view/</a></p> 
<h4 id="思路queue层次遍历-1">思路:<em>（queue</em>层次遍历）：</h4> 
<p>题意：人站在树的右边，从右往左看，能看到的从上往下的序列。 <br> 做完这道题感觉智商被限制，debug了半天，对queue使用不熟练。 <br> 层次遍历，每次先左右的节点入栈，遍历每一层的时候把最右边的节点值保存即可。 <br> 代码：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[int]
        """</span>
        results = []
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> []
        queue = [root]
        <span class="hljs-keyword">while</span> queue:

            <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(queue)):
                cur = queue.pop(<span class="hljs-number">0</span>)
                <span class="hljs-keyword">if</span> r==<span class="hljs-number">0</span>:
                    results.append(cur.val)
                <span class="hljs-keyword">if</span> cur.right!=<span class="hljs-keyword">None</span>:
                    queue.append(cur.right)
                <span class="hljs-keyword">if</span> cur.left!=<span class="hljs-keyword">None</span>:
                    queue.append(cur.left)    
        <span class="hljs-keyword">return</span> results</code></pre> 
<hr> 
<h3 id="21-merge-two-sorted-lists">21. Merge Two Sorted Lists</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/merge-two-sorted-lists/" rel="nofollow">https://leetcode.com/problems/merge-two-sorted-lists/</a></p> 
<h4 id="思路链表">思路_链表</h4> 
<p>链表合并没啥难度上代码：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(self, l1, l2)</span>:</span>
        <span class="hljs-string">"""
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> l1==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> l2
        <span class="hljs-keyword">if</span> l2==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> l1
        L = ListNode(<span class="hljs-number">0</span>)
        R = L 
        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:
            <span class="hljs-keyword">if</span> l1.val&lt;l2.val:
                L.next = l1
                L = L.next
                l1 = l1.next
            <span class="hljs-keyword">else</span>:
                L.next = l2
                L = L.next
                l2 = l2.next
        <span class="hljs-keyword">if</span> l1==<span class="hljs-keyword">None</span>:
            L.next = l2
        <span class="hljs-keyword">else</span>:
            L.next = l1
        <span class="hljs-keyword">return</span> R.next</code></pre> 
<hr> 
<h3 id="spiral-matrix-ii">Spiral Matrix II</h3> 
<p>题目链接：<a href="https://leetcode.com/problems/spiral-matrix-ii/" rel="nofollow">https://leetcode.com/problems/spiral-matrix-ii/</a></p> 
<h4 id="思路螺旋矩阵生成">思路_螺旋矩阵生成</h4> 
<p>题意：给定一个数，将1·n^2以螺旋结构的形式填充到矩阵中。 <br> 代码:</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateMatrix</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: List[List[int]]
        """</span>
        a = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(n)]
        colbegin,colend,rowbegin,rowend = <span class="hljs-number">0</span>,n,<span class="hljs-number">0</span>,n
        num = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> colbegin&lt;colend <span class="hljs-keyword">and</span> rowbegin&lt;rowend:
            <span class="hljs-keyword">if</span> num&lt;=n**<span class="hljs-number">2</span>:
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(colbegin,colend):
                    a[rowbegin][i] = num
                    num += <span class="hljs-number">1</span>
            rowbegin += <span class="hljs-number">1</span>


            <span class="hljs-keyword">if</span> num&lt;=n**<span class="hljs-number">2</span>:
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rowbegin,rowend):
                    a[i][colend-<span class="hljs-number">1</span>] = num
                    num += <span class="hljs-number">1</span>
            colend -= <span class="hljs-number">1</span>


            <span class="hljs-keyword">if</span> num&lt;=n**<span class="hljs-number">2</span>:
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(colend-<span class="hljs-number">1</span>,colbegin-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
                    a[rowend-<span class="hljs-number">1</span>][i] = num
                    num += <span class="hljs-number">1</span>
            rowend -= <span class="hljs-number">1</span>

            <span class="hljs-keyword">if</span> num&lt;=n**<span class="hljs-number">2</span>:
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rowend-<span class="hljs-number">1</span>,rowbegin-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
                    a[i][colbegin] = num
                    num += <span class="hljs-number">1</span>
            colbegin += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> a</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a64e110436eee42b05942ffdaeab1f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">css 百叶窗效果</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6efa895c31577be547d0276909c7127e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Extjs动画效果(自定义动画)  Ext Core 预置的 12 个动画功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>