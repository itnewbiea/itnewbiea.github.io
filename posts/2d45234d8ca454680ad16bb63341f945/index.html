<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>04 supervised learning - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="04 supervised learning" />
<meta property="og:description" content="Summary: unspervised learning clustering（聚类算法）Anomaly detection（异常检测） Recommender Systems（推荐系统）Reinforcement Learning（强化学习） 一 、 K-means算法 1.Notion a) K-means做的 ​ k-means重复做的两件事中
​ 第一件：是分配簇质心，然后将样本点距离近的变成相关的颜色
​ 第二件：重新遍历所有相同类型的点，然后取平均值，选出新的簇质心，检测每个点距离谁最近
b) some symbol &amp; cost function 2. k-means 聚类的步骤 a) Random initialization k ​ 簇质心随机选择样本中的点，然后循环多次选择不同的样本为簇质心，用于来找到 J 最小的时候的簇质心，次数如果太多也会降低效果
b ) how many k do we need ? i . elbow method(肘部法则) ​ 当我们将k 从1增加到m时候，代价函数 J 的函数图像会从大到小的递减，函数会有一个从递减迅速到缓慢的点，类似于人类的肘部 （但是有时很多J都是平缓下降的 没有肘部）
二 、 Anomaly detection 1. notion 如何计算正态分布的两个变量
2. 计算步骤 首先算出每一个特征的均值和方差利用每个特征的方差和均值算出某一个样本中的概率p(x)用计算出的p(x)和阈值比较，如果满足则表示有问题查看算法在交叉验证集中没能检测出的异常，然后考虑是否需要新建一个特征，使得发现这些异常原理： 算出每个样本的feature相较于所有样本中的异常大或者小的feature，然后p(x）乘出来会很小所以标记为异常
3. algorithm evaluation system（异常评估系统） 4 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2d45234d8ca454680ad16bb63341f945/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T20:58:08+08:00" />
<meta property="article:modified_time" content="2024-01-04T20:58:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">04 supervised learning</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Summary_0"></a><strong>Summary:</strong></h2> 
<ul><li>unspervised learning 
  <ul><li>clustering（聚类算法）</li><li>Anomaly detection（异常检测）</li></ul> </li><li>Recommender Systems（推荐系统）</li><li>Reinforcement Learning（强化学习）</li></ul> 
<h2><a id="__Kmeans_8"></a>一 、 K-means算法</h2> 
<h3><a id="1Notion_10"></a>1.Notion</h3> 
<h4><a id="a_Kmeans_12"></a>a) K-means做的</h4> 
<p>​ k-means<strong>重复做</strong>的两件事中</p> 
<p>​ 第一件：是分配簇质心，然后将样本点距离近的变成相关的颜色</p> 
<p>​ 第二件：重新遍历所有相同类型的点，然后取平均值，选出新的簇质心，检测每个点距离谁最近</p> 
<h4><a id="b_some__symbol__cost_function_20"></a>b) some symbol &amp; cost function</h4> 
<p><img src="https://images2.imgbox.com/45/b3/kee6Qbs9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_kmeans__27"></a>2. k-means 聚类的步骤</h3> 
<h4><a id="a__Random_initialization_k_29"></a>a) Random initialization k</h4> 
<p>​ 簇质心随机选择样本中的点，然后循环多次选择不同的样本为簇质心，用于来找到 J 最小的时候的簇质心，次数如果太多也会降低效果</p> 
<p><img src="https://images2.imgbox.com/95/cb/ulPW5Crm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="b__how_many_k_do_we__need__36"></a>b ) how many k do we need ?</h4> 
<h5><a id="i__elbow_method_38"></a>i . elbow method(肘部法则)</h5> 
<p>​ 当我们将<strong>k</strong> 从1增加到m时候，代价函数 J 的函数图像会从大到小的递减，函数会有一个从递减迅速到缓慢的点，类似于<strong>人类的肘部</strong> （但是有时很多J都是平缓下降的 没有肘部）<br> <img src="https://images2.imgbox.com/0e/49/t80YKk6X_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__Anomaly_detection_45"></a>二 、 Anomaly detection</h2> 
<h3><a id="1_notion_47"></a>1. notion</h3> 
<p><img src="https://images2.imgbox.com/4f/c0/9uaVYgsJ_o.png" alt="在这里插入图片描述"><br> <strong>如何计算正态分布的两个变量</strong></p> 
<p><img src="https://images2.imgbox.com/c1/d1/3lmrp7CN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__57"></a>2. 计算步骤</h3> 
<p><img src="https://images2.imgbox.com/89/f2/RCsULPLq_o.png" alt="在这里插入图片描述"></p> 
<ul><li>首先算出每一个特征的<strong>均值和方差</strong></li><li>利用每个<strong>特征的方差和均值</strong>算出某一个样本中的概率<strong>p(x)</strong></li><li>用计算出的<strong>p(x)和阈值</strong>比较，如果满足则表示有问题</li><li><strong>查看算法在交叉验证集中没能检测出的异常，然后考虑是否需要新建一个特征，使得发现这些异常</strong></li><li><strong>原理：</strong> 算出每个样本的<strong>feature</strong>相较于所有样本中的<strong>异常大或者小的feature</strong>，然后p(x）乘出来会很小所以标记为异常<br> <img src="https://images2.imgbox.com/f8/1e/IAYPD3yh_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="3_algorithm_evaluation_system_69"></a>3. algorithm evaluation system（异常评估系统）</h3> 
<p><img src="https://images2.imgbox.com/03/aa/k4o51hxK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__Anomaly_detection__VS__supervised_learning_74"></a>4 . Anomaly detection VS supervised learning</h3> 
<h4><a id="a_how_to_choose_right_algorithm_76"></a>a) how to choose right algorithm</h4> 
<ul><li>当有很少的<strong>正样本</strong>时，异常检测算法通常是更合适的选择，负样本用于算<strong>p(x)<strong>的参数，而</strong>正样本</strong>只用于测试集中的交叉验证集，用于参数调整和评估</li><li>异常检测适用于经常出现<strong>新的异常</strong>，以前样本<strong>不包含的异常</strong>，而监督学习适用于<strong>垃圾邮件类</strong>对类型基本不变的情况</li></ul> 
<p>​</p> 
<h3><a id="5_choose_feature_83"></a>5. choose feature</h3> 
<p>​ 因为异常检测算法很难找出要<strong>忽略的特征</strong> 所以选择特征是很重要的</p> 
<p><img src="https://images2.imgbox.com/23/04/W9Z6byEp_o.png" alt="在这里插入图片描述"></p> 
<p>​ 首先根据plt.hist函数画出直方图，查看是否类似<strong>高斯曲线</strong>,如果是则可以直接用，如果不是则对x进行变化，变成x的函数。最后再形成高斯曲线的形式</p> 
<h2><a id="Recommended_systems__94"></a>三、Recommended systems （推荐系统）</h2> 
<h3><a id="1notion_96"></a>1.notion</h3> 
<p><img src="https://images2.imgbox.com/47/6f/LdV9CGAF_o.png" alt="在这里插入图片描述"></p> 
<p>​</p> 
<h3><a id="2__102"></a>2. 协同过滤算法</h3> 
<pre><code>		假如我们无法从样本中获取足够的特征时候，怎么才能使用线性回归来
</code></pre> 
<h4><a id="a_cost_function_106"></a>a) cost function</h4> 
<p><img src="https://images2.imgbox.com/ce/62/H2wkB7M6_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/2c/de/3G5jsvdW_o.png" alt="在这里插入图片描述"></p> 
<p>​ b) gradient descent</p> 
<p><img src="https://images2.imgbox.com/e8/70/bemDp1x3_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_Mean__Normalization_121"></a>3. Mean Normalization（均值归一化）</h3> 
<p>​ <strong>作用：</strong> 当新用户进行预测时，会直接全部都预测为0，但均值归一化会出手，使得等于已评价用户的平均值。</p> 
<p><img src="https://images2.imgbox.com/2d/fe/n68Fc0iW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_build_collaborative_filtering_algorithm_by_tensorflow_127"></a>4. build collaborative filtering algorithm by tensorflow</h3> 
<h3><a id="5___131"></a>5 . 协同过滤和基于内容的协同过滤对比</h3> 
<p>​<img src="https://images2.imgbox.com/eb/20/d1uMcKcL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6___136"></a>6 . 从大型目录中推荐</h3> 
<p><img src="https://images2.imgbox.com/a2/66/DulObzuo_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/90/f7/CIMYNkR4_o.png" alt="在这里插入图片描述"></p> 
<p><strong>第一步：检索</strong>，找到许多大范围的可以推荐的相似电影</p> 
<p><strong>第二步：排名</strong>，将用户和检索到的电影的特征向量都输入到这个神经网络中去，得到用户对电影的评分预测值</p> 
<h2><a id="__Reinforcement_learning_148"></a>四 、 Reinforcement learning</h2> 
<p>​ 做一个奖罚机制，告诉他什么时候做的好，什么时候做不好，在学习的过程中，经常会看到<strong>四个变量：状态，行动，奖励，下一个状态</strong></p> 
<h3><a id="1__reward_of_reinforcement_learning_152"></a>1 . reward of reinforcement learning</h3> 
<p>​ 最终的奖励不仅仅是单独和目的地的值有关，还有到达的时间有关，奖励等于一步一步的时间的<strong>加权值</strong>到最后终点的值的乘积</p> 
<h3><a id="2__decision_on_reinforcement__learning_156"></a>2 . decision on reinforcement learning</h3> 
<p>​ 找到一个函数，告诉我们程序下一步需要往哪里</p> 
<h3><a id="3__import_notation_160"></a>3 . import notation</h3> 
<p><img src="https://images2.imgbox.com/63/03/bC6nk6De_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__State_action_value_function_167"></a>4 . State action value function（状态动作价值函数）</h3> 
<p>​ **Q（state,action)**在某个状态时做出不同动作得到的奖励，<strong>如果有办法计算每一个状态的不同动作对应的Q（s,a)则可以得到最大的奖励</strong></p> 
<h3><a id="5__Bellman_Equation__171"></a>5 . Bellman Equation (贝尔曼方程)</h3> 
<h4><a id="anotion_173"></a>a)notion</h4> 
<p><img src="https://images2.imgbox.com/5a/da/z1h7XGO2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="b_Explanation_of__Equation_178"></a>b) Explanation of Equation</h4> 
<p><img src="https://images2.imgbox.com/ee/e0/oTyFhZlJ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="c_random_or_stochastic_environments_183"></a>c) random or stochastic environments（模拟随机的环境）</h4> 
<p>​ 因为实际的环境中，机器不能完全按照我们的思想去进行，有一定的概率犯错，所以<strong>最大化的奖励需要取好多次折扣奖励的平均值，也叫期望</strong></p> 
<h3><a id="6__189"></a>6. 算法的改进</h3> 
<h4><a id="aminibatch_191"></a>a)mini-batch</h4> 
<p>​ 既可以用于supervised learning 也可以用于强化学习</p> 
<p>​ <strong>作用：</strong> 监督学习中，当数据量很大的时候，做梯度下降时，每次只看前一次的数据集的子集，所以迭代的更快</p> 
<h4><a id="b_softupdate_197"></a>b) soft-update</h4> 
<p>​ 强化学习算法更好的收敛</p> 
<h4><a id="aminibatch_215"></a>a)mini-batch</h4> 
<p>​ 既可以用于supervised learning 也可以用于强化学习</p> 
<p>​ <strong>作用：</strong> 监督学习中，当数据量很大的时候，做梯度下降时，每次只看前一次的数据集的子集，所以迭代的更快</p> 
<h4><a id="b_softupdate_221"></a>b) soft-update</h4> 
<p>​ 强化学习算法更好的收敛</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd52ddc3b48d1dd74f84b03dd23c1572/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hadoop集群三节点搭建（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/83a33e8225cf5502378d247c83feef87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">兄弟们mdpi或者ieee Access润色和翻译都咋搞的哇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>