<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SimpleHostRoutingFilter - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SimpleHostRoutingFilter" />
<meta property="og:description" content="2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; /*
* Copyright 2013-2017 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/caf3856e1d1828c23018d3ddb6a6dadb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-03T15:56:00+08:00" />
<meta property="article:modified_time" content="2018-04-03T15:56:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SimpleHostRoutingFilter</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="content" id="articleContent"> 
 <div class="ad-wrap"> 
  <p><a style="color:#A00;font-weight:bold;" href="https://my.oschina.net/u/2663968/blog/3061697" rel="nofollow">2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; </a> <img src="https://images2.imgbox.com/55/dd/U03qv6cL_o.png" alt="hot3.png"></p> 
 </div> 
 <p>/*<br>  * Copyright 2013-2017 the original author or authors.<br>  *<br>  * Licensed under the Apache License, Version 2.0 (the "License");<br>  * you may not use this file except in compliance with the License.<br>  * You may obtain a copy of the License at<br>  *<br>  *      http://www.apache.org/licenses/LICENSE-2.0<br>  *<br>  * Unless required by applicable law or agreed to in writing, software<br>  * distributed under the License is distributed on an "AS IS" BASIS,<br>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br>  * See the License for the specific language governing permissions and<br>  * limitations under the License.<br>  */</p> 
 <p>package org.springframework.cloud.netflix.zuul.filters.route;</p> 
 <p>import java.io.IOException;<br> import java.io.InputStream;<br> import java.net.URL;<br> import java.security.SecureRandom;<br> import java.security.cert.CertificateException;<br> import java.security.cert.X509Certificate;<br> import java.util.ArrayList;<br> import java.util.List;<br> import java.util.Map;<br> import java.util.Timer;<br> import java.util.TimerTask;</p> 
 <p>import javax.annotation.PostConstruct;<br> import javax.annotation.PreDestroy;<br> import javax.net.ssl.SSLContext;<br> import javax.net.ssl.TrustManager;<br> import javax.net.ssl.X509TrustManager;<br> import javax.servlet.http.HttpServletRequest;</p> 
 <p>import org.apache.commons.logging.Log;<br> import org.apache.commons.logging.LogFactory;<br> import org.apache.http.Header;<br> import org.apache.http.HttpHost;<br> import org.apache.http.HttpRequest;<br> import org.apache.http.HttpResponse;<br> import org.apache.http.ProtocolException;<br> import org.apache.http.client.RedirectStrategy;<br> import org.apache.http.client.config.CookieSpecs;<br> import org.apache.http.client.config.RequestConfig;<br> import org.apache.http.client.methods.CloseableHttpResponse;<br> import org.apache.http.client.methods.HttpPatch;<br> import org.apache.http.client.methods.HttpPost;<br> import org.apache.http.client.methods.HttpPut;<br> import org.apache.http.client.methods.HttpUriRequest;<br> import org.apache.http.config.Registry;<br> import org.apache.http.config.RegistryBuilder;<br> import org.apache.http.conn.socket.ConnectionSocketFactory;<br> import org.apache.http.conn.socket.PlainConnectionSocketFactory;<br> import org.apache.http.conn.ssl.NoopHostnameVerifier;<br> import org.apache.http.conn.ssl.SSLConnectionSocketFactory;<br> import org.apache.http.entity.ContentType;<br> import org.apache.http.entity.InputStreamEntity;<br> import org.apache.http.impl.client.CloseableHttpClient;<br> import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;<br> import org.apache.http.impl.client.HttpClientBuilder;<br> import org.apache.http.impl.client.HttpClients;<br> import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;<br> import org.apache.http.message.BasicHeader;<br> import org.apache.http.message.BasicHttpEntityEnclosingRequest;<br> import org.apache.http.message.BasicHttpRequest;<br> import org.apache.http.protocol.HttpContext;<br> import org.springframework.cloud.netflix.zuul.filters.ProxyRequestHelper;<br> import org.springframework.cloud.netflix.zuul.filters.ZuulProperties;<br> import org.springframework.cloud.netflix.zuul.filters.ZuulProperties.Host;<br> import org.springframework.cloud.netflix.zuul.util.ZuulRuntimeException;<br> import org.springframework.util.LinkedMultiValueMap;<br> import org.springframework.util.MultiValueMap;<br> import org.springframework.util.StringUtils;</p> 
 <p>import com.netflix.config.DynamicIntProperty;<br> import com.netflix.config.DynamicPropertyFactory;<br> import com.netflix.zuul.ZuulFilter;<br> import com.netflix.zuul.constants.ZuulConstants;<br> import com.netflix.zuul.context.RequestContext;</p> 
 <p>import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.HTTPS_SCHEME;<br> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.HTTP_SCHEME;<br> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.ROUTE_TYPE;<br> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SIMPLE_HOST_ROUTING_FILTER_ORDER;</p> 
 <p>/**<br>  * Route {<!-- --><a href="https://my.oschina.net/u/393" rel="nofollow" class="referer">@link</a> ZuulFilter} that sends requests to predetermined URLs via apache {<!-- --><a href="https://my.oschina.net/u/393" rel="nofollow" class="referer">@link</a> HttpClient}.<br>  * URLs are found in {<!-- --><a href="https://my.oschina.net/u/393" rel="nofollow" class="referer">@link</a> RequestContext#getRouteHost()}.<br>  *<br>  * <a href="https://my.oschina.net/arthor" rel="nofollow" class="referer">@author</a> Spencer Gibb<br>  * <a href="https://my.oschina.net/arthor" rel="nofollow" class="referer">@author</a> Dave Syer<br>  * @author Bilal Alp<br>  */<br> public class SimpleHostRoutingFilter extends ZuulFilter {<!-- --></p> 
 <p>    private static final Log log = LogFactory.getLog(SimpleHostRoutingFilter.class);</p> 
 <p>    private static final DynamicIntProperty SOCKET_TIMEOUT = DynamicPropertyFactory<br>             .getInstance()<br>             .getIntProperty(ZuulConstants.ZUUL_HOST_SOCKET_TIMEOUT_MILLIS, 10000);</p> 
 <p>    private static final DynamicIntProperty CONNECTION_TIMEOUT = DynamicPropertyFactory<br>             .getInstance()<br>             .getIntProperty(ZuulConstants.ZUUL_HOST_CONNECT_TIMEOUT_MILLIS, 2000);</p> 
 <p>    private final Timer connectionManagerTimer = new Timer(<br>             "SimpleHostRoutingFilter.connectionManagerTimer", true);</p> 
 <p>    private boolean sslHostnameValidationEnabled;<br>     private boolean forceOriginalQueryStringEncoding;</p> 
 <p>    private ProxyRequestHelper helper;<br>     private Host hostProperties;<br>     private PoolingHttpClientConnectionManager connectionManager;<br>     private CloseableHttpClient httpClient;</p> 
 <p>    private final Runnable clientloader = new Runnable() {<!-- --><br>         @Override<br>         public void run() {<!-- --><br>             try {<!-- --><br>                 SimpleHostRoutingFilter.this.httpClient.close();<br>             }<br>             catch (IOException ex) {<!-- --><br>                 log.error("error closing client", ex);<br>             }<br>             SimpleHostRoutingFilter.this.httpClient = newClient();<br>         }<br>     };</p> 
 <p>    public SimpleHostRoutingFilter(ProxyRequestHelper helper, ZuulProperties properties) {<!-- --><br>         this.helper = helper;<br>         this.hostProperties = properties.getHost();<br>         this.sslHostnameValidationEnabled = properties.isSslHostnameValidationEnabled();<br>         this.forceOriginalQueryStringEncoding = properties<br>                 .isForceOriginalQueryStringEncoding();<br>     }</p> 
 <p>    @PostConstruct<br>     private void initialize() {<!-- --><br>         this.httpClient = newClient();<br>         SOCKET_TIMEOUT.addCallback(this.clientloader);<br>         CONNECTION_TIMEOUT.addCallback(this.clientloader);<br>         this.connectionManagerTimer.schedule(new TimerTask() {<!-- --><br>             @Override<br>             public void run() {<!-- --><br>                 if (SimpleHostRoutingFilter.this.connectionManager == null) {<!-- --><br>                     return;<br>                 }<br>                 SimpleHostRoutingFilter.this.connectionManager.closeExpiredConnections();<br>             }<br>         }, 30000, 5000);<br>     }</p> 
 <p>    @PreDestroy<br>     public void stop() {<!-- --><br>         this.connectionManagerTimer.cancel();<br>     }</p> 
 <p>    @Override<br>     public String filterType() {<!-- --><br>         return ROUTE_TYPE;<br>     }</p> 
 <p>    @Override<br>     public int filterOrder() {<!-- --><br>         return SIMPLE_HOST_ROUTING_FILTER_ORDER;<br>     }</p> 
 <p>    @Override<br>     public boolean shouldFilter() {<!-- --><br>         return RequestContext.getCurrentContext().getRouteHost() != null<br>                 &amp;&amp; RequestContext.getCurrentContext().sendZuulResponse();<br>     }</p> 
 <p>    @Override<br>     public Object run() {<!-- --><br>         RequestContext context = RequestContext.getCurrentContext();<br>         HttpServletRequest request = context.getRequest();<br>         MultiValueMap&lt;String, String&gt; headers = this.helper<br>                 .buildZuulRequestHeaders(request);<br>         MultiValueMap&lt;String, String&gt; params = this.helper<br>                 .buildZuulRequestQueryParams(request);<br>         String verb = getVerb(request);<br>         InputStream requestEntity = getRequestBody(request);<br>         if (request.getContentLength() &lt; 0) {<!-- --><br>             context.setChunkedRequestBody();<br>         }</p> 
 <p>        String uri = this.helper.buildZuulRequestURI(request);<br>         this.helper.addIgnoredHeaders();</p> 
 <p>        try {<!-- --><br>             CloseableHttpResponse response = forward(this.httpClient, verb, uri, request,<br>                     headers, params, requestEntity);<br>             setResponse(response);<br>         }<br>         catch (Exception ex) {<!-- --><br>             throw new ZuulRuntimeException(ex);<br>         }<br>         return null;<br>     }</p> 
 <p>    protected PoolingHttpClientConnectionManager newConnectionManager() {<!-- --><br>         try {<!-- --><br>             final SSLContext sslContext = SSLContext.getInstance("SSL");<br>             sslContext.init(null, new TrustManager[] { new X509TrustManager() {<!-- --><br>                 @Override<br>                 public void checkClientTrusted(X509Certificate[] x509Certificates,<br>                         String s) throws CertificateException {<!-- --><br>                 }</p> 
 <p>                @Override<br>                 public void checkServerTrusted(X509Certificate[] x509Certificates,<br>                         String s) throws CertificateException {<!-- --><br>                 }</p> 
 <p>                @Override<br>                 public X509Certificate[] getAcceptedIssuers() {<!-- --><br>                     return null;<br>                 }<br>             } }, new SecureRandom());</p> 
 <p>            RegistryBuilder&lt;ConnectionSocketFactory&gt; registryBuilder = RegistryBuilder<br>                     .&lt;ConnectionSocketFactory&gt; create()<br>                     .register(HTTP_SCHEME, PlainConnectionSocketFactory.INSTANCE);<br>             if (this.sslHostnameValidationEnabled) {<!-- --><br>                 registryBuilder.register(HTTPS_SCHEME,<br>                         new SSLConnectionSocketFactory(sslContext));<br>             }<br>             else {<!-- --><br>                 registryBuilder.register(HTTPS_SCHEME, new SSLConnectionSocketFactory(<br>                         sslContext, NoopHostnameVerifier.INSTANCE));<br>             }<br>             final Registry&lt;ConnectionSocketFactory&gt; registry = registryBuilder.build();</p> 
 <p>            this.connectionManager = new PoolingHttpClientConnectionManager(registry, null, null, null,<br>                     hostProperties.getTimeToLive(), hostProperties.getTimeUnit());<br>             this.connectionManager<br>                     .setMaxTotal(this.hostProperties.getMaxTotalConnections());<br>             this.connectionManager.setDefaultMaxPerRoute(<br>                     this.hostProperties.getMaxPerRouteConnections());<br>             return this.connectionManager;<br>         }<br>         catch (Exception ex) {<!-- --><br>             throw new RuntimeException(ex);<br>         }<br>     }</p> 
 <p>    protected CloseableHttpClient newClient() {<!-- --><br>         final RequestConfig requestConfig = RequestConfig.custom()<br>                 .setSocketTimeout(SOCKET_TIMEOUT.get())<br>                 .setConnectTimeout(CONNECTION_TIMEOUT.get())<br>                 .setCookieSpec(CookieSpecs.IGNORE_COOKIES).build();</p> 
 <p>        HttpClientBuilder httpClientBuilder = HttpClients.custom();<br>         if (!this.sslHostnameValidationEnabled) {<!-- --><br>             httpClientBuilder.setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE);<br>         }<br>         return httpClientBuilder.setConnectionManager(newConnectionManager())<br>                 .disableContentCompression()<br>                 .useSystemProperties().setDefaultRequestConfig(requestConfig)<br>                 .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false))<br>                 .setRedirectStrategy(new RedirectStrategy() {<!-- --><br>                     @Override<br>                     public boolean isRedirected(HttpRequest request,<br>                             HttpResponse response, HttpContext context)<br>                             throws ProtocolException {<!-- --><br>                         return false;<br>                     }</p> 
 <p>                    @Override<br>                     public HttpUriRequest getRedirect(HttpRequest request,<br>                             HttpResponse response, HttpContext context)<br>                             throws ProtocolException {<!-- --><br>                         return null;<br>                     }<br>                 }).build();<br>     }</p> 
 <p>    private CloseableHttpResponse forward(CloseableHttpClient httpclient, String verb,<br>             String uri, HttpServletRequest request, MultiValueMap&lt;String, String&gt; headers,<br>             MultiValueMap&lt;String, String&gt; params, InputStream requestEntity)<br>             throws Exception {<!-- --><br>         Map&lt;String, Object&gt; info = this.helper.debug(verb, uri, headers, params,<br>                 requestEntity);<br>         URL host = RequestContext.getCurrentContext().getRouteHost();<br>         HttpHost httpHost = getHttpHost(host);<br>         uri = StringUtils.cleanPath((host.getPath() + uri).replaceAll("/{2,}", "/"));<br>         int contentLength = request.getContentLength();</p> 
 <p>        ContentType contentType = null;</p> 
 <p>        if (request.getContentType() != null) {<!-- --><br>             contentType = ContentType.parse(request.getContentType());<br>         }</p> 
 <p>        InputStreamEntity entity = new InputStreamEntity(requestEntity, contentLength, contentType);</p> 
 <p>        HttpRequest httpRequest = buildHttpRequest(verb, uri, entity, headers, params, request);<br>         try {<!-- --><br>             log.debug(httpHost.getHostName() + " " + httpHost.getPort() + " "<br>                     + httpHost.getSchemeName());<br>             CloseableHttpResponse zuulResponse = forwardRequest(httpclient, httpHost,<br>                     httpRequest);<br>             this.helper.appendDebug(info, zuulResponse.getStatusLine().getStatusCode(),<br>                     revertHeaders(zuulResponse.getAllHeaders()));<br>             return zuulResponse;<br>         }<br>         finally {<!-- --><br>             // When HttpClient instance is no longer needed,<br>             // shut down the connection manager to ensure<br>             // immediate deallocation of all system resources<br>             // httpclient.getConnectionManager().shutdown();<br>         }<br>     }</p> 
 <p>    protected HttpRequest buildHttpRequest(String verb, String uri,<br>             InputStreamEntity entity, MultiValueMap&lt;String, String&gt; headers,<br>             MultiValueMap&lt;String, String&gt; params, HttpServletRequest request) {<!-- --><br>         HttpRequest httpRequest;<br>         String uriWithQueryString = uri + (this.forceOriginalQueryStringEncoding<br>                 ? getEncodedQueryString(request) : this.helper.getQueryString(params));</p> 
 <p>        switch (verb.toUpperCase()) {<!-- --><br>             case "POST":<br>                 HttpPost httpPost = new HttpPost(uriWithQueryString);<br>                 httpRequest = httpPost;<br>                 httpPost.setEntity(entity);<br>                 break;<br>             case "PUT":<br>                 HttpPut httpPut = new HttpPut(uriWithQueryString);<br>                 httpRequest = httpPut;<br>                 httpPut.setEntity(entity);<br>                 break;<br>             case "PATCH":<br>                 HttpPatch httpPatch = new HttpPatch(uriWithQueryString);<br>                 httpRequest = httpPatch;<br>                 httpPatch.setEntity(entity);<br>                 break;<br>             case "DELETE":<br>                 BasicHttpEntityEnclosingRequest entityRequest = new BasicHttpEntityEnclosingRequest(<br>                         verb, uriWithQueryString);<br>                 httpRequest = entityRequest;<br>                 entityRequest.setEntity(entity);<br>                 break;<br>             default:<br>                 httpRequest = new BasicHttpRequest(verb, uriWithQueryString);<br>                 log.debug(uriWithQueryString);<br>         }</p> 
 <p>        httpRequest.setHeaders(convertHeaders(headers));<br>         return httpRequest;<br>     }</p> 
 <p>    private String getEncodedQueryString(HttpServletRequest request) {<!-- --><br>         String query = request.getQueryString();<br>         return (query != null) ? "?" + query : "";<br>     }</p> 
 <p>    private MultiValueMap&lt;String, String&gt; revertHeaders(Header[] headers) {<!-- --><br>         MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;String, String&gt;();<br>         for (Header header : headers) {<!-- --><br>             String name = header.getName();<br>             if (!map.containsKey(name)) {<!-- --><br>                 map.put(name, new ArrayList&lt;String&gt;());<br>             }<br>             map.get(name).add(header.getValue());<br>         }<br>         return map;<br>     }</p> 
 <p>    private Header[] convertHeaders(MultiValueMap&lt;String, String&gt; headers) {<!-- --><br>         List&lt;Header&gt; list = new ArrayList&lt;&gt;();<br>         for (String name : headers.keySet()) {<!-- --><br>             for (String value : headers.get(name)) {<!-- --><br>                 list.add(new BasicHeader(name, value));<br>             }<br>         }<br>         return list.toArray(new BasicHeader[0]);<br>     }</p> 
 <p>    private CloseableHttpResponse forwardRequest(CloseableHttpClient httpclient,<br>             HttpHost httpHost, HttpRequest httpRequest) throws IOException {<!-- --><br>         return httpclient.execute(httpHost, httpRequest);<br>     }</p> 
 <p>    private HttpHost getHttpHost(URL host) {<!-- --><br>         HttpHost httpHost = new HttpHost(host.getHost(), host.getPort(),<br>                 host.getProtocol());<br>         return httpHost;<br>     }</p> 
 <p>    private InputStream getRequestBody(HttpServletRequest request) {<!-- --><br>         InputStream requestEntity = null;<br>         try {<!-- --><br>             requestEntity = request.getInputStream();<br>         }<br>         catch (IOException ex) {<!-- --><br>             // no requestBody is ok.<br>         }<br>         return requestEntity;<br>     }</p> 
 <p>    private String getVerb(HttpServletRequest request) {<!-- --><br>         String sMethod = request.getMethod();<br>         return sMethod.toUpperCase();<br>     }</p> 
 <p>    private void setResponse(HttpResponse response) throws IOException {<!-- --><br>         RequestContext.getCurrentContext().set("zuulResponse", response);<br>         this.helper.setResponse(response.getStatusLine().getStatusCode(),<br>                 response.getEntity() == null ? null : response.getEntity().getContent(),<br>                 revertHeaders(response.getAllHeaders()));<br>     }</p> 
 <p>    /**<br>      * Add header names to exclude from proxied response in the current request.<br>      * @param names<br>      */<br>     protected void addIgnoredHeaders(String... names) {<!-- --><br>         this.helper.addIgnoredHeaders(names);<br>     }</p> 
 <p>    /**<br>      * Determines whether the filter enables the validation for ssl hostnames.<br>      * @return true if enabled<br>      */<br>     boolean isSslHostnameValidationEnabled() {<!-- --><br>         return this.sslHostnameValidationEnabled;<br>     }<br> }<br>  </p> 
 <div class="ad-wrap"> 
  <div id="blog-title-ad"> 
   <ins class="adsbygoogle"></ins> 
  </div> 
 </div> 
</div> 
<p>转载于:https://my.oschina.net/xiaominmin/blog/1789326</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03a8be19cd9c761b4b3d58b28bd0cb0c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">numpy矩阵遍历</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eca2f2d2a18c92872527882e0dabd26f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32之SPI读写FLASH(W25Q64)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>