<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PHP之伪协议 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PHP之伪协议" />
<meta property="og:description" content="前言 伪协议是什么？
PHP伪协议事实上就是支持的协议与封装协议。ctf中的文件包含、文件读取的绕过、正则的绕过等等会需要用到。
那伪协议有哪些？
file:// 、data:// 、 gopher:// 、php:// 等等，下面会讲。
PHP伪协议 【file://协议】 --------本地文件传输协议
file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受配置文件中allow_url_fopen与allow_url_include的影响。
格式：
www.xxx.com?cmd.php=file://[文件的绝对路径和文件名] file://的学问挺大的，如果对其有兴趣的可以百度细搜，在ctf中file用的较少(一般会被过滤)，这里就讲如何用，为CTF的题目做准备的。
【php://协议】 重头戏了属于是，php:// 是ctf的常客，所以关于它的故事很多。
使用条件(php.ini配置)：
allow_url_fopenallow_url_includephp://inputon/offonphp://stdinon/offonphp://memoryon/offonphp://tempon/offonphp://filteron/offon/off 看着确实挺多的，有点迷糊，但是只需要记住php://input 以及 php://filter 就行了，就这俩常用，如果想了解其它几个的作用开拓新的绕过姿势可以自己百度搜索哈哈哈。
php://filter 名称描述resource&lt;---&gt;要过滤的数据流这是个必要参数。它指定了你需要筛选过滤的数据流(简单来说就是你的数据来源)read&lt;---&gt;读链的筛选列表这个参数可选。可以设定一个或多个过滤器名称。以管道符（/）分隔write&lt;---&gt;读链的筛选列表这个参数可选。可以设定一个或多个过滤器名称。以管道符（/）分隔 看着很乏味，拿个基础题看看
[第一章 web入门]afr_1 非常基础的题目，考察点纯纯就是php://filter，想做的可以在BUU平台复现
题目给了提示，文件包含，所以这个p盲猜是include内的参数，所以直接输入flag试试 不能直接读取，那就用伪协议间接读它的源码，看看源码有什么猫腻
因为这里用了一次base64编码，用脚本解码就可以了。
小结：
遇到文件包含需要读取源码可以使用php://filter协议，格式如下
读：php://filter/resource=文件名 php://filter/read=convert.base64-encode/resource=文件名 写：php://filter/resource=文件名&amp;txt=文件内容 php://filter/write=convert.base64-encode/resource=文件名&amp;txt=文件内容 php://input ----可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。
php://input是php语言中一个只读的数据流；通过&#34;php://input&#34;，可以读取从Http客户端以POST方式提交、请求头“Content-Type”值非&#34;multipart/form-data​&#34;的所有数据；&#34;php://input&#34;一般用来读取POST上来，除已被处理以外的剩余数据。
说白了就是当遇到正则匹配时GET传参不能出现的敏感字符，可以通过php://input在POST上传最后绕过了检测。
格式为：
GET : index.php?cmd=php://input POST : flag.php(目的数据) 有个协议和php://input作用相同，如果碰到input被过滤的情况可以用其替代，这个协议叫data://协议，也比较常用。
和php:input不同的是data://需要 allow_url_fopen、allow_url_include都需要打开（on）。
格式也稍稍有点不同，全部是在GET实现的
file.php?file=data://text/plain;base64,SSBsb3ZlIFBIUAo= data://text/plain 是固定格式，后面如果有过滤可以用base64，内容可以是命令，也可以输出一些东西，看题目行事。
【zip://,bzip2://,zlib://协议】 zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。
【zip://协议】 格式：
zip:// [压缩文件绝对路径]#[压缩文件内的子文件名]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/cac70b42f5e59d5c939dcf05a841f407/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-13T19:32:43+08:00" />
<meta property="article:modified_time" content="2022-03-13T19:32:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PHP之伪协议</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>伪协议是什么？</p> 
<p>PHP伪协议事实上就是支持的协议与封装协议。ctf中的文件包含、文件读取的绕过、正则的绕过等等会需要用到。</p> 
<p>那伪协议有哪些？</p> 
<p><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">file://</span></span> 、<span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">data://</span></span> 、 <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">gopher://</span></span> 、<span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">php://</span></span> 等等，下面会讲。</p> 
<p></p> 
<h2 id="PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE">PHP伪协议</h2> 
<h3 id="%E3%80%90file%3A%2F%2F%E5%8D%8F%E8%AE%AE%E3%80%91">【file://协议】</h3> 
<p>--------本地文件传输协议</p> 
<p><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">file:// </span></span>用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受配置文件中allow_url_fopen与allow_url_include的影响。</p> 
<p>格式：</p> 
<pre><code>www.xxx.com?cmd.php=file://[文件的绝对路径和文件名]</code></pre> 
<p></p> 
<p><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">file://</span></span>的学问挺大的，如果对其有兴趣的可以百度细搜，在ctf中file用的较少(<span style="background-color:#f3f3f4;">一般会被过滤</span>)，这里就讲如何用，为CTF的题目做准备的。</p> 
<p></p> 
<h3 id="%E3%80%90php%3A%2F%2F%E5%8D%8F%E8%AE%AE%E3%80%91">【<strong>php://协议</strong>】</h3> 
<p>重头戏了属于是，<span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">php://</span></span> 是ctf的常客，所以关于它的故事很多。</p> 
<p>使用条件(php.ini配置)：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td></td><td><strong>allow_url_fopen</strong></td><td><strong>allow_url_include</strong></td></tr><tr><td><strong>php://input</strong></td><td>on/off</td><td>on</td></tr><tr><td><strong>php://stdin</strong></td><td>on/off</td><td>on</td></tr><tr><td><strong>php://memory</strong></td><td>on/off</td><td>on</td></tr><tr><td><strong>php://temp</strong></td><td>on/off</td><td>on</td></tr><tr><td><strong>php://filter</strong></td><td>on/off</td><td>on/off</td></tr></tbody></table> 
<p>看着确实挺多的，有点迷糊，但是只需要记住<span style="color:#fe2c24;"><strong><span style="background-color:#f3f3f4;">php://input</span></strong></span><strong> </strong>以及 <span style="color:#fe2c24;"><strong><span style="background-color:#f3f3f4;">php://filter</span></strong></span> 就行了，就这俩常用，如果想了解其它几个的作用开拓新的绕过姿势可以自己百度搜索哈哈哈。</p> 
<h4 id="%C2%A0%20php%3A%2F%2Ffilter"><strong>  php://filter</strong></h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:599px;"><tbody><tr><td style="width:195px;">名称</td><td style="width:401px;">描述</td></tr><tr><td style="width:195px;">resource&lt;---&gt;要过滤的数据流</td><td style="width:401px;">这是个必要参数。它指定了你需要筛选过滤的数据流(简单来说就是你的数据来源)</td></tr><tr><td style="width:195px;">read&lt;---&gt;读链的筛选列表</td><td style="width:401px;">这个参数可选。可以设定一个或多个过滤器名称。以管道符（/）分隔</td></tr><tr><td style="width:195px;">write&lt;---&gt;读链的筛选列表</td><td style="width:401px;">这个参数可选。可以设定一个或多个过滤器名称。以管道符（/）分隔</td></tr></tbody></table> 
<p>看着很乏味，拿个基础题看看</p> 
<h3 id="%5B%E7%AC%AC%E4%B8%80%E7%AB%A0%20web%E5%85%A5%E9%97%A8%5Dafr_1">[第一章 web入门]afr_1</h3> 
<p>非常基础的题目，考察点纯纯就是php://filter，想做的可以在<a class="link-info" href="http://buuoj.cn" rel="nofollow" title="BUU平台">BUU平台</a>复现</p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/d3/4e/P0svlj7m_o.png" width="943"></p> 
<p>题目给了提示，文件包含，所以这个p盲猜是include内的参数，所以直接输入flag试试 </p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/ce/d1/sThx1l13_o.png" width="902"></p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/fa/72/T3IdlEN8_o.png" width="1099"> </p> 
<p> </p> 
<p>不能直接读取，那就用伪协议间接读它的源码，看看源码有什么猫腻</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/aa/c5/tQPxc8pK_o.png" width="1200"></p> 
<p> 因为这里用了一次base64编码，用脚本解码就可以了。</p> 
<p><img alt="" height="398" src="https://images2.imgbox.com/ca/2a/BBahuWxG_o.png" width="801"></p> 
<p> 小结：</p> 
<p>遇到文件包含需要读取源码可以使用php://filter协议，格式如下</p> 
<pre><code>读：php://filter/resource=文件名

php://filter/read=convert.base64-encode/resource=文件名

写：php://filter/resource=文件名&amp;txt=文件内容

php://filter/write=convert.base64-encode/resource=文件名&amp;txt=文件内容</code></pre> 
<h4 id="php%3A%2F%2Finput"><strong>php://input</strong></h4> 
<p>                   ----可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。</p> 
<p><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">php://input</span></span>是php语言中一个只读的数据流；通过"php://input"，可以读取从Http客户端以POST方式提交、请求头“Content-Type”值非"multipart/form-data​"的所有数据；"php://input"一般用来读取POST上来，除已被处理以外的剩余数据。</p> 
<p>说白了就是当遇到正则匹配时GET传参不能出现的敏感字符，可以通过php://input在POST上传最后绕过了检测。</p> 
<p>格式为：</p> 
<pre><code>GET : index.php?cmd=php://input

POST : flag.php(目的数据)</code></pre> 
<p>有个协议和php://input作用相同，如果碰到input被过滤的情况可以用其替代，这个协议叫<span style="color:#fe2c24;"><strong><span style="background-color:#f3f3f4;">data://</span></strong></span>协议，也比较常用。</p> 
<p>和php:input不同的是data://需要 allow_url_fopen、allow_url_include都需要打开（on）。</p> 
<p>格式也稍稍有点不同，全部是在GET实现的</p> 
<pre><code>file.php?file=data://text/plain;base64,SSBsb3ZlIFBIUAo=</code></pre> 
<p><img alt="" height="185" src="https://images2.imgbox.com/81/0b/fmE1gzdU_o.png" width="792"></p> 
<p><strong>data://text/plain</strong> 是固定格式，后面如果有过滤可以用base64，内容可以是命令，也可以输出一些东西，看题目行事。</p> 
<h3><strong>【zip://,bzip2://,zlib://协议】</strong></h3> 
<p></p> 
<p><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">zip://</span></span>, <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">bzip2://</span></span>, <strong><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">zlib://</span></span></strong> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。</p> 
<p></p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/80/dd/m6HqHjX8_o.png" width="1070"></p> 
<h4><br><strong>【zip://协议】</strong></h4> 
<p>格式：</p> 
<p><span style="background-color:#fef2f0;">zip:// [压缩文件绝对路径]#[压缩文件内的子文件名]</span></p> 
<p>例如:    zip://archive.zip#dir/file.txt</p> 
<p>先将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩,压缩文件名为file.zip,如果可以上传zip文件便直接上传，若不能便将file.zip重命名为file.jpg后在上传，其他几种压缩格式也可以这样操作。</p> 
<p>由于#在get请求中会将后面的参数忽略所以使用get请求时候应进行url编码为%23，且此处经过测试相对路径是不可行，所以只能用绝对路径。</p> 
<p></p> 
<h4><strong>【bzip2://协议】</strong></h4> 
<p>使用方法：</p> 
<pre><code>file = compress.bzip2://file.bz2</code></pre> 
<p>在本地的格式使用</p> 
<pre><code>http://127.0.0.1/cmd.php?file=compress.bzip2://D:/phpStudy/PHPTutorial/WWW/file.jpg

或者

http://127.0.0.1/cmd.php?file=compress.bzip2://./file.jpg</code></pre> 
<p></p> 
<h4><strong>【zlib://协议】</strong></h4> 
<p>使用方法：</p> 
<pre><code>file=compress.zlib://file.gz</code></pre> 
<p>在本地的格式使用</p> 
<pre><code>​
http://127.0.0.1/cmd.php?file=compress.zlib://D:/phpStudy/PHPTutorial/WWW/file.jpg

或者

http://127.0.0.1/cmd.php?file=compress.zlib://./file.jpg

​</code></pre> 
<p></p> 
<p>总结：要真正要熟知的可能就是php://**的协议，像后面的几个压缩协议，只是为了拓展攻击面，但事实是我可能太菜了，没碰到很多题目需要用到zip://这类协议的。</p> 
<p></p> 
<p></p> 
<p> 参考：<a href="https://www.php.net/manual/zh/wrappers.compression.php" rel="nofollow" title="PHP: zlib:// - Manual">PHP: zlib:// - Manual</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff2e5c8e4240798dfed54df7ae529b2e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS中setTimeout()的用法详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7774f9c7d58ce9dd92611b392b26438/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OA系统--userServer</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>