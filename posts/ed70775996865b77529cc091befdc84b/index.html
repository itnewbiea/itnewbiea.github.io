<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java虚拟机中的垃圾回收 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java虚拟机中的垃圾回收" />
<meta property="og:description" content="2 垃圾回收 2.1 判断一个对象是否可回收 2.1.1 引用计数法 如果一个对象被另一个对象引用，那么它的引用计数加一，如果那个对象不再引用它了，那么引用计数减一。当引用计数为 0 时，该对象就应该被垃圾回收了。
但是下面这种互相引用的情况就无法回收了：
两个对象的计数都为1，导致两个对象都无法被释放
2.1.2 可达性分析算法 垃圾回收之前，扫描所有对象，判断每个对象是否被根对象引用，如果没有被根对象引用，那么在以后垃圾回收时就将那些没有与根相连的对象回收
Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收哪些对象可以作为 GC Root ? 查找可以作为GCRoot的对象：
运行下面程序：
public static void main(String[] args) throws IOException { ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(&#34;a&#34;); list.add(&#34;b&#34;); list.add(1); System.out.println(1); System.in.read(); list = null; System.out.println(2); System.in.read(); System.out.println(&#34;end&#34;); } 使用 jmap -dump:format=b,live,file=1.bin 进程id 将堆内存中的信息存储到文件1.bin中
使用Eclipse Memory Analyzer 打开1.bin文件，选择 GC Root 选项进行分析：
可以看出 GC Root 分为四类：
System Class ：系统类，启动类加载器加载的类，例如Object，HashMap等核心类Native Stack：Java 有时候需要调用系统中的一些方法Busy Monitor ：被加锁的对象也需要被保留Thread：活动线程的栈帧内中使用的对象 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ed70775996865b77529cc091befdc84b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T22:08:23+08:00" />
<meta property="article:modified_time" content="2023-12-29T22:08:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java虚拟机中的垃圾回收</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="2__0"></a>2 垃圾回收</h2> 
<h3><a id="21__2"></a>2.1 判断一个对象是否可回收</h3> 
<h4><a id="211__4"></a>2.1.1 引用计数法</h4> 
<p>如果一个对象被另一个对象引用，那么它的引用计数加一，如果那个对象不再引用它了，那么引用计数减一。当引用计数为 0 时，该对象就应该被垃圾回收了。</p> 
<p>但是下面这种互相引用的情况就无法回收了：</p> 
<p>两个对象的计数都为1，导致两个对象都无法被释放</p> 
<p><img src="https://images2.imgbox.com/ab/4e/M1wUgxqr_o.png" alt="image-20231222213023143"></p> 
<h4><a id="212__14"></a>2.1.2 可达性分析算法</h4> 
<p>垃圾回收之前，扫描所有对象，判断每个对象是否被根对象引用，如果没有被根对象引用，那么在以后垃圾回收时就将那些没有与根相连的对象回收</p> 
<ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收</li><li>哪些对象可以作为 GC Root ?</li></ul> 
<p><strong>查找可以作为GCRoot的对象：</strong></p> 
<p>运行下面程序：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        list <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


</code></pre> 
<p>使用 <code> jmap -dump:format=b,live,file=1.bin 进程id</code> 将堆内存中的信息存储到文件1.bin中</p> 
<p>使用Eclipse Memory Analyzer 打开1.bin文件，选择 GC Root 选项进行分析：</p> 
<p><img src="https://images2.imgbox.com/80/5e/20JRGPvL_o.png" alt="image-20231222214435898"></p> 
<p>可以看出 GC Root 分为四类：</p> 
<ul><li>System Class ：系统类，启动类加载器加载的类，例如Object，HashMap等核心类</li><li>Native Stack：Java 有时候需要调用系统中的一些方法</li><li>Busy Monitor ：被加锁的对象也需要被保留</li><li>Thread：活动线程的栈帧内中使用的对象</li></ul> 
<h4><a id="213__58"></a>2.1.3 五种引用</h4> 
<ol><li> <p>强引用</p> <p>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p> </li></ol> 
<p>例如：C对象和B对象强引用了 A1 对象，只有 C 对象和 B 对象都不强引用了 A1 对象，A1 对象才可以被垃圾回收</p> 
<p><img src="https://images2.imgbox.com/16/2e/wKYnyIue_o.png" alt="image-20231223165023644"></p> 
<ol start="2"><li>软引用（SoftReference） 
  <ul><li><strong>仅有软引用引用该对象时</strong>，<strong>在垃圾回收后，内存仍不足时会再次触发垃圾回收</strong>，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li></ul> </li><li>弱引用（WeakReference） 
  <ul><li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li></ul> </li></ol> 
<p><img src="https://images2.imgbox.com/26/eb/tyvraTnI_o.png" alt="image-20231223165530366"></p> 
<ol start="4"><li>虚引用（PhantomReference）</li></ol> 
<ul><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul> 
<p>Cleaner 对象虚引用 ByteBuffer 对象</p> 
<p><img src="https://images2.imgbox.com/28/bd/tpJ3AdQe_o.png" alt="image-20231223165915900"></p> 
<p>当ByteBuffer 对象被回收后，其分配的直接内存还没有被回收。</p> 
<p>这时Cleaner对象会被放入引用队列：</p> 
<p><img src="https://images2.imgbox.com/35/21/MgblpTvU_o.png" alt="image-20231223170045348"></p> 
<p>虚引用所在的队列会由一个ReferenceHandler的线程来定时的在队列中寻找是否有新入队的 Cleaner ，如果有就会调用 Cleaner 对象中的 clean 方法。而 clean 方法就会根据前面记录的直接内存的地址，用 Unsafe.freeMemory 方法释放直接内存：</p> 
<p><img src="https://images2.imgbox.com/fe/8b/kgU8rDtZ_o.png" alt="image-20231223170306689"></p> 
<ol start="5"><li>终结器引用（FinalReference）</li></ol> 
<ul><li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象<br> 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，第二次 GC 时才能回收被引用对象</li></ul> 
<p>所有对象都继承自Object类，其中有一个 finalize 方法</p> 
<p>如果 finalize 方法被重写了，也就是被对象实现了。jvm 就会将终结器引用对象放入引用队列。就会有一个FinalizeHandler的线程对队列进行检查。找到了终结器引用，就会根据它找到该对象，调用 finalize 方法。调用完后，第二次垃圾回收才可以把该对象回收掉</p> 
<p><img src="https://images2.imgbox.com/b3/96/00DipPWa_o.png" alt="image-20231223170935669"></p> 
<h4><a id="214__106"></a>2.1.4 软引用的示例</h4> 
<p>内存不足时，会回收软引用对象，可用于对象缓存</p> 
<p>可以用 SoftReference 对象保证要软引用的对象：</p> 
<p>首先限制内存大小的 vm option ：<code>-Xmx20m</code></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> d1_SoftReference <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// list -&gt; SoftReference -&gt; byte[]</span>
        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环结束"</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> reference <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：可以看出由于内存空间不足，前三个ref都被回收掉了</p> 
<pre><code class="prism language-java"><span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@10f87f48</span>
<span class="token number">1</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@b4c966a</span>
<span class="token number">2</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@2f4d3709</span>
<span class="token number">3</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@4e50df2e</span>
<span class="token number">4</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@1d81eb93</span>
<span class="token number">5</span>
循环结束<span class="token number">5</span>
<span class="token keyword">null</span>
<span class="token keyword">null</span>
<span class="token keyword">null</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@4e50df2e</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@1d81eb93</span>
</code></pre> 
<p>软引用，引用的对象为 null，那么软引用本身也就没有必要保留了。这里可以用软引用队列来对软引用对象本身进行回收</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> d1_SoftReference <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 引用队列</span>
        <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 这里关联了软引用队列，当 byte[]被回收时，软引用本身会被加入到 queue中</span>
            <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 清除掉没有内容的软引用本身：</span>
        <span class="token class-name">Reference</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> poll <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>poll <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>poll<span class="token punctuation">)</span><span class="token punctuation">;</span>
            poll <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环结束"</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> reference <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：这里的list中只有2个byte数组了</p> 
<pre><code class="prism language-java"><span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@10f87f48</span>
<span class="token number">1</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@b4c966a</span>
<span class="token number">2</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@2f4d3709</span>
<span class="token number">3</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@4e50df2e</span>
<span class="token number">4</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@1d81eb93</span>
<span class="token number">5</span>
循环结束<span class="token number">2</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@4e50df2e</span>
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@1d81eb93</span>
</code></pre> 
<h4><a id="215___202"></a>2.1.5 弱引用示例</h4> 
<p>不管内存是否充足，如果只有弱引用引用该对象，就会回收该对象</p> 
<pre><code class="prism language-java"><span class="token comment">// -Xmx20m</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> d2_WeakReference <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// list -&gt; WeakReference -&gt; byte[]</span>
        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> ref <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> weakReference <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>weakReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环结束："</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：在垃圾回收时会将弱引用对象回收：</p> 
<pre><code class="prism language-java"><span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@10f87f48</span> 

<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@10f87f48</span> 
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@1d81eb93</span> 

<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@10f87f48</span> 
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@1d81eb93</span> 
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@7291c18f</span> 

<span class="token keyword">null</span> 
<span class="token keyword">null</span> 
<span class="token keyword">null</span> 
<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token annotation punctuation">@34a245ab</span> 

<span class="token keyword">null</span> 
<span class="token keyword">null</span> 
<span class="token keyword">null</span> 
<span class="token keyword">null</span> 
<span class="token keyword">null</span> 

循环结束：<span class="token number">5</span>
</code></pre> 
<h3><a id="22__251"></a>2.2 垃圾回收算法</h3> 
<h4><a id="221___253"></a>2.2.1 标记清除</h4> 
<p>Mark Sweep</p> 
<p>记录垃圾对象的地址</p> 
<p>优点：速度快</p> 
<p>缺点：造成内存碎片，本可以存下的新对象因为内存分布的太分散而无法存下</p> 
<p><img src="https://images2.imgbox.com/3b/d1/ggFAdYWG_o.png" alt="image-20231223190346153"></p> 
<h4><a id="222__265"></a>2.2.2 标记整理</h4> 
<p>将所有存活的对象移动到一端，避免了内存碎片的产生，但是由于对象发生了移动，所以算法的速度慢</p> 
<ul><li>速度慢</li><li>没内存碎片</li></ul> 
<p><img src="https://images2.imgbox.com/ff/f8/xfNKiHgo_o.png" alt="image-20231223190839788"></p> 
<h4><a id="223__274"></a>2.2.3 复制</h4> 
<p>把内存空间分为两部分。一部分内存空间用完了，就把存活的对象复制到另一部分的内存空间上面。然后把使用过的内存空间进行清理。</p> 
<ul><li>不会产生碎片</li><li>占用双倍的内存空间</li></ul> 
<p><img src="https://images2.imgbox.com/1e/4c/paORGjrt_o.png" alt="image-20231223191124239"></p> 
<h3><a id="23__283"></a>2.3 分代垃圾回收</h3> 
<p><img src="https://images2.imgbox.com/4f/f9/vZn8yOFC_o.png" alt="image-20231224155037939"></p> 
<ul><li>对象首先分配在伊甸园区</li><li>当新生代空间不足时，触发 minor gc，伊甸园和 from 区域存货的对象复制到 to 区域，存活的对象年龄加 1 ，并交换 from 和 to 两个区域</li><li>minor gc 会引发 stop the world ，暂停其他用户线程，等待垃圾回收结束，用户线程才恢复运行</li><li>对象年龄的寿命超过阈值 15 时，会晋升到老年代</li><li>当老年代空间不足时，会首先触发 minor gc，如果之后空间仍然不足，就会触发 full gc，STW 的时间更长</li></ul> 
<hr> 
<p>对于大对象，新生代无法存入，就会直接存入老年代</p> 
<p>如果大对象老年代都无法存下，就会抛出内存溢出的异常</p> 
<p>多线程下运行，一个线程的内存溢出不会影响其他线程中断</p> 
<h4><a id="231__VM__301"></a>2.3.1 相关 VM 参数</h4> 
<p><code>-Xms</code> ：堆初始大小</p> 
<p><code>-Xmx</code> 或 <code> -XX:MaxHeapSize=size</code> ：堆最大大小</p> 
<p><code>-Xmn</code> 或 <code>-XX:NewSize=size + -XX:MaxNewSize=size</code> 新生代大小</p> 
<p><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code>：幸存区比例（动态）</p> 
<p><code>-XX:SurvivorRatio=ratio</code> 幸存区比例</p> 
<p><code>-XX:MaxTenuringThreshold=threshold</code> 晋升阈值</p> 
<p><code>-XX:+PrintTenuringDistribution</code> 晋升详情</p> 
<p><code>-XX:+PrintGCDetails -verbose:gc</code> GC详情</p> 
<p><code>-XX:+ScavengeBeforeFullGC</code> FullGC 前 MinorGC</p> 
<h3><a id="24__321"></a>2.4 垃圾回收器</h3> 
<ol><li> <p>串行</p> 
  <ul><li>单线程的垃圾回收期，回收时，其他线程暂停</li><li>适合个人电脑，其堆内存较小，CPU个数少的</li><li>吞吐量优先</li></ul> </li><li> <p>多线程运行</p> 
  <ul><li>堆内存较大，多核 CPU 支持（如果不是多核，就需要争抢时间片）</li><li>让单位时间内，STW 的时间最短 
    <ul><li>垃圾回收时间占比少：0.2 0.2 = 0.4</li></ul> </li></ul> </li><li> <p>响应时间优先</p> 
  <ul><li>多线程运行</li><li>堆内存较大，多核 CPU 支持</li><li>尽可能让单次的 STW 的时间最短 
    <ul><li>每次0.1，回收多次：0.1 0.1 0.1 0.1 0.1 = 0.5</li></ul> </li></ul> </li></ol> 
<h4><a id="241__338"></a>2.4.1 串行</h4> 
<p>VM 参数：<code>-XX:+UseSerialGC=Serial+SerialOld</code></p> 
<p>Serial : 工作在新生代，回收算法是复制算法</p> 
<p>SerialOld：工作在老年代，回收算法是标记整理算法</p> 
<p><img src="https://images2.imgbox.com/9d/71/rgwrDj2O_o.png" alt="image-20231224162304198"></p> 
<p>所有线程在安全点前阻塞，单线程的垃圾回收器运行；因为可能会更改对象地址，所以线程需要阻塞（STW）</p> 
<h4><a id="242__350"></a>2.4.2 吞吐量优先</h4> 
<p><code>-XX:+UseParallelGC</code> ：新生代采用复制算法</p> 
<p><code>-XX:+UseParallelOldGC</code> ：老年代采用标记整理了算法</p> 
<p><code>Paralle</code> 表示回收器是并行的</p> 
<p><img src="https://images2.imgbox.com/b7/95/R3FbnPjb_o.png" alt="image-20231224163318445"></p> 
<p>垃圾回收器的线程数默认是和CPU的核数相同的。</p> 
<p><code>-XX:+UseAdaptiveSizePolicy</code> ：自动调整垃圾回收的参数，例如eden，from，to，晋升阈值的大小</p> 
<p><code>-XX:GCTimeRation=ratio</code>：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
         / 
        
       
         ( 
        
       
         1 
        
       
         + 
        
       
         r 
        
       
         a 
        
       
         t 
        
       
         i 
        
       
         o 
        
       
         ) 
        
       
      
        1/(1+ratio) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1/</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mclose">)</span></span></span></span></span> ，ratio 默认99，垃圾回收的时间占比为1%；但是难以达到，一般设置19；调整垃圾回收时间与总时间的占比，用于调整吞吐量</p> 
<p><code>-XX:MaxGCPauseMillis=ms</code> ：默认为 200 ms；用于调整每次垃圾回收的暂停时间</p> 
<h4><a id="243__CMS_368"></a>2.4.3 响应时间优先 CMS</h4> 
<p><code>-XX:+UseConcMarkSweepGC</code> ：<strong>并发</strong>标记清除回收器，用于老年代；</p> 
<p><code>-XX:+UseParNewGC</code>：新生代的复制算法</p> 
<p>如果并发出现问题，例如标记清除算法会产生很多内存碎片就会并发失败，老年代的垃圾回收器就会退化成 <code>SerialOld</code> 的复制串行回收器</p> 
<p><img src="https://images2.imgbox.com/4a/9b/2WJO3U2y_o.png" alt="image-20231224164421464"></p> 
<p>老年代空间不足，达到运行点，进行初始标记，对那些根对象进行遍历</p> 
<p>随后进行并发标记遍历其他对象，与此同时其他线程继续运行</p> 
<p>当进行重新标记时，需要STW， 随后进行重新标记</p> 
<p><code>ParallelGCThreads=n</code> <code> -XX:ConcGCThreads=threads</code> ：可以设置并发标记线程数量；清理垃圾的同时，可能会产生新垃圾，得等到下次垃圾回收时才能释放，称为浮动垃圾。所以需要为这些浮动垃圾预留空间。</p> 
<p><code>-XX:CMSInitiatingOccupancyFraction=percent</code> ：执行垃圾回收时的内存占比</p> 
<p><code>-XX:+CMSScavengeBeforeRemark</code> ：重新标记时，可能新生代的对象引用老年代的对象，就需要扫描整个堆进行可达性分析，而这些新生代的对象将来也是要被回收掉的，就导致做了无用的查找工作。这个参数可以在重新标记前，对新生代进行一次垃圾回收，这样新生代的对象就少了，查找的工作就少了</p> 
<h4><a id="244_G1_390"></a>2.4.4 G1</h4> 
<p>Garbage First 简称 G1 收集器。</p> 
<p>2017 JDK 9默认</p> 
<p>适用场景：</p> 
<ul><li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的 Region</li><li>整体上是标记+整理算法，两个区域之间是复制算法</li></ul> 
<p>相关 JVM 参数：</p> 
<ul><li><code>-XX:+UseG1GC</code></li><li><code>-XX:G1HeapRegionSize=size</code></li><li><code>-XX:MaxGCPauseMillis=time</code></li></ul> 
<h5><a id="1_408"></a>1）垃圾回收阶段</h5> 
<img src="https://images2.imgbox.com/f2/28/Sobu3AD3_o.png" alt="image-20231224170901118"> 
<h5><a id="2Young_Collection_412"></a>2）Young Collection</h5> 
<p><img src="https://images2.imgbox.com/77/c0/tyAE9G9I_o.png" alt="image-20231224170943839"></p> 
<p>新生代内存紧张后，就会将新生代的Eden区域的垃圾回收对象复制到幸存区 survivor</p> 
<p><img src="https://images2.imgbox.com/d9/9d/dA8DmdA2_o.png" alt="image-20231224171205359"></p> 
<p>当 survivor 区域的年龄超过晋升阈值就会复制到老年区 Old</p> 
<p><img src="https://images2.imgbox.com/5e/6d/jvjQOnR8_o.png" alt="image-20231224171215817"></p> 
<h5><a id="3_Young_Collection_CMconcurrent_Mark_424"></a>3) Young Collection +CM（concurrent Mark，并发标记）</h5> 
<ul><li> <p>在Young GC时会进行 GC Root的初始标记</p> </li><li> <p>老年代占用堆空间达到阈值时，进行并发标记（不会STW），由下面的 VM 参数决定</p> <p><code>-XX:InitiatingHeapOccupancyPercent=percent </code>（默认45%）</p> </li></ul> 
<p><img src="https://images2.imgbox.com/ff/70/KoaxY3Yu_o.png" alt="image-20231224171525523"></p> 
<h5><a id="4_434"></a>4）混合收集</h5> 
<p>对 E，S，O 进行全面垃圾回收</p> 
<ul><li>最后标记 (Remark) 会 STW。因为是并发的，其他线程可能产生新的垃圾，所以需要进行最后标记</li><li>拷贝存活 (Evacuation) 会 STW</li></ul> 
<p>Eden 中的对象会复制到 Survivor ，Surivior 区域年龄达到晋升阈值会复制到 Old</p> 
<p>Old 区域会根据设置的垃圾回收时间有选择的回收部分老年代的对象，挑选那些回收价值高的也就是<strong>能释放内存更多的对象</strong>进行回收。</p> 
<p>垃圾回收暂停时间设置：<code>-XX:MaxGCPauseMillis=ms</code></p> 
<p><img src="https://images2.imgbox.com/be/5f/XfkJBmnj_o.png" alt="image-20231224172217020"></p> 
<h5><a id="5Full_GC_449"></a>5）Full GC</h5> 
<ul><li>SerialGC<br> 新生代内存不足发生的垃圾收集 - minor gc<br> 老年代内存不足发生的垃圾收集 - full gc</li><li>ParallelGC<br> 新生代内存不足发生的垃圾收集 - minor gc<br> 老年代内存不足发生的垃圾收集 - full gc</li><li>CMS<br> 新生代内存不足发生的垃圾收集 - minor gc<br> 老年代内存不足</li><li>G1<br> 新生代内存不足发生的垃圾收集 - minor gc<br> 老年代内存不足</li></ul> 
<h5><a id="6_Young_Collection__464"></a>6) Young Collection 跨代引用</h5> 
<p>新生代回收的跨代引用（老年代引用新生代）问题</p> 
<p>新生代回收时需要查找有哪些 GC Root，再进行可达性分析和回收</p> 
<p>查找 GC Root 需要查找整个老年代花费时间多。</p> 
<p>可以把老年代区域分割成多个 card，如果这个 card 引用了新生代，那么这个 card 就是脏 card。</p> 
<p><img src="https://images2.imgbox.com/d8/90/R4GQTV7e_o.png" alt="image-20231225151030711"></p> 
<ul><li>老年代里有卡表，新生代里有 Remembered Set 记录有那些脏 card 引用自己 
  <ul><li>垃圾回收时就会通过 Remembered Set 找到脏card里的GC Root</li></ul> </li><li>在引用变更时通过 post-write barrier + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul> 
<p><img src="https://images2.imgbox.com/e0/52/5akbEhNY_o.png" alt="image-20231225151153020"></p> 
<h5><a id="7_Remark_483"></a>7) Remark</h5> 
<p>pre-write barrier + satb_mark_queue</p> 
<p><img src="https://images2.imgbox.com/d1/df/wkYKHDVe_o.png" alt="image-20231225151551342"></p> 
<p>C的引用发生改变则会添加写屏障，并放入队列，将来的Remark阶段就会通过队列对C对象进行处理决定是否垃圾回收</p> 
<p><img src="https://images2.imgbox.com/9f/45/25gs0Cvv_o.png" alt="image-20231225151849670"></p> 
<h5><a id="8JDK_8u20__493"></a>8）JDK 8u20 字符串去重</h5> 
<ul><li> <p>优点：节省大量内存</p> </li><li> <p>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</p> <p>开启这个开关（默认打开）：<code>-XX:+UseStringDeduplication</code></p> </li></ul> 
<pre><code class="prism language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// char[]{'h','e','l','l','o'}</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// char[]{'h','e','l','l','o'}</span>
</code></pre> 
<ul><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1并发检查是否有字符串重复</li><li>如果它们值一样，让它们引用同一个 char[]</li><li>注意，与 String.intern() 不一样 
  <ul><li>String.intern() 关注的是字符串对象</li><li>而字符串去重关注的是 char[]</li><li>在 JVM 内部，使用了不同的字符串表</li></ul> </li></ul> 
<h5><a id="9_JDK_8u40__514"></a>9) JDK 8u40 并发标记类卸载</h5> 
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类<br> <code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认启用</p> 
<h5><a id="10JDK_8u60__519"></a>10）JDK 8u60 回收巨型对象</h5> 
<ul><li>一个对象大于 region 的一半时，称之为巨型对象</li><li><strong>G1 不会对巨型对象进行拷贝</strong></li><li><strong>回收时被优先考虑</strong></li><li>G1 会跟<strong>踪老年代所有 incoming 引用</strong>，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li></ul> 
<p><img src="https://images2.imgbox.com/a4/f2/1W9QyzO4_o.png" alt="image-20231225152524545"></p> 
<p><img src="https://images2.imgbox.com/06/e3/KrjT2tsF_o.png" alt="image-20231225152704858"></p> 
<h5><a id="11JDK_9__530"></a>11）JDK 9 并发标记起始时间的调整</h5> 
<ul><li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li><li>JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code></li><li>JDK 9 可以动态调整 
  <ul><li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空档空间</li></ul> </li></ul> 
<h3><a id="25__539"></a>2.5 垃圾回收调优</h3> 
<h4><a id="251__541"></a>2.5.1 调优领域</h4> 
<ul><li>内存</li><li>锁竞争</li><li>CPU 占用</li><li>IO 占用</li></ul> 
<h4><a id="252__548"></a>2.5.2 确定目标</h4> 
<ul><li> <p>低延迟还是高吞吐量，选择合适的回收器</p> </li><li> <p>响应时间优先：CMS，G1，ZGC</p> </li><li> <p>吞吐量优先：ParallelGC</p> </li></ul> 
<h4><a id="253__GC__GC_556"></a>2.5.3 最快的 GC 是不 GC</h4> 
<ul><li>查看 FullGC 前后的内存占用，考虑下面的问题： 
  <ul><li>数据是不是太多？ 
    <ul><li>resultSet = statement.executeQuery(“select *from large_table”) 查出的数据太多，可以加个 <code> limit n</code> 限制一下查出数据的数量</li></ul> </li><li>数据表示是否太臃肿？ 
    <ul><li>对象图，只查出只用的数据，例如查找年龄，不要也把姓名其他信息查出来</li><li>对象大小设置，一个Object 最小占16字节，包装类型占24字节，基本类型int只占4字节</li></ul> </li><li>是否存在内存泄漏？ 
    <ul><li>创建一个static Map map = xxx，长时间存货对象</li><li>可以用软引用，弱引用，进行回收</li><li>使用第三方缓存实现</li></ul> </li></ul> </li></ul> 
<h4><a id="254__569"></a>2.5.4 新生代调优</h4> 
<p>新生代特点：</p> 
<ul><li>所有的 new 操作的内存分配非常廉价 
  <ul><li>首先会分配在TLAB中（thread-local allocation buffer）</li></ul> </li><li>死亡对象的回收代价是零</li><li>大部分对象用过即死</li><li>Minor GC 的时间远远低于 Full GC</li></ul> 
<p>新生代内存是否越大越好？</p> 
<p><code>-Xmn</code> ：设置新生代内存的vm命令<br> Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p> 
<ul><li> <p>新生代能容纳所有【并发量 * (请求-响应)】的数据</p> </li><li> <p>幸存区大到能保留【当前活跃对象+需要晋升对象】</p> </li><li> <p>晋升阈值配置得当，让长时间存活对象尽快晋升</p> <p>-XX:MaxTenuringThreshold=threshold<br> -XX:+PrintTenuringDistribution</p> </li></ul> 
<h4><a id="255__593"></a>2.5.5 老年代调优</h4> 
<p>以 CMS 为例，具有浮动垃圾的问题，如果浮动垃圾存不下就会并发失败退化为Serial</p> 
<ul><li>CMS 的老年代内存越大越好</li><li>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代</li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3 
  <ul><li><code>-XX:CMSInitiatingOccupancyFraction=percent</code></li></ul> </li></ul> 
<h4><a id="256__602"></a>2.5.6 案例</h4> 
<ul><li>案例1 Full GC 和 Minor GC频繁 
  <ul><li>新生代内存太小，创建的对象生成周期短，但因新生代内存下而晋升到老年代</li><li>可以调大新生代内存，同时调大晋升阈值</li></ul> </li><li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS） 
  <ul><li>重新标记时会扫描所有对象，耗时太多</li><li>设置<code>-XX:+CMSScavengeBeforeRemark</code> ：重新标记前回收一遍新生代的垃圾</li></ul> </li><li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7） 
  <ul><li>1.7 永久代内存空间不足也会导致Full GC</li><li>1.7 方法区存放在永久代，可以增大方法区的内存</li></ul> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1fa49b7d5939cdf420149e520454f63/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【mysql】—— 表的内连和外连</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5860d2f38a48ebf4bb75e8569e40853d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML5-新增语义相关标签</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>