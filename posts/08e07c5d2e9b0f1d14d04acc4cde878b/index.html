<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Ping命令的作用和参数说明 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Ping命令的作用和参数说明" />
<meta property="og:description" content="TTL是IP协议包中的一个值，它告诉网络路由器包在网络中的时间是否太长而应被丢弃。有很多原因使包在一定时间内不能被传递到目的地。例如，不正确的路由表可能导致包的无限循环。所以需要在包中设置这样一个值，包在每经过一个节点，将这个值减1，反复这样操作，最终可能造成两个结果：包在这个值还为正数的时候到达了目的地，或者是在经过一定数量的节点后，这个值减为了0。前者代表完成了一次正常的传输，后者代表包可能选择了一条非常长的路径甚至是进入了环路，这显然不是我们期望的，所以在这个值为0的时候，网络设备将不会再传递这个包而是直接将他抛弃，并发送一个通知给包的源地址，说这个包已死。 第二个问题，通过TTL值我们能得到什么 其实TTL值这个东西本身并代表不了什么，对于使用者来说，关心的问题应该是包是否到达了目的地而不是经过了几个节点后到达。但是TTL值还是可以得到有意思的信息的。 每个操作系统对TTL值得定义都不同，这个值甚至可以通过修改某些系统的网络参数来修改，例如Win2000默认为128，通过注册表也可以修改。而Linux大多定义为64。不过一般来说，很少有人会去修改自己机器的这个值的，这就给了我们机会可以通过ping的回显TTL来大体判断一台机器是什么操作系统。如你看到112，可能是初始128，跳了16个节点，或者是初始160，跳了48次。 不同的操作系统，它的TTL值默认值是不相同的。默认情况下，Linux系统的TTL值为64或255，Windows NT/2000/XP系统的TTL值为128，Windows 98系统的TTL值为32，UNIX主机的TTL值为255。 以我公司2台机器为例 看如下命令 ping 61.152.93.131 Pinging 61.152.93.131 with 32 bytes of data: Reply from 61.152.93.131: bytes=32 time=21ms TTL=118 Reply from 61.152.93.131: bytes=32 time=19ms TTL=118 Reply from 61.152.93.131: bytes=32 time=18ms TTL=118 Reply from 61.152.93.131: bytes=32 time=22ms TTL=118 Ping statistics for 61.152.93.131: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss Approximate round trip times in milli-seconds: Minimum = 18ms, Maximum = 22ms, Average = 20ms ping 61." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/08e07c5d2e9b0f1d14d04acc4cde878b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T01:42:01+08:00" />
<meta property="article:modified_time" content="2019-07-03T01:42:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Ping命令的作用和参数说明</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body">
  TTL是IP协议包中的一个值，它告诉网络路由器包在网络中的时间是否太长而应被丢弃。有很多原因使包在一定时间内不能被传递到目的地。例如，不正确的路由表可能导致包的无限循环。所以需要在包中设置这样一个值，包在每经过一个节点，将这个值减1，反复这样操作，最终可能造成两个结果：包在这个值还为正数的时候到达了目的地，或者是在经过一定数量的节点后，这个值减为了0。前者代表完成了一次正常的传输，后者代表包可能选择了一条非常长的路径甚至是进入了环路，这显然不是我们期望的，所以在这个值为0的时候，网络设备将不会再传递这个包而是直接将他抛弃，并发送一个通知给包的源地址，说这个包已死。 第二个问题，通过TTL值我们能得到什么 其实TTL值这个东西本身并代表不了什么，对于使用者来说，关心的问题应该是包是否到达了目的地而不是经过了几个节点后到达。但是TTL值还是可以得到有意思的信息的。 每个操作系统对TTL值得定义都不同，这个值甚至可以通过修改某些系统的网络参数来修改，例如Win2000默认为128，通过注册表也可以修改。而Linux大多定义为64。不过一般来说，很少有人会去修改自己机器的这个值的，这就给了我们机会可以通过ping的回显TTL来大体判断一台机器是什么操作系统。如你看到112，可能是初始128，跳了16个节点，或者是初始160，跳了48次。 
 <br> 不同的操作系统，它的TTL值默认值是不相同的。默认情况下，Linux系统的TTL值为64或255，Windows NT/2000/XP系统的TTL值为128，Windows 98系统的TTL值为32，UNIX主机的TTL值为255。 
 <br> 
 <br> 以我公司2台机器为例 看如下命令 ping 61.152.93.131 
 <br> 
 <br> Pinging 61.152.93.131 with 32 bytes of data: 
 <br> Reply from 61.152.93.131: bytes=32 time=21ms TTL=118 
 <br> Reply from 61.152.93.131: bytes=32 time=19ms TTL=118 
 <br> Reply from 61.152.93.131: bytes=32 time=18ms TTL=118 
 <br> Reply from 61.152.93.131: bytes=32 time=22ms TTL=118 
 <br> Ping statistics for 61.152.93.131: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss 
 <br> Approximate round trip times in milli-seconds: 
 <br> Minimum = 18ms, Maximum = 22ms, Average = 20ms 
 <br> 
 <br> ping 61.152.104.40 Pinging 61.152.104.40 with 32 bytes of data: 
 <br> Reply from 61.152.104.40: bytes=32 time=28ms TTL=54 
 <br> Reply from 61.152.104.40: bytes=32 time=18ms TTL=54 
 <br> Reply from 61.152.104.40: bytes=32 time=18ms TTL=54 
 <br> Reply from 61.152.104.40: bytes=32 time=13ms TTL=54 
 <br> Ping statistics for 61.152.104.40: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss 
 <br> Approximate round trip times in milli-seconds: 
 <br> Minimum = 13ms, Maximum = 28ms, Average = 19ms 
 <br> 第一台TTL为118，则基本可以判断这是一台Windows机器，从我的机器到这台机器经过了10个节点，因为128-118=10。而第二台应该是台Linux，理由一样64-54=10。 了解了上面的东西，可能有人会有一些疑问，例如以下： 1，不是说包可能走很多路径吗，为什么我看到的4个包TTL都是一样的，没有出现不同？ 这是由于包经过的路径是经过了一些最优选择算法来定下来的，在网络拓扑稳定一段时间后，包的路由路径也会相对稳定在一个最短路径上。具体怎么算出来的要去研究路由算法了，不在讨论之列。 2，对于上面例子第二台机器，为什么不认为它是经过了74个节点的Windows机器？因为128-74=54。 对于这个问题，我们要引入另外一个很好的ICMP协议工具。不过首先要声明的是，一个包经过74个节点这个有些恐怖，这样的路径还是不用为好。 要介绍的这个工具是tracert（*nix下为traceroute），让我们来看对上面的第二台机器用这个命令的结果 tracert 61.152.104.40 
 <br> Tracing route to 61.152.104.40 over a maximum of 30 hops 
 <br> 1 13 ms 16 ms 9 ms 10.120.32.1 
 <br> 2 9 ms 9 ms 11 ms 219.233.244.105 
 <br> 3 12 ms 10 ms 10 ms 219.233.238.173 
 <br> 4 15 ms 15 ms 17 ms 219.233.238.13 
 <br> 5 14 ms 19 ms 19 ms 202.96.222.73 
 <br> 6 14 ms 17 ms 13 ms 202.96.222.121 
 <br> 7 14 ms 15 ms 14 ms 61.152.81.86 
 <br> 8 15 ms 14 ms 13 ms 61.152.87.162 
 <br> 9 16 ms 16 ms 28 ms 61.152.99.26 
 <br> 10 12 ms 13 ms 18 ms 61.152.99.94 
 <br> 11 14 ms 18 ms 16 ms 61.152.104.40 
 <br> Trace complete. 
 <br> 从这个命令的结果能够看到从我的机器到服务器所走的路由，确实是11个节点（上面说10个好像是我犯了忘了算0的错误了，应该是64-54+1，嘿嘿），而不是128的TTL经过了70多个节点。 既然已经说到这里了，不妨顺便说说关于这两个ICMP命令的高级一点的东西。 首先是ping命令，其实ping有这样一个参数，可以无视操作系统默认TTL值而使用自己定义的值来发送ICMP Request包。 例如还是用那台Linux机器，用以下命令： ping 61.152.104.40 -i 11 
 <br> Pinging 61.152.104.40 with 32 bytes of data: 
 <br> Reply from 61.152.104.40: bytes=32 time=10ms TTL=54 
 <br> Reply from 61.152.104.40: bytes=32 time=13ms TTL=54 
 <br> Reply from 61.152.104.40: bytes=32 time=10ms TTL=54 
 <br> Reply from 61.152.104.40: bytes=32 time=13ms TTL=54 
 <br> Ping statistics for 61.152.104.40: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss), 
 <br> Approximate round trip times in milli-seconds: 
 <br> Minimum = 10ms, Maximum = 13ms, Average = 11ms 
 <br> 这个命令我们定义了发包的TTL为11，而前面我们知道，我到这台服务器是要经过11个节点的，所以这个输出和以前没什么不同。现在再用这个试试看： ping 61.152.104.40 -i 10 
 <br> Pinging 61.152.104.40 with 32 bytes of data: 
 <br> Reply from 61.152.99.94: TTL expired in transit. 
 <br> Reply from 61.152.99.94: TTL expired in transit. 
 <br> Reply from 61.152.99.94: TTL expired in transit. 
 <br> Reply from 61.152.99.94: TTL expired in transit. 
 <br> Ping statistics for 61.152.104.40: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss), 
 <br> Approximate round trip times in milli-seconds: 
 <br> Minimum = 0ms, Maximum = 0ms, Average = 0ms 
 <br> 可以看到，结果不一样了，我定义了TTL为10来发包，结果是TTL expired in transit.就是说在到达服务器之前这个包的生命周期就结束了。注意看这句话前面的ip，这个ip恰好是我们前面tracert结果到服务器之前的最后1个ip，包的TTL就是在这里减少到0了，根据我们前面的讨论，当TTL减为0时设备会丢弃包并发送一个TTL过期的ICMP反馈给源地址，这里的结果就是最好的证明。 通过这里再次又证明了从我机器到服务器是经过了11个节点而不是70多个，呵呵。 最后再巩固一下知识，有人可能觉得tracer这个命令很神奇，可以发现一个包所经过的路由路径。其实这个命令的原理就在我们上面的讨论中。 想象一下，如果我给目的服务器发送一个TTL为1的包，结果会怎样？ 根据前面的讨论，在包港出发的第一个节点，TTL就会减少为0，这时这个节点就会回应TTL失效的反馈，这个回应包含了设备本身的ip地址，这样我们就得到了路由路径的第一个节点的地址。 因此，我们继续发送TTL=2的包，也就受到第二个节点的TTL失效回应 依次类推，我们一个一个的发现，当最终返回的结果不是TTL失效而是ICMP Response的时候，我们的tracert也就结束了，就是这么简单。 顺便补一句ping命令还有个-n的参数指定要发包的数量，指定了这个数字就会按照你的要求来发包了而不是默认的4个包。如果使用-t参数的话，命令会一直发包直到你强行中止它。 
 <br> 参考资料： 
 <a href="http://www.da66.com/articleview/2006-4-20/article_view_234.htm#top" rel="nofollow">http://www.da66.com/articleview/2006-4-20/article_view_234.htm#top</a> 
</div> 
<p>转载于:https://www.cnblogs.com/wyxy2005/archive/2009/02/12/1388757.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d30ebecedc723aee86be3143bbd4c7d7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">懒人笔记-memcache配置(php)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9321566d8f60aec6843a02ed9de79e29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何获得Oracle系统性能统计？ Oracle大型数据库系统在AIXUNIX上的实战详解 集中讨论 14...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>