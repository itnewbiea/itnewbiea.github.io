<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用遗传算法进行特征选择 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用遗传算法进行特征选择" />
<meta property="og:description" content="文章目录 一、问题举例二、算法描述1、基于类内类间距离的可分性判据2、遗传算法（Genetic Algorithm）1) 初始化种群2）计算当前种群 M（t）中每条染色体的适应度值 f（m）3）基于适应度值的选择4）交叉5）变异6）重复迭代 3、顺序前进法和顺序后退法 三、结果1、在 sonar 数据集上验证遗传算法2、在 Iris 数据集上验证遗传算法3、顺序前进法和顺序后退法5、对比算法：顺序前进法和顺序后退法 四、总结五、代码 一、问题举例 要求：在Sonar和Iris数据集上进行验证遗传算法特征选择性能 对比算法：顺序前进法和顺序后退法 特征选择由类别可分性判据&#43;搜索算法实现 二、算法描述 1、基于类内类间距离的可分性判据 要进行特征选择，首先要确定选择的准则，也就是如何评价选出的一组特征。确定了评价准则后，特征选择问题就变成从D个特征中选出使准则函数最优的d个特征（d &lt; D）。
Fisher线性判别采用了使样本投影到一维后类内离散度尽可能小，类间离散度尽可能大的准则来确定最佳的投影方向，这其实就是一个直观的类别可分性判据。可以用两类中的任意两两样本之间的距离的平均来代表两个类之间的距离，现在可以将其推导到多类情况。
令 x_k^((i)), x_l^((j)) 分别为 ω_i 类及 ω_i 类中的D维特征向量，δ(x_k((i))&#43;x_l((j)) ) 为这两个向量间的距离，则各类特征向量之间的平均距离为
式中c为类别数，ni为 ωi类中的样本数，nj为 ωj类中的样本数，Pi 、Pj是相应类别的先验概率。
多维空间中两个向量之间有很多种距离度量，在欧式距离情况下有
用 m_i表示第i类样本集的均值向量
用 ??表示所有各类的样本集的总平均向量
将上述式子代入到平均距离的公式得
也可以用下面定义的矩阵写出 Jd(x)的表达式,令
因为要保证类间离散度尽可能大，类内离散度尽可能小，故定义以下距离判据
基于距离的可分性判据定义直观、易于实现，因此比较常用。没有直接考虑 样本的分布情况，很难在理论上建立起它们与分类错误率的联系，而且当两类样 本的分布有重叠时，这些判据不能反映重叠的情况。为了简化计算，采用基于类 内类间距离的可分性判据，且根据公式可知，Jd（x）的值越大，表示特征的可分离性越好.
2、遗传算法（Genetic Algorithm） 遗传算法把候选对象编码为一条染色体（chromesome），在特征选择中，如 果目标是从 D 个特征中选择 d 个，则把所有特征描述为一条由 D 个 0/1 字符组 成的字符串，0 代表该特征没有被选中，1 代表该特征被选中，这个字符串就叫 做染色体，记作 m。显然，要求的是一条有且仅有 d 个 1 的染色体，这样的染色 体共有 ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e276d6118d91506814fcafebc25702c8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-20T21:57:27+08:00" />
<meta property="article:modified_time" content="2019-01-20T21:57:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用遗传算法进行特征选择</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、问题举例</a></li><li><a href="#_5" rel="nofollow">二、算法描述</a></li><li><ul><li><a href="#1_6" rel="nofollow">1、基于类内类间距离的可分性判据</a></li><li><a href="#2Genetic_Algorithm_25" rel="nofollow">2、遗传算法（Genetic Algorithm）</a></li><li><ul><li><a href="#1__28" rel="nofollow">1) 初始化种群</a></li><li><a href="#2_Mt_fm_33" rel="nofollow">2）计算当前种群 M（t）中每条染色体的适应度值 f（m）</a></li><li><a href="#3_36" rel="nofollow">3）基于适应度值的选择</a></li><li><a href="#4_41" rel="nofollow">4）交叉</a></li><li><a href="#5_45" rel="nofollow">5）变异</a></li><li><a href="#6_48" rel="nofollow">6）重复迭代</a></li></ul> 
   </li><li><a href="#3_50" rel="nofollow">3、顺序前进法和顺序后退法</a></li></ul> 
  </li><li><a href="#_53" rel="nofollow">三、结果</a></li><li><ul><li><a href="#1_sonar__54" rel="nofollow">1、在 sonar 数据集上验证遗传算法</a></li><li><a href="#2_Iris__66" rel="nofollow">2、在 Iris 数据集上验证遗传算法</a></li><li><a href="#3_68" rel="nofollow">3、顺序前进法和顺序后退法</a></li><li><a href="#5_72" rel="nofollow">5、对比算法：顺序前进法和顺序后退法</a></li></ul> 
  </li><li><a href="#_75" rel="nofollow">四、总结</a></li><li><a href="#_80" rel="nofollow">五、代码</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、问题举例</h2> 
<pre><code>要求：在Sonar和Iris数据集上进行验证遗传算法特征选择性能
对比算法：顺序前进法和顺序后退法
特征选择由类别可分性判据+搜索算法实现
</code></pre> 
<h2><a id="_5"></a>二、算法描述</h2> 
<h3><a id="1_6"></a>1、基于类内类间距离的可分性判据</h3> 
<p>  要进行特征选择，首先要确定选择的准则，也就是如何评价选出的一组特征。确定了评价准则后，特征选择问题就变成从D个特征中选出使准则函数最优的d个特征（d &lt; D）。<br>   Fisher线性判别采用了使样本投影到一维后类内离散度尽可能小，类间离散度尽可能大的准则来确定最佳的投影方向，这其实就是一个直观的类别可分性判据。可以用两类中的任意两两样本之间的距离的平均来代表两个类之间的距离，现在可以将其推导到多类情况。<br>   令 x_k^((i)), x_l^((j)) 分别为 ω_i 类及 ω_i 类中的D维特征向量，δ(x_k<sup>((i))+x_l</sup>((j)) ) 为这两个向量间的距离，则各类特征向量之间的平均距离为<br> <img src="https://images2.imgbox.com/64/b7/HzcvmhaC_o.png" alt="在这里插入图片描述"><br>   式中c为类别数，ni为 ωi类中的样本数，nj为 ωj类中的样本数，Pi 、Pj是相应类别的先验概率。<br>   多维空间中两个向量之间有很多种距离度量，在欧式距离情况下有</p> 
<p><img src="https://images2.imgbox.com/5c/89/9u8L2muc_o.png" alt="在这里插入图片描述"><br>   用 m_i表示第i类样本集的均值向量<br> <img src="https://images2.imgbox.com/3d/c1/LEFOQrxR_o.png" alt="在这里插入图片描述">  用 ??表示所有各类的样本集的总平均向量<br> <img src="https://images2.imgbox.com/c3/b5/kOwrUF4P_o.png" alt="在这里插入图片描述"><br>   将上述式子代入到平均距离的公式得<br> <img src="https://images2.imgbox.com/15/95/wlRZ71Hn_o.png" alt="在这里插入图片描述"><br>   也可以用下面定义的矩阵写出 Jd(x)的表达式,令<br> <img src="https://images2.imgbox.com/67/e2/SdbZC8tj_o.png" alt="在这里插入图片描述"><br>   因为要保证类间离散度尽可能大，类内离散度尽可能小，故定义以下距离判据<br> <img src="https://images2.imgbox.com/9d/c7/3xbK7ThK_o.png" alt="在这里插入图片描述" width="200" height="90"><br>   基于距离的可分性判据定义直观、易于实现，因此比较常用。没有直接考虑 样本的分布情况，很难在理论上建立起它们与分类错误率的联系，而且当两类样 本的分布有重叠时，这些判据不能反映重叠的情况。为了简化计算，采用基于类 内类间距离的可分性判据，且根据公式可知，Jd（x）的值越大，表示特征的可分离性越好.</p> 
<h3><a id="2Genetic_Algorithm_25"></a>2、遗传算法（Genetic Algorithm）</h3> 
<p>   遗传算法把候选对象编码为一条染色体（chromesome），在特征选择中，如 果目标是从 D 个特征中选择 d 个，则把所有特征描述为一条由 D 个 0/1 字符组 成的字符串，0 代表该特征没有被选中，1 代表该特征被选中，这个字符串就叫 做染色体，记作 m。显然，要求的是一条有且仅有 d 个 1 的染色体，这样的染色 体共有 ?? ?种。 优化的目标被描述成适应度（fitness）函数，每一条染色体对应一个适应 度值 f（m）。可以用前面定义的基于类内类间距离的类别可分性判据 Jd（x）作 为适应度。<br>    <strong>遗传算法具体步骤如下</strong></p> 
<h4><a id="1__28"></a>1) 初始化种群</h4> 
<p>   以 sonar 数据集为例，一条染色体为一个 1*60 维的行向量，假设我们要从 60 个特征中选 30 个特征，则初始化的一个染色体为将一个零向量的随机 30 位 变成 1，这样就从 60 维特征中随机选了 30 维，如下所示<br> <img src="https://images2.imgbox.com/67/91/44lnG7wf_o.png" alt="在这里插入图片描述"></p> 
<p>   重复上述过程 n 次，则可以得到一个有 n 条染色体的初代种群 M（0），每条 染色体都不尽相同。</p> 
<h4><a id="2_Mt_fm_33"></a>2）计算当前种群 M（t）中每条染色体的适应度值 f（m）</h4> 
<p>   将每一条染色体的适应度值（fitness）求出，即将每一条染色体所代表的 d 维特征选出，将原 Sonar 数据集变成一个 208*d 维的矩阵，计算出基于类内类 间距离的可分性判据 Jd（x），作为该染色体的适应度值 f（m）。<br>    <strong>经过 n 次计算之后，可以得到每条染色体的适应度值。</strong></p> 
<h4><a id="3_36"></a>3）基于适应度值的选择</h4> 
<p>   按照选择概率 p(f(m))对种群中的染色体进行采样，由采样出的染色体经过 一定的操作繁殖出下一代染色体，组成下一代的种群 M（t+1）。<br>    将种群中每条染色体的适应度值逐个累加，得到一些从 0 到 1 的区间，如图所示<br> <img src="https://images2.imgbox.com/ad/bb/yKQ8d2uK_o.png" alt="在这里插入图片描述"><br>    假设一个种群有 4 个条染色体，每条染色体的适应度值为 0.14、0.49、0.06、 0.31，则将这些适应度值逐个累加起来，得到四个区间（0，0.14）、（0.14，0.63）、 （0.63，0.69）、（ 0.69，1），每个区间的长度所代表着对应染色体的适应度值。 我们从 0 到 1 中取一个随机数，该数落在哪个区间，就取哪条染色体。重复 n 次， 得到了基于上一代种群适应度值的新子代种群 M（t+1）， 而且保证了种群的染色 体数目不改变，恒为 n。</p> 
<h4><a id="4_41"></a>4）交叉</h4> 
<p>  首先将一个种群平均分成两部分，称为两个父代种群，将这两个父代种群随 机打乱，再从两个父代中分别取一个染色体进行交叉，这样就完成了一次随机匹 配的过程。<br>    为了使交叉之后的染色体特征维数不变，采用了如下方法：<br>    先从一个父代染色体中随机选取一个片段（长度为 k），统计该片段中有几 个为 1 的基因，再从与之匹配的父代染色体中寻找长度相同、1 基因数目相同的片段，若找到，则进行交叉操作；若未找到，则寻找下一对父代染色体，直到将 所有父代种群遍历完毕。</p> 
<h4><a id="5_45"></a>5）变异</h4> 
<p>   基因突变是染色体的某一个位点上基因的改变。同样地，为了使变异之后染 色体中特征数量不变，采用了以下方法：<br>    先按一定的概率（称为变异概率）选择是否进行变异操作，若是，则随机从 种群中选择一个个体，再随机地选择一个基因进行反转，若该基因由 1 变为了0， 则再随机选一个 0 变成 1，反之也执行同样的操作。直至遍历完种群中所有的个 体。这样就能保证每个染色体的特征个数不会被改变。</p> 
<h4><a id="6_48"></a>6）重复迭代</h4> 
<p>   在进行完选择、交叉、和变异操作之后，上一代的种群 M（t）已经变成了新 一代的种群 M（t+1）。重复过程（2），在遗传算法迭代的过程中，种群中的染色 体会趋于所选特征数中的最优解，达到一定的迭代次数 t 后，算法停止，输出最 终种群中适应度值最大的染色体，即完成了在 D 维特征中选择 d 个最优的特征。</p> 
<h3><a id="3_50"></a>3、顺序前进法和顺序后退法</h3> 
<p>   顺序前进法是一种<strong>自底向上</strong>的方法。第一个特征选择单独最优的特征，第二 个特征从其余所有特征中选择与第一个特征组合在一起后准则最优的特征，后面 的每一个特征都选择与已经入选的特征组合起来最优的特征。<br>    顺序后退法是一种<strong>从顶向下</strong>的方法，与顺序前进法相对应。从所有特征逐一 剔除不被选中的特征。每次剔除的特征都是使得剩余的特征的准则函数值最优的 特征。</p> 
<h2><a id="_53"></a>三、结果</h2> 
<h3><a id="1_sonar__54"></a>1、在 sonar 数据集上验证遗传算法</h3> 
<p>   首先看在取 30 维特征的时候，随着遗传算法的迭代，每一代种群的适应度 值收敛情况<br> <img src="https://images2.imgbox.com/08/eb/PWdQsbVj_o.png" alt="在这里插入图片描述"><br>    从图中可以很明显地看出，随着遗传算法迭代次数的增加，每一代种群的适 应度值在逐渐变大。当迭代次数达到 60 次的时候，种群中的最大适应度值趋于 最大，在之后收敛与 0.07 左右.<br>    经过遗传算法迭代 150 次求得的最优种群如下图<br> <img src="https://images2.imgbox.com/f4/60/W8w9zlr6_o.png" alt="在这里插入图片描述"><br>    图中红色代表 0，蓝色代表 1，横坐标表示特征，纵坐标表示每个染色体。 图中只显示了一部分。可以看见，在迭代后，每个个体所选择的特征趋于一致。<br>    所选出的适应度值最优的染色体和特征为<br> <img src="https://images2.imgbox.com/8f/bc/jYf9vsig_o.png" alt="在这里插入图片描述"><br>    现在扩展到选择其他个数的特征的情况，将 d 从 1 取到 60，每个 d 都对应 着一个最优适应度值，现横向将其比较<br> <img src="https://images2.imgbox.com/ad/63/vaWi8cnR_o.png" alt="在这里插入图片描述"><br>    从图中可以看出，用遗传算法从 60 维中取 1 到 5 维的时候得出的最优染色 体适应度值最大，在 20 维之后适应度值呈现平稳下降的趋势，最终收敛于 0.03 左右。</p> 
<h3><a id="2_Iris__66"></a>2、在 Iris 数据集上验证遗传算法</h3> 
<p>  由于 Iris 数据集的特征只有 4 维，特征选择的情况较简单,这里不再赘述。</p> 
<h3><a id="3_68"></a>3、顺序前进法和顺序后退法</h3> 
<p>  以 Sonar 数据集为例，验证从 60 维中选择 30 维特征的选择情况。<br> <img src="https://images2.imgbox.com/f6/8a/KHMcehFH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/54/88/ARUO9qQl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5_72"></a>5、对比算法：顺序前进法和顺序后退法</h3> 
<p>   以 Sonar 数据集为例，从 60 维特征中取 1 到 10 维，分别看遗传算法、顺序 前进法、顺序后退法的每一维最优适应度值<br> <img src="https://images2.imgbox.com/b5/10/ClH1Iqjq_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_75"></a>四、总结</h2> 
<p>  1、遗传算法作为一种解决最优化的一种搜索启发式算法，是进化算法的一 种，在选择特征方面具有显著效果。随着遗传算法迭代次数的增加，每一代种群 的适应度值逐渐收敛于局部最优解，从而能够找到所选择的最优特征。<br>    2、顺序前进法与单独最优特征的选择方法相比，考虑了一定的特征间组合 的因素，但是其第一个特征仍是仅靠单个特征的准则来选择的，而且每个特征一旦入选 后就无法再剔除，即使它与后面选择的特征并不是最优的组合。<br>   3、顺序后退法也考虑了特征间的组合，但是由于是自顶向下的方法，很多 进行高维空间进行，计算量比顺序前进法大些。而且顺序后退法在一旦剔除了某 一特征后就无法再把它选入。<br>   4、通过上图的对比可以看出，遗传算法和顺序前进法选出的最优染色体的 适应度值受维数影响较大，但遗传算法的适应度值要大于顺序前进法。顺序后退 法选出的最优染色体的适应度值不但不受维数影响，而且都要大于遗传算法。得 出的结果为：顺序后退法&gt;遗传算法&gt;顺序前进法。</p> 
<h2><a id="_80"></a>五、代码</h2> 
<p>实验环境Python3.6<br> GitHub地址如下<br> Pattern recognition / GA<br> <a href="https://github.com/Fangzhenxuan/AI_Projects.git">https://github.com/Fangzhenxuan/AI_Projects.git</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43171dd714d76c6ddd451b04994622fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">void SysTick_Handler(void)系统滴答时钟中断函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43cf715941ec313f1309004ec0e30779/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Electron&#43;Vue 小清新代码笔记工具，确定不来尝试一下嘛？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>