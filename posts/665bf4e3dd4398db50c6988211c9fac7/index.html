<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue3 源码之生命周期钩子 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue3 源码之生命周期钩子" />
<meta property="og:description" content="生命周期钩子对应的生命周期Option如下:
beforeCreate -&gt; 使用 setup() created -&gt; 使用 use setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy-&gt; onBeforeUnmount destroyed -&gt; onUnmounted activated -&gt; onActivated deactivated -&gt; onDeactivated errorCaptured -&gt; onErrorCaptured 除此之外, 还新增了两个用于调试的生命周期:
onRenderTrackedonRenderTriggered 注册钩子函数 export const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT) export const onMounted = createHook(LifecycleHooks.MOUNTED) export const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE) export const onUpdated = createHook(LifecycleHooks.UPDATED) export const onBeforeUnmount = createHook(LifecycleHooks.BEFORE_UNMOUNT) export const onUnmounted = createHook(LifecycleHooks." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/665bf4e3dd4398db50c6988211c9fac7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-23T16:34:15+08:00" />
<meta property="article:modified_time" content="2021-04-23T16:34:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue3 源码之生命周期钩子</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>生命周期钩子对应的生命周期Option如下:</p> 
<pre><code>beforeCreate -&gt; 使用 setup() 
created -&gt; 使用 use setup() 
beforeMount -&gt; onBeforeMount 
mounted -&gt; onMounted 
beforeUpdate -&gt; onBeforeUpdate 
updated -&gt; onUpdated 
beforeDestroy-&gt; onBeforeUnmount 
destroyed -&gt; onUnmounted 
activated -&gt; onActivated 
deactivated -&gt; onDeactivated 
errorCaptured -&gt; onErrorCaptured</code></pre> 
<p>除此之外, 还新增了两个用于调试的生命周期:</p> 
<ul><li>onRenderTracked</li><li>onRenderTriggered</li></ul> 
<h3 id="注册钩子函数">注册钩子函数</h3> 
<pre><code>export const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT)
export const onMounted = createHook(LifecycleHooks.MOUNTED)
export const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE)
export const onUpdated = createHook(LifecycleHooks.UPDATED)
export const onBeforeUnmount = createHook(LifecycleHooks.BEFORE_UNMOUNT)
export const onUnmounted = createHook(LifecycleHooks.UNMOUNTED)
export type DebuggerHook = (e: DebuggerEvent) =&gt; void
export const onRenderTriggered = createHook&lt;DebuggerHook&gt;(LifecycleHooks.RENDER_TRIGGERED)
export const onRenderTracked = createHook&lt;DebuggerHook&gt;(LifecycleHooks.RENDER_TRACKED)</code></pre> 
<p><code>createHook</code>的实现如下:</p> 
<pre><code>const createHook = function(lifecycle)  { 
  return function (hook, target = currentInstance) { 
    injectHook(lifecycle, hook, target) 
  } 
}</code></pre> 
<p> </p> 
<p>其内部的<code>injectHook</code>实现如下:</p> 
<pre><code>function injectHook(type, hook, target = currentInstance, prepend = false) { 
  const hooks = target[type] || (target[type] = []) 
  // 封装 hook 钩子函数并缓存 
  const wrappedHook = hook.__weh || 
    (hook.__weh = (...args) =&gt; { 
      if (target.isUnmounted) { 
        return 
      } 
      // 停止依赖收集 
      pauseTracking() 
      // 设置 target 为当前运行的组件实例 
      setCurrentInstance(target) 
      // 执行钩子函数 
      const res = callWithAsyncErrorHandling(hook, target, type, args) 
      setCurrentInstance(null) 
      // 恢复依赖收集 
      resetTracking() 
      return res 
    }) 
  if (prepend) { 
    hooks.unshift(wrappedHook) 
  } 
  else { 
    hooks.push(wrappedHook) 
  } 
}</code></pre> 
<p>该函数主要是对用户注册的钩子函数<code>hook</code>做了一层封装, 然后添加到一个数组中, 把数组保存在当前组件实例的target上, 这里, key是用来区分钩子函数的字符串. 比如, <code>onMounted</code>注册的钩子函数在组件实例上就是通过<code>instance.m</code>来保存的.</p> 
<p>组件实例在后续会通过不同的字符串<code>key</code>找到对应的钩子函数数组并执行.</p> 
<p>对于相同的钩子函数, 会把封装的<code>wrappedHook</code>钩子函数缓存到<code>hook.__weh</code>中, 这样后续通过<code>scheduler</code>方式执行的钩子函数就会被去重.</p> 
<p>后续执行<code>wrappedHook</code>函数时, 会先停止依赖手机, 因为钩子函数内部访问的响应式DJUI想爱你个, 通常都已经执行过依赖手机, 所以钩子函数执行的时候就没有必要再次进行.</p> 
<p>接着是设置 target 为当前组件实例.</p> 
<p>在接下来通过<code>callWithAsyncErrorHandling</code>方法执行注册的hook钩子函数, 执行完毕后设置当前运行组件实例为null, 并恢复依赖收集</p> 
<p> </p> 
<h3 id="onbeforemount-和-onmounted">onBeforeMount 和 onMounted</h3> 
<p><code>onBeforeMount</code>注册的<code>beforeMount</code>钩子函数会在组件挂载之前执行</p> 
<p><code>onMounted</code>注册的<code>mounted</code>钩子会在组件挂载之后执行</p> 
<p>我们回头看看组件渲染函数中关于组件挂载部分的实现:</p> 
<pre><code>const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; { 
  // 创建响应式的副作用渲染函数 
  instance.update = effect(function componentEffect() { 
    if (!instance.isMounted) { 
      // 获取组件实例上通过 onBeforeMount 钩子函数和 onMounted 注册的钩子函数 
      const { bm, m } = instance; 
      // 渲染组件生成子树 vnode 
      const subTree = (instance.subTree = renderComponentRoot(instance)) 
      // 执行 beforemount 钩子函数 
      if (bm) { 
        invokeArrayFns(bm) 
      } 
      // 把子树 vnode 挂载到 container 中 
      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG) 
      // 保留渲染生成的子树根 DOM 节点 
      initialVNode.el = subTree.el 
      // 执行 mounted 钩子函数 
      if (m) { 
        queuePostRenderEffect(m, parentSuspense) 
      } 
      instance.isMounted = true 
    } 
    else { 
      // 更新组件 
    } 
  }, prodEffectOptions) 
}
</code></pre> 
<p> </p> 
<p>在执行<code>patch</code>挂载组件之前, 会检测组件实例上是否有注册的<code>beforeMonut</code>钩子函数<code>bm</code>, 如果有则通过<code>invokeArrayFns</code>函数执行它, 挂载之后, 则检查是否有函数<code>m</code>, 然后通过<code>queuePostRenderEffect</code>将<code>mounted</code>函数推入<code>postFlushCbs</code>, 然后在整个树render以后, 同步执行<code>flushPostFlushCbs</code>函数调用<code>mounted</code>钩子函数</p> 
<p>对于嵌套组件, 组件会先执行父组件的beforeMount, 然后子组件的<code>beforeMount</code>, 然后子组件的<code>mounted</code>, 最后是父组件的<code>mounted</code>.</p> 
<h3 id="onbeforeupdate-和-onupdated">onBeforeUpdate 和 onUpdated</h3> 
<p>onBeforeUpdate注册的<code>beforeUpdate</code>会在组件更新之前执行, <code>onUpdated</code>会在组件更新之后执行.</p> 
<pre><code>const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; { 
  // 创建响应式的副作用渲染函数 
  instance.update = effect(function componentEffect() { 
    if (!instance.isMounted) { 
      // 渲染组件 
    } 
    else { 
      // 更新组件 
      // 获取组件实例上通过 onBeforeUpdate 钩子函数和 onUpdated 注册的钩子函数 
      let { next, vnode, bu, u } = instance 
      // next 表示新的组件 vnode 
      if (next) { 
        // 更新组件 vnode 节点信息 
        updateComponentPreRender(instance, next, optimized) 
      } 
      else { 
        next = vnode 
      } 
      // 渲染新的子树 vnode 
      const nextTree = renderComponentRoot(instance) 
      // 缓存旧的子树 vnode 
      const prevTree = instance.subTree 
      // 更新子树 vnode 
      instance.subTree = nextTree 
      // 执行 beforeUpdate 钩子函数 
      if (bu) { 
        invokeArrayFns(bu) 
      } 
      // 组件更新核心逻辑，根据新旧子树 vnode 做 patch 
      patch(prevTree, nextTree, 
 // 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点 
        hostParentNode(prevTree.el), 
   // 缓存更新后的 DOM 节点 
        getNextHostNode(prevTree), 
        instance, 
        parentSuspense, 
        isSVG) 
      // 缓存更新后的 DOM 节点 
      next.el = nextTree.el 
      // 执行 updated 钩子函数 
      if (u) { 
        queuePostRenderEffect(u, parentSuspense) 
      } 
    } 
  }, prodEffectOptions) 
}
</code></pre> 
<p> </p> 
<p>不要在 updated 钩子函数中更改数据，因为这样会再次触发组件更新，导致无限递归更新</p> 
<p>父组件的更新不一定会导致子组件的更新，因为 Vue.js 的更新粒度是组件级别的</p> 
<h3 id="onbeforeunmount-和-onunmounted">onBeforeUnmount 和 onUnmounted</h3> 
<p>onBeforeUnmount 注册的 beforeUnMount 钩子函数会在组件销毁之前执行</p> 
<p>onUnmounted 注册的 unmounted 钩子函数会在组件销毁之后执行</p> 
<pre><code>const unmountComponent = (instance, parentSuspense, doRemove) =&gt; { 
  const { bum, effects, update, subTree, um } = instance 
  // 执行 beforeUnmount 钩子函数 
  if (bum) { 
    invokeArrayFns(bum) 
  } 
  // 清理组件引用的 effects 副作用函数 
  if (effects) { 
    for (let i = 0; i &lt; effects.length; i++) { 
      stop(effects[i]) 
    } 
  } 
  // 如果一个异步组件在加载前就销毁了，则不会注册副作用渲染函数 
  if (update) { 
    stop(update) 
    // 调用 unmount 销毁子树 
    unmount(subTree, instance, parentSuspense, doRemove) 
  } 
  // 执行 unmounted 钩子函数 
  if (um) { 
    queuePostRenderEffect(um, parentSuspense) 
  } 
}
</code></pre> 
<p>组件销毁的逻辑比较简单, 就是清理组件实例上绑定的<code>effect</code>副作用函数和注册的副作用渲染函数<code>update</code>以及调用<code>unmount</code>销毁子树.</p> 
<h3 id="onerrorcaptured"><a href="http://know.shuerbuzuo.cn/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%5BVue3%5D%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%9005_%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90.html#onerrorcaptured" rel="nofollow">#</a>onErrorCaptured</h3> 
<p>组件销毁的逻辑比较简单, 就是清理组件实例上绑定的<code>effect</code>副作用函数和注册的副作用渲染函数<code>update</code>以及调用<code>unmount</code>销毁子树.</p> 
<p>我们在前面多次看到过一个函数<code>callWithErrorHandling</code>, 他用于执行一段函数, 并通过<code>handleError</code>处理错误. <code>handleError</code>的实现如下:</p> 
<pre><code>function handleError(err, instance, type) { 
  const contextVNode = instance ? instance.vnode : null 
  if (instance) { 
    let cur = instance.parent 
    // 为了兼容 2.x 版本，暴露组件实例给钩子函数 
    const exposedInstance = instance.proxy 
    // 获取错误信息 
    const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type 
    // 尝试向上查找所有父组件，执行 errorCaptured 钩子函数 
    while (cur) { 
      const errorCapturedHooks = cur.ec 
      if (errorCapturedHooks) { 
        for (let i = 0; i &lt; errorCapturedHooks.length; i++) { 
          // 如果执行的 errorCaptured 钩子函数并返回 true，则停止向上查找。、 
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo)) { 
            return 
          } 
        } 
      } 
      cur = cur.parent 
    } 
  } 
  // 往控制台输出未处理的错误 
  logError(err, type, contextVNode) 
}
</code></pre> 
<p> </p> 
<p>函数会从当前宝座的组件的父组件实例开始, 尝试去查找注册<code>errorCaptured</code>钩子函数, 如果有则遍历判断<code>errorCaptured</code>钩子函数是否为<code>true</code>, 如果是则说明这个错误已经正确处理, 否则会通过<code>logError</code>向控制台抛出错误.</p> 
<p>所以<code>errorCaptured</code>本质上用于捕获来自子孙组件的错误, 返回true就可以阻止错误继续向上传播</p> 
<p> </p> 
<p>函数会从当前宝座的组件的父组件实例开始, 尝试去查找注册<code>errorCaptured</code>钩子函数, 如果有则遍历判断<code>errorCaptured</code>钩子函数是否为<code>true</code>, 如果是则说明这个错误已经正确处理, 否则会通过<code>logError</code>向控制台抛出错误.</p> 
<p>所以<code>errorCaptured</code>本质上用于捕获来自子孙组件的错误, 返回true就可以阻止错误继续向上传播</p> 
<p> </p> 
<h3 id="onrendertracked-和-onrendertriggered">onRenderTracked 和 onRenderTriggered</h3> 
<p> </p> 
<p>onRenderTracked 和 onRenderTriggered 在开发阶段渲染调试用的</p> 
<p>我们回顾一下创建副作用渲染函数的第二个参数, 在开发环境下他们是这样的:</p> 
<p> </p> 
<h4>onRenderTracked 状态跟踪</h4> 
<p><code>onRenderTracked</code>直译过来就是<code>状态跟踪</code>，它会跟踪页面上所有响应式变量和方法的状态，也就是我们用<code>return</code>返回去的值，它都会跟踪。只要页面有<code>update</code>的情况，它就会跟踪，然后生成一个<code>event</code>对象，我们通过<code>event</code>对象来查找程序的问题所在。</p> 
<p>使用<code>onRenderTracked</code>同样要使用<code>import</code>进行引入。</p> 
<pre>import { .... ,onRenderTracked,} from "vue";</pre> 
<p>引用后就可以在<code>setup()</code>函数中进行引用了。</p> 
<pre><code>onRenderTracked((event) =&gt; {
console.log("状态跟踪组件-----------&gt;");
console.log(event);
});</code></pre> 
<p>写完后可以到终端中启动测试服务<code>npm run serve</code>，然后看一下效果，在组件没有更新的时候<code>onRenderTracked</code>是不会执行的，组件更新时，它会跟组里边每个值和方法的变化。</p> 
<p> </p> 
<h4>onRenderTriggered 状态触发</h4> 
<p><code>onRenderTriggered</code>直译过来是<code>状态触发</code>，它不会跟踪每一个值，而是给你变化值的信息，并且新值和旧值都会给你明确的展示出来。</p> 
<p>如果把<code>onRenderTracked</code>比喻成散弹枪，每个值都进行跟踪，那<code>onRenderTriggered</code>就是狙击枪，只精确跟踪发生变化的值，进行针对性调试。</p> 
<p>使用它同样要先用<code>import</code>进行引入</p> 
<pre>import { .... ,onRenderTriggered,} from "vue";</pre> 
<p>在使用<code>onRenderTriggered</code>前，记得注释相应的<code>onRenderTracked</code>代码，这样看起来会直观很多。 然后把<code>onRenderTriggered()</code>函数，写在<code>setup()</code>函数里边。</p> 
<pre><code>onRenderTriggered((event) =&gt; {
console.log("状态触发组件---------------&gt;");
console.log(event);
});</code></pre> 
<p>对 event 对象属性的详细介绍：</p> 
<pre><code>- key 那边变量发生了变化
- newValue 更新后变量的值
- oldValue 更新前变量的值
- target 目前页面中的响应变量和函数</code></pre> 
<p>通过这些你能很好的对代码进行调试。这些调试用的钩子函数，如果你能正确合理的使用，是真的可以快速解决问题的。</p> 
<pre> </pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/212cebd2afb8f8e9b666359738559188/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32CubeMX_以太网_RMII_LwIP_TCP</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7dca99c99c278e27cc245743f9a19c29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Error in render: “RangeError: Maximum call stack size exceeded“</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>