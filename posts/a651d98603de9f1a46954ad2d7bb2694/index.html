<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java8 新的日期/时间API操作和示例 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java8 新的日期/时间API操作和示例" />
<meta property="og:description" content="目录
1、Java8 新的日期/时间API操作
（1）LocalDate、LocalTime 和 LocalDateTime 时间类
（2）Instant、Duration 和 Period 时间间隔类
（3）Temporal、TemporalField 和 ChronoField
（4）时间、日期设置和修改
（5）时间、日期解析和格式化
（6）不同时区的时间处理
2、日期/时间 API 使用示例
（1）通过 Java 的基本语法来实现万年历
（2）Java 获取一年中所有的周六和周日
1、Java8 新的日期/时间API操作 Java 旧的日期时间类 java.util.Date 和 java.util.Calendar 存在可变性，导致在多线程环境下使用时会存在线程安全问题。在新的 API 中，几乎所有的类都是不可变的，从而保证了线程安全性。此外，旧的 API 命名不清晰，使得日期时间处理相对困难。新的 API 使用了更清晰和直观的命名，使得代码更易读、更易写。
（1）LocalDate、LocalTime 和 LocalDateTime 时间类 LocalDate 和 LocalTime 是 Java 中 java.time 包下的两个日期时间类，用于分别表示日期和时间，它们不包含时区信息，仅仅表示日期或时间部分。//时间和日期可以进行分开
LocalDate：用于表示日期，包含年、月、日，但不包含时、分、秒和时区信息，可以使用 now() 方法获取当前日期，或者使用 of() 方法指定特定的年、月、日创建实例。
// 获取当前日期 LocalDate currentDate = LocalDate.now(); // 创建特定日期 LocalDate specificDate = LocalDate.of(2023, 12, 31); // 获取年、月、日 int year = currentDate." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a651d98603de9f1a46954ad2d7bb2694/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T14:15:59+08:00" />
<meta property="article:modified_time" content="2023-12-28T14:15:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java8 新的日期/时间API操作和示例</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81Java8%20%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%2F%E6%97%B6%E9%97%B4API%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#1%E3%80%81Java8%20%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%2F%E6%97%B6%E9%97%B4API%E6%93%8D%E4%BD%9C" rel="nofollow">1、Java8 新的日期/时间API操作</a></p> 
<p id="%EF%BC%881%EF%BC%89LocalDate%E3%80%81LocalTime%20%E5%92%8C%20LocalDateTime%20%E6%97%B6%E9%97%B4%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89LocalDate%E3%80%81LocalTime%20%E5%92%8C%20LocalDateTime%20%E6%97%B6%E9%97%B4%E7%B1%BB" rel="nofollow">（1）LocalDate、LocalTime 和 LocalDateTime 时间类</a></p> 
<p id="%EF%BC%882%EF%BC%89Instant%E3%80%81Duration%20%E5%92%8C%20Period%20%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89Instant%E3%80%81Duration%20%E5%92%8C%20Period%20%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%B1%BB" rel="nofollow">（2）Instant、Duration 和 Period 时间间隔类</a></p> 
<p id="%EF%BC%883%EF%BC%89Temporal%E3%80%81TemporalField%20%E5%92%8C%20ChronoField-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89Temporal%E3%80%81TemporalField%20%E5%92%8C%20ChronoField" rel="nofollow">（3）Temporal、TemporalField 和 ChronoField</a></p> 
<p id="%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BF%AE%E6%94%B9-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BF%AE%E6%94%B9" rel="nofollow">（4）时间、日期设置和修改</a></p> 
<p id="%EF%BC%885%EF%BC%89%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E8%A7%A3%E6%9E%90%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E8%A7%A3%E6%9E%90%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96" rel="nofollow">（5）时间、日期解析和格式化</a></p> 
<p id="%EF%BC%886%EF%BC%89%E4%B8%8D%E5%90%8C%E6%97%B6%E5%8C%BA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89%E4%B8%8D%E5%90%8C%E6%97%B6%E5%8C%BA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86" rel="nofollow">（6）不同时区的时间处理</a></p> 
<p id="2%E3%80%81%E6%97%A5%E6%9C%9F%2F%E6%97%B6%E9%97%B4%20API%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%97%A5%E6%9C%9F%2F%E6%97%B6%E9%97%B4%20API%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" rel="nofollow">2、日期/时间 API 使用示例</a></p> 
<p id="%EF%BC%881%EF%BC%89%E9%80%9A%E8%BF%87%20Java%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%87%E5%B9%B4%E5%8E%86-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E9%80%9A%E8%BF%87%20Java%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%87%E5%B9%B4%E5%8E%86" rel="nofollow">（1）通过 Java 的基本语法来实现万年历</a></p> 
<p id="%EF%BC%882%EF%BC%89Java%20%E8%8E%B7%E5%8F%96%E4%B8%80%E5%B9%B4%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%91%A8%E5%85%AD%E5%92%8C%E5%91%A8%E6%97%A5-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89Java%20%E8%8E%B7%E5%8F%96%E4%B8%80%E5%B9%B4%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%91%A8%E5%85%AD%E5%92%8C%E5%91%A8%E6%97%A5" rel="nofollow">（2）Java 获取一年中所有的周六和周日</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3>1、Java8 新的日期/时间API操作</h3> 
<p>        Java 旧的日期时间类<em> java.util.Date </em>和<em> java.util.Calendar </em>存在可变性，导致在多线程环境下使用时会存在线程安全问题。<span style="color:#fe2c24;"><em>在新的 API 中，几乎所有的类都是不可变的，从而保证了线程安全性</em></span>。此外，旧的<em> API </em>命名不清晰，使得日期时间处理相对困难。新的<em> API </em>使用了更清晰和直观的命名，使得代码更易读、更易写。</p> 
<h4 id="%EF%BC%881%EF%BC%89LocalDate%E3%80%81LocalTime%20%E5%92%8C%20LocalDateTime%20%E6%97%B6%E9%97%B4%E7%B1%BB">（1）LocalDate、LocalTime 和 LocalDateTime 时间类</h4> 
<p>        <em>LocalDate </em>和 <em>LocalTime </em>是<em> Java </em>中<em> java.time </em>包下的两个日期时间类，用于分别表示日期和时间，它们<em>不包含时区信息，仅仅表示日期或时间部分</em>。<span style="color:#4da8ee;">//时间和日期可以进行分开</span></p> 
<p>        <strong><em>LocalDate：</em></strong><span style="color:#fe2c24;"><em>用于表示日期，包含年、月、日，但不包含时、分、秒和时区信息</em></span>，可以使用 <em>now() </em>方法获取当前日期，或者使用 <em>of() </em>方法指定特定的年、月、日创建实例。</p> 
<pre><code>// 获取当前日期
LocalDate currentDate = LocalDate.now();

// 创建特定日期
LocalDate specificDate = LocalDate.of(2023, 12, 31);

// 获取年、月、日
int year = currentDate.getYear();
int month = currentDate.getMonthValue();
int day = currentDate.getDayOfMonth();
</code></pre> 
<p>        <em><strong>LocalTime：</strong><span style="color:#fe2c24;">用于表示时间，包含时、分、秒和纳秒，但不包含日期和时区信息</span></em>。也可以使用 <em>now() </em>方法获取当前时间，或者使用 <em>of() </em>方法指定特定的时、分、秒创建实例。</p> 
<pre><code>// 获取当前时间
LocalTime currentTime = LocalTime.now();

// 创建特定时间
LocalTime specificTime = LocalTime.of(12, 30, 0);

// 获取时、分、秒
int hour = currentTime.getHour();
int minute = currentTime.getMinute();
int second = currentTime.getSecond();</code></pre> 
<p>        <strong><em>LocalDateTime：</em></strong>是 LocalDate 和 LocalTime 的合体。它<span style="color:#fe2c24;"><em>同时表示了日期和时间</em></span>，但不带有时区信息，你可以直接创建，也可以通过合并日期和时间对象构造，如下所示。</p> 
<pre><code>// 获取当前日期时间
LocalDateTime currentDateTime = LocalDateTime.now();

// 创建特定日期时间
LocalDateTime specificDateTime = LocalDateTime.of(2023, 12, 31, 12, 30, 0);

// 使用 LocalDate 和 LocalTime 构建 LocalDateTime
LocalDate localDate = LocalDate.of(2023, 12, 31);
LocalTime localTime = LocalTime.of(12, 30);
LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);
</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89Instant%E3%80%81Duration%20%E5%92%8C%20Period%20%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%B1%BB">（2）Instant、Duration 和 Period 时间间隔类</h4> 
<p><em>        Instant、Duration </em>和<em> Period </em>是<em> Java </em>中用于处理时间间隔和持续时间的类。</p> 
<p>       <span style="color:#fe2c24;"> </span><em><strong>Instant：</strong><span style="color:#fe2c24;">用于表示时间线上的一个具体点</span></em>，通常表示自 <em>1970-01-01T00:00:00Z</em>（即协调世界时）开始经过的秒数和纳秒数。可以使用 <em>now() </em>方法获取当前的时间点，或者使用 <em>ofEpochSecond()、ofEpochMilli() </em>等方法指定特定的秒数或毫秒数创建实例。</p> 
<pre><code>// 获取当前时间点
Instant currentInstant = Instant.now();

// 创建特定时间点
Instant specificInstant = Instant.ofEpochSecond(1630452000); // 2022-09-01T00:00:00Z</code></pre> 
<p>        需要特别强调的一点，<span style="color:#fe2c24;"><em>Instant 的设计初衷是为了便于机器使用</em></span>。它包含的<span style="color:#fe2c24;"><em>是由秒及纳秒所构成的数字</em></span>。所以，它无法处理那些我们非常容易理解的时间单位。比如下面这段语句：</p> 
<pre><code>int hour = Instant.now().get(ChronoField.HOUR_OF_DAY);</code></pre> 
<p>        它会抛出如下异常：</p> 
<p><em>        Exception in thread "main" java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: HourOfDay</em></p> 
<p>       <em><strong> Duration：</strong></em>用于表示时间段的持续时间，<span style="color:#fe2c24;"><em>包含了以秒和纳秒为单位的时间间隔</em></span>。可以使用 <em>between() </em>方法计算两个时间点之间的持续时间，或者使用<em> ofSeconds()、ofMinutes() </em>等方法指定特定的时间间隔创建实例。</p> 
<pre><code>// 计算两个时间/时间点之间的持续时间：不支持使用LocalDate入参
Duration instantDuration = Duration.between(startInstant, endInstant);
Duration timeDuration = Duration.between(startTime, endTime);</code></pre> 
<p>        <em><strong>Period：</strong><span style="color:#fe2c24;">用于表示日期之间的时间段，以年、月、日为单位</span></em>。可以使用<em> between() </em>方法计算两个日期之间的时间段，或者使用 <em>of() </em>方法指定特定的年、月、日创建实例。</p> 
<pre><code>// 计算两个日期之间的时间段：不支持时间
Period period = Period.between(startDate, endDate);

// 创建特定时间段
Period specificPeriod = Period.ofYears(2); // 2年的时间段
</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89Temporal%E3%80%81TemporalField%20%E5%92%8C%20ChronoField">（3）Temporal、TemporalField 和 ChronoField</h4> 
<p>        对于一套新的 <em>API</em>，我们常常会为一些陌生的类而感到困惑，比如<em> Temporal、TemporalField 和 ChronoField。</em></p> 
<p>        <em>Temporal</em> 是<em> Java Date Time API </em>中的一个接口，它<em><span style="color:#fe2c24;">是所有日期和时间类的基本接口，定义了对日期时间操作的通用方法</span></em>。<span style="color:#4da8ee;">//定义一个通用接口的好处是，它的类型可以对所有的子类类型进行抽象，使一套模板方法具有普适性</span></p> 
<p>        <em>TemporalField </em>是一个接口，它<em><span style="color:#fe2c24;">定义了如何访问 Temporal 对象某个字段的值</span></em>。<em>ChronoField</em> 枚举实现了这一接口，所以你可以很方便地使用 get 方法得到枚举元素的值，如下所示：<span style="color:#4da8ee;">//<em>ChronoField</em> 是一个枚举类</span></p> 
<pre><code>// 通过 TemporalField 获取字段值
int month = LocalDate.now().get(ChronoField.MONTH_OF_YEAR);
int hour = LocalTime.now().get(ChronoField.CLOCK_HOUR_OF_DAY);
int week = LocalDateTime.now().get(ChronoField.ALIGNED_WEEK_OF_MONTH);</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BF%AE%E6%94%B9">（4）时间、日期设置和修改</h4> 
<p>        在 <em>Java </em>中，可以使用 <em>LocalDateTime</em> 类来修改日期时间的各个部分。<em>LocalDateTime </em>是不可变的，因此<em><span style="color:#fe2c24;">修改操作会返回一个新的实例，而不是修改原始实例</span></em>。</p> 
<p>        以下是一些常见的 <em>LocalDateTime </em>时间修改操作示例：</p> 
<p>       <em><strong> 增减年、月、日、时、分、秒、纳秒：</strong></em></p> 
<pre><code>    LocalDateTime currentDateTime = LocalDateTime.now();

    // 增加或减少年、月、日、时、分、秒、纳秒
    LocalDateTime futureDateTime = currentDateTime.plusYears(1)
          .minusMonths(3)
          .plusDays(7)
          .plusHours(2)
          .minusMinutes(30)
          .plusSeconds(15)
          .minusNanos(500000000);

    // 或者使用带有时间单位的方法
    LocalDateTime modifiedDateTime = currentDateTime.plus(1, ChronoUnit.YEARS)
          .minus(3, ChronoUnit.MONTHS)
          .plus(7, ChronoUnit.DAYS)
          .plus(2, ChronoUnit.HOURS)
          .minus(30, ChronoUnit.MINUTES)
          .plus(15, ChronoUnit.SECONDS)
          .minus(500000000, ChronoUnit.NANOS);</code></pre> 
<p>        <em><strong>设置特定的年、月、日、时、分、秒、纳秒：</strong></em></p> 
<pre><code>    LocalDateTime currentDateTime = LocalDateTime.now();

    // 设置特定的年、月、日、时、分、秒、纳秒
    LocalDateTime newDateTime = currentDateTime.withYear(2025)
              .withMonth(10)
              .withDayOfMonth(15)
              .withHour(18)
              .withMinute(45)
              .withSecond(30)
              .withNano(0);
</code></pre> 
<p>       <strong><em>使用 TemporalAdjuster 对象对日期进行灵活处理：</em></strong></p> 
<p>        <em>TemporalAdjuster</em> 是 <em>Java Date Time API </em>中的一个接口，<em><span style="color:#fe2c24;">用于根据特定的规则调整日期时间</span></em>，例如，将日期调整为下一个工作日、月末、下个星期等。通过<em> TemporalAdjusters </em>类的静态工厂方法可以使用大量预定义的 <em>TemporalAdjuster</em>，代码如下所示：</p> 
<pre><code>LocalDateTime now = LocalDateTime.now();
LocalDateTime dayOfWeek = now.with(TemporalAdjusters.dayOfWeekInMonth(1, DayOfWeek.SUNDAY));
LocalDateTime lastDayOfMonth = now.with(TemporalAdjusters.lastDayOfMonth());</code></pre> 
<p>       <em><strong>使用自定义的 TemporalAdjuster 对象：</strong></em></p> 
<p>        正如我们看到的，使用 <em><strong>TemporalAdjuster </strong></em>可以进行更加复杂的日期操作，那么如果没有找到符合要求的 <em>TemporalAdjuster</em>，我们也可以创建自定义的 <em>TemporalAdjuster</em><em>，</em>方法很简单，只需要实现 <em><strong>TemporalAdjuster </strong></em>接口即可，代码如下所示：</p> 
<pre><code>public class NextWorkingDay implements TemporalAdjuster {
    @Override
    public Temporal adjustInto(Temporal temporal) {
        DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));
        int daysToAdd = 1;
        if (dayOfWeek == DayOfWeek.FRIDAY) {
            daysToAdd = 3; //星期五至星期一，加3天
        } else if (dayOfWeek == DayOfWeek.SATURDAY) {
            daysToAdd = 2; //星期六至星期一，加2天
        }
        //其他时间都是+1天
        return temporal.plus(daysToAdd, ChronoUnit.DAYS);
    }

    public static void main(String[] args) {
        LocalDate date = LocalDate.now();
        TemporalAdjuster adjuster = new NextWorkingDay();
        LocalDate nextWorkingDay = date.with(adjuster);
    }
}</code></pre> 
<p>       <em> TemporalAdjuster </em>接口只声明了单一的一个方法：<em>adjustInto</em>，因此它也是一个函数式接口。</p> 
<h4 id="%EF%BC%885%EF%BC%89%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E8%A7%A3%E6%9E%90%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96">（5）时间、日期解析和格式化</h4> 
<p><em>        DateTimeFormatter </em>是<em> Java Date Time API </em>中用于格式化和解析日期时间对象的类。</p> 
<p>        <em><strong>格式化日期时间对象为字符串：</strong></em></p> 
<pre><code>LocalDateTime dateTime = LocalDateTime.now();
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String formattedDateTime = dateTime.format(formatter);</code></pre> 
<p>        <em><strong>解析字符串为日期时间对象：</strong></em></p> 
<pre><code>String strDateTime = "2023-12-31 15:30:00";
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
LocalDateTime parsedDateTime = LocalDateTime.parse(strDateTime, formatter);</code></pre> 
<p>        <em><strong>预定义的 DateTimeFormatter：</strong></em></p> 
<p>        <em>Java</em> 提供了一些预定义的 <em>DateTimeFormatter</em>，方便进行常见格式化和解析操作：</p> 
<ul><li><em>DateTimeFormatter.ISO_LOCAL_DATE</em>：<em>ISO </em>格式的日期，例如：<em>"2023-12-31"</em></li><li><em>DateTimeFormatter.ISO_LOCAL_TIME</em>：<em>ISO </em>格式的时间，例如：<em>"15:30:00"</em></li><li><em>DateTimeFormatter.ISO_LOCAL_DATE_TIME</em>：<em>ISO</em> 格式的日期时间，例如：<em>"2023-12-31T15:30:00"</em></li><li><em>DateTimeFormatter.BASIC_ISO_DATE</em>：基本的 <em>ISO</em> 格式日期，例如：<em>"20231231"</em></li></ul> 
<p>        使用示例：</p> 
<pre><code>//格式化
String format = localDateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);

//解析
LocalDateTime parse = LocalDateTime.parse("2023-12-27T13:39:07", DateTimeFormatter.ISO_LOCAL_DATE_TIME);
</code></pre> 
<h4 id="%EF%BC%886%EF%BC%89%E4%B8%8D%E5%90%8C%E6%97%B6%E5%8C%BA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86">（6）不同时区的时间处理</h4> 
<p>        时区的处理是新版日期和时间 <em>API </em>新增加的重要功能，使用新版日期和时间<em> API </em>时区的处理被极大地简化了。新的<em> java.time.zoneId </em>类是老版<em> java.util.Timezone </em>的替代品。<em>zoneId </em>类跟其他日期类一样，也是无法修改的。</p> 
<p>        <em><strong>获取默认时区和所有可用的时区：</strong></em></p> 
<pre><code>//获取默认时区
ZoneId defaultZone = ZoneId.systemDefault(); // Asia/Shanghai

//获取所有可用的时区
Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds();</code></pre> 
<p>        每个特定的<em> zoneId </em>对象都是一个地区<em> ID </em>标识，地区<em> ID</em> 都为 <em>“{区域/城市}”</em> 的格式，如：<em>"Asia/Shanghai"，</em>这些地区集合的设定都由英特网编号分配机构（IANA）的时区数据库提供。</p> 
<p><strong>        <em>创建特定的时区实例：</em></strong></p> 
<pre><code>ZoneId newYorkZone = ZoneId.of("America/New_York");
ZoneId londonZone = ZoneId.of("Europe/London");
ZoneId tokyoZone = ZoneId.of("Asia/Tokyo");</code></pre> 
<p><strong>       <em> 将时区应用到日期时间对象：</em></strong></p> 
<pre><code>LocalDateTime localDateTime = LocalDateTime.now();
ZonedDateTime newYorkDateTime = localDateTime.atZone(newYorkZone);
ZonedDateTime londonDateTime = localDateTime.atZone(londonZone);
ZonedDateTime tokyoDateTime = localDateTime.atZone(tokyoZone);

//默认时区
ZoneId defaultZone = ZoneId.systemDefault();
ZonedDateTime defaultZoneTime = localDateTime.atZone(defaultZone);
//defaultZoneTime内容：
2023-12-28T09:29:30.277+08:00[Asia/Shanghai]</code></pre> 
<p>        <em><strong>在不同时区之间转换时间：</strong></em></p> 
<pre><code>ZonedDateTime tokyoTime = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));
ZonedDateTime londonTime = tokyoTime.withZoneSameInstant(ZoneId.of("Europe/London"));</code></pre> 
<p>        <em>ZoneId </em>可以用于将本地日期时间转换为特定时区的日期时间，并且允许在不同时区之间进行时间转换。它是处理全球时区的重要工具，在跨越不同时区的应用程序中特别有用。</p> 
<p>        在示例中，带时区信息的时间使用 <em>ZonedDateTime </em>进行表示，<em><strong>那么 ZonedDateTime、LocaleDate、LocalTime、LocalDateTime 以及 ZoneId 之间有什么差异呢？</strong></em></p> 
<p>        下边一张图，可以清晰的解释它们之间的区别：</p> 
<p class="img-center"><img alt="" height="209" src="https://images2.imgbox.com/62/d6/SvrDa7Sg_o.png" width="450"></p> 
<h3 id="2%E3%80%81%E6%97%A5%E6%9C%9F%2F%E6%97%B6%E9%97%B4%20API%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">2、日期/时间 API 使用示例</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E9%80%9A%E8%BF%87%20Java%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%87%E5%B9%B4%E5%8E%86">（1）通过 Java 的基本语法来实现万年历</h4> 
<p>        通过年份和月份的天数进行万年历计算：</p> 
<pre><code>import java.util.Scanner;

/**
 * @author swadian2008
 */
public class DateUtils {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入年：");
        int year = sc.nextInt();
        System.out.println("请输入月份：");
        int month = sc.nextInt();
        
        //1.计算1900.1.1到输入年的天数
        int dayOfYear = 0;
        for (int i = 1900; i &lt; year; i++) {
            if (i % 4 == 0 &amp;&amp; i % 100 != 0 || i % 400 == 0) { // 闰年
                dayOfYear += 366;
            } else {
                dayOfYear += 365;
            }
        }
        
        //2.计算1月到输入月的天数
        int dayOfMonth = 0;
        for (int i = 1; i &lt; month; i++) {
            switch (i) {
                case 1:
                case 3:
                case 5:
                case 7:
                case 8:
                case 10:
                case 12:
                    dayOfMonth += 31;
                    break;
                case 4:
                case 6:
                case 9:
                case 11:
                    dayOfMonth += 30;
                    break;
                case 2:
                    if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || (year % 400 == 0)) {
                        dayOfMonth += 29;
                    } else {
                        dayOfMonth += 28;
                    }
                    break;
            }
        }
        
        //3.获取输入月的天数
        int day = 0;
        switch (month) {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                day = 31;
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                day = 30;
                break;
            case 2:
                if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || (year % 400 == 0)) {
                    day = 29;
                } else {
                    day = 28;
                }
                break;
        }
        //4.计算星期
        int allDay = dayOfYear + dayOfMonth + 1;
        int week = allDay % 7; // 计算余数在星期中的位置
        int count = 0;// 计数器,记录日期的空格

        System.out.println("星期日\t星期一\t星期二\t星期三\t星期四\t星期五\t星期六");
        
        //5.打印空格
        for (int i = 1; i &lt;= week; i++) {
            System.out.print("\t\t\t");
            count++;
        }
        
        //6. 打印日历
        for (int i = 1; i &lt;= day; i++) {
            if (i &lt; 10) { // 为了格式化
                System.out.print(i + "\t\t\t");
            } else {
                System.out.print(i + "\t\t");
            }
            count++;
            //若记录数是七的倍数，换行输出
            if (count % 7 == 0) {
                System.out.println();
            }
        }
    }
}</code></pre> 
<p>        输出结果图示：</p> 
<p class="img-center"><img alt="" height="238" src="https://images2.imgbox.com/83/1f/TIWdS43c_o.png" width="500"></p> 
<h4 id="%EF%BC%882%EF%BC%89Java%20%E8%8E%B7%E5%8F%96%E4%B8%80%E5%B9%B4%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%91%A8%E5%85%AD%E5%92%8C%E5%91%A8%E6%97%A5">（2）Java 获取一年中所有的周六和周日</h4> 
<p>        下边的示例中使用了一个Map来收集一年当中的周六和周日的日期，统计年份可以根据需要进行调节，下边代码也适合用来处理自定义节假日的需求：</p> 
<pre><code>import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.Period;
import java.time.temporal.ChronoField;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.stream.Collectors;
import static java.time.temporal.TemporalAdjusters.firstInMonth;

/**
 * @author swadian2008
 */
public class WeekDay {

    public static void main(String[] args) {
        //收集2023年所有的周六和周日
        int year = 2023;
        int month = 1;
        int day = 1;

        //按月份统计周六和周日
        Map&lt;Integer, List&lt;Integer&gt;&gt; weekMap = new HashMap&lt;&gt;(12);
        //创建代表一年中第一天的LocalDate对象
        LocalDate localDate = LocalDate.of(year, month, day);
        //收集所有星期六
        collectDayOfWeek(weekMap, localDate, DayOfWeek.SATURDAY, year);
        //收集所有星期日
        collectDayOfWeek(weekMap, localDate, DayOfWeek.SUNDAY, year);

        Map&lt;Integer, List&lt;Integer&gt;&gt; sortWeekMap = weekMap.entrySet().stream().collect(Collectors.toMap(Entry::getKey, r -&gt; r.getValue().stream().sorted(Comparator.naturalOrder()).collect(Collectors.toList())));

        for (Entry&lt;Integer, List&lt;Integer&gt;&gt; map : sortWeekMap.entrySet()) {
            System.out.println(map.getKey() + "月:" + map.getValue().toString());
        }
    }

    private static void collectDayOfWeek(Map&lt;Integer, List&lt;Integer&gt;&gt; weekMap, LocalDate localDate, DayOfWeek dayOfWeek, int year) {
        //获取一年中的第一个指定日期（星期六或星期日）
        LocalDate weekday = localDate.with(firstInMonth(dayOfWeek));

        while (weekday.getYear() == year) {
            int month = weekday.get(ChronoField.MONTH_OF_YEAR);
            int day = weekday.getDayOfMonth();

            List&lt;Integer&gt; integers = weekMap.get(month);
            if (Objects.nonNull(integers) &amp;&amp; !integers.isEmpty()) {
                integers.add(day);
            } else {
                integers = new ArrayList&lt;&gt;();
                integers.add(day);
                weekMap.put(month, integers);
            }
            //向后迭代一个星期
            weekday = weekday.plus(Period.ofDays(7));
        }
    }
}</code></pre> 
<p>        输出结果：</p> 
<pre><code>1月:[1, 7, 8, 14, 15, 21, 22, 28, 29]
2月:[4, 5, 11, 12, 18, 19, 25, 26]
3月:[4, 5, 11, 12, 18, 19, 25, 26]
4月:[1, 2, 8, 9, 15, 16, 22, 23, 29, 30]
5月:[6, 7, 13, 14, 20, 21, 27, 28]
6月:[3, 4, 10, 11, 17, 18, 24, 25]
7月:[1, 2, 8, 9, 15, 16, 22, 23, 29, 30]
8月:[5, 6, 12, 13, 19, 20, 26, 27]
9月:[2, 3, 9, 10, 16, 17, 23, 24, 30]
10月:[1, 7, 8, 14, 15, 21, 22, 28, 29]
11月:[4, 5, 11, 12, 18, 19, 25, 26]
12月:[2, 3, 9, 10, 16, 17, 23, 24, 30, 31]</code></pre> 
<p>        至此，全文结束。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa7e7fd0cba5802fea41aee4d9d9c0bf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle 查询某个时间之内的数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f4c44f5d902da436e3aa6323314bc78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;连接数据库（DataBase）之加载外部依赖项</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>