<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Leetcode双指针题（java作答） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Leetcode双指针题（java作答）" />
<meta property="og:description" content="目录
26.删除排序数组中的重复项
283.移动零
925.长按键入
面试题04.二维数组中的查找
532.数组中的K-diff数对
977.有序数组的平方
88.合并两个有序数组
349.两个数组的交集
830.较大分组的位置
26.删除排序数组中的重复项 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array
class Solution { public int removeDuplicates(int[] nums) { int j=0; for(int i=1;i&lt;nums.length;i&#43;&#43;){ if(nums[j]!=nums[i]){ nums[j&#43;1]=nums[i]; j&#43;&#43;; } } return j&#43;1; } } 283.移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
必须在原数组上操作，不能拷贝额外的数组。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/42dad268af1d21b91c8fba8debe29e09/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-17T16:21:04+08:00" />
<meta property="article:modified_time" content="2020-03-17T16:21:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Leetcode双指针题（java作答）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:40px;"><a href="#main-toc" rel="nofollow">26.删除排序数组中的重复项</a></p> 
<p id="283.%E7%A7%BB%E5%8A%A8%E9%9B%B6-toc" style="margin-left:40px;"><a href="#283.%E7%A7%BB%E5%8A%A8%E9%9B%B6" rel="nofollow">283.移动零</a></p> 
<p id="925.%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5-toc" style="margin-left:40px;"><a href="#925.%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5" rel="nofollow">925.长按键入</a></p> 
<p id="%E9%9D%A2%E8%AF%95%E9%A2%9804.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9804.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">面试题04.二维数组中的查找</a></p> 
<p id="532.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9-toc" style="margin-left:40px;"><a href="#532.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9" rel="nofollow">532.数组中的K-diff数对</a></p> 
<p id="977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-toc" style="margin-left:40px;"><a href="#977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9" rel="nofollow">977.有序数组的平方</a></p> 
<p id="88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84" rel="nofollow">88.合并两个有序数组</a></p> 
<p id="349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-toc" style="margin-left:40px;"><a href="#349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86" rel="nofollow">349.两个数组的交集</a></p> 
<p id="830.%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#830.%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow">830.较大分组的位置</a></p> 
<hr id="hr-toc"> 
<h3>26.删除排序数组中的重复项</h3> 
<blockquote> 
 <p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p> 
 <p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p> 
 <p> </p> 
 <p>示例 1:</p> 
 <p>给定数组 nums = [1,1,2], </p> 
 <p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p> 
 <p>你不需要考虑数组中超出新长度后面的元素。</p> 
 <p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
        int j=0;
        for(int i=1;i&lt;nums.length;i++){
            if(nums[j]!=nums[i]){
                nums[j+1]=nums[i];
                j++;
            }
        }
        return j+1;
    }
}</code></pre> 
<h3 id="283.%E7%A7%BB%E5%8A%A8%E9%9B%B6">283.移动零</h3> 
<blockquote> 
 <p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p> 
 <p>示例:</p> 
 <p>输入: [0,1,0,3,12]<br> 输出: [1,3,12,0,0]<br> 说明:</p> 
 <p>必须在原数组上操作，不能拷贝额外的数组。<br> 尽量减少操作次数。</p> 
 <p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/move-zeroes</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public void moveZeroes(int[] nums) {
        int j=0;
        for(int i=0;i&lt;nums.length;i++){
            if(nums[i]!=0){
                nums[j]=nums[i];
                if(i!=j){
                    nums[i]=0;
                }
                j++;
            }
        }
    }
}</code></pre> 
<h3 id="925.%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5">925.长按键入</h3> 
<blockquote> 
 <p>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。</p> 
 <p>你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。</p> 
 <p> </p> 
 <p>示例 1：</p> 
 <p>输入：name = "alex", typed = "aaleex"<br> 输出：true<br> 解释：'alex' 中的 'a' 和 'e' 被长按。<br> 示例 2：</p> 
 <p>输入：name = "saeed", typed = "ssaaedd"<br> 输出：false<br> 解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。<br> 示例 3：</p> 
 <p>输入：name = "leelee", typed = "lleeelee"<br> 输出：true<br> 示例 4：</p> 
 <p>输入：name = "laiden", typed = "laiden"<br> 输出：true<br> 解释：长按名字中的字符并不是必要的。<br>  </p> 
 <p>提示：</p> 
 <p>name.length &lt;= 1000<br> typed.length &lt;= 1000<br> name 和 typed 的字符都是小写字母。</p> 
 <p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/long-pressed-name</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public boolean isLongPressedName(String name, String typed) {
        if(name.charAt(0)!=typed.charAt(0)){
            return false;
        }
        int flagLen=0;
        int j=0;
        boolean flag=true;
        for(int i=0;i&lt;typed.length();i++){
            if(j==name.length()){
                if(typed.charAt(i)!=name.charAt(j-1)){
                    flag=false;
                    break;
                }
            }else{
                if(typed.charAt(i)==name.charAt(j)){
                    j++;
                    flagLen++;
                }else{
                    if(typed.charAt(i)!=name.charAt(j-1)){
                        flag=false;
                        break;
                    }
                }
            }
        }
        return flagLen==name.length()&amp;&amp;flag;
    }
}</code></pre> 
<h3 id="%E9%9D%A2%E8%AF%95%E9%A2%9804.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">面试题04.二维数组中的查找</h3> 
<blockquote> 
 <p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p> 
 <p> </p> 
 <p><strong>示例:</strong></p> 
 <p>现有矩阵 matrix 如下：</p> 
 <pre><code class="language-html">[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
</code></pre> 
 <p>给定 target = <code>5</code>，返回 <code>true</code>。</p> 
 <p>给定 target = <code>20</code>，返回 <code>false</code>。</p> 
 <p> </p> 
 <p><strong>限制：</strong></p> 
 <p><code>0 &lt;= n &lt;= 1000</code></p> 
 <p><code>0 &lt;= m &lt;= 1000</code></p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if(matrix.length==0){
            return false;
        }
        int i=matrix.length-1;
        int j=0;
        while(true){
            if(i&lt;0|j&gt;=matrix[0].length){
                break;
            }
            if(matrix[i][j]==target){
                return true;
            }
            if(matrix[i][j]&lt;target){
                j++;
            }else{
                i--;
            }
        }
        return false;
    }
}</code></pre> 
<h3 id="532.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9">532.数组中的K-diff数对</h3> 
<blockquote> 
 <p>给定一个整数数组和一个整数 <strong>k</strong>, 你需要在数组里找到<strong>不同的 </strong>k-diff 数对。这里将 <strong>k-diff</strong> 数对定义为一个整数对 (i, j), 其中<strong> i </strong>和<strong> j </strong>都是数组中的数字，且两数之差的绝对值是 <strong>k</strong>.</p> 
 <p><strong>示例 1:</strong></p> 
 <pre><code class="language-html">输入: [3, 1, 4, 1, 5], k = 2
输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
</code></pre> 
 <p><strong>示例 2:</strong></p> 
 <pre><code class="language-html">输入:[1, 2, 3, 4, 5], k = 1
输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
</code></pre> 
 <p><strong>示例 3:</strong></p> 
 <pre><code class="language-html">输入: [1, 3, 1, 5, 4], k = 0
输出: 1
解释: 数组中只有一个 0-diff 数对，(1, 1)。
</code></pre> 
 <p><strong>注意:</strong></p> 
 <ol><li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li><li>数组的长度不超过10,000。</li><li>所有输入的整数的范围在 [-1e7, 1e7]。</li></ol> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public int findPairs(int[] nums, int k) {
        int count=0;
        Arrays.sort(nums);
        int j=0;
        int i=0;
        
        for(j=0;j&lt;nums.length;j++){
            if(j!=0&amp;&amp;nums[j]==nums[j-1]){
                continue;
            }
            for(i=j+1;i&lt;nums.length;i++){
                if(i!=j+1&amp;&amp;nums[i]==nums[i-1]){
                    continue;
                }
                if(Math.abs(nums[j]-nums[i])==k){
                    count++;
                }
            }    
        }
        return count;
    }
}</code></pre> 
<h3 id="977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9">977.有序数组的平方</h3> 
<blockquote> 
 <p>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p> 
 <p><strong>示例 1：</strong></p> 
 <pre><code class="language-html">输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
</code></pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><code class="language-html">输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]
</code></pre> 
 <p><strong>提示：</strong></p> 
 <ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li><li><code>A</code> 已按非递减顺序排序。</li></ol> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public int[] sortedSquares(int[] A) {
        int[] B=new int[A.length];
        int i=0;
        int j=A.length-1;
        int z=A.length-1;
        while(true){
            if(i&gt;j){
                break;
            }
            if(A[i]*A[i]&gt;A[j]*A[j]){
                B[z--]=A[i]*A[i];
                i++;
            }else{
                B[z--]=A[j]*A[j];
                j--;
            }
            
        }
        return B;
    }
}</code></pre> 
<h3 id="88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">88.合并两个有序数组</h3> 
<blockquote> 
 <p>给你两个有序整数数组 <em>nums1 </em>和 <em>nums2</em>，请你将 <em>nums2 </em>合并到 <em>nums1 </em>中<em>，</em>使 <em>num1 </em>成为一个有序数组。</p> 
 <p><strong>说明:</strong></p> 
 <ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n </em>。</li><li>你可以假设 <em>nums1 </em>有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li></ul> 
 <p><strong>示例:</strong></p> 
 <pre><code class="language-html">输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]</code></pre> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] nums=new int[nums1.length];
        for(int i=0;i&lt;m;i++){
            nums[i]=nums1[i];
        }
        int i=0;
        int j=0;
        int z=0;
        while(true){
            if(z==nums.length){
                break;
            }
            if(i&lt;m&amp;&amp;j&lt;n){
                if(nums[i]&gt;nums2[j]){
                    nums1[z++]=nums2[j++];
                }else{
                    nums1[z++]=nums[i++];
                }
            }else if(i==m){
                nums1[z++]=nums2[j++];
            }else if(j==n){
                nums1[z++]=nums[i++];
            }

        }
    }
}</code></pre> 
<h3 id="349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86">349.两个数组的交集</h3> 
<blockquote> 
 <p>给定两个数组，编写一个函数来计算它们的交集。</p> 
 <p><strong>示例 1:</strong></p> 
 <pre><code class="language-html hljs">输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
</code></pre> 
 <p><strong>示例 2:</strong></p> 
 <pre><code class="language-html hljs">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]</code></pre> 
 <p><strong>说明:</strong></p> 
 <ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int i=0;
        int j=0;
        int[] num=new int[nums1.length];
        int z=0;
        while(true){
            if(i==nums1.length||j==nums2.length){
                break;
            }
            if(i!=0&amp;&amp;nums1[i]==nums1[i-1]){
                i++;
                continue;
            }
            if(j!=0&amp;&amp;nums2[j]==nums2[j-1]){
                j++;
                continue;
            }
            if(nums1[i]==nums2[j]){
                num[z++]=nums1[i];
                i++;
                j++;
            }else if(nums1[i]&gt;nums2[j]){
                j++;
            }else{
                i++;
            }
        }
        int[] ans=new int[z];
        for(int k=0;k&lt;z;k++){
            ans[k]=num[k];
        }
        return ans;
    }
}</code></pre> 
<h3 id="830.%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE">830.较大分组的位置</h3> 
<blockquote> 
 <p>在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。</p> 
 <p>例如，在字符串 S = "abbxxxxzyy" 中，就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组。</p> 
 <p>我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。</p> 
 <p>最终结果按照字典顺序输出。</p> 
 <p>示例 1:</p> 
 <p>输入: "abbxxxxzzy"<br> 输出: [[3,6]]<br> 解释: "xxxx" 是一个起始于 3 且终止于 6 的较大分组。<br> 示例 2:</p> 
 <p>输入: "abc"<br> 输出: []<br> 解释: "a","b" 和 "c" 均不是符合要求的较大分组。<br> 示例 3:</p> 
 <p>输入: "abcdddeeeeaabbbcd"<br> 输出: [[3,5],[6,9],[12,14]]<br> 说明:  1 &lt;= S.length &lt;= 1000</p> 
 <p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/positions-of-large-groups</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String S) {
        List&lt;List&lt;Integer&gt;&gt; lis = new ArrayList();
        List&lt;Integer&gt; inlis = new ArrayList();
        int i=0;
        int j=0;
        int count = 0;
        while(true){
            if(S.charAt(i)==S.charAt(j)){
                count++;
                j++;
            }else{
                if(count&gt;=3){
                    inlis.add(i);
                    inlis.add(i+count-1);
                    lis.add(inlis);
                    inlis = new ArrayList();
                }
                i=j;
                count=0;
            }
            if(j&gt;=S.length()){
                if(count&gt;=3){
                    inlis.add(i);
                    inlis.add(i+count-1);
                    lis.add(inlis);
                    inlis = new ArrayList();
                }
                i=j;
                count=0;
                break;
            }
        }
        return lis;
    }
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c94181c6ddc644e655b4fc841ad79dd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机图形学学习笔记（5.2）：规则形体的表示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4586eb38e6865f947b217ef8e88c823a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">spring cloud feign 动态设置header</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>