<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 算法篇-链表的经典算法：判断回文链表、判断环链表与寻找环入口节点(“龟兔赛跑“算法实现) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 算法篇-链表的经典算法：判断回文链表、判断环链表与寻找环入口节点(“龟兔赛跑“算法实现)" />
<meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 链表的创建
2.0 判断回文链表说明
2.1 快慢指针方法
2.2 使用递归方式实现反转链表方法
2.3 实现判断回文链表 - 使用快慢指针与反转链表方法
3.0 判断环链表说明
3.1 实现判断环链表与寻找环入口节点 - &#34;龟兔赛跑&#34;算法实现
3.2 解释为什么第一次相遇后，兔、龟每一次都走一步最终会相遇且该节点是环入口节点的原因
4.0 实现判断回文链表、判断环链表且寻找环入口节点的完整代码
1.0 链表的创建 链表是一种常见的数据结构，用于存储一系列元素。链表由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表可以分为单向链表和双向链表，其中单向链表的节点只有一个指针指向下一个节点，而双向链表的节点有两个指针，分别指向前一个节点和后一个节点。 为后续实现算法方便，这里需要实现一个带哨兵节点的单链表。
代码如下：
import java.util.Iterator; public class List implements Iterable&lt;Integer&gt;{ private final Node sentry; static class Node { public int value; public Node next; public Node() { } public Node(int value, Node next) { this.value = value; this.next = next; } @Override public String toString() { return &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0c706635fc192d09307abbb7708b20e7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T22:07:02+08:00" />
<meta property="article:modified_time" content="2023-11-20T22:07:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 算法篇-链表的经典算法：判断回文链表、判断环链表与寻找环入口节点(“龟兔赛跑“算法实现)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong> </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="436" src="https://images2.imgbox.com/67/f8/UKLAQDTX_o.jpg" width="400"> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/09/f6/GEdNxszN_o.gif"></p> 
<p style="text-align:center;"> </p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">        1.0 链表的创建</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.0%20%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%20-%20%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.0%20%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%20-%20%E8%AF%B4%E6%98%8E" rel="nofollow">        2.0 判断回文链表说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%96%B9%E6%B3%95" rel="nofollow">        2.1 快慢指针方法</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%96%B9%E6%B3%95" rel="nofollow">        2.2 使用递归方式实现反转链表方法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%20-%20%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%20-%20%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%96%B9%E6%B3%95" rel="nofollow">        2.3 实现判断回文链表 - 使用快慢指针与反转链表方法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%AF%B4%E6%98%8E" rel="nofollow">        3.0 判断环链表说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%C2%A0-%20%22%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%22%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%C2%A0-%20%22%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%22%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" rel="nofollow">        3.1 实现判断环链表与寻找环入口节点 - "龟兔赛跑"算法实现</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.2%20%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B8%E9%81%87%E5%90%8E%EF%BC%8C%E5%85%94%E3%80%81%E9%BE%9F%E6%AF%8F%E4%B8%80%E6%AC%A1%E9%83%BD%E8%B5%B0%E4%B8%80%E6%AD%A5%E6%9C%80%E7%BB%88%E4%BC%9A%E7%9B%B8%E9%81%87%E4%B8%94%E8%AF%A5%E8%8A%82%E7%82%B9%E6%98%AF%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.2%20%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B8%E9%81%87%E5%90%8E%EF%BC%8C%E5%85%94%E3%80%81%E9%BE%9F%E6%AF%8F%E4%B8%80%E6%AC%A1%E9%83%BD%E8%B5%B0%E4%B8%80%E6%AD%A5%E6%9C%80%E7%BB%88%E4%BC%9A%E7%9B%B8%E9%81%87%E4%B8%94%E8%AF%A5%E8%8A%82%E7%82%B9%E6%98%AF%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">        3.2 解释为什么第一次相遇后，兔、龟每一次都走一步最终会相遇且该节点是环入口节点的原因</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E3%80%81%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%94%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E3%80%81%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%94%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        4.0 实现判断回文链表、判断环链表且寻找环入口节点的完整代码</a></strong></p> 
<hr> 
<p> </p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA">        1.0 链表的创建</h2> 
<p>        <strong>链表是一种常见的数据结构，用于存储一系列元素。链表由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表可以分为单向链表和双向链表，其中单向链表的节点只有一个指针指向下一个节点，而双向链表的节点有两个指针，分别指向前一个节点和后一个节点。        </strong></p> 
<p><strong>        为后续实现算法方便，这里需要实现一个<span style="color:#fe2c24;">带哨兵节点的单链表</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.util.Iterator;

public class List implements Iterable&lt;Integer&gt;{
    private final Node sentry;

    static class Node {
        public int value;
        public Node next;

        public Node() {
        }

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "value=" + value + "}";
        }
    }

    //外部类构造器，初始化哨兵节点
    public List() {
        sentry = new Node(-1,null);
    }

    //头插节点
    public void addFirst(int value) {
        this.sentry.next = new Node(value,this.sentry.next);
    }

    //尾插节点
    public void addLats(int value) {
        Node p = this.sentry;
        while (p.next != null) {
            p = p.next;
        }
        p.next = new Node(value,null);
    }

    //重写迭代器
    @Override
    public Iterator&lt;Integer&gt; iterator() {

        return new Iterator&lt;Integer&gt;() {
            Node p = sentry.next;

            @Override
            public boolean hasNext() {
                return p != null;
            }

            @Override
            public Integer next() {
                int k = p.value;
                p = p.next;
                return k;
            }
        };
    }

}
</code></pre> 
 <p>        <strong>简单对以上代码进行分析：将链表进行封装成一个<span style="color:#fe2c24;">外部类</span>，<span style="color:#fe2c24;">静态内部类</span>则是节点类进行封装。外部类的成员变量为一个哨兵节点，内部类的成员变量为 <span style="color:#fe2c24;">int value 值</span>、 <span style="color:#fe2c24;">Node next 指向下一个节点的引用变量</span>。外部类实现了<span style="color:#fe2c24;">头插节点</span>、<span style="color:#fe2c24;">尾插节点</span>、<span style="color:#fe2c24;">重写了迭代器</span>等。</strong></p> 
 <p><strong>需要了解可以点击该链接：<a href="https://blog.csdn.net/Tingfeng__/article/details/134231658?spm=1001.2014.3001.5501" title="Java 数据结构篇-实现单链表核心API-CSDN博客">Java 数据结构篇-实现单链表核心API-CSDN博客</a></strong></p> 
</blockquote> 
<p> </p> 
<h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.0%20%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%20-%20%E8%AF%B4%E6%98%8E" style="background-color:transparent;">        2.0 判断回文链表说明</h2> 
<p>        <strong>回文链表是指一个链表从头到尾和从尾到头读是一样的，也就是说，<span style="color:#fe2c24;">链表的节点值按照顺序排列和逆序排列是相同的</span>。例如，链表 1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1 就是一个回文链表，因为从头到尾读和从尾到头读都是 1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%96%B9%E6%B3%95">        2.1 快慢指针方法</h3> 
<p>        <strong>实现判断回文链表时需要用到<span style="color:#fe2c24;">快慢指针方法来寻找中间节点</span>。</strong></p> 
<p><strong>        具体思路：<span style="color:#fe2c24;">实现快慢指针找中间节点</span>，定义两个指针，对于 <span style="color:#fe2c24;">fast 指针</span>来说，每一次循环都要走两步，直到<span style="color:#fe2c24;"> fast == null</span> 或者 <span style="color:#fe2c24;">fast.next == null</span>，遇到这两种情况都要结束循环了，<span style="color:#fe2c24;">注意不要缺少了 fast.next == null 的情况，不然有可能抛出 "空指针异常"</span> ；对于<span style="color:#fe2c24;"> slow </span>指针来说，每一次循环都要走一步，直到退出循环后，若链表的节点的数量为<span style="color:#fe2c24;">奇数</span>时，则指向的节点就是中间节点。</strong></p> 
<p><strong>        若链表的节点的数量为<span style="color:#fe2c24;">偶数</span>时，则指向的节点是中间两个节点的后一个节点。例如链表 1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null，此时循环结束后，slow 指针指向的是靠后面值为 3 的节点。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //查找链表中的中间的节点(快慢指针):假如为奇数，则需要找到中间的节点；
    // 假如是偶数，则需要找到中间的两个节点的后一个节点。
    public Node searchMidNode() {
        //判断是否为空链表
        if (this.sentry.next == null) {
            return null;
        }

        Node fast = this.sentry.next;
        Node slow = this.sentry.next;
        while (fast!= null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%96%B9%E6%B3%95">        2.2 使用递归方式实现反转链表方法</h3> 
<p>       <span style="color:#fe2c24;"> </span><strong><span style="color:#fe2c24;">实现判断回文链表时需要实现反转链表。</span></strong></p> 
<p><strong>        具体思路：先考虑递出的<span style="color:#fe2c24;">终止条件</span>为：当<span style="color:#fe2c24;"> p.next == null </span>时，则返回 <span style="color:#fe2c24;">p </span>这个节点。再考虑在回归的过程中，需要将该 p 节点一直回归到回归过程结束为止。还需要将每一个节点都需要反转一下，<span style="color:#fe2c24;">p.next.next = p</span>，注意这里需要将 <span style="color:#fe2c24;">p.next </span>"暂时" 置为<span style="color:#fe2c24;"> null</span> ，<span style="color:#fe2c24;">p.next = null</span>，否则会陷入死循环中。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //用递归实现链表反转
    public Node reverseRecursion(Node p) {
        if (p.next == null) {
            return p;
        }

        Node last = reverseRecursion(p.next);
        p.next.next = p;
        p.next = null;
        return last;
    }</code></pre> 
 <p><strong>         用递归实现链表反转是其中一种的方法，还有四种方法可以实现链表反转，需要了解可以点击一下链接：<strong><a href="https://blog.csdn.net/Tingfeng__/article/details/134372327?spm=1001.2014.3001.5501" title="Java 算法篇-深入了解单链表的反转（实现：用 5 种方式来具体实现）-CSDN博客">Java 算法篇-深入了解单链表的反转（实现：用 5 种方式来具体实现）-CSDN博客</a></strong></strong> </p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%20-%20%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%96%B9%E6%B3%95" style="background-color:transparent;">        2.3 实现判断回文链表 - 使用快慢指针与反转链表方法</h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">先找到链表中的中间节点</span>，例如链表 1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null ，需要先找节点值为：3 的节点，<span style="color:#fe2c24;">可以用快慢指针来实现找中间节点</span>。然后将该节点后面的链表( 3 -&gt; 2 -&gt; 1 -&gt; null )进行反转，<span style="color:#fe2c24;">可以用递归来实现反转的链表</span>，得 1 -&gt; 2 -&gt; 3 -&gt; null 。接着，用旧链表进行与反转后的链表遍历比较，若出现不相同值的节点，则判断该链表不是回文链表；若遍历完都没有返回 false ，则判断该链表为回文链表。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //查找链表中的中间的节点(快慢指针):假如为奇数，则需要找到中间的节点；
    // 假如是偶数，则需要找到中间的两个节点的后一个节点。
    public Node searchMidNode() {
        //判断是否为空链表
        if (this.sentry.next == null) {
            return null;
        }

        Node fast = this.sentry.next;
        Node slow = this.sentry.next;
        while (fast!= null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }


    //用递归实现链表反转
    public Node reverseRecursion(Node p) {
        if (p.next == null) {
            return p;
        }

        Node last = reverseRecursion(p.next);
        p.next.next = p;
        p.next = null;
        return last;
    }



    //判断是否为回文链表
    public boolean isPalindromeList() {
        Node p = this.sentry.next;

        //需要先找到中间节点
        Node midNode = this.searchMidNode();
        //然后将中间节点往后的链表进行反转，反转可以用递归的方法。
        Node newMidNode = reverseRecursion(midNode);
        //接下来就要对旧节点的前半段链表进行循环遍历来比较了每一个节点的值是否相同了
        //当且仅当，当迭代到反转后的链表的最后一个为 null 时，结束循环
        while (newMidNode != null) {
            if (p.value != newMidNode.value) {
                return false;
            }
            p = p.next;
            newMidNode = newMidNode.next;
        }
        return true;

    }

</code></pre> 
 <p>       <strong> 需要注意的是，对与 p 链表来说，一旦实现了链表反转， p 自身的链表会改变。反转之后的链表<span style="color:#fe2c24;"> newMidNode == null 时，就该结束循环了</span>。而<span style="color:#fe2c24;">不能以 p == null 作为结束循环条件</span>，原因是当链表的节点为偶数时，那么反转后的链表会比 p 链表少一个节点，假如用 <span style="color:#fe2c24;">p == null</span> 作为结束循环的条件，那么当链表的节点数为偶数时，肯定会报 "空指针异常"，所以需要以 <span style="color:#fe2c24;">newMidNode == null 作为循环结束条件</span>。</strong></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%AF%B4%E6%98%8E">        3.0 判断环链表说明</h2> 
<p>        <strong>环链表是指链表中至少有一个节点的 next 指针指向了链表中的一个已经存在的节点，使得链表中存在环形结构。换句话说，链表中的一个节点的 next 指针指向了之前的某个节点，导致链表中存在环。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%C2%A0-%20%22%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%22%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">        3.1 实现判断环链表与寻找环入口节点 - "龟兔赛跑"算法实现</h3> 
<p>        <strong>具体思路：先来判断是否为环链表，可以比作为龟与兔的实际情景，当龟每一次走一步时，兔每一次走两步。<span style="color:#fe2c24;">即在相同时间下，兔所走的路程时龟的两倍</span>。</strong></p> 
<p><strong>        <span style="color:#fe2c24;">情况一：当兔第一次没有追上龟时，则不是环链表，直接返回 null 。</span></strong></p> 
<p><strong>        <span style="color:#fe2c24;">情况二：当兔第一次追上了龟时，可以判断为该链表为环形链表。</span>接着寻找环入口，步骤为：可以借助兔子来记录第一次相遇的节点，对于龟来说，移到头节点开始一步步走，同时，兔子这次也是一步步走，当他们第二次相遇时，当前节点就为环入口节点。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //判断是否闭环，如果是返回，则返回换入口；如果不是，则返回 null
    public Node isLoop() {
        Node fast = this.sentry.next;
        Node slow = this.sentry.next;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;


            if (slow == fast) {
                slow = this.sentry.next;

                //特例：当链表成为一个大环的时候(头尾相连),则直接返回

                //再相遇即为换入口节点
                while (true) {
                    if (slow == fast) {
                        return slow;
                    }
                    slow = slow.next;
                    fast = fast.next;

                }
            }
        }
        //从循环出来的不是闭环
        return null;
    }</code></pre> 
 <p>        <strong>需要注意的是，<span style="color:#fe2c24;">当该链表是首尾相连时，第一次相遇时，不用再走第二次了，因为此时正好是环入口节点，直接返回当前节点</span>。因此第一次相遇之后，将龟移到头节点处，接着就要判断此时龟与兔此时是否为同一个节点。否则，将龟移到头节点处后，没有先判断龟与兔是否为同一个节点，而将龟、兔同时走向下一步时，就会进入判断 if(slow == fast)，返回已经相对与环节点的下一个的节点。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.2%20%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B8%E9%81%87%E5%90%8E%EF%BC%8C%E5%85%94%E3%80%81%E9%BE%9F%E6%AF%8F%E4%B8%80%E6%AC%A1%E9%83%BD%E8%B5%B0%E4%B8%80%E6%AD%A5%E6%9C%80%E7%BB%88%E4%BC%9A%E7%9B%B8%E9%81%87%E4%B8%94%E8%AF%A5%E8%8A%82%E7%82%B9%E6%98%AF%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%9F%E5%9B%A0">        3.2 解释为什么第一次相遇后，兔、龟每一次都走一步最终会相遇且该节点是环入口节点的原因</h3> 
<p>        <strong>假设，起点到环入口点的距离为 a 个节点，n 为在环中转的圈数，k 为在圈中走的节点数(可以理解为不够一圈的余数)。可以得出一条公式：<span style="color:#fe2c24;">h = a + n 无论 n 为多少，h 都会刚好来到环入口处</span>。</strong></p> 
<p><strong>        那么在龟、兔第一次相遇时，对于<span style="color:#fe2c24;">龟来说，走了 g = a + n1 + k</span>，对于<span style="color:#fe2c24;">兔来说，走了 t = a + n2 + k</span>，对于 n1 ，n2 来说是多少都不在乎，但是两者的 k 、a 是一样的。上面说到，在第一次相遇的时候，兔所走的距离恰好是龟的距离的两倍，则龟走的距离 = 兔走的距离 - 龟走的距离，由此可得，相当与将龟走的距离换算为圈数：<span style="color:#fe2c24;"> g = t - g = n2 - n1 </span>，<span style="color:#fe2c24;">g = n3</span>，n3 具体是多少圈不在乎，反正知道是走了圈数，那么结合 <span style="color:#fe2c24;">a + n 永远走到的是环入口节点</span>，那么 n3 再加上 a 是不是也会走到环入口处？</strong></p> 
<p><strong>        所以此时，利用兔在与龟的第一次相遇的节点，与龟重新移回头节点处，接着龟与兔每一次走一步，知道他们相遇时所在的节点即为环入口节点。</strong></p> 
<p> </p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E3%80%81%E5%88%A4%E6%96%AD%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%94%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        4.0 实现判断回文链表、判断环链表且寻找环入口节点的完整代码</h2> 
<blockquote> 
 <pre><code class="language-java">import java.util.Iterator;

public class List implements Iterable&lt;Integer&gt;{
    private final Node sentry;

    static class Node {
        public int value;
        public Node next;

        public Node() {
        }

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "value=" + value + "}";
        }
    }

    //外部类构造器，初始化哨兵节点
    public List() {
        sentry = new Node(-1,null);
    }

    //头插节点
    public void addFirst(int value) {
        this.sentry.next = new Node(value,this.sentry.next);
    }

    //尾插节点
    public void addLats(int value) {
        Node p = this.sentry;
        while (p.next != null) {
            p = p.next;
        }
        p.next = new Node(value,null);
    }

    //重写迭代器
    @Override
    public Iterator&lt;Integer&gt; iterator() {

        return new Iterator&lt;Integer&gt;() {
            Node p = sentry.next;

            @Override
            public boolean hasNext() {
                return p != null;
            }

            @Override
            public Integer next() {
                int k = p.value;
                p = p.next;
                return k;
            }
        };
    }

    //查找链表中的中间的节点(快慢指针):假如为奇数，则需要找到中间的节点；
    // 假如是偶数，则需要找到中间的两个节点的后一个节点。
    public Node searchMidNode() {
        //判断是否为空链表
        if (this.sentry.next == null) {
            return null;
        }

        Node fast = this.sentry.next;
        Node slow = this.sentry.next;
        while (fast!= null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }


    //判断是否为回文链表
    public boolean isPalindromeList() {
        Node p = this.sentry.next;

        //需要先找到中间节点
        Node midNode = this.searchMidNode();
        //然后将中间节点往后的链表进行反转，反转可以用递归的方法。
        Node newMidNode = reverseRecursion(midNode);
        //接下来就要对旧节点的前半段链表进行循环遍历来比较了每一个节点的值是否相同了
        //当且仅当，当迭代到反转后的链表的最后一个为 null 时，结束循环
        while (newMidNode != null) {
            if (p.value != newMidNode.value) {
                return false;
            }
            p = p.next;
            newMidNode = newMidNode.next;
        }
        return true;

    }

    //用递归实现链表反转
    public Node reverseRecursion(Node p) {
        if (p.next == null) {
            return p;
        }

        Node last = reverseRecursion(p.next);
        p.next.next = p;
        p.next = null;
        return last;
    }


    //判断是否闭环，如果是返回，则返回换入口；如果不是，则返回 null
    public Node isLoop() {
        Node fast = this.sentry.next;
        Node slow = this.sentry.next;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;


            if (slow == fast) {
                slow = this.sentry.next;

                //特例：当链表成为一个大环的时候(头尾相连),则直接返回

                //再相遇即为换入口节点
                while (true) {
                    if (slow == fast) {
                        return slow;
                    }
                    slow = slow.next;
                    fast = fast.next;

                }
            }
        }
        //从循环出来的不是闭环
        return null;
    }

}</code></pre> 
 <p></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/aa/fa/HbmQLHIw_o.gif"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10a85ee3d2925b59f01861998f88a58d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">gradle8.0或者其他版本下载太慢或者time out超时（完美解决方法）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50164a7b33873c06ab8d773fb9d0847e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode设置前进、后退快捷键</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>