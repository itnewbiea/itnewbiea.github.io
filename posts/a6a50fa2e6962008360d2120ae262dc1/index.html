<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】——string的功能介绍及使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;】——string的功能介绍及使用" />
<meta property="og:description" content="前言：
在上期，我们简单的介绍了关于 模板和STL ，今天我就带领大家学习一下关于 【string】类。本期，我们主要讲解的是关于 【string】的基本介绍以及【string】类的常用接口说明。有了以上的基本认识之后，在下期，我们将模拟实现一个【string】类。
目录
（一）为什么学习string类？
1、 C语言中的字符串
（a）string类的引出🔥
2、两个面试题(暂不做讲解)
（二）标准库中的string类
1、 string类(了解)
2、编码
（a）ascll码
（b）万国码
（c）GBK字库
（三）string类对象的访问及遍历操作
1、遍历三剑客 🔥
（a）迭代器 begin()&#43;end()
（b）迭代器 rbegin()&#43;rend()
（c）for&#43;[]
（d）范围for
2、单个字符
（四）string类对象的常见构造
（五）string类对象的容量操作
1、size() 和 length()
2、capacity()
3、empty()
4、clear()
5、resize()
6、reserve()
（六）string类对象的修改操作
1、push_back()
2、append()
3、operator&#43;=
4、find() 和 npos()
5、rfind()
6、substr()
（七）string类非成员函数
（八）vs和g&#43;&#43;下string结构的说明
（九）总结
前言：
string 是C&#43;&#43;里面我们最常见的类之一，管理的是字符串。那什么是最常见的呢？
传统的类型，如内置类型只能表示一些基础的信息，当需要表示一些复杂的信息时就不适用了；假如我们要表示地址，表示身份证号码，此时再用日常的类型则无法较好的表示出来； （一）为什么学习string类？ 1、 C语言中的字符串 基于上述情况，在C语言中引入了字符串来管理
C语言中，字符串是以&#39;\0&#39;结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数；但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。 （a）string类的引出🔥 💨 假如此时我们的搬家了，这时需要修改家庭住址，地址信息变长了，这就会导致原先的字符串数组存放不下这么多的信息。
💨 因此在 C语言 中不能很好的进行管理，在C&#43;&#43; 中就提出了【string】类来管理字符串。
2、两个面试题(暂不做讲解) 把字符串转化为整数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a6a50fa2e6962008360d2120ae262dc1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-26T20:01:22+08:00" />
<meta property="article:modified_time" content="2023-04-26T20:01:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】——string的功能介绍及使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;"><strong>前言：</strong></span></p> 
<p><strong>在上期，我们简单的介绍了关于 模板和STL ，今天我就带领大家学习一下关于 【string】类。本期，我们主要讲解的是关于 【string】的基本介绍以及【string】类的常用接口说明。有了以上的基本认识之后，在下期，我们将模拟实现一个【string】类。</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3e/1d/JXetYWpg_o.jpg"></p> 
<p></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0string%E7%B1%BB%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0string%E7%B1%BB%EF%BC%9F" rel="nofollow">（一）为什么学习string类？</a></p> 
<p id="1%E3%80%81%C2%A0C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#1%E3%80%81%C2%A0C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">1、 C语言中的字符串</a></p> 
<p id="%EF%BC%88a%EF%BC%89string%E7%B1%BB%E7%9A%84%E5%BC%95%E5%87%BA%F0%9F%94%A5-toc" style="margin-left:80px;"><a href="#%EF%BC%88a%EF%BC%89string%E7%B1%BB%E7%9A%84%E5%BC%95%E5%87%BA%F0%9F%94%A5" rel="nofollow">（a）string类的引出🔥</a></p> 
<p id="2%E3%80%81%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98(%E6%9A%82%E4%B8%8D%E5%81%9A%E8%AE%B2%E8%A7%A3)-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%28%E6%9A%82%E4%B8%8D%E5%81%9A%E8%AE%B2%E8%A7%A3%29" rel="nofollow">2、两个面试题(暂不做讲解)</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB" rel="nofollow">（二）标准库中的string类</a></p> 
<p id="1%E3%80%81%20string%E7%B1%BB(%E4%BA%86%E8%A7%A3)-toc" style="margin-left:40px;"><a href="#1%E3%80%81%20string%E7%B1%BB%28%E4%BA%86%E8%A7%A3%29" rel="nofollow">1、 string类(了解)</a></p> 
<p id="2%E3%80%81%E7%BC%96%E7%A0%81-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%BC%96%E7%A0%81" rel="nofollow">2、编码</a></p> 
<p id="%EF%BC%88a%EF%BC%89ascll%E7%A0%81-toc" style="margin-left:80px;"><a href="#%EF%BC%88a%EF%BC%89ascll%E7%A0%81" rel="nofollow">（a）ascll码</a></p> 
<p id="%EF%BC%88b%EF%BC%89%E4%B8%87%E5%9B%BD%E7%A0%81-toc" style="margin-left:80px;"><a href="#%EF%BC%88b%EF%BC%89%E4%B8%87%E5%9B%BD%E7%A0%81" rel="nofollow">（b）万国码</a></p> 
<p id="%EF%BC%88c%EF%BC%89GBK%E5%AD%97%E5%BA%93-toc" style="margin-left:80px;"><a href="#%EF%BC%88c%EF%BC%89GBK%E5%AD%97%E5%BA%93" rel="nofollow">（c）GBK字库</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C" rel="nofollow">（三）string类对象的访问及遍历操作</a></p> 
<p id="1%E3%80%81%E9%81%8D%E5%8E%86%E4%B8%89%E5%89%91%E5%AE%A2%C2%A0%F0%9F%94%A5-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%81%8D%E5%8E%86%E4%B8%89%E5%89%91%E5%AE%A2%C2%A0%F0%9F%94%A5" rel="nofollow">1、遍历三剑客 🔥</a></p> 
<p id="%EF%BC%88a%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%20begin()%2Bend()-toc" style="margin-left:80px;"><a href="#%EF%BC%88a%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%20begin%28%29%2Bend%28%29" rel="nofollow">（a）迭代器 begin()+end()</a></p> 
<p id="%EF%BC%88b%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%20rbegin()%2Brend()-toc" style="margin-left:80px;"><a href="#%EF%BC%88b%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%20rbegin%28%29%2Brend%28%29" rel="nofollow">（b）迭代器 rbegin()+rend()</a></p> 
<p id="%EF%BC%88c%EF%BC%89for%2B%5B%5D-toc" style="margin-left:80px;"><a href="#%EF%BC%88c%EF%BC%89for%2B%5B%5D" rel="nofollow">（c）for+[]</a></p> 
<p id="%EF%BC%88d%EF%BC%89%E8%8C%83%E5%9B%B4for-toc" style="margin-left:80px;"><a href="#%EF%BC%88d%EF%BC%89%E8%8C%83%E5%9B%B4for" rel="nofollow">（d）范围for</a></p> 
<p id="2%E3%80%81%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6" rel="nofollow">2、单个字符</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0" rel="nofollow">（四）string类对象的常见构造</a></p> 
<p id="%EF%BC%88%E4%BA%94%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%BA%94%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C" rel="nofollow">（五）string类对象的容量操作</a></p> 
<p id="1%E3%80%81size()%20%E5%92%8C%20length()-toc" style="margin-left:40px;"><a href="#1%E3%80%81size%28%29%20%E5%92%8C%20length%28%29" rel="nofollow">1、size() 和 length()</a></p> 
<p id="2%E3%80%81capacity()-toc" style="margin-left:40px;"><a href="#2%E3%80%81capacity%28%29" rel="nofollow">2、capacity()</a></p> 
<p id="3%E3%80%81empty()-toc" style="margin-left:40px;"><a href="#3%E3%80%81empty%28%29" rel="nofollow">3、empty()</a></p> 
<p id="4%E3%80%81clear()-toc" style="margin-left:40px;"><a href="#4%E3%80%81clear%28%29" rel="nofollow">4、clear()</a></p> 
<p id="5%E3%80%81resize()-toc" style="margin-left:40px;"><a href="#5%E3%80%81resize%28%29" rel="nofollow">5、resize()</a></p> 
<p id="6%E3%80%81reserve()-toc" style="margin-left:40px;"><a href="#6%E3%80%81reserve%28%29" rel="nofollow">6、reserve()</a></p> 
<p id="%EF%BC%88%E5%85%AD%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%85%AD%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C" rel="nofollow">（六）string类对象的修改操作</a></p> 
<p id="1%E3%80%81push_back()-toc" style="margin-left:40px;"><a href="#1%E3%80%81push_back%28%29" rel="nofollow">1、push_back()</a></p> 
<p id="2%E3%80%81append()-toc" style="margin-left:40px;"><a href="#2%E3%80%81append%28%29" rel="nofollow">2、append()</a></p> 
<p id="3%E3%80%81operator%2B%3D-toc" style="margin-left:40px;"><a href="#3%E3%80%81operator%2B%3D" rel="nofollow">3、operator+=</a></p> 
<p id="4%E3%80%81find()%20%E5%92%8C%20npos()-toc" style="margin-left:40px;"><a href="#4%E3%80%81find%28%29%20%E5%92%8C%20npos%28%29" rel="nofollow">4、find() 和 npos()</a></p> 
<p id="5%E3%80%81rfind()-toc" style="margin-left:40px;"><a href="#5%E3%80%81rfind%28%29" rel="nofollow">5、rfind()</a></p> 
<p id="6%E3%80%81substr()-toc" style="margin-left:40px;"><a href="#6%E3%80%81substr%28%29" rel="nofollow">6、substr()</a></p> 
<p id="%EF%BC%88%E4%B8%83%EF%BC%89string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%83%EF%BC%89string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">（七）string类非成员函数</a></p> 
<p id="%EF%BC%88%E5%85%AB%EF%BC%89vs%E5%92%8Cg%2B%2B%E4%B8%8Bstring%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%85%AB%EF%BC%89vs%E5%92%8Cg%2B%2B%E4%B8%8Bstring%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">（八）vs和g++下string结构的说明</a></p> 
<p id="%EF%BC%88%E4%B9%9D%EF%BC%89%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B9%9D%EF%BC%89%E6%80%BB%E7%BB%93" rel="nofollow">（九）总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>前言：</strong></span></p> 
<blockquote> 
 <p><strong>string 是C++里面我们最常见的类之一，管理的是字符串。那什么是最常见的呢？</strong></p> 
</blockquote> 
<ul><li><strong>传统的类型，如内置类型只能表示一些基础的信息，当需要表示一些复杂的信息时就不适用了；</strong></li><li><strong>假如我们要表示地址，表示身份证号码，此时再用日常的类型则无法较好的表示出来；</strong></li></ul> 
<h2 id="%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0string%E7%B1%BB%EF%BC%9F">（一）为什么学习string类？</h2> 
<h3 id="1%E3%80%81%C2%A0C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">1、 C语言中的字符串</h3> 
<p><span style="color:#fe2c24;"><strong>基于上述情况，在C语言中引入了字符串来管理</strong></span></p> 
<ol><li><strong>C语言中，字符串是以'\0'结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数；</strong></li><li><strong>但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。</strong></li></ol> 
<h4 id="%EF%BC%88a%EF%BC%89string%E7%B1%BB%E7%9A%84%E5%BC%95%E5%87%BA%F0%9F%94%A5">（a）string类的引出🔥</h4> 
<p> 💨  假如此时我们的搬家了，这时需要修改家庭住址，地址信息变长了，这就会导致原先的字符串数组存放不下这么多的信息。</p> 
<p> 💨  <span style="color:#fe2c24;"><strong>因此在 C语言 中不能很好的进行管理，在C++ 中就提出了【string】类来管理字符串。</strong></span></p> 
<hr> 
<h3 id="2%E3%80%81%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98(%E6%9A%82%E4%B8%8D%E5%81%9A%E8%AE%B2%E8%A7%A3)">2、两个面试题(暂不做讲解)</h3> 
<p><a class="link-info" href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;&amp;tqId=11202&amp;rp=6&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="把字符串转化为整数">把字符串转化为整数</a></p> 
<p><a class="link-info" href="https://leetcode.cn/problems/add-strings/" rel="nofollow" title="字符串相加">字符串相加</a></p> 
<p>在OJ中，有关字符串的题目基本以string类的形式出现，而且在常规工作中，为了简单、方便、快捷，基本 都使用string类，很少有人去使用C库中的字符串操作函数。</p> 
<hr> 
<h2 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB">（二）标准库中的string类</h2> 
<h3 id="1%E3%80%81%20string%E7%B1%BB(%E4%BA%86%E8%A7%A3)">1、 string类(了解)</h3> 
<blockquote> 
 <p><strong>首先，在正式的介绍之前，我先给大家说明一点：</strong></p> 
</blockquote> 
<ul><li>在接下来的学习中，我们要学会去浏览权威的文档，对于那些全是英文的文档，大家不要害怕。作为一个合格的 “程序猿” ，学会看文档是必不可少的一项技能。</li></ul> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>【string】文档介绍</strong></span>：<a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/" rel="nofollow" title="string类的文档介绍">string类的文档介绍</a></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>接下来，我通过文档简单的介绍一下【string】，看文档里面是怎么“解释说明的”。</strong></span></p> 
</blockquote> 
<p>此时可能就会有小伙伴有 疑问了。我介绍过说【string】是一个模板。但是根据之前的学习觉得这个跟模板没多大的关系啊似乎？</p> 
<ul><li><strong>其实【string】确实是一个模板，只是被 typedef 出来的而已，当我们打开文档时。</strong></li></ul> 
<p>我们可以发现如下字眼：</p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/de/22/8lqfisge_o.png" width="737"></p> 
<ul><li><strong> 此时，当处于目前页面的文档往回退一页时，大家可以发现如下字眼：</strong></li></ul> 
<p><img alt="" height="371" src="https://images2.imgbox.com/eb/77/3P9wJ2ZD_o.png" width="1112"></p> 
<ul><li><strong> 由于一些历史的原因，string 还提供了 宽字符的存在，紧接着由于 <span style="color:#fe2c24;">C++11</span> 的提出，又新增了两个，分别是<span style="color:#fe2c24;">【u 16string】</span>和 <span style="color:#fe2c24;"> 【u 32string】</span></strong></li></ul> 
<p> <img alt="" height="704" src="https://images2.imgbox.com/4d/b5/9bMsgMZE_o.png" width="1200"></p> 
<p><strong><span style="background-color:#ffd900;"> 那么此时就有很多小伙伴有疑问了，为什么要引入这么多呢？</span></strong></p> 
<p> 💨  其实，大家在这一部分要这么理解。大家在看待这个【string】的时候其实就像我们之前学习的 “顺序表” 一样，底层管理的是一个字符数组，只是支持增删查改；</p> 
<p>因此，换句话说，我们可以这样理解：</p> 
<ol><li><strong><span style="color:#fe2c24;">【string】</span>   ：管理的是 “char”类型的数组；</strong></li><li><strong><span style="color:#fe2c24;">【wstring】</span>：管理的是 “wchar” 类型的数组；</strong></li><li><strong><span style="color:#fe2c24;">【u 16string】</span><span style="color:#0d0016;">和 </span><span style="color:#fe2c24;"> 【u 32string】：</span><span style="color:#0d0016;">管理的是 “char16_t”和“char32_t” 的数组。</span></strong></li></ol> 
<p><strong>区别在于 ：</strong></p> 
<ol><li><strong><span style="color:#fe2c24;">【string】</span><span style="color:#0d0016;">：一个字符表示<span style="background-color:#4da8ee;">一个</span>字节</span></strong></li><li><strong><span style="color:#fe2c24;">【wstring】和 【u 16string】</span>：<span style="color:#0d0016;">一个字符表示<span style="background-color:#38d8f0;">两个</span>字节</span></strong></li><li><strong><span style="color:#0d0016;"> </span><span style="color:#fe2c24;">【u 32string】</span><span style="color:#0d0016;">：一个字符表示<span style="background-color:#38d8f0;">四个</span>字节</span></strong></li></ol> 
<blockquote> 
 <p><strong>因此，至于为什么引入这么多。其实目的只有一个就是<span style="color:#fe2c24;">为了达到管理不同字符数组的需求</span>。</strong></p> 
</blockquote> 
<hr> 
<h3 id="2%E3%80%81%E7%BC%96%E7%A0%81">2、编码</h3> 
<h4 id="%EF%BC%88a%EF%BC%89ascll%E7%A0%81">（a）ascll码</h4> 
<p>理解上述问题之后，此时又引出了一个问题。</p> 
<ul><li><strong>那就是为了达到管理不同的字符的需求，我们需要先理解 “编码” 的基本知识！！！</strong></li></ul> 
<p>对于 “编码” 这个东西，我相信大家在之前肯定已经听说过了，对其都有或多或少的了解。那大家知道，我们第一个接触的编码是什么吗？</p> 
<ul><li><span style="color:#fe2c24;"><strong>其实就是在平常学习中听得最多的 ASCLL编码 了。</strong></span></li></ul> 
<p><img alt="" height="546" src="https://images2.imgbox.com/79/97/FXlS5CoP_o.png" width="1126"></p> 
<p> 此时我们要显示英文是不是很简单啊！因为英文最主要的就是由以下几部分组成：</p> 
<ol><li><span style="color:#fe2c24;"><strong>26个字母，如果区别大小写，那就是52个；</strong></span></li><li><span style="color:#fe2c24;"><strong>在加上数字；</strong></span></li><li><span style="color:#fe2c24;"><strong>最后就是标点符号</strong></span></li></ol> 
<p></p> 
<p>了解以上之后，此时我问大家计算机能否直接存储以上这些信息呢？</p> 
<ul><li><strong>铁铁的是不能的，因为在计算机内存里面一切皆是二进制的 0和1 ；</strong></li><li><strong>所以基于上述原因，需要建立一张对应关系的映射表，因此美国基于常见的字符建立了一张ASCll表</strong></li></ul> 
<p><img alt="" height="768" src="https://images2.imgbox.com/3c/60/O5uYqekj_o.png" width="1194"></p> 
<p></p> 
<ul><li><strong>假设我要存字符 ‘a’ ，此时我就去查这张表，对于‘a’，在表里面映射的就是 97，因此只需存入一个97 在计算机里面即可。</strong></li></ul> 
<p></p> 
<p>接下来，我们通过代码演示一下：</p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/23/1a/sKVW0ZFO_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>解释说明👇</strong></span></p> 
<ol><li><strong> 在上述的代码中，我们写了一段简单的代码；</strong></li><li><strong>此时我们调试起来，我没有使用监视窗口，我直接使用底层的内存去查看；</strong></li><li><strong>大家可以发现，对于我们给出的 “apple” ，在内存中，首字节的 61 即表示 “a”因为在内存下是16进制，转换过来就是 “a”对应的ascll码值 97；</strong></li><li><strong>相同的，后面的字符依次按照这个规则，就可以验证上述编码表的内容。</strong></li></ol> 
<hr> 
<h4 id="%EF%BC%88b%EF%BC%89%E4%B8%87%E5%9B%BD%E7%A0%81">（b）万国码</h4> 
<p><strong>但是此时就遇到一个问题，假如我们就照搬这个ascll码，中文是否可以显示呢？</strong></p> 
<ol><li><strong>答案很明显，中文要在计算机上显示是十分困难的。</strong></li><li><strong>对于美国这套相对来说还还是很简单的，就那么些符号，要显示文字就用符号组成；</strong></li><li><strong>但是对于我们中国文字来说，我们走的是象形文字的路线。汉字都有差不多十万个，对于美国那套就像是一个汉字由一个符号组成，但是我们每个汉字都是独立的意思；</strong></li><li><strong>还有数量多了之后，一个字节最多可以表示256个，但是我们的文字是远超于256的；</strong></li><li><strong>同时，世界上不同的国家语言文字表示还各不相同；</strong></li><li><strong>因此，基于上诉这种情况，为了能够更好的显示以及推广，就有 推出了 <span style="color:#fe2c24;">【Unicode】</span>。</strong></li></ol> 
<p></p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/2d/a0/sB675akU_o.png" width="1114"></p> 
<blockquote> 
 <p> 万国码可以表示很多国家的文字，但是同时也会出现一个分歧。</p> 
</blockquote> 
<ol><li><strong>比如像有些国家它的文字最多上万个甚至更少，而像我们中国那就是多的数不胜数；</strong></li><li><strong>在这个地方假如有一个字节又不好表示，两个字节又太多了；</strong></li><li><strong>因此，基于这种情况万国码又开始划分为三种：<span style="color:#fe2c24;">UTF-8 、UTF-16、 UTF-32</span></strong></li></ol> 
<p><strong><span style="color:#fe2c24;">UTF-8</span></strong></p> 
<ul><li><strong>UTF-8以字节为单位对统一码进行编码。同时<span style="background-color:#f3f3f4;">兼容 ascll码</span>；</strong></li><li><strong>特点是对不同范围的字符使用不同长度的编码</strong></li><li><strong>最重要的一点是支持变长的，意识就是同时支持 1字节，也可以使用2字节，最多支持4字节</strong></li></ul> 
<p><strong><span style="color:#fe2c24;">UTF-16</span></strong></p> 
<ul><li><strong>UTF-16编码以16位<a href="https://baike.baidu.com/item/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0/9203544?fromModule=lemma_inlink" rel="nofollow" title="无符号整数">无符号整数</a>为单位。</strong></li></ul> 
<p><strong><span style="color:#fe2c24;">UTF-32</span></strong></p> 
<ul><li><strong>UTF-32编码以32位无符号整数为单位。</strong></li></ul> 
<hr> 
<h4 id="%EF%BC%88c%EF%BC%89GBK%E5%AD%97%E5%BA%93">（c）GBK字库</h4> 
<p>而对于我们中国来说，由于历史的原因，导致有些文字太复杂或者其他原因，在老外的那一套框架中就没有我们想要的那个字。</p> 
<ul><li><strong>因此，就衍生出了我们中国自己的这样一个规范，名为——GBK字库</strong></li></ul> 
<hr> 
<p>假如此时我们写了这样的一段代码</p> 
<pre><code class="language-cpp">int main()
{
	char str[] = "apple";

	char str1[] = "中国";
	cout &lt;&lt; sizeof(str1) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p> 大家知道对于 【str1】的大小是多少吗？</p> 
<p><strong>我们在通过调试去观察</strong></p> 
<p><img alt="" height="477" src="https://images2.imgbox.com/08/af/Ry7xhSiI_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>解释：</strong></span></p> 
<p><strong>对于 str1 显示的为什么是负的呢？</strong></p> 
<ul><li><strong>很简单，因为它要兼容ascll，因此它在这里运行的时候不能用正的值，就是第一个比特位是 0的那个要兼容ascll，它是 char 那个系列的；</strong></li><li><strong>此时对于 char的第一个字节如果是 0就去ascll中查，如果不是 0，就需要用两个组合起来去查后面这个编码表。</strong></li></ul> 
<p></p> 
<p>我们在写出这样的几行代码，再带大家看看最终的结果是什么：</p> 
<pre><code class="language-cpp">int main()
{
	char str[] = "apple";

	char str1[] = "中国";
	cout &lt;&lt; sizeof(str1) &lt;&lt; endl;

	str1[3]--;
	cout &lt;&lt; str1 &lt;&lt; endl;

	str1[3]--;
	cout &lt;&lt; str1 &lt;&lt; endl;

	str1[3]--;
	cout &lt;&lt; str1 &lt;&lt; endl;

	str1[3]++;
	cout &lt;&lt; str1 &lt;&lt; endl;

	str1[3]++;
	cout &lt;&lt; str1 &lt;&lt; endl;

	str1[3]++;
	cout &lt;&lt; str1 &lt;&lt; endl;
	return 0;
}</code></pre> 
<ul><li><strong>输出结果如下：</strong></li></ul> 
<p><img alt="" height="472" src="https://images2.imgbox.com/1b/87/r0GdiBfF_o.png" width="762"></p> 
<ul><li><span style="color:#fe2c24;"><strong>从上可见，汉字在经过编码表的时候不是随便编的，他把同音字编到一起去了</strong></span></li></ul> 
<blockquote> 
 <p>对于这种情况在生活中我们可以举个简单的例子来说明，大家知道<strong>“净网行动”</strong>吧！！</p> 
</blockquote> 
<ol><li><strong>当我们在峡谷中遇到那些打得又菜，专门来演你的人之后，此时如果你脾气好点就是打字问候对方。但是当我们输入我们想打的字时显示的却是 ‘###’这样的情况；</strong></li><li><strong>所以当我们有编码表时，由于同音词很多，我们可以打同音字。游戏厂家为了营造和谐的上网氛围就会利用这种手段把这些字全部屏蔽掉，对于做的好厂家，此时当我们在输入一些字时，连同音字都打不出来。</strong></li></ol> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>小结：</strong></span></p> 
<ul><li><strong>因此，计算机在C++ 里面要与时俱进的去这样发展，为了应对不同的编码，C++就引入了模板：不管你是【char】的数组，还是【wchar】类型的数组都可以支持。所以【string】类才搞得这么的复杂。</strong></li></ul> 
<p></p> 
<hr> 
<h2 id="%EF%BC%88%E4%B8%89%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C">（三）string类对象的访问及遍历操作</h2> 
<h3 id="1%E3%80%81%E9%81%8D%E5%8E%86%E4%B8%89%E5%89%91%E5%AE%A2%C2%A0%F0%9F%94%A5">1、遍历三剑客 🔥</h3> 
<blockquote> 
 <p><strong>首先，我们要谈的就是关于进行string遍历的三种方法：</strong></p> 
</blockquote> 
<h4 id="%EF%BC%88a%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%20begin()%2Bend()">（a）迭代器 begin()+end()</h4> 
<p><span style="color:#fe2c24;"><strong>begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</strong></span></p> 
<ul><li><strong>代码展示：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
    //遍历和读写容器的数据
	string str("hello world");

	string::iterator it = str.begin();
	while (it != str.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;

	return 0;
}</code></pre> 
<ul><li><strong>但是，此时又有一个问题，那就是你这传的是普通对象，那对于 const 对象这样做是否可以呢？</strong></li><li><strong>当我们如下这样去赋值时，是否还可以去遍历字符串呢？</strong></li></ul> 
<pre><code class="language-cpp">void Func(const string&amp; s)
{
	string::iterator it = s.begin();
	while (it != s.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;
}

int main()
{
	string str("hello world");

	// 2.正向迭代器
	string::iterator it = str.begin();
	while (it != str.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;
	Func(str);

	return 0;
}</code></pre> 
<ul><li><strong>当我们去编译代码时，就会自动出现报错的情况</strong></li></ul> 
<p><img alt="" height="208" src="https://images2.imgbox.com/4e/be/mJgQchzt_o.png" width="1200"></p> 
<ul><li><strong> 那什么原因呢？我们可以去结合文档查看 begin接口</strong></li></ul> 
<p><img alt="" height="413" src="https://images2.imgbox.com/7c/9e/xh7vUBnV_o.png" width="1200"></p> 
<ul><li><strong> 所以，此时我们需要使用【const】版本的迭代器：</strong></li></ul> 
<pre><code class="language-cpp">void Func(const string&amp; s)
{
    //遍历和读容器的数据，不能写
    string::const_iterator it = s.begin();
    while (it != s.end())
    {
        //*it += 1;  //此时const迭代器就不允许进行修改操作

        cout &lt;&lt; *it &lt;&lt; " ";
        ++it;
    }
    cout &lt;&lt; endl;
}

int main()
{
    string str("hello world");

    // 2.正向迭代器
    string::iterator it = str.begin();
    while (it != str.end())
    {
        cout &lt;&lt; *it &lt;&lt; " ";
        ++it;
    }
    cout &lt;&lt; endl;
    Func(str);

    return 0;
}</code></pre> 
<p></p> 
<p><strong>大家不难发现上述的这种方式是从前往后遍历的。</strong></p> 
<p><strong>那么当我们想从后往前遍历，string 是否支持呢？</strong></p> 
<ul><li>因此为了满足以上这种需求，在 【string】类中还引入了关键字—— <strong><span style="color:#fe2c24;">rbegin </span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;"> rend</span></strong></li></ul> 
<hr> 
<h4 id="%EF%BC%88b%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%20rbegin()%2Brend()">（b）迭代器 rbegin()+rend()</h4> 
<ul><li><strong>代码展示：</strong></li></ul> 
<pre><code class="language-cpp">
	string::reverse_iterator rit_1 = str.rbegin();
	while (rit_1 != str.rend())
	{
		cout &lt;&lt; *rit_1 &lt;&lt; " ";
		++rit_1;
	}
	cout &lt;&lt; endl;</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>此处也有 const类型，与上述的同理！！！ </strong></span></li></ul> 
<hr> 
<h4 id="%EF%BC%88c%EF%BC%89for%2B%5B%5D">（c）for+[]</h4> 
<p><span style="color:#fe2c24;"><strong>返回pos位置的字符，const string类对象调用</strong></span></p> 
<ul><li><strong>代码展示：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str("hello world");

	for (size_t i = 0; i &lt; str.size(); ++i)
		cout &lt;&lt; str[i] &lt;&lt; " ";

	return 0;
}</code></pre> 
<h4 id="%EF%BC%88d%EF%BC%89%E8%8C%83%E5%9B%B4for">（d）范围for</h4> 
<p><span style="color:#fe2c24;"><strong>C++11支持更简洁的范围for的新遍历方式</strong></span></p> 
<ul><li><strong>代码展示：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str("hello world");

	for (auto e : str)
		cout &lt;&lt; e &lt;&lt; " ";

	return 0;
}</code></pre> 
<p></p> 
<ul><li><strong>整体代码如下：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str("hello world");


	// 3种遍历方式：
	// 需要注意的以下三种方式除了遍历string对象，还可以遍历是修改string中的字符，
	// 另外以下三种方式对于string而言，第一种使用最多
	
	// 1. for+operator[]
	for (size_t i = 0; i &lt; str.size(); ++i)
		cout &lt;&lt; str[i] &lt;&lt; " ";

	cout &lt;&lt; endl;

	// 2.正向迭代器
	string::iterator it = str.begin();
	while (it != str.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;


	// 3.反向迭代器
	// string::reverse_iterator rit = s.rbegin();
	string::reverse_iterator rit_1 = str.rbegin();
	while (rit_1 != str.rend())
	{
		cout &lt;&lt; *rit_1 &lt;&lt; " ";
		++rit_1;
	}
	cout &lt;&lt; endl;

	// C++11之后，直接使用auto定义迭代器，让编译器推到迭代器的类型
	auto rit_2 = str.rbegin();
	while (rit_2 != str.rend())
	{
		cout &lt;&lt; *rit_2 &lt;&lt; " ";
		++rit_2;
	}
	cout &lt;&lt; endl;

	// 4.范围for
	for (auto e : str)
		cout &lt;&lt; e &lt;&lt; " ";
	cout &lt;&lt; endl;

	return 0;
}</code></pre> 
<hr> 
<h3 id="2%E3%80%81%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6">2、单个字符</h3> 
<ul><li><strong>不仅如此，除了上述的可以遍历整个字符串之外，string还可以遍历一个字符。具体如下：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str("hello world");

	cout &lt;&lt; str[8] &lt;&lt; endl; 
}</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>我们可以通过输入不同的数字下标来达到遍历每个字符的目的。</strong></span></li></ul> 
<p></p> 
<ul><li><span style="color:#0d0016;"><strong>同时我们还可以修改字符串中的某个字符：</strong></span></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");

	//对str1，可以修改字符串中的某个字符
	cout &lt;&lt; str1[8] &lt;&lt; endl;
	str1[8] = 'E';
	cout &lt;&lt; str1 &lt;&lt; endl;

	return 0;
}</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>本来str[8]的位置的字符是 r，经过我们的手动修改，就把原本的 字符‘r’ ，改为了‘E’，输出结果如下：</strong></span></li></ul> 
<p><img alt="" height="106" src="https://images2.imgbox.com/2f/e2/gG7AO1bK_o.png" width="654"></p> 
<p></p> 
<ol><li><strong>但是以上对字符串进行修改的操作，在const类型下则是不可以的，编译器会提示报错：</strong></li></ol> 
<pre><code class="language-cpp">
int main()
{
	
	const string str2("Hello world");

	//对于str2，则不能修改字符串中的某个字符
	cout &lt;&lt; str2[8] &lt;&lt; endl;
	str2[8] = 'E';
	cout &lt;&lt; str2 &lt;&lt; endl; //编译失败，因为const类型对象不能修改

	return 0;
}</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>当我们运行代码，最后编译器会提示报错：</strong></span></li></ul> 
<p><img alt="" height="204" src="https://images2.imgbox.com/c7/15/EmliHeMI_o.png" width="738"></p> 
<p></p> 
<ul><li><strong>整体代码如下：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");
	const string str2("Hello world");

	//对str1，可以修改字符串中的某个字符
	cout &lt;&lt; str1[8] &lt;&lt; endl;
	str1[8] = 'E';
	cout &lt;&lt; str1 &lt;&lt; endl;

	//对于str2，则不能修改字符串中的某个字符
	cout &lt;&lt; str2[8] &lt;&lt; endl;
	str2[8] = 'E';
	cout &lt;&lt; str2 &lt;&lt; endl; //编译失败，因为const类型对象不能修改

	return 0;
}</code></pre> 
<hr> 
<h2 id="%EF%BC%88%E5%9B%9B%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0">（四）string类对象的常见构造</h2> 
<p></p> 
<ul><li><strong>整体代码如下：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");
	string str2="hello world";  //构造和str1一样的效果

	string();//构造空的string类对象，即空字符串

	//复制构造函数,构造 str1 的副本。
	string s1(str1);
	cout &lt;&lt; s1 &lt;&lt; endl;//hello world

	//子字符串构造函数
	//复制 str1 中从字符位置 8, 开始并跨越 3 字符的部分
	string s2(str1, 8, 3);
	cout &lt;&lt; s2 &lt;&lt; endl;  //rld

	//复制 s3 指向的以 null 结尾的字符序列
	//表示复制 s3指向的前六个字符
	string s3("have a nice day", 6);
	cout &lt;&lt; s3 &lt;&lt; endl;  //have a

	//范围构造函数
	//以相同的顺序复制区域【str1.begin(), str1.begin() + 7】 中的字符序列。
	string s4(str1.begin(), str1.begin() + 7);
	cout &lt;&lt; s4 &lt;&lt; endl; //hello w

    //填充构造函数
	//用字符 x 的 10 个连续副本填充字符串,string类对象中包含10个字符x
	string s5(10, 'x');
	cout &lt;&lt; s5 &lt;&lt; endl; //xxxxxxxxxx

	
	string s6(10, 42);
	cout &lt;&lt; s6 &lt;&lt; endl; //**********


	return 0;
}</code></pre> 
<hr> 
<h2 id="%EF%BC%88%E4%BA%94%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C">（五）string类对象的容量操作</h2> 
<p>接下来，我们将要学习的便是关于 【string】类的容量操作了。主要学习的包括以下几个基本操作的内容：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><span style="color:#fe2c24;"><strong>函数名称</strong></span></td><td style="text-align:center;"><span style="color:#fe2c24;"><strong>功能说明</strong></span></td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/size/" rel="nofollow" title="size">size</a> （重点）</td><td>返回字符串有效字符长度</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/length/" rel="nofollow" title="length">length</a></td><td>返回字符串有效字符长度</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/capacity/" rel="nofollow" title="capacity">capacity</a></td><td>返回空间总大小</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/empty/" rel="nofollow" title="empty">empty</a>（重点）</td><td>检测字符串释放为空串，是返回true，否则返回false</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/clear/" rel="nofollow" title="clear">clear</a>（重点）</td><td>清空有效字符</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/reserve/" rel="nofollow" title="reserve">reserve</a>（重点）</td><td>为字符串预留空间**</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/resize/" rel="nofollow" title="resize">resize</a>（重点）</td><td>将有效字符的个数该成n个，多出的空间用字符c填充</td></tr></tbody></table> 
<h3 id="1%E3%80%81size()%20%E5%92%8C%20length()">1、size() 和 length()</h3> 
<blockquote> 
 <p><strong>大家看到上述的表之后，可能会觉得奇怪。我第一个写出来的是 size() ，为什么还要有一个 length() 呢？</strong></p> 
</blockquote> 
<ul><li><strong>别着急，我们通过代码具体感受一下二者：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");
	cout &lt;&lt; str1.size() &lt;&lt; endl;
	cout &lt;&lt; str1.length() &lt;&lt; endl;

	return 0;
}</code></pre> 
<ul><li><strong>上述的代码大家觉得最后的结果是一样的吗？我在这就不卖关子了，直接编译代码，最终结果如下图所示：</strong></li></ul> 
<p><img alt="" height="203" src="https://images2.imgbox.com/0a/33/Mmm2Eak1_o.png" width="662"></p> 
<p></p> 
<ul><li><span style="color:#0d0016;"><strong>从上我们不难看出，二者的功能都是相同的；</strong></span></li></ul> 
<blockquote> 
 <p>那这两者到底有什么关系呢？我给大家浅浅的解释一下：</p> 
</blockquote> 
<p>对于这个string 呢，其实还涉及到一个发展历史。具体是什么呢？</p> 
<ol><li>其实string 相对STL的出来还要早一些，严格来说是不属于STL的，它不是在STL下产生的，而是在C++标准库下产生的；</li><li>最开始的出现的时候呢，它的名字就叫做【length 】，最开始设计的时候对于字符串使用 【length】是不是很符合这样的需求；</li><li>之后随着STL的发展，因为在标准库之中已经有了这样的一个雏形了，所以 STL没有加它，但是从功法用途上就是一个数据结构；</li><li>为了跟其他的数据结构保持一致，对于顺序表，链表这样的用【length】还说得过去，但是对于 “树”这样的数据结构却是显得不合适的；</li><li>因此，基于上述这样的原因便引出了 size()。<span style="color:#fe2c24;"><strong>size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一 致，一般情况下基本都是用size()。</strong></span></li></ol> 
<hr> 
<h3 id="2%E3%80%81capacity()">2、capacity()</h3> 
<p>很明显，主要的功能就是 ：返回已分配存储的大小</p> 
<ul><li><strong>代码演示：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");

	
	//capacity
	cout &lt;&lt; str1.capacity() &lt;&lt; endl; //16


	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
<ol><li>其实呢，对于上述的字符串分配的空间的大小。严格意义上来说是 【16】。</li><li>vs下面的这个空间是不包含 \0 的，它不认为 \0 是有效字符，它认为 \0 是标识字符，string的结果使用 \0进行表示的。</li></ol> 
<p></p> 
<ul><li><strong>接下来，我通过监视窗口带大家瞧一瞧</strong></li></ul> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/eb/c3/sGvyRA1F_o.png" width="1200"></p> 
<p></p> 
<hr> 
<h3 id="3%E3%80%81empty()">3、empty()</h3> 
<p>顾名思义就是判断字符串是否为空的一个接口函数。如果<a href="https://legacy.cplusplus.com/basic_string::length" rel="nofollow" title="字符串长度">字符串长度</a>为 0，则为 true，否则为 false。</p> 
<hr> 
<h3 id="4%E3%80%81clear()">4、clear()</h3> 
<p>主要功能就是 ：清除字符串</p> 
<ul><li><strong>代码展示：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");

	cout &lt;&lt; str1.size() &lt;&lt; endl;  //11
	cout &lt;&lt; str1 &lt;&lt; endl;         //hello world

	str1.clear();
	cout &lt;&lt; str1.size() &lt;&lt; endl; //0
	cout &lt;&lt; str1 &lt;&lt; endl;        //被清空了

	return 0;
}</code></pre> 
<ul><li><strong>结果展示：</strong></li></ul> 
<p><img alt="" height="332" src="https://images2.imgbox.com/53/3a/oBgWqi9p_o.png" width="740"></p> 
<ul><li><span style="color:#fe2c24;"><strong> clear()只是将string中有效字符清空，不改变底层空间大小。</strong></span></li></ul> 
<hr> 
<p></p> 
<h3 id="5%E3%80%81resize()">5、resize()</h3> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">主要功能</span>：调整字符串大小。相当于【开空间+初始化】</strong></p> 
</blockquote> 
<p><br><strong><span style="background-color:#ffd900;">常见三种用法</span></strong></p> 
<ul><li><strong>1、如果n小于当前的容器大小，那么则保留容器的前n个元素，去除（erasing）超过的部分。</strong></li><li><strong>2、如果n大于当前的容器大小，则通过在容器结尾插入(inserting)适合数量的元素使得整个容器大小达到n。且如果给出val，插入的新元素全为val，否则，执行默认构造函数。</strong></li><li><strong>3、如果n大于当前容器的容量（capacity）时，则会自动重新分配一个存储空间。</strong></li></ul> 
<p></p> 
<p>​​​</p> 
<ul><li><strong>代码展示：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");


	// 将str中有效字符个数增加到12个，多出位置用'X'进行填充
	// “xxxxxxxxx”
	str1.resize(12, 'X');
	cout &lt;&lt; str1.size() &lt;&lt; endl;     //12
	cout &lt;&lt; str1.capacity() &lt;&lt; endl; //15
	cout &lt;&lt; str1 &lt;&lt; endl;            //hello worldX


	//将str中有效字符个数增加到15个，多出位置用缺省值'\0'进行填充
	// "xxxxxxxxxx\0\0\0\0\0"
	// 注意此时s中有效字符个数已经增加到15个
	str1.resize(15);
	cout &lt;&lt; str1.size() &lt;&lt; endl;     //15
	cout &lt;&lt; str1.capacity() &lt;&lt; endl; //15
	cout &lt;&lt; str1 &lt;&lt; endl;            //hello world    
	cout &lt;&lt; endl;


	// 将str中有效字符个数增加到20个，多出位置用缺省值'X'进行填充
	//注意此时容量的变化
	str1.resize(20 ,'X');
	cout &lt;&lt; str1.size() &lt;&lt; endl;     //20
	cout &lt;&lt; str1.capacity() &lt;&lt; endl; //31
	cout &lt;&lt; str1 &lt;&lt; endl;            //hello worldXXXXXXXXX  
	cout &lt;&lt; endl;


	// 将str中有效字符个数缩小到5个
	str1.resize(5);
	cout &lt;&lt; str1.size() &lt;&lt; endl;       //5
	cout &lt;&lt; str1.capacity() &lt;&lt; endl;   //15
	cout &lt;&lt; str1 &lt;&lt; endl;              //hello
	cout &lt;&lt; endl;

	return 0;
}</code></pre> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
<ol><li><strong>resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个；</strong></li><li><strong>不同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的 元素空间。</strong></li><li><strong>resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。</strong></li><li><strong>如果发生了重新分配，则使用容器的分配器分配存储空间，这可能会在失败时抛出异常。</strong></li></ol> 
<hr> 
<h3 id="6%E3%80%81reserve()">6、reserve()</h3> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">主要功能</span>：<span style="color:#000000;"><span style="background-color:#ffffff;">请求更改容量</span></span>，请求使<a href="https://legacy.cplusplus.com/basic_string::capacity" rel="nofollow" title="字符串容量">字符串容量</a>适应计划<a href="https://legacy.cplusplus.com/basic_string::size" rel="nofollow" title="的大小">的大小</a>更改为最多 <em>n</em> 个字符。</strong></p> 
</blockquote> 
<p></p> 
<ul><li><strong>代码展示：</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");

	//测试reserve是否会改变string中有效元素个数
	str1.reserve(100);
	cout &lt;&lt; str1.size() &lt;&lt; endl;     
	cout &lt;&lt; str1.capacity() &lt;&lt; endl; 
	cout &lt;&lt; endl;

	
	// 测试reserve参数小于string的底层空间大小时，是否会将空间缩小
	
	str1.resize(100);
	cout &lt;&lt; str1.size() &lt;&lt; endl;
	cout &lt;&lt; str1.capacity() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p></p> 
<ul><li><strong>因此，有了这样的特性，我们就可以使用 reserve 来提高插入的效率了</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	// 利用reserve提高插入数据的效率，避免增容带来的开销
		string str;
		size_t sz = str.capacity();
		cout &lt;&lt; "making str grow:\n";
		cout &lt;&lt; "capacity changed:" &lt;&lt; sz &lt;&lt; endl;;

		for (int i = 0; i &lt; 100; ++i)
		{
			str.push_back('X');
			if (sz != str.capacity())
			{
				sz = str.capacity();
				cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n';
			}
		}
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
<ol><li><span style="color:#0d0016;"><strong>reserve(size_t res_arg=0)：为string预留空间，不改变有效元素个数，当reserve的参数小于 string的底层空间总大小时，reserver</strong></span><span style="color:#fe2c24;"><strong>不会改变容量大小</strong></span><span style="color:#0d0016;"><strong>。</strong></span></li><li><span style="color:#fe2c24;"><strong><span style="background-color:#f3f3f4;">对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留好。</span></strong></span></li></ol> 
<p></p> 
<hr> 
<ul><li><span style="color:#0d0016;"><strong>两者的比较如下：</strong></span></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello world");

	
	str1.reserve(100);
	cout &lt;&lt; str1.size() &lt;&lt; endl;     
	cout &lt;&lt; str1.capacity() &lt;&lt; endl; 
	cout &lt;&lt; endl;

	
	string str2("hello world");
	str2.resize(100);
	cout &lt;&lt; str2.size() &lt;&lt; endl;
	cout &lt;&lt; str2.capacity() &lt;&lt; endl;

	return 0;
}</code></pre> 
<ul><li><strong>运行结果如下：</strong></li></ul> 
<p><img alt="" height="535" src="https://images2.imgbox.com/95/d9/n6AvzTRE_o.png" width="857"></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong> 现象解释：</strong></span></p> 
<ol><li><strong>从上述我们可以发现，resize 不仅把字符串的 size给改了，而且还把capacity也给改了；</strong></li><li><strong>而reserve只把只把 capacity给改变，而没有改变 size 的大小。</strong></li></ol> 
<hr> 
<p></p> 
<h2 id="%EF%BC%88%E5%85%AD%EF%BC%89string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">（六）string类对象的修改操作</h2> 
<blockquote> 
 <p><strong>对于修改操作，我们主要学习的有以下几个接口功能，其余的在这暂不详解，最多带过，如果以后遇到，我们再说。</strong></p> 
</blockquote> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><span style="color:#fe2c24;"><strong>函数名称</strong></span></td><td style="text-align:center;"><span style="color:#fe2c24;"><strong>功能说明</strong></span></td></tr><tr><td><a class="link-info" href="https://cplusplus.com/reference/string/string/push_back/" rel="nofollow" title="push_back">push_back</a></td><td>在字符串后尾插字符c</td></tr><tr><td><a class="link-info" href="https://cplusplus.com/reference/string/string/append/" rel="nofollow" title="append">append</a></td><td>在字符串后追加一个字符串</td></tr><tr><td><a class="link-info" href="https://cplusplus.com/reference/string/string/operator+=/" rel="nofollow" title="operator+=">operator+=</a></td><td>在字符串后追加字符串str</td></tr><tr><td><a class="link-info" href="https://cplusplus.com/reference/string/string/c_str/" rel="nofollow" title="c_str">c_str</a></td><td>返回C格式字符串</td></tr><tr><td><a class="link-info" href="https://cplusplus.com/reference/string/string/find/" rel="nofollow" title="find">find</a>+<a class="link-info" href="https://cplusplus.com/reference/string/string/npos/" rel="nofollow" title="npos">npos</a> </td><td>从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a class="link-info" href="https://cplusplus.com/reference/string/string/rfind/" rel="nofollow" title="rfind">rfind</a></td><td>从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a class="link-info" href="https://cplusplus.com/reference/string/string/substr/" rel="nofollow" title="substr">substr</a></td><td>在str中从pos位置开始，截取n个字符，然后将其返回</td></tr></tbody></table> 
<hr> 
<h3 id="1%E3%80%81push_back()">1、push_back()</h3> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>主要功能</strong></span>：<strong>将字符 <em>c</em> 追加到<a href="https://cplusplus.com/string" rel="nofollow" title="字符串">字符串</a>的末尾，将其<a href="https://cplusplus.com/string::length" rel="nofollow" title="长度">长度</a>增加 1。</strong></p> 
</blockquote> 
<ul><li><strong>当我们想在字符串的末尾追加一个字符时，我们就可以用到 push_back 这个函数接口。</strong></li></ul> 
<p></p> 
<ul><li><strong>代码演示</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello");
	cout &lt;&lt; str1 &lt;&lt; endl;       //5
	cout &lt;&lt; str1.size() &lt;&lt; endl;//hello

	str1.push_back('X');       // 在str后插入X
	cout &lt;&lt; str1 &lt;&lt; endl;      //helloX
	cout &lt;&lt; str1.size() &lt;&lt; endl;//6
	return 0;
}</code></pre> 
<hr> 
<h3 id="2%E3%80%81append()">2、append()</h3> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>主要功能</strong></span>：<strong><span style="color:#000000;"><span style="background-color:#ffffff;">追加到字符串</span></span>，通过在当前值的末尾附加其他字符来扩展<a href="https://legacy.cplusplus.com/basic_string" rel="nofollow" title="basic_string">basic_string</a>：</strong></p> 
</blockquote> 
<ul><li>那此时我想追加一组字符串，上述的push_back 则不适用了，此时我们需要使用 append() 这个接口函数。</li></ul> 
<pre><code class="language-cpp">str1.append(" world");  // 在str后插入单词world
cout &lt;&lt; str1 &lt;&lt; endl;
cout &lt;&lt; str1.size() &lt;&lt; endl; </code></pre> 
<p>但是在显示中，我们其实很不喜欢这个用法，最常用的就是下面这个接口。</p> 
<hr> 
<h3 id="3%E3%80%81operator%2B%3D">3、operator+=</h3> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">主要功能</span>：追加到字符串</strong></p> 
</blockquote> 
<ul><li><strong>代码演示</strong></li></ul> 
<pre><code class="language-cpp">str1 += ' ';            // 在str后插入空格
str1 += "wo";           // 在str1后追加一个字符'wo'   
str1 += "rld";          // 在str1后追加一个字符串"rld"
cout &lt;&lt; str1 &lt;&lt; endl;
cout &lt;&lt; str1.size() &lt;&lt; endl;</code></pre> 
<p></p> 
<hr> 
<p>关于插入功能的函数接口大概就是以上几个，我们常用的就是最后 一种</p> 
<ul><li><strong>整体代码展示</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("hello");
	/cout &lt;&lt; str1 &lt;&lt; endl;
	cout &lt;&lt; str1.size() &lt;&lt; endl;

	//push_back
	str1.push_back('X');   // 在str后插入X
	cout &lt;&lt; str1 &lt;&lt; endl;
	cout &lt;&lt; str1.size() &lt;&lt; endl;

	//append
	str1.append(" world");  // 在str后插入单词world
	cout &lt;&lt; str1 &lt;&lt; endl;
	cout &lt;&lt; str1.size() &lt;&lt; endl; 

	//operator+=
	str1 += ' ';            // 在str后插入空格
	str1 += "wo";           // 在str1后追加一个字符'wo'   
	str1 += "rld";          // 在str1后追加一个字符串"rld"
	cout &lt;&lt; str1 &lt;&lt; endl;
	cout &lt;&lt; str1.c_str() &lt;&lt; endl;   // 以C语言的方式打印字符串
	cout &lt;&lt; str1.size() &lt;&lt; endl;


	return 0;
}</code></pre> 
<hr> 
<h3 id="4%E3%80%81find()%20%E5%92%8C%20npos()">4、find() 和 npos()</h3> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">主要功能</span>：<span style="color:#000000;"><span style="background-color:#ffffff;">查找字符串中的第一个匹配项</span></span>，在<a href="https://legacy.cplusplus.com/basic_string" rel="nofollow" title="basic_string">basic_string</a>中搜索由其参数指定的序列的第一个匹配项。</strong></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">分析：</span></strong></span></p> 
<ol><li><strong>函数原理就是从pos位置开始搜索整个字符串，如果没有输入起始位置pos，则默认为0。</strong></li><li><strong>找到能成功匹配的子字符串str，如果可以找到合法存在的子字符串位置，此时需要需要注意一点的是，<span style="color:#fe2c24;">返回这个位置的索引坐标相对于整个字符串的起始位置而言</span>，而不是相对于起始搜索的位置，否则返回npos.</strong></li></ol> 
<blockquote> 
 <p>至于什么是 【npos】，在这里我也简单的提一下：</p> 
</blockquote> 
<ul><li><strong>首先，我们先看看文档是怎么介绍的，具体如下：</strong></li></ul> 
<p><img alt="" height="444" src="https://images2.imgbox.com/ef/67/dOnAWG5B_o.png" width="1200"></p> 
<p><strong><span style="background-color:#ffd900;"> 小结：</span></strong></p> 
<ol><li>  <strong>npos: 这是一个特殊值，等于size_type可以表达的最大值，通常为无符号整型的最大值。</strong></li><li><strong>确切的含义取决于上下文，通常用来标识字符串结束或者是函数作用错误指示符。</strong></li><li><strong>在本函数当中就用来代表函数作用错误，</strong><a href="https://so.csdn.net/so/search?q=find%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" title="find函数">find函数</a><strong>在找不到指定值得情况下会返回string::npos。</strong></li></ol> 
<p></p> 
<p> 🔥<strong><span style="background-color:#ffd900;">用法：</span></strong></p> 
<ul><li><strong>1、例如，当我们想查找一个字符时，我们可以使用到 find()，具体如下:</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str("have a nice day");

	int s1 = str.find("e");       //pos未输入则默认为0
	int s2 = str.find("e", 4);
    
	cout &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; endl; //3 10

     if(s.find("i", 10) == s.npos)
        cout &lt;&lt; s.npos &lt;&lt; endl; 

	return 0;
}

// npos是string里面的一个静态成员变量
// static const size_t npos = -1;</code></pre> 
<ul><li><strong>2、例如，我们想在str1 字符串中查找查找和 str2 匹配的字符串，具体如下:</strong></li></ul> 
<pre><code class="language-cpp">
int main()
{
	string str1("have a nice day");
	string str2("ce");

	str1.find(str2);
	if(str1.find(str2) != string::npos)
		cout &lt;&lt; str1.find(str2) &lt;&lt; endl;

	return 0;
}</code></pre> 
<hr> 
<h3 id="5%E3%80%81rfind()">5、rfind()</h3> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">主要功能</span>：是从字符串右侧开始匹配str，并返回在字符串中的下标位置</strong></p> 
</blockquote> 
<ul><li><strong>1、例如，当我们想查找一个字符时，我们可以使用到 rfind()，具体如下:</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("have a nice day");
	string str2("ce");


	cout &lt;&lt; str1.find('d') &lt;&lt; endl;
	cout &lt;&lt; str1.rfind('d') &lt;&lt; endl;
	

	return 0;
}</code></pre> 
<ul><li><strong>2、例如，我们想在str1 字符串中查找查找和 str2 匹配的字符串，具体如下:</strong></li></ul> 
<pre><code class="language-cpp">int main()
{
	string str1("have a nice day");
	string str2("ce");

	str1.rfind(str2);
	if (str1.rfind(str2) != string::npos)
		cout &lt;&lt; str1.rfind(str2) &lt;&lt; endl;


	return 0;
}</code></pre> 
<p><strong><span style="background-color:#ffd900;">小结：</span></strong></p> 
<ul><li><strong>最后的运行结果跟 find 运行的时候结果是一样的。</strong></li></ul> 
<hr> 
<h3 id="6%E3%80%81substr()">6、substr()</h3> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">主要功能</span>：<span style="color:#000000;"><span style="background-color:#ffffff;">生成子字符串</span></span>，返回一个新构造的对象，其值初始化为此对象的子字符串的副本。</strong></p> 
</blockquote> 
<ul><li><strong>1、例如，当我们想查找一个文件的后缀时，我们可以使用到 </strong>substr<strong>()，具体如下:</strong></li></ul> 
<pre><code class="language-cpp">int main()
{

	// 获取file的后缀
	string file("string.cpp");
	size_t pos = file.rfind('.');
	string suffix(file.substr(pos, file.size() - pos));
	cout &lt;&lt; suffix &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><strong><span style="background-color:#ffd900;">解释说明：</span></strong></p> 
<ol><li><strong>假设此时我们有一个文件，叫【string.cpp】，当我们想查找文件的后缀时我们使用find查找到文件名的 后缀的起始，即【.】所在的位置后面的即为文件的后缀名；</strong></li><li><strong>在此处，我们通过查找到【.】所在位置，用整个字符串的长度减去pos位置之前的，得到的即为文件后缀名；</strong></li><li><strong>又因为文件后缀也是一个字符串，因此我们还用到了【substr】接口。</strong></li></ol> 
<hr> 
<ul><li><strong>2、例如，当我们想取出一个网络的域名时，我们也可以使用到 </strong>substr<strong>()，具体如下:</strong></li></ul> 
<pre><code class="language-cpp">
int main()
{
	// 取出DNS中的域名
	string DNS("https://legacy.cplusplus.com/reference/string/basic_string/substr/");
	cout &lt;&lt; DNS &lt;&lt; endl;
	size_t start = DNS.find("://");
	if (start == string::npos)
	{
		cout &lt;&lt; "invalid DNS" &lt;&lt; endl;
		return -1;
	}

	start += 3;
	size_t finish = DNS.find('/', start);
	string address = DNS.substr(start, finish - start);
	cout &lt;&lt; address &lt;&lt; endl;

	return 0;
}</code></pre> 
<hr> 
<h2></h2> 
<h2></h2> 
<h2 id="%EF%BC%88%E4%B8%83%EF%BC%89string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">（七）string类非成员函数</h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>函数</td><td>功能说明</td></tr><tr><td><a class="link-info" href="https://cplusplus.com/reference/string/string/operator+/" rel="nofollow" title="operator+">operator+</a></td><td>尽量少用，因为传值返回，导致深拷贝效率低</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/operator%3E%3E/" rel="nofollow" title="operator&gt;&gt;">operator&gt;&gt;</a></td><td>输入运算符重载</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/operator%3C%3C/" rel="nofollow" title="operator&lt;&lt;">operator&lt;&lt;</a></td><td>输出运算符重载</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/getline/" rel="nofollow" title="getline">getline</a></td><td>获取一行字符串</td></tr><tr><td><a class="link-info" href="https://legacy.cplusplus.com/reference/string/basic_string/operators/" rel="nofollow" title="relational operators">relational operators</a></td><td>大小比较</td></tr></tbody></table> 
<p></p> 
<ul><li><strong>上面的几个接口大家了解一下，在OJ题目中会有一些体现他们的使用。string类中还有一些其他的操作，这里不一一列举，大家在需要用到时不明白了查文档即可。 </strong></li></ul> 
<hr> 
<h2 id="%EF%BC%88%E5%85%AB%EF%BC%89vs%E5%92%8Cg%2B%2B%E4%B8%8Bstring%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%B4%E6%98%8E">（八）vs和g++下string结构的说明</h2> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">注意</span>：下述结构是在32位平台下进行验证，32位平台下指针占4个字节。</strong></p> 
</blockquote> 
<p> 💨 <span style="color:#fe2c24;"><strong>vs下string的结构</strong></span></p> 
<p><strong>string总共占28个字节，内部结构稍微复杂一点，先是有一个联合体，联合体用来定义string中字 符串的存储空间：</strong></p> 
<ul><li><span style="color:#1a439c;"><strong>当字符串长度小于16时，使用内部固定的字符数组来存放</strong></span></li><li><span style="color:#1a439c;"><strong>当字符串长度大于等于16时，从堆上开辟空间</strong></span></li></ul> 
<pre><code class="language-cpp">union _Bxty
{ 
 // storage for small buffer or pointer to larger one
 value_type _Buf[_BUF_SIZE];
 pointer _Ptr;
 char _Alias[_BUF_SIZE]; // to permit aliasing
} _Bx;
</code></pre> 
<ol><li>这种设计也是有一定道理的，大多数情况下字符串的长度都小于16，那string对象创建好之后，内 部已经有了16个字符数组的固定空间，不需要通过堆创建，效率高。</li><li>其次：还有一个size_t字段保存字符串长度，一个size_t字段保存从堆上开辟空间总的容量</li><li>最后：还有一个指针做一些其他事情。 故总共占16+4+4+4=28个字节。</li></ol> 
<p><img alt="" height="474" src="https://images2.imgbox.com/b2/fa/OE0IOp6a_o.png" width="1168"></p> 
<p> 💨 <span style="color:#fe2c24;"><strong> g++下string的结构</strong></span></p> 
<p><strong>G++下，string是通过写时拷贝实现的，string对象总共占4个字节，内部只包含了一个指针，该指 针将来指向一块堆空间，内部包含了如下字段：</strong></p> 
<ul><li><strong><span style="color:#1a439c;">空间总大小 </span></strong></li><li><strong><span style="color:#1a439c;">字符串有效长度 </span></strong></li><li><strong><span style="color:#1a439c;">引用计数</span></strong></li></ul> 
<pre><code class="language-cpp">struct _Rep_base
{
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
};</code></pre> 
<ul><li><span style="color:#1a439c;"><strong>指</strong><strong>向堆空间的指针，用来存储字符串</strong></span></li></ul> 
<p></p> 
<hr> 
<h2 id="%EF%BC%88%E4%B9%9D%EF%BC%89%E6%80%BB%E7%BB%93"><span style="color:#0d0016;"><strong>（九）总结</strong></span></h2> 
<blockquote> 
 <p><strong>到此，关于本文的内容便全部讲解完毕了。接下来，我们回顾一下本文都学到了什么：</strong></p> 
</blockquote> 
<ol><li><strong>首先，我们对为什么要学习 string类进行了解释说明。string是表示字符串的字符串类。不管是在以后的工作上还是日常练习都经常使用到 string；</strong></li><li><strong>其次，通过文档我们对标准库中的 string类进行了简单的，string在底层实际是：basic_string模板类的别名【typedef basic_string string】，紧接着还介绍了一系列的补充知识；</strong></li><li><strong>在接下来就是对 string类的常用接口说明以及讲解。该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作；</strong></li><li><strong>最后，说明一点：string 不能操作多字节或者变长字符的序列（🔥）</strong></li></ol> 
<blockquote> 
 <p><strong>以上便是全文的基本内容了，非常感谢各位小伙伴的阅读！！</strong></p> 
</blockquote> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/96/95/sI80Hnq0_o.gif"></strong></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b1a096e7206ef6e6b36db1654c1e308/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue控制台警告Runtime directive used on component with non-element root node.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c00e4c7f9e153e643f65f539ac3df6c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python】将数据写入excel文件中</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>