<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【缓存】-缓存中间件 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【缓存】-缓存中间件" />
<meta property="og:description" content="简介：主要介绍缓存中间件MemCached和Redis
MemCached 1、MemCached介绍 MemCached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。它便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题，本质上，它是一个简洁的key-value存储系统
2、MemCached工作原理 主要通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度。见下图： Redis 1、Redis简介 Redis 是完全开源免费的，是一个高性能的key-value数据库。
Redis 与其他 key - value 缓存产品有以下三个特点： （1）Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 （2）Redis支持String、list、set、zset、hash等数据结构的存储。 （3）Redis支持数据的备份，即master-slave模式的数据备份。
2、Linux下安装Redis 下载地址：http://redis.io/download （1）下载并安装：
$ wget http://download.redis.io/releases/redis-4.0.10.tar.gz $ tar xzf redis-4.0.10.tar.gz $ cd redis-4.0.10 $ make （2）启动redis服务
$ cd src $ ./redis-server （3）使用redis客户端
$ cd src $ ./redis-cli redis&gt; set companyName G7 OK redis&gt; get companyName &#34;G7&#34; 3、Java使用Redis import redis.clients.jedis.Jedis; import java.util.*; /** * Created by pc on 2018/7/23. * Redis数据类型 */ public class RedisDemo { //String public static void redisString(){ //连接 Redis 服务 Jedis jedis = new Jedis(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/42936d52a843164c1546cff41aeffbc2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-14T20:28:05+08:00" />
<meta property="article:modified_time" content="2018-08-14T20:28:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【缓存】-缓存中间件</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>简介：主要介绍缓存中间件MemCached和Redis</p> 
<h3 id="memcached">MemCached</h3> 
<p>1、MemCached介绍 <br> MemCached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。它便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题，本质上，它是一个简洁的key-value存储系统</p> 
<p>2、MemCached工作原理 <br> 主要通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度。见下图： <br> <img src="https://images2.imgbox.com/ca/f9/NyDAezKD_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="redis">Redis</h3> 
<h4 id="1redis简介">1、Redis简介</h4> 
<p>Redis 是完全开源免费的，是一个高性能的key-value数据库。</p> 
<p>Redis 与其他 key - value 缓存产品有以下三个特点： <br> （1）Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 <br> （2）Redis支持String、list、set、zset、hash等数据结构的存储。 <br> （3）Redis支持数据的备份，即master-slave模式的数据备份。</p> 
<h4 id="2linux下安装redis">2、Linux下安装Redis</h4> 
<p>下载地址：<a href="http://redis.io/download" rel="nofollow">http://redis.io/download</a> <br> （1）下载并安装：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">$ wget http://download<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.io</span>/releases/redis-<span class="hljs-number">4.0</span><span class="hljs-number">.10</span><span class="hljs-preprocessor">.tar</span><span class="hljs-preprocessor">.gz</span>
$ tar xzf redis-<span class="hljs-number">4.0</span><span class="hljs-number">.10</span><span class="hljs-preprocessor">.tar</span><span class="hljs-preprocessor">.gz</span>
$ cd redis-<span class="hljs-number">4.0</span><span class="hljs-number">.10</span>
$ make</code></pre> 
<p>（2）启动redis服务</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cd src
<span class="hljs-variable">$ </span>./redis-server</code></pre> 
<p>（3）使用redis客户端</p> 
<pre class="prettyprint"><code class=" hljs bash">$ <span class="hljs-built_in">cd</span> src
$ ./redis-cli
redis&gt; <span class="hljs-keyword">set</span> companyName G7
OK
redis&gt; get companyName 
<span class="hljs-string">"G7"</span></code></pre> 
<h4 id="3java使用redis">3、Java使用Redis</h4> 
<pre class="prettyprint"><code class=" hljs cs">import redis.clients.jedis.Jedis;
import java.util.*;

<span class="hljs-comment">/**
 * Created by pc on 2018/7/23.
 * Redis数据类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> RedisDemo
{
    <span class="hljs-comment">//String</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redisString</span>(){
        <span class="hljs-comment">//连接 Redis 服务</span>
        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"172.16.*.**"</span>,<span class="hljs-number">6379</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"连接成功"</span>);
        <span class="hljs-comment">//查看服务是否运行</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Server is running: "</span> + jedis.ping());
        <span class="hljs-comment">//设置 redis 字符串数据</span>
        jedis.<span class="hljs-keyword">set</span>(<span class="hljs-string">"runoobkey"</span>, <span class="hljs-string">"www.runoob.com"</span>);
        <span class="hljs-comment">// 获取存储的数据并输出</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"redis 存储的字符串为: "</span>+ jedis.<span class="hljs-keyword">get</span>(<span class="hljs-string">"runoobkey"</span>));
    }

    <span class="hljs-comment">//list</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redisList</span>(){
        <span class="hljs-comment">//连接 Redis 服务</span>
        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"172.16.*.**"</span>,<span class="hljs-number">6379</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"连接成功"</span>);
        <span class="hljs-comment">//存储数据到列表中</span>
        jedis.lpush(<span class="hljs-string">"site-list"</span>, <span class="hljs-string">"Baidu"</span>);
        jedis.lpush(<span class="hljs-string">"site-list"</span>, <span class="hljs-string">"Google"</span>);
        jedis.lpush(<span class="hljs-string">"site-list"</span>, <span class="hljs-string">"Taobao"</span>);
        <span class="hljs-comment">// 获取存储的数据并输出</span>
        List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">"site-list"</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">2</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) {
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"列表项为: "</span>+list.<span class="hljs-keyword">get</span>(i));
        }
    }

    <span class="hljs-comment">//set</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redisSet</span>(){
        <span class="hljs-comment">//连接 Redis 服务</span>
        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"172.16.*.**"</span>,<span class="hljs-number">6379</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"连接成功"</span>);
        <span class="hljs-comment">//存入set的值</span>
        Long mySet = jedis.sadd(<span class="hljs-string">"websites"</span>, <span class="hljs-string">"Baidu"</span>, <span class="hljs-string">"Taobao"</span>, <span class="hljs-string">"Google"</span>);
        <span class="hljs-comment">//获取set的值</span>
        Set&lt;String&gt; website = jedis.smembers(<span class="hljs-string">"websites"</span>);
        Iterator&lt;String&gt; it = website.iterator();
        <span class="hljs-keyword">while</span>(it.hasNext()){
            System.<span class="hljs-keyword">out</span>.println(it.next());
        }
    }

    <span class="hljs-comment">//hash</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redisHash</span>(){
        <span class="hljs-comment">//连接 Redis 服务</span>
        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"172.16.*.**"</span>,<span class="hljs-number">6379</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"连接成功"</span>);
        Map&lt;String, String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        hashMap.put(<span class="hljs-string">"Baidu"</span>,<span class="hljs-string">"www.baidu.com"</span>);
        hashMap.put(<span class="hljs-string">"Taobao"</span>,<span class="hljs-string">"www.taobao.com"</span>);
        hashMap.put(<span class="hljs-string">"Google"</span>,<span class="hljs-string">"www.google.com"</span>);
        jedis.hmset(<span class="hljs-string">"website"</span>, hashMap);
        System.<span class="hljs-keyword">out</span>.println(jedis.hgetAll(<span class="hljs-string">"website"</span>));

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        redisString();
<span class="hljs-comment">//        redisList();</span>
<span class="hljs-comment">//        redisSet();</span>
<span class="hljs-comment">//        redisHash();</span>
    }
}
</code></pre> 
<p>运行后，如下图： <br> <img src="https://images2.imgbox.com/19/32/vNswITJ0_o.png" alt="这里写图片描述" title=""></p> 
<h4 id="4redis缓存策略">4、Redis缓存策略</h4> 
<p>（1）缓存【失效】：客户端请求数据先从缓存中查询，如果没有再查询数据库，最后将数据放入缓存 <br> （2）缓存【命中】：客户端从缓存中直接取到数据，返回结果 <br> （3）缓存【更新】：客户端写入数据到数据库，成功之后，让缓存失效（下次请求时从缓存中拿不到，则查询数据库，再放入缓存）</p> 
<h4 id="5有问题的几种更新缓存策略">5、有问题的几种更新缓存策略</h4> 
<p>（1）先更新缓存，然后更新DB。见下图： <br> <img src="https://images2.imgbox.com/08/4e/wWuBMZ5d_o.png" alt="这里写图片描述" title=""></p> 
<p>从图中可以看出，两个并发写操作，由于某些原因（io阻塞，cpu时间片分配，协程调度，网络原因等等），导致Thread2的更新DB晚于Thread1的更新DB，但是Redis中此时的数据Thread1的，而DB中的数据时Thread2的，这就出现了不一致的问题，DB中是脏数据</p> 
<p>（2）先更新DB，然后更新缓存。见下图： <br> <img src="https://images2.imgbox.com/7a/15/033ASz19_o.png" alt="这里写图片描述" title=""></p> 
<p>从图中可以看出，两个并发写操作，由于某些原因导致Thread2的更新Redis晚于Thread1的更新Redis ，但是DB中此时的数据Thread1的，而Redis中的数据时Thread2的，这就出现了不一致的问题</p> 
<p>（3）先删除缓存，然后再更新数据库。见下图： <br> <img src="https://images2.imgbox.com/cc/05/ivr38zfU_o.png" alt="这里写图片描述" title=""></p> 
<p>两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，会把老数据读出来后放到缓存中，然后更新操作更新了DB。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的</p> 
<p>（4）先数据库，成功之后，让缓存失效，下次请求时从缓存中拿不到，则查询数据库，再放入缓存。见下图： <br> <img src="https://images2.imgbox.com/b6/d3/0zCTiwW7_o.png" alt="这里写图片描述" title=""></p> 
<p>这种更新策略是我们实际最常用的，但也可能出现问题。实际上出现问题的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p> 
<h4 id="6redis与memcached的区别">6、Redis与MemCached的区别</h4> 
<p>（1）Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等； <br> （2）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储； <br> （3）虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘； <br> （4）分布式集群部署： <br> a、memcache集群节点间的数据是独立的，不能相互通讯，但可以利用magent开源软件解决 ; <br> b、Redis高可用的，可以做一主多从，主从之间进行数据同步。 当Master宕机后，通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务，主机恢复后以slave的身份重新加入 <br> （5）存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）； <br> （6）灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p> 
<p>……完</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/356dd70ed3aa773ab13be4a8ff7465c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">程序员到底学什么</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/855da03b977eb2d14a4061e27e1f8be9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">打开浏览器，显示网页可能暂时无法连接,或者它已永久性的移动到了新地址</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>