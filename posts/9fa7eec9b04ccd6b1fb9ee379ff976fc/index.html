<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>庖丁解牛——用纯python构建深度学习框架(三) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="庖丁解牛——用纯python构建深度学习框架(三)" />
<meta property="og:description" content="导语 在上一篇中我们简单介绍了神经网络的样子，以及通过拓扑排序和反向传播实现自动求导，但是那只是停留在概念层面，那么接下来就是用代码实现拓扑排序，以及模拟神经网络的计算过程
实现拓扑排序 先提一点，实际上在python3.9的版本上已经有了拓扑排序的功能，如果是使用python3.9版本的同学可以在python官网查看相关文档调取使用，因为我是用的是python3.8版本，所以需要手动实现拓扑排序的功能。
再理一下流程。如下图
x , k 1 , b 1 x,k_1,b_1 x,k1​,b1​把值输入到 L 1 ( ) L_1() L1​()，之后进行非线性变换，把 L 1 ( ) L_1() L1​()的结果输出到 s i g m o i d ( ) sigmoid() sigmoid(),之后再把非线性变换结果和第二次线性变换的参数 s i g m o i d ( x ) , k 2 , b 2 sigmoid(x),k_2,b_2 sigmoid(x),k2​,b2​输入到 L 2 ( ) L_2() L2​()之后再把最后的结果和 y y y值输入到 L o s s ( ) Loss() Loss()函数得到损失值，然后根据 L o s s Loss Loss值反向传播，不断优化参数，再进行向前传播继续得到 L o s s Loss Loss值，如此往复，最终得到模型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9fa7eec9b04ccd6b1fb9ee379ff976fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-09T16:47:36+08:00" />
<meta property="article:modified_time" content="2021-09-09T16:47:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">庖丁解牛——用纯python构建深度学习框架(三)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>导语</h2> 
<blockquote> 
 <p>在上一篇中我们简单介绍了神经网络的样子，以及通过拓扑排序和反向传播实现自动求导，但是那只是停留在概念层面，那么接下来就是用代码实现拓扑排序，以及模拟神经网络的计算过程</p> 
</blockquote> 
<h2><a id="_3"></a>实现拓扑排序</h2> 
<p>先提一点，实际上在python3.9的版本上已经有了拓扑排序的功能，如果是使用python3.9版本的同学可以在python官网查看相关文档调取使用，因为我是用的是python3.8版本，所以需要手动实现拓扑排序的功能。</p> 
<p>再理一下流程。如下图<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         , 
        
        
        
          k 
         
        
          1 
         
        
       
         , 
        
        
        
          b 
         
        
          1 
         
        
       
      
        x,k_1,b_1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>把值输入到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          L 
         
        
          1 
         
        
       
         ( 
        
       
         ) 
        
       
      
        L_1() 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></span>，之后进行非线性变换，把<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          L 
         
        
          1 
         
        
       
         ( 
        
       
         ) 
        
       
      
        L_1() 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></span>的结果输出到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         i 
        
       
         g 
        
       
         m 
        
       
         o 
        
       
         i 
        
       
         d 
        
       
         ( 
        
       
         ) 
        
       
      
        sigmoid() 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></span>,之后再把非线性变换结果和第二次线性变换的参数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         i 
        
       
         g 
        
       
         m 
        
       
         o 
        
       
         i 
        
       
         d 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         , 
        
        
        
          k 
         
        
          2 
         
        
       
         , 
        
        
        
          b 
         
        
          2 
         
        
       
      
        sigmoid(x),k_2,b_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>输入到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          L 
         
        
          2 
         
        
       
         ( 
        
       
         ) 
        
       
      
        L_2() 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></span>之后再把最后的结果和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
      
        y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>值输入到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         o 
        
       
         s 
        
       
         s 
        
       
         ( 
        
       
         ) 
        
       
      
        Loss() 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></span>函数得到损失值，然后根据<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         o 
        
       
         s 
        
       
         s 
        
       
      
        Loss 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span></span>值反向传播，不断优化参数，再进行向前传播继续得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         o 
        
       
         s 
        
       
         s 
        
       
      
        Loss 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span></span>值，如此往复，最终得到模型。<br> 这就是整个训练过程，所以现在的任务要先实现拓扑排序，为后续的向前计算和向后计算做准备。<br> <img src="https://images2.imgbox.com/2d/86/OV5hW1Yr_o.png" alt="在这里插入图片描述"><br> 顺着上一篇的思路，建立节点与节点之间的关系，我们需要从输出和输入来建立。</p> 
<pre><code class="prism language-python"><span class="token comment">#先创建一个图备用</span>
x<span class="token punctuation">,</span>k1<span class="token punctuation">,</span>b1<span class="token punctuation">,</span>linear1<span class="token punctuation">,</span>sigmoid1<span class="token punctuation">,</span>y<span class="token punctuation">,</span>loss <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">,</span><span class="token string">'k1'</span><span class="token punctuation">,</span><span class="token string">'b1'</span><span class="token punctuation">,</span><span class="token string">'linear1'</span><span class="token punctuation">,</span><span class="token string">'sigmoid1'</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">,</span><span class="token string">'loss'</span>
k2<span class="token punctuation">,</span>b2<span class="token punctuation">,</span>linear2<span class="token punctuation">,</span>sigmoid2 <span class="token operator">=</span><span class="token string">'k2'</span><span class="token punctuation">,</span><span class="token string">'b2'</span><span class="token punctuation">,</span><span class="token string">'linear2'</span><span class="token punctuation">,</span><span class="token string">'sigmoid2'</span> 
test_graph <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">:</span><span class="token punctuation">[</span>linear1<span class="token punctuation">]</span><span class="token punctuation">,</span>
        k1<span class="token punctuation">:</span><span class="token punctuation">[</span>linear1<span class="token punctuation">]</span><span class="token punctuation">,</span>
        b1<span class="token punctuation">:</span><span class="token punctuation">[</span>linear1<span class="token punctuation">]</span><span class="token punctuation">,</span>
        linear1<span class="token punctuation">:</span><span class="token punctuation">[</span>sigmoid1<span class="token punctuation">]</span><span class="token punctuation">,</span>
        sigmoid1<span class="token punctuation">:</span><span class="token punctuation">[</span>linear2<span class="token punctuation">]</span><span class="token punctuation">,</span>
        k2 <span class="token punctuation">:</span> <span class="token punctuation">[</span>linear2<span class="token punctuation">]</span><span class="token punctuation">,</span>
        b2 <span class="token punctuation">:</span> <span class="token punctuation">[</span>linear2<span class="token punctuation">]</span><span class="token punctuation">,</span>
        linear2<span class="token punctuation">:</span><span class="token punctuation">[</span>sigmoid2<span class="token punctuation">]</span><span class="token punctuation">,</span>
        sigmoid2<span class="token punctuation">:</span><span class="token punctuation">[</span>loss<span class="token punctuation">]</span><span class="token punctuation">,</span>
        y<span class="token punctuation">:</span><span class="token punctuation">[</span>loss<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么首先我们要理清各个节点的关系，找出有输入的 I (Input)节点，和有O(Output)输出的节点，以及只有OONI(Only Output No Input)输出没有输入的节点即外缘节点,并用列表存储记录</p> 
<pre><code class="prism language-python">all_nodes_have_inputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
all_nodes_have_outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

all_nodes_only_have_outputs_no_inputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre> 
<p>通过对test_graph的此参数观察我们我可以清楚，有输出的O节点是字典的键，那么I节点就是字典的值。求解OONI节点的话我们可以通过集合的差集来求得。<br> <em>在这里因为字典的值是字典，我们需要用到python自带的reduce函数，目的是得到的数据为列表，具体用法可以到<a href="https://docs.python.org/3/library/functools.html?highlight=reduce#functools.reduce" rel="nofollow">python的官方文档</a>查看</em></p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> <span class="token builtin">reduce</span> 
<span class="token keyword">import</span> random

<span class="token comment">#创建一个列表用来存储排序后的结果</span>
sorted_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

all_nodes_have_inputs <span class="token operator">=</span> <span class="token builtin">reduce</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> a<span class="token punctuation">,</span> b<span class="token punctuation">:</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span><span class="token builtin">list</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
all_nodes_have_outputs <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

all_nodes_only_have_outputs_no_inputs <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span>all_node_have_outputs<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">set</span><span class="token punctuation">(</span>all_nodes_have_inputs<span class="token punctuation">)</span>
</code></pre> 
<p>数据准备完成之后，开始进行拓扑排序<br> 大致思路是先找到OONI节点，然后记录删除，再在删除后的图中一种重复之前的工作，直到最后一个节点</p> 
<pre><code class="prism language-python"><span class="token comment"># 如果OONI节点存在，那么就随机选取一个</span>
<span class="token keyword">if</span> alL_nodes_only_have_outputs_no_inputs<span class="token punctuation">:</span>
	node <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>all_nodes_only_have_outputs_no_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment"># 记录存储OONI节点</span>
	sorted_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	
	<span class="token comment"># 在原字典中删除OONI节点</span>
	graph<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	
</code></pre> 
<p>这样我们的大致流程就写好了，因为我们需要不断的寻找、记录和删除节点，直至原字典没有任何数据，所以需要用一个while循环。下面我们就用函数来封装一下拓扑排序的代码。</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">topologic</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>

    sorted_node <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token keyword">while</span> graph<span class="token punctuation">:</span>
        all_nodes_have_inputs <span class="token operator">=</span> <span class="token builtin">reduce</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> a<span class="token punctuation">,</span> b<span class="token punctuation">:</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span><span class="token builtin">list</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
        all_node_have_outputs <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
        all_nodes_only_have_outputs_no_inputs <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span>all_node_have_outputs<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">set</span><span class="token punctuation">(</span>all_nodes_have_inputs<span class="token punctuation">)</span>
    
        <span class="token keyword">if</span> all_nodes_only_have_outputs_no_inputs<span class="token punctuation">:</span>
            node <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>all_nodes_only_have_outputs_no_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span>
            
            sorted_node<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            
            <span class="token comment">#最后一个节点Loss节点是没有输出的，所以不在字典的key上，删除最后一个OONI节点</span>
            <span class="token comment">#Loss也就被删除了，所以该if语句是把Loss节点或者说最后一个节点添加到sorted_list中</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                sorted_node <span class="token operator">+=</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span>
                
            graph<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                    
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">'This graph has circle, which cannot get topological order'</span><span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> sorted_node

<span class="token comment">#下面测试一下效果</span>
topologic<span class="token punctuation">(</span>test_graph<span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token string">'k2'</span><span class="token punctuation">,</span>
 <span class="token string">'b1'</span><span class="token punctuation">,</span>
 <span class="token string">'y'</span><span class="token punctuation">,</span>
 <span class="token string">'x'</span><span class="token punctuation">,</span>
 <span class="token string">'b2'</span><span class="token punctuation">,</span>
 <span class="token string">'k1'</span><span class="token punctuation">,</span>
 <span class="token string">'linear1'</span><span class="token punctuation">,</span>
 <span class="token string">'sigmoid1'</span><span class="token punctuation">,</span>
 <span class="token string">'linear2'</span><span class="token punctuation">,</span>
 <span class="token string">'sigmoid2'</span><span class="token punctuation">,</span>
 <span class="token string">'loss'</span><span class="token punctuation">]</span>
</code></pre> 
<p>可以看到结果是严格按照我们的预期，实际这也展示了我们的计算过程。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         , 
        
       
         y 
        
       
         , 
        
        
        
          k 
         
        
          1 
         
        
       
         , 
        
        
        
          b 
         
        
          1 
         
        
       
         , 
        
        
        
          k 
         
        
          2 
         
        
       
         , 
        
        
        
          b 
         
        
          2 
         
        
       
      
        x,y,k_1,b_1,k_2,b_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>这些都是我们预先得到的数据，或是设置的参数，然后就是把相关参数和数据带依次带入到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          L 
         
        
          1 
         
        
       
         ( 
        
       
         ) 
        
       
         − 
        
       
         &gt; 
        
       
         S 
        
       
         i 
        
       
         g 
        
       
         m 
        
       
         o 
        
       
         i 
        
        
        
          d 
         
        
          1 
         
        
       
         ( 
        
       
         ) 
        
       
         − 
        
       
         &gt; 
        
        
        
          L 
         
        
          2 
         
        
       
         ( 
        
       
         ) 
        
       
         − 
        
       
         &gt; 
        
       
         S 
        
       
         i 
        
       
         g 
        
       
         m 
        
       
         o 
        
       
         i 
        
        
        
          d 
         
        
          2 
         
        
       
         ( 
        
       
         ) 
        
       
         − 
        
       
         &gt; 
        
       
         L 
        
       
         o 
        
       
         s 
        
       
         s 
        
       
         ( 
        
       
         ) 
        
       
      
        L_1()-&gt;Sigmoid_1()-&gt;L_2()-&gt;Sigmoid_2() -&gt;Loss() 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></span>，实际上这也是正向传播的过程。</p> 
<p>得到拓扑排序的函数之后我们就要用节点来表示各个量。</p> 
<pre><code class="prism language-python"><span class="token comment"># 首先创建一个节点类</span>
<span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span>outputs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>inputs <span class="token operator">=</span> inputs
        self<span class="token punctuation">.</span>outputs <span class="token operator">=</span> outputs
      
<span class="token comment"># 那么我们的节点就可以实例化了</span>
node_x <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>outputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_linear<span class="token punctuation">]</span><span class="token punctuation">)</span>
node_k <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>outputs <span class="token operator">=</span><span class="token punctuation">[</span>node_linear<span class="token punctuation">]</span><span class="token punctuation">)</span>
node_b <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>outputs <span class="token operator">=</span><span class="token punctuation">[</span>node_linear<span class="token punctuation">]</span><span class="token punctuation">)</span>
node_y <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>outputs <span class="token operator">=</span><span class="token punctuation">[</span>node_loss<span class="token punctuation">]</span><span class="token punctuation">)</span>
node_linear <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_x<span class="token punctuation">,</span> node_k<span class="token punctuation">,</span> node_b<span class="token punctuation">]</span><span class="token punctuation">,</span>outputs <span class="token operator">=</span><span class="token punctuation">[</span>node_sigmoid<span class="token punctuation">]</span><span class="token punctuation">)</span>
node_sigmoid <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_linear<span class="token punctuation">]</span><span class="token punctuation">,</span>outputs <span class="token operator">=</span><span class="token punctuation">[</span>node_loss<span class="token punctuation">]</span><span class="token punctuation">)</span>
node_loss <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_y<span class="token punctuation">,</span>node_sigmoid<span class="token punctuation">]</span><span class="token punctuation">,</span>outputs <span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>      
</code></pre> 
<p>实际上这段代码不论是看上去还是运行都不是很好的代码。所以我们要优化一下。<br> 那么我们可以按照上面拓扑图的形式，在我们实例化节点的时候只需要写出它的输入节点就可了，第二级的输入节点就是第一级的输出节点，所以可以这样优化一下代码</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>inputs <span class="token operator">=</span> inputs
        self<span class="token punctuation">.</span>outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        <span class="token keyword">for</span> node <span class="token keyword">in</span> inputs<span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>outputs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
            
node_x <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token punctuation">)</span>
node_k <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token punctuation">)</span>
node_b <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token punctuation">)</span>
node_y <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token punctuation">)</span>
node_linear <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_x<span class="token punctuation">,</span> node_k<span class="token punctuation">,</span> node_b<span class="token punctuation">]</span><span class="token punctuation">)</span>
node_sigmoid <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_linear<span class="token punctuation">]</span><span class="token punctuation">)</span>
node_loss <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_y<span class="token punctuation">,</span>node_sigmoid<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>下面我就需要一些代码来生成图</p> 
<pre><code class="prism language-python"><span class="token comment"># 创建一个列表，其中元素都是需要输入参数的节点</span>
need_feed_value_nodes <span class="token operator">=</span> <span class="token punctuation">[</span>node_x<span class="token punctuation">,</span> node_y<span class="token punctuation">,</span> node_k<span class="token punctuation">,</span> node_b<span class="token punctuation">]</span>

<span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict
<span class="token comment"># 该模块可以让我们通过上面的节点，也就是外援节点生成图</span>
computing_graph <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span>

<span class="token keyword">while</span> need_feed_value_nodes<span class="token punctuation">:</span>
	n <span class="token operator">=</span> need_feed_value_nodes<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> n <span class="token keyword">in</span> computing_graph<span class="token punctuation">:</span><span class="token keyword">continue</span>

    <span class="token keyword">for</span> m <span class="token keyword">in</span> n<span class="token punctuation">.</span>outputs<span class="token punctuation">:</span>
        computing_graph<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
    	need_feed_value_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>

<span class="token comment">#这样我们就可以用拓扑排序来进行排序了</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>topologic<span class="token punctuation">(</span>computing_graph<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Node at <span class="token number">0x2232c0cf4c0</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Node at <span class="token number">0x2232c0cf1c0</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Node at <span class="token number">0x2232c0cfd30</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Node at <span class="token number">0x2232c6ae160</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Node at <span class="token number">0x2232c0cf400</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Node at <span class="token number">0x2232c0cfe20</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Node at <span class="token number">0x2232c0cfe50</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre> 
<p>打印出来的都是地址，那么我们可以在Node类中做一点手脚，让结果更清晰，同时我们也可以把上面的代码进行封装</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> random
<span class="token keyword">from</span> functools <span class="token keyword">import</span> <span class="token builtin">reduce</span>
<span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict


<span class="token keyword">def</span> <span class="token function">topologic</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">"""拓扑排序"""</span>
    sorted_node <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token keyword">while</span> graph<span class="token punctuation">:</span>
        all_nodes_have_inputs <span class="token operator">=</span> <span class="token builtin">reduce</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> a<span class="token punctuation">,</span> b<span class="token punctuation">:</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span><span class="token builtin">list</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#所有有输入的节点</span>
        all_node_have_outputs <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#所有有输出的节点</span>
        all_nodes_only_have_outputs_no_inputs <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span>all_node_have_outputs<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">set</span><span class="token punctuation">(</span>all_nodes_have_inputs<span class="token punctuation">)</span>
    
        <span class="token keyword">if</span> all_nodes_only_have_outputs_no_inputs<span class="token punctuation">:</span>
            node <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>all_nodes_only_have_outputs_no_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span>
            
            sorted_node<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                sorted_node <span class="token operator">+=</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span>
                
            graph<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            
            <span class="token keyword">for</span> _<span class="token punctuation">,</span>links <span class="token keyword">in</span> graph<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node <span class="token keyword">in</span> links<span class="token punctuation">:</span>links<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                    
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">'This graph has circle, which cannot get topological order'</span><span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> sorted_node
  


<span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">"""定义一个节点类"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token triple-quoted-string string">"""初始化参数"""</span>
        self<span class="token punctuation">.</span>inputs <span class="token operator">=</span> inputs
        self<span class="token punctuation">.</span>outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        
        <span class="token keyword">for</span> node <span class="token keyword">in</span> inputs<span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>outputs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        
    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token triple-quoted-string string">"""打印时，打印节点名"""</span>
        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f'Node:</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">'</span></span>




<span class="token keyword">def</span> <span class="token function">convert_feed_dict_to_graph</span><span class="token punctuation">(</span>feed_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""根据外缘节点生成图"""</span>
    need_expand <span class="token operator">=</span> <span class="token punctuation">[</span>n <span class="token keyword">for</span> n <span class="token keyword">in</span> feed_dict<span class="token punctuation">]</span>
    
    computing_graph <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span>

    <span class="token keyword">while</span> need_expand<span class="token punctuation">:</span>
        n <span class="token operator">=</span> need_expand<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> n <span class="token keyword">in</span> computing_graph<span class="token punctuation">:</span><span class="token keyword">continue</span>

        <span class="token keyword">for</span> m <span class="token keyword">in</span> n<span class="token punctuation">.</span>outputs<span class="token punctuation">:</span>
            computing_graph<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
            need_expand<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
    <span class="token keyword">return</span> computing_graph

<span class="token comment">#定义节点</span>
node_x <span class="token operator">=</span> Node<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">)</span>
node_k <span class="token operator">=</span> Node<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'k'</span><span class="token punctuation">)</span>
node_b <span class="token operator">=</span> Node<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">)</span>
node_y <span class="token operator">=</span> Node<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'y'</span><span class="token punctuation">)</span>
node_linear <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_x<span class="token punctuation">,</span> node_k<span class="token punctuation">,</span> node_b<span class="token punctuation">]</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token string">'linear'</span><span class="token punctuation">)</span>
node_sigmoid <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_linear<span class="token punctuation">]</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token string">'sigmoid'</span><span class="token punctuation">)</span>
node_loss <span class="token operator">=</span> Node<span class="token punctuation">(</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span>node_y<span class="token punctuation">,</span>node_sigmoid<span class="token punctuation">]</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token string">'loss'</span><span class="token punctuation">)</span>
<span class="token comment">#外缘节点</span>
need_feed_value_nodes <span class="token operator">=</span> <span class="token punctuation">[</span>node_x<span class="token punctuation">,</span> node_y<span class="token punctuation">,</span> node_k<span class="token punctuation">,</span> node_b<span class="token punctuation">]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>topologic<span class="token punctuation">(</span>convert_feed_dict_to_graph<span class="token punctuation">(</span>feed_dict<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">[</span>Node<span class="token punctuation">:</span>y<span class="token punctuation">,</span> Node<span class="token punctuation">:</span>x<span class="token punctuation">,</span> Node<span class="token punctuation">:</span>k<span class="token punctuation">,</span> Node<span class="token punctuation">:</span>b<span class="token punctuation">,</span> Node<span class="token punctuation">:</span>linear<span class="token punctuation">,</span> Node<span class="token punctuation">:</span>sigmoid<span class="token punctuation">,</span> Node<span class="token punctuation">:</span>loss<span class="token punctuation">]</span>

</code></pre> 
<p>到这一步我们就基本实现了神经网络计算之前的工作！！！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42352dee8df93d7f1ad38676313828a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">女朋友让我写 1 万字检讨</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e81183eb7abe1e31f5e060c9f632944/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">string篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>