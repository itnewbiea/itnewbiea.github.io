<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis（9.2）—— 哨兵的安装和部署 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis（9.2）—— 哨兵的安装和部署" />
<meta property="og:description" content="上一节介绍了Redis Sentinel的基本架构，本节将介绍如何安装和部署Redis Sentinel。
9.2.1 部署拓扑结构 下面将以3个Sentinel节点、1个主节点、2个从节点组成一个Redis Sentinel进行说明，拓扑结构如图9-13所示。 具体的物理部署如表9-2所示。 9.2.2 部署Redis数据节点 9.1节提到过，Redis Sentinel中Redis数据节点没有做任何特殊配置，按照之前章节介绍的方法启动就可以，下面以一个比较简单的配置进行说明。 1.启动主节点 配置： redis-6379.conf port 6379 daemonize yes logfile &#34;6379.log&#34; dbfilename &#34;dump-6379.rdb&#34; dir &#34;/opt/soft/redis/data/&#34; 启动主节点： redis-server redis-6379.conf 确认是否启动。一般来说只需要ping命令检测一下就可以，确认Redis数据节点是否已经启动。 $ redis-cli -h 127.0.0.1 -p 6379 ping PONG 此时拓扑结构如图9-14所示。 图9-14 启动主节点
2.启动两个从节点 配置： 两个从节点的配置是完全一样的，下面以一个从节点为例子进行说明，和主节点的配置不一样的是添加了slaveof配置。 redis-6380.conf port 6380 daemonize yes logfile &#34;6380.log&#34; dbfilename &#34;dump-6380.rdb&#34; dir &#34;/opt/soft/redis/data/&#34; slaveof 127.0.0.1 6379 启动两个从节点： redis-server redis-6380.conf redis-server redis-6381.conf 验证： $ redis-cli -h 127.0.0.1 -p 6380 ping PONG $ redis-cli -h 127." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f80b86d31b6b8fb2b12ae643d8b8f1c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-02T16:10:33+08:00" />
<meta property="article:modified_time" content="2018-04-02T16:10:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis（9.2）—— 哨兵的安装和部署</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上一节介绍了Redis Sentinel的基本架构，本节将介绍如何安装和部署Redis Sentinel。</p> 
<strong>9.2.1 部署拓扑结构</strong> 
<br>下面将以3个Sentinel节点、1个主节点、2个从节点组成一个Redis Sentinel进行说明，拓扑结构如图9-13所示。 
<br> 
<img src="https://images2.imgbox.com/6b/1e/vm5tz1qf_o.png" alt=""> 
<br>具体的物理部署如表9-2所示。 
<br> 
<img src="https://images2.imgbox.com/de/50/FeaiNlLS_o.png" alt=""> 
<br> 
<strong>9.2.2 部署Redis数据节点</strong> 
<br>9.1节提到过，Redis Sentinel中Redis数据节点没有做任何特殊配置，按照之前章节介绍的方法启动就可以，下面以一个比较简单的配置进行说明。 
<br> 
<strong>1.启动主节点</strong> 
<br>配置： 
<br>redis-6379.conf 
<br>port 6379 
<br>daemonize yes 
<br>logfile "6379.log" 
<br>dbfilename "dump-6379.rdb" 
<br>dir "/opt/soft/redis/data/" 
<br>启动主节点： 
<br>redis-server redis-6379.conf 
<br>确认是否启动。一般来说只需要ping命令检测一下就可以，确认Redis数据节点是否已经启动。 
<br>$ redis-cli -h 127.0.0.1 -p 6379 ping 
<br>PONG 
<br>此时拓扑结构如图9-14所示。 
<br> 
<p><img src="https://images2.imgbox.com/93/d2/n90EIYIX_o.png" alt=""><br></p> 
<p>      图9-14 启动主节点</p> 
<strong>2.启动两个从节点</strong> 
<br>配置： 
<br>两个从节点的配置是完全一样的，下面以一个从节点为例子进行说明，和主节点的配置不一样的是添加了slaveof配置。 
<br>redis-6380.conf 
<br>port 6380 
<br>daemonize yes 
<br>logfile "6380.log" 
<br>dbfilename "dump-6380.rdb" 
<br>dir "/opt/soft/redis/data/" 
<br>slaveof 127.0.0.1 6379 
<br>启动两个从节点： 
<br>redis-server redis-6380.conf 
<br>redis-server redis-6381.conf 
<br>验证： 
<br>$ redis-cli -h 127.0.0.1 -p 6380 ping 
<br>PONG 
<br>$ redis-cli -h 127.0.0.1 -p 6381 ping 
<br>PONG 
<br> 
<strong>3.确认主从关系</strong> 
<br>主节点的视角，它有两个从节点，分别是127.0.0.1：6380和127.0.0.1：6381： 
<br>$ redis-cli -h 127.0.0.1 -p 6379 info replication 
<br># Replication 
<br>role:master 
<br>connected_slaves:2 
<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=1 
<br>slave1:ip=127.0.0.1,port=6381,state=online,offset=281,lag=0 
<br>................. 
<br>从节点的视角，它的主节点是127.0.0.1：6379： 
<br>$ redis-cli -h 127.0.0.1 -p 6380 info replication 
<br># Replication 
<br>role:slave 
<br>master_host:127.0.0.1 
<br>master_port:6379 
<br>master_link_status:up 
<br>................. 
<br>此时拓扑结构如图9-15所示。 
<br> 
<img src="https://images2.imgbox.com/d0/72/apuhbCx3_o.png" alt=""> 
<br> 
<strong>9.2.3 部署Sentinel节点</strong> 
<br>3个Sentinel节点的部署方法是完全一致的（端口不同），下面以sentinel-1节点的部署为例子进行说明。 
<br> 
<strong>1.配置Sentinel节点</strong> 
<br>redis-sentinel-26379.conf 
<br>port 26379 
<br>daemonize yes 
<br>logfile "26379.log" 
<br>dir /opt/soft/redis/data 
<br>sentinel monitor mymaster 127.0.0.1 6379 2 
<br>sentinel down-after-milliseconds mymaster 30000 
<br>sentinel parallel-syncs mymaster 1 
<br>sentinel failover-timeout mymaster 180000 
<br>1）Sentinel节点的默认端口是26379。 
<br>2）sentinel monitor mymaster 127.0.0.1 63792配置代表sentinel-1节点需要监控127.0.0.1：6379这个主节点，2代表判断主节点失败至少需要2个Sentinel节点同意，mymaster是主节点的别名，其余Sentinel配置将在下一节进行详细说明。 
<br> 
<strong>2.启动Sentinel节点</strong> 
<br>Sentinel节点的启动方法有两种： 
<br>方法一， 使用redis-sentinel命令： 
<br>redis-sentinel redis-sentinel-26379.conf 
<br>方法二， 使用redis-server命令加--sentinel参数： 
<br>redis-server redis-sentinel-26379.conf --sentinel 
<br>两种方法本质上是一样的。 
<br> 
<strong>3.确认</strong> 
<br>Sentinel节点本质上是一个特殊的Redis节点，所以也可以通过info命令来查询它的相关信息，从下面info的Sentinel片段来看，Sentinel节点找到了主节点127.0.0.1：6379，发现了它的两个从节点，同时发现Redis Sentinel一共有3个Sentinel节点。这里只需要了解Sentinel节点能够彼此感知到对方，同时能够感知到Redis数据节点就可以了： 
<br>$ redis-cli -h 127.0.0.1 -p 26379 info Sentinel 
<br># Sentinel 
<br>sentinel_masters:1 
<br>sentinel_tilt:0 
<br>sentinel_running_scripts:0 
<br>sentinel_scripts_queue_length:0 
<br>master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3 
<br>当三个Sentinel节点都启动后，整个拓扑结构如图9-16所示。至此Redis Sentinel已经搭建起来了，整体上还是比较容易的，但是有2点需要强调一下： 
<br>1）生产环境中建议Redis Sentinel的所有节点应该分布在不同的物理机上。 
<br>2）Redis Sentinel中的数据节点和普通的Redis数据节点在配置上没有任何区别，只不过是添加了一些Sentinel节点对它们进行监控。 
<br> 
<img src="https://images2.imgbox.com/72/6e/fS4lMOW1_o.png" alt=""> 
<br> 
<strong>9.2.4 配置优化</strong> 
<br>了解每个配置的含义有助于更加合理地使用Redis Sentinel，因此本节将对每个配置的使用和优化进行详细介绍。Redis安装目录下有一个sentinel.conf，是默认的Sentinel节点配置文件，下面就以它作为例子进行说明。 
<br>1.配置说明和优化 
<br>port 26379 
<br>dir /opt/soft/redis/data 
<br>sentinel monitor mymaster 127.0.0.1 6379 2 
<br>sentinel down-after-milliseconds mymaster 30000 
<br>sentinel parallel-syncs mymaster 1 
<br>sentinel failover-timeout mymaster 180000 
<br>#sentinel auth-pass &lt;master-name&gt; &lt;password&gt; 
<br>#sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; 
<br>#sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; 
<br>port和dir分别代表Sentinel节点的端口和工作目录， 下面重点对sentinel相关配置进行详细说明。 
<br> 
<strong>（1）sentinel monitor</strong> 
<br>配置如下： 
<br>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt; 
<br>Sentinel节点会定期监控主节点，所以从配置上必然也会有所体现，本配置说明Sentinel节点要监控的是一个名字叫做&lt;master-name&gt;，ip地址和端口为&lt;ip&gt;&lt;port&gt;的主节点。&lt;quorum&gt;代表要判定主节点最终不可达所需要的票数。但实际上Sentinel节点会对所有节点进行监控，但是在Sentinel节点的配置中没有看到有关从节点和其余Sentinel节点的配置，那是因为Sentinel节点会从主节点中获取有关从节点以及其余Sentinel节点的相关信息，有关这部分是如何实现的，将在9.5节介绍。 
<br>例如某个Sentinel初始节点配置如下： 
<br>port 26379 
<br>daemonize yes 
<br>logfile "26379.log" 
<br>dir /opt/soft/redis/data 
<br>sentinel monitor mymaster 127.0.0.1 6379 2 
<br>sentinel down-after-milliseconds mymaster 30000 
<br>sentinel parallel-syncs mymaster 1 
<br>sentinel failover-timeout mymaster 180000 
<br>当所有节点启动后，配置文件中的内容发生了变化，体现在三个方面： 
<br>·Sentinel节点自动发现了从节点、其余Sentinel节点。 
<br>·去掉了默认配置，例如parallel-syncs、failover-timeout参数。 
<br>·添加了配置纪元相关参数。 
<br>启动后变化为： 
<br>port 26379 
<br>daemonize yes 
<br>logfile "26379.log" 
<br>dir "/opt/soft/redis/data" 
<br>sentinel monitor mymaster 127.0.0.1 6379 2 
<br>sentinel config-epoch mymaster 0 
<br>sentinel leader-epoch mymaster 0 
<br>#发现两个slave节点 
<br>sentinel known-slave mymaster 127.0.0.1 6380 
<br>sentinel known-slave mymaster 127.0.0.1 6381 
<br>#发现两个sentinel节点 
<br>sentinel known-sentinel mymaster 127.0.0.1 26380 282a70ff56c36ed56e8f7ee6ada74124140d6f53 
<br>sentinel known-sentinel mymaster 127.0.0.1 26381 f714470d30a61a8e39ae031192f1feae7eb5b2be 
<br>sentinel current-epoch 0 
<br>&lt;quorum&gt;参数用于故障发现和判定，例如将quorum配置为2，代表至少有2个Sentinel节点认为主节点不可达，那么这个不可达的判定才是客观的。 
<br>对于&lt;quorum&gt;设置的越小，那么达到下线的条件越宽松，反之越严格。一般建议将其设置为Sentinel节点的一半加1。同时&lt;quorum&gt;还与Sentinel节点的领导者选举有关，至少要有max（quorum，num（sentinels）/2 + 1）个Sentinel节点参与选举，才能选出领导者Sentinel，从而完成故障转移。例如有5个Sentinel节点，quorum=4，那么至少要有max（quorum， num（sentinels） /2 + 1） = 4个在线Sentinel节点才可以进行领导者选举。 
<br> 
<strong>（2）sentinel down-after-milliseconds</strong> 
<br>配置如下： 
<br>sentinel down-after-milliseconds &lt;master-name&gt; &lt;times&gt; 
<br>每个Sentinel节点都要通过定期发送ping命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过了down-after-milliseconds配置的时间且没有有效的回复，则判定节点不可达，&lt;times&gt;（单位为毫秒）就是超时时间。这个配置是对节点失败判定的重要依据。 
<br> 
<p>优化说明：down-after-milliseconds越大，代表Sentinel节点对于节点不可达的条件越宽松，反之越严格。条件宽松有可能带来的问题是节点确实不可达了，那么应用方需要等待故障转移的时间越长，也就意味着应用方故障时间可能越长。条件严格虽然可以及时发现故障完成故障转移，但是也存在一定的误判率。</p> 
<strong>运维提示</strong> 
<br>down-after-milliseconds虽然以&lt;master-name&gt;为参数，但实际上对Sentinel节点、 主节点、 从节点的失败判定同时有效。 
<br> 
<strong>（3） sentinel parallel-syncs</strong> 
<br>配置如下： 
<br>sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt; 
<br>当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，parallel-syncs就是用来限制在一次故障转移之后，每次向新的主节点发起复制操作的从节点个数。如果这个参数配置的比较大，那么多个从节点会向新的主节点同时发起复制操作，尽管复制操作通常不会阻塞主节点，但是同时向主节点发起复制，必然会对主节点所在的机器造成一定的网络和磁盘IO开销。图9-17展示parallel-syncs=3和parallel-syncs=1的效果，parallelsyncs=3会同时发起复制，parallel-syncs=1时从节点会轮询发起复制。 
<br> 
<strong>（4） sentinel failover-timeout</strong> 
<br>配置如下： 
<br>sentinel failover-timeout &lt;master-name&gt; &lt;times&gt; 
<br> 
<img src="https://images2.imgbox.com/7b/5a/xRNPCYSI_o.png" alt=""> 
<br>failover-timeout通常被解释成故障转移超时时间，但实际上它作用于故障转移的各个阶段： 
<br>a）选出合适从节点。 
<br>b）晋升选出的从节点为主节点。 
<br>c）命令其余从节点复制新的主节点。 
<br>d）等待原主节点恢复后命令它去复制新的主节点。 
<br>failover-timeout的作用具体体现在四个方面： 
<br>1）如果Redis Sentinel对一个主节点故障转移失败，那么下次再对该主节点做故障转移的起始时间是failover-timeout的2倍。 
<br>2）在b）阶段时，如果Sentinel节点向a）阶段选出来的从节点执行slaveof no one一直失败（例如该从节点此时出现故障），当此过程超过failover-timeout时，则故障转移失败。 
<br>3）在b）阶段如果执行成功，Sentinel节点还会执行info命令来确认a）阶段选出来的节点确实晋升为主节点，如果此过程执行时间超过failovertimeout时，则故障转移失败。 
<br> 
<p>4）如果c）阶段执行时间超过了failover-timeout（不包含复制时间），则故障转移失败。注意即使超过了这个时间，Sentinel节点也会最终配置从节点去同步最新的主节点。</p> 
<strong>（5）sentinel auth-pass</strong> 
<br>配置如下： 
<br>sentinel auth-pass &lt;master-name&gt; &lt;password&gt; 
<br> 
<p>如果Sentinel监控的主节点配置了密码，sentinel auth-pass配置通过添加主节点的密码，防止Sentinel节点对主节点无法监控。</p> 
<strong>（6）sentinel notification-script</strong> 
<br>配置如下： 
<br>sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; 
<br>sentinel notification-script的作用是在故障转移期间，当一些警告级别的Sentinel事件发生（指重要事件，例如-sdown：客观下线、-odown：主观下线）时，会触发对应路径的脚本，并向脚本发送相应的事件参数。 
<br>例如在/opt/redis/scripts/下配置了notification.sh，该脚本会接收每个Sentinel节点传过来的事件参数，可以利用这些参数作为邮件或者短信报警依据： 
<br>#!/bin/sh 
<br>#获取所有参数 
<br>msg=$* 
<br>#报警脚本或者接口，将msg作为参数 
<br>exit 0 
<br>如果需要该功能，就可以在Sentinel节点添加如下配置（&lt;mastername&gt;=mymaster）： 
<br>sentinel notification-script mymaster /opt/redis/scripts/notification.sh 
<br> 
<p>例如下面就是某个Sentinel节点对主节点做了主观下线（有关主观下线的概念将在9.5节进行详细介绍）后脚本收到的参数：</p> 
<strong>（7） sentinel client-reconfig-script</strong> 
<br>配置如下： 
<br>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; 
<br>sentinel client-reconfig-script的作用是在故障转移结束后，会触发对应路径的脚本，并向脚本发送故障转移结果的相关参数。和notification-script类似，可以在/opt/redis/scripts/下配置了client-reconfig.sh，该脚本会接收每个Sentinel节点传过来的故障转移结果参数，并触发类似短信和邮件报警： 
<br>#!/bin/sh 
<br>#获取所有参数 
<br>msg=$* 
<br>#报警脚本或者接口， 将msg作为参数 
<br>exit 0 
<br>如果需要该功能，就可以在Sentinel节点添加如下配置（&lt;mastername&gt;=mymaster）： 
<br>sentinel client-reconfig-script mymaster /opt/redis/scripts/client-reconfig.sh 
<br>当故障转移结束，每个Sentinel节点会将故障转移的结果发送给对应的脚本，具体参数如下： 
<br>&lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt; 
<br>·&lt;master-name&gt;：主节点名。 
<br>·&lt;role&gt;：Sentinel节点的角色，分别是leader和observer，leader代表当前Sentinel节点是领导者，是它进行的故障转移； observer是其余Sentinel节点。 
<br>·&lt;from-ip&gt;：原主节点的ip地址。 
<br>·&lt;from-port&gt;：原主节点的端口。 
<br>·&lt;to-ip&gt;：新主节点的ip地址。 
<br>·&lt;to-port&gt;：新主节点的端口。 
<br>例如以下内容分别是三个Sentinel节点发送给脚本的， 其中一个是leader，另外两个是observer： 
<br>mymaster leader start 127.0.0.1 6379 127.0.0.1 6380 
<br>mymaster observer start 127.0.0.1 6379 127.0.0.1 6380 
<br>mymaster observer start 127.0.0.1 6379 127.0.0.1 6380 
<br>有关sentinel notification-script和sentinel client-reconfig-script有几点需要注意： 
<br>·&lt;script-path&gt;必须有可执行权限。 
<br>·&lt;script-path&gt;开头必须包含shell脚本头（ 例如#！ /bin/sh） ， 否则事件发生时Redis将无法执行脚本产生如下错误： 
<br>-script-error /opt/sentinel/notification.sh 0 2 
<br>·Redis规定脚本的最大执行时间不能超过60秒，超过后脚本将被杀掉。 
<br>·如果shell脚本以exit 1结束，那么脚本稍后重试执行。如果以exit 2或者更高的值结束，那么脚本不会重试。正常返回值是exit 0。 
<br> 
<p>·如果需要运维的Redis Sentinel比较多，建议不要使用这种脚本的形式来进行通知，这样会增加部署的成本。</p> 
<strong>2.如何监控多个主节点</strong> 
<br>Redis Sentinel可以同时监控多个主节点，具体拓扑图类似于图9-18。配置方法也比较简单，只需要指定多个masterName来区分不同的主节点即可，例如下面的配置监控monitor master-business-1（10.10.xx.1：6379）和monitor master-business-2（10.10.xx.2：6379）两个主节点： 
<br>sentinel monitor master-business-1 10.10.xx.1 6379 2 
<br>sentinel down-after-milliseconds master-business-1 60000 
<br>sentinel failover-timeout master-business-1 180000 
<br>sentinel parallel-syncs master-business-1 1 
<br>sentinel monitor master-business-2 10.16.xx.2 6380 2 
<br>sentinel down-after-milliseconds master-business-2 10000 
<br>sentinel failover-timeout master-business-2 180000 
<br>sentinel parallel-syncs master-business-2 1 
<br> 
<img src="https://images2.imgbox.com/3c/b1/7UhodVSf_o.png" alt=""> 
<br> 
<strong>3.调整配置</strong> 
<br>和普通的Redis数据节点一样，Sentinel节点也支持动态地设置参数，而且和普通的Redis数据节点一样并不是支持所有的参数，具体使用方法如下： 
<br>sentinel set &lt;param&gt; &lt;value&gt; 
<br>表9-3是sentinel set命令支持的参数。 
<br> 
<img src="https://images2.imgbox.com/a9/b3/rGuQI1eu_o.png" alt=""> 
<br>有几点需要注意一下： 
<br>1）sentinel set命令只对当前Sentinel节点有效。 
<br>2）sentinel set命令如果执行成功会立即刷新配置文件， 这点和Redis普通数据节点设置配置需要执行config rewrite刷新到配置文件不同。 
<br>3）建议所有Sentinel节点的配置尽可能一致，这样在故障发现和转移时比较容易达成一致。 
<br>4）表9-3中为sentinel set支持的参数，具体可以参考源码中的sentinel.c的sentinelSetCommand函数。 
<br>5）Sentinel对外不支持config命令。 
<br> 
<br> 
<strong>9.2.5 部署技巧</strong> 
<br>到现在有关Redis Sentinel的配置和部署方法相信读者已经基本掌握了，但在实际生产环境中都有哪些部署的技巧？本节将总结一下。 
<br>1）Sentinel节点不应该部署在一台物理“机器”上。 
<br>这里特意强调物理机是因为一台物理机做成了若干虚拟机或者现今比较流行的容器，它们虽然有不同的IP地址，但实际上它们都是同一台物理机，同一台物理机意味着如果这台机器有什么硬件故障，所有的虚拟机都会受到影响，为了实现Sentinel节点集合真正的高可用，请勿将Sentinel节点部署在同一台物理机器上。 
<br>2）部署至少三个且奇数个的Sentinel节点。 
<br>3个以上是通过增加Sentinel节点的个数提高对于故障判定的准确性，因为领导者选举需要至少一半加1个节点，奇数个节点可以在满足该条件的基础上节省一个节点。有关Sentinel节点如何判断节点失败，如何选举出一个Sentinel节点进行故障转移将在9.5节进行介绍。 
<br>4）只有一套Sentinel，还是每个主节点配置一套Sentinel？ 
<br>Sentinel节点集合可以只监控一个主节点，也可以监控多个主节点，也就意味着部署拓扑可能是图9-19和图9-20两种情况。 
<br> 
<img src="https://images2.imgbox.com/e0/29/PtDAq4LK_o.png" alt=""> 
<br> 
<img src="https://images2.imgbox.com/9e/35/7E5omUpy_o.png" alt=""> 
<br>                                                                              图9-20 多套Sentine节点集合 
<br>那么在实际生产环境中更偏向于哪一种部署方式呢，下面分别分析两种方案的优缺点。 
<br>方案一：一套Sentinel，很明显这种方案在一定程度上降低了维护成本，因为只需要维护固定个数的Sentinel节点，集中对多个Redis数据节点进行管理就可以了。但是这同时也是它的缺点，如果这套Sentinel节点集合出现异常，可能会对多个Redis数据节点造成影响。还有如果监控的Redis数据节点较多，会造成Sentinel节点产生过多的网络连接，也会有一定的影响。 
<br> 
<p>方案二：多套Sentinel，显然这种方案的优点和缺点和上面是相反的，每个Redis主节点都有自己的Sentinel节点集合，会造成资源浪费。但是优点也很明显，每套Redis Sentinel都是彼此隔离的。</p> 
<strong>运维提示</strong> 
<br>如果Sentinel节点集合监控的是同一个业务的多个主节点集合，那么使用方案一、否则一般建议采用方案二。 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/823fee621a4ffaaa135e000301647023/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多haar车辆检测&#43;KCF跟踪（企业级项目）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6fa4f4ddc013e39d178cba277b7d72f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">#1079 : 离散化&#43;线段树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>