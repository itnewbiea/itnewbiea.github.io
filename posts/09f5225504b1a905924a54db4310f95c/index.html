<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>都用HTTPS了，还能被查出浏览记录？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="都用HTTPS了，还能被查出浏览记录？" />
<meta property="og:description" content="最近，群里一个刚入职的小伙因为用公司电脑访问奇怪的网站，被约谈了。他很困惑 —— 访问的都是HTTPS的网站，公司咋知道他访问了啥？
实际上，由于网络通信有很多层，即使加密通信，仍有很多途径暴露你的访问地址，比如：
DNS查询：通常DNS查询是不会加密的，所以，能看到你DNS查询的观察者（比如运营商）是可以推断出访问的网站
IP地址：如果一个网站的IP地址是独一无二的，那么只需看到目标 IP地址，就能推断出用户正在访问哪个网站。当然，这种方式对于多网站共享同一个IP地址（比如CDN）的情况不好使
流量分析：当访问一些网站的特定页面，可能导致特定大小和顺序的数据包，这种模式可能被用来识别访问的网站
cookies或其他存储：如果你的浏览器有某个网站的cookies，显然这代表你曾访问过该网站，其他存储信息（比如localStorage）同理
除此之外，还有很多方式可以直接、间接知道你的网站访问情况。
本文将聚焦在HTTPS协议本身，聊聊只考虑HTTPS协议的情况下，你的隐私是如何泄露的。
HTTPS简介 我们每天访问的网站大部分是基于HTTPS协议的，简单来说，HTTPS = HTTP &#43; TLS，其中：
HTTP是一种应用层协议，用于在互联网上传输超文本（比如网页内容）。由于HTTP是明文传递，所以并不安全
TLS是一种安全协议。TLS在传输层对数据进行加密，确保任何敏感信息在两端（比如客户端和服务器）之间安全传输，不被第三方窃取或篡改
所以理论上，结合了HTTP和TLS特性的HTTPS，在数据传输过程是被加密的。但是，TLS建立连接的过程却不一定是加密的。
TLS的握手机制 当我们通过TLS传递加密的HTTP信息之前，需要先建立TLS连接，比如：
当用户首次访问一个HTTPS网站，浏览器开始查询网站服务器时，会发生TLS连接
当页面请求API时，会发生TLS连接
建立连接的过程被称为TLS握手，根据TLS版本不同，握手的步骤会有所区别。
但总体来说，TLS握手是为了达到三个目的：
协商协议和加密套件：通信的两端确认接下来使用的TLS版本及加密套件
验证省份：为了防止“中间人”攻击，握手过程中，服务器会向客户端发送其证书，包含服务器公钥和证书授权中心（即CA）签名的身份信息。客户端可以使用这些信息验证服务器的身份
生成会话密钥：生成用于加密接下来数据传输的密钥
TLS握手机制的缺点 虽然TLS握手机制会建立安全的通信，但在握手初期，数据却是明文发送的，这就造成隐私泄漏的风险。
在握手初期，客户端、服务端会依次发送、接收对方的打招呼信息。首先，客户端会向服务端打招呼（发送client hello信息），该消息包含：
客户端支持的TLS版本
支持的加密套件
一串称为客户端随机数（client random）的随机字节
SNI等一些服务器信息
服务端接收到上述消息后，会向客户端打招呼（发送server hello消息），再回传一些信息。
其中，SNI（Server Name Indication，服务器名称指示）就包含了用户访问的网站域名。
那么，握手过程为什么要包含SNI呢？
这是因为，当多个网站托管在一台服务器上并共享一个IP地址，且每个网站都有自己的SSL证书时，那就没法通过IP地址判断客户端是想和哪个网站建立TLS连接，此时就需要域名信息辅助判断。
打个比方，快递员送货上门时，如果快递单只有收货的小区地址（IP地址），没有具体的门牌号（域名），那就没法将快递送到正确的客户手上（与正确的网站建立TLS连接）。
所以，SNI作为TLS的扩展，会在TLS握手时附带上域名信息。由于打招呼的过程是明文发送的，所以在建立HTTPS连接的过程中，中间人就能知道你访问的域名信息。
企业内部防火墙的访问控制和安全策略，就是通过分析SNI信息完成的。
虽然防火墙可能已经有授信的证书，但可以先分析SNI，根据域名情况再判断要不要进行深度检查，而不是对所有流量都进行深度检查
那么，这种情况下该如何保护个人隐私呢？
Encrypted ClientHello Encrypted ClientHello（ECH）是TLS1.3的一个扩展，用于加密Client Hello消息中的SNI等信息。
当用户访问一个启用ECH的服务器时，网管无法通过观察SNI来窥探域名信息。只有目标服务器才能解密ECH中的SNI，从而保护了用户的隐私。
当然，对于授信的防火墙还是不行，但可以增加检查的成本
开启ECH需要同时满足：
服务器支持TLS的ECH扩展
客户端支持ECH
比如，cloudflare SNI测试页支持ECH扩展，当你的浏览器不支持ECH时，访问该网站sni会返回plaintext：
对于chrome，在chrome://flags/#encrypted-client-hello中，配置ECH支持：
再访问上述网站，sni如果返回encrypted则代表支持ECH。
总结 虽然HTTPS连接本身是加密的，但在建立HTTPS的过程中（TLS握手），是有数据明文传输的，其中SNI中包含了服务器的域名信息。
虽然SNI信息的本意是解决同一IP下部署多个网站，每个网站对应不同的SSL证书，但也会泄漏访问的网站地址。
ECH通过对TLS握手过程中的敏感信息（主要是SNI）进行加密，为用户提供了更强的隐私保护。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/09f5225504b1a905924a54db4310f95c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-06T14:06:42+08:00" />
<meta property="article:modified_time" content="2023-11-06T14:06:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">都用HTTPS了，还能被查出浏览记录？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近，群里一个刚入职的小伙因为用公司电脑访问奇怪的网站，被约谈了。他很困惑 —— 访问的都是<code>HTTPS</code>的网站，公司咋知道他访问了啥？<img alt="" height="213" src="https://images2.imgbox.com/cb/24/MAapmyS3_o.png" width="975"></p> 
<p>实际上，由于网络通信有很多层，即使加密通信，仍有很多途径暴露你的访问地址，比如：</p> 
<ul><li> <p><code>DNS</code>查询：通常<code>DNS</code>查询是不会加密的，所以，能看到你<code>DNS</code>查询的观察者（比如运营商）是可以推断出访问的网站</p> </li><li> <p><code>IP</code>地址：如果一个网站的<code>IP</code>地址是独一无二的，那么只需看到目标 <code>IP</code>地址，就能推断出用户正在访问哪个网站。当然，这种方式对于多网站共享同一个<code>IP</code>地址（比如<code>CDN</code>）的情况不好使</p> </li><li> <p>流量分析：当访问一些网站的特定页面，可能导致特定大小和顺序的数据包，这种模式可能被用来识别访问的网站</p> </li><li> <p><code>cookies</code>或其他存储：如果你的浏览器有某个网站的<code>cookies</code>，显然这代表你曾访问过该网站，其他存储信息（比如<code>localStorage</code>）同理</p> </li></ul> 
<p>除此之外，还有很多方式可以直接、间接知道你的网站访问情况。</p> 
<p>本文将聚焦在<code>HTTPS</code>协议本身，聊聊只考虑<code>HTTPS</code>协议的情况下，你的隐私是如何泄露的。</p> 
<h3>HTTPS简介</h3> 
<p>我们每天访问的网站大部分是基于<code>HTTPS</code>协议的，简单来说，<code>HTTPS</code> = <code>HTTP</code> + <code>TLS</code>，其中：</p> 
<ul><li> <p><code>HTTP</code>是一种应用层协议，用于在互联网上传输超文本（比如网页内容）。由于<code>HTTP</code>是明文传递，所以并不安全</p> </li><li> <p><code>TLS</code>是一种安全协议。<code>TLS</code>在传输层对数据进行加密，确保任何敏感信息在两端（比如客户端和服务器）之间安全传输，不被第三方窃取或篡改</p> </li></ul> 
<p>所以理论上，结合了<code>HTTP</code>和<code>TLS</code>特性的<code>HTTPS</code>，在数据传输过程是被加密的。但是，<code>TLS</code>建立连接的过程却不一定是加密的。</p> 
<h4>TLS的握手机制</h4> 
<p>当我们通过<code>TLS</code>传递加密的<code>HTTP</code>信息之前，需要先建立<code>TLS</code>连接，比如：</p> 
<ul><li> <p>当用户首次访问一个<code>HTTPS</code>网站，浏览器开始查询网站服务器时，会发生<code>TLS</code>连接</p> </li><li> <p>当页面请求<code>API</code>时，会发生<code>TLS</code>连接</p> </li></ul> 
<p>建立连接的过程被称为<strong>TLS握手</strong>，根据<code>TLS</code>版本不同，握手的步骤会有所区别。</p> 
<p><img alt="" height="859" src="https://images2.imgbox.com/81/fe/66FdQGWv_o.png" width="1200"></p> 
<p> </p> 
<p>但总体来说，<strong>TLS握手</strong>是为了达到三个目的：</p> 
<ol><li> <p>协商协议和加密套件：通信的两端确认接下来使用的<code>TLS</code>版本及加密套件</p> </li><li> <p>验证省份：为了防止“中间人”攻击，握手过程中，服务器会向客户端发送其证书，包含服务器公钥和证书授权中心（即<code>CA</code>）签名的身份信息。客户端可以使用这些信息验证服务器的身份</p> </li><li> <p>生成会话密钥：生成用于<strong>加密接下来数据传输</strong>的密钥</p> </li></ol> 
<h3>TLS握手机制的缺点</h3> 
<p>虽然<code>TLS</code>握手机制会建立安全的通信，但在握手初期，数据却是明文发送的，这就造成<strong>隐私泄漏</strong>的风险。</p> 
<p>在握手初期，客户端、服务端会依次发送、接收对方的<strong>打招呼信息</strong>。首先，客户端会向服务端打招呼（发送<strong>client hello信息</strong>），该消息包含：</p> 
<ul><li> <p>客户端支持的<code>TLS</code>版本</p> </li><li> <p>支持的加密套件</p> </li><li> <p>一串称为<strong>客户端随机数</strong>（<code>client random</code>）的随机字节</p> </li><li> <p><code>SNI</code>等一些服务器信息</p> </li></ul> 
<p>服务端接收到上述消息后，会向客户端打招呼（发送<strong>server hello消息</strong>），再回传一些信息。</p> 
<p>其中，<code>SNI</code>（<code>Server Name Indication</code>，服务器名称指示）就包含了用户访问的网站域名。</p> 
<p>那么，握手过程为什么要包含<code>SNI</code>呢？</p> 
<p>这是因为，当多个网站托管在一台服务器上并共享一个<code>IP</code>地址，且每个网站都有自己的<code>SSL</code>证书时，那就没法通过<code>IP</code>地址判断客户端是想和哪个网站建立<code>TLS</code>连接，此时就需要<strong>域名信息</strong>辅助判断。</p> 
<p>打个比方，快递员送货上门时，如果快递单只有收货的小区地址（<code>IP</code>地址），没有具体的门牌号（域名），那就没法将快递送到正确的客户手上（与正确的网站建立<code>TLS</code>连接）。</p> 
<p>所以，<code>SNI</code>作为<code>TLS</code>的扩展，会在<code>TLS</code>握手时附带上域名信息。由于打招呼的过程是明文发送的，所以在建立<code>HTTPS</code>连接的过程中，中间人就能知道你访问的域名信息。</p> 
<p>企业内部防火墙的访问控制和安全策略，就是通过分析<code>SNI</code>信息完成的。</p> 
<blockquote> 
 <p>虽然防火墙可能已经有授信的证书，但可以先分析<code>SNI</code>，根据域名情况再判断要不要进行深度检查，而不是对所有流量都进行深度检查</p> 
</blockquote> 
<p>那么，这种情况下该如何保护个人隐私呢？</p> 
<h3>Encrypted ClientHello</h3> 
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cloudflare.com%2Fencrypted-client-hello%2F" rel="nofollow" title="Encrypted ClientHello">Encrypted ClientHello</a>（<code>ECH</code>）是<code>TLS</code>1.3的一个扩展，用于加密<code>Client Hello</code>消息中的<code>SNI</code>等信息。</p> 
<p>当用户访问一个启用<code>ECH</code>的服务器时，网管无法通过观察<code>SNI</code>来窥探域名信息。只有目标服务器才能解密<code>ECH</code>中的<code>SNI</code>，从而保护了用户的隐私。</p> 
<blockquote> 
 <p>当然，对于授信的防火墙还是不行，但可以增加检查的成本</p> 
</blockquote> 
<p>开启<code>ECH</code>需要同时满足：</p> 
<ul><li> <p>服务器支持<code>TLS</code>的<code>ECH</code>扩展</p> </li><li> <p>客户端支持<code>ECH</code></p> </li></ul> 
<p>比如，<a href="https://link.juejin.cn?target=https%3A%2F%2Fcrypto.cloudflare.com%2Fcdn-cgi%2Ftrace" rel="nofollow" title="cloudflare SNI测试页">cloudflare SNI测试页</a>支持<code>ECH</code>扩展，当你的浏览器不支持<code>ECH</code>时，访问该网站<code>sni</code>会返回<code>plaintext</code>：</p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/bc/35/MlcSzKpm_o.png" width="898"></p> 
<p>对于<code>chrome</code>，在<a href="https://link.juejin.cn/?target=" rel="nofollow" title="chrome://flags/#encrypted-client-hello">chrome://flags/#encrypted-client-hello</a>中，配置<code>ECH</code>支持：<img alt="" height="293" src="https://images2.imgbox.com/9b/cb/nLy3apfV_o.png" width="1200"></p> 
<p> </p> 
<p>再访问上述网站，<code>sni</code>如果返回<code>encrypted</code>则代表支持<code>ECH</code>。</p> 
<h3>总结</h3> 
<p>虽然<code>HTTPS</code>连接本身是加密的，但在建立<code>HTTPS</code>的过程中（<code>TLS</code>握手），是有数据明文传输的，其中<code>SNI</code>中包含了服务器的域名信息。</p> 
<p>虽然<code>SNI</code>信息的本意是解决<strong>同一IP下部署多个网站，每个网站对应不同的SSL证书</strong>，但也会泄漏<strong>访问的网站地址</strong>。</p> 
<p><code>ECH</code>通过对<code>TLS</code>握手过程中的敏感信息（主要是<code>SNI</code>）进行加密，为用户提供了更强的隐私保护。</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/712825ba7b021212c979dfc9b72d31ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring 中 @Qualifier 注解还能这么用？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba87f4adedd3624b7e5cf5bf22a4161a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">5K买的300集全套JAVA面试视频、10W&#43;字文档成功上岸一线互联网大厂</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>