<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux struct device设备结构体 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux struct device设备结构体" />
<meta property="og:description" content="这篇是我学习时遇见的struct device内容的集合，记录着所学时对此结构体的理解，内容不完善，会不断更新
在学习Linux设备驱动时，经常遇见的是就是struct device结构体，他是保存设备基本信息的结构体。几乎在所有的驱动中都会遇见，意思就是他是驱动的设备结构体，所有的各种类型的结构体都继承他。在include/linux/device.h的723行有定义，其内容如下：
struct device { struct device	*parent; struct device_private	*p; struct kobject kobj; const char	*init_name; /* initial name of the device */ const struct device_type *type; struct mutex	mutex;	/* mutex to synchronize calls to * its driver. */ struct bus_type	*bus;	/* type of bus device is on */ struct device_driver *driver;	/* which driver has allocated this device */ void	*platform_data;	/* Platform specific data, device core doesn&#39;t touch it */ void	*driver_data;	/* Driver data, set and get with dev_set/get_drvdata */ struct dev_pm_info	power; struct dev_pm_domain	*pm_domain; #ifdef CONFIG_PINCTRL struct dev_pin_info	*pins; #endif #ifdef CONFIG_NUMA int	numa_node;	/* NUMA node this device is close to */ #endif u64	*dma_mask;	/* dma mask (if dma&#39;able device) */ u64	coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1dfba41f72d72a21cb071b11907abf3a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-27T17:36:14+08:00" />
<meta property="article:modified_time" content="2020-03-27T17:36:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux struct device设备结构体</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>这篇是我学习时遇见的struct device内容的集合，记录着所学时对此结构体的理解，内容不完善，会不断更新</strong><br> 在学习Linux设备驱动时，经常遇见的是就是struct device结构体，他是保存设备基本信息的结构体。几乎在所有的驱动中都会遇见，意思就是他是驱动的设备结构体，所有的各种类型的结构体都继承他。在include/linux/device.h的723行有定义，其内容如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> device <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> device		<span class="token operator">*</span>parent<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> device_private	<span class="token operator">*</span>p<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> kobject kobj<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span>		<span class="token operator">*</span>init_name<span class="token punctuation">;</span> <span class="token comment">/* initial name of the device */</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> device_type <span class="token operator">*</span>type<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> mutex		mutex<span class="token punctuation">;</span>	<span class="token comment">/* mutex to synchronize calls to
					 * its driver.
					 */</span>

	<span class="token keyword">struct</span> bus_type	<span class="token operator">*</span>bus<span class="token punctuation">;</span>		<span class="token comment">/* type of bus device is on */</span>
	<span class="token keyword">struct</span> device_driver <span class="token operator">*</span>driver<span class="token punctuation">;</span>	<span class="token comment">/* which driver has allocated this
					   device */</span>
	<span class="token keyword">void</span>		<span class="token operator">*</span>platform_data<span class="token punctuation">;</span>	<span class="token comment">/* Platform specific data, device
					   core doesn't touch it */</span>
	<span class="token keyword">void</span>		<span class="token operator">*</span>driver_data<span class="token punctuation">;</span>	<span class="token comment">/* Driver data, set and get with
					   dev_set/get_drvdata */</span>
	<span class="token keyword">struct</span> dev_pm_info	power<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> dev_pm_domain	<span class="token operator">*</span>pm_domain<span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> CONFIG_PINCTRL</span>
	<span class="token keyword">struct</span> dev_pin_info	<span class="token operator">*</span>pins<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> CONFIG_NUMA</span>
	<span class="token keyword">int</span>		numa_node<span class="token punctuation">;</span>	<span class="token comment">/* NUMA node this device is close to */</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
	u64		<span class="token operator">*</span>dma_mask<span class="token punctuation">;</span>	<span class="token comment">/* dma mask (if dma'able device) */</span>
	u64		coherent_dma_mask<span class="token punctuation">;</span><span class="token comment">/* Like dma_mask, but for
					     alloc_coherent mappings as
					     not all hardware supports
					     64 bit addresses for consistent
					     allocations such descriptors. */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span>	dma_pfn_offset<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> device_dma_parameters <span class="token operator">*</span>dma_parms<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> list_head	dma_pools<span class="token punctuation">;</span>	<span class="token comment">/* dma pools (if dma'ble) */</span>

	<span class="token keyword">struct</span> dma_coherent_mem	<span class="token operator">*</span>dma_mem<span class="token punctuation">;</span> <span class="token comment">/* internal for coherent mem
					     override */</span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> CONFIG_DMA_CMA</span>
	<span class="token keyword">struct</span> cma <span class="token operator">*</span>cma_area<span class="token punctuation">;</span>		<span class="token comment">/* contiguous memory area for dma
					   allocations */</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
	<span class="token comment">/* arch specific additions */</span>
	<span class="token keyword">struct</span> dev_archdata	archdata<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> device_node	<span class="token operator">*</span>of_node<span class="token punctuation">;</span> <span class="token comment">/* associated device tree node */</span>
	<span class="token keyword">struct</span> fwnode_handle	<span class="token operator">*</span>fwnode<span class="token punctuation">;</span> <span class="token comment">/* firmware device node */</span>

	dev_t			devt<span class="token punctuation">;</span>	<span class="token comment">/* dev_t, creates the sysfs "dev" */</span>
	u32			id<span class="token punctuation">;</span>	<span class="token comment">/* device instance */</span>

	spinlock_t		devres_lock<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> list_head	devres_head<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> klist_node	knode_class<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> class		<span class="token operator">*</span>class<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> attribute_group <span class="token operator">*</span><span class="token operator">*</span>groups<span class="token punctuation">;</span>	<span class="token comment">/* optional groups */</span>

	<span class="token keyword">void</span>	<span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> device <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> iommu_group	<span class="token operator">*</span>iommu_group<span class="token punctuation">;</span>

	bool			offline_disabled<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>
	bool			offline<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>2020/3/27更新</strong> ：struct device内容有这个：</p> 
<pre><code class="prism language-c"><span class="token operator">*</span> @of_node<span class="token punctuation">:</span>	Associated device tree node<span class="token punctuation">.</span>
<span class="token keyword">struct</span> device_node	<span class="token operator">*</span>of_node<span class="token punctuation">;</span>
</code></pre> 
<p>这是struct device_node类型，保存着当前设备结点信息。上面是此变量的注释，大概意思就是 关联设备树节点。比如，当获得i2c设备信息时（i2c设备信息结构体struct i2c_client),i2c_client结构体里面有struct device <strong>device</strong>变量，此<strong>device</strong>的of_node变量就是当前在设备树中此i2c设备结点，就可以通过此节点获取设备树中此节点的任何信息。</p> 
<p><strong>2020/3/28更新</strong>：</p> 
<pre><code class="prism language-c"> <span class="token punctuation">.</span> @parent<span class="token punctuation">:</span>	The device's <span class="token string">"parent"</span> device<span class="token punctuation">,</span> the device to which it is attached<span class="token punctuation">.</span>
 <span class="token operator">*</span> 		In most cases<span class="token punctuation">,</span> a parent device is some sort of bus or host
 <span class="token operator">*</span> 		controller<span class="token punctuation">.</span> If parent is <span class="token constant">NULL</span><span class="token punctuation">,</span> the device<span class="token punctuation">,</span> is a top<span class="token operator">-</span>level device<span class="token punctuation">,</span>
 <span class="token operator">*</span> 		which is not usually what you want<span class="token punctuation">.</span>
<span class="token keyword">struct</span> device		<span class="token operator">*</span>parent<span class="token punctuation">;</span>
</code></pre> 
<p>这也是struct device类型，表示当前设备的父设备。上面是此变量的注释，大概意思就是当前设备所连接的上层设备叫父设备，大多数情况下，父设备是总线或者主机控制器，如果父设备是空的，表示这是最顶层的设备。比如：我现在input子系统驱动屏幕触控IC，触控IC所使用的总线是I2C，所示可表示：input输入子系统设备的父设备是屏幕触控IC，而触控IC的父设备是I2C总线控制器。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07c2b4481e74a2b00c12185a0c7a47da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Caused by: java.lang.NoClassDefFoundError：</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b54125a50c418596c19188796bafd7e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">信息检索中 (IR) 的评价指标: P@n, MAP, MRR, DCG, NDCG</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>