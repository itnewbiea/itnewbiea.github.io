<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;通过匿名对象调用成员函数 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;通过匿名对象调用成员函数" />
<meta property="og:description" content="C&#43;&#43; 通过匿名对象调用成员函数 刚开始写第一个 leetcode 程序就看到了之前没见到过的东西。首先，框架定义了一个Solution类，我们把方法写在成员函数twoSum(int,int)内，main()函数直接通过构造一个匿名的对象调用该成员函数。
vector&lt;int&gt; ret = Solution().twoSum(nums, target); 进一步总结，如果想要调用成员函数，其实是有三种方法的： 1、设置成静态成员函数，可以直接通过类名调用 Class::fun();
2、创建一个对象 object，使用object.fun()方法调用;
3、创建一个匿名的对象，使用匿名对象调用 Class().fun();
参考：http://www.cnblogs.com/gossiplee/p/4612929.html 《C&#43;&#43;临时匿名对象》
#include &#34;iostream&#34; using namespace std; class A { public: A (int _a=0, int _b=0) { this-&gt;a1 = _a; this-&gt;b1 = _b; cout &lt;&lt; &#34;construct function called！&#34; &lt;&lt; endl; } A (A &amp;obj) { cout &lt;&lt; &#34;copy_constructor function called!&#34; &lt;&lt; endl; } ~A() { cout &lt;&lt; &#34;objext destory function called!&#34; &lt;&lt; endl; } void printf() { cout &lt;&lt; this-&gt;a1 &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ecf549ba2ace8c0a44ca19f63d6bc4d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-15T17:36:29+08:00" />
<meta property="article:modified_time" content="2019-05-15T17:36:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;通过匿名对象调用成员函数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>C++ 通过匿名对象调用成员函数</h3> 
<p>刚开始写第一个 leetcode 程序就看到了之前没见到过的东西。首先，框架定义了一个Solution类，我们把方法写在成员函数twoSum(int,int)内，main()函数直接通过构造一个匿名的对象调用该成员函数。</p> 
<pre class="has"><code class="language-cpp">vector&lt;int&gt; ret = Solution().twoSum(nums, target);</code></pre> 
<h3><strong>进一步总结，如果想要调用成员函数，其实是有三种方法的：</strong></h3> 
<p>1、设置成静态成员函数，可以直接通过类名调用 Class::fun();</p> 
<p>2、创建一个对象 object，使用object.fun()方法调用;</p> 
<p>3、创建一个匿名的对象，使用匿名对象调用 Class().fun();</p> 
<p> </p> 
<p>参考：<a href="http://www.cnblogs.com/gossiplee/p/4612929.html" rel="nofollow">http://www.cnblogs.com/gossiplee/p/4612929.html</a>  《<a href="https://www.cnblogs.com/gossiplee/p/4612929.html" rel="nofollow" id="cb_post_title_url">C++临时匿名对象</a>》</p> 
<pre class="has"><code class="language-cpp">#include "iostream"
using namespace std;

class A
{
public:
    A (int _a=0, int _b=0)
    {
        this-&gt;a1 = _a;
        this-&gt;b1 = _b;
        cout &lt;&lt; "construct function called！" &lt;&lt; endl;
    }
    A (A &amp;obj)
    {
        cout &lt;&lt; "copy_constructor function called!" &lt;&lt; endl;
    }
    ~A()
    {
        cout &lt;&lt; "objext destory function called!" &lt;&lt; endl;
    }
    void printf()
    {
        cout &lt;&lt; this-&gt;a1 &lt;&lt; " " &lt;&lt; this-&gt;b1 &lt;&lt; endl;

    }
protected:
private:
    int a1;
    int b1;
};

int main()
{
    A(10, 10).printf();  //直接通过类名构造一个匿名对象，用后即焚
    cout &lt;&lt; "在此处打印之前，匿名对象就已经被析构！" &lt;&lt; endl;
    return 0;
}</code></pre> 
<h3>顺便说一下C++ 11中引入的匿名函数</h3> 
<p>参考：<a href="https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html" rel="nofollow">C++11中的匿名函数(lambda函数,lambda表达式)</a></p> 
<p>　　C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式). Lambda表达式具体形式如下:</p> 
<p>　　　　[capture](parameters)-&gt;return-type{body}</p> 
<p>　　如果没有参数,空的圆括号()可以省略.返回值也可以省略,如果函数体只由一条return语句组成或返回类型为void的话.形如:</p> 
<p>　　 　 [capture](parameters){body}</p> 
<p>　　下面举了几个Lambda函数的例子:  </p> 
<pre class="has"><code class="language-cpp">[](int x, int y) { return x + y; } // 隐式返回类型
[](int&amp; x) { ++x; }   // 没有return语句 -&gt; lambda 函数的返回类型是'void'
[]() { ++global_x; }  // 没有参数,仅访问某个全局变量
[]{ ++global_x; }     // 与上一个相同,省略了()
[](int x, int y) -&gt; int { int z = x + y; return z; } //有一个int返回值


lambda函数可以引用在它之外声明的变量。这些变量的集合叫做一个闭包，闭包被定义在lambda表达式声明的方括号[]内，这个机制允许这些变量按值或按引用被捕获：

[]        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
[x, &amp;y]   //x 按值捕获, y 按引用捕获.
[&amp;]       //用到的任何外部变量都隐式按引用捕获
[=]       //用到的任何外部变量都隐式按值捕获
[&amp;, x]    //x显式地按值捕获. 其它变量按引用捕获
[=, &amp;z]   //z按引用捕获. 其它变量按值捕获

举一个例子
std::vector&lt;int&gt; some_list;
int total = 0;
for (int i=0;i&lt;5;++i) some_list.push_back(i);
std::for_each(begin(some_list), end(some_list), [&amp;total](int x) 
{
    total += x;
});

//此例计算list中所有元素的总和. 变量total被存为lambda函数闭包的一部分. 因为它是栈变量(局部变量)total的引用,所以可以改变它的值</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9667ff32b042c325e728bc160cd7395c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS7 中MySQL的安装以及MySQL密码的修改</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40837d150b037e3a222965ebab9e3498/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记一次post请求参数为json格式时，HTTPServletRequest拿不到请求参数问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>