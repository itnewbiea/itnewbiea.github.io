<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenGL 简介 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenGL 简介" />
<meta property="og:description" content="OpenGL 简介 一、GPU 接口规范 对于刚接触 OpenGL 的初学者,常常会有这样一个疑问: OpenGL 的源码在哪里,如何编译?
然而实际上 OpenGL 并不是一个软件实现,更多的是一个标准协议; OpenGL 更像是一种显卡驱动标准,由各个硬件厂家适配,各个硬件厂商根据 OpenGL 接口规范编撰对应的驱动.
换句话说,对于各个硬件厂商 OpenGL 确实是一个基于 GPU 的软件实现,但是对于普通的应用层开发者 OpenGL 就是一个由硬件厂商提供的驱动程序罢了,也就是为什么你找不到 OpenGL 源代码实现的原因了.
OpenGL 是操作 GPU 的其中一种方法,但绝不是唯一的途径; OpenGL 由 Khronos 进行管理,在 Khronos 的官网下,你可以找到下面这张图:
在这里,你可能看到一些熟悉的名称,比如 EGL 、glTF、OpenCL、OpenGL 以及 Vulkan等等,这里定义了许多标准规范;这里我们仅仅谈及真正直接操作GPU的标准协议,也就是下图中 3D Graphics 的部分:
然后呢,这就是全部了吗? 实际并不是, Khronos 更多像是一个联盟,有着许多成员如 Apple、Intel、AMD、Google、ARM、Qualcomm、Nvidia 等等成员.
所以,也就会出现&#34;分道扬镳&#34;的现象,比如:
微软下的 Direct X (D3D9、D3D11、D3D12),对标 OpenGL:
苹果下的 Metal, 还是对标 OpenGL:
以及英伟达大名鼎鼎的 CUDA, 对标 OpenCL:
可以看到关于一个 GPU 接口规范的指定,出现了很多不同的角色比如硬件产商、操作系统提供者等等;为什么会出现这么多种规范呢?其中一部分原因来自于某一种标准实现并不适用于某些场景,但还有其他一部分原因就是跟为什么有这么多中编程语言类似的原因.
二、GPU 接口分类 GPU(Graphic Processing Unit)按我的理解可以分为两大类 GL(Graphic Language) 和 CL(Compute Language):" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/cfde3856c9c62877c7e0c4e29037fc1f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-21T10:24:30+08:00" />
<meta property="article:modified_time" content="2023-04-21T10:24:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenGL 简介</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="OpenGL__1"></a>OpenGL 简介</h2> 
<h3><a id="GPU__3"></a>一、GPU 接口规范</h3> 
<p>对于刚接触 <code>OpenGL</code> 的初学者,常常会有这样一个疑问: <code>OpenGL</code> 的源码在哪里,如何编译?</p> 
<p>然而实际上 <code>OpenGL</code> 并不是一个软件实现,更多的是一个标准协议; <code>OpenGL</code> 更像是一种显卡驱动标准,由各个硬件厂家适配,各个硬件厂商根据 <code>OpenGL</code> 接口规范编撰对应的驱动.</p> 
<blockquote> 
 <p>换句话说,对于各个硬件厂商 <code>OpenGL</code> 确实是一个基于 <code>GPU</code> 的软件实现,但是对于普通的应用层开发者 <code>OpenGL</code> 就是一个由硬件厂商提供的驱动程序罢了,也就是为什么你找不到 <code>OpenGL</code> 源代码实现的原因了.</p> 
</blockquote> 
<p><code>OpenGL</code> 是操作 <code>GPU</code> 的其中一种方法,但绝不是唯一的途径; <code>OpenGL</code> 由 <code>Khronos</code> 进行管理,在 <code>Khronos</code> 的<a href="https://www.khronos.org/" rel="nofollow">官网</a>下,你可以找到下面这张图:</p> 
<p><img src="https://images2.imgbox.com/46/96/GUPfbuNY_o.png" alt="Khronos_Brief"></p> 
<p>在这里,你可能看到一些熟悉的名称,比如 <code>EGL</code> 、<code>glTF</code>、<code>OpenCL</code>、<code>OpenGL</code> 以及 <code>Vulkan</code>等等,这里定义了许多标准规范;这里我们仅仅谈及<strong>真正直接</strong>操作<code>GPU</code>的标准协议,也就是下图中 <code>3D Graphics</code> 的部分:</p> 
<p><img src="https://images2.imgbox.com/60/8c/MWftbW9C_o.png" alt="Khronos_Classification"></p> 
<p>然后呢,这就是全部了吗? 实际并不是, <code>Khronos</code> 更多像是一个联盟,有着许多成员如 <code>Apple</code>、<code>Intel</code>、<code>AMD</code>、<code>Google</code>、<code>ARM</code>、<code>Qualcomm</code>、<code>Nvidia</code> 等等成员.</p> 
<p>所以,也就会出现"分道扬镳"的现象,比如:</p> 
<p>微软下的 <code>Direct X</code> (D3D9、D3D11、D3D12),对标 <code>OpenGL</code>:</p> 
<p><img src="https://images2.imgbox.com/26/79/8r9IADe2_o.png" alt="Dirext_X"></p> 
<p>苹果下的 <code>Metal</code>, 还是对标 <code>OpenGL</code>:</p> 
<p><img src="https://images2.imgbox.com/5f/99/ERCPalUD_o.png" alt="Metal"></p> 
<p>以及英伟达大名鼎鼎的 <code>CUDA</code>, 对标 <code>OpenCL</code>:</p> 
<p><img src="https://images2.imgbox.com/f2/16/IeG7RqvC_o.png" alt="CUDA"></p> 
<p>可以看到关于一个 GPU 接口规范的指定,出现了很多不同的角色比如硬件产商、操作系统提供者等等;为什么会出现这么多种规范呢?其中一部分原因来自于某一种标准实现并不适用于某些场景,但还有其他一部分原因就是跟为什么有这么多中编程语言类似的原因.</p> 
<h3><a id="GPU__37"></a>二、GPU 接口分类</h3> 
<p><code>GPU</code>(Graphic Processing Unit)按<strong>我的理解</strong>可以分为两大类 <code>GL</code>(Graphic Language) 和 <code>CL</code>(Compute Language):</p> 
<p><img src="https://images2.imgbox.com/15/8e/z2x3WJ5o_o.png" alt="GPU_Classification"></p> 
<p>本文讨论的重点在 <code>OpenGL</code>, 故实际上处于 <code>GPU</code> 的 <code>GL</code> 分支.</p> 
<blockquote> 
 <p>题外话</p> 
 <p>实际上很多人会发现 <code>VULKAN</code> 和 <code>OpenGL</code> 非常的相似,虽然<code>VULKAN</code> 一方面是为了解决 <code>OpenGL</code> 设计之初留下的问题,但 <code>VULKAN</code> 个人认为另一个积极的意义是在于给予行业一个新的标准化机会;例如 <code>VULKAN</code> 的协议制定苹果就挺上心的 (毕竟"分道扬镳"对于开发者而言意味着成倍的开发成本,对于厂商则很难形成一个开发者愿意投入的生态).</p> 
</blockquote> 
<blockquote> 
 <p>From Arm Mali Developer OpenGL ES 3.x GUIDE</p> 
 <p>Built from the ground up, Vulkan was intended to replace OpenGL as the main graphics API.</p> 
 <p>OpenGL had successfully served the industry for more than 20 years, but it was time for a clean</p> 
 <p>start. The new graphics API was expected to provide a set of benefits across multiple platforms</p> 
 <p>that the graphics community recognizes and values today.</p> 
</blockquote> 
<h3><a id="OpenGL__58"></a>三、OpenGL 设计结构</h3> 
<p>如果用一句话来描述 <code>OpenGL</code> 的话,我想应该是基于C/S结构设计的模板模式(设计模式里的那个);在 <strong>图形渲染管线</strong> 这节,主要介绍的是其模板设计,在 <code>OpenGL</code> 里我们称之为 <code>PipeLine</code>;在 <strong>C/S结构</strong> 这节,则介绍 <code>OpenGL</code> C/S 结构给 <code>OpenGL</code> 带来的一些对于初学者看起来可能觉得奇奇怪怪的东西.</p> 
<h4><a id="1__62"></a>(1) 图形渲染管线</h4> 
<p>下图是出自于 <code>es_spec_3.2.pdf</code> 中 <code>Dataflow Model</code>:</p> 
<p><img src="https://images2.imgbox.com/67/ea/5zFTtEz6_o.png" alt="OpenGL_Pipeline"></p> 
<p>这张图描述的东西挺多,但对于初学 <code>OpenGL</code> 只需要关心红色标注部分即可.其他部分例如 <code>Framebuffer</code> 的一部分 (Default Framebuffer) 在本章中由 <code>EGL</code> 负责; 而 <code>Compute Shader</code> 则是 <code>OpenGL</code> 提供的 <code>CL</code> 功能,目前讲述的是 <code>GL</code> 的部分,故省略.</p> 
<p>上图就是 <code>OpenGL</code> 渲染管线整体的数据流图,仔细观察图中的左下方可以发现, <code>OpenGL</code> 按照颜色对不同的部分进行了区分,例如 <code>Fixed Function Stage</code> 以及 <code>Programmable Stage</code> 等等; 对于大部分的开发者而言需要关注 <code>Fixed Function Stage</code> 中的 <code>Vertex Shader</code> 以及 <code>Fragement Shader</code>,以及<strong>理解</strong> <code>Fixed Function Stage</code> 中的 <code>Rasterization</code> 、<code>Per-Fragement Operations</code> 以及 <code>Tessellation Primitive Gen</code> 等步骤.某些 <code>Fixed Function Stage</code> 对于开发者而言属于不可控制的节点,但是只有充分理解其行为才能在其他<strong>可编程</strong>部分写出自己想要的程序.</p> 
<blockquote> 
 <p>题外话: 为什么要引入 Pipeline 的概念呢?</p> 
 <p>Each pipeline is controlled by a monolithic object created from a description of all of the shader</p> 
 <p>stages and any relevant fixed-function stages. Linking the whole pipeline together allows the</p> 
 <p>optimization of shaders based on their input/outputs and eliminates expensive draw time state</p> 
 <p>validation. (from vulkan spec)</p> 
</blockquote> 
<h4><a id="2_CS_82"></a>(2) C/S结构</h4> 
<p>谈起 <code>OpenGL</code> C/S 结构,就不得不提 <code>OpenGL</code> 对于开发者的一个强约束限制,就是: 只能在 <code>OpenGL</code> 所在的 <code>context</code> 线程里操作 <code>OpenGL</code> 的接口.</p> 
<p>语言上可能很难说清楚这个 C/S 到底是什么结构,但是图例可能会相对清楚,例如使用 <code>EGL</code> 来创建 <code>OpenGL context</code> 时,在 <code>eglInitialize</code> 调用前后,可以看到这样有意思的现象:</p> 
<p><img src="https://images2.imgbox.com/58/2b/xSMA6LP0_o.png" alt="EGL_BEFORE"><br> <img src="https://images2.imgbox.com/33/b3/7IBLh0bK_o.png" alt="EGL_AFTER"></p> 
<p>在前后两个接口调用前,程序的堆栈发生了明显的变化,这些多出来的线程主要就是用来辅助 <code>OpenGL Server</code> 运行的;实际上<strong>直到</strong>调用<code>EGL</code>接口<code>eglMakeCurrent</code>前,都是不能调用 <code>OpenGL</code> 接口的.其实也很好理解, <code>Server</code> 都没运行起来, <code>Client</code> 怎么能请求呢?</p> 
<p>实际上,很多人说创建 <code>OpenGL context</code> 是为了给 <code>OpenGL</code> 提供一个渲染使用的<strong>画布</strong>;在我看来这种说法固然没有什么错误,不过我觉得更大一部分的贡献是在于运行起 <code>OpenGL Server</code>. 创建 <code>OpenGL context</code> 有很多种方式,例如使用 <code>EGL</code>、<code>SDL</code> 、<code>GLFW</code>、<code>QT</code>等等非常多种;为什么存在这种多种创建方式的主要原因在于: <code>OpenGL</code> 希望自己与硬件无关,而创建 <code>OpenGL context</code> 往往需要涉及到具体的硬件信息,比如这个 <code>context</code> 是运行在哪一个 <code>Display</code> 上 (<code>OpenGL</code> 标准里有针对于此详细的信息,有兴趣可以自己翻阅下).</p> 
<p>在嵌入式上, <code>EGL</code> 、<code>OpenGL ES</code> 以及 <code>GLSL ES</code> 往往是一起使用的三剑客; 在这里实际上已经简单涉及到了 <code>EGL</code> 了,受限于篇幅本章就不再展开 <code>EGL</code> 相关的细节.</p> 
<blockquote> 
 <p>由于 <code>OpenGL</code> 只是一个规范而非实现,所以上面的现象在不同硬件平台,不同版本里面的现象可能是不同的;<code>OpenGL</code> 标准里也有明确写明,这要能保证接口调用的结果是符合预期的,<code>OpenGL</code> 不关注具体实现.</p> 
</blockquote> 
<p>那这种 C/S 结构对于我们使用 <code>OpenGL</code> 有什么影响呢? 最大的影响就是在于我们只能在 <code>OpenGL context</code> 所在的线程调用 <code>OpenGL</code> 的接口,详细阅读 <code>EGL</code> 标准你会知道所有 <code>OpenGL</code> 接口都存在一个阴式的入参,就是 <code>OpenGL Context</code>; 这种接口设计广泛存在于 <code>OpenGL</code> 的各种接口,在深入学习 <code>OpenGL</code> 之后应该会更加有感触,这里由于篇幅也不再展开了.</p> 
<h3><a id="_101"></a>四、渲染管线</h3> 
<p>在这节里,会对 <strong>图形渲染管线</strong> 小结中部分出现的环节进行描述,旨在理解一个完整 <code>OpenGL</code> 渲染管线的运行流程以及其逻辑.</p> 
<h4><a id="1__105"></a>(1) 背景补充</h4> 
<p>在真正描述渲染管线前,需要知道以下几个常识:</p> 
<ul><li>两点确定一条直线</li><li>三点确定一个三角形</li><li>n边形可以由 (n-2) 个三角形组成</li></ul> 
<p>在 <code>OpenGL</code> 中,所有图形均有点(point)、线(Line Segment)、三角形(Triangle)组成;换句话说对于 <code>OpenGL</code> 而言最基础的元素是<strong>点</strong>,在 <code>OpenGL</code> 里称之为顶点(Vertex),对应的可编程节点则是 <code>Vertex Shader</code>.</p> 
<p>而另外一个可编程节点则是 <code>Fragment Shader</code>;在非常早期的时候 <code>Fragment Shader</code> 其实是叫做 <code>Pixel Shader</code>; <code>OpenGL</code> 将 <code>Pixel</code> 替换为了 <code>Fragment</code> 的一个原因是在于 <code>Pixel</code> 强调的是一个点的概念而 <code>Fragment</code> 则是代表一个面的概念;在实际屏幕显示时，实际上对应的是一块块像素块,而像素块并不一定是正方形,所以后来修改为 <code>Fragment</code> 强调面的概念.对于初学者而言,可能 <code>Pixel Shader</code> 会更加容易理解.</p> 
<h4><a id="2_GLSL_117"></a>(2) GLSL</h4> 
<p><code>OpenGL</code> 整个渲染管线中存在可编程节点, <code>OpenGL</code> 将它们统称为 <code>Shader</code>. 值得注意的是,并不是所有可编程节点都是需要的;在大多数场景下,我们只需要处理 <code>Vertex Shader</code> 和 <code>Fragment Shader</code> 就足够了.</p> 
<p>为了实现可编程的这个目标, <code>OpenGL</code> 需要搭配一门 <code>GPU</code> 编程语言使用,即 <code>GLSL</code>(OpenGL Shading Language); 实际上对于大部分 <code>GPU</code> 开发者而言,最终的主要任务就是编写和优化 <code>GLSL</code>, 高效的 <code>GLSL</code> 能够节约 <code>GPU</code> 的使用资源以及缩短 <code>GPU</code> 的处理时间.</p> 
<p>在本章中由于篇幅也不打算展开 <code>GLSL</code> 的细节描述,在之后以案例的感性形式给出一个 <code>GLSL</code> 的使用.这里给出一个示例的 <code>GLSL</code> 写法,对应亮度擦除(转场)的实现:</p> 
<pre><code class="prism language-glsl"># vertex
attribute vec3 Position;
attribute vec2 iUv;
varying   vec2 oUV;
uniform mat4 WorldViewProj;

void main(void)
{
    oUV         =  iUv;
    gl_Position =  WorldViewProj * vec4(Position, 1.0);
}
</code></pre> 
<pre><code class="prism language-glsl"># fragment
varying vec2 oUV;
uniform sampler2D TexA;
uniform sampler2D TexB;
uniform sampler2D TexL;
uniform float Progress;

void main(void)
{
    float softness = 0.03f;
    float luma = texture(TexL, oUV).x;
    float time = mix(0.0f, 1.0f + softness, Progress);

    vec4 acolor = texture(TexA, oUV);
    vec4 bcolor = texture(TexB, oUV);

    if (luma &lt;= time - softness)
    {
        gl_FragColor = bcolor;
    }
    else if (luma &gt;= time)
    {
        gl_FragColor = acolor;
    }
    else
    {
        float alpha = (time - luma) / softness;
        gl_FragColor = mix(acolor, bcolor, alpha);
    }
}
</code></pre> 
<p>在 <code>GLSL</code> 中,变量简单地将可以分为 <code>attribute</code> 、<code>varying</code> 和 <code>uniform</code> 三种. 由于历史的原因 <code>attribute</code> 也称之为 <code>in</code>,而 <code>varying</code> 则称之为 <code>output</code>.可以在 <code>GLSL</code> 标准中找到下列表述:</p> 
<blockquote> 
 <p>Not all language constructs present in earlier versions of the language are available in later</p> 
 <p>versions e.g. attribute and varying qualifiers are present in v1.00 but not v3.00. However, the</p> 
 <p>functionality of GLSL ES 3.20 is a super-set of GLSL ES 3.10.</p> 
</blockquote> 
<p>可以看到目前 <code>GLSL</code> 更推崇使用 <code>in</code> 代替废弃的 <code>attribute</code>,而使用 <code>out</code> 去代替废弃的 <code>varying</code>;但是个人认为它们还是尤其意义的,尤其是对于初学者而言,例如 <code>OpenGL</code> 可只有 <code>glBindAttribLocation</code> 接口,可没有 <code>glBindInputLocation</code>;为了做一下兼容处理,一般会在 <code>GLSL</code> 程序前写入一段宏定义:</p> 
<pre><code class="prism language-glsl">#if __VERSION__ &gt;= 130
    #define attribute in
    #define varying out
#endif
</code></pre> 
<p>如果我们将 <code>Shader</code> 理解为一个函数,那么就存在入参和出参,分别对应于 <code>attribute</code> 和 <code>varying</code>;这里可以抛出一个问题, <code>attribute</code> 入参是如何传递进去的? 要回答这个问题,需要回到 <code>OpenGL Pipeline</code> 的数据流图:</p> 
<p><img src="https://images2.imgbox.com/8b/31/NWFwPxOO_o.png" alt="OpenGL_Pipeline"></p> 
<p>在整个 <code>PipeLine</code> 运行之初存在一个 <code>Vertex Puller</code> 的环节,<code>Vetex Shader</code> 中的 <code>attribute</code> 就是从这里传递进去的;那么 <code>Fragment Shader</code> 的 <code>attribute</code>呢? 仔细观察上面 <code>vertex</code> 和 <code>fragment</code> 的代码以及结合 <code>varying</code> 这个单词的含义,就能找到答案.注意对你而言,只有 <code>Vetex Shader</code> 的入参是你真正自己传递进去的.</p> 
<p>在 <code>GLSL</code> 中除了 <code>attribute</code> 和 <code>varying</code>,还存在一个广泛使用的类型 <code>uniform</code>, 一般我们可以将其理解为常量即可; <code>uniform</code> 可以分为两大类,详细可看下 <code>OpenGL ES</code> 标准中的 <code>7.6 Uniform Variables</code>:</p> 
<ul><li>Named uniform blocks</li><li>Default uniform block</li></ul> 
<p>其中特别指出 <code>Uniforms in the default uniform block are program object-specific state.</code>, 其实就是再说有些 <code>uniform</code> 类似于一个句柄,我们只能通过 <code>GLSL</code> 内置接口去操作,例如上面出现的 <code>sampler2D</code> 去操作;而另外的 <code>uniform</code> 而是开发者传递进去的.</p> 
<p>其实这里我个人觉得将 <code>uniform</code> 描述为常量在初期是会造成一些理解上的偏差的. 例如 <code>uniform</code> 都是一个常量了,为什么我不能直接将其内嵌入代码即可? 这实际是在于 <code>uniform</code> 只是在一次 <code>Pipeline</code> 过程中才是常量;例如在上面的例子中,存在 <code>uniform</code> 变量 <code>Progress</code>, 实际程序运行的过程中它以 60hz 的速率,从 0.0f 到 1.0f 以 1.0f/60 步进的速率发生着改变,不然图像怎么会出现变化呢?</p> 
<p>然后不同 <code>Shader</code> 存在着不同的内置变量,例如 <code>Vertex</code> 存在内置变量 <code>gl_Position</code> 对应着一个顶点的坐标, 而 <code>Fragment</code> 则存在内置变量 <code>gl_FragColor</code> 对应着一个像素点信息.</p> 
<blockquote> 
 <p><code>OpenGL</code> 的坐标分为 w、y、z、w, 即非笛卡尔坐标,当 w 为 1 则可以理解为笛卡尔坐标系; 此外,坐标的取值分为为 [-1.0f, 1.0f], (0.0, 0.0) 代表中心坐标,也是为什么你会经常看到一个类似于 <code>WorldViewProj</code> 的 <code>uniform</code> 变量, 世界坐标系投影.</p> 
</blockquote> 
<p>这里又引出一个很有趣的问题,假设我们需要绘制一张 1080P 的图片; 那么需要两个三角形,对应6个坐标顶点, <code>gl_Position</code> 需要被赋值 6 次; 而 <code>gl_FragColor</code> 则需要被赋值 1080*1920 次. 这里可以停下来思考一个问题, <code>vertex</code> 中的 <code>oUV</code> 和 <code>fragment</code> 中的 <code>oUV</code> 数量是一致的吗? <code>uniform</code> 变量 <code>Progress</code> 到底存在几个?</p> 
<p>回答得了这个问题,就打开了 GPU GL 并行处理的大门; 这个问题将会在 <code>Rasterization</code> 栅格化中解释.</p> 
<h4><a id="3__212"></a>(3) 栅格化</h4> 
<p>对于开发者而言,传入的只是几个顶点坐标,而实际上渲染时肯定针对的是一块像素区域;从 <code>Vertex</code> 到 <code>Fragment</code> 的过程实际上<strong>大体</strong>就是 <code>Rasterization</code> 栅格化.</p> 
<p>在讲解 <code>Rasterization</code> 之前,给出一个案例的描述,可以思考一下为什么出来一张长这样子的图:</p> 
<pre><code class="prism language-glsl"># vertex
attribute vec3 Position;
attribute vec2 iUv;
varying   vec2 oUV;
uniform mat4 WorldViewProj;

void main(void)
{
    oUV         =  iUv;
    gl_Position =  WorldViewProj * vec4(Position, 1.0);
}
</code></pre> 
<pre><code class="prism language-glsl"># fragment
varying vec2 oUV;
uniform sampler2D TexA;
uniform sampler2D TexB;

void main(void)
{
    float val = (oUV.x + oUV.y) / 2;
    gl_FragColor = vec4(val, val, val, val);
}
</code></pre> 
<p>并且在 <code>Vertex Puller</code> 中输入以下数据:</p> 
<pre><code class="prism language-tex">// Position(3 scalar)        iUv(2 scalar)
   // one rectangle
   0.0      0.0      0.0      0.0  0.0
   1920.0   0.0      0.0      1.0  0.0
   1920.0   1080.0   0.0      1.0  1.0
   // another rectangle
   0.0      0.0      0.0      0.0  0.0
   1920.0   1080.0   0.0      1.0  1.0
   0.0      1080.0   0.0      0.0  1.0
</code></pre> 
<p>图例如下:</p> 
<p><img src="https://images2.imgbox.com/67/8a/sMOMJWcT_o.png" alt="DrawRect"></p> 
<p>实际你在屏幕输出可以看到下面这样的效果:</p> 
<p><img src="https://images2.imgbox.com/57/b9/BWP8UJoh_o.png" alt="RasterizationDemo"></p> 
<p><code>OpenGL</code> 的基础元素有点(Point)、线(Line Segment)以及三角形(Triangle),其栅格化过程各有不同,在这里选取三角形(Triangle)进行表述(实际上大多数场景也只会用到Triangle).</p> 
<blockquote> 
 <p>此节所有描述均来自于 <code>OpenGL ES</code> 中的 <code>13.7 Polygons</code>.</p> 
</blockquote> 
<p>对于上面演示的这个例子如果以 1080P 作为屏幕尺寸,那么右上三角形输入三个顶点(vertex)则应该输出 1080*1920/2 个像素点(fragment); 这个过程我们称之为 <code>Rasterization</code> 栅格化,对应于 <code>OpenGL ES</code> 标准中的 <code>Fixed-Function Primitive Assembly and Rasterization</code>.</p> 
<p>栅格化的本质是数据内插(interpolation),即如何使用三个顶点(vertex)内插出1080*1920/2 个像素点(fragment)?这里就要谈及内插公式,这里不想讲得过于复杂就附带上 <code>OpenGL ES</code> 中官方的描述,并做扼要的说明:</p> 
<p><img src="https://images2.imgbox.com/41/ee/4O6g9miX_o.png" alt="RasterizationPolygons1"><br> <img src="https://images2.imgbox.com/c1/10/GlSSy8Ke_o.png" alt="RasterizationPolygons2"></p> 
<ul><li>p : barycentric coordinates, 三角形中任意一点</li><li>abc : p 与三角形三个顶点相连接,可以分割出三个子三角形; abc就是子三角形和三角形的比例关系,故 a+b+c=1</li><li>associated datunm : 相关数据,比如内置变量 <code>gl_Position</code>,自定义输出变量 <code>varying</code> <code>oUV</code></li><li>w : clip coordinate; 被剪辑过的坐标,这里简单可以理解为没有剪辑,传入是什么就是什么</li></ul> 
<p>结合下面这张图以及输入的值,找几个坐标好好算一算,就可以理解这个内插公式了:<br> <img src="https://images2.imgbox.com/ce/bf/vbDjH5Ms_o.png" alt="RasterizationDemo"></p> 
<h3><a id="_286"></a>五、案例演示</h3> 
<h4><a id="1__288"></a>(1) 素材源</h4> 
<h5><a id="TexA_290"></a>TexA</h5> 
<p><img src="https://images2.imgbox.com/38/e7/rwDwXoc8_o.png" alt="TexA"></p> 
<h5><a id="TexB_294"></a>TexB</h5> 
<p><img src="https://images2.imgbox.com/60/ff/50SM0F5r_o.png" alt="TexB"></p> 
<h5><a id="TexL_298"></a>TexL</h5> 
<p><img src="https://images2.imgbox.com/fa/ce/K3Yz9GfI_o.png" alt="TexL"></p> 
<h5><a id="Vertex_302"></a>Vertex</h5> 
<pre><code class="prism language-tex">// Position(3 scalar)        iUv(2 scalar)
   // one rectangle
   0.0      0.0      0.0      0.0  0.0
   1920.0   0.0      0.0      1.0  0.0
   1920.0   1080.0   0.0      1.0  1.0
   // another rectangle
   0.0      0.0      0.0      0.0  0.0
   1920.0   1080.0   0.0      1.0  1.0
   0.0      1080.0   0.0      0.0  1.0
</code></pre> 
<h4><a id="2__316"></a>(2) 渐变转场</h4> 
<p><code>FadeVal</code> 从 0.0 至 1.0 均匀变化.</p> 
<h5><a id="Fade_vertex_shader_320"></a>Fade vertex shader</h5> 
<pre><code class="prism language-glsl">attribute vec3 Position;
attribute vec2 iUv;
varying   vec2 oUV;
uniform mat4 WorldViewProj;

void main(void)
{
    oUV         =  iUv;
    gl_Position =  WorldViewProj * vec4(Position, 1.0);
}
</code></pre> 
<h5><a id="Fade_fragemet_shader_335"></a>Fade fragemet shader</h5> 
<pre><code class="prism language-glsl">varying vec2 oUV;
uniform sampler2D TexA;
uniform sampler2D TexB;
uniform float FadeVal;

void main(void)
{
    gl_FragColor = mix(texture(TexA, oUV), texture(TexB, oUV), FadeVal);
}
</code></pre> 
<h5><a id="_349"></a>渐变转场效果图</h5> 
<p><img src="https://images2.imgbox.com/36/19/8tHwnnfv_o.gif" alt="TransitionFade"></p> 
<h4><a id="3__353"></a>(3) 亮度擦除转场</h4> 
<p>演示百叶窗效果,本质原理为查表;<code>Progress</code> 从 0.0 至 1.0 均匀变化.</p> 
<h5><a id="Luma_vertex_shader_357"></a>Luma vertex shader</h5> 
<pre><code class="prism language-glsl">attribute vec3 Position;
attribute vec2 iUv;
varying   vec2 oUV;
uniform mat4 WorldViewProj;

void main(void)
{
    oUV         =  iUv;
    gl_Position =  WorldViewProj * vec4(Position, 1.0);
}
</code></pre> 
<h5><a id="Luma_fragment_shader_372"></a>Luma fragment shader</h5> 
<pre><code class="prism language-glsl">varying vec2 oUV;
uniform sampler2D TexA;
uniform sampler2D TexB;
uniform sampler2D TexL;
uniform float Progress;

void main(void)
{
    float softness = 0.03f;
    float luma = texture(TexL, oUV).x;
    float time = mix(0.0f, 1.0f + softness, Progress);

    vec4 acolor = texture(TexA, oUV);
    vec4 bcolor = texture(TexB, oUV);

    if (luma &lt;= time - softness)
    {
        gl_FragColor = bcolor;
    }
    else if (luma &gt;= time)
    {
        gl_FragColor = acolor;
    }
    else
    {
        float alpha = (time - luma) / softness;
        gl_FragColor = mix(acolor, bcolor, alpha);
    }
}
</code></pre> 
<h5><a id="_406"></a>亮度擦除转场效果图</h5> 
<p><img src="https://images2.imgbox.com/20/5b/DAIyJsQh_o.gif" alt="TransitionLuma"></p> 
<h3><a id="_410"></a>结语</h3> 
<p>在写这篇文章之前我想了很久,最终我决定不去描述 <code>OpenGL</code> 的各个细节,比如 <code>OpenGL</code> 的接口定义、如何调用、如何从 CPU 向 GPU 传输数据等等; 想以概括性的方式描述一下 <code>OpenGL</code> 即可;如果想深入了解 <code>OpenGL</code> ,可以读读 <a href="http://geekfaner.com/shineengine/blog2_OpenGLESv2_1.html" rel="nofollow">ES 2.0知识串讲</a>,个人非常喜欢(所以本章的写法侧重点也与此不同,不想重复).</p> 
<p>此外,本章所描述的大部分实现你都可以从 <a href="https://github.com/HR1025/MMP">MMP</a> 这个仓库中找到,详细可以阅读下 <a href="https://github.com/HR1025/MMP/blob/dev/Doc/markdown/DEBUG.md">调试</a>.</p> 
<blockquote> 
 <p>MMP 是业余时我自己开发的一个SDK,目前主要参考了几个开源程序,比如 <a href="https://github.com/hrydgard/ppsspp">ppsspp</a> (很有意思的开源模拟器)以及 <a href="https://github.com/obsproject/obs-studio">obs</a>; 个人觉得都是相当优秀的开源项目,值得学习以及投入.</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f6c9b2812e940a972b36ea3c552ba8b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Doris-1.2.0升级到Doris-1.2.4</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c747710039d9dbc9ccff54241622ed87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux服务器时间不同步问题处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>