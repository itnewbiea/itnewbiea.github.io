<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android Parcel对象详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android Parcel对象详解" />
<meta property="og:description" content="今天在公司没什么很急的事情，想起这几天一直在用Parcel这个类来做一些工作。
关于Parcel的使用 在分析Parcel之前，首先按照分析流程，介绍下关于Parcel的相关常规使用。
首先是关于Parcel的获取：
Parcel parcle = Parcel.Obtain(); 额，这感觉似曾相识啊，我们这里大胆猜测Parcel的初始化也是由其对象池进行初始化的。在得到了Parcel对象之后，下一步的工作。嗯，我想起来，应该介绍下Parcel的作用吧：
其实看到这篇文章的各位，应该也不需要这种科普吧，哈哈。我从源码注释中截取如下:
*Container for a message (data and object references) that can * be sent through an IBinder. A Parcel can contain both flattened data * that will be unflattened on the other side of the IPC (using the various * methods here for writing specific types, or the general
从这段注释中可以看出，Parcel是一个容器，他可以包含数据或者是对象引用，并且能够用于Binder的传输。同时支持序列化以及跨进程之后进行反序列化，同时其提供了很多方法帮助开发者完成这些功能。ok，对这里差不多明朗了，Parcel主要就是用来进行IPC通信的。当然不仅仅是Binder这一种跨进程通信。
接下来回到这题，既然Parcel是一个容器，那么肯定需要向其中传入数据才行啊，没错，所以在初始化Parcel之后，需要进行如下操作:
parcel.writeInt(int val); 向Parcel中传入一个Int型的数据，接下来还有:
parcel.writeString(String val); 向Parcel中传入一个String型的数据。
这里只以这两种最为常见的数据类型的写入作为例子，实际上Parcel所支持的数据类型可多了去了，具体可以如下图所示:
在完成了数据的写入之后，就需要进行数据的序列化：
parcel.marshall(); 在经过上一步的处理之后，返回了一个byte数组，主要的IPC相关的操作主要就是围绕此byte数组进行的。同时，由于parcel的读写都是一个指针操作的，这一步涉及到native的操作，所以，在将数据写入之后，需要将指针手动指向到最初的位置，即如下的操作：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/855e5c6bdf60e8b39de4aa73579875a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-09T22:40:17+08:00" />
<meta property="article:modified_time" content="2017-01-09T22:40:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android Parcel对象详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今天在公司没什么很急的事情，想起这几天一直在用Parcel这个类来做一些工作。</p> 
<h2 id="关于parcel的使用">关于Parcel的使用</h2> 
<p>在分析Parcel之前，首先按照分析流程，介绍下关于Parcel的相关常规使用。</p> 
<p>首先是关于Parcel的获取：</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">Parcel parcle </span>=<span class="hljs-string"> Parcel.Obtain();</span></code></pre> 
<p>额，这感觉似曾相识啊，我们这里大胆猜测Parcel的初始化也是由其对象池进行初始化的。在得到了Parcel对象之后，下一步的工作。嗯，我想起来，应该介绍下Parcel的作用吧：</p> 
<p>其实看到这篇文章的各位，应该也不需要这种科普吧，哈哈。我从源码注释中截取如下:</p> 
<blockquote> 
 <p>*Container for a message (data and object references) that can <br> * be sent through an IBinder. A Parcel can contain both flattened data <br> * that will be unflattened on the other side of the IPC (using the various <br> * methods here for writing specific types, or the general</p> 
</blockquote> 
<p>从这段注释中可以看出，Parcel是一个容器，他可以包含数据或者是对象引用，并且能够用于Binder的传输。同时支持序列化以及跨进程之后进行反序列化，同时其提供了很多方法帮助开发者完成这些功能。ok，对这里差不多明朗了，Parcel主要就是用来进行IPC通信的。当然不仅仅是Binder这一种跨进程通信。</p> 
<p>接下来回到这题，既然Parcel是一个容器，那么肯定需要向其中传入数据才行啊，没错，所以在初始化Parcel之后，需要进行如下操作:</p> 
<pre class="prettyprint"><code class=" hljs ocaml">parcel.writeInt(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>);</code></pre> 
<p>向Parcel中传入一个Int型的数据，接下来还有:</p> 
<pre class="prettyprint"><code class=" hljs javascript">parcel.writeString(<span class="hljs-built_in">String</span> val);</code></pre> 
<p>向Parcel中传入一个String型的数据。</p> 
<p>这里只以这两种最为常见的数据类型的写入作为例子，实际上Parcel所支持的数据类型可多了去了，具体可以如下图所示:</p> 
<p><img src="https://images2.imgbox.com/f3/2d/mO5inGTn_o.png" alt="这里写图片描述" title=""></p> 
<p>在完成了数据的写入之后，就需要进行数据的序列化：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">parcel<span class="hljs-preprocessor">.marshall</span>()<span class="hljs-comment">;</span></code></pre> 
<p>在经过上一步的处理之后，返回了一个byte数组，主要的IPC相关的操作主要就是围绕此byte数组进行的。同时，由于parcel的读写都是一个指针操作的，这一步涉及到native的操作，所以，在将数据写入之后，需要将指针手动指向到最初的位置，即如下的操作：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">parcel<span class="hljs-preprocessor">.setDataPosition</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span></code></pre> 
<p>到此处，Parcel的这一步操作还没有收尾，想想前面parcel的Obtain()方法，我们有理由相信，parcel的销毁应该是使用了对应的recycle()方法。</p> 
<p>所以此处有:</p> 
<pre class="prettyprint"><code class=" hljs avrasm">parcel<span class="hljs-preprocessor">.recycle</span>()<span class="hljs-comment">;</span></code></pre> 
<p>将此Parcel对象进行释放，完成了IPC操作的一半。至于是如何将数据传输过去的，暂不进行展开。此处在IPC的另一端的Parcel的获取处理。</p> 
<p>再进行了IPC的操作之后，一般读取出来的就是之前序列化的byte数组，所以，首先要进行一个反序列化操作，即如下的操作:</p> 
<pre class="prettyprint"><code class=" hljs cs">parcel.unmarshall(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">int</span> offest, <span class="hljs-keyword">int</span> length);</code></pre> 
<p>其中的参数分别是这个byte数组，以及读取偏移量，以及数组的长度。</p> 
<p>此时得到的parcel就是一个正常的parcel对象，这时就可以将之前我们所存入的数据<strong>按照顺序</strong>进行获取，即：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">parcel<span class="hljs-preprocessor">.readInt</span>()<span class="hljs-comment">;</span></code></pre> 
<p>以及</p> 
<pre class="prettyprint"><code class=" hljs avrasm">parcel<span class="hljs-preprocessor">.readString</span>()<span class="hljs-comment">;</span></code></pre> 
<p>读取完毕之后，同样是一个parcel的回收操作：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">parcel<span class="hljs-preprocessor">.recycle</span>()<span class="hljs-comment">;</span></code></pre> 
<p>以上就是parcel的常规使用，获取有些朋友不太知道parcel的使用场景，其实最常见的，在我们编写完AIDL的接口之后，IDE会自动生成一个对应的.java文件，这个java文件就是实际用来进行aidl的通信的，在这个实现里面，数据的传递就是使用的parcel，当然还有其他的应用场景，这里只说了一个大家都比较常见的实践。</p> 
<h2 id="关于parcel的实现">关于Parcel的实现</h2> 
<p>之前有提到过，parcel的使用对于java开发者来说，还是比较陌生的，像极了指针的操作，所以基本可以确定java层对于parcel的处理仅仅是一个封装代理，实际的实现在c/c++ native。既然这样的话，我们就应该想到，parcel的使用同样涉及到jni的使用。所以我们目前的思路就是在源码中找到parcel的三层代码(Java-Jni-C)。</p> 
<p>我的具体做法是直接使用 everything 在源码目录下搜索 parcel，然后根据之前的思路进行包的导出，我的分析基础就是以下的几个包里的实现:</p> 
<p>Java层：</p> 
<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\frameworks</span><span class="hljs-command">\base</span><span class="hljs-command">\core</span><span class="hljs-command">\java</span><span class="hljs-command">\android</span><span class="hljs-command">\os</span></code></pre> 
<p>JNI:</p> 
<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\frameworks</span><span class="hljs-command">\base</span><span class="hljs-command">\core</span><span class="hljs-command">\jni</span></code></pre> 
<p>native:</p> 
<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\frameworks</span><span class="hljs-command">\native</span><span class="hljs-command">\libs</span><span class="hljs-command">\binder</span></code></pre> 
<p>然后导入这几个包中的文件方便检索：</p> 
<p><img src="https://images2.imgbox.com/d3/6c/MARPP0Ay_o.png" alt="这里写图片描述" title=""></p> 
<p>根据我们以上的使用顺序来进行分析，首先需要进行一个Parcel的获取，看看Java层的实现：</p> 
<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-javadoc">/**
     * Retrieve a new Parcel object from the pool.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Parcel <span class="hljs-title">obtain</span>() {
        <span class="hljs-keyword">final</span> Parcel[] pool = sOwnedPool;
        <span class="hljs-keyword">synchronized</span> (pool) {
            Parcel p;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;POOL_SIZE; i++) {
                p = pool[i];
                <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span>) {
                    pool[i] = <span class="hljs-keyword">null</span>;
                    <span class="hljs-keyword">if</span> (DEBUG_RECYCLE) {
                        p.mStack = <span class="hljs-keyword">new</span> RuntimeException();
                    }
                    <span class="hljs-keyword">return</span> p;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Parcel(<span class="hljs-number">0</span>);
    }</code></pre> 
<p>从注释也可以看出，Parcle的初始化，主要是使用一个对象池进行的，这样可以提高性能以及内存消耗。首先要明确的是，源码中定义的池子有两个：</p> 
<pre class="prettyprint"><code class=" hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> POOL_SIZE = <span class="hljs-number">6</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Parcel[] sOwnedPool = <span class="hljs-keyword">new</span> Parcel[POOL_SIZE];
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Parcel[] sHolderPool = <span class="hljs-keyword">new</span> Parcel[POOL_SIZE];</code></pre> 
<p>从名字也可以看出，不同池子的作用，sOwnedPool 这个池子主要就是用来存储parcel的，Obtain()方法首先会去检索池子中的parcel对象，若是能取出parcel，那么先将这个这个parcel返回，同时将这个位置置空。若是现在连池子都不存在的话，那么就直接新建一个parcel对象。这里的实现与Handler中的message采用同样的处理。</p> 
<p>我们了解了获取之后，比较关心的就是如何去新建一个parcel对象，也就是new这个过程，那么看看此处中的parcel构造方法：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-title">Parcel</span>(<span class="hljs-keyword">int</span> nativePtr) {
        <span class="hljs-keyword">if</span> (DEBUG_RECYCLE) {
            mStack = <span class="hljs-keyword">new</span> RuntimeException();
        }
        <span class="hljs-comment">//Log.i(TAG, "Initializing obj=0x" + Integer.toHexString(obj), mStack);</span>
        init(nativePtr);
    }</code></pre> 
<p>可以看到，在此处参数名称被称为：nativePtr，这个大家都比较熟悉了，ptr嘛，指的就是一个指针，这里又是一个封装，需要继续深入看实现：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>(<span class="hljs-keyword">int</span> nativePtr) {
        <span class="hljs-keyword">if</span> (nativePtr != <span class="hljs-number">0</span>) {
            mNativePtr = nativePtr;
            mOwnsNativeParcelObject = <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> {
            mNativePtr = nativeCreate();
            mOwnsNativeParcelObject = <span class="hljs-keyword">true</span>;
        }
    }</code></pre> 
<p>这里首先对参数进行检查，这里因为初始化传入的参数是0，那么直接执行nativeCreate(),并且将标志位mOwnsNativeParcelObject 置为true，表示这个 parcel已经在native进行了创建。</p> 
<p>此处的ativeCreate()是一个native方法，其具体实现已经切换到native环境了，那么我们此时的分析就要从jni进行了，经过检索，在jni的代码中，其实现为以下函数：</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">static</span> jint android_os_Parcel_create(JNIEnv* env, jclass clazz)
{
    Parcel* parcel = <span class="hljs-keyword">new</span> Parcel();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jint&gt;(parcel);
}</code></pre> 
<p>这是一个jni的实现，首先是调用了native的初始化，并且，返回操作这个对象的指针：</p> 
<pre class="prettyprint"><code class=" hljs mathematica">Parcel::Parcel()
<span class="hljs-list">{
    initState();
}</span></code></pre> 
<p>是一个c++的构造方法，关于析构方法，暂时不管，其中的init实现为：</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> Parcel::initState()
{
    mError = NO_ERROR;
    mData = <span class="hljs-number">0</span>;
    mDataSize = <span class="hljs-number">0</span>;
    mDataCapacity = <span class="hljs-number">0</span>;
    mDataPos = <span class="hljs-number">0</span>;
    ALOGV(<span class="hljs-string">"initState Setting data size of %p to %d\n"</span>, <span class="hljs-keyword">this</span>, mDataSize);
    ALOGV(<span class="hljs-string">"initState Setting data pos of %p to %d\n"</span>, <span class="hljs-keyword">this</span>, mDataPos);
    mObjects = <span class="hljs-literal">NULL</span>;
    mObjectsSize = <span class="hljs-number">0</span>;
    mObjectsCapacity = <span class="hljs-number">0</span>;
    mNextObjectHint = <span class="hljs-number">0</span>;
    mHasFds = <span class="hljs-literal">false</span>;
    mFdsKnown = <span class="hljs-literal">true</span>;
    mAllowFds = <span class="hljs-literal">true</span>;
    mOwner = <span class="hljs-literal">NULL</span>;
}</code></pre> 
<p>可以看出，对parcel的初始化，只是在native层初始化了一些数据值。</p> 
<p>在完成初始化之后，就将这个操作指针给返回。这样就完成了parcel的初始化。</p> 
<p>初始化完毕之后，就可以进行数据的写入了，首先写入一个int型数据，其java层实现如下：</p> 
<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-javadoc">/**
     * Write an integer value into the parcel at the current dataPosition(),
     * growing dataCapacity() if needed.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeInt</span>(<span class="hljs-keyword">int</span> val) {
        nativeWriteInt(mNativePtr, val);
    }</code></pre> 
<p>可以看出，在这里java层就纯粹是一个对于native实现的封装了，这时候的分析来到jni：</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> android_os_Parcel_writeInt(JNIEnv* env, jclass clazz, jint nativePtr, jint val) {
    Parcel* parcel = <span class="hljs-keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);
    <span class="hljs-keyword">const</span> status_t err = parcel-&gt;writeInt32(val);
    <span class="hljs-keyword">if</span> (err != NO_ERROR) {
        signalExceptionForError(env, clazz, err);
    }
}</code></pre> 
<p>在这里我们要特别注意两个参数，一个是之前传上去的指针以及需要保存的int数据，这两个值分别是：</p> 
<pre class="prettyprint"><code class=" hljs fsharp">jint nativePtr, jint <span class="hljs-keyword">val</span></code></pre> 
<p>首先是根据这个指针，这里说一下，指针实际上就是一个整型地址值，所以这里使用强转将int值转化为parcel类型的指针是可行的，然后使用这个指针来操作native的parcel对象，即：</p> 
<pre class="prettyprint"><code class=" hljs vbscript"><span class="hljs-keyword">const</span> status_t <span class="hljs-built_in">err</span> = parcel-&gt;writeInt32(val);</code></pre> 
<p>这里注意到我们是写入了一个32位的int值，这个点一定要注意，32位，4个字节。</p> 
<p>深入进去看看实现：</p> 
<pre class="prettyprint"><code class=" hljs fsharp">status_t Parcel::writeInt32(int32_t <span class="hljs-keyword">val</span>)
{
    <span class="hljs-keyword">return</span> writeAligned(<span class="hljs-keyword">val</span>);
}</code></pre> 
<p>可以看出，这里实际上调用了：</p> 
<pre class="prettyprint"><code class=" hljs fsharp">writeAligned(<span class="hljs-keyword">val</span>);</code></pre> 
<p>来进行数据的写入，这里理解下align的意思，实际上是一个对齐写入，怎么个对齐法，看看：</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
status_t Parcel::writeAligned(T val) {
    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(<span class="hljs-keyword">sizeof</span>(T)) == <span class="hljs-keyword">sizeof</span>(T));

    <span class="hljs-keyword">if</span> ((mDataPos+<span class="hljs-keyword">sizeof</span>(val)) &lt;= mDataCapacity) {
restart_write:
        *<span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;
        <span class="hljs-keyword">return</span> finishWrite(<span class="hljs-keyword">sizeof</span>(val));
    }

    status_t err = growData(<span class="hljs-keyword">sizeof</span>(val));
    <span class="hljs-keyword">if</span> (err == NO_ERROR) <span class="hljs-keyword">goto</span> restart_write;
    <span class="hljs-keyword">return</span> err;
}</code></pre> 
<p>在这个方法中首先是一个断言检查，然后对输入的参数取size值，再加上之前已经移动的位置，判断是否超过了该Pacel所定义的能力值mDataCapacity。</p> 
<p>若是超过了能力值的话，那么直接将能力值进行扩大，扩大的值是val值的大小，比如，int值是32bit，那么就增加4个字节，返回的结果是状态值，若是没有出错的话，就利用goto语句执行，这里的goto的语句只要是一个指针的操作，将指针移动到端点，然后写入val的size值。这里可以看出这个函数的意义，因为无论是否超过能力值它都会写入T类型值的size值。</p> 
<p>到这里，Parcel就写入了一个Int型的值。</p> 
<p>同样的思路，大家可以参考以上的分析，继续进行Parcel一个常规使用的分析，我之前是想将全部的实现都分析出来的，但是后来发现，大体的思路都差不多，这么写的话，会多出来很多废话，所以接下来的分析，大家如果有兴趣的话，就继续分析下去，欢迎一起进行讨论！</p> 
<p>另外，在分析过程中，我对Android的JNI调用进行一番探索，总之一句话就是说Jvm环境切换到Native环境之中后，Java如何通过Java层声明的native方法来查找到对应的JNI方法的？因为我对JVM的实现这一部分没有太多了解，所以只能从Android源码中代码层面上来分析，至少在Android中：</p> 
<p>在切换到native环境之后，实际上，这两种函数的映射是由一个多重数组来进行管理的，具体如下：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> JNINativeMethod gParcelMethods[] = {
    {<!-- --><span class="hljs-string">"nativeDataSize"</span>,            <span class="hljs-string">"(I)I"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_dataSize},
    {<!-- --><span class="hljs-string">"nativeDataAvail"</span>,           <span class="hljs-string">"(I)I"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_dataAvail},
    {<!-- --><span class="hljs-string">"nativeDataPosition"</span>,        <span class="hljs-string">"(I)I"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_dataPosition},
    {<!-- --><span class="hljs-string">"nativeDataCapacity"</span>,        <span class="hljs-string">"(I)I"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_dataCapacity},
    {<!-- --><span class="hljs-string">"nativeSetDataSize"</span>,         <span class="hljs-string">"(II)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_setDataSize},
    {<!-- --><span class="hljs-string">"nativeSetDataPosition"</span>,     <span class="hljs-string">"(II)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_setDataPosition},
    {<!-- --><span class="hljs-string">"nativeSetDataCapacity"</span>,     <span class="hljs-string">"(II)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_setDataCapacity},

    {<!-- --><span class="hljs-string">"nativePushAllowFds"</span>,        <span class="hljs-string">"(IZ)Z"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_pushAllowFds},
    {<!-- --><span class="hljs-string">"nativeRestoreAllowFds"</span>,     <span class="hljs-string">"(IZ)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_restoreAllowFds},

    {<!-- --><span class="hljs-string">"nativeWriteByteArray"</span>,      <span class="hljs-string">"(I[BII)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_writeNative},
    {<!-- --><span class="hljs-string">"nativeWriteInt"</span>,            <span class="hljs-string">"(II)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_writeInt},
    {<!-- --><span class="hljs-string">"nativeWriteLong"</span>,           <span class="hljs-string">"(IJ)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_writeLong},
    {<!-- --><span class="hljs-string">"nativeWriteFloat"</span>,          <span class="hljs-string">"(IF)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_writeFloat},
    {<!-- --><span class="hljs-string">"nativeWriteDouble"</span>,         <span class="hljs-string">"(ID)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_writeDouble},
    {<!-- --><span class="hljs-string">"nativeWriteString"</span>,         <span class="hljs-string">"(ILjava/lang/String;)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_writeString},
    {<!-- --><span class="hljs-string">"nativeWriteStrongBinder"</span>,   <span class="hljs-string">"(ILandroid/os/IBinder;)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_writeStrongBinder},
    {<!-- --><span class="hljs-string">"nativeWriteFileDescriptor"</span>, <span class="hljs-string">"(ILjava/io/FileDescriptor;)V"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_writeFileDescriptor},

    {<!-- --><span class="hljs-string">"nativeCreateByteArray"</span>,     <span class="hljs-string">"(I)[B"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_createByteArray},
    {<!-- --><span class="hljs-string">"nativeReadInt"</span>,             <span class="hljs-string">"(I)I"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_readInt},
    {<!-- --><span class="hljs-string">"nativeReadLong"</span>,            <span class="hljs-string">"(I)J"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_readLong},
    {<!-- --><span class="hljs-string">"nativeReadFloat"</span>,           <span class="hljs-string">"(I)F"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_readFloat},
    {<!-- --><span class="hljs-string">"nativeReadDouble"</span>,          <span class="hljs-string">"(I)D"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_readDouble},
    {<!-- --><span class="hljs-string">"nativeReadString"</span>,          <span class="hljs-string">"(I)Ljava/lang/String;"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_readString},
    {<!-- --><span class="hljs-string">"nativeReadStrongBinder"</span>,    <span class="hljs-string">"(I)Landroid/os/IBinder;"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_readStrongBinder},
    {<!-- --><span class="hljs-string">"nativeReadFileDescriptor"</span>,  <span class="hljs-string">"(I)Ljava/io/FileDescriptor;"</span>, (<span class="hljs-keyword">void</span>*)android_os_Parcel_readFileDescriptor},

........</code></pre> 
<p>以下还有很多映射关系，这样通过映射就可以将函数给进行对应了，但是还有一点，这个东西是何时，以及何处进行调用的，这个展开说又是一个漫长的故事了，所以这一段我也不进行分析了，大家知道有这么一个东西就ok了，当然欢迎一起进行讨论哦！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/884ca8989b2e41a53f21352818cf1b98/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">extends、implements: 是否要求强制“继承/实现”所有的的“变量和方法”？？？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4740e110c8c5ad67c59c5bf01a43ba33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Excel多级下拉菜单联动自动匹配内容</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>