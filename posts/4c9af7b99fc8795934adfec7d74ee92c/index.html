<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>stm32不同io口组合新的端口_STM32学习之旅~~~~~~~~~蜂鸣器实例 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="stm32不同io口组合新的端口_STM32学习之旅~~~~~~~~~蜂鸣器实例" />
<meta property="og:description" content="在前面章节中我们已经介绍了如何控制 STM32 的 IO 口输出高低电平，本章我们通过另外一个实验来讲述 STM32 IO 口的输出。通过 STM32F1 芯片的一个 IO口控制板载有源/无源蜂鸣器，实现蜂鸣器控制。
蜂鸣器介绍 蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电，广泛应用于计算机、打印机、复印机、报警器、电子玩具、汽车电子设备、电话机、定时器等电子产品中作发声器件。蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。
压电式蜂鸣器主要由多谐振荡器、压电蜂鸣片、阻抗匹配器及共鸣箱、外壳等组成。多谐振荡器由晶体管或集成电路构成，当接通电源后(1.5~15V 直流工作电压)，多谐振荡器起振,输出 1.5～5kHZ 的音频信号，阻抗匹配器推动压电蜂鸣片发声。
电磁式蜂鸣器由振荡器、电磁线圈、磁铁、振动膜片及外壳等组成。接通电源后，振荡器产生的音频信号电流通过电磁线圈，使电磁线圈产生磁场，振动膜片在电磁线圈和磁铁的相互作用下，周期性地振动发声。
其实一句话就可概括它们之间的区别，想要压电式蜂鸣器发声，需提供一定频率的脉冲信号；想要电磁式蜂鸣器发声，只需提供电源即可。无源蜂鸣器，属于压电式蜂鸣器类型；有源蜂鸣器，属于电磁式蜂鸣器类型。这里说的有源，并不是指电源的意思，而是指蜂鸣器内部是否含有振荡电路，有源蜂鸣器内部自带振荡电路，只需提供电源即可发声，而无源蜂鸣器则需提供一定频率的脉冲信号才能发声，频率大小通常在 1.5-5KHz 之间。有源蜂鸣器实物如下图。
如果给有源蜂鸣器加一个 1.5-5KHz 的脉冲信号，同样也会发声，而且改变这个频率，就可以调节蜂鸣器音调，产生各种不同音色、音调的声音。如果改变输出电平的高低电平占空比，则可以改变蜂鸣器的声音大小。
硬件设计 在前面我们已经对 STM32 的 GPIO 做了简单介绍，并且还使用了其中
IO 口直接控制开发板上的 LED。对于本章要实现蜂鸣器的控制，我们能否直接使用 STM32 的 IO 口驱动呢？根据 STM32F103 芯片数据手册可知， 单个 IO 口的最大输出电流是 25mA，而蜂鸣器的驱动电流是 30mA 左右，两者非常接近，有的朋友就想直接用 IO 口来驱动，但是有没有考虑到整个芯片的输出电流，整个芯片的输出电流最大也就 150mA，如果在驱动蜂鸣器上就耗掉了 30mA，那么 STM32 其他的 IO 口及外设电流就非常拮据了。所以我们不会直接使用 IO 口驱动蜂鸣器，而是通过三极管把电流放大后再驱动蜂鸣器，这样 STM32 的 IO 口只需要提供不到1mA 的电流就可控制蜂鸣器。所以我们也经常说到 STM32 芯片是用来做控制的，而不是驱动。开发板上的无源蜂鸣器模块电路原理图如下所示。
开发板上的有源蜂鸣器模块电路原理图如下所示。
从这两个电路图可以看到， 无源蜂鸣器的控制需要给其一定频率的脉冲才能发声，仅给一个高电平或者低电平是不能发声的，因此蜂鸣器模块电路直接将STM32引脚接在NPN三极管的基极上， 然后三极管的发射极连接蜂鸣器，无需考虑外界对 PB5 脚产生的高低电平会对蜂鸣器发声干扰。如果使用的是有源蜂鸣器，它只要有电源就会发声，因此就必须考虑外界对 PB5 引脚电平的干扰问题。通过电阻 R06 和 PNP 三极管 TP6 进行电流放大，从而驱动蜂鸣器。电阻 R66 是一个上拉电阻， 用来防止蜂鸣器误发声。 当 PB5 引脚输出低电平时， PNP三极管导通，蜂鸣器发声；当 PB5 引脚输出高电平时，PNP 三极管截止，蜂鸣器停止发声。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4c9af7b99fc8795934adfec7d74ee92c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-25T21:52:21+08:00" />
<meta property="article:modified_time" content="2021-01-25T21:52:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">stm32不同io口组合新的端口_STM32学习之旅~~~~~~~~~蜂鸣器实例</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p> 在前面章节中我们已经介绍了如何控制 STM32 的 IO 口输出高低电平，本章我们通过另外一个实验来讲述 STM32 IO 口的输出。通过 STM32F1 芯片的一个 IO口控制板载有源/无源蜂鸣器，实现蜂鸣器控制。</p> 
 <h2><strong>蜂鸣器介绍</strong></h2> 
 <p> 蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电，广泛应用于计算机、打印机、复印机、报警器、电子玩具、汽车电子设备、电话机、定时器等电子产品中作发声器件。蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。</p> 
 <p> 压电式蜂鸣器主要由多谐振荡器、压电蜂鸣片、阻抗匹配器及共鸣箱、外壳等组成。多谐振荡器由晶体管或集成电路构成，当接通电源后(1.5~15V 直流工作电压)，多谐振荡器起振,输出 1.5～5kHZ 的音频信号，阻抗匹配器推动压电蜂鸣片发声。</p> 
 <p> 电磁式蜂鸣器由振荡器、电磁线圈、磁铁、振动膜片及外壳等组成。接通电源后，振荡器产生的音频信号电流通过电磁线圈，使电磁线圈产生磁场，振动膜片在电磁线圈和磁铁的相互作用下，周期性地振动发声。</p> 
 <p> 其实一句话就可概括它们之间的区别，想要压电式蜂鸣器发声，需提供一定频率的脉冲信号；想要电磁式蜂鸣器发声，只需提供电源即可。无源蜂鸣器，属于压电式蜂鸣器类型；有源蜂鸣器，属于电磁式蜂鸣器类型。这里说的有源，并不是指电源的意思，而是指蜂鸣器内部是否含有振荡电路，有源蜂鸣器内部自带振荡电路，只需提供电源即可发声，而无源蜂鸣器则需提供一定频率的脉冲信号才能发声，频率大小通常在 1.5-5KHz 之间。有源蜂鸣器实物如下图。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/d1/d3/orwalSw1_o.png" alt="e6002b9ab19aed22317e546c5d443d98.png"> 
 </div> 
 <p> 如果给有源蜂鸣器加一个 1.5-5KHz 的脉冲信号，同样也会发声，而且改变这个频率，就可以调节蜂鸣器音调，产生各种不同音色、音调的声音。如果改变输出电平的高低电平占空比，则可以改变蜂鸣器的声音大小。</p> 
 <h2><strong>硬件设计</strong></h2> 
 <p> 在前面我们已经对 STM32 的 GPIO 做了简单介绍，并且还使用了其中</p> 
 <p>IO 口直接控制开发板上的 LED。对于本章要实现蜂鸣器的控制，我们能否直接使用 STM32 的 IO 口驱动呢？根据 STM32F103 芯片数据手册可知， 单个 IO 口的最大输出电流是 25mA，而蜂鸣器的驱动电流是 30mA 左右，两者非常接近，有的朋友就想直接用 IO 口来驱动，但是有没有考虑到整个芯片的输出电流，整个芯片的输出电流最大也就 150mA，如果在驱动蜂鸣器上就耗掉了 30mA，那么 STM32 其他的 IO 口及外设电流就非常拮据了。所以我们不会直接使用 IO 口驱动蜂鸣器，而是通过三极管把电流放大后再驱动蜂鸣器，这样 STM32 的 IO 口只需要提供不到1mA 的电流就可控制蜂鸣器。所以我们也经常说到 STM32 芯片是用来做控制的，而不是驱动。开发板上的无源蜂鸣器模块电路原理图如下所示。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/68/30/LKe8nJl1_o.png" alt="5aa81207c7ec2692027e0325097d698a.png"> 
 </div> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/1b/11/6MIUXmtg_o.png" alt="4b519645b56d4027b0ff907084aeeec9.png"> 
 </div> 
 <p> 开发板上的有源蜂鸣器模块电路原理图如下所示。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/d6/2c/RiIFdg05_o.png" alt="d8f0f21aca48eb4998b831c86eb443f0.png"> 
 </div> 
 <p> 从这两个电路图可以看到， 无源蜂鸣器的控制需要给其一定频率的脉冲才能发声，仅给一个高电平或者低电平是不能发声的，因此蜂鸣器模块电路直接将STM32引脚接在NPN三极管的基极上， 然后三极管的发射极连接蜂鸣器，无需考虑外界对 PB5 脚产生的高低电平会对蜂鸣器发声干扰。如果使用的是有源蜂鸣器，它只要有电源就会发声，因此就必须考虑外界对 PB5 引脚电平的干扰问题。通过电阻 R06 和 PNP 三极管 TP6 进行电流放大，从而驱动蜂鸣器。电阻 R66 是一个上拉电阻， 用来防止蜂鸣器误发声。 当 PB5 引脚输出低电平时， PNP三极管导通，蜂鸣器发声；当 PB5 引脚输出高电平时，PNP 三极管截止，蜂鸣器停止发声。</p> 
 <h2><strong>软件设计</strong></h2> 
 <h2><strong>蜂鸣器初始化函数</strong></h2> 
 <p> 打开工程中 beep.c 文件，里面代码如下：</p> 
 <p>#include "beep.h"</p> 
 <p>/****************************************************************</p> 
 <p>***************</p> 
 <p>* 函 数 名 : BEEP_Init</p> 
 <p>* 函数功能 : 蜂鸣器初始化</p> 
 <p>* 输 入 : 无</p> 
 <p>* 输 出 : 无</p> 
 <p>****************************************************************/</p> 
 <p>void BEEP_Init() //端口初始化</p> 
 <p>{<!-- --></p> 
 <p>GPIO_InitTypeDef GPIO_InitStructure; //声明一个结构体变量，用来初始化 GPIO</p> 
 <p>RCC_APB2PeriphClockCmd(BEEP_PORT_RCC,ENABLE); /* 开启 GPIO 时钟 */</p> 
 <p>/* 配置 GPIO 的模式和 IO 口 */</p> 
 <p>GPIO_InitStructure.GPIO_Pin=BEEP_PIN; //选择你要设置的 IO口</p> 
 <p>GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; //设置推挽输出模式</p> 
 <p>GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; //设置传输速率</p> 
 <p>GPIO_Init(BEEP_PORT,&amp;GPIO_InitStructure); /* 初始化 GPIO*/</p> 
 <p>}</p> 
 <p> BEEP_Init()函数用来初始化蜂鸣器的端口及时钟，在函数内我们看到有几个参数不是库函数内的，比如 BEEP_PIN、BEEP_PORT、BEEP_PORT_RCC，这种情况一般是我们自己定义的宏，通常放在对应的头文件内，我们打开 beep.h，可以看到如下代码：</p> 
 <p>#ifndef _beep_H</p> 
 <p>#define _beep_H</p> 
 <p>#include "system.h"</p> 
 <p>/* 蜂鸣器时钟端口、引脚定义 */</p> 
 <p>#define BEEP_PORT GPIOB</p> 
 <p>#define BEEP_PIN GPIO_Pin_5</p> 
 <p>#define BEEP_PORT_RCC RCC_APB2Periph_GPIOB</p> 
 <p>#define beep PBout(5)</p> 
 <p>void BEEP_Init(void);</p> 
 <p>#endif</p> 
 <p> 里面就将蜂鸣器的GPIO 端口及管脚进行了宏定义，这样做是方便大家移植程序，只需要对这个宏修改就能实现蜂鸣器的初始化修改。</p> 
 <h2><strong>主函数</strong></h2> 
 <p> 我们打开工程中 main.c 文件，里面代码如下：</p> 
 <p>/****************************************************************</p> 
 <p>* 函 数 名 : main</p> 
 <p>* 函数功能 : 主函数</p> 
 <p>* 输 入 : 无</p> 
 <p>* 输 出 : 无</p> 
 <p>****************************************************************/</p> 
 <p>int main()</p> 
 <p>{<!-- --></p> 
 <p> u16 i=0;</p> 
 <p> SysTick_Init(72);</p> 
 <p> LED_Init();</p> 
 <p> BEEP_Init();</p> 
 <p> while(1)</p> 
 <p> {<!-- --></p> 
 <p> i++;</p> 
 <p> if(i%10==0)</p> 
 <p> {<!-- --></p> 
 <p> beep=!beep;</p> 
 <p> }</p> 
 <p> if(i%20000==0)</p> 
 <p> {<!-- --></p> 
 <p> led1=!led1;</p> 
 <p> }</p> 
 <p> delay_us(10);</p> 
 <p> }</p> 
 <p>}</p> 
 <p> 主函数实现的功能比较简单，首先将使用到的外设硬件进行初始化，然后进入 while 循环，间隔 100us 对蜂鸣器管脚电平翻转，这样就产生了一个频率为5KHz 的脉冲，因此无源蜂鸣器就会发声，当然有源蜂鸣器的控制可以更简单，只需要给它一个低电平即可，为了实现 2 块板子程序的兼容，这里就统一采用此种方式控制蜂鸣器。间隔 200ms 对 led1 管脚电平翻转，因为使用到了 delay_us延时函数，所以在 main 函数开始处就需要调用 SysTick_Init(72)初始化，这个在我们后面所有程序都会使用，后面就不重复。</p> 
 <p> 将工程程序编译下载到开发板内，可以看到 D1 指示灯间隔 200ms 闪烁，蜂鸣器发声。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8747103d1c9310c6108e11a84a15e919/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NodeMCU学习（二）--NodeMCU介绍及使用（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15bba81bccf756915e5ba0794de32645/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">笔记_Open CASCADE-Mesh Process</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>