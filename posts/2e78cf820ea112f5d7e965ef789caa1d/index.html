<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之状态模式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之状态模式" />
<meta property="og:description" content="一、背景 状态这个词汇我们并不陌生，在日常生活中，不同时间就有不同的状态，早上起来精神饱满，中午想睡觉，下午又渐渐恢复，晚上可能只想睡觉，这就对应着一天中不同的状态。
二、定义 状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。
2.1. 模式的结构
状态模式包含以下主要角色。
环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。 UML图如下：
代码
using System; using System.Collections.Generic; namespace ConsoleApp1 { /// &lt;summary&gt; /// 环境类 /// &lt;/summary&gt; public class Context { private State state; //定义环境类的初始状态 public Context() { this.state = new ConcreteStateA(); } //设置新状态 public void setState(State state) { this.state = state; } //读取状态 public State getState() { return (state); } //对请求做处理 public void Handle() { state.Handle(this); } } /// &lt;summary&gt; /// 抽象状态类 /// &lt;/summary&gt; public abstract class State { public abstract void Handle(Context context); } //具体状态A类 public class ConcreteStateA : State { public override void Handle(Context context) { Console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2e78cf820ea112f5d7e965ef789caa1d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-31T22:14:22+08:00" />
<meta property="article:modified_time" content="2023-01-31T22:14:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之状态模式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、背景</h4> 
<p>状态这个词汇我们并不陌生，在日常生活中，不同时间就有不同的状态，早上起来精神饱满，中午想睡觉，下午又渐渐恢复，晚上可能只想睡觉，这就对应着一天中不同的状态。</p> 
<h4>二、定义</h4> 
<p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p> 
<p>2.1. 模式的结构</p> 
<p>状态模式包含以下主要角色。</p> 
<ol><li>环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li></ol> 
<p>UML图如下：</p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/8f/11/JZxTRcpw_o.png" width="550"></p> 
<p> 代码</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;

namespace ConsoleApp1
{
    /// &lt;summary&gt;
    /// 环境类
    /// &lt;/summary&gt;
    public class Context
    {
        private State state;
        //定义环境类的初始状态
        public Context()
        {
            this.state = new ConcreteStateA();
        }
        //设置新状态
        public void setState(State state)
        {
            this.state = state;
        }
        //读取状态
        public State getState()
        {
            return (state);
        }
        //对请求做处理
        public void Handle()
        {
            state.Handle(this);
        }
    }
    /// &lt;summary&gt;
    /// 抽象状态类
    /// &lt;/summary&gt;
    public abstract class State
    {
        public abstract void Handle(Context context);
    }
    //具体状态A类
    public class ConcreteStateA : State
    {


        public override void Handle(Context context)
        {
            Console.WriteLine("当前状态是 A.");
            context.setState(new ConcreteStateB());
        }
    }

    /// &lt;summary&gt;
    /// 具体状态B类
    /// &lt;/summary&gt;
    public class ConcreteStateB : State
    {
        public override void Handle(Context context)
        {
            Console.WriteLine("当前状态是 B.");
            context.setState(new ConcreteStateA());
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Context context = new Context();    //创建环境
            context.Handle();    //处理请求
            context.Handle();
            context.Handle();
            context.Handle();
            Console.ReadKey();
        }
    }
}
</code></pre> 
<p>运行结果</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/41/dc/KZR7hd5m_o.png" width="302"></p> 
<p></p> 
<h4>三、实例</h4> 
<p>用“状态模式”设计一个多线程的状态转换程序。</p> 
<p>分析：多线程存在 5 种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态，其状态转换规律如图 所示。</p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/d9/24/G5CviBQQ_o.png" width="550"></p> 
<p>UML如图所示</p> 
<p><img alt="" height="619" src="https://images2.imgbox.com/67/1b/bNg4nAhB_o.png" width="600"></p> 
<p> 程序代码如下：</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;

namespace ConsoleApp1
{
    /// &lt;summary&gt;
    /// 环境类
    /// &lt;/summary&gt;
    class ThreadContext
    {
        private ThreadState state;
        public ThreadContext()
        {
            state = new New();
        }
        public void setState(ThreadState state)
        {
            this.state = state;
        }
        public ThreadState getState()
        {
            return state;
        }
        public void start()
        {
            ((New)state).start(this);
        }
        public void getCPU()
        {
            ((Runnable)state).getCPU(this);
        }
        public void suspend()
        {
            ((Running)state).suspend(this);
        }
        public void stop()
        {
            ((Running)state).stop(this);
        }
        public void resume()
        {
            ((Blocked)state).resume(this);
        }
    }

    /// &lt;summary&gt;
    /// 抽象状态类：线程状态
    /// &lt;/summary&gt;
    abstract class ThreadState
    {
        protected String stateName; //状态名
    }

    /// &lt;summary&gt;
    /// 具体状态类：新建状态
    /// &lt;/summary&gt;
    class New : ThreadState
    {
        public New()
        {
            stateName = "新建状态";
            Console.WriteLine("当前线程处于：新建状态.");
        }
        public void start(ThreadContext hj)
        {
            Console.WriteLine("调用start()方法--&gt;");
            if (stateName.Equals("新建状态"))
            {
                hj.setState(new Runnable());
            }
            else
            {
                Console.WriteLine("当前线程不是新建状态，不能调用start()方法.");
            }
        }
    }

    /// &lt;summary&gt;
    /// 具体状态类：就绪状态
    /// &lt;/summary&gt;
    class Runnable : ThreadState
    {
        public Runnable()
        {
            stateName = "就绪状态";
            Console.WriteLine("当前线程处于：就绪状态.");
        }
        public void getCPU(ThreadContext hj)
        {
            Console.WriteLine("获得CPU时间--&gt;");
            if (stateName.Equals("就绪状态"))
            {
                hj.setState(new Running());
            }
            else
            {
                Console.WriteLine("当前线程不是就绪状态，不能获取CPU.");
            }
        }
    }
    /// &lt;summary&gt;
    /// 具体状态类：运行状态
    /// &lt;/summary&gt;
    class Running : ThreadState
    {
        public Running()
        {
            stateName = "运行状态";
            Console.WriteLine("当前线程处于：运行状态.");
        }
        public void suspend(ThreadContext hj)
        {
            Console.WriteLine("调用suspend()方法--&gt;");
            if (stateName.Equals("运行状态"))
            {
                hj.setState(new Blocked());
            }
            else
            {
                Console.WriteLine("当前线程不是运行状态，不能调用suspend()方法.");
            }
        }
        public void stop(ThreadContext hj)
        {
            Console.WriteLine("调用stop()方法--&gt;");
            if (stateName.Equals("运行状态"))
            {
                hj.setState(new Dead());
            }
            else
            {
                Console.WriteLine("当前线程不是运行状态，不能调用stop()方法.");
            }
        }
    }
    /// &lt;summary&gt;
    /// 具体状态类：阻塞状态
    /// &lt;/summary&gt;
    class Blocked : ThreadState
    {
        public Blocked()
        {
            stateName = "阻塞状态";
            Console.WriteLine("当前线程处于：阻塞状态.");
        }
        public void resume(ThreadContext hj)
        {
            Console.WriteLine("调用resume()方法--&gt;");
            if (stateName.Equals("阻塞状态"))
            {
                hj.setState(new Runnable());
            }
            else
            {
                Console.WriteLine("当前线程不是阻塞状态，不能调用resume()方法.");
            }
        }
    }
    /// &lt;summary&gt;
    /// 具体状态类：死亡状态
    /// &lt;/summary&gt;
    class Dead : ThreadState
    {
        public Dead()
        {
            stateName = "死亡状态";
            Console.WriteLine("当前线程处于：死亡状态.");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ThreadContext context = new ThreadContext();
            context.start();
            context.getCPU();
            context.suspend();
            context.resume();
            context.getCPU();
            context.stop();
            Console.ReadKey();
        }
    }
}
</code></pre> 
<p>运行结果</p> 
<p><img alt="" height="261" src="https://images2.imgbox.com/47/e1/An2cWOBl_o.png" width="377"></p> 
<h4>四、总结</h4> 
<p>状态模式是一种对象行为型模式，其主要优点如下。</p> 
<ol><li>结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li></ol> 
<p><br> 状态模式的主要缺点如下。</p> 
<ol><li>状态模式的使用必然会增加系统的类与对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li><li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li></ol> 
<p>参考：</p> 
<p><a href="http://c.biancheng.net/view/1388.html" rel="nofollow" title="http://c.biancheng.net/view/1388.html">http://c.biancheng.net/view/1388.html</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f6828bbd751adfbbbb5edd552e5f947/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电子技术——MOS放大器基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d9832e79c033843f75e2a16b819f7a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何利用 HBuilderX 制作图文混排的网页</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>