<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux任务之间的通信与同步,【gogofly原创】嵌入式操作系统分析（五）：进程间通信与同步... - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux任务之间的通信与同步,【gogofly原创】嵌入式操作系统分析（五）：进程间通信与同步..." />
<meta property="og:description" content="进程间通信与同步
作者：gogofly邮箱：
一、概述
在单任务系统中，任务是线性执行，任务不可能被抢占，所以不需要同步来保护共享资源与临界资源，同时单任务也不存在数据交换的问题，但对于多任务操作系统，会出现与但任务系统不同的问题，进程间通信与同步就是为了解决这些问题而提出的特有机制，它们为多任务系统提供了不同进程的通信机制，同时也提供了对于临界资源和共享资源的保护。
进程间通信与同步是多任务系统中的不同表现形式,，对于一些嵌入式操作系统，进程间通信与同步处于同一地址空间，这样使一些进程间通信机制同时可以用作同步机制，比如在UCOS中的一些进程间通信与同步机制。对于另外一些嵌入式操作系统中，进程间通信与同步处于不同的地址空间，它们是截然不同的两种机制，相互间没有什么联系(不包括同一进程中的不同线程同步)，最典型的就是嵌入式Linux中的进程间通信与同步机制。
二、进程间通信与同步区别与联系
在不同的嵌入式系统中，进程间通信与同步的实现方式有所不同，但是基本原理都差不多。对于进程间通信与同步，主要有2种方式：虚拟内存系统中的进程间通信与同步和Falt 内存系统中的进程间通信与同步。
Linux系统中的进程间通信是典型的虚拟内存系统中的进程间通信：Linux的进程间通信是不同进程间交换数据的机制。由于Linux系统支持虚拟内存，对于每一个进程，系统会为它分配一个单独的进程空间，不同的进程有不同的进程空间，相互之间没有什么关系，在这种系统中，不能用全局变量等一般的手段来实现不同进程间的数据交换，所以必须提供特有的数据交换机制：进程间通信。
同时此类系统中，由于内核空间是由不同的进程共享，所以在内核的数据可以由不同的进程共享，不同的进程也可能同时需要访问临界资源，同时要考虑内核中的中断，这种情况下，进程间的数据交换已经不是问题，现在的问题是如何保护临界资源和共享资源不被同时访问造成资源的紊乱，这就是Linux的同步机制。
UCOS是比较典型的Falt 内存系统，它不支持虚拟内存机制，也没有用户空间和内核空间的区别，实际上它就象是Linux的内核空间，不同任务间可以相互访问，没有不同进程间内存保护机制。所以可以完全利用Linux系统中的同一进程中不同线程的通信机制。由于所有的任务与中断都共享同一地址空间，所以同步机制也与任务间通信在同一空间中实现，是这2种机制的相互替换成为可能。
(待续)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4f286797baa4c57e95dc6ce12b2f488b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-14T06:31:42+08:00" />
<meta property="article:modified_time" content="2021-05-14T06:31:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux任务之间的通信与同步,【gogofly原创】嵌入式操作系统分析（五）：进程间通信与同步...</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>进程间通信与同步</p> 
 <p>作者：gogofly邮箱：</p> 
 <p>一、概述</p> 
 <p>在单任务系统中，任务是线性执行，任务不可能被抢占，所以不需要同步来保护共享资源与临界资源，同时单任务也不存在数据交换的问题，但对于多任务操作系统，会出现与但任务系统不同的问题，进程间通信与同步就是为了解决这些问题而提出的特有机制，它们为多任务系统提供了不同进程的通信机制，同时也提供了对于临界资源和共享资源的保护。</p> 
 <p>进程间通信与同步是多任务系统中的不同表现形式,，对于一些嵌入式操作系统，进程间通信与同步处于同一地址空间，这样使一些进程间通信机制同时可以用作同步机制，比如在UCOS中的一些进程间通信与同步机制。对于另外一些嵌入式操作系统中，进程间通信与同步处于不同的地址空间，它们是截然不同的两种机制，相互间没有什么联系(不包括同一进程中的不同线程同步)，最典型的就是嵌入式Linux中的进程间通信与同步机制。</p> 
 <p>二、进程间通信与同步区别与联系</p> 
 <p>在不同的嵌入式系统中，进程间通信与同步的实现方式有所不同，但是基本原理都差不多。对于进程间通信与同步，主要有2种方式：虚拟内存系统中的进程间通信与同步和Falt 内存系统中的进程间通信与同步。</p> 
 <p>Linux系统中的进程间通信是典型的虚拟内存系统中的进程间通信：Linux的进程间通信是不同进程间交换数据的机制。由于Linux系统支持虚拟内存，对于每一个进程，系统会为它分配一个单独的进程空间，不同的进程有不同的进程空间，相互之间没有什么关系，在这种系统中，不能用全局变量等一般的手段来实现不同进程间的数据交换，所以必须提供特有的数据交换机制：进程间通信。</p> 
 <p>同时此类系统中，由于内核空间是由不同的进程共享，所以在内核的数据可以由不同的进程共享，不同的进程也可能同时需要访问临界资源，同时要考虑内核中的中断，这种情况下，进程间的数据交换已经不是问题，现在的问题是如何保护临界资源和共享资源不被同时访问造成资源的紊乱，这就是Linux的同步机制。</p> 
 <p>UCOS是比较典型的Falt 内存系统，它不支持虚拟内存机制，也没有用户空间和内核空间的区别，实际上它就象是Linux的内核空间，不同任务间可以相互访问，没有不同进程间内存保护机制。所以可以完全利用Linux系统中的同一进程中不同线程的通信机制。由于所有的任务与中断都共享同一地址空间，所以同步机制也与任务间通信在同一空间中实现，是这2种机制的相互替换成为可能。</p> 
 <p>(待续)</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3bbfe3430cdca4f95bc50ec793ba28e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux grep -11,11个高级Linux字符类和括号表达式的grep命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/928ab28af2d607d67e9a9afb695cdb1e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA利用自带Axis工具和wsdl文件反向生成服务端客户端代码详细流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>