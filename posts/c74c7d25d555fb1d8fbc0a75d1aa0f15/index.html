<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>maven 分模块项目 主子pom之间的引入依赖关系 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="maven 分模块项目 主子pom之间的引入依赖关系" />
<meta property="og:description" content="在项目时用到maven管理项目，在一个就项目的基础上开发新的项目；关于子项目和父项目，子项目与子项目之间的调用问题，发现自己存在不足，以下是自己查询的问题，解决了自己的疑惑。
原文链接：https://www.cnblogs.com/kuoAT/p/6845876.html
问题
下面是一个简略的项目结构图
Parent
`------ childA(BusinessLayer)
`--- pom.xml
`------ childB(WebLayer)
`--- pom.xml
`------ pom.xml
1、Parent怎么能找到childA和childB呢？
在maven中，parent模块组织好childA和childB，叫做&#34;聚合&#34;，多个模块联合编译。实现起来很简单，只需要在parent的pom文件里加入以下内容。
&lt;modules&gt; &lt;module&gt;childA&lt;/module&gt; &lt;module&gt;childB&lt;/module&gt; &lt;/modules&gt; 2、是不是这样写就完全ok了？
这样只是告诉maven编译器，在读取parent的pom文件时去找到childA和childB，但还是会分别去编译他们引入的依赖。这样就会导致pom文件引入的包重复！！于是我们引入了&#34;继承&#34;的概念，也就是形成&#34;父子&#34;关系，子pom可以引用到父pom中引入的依赖。具体做法如下：
在parent中，写入以下内容，其中&#34;*&#34;标识的行可以组成一个路径，通过这个路径可以在maven仓库中找到这个pom文件！本例中，path为M2_Path/com/sang/main/Parent-Moduel/1.0.2/xxxx-1.0.2.pom。所以这三个标签是必须的！！！
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.sang.main&lt;/groupId&gt; * &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt; * &lt;version&gt;1.0.2&lt;/version&gt; * &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;Simple-main&lt;/name&gt; 父pom写好了，子pom就通过&lt;parent&gt;标签继承父pom的依赖，如下：
&lt;parent&gt; &lt;groupId&gt;com.sang.main&lt;/groupId&gt; &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!--本例中此处是可选的--&gt; &lt;/parent&gt; 值得注意的是&lt;relativePath&gt;标签，如果pom的层次关系就像本例中的那样只隔一层，则可以省略这个。maven同样可以找到子pom。
子pom中引入&lt;parent&gt;标签后，就会从父pom继承&lt;version&gt;等属性了，例如childA只需要再加入如下内容即可！
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.sang.business&lt;/groupId&gt; &lt;!--和artifactId一起唯一标识这个jar文件--&gt; &lt;artifactId&gt;ChildA-module&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--指明打包类型--&gt; &lt;name&gt;childA&lt;/name&gt; 3、如何添加依赖？
maven可以让我们方便地管理jar包依赖，具体做法如下：
&lt;dependencies&gt; &lt;dependency&gt; &lt;!--添加一个jar包依赖--&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 如果不通过继承，则需要在每个pom中加入这样的依赖，这样子pom对应的模块可以引用到这个jar包。上面提到的重复引用jar包，可以通过下面的方式解决：
主pom中把依赖通过&lt;dependecyManagement&gt;引起来，表示子pom可能会用到的jar包依赖
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 子pom如果需要引用该jar包，则直接引用即可！不需要加入&lt;version&gt;，便于统一管理。此外也可以加入仅在子pom中用到的jar包，比如：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c74c7d25d555fb1d8fbc0a75d1aa0f15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-24T21:43:06+08:00" />
<meta property="article:modified_time" content="2020-03-24T21:43:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">maven 分模块项目 主子pom之间的引入依赖关系</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>在项目时用到maven管理项目，在一个就项目的基础上开发新的项目；关于子项目和父项目，子项目与子项目之间的调用问题，发现自己存在不足，以下是自己查询的问题，解决了自己的疑惑。</strong></p> 
<p> 原文链接：https://www.cnblogs.com/kuoAT/p/6845876.html</p> 
<p><strong>问题</strong></p> 
<p>下面是一个简略的项目结构图</p> 
<p>Parent<br> `------ childA(BusinessLayer)<br>           `--- pom.xml<br><br> `------ childB(WebLayer)<br>          `--- pom.xml<br><br> `------ pom.xml</p> 
<p><strong>1、Parent怎么能找到childA和childB呢？</strong></p> 
<p>在maven中，parent模块组织好childA和childB，叫做"聚合"，多个模块联合编译。实现起来很简单，只需要在parent的pom文件里加入以下内容。</p> 
<pre><code class="language-java">&lt;modules&gt;
   &lt;module&gt;childA&lt;/module&gt;
   &lt;module&gt;childB&lt;/module&gt;
&lt;/modules&gt;</code></pre> 
<p><strong>2、是不是这样写就完全ok了？</strong></p> 
<p>这样只是告诉maven编译器，在读取parent的pom文件时去找到childA和childB，但还是会分别去编译他们引入的依赖。这样就会导致pom文件引入的包重复！！于是我们引入了"继承"的概念，也就是形成"父子"关系，子pom可以引用到父pom中引入的依赖。具体做法如下：</p> 
<p>在parent中，写入以下内容，其中"*"标识的行可以组成一个路径，通过这个路径可以在maven仓库中找到这个pom文件！本例中，path为M2_Path/com/sang/main/Parent-Moduel/1.0.2/xxxx-1.0.2.pom。所以这三个标签是必须的！！！</p> 
<pre><code class="language-java">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  
&lt;groupId&gt;com.sang.main&lt;/groupId&gt;              *
&lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt;         *
&lt;version&gt;1.0.2&lt;/version&gt;            *
&lt;packaging&gt;pom&lt;/packaging&gt;  
&lt;name&gt;Simple-main&lt;/name&gt;</code></pre> 
<p>父pom写好了，子pom就通过&lt;parent&gt;标签继承父pom的依赖，如下：</p> 
<pre><code class="language-java">&lt;parent&gt;
   &lt;groupId&gt;com.sang.main&lt;/groupId&gt;
   &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt;
   &lt;version&gt;1.0.2&lt;/version&gt;
   &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;  &lt;!--本例中此处是可选的--&gt;
&lt;/parent&gt;</code></pre> 
<p>值得注意的是&lt;relativePath&gt;标签，如果pom的层次关系就像本例中的那样只隔一层，则可以省略这个。maven同样可以找到子pom。</p> 
<p>子pom中引入&lt;parent&gt;标签后，就会从父pom继承&lt;version&gt;等属性了，例如childA只需要再加入如下内容即可！</p> 
<pre><code class="language-java">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  
&lt;groupId&gt;com.sang.business&lt;/groupId&gt;     &lt;!--和artifactId一起唯一标识这个jar文件--&gt;
&lt;artifactId&gt;ChildA-module&lt;/artifactId&gt;
&lt;packaging&gt;jar&lt;/packaging&gt;         &lt;!--指明打包类型--&gt;
&lt;name&gt;childA&lt;/name&gt;</code></pre> 
<p><strong>3、如何添加依赖？</strong></p> 
<p>maven可以让我们方便地管理jar包依赖，具体做法如下：</p> 
<pre><code class="language-java">&lt;dependencies&gt;
     &lt;dependency&gt;   &lt;!--添加一个jar包依赖--&gt;
         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;version&gt;2.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<p>如果不通过继承，则需要在每个pom中加入这样的依赖，这样子pom对应的模块可以引用到这个jar包。上面提到的重复引用jar包，可以通过下面的方式解决：</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>主pom中把依赖通过&lt;dependecyManagement&gt;引起来，表示子pom可能会用到的jar包依赖</p> 
<pre><code class="language-java">&lt;dependencyManagement&gt;
   &lt;dependencies&gt;
      &lt;dependency&gt;
           &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
          &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
          &lt;version&gt;2.5&lt;/version&gt;
      &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre> 
<p>子pom如果需要引用该jar包，则直接引用即可！不需要加入&lt;version&gt;，便于统一管理。此外也可以加入仅在子pom中用到的jar包，比如：</p> 
<pre><code class="language-java">&lt;dependencies&gt;
   &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;   &lt;!--此处不再需要verison了！--&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
       &lt;artifactId&gt;jackson-core-lgpl&lt;/artifactId&gt;
       &lt;version&gt;1.9.4&lt;/version&gt;    &lt;!--当然也可以加入只在这个子模块中用到的jar包--&gt;
   &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre> 
<p>如果父pom中使用的是</p> 
<pre><code class="language-java">&lt;dependencies&gt;....&lt;/dependencies&gt;</code></pre> 
<p>的方式，则子pom会自动使用pom中的jar包， <br> 如果父pom使用</p> 
<pre><code class="language-java">&lt;dependencyManagement&gt;

    &lt;dependencies&gt;....&lt;/dependencies&gt;

&lt;/dependencyManagement&gt;</code></pre> 
<p>方式，则子pom不会自动使用父pom中的jar包，这时如果子pom想使用的话，就要给出groupId和artifactId，无需给出version</p> 
<p> </p> 
<p><strong>4、除了jar包依赖，插件也可以通过这样的方式进行管理</strong></p> 
<pre><code class="language-java">&lt;!-- mainModule --&gt;
&lt;build&gt;
   &lt;pluginManagement&gt;
      &lt;plugins&gt;
          &lt;plugin&gt;
               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
               &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
               &lt;version&gt;2.1.1&lt;/version&gt;
          &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/pluginManagement&gt;
&lt;/build&gt;

&lt;!-- childA --&gt;
&lt;build&gt;   
   &lt;plugins&gt;
      &lt;plugin&gt;
           &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
           &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
   &lt;/plugins&gt;
&lt;/build&gt;</code></pre> 
<p><strong>5、如果子pom间存在引用关系，比如childA被引用到了childB的jar包，该怎么做？</strong></p> 
<pre><code class="language-java">&lt;dependency&gt;
   &lt;groupId&gt;com.module&lt;/groupId&gt;
   &lt;artifactId&gt;childA&lt;/artifactId&gt;       &lt;!--加上childA的依赖--&gt;
   &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p> </p> 
<pre> </pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86e811126c848a2dba7daa1307cd344f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">视觉SLAM十四讲 第八讲 视觉里程计2 8.5直接法BA法 代码解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e601cba781e02f7fab30fea7f730799/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android设置Activity背景色为透明的3种方</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>