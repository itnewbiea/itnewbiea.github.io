<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>串的基本操作 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="串的基本操作" />
<meta property="og:description" content="掌握串的基本操作、初始化字符串 生成一个值为chars常量串的字符串S、返回字符串的长度、复制字符串、比较两个字符串、将字符串清为空串，并释放该字符串所占空间、在串S1的第pos个字符之前插入串S2、删除主串中指定位置之后一定长度的子串、用T返回由S1和S2联接而成的新串、用T返回串S的第pos个字符起长度为len的子串、返回子串T在主串S中第pos个字符之后的位置、用KMP算法实现返回子串T在主串S中第pos个字符之后的位置、遍历串S；
#include &lt;iostream&gt; #include &lt;vector&gt; #define MAXSIZE 50 using namespace std; typedef struct { char ch[MAXSIZE&#43;1]; int length; }TString,*HString; HString InitString();//初始化字符串 bool StrAssign (HString S,char chs[]);//生成一个值为chars常量串的字符串S int StrLength(HString S);//返回字符串的长度 bool StringCopy(HString S1,HString S2);//将串S2复制到S1 int StrCompare(HString S,HString T);//比较两个字符串，若S&gt;T,则返回值&gt;0; 若S&lt;T,则返回值&lt;0 ;若S=T，则返回值=0 bool ClearString(HString S);//将S清为空串，并释放S所占空间 bool StrInsert(HString S1,HString S2,int pos);//在串S1的第pos个字符之前插入串S2 bool DeleteString(HString S,int pos,int len);//删除主串中指定位置之后一定长度的子串 bool Concat(HString T,HString S1,HString S2);//用T返回由S1和S2联接而成的新串 bool SubString(HString T,HString S,int pos,int len);//用T返回串S的第pos个字符起长度为len的子串 int Index(HString S,HString T,int pos);//返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数值为0 vector&lt;int&gt; getNext(HString T); //next数组的实现 int Index1(HString S,HString T,int pos);//用KMP算法实现返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数值为0 bool traverString(HString S);//遍历串S int main(){ cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eb1c1d0801505a58ff6be6ae75a5e7d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-02T22:11:59+08:00" />
<meta property="article:modified_time" content="2022-10-02T22:11:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">串的基本操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#393939;"><span style="color:#393939;">掌握串的基本操作、初始化字符串 生成一个值为chars常量串的字符串S、返回字符串的长度、复制字符串、比较两个字符串、将字符串清为空串，并释放该字符串所占空间、在串S1的第pos个字符之前插入串S2、删除主串中指定位置之后一定长度的子串、用T返回由S1和S2联接而成的新串、用T返回串S的第pos个字符起长度为len的子串、返回子串T在主串S中第pos个字符之后的位置、用KMP算法实现返回子串T在主串S中第pos个字符之后的位置、遍历串S；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<pre><code class="hljs">#include &lt;iostream&gt;

#include &lt;vector&gt;

#define MAXSIZE 50

using namespace std;

typedef struct {

char ch[MAXSIZE+1];

int length;

}TString,*HString;

HString InitString();//初始化字符串

bool StrAssign (HString S,char chs[]);//生成一个值为chars常量串的字符串S

int StrLength(HString S);//返回字符串的长度

bool StringCopy(HString S1,HString S2);//将串S2复制到S1

int StrCompare(HString S,HString T);//比较两个字符串，若S&gt;T,则返回值&gt;0; 若S&lt;T,则返回值&lt;0 ;若S=T，则返回值=0

bool ClearString(HString S);//将S清为空串，并释放S所占空间

bool StrInsert(HString S1,HString S2,int pos);//在串S1的第pos个字符之前插入串S2

bool DeleteString(HString S,int pos,int len);//删除主串中指定位置之后一定长度的子串

bool Concat(HString T,HString S1,HString S2);//用T返回由S1和S2联接而成的新串

bool SubString(HString T,HString S,int pos,int len);//用T返回串S的第pos个字符起长度为len的子串

int Index(HString S,HString T,int pos);//返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数值为0

vector&lt;int&gt; getNext(HString T); //next数组的实现

int Index1(HString S,HString T,int pos);//用KMP算法实现返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数值为0

bool traverString(HString S);//遍历串S



int main(){

cout &lt;&lt; "请输入一串字符串" &lt;&lt; endl;

char ch[MAXSIZE];

cin &gt;&gt; ch;

HString S = InitString();

if(StrAssign(S,ch)){

cout &lt;&lt; "字符串S赋值成功" &lt;&lt; endl;

traverString(S);

}

cout &lt;&lt; "请输入一串字符串" &lt;&lt; endl;

char ch1[MAXSIZE];

cin &gt;&gt; ch1;

HString S1 = InitString();

if(StrAssign(S1,ch1)){

cout &lt;&lt; "字符串S1赋值成功" &lt;&lt; endl;

traverString(S1);

}

cout &lt;&lt; "S字符串长度为" &lt;&lt; StrLength(S) &lt;&lt; endl;

HString S2 = InitString();

if(StringCopy(S2,S)){

cout &lt;&lt; "字符串S2复制S成功" &lt;&lt; endl;

traverString(S2);

}

    cout &lt;&lt; "字符串S1和S2比较大小" &lt;&lt; endl;

int m = StrCompare(S1,S2);

if(m==0){

cout &lt;&lt; "字符串S1等于S2" &lt;&lt; endl;

}

else if(m&gt;0){

cout &lt;&lt; "字符串S1大于S2" &lt;&lt; endl;

}

else if(m&lt;0){

cout &lt;&lt; "字符串S1小于S2" &lt;&lt; endl;

}

cout &lt;&lt; "请分别输入要插入的字符串和插入字符串S的位置" &lt;&lt; endl;

char ch2[MAXSIZE];

int n;

cin &gt;&gt; ch2 &gt;&gt; n;

HString S3 = InitString();

StrAssign(S3,ch2);

StrInsert(S,S3,n);

traverString(S);

int k,p;

cout &lt;&lt; "请分别输入在S中要删除的指定位置之后的子串的位置及子串的长度" &lt;&lt; endl;

cin &gt;&gt; k &gt;&gt; p;

if(DeleteString(S,k,p)){

cout &lt;&lt; "删除成功" &lt;&lt; endl;

traverString(S);

}

cout &lt;&lt; "请分别输入串S的子串的起始位置和长度" &lt;&lt; endl;

cin &gt;&gt; k &gt;&gt; p;

HString T = InitString();

if(SubString(T,S,k,p)){

cout &lt;&lt; "子串获取成功" &lt;&lt; endl;

traverString(T);

}



HString S4 = InitString();

Concat(S4,S1,S2);

cout &lt;&lt; "S1和S2串联而成新串S4" &lt;&lt; endl;

traverString(S4);

char ch3[MAXSIZE];

int i;

cout &lt;&lt; "请分别输入S1的子串和从主串中查找子串的起始位置" &lt;&lt; endl;

cin &gt;&gt; ch3 &gt;&gt; i;

HString S5 = InitString();

StrAssign(S5,ch3);

cout &lt;&lt; "子串在主串中的位置为" &lt;&lt; Index(S1,S5,i) &lt;&lt; endl;

cout &lt;&lt; "用KMP算法求";

cout &lt;&lt; "子串在主串中的位置为" &lt;&lt; Index1(S1,S5,i) &lt;&lt; endl;

ClearString(S);

ClearString(S1);

ClearString(S2);

ClearString(S3);

ClearString(S4);

ClearString(S5);

return 0;

}

//初始化字符串

HString InitString(){

 HString str= new TString;

      if(!str)

            cout &lt;&lt; "动态内存分配失败!" &lt;&lt; endl;

      str-&gt;length=0;

      return str;

}

//生成一个值为chars常量串的字符串S

bool StrAssign (HString S,char chs[]){

int i=0;

while(chs[i])

    {

            S-&gt;ch[S-&gt;length++]=chs[i++];

    }

    return true;

      

}

    





//返回字符串的长度

int StrLength(HString S){

return S-&gt;length;

}



//将串S2复制到S1

bool StringCopy(HString S1,HString S2){

for(int i=0;i&lt;S2-&gt;length;i++){

S1-&gt;ch[i] = S2-&gt;ch[i];

}

S1-&gt;length = S2-&gt;length;

return S1;

}

//比较两个字符串，若S&gt;T,则返回值&gt;0; 若S&lt;T,则返回值&lt;0 ;若S=T，则返回值=0

int StrCompare(HString S,HString T){

for(int i=0;(i&lt;S-&gt;length)&amp;&amp;(i&lt;T-&gt;length);++i){

if(S-&gt;ch[i] != T-&gt;ch[i])

    return (int)(S-&gt;ch[i])-(int)(T-&gt;ch[i]);

}

return (int)(S-&gt;length)-(int)(T-&gt;length);

}



//将S清为空串，并释放S所占空间

bool ClearString(HString S){

if(S){

delete S;

}

S-&gt;length = 0;

return true;

    

}



//在串S1的第pos个字符之前插入串S2

bool StrInsert(HString S1,HString S2,int pos){

if(pos&lt;1||pos&gt;S1-&gt;length){

cout &lt;&lt; "输入错误" &lt;&lt; endl;

return false;

}

for(int i=(S1-&gt;length-1);i&gt;=pos-1;i--){

S1-&gt;ch[i+S2-&gt;length] = S1-&gt;ch[i];

}

int k = pos-1;

for(int j=0;j&lt;S2-&gt;length;j++)

S1-&gt;ch[k++] = S2-&gt;ch[j];

S1-&gt;length += S2-&gt;length;

return true;

}

//删除主串中指定位置之后一定长度的子串

bool DeleteString(HString S,int pos,int len)

{

      if(pos&lt;1||pos&gt;S-&gt;length||len+pos-1&gt;S-&gt;length)

      {

             cout &lt;&lt; "输入错误";

             exit(-1);

      }

      int i;

      for(i=pos+len;i&lt;=S-&gt;length;i++)

      {



            S-&gt;ch[i-len]=S-&gt;ch[i];

      }

      S-&gt;length=S-&gt;length-len;

      return true;



}

//用T返回由S1和S2联接而成的新串

bool Concat(HString T,HString S1,HString S2){

for(int i=0;i&lt;S1-&gt;length;i++){

T-&gt;ch[i] = S1-&gt;ch[i];

  }

  T-&gt;length = S1-&gt;length;

  int j=0;

  while(T-&gt;length!=S1-&gt;length+S2-&gt;length){

  T-&gt;ch[T-&gt;length++] = S2-&gt;ch[j++];

 }

 return true;

}



//用T返回串S的第pos个字符起长度为len的子串

bool SubString(HString T,HString S,int pos,int len){

if(pos&lt;1||pos&gt;S-&gt;length||len&lt;0||len&gt;S-&gt;length-pos+1)

    return false;

if(!len){

T-&gt;ch[0] = '\0';

T-&gt;length = 0;

}

else{

for(int i=0;i&lt;len;i++){

T-&gt;ch[i] = S-&gt;ch[pos-1+i];

T-&gt;length = len;

}

}

return true;

}



//返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数值为0

int Index(HString S,HString T,int pos){

        if(S-&gt;length&lt;T-&gt;length)

    return 0;

        if(pos&lt;1||pos&gt;S-&gt;length){

cout &lt;&lt; "输入错误" &lt;&lt; endl;

return 0;

    }

        for(int i=pos;i&lt;S-&gt;length;i++){

            int i1 = i;

            int i2 = 0;

            while(i2&lt;S-&gt;length){

                if(S-&gt;ch[i1]==T-&gt;ch[i2]){

                 i1++;

i2++;

}

                else

    break;

            }

            if(i2==T-&gt;length)

    return (i+1);

        }

        return 0;

}

//next数组的实现

vector&lt;int&gt; getNext(HString T){

        vector&lt;int&gt; next(T-&gt;length);

        if(T-&gt;length==0)

    return next;

        if(T-&gt;length==1){

            next[0] = -1;

            return next;

        }

        next[0] = -1;

        next[1] = 0;

        for(int i=2;i&lt;T-&gt;length;i++){

            int j = next[i-1];

            while(j&gt;=0&amp;&amp;T-&gt;ch[i-1]!=T-&gt;ch[j]){

             j = next[j];

}

            if(j==-1)

    next[i] = 0;

            else

    next[i] = j+1;

        }

        return next;

    }



//用KMP算法实现返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数值为0

int Index1(HString S,HString T,int pos){

if(pos&lt;1||pos&gt;S-&gt;length){

cout &lt;&lt; "输入错误" &lt;&lt; endl;

return 0;

}

int i1 = pos;

int i2 = 0;

vector&lt;int&gt; next = getNext(T);

while(i1&lt;S-&gt;length&amp;&amp;i2&lt;T-&gt;length){

if(S-&gt;ch[i1] == T-&gt;ch[i2]){

i1++;

i2++;

}

else if(i2==0){

i1++;

}else{

i2 = next[i2];

}

}

return i2 = T-&gt;length?(i1-i2+1):0;

}

//遍历串S

bool traverString(HString S){

    if(S-&gt;length == 0){

     cout &lt;&lt; "此串为空" &lt;&lt; endl;

     return false;

}

cout &lt;&lt; "此时该字符串为";

for(int i=0;i&lt;S-&gt;length;i++){

cout &lt;&lt; S-&gt;ch[i];

}

cout &lt;&lt; endl;

return true;

}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/834ddf8ca1da41ed3c7ed3462eeb7309/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">稀疏矩阵的基本操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99e5e54422a237cf9f7fe31c335c59f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity的UI框架</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>