<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue实战性能优化-节流防抖路由懒加载gzip减少接口请求 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue实战性能优化-节流防抖路由懒加载gzip减少接口请求" />
<meta property="og:description" content="**前言：**这是自己在做vue移动端项目中总结的几点关于性能优化的知识点，分享记录一下。
文章有以下几个优化部分
gzip图片压缩路由懒加载减少接口请求keep-alive页面缓存防抖节流工具型方法封装​ 一、gzip图片压缩
** **gizp压缩是一种http请求优化方式，通过减少文件体积来提高加载速度。html、js、css文件甚至json数据都可以用它压缩，可以减小60%以上的体积。(需要后端的支持)
步骤：（按步骤来）
1、安装 npm i compression-webpack-plugin@1.1.11 -D 2、在vue.config.js 配置里面 进行导包 // 导包 const CompressionWebpackPlugin = require(&#39;compression-webpack-plugin&#39;) // 匹配文件名const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i// 配置module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV === &#39;production&#39;) { return { plugins: [ new CompressionWebpackPlugin({ filename: &#39;[path].gz[query]&#39;, algorithm: &#39;gzip&#39;, // 默认为gzip test: productionGzipExtensions, threshold: 2048, // 对超过2k的数据进行压缩 minRatio: 0.8, // 仅压缩比该比率更好的（minRatio = Compressed Size / Original Size） deleteOriginalAssets: false // 是否删除原文件 }) ] } } }} 3、运行 npm run build 进行打包 gzip压缩后,通过gzip压缩可以使Vue首页加载速度大大提升,以下是压缩前与压缩后，差距还是非常大的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ea6b0673d45ec7534358f58674668634/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-08T02:04:40+08:00" />
<meta property="article:modified_time" content="2021-01-08T02:04:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue实战性能优化-节流防抖路由懒加载gzip减少接口请求</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>**前言：**这是自己在做vue移动端项目中总结的几点关于性能优化的知识点，分享记录一下。</p> 
<p>文章有以下几个优化部分</p> 
<ul><li>gzip图片压缩</li><li>路由懒加载</li><li>减少接口请求</li><li>keep-alive页面缓存</li><li>防抖节流工具型方法封装</li><li>​</li></ul> 
<p><strong>一、gzip图片压缩</strong></p> 
<p>** **gizp压缩是一种http请求优化方式，通过减少文件体积来提高加载速度。html、js、css文件甚至json数据都可以用它压缩，可以减小60%以上的体积。(需要后端的支持)</p> 
<p><img src="https://images2.imgbox.com/3f/96/yXbdngPk_o.png" alt="img"></p> 
<p>步骤：（按步骤来）</p> 
<pre><code>1、安装 npm i compression-webpack-plugin@1.1.11 -D
</code></pre> 
<pre><code>2、在vue.config.js 配置里面 进行导包 // 导包 const CompressionWebpackPlugin = require('compression-webpack-plugin') // 匹配文件名const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i// 配置module.exports = {  configureWebpack: config =&gt; {    if (process.env.NODE_ENV === 'production') {      return {        plugins: [          new CompressionWebpackPlugin({            filename: '[path].gz[query]',            algorithm: 'gzip',  // 默认为gzip            test: productionGzipExtensions,            threshold: 2048, // 对超过2k的数据进行压缩             minRatio: 0.8,  // 仅压缩比该比率更好的（minRatio = Compressed Size / Original Size）            deleteOriginalAssets: false  // 是否删除原文件          })        ]      }    }  }}
</code></pre> 
<pre><code>3、运行 npm run build 进行打包
</code></pre> 
<p>gzip压缩后,通过gzip压缩可以使Vue首页加载速度大大提升,以下是压缩前与压缩后，差距还是非常大的</p> 
<p><img src="https://images2.imgbox.com/5b/1f/Llfr3edO_o.png" alt="img"></p> 
<pre><code>4、进行打包分析可以更具体的查看
</code></pre> 
<pre><code>const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPluginmodule.exports = {    // 构建体积分析    chainWebpack: config =&gt; {      config        .plugin('webpack-bundle-analyzer')        .use(BundleAnalyzerPlugin)        .init(Plugin =&gt; new Plugin())    }}
</code></pre> 
<pre><code>执行 npm run build --report
</code></pre> 
<p><img src="https://images2.imgbox.com/93/de/NSpBEXic_o.png" alt="img"><img src="https://images2.imgbox.com/bf/aa/HIy1Joua_o.png" alt="img"></p> 
<p><strong>二、路由懒加载</strong></p> 
<p>当打包构建应用时，JavaScript 包会变得非常大，会影响页面的加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。****</p> 
<pre><code>1、在路由配置中import方法实现路由懒加载
</code></pre> 
<pre><code>const router = new VueRouter({  routes: [    { path: '/foo', component: () =&gt; import('./Foo.vue') }  ]})
</code></pre> 
<p>第三方插件按需加载方法：</p> 
<p>以Vant为例，借助 babel-plugin-import ，只引入需要的组件，以达到减少体积</p> 
<p>安装：（装包）</p> 
<pre><code>npm i babel-plugin-import -D
</code></pre> 
<pre><code>// 在.babelrc 中添加配置// 注意：webpack 1 无需设置 libraryDirectory{  "plugins": [    ["import", {      "libraryName": "vant",      "libraryDirectory": "es",      "style": true    }]  ]}
</code></pre> 
<pre><code>按需加载组件// 你可以在代码中直接引入 Vant 组件// 插件会自动将代码转化为方式二中的按需引入形式import { Button } from 'vant';
</code></pre> 
<p><strong>三、减少接口请求</strong></p> 
<p>每次路由跳转或者反复多次刷新时重新向服务器发送请求时取消上一次发送的接口请求</p> 
<p>1、请求拦截器js文件中设置</p> 
<pre><code>// 取消请求let cancelArr = []window.cancelAxios = function (url, allAxios = false) {  cancelArr = cancelArr.filter(item =&gt; {    if (allAxios) {      item.c()      return false    } else {      if (item.url === url) {        item.c()        return false      } else {        return true      }    }  })}// 请求拦截器_fetch.interceptors.request.use(  function (config) {    window.cancelAxios(config.url)    config.cancelToken = new axios.CancelToken(cancel =&gt; {      cancelArr.push({        url: config.url,        c: cancel      })    })    return config  },  function (error) {    return Promise.reject(error)  })
</code></pre> 
<p>2、路由beforeEach前置守卫</p> 
<pre><code>// 前置守卫router.beforeEach((to, from, next) =&gt; {  // 每次跳转路由取消所有请求  window.cancelAxios('', true)}
</code></pre> 
<p><img src="https://images2.imgbox.com/4b/34/QeGddtsf_o.png" alt="img"></p> 
<p>四、keep-alive页面缓存</p> 
<p>原因：当你希望某个页面不被重新渲染,就可以使用Vue的keep-alive组件,不仅可以缓存当前页面数据,还可以避免多次渲染降低性能。在组件中设置一个name属性</p> 
<pre><code>export default {  name: 'article',   // name值  // keep-alive的生命周期  // 初次进入时：created &gt; mounted &gt; activated  // 再次进入：只会触发 activated  activated () {    // to do..  },  // 退出后触发 deactivated  deactivated () {    // to do..  }}
</code></pre> 
<p>在路由出口处用keep-alive标签包着，标签内定义include=“article” 详细备注请看下方</p> 
<pre><code>&lt;!-- 路由出口 --&gt;   &lt;!-- include - 字符串或正则表达式。只有名称匹配的组件会被缓存。        exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。        max - 数字。最多可以缓存多少组件实例。--&gt;    &lt;keep-alive include="article"&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;
</code></pre> 
<p><strong>五、节流防抖</strong></p> 
<p>好多公司面试都爱问这个问题，看看是怎么封装的</p> 
<p>防抖工具型方法封装</p> 
<pre><code>function debounce (fnEvent, time) {          var _time = null          return function () {            let _arg = arguments            let _this = this            if (_time) {              clearTimeout(_time)            }            _time = setTimeout(() =&gt; {              fnEvent.apply(_this, _arg)            }, time)          }        }
</code></pre> 
<p><strong>节流工具型方法封装</strong></p> 
<pre><code>function throttle (fnEvent, time) {        var isLoading = false        return function () {          let _arg = arguments          if (!isLoading) {            isLoading = true            let _this = this            setTimeout(() =&gt; {              fnEvent.apply(_this, _arg)              isLoading = false            }, time)          }        }      }
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce64162116078a3017feaa6ceeae629d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PIM DM技术原理与实验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58150bccdfe68dcd22305f33fa9d59db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">有向图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>