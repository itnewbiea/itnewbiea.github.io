<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python Selenium 抓取Shadow Dom内部元素方法更新 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python Selenium 抓取Shadow Dom内部元素方法更新" />
<meta property="og:description" content="By Mejias
背景：
应团队的PMP的要求，为自己的Team开发了一个内部网站信息抓取的工具（整体代码展示见文章末尾，可能稍微有点长）。上上周周写完测试后推给了大家，没有什么问题。今天Team的一个小伙伴突然告诉我报错，显示是Chrome Driver与Chrome版本不对，搜索Chrome://version，才发现是Chrome自动升级了。这样原来版本的Chrome driver就不支持了，导致程序报错。
在Chrome Driver官网here重新搜索了版本匹配的Chrome Driver并下载安装好之后，再次运行程序，发现前面都运行的很好直到后面首尾部分报错如下:
报错显示的是下面这里出了问题：
def control_in_shadow(driver,js): shadow = driver.execute_script(js) return shadow #返回的对象在这里 js = &#39;return document.querySelector(&#34;#ra-shadow-root&#34;).shadowRoot&#39; shadow= control_in_shadow(driver,js) shadow.find_element(By.ID,&#39;ra-asin-list-count-input&#39;).clear() shadow.find_element(By.ID,&#39;ra-asin-list-count-input&#39;).send_keys(&#39;1000&#39;) shadow.find_element(By.ID,&#39;ra-asin-list-load-btn&#39;).click() 上面的代码访问下列Shadow Doml里的元素。
采用的方法就是常说的三步法：
定位到Shadow Dom的Host节点 =》 使用.shadowRoot属性定位到根节点 =》
直接通过页面Element的方法访问Shadow Dom内部的元素。这种方法在未更新chrome driver 的版本之前一直用的很好的。
但是在更新了Chrome版本和chrome driver版本之后就会报错了。原来的方法在新的chrome driver并不适用。于是在收到小伙伴的反馈后，就需要测试代码问题以及修改和Refine了。
测试&amp;发现问题：
首先根据上面的报错可以定位到是下面的代码出了问题。
​ def control_in_shadow(driver,js): shadow = driver.execute_script(js) return shadow #返回的对象在这里 js = &#39;return document.querySelector(&#34;#ra-shadow-root&#34;).shadowRoot&#39; shadow= control_in_shadow(driver,js) shadow.find_element(By.ID,&#39;ra-asin-list-count-input&#39;).clear() shadow.find_element(By.ID,&#39;ra-asin-list-count-input&#39;).send_keys(&#39;1000&#39;) shadow.find_element(By.ID,&#39;ra-asin-list-load-btn&#39;).click() ​ 因为.execute_script(js)是driver对象自带的方法，这一段执行JS语句也没有报错，所以肯定不是定义的新方法的问题。而且看代码报错是说函数返回的对象是一个dict，而不是原来应该是的remote controlled web element元素，导致web element的查找元素的方法.find_element(By.)使用报错。所以我这里定位到这个返回对象“shadow”是否问题。
为了测试它是否只是一个dict还是说代表了shadowRoot这个节点，我们可以使用shadowRoot的一些属性和方法去测试他是否是一个shadowRoot。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6dfb6266d82dcdbf350ba1a0b4b2b0c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-23T19:27:19+08:00" />
<meta property="article:modified_time" content="2021-11-23T19:27:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python Selenium 抓取Shadow Dom内部元素方法更新</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0;text-align:center;"></h2> 
<p style="margin-left:.0001pt;text-align:right;">By Mejias</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>背景：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">应团队的PMP的要求，为自己的Team开发了一个内部网站信息抓取的工具（整体代码展示见文章末尾，可能稍微有点长）。上上周周写完测试后推给了大家，没有什么问题。今天Team的一个小伙伴突然告诉我报错，显示是Chrome Driver与Chrome版本不对，搜索Chrome://version，才发现是Chrome自动升级了。这样原来版本的Chrome driver就不支持了，导致程序报错。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="318" src="https://images2.imgbox.com/43/44/zteBsD6B_o.png" width="693"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">在Chrome Driver官网<a href="https://chromedriver.chromium.org/downloads" rel="nofollow" title="here">here</a>重新搜索了版本匹配的Chrome Driver并下载安装好之后，再次运行程序，发现前面都运行的很好直到后面首尾部分报错如下:</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="105" src="https://images2.imgbox.com/12/1c/w3RRwZRE_o.png" width="693"></p> 
<p style="margin-left:.0001pt;text-align:justify;">报错显示的是下面这里出了问题：</p> 
<pre><code class="language-python">def control_in_shadow(driver,js):

    shadow = driver.execute_script(js)

    return shadow #返回的对象在这里

js = 'return document.querySelector("#ra-shadow-root").shadowRoot'

shadow= control_in_shadow(driver,js)

shadow.find_element(By.ID,'ra-asin-list-count-input').clear()

shadow.find_element(By.ID,'ra-asin-list-count-input').send_keys('1000')

shadow.find_element(By.ID,'ra-asin-list-load-btn').click()</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">上面的代码访问下列Shadow Doml里的元素。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="317" src="https://images2.imgbox.com/3c/0d/r5iKT6qo_o.png" width="693"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">采用的方法就是常说的三步法：</p> 
<p style="margin-left:.0001pt;text-align:justify;">定位到Shadow Dom的Host节点 =》 使用.shadowRoot属性定位到根节点 =》</p> 
<p style="margin-left:.0001pt;text-align:justify;">直接通过页面Element的方法访问Shadow Dom内部的元素。这种方法在未更新chrome driver 的版本之前一直用的很好的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">但是在更新了Chrome版本和chrome driver版本之后就会报错了。原来的方法在新的chrome driver并不适用。于是在收到小伙伴的反馈后，就需要测试代码问题以及修改和Refine了。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>测试&amp;发现问题：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">首先根据上面的报错可以定位到是下面的代码出了问题。</p> 
<pre><code class="language-python">​
def control_in_shadow(driver,js):

    shadow = driver.execute_script(js)

    return shadow #返回的对象在这里

js = 'return document.querySelector("#ra-shadow-root").shadowRoot'

shadow= control_in_shadow(driver,js)

shadow.find_element(By.ID,'ra-asin-list-count-input').clear()

shadow.find_element(By.ID,'ra-asin-list-count-input').send_keys('1000')

shadow.find_element(By.ID,'ra-asin-list-load-btn').click()

​</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">因为.execute_script(js)是driver对象自带的方法，这一段执行JS语句也没有报错，所以肯定不是定义的新方法的问题。而且看代码报错是说函数返回的对象是一个dict，而不是原来应该是的remote controlled web element元素，导致web element的查找元素的方法.find_element(By.)使用报错。所以我这里定位到这个返回对象<span style="background-color:#ffff00;">“shadow”</span>是否问题。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">为了测试它是否只是一个dict还是说代表了shadowRoot这个节点，我们可以使用shadowRoot的一些属性和方法去测试他是否是一个shadowRoot。</p> 
<p style="margin-left:.0001pt;text-align:justify;">shadowDom的shadowRoot有许多的属性，例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">shadowRoot.host（返回根节点的宿主节点的引用）；</p> 
<p style="margin-left:.0001pt;text-align:justify;">shadowRoot.innerHTML(返回对shadowRoot内的DOM树的引用)</p> 
<p style="margin-left:.0001pt;text-align:justify;">shadowRoot.mode(返回shadowRoot的模式 -open或 -closed)</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">测试代码如下：</span></p> 
<pre><code class="language-python">def control_in_shadow(driver,js):

    shadow = driver.execute_script(js)

    return shadow #返回的对象在这里

 js = 'return document.querySelector("#ra-shadow-root").shadowRoot'

 shadow= control_in_shadow(driver,js)

 shadow.host

 shadow.mode

 shadow.innerHTML</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">测试结果如下：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="64" src="https://images2.imgbox.com/01/94/YAtcG88B_o.png" width="735"></p> 
<p style="margin-left:.0001pt;text-align:justify;">可以看出返回的shadow对象已经不是一个shadowRoot元素，所以也不<span style="color:#fe2c24;">能使用他的一些属性</span>，包括上述代码的.find_element(By.Id)方法了。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">解决bug的尝试：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">这里我们可以看到直接用driver.execute_script()返回值不能再进行页面的一些操作了，但是在代码里运行js语言依然没有问题，所以我们想到的解决办法就是<span style="background-color:#fbd4d0;">直接书写JS语言在Python代码中运行</span>。比如上述的几个属性可以通过下面的代码得到返回值。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<pre><code class="language-python">​def control_in_shadow(driver,js):

    shadow = driver.execute_script(js)

    return shadow #返回的对象在这里

js = 'return document.querySelector("#ra-shadow-root").shadowRoot'

shadow= control_in_shadow(driver,js)

js1 = 'return document.querySelector("#ra-shadow-root").shadowRoot.host'

js2 = 'return document.querySelector("#ra-shadow-root").shadowRoot.mode'

js3 = 'return document.querySelector("#ra-shadow-root").shadowRoot.innerHTML'

host_res =  control_in_shadow(driver,js1)

mode_res = control_in_shadow(driver,js2)

inner_HTML_res = control_in_shadow(driver,js3)

print(host_res)

print(mode_res)

print(inner_HTML_res)

​</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">解决测试的运行结果：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="103" src="https://images2.imgbox.com/95/cc/hMMe8Ay4_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;">可以看出通过直接运行JS可以成功的找到所有的属性返回值，以及访问到宿主节点的IP为一个web element对象。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>代码修复：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">根据以上的探索，我们可以知道可以通过直接在Python中运行JS语句实现成功的访问shadow Dom里面的元素。基于此我们可以把原始代码修改如下(原始代码不需要的行已经注释起来了):</p> 
<pre><code class="language-python">​
def control_in_shadow(driver,js):

    shadow = driver.execute_script(js)

    return shadow #返回的对象在这里

js1 = 'return document.querySelector("#ra-shadow-root").shadowRoot.getElementById("ra-asin-list-count-input")'

#shadow= control_in_shadow(driver,js)

input_id = control_in_shadow(driver,js1)

input_id.clear()

input_id.send_keys('1000')

       

#shadow.find_element(By.ID,'ra-asin-list-count-input').clear()

#shadow.find_element(By.ID,'ra-asin-list-count-input').send_keys('1000')

#shadow.find_element(By.ID,'ra-asin-list-load-btn').click()

js2 = 'document.querySelector("#ra-shadow-root").shadowRoot.getElementById("ra-asin-list-load-btn").click()'

load_id = control_in_shadow(driver,js2)

load_id

js3 = 'return document.querySelector("#ra-shadow-root").shadowRoot.getElementById("ra-asin-list-csv-btn")'

  save_id = control_in_shadow(driver,js3)

​</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">上面的代码运行起来就没有问题了。而且这是通过直接操作JS语句的，速度上也是可以的。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>初始代码展示：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">以下为整段代码（可能稍微有点长）。后续有机会可以和大家分享下面代码的编写的逻辑。</p> 
<pre><code class="language-python">import pandas as pd

import numpy as np

import os



from selenium import webdriver

from selenium.webdriver.chrome.service import Service

from selenium.webdriver.chrome.options import Options

from selenium.webdriver.common.by import By

from selenium.webdriver.common.action_chains import ActionChains

from selenium.webdriver.support.ui import WebDriverWait

from selenium.webdriver.support.wait import WebDriverWait

from selenium.webdriver.support import expected_conditions as EC



import selenium.common.exceptions

import requests

import time

import json

import mitmproxy

import pyautogui



def open_chrome_driver(option):

    driver = webdriver.Chrome(options = option)

    return driver



def open_new_window(driver,url):

    new = 'window.open(%s)'%url

    driver.execute_script(new)

    handles = driver.window_handles

    driver.switch_to.window(handles[-1])

    return driver

   

def open_url(driver,url):

    driver.get(url)



def wait_by_clickable(driver,wait_time,ID):

    wait = WebDriverWait(driver,wait_time)

    wait_name = wait.until(EC.element_to_be_clickable(driver.find_element(By.ID,ID)))

    return wait_name



def wait_by_presence(driver,wait_time,ID):

    wait = WebDriverWait(driver,wait_time)

    wait_name = wait.until(EC.presence_of_element_located((By.ID,ID)))

    return wait_name

   

def keyboard_perform(driver,ID):

    logo = driver.find_element(By.ID,ID)

    rightClick = ActionChains(driver)

    rightClick.context_click(logo).perform()

    time.sleep(4)

   

    pyautogui.typewrite(['down','down','down','down','down','down','down','down','down'])

    time.sleep(4)

   

    pyautogui.typewrite(['enter'])

    time.sleep(5)

    pyautogui.typewrite(['enter'])

    time.sleep(5)

   

def control_in_shadow(driver,js):

    shadow = driver.execute_script(js)

    return shadow



def find_key_words(file_name):

    pecos = pd.read_excel(file_name)

    key_words = list(pecos.loc[:,'title'])

    print(key_words)

    return key_words



def find_index(list,element):

    for i in range (0,len(list)):

        if list[i] == element:

            return i

        else:

            pass

   

def concatenate_file(path):

    os.chdir(r'%s./Peco_File_Download'%path)

    filelist = []

    list_link=[]

    filelist2 = []

    key_content_list = []



    for root, dirs,files in os.walk(".",topdown = False):

        for name in files:

            str = os.path.join(root,name)

            if str.split('.')[-1] == 'csv':

                filelist.append(str)

   

    for each_file in filelist:

        name = each_file.split('\\')[1]

        filelist2.append(name)

        key = name.split('-ASIN')[0]

        key_content_list.append(key)



    for each_range in range(len(filelist2)):

        list_count = pd.read_csv(r'%s'%filelist2[each_range])

        list_link.append(list_count)

       

    for each_file in filelist:

        inx = find_index(filelist,each_file)

        current_list = list_link[inx]

        current_list['key_words'] = key_content_list[inx]

       

    df1 = pd.concat(list_link,ignore_index = True)

    df2 = df1[['asin','key_words']]

    df2.to_csv('合并后的表格.csv')

   

def find_one_B_one(keywords,final_sleep_time):

    #open_existed_chrome_option

    option = webdriver.ChromeOptions()

    option.add_experimental_option("debuggerAddress","127.0.0.1:9999")

    driver = open_chrome_driver(option)

    for i in keywords:

        url = "https://www.amazon.com/"

        open_url(driver,url)

       

        #search&amp;submit keywords

        search_box = wait_by_clickable(driver,1200,'twotabsearchtextbox')

        search_box

       

        search_box.send_keys(i)

   

        submit_button = wait_by_clickable(driver,1200,'nav-search-submit-button')

        submit_button

        submit_button.click()

        time.sleep(0.01)



        #retail_assistance

        keyboard_perform(driver,'nav-search-submit-button')

        shadow_root = wait_by_presence(driver,1200,'ra-shadow-root')

        shadow_root

        time.sleep(4)



        js = 'return document.querySelector("#ra-shadow-root").shadowRoot'

        shadow= control_in_shadow(driver,js)



        shadow.find_element(By.ID,'ra-asin-list-count-input').clear()

        shadow.find_element(By.ID,'ra-asin-list-count-input').send_keys('1000')

        shadow.find_element(By.ID,'ra-asin-list-load-btn').click()

        time.sleep(final_sleep_time)

       

        wait = WebDriverWait(driver,4000)

        tag = shadow.find_element(By.ID,'ra-asin-list-csv-btn')

        save_button = wait.until(EC.element_to_be_clickable(tag))

        save_button

        time.sleep(4)

        save_button.click()

        time.sleep(4)



if __name__ == "__main__":

    path = os.getcwd()

    wait_sleep_time = int(input('请输入您需要等待pecos load的时长/second:'))

    keywords = find_key_words('PECO Keywords.xlsx')

    find_one_B_one(keywords,wait_sleep_time)

    #concatenate_file(path)</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd4117e8be888f06b038b6b532e915da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">filter的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/960f747fd1aaec04f57e66b49ec536c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于js变量声明的几种方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>