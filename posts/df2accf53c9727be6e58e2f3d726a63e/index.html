<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LVS的介绍与使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LVS的介绍与使用" />
<meta property="og:description" content="LVS负载均衡 1.LVS服务简述 1.1lvs服务简介 ​ LVS（Linux Virtual Server）即Linux虚拟服务器，是一个虚拟的服务器集群系统，该项目是1998年5月由章文嵩博士主导的开源负载均衡项目，是国内最早出现的自由软件项目之一。目前 LVS 已经被集成到Linux内核模块中。
​ 通过LVS的负载均衡技术和LINUX操作系统可以实现一个高性能、高可用的LINUX服务器集群，它具有良好的可靠性、可扩展性和可操作性。LVS架构从逻辑上可分为调度层、Server集群层和共享存储层。
1.2LVS的发展与组成 1.IPVS(LVS)的发展史 ​ (1)在Linux2.2内核时，IPVS就已经以内核补丁的形式出现。
​ (2)从Linux2.4.24版本以后，IIPVS便成为Linux官方标准内核的一部分。
2.LVS的组成 LVS由两部分程序组成，即IPVS和IPVSADM。
​ IPVS:IP Virtual Server的缩写，其代码工作在系统内核空间，也是实现调度的代码段。
​ IPVSADM:工作在用户空间，负责为IPVS内核框架编写规则，定义谁是前端集群服务器，谁是后端真实服务器(Real Server)。
1.3.为什么需要LVS 简单来说，当并发连接数超过了Ngix的负载上限时，就需要使用LVS了。就目前实际环境来讲，日均页面访问量（pv）在1000万～2000万或并发量在5万以下时都可以使用Nginx。流量超过这个标准或一些大型的门户网站、电商平台也会使用LVS，这是因为它们的流量或并发量随时可能存在高峰时段，或者说可能在某个点会超过以往所有的流量峰值。
LVS与Nginx的功能对比如下。
(1)、LVS比Nginx具有更强的抗负载能力，性能比较高（能达到F5性能的60％左右），而且LVS工作在网络4层仅做请求分发之用，没有流量，所以在效率上基本不需要太过考虑，且对内存和CPU资源消耗比较低，只考验网卡或 linux2.4 内核的承载能力。
Nginx则工作在网络的应用层，可以针对HTTP应用实施一些分流策略。
(2)、LVS安装配置比较简单，对网络的依赖较大，但稳定性较高。Ngix安装配置相对复杂，对网络的依赖较小。
(3)、LVS不支持正则匹配处理，不能做动静态分离，而Ngx具有这方面的功能。
(4)、LVS适用的协议范围较广。Nginx仅能支持HTTP、HTTPS、Email协议，因此适用范围就大大缩小了。
(5)、基本上能支持所有应用，因为lvs工作在4层，所以它可以对几乎所有应用做负载均衡，包括httP、数据库、聊天室等等。
注：LVS 需要手工动态增加命令，所以需要 Keepalived 来实现自动配合。
常见负载均衡对比优势缺点硬件:F5性能好技术支持价格昂贵购买2台1对.Ivs工作四层效率极其高对数据做的转发负载 均衡在低数据量的效率不高，高效率需要在大数据量才体现(运维成本较高)nginx使用简单 支持4层(1.9版本后支持)和7层反 向代理缓存流量镜像处理数据代理模式替用户去查找找到后发送给用户并发 较大(5w以上)haproxy相对复杂支持4层和7层反向代理处理数据代理模式替用户去查找找到后发送给用户并发 较大(10w以上比nginx多) 14.需了解arp协议 arp解析过程
1.发出广播请求ip对应的mac地址是？Who has10.0.0.8?Tell10.0.0.7
2.发出响应单播告诉对方我的mac地址是xXXx
3.0.8发请请求询问0.7的mac地址单播
4.0.7把自己mac地址发送给.8
2、ipvsadm命令及参数介绍 部署和配置LVS服务会经常用到一些命令，如ipvsadm，可以使用“ipvsadm一help”命令查看使用帮助。
ipvsadm命令的常用参数及其说明如下。
参数说明-C清空配置列表-A增加虚拟vip服务-E编辑虚拟vip服务-D删除虚拟vip服务-a添加真实主机-e编辑真实主机配置-d删除真实主机配置-L显示详细列表信息-h显示帮助信息-s指定算法-g指定DR模式（默认的模式）-i指定TUN模式-m指定NAT模式-w指定权重参数-c查看连接数–timeout查看超时–daemon进程输出信息–states输出静态信息-n以数字形式输出信息 ipvsadm命令还有其他一些不常用的参数，可以访问官方网站了解。
LVS中文官网： http://zh.linuxvirtualserver.org/
1.3LVS相关的术语 在学习LVS服务时，首先要了解VS中相关的专业术语，以便更好地理解与掌握LVS服务。
LVS相关术语及其说明如下表。
术语说明DS (Director Server)前端负载均衡节点服务器RS (Real Server)后端真实服务器DIP (Director Server IP)用于与内部主机通信的IP地址VIP (Virtual IP)向外部直接面向用户请求，用于用户请求的目标IP地址RIP (Real Server IP)后端真实服务器的IP地址CIP (Client IP)访问客户端的IP地址 3、LVS的工作模式 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/df2accf53c9727be6e58e2f3d726a63e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-10T18:51:22+08:00" />
<meta property="article:modified_time" content="2023-01-10T18:51:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LVS的介绍与使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="LVS_0"></a>LVS负载均衡</h3> 
<h4><a id="1LVS_2"></a>1.LVS服务简述</h4> 
<h5><a id="11lvs_4"></a>1.1lvs服务简介</h5> 
<p>​ LVS（Linux Virtual Server）即Linux虚拟服务器，是一个虚拟的服务器集群系统，该项目是1998年5月由章文嵩博士主导的开源负载均衡项目，是国内最早出现的自由软件项目之一。目前 LVS 已经被集成到Linux内核模块中。</p> 
<p>​ 通过LVS的负载均衡技术和LINUX操作系统可以实现一个高性能、高可用的LINUX服务器集群，它具有良好的可靠性、可扩展性和可操作性。LVS架构从逻辑上可分为调度层、Server集群层和共享存储层。</p> 
<h5><a id="12LVS_10"></a>1.2LVS的发展与组成</h5> 
<h6><a id="1IPVSLVS_12"></a>1.IPVS(LVS)的发展史</h6> 
<p>​ (1)在Linux2.2内核时，IPVS就已经以内核补丁的形式出现。</p> 
<p>​ (2)从Linux2.4.24版本以后，IIPVS便成为Linux官方标准内核的一部分。</p> 
<h6><a id="2LVS_18"></a>2.LVS的组成</h6> 
<p>LVS由两部分程序组成，即IPVS和IPVSADM。</p> 
<p>​ IPVS:IP Virtual Server的缩写，其代码工作在系统内核空间，也是实现调度的代码段。</p> 
<p>​ IPVSADM:工作在用户空间，负责为IPVS内核框架编写规则，定义谁是前端集群服务器，谁是后端真实服务器(Real Server)。</p> 
<h5><a id="_26"></a></h5> 
<h5><a id="13LVS_28"></a>1.3.为什么需要LVS</h5> 
<p>简单来说，当并发连接数超过了Ngix的负载上限时，就需要使用LVS了。就目前实际环境来讲，日均页面访问量（pv）在1000万～2000万或并发量在5万以下时都可以使用Nginx。流量超过这个标准或一些大型的门户网站、电商平台也会使用LVS，这是因为它们的流量或并发量随时可能存在高峰时段，或者说可能在某个点会超过以往所有的流量峰值。</p> 
<p>LVS与Nginx的功能对比如下。</p> 
<p>(1)、LVS比Nginx具有更强的抗负载能力，性能比较高（能达到F5性能的60％左右），而且LVS工作在网络4层仅做请求分发之用，没有流量，所以在效率上基本不需要太过考虑，且<font color="red">对内存和CPU资源消耗比较低，只考验网卡或 linux2.4 内核的承载能力。</font></p> 
<p>Nginx则工作在网络的应用层，可以针对HTTP应用实施一些分流策略。</p> 
<p>(2)、LVS安装配置比较简单，对网络的依赖较大，但稳定性较高。Ngix安装配置相对复杂，对网络的依赖较小。</p> 
<p>(3)、LVS不支持正则匹配处理，不能做动静态分离，而Ngx具有这方面的功能。</p> 
<p>(4)、LVS适用的协议范围较广。Nginx仅能支持HTTP、HTTPS、Email协议，因此适用范围就大大缩小了。</p> 
<p>(5)、基本上能支持所有应用，因为lvs工作在4层，所以它可以对几乎所有应用做负载均衡，包括httP、数据库、聊天室等等。<br> 注：LVS 需要手工动态增加命令，所以需要 Keepalived 来实现自动配合。</p> 
<table><thead><tr><th>常见负载均衡对比</th><th>优势</th><th>缺点</th></tr></thead><tbody><tr><td>硬件:F5</td><td>性能好技术支持</td><td>价格昂贵购买2台1对.</td></tr><tr><td>Ivs</td><td>工作四层效率极其高对数据做的转发负载 均衡</td><td>在低数据量的效率不高，高效率需要在大数据量才体现(运维成本较高)</td></tr><tr><td>nginx</td><td>使用简单 支持4层(1.9版本后支持)和7层反 向代理缓存流量镜像</td><td>处理数据代理模式替用户去查找找到后发送给用户并发 较大(5w以上)</td></tr><tr><td>haproxy</td><td>相对复杂支持4层和7层反向代理</td><td>处理数据代理模式替用户去查找找到后发送给用户并发 较大(10w以上比nginx多)</td></tr></tbody></table> 
<h5><a id="14arp_58"></a>14.需了解arp协议</h5> 
<p>arp解析过程</p> 
<p>1.发出广播请求ip对应的mac地址是？Who has10.0.0.8?Tell10.0.0.7</p> 
<p>2.发出响应单播告诉对方我的mac地址是xXXx</p> 
<p>3.0.8发请请求询问0.7的mac地址单播</p> 
<p>4.0.7把自己mac地址发送给.8</p> 
<h4><a id="2ipvsadm_76"></a>2、ipvsadm命令及参数介绍</h4> 
<p><img src="https://images2.imgbox.com/a2/48/roMLGJlt_o.png" alt="image-20221014031503150"></p> 
<p>部署和配置LVS服务会经常用到一些命令，如ipvsadm，可以使用“ipvsadm一help”命令查看使用帮助。</p> 
<p>ipvsadm命令的常用参数及其说明如下。</p> 
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-C</td><td>清空配置列表</td></tr><tr><td>-A</td><td>增加虚拟vip服务</td></tr><tr><td>-E</td><td>编辑虚拟vip服务</td></tr><tr><td>-D</td><td>删除虚拟vip服务</td></tr><tr><td>-a</td><td>添加真实主机</td></tr><tr><td>-e</td><td>编辑真实主机配置</td></tr><tr><td>-d</td><td>删除真实主机配置</td></tr><tr><td>-L</td><td>显示详细列表信息</td></tr><tr><td>-h</td><td>显示帮助信息</td></tr><tr><td>-s</td><td>指定算法</td></tr><tr><td>-g</td><td>指定DR模式（默认的模式）</td></tr><tr><td>-i</td><td>指定TUN模式</td></tr><tr><td>-m</td><td>指定NAT模式</td></tr><tr><td>-w</td><td>指定权重参数</td></tr><tr><td>-c</td><td>查看连接数</td></tr><tr><td>–timeout</td><td>查看超时</td></tr><tr><td>–daemon</td><td>进程输出信息</td></tr><tr><td>–states</td><td>输出静态信息</td></tr><tr><td>-n</td><td>以数字形式输出信息</td></tr></tbody></table> 
<p>ipvsadm命令还有其他一些不常用的参数，可以访问官方网站了解。</p> 
<p>LVS中文官网： http://zh.linuxvirtualserver.org/</p> 
<p><img src="https://images2.imgbox.com/24/d2/fovkTOyg_o.png" alt="image-20221014031621682"></p> 
<h5><a id="13LVS_120"></a>1.3LVS相关的术语</h5> 
<p>在学习LVS服务时，首先要了解VS中相关的专业术语，以便更好地理解与掌握LVS服务。</p> 
<p>LVS相关术语及其说明如下表。</p> 
<table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>DS (Director Server)</td><td>前端负载均衡节点服务器</td></tr><tr><td>RS (Real Server)</td><td>后端真实服务器</td></tr><tr><td>DIP (Director Server IP)</td><td>用于与内部主机通信的IP地址</td></tr><tr><td>VIP (Virtual IP)</td><td>向外部直接面向用户请求，用于用户请求的目标IP地址</td></tr><tr><td>RIP (Real Server IP)</td><td>后端真实服务器的IP地址</td></tr><tr><td>CIP (Client IP)</td><td>访问客户端的IP地址</td></tr></tbody></table> 
<h4><a id="3LVS_137"></a>3、LVS的工作模式</h4> 
<h5><a id="31_139"></a>3.1.网络地址转换模式</h5> 
<p>在网络地址转换(NAT)模式下，调度器(Lvs)改写请求报文中的目标地址（也可能改写目标端口），然后根据相关算法将请求分流至后端真实主机服务器(Real Server)，真实主机服务器响应请求报文后返回给调度器，再经过调度器重写报文的源地址，从而返回给请求的客户端用户，完成整个数据请求传输过程。</p> 
<p>LVS网络地址转换模式的逻辑架构如图18-1所示。</p> 
<p><img src="https://images2.imgbox.com/bd/7d/AEC3fK7F_o.jpg" alt=""></p> 
<h6><a id="311_149"></a>3.1.1.整个过程描述</h6> 
<p>(1)客户端发出请求的数据包（假定客户端CIP10.0.0.1:80是数据包源地址，目标地址是VIP:20.0.0.1:80)。</p> 
<p>(2)用户请求的数据经过调度器(LS)，目标的地址会被调度器改写成后端其中某个真实主机的地址（假定为RIPA:192.168.1.1:80)。</p> 
<p>(3)后端真实服务器收到请求数据后，对比发现目标地址是自己，响应并返回应答信息给调度器。<font color="red">此时源地址是RIP，目标地址是VIP</font>。</p> 
<p>(4)调度器收到后端服务器请求后，将源地址改写成VIP地址（实际地址是RIPA)，然后将数据返回给请求的客户端用户。</p> 
<p>(5)客户端收到返回的数据包，整个请求过程完成。</p> 
<h6><a id="312LVS_161"></a>3.1.2.LVS网络地址转换模式的特点</h6> 
<p>(I)后端真实主机使用私有地址，但网关必须指向DIP，且DIP和RIP必须在同一网段内。</p> 
<p>(2)请求和返回的数据报文都需要过LS主机，在高负载场景中，LS主机很容易成为全局的性能瓶颈。一般来说，DS主机支持20台左右的服务器节点。</p> 
<p>(3)支持端口映射，且后端RS主机可以使用任意的操作系统，比较灵活。</p> 
<h6><a id="313LVSNAT_173"></a>3.1.3.LVS服务NAT模式部署</h6> 
<p>LVS服务NAT模式部署的操作步骤如下。</p> 
<p>1.服务器环境准备服务器规划。</p> 
<p>1，服务器环境准备</p> 
<table><thead><tr><th>服务器角色</th><th>服务器1P地址</th><th>备注</th></tr></thead><tbody><tr><td>LVS</td><td>ens33:192.168.245.165</td><td>VIP:192.168.245.165对外服务</td></tr><tr><td></td><td>ens37:10.0.0.2(内网地址)</td><td></td></tr><tr><td>RS节点A</td><td>ens37:10.0.0.3(内网地址)</td><td>网关指向10.0.0.2</td></tr><tr><td>RS节点B</td><td>cns37:10.0.0.4(内网地址)</td><td>网关指向10.0.0.2</td></tr></tbody></table> 
<p>2.部署后端服务器</p> 
<p>略</p> 
<h5><a id="32_200"></a>3.2.隧道模式</h5> 
<p>隧道(Tunneling，TUN)模式是调度器(LB）在收到客户端请求后，将报文通过IP隧道转发至后端真实主机服务器，这样调度器就只需要处理用户请求的入站报文。此模式对提高访问效率起着很大的作用。</p> 
<p>LVS隧道模式的逻辑架构如图18-2所示。</p> 
<p><img src="https://images2.imgbox.com/95/fc/5WNGf2ZZ_o.jpg" alt=""></p> 
<h6><a id="321_210"></a>3.2.1.整个过程描述</h6> 
<p>(1)客户端发出请求数据包（假定源地址是客户端CIP:10.0.0.1:80，目标地址是VIP:20.0.0.1:80)。</p> 
<p>(2)用户请求数据报文到达调度器后，调度器将数据报文重新封装成另一个IP包（源地址、目标地址不变，只是增加了一个IP头)，然后通过IP隧道转发至后端真实主机服务器。</p> 
<p>(3)后端真实服务器收到数据包后进行解包操作，最终发现目标地址不是自己，而是绑定在lo接口上的VIP地址（所以需要先绑定VIP地址），此时真实服务器开始处理请求，处理完成后，通过lo接口将数据传递给真实服务器的出接口，最终再向外传递（此时源地址是VIP，目标地址是CIP)。</p> 
<p>(4)客户端收到返回的信息，完成整个过程。</p> 
<h6><a id="322LVS_220"></a>3.2.2.LVS隧道模式的特点</h6> 
<p>(1)后端服务器RIP，绑定的VIP、DIP必须是公网地址，且后端服务器的网关不指向DIP，</p> 
<p>(2)所有的客户端请求数据报文都经过调度器，但响应返回的数据不必经过调度器：</p> 
<p>(3)不支持端口映射，且后端RS主机的系统必须要支持隧道协议。</p> 
<p>注意：此模式存在弊端：那就是此模式后端服务器都器要定一个相同的VIP地址。用户请求的数据包经转发到达内网后，内网会有多台主机服务器回应此数据包请求，而用户端收到的是最快回应的内网后端主机返回的数据，这样看来数据包没有经过调度器，那么所谓的负数均衡也就不存在了。所以，内网后端主机需要做抑制ARP的配置，使所有的后端主机服务器不再响应目标地址是VIP的请求，而是由调度器来响应用户端的这类请求，从而达到负载均衡的目的，一般在实标生产环境中，这个款式派少使用。</p> 
<h6><a id="323LVSTUN_232"></a>3.2.3.LVS服务TUN模式部署</h6> 
<p>略</p> 
<h5><a id="33_242"></a>3.3.直接路由模式</h5> 
<p>直接路由(Direct Routing，DR)模式通过改写请示报文中的目标MAC地址（将请求报文中的目标MAC改写成后端某台RS主机的MAC)，将请求发到后端真实主机服务器，而真实主机服务器响应后的数据直接返回给请求的客户端。此模式要求调度器与真实主机服务器要有一块网卡是连接在同一网段中的。</p> 
<p>LVS直接路由模式的逻辑架构如图18-3所示。</p> 
<p><img src="https://images2.imgbox.com/4a/72/QPb6SvFa_o.jpg" alt=""></p> 
<h6><a id="331_252"></a>3.3.1.整个过程描述</h6> 
<p>(1)客户端发出请求的数据包（假定客户端CP10.0.0.1:80是数据包源地址，目标地址是VP:20.0.0.1:80)。</p> 
<p>(2)LVS调度器接收到请求数据包后，不转换其地址及端口，也不进行重新封装操作，只是将请求数据报文中的源MAC地址改写成DIP的MAC地址，将目标的MAC地址改写成RIP的MAC地址，但此时的源IP和目标IP是不改变的，然后将数据包转发出去</p> 
<p>3)后端真实主机服务器收到数据包，发现目标的MAC地址是自己，继续解包发现目标IP是VIP(事先在本机lo端口绑定VIP，开启抑制ARP功能)，从而接收数据报文信息进行处理，处理完成后通过L0接口传递给外网口，再向外发送。这样真实主机服务器是直接对客户端的请求做出响应并回复的。</p> 
<p>(4)客户端收到回复的数据包，整个过程完成。</p> 
<h6><a id="332LVS_264"></a>3.3.2.LVS直接路由模式的特点</h6> 
<p>lvs dr模式中lvs只负责转发并修改用户的目标lP的mac地址dmac</p> 
<p>lvs dr模式中服务端给用户的响应是通过后端rs服务器处理，直接响应给用户.不再通过lvs</p> 
<p>lvs vip公网ip，rs服务器也要有公网ip</p> 
<p>优势</p> 
<p>lvs dr支持更高并发（几十万几百万）nginx(几万)</p> 
<p>局限性</p> 
<p>lvs和后端rs服务器，必须要在同1个局域网，涉及到rp解析</p> 
<p>用户请求过来的端口无法修改的.用户的请求是什么端口后端S服务器就要开端口</p> 
<p>lvs dr模式需要vs服务器进行配置，同时还要在后端rs服务端<strong>lo网卡绑定vip，抑制arp解析(每一台)</strong></p> 
<h6><a id="333DR_286"></a>3.3.3.服务DR模式部署</h6> 
<p>LVS服务DR模式部署的操作步骤如下。</p> 
<h6><a id="1_290"></a>1.服务器环境准备服务器规划。</h6> 
<table><thead><tr><th>服务器角色</th><th>服务器IP地址</th><th>备注</th></tr></thead><tbody><tr><td>LVS</td><td>192.168.245.165</td><td>lvs</td></tr><tr><td>vip（反向代理）</td><td>192.168.245.166</td><td>vip</td></tr><tr><td>web01</td><td>192.168.245.167</td><td>nginx1</td></tr><tr><td>web02</td><td>192.168.245.168</td><td>nginx2</td></tr></tbody></table> 
<h6><a id="2_301"></a>2.部署后端服务器</h6> 
<p>后端web01和web02安装nginx服务，启动服务并检查，操作如下。</p> 
<pre><code>[root@web01 ~]# cat /etc/nginx/conf/vhost/web01.conf
server {
	listen 80;
	server_name localhost;
	root /code/lvs;
	location / {
	index index.html;
	}
}

[root@web01 ~]# mkdir /code/lvs
[root@web01 ~]# echo lvs `hostname` `hostname -I ` &gt;/code/lvs/index.html

#复制配置文件和首页文件到web02上
</code></pre> 
<h6><a id="3_324"></a>3.反向代理</h6> 
<pre><code>[root@web01 ~]# cat /etc/nginx/conf/nginx.conf

upstream web_pools {
server 192.168.245.167:80;
server 192.168.245.168:80;
}

server {
		listen 80;
        server_name  localhost;
location / {
proxy_pass http://web_pools;

}
}
</code></pre> 
<h6><a id="4dns_344"></a>4.修改宿主机本地dns文件</h6> 
<p><img src="https://images2.imgbox.com/3a/cc/zTGkGeVY_o.png" alt="image-20221014150155717"></p> 
<h6><a id="5LVS_354"></a>5.部署LVS软件</h6> 
<p>安装之前查看下内核是否有加载lvs</p> 
<p>[root@LVS ~]# lsmod |grep ip_vs</p> 
<p>安装软件包</p> 
<p>[root@LVS ~]# yum install -y ipvsadm</p> 
<p>#查看软件包内容</p> 
<p>[root@LVS ~]# rpm -ql ipvsadm</p> 
<p>/etc/sysconfig/ipvsadm-config</p> 
<p>/usr/lib/systemd/system/ipvsadm.service</p> 
<p>/usr/sbin/ipvsadm #管理lvs规则ip_vs</p> 
<p>/usr/sbin/ipvsadm-festore #恢复从文件中恢复lvs规则</p> 
<p>/usr/sbin/ipvsadm-save #保存lvs规则</p> 
<p>systemctl cat ipvsadm</p> 
<p>[root@LVS ~]# ipvsadm -ln</p> 
<pre><code>IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
</code></pre> 
<h6><a id="6LVS_DR_392"></a>6.配置LVS DR模式负载均衡</h6> 
<p>(1)LVS服务器配置VIP地址，对外提供服务。</p> 
<p>临时配置</p> 
<p>[root@LVS ~]# ifconfig ens33:250 192.168.245.166/24</p> 
<p>[root@LVS ~]# ifconfig ens33:250</p> 
<p>(2)配置LVS服务，过程如下。</p> 
<p>[root@LVS ~]# ipvsadm -C #清空原来的所有配置</p> 
<p>[root＠LVS～]# ipvsadm -A -t 192.168.245.166:80 -s wrr #配置VIP与调度算法</p> 
<p>[root＠LVS～]# ipvsadm -ln #查看配置</p> 
<p>截图</p> 
<p>(3)添加后端真实主机服务器。</p> 
<p>[root@LVS~]#ipvsadm -a -t 192.168.245.166:80 -r 192.168.245.167 -g -w 1 #注意-p参数</p> 
<p>[root@LVS~]#ipvsadm -a -t 192.168.245.166:80 -r 192.168.245.168 -g -w 1</p> 
<p>[root@LVS ~]# ipvsadm -ln</p> 
<pre><code>IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.245.166:80 wrr
  -&gt; 192.168.245.167:80           Route   1      0          0         
  -&gt; 192.168.245.168:80           Route   1      0          0 
</code></pre> 
<h6><a id="7ARPIP_439"></a>7.后端服务器配置抑制ARP功能与绑定IP地址</h6> 
<p>绑定IP地址</p> 
<p>临时配置</p> 
<p>[root@web01 ~]# ifconfig lo:250 192.168.245.166/32</p> 
<p>[root@web01 ~]# ifconfig lo:250</p> 
<p>永久配置</p> 
<pre><code>[root@web02 network-scripts]# cd /etc/sysconfig/network-scripts
[root@web02 network-scripts]# cp ifcfg-lo ifcfg-lo:1
[root@web02 network-scripts]# vim ifcfg-lo:1
DEVICE=lo:1
IPADDR=192.168.245.166
NETMASK=255.255.255.255
# If you're having problems with gated making 127.0.0.0/8 a martian,
# you can change this to something else (255.255.255.255, for example)
#BROADCAST=127.255.255.255
ONBOOT=yes
NAME=loopback

复制
[root@web02 network-scripts]# scp ./ifcfg-lo:1 192.168.245.167:/etc/sysconfig/network-scripts
</code></pre> 
<pre><code>#抑制arp解析
方法1：
cat &gt;&gt;/etc/sysctl.conf&lt;&lt;EOF
net.ipv4.conf.all.arp_ignore=1
net.ipv4.conf.all.arp_announce=2
net.ipv4.conf.lo.arp_ignore=1
net.ipv4.conf.lo.arp_announce=2
EOF

sysctl -p

方法2：
echo  "1" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
echo  "2" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
echo  "1" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
echo  "2" &gt;/proc/sys/net/ipv4/conf/all/arp_announce
</code></pre> 
<p>注：</p> 
<p>arp_ignore为1：只响应目的IP地址为接收网卡上的本地地址的arp请求。</p> 
<p>arp_announce为2时：只向该网卡回应与该网段匹配的ARP报文。</p> 
<p>[root@web02 ~]# 重复上述操作</p> 
<h6><a id="8_501"></a>8.测试</h6> 
<p>1.尽量不要在本地使用curl命令测试</p> 
<p>2.lvs应对高并发负载均衡，访问是比较少时，并不能像nginx那样1：1轮询</p> 
<p><img src="https://images2.imgbox.com/bf/00/qRrh9yx1_o.png" alt="image-20221014150025049"></p> 
<p>连续点击不会实现连续跳转，需隔几分钟再点才会出现跳转</p> 
<p><img src="https://images2.imgbox.com/a9/ab/It5KOFoJ_o.png" alt="image-20221014150123018"></p> 
<h6><a id="9lvskeepalived_521"></a>9.lvs与keepalived配合</h6> 
<p>1.服务器环境准备服务器规划。</p> 
<table><thead><tr><th>服务器角色</th><th>服务器IP地址</th><th>备注</th></tr></thead><tbody><tr><td>lvs1（反向代理1）</td><td>192.168.245.165</td><td>lvs,keepalived</td></tr><tr><td>vip</td><td>192.168.245.166</td><td>vip</td></tr><tr><td>lvs2（反向代理2）</td><td>192.168.245.169</td><td>keepalived</td></tr><tr><td>web01</td><td>192.168.245.167</td><td>nginx1</td></tr><tr><td>web02</td><td>192.168.245.168</td><td>nginx</td></tr></tbody></table> 
<p>修改keepalived配置文件</p> 
<p>[root@lvs2 keepalived]# cp keepalived.conf keepalived.conf.bak</p> 
<pre><code>! Configuration File for keepalived

global_defs {
   router_id LVS2	#keepalived身份id,每个keepalived不同
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}
	
vrrp_instance VI_1 {		#实例名称	在同1对主备之间要一致
    state MASTER			#指定Keepalived的角色，MASTER为主，BACKUP为备
    interface ens33			#指定网卡
    virtual_router_id 51	#虚拟路由编号，主备要一致
    priority 100			#优先级主＞备相差50
    advert_int 1			#检查间隔，默认为1s
    authentication {		#这里配置的密码最多为8位，主备要一致，否则无法正常通讯
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.245.166		#定义虚拟IP(VIP)，可多设，每行一个
    }
}


# 定义对外提供服务的LVS的VIP以及port
virtual_server 192.168.245.166 80 {
    delay_loop 6			# 设置健康检查时间，单位是秒
    lb_algo rr				# 设置负载调度的算法为rr
    lb_kind DR				# 设置LVS实现负载的机制，有NAT、TUN、DR三个模式
    persistence_timeout 0	# 会话保持时间
    protocol TCP			# 使用tcp协议
    nat_mask 255.255.255.0	# vip对应的子网掩码
    
    # 指定real server1的IP地址
    real_server 192.168.245.167 80 {
        weight 1
            TCP_CHECK {
	    connect_port 80
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
        }
    }
    
    # 指定real server2的IP地址
    real_server 192.168.245.168 80 {
        weight 1
            TCP_CHECK {				#安全检查
            connect_port 80
            connect_timeout 3		#连接超时为3秒
            nb_get_retry 3			#重试的次数为3次
            delay_before_retry 3	##每次检查之前等待3秒
        }
    }


}

复制keepalived配置文件到lvs1上
[root@lvs2 keepalived]# scp keepalived.conf 192.168.245.165:/etc/keepalived/
[root@lvs1 keepalived]# vim /etc/keepalived/keepalived.conf
只需修改：
router_id LVS1
state BACKUP
interface ens33
virtual_router_id 51
priority 50

测试：
[root@web02 ~]# nginx -s stop						#真实服务器服务一关闭，lvs就会去掉规则
[root@lvs1 keepalived]# ipvsadm -ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.245.166:80 wrr
  -&gt; 192.168.245.167:80           Route   1      0          0         

[root@web02 ~]# nginx						
[root@lvs1 keepalived]# ipvsadm -ln			#真实服务器服务启动，lvs就会添加规则
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.245.166:80 wrr
  -&gt; 192.168.245.167:80           Route   1      0          0         
  -&gt; 192.168.245.168:80           Route   1      0          0  
</code></pre> 
<p>LVS三种模式优缺点对比</p> 
<p>https://blog.csdn.net/qq_39376481/article/details/89506321</p> 
<h5><a id="34Full_NAT_641"></a>3.4.Full NAT模式</h5> 
<p>Full NAT模式针对上述3种模式的缺点而设计，使真实服务器能够跨越VLAN进行通信，只需要连接到内网网络即可。此模式是LVS在淘宝环境中的应用。</p> 
<p>Full NAT模式的逻辑架构如图18-4所示。</p> 
<p><img src="https://images2.imgbox.com/46/36/lBnLouxX_o.jpg" alt=""></p> 
<p>此模式过程描述如下。</p> 
<p>(1)入站时，目标IP更改成后端真实服务器的IP，源IP更改成内网本地的IP。</p> 
<p>(2)出站时，目标IP更改成客户端的IP地址，而源IP则更改成VIP地址。</p> 
<p>Full NAT模式主要是把网关和其他的机器通信更改成一般普通类的网络通信，从而解决前面无法跨越VLAN的问题。使用这种模式，LVS和RS的安装部署在VLAN中将不再受任何限制，提高了部署与运维的便捷度。</p> 
<h4><a id="4LVS_661"></a>4、LVS调度算法</h4> 
<p>LVS的强大功能也来自于共调度算法，VS调度算法决定了如何在后端集群节点之间分流负载压力，从而提升用户体验。</p> 
<p>常用的VS的调度算法有以下10种，下面将逐一对其进行介绍。</p> 
<h5><a id="1RR_667"></a>1.轮询(RR)</h5> 
<p>轮询算法是最简单的。轮询调度按照依次交替循环的方式将用户请求转发到后端不同的服务器上，调度器会将所有的请求平均分配给后端的每个主机服务器。这种算法比较适用于集群中各个节点的处理能力均衡的情况。</p> 
<h5><a id="2WRR_671"></a>2.加权轮询(WRR)</h5> 
<p>加权轮询算法是在轮询算法的基础之上增加了一个权重的概念，就是给后端服务器配置权重，权重越高，调度器分配给它的请求就越多，权重的取值范围为0～100。这种算法相当于是对轮询调度算法的一种优化，这样前端的调度器会在分发请求时考虑到服务器的性能，性能高的权重值高，性能低的权重值低，同时也可以保证请求响应的及时性。</p> 
<h5><a id="3LC_675"></a>3.最少连接(LC)</h5> 
<p>最少连接算法最容易理解，就是调度器会根据后端服务器的连接数来决定将请求分发给哪一个服务器，同一时间内优先分发请求给连接数少的服务器。</p> 
<h5><a id="4WLC_679"></a>4.加权最少连接(WLC)</h5> 
<p>加权最少连接算法一般用于在集群系统中各服务器的性能相差较大的场景中，默认也是采用这种算法。调度器利用此算法来优化负载均衡各方面的性能，有较高权重值的服务器将承担较大的负载连接。调度器还可以自动获取后端服务器的真实负载情况，以便动态地调整其权重值。</p> 
<h5><a id="5LBLC_683"></a>5.基于局部性的最少连接(LBLC)</h5> 
<p>基于局部性的最少连接调度算法是针对目标P地址的负载均衡，多用于Cache（缓存）集群系统。<font color="red">该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器</font>，如果这台服务器的负载不高并有处理请求的能力，调度器就会分发请求到该服务器。若该服务器负载过高，没有处理能力，则调度器会继续选择其他的可用服务器来分发请求。</p> 
<h5><a id="6LBLCR_687"></a>6.复杂的基于局部性的最少连接(LBLCR)</h5> 
<p>复杂的基于局部性的最少连接调度算法也是针对目标P地址的负载均衡，主要用于Cache（缓存）集群系统。与基于局部性的最少连接算法不同，<font color="red">它需要维护从一个目标IP地址到一组服务器之间的映射关系。</font>该算法根据请求的目标P地址找出该目标地址对应的服务器组，按“最少连接”的规则从服务器组中选择出一台服务器，如果该服务器负载较小，则将请求分发到该服务器上；如果该服务器负载较大，则重新从集群服务器中按规则选择一台服务器，并将该服务器加入此服务器组中，然后将请求分发到该服务器上。这种算法可以减少单台服务器负载过高情况的发生次数。</p> 
<h5><a id="7DH_691"></a>7.目标地址散列调度(DH)</h5> 
<p>这种算法根据请求的目标IP地址，作为散列键(Hash Key)从静态分配的散列表中找出对应的服务器，如果该服务器负载不高，则将请求分发给该服务器，否则返回空。</p> 
<h5><a id="8SH_695"></a>8.源地址散列调度(SH)</h5> 
<p>这种算法根据请求的源IP地址，作为散列键(Hash Key)从静态分配的散列表中找出对应的服务器，如果该服务器负载不高，则将请求分发给该服务器，否则返回空。</p> 
<h5><a id="9SED_699"></a>9.最短延迟调度(SED)</h5> 
<p>最短延迟调度算法是在加权最少连接的基础上改进的，Overhead = (ACTIVE+1)* 256/权重，不再考虑非活动状态，把当前处于活动状态的数目+1来实现，数目最小的，接受下次请求，+1的目的是考虑加权时非活动连接过多的的缺陷：当权限过大时，会倒置空闲服务器一直处于无连接状态。</p> 
<h5><a id="10NQ_703"></a>10.永不排队/最少队列调度(NQ)</h5> 
<p><font color="red">如果有一台后端服务器的连接数为0，就将请求直接分配过去，不需要再进行SED运算，保证不会有一个主机很空闲</font>。在SED基础上无论加几，第二次一定将请求分发给下一个主机。不考虑非活动连接时才用NQ，SED要考虑活动状态连接。对于DNS的UDP，不需要考虑非活动连接，而htpd的处于保持状态的服务需要考虑非活动连接给服务器的压力。</p> 
<p><font color="red">注意：RR、WRR、DH、SH这4种算法称为LVS的静态调度算法，LC、WLC、LBLC、LBLCR、SED、NQ这6种算法称为LVS的动态调度算法。</font></p> 
<p>静态调度只根据算法进行调度选择，而没有考虑后端服务器实际的连接及负载情况；动态调度会根据后端服务器的实际连接及负载情况来分发请求。</p> 
<p>一般实际生产环境常用的调度算法有RR、WRR、LC、WLC，常用于HTTP、MySQL、Mail等服务中。</p> 
<p>要获取更多资料，参考LVS官方网站。</p> 
<p>求的源IP地址，作为散列键(Hash Key)从静态分配的散列表中找出对应的服务器，如果该服务器负载不高，则将请求分发给该服务器，否则返回空。</p> 
<h5><a id="9SED_719"></a>9.最短延迟调度(SED)</h5> 
<p>最短延迟调度算法是在加权最少连接的基础上改进的，Overhead = (ACTIVE+1)* 256/权重，不再考虑非活动状态，把当前处于活动状态的数目+1来实现，数目最小的，接受下次请求，+1的目的是考虑加权时非活动连接过多的的缺陷：当权限过大时，会倒置空闲服务器一直处于无连接状态。</p> 
<h5><a id="10NQ_723"></a>10.永不排队/最少队列调度(NQ)</h5> 
<p><font color="red">如果有一台后端服务器的连接数为0，就将请求直接分配过去，不需要再进行SED运算，保证不会有一个主机很空闲</font>。在SED基础上无论加几，第二次一定将请求分发给下一个主机。不考虑非活动连接时才用NQ，SED要考虑活动状态连接。对于DNS的UDP，不需要考虑非活动连接，而htpd的处于保持状态的服务需要考虑非活动连接给服务器的压力。</p> 
<p><font color="red">注意：RR、WRR、DH、SH这4种算法称为LVS的静态调度算法，LC、WLC、LBLC、LBLCR、SED、NQ这6种算法称为LVS的动态调度算法。</font></p> 
<p>静态调度只根据算法进行调度选择，而没有考虑后端服务器实际的连接及负载情况；动态调度会根据后端服务器的实际连接及负载情况来分发请求。</p> 
<p>一般实际生产环境常用的调度算法有RR、WRR、LC、WLC，常用于HTTP、MySQL、Mail等服务中。</p> 
<p>要获取更多资料，参考LVS官方网站。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f229a586bf8b463774aaae95abea701/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【简单粗暴】Python导入cv2包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e535bf64205cf8afebf827c17ae86dec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GITHUB设置代理——解决git clone下载过慢的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>