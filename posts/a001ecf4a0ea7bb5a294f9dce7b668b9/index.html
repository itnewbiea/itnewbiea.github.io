<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构OJ实验3-堆栈 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构OJ实验3-堆栈" />
<meta property="og:description" content="A. DS堆栈--逆序输出（STL栈使用） 题目描述 C&#43;&#43;中已经自带堆栈对象stack，无需编写堆栈操作的具体实现代码。
本题目主要帮助大家熟悉stack对象的使用，然后实现字符串的逆序输出
输入一个字符串，按字符按输入顺序压入堆栈，然后根据堆栈后进先出的特点，做逆序输出
stack类使用的参考代码
n包含头文件&lt;stack&gt;：#include &lt;stack&gt;
n创建一个堆栈对象s（注意stack是模板类）：stack &lt;char&gt; s;//堆栈的数据类型是字符型
n把一个字符ct压入堆栈：s.push(ct);
n把栈顶元素弹出：s.pop();
n获取栈顶元素，放入变量c2：c2 =s.top();
n判断堆栈是否空：s.empty()，如果为空则函数返回true，如果不空则返回false
输入 第一行输入t，表示有t个测试实例
第二起，每一行输入一个字符串，注意字符串不要包含空格
字符串的输入可以考虑一下代码：
#include &lt;string&gt;
int main()
{ string str;
Int len;
cin&gt;&gt;str; //把输入的字符串保存在变量str中
len = str.length() //获取输入字符串的长度
}
输出 每行逆序输出每一个字符串
样例查看模式 正常显示查看格式
输入样例1 2
abcdef
aabbcc
输出样例1 fedcba
ccbbaa
AC代码 #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main() { int t; cin &gt;&gt; t; while (t--) { string s; cin &gt;&gt; s; stack&lt;char&gt;st; for (int i = 0; i &lt; s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a001ecf4a0ea7bb5a294f9dce7b668b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T09:29:41+08:00" />
<meta property="article:modified_time" content="2024-01-01T09:29:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构OJ实验3-堆栈</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>A. DS堆栈--逆序输出（STL栈使用）</h3> 
<h4>题目描述</h4> 
<p>C++中已经自带堆栈对象stack，无需编写堆栈操作的具体实现代码。</p> 
<p>本题目主要帮助大家熟悉stack对象的使用，然后实现字符串的逆序输出</p> 
<p>输入一个字符串，按字符按输入顺序压入堆栈，然后根据堆栈后进先出的特点，做逆序输出</p> 
<p>stack类使用的参考代码</p> 
<p>n包含头文件&lt;stack&gt;：#include &lt;stack&gt;</p> 
<p>n创建一个堆栈对象s（注意stack是模板类）：stack &lt;char&gt;  s;//堆栈的数据类型是字符型</p> 
<p>n把一个字符ct压入堆栈：s.push(ct);</p> 
<p>n把栈顶元素弹出：s.pop();</p> 
<p>n获取栈顶元素，放入变量c2：c2 =s.top();</p> 
<p>n判断堆栈是否空：s.empty()，如果为空则函数返回true，如果不空则返回false</p> 
<h4>输入</h4> 
<p>第一行输入t，表示有t个测试实例<br> 第二起，每一行输入一个字符串，注意字符串不要包含空格</p> 
<p>字符串的输入可以考虑一下代码：</p> 
<p>#include &lt;string&gt;</p> 
<p>int main()</p> 
<p>{ string str;</p> 
<p>Int len;</p> 
<p>cin&gt;&gt;str; //把输入的字符串保存在变量str中</p> 
<p>len = str.length()  //获取输入字符串的长度</p> 
<p>}</p> 
<h4>输出</h4> 
<p>每行逆序输出每一个字符串</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>2<br> abcdef<br> aabbcc</p> 
<h4>输出样例1</h4> 
<p>fedcba<br> ccbbaa</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stack&gt;
using namespace std;
int main()
{
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		string s;
		cin &gt;&gt; s;
		stack&lt;char&gt;st;
		for (int i = 0; i &lt; s.size(); i++)
		{
			st.push(s[i]);
		}
		while(!st.empty())
		{
			cout &lt;&lt; st.top();
			st.pop();
		}
		cout &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
<h3>B. DS堆栈--行编辑</h3> 
<h4>题目描述</h4> 
<p>使用C++的STL堆栈对象，编写程序实现行编辑功能。行编辑功能是：当输入#字符，则执行退格操作；如果无字符可退就不操作，不会报错</p> 
<p>本程序默认不会显示#字符，所以连续输入多个#表示连续执行多次退格操作</p> 
<p>每输入一行字符打回车则表示字符串结束</p> 
<p>注意：必须使用堆栈实现，而且结果必须是正序输出</p> 
<h4>输入</h4> 
<p>第一行输入一个整数t，表示有t行字符串要输入<br> 第二行起输入一行字符串，共输入t行</p> 
<h4>输出</h4> 
<p>每行输出最终处理后的结果，如果一行输入的字符串经过处理后没有字符输出，则直接输出NULL</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1</h4> 
<p>4<br> chinaa#<br> sb#zb#u<br> ##shen###zhen###<br> chi##a#####</p> 
<h4>输出样例1</h4> 
<p>china<br> szu<br> sz<br> NULL</p> 
<h4>输入样例2 </h4> 
<p>1<br> ###############################################################################################</p> 
<h4>输出样例2</h4> 
<p>NULL</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stack&gt;
using namespace std;
int main()
{
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		string s;
		cin &gt;&gt; s;
		stack&lt;char&gt;st;
		for (int i = 0; i &lt; s.size(); i++)
		{
			if (s[i] != '#')st.push(s[i]);
			else
			{
				if (!st.empty())
				{
					st.pop();
				}
			}
		}
		stack&lt;char&gt;ans;
		while(!st.empty())
		{
			ans.push( st.top());
			st.pop();
		}
		if (ans.empty())
		{
			cout &lt;&lt; "NULL" &lt;&lt; endl;
		}
		else
		{
			while (!ans.empty())
			{
				cout &lt;&lt; ans.top();
				ans.pop();
			}
			cout &lt;&lt; endl;
		}
	}
	return 0;
}</code></pre> 
<h3>C. DS堆栈--迷宫求解</h3> 
<h4>题目描述</h4> 
<p>给出一个N*N的迷宫矩阵示意图，从起点[0,0]出发，寻找路径到达终点[N-1, N-1]</p> 
<p>要求使用堆栈对象来实现，具体算法参考课本3.2.4节51页</p> 
<h4>输入</h4> 
<p>第一行输入t，表示有t个迷宫</p> 
<p>第二行输入n，表示第一个迷宫有n行n列</p> 
<p>第三行起，输入迷宫每一行的每个方格的状态，0表示可通过，1表示不可通过</p> 
<p>输入n行</p> 
<p>以此类推输入下一个迷宫</p> 
<h4>输出</h4> 
<p>逐个输出迷宫的路径</p> 
<p>如果迷宫不存在路径，则输出no path并回车</p> 
<p>如果迷宫存在路径，将路径中每个方格的x和y坐标输出，从起点到终点，每输出四个方格就换行，最终以单词END结尾，具体格式参考示范数据</p> 
<p>输出的代码参考如下：</p> 
<p>//path是保存路径的堆栈，堆栈中每个元素都包含x坐标和y坐标，用属性xp和yp表示</p> 
<p>//path1是一个临时堆栈，把path的数据倒序输出到path1，使得路径按正序输出</p> 
<p>if (!path.empty())//找到路径</p> 
<p>{//......若干代码，实现path的数据导入path1</p> 
<p>i=0;  //以下是输出路径的代码</p> 
<p>while (!path1.empty())</p> 
<p>{cpos = path1.top();</p> 
<p>if ( (++i)%4 == 0 )</p> 
<p>cout&lt;&lt;'['&lt;&lt;cpos.xp&lt;&lt;','&lt;&lt;cpos.yp&lt;&lt;']'&lt;&lt;"--"&lt;&lt;endl;</p> 
<p>else</p> 
<p>cout&lt;&lt;'['&lt;&lt;cpos.xp&lt;&lt;','&lt;&lt;cpos.yp&lt;&lt;']'&lt;&lt;"--";</p> 
<p>path1.pop();</p> 
<p>}</p> 
<p>cout&lt;&lt;"END"&lt;&lt;endl;</p> 
<p>}</p> 
<p>else</p> 
<p>cout&lt;&lt;"no path"&lt;&lt;endl; //找不到路径输出no path</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>2<br> 8<br> 0 0 0 1 1 1 1 1<br> 1 0 0 0 1 0 0 1<br> 1 0 0 0 1 0 0 0<br> 1 1 0 0 0 0 0 1<br> 0 0 1 1 0 1 1 0<br> 0 0 0 0 0 0 1 1<br> 1 1 1 1 1 0 0 1<br> 0 0 0 0 1 0 0 0<br> 7<br> 0 0 0 1 1 1 1<br> 1 0 0 1 0 0 1<br> 1 0 0 1 0 0 0<br> 1 1 0 0 0 0 1<br> 0 0 1 1 0 1 0<br> 1 0 0 0 0 1 0<br> 0 0 0 0 1 1 0</p> 
<h4>输出样例1</h4> 
<p>[0,0]--[0,1]--[0,2]--[1,2]--<br> [1,3]--[2,3]--[3,3]--[3,4]--<br> [4,4]--[5,4]--[5,5]--[6,5]--<br> [6,6]--[7,6]--[7,7]--END<br> no path</p> 
<h4>输入样例2 </h4> 
<p>2<br> 12<br> 0 1 1 1 1 1 1 1 1 1 1 0<br> 0 0 0 0 0 0 0 0 0 0 0 1<br> 0 1 1 1 1 0 1 1 1 1 0 1<br> 1 0 0 0 0 0 0 0 0 0 0 1<br> 0 0 1 1 1 1 0 1 0 1 1 0<br> 0 1 1 1 1 1 1 1 1 1 0 0<br> 0 0 0 0 0 0 0 0 0 0 0 1<br> 1 1 1 1 0 1 1 1 1 1 0 1<br> 1 1 1 1 1 0 1 1 1 1 0 1<br> 1 1 1 1 1 0 0 0 0 0 0 0<br> 1 1 1 1 1 1 1 1 0 1 1 1<br> 0 1 0 1 0 1 0 1 0 0 0 0<br> 12<br> 0 1 1 1 1 1 1 1 1 1 1 0<br> 0 0 0 0 0 0 0 0 0 0 0 1<br> 0 1 1 1 1 0 1 1 1 1 0 1<br> 1 0 0 0 0 0 0 0 0 0 0 1<br> 0 0 1 1 1 1 0 1 0 1 1 0<br> 0 1 1 1 1 1 1 1 1 1 0 0<br> 0 0 0 0 0 0 0 0 0 0 1 1<br> 1 1 1 1 0 1 1 1 1 1 0 1<br> 1 1 1 1 1 0 1 1 1 1 0 1<br> 1 1 1 1 1 0 0 0 0 0 0 0<br> 1 1 1 1 1 1 1 1 0 1 1 1<br> 0 1 0 1 0 1 0 1 0 0 0 0</p> 
<h4>输出样例2</h4> 
<p>[0,0]--[1,0]--[1,1]--[1,2]--<br> [1,3]--[1,4]--[1,5]--[1,6]--<br> [1,7]--[1,8]--[1,9]--[1,10]--<br> [2,10]--[3,10]--[3,9]--[3,8]--<br> [3,7]--[3,6]--[3,5]--[3,4]--<br> [3,3]--[3,2]--[3,1]--[4,1]--<br> [4,0]--[5,0]--[6,0]--[6,1]--<br> [6,2]--[6,3]--[6,4]--[6,5]--<br> [6,6]--[6,7]--[6,8]--[6,9]--<br> [6,10]--[7,10]--[8,10]--[9,10]--<br> [9,9]--[9,8]--[10,8]--[11,8]--<br> [11,9]--[11,10]--[11,11]--END<br> no path</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stack&gt;
#include&lt;vector&gt;
using namespace std;
void GoMaze(int n)
{
	//vector开二维数组
	vector&lt;vector&lt;int&gt;&gt;g(n, vector&lt;int&gt;(n));
	for (int i = 0; i &lt; n; i++)
	{
		for (int j = 0; j &lt; n; j++)
		{
			cin&gt;&gt; g[i][j];
		}
	}
	//起点和终点不通
	if (g[0][0] == 1 || g[n - 1][n - 1] == 1)
	{
		cout &lt;&lt; "no path" &lt;&lt; endl;
		return;
	}
	stack&lt;pair&lt;int, int&gt;&gt;path;
	int x = 0, y = 0;
	bool flag = 0;
	path.push({ x,y });
	while (!path.empty())
	{
		g[x][y] = 1;//走过不再走
		if (y + 1 &lt;= n - 1 &amp;&amp; g[x][y + 1] == 0)//先向下
		{
			y++;
			path.push({ x,y });
		}
		else if (x + 1 &lt;= n - 1 &amp;&amp; g[x + 1][y] == 0)//再向右
		{
			x++;
			path.push({ x,y });
		}
		else if (y - 1 &gt;= 0 &amp;&amp; g[x][y - 1] == 0)//向上退回
		{
			y--;
			path.push({ x,y });
		}
		else if (x - 1 &gt;= 0 &amp;&amp; g[x - 1][y] == 0)//向左退回
		{
			x--;
			path.push({ x,y });
		}
		else
		{
			//不能前进也无法退回(例如）
			//---1
			//11-1
			//1111
			//退回原来的位置，再次选择
			path.pop();//此位置不行
			if (!path.empty())//每次pop前都要判断，预防报错
			{
				auto tt = path.top();//使用栈体现，刚刚走过的
				x = tt.first;
				y = tt.second;
			}
		}
		if (x == n - 1 &amp;&amp; y == n - 1)
		{
			flag = 1;
			break;
		}
	}
	if (flag)
	{
		stack&lt;pair&lt;int, int&gt;&gt;temp;
		while (!path.empty())
		{
			temp.push(path.top());
			path.pop();
		}
		int count = 0;
		while (!temp.empty())
		{
			cout &lt;&lt; "[" &lt;&lt; temp.top().first &lt;&lt; "," &lt;&lt; temp.top().second &lt;&lt; "]";
			count++;
			temp.pop();
			cout &lt;&lt; "--";
			if (count == 4)
			{
				count = 0;
				cout &lt;&lt; endl;
			}
		}
		cout &lt;&lt; "END" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "no path" &lt;&lt; endl;
	}
}
int main()
{
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		int n;
		cin &gt;&gt; n;
		GoMaze(n);
	}
	return 0;
}
</code></pre> 
<h3>D. DS堆栈--括号匹配</h3> 
<h4>题目描述</h4> 
<p>处理表达式过程中需要对括号匹配进行检验，括号匹配包括三种：“(”和“)”，“[”和“]”，“{”和“}”。例如表达式中包含括号如下：</p> 
<pre><code>(	)	[	(	)	(	[	]	)	]	{	}
1	2	3	4	5	6	7	8	9	10	11	12
</code></pre> 
<p>从上例可以看出第1和第2个括号匹配，第3和第10个括号匹配，4和5匹配，6和9匹配，7和8匹配，11和12匹配。从中可以看到括号嵌套的的情况是比较复杂的，使用堆栈可以很方便的处理这种括号匹配检验，可以遵循以下规则：</p> 
<p>1、 当接收第1个左括号，表示新的一组匹配检查开始；随后如果连续接收到左括号，则不断进堆栈。</p> 
<p>2、 当接受第1个右括号，则和最新进栈的左括号进行匹配，表示嵌套中1组括号已经匹配消除</p> 
<p>3、 若到最后，括号不能完全匹配，则说明输入的表达式有错</p> 
<p>建议使用C++自带的stack对象来实现</p> 
<p>stack类使用的参考代码</p> 
<p>n包含头文件&lt;stack&gt;：#include &lt;stack&gt;</p> 
<p>n创建一个堆栈对象s（注意stack是模板类）：stack &lt;char&gt;  s;//堆栈的数据类型是字符型</p> 
<p>n把一个字符ct压入堆栈：s.push(ct);</p> 
<p>n把栈顶元素弹出：s.pop();</p> 
<p>n获取栈顶元素，放入变量c2：c2 =s.top();</p> 
<p>n判断堆栈是否空：s.empty()，如果为空则函数返回true，如果不空则返回false</p> 
<h4>输入</h4> 
<p>第一行输入一个t，表示下面将有t组测试数据。接下来的t行的每行输入一个表达式，表达式只考虑英文半角状态输入，无需考虑中文全角输入</p> 
<h4>输出</h4> 
<p>对于每一行的表达式，检查括号是否匹配，匹配则输入ok，不匹配则输出error</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>2<br> (a+b)[4*5+(-6)]<br> [5*8]/{(a+b)-6</p> 
<h4>输出样例1</h4> 
<p>ok<br> error</p> 
<h4>输入样例2 </h4> 
<p>4<br> {1+1}[3+3](5+5)<br> ((({<!-- -->{<!-- -->{}}})))<br> ((({<!-- -->{<!-- -->{}}})))([[]])<br> ((({<!-- -->{<!-- -->{5+5}}})))([[]])(1+1)</p> 
<h4>输出样例2</h4> 
<p>ok<br> ok<br> ok<br> ok</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stack&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		string s;
		cin &gt;&gt; s;
		stack&lt;char&gt;st;
		bool flag = 0;
		for (int i = 0; i &lt; s.size(); i++)
		{
			if (s[i] == '(' || s[i] == '[' || s[i] == '{')
			{
				st.push(s[i]);
			}
			else if (s[i] == ')')
			{
				if (st.top() != '(')
				{
					flag = 1;
					break;
				}
				else
				{
					st.pop();
				}
			}
			else if (s[i] == ']')
			{
				if (st.top() != '[')
				{
					flag = 1;
					break;
				}
				else
				{
					st.pop();
				}
			}
			else if (s[i] == '}')
			{
				if (st.top() != '{')
				{
					flag = 1;
					break;
				}
				else
				{
					st.pop();
				}
			}
			else continue;
		}
		if (flag || !st.empty())
		{
			cout &lt;&lt; "error" &lt;&lt; endl;
		}
		else cout &lt;&lt; "ok" &lt;&lt; endl;
	}
	return 0;
}
</code></pre> 
<h3>E. DS堆栈--表达式计算</h3> 
<h4>题目描述</h4> 
<p>计算一个表达式的运算结果</p> 
<p>使用C++自带stack堆栈对象来实现</p> 
<p>参考课本的算法伪代码P53-54</p> 
<p>例如</p> 
<p>1. Push (OPTR, '#');表示把字符#压入堆栈OPTR中，转换成c++代码就是OPTR.push('#');</p> 
<p>2. Pop(OPND, a); 表示弹出栈OPND的栈顶元素，并把栈顶元素放入变量a中。因此改成c++代码是两个操作：</p> 
<p>a = OPND.top();   OPND.pop();</p> 
<p>3. a = GetTop(OPND)表示获取栈OPND的栈顶元素，转成c++代码就是： a = OPND.top()</p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/d2/00/hwC7Hzwb_o.png" width="658"></p> 
<p><img alt="" height="807" src="https://images2.imgbox.com/11/22/mEsI6817_o.png" width="637"></p> 
<p><img alt="" height="469" src="https://images2.imgbox.com/e9/b5/wGXdb3J7_o.png" width="573"></p> 
<h4>输入</h4> 
<p>第一个输入t，表示有t个实例</p> 
<p>第二行起，每行输入一个表达式，每个表达式末尾带#表示结束</p> 
<p>输入t行</p> 
<h4>输出</h4> 
<p>每行输出一个表达式的计算结果，计算结果用浮点数（含4位小数）的格式表示</p> 
<p>用cout控制浮点数输出的小数位数，需要增加一个库文件，并使用fixed和setprecision函数，代码如下：</p> 
<p>#include &lt;iostream&gt;<br> #include&lt;iomanip&gt;<br> using namespace std;</p> 
<p>int main()</p> 
<p>{ double temp = 12.34</p> 
<p>cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;temp&lt;&lt;endl;</p> 
<p>}</p> 
<p>输出结果为12.3400</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
char opset[7]={'+','-','*','/','(',')','#'};
char Prior[7][7]=//列为当前，行为栈顶
{
    '&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;',
    '&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;',
    '&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;',
    '&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;',
    '&lt;','&lt;','&lt;','&lt;','&lt;','=',' ',
    '&gt;','&gt;','&gt;','&gt;',' ','&gt;','&gt;',
    '&lt;','&lt;','&lt;','&lt;','&lt;',' ','='
};
char precede(char aop,char bop)
{
    int x,y;
    for(int i=0;i&lt;7;i++)
    {
        if(opset[i]==aop)
        {
            x=i;
        }
        if(opset[i]==bop)
        {
            y=i;
        }
    }
    return Prior[x][y];
}
int In(char Test,char* Testop)
{
    for(int i=0;i&lt;7;i++)
    {
        if(Test==Testop[i])
        {
            return 1;
        }
    }
    return 0;
}
double Operate(double a,char theta,double b)
{
    if(theta=='+')
    {
        return a+b;
    }
    else if(theta=='-')
    {
        return b-a;
    }
    else if(theta=='*')
    {
        return a*b;
    }
    else if(theta=='/')
    { 
        return b/a;
    }
    //-----a/b  stack(b/a)
}
double EvaluateExpression(string exp)
{
    stack&lt;double&gt;opnd;//操作数
    stack&lt;char&gt;optr;//操作运算符
    char tempdata[20];
    double data,a,b,r;
    char theta,dr[2];
    char c;
    int i=0;
    //先放入#
    optr.push('#');
    c=exp[0];
    strcpy(tempdata,"\0");
    //遇到两个#停止
    while(c!='#'||optr.top()!='#')
    {
        if(!In(c,opset))//不是运算符，是数字
        {
            dr[0]=c;
            dr[1]='\0';
            strcat(tempdata,dr);
            //c为下一个字符
            c=exp[++i];
            //c是运算符
            if(In(c,opset))
            {
                //转换为数字
               data=(double)atof(tempdata);
               opnd.push(data);
               strcpy(tempdata,"\0");
            }
        }
        else//是数字
        {
            switch(precede(optr.top(),c))
            {
                case '&lt;'://栈顶元素优先权低
                optr.push(c);
                c=exp[++i];
                break;
                case '=':
                optr.pop();
                c=exp[++i];
                break;
                case '&gt;'://栈顶元素优先权低
                theta=optr.top();
                optr.pop();
                a=opnd.top();
                opnd.pop();
                b=opnd.top();
                opnd.pop();
                opnd.push(Operate(a,theta,b));
                break;
            }
        }
    }
    return opnd.top();
}
int main()
{
    string exp;
    int t;
    double result;
    cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;exp;
        result=EvaluateExpression(exp);
        cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;result&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ece6e6ad52a4558e8e7227e9406823d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">分布式【RPC 常见面试题】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38f6d1be17c396fed147ad33a823c4a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu安装xinetd服务报错 invoke-rc.d: policy-rc.d denied execution of restart解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>