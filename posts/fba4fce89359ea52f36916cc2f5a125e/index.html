<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Makefile基础 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Makefile基础" />
<meta property="og:description" content="文章来源地址：https://zhuanlan.zhihu.com/p/56946817?utm_source=qq
前言 通过之前章节的学习，我们对Makefile有个基础的认识，现在开始自己动手写Makefile。
目前网络上有不少可以自动生成Makefile的工具，但很多项目其实没必要那么复杂，完全可以自己动手写出来。
而且对于初学者来说，自己动手写一遍Makefile可以顶看十遍高手写的Makefile，也可以加深对Makefile的理解，将来公司的Makefile有需要修改的时候自己就可以动手搞定，不需要依靠他人，何乐而不为？
源代码介绍 在本教程中用于示例的代码很简单，仅仅是在main函数中调用了fun1及fun2函数，而fun1及fun2独立写在fun1.c及fun2.c里。代码如下：
//main.c
int main()
{
printf(“hello world\n”);
fun1();
fun2();
}
//fun1.c
void fun1()
{
printf(“this is fun1\n”);
}
//fun2.c
void fun2()
{
printf(“this is fun2\n”);
}
3. 第一版Makefile
对于我们的示例代码，不通过Makefile编译其实也很简单：
gcc main.c fun1.c fun2.c -o app
我们知道，Makefile其实就是按规则一条条的执行。所以，我们完全可以把上面那条命令写成Makefile的一个规则。我们的目标是app，按此写法依赖是main.c fun1.c fun2.c，则最终的Makefile如下：
app: main.c fun1.c fun2.c
gcc main.c fun1.c fun2.c -o app
但这个版本的Makefile有两个很重要的不足：
对于简单代码还好，而对于大型项目，具有成千上万代码来说，仅用一行规则是完全不够的，即使够的话也需要写很长的一条规则；
任何文件只要稍微做了修改就需要整个项目完整的重要编译。
基于此，我们在第一版的基础上优化出第二版。
第二版Makefile 在第二版Makefile中，为了避免改动任何代码就需要重新编译整个项目的问题，我们将主规则的各个依赖替换成各自的中间文件，即main.c --&gt; main.o，fun1.c --&gt; fun1.o，fun2.c --&gt; fun2.o，再对每个中间文件的生成各自写条规则比如对于main.o，规则为：
main.o: main.c
​ gcc -c main." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fba4fce89359ea52f36916cc2f5a125e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-30T16:07:23+08:00" />
<meta property="article:modified_time" content="2022-01-30T16:07:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Makefile基础</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>文章来源<a href="https://zhuanlan.zhihu.com/p/56946817?utm_source=qq" rel="nofollow">地址</a>：https://zhuanlan.zhihu.com/p/56946817?utm_source=qq</p> 
<hr> 
<ol><li>前言</li></ol> 
<p>通过之前章节的学习，我们对Makefile有个基础的认识，现在开始自己动手写Makefile。</p> 
<p>目前网络上有不少可以自动生成Makefile的工具，但很多项目其实没必要那么复杂，完全可以自己动手写出来。</p> 
<p>而且对于初学者来说，自己动手写一遍Makefile可以顶看十遍高手写的Makefile，也可以加深对Makefile的理解，将来公司的Makefile有需要修改的时候自己就可以动手搞定，不需要依靠他人，何乐而不为？</p> 
<ol start="2"><li>源代码介绍</li></ol> 
<p>在本教程中用于示例的代码很简单，仅仅是在main函数中调用了fun1及fun2函数，而fun1及fun2独立写在fun1.c及fun2.c里。代码如下：</p> 
<p>//main.c<br> int main()<br> {<!-- --><br> printf(“hello world\n”);<br> fun1();<br> fun2();<br> }<br> //fun1.c<br> void fun1()<br> {<!-- --><br> printf(“this is fun1\n”);<br> }<br> //fun2.c<br> void fun2()<br> {<!-- --><br> printf(“this is fun2\n”);<br> }<br> 3. 第一版Makefile</p> 
<p>对于我们的示例代码，不通过Makefile编译其实也很简单：</p> 
<p>gcc main.c fun1.c fun2.c -o app</p> 
<p>我们知道，Makefile其实就是按规则一条条的执行。所以，我们完全可以把上面那条命令写成Makefile的一个规则。我们的目标是app，按此写法依赖是main.c fun1.c fun2.c，则最终的Makefile如下：</p> 
<p>app: main.c fun1.c fun2.c<br> gcc main.c fun1.c fun2.c -o app<br> 但这个版本的Makefile有两个很重要的不足：</p> 
<p>对于简单代码还好，而对于大型项目，具有成千上万代码来说，仅用一行规则是完全不够的，即使够的话也需要写很长的一条规则；<br> 任何文件只要稍微做了修改就需要整个项目完整的重要编译。<br> 基于此，我们在第一版的基础上优化出第二版。</p> 
<ol start="4"><li>第二版Makefile</li></ol> 
<p>在第二版Makefile中，为了避免改动任何代码就需要重新编译整个项目的问题，我们将主规则的各个依赖替换成各自的中间文件，即main.c --&gt; main.o，fun1.c --&gt; fun1.o，fun2.c --&gt; fun2.o，再对每个中间文件的生成各自写条规则比如对于main.o，规则为：</p> 
<p>main.o: main.c<br> ​ gcc -c main.c -o main.o<br> 这样做的好处是，当有一个文件发生改动时，只需重新编译此文件即可，而无需重新编译整个项目。完整Makefile如下：</p> 
<p>app: main.o fun1.o fun2.o<br> gcc main.o fun1.o fun2.o -o app</p> 
<p>main.o: main.c<br> gcc -c main.c -o main.o</p> 
<p>fun1.o: fun1.c<br> gcc -c fun1.c -o fun1.o</p> 
<p>fun2.o: fun2.c<br> gcc -c fun2.c -o fun2.o<br> 第二版Makefile同样具有一些缺陷：</p> 
<p>里面存在一些重复的内容，可以考虑用变量代替；<br> 后面三条规则非常类似，可以考虑用一条模式规则代替。<br> 基于此，我们在第二版的基础上优化出第三版。</p> 
<ol start="5"><li>第三版Makefile</li></ol> 
<p>在第三版Makefile中，我们使用变量及模式规则使Makefile更加简洁。使用的三个变量如下：</p> 
<p>obj = main.o fun1.o fun2.o<br> target = app<br> CC = gcc<br> 使用的模式规则为：</p> 
<p>%.o: %.c<br> ​ $(CC) -c $&lt; -o <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         @ 
        
       
         这 
        
       
         条 
        
       
         模 
        
       
         式 
        
       
         规 
        
       
         则 
        
       
         表 
        
       
         示 
        
       
         ： 
        
       
         所 
        
       
         有 
        
       
         的 
        
       
         . 
        
       
         o 
        
       
         文 
        
       
         件 
        
       
         都 
        
       
         由 
        
       
         对 
        
       
         应 
        
       
         的 
        
       
         . 
        
       
         c 
        
       
         文 
        
       
         件 
        
       
         生 
        
       
         成 
        
       
         。 
        
       
         在 
        
       
         规 
        
       
         则 
        
       
         里 
        
       
         ， 
        
       
         我 
        
       
         们 
        
       
         又 
        
       
         看 
        
       
         到 
        
       
         了 
        
       
         两 
        
       
         个 
        
       
         自 
        
       
         动 
        
       
         变 
        
       
         量 
        
       
         ： 
        
       
      
        @ 这条模式规则表示：所有的.o文件都由对应的.c文件生成。在规则里，我们又看到了两个自动变量： 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">@</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">规</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">的</span><span class="mord">.</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">都</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">规</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">又</span><span class="mord cjk_fallback">看</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">动</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">：</span></span></span></span></span>&lt;和$@。其实自动变量有很多，常用的有三个：</p> 
<p>$&lt;：第一个依赖文件；</p> 
<p>$@：目标；</p> 
<p>$^：所有不重复的依赖文件，以空格分开​</p> 
<p>obj = main.o fun1.o fun2.o<br> target = app<br> CC = gcc</p> 
<p>$(target): $(obj)<br> $(CC) $(obj) -o $(target)</p> 
<p>%.o: %.c<br> $(CC) -c $&lt; -o $@<br> 第三版Makefile依然存在一些缺陷：</p> 
<p>obj对应的文件需要一个个输入，工作量大；<br> 文件数目比较少时还好，文件数目一旦很多的话，obj将很长；<br> 而且每增加/删除一个文件，都需要修改Makefile。<br> 基于此，我们在第二版的基础上优化出第四版。</p> 
<ol start="6"><li>第四版Makefile</li></ol> 
<p>在第四版Makefile中，我们隆重推出了两个函数：wildcard和patsubst。</p> 
<p>wildcard：</p> 
<p>扩展通配符，搜索指定文件。在此我们使用src = $(wildcard ./*.c)，代表在当前目录下搜索所有的.c文件，并赋值给src。函数执行结束后，src的值为：main.c fun1.c fun2.c。</p> 
<p>patsubst：</p> 
<p>替换通配符，按指定规则做替换。在此我们使用</p> 
<p>obj = $(patsubst %.c, %.o, $(src))<br> 代表将src里的每个文件都由.c替换成.o。函数执行结束后，obj的值为main.o fun1.o fun2.o，其实跟第三版Makefile的obj值一模一样，只不过在这里它更智能一些，也更灵活。</p> 
<p>除了使用patsubst函数外，我们也可以使用模式规则达到同样的效果，比如：</p> 
<p>obj = $(src:%.c=%.o)<br> 也是代表将src里的每个文件都由.c替换成.o。</p> 
<p>几乎每个Makefile里都会有一个伪目标clean，这样我们通过执行make clean命令就是将中间文件如.o文件及目标文件全部删除，留下干净的空间。一般是如下写法：</p> 
<p>.PHONY: clean<br> clean:<br> ​ rm -rf $(obj) $(target)<br> .PHONY代表声明clean是一个伪目标，这样每次执行make clean时，下面的规则都会被执行。</p> 
<p>src = $(wildcard ./*.c)<br> obj = $(patsubst %.c, %.o, $(src))<br> #obj = $(src:%.c=%.o)<br> target = app<br> CC = gcc</p> 
<p>$(target): $(obj)<br> $(CC) $(obj) -o $(target)</p> 
<p>%.o: %.c<br> $(CC) -c $&lt; -o $@</p> 
<p>.PHONY: clean<br> clean:<br> rm -rf $(obj) $(target)<br> 7. 总结</p> 
<p>Makefile其实也并不难，但关键的是一定要自己动手写，这样才会更加加深理解，否则也容易造成眼高手低。如果实在不知道从何下手，可以尝试按上面的教程，一步步写下来，也只需要写四个版本而已，写完了相信就有了初步的理解。</p> 
<p>在源代码里，总共有四个Makefile文件，可以通过make -f Makefile1来执行不同的Makefile。</p> 
<p>自己平时工作中写makefile文件都是根据源码原来的进行修，没有仔细研究过，这个文章一步一步进行，挺好<br> 谢谢作者；</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57154b55999173c8741b6a55df87cb32/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python&#43;OpenCV笔记（三十）：人脸检测与识别（二）——在静态图像与视频上进行人脸检测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e5acdede9f0b8853357b772c5d2ddf75/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Excel如何批量删除空格</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>