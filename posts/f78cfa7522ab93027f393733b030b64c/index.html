<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【华为云-云驻共创】多沙箱容器运行时Kuasar开发上手实践 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【华为云-云驻共创】多沙箱容器运行时Kuasar开发上手实践" />
<meta property="og:description" content="【摘要】在云原生技术发蓬勃发展的时代，底层承载应用的容器很重要，然而，单一容器隔离技术已经无法满足各种场景的要求，不同的场景都需要不同的容器形态来承载，从而产生了不同的沙箱技术。本文结合沙箱容器发展的历程，介绍华为云多沙箱容器运行时 Kuasar 项目的优势，并为开发者演示 Kuasar 的安装运行方式，开启多沙箱容器运行时的上手实践体验！
文章目录 前言沙箱容器的发展容器时代沙箱崛起 Kuasar 项目简介项目简介Kuasar定位MicroVM SandboxerApp Kernel SandboxerWasm SandboxerKuasar管理模型的变化性能表现启动时间测试内存消耗测试 Kuasar 安装部署预准备安装部署下载并源码编译配置 cotainerd 运行组件启动kuasar配置containerd环境变量 运行容器运行vmm沙箱运行quark沙箱运行wasm沙箱查看现有Pod和清空演示 总结Reference 前言 在一年一度的云原生开源领域顶级峰会KubeCon &#43; CloudNativeCon Europe 2023上，由华为云、中国农业银行、openEuler 社区和 CNCF 项目 WasmEdge 等联合发起的云原生多沙箱容器运行时 Kuasar 正式宣布开源，受到云原生社区、Rust 社区和云厂商们的广泛关注和热烈讨论。
全新云原生开源项目Kuasar，其结合了华为云多年生产业务实践以及对沙箱技术发展的思考，基于业界新兴的沙箱接口实现。在保留传统容器运行时功能的基础上，Kuasar通过全面Rust化以及优化管理模型和框架等手段，进一步降低管理开销、简化调用链路，灵活扩展对业界主流沙箱技术的支持，实现云原生业务场景全覆盖。此外，通过支持多安全沙箱共节点部署，Kuasar可以充分利用节点资源、降本增效，为用户提供更安全高效的沙箱场景解决方案。
沙箱容器的发展 容器时代 早在 2013 年，docker 横空出世，标志着容器时代到来。最初的容器技术，其实就是利用 Linux 内核提供的命名空间 Namespace 和控制组 Cgroup 功能，实现容器进程之间的资源隔离和限制。在容器时代，容器就是 docker 里唯一的一等公民。
不久，2014年，容器编排领域诸侯争霸，随着 Kubernetes 最终成为主流的容器编排工具，Pod也成为容器编排领域的一等公民，为了兼容 Pod 这一概念，docker 引入了 pause 容器。
然而，pause 容器的引入常常让开发者感到困惑，因为 Pod 与 pause 容器之间存在着很多差异。在 kubernetes 中，Pod 是一组容器逻辑和物理资源的载体，而 pause 容器只是提供了容器间共享的 namespace 而已。此外，容器运行时里有很多冗余和复杂的判断逻辑用于区分 pause 容器和用户容器，使得代码阅读和开发变得困难。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f78cfa7522ab93027f393733b030b64c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-28T10:03:42+08:00" />
<meta property="article:modified_time" content="2023-07-28T10:03:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【华为云-云驻共创】多沙箱容器运行时Kuasar开发上手实践</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>【摘要】在云原生技术发蓬勃发展的时代，底层承载应用的容器很重要，然而，单一容器隔离技术已经无法满足各种场景的要求，不同的场景都需要不同的容器形态来承载，从而产生了不同的沙箱技术。本文结合沙箱容器发展的历程，介绍华为云多沙箱容器运行时 Kuasar 项目的优势，并为开发者演示 Kuasar 的安装运行方式，开启多沙箱容器运行时的上手实践体验！</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#_12" rel="nofollow">沙箱容器的发展</a></li><li><ul><li><a href="#_14" rel="nofollow">容器时代</a></li><li><a href="#_37" rel="nofollow">沙箱崛起</a></li></ul> 
   </li><li><a href="#Kuasar__66" rel="nofollow">Kuasar 项目简介</a></li><li><ul><li><a href="#_68" rel="nofollow">项目简介</a></li><li><a href="#Kuasar_96" rel="nofollow">Kuasar定位</a></li><li><a href="#MicroVM_Sandboxer_119" rel="nofollow">MicroVM Sandboxer</a></li><li><a href="#App_Kernel_Sandboxer_130" rel="nofollow">App Kernel Sandboxer</a></li><li><a href="#Wasm_Sandboxer_145" rel="nofollow">Wasm Sandboxer</a></li><li><a href="#Kuasar_158" rel="nofollow">Kuasar管理模型的变化</a></li><li><a href="#_176" rel="nofollow">性能表现</a></li><li><ul><li><a href="#_195" rel="nofollow">启动时间测试</a></li><li><a href="#_206" rel="nofollow">内存消耗测试</a></li></ul> 
   </li></ul> 
   </li><li><a href="#Kuasar__217" rel="nofollow">Kuasar 安装部署</a></li><li><ul><li><a href="#_219" rel="nofollow">预准备</a></li><li><a href="#_235" rel="nofollow">安装部署</a></li><li><ul><li><a href="#_237" rel="nofollow">下载并源码编译</a></li><li><a href="#_cotainerd_257" rel="nofollow">配置 cotainerd</a></li></ul> 
    </li><li><a href="#_295" rel="nofollow">运行组件</a></li><li><ul><li><a href="#kuasar_297" rel="nofollow">启动kuasar</a></li><li><a href="#containerd_307" rel="nofollow">配置containerd环境变量</a></li></ul> 
    </li><li><a href="#_316" rel="nofollow">运行容器</a></li><li><ul><li><a href="#vmm_329" rel="nofollow">运行vmm沙箱</a></li><li><a href="#quark_346" rel="nofollow">运行quark沙箱</a></li><li><a href="#wasm_361" rel="nofollow">运行wasm沙箱</a></li><li><a href="#Pod_370" rel="nofollow">查看现有Pod和清空演示</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_377" rel="nofollow">总结</a></li><li><ul><li><a href="#Reference_383" rel="nofollow">Reference</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_4"></a>前言</h3> 
<p>在一年一度的云原生开源领域顶级峰会<code>KubeCon + CloudNativeCon Europe 2023</code>上，由<strong>华为云、中国农业银行、openEuler 社区和 CNCF 项目 WasmEdge</strong> 等联合发起的<strong>云原生多沙箱容器运行时 Kuasar 正式宣布开源</strong>，受到云原生社区、Rust 社区和云厂商们的广泛关注和热烈讨论。</p> 
<p>全新云原生开源项目Kuasar，其结合了华为云多年生产业务实践以及对沙箱技术发展的思考，基于业界新兴的沙箱接口实现。在保留传统容器运行时功能的基础上，Kuasar通过全面Rust化以及优化管理模型和框架等手段，进一步降低管理开销、简化调用链路，灵活扩展对业界主流沙箱技术的支持，实现云原生业务场景全覆盖。此外，通过支持多安全沙箱共节点部署，Kuasar可以充分利用节点资源、降本增效，为用户提供更安全高效的沙箱场景解决方案。</p> 
<hr> 
<h3><a id="_12"></a>沙箱容器的发展</h3> 
<h4><a id="_14"></a>容器时代</h4> 
<p><img src="https://images2.imgbox.com/33/ca/Y0Yqptfy_o.png" alt="image-20230703160021362.png"></p> 
<p>早在 2013 年，docker 横空出世，标志着容器时代到来。最初的容器技术，其实就是利用 Linux 内核提供的命名空间 Namespace 和控制组 Cgroup 功能，实现容器进程之间的资源隔离和限制。在容器时代，容器就是 docker 里唯一的一等公民。</p> 
<p><img src="https://images2.imgbox.com/a1/92/g7hHaXnz_o.png" alt="image-20230703160041595.png"></p> 
<p>不久，2014年，容器编排领域诸侯争霸，随着 Kubernetes 最终成为主流的容器编排工具，Pod也成为容器编排领域的一等公民，为了兼容 Pod 这一概念，docker 引入了 pause 容器。</p> 
<p>然而，pause 容器的引入常常让开发者感到困惑，因为 Pod 与 pause 容器之间存在着很多差异。在 kubernetes 中，Pod 是一组容器逻辑和物理资源的载体，而 pause 容器只是提供了容器间共享的 namespace 而已。此外，容器运行时里有很多冗余和复杂的判断逻辑用于区分 pause 容器和用户容器，使得代码阅读和开发变得困难。</p> 
<p>2019年，containerd从 CNCF 毕业，目前已在 kubernetes中成为首选的容器运行时，同样 containerd 也需要借助 pause 容器来运行一个 Pod。</p> 
<p><img src="https://images2.imgbox.com/78/7d/8K2xgnHs_o.png" alt="image-20230703175933767.png"></p> 
<p><strong>由于runC容器与宿主机系统共享内核，一旦发生容器逃逸，尤其是在多租场景下，将带来巨大的安全隐患。</strong></p> 
<hr> 
<h4><a id="_37"></a>沙箱崛起</h4> 
<p>随着上述问题的出现，也陆续出现相关的解决方案。时间来到2018年，云原生领域飞速发展，许多沙箱（Sandbox）隔离技术都被应用到容器领域，沙箱容器如火如荼。沙箱容器将容器进程限制在一个封闭的沙箱环境中，防止其对系统和其他容器造成破坏，具有极高的安全性。沙箱天然符合 Pod 的定义，它为一组容器提供了一个隔离的环境，在沙箱环境中运行的容器，就是<strong>沙箱容器</strong>。</p> 
<p>根据沙箱隔离的边界可分为<strong>轻量虚拟机沙箱</strong>（MicroVM Sandbox）、<strong>用户态内核沙箱</strong>（Application Kernel Sandbox）和<strong>WebAssembly 沙箱</strong>（Wasm Sandbox）。它们都是为满足不同业务需求而孵化的产物，所以它们在不同的维度上有着各自的优势。</p> 
<ul><li> <p><strong>轻量虚拟机沙箱</strong>（MicroVM Sandbox）：在宿主机上模拟一套完整的虚拟机，容器运行在虚拟机内，具有非常高的安全隔离效果。</p> </li><li> <p><strong>用户态内核沙箱</strong>（Application Kernel Sandbox）：通过一个运行在用户态的内核程序，拦截并实现容器的系统调用，从而保证容器间的安全隔离性。</p> </li><li> <p><strong>WebAssembly</strong> <strong>沙箱</strong>（Wasm Sandbox）：将容器运行在 WebAssembly 的运行时中，依赖 WebAssembly 的能力提供进进程级别的隔离。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/d9/8d/YKoQwZqv_o.png" alt="image-20230703163015164.png"></p> 
<p>每种沙箱在极速弹性、安全隔离和标准通用维度有各自的优势，目前云厂商都已在生产环境布局了沙箱容器产品，每个沙箱借助 <code>containerd Shim v2</code>均实现了一套管理面的程序，彼此之间不相兼容。</p> 
<p><img src="https://images2.imgbox.com/a6/80/CkcFVrLj_o.png" alt="image-20230703163609606.png"></p> 
<p>2023年 3 月，<code>containerd</code> 在其 <code>v1.7.0</code> 版本中发布了 <code>Sandbox API</code>特性，该特性提供了一套管理沙箱的 API ，它的出现使得容器和沙箱的概念解耦，“容器归容器，沙箱归沙箱”，创建 Pod 就是创建沙箱，不再需要借助 pasue 容器。</p> 
<p><img src="https://images2.imgbox.com/93/bc/9k4Yowgm_o.png" alt="image-20230703164309361.png"></p> 
<p><strong>沙箱容器已成为云原生场景下的安全解决方案，我们希望借助Sandbox API 的力量，实现一种支持多种沙箱技术的容器运行时。</strong></p> 
<hr> 
<h3><a id="Kuasar__66"></a>Kuasar 项目简介</h3> 
<h4><a id="_68"></a>项目简介</h4> 
<p>Sandbox API 的出现使得沙箱成为容器世界新的一等公民，我们需要一个支持多种主流沙箱技术的容器运行时，同时具有可扩展、可维护、可演进机制。因此，Kuasar 应运而生。</p> 
<p>华为云于2023 年 4 月在荷兰阿姆斯特丹举办的<code>KubeCon + CloudNativeCon Europe 2023</code>云原生峰会上正式开源Kuasar 。新开源的多沙箱容器运行时 Kuasar 可以充分利用节点资源、降本增效，为用户提供更安全高效的沙箱场景解决方案。</p> 
<p>Kuasar 是一个基于 Rust 语言开发，可以同时支持多种主流沙箱隔离技术的容器运行时，具有以下特点：</p> 
<ul><li><strong>对沙箱友好</strong>：基于 Sandbox API 接口开发，区别于当前的 Shim v2 接口，对沙箱的定义和生命周期管理有天然优势。</li><li><strong>多沙箱混部</strong>：集成多种主流沙箱技术，可以在单个节点上运行多种不同类型的沙箱容器。</li><li><strong>简化的模型</strong>：采用了 1:N 的容器进程管理模型，对比目前 Shim 进程 1:1 的做法，带来了 100% 启动速度提升和 99% 内存开销优化。</li></ul> 
<hr> 
<p><strong>Github地址</strong>： <a href="https://github.com/kuasar-io/kuasar">https://github.com/kuasar-io/kuasar</a></p> 
<p><img src="https://images2.imgbox.com/4a/82/kt2nkTuX_o.png" alt="image-20230703170203846.png"></p> 
<hr> 
<p><strong>项目官网</strong>：<a href="https://kuasar.io" rel="nofollow">https://kuasar.io</a></p> 
<p><img src="https://images2.imgbox.com/ff/19/9KkENvev_o.png" alt="image-20230703170723726.png"></p> 
<hr> 
<h4><a id="Kuasar_96"></a>Kuasar定位</h4> 
<p>Kuasar 是一个多沙箱容器运行时，那么什么是容器运行时？简单说容器运行时是一个负责拉起容器，管理容器运行状态的运行时组件，可以分为高阶容器运行时和低阶容器运行时两类：</p> 
<ul><li><strong>高阶容器运行时</strong>：负责 CRI 的实现，从高维度管理容器和镜像实例，containerd, CRI-O, docker 还有 iSulad 都是典型的高阶容器运行时。</li><li><strong>低阶容器运行时</strong>：负责 OCI 实现，真正操作容器。Kata-containers 和 runC 等都是低阶容器运行时。</li></ul> 
<hr> 
<p><img src="https://images2.imgbox.com/55/05/AoTmzv9D_o.png" alt="image-20230703175846432.png"></p> 
<p>Kuasar 属于低阶容器运行时，和高阶容器运行 containerd 交互，Kuasar 主要由两个模块组成：</p> 
<ul><li>Kuasar-Sandboxer：实现了 Sandbox API，负责管理沙箱生命周期和资源分配。Sandboxer 以插件的形式和 containerd 交互。</li><li>Kuasar-Task：实现了 Task API，负责管理容器的生命周期和资源分配。</li></ul> 
<hr> 
<p>目前，在北向接口层面，Kuasar 正在与 containerd 联合构建最新的沙箱接口标准，sandboxer 插件已经加入 containerd v2.0 的版本路标；此外，OpenEuler 社区的轻量级容器引擎 iSulad 项目也已经完成与 Kuasar 项目的对接。而在南向沙箱层面，Kuasar 已经支持包括 Cloud Hypervisor（MicroVM 类）、WasmEdge（Wasm 类）、StratoVirt（MicroVM 类）、Quark（App Kernel类）在内的多类主流安全沙箱。并已在<a href="https://kuasar.io/docs/roadmap" rel="nofollow">Roadmap</a>中计划支持更多的沙箱，在未来可以适应更多的云原生场景。</p> 
<hr> 
<h4><a id="MicroVM_Sandboxer_119"></a>MicroVM Sandboxer</h4> 
<p>在轻量级虚机场景，虚机进程提供了完整的虚拟化层和Linux 内核，此类的虚机包括 <a href="https://www.cloudhypervisor.org/" rel="nofollow">Cloud Hypervisor</a>、 <a href="https://gitee.com/openeuler/stratovirt" rel="nofollow">StratoVirt</a>、 <a href="https://firecracker-microvm.github.io" rel="nofollow">Firecracker</a> 和<a href="https://www.qemu.org" rel="nofollow">QEMU</a>。在 MicroVM Sandboxer 中， vmm-sandboxer 负责创建虚机和调用 API vmm-task 作为虚机里的 init 进程负责拉起容器进程，容器的 IO 流则可通过虚机的 vsock 或 uds 导出。</p> 
<p><img src="https://images2.imgbox.com/7b/87/eUeIKO5E_o.png" alt="image-20230703180046968.png"></p> 
<p>目前仅支持 Cloud Hypervisor, QEMU 和 StratoVirt。</p> 
<hr> 
<h4><a id="App_Kernel_Sandboxer_130"></a>App Kernel Sandboxer</h4> 
<p>App Kernel Sandbox将 KVM 虚拟化层和 Guest 内核深度融合成一个用户态内核进程，通过拦截容器系统调用实现容器隔离。典型代表包括 gVisor 和 Quark 。</p> 
<p>Quark 是一款App Kernel沙箱，使用自己的 QVisor hypervisor 和自定义内核 QKernel。QVisor 只负责KVM虚拟机的生命周期管理，并不模拟任何设备。Qkernel 拦截所有的 syscall，在需要的情况下，通过 VM_Exit 或者 eventfd 通知 QVisor 处理。通过将主机进程的内存空间映射到 VM 的物理内存空间中，实现 QVisor 和 QKernel 的内存共享。</p> 
<p>App Kernel Sandboxer 的 quark-sandboxer 拉起 Qvisor 和 Qkernel，每当 containerd 需要在沙箱中启动一个容器时，QVisor 中的 quark-task 将调用 Qkernel 来启动一个新的容器。同一 Pod 中的所有容器都将在同一个进程中运行。</p> 
<p><img src="https://images2.imgbox.com/7f/ef/Qxh58b8j_o.png" alt="image-20230703180754844.png"></p> 
<p>目前仅支持Quark。</p> 
<hr> 
<h4><a id="Wasm_Sandboxer_145"></a>Wasm Sandboxer</h4> 
<p>如果说 App Kernel 沙箱是在虚拟化和内核层面实现了一套隔离沙箱技术，那么WebAssembly 沙箱则是定义了一套新的体系结构，包含一套指令集和虚拟机。所有程序必须编译成 WebAssembly 指令集才能在 WebAssembly 虚拟机中运行。因此对应用程序有很高的要求，常见的 Wasm 沙箱有 WasmEdge 和 Wasmtime 。</p> 
<p>wasm-sandboxer 和 wasm-task 在 WebAssembly 沙箱内启动容器。当 containerd 需要在沙箱中启动容器时，wasm-task 将 fork 一个新进程，启动一个新的 WasmEdge runtime，并在其中运行 Wasm 代码。同一 Pod 内的所有容器都将与 wasm-task 进程共享相同的 Namespace 和 Cgroup 资源。</p> 
<p><img src="https://images2.imgbox.com/86/64/VEQwNAA9_o.png" alt="image-20230703181104620.png"></p> 
<p>目前仅支持 WasmEdge。受到某些技术限制（主要是标准输入输出无法重定向），wasm-task 使用 fork 的方式新启动一个 runtime。后续演进可能会选择直接在进程内启动 runtime ，实现更快速地启动和更低的内存占用。</p> 
<hr> 
<h4><a id="Kuasar_158"></a>Kuasar管理模型的变化</h4> 
<p>在目前容器运行时的 Shim v2 模型中，containerd 每创建一个 Pod，就要创建一个对应的 Shim 进程用于 Pod 的管理，Shim 进程再去创建虚机和容器，在这种场景下，管理面 Shim 进程和 Pod 的数量关系为1:1。</p> 
<p>但在 Kuasar 中，只需要运行一个 Kuasar-Sandboxer 进程，containerd 对 Pod 的管理都是调用 Sandboxer 对外暴露的接口，不再需要为每个 Pod 都拉起一个管理进程，因此，管理面 Sandboxer 进程和 Pod 的数量关系为 1:N. 这种模型可以大大减少常驻进程的数量，整个架构也因此变得更清晰简洁。</p> 
<p><img src="https://images2.imgbox.com/0f/1f/SEOBV2Kr_o.png" alt="image-20230703181807237.png"></p> 
<p>Kuasar改变当前的Shim V2 的管理模型，带来以下收益：</p> 
<ol><li><strong>sandbox管理逻辑清晰</strong>：sandbox 管理逻辑和 container 管理逻辑完全分开，开发友好，语义清晰。</li><li><strong>简化 container 调用链</strong>：取消 Task API 到 Shim v2 API 的转化，直接调用，链路简化。</li><li><strong>高效的 sandboxer 进程</strong>： Sandboxer 进程常驻减掉了冷启动 Shim 进程的耗时， 1:N 管理模型大幅减少了进程数量，Rust 程序内存安全，相比 Golang 开销小。</li><li><strong>pause</strong> <strong>容器消失</strong>：创建 Pod 不再创建 pause 容器，不再需要准备 pause 容器镜像快照。</li></ol> 
<hr> 
<h4><a id="_176"></a>性能表现</h4> 
<p>那么 Kuasar 的性能表现究竟如何呢？选择大家最关心的“<strong>端到端容器启动时间</strong>”和“<strong>管理面组件内存消耗</strong>”作为衡量 Kuasar 性能的两个指标，具体定义如下：</p> 
<ul><li><strong>端到端容器启动时间</strong>：在 containerd v1.7.0 的 CRI 实现中，摒弃了将沙箱伪装成容器的做法，改用 Sandbox API 新特性来创建沙箱和启动容器，因此我们需要以 CRI 为入口，实际测试端到端拉起一个容器进程所需要的时间。</li><li><strong>管理面组件内存消耗</strong>：测量管理组件的内存消耗（不包括虚机），即对比Sandboxer 进程和所有 Shim v2 进程的 PSS 内存（ Proportional Set Size ）。PSS是单个进程运行时实际占用的物理内存，包含共享库按比例分配后占用的内存。</li></ul> 
<p><img src="https://images2.imgbox.com/0a/15/CutBbD5i_o.png" alt="image-20230703182912215.png"></p> 
<p>控制如下变量：</p> 
<ul><li>VMM 、 Guest OS （除 init 进程）、 Guest Kernel 保持一致。</li><li>容器镜像相同，并直接使用本地镜像快照。</li><li>容器存储驱动均采用 Overlayfs。</li><li>容器网络为 HostNetwork 模式。</li></ul> 
<hr> 
<h5><a id="_195"></a>启动时间测试</h5> 
<p><img src="https://images2.imgbox.com/63/ff/a3WaOah6_o.png" alt="image-20230703183433601.png"></p> 
<p>启动时间测试分为两组，一组统计单个 Pod 的启动时间，另一组统计并行启动50个 Pod 的时间：</p> 
<p>Kuasar 100% 的启动速度提升主要得益于两方面，一方面是 Sandbox API 的实现，使得创建容器不再单独创建 pause 容器，节省了准备pause容器镜像快照的时间；另一方面得益于1:N 的管理模型，Sandboxer 进程常驻，从而节省了冷启动 Shim 进程的时间，这使得容器的启动速度大大提升。</p> 
<hr> 
<h5><a id="_206"></a>内存消耗测试</h5> 
<p><img src="https://images2.imgbox.com/48/05/m8g9kK0e_o.png" alt="image-20230703183528578.png"></p> 
<p>内存消耗测试共分三轮，每轮分别启动了1、5、10、20、30和50个Pod，查询Sandboxer 进程和所有 Shim 进程的 PSS 数值。</p> 
<p>Kuasar 节省近99%的内存，原因也可分为两点：主要是 1:N 的管理模型使得 N 个进程减少为1个进程，带来的内存收益与 Pod 数成正比；其次，Kuasar 采用了 Rust 编程语言，相比于 Kata Shim 进程使用的 Golang 语言，语言本身也会带来一些内存收益。</p> 
<hr> 
<h3><a id="Kuasar__217"></a>Kuasar 安装部署</h3> 
<h4><a id="_219"></a>预准备</h4> 
<p>在安装配置前需要大家预准备以下内容：</p> 
<p><img src="https://images2.imgbox.com/2d/50/cIeIBkyR_o.png" alt="image-20230704141422102.png"></p> 
<p>其余具体构建需求可参考官网和Github地址：<br> 官方地址：<a href="https://kuasar.io/docs/developer/build/" rel="nofollow">https://kuasar.io/docs/developer/build/</a><br> Github地址：<a href="https://github.com/kuasar-io/kuasar">https://github.com/kuasar-io/kuasar</a></p> 
<p><img src="https://images2.imgbox.com/27/c3/qjZSsfP2_o.png" alt="image-20230707095618287.png"></p> 
<hr> 
<h4><a id="_235"></a>安装部署</h4> 
<h5><a id="_237"></a>下载并源码编译</h5> 
<p>安装部署可参考Github地址：<a href="https://github.com/kuasar-io/kuasar">https://github.com/kuasar-io/kuasar</a></p> 
<p><img src="https://images2.imgbox.com/27/94/MPhxIDqF_o.png" alt="image-20230707095708348.png"></p> 
<p>操作命令：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> clone https://github.com/kuasar-io/kuasar.git
<span class="token builtin class-name">cd</span> kuasar
<span class="token function">make</span> all
<span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<p>注：Guest OS 镜像需在容器里编译，故需要启动 containerd 或其他容器运行时。</p> 
<hr> 
<h5><a id="_cotainerd_257"></a>配置 cotainerd</h5> 
<p>containerd的配置文件 /etc/containerd/config.toml 中需要新增三个 runtime，分别是vmm、quark、wasm：</p> 
<pre><code class="prism language-toml">[proxy_plugins.vmm ]
  type = "sandbox"
  address = "/run/vmm-sandboxer.sock"
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.vmm]
  runtime_type = "io.containerd.kuasar.v1"
  sandboxer = "vmm"
  io_type = "hvsock"
</code></pre> 
<pre><code class="prism language-toml">[proxy_plugins.quark ]
  type = "sandbox"
  address = "/run/quark-sandboxer.sock"
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.quark]
  runtime_type = "io.containerd.quark.v1"
  sandboxer = "quark"
</code></pre> 
<pre><code class="prism language-toml">[proxy_plugins.wasm ]
  type = "sandbox"
  address = "/run/wasm-sandboxer.sock"
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.wasm]
  runtime_type = "io.containerd.wasm.v1"
  sandboxer = "wasm"
</code></pre> 
<p>不支持AppArmor特性，因此还需要配置 disable_apparmor = true</p> 
<p><img src="https://images2.imgbox.com/66/02/RYXMaxWJ_o.png" alt="image-20230707112123151.png"></p> 
<hr> 
<h4><a id="_295"></a>运行组件</h4> 
<h5><a id="kuasar_297"></a>启动kuasar</h5> 
<p>使用以下命令启动kuasar：</p> 
<pre><code class="prism language-bash">对于vmm: <span class="token function">nohup</span> vmm-sandboxer <span class="token parameter variable">--listen</span> /run/vmm-sandboxer.sock <span class="token parameter variable">--dir</span> /run/kuasar-vmm <span class="token operator">&amp;</span>
对于quark: <span class="token function">nohup</span> quark-sandboxer <span class="token parameter variable">--listen</span> /run/quark-sandboxer.sock <span class="token parameter variable">--dir</span> /var/lib/kuasar-quark <span class="token operator">&amp;</span>
对于wasm: <span class="token function">nohup</span> wasm-sandboxer <span class="token parameter variable">--listen</span> /run/wasm-sandboxer.sock <span class="token parameter variable">--dir</span> /run/kuasar-wasm <span class="token operator">&amp;</span>
</code></pre> 
<h5><a id="containerd_307"></a>配置containerd环境变量</h5> 
<p>ENABLE_CRI_SANDBOXES=1 containerd ，Sandbox API 必须设置环境变量 <strong>ENABLE_CRI_SANDBOXES=1</strong> 才生效</p> 
<p><img src="https://images2.imgbox.com/fd/ac/XNsKULhp_o.png" alt="image-20230707142513839.png"></p> 
<hr> 
<h4><a id="_316"></a>运行容器</h4> 
<p>根据说明文档，我们可直接运行代码仓提供的脚本进行测试。</p> 
<p><img src="https://images2.imgbox.com/97/b2/M4c8WDaV_o.png" alt="image-20230707143418833.png"></p> 
<p>准备好所演示的镜像：</p> 
<p><img src="https://images2.imgbox.com/74/01/dorRVVNs_o.png" alt="image-20230707144250934.png"></p> 
<hr> 
<h5><a id="vmm_329"></a>运行vmm沙箱</h5> 
<pre><code class="prism language-bash"><span class="token function">bash</span> examples/run_example_container.sh vmm
</code></pre> 
<p><img src="https://images2.imgbox.com/a8/24/vCl3LNyQ_o.png" alt="image-20230707144612228.png"></p> 
<hr> 
<p>测试容器的访问：</p> 
<p><img src="https://images2.imgbox.com/74/49/DAERuqpE_o.png" alt="image-20230707145248796.png"></p> 
<hr> 
<h5><a id="quark_346"></a>运行quark沙箱</h5> 
<pre><code class="prism language-bash"><span class="token function">bash</span> examples/run_example_container.sh quark
</code></pre> 
<p><img src="https://images2.imgbox.com/8f/f4/4tRjp0QB_o.png" alt="image-20230707145603676.png"></p> 
<p>测试容器的访问：</p> 
<p><img src="https://images2.imgbox.com/12/64/EeoNzofp_o.png" alt="image-20230707145724035.png"></p> 
<hr> 
<h5><a id="wasm_361"></a>运行wasm沙箱</h5> 
<pre><code class="prism language-bash"><span class="token function">bash</span> examples/run_example_wasm_container.sh
</code></pre> 
<p><img src="https://images2.imgbox.com/04/b4/byNq5eIz_o.png" alt="image-20230707152043414.png"></p> 
<h5><a id="Pod_370"></a>查看现有Pod和清空演示</h5> 
<p><img src="https://images2.imgbox.com/30/10/vCoeitKn_o.png" alt="image-20230707152511018.png"></p> 
<hr> 
<h3><a id="_377"></a>总结</h3> 
<p>Kuasar作为新一代的容器运行时，不再采用通过 shim v2 接口来管理 Pod，取而代之的是 Kuasar 向容器引擎提供的新一代容器运行时 Pod 管理接口 Sandbox API。这套接口不仅逻辑更加清晰，而且可以支持多沙箱接入。每一种 Sandboxer 都使用了自己的容器隔离技术，用来管理同一类型的 Pod。而Kuasar 将发挥沙箱接口的优势，拥抱业界最新的 DRA(Dynamic Resource Allocation)、CDI(Container Device Interface) 等管理接口，为云原生场景带来更安全、高效、便捷的容器解决方案，为云原生应用提供更安全的保障。</p> 
<hr> 
<h4><a id="Reference_383"></a>Reference</h4> 
<p><strong>Kuasar Github</strong>：<a href="https://github.com/kuasar-io">https://github.com/kuasar-io</a></p> 
<p><strong>Kuasar官网</strong>：<a href="https://kuasar.io" rel="nofollow">https://kuasar.io</a></p> 
<hr> 
<blockquote> 
 <p>本文参与华为云社区【内容共创】活动第22期。</p> 
 <p>【内容共创】活动第22期活动详情：<a href="https://bbs.huaweicloud.com/blogs/402312" rel="nofollow">https://bbs.huaweicloud.com/blogs/402312</a></p> 
 <p>任务19.[<a href="https://bbs.huaweicloud.com/live/DTT_live/202305171630.html" rel="nofollow">DTSE Tech Talk 技术直播 NO.28 多沙箱容器运行时Kuasar开发上手实践</a>]</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67e92c50a1a5a708defbf15ce25f49b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python】Pillow 库入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d94dfcd38740dd3d4a8e4265c0d854bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Drupal YAML 反序列化代码执行漏洞(CVE-2017-6920)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>