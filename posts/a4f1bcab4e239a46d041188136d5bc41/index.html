<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ros手柄控制机器人小车(三) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ros手柄控制机器人小车(三)" />
<meta property="og:description" content="今天学到了，使用了ros::spin()就是让程序一直在subscriber里面死循环．
更新需求，要把按键设置成控制速度按钮，摇杆作为前进后退的控制．
首先需要测试手柄上所有的按键对应的buttons[]的哪一位：
sudo jstest /dev0/input/js0 全部测试后，发现了以下对应信息：
Buttons[]: A: 0 B: 1 X: 2 Y: 3 L1: 4 R1: 5 select:6 start: 7 mode: 8 //9,10没有分配 控制的逻辑还是在按下L1下开始，只有按下L1其他按键按动才会启动，现在的设想是：
Ｙ和A分别控制线速度的增加和减少，Ｘ和Ｂ分别控制角速度的增加和减少;
每个设置４档：０，１，２，３
SELECT设置为最低速度, START设置为最高速度，其它按键暂时不设置．
设置比较简单，但最后的逻辑需要思考一下，先实现：
首先在launch里面更改：
&lt;launch&gt; &lt;node pkg=&#34;turtlesim&#34; type=&#34;turtlesim_node&#34; name=&#34;turtle1&#34; output=&#34;screen&#34; /&gt; &lt;node pkg=&#34;ros_handle_control&#34; type=&#34;teleop_turtle4&#34; name=&#34;teleop4&#34; output=&#34;screen&#34; /&gt; &lt;node pkg=&#34;ros_handle_control&#34; type=&#34;teleop_turtle5&#34; name=&#34;teleop5&#34; output=&#34;screen&#34; /&gt; &lt;!-- 方向按键控制 --&gt; &lt;param name=&#34;axis_linear&#34; value=&#34;7&#34; type=&#34;int&#34; /&gt; &lt;param name=&#34;axis_angular&#34; value=&#34;6&#34; type=&#34;int&#34; /&gt; &lt;!-- 摇杆控制 --&gt; &lt;param name=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a4f1bcab4e239a46d041188136d5bc41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-03T14:45:27+08:00" />
<meta property="article:modified_time" content="2022-11-03T14:45:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ros手柄控制机器人小车(三)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>今天学到了，使用了ros::spin()就是让程序一直在subscriber里面死循环．</strong></p> 
<p>更新需求，要把按键设置成控制速度按钮，摇杆作为前进后退的控制．</p> 
<p>首先需要测试手柄上所有的按键对应的buttons[]的哪一位：</p> 
<pre><code>sudo jstest /dev0/input/js0</code></pre> 
<p>全部测试后，发现了以下对应信息：</p> 
<pre><code class="language-XML">Buttons[]:
A:     0
B:     1
X:     2
Y:     3
L1:    4
R1:    5
select:6
start: 7
mode:  8
//9,10没有分配</code></pre> 
<p>控制的逻辑还是在按下L1下开始，只有按下L1其他按键按动才会启动，现在的设想是：</p> 
<p>Ｙ和A分别控制线速度的增加和减少，Ｘ和Ｂ分别控制角速度的增加和减少;</p> 
<p>每个设置４档：０，１，２，３</p> 
<p>SELECT设置为最低速度, START设置为最高速度，其它按键暂时不设置．</p> 
<p>设置比较简单，但最后的逻辑需要思考一下，先实现：</p> 
<p>首先在launch里面更改：</p> 
<pre><code class="language-XML">&lt;launch&gt;
    &lt;node pkg="turtlesim" type="turtlesim_node" name="turtle1" output="screen" /&gt;
   
    &lt;node pkg="ros_handle_control" type="teleop_turtle4" name="teleop4" output="screen" /&gt;
    &lt;node pkg="ros_handle_control" type="teleop_turtle5" name="teleop5" output="screen" /&gt;

&lt;!-- 方向按键控制 --&gt;
    &lt;param name="axis_linear" value="7" type="int" /&gt;
    &lt;param name="axis_angular" value="6" type="int" /&gt;
&lt;!-- 摇杆控制 --&gt;
    &lt;param name="sticks_left" value="1" type="int" /&gt;
    &lt;param name="sticks_right" value="3" type="int" /&gt;

&lt;!-- 线速度系数设置 --&gt;
    &lt;param name="linear_ratio" value="0.5" type="double" /&gt;
&lt;!-- 角速度系数设置 --&gt;
    &lt;param name="angular_ratio" value="0.5" type="double" /&gt;

&lt;!-- 线速度换档 --&gt;
    &lt;param name="linear_up" value="3" type=int /&gt;
    &lt;param name="linear_down" value="0" type=int /&gt;

&lt;!-- 角速度换挡  --&gt;
    &lt;param name="angular_up" value="1" type=int /&gt;
    &lt;param name="angular_down" value="2" type=int /&gt;

&lt;!-- 设置最低速度和最高速度 --&gt;
    &lt;param name="min_speed" value="6" type=int /&gt;
    &lt;param name="max_speed" value="7" type=int /&gt;

    &lt;param name="ton" value="4" type="int" /&gt;
    &lt;node respawn="true" pkg="joy" type="joy_node" name="joystick" /&gt;

&lt;/launch&gt;</code></pre> 
<p>然后现在teleop_turtle4.cpp里面先修改:</p> 
<pre><code class="language-cpp">#include &lt;ros/ros.h&gt;
#include &lt;geometry_msgs/Twist.h&gt;
#include &lt;sensor_msgs/Joy.h&gt;

int axis_linear, axis_angular;
int sticks_left, sticks_right;
int ton;

double linear_ratio, angular_ratio;
int linear_up, linear_down, angular_up, angular_down;
int max_speed, min_speed;
double vel_x, vel_z;

bool L1_press = false;
void linear_speed_updown(const sensor_msgs::Joy::ConstPtr &amp;joy)
{
    if(joy-&gt;buttons[linear_up])
    {
        vel_x += linear_ratio;
    }
    else if(joy-&gt;buttons[linear_down])
    {
        vel_x -= linear_ratio;
    }
}

void angular_speed_updown(const sensor_msgs::Joy::ConstPtr &amp;joy)
{
    if(joy-&gt;buttons[angular_up])
    {
        vel_z += angular_ratio;
    }
    else if(joy-&gt;buttons[angular_down])
    {
        vel_z -= angular_ratio;
    }
}

void max_min_charge(double&amp; v)
{
    if(v &gt; 0)
        v &gt; 4 ? v = 4 : v;
    else if(v &lt; 0)
        v &lt; -4 ? v = -4 : v;
}
void callback(const sensor_msgs::Joy::ConstPtr &amp;joy)
{

    ROS_INFO("6546546546546");
    if(joy-&gt;buttons[ton])
    {
        if(joy-&gt;axes[axis_linear] || joy-&gt;axes[axis_angular])
        {
            vel_x = joy-&gt;axes[axis_linear];
            vel_z = joy-&gt;axes[axis_angular];
            linear_speed_updown(joy);
        }
        else if(joy-&gt;axes[sticks_left] ||  joy-&gt;axes[sticks_right])
        {
            vel_x = joy-&gt;axes[sticks_left];
            vel_z = joy-&gt;axes[sticks_right];
            angular_speed_updown(joy);
        }
        linear_speed_updown(joy);
        angular_speed_updown(joy);
        if(joy-&gt;buttons[min_speed])
        {
            vel_x = 0.5;
            vel_z = 0.5;
        }
        else if(joy-&gt;buttons[max_speed])
        {
            vel_x = 4;
            vel_z = 4;
        }
        max_min_charge(vel_x);
        max_min_charge(vel_z);
        ROS_INFO("当前线速度为:%.3lf ; 角速度为:%.3lf", vel_x, vel_z);            
    }
    else
    {
        vel_x = 0;
        vel_z = 0;
    }


}

int main(int argc, char** argv)
{
    setlocale(LC_ALL, "");
    
    ros::init(argc, argv, "sub_joy_pub_msgs");
    ros::NodeHandle nh;
    ros::Rate r(20);

    ros::Subscriber sub;
    ros::Publisher pub;
    nh.param&lt;int&gt;("linear_up", linear_up, 3);
    nh.param&lt;int&gt;("linear_down", linear_down, 0);
    nh.param&lt;int&gt;("angular_up", angular_up, 1);
    nh.param&lt;int&gt;("angular_down", angular_down, 2);
    
    nh.param&lt;double&gt;("linear_ratio", linear_ratio, 0.5);
    nh.param&lt;double&gt;("angular_ratio", angular_ratio, 0.5);

    nh.param&lt;int&gt;("max_speed", max_speed, 6);
    nh.param&lt;int&gt;("min_speed", min_speed, 7);
    nh.param&lt;int&gt;("ton", ton, 4);
    // 按手柄摇杆分配
    nh.param&lt;int&gt;("sticks_left", sticks_left, 7);
    nh.param&lt;int&gt;("sticks_right", sticks_right, 6);
    // 按键分配
    nh.param&lt;int&gt;("axis_linear", axis_linear, 1);
    nh.param&lt;int&gt;("axis_angular", axis_angular, 2);
    
    sub = nh.subscribe&lt;sensor_msgs::Joy&gt;("/joy", 10, callback);



    ros::spin();
    
    return 0;
}</code></pre> 
<p>第一版写的很繁琐，需要修改，相关的逻辑也很乱，怎么才能做到在按下L１的时候按方向键控制方向，并且在按动Ｙ和Ａ的时候进行速度的加减，之前尝试了一种方法没有完美实现，只能在按下Ｌ１后确定方向按键后松开按键，然后再对速度进行加减．但不太行，想了一下，</p> 
<p>准备在设置多个bool来判断按键，然后在进一步处理，这样对于数据的处理更加合理．</p> 
<p><strong>想了很久，发现可以根据每一个按键设置对应的速度，最后在把所有的速度全部加起来，这样就可以完美解决按键匹配的功能．</strong></p> 
<pre><code class="language-cpp">#include &lt;ros/ros.h&gt;
#include &lt;geometry_msgs/Twist.h&gt;
#include &lt;sensor_msgs/Joy.h&gt;

int axis_linear, axis_angular;
int sticks_left, sticks_right;
int ton;

double linear_ratio, angular_ratio;
int linear_up, linear_down, angular_up, angular_down;
int max_speed, min_speed;
double vel_x, vel_z;
double vx_scale = 0, vz_scale = 0;
double vx = 0, vz = 0;
bool min_flag = false, max_flag = false;
bool use_min_max_speed = false;
int cnt = 0;



ros::Subscriber sub;
ros::Publisher pub;
void linear_speed_updown(const sensor_msgs::Joy::ConstPtr &amp;joy)
{

    if(joy-&gt;buttons[linear_up])
    {
        min_flag = false;
        max_flag = false;
        vx_scale += linear_ratio;
    }
    else if(joy-&gt;buttons[linear_down])
    {
        min_flag = false;
        max_flag = false;
        vx_scale -= linear_ratio;
    }
}
void angular_speed_updown(const sensor_msgs::Joy::ConstPtr &amp;joy)
{
    if(joy-&gt;buttons[angular_up])
    {
        min_flag = false;
        max_flag = false;
        vz_scale += angular_ratio;
    }
    else if(joy-&gt;buttons[angular_down])
    {
        min_flag = false;
        max_flag = false;
        vz_scale -= angular_ratio;
    }
}
        //这里可以加前进后退方向的判断 
void max_min_speed(const sensor_msgs::Joy::ConstPtr &amp;joy)
{
    if(joy-&gt;buttons[min_speed])
    {
        min_flag = true;
        vx = 0;
        vz = 0;
        vel_x = 0;
        vel_z = 0;
        vx_scale = 0;
        vz_scale = 0;
    }
    else if(joy-&gt;buttons[max_speed])
    {
        max_flag = true;
        vx = 0;
        vz = 0;
        vel_x = 0;
        vel_z = 0;
        vx_scale = 0;
        vz_scale = 0;
    }    
}
void max_min_charge(double&amp; v)
{
    if(v &gt; 0)
        v &gt; 1 ? v = 1 : v;
    else if(v &lt; 0)
        v &lt; -1 ? v = -1 : v;
}
void callback(const sensor_msgs::Joy::ConstPtr &amp;joy)
{

    if(joy-&gt;buttons[ton])
    {
        if(joy-&gt;axes[axis_linear]||joy-&gt;axes[axis_angular])
        {
            linear_speed_updown(joy);
            angular_speed_updown(joy);
            vel_x = joy-&gt;axes[axis_linear] * 0.1;
            vel_z = joy-&gt;axes[axis_angular] * 0.1;
            use_min_max_speed = true;
        }
        vx = vel_x + vx_scale;
        vz = vel_z + vz_scale;
        if(min_flag == true)
        {
            vx = 0.1;
        }
        if(max_flag == true)
        {
            vx = 1;
        }
        if((joy-&gt;buttons[min_speed] || joy-&gt;buttons[max_speed]) &amp;&amp; use_min_max_speed)
        {
            if(joy-&gt;buttons[min_speed])
            {
                min_flag = true;
            }
            else if(joy-&gt;buttons[max_speed])
            {
                max_flag = true;
            }
            use_min_max_speed = false;    
        }

        max_min_charge(vx);
        max_min_charge(vz);
 
    }
    else
    {
        vx = 0;
        vz = 0;
        vel_x = 0;
        vel_z = 0;
        vx_scale = 0;
        vz_scale = 0;
        cnt = 0;
    }


    ROS_INFO("当前线速度为:%.3lf ; 角速度为:%.3lf", vx, vz);          

}

int main(int argc, char** argv)
{
    setlocale(LC_ALL, "");
    
    ros::init(argc, argv, "sub_joy_pub_msgs");
    ros::NodeHandle nh;
    ros::Rate r(10);
    nh.param&lt;int&gt;("linear_up", linear_up, 3);
    nh.param&lt;int&gt;("linear_down", linear_down, 0);
    nh.param&lt;int&gt;("angular_up", angular_up, 1);
    nh.param&lt;int&gt;("angular_down", angular_down, 2);
    
    nh.param&lt;double&gt;("linear_ratio", linear_ratio, 0.5);
    nh.param&lt;double&gt;("angular_ratio", angular_ratio, 0.5);

    nh.param&lt;int&gt;("max_speed", max_speed, 6);
    nh.param&lt;int&gt;("min_speed", min_speed, 7);
    nh.param&lt;int&gt;("ton", ton, 4);
    // 按手柄摇杆分配
    nh.param&lt;int&gt;("sticks_left", sticks_left, 7);
    nh.param&lt;int&gt;("sticks_right", sticks_right, 6);
    // 按键分配
    nh.param&lt;int&gt;("axis_linear", axis_linear, 1);
    nh.param&lt;int&gt;("axis_angular", axis_angular, 2);
    
    sub = nh.subscribe&lt;sensor_msgs::Joy&gt;("/joy", 10, callback);
    pub = nh.advertise&lt;geometry_msgs::Twist&gt;("/turtle1/cmd_vel", 10);    

    while(ros::ok())
    {
        geometry_msgs::Twist v;
        v.linear.x = vx;
        v.angular.z = vz;
        pub.publish(v);
        ros::spinOnce();
    }
    
    return 0;
}</code></pre> 
<p>但在设置最低速度和最高速度的时候出了，问题，必须要一直按着selec和start按键，才能设置成相应的速度，按一下就松开就会刷新走，最后请教了师兄，把判断的flag的放置进速度调整里面就行了．还是实际开发能力太弱了，得加强！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bda208524afb0853cd906c66be6aa021/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">开机都得先科学上网，再退出，才能连接校园网</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d131eddac47d83bbc35e4de826127bd0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】String.join()方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>