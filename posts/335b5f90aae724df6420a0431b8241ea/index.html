<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图像处理​​​​​​​--十大经典算法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图像处理​​​​​​​--十大经典算法" />
<meta property="og:description" content="导读：随着现代社会的发展，信息的形式和数量正在迅猛增长。其中很大一部分是图像，图像可以把事物生动地呈现在我们面前，让我们更直观地接受信息。
这是小编的其他文章,希望对大家有所帮助,点击即可阅读
人工智能常用的十大算法 人工智能数学基础（一） 人工智能数学基础(二)
人工智能数学基础（三） 人工智能数学基础（四）
为了方便大家学习交流，我建了一个扣裙：966367816（学习交流、大牛答疑、大厂内推）
另外我还整理了整整200G的人工智能学习笔记、课程视频、面试宝典一并可以无套路免费
分享给大家！
定义 图像处理（image processing）又称为影像处理，是用计算机对图像进行达到所需结果的技术。应用广泛，多用于测绘学、大气科学、天文学、美图、使图像提高辨识等
图像处理是对图像进行分析、加工、和处理，使其满足视觉、心理以及其他要求的技术。图像处理是信号处理在图像域上的一个应用，目前大多数的图像是以数字形式存储，因而图像处理很多情况下指数字图像处理。
下面简单介绍下数字图像处理领域中的经典算法。
深度优先搜索(DFS) DFS（Depth-First-Search）深度优先搜索，是计算机术语，是一种在开发爬虫早期使用较多的方法，是搜索算法的一种。它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件) 。
深度优先遍历图的算法是，假定给定图G的初始状态是所有顶点均未被访问过，在G中任选一个顶点i作为遍历的初始点，则深度优先搜索递归调用步骤：
1、访问搜索到的未被访问的邻接点；
2、将此顶点标记为已访问节点；
3、搜索该顶点的未被访问的邻接点，若该邻接点存在，则从此邻接点开始进行同样的访问和搜索，反复进行直到所有节点都被访问为止。
算法详解:
首先选定图的类别（有向图、无向图），再选定图的存储结构，根据输入的顶点或者边建立图；并把相应的邻接表或者邻接矩阵输出；
根据已有的邻接矩阵或邻接表用递归方法编写深度优先搜索遍历算法，并输出遍历结果；
图的深度遍历原则：
1 如果有可能，访问一个领接的未访问的节点，标记它，并把它放入栈中。
2 当不能执行规则 1 时，如果栈不为空，则从栈中弹出一个元素。
3 如果不能执行规则 1 和规则 2 时，则完成了遍历。
代码中的图使用的是Graph 图－邻接矩阵法 来表示，其他的表示法请见：Graph 图－邻接表法
代码中的Stack为辅助结构，用来记载访问过的节点。栈的详细描述可以见：ArrayStack 栈 ，LinkedStack 栈 。
Vertex表示图中的节点，其中包含访问，是否访问，清除访问标志的方法。 Graph.main：提供简单测试。代码可以以指定下标的节点开始作深度遍历。 代码比较简单，除了Graph.dsf(int i)深度优先遍历算法外没有过多注释。
广度优先搜索(BFS) 广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。
作法:
BFS是一种盲目搜索法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能地址，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。
从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实现里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。（open-closed表）
A*搜索算法 A*算法是一种静态路网中求解最短路最有效的直接搜索方法。之后涌现了很多预处理算法（ALT，CH，HL等等），在线查询效率是A*算法的数千甚至上万倍。
A*算法操作：首先将起始结点S放入OPEN表，CLOSE表置空，算法描述：
1、如果OPEN表不为空，从表头取一个结点n，如果为空算法失败。
2、n是目标解吗？是，找到一个解（继续寻找，或终止算法）。
3、将n的所有后继结点展开，就是从n可以直接关联的子结点，如果不在CLOSE表中，就将它们放入OPEN表，并把S放入CLOSE表，同时计算每一个后继结点的估价值f(n)，将OPEN表按f(x)排序，最小的放在表头，重复算法，回到1。
Dijkstra算法 戴克斯特拉算法（又译迪杰斯特拉算法） 是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/335b5f90aae724df6420a0431b8241ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-29T15:07:18+08:00" />
<meta property="article:modified_time" content="2021-09-29T15:07:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图像处理​​​​​​​--十大经典算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>导读：随着现代社会的发展，信息的形式和数量正在迅猛增长。其中很大一部分是图像，图像可以把事物生动地呈现在我们面前，让我们更直观地接受信息。</strong></p> 
<hr> 
<p>这是小编的其他文章,希望对大家有所帮助,<strong>点击即可阅读</strong></p> 
<p><a class="link-info" href="https://blog.csdn.net/Java_rich/article/details/120306028?spm=1001.2014.3001.5501" title="人工智能常用的十大算法">人工智能常用的十大算法</a>      <a class="link-info" href="https://blog.csdn.net/Java_rich/article/details/120361765?spm=1001.2014.3001.5501" title="人工智能数学基础（一）">人工智能数学基础（一）</a>     <a class="link-info" href="https://blog.csdn.net/Java_rich/article/details/120412229?spm=1001.2014.3001.5501" title="人工智能数学基础(二)">人工智能数学基础(二)</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/Java_rich/article/details/120451382?spm=1001.2014.3001.5501" title="人工智能数学基础（三）">人工智能数学基础（三）</a>   <a class="link-info" href="https://blog.csdn.net/Java_rich/article/details/120473401?spm=1001.2014.3001.5501" title="人工智能数学基础（四）">人工智能数学基础（四）</a></p> 
<p>为了方便大家学习交流，我建了一个扣裙：<strong><span style="color:#fe2c24;">966367816</span></strong>（学习交流、大牛答疑、大厂内推）<br> 另外我还整理了整整200G的人工智能学习笔记、课程视频、面试宝典一并可以无套路免费<br> 分享给大家！</p> 
<blockquote> 
 <h3><span style="color:#0d0016;">定义</span></h3> 
</blockquote> 
<p><span style="background-color:#38d8f0;">图像处理（image processing）又称为影像处理，是用计算机对图像进行达到所需结果的技术</span>。应用广泛，多用于测绘学、大气科学、天文学、美图、使图像提高辨识等</p> 
<p>图像处理是对图像进行分析、加工、和处理，使其满足视觉、心理以及其他要求的技术。图像处理是信号处理在图像域上的一个应用，目前大多数的图像是以数字形式存储，因而图像处理很多情况下指数字图像处理。</p> 
<p style="text-align:center;"><img alt="" height="193" src="https://images2.imgbox.com/65/26/gaJJ9wn8_o.jpg" width="193"></p> 
<p> 下面简单介绍下数字图像处理领域中的经典算法。</p> 
<blockquote> 
 <h3><span style="color:#0d0016;"><strong>深度优先搜索(</strong>DFS)</span></h3> 
</blockquote> 
<p><span style="background-color:#38d8f0;">DFS（Depth-First-Search）深度优先搜索，是计算机术语，是一种在开发爬虫早期使用较多的方法，是搜索算法的一种</span>。它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件) 。</p> 
<p>深度优先遍历图的算法是，假定给定图G的初始状态是所有顶点均未被访问过，在G中任选一个顶点i作为遍历的初始点，则深度优先搜索递归调用步骤：</p> 
<p>1、访问搜索到的未被访问的邻接点；</p> 
<p>2、将此顶点标记为已访问节点；</p> 
<p>3、搜索该顶点的未被访问的邻接点，若该邻接点存在，则从此邻接点开始进行同样的访问和搜索，反复进行直到所有节点都被访问为止。</p> 
<p style="text-align:center;"><img alt="" height="178" src="https://images2.imgbox.com/fd/7d/pnhz1mg7_o.jpg" width="248">  <img alt="" height="152" src="https://images2.imgbox.com/7f/c4/yGg7mspS_o.png" width="187"><img alt="" height="133" src="https://images2.imgbox.com/70/cf/fTJHZ7Bp_o.jpg" width="133"></p> 
<p></p> 
<p> <strong><span style="background-color:#ffd900;">算法详解:</span></strong></p> 
<p>首先选定图的类别（有向图、无向图），再选定图的存储结构，根据输入的顶点或者边建立图；并把相应的邻接表或者邻接矩阵输出；</p> 
<p>根据已有的邻接矩阵或邻接表用递归方法编写深度优先搜索遍历算法，并输出遍历结果；</p> 
<p><strong><span style="background-color:#ffd900;">图的深度遍历原则：</span></strong></p> 
<p>1 如果有可能，访问一个领接的未访问的节点，标记它，并把它放入栈中。</p> 
<p>2 当不能执行规则 1 时，如果栈不为空，则从栈中弹出一个元素。</p> 
<p>3 如果不能执行规则 1 和规则 2 时，则完成了遍历。</p> 
<p>代码中的图使用的是Graph 图－邻接矩阵法 来表示，其他的表示法请见：Graph 图－邻接表法</p> 
<p>代码中的Stack为辅助结构，用来记载访问过的节点。栈的详细描述可以见：ArrayStack 栈 ，LinkedStack 栈 。</p> 
<p>Vertex表示图中的节点，其中包含访问，是否访问，清除访问标志的方法。 Graph.main：提供简单测试。代码可以以指定下标的节点开始作深度遍历。 代码比较简单，除了Graph.dsf(int i)深度优先遍历算法外没有过多注释。</p> 
<blockquote> 
 <h3><span style="color:#0d0016;"><strong>广度优先搜索(</strong>BFS)</span></h3> 
</blockquote> 
<p> <span style="background-color:#38d8f0;">广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法</span>。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。</p> 
<p><strong><span style="color:#ffd900;"> </span><span style="color:#0d0016;"><span style="background-color:#ffd900;">作法:</span></span></strong></p> 
<p>BFS是一种盲目搜索法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能地址，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。</p> 
<p>从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实现里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。（open-closed表）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/78/b1/QzcyUkL0_o.jpg"></p> 
<blockquote> 
 <h3><span style="color:#0d0016;"><strong>A*搜索算法</strong> </span></h3> 
</blockquote> 
<p> <span style="background-color:#38d8f0;">A*算法是一种静态路网中求解最短路最有效的直接搜索方法。</span>之后涌现了很多预处理算法（ALT，CH，HL等等），在线查询效率是A*算法的数千甚至上万倍。</p> 
<p>A*算法操作：首先将起始结点S放入OPEN表，CLOSE表置空，算法描述：</p> 
<p>1、如果OPEN表不为空，从表头取一个结点n，如果为空算法失败。</p> 
<p>2、n是目标解吗？是，找到一个解（继续寻找，或终止算法）。</p> 
<p>3、将n的所有后继结点展开，就是从n可以直接关联的子结点，如果不在CLOSE表中，就将它们放入OPEN表，并把S放入CLOSE表，同时计算每一个后继结点的估价值f(n)，将OPEN表按f(x)排序，最小的放在表头，重复算法，回到1。</p> 
<blockquote> 
 <h3><span style="color:#0d0016;"><strong>Dijkstra算法</strong></span></h3> 
</blockquote> 
<p><strong><span style="background-color:#38d8f0;">戴克斯特拉算法</span></strong><span style="background-color:#38d8f0;">（又译</span><strong><span style="background-color:#38d8f0;">迪杰斯特拉算法</span></strong><span style="background-color:#38d8f0;">） 是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。</span>迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p> 
<p>Dijkstra算法采用的是一种贪心的策略，基本算法思想：</p> 
<p>1、通过Dijkstra计算图G中的最短路径时，需要指定起点s。</p> 
<p>2、引进两个集合S和U。S的作用是记录已求出最短路径的顶点，而U则是记录还未求出最短路径的顶点。</p> 
<p>3、初始时，S中只有起点s，U中是除s之外的顶点，并且U中顶点的路径是"起点s到该顶点的路径"。然后，从U中找出路径最短的顶点，并将其加入到S中；更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9b/80/7EGPuTPS_o.jpg"></p> 
<blockquote> 
 <h3><strong>Bellman-Ford算法</strong> </h3> 
</blockquote> 
<p>Bellman - ford算法是求含负权图的单源最短路径的一种算法，其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在n-1次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。</p> 
<p style="text-align:center;"><img alt="" height="160" src="https://images2.imgbox.com/80/e6/CELhzHb4_o.png" width="149"></p> 
<p> Bellman-Ford算法能在更普遍的情况下解决单源点最短路径问题，算法描述：</p> 
<p>1、初始化：将除源点外的所有顶点的最短距离估计值。</p> 
<p>2、迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离。</p> 
<p>3、检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解。否则算法返回true，并且从源点可达的顶点v的最短距离保存在集合dist[v]中。</p> 
<blockquote> 
 <h3> <strong>Floyd-Warshall算法</strong></h3> 
</blockquote> 
<p>Floyd-Warshall算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题。</p> 
<p><strong><span style="background-color:#ffd900;">算法思想：</span></strong></p> 
<p>1、创建源顶点 v 到图中所有顶点的距离的集合S，为图中的所有顶点指定一个距离值，初始均为I，源顶点距离为0。</p> 
<p>2、计算最短路径，执行 V - 1 次遍历。</p> 
<p>3、对于图中的每条边：如果起点u的距离d 加上边的权值w小于终点v的距离d，则更新终点v的距离值d。</p> 
<p>4.检测图中是否有负权边形成了环，遍历图中的所有边，计算u至v的距离，如果对于v存在更小的距离，则说明存在环。</p> 
<blockquote> 
 <h3><strong>Prim算法</strong></h3> 
</blockquote> 
<p> 图论的一种算法，可在加权连通图里搜索最小生成树。由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。</p> 
<p>Prim算法在找当前最近顶点时使用到了贪婪算法，算法描述：</p> 
<p>1、 在一个加权连通图中，顶点集合V，边集合为E。</p> 
<p>2、任意选出一个点作为初始顶点,标记为visit,计算所有与之相连接的点的距离，选择距离最短的，标记visit。</p> 
<p>3、在剩下的点，计算与已标记visit点距离最小的点，标记visit,证明加入了最小生成树，重复操作，直到所有点都被标记为visit。</p> 
<p style="text-align:center;"><img alt="" height="137" src="https://images2.imgbox.com/df/56/FQ0jckeb_o.png" width="164"></p> 
<blockquote> 
 <h3><strong>Kruskal算法</strong> </h3> 
</blockquote> 
<p>Kruskal算法是一种用来寻找最小生成树的算法,在剩下的所有未选取的边中，找最小边，如果和已选取的边构成回路，则放弃，选取次小边。</p> 
<p>Kruskal算法就是基于并查集的贪心算法,算法描述：</p> 
<p>1、将图G看做一个森林，每个顶点为一棵独立的树。</p> 
<p>2、将所有的边加入集合S，即一开始S = E 。</p> 
<p>3、从S中拿出一条最短的边(u,v)，如果(u,v)不在同一棵树内，则连接u,v合并这两棵树，同时将(u,v)加入生成树的边集E'。</p> 
<p>4、重复3直到所有点属于同一棵树，边集E'就是一棵最小生成树。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c7/24/XfrNPgg9_o.png"></p> 
<blockquote> 
 <h3> <strong>匈牙利算法</strong></h3> 
</blockquote> 
<p><strong><span style="background-color:#38d8f0;">匈牙利算法</span></strong><span style="background-color:#38d8f0;">是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。</span>美国数学家哈罗德·库恩于1955年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家Dénes Kőnig和Jenő Egerváry的工作之上创建起来的。</p> 
<p style="text-align:center;"><img alt="" height="185" src="https://images2.imgbox.com/f6/cf/Gd1RapzI_o.png" width="225"></p> 
<p>算法轮廓：</p> 
<p>1、置M为空</p> 
<p>2、找出一条增广路径P，通过异或操作获得更大的匹配M'代替M.</p> 
<p>3、重复2操作直到找不出增广路径为止。</p> 
<blockquote> 
 <h3><strong>Ford-Fulkerson算法</strong></h3> 
</blockquote> 
<p> 也称最大流量算法，常用于作为一个距离向量路由协议例如RIP， BGP， ISO IDRP， NOVELL IPX的算法。</p> 
<p>Ford-Fulkerson 算法是一种迭代方法。开始时，对所有 u, v ∈ V 有 f(u, v) = 0，即初始状态时流的值为 0。在每次迭代中，可通过寻找一条增广路径来增加流值。增广路径可以看做是从源点 s 到汇点 t 之间的一条路径，沿该路径可以压入更多的流，从而增加流的值。反复进行这一过程，直至增广路径都被找出为止。</p> 
<p><strong><span style="background-color:#ffd900;">复杂:</span></strong></p> 
<p>通过将流量增加路径添加到已在图中建立的流量，当在图表中不再能够找到流量增加路径时，将达到最大流量。但是，无法确定是否会达到这种情况，因此可以保证的最佳方案是，如果算法终止，答案将是正确的。在算法永远运行的情况下，流可能甚至不会收敛到最大流量。但是，这种情况只发生在不合理的流量值。当容量为整数时，Ford-Fulkerson的运行时间受O（E f）的限制（参见大O表示法），其中E是数字图中的边和f是图中的最大流量。这是因为每个扩充路径都可以在O（E））时间内找到并且将流量增加至少1 的整数量，其上限f 。</p> 
<p>具有保证终止和独立于最大流量值的运行时间的Ford-Fulkerson算法的变体是Edmonds-Karp算法，该算法在中运行O(VE2)时间。</p> 
<hr> 
<p> 小编整理了有关人工智能的资料，有python基础，图像处理opencv\自然语言处理、机器学习<br> 数学基础等资源库，想学习人工智能或者转行到高薪资行业的，大学生也非常实用，无任<br> 何套路免费提供,，加我裙【<strong><span style="color:#fe2c24;">966367816</span></strong>】下载，或者<strong><span style="color:#fe2c24;">扫码+vx</span></strong>（更方便） 也可以领取的内部资源，人工智能题库，大厂面试题 学习大纲 自学课程大纲还有200G人工智能资料大礼包免费送哦~ </p> 
<p style="text-align:center;">欢迎大家扫码撩我呀~</p> 
<p style="text-align:center;"><img alt="" height="150" src="https://images2.imgbox.com/cc/e0/Sebm6CKv_o.png" width="150"></p> 
<p></p> 
<p><br>  </p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0e747af7e0aa8e91c14cca64d845dc0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电子产品历史价格怎么查？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d63276574b050957abde9fba16e7e72/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">moment 时间类型的转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>