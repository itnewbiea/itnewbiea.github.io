<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP-4次挥手小记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP-4次挥手小记" />
<meta property="og:description" content="简介 本篇读完需要10分钟,读完能了解:
TCP4次挥手
为什么要4次挥手
TIME_WAIT等待2MSL的原因
TCP故障检测
相关阅读 目录
断开连接过程(4次挥手) TIPS 三次挥手会有什么问题
B向A发送链接释放报文(FIN=1,ACK=1)后直接断开连接，如果A没有收到这个FIN数据包，A就会一直处于FINT-WAIT-2状态
等待2MSL(最大报文段生存时间)原因
网络不可靠的情况,会出现最后一个ACK丢失。B如果没有收到ACK，将不断重复发送FIN片段。A会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么A会重发ACK并再次等待2MSL。2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个keepalive计时器，服务器每收到一次客户端的请求后都会重新Reset这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
TIME_WAIT扩展 场景: 在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。
查询现象: netstat -ant|awk ‘/^tcp/ {&#43;&#43;S[$NF]} END {for(a in S) print (a,S[a])}’
LAST_ACK 14
SYN_RECV 348
ESTABLISHED 70
FIN_WAIT1 229
FIN_WAIT2 30
CLOSING 33
TIME_WAIT 18122
处理: 编辑内核文件/etc/sysctl.conf，加入以下内容： net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT
sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1
表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout
修改系默认的 TIMEOUT 时间 然后执行 /sbin/sysctl -p 让参数生效." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/65f055e442cff52414e2d53f6912f07a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-09T15:58:33+08:00" />
<meta property="article:modified_time" content="2022-09-09T15:58:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP-4次挥手小记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>简介</h2> 
<p>本篇读完需要10分钟,读完能了解:</p> 
<ol><li> <p>TCP4次挥手</p> </li><li> <p>为什么要4次挥手</p> </li><li> <p>TIME_WAIT等待2MSL的原因</p> </li><li> <p>TCP故障检测</p> </li></ol> 
<h2><a id="_11"></a>相关阅读</h2> 
<p><a href="https://blog.csdn.net/qq_21078159/article/details/121957175">目录</a></p> 
<h2><a id="4_13"></a>断开连接过程(4次挥手)</h2> 
<p><img src="https://images2.imgbox.com/12/f6/wQ18GfS7_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="TIPS_16"></a>TIPS</h2> 
<blockquote> 
 <p><strong>三次挥手会有什么问题</strong><br> B向A发送链接释放报文(FIN=1,ACK=1)后直接断开连接，如果A没有收到这个FIN数据包，A就会一直处于FINT-WAIT-2状态<br> <strong>等待2MSL(最大报文段生存时间)原因</strong><br> 网络不可靠的情况,会出现最后一个ACK丢失。B如果没有收到ACK，将不断重复发送FIN片段。A会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么A会重发ACK并再次等待2MSL。2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。<br> <strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong><br> TCP还设有一个keepalive计时器，服务器每收到一次客户端的请求后都会重新Reset这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p> 
</blockquote> 
<h2><a id="TIME_WAIT_25"></a>TIME_WAIT扩展</h2> 
<blockquote> 
 <p><strong>场景</strong>: 在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。<br> <strong>查询现象:</strong> netstat -ant|awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}’</p> 
 <p>LAST_ACK 14</p> 
 <p>SYN_RECV 348</p> 
 <p>ESTABLISHED 70</p> 
 <p>FIN_WAIT1 229</p> 
 <p>FIN_WAIT2 30</p> 
 <p>CLOSING 33</p> 
 <p>TIME_WAIT 18122<br> <strong>处理:</strong> 编辑内核文件/etc/sysctl.conf，加入以下内容： net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br> net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT<br> sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1<br> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout<br> 修改系默认的 TIMEOUT 时间 然后执行 /sbin/sysctl -p 让参数生效.</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce31482044dad4ec0bb90122640eeb24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jetpack（二）—— ViewModel</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d63806f7e82b00d440f86dc1d625b2b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python MQTT订阅消息QOS=1的注意点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>