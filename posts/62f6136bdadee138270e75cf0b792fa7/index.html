<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>流媒体学习之路(WebRTC)——GCC分析（4） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="流媒体学习之路(WebRTC)——GCC分析（4）" />
<meta property="og:description" content="流媒体学习之路(WebRTC)——GCC分析（4） —— 我正在的github给大家开发一个用于做实验的项目 —— github.com/qw225967/Bifrost 目标：可以让大家熟悉各类Qos能力、带宽估计能力，提供每个环节关键参数调节接口并实现一个json全配置，提供全面的可视化算法观察能力。 欢迎大家使用 —— 文章目录 流媒体学习之路(WebRTC)——GCC分析（4）一、间隔计算（InterArrival）1.1 模块介绍1.2 代码 二、码率控制（AimdRateControl）2.1 背景2.2 代码 三、总结 在讲具体内容之前插一句嘴，从GCC分析（3）开始，我们将针对GCC的实现细节去分析它设计的原理，让我们理解这些类存在的意义，不再带大家去串具体的流程了。
一、间隔计算（InterArrival） 1.1 模块介绍 WebRTC 的 InterArrival 类是用于计算包之间的到达时间差(Inter-Arrival Time)的类。 如果观察WebRTC的提交记录你会发现，这个类随着卡尔曼滤波器、趋势线等等算法的变更也一直在调整。那么为什么要存在这个接收间隔的计算类呢？
细心的小伙伴在观察我们发送视频数据的时候会发现，数据的发送是一股一股的——常常是一次发送几个包。
这是因为我们采集的数据帧大小是实时变化的每次可发送的数据量都不一样，而pacer发送是依赖于定时器去触发发送事件的，这样的触发模式有两种：周期模式（kPeriodic）、动态模式（kDynamic）——后来好像动态模式的代码被移除了，但是我们今天不是关注pacer的问题，而是补充一些小知识。
周期模式中，定时5ms会触发一次发送；
动态模式中，每次都会计算下一次触发发送的时间;
可以直观的理解为，当数据在接收端产生接收间隔增大时，这个间隔不仅仅是网络导致的，还有可能是发送时就已经造成了间隔增大。那么我们想把这个间隔计算出来也就需要发送端记录自己的发送时间了，InterArrival这个类就做这些变化的校准。
1.2 代码 该部分最重要的代码是在延迟估计IncomingPacketFeedback调用的，下面展示一部分伪代码
void DelayBasedBwe::IncomingPacketFeedback(const PacketResult&amp; packet_feedback, Timestamp at_time) { ... uint32_t ts_delta = 0; int64_t t_delta = 0; int size_delta = 0; // 校准接收间隔 bool calculated_deltas = inter_arrival_-&gt;ComputeDeltas( timestamp, packet_feedback.receive_time.ms(), at_time.ms(), packet_feedback.sent_packet.size.bytes(), &amp;ts_delta, &amp;t_delta, &amp;size_delta); double ts_delta_ms = (1000." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/62f6136bdadee138270e75cf0b792fa7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T10:17:28+08:00" />
<meta property="article:modified_time" content="2024-01-02T10:17:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">流媒体学习之路(WebRTC)——GCC分析（4）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="WebRTCGCC4_0"></a>流媒体学习之路(WebRTC)——GCC分析（4）</h2> 
<pre><code>——
我正在的github给大家开发一个用于做实验的项目 —— github.com/qw225967/Bifrost

目标：可以让大家熟悉各类Qos能力、带宽估计能力，提供每个环节关键参数调节接口并实现一个json全配置，提供全面的可视化算法观察能力。

欢迎大家使用
——
</code></pre> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#WebRTCGCC4_0" rel="nofollow">流媒体学习之路(WebRTC)——GCC分析（4）</a></li><li><a href="#InterArrival_18" rel="nofollow">一、间隔计算（InterArrival）</a></li><li><ul><li><a href="#11__19" rel="nofollow">1.1 模块介绍</a></li><li><a href="#12__32" rel="nofollow">1.2 代码</a></li></ul> 
  </li><li><a href="#AimdRateControl_225" rel="nofollow">二、码率控制（AimdRateControl）</a></li><li><ul><li><a href="#21__226" rel="nofollow">2.1 背景</a></li><li><a href="#22__252" rel="nofollow">2.2 代码</a></li></ul> 
  </li><li><a href="#_495" rel="nofollow">三、总结</a></li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<p>  在讲具体内容之前插一句嘴，从GCC分析（3）开始，我们将针对GCC的实现细节去分析它设计的原理，让我们理解这些类存在的意义，不再带大家去串具体的流程了。</p> 
<h2><a id="InterArrival_18"></a>一、间隔计算（InterArrival）</h2> 
<h3><a id="11__19"></a>1.1 模块介绍</h3> 
<p>  WebRTC 的 InterArrival 类是用于计算包之间的到达时间差(Inter-Arrival Time)的类。 如果观察WebRTC的提交记录你会发现，这个类随着卡尔曼滤波器、趋势线等等算法的变更也一直在调整。那么为什么要存在这个接收间隔的计算类呢？</p> 
<p><img src="https://images2.imgbox.com/24/56/I50oQoWE_o.png" alt="在这里插入图片描述"></p> 
<p>  细心的小伙伴在观察我们发送视频数据的时候会发现，数据的发送是一股一股的——常常是一次发送几个包。<br>   这是因为我们采集的数据帧大小是实时变化的每次可发送的数据量都不一样，而pacer发送是依赖于定时器去触发发送事件的，这样的触发模式有两种：周期模式（kPeriodic）、动态模式（kDynamic）——后来好像动态模式的代码被移除了，但是我们今天不是关注pacer的问题，而是补充一些小知识。</p> 
<p>  周期模式中，定时5ms会触发一次发送；<br>   动态模式中，每次都会计算下一次触发发送的时间;</p> 
<p>  <strong>可以直观的理解为，当数据在接收端产生接收间隔增大时，这个间隔不仅仅是网络导致的，还有可能是发送时就已经造成了间隔增大。那么我们想把这个间隔计算出来也就需要发送端记录自己的发送时间了，InterArrival这个类就做这些变化的校准。</strong></p> 
<h3><a id="12__32"></a>1.2 代码</h3> 
<p>  该部分最重要的代码是在延迟估计IncomingPacketFeedback调用的，下面展示一部分伪代码</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> DelayBasedBwe<span class="token operator">::</span><span class="token function">IncomingPacketFeedback</span><span class="token punctuation">(</span><span class="token keyword">const</span> PacketResult<span class="token operator">&amp;</span> packet_feedback<span class="token punctuation">,</span>
                                           Timestamp at_time<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token class-name">uint32_t</span> ts_delta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token class-name">int64_t</span> t_delta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> size_delta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 校准接收间隔</span>
  bool calculated_deltas <span class="token operator">=</span> inter_arrival_<span class="token operator">-&gt;</span><span class="token function">ComputeDeltas</span><span class="token punctuation">(</span>
      timestamp<span class="token punctuation">,</span> packet_feedback<span class="token punctuation">.</span>receive_time<span class="token punctuation">.</span><span class="token function">ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> at_time<span class="token punctuation">.</span><span class="token function">ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      packet_feedback<span class="token punctuation">.</span>sent_packet<span class="token punctuation">.</span>size<span class="token punctuation">.</span><span class="token function">bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ts_delta<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t_delta<span class="token punctuation">,</span>
      <span class="token operator">&amp;</span>size_delta<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> ts_delta_ms <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1000.0</span> <span class="token operator">*</span> ts_delta<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> kInterArrivalShift<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 把间隔放入检测器进行拥塞检测</span>
  delay_detector_<span class="token operator">-&gt;</span><span class="token function">Update</span><span class="token punctuation">(</span>t_delta<span class="token punctuation">,</span> ts_delta_ms<span class="token punctuation">,</span>
                          packet_feedback<span class="token punctuation">.</span>sent_packet<span class="token punctuation">.</span>send_time<span class="token punctuation">.</span><span class="token function">ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                          packet_feedback<span class="token punctuation">.</span>receive_time<span class="token punctuation">.</span><span class="token function">ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> calculated_deltas<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  ComputeDeltas里面细分了每个包组的概念，将包组的间隔区分出来保证我们计算的准确度：</p> 
<pre><code class="prism language-c">bool InterArrival<span class="token operator">::</span><span class="token function">ComputeDeltas</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> timestamp<span class="token punctuation">,</span> <span class="token class-name">int64_t</span> arrival_time_ms<span class="token punctuation">,</span>
                                 <span class="token class-name">int64_t</span> system_time_ms<span class="token punctuation">,</span> <span class="token class-name">size_t</span> packet_size<span class="token punctuation">,</span>
                                 <span class="token class-name">uint32_t</span><span class="token operator">*</span> timestamp_delta<span class="token punctuation">,</span>
                                 <span class="token class-name">int64_t</span><span class="token operator">*</span> arrival_time_delta_ms<span class="token punctuation">,</span>
                                 <span class="token keyword">int</span><span class="token operator">*</span> packet_size_delta<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 传入参数：</span>
  <span class="token comment">// timestamp 数据发送的时间戳</span>
  <span class="token comment">// arrival_time_ms 对端接收到数据的时间戳</span>
  <span class="token comment">// system_time_ms 当前系统时间，其实是feedback接到的时间</span>
  <span class="token comment">// packet_size 当前数据包的大小</span>
  <span class="token comment">// 输出内容 —— timestamp_delta 发送间隔</span>
  <span class="token comment">// 输出内容 —— arrival_time_delta_ms 接收间隔</span>
  <span class="token comment">// 输出内容 —— packet_size_delta 两个包组直接包数量的差值</span>

  bool calculated_deltas <span class="token operator">=</span> false<span class="token punctuation">;</span>
  <span class="token comment">// 第一个包组，记录信息</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current_timestamp_group_<span class="token punctuation">.</span><span class="token function">IsFirstPacket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// We don't have enough data to update the filter, so we store it until we</span>
    <span class="token comment">// have two frames of data to process.</span>
    current_timestamp_group_<span class="token punctuation">.</span>timestamp <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>
    current_timestamp_group_<span class="token punctuation">.</span>first_timestamp <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>
    current_timestamp_group_<span class="token punctuation">.</span>first_arrival_ms <span class="token operator">=</span> arrival_time_ms<span class="token punctuation">;</span>

  <span class="token comment">// 连续包组返回</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">PacketInOrder</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">,</span> arrival_time_ms<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>

  <span class="token comment">// 新包组开始计算间隔</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">NewTimestampGroup</span><span class="token punctuation">(</span>arrival_time_ms<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// First packet of a later frame, the previous frame sample is ready.</span>
    <span class="token comment">// 第一个包组不计算，后续包组开始计算</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_timestamp_group_<span class="token punctuation">.</span>complete_time_ms <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 记录包组之间的发送间隔</span>
      <span class="token operator">*</span>timestamp_delta <span class="token operator">=</span>
          current_timestamp_group_<span class="token punctuation">.</span>timestamp <span class="token operator">-</span> prev_timestamp_group_<span class="token punctuation">.</span>timestamp<span class="token punctuation">;</span>
      <span class="token comment">// 记录包组之间的接收间隔</span>
      <span class="token operator">*</span>arrival_time_delta_ms <span class="token operator">=</span> current_timestamp_group_<span class="token punctuation">.</span>complete_time_ms <span class="token operator">-</span>
                               prev_timestamp_group_<span class="token punctuation">.</span>complete_time_ms<span class="token punctuation">;</span>
      <span class="token comment">// Check system time differences to see if we have an unproportional jump</span>
      <span class="token comment">// in arrival time. In that case reset the inter-arrival computations.</span>
      <span class="token comment">// 计算系统时间变化，防止系统时间跳变影响计算</span>
      <span class="token class-name">int64_t</span> system_time_delta_ms <span class="token operator">=</span>
          current_timestamp_group_<span class="token punctuation">.</span>last_system_time_ms <span class="token operator">-</span>
          prev_timestamp_group_<span class="token punctuation">.</span>last_system_time_ms<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>arrival_time_delta_ms <span class="token operator">-</span> system_time_delta_ms <span class="token operator">&gt;=</span>
          kArrivalTimeOffsetThresholdMs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

	  <span class="token comment">// 对端的接收时间戳可能已经生变化，影响计算</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>arrival_time_delta_ms <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// The group of packets has been reordered since receiving its local</span>
        <span class="token comment">// arrival timestamp.</span>
        <span class="token operator">++</span>num_consecutive_reordered_packets_<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>num_consecutive_reordered_packets_ <span class="token operator">&gt;=</span> kReorderedResetThreshold<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        num_consecutive_reordered_packets_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      
      <span class="token comment">// 计算两个包组的数据量差值</span>
      <span class="token operator">*</span>packet_size_delta <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>current_timestamp_group_<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">-</span>
                           static_cast<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>prev_timestamp_group_<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
      calculated_deltas <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	
	<span class="token comment">// 更新数据</span>
    prev_timestamp_group_ <span class="token operator">=</span> current_timestamp_group_<span class="token punctuation">;</span>
    <span class="token comment">// The new timestamp is now the current frame.</span>
    current_timestamp_group_<span class="token punctuation">.</span>first_timestamp <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>
    current_timestamp_group_<span class="token punctuation">.</span>timestamp <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>
    current_timestamp_group_<span class="token punctuation">.</span>first_arrival_ms <span class="token operator">=</span> arrival_time_ms<span class="token punctuation">;</span>
    current_timestamp_group_<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    current_timestamp_group_<span class="token punctuation">.</span>timestamp <span class="token operator">=</span>
        <span class="token function">LatestTimestamp</span><span class="token punctuation">(</span>current_timestamp_group_<span class="token punctuation">.</span>timestamp<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Accumulate the frame size.</span>
  current_timestamp_group_<span class="token punctuation">.</span>size <span class="token operator">+=</span> packet_size<span class="token punctuation">;</span>
  current_timestamp_group_<span class="token punctuation">.</span>complete_time_ms <span class="token operator">=</span> arrival_time_ms<span class="token punctuation">;</span>
  current_timestamp_group_<span class="token punctuation">.</span>last_system_time_ms <span class="token operator">=</span> system_time_ms<span class="token punctuation">;</span>

  <span class="token keyword">return</span> calculated_deltas<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool InterArrival<span class="token operator">::</span><span class="token function">PacketInOrder</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> timestamp<span class="token punctuation">,</span> <span class="token class-name">int64_t</span> arrival_time_ms<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current_timestamp_group_<span class="token punctuation">.</span><span class="token function">IsFirstPacket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arrival_time_ms <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// NOTE: Change related to</span>
    <span class="token comment">// https://github.com/versatica/mediaproxy/issues/357</span>
    <span class="token comment">//</span>
    <span class="token comment">// Sometimes we do get negative arrival time, which causes BelongsToBurst()</span>
    <span class="token comment">// to fail, which may cause anything that uses InterArrival to crash.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Credits to @sspanak and @Ivaka.</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Assume that a diff which is bigger than half the timestamp interval</span>
    <span class="token comment">// (32 bits) must be due to reordering. This code is almost identical to</span>
    <span class="token comment">// that in IsNewerTimestamp() in module_common_types.h.</span>
    <span class="token class-name">uint32_t</span> timestamp_diff <span class="token operator">=</span>
        timestamp <span class="token operator">-</span> current_timestamp_group_<span class="token punctuation">.</span>first_timestamp<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token class-name">uint32_t</span> int_middle <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>

    <span class="token comment">// 处理跳变</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timestamp_diff <span class="token operator">==</span> int_middle<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> timestamp <span class="token operator">&gt;</span> current_timestamp_group_<span class="token punctuation">.</span>first_timestamp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> timestamp_diff <span class="token operator">&lt;</span> int_middle<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Assumes that |timestamp| is not reordered compared to</span>
<span class="token comment">// |current_timestamp_group_|.</span>
bool InterArrival<span class="token operator">::</span><span class="token function">NewTimestampGroup</span><span class="token punctuation">(</span><span class="token class-name">int64_t</span> arrival_time_ms<span class="token punctuation">,</span>
                                     <span class="token class-name">uint32_t</span> timestamp<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current_timestamp_group_<span class="token punctuation">.</span><span class="token function">IsFirstPacket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
  
  <span class="token comment">// 计算突发数据，确认突发数据直接返回</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">BelongsToBurst</span><span class="token punctuation">(</span>arrival_time_ms<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 差值大于5ms就认为是下一个发送周期</span>
    <span class="token class-name">uint32_t</span> timestamp_diff <span class="token operator">=</span>
        timestamp <span class="token operator">-</span> current_timestamp_group_<span class="token punctuation">.</span>first_timestamp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> timestamp_diff <span class="token operator">&gt;</span> kTimestampGroupLengthTicks<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

bool InterArrival<span class="token operator">::</span><span class="token function">BelongsToBurst</span><span class="token punctuation">(</span><span class="token class-name">int64_t</span> arrival_time_ms<span class="token punctuation">,</span>
                                  <span class="token class-name">uint32_t</span> timestamp<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>burst_grouping_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 计算于上一个发送时间、接收时间的差值</span>
  <span class="token class-name">int64_t</span> arrival_time_delta_ms <span class="token operator">=</span>
      arrival_time_ms <span class="token operator">-</span> current_timestamp_group_<span class="token punctuation">.</span>complete_time_ms<span class="token punctuation">;</span>
  <span class="token class-name">uint32_t</span> timestamp_diff <span class="token operator">=</span> timestamp <span class="token operator">-</span> current_timestamp_group_<span class="token punctuation">.</span>timestamp<span class="token punctuation">;</span>
  
  <span class="token comment">// 当发送间隔转为ms后差值在0.5浮动范围内</span>
  <span class="token class-name">int64_t</span> ts_delta_ms <span class="token operator">=</span> timestamp_to_ms_coeff_ <span class="token operator">*</span> timestamp_diff <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ts_delta_ms <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span>
  
  <span class="token comment">// 一旦接收间隔比发送间隔加上浮动值0.5还小，证明这些包连续发送</span>
  <span class="token keyword">int</span> propagation_delta_ms <span class="token operator">=</span> arrival_time_delta_ms <span class="token operator">-</span> ts_delta_ms<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>propagation_delta_ms <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">/* 连续发送 */</span>
      arrival_time_delta_ms <span class="token operator">&lt;=</span> kBurstDeltaThresholdMs <span class="token operator">&amp;&amp;</span> <span class="token comment">/* 处于同一发送周期 */</span>
      arrival_time_ms <span class="token operator">-</span> current_timestamp_group_<span class="token punctuation">.</span>first_arrival_ms <span class="token operator">&lt;</span>
          kMaxBurstDurationMs<span class="token punctuation">)</span>  <span class="token comment">/* 最大异常值限制 */</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
  <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  经过该模块后就会进入TrendLine模块进行趋势计算，获得当前的拥塞情况。</p> 
<h2><a id="AimdRateControl_225"></a>二、码率控制（AimdRateControl）</h2> 
<h3><a id="21__226"></a>2.1 背景</h3> 
<p>  本系列文章GCC(3)提到了ack计算模块以及链路容量计算模块，事实上这两个模块在码率控制类中计算出了最终的码率。ack链路容量计算出完后输入到码率计算模块，码率区分上涨、下调、维持不变三种情况，他们所有的状态变化都取决于趋势线计算出来的状态。</p> 
<p>  状态机切换大家都很熟悉，就是下面这张图（来自于谷歌公开的Performance Analysis of Google Congestion Control Algorithm for WebRTC文章）：<br> <img src="https://images2.imgbox.com/72/10/s6r1vwXJ_o.png" alt="在这里插入图片描述"><br>   网络状态分为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">BandwidthUsage</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 网络正常</span>
  kBwNormal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>

  <span class="token comment">// 网络过度使用</span>
  kBwUnderusing <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>

  <span class="token comment">// 网络正在排空</span>
  kBwOverusing <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
  kLast
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  把趋势线的斜率图像化，可以看出来这几个状态在整个趋势计算的过程中是下图这样变化的：</p> 
<p><img src="https://images2.imgbox.com/0a/4b/YhmLVty6_o.png" alt="在这里插入图片描述"><br>   之所以这样设计是因为，<strong>GCC思想希望保证整体的流畅性，整体非常敏感。码率下调很快，上涨则是比较缓慢的。状态上，随时可以进入overusing状态，但是上涨却不是立刻进行的，而是先转入hold状态再继续上探</strong>。</p> 
<h3><a id="22__252"></a>2.2 代码</h3> 
<p>  这里展示一下代码中状态切换的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token class-name">AimdRateControl</span><span class="token double-colon punctuation">::</span><span class="token function">ChangeState</span><span class="token punctuation">(</span><span class="token keyword">const</span> RateControlInput<span class="token operator">&amp;</span> input<span class="token punctuation">,</span>
                                  Timestamp at_time<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>bw_state<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> BandwidthUsage<span class="token double-colon punctuation">::</span>kBwNormal<span class="token operator">:</span>
      <span class="token comment">// 只有hold状态能进入码率上涨</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>rate_control_state_ <span class="token operator">==</span> kRcHold<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        time_last_bitrate_change_ <span class="token operator">=</span> at_time<span class="token punctuation">;</span>
        rate_control_state_ <span class="token operator">=</span> kRcIncrease<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> BandwidthUsage<span class="token double-colon punctuation">::</span>kBwOverusing<span class="token operator">:</span>
      <span class="token comment">// 出现网络过度使用时下调码率</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>rate_control_state_ <span class="token operator">!=</span> kRcDecrease<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        rate_control_state_ <span class="token operator">=</span> kRcDecrease<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> BandwidthUsage<span class="token double-colon punctuation">::</span>kBwUnderusing<span class="token operator">:</span>
      <span class="token comment">// 当网络开始排空时先转成hold状态</span>
      rate_control_state_ <span class="token operator">=</span> kRcHold<span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  码率计算：</p> 
<pre><code class="prism language-cpp">DataRate <span class="token class-name">AimdRateControl</span><span class="token double-colon punctuation">::</span><span class="token function">ChangeBitrate</span><span class="token punctuation">(</span>DataRate new_bitrate<span class="token punctuation">,</span>
                                        <span class="token keyword">const</span> RateControlInput<span class="token operator">&amp;</span> input<span class="token punctuation">,</span>
                                        Timestamp at_time<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 取出吞吐量估计值</span>
  DataRate estimated_throughput <span class="token operator">=</span>
      input<span class="token punctuation">.</span>estimated_throughput<span class="token punctuation">.</span><span class="token function">value_or</span><span class="token punctuation">(</span>latest_estimated_throughput_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>estimated_throughput<span class="token punctuation">)</span>
    latest_estimated_throughput_ <span class="token operator">=</span> <span class="token operator">*</span>input<span class="token punctuation">.</span>estimated_throughput<span class="token punctuation">;</span>

  <span class="token comment">// An over-use should always trigger us to reduce the bitrate, even though</span>
  <span class="token comment">// we have not yet established our first estimate. By acting on the over-use,</span>
  <span class="token comment">// we will end up with a valid estimate.</span>
  <span class="token comment">// 初始阶段，只要不是网络拥塞就不进行以下逻辑计算</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bitrate_is_initialized_ <span class="token operator">&amp;&amp;</span>
      input<span class="token punctuation">.</span>bw_state <span class="token operator">!=</span> BandwidthUsage<span class="token double-colon punctuation">::</span>kBwOverusing<span class="token punctuation">)</span>
    <span class="token keyword">return</span> current_bitrate_<span class="token punctuation">;</span>

  <span class="token comment">// 状态切换</span>
  <span class="token function">ChangeState</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> at_time<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">switch</span> <span class="token punctuation">(</span>rate_control_state_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// hold状态直接返回</span>
    <span class="token keyword">case</span> kRcHold<span class="token operator">:</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> kRcIncrease<span class="token operator">:</span>
      <span class="token comment">// 吞吐量估计大于了链路容量统计，则重置容量统计</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>estimated_throughput <span class="token operator">&gt;</span> link_capacity_<span class="token punctuation">.</span><span class="token function">UpperBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        link_capacity_<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Do not increase the delay based estimate in alr since the estimator</span>
      <span class="token comment">// will not be able to get transport feedback necessary to detect if</span>
      <span class="token comment">// the new estimate is correct.</span>
      
      <span class="token comment">// alr状态下可以根据no_bitrate_increase_in_alr_决定是否继续进行码率增长</span>
      <span class="token comment">// 当alr状态下持续码率增长，一旦出现码率暴增发送码率就会爆发式增大</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>send_side_ <span class="token operator">&amp;&amp;</span> in_alr_ <span class="token operator">&amp;&amp;</span> no_bitrate_increase_in_alr_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        
        <span class="token comment">// 计算出链路容量则进入加性增，因为当前瓶颈已知</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>link_capacity_<span class="token punctuation">.</span><span class="token function">has_estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// The link_capacity estimate is reset if the measured throughput</span>
          <span class="token comment">// is too far from the estimate. We can therefore assume that our</span>
          <span class="token comment">// target rate is reasonably close to link capacity and use additive</span>
          <span class="token comment">// increase.</span>
          DataRate additive_increase <span class="token operator">=</span>
              <span class="token function">AdditiveRateIncrease</span><span class="token punctuation">(</span>at_time<span class="token punctuation">,</span> time_last_bitrate_change_<span class="token punctuation">)</span><span class="token punctuation">;</span>
          new_bitrate <span class="token operator">+=</span> additive_increase<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// If we don't have an estimate of the link capacity, use faster ramp</span>
          <span class="token comment">// up to discover the capacity.</span>
          <span class="token comment">// 未存在里哪路容量则需要乘性增去做探测</span>
          DataRate multiplicative_increase <span class="token operator">=</span> <span class="token function">MultiplicativeRateIncrease</span><span class="token punctuation">(</span>
              at_time<span class="token punctuation">,</span> time_last_bitrate_change_<span class="token punctuation">,</span> new_bitrate<span class="token punctuation">)</span><span class="token punctuation">;</span>
          new_bitrate <span class="token operator">+=</span> multiplicative_increase<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      time_last_bitrate_change_ <span class="token operator">=</span> at_time<span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> kRcDecrease<span class="token operator">:</span>
      <span class="token comment">// TODO(srte): Remove when |estimate_bounded_backoff_| has been validated.</span>
      <span class="token comment">// 取当前链路容量的小值与吞吐量对比取大值，用于激进地下调码率</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>network_estimate_ <span class="token operator">&amp;&amp;</span> capacity_deviation_ratio_threshold_ <span class="token operator">&amp;&amp;</span>
          <span class="token operator">!</span>estimate_bounded_backoff_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        estimated_throughput <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>estimated_throughput<span class="token punctuation">,</span>
                                        network_estimate_<span class="token operator">-&gt;</span>link_capacity_lower<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      
      <span class="token keyword">if</span> <span class="token punctuation">(</span>estimated_throughput <span class="token operator">&gt;</span> low_throughput_threshold_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Set bit rate to something slightly lower than the measured throughput</span>
        <span class="token comment">// to get rid of any self-induced delay.</span>
        <span class="token comment">// 新的码率需要略低于吞吐量，避免引入新的排队导致延迟</span>
        new_bitrate <span class="token operator">=</span> estimated_throughput <span class="token operator">*</span> beta_<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>new_bitrate <span class="token operator">&gt;</span> current_bitrate_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// Avoid increasing the rate when over-using.</span>
          <span class="token comment">// 当此时新的码率仍然高于当前码率，则根据链路容量重新设置新码率</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>link_capacity_<span class="token punctuation">.</span><span class="token function">has_estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            new_bitrate <span class="token operator">=</span> beta_ <span class="token operator">*</span> link_capacity_<span class="token punctuation">.</span><span class="token function">estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
		
		<span class="token comment">// estimate_bounded_backoff_ 称为边界避退，目的是标记在链路容量下限高于当前容量时，使用链路容量下限</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>estimate_bounded_backoff_ <span class="token operator">&amp;&amp;</span> network_estimate_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          new_bitrate <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>
              new_bitrate<span class="token punctuation">,</span> network_estimate_<span class="token operator">-&gt;</span>link_capacity_lower <span class="token operator">*</span> beta_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 吞吐量小于低吞吐的阈值，则直接使用吞吐量</span>
        new_bitrate <span class="token operator">=</span> estimated_throughput<span class="token punctuation">;</span>
		<span class="token comment">// 已经估计出带宽则取吞吐量、带宽的最大值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>link_capacity_<span class="token punctuation">.</span><span class="token function">has_estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          new_bitrate <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>new_bitrate<span class="token punctuation">,</span> link_capacity_<span class="token punctuation">.</span><span class="token function">estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 超过吞吐阈值都使用阈值</span>
        new_bitrate <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>new_bitrate<span class="token punctuation">,</span> low_throughput_threshold_<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

	  <span class="token comment">// 如果当前码率已经很小，则继续使用当前码率 </span>
      new_bitrate <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>new_bitrate<span class="token punctuation">,</span> current_bitrate_<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
      <span class="token keyword">if</span> <span class="token punctuation">(</span>bitrate_is_initialized_ <span class="token operator">&amp;&amp;</span> estimated_throughput <span class="token operator">&lt;</span> current_bitrate_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      	<span class="token comment">// 有可能存在过度下降码率的情况，一旦超过下降的90%，则不使用该码率</span>
        <span class="token keyword">constexpr</span> <span class="token keyword">double</span> kDegradationFactor <span class="token operator">=</span> <span class="token number">0.9</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>smoothing_experiment_ <span class="token operator">&amp;&amp;</span>
            new_bitrate <span class="token operator">&lt;</span> kDegradationFactor <span class="token operator">*</span> beta_ <span class="token operator">*</span> current_bitrate_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// If bitrate decreases more than a normal back off after overuse, it</span>
          <span class="token comment">// indicates a real network degradation. We do not let such a decrease</span>
          <span class="token comment">// to determine the bandwidth estimation period.</span>
          last_decrease_ <span class="token operator">=</span> absl<span class="token double-colon punctuation">::</span>nullopt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 记录该下降的码率</span>
          last_decrease_ <span class="token operator">=</span> current_bitrate_ <span class="token operator">-</span> new_bitrate<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>estimated_throughput <span class="token operator">&lt;</span> link_capacity_<span class="token punctuation">.</span><span class="token function">LowerBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// The current throughput is far from the estimated link capacity. Clear</span>
        <span class="token comment">// the estimate to allow an immediate update in OnOveruseDetected.</span>
        link_capacity_<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
	  
	  <span class="token comment">// 更新状态记录</span>
      bitrate_is_initialized_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      link_capacity_<span class="token punctuation">.</span><span class="token function">OnOveruseDetected</span><span class="token punctuation">(</span>estimated_throughput<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Stay on hold until the pipes are cleared.</span>
      rate_control_state_ <span class="token operator">=</span> kRcHold<span class="token punctuation">;</span>
      time_last_bitrate_change_ <span class="token operator">=</span> at_time<span class="token punctuation">;</span>
      time_last_bitrate_decrease_ <span class="token operator">=</span> at_time<span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 选择码率</span>
  <span class="token keyword">return</span> <span class="token function">ClampBitrate</span><span class="token punctuation">(</span>new_bitrate<span class="token punctuation">,</span> estimated_throughput<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


DataRate <span class="token class-name">AimdRateControl</span><span class="token double-colon punctuation">::</span><span class="token function">ClampBitrate</span><span class="token punctuation">(</span>DataRate new_bitrate<span class="token punctuation">,</span>
                                       DataRate estimated_throughput<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// Allow the estimate to increase as long as alr is not detected to ensure</span>
  <span class="token comment">// that there is no BWE values that can make the estimate stuck at a too</span>
  <span class="token comment">// low bitrate. If an encoder can not produce the bitrate necessary to</span>
  <span class="token comment">// fully use the capacity, alr will sooner or later trigger.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>send_side_ <span class="token operator">&amp;&amp;</span> no_bitrate_increase_in_alr_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Don't change the bit rate if the send side is too far off.</span>
    <span class="token comment">// We allow a bit more lag at very low rates to not too easily get stuck if</span>
    <span class="token comment">// the encoder produces uneven outputs.</span>

    <span class="token comment">// 每次上涨有一个最大的上涨限度，1.5 * 吞吐量 + 10kbps，避免超出吞吐量上涨过多</span>
    <span class="token keyword">const</span> DataRate max_bitrate <span class="token operator">=</span>
        <span class="token number">1.5</span> <span class="token operator">*</span> estimated_throughput <span class="token operator">+</span> <span class="token class-name">DataRate</span><span class="token double-colon punctuation">::</span><span class="token function">kbps</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_bitrate <span class="token operator">&gt;</span> current_bitrate_ <span class="token operator">&amp;&amp;</span> new_bitrate <span class="token operator">&gt;</span> max_bitrate<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      new_bitrate <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>current_bitrate_<span class="token punctuation">,</span> max_bitrate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>network_estimate_ <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>estimate_bounded_increase_ <span class="token operator">||</span> capacity_limit_deviation_factor_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    DataRate upper_bound <span class="token operator">=</span> network_estimate_<span class="token operator">-&gt;</span>link_capacity_upper<span class="token punctuation">;</span>
    new_bitrate <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>new_bitrate<span class="token punctuation">,</span> upper_bound<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  new_bitrate <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>new_bitrate<span class="token punctuation">,</span> min_configured_bitrate_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> new_bitrate<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

DataRate <span class="token class-name">AimdRateControl</span><span class="token double-colon punctuation">::</span><span class="token function">MultiplicativeRateIncrease</span><span class="token punctuation">(</span>
    Timestamp at_time<span class="token punctuation">,</span> Timestamp last_time<span class="token punctuation">,</span> DataRate current_bitrate<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 1.08这个参数与丢包估计的上涨参数一样</span>
  <span class="token keyword">double</span> alpha <span class="token operator">=</span> <span class="token number">1.08</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>last_time<span class="token punctuation">.</span><span class="token function">IsFinite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> time_since_last_update <span class="token operator">=</span> at_time <span class="token operator">-</span> last_time<span class="token punctuation">;</span>
    alpha <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>alpha<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>time_since_last_update<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">seconds</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  DataRate multiplicative_increase <span class="token operator">=</span>
      std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>current_bitrate <span class="token operator">*</span> <span class="token punctuation">(</span>alpha <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">DataRate</span><span class="token double-colon punctuation">::</span><span class="token function">bps</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> multiplicative_increase<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

DataRate <span class="token class-name">AimdRateControl</span><span class="token double-colon punctuation">::</span><span class="token function">AdditiveRateIncrease</span><span class="token punctuation">(</span>Timestamp at_time<span class="token punctuation">,</span>
                                               Timestamp last_time<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">double</span> time_period_seconds <span class="token operator">=</span> <span class="token punctuation">(</span>at_time <span class="token operator">-</span> last_time<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">seconds</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> data_rate_increase_bps <span class="token operator">=</span>
      <span class="token function">GetNearMaxIncreaseRateBpsPerSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> time_period_seconds<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token class-name">DataRate</span><span class="token double-colon punctuation">::</span><span class="token function">bps</span><span class="token punctuation">(</span>data_rate_increase_bps<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token class-name">AimdRateControl</span><span class="token double-colon punctuation">::</span><span class="token function">GetNearMaxIncreaseRateBpsPerSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// RTC_DCHECK(!current_bitrate_.IsZero());</span>
  <span class="token comment">// 加性增以固定的15帧换算帧间隔，最终根据帧间隔计算出一个大致的平均包大小</span>
  <span class="token keyword">const</span> TimeDelta kFrameInterval <span class="token operator">=</span> <span class="token class-name">TimeDelta</span><span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">15</span><span class="token punctuation">;</span>
  DataSize frame_size <span class="token operator">=</span> current_bitrate_ <span class="token operator">*</span> kFrameInterval<span class="token punctuation">;</span>
  <span class="token keyword">const</span> DataSize kPacketSize <span class="token operator">=</span> <span class="token class-name">DataSize</span><span class="token double-colon punctuation">::</span><span class="token function">bytes</span><span class="token punctuation">(</span><span class="token number">1200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> packets_per_frame <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">ceil</span><span class="token punctuation">(</span>frame_size <span class="token operator">/</span> kPacketSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
  DataSize avg_packet_size <span class="token operator">=</span> frame_size <span class="token operator">/</span> packets_per_frame<span class="token punctuation">;</span>

  <span class="token comment">// Approximate the over-use estimator delay to 100 ms.</span>
  <span class="token comment">// 使用平均包大小换算出每个计算周期的增长值，最大为4kbps</span>
  TimeDelta response_time <span class="token operator">=</span> rtt_ <span class="token operator">+</span> <span class="token class-name">TimeDelta</span><span class="token double-colon punctuation">::</span><span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>in_experiment_<span class="token punctuation">)</span> response_time <span class="token operator">=</span> response_time <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> increase_rate_bps_per_second <span class="token operator">=</span>
      <span class="token punctuation">(</span>avg_packet_size <span class="token operator">/</span> response_time<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">bps</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> kMinIncreaseRateBpsPerSecond <span class="token operator">=</span> <span class="token number">4000</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>kMinIncreaseRateBpsPerSecond<span class="token punctuation">,</span> increase_rate_bps_per_second<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_495"></a>三、总结</h2> 
<p>  本文接着前面提到的码率控制，讲述了计算包组间隔的类，该类用于校准发送间隔在周期发送中的误差。后续接着上一篇GCC介绍讲了经过ack模块后，码率是怎么计算出来的。在什么情况下它会上涨？什么情况下会下跌？并且结合状态机图给大家分析了GCC上涨和下降的规律，发现它是个激进下降，缓慢上涨的拥塞控制算法。这样做的好处是：可以尽最大能力保证播放的流畅度，提高交互能力避免微小的拥塞导致卡顿。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73de43c3d4e7d7e2dc9d9135d23cd6a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">优优嗨聚集团：冬季旅游市场，寒风中的暖流“</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6dcc20891ce3b64a95fd70317d00ebef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python股票分析挖掘预测技术指标知识大全之BOLL线详解(4)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>