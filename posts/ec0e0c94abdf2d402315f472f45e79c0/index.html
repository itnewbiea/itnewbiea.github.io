<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>每日一题--删除链表的倒数第 N 个结点 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="每日一题--删除链表的倒数第 N 个结点" />
<meta property="og:description" content="破阵子-晏殊
燕子欲归时节，高楼昨夜西风。
求得人间成小会，试把金尊傍菊丛。歌长粉面红。
斜日更穿帘幕，微凉渐入梧桐。
多少襟情言不尽，写向蛮笺曲调中。此情千万重。
目录
题目描述：
思路分析：
方法及时间复杂度：
法一 双指针(经典解法)
法二 计算链表长度(暴力解法)
法三 栈
法四 哈希表
法五 vector
法六 递归(烧脑解法)
个人总结：
题目描述： 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）
思路分析： 此题要求是删除倒数第N个结点，那么主要的就是找到倒数第N个结点，然后让该节点的前一个指向该结点的下一个。
那么这道题便有五种以上的解法，核心就是找到要删的那个结点。
方法及时间复杂度： 法一 双指针(经典解法) 定义两指针：fast=head,slow=head。
fast先走n步，然后fast跟slow同时走。
直到fast走到空，此时slow 就到删除的结点。原理：设链表长L，快指针共走L步，慢指针走L-n步。故此方法由法二得来。
由于这题是删除该结点，这得需要删除结点的前继结点。所以让slow少走一步。可以直接开辟一个虚拟结点让slow=dummy。
这样solw就可以到达删除结点的前一个结点了。然后像思路分析那样操作。代码如下：
class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy=new ListNode(0,head); ListNode* fast=head,*slow=dummy; while(n--){ fast=fast-&gt;next; } while(fast){ fast=fast-&gt;next; slow=slow-&gt;next; } slow-&gt;next=slow-&gt;next-&gt;next; ListNode* ans=dummy-&gt;next; delete dummy; return ans; } }; 时间复杂度O(L)，链表长度为L。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ec0e0c94abdf2d402315f472f45e79c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-26T08:49:04+08:00" />
<meta property="article:modified_time" content="2023-11-26T08:49:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">每日一题--删除链表的倒数第 N 个结点</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"></p> 
<blockquote> 
 <p><em><strong>破阵子-晏殊</strong></em></p> 
 <p></p> 
 <p><strong>燕子欲归时节，高楼昨夜西风。</strong></p> 
 <p><strong>求得人间成小会，试把金尊傍菊丛。歌长粉面红。<br> 斜日更穿帘幕，微凉渐入梧桐。</strong></p> 
 <p><strong>多少襟情言不尽，写向蛮笺曲调中。此情千万重。</strong></p> 
</blockquote> 
<p><img alt="" height="346" src="https://images2.imgbox.com/26/39/jjhpDbOo_o.jpg" width="642"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A" rel="nofollow">题目描述：</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow">思路分析：</a></p> 
<p id="%E6%96%B9%E6%B3%95%E5%8F%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%96%B9%E6%B3%95%E5%8F%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A" rel="nofollow">方法及时间复杂度：</a></p> 
<p id="%E6%B3%95%E4%B8%80%20%E5%8F%8C%E6%8C%87%E9%92%88(%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95)-toc" style="margin-left:40px;"><a href="#%E6%B3%95%E4%B8%80%20%E5%8F%8C%E6%8C%87%E9%92%88%28%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95%29" rel="nofollow">法一 双指针(经典解法)</a></p> 
<p id="%E6%B3%95%E4%BA%8C%20%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6(%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95)-toc" style="margin-left:40px;"><a href="#%E6%B3%95%E4%BA%8C%20%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%28%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95%29" rel="nofollow">法二 计算链表长度(暴力解法)</a></p> 
<p id="%E6%B3%95%E4%B8%89%20%E6%A0%88-toc" style="margin-left:40px;"><a href="#%E6%B3%95%E4%B8%89%20%E6%A0%88" rel="nofollow">法三 栈</a></p> 
<p id="%E6%B3%95%E5%9B%9B%20%E5%93%88%E5%B8%8C%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E6%B3%95%E5%9B%9B%20%E5%93%88%E5%B8%8C%E8%A1%A8" rel="nofollow">法四 哈希表</a></p> 
<p id="%E6%B3%95%E4%BA%94%20vector-toc" style="margin-left:40px;"><a href="#%E6%B3%95%E4%BA%94%20vector" rel="nofollow">法五 vector</a></p> 
<p id="%E6%B3%95%E5%85%AD%20%E9%80%92%E5%BD%92(%E7%83%A7%E8%84%91%E8%A7%A3%E6%B3%95)-toc" style="margin-left:40px;"><a href="#%E6%B3%95%E5%85%AD%20%E9%80%92%E5%BD%92%28%E7%83%A7%E8%84%91%E8%A7%A3%E6%B3%95%29" rel="nofollow">法六 递归(烧脑解法)</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">个人总结：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%C2%A0%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A"> 题目描述：</h2> 
<p>给你一个链表，删除链表的倒数第 <code>n</code><em> </em>个结点，并且返回链表的头结点。</p> 
<p><img alt="" height="423" src="https://images2.imgbox.com/a6/77/juoMzJzI_o.png" width="444"></p> 
<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/" rel="nofollow" title="19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p> 
<h2 id="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%EF%BC%9A">思路分析：</h2> 
<p>此题要求是删除倒数第N个结点，那么主要的就是找到倒数第N个结点，然后让该节点的前一个指向该结点的下一个。</p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/09/4d/tK77CFrQ_o.png" width="636"></p> 
<p> 那么这道题便有五种以上的解法，<span style="color:#0d0016;">核心就是找到要删的那个结点。</span></p> 
<h2 id="%E6%96%B9%E6%B3%95%E5%8F%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A">方法及时间复杂度：</h2> 
<h3 id="%E6%B3%95%E4%B8%80%20%E5%8F%8C%E6%8C%87%E9%92%88(%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95)">法一 双指针(经典解法)</h3> 
<p>定义两指针：fast=head,slow=head。</p> 
<p><img alt="" height="685" src="https://images2.imgbox.com/e3/79/S1iXKQIp_o.png" width="1200"></p> 
<p>fast先走n步，然后fast跟slow同时走。</p> 
<p><img alt="" height="654" src="https://images2.imgbox.com/b0/26/l9uL9WZx_o.png" width="1200"></p> 
<p>直到fast走到空，此时slow 就到删除的结点。原理：设链表长L，快指针共走L步，慢指针走L-n步。故此方法由法二得来。</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/52/e7/0kQsY4Vc_o.png" width="1200"></p> 
<p> 由于这题是删除该结点，这得需要删除结点的前继结点。所以让slow少走一步。可以直接开辟一个虚拟结点让slow=dummy。</p> 
<p><img alt="" height="640" src="https://images2.imgbox.com/2c/61/zyef0iu0_o.png" width="1200"></p> 
<p><img alt="" height="652" src="https://images2.imgbox.com/61/04/iut1X9NP_o.png" width="1200"></p> 
<p></p> 
<p> 这样solw就可以到达删除结点的前一个结点了。然后像思路分析那样操作。代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy=new ListNode(0,head);
        ListNode* fast=head,*slow=dummy;
        while(n--){
            fast=fast-&gt;next;
        }
        while(fast){
            fast=fast-&gt;next;
            slow=slow-&gt;next;
        }
        slow-&gt;next=slow-&gt;next-&gt;next;
        ListNode* ans=dummy-&gt;next;
        delete dummy;
        return ans;
    }
};</code></pre> 
<p><strong>时间复杂度O(L)，链表长度为L。</strong></p> 
<p><strong>空间复杂度O(1)。</strong></p> 
<h3></h3> 
<h3 id="%E6%B3%95%E4%BA%8C%20%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6(%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95)">法二 计算链表长度(暴力解法)</h3> 
<p>遍历链表计算长度，减去n就是正着数的个数，注意的是，如果长度L-n==0就是头删了。代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int count=0;
        ListNode* cur=head,*pre=head;
        while(cur){
            ++count;
            cur=cur-&gt;next;
        }
        if(count==n) return head-&gt;next;
        cur=head;
        for(int i=0;i&lt;(count-n)&amp;&amp;cur!=nullptr;++i){
            pre=cur;
            cur=cur-&gt;next;
        }
        pre-&gt;next=cur-&gt;next;
        return head;
    }
};</code></pre> 
<p><strong>时间复杂度O(L)，链表长度为L。</strong></p> 
<p><strong>空间复杂度O(1)。</strong></p> 
<p></p> 
<h3 id="%E6%B3%95%E4%B8%89%20%E6%A0%88">法三 栈</h3> 
<p>根据栈的特点先进后出，创建一个虚拟头节点（防止空栈），让所有结点入栈，然后出栈n个结点，此时栈顶元素就是要删除的结点的前一个。</p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/1b/fe/8aiXPYOh_o.png" width="601"></p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy=new ListNode(0,head);
        stack&lt;ListNode*&gt; st;
        ListNode* cur=dummy;
        while(cur){
            st.emplace(cur);
            cur=cur-&gt;next;
        }
        for(int i=0;i&lt;n;++i){
            st.pop();
        }
        ListNode* pre=st.top();
        pre-&gt;next=pre-&gt;next-&gt;next;
        ListNode* ans=dummy-&gt;next;
        delete dummy;
        return ans;
    }
};</code></pre> 
<p></p> 
<p><strong>时间复杂度O(L)，链表长度为L。</strong></p> 
<p><strong>空间复杂度O(L)。为栈开销</strong></p> 
<p></p> 
<h3 id="%E6%B3%95%E5%9B%9B%20%E5%93%88%E5%B8%8C%E8%A1%A8">法四 哈希表</h3> 
<p>主要思想是一样的，查找到删除结点的前一个结点，如果前一个没有结点就头删。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        unordered_map&lt;int,ListNode*&gt; hash;
        ListNode *cur=head;
        int i=0;
        while(cur){
            hash.insert({i++,cur});
            cur=cur-&gt;next;
        }
        int target=i-n;
        if(target==0) return head-&gt;next;
        //target上一个位置的指针指向下一个
        ListNode* left=hash[target-1];
        left-&gt;next=left-&gt;next-&gt;next;
        return head;
    }
};</code></pre> 
<p><strong>时间复杂度O(L)，链表长度为L，哈希表查找也为O(L)。</strong></p> 
<p><strong>空间复杂度O(L)。哈希表的开销。</strong></p> 
<h3></h3> 
<h3 id="%E6%B3%95%E4%BA%94%20vector">法五 vector</h3> 
<p>与法四思路相同，不多解释。</p> 
<pre><code class="language-cpp">class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        vector&lt;ListNode*&gt; ret;
        ListNode* cur=head;
        while(cur){
            ret.emplace_back(cur);
            cur=cur-&gt;next;
        }
        int target=ret.size()-n;
        if(target==0) return head-&gt;next;
        ListNode* left=ret[target-1];
        left-&gt;next=left-&gt;next-&gt;next;
        return head;
    }
};</code></pre> 
<p><strong>时间复杂度O(L)，链表长度为L。</strong></p> 
<p><strong>空间复杂度O(L)。</strong></p> 
<p></p> 
<h3 id="%E6%B3%95%E5%85%AD%20%E9%80%92%E5%BD%92(%E7%83%A7%E8%84%91%E8%A7%A3%E6%B3%95)">法六 递归(烧脑解法)</h3> 
<p>这种解法我也受人启发。但使用递归得考虑数据长度，防止栈溢出。思路很简单，与前几种种解法思路相同，定义一个count，递归遍历整个链表，然后回溯整个链表，回溯时count+1。<strong>当count==n时，此时已经回溯到要删除结点</strong>，此时返回此结点的下一个结点，类似于跳过该结点。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    int count=0;
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return nullptr;
        head-&gt;next=removeNthFromEnd(head-&gt;next,n);
        count++;
        if(count==n) return head-&gt;next;
        return head;
    }
};</code></pre> 
<p><strong>时间复杂度O(L)。</strong></p> 
<p><strong>空间复杂度O(L)。</strong></p> 
<h2 id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A">个人总结：</h2> 
<p>大致思路就是找倒数第n个结点，删除结点实现起来其实并不复杂，可以还有更多的方法做这道题。</p> 
<p></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91307ae8b744229ce55b7285ee57fc03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue项目的创建、运行与端口号修改</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3316ed4602dde9d13b05aabfa2fe16c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络视频播放卡顿原因分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>