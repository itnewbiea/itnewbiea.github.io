<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis基础数据类型和命令 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis基础数据类型和命令" />
<meta property="og:description" content="1、Redis通用命令 通用指令是部分数据类型的，都可以使用的指令，常见的有，通过help [command] 可以查看一个命令的具体用法：
KEYS：查看符合模板的所有key，匹配查询的所有的KEY，可以使用通配符 * ？ [] ，不建议在生产上面使用这个命令，会阻塞进程。*模糊匹配、？匹配一个字符、[]匹配括号里面的字符 。 DEL：删除一个指定的key。 EXISTS：判断key是否存在。 EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除。 TTL：查看一个KEY的剩余有效期。 2、String类型 字符串类型是Redis中最基本的存储类型【key-value】，value根据字符串的格式不同分为3类：
string：普通字符串。
int：整数类型，可以做自增、自减操作。
float：浮点类型，可以做自增、自减操作。
String类型是二进制安全的，意思是redis的string可以包含任何数据，不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大默认空间不能超过512m。
内部实现 String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。
SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：
SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
SDS 获取字符串长度的时间复杂度是 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。
Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a3646371dd376f83d7dd24cbef57c8c5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-07T16:34:03+08:00" />
<meta property="article:modified_time" content="2023-03-07T16:34:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis基础数据类型和命令</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1、Redis通用命令</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">通用指令是部分数据类型的，都可以使用的指令，常见的有，通过help [command] 可以查看一个命令的具体用法：</span></span></p> 
 <pre class="kdocs-shell"><code class="language-shell">KEYS：查看符合模板的所有key，匹配查询的所有的KEY，可以使用通配符 *  ？ [] ，不建议在生产上面使用这个命令，会阻塞进程。*模糊匹配、？匹配一个字符、[]匹配括号里面的字符 。
DEL：删除一个指定的key。
EXISTS：判断key是否存在。
EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除。
TTL：查看一个KEY的剩余有效期。</code></pre> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2、String类型</span></h2> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">字符串类型是Redis中最基本的存储类型【key-value】，value根据字符串的格式不同分为3类：</span></span></p> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">string：普通字符串。</span></p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">int：整数类型，可以做自增、自减操作。</span></p></li></ol> 
 <ol start="3"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">float：浮点类型，可以做自增、自减操作。</span></p></li></ol> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;">String类型是二进制安全的，意思是redis的string可以包含任何数据，不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大默认空间不能超过512m。</span></span></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">内部实现</span></h3> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</span></span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;">SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">SDS 获取字符串长度的时间复杂度是 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">字符串对象的内部编码（encoding）有 3 种 ：int、raw 和 embstr。</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">如果一个字符串对象保存的是整数值，且这个整数值可以用long类型表示，那么字符串对象会将ptr属性指向整数值，并将字符串对象的编码设置为int。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">如果字符串对象保存的是一个长度小于等于32字节的字符串值，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">如果字符串对象保存的是一个长度大于32字节的字符串值，那么字符串对象将使用一个SDS来保存这个字符串值，并将对象的编码设置为raw。</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">【内部结构实现】</span>🔗<span class="kdocs-fontSize" style="font-size:9pt;"> </span><a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/yaluoshan/article/details/109702492" target="_blank" rel="noopener noreferrer"><span class="kdocs-fontSize" style="font-size:9pt;">https://blog.csdn.net/yaluoshan/article/details/109702492</span></a></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">常见命令 </span></h3> 
 <pre class="kdocs-shell"><code class="language-shell">set key value：添加或者修改已经存在的一个String类型的键值对。
met key1 value1 key2 value2：根据多个key获取多个String类型的value。
get key ：根据key获取String类型的 value。
mget key key：批量添加多个String类型的键值对。
getset key value ：先get再set，返回旧值，如果没有旧值返回nil。
append key value  ：向指定的key的value后追加字符串。
strlen key ：获取key对应值的字符串长度。
incr key ：value + 1 让一个整型的key自增1。
decr key ：value - 1让一个整型的key自减1。
incrby key number：value + number 让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2。
decrby key number：value - number。
incrbyfloat key：让一个浮点类型的数字自增并指定步长。
setnx key value：添加一个String类型的键值对，如果key不存在就设置，返回1，如果key已经存在就不设置，返回0。
setex key seconds expire：设置键值过期时间 。
msetnx key1 value1 key2 value2：当所有 key 都成功设置，返回 1 ,有一个key设置失败，所有的key设置都会失败，返回 0 。
获取或者设置指定范围内的值
    getrange key begin end ：获取[begin,end]下标范围内的值，如果是(0,1)就是获取所有值。
    setrange key begin xxx：从begin下标开始设置xxx值，将原有的替换掉。</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">应用场景</span></h3> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;">缓存对象</span>: 将对象转换成字符串类型。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;">分布式锁</span>：<span class="kdocs-bold" style="font-weight:bold;">SET lock_key unique_value NX PX 10000 </span></span></p> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">lock_key 就是 key 键；</span></p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">unique_value 是客户端生成的唯一的标识；</span></p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</span></p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;">常规计数</span>：因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量、阅读量等等。</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3、Hash类型</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Redis Hash 是一个 string 类型的 field(字段) 和 value(属性) 的映射表，hash 特别适合用于存储对象。其value是一个无序字典，类似于Java中的HashMap结构。</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-italic" style="font-style:italic;">一个hash可以存多个key-value，类似一个对象的多个字段和属性，String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便。</span></span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-italic" style="font-style:italic;">Hash数据类型（散列类型)、hash用于存储对象。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。</span></span></span></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">内部实现</span></h3> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">Hash 类型的底层数据结构是由<span class="kdocs-bold" style="font-weight:bold;">压缩列表或哈希表</span>实现的：</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<span class="kdocs-bold" style="font-weight:bold;">压缩列表</span>作为 Hash 类型的底层数据结构；</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">如果哈希类型元素不满足上面条件，Redis 会使用<span class="kdocs-bold" style="font-weight:bold;">哈希表</span>作为 Hash 类型的底层数据结构。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</span>。</span></p></li></ul> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">Hash的常见命令</span></h3> 
 <pre class="kdocs-shell"><code class="language-shell">HSET key field value：添加或者修改hash类型key的field的值。
HGET key field：获取一个hash类型key的field的值。
HMSET：批量添加多个hash类型key的field的值。
HMGET：批量获取多个hash类型key的field的值。
HGETALL：获取一个hash类型的key中的所有的field和value。
HKEYS：获取一个hash类型的key中的所有的field。
HVALS：获取一个hash类型的key中的所有的value。
HINCRBY:让一个hash类型key的字段值自增并指定步长。
HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行。
HLEN key ：返回哈希表key中所有的键值。</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">应用场景</span></h3> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;">缓存对象</span>：Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</span></p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;">购物车</span></span></p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;">分布式锁</span></span></p></li></ol> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4、List类型</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。可以从头部或尾部向 List 列表添加元素。</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">列表的最大长度为 2^32 - 1，也即每个列表支持超过 40 亿个元素。</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">list 列表，它是简单的字符串列表，按照插入顺序排序，底层实际上是个链表结构。列表对象的编码是quicklist。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">特征也与LinkedList类似：<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">有序、元素可以重复、插入和删除快、查询速度一般</span></span></span></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">使用场景</span></h3> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">常用来存储一个有序数据，例如：<span class="kdocs-color" style="color:#C21C13;">朋友圈点赞列表，评论列表</span>等。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">使用List结构，我们可以轻松地实现<span class="kdocs-color" style="color:#C21C13;">最新消息排队功能</span>（比如新浪微博的TimeLine）。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">List的另一个应用就是消息队列，可以利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">Redis还提供了操作List中某一段的api，你可以直接查询，删 除List中某一段的元素。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">使用列表的技巧：<span class="kdocs-color" style="color:#C21C13;">lpush+lpop=Stack(栈)、lpush+rpop=Queue（队列）lpush+ltrim=Capped Collection（有限集合）lpush+brpop=Message Queue（消息队列）</span></span></p></li></ul> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">常见命令</span></h3> 
 <pre class="kdocs-shell"><code class="language-shell">LPUSH key  element ... ：向列表左侧插入一个或多个元素
LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil
RPUSH key  element ... ：向列表右侧插入一个或多个元素
RPOP key：移除并返回列表右侧的第一个元素
LRANGE key star end：返回一段角标范围内的所有元素
BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</code></pre> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5、Set类型</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">Set 类型的底层数据结构是由<span class="kdocs-bold" style="font-weight:bold;">哈希表或整数集合</span>实现的：<span class="kdocs-color" style="color:#C21C13;">无序、元素不可重复、查找快、支持交集、并集、差集等功能</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用<span class="kdocs-bold" style="font-weight:bold;">整数集合</span>作为 Set类型的底层数据结构；</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">如果集合中的元素不满足上面条件，则 Redis 使用<span class="kdocs-bold" style="font-weight:bold;">哈希表</span>作为 Set 类型的底层数据结构。</span></p></li></ul> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">常见命令</span></h3> 
 <pre class="kdocs-shell"><code class="language-shell">SADD key member ... ：向set中添加一个或多个元素
SREM key member ... : 移除set中的指定元素
SCARD key： 返回set中元素的个数
SISMEMBER key member：判断一个元素是否存在于set中
SMEMBERS：获取set中的所有元素
SINTER key1 key2 ... ：求key1与key2的交集
SDIFF key1 key2 ... ：求key1与key2的差集
SUNION key1 key2 ..：求key1和key2的并集</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">应用场景</span></h3> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">集合的主要几个特性，无序、不可重复、支持并交差等操作。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">但是要提醒你一下，这里有一个潜在的风险。<span class="kdocs-bold" style="font-weight:bold;">Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</span>。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">点赞：</span>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">共同关注：</span>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">抽奖活动：</span>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6、Zset类型</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">SortedSet具备的特性：可排序、元素不重复、查询速度快。</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">常见命令</span></span></p> 
 <pre class="kdocs-shell"><code class="language-shell">ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值
ZREM key member：删除sorted set中的一个指定元素
ZSCORE key member : 获取sorted set中的指定元素的score值
ZRANK key member：获取sorted set 中的指定元素的排名
ZCARD key：获取sorted set中的元素个数
ZCOUNT key min max：统计score值在给定范围内的所有元素的个数
ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值
ZRANGE key min max：按照score排序后，获取指定排名范围内的元素
ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素
ZDIFF、ZINTER、ZUNION：求差集、交集、并集</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可。</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">7、Redis GEO</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。Redis geo并不是全新的数据结构，而是基于Sorted Set来实现的。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">Redis GEO 操作方法有：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">geoadd：添加地理位置的坐标。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">geopos：获取地理位置的坐标。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">geodist：计算两个位置之间的距离。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">geohash：返回一个或多个位置对象的 geohash 值。</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">8、Redis HyperLogLog</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">Redis中的HLL是基于string结构实现的，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">其测量结果是概率性的，有小于0.81％的误差.</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">相关算法原理大家可以参考：</span><a class="kdocs-link" style="color:#0A6CFF;" href="https://juejin.cn/post/6844903785744056333#heading-0" rel="nofollow noopener noreferrer" target="_blank"><span class="kdocs-fontSize" style="font-size:9pt;">https://juejin.cn/post/6844903785744056333#heading-0</span></a></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">9、Redis bitmap</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">key offset value ：offset是占的位 value 通过使用0和1的方式标记。</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个常用命令用于处理二进制位数组。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">SETBIT：向指定位置（offset）存入一个0或1</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">GETBIT ：获取指定位置（offset）的bit值</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">BITCOUNT ：统计BitMap中值为1的bit位的数量</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">10、Stream</span></h2> 
 <p style="text-align:left;"><a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/kevin_tech/article/details/126458080" target="_blank" rel="noopener noreferrer"><span class="kdocs-fontSize" style="font-size:9pt;">https://blog.csdn.net/kevin_tech/article/details/126458080</span></a></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/12595c1b92c5ebf0a0aeafd52886dac3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Unity】 PlayerPrefs 保存本地数据和持久化用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd5c85005fc1091522a5ec81aaa6d029/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多线程 | FutureTask实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>