<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>纯JS前端分页方法（JS分页） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="纯JS前端分页方法（JS分页）" />
<meta property="og:description" content="1、JS分页函数：开发过程中，分页功能一般是后台提供接口，前端只要传page（当前页码）和pageSize（每页最大显示条数）及对应的其他查询条件，就可以返回所需分页显示的数据。
但是有时也需要前端本地进行一些简单的分页处理以减轻浏览器渲染时的内存损耗。如后台传回的数据条数非常多，达到几千条甚至上万条，但是后台又不方便分页传回数据，这个时候就只能前端先获取所有数据保存下来，然后前端本地进行分页并渲染显示。
2、只需要一个纯原生的js函数就可以实现前端的分页功能，直接上js代码：
/** * @name getTableData * @desc 纯JS前端分页方法 * @param {Number} page 当前页码，默认1 * @param {Number} pageSize 每页最多显示条数，默认10 * @param {Array} totalData 总的数据集，默认为空数组 * @return {Object} { data, //当前页展示数据，数组 page, //当前页码 pageSize, //每页最多显示条数 length, //总的数据条数 } **/ const getTableData = (page = 1, pageSize = 10, totalData = []) =&gt; { const { length } = totalData; const tableData = { data: [], page, pageSize, length, }; if (pageSize &gt;= length) { //pageSize大于等于总数据长度，说明只有1页数据或没有数据 tableData." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/59feb20e22ce97deabdec0926d283ef1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-15T14:44:55+08:00" />
<meta property="article:modified_time" content="2023-05-15T14:44:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">纯JS前端分页方法（JS分页）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、JS分页函数：开发过程中，分页功能一般是后台提供接口，前端只要传page（当前页码）和pageSize（每页最大显示条数）及对应的其他查询条件，就可以返回所需分页显示的数据。</p> 
<p>但是有时也需要前端本地进行一些简单的分页处理以减轻浏览器渲染时的内存损耗。如后台传回的数据条数非常多，达到几千条甚至上万条，但是后台又不方便分页传回数据，这个时候就只能前端先获取所有数据保存下来，然后前端本地进行分页并渲染显示。</p> 
<p>2、只需要一个纯原生的js函数就可以实现前端的分页功能，直接上js代码：</p> 
<pre><code class="language-javascript">/**
 * @name  getTableData
 * @desc  纯JS前端分页方法
 * @param  {Number} page 当前页码，默认1
 * @param  {Number} pageSize 每页最多显示条数，默认10
 * @param  {Array} totalData 总的数据集，默认为空数组
 * @return {Object} {
    data, //当前页展示数据，数组
    page, //当前页码
    pageSize, //每页最多显示条数
    length, //总的数据条数
  }
**/
const getTableData = (page = 1, pageSize = 10, totalData = []) =&gt; {
  const { length } = totalData;
  const tableData = {
    data: [],
    page,
    pageSize,
    length,
  };
  if (pageSize &gt;= length) { //pageSize大于等于总数据长度，说明只有1页数据或没有数据
    tableData.data = totalData;
    tableData.page = 1;//直接取第一页
  } else { //pageSize小于总数据长度，数据多余1页
    const num = pageSize * (page - 1);//计算当前页（不含）之前的所有数据总条数
    if (num &lt; length) { //如果当前页之前所有数据总条数小于（不能等于）总的数据集长度，则说明当前页码没有超出最大页码
      const startIndex = num;//当前页第一条数据在总数据集中的索引
      const endIndex = num + pageSize - 1;//当前页最后一条数据索引
      tableData.data = totalData.filter((_, index) =&gt; index &gt;= startIndex &amp;&amp; index &lt;= endIndex);//当前页数据条数小于每页最大条数时，也按最大条数范围筛取数据
    } else { //当前页码超出最大页码，则计算实际最后一页的page，自动返回最后一页数据
      const size = parseInt(length / pageSize); //取商
      const rest = length % pageSize; //取余数
      if (rest &gt; 0) { //余数大于0，说明实际最后一页数据不足pageSize，应该取size+1为最后一条的页码
        tableData.page = size + 1;//当前页码重置，取size+1
        tableData.data = totalData.filter((_, index) =&gt; index &gt;= (pageSize * size) &amp;&amp; index &lt;= length);
      } else if (rest === 0) { //余数等于0，最后一页数据条数正好是pageSize
        tableData.page = size;//当前页码重置，取size
        tableData.data = totalData.filter((_, index) =&gt; index &gt;= (pageSize * (size - 1)) &amp;&amp; index &lt;= length);
      } //注：余数不可能小于0
    }
  }
  return tableData;
};</code></pre> 
<p>只需要传入对应参数就可以返回带有对应分页属性的对象，用于前端界面展示。</p> 
<p></p> 
<p>如有问题欢迎留言讨论。</p> 
<p>原创博客禁止抄袭，转载请注明出处：<a href="https://www.cnblogs.com/xiao-pengyou/" rel="nofollow" title="原文地址:https://www.cnblogs.com/xiao-pengyou/">原文地址:https://www.cnblogs.com/xiao-pengyou/</a></p> 
<p>知识在于分享，如有问题欢迎评论！ 原创博客禁止抄袭，原文地址:https://www.cnblogs.com/xiao-pengyou/</p> 
<p></p> 
<p>我结合 element-UI的写法</p> 
<pre><code class="language-javascript">   eventSizeChange: function (e) { // 切换一页显示多少条
      this.$refs.table.setScrollTop(0); // 翻页后表格从顶部开始渲染
      this.dataListPageSize = e;
      this.getTableData(this.currentPage,e);
    },
    eventCurrentChange: function (e) {  // 翻页
      this.currentPage = e; // 当前页数
      this.getTableData(e,this.dataListPageSize);
      this.$refs.table.setScrollTop(0); // 翻页后表格从顶部开始渲染
    },

     // * @name  getTableData
     // * @param  {Number} page 当前页码，默认1
     // * @param  {Number} pageSize 每页最多显示条数，默认10
     // * @param  {Array} totalData 总的数据集，默认为空数组
     // * @return {Object} {
     //  data, //当前页展示数据，数组
     //  page, //当前页码
     //  pageSize, //每页最多显示条数
     //  length, //总的数据条数
     //  }
    getTableData:function(page,pageSize){
      let totalData = this.dsDataList;
      const { length } = totalData;

      const tableData = {
        data: [],
        page,
        pageSize,
        length,
      };

      if (pageSize &gt;= length) { //pageSize大于等于总数据长度，说明只有1页数据或没有数据
        tableData.data = totalData;
        tableData.page = 1;//直接取第一页
      } else { //pageSize小于总数据长度，数据多余1页
        const num = pageSize * (page - 1);//计算当前页（不含）之前的所有数据总条数
        if (num &lt; length) { //如果当前页之前所有数据总条数小于（不能等于）总的数据集长度，则说明当前页码没有超出最大页码
          const startIndex = num;//当前页第一条数据在总数据集中的索引
          const endIndex = num + pageSize - 1;//当前页最后一条数据索引
          tableData.data = totalData.filter((_, index) =&gt; index &gt;= startIndex &amp;&amp; index &lt;= endIndex);//当前页数据条数小于每页最大条数时，也按最大条数范围筛取数据
        } else { //当前页码超出最大页码，则计算实际最后一页的page，自动返回最后一页数据
          const size = parseInt(length / pageSize); //取商
          const rest = length % pageSize; //取余数
          if (rest &gt; 0) { //余数大于0，说明实际最后一页数据不足pageSize，应该取size+1为最后一条的页码
            tableData.page = size + 1;//当前页码重置，取size+1
            tableData.data = totalData.filter((_, index) =&gt; index &gt;= (pageSize * size) &amp;&amp; index &lt;= length);
          } else if (rest === 0) { //余数等于0，最后一页数据条数正好是pageSize
            tableData.page = size;//当前页码重置，取size
            tableData.data = totalData.filter((_, index) =&gt; index &gt;= (pageSize * (size - 1)) &amp;&amp; index &lt;= length);
          } //注：余数不可能小于0
        }
      }
      this.dataList = tableData.data;
    },</code></pre> 
<p>完美实现，感谢博主分享。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9840d764e10988dc08d55f4bb03949d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux centos 安装DOCKER开原版</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b25333f2b00c961327fc89931b2fac10/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQl乱码问题解决方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>