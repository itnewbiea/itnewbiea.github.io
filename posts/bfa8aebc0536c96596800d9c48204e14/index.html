<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java23种设计模式之单例模式的五种实现方式、反射破解单例模式、不能破解枚举单例模式详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java23种设计模式之单例模式的五种实现方式、反射破解单例模式、不能破解枚举单例模式详解" />
<meta property="og:description" content="源码链接（Gitee码云）：https://gitee.com/oldou/javadesignpatterns
这里有我整理好的Java23种设计模式的源码以及博客教程，博客教程中介绍了Java23种设计的模式的各种实现方式以及应用场景，非常适用于学习以及提高我们的设计思维，如果对大家有所帮助，请记得star一下给予作者一定的精神支持，你的star是我写出更好的博客的动力，谢谢大家。
目录 设计模式简介单例模式的简介单例模式的实现实现方式一：饿汉式（单例对象立即加载）实现方式二：懒汉式（单例对象延迟加载）实现方式三：双重检测锁实现（不建议使用）实现方式四：静态内部类实现方式(懒加载方式)实现方式五：枚举 反射破解单例模式枚举单例模式的解释单例模式总结 设计模式简介 将设计者的思维融入大家的学习和工作中，更高层次的思考！
• 创建型模式：
– 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。
• 结构型模式：
– 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
• 行为型模式：
– 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。
本次文章介绍的是单例模式的五种实现方式。
单例模式的简介 • 核心作用：
保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。
• 常见应用场景：
– Windows的Task Manager（任务管理器）就是很典型的单例模式
– windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
– 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。
– 网站的计数器，一般也是采用单例模式实现，否则难以同步。
– 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
– 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
– 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。
– Application 也是单例的典型应用（Servlet编程中会涉及到）
– 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理
– 在servlet编程中，每个Servlet也是单例
– 在spring MVC框架/struts1框架中，控制器对象也是单例
• 单例模式的优点：
– 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，
则可 以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决
– 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理
• 常见的五种单例模式实现方式：
– 主要：
• 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
• 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bfa8aebc0536c96596800d9c48204e14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-24T18:15:45+08:00" />
<meta property="article:modified_time" content="2020-07-24T18:15:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java23种设计模式之单例模式的五种实现方式、反射破解单例模式、不能破解枚举单例模式详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <blockquote> 
  <p>源码链接（Gitee码云）：<a href="https://gitee.com/oldou/javadesignpatterns" rel="nofollow">https://gitee.com/oldou/javadesignpatterns</a><br> 这里有我整理好的Java23种设计模式的源码以及博客教程，博客教程中介绍了Java23种设计的模式的各种实现方式以及应用场景，非常适用于学习以及提高我们的设计思维，如果对大家有所帮助，请记得star一下给予作者一定的精神支持，你的star是我写出更好的博客的动力，谢谢大家。</p> 
 </blockquote> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">设计模式简介</a></li><li><a href="#_18" rel="nofollow">单例模式的简介</a></li><li><a href="#_51" rel="nofollow">单例模式的实现</a></li><li><ul><li><a href="#_52" rel="nofollow">实现方式一：饿汉式（单例对象立即加载）</a></li><li><a href="#_89" rel="nofollow">实现方式二：懒汉式（单例对象延迟加载）</a></li><li><a href="#_122" rel="nofollow">实现方式三：双重检测锁实现（不建议使用）</a></li><li><a href="#_165" rel="nofollow">实现方式四：静态内部类实现方式(懒加载方式)</a></li><li><a href="#_204" rel="nofollow">实现方式五：枚举</a></li></ul> 
  </li><li><a href="#_231" rel="nofollow">反射破解单例模式</a></li><li><a href="#_256" rel="nofollow">枚举单例模式的解释</a></li><li><a href="#_346" rel="nofollow">单例模式总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_4"></a>设计模式简介</h2> 
<p>将设计者的思维融入大家的学习和工作中，更高层次的思考！<br> • 创建型模式：<br> – 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。</p> 
<p>• 结构型模式：<br> – 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p> 
<p>• 行为型模式：<br> – 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</p> 
<p><strong>本次文章介绍的是单例模式的五种实现方式</strong>。</p> 
<h2><a id="_18"></a>单例模式的简介</h2> 
<p><strong>• 核心作用：</strong><br> 保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。</p> 
<p><strong>• 常见应用场景：</strong><br> – Windows的Task Manager（任务管理器）就是很典型的单例模式<br> – windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。<br> – 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。<br> – 网站的计数器，一般也是采用单例模式实现，否则难以同步。<br> – 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。<br> – 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。<br> – 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。<br> – Application 也是单例的典型应用（Servlet编程中会涉及到）<br> – 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理<br> – 在servlet编程中，每个Servlet也是单例<br> – 在spring MVC框架/struts1框架中，控制器对象也是单例</p> 
<p><strong>• 单例模式的优点：</strong><br> – 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，<br> 则可 以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</p> 
<p>– 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理</p> 
<p><strong>• 常见的五种单例模式实现方式：</strong><br> – 主要：<br> • 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）<br> • 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</p> 
<p>– 其他：<br> • 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）<br> • 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)<br> • 枚举单例(线程安全，调用效率高，不能延时加载)</p> 
<h2><a id="_51"></a>单例模式的实现</h2> 
<h3><a id="_52"></a>实现方式一：饿汉式（单例对象立即加载）</h3> 
<p>• 饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。<br> • 问题：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！</p> 
<p>需要注意的三点：<br> 第一点：需要将构造器私有，构造器私有之后别人就访问不了了，只有自己可以用；<br> 第二点：提供一个属性，这个属性是static变量，并且是私有的，static变量是类变量，从属于这个类，那么这个类就只有这么一个属性，它就指定了这个对象；<br> 第三点：提供一个开放的方法，别人只能从这里取对象。<br> 以上三点的描述，详细代码见以下的第一个！！</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 测试饿汉式单例模式
 *  --所谓饿汉式，表示的是很饿，上来就把你吃了，相当于当类加载器加载以下类的时候，
 *    加载的时候就把这个对象New出来，初始以下的静态属性，不管你要不要，上来就给建好。
 *    这个就是立即加载。这个就是不好的地方。
 *
 *  --特点：
 *  1.线程安全：方法前不需要加synchronized,因为我们去创建对象时，在类初始化时立刻加载，
 *             在类加载器加载对象时是一个天然的线程安全模式。
 *             不存在创建对象/初始化属性多线程不安全的问题，所以天然线程安全。
 *
 *  2.显然不加同步标记的话，效率就高。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//类初始化时，立即加载这个对象(没有延时加载的优势)，加载类时，天然的是线程安全的</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Demo01 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//提供私有的构造器,一旦构造器私有，别人就无法去new这个对象了，保证了内存中只有这么一个对象</span>
    <span class="token keyword">private</span> <span class="token function">Demo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">//方法没有同步，调用效率高</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Demo01 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_89"></a>实现方式二：懒汉式（单例对象延迟加载）</h3> 
<p>• 要点：<br> – lazy load! 延迟加载， 懒加载！ 真正用的时候才加载！</p> 
<p>• 问题：<br> – 资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。<br> –调用的效率低。</p> 
<p>注意：如果类创建对象时用到的代价很高，那么就使用延时加载，也就是懒汉式；如果类调用效率非常频繁，就用饿汉式。</p> 
<p>代码为：</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 懒汉式单例模式
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo02</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//类初始化时，不初始化这个对象(实现了延时加载，真正用到的时候才去创建)</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Demo02 INSTANCE<span class="token punctuation">;</span>

    <span class="token comment">//构造器私有，一旦构造器私有，别人就无法去new这个对象了，保证了内存中只有这么一个对象</span>
    <span class="token keyword">private</span> <span class="token function">Demo02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">//方法同步，调用效率低</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Demo02 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>INSTANCE<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_122"></a>实现方式三：双重检测锁实现（不建议使用）</h3> 
<p>• 这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，<br> 只有第一次才同步创建了以后就没必要了。<br> • 问题：由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题。不建议使用。<br> 代码如下所示：</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 双重检测锁模式的懒汉式，DCL懒汉式
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo03</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Demo03 INSTANCE<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token function">Demo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Demo03 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//先判断对象是否已经实例化过，没有实例化才能进入加锁代码</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>INSTANCE<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//对类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Demo03<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>INSTANCE<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code>/**
 * 为什么要加 volatile关键字修饰 instance
 * 我们创建一个对象一般的步骤就是：
 *  1、分配内存空间
 *  2、执行构造方法，初始化对象
 *  3、把这个对象指向对应的内存空间
 *  一般情况下，我们期望的是执行123这样的顺序，但是真实可能执行132，比如这个时候A线程是这样的方式
 *  先分配内存空间，然后在把这个内存空间占用，再把这个对象放进去，在多线程情况下，如果这个时候来了个线程B
 * 线程B过来以后，由于是先去指向对应的内存空间，它会认为 instance 不等于null，它就会直接return回去，
 * 此时的这个instance还没有完成构造，这个时候空间是一片虚无，就会出问题，因此加一个volatile关键字
 * 可以避免指令重排，保证可见性。
 *
**/
</code></pre> 
<h3><a id="_165"></a>实现方式四：静态内部类实现方式(懒加载方式)</h3> 
<p><strong>基本思路</strong>：首先是静态内部类，在里面定义单例对象，然后也提供一个方法getInstance()，通过调用静态内部的方法进行访问，构造器私有，这种方式不仅线程安全，还是懒加载模式。</p> 
<p>当我们第一次去初始化这个类的时候，并不会立即初始化它的静态内部类，当真正要用的时候，才会通过getInstance()这个方法去调用InnerClass.INSTANCE ;从而去加载内部类中的代码，使用时也不存在同步的问题。调用效率也不错，很多开源的都用这个。</p> 
<p><strong>• 要点</strong>：<br> – 外部类没有static属性，则不会像饿汉式那样立即加载对象。<br> – 只有真正调用getInstance(),才会加载静态内部类。加载类时是线程安全的。 INSTANCE 是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.<br> – 兼备了并发高效调用和延迟加载的优势！</p> 
<p><strong>优点</strong>：<br> 1、线程安全，还是懒加载模式<br> 2、调用效率高<br> 3、实现了延时加载<br> 代码实现：</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 静态内部类实现单例模式
 *
 * 优点：
 * 1、线程安全，还是懒加载模式
 * 2、调用效率高
 * 3、实现了延时加载
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo04</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//在静态内部类中定义单例对象，因为第一次初始化这个类时并不会立即初始化静态内部类</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Demo04 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo04</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//构造器私有</span>
    <span class="token keyword">private</span> <span class="token function">Demo04</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">//通过静态内部类获取实例</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Demo04 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> InnerClass<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span> <span class="token comment">//</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_204"></a>实现方式五：枚举</h3> 
<p>• 优点：<br> – 实现简单<br> – <font color="red">枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！</font></p> 
<p>• 缺点：<br> – 无延迟加载</p> 
<p>代码如下：</p> 
<pre><code>/**
 * 使用枚举方式实现单例模式
 • 优点：
 – 实现简单
 – 枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！
 */
public enum Demo05 {
    /**
     *  定义一个枚举元素，它就代表了Singleton的一个实例
     */
    INSTANCE;
    public Demo05 getInstance(){
        return INSTANCE;
    }

}
</code></pre> 
<h2><a id="_231"></a>反射破解单例模式</h2> 
<p>以上五种单例模式的实现方式中，前四种方式都是不太安全的，饿汉、懒汉、双重检查锁、静态内部类这四种方式都可以使用反射进行破解。</p> 
<p>下面以破解饿汉式为例：</p> 
<pre><code class="prism language-java"><span class="token comment">//测试使用反射破坏单例（懒汉为例）</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{<!-- --></span>
            Demo01 instance <span class="token operator">=</span> Demo01<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//获取通过反射私有构造器（这里null表示获取无参）</span>
            Constructor<span class="token generics function"><span class="token punctuation">&lt;</span>Demo01<span class="token punctuation">&gt;</span></span> declaredConstructor <span class="token operator">=</span> Demo01<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//破坏私有构造器</span>
            declaredConstructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//通过反射创建对象</span>
            Demo01 instance2 <span class="token operator">=</span> declaredConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//通过输出可以明显的看出创建了两个对象，单例模式被破解了</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8b/73/POtagTfv_o.png" alt="在这里插入图片描述"><br> 可以发现，已经创建了新的对象，按照单例模式的说法，它们应该是一个对象才对，但是结果证明，通过反射能够破解掉单例模式，通过反射创建了两个不同的对象，其他的你们也可以使用这种方式去测试一下，结果都是一样的。</p> 
<p>那么我们要怎么解决反射破解单例模式这样的一个问题呢？首先我们可以去查看反射的源码：<br> <img src="https://images2.imgbox.com/13/8f/HyC8wEtq_o.png" alt="在这里插入图片描述"><br> 源码中我们可以看见这么一句话，<font color="red">如果你的这个类型是枚举类型，想要通过反射去创建对象时会抛出一个异常（不能通过反射创建枚举对象）</font>;</p> 
<h2><a id="_256"></a>枚举单例模式的解释</h2> 
<p>枚举是JDK1.5出来的，自带单例模式。<br> 那么我们来看一下枚举怎么实现单例模式：</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 枚举实现单例
 */</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span>  EnumSingle <span class="token punctuation">{<!-- --></span>
    INSTANCE<span class="token punctuation">;</span>
    <span class="token keyword">public</span> EnumSingle <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        EnumSingle instance1 <span class="token operator">=</span> EnumSingle<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
        EnumSingle instance2 <span class="token operator">=</span> EnumSingle<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：<br> <img src="https://images2.imgbox.com/89/55/lZdezSl0_o.png" alt="在这里插入图片描述"><br> 接下来我们测试一下，反射能不能破坏枚举实现的单例：<br> 这里我用原来的代码的进行测试，就是名字不一样而已，将原来的Demo05改为了EnumeSingle。</p> 
<p>首先我们查看一下源码中是有参构造还是无参构造，我们一个一个的侧，找到EnumeSingle的class文件，查看里面是无参构造，然后我们使用反射去将私有的构造器的私有属性破除掉。<br> <img src="https://images2.imgbox.com/f1/45/sVJAIsX8_o.png" alt="在这里插入图片描述"><br> 我们发现class文件里面确实有私有的无参构造器，下面我们去测试一下看能不能通过构造器破解掉枚举的单例模式：</p> 
<pre><code class="prism language-java"><span class="token comment">//测试通过反射是否能够破解枚举方式的单例模式</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{<!-- --></span>
        EnumSingle instance1 <span class="token operator">=</span> EnumSingle<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
        <span class="token comment">//使用反射获取无参构造器</span>
        Constructor<span class="token generics function"><span class="token punctuation">&lt;</span>EnumSingle<span class="token punctuation">&gt;</span></span> declaredConstructor <span class="token operator">=</span> EnumSingle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将构造器的私有属性破除掉</span>
        declaredConstructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取对象</span>
        EnumSingle instance2 <span class="token operator">=</span> declaredConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：<br> <img src="https://images2.imgbox.com/f5/78/FFb48Qh9_o.png" alt="在这里插入图片描述"><br> 然后竟然抛出了没有无参构造这么一个异常，它说我们这个类里面没有一个空参的构造器，前面给图中不就有一个无参构造器吗？这难道不是坑爹吗？而反射的newInstance源码中。正常的报错应该是以下错误（不能使用反射创建枚举对象）：<br> <img src="https://images2.imgbox.com/ae/3a/iAbrlVHY_o.png" alt="在这里插入图片描述"><br> 那就说明IDEA骗了我们，IDEA告诉我们EnumeSingle.class文件中有一个无参构造方法，但是通过Java程序运行我们知道这里面根本没有这玩意儿，接下来我们去分析一下是什么原因。</p> 
<p>我们使用反编译工具去编译一下，将EnumeSingle.class文件反编译成java文件。<br> <img src="https://images2.imgbox.com/c7/b4/H9BsW9d0_o.png" alt="在这里插入图片描述"><br> 反编译出来的Java文件，查看其中的代码发现IDEA是个骗子，这里用了有参构造，<br> 这个时候我们就去修改代码继续测试：</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 枚举实现单例
 */</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span>  EnumSingle <span class="token punctuation">{<!-- --></span>
    INSTANCE<span class="token punctuation">;</span>
    <span class="token keyword">public</span> EnumSingle <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span> InvocationTargetException<span class="token punctuation">,</span> InstantiationException <span class="token punctuation">{<!-- --></span>
        EnumSingle instance1 <span class="token operator">=</span> EnumSingle<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
        <span class="token comment">//使用反射获取无参构造器</span>
        Constructor<span class="token generics function"><span class="token punctuation">&lt;</span>EnumSingle<span class="token punctuation">&gt;</span></span> declaredConstructor <span class="token operator">=</span> EnumSingle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将构造器的私有属性破除掉</span>
        declaredConstructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取对象</span>
        EnumSingle instance2 <span class="token operator">=</span> declaredConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个时候输出：<br> <img src="https://images2.imgbox.com/69/38/sP1TTMEE_o.png" alt="在这里插入图片描述"><br> 结果还是证明了反射不能破解枚举实现的单例模式，果然如反射的源码中所述不能破解枚举，枚举还是牛逼啊。</p> 
<h2><a id="_346"></a>单例模式总结</h2> 
<p><strong>• 常见的五种单例模式实现方式</strong><br> – 主要：<br> <strong>• 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）</strong><br> <strong>• 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</strong><br> – 其他：<br> • 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）<br> <strong>• 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)</strong><br> • 枚举式(线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化漏洞！)</p> 
<p><strong>• 如何选用?</strong><br> – 单例对象 占用 资源 少，不需要 延时加载：<br> • 枚举式 好于 饿汉式</p> 
<p>– 单例对象 占用 资源 大，需要 延时加载：<br> • 静态内部类式 好于 懒汉式</p> 
<p><strong>寄言：</strong><br> 学习设计模式时一定要动手去敲代码，再加以理解，尤其是饿汉式和懒汉式，一定要熟悉到自己能够手写出来，因为面试的时候经常会让你手写出来（亲测）。</p> 
<blockquote> 
 <blockquote> 
  <p>源码链接（Gitee码云）：<a href="https://gitee.com/oldou/javadesignpatterns" rel="nofollow">https://gitee.com/oldou/javadesignpatterns</a><br> 这里有我整理好的Java23种设计模式的源码以及博客教程，博客教程中介绍了Java23种设计的模式的各种实现方式以及应用场景，非常适用于学习以及提高我们的设计思维，如果对大家有所帮助，请记得star一下给予作者一定的精神支持，你的star是我写出更好的博客的动力，谢谢大家。</p> 
 </blockquote> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1443ba5da7794ee9c4c47f1265c3c23/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">我就是小马那个穷困潦倒的诗人程序员朋友</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/746e6d8eb29c7c4124ca78522379fb86/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用Echarts实现中国地图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>