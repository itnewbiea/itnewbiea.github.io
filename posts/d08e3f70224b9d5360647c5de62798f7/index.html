<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis动态 sql用法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mybatis动态 sql用法" />
<meta property="og:description" content="什么是动态SQL？ 根据不同条件拼接 SQL 语句，实现对数据库更准确的操作。
为什么会有动态SQL？ 因为在我们的网页中，很多功能都是不能写死的，先不说会增加我的工作量，更会影响我们代码的效率。
以下列网站的功能为例，那么多查询条件，一个一个写都要写几十条，更别说把他们组合起来做查询了！！！
如何使用动态SQL? 两种方式：
①映射器XML配置文件
②注解
映射器XML配置文件使用动态SQL if：单条件分支判断:&lt; if test =&#34;条件&#34;&gt; 满足条件的语句&lt;/if&gt;
&lt;select id=&#34;findoneStudent&#34; resultMap=&#34;stu_class_map&#34; parameterType=&#34;student&#34;&gt; &lt;!-- 利用反射对象，让resultType知道我们需要的类型Class.forName(&#34;com.mysql.cj.jdbc.Driver&#34;)--&gt; &lt;!-- parameterType=传入参数的类型 ,有传入参数的时候用--&gt; select * from student where 1=1 &lt;if test=&#34;ssex!=null&#34;&gt; and ssex =#{ssex} &lt;!--如果条件成立则将标签包裹的sql语句拼接，不满足则直接忽略，继续往下执行--&gt; &lt;/if&gt; &lt;if test=&#34;classid!=0&#34;&gt; and classid=#{classid} &lt;/if&gt; &lt;/select&gt; 使用if if时，因为sql语句的拼接，导致每句sql语句前面都要加个连接关键字and,但是这时候如果第一个条件为空时，直接拼接后面带and的语句，就会出现运行错误。可以在where前面加个恒成立1=1，拼接后面的sql；之后所有的sql语句都要加上and； choose ：多条件分支判断，等 同于 java 的 switch 。
&lt;select id=&#34;findonechose&#34; resultMap=&#34;stu_class_map&#34; parameterType=&#34;student&#34;&gt; &lt;include refid=&#34;stu_find&#34;&gt;&lt;/include&gt; where 1=1 &lt;choose&gt; &lt;when test=&#34;ssex!=null&#34;&gt; and ssex=#{ssex} &lt;/when&gt; &lt;when test=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d08e3f70224b9d5360647c5de62798f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-14T14:39:19+08:00" />
<meta property="article:modified_time" content="2022-08-14T14:39:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis动态 sql用法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81SQL%EF%BC%9F"><strong>什么是动态SQL？</strong></h4> 
<p>        根据不同条件拼接 SQL 语句，实现对数据库更准确的操作。</p> 
<h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%8A%A8%E6%80%81SQL%EF%BC%9F"><strong>为什么会有动态SQL？</strong></h4> 
<p>        因为在我们的网页中，很多功能都是不能写死的，先不说会增加我的工作量，更会影响我们代码的效率。</p> 
<p>        以下列网站的功能为例，那么多查询条件，一个一个写都要写几十条，更别说把他们组合起来做查询了！！！</p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/84/1c/wNakVs63_o.png" width="229"></p> 
<h4 id="%C2%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81SQL%3F"><strong> 如何使用动态SQL?</strong></h4> 
<p>        两种方式：</p> 
<p>        ①映射器XML配置文件</p> 
<p>        ②注解</p> 
<p></p> 
<h3 id="%E6%98%A0%E5%B0%84%E5%99%A8XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81SQL"><strong>映射器XML配置文件使用动态SQL</strong></h3> 
<p>       <span style="color:#fe2c24;"><strong> if</strong>：单条件分支判断:</span>&lt; if test ="条件"&gt; 满足条件的语句&lt;/if&gt;</p> 
<pre><code class="language-XML">&lt;select id="findoneStudent" resultMap="stu_class_map" parameterType="student"&gt;
	&lt;!-- 利用反射对象，让resultType知道我们需要的类型Class.forName("com.mysql.cj.jdbc.Driver")--&gt; 
	&lt;!-- parameterType=传入参数的类型 ,有传入参数的时候用--&gt; 
select * from student where 1=1
&lt;if test="ssex!=null"&gt;
and ssex =#{ssex} 
    &lt;!--如果条件成立则将标签包裹的sql语句拼接，不满足则直接忽略，继续往下执行--&gt;
&lt;/if&gt;
&lt;if test="classid!=0"&gt;
and classid=#{classid} 
&lt;/if&gt;
&lt;/select&gt;</code></pre> 
<p>    使用if  if时，因为sql语句的拼接，导致每句sql语句前面都要加个连接关键字and,但是这时候如果第一个条件为空时，直接拼接后面带and的语句，就会出现运行错误。可以在where前面加个恒成立1=1，拼接后面的sql；之后所有的sql语句都要加上and；   </p> 
<p><span style="color:#fe2c24;"><strong>choose</strong> ：多条件分支判断，等 同于 java 的 switch 。</span></p> 
<pre><code class="language-XML"> &lt;select id="findonechose" resultMap="stu_class_map" parameterType="student"&gt;
 &lt;include refid="stu_find"&gt;&lt;/include&gt; where 1=1
 	&lt;choose&gt;
 &lt;when test="ssex!=null"&gt;
 and ssex=#{ssex}
 &lt;/when&gt;
 &lt;when test="classid!=0"&gt;
 and classid=#{classid}
 &lt;/when&gt;
 &lt;otherwise&gt;
 and sname="奥特曼"
&lt;!--当以上when全不满足则执行otherwise里的代码--&gt;
&lt;!--我很可以有多个，otherwise只能有一个--&gt;
 &lt;/otherwise&gt;
 	&lt;/choose&gt;
 &lt;/select&gt;</code></pre> 
<p><span style="color:#fe2c24;"><strong>where</strong>:自动拼接where，去and或者or</span></p> 
<p></p> 
<p>如果我们第一条的查询条件全部为空时</p> 
<pre><code class="language-XML">select * from student where
&lt;if test="ssex!=null"&gt;
and ssex =#{ssex} 
&lt;/if&gt;
&lt;!--如何我们的这段代码不用1=1的这种办法处理，且if里面为null时，我们的sql语句就会出错--&gt;
&lt;!--就会变成这个样子：select * from student where  --&gt;</code></pre> 
<p>这时候可以用我们的where处理</p> 
<pre><code class="language-XML">&lt;select id="findwhere" resultMap="stu_class_map" parameterType="student"&gt;
    select * from student
      &lt;where&gt;
 	        &lt;if test="ssex!=null"&gt;
 	            and ssex =#{ssex} 
 	        &lt;/if&gt;
 	        &lt;if test="classid!=0"&gt;
 	            and classid=#{classid} 
 	        &lt;/if&gt;
     &lt;/where&gt;
     &lt;!--where 只会在至少有一条sql语句被拼接时才会加入，也会自动帮我们去的开头的and,or--&gt;
&lt;/select&gt;</code></pre> 
<p><span style="color:#fe2c24;"><strong>set</strong>:类似于where，主要是用在新增中 ，会在第一条拼接的语句中自动加上set关键字，并去除，(逗号)</span></p> 
<pre><code class="language-XML">&lt;update id="//updateStudent"   parameterType="com.ape.bean.Student"&gt;
 update student
 &lt;set&gt;
 &lt;if test="sname!=null"&gt;sname=#{sname},&lt;/if&gt;
 &lt;if test="ssex!=null"&gt;ssex=#{ssex},&lt;/if&gt;
 &lt;if test="birthday!=null"&gt;birthday=#{birthday},&lt;/if&gt;
 &lt;if test="classid!=0"&gt;classid=#{classid},&lt;/if&gt;
 &lt;/set&gt;
 &lt;where&gt;sid=#{sid}&lt;/where&gt;
 &lt;/update&gt;

&lt;!--在包含的语句前输出一个 set，
然后如果包含的语句是以逗号结束的话将会
把该逗号忽略。有了 set 元素就可以动态的更
新那些修改了的字段--&gt;</code></pre> 
<p><strong><span style="color:#fe2c24;">trim:</span></strong><span style="color:#fe2c24;">万能标签，可代替任意元素标签，进行自定义的拼接，去除；</span></p> 
<pre><code>
&lt;trim prefix="(" suffixOverrides="," suffix=")"&gt;
    &lt;if test="sname!=null"&gt;sname,&lt;/if&gt;
&lt;/trim&gt;
&lt;!--里面有两组标签属性
prefix--开头加上什么，prefixOverrides--开头去掉什么
suffix--结尾加上什么，suffixOverrides--结尾去掉什么--&gt;

&lt;!--修改--&gt;
&lt;update id="updateStudent"   parameterType="Student"&gt;
 update student
 &lt;trim prefix="set" suffixOverrides=","&gt;
 &lt;if test="sname!=null"&gt;sname=#{sname},&lt;/if&gt;
 &lt;if test="ssex!=null"&gt;ssex=#{ssex},&lt;/if&gt;
 &lt;if test="birthday!=null"&gt;birthday=#{birthday},&lt;/if&gt;
 &lt;if test="classid!=0"&gt;classid=#{classid},&lt;/if&gt;
&lt;/trim&gt;
 &lt;where&gt;sid=#{sid}&lt;/where&gt;
 &lt;/update&gt;


&lt;!--新增--&gt;
 &lt;insert id="addStudent" parameterType="Student"&gt;
 insert into student 
 &lt;trim prefix="(" suffixOverrides="," suffix=")"&gt;
 &lt;if test="sname!=null"&gt;sname,&lt;/if&gt;
 &lt;if test="ssex!=null"&gt;ssex,&lt;/if&gt;
 &lt;if test="birthday!=null"&gt;birthday,&lt;/if&gt;
 &lt;if test="classid!=0"&gt;classid,&lt;/if&gt;
 &lt;/trim&gt;
 values
 &lt;trim prefix="(" suffixOverrides="," suffix=")"&gt;
 &lt;if test="sname!=null"&gt;#{sname},&lt;/if&gt;
 &lt;if test="ssex!=null"&gt;#{ssex},&lt;/if&gt;
 &lt;if test="birthday!=null"&gt;#{birthday},&lt;/if&gt;
 &lt;if test="classid!=0"&gt;#{classid},&lt;/if&gt;
 &lt;/trim&gt;
 &lt;/insert&gt;</code></pre> 
<p><span style="color:#fe2c24;"><strong>foreach:循环</strong></span></p> 
<pre><code class="language-XML">&lt;!--foreach循环--&gt;
&lt;foreach collection="list" item="n" open="(" close=")"separator=","&gt;
	#{n}
&lt;/foreach&gt;
&lt;!--foreach标签里的参数：
collection ：传入集合类型list,数组类型：array,或者其他别名
item="n":接参（可写任意）
open="(" 开头加上什么
close=")结尾加上什么
separator=","分隔符是什么；--&gt;

例：
&lt;select id="findbyList"   resultMap="stu_class_map"  parameterType="Student" &gt;
select * from student where sid in
&lt;foreach collection="list" item="n" open="(" close=")" separator=","&gt;
	#{n}
&lt;/foreach&gt;
 &lt;/select&gt;</code></pre> 
<p><span style="color:#fe2c24;"><strong>bind</strong>：取别名，在 动态sql里充当处理模糊查询的作用。</span></p> 
<pre><code class="language-XML">&lt;bind name="mh" value="_parameter+'%'"/&gt;
&lt;!--name=要取的名字--&gt;
value=_parameter     _parameter就是我们要传入的值，可以在这里做拼接
&lt;!--使用时，只需要填入给标签取的名字--&gt;
select * from student where sname like #{mh}


例：
 &lt;/select&gt;
 &lt;select id="1findBymh" resultMap="stu_class_map" parameterType="String"&gt;
 &lt;bind name="mh" value="_parameter+'%'"/&gt;
 select * from student where sname like #{mh}
 &lt;/select&gt;</code></pre> 
<p><strong><span style="color:#fe2c24;">sql片段</span></strong>：不是完整的sql语句<br> &lt;sql id=""&gt;    sql片段，字段&lt;/sql&gt;<br> 使用<br> &lt;include id="sqlid"&gt;sqll片段&lt;/include&gt;<br> 可以代替写入的sql片段</p> 
<pre><code class="language-XML">&lt;sql id="stu_find"&gt;
select * from student
&lt;/sql&gt;


 &lt;select id="findallStudent"   resultMap="stu_class_map"  &gt;
&lt;include refid="stu_find"&gt;&lt;/include&gt; left join class on student.classid=class.classid;
 &lt;/select&gt;


输出之后 sql语句就会变成
select * from student left join class on student.classid=class.classid;


&lt;include refid="stu_find"&gt;&lt;/include&gt;会代替我们自定义的sql片段


</code></pre> 
<h3>注解中使用动态sql</h3> 
<p>一，查询</p> 
<pre><code class="language-java">@Select("select * from student ")
public List&lt;Student&gt; findAllStu();

解决多参的问题可以用@Param注解取别名，然后再sql语句中使用别名</code></pre> 
<p><br> 二，新增</p> 
<pre><code class="language-java">@Insert("insert into student(sname,ssex,birthday,classid) values(sname,ssex,birthday,classid)")
    @Options(keyProperty = "sid", useGeneratedKeys = true)
    public int addStudent(Student s);
主键回填问题可以用@Options注解</code></pre> 
<p>三，<br> 单表联查，1v1<br> 普通联查发现，主表下面的副标是空值，因为没有做映射；我们在xml文件的时候是用resultMap标签完成的，但是在注释里我们使用Results</p> 
<pre><code class="language-java">@Results({
    @Result(column ="classid",property = "classid"),
    @Result(column ="classid",one = @One(select ="com.ape.Mapper.BjMapper.findBjbyclassid"),property ="bj")

    })
    @Select("select * from student")
    public List&lt;Student&gt; findStuandClass();</code></pre> 
<p><br> 做联查映射关系，column=主表的关联字段，one注解=@one (selec=t获取一个字符串(通过该字符串获取带参数的对象))，<br> 这里需要创建一个接口，写一个获取该对象的方法<br> select=该接口的类路径.方法</p> 
<p>最后赋值给prepery"对象"；<br> prepery对象就是我们要做映射的对象。最终会把coulumn字段映射给prepery对象对应的属性，这时候，主表的映射就没了，需要自己再声明一次<br> ,注释的sql语句没有联查 语法，不能left,join,right;</p> 
<p>四，多表联查</p> 
<p>一对多：</p> 
<p>关键字用many@Many,其他地方跟一对一基本一样 <br> ，many注解=@Many (selec=t获取一个字符串(通过该字符串获取带参数的对象))，</p> 
<h4>用方法写 sql语句:</h4> 
<pre><code class="language-java">

@UpdateProvider(type = tclei.class,method = "updt")
	public int updateTecher(Teacher t);

//type=类映射,写有sql语句的方法的类名，
//methd=类里面的方法名
	
	class tclei{
		public String updt(Teacher t) {
//sql方法参数的类型必须跟方法入参的类型一样
			String sql="update teacher set ";
			if (t.getTname()!=null) {
				sql+="tname=#{tname}";
			}
			if (t.getTname()!=null) {
				sql+=",";
			}
			
			if (t.getTbirthday()!=null) {
				sql+="Tbirthday=#{Tbirthday}";
			}
			if (t.getTbirthday()!=null) {
				sql+=",";
			}
			
			if (t.getTsex()!=0) {
				sql+="Tsex=#{Tsex}";
			}
			if (t.getTsex()!=0) {
				sql+=",";
			}
			
			if (t.getTaddress()!=null) {
				sql+="Taddress=#{Taddress}";
			}
			if (t.getTaddress()!=null) {
				sql+=",";
			}
			
			if (t.getTemail()!=null) {
				sql+="Temail=#{Temail}";
			}
			//sql=sql.substring(0, sql.length()-1);
			sql+=" where tid=#{tid}";
			return sql;}
	}</code></pre> 
<p>SQL方法的过度：构造器,就是SQL方法的升级版<br> 构造器SQL<br> return new SQL( ) {  {  <br> SECECT（可以写多个select,会自动拼接里面的内容）<br> FROM<br> if<br> WHERE<br> if<br> } }<br> 多个判断用WHERE隔开，WHERE会自动拼接and</p> 
<p>删除</p> 
<pre><code class="language-java">@DeleteProvider(type = DelTea.class,method = "deleteTeacher")
	public int deleteTeacher( Teacher t);
//type：类名
//method:方法名

class DelTea{
     /返回值必须是String类型
	public String deleteTeacher( Teacher t) {
	return new SQL() {<!-- -->{
		DELETE_FROM("teacher");
		if (t.getTid()!=0) {	
			WHERE("tid=#{tid}");
		}else {
			WHERE("tid=0");
		}
		
	}}.toString();
	}
}</code></pre> 
<p><br>  </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1408a69637365a2350bd1280a023744/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">适配与视口、分辨率、媒体查询、缩放的学习、消化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9cd5cd24198ce808cc5e73e67b5800e7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">单GDB调试RISC-V CPU 多核时，continue 命令行为解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>