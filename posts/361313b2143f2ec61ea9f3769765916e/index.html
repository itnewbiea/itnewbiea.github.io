<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring自带定时任务框架Schedule - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring自带定时任务框架Schedule" />
<meta property="og:description" content="import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; @Component @EnableScheduling public class SchedulerTask{ /* * * DESC : 编写定时任务，每5秒输出一次 * */ @Scheduled(cron = &#34;*/5 * * * * ?&#34;) private void scheduleTask(){ System.out.println(&#34;Schedule............&#34;); } } 如果想要在项目启动时就执行一次定时任务，可以实现InitializingBean接口
import org.springframework.beans.factory.InitializingBean; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; @Component @EnableScheduling public class SchedulerTask implements InitializingBean{ /* * * DESC : 编写定时任务，每5秒输出一次 * */ @Scheduled(cron = &#34;*/5 * * * * ?&#34;) private void scheduleTask(){ System.out.println(&#34;Schedule............&#34;); } @Override public void afterPropertiesSet() throws Exception { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/361313b2143f2ec61ea9f3769765916e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-05T10:27:06+08:00" />
<meta property="article:modified_time" content="2020-08-05T10:27:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring自带定时任务框架Schedule</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre><code class="language-java">import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
 
@Component
@EnableScheduling
public class SchedulerTask{
	
	
	/*
	 * 
	 * DESC :  编写定时任务，每5秒输出一次
	 * 
	 */
	@Scheduled(cron = "*/5 * * * * ?")
	private void scheduleTask(){
		System.out.println("Schedule............");
	}
 
 
}</code></pre> 
<p><strong>如果想要在项目启动时就执行一次定时任务，可以实现InitializingBean接口</strong></p> 
<pre><code class="language-java">import org.springframework.beans.factory.InitializingBean;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
 
@Component
@EnableScheduling
public class SchedulerTask implements InitializingBean{
	
	
	/*
	 * 
	 * DESC :  编写定时任务，每5秒输出一次
	 * 
	 */
	@Scheduled(cron = "*/5 * * * * ?")
	private void scheduleTask(){
		System.out.println("Schedule............");
	}
 
	@Override
	public void afterPropertiesSet() throws Exception {
		this.scheduleTask();	//调用定时任务，项目初始化就会执行一次
	}
 
 
}</code></pre> 
<p><strong>有关触发器时间表达式corn配置</strong></p> 
<pre><code class="language-java">每隔5秒执行一次任务：  "*/5 * * * * ?"
 
每隔1分钟执行一次任务：  "0 */1 * * * ?"
 
每天23点执行一次任务：  "0 0 23 * * ?"
 
每天凌晨1点执行一次任务：  "0 0 1 * * ?"
 
每月1号凌晨1点执行一次任务：  "0 0 1 1 * ?"
 
每月1号凌晨2点执行一次任务：  "0 0 2 1 * ? *"
 
每月最后一天23点执行一次任务：  "0 0 23 L * ?"
 
每周星期天凌晨1点执行一次任务：  "0 0 1 ? * L"
 
26分、29分、33分各执行一次任务：  "0 26,29,33 * * * ?"
 
每天的0点、13点、18点、21点各执行一次任务：   "0 0 0,13,18,21 * * ?"
 
周一到周五每天上午10:15执行一次任务:  "0 15 10 ? * MON-FRI" 
 
2020-2021年的每个月的最后一个星期五上午10:15执行一次任务： "0 15 10 ? 6L 2020-2021"
 
 
 
#在线配置
https://qqe2.com/cron</code></pre> 
<p>定时任务编写试验</p> 
<pre><code class="language-java">@Slf4j
@Component
@RestController
@AllArgsConstructor
@ApiOperation(value = "临时额度到期逻辑处理")
public class ResidualMarginTask {
    /**
     * 基本信息
     */
    @Autowired
    private ChannelQuotaInfoService channelQuotaInfoService;

    /**
     * 每天上午10点、下午14点、下午16点执行
     */
    @Scheduled(cron = "0 0 10,14,16 * * ?")
    public void start() {
        Date date = new Date();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        //获取当前日期时间
        Long dayTime = calendar.getTime().getTime();
        //Step1：查询额度信息表数据并更新数据库
        List&lt;ChannelQuotaInfo&gt; list = channelQuotaInfoService.list(Wrappers.&lt;ChannelQuotaInfo&gt;query().lambda());
        List&lt;ChannelQuotaInfo&gt; quotaInfoList = new ArrayList&lt;&gt;();
        if (list != null &amp;&amp; list.size() &gt; 0) {
            for (int i = 0; i &lt; list.size(); i++) {
                ChannelQuotaInfo info = list.get(i);
                Long endTime = info.getValidityTermEnd().getTime();
                //判断如果当前日期大于临时额度有效期：表示临时额度已过期，需要将临时额度清零，且剩余额度对应减少
                if (dayTime &gt;= endTime) {
                    //获取剩余额度
                    BigDecimal surplusQuota = info.getSurplusQuota() == null ? BigDecimal.ZERO : info.getSurplusQuota();
                    //获取临时额度
                    BigDecimal tempQuota = info.getTempQuota() == null ? BigDecimal.ZERO : info.getTempQuota();
                    //剩余额度=剩余额度-临时额度
                    info.setSurplusQuota(surplusQuota.subtract(tempQuota));
                    //临时额度清零
                    info.setTempQuota(BigDecimal.ZERO);
                    channelQuotaInfoService.updateById(info);
                    quotaInfoList.add(info);
                }
            }

            //Step2: 调用渠道服务更新渠道子系统额度信息
            channelQuotaInfoService.synchronousLimitToChannel(quotaInfoList);
        }
    }
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a712ac977a3666f792f708828764a8bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">你的分支在3次提交之前领先于‘origin / master‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e55850f3216b507994c41726ad44cb09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何使用Python爬虫&#43;数据分析对新冠疫情数据实时监控！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>