<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】栈和队列 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】栈和队列" />
<meta property="og:description" content="一、栈 1.栈的概念与结构 栈是一种特殊的线性表，即栈也是线性表，可见栈的特性，栈只运行在特定的一端进行插入和删除操作，这一端我们就叫为栈顶，另一端我们称为栈底，所以栈有一个很重要的性质，即所有入栈的元素都遵循后进先出LIFO（last in first out）的原则。
2.栈的具体实现 栈的实现有两种实现方式，一种是链表，一种是顺序表，如果是链表的话也是可以实现的，我们知道单链表的尾插是需要遍历链表找到尾才可以尾插，故代价比较大，而顺序表的数组就相对代价小了很多，所以我们的栈是用顺序表实现的。
下面贴上栈的具体实现代码：
Stack.h --- 实现栈的函数的声明，类型的定义等等
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; #include&lt;stdbool.h&gt; // 支持动态增长的栈 typedef int STDataType; typedef struct Stack { STDataType* a; int top;	// 栈顶 int capacity; // 容量 }ST; // 初始化栈 void STInit(ST* ps); // 入栈 void STPush(ST* ps, STDataType data); // 出栈 void STPop(ST* ps); // 获取栈顶元素 STDataType STTop(ST* ps); // 获取栈中有效元素个数 int STSize(ST* ps); // 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 bool STEmpty(ST* ps); // 销毁栈 void STDestroy(ST* ps); Stack." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ad1c4ed7d8f05441402539cb39936028/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T21:33:53+08:00" />
<meta property="article:modified_time" content="2024-01-06T21:33:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】栈和队列</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、栈</h2> 
<h3>1.栈的概念与结构</h3> 
<p>        <span style="color:#fe2c24;">栈是一种特殊的线性表，即栈也是线性表，可见栈的特性，栈只运行在特定的一端进行插入和删除操作，这一端我们就叫为栈顶，另一端我们称为栈底，所以栈有一个很重要的性质，即所有入栈的元素都遵循后进先出LIFO（last in first out）的原则。</span></p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/dc/ac/Xhr9UEzq_o.png" width="739"></p> 
<h3>2.栈的具体实现</h3> 
<p>        <span style="color:#fe2c24;">栈的实现有两种实现方式，一种是链表，一种是顺序表，如果是链表的话也是可以实现的，我们知道单链表的尾插是需要遍历链表找到尾才可以尾插，故代价比较大，而顺序表的数组就相对代价小了很多，所以我们的栈是用顺序表实现的。</span></p> 
<p><span style="color:#0d0016;">下面贴上栈的具体实现代码：</span></p> 
<p><span style="color:#0d0016;">Stack.h --- 实现栈的函数的声明，类型的定义等等</span></p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

// 支持动态增长的栈
typedef int STDataType;

typedef struct Stack
{
	STDataType* a;
	int top;		// 栈顶
	int capacity;  // 容量 
}ST;

// 初始化栈 
void STInit(ST* ps);

// 入栈 
void STPush(ST* ps, STDataType data);

// 出栈 
void STPop(ST* ps);

// 获取栈顶元素 
STDataType STTop(ST* ps);

// 获取栈中有效元素个数 
int STSize(ST* ps);

// 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 
bool STEmpty(ST* ps);

// 销毁栈 
void STDestroy(ST* ps);
</code></pre> 
<p>Stack.c --- 栈的函数接口实现</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include"Stack.h"

void STInit(ST* ps)
{
	assert(ps);
	ps-&gt;a = NULL;

	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
}

void STPush(ST* ps, STDataType data)
{
	assert(ps);

	if (ps-&gt;top == ps-&gt;capacity)
	{
		int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
		STDataType* tmp = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * newcapacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		ps-&gt;a = tmp;
		ps-&gt;capacity = newcapacity;
	}
	ps-&gt;a[ps-&gt;top] = data;
	ps-&gt;top++;
}

void STPop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);

	ps-&gt;top--;
}

STDataType STTop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);

	return ps-&gt;a[ps-&gt;top - 1];
}

int STSize(ST* ps)
{
	assert(ps);

	return ps-&gt;top;
}

bool STEmpty(ST* ps)
{
	assert(ps);

	return ps-&gt;top == 0;
}

void STDestroy(ST* ps)
{
	assert(ps);
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;capacity = ps-&gt;top = 0;
}
</code></pre> 
<h2>二、队列</h2> 
<h3>1.队列的概念与结构</h3> 
<p>     <span style="color:#fe2c24;">   队列是一种在特定一端进行插入数据，另一端进行删除数据，分别为队列的入队和出队，</span></p> 
<p><span style="color:#fe2c24;">队列具有先进先出FIFO(first in first out)的特性。</span></p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/ea/3a/3CmrXlRv_o.png" width="850"></p> 
<h3>2.队列的具体实现</h3> 
<p>   <span style="color:#fe2c24;">     队列可以用链表和顺序表实现，但我们通常是使用链表实现，因为我们在数组头上入数据时需要进行大量的挪动数据，时间复杂度高，效率低，而链表的头插就会很方便，所以我们选用链表作为链表的实现方式。</span></p> 
<p>Queue.h --- 队列的函数的声明与类型的定义。</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;

typedef int QDataType;

// 链式结构：表示队列 
typedef struct QListNode
{
	struct QListNode* next;
	QDataType data;
}QNode;

// 队列的结构 
typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;

// 初始化队列 
void QueueInit(Queue* q);

// 队尾入队列 
void QueuePush(Queue* q, QDataType data);

// 队头出队列 
void QueuePop(Queue* q);

// 获取队列头部元素 
QDataType QueueFront(Queue* q);

// 获取队列队尾元素 
QDataType QueueBack(Queue* q);

// 获取队列中有效元素个数 
int QueueSize(Queue* q);

// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
bool QueueEmpty(Queue* q);

// 销毁队列 
void QueueDestroy(Queue* q);
</code></pre> 
<p>Queue.c --- 函数接口的实现</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include"Queue.h"

void QueueInit(Queue* q)
{
	assert(q);
	q-&gt;phead = q-&gt;ptail = NULL;
	q-&gt;size = 0;
}

void QueuePush(Queue* q, QDataType data)
{
	assert(q);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode-&gt;data = data;
	newnode-&gt;next = NULL;
	if (q-&gt;ptail == NULL)
	{
		q-&gt;phead = q-&gt;ptail = newnode;
	}
	else
	{
		q-&gt;ptail-&gt;next = newnode;
		q-&gt;ptail = newnode;
	}
	q-&gt;size++;
}

void QueuePop(Queue* q)
{
	assert(q);

	assert(q-&gt;phead);
	QNode* del = q-&gt;phead;
	q-&gt;phead = q-&gt;phead-&gt;next;
	free(del);
	del = NULL;

	if (q-&gt;phead == NULL)
		q-&gt;ptail = NULL;
	q-&gt;size--;
}

void QueueDestroy(Queue* q)
{
	assert(q);
	QNode* cur = q-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	q-&gt;phead = q-&gt;ptail = NULL;
	q-&gt;size = 0;
}

QDataType QueueFront(Queue* q)
{
	assert(q);
	assert(q-&gt;phead);

	return q-&gt;phead-&gt;data;
}

QDataType QueueBack(Queue* q)
{
	assert(q);
	assert(q-&gt;ptail);

	return q-&gt;ptail-&gt;data;
}

int QueueSize(Queue* q)
{
	assert(q);
	return q-&gt;size;
}

bool QueueEmpty(Queue* q)
{
	assert(q);

	return q-&gt;phead == NULL;
}</code></pre> 
<h3>3.循环队列</h3> 
<p>队列还有一种特殊的队列，这种队列就是循环队列。</p> 
<p><img alt="" height="635" src="https://images2.imgbox.com/e3/ab/9zoVedLi_o.png" width="980"></p> 
<p>对于循环队列的实现我们主要是弄懂空和满是如何判断的，这样我们就很容易就能写出一个循环队列。</p> 
<p>循环队列也是可以用链表和顺序表实现，但建议使用用顺序表实现，链表实现更不利于控制，具体小伙伴们可以尝试一下链表实现，可能会很痛苦哦！</p> 
<p>如果是用顺序表实现，如何判断空呢？</p> 
<p>如果我们申请k个空间存放k个数据。</p> 
<p>我们会学到用头与尾相等就可以了，但如何判断满呢？</p> 
<p>我们第一想法可能是头front在下标0的位置，尾rear在下标为k-1的位置，这样想，那可就太天真了。事实是front是不一定就是在下标为0的位置的，可能在其他的任何位置，那就很难判满了。</p> 
<p>由以上发现循环队列不像我们想的这么简单的，如果我们想它既能判空又能判满，那就必须再想一个方法，使判空和判满能互不干扰，一劳永逸。</p> 
<p>这里我们提供一个方法就是可以我们多申请一个额外空间，即申请k+1个空间，这样有了额外一个空间，判空依旧可以是front == rear 而判满就可以是 front == (rear + 1) % k + 1。</p> 
<p>下面有三个oj题，小伙伴们可以进行练习。</p> 
<h2>三、栈和队列的oj题</h2> 
<p><strong>1. 括号匹配问题。<a class="link-info" href="https://leetcode.cn/problems/valid-parentheses/" rel="nofollow" title="oj链接">oj链接</a><br> 2. 用队列实现栈。<a class="link-info" href="https://leetcode.cn/problems/implement-stack-using-queues/" rel="nofollow" title="oj链接">oj链接</a><br> 3. 用栈实现队列。<a class="link-info" href="https://leetcode.cn/problems/implement-queue-using-stacks/" rel="nofollow" title="oj链接">oj链接</a><br> 4. 设计循环队列。<a class="link-info" href="https://leetcode.cn/problems/design-circular-queue/" rel="nofollow" title="oj链接">oj链接</a></strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/914e883938704683137a5229c462c677/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Springboot整合RocketMQ 基本消息处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/544fa59f5dc17cb3a0af7925c2c820c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【c语言】程序环境和预处理（内功更上一层）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>