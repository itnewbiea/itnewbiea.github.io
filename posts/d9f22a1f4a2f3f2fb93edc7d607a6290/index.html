<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式开发入门设计 —— 色盲检测系统 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="嵌入式开发入门设计 —— 色盲检测系统" />
<meta property="og:description" content="目录
前言
设计目标
搭建环境
1、虚拟机与 windows 挂载共享文件目录
2、搭建虚拟测试环境（屏幕）
3、启动虚拟测试环境（屏幕） Code
1、打开（bmp）图片（open函数）
2、读取（bmp）图片（read函数）
3、显示（bmp）图片（mmap函数）
1）打开 lcd 驱动 2）内存映射mmap【*重点】
3）释放映射内存
4）关闭文件描述符
4、触摸屏
5、主函数
效果演示
结果演示
设计总结
前言 说到色盲，大家肯定会想到各种奇奇怪怪的图片，比如下图：
可能你看来看去，也看不出来图片中有啥；可能你第一眼看过去就知道图片中有个图形，但它是三角形呢？还是圆形呢？还是方形呢？「可先在评论区留下你的答案」，等会在文末附上参考答案。
既然是嵌入式，当然少不了虚拟机了。我用的是VMare Workstation 16，使用的ubuntu 也是16。至于为什么都是16呢，当然与它的各项性能有关。下面正式进入正题。
设计目标 搭建基本的开发环境实现基础的图片显示、切换模拟现实触摸屏效果计算测试结果，得出报告 搭建环境 测试测试，当然需要看到才能测试，所以先把测试环境给搭建起来。本次设计使用的屏幕是虚拟屏幕。至于为什么是虚拟屏幕，原因【￥】你懂我懂大家都懂。
1、虚拟机与 windows 挂载共享文件目录 最后可别忘了在底下点个「确定」。
2、搭建虚拟测试环境（屏幕） 进入共享文件夹：
进入触摸屏模拟器文件夹：
分别对 event_drv 和 mmap_drv 文件中的object文件 进行清除【对上次编译】和编译 ，以及安装驱动：
清楚指令：make clean
编译指令：make
驱动安装指令：sudo insmod xxx.ko
3、启动虚拟测试环境（屏幕） 就会看到如下图的lcd模拟器：
到此环境搭建、启动完成。接下来就交给程序猿了！
Code 有图才有测试，来先上图：
上图也没那么简单，不过也没有那么容易。
1、打开（bmp）图片（open函数） bmp图片是没有经过压缩的图格式bmp格式(24位图):文件信息头&#43;图片信息头&#43;像素点颜色码注意：bmp图片需要严格使用宽度是4的倍数(字节对齐) 如果不是4的倍数,bmp图片储存时宽度会自动补齐为4的倍数如果不处理这个问题,图片会倾斜 &lt;linux 提供了两个open函数，选其一即可&gt;
int open(const char *path, int oflag, ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d9f22a1f4a2f3f2fb93edc7d607a6290/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-14T19:04:35+08:00" />
<meta property="article:modified_time" content="2021-09-14T19:04:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式开发入门设计 —— 色盲检测系统</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow" title="前言">前言</a></p> 
<p id="%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87-toc" style="margin-left:0px;"><a href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87" rel="nofollow" title="设计目标">设计目标</a></p> 
<p id="%E7%8E%AF%E5%A2%83-toc" style="margin-left:0px;"><a href="#%E7%8E%AF%E5%A2%83" rel="nofollow" title="搭建环境">搭建环境</a></p> 
<p id="1%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%20windows%20%E6%8C%82%E8%BD%BD%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%20windows%20%E6%8C%82%E8%BD%BD%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95" rel="nofollow" title="1、虚拟机与 windows 挂载共享文件目录">1、虚拟机与 windows 挂载共享文件目录</a></p> 
<p id="2%E3%80%81%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E5%B1%8F%E5%B9%95%EF%BC%89-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E5%B1%8F%E5%B9%95%EF%BC%89" rel="nofollow" title="2、搭建虚拟测试环境（屏幕）">2、搭建虚拟测试环境（屏幕）</a></p> 
<p id="3%E3%80%81%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E5%B1%8F%E5%B9%95%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E5%B1%8F%E5%B9%95%EF%BC%89%C2%A0" rel="nofollow" title="3、启动虚拟测试环境（屏幕） ">3、启动虚拟测试环境（屏幕） </a></p> 
<p id="Code-toc" style="margin-left:0px;"><a href="#Code" rel="nofollow" title="Code">Code</a></p> 
<p id="1%E3%80%81%E6%89%93%E5%BC%80%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88open%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%89%93%E5%BC%80%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88open%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow" title="1、打开（bmp）图片（open函数）">1、打开（bmp）图片（open函数）</a></p> 
<p id="2%E3%80%81%E8%AF%BB%E5%8F%96%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88read%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%AF%BB%E5%8F%96%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88read%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow" title="2、读取（bmp）图片（read函数）">2、读取（bmp）图片（read函数）</a></p> 
<p id="3%E3%80%81%E6%98%BE%E7%A4%BA%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88mmap%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%98%BE%E7%A4%BA%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88mmap%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow" title="3、显示（bmp）图片（mmap函数）">3、显示（bmp）图片（mmap函数）</a></p> 
<p id="1%EF%BC%89%E6%89%93%E5%BC%80%20lcd%20%E9%A9%B1%E5%8A%A8%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E6%89%93%E5%BC%80%20lcd%20%E9%A9%B1%E5%8A%A8%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow" title="1）打开 lcd 驱动              ">1）打开 lcd 驱动              </a></p> 
<p id="%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%EF%BC%89%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%EF%BC%89%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap" rel="nofollow" title="2）内存映射mmap【*重点】">2）内存映射mmap【*重点】</a></p> 
<p id="3%EF%BC%89%E9%87%8A%E6%94%BE%E6%98%A0%E5%B0%84%E5%86%85%E5%AD%98-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E9%87%8A%E6%94%BE%E6%98%A0%E5%B0%84%E5%86%85%E5%AD%98" rel="nofollow" title="3）释放映射内存">3）释放映射内存</a></p> 
<p id="%C2%A0%204%EF%BC%89%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-toc" style="margin-left:80px;"><a href="#%C2%A0%204%EF%BC%89%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" rel="nofollow" title="4）关闭文件描述符">4）关闭文件描述符</a></p> 
<p id="5%EF%BC%89%E8%A7%A6%E6%91%B8%E5%B1%8F-toc" style="margin-left:40px;"><a href="#5%EF%BC%89%E8%A7%A6%E6%91%B8%E5%B1%8F" rel="nofollow" title="4、触摸屏">4、触摸屏</a></p> 
<p id="6%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0" rel="nofollow" title="5、主函数">5、主函数</a></p> 
<p id="%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA" rel="nofollow" title="效果演示">效果演示</a></p> 
<p id="%E7%BB%93%E6%9E%9C%E6%BC%94%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E6%9E%9C%E6%BC%94%E7%A4%BA" rel="nofollow" title="结果演示">结果演示</a></p> 
<p id="%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93" rel="nofollow" title="设计总结">设计总结</a></p> 
<hr id="hr-toc"> 
<h2>前言</h2> 
<p>说到色盲，大家肯定会想到各种奇奇怪怪的图片，比如下图：</p> 
<p style="text-align:center;"><img alt="" height="164" src="https://images2.imgbox.com/2d/fe/AHhvPPvi_o.png" width="282"></p> 
<p> 可能你看来看去，也看不出来图片中有啥；可能你第一眼看过去就知道图片中有个图形，但它是三角形呢？还是圆形呢？还是方形呢？<span style="color:#e6b223;">「可先在评论区留下你的答案」</span>，等会在<span style="color:#fe2c24;">文末</span>附上参考答案。</p> 
<p>既然是嵌入式，当然少不了虚拟机了。我用的是VMare Workstation 16，使用的ubuntu 也是16。至于为什么都是16呢，当然与它的各项性能有关。下面正式进入正题。</p> 
<h2 id="%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87">设计目标</h2> 
<ol><li>搭建基本的开发环境</li><li>实现基础的图片显示、切换</li><li>模拟现实触摸屏效果</li><li>计算测试结果，得出报告</li></ol> 
<h2 id="%E7%8E%AF%E5%A2%83">搭建环境</h2> 
<p>测试测试，当然需要看到才能测试，所以先把测试环境给搭建起来。本次设计使用的屏幕是虚拟屏幕。至于为什么是虚拟屏幕，原因<span style="color:#fe2c24;">【￥】</span>你懂我懂大家都懂。</p> 
<h3 id="1%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%20windows%20%E6%8C%82%E8%BD%BD%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span style="color:#1a439c;"><strong>1、虚拟机与 windows 挂载共享文件目录 </strong></span></h3> 
<p><img alt="" height="82" src="https://images2.imgbox.com/d9/dc/zcF23haI_o.png" width="656"></p> 
<p> <img alt="" height="148" src="https://images2.imgbox.com/f5/8c/1khZT2d3_o.png" width="656"></p> 
<p><img alt="" height="590" src="https://images2.imgbox.com/e1/97/usRWKONv_o.png" width="854"></p> 
<p> 最后可别忘了在底下点个<span style="color:#e6b223;">「确定」。</span></p> 
<h3 id="2%E3%80%81%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E5%B1%8F%E5%B9%95%EF%BC%89"><span style="color:#1a439c;"><strong>2、搭建虚拟测试环境（屏幕） </strong></span></h3> 
<p>        <strong>进入共享文件夹：</strong></p> 
<p style="text-align:center;"><img alt="" height="76" src="https://images2.imgbox.com/f7/6d/AfWDi1yT_o.png" width="462"></p> 
<p> <strong>进入触摸屏模拟器文件夹：</strong></p> 
<p style="text-align:center;"><img alt="" height="38" src="https://images2.imgbox.com/77/36/fynKYvhj_o.png" width="651"></p> 
<p><strong>分别对 event_drv 和 mmap_drv 文件中的object文件 进行清除【对上次编译】和编译 ，以及安装驱动：</strong></p> 
<blockquote> 
 <p><strong>清楚指令：make clean</strong></p> 
 <p><strong>编译指令：make</strong></p> 
 <p><strong>驱动安装指令：sudo insmod  xxx.ko</strong></p> 
</blockquote> 
<p><img alt="" height="633" src="https://images2.imgbox.com/fd/f8/AfPL2PSn_o.png" width="707"></p> 
<h3 id="3%E3%80%81%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E5%B1%8F%E5%B9%95%EF%BC%89%C2%A0"><span style="color:#1a439c;"><strong>3、启动虚拟测试环境（屏幕）  </strong></span></h3> 
<p><img alt="" height="155" src="https://images2.imgbox.com/2e/f2/TiCkvx4v_o.png" width="646"></p> 
<p><strong>就会看到如下图的lcd模拟器：</strong></p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/51/9c/tZlNHpKF_o.png" width="675"></p> 
<p> 到此环境搭建、启动完成。接下来就交给<strong><span style="color:#38d8f0;">程序猿</span></strong>了！</p> 
<h2 id="Code">Code</h2> 
<p>有图才有测试，来先上图：</p> 
<p>上图也没那么简单，不过也没有那么容易。</p> 
<h3 id="1%E3%80%81%E6%89%93%E5%BC%80%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88open%E5%87%BD%E6%95%B0%EF%BC%89"><span style="color:#1a439c;"><strong>1、打开（bmp）图片（open函数）</strong></span></h3> 
<ul><li><span style="color:#1c7331;">bmp图片是没有经过压缩的图格式</span></li><li><span style="color:#1c7331;">bmp格式(24位图):文件信息头+图片信息头+像素点颜色码</span></li><li><span style="color:#1c7331;">注意：bmp图片需要严格使用宽度是4的倍数(字节对齐)</span> 
  <ul><li><span style="color:#1c7331;">如果不是4的倍数,bmp图片储存时宽度会自动补齐为4的倍数</span></li><li><span style="color:#1c7331;">如果不处理这个问题,图片会倾斜</span></li></ul></li></ul> 
<p><span style="color:#0d0016;"><strong>&lt;linux 提供了两个open函数，选其一即可&gt;</strong></span></p> 
<pre><code class="language-cpp">int open(const char *path, int oflag, ...);
int openat(int fd, const char *path, int oflag, ...);//选用前者
</code></pre> 
<blockquote> 
 <p>        参数1：const char *path  —— <span style="color:#1c7331;">所需要打开的文件的路径以及文件名 </span></p> 
 <p><span style="color:#1c7331;">                        比如：/test/a.bmp （根目录下的a.bmp文件）</span></p> 
 <p>        参数2： oflag -—— <span style="color:#1c7331;">文件的权限 —— 分为：可读、可写、可读可写等</span></p> 
</blockquote> 
<p><img alt="" height="237" src="https://images2.imgbox.com/52/f3/OoVhFGem_o.png" width="661"></p> 
<blockquote> 
 <p>        返回值：</p> 
 <p>             <span style="color:#1c7331;">   返回 -1 则说明文件不可被创建 or 修改。</span></p> 
</blockquote> 
<pre><code class="language-cpp">代码如下：
int bmp_fd = open(bmp_name ,  O_RDWR);
	if(bmp_fd == -1){
		printf("open error %s\n ", bmp_name);
		return -1;
	}</code></pre> 
<h3 id="2%E3%80%81%E8%AF%BB%E5%8F%96%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88read%E5%87%BD%E6%95%B0%EF%BC%89"><span style="color:#1a439c;"><strong>2、读取（bmp）图片（read函数）</strong></span></h3> 
<p>&lt;与open函数一样，read函数同样也有两个&gt;</p> 
<pre><code class="language-cpp">ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
ssize_t read(int fildes, void *buf, size_t nbyte);//选用后者</code></pre> 
<blockquote> 
 <p><span style="color:#1c7331;">参数1：</span>fildes —— <span style="color:#1c7331;">所需要读取的文件描述符</span></p> 
 <p><span style="color:#1c7331;">参数2：</span>void *buf —— <span style="color:#1c7331;">储存读取到的数据（地方）</span></p> 
 <p><span style="color:#1c7331;">参数3：</span> size_t nbyte —— <span style="color:#1c7331;">储存多大字节的数据</span></p> 
</blockquote> 
<pre><code class="language-cpp">代码如下：
//创建能储存bmp颜色数据的buf
unsigned char bmp_buf[800*480*3];
//每次使用前，先对buf的内容进行清空处理
bzero(bmp_buf ,sizeof(bmp_buf));
//读取数据到buf里面
read(bmp_fd , bmp_buf ,sizeof(bmp_buf));
</code></pre> 
<h3 id="3%E3%80%81%E6%98%BE%E7%A4%BA%EF%BC%88bmp%EF%BC%89%E5%9B%BE%E7%89%87%EF%BC%88mmap%E5%87%BD%E6%95%B0%EF%BC%89"><span style="color:#1a439c;"><strong>3、显示（bmp）图片（mmap函数）</strong></span></h3> 
<p><span style="color:#1c7331;"><strong>俗话说：“眼见为实，耳听为虚。”所以我们必须来点实际的，将图片在虚拟屏幕上展示出来。</strong></span></p> 
<h4 id="1%EF%BC%89%E6%89%93%E5%BC%80%20lcd%20%E9%A9%B1%E5%8A%A8%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0"><strong>1）打开 lcd 驱动               </strong></h4> 
<pre><code class="language-cpp">int lcd_fd = open("/dev/ubuntu_lcd" ,  O_RDWR);    //驱动一般都在文件夹/dev/下
     if(lcd_fd == -1)
    {
	printf("open  lcd error!\n");
	return -1;
    }</code></pre> 
<h4 id="%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%EF%BC%89%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap"><strong>2）内存映射mmap【*重点】</strong></h4> 
<pre><code class="language-cpp">void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);</code></pre> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>参数1：void *addr —— 映射内存的起始地址,一般写NULL,由内核自动分配       <br> 参数2：size_t length  ——  映射内存的大小       <br> 参数3：int prot  —— 从以下参数选择一个或者多个,多个使用 位或 | 操作</strong></span></p> 
 <ul><li><span style="color:#0d0016;"><strong>               PROT_EXEC  可执行权限.</strong></span></li><li><span style="color:#0d0016;"><strong>               PROT_READ  可读权限.</strong></span></li><li><span style="color:#0d0016;"><strong>               PROT_WRITE 可写权限.</strong></span></li><li><span style="color:#0d0016;"><strong>               PROT_NONE  内存不可以操作.</strong></span></li></ul> 
 <p><strong><span style="color:#1c7331;">参数4：int flags  —— 使用MAP_SHARED,用于共享映射内存<br> 参数5：int fd ——  open函数打开的文件描述符<br> 参数6：off_t offset —— 操作共享内存的偏移量,用于映射屏幕写0,不需要偏移</span></strong></p> 
 <p><strong><span style="color:#1c7331;">返回值:成功 —— 返回映射内存的起始地址<br>             失败 —— 返回MAP_FAILED (MAP_FAILED是(void *) -1地址),并写入出错码</span></strong></p> 
</blockquote> 
<pre><code class="language-cpp">unsigned int *mmap_fd = (unsigned int *)mmap(NULL , 800*480*4 , PROT_READ |  PROT_WRITE , MAP_SHARED  , lcd_fd , 0);
	for(y=0 ;y&lt;480 ;y++)
	{
		for(x=0 ; x&lt;800 ;x++)
		{         
			*(mmap_fd+x+y*800) =  bmp_buf[x*3+(479-y)*800*3]&lt;&lt; 0  | bmp_buf[3*x+1+(479-y)*800*3]&lt;&lt;8 | bmp_buf[3*x+2+(479-y)*800*3]&lt;&lt;16 ;  //分别对应着R B G 的位置
		}	
	}</code></pre> 
<h4 id="3%EF%BC%89%E9%87%8A%E6%94%BE%E6%98%A0%E5%B0%84%E5%86%85%E5%AD%98"><strong>3）释放映射内存</strong></h4> 
<pre><code class="language-cpp">int munmap(void *addr, size_t length);</code></pre> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>参数1：void *addr ——  需要释放的内存映射地址(mmap返回的地址)<br> 参数2：size_t length ——  需要释放内存的大小</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>返回值：成功 —— 返回0<br>               失败 —— 返回-1,并写入出错码</strong></span></p> 
</blockquote> 
<pre><code class="language-cs">//原码如下：
munmap(mmap_fd , 800*480*4);</code></pre> 
<h4 id="%C2%A0%204%EF%BC%89%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><strong>4）关闭文件描述符</strong></h4> 
<pre><code class="language-cpp">//原码如下：	
close(bmp_fd);
close(lcd_fd);</code></pre> 
<h3 id="5%EF%BC%89%E8%A7%A6%E6%91%B8%E5%B1%8F"><strong>4、触摸屏</strong></h3> 
<p><strong><span style="color:#1c7331;">同样，触摸屏也是要打开的。</span></strong></p> 
<pre><code class="language-cpp">int ts_fd = open("/dev/ubuntu_event" ,  O_RDWR);
    if(ts_fd == -1)
    {
	printf("open ubuntu_event error !\n");
	return -1;
    }</code></pre> 
<p><span style="color:#0d0016;">但这里的触摸屏是根据触摸事件来判断的。但由于没有真正实感，只能通过鼠标点击。即通过捕抓x，y坐标进行判断当前事件。</span></p> 
<pre><code class="language-cpp">#include  &lt;linux/input.h&gt;

struct input_event {
	struct timeval time;	// 事件发生的事件
	__u16 type;		// 事件的类型 用来区分不同的硬件设备 比如键盘/鼠标/触摸屏...
	__u16 code;		// 事件编码   比如键盘的某个按键 
	__s32 value;		// 事件的值   比如某个按键时按下还是松开 / 状态
};</code></pre> 
<blockquote> 
 <p><strong><span style="color:#1c7331;">/*<br>  * Event types<br>  */<br> #define EV_SYN            0x00     //事件的分割标志       <br> #define EV_KEY            0x01    //按键事件<br> #define EV_REL            0x02    //相对位移事件 鼠标<br> #define EV_ABS            0x03    //绝对位移事件 触摸屏</span></strong></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>/*<br>  * Absolute axes<br>  */</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>#define ABS_X            0x00    // x轴<br> #define ABS_Y            0x01    // y轴</strong></span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong> 注意：</strong></span><span style="color:#4da8ee;">上面定义，都是linux的自带文件</span><span style="color:#1a439c;"><strong>，路径：</strong></span><span style="color:#ad720d;"><u> ../usr/include/linux/   </u>  </span> <span style="color:#1a439c;"><strong> </strong></span><span style="color:#be191c;"><strong> input.h</strong></span><span style="color:#1a439c;"><strong> </strong></span><span style="color:#0d0016;"><strong>或者 </strong></span><span style="color:#fe2c24;"><strong>input-event-codes.h</strong></span></p> 
<p>        我们不仅仅捕抓一次的（x，y），所以需要加入一个循环，将每一次点击的（x，y）都存起来。然后根据xy的范围值进行判断，判断当前用户的操作。</p> 
<pre><code class="language-cpp">struct input_event  data;	
//将触摸屏的信息读取到 data
printf("the touch screen was activited!\n");
while(1)
{	
	read( ts_fd , &amp;data , sizeof(struct input_event));
	//判断是不是触摸屏事件
	if(data.type == 3 &amp;&amp; data.code == 0)
	{
		//x轴的值
		*x = data.value;
		printf("x = %d\n" , *x);
	}else if(data.type == 3 &amp;&amp; data.code == 1)
	{
		//y轴的值
		*y = data.value;
		printf("y = %d\n" , *y);
		if(x&gt;0){
			break;
                }
	}		
}
	
//关闭触摸屏
close(ts_fd);</code></pre> 
<h3 id="6%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0"><span style="color:#1c7331;"><strong>5、主函数</strong></span></h3> 
<pre><code class="language-cpp">//部分原码：
int main()
{
	//初始化测试界面
	show_color();//白背景
	show_bmp("../picture/1.bmp" , 800 ,400 ,0 ,0);//题目一
	show_bmp("../picture/20.bmp" , 140 ,30 , 330 ,415);//下一题
	
	char auth_ans[3] = {'3', '3', '1'};//官方参考答案
	char usr_ans[3] = {0};//用户测试答案
	
/*
	i     //用来指示答案图片
	k     //用来指示下一道题
	j     //用来指示选择后跳转到下一道题
	b     //用来指示用户测试得到的答案
	a     //用来指示用户的测试结果比较
*/

	while(1){
		new_ts(&amp;x,&amp;y);
		if((280 &lt; x &amp;&amp; x &lt; 330 ) &amp;&amp; (360 &lt; y &amp;&amp; y &lt;390)) //选择答案是第一个
		{	
			show_bmp(picture_an[i + 0] , 800 ,400 ,0 ,0);
			show_bmp(picture_next[j], 140 ,30 , 330 ,415);
			usr_ans[b] = '1';
			printf("==== %c\n",usr_ans[b]);
		}
		
		if((370 &lt; x &amp;&amp; x &lt; 420 ) &amp;&amp; (360 &lt; y &amp;&amp; y &lt;390) )//选择答案是第二个
		{		
			show_bmp(picture_an[i + 1] , 800 ,400 ,0 ,0);
			show_bmp(picture_next[j], 140 ,30 , 330 ,415);
			usr_ans[b] = '2';
			printf("==== %c\n",usr_ans[b]);
		}
		
		if((460 &lt; x &amp;&amp; x &lt; 500 ) &amp;&amp; (360 &lt; y &amp;&amp; y &lt;390)) //选择答案是第三个
		{			
			show_bmp(picture_an[i + 2], 800 ,400 ,0 ,0);
			show_bmp(picture_next[j], 140 ,30 , 330 ,415);
			usr_ans[b] = '3';
			printf("==== %c\n",usr_ans[b]);
		}
		if((330 &lt; x &amp;&amp; x &lt; 470 ) &amp;&amp; (415 &lt; y &amp;&amp; y &lt; 445 ))
			{
				//切换到下一张图片测试
				if(k &lt; 3)
				{
					show_bmp( picture_topic[k], 800 ,400 ,0 ,0);
					j++;
					show_bmp(picture_next[j], 140 ,30 , 330 ,415);
				}
					k++;
					
					i = i+3;
					j++;
					b++;
			}
				printf("k = %d\n",k);
		if(k  &gt; 3 ){                                              //测试完成，打印结果
			show_bmp("../picture/done.bmp" , 800 ,480 ,0 ,0);
			printf("the test is done!!\n");
			break;
		}
		
	}
	return 0;
	
}</code></pre> 
<h2 id="%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA">效果演示</h2> 
<figure class="image"> 
 <img alt="" height="300" src="https://images2.imgbox.com/a1/b8/RdYHvhJS_o.png" width="500"> 
 <figcaption> 
  <strong>初始界面</strong> 
 </figcaption> 
</figure> 
<p></p> 
<figure class="image"> 
 <img alt="" height="300" src="https://images2.imgbox.com/54/63/dfEkKwRv_o.png" width="500"> 
 <figcaption> 
  <strong>选择界面</strong> 
 </figcaption> 
</figure> 
<p></p> 
<figure class="image"> 
 <img alt="" height="300" src="https://images2.imgbox.com/fe/9a/kAMkjrWh_o.png" width="500"> 
 <figcaption> 
  <strong> 下一题</strong> 
 </figcaption> 
</figure> 
<p> </p> 
<figure class="image"> 
 <img alt="" height="300" src="https://images2.imgbox.com/ae/98/4pF0xuVk_o.png" width="500"> 
 <figcaption> 
  <strong>测试结束</strong> 
 </figcaption> 
</figure> 
<h2 id="%E7%BB%93%E6%9E%9C%E6%BC%94%E7%A4%BA">结果演示</h2> 
<p><span style="color:#1a439c;"><strong>正常者</strong></span></p> 
<p><img alt="" height="171" src="https://images2.imgbox.com/dc/2a/ZhofqDIJ_o.png" width="476"></p> 
<p><span style="color:#1a439c;"><strong> 色弱者</strong></span></p> 
<p><img alt="" height="153" src="https://images2.imgbox.com/35/a5/JQyr0Hmi_o.png" width="503"></p> 
<p><span style="color:#1a439c;"><strong> 色盲者</strong></span></p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/b2/a0/kv2kAy13_o.png" width="482"></p> 
<p></p> 
<h2 id="%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93">设计总结</h2> 
<p>本设计为很基础的嵌入式开发设计，所用的素材基本都是就地取材，如read、open等函数。设计中唯一较难理解的应该就是内存映射的那一部分了。因为一个像素点包含4个字节，分别对应A、R、B、G。一个字节对应者8位比特。所以需要将图片提取出来的像素值给它安排到对应的位置上比如G是最后提取的，即左移0位即可；而R是首先提取的，所以要将其左移16位。同时数据的先后问题，所以会出现显示图片倒置的现象，只需将其纵坐标的值对称交换即可。实现同样的效果的方法还有很多，比如HTML5，因为HTML5设计出来的色盲检测系统可能会更贴切实际感官。同时设计效果还可以多样化，比如给用户提示哪一道错误、增加返回上一道题目的功能等。enmm，大脑继续开发！</p> 
<p><strong>注意：<span style="color:#9c8ec1;">本设计所有资源（lcd+源码）已上传，需要的自取</span></strong></p> 
<p><span style="color:#eaf4fc;">本设计中所用的资源，部分来源于网络，若侵权，联系删除。</span></p> 
<p><span style="color:#eaf4fc;">写在最后，本文不代表任何人观点，若有不足之处，欢迎指正~</span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7939ecaee8506a90756b5bb0c91f0d82/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UE4 RTXGI插件安装及使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1312d95f875545732c3421531275ee3e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">设置contenteditable属性的div粘贴图片问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>