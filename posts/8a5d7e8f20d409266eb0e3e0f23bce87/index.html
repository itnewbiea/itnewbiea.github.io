<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;基础之string类型 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;基础之string类型" />
<meta property="og:description" content="C&#43;&#43;基础之string类型 string 类型支持长度可变的字符串，C&#43;&#43; 标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。标准库 string 类型的目的就是满足对字符串的一般应用。
与其他的标准库类型一样，用户程序要使用 string 类型对象，必须包含相关头文件。如果提供了合适的 using 声明，那么编写出来的程序将会变得简短些：
#include &lt;string&gt; using std::string; string 对象的定义和初始化 string 标准库支持几个构造函数。构造函数是一个特殊成员函数，定义如何初始化该类型的对象。下面列出了几个 string 类型常用的构造函数。当没有明确指定对象初始化式时，系统将使用默认构造函数。
string s1;默认构造函数 s1 为空串string s2(s1);将 s2 初始化为 s1 的一个副本string s3(“value”);将 s3 初始化为一个字符串字面值副本string s4(n, ‘c’);将 s4 初始化为字符 ‘c’ 的 n 个副本 PS：因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 string 类型不是同一种类型。这一点很容易引起混乱，编程时一定要注意区分字符串字面值和 string 数据类型的使用，这很重要。
string 对象的读写 int main() { string s;	//定义一个空字符串 cin &gt;&gt; s;	//从标准输入读取 string 并将读入的串存储在 s 中 cout &lt;&lt; s &lt;&lt; endl;	return 0; } PS:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8a5d7e8f20d409266eb0e3e0f23bce87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-25T17:41:54+08:00" />
<meta property="article:modified_time" content="2018-09-25T17:41:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;基础之string类型</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Cstring_0"></a>C++基础之string类型</h2> 
<hr> 
<p>string 类型支持长度可变的字符串，C++ 标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。标准库 string 类型的目的就是满足对字符串的一般应用。<br> 与其他的标准库类型一样，用户程序要使用 string 类型对象，必须包含相关头文件。如果提供了合适的 using 声明，那么编写出来的程序将会变得简短些：</p> 
<pre><code>#include &lt;string&gt;
using std::string;
</code></pre> 
<h3><a id="string__10"></a>string 对象的定义和初始化</h3> 
<p>string 标准库支持几个构造函数。构造函数是一个特殊成员函数，定义如何初始化该类型的对象。下面列出了几个 string 类型常用的构造函数。当没有明确指定对象初始化式时，系统将使用默认构造函数。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>string s1;</td><td>默认构造函数 s1 为空串</td></tr><tr><td>string s2(s1);</td><td>将 s2 初始化为 s1 的一个副本</td></tr><tr><td>string s3(“value”);</td><td>将 s3 初始化为一个字符串字面值副本</td></tr><tr><td>string s4(n, ‘c’);</td><td>将 s4 初始化为字符 ‘c’ 的 n 个副本</td></tr></tbody></table> 
<p><strong>PS：因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 string 类型不是同一种类型。这一点很容易引起混乱，编程时一定要注意区分字符串字面值和 string 数据类型的使用，这很重要。</strong></p> 
<h3><a id="string__21"></a>string 对象的读写</h3> 
<pre><code>int main()
{
string s;				//定义一个空字符串
cin &gt;&gt; s;				//从标准输入读取 string 并将读入的串存储在 s 中
cout &lt;&lt; s &lt;&lt; endl;	
return 0;
}
</code></pre> 
<p><strong>PS:</strong><br> <strong>string 类型的输入操作符：</strong><br> <strong>读取并忽略开头所有的空白字符（如空格，换行符，制表符）。</strong><br> <strong>读取字符直至再次遇到空白字符，读取终止。</strong><br> 如果给定输入是"Hello World!"（注意到开头和结尾的空格），则屏幕上将输出"Hello"，而不含任何空格。</p> 
<h4><a id="_string__37"></a>读入未知数目的 string 对象</h4> 
<p>和内置类型的输入操作一样，string 的输入操作符也会返回所读的数据流。因此，可以把输入操作作为判断条件。下面的程序将从标准输入读取一组 string 对象，然后在标准输出上逐行输出：</p> 
<pre><code>int main()
{
string word;
while (cin &gt;&gt; word)
cout &lt;&lt; word &lt;&lt; endl;
return 0;
}
</code></pre> 
<p>上例中，用输入操作符来读取 string 对象。该操作符返回所读的 istream 对象，并在读取结束后，作为 while 的判断条件。如果输入流是有效的，即还未到达文件尾且未遇到无效输入，则执行 while 循环体，并将读取到的字符串输出到标准输出。如果到达了文件尾，则跳出 while 循环。</p> 
<h4><a id="_getline__50"></a>使用 getline 读取整行文本</h4> 
<p>另外还有一个有用的 string IO 操作：getline。这个函数接受两个参数：一个输入流对象和一个 string 对象。getline 函数从输入流的下一行读取，并保存读取的内容到不包括换行符。和输入操作符不一样的是，getline 并不忽略行开头的换行符。只要 getline 遇到换行符，即便它是输入的第一个字符，getline 也将停止读入并返回。如果第一个字符就是换行符，则 string 参数将被置为空 string。<br> getline 函数将 istream 参数作为返回值，和输入操作符一样也把它用作判断条件。例如，重写前面那段程序，把每行输出一个单词改为每次输出一行文本：</p> 
<pre><code>int main()
{
string line;
while (getline(cin, line))
cout &lt;&lt; line &lt;&lt; endl;
return 0;
}
</code></pre> 
<p>由于 line 不含换行符，若要逐行输出需要自行添加。照常，我们用 endl 来输出一个换行符并刷新输出缓冲区。<br> 由于 getline 函数返回时丢弃换行符，换行符将不会存储在 string 对象中。</p> 
<h3><a id="string__65"></a>string 对象的操作</h3> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>s.empty()</td><td>如果 s 为空串，则返回 true，否则返回 false。</td></tr><tr><td>s.size()</td><td>返回 s 中字符的个数</td></tr><tr><td>s[n]</td><td>返回 s 中位置为 n 的字符，位置从 0 开始计数</td></tr><tr><td>s1 + s2</td><td>把 s1 和s2 连接成一个新字符串，返回新生成的字符串</td></tr><tr><td>s1 = s2</td><td>把 s1 内容替换为 s2 的副本</td></tr><tr><td>v1 == v2</td><td>比较 v1 与 v2的内容，相等则返回 true，否则返回 false</td></tr><tr><td>!=, &lt;, &lt;=, &gt;, and &gt;=</td><td>保持这些操作符惯有的含义</td></tr></tbody></table> 
<h4><a id="string__size__empty__75"></a>string 的 size 和 empty 操作</h4> 
<p>string 对象的长度指的是 string 对象中字符的个数，可以通过 size 操作获取：</p> 
<pre><code>int main()
{
string st("The expense of spirit\n");
cout &lt;&lt; "The size of " &lt;&lt; st &lt;&lt; "is " &lt;&lt; st.size()
&lt;&lt; " characters, including the newline" &lt;&lt; endl;
return 0;
}
</code></pre> 
<p>编译并运行这个程序，得到的结果为：</p> 
<pre><code>The size of The expense of spirit
is 22 characters, including the newline
</code></pre> 
<p>了解 string 对象是否空是有用的。一种方法是将 size 与 0 进行比较：</p> 
<pre><code>if (st.size() == 0)
// ok: empty
</code></pre> 
<p>本例中，程序员并不需要知道 string 对象中有多少个字符，只想知道 size 是否为 0。用 string 的成员函数 empty() 可以更直接地回答这个问题：</p> 
<pre><code>if (st.empty())
// ok: empty
</code></pre> 
<p>empty() 成员函数将返回 bool，如果 string 对象为空则返回 true 否则返回 false。</p> 
<h4><a id="stringsize_type__106"></a>string::size_type 类型</h4> 
<p>从逻辑上来讲，size() 成员函数似乎应该返回整形数值，或无符号整数。但事实上，size 操作返回的是 string::size_type 类型的值。我们需要对这种类型做一些解释。<br> string 类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine-independent）。size_type 就是这些配套类型中的一种。它定义为与 unsigned 型（unsigned int 或 unsigned long）具有相同的含义，而且可以保证足够大能够存储任意 string 对象的长度。为了使用由 string 类型定义的 size_type 类型是由 string 类定义。<br> 任何存储 string 的 size 操作结果的变量必须为 string::size_type 类型。特别重要的是，还要把 size 的返回值赋给一个 int 变量。<br> 虽然我们不知道 string::size_type 的确切类型，但可以知道它是 unsigned 型。对于任意一种给定的数据类型，它的 unsigned 型所能表示的最大正数值比对应的 signed 型要大倍。这个事实表明 size_type 存储的 string 长度是 int 所能存储的两倍。<br> 使用 int 变量的另一个问题是，有些机器上 int 变量的表示范围太小，甚至无法存储实际并不长的 string 对象。如在有 16 位 int 型的机器上，int 类型变量最大只能表示 32767 个字符的 string 个字符的 string 对象。而能容纳一个文件内容的 string 对象轻易就会超过这个数字。因此，为了避免溢出，保存一个 stirng 对象 size 的最安全的方法就是使用标准库类型 string::size_type。</p> 
<h4><a id="string__112"></a>string 关系操作符</h4> 
<p>string 类定义了几种关系操作符用来比较两个 string 值的大小。这些操作符实际上是比较每个 string。<br> <strong>PS: string 对象比较操作是区分大小写的，即同一个字符的大小写形式被认为是两个不同的字符。在多数计算机上，大写的字母位于小写之前：任何一个大写之母都小于任意的小写字母。</strong><br> == 操作符比较两个 string 对象，如果它们相等，则返回 true。两个 string 对象相等是指它们的长度相同，且含有相同的字符。标准库还定义了 != 操作符来测试两个 string 对象是否不等。<br> 关系操作符 &lt;，&lt;=，&gt;，&gt;= 分别用于测试一个 string 对象是否小于、小于或等于、大于、大于或等于另一个 string 对象：</p> 
<pre><code>string big = "big", small = "small";
string s1 = big;    // s1 is a copy of big
if (big == small)   // false
	 // ...
if (big &lt;= s1)      // true
	// ...
</code></pre> 
<p>关系操作符比较两个 string 对象时采用了和（大小写敏感的）字典排序相同的策略：</p> 
<ul><li>如果两个 string 对象长度不同，且短的 string 对象与长的 string 对象的前面部分相匹配，则短的 string 对象小于长的 string 对象。</li><li>如果 string 对象的字符不同，则比较第一个不匹配的字符。<br> 举例来说，给定 string 对象:</li></ul> 
<pre><code>string substr = "Hello";
string phrase = "Hello World";
string slang  = "Hiya";
</code></pre> 
<p>则 substr 小于 phrase，而 slang 则大于 substr 或 phrase</p> 
<h4><a id="string__138"></a>string 对象的赋值</h4> 
<p>总体上说，标准库类型尽量设计得和基本数据类型一样方便易用。因此，大多数库类型支持赋值操作。对 string 对象来说，可以把一个 string 对象赋值给另一个 string 对象；<br> 大多数 string 库类型的赋值等操作的实现都会遇到一些效率上的问题，但值得注意的是，从概念上讲，赋值操作确实需要做一些工作。它必须先把 st1 占用的相关内存释放掉，然后再分配给 st2 足够存放 st2 副本的内存空间，最后把 st2 中的所有字符复制到新分配的内存空间。</p> 
<h4><a id="_string__141"></a>两个 string 对象相加</h4> 
<p>string 对象的加法被定义为连接（concatenation）。也就是说，两个（或多个）string 对象可以通过使用加操作符 + 或者复合赋值操作符 +=（1.4.1 节）连接起来。给定两个 string 对象：</p> 
<pre><code>string s1("hello, ");
string s2("world\n");
</code></pre> 
<p>下面把两个 string 对象连接起来产生第三个 string 对象：</p> 
<pre><code>string s3 = s1 + s2;   // s3 is hello, world\n
</code></pre> 
<p>如果要把 s2 直接追加到 s1 的末尾，可以使用 += 操作符：</p> 
<pre><code>s1 += s2;   // equivalent to s1 = s1 + s2
</code></pre> 
<h4><a id="_158"></a>和字符串字面值的连接</h4> 
<p>上面的字符串对象 s1 和 s2 直接包含了标点符号。也可以通过将 string 对象和字符串字面值混合连接得到同样的结果：</p> 
<pre><code>string s1("hello");
string s2("world");
string s3 = s1 + ", " + s2 + "\n";
</code></pre> 
<p>当进行 string 对象和字符串字面值混合连接操作时，+ 操作符的左右操作数必须至少有一个是 string 类型的：</p> 
<pre><code>string s1 = "hello";  
string s2 = "world";
string s3 = s1 + ", ";           	//正确
string s4 = "hello" + ", ";      	//错误
string s5 = s1 + ", " + "world"; 	// 正确
string s6 = "hello" + ", " + s2;		// 错误
</code></pre> 
<p>s3 和 s4 的初始化只用了一个单独的操作。在这些例子中，很容易判断 s3 的初始化是合法的：把一个 string 对象和一个字符串字面值连接起来。而 s4 的初始化试图将两个字符串字面值相加，因此是非法的。<br> s5 的初始化方法显得有点不可思议，但这种用法和标准输入输出的串联效果是一样的。本例中，string 标准库定义加操作返回一个 string 对象。这样，在对 s5 进行初始化时，子表达式 s1 + ", " 将返回一个新 string 对象，后者再和字面值 "world\n"连接。整个初始化过程可以改写为：</p> 
<pre><code>string tmp = s1 + ", "; 
s5 = tmp + "world";   
</code></pre> 
<p>而 s6 的初始化是非法的。依次来看每个子表达式，则第一个子表达式试图把两个字符串字面值连接起来。这是不允许的，因此这个语句是错误的。</p> 
<h4><a id="_string__184"></a>从 string 对象获取字符</h4> 
<p>string 类型通过下标操作符（[ ]）来访问 string 对象中的单个字符。下标操作符需要取一个 size_type 类型的值，来标明要访问字符的位置。这个下标中的值通常被称为“下标”或“索引”。<br> <strong>PS:</strong><br> <strong>string 对象的下标从 0 开始。如果 s 是一个 string 对象且 s 不空，则 s[0] 就是字符串的第一个字符， s[1] 就表示第二个字符（如果有的话），而 s[s.size() - 1] 则表示 s 的最后一个字符。</strong><br> <strong>引用下标时如果超出下标作用范围就会引起溢出错误。</strong><br> 可用下标操作符分别取出 string 对象的每个字符，分行输出：</p> 
<pre><code>string str("some string");
for (string::size_type ix = 0; ix != str.size(); ++ix)
	cout &lt;&lt; str[ix] &lt;&lt; endl;
</code></pre> 
<p>每次通过循环，就从 str 对象中读取下一个字符，输出该字符并换行。</p> 
<h5><a id="_197"></a>下标操作可用作左值</h5> 
<p>前面说过，变量是左值，且赋值操作的左操作的必须是左值。和变量一样，string 对象的下标操作返回值也是左值。因此，下标操作可以放于赋值操作符的左边或右边。通过下面循环把 str 对象的每一个字符置为 *：</p> 
<pre><code>for (string::size_type ix = 0; ix != str.size(); ++ix)
	str[ix] = '*';
</code></pre> 
<h5><a id="_204"></a>计算下标值</h5> 
<p>任何可产生整型值的表达式可用作下标操作符的索引。例如，假设 someval 和 someotherval 是两个整形对象，可以这样写：<br> 虽然任何整型数值都可作为索引，但索引的实际数据类型却是类型 unsigned 类型 string::size_type。<br> 前面讲过，应该用 string::size_type 类型的变量接受 size 函数的返回值。在定义用作索引的变量时，出于同样的道理，string 对象的索引变量最好也用 string::size_type 类型。<br> 在使用下标索引 string 对象时，必须保证索引值“在上下界范围内”。“在上下界范围内”就是指索引值是一个赋值为 size_type 类型的值，其取值范围在 0 到 string 对象长度减 1 之间。使用 string::size_type 类型或其他 unsigned 类型，就只需要检测它是否小于 string 对象的长度。<br> <strong>PS: 标准库不要求检查索引值，所用索引的下标越界是没有定义的，这样往往会导致严重的运行时错误。</strong></p> 
<h4><a id="string__210"></a>string 对象中字符的处理</h4> 
<p>我们经常要对 string 对象中的单个字符进行处理，例如，通常需要知道某个特殊字符是否为空白字符、字母或数字。下表列出了各种字符操作函数，适用于 string 对象的字符（或其他任何 char 值）。这些函数都在 cctype 头文件中定义。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>isalnum(c）</td><td>如果 c 是字母或数字，则为 True。</td></tr><tr><td>isalpha(c）</td><td>如果 c 是字母，则为 true。</td></tr><tr><td>iscntrl(c）</td><td>如果 c 是控制字符，则为 true</td></tr><tr><td>isdigit(c）</td><td>如果 c 是数字，则为 true。</td></tr><tr><td>isgraph(c）</td><td>如果 c 不是空格，但可打印，则为 true。</td></tr><tr><td>islower(c）</td><td>如果 c 是小写字母，则为 true。</td></tr><tr><td>isprint(c）</td><td>如果 c 是可打印的字符，则为 true。</td></tr><tr><td>ispunct(c）</td><td>如果 c 是标点符号，则 true。</td></tr><tr><td>isspace(c）</td><td>如果 c 是空白字符，则为 true。</td></tr><tr><td>isupper(c）</td><td>如果 c 是大写字母，则 true。</td></tr><tr><td>isxdigit(c）</td><td>如果是 c 十六进制数，则为 true。</td></tr><tr><td>tolower（c)</td><td>如果 c 大写字母，返回其小写字母形式，否则直接返回 c。</td></tr><tr><td>toupper(c）</td><td>如果 c 是小写字母，</td></tr></tbody></table> 
<p>表中的大部分函数是测试一个给定的字符是否符合条件，并返回一个 int 作为真值。如果测试失败，则该函数返回 0 ，否则返回一个（无意义的）非 0 ，表示被测字符符合条件。<br> 表中的这些函数，可打印的字符是指那些可以表示的字符，空白字符则是空格、制表符、垂直制表符、回车符、换行符和进纸符中的任意一种；标点符号则是除了数字、字母或（可打印的）空白字符（如空格）以外的其他可打印字符。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a8e7c5fdff10ba98a82dbed45d73f41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android的碎片fragment和activity之前的关系 以及MVP模式详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3da189cfd21c9b4404422786061d539/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">配置jupyter notebook全步骤，更改默认路径，jupyter不是</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>