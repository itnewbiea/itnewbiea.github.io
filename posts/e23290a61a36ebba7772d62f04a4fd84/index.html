<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法逆袭之路（1） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法逆袭之路（1）" />
<meta property="og:description" content="11.29 开始跟进算法题进度!
每天刷4题左右 ,一周之内一定要是统一类型
而且一定稍作总结, 了解他们的内在思路究竟是怎样的!!
12.24 一定要每天早中晚都要复习一下
早中午每段一两道, 而且一定要是同一个类型, 不然刷起来都没有意义
12.26/27： 斐波那契数
爬楼梯
最小花费爬楼梯
不同路径1/2
12.28： 整数拆分
重点思路：一个正整数可以分为两个，或者多个，多个可以用dp[i-j]代替，一定不能直接分为乘以dp的情况，因为这就默认了必须拆分为三个以上
不同的二叉搜索树
重点思路： 把左右子树所有情况乘起来，递归子树的问题。注意左右节点个数的边界
12.29 01背包理论
12.30 分割等和子集
很难看出来是01背包。满足的条件有
每个元素只有取和不取两个状态
结果要满足，某一部分和，刚好等于什么什么value，而背包问题是在限制的重量内计算他们价值最大值， 这里只需把求最大值改成求刚好 == sum即可
此题的weight和value都是nums【i】，因为是一个一个数字要求刚好和为sum
dp【i】代表在i内之和最大为多少 本题要求刚好等于sum所以结束条件是dp[ sum ] == sum ，即总量为sum之内刚好最大为sum！
581. 最短无序连续子数组
12.31 209. 长度最小的子数组
思路：滑动窗口，先不断右移直到sum&gt;=target ， 然后左指针左移直到小于target，记录暂时的最小长度，然后继续右移右移直到sum&gt;=target ， 左指针左移直到小于target，不断迭代最小长度
和为 K 的子数组
使用前缀和，核心是
map.containskey(sum-k); map.put(sum,map.getOrDefault(sum,0)&#43;1); 滑动窗口 按照这题为模板
这种题的特征是 &#34;子串&#34; &#34;子数组&#34; 这种需要连续元素的
有一个窗口在扫描，使用两个变量left限制左范围：right用于for遍历计数
tmp,max用于记录最终数据
从0处开始滑动区间 ，right每加一次，就判断right这个元素和窗口内的元素是否满足某种条件
如果不满足了就进入处理块, 不断把left向右推进直到他满足条件, 在外层循环记录tmp和最大的max即可.(此题判断的条件是是否有重复元素，有就把left推进到重复的位置)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e23290a61a36ebba7772d62f04a4fd84/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T09:23:21+08:00" />
<meta property="article:modified_time" content="2024-01-04T09:23:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法逆袭之路（1）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>11.29</h3> 
<p>开始跟进算法题进度!</p> 
<p>每天刷4题左右 ,一周之内一定要是统一类型</p> 
<p>而且一定稍作总结, 了解他们的<strong>内在思路</strong>究竟是怎样的!!</p> 
<p></p> 
<h3>12.24</h3> 
<p>一定要每天早中晚都要复习一下</p> 
<p>早中午每段一两道, 而且一定要是同一个类型, 不然刷起来都没有意义</p> 
<p></p> 
<h3>12.26/27：</h3> 
<p>斐波那契数</p> 
<p>爬楼梯</p> 
<p>最小花费爬楼梯</p> 
<p>不同路径1/2</p> 
<p></p> 
<h3>12.28：</h3> 
<p>整数拆分</p> 
<p><img alt="" height="749" src="https://images2.imgbox.com/9f/2f/Wcrc2Ou6_o.png" width="1200"></p> 
<p>重点思路：一个正整数可以分为两个，或者多个，多个可以用dp[i-j]代替，一定<strong>不能直接分为乘以dp的情况，因为这就默认了必须拆分为三个以上</strong></p> 
<p>不同的二叉搜索树</p> 
<p>重点思路： 把左右子树所有情况乘起来，递归子树的问题。注意左右节点个数的边界</p> 
<p></p> 
<h3>12.29</h3> 
<p>01背包理论</p> 
<p></p> 
<hr> 
<h3>12.30</h3> 
<p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/" rel="nofollow" title="分割等和子集">分割等和子集</a></p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/c3/58/QnDrusw5_o.png" width="1200"></p> 
<p>很难看出来是01背包。满足的条件有</p> 
<ol><li> <p>每个元素只有取和不取两个状态</p> </li><li> <p>结果要满足，某一部分和，刚好等于什么什么value，而背包问题是在限制的重量内计算他们价值最大值， 这里只需把求最大值改成求刚好 == sum即可</p> </li><li> <p>此题的weight和value都是nums【i】，因为是一个一个数字要求刚好和为sum</p> </li><li> <p>dp【i】代表在i内之和最大为多少 本题要求刚好等于sum所以结束条件是dp[ sum ] == sum ，即总量为sum之内刚好最大为sum！</p> </li></ol> 
<p></p> 
<p><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" rel="nofollow" title="581. 最短无序连续子数组">581. 最短无序连续子数组</a></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e4/5f/TuA8UNKe_o.png" width="1200"></p> 
<hr> 
<p></p> 
<h3>12.31</h3> 
<ol><li> <p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" rel="nofollow" title="209. 长度最小的子数组">209. 长度最小的子数组</a></p> </li></ol> 
<p><img alt="" height="1130" src="https://images2.imgbox.com/d7/42/1g08xZv6_o.png" width="900"></p> 
<p>思路：滑动窗口，先不断右移直到sum&gt;=target ， 然后左指针左移直到小于target，记录暂时的最小长度，然后继续右移右移直到sum&gt;=target ， 左指针左移直到小于target，不断迭代最小长度</p> 
<p></p> 
<ol><li> <p>和为 K 的子数组</p> </li></ol> 
<p><img alt="" height="378" src="https://images2.imgbox.com/74/52/Ejr20jCt_o.png" width="875"></p> 
<p>使用前缀和，核心是</p> 
<pre>map.containskey(sum-k);
map.put(sum,map.getOrDefault(sum,0)+1);</pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2>滑动窗口</h2> 
<p>按照这题为模板</p> 
<p>这种题的特征是 <strong>"子串" "子数组"</strong> 这种需要<strong>连续</strong>元素的</p> 
<p>有一个窗口在扫描，使用两个变量left限制左范围：right用于for遍历计数</p> 
<p>tmp,max用于记录最终数据</p> 
<p>从0处开始滑动区间 ，right每加一次，就判断right这个元素和窗口内的元素是否满足某种条件</p> 
<p>如果不满足了就进入处理块, 不断把left向右推进直到他满足条件, 在外层循环记录tmp和最大的max即可.(此题判断的条件是是否有重复元素，有就把left推进到重复的位置)</p> 
<p></p> 
<h3>无重复字符最长子串</h3> 
<p><img alt="" height="891" src="https://images2.imgbox.com/4c/5f/S7DHe7UW_o.png" width="1200"></p> 
<p><img alt="" height="665" src="https://images2.imgbox.com/cd/5d/4aWtomC6_o.png" width="790"></p> 
<p><strong>字节最经典的一道题</strong></p> 
<p>注意要用HashMap提高查找效率</p> 
<ol><li> <p>containsKey先于put处理防止自己contains自己。调整i位置，通过比较两个元素下标谁大，来确定谁是后面的0</p> </li><li> <p>左边界调整位置的时候调整到第一个有效位（即重复位+1），而不是重复位，因为如果这个字符串没有重复的，此时应该使用j-i+1计算结果， 然而如果是调整到重复位 结果就变成了j-i，没有统一。所以<strong>必须挪到重复位的右边(第一个有效位)！</strong></p> </li><li> <p>i = Math.max(i,map.get(s.charAt(j))+1); 这一句是比较 当前边界和重复字符谁更右 ，</p> <p>取更右边的作为边界</p> <p></p> <p>重点：要用HashMap来搞。注意<strong>put是会覆盖相同的元素的！！！！</strong>由于遍历的顺序是下标由小到大，因此得到的那个重复元素的下标<strong>一定是目前最大的</strong>，直接和左边界比较即可</p> </li></ol> 
<p></p> 
<p></p> 
<h2>哈希表(12.9-12.16)</h2> 
<p><strong>什么时候使用哈希法</strong>:</p> 
<p>1.当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p> 
<p>经典题: 比较两个集合的元素<strong>重叠</strong>的地方, 或者这个数组能不能由那个数组里的元素构成</p> 
<p>2.当我们需要在一次遍历中记录某种元素<strong>出现的次数</strong>, 或者记录某个和他相关的特征的时候</p> 
<p>抽象来说就是, 需要建立<strong>一个数据和另一个数据之间的映射关系</strong>的时候</p> 
<p>下面是这两种数据结构的一些常用方法：</p> 
<p><strong>HashMap</strong></p> 
<ol><li> <p><code>put(key, value)</code>: 如果key已经存在，那么值就更新</p> </li><li> <p><code>get(key)</code>: 根据key获取value</p> </li><li> <p><code>remove(key)</code>: 删除HashMap中指定key的元素</p> </li><li> <p><code>containsKey(key)</code>: 检查HashMap中是否包含给定的key</p> </li><li> <p><code>containsValue(value)</code>: 检查HashMap中是否包含给定的value</p> </li><li> <p><code>keySet()</code>: 返回所有key的Set</p> </li><li> <p><code>values()</code>: 返回所有value的Collection</p> </li><li> <p><code>isEmpty()</code>: 检查是否为空</p> </li><li> <p><code>clear()</code>: 清除所有元素</p> </li><li> <p>map.put(i , getOrDefault(map.get(i),0)+1)</p> </li></ol> 
<p><strong>HashSet</strong></p> 
<ol><li> <p><code>add(element)</code>: 添加一个元素</p> </li><li> <p><code>remove(element)</code>: 删除一个元素</p> </li><li> <p><code>contains(element)</code>:是否包含给定的元素</p> </li><li> <p><code>isEmpty()</code>: 检查是否为空</p> </li><li> <p><code>clear()</code>: 清除所有元素</p> </li><li> <p><code>size()</code>: 返回<strong>元素</strong>的数量</p> </li><li> <p><code>iterator()</code>: 返回一个迭代器，用于遍历HashSet中的所有元素。</p> </li></ol> 
<p></p> 
<h2>回溯(12.19-12.24)</h2> 
<h4>为什么要用回溯?</h4> 
<ul><li> <p>for循环只能有单层遍历,但是回溯是可以多层遍历</p> </li><li> <p>回溯的本质就是多层遍历, <strong>用for循环控制这一层的广度, 用递归控制深度</strong>, 用退出条件控制结束时机</p> </li><li> <p>一定要画图辅助理解,可以明确写递归方法的思路, <strong>这很重要</strong></p> </li><li> <p>什么题用回溯?问你返回所有可能得什么什么组合,集合, 需要枚举/遍历所有情况 , 特别是<strong>组合/子集</strong>问题,要从题目抽象中出来</p> </li></ul> 
<h4>基本步骤</h4> 
<ol><li> <p>定义结果res集合(ArrayList) 临时存储tmp集合(LinkedList) 当前总和int sum</p> <pre>    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();
    int sum=0;</pre> <p></p> </li><li> <p>定义dfs函数, 包含传入的数组nums, 每次遍历的开头begin, 目标target</p> </li><li> <p>定义退出条件: 等于target时 把tmp加入res然后返回 超出target直接返回 大小超出也返回</p> </li><li> <p>定义循环体:注意for(<strong>i=begin</strong>;i&lt;length;i++)</p> </li><li> <pre> tmp.add(candidates[i]);
    sum += candidates[i];
    dfs(candidates, i ,target);
    sum -= candidates[i];
    tmp.removeLast();</pre> <p></p> </li></ol> 
<h4><strong>三大要点总结</strong></h4> 
<ul><li> <p>数组中(有无)<strong>重复元素</strong></p> </li><li> <p>结果中(能否)含有<strong>重复元素</strong></p> </li><li> <p>结果(能否)出现<strong>重复集合</strong>(顺序不同是否算同一个集合)</p> </li></ul> 
<p>主要是修改i = begin参数 和 dfs(nums, i ,target)中是 i 还是 i+1</p> 
<p>子集能重复, 只用修改为 i=0 不可重复则是 i=begin</p> 
<p>重点情况:</p> 
<ol><li> <p>数组中无重复元素 结果中不能含有重复元素 子集不能出现重复:</p> <p>i=begin dfs(nums, i+1 ,target)</p> </li><li> <p><strong>数组中有重复元素 结果中能含有重复元素 子集不能出现重复</strong>:</p> <p>加条件:</p> <p>if(i &gt; begin &amp;&amp; nums[i] == nums[i-1]) continue;</p> <p>i=begin dfs(nums, i+1 ,target)</p> </li><li> <p><strong>数组中有重复元素 结果中不含有重复元素 子集不能出现重复:</strong></p> <p>加条件:</p> <p>if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;</p> <p>i=begin dfs(nums, i+1 ,target)</p> <p></p> <p></p> <p>###</p> </li></ol> 
<h4>回文子串问题</h4> 
<p>12.28</p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/20/b5/6X9QZ4EA_o.png" width="855"></p> 
<pre>class Solution {
    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
    List&lt;String&gt; tmp = new LinkedList&lt;&gt;();
    public List&lt;List&lt;String&gt;&gt; partition(String s) 
    {
        int index = 0;
        dfs(0,s);
        return res;
    }
​
    public void dfs(int index , String s)
    {
        if(index == s.length())
        {
            res.add(new ArrayList(tmp));
        }
​
        for(int i = index;i &lt; s.length();i++)
        {
               if(fun(index,i,s) == true) 
               {
                   String now = s.substring(index,i+1);
                   tmp.add(now);
                   dfs(i+1,s);
                   tmp.removeLast();
               }
        }
    }
​
    public boolean fun(int i,int j,String s)
    {
        while(true)
        {
            if(i &gt;= j)return true;
            if(s.charAt(i) != s.charAt(j))
            {
                return false;
            }
            i++;
            j--;
        }
       
    }
​
​
​
}</pre> 
<p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/" rel="nofollow" title="力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p> 
<p>可以算困难一级的了</p> 
<p>难点:</p> 
<ul><li> <p>把分割方案化为回溯问题, 我们想枚举每一种字符串的分割方式, 再一个一个去验证</p> </li><li> <p>可以看做是字符间空隙的组合问题(在一个空隙集合中选择不同的空隙组合) 采用回溯枚举</p> </li><li> <p>因为for循环只能有单层遍历,但是回溯是可以多层遍历(回溯的本质就是遍历, 用for循环控制这一层的广度, 用递归控制深度, 用退出条件控制结束时机 )</p> </li><li> <p>一定要画图辅助理解, 这很重要,一开始都没意识到</p> </li><li> <p>判断回文直接双指针</p> </li><li> <pre>//我们使用index来代表当前遍历的空隙, 当枚举到**最后一个字符后**的空隙时就才遍历
if(index == s.length())  
        {
            res.add(new ArrayList(tmp));
        }
​
        for(int i = index;i &lt; s.length();i++)
        {
 //index和i表示我们当前处理的哪两个空隙之间的字符串,只有当前满足是回文我们才继续去dfs,否则直接进入下一个循环,这样保证了只有回文, 并且因为只有遍历到最后一个字符后才会结束,所以不用担心会脏结果
               if(fun(index,i,s) == true) 
               {
                  String now = s.substring(index,i+1);  //注意边界是[index,i]
                   tmp.add(now);
                   dfs(i+1,s);//从下一个字符开始继续判断
                   tmp.removeLast();
               }
        }</pre> <p></p> </li></ul> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2>动态规划(12.25-1.4)</h2> 
<p></p> 
<p>如果某一问题有很多<strong>重叠子问题</strong>，使用动态规划是最有效的。</p> 
<p>就是你发现这一步的答案要根据上一步的答案得，而且上一步的答案也是同样的方法得到的</p> 
<p>所以动态规划中每一个状态一定是由<strong>上一个状态推导</strong>出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的</p> 
<p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p> 
<hr> 
<h3><strong>动规五步曲</strong>（一定要明确的每一步结果写出来）</h3> 
<ol><li> <p><strong>确定dp数组（dp table）以及下标的含义</strong></p> <p>这很重要，注释出来</p> </li><li> <p><strong>确定递推公式</strong></p> <p>写完dp数组含义以后 立马着手递推公式 用注释先写上</p> </li><li> <p><strong>dp数组如何初始化</strong></p> <p>一定要注意dp[0] dp[1] 这种边界值的初始化，很有可能要取特值</p> </li><li> <p><strong>确定遍历顺序</strong></p> <p>要确保后面的可以由前面的推出来，特别是多维dp</p> </li><li> <p><strong>举例推导dp数组</strong></p> </li></ol> 
<hr> 
<p>为什么要先确定递推公式，然后在考虑初始化呢？因为一些情况是递推公式决定了dp数组要如何初始化！</p> 
<p><strong>Debug三问</strong></p> 
<ol><li> <p><strong>这道题目我举例推导状态转移公式了么？</strong></p> </li><li> <p><strong>我打印dp数组的日志了么？</strong></p> </li><li> <p><strong>打印出来了dp数组和我想的一样么？</strong></p> </li></ol> 
<p></p> 
<h3>背包问题</h3> 
<h4>01背包</h4> 
<p>（1）</p> 
<p>对于背包问题，有一种写法即dp<a href="#" rel="nofollow">i</a> 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p> 
<p></p> 
<p class="img-center"><img alt="动态规划-背包问题1" height="494" src="https://images2.imgbox.com/ac/98/66RgVhE7_o.png" width="912"></p> 
<p></p> 
<p>确定递推公式</p> 
<p>不放物品i：和上一个相同。由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp<a href="#" rel="nofollow">i</a>就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</p> 
<p>放物品i：等于上一个加这个的value。由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</p> 
<p>取i那就是后者，不取i就是前者</p> 
<pre>dp[i][j] = max{ dp[i-1][j] , dp[i-1][j-weight[i]] + value[i] }</pre> 
<p><strong>（2）滚动数组法</strong></p> 
<p>重点一定要记住， 就是<strong>数据的覆盖</strong></p> 
<p>在此时，数组是一遍一遍覆盖的。覆盖前就相当于原来的dp[i-1 ] [j ],所以此时，不取物品i 的情况就可以化为dp[j ] 直接就是上一个的。同理，要取物品i 就直接化为dp[j-weight ]+value[j ]</p> 
<pre>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</pre> 
<p>dp[j]表示<strong>：容量为j的背包，所背的物品价值可以最大为dp[j]</strong></p> 
<p>初始化dp就应该全是0，在题目给的全是正整数的情况下可以保证<strong>后续被覆盖掉</strong>。</p> 
<p>循环还是双重循环，要有i 控制前n个物品进不进去， 但是dp会减少一维度</p> 
<p><strong>同时我们可以窥见遍历的次序问题。因为我们要保证j 之前的数据还没有被覆盖</strong></p> 
<p>因为有比较dp[j - weight[i]] + value[i]的部分</p> 
<p>所以我们要<strong>倒序遍历</strong></p> 
<p>ps：能不能交换遍历顺序？不能，不然就变成 dp[j]表示：取前 j 个的背包，所背的物品价值可以最大为dp[j]</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91fbbea34b5f617970fb339795bd4dc3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">内联函数的作用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24f293952624da055563cb314bfa4b66/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">为什么会去华为 OD？网传的 OD 转华为正编，真的假的？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>