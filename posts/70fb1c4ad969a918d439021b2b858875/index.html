<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Leetcode]5897. 将数组分成两个数组并最小化数组和的差 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[Leetcode]5897. 将数组分成两个数组并最小化数组和的差" />
<meta property="og:description" content="【题目描述如下】
给你一个长度为 2 * n 的整数数组。你需要将 nums 分成 两个 长度为 n 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。nums 中每个元素都需要放入两个数组之一。
请你返回 最小 的数组和之差。
示例 1：
输入：nums = [3,9,7,3]
输出：2
解释：最优分组方案是分成 [3,9] 和 [7,3] 。
数组和之差的绝对值为 abs((3 &#43; 9) - (7 &#43; 3)) = 2 。
示例 2：
输入：nums = [-36,36]
输出：72
解释：最优分组方案是分成 [-36] 和 [36] 。
数组和之差的绝对值为 abs((-36) - (36)) = 72 。
示例 3：
输入：nums = [2,-1,0,4,-2,-9]
输出：0
解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/70fb1c4ad969a918d439021b2b858875/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-10T21:04:48+08:00" />
<meta property="article:modified_time" content="2021-10-10T21:04:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Leetcode]5897. 将数组分成两个数组并最小化数组和的差</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>【题目描述如下】</p> 
<p>给你一个长度为 2 * n 的整数数组。你需要将 nums 分成 两个 长度为 n 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。nums 中每个元素都需要放入两个数组之一。</p> 
<p>请你返回 最小 的数组和之差。</p> 
<p>示例 1：</p> 
<p>输入：nums = [3,9,7,3]<br> 输出：2<br> 解释：最优分组方案是分成 [3,9] 和 [7,3] 。<br> 数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。<br> 示例 2：</p> 
<p>输入：nums = [-36,36]<br> 输出：72<br> 解释：最优分组方案是分成 [-36] 和 [36] 。<br> 数组和之差的绝对值为 abs((-36) - (36)) = 72 。<br> 示例 3：</p> 
<p>输入：nums = [2,-1,0,4,-2,-9]<br> 输出：0<br> 解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。<br> 数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。<br>  </p> 
<p>提示：</p> 
<p>1 &lt;= n &lt;= 15<br> nums.length == 2 * n<br> -107 &lt;= nums[i] &lt;= 107</p> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference<br> 【题目分析】</p> 
<p>刚开始看到这个题目，感觉很熟悉，状态压缩嘛，于是很开心的做了起来。代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    /*
        每个数都有放在数组1或数组2两种选择，所以一共有2^2n-1中可能，由于是等分为两个数组，
        中间要去掉不能等分的；采用状态压缩法，用二进制表示每一种分组；
    */
    int BitCount(unsigned int n)
    {
        unsigned int c = 0 ;
        while (n &gt; 0) {
            c += n &amp; 1;
            n &gt;&gt;= 1;
        }
        return c ;
    }
    int CalcSum(vector&lt;int&gt;&amp; nums, unsigned int n)
    {
        int res = 0;
        int i = 0;
        while (n &gt; 0) {
            if (n &amp; 1) {
                res += nums[i];
            }
            i++;
            n &gt;&gt;= 1;
        }
        return res;
    }
    int minimumDifference(vector&lt;int&gt;&amp; nums) {
        int res = INT_MAX;
        int n = nums.size();
        vector&lt;bool&gt; rec((1 &lt;&lt; n), false);
        for (int i = (1 &lt;&lt; (n / 2)) - 1; i &lt; 1 &lt;&lt; n; i++) {
            if (BitCount(i) == n / 2) {
                // 求补集
                int left = i ^ ((1 &lt;&lt; n) - 1);
                res = min(res, abs(CalcSum(nums, i) - CalcSum(nums, left)));
            } 
        }
        return res;
    }
};
</code></pre> 
<p>每个数都有放在数组1或数组2两种选择，所以一共有2^2n-1中可能，由于是等分为两个数组，中间要去掉不能等分的；采用状态压缩法，用二进制表示每一种分组； 由于n最大为15，上述代码的时间复杂度O(2^2n)，代码会超时；</p> 
<p>后来看了题解，发现使用分段的<strong>状态压缩和二分查找</strong>很巧妙地降低时间复杂度为O(n*2^n)；</p> 
<p>代码分三步：</p> 
<p>1）首先在前半段（n）进行状态枚举，每个数有两种情况：放到数组1，即加上其值；放到数组2，即减去其值。这样可以求出后半段的所有组合，存入数组f；</p> 
<p>同理针对后半段采用同样的策略，将所有的组合放入数组g；</p> 
<p>2）分别对f、g中的数组进行升序排列，以便后续二分查找；</p> 
<p>3）所求最小差值为min(abs(f[i] + g[n-i]))，遍历每个f[i]，同时用二分法查找绝对值和最小的g[n-i]；</p> 
<p>i + n - i = n表示等分的两个数组，每个有n个数；</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    /*
        每个数都有放在数组1或数组2两种选择，所以一共有2^2n-1中可能，由于是等分为两个数组，
        中间要去掉不能等分的；采用状态压缩法，用二进制表示每一种分组；
        由于n最大为15,O(2^2n)会导致代码超时；
        所以分成两段进行求解,将时间复杂度降至O(n*2^n);
    */
    int BitCount(unsigned int n)
    {
        unsigned int c = 0 ;
        while (n &gt; 0) {
            c += n &amp; 1;
            n &gt;&gt;= 1;
        }
        return c ;
    }

    int minimumDifference(vector&lt;int&gt;&amp; nums) {
        int res = INT_MAX;
        int n = nums.size() / 2;
        vector&lt;vector&lt;int&gt;&gt; f(n + 1);
        vector&lt;vector&lt;int&gt;&gt; g(n + 1);
        for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
            int cnt = BitCount(i);
            int j = 0;
            int sum = 0;
            int mask = i;
            while (j &lt; n) {
                if (mask &amp; 0x1) {
                    sum += nums[j];
                } else {
                    sum -= nums[j];
                }
                mask &gt;&gt;= 1;
                j++;
            }
            f[cnt].emplace_back(sum);
        }
        for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
            int cnt = BitCount(i);
            int j = 0;
            int sum = 0;
            int mask = i;
            while (j &lt; n) {
                if (mask &amp; 0x1) {
                    sum += nums[n + j];
                } else {
                    sum -= nums[n + j];
                }
                mask &gt;&gt;= 1;
                j++;
            }
            g[cnt].emplace_back(sum);
        }
        // 升序排列，为了方便后面二分查找
        for (int i = 0; i &lt; n; i++) {
            sort(begin(f[i]), end(f[i]));
            sort(begin(g[i]), end(g[i]));
        }
        // 最小差值即为min(abs(f[i] + g[n-i]))
        for (int i = 0; i &lt; n; i++) {
            for (auto&amp; ft : f[i]) {
                // 查找大于等于-ft的，以便绝对值和最小
                auto it = lower_bound(begin(g[n - i]), end(g[n - i]), -ft);
                // 如果找到了
                if (it != end(g[n - i])) {
                    res = min(res, abs(ft + *it));
                }
                // 如果it == end没找到，则取最接近的
                if (it != begin(g[n - i])) {
                    res = min(res, abs(ft + *prev(it)));
                }
            }
        }
        return res;
    }
};</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9989e6a6edfedb9a58c7de18f4de984a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在vs2019连接linux环境下，mysql头文件报错的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca597feba5e7628534d5e1df02e330f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">gRPC-Java（二）：一个Demo熟悉gRPC的四种模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>