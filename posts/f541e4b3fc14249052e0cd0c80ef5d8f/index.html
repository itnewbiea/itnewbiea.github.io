<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线性时间选择 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线性时间选择" />
<meta property="og:description" content="问题：给定线性序集中n个元素和一个整数k，1&lt;=k&lt;=n，要求找出这n个元素中第k小的元素。
我们采用快速排序的思想来解决这个问题。首先我们要找到基准的位置，如果基准的位置小于k，则表示第k小的元素在基准的后面，否则在基准的前面。
如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的2个子数组的长度都至少为原数组长度的 ε 倍（0&lt;ε&lt;1是某个常数），那么就可以在最坏情况下用O(n)时间完成选择任务。
算法过程如下：
将这个函数定义为select(nums,p,r,k)，即为找到nums[p:r]数组中第k（1&lt;=k&lt;=n）小的元素。假如数组的长度小于75，那么直接用快排来解决。将n个输入元素划分成ceil(n/5)个组，每组5个元素，只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共ceil(n/5)个。递归调用select来找出这ceil(n/5)个元素的中位数。如果ceil(n/5)是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。 //一次快排 int Partition(int nums[],int p,int r,int x) { if(p&gt;r) return -1; //找出基准x的位置并与第一位交换 for(int i=p;i&lt;=r;i&#43;&#43;) { if(nums[i]==x) { swap(x,nums[p]); break; } } int left=p,right=r; while(left&lt;right) { while(left&lt;right &amp;&amp; nums[right]&gt;=x) right--; nums[left]=nums[right]; while(left&lt;right &amp;&amp; nums[left]&lt;x) left&#43;&#43;; nums[right]=nums[left]; } nums[left]=x; return left; } //快速排序 void QuickSort(int nums[],int low,int high) { if(low&gt;high) return; int key=nums[low]; int left=low,right=high; while(left&lt;right) { while(left&lt;right &amp;&amp; nums[right]&gt;=key) right--; nums[left]=nums[right]; while(left&lt;right &amp;&amp; nums[left]&lt;key) left&#43;&#43;; nums[right]=nums[left]; } nums[left]=key; QuickSort(nums,low,left-1); QuickSort(nums,left&#43;1,high); } int Select(int nums[],int p,int r,int k) { if(r-p&lt;75) { QuickSort(nums,p,r); return nums[p&#43;k-1]; } //每5个为一组，找到各组的中位数，并存储在前(r-p-4)/5个位置里	for(int i=0;i&lt;=(r-p-4)/5;i&#43;&#43;) { QuickSort(nums,p&#43;5*i,p&#43;5*i&#43;4); swap(nums[p&#43;i],nums[p&#43;5*i&#43;2]); } //找所有中位数的中位数 int x=Select(nums,p,p&#43;(r-p-4)/5,(r-p-4)/10); //以x为基准做一次快排 int i=Partition(nums,p,r,x); int j=i-p&#43;1; //判断k属于那个部分 if(k&lt;=j) return Select(nums,p,i,k); else return Select(nums,i&#43;1,r,k-j); } 为什么是线性时间呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f541e4b3fc14249052e0cd0c80ef5d8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-28T11:49:55+08:00" />
<meta property="article:modified_time" content="2018-09-28T11:49:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线性时间选择</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>问题：给定线性序集中n个元素和一个整数k，1&lt;=k&lt;=n，要求找出这n个元素中第k小的元素。</p> 
<p>我们采用快速排序的思想来解决这个问题。首先我们要找到基准的位置，如果基准的位置小于k，则表示第k小的元素在基准的后面，否则在基准的前面。</p> 
<p>如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的2个子数组的长度都至少为原数组长度的 ε 倍（0&lt;ε&lt;1是某个常数），那么就可以在最坏情况下用O(n)时间完成选择任务。</p> 
<p>算法过程如下：</p> 
<ul><li>将这个函数定义为select(nums,p,r,k)，即为找到nums[p:r]数组中第k（1&lt;=k&lt;=n）小的元素。</li><li>假如数组的长度小于75，那么直接用快排来解决。</li><li>将n个输入元素划分成ceil(n/5)个组，每组5个元素，只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共ceil(n/5)个。</li><li>递归调用select来找出这ceil(n/5)个元素的中位数。如果ceil(n/5)是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。</li></ul> 
<p><img src="https://images2.imgbox.com/23/d3/954gJYVD_o.jpg" alt="在这里插入图片描述"></p> 
<pre><code>//一次快排
int Partition(int nums[],int p,int r,int x)
{
	if(p&gt;r) return -1;
	//找出基准x的位置并与第一位交换 
	for(int i=p;i&lt;=r;i++)
	{
		if(nums[i]==x)
		{
			swap(x,nums[p]);
			break;
		}
	}
	int left=p,right=r;
	while(left&lt;right)
	{
		while(left&lt;right &amp;&amp; nums[right]&gt;=x) right--;
		nums[left]=nums[right];
		while(left&lt;right &amp;&amp; nums[left]&lt;x) left++;
		nums[right]=nums[left];
	}
	nums[left]=x;
	return left;
}

//快速排序
void QuickSort(int nums[],int low,int high)
{
	if(low&gt;high) return;
	int key=nums[low];
	int left=low,right=high;
	while(left&lt;right)
	{
		while(left&lt;right &amp;&amp; nums[right]&gt;=key) right--;
		nums[left]=nums[right];
		while(left&lt;right &amp;&amp; nums[left]&lt;key) left++;
		nums[right]=nums[left];
	}
	nums[left]=key;
	QuickSort(nums,low,left-1);
	QuickSort(nums,left+1,high);
}

int Select(int nums[],int p,int r,int k)
{
	if(r-p&lt;75)
	{
		QuickSort(nums,p,r);
		return nums[p+k-1]; 
	}
	//每5个为一组，找到各组的中位数，并存储在前(r-p-4)/5个位置里	
	for(int i=0;i&lt;=(r-p-4)/5;i++)
	{
		QuickSort(nums,p+5*i,p+5*i+4);
		swap(nums[p+i],nums[p+5*i+2]);
	}
	//找所有中位数的中位数 
	int x=Select(nums,p,p+(r-p-4)/5,(r-p-4)/10);
	//以x为基准做一次快排 
	int i=Partition(nums,p,r,x);
	int j=i-p+1;
	//判断k属于那个部分 
	if(k&lt;=j)
		return Select(nums,p,i,k);
	else
	    return Select(nums,i+1,r,k-j);
}  
</code></pre> 
<p>为什么是线性时间呢？<br> 设所有元素互不相同。在这种情况下，找出的基准x至少比3(n-5)/10个元素大，因为在每一组中有2个元素小于本组的中位数，有floor(n/5-1)/2*2=floor(n/5-1)个元素小于基准，而ceil(n/5)个中位数中又有floor((n-5)/10)（=(n/5-1)/2）个小于基准x。同理，基准x也至少比3(n-5)/10（=(n/5)-1+(n-5)/10）个元素小。而当n≥75时，3(n-5)/10≥n/4所以按此基准划分所得的2个子数组的长度都至少缩短1/4。故原问题的时间复杂度可表示为：</p> 
<pre><code>T(n)=c                  ,n&lt;75
T(n)=T(n/5)+T(3n/4)+cn  ,n&gt;=75
</code></pre> 
<p>上述算法将每一组的大小定为5，并选取75作为是否作递归调用的分界点。这2点保证了T(n)的递归式中2个自变量之和n/5+3n/4=19n/20=εn，0&lt;ε&lt;1。这是使T(n)=O(n)的关键之处。当然，除了5和75之外，还有其他选择。读者也可以考虑7的情况。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20c7f007447e727e3000019c62b5cafe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python实现&#34;2的幂&#34;的两种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa824bb27688423281334c348a8630d6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">.NET MVC4 用HttpClient后台post 请求webapi</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>