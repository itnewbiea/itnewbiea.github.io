<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>byte数据的常用操作函数 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="byte数据的常用操作函数" />
<meta property="og:description" content="/// &lt;summary&gt; /// 本类提供了对byte数据的常用操作函数 /// &lt;/summary&gt; public class ByteUtil { private static char[] HEX_CHARS = {&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;}; private static byte[] BITS = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80}; /// &lt;summary&gt; /// 将字节数组转换为HEX形式的字符串, 使用指定的间隔符 /// &lt;/summary&gt; public static string ByteToHex(byte[] buf, string separator) { System.Text.StringBuilder sb = new System.Text.StringBuilder(); for(int i = 0;i &lt; buf.Length;i&#43;&#43;) { if (i &gt; 0) { sb.Append(separator); } sb.Append(HEX_CHARS[buf[i] &gt;&gt; 4]).Append(HEX_CHARS[buf[i] &amp; 0x0F]); } return sb." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8a03168ea7fa6f9f9709467d5342ebed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-12-12T11:11:47+08:00" />
<meta property="article:modified_time" content="2012-12-12T11:11:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">byte数据的常用操作函数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre><code class="language-csharp">/// &lt;summary&gt;
/// 本类提供了对byte数据的常用操作函数
/// &lt;/summary&gt;
public class ByteUtil
{
private static char[] HEX_CHARS = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
private static byte[] BITS = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};


/// &lt;summary&gt;
/// 将字节数组转换为HEX形式的字符串, 使用指定的间隔符
/// &lt;/summary&gt;
public static string ByteToHex(byte[] buf, string separator)
{
System.Text.StringBuilder sb = new System.Text.StringBuilder();
for(int i = 0;i &lt; buf.Length;i++)
{
if (i &gt; 0)
{
sb.Append(separator);
}
sb.Append(HEX_CHARS[buf[i] &gt;&gt; 4]).Append(HEX_CHARS[buf[i] &amp; 0x0F]);
}
return sb.ToString();
}




/// &lt;summary&gt;
/// 将字节数组转换为HEX形式的字符串, 使用指定的间隔符
/// &lt;/summary&gt;
public static string ByteToHex(byte[] buf, char c)
{
System.Text.StringBuilder sb = new System.Text.StringBuilder();
for(int i = 0;i &lt; buf.Length;i++)
{
if (i &gt; 0)
{
sb.Append(c);
}
sb.Append(HEX_CHARS[buf[i] &gt;&gt; 4]).Append(HEX_CHARS[buf[i] &amp; 0x0F]);
}
return sb.ToString();
}


        /// &lt;summary&gt;
        /// 判断字节数组前几位是否符合一定规则
        /// &lt;/summary&gt;
        /// &lt;param name="data"&gt;需要判断的字节数组&lt;/param&gt;
        /// &lt;param name="pattern"&gt;匹配规则&lt;/param&gt;
        /// &lt;returns&gt;如果匹配返回true&lt;/returns&gt;
        public static bool IsMatch(byte[] data, params byte[] pattern)
        {
            if (data == null || data.Length &lt; pattern.Length)
                return false;


            for(int i = 0;i &lt; pattern.Length;i++)
            {
                if (data[i] != pattern[i])
                    return false;
            }
            return true;
        }


        /// &lt;summary&gt;
        /// 判断指定字节是否为列举的某个值
        /// &lt;/summary&gt;
        /// &lt;param name="value"&gt;需要判断的值&lt;/param&gt;
        /// &lt;param name="choice"&gt;可能值&lt;/param&gt;
        /// &lt;returns&gt;如果与任一个可能值相等则返回true&lt;/returns&gt;
        public static bool IsMatch(byte value, params byte[] choice)
        {
            if (choice == null || choice.Length == 0)
                return false;


            foreach(byte item in choice)
            {
                if (item == value)
                    return true;
            }
            return false;
        }




        /// &lt;summary&gt;
        /// 将字节数组转换为HEX形式的字符串, 没有间隔符
        /// &lt;/summary&gt;
        public static string ByteToHex(byte[] buf)
{
return ByteToHex(buf, string.Empty);
}




/// &lt;summary&gt;
/// 将字节数组转换为HEX形式的字符串
/// 转换后的字符串长度为字节数组长度的两倍
/// 如: 1, 2 转换为 0102
/// &lt;/summary&gt;
public static string ByteToHex(byte b)
{
return string.Empty + HEX_CHARS[b &gt;&gt; 4] + HEX_CHARS[b &amp; 0x0F];
}




/// &lt;summary&gt;
/// 将字节流信息转换为HEX字符串
/// &lt;/summary&gt;
public static string DumpBytes(byte[] bytes)
{
return DumpBytes(bytes, 0, bytes.Length);
}


/// &lt;summary&gt;
        /// 将字节流信息转换为HEX字符串
/// &lt;/summary&gt;
public static string DumpBytes(byte[] bytes, int offset, int len)
{
   StringBuilder buf = new StringBuilder();
for(int i = 0;i &lt; len;i++)
{
if (i == 0 || i % 16 == 0)
                    buf.AppendLine();
   
buf.Append(ByteToHex(bytes[i + offset]));
                buf.Append(' ');
}
            buf.AppendLine();
            return buf.ToString();
}




/// &lt;summary&gt;
/// 计算字节块的模256校验和
/// &lt;/summary&gt;
public static byte SumBytes(byte[] bytes, int offset, int len)
{
int sum = 0;
for(int i = 0;i &lt; len;i++)
{
sum += bytes[i + offset];
if (sum &gt;= 256)
{
sum = sum % 256;
}
}
return (byte)sum;
}


/// &lt;summary&gt;
/// 计算字节块的模256双字节校验和(低位在前)
/// &lt;/summary&gt;
public static byte[] Sum2Bytes(byte[] bytes, int offset, int len)
{
int sum = 0;
for(int i = 0;i &lt; len;i++)
sum += bytes[i + offset];
            return new byte[] { (byte)(sum % 256), (byte)(sum / 256) };
}


/// &lt;summary&gt;
/// 计算字节块的异或校验和
/// &lt;/summary&gt;
public static byte XorSumBytes(byte[] bytes, int offset, int len)
{
byte sum = bytes[0 + offset];
for(int i = 1;i &lt; len;i++)
{
sum = (byte)(sum ^ bytes[i + offset]);
}
return sum;
}




/// &lt;summary&gt;
/// 计算字节块的异或校验和
/// &lt;/summary&gt;
public static byte XorSumBytes(byte[] bytes)
{
return XorSumBytes(bytes, 0, bytes.Length);
}




/// &lt;summary&gt;
/// 比较两个字节块是否相等。相等返回true否则false
/// &lt;/summary&gt;
public static bool CompareBytes(byte[] bytes1, int offset1, byte[] bytes2, int offset2, int len)
{
for(int i = 0;i &lt; len;i++)
{
if (bytes1[i + offset1] != bytes2[i + offset2])
{
return false;
}
}
return true;
}


/// &lt;summary&gt;
/// 将两个字符的hex转换为byte
/// &lt;/summary&gt;
public static byte HexToByte(char[] hex, int offset)
{
byte result = 0;
for(int i = 0;i &lt; 2;i++)
{
char c = hex[i + offset];
byte b = 0;
switch (c)
{
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
b = (byte)(c - '0');
break;
case 'A':
case 'B':
case 'C':
case 'D':
case 'E':
case 'F':
b = (byte)(10 + c - 'A');
break;
case 'a':
case 'b':
case 'c':
case 'd':
case 'e':
case 'f':
b = (byte)(10 + c - 'a');
break;
}
if (i == 0)
{
b = (byte)(b * 16);
}
result += b;
}


return result;
}


/// &lt;summary&gt;
/// 将两个字符的hex转换为byte
/// &lt;/summary&gt;
public static byte HexToByte(byte[] hex, int offset)
{
char[] chars = {(char)hex[offset], (char)hex[offset + 1]};
return HexToByte(chars, 0);
}


        /// &lt;summary&gt;
        /// 转换16进制字符串为字节数组
        /// &lt;param name="hex"&gt;有分隔或无分隔的16进制字符串，如“AB CD EF 12 34...”或“ABCDEF1234...”&lt;/param&gt;
        /// &lt;param name="dot"&gt;任意分隔字符，但不能是16进制字符&lt;/param&gt;
        /// &lt;returns&gt;字节数组&lt;/returns&gt;
        /// &lt;/summary&gt;
        public static byte[] HexToByte(string hex, params char[] dot) {
            char[] ca = new char[2];
            List&lt;byte&gt; list = new List&lt;byte&gt;();
            for (int i = 0, n = 0; i &lt; hex.Length; i++) {
                if (Array.IndexOf&lt;char&gt;(dot, hex[i]) &gt;= 0) {
                    continue;
                }


                switch (++n) {
                    case 1:
                        ca[0] = hex[i];
                        break;


                    case 2:
                        ca[1] = hex[i];
                        list.Add(ByteUtil.HexToByte(ca, 0));
                        n = 0;
                        break;
                }
            }


            return list.ToArray();
        }


/// &lt;summary&gt;
/// 将uint变量分解为四个字节。高位在前。
/// &lt;/summary&gt;
public static void UintToBytes(uint i, byte[] bytes, int offset)
{
bytes[offset] = (byte)((i &amp; 0xFF000000) &gt;&gt; 24);
bytes[offset + 1] = (byte)((i &amp; 0x00FF0000) &gt;&gt; 16);
bytes[offset + 2] = (byte)((i &amp; 0x0000FF00) &gt;&gt; 8);
bytes[offset + 3] = (byte)(i &amp; 0x000000FF);
}


        /// &lt;summary&gt;
        /// 将uint变量分解为四个字节。高位在前。
        /// &lt;/summary&gt;
        public static byte[] UintToBytes(uint i)
        {
            byte[] bytes = new byte[4];
            bytes[0] = (byte)((i &amp; 0xFF000000) &gt;&gt; 24);
            bytes[1] = (byte)((i &amp; 0x00FF0000) &gt;&gt; 16);
            bytes[2] = (byte)((i &amp; 0x0000FF00) &gt;&gt; 8);
            bytes[3] = (byte)(i &amp; 0x000000FF);
            return bytes;
        }


        /// &lt;summary&gt;
        /// 将int变量分解为四个字节。高位在前。
        /// &lt;/summary&gt;
        public static byte[] IntToBytes(int i)
        {
            byte[] data = BitConverter.GetBytes(i);
            Array.Reverse(data);
            return data;


            //byte[] bytes = new byte[4];
            //bytes[0] = (byte)((i &amp; 0xFF000000) &gt;&gt; 24);
            //bytes[1] = (byte)((i &amp; 0x00FF0000) &gt;&gt; 16);
            //bytes[2] = (byte)((i &amp; 0x0000FF00) &gt;&gt; 8);
            //bytes[3] = (byte)(i &amp; 0x000000FF);
            //return bytes;
        }


/// &lt;summary&gt;
/// 将四个字节合成为一个int
/// &lt;/summary&gt;
public static uint BytesToUint(byte[] bytes, int offset)
{
uint a = ((uint)bytes[offset]) &lt;&lt; 24;
uint b = ((uint)bytes[offset + 1]) &lt;&lt; 16;
uint c = ((uint)bytes[offset + 2]) &lt;&lt; 8;
uint d = bytes[offset + 3];
return a + b + c + d;
}


        /// &lt;summary&gt;
        /// 将ulong变量分解为八个字节。高位在前。
        /// &lt;/summary&gt;
        public static byte[] UlongToBytes(ulong i)
        {
            byte[] bytes = new byte[8];
            bytes[0] = (byte)((i &amp; 0xFF00000000000000) &gt;&gt; 56);
            bytes[1] = (byte)((i &amp; 0x00FF000000000000) &gt;&gt; 48);
            bytes[2] = (byte)((i &amp; 0x0000FF0000000000) &gt;&gt; 40);
            bytes[3] = (byte)((i &amp; 0x000000FF00000000) &gt;&gt; 32);
            bytes[4] = (byte)((i &amp; 0x00000000FF000000) &gt;&gt; 24);
            bytes[5] = (byte)((i &amp; 0x0000000000FF0000) &gt;&gt; 16);
            bytes[6] = (byte)((i &amp; 0x000000000000FF00) &gt;&gt; 8);
            bytes[7] = (byte)(i &amp; 0x00000000000000FF);
            return bytes;
        }


        /// &lt;summary&gt;
        /// 将八个字节合成为一个ulong
        /// &lt;/summary&gt;
        public static ulong BytesToUlong(byte[] bytes, int offset)
        {
            ulong a = ((ulong)bytes[offset]) &lt;&lt; 56;
            ulong b = ((ulong)bytes[offset + 1]) &lt;&lt; 48;
            ulong c = ((ulong)bytes[offset + 2]) &lt;&lt; 40;
            ulong d = ((ulong)bytes[offset + 3]) &lt;&lt; 32;
            ulong e = ((ulong)bytes[offset + 4]) &lt;&lt; 24;
            ulong f = ((ulong)bytes[offset + 5]) &lt;&lt; 16;
            ulong g = ((ulong)bytes[offset + 6]) &lt;&lt; 8;
            ulong h = bytes[offset + 7];
            return a + b + c + d + e + f + g + h;
        }




/// &lt;summary&gt;
/// 设置某个字节的指定位
/// &lt;/summary&gt;
/// &lt;param name="b"&gt;需要设置的字节&lt;/param&gt;
/// &lt;param name="pos"&gt;1-8, 1表示最低位, 8表示最高位&lt;/param&gt;
/// &lt;param name="on"&gt;true表示设置1, false表示设置0&lt;/param&gt;
public static void ByteSetBit(ref byte b, int pos, bool on)
{
int temp = BITS[pos - 1];


if (!on)
{
//取反
temp = temp ^ 0xFF;
}


b = (byte)(on?(b | temp):(b &amp; temp));
}


/// &lt;summary&gt;
/// 判断某个byte的某个位是否为1
/// &lt;/summary&gt;
        /// &lt;param name="pos"&gt;第几位，大于等于1&lt;/param&gt;
public static bool ByteGetBit(byte b, int pos)
{
int temp = BITS[pos - 1];
return (b &amp; temp) != 0;
}




/// &lt;summary&gt;
/// 设置双比特值
/// &lt;/summary&gt;
/// &lt;param name="b"&gt;需要设置的字节&lt;/param&gt;
/// &lt;param name="low"&gt;低位, 1-7&lt;/param&gt;
/// &lt;param name="val"&gt;值，0-3&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static void ByteSetBitPair(ref byte b, int low, int val)
{
if (low &lt; 1 || low &gt; 7)
{
throw new ArgumentException(string.Format("无效的low值:{0}", low));
}


switch(val)
{
case 0:
{
ByteUtil.ByteSetBit(ref b, low, false);
ByteUtil.ByteSetBit(ref b, low + 1, false);
break;
}
case 1:
{
ByteUtil.ByteSetBit(ref b, low, true);
ByteUtil.ByteSetBit(ref b, low + 1, false);
break;
}
case 2:
{
ByteUtil.ByteSetBit(ref b, low, false);
ByteUtil.ByteSetBit(ref b, low + 1, true);
break;
}
case 3:
{
ByteUtil.ByteSetBit(ref b, low, true);
ByteUtil.ByteSetBit(ref b, low + 1, true);
break;
}
default:
{
throw new ArgumentException(string.Format("无效的val值:{0}", val));
}
}
}




/// &lt;summary&gt;
/// 读取双比特值
/// &lt;/summary&gt;
/// &lt;param name="b"&gt;需要读取的字节&lt;/param&gt;
/// &lt;param name="low"&gt;低位, 0-6&lt;/param&gt;
/// &lt;returns&gt;0-3&lt;/returns&gt;
public static byte ByteGetBitPair(byte b, int low)
{
if (low &lt; 0 || low &gt; 7)
{
throw new ArgumentException(string.Format("无效的low值:{0}", low));
}


int x = 0;
x += ByteUtil.ByteGetBit(b, low)?1:0;
x += ByteUtil.ByteGetBit(b, low + 1)?2:0;


return (byte)x;
}


/// &lt;summary&gt;
/// 将short转换为两个字节
/// &lt;/summary&gt;
/// &lt;param name="s"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static byte[] ShortToByte(short s)
{
return UshortToByte((ushort)s);
}


/// &lt;summary&gt;
/// 将ushort转换为两个字节
/// &lt;/summary&gt;
public static byte[] UshortToByte(ushort u)
{
return new byte[]{
(byte)(u &gt;&gt; 8),
(byte)(u &amp; 0x00FF)
};
}


/// &lt;summary&gt;
/// 将两个字节转换为一个short
/// &lt;/summary&gt;
public static short BytesToShort(byte[] data, int offset)
{
short a = data[offset], b = data[offset + 1];
return (short)((a &lt;&lt; 8) + b);
}


        /// &lt;summary&gt;
        /// 将两个字节转换为一个short
        /// &lt;/summary&gt;
        public static ushort BytesToUshort(byte[] data, int offset)
        {
            ushort a = data[offset], b = data[offset + 1];
            return (ushort)((a &lt;&lt; 8) + b);
        }
   
   /// &lt;summary&gt;
   /// 将四个字节转换为int
   /// &lt;/summary&gt;
   /// &lt;param name="data"&gt;&lt;/param&gt;
   /// &lt;param name="offset"&gt;&lt;/param&gt;
   /// &lt;returns&gt;&lt;/returns&gt;
   public static int BytesToInt(byte[] data, int offset)
   {
            return (data[offset] &lt;&lt; 24) + (data[offset + 1] &lt;&lt; 16) + (data[offset + 2] &lt;&lt; 8) + data[offset + 3];
   }


        /// &lt;summary&gt;
        /// 将guid字符串转换为等价的16维字节数组
        /// &lt;/summary&gt;
        public static byte[] GuidToBytes(string s)
        {
            byte[] guid = new byte[16];
            char[] hex = s.Replace("-", string.Empty).Replace(" ", string.Empty).ToCharArray();
            for (int i = 0; i &lt; 32; i += 2)
            {
                guid[i / 2] = ByteUtil.HexToByte(hex, i);
            }
            return guid;
        }


        /// &lt;summary&gt;
        /// CRC16校验表
        /// &lt;/summary&gt;
        static ushort[] wCRCTalbeAbs = {0x0000, 0xCC01, 0xD801, 0x1400, 0xF001, 0x3C00, 0x2800, 0xE401, 0xA001, 0x6C00, 0x7800, 0xB401, 0x5000, 0x9C01, 0x8801, 0x4400};


        /// &lt;summary&gt;
        /// 计数字节块的CRC16校验值
        /// &lt;/summary&gt;
        public static int CRC16Bytes(byte[] bytes, int offset, int len)
        {
                int wCRC = 0xFFFF;
                byte chChar;


                for (int i = offset; i &lt; len; i++)
                {
                        chChar = bytes[i];
                        wCRC = wCRCTalbeAbs[(chChar ^ wCRC) &amp; 15] ^ (wCRC &gt;&gt; 4);
                        wCRC = wCRCTalbeAbs[((chChar &gt;&gt; 4) ^ wCRC) &amp; 15] ^ (wCRC &gt;&gt; 4);
                }


                return wCRC;
        }


        /// &lt;summary&gt;
        /// 字节格式化，将字节转换为字节、KB、MB、GB显示
        /// &lt;/summary&gt;
        /// &lt;param name="bytes"&gt;字节数&lt;/param&gt;
        /// &lt;returns&gt;格式化后的字符串&lt;/returns&gt;
        public static string ByteFormater(long bytes)
        {
            const long KB = 1024;
            const long MB = 1024 * 1024;
            const long GB = 1024 * 1024 * 1024;


            if (bytes &gt;= GB)
            {
                double result = bytes * 1.0 / GB;
                return result.ToString("#,##0.0") + "GB";
            }
            if (bytes &gt;= MB)
            {
                double result = bytes * 1.0 / MB;
                return result.ToString("#,##0.0") + "MB";
            }
            if (bytes &gt;= KB)
            {
                double result = bytes * 1.0 / KB;
                return result.ToString("#,##0.0") + "KB";
            }
            return bytes.ToString("#,##0") + "字节";
        }
    }</code></pre> 
<br> 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1fcd7dc89f776cb1632a43c8095dd3a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实用网址（永久更新中）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d169b7165ad3a501ab6eddd18465130/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">是如何利用LoadRunner判断HTTP服务器的返回状态.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>