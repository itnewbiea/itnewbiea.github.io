<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】特殊类设计 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;】特殊类设计" />
<meta property="og:description" content="一、设计一个类，不能被拷贝 拷贝只会发生在两个场景中：拷贝构造函数和赋值运算符重载。
因此想要让一个类禁止拷贝，只需让该类不能调用拷贝构造函数以及赋值运算符重载即可。
1、C&#43;&#43;98 将拷贝构造函数与赋值运算符重载只声明不定义，并且将其访问权限设置为私有即可。
class CopyBan { public: CopyBan() {} private: CopyBan(const CopyBan&amp; cb); // 拷贝构造函数声明 CopyBan&amp; operator=(const CopyBan&amp; cb); // 赋值运算符重载声明 }; 【原因】 设置成私有：如果只声明而没有设置成 private，用户自己如果在类外定义了，就可以不能禁止拷贝了。只声明不定义：不定义是因为该函数根本不会调用，定义了其实也没什么意义，不写反而更简单，而且如果定义了就不能防止成员函数内部拷贝了。 如上图代码，在对这个特殊类进行拷贝和赋值的时候，因为这两个成员函数私有而无法调用。
拷贝构造以及赋值运算符重载等成员函数，在调用时都是编译器在域外调用，所以必须是公有的。
2、C&#43;&#43;11 C&#43;&#43;11 扩展了 delete 的用法，delete 除了释放 new 申请的资源以外，如果在默认成员函数后跟上 = delete，表示让编译器删除掉该默认成员函数，此时编译器也不会自动生成默认的拷贝构造和赋值运算符重载函数。
class CopyBan { public: CopyBan() {} private: CopyBan(const CopyBan&amp; cb) = delete; // 拷贝构造函数声明 CopyBan&amp; operator=(const CopyBan&amp; cb) = delete; // 赋值运算符重载声明 }; 二、设计一个类，只能在堆上创建对象 正常创建类对象时，会在栈上创建，并且自动调用构造函数来初始化。下面设计一个类，只能在堆上创建对象。
1、实现方式 只能在创建在堆上时，就需要让该对象只能通过 new 来创建，并且调用构造函数来初始化。
将类的构造函数私有，拷贝构造声明成私有。防止别人调用拷贝在栈上生成对象。 提供一个静态的成员函数，在该静态成员函数中完成堆对象的创建。 class HeapOnly { public: static HeapOnly* CreateObject() { return new HeapOnly; } private: //构造函数 HeapOnly() {} HeapOnly(const HeapOnly&amp; hp) = delete; // 禁止拷贝 }; 定义一个静态成员函数，在该函数内部 new 一个 HeapOnly 对象。将构造函数和拷贝构造函数私有，并且禁止生成拷贝构造函数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fe85f1827c89f7ca77e2ce50496f2049/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T12:15:28+08:00" />
<meta property="article:modified_time" content="2023-12-25T12:15:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】特殊类设计</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、<span style="color:#333333;">设计一个类，不能被拷贝</span><span style="color:#0d0016;"> </span></h2> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>拷贝</strong></span><span style="color:#0d0016;">只会发生在两个场景中：</span><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">拷贝构造函数</span></strong></span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;"><span style="background-color:#ffd900;"><strong>赋值运算符重载</strong></span></span><span style="color:#0d0016;"><span style="background-color:#ffd900;">。</span></span></p> 
 <p><span style="color:#0d0016;">因此<strong>想要让一个类禁止拷贝，只需让<span style="background-color:#ffd900;">该类不能调用拷贝构造函数以及赋值运算符重载</span>即可</strong>。</span></p> 
</blockquote> 
<hr> 
<h4><span style="color:#0d0016;">1、C++98</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><span style="background-color:#ffd900;">将拷贝构造函数与赋值运算符重载</span><strong><span style="background-color:#ffd900;">只声明不定义</span></strong>，并且将其<strong>访问权限设置为<span style="background-color:#ffd900;">私有</span></strong>即可。</span></p> 
</blockquote> 
<pre><code class="language-cpp">class CopyBan
{
public:
	CopyBan()
	{}
private:
	CopyBan(const CopyBan&amp; cb); // 拷贝构造函数声明
	CopyBan&amp; operator=(const CopyBan&amp; cb); // 赋值运算符重载声明
};</code></pre> 
<div> 
 <strong><span style="color:#0d0016;">【原因】</span></strong> 
</div> 
<blockquote> 
 <ol><li><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">设置成私有</span></strong></span><span style="color:#0d0016;">：如果只声明而没有设置成 private，用户自己如果在类外定义了，就可以不</span><span style="color:#0d0016;">能禁止拷贝了。</span></li><li><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">只声明不定义</span></strong></span><span style="color:#0d0016;">：不定义是因为该函数根本不会调用，定义了其实也没什么意义，不写</span><span style="color:#0d0016;">反而更简单，而且如果定义了就不能防止成员函数内部拷贝了。 </span></li></ol> 
</blockquote> 
<p><img alt="" height="208" src="https://images2.imgbox.com/bc/9e/qvX1Gpfq_o.png" width="420"></p> 
<p><span style="color:#0d0016;">如上图代码，在对这个特殊类进行拷贝和赋值的时候，<span style="background-color:#ffd900;">因为这两个成员函数私有而无法调用</span>。</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">拷贝构造以及赋值运算符重载等成员函数，在调用时都是编译器在域外调用，所以必须是公有的。</span></p> 
</blockquote> 
<hr> 
<h4><span style="color:#0d0016;">2、C++11</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>C++11</strong> 扩展了 </span><span style="color:#fe2c24;"><strong>delete</strong></span><span style="color:#0d0016;"> 的用法，delete 除了<span style="background-color:#ffd900;">释放 new 申请的资源</span>以外，如果<span style="background-color:#ffd900;">在默认成员函数后跟上 </span></span><span style="color:#fe2c24;"><span style="background-color:#ffd900;"><strong>= delete</strong></span></span><span style="color:#0d0016;"><span style="background-color:#ffd900;">，表示</span></span><span style="color:#fe2c24;"><span style="background-color:#ffd900;"><strong>让编译器删除掉该默认成员函数</strong></span></span><span style="color:#0d0016;">，此时编译器也<span style="background-color:#ffd900;">不会自动生成默认的拷贝构造和赋值运算符重载函数</span>。</span></p> 
</blockquote> 
<pre><code class="language-cpp">class CopyBan
{
public:
	CopyBan()
	{}
private:
	CopyBan(const CopyBan&amp; cb) = delete; // 拷贝构造函数声明
	CopyBan&amp; operator=(const CopyBan&amp; cb) = delete; // 赋值运算符重载声明
};</code></pre> 
<hr> 
<h2><span style="color:#0d0016;">二、设计一个类，只能在</span><span style="color:#fe2c24;">堆上</span><span style="color:#0d0016;">创建对象 </span></h2> 
<blockquote> 
 <p><span style="color:#0d0016;">正常创建类对象时，会在栈上创建，并且自动调用构造函数来初始化。下面设计一个类，只能在</span><span style="color:#fe2c24;">堆上</span><span style="color:#0d0016;">创建对象。</span></p> 
</blockquote> 
<h4><span style="color:#0d0016;">1、实现方式</span></h4> 
<p><span style="color:#0d0016;">只能在创建在<strong>堆上</strong>时，就需要让该对象只能通过 new 来创建，并且调用构造函数来初始化。</span></p> 
<blockquote> 
 <ol><li><span style="color:#0d0016;"><span style="background-color:#ffd900;">将类的构造函数私有，拷贝构造声明成私有。</span>防止别人调用拷贝在栈上生成对象。 </span></li><li><span style="color:#0d0016;"><span style="background-color:#ffd900;">提供一个静态的成员函数</span>，在该静态成员函数中完成<span style="background-color:#ffd900;">堆对象的创建</span>。</span></li></ol> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">class HeapOnly
{
public:
	static HeapOnly* CreateObject()
	{
		return new HeapOnly;
	}
private:
	//构造函数
	HeapOnly() {}
	HeapOnly(const HeapOnly&amp; hp) = delete; // 禁止拷贝
};</code></pre> 
 <p>定义一个静态成员函数，在该函数内部 new 一个 HeapOnly 对象。将构造函数和拷贝构造函数私有，并且禁止生成拷贝构造函数。</p> 
 <p><strong><span style="color:#0d0016;">【原因】</span></strong></p> 
 <ul><li>使用静态成员函数 new 一个 HeapOnly 对象。</li></ul> 
 <blockquote> 
  <p>那么非静态成员函数在调用时，必须使用点 (.) 操作符来调用，这一步是为了传 this 指针。这样的前提是先有一个 HeapOnly 对象，但是构造函数设置成了私有，就无法创建这样一个对象。</p> 
  <p>而静态成员函数的调用不用传 this 指针，也就不需要必须有 HeapOnly 对象，只需要类域 :: 静态成员函数即可。静态成员函数属于 HeapOnly 域内，所以在 new 一个对象的时候，可以调用私有的构造函数。</p> 
 </blockquote> 
 <ul><li>禁止调用拷贝构造函数并且私有化。</li></ul> 
 <blockquote> 
  <p>这样做的目的是为了禁止拷贝，防止使用堆区上的 HeapOnly 对象在栈区上拷贝，如下面代码：</p> 
  <p><img alt="" height="163" src="https://images2.imgbox.com/f4/5c/d8l9J7Do_o.png" width="420"></p> 
  <p>而禁止了拷贝构造就杜绝了这一行为，从而保证了 HeapOnly 对象只能在堆上创建。</p> 
 </blockquote> 
 <hr> 
 <h2><span style="color:#0d0016;">三、<strong>设计一个类，只能在</strong></span><span style="color:#fe2c24;"><strong>栈上</strong></span><span style="color:#0d0016;"><strong>创建对象</strong></span></h2> 
 <blockquote> 
  <p></p> 
  <ul><li>主要是需要做到不能在堆上创建类对象。</li><li>new 一个对象的时候，会调用该类的 operator new(size_t size) 函数，在释放资源的时候又会调用该类的 operator delete(void* p) 函数。</li></ul> 
 </blockquote> 
 <h4><span style="color:#0d0016;">1、方法一</span></h4> 
 <blockquote> 
  <p><span style="color:#0d0016;">所以防止在堆上创建类对象就是要禁止调用 operator new(size_t size) 和 operator delete(void* p) 这两个函数。</span></p> 
 </blockquote> 
 <div> 
  <pre><code class="language-cpp">class StackOnly
{
public:
	// 构造函数
	StackOnly()
	{}

	void* operator new(size_t size) = delete; // 禁止调用new
	void operator delete(void* p) = delete; // 禁止调用delete
};</code></pre> 
  <p>使用 delete 来禁止这两个函数的调用，那么在 new 一个对象的时候，就会产生编译错误，从而无法在堆区上创建类对象。</p> 
  <p><img alt="" height="116" src="https://images2.imgbox.com/26/20/QDtd3Okq_o.png" width="420"></p> 
  <p>此时在堆上创建对象时就会报错，尝试引用已删除的函数。</p> 
  <hr> 
  <h4>2、方法二</h4> 
  <blockquote> 
   <p><span style="color:#0d0016;">另一种方式就是和之前一样，通过一个静态成员函数在栈区上创建一个类对象，并且<span style="background-color:#ffd900;">将默认构造函数私有化</span>，然后<span style="background-color:#ffd900;">设计静态方法创建对象返回</span>即可。</span></p> 
  </blockquote> 
  <pre><code class="language-cpp">class StackOnly
{
public:
	static StackOnly CreateObject()
	{
		return StackOnly();
	}
private:
	StackOnly()
	{}
};</code></pre> 
  <p><img alt="" height="175" src="https://images2.imgbox.com/0d/21/PEJPKIFR_o.png" width="420"></p> 
  <p>此时 new 一个对象的时候，由于默认构造函数私有而无法调用，所以报错。</p> 
  <hr> 
  <p>但以上两种设计方法都有一个漏洞，类对象可以在静态区（数据段）上创建：</p> 
  <pre><code class="language-cpp">static StackOnly so = StackOnly::CreateObject();</code></pre> 
  <blockquote> 
   <p><strong><span style="background-color:#ffd900;">设计特殊类的<span style="color:#fe2c24;">核心</span></span>：只能通过静态成员函数来创建类，封掉其他所有创建方式</strong>。</p> 
  </blockquote> 
  <hr> 
  <h2><span style="color:#0d0016;">四、设计一个类，不能被继承<strong> </strong></span></h2> 
 </div> 
 <h4><span style="color:#0d0016;">1、C++98 方式</span><span style="color:#777777;"> </span></h4> 
 <blockquote> 
  <p><span style="color:#0d0016;">C++98 中<strong><span style="background-color:#ffd900;">构造函数私有化</span></strong>，<span style="background-color:#ffd900;">派生类中调不到基类的构造函数则无法继承</span>。</span></p> 
 </blockquote> 
 <div> 
  <pre><code class="language-cpp">// 基类
class NonInherit
{
private:
	// 基类构造函数私有
	NonInherit()
	{}
};

// 派生类
class B : public NonInherit
{};</code></pre> 
  <hr> 
  <h4><span style="color:#0d0016;">2、C++11 方法 </span></h4> 
  <blockquote> 
   <div> 
    <span style="color:#0d0016;">使用</span> 
    <span style="color:#fe2c24;"><strong> final</strong></span> 
    <span style="color:#0d0016;"> 关键字来<strong>修饰类，表示<span style="background-color:#ffd900;">该类不能被继承</span>。</strong></span> 
   </div> 
  </blockquote> 
 </div> 
 <div> 
  <pre><code class="language-cpp">class A final
{};</code></pre> 
  <hr> 
  <h2><span style="color:#0d0016;">五、设计一个类，只能创建一个对象（单例模式）</span></h2> 
  <h4><span style="color:#0d0016;">1、设计模式</span></h4> 
  <blockquote> 
   <div> 
    <span style="color:#fe2c24;"><strong>设计模式</strong></span> 
    <span style="color:#0d0016;">（Design Pattern）是一套<strong>被反复使用、多数人知晓的、经过分类的、代码设计经验的</strong></span> 
    <span style="color:#0d0016;"><strong>总结</strong>。</span> 
   </div> 
  </blockquote> 
  <h5><span style="color:#fe2c24;"><strong>为什么会产生设计模式这样的东西呢？</strong></span></h5> 
  <blockquote> 
   <div> 
    <span style="color:#0d0016;">就像人类历史发展会产生兵法。最开始部落之间打仗时都是人拼人的对砍。后来春秋战国时期，七国之间经常打仗，就发现打仗也是有<strong>套路</strong>的，后来孙子就总结出了《孙子兵法》。孙子兵法也是类似。</span> 
   </div> 
   <div> 
    <span style="color:#0d0016;"><span style="background-color:#ffd900;">使用设计模式的目的</span>：为了代码<strong><span style="background-color:#ffd900;">可重用性</span></strong>、让代码<strong><span style="background-color:#ffd900;">更容易被他人理解</span></strong>、<strong><span style="background-color:#ffd900;">保证代码可靠性</span></strong>。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 </span> 
   </div> 
  </blockquote> 
  <div> 
   <hr> 
   <h4><span style="color:#0d0016;">2、单例模式（一种设计模式）</span></h4> 
  </div> 
  <blockquote> 
   <ul><li><span style="color:#fe2c24;"><strong>单例模式</strong></span><span style="color:#0d0016;">：<strong><span style="background-color:#ffd900;">一个类只能创建一个对象。</span></strong></span></li><li><span style="color:#0d0016;"><strong>该模式可以保证系统中<span style="background-color:#ffd900;">该类只有一个实例</span>，并提供一个</strong></span><span style="color:#0d0016;"><strong>访问它的全局访问点，该实例被所有程序模块共享</strong>。</span></li></ul> 
   <div> 
    <span style="color:#0d0016;">比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理。 </span> 
   </div> 
  </blockquote> 
  <ul><li><strong>全局只有一个实例对象</strong>，所以<span style="background-color:#ffd900;">将单例对象放在<span style="color:#fe2c24;">静态区 / 堆区</span></span>（保证只创建一次）。</li><li> 为了<strong>防止其他位置创建该对象</strong>，<span style="background-color:#ffd900;">将构造函数<span style="color:#fe2c24;">私有</span></span>。</li><li> 为了<strong>防止拷贝</strong>，<span style="background-color:#ffd900;">使用<span style="color:#fe2c24;"> delete </span>修饰拷贝构造和赋值运算符重载函数</span>。</li></ul> 
  <hr> 
  <p><strong><span style="color:#0d0016;">单例模式有两种实现模式：</span></strong></p> 
  <h5><span style="color:#0d0016;">（1）饿汉模式</span></h5> 
  <blockquote> 
   <div> 
    <span style="color:#0d0016;">就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象。 </span> 
   </div> 
  </blockquote> 
 </div> 
 <pre><code class="language-cpp">// 饿汉模式
class Singleton
{
public:
    // 获取单例对象接口
    static Singleton* GetInstance()
    {
        return &amp;m_instance;
    }
private:
    // 构造函数私有
    Singleton()
    {};
    
    // C++98 防拷贝
    Singleton(Singleton const&amp; s); 
    Singleton&amp; operator=(Singleton const&amp; s); 
      
    // or
      
    // C++11
    Singleton(const Singleton&amp; s) = delete; // 禁止使用拷贝构造
	Singleton&amp; operator=(const Singleton&amp; s) = delete; // 禁止使用赋值运算符重载
  
    // 保证单例对象在静态区且只有一个
	static Singleton m_instance; // 单例对象
};
// 在程序入口之前就完成单例对象的初始化
Singleton* Singleton::m_instance = new Singleton; 

int main()
{
	cout &lt;&lt; Singleton::GetInstance() &lt;&lt; endl;
	cout &lt;&lt; Singleton::GetInstance() &lt;&lt; endl;
	cout &lt;&lt; Singleton::GetInstance() &lt;&lt; endl;
	return 0;
}</code></pre> 
 <p><img alt="" height="686" src="https://images2.imgbox.com/68/20/XlCRaNDc_o.png" width="700"></p> 
 <p><span style="color:#0d0016;">静态成员变量只能在类域外进行定义初始化。</span></p> 
 <p><span style="color:#0d0016;">所以在 main 函数之前就将单例对象定义初始化，此时该单例对象创建在静态区上，而且仅有一个，后面就无法再创建。</span></p> 
 <blockquote> 
  <ul><li><span style="color:#0d0016;">想要获取该单例对象只能通过静态成员函数 GetInstance() 来获取。</span></li><li><span style="color:#0d0016;">静态成员函数可以直接访问静态成员变量 m_instance。</span></li></ul> 
 </blockquote> 
 <pre><code class="language-cpp">int main()
{
	Singleton* s = Singleton::GetInstance(); // 获取单例对象
	return 0;
}</code></pre> 
 <h6><span style="color:#fe2c24;"><strong>为什么称之为<span style="background-color:#ffd900;">饿汉模式</span>呢？</strong></span></h6> 
 <blockquote> 
  <p><span style="color:#0d0016;">不管将来会不会使用到这个单例对象，但是在程序一启动还没有进入 main 函数之前就创建一个唯一的实例对象。就像一个饿汉一样，一上来就先吃（创建单例对象）。</span></p> 
 </blockquote> 
 <h6><strong><span style="color:#0d0016;">【总结】</span></strong></h6> 
 <blockquote> 
  <p><span style="color:#0d0016;">1、<span style="background-color:#ffd900;">如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，那么显然使用饿汉模式来避免资源竞争，提高响应速度更好。</span><br> 2、<span style="background-color:#ffd900;">饿汉单例模式</span><strong><span style="background-color:#ffd900;">优点</span></strong>：</span></p> 
  <ul><li>保证全局（整个进程）只有唯一实例对象。</li><li><span style="color:#0d0016;">饿汉模式：一开始就创建对象，特别简单。</span></li></ul> 
  <p><span style="color:#0d0016;">3、<span style="background-color:#ffd900;">饿汉单例模式</span><strong><span style="background-color:#ffd900;">缺点</span></strong>：</span></p> 
  <ul><li>多个单例对象 A、B、C 假设要求他们之间有依赖关系：依次创建就无法达到，无法保证顺序<span style="color:#0d0016;">可能会导致进程启动很慢。</span></li></ul> 
 </blockquote> 
</div> 
<div> 
 <span style="color:#0d0016;">如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，那么显然使用饿汉模式来避 </span> 
</div> 
<div> 
 <span style="color:#0d0016;">免资源竞争，提高响应速度更好。 </span> 
</div> 
<hr> 
<h5><span style="color:#0d0016;">（2）懒汉模式</span></h5> 
<pre><code class="language-cpp">// 懒汉模式
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std;

class Singleton
{
public:
    static Singleton* GetInstance()
    {
        // 注意这里一定要使用Double-Check的方式加锁，才能保证效率和线程安全
		if (nullptr == m_pInstance) 
        {
            // 如果单例对象没有创建则在堆区创建
            if (nullptr == m_pInstance)
            {
                m_pInstance = new Singleton();
            }
            return m_pInstance;
        }
    }
    
    // 实现一个内嵌垃圾回收类
	class CGarbo 
    {
	public:
		~CGarbo() 
        {
			if (Singleton::m_pInstance)
				delete Singleton::m_pInstance;
		}
	};

	// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象
	static CGarbo Garbo;
private:
    // 构造函数
    Singleton(){};

    // 防拷贝
    Singleton(const Singleton&amp; s) = delete; // 禁止拷贝
	Singleton&amp; operator=(const Singleton&amp; s) = delete; // 禁止赋值

    //静态单例对象指针
	static Singleton* m_pInstance;//单例对象指针

	static mutex m_mtx; //互斥锁
};

Singleton* Singleton::m_pInstance = nullptr; // 初始化为空
Singleton::CGarbo Garbo;
mutex Singleton::m_mtx;

void func(int n)
{
	cout &lt;&lt; Singleton::GetInstance() &lt;&lt; endl;
}
 
// 多线程环境下才能演示上面GetInstance()加锁和不加锁的区别
int main()
{
	thread t1(func, 10);
	thread t2(func, 10);
	t1.join();
	t2.join();
	cout &lt;&lt; Singleton::GetInstance() &lt;&lt; endl;
	cout &lt;&lt; Singleton::GetInstance() &lt;&lt; endl;
    return 0;
}</code></pre> 
<p><img alt="" height="597" src="https://images2.imgbox.com/a6/1a/456R2M2a_o.png" width="700"></p> 
<p>这里出现了一个有关线程安全的问题。当多线程时，进行判断为 nullptr，这时还没有调用 new，当前的线程就被切走了。下一个线程来了还是 nullptr 就又进去 new 了一个对象，然后恢复第一个线程的上下文后又 new 了一个对象，第二个 new 的就将第一个的给覆盖了，所以就出现了错误。</p> 
<p>这里我们就可以使用<strong><span style="background-color:#ffd900;">互斥锁</span></strong>：</p> 
<p><img alt="" height="533" src="https://images2.imgbox.com/5a/c3/P2pJW6NG_o.png" width="460"></p> 
<p>因为加锁需要加在一个锁上才有用，所以我们也要将锁设为静态的，然后在类外进行初始化，这样就保证了只实例化出一个对象来，但实际上这样还是有问题的。</p> 
<p>当我们 new 出一个对象之后，我们在进行调用 GetInstance 的时候，还会不停的加锁解锁。加锁解锁是有性能消耗的，所以不断的加锁解锁是很不好的，所以这里我们要使用<strong>双检测加锁</strong>：</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/1f/57/7u7L8ef7_o.png" width="380"></p> 
<p>这样减少了加锁，提高了效率，但还是会有一点问题，单例对象什么时候释放呢？</p> 
<p>其实单例对象是不需要释放的。因为在一般情况下，单例在进程启动之后随时会被使用，而且这个对象也不大，所以就可以不去释放它。那么会有内存泄漏吗？</p> 
<p>如果进程是正常结束的，因为 new 出来得到的进程地址空间是虚拟内存，当结束之后就会将地址通过页表取消映射，那么 new 出来的资源就会还给 OS。当然如果想要释放也是没有问题的：<br><img alt="" height="295" src="https://images2.imgbox.com/c0/d5/ogaGtv0L_o.png" width="360"></p> 
<p>实现一个 DelInstance 手动调用的去释放。</p> 
<p>当然有可能考虑到程序结束时，需要处理一下持久化保存一些数据，比方说要将数据写到硬盘上。那么可以写一个析构函数，在析构函数中去处理。如果担心会忘记手动调用  DelInstance ，那么可以通过设计一个类，在类中实现一个析构函数。</p> 
<p><img alt="" height="633" src="https://images2.imgbox.com/78/85/1vCQyTtG_o.png" width="540"></p> 
<p>上面就是在创建的时候创建一个 _gc。当 main 结束时，_gc 生命周期结束，然后调用它的析构函数，直接将单例对象进行析构。</p> 
<blockquote> 
 <ul><li>同样将构造函数私有，拷贝构造和赋值运算符重载函数禁止调用，用来保证单例模式的唯一性。</li><li>增加静态单例对象指针成员变量。</li></ul> 
</blockquote> 
<p><span style="color:#0d0016;">在类外实例化静态指针变量的时候，并没有创建单例对象，而是将其初始化为空。</span></p> 
<pre><code class="language-cpp">int main()
{
	Singleton* ps = Singleton::GetInstance();//获取单例对象
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;">在获取单例对象时，如果是第一次使用，那么就会在堆区上 new 一个单例对象，并且将所在地址赋值给静态的成员指针变量。</span></p> 
</blockquote> 
<h6><span style="color:#fe2c24;"><strong>为什么称之为懒汉模式呢？</strong></span></h6> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>懒汉模式</strong></span><span style="color:#0d0016;">又叫做延时加载模式。如果单例对象构造十分耗时或者占用很多资源，比如加载插件、初始化网络连接、读取文件等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢，所以这种情况使用懒汉模式（延迟加载）更好。</span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;">【优点】</span></p> 
 <ul><li><span style="color:#0d0016;">第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序（</span>通过代码顺序）<span style="color:#0d0016;">自由控制。</span></li></ul> 
 <hr> 
 <p><span style="color:#0d0016;">【缺点】</span></p> 
 <ul><li><span style="color:#0d0016;">复杂。</span></li><li><span style="color:#0d0016;">如果不加锁是会出现线程安全的问题。</span>但是加锁是会十分影响性能的，所以引入了双检查。那么既要保证线程安全+又要保证效率的问题。</li></ul> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00f6c085e6628c04824a4a62bccabbe5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">云原生MeetUp| 1222 KubeSphere &#43; 敏捷 主题分享会</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3ae43ecc157be8b836ac15a981f965c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Javaweb考前复习冲刺(不断更新版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>