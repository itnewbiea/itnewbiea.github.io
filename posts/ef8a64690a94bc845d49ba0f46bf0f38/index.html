<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WEBSPHERE性能调优! - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WEBSPHERE性能调优!" />
<meta property="og:description" content="一、websphere参数设置及性能调优
1、应用程序服务器 &gt; server1 &gt; Web 容器-&gt;线程池 Web 容器用来设置最大并发用户，它维护着一个线程池，用来处理接受到的jsp/servlet请求。
2、应用程序服务器 &gt; server1 &gt;ORB 服务-&gt;线程池 对象请求代理（ORB）可以设置线程池的大小；同时，在这里也可以设置线程池自增长功能，点选“可增长线程池”选项，使得即使设置了最大的线程池大小，当并发的EJB请求过多，线程池的大小还是可以超过预先设置的最大值。
3、应用程序服务器 &gt; server1 &gt;ORB 服务 在EJB1.1规范中，要求远程方法一律使用参数值传递方式来调用，如果调用EJB的Servlet或者其它EJB是部署在同一个应用服务器下，那么它们 是共享一个JVM的，也就是说可以使得函数调用的方式变为参数引用传递，这样的话，视参数对象的复杂程度而定，可以提高5%-50%的函数调用效率。我们 可以通过点击 “按引用传送” 选项来调整ORB的参数传递方式。
4、应用程序服务器 &gt; server1 &gt;Web 容器-&gt;定制属性 MaxKeepAliveConnections ：表示系统同时保存的最大连接个数，超过这一个数时最近最少被使用的连接将被关闭, 整型，缺省值是：300；
MaxKeepAliveRequests ：客户端请求被保持到一个请求队列，此属性用于决定请求队列可保持的最大客户端请求数，整型，缺省值是：100；
5、应用程序服务器 &gt; server1 &gt;进程定义 &gt;Java 虚拟机-&gt;初始堆大小 Java 虚拟机（JVM）堆大小设置将影响 Java 对象的无用数据收集。堆设置过大，会占用过多的内存，使内存资源耗尽，从而会频繁的进行I/O操作来使用虚拟内存。堆设置过小，会使得对象可分配空间变小，从而会频繁的使用垃圾收集机制来释放内存空间，而每次垃圾收集，都会耗用一定的系统资源。请考虑： (1)选定应用程序服务器的 JVM 堆是否与同一机器上的其它应用程序服务器 JVM 堆共享物理内存。例如，您是以本地方式还是以远程方式运行监视器？
(2)指定 JVM 堆驻留在物理内存中并防止交换到磁盘。 (3)将起始 JVM 堆大小设置为最大 JVM 堆大小的 1/4。 (4)如果机器上只有一个应用程序服务器，则将最大 JVM 堆大小设置为以下值： 128 MB（内存小于 1 GB 的系统） 256 MB（内存 1 - 2 GB 的系统） 512 MB（内存大于 2 GB 的系统）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ef8a64690a94bc845d49ba0f46bf0f38/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-08-16T11:33:00+08:00" />
<meta property="article:modified_time" content="2010-08-16T11:33:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WEBSPHERE性能调优!</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="sina_keyword_ad_area2" class="articalContent"> 
 <p>一、websphere参数设置及性能调优</p> 
 <p><strong>1、应用程序服务器 &gt; server1 &gt; Web 容器-&gt;线程池</strong> </p> 
 <p>Web 容器用来设置最大并发用户，它维护着一个线程池，用来处理接受到的jsp/servlet请求。</p> 
 <p><strong>2、应用程序服务器 &gt; server1 &gt;ORB 服务-&gt;线程池</strong> </p> 
 <p> 对象请求代理（ORB）可以设置线程池的大小；同时，在这里也可以设置线程池自增长功能，点选“可增长线程池”选项，使得即使设置了最大的线程池大小，当并发的EJB请求过多，线程池的大小还是可以超过预先设置的最大值。</p> 
 <p><strong>3、应用程序服务器 &gt; server1 &gt;ORB 服务</strong> </p> 
 <p> 在EJB1.1规范中，要求远程方法一律使用参数值传递方式来调用，如果调用EJB的Servlet或者其它EJB是部署在同一个应用服务器下，那么它们 是共享一个JVM的，也就是说可以使得函数调用的方式变为参数引用传递，这样的话，视参数对象的复杂程度而定，可以提高5%-50%的函数调用效率。我们 可以通过点击 “按引用传送” 选项来调整ORB的参数传递方式。</p> 
 <p><strong>4、应用程序服务器 &gt; server1 &gt;Web 容器-&gt;定制属性</strong> </p> 
 <p> <strong>MaxKeepAliveConnections</strong> ：表示系统同时保存的最大连接个数，超过这一个数时最近最少被使用的连接将被关闭, 整型，缺省值是：300；</p> 
 <p> <strong>MaxKeepAliveRequests</strong> ：客户端请求被保持到一个请求队列，此属性用于决定请求队列可保持的最大客户端请求数，整型，缺省值是：100；</p> 
 <p><strong>5、应用程序服务器 &gt; server1 &gt;进程定义 &gt;Java 虚拟机-&gt;初始堆大小</strong> </p> 
 <p> Java 虚拟机（JVM）堆大小设置将影响 Java 对象的无用数据收集。堆设置过大，会占用过多的内存，使内存资源耗尽，从而会频繁的进行I/O操作来使用虚拟内存。堆设置过小，会使得对象可分配空间变小，从而会频繁的使用垃圾收集机制来释放内存空间，而每次垃圾收集，都会耗用一定的系统资源。请考虑：    </p> 
 <p> (1)选定应用程序服务器的 JVM 堆是否与同一机器上的其它应用程序服务器 JVM 堆共享物理内存。例如，您是以本地方式还是以远程方式运行监视器？</p> 
 <p> (2)指定 JVM 堆驻留在物理内存中并防止交换到磁盘。    </p> 
 <p> (3)将起始 JVM 堆大小设置为最大 JVM 堆大小的 1/4。    </p> 
 <p> (4)如果机器上只有一个应用程序服务器，则将最大 JVM 堆大小设置为以下值：    </p> 
 <p> 128 MB（内存小于 1 GB 的系统）    </p> 
 <p> 256 MB（内存 1 - 2 GB 的系统）    </p> 
 <p> 512 MB（内存大于 2 GB 的系统）</p> 
 <p><strong>6、JDBC</strong> <strong>提供程序 &gt; Sybase JDBC Driver &gt;数据源 &gt; 语句高速缓存大小</strong> </p> 
 <p>将预备语句高速缓存大小设置为等于已配置数据源连接最大数目。</p> 
 <p><strong>7、JDBC</strong> <strong>提供程序 &gt; Sybase JDBC Driver &gt;数据源 &gt; 连接池</strong> </p> 
 <p> <strong>最小连接数：</strong> 连接池保持的最小备用物理连接数。当连接池中的备用物理连接被分配给客户请求后，连接池中的备用物理连接的实际数量小于此数时，应用服务器将建立新的物理连接到连接池中备用。</p> 
 <p> <strong>最大连接数：</strong> 连接池保持的最大备用物理连接数。当应用程序完成对连接的操作，应用程序所使用的物理连接被返回到连接池中作为备用连接，当连接池中的实际备用物理连接的实际数量大于此数时，应用服务器将关闭此物理连接。</p> 
 <p><strong>8、资源 -&gt; WebSphere JMS 提供程序-&gt;WebSphere 队列连接工厂-&gt;点击所创建的工厂-&gt;配置-&gt;连接池</strong> </p> 
 <p>JMS 应用程序通过“队列连接工厂”创建队列连接来与 JMS 提供程序通信。WebSphere Application Server 对这些连接进行池化以提高 JMS 应用程序的性能。连接池避免了与消息传递中间件连接（以及后面的断开连接）时的性能开销。</p> 
 <p>当应用程序调用 QueueConnectionFactory.createQueueConnection() 时，应用服务器将检查连接池中是否有连接到工厂使用的队列管理器的空闲连接可用。如果发现空闲连接，则将其标记为 in use 并返回给应用程序。如果池中所有连接都在使用中，或者 createQueueConnection() 方法首次在连接工厂上调用，则会创建一个新的连接并返回给应用程序。连接池将维护此新连接的引用，并将其标记为“in use”。</p> 
 <p>如果池中总连接数达到最大，则 QueueConnectionFactory.createQueueConnection() 方法将等待“in use”连接变为可用。对于这种情况，该方法等待连接的最大等待时间是由连接池的连接超时属性指定的</p> 
 <p><strong>9、资源 -&gt; WebSphere JMS 提供程序-&gt;WebSphere 队列连接工厂-&gt;点击所创建的工厂-&gt;配置-&gt;会话池</strong> </p> 
 <p>队列会话是使用 QueueConnection.createQueueSession() 方法从队列连接创建的。为了提高性能，这些会话也维护在一个池中（会话池）。</p> 
 <p> 每个队列连接都有一个与之相关联的会话池。这意味着，如果在连接池中最多有两个连接，在会话池中最多有四个会话，则对于此队列连接工厂可以有多达八个会话；也意味着，对于此队列连接工厂，每个连接最多只有四个会话。</p> 
 <p>二、具体参数设置</p> 
 <p>省略！</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1897ae6371d964e15d81599775959364/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库设计 - 设计表和字段</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/414429860eb8a6e510adc349c11ffe59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java中foreach 用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>