<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Weblogic安全漫谈(一) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Weblogic安全漫谈(一)" />
<meta property="og:description" content="前言 @frohoff在2015年初发现commons-collections的反序列化利用链并发布了ysoserial工具[1]。9个月后，@breenmachine对众多知名Java中间件的利用文章[2]使Java反序列化漏洞变得广为人知，Weblogic中首当其冲的就是大家多少都有点耳熟的T3协议反序列化。本篇从CVE-2015-4852入手了解T3协议的构造，作为后续T3反序列化漏洞学习和利用的基础。
环境搭建与补丁定位 Weblogic官网提供无补丁的初始版本下载[3]，为了方便后续调试分析可以先把几个大版本的安装包（Generic）、以及某些有较大安全特性变化的JDK准备好。
官方只为付费帐户提供安全补丁的下载权限，但普通账户在高级搜索页面[4]列出对应版本的补丁号与发布时间，结合官方安全公告页的CVE发布时间[5]，基本可以让CVE对应上Patch。
有了Patch号可以通过CSDN&#43;某宝积分或者某鱼卖家等等方式下到补丁，Patch详情页里可以看到哈希，有官方原版zip洁癖的同学也可以对一下。
环境搭建时，用WeblogicEnvironment[6]构建不同JDK与Weblogic版本的docker镜像会比较方便，后续也能用容器区分不同的补丁版本。运行前需要参考issues/8改一下Dockerfile，另外就是根据个人需要做适当调整了，比如Weblogic开启的远程调试端口默认为8453（对应IDEA默认的5005）、调整JDK版本等等。
CVE-2015-4852 《攻击JavaRMI概述》[7]中说过JavaRMI机制基于JRMP协议通信，Weblogic有一个与JRMP同类的应用层协议就是T3。T3协议用在Weblogic的这类商用产品当中，协议实现并不开源且没有文档，小编主要靠连蒙带猜和逆向去管中窥豹。
/u01/app/oracle/Domains/ExampleSilentWTDomain/bin/stopWebLogic.sh用到了T3协议去停掉Weblogic，在执行前挂上tcpdump -i any -w t3-stop.pcap抓一下数据包。
Java原生序列化流通过十六进制为ac ed 00 05的字节作为开头的标识（黑话管它叫做魔术字节），ysoserial也正是通过原生序列化生成的payload，自然能简单粗暴地想到是不是直接替换就行了，那么要替换掉哪些部分呢？能看出先进行了第一次通信，请求和响应都是可读的ASCII字符，后续的的请求中似乎也没有用到响应的内容。
把第二次请求字节流扒下来反序列化并处理异常后可以发现存在五个Object，因为WebServer每个请求通常会起一个新的线程来处理，不用担心像内核Pwn一样没处理好异常整个系统蹦掉，那么从第一处魔术字节开始替换为payload，后续部分抛掉不管必然会报错，但问题不大，将原本第二次请求的A &#43; Serial &#43; B &#43; Serial &#43; ...改成A &#43; Payload。
构造如下脚本用作发送payload的客户端，它好比航天发射场组装火箭后打出去，payload就是火箭里用于开展科学实验的载荷。
那么问题来了，首先是为什么要先经过第一次通信交互（t3Bootstrap）。我们大家都知道在黑盒打不通的时候通常都是打不通的，对此小编也感到很惊讶，将payload硬莽过去只会得不到响应。这就如同需要用火箭将实验载荷送到预定轨道一样。
第二个问题是payload前加上的那些字节数据是干嘛的，即火箭为什么要设计构建成这样？自然是为了让载荷顺利进入预定轨道。相信有的同学想喷我了，这里看似相互解释了实则什么都没解释，如果前面还能从没响应的现象下手企图蒙混过关，但这里不啃代码是圆不过去了。
我知道你很急，但你先别急。我们先来看看稍微简单一点的第三个问题，即payload用什么？要使用ysoserial生成的CC链就需要看目标环境有没有相应依赖，快速但不准确的方法是直接找有没有Jar包。
# find /u01/ -name &#34;*commons*collections*.jar&#34; /u01/app/oracle/middleware/modules/com.bea.core.apache.commons.collections_3.2.0.jar 为了更精确定位则可以采用META-INF等信息判断版本、运行时相应上下文能否调到关键类等等方法。
如此我们便能利用这个祖师爷漏洞，对着周朝出土的Weblogic一顿RCE了：
java -jar ysoserial.jar CommonsCollections6 &#34;touch /tmp/pwned&#34; &gt; /tmp/poc.ser python3 t3client.py 127.0.0.1 7001 /tmp/poc.ser # ls -al /tmp/ | grep &#39;pwned&#39; -rw-r----- 1 root root 0 Feb 17 17:18 pwned 逆向T3协议头 猜测关键词暴力搜索后，找到第一次交互时响应数据的来源。下断点得到调用栈：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/42e36fbbe47c8186f4f1b4db5bf1290b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T10:45:56+08:00" />
<meta property="article:modified_time" content="2024-01-02T10:45:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Weblogic安全漫谈(一)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>@frohoff在2015年初发现<span style="color:#be191c;"><code><span style="background-color:#cccccc;">commons-collections</span></code></span>的反序列化利用链并发布了<span style="color:#be191c;"><code><span style="background-color:#cccccc;">ysoserial</span></code></span>工具[1]。9个月后，@breenmachine对众多知名Java中间件的利用文章[2]使Java反序列化漏洞变得广为人知，Weblogic中首当其冲的就是大家多少都有点耳熟的T3协议反序列化。本篇从CVE-2015-4852入手了解T3协议的构造，作为后续T3反序列化漏洞学习和利用的基础。</p> 
<h3 style="background-color:transparent;">环境搭建与补丁定位</h3> 
<p>Weblogic官网提供无补丁的初始版本下载[3]，为了方便后续调试分析可以先把几个大版本的安装包（Generic）、以及某些有较大安全特性变化的JDK准备好。</p> 
<p>官方只为付费帐户提供安全补丁的下载权限，但普通账户在高级搜索页面[4]列出对应版本的补丁号与发布时间，结合官方安全公告页的CVE发布时间[5]，基本可以让CVE对应上Patch。</p> 
<p><img alt="" height="989" src="https://images2.imgbox.com/f5/1a/1OmqXIJk_o.png" width="1080"></p> 
<p>有了Patch号可以通过CSDN+某宝积分或者某鱼卖家等等方式下到补丁，Patch详情页里可以看到哈希，有官方原版zip洁癖的同学也可以对一下。</p> 
<p>环境搭建时，用WeblogicEnvironment[6]构建不同JDK与Weblogic版本的docker镜像会比较方便，后续也能用容器区分不同的补丁版本。运行前需要参考<span style="color:#be191c;"><code><span style="background-color:#cccccc;">issues/8</span></code></span>改一下Dockerfile，另外就是根据个人需要做适当调整了，比如Weblogic开启的远程调试端口默认为8453（对应IDEA默认的5005）、调整JDK版本等等。</p> 
<h3>CVE-2015-4852</h3> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxMjI3MDgwOA==&amp;mid=2247484014&amp;idx=1&amp;sn=deac4e024f485d9b0265671056e73ad9&amp;chksm=c10e36d9f679bfcf7b85bc5c531e9d1bdc722d680fa8e41fa3248f1b694bbb8f2b9a41747dc0&amp;scene=21#wechat_redirect" rel="nofollow" title="《攻击JavaRMI概述》">《攻击JavaRMI概述》</a>[7]中说过JavaRMI机制基于JRMP协议通信，Weblogic有一个与JRMP同类的应用层协议就是T3。T3协议用在Weblogic的这类商用产品当中，协议实现并不开源且没有文档，小编主要靠连蒙带猜和逆向去管中窥豹。</p> 
<p><span style="color:#be191c;"><code><span style="background-color:#cccccc;">/u01/app/oracle/Domains/ExampleSilentWTDomain/bin/stopWebLogic.sh</span></code></span>用到了T3协议去停掉Weblogic，在执行前挂上<span style="color:#be191c;"><code><span style="background-color:#cccccc;">tcpdump -i any -w t3-stop.pcap</span></code></span>抓一下数据包。</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/34/ab/5A7UJeSX_o.png" width="1080"></p> 
<p>Java原生序列化流通过十六进制为<span style="color:#be191c;"><code><span style="background-color:#cccccc;">ac ed 00 05</span></code></span>的字节作为开头的标识（黑话管它叫做魔术字节），<span style="color:#be191c;"><code><span style="background-color:#cccccc;">ysoserial</span></code></span>也正是通过原生序列化生成的payload，自然能简单粗暴地想到是不是直接替换就行了，那么要替换掉哪些部分呢？能看出先进行了第一次通信，请求和响应都是可读的ASCII字符，后续的的请求中似乎也没有用到响应的内容。</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/b9/76/ZEKPFsyV_o.png" width="1080"></p> 
<p>把第二次请求字节流扒下来反序列化并处理异常后可以发现存在五个Object，因为WebServer每个请求通常会起一个新的线程来处理，不用担心像内核Pwn一样没处理好异常整个系统蹦掉，那么从第一处魔术字节开始替换为payload，后续部分抛掉不管必然会报错，但问题不大，将原本第二次请求的<span style="color:#be191c;"><code><span style="background-color:#cccccc;">A + Serial + B + Serial + ...</span></code></span>改成<span style="color:#be191c;"><code><span style="background-color:#cccccc;">A + Payload</span></code></span>。</p> 
<p>构造如下脚本用作发送payload的客户端，它好比航天发射场组装火箭后打出去，payload就是火箭里用于开展科学实验的载荷。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b5/94/bcFTwCHY_o.png" width="1080"></p> 
<p>那么问题来了，首先是为什么要先经过第一次通信交互（t3Bootstrap）。我们大家都知道在黑盒打不通的时候通常都是打不通的，对此小编也感到很惊讶，将payload硬莽过去只会得不到响应。这就如同需要用火箭将实验载荷送到预定轨道一样。</p> 
<p>第二个问题是payload前加上的那些字节数据是干嘛的，即火箭为什么要设计构建成这样？自然是为了让载荷顺利进入预定轨道。相信有的同学想喷我了，这里看似相互解释了实则什么都没解释，如果前面还能从没响应的现象下手企图蒙混过关，但这里不啃代码是圆不过去了。</p> 
<p>我知道你很急，但你先别急。我们先来看看稍微简单一点的第三个问题，即payload用什么？要使用<span style="color:#be191c;"><code><span style="background-color:#cccccc;">ysoserial</span></code></span>生成的CC链就需要看目标环境有没有相应依赖，快速但不准确的方法是直接找有没有Jar包。</p> 
<pre><code class="hljs"># find /u01/ -name "*commons*collections*.jar"
/u01/app/oracle/middleware/modules/com.bea.core.apache.commons.collections_3.2.0.jar</code></pre> 
<ul><li> <p>为了更精确定位则可以采用META-INF等信息判断版本、运行时相应上下文能否调到关键类等等方法。</p> </li></ul> 
<p>如此我们便能利用这个祖师爷漏洞，对着周朝出土的Weblogic一顿RCE了：</p> 
<pre><code class="hljs">java -jar ysoserial.jar CommonsCollections6 "touch /tmp/pwned" &gt; /tmp/poc.ser

python3 t3client.py 127.0.0.1 7001 /tmp/poc.ser

# ls -al /tmp/ | grep 'pwned'
-rw-r----- 1 root root    0 Feb 17 17:18 pwned</code></pre> 
<h3>逆向T3协议头</h3> 
<p></p> 
<p class="img-center"><img alt="图片" height="505" src="https://images2.imgbox.com/08/b1/wmvIZQMU_o.png" width="1080"></p> 
<p>猜测关键词暴力搜索后，找到第一次交互时响应数据的来源。下断点得到调用栈：</p> 
<pre><code class="hljs">connectReplyOK:160, Login (weblogic.socket)
readBootstrapMessage:189, MuxableSocketT3 (weblogic.rjvm.t3)
dispatch:323, MuxableSocketT3 (weblogic.rjvm.t3)
dispatch:394, BaseAbstractMuxableSocket (weblogic.socket)
dispatch:185, MuxableSocketDiscriminator (weblogic.socket)
readReadySocketOnce:960, SocketMuxer (weblogic.socket)
readReadySocket:897, SocketMuxer (weblogic.socket)
processSockets:130, PosixSocketMuxer (weblogic.socket)
run:29, SocketReaderRequest (weblogic.socket)
execute:42, SocketReaderRequest (weblogic.socket)
execute:145, ExecuteThread (weblogic.kernel)
run:117, ExecuteThread (weblogic.kernel)</code></pre> 
<p> <img alt="" height="602" src="https://images2.imgbox.com/c8/3f/tGsZXZBW_o.png" width="1080"></p> 
<p> <span style="color:#be191c;"><code><span style="background-color:#cccccc;">MuxableSocketT3#dispatch</span></code></span>方法根据<span style="color:#be191c;"><code><span style="background-color:#cccccc;">bootstrapped</span></code></span>来判断连接是否经<span style="color:#be191c;"><code><span style="background-color:#cccccc;">readBootstrapMessage</span></code></span>方法初始化过，解析提取的就是上文首次通信时发给服务端的数据。（这是10.3.6.0的位置，12.2.1.3在<span style="color:#be191c;"><code><span style="background-color:#cccccc;">com.oracle.weblogic.rjvm.jar</span></code></span>中<span style="color:#be191c;"><code><span style="background-color:#cccccc;">weblogic/rjvm/t3/MuxableSocketT3#readIncomingConnectionBootstrapMessage</span></code><span style="background-color:#cccccc;">）</span></span>。</p> 
<p> <img alt="" height="531" src="https://images2.imgbox.com/b3/bc/pDrpIima_o.png" width="1080"></p> 
<p><span style="color:#be191c;"><code><span style="background-color:#cccccc;">MuxableSocketDiscriminator#dispatch</span></code></span>方法根据协议名将请求分配给HTTP、T3等不同处理类，以此实现端口复用。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="531" src="https://images2.imgbox.com/5c/d3/JKBTCgmG_o.png" width="1080"></p> 
<p>再将断点下在<span style="color:#be191c;"><code><span style="background-color:#cccccc;">ObjectInputStream#readObject</span></code></span>并得到第二次请求时的调用栈：</p> 
<pre><code class="hljs">readObject0:1327, ObjectInputStream (java.io)
readObject:349, ObjectInputStream (java.io)
readObject:67, InboundMsgAbbrev (weblogic.rjvm)
read:39, InboundMsgAbbrev (weblogic.rjvm)
readMsgAbbrevs:283, MsgAbbrevJVMConnection (weblogic.rjvm)
init:215, MsgAbbrevInputStream (weblogic.rjvm)
dispatch:498, MsgAbbrevJVMConnection (weblogic.rjvm)
dispatch:330, MuxableSocketT3 (weblogic.rjvm.t3)
dispatch:394, BaseAbstractMuxableSocket (weblogic.socket)
readReadySocketOnce:960, SocketMuxer (weblogic.socket)
readReadySocket:897, SocketMuxer (weblogic.socket)
processSockets:130, PosixSocketMuxer (weblogic.socket)
run:29, SocketReaderRequest (weblogic.socket)
execute:42, SocketReaderRequest (weblogic.socket)
execute:145, ExecuteThread (weblogic.kernel)
run:117, ExecuteThread (weblogic.kernel)</code></pre> 
<p><img alt="" height="556" src="https://images2.imgbox.com/a4/1a/M9uMMtdH_o.png" width="1080"></p> 
<p>数据由<span style="color:#be191c;"><code><span style="background-color:#cccccc;">MsgAbbrevInputStream#init</span></code></span>调用各个方法解析。先看<span style="color:#be191c;"><code><span style="background-color:#cccccc;">super.init(chunk, 4)</span></code></span>，最终前4字节被skip掉：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="340" src="https://images2.imgbox.com/4f/54/hyUkHCyO_o.png" width="1080"></p> 
<p>这4个字节其实就是EXP中的<span style="color:#be191c;"><code><span style="background-color:#cccccc;">chunkLength</span></code></span>，表示包括自己在内的这段<span style="color:#be191c;"><code><span style="background-color:#cccccc;">Header</span></code></span>的字节长度，可以偷懒直接赋0。</p> 
<p>继续看到<span style="color:#be191c;"><code><span style="background-color:#cccccc;">readHeader</span></code></span>方法中存在大量标识数据：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="742" src="https://images2.imgbox.com/56/1f/eHXYsgRI_o.png" width="1080"></p> 
<p><span style="color:#be191c;"><code><span style="background-color:#cccccc;">cmd</span></code></span>字节应该是指代通信类型，可以从<span style="color:#be191c;"><code><span style="background-color:#cccccc;">weblogic/rjvm/JVMMessage</span></code></span>类中的变量名看出：</p> 
<pre><code> static final byte CMD_UNDEFINED = 0;
    static final byte CMD_IDENTIFY_REQUEST = 1;
    static final byte CMD_IDENTIFY_RESPONSE = 2;
    static final byte CMD_REQUEST_CLOSE = 11;
    static final byte CMD_IDENTIFY_REQUEST_CSHARP = 12;
    static final byte CMD_IDENTIFY_RESPONSE_CSHARP = 13;
    static final byte CMD_NO_ROUTE_IDENTIFY_REQUEST = 9;
    static final byte CMD_TRANSLATED_IDENTIFY_RESPONSE = 10;
    static final byte CMD_PEER_GONE = 3;
    static final byte CMD_ONE_WAY = 4;
    static final byte CMD_REQUEST = 5;
    static final byte CMD_RESPONSE = 6;
    static final byte CMD_ERROR_RESPONSE = 7;
    static final byte CMD_INTERNAL = 8;</code></pre> 
<p>没猜到<span style="color:#be191c;"><code><span style="background-color:#cccccc;">QOS</span></code></span>字节的含义，类初始化时被赋为十进制<span style="color:#be191c;"><code><span style="background-color:#cccccc;">101</span></code></span>，所以EXP同样用了这个值。</p> 
<p><span style="color:#be191c;"><code><span style="background-color:#cccccc;">flags</span></code></span>字节从后面<span style="color:#be191c;"><code><span style="background-color:#cccccc;">getFlag</span></code></span>方法可以看出用来从二进制位控制<span style="color:#be191c;"><code><span style="background-color:#cccccc;">hasJVMIDs</span></code><span style="background-color:#cccccc;">、</span><code><span style="background-color:#cccccc;">hasTX</span></code><span style="background-color:#cccccc;">、</span><code><span style="background-color:#cccccc;">hasTrace</span></code></span>（类比Linux的rwx权限与777）。</p> 
<p><span style="color:#be191c;"><code><span style="background-color:#cccccc;">responseId</span></code></span>字节用于标识通信顺序、<span style="color:#be191c;"><code><span style="background-color:#cccccc;">invokeableId</span></code></span>字节用于标识被调用的方法，目前用不到置为初始值-1。</p> 
<p><span style="color:#be191c;"><code><span style="background-color:#cccccc;">abbrevOffset</span></code></span>字节顾名思义是abbrev的偏移长度，表示<span style="color:#be191c;"><code><span style="background-color:#cccccc;">Header</span></code></span>结尾处 相距 后面字节流<span style="color:#be191c;"><code><span style="background-color:#cccccc;">MsgAbbrevs</span></code></span>部分的距离，在<span style="color:#be191c;"><code><span style="background-color:#cccccc;">init</span></code></span>方法中会被skip掉，EXP中直接赋0表示没有额外的数据需要跳过。</p> 
<p>读完<span style="color:#be191c;"><code><span style="background-color:#cccccc;">Header</span></code></span>部分继续进入到<span style="color:#be191c;"><code><span style="background-color:#cccccc;">readMsgAbbrevs</span></code></span>方法中，会调用<span style="color:#be191c;"><code><span style="background-color:#cccccc;">InboundMsgAbbrev#read</span></code></span>方法：</p> 
<p><img alt="" height="489" src="https://images2.imgbox.com/a2/fd/SmEIFhGi_o.png" width="1080"></p> 
<p><span style="color:#be191c;"><code><span style="background-color:#cccccc;">length</span></code></span>就是EXP中的<span style="color:#be191c;"><code><span style="background-color:#cccccc;">countLength</span></code></span>，可以看到这个值对应for循环的次数。</p> 
<p><span style="color:#be191c;"><code><span style="background-color:#cccccc;">length2</span></code></span>就是EXP中的<span style="color:#be191c;"><code><span style="background-color:#cccccc;">capacityLength</span></code><span style="background-color:#cccccc;">，</span><code><span style="background-color:#cccccc;">bubblingAbbrever.getCapacity()</span></code></span>拿到的就是第一次请求中的<span style="color:#be191c;"><code><span style="background-color:#cccccc;">AS</span></code></span>，要设置得比它大才会进入<span style="color:#be191c;"><code><span style="background-color:#cccccc;">readObeject</span></code></span>分支。</p> 
<p>最后进入重写的有参<span style="color:#be191c;"><code><span style="background-color:#cccccc;">readObject</span></code></span>中，<span style="color:#be191c;"><code><span style="background-color:#cccccc;">msgAbbrevInputStream.read()</span></code></span>读到的字节是十进制0时进入无参<span style="color:#be191c;"><code><span style="background-color:#cccccc;">readObject</span></code></span>。但<span style="color:#be191c;"><code><span style="background-color:#cccccc;">ServerChannelInputStream</span></code></span>没有重写无参<span style="color:#be191c;"><code><span style="background-color:#cccccc;">readObject</span></code></span>，所以最终进到父类<span style="color:#be191c;"><code><span style="background-color:#cccccc;">ObjectInputStream</span></code></span>的<span style="color:#be191c;"><code><span style="background-color:#cccccc;">readObject</span></code></span>衔接上CC链。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c45734a97b948fbeb0c90ac96c293eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">window.history.go(-1)回退未刷新问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/32d8d9f18af9135d27375a71bb5104a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分布式【Zookeeper ZAB协议】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>