<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 8.0网络DNS - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 8.0网络DNS" />
<meta property="og:description" content="1 Linux DNS规范
Linux上并没有一个单独的方法可以完成DNS查询工作；没有一个有这样的明确接口的核心系统调用system call。不过，glibc (nss)的getaddrinfo (3), gethostbyname (3)等相关API (RFC3493)提供了DNS查询功能。
1）不支持nscd（name service cache daemon）服务，那么这2个函数接口通过文件/etc/resolv.conf获取DNS服务器的IP地址，然后通过socket通信发送请求到该DNS IP地址去获取待查询域名的IP地址。
2）支持nscd服务（or dnsmasq），这2个函数接口发送请求给nscd，nscd再返回响应给请求者。
3）ping uses glibc gethostbyname()。
2 Android netd DNS
2.1 Android 4.3 DNS
Android 4.3 incorporated a somewhat confusing series of commits under the heading of &#34;dns cache per interface,&#34; which effectively causes all Bionic DNS requests to be proxied through netd.
ANDROID_DNS_MODE=local
dumpsys connectivity
dumpsys netd
ndc tether dns set
ndc tether dns list" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/40b092db3a4b5a58b0e4cebb1775f515/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-01T15:10:28+08:00" />
<meta property="article:modified_time" content="2022-12-01T15:10:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 8.0网络DNS</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1 Linux DNS规范<br> Linux上并没有一个单独的方法可以完成DNS查询工作；没有一个有这样的明确接口的核心系统调用system call。不过，glibc (nss)的getaddrinfo (3), gethostbyname (3)等相关API (RFC3493)提供了DNS查询功能。<br> 1）不支持nscd（name service cache daemon）服务，那么这2个函数接口通过文件/etc/resolv.conf获取DNS服务器的IP地址，然后通过socket通信发送请求到该DNS IP地址去获取待查询域名的IP地址。<br> 2）支持nscd服务（or dnsmasq），这2个函数接口发送请求给nscd，nscd再返回响应给请求者。<br> 3）ping uses glibc gethostbyname()。<br><br> 2 Android netd DNS<br> 2.1 Android 4.3 DNS<br> Android 4.3 incorporated a somewhat confusing series of commits under the heading of "dns cache per interface," which effectively causes all Bionic DNS requests to be proxied through netd.<br><br> ANDROID_DNS_MODE=local<br> dumpsys connectivity<br> dumpsys netd<br> ndc tether dns set<br> ndc tether dns list<br><br> iptables -t nat -I OUTPUT -p udp \<br> --dport 53 -j DNAT \<br> --to-destination 192.168.1.5:53<br> iptables -t nat -I OUTPUT -p tcp \<br> --dport 53 -j DNAT \<br> --to-destination 192.168.1.5:53<br><br> This works by intercepting the DNS requests meant for the remote nameserver and redirecting it to the local DNS server. <br><br> 2.2 Android netd DNS<br> libcore/ojluni/src/main/java/java/net/InetAddress.java<br> netd中dns server设置文件：ResolverController.cpp<br> netd中域名解析文件：DnsProxyListener.cpp<br><br> Figure 2-1 Android netd DNS</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/40/bd/66RIUxSv_o.jpg"></p> 
<p>2.3 libc DNS解析函数<br> Android bionic: based on OpenBSD, b means BSD<br> bionic/libc/dns/net/getaddrinfo.c<br> getaddrinfo(): IPv4 and IPv6<br> bionic/libc/dns/net/getnameinfo.c<br> getnameinfo()<br> bionic/libc/dns/net/gethnamaddr.c<br> gethostbyname(): only IPv4, gethostbyname_r(), r means reentry<br><br> 通过netd获取DNS服务器的IP地址（Ubuntu通过进程dnsmasq和配置文件/etc/resolv.conf），然后构建DNS请求包，查询域名对应的IP地址，并且按照netId的分类缓存到netd中：<br> bionic/libc/dns/net/gethnamaddr.c<br> gethostbyname_internal_real()<br><br> 2.4 Android三个网络基础库DNS解析<br> 1) JDK HttpURLConnection<br> 2) Apache HttpClient，Android 6.0之后不再支持HttpClient<br> 3) OkHttp, third-party library<br><br> 以上3个类库都会调用下面的JDK函数<br> InetAddress.getByName()<br> getaddrinfo() - libc DNS parser API<br><br> 2.5 DHCP<br> DHCP Offer报文Options中包含了DNS Server地址<br><br> Android GB system/core/libnetutils/dhcp_utils.c<br> int dhcp_do_request(...,<br> in_addr_t *dns1, in_addr_t *dns2...)<br><br> 3 Android netId<br> 3.1 获取网络接口的netId<br> netd中将接口名（wlan0、eth0等）转化为netId的函数：<br> server/NetworkController.cpp<br> NetworkController::getNetworkForInterface(<br> const char* interface)<br><br> 3.2 代码示例<br> server/CommandListener.cpp<br> 函数CommandListener::NetworkCommand::runCommand()的最后添加如下的代码：<br> //     0            1                2<br> // network query_netid if_name<br> if (!strcmp(argv[1], "query_netid")) {<!-- --><br>     if (argc &lt; 3) {<!-- --><br>         return syntaxError(client,<br>             "Missing argument");<br>     }<br>     int _netId =<br>         gCtls-&gt;netCtrl.getNetworkForInterface(<br>             argv[2]);<br>     char msg[16] = {0};<br>     int retval = snprintf(msg, 15, "%d", _netId);<br>     if (retval &gt; 0) {<!-- --><br>         client-&gt;sendMsg(<br>             ResponseCode::CommandOkay,<br>             msg, false);<br>         return 0;<br>     } else {<!-- --><br>         return operationError(client,<br>             "Can not get netId", retval);<br>     }<br> }<br> 用法：ndc network query_netid wlan0<br><br> 4 ndc<br> 4.1 查询可用命令表<br> ndc interface list<br><br> 4.2 清除netd DNS缓存<br> ndc resolver flushif eth0<br> ndc resolver flushdefaultif -- flush default DNS resolver<br><br> Android 8.0没有导出刷新DNS缓存的接口，可以调用如下API添加。<br> bionic/libc/dns/resolv/res_cache.c<br> _resolv_flush_cache_for_net(netId)<br><br> 4.3 设置netd DNS<br> ndc resolver setnetdns &lt;netid&gt; &lt;domain&gt; &lt;dns1&gt; &lt;dns2&gt; ...<br> ndc resolver setnetdns eth0 "" 8.8.8.8 192.168.1.1<br> ndc resolver setnetdns eth0 localdomain 8.8.8.8 192.168.1.1<br><br> 5 Abbreviations<br> dnsmasq: DNS masquerade<br> mdnsd: multicast DNS，组播DNS<br> ndc：Native Daemon Connector<br> ojluni：Android libcore中的模块，包含OpenJDK、Language、Util、Net、IO</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bdd691ec47b24ce8ccff4e91ef1552c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言学习之原码、反码、补码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4319850c543fde98dceb46a1cf6cbc69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DMA简单理解和分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>