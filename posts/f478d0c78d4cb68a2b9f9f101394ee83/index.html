<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue3使用拖拽组件draggable-next的使用教程【保姆级】 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue3使用拖拽组件draggable-next的使用教程【保姆级】" />
<meta property="og:description" content="环境：vue3&#43;setup语法
首先放官方文档的链接：
中文版本： vue.draggable.next 中文文档 - itxst.com （民间翻译）
英文版本：GitHub - SortableJS/vue.draggable.next: Vue 3 compatible drag-and-drop component based on Sortable.js
因为自己写的过程中，官方文档和网上的资料都非常不明，使用版本各不相同，极易踩坑，自己写完后就总结一下，与诸位共勉。
（一）首先，明确需求： 做一个可重复拖拽生成的表格设计器，效果图如下：
（二）搭一个基本的可互相拖拽的框架 （1）在终端使用npm命令下载插件
npm i -S vuedraggable@next //导入 import draggable from &#39;vuedraggable&#39; （2）拖拽插件大致可分为两种使用方式——分组拖拽与单组拖拽
单组拖拽为只有一组数据，而拖拽是交换此组数据内部的位置，如下图所示：
而互相拖拽是有两组数据，两组数据可以各自内部换顺序，可以相互拖拽到对方的数组中。
本文需求只用到了互相拖拽，互相拖拽的代码形式如下：
//需要克隆的数据，A组 &lt;draggable :list=&#34;dragList&#34; ghost-class=&#34;ghost&#34; :force-fallback=&#34;true&#34; :group=&#34;{ name: &#39;list&#39;, pull: &#39;clone&#39; }&#34; :sort=&#34;false&#34; itemKey=&#34;id&#34;&gt; &lt;template #item=&#34;{ element }&#34;&gt; &lt;div class=&#34;item move&#34;&gt; &lt;label class=&#34;move&#34;&gt;{{ element.name }}&lt;/label&gt; &lt;/div&gt; &lt;/template&gt; &lt;/draggable&gt; //拖拽的结果，B组 &lt;draggable :list=&#34;widgetList&#34; ghost-class=&#34;ghost&#34; itemKey=&#34;id&#34; :force-fallback=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f478d0c78d4cb68a2b9f9f101394ee83/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-07T17:35:31+08:00" />
<meta property="article:modified_time" content="2023-06-07T17:35:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue3使用拖拽组件draggable-next的使用教程【保姆级】</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>环境：<a href="https://so.csdn.net/so/search?q=vue3&amp;spm=1001.2101.3001.7020" title="vue3">vue3</a>+setup语法</p> 
<p>首先放官方文档的链接：</p> 
<p>中文版本： <a href="https://www.itxst.com/vue-draggable-next/tutorial.html" rel="nofollow" title="vue.draggable.next 中文文档 - itxst.com">vue.draggable.next 中文文档 - itxst.com</a> （民间翻译）</p> 
<p>英文版本：<a href="https://github.com/SortableJS/vue.draggable.next" title="GitHub - SortableJS/vue.draggable.next: Vue 3 compatible drag-and-drop component based on Sortable.js">GitHub - SortableJS/vue.draggable.next: Vue 3 compatible drag-and-drop component based on Sortable.js</a></p> 
<p>因为自己写的过程中，官方文档和网上的资料都非常不明，使用版本各不相同，极易踩坑，自己写完后就总结一下，与诸位共勉。</p> 
<h4><a name="t0"></a>（一）首先，明确需求：</h4> 
<p>做一个可重复拖拽生成的表格设计器，效果图如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/1e/98/C7VfQqtp_o.png"></p> 
<h4><a name="t1"></a>（二）搭一个基本的可互相拖拽的框架</h4> 
<p>（1）在终端使用npm命令下载插件</p> 
<pre><code class="language-javascript">npm i -S vuedraggable@next
 
//导入
import draggable from 'vuedraggable'</code></pre> 
<p>（2）拖拽插件大致可分为两种使用方式——分组拖拽与单组拖拽</p> 
<p>单组拖拽为只有一组数据，而拖拽是交换此组数据内部的位置，如下图所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/d7/35/Uj8g9pGA_o.gif"></p> 
<p>而互相拖拽是有两组数据，两组数据可以各自内部换顺序，可以相互拖拽到对方的数组中。</p> 
<p>本文需求只用到了互相拖拽，互相拖拽的代码形式如下：</p> 
<pre><code class="language-javascript">    //需要克隆的数据，A组
    &lt;draggable :list="dragList" ghost-class="ghost" :force-fallback="true" :group="{ name: 'list', pull: 'clone' }"
      :sort="false" itemKey="id"&gt;
      &lt;template #item="{ element }"&gt;
        &lt;div class="item move"&gt;
          &lt;label class="move"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/draggable&gt;
 
//拖拽的结果，B组
 &lt;draggable :list="widgetList" ghost-class="ghost" itemKey="id" :force-fallback="true" group="list" :fallback-class="true"
    :fallback-on-body="true"&gt;
    &lt;template #item="{ element }"&gt;
      &lt;div class="item move"&gt;
        &lt;label class="move"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/draggable&gt;
 
&lt;script lang="ts" setup&gt;
import draggable from 'vuedraggable'
 
interface type {
  name: string,
  id: number
}
const dragList: type[] = reactive&lt;type[]&gt;([
  { name: "单行文本", id: 1 },
  { name: "多行文本", id: 2 },
  { name: "计数器", id: 3 },
  { name: "单选框组", id: 4 },
])
 
const widgetList = reactive&lt;type[]&gt;([
  { name: "多行文本", id: 2 },
])</code></pre> 
<p><a href="https://so.csdn.net/so/search?q=draggable&amp;spm=1001.2101.3001.7020" title="draggable">draggable</a>的一些常用的属性我作了整理，方便根据不同的需求取用，可核对表格填写：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> <p>属性</p> </td><td> <p>说明</p> </td><td> <p>类型</p> </td><td> <p>是否必填</p> </td></tr><tr><td> <p>group</p> </td><td> <p>如果是分组拖拽，可通过设置group的name来实现分类。</p> <p>pull属性代表拖出，put为拖入，</p> <p>:group="{ name :'list',pull : true, put: false }"</p> <p>代表这个分组与其他name为list的分组可实现分组拖拽，此分组允许拖出，不允许拖入，pull为‘clone’则代表clone模式，pull与put可写可不写，默认值都为true</p> </td><td> <p>Object / string</p> </td><td> <p>否</p> <p>（分组拖拽时必填）</p> </td></tr><tr><td> <p>list</p> </td><td> <p>绑定的数据</p> </td><td> <p>Array</p> </td><td> <p>是</p> </td></tr><tr><td> <p>sort</p> </td><td> <p>是否开启排序功能，默认为true,如果设置为false,它所在组无法排序</p> </td><td> <p>Boolean</p> </td><td> <p>否</p> </td></tr><tr><td> <p>force-fallback</p> </td><td> <p>默认false，忽略HTML5的拖拽行为，因为h5里有个属性也是可以拖动，你要自定义ghostClass chosenClass dragClass样式时，建议forceFallback设置为true</p> </td><td> <p>Boolean</p> </td><td> <p>否</p> <p>（设置ghost-class或drag-class时为必填）</p> </td></tr><tr><td> <p>ghost-class</p> </td><td> <p>:ghostClass=“ghostClass” 设置拖动元素的占位符类名,可以将拖动时的元素设置为不同的样式。自定义样式可能需要加!important才能生效，并把forceFallback属性设置成true。</p> </td><td> <p>String</p> </td><td> <p>否</p> </td></tr><tr><td> <p>disabled</p> </td><td> <p>是否禁用，默认false</p> </td><td> <p>Boolean</p> </td><td> <p>否</p> </td></tr><tr><td> <p>drag-class</p> </td><td> <p>:drag-class="dragClass"拖动元素的样式，你的自定义样式可能需要加!important才能生效，并把forceFallback属性设置成true</p> </td><td> <p>Boolean</p> </td><td> <p>否</p> </td></tr><tr><td> <p>item-key</p> </td><td> <p>每个元素唯一的标识，建议使用id</p> <p>itemKey='id'，注意，此处无需写成变量形式</p> </td><td> <p>String</p> </td><td> <p>是</p> <p>（不填也能运行，但控制台会报警告）</p> </td></tr></tbody></table> 
<p>到现在为止，这已经是个互相拖拽的组件了。</p> 
<p>（3）如果发现自己写的组件 不能进行拖拽，或者网页上不显示组件 ，或者出现红色报错信息，则检查以下注意点 ：</p> 
<ol><li> <p>group中name是否一致，group为变量，需要 :group =‘{name:'' }’的形式</p> </li><li> <p>AB组的元素要实现互相拖拽，元素的数据结构必须完全一致，如果不放心，可以使用interface来定义一个类型诸如 interface itemType { name : string , id:number }</p> </li><li> <p>AB组绑定的数组是否为响应式，如非<a href="https://so.csdn.net/so/search?q=%E5%93%8D%E5%BA%94%E5%BC%8F&amp;spm=1001.2101.3001.7020" title="响应式">响应式</a>，会发生拖拽成功，但不能及时响应的情况，可以用这个方法自检--&gt;先进行拖拽，然后在代码的html部分随便加个东西，然后保存，观察网页上是否显示刚才拖拽的内容，如果出现，那就是数组非响应式的问题。</p> </li><li> <p>在新版vue3中，item插槽是必写的部分，不能使用v-for循环替代。<br>  </p> <pre><code class="language-html">&lt;draggable&gt;
    &lt;template #item="{ element }"&gt;
        &lt;div class="item move"&gt;
          &lt;label class="move"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
        &lt;/div&gt;
      &lt;/template&gt;
&lt;/draggable&gt;</code></pre> <p></p> </li><li> <p>item插槽中只允许有一个子元素，此处有个坑，就是如果有两个子元素，但注释掉了一个，也会报错。哪怕实际上这只有一个子元素。<br>  </p> <pre><code class="language-html">//正确的  
&lt;template #item="{ element }"&gt;
      &lt;div class="item move"&gt;
        &lt;label class="move"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
      &lt;/div&gt;
 &lt;/template&gt;
 
//会报错的情况！
&lt;template #item="{ element }"&gt;
      &lt;!-- &lt;div class="class"&gt;&lt;/div&gt; --&gt;
      &lt;div class="item move"&gt;
        &lt;label class="move"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
      &lt;/div&gt;
 &lt;/template&gt;</code></pre> <p></p> </li></ol> 
<p>到此为止，已经实现拖拽成功。有些人可能会碰到这个问题————如果B组为空，向B组内拖第一个组件的时候，会出现拖拽困难，只能往拖拽区的最顶部拖才能成功 / 根本无法拖拽成功。</p> 
<p>原因：因为B组的draggable渲染时为一个高度为auto的div，当前组如果为空，高度也为0，可拖拽区就会变得很小或不存在。</p> 
<p>解决方法：为B组的draggable设计高度，具体代码为添加类名，在css中设置</p> 
<pre><code class="language-html">&lt;draggable :list="widgetList" ghost-class="ghost" itemKey="id" :force-fallback="true" group="list" :fallback-class="true"
    :fallback-on-body="true" class="drag-content"&gt;
    &lt;template #item="{ element }"&gt;
      &lt;div class="item move"&gt;
        &lt;label class="move"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/draggable&gt;
 
&lt;style lang="less" scoped&gt;
    .drag-content {
        height:500px; //建议是外层嵌套一层div，div固定高，此处再设为100%
    }
&lt;/style&gt;</code></pre> 
<h4><a name="t2"></a>（三）将拖拽后的内容替换为element组件/其它指定内容</h4> 
<p>我们发现，拖拽后显示的内容可自由定义，在B组的draggable中设置</p> 
<p>此时，我们需要完善dragList的数组结构,来映射拖拽后所形成的不同组件</p> 
<p>（在组件少的情况下可以这么做）</p> 
<pre><code class="language-javascript">interface itemType {
  name: string,
  id: number,
  element:string
}
 
const dragList: type[] = reactive&lt;type[]&gt;([
  { name: "单行文本", id: 1, element: 'Input' },
  { name: "多行文本", id: 2, element: 'Textarea' },
  { name: "计数器", id: 3, element: 'InputNumber' },
  { name: "单选框组", id: 4, element: 'Radio' },
])
 
const widgetList = reactive&lt;type[]&gt;([
 
])</code></pre> 
<pre><code class="language-html">//  A组
&lt;draggable :list="dragList" ghost-class="ghost" :force-fallback="true" :group="{ name: 'list', pull: 'clone' }"
      :sort="false" itemKey="id"&gt;
      &lt;template #item="{ element }"&gt;
        &lt;div class="item move"&gt;
          &lt;label class="move"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/draggable&gt;
 
// B组
    &lt;draggable :list="widgetList" ghost-class="ghost" itemKey="id" :force-fallback="true" group="list"
      :fallback-class="true" :fallback-on-body="true" class="drag-content"&gt;
      &lt;template #item="{ element }"&gt;
        &lt;div class="item move"&gt;
          &lt;label class="move title"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
          &lt;div&gt; &lt;el-input v-model="input" placeholder="Please input" v-if="element.element === 'input'" /&gt;&lt;/div&gt;
          &lt;div&gt;&lt;el-input v-model="textarea" :rows="2" type="textarea" placeholder="Please input"
              v-if="element.element === 'textarea'" /&gt; &lt;/div&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/draggable&gt;</code></pre> 
<p>点击控件拖过去，就可以实现如下的效果，如果不想要标题，可以把label部分去掉，其他控件如法炮制即可：</p> 
<p><img alt="" src="https://images2.imgbox.com/c6/aa/kIY8hBC7_o.png"></p> 
<p>在组件数量少的时候，可以这么做，但数量多时，建议使用component标签来映射</p> 
<p>（1）先更改一下文件的结构</p> 
<p><img alt="" src="https://images2.imgbox.com/fe/12/1HoXQunC_o.png"></p> 
<p>（2）写一个公共的函数去返回当前widgets文件夹下的所有文件</p> 
<pre><code class="language-javascript">// getWidget.ts
 
const gets = {} as any 
const modules = import.meta.glob('./*.vue', {eager:true})
for (let each in modules) {
  const name = (modules[each] as any).default.__name
  gets[name] = (modules[each] as any).default
}
 
console.log(gets);
 
export default gets</code></pre> 
<p>也可使用globEager方法，编译器会报错：函数已经弃用，不过不影响使用。</p> 
<p>（3）分别把每个组件的部分写好</p> 
<p><img alt="" src="https://images2.imgbox.com/f6/8c/43MbosdN_o.png"></p> 
<pre><code class="language-html">// Input.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;el-input v-model="input" placeholder="Please input"  /&gt;
  &lt;/div&gt;
&lt;/template&gt;
  
&lt;script lang="ts" setup&gt;
 
 const input=ref('')
&lt;/script&gt;
 
&lt;style lang="less" scoped&gt;
 
&lt;/style&gt;</code></pre> 
<p>（4）使用component标签映射</p> 
<pre><code class="language-html"> 
    &lt;draggable :list="widgetList" ghost-class="ghost" itemKey="id" :force-fallback="true" group="list"
      :fallback-class="true" :fallback-on-body="true" class="drag-content"&gt;
      &lt;template #item="{ element }"&gt;
 
        &lt;div class="item move"&gt;
          &lt;label class="move title"&gt;{<!-- -->{ element.name }}&lt;/label&gt;
          &lt;div&gt;
            &lt;component :is="getWidget(element.element)"&gt;&lt;/component&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/draggable&gt;
  
 
// 使用函数映射
 
&lt;script lang="ts" setup&gt;
import draggable from 'vuedraggable'
//要注意导入
import getName from './widgets/getWidget'
 
 
const getWidget = (name: string) =&gt; {
//写的时候，组件的起名一定要与dragList中的element名字一模一样，不然会映射不上
  return getName[name]
}</code></pre> 
<p>（5）最终效果</p> 
<p>成功实现！</p> 
<p><img alt="" src="https://images2.imgbox.com/ac/56/u45zZNoM_o.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/411b7fc0cab06a7f3406a21ec8e9e51d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深度学习 项目实战】Keras深度学习多变量时间序列预测的LSTM模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e46f32ab48239ad0a37878395f91f02/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">文件描述符表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>