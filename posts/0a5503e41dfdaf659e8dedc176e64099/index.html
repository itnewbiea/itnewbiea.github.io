<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文通透Text Embedding模型：从text2vec、openai-ada-002到m3e、bge - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文通透Text Embedding模型：从text2vec、openai-ada-002到m3e、bge" />
<meta property="og:description" content="前言 本文已经是今年的第31篇大模型相关的技术文章了，如果说
半年之前写博客，更多是出于个人兴趣 &#43; 读者需要那自我司于23年Q3组建LLM项目团队之后，写博客就成了：个人兴趣 &#43; 读者需要 &#43; 项目需要
如此兼备三者，实在是写博客之幸运矣 我和我司更非常高兴通过博客、课程、内训、项目，与大家共同探讨如何把先进的大模型技术更好、更快的落地到各个行业的业务场景中，赋能千千万万公司的实际业务
而本文一开始是属于：因我司第三项目组「知识库问答项目」而起的此文《知识库问答LangChain&#43;LLM的二次开发：商用时的典型问题及其改进方案》中的1.2节(该1.2节初稿来自我司LLM项目团队第三项目组的bingo)，但为把Text Embedding模型阐述的更为精准、全面，特把那部分的内容抽取出来，不断完善成此文
最终尽可能相比网上已有的其他资料都更细致化
第一部分 衡量文本向量表示效果的榜单：MTEB、C-MTEB 1.2 《MTEB: Massive Text Embedding Benchmark(海量文本嵌入基准)》 判断哪些文本嵌入模型效果较好，通常需要一个评估指标来进行比较，《MTEB: Massive Text Embedding Benchmark(海量文本嵌入基准)》就是一个海量文本嵌入模型的评估基准
论文地址：https://arxiv.org/abs/2210.07316
MTEB包含8个语义向量任务，涵盖58个数据集和112种语言。通过在MTEB上对33个模型进行基准测试，建立了迄今为止最全面的文本嵌入基准。我们发现没有特定的文本嵌入方法在所有任务中都占主导地位。这表明该领域尚未集中在一个通用的文本嵌入方法上，并将其扩展到足以在所有嵌入任务上提供最先进的结果github地址：https://github.com/embeddings-benchmark/mteb#leaderboard 榜单地址：https://huggingface.co/spaces/mteb/leaderboard
1.2 中文海量文本embedding任务排行榜：C-MTEB 从Chinese Massive Text Embedding Benchmark中可以看到目前最新的针对中文海量文本embedding的各项任务的排行榜，针对不同的任务场景均有单独的排行榜。
任务榜单包括：
RetrievalSTSPairClassificationClassificationRerankingClustering 其中，在本地知识库任务中，主要是根据问题query的embedding表示到向量数据库中检索相似的本地知识文本片段。因此，该场景主要是Retrieval检索任务。检索任务榜单如下：
目前检索任务榜单下效果最好的是bge系列的bge-large-zh模型，langchain-chatchat项目中默认的m3e-base也处于比较靠前的位置
第二部分 text-embedding-ada-002 2.1 模型简介 text-embedding-ada-002是OpenAI提供的一个embedding模型，但需要调用接口付费使用。其具有如下特点：
统一能力：OpenAI通过将五个独立的模型(文本相似性、文本搜索-查询、文本搜索-文档、代码搜索-文本和代码搜索-代码)合并为一个新的模型
在一系列不同的文本搜索、句子相似性和代码搜索基准中，这个单一的表述比以前的嵌入模型表现得更好上下文：上下文长度为8192，使得它在处理长文档时更加方便嵌入尺寸：只有1536个维度，是davinci-001嵌入尺寸的八分之一，使新的嵌入在处理矢量数据库时更具成本效益 2.2 模型使用 以下是OpenAI官方文档中给出的用于文本搜索的代码实例
from openai.embeddings_utils import get_embedding, cosine_similarity def search_reviews(df, product_description, n=3, pprint=True): embedding = get_embedding(product_description, model=&#39;text-embedding-ada-002&#39;) df[&#39;similarities&#39;] = df.ada_embedding.apply(lambda x: cosine_similarity(x, embedding)) res = df." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0a5503e41dfdaf659e8dedc176e64099/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T00:24:09+08:00" />
<meta property="article:modified_time" content="2024-01-04T00:24:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文通透Text Embedding模型：从text2vec、openai-ada-002到m3e、bge</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>本文已经是今年的第31篇大模型相关的技术文章了，如果说</p> 
<ul><li>半年之前写博客，更多是出于个人兴趣 + 读者需要</li><li>那自我司于23年Q3组建LLM项目团队之后，写博客就成了：个人兴趣 + 读者需要 + 项目需要<br> 如此兼备三者，实在是写博客之幸运矣</li></ul> 
<p>我和我司更非常高兴通过博客、课程、内训、项目，与大家共同探讨如何把先进的大模型技术更好、更快的落地到各个行业的业务场景中，赋能千千万万公司的实际业务</p> 
<p>而本文一开始是属于：因我司第三项目组「知识库问答项目」而起的此文《<a class="link-info" href="https://blog.csdn.net/v_JULY_v/article/details/135257848" title="知识库问答LangChain+LLM的二次开发：商用时的典型问题及其改进方案">知识库问答LangChain+LLM的二次开发：商用时的典型问题及其改进方案</a>》中的1.2节(<span style="color:#7b7f82;"><em>该1.2节初稿来自我司LLM项目团队第三项目组的bingo</em></span>)，但为把Text Embedding模型阐述的更为精准、全面，特把那部分的内容抽取出来，不断完善成此文</p> 
<p>最终尽可能相比网上已有的其他资料都更细致化</p> 
<p></p> 
<h2>第一部分 衡量文本向量表示效果的榜单：MTEB、C-MTEB</h2> 
<h3>1.2 《MTEB: Massive Text Embedding Benchmark(海量文本嵌入基准)》</h3> 
<p>判断哪些文本嵌入模型效果较好，通常需要一个评估指标来进行比较，《MTEB: Massive Text Embedding Benchmark(海量文本嵌入基准)》就是一个海量文本嵌入模型的评估基准</p> 
<ul><li>论文地址：https://arxiv.org/abs/2210.07316<br> MTEB包含8个语义向量任务，涵盖58个数据集和112种语言。通过在MTEB上对33个模型进行基准测试，建立了迄今为止最全面的文本嵌入基准。我们发现没有特定的文本嵌入方法在所有任务中都占主导地位。这表明该领域尚未集中在一个通用的文本嵌入方法上，并将其扩展到足以在所有嵌入任务上提供最先进的结果</li><li>github地址：<a class="link-info" href="https://github.com/embeddings-benchmark/mteb#leaderboard" title="https://github.com/embeddings-benchmark/mteb#leaderboard">https://github.com/embeddings-benchmark/mteb#leaderboard</a></li></ul> 
<p class="img-center"><img alt="" height="414" src="https://images2.imgbox.com/b2/ef/nAtuB7rA_o.png" width="800"></p> 
<p>榜单地址：<a href="https://huggingface.co/spaces/mteb/leaderboard" rel="nofollow" title="https://huggingface.co/spaces/mteb/leaderboard">https://huggingface.co/spaces/mteb/leaderboard</a></p> 
<p class="img-center"><img alt="" height="606" src="https://images2.imgbox.com/76/20/zHzWWvJG_o.png" width="1000"></p> 
<h3>1.2 中文海量文本embedding任务排行榜：C-MTEB</h3> 
<p>从<a href="https://github.com/FlagOpen/FlagEmbedding/blob/master/C_MTEB/README.md" title="Chinese Massive Text Embedding Benchmark">Chinese Massive Text Embedding Benchmark</a>中可以看到目前最新的针对中文海量文本embedding的各项任务的排行榜，针对不同的任务场景均有单独的排行榜。</p> 
<p>任务榜单包括：</p> 
<ul><li>Retrieval</li><li>STS</li><li>PairClassification</li><li>Classification</li><li>Reranking</li><li>Clustering</li></ul> 
<p>其中，在本地知识库任务中，主要是根据问题query的embedding表示到向量数据库中检索相似的本地知识文本片段。因此，该场景主要是Retrieval检索任务。检索任务榜单如下：</p> 
<p class="img-center"><img alt="" height="669" src="https://images2.imgbox.com/45/83/oinOXFZS_o.png" width="800"></p> 
<p>目前检索任务榜单下效果最好的是bge系列的<a href="https://huggingface.co/BAAI/bge-large-zh" rel="nofollow" title="bge-large-zh">bge-large-zh</a>模型，langchain-chatchat项目中默认的<a href="https://huggingface.co/moka-ai/m3e-base" rel="nofollow" title="m3e-base">m3e-base</a>也处于比较靠前的位置</p> 
<p></p> 
<h2>第二部分 text-embedding-ada-002</h2> 
<h3>2.1 模型简介</h3> 
<p><a class="link-info" href="https://openai.xiniushu.com/docs/guides/embeddings" rel="nofollow" title="text-embedding-ada-002">text-embedding-ada-002</a>是OpenAI提供的一个embedding模型，但需要调用接口付费使用。其具有如下特点：</p> 
<ul><li>统一能力：OpenAI通过将五个独立的模型(文本相似性、文本搜索-查询、文本搜索-文档、代码搜索-文本和代码搜索-代码)合并为一个新的模型<br> 在一系列不同的文本搜索、句子相似性和代码搜索基准中，这个单一的表述比以前的嵌入模型表现得更好</li><li>上下文：上下文长度为8192，使得它在处理长文档时更加方便</li><li>嵌入尺寸：只有1536个维度，是davinci-001嵌入尺寸的八分之一，使新的嵌入在处理矢量数据库时更具成本效益</li></ul> 
<h3>2.2 模型使用</h3> 
<p>以下是OpenAI官方文档中给出的用于文本搜索的代码实例</p> 
<pre><code>from openai.embeddings_utils import get_embedding, cosine_similarity

def search_reviews(df, product_description, n=3, pprint=True):
  embedding = get_embedding(product_description, model='text-embedding-ada-002')
  df['similarities'] = df.ada_embedding.apply(lambda x: cosine_similarity(x, embedding))
  res = df.sort_values('similarities', ascending=False).head(n)
  return res

res = search_reviews(df, 'delicious beans', n=3)</code></pre> 
<p></p> 
<h2>第三部分 m3e模型</h2> 
<h3>3.1 m3e模型简介</h3> 
<p>M3E(<em><span style="color:#7b7f82;">Moka Massive Mixed Embedding，m3e-base模型下载地址：<a class="link-info" href="https://huggingface.co/moka-ai/m3e-base" rel="nofollow" title="https://huggingface.co/moka-ai/m3e-base">https://huggingface.co/moka-ai/m3e-base</a>，m3e GitHub地址：<a class="link-info" href="https://github.com/wangyingdong/m3e-base" title="GitHub - wangyingdong/m3e-base">GitHub - wangyingdong/m3e-base</a></span></em>)，其</p> 
<ul><li>使用in-batch负采样的对比学习的方式在句对数据集进行训练，为了保证in-batch负采样的效果，使用A100来最大化batch-size，并在共计2200W+的句对数据集(<span style="color:#7b7f82;"><em>包含中文百科，金融，医疗，法律，新闻，学术等多个领域</em></span>)上训练了 1 epoch</li><li>使用了指令数据集，M3E 使用了300W+的指令微调数据集，这使得 M3E 对文本编码的时候可以遵从指令，这部分的工作主要被启发于 <a href="https://link.zhihu.com/?target=https%3A//github.com/HKUNLP/instructor-embedding" rel="nofollow" title="instructor-embedding">instructor-embedding</a></li><li>基础模型，M3E 使用 <a href="https://link.zhihu.com/?target=https%3A//huggingface.co/hfl/chinese-roberta-wwm-ext" rel="nofollow" title="Roberta">Roberta</a> 系列模型进行训练，目前提供 small 和 base 两个版本<br> 此文《<a class="link-info" href="https://blog.csdn.net/v_JULY_v/article/details/135257848" title="知识库问答LangChain+LLM的二次开发：商用时的典型问题及其改进方案">知识库问答LangChain+LLM的二次开发：商用时的典型问题及其改进方案</a>》中的langchain-chatchat便默认用的m3e-base</li></ul> 
<h4>3.1.1 m3e与openai text-embedding-ada-002</h4> 
<p>以下是m3e的一些重大更新</p> 
<ul><li>2023.06.08，添加检索任务的评测结果，在 T2Ranking 1W 中文数据集上，m3e-base 在 ndcg@10 上达到了 <strong>0.8004</strong>，超过了 openai-ada-002 的 0.7786<br> 见下图<strong>s2p ndcg@10</strong>那一列(<span style="color:#7b7f82;"><em>其中s2p, 即 sentence to passage ，代表了异质文本之间的嵌入能力，适用任务：文本检索，GPT 记忆模块等</em></span>)</li><li>2023.06.07，添加文本分类任务的评测结果，在 6 种文本分类数据集上，m3e-base 在 accuracy 上达到了 <strong>0.6157</strong>，超过了 openai-ada-002 的 0.5956<br> 见下图<strong>s2s ACC</strong>那一列(<span style="color:#7b7f82;"><em>其中s2s, 即 sentence to sentence ，代表了同质文本之间的嵌入能力，适用任务：文本相似度，重复问题检测，文本分类等</em></span>) <p class="img-center"><img alt="" height="258" src="https://images2.imgbox.com/f3/35/8jdCMV6A_o.png" width="800"></p> </li></ul> 
<p>此外，m3e团队建议</p> 
<ol><li>如果使用场景主要是中文，少量英文的情况，建议使用 m3e 系列的模型</li><li>多语言使用场景，并且不介意数据隐私的话，作者团队建议使用 openai text-embedding-ada-002</li><li>代码检索场景，推荐使用 openai text-embedding-ada-002</li><li>文本检索场景，请使用具备文本检索能力的模型，只在 S2S 上训练的文本嵌入模型，没有办法完成文本检索任务</li></ol> 
<h3>3.2 m3e模型微调</h3> 
<ul><li>微调脚本：<br> m3e是使用uniem脚本进行微调 <pre><code>from datasets import load_dataset

from uniem.finetuner import FineTuner

dataset = load_dataset('shibing624/nli_zh', 'STS-B')
# 指定训练的模型为 m3e-small
finetuner = FineTuner.from_pretrained('moka-ai/m3e-small', dataset=dataset)
finetuner.run(epochs=3)</code></pre> </li></ul> 
<p>详细教程暂放在「大模型项目开发线上营」中，至于本文后续更新</p> 
<p></p> 
<h2>第四部分 bge模型</h2> 
<h3>4.1 bge模型的简介</h3> 
<p>BGE是北京智源人工智能研究院发布的中英文语义向量模型(<em><span style="color:#7b7f82;">hf地址：<a href="https://huggingface.co/BAAI/bge-large-zh" rel="nofollow" title="https://huggingface.co/BAAI/bge-large-zh">https://huggingface.co/BAAI/bge-large-zh</a>，GitHub地址：<a href="https://github.com/FlagOpen/FlagEmbedding/blob/master/README_zh.md" title="https://github.com/FlagOpen/FlagEmbedding/blob/master/README_zh.md">https://github.com/FlagOpen/FlagEmbedding/blob/master/README_zh.md</a></span></em>)，以下是BGE的技术亮点</p> 
<ol><li>高效预训练和大规模文本微调；</li><li>在两个大规模语料集上采用了RetroMAE预训练算法，进一步增强了模型的语义表征能力；</li><li>通过负采样和难负样例挖掘，增强了语义向量的判别力；</li><li>借鉴Instruction Tuning的策略，增强了在多任务场景下的通用能力</li></ol> 
<h4>4.1.1 RetroMAE的预训练步骤</h4> 
<p>目前主流的语言模型的预训练任务都是token级别的，比如MLM或者Seq2Seq，但是这种训练任务难以让模型获得一个高质量的基于句子级别的句向量，这限制了语言模型在检索任务上的潜力。针对这个弊端，目前有两者针对检索模型的预训练策略</p> 
<ul><li>第一种是self-contrastive learning，这种方式往往受限于数据增强的质量，并且需要采用非常庞大数量的的负样本</li><li>另一种基于anto-encoding，一种自重建方法，不受数据增强跟负样本采样策略的影响，基于这种方法的模型性能好坏有两个关键因素<br> 其一是重建任务必须要对编码质量有足够的要求，其二是训练数据需要被充分利用到</li></ul> 
<p>基于此，研究人员提出了RetraoMAE(<em>RetroMAE论文：<em><a href="https://arxiv.org/abs/2205.12035" rel="nofollow" title="https://arxiv.org/abs/2205.12035">https://arxiv.org/abs/2205.12035</a></em></em>)，它包括两个模块，其一是一个类似于BERT的编码器，用于生成句向量，其二是一个一层transformer的解码器，用于重建句子，如下图所示</p> 
<p class="img-center"><img alt="" height="370" src="https://images2.imgbox.com/60/75/LHI3KKlg_o.png" width="500"></p> 
<h5><strong>4.1.1.1 编码Encoding</strong></h5> 
<p><strong>所谓编码，即Mask(EN)掉一小部分token然后通过BERT编码得到句子嵌入<span style="color:#7b7f82;"><em>sentence embedding</em></span></strong><img alt="h_x" class="mathcode" src="https://images2.imgbox.com/9d/d9/q1OsIDeu_o.png">，具体步骤如下</p> 
<ol><li>给定一个句子输入<img alt="X" class="mathcode" src="https://images2.imgbox.com/32/dc/n9WOS1ys_o.png">：<em>Norwegian forest cat is a breed of dom-estic cat originating in northern Europe</em></li><li>随机Mask(EN)掉其中一小部分token后得到<img alt="X_{enc}" class="mathcode" src="https://images2.imgbox.com/63/69/HEMPQcul_o.png">：<em>[M] forest cat is a breed of [M] cat originating in [M] Europe</em><br> 这里通常会采用一定的mask比例(15%～30%)，从而能保留句子原本大部分的信息</li><li>然后利用类似BERT的编码器<img alt="\Phi^{e n c}(\cdot)" class="mathcode" src="https://images2.imgbox.com/12/ea/cZCEwSdB_o.png">对其进行编码，得到对应的的句子嵌入<img alt="\mathbf{h}_{\tilde{X}}" class="mathcode" src="https://images2.imgbox.com/3a/3d/4c0eoRrW_o.png">「<span style="color:#7b7f82;"><em>一般将[CLS]位置最后一层的隐状态作为句子嵌入</em></span>」，如下公式所示<br>                                                                                        <img alt="\mathbf{h}_{\tilde{X}} \leftarrow \Phi_{e n c}\left(\tilde{X}_{e n c}\right)" class="mathcode" src="https://images2.imgbox.com/88/dc/orylUJhG_o.png"><br><span style="color:#7b7f82;"><em>We apply a BERT like encoder with 12 layers and768 hidden-dimensions, which helps to capture thein-depth semantics of the sentence. Following the common practice, we select the [CLS] token’s finalhidden state as the sentence embedding.</em></span></li></ol> 
<h5><strong>4.1.1.2 解码Decoding</strong></h5> 
<p><strong>所谓解码，即Mask(DE)很大一部分token然后结合句子嵌入<em>sentence embedding</em></strong><img alt="\mathbf{h}_{\tilde{X}}" class="mathcode" src="https://images2.imgbox.com/f0/e4/qVHKRxvM_o.png"><strong>，让解码器重构原始句子</strong></p> 
<p>具体而言，即是联合以下两个部分，好让解码器在该两部分的基础上重构原始句子</p> 
<ul><li><span style="color:#ed7976;">利用Mask(DE)后的文本输入<img alt="\tilde{X}_{d e c}" class="mathcode" src="https://images2.imgbox.com/1d/32/PP40fGL8_o.png"></span>：<em>[MI [M] cat is MI [M} of dom-estic [M] [M] in northern [M]</em><br> (<span style="color:#7b7f82;"><em>这里采取了比encoder部分更加激进的mask比例，比如50%～70%</em></span>)</li><li><span style="color:#ed7976;">与上一节encoder生成的句子嵌入</span>(<span style="color:#7b7f82;"><em>sentence embedding</em></span>)<br><strong><span style="color:#7b7f82;"><em>论文中对这一步骤的英文阐述是：The masked input is joined with the sentence embedding, based on which the original sentence is reconstructed by the decoder.</em></span></strong></li></ul> 
<p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/32/3e/UeIKhDR5_o.png" width="1000"></p> 
<blockquote> 
 <p><span style="color:#7b7f82;"><em>有个细节是，这里的Mask(DE)输入带上位置嵌入了，即句子嵌入<img alt="\mathbf{h}_{\tilde{X}}" class="mathcode" src="https://images2.imgbox.com/77/26/fcjDCEZR_o.png">和带有位置的掩码输入被组合成以下序列<br>                                                                               <img alt="\mathbf{H}_{\tilde{X}_{d e c}} \leftarrow\left[\mathbf{h}_{\tilde{X}}, \mathbf{e}_{x_{1}}+\mathbf{p}_{1}, \ldots, \mathbf{e}_{x_{N}}+\mathbf{p}_{N}\right]" class="mathcode" src="https://images2.imgbox.com/aa/bb/Digrr0q1_o.png"><br> 其中，<img alt="e_{x_i}" class="mathcode" src="https://images2.imgbox.com/9a/76/emTZw19l_o.png">表示<img alt="x_i" class="mathcode" src="https://images2.imgbox.com/14/35/ZJ94SpPO_o.png">的嵌入，在<img alt="x_i" class="mathcode" src="https://images2.imgbox.com/2f/48/BbqsYViF_o.png">的基础上增加了一个额外的位置嵌入<img alt="p_i" class="mathcode" src="https://images2.imgbox.com/4e/c7/k29Ah6xX_o.png"></em></span></p> 
 <hr> 
 <p><span style="color:#7b7f82;"><em>接下来，通过优化以下目标，学习解码器<img alt="\Phi_{d e c}" class="mathcode" src="https://images2.imgbox.com/63/0e/Vlys28hH_o.png">来重构原始句子<img alt="X" class="mathcode" src="https://images2.imgbox.com/36/fa/EHCh7cAF_o.png"><br>                                                                               <img alt="\mathcal{L}_{d e c}=\sum_{x_{i} \in \text { masked }} \mathrm{CE}\left(x_{i} \mid \Phi_{\text {dec }}\left(\mathbf{H}_{\tilde{X}_{d e c}}\right)\right)" class="mathcode" src="https://images2.imgbox.com/53/ee/ERDyRnGZ_o.png"></em></span><br> 其中，<img alt="CE" class="mathcode" src="https://images2.imgbox.com/6c/5a/IKmH6CSm_o.png">是交叉熵损失</p> 
</blockquote> 
<p>由于在解码器部分采用了极其简单的网络结构跟非常激进的mask比例，从而使得解码任务变得极具挑战性，迫使encoder去生成高质量的句向量才能最终准确地完成原文本重建</p> 
<h5><strong>4.1.1.3 增强解码Enhanced Decoding</strong></h5> 
<p>前面提及的解码策略有一种缺陷，就是训练信号只来源于被mask掉的token，而且每个mask掉的token都是基于同一个上下文重建的。于是研究人员提出了一种新的解码方法：Enhanced Decoding，具体做法如下</p> 
<ul><li>a) 首先生成两个不同的输入流H1(query)跟H2(context) <p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/92/b9/TtedQmw4_o.png" width="300"></p> <span style="color:#7b7f82;"><em><strong>其中<img alt="\mathbf{h}_{\tilde{X}}" class="mathcode" src="https://images2.imgbox.com/7a/c6/Xblt5kyR_o.png">是句子嵌入，<img alt="e_{x_i}" class="mathcode" src="https://images2.imgbox.com/fb/6b/iU5w0sw5_o.png">是标记嵌入(在这个地方没有标记被掩码)，<img alt="p_i" class="mathcode" src="https://images2.imgbox.com/ce/fe/LhoRVTXe_o.png">是位置嵌入</strong></em></span><br><span style="color:#7b7f82;"><em><strong>相当于 <br><img alt="H_1" class="mathcode" src="https://images2.imgbox.com/77/29/hWsZgOG2_o.png">是sentence embedding + Position embedding<br><img alt="H_2" class="mathcode" src="https://images2.imgbox.com/56/eb/iqZ1p5u7_o.png">为sentence embedding和token embedding + position embedding</strong></em></span></li><li>b) 通过attention机制得到新的输出<img alt="A" class="mathcode" src="https://images2.imgbox.com/3a/9a/OLCZojRg_o.png"><p class="img-center"><img alt="" height="134" src="https://images2.imgbox.com/52/b3/8N1SyBUy_o.png" width="300"></p> 这里的<img alt="M" class="mathcode" src="https://images2.imgbox.com/9b/d5/Z4Y6Nlq7_o.png">是一个mask矩阵，第<img alt="i" class="mathcode" src="https://images2.imgbox.com/72/c9/bKBtztDP_o.png">个token所能看得到的其他token是通过抽样的方式决定的(当然要确保看不到自身token，而且都要看得见第一个token，也就是encoder所产出CLS句向量的信息) 
  <blockquote> 
   <p><span style="color:#7b7f82;"><em>其中一个和常规decoder不一样的地方是，H1作为Q，H2作为KV</em></span></p> 
   <p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/08/76/lp8vfTkd_o.png" width="1000"></p> 
   <p><span style="color:#7b7f82;"><em>H1中的每个token embedding去H2中查找比较重要的上下文：包括<strong>H2被采样到的 token，以及初始token embedding</strong>都能看到[这里的初始embedding就是sentence embedding]，至于对角线上的因代表的各自自身，故看不到</em></span></p> 
   <hr> 
   <p><span style="color:#7b7f82;"><em>为方便大家更好、更快的理解，我再举个例子，比如：</em></span></p> 
   <p><span style="color:#7b7f82;"><em>P0上的<img alt="x_0" class="mathcode" src="https://images2.imgbox.com/97/fd/mLBsmUS6_o.png">能看见P1上的<img alt="x_1" class="mathcode" src="https://images2.imgbox.com/17/90/D3wbmoM3_o.png">                       (<s>x0</s>、x1)<br> P1上的<img alt="x_1" class="mathcode" src="https://images2.imgbox.com/6c/e3/aCYc0kky_o.png">能看见P0、P2上的<img alt="x_0" class="mathcode" src="https://images2.imgbox.com/c8/ab/nMKlp02C_o.png">、<img alt="x_2" class="mathcode" src="https://images2.imgbox.com/27/33/tT8VqcG8_o.png">       (x0、<s>x1</s>、x2)<br> P2上的<img alt="x_2" class="mathcode" src="https://images2.imgbox.com/9a/de/NXWRZOxH_o.png">能看见P0、P1上的<img alt="x_0" class="mathcode" src="https://images2.imgbox.com/3a/42/t0ErF2eL_o.png">、<img alt="x_1" class="mathcode" src="https://images2.imgbox.com/75/d7/uLlnRttv_o.png">       (x0、x1、<s>x2</s>)<br> P3上的<img alt="x_3" class="mathcode" src="https://images2.imgbox.com/8a/df/SA09BqRO_o.png">能看见P0、P4上的<img alt="x_0" class="mathcode" src="https://images2.imgbox.com/0b/6e/Cuo91PVm_o.png">、<img alt="x_4" class="mathcode" src="https://images2.imgbox.com/00/91/ZwfG6ySj_o.png">       (x0、_ 、 _、<s>x3</s>、x4)<br> P4上的<img alt="x_4" class="mathcode" src="https://images2.imgbox.com/c8/ed/H8hzrTCt_o.png">能看见P0、P3上的<img alt="x_0" class="mathcode" src="https://images2.imgbox.com/48/49/iAAATHIK_o.png">、<img alt="x_3" class="mathcode" src="https://images2.imgbox.com/02/45/KlPfkiKU_o.png">       (x0、_ 、 _、x3、<s>x4</s>)<br> 之后，每个token xi基于对矩阵M的第i行可见的上下文进行重构(each token xi is recon-structed based on the context which are visible tothe i-th row of matrix M)，该矩阵即如下所示<br>                                                                 <img alt="\mathbf{M}_{i j}=\left\{\begin{array}{l} 0, \quad x_{j} \in s\left(X_{\neq i}\right), \text { or } j_{\mid i \neq 0}=0 \\ -\infty, \text { otherwise. } \end{array}\right." class="mathcode" src="https://images2.imgbox.com/4c/d1/MxAv6D3s_o.png"></em></span><br> 主对角线位置填充为-∞(<span style="color:#7b7f82;"><em>因为其代表自身，故不可见</em></span>)，可见上下文的位置填充为0，代表可见</p> 
  </blockquote> </li></ul> 
<ul><li>c)最终利用attention后的输出A跟H1一起过FNN(即resnet)去重建原文本，这里重建的目标不仅仅是被mask掉的token，而是全部token<br>                                                                 <img alt="\mathcal{L}_{d e c}=\sum_{x_{i} \in X} \mathrm{CE}\left(x_{i} \mid \mathbf{A}, \mathbf{H}_{1}\right)" class="mathcode" src="https://images2.imgbox.com/46/77/gRP7CfyU_o.png"><br><br> 最终RetroMAE的损失由两部分相加得到，其一是encoder部分的MLM损失，其二是deocder部分自重建的交叉熵损失</li></ul> 
<p>最后，再总结一下<span style="color:#000000;">RetroMAE 预训练步骤</span></p> 
<p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/68/3a/ux3iwOSE_o.png" width="1000"></p> 
<ol><li>(A)编码阶段：将输入进行一定比例的mask操作，并编码为句子嵌入(绿色矩形)<br><em><span style="color:#7b7f82;">(A) Encoding: the input is moderately masked and encoded as the sentence embedding (the green rectangle)</span></em></li><li>(B)解码阶段：对输入使用很高比例的mask操作，并与句子嵌入连接以恢复被mask的部分(阴影符号)<br><span style="color:#7b7f82;"><em>(B) Decoding: the input is aggressively masked, and joined with the sentence embedding to reconstruct the masked tokens (the shadowed tokens).</em></span></li><li>(C)增强编码阶段：基于每行的句子嵌入和可见上下文来重建所有输入符号；主对角线位置填充为-∞(<span style="color:#7b7f82;"><em>灰色，因为其代表自身，故不可见</em></span>)，可见上下文的位置填充为0(<span style="color:#1a439c;"><em>蓝色</em></span>)<br><span style="color:#7b7f82;"><em>(C) Enhanced encoding: all input tokens are reconstructed based on the sentence embedding and the visible context in each row (defined in Eq. 7); the main diagonal positions are filled with −∞ (grey), and positions for the visible context are filled with 0 (blue).</em></span></li></ol> 
<h3>4.2 bge模型的微调</h3> 
<ul><li>​微调脚本：https://github.com/FlagOpen/FlagEmbedding/tree/master/examples/finetune</li><li>数据格式 <pre><code>{"query": str, "pos": List[str], "neg":List[str]}</code></pre> </li><li>难负样本挖掘<br> 难负样本是一种广泛使用的提高句子嵌入质量的方法。可以按照以下方法挖掘难负样本 <pre><code>python -m FlagEmbedding.baai_general_embedding.finetune.hn_mine \
--model_name_or_path BAAI/bge-base-en-v1.5 \
--input_file toy_finetune_data.jsonl \
--output_file toy_finetune_data_minedHN.jsonl \
--range_for_sampling 2-200 \
--use_gpu_for_searching</code></pre> </li><li>训练 <pre><code>python -m FlagEmbedding.baai_general_embedding.finetune.hn_mine \
--model_name_or_path BAAI/bge-base-en-v1.5 \
--input_file toy_finetune_data.jsonl \
--output_file toy_finetune_data_minedHN.jsonl \
--range_for_sampling 2-200 \
--use_gpu_for_searching</code></pre> </li></ul> 
<p></p> 
<h2 style="background-color:transparent;">参考文献与推荐阅读</h2> 
<ol><li><a class="link-info" href="https://blog.csdn.net/dzysunshine/article/details/133674250" title="Text embedding 模型总结">Text embedding 模型总结</a></li><li><a class="link-info" href="https://zhuanlan.zhihu.com/p/651017743" rel="nofollow" title="BGE登顶MTEB的神器--RetroMAE｜一种基于自动编码的检索模型预训练方法">BGE登顶MTEB的神器--RetroMAE｜一种基于自动编码的检索模型预训练方法</a></li><li><a class="link-info" href="https://zhuanlan.zhihu.com/p/648448793" rel="nofollow" title="链接大模型与外部知识，智源开源最强语义向量模型BGE">链接大模型与外部知识，智源开源最强语义向量模型BGE</a></li><li><a class="link-info" href="https://zhuanlan.zhihu.com/p/649049846" rel="nofollow" title="RetroMAE: Pre-Training Retrieval-oriented Language Models Via Masked Auto-Encoder阅读笔记">RetroMAE: Pre-Training Retrieval-oriented Language Models Via Masked Auto-Encoder阅读笔记</a></li><li><a class="link-info" href="https://zhuanlan.zhihu.com/p/653724148" rel="nofollow" title="RetroMAE+key word=RetroMAE-2">RetroMAE+key word=RetroMAE-2</a>..</li><li><a class="link-info" href="https://zhuanlan.zhihu.com/p/655310436" rel="nofollow" title="语言模型之Text embedding（思考篇）">语言模型之Text embedding（思考篇）</a></li><li><a class="link-info" href="https://openai.xiniushu.com/docs/guides/embeddings" rel="nofollow" title="OpenAI中文文档：嵌入（Embeddings）">OpenAI中文文档：嵌入（Embeddings）</a></li><li>..</li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2ce19ece66740f36d541fe3ef13b9a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pytorch深度学习笔记（共计169页，基于本人听完B站小土堆PyTorch深度学习快速入门教程所写）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be163f3a46a51a12011f11a256415061/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【二叉树】654.最大二叉树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>