<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java锁系列1/3--常用锁的分类 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java锁系列1/3--常用锁的分类" />
<meta property="og:description" content="说到线程安全，经常会用到锁。了解锁有哪些，锁又是如何设计的，对在业务中选择合适的锁很重要。
（一）锁的分类概述 （二）锁的分类详解 1.可重入锁 、不可重入锁
类型概念（同一个线程角度分析）类型模型可重入锁可以重入上锁的代码段方法调用时，次都可访问另一个方法（例如：递归）不可重入锁不可以重入上锁后的代码段独立的访问每一个方法，加锁 - 释放 2.共享锁、排他锁
类型概念示例共享锁可被多个线程所持有ReadWriteLock的读锁排他锁一次只能被一个线程所持有ReadWriteLock的写锁 3.公平锁、非公平锁
类型概念（多个线程角度分析）特点公平锁按照申请锁的顺序来获取锁公平非公平锁获取锁的顺序并不是按照申请锁的顺序吞吐量比公平锁大，但可能造成饥饿现象 4.偏向锁、轻量级锁、重量级锁（锁的状态）
Java 5通过引入锁升级的机制来实现高效Synchronized，通过对象监视器在对象头中的字段来表明。 类型概念特点偏向锁一段同步代码一直被一个线程所访问，那么该线程会自动获取锁降低获取锁的代价轻量级锁当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁不会阻塞，提高性能重量级锁锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁重量级锁会让他申请的线程进入阻塞，性能降低 5.乐观锁、悲观锁（看待并发同步的角度）
类型概念场景乐观锁每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。多读的，提高吞吐量悲观锁对于同一个数据的并发操作，一定会发生修改的（实际上可能未修改）。因此对于同一份数据的并发操作，采取加锁的形式。加锁失败，说明该记录正在被修改，当前查询可能要等待或者抛出异常（开发者决定） 6.自旋锁
类型概念特点自旋锁概念尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁减少线程上下文切换的消耗；但是循环会消耗CPU （三）锁的设计 锁的设计用锁的粒度很好解释，锁的粒度涉及到临界区。临界区大，我们保护的范围更大，但是会影响效率，而临界区小了，可能又会导致不安全。
如何不知道如何选择，可以先保证安全，再进行优化。
临界区：我们居住的房子，门上都会有锁，而我们锁住的也是这个屋子的安全，而这个屋子就是临界区。
总结 了解了锁的分类，算是对锁有个基本认识了。要想更深入的了解锁，还需要了解锁底层原理，而常用锁底层实现都是 AQS实现的，下一篇我们就来聊聊【Java锁系列2/3–分析AQS源码】" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0fe47456ff00da28cb63df907b5af8b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-08T21:21:14+08:00" />
<meta property="article:modified_time" content="2022-04-08T21:21:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java锁系列1/3--常用锁的分类</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>说到线程安全，经常会用到锁。了解锁有哪些，锁又是如何设计的，对在业务中选择合适的锁很重要。</p> 
<h3><a id="_2"></a>（一）锁的分类概述</h3> 
<p><img src="https://images2.imgbox.com/32/54/6BmxT1yx_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_8"></a>（二）锁的分类详解</h3> 
<p>1.可重入锁 、不可重入锁</p> 
<table><thead><tr><th>类型</th><th>概念（同一个线程角度分析）类型</th><th>模型</th></tr></thead><tbody><tr><td>可重入锁</td><td>可以重入上锁的代码段</td><td>方法调用时，次都可访问另一个方法（例如：递归）</td></tr><tr><td>不可重入锁</td><td>不可以重入上锁后的代码段</td><td>独立的访问每一个方法，加锁 - 释放</td></tr></tbody></table> 
<p>2.共享锁、排他锁</p> 
<table><thead><tr><th>类型</th><th>概念</th><th>示例</th></tr></thead><tbody><tr><td>共享锁</td><td>可被多个线程所持有</td><td>ReadWriteLock的读锁</td></tr><tr><td>排他锁</td><td>一次只能被一个线程所持有</td><td>ReadWriteLock的写锁</td></tr></tbody></table> 
<p>3.公平锁、非公平锁</p> 
<table><thead><tr><th>类型</th><th>概念（多个线程角度分析）</th><th>特点</th></tr></thead><tbody><tr><td>公平锁</td><td>按照申请锁的顺序来获取锁</td><td>公平</td></tr><tr><td>非公平锁</td><td>获取锁的顺序并不是按照申请锁的顺序</td><td>吞吐量比公平锁大，但可能造成饥饿现象</td></tr></tbody></table> 
<p>4.偏向锁、轻量级锁、重量级锁（锁的状态）</p> 
<ul><li>Java 5通过引入锁升级的机制来实现高效Synchronized，通过对象监视器在对象头中的字段来表明。</li></ul> 
<table><thead><tr><th>类型</th><th>概念</th><th>特点</th></tr></thead><tbody><tr><td>偏向锁</td><td>一段同步代码一直被一个线程所访问，那么该线程会自动获取锁</td><td>降低获取锁的代价</td></tr><tr><td>轻量级锁</td><td>当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁</td><td>不会阻塞，提高性能</td></tr><tr><td>重量级锁</td><td>锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁</td><td>重量级锁会让他申请的线程进入阻塞，性能降低</td></tr></tbody></table> 
<p>5.乐观锁、悲观锁（看待并发同步的角度）</p> 
<table><thead><tr><th>类型</th><th>概念</th><th>场景</th></tr></thead><tbody><tr><td>乐观锁</td><td>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</td><td>多读的，提高吞吐量</td></tr><tr><td>悲观锁</td><td>对于同一个数据的并发操作，一定会发生修改的（实际上可能未修改）。因此对于同一份数据的并发操作，采取加锁的形式。</td><td>加锁失败，说明该记录正在被修改，当前查询可能要等待或者抛出异常（开发者决定）</td></tr></tbody></table> 
<p>6.自旋锁</p> 
<table><thead><tr><th>类型</th><th>概念</th><th>特点</th></tr></thead><tbody><tr><td>自旋锁</td><td>概念尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</td><td>减少线程上下文切换的消耗；但是循环会消耗CPU</td></tr></tbody></table> 
<h3><a id="_48"></a>（三）锁的设计</h3> 
<p>锁的设计用锁的粒度很好解释，锁的粒度涉及到临界区。临界区大，我们保护的范围更大，但是会影响效率，而临界区小了，可能又会导致不安全。<br> 如何不知道如何选择，可以先保证安全，再进行优化。<br> 临界区：我们居住的房子，门上都会有锁，而我们锁住的也是这个屋子的安全，而这个屋子就是临界区。</p> 
<h3><a id="_53"></a>总结</h3> 
<p>了解了锁的分类，算是对锁有个基本认识了。要想更深入的了解锁，还需要了解锁底层原理，而常用锁底层实现都是 AQS实现的，下一篇我们就来聊聊【Java锁系列2/3–分析AQS源码】</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b3f17d583534d00c21e4f86aa3f1728/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【SNA】社会网络分析二 Gephi 功能详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a63f70b65639dbd99d074bb39f25f5f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">办公小技巧：excel怎么排序？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>