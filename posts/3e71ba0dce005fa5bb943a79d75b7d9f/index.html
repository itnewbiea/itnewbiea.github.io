<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JavaScript】期约与异步函数 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JavaScript】期约与异步函数" />
<meta property="og:description" content="在最基本的形式中，JavaScript是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。
JavaScript单线程模型 在最基本的形式中，JavaScript是一种同步的、阻塞的、单线程的编程语言，在这种语言中，一次只能执行一个操作。
JavaScript引擎从文件顶部开始执行脚本，然后一路向下执行。在执行阶段，他创建执行上下文，将函数推入或移出调用栈。
The JavaScript engine executes a script from the top of the file and works its way down. It creates the execution contexts, pushes, and pops functions onto and off the call stack in the execution phase.
事件循环 事件循环（Event Loop）。a constantly running process that coordinates the tasks between the call stack and callback queue to achieve concurrency.
一个持续运行的进程，协调调用栈和回调队列之间的任务，以实现并发。
阻塞函数 阻塞函数（blocking function），需要花费很长时间才能执行完成的函数。阻塞函数会阻断网页的所有交互操作。
事件队列 callback queue，task queue。存放异步操作，在主线程完成处理后运行。
JavaScript Event Loop" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3e71ba0dce005fa5bb943a79d75b7d9f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-26T18:25:29+08:00" />
<meta property="article:modified_time" content="2022-07-26T18:25:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JavaScript】期约与异步函数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在最基本的形式中，JavaScript是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p> 
<h3><a id="JavaScript_1"></a>JavaScript单线程模型</h3> 
<p>在最基本的形式中，JavaScript是一种同步的、阻塞的、单线程的编程语言，在这种语言中，一次只能执行一个操作。<br> JavaScript引擎从文件顶部开始执行脚本，然后一路向下执行。在执行阶段，他创建执行上下文，将函数推入或移出调用栈。<br> The JavaScript engine executes a script from the top of the file and works its way down. It creates the <strong>execution contexts</strong>, pushes, and pops functions onto and off <strong>the call stack</strong> in the execution phase.</p> 
<h3><a id="_5"></a>事件循环</h3> 
<p>事件循环（Event Loop）。a constantly running process that coordinates the tasks between the call stack and callback queue to achieve concurrency.<br> 一个持续运行的进程，协调调用栈和回调队列之间的任务，以实现并发。<br> <img src="https://images2.imgbox.com/4b/4c/MyE7YegY_o.png" alt="请添加图片描述"></p> 
<h3><a id="_10"></a>阻塞函数</h3> 
<p>阻塞函数（blocking function），需要花费很长时间才能执行完成的函数。阻塞函数会阻断网页的所有交互操作。</p> 
<h3><a id="_12"></a>事件队列</h3> 
<p>callback queue，task queue。存放异步操作，在主线程完成处理后运行。</p> 
<blockquote> 
 <p>JavaScript Event Loop<br> https://www.javascripttutorial.net/javascript-event-loop/</p> 
</blockquote> 
<h3><a id="_16"></a>异步编程实现方法</h3> 
<p>回调函数和事件；期约。并发和异步（concurrently and asynchronously）</p> 
<h3><a id="Promise_18"></a>Promise对象</h3> 
<p>表示一个异步操作最终的状态（待定，完成或失败）及其结果值。<br> Promise状态转变后不可逆。<br> 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p> 
<h4><a id="Promise_22"></a>Promise期约三种状态</h4> 
<p>pending：待定，初始状态。<br> fulfilled：实现，异步操作成功。<br> rejected：拒绝，异步操作失败。<br> 当一个期约promise是fulfilled状态时，会调用then()方法。当一个期约promise是rejected状态时，会调用catch()方法。</p> 
<h4><a id="_27"></a>结果值</h4> 
<p>无<br> the fulfillment value<br> the rejection reason</p> 
<blockquote> 
 <p>无返回、原始值、对象、期约Promise、thenable对象。</p> 
</blockquote> 
<h4><a id="_32"></a>构造函数</h4> 
<p>创建一个新的Promise对象。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 语法格式</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 参数executor - 一段自定义代码的函数</span>
<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolutionFunc<span class="token punctuation">,</span> rejectionFunc</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 通常是一些异步操作</span>
      <span class="token comment">// do something asynchronous which eventually calls either:</span>
  <span class="token comment">//</span>
  <span class="token comment">//   resolve(someValue)        // fulfilled</span>
  <span class="token comment">// or</span>
  <span class="token comment">//   reject("failure reason")  // rejected</span>
      <span class="token punctuation">}</span>
当异步任务成功时，第一个函数（resolve）将被调用，并返回一个值代表成功。当其失败时，第二个函数（reject）将被调用，并返回失败原因（失败原因通常是一个error对象）。
<span class="token function">resolutionFunc</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 当被敲定时调用</span>
<span class="token function">rejectionFunc</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token comment">// 当被拒绝时调用</span>

<span class="token comment">// 返回值</span>
返回一个promise对象。对象的状态由resolutionFunc和rejectionFunc决定，对象的结果值是他们的参数。
</code></pre> 
<h4><a id="_55"></a>静态方法</h4> 
<p><strong>resolve函数</strong>的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 语法格式</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 参数</span>
value	<span class="token comment">// 给定的结果值</span>
<span class="token comment">// 返回值</span>
返回一个带有给定结果值，已实现fulfill状态的Promise对象。

返回值情况：
若参数为值value，则返回一个fulfilled的新期约，期约结果值为value。
若参数为promise，则返回参数promise本身。
若参数为thenable对象，则返回执行thenable对象的then方法后的新期约。

<span class="token comment">// 等价于</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>reject函数</strong>的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 语法格式</span>
Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 参数</span>
reason	<span class="token comment">// 被拒绝的原因</span>
<span class="token comment">// 返回值</span>
返回一个结果值为给定拒绝原因reason，已拒绝rejected状态的Promise对象。
</code></pre> 
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例。</p> 
<h4><a id="_83"></a>实例方法</h4> 
<p><strong>then方法</strong>：<br> 为 Promise 实例添加状态改变时的回调函数。指定resolved状态和rejected状态的回调函数。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 语法格式</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span>onFulfilled<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> onRejected<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// fulfillment</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// rejection</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 参数</span>
onFulfilled<span class="token punctuation">;</span>  <span class="token comment">// Promise变成实现状态时调用此处理程序函数，参数value为实现的最终结果（the fulfillment value）</span>
onRejected<span class="token punctuation">;</span>  <span class="token comment">// Promise变成拒绝状态时调用此处理程序函数，参数reason为拒绝的原因（the rejection reason）</span>
<span class="token comment">// 如果该参数不是函数，则会在内部被替换为“Identity”函数，即(x) =&gt; x,原样返回 promise 最终结果的函数</span>
<span class="token comment">// 如果该参数不是函数，则会在内部被替换为一个 "Thrower" 函数 (it throws an error it received as argument)。</span>
<span class="token comment">// 如果调用then时一个参数也没有，则then方法返回一个和调用then方法的期约一样状态和结果值的新期约。</span>

<span class="token comment">// 返回值</span>
返回一个新期约Promise。

then方法返回的新期约遵循以下规则。若then中的回调函数：
返回了一个值，那么 then 返回的 Promise 状态已锁定resolved，并且结果值为 <span class="token operator">**</span>返回的值<span class="token operator">**</span>。
没有返回任何值，那么 then 返回的 Promise 状态已锁定resolved，并且结果值为 <span class="token operator">**</span><span class="token keyword">undefined</span><span class="token operator">**</span>。
抛出一个错误，那么 then 返回的 Promise 将会成为拒绝状态，并且将抛出的错误作为结果值。
返回一个已经是接受状态的 Promise，那么 then 返回的 Promise 也会成为实现 fulfilled 状态，并且结果值为返回语句中 Promise 的实现值（fulfillment value）。
返回一个已经是拒绝状态的 Promise，那么 then 返回的 Promise 也会成为拒绝 rejected 状态，并且结果值为返回语句中 Promise 的拒绝原因（rejection reason）。
返回一个未定状态（pending）的 Promise，那么 then 返回的 Promise 状态也是未定的。
</code></pre> 
<p>then方法的第一个参数是resolved状态的回调函数（callback function），第二个参数是rejected状态的回调函数，它们都是可选的。返回一个新的Promise实例。</p> 
<p><strong>catch方法</strong><br> 为Promise添加拒绝状态时的回调函数。返回一个新的Promise。p.catch(onRejected);相当于调用p.then(undefined,onRejected);</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 语法格式</span>
p<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">// rejection}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 参数</span>
onRejected  <span class="token comment">// 函数，当Promise状态为rejected失败时调用</span>
reason  <span class="token comment">// 失败的原因。</span>

<span class="token comment">// 返回值</span>
返回一个新Promise。
<span class="token comment">// 调用catch时无参数，则返回一个新期约。新期约的状态和结果值和调用then方法的期约一致。</span>

<span class="token keyword">catch</span>方法返回的新期约遵循以下规则。若catch中的回调函数：
<span class="token operator">**</span>返回rejected状态的Promise<span class="token operator">**</span>，则catch方法返回一个rejected状态的新期约，并且新期约结果值为回调函数返回语句中期约的拒绝原因。
<span class="token operator">**</span>抛出一个错误<span class="token operator">**</span>，则catch方法返回一个rejected的新期约，并且新期约结果值为抛出的错误。
<span class="token operator">**</span>其余情况<span class="token operator">**</span>都返回一个fulfilled状态的新期约。
</code></pre> 
<p><strong>finally方法</strong><br> 回调函数，无论Promise是否成功完成后都需要执行的代码。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 语法格式</span>
p<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span>onFinally<span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// settled (fulfilled or rejected)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 参数</span>
onFinally	<span class="token comment">// Promise为已确定settled状态被调用的回调函数</span>

<span class="token comment">// 返回值</span>
返回一个新的Promise。Promise的状态和结果值和调用finally的Promise相同。
</code></pre> 
<blockquote> 
 <p>then()，catch()，finally() 都定义在原型对象<code>Promise.prototype</code>上。</p> 
</blockquote> 
<h4><a id="Promise_156"></a>Promise术语回顾</h4> 
<p>创建promise时，它既不是成功也不是失败状态。这个状态叫作pending（待定）。<br> 当promise返回时，称为 resolved（已解决）.<br> 一个成功resolved的promise称为fullfilled（实现）。它返回一个值，可以通过将.then()块链接到promise链的末尾来访问该值。 .then()块中的执行程序函数将包含promise的返回值。<br> 一个不成功resolved的promise被称为rejected（拒绝）了。它返回一个原因（reason），一条错误消息，说明为什么拒绝promise。可以通过将.catch()块链接到promise链的末尾来访问此原因。</p> 
<h4><a id="Promises__callbacks_162"></a>Promises 对比 callbacks</h4> 
<p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p> 
<p>然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p> 
<p>您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。<br> Promise总是严格按照它们放置在事件队列中的顺序调用。<br> 错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。</p> 
<pre><code class="prism language-javascript"><span class="token function">chooseToppings</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">toppings</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">placeOrder</span><span class="token punctuation">(</span>toppings<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">order</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">collectOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">pizza</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">eatPizza</span><span class="token punctuation">(</span>pizza<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>



<span class="token function">chooseToppings</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">toppings</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token function">placeOrder</span><span class="token punctuation">(</span>toppings<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">order</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token function">collectOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">pizza</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">eatPizza</span><span class="token punctuation">(</span>pizza<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="Promise_VS_thenable_194"></a>Promise VS thenable</h4> 
<p>thenable - Any object that has a method named “then” is called a “thenable” object.</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// some codes are here</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// obj is a thenable object</span>
</code></pre> 
<pre><code class="prism language-javascript"><span class="token comment">// Resolve一个thenable对象</span>
<span class="token keyword">var</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">onFulfill<span class="token punctuation">,</span> onReject</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">onFulfill</span><span class="token punctuation">(</span><span class="token string">"fulfilled!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1 <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token comment">// true, 这是一个Promise对象</span>

p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出"fulfilled!"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 不会被调用</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Thenable在callback之前抛出异常</span>
<span class="token comment">// Promise rejects</span>
<span class="token keyword">var</span> thenable <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Throwing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"Resolving"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span><span class="token punctuation">;</span>
p2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 不会被调用</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Throwing</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Thenable在callback之后抛出异常</span>
<span class="token comment">// Promise resolves</span>
<span class="token keyword">var</span> thenable <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"Resolving"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Throwing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span><span class="token punctuation">;</span>
p3<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出"Resolving"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 不会被调用</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<p>every promise object is just a thenable object, but every thenable object is not a promise object.</p> 
<h3><a id="ES8_247"></a>异步函数（ES8）</h3> 
<p>ES6期约模式在ECMAScript函数中的应用。<br> async/await。使得同步方式书写的代码能够异步执行。解决利用异步结构组织代码的问题。<br> <strong>async</strong> 关键字用于声明异步函数。异步函数始终返回期约对象。异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这个值会被 Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。<br> <strong>await</strong> 关键字可以暂停异步函数代码的执行，等待期约解决。await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。await 关键字尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。<br> 实际async是一个标识符，标识函数是异步函数。await真正进行异步操作，控制停止和恢复执行。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 异步函数</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 
 <span class="token keyword">throw</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 抛出错误，返回拒绝原因为3的拒绝期约 </span>
 Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 单独的拒绝期约不会被异步函数捕获</span>

 <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">throw</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抛出错误。返回期约拒绝原因为3的拒绝期约</span>
 <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对拒绝期约使用await会释放（unwrap）错误值，即将拒绝期约返回</span>
 <span class="token comment">// 除抛出错误和拒绝期约，其他情况都需要return才能返回期约</span>
 
 <span class="token keyword">return</span> 原始值<span class="token operator">/</span>对象<span class="token operator">/</span>期约<span class="token operator">/</span>thenable对象<span class="token punctuation">;</span>  <span class="token comment">// 返回相应的期约</span>
 <span class="token comment">// 若异步函数没有返回语句，则自动返回状态为fulfilled、结果值为undefined的期约</span>
 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这行代码不会执行</span>
<span class="token punctuation">}</span> 
<span class="token comment">// 给返回的期约添加一个拒绝处理程序</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 1</span>
<span class="token comment">// 2</span>
<span class="token comment">// 3</span>
</code></pre> 
<blockquote> 
 <p>Anything you <code>await</code> is passed through <code>Promise.resolve()</code> , so you can safely <code>await</code> non-native promises.</p> 
</blockquote> 
<h3><a id="_278"></a>总结</h3> 
<p>添加期约和异步函数的 <strong>目的</strong>：掌握单线程 JavaScript 运行时的异步行为</p> 
<p><strong>期约</strong> 主要功能是为异步代码提供了清晰的抽象。</p> 
<ul><li>可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。</li></ul> 
<p><strong>异步函数</strong> 将期约应用于 JavaScript 函数的结果。</p> 
<ul><li>异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/411bd0b91bfb4e4338d5cdafed48b408/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多数据源配置下，解决org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c2b5e01370cc97699459a70e9ce75d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pinia 入门及使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>