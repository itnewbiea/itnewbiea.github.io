<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java设计模式—组合模式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java设计模式—组合模式" />
<meta property="og:description" content="组合模式是一种常见的设计模式（但我感觉有点复杂）也叫合成模式，有时又叫做部分-整体模式，主要是用来描述部分与整体的关系。
个人理解：组合模式就是将部分组装成整体。
定义如下：
将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
通用类图如下：
组合模式的包含角色：
● Component 抽象构件角色
定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。
● Leaf 叶子构件
叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。
● Composite 树枝构件
树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。
通用源代码：
抽象构件 public abstract class Component { //个体和整体都具有的共享 public void do Something(){ //编写业务逻辑 } } 树枝构件 public class Composite extends Component { //构件容器 private Array List&lt;Component&gt; component Array List = new Array List&lt;Component&gt;() //增加一个叶子构件或树枝构件 public void add(Component component){ this.component Array List.add(component); } //删除一个叶子构件或树枝构件 public void remove(Component component){ this.component Array List.remove(component); } //获得分支下的所有叶子构件和树枝构件 public Array List&lt;Component&gt; get Children(){ return this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e28cd3242c455803135eb648e91a6aae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-10T19:31:00+08:00" />
<meta property="article:modified_time" content="2016-09-10T19:31:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java设计模式—组合模式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p> </p> 
 <p><span style="font-size:24px;"><strong>组合模式是一种常见的设计模式（但我感觉有点复杂）也叫合成模式，有时又叫做部分-整体模式，主要是用来描述部分与整体的关系。</strong></span></p> 
 <p><span style="font-size:24px;"><strong></strong></span> </p> 
 <p><strong><span style="font-size:24px;">个人理解：组合模式就是将部分组装成整体。</span></strong></p> 
 <p> </p> 
 <p><span style="font-size:24px;"><strong>定义如下：</strong></span></p> 
 <p><span style="font-size:24px;"><strong>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</strong></span></p> 
 <p> </p> 
 <p><span style="font-size:14px;">通用类图如下：</span></p> 
 <p><img alt="" src="https://images2.imgbox.com/3b/1d/CFI0HBUW_o.jpg"></p> 
 <p> </p> 
 <p><span style="font-size:24px;">组合模式的包含角色：</span></p> 
 <p><span style="font-size:18px;"><br><strong>● Component 抽象构件角色</strong><br> 定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。</span></p> 
 <p><span style="font-size:18px;"><strong>● Leaf 叶子构件</strong><br> 叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br><strong>● Composite 树枝构件</strong><br> 树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</span><br></p> 
 <p> </p> 
 <p><span style="font-size:24px;"><strong>通用源代码：</strong></span></p> 
 <pre><code class="language-java">抽象构件
public abstract class Component {
     //个体和整体都具有的共享
     public void do Something(){
             //编写业务逻辑
     }
}
</code></pre> 
 <p><br>  </p> 
 <pre><code class="language-java">树枝构件
public class Composite extends Component {
     //构件容器
     private Array List&lt;Component&gt; component Array List = new Array List&lt;Component&gt;()
     //增加一个叶子构件或树枝构件
     public void add(Component component){
             this.component Array List.add(component);
     }
     //删除一个叶子构件或树枝构件
     public void remove(Component component){
             this.component Array List.remove(component);
     }    
 //获得分支下的所有叶子构件和树枝构件
     public Array List&lt;Component&gt; get Children(){
             return this.component Array List;
     }
}
</code></pre> 
 <p><br><br><span style="font-size:18px;">树叶节点是没有子下级对象的对象，定义参加组合的原始对象行为。</span></p> 
 <pre><code class="language-java">树叶构件
public class Leaf extends Component {
     /*
      * 
可以覆写父类方法
      * public void do Something(){
      * 
      * }
      */
}
</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">测试类负责树状结构的建立，并可以通过递归方式遍历整个树。</span></p> 
 <pre><code class="language-java">public class Client {
     public static void main(String[] args) {
            //创建一个根节点
             Composite root = new Composite();
             root.do Something();
             //创建一个树枝构件
             Composite branch = new Composite();
             //创建一个叶子节点
             Leaf leaf = new Leaf();
             //建立整体
             root.add(branch);
             branch.add(leaf);          
     }
     //通过递归遍历树
     public static void display(Composite root){
             for(Component c:root.get Children()){
                  if(c instanceof Leaf){ //叶子节点
                          c.do Something();
                  }else{ //树枝节点
                          display((Composite)c);
                  }
             }
     }
}
</code></pre> 
 <p><br></p> 
 <span style="font-size:18px;"></span> 
 <p><strong><span style="font-size:24px;">组合模式的优点：</span></strong></p> 
 <p><strong><span style="font-size:24px;"></span><br><span style="font-size:18px;">● 高层模块调用简单</span></strong><br><span style="font-size:18px;">一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。<br><strong>● 节点自由增加</strong><br> 使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。</span><br><br></p> 
 <p></p> 
 <span style="font-size:18px;"></span> 
 <p><strong><span style="font-size:24px;">组合模式的缺点：</span></strong></p> 
 <p><strong><span style="font-size:24px;"></span></strong><br><span style="font-size:18px;">       组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围。</span><br></p> 
 <p><span style="font-size:18px;"><span style="font-size:24px;"><strong>使用场景：</strong></span><br> ● 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。<br> ● 从一个整体中能够独立出部分模块或功能的场景。<br></span></p> 
 <p><span style="font-size:24px;"><strong>注意事项：</strong></span></p> 
 <p><span style="font-size:18px;">只要是树形结构，就要考虑使用组合模式，这个一定要记住，只要是要体现局部和整体的关系的时候，而且这种关系还可能比较深，考虑一下组合模式吧。</span></p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/lanzhi/p/6467276.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f34aaffc64b4ca40a09ef37d2908c53/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GCC_RESET_STATUS Definition (check each platform SWI)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0aa01ce59479d3f78ae9613b4fc7d9a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Elasticsearch常用配置及性能参数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>