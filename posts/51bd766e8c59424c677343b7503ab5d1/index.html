<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>这可能是史上最好用的PickerView库了 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="这可能是史上最好用的PickerView库了" />
<meta property="og:description" content="从去年开始大概已经有10个月没有更新博客了，去年结婚，也有了个小baby,导致这么长时间没有更新博客，从今天起博客正常更新，一切步入正轨。今天受一个好朋友的重托分享他的一篇文章：这可能是史上最好用的PickerView库了，同时也欢迎大家关注他的简书账号：笨小孩。下面开启“CV”模式！！！
如果你看到了这篇文章，希望你耐心的把它看完。我保证你认真看完了全部，一定不会让你失望。因为你可能遇到了史上最好用的PickerView库。 本文会通过和目前github上最受欢迎的PickerView库做详细的对比，通过对比你可以清晰的感受它的好用和强大。 先来一下github地址方便那些喜欢直接看代码的同志们：https://github.com/jaaksi/pickerview.
一个非常好用的Android PickerView库，内部提供3种常用类型的Picker。支持扩展自定义Picker。
TimePicker：时间选择器，包含日期MixedTimePicker:：聚合的时间选择器OptionPicker：联动选择器 Screenshot MixedTimePicker.gif
custom.png
APK Demo App下载连接
PickerView README
Picker 通过组装PickerView实现常用的Picker选择器。上面已经列举提供的3中常用的Picker。
BasePicker Picker基类：封装了TopBar，PickerView容器，create and add PickerView方法，Picker弹窗等方法。 三种Picker都继承自BasePicker，你也可以继承它扩展自己的Picker。
API apidescriptionsetPickerBackgroundColor设置picker背景setPadding设置PickerView父容器padding 单位:pxsetTag给Picker 设置tag，用于区分不同的picker等。用法同View setTaggetRootLayout获取PickerView的父容器，创建DefaultTopBar时必须指定setOnPickerChooseListener设置picker取消，确定按钮监听。可用于拦截选中操作setTopBar设置自定义TopBarsetInterceptor设置拦截器createPickerView创建PickerViewgetPickerViews获取Picker中所有的pickerview集合addPicker将创建的PickerView 添加到上面集合中，createPickerView内部已调用该方法findPickerViewByTag通过tag找到对应的PickerViewisScrolling是否滚动未停止。滚动未停止的时候，不响应Picker的取消，确定按键getPickerDialog获取Picker弹窗。可以在new之后设置dialog属性show显示picker弹窗 对比github上最受欢迎的同类库 Android-PickerView 本库将TopBar等通用相关逻辑封装在基类中，并提供代码中创建PickerView方法，不需要再依赖xml。用户自定义Picker时，继承BasePicker，只需要处理自己的逻辑即可，简单便捷。 而对Android-PickerView来说，实现自定义Picker，依然需要处理TopBar等逻辑。造成大量重复代码。 TopBar TopBar:TopBar通过抽象接口ITopBar来管理，实现Picker与TopBar的解耦。提供默认实现DefaultTopBar。可实现接口定制自己的TopBar。
public interface ITopBar { /** * @return topbar view */ View getTopBarView(); /** * @return 取消按钮view */ View getBtnCancel(); /** * @return 确定按钮view */ View getBtnConfirm(); /** * @return title view */ TextView getTitleView(); } DefaultTopBar API apidescriptionsetDividerColor设置topbar bottom line colorsetDividerHeight设置bottom divider line heightgetDivider获取TopBar bottom linegetTitleView获取TopBar title view Interceptor 拦截器：用于在pickerview创建时拦截，设置pickerview的属性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/51bd766e8c59424c677343b7503ab5d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-05T10:43:44+08:00" />
<meta property="article:modified_time" content="2018-03-05T10:43:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">这可能是史上最好用的PickerView库了</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    从去年开始大概已经有10个月没有更新博客了，去年结婚，也有了个小baby,导致这么长时间没有更新博客，从今天起博客正常更新，一切步入正轨。今天受一个好朋友的重托分享他的一篇文章：<a href="https://www.jianshu.com/p/0bfad68b19f1" rel="nofollow">这可能是史上最好用的PickerView库了</a>，同时也欢迎大家关注他的简书账号：<a href="https://www.jianshu.com/u/49d08ec395e4" rel="nofollow">笨小孩</a>。下面开启“CV”模式！！！</p> 
<pre><code class="language-html">如果你看到了这篇文章，希望你耐心的把它看完。我保证你认真看完了全部，一定不会让你失望。因为你可能遇到了史上最好用的PickerView库。 本文会通过和目前github上最受欢迎的PickerView库做详细的对比，通过对比你可以清晰的感受它的好用和强大。</code></pre> 
<p>    先来一下github地址方便那些喜欢直接看代码的同志们：<a href="https://github.com/jaaksi/pickerview">https://github.com/jaaksi/pickerview.</a></p> 
<p>    一个非常好用的Android PickerView库，内部提供3种常用类型的Picker。支持扩展自定义Picker。</p> 
<ol><li>TimePicker：时间选择器，包含日期</li><li>MixedTimePicker:：聚合的时间选择器</li><li>OptionPicker：联动选择器</li></ol> 
<p></p> 
<h3>Screenshot</h3> 
<p><img src="https://images2.imgbox.com/37/55/1mBLSZKp_o.gif" alt=""></p> 
<p><img src="https://images2.imgbox.com/2a/4d/iBM7R8X1_o.gif" alt=""><br></p> 
<p><em>      MixedTimePicker.gif</em></p> 
<p><img src="https://images2.imgbox.com/c9/dd/tzpdn5wA_o.png" alt=""></p> 
<p><em>            custom.png</em></p> 
<p><em></em></p> 
<h3>APK</h3> 
<p><em><a href="https://link.juejin.im?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fgithub.com%252Fjaaksi%252Fpickerview%252Fblob%252Fmaster%252Fdocs%252Fapp-debug.apk" rel="nofollow">Demo App</a>下载连接<br></em></p> 
<p></p> 
<h3>PickerView</h3> 
<p><a href="https://link.juejin.im?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fgithub.com%252Fjaaksi%252Fpickerview%252Fblob%252Fmaster%252FREADME_PickerView.md" rel="nofollow">README<br></a></p> 
<p></p> 
<h3>Picker</h3> 
<p>通过组装PickerView实现常用的Picker选择器。上面已经列举提供的3中常用的Picker。</p> 
<p></p> 
<h3>BasePicker</h3> 
<p>Picker基类：封装了TopBar，PickerView容器，create and add PickerView方法，Picker弹窗等方法。 三种Picker都继承自BasePicker，你也可以继承它扩展自己的Picker。</p> 
<p></p> 
<h4>API</h4> 
<table><thead><tr><th>api</th><th>description</th></tr></thead><tbody><tr><td>setPickerBackgroundColor</td><td>设置picker背景</td></tr><tr><td>setPadding</td><td>设置PickerView父容器padding 单位:px</td></tr><tr><td>setTag</td><td>给Picker 设置tag，用于区分不同的picker等。用法同View setTag</td></tr><tr><td>getRootLayout</td><td>获取PickerView的父容器，创建DefaultTopBar时必须指定</td></tr><tr><td>setOnPickerChooseListener</td><td>设置picker取消，确定按钮监听。可用于拦截选中操作</td></tr><tr><td>setTopBar</td><td>设置自定义TopBar</td></tr><tr><td>setInterceptor</td><td>设置拦截器</td></tr><tr><td>createPickerView</td><td>创建PickerView</td></tr><tr><td>getPickerViews</td><td>获取Picker中所有的pickerview集合</td></tr><tr><td>addPicker</td><td>将创建的PickerView 添加到上面集合中，createPickerView内部已调用该方法</td></tr><tr><td>findPickerViewByTag</td><td>通过tag找到对应的PickerView</td></tr><tr><td>isScrolling</td><td>是否滚动未停止。滚动未停止的时候，不响应Picker的取消，确定按键</td></tr><tr><td>getPickerDialog</td><td>获取Picker弹窗。可以在new之后设置dialog属性</td></tr><tr><td>show</td><td>显示picker弹窗</td></tr></tbody></table> 
<br> 
<pre><code class="language-html">对比github上最受欢迎的同类库 Android-PickerView
本库将TopBar等通用相关逻辑封装在基类中，并提供代码中创建PickerView方法，不需要再依赖xml。用户自定义Picker时，继承BasePicker，只需要处理自己的逻辑即可，简单便捷。
而对Android-PickerView来说，实现自定义Picker，依然需要处理TopBar等逻辑。造成大量重复代码。
</code></pre> 
<h4>TopBar</h4> 
<p>TopBar:TopBar通过抽象接口ITopBar来管理，实现Picker与TopBar的解耦。提供默认实现DefaultTopBar。可实现接口定制自己的TopBar。</p> 
<pre><code class="language-html">   public interface ITopBar {
     /**
      * @return topbar view
      */
     View getTopBarView();

     /**
      * @return 取消按钮view
      */
     View getBtnCancel();

     /**
      * @return 确定按钮view
      */
     View getBtnConfirm();

     /**
      * @return title view
      */
     TextView getTitleView();
   }
</code></pre> 
<h4>DefaultTopBar API</h4> 
<table><thead><tr><th>api</th><th>description</th></tr></thead><tbody><tr><td>setDividerColor</td><td>设置topbar bottom line color</td></tr><tr><td>setDividerHeight</td><td>设置bottom divider line height</td></tr><tr><td>getDivider</td><td>获取TopBar bottom line</td></tr><tr><td>getTitleView</td><td>获取TopBar title view</td></tr></tbody></table> 
<h4>Interceptor</h4> 
<p>拦截器：用于在pickerview创建时拦截，设置pickerview的属性。</p> 
<pre><code class="language-html">Picker内部并不提供对PickerView的设置方法，而是通过Interceptor实现。这种设计用来实现Picker和PickerView的属性设置完美解耦。</code></pre> 
<pre><code class="language-html">private void init(){
    mTimePicker.setInterceptor(new BasePicker.Interceptor() {
      @Override public void intercept(PickerView pickerView) {
        pickerView.setVisibleItemCount(5);
        // 将年月设置为循环的
        int type = (int) pickerView.getTag();
        if (type == TimePicker.TYPE_YEAR || type == TimePicker.TYPE_MONTH) {
          pickerView.setIsCirculation(true);
        }
      }
    })
   }
</code></pre> 
<p>    这一点对比 <a href="https://link.juejin.im?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fgithub.com%252FBigkoo%252FAndroid-PickerView%252Fblob%252Fmaster%252Fpickerview%252Fsrc%252Fmain%252Fjava%252Fcom%252Fbigkoo%252Fpickerview%252FTimePickerView.java" rel="nofollow">Android-PickerView</a>, 每个Picker都需要声明对PickerView的设置方法，与PickerView严重耦合。需要开发者copy大量重复代码，且无法区分每一个PickerView设置不同的属性。</p> 
<p></p> 
<h3>TimePicker</h3> 
<p>常用的时间选择器，支持 年、月、日、时、分</p> 
<p></p> 
<p>常用的时间选择器，支持 年、月、日、时、分</p> 
<ul><li>时间类型type的设计：自由组合、随心所欲(当然应该是有意义的)</li></ul> 
<pre><code>  TYPE_YEAR | TYPE_MONTH | TYPE_DAY | TYPE_HOUR | TYPE_MINUTE
</code></pre> 
<p>对比 Android-PickerView <a href="https://link.juejin.im?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fgithub.com%252FBigkoo%252FAndroid-PickerView%252Fblob%252Fmaster%252Fpickerview%252Fsrc%252Fmain%252Fjava%252Fcom%252Fbigkoo%252Fpickerview%252FTimePickerView.java" rel="nofollow">TimePickerView</a></p> 
<pre><code class="language-html"> /**
  * Android-PickerView中的设置type方法：参数设置麻烦且不易理解
  * 长度必须为6的数组，表示年月日时分秒 的显示与否，不设置则默认全部显示
  */
  setType(boolean[] type)
  
  // 本项目设置type方法：简单易懂，组合方便
  setType(TYPE_DATE | TYPE_HOUR)</code></pre> 
<ul><li>完美支持时间区间设置以及选中联动</li><li>支持Format，如显示今年，明年</li></ul> 
<h4>API</h4> 
<table><thead><tr><th>api</th><th>description</th></tr></thead><tbody><tr><td>type</td><td>时间类型，需要在Builder构造方法中指定，不能改变</td></tr><tr><td>OnTimeSelectListener</td><td>选中时间回调，需要在Builder构造方法中指定，不能改变</td></tr><tr><td>setRangDate</td><td>设置起止时间</td></tr><tr><td>setSelectedDate</td><td>设置选中时间戳</td></tr><tr><td>setInterceptor</td><td>设置拦截器</td></tr><tr><td>setFormatter</td><td>设置Formatter，内部提供默认的Formatter</td></tr><tr><td>create</td><td>通过Builder构建 TimePicker</td></tr><tr><td> </td><td>以上是TimePicker.Builder的，下面是TimePicker的</td></tr><tr><td>setFormatter</td><td>同上</td></tr><tr><td>setSelectedDate</td><td>同上</td></tr><tr><td>getType</td><td>获取type</td></tr><tr><td>hasType</td><td>判断是否包含某种type</td></tr></tbody></table> 
<h4>Formatter</h4> 
<p>TimePicker Formatter：用于根据type和num格式化时间文案</p> 
<pre><code>  public interface Formatter {
    /**
     * 根据type和num格式化时间
     *
     * @param picker picker
     * @param type 并不是模式，而是当前item所属的type，如年，时
     * @param position position
     * @param num position item显示的数字
     */
    CharSequence format(TimePicker picker, int type, int position, int num);
  }
</code></pre> 
<p>内部提供默认的 Formatter实现DefaultFormatter。用户可以设置自定义Formatter或继承DefaultFormatter进行扩展。</p> 
<blockquote> 
 <p><em>TimePicker初始化，如果未设置时间区间，会使用默认区间。三种Picker都采用Builder模式初始化。且用户自定义的Picker也应该采用这种模式进行初始化。</em></p> 
</blockquote> 
<h4>Simple Example</h4> 
<pre><code>    mTimePicker = new TimePicker.Builder(mActivity, type, this)
      // 设置时间区间
      .setRangDate(1526361240000L, 1893563460000L)
      // 设置选中时间
      //.setSelectedDate()
      // 设置pickerview样式
      .setInterceptor(new BasePicker.Interceptor() {
        @Override public void intercept(PickerView pickerView) {
          pickerView.setVisibleItemCount(5);
          // 将年月设置为循环的
          int type = (int) pickerView.getTag();
          if (type == TimePicker.TYPE_YEAR || type == TimePicker.TYPE_MONTH) {
            pickerView.setIsCirculation(true);
          }
        }
      })
      // 设置 Formatter
      .setFormatter(new TimePicker.DefaultFormatter() {
        // 自定义Formatter显示去年，今年，明年
        @Override public CharSequence format(TimePicker picker, int type, int position, int num) {
          if (type == TimePicker.TYPE_YEAR) {
            int offset = num - mCurrYear;
            if (offset == -1) return "去年";
            if (offset == 0) return "今年";
            if (offset == 1) return "明年";
            return num + "年";
          }

          return super.format(picker, type, position, num);
        }
      }).create();

    //mTimePicker.setSelectedDate(1549349843000L);
    mTimePicker.show();
</code></pre> 
<h3>MixedTimePicker</h3> 
<p>常用的聚合时间选择器。日期（年、月、日）聚合，时间（小时、分钟）聚合。</p> 
<ul><li>混合模式：github上的TimePicker库基本都不提供该种类型的Picker</li><li>支持自定义日期格式，时间格式</li><li>支持设置时间间隔</li><li>支持设置区间以及选中联动</li><li>支持设置纯日期，纯时间模式，采用type同TimePicker</li></ul> 
<h4>API</h4> 
<table><thead><tr><th>api</th><th>description</th></tr></thead><tbody><tr><td>type</td><td>类型，需要在Builder构造方法中指定，不能改变</td></tr><tr><td>OnTimeSelectListener</td><td>选中时间回调，需要在Builder构造方法中指定，不能改变</td></tr><tr><td>setRangDate</td><td>设置起止时间</td></tr><tr><td>setSelectedDate</td><td>设置选中时间戳</td></tr><tr><td>setTimeMinuteOffset</td><td>设置时间间隔分钟数(60%offset==0才有效)，以0为起始边界</td></tr><tr><td>setContainsStarDate</td><td>设置mTimeMinuteOffset作用时，是否包含超出的startDate</td></tr><tr><td>setContainsEndDate</td><td>设置mTimeMinuteOffset作用时，是否包含超出的endDate</td></tr><tr><td>setInterceptor</td><td>设置拦截器</td></tr><tr><td>setFormatter</td><td>设置Formatter，内部提供默认的Formatter</td></tr><tr><td>create</td><td>通过Builder构建 MixedTimePicker</td></tr><tr><td> </td><td>以上是MixedTimePicker.Builder的，下面是MixedTimePicker的</td></tr><tr><td>setFormatter</td><td>同上</td></tr><tr><td>setSelectedDate</td><td>同上</td></tr><tr><td>getType</td><td>获取type</td></tr><tr><td>hasType</td><td>判断是否包含某种type</td></tr></tbody></table> 
<h4>Formatter</h4> 
<p>MixedTimePicker Formatter：用于自定义日期和时间格式。内部提供默认的 Formatter实现。</p> 
<pre><code>  public interface Formatter {
    /**
     * 用户可以自定义日期格式和时间格式
     *
     * @param picker picker
     * @param date 当前状态对应的日期或者时间
     * @param position 当前type所在的position
     */
    CharSequence format(MixedTimePicker picker, int type, Date date, int position);
    }
</code></pre> 
<blockquote> 
 <p>MixedTimePicker 的 Formatter 完美体现了Formatter设计的精妙之处。用户可以根据回调中的type和date自定义日期和时间格式。比如显示今天，或 xx月xx日 星期 x</p> 
</blockquote> 
<h4>Simple Example</h4> 
<pre><code>    mTimePicker = new MixedTimePicker.Builder(mActivity, MixedTimePicker.TYPE_ALL, this)
      // 设置不包含超出的结束时间&lt;=
      .setContainsEndDate(false)
      // 设置时间间隔为30分钟
      .setTimeMinuteOffset(30)
      .setRangDate(1517771651000L, 1577976666000L)
      .setFormatter(new MixedTimePicker.DefaultFormatter() {
        @Override
        public CharSequence format(MixedTimePicker picker, int type, Date date, int position) {
          if (type == MixedTimePicker.TYPE_DATE) {
            CharSequence text;
            int dayOffset = DateUtil.getDayOffset(date.getTime(), System.currentTimeMillis());
            if (dayOffset == 0) {
              text = "今天";
            } else if (dayOffset == 1) {
              text = "明天";
            } else { // xx月xx日 星期 x
              text = mDateFormat.format(date);
            }
            return text;
          }
          return super.format(picker, type, date, position);
        }
      })
      .create();
    // 2018/2/5 03:14:11 - 2020/1/2 22:51:6
    Dialog pickerDialog = mTimePicker.getPickerDialog();
    pickerDialog.setCanceledOnTouchOutside(true);
    DefaultTopBar topBar = (DefaultTopBar) mTimePicker.getTopBar();
    topBar.getTitleView().setText("请选择时间");
</code></pre> 
<blockquote> 
 <p><em>不同于TimePicker, MixedTimePicker 由于支持纯时间模式（日期取选中时间的日期），&lt;font color=red&gt;不提供默认区间。如果模式中包含日期模式，则会强制要求设置时间区间&lt;/font&gt;</em></p> 
</blockquote> 
<h3>OptionPicker</h3> 
<ul><li>支持设置层级</li><li>构造数据源及其简单，只需要实现OptionDataSet接口</li><li>支持通过对应选中的values设置选中项。内部处理选中项逻辑，避免用户记录下标且麻烦的遍历处理</li></ul> 
<blockquote> 
 <p>对比 Android-PickerView的 <a href="https://link.juejin.im?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fgithub.com%252FBigkoo%252FAndroid-PickerView%252Fblob%252Fmaster%252Fpickerview%252Fsrc%252Fmain%252Fjava%252Fcom%252Fbigkoo%252Fpickerview%252FOptionsPickerView.java" rel="nofollow">OptionsPickerView</a></p> 
</blockquote> 
<table><thead><tr><th>function</th><th>Android-PickerViews</th><th>本控件</th></tr></thead><tbody><tr><td>多级</td><td>最多支持3级(写死的)</td><td>构造时设置级别(无限制)</td></tr><tr><td>构造数据源</td><td>需要构建每一级的集合，二三级为嵌套</td><td>一级数据entity实现OptionDataSet接口即可</td></tr><tr><td>设置数据源</td><td>提供三个方法，分别用于一、二、三级的</td><td>只需要设置一级数据集</td></tr><tr><td>联动选中</td><td>提供三个，只能设置选中的下标。<br>需要用户自己通过多层遍历定位每一级别选中的下标，然后再设置</td><td>只需要传入选中的values(可变长数组)，不需要任何计算</td></tr></tbody></table> 
<p>Android-PickerView 中的 OptionsPickerView 代码。由于不知道层级，所以每个方法都提供3个用来对应（最多）3级选择。</p> 
<pre><code>    // 提供3个选中的方法，分别对应1,2,3级联动的情况
    public void setSelectOptions(int option1)

    public void setSelectOptions(int option1, int option2)

    public void setSelectOptions(int option1, int option2, int option3)

    // 提供3个设置数据源的方法，分别对应1,2,3级联动的情况
    public void setPicker(List&lt;T&gt; optionsItems)

    public void setPicker(List&lt;T&gt; options1Items, List&lt;List&lt;T&gt;&gt; options2Items)

    public void setPicker(List&lt;T&gt; options1Items, List&lt;List&lt;T&gt;&gt; options2Items,
          List&lt;List&lt;List&lt;T&gt;&gt;&gt; options3Items) {
    }
</code></pre> 
<p>本库中的OptionPicker</p> 
<pre><code>/**
   * 根据选中的values初始化选中的position并初始化pickerview数据
   *
   * @param options data
   * @param values 选中数据的value{@link OptionDataSet#getValue()}
   */
  public void setDataWithValues(List&lt;? extends OptionDataSet&gt; options, String... values) {
    mOptions = options;
    setSelectedWithValues(values);
  }

  /**
   * 根据选中的values初始化选中的position
   *
   * @param values 选中数据的value{@link OptionDataSet#getValue()}，如果values[0]==null，则进行默认选中，其他为null认为没有该列
   */
  public void setSelectedWithValues(String... values) {
  ...
  }
</code></pre> 
<blockquote> 
 <p>如上面对比表格中所列举的，无论是层级，构造数据源和设置数据源，还是设置选中的选项，本库的API都十分简单，方便。</p> 
</blockquote> 
<h4>API</h4> 
<table><thead><tr><th>api</th><th>description</th></tr></thead><tbody><tr><td>mHierarchy</td><td>层级，需要在Builder构造方法中指定，不能改变</td></tr><tr><td>OnOptionSelectListener</td><td>选中回调，需要在Builder构造方法中指定，不能改变</td></tr><tr><td>setInterceptor</td><td>设置拦截器</td></tr><tr><td>setFormatter</td><td>设置Formatter</td></tr><tr><td>create</td><td>通过Builder构建 OptionPicker</td></tr><tr><td> </td><td>以上是OptionPicker.Builder的，下面是OptionPicker的</td></tr><tr><td>setFormatter</td><td>同上</td></tr><tr><td>setDataWithValues</td><td>根据选中的values初始化选中的position并初始化pickerview数据。<br>values参数为可变长数组，可以不设置。</td></tr><tr><td>setDataWithIndexs</td><td>设置数据和选中position。不建议使用，建议使用 setDataWithValues</td></tr><tr><td>setSelectedWithValues</td><td>根据选中的values初始化选中的position</td></tr><tr><td>setSelectedWithIndexs</td><td>设置选中的position。不建议使用，建议使用 setSelectedWithValues</td></tr><tr><td>getOptions</td><td>获取数据集</td></tr><tr><td>getSelectedPosition</td><td>获取选中的下标，数组size=mHierarchy，如果为-1表示该列没有数据</td></tr><tr><td>getSelectedOptions</td><td>获取选中的选项，如果指定index为null则表示该列没有数据</td></tr></tbody></table> 
<blockquote> 
 <p>需要注意的是：本库中的OptionPicker只用于联动的，不支持多级别且不联动。 基本没有这种需求，如果大家有这种需求，我会在后续迭代中支持。</p> 
</blockquote> 
<h3>Others</h3> 
<blockquote> 
 <p>奇葩设计：部分default属性声明为static而非final</p> 
</blockquote> 
<h4>全局设置default属性</h4> 
<p>奇葩也好，亮点也罢。作为一个UI控件，不同的app，不同的UI，不同的产品自然会有不同的样式。<br> 考虑到在一个app中我们会用到很多Picker，而我们又需要定制自己的UI的样式，如果通过动态方法设置样式就太麻烦了。<br> 故做此设计。你可以通过配置这些static变量来快速定制一个满足自己app样式需求的Picker。<br> 当然你也可以通过封装方法来处理PickerView，Picker,装饰器等样式，但这样一样十分麻烦。我相信你自己都会烦。</p> 
<h4>静态默认值</h4> 
<blockquote> 
 <p><em>所有的这些静态属性值都以 sDefault 开头</em></p> 
</blockquote> 
<ul><li>BasePickerView</li></ul> 
<table><thead><tr><th>field</th><th>description</th><th>defaultValue</th></tr></thead><tbody><tr><td>sDefaultVisibleItemCount</td><td>默认可见的item个数</td><td>5</td></tr><tr><td>sDefaultItemSize</td><td>默认itemSize</td><td>50(dp)</td></tr><tr><td>sDefaultIsCirculation</td><td>默认是否循环</td><td>false</td></tr></tbody></table> 
<ul><li>PickerView</li></ul> 
<table><thead><tr><th>field</th><th>description</th><th>defaultValue</th></tr></thead><tbody><tr><td>sOutTextSize</td><td>default out text size</td><td>18(dp)</td></tr><tr><td>sCenterTextSize</td><td>default center text size</td><td>22(dp)</td></tr><tr><td>sCenterColor</td><td>default center text color</td><td>Color.BLUE</td></tr><tr><td>sOutColor</td><td>default out text color</td><td>Color.GRAY</td></tr></tbody></table> 
<ul><li>BasePicker</li></ul> 
<table><thead><tr><th>field</th><th>description</th><th>defaultValue</th></tr></thead><tbody><tr><td>sDefaultPaddingRect</td><td>pickerView父容器的 default padding</td><td>null(无padding)</td></tr><tr><td>sDefaultPickerBackgroundColor</td><td>default picker background color</td><td>Color.WHITE</td></tr><tr><td>sDefaultTopBarCreator</td><td>用于构建自定义defaultTopBar的接口</td><td>null</td></tr></tbody></table> 
<ul><li>DefaultCenterDecoration</li></ul> 
<table><thead><tr><th>field</th><th>description</th><th>defaultValue</th></tr></thead><tbody><tr><td>sDefaultLineColor</td><td>default line color</td><td>Color.BLUE</td></tr><tr><td>sDefaultLineWidth</td><td>default line width</td><td>1(dp)</td></tr><tr><td>sDefaultDrawable</td><td>default item background drawable</td><td>null</td></tr><tr><td>sDefaultMarginRect</td><td>default line margin</td><td>null(无margin)</td></tr></tbody></table> 
<blockquote> 
 <p><strong>建议初始化这些属性值放到Application中完成，避免app发生crash而导致失效</strong></p> 
</blockquote> 
<h4>Simple Example</h4> 
<pre><code>public class MyApplication extends Application {

  @Override public void onCreate() {
    super.onCreate();
    // 建议在application中初始化picker 默认属性实现全局设置
    initDefaultPicker();
  }

  private void initDefaultPicker() {
    // 利用修改静态默认属性值，快速定制一套满足自己app样式需求的Picker.
    // BasePickerView
    PickerView.sDefaultVisibleItemCount = 3;
    PickerView.sDefaultItemSize = 50;
    PickerView.sDefaultIsCirculation = true;

    // PickerView
    PickerView.sOutTextSize = 18;
    PickerView.sCenterTextSize = 18;
    PickerView.sCenterColor = Color.RED;
    PickerView.sOutColor = Color.GRAY;

    // BasePicker
    int padding = Util.dip2px(this, 20);
    BasePicker.sDefaultPaddingRect = new Rect(padding, padding, padding, padding);
    BasePicker.sDefaultPickerBackgroundColor = Color.WHITE;
    // 自定义 TopBar
    BasePicker.sDefaultTopBarCreator = new BasePicker.IDefaultTopBarCreator() {
      @Override public ITopBar createDefaultTopBar(LinearLayout parent) {
        return new CustomTopBar(parent);
      }
    };

    // DefaultCenterDecoration
    DefaultCenterDecoration.sDefaultLineWidth = 1;
    DefaultCenterDecoration.sDefaultLineColor = Color.RED;
    //DefaultCenterDecoration.sDefaultDrawable = new ColorDrawable(Color.WHITE);
    int leftMargin = Util.dip2px(this, 10);
    int topMargin = Util.dip2px(this, 2);
    DefaultCenterDecoration.sDefaultMarginRect =
      new Rect(leftMargin, -topMargin, leftMargin, -topMargin);
  }
}
</code></pre> 
<h3>Change Log</h3> 
<blockquote> 
 <p>v1.0.0(2018-03-03)</p> 
</blockquote> 
<ul><li>release v1.0.0</li></ul> 
<h3>Gradle</h3> 
<p>compile '<a href="https://link.juejin.im?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dorg.jaaksi%253Apickerview%253A1.0.0%2540aar%2527" rel="nofollow">org.jaaksi:pickerview:1.0.0@aar'</a></p> 
<h3>Thanks</h3> 
<ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fgithub.com%252F1993hzw%252FAndroids%252Fblob%252Fmaster%252Fandroids%252Fsrc%252Fcn%252Fforward%252Fandroids%252Fviews%252FScrollPickerView.java" rel="nofollow">ScrollPickerView</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fgithub.com%252FBigkoo%252FAndroid-PickerView" rel="nofollow">Android-PickerView</a></li></ul> 
<blockquote> 
 <p>感谢你耐心的看完。欢迎大家提意见。<br> Github地址：<a href="https://github.com/jaaksi/pickerview">https://github.com/jaaksi/pickerview</a><br></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5811d018c9c7b21e849dd710761e1236/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTML5详细学习资料</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba0055bfbf4a86fb63ea8481f46ca666/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MATLAB提取矩阵中的一部分</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>