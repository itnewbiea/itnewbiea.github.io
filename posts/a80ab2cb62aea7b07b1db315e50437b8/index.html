<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Webpack下多环境配置的思路 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Webpack下多环境配置的思路" />
<meta property="og:description" content="前言 由于前后端分离的前端应用脱离了后端的支持，在单独开发前端应用时，页面调试时使用固定的开发环境地址还好，如果出现在本地开发时需要调试不同环境的远端API，或者需要将应用部署到不同环境的服务器上时，如果不将这些环境对应的服务器地址、环境专属变量等单独配置，也许每次切换环境都需要修改大量代码。网上关于这部分的资料较少，所以下面将以用vue-cli init命令生成的Vue/Webpack项目作为例子，介绍一下我当前正在使用的简单的多环境配置的思路。
1、理想中的多环境配置 在后端开发中，项目中不同环境对应的参数配置在不同的配置文件中。当需要打包基于Maven的Java项目时，通常只需要在打包命令的后面加上-P参数指定Profile环境，即可打包出对应环境的包，同理前端在使用webpack开发或者打包时如果也能这么做，就会方便很多。
/* maven常用打包命令 */ mvn clean package -P prod 复制代码 而在前端项目中，调试与打包命令vue-cli init已经为我们在package.json中生成好了。
/* /package.json */ &#34;scripts&#34;: { &#34;dev&#34;: &#34;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&#34;, &#34;start&#34;: &#34;npm run dev&#34;, &#34;lint&#34;: &#34;eslint --ext .js,.vue src&#34;, &#34;build&#34;: &#34;node build/build.js&#34; } 复制代码 如果可以将这些命令改造成后端中类似的打包命令，就很方便了，例如：
/* 改造后的命令，只是打个比方，实际并不一定是这样 */ &#34;scripts&#34;: { &#34;start:dev&#34;: &#34;npm run dev -P dev&#34;, &#34;build:test&#34;: &#34;node build/build.js -P test&#34; } /* 命令行 */ $ npm run start:dev //本地调试，开发环境 $ npm run build:test //打包，测试环境 复制代码 所以首先需要解决的是如何把参数传递到调试/打包的脚本中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a80ab2cb62aea7b07b1db315e50437b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-26T01:57:24+08:00" />
<meta property="article:modified_time" content="2018-06-26T01:57:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Webpack下多环境配置的思路</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h3 class="heading">前言</h3> 
 <p>由于前后端分离的前端应用脱离了后端的支持，在单独开发前端应用时，页面调试时使用固定的开发环境地址还好，如果出现在本地开发时需要调试不同环境的远端API，或者需要将应用部署到不同环境的服务器上时，如果不将这些环境对应的服务器地址、环境专属变量等单独配置，也许每次切换环境都需要修改大量代码。网上关于这部分的资料较少，所以下面将以用<code>vue-cli init</code>命令生成的<code>Vue/Webpack</code>项目作为例子，介绍一下我当前正在使用的简单的多环境配置的思路。</p> 
 <h3 class="heading">1、理想中的多环境配置</h3> 
 <p>在后端开发中，项目中不同环境对应的参数配置在不同的配置文件中。当需要打包基于<code>Maven</code>的<code>Java</code>项目时，通常只需要在打包命令的后面加上<code>-P</code>参数指定Profile环境，即可打包出对应环境的包，同理前端在使用<code>webpack</code>开发或者打包时如果也能这么做，就会方便很多。</p> 
 <pre><code class="hljs bash copyable">/* maven常用打包命令 */
mvn clean package -P prod
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>而在前端项目中，调试与打包命令<code>vue-cli init</code>已经为我们在<code>package.json</code>中生成好了。</p> 
 <pre><code class="hljs bash copyable">/* /package.json */
<span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,
    <span class="hljs-string">"start"</span>: <span class="hljs-string">"npm run dev"</span>,
    <span class="hljs-string">"lint"</span>: <span class="hljs-string">"eslint --ext .js,.vue src"</span>,
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"node build/build.js"</span>
  }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>如果可以将这些命令改造成后端中类似的打包命令，就很方便了，例如：</p> 
 <pre><code class="hljs bash copyable">/* 改造后的命令，只是打个比方，实际并不一定是这样 */
<span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"start:dev"</span>: <span class="hljs-string">"npm run dev -P dev"</span>,
    <span class="hljs-string">"build:test"</span>: <span class="hljs-string">"node build/build.js -P test"</span>
  }

/* 命令行 */
$ npm run start:dev  //本地调试，开发环境
$ npm run build:<span class="hljs-built_in">test</span>  //打包，测试环境
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>所以首先需要解决的是如何把参数传递到调试/打包的脚本中。</p> 
 <p><em><code>注意：</code>这里想特别说明一下的是，<code>vue-cli</code>脚手架帮我们生成好了整个项目，而且也有对应<code>webpack.dev.conf.js</code>和<code>webpack.prod.conf.js</code>两个分离的<code>webpack</code>配置文件，但由于文件的命名问题（<code>dev.conf.js/prod.conf.js</code>），很容易让人误以为这两个文件就是webpack针对不同环境的配置。但实际上这两个文件一个是用于本地调试时的配置文件，另一个是用于打包部署的配置文件。调试/打包两种模式 与 环境（<code>dev/test/pre/prod</code>等）是可以相互组合的。理论上来讲这两个<code>webpack</code>的配置文件我觉得应该叫<code>webpack.debug.conf.js</code>和<code>webpack.build.conf.js</code>会更贴切一点。</em></p> 
 <h3 class="heading">2、脚本参数化</h3> 
 <p>在<code>node.js</code>中传递参数到脚本中，有多种方法，例如使用<code>process.argv</code>：</p> 
 <pre><code class="hljs bash copyable">/* hello.js */
console.log(<span class="hljs-string">'hello '</span>, process.argv[2]);

/* 命令行 */
$ node ./hello.js tidus
//process.argv = [<span class="hljs-string">'node'</span>, <span class="hljs-string">'./hello.js'</span>, <span class="hljs-string">'tidus'</span>]
hello tidus
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>虽然<code>process.argv</code>很方便，但可配置性不高，所以这里用的是<code>yargs</code>，它是node.js中的一个组件，可以通过<code>npm</code>直接安装。 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fyargs%2Fyargs%2Fblob%2FHEAD%2Fdocs%2Fapi.md" rel="nofollow">===&gt;戳我查看yargs的api文档</a></p> 
 <pre><code class="hljs bash copyable">$ npm install yargs --dev --save

/* hello.js */
const argv = require(<span class="hljs-string">'yargs'</span>).argv;
console.log(<span class="hljs-string">'hello '</span>, argv.env);

/* 命令行 */
$ node ./hello.js --env <span class="hljs-built_in">test</span>
hello <span class="hljs-built_in">test</span>
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>通过<code>yargs</code>可以方便的获取指定名称的命令行参数，接下来就要看看如何利用这个参数实现多文件配置。</p> 
 <h3 class="heading">3、引入环境变量</h3> 
 <p>首先在<code>Webpack</code>的官网中已经有过简单介绍如何配置环境变量的文档，具体参考<a href="https://link.juejin.im?target=https%3A%2F%2Fwebpack.js.org%2Fguides%2Fproduction%2F" rel="nofollow">Webpack Production</a>。简单的来说就是<code>DefinePlugin</code>插件会将我们源码中所有出现的指定字符串替换为我们提供的对象/字符串，不同环境的配置文件则放在<code>/config</code>目录下。</p> 
 <pre><code class="hljs bash copyable">/* /build/webpack.dev.conf.js: */
plugins: [
    new webpack.DefinePlugin({
      // 源码中所有 process.env 都会被替换为
      // <span class="hljs-string">'../config/dev.env'</span>这个module <span class="hljs-built_in">export</span>出来的东西
      <span class="hljs-string">'process.env'</span>: require(<span class="hljs-string">'../config/dev.env'</span>)
    })
]

/* /config/dev.env.js */
<span class="hljs-string">'use strict'</span>
const merge = require(<span class="hljs-string">'webpack-merge'</span>)
const prodEnv = require(<span class="hljs-string">'./prod.env'</span>)

module.exports = merge(prodEnv, {
  NODE_ENV: <span class="hljs-string">'"development"'</span>
})
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>显然我们可以直接用这个插件为我们的多环境变量服务。 我们可以通过上面传入到脚本中的环境参数，动态加载不同环境的配置文件，以达到切换环境的目的。动态加载不同配置环境的代码：</p> 
 <pre><code class="hljs bash copyable">/* /build/webpack.env.conf.js */
// 定义参数配置
const argv = require(<span class="hljs-string">'yargs'</span>).argv;

// 获取环境变量
const env = argv.e;
process.stdout.write(<span class="hljs-string">'the env is '</span>+ env +<span class="hljs-string">'\n'</span>);

// require指定的环境配置文件
const envConfigFile = <span class="hljs-string">"../config/"</span> + env + <span class="hljs-string">".env.js"</span>;
process.stdout.write(<span class="hljs-string">'the env config file is '</span>+ envConfigFile +<span class="hljs-string">'\n'</span>);

// 将require的配置文件原封不动<span class="hljs-built_in">export</span>回出去
module.exports = require(envConfigFile);
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>接下来要将动态加载的环境文件丢到<code>webpack</code>的配置文件中，由于<code>webpack.dev.conf.js</code>和<code>webpack.prod.conf.js</code>都是继承自<code>webpack.base.conf.js</code>，所以我们直接改写<code>wepack.base.conf.js</code>的插件配置部分，直接添加<code>DefinePlugin</code>插件的配置，并去掉原配置文件该插件的配置：</p> 
 <pre><code class="hljs bash copyable">/* /build/webpack.base.conf.js */

// 引入上面的webpack.env.conf模块
const envConfig = require(<span class="hljs-string">'./webpack.env.conf'</span>)
module.exports = {
  ...
  ,
  // 配置DefinePlugin插件
  plugins: [
    // http://vuejs.github.io/vue-loader/en/workflow/production.html
    new webpack.DefinePlugin({
      <span class="hljs-string">'process.env'</span>: envConfig
    })
  ],
  ...
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>然后调试/打包的命令还是用回默认生成的命令，只不过在命令后面传入环境参数：</p> 
 <pre><code class="hljs bash copyable">/* /package.json */
<span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"start:dev"</span>: <span class="hljs-string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --e dev"</span>,
    <span class="hljs-string">"start:test"</span>: <span class="hljs-string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --e test"</span>,
    <span class="hljs-string">"start:pre"</span>: <span class="hljs-string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --e pre"</span>,
    <span class="hljs-string">"start:prod"</span>: <span class="hljs-string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --e prod"</span>,
    <span class="hljs-string">"build:dev"</span>: <span class="hljs-string">"node build/build.js --e dev"</span>,
    <span class="hljs-string">"build:test"</span>: <span class="hljs-string">"node build/build.js --e test"</span>,
    <span class="hljs-string">"build:pre"</span>: <span class="hljs-string">"node build/build.js --e pre"</span>,
    <span class="hljs-string">"build:prod"</span>: <span class="hljs-string">"node build/build.js --e prod"</span>,
  }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>我们的环境配置文件中的内容可以是这样的：</p> 
 <pre><code class="hljs bash copyable">/* /config/test.env.js */
<span class="hljs-string">'use strict'</span>
const merge = require(<span class="hljs-string">'webpack-merge'</span>)
const prodEnv = require(<span class="hljs-string">'./prod.env'</span>)

module.exports = merge(prodEnv, {
  NODE_ENV: <span class="hljs-string">'"test"'</span>,
  API_HOST: <span class="hljs-string">'"http://test.xx.com:8080"'</span>
})
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>然后我们就可以在源码中使用<code>process.env.NODE_ENV</code>来获取我们配置的环境变量的值，甚至可以单独抽离一个api模块：</p> 
 <pre><code class="hljs bash copyable">/* /src/api/index.js */
const API_HOST = process.env.API_HOST;

<span class="hljs-built_in">export</span> default {
  api1: `<span class="hljs-variable">${API_HOST}</span>/path/to/api1`,
  api2: `<span class="hljs-variable">${API_HOST}</span>/path/to/api2`
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>最后，在我们的Vue组件中就可以很方便的使用这些环境配置了：</p> 
 <pre><code class="hljs bash copyable">/* /src/components/HelloWorld.vue */
  import api from <span class="hljs-string">'@/api'</span>;
  <span class="hljs-function"><span class="hljs-title">data</span></span> () {
      <span class="hljs-built_in">return</span> {
        msg: <span class="hljs-string">'Welcome to Your Vue.js App'</span>,
        env: process.env.NODE_ENV,
        api1: api.api1,
        api2: api.api2
      }
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">4、总结</h3> 
 <p>整个流程下来，我们添加了一个<code>webpack.env.conf.js</code>模块，稍微小修改了一下<code>vue-cli</code>生成的3个<code>webpack</code>配置文件，并在<code>config</code>目录下添加了各个环境的配置文件，项目的结构是这样子的： </p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 最终在页面上看到的是这样子的： 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/79ef07e9b4690a4b3553ee68751e9e1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python创建多维数组的3种方式：</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b32760d122caac89122159f5bea8cde/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python导入cv2的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>