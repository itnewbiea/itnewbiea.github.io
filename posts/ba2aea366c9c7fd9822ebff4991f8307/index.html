<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>今日份分享：Flutter自定义之旋转木马 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="今日份分享：Flutter自定义之旋转木马" />
<meta property="og:description" content="先上图，带你回到童年时光:
效果分析 子布局按照圆形顺序放置且平分角度
子布局旋转、支持手势滑动旋转、快速滑动抬手继续旋转、自动旋转
支持X轴旋转
支持前后缩放子布局（起始角度为前，相对位置为后，最前面最大，反而越小）
多个布局叠加时前面遮挡后面
效果难点问题 Flutter如何实现控件布局达到3D效果？Flutter如何实现子控件旋转、自动旋转、手势滑动时关联子控件旋转滚动？快速滑动抬手继续旋转滚动？Flutter如何实现多个布局叠加时前面遮挡后面？ 1.子布局按照圆形顺序放置且平分角度 如上图所示：
如上图所示(参考系:最下方为0度，逆时针旋转角度增加)
第一个点 解：根据已知条件列方程式 x2=width/2&#43;sin(a)*R y2=height/2&#43;cos(a)*R 第二个点 解：根据已知条件列方程式① ① x=width/2-sin(b)*R y=height/2-cos(b)*R 因为b=a-180,所以带入①方程得： ② x=width/2-sin(a-180)*R y=height/2-cos(a-180)*R 又因为sin（k*360&#43;a)=sin(a),所以②方式可以修改为： ③ x=width/2-sin(180&#43;a)*R y=height/2-cos(180&#43;a)*R 又又因为 sin(180&#43;a)=-sin(a),cos(180&#43;a)=-cosa 带入③方程式得： ④ x=width/2&#43;sin(a)*R y=height/2&#43;cos(a)*R 由上面2点计算得，每个子布局的中心点坐标公式统一为： x=width/2&#43;sin(a)*R y=height/2&#43;cos(a)*R 以上所用三角函数公式表：
通过上面计算得出子控件的位置公式后，开始我们的代码。
实现子控件按照圆形布局及平分角度代码如下:
//所有子控件的位置数据 //count:子控件数量； //startAngle:开始角度默认为0; //rotateAngle:偏转角度默认为0; List&lt;Point&gt; _childPointList({Size size = Size.zero}) { List&lt;Point&gt; childPointList = []; double averageAngle = 360 / count; double radius = size.width / 2 - childWidth / 2; for (int i = 0; i &lt; count; i&#43;&#43;) { /********************子布局角度*****************/ double angle = startAngle &#43; averageAngle * i &#43; rotateAngle; //子布局中心点坐标 var centerX = size." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ba2aea366c9c7fd9822ebff4991f8307/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-10T10:46:24+08:00" />
<meta property="article:modified_time" content="2021-12-10T10:46:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">今日份分享：Flutter自定义之旋转木马</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>先上图，带你回到童年时光:</p> 
<p><img src="https://images2.imgbox.com/b3/57/ehvnaoAm_o.gif" alt=""></p> 
<h3><a id="_6"></a>效果分析</h3> 
<ul><li> <p>子布局按照圆形顺序放置且平分角度</p> </li><li> <p>子布局旋转、支持手势滑动旋转、快速滑动抬手继续旋转、自动旋转</p> </li><li> <p>支持X轴旋转</p> </li><li> <p>支持前后缩放子布局（起始角度为前，相对位置为后，最前面最大，反而越小）</p> </li><li> <p>多个布局叠加时前面遮挡后面</p> </li></ul> 
<h3><a id="_18"></a>效果难点问题</h3> 
<ul><li>Flutter如何实现控件布局达到3D效果？</li><li>Flutter如何实现子控件旋转、自动旋转、手势滑动时关联子控件旋转滚动？快速滑动抬手继续旋转滚动？</li><li>Flutter如何实现多个布局叠加时前面遮挡后面？</li></ul> 
<h6><a id="1_24"></a>1.子布局按照圆形顺序放置且平分角度</h6> 
<p>如上图所示：</p> 
<p><img src="https://images2.imgbox.com/24/f2/1mLrrwIQ_o.png" alt=""></p> 
<p>如上图所示(参考系:<code>最下方为0度，逆时针旋转角度增加</code>)</p> 
<pre><code>第一个点
解：根据已知条件列方程式
x2=width/2+sin(a)*R
y2=height/2+cos(a)*R    

第二个点
解：根据已知条件列方程式①
① x=width/2-sin(b)*R 
   y=height/2-cos(b)*R
因为b=a-180,所以带入①方程得：
② x=width/2-sin(a-180)*R
   y=height/2-cos(a-180)*R 
又因为sin（k*360+a)=sin(a),所以②方式可以修改为：
③ x=width/2-sin(180+a)*R
   y=height/2-cos(180+a)*R
又又因为 sin(180+a)=-sin(a),cos(180+a)=-cosa 带入③方程式得：
④ x=width/2+sin(a)*R 
  y=height/2+cos(a)*R 

由上面2点计算得，每个子布局的中心点坐标公式统一为：
x=width/2+sin(a)*R 
y=height/2+cos(a)*R
</code></pre> 
<p>以上所用三角函数公式表：</p> 
<p><img src="https://images2.imgbox.com/17/a4/y05EFsFk_o.png" alt=""></p> 
<p>通过上面计算得出子控件的位置公式后，开始我们的代码。</p> 
<p>实现子控件按照圆形布局及平分角度代码如下:</p> 
<pre><code>//所有子控件的位置数据
//count:子控件数量；  
//startAngle:开始角度默认为0;  
//rotateAngle:偏转角度默认为0;
List&lt;Point&gt; _childPointList({Size size = Size.zero}) {
    List&lt;Point&gt; childPointList = [];
    double averageAngle = 360 / count;
    double radius = size.width / 2 - childWidth / 2;   
    for (int i = 0; i &lt; count; i++) {
       /********************子布局角度*****************/
      double angle = startAngle + averageAngle * i + rotateAngle;
      //子布局中心点坐标
      var centerX = size.width / 2 + sin(radian(angle)) * radius;
      var centerY = size.height / 2 + cos(radian(angle)) * radius;
      childPointList.add(Point(
        centerX,
        centerY,
        childWidth,
        childHeight,
        centerX - childWidth / 2,
        centerY - childHeight / 2,
        centerX + childWidth / 2,
        centerY + childHeight / 2,
        1,
        angle,
        i,
      ));
    }
    return childPointList;
  }

///角度转弧度
///弧度 =度数 * (π / 180）
///度数 =弧度 * (180 / π）
double radian(double angle) {
    return angle * pi / 180;
}
</code></pre> 
<h6><a id="2_105"></a>2.子布局如何旋转？自动旋转？支持手势滑动旋转？快速滑动抬手继续旋转？</h6> 
<p><code>子布局如何旋转</code></p> 
<p>所谓的旋转就是所有的子布局绕着圆形移动，布局一旦移动就代表中间位置改变，根据上面我们计算的子布局位置的公式来看:</p> 
<pre><code>中心点坐标
x=width/2+sin(a)*R 
y=height/2+cos(a)*R
</code></pre> 
<p>因为<code>width</code>和<code>R</code>都是已知并且定下来的尺寸，所以说，想要改变中心点坐标，只需修改 角度a就可以了。要想达到旋转效果的话就是让所有的子布局都同时移动相同的角度即可。</p> 
<pre><code>子布局原始角度值:
double angle = startAngle + averageAngle * i; 
我们可以在此基础上加上一个可变的角度值，通过改变这个值，所有的子布局都会同时加上此值同时移动了位置。如下:
double angle = startAngle + averageAngle * i + rotateAngle; 
其中 rotateAngle 就是可变的值。改变这个值就能让布局动起来
</code></pre> 
<h6><a id="_127"></a>自动旋转</h6> 
<p>同理，我们只要搞个定时器，周期性修改这个<code>rotateAngle</code>值，并<code>setState(() {})</code>刷新下，看起来就自动旋转了。</p> 
<h6><a id="_131"></a>支持手势滑动旋转</h6> 
<p>大家已经知道通过修改<code>rotateAngle</code>值去实现旋转，那么支持手势滑动旋转顾名思义就是通过手势修改这个rotateAngle值就OK，那么手势处理Flutter提供了<code>GestureDetector</code>组件，这个组件功能很强大，这里面我们使用了他的几个回调方法。</p> 
<p>本次实现直接使用水平滑动监听，大家如果想兼容竖直滑动可以自己尝试修改就可以。</p> 
<pre><code>GestureDetector(
        ///水平滑动按下
        onHorizontalDragDown: (DragDownDetails details) {...},

        ///水平滑动开始
        onHorizontalDragStart: (DragStartDetails details) {
          //记录拖动开始时当前的选择角度值
          downAngle = rotateAngle;
          //记录拖动开始时的x坐标
          downX = details.globalPosition.dx;
        },

        ///水平滑动中
        onHorizontalDragUpdate: (DragUpdateDetails details) {
           //滑动中X坐标值
          var updateX = details.globalPosition.dx;
          //计算当前旋转角度值并刷新
          rotateAngle = (downX - updateX) * slipRatio + downAngle;
          if (mounted) setState(() {});
        },

        ///水平滑动结束
        onHorizontalDragEnd: (DragEndDetails details) {...},

        ///滑动取消
        onHorizontalDragCancel: () {...},

        behavior: HitTestBehavior.opaque,//deferToChild   translucent
        child: xxx,
);
</code></pre> 
<h6><a id="_170"></a>快速滑动抬手继续旋转</h6> 
<p>抬手还能继续旋转，也就是当我们快速滑动抬手的时候只要继续修改旋转角度值<code>rotateAngle</code>就可以达到继续旋转的效果。当我们抬手的时候我们可以拿到什么呢？</p> 
<p>例如：当我们骑着小黄单车在大路上快速的蹬着脚蹬子然后停止蹬，你的小黄已当时的速度飞驰在这个大路上，由于地面的摩擦力的影响，速度会越来越小，最后停止。</p> 
<pre><code>///水平滑动结束
onHorizontalDragEnd: (DragEndDetails details) {
          //x方向上每秒速度的像素数
          velocityX = details.velocity.pixelsPerSecond.dx; 
          _controller.reset();
          _controller.forward();
 },

  //动画设置rotateAngle
   _controller = AnimationController(
      vsync: this,
      duration: Duration(milliseconds: 1000),
    );

    animation = CurvedAnimation(
      parent: _controller,
      curve: Curves.linearToEaseOut,
    );

    animation = new Tween&lt;double&gt;(begin: 1, end: 0).animate(animation)
      ..addListener(() {
        //当前速度
        var velocity = animation.value * -velocityX;
        var offsetX = radius != 0 ? velocity * 5 / (2 * pi * radius) : velocity;
        rotateAngle += offsetX;
        setState(() =&gt; {});
      })
      ..addStatusListener((status) {
        if (status == AnimationStatus.completed) {
          rotateAngle = rotateAngle % 360;
          _startRotateTimer();
        }
      });
</code></pre> 
<h6><a id="3X_212"></a>3.支持X轴旋转</h6> 
<p><img src="https://images2.imgbox.com/c7/96/1AOhoQSH_o.png" alt=""></p> 
<p>上图是X轴方向查看旋转切面图，按照x轴旋转所有的x坐标都是相同的，y值从上往下不断增加。因为绕着X轴旋转时，X坐标是不变的，Y坐标值改变，当旋转了a角度时，现在的Y坐标如图所示为</p> 
<pre><code>Y坐标旋转后=height/2+y*cos(a)     y值我们已经在上面计算过了，y=cos(a)*R 
所以最终的计算公式是:
Y坐标值=height/2+cos(a)*R*cos(a)
cos(a)在a=[0,90]区间时对应的值是1-0   即是 a=0度时cos(a)=1,就是原始状态(与Y轴平行)，a=90度时cos(a)=0,就是与Y轴垂直准状态。所以我们可以设置a在0-90之间即可。
</code></pre> 
<h5><a id="4_225"></a>4.支持前后缩放子布局（起始角度为前，相对位置为后，最前面最大，反而越小）</h5> 
<p><img src="https://images2.imgbox.com/58/dd/Mi2CZI19_o.png" alt=""></p> 
<p>上图为cos余弦曲线图。<code>0</code>度和<code>360</code>度最大 ，<code>180</code>度最小，刚好与我们设计的初始值从0开始，然后逆时针绕一圈角度从<code>0-360</code>度。</p> 
<p><img src="https://images2.imgbox.com/47/21/WWknxqA6_o.png" alt=""></p> 
<p>所以缩放比scale计算公式可以写为：</p> 
<pre><code>var scale = (1 - minScale) / 2 * (1 + cos(radian(angle - startAngle))) + minScale;
</code></pre> 
<p><code>minScale</code>为最小缩放比，为了让缩放有个极限值，即 scale范围为：<code>（minScale，1）</code></p> 
<h6><a id="5_241"></a>5.多个布局叠加时前面遮挡后面</h6> 
<p>从视觉感受，靠近前面的布局应该遮挡后面的布局，在Android当中<code>bringToFront()</code>方法可以让布局置于前面,Flutter没有提供此方法，我们该如何处理这种情况呢？</p> 
<p>Flutter提供一个Stack布局，也叫层叠式布局，当我们添加子布局到Stack布局中时，后面添加的会遮住前面添加的，所以只要我们在添加子布局的时候按照由后到前来添加即可。话说怎么知道是前是后呢？</p> 
<p>知道实现思路现在要解决的问题是：</p> 
<p>如何区分前与后？有什么条件可以区分？</p> 
<h3><a id="_251"></a>考虑中…</h3> 
<h6><a id="1YY_253"></a>1、根据坐标值？Y坐标小就是后面，Y坐标大就是前面？</h6> 
<p>答案是不一定；因为当我启动角度不是0的时候，比如是90度，那么最右面是前面，最左边是后面，这个时候是X坐标的大小区分前后关系，所以说单独使用坐标值的大小来决定前后关系是不对的。</p> 
<h6><a id="2_257"></a>2、根据前大后小原则？根据缩放值排序来添加子布局？</h6> 
<p>答案是可行；因为我们已经实现了前面的布局缩放值是1，后面的缩放值越来越小，而且我们已经处理了启动角度问题，所以根据缩放值来实现是可行的。</p> 
<pre><code>///通过缩放值进行排序，从小到大
childPointList.sort((a, b) {
  return a.scale.compareTo(b.scale);
});

///遍历添加子布局
Stack(
  children: childPointList.map(
              (Point point) {
                return Positioned(
                    width: point.width,
                    left: point.left,
                    top: point.top,
                    child: this.widget.children[point.index]);
              },
            ).toList(),
   ),
</code></pre> 
<p>通过上面方式即可实现前后遮挡效果了。</p> 
<h6><a id="_282"></a>小知识点</h6> 
<p>Flutter 之<code>Stack</code> 组件<code>Stack</code>一个可以叠加子控件的布局，这里主要讲一下 <code>Positioned</code>，其他使用方式可以看下官网说明。</p> 
<pre><code>Positioned({
  Key key,
  this.left,
  this.top,
  this.right,
  this.bottom,
  this.width,
  this.height,
  @required Widget child,
})
</code></pre> 
<p>使用<code>Positioned</code>控制Widget的位置，通过Positioned可以随意摆放一个组件，有点像绝对布局。其中<code>left</code>、<code>top</code> 、<code>right</code>、 <code>bottom</code>分别代表离Stack左、上、右、底四边的距离。</p> 
<h6><a id="FlutterLayoutBuilder__301"></a>Flutter之LayoutBuilder 组件</h6> 
<p>有时我们希望根据组件的大小确认组件的外观，比如竖屏的时候上下展示，横屏的时候左右展示，通过LayoutBuilder组件可以获取父组件的约束尺寸。</p> 
<p>附：github链接：https://github.com/yixiaolunhui/my_flutter</p> 
<p>原文链接：https://www.jianshu.com/p/4512486fc52b</p> 
<h5><a id="_309"></a>文末</h5> 
<p>您的点赞收藏就是对我最大的鼓励！<br> 欢迎关注我，分享Android干货，交流Android技术。<br> 对文章有何见解，或者有何技术问题，欢迎在评论区一起留言讨论！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f5c10c356ebc1e288e5e2258c4d58ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">zzulioj：指针结构体 题解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81ee61e08f81003b8522ca9ee35bc30b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android-Q和中端手机-这是我们在谷歌I-O-2019上看到的所有东西</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>