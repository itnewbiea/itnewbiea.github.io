<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>接口测试之Postman使用全指南(原来使用 Postman测试API接口如此简单) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="接口测试之Postman使用全指南(原来使用 Postman测试API接口如此简单)" />
<meta property="og:description" content="Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件
一、Postman背景介绍 用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。今天给大家介绍的这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。
二、Postman的操作环境 postman适用于不同的操作系统，Postman Mac、Windows X32、Windows X64、Linux系统，还支持postman 浏览器扩展程序、postman chrome应用程序等。
三、Postman重要提示： 由于2018年初chrome停止对chrome应用程序的支持，你的postman插件可能无法正常使用了。目前chrome应用商店能使用的就是chrome扩展程序和主题背景。
四、什么是接口测试 接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。
由于如今的系统复杂度不断上升，传统的测试方法成本急剧增加且测试效率大幅下降，所以就要做接口测试。同时，接口测试相对容易实现自动化持续集成，且相对UI自动化也比较稳定，可以减少人工回归测试人力成本与时间，缩短测试周期，支持后端快速发版需求。接口持续集成是为什么能低成本高收益的根源。现在很多系统前后端架构是分离的，从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。
五、接口测试工具 postman&#43;newman&#43;jenkins&#43;git/svn
jmeter&#43;ant&#43;jenkins&#43;git/svn
postman简介：
postman一个款功能强大的接口测试工具。专为接口而生。
安装：
两个版本：
Postman Chome app(chorme浏览器，翻墙) 不推荐
Postman native app 客户端的安装方式：
下载地址： https://www.getpostman.com/apps
注册，登录。只有登录后才可以使用Postman的云服务的功能。
六、接口测试流程 1.拿到接口文档。（抓包：F12，fiddler，charles）,熟悉接口业务，接口地址，请求参数，请求头信息，请求方式，鉴权方式。
2.编写接口用例编写以及评审。
3.使用接口测试工具执行接口测试。
4.输出接口测试报告。
七、接口测试执行 鉴权码：鉴权你是否有访问此接口的权限的一个字符串码。
获取鉴权码的方式：
1.有一个专门的获取token鉴权码的接口。
2.登录之后自动生成token鉴权码。
get请求以?方式传参，多个参数之间用@分隔。
请求的功能页签：
Params：get请求传参 Authorization：是验证是否拥有从服务器访问所需数据的权限。
Headers：请求头。
Body：（post请求传参）
1.form-data：表单：键值对，还有文件上传。
2.x-www-form-urlenconded 表单：键值对。
3.raw:传各种其他类型的参数，比如：Text,Javascript,json，html，xml
4.binary：用于上传二进制文件。
pre-erquest script:接口请求之前的js脚本。
Tests:接口请求之后的断言（断言接口是否请求成功）
Settings：对请求的设置。
-------------
Cookie：是Postman用于自动管理iCookie关联。
响应的功能页签：
Body:响应内容。
Pretty:json格式，raw:文本格式，proview:网页格式。
Cookie:响应的Cookie信息。
Headers:响应头
TestResults：断言结果
响应状态码：200
响应信息：OK" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/44603e7166dbfad3894017e39a4f8721/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-19T15:49:13+08:00" />
<meta property="article:modified_time" content="2022-05-19T15:49:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">接口测试之Postman使用全指南(原来使用 Postman测试API接口如此简单)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件</p> 
<h2>一、Postman背景介绍</h2> 
<p>用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。今天给大家介绍的这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p> 
<h2>二、Postman的操作环境</h2> 
<p>postman适用于不同的操作系统，Postman Mac、Windows X32、Windows X64、Linux系统，还支持postman 浏览器扩展程序、postman chrome应用程序等。</p> 
<h2>三、Postman重要提示：</h2> 
<p>由于2018年初chrome停止对chrome应用程序的支持，你的postman插件可能无法正常使用了。目前chrome应用商店能使用的就是chrome扩展程序和主题背景。</p> 
<h2>四、什么是接口测试</h2> 
<p>接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。</p> 
<p>由于如今的系统复杂度不断上升，传统的测试方法成本急剧增加且测试效率大幅下降，所以就要做接口测试。同时，接口测试相对容易实现自动化持续集成，且相对UI自动化也比较稳定，可以减少人工回归测试人力成本与时间，缩短测试周期，支持后端快速发版需求。接口持续集成是为什么能低成本高收益的根源。现在很多系统前后端架构是分离的，从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。</p> 
<h2>五、接口测试工具</h2> 
<p>postman+newman+jenkins+git/svn<br> jmeter+ant+jenkins+git/svn<br> postman简介：<br> postman一个款功能强大的接口测试工具。专为接口而生。<br> 安装：<br> 两个版本：<br> Postman Chome app(chorme浏览器，翻墙) 不推荐<br> Postman native app 客户端的安装方式：<br> 下载地址： https://www.getpostman.com/apps<br> 注册，登录。只有登录后才可以使用Postman的云服务的功能。</p> 
<h2>六、接口测试流程</h2> 
<p>1.拿到接口文档。（抓包：F12，fiddler，charles）,熟悉接口业务，接口地址，请求参数，请求头信息，请求方式，鉴权方式。</p> 
<p>2.编写接口用例编写以及评审。</p> 
<p>3.使用接口测试工具执行接口测试。</p> 
<p>4.输出接口测试报告。</p> 
<h2>七、接口测试执行</h2> 
<p>鉴权码：鉴权你是否有访问此接口的权限的一个字符串码。<br> 获取鉴权码的方式：<br>         1.有一个专门的获取token鉴权码的接口。<br>         2.登录之后自动生成token鉴权码。<br> get请求以?方式传参，多个参数之间用@分隔。</p> 
<p>请求的功能页签：</p> 
<p>Params：get请求传参 Authorization：是验证是否拥有从服务器访问所需数据的权限。<br> Headers：请求头。<br> Body：（post请求传参）<br>         1.form-data：表单：键值对，还有文件上传。<br>         2.x-www-form-urlenconded  表单：键值对。<br>         3.raw:传各种其他类型的参数，比如：Text,Javascript,json，html，xml<br>         4.binary：用于上传二进制文件。<br> pre-erquest script:接口请求之前的js脚本。<br> Tests:接口请求之后的断言（断言接口是否请求成功）<br> Settings：对请求的设置。<br> -------------<br> Cookie：是Postman用于自动管理iCookie关联。</p> 
<p>响应的功能页签：</p> 
<p>Body:响应内容。<br> Pretty:json格式，raw:文本格式，proview:网页格式。<br> Cookie:响应的Cookie信息。<br> Headers:响应头<br> TestResults：断言结果<br> 响应状态码：200<br> 响应信息：OK<br> 响应时间和响应字节数<br> --------------------------------------------------------------------------------------------<br> Console:控制台，用于接口测试调试。<br> 面试题：<br> 接口测试中get请求和post请求的区别是什么？<br> 1.get请求一般是获取资源，psot请求一般是提交资源。<br> 2.get是通过在地址栏中以?方式传参，多个参数用&amp;分隔，post请求是通过表单传参。<br> 3.post比get安全</p> 
<h2>八、全局变量和环境变量</h2> 
<p>全局变量：能够在所有的接口请求里面使用的变量的叫全局变量。<br> 环境变量：环境变量让代码能够在不同的环境下去执行。环境变量其实也是全局变量。<br> http协议默认端口：80<br> https协议默认端口：443</p> 
<p>Postman环境变量设置及使用</p> 
<p>为什么要创建环境变量？什么是环境变量？</p> 
<p>做为测试人员，我们经常会碰到正式环境和测试环境，我们接口也有测试和正式环境之分，为了更好的使用postman这个接口工具，所以我们就需要用到环境变量<br>  <br> 添加环境组</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/33/e9/qerszeG9_o.png"></p> 
<p>组下添加环境变量，并给变量赋值</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c5/94/vqMWaj3e_o.png"></p> 
<p>添加后的环境  </p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c4/b9/kp82iesA_o.png"></p> 
<p> 引用时必须先选择环境组，再应用环境变量，语法：{<!-- -->{变量名}} </p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/23/52/xS4cxPjB_o.png"></p> 
<p>选择右边红框，修改环境变量的值（不建议在界面中直接修改） </p> 
<h2><img alt="在这里插入图片描述" src="https://images2.imgbox.com/40/62/wLaCjgw1_o.png">九、postman接口关联</h2> 
<p><strong>接口关联的第一种方式：json提取器</strong></p> 
<pre><code class="language-python">
//1.获取响应的主体正文
var resbody= responseBody;
console.log(resbody);
//2.如果返回的是json字符串，可以转换成json对象然后解析
var jsonobj = JSON.parse(responseBody);
console.log(jsonobj.access_token);
//3.把提取到的token放到全局变量
pm.globals.set("access_token",jsonobj.access_token);
</code></pre> 
<p><strong>接口关联的第二种方式：正则表达式</strong></p> 
<pre><code class="language-python">//1.获取响应的主体正文
var resbody = responseBody;
console.log(resbody);
// //2.如果返回的是json字符串，可以转换成json对象然后解析
// var jsonobj = JSON.parse(responseBody);
// console.log(jsonobj.access_token);
//2.使用正则表达式提取
var value =  responseBody.match(new RegExp('"access_token":"(.*?)"'));
console.log(value[1]);
//3.把提取到的token放到全局变量
pm.globals.set("access_token",value[1]);</code></pre> 
<p></p> 
<h2>十、postman动态参数</h2> 
<p>postman内置动态参数<br> 企业当中做接口测试的时候不能把参数写死<br> 接口测试包含三个动态参数，如下：<br> 时间戳：{<!-- -->{KaTeX parse error: Expected 'EOF', got '}' at position 10: randomint}̲} 生成一个GUID的字符串：…guid}}很长的一个字符串</p> 
<p>Postman环境变量和全局变量<br> 开发环境，测试环境，预发布环境，线上环境</p> 
<p>不管是环境变量也好还是Gobal也好全都是全局变量</p> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81postman%E6%96%AD%E8%A8%80">十一、postman断言</h2> 
<p><strong>Setting an environment variable  (设置一个环境变量)</strong></p> 
<pre><code class="language-python">pm.environment.set("variable_key", "variable_value");</code></pre> 
<p><strong>Setting a nested object as an environment variable (将嵌套对象设置为环境变量)</strong></p> 
<pre><code class="language-python">var array = [1, 2, 3, 4];

pm.environment.set("array", JSON.stringify(array, null, 2));

var obj = { a: [1, 2, 3, 4], b: { c: 'val' } };

pm.environment.set("obj", JSON.stringify(obj));
</code></pre> 
<p><strong>Getting an environment variable (获取环境变量)</strong></p> 
<pre><code class="language-python">pm.environment.get("variable_key");</code></pre> 
<p><strong>Getting an environment variable (whose value is a stringified object)  获取一个环境变量（其值是一个字符串化的对象）</strong></p> 
<pre><code class="language-python">// These statements should be wrapped in a try-catch block if the data is coming from an unknown source.

var array = JSON.parse(pm.environment.get("array"));

var obj = JSON.parse(pm.environment.get("obj"));</code></pre> 
<p><strong>Clear an environment variable (清除一个环境变量)</strong></p> 
<pre><code class="language-python">	pm.environment.unset("variable_key");</code></pre> 
<p><strong>Set a global variable (设置一个全局变量)</strong></p> 
<pre><code class="language-python">pm.globals.set("variable_key", "variable_value");</code></pre> 
<p><strong>Get a global variable (获取一个全局变量)</strong></p> 
<pre><code class="language-python">pm.globals.get("variable_key");</code></pre> 
<p><strong>Clear a global variable (清除全局变量)</strong></p> 
<pre><code class="language-python">pm.globals.unset("variable_key");</code></pre> 
<p><strong>Get a variable (获取一个变量)</strong></p> 
<p>该函数在全局变量和活动环境中搜索变量。</p> 
<pre><code class="language-python">pm.variables.get("variable_key");</code></pre> 
<p><strong>Check if response body contains a string (检查响应主体是否包含字符串)</strong></p> 
<pre><code class="language-python">pm.test("Body matches string", function () {

    pm.expect(pm.response.text()).to.include("string_you_want_to_search");

});</code></pre> 
<p><strong>Check if response body is equal to a string (检查响应主体是否等于一个字符串）</strong></p> 
<pre><code class="language-python">pm.test("Body is correct", function () {

    pm.response.to.have.body("response_body_string");

});</code></pre> 
<p><strong>Check for a JSON value （<strong>检查JSON值</strong>）</strong></p> 
<pre><code class="language-python">pm.test("Your test name", function () {

    var jsonData = pm.response.json();

    pm.expect(jsonData.value).to.eql(100);

});</code></pre> 
<p><strong>Content-Type is present （<strong>内容类型存在</strong>）</strong></p> 
<pre><code class="language-python">pm.test("Content-Type is present", function () {

    pm.response.to.have.header("Content-Type");

});</code></pre> 
<p><strong>Response time is less than 200ms （<strong>响应时间小于200ms</strong>）</strong></p> 
<pre><code class="language-python">pm.test("Response time is less than 200ms", function () {

    pm.expect(pm.response.responseTime).to.be.below(200);

});</code></pre> 
<p><strong>Status code is 200 （<strong>状态码是200</strong>）</strong></p> 
<pre><code class="language-python">pm.test("Status code is 200", function () {

    pm.response.to.have.status(200);

});</code></pre> 
<p><strong>Code name contains a string （<strong>代码名称包含一个字符串</strong>）</strong></p> 
<pre><code class="language-python">pm.test("Status code name has string", function () {

    pm.response.to.have.status("Created");

});</code></pre> 
<p><strong>Successful POST request status code （<strong>成功的POST请求状态码</strong>）</strong></p> 
<pre><code class="language-python">pm.test("Successful POST request", function () {

    pm.expect(pm.response.code).to.be.oneOf([201,202]);

})</code></pre> 
<p><strong>Use TinyValidator for JSON data （<strong>对于JSON数据使用TinyValidator</strong>）</strong></p> 
<pre><code class="language-python">var schema = {

 "items": {

 "type": "boolean"

 }

};

var data1 = [true, false];

var data2 = [true, 123];

pm.test('Schema is valid', function() {

  pm.expect(tv4.validate(data1, schema)).to.be.true;

  pm.expect(tv4.validate(data2, schema)).to.be.true;

});</code></pre> 
<p><strong>Decode base64 encoded data （<strong>解码base64编码的数据</strong>）</strong></p> 
<pre><code class="language-python">var intermediate,

    base64Content, // assume this has a base64 encoded value

    rawContent = base64Content.slice('data:application/octet-stream;base64,'.length);

intermediate = CryptoJS.enc.Base64.parse(base64content); // CryptoJS is an inbuilt object, documented here: https://www.npmjs.com/package/crypto-js

pm.test('Contents are valid', function() {

  pm.expect(CryptoJS.enc.Utf8.stringify(intermediate)).to.be.true; // a check for non-emptiness

});</code></pre> 
<p><strong>Send an asynchronous request （<strong>发送异步请求</strong>）</strong></p> 
<p>该功能既可以作为预先请求，也可以作为测试脚本使用。</p> 
<pre><code class="language-python">pm.sendRequest("https://postman-echo.com/get", function (err, response) {

    console.log(response.json());

});</code></pre> 
<p><strong>Convert XML body to a JSON object （<strong>将XML正文转换为JSON对象</strong>）</strong></p> 
<pre><code class="language-python">var jsonObject = xml2Json(responseBody);</code></pre> 
<h2>十二、postman用例的批量执行</h2> 
<p>数据驱动：csv,json<br> 特别注意： 在参数里面取数据文件的值和取全局变量一致，在断言里面取数据文件的值使<br> 用：data["名称"]<br> csv文件编码格式必须为：UTF-8</p> 
<h2>十三、必须带请求头的接口的测试方式</h2> 
<p>Host: www.baidu.com 请求的主机地址<br> Connection: keep-alive 连接方式：保持活跃<br> User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36<br> (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 请求的客户端的类型 （模拟<br> 浏览器的请求）<br> X-Requested-With: XMLHttpRequest 异步请求：长沙到北京，高铁，飞机，走路，局<br> 部刷新<br> Referer: 来源<br> Accept-Encoding: gzip, deflate, br         客户端接收的数据压缩方式<br> Accept-Language: zh-CN,zh;q=0.9         客户端接收的数据编码格式<br> Cookie: 请求的Cookie信息<br> Content-Type 请求的数据类型<br> form-data:                 Content-Type :multipart/form-data 表单文件上传<br> x-www-from-urlencoded:         Content-Type x-www-from-urlencoded: 表单 提交<br> raw:                 Content-Type：applicaton/json 根据你选择的数据类型 来决定<br> binary:                 Content-Type：binary 二进制文件</p> 
<h2>十四、接口MOCK</h2> 
<p>使用场景：前后端分离，后端的接口数据没有出来，前端需要调用后的接口实现业务，为了<br> 保证我们前端能够正常的开发以及测试，那么就需要使用MOCK，模拟桩。模拟一个接</p> 
<h2>十五、Postman接口测试之Cookie鉴权。</h2> 
<p>接口鉴权，接口加密，接口签名（金融项目，银行项目，信贷项目，特大型项目）</p> 
<p>1.什么是cookie?<br> cookie本质就是一段文本信息，客户端第一次访问服务器时，那么服务器不知道客户端的<br> 身份，所有就需要创建一个身份标识，这个身份标识就是cookie,以键值对的方式保存。<br> cookie鉴权的原理：<br> 当客户端 第一次 访问服务器时，那么服务器就会生成cookie，并且把生成的cookie信息放<br> 到响应头的set-cookie字段里面，然后发送给客户端。客户端接收到cookie之后就会保存<br> 起来，然后在 第2-N次 请求服务器的时候自动化的带上cookie信息实现鉴权。</p> 
<p>2.cookie分类<br> 回话cookie：保存在内存中，浏览器关闭之后自动化消失。<br> 持久cookie：保存在硬盘中，浏览器关闭之后不会消失。只有当持久化的时间到期了才会<br> 消失。</p> 
<p>3.数据格式<br> name:cookie的名称<br> value:cookie的值<br> domain：cookie作为的ip地址。<br> path:cookie所在的服务器上面的项目的路径。<br> exprise in：失效时间<br> size:大小<br> 凡是网页端的项目，95%以上都是存在cookie鉴权。<br> 说明：postman能够自动的保存第一次访问服务器的cookie信息，并且能够在第2-N次的<br> 时候自动的带上cookie的信息。</p> 
<h2 id="%E5%8D%81%E5%85%AD%E3%80%81%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86">十六、接口加密解密</h2> 
<p><strong>1.对称式的加密方式（私钥加密）：不常用DES和AES，已经别淘汰了。</strong></p> 
<p>Base64加密：</p> 
<pre><code class="language-python">//base64加密方式：  
var username = CryptoJS.enc.Utf8.parse("admin");//转为utf‐8  
var base64_username = CryptoJS.enc.Base64.stringify(username);//转为Base64 加密
console.log(base64_username);</code></pre> 
<p>Base64解密：</p> 
<pre><code class="language-python">//base64解密方式： 
var username = CryptoJS.enc.Base64.parse("YWRtaW4=");//解密
var new_username = username.toString(CryptoJS.enc.Utf8);//转为utf‐8
console.log(new_username)</code></pre> 
<p><strong>2.非对称的加密方式（双钥《公钥和私钥》加密</strong>）：RSA加密方式<br> 由一个密码生成的双钥，公钥加密，私钥解密。私钥加密，公钥解密、</p> 
<p><strong>3.只加密不解密</strong><br> 1.MD5加密。</p> 
<pre><code class="language-python">//MD5加密
var new_username2 = CryptoJS.MD5("admin").toString().toUpperCase();
console.log(new_username2)</code></pre> 
<h2 id="%E5%8D%81%E4%B8%83%E3%80%81newman%EF%BC%88%E6%96%B0%E7%94%B7%E4%BA%BA%EF%BC%8C%E9%9D%9EGUI%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8C%EF%BC%89">十七、newman（新男人，非<a href="https://so.csdn.net/so/search?q=GUI&amp;spm=1001.2101.3001.7020" title="GUI">GUI</a>的方式运行）</h2> 
<p>postman为接口而生，newman为postman而生。</p> 
<p>运行命令：newman run<br> 常用参数：<br> -e 使用环境变量<br> -g 使用全局变量<br> -d 使用CSV、json数据驱动<br> -n 循环次数<br> -r cli,html,json,junit --reporter-html-export 生成html报告。</p> 
<p>应用步骤：<br>         1.导出用例，环境变量，全局变量，数据文件。json格式。<br>         2.运行并生成html报告。</p> 
<p>newman run "e:\\testcase.json" -e "e:\\huanjing.json" -g "e:\\globals.json" -r<br> cli,html,json,junit --reporter-html-export "e:\\newmanreport.html"</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/defb4ff0072770f77b2db8d6bc711006/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">招商银行2022FinTech数据赛道总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95deb40e05ef1d808893ed2c6b4bee27/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ROS环境下采用PCL点云库对PCD格式点云进行滤波、旋转和平移等处理，并用RVIZ实时显示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>