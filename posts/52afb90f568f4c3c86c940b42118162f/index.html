<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>javascript设计模式_JavaScript经常用的设计模式及其实现方式（一） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="javascript设计模式_JavaScript经常用的设计模式及其实现方式（一）" />
<meta property="og:description" content="最近小编在学习JS设计模式时，经常对其应用场景感到非常不明确。故而专门抽出时间总结一下并分享给大家。今天是第一期分享。
单例模式 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
实现：
用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。
let Singleins = function(name){ this.name = name; this.instance = null;}Singleins.prototype.getName = function(){ console.log(this.name)}Singleins.getInstance = function(name){ if(!this.instance){ this.instancee = new Singleins(name); } return this.instance;}let a = Singleins.getInstance(&#39;test1&#39;);let b = Singleins.getInstance(&#39;test2&#39;);alert(a === b); //true 策略模式 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
实现:
策略模式的目的就是将算法的使用与算法的实现分离开来。利用JS实现的策略模式如下：
let strategies = { &#34;S&#34;:function(num){ return num * 4; }, &#34;A&#34;:function(num){ return num * 3; }, &#34;B&#34;:function(num){ return num * 2; }};let useStrategy = function(level,num){ return strategies[level](num);};useStrategy(&#39;S&#39;, 2000); //8000useStrategy(&#39;A&#39;, 1000); //3000 代理模式 定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/52afb90f568f4c3c86c940b42118162f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-14T04:55:30+08:00" />
<meta property="article:modified_time" content="2020-11-14T04:55:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">javascript设计模式_JavaScript经常用的设计模式及其实现方式（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/c7/4b/LaM6uKej_o.png" alt="2421bcbef25b4873e8646ebc2fcf983d.png"> 
 </div> 
 <p>最近小编在学习JS设计模式时，经常对其应用场景感到非常不明确。故而专门抽出时间总结一下并分享给大家。今天是第一期分享。</p> 
 <h2 class="pgc-h-decimal">单例模式</h2> 
 <p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p> 
 <p>实现：</p> 
 <p>用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。</p> 
 <pre class="has"><code>let Singleins = function(name){    this.name = name;    this.instance = null;}Singleins.prototype.getName = function(){    console.log(this.name)}Singleins.getInstance = function(name){    if(!this.instance){        this.instancee = new Singleins(name);    }    return this.instance;}let a = Singleins.getInstance('test1');let b = Singleins.getInstance('test2');alert(a === b);  //true</code></pre> 
 <h2 class="pgc-h-decimal">策略模式</h2> 
 <p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p> 
 <p>实现:</p> 
 <p>策略模式的目的就是将算法的使用与算法的实现分离开来。利用JS实现的策略模式如下：</p> 
 <pre class="has"><code>let strategies = {     "S":function(num){         return num * 4;     },     "A":function(num){         return num * 3;     },     "B":function(num){         return num * 2;     }};let useStrategy = function(level,num){    return strategies[level](num);};useStrategy('S', 2000); //8000useStrategy('A', 1000); //3000</code></pre> 
 <h2 class="pgc-h-decimal">代理模式</h2> 
 <p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。</p> 
 <p>实现：</p> 
 <p>代理模式按照作用可分为保护代理和虚拟代理两种形式。</p> 
 <ul><li>保护代理主要用于控制不同权限的对象对目标对象的访问。</li><li>虚拟代理主要把一些开销很大的对象，延迟到真正需要它的时候才去创建。</li></ul> 
 <p>在JS中，保护代理并不容易实现，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式。用虚拟代理的方式实现图片延迟加载功能：</p> 
 <pre class="has"><code>let myImage = (function(){    let imgNode = document.createElement('img');    document.body.appendChild('imgNode');    return {        setSrc:function(src){            imgNode.src = src;        }    }})();let proxyImage = (function(){    let img = new Image();    img.onload = function(){        myImage.setSrc(this.src);    };    return {        setSrc:function(src){            myImage.setSrc('loading.gif');            img.src = src;        }    }})();proxyImage.setSrc('xxxxx.jpg');</code></pre> 
 <p>这样实现图片延迟加载功能，更符合单一职责原则和开放-封闭原则。myImage只实现了给img节点设置src的功能，proxyImage只实现了给图片预加载loading图的功能，这样就避免了两种功能的强耦合。以后如果不需要loading图的预加载功能，可以直接不用proxyImage，不需要修改myImage。</p> 
 <h2 class="pgc-h-decimal">迭代器模式</h2> 
 <p>定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p> 
 <p>实现：</p> 
 <p>迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。迭代器可以分为内部迭代器和外部迭代器。</p> 
 <ul><li><strong>内部迭代器</strong></li></ul> 
 <pre class="has"><code>let each = function(ary,callback){    for(let i=0,l = ary.length;i</code></pre> 
 <ul><li><strong>外部迭代器</strong></li></ul> 
 <pre class="has"><code>let Iterator = function(obj){   let current = 0;   let next = function(){       current +=1;   };      let isDone = function(){       return current&gt;=obj.length;   };     let getCurrItem = function(){      return obj[current];  };    return {      next,      isDone,      getCurrItem,      length:obj.length  }};</code></pre> 
 <hr> 
 <p>本文部分内容摘自《JavaScript设计模式与开发实践》，若转载请注明出处，转发感激不尽。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5e4cc489b3e4f479473884589060b72/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">秀米复制到公众号格式变了_有哪些好用又免费的公众号编辑器？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/319bb7f04a82c07eb0ea1c40a8665989/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MATLAB 中的cumsum函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>