<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>死锁的四个必要条件 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="死锁的四个必要条件" />
<meta property="og:description" content="死锁在高并发中是一个常见的名词。产生的四个必要条件如下：
互斥条件：一个资源同一时间能且只能被一个线程访问；
不可掠夺：当资源被一个线程占用时，其他线程不可抢夺该资源；
请求与等待：当资源被一个线程占用时，其他线程只能等待资源的释放再拥有；
循环等待：指的是若干线程形成头尾相接的情况，将所有资源都占用导致的整体死锁或局部死锁。
图演示 线程1依次占用资源1和资源2，当尝试占用资源2时，发现该资源被线程2占用，此时只能等待线程2的释放，此时处于阻塞状态；
线程2依次占用资源2和资源1，当尝试占用资源1时，发现该资源被线程1占用，此时只能等待线程1的释放，此时处于阻塞状态。
这两个线程无限的等待对方资源的释放，则成为死锁。
代码演示 package com.lidantao.deadLock; import java.util.concurrent.TimeUnit; /** * @author Cola * @Date 2023年02月16日 10:41:00 */ public class Demo { public static void main(String[] args) throws InterruptedException { Object obj1 = new Object(); Object obj2 = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (obj1) { try { System.out.println(&#34;====线程1尝试占用资源1====&#34;); obj1.hashCode(); System.out.println(&#34;====线程1已经占用资源1====&#34;); TimeUnit.SECONDS.sleep(3); System.out.println(&#34;======线程1尝试占用资源2======&#34;); synchronized (obj2) { obj2.hashCode(); System.out.println(&#34;====线程1已经占用资源2====&#34;); } } catch (InterruptedException e) { e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b44939c4dc1411b52f58dcad975f414b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-16T11:15:52+08:00" />
<meta property="article:modified_time" content="2023-02-16T11:15:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">死锁的四个必要条件</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">死锁</span></span>在高并发中是一个常见的名词。产生的四个必要条件如下：</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">互斥条件</span></span>：一个资源同一时间能且只能被一个线程访问；</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">不可掠夺</span></span>：当资源被一个线程占用时，其他线程不可抢夺该资源；</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">请求与等待</span></span>：当资源被一个线程占用时，其他线程只能等待资源的释放再拥有；</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">循环等待</span></span>：指的是若干线程形成头尾相接的情况，将所有资源都占用导致的整体死锁或局部死锁。</p></li></ol> 
 <p style=""></p> 
 <h2 style="">图演示</h2> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:657px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:41.70472%;height:0;"> 
    <img src="https://images2.imgbox.com/d2/94/G8SV6q6C_o.png" style="margin-left:;display:block;width:657px;margin-top:-41.70472%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">线程1依次占用资源1和资源2，当尝试占用资源2时，发现该资源被线程2占用，此时只能等待线程2的释放，此时处于阻塞状态；</p> 
 <p style="">线程2依次占用资源2和资源1，当尝试占用资源1时，发现该资源被线程1占用，此时只能等待线程1的释放，此时处于阻塞状态。</p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">这两个线程无限的等待对方资源的释放，则成为死锁。</span></span></p> 
 <p style=""></p> 
 <h2 style="">代码演示</h2> 
 <pre class="kdocs-java"><code class="language-java">package com.lidantao.deadLock;

import java.util.concurrent.TimeUnit;

/**
 * @author Cola
 * @Date 2023年02月16日 10:41:00
 */
public class Demo {

    public static void main(String[] args) throws InterruptedException {

        Object obj1 = new Object();
        Object obj2 = new Object();

        Thread t1 = new Thread(() -&gt; {
            synchronized (obj1) {
                try {
                    System.out.println("====线程1尝试占用资源1====");
                    obj1.hashCode();
                    System.out.println("====线程1已经占用资源1====");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println("======线程1尝试占用资源2======");
                    synchronized (obj2) {
                        obj2.hashCode();
                        System.out.println("====线程1已经占用资源2====");
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "线程1");

        Thread t2 = new Thread(() -&gt; {
            synchronized (obj2) {
                try {
                    System.out.println("====线程2尝试占用资源2====");
                    obj2.hashCode();
                    System.out.println("====线程2已经占用资源2====");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println("======线程2尝试占用资源1======");
                    synchronized (obj1){
                        obj1.hashCode();
                        System.out.println("====线程2已经占用资源1====");
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "线程2");

        // 启动线程
        t1.start();
        t2.start();

        // t1业务完成
        t1.join();
        System.out.println("====== t1线程业务已完成 ======");

        // t2业务完成
        t2.join();
        System.out.println("====== t2线程业务已完成 ======");

    }
}
</code></pre> 
 <p style=""></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-color" style="color:#C21C13;">控制台输出，两线程彼此等待资源释放，无法停止线程</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:489px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:49.488754%;height:0;"> 
    <img src="https://images2.imgbox.com/4d/7e/yvOPyUnm_o.png" style="margin-left:;display:block;width:489px;margin-top:-49.488754%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-color" style="color:#C21C13;">经jconsole验证，线程1与线程2掠夺资源产生死锁</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:568px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:36.61972%;height:0;"> 
    <img src="https://images2.imgbox.com/42/1a/rZINvjJ6_o.png" style="margin-left:;display:block;width:568px;margin-top:-36.61972%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style="">处理死锁</h2> 
 <p style="">既然了解了死锁的必要条件，那么我们只要破坏其中一个条件则可避免产生死锁。</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>通常我们在业务中，可以<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">设置等待时间</span></span>。例如尝试占用资源时，设置等待时间，时间内未获得资源，则放弃尝试，避免程序长时间等待，占用过高的CPU资源。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">尽量一次只占用一个资源</span></span>，不要一次嵌套的占用多个资源，占用资源链越长，越容易产生死锁问题。</p></li></ol> 
 <p style=""></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b360417ec41fb341ea871aaca4983048/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">php微信公众号的token认证</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bbf518023176fe02555625d51ba3397/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记账本App项目简记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>