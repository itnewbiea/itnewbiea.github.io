<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于“Python”的核心知识点整理大全27 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于“Python”的核心知识点整理大全27" />
<meta property="og:description" content="目录
10.5 小结
第１1 章
测试代码
11.1 测试函数
name_function.py
函数get_formatted_name()将名和姓合并成姓名，在名和姓之间加上一个空格，并将它们的 首字母都大写，再返回结果。为核实get_formatted_name()像期望的那样工作，我们来编写一个 使用这个函数的程序。程序names.py让用户输入名和姓，并显示整洁的全名： names.py
11.1.1 单元测试和测试用例
11.1.2 可通过的测试
test_name_ function.py
11.1.3 不能通过的测试
name_ function.py
11.1.4 测试未通过时怎么办
name_function.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
10.5 小结 在本章中，你学习了：如何使用文件；如何一次性读取整个文件，以及如何以每次一行的方 式读取文件的内容；如何写入文件，以及如何将文本附加到文件末尾；什么是异常以及如何处理 程序可能引发的异常；如何存储Python数据结构，以保存用户提供的信息，避免用户每次运行程 序时都需要重新提供。
在第11章中，你将学习高效的代码测试方式，这可帮助你确定代码正确无误，以及发现扩展 现有程序时可能引入的bug。
第１1 章 测试代码 11.1 测试函数 要学习测试，得有要测试的代码。下面是一个简单的函数，它接受名和姓并返回整洁的姓名：
name_function.py def get_formatted_name(first, last): &#34;&#34;&#34;Generate a neatly formatted full name.&#34;&#34;&#34; full_name = first &#43; &#39; &#39; &#43; last return full_name.title() 函数get_formatted_name()将名和姓合并成姓名，在名和姓之间加上一个空格，并将它们的 首字母都大写，再返回结果。为核实get_formatted_name()像期望的那样工作，我们来编写一个 使用这个函数的程序。程序names.py让用户输入名和姓，并显示整洁的全名： names.py from name_function import get_formatted_name print(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fdda528c088f11293805ba53c850fe2d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-18T13:42:15+08:00" />
<meta property="article:modified_time" content="2023-12-18T13:42:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于“Python”的核心知识点整理大全27</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="10.5%20%E5%B0%8F%E7%BB%93-toc" style="margin-left:40px;"><a href="#10.5%20%E5%B0%8F%E7%BB%93" rel="nofollow">10.5 小结</a></p> 
<p id="%E7%AC%AC%EF%BC%911%20%E7%AB%A0-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%EF%BC%911%20%E7%AB%A0" rel="nofollow">第１1 章</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" rel="nofollow">测试代码</a></p> 
<p id="11.1%20%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#11.1%20%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0" rel="nofollow">11.1 测试函数</a></p> 
<p id="name_function.py-toc" style="margin-left:120px;"><a href="#name_function.py" rel="nofollow">name_function.py</a></p> 
<p id="%E5%87%BD%E6%95%B0get_formatted_name()%E5%B0%86%E5%90%8D%E5%92%8C%E5%A7%93%E5%90%88%E5%B9%B6%E6%88%90%E5%A7%93%E5%90%8D%EF%BC%8C%E5%9C%A8%E5%90%8D%E5%92%8C%E5%A7%93%E4%B9%8B%E9%97%B4%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%AE%83%E4%BB%AC%E7%9A%84%20%E9%A6%96%E5%AD%97%E6%AF%8D%E9%83%BD%E5%A4%A7%E5%86%99%EF%BC%8C%E5%86%8D%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E3%80%82%E4%B8%BA%E6%A0%B8%E5%AE%9Eget_formatted_name()%E5%83%8F%E6%9C%9F%E6%9C%9B%E7%9A%84%E9%82%A3%E6%A0%B7%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9D%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%20%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%82%E7%A8%8B%E5%BA%8Fnames.py%E8%AE%A9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%90%8D%E5%92%8C%E5%A7%93%EF%BC%8C%E5%B9%B6%E6%98%BE%E7%A4%BA%E6%95%B4%E6%B4%81%E7%9A%84%E5%85%A8%E5%90%8D%EF%BC%9A%20names.py-toc" style="margin-left:120px;"><a href="#%E5%87%BD%E6%95%B0get_formatted_name%28%29%E5%B0%86%E5%90%8D%E5%92%8C%E5%A7%93%E5%90%88%E5%B9%B6%E6%88%90%E5%A7%93%E5%90%8D%EF%BC%8C%E5%9C%A8%E5%90%8D%E5%92%8C%E5%A7%93%E4%B9%8B%E9%97%B4%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%AE%83%E4%BB%AC%E7%9A%84%20%E9%A6%96%E5%AD%97%E6%AF%8D%E9%83%BD%E5%A4%A7%E5%86%99%EF%BC%8C%E5%86%8D%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E3%80%82%E4%B8%BA%E6%A0%B8%E5%AE%9Eget_formatted_name%28%29%E5%83%8F%E6%9C%9F%E6%9C%9B%E7%9A%84%E9%82%A3%E6%A0%B7%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9D%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%20%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%82%E7%A8%8B%E5%BA%8Fnames.py%E8%AE%A9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%90%8D%E5%92%8C%E5%A7%93%EF%BC%8C%E5%B9%B6%E6%98%BE%E7%A4%BA%E6%95%B4%E6%B4%81%E7%9A%84%E5%85%A8%E5%90%8D%EF%BC%9A%20names.py" rel="nofollow">函数get_formatted_name()将名和姓合并成姓名，在名和姓之间加上一个空格，并将它们的 首字母都大写，再返回结果。为核实get_formatted_name()像期望的那样工作，我们来编写一个 使用这个函数的程序。程序names.py让用户输入名和姓，并显示整洁的全名： names.py</a></p> 
<p id="11.1.1%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-toc" style="margin-left:80px;"><a href="#11.1.1%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B" rel="nofollow">11.1.1 单元测试和测试用例</a></p> 
<p id="11.1.2%20%E5%8F%AF%E9%80%9A%E8%BF%87%E7%9A%84%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#11.1.2%20%E5%8F%AF%E9%80%9A%E8%BF%87%E7%9A%84%E6%B5%8B%E8%AF%95" rel="nofollow">11.1.2 可通过的测试</a></p> 
<p id="test_name_%20function.py-toc" style="margin-left:120px;"><a href="#test_name_%20function.py" rel="nofollow">test_name_ function.py</a></p> 
<p id="11.1.3%20%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E7%9A%84%E6%B5%8B%E8%AF%95-toc" style="margin-left:120px;"><a href="#11.1.3%20%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E7%9A%84%E6%B5%8B%E8%AF%95" rel="nofollow">11.1.3 不能通过的测试</a></p> 
<p id="name_%20function.py-toc" style="margin-left:120px;"><a href="#name_%20function.py" rel="nofollow">name_ function.py</a></p> 
<p id="11.1.4%20%E6%B5%8B%E8%AF%95%E6%9C%AA%E9%80%9A%E8%BF%87%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E-toc" style="margin-left:120px;"><a href="#11.1.4%20%E6%B5%8B%E8%AF%95%E6%9C%AA%E9%80%9A%E8%BF%87%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E" rel="nofollow">11.1.4 测试未通过时怎么办</a></p> 
<p id="name_function.py-toc" style="margin-left:120px;"><a href="#name_function.py" rel="nofollow">name_function.py</a></p> 
<p id="%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A" rel="nofollow">往期快速传送门👆（在文章最后）：</a></p> 
<p id="%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81-toc" style="margin-left:0px;"><a href="#%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81" rel="nofollow">感谢大家的支持！欢迎订阅收藏！专栏将持续更新！</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p style="text-align:center;"><img alt="" height="234" src="https://images2.imgbox.com/ea/cd/OBIAXuRd_o.png" width="364"></p> 
<h3 id="10.5%20%E5%B0%8F%E7%BB%93" style="text-align:center;">10.5 小结</h3> 
<blockquote> 
 <p style="text-align:center;">在本章中，你学习了：如何使用文件；如何一次性读取整个文件，以及如何以每次一行的方 式读取文件的内容；如何写入文件，以及如何将文本附加到文件末尾；什么是异常以及如何处理 程序可能引发的异常；如何存储Python数据结构，以保存用户提供的信息，避免用户每次运行程 序时都需要重新提供。</p> 
 <p style="text-align:center;">在第11章中，你将学习高效的代码测试方式，这可帮助你确定代码正确无误，以及发现扩展 现有程序时可能引入的bug。</p> 
</blockquote> 
<h2 id="%E7%AC%AC%EF%BC%911%20%E7%AB%A0" style="text-align:center;">第１1 章</h2> 
<h3 id="%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" style="text-align:center;">测试代码</h3> 
<h3 id="11.1%20%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0" style="text-align:center;">11.1 测试函数</h3> 
<blockquote> 
 <p style="text-align:center;">要学习测试，得有要测试的代码。下面是一个简单的函数，它接受名和姓并返回整洁的姓名：</p> 
 <h5 id="name_function.py" style="text-align:center;">name_function.py</h5> 
</blockquote> 
<pre><code class="language-python">def get_formatted_name(first, last):
 """Generate a neatly formatted full name."""
 full_name = first + ' ' + last
 return full_name.title() </code></pre> 
<blockquote> 
 <h5 id="%E5%87%BD%E6%95%B0get_formatted_name()%E5%B0%86%E5%90%8D%E5%92%8C%E5%A7%93%E5%90%88%E5%B9%B6%E6%88%90%E5%A7%93%E5%90%8D%EF%BC%8C%E5%9C%A8%E5%90%8D%E5%92%8C%E5%A7%93%E4%B9%8B%E9%97%B4%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%AE%83%E4%BB%AC%E7%9A%84%20%E9%A6%96%E5%AD%97%E6%AF%8D%E9%83%BD%E5%A4%A7%E5%86%99%EF%BC%8C%E5%86%8D%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E3%80%82%E4%B8%BA%E6%A0%B8%E5%AE%9Eget_formatted_name()%E5%83%8F%E6%9C%9F%E6%9C%9B%E7%9A%84%E9%82%A3%E6%A0%B7%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9D%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%20%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%82%E7%A8%8B%E5%BA%8Fnames.py%E8%AE%A9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%90%8D%E5%92%8C%E5%A7%93%EF%BC%8C%E5%B9%B6%E6%98%BE%E7%A4%BA%E6%95%B4%E6%B4%81%E7%9A%84%E5%85%A8%E5%90%8D%EF%BC%9A%20names.py" style="text-align:center;">函数get_formatted_name()将名和姓合并成姓名，在名和姓之间加上一个空格，并将它们的 首字母都大写，再返回结果。为核实get_formatted_name()像期望的那样工作，我们来编写一个 使用这个函数的程序。程序names.py让用户输入名和姓，并显示整洁的全名： names.py</h5> 
</blockquote> 
<pre><code class="language-python">from name_function import get_formatted_name
print("Enter 'q' at any time to quit.")
while True:
 first = input("\nPlease give me a first name: ")
 if first == 'q':
 break
 last = input("Please give me a last name: ")
 if last == 'q':
 break
 formatted_name = get_formatted_name(first, last)
 print("\tNeatly formatted name: " + formatted_name + '.')</code></pre> 
<blockquote> 
 <p style="text-align:center;">这个程序从name_function.py中导入get_formatted_name()。用户可输入一系列的名和姓，并 看到格式整洁的全名：</p> 
</blockquote> 
<pre><code class="language-python">Enter 'q' at any time to quit.
Please give me a first name: janis
Please give me a last name: joplin
 Neatly formatted name: Janis Joplin.
Please give me a first name: bob
Please give me a last name: dylan
 Neatly formatted name: Bob Dylan.
Please give me a first name: q</code></pre> 
<blockquote> 
 <p style="text-align:center;">从上述输出可知，合并得到的姓名正确无误。现在假设我们要修改get_formatted_name()， 使其还能够处理中间名。这样做时，我们要确保不破坏这个函数处理只有名和姓的姓名的方式。 为此，我们可以在每次修改get_formatted_name()后都进行测试：运行程序names.py，并输入像 Janis Joplin这样的姓名，但这太烦琐了。所幸Python提供了一种自动测试函数输出的高效方式。 倘若我们对get_formatted_name()进行自动测试，就能始终信心满满，确信给这个函数提供我们 测试过的姓名时，它都能正确地工作。</p> 
</blockquote> 
<h4 id="11.1.1%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B" style="text-align:center;">11.1.1 单元测试和测试用例</h4> 
<blockquote> 
 <p style="text-align:center;">Python标准库中的模块unittest提供了代码测试工具。单元测试用于核实函数的某个方面没 有问题；测试用例是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。 良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。全覆盖式测 试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖可 能很难。通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖。</p> 
</blockquote> 
<h4 id="11.1.2%20%E5%8F%AF%E9%80%9A%E8%BF%87%E7%9A%84%E6%B5%8B%E8%AF%95" style="text-align:center;">11.1.2 可通过的测试</h4> 
<blockquote> 
 <p style="text-align:center;">创建测试用例的语法需要一段时间才能习惯，但测试用例创建后，再添加针对函数的单元测 试就很简单了。要为函数编写测试用例，可先导入模块unittest以及要测试的函数，再创建一个继承unittest.TestCase的类，并编写一系列方法对函数行为的不同方面进行测试。 下面是一个只包含一个方法的测试用例，它检查函数get_formatted_name()在给定名和姓时 能否正确地工作：</p> 
 <h5 id="test_name_%20function.py" style="text-align:center;">test_name_ function.py</h5> 
 <p style="text-align:center;"></p> 
</blockquote> 
<pre><code class="language-python">import unittest
from name_function import get_formatted_name
1 class NamesTestCase(unittest.TestCase):
 """测试name_function.py"""
 def test_first_last_name(self):
 """能够正确地处理像Janis Joplin这样的姓名吗？"""
2 formatted_name = get_formatted_name('janis', 'joplin')
3 self.assertEqual(formatted_name, 'Janis Joplin')
unittest.main()</code></pre> 
<blockquote> 
 <p style="text-align:center;">首先，我们导入了模块unittest和要测试的函数get_formatted_ name()。在1处，我们创建 了一个名为NamesTestCase的类，用于包含一系列针对get_formatted_name()的单元测试。你可随 便给这个类命名，但最好让它看起来与要测试的函数相关，并包含字样Test。这个类必须继承 unittest.TestCase类，这样Python才知道如何运行你编写的测试。</p> 
 <p style="text-align:center;">NamesTestCase只包含一个方法，用于测试get_formatted_name()的一个方面。我们将这个方 法命名为test_first_last_name()，因为我们要核实的是只有名和姓的姓名能否被正确地格式化。 我们运行test_name_function.py时，所有以test_打头的方法都将自动运行。在这个方法中，我们 调用了要测试的函数，并存储了要测试的返回值。在这个示例中，我们使用实参'janis'和'joplin' 调用get_formatted_name()，并将结果存储到变量formatted_name中（见2）。</p> 
 <p style="text-align:center;">在3处，我们使用了unittest类最有用的功能之一：一个断言方法。断言方法用来核实得到 的结果是否与期望的结果一致。在这里，我们知道get_formatted_name()应返回这样的姓名，即 名和姓的首字母为大写，且它们之间有一个空格，因此我们期望formatted_name的值为Janis Joplin。为检查是否确实如此，我们调用unittest的方法assertEqual()，并向它传递formatted_ name和'Janis Joplin'。代码行self.assertEqual(formatted_name, 'Janis Joplin')的意思是说： “将formatted_name的值同字符串'Janis Joplin'进行比较，如果它们相等，就万事大吉，如果它 们不相等，跟我说一声！”</p> 
 <p style="text-align:center;">代码行unittest.main()让Python运行这个文件中的测试。运行test_name_function.py时，得 到的输出如下：</p> 
</blockquote> 
<pre><code class="language-python">.
----------------------------------------------------------------------
Ran 1 test in 0.000s
OK</code></pre> 
<blockquote> 
 <p style="text-align:center;">第1行的句点表明有一个测试通过了。接下来的一行指出Python运行了一个测试，消耗的时 间不到0.001秒。最后的OK表明该测试用例中的所有单元测试都通过了。 上述输出表明，给定包含名和姓的姓名时，函数get_formatted_name()总是能正确地处理。 修改get_formatted_name()后，可再次运行这个测试用例。如果它通过了，我们就知道在给定Janis Joplin这样的姓名时，这个函数依然能够正确地处理。</p> 
</blockquote> 
<h5 id="11.1.3%20%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E7%9A%84%E6%B5%8B%E8%AF%95" style="text-align:center;">11.1.3 不能通过的测试</h5> 
<blockquote> 
 <p style="text-align:center;">测试未通过时结果是什么样的呢？我们来修改get_formatted_name()，使其能够处理中间名， 但这样做时，故意让这个函数无法正确地处理像Janis Joplin这样只有名和姓的姓名。 下面是函数get_formatted_name()的新版本，它要求通过一个实参指定中间名：</p> 
 <h5 id="name_%20function.py" style="text-align:center;">name_ function.py</h5> 
</blockquote> 
<pre><code class="language-python">def get_formatted_name(first, middle, last):
"""生成整洁的姓名"""
 full_name = first + ' ' + middle + ' ' + last
 return full_name.title()</code></pre> 
<blockquote> 
 <p style="text-align:center;">这个版本应该能够正确地处理包含中间名的姓名，但对其进行测试时，我们发现它再也不能 正确地处理只有名和姓的姓名。这次运行程序test_name_function.py时，输出如下：</p> 
</blockquote> 
<pre><code class="language-python">1 E
======================================================================
2 ERROR: test_first_last_name (__main__.NamesTestCase)
----------------------------------------------------------------------
3 Traceback (most recent call last):
 File "test_name_function.py", line 8, in test_first_last_name
 formatted_name = get_formatted_name('janis', 'joplin')
TypeError: get_formatted_name() missing 1 required positional argument: 'last'
----------------------------------------------------------------------
4 Ran 1 test in 0.000s
5 FAILED (errors=1)</code></pre> 
<blockquote> 
 <p style="text-align:center;">其中包含的信息很多，因为测试未通过时，需要让你知道的事情可能有很多。第1行输出只 有一个字母E（见1），它指出测试用例中有一个单元测试导致了错误。接下来，我们看到 NamesTestCase中的test_first_last_name()导致了错误（见2）。测试用例包含众多单元测试时， 知道哪个测试未通过至关重要。在3处，我们看到了一个标准的traceback，它指出函数调用 get_formatted_name('janis', 'joplin')有问题，因为它缺少一个必不可少的位置实参。 我们还看到运行了一个单元测试（见4）。最后，还看到了一条消息，它指出整个测试用例 都未通过，</p> 
 <p style="text-align:center;">因为运行该测试用例时发生了一个错误（见5）。这条消息位于输出末尾，让你一眼 就能看到——你可不希望为获悉有多少测试未通过而翻阅长长的输出。</p> 
</blockquote> 
<h5 id="11.1.4%20%E6%B5%8B%E8%AF%95%E6%9C%AA%E9%80%9A%E8%BF%87%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E" style="text-align:center;">11.1.4 测试未通过时怎么办</h5> 
<blockquote> 
 <p style="text-align:center;">测试未通过时怎么办呢？如果你检查的条件没错，测试通过了意味着函数的行为是对的，而 测试未通过意味着你编写的新代码有错。因此，测试未通过时，不要修改测试，而应修复导致测 试不能通过的代码：检查刚对函数所做的修改，找出导致函数行为不符合预期的修改。 在这个示例中，get_formatted_name()以前只需要两个实参——名和姓，但现在它要求提供 名、中间名和姓。新增的中间名参数是必不可少的，这导致get_formatted_name()的行为不符合 预期。就这里而言，最佳的选择是让中间名变为可选的。这样做后，使用类似于Janis Joplin的姓 名进行测试时，测试就会通过了，同时这个函数还能接受中间名。下面来修改 get_formatted_name()，将中间名设置为可选的，然后再次运行这个测试用例。如果通过了，我 们接着确认这个函数能够妥善地处理中间名。 要将中间名设置为可选的，可在函数定义中将形参middle移到形参列表末尾，并将其默认值 指定为一个空字符串。我们还要添加一个if测试，以便根据是否提供了中间名相应地创建姓名：</p> 
 <h5 style="text-align:center;">name_function.py</h5> 
</blockquote> 
<pre><code class="language-python">def get_formatted_name(first, last, middle=''):
 """生成整洁的姓名"""
 if middle:
 full_name = first + ' ' + middle + ' ' + last
 else:
 full_name = first + ' ' + last
 return full_name.title()</code></pre> 
<blockquote> 
 <p style="text-align:center;">在get_formatted_name()的这个新版本中，中间名是可选的。如果向这个函数传递了中间名 （if middle:），姓名将包含名、中间名和姓，否则姓名将只包含名和姓。现在，对于两种不同的 姓名，这个函数都应该能够正确地处理。为确定这个函数依然能够正确地处理像Janis Joplin这样 的姓名，我们再次运行test_name_function.py：</p> 
</blockquote> 
<pre><code class="language-python">.
----------------------------------------------------------------------
Ran 1 test in 0.000s
OK </code></pre> 
<blockquote> 
 <p style="text-align:center;">现在，测试用例通过了。太好了，这意味着这个函数又能正确地处理像Janis Joplin这样的姓 名了，而且我们无需手工测试这个函数。这个函数很容易就修复了，因为未通过的测试让我们得 知新代码破坏了函数原来的行为。</p> 
</blockquote> 
<p style="text-align:center;"><a href="https://blog.csdn.net/lzy302810/article/details/135043856?spm=1001.2014.3001.5501" title="关于“Python”的核心知识点整理大全25-CSDN博客">关于“Python”的核心知识点整理大全25-CSDN博客</a></p> 
<p style="text-align:center;"><a href="https://blog.csdn.net/lzy302810/article/details/134917938?spm=1001.2014.3001.5502" title="关于“Python”的核心知识点整理大全12-CSDN博客">关于“Python”的核心知识点整理大全12-CSDN博客</a></p> 
<h2 id="%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A" style="text-align:center;">往期快速传送门👆（在文章最后）：</h2> 
<h2 id="%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81" style="text-align:center;"><a name="t8"></a><a name="t10"></a><a name="t13"></a><a name="t11"></a>感谢大家的支持！欢迎订阅收藏！专栏将持续更新！</h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01a9fbe59e8c69656fca4a5f63f94078/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【玩转Node.JS】=＞ 之 Buffer（缓冲器）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f584ce940ac330d05559736750f38592/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端检测字符串中是否含有特殊字符，并返回该特殊字符</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>