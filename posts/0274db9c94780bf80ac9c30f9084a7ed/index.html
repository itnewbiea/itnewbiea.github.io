<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CommonJS模块与ES6模块及区别 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CommonJS模块与ES6模块及区别" />
<meta property="og:description" content="CommonJS模块和ES6模块 在ES6之前，js本没有模块体系之说，最主要使用的是CommonJS和AMD两种。前者用于服务器，后者用于浏览器，ES6后在语言标准的层面上实现了模块功能，使用简单，称为浏览器和服务器通用的模块解决方案。
CommonJS模块化规范 Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖，规定每个模块内部，规定 module 变量代表当前模块，module 变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口，加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。
let { start , exist , readFile } = require(&#39;fs&#39;); //也等同于 let fs1 = require(&#39;fs&#39;); let start = fs1.start; let exist = fs1.exist; let readFile = fs1.readFile; ES6模块 ES6中提供了模块的概念，我们可以向使用模块引用的方式引用模块
import { start, exists, readFile } from &#39;fs&#39; 首先建一个文件 index.js 定义变量并暴露出去
let num = 10 ; let obj = {} ; let arr = [] ; let func = functiom(){}; export { num , obj , arr , func }; 然后想要在另一个文件接收这个变量就需要引入 import命令加载这个模块" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0274db9c94780bf80ac9c30f9084a7ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-24T17:09:29+08:00" />
<meta property="article:modified_time" content="2022-03-24T17:09:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CommonJS模块与ES6模块及区别</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>CommonJS模块和ES6模块</h3> 
<p>        在ES6之前，js本没有模块体系之说，最主要使用的是CommonJS和AMD两种。前者用于服务器，后者用于浏览器，ES6后在语言标准的层面上实现了模块功能，使用简单，称为浏览器和服务器通用的模块解决方案。</p> 
<h4>CommonJS模块化规范</h4> 
<p>        Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖，规定每个模块内部，规定 module 变量代表当前模块，module 变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口，加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。</p> 
<pre><code class="language-javascript">let { start , exist , readFile } = require('fs');

//也等同于
let fs1 = require('fs');
let start = fs1.start;
let exist = fs1.exist;
let readFile = fs1.readFile;</code></pre> 
<h4>ES6模块 </h4> 
<p>        ES6中提供了模块的概念，我们可以向使用模块引用的方式引用模块</p> 
<pre><code class="language-javascript">import { start, exists, readFile } from 'fs'</code></pre> 
<p>首先建一个文件 index.js 定义变量并暴露出去</p> 
<pre><code class="language-javascript">let num = 10 ;
let obj = {} ;
let arr = [] ;
let func = functiom(){};

export { num , obj , arr , func };
 </code></pre> 
<p>然后想要在另一个文件接收这个变量就需要引入 import命令加载这个模块</p> 
<pre><code class="language-javascript">import { num , obj , arr , func } from 'index.js'
import index from 'index.js'</code></pre> 
<h3>共同点</h3> 
<p> 都能够把对象内部的属性进行改变操作</p> 
<h3>ES6模块与CommonJS模块的差异</h3> 
<blockquote> 
 <p>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用</p> 
 <p>CommonJS模块是运行时加载，ES6模块是编译时输出接口</p> 
</blockquote> 
<blockquote> 
 <p> <strong>CommonJS模块特点：</strong></p> 
 <ol><li>对于基本数据类型，属于复制。即会被模块缓存，如果在另外一个模块导入相同的变量也可以对该变量进行赋值</li><li>对于复杂数据类型，是浅拷贝。由于两个模块引用对象指向同一内存空间，因此对该模块的值作出修改时会影响到另一个模块</li><li>当使用require命令加载某一个模块时，就会运行整个模块的代码</li><li>当使用require命令加载同一个模块的时候，不会再执行该模块，而是取到缓存之中的值，CommonJS模块无论加载多少次，都只会在第一次加载的时候运行一次，以后在加载都是在缓存中取值返回第一次运行的结果，除非手动清除系统缓存</li><li>循环加载时，属于加载时执行。即脚本代码在require的时候就会全部执行，一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出</li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>ES6模块特点 </strong></p> 
 <ol><li>静态化，必须定义在顶部，不能使用条件语句，自动采用严格模式</li><li>treeshaking(webpack会在打包的时候忽略掉没有用的代码)和编译优化，以及在webpack3中作用域的提升</li><li>外部可以拿到实时的值而不是缓存中的值，是引用而不是拷贝</li><li>es6模块中的值是属于动态只读引用</li><li>对于只读来说，就是不能修改引入变量的值，import变量是只读的，无论是基本数据类型还是复杂数据类型，当模块遇到import命令的时候。就会生成一个只读引用。等到脚本真正执行的时候，再根据这个只读引用到被加载的那个模块里面去取值</li><li>对于动态来说，原始值发生变化，import加载的值也发生变化，无论是基本数据类型还是复杂数据类型</li><li>循环加载时，es6模块时动态引用的，只要两个模块之间存在某个引用，代码就能构执行</li></ol> 
</blockquote> 
<h3>循环加载 </h3> 
<p>        循环加载指的是 a.js 也就是a脚本执行依赖于 b.js 也就是b脚本，而b脚本执行又需要a脚本。</p> 
<blockquote> 
 <p> 通常，“循环加载”表示存在强耦合，如果处理不当，还可能会导致递归加载，使得程序无法执行，因此应该避免出现。</p> 
 <ul><li><strong>耦合性(Coupling) </strong>，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。</li><li>递归加载，递归调用之前的语句是从上到下的，函数调用之后的语句是从下到上的，因为后面的语句要等最下层或者最里面最后调用的那个函数执行之后不再调用了再开始执行，然后返回上一层的时候再执行上一层函数调用后面的语句。并且特别注意的是，每次函数返回后直接就是函数调用后面的语句。</li></ul> 
</blockquote> 
<h4>CommonJS模块的循环加载 </h4> 
<p>        CommonJS模块中重要特性就是加载时执行，就是脚本代码在require的时候就会全部执行，如果出现某个模块出现<span style="color:#fe2c24;">循环加载</span><span style="color:#0d0016;">，就会只输出已经执行了的部分，还没有执行的部分就不会输出。</span></p> 
<h4> ES6模块的循环加载</h4> 
<p>         ES6处理<span style="color:#fe2c24;">循环加载</span><span style="color:#0d0016;">和CommonJS有本质上的不同，ES6模块是动态引用，如果使用 import 从一个模块加载变量，那些变量并不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己能够保证真正取值的时候能够取到值。</span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f8b7dd7343f9fb8996805088f5e09cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决报错FileNotFoundError: Could not find module.... Try using the full path with constructor syntax.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f8dbbe27defba8c299006e85f7e6367/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">postman参数化导入csv文件中文乱码解决方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>