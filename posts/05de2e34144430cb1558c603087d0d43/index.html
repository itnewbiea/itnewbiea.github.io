<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Prism学习笔记-模块之间通信的几种方式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Prism学习笔记-模块之间通信的几种方式" />
<meta property="og:description" content="在开发大型复杂系统时，我们通常会按功能将系统分成很多模块，这样模块就可以独立的并行开发、测试、部署、修改。使用Prism框架设计表现层时，我们也会遵循这个原则，按功能相关性将界面划分为多个模块，每个模块又包含多个Region。这就需要解决模块之间、Region之间经常需要进行通信的问题，Prism提供了以下几种方式：
1、聚合事件（Event aggregation）
使用方式，先在一个公共模块中定义一个事件MyEvent ，传输数据为MyEntity。
public class MyEvent : CompositePresentationEvent&lt;MyEntity&gt;
{
}
然后在需要等待处理事件的模块中订阅事件，如下所示：
private IEventAggregator eventAggregator;
eventAggregator = (IEventAggregator)ServiceLocator.Current.GetService(typeof(IEventAggregator));
eventAggregator.GetEvent&lt;MyEvent&gt;().Subscribe(MyEventHandler, true);
public void MyEventHandler(MyEntity myEntity)
{
}
eventAggregator 相当于一个全局的集合，保存了所有订阅的事件。
在发起通信的模块中发布事件，如下所示：
eventAggregator.GetEvent&lt;CreatePlanEvent&gt;().Publish(new MyEntity());
2、全局命令
使用方式，在公共模块中定义一个全局命令类：
public static class GlobalCommands
{
public static CompositeCommand OpenCommand = new CompositeCommand();
}
在使用该命令的View中：
&lt;Button Command=&#34;{x:Static s:GlobalCommands.OpenCommand }&#34; &gt;
在响应该命令的模块中：
public ICommand OpenCommand { get; set; }
OpenCommand = new RelayCommand(param =&gt; this.Open(param));
GlobalCommands.OpenCommand.RegisterCommand(OpenCommand);
不用绑定时可以这样执行：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/05de2e34144430cb1558c603087d0d43/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-11-19T17:46:00+08:00" />
<meta property="article:modified_time" content="2011-11-19T17:46:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Prism学习笔记-模块之间通信的几种方式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>在开发大型复杂系统时，我们通常会按功能将系统分成很多模块，这样模块就可以独立的并行开发、测试、部署、修改。使用Prism框架设计表现层时，我们也会遵循这个原则，按功能相关性将界面划分为多个模块，每个模块又包含多个Region。这就需要解决模块之间、Region之间经常需要进行通信的问题，Prism提供了以下几种方式：</p> 
 <p>1、聚合事件（<strong>Event aggregation</strong>）</p> 
 <p>使用方式，先在一个公共模块中定义一个事件MyEvent ，传输数据为MyEntity。</p> 
 <p>public class MyEvent : CompositePresentationEvent&lt;MyEntity&gt;<br>{<!-- --><br>}</p> 
 <p>然后在需要等待处理事件的模块中订阅事件，如下所示：</p> 
 <p>private IEventAggregator eventAggregator;</p> 
 <p>eventAggregator = (IEventAggregator)ServiceLocator.Current.GetService(typeof(IEventAggregator));</p> 
 <p>eventAggregator.GetEvent&lt;MyEvent&gt;().Subscribe(MyEventHandler, true);</p> 
 <p align="justify">public void MyEventHandler(MyEntity myEntity)<br>{<!-- --></p> 
 <p>}</p> 
 <p>eventAggregator 相当于一个全局的集合，保存了所有订阅的事件。</p> 
 <p>在发起通信的模块中发布事件，如下所示：</p> 
 <p>eventAggregator.GetEvent&lt;CreatePlanEvent&gt;().Publish(new MyEntity());</p> 
 <p>2、全局命令</p> 
 <p>使用方式，在公共模块中定义一个全局命令类：</p> 
 <p>public static class GlobalCommands<br>{<!-- --><br>        public static CompositeCommand OpenCommand = new CompositeCommand();</p> 
 <p>}</p> 
 <p>在使用该命令的View中：</p> 
 <p>&lt;Button Command="{x:Static s:GlobalCommands.OpenCommand }" &gt;</p> 
 <p>在响应该命令的模块中：</p> 
 <p>public ICommand OpenCommand { get; set; }</p> 
 <p>OpenCommand = new RelayCommand(param =&gt; this.Open(param));</p> 
 <p>GlobalCommands.OpenCommand.RegisterCommand(OpenCommand);</p> 
 <p>不用绑定时可以这样执行：</p> 
 <p>GlobalCommands.OpenCommand.Execute(param);</p> 
 <p>3、<strong>Region context</strong></p> 
 <p>在Prism安装文件中自带的UIComposition例子中演示了两个Tab页共享一个数据集，</p> 
 <p>用法是在View中：</p> 
 <p>prism:RegionManager.RegionContext="{Binding CurrentEmployee}"</p> 
 <p>在两个Tab页的View的后台代码中：</p> 
 <p>RegionContext.GetObservableContext(this).PropertyChanged += (s, e)<br>                                                                        =&gt;<br>                                                                        employeeDetailsViewModel.CurrentEmployee =<br>                                                                        RegionContext.GetObservableContext(this).Value<br>                                                                        as Employee;</p> 
 <p>我们还可以利用Region.Context属性共享数据，Region.Context中可以保存任何该Region需要与其他Region共享的数据。</p> 
 <p>因此我在实际使用时用Region.Context来保存一个控件对象的引用。如下所示：</p> 
 <p>在一个模块中保存</p> 
 <p>mainRegion.Context = new ContentControl();</p> 
 <p>在另一个模块中取出</p> 
 <p>IRegion mainRegion = regionManager.Regions["MainRegion"];<br>if (mainRegion == null) return;<br>ContentControlpane = mainRegion.Context as ContentControl;</p> 
 <p>因为regionManager是全局的，所以可以随时获得感兴趣的Region和Context</p> 
 <p>4、共享服务</p> 
 <p>这种方法我们在前面已经接触到了，如：</p> 
 <p>eventAggregator = (IEventAggregator)ServiceLocator.Current.GetService(typeof(IEventAggregator));</p> 
 <p>还可以，container= (IEventAggregator)ServiceLocator.Current.GetService(typeof(IUnityContainer));</p> 
 <p>IEventAggregator和IUnityContainer是Prism已有的服务，我们还可以自定义服务，请参考Prism自带的StockTrader RI例子</p> 
 <p>中的IMarketHistoryService服务。</p> 
</div> 
<p>转载于:https://www.cnblogs.com/wenjingu/archive/2011/11/19/2255398.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a42490406b6acc8585dc09694063213f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JSTL函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/13d5492252ee1a6c6b9be94d4795ab2f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux用tar解压文件无法 open: 没有该文件或目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>