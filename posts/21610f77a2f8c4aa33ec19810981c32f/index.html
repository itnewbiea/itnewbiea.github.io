<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mongoose（三）：数据类型 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mongoose（三）：数据类型" />
<meta property="og:description" content="既然Mongoose是数据建模用的，那么必然应当极为重视数据类型。
关于数据类型，官网文档 里有详尽的描述，以下是原文与调皮的译文。
注意：这绝非是一个词一个词的翻译，请不要用它来学习英文。=w=
SchemaTypes 数据类型 SchemaTypes handle definition of path defaults, validation, getters, setters, field selection defaults for queries and other general characteristics for Strings and Numbers. Check out their respective API documentation for more detail.
数据类型用于定义默认路径， 验证方式， 获取/设置方法，用于数据库查询的默认字段，以及其他针对字符串与数字的特性。关于详细信息请查阅相关API文档。
译注：默认路径即某个域相对于文档而言的路径，如{a: 1}这个文档中，若指定路径为’a’，即可访问到1这个数据。
Following are all valid Schema Types. 接下来是Mongoose中所有可用的数据类型。
String 字符串Number 数字Date 日期Buffer 缓冲区Boolean 布尔值Mixed 混合Objectid 对象IDArray 数组 Example 举个栗子！
var schema = new Schema({ name: String, binary: Buffer, living: Boolean, updated: { type: Date, default: Date." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/21610f77a2f8c4aa33ec19810981c32f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-05-02T22:19:07+08:00" />
<meta property="article:modified_time" content="2016-05-02T22:19:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mongoose（三）：数据类型</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>既然Mongoose是数据建模用的，那么必然应当极为重视数据类型。</p> 
<p>关于数据类型，<a href="http://mongoosejs.com/docs/schematypes.html" rel="nofollow">官网文档</a> 里有详尽的描述，以下是原文与调皮的译文。</p> 
<p><strong>注意：这绝非是一个词一个词的翻译，请不要用它来学习英文。=w=</strong></p> 
<hr> 
<h2 id="schematypes-数据类型">SchemaTypes 数据类型</h2> 
<p>SchemaTypes handle definition of path defaults, validation, getters, setters, field selection defaults for queries and other general characteristics for Strings and Numbers. Check out their respective API documentation for more detail.</p> 
<p>数据类型用于定义默认路径， 验证方式， 获取/设置方法，用于数据库查询的默认字段，以及其他针对字符串与数字的特性。关于详细信息请查阅相关API文档。</p> 
<blockquote> 
 <p>译注：默认路径即某个域相对于文档而言的路径，如{a: 1}这个文档中，若指定路径为’a’，即可访问到1这个数据。</p> 
</blockquote> 
<p>Following are all valid Schema Types. <br> 接下来是Mongoose中所有可用的数据类型。</p> 
<ul><li>String <br> 字符串</li><li>Number <br> 数字</li><li>Date <br> 日期</li><li>Buffer <br> 缓冲区</li><li>Boolean <br> 布尔值</li><li>Mixed <br> 混合</li><li>Objectid <br> 对象ID</li><li>Array <br> 数组</li></ul> 
<p>Example <br> 举个栗子！</p> 
<pre class="prettyprint"><code class="language-js hljs "><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({
  name:    <span class="hljs-built_in">String</span>,
  binary:  Buffer,
  living:  <span class="hljs-built_in">Boolean</span>,
  updated: { type: <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">default</span>: <span class="hljs-built_in">Date</span>.now },
  age:     { type: <span class="hljs-built_in">Number</span>, min: <span class="hljs-number">18</span>, max: <span class="hljs-number">65</span> },
  mixed:   Schema.Types.Mixed,
  _someId: Schema.Types.ObjectId,
  array:      [],
  ofString:   [<span class="hljs-built_in">String</span>],
  ofNumber:   [<span class="hljs-built_in">Number</span>],
  ofDates:    [<span class="hljs-built_in">Date</span>],
  ofBuffer:   [Buffer],
  ofBoolean:  [<span class="hljs-built_in">Boolean</span>],
  ofMixed:    [Schema.Types.Mixed],
  ofObjectId: [Schema.Types.ObjectId],
  nested: {
    stuff: { type: <span class="hljs-built_in">String</span>, lowercase: <span class="hljs-literal">true</span>, trim: <span class="hljs-literal">true</span> }
  }
})

<span class="hljs-comment">// example use</span>

<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);

<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> Thing;
m.name = <span class="hljs-string">'Statue of Liberty'</span>;
m.age = <span class="hljs-number">125</span>;
m.updated = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
m.binary = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">0</span>);
m.living = <span class="hljs-literal">false</span>;
m.mixed = { any: { thing: <span class="hljs-string">'i want'</span> } };
m.markModified(<span class="hljs-string">'mixed'</span>);
m._someId = <span class="hljs-keyword">new</span> mongoose.Types.ObjectId;
m.array.push(<span class="hljs-number">1</span>);
m.ofString.push(<span class="hljs-string">"strings!"</span>);
m.ofNumber.unshift(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);
m.ofDates.addToSet(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>);
m.ofBuffer.pop();
m.ofMixed = [<span class="hljs-number">1</span>, [], <span class="hljs-string">'three'</span>, { four: <span class="hljs-number">5</span> }];
m.nested.stuff = <span class="hljs-string">'good'</span>;
m.save(callback);</code></pre> 
<h3 id="usage-notes-用法要点">Usage notes 用法要点</h3> 
<h4 id="dates-日期型">Dates 日期型</h4> 
<p>Built-in Date methods are not hooked into the mongoose change tracking logic which in English means that if you use a Date in your document and modify it with a method like setMonth(), mongoose will be unaware of this change and doc.save() will not persist this modification. If you must modify Date types using built-in methods, tell mongoose about the change with doc.markModified(‘pathToYourDate’) before saving.</p> 
<p>Mongoose不跟踪JS内建的日期方法对数据造成的改变。这意味着如果你在文档中使用<code>Date</code> 类型并用<code>setMonth</code>之类的方法去修改它，Mongoose不会意识到它的改变，调用<code>doc.save</code>方法保存时不会保留这个修改。如果你一定要用JS内建的方法修改Date类型的数据，在保存之前用<code>doc.markModified</code> 方法告诉Mongoose这个改变。</p> 
<pre class="prettyprint"><code class="language-js hljs "><span class="hljs-keyword">var</span> Assignment = mongoose.model(<span class="hljs-string">'Assignment'</span>, { dueDate: <span class="hljs-built_in">Date</span> });
Assignment.findOne(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, doc)</span> {<!-- --></span>
  doc.dueDate.setMonth(<span class="hljs-number">3</span>);
  doc.save(callback); <span class="hljs-comment">// THIS DOES NOT SAVE YOUR CHANGE</span>

  doc.markModified(<span class="hljs-string">'dueDate'</span>);
  doc.save(callback); <span class="hljs-comment">// works</span>
})</code></pre> 
<h4 id="mixed-混合型">Mixed 混合型</h4> 
<p>An “anything goes” SchemaType, its flexibility comes at a trade-off of it being harder to maintain. Mixed is available either through Schema.Types.Mixed or by passing an empty object literal. The following are equivalent:</p> 
<p>混合型是一种“存啥都行”的数据类型，它的灵活性来自于对可维护性的妥协。Mixed类型用<code>Schema.Types.Mixed</code> 或者一个字面上的空对象<code>{}</code>来定义。下面的定义是等价的： </p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">var</span> Any = <span class="hljs-keyword">new</span> Schema({ any: {} });
<span class="hljs-keyword">var</span> Any = <span class="hljs-keyword">new</span> Schema({ any: Schema.Types.Mixed });</code></pre> 
<p>Since it is a schema-less type, you can change the value to anything else you like, but Mongoose loses the ability to auto detect and save those changes. To “tell” Mongoose that the value of a Mixed type has changed, call the .markModified(path) method of the document passing the path to the Mixed type you just changed.</p> 
<p>因为它是一种 <del>无拘无束，无法无天</del> 无固定模式的类型，所以你可以想怎么改就怎么改，但是Mongoose 没有能力去自动检测和保存这些改动。请通过调用<code>doc.markModified</code> 方法来告诉Mongoose某个混合类型的值被改变了。</p> 
<pre class="prettyprint"><code class="language-js hljs ">person.anything = { x: [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, { y: <span class="hljs-string">"changed"</span> }] };
person.markModified(<span class="hljs-string">'anything'</span>);
person.save(); <span class="hljs-comment">// anything will now get saved</span></code></pre> 
<h4 id="objectids-对象id型">ObjectIds 对象ID型</h4> 
<p>To specify a type of ObjectId, use Schema.Types.ObjectId in your declaration. <br> 用<code>Schema.Types.ObjectId</code> 来声明一个对象ID类型。</p> 
<blockquote> 
 <p>译注：对象ID同MongoDB内置的<code>_id</code> 的类型。由24位Hash字符串。</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-js hljs "><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> ObjectId = mongoose.Schema.Types.ObjectId;
<span class="hljs-keyword">var</span> Car = <span class="hljs-keyword">new</span> Schema({ driver: ObjectId });
<span class="hljs-comment">// or just Schema.ObjectId for backwards compatibility with v2</span></code></pre> 
<h4 id="arrays-数组型">Arrays 数组型</h4> 
<p>Provide creation of arrays of SchemaTypes or Sub-Documents. <br> 提供创造各种数据类型或子文档的数组的方法。</p> 
<pre class="prettyprint"><code class="language-js hljs "><span class="hljs-keyword">var</span> ToySchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> ToyBox = <span class="hljs-keyword">new</span> Schema({
  toys: [ToySchema],
  buffers: [Buffer],
  string:  [<span class="hljs-built_in">String</span>],
  numbers: [<span class="hljs-built_in">Number</span>]
  <span class="hljs-comment">// ... etc</span>
});</code></pre> 
<p>Note: specifying an empty array is equivalent to Mixed. The following all create arrays of Mixed: <br> 注意：用一个空数组来定义等价于创建一个混合型的数组。下面都是创建混合型数组的例子：</p> 
<pre class="prettyprint"><code class="language-js hljs "><span class="hljs-keyword">var</span> Empty1 = <span class="hljs-keyword">new</span> Schema({ any: [] });
<span class="hljs-keyword">var</span> Empty2 = <span class="hljs-keyword">new</span> Schema({ any: <span class="hljs-built_in">Array</span> });
<span class="hljs-keyword">var</span> Empty3 = <span class="hljs-keyword">new</span> Schema({ any: [Schema.Types.Mixed] });
<span class="hljs-keyword">var</span> Empty4 = <span class="hljs-keyword">new</span> Schema({ any: [{}] });</code></pre> 
<h4 id="creating-custom-types-创建自定义类型">Creating Custom Types 创建自定义类型</h4> 
<p>Mongoose can also be extended with custom SchemaTypes. Search the plugins site for compatible types like mongoose-long, mongoose-int32 and other types. To create your own custom schema take a look at Creating a Basic Custom Schema Type. <br> Mongoose也支持使用自定义的数据类型来拓展功能。从<a href="http://plugins.mongoosejs.com/" rel="nofollow">Mongoose插件站</a>搜索合适的类型，比如mongoose-long，mongoose-int32或者其他类型。 想要自己创建类型的话请参考<a href="http://mongoosejs.com/docs/customschematypes.html" rel="nofollow">创建一个基础的自定义数据类型</a>。</p> 
<hr> 
<p>Next Up <br> 下一步</p> 
<p>Now that we’ve covered SchemaTypes, let’s take a look at Models. <br> 现在我们看完数据类型部分，让我们来看看模型部分。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54cbd232fce72873924c3f8bfe00c772/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;中关键字const和mutable的用法总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d06bd75e27d6d91cb8ed5a8e67866da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android开发之 SwipeRefreshLayout</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>