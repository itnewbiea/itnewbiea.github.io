<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>gdal库的三个使用心得 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="gdal库的三个使用心得" />
<meta property="og:description" content="作者：朱金灿
来源：http://blog.csdn.net/clever101
最近使用gdal库比较多，就谈谈gdal库的一些使用心得。
第一个是GDALOpen的访问权限参数会影响图像的创建金字塔方式。比如你是这样打开图像和创建金字塔：
std::string strImgPath = _T(“C:\\1.tif”); GDALDataset* mGdalDataset=(GDALDataset*)(GDALOpen(strImgPath.c_str(),GA_Update)); mGdalDataset -&gt;BuildOverviews(_T(&#34;NEAREST&#34;),nLevel,pBandList,0,NULL,GdalBuildPyramidProgress,NULL); 运行完这段代码之后你会奇怪地发现在图像文件所在的文件夹并没有ovr文件或rrd文件出现，那么究竟有没有金字塔生成呢？实际上是有的。那么图像金字塔数据究竟存储在哪里，我猜测是存储在图像文件本身去了。为何这么说呢？因为我试着把第一行代码的GA_Update改为GA_ReadOnly，结果出现了ovr文件，也就是说当设置为GA_Update，金字塔数据是有可能放在图像文件的，当然我没有确认。这里还有一些疑问：如果金字塔数据是存储在文件里，那么对于tif文件具体是存储在哪里？对于其它图像文件又是存储在哪里呢？
第二个在调用完RasterIO函数对图像进行写入操作之后只是保留在缓存，需要再调用FlushCache函数才能真正把数据写到磁盘去。
第三个是网上有一篇关于坐标转换的教程：GDAL库学习笔记(五):坐标系之间的转化。其中有一段代码是这样的：
OGRSpatialReference oUTM, *poLatLong; OGRCoordinateTransformation *poTransform; oUTM.SetProjCS(&#34;UTM 17 / WGS84&#34;); oUTM.SetWellKnownGeogCS( &#34;WGS84&#34; ); oUTM.SetUTM( 17 ); poLatLong = oUTM.CloneGeogCS(); poTransform = OGRCreateCoordinateTransformation( &amp;oUTM, poLatLong ); if( poTransform == NULL ) { ... } ... if( !poTransform-&gt;Transform( nPoints, x, y, z ) ) ... 我试过多次，OGRCreateCoordinateTransformation总是执行失败。后来看了gdal的源码，发现ogr集成prj4库进行投影坐标转换颇有些坑爹的地方。我们看一些OGRCreateCoordinateTransformation函数大致是怎么做的：
OGRCreateCoordinateTransformation函数大致是怎么做的： OGRCoordinateTransformation* OGRCreateCoordinateTransformation( OGRSpatialReference *poSource, OGRSpatialReference *poTarget ) { OGRProj4CT *poCT; if( !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/216d655acb81623d7404e09db590d79f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-09-15T23:34:00+08:00" />
<meta property="article:modified_time" content="2013-09-15T23:34:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">gdal库的三个使用心得</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="font-size:14px;"> </span></p> 
 <p><span style="font-size:14px;">作者：朱金灿</span></p> 
 <p><span style="font-size:14px;">来源：<a href="http://blog.csdn.net/clever101">http://blog.csdn.net/clever101</a></span></p> 
 <p><span style="font-size:14px;"> </span></p> 
 <p><span style="font-size:14px;">         最近使用gdal库比较多，就谈谈gdal库的一些使用心得。</span></p> 
 <p><span style="font-size:14px;">         第一个是GDALOpen的访问权限参数会影响图像的创建金字塔方式。比如你是这样打开图像和创建金字塔：</span></p> 
 <p><span style="font-size:14px;"></span></p> 
 <pre><code class="language-cpp">std::string strImgPath = _T(“C:\\1.tif”);
GDALDataset* mGdalDataset=(GDALDataset*)(GDALOpen(strImgPath.c_str(),GA_Update));
mGdalDataset -&gt;BuildOverviews(_T("NEAREST"),nLevel,pBandList,0,NULL,GdalBuildPyramidProgress,NULL);
</code></pre> 
 <br> 
 <p></p> 
 <p>        运行完这段代码之后你会奇怪地发现在图像文件所在的文件夹并没有ovr文件或rrd文件出现，那么究竟有没有金字塔生成呢？实际上是有的。那么图像金字塔数据究竟存储在哪里，我猜测是存储在图像文件本身去了。为何这么说呢？因为我试着把第一行代码的<span style="color:#010001;">GA_Update</span><span style="color:#010001;">改为GA_ReadOnly</span>，结果出现了ovr文件，也就是说当设置为GA_Update，金字塔数据是有可能放在图像文件的，当然我没有确认。这里还有一些疑问：如果金字塔数据是存储在文件里，那么对于tif文件具体是存储在哪里？对于其它图像文件又是存储在哪里呢？</p> 
 <p><span style="color:#010001;">      </span></p> 
 <p><span style="color:#010001;">        </span><span style="color:#010001;">第二个在调用完RasterIO</span>函数对图像进行写入操作之后只是保留在缓存，需要再调用FlushCache函数才能真正把数据写到磁盘去。</p> 
 <p><span style="color:#010001;"> </span></p> 
 <p><span style="color:#010001;">       </span><span style="color:#010001;">第三个是网上有一篇关于坐标转换的教程：<a href="http://blog.sina.com.cn/s/blog_6e51df7f0100ui7n.html" rel="nofollow">GDAL库学习笔记(</a></span>五):坐标系之间的转化。其中有一段代码是这样的：</p> 
 <p></p> 
 <pre><code class="language-cpp">OGRSpatialReference    oUTM, *poLatLong;
OGRCoordinateTransformation *poTransform;
oUTM.SetProjCS("UTM 17 / WGS84");
oUTM.SetWellKnownGeogCS( "WGS84" );
 oUTM.SetUTM( 17 );
 poLatLong = oUTM.CloneGeogCS();
 poTransform = OGRCreateCoordinateTransformation( &amp;oUTM, poLatLong );
 if( poTransform == NULL )
 {
     ...
 }
  ...
if( !poTransform-&gt;Transform( nPoints, x, y, z ) )
  ...
</code></pre> 
 <br> 
 <p></p> 
 <p><span style="color:#010001;">        我试过多次，</span>OGRCreateCoordinateTransformation总是执行失败。后来看了gdal的源码，发现ogr集成prj4库进行投影坐标转换颇有些坑爹的地方。我们看一些OGRCreateCoordinateTransformation函数大致是怎么做的：</p> 
 <p></p> 
 <pre><code class="language-cpp">OGRCreateCoordinateTransformation函数大致是怎么做的：
OGRCoordinateTransformation*  
OGRCreateCoordinateTransformation( OGRSpatialReference *poSource, 
                                   OGRSpatialReference *poTarget )

{
    OGRProj4CT  *poCT;

    if( !LoadProjLibrary() )
    {
        CPLError( CE_Failure, CPLE_NotSupported, 
                  "Unable to load PROJ.4 library (%s), creation of\n"
                  "OGRCoordinateTransformation failed.",
                  GetProjLibraryName() );
        return NULL;
    }

    poCT = new OGRProj4CT();
    
    if( !poCT-&gt;Initialize( poSource, poTarget ) )
    {
        delete poCT;
        return NULL;
    }
    else
    {
        return poCT;
    }
}
</code></pre>         其中 
 <span style="color:#010001;">LoadProjLibrary</span> 
 <span style="color:#010001;">的含义很明显，就是加载prj4</span>库。我们再看看 
 <span style="color:#010001;">LoadProjLibrary</span> 
 <span style="color:#010001;">函数</span>： 
 <br> 
 <p></p> 
 <p></p> 
 <pre><code class="language-cpp">static int LoadProjLibrary()

{
    CPLMutexHolderD( &amp;hPROJMutex );
    static int  bTriedToLoad = FALSE;
    const char *pszLibName;
    
    if( bTriedToLoad )
        return( pfn_pj_transform != NULL );

    bTriedToLoad = TRUE;

    pszLibName = GetProjLibraryName();

#ifdef PROJ_STATIC
    pfn_pj_init = pj_init;
    pfn_pj_init_plus = pj_init_plus;
    pfn_pj_fwd = pj_fwd;
    pfn_pj_inv = pj_inv;
    pfn_pj_free = pj_free;
    pfn_pj_transform = pj_transform;
    pfn_pj_get_errno_ref = (int *(*)(void)) pj_get_errno_ref;
    pfn_pj_strerrno = pj_strerrno;
    pfn_pj_dalloc = pj_dalloc;
#if PJ_VERSION &gt;= 446
    pfn_pj_get_def = pj_get_def;
#endif    
#else
    CPLPushErrorHandler( CPLQuietErrorHandler );

    pfn_pj_init = (projPJ (*)(int, char**)) CPLGetSymbol( pszLibName,
                                                       "pj_init" );
    CPLPopErrorHandler();
    
    if( pfn_pj_init == NULL )
       return( FALSE );

    pfn_pj_init_plus = (projPJ (*)(const char *)) 
        CPLGetSymbol( pszLibName, "pj_init_plus" );
    pfn_pj_fwd = (projUV (*)(projUV,projPJ)) 
        CPLGetSymbol( pszLibName, "pj_fwd" );
    pfn_pj_inv = (projUV (*)(projUV,projPJ)) 
        CPLGetSymbol( pszLibName, "pj_inv" );
    pfn_pj_free = (void (*)(projPJ)) 
        CPLGetSymbol( pszLibName, "pj_free" );
    pfn_pj_transform = (int (*)(projPJ,projPJ,long,int,double*,
                                double*,double*))
                        CPLGetSymbol( pszLibName, "pj_transform" );
    pfn_pj_get_errno_ref = (int *(*)(void))
        CPLGetSymbol( pszLibName, "pj_get_errno_ref" );
    pfn_pj_strerrno = (char *(*)(int))
        CPLGetSymbol( pszLibName, "pj_strerrno" );

    CPLPushErrorHandler( CPLQuietErrorHandler );
    pfn_pj_get_def = (char *(*)(projPJ,int))
        CPLGetSymbol( pszLibName, "pj_get_def" );
    pfn_pj_dalloc = (void (*)(void*))
        CPLGetSymbol( pszLibName, "pj_dalloc" );
    CPLPopErrorHandler();

#endif

    if( pfn_pj_transform == NULL )
    {
        CPLError( CE_Failure, CPLE_AppDefined, 
                  "Attempt to load %s, but couldn't find pj_transform.\n"
                  "Please upgrade to PROJ 4.1.2 or later.", 
                  pszLibName );

        return FALSE;
    }

    return( TRUE );
}
</code></pre> 
 <br> 
 <p></p> 
 <p>         gdal库集成prj4库有两种方式：静态库集成和动态库集成，使用预处理器<span style="color:#010001;">PROJ_STATIC</span>。首先看看静态库集成：</p> 
 <pre><code class="language-cpp">    pfn_pj_init = pj_init;
    pfn_pj_init_plus = pj_init_plus;
    pfn_pj_fwd = pj_fwd;
    pfn_pj_inv = pj_inv;
    pfn_pj_free = pj_free;
    pfn_pj_transform = pj_transform;
    pfn_pj_get_errno_ref = (int *(*)(void)) pj_get_errno_ref;
    pfn_pj_strerrno = pj_strerrno;
    pfn_pj_dalloc = pj_dalloc;
</code></pre> 
 <br> 
 <p>           这里只是函数指针的赋值，那么函数调用的地方在哪里呢？我并没有找到。动态库集成就更扯淡了，首先通过<span style="color:#010001;">GetProjLibraryName</span><span style="color:#010001;">函数获取prj4</span>库的动态库名字，这里名字规定为：</p> 
 <pre><code class="language-cpp">#if (defined(WIN32) || defined(WIN32CE)) &amp;&amp; !defined(__MINGW32__)
#  define LIBNAME      "proj.dll"
#elif defined(__CYGWIN__) || defined(__MINGW32__)
// XXX: If PROJ.4 library was properly built using libtool in Cygwin or MinGW
// environments it has the interface version number embedded in the file name
// (it is CURRENT-AGE number). If DLL came somewhere else (e.g. from MSVC
// build) it can be named either way, so use PROJSO environment variable to
// specify the right library name. By default assume that in Cygwin/MinGW all
// components were buit in the same way.
#  define LIBNAME      "libproj-0.dll"
#elif defined(__APPLE__)
#  define LIBNAME      "libproj.dylib"
#else
#  define LIBNAME      "libproj.so"
#endif
</code></pre>   
 <p>          也就是说假如在windows平台下不叫proj.dll，压根加载不了prj4库，还有致命一条：proj.dll究竟放在哪个路径下呢？据我经验，LoadLibrary没有指定路径的话，在Windows平台只能在当前目录和在系统环境变量路径中找到，具体见：<a href="http://www.cnblogs.com/clever101/archive/2010/05/05/1728435.html" rel="nofollow">关于DLL搜索路径的顺序问题</a>。动态库集成和静态库集成存在一样的问题，只找到函数地址，并不见调用的地方。</p> 
 <br> 
 <p><br></p> 
 <br> 
 <p><br></p> 
 <p><br></p> 
 <br> 
</div> 
<p>转载于:https://www.cnblogs.com/lanzhi/p/6470488.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dafc3b143c13b469d9bd8c6c7c10b75c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用LoadRunner判断HTTP服务器的返…</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de9083ab562e84aeeb602793c90b6c25/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">XBMC插件addon.xml编写说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>