<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>南京邮电大学面向对象程序设计及C&#43;&#43;实验2：继承与派生实验 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="南京邮电大学面向对象程序设计及C&#43;&#43;实验2：继承与派生实验" />
<meta property="og:description" content="一、实验目的和要求
（1）掌握单继承和多重继承下派生类的定义方法，理解基类成员在不同的继承方式下不同的访问属性。
（2）正确定义派生类的构造函数与析构函数，理解定义一个派生类对象时各个构造函数、析构函数被调用的顺序。
（3）正确定义虚基类，消除在多层次多重继承方式下顶层基类中成员访问的二义性问题，关注此时各构造函数、析构函数的调用顺序。
（4）通过基类与公有派生类的定义，及基类对象、指针、引用与派生类的对象、地址间相互赋值的方法，正确理解赋值兼容的4种情况，通过程序理解其不可逆性。
二、实验环境(实验设备)
硬件: 微型计算机
软件: Windows 操作系统、Microsoft Visual Studio 2010
三、实验原理及内容
实验题目1: 定义一个车基类，派生出自行车类和汽车类，又以自行车类和汽车类为基类共同派生出摩托车类，每个类都要定义带有参数的构造函数。对自行车类继承车基类的方式分别用private、protected、public，观察基类成员在派生类中的访问属性；观察自行车类、汽车类和摩托车类对象定义时构造、析构函数的调用顺序。最后将车基类定义为虚基类再观察程序运行结果。
实验解答：
①根据提示进行填写完整实验指导204页代码对应位置内容如下：
( 1 ) MaxSpeed = m; ( 2 ) Weight = w; ( 3 ) Vehicle(m,w) ( 4 ) Height = h; ( 5 ) Vehicle::Show() ; ( 6 ) cout&lt;&lt;”It’s height is:”&lt;&lt;Height&lt;&lt;endl; ( 7 ) Bicycle b(100,100,100); 此时程序的运行结果是：
Constructing Vehicle...
Constructing Bicycle...
The vehicle is running!
Please stop running!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/00ef9bb8479cf083198a3de8a30995bf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-29T13:14:06+08:00" />
<meta property="article:modified_time" content="2023-04-29T13:14:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">南京邮电大学面向对象程序设计及C&#43;&#43;实验2：继承与派生实验</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="background-color:#f3f3f4;">一、实验目的和要求</span></strong><br><span style="background-color:#f3f3f4;">（1）掌握单继承和多重继承下派生类的定义方法，理解基类成员在不同的继承方式下不同的访问属性。</span><br><span style="background-color:#f3f3f4;">（2）正确定义派生类的构造函数与析构函数，理解定义一个派生类对象时各个构造函数、析构函数被调用的顺序。</span><br><span style="background-color:#f3f3f4;">（3）正确定义虚基类，消除在多层次多重继承方式下顶层基类中成员访问的二义性问题，关注此时各构造函数、析构函数的调用顺序。</span><br><span style="background-color:#f3f3f4;">（4）通过基类与公有派生类的定义，及基类对象、指针、引用与派生类的对象、地址间相互赋值的方法，正确理解赋值兼容的4种情况，通过程序理解其不可逆性。</span></p> 
<p><strong><span style="background-color:#f3f3f4;">二、实验环境(实验设备)</span></strong><br><span style="background-color:#f3f3f4;">硬件:  微型计算机</span><br><span style="background-color:#f3f3f4;">软件:  Windows 操作系统、Microsoft Visual Studio 2010</span></p> 
<p><strong><span style="background-color:#f3f3f4;">三、实验原理及内容</span></strong><br><span style="background-color:#f3f3f4;"><span style="color:#fe2c24;">实验题目1: </span>定义一个车基类，派生出自行车类和汽车类，又以自行车类和汽车类为基类共同派生出摩托车类，每个类都要定义带有参数的构造函数。对自行车类继承车基类的方式分别用private、protected、public，观察基类成员在派生类中的访问属性；观察自行车类、汽车类和摩托车类对象定义时构造、析构函数的调用顺序。最后将车基类定义为虚基类再观察程序运行结果。</span><br><span style="background-color:#f3f3f4;">实验解答：</span><br><strong><span style="background-color:#f3f3f4;"><span style="color:#fe2c24;">①根据提示进行填写完整实验指导204页代码对应位置内容如下</span>：</span></strong><br><strong><span style="background-color:#c7e6ea;">( 1 ) MaxSpeed = m;                                                          </span><br><span style="background-color:#c7e6ea;">( 2 )  Weight = w;                                                         </span><br><span style="background-color:#c7e6ea;">( 3 ) Vehicle(m,w)                                                          </span><br><span style="background-color:#c7e6ea;">( 4 )   Height = h;                                                        </span><br><span style="background-color:#c7e6ea;">( 5 )  Vehicle::Show() ;                                                         </span><br><span style="background-color:#c7e6ea;">( 6 ) cout&lt;&lt;”It’s height is:”&lt;&lt;Height&lt;&lt;endl;                                                          </span><br><span style="background-color:#c7e6ea;">( 7 ) Bicycle b(100,100,100);   </span>  </strong>                                                     </p> 
<p><span style="background-color:#f3f3f4;">此时程序的运行结果是：</span><br><strong><span style="background-color:#c7e6ea;">Constructing Vehicle...</span><br><span style="background-color:#c7e6ea;">Constructing Bicycle...</span><br><span style="background-color:#c7e6ea;">The vehicle is running!</span><br><span style="background-color:#c7e6ea;">Please stop running!</span><br><span style="background-color:#c7e6ea;">It’s maxspeed is:100</span><br><span style="background-color:#c7e6ea;">It’s weight is:100</span><br><span style="background-color:#c7e6ea;">It’s height is:100</span><br><span style="background-color:#c7e6ea;">Constructing Bicycle...</span><br><span style="background-color:#c7e6ea;">Destructing Vehicle..</span></strong><span style="background-color:#c7e6ea;">.</span></p> 
<p><br><strong><span style="color:#fe2c24;">② 将继承方式改为private或protected，观察并分析程序的编译结果。</span></strong></p> 
<p><span style="background-color:#eaf4fc;">“Vehicle::Run”不可访问，因为“Bicycle”使用“private”从“Vehicle”继承”</span><br><span style="background-color:#eaf4fc;">“Vehicle::Stop”不可访问，因为“Bicycle”使用“private”从“Vehicle”继承”</span></p> 
<p><span style="color:#fe2c24;"><strong>③ 在Bicycle类下面增加Car类的定义，参考实验教材给出的代码，划线部分自己完成。</strong></span><br><span style="background-color:#e7fafa;">( 8 )  Vehicle(m,w)                                                          </span><br><span style="background-color:#e7fafa;">( 9 )  SeatNum = s;                                                          </span><br><span style="background-color:#e7fafa;">( 10 )  Vehicle::Show;                                                         </span><br><span style="background-color:#e7fafa;">( 11 )  cout&lt;&lt;”The number of seats is:”&lt;&lt;SeatNum&lt;&lt;endl;                                                         </span><br><span style="background-color:#e7fafa;">( 12 )  b(100,100,100);                                                         </span><br><span style="background-color:#e7fafa;">( 13 )  c(100,100,100);     </span>                                                     </p> 
<p><strong><span style="color:#fe2c24;">④ 增加的第3层类MotorCycle及修改以后的main( )函数，代码参见实验教材。</span></strong><br><span style="background-color:#eaf4fc;">( 14 ) Bicycle(m,w,h),Car(m,w,s)                                                          </span><br><span style="background-color:#eaf4fc;">( 15 )mc(100,100,100,100)   </span>                                                        </p> 
<p><strong><span style="color:#fe2c24;">⑤ 将Vehicle声明为虚基类以消除二义性，具体要在上面的基础上修改3个地方。</span></strong><br>   将class Bicycle: public Vehicle 修改为 class Bicycle: virtual public Vehicle。<br>   将class Car: public Vehicle 修改为 class Car: virtual public Vehicle。<br>   在第3层类的构造函数MotorCycle(int m,int w,int h,int s):   （16）            的初始化列表中增加对虚基类构造函数的调用。<br><span style="background-color:#eaf4fc;">( 16 ) Vehicle(m,w),Bicycle(m,w,h),Car(m,w,s)   </span>                                                       </p> 
<p><span style="background-color:#f3f3f4;"><span style="color:#fe2c24;">实验题目2：</span>定义Base类及它的公有派生类Derived类，两个类中均定义带参数的构造函数，基类中定义函数Show( )，派生类中也定义一个同名的Show( )，二者输出内容有所区别。主函数中定义基类的对象、指针、引用，也定义派生类的对象。</span><br><span style="background-color:#f3f3f4;">① 对赋值兼容的4种情况作测试，对每行的输出结果进行观察，理解赋值兼容何时调用基类的成员函数，什么情况下才会调用派生类的成员函数。</span><br><span style="background-color:#f3f3f4;">② 在主函数的return 0;语句前增加4条语句，观察并记下编译时的报错信息，理解赋值兼容的不可逆性。</span><br> 实验解答：<br><span style="color:#fe2c24;"><strong>① 按提示将程序填写完整，代码参见实验教材，对应位置内容是：</strong></span><br><span style="background-color:#eaf4fc;">(1 ) b1(1) ;                                                               </span><br><span style="background-color:#eaf4fc;">(2 ) d1(2) ;                                                               </span><br><span style="background-color:#eaf4fc;">(3 ) b1 = d1;                                                                </span><br><span style="background-color:#eaf4fc;">(4 ) &amp;b2 = d1;                                                                </span><br><span style="background-color:#eaf4fc;">(5 ) *b3 = &amp;d1                                                                </span><br><span style="background-color:#eaf4fc;">(6 ) =new Drived(1);     </span>                                                           </p> 
<p>程序的运行结果是：<br><span style="background-color:#eaf4fc;">基类对象 b1.show():</span><br><span style="background-color:#eaf4fc;">i in Base is:1</span><br><span style="background-color:#eaf4fc;">基类b1=d1,b1.show():</span><br><span style="background-color:#eaf4fc;">i in Base is:2</span><br><span style="background-color:#eaf4fc;">派生类对象 d1.show():</span><br><span style="background-color:#eaf4fc;">i in Derived is:2</span><br><span style="background-color:#eaf4fc;">引用b2=d1,b2.show():</span><br><span style="background-color:#eaf4fc;">i in Base is:2</span><br><span style="background-color:#eaf4fc;">基类指针b3=&amp;d1,b3-&gt;show():</span><br><span style="background-color:#eaf4fc;">i in Base is:2</span><br><span style="background-color:#eaf4fc;">基类指针b4=d4,b4-&gt;show():</span><br><span style="background-color:#eaf4fc;">i in Base is:1</span><br><span style="background-color:#eaf4fc;">派生类指针d4,d4-&gt;show():</span><br><span style="background-color:#eaf4fc;">i in Derived is:1</span></p> 
<p><br> ② 在主函数的return 0;语句前增加4条语句：<br> Derived d5=b1;<br> Derived &amp;d6=b1;<br> Derived *d7=&amp;b1;<br> d7=b3;<br><span style="color:#fe2c24;"><strong>观察并记下编译时的报错信息，理解赋值兼容的不可逆性。</strong></span><br><span style="background-color:#eaf4fc;">“初始化”: 无法从“Base”转换为“Derived”</span><br><span style="background-color:#eaf4fc;">无构造函数可以接受源类型，或构造函数重载决策不明确</span><br><span style="background-color:#eaf4fc;">“初始化”: 无法从“Base”转换为“Derived &amp;”</span><br><span style="background-color:#eaf4fc;">“初始化”: 无法从“Base *”转换为“Derived *”</span><br><span style="background-color:#eaf4fc;">从基类型到派生类型的强制转换需要 dynamic_cast 或 static_cast</span><br><span style="background-color:#eaf4fc;">“=”: 无法从“Base *”转换为“Derived *”</span><br><span style="background-color:#eaf4fc;">从基类型到派生类型的强制转换需要 dynamic_cast 或 static_cast</span></p> 
<p>四、实验小结（包括问题和解决方法、心得体会、意见与建议等）<br> (一)实验中遇到的主要问题及解决方法<br><strong><span style="color:#fe2c24;">1.在题目（1）中将Bicycle继承Vehicle类的方式分别修改为protected和private，再重新编译，请在小结中记录报错信息，解释原因。记录采取何种修改方式使程序正确运行？</span></strong><br><span style="background-color:#eaf4fc;">报错: “Vehicle::Run”不可访问，因为“Bicycle”使用“private”方式从“Vehicle”继承</span><br><span style="background-color:#eaf4fc;">“Vehicle::Stop”不可访问，因为“Bicycle”使用“private”方式从“Vehicle”继承</span><br><span style="background-color:#eaf4fc;">“Vehicle::Stop”不可访问，因为“Bicycle”使用“protected”方式从“Vehicle”继承</span><br><span style="background-color:#eaf4fc;">因为基类中的成员函数都是派生类的私有的或保护的成员函数，类外用派生类对象都不能再调用。</span><br><span style="background-color:#eaf4fc;">采取 public 继承方式可以使程序正确运行</span></p> 
<p><br><strong><span style="color:#fe2c24;">2. 在题目（2）中观察运行结果，总结在有赋值兼容的情况下，何时调用基类的成员函数，何时才会调用派生类的成员函数。</span></strong><br><span style="background-color:#eaf4fc;">对基类调用非虚函数时总是调用基类的成员函数。</span><br><span style="background-color:#eaf4fc;">对基类调用虚函数时：</span><br><span style="background-color:#eaf4fc;">1.对基类对象进行赋值时，调用的是基类的成员函数。</span><br><span style="background-color:#eaf4fc;">2.对基类的对象引用和基类的对象指针进行赋值时，调用的属是派生类的成员函数。</span></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/63ca124a1890a46abd26ad3d8f951a59/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据拟合的相关函数（图像及应用实例 ）- 基于python</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/118dfd0063ac06275f27e2e6833b3e5c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">硬件设计规范</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>