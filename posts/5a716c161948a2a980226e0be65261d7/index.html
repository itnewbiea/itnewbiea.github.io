<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>人工智能和图搜索 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="人工智能和图搜索" />
<meta property="og:description" content="什么是人工智能？ 环顾四周，你会发现人工智能并没有一个明确且单一的定义。有人说，“人工智能被定义为对理性主体的研究”，其中“理性主体可以是任何做出决策的人、公司、机器或软件。它在考虑过去和未来后执行具有最佳结果的行动”。当前感知（代理在给定实例下的感知输入）”。其他则更哲学地试图找到人类自然智能和机器能做的事情之间的界限。
但所有的定义都试图说明，人工智能实际上是一门学科，当你想知道该做什么而你不知道该做什么时。这里出现了一个理性代理，通过一些传感器感知环境并查看它已经执行的旧操作，它尝试选择具有最佳结果的下一个操作。 那么让我们看一个经典的寻路问题。我们有一个包含许多节点的图，您尝试找到两个节点之间成本最小的路径。这是人工智能代理的定义。你并不完全知道路径是什么，而理性主体通过感知环境（在我们的例子中是图表）会找到该路径。
但我们知道有很多算法能够解决图搜索问题。只需查看 DFS、BFS、Dijkstra 或A*即可。我们中的一些人从高中就知道这个算法。那么这里有什么新内容呢？这真的是人工智能代理所做的吗？嗯，是的，但不仅如此。人工智能不仅仅是一种编程范式，就像图搜索算法一样，而且，正如我之前所说，它是对理性主体的研究，这些理性主体研究环境并尝试选择具有最佳结果的行动。
AI 代理是一个广义的术语。它们涉及机器学习、神经网络、深度学习等等，并应用于金融、医疗机构、安全等领域。所以图搜索只是人工智能的一个小子类型。
经典的图搜索算法和能够找到两个节点之间最短路径的人工智能代理之间的区别只是术语的不同。理解这一点很重要，就像你试图创建一个与老式算法实际上没有什么不同的人工智能代理一样。
所有这些算法的要点是，在访问一个节点后，我们必须选择下一个未访问的节点并“访问”它，以查看是否达到目标。
更多关于 BFS 正如我之前所说，广度优先搜索是一种基于树的算法。它的名字来源于图遍历是分层的想法。从源节点开始，我们首先探索邻居，然后进一步向下移动。
我们看下图：
从节点 A 开始，我们看到这个图如何变成一棵树。
A 是位于第 0 层的起始节点，然后 B 和 C 位于第 1 层，然后 D 和 E 位于第 2 层。这就是 BFS 遍历该图的顺序。
如果我们使用 BFS 遍历该图，顺序将是：A -&gt; B -&gt; C -&gt; D -&gt; E。
仔细观察这棵树，我们会发现 B 和 C、E 和 D 之间存在一些联系。发生这种情况是因为我们的图包含循环。但如果我们想最优地遍历它，我们不应该再次访问已经访问过的节点。因此，选择要访问的节点的条件之一就是未被访问。
算法如何工作 考虑到，在访问起始节点之后，我们将继续访问它的所有邻居，然后我们将进入下一个“层”，并且需要一个队列。当我们访问一个节点时，我们检查它的邻居，如果尚未访问邻居，我们将它们添加到队列中。然后，我们实际上只是从队列中选择下一个要访问的节点。我们需要做的另一件事是标记已访问的节点，以便不再访问它们。这样，我们将只访问所有图节点一次。
因此，使用该算法，如果起始节点和目标之间至少存在一条路径，我们就能够找到任何节点。 寻找成本最低的路径 让我们通过在顶点上添加一些成本来更改我们的图。
现在我们想从A到D走成本最低的路径。我们看到从 A 到D有多种方法。我们可以走这条路径，A -&gt; B -&gt; D，成本为 20，或者我们可以选择 A -&gt; C -&gt; B -&gt; D，成本较低，为 16。但是还有另一条成本最低的路径3、A -&gt; C -&gt; E -&gt; D。 那么，我们应该怎么做才能找到这条路径呢？我们需要改变获取下一个节点访问的方式。在经典的BFS算法中，我们采用先进先出的队列顺序（先进先出）来选择下一个要访问的节点。我们最终会找到目标，但不是最便宜的路径。为了以最低的成本到达路径上的目标，我们需要改变从队列中获取下一个要访问的节点的方式。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5a716c161948a2a980226e0be65261d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-30T23:58:31+08:00" />
<meta property="article:modified_time" content="2023-09-30T23:58:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">人工智能和图搜索</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><span style="color:#222635;"><span style="background-color:#ffffff;">什么是人工智能？</span></span></h3> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">环顾四周，你会发现人工智能并没有一个明确且单一的定义。有人说，“人工智能被定义为对理性主体的研究”，其中“理性主体可以是任何做出决策的人、公司、机器或软件。它在考虑过去和未来后执行具有最佳结果的行动”。当前感知（代理在给定实例下的感知输入）”。其他则更哲学地试图找到人类自然智能和机器能做的事情之间的界限。</span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">但所有的定义都试图说明，人工智能实际上是一门学科，当你想知道该做什么而你不知道该做什么时。这里出现了一个理性代理，通过一些传感器感知环境并查看它已经执行的旧操作，它尝试选择具有最佳结果的下一个操作。 </span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">那么让我们看一个经典的寻路问题。我们有一个包含许多节点的图，您尝试找到两个节点之间成本最小的路径。这是人工智能代理的定义。你并不完全知道路径是什么，而理性主体通过感知环境（在我们的例子中是图表）会找到该路径。</span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">但我们知道有很多算法能够解决图搜索问题。只需查看 DFS、BFS、Dijkstra 或<a href="https://dzone.com/articles/from-dijkstra-to-a-star-a" rel="nofollow" title="A*">A*</a>即可。我们中的一些人从高中就知道这个算法。那么这里有什么新内容呢？这真的是人工智能代理所做的吗？嗯，是的，但不仅如此。人工智能不仅仅是一种编程范式，就像图搜索算法一样，而且，正如我之前所说，它是对理性主体的研究，这些理性主体研究环境并尝试选择具有最佳结果的行动。</span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">AI 代理是一个广义的术语。它们涉及机器学习、神经网络、深度学习等等，并应用于金融、医疗机构、安全等领域。所以图搜索只是人工智能的一个小子类型。</span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">经典的图搜索算法和能够找到两个节点之间最短路径的人工智能代理之间的区别只是术语的不同。理解这一点很重要，就像你试图创建一个与老式算法实际上没有什么不同的人工智能代理一样。</span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">所有这些算法的要点是，在访问一个节点后，我们必须选择下一个未访问的节点并“访问”它，以查看是否达到目标。</span></span></p> 
<h4><span style="color:#222635;"><span style="background-color:#ffffff;">更多关于 BFS</span></span></h4> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">正如我之前所说，广度优先搜索是一种基于树的算法。它的名字来源于图遍历是分层的想法。从源节点开始，我们首先探索邻居，然后进一步向下移动。</span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">我们看下图：</span></span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="图片标题" class="fr-dib fr-fin" height="201" src="https://images2.imgbox.com/15/ff/Yg37T75p_o.png" width="481"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">从节点 A 开始，我们看到这个图如何变成一棵树。</span></span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="图片标题" class="fr-dib fr-fin" height="281" src="https://images2.imgbox.com/30/2b/iKBHoowB_o.png" width="451"></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">A 是位于第 0 层的起始节点，然后 B 和 C 位于第 1 层，然后 D 和 E 位于第 2 层。这就是 BFS 遍历该图的顺序。</span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">如果我们使用 BFS 遍历该图，顺序将是：A -&gt; B -&gt; C -&gt; D -&gt; E。</span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">仔细观察这棵树，我们会发现 B 和 C、E 和 D 之间存在一些联系。发生这种情况是因为我们的图包含循环。但如果我们想最优地遍历它，我们不应该再次访问已经访问过的节点。因此，选择要访问的节点的条件之一就是未被访问。</span></span></p> 
<h4><span style="color:#222635;"><span style="background-color:#ffffff;">算法如何工作</span></span></h4> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">考虑到，在访问起始节点之后，我们将继续访问它的所有邻居，然后我们将进入下一个“层”，并且需要一个队列。当我们访问一个节点时，我们检查它的邻居，如果尚未访问邻居，我们将它们添加到队列中。然后，我们实际上只是从队列中选择下一个要访问的节点。我们需要做的另一件事是标记已访问的节点，以便不再访问它们。这样，我们将只访问所有图节点一次。</span></span></p> 
<div> 
 <div> 
  <div> 
   <div style="margin-left:31px;"> 
    <div> 
     <div> 
      <div> 
       <div> 
        <div style="text-align:right;"> 
         <div> 
          <span style="color:#222635;"><span style="background-color:#ffffff;">因此，使用该算法，如果起始节点和目标之间至少存在一条路径，我们就能够找到任何节点。</span></span> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<h4><span style="color:#222635;"><span style="background-color:#ffffff;">寻找成本最低的路径</span></span></h4> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">让我们通过在顶点上添加一些成本来更改我们的图。</span></span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="图片标题" class="fr-dib fr-fin" height="201" src="https://images2.imgbox.com/8c/68/txRc4wwW_o.png" width="481"></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">现在我们想从A到D走成本最低的路径。<em>我们看到从 A 到D</em>有多种方法。我们可以走这条路径，A -&gt; B -&gt; D，成本为 20，或者我们可以选择 A -&gt; C -&gt; B -&gt; D，成本较低，为 16。但是还有另一条成本最低的路径3、A -&gt; C -&gt; E -&gt; D。 那么，我们应该怎么做才能找到这条路径呢？我们需要改变获取下一个节点访问的方式。在经典的BFS算法中，我们采用先进先出的队列顺序（先进先出）来选择下一个要访问的节点。我们最终会找到目标，但不是最便宜的路径。为了以最低的成本到达路径上的目标，我们需要改变从队列中获取下一个要访问的节点的方式。</span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">我将向您介绍的算法称为统一成本搜索，它是 Dijkstra 的稍微修改版本，当我们找到目的地时我们就停下来。经典的 Dijkstra 算法继续访问所有节点，直到队列为空，找到图中从起始节点到每个其他节点的最小成本。与 BFS 不同的是，这里我们必须存储一个新值，表示从开始到当前访问节点迄今为止的总成本。</span></span></p> 
<p style="margin-left:0;"><span style="color:#222635;"><span style="background-color:#ffffff;">队列不会按 FIFO 规则排序，而是根据当前到目前为止的成本值对队列进行排序，优先考虑迄今为止成本最低的未访问节点。</span></span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3243c215a1da7510e8603ff6017777c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu20.04 制作系统ISO镜像并物理机还原</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfd8b2aa448f9033a354962c1c8d0981/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言结构体相关知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>