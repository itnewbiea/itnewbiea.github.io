<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>遗传算法(Genetic Algorithm)之deap学习笔记(一): 基础概念 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="遗传算法(Genetic Algorithm)之deap学习笔记(一): 基础概念" />
<meta property="og:description" content="遗传算法是通过计算机模拟生物学中的染色体用于解决最优化的一种搜索算法。
使用遗传算法要考虑的因素：
个体表征(Individual representation)
评估和适应度分配(Evaluation and fitness assignment)
选择(Selection)
变化(variation)，比如变异(Mutation)和交叉(Crossover)
停止标准(Stopping criterion)，确定算法何时应该停止，要么是因为达到最佳值，要么是因为优化过程没有进行。
一般来说遗传算法的结构为：
def evolutionary_algorithm(): population = [] # a list with all the individuals in the population population = initialize_population(pop_size) t = 0 while not stop_criterion( population[t] ): fitnesses = evaluate( population[t] ) populations[t&#43;1] = environmental_selection( population[t], offspring ) offspring = mating_and_mutation( population[t], fitnesses ) t = t&#43;1 DEAP是一个用于遗传算法计算的 Python 库：
https://deap.readthedocs.io/en/master/
DEAP GA 的基本特征：
deap.creator: 一个允许创建满足进化算法需求的类。
deap.base.Toolbox: 包含进化运算符的进化工具箱。可以使用 register() 方法任何与其他函数填充工具箱。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5d173bf7237d56a085e48d688d7ed5a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-09T02:49:28+08:00" />
<meta property="article:modified_time" content="2023-02-09T02:49:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">遗传算法(Genetic Algorithm)之deap学习笔记(一): 基础概念</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">遗传算法是通过计算机模拟生物学中的染色体用于解决最优化的一种搜索算法。</p> 
 <p style="">使用遗传算法要考虑的因素：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>个体表征(Individual representation)</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>评估和适应度分配(Evaluation and fitness assignment)</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>选择(Selection)</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>变化(variation)，比如变异(Mutation)和交叉(Crossover)</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>停止标准(Stopping criterion)，确定算法何时应该停止，要么是因为达到最佳值，要么是因为优化过程没有进行。</p></li></ul> 
 <p style=""></p> 
 <p style="">一般来说遗传算法的结构为：</p> 
 <pre class="kdocs-python"><code class="language-python">def evolutionary_algorithm():

    population = [] # a list with all the individuals in the population

    population =  initialize_population(pop_size)
    t = 0

    while not stop_criterion( population[t] ):
        fitnesses = evaluate( population[t] )
        populations[t+1] = environmental_selection( population[t], offspring )
        offspring = mating_and_mutation( population[t], fitnesses )
        t = t+1</code></pre> 
 <p style="">DEAP是一个用于遗传算法计算的 Python 库：</p> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://deap.readthedocs.io/en/master/" rel="nofollow noopener noreferrer" target="_blank">https://deap.readthedocs.io/en/master/</a></p> 
 <p style=""></p> 
 <p style="">DEAP GA 的基本特征：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>deap.creator: 一个允许创建满足进化算法需求的类。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>deap.base.Toolbox: 包含进化运算符的进化工具箱。可以使用 register() 方法任何与其他函数填充工具箱。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>deap.base.Fitness([values]): 适应度是用于测量解决方案的质量的一个度量。 如果值作为元组提供，则使用这些值初始化适应度，否则为空（或无效）。 一般应该继承这个类来定义自己的适应度。</p></li></ul> 
 <p style=""></p> 
 <h3 style="">个体表征(Individual representation):</h3> 
 <h4 style="">首先，定义个体及其特征</h4> 
 <pre class="kdocs-python"><code class="language-python">import random

from deap import base
from deap import creator
from deap import tools

IND_SIZE = 5

creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

toolbox1 = base.Toolbox()
toolbox1.register("attr_float", random.random)
toolbox1.register("individual", tools.initRepeat, creator.Individual,
                 toolbox1.attr_float, n=IND_SIZE)</code></pre> 
 <p style="">现在可以构建第一个个体：</p> 
 <pre class="kdocs-python"><code class="language-python">ind1 = toolbox1.individual()</code></pre> 
 <p style="">打印个体 ind1 并检查其适应性：</p> 
 <pre class="kdocs-python"><code class="language-python">print(ind1)
# 应该为类似于这样的信息
# [0.9841619462895895, 0.9475698700500977, 0.05339882337867663, 0.31524481600878207, 0.9304010252473477]
ind1.fitness.valid
# False</code></pre> 
 <p style="">个体被打印为为列表并且适应度无效，因为它不包含任何值。</p> 
 <p style=""></p> 
 <h4 style="">定义个体群体</h4> 
 <p style="">现在可以在register中注册一个人口来填充个体</p> 
 <pre class="kdocs-python"><code class="language-python">toolbox1.register("population", tools.initRepeat, list, toolbox1.individual)</code></pre> 
 <p style="">然后用它来创建初始种群。</p> 
 <pre class="kdocs-python"><code class="language-python">pop = toolbox1.population(n=20) # 20</code></pre> 
 <p style="">第一个个体：</p> 
 <pre class="kdocs-python"><code class="language-python">print( pop[0] )
# [0.9945252850424942, 0.7557223153142187, 0.6154978995613851, 0.433930220107276, 0.9700488979770402]</code></pre> 
 <p style=""></p> 
 <h3 style="">评估和适应度分配(Evaluation and fitness assignment):</h3> 
 <p style="">看第一个个体的评价，就是算法中评价适应度的部分。 对于某些问题，可以通过许多不同的方式进行评估，其中一些比其他的更好。</p> 
 <p style="">在 DEAP 中：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>典型的评估函数将一个个体作为参数，并将其适应度作为元组返回。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>适应度是一个浮点值列表，并且具有一个有效的属性，可以知道这个个体是否应该被重新评估。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>通过将值设置为关联的元组来设置适应度。</p></li></ul> 
 <p style="">例如，下面评估先前创建的个体 ind1 并将其适应度分配给相应的值：</p> 
 <pre class="kdocs-python"><code class="language-python">def evaluate(individual):
     a = sum(individual)
    return a,</code></pre> 
 <p style="">在 DEAP 中处理单一适应度测量没有什么不同。 评估函数仍必须返回一个元组，因为单测度适应度被视为多测度（多目标）适应度的特例。</p> 
 <p style="">如果要评估一个个体，只需调用评估函数即可。 当传递了完整的个体，然后返回到适应度元组，再将其分配给个体适应度值。</p> 
 <pre class="kdocs-python"><code class="language-python">ind1 = pop[0]
ind1.fitness.values = evaluate(ind1)
print(ind1.fitness.valid)
# True
print(ind1)
# [0.9945252850424942, 0.7557223153142187, 0.6154978995613851, 0.433930220107276, 0.9700488979770402]
ind1.fitness.values
# (3.769724618002414,)</code></pre> 
 <p style=""></p> 
 <h3 style="">选择(Selection)</h3> 
 <p style="">通过 deap.operators 模块中可用的选择运算符在种群中进行选择。</p> 
 <p style="">选择运算符通常将一个可迭代的个体容器和要选择的个体数量作为第一个参数。 它返回一个列表，其中包含对所选个体的引用。</p> 
 <p style="">首先，我们必须评估每个个体的适应度。 我们只想评估发生变化的个体的适应性，但是初始种群中没有个体的适应度是已知的，因此我们必须首先评估所有个体。</p> 
 <pre class="kdocs-python"><code class="language-python">fitnesses = list(map(evaluate, pop))</code></pre> 
 <p style="">这为我们提供了与群体中每个个体对应的适应度值列表。 接下来，我们将适应度分配给每个个体。可以使用 zip将具有相应适应度的个体排列起来。</p> 
 <pre class="kdocs-python"><code class="language-python">for ind, fit in zip(pop, fitnesses):
    ind.fitness.values = fit</code></pre> 
 <p style="">在下面的代码中，我们使用一种方法来选择人口中排名前 2 的个体。</p> 
 <pre class="kdocs-python"><code class="language-python">selected = tools.selBest(pop, 2)</code></pre> 
 <p style="">检查是否成功地选择了群体中位置为 0 的个体</p> 
 <pre class="kdocs-python"><code class="language-python">pop[0] in selected
# False</code></pre> 
 <p style="">因此，我们最终得到一份“选定”个体的列表，这些个体可能能够繁殖到下一代。</p> 
 <p style=""></p> 
 <h3 style="">变异(Mutation)</h3> 
 <p style="">deap.tools 模块中有多种变异算子。每个突变都有自己的特点，可以应用于不同类型的个体。</p> 
 <p style="">要对第一个个体应用突变（此处为高斯突变(gaussian mutation)），只需应用所需的函数即可。</p> 
 <pre class="kdocs-python"><code class="language-python">pop[0]
# [0.9945252850424942,
# 0.7557223153142187,
# 0.6154978995613851,
# 0.433930220107276,
# 0.9700488979770402]

tools.mutGaussian(pop[0], mu=0.0, sigma=0.2, indpb=0.2)
# ([1.106753515634373,
#  0.34892623294563724,
#  0.6154978995613851,
#  0.6722066739974353,
#  1.4913149064117197],)</code></pre> 
 <p style="">Mu 和 sigma 是高斯曲线的项，indpb 是每个基因突变的独立概率。</p> 
 <p style="">我们还需要删除个体的 fitness.value，因为它已经发生变化，需要在下次我们需要它的适应性时重新评估。</p> 
 <pre class="kdocs-python"><code class="language-python">del pop[0].fitness.values</code></pre> 
 <p style="">DEAP 中的变异运算符具有破坏性，并会就地突变原始个体。 因此，如果要保留原始父突变前，就必须提前复制。 我们可以使用toolbox中的克隆功能克隆一个个体。</p> 
 <pre class="kdocs-python"><code class="language-python">mutant = toolbox1.clone(pop[0])
tools.mutGaussian(mutant, mu=0.0, sigma=0.2, indpb=0.2)
del mutant.fitness.values</code></pre> 
 <h3 style="">交叉(Crossover)</h3> 
 <p style="">deap.tools 模块中有多种交叉算子。每个算子都有自己的特点，可能适用于不同类型的个体。与变异一样，交叉具有破坏性，因此通常需要先复制个体。 </p> 
 <p style="">下面是克隆种群中前两个个体然后将它们相互交叉的示例</p> 
 <pre class="kdocs-python"><code class="language-python">child1, child2 = [ toolbox1.clone(ind) for ind in (pop[0], pop[1]) ]
tools.cxOnePoint(child1, child2)
del child1.fitness.values
del child2.fitness.values</code></pre> 
 <p style="">和变异一样，因为我们对个体做了改变，所以需要删除它们的 fitness.values 以便下次重新评估它们。</p> 
 <p style="">通常需要设置一个交叉的概率：</p> 
 <pre class="kdocs-python"><code class="language-python">cxProb = 0.6

if random.random() &lt; cxProb:
    child1, child2 = [ toolbox1.clone(ind) for ind in (pop[0], pop[1]) ]
    tools.cxOnePoint(child1, child2)
    del child1.fitness.values
    del child2.fitness.values</code></pre> 
 <p style=""></p> 
 <h3 style="">将运算符和toolbox一起使用</h3> 
 <p style="">toolbox基本上有两种方法，register() 和 unregister()，用于在toolbox中添加或删除。</p> 
 <p style="">比如：</p> 
 <pre class="kdocs-python"><code class="language-python">def evaluateInd(individual):
    return result,

toolbox1.register("mate", tools.cxOnePoint)
toolbox1.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox1.register("select", tools.selTournament, tournsize=3)
toolbox1.register("evaluate", evaluateInd)</code></pre> 
 <p style="">现在可以通过调用toolbox来调用：比如mutate，它将使用注册时的默认参数</p> 
 <pre class="kdocs-python"><code class="language-python">mutant = toolbox1.clone(pop[0])
toolbox1.mutate(mutant)
del mutant.fitness.values</code></pre> 
 <p style=""></p> 
 <p style="">这个笔记简单的介绍了DEAP中遗传算法的结构，后续会继续更新更深层的学习内容。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21b0e54e1173384a19f51dce7521ffd4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于 SmartX 分布式存储的 RDMA 与 TCP/IP 技术与性能对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c7c060b8413613043483841f3098d0c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端调用后端接口,并把数据做分页处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>