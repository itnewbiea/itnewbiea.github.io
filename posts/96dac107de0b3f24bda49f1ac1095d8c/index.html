<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构)" />
<meta property="og:description" content="常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构) 数据结构和算法作为程序员的基本功，一定得稳扎稳打的学习，我们常见的框架底层就是各类数据结构，例如跳表之于redis、B&#43;树之于mysql、倒排索引之于ES，熟悉了底层数据结构，对框架有了更深层次的理解，在后续程序设计过程中就更能得心应手。掌握常见数据结构和算法的重要性显而易见，本文主要讲解了几种常见的数据结构及基础的排序和查找算法，最后对高频算法笔试面试题做了总结。本文会持续补充，希望对大家日常学习或找工作有所帮忙。
文章目录 常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构)1、什么是数据结构？(研究应用程序中数据之间逻辑关系、存储方式及其操作的学问就是数据结构)2、为什么学习数据结构和算法？3、有哪些常见的数据结构？4、说一下几种常见的排序算法和分别的复杂度，java提供的默认排序算法(数组排序)4.1、排序算法4.2、排序工具类Arrays？如何实现一个通用的、高性能的排序函数？(Java语言采用==堆排序==实现排序函数，C语言使用快速排序实现排序函数)4.3、常见的查找算法？4.4、复杂度分析4.5、如何高效地判断无序数组中是否包含某特定值？4.6、查找算法实战？4.7、哪些数据结构有序？ 纳尼，好奇怪的问题 5、数组部分面试题6、链表部分面试题6.1、单链表：next指针 (尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点)6.2、描述一下链式存储结构6.3、倒排一个LinkedList（即链表的反转）6.4、判断一个单链表中是否有环？ 阿里 LeetCode1416.5、判定给定的链表是否已NULL结束，如果链表中存在环，返回环的长度？6.6、快慢指针能解决的问题？ 阿里6.7、实现两个有序的链表合并为一个有序链表(双重遍历) LeetCode23 合并k个排序链表6.8、在有序链表中插入一个结点6.9、求两个单向链表的合并点，合并后成为一个单向链表。假设链表list1和链表list2在相交前的节点数量分别为n和m，n/m大小不确定，求两个链表的合并点。6.10、如何判断一个字符串(链表)是否是回文字符串的问题(字符串是通过单链表来存储)(上海自来水来自海上)6.11、O(1)时间内删除单链表中某一个节点6.12、如何逐对逆置链表？初始1-&gt;2-&gt;3-&gt;4-&gt;X,逐对转置后，为2-&gt;1-&gt;4-&gt;3-&gt;X。6.13、约瑟夫环(N个人想选出一个领头人，他们排成一个环，沿着环每数到第M个人就排除该人，并从下一个人开始重新数，求最后留在环中的人) 7、栈(一种特殊的线性表，只能固定在一端进行插入、删除操作 可分为顺序栈结构和链式栈结构)7.1、栈的特性7.2、栈的使用场景 美团 8、队列部分知识点(关键点：确定队空/队满的判定条件)8.1、具有某种特性的队列：循环队列、阻塞队列、并发队列(在片底层的系统、框架、中间件开发中，起着重要的作用，如高性能队列Disruptor、Linux环形缓存，用到了循环并发队列8.2、队列使用场景 美团8.3、高性能队列Disruptor(内存消息队列) kafka8.4、写一个生产者-消费者队列 政采云问到了 ***非常好的题目 通过arrayblockingqueue的put/take&#43;callable实现，详见后面的阻塞队列 9、递归方法10、散列表相关知识点(HashMap/LinkedHashMap)10.1、什么是hash算法，他们用于什么？10.2、hash函数是怎么实现的？10.3、hash冲突解决方案：(开放定址法/链表法)10.4、面试题 11、字符串处理算法总结：11.1、用Java写一个递归遍历目录下面的所有文件11.2、给定一个txt文件，如何得到某字符串出现的次数11.3、实现一个字符集，只包含a～z这26个英文字母的Trie树（也称为字典树/键树）11.4、实现朴素的字符串匹配算法(暴力匹配算法/BF算法) 12、树部分面试题12.1、如何遍历一棵二叉树？12.2、二叉查找树(二叉搜索树)(Mysql索引的底层)12.3、红黑树的应用场景(TreeMap 红黑树：一种近似平衡的二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1。包括完全二叉树、满二叉树) 红黑树一定得掌握12.4、数据结构 堆12.5、AC自动机：如何用多模式串匹配实现敏感词过滤功能？(使用Trie树)12.6 B树和B&#43;树的区别(为什么 MongoDB 索引选择B树，而 Mysql 选择B&#43;树)? 13、海量数据的处理思路问题13.1、大数据量的问题：13.2、有10G大小的文件，每行记录一条运单信息，机器大小是500M，求出出现次数最多的前1000条运单号，给出思路。13.3、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？13.4、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。13.5、怎么在海量数据中找出重复次数最多的一个？13.6、如果你所在的省有50万考生，如何通过成绩快速排序得出名次呢？13.7、假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序，你有什么比较快速的排序方法呢？13.8、假设我们有1000万个整型数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过100MB，你会怎么做呢？13.9、如何在海量数据中快速查找某个数据？(索引)(在计算机组成中称为寻址)13.10、并行计算：利用并行处理提高算法的执行效率(分治的思想) 14、图的应用14.1、如何存储微博、微信等社交网络中的好友关系？14.2、如何在内存中存储图这种数据结构？14.3、图的其他领域应用？14.4、如何找出社交网络中的三度好友关系？(深度优先和广度优先搜索算法)(存储使用邻接表)(无向图)14.5、如何确定代码源文件的编译依赖关系？(拓扑排序 有向无环图)14.6、最短路径算法 (Dijkstra/A*)14.7、A*搜索算法(实现游戏中的寻路功能) 15、位图(bitmap)与推荐算法15.1、什么是布隆过滤器，其实现原理是？（java.util的BitSet类，实现类位图） False positive指的是？（蚂蚁问到）15.2、概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？15.3、推荐系统 16、断点续传思路和算法 1、什么是数据结构？(研究应用程序中数据之间逻辑关系、存储方式及其操作的学问就是数据结构) 程序中数据大致有四种基本逻辑结构：集合(同属一个集合)/线性关系(一对一)/树形结构(一对多)/图状结构或网状结构(多对多)物理存储结构：顺序存储结构/非顺序结构(链式存储/散列结构)算法的设计取决于逻辑结构；算法的实现依赖于存储结构 2、为什么学习数据结构和算法？ 有3点比较重要 (王争)
1、直接好处是能够有写出性能更优的代码；数据结构：存储；算法：计算； 算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算。 2、算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面；3、长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。 推荐的书籍及教程
《大话数据结构 程杰》入门
《算法图解》
《数据结构与算法分析：Java语言描述》(大学课本 伪代码)
《剑指offer》 使用的C&#43;&#43;语言来实现的，现在我不怎么使用了
《程序员代码面试指南:IT名企算法与数据结构题目最优解》左程云，现在正在看的书
《编程珠玑》(对大数据量处理的算法)
《编程之美》(超级难)
《算法导论》(很厚很无聊)
《算法第四版》(推荐 本书没有动态规划)
《数据结构与算法 极客时间》 王争google
《算法帝国》
《数学之美》
《算法之美》(闲暇阅读) https://github." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/96dac107de0b3f24bda49f1ac1095d8c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-25T13:47:13+08:00" />
<meta property="article:modified_time" content="2022-03-25T13:47:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Java_0"></a>常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构)</h3> 
<blockquote> 
 <p><strong>数据结构和算法</strong>作为程序员的基本功，一定得稳扎稳打的学习，我们常见的框架底层就是各类数据结构，例如跳表之于redis、B+树之于mysql、倒排索引之于ES，熟悉了底层数据结构，<mark>对框架有了更深层次的理解，在后续程序设计过程中就更能得心应手</mark>。掌握常见数据结构和算法的重要性显而易见，本文主要讲解了几种常见的数据结构及基础的排序和查找算法，最后对高频算法笔试面试题做了总结。<mark>本文会持续补充</mark>，希望对大家日常学习或找工作有所帮忙。</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Java_0" rel="nofollow">常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构)</a></li><li><ul><li><a href="#1_5" rel="nofollow">1、什么是数据结构？(研究应用程序中数据之间逻辑关系、存储方式及其操作的学问就是数据结构)</a></li><li><a href="#2_12" rel="nofollow">2、为什么学习数据结构和算法？</a></li><li><a href="#3_41" rel="nofollow">3、有哪些常见的数据结构？</a></li><li><a href="#4java_59" rel="nofollow">4、说一下几种常见的排序算法和分别的复杂度，java提供的默认排序算法(数组排序)</a></li><li><ul><li><a href="#41_60" rel="nofollow">4.1、排序算法</a></li><li><a href="#42ArraysJavaC_287" rel="nofollow">4.2、排序工具类Arrays？如何实现一个通用的、高性能的排序函数？(Java语言采用==堆排序==实现排序函数，C语言使用快速排序实现排序函数)</a></li><li><a href="#43_303" rel="nofollow">4.3、常见的查找算法？</a></li><li><a href="#44_495" rel="nofollow">4.4、复杂度分析</a></li><li><a href="#45_513" rel="nofollow">4.5、如何高效地判断无序数组中是否包含某特定值？</a></li><li><a href="#46_539" rel="nofollow">4.6、查找算法实战？</a></li><li><a href="#47___551" rel="nofollow">4.7、哪些数据结构有序？ 纳尼，好奇怪的问题</a></li></ul> 
    </li><li><a href="#5_553" rel="nofollow">5、数组部分面试题</a></li><li><a href="#6_656" rel="nofollow">6、链表部分面试题</a></li><li><ul><li><a href="#61next_NULL_657" rel="nofollow">6.1、单链表：next指针 (尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点)</a></li><li><a href="#62_701" rel="nofollow">6.2、描述一下链式存储结构</a></li><li><a href="#63LinkedList_705" rel="nofollow">6.3、倒排一个LinkedList（即链表的反转）</a></li><li><a href="#64___LeetCode141_729" rel="nofollow">6.4、判断一个单链表中是否有环？ 阿里 LeetCode141</a></li><li><a href="#65NULL_762" rel="nofollow">6.5、判定给定的链表是否已NULL结束，如果链表中存在环，返回环的长度？</a></li><li><a href="#66_____796" rel="nofollow">6.6、快慢指针能解决的问题？ 阿里</a></li><li><a href="#67_LeetCode23_k_856" rel="nofollow">6.7、实现两个有序的链表合并为一个有序链表(双重遍历) LeetCode23 合并k个排序链表</a></li><li><a href="#68_899" rel="nofollow">6.8、在有序链表中插入一个结点</a></li><li><a href="#69list1list2nmnm_921" rel="nofollow">6.9、求两个单向链表的合并点，合并后成为一个单向链表。假设链表list1和链表list2在相交前的节点数量分别为n和m，n/m大小不确定，求两个链表的合并点。</a></li><li><a href="#610_971" rel="nofollow">6.10、如何判断一个字符串(链表)是否是回文字符串的问题(字符串是通过单链表来存储)(上海自来水来自海上)</a></li><li><a href="#611O1_980" rel="nofollow">6.11、O(1)时间内删除单链表中某一个节点</a></li><li><a href="#6121234X2143X_986" rel="nofollow">6.12、如何逐对逆置链表？初始1-&gt;2-&gt;3-&gt;4-&gt;X,逐对转置后，为2-&gt;1-&gt;4-&gt;3-&gt;X。</a></li><li><a href="#613NM_1005" rel="nofollow">6.13、约瑟夫环(N个人想选出一个领头人，他们排成一个环，沿着环每数到第M个人就排除该人，并从下一个人开始重新数，求最后留在环中的人)</a></li></ul> 
    </li><li><a href="#7__1031" rel="nofollow">7、栈(一种特殊的线性表，只能固定在一端进行插入、删除操作 可分为顺序栈结构和链式栈结构)</a></li><li><ul><li><a href="#71_1032" rel="nofollow">7.1、栈的特性</a></li><li><a href="#72___1046" rel="nofollow">7.2、栈的使用场景 美团</a></li></ul> 
    </li><li><a href="#8_1297" rel="nofollow">8、队列部分知识点(关键点：确定队空/队满的判定条件)</a></li><li><ul><li><a href="#81DisruptorLinux_1298" rel="nofollow">8.1、具有某种特性的队列：循环队列、阻塞队列、并发队列(在片底层的系统、框架、中间件开发中，起着重要的作用，如高性能队列Disruptor、Linux环形缓存，用到了循环并发队列</a></li><li><a href="#82__1303" rel="nofollow">8.2、队列使用场景 美团</a></li><li><a href="#83Disruptor__kafka_1309" rel="nofollow">8.3、高性能队列Disruptor(内存消息队列) kafka</a></li><li><a href="#84_______arrayblockingqueueputtakecallable_1655" rel="nofollow">8.4、写一个生产者-消费者队列 政采云问到了 ***非常好的题目 通过arrayblockingqueue的put/take+callable实现，详见后面的阻塞队列</a></li></ul> 
    </li><li><a href="#9_1660" rel="nofollow">9、递归方法</a></li><li><a href="#10HashMapLinkedHashMap_1874" rel="nofollow">10、散列表相关知识点(HashMap/LinkedHashMap)</a></li><li><ul><li><a href="#101hash_1875" rel="nofollow">10.1、什么是hash算法，他们用于什么？</a></li><li><a href="#102hash_1908" rel="nofollow">10.2、hash函数是怎么实现的？</a></li><li><a href="#103hash_1932" rel="nofollow">10.3、hash冲突解决方案：(开放定址法/链表法)</a></li><li><a href="#104_1959" rel="nofollow">10.4、面试题</a></li></ul> 
    </li><li><a href="#11_2100" rel="nofollow">11、字符串处理算法总结：</a></li><li><ul><li><a href="#111Java_2104" rel="nofollow">11.1、用Java写一个递归遍历目录下面的所有文件</a></li><li><a href="#112txt_2118" rel="nofollow">11.2、给定一个txt文件，如何得到某字符串出现的次数</a></li><li><a href="#113az26Trie_2132" rel="nofollow">11.3、实现一个字符集，只包含a～z这26个英文字母的Trie树（也称为字典树/键树）</a></li><li><a href="#114BF_2176" rel="nofollow">11.4、实现朴素的字符串匹配算法(暴力匹配算法/BF算法)</a></li></ul> 
    </li><li><a href="#12_2428" rel="nofollow">12、树部分面试题</a></li><li><ul><li><a href="#121_2429" rel="nofollow">12.1、如何遍历一棵二叉树？</a></li><li><a href="#122Mysql_2520" rel="nofollow">12.2、二叉查找树(二叉搜索树)(Mysql索引的底层)</a></li><li><a href="#123TreeMap_1______2607" rel="nofollow">12.3、红黑树的应用场景(TreeMap 红黑树：一种近似平衡的二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1。包括完全二叉树、满二叉树) 红黑树一定得掌握</a></li><li><a href="#124__2633" rel="nofollow">12.4、数据结构 堆</a></li><li><a href="#125ACTrie_2676" rel="nofollow">12.5、AC自动机：如何用多模式串匹配实现敏感词过滤功能？(使用Trie树)</a></li><li><a href="#126_BB_MongoDB_B_Mysql_B_2703" rel="nofollow">12.6 B树和B+树的区别(为什么 MongoDB 索引选择B树，而 Mysql 选择B+树)?</a></li></ul> 
    </li><li><a href="#13_2726" rel="nofollow">13、海量数据的处理思路问题</a></li><li><ul><li><a href="#131_2727" rel="nofollow">13.1、大数据量的问题：</a></li><li><a href="#13210G500M1000_2731" rel="nofollow">13.2、有10G大小的文件，每行记录一条运单信息，机器大小是500M，求出出现次数最多的前1000条运单号，给出思路。</a></li><li><a href="#133ab50urlurl644Gaburl_2737" rel="nofollow">13.3、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</a></li><li><a href="#1342525_2744" rel="nofollow">13.4、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</a></li><li><a href="#135_2749" rel="nofollow">13.5、怎么在海量数据中找出重复次数最多的一个？</a></li><li><a href="#13650_2753" rel="nofollow">13.6、如果你所在的省有50万考生，如何通过成绩快速排序得出名次呢？</a></li><li><a href="#1371010_2754" rel="nofollow">13.7、假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</a></li><li><a href="#138100081000_100MB_2755" rel="nofollow">13.8、假设我们有1000万个整型数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过100MB，你会怎么做呢？</a></li><li><a href="#139_2757" rel="nofollow">13.9、如何在海量数据中快速查找某个数据？(索引)(在计算机组成中称为寻址)</a></li><li><a href="#1310_2831" rel="nofollow">13.10、并行计算：利用并行处理提高算法的执行效率(分治的思想)</a></li></ul> 
    </li><li><a href="#14_2840" rel="nofollow">14、图的应用</a></li><li><ul><li><a href="#141_2841" rel="nofollow">14.1、如何存储微博、微信等社交网络中的好友关系？</a></li><li><a href="#142_2856" rel="nofollow">14.2、如何在内存中存储图这种数据结构？</a></li><li><a href="#143_2864" rel="nofollow">14.3、图的其他领域应用？</a></li><li><a href="#144_2870" rel="nofollow">14.4、如何找出社交网络中的三度好友关系？(深度优先和广度优先搜索算法)(存储使用邻接表)(无向图)</a></li><li><a href="#145__2879" rel="nofollow">14.5、如何确定代码源文件的编译依赖关系？(拓扑排序 有向无环图)</a></li><li><a href="#146_DijkstraA_2978" rel="nofollow">14.6、最短路径算法 (Dijkstra/A*)</a></li><li><a href="#147A_3085" rel="nofollow">14.7、A*搜索算法(实现游戏中的寻路功能)</a></li></ul> 
    </li><li><a href="#15bitmap_3165" rel="nofollow">15、位图(bitmap)与推荐算法</a></li><li><ul><li><a href="#151javautilBitSet_False_positive_3196" rel="nofollow">15.1、什么是布隆过滤器，其实现原理是？（java.util的BitSet类，实现类位图） False positive指的是？（蚂蚁问到）</a></li><li><a href="#152_3214" rel="nofollow">15.2、概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？</a></li><li><a href="#153_3227" rel="nofollow">15.3、推荐系统</a></li></ul> 
    </li><li><a href="#16_3245" rel="nofollow">16、断点续传思路和算法</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1_5"></a>1、什么是数据结构？(研究应用程序中数据之间逻辑关系、存储方式及其操作的学问就是数据结构)</h4> 
<ul><li>程序中数据大致有四种基本逻辑结构：集合(同属一个集合)/线性关系(一对一)/树形结构(一对多)/图状结构或网状结构(多对多)</li><li>物理存储结构：顺序存储结构/非顺序结构(链式存储/散列结构)</li><li><strong>算法的设计取决于逻辑结构；算法的实现依赖于存储结构</strong></li></ul> 
<hr> 
<h4><a id="2_12"></a>2、为什么学习数据结构和算法？</h4> 
<p><strong>有3点比较重要</strong> (王争)</p> 
<ul><li>1、直接好处是能够有写出性能更优的代码；<mark>数据结构：存储；算法：计算</mark>； 
  <ul><li>算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算。</li></ul> </li><li>2、算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面；</li><li>3、长期来看，<strong>大脑思考能力是个人最重要的核心竞争力</strong>，而算法是为数不多的能够有效训练大脑思考能力的途径之一。</li></ul> 
<p><strong>推荐的书籍及教程</strong><br> 《大话数据结构 程杰》入门<br> 《算法图解》<br> 《<strong>数据结构与算法分析：Java语言描述</strong>》(大学课本 伪代码)<br> 《<strong>剑指offer</strong>》 使用的C++语言来实现的，现在我不怎么使用了<br> 《<strong>程序员代码面试指南:IT名企算法与数据结构题目最优解</strong>》左程云，现在正在看的书<br> 《编程珠玑》(对大数据量处理的算法)<br> 《编程之美》(超级难)<br> 《算法导论》(很厚很无聊)<br> 《算法第四版》(推荐 本书没有动态规划)<br> 《<strong>数据结构与算法 极客时间</strong>》 王争google<br> 《算法帝国》<br> 《数学之美》<br> 《算法之美》(闲暇阅读) https://github.com/wangzheng0822/algo<br> 《计算机程序设计艺术》<strong>面试必刷的宝典</strong><br> 《图解Java数据结构》韩顺平<br> 《数据结构与算法之美》王争</p> 
<p><strong>倘若是在日常开发中，算法的基本逻辑，优缺点、适用场景是更为重要的。</strong></p> 
<blockquote> 
 <p>如果是<mark>考察技术基础</mark>，考核的范围应该是<strong>算法的基本逻辑，优缺点、适用场景</strong>，<mark>因为这些技术点在后续具体应用中选择合适的算法来解决问题的时候很有用</mark>；如果是考察<strong>思维能力</strong>，考核的方式应该是给一个具体的<mark>算法应用题</mark>，来看看<strong>面试者的分析和思考过程</strong>，例如一道业务上曾经用到的“如何快速计算你好友的好友和你的共同好友数”。</p> 
</blockquote> 
<hr> 
<h4><a id="3_41"></a>3、有哪些常见的数据结构？</h4> 
<table><thead><tr><th>概念</th><th>简介</th></tr></thead><tbody><tr><td>数据结构</td><td><strong>数组</strong>、<strong>链表</strong>(单链表/双向链表/循环链表/双向循环/静态链表)、<strong>栈</strong>(顺序栈/链式栈)、<strong>队列</strong>(双端队列/阻塞队列在线程池中大量使用/并发队列/并发阻塞队列)、<strong>散列表</strong>(散列函数/冲突解决(链表法/开放寻址)/二分快速定位元素/动态扩容/位图)、<strong>二叉树</strong>(平衡二叉树/二叉查找树/mysql底层)、<strong>树</strong>(b树/B+树/2-3树/2-3-4树)、<strong>堆</strong>(大顶堆/小顶堆/优先级队列/大数据量求topK)、<strong>图</strong>(图的存储(邻接矩阵/邻接表)/拓扑排序/最短路径/最小生成树/二分图)、<strong>跳表</strong>(链表可以快速二分查找元素)、<strong>Trie树</strong>(用于字符串补全/ES底层搜索的字符串匹配)</td></tr><tr><td>算法</td><td>递归、<strong>排序</strong>(O(n2)冒泡/选择/插入/希尔 O(lgn)归并/快排/堆排 O(n)计数/基数/桶)、二<strong>分查找</strong>(线性表/树结构/散列表)、<strong>搜索</strong>(深度优先/广度优先/A<em>启发式)、哈希算法、<strong>字符串匹配算法</strong>(朴素/KMP/Robin-Karp/Boyer-Moore/AC自动机/Trie树/后缀数组)、 <strong>复杂度分析</strong>(空间复杂度/时间复杂度(最好/最差/平均/均摊))、<strong>基本算法思想</strong>(贪心算法、分治算法、回溯算法、动态规划</em>) 、其他(数论/计算几何/概率分布/并查集/拓扑网络/矩阵计算/线性规划)</td></tr><tr><td>面试题</td><td><strong>链表</strong>：单链表反转(把指针转向)，链表中环的检测(遍历+数组保存遍历过的元素/双指针,前指针走两步,后指针走一步)，两个有序的链表合并(双重遍历)，删除链表倒数第n个结点(双指针,前指针比后指针先走n步)，求链表的中间结点(双指针,前指针走两步,后指针走一步)等、<strong>栈</strong>：在函数调用中的应用，在表达式求值中的应用，在括号匹配中的应用(网页爬虫中&lt; html&gt;&lt; script&gt;的排除)、<strong>排序</strong>：如何在O(n)的时间复杂度内查找一个无序数组中的第 K大元素(基数排序)</td></tr></tbody></table> 
<p><strong>由于日常开发使用java居多，因此使用JDK提供的Java版各类数据结构更加符合实际需求</strong>。</p> 
<table><thead><tr><th>概念</th><th>Java版接口</th><th>Java版抽象类</th><th>Java版实现类</th></tr></thead><tbody><tr><td>数组</td><td>Iterable</td><td>AbstractList</td><td>AbstractSequentialList ， ArrayList ， Vector，CopyOnWriteArrayList ，LinkedList，RoleList，RoleUnresolvedList</td></tr><tr><td>队列</td><td>Iterable</td><td>AbstractQueue</td><td>ConcurrentLinkedDeque ， ConcurrentLinkedQueue ，DelayQueue，LinkedBlockingDeque，LinkedBlockingQueue，LinkedTransferQueue，PriorityBlockingQueue，PriorityQueue，SynchronousQueue</td></tr><tr><td>集合</td><td>Iterable</td><td></td><td>ConcurrentSkipListSet ，CopyOnWriteArraySet，EnumSet，HashSet，LinkedHashSet，TreeSet</td></tr><tr><td>栈</td><td></td><td>AbstractCollection</td><td>stack</td></tr></tbody></table> 
<hr> 
<h4><a id="4java_59"></a>4、说一下几种常见的排序算法和分别的复杂度，java提供的默认排序算法(数组排序)</h4> 
<h5><a id="41_60"></a>4.1、排序算法</h5> 
<p><strong>排序算法指标</strong></p> 
<table><thead><tr><th>排序方法</th><th>时间复杂度(表示的是一个算法执行效率与数据规模增长的变化趋势)</th><th>最好最差情况</th><th>稳定性</th><th>最小辅助空间(表示算法的存储空间与数据规模之间的增长关系)</th></tr></thead><tbody><tr><td>选择排序</td><td>n^2</td><td>-</td><td>不稳定</td><td>空间O(1)</td></tr></tbody></table> 
<ul><li><strong>选择排序</strong>(原理：将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中)</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp<span class="token punctuation">,</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//第一个数据给temp a[i]为已排序区间的末尾</span>
		flag <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				temp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 值</span>
				flag <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 位置</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 最小数据与第一个数据进行交换</span>
			a<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>插入排序</strong> n^2 空间O(1) 稳定(每次将一个待排序的元素，按其关键字的大小插入到前面已经排好序的子文件的适当位置) 经常使用</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 寻找插入的位置</span>
			<span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//依次后移</span>
					j<span class="token operator">--</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment">//插入合适的位置</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>冒泡</strong> n^2 稳定(相邻两元素进行比较，如有需要则进行交换)(两个for循环 一轮比较9次，二轮比较8次)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 冒泡排序 <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 冒泡排序，a表示数组，n表示数组大小</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">// 提前退出冒泡循环的标志位</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 交换</span>
					<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
					a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
					a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
					flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 表示有数据交换</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 没有数据交换，提前退出</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>希尔</strong> nlgn~n^2 (将整个待排元素序列分割成若干个子序列，分别进行直接插入排序，待整个序列的元素基本有序，在对全体元素进行一次直接插入排序)</li><li><strong>快排</strong> nlgn 空间复杂度O(lgn) 不稳定 基于分割交换排序的原则，这种类型的算法占用空间较小，他将待排序列表分成三个主要部分：小于基准的元素，基准元素，大于基准的元素 
  <ul><li>(思想：通过一次划分：将待排元素分为左右两个子序列，左侧均小于基准元素排序码，右侧均大于等于基准元素排序码，反复递归，直至每一个序列只有一个元素为止)</li><li>快排的优化方法，在选择基准元素时，可以(1、三数取中法(首/尾/中间各取一个数据作为分区点，取中间数作为分区点) 2、随机法)</li></ul> </li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> index<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&gt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">;</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> high<span class="token punctuation">;</span>
	<span class="token comment">//基准点</span>
	index <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//由小到大排列   好吧，通过代码知道了扫描的顺序，从右开始向左扫描，若是交换了元素，从左往右扫描，然后依次进行</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			j<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//从右向左扫描</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//说明上述array[j]&lt;index,while循环跳出，该值放置在基准左侧</span>
			array<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//从左向右扫描</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//说明上述array[i]&gt;index,while循环跳出，该值放置在基准右侧</span>
			array<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//最后把基准元素放上去</span>
	array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">;</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>编程题</strong>：用快排思想在O(n)内查找第K大元素？比如，4，2，5，12，3 这样一组数据，第3大元素就是4。</p> 
<blockquote> 
 <p>思路：选择数组区间A[0…n-1]的最后一个元素A[n-1]作为pivot，对数组A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]，如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1, 说明第K大元素出现在A[p+1…n-1]区间，我们再按照上面的思路递归地在A[p+1…n-1]这个区间内查找</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 查找无序数组的第<span class="token class-name">K</span>大的数 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> partition <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//经过一轮分区</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>partition <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">!=</span> k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>partition <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//说明第K大元素出现在A[p+1…n-1]区间</span>
				partition <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partition <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span><span class="token comment">//说明第K大元素出现在A[1…p-1]区间</span>
				partition <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> partition <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> arr<span class="token punctuation">[</span>partition<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//一次成功</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> p<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 这里要是 &lt;= ，不然会出现死循环，比如查找数组 [1,1,2] 的第二小的元素   这操作真的秀</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//放基准元素左侧</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
				i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(n)</span>
</code></pre> 
<blockquote> 
 <p><mark>补充</mark>：倘若是现在开发“查找第K大元素” 这个需求，我会将这批数据放进List集合里面，然后使用Collections.sort()方法按大小排序好，然后get第K个元素。</p> 
</blockquote> 
<ul><li><strong>堆排</strong> nlgn 不稳定<br> 可以看做是选择排序的改进，基于比较的排序算法，他将其输入划分为未排序和排序的区域，通过不断消除最小元素并将其移动到排序区域来收缩未排序区域。</li><li><strong>归并</strong> nlgn 稳定 jdK1.7之前集合工具包默认使用的排序算法 <mark>1.7使用的是TimSort排序方法，还没有研究过</mark> （可分为二路归并/多路归并）<br> 使用分治思想，将复杂问题分解为较小的子问题，直到分解的足够小，可以轻松解决问题为止。（将两个有序表合并成一个有序表） 由大到小排列</li></ul> 
<pre><code class="prism language-java"><span class="token comment">//使用分治的思想</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token class-name">MergeSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">MergeSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Merge</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//Merge的作用：将已经有序的A[p…q]和A[q+1…r]合并成一个有序的数组，并且放入A[p…r]。</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>
	n1 <span class="token operator">=</span> q <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	n2 <span class="token operator">=</span> r <span class="token operator">-</span> q<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">L</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">R</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> p<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token class-name">L</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token class-name">R</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//相当于合并两条有序的链表  由大到小排列</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">L</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token class-name">R</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">L</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			j<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">L</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> j<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p><strong>基数排序</strong> O(n) 空间复杂度O(rd) 稳定(基数排序必须依赖于另外的排序方法 实质是多关键字排序)<br> 是通过比较数字将其分配到不同的“桶里”来排序元素的。他是线性排序算法之一。<br> 解决方案：1、最高位优先法MSD 2、最低位优先法LSD</p> </li><li> <p><strong>桶排序</strong> O(n) 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序<br> 适用场景：外部排序中(磁盘中，内存有限，无法将数据全部加载到内存中)</p> </li><li> <p><strong>计数排序</strong>(桶排序的一种特殊形式：每个桶中的数据相同)</p> </li><li> <p><strong>排序方法的选择？</strong> n代表数据量<br> 1、n较小，可以采用直接插入或直接选择排序<br> 2、若文件初始状态基本有序，应选用直接插入、冒泡或随机的快速排序<br> 3、n较大，采用复杂度为O(nlgn)的方法：快排/堆排/归并<br> 4、在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法？<br> 从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。</p> </li><li> <p><strong>利用快排思想实现在O(n)内查找第K大的元素？</strong></p> </li></ul> 
<blockquote> 
 <p><mark>快排核心思想就是分治和分区</mark>，选择数组区间A[0…n-1]的最后一个元素A[n-1]作为pivot(基准元素)，对数组A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1, 说明第K大元素出现在A[p+1…n-1]区间，我们再按照上面的思路递归地在A[p+1…n-1]这个区间内查找。同理，如果K&lt;p+1，那我们就在A[0…p-1]区间查找</p> 
</blockquote> 
<blockquote> 
 <p><strong>为什么这个算法的时间复杂度为O(n)？</strong> <br> 第一次分区查找，我们需要对大小为n的数组执行分区操作，需要遍历n个元素。第二次分区查找，我们只需要对大小为n/2的数组执行分区操作，需要遍历n/2个元素。<br> 依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为1。如果把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于2n-1。所以，上述解决思路的时间复杂度就为O(n)。</p> 
</blockquote> 
<blockquote> 
 <p><strong>如果数据存储在链表中，这三种排序算法还能工作吗？</strong><br> 一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；<br> 插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；<br> 选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。</p> 
</blockquote> 
<h5><a id="42ArraysJavaC_287"></a>4.2、排序工具类Arrays？如何实现一个通用的、高性能的排序函数？(Java语言采用<mark>堆排序</mark>实现排序函数，C语言使用快速排序实现排序函数)</h5> 
<ul><li>Arrays拥有一组static方法(equals():比较两个array是否相等/fill():将值填入array中/sort():用来对array进行排序/binarySearch():在排好序的array中寻找元素/system.arraycopy():array的复制)</li><li>Jdk7中Arrays.sort()和Collections.sort()排序方法使用注意: <strong>jdk1.6中的arrays.sort（）和 collections.sort（）使用的是MergeSort； jdk1.7中内部实现转换成了TimSort方法，</strong></li><li>对对象间比较的实现<br> 1、有两个参数，第一个是比较的数据，第二个是比较的规则，如果comparator为空，则使用comparableTimSort的sort实现<br> 2、传入的待排序数组若小于MIN_MERGE（Java实现中为32）则从数组开始处找到一组连接升序或严格降序（找到后翻转）的数<br> BinarySort：使用二分查找的方法将后续的数插入之前的已排序数组<br> 3、开始真正的TimSort过程（选取minRun大小，之后待排序数组将被分成以minRun大小为区块的一块块子数组）<br> Timsort的思想：<strong>找到已经排好序的数据子序列，然后对剩余部分排序，最后合并起来</strong></li><li><strong>java提供的默认排序算法</strong><br> 1、对于基础数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序；<br> 2、而对于对象数据类型，目前则是使用TimSort，思想上也是一种归并(Merge)和二分插入排序（binary Sort）结合的优化排序算法。<br> 思路是查找数据集中已经排好序的分区（这里叫run 连续升或降的序列），然后合并这些分区来达到排序的目的。</li></ul> 
<ul><li>Java8引入了<strong>并行排序算法</strong>(直接使用parallelSort方法)，这是为了充分利用现代多核处理器的计算能力，<strong>底层实现基于fork-join框架</strong>,当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是,当数据集增长到数万或百万以上时,提高就非常大了，具体还是取决于处理器和系统环境.</li><li><strong>fork-join框架的适用场景</strong>：计算密集型，而非IO密集型，踩过坑</li></ul> 
<hr> 
<h5><a id="43_303"></a>4.3、常见的查找算法？</h5> 
<ul><li>1、二分查找法(<strong>考虑好边界条件，不要被面试官抓住漏洞</strong>)(使用Arrays工具类的binarySearch方法)<br> <strong>思路</strong>：先确定数组的中间位置，然后将要查询的值与数组中间位置的值进行比较，若小于数组中间值，则要查找的值应位于该中间值之前，依次类推；<br> <strong>算法</strong>： 1、如果关键字小于中央元素，只需继续在数组的前半部分进行搜索；2、如果关键字与中央元素相等，则搜索结束，找到匹配元素；3、如果关键字大于中央元素，只需继续在数组的后半部分进行搜索<br> <strong>限制</strong>：用于顺序链表或排序后的链表<br> <strong>注意事项</strong>：1、循环退出条件low&lt;=high;2、mid的取值(low+(high-low)&gt;&gt;1)因为相比除法运算来说，计算机处理位运算要快得多;3、low和high的更新low=mid+1,high=mid-1<br> <strong>时间复杂度</strong>：O(lgn)</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//或者int mid = low+((high-low)&gt;&gt;1)；</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>2、<strong>4种常见的二分查找变形问题</strong><br> 第一种：查找第一个值等于给定值的元素</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> 
				<span class="token keyword">return</span> mid<span class="token punctuation">;</span>  <span class="token comment">//mid不是第一个数或mid左边的数不是</span>
			<span class="token keyword">else</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>第二种：查找最后一个值等于给定值的元素</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
			<span class="token keyword">else</span>
				low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>第三种：查找第一个大于等于给定值的元素</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
			<span class="token keyword">else</span>
				high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>第四种：查找最后一个小于等于给定值的元素</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch7</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
			<span class="token keyword">else</span>
				low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>3、如果有序数组是一个循环有序数组，比如4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>
			<span class="token keyword">return</span> left<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>
			<span class="token keyword">return</span> right<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 第一种情况</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">//在mid到左侧最大值区间</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//target小于中间值</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//在右侧区间</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 第二种情况   mid小于最左值</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//两种情况：1、在mid右侧  2、在左侧</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//1、在mid右侧 </span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//2、在左侧</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//在右侧的左边区域</span>
				right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>4、x的平方根 LeetCode69 实现int sqrt(int x)函数。计算并返回x的平方根，其中x是非负整数,由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去</li></ul> 
<ul><li>方法1：java自带API</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>方法2：二分搜索</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//注：在中间过程计算平方的时候可能出现溢出，所以用long long。</span>
	<span class="token keyword">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> j<span class="token operator">=</span>x<span class="token operator">/</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//对于一个非负数n，它的平方根不会大于（n/2+1）</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>j<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">long</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
	    <span class="token keyword">long</span> res<span class="token operator">=</span>mid<span class="token operator">*</span>mid<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token operator">==</span>x<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token operator">&lt;</span>x<span class="token punctuation">)</span> i<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> j<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>方法3：牛顿迭代法 求c的算术平方根就是求f(x)=x^2-c的正根 迭代公式：xn+1=1/2(xn+c/xn)</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> last<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> res<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token operator">!=</span>last<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		last<span class="token operator">=</span>res<span class="token punctuation">;</span>
		res<span class="token operator">=</span><span class="token punctuation">(</span>res<span class="token operator">+</span>x<span class="token operator">/</span>res<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token keyword">int</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h5><a id="44_495"></a>4.4、复杂度分析</h5> 
<p><strong>常见的时间复杂度？</strong>（<strong>表示的是一个算法执行效率与数据规模增长的变化趋势</strong>）</p> 
<table><thead><tr><th>时间复杂度</th><th>概念</th></tr></thead><tbody><tr><td>1. O(1) 常数阶</td><td>常量级别的时间复杂度：只要代码的执行时间不随n的增大而增长，这样代码的时间复杂度我们都记作O(1)。</td></tr><tr><td>2、O(logn)对数阶、O(nlogn)线性对数阶</td><td>代码循环执行的次数呈现对数关系</td></tr><tr><td>3、O(m+n)、O(m*n)</td><td>代码的复杂度由两个数据的规模来决定</td></tr></tbody></table> 
<p><strong>空间复杂度</strong>：(<strong>表示算法的存储空间与数据规模之间的增长关系</strong>)<br> 常见的空间复杂度就是O(1)、O(n)、O(n2)</p> 
<ul><li><strong>平均时间复杂度</strong>(加权平均时间复杂度)：加了概率</li><li><strong>均摊时间复杂度</strong>：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。</li><li><strong>算法的最好情况和最坏情况？</strong><br> 最好情况：算法执行最佳的数据排列。如：二分搜索时，目标值正好位于搜索的数据中心，时间复杂度为0；<br> 最差情况：给定算法的最差输入。如：快速排序中，如果选择的关键值是列表中最大或最小值，最差情况就会发生，时间复杂度会变成O(n^2)</li></ul> 
<hr> 
<h5><a id="45_513"></a>4.5、如何高效地判断无序数组中是否包含某特定值？</h5> 
<pre><code class="prism language-java"><span class="token comment">// 方法1：使用list  (**最常使用**)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">useList</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token class-name">String</span> targetValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>targetValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
		
<span class="token comment">// 方法2：使用Set  低效</span>
<span class="token operator">&gt;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">useSet</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token class-name">String</span> targetValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>targetValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方法3：使用一个简单循环  最高效</span>
<span class="token operator">&gt;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">useLoop</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token class-name">String</span> targetValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>targetValue<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>方法4：Arrays.binarySearch()方法：数组必须是有序的(有序数组时，使用列表或树可达到O(lgn),使用hashset可达到O(1))</li></ul> 
<hr> 
<h5><a id="46_539"></a>4.6、查找算法实战？</h5> 
<ul><li> <p>1、我们要给电商交易系统中的“订单”排序。订单有两个属性(下单时间，订单金额) 需求是按金额从小到大对订单数据排序。对金额相等的订单，按下单时间从早到晚排序<br> <strong>稳定性概念</strong>：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变<br> <strong>思路</strong>：先按下单时间给订单排序，排完序之后，使用稳定排序算法，按订单金额重新排序(稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变)</p> </li><li> <p>2、O(n)时间复杂度内求无序数组中的第K大元素？(利用分区的思想) 代码放在eclipse中<br> 我们选择数组区间A[0…n-1]的最后一个元素A[n-1]作为pivot，对数组A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。<br> 如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1, 说明第K大元素出现在A[p+1…n-1]区间，我们再按照上面的思路递归地在A[p+1…n-1]这个区间内查找。同理，如果K&lt;p+1，那我们就在A[0…p-1]区间查找。</p> </li><li> <p>3、现在你有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，你有什么好的解决思路<br> <strong>answer</strong>：先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O(n)，空间复杂度是O（1）,几乎不占用内存。</p> </li></ul> 
<h5><a id="47___551"></a>4.7、哪些数据结构有序？ 纳尼，好奇怪的问题</h5> 
<h4><a id="5_553"></a>5、数组部分面试题</h4> 
<p>定义：是多个相同类型数据按一定顺序排列的集合，bi</p> 
<ul><li>1、实现一个支持动态扩容的数组</li><li>2、实现一个大小固定的有序数组，支持动态增删改操作 实际开发中我们使用ArrayList，更高效</li><li>3、实现两个有序数组合并为一个有序数组</li><li>4、数组操作常见问题(数组脚标越界异常(ArrayIndexOutOfBoundsException)/空指针异常(NullPointerException))</li><li><strong>leetcode15:三数求和</strong><br> 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组<br> <strong>思路</strong>：首先对数据进行排序，然后确定第一个数，使用for循环，后两个数使用两指针，依次尝试，如果值大于0-num[i],右指针左移；如果值小于0-num[i],左指针右移。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//由小到大</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> ls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// 跳过可能重复的答案</span>
 
				<span class="token keyword">int</span> l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						ls<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>
						<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>
						l<span class="token operator">++</span><span class="token punctuation">;</span>
						r<span class="token operator">--</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">// 跳过重复值</span>
						l<span class="token operator">++</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
						<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>
						r<span class="token operator">--</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> ls<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度是O(n^2)</span>
</code></pre> 
<ul><li>leetcode169:求众数 给定一个大小为n的数组，找到其中的众数。众数是指在数组中出现次数大于?n/2?的元素<br> 先决条件：给定的数组总是存在众数<br> <strong>思路</strong>：1、利用摩尔投票法 2、利用java的api</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> maj <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>maj <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			count<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			count<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//说明maj所代表的数不能超过一半</span>
				maj <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(n)</span>
	<span class="token keyword">return</span> maj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>第二种解法：使用java的api，排序</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//时间复杂度O(nlgn)</span>
	<span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>LeetCode41：求缺失的第一个正数</strong><br> 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//先排序，然后分两种情况 ：有1  和  没有1 （负数略过）</span>
		<span class="token comment">//1.没有1，则输出1</span>
		<span class="token comment">//2.有1 则判断下一个数和前一个数是否相等、差1或者差好几个数，相等继续，差1继续，否则退出</span>
		<span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> i<span class="token punctuation">;</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment">//负数略过</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
				flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>nums<span class="token punctuation">.</span>length <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token boolean">true</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(n)</span>
</code></pre> 
<p>Demo 五子棋程序中，有存盘退出和续上盘的功能，因为该二维数组中的很多值默认为0，因此记录了很多没有意义的数据 --》稀疏</p> 
<hr> 
<h4><a id="6_656"></a>6、链表部分面试题</h4> 
<h5><a id="61next_NULL_657"></a>6.1、单链表：next指针 (尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点)</h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token class-name">ListNode</span> next<span class="token punctuation">;</span>
	<span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		val <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>循环链表</strong>：循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表(比如著名的约瑟夫问题)</p> 
<pre><code class="prism language-java"><span class="token class-name">ListNode</span> p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//在单链表的基础之上，链尾指向链头</span>
q <span class="token operator">=</span>p<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token punctuation">.</span><span class="token function">setVal</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
p<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构建循环链表</span>
</code></pre> 
<p>在遍历循环链表时得特别小心，否则将会无限地遍历链表，因为循环链表每一个结点都有一个后继结点<br> <strong>双向链表</strong>：(需要额外的两个空间来存储后继结点next和前驱结点的地址prev)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> value<span class="token punctuation">;</span>
	<span class="token class-name">ListNode</span> prev<span class="token punctuation">;</span>
	<span class="token class-name">ListNode</span> next<span class="token punctuation">;</span>
	<span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> val<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>使用技巧：</strong><br> 1、理解指针或引用的含义：是存储所指对象的内存地址(将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针)<br> 2、警惕指针丢失和内存泄漏 java不需考虑(使用jvm自动管理内存)<br> 3、利用哨兵简化实现难度：如果我们引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点(插入排序、归并排序、动态规划)<br> 删除最后一个结点和删除其他节点,插入第一个结点和插入其他节点可以统一为相同的代码逻辑。<br> <strong>哨兵的好处</strong>：它可以减少特殊情况的判断，比如判空，判越界，因为空可越界可认为是小概率情况，如实每次执行代码都走一遍，大多数情况下是多于的。<br> 比如给一个哨兵节点，以及将key赋值给末尾元素，让数组遍历不用判断越界也可以因为相等停下来。<br> 4、重点留意便捷条件处理：(如果链表为空时，代码是否能正常工作？如果链表只包含一个结点时，代码是否能正常工作？代码逻辑在处理头结点和尾结点的时候，是否能正常工作？)<br> 5、举例画图，辅助思考：(举例法和画图法)</p> 
<hr> 
<h5><a id="62_701"></a>6.2、描述一下链式存储结构</h5> 
<ul><li>可以用任意一组存储单元来存储单链表中的数据结构（可以不连续），存储每个元素的值a，还必须存储后集结点的信息，这两个信息组成结点。</li></ul> 
<hr> 
<h5><a id="63LinkedList_705"></a>6.3、倒排一个LinkedList（即链表的反转）</h5> 
<p>开发中使用集合工具包，Collecionts.reverse(List&lt;?&gt; list)<br> <strong>原理</strong>：i m n相邻，调整指针的指向，调整m的指向，指向结点i，链表会断开，需要在调整之前把n保存起来 代码P236</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 链表反转 <span class="token punctuation">{<!-- --></span>
<span class="token comment">//单链表的反转 调整指针的指向，在调整next指针之前，需要保存前一个值 反转后链表的头结点为原始链表的尾节点，即next为空指针的节点</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseIteratively</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Node</span> pReversedHead <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> pNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> pPrev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Node</span> pNext <span class="token operator">=</span> pNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>pNext <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				pReversedHead <span class="token operator">=</span> pNode<span class="token punctuation">;</span><span class="token comment">//pNode此时为最后一个结点 反转后链表的头结点为原始链表的尾节点</span>
			<span class="token punctuation">}</span>
			pNode<span class="token punctuation">.</span>next <span class="token operator">=</span> pPrev<span class="token punctuation">;</span>
			pPrev <span class="token operator">=</span> pNode<span class="token punctuation">;</span>
			pNode <span class="token operator">=</span> pNext<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		head <span class="token operator">=</span> pReversedHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>		
</code></pre> 
<hr> 
<h5><a id="64___LeetCode141_729"></a>6.4、判断一个单链表中是否有环？ 阿里 LeetCode141</h5> 
<ul><li><strong>思路1：蛮力法</strong><br> 若链表中出现多个结点的后继指针重复，就表明存在环。从第一个结点开始，令其为当前节点，然后看看链表中其他节点的后继指针是否指向当前结点，如果存在，说明链表中存在环。<br> <strong>缺点</strong>：如果不能确定链表的表尾，算法将会出现死循环。</li></ul> 
<p>*<strong>思路2</strong>：使用散列表(时间复杂度O(n)，空间复杂度O(n))<br> 从表头节点开始，逐一遍历链表中的每个结点；<br> 对于每个结点，检查该结点的地址是否存在于散列表中；<br> 如果存在，则表明当前访问的结点已经被访问过，出现此情况的原因是给定的链表中存在环；<br> 如果散列表中没有当前节点的地址，那么把该地址插入散列表中；<br> 重复上述过程，直至到达表尾或找到环。</p> 
<ul><li><strong>思路3</strong>：如果一个单链表中有环，用一个指针去遍历，永远不会结束，所以可以用两个指针，一个指针一次走一步，另一个指针一次走两步，如果存在环，则这两个指针会在环内相遇，时间复杂度为O(n) indeed（无论环的个数是奇数还是偶）被称为Floyd算法</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token keyword">boolean</span> <span class="token function">checkCircle</span><span class="token punctuation">(</span><span class="token class-name">Node</span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">Node</span> fast <span class="token operator">=</span> list<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
	<span class="token class-name">Node</span> slow <span class="token operator">=</span> list<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span>fast<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>        
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(n) 空间复杂度O(1)</span>
</code></pre> 
<p><strong>对floyd算法的补充</strong>：如果两个指针每次分别移动2个结点和3个结点，而不是移动一个和2个结点，算法仍然有效吗？<br> 可以，算法的复杂度可能增加</p> 
<hr> 
<h5><a id="65NULL_762"></a>6.5、判定给定的链表是否已NULL结束，如果链表中存在环，返回环的长度？</h5> 
<p>思路：在找到链表中的环后，保持slowPtr指针不变，fastPtr指针则继续移动，每次移动fastPtr指针时，计数器变量加1，直至再一次回到slowPtr指针所在的位置，即为环的长度。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 检测环的长度 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token class-name">FindLoopLength</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token class-name">ListNode</span> slowPtr <span class="token operator">=</span>head<span class="token punctuation">,</span>fastPtr <span class="token operator">=</span>head<span class="token punctuation">;</span>
		<span class="token keyword">boolean</span> loopExists <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>fastPtr<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fastPtr<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			slowPtr <span class="token operator">=</span> slowPtr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			fastPtr <span class="token operator">=</span> fastPtr<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>slowPtr <span class="token operator">==</span> fastPtr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				loopExists <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>loopExists<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			fastPtr <span class="token operator">=</span>fastPtr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>slowPtr <span class="token operator">!=</span> fastPtr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				fastPtr <span class="token operator">=</span>fastPtr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
				counter<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> counter<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//链表中不存在环</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>	<span class="token comment">//时间复杂度O(n)</span>
</code></pre> 
<p>补充：此思路可以引申为 求循环小数的开始位置(小数点之后的位数)和循环长度</p> 
<hr> 
<h5><a id="66_____796"></a>6.6、快慢指针能解决的问题？ 阿里</h5> 
<ul><li>1、已知单链表的头指针，查找到倒数第K个节点，然后删除这个节点<br> <strong>思路1：快慢指针法：</strong><br> 我们定义一个快指针P和慢指针Q,先让P指针走到K个节点位置，然后Q指针从头指针开始和P一起移动，当P移动到尾部的时候，那么此时Q节点所在的位置就是倒数第K个节点</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">deleteLastKth</span><span class="token punctuation">(</span><span class="token class-name">Node</span> list<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Node</span> fast <span class="token operator">=</span>list<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> i<span class="token operator">&lt;</span>k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fast <span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token operator">++</span>i<span class="token punctuation">;</span><span class="token comment">//第一个指针先走k步</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> list<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">Node</span> slow <span class="token operator">=</span>list<span class="token punctuation">;</span>
	<span class="token class-name">Node</span> prev <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		prev <span class="token operator">=</span>slow<span class="token punctuation">;</span>  <span class="token comment">//prev为倒数第k个数</span>
		slow <span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		list <span class="token operator">=</span> list<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		prev<span class="token punctuation">.</span>next <span class="token operator">=</span>prev<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(n)</span>
</code></pre> 
<p><strong>思路2：蛮力法(时间复杂度最高)</strong><br> 从链表的第一个结点开始，统计当前节点后面的结点个数。如果后面的节点个数小于k-1，算法结束；如果大于k-1，则移动到下一个结点，重复该过程<br> <strong>思路3：散列表O(m) 为了减少链表遍历的次数</strong><br> 散列表的条目是&lt;结点的位置，结点地址&gt;，在遍历链表时，可以得到链表的长度，令M表示链表的长度，这样求链表的导师胡第n个结点的问题转变为求链表正数<br> 第M-n+1个结点。返回散列表中主键为M-n+1的值即可。时间复杂度O(m)，空间复杂度O(m)：创建一个大小为M的散列表。</p> 
<ul><li>2、已知单链表的头结点，查找到链表的中间节点(只允许扫描一次)<br> 一个快指针P和慢指针Q,P和Q同时从头指针出发，快指针P每次移动两步，慢指针每次移动一步，当快指针P到尾部的时候，慢指针Q所在的位置就是中间节点的位置</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 找到链表的中间节结点 <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">ListNode</span> <span class="token class-name">FindMiddle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">ListNode</span> ptr1x<span class="token punctuation">,</span> ptr2x<span class="token punctuation">;</span>
		ptr1x <span class="token operator">=</span> ptr2x <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">//不断循环，直至第一个指针到达表尾</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>ptr1x<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				ptr1x <span class="token operator">=</span>ptr1x<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只移动第一个指针</span>
				i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				ptr1x <span class="token operator">=</span> ptr1x<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				ptr2x <span class="token operator">=</span> ptr2x<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>        
		<span class="token keyword">return</span> ptr2x<span class="token punctuation">;</span><span class="token comment">//返回ptr2x的值，即为中间结点</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(n)  空间复杂度O(1)</span>
</code></pre> 
<hr> 
<h5><a id="67_LeetCode23_k_856"></a>6.7、实现两个有序的链表合并为一个有序链表(双重遍历) LeetCode23 合并k个排序链表</h5> 
<p>思路：使用分治的思想，两两归并</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lists<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> lists<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> l1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mid<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			l1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> l2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span>lists<span class="token punctuation">.</span>length<span class="token operator">-</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid<span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lists<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			l2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token function">mergeKLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">mergeKLists</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
	<span class="token comment">//两个有序链表合并为一个新的有序链表  递归的方法</span>
	<span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> l1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> l1<span class="token punctuation">;</span>

		<span class="token class-name">ListNode</span> head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			head <span class="token operator">=</span> l1<span class="token punctuation">;</span>
			head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			head <span class="token operator">=</span> l2<span class="token punctuation">;</span>
			head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h5><a id="68_899"></a>6.8、在有序链表中插入一个结点</h5> 
<pre><code class="prism language-java">		<span class="token keyword">public</span> <span class="token keyword">class</span> 在有序链表中插入一个结点 <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">ListNode</span> <span class="token class-name">InsertSortedList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> newNode<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token class-name">ListNode</span> current <span class="token operator">=</span>head<span class="token punctuation">;</span>
				<span class="token class-name">ListNode</span> temp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">//遍历链表，直至找到比新节点中数据值更大的节点</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> newNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					temp <span class="token operator">=</span> current<span class="token punctuation">;</span><span class="token comment">//temp为current的上一个节点</span>
					current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">//current为比newNode值大的数</span>
				<span class="token punctuation">}</span>
				<span class="token comment">//在该结点前插入新节点</span>
				newNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
				temp<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
			<span class="token punctuation">}</span>   
		<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(n)</span>
</code></pre> 
<hr> 
<h5><a id="69list1list2nmnm_921"></a>6.9、求两个单向链表的合并点，合并后成为一个单向链表。假设链表list1和链表list2在相交前的节点数量分别为n和m，n/m大小不确定，求两个链表的合并点。</h5> 
<p><strong>方法1：蛮力法</strong><br> 把第一个链表中的每一个结点指针与第二个链表中的每一个结点指针比较，当结点相等时，即为相交结点。时间复杂度为O(mn)<br> <strong>方法2：散列表</strong><br> 选择结点较少的链表(若链表长度未知，那么随便选择一个链表)，将其所有结点的指针值保存在散列表中；遍历另一个链表，对于该链表中的每一个结点，检查散列表<br> 中是否已经保存了其结点指针。如果两个链表存在合并点，那么必定会在散列表中找到记录。时间复杂度O(m)+O(n)；空间复杂度O(m)或O(n)<br> <strong>方法3：两个栈</strong><br> 创建两个栈，然后遍历两个链表，分别把所有结点存入第一个和第二个栈，两个栈包含了对应链表的结点地址，比较两个栈的栈顶元素，如果相等，则弹出两个栈<br> 的栈顶元素并保存在临时变量中，继续上述操作，直至两个栈的栈顶元素不相等，此时即找到了两个链表的合并点。时间复杂度O(m+n),空间复杂度O(m+n)<br> <strong>方法4：时间复杂度超低的解法</strong><br> 获取两个链表L1/L2的长度，O(max(m,n))；计算两个长度的差d，从较长链表的表头开始，移动d步，然后两个链表同时移动，直至出现两个后继指针相等的情况。</p> 
<pre><code class="prism language-java">			<span class="token keyword">public</span> <span class="token keyword">class</span> 求两个链表的合并点 <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">ListNode</span> <span class="token class-name">FindIntersectingNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
					<span class="token keyword">int</span> L1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>L2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>diff<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//L1为第一个链表的长度，L2为第二个链表的长度，diff为两链表的差值</span>
					<span class="token class-name">ListNode</span> head1<span class="token operator">=</span>list1<span class="token punctuation">,</span>head2<span class="token operator">=</span>list2<span class="token punctuation">;</span>
					<span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						L1<span class="token operator">++</span><span class="token punctuation">;</span>
						head1 <span class="token operator">=</span> head1<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">while</span> <span class="token punctuation">(</span>head2 <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						L2<span class="token operator">++</span><span class="token punctuation">;</span>
						head2 <span class="token operator">=</span> head2<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>L1<span class="token operator">&lt;</span>L2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						head1 <span class="token operator">=</span> list2<span class="token punctuation">;</span>
						head2 <span class="token operator">=</span> list1<span class="token punctuation">;</span>
						diff <span class="token operator">=</span> L2<span class="token operator">-</span>L1<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">else</span>  <span class="token punctuation">{<!-- --></span>
						head1 <span class="token operator">=</span> list1<span class="token punctuation">;</span>
						head2 <span class="token operator">=</span> list2<span class="token punctuation">;</span>
						diff <span class="token operator">=</span> L1<span class="token operator">-</span>L2<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> diff<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						head1 <span class="token operator">=</span> head1<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> head2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token keyword">if</span> <span class="token punctuation">(</span>head1 <span class="token operator">==</span> head2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						   <span class="token keyword">return</span> head1<span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
						head1<span class="token operator">=</span> head1<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						head2 <span class="token operator">=</span> head2<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(max(m,n)) 空间复杂度O(1)</span>
</code></pre> 
<hr> 
<h5><a id="610_971"></a>6.10、如何判断一个字符串(链表)是否是回文字符串的问题(字符串是通过单链表来存储)(上海自来水来自海上)</h5> 
<p>1）前提：字符串以单个字符的形式存储在单链表中。<br> 2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。<br> 3）将链表中的字符倒序存储一份在另一个链表中。<br> 4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。<br> <strong>思路2</strong>：使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等<br> 时间复杂度O(n) 空间复杂度O(1)</p> 
<hr> 
<h5><a id="611O1_980"></a>6.11、O(1)时间内删除单链表中某一个节点</h5> 
<p>把后一个元素赋值给待删除节点，这样也就相当于是删除了当前元素<br> 1. 如果待删除节点不是最后一个节点，就用他的next节点的value覆盖它的value，然后删掉它的next节点<br> 2、如果是最后一个节点，顺序遍历o（n）</p> 
<hr> 
<h5><a id="6121234X2143X_986"></a>6.12、如何逐对逆置链表？初始1-&gt;2-&gt;3-&gt;4-&gt;X,逐对转置后，为2-&gt;1-&gt;4-&gt;3-&gt;X。</h5> 
<pre><code class="prism language-java"><span class="token comment">//递归版本</span>
<span class="token class-name">ListNode</span> <span class="token class-name">ReversePairRecursive</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token class-name">ListNode</span> temp<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> head<span class="token punctuation">;</span>  <span class="token comment">//当前链表为空或只有一个元素</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//逆置第一对</span>
		temp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		head<span class="token punctuation">.</span>next <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment">//第一个结点的下一个为第三个结点</span>
		temp<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//第一个结点变为第二个</span>
		head <span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token comment">//第二个结点变第一个</span>
		head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token class-name">ReversePairRecursive</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h5><a id="613NM_1005"></a>6.13、约瑟夫环(N个人想选出一个领头人，他们排成一个环，沿着环每数到第M个人就排除该人，并从下一个人开始重新数，求最后留在环中的人)</h5> 
<pre><code class="prism language-java">		<span class="token comment">/**
		 * @param N 人数
		 * @param M 需要排除的人序号
		 * @return 最后留下来的人
		 */</span>
		<span class="token class-name">ListNode</span> <span class="token class-name">GetJosephusPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">M</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token class-name">ListNode</span> p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>q<span class="token punctuation">;</span>
			<span class="token comment">//建立一个包含所有人的循环链表</span>
			p<span class="token punctuation">.</span><span class="token function">setVal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			q <span class="token operator">=</span>p<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				p<span class="token punctuation">.</span><span class="token function">setVal</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			p<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构建循环链表</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token class-name">N</span><span class="token punctuation">;</span> count <span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>count<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">M</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				p<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除选手</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token comment">//最后留下的勇者</span>
		<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="7__1031"></a>7、栈(一种特殊的线性表，只能固定在一端进行插入、删除操作 可分为顺序栈结构和链式栈结构)</h4> 
<h5><a id="71_1032"></a>7.1、栈的特性</h5> 
<p><strong>递归的本质 栈</strong><br> 1、递归是函数里调用自身<br> 2、必须有一个明确的递归出口<br> 3、在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出 <br> <strong>递归的基本思想：</strong><br> 1、是把规模较大的一个问题，分解成规模较小的多个子问题去解决<br> 2、先解决子问题，再基于子问题来解决当前问题<br> 递归和内存：每次递归调用都在内存中生成一个新的函数副本(仅仅是一些相关的变量)，一旦函数结束(即返回某些数据)，改返回函数的副本就从内存中删除。<br> <strong>递归一般用于解决三类问题：</strong><br> 1、数据的定义是按递归定义的。（Fibonacci函数，n的阶乘）<br> 2、问题解法按递归实现。（动态规划/分治/回溯）归并排序和快速排序用到了递归的思想<br> 3、数据的结构形式是按递归定义的。（二叉树的/先/中/后序遍历，图的深度/广度优先搜索）</p> 
<h5><a id="72___1046"></a>7.2、栈的使用场景 美团</h5> 
<ul><li><strong>子程序的调用</strong>：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中 
  <ul><li>JVM中的栈帧</li></ul> </li><li><strong>处理递归调用</strong>：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中</li><li><strong>表达式的转换和求值</strong></li><li><strong>二叉树的遍历</strong></li><li><strong>图的深度优先搜索</strong></li><li><strong>浏览器的前进、后退功能</strong></li><li>字符串反转</li></ul> 
<p>1、栈在表达式求值中的应用：(一个保存操作符的栈，另一个是保存运算符的栈)<br> 我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较(栈顶元素优先级高就取出运算符，从操作数栈取两个操作数，结果压入操作数栈)</p> 
<ul><li>LeetCode150 逆波兰表示式求值(后缀表达式)(逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的内存结构是栈式结构，它执行先进后出的顺序)</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">String</span> str <span class="token operator">=</span> tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">char</span> ch <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
				stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//如果是运算符</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
					<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> num2 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> num1 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">switch</span> <span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span>
					stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span>
					stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num1 <span class="token operator">-</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span>
					stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num1 <span class="token operator">*</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>
					stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num1 <span class="token operator">/</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
			stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>栈在括号匹配中的应用：(我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号)</p> 
<ul><li>LeetCode20：有效的括号 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串，判断字符串是否有效</li></ul> 
<pre><code class="prism language-java">		<span class="token keyword">public</span> <span class="token keyword">class</span> 有效的括号 <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> aChar <span class="token operator">:</span> chars<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>aChar<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSym</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> aChar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
						stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>aChar<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//括号是否能匹配成功</span>
			<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSym</span><span class="token punctuation">(</span><span class="token keyword">char</span> c1<span class="token punctuation">,</span> <span class="token keyword">char</span> c2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token punctuation">(</span>c1 <span class="token operator">==</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> c2 <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>c1 <span class="token operator">==</span> <span class="token string">'['</span> <span class="token operator">&amp;&amp;</span> c2 <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>c1 <span class="token operator">==</span> <span class="token string">'{'</span> <span class="token operator">&amp;&amp;</span> c2 <span class="token operator">==</span> <span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>变体1：给定一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度 例如：输入: "(()"输出: 2 输入: “)()())” 输出: 4<br> 对于这种括号匹配问题，一般都是使用栈，我们先找到所有可以匹配的索引号，然后找出最长连续数列！O(nlogn)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 最长有效括号 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//System.out.println(stack);</span>
		<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> 
				stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
					stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>思路2：动态规划</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//状态转移表   下标表示对应考察元素     返回值表示最长有效括弧</span>
	<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">?</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">?</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>编程题5：如何实现浏览器的前进、后退功能？</strong><br> 我们使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y.当我们点击前进按钮时，<br> 我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。<br> <strong>递归需要满足的三个条件</strong>：1、一个问题的解可以分解为几个问题的解；2、这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样；3、存在递归终止条件<br> 首先是定义ListNode，最基础的数据结构(包含int value，指向下一个结点点的指针)，然后有结点构成栈(包含pop/push/print/clear等功能)，最后实现浏览器功能()</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 用栈实现浏览器的前进后退 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">String</span> currentPage<span class="token punctuation">;</span>
	<span class="token comment">//使用两个栈，X和Y</span>
	<span class="token keyword">private</span> <span class="token class-name">LinkedListBasedStack</span> backStack<span class="token punctuation">;</span>			<span class="token comment">//LinkedListBasedStack为基于链表实现的栈，功能有入栈/出栈/获取栈顶元素/打印栈中元素</span>
	<span class="token keyword">private</span> <span class="token class-name">LinkedListBasedStack</span> forwardStack<span class="token punctuation">;</span>
	<span class="token comment">//构造函数</span>
	<span class="token keyword">public</span> 用栈实现浏览器的前进后退<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>backStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedListBasedStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个栈  打开新页面时入栈，页面前进时入栈  后退时出栈</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>forwardStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedListBasedStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二个栈  前进时出栈  后退时入栈</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token keyword">open</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPage <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>backStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//入栈 第一个栈</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>forwardStack<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">showUrl</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">"Open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canGoBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>backStack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canGoForward</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>forwardStack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//后退功能</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">goBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">canGoBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>forwardStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二个栈入栈</span>
			<span class="token class-name">String</span> backUrl <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>backStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个栈出栈</span>
			<span class="token function">showUrl</span><span class="token punctuation">(</span>backUrl<span class="token punctuation">,</span> <span class="token string">"Back"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> backUrl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"* Cannot go back, no pages behind."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//前进功能</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">goForward</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">canGoForward</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>backStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个栈入栈</span>
			<span class="token class-name">String</span> forwardUrl <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>forwardStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二个栈出栈</span>
			<span class="token function">showUrl</span><span class="token punctuation">(</span>forwardUrl<span class="token punctuation">,</span> <span class="token string">"Foward"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> forwardUrl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"** Cannot go forward, no pages ahead."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showUrl</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>currentPage <span class="token operator">=</span> url<span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>prefix <span class="token operator">+</span> <span class="token string">" page == "</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkCurrentPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current page is: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>currentPage<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编程题3：用数组实现一个顺序栈</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 用数组实现栈 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span> <span class="token comment">// 数组</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">// 栈中元素个数</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment">// 栈的大小</span>
	<span class="token comment">// 初始化数组，申请一个大小为n的数组空间</span>
	<span class="token keyword">public</span> 用数组实现栈<span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 入栈操作</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 数组空间不够了，直接返回false，入栈失败。</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> n<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token comment">// 将item放到下标为count的位置，并且count加一</span>
		items<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 出栈操作</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 栈为空，则直接返回null</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span>
		<span class="token class-name">String</span> tmp <span class="token operator">=</span> items<span class="token punctuation">[</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token operator">--</span>count<span class="token punctuation">;</span>
		<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编程题4：用链表实现一个链式栈</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 用链表实现栈 <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">private</span> <span class="token class-name">ListNode</span> top <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token comment">//入栈</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">ListNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//判断是否栈空</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				top <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> top<span class="token punctuation">;</span>
				top <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//出栈</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> value <span class="token operator">=</span> top<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
			top <span class="token operator">=</span> top<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			<span class="token keyword">return</span> value<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">ListNode</span> p <span class="token operator">=</span> top<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="8_1297"></a>8、队列部分知识点(关键点：确定队空/队满的判定条件)</h4> 
<h5><a id="81DisruptorLinux_1298"></a>8.1、具有某种特性的队列：循环队列、阻塞队列、并发队列(在片底层的系统、框架、中间件开发中，起着重要的作用，如高性能队列Disruptor、Linux环形缓存，用到了循环并发队列</h5> 
<p>java concurrent并发包利用ArrayBlockingQueue来实现公平锁等)<br> 分类：顺序队列和链式队列(用数组实现的队列和链表实现的队列) 基于链表实现的无界队列(可能会导致过多的请求排队，响应时间较长)，基于数组实现的有界队列(大小有限)</p> 
<h5><a id="82__1303"></a>8.2、队列使用场景 美团</h5> 
<ul><li>排队请求；</li><li>数据库连接池；</li><li>高性能队列Disruptor</li></ul> 
<h5><a id="83Disruptor__kafka_1309"></a>8.3、高性能队列Disruptor(内存消息队列) kafka</h5> 
<p>Disruptor(线程之间用于消息传递的队列)(应用apache Storm/canal/log4j2) 性能比常用的内存消息队列ArrayblockingQueue要高出一个数量级，它还因此获得过Oracle官方的Duke大奖<br> 1、Disruptor详解？<br> 基于循环队列保证数据被消费的顺序性。(实现了一个最简单的“生产者-消费者模型”)在这个模型中，“生产者”生产数据，并且将数据放到一个中心存储容器中。之后，“消费者”从中心存储容器中，取出数据消费。而存储数据的中心存储容器，是用什么样的数据结构来实现的呢？(1、基于链表实现的链式队列；2、基于数组实现的顺序队列(循环队列))<br> 基于循环队列的生产者/消费者模型：思路(当队列满了之后，生产者就轮询等待，当队列空了后，消费者就轮训等待)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Queue</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span><span class="token comment">//基于数据实现</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Long</span> element<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> size <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//循环队列满了</span>
		data<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
		tail <span class="token operator">=</span> <span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> size<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//循环队列为空</span>
		<span class="token keyword">long</span> ret <span class="token operator">=</span> data<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
		head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> size<span class="token punctuation">;</span>
		<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> queue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token class-name">Long</span> data<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//说明添加失败，队列为满，等待消费</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">Queue</span> queue<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> queue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">comsume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Long</span> data <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// TODO:...消费数据的业务逻辑...</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述代码存在的问题：多线程下，多个生产者写入的数据可能会互相覆盖，多个消费者可能会读取重复的数据<br> <strong>解决方法</strong>：1、加锁(同一时间只允许一个线程执行add()函数，相当于并行改成了串行)，可以使用CAS乐观锁机制减少加锁的粒度。<br> <strong>基于无锁的并发“生产者-消费者模型”</strong></p> 
<ul><li>对于生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的n个（n≥1）存储单元。后续往队列中添加元素，就可以不用加锁了；</li><li>对于消费者来说，处理的过程跟生产者是类似的。它先去申请一批连续可读的存储单元，当申请到这批存储单元之后，后续的读取操作就可以不用加锁了。<br> 源码中，Disruptor采用的是RingBuffer和AvailableBuffer这两个结构<br> 需要注意的地方：生产者A申请到一组连续的存储单元，假设下标是3到6的存储单元，生产者B紧跟着申请到下标是7到9的存储单元，那么3-6没有完全写入数据之前，7-9的数据是无法读取的，这是Disruptor实现思路的一个弊端。实际上，不管架构设计还是产品设计，往往越简单的设计思路，越能更好地解决问题。<br> <strong>4、实现一个消息队列系统</strong></li></ul> 
<p>编程题1：用数组实现一个顺序队列</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 用数组实现的队列 <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 数组：items，数组大小：n</span>
	<span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// head表示队头下标，tail表示队尾下标</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// 申请一个大小为capacity的数组</span>
	<span class="token keyword">public</span> 用数组实现的队列<span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
		n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 入队</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果tail == n 表示队列已经满了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> n<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
		<span class="token operator">++</span>tail<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//入队操作，将item放入队尾      并更新head/tail的索引 可以动态扩容的队列</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// tail == n表示队列末尾没有空间了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//tail ==n &amp;&amp; head==0，表示整个队列都占满了</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">// 表示整个队列都占满了</span>
			<span class="token comment">// 数据搬移</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tail<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				items<span class="token punctuation">[</span>i <span class="token operator">-</span> head<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//搬移完之后重新更新head和tail</span>
			tail <span class="token operator">-=</span> head<span class="token punctuation">;</span>
			head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
		<span class="token operator">++</span>tail<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 出队</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果head == tail 表示队列为空</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span>
		<span class="token class-name">String</span> ret <span class="token operator">=</span> items<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>head<span class="token punctuation">;</span>
		<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编程题2：用链表实现一个链式队列</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 基于链表实现的队列 <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 队列的队首和队尾</span>
	<span class="token keyword">private</span> <span class="token class-name">ListNode</span> head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token class-name">ListNode</span> tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token comment">// 入队</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//新建的队列</span>
			<span class="token class-name">ListNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
			tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 出队</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token class-name">String</span> value <span class="token operator">=</span> head<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
		head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">ListNode</span> p <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>编程题3</strong>：实现一个循环队列(最关键的是，确定好队空和队满的判定条件)（我使用数组实现）<br> 队列为空的判断条件仍然是head == tail，当队满时，(tail+1)%n=head，循环队列会浪费一个数组的存储空间。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 循环队列 <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//数组：items，数组大小：n</span>
	<span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// head表示队头下标，tail表示队尾下标</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// 申请一个大小为capacity的数组</span>
	<span class="token keyword">public</span> 循环队列<span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
		n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 入队</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 队列满了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n <span class="token operator">==</span> head<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
		tail <span class="token operator">=</span> <span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 出队</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果head == tail 表示队列为空</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token class-name">String</span> ret <span class="token operator">=</span> items<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
		head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>
		<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>编程题4</strong>：实现一个双端队列 java中有工具包Deque</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 自己动手实现双端队列 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> 自己动手实现双端队列<span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">insertFront</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		head<span class="token operator">=</span> <span class="token function">decr</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
		data<span class="token punctuation">[</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">insertLast</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		data<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
		tail <span class="token operator">=</span> <span class="token function">incr</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">deleteFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		data<span class="token punctuation">[</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		head <span class="token operator">=</span> <span class="token function">incr</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">deleteLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		tail <span class="token operator">=</span> <span class="token function">decr</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
		data<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>data<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getRear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> data<span class="token punctuation">[</span><span class="token function">decr</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> head <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>head<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> tail<span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>head<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//前进一步</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">incr</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">++</span>index <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//后退一步</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">decr</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">--</span>index <span class="token operator">+</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编程题5：滑动窗口最大值</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span>nums<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> 
		<span class="token keyword">return</span> nums<span class="token punctuation">;</span>
	<span class="token comment">//双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数按从大到小排序</span>
	<span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 结果数组</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">//保证从大到小 如果前面数小 弹出</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			list<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//添加当前值对应的数组下标</span>
		list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//初始化窗口 等到窗口长度为k时 下次移动在删除过期数值</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>i<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			list<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
		<span class="token punctuation">}</span> 
		<span class="token comment">//窗口长度为k时 再保存当前窗口中最大值</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			result<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>	
</code></pre> 
<ul><li>编程题6：两个栈实现队列<br> 思路：用栈a栈b模拟队列q，a为插入栈，b为弹出栈，栈a提供入队功能，栈b提供出队功能。入队时，入栈a即可，出队时，分两种情况：<br> *1、栈b不为空，直接弹出栈b的数据 *2、栈b为空，则依次弹出栈a的数据，放入栈b中，再弹出栈b的数据。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 两个栈实现队列<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//E为链表或数组</span>
	<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				s2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编程题7：使用两个队列实现栈<br> 思路：确保有一个队列总是空的， 入栈：在任何一个非空队列中插入元素，检查队列q1是否为空，如果q1为空，那么对q2执行入队操作；<br> 出栈：如果队列q1非空，那么从q1移n-1个元素到q2中，然后对q1中的最后一个元素执行出队操作并返回该元素。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 使用队列实现栈<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> queue1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//E为链表或数组;</span>
	<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> queue2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>queue1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			queue2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			queue1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token class-name">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> i<span class="token punctuation">,</span>size<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>queue2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			size <span class="token operator">=</span> queue1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				queue2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>queue1<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> queue1<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			size <span class="token operator">=</span> queue2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				queue1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>queue2<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> queue2<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h5><a id="84_______arrayblockingqueueputtakecallable_1655"></a>8.4、写一个生产者-消费者队列 政采云问到了 ***非常好的题目 通过arrayblockingqueue的put/take+callable实现，详见后面的阻塞队列</h5> 
<ul><li>1、可以通过阻塞队列实现 2、也可以通过wait-notify来实现 3、通过无锁的内存高性能队列Disruptor实现“生产者-消费者模型”</li><li>后续补充具体例子</li></ul> 
<hr> 
<h4><a id="9_1660"></a>9、递归方法</h4> 
<p><strong>递归的使用场景</strong><br> 1、查询类目树</p> 
<p><strong>使用递归时应该注意的问题？</strong><br> 1、警惕堆栈溢出：(如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险) 解决方案：递归调用超过一定的深度后，就停止队规，返回错误(由于递归深度无法事先知道，这种方案不实用)</p> 
<ul><li>在递归调用类目树时遇到过，由于程序不当，造成了树一直被递归调用，从而导致堆栈溢出</li></ul> 
<p>2、递归代码的重复计算问题：某一个子问题被重复计算了多次。解决方案：通过一个数据结构(散列表)保存已经求结果的f(k),先看子问题是否被求解过，若是，直接从散列表中取值返回。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token comment">//hasSolvedList可以理解为一个Map，key是n，value是f(n)</span>
	hasSolvedList<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> hasSolvedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	hasSolvedList<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//王争这道题没写好，他的本意是记忆化递归</span>
</code></pre> 
<p>3、空间复杂度，比较大，为O(n)<br> 3、递归代码改写为非递归代码：f(x) =f(x-1)+1 -&gt;</p> 
<pre><code class="prism language-java">	<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			ret <span class="token operator">=</span> ret <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
	<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> prepre <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			ret <span class="token operator">=</span> pre <span class="token operator">+</span> prepre<span class="token punctuation">;</span>
			prepre <span class="token operator">=</span> pre<span class="token punctuation">;</span>
			pre <span class="token operator">=</span> ret<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>4、如何调试递归？调试递归:<mark>1.打印日志发现，递归值。2.结合条件断点进行调试</mark></p> 
<p>编程题2：如何找到“最终推荐人”？在数据库表中，我们可以记录两行数据，其中actor_id表示用户id，referrer_id表示推荐人id</p> 
<pre><code class="prism language-java"><span class="token keyword">long</span> <span class="token function">findRootReferrerId</span><span class="token punctuation">(</span><span class="token keyword">long</span> actorId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Long</span> referrerId <span class="token operator">=</span> select referrer_id from <span class="token punctuation">[</span>table<span class="token punctuation">]</span> where actor_id <span class="token operator">=</span> actorId<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>referrerId <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> actorId<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">findRootReferrerId</span><span class="token punctuation">(</span>referrerId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>可能出现的问题</strong>：1、递归很深会出现堆栈溢出的问题 2、若数据库中存在脏数据，可能会出现无限循环的问题 （如何来检测环的存在呢？）</p> 
<ul><li><strong>检测环可以构造一个set集合或者散列表</strong>(下面都叫散列表)。每次获取到上层推荐人就去散列表里先查，没有查到的话就加入，如果存在则表示存在环了。当然，每一次查询都是一个自己的散列表，不能共用。</li><li><strong>检测环的第二种方法：双指针法</strong>(从起点开始分别以2x,1x速度出发两个指针,当遇到null停止,相遇点为null时说明没有环,如果相遇点不为null,说明有环)<br> 编程1；实现斐波那契数列求值f(n)=f(n-1)+f(n-2) or 假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问走这n个台阶有多少种走法？<br> 递推公式：f(n)=f(n-1)+f(n-2) 递归终止条件：f(1)=1,f(2)=2<br> 最终的递归代码是这样的：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编程题2：汉诺塔(思想：将原柱最上面的n-1个圆盘移动到辅助柱；将第n个圆盘从原柱移到目的柱；将辅助柱的n-1个圆盘移动到目的柱)</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token class-name">TowersOfHanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">char</span> frompeg<span class="token punctuation">,</span><span class="token keyword">char</span> topeg<span class="token punctuation">,</span><span class="token keyword">char</span> auxpeg<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">/*如果仅有一个圆盘，直接移动，然后返回*/</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">syso</span><span class="token punctuation">(</span><span class="token string">"Move disk 1 from peg"</span><span class="token operator">+</span>frompeg<span class="token operator">+</span><span class="token string">"to peg"</span><span class="token operator">+</span>topeg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*利用c作为辅助，将A柱最上面的n-1个圆盘移动到B柱*/</span>
	<span class="token class-name">TowersOfHanoi</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> frompeg<span class="token punctuation">,</span> topeg<span class="token punctuation">,</span>auxpeg<span class="token punctuation">)</span>；
	<span class="token comment">/*将余下的圆盘从A柱移动C柱*/</span>
	<span class="token function">syso</span><span class="token punctuation">(</span><span class="token string">"Move disk 1 from peg"</span><span class="token operator">+</span>frompeg<span class="token operator">+</span><span class="token string">"to peg"</span><span class="token operator">+</span>topeg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*利用A柱作为辅助，将B柱上的n-1个圆盘移到C柱*/</span>
	<span class="token class-name">TowersOfHanoi</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> auxpeg<span class="token punctuation">,</span>topeg<span class="token punctuation">,</span>frompeg<span class="token punctuation">)</span>；
<span class="token punctuation">}</span>
</code></pre> 
<p>编程3；实现求阶乘n!</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> <span class="token class-name">Fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//基本情形：当参数为0或1时，返回1</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> n<span class="token operator">*</span><span class="token class-name">Fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编程4；实现一组数据集合的全排列</p> 
<pre><code class="prism language-java">		<span class="token keyword">public</span> <span class="token keyword">class</span> 实现一组数据集合的全排列 <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printAllSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token function">_printAllSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">List</span> list <span class="token operator">:</span> result<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					count<span class="token operator">++</span><span class="token punctuation">;</span>
					<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token operator">+</span><span class="token string">" 第"</span><span class="token operator">+</span>count<span class="token operator">+</span><span class="token string">"种"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">_printAllSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmpArr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 结束条件</span>
				<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>tmpArr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> subList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> subList2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					subList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmpArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					subList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmpArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					subList2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmpArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					subList2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmpArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>subList<span class="token punctuation">)</span><span class="token punctuation">;</span>
					result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>subList2<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">return</span> result<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// 当前层处理</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tmpArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 顺序拿出一个参数，其余交给下一层处理</span>
					<span class="token keyword">int</span> tmp <span class="token operator">=</span> tmpArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
					<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>tmpArr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
					<span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
					<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> tmpArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
							arr<span class="token punctuation">[</span>offset<span class="token punctuation">]</span> <span class="token operator">=</span> tmpArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
							offset<span class="token operator">++</span><span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
					<span class="token punctuation">}</span>
					<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> nextLevelResult <span class="token operator">=</span> <span class="token function">_printAllSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">// 处理下一层结果（当前值加到结果的前面、后面）</span>
					<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> nextList <span class="token operator">:</span> nextLevelResult<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> appendList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						appendList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
						appendList<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>nextList<span class="token punctuation">)</span><span class="token punctuation">;</span>
						result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>appendList<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">return</span> result<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token comment">//[1, 2, 3, 4] 第1种  [1, 2, 4, 3] 第2种  [1, 3, 2, 4] 第3种  [1, 3, 4, 2] 第4种  [1, 4, 2, 3] 第5种  [1, 4, 3, 2] 第6种</span>
</code></pre> 
<p>编程5；爬楼梯<br> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p> 
<pre><code class="prism language-java"><span class="token comment">//方法1：暴力法 使用递归</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">climb_Stairs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climb_Stairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token function">climb_Stairs</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb_Stairs</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度：O(2^n)</span>
</code></pre> 
<p>方法2：记忆化递归 每一步的结果存储在 memomemo 数组之中，每当函数再次被调用，我们就直接从 memomemo 数组返回结果</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 记忆化递归 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> memo<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token function">climb_Stairs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climb_Stairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> memo<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">climb_Stairs</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> memo<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb_Stairs</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>方法3：动态规划 第i阶可以由以下两种方法得到：在第(i-1)阶后向上爬一阶。在第(i-2)阶后向上爬 2 阶。状态转移公式：dp[i]=dp[i?1]+dp[i?2]</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 动态规划求解爬楼梯 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="10HashMapLinkedHashMap_1874"></a>10、散列表相关知识点(HashMap/LinkedHashMap)</h4> 
<h5><a id="101hash_1875"></a>10.1、什么是hash算法，他们用于什么？</h5> 
<blockquote> 
 <p>hash算法是一个hash函数，他使用任意长度的字符串，并将其减少为唯一的固定长度字符串。他用于密码有效性、消息和数据完整性以及许多其他加密系统。</p> 
</blockquote> 
<ul><li>加密算法原理：加密是将明文转换成“密文”的过程。要转换文本，算法使用一系列被称为“键”的位来进行计算。密钥越大，创建密文的潜在模式越多。大多数加密算法使用长度约为64到128位的固定输入块，而有些则使用流方法。</li><li>常用的加密算法：3-way blowfish cast cmea gost des/triple des idea loki crc MD5</li><li>哈希算法的应用：安全加密(MD5/SHA)、数据校验、唯一标识、散列函数，负载均衡、数据分片、分布式存储 **</li><li>安全加密：第一是很难根据哈希值反向推导出原始数据，第二是散列冲突的概率很小。</li><li>唯一标识：图片的唯一id(我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中)</li><li>数据校验:我们通过哈希算法，对100个文件块分别取哈希值，并且保存在种子文件中。哈希算法特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</li><li>散列函数：对于冲突的要求低很多(即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决),更看重的是散列的平均性和哈希算法的执行效率。</li></ul> 
<ul><li><strong>在分布式系统中的应用：</strong></li></ul> 
<ul><li>负载均衡：(利用哈希算法替代映射表)通过哈希算法，对客户端IP地址或者会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</li></ul> 
<p><strong>数据分片</strong>：(通过哈希算法对处理的海浪数据进行分片，多机分布式处理，突破单机资源限制)<br> 1、如何统计“搜索关键词”出现的次数？(难点：搜索日志很大，没办法放到一台机器的内存中；第二：如果只用一台机器处理数据，时间耗费很长)<br> 我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度(n台机器，从搜索记录的日志文件中，依次独处每个搜索关键词，并且通过哈希函数计算hash值，然后再跟n取模<br> 最终得到的值，就是应该被分配到的机器编号)(MapReduce的基本设计思想)<br> 2、如何快速判断图片是否在图库中？我们同样可以对数据进行分片，然后采用多机处理。我们准备n台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯<br> 一标识，然后与机器个数n求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。<br> 当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去编号k的机器构建的散列表中查找。</p> 
<p><strong>分布式存储</strong>：(利用一致性哈希算法，解决缓存等分布式系统的扩容/缩容导致数据大量搬移的问题)<br> 假设我们有k个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成m个小区间（m远大于k），每个机器负责m/k个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p> 
<p>散列表：散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。<br> 当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标。</p> 
<p>散列函数：1. 散列函数计算得到的散列值是一个非负整数；2. 如果key1 = key2，那hash(key1) == hash(key2)；3. 如果key1 ≠ key2，那hash(key1) ≠ hash(key2)(这一点即使是MD5/CRC算法也无法完全避免散列冲突)</p> 
<ul><li>应用：判断单词是否拼写错误(使用Trie树更好)；redis的字典是使用链式法来解决散列冲突的，并且使用了渐进式rehash方式进行hash表的弹性扩容</li></ul> 
<blockquote> 
 <p><strong>Q:区块链使用的是哪种哈希算法？是为了什么问题而使用的呢？</strong><br> A:区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体(区块头保存着自己区块体和上一个区块头 的哈希值),因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。区块链使用的是SHA256哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。</p> 
</blockquote> 
<hr> 
<h5><a id="102hash_1908"></a>10.2、hash函数是怎么实现的？</h5> 
<p>1、散列算法 hash(key)&amp;(capitity-1) //在插入或查找时,计算Key被映射到桶的位置。 当capacity为2的整数倍是该公式才成立。相当于对key的hash值对表厂取模，基于hashmap是2的幂次方特性，这种位运算速度更快。<br> 2、hash的高16bit和低16bit做了一个异或<br> 3、（n-1）&amp;hash 得到下标<br> 4、使用&amp;代替取模，实现了均匀的散列，但效率要高很多，与运算比取模的效率高，由于计算机组成原理 <br> 代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>capitity <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//capicity表示散列表的大小</span>
<span class="token punctuation">}</span>	
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>var1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			var1 <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> var1 <span class="token operator">+</span> var2<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> var1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> var1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h5><a id="103hash_1932"></a>10.3、hash冲突解决方案：(开放定址法/链表法)</h5> 
<p>使用链地址法，先找到下标i，KEY值找Entry对象，新值存放在数组中，旧值在新值的链表上，将存放在数组中的Entry设置为新值的next</p> 
<ul><li>开放定址法<br> 散列表的冲突处理？散列表的冲突处理主要分为闭散列法和开散列法；常用：线性探测法、链地址法 20181230补<br> 1、闭散列法(开放寻址法) 不开辟额外的存储空间 (当数据量比较小、装载因子小的时候，适合采用开放寻址法)</li></ul> 
<blockquote> 
 <p>特点<br> 1、不开辟额外的存储空间，还是在原先hash表的空间范围之内<br> 2、当插入元素发生了散列冲突，就逐个查找下一个空的散列地址供插入，直到查找失败</p> 
</blockquote> 
<blockquote> 
 <p>方法<br> 1、线性探测法：将散列表看作是一个循环向量，若初始地址是f(key)=d，则依照顺序d、d+1、d+2…的顺序取查找，即f(key)=(f(key)+1)mod N;(ThreadLocalMap使用的线性探测法)<br> 2、二次探测法：基本思路和线性探测法一致，只是搜索的步长和方向更加的多样，会交替以两个方向，步长为搜索次数的平方来查找 **<br> 3、 双重散列法：通常双重散列法是开放地址中最好的方法，其通过提供hash()和rehash()两个函数，前者产生冲突的时候，定制化后者rehash()重新寻址</p> 
</blockquote> 
<p>2、开散列法(链地址法) 寻找额外的存储空间(基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略)</p> 
<blockquote> 
 <p>1、特点<br> 1、一般通过将冲突的元素组织在链表中，采用链表遍历的方式查找<br> 2、解决方法直观,实现起来简单,尤其在删除元素的时候此处只是简单的链表操作<br> 3、开散列法可以存储超过散列表容量个数的元素</p> 
</blockquote> 
<blockquote> 
 <p>2、方法<br> 1、链地址法：相同散列值的记录放到同一个链表中，他们在同一个Bucket中（java中LinkedHashMap采用此方法）<br> 优化方案：将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。<br> 2、公共溢出法：将所有的冲突都放到一个公共的溢出表中去，适用于冲突情况很小的时候</p> 
</blockquote> 
<hr> 
<h5><a id="104_1959"></a>10.4、面试题</h5> 
<ul><li><strong>1、假设我们有10万条URL访问日志，如何按照访问次数给URL排序</strong><br> 遍历10万条数据，以URL为key，访问次数为value，存入散列表，同时记录访问次数的最大值K，时间复杂度O(N)，如果K不是很大，可以使用桶排序，时间复杂度O(N)。如果k非常大(10万)，就使用快速排序，复杂度O(NlgN)</li><li>2、<strong>有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？</strong><br> 以第一个字符串数组构建散列表，key为字符串，value为出现次数。再遍历第二个字符串数组，以字符串为key在散列表中查找，如果value大于零，说明存在相同字符串。时间复杂度O(N)。</li><li><strong>3、如何避免低效扩容？</strong><br> 当装载因子已经到达阈值，需要先进行扩容，再插入数据，这种操作很低效。解决方案：将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。<br> 当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。</li><li>5、如何通过哈希算法生成短网址？（王争的第56讲 http://t.cn是短网址服务的域名）<br> MurmurHash算法。现在它已经广泛应用到Redis、MemCache、Cassandra、HBase、Lucene等众多著名的软件中。</li><li>6、编程实现一个基于链表法解决冲突问题的散列表</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashTable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> tSize<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashTableNode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> blockCount<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token class-name">ListNode</span> startNode<span class="token punctuation">;</span><span class="token comment">//维护的线性表</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> 基于散列表解决冲突的散列表 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> LOADFACTOR <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HashTable</span> <span class="token function">createHashTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">HashTable</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//count默认设置为0；</span>
		h<span class="token punctuation">.</span><span class="token function">settSize</span><span class="token punctuation">(</span>size <span class="token operator">/</span> LOADFACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> h<span class="token punctuation">.</span><span class="token function">gettSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			h<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">setStartNode</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> h<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hashSearch</span><span class="token punctuation">(</span><span class="token class-name">HashTable</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">ListNode</span> temp<span class="token punctuation">;</span>
		temp <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token class-name">Hash</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> h<span class="token punctuation">.</span><span class="token function">gettSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getStartNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">getVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> 
			<span class="token punctuation">}</span>
			temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//散列函数</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">Hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> gettSize<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> h <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token comment">/* data.hashCode(); */</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>gettSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// capicity表示散列表的大小</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>7、<strong>编程实现一个LRU缓存淘汰算法</strong> (使用散列表+链表组合实现缓存淘汰算法)LinkedHashMap(思路牛逼)(双向链表+散列表)(使用双向链表支持按照插入的顺序遍历数据，支持按照访问顺序遍历数据)</p> 
<p>一个缓存（cache）系统主要包含下面这几个操作：往缓存中添加一个数据；从缓存中删除一个数据；在缓存中查找一个数据。<br> ①使用双向链表存储数据，链表中每个节点存储数据（data）、前驱指针（prev）、后继指针（next）和hnext指针（解决散列冲突的链表指针）。<br> ②散列表通过链表法解决散列冲突，所以每个节点都会在两条链中。一条链是双向链表，另一条链是散列表中的拉链。前驱和后继指针是为了将节点串在双向链表中，hnext指针是为了将节点串在散列表的拉链中。(牛逼)</p> 
<ul><li>往缓存中查找一个数据：在散列表中查找数据的时间复杂度为O(1)，找到后，将其移动到双向链表的尾部</li><li>删除数据：在O(1)时间复杂度里找到要删除的结点，双向链表可以通过前驱指针O(1)时间复杂度获取前驱结点</li><li>添加一个数据：先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> LRU缓存淘汰算法<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">ListNode</span> head<span class="token punctuation">;</span> <span class="token comment">//最近最少使用，类似列队的头，出队</span>
	<span class="token keyword">private</span> <span class="token class-name">ListNode</span> tail<span class="token punctuation">;</span> <span class="token comment">//最近最多使用，类似队列的尾，入队</span>
	<span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">ListNode</span><span class="token punctuation">&gt;</span></span> cache<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
	<span class="token keyword">public</span> LRU缓存淘汰算法<span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">ListNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">moveNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把该数据移动到链表尾部</span>
			<span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">ListNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
			<span class="token function">moveNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把该数据移动到链表尾部</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span><span class="token comment">//缓存满了，移除链表的头结点</span>
			<span class="token function">removeHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">addNode</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">ListNode</span> tempNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
			cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
			head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			tempNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
				head<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
			head <span class="token operator">=</span> tail <span class="token operator">=</span> node<span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token function">addNodeToTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addNodeToTail</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		node<span class="token punctuation">.</span>prev <span class="token operator">=</span> tail<span class="token punctuation">;</span>
		tail<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
		tail <span class="token operator">=</span> node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//移动数据到链表尾部 分类讨论：第一种要移动的结点是头结点；第二种直接为尾节点，无需处理；第三种为链表中的结点</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> node <span class="token operator">&amp;&amp;</span> node <span class="token operator">!=</span> tail<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			head <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			head<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			node<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token function">addNodeToTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> node<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
			node<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token function">addNodeToTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>java中有现成的工具可以使用</p> 
<ul><li>LinkedHashMap维护了插入的先后顺序【FIFO】，适合LRU算法做缓存（最近最少使用）(在项目中被用到过)</li></ul> 
<pre><code class="prism language-java"> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> unchecked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span> <span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">.75F</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
         <span class="token comment">//什么时候执行LRU操作</span>
         <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">20</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h4><a id="11_2100"></a>11、字符串处理算法总结：</h4> 
<p>理解常用字符串匹配算法的原理、实现、设计意图和应用场景，搞清楚能解决什么问题。</p> 
<h5><a id="111Java_2104"></a>11.1、用Java写一个递归遍历目录下面的所有文件</h5> 
<p>思路：利用File类中的一个listFiles将该文件路径下所有的文件全部列出来，然后通过循环遍历</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">showDirectory</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>		   
	<span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		   
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">File</span> a<span class="token operator">:</span>files<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>	
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
		<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>	
			<span class="token function">showDirectory</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="112txt_2118"></a>11.2、给定一个txt文件，如何得到某字符串出现的次数</h5> 
<pre><code class="prism language-java"><span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"E://test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="113az26Trie_2132"></a>11.3、实现一个字符集，只包含a～z这26个英文字母的Trie树（也称为字典树/键树）</h5> 
<ul><li>暂时在项目中找不到使用场景。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">char</span> data<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> isEndingChar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Trie</span>树 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">TrieNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//存储无意义字符</span>
	<span class="token comment">// 往Trie树中插入一个字符串</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> text<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> index <span class="token operator">=</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">TrieNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		p<span class="token punctuation">.</span>isEndingChar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 在Trie树中查找一个字符串</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> index <span class="token operator">=</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 不存在pattern</span>
			<span class="token punctuation">}</span>
			p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>isEndingChar <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 不能完全匹配，只能匹配前缀</span>
		<span class="token keyword">else</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 找到pattern</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="114BF_2176"></a>11.4、实现朴素的字符串匹配算法(暴力匹配算法/BF算法)</h5> 
<ul><li>思路：我们在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串 我们把主串的长度记作n，模式串的长度记作m。因为我们是在主串中查找模式串，所以n&gt;m</li><li>我们在主串中，检查起始位置分别是0、1、2…n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的。</li></ul> 
<p>JDK提供的Utils方法：</p> 
<pre><code class="prism language-java"><span class="token comment">// 时间复杂度：O(n*m)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> bool <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">'jd.com'</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>aa<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">// 暴力匹配算法 时间复杂度是O(n*m)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bF</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> m <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//主串</span>
	<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b1 <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//模式串</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m <span class="token operator">-</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//n为模式串的长度</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">==</span> b1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				k<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//k的值表示匹配的长度</span>
			<span class="token punctuation">}</span><span class="token keyword">else</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>思路：我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了，效率取决于哈希算法的设计方法。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">rK</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> m <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m <span class="token operator">-</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//主串可以分解为子串的个数</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b1 <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//将26的次方存储在一个表里，取的时候直接用,虽然溢出，但没啥问题</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		table<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>
		s <span class="token operator">*=</span> <span class="token number">26</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m <span class="token operator">-</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//主串</span>
		s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			s <span class="token operator">+=</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">*</span> table<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//table为倒序</span>
		<span class="token punctuation">}</span>
		hash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//模式串</span>
		s <span class="token operator">+=</span> <span class="token punctuation">(</span>b1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">*</span> table<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m <span class="token operator">-</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//两者的hash值比较</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> j<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">// sunday算法 时间复杂度 O(n)</span>
 <span class="token comment">/**
 * 判断子串中是否存在末尾下一个位置对应的父串的字符
 * 每次从后往前匹配，为了不遗漏可能的匹配，应该是跳到使得子串中最右一个字符与父串中的该字符对应，
 * 这样跳过的距离最小，且是安全的。
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sonArray<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> sonArray<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sonArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//这里转为char数组要更方便些</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fatherArray <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sonArray <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> fatherLength <span class="token operator">=</span> fatherArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> sonLength <span class="token operator">=</span> sonArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//+ j是可能会出现最后一次移动father剩余长度与son长度不一致的情况</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> fatherLength <span class="token operator">-</span> sonLength <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fatherArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> sonArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//如果父串与子串当前字符不相等</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> fatherLength <span class="token operator">-</span> sonLength <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//这里说明子串已经是在和父串中最后可能想等的字符比较过了，并且后面也没有可比较的了，所以返回</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">//如果父串的中间部分与子串匹配，且结果不相等</span>
            <span class="token comment">//就从子串最后面开始，找出子串最后一位的下一位对应父串的字符在子串中是否存在</span>
            <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">contains</span><span class="token punctuation">(</span>sonArray<span class="token punctuation">,</span> fatherArray<span class="token punctuation">[</span>i <span class="token operator">-</span> j <span class="token operator">+</span> sonLength<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//不存在则直接跳到再下一位，子串从头开始</span>
                i <span class="token operator">=</span> i <span class="token operator">-</span> j <span class="token operator">+</span> sonLength <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//存在则将这个字符与子串最右边与它相同的字符对其,并再次从头开始比较</span>
                i <span class="token operator">=</span> i <span class="token operator">+</span> sonLength <span class="token operator">-</span> pos <span class="token operator">-</span> j<span class="token punctuation">;</span>
                j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//如果父串与子串当前字符相等</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> sonLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//如果比较到了子串的最后一位，说明已经存在</span>
                <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//不是子串最后一位，则进行下一个字符的对比</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
                j<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 测试</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	   <span class="token class-name">String</span> source <span class="token operator">=</span> <span class="token string">"http://www.cg.yixiubao.tv.com?itemId=1111"</span><span class="token punctuation">;</span>
	   <span class="token class-name">String</span> target <span class="token operator">=</span> <span class="token string">"cg.yixiubao.tv"</span><span class="token punctuation">;</span>
	   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法思想：编程中一定会出现的问题：变种非常多(反转/反转单词/子串/最长子串/最长子序列)</p> 
<ul><li>1、用固定支付替换字符串中的空格<br> 使用stringbuffer的append（）</li><li>2、验证是否是回文串<br> 只考虑字母和数字字符，先用isletterOrDigit来跳过其他字符，第一个字符与最后一个字符依次比较，然后I++，J–</li><li>3、数组的最长公共前缀<br> 先用数组的sort方法升序排列，找出数组第一个字符串和最后一个的长度，按小的计算，比较字符串的元素，若相等就<br> 保存在Stringbuffer中</li><li>4、最长回文串 区分大小写<br> 字符出现次数为双+一个只出现一次的字符，遍历数组，字符在hashset中就移除，count++，否则，添加进去</li></ul> 
<p>5、反转字符串，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题 输入：[“h”,“e”,“l”,“l”,“o”]输出：[“o”,“l”,“l”,“e”,“h”]</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> r <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">!=</span> mid <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">char</span> temp <span class="token operator">=</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
		s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>
		s<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
		l<span class="token operator">++</span><span class="token punctuation">;</span>
		r<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度O(n)</span>
</code></pre> 
<p>StringTokenizer详解：(允许应用程序将字符串分解为标记)<br> 1、int countTokens() 计算在生成异常之前可以调用此 tokenizer 的 nextToken 方法的次数；<br> 2、boolean hasMoreElements() 返回与 hasMoreTokens 方法相同的值；<br> 3、String nextToken(String delim) 返回此 string tokenizer 的字符串中的下一个标记。<br> 下面是一个使用 tokenizer 的实例。代码如下：</p> 
<pre><code class="prism language-java"><span class="token class-name">StringTokenizer</span> st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span><span class="token string">"this is a test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出以下字符串： this is a test<br> StringTokenizer出于兼容性的原因而被保留，建议使用String的split方法或java.util.regex包。建议</p> 
<pre><code class="prism language-java"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token string">"this is a test"</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span>result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>输出以下字符串： this is a test</p> 
<p>6、 翻转字符串里的单词 输入: “the sky is blue” 输出: “blue is sky the”</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strArr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\s+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正则匹配空格</span>
	<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>strArr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//倒序遍历，添加空格</span>
		sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>strArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//去除首尾多余空格，toString返回</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>7、字符串转换整数 请你来实现一个 atoi 函数，使其能将字符串转换成整数<br> 该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数<br> 例如：输入: " -42" 输出: -42 第一个非空白字符为 ‘-’, 它是一个负号<br> 输入: “4193 with words” 输出: 4193 解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//使用flag指定数值正负</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> len <span class="token operator">||</span> <span class="token operator">!</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token class-name">String</span> string <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> parseInt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
		parseInt <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			parseInt <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			parseInt <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> parseInt<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>parseInt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="12_2428"></a>12、树部分面试题</h4> 
<h5><a id="121_2429"></a>12.1、如何遍历一棵二叉树？</h5> 
<p>二叉树是n个有限元素的集合，由根元素以及左右子数组成。集合可以为空。</p> 
<ul><li>概念：结点的度，结点所拥有的子树的个数称为度。<br> 叶节点，度为o的结点。<br> 分支节点，即非叶子结点</li><li>路径：n1，n2，，，nk的长度为路径</li><li>层数：根结点层数为1，其余的结点++双亲</li><li>深度：最大层数</li><li>满二叉树：所有叶子结点在同一层</li><li>完全二叉树：叶子结点只能出现在最下层和次下层。</li><li>性质： 非空二叉树第i层最多2{i-1}个结点<br> 深度为k，最多2{k}-1个结点，最少k个结点<br> 非空二叉树，度为0的节点数比度为2的节点数多1，n0=n2+1；<br> n个结点的完全二叉树的深度为lgn+1</li><li>存储：1、基于指针或者应用的二叉链式存储法；2、基于数组的顺序存储法(适合完全二叉树) <br> 链式存储法：每个结点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针<br> 顺序存储法：节点X存储在数据中下标为i的位置，下标为2<em>i的位置存储的是左子节点，下标为2</em>i+1的位置存储的是右子节点。</li><li>遍历：使用队列来实现对二叉树的层序遍历，思路：根结点放入队列，每次从队列中取出一个结点，打印值。若这个值有子结点，子结点入队尾，直至队列为空。 代码P305（是一种广度优先的遍历算法）<br> 递归实现：中序遍历，先序遍历，后序遍历(表示的是节点与它的左右子树节点遍历打印的先后顺序) 时间复杂度O(n)<br> 非递归中序遍历：首先要移动到结点的左子树，完成左子树的遍历后，再将结点出栈进行</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token class-name">InOrderNonRecursive</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">Stack</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
			root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		root <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token punctuation">)</span> s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>非递归先序遍历：需要使用一个栈来记录当前节点，以便在完成左子树遍历后能返回到右子树中进行遍历；<br> * 在遍历左子树之前，把当前节点保存在栈中，直至遍历完左子树，将该元素出栈，然后找到右子树进行遍历。</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token class-name">PreOderNonRecursive</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">Stack</span> s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用栈保存将要遍历的结点</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
			s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
			root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		root <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token punctuation">)</span> s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
递归后序遍历：
<span class="token keyword">void</span> <span class="token class-name">PostOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">PostOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PostOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
层序遍历：
<span class="token keyword">void</span> <span class="token class-name">LevelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token class-name">TreeNode</span> temp<span class="token punctuation">;</span>
	<span class="token class-name">Queue</span> q<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	q<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h5><a id="122Mysql_2520"></a>12.2、二叉查找树(二叉搜索树)(Mysql索引的底层)</h5> 
<p>二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作<br> 1、查找操作：我们先去根节点，如果它等于我们要查找的数据，就返回；如果比根节点小，就在左子树中递归查找；如果比根节点值大，就在右子树中递归查找。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearchTree</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">Node</span> tree<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Node</span> p <span class="token operator">=</span> tree<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">private</span> <span class="token keyword">int</span> data<span class="token punctuation">;</span>
		<span class="token keyword">private</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
		<span class="token keyword">private</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2、插入操作 得先比较，从根节点开始</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">Node</span> p <span class="token operator">=</span> tree<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				p<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// data &lt; p.data</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				p<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3、二叉查找树的删除操作(1、如果要删除的节点没有子节点，我们只需要直接将父节点中指向要删除节点的指针置为null；2、要删除的节点有一个子节点，我们只需要更新父节点，指向要删除节点的指针<br> 3、要删除的节点有两个子节点，找到这个节点的右子树中的最小节点，替换到要删除的节点上)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Node</span> p <span class="token operator">=</span> tree<span class="token punctuation">;</span> <span class="token comment">// p指向要删除的节点，初始化指向根节点</span>
	<span class="token class-name">Node</span> pp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// pp记录的是p的父节点</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>data <span class="token operator">!=</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		pp <span class="token operator">=</span> p<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token keyword">else</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 没有找到</span>
	<span class="token comment">//要删除的节点有两个子节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//查找右子树中最小节点</span>
		<span class="token class-name">Node</span> minP <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> minPP <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// minPP表示minP的父节点</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>minP<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			minPP <span class="token operator">=</span> minP<span class="token punctuation">;</span>
			minP <span class="token operator">=</span> minP<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		p<span class="token punctuation">.</span>data <span class="token operator">=</span> minP<span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token comment">// 将minP的数据替换到p中</span>
		p <span class="token operator">=</span> minP<span class="token punctuation">;</span> <span class="token comment">// 下面就变成了删除minP了</span>
		pp <span class="token operator">=</span> minPP<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//删除节点是叶子节点或者仅有一个子节点</span>
	<span class="token class-name">Node</span> child<span class="token punctuation">;</span> <span class="token comment">// p的子节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> child <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> child <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token keyword">else</span> child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pp <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> tree <span class="token operator">=</span> child<span class="token punctuation">;</span> <span class="token comment">// 删除的是根节点</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pp<span class="token punctuation">.</span>left <span class="token operator">==</span> p<span class="token punctuation">)</span> pp<span class="token punctuation">.</span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>
	<span class="token keyword">else</span> pp<span class="token punctuation">.</span>right <span class="token operator">=</span> child<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>二叉查找树的执行效率：若是根节点的左右子树季度不平衡，已经退化到了链表，查找的时间复杂度为O(n)；平衡二叉查找树的时间复杂度O(lgn)</p> 
<hr> 
<h5><a id="123TreeMap_1______2607"></a>12.3、红黑树的应用场景(TreeMap 红黑树：一种近似平衡的二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1。包括完全二叉树、满二叉树) 红黑树一定得掌握</h5> 
<ul><li> <p><strong>红黑树的由来</strong><br> 红黑树是于1972年发明的，当时称为对称二叉B树，1978年得到优化，正式命名为红黑树。它的主要特征是在每个节点上增加一个属性来表示节点的颜色，可以是红色，也可以是黑色。红黑树和 AVL 树类似，都是在进行插入和删除元素时，通过特定的旋转来保持自身平衡的， 从而获得较高的查找性能。与AVL树相比，红黑树并不追求所有递归子树的高度差不超过1， <mark>而是保证从根节点到叶子节点的最长路径不超过最短路径的2 倍</mark>，所以它的最坏运行时间也是 O(logn)。<mark>红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除操作后的自平衡调整</mark>。当然 ， 红黑树在本质上还是二叉查找树，它额外引入了 5 个约束条件，如下</p> </li><li> <p><strong>红黑树的特点</strong><br> 1、每个节点要么是红色，要么是黑色;<br> 2、根节点必须是黑色;<br> 3、红色节点不能连续(红色节点的孩子和父亲都不能是红色);<br> 4、对于每个节点，从该点至叶子的任何路径，都含有相同个数的黑色节点;<br> 5、确保节点的左右子树的高度差，不会超过二者中较低那个的一倍;</p> </li><li> <p><strong>应用场景</strong>：搜索，插入删除次数多(为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的)<br> 1、map和set都是用红黑树实现的<br> 2、linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块<br> 3、epoll在内核中的实现，用红黑树管理事件块<br> 4、nginx中，用红黑树管理timer<br> 5、Java的TreeMap实现<br> AVL树适合用于插入删除次数比较少，但查找多的情况</p> </li><li> <p>关于动态数据结构：链表/栈/队列/哈希表（链表适合遍历的场景，插入和删除操作方便；栈和队列可以算一种特殊的链表，分别使用先进后出和先进先出的场景；哈希表适合插入和删除比较少，查找比较多的场景；红黑树对数据要求有序，对数据增删改查都有一定要求的时候）</p> </li><li> <p>散列表/跳表/红黑树性能对比：<br> 1、散列表：插入删除查找都是O(1)，是最常用的，缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于不需要顺序遍历、数据更新不那么频繁的；<br> 2、跳表：插入删除查找都是O(lgn)，能顺序遍历，缺点是空间复杂度O(n)，适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便；<br> 3、红黑树：插入删除查找都是O(lgn)，中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。</p> </li></ul> 
<hr> 
<h5><a id="124__2633"></a>12.4、数据结构 堆</h5> 
<ul><li>满足条件：1、堆是一个完全二叉树；2、堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值<br> 堆都支持哪些操作以及如何存储一个堆(通过数组来存储)</li><li>缺点：对于一组已经有序的数据来说，经过建堆后，数据反而变得更无序了</li><li>堆排序的过程：1、建立初始堆(把数组中的元素的序列看成是一颗完全二叉树，对该二叉树进行调整，使之成为堆) 根节点的索引是1<br> 2、堆排序(把根元素与最右子节点交换，然后再次构建堆，再与倒数第二集结点交换，然后再构建堆) 生成由小到大排列的数组<br> 时间复杂度：假设有n个数据，需要进行n-1次建堆，每次建堆本身耗时lgn，则其时间效率为O(nlgn) 空间复杂度O(1)<br> 建堆操作：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">buildHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> maxPos <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>maxPos<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>maxPos <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> maxPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
		i <span class="token operator">=</span> maxPos<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>	
</code></pre> 
<pre><code>	排序操作：	//n表示数据的个数，数组a中的数据从下标1到n的位置。
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">buildHeap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> k <span class="token operator">=</span> n<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">--</span>k<span class="token punctuation">;</span>
		<span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>为什么快速排序要比堆排序性能好？<br> 1、堆排序数据访问的方式没有快速排序友好(开拍是顺序访问；堆排序是跳着访问，对cpu缓存不友好)<br> 2、同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序<br> 应用：1、优先级队列；2、topK；3、流里面的中位数；</p> 
<hr> 
<h5><a id="125ACTrie_2676"></a>12.5、AC自动机：如何用多模式串匹配实现敏感词过滤功能？(使用Trie树)</h5> 
<p>字符串匹配算法：单模式串匹配算法(BF算法、RK算法、BM算法、KMP算法)，多模式串匹配算法(Trie树 最长前缀匹配)<br> AC自动机算法包含两个部分，第一部分是将多个模式串构建成AC自动机，第二部分是在AC自动机中匹配主串。第一部分又分为两个小的步骤，一个是将模式串构建成Trie树，另一个是在Trie树上构建失败指针 <br> 适用场景：</p> 
<ul><li>单模式串匹配：<br> BF(直接匹配算法 简单场景，主串和模式串都不太长, O(m<em>n) 效率最低)<br> KP(字符集范围不要太大且模式串不要太长，否则hash值可能冲突，O(n))<br> naive-BM(模式串最好不要太长（因为预处理较重）,比如IDE编辑器里的查找场景；预处理O(m</em>m),匹配O(n),实现较复杂，需要较多额外空间)<br> KMP(适合所有场景，整体实现起来也比BM简单，O(n+m)，仅需一个next数组的O(n)额外空间；但统计意义下似乎BM更快)<br> 还有一种比BM/KMP更快，且实现+理解起来都更容易的Sunday算法</li><li>多模式串匹配：<br> naive-Trie(适合多模式串公共前缀较多的匹配(O(n*k)) 或者 根据公共前缀进行查找(O(k))的场景，比如搜索框的自动补全提示 root不存储字符)<br> AC自动机(适合大量文本中多模式串的精确匹配查找, 查找的复杂度可以到O(n))**<br> 定义：AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在树上</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AcNode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">char</span> data<span class="token punctuation">;</span> 
	<span class="token keyword">public</span> <span class="token class-name">AcNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AcNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//字符集只包含a~z这26个字符</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> isEndingChar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//结尾字符为true</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//当isEndingChar=true时，记录模式串长度</span>
	<span class="token keyword">public</span> <span class="token class-name">AcNode</span> fail<span class="token punctuation">;</span> <span class="token comment">//失败指针  相当于KMP中失效函数next数组</span>
	<span class="token keyword">public</span> <span class="token class-name">AcNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="126_BB_MongoDB_B_Mysql_B_2703"></a>12.6 B树和B+树的区别(为什么 MongoDB 索引选择B树，而 Mysql 选择B+树)?</h5> 
<p>一个是数据的保存位置，</p> 
<ul><li>B树的数据每个节点既保存索引，又保存数据；B+树的数据只会落在叶子节点</li></ul> 
<p>一个是相邻节点的指向</p> 
<ul><li>增加了相邻节点的指向指针</li></ul> 
<p>上述两种特性造成的现象为：<br> 1、B+树查询时间复杂度固定是logn，B树查询复杂度最好是 O(1)。<br> 2、B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等，而B树每个节点 key 和 data 在一起，无法区间查找。<br> 3、B+树更适合外部存储，也就是磁盘存储。由于父级节点无 data 域，每个节点能索引的范围更大更精确<br> 4、注意这个区别相当重要，B树每个节点即保存数据又保存索引，所以磁盘IO的次数很少，B+树只有叶子节点保存，磁盘IO多，但是区间访问比较好。</p> 
<p>MongoDB</p> 
<ul><li>MongoDB 是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据。比如之前我们的表可能有用户表、订单表、购物车表等等，还要建立他们之间的外键关联关系。但是类Json就不一样了。</li><li>MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql。<br> <img src="https://images2.imgbox.com/b8/15/zKJnZ4fC_o.png" alt="在这里插入图片描述"></li></ul> 
<p>Mysql</p> 
<ul><li>Mysql作为一个关系型数据库，数据的关联性是非常强的，<mark>区间访问</mark>是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。</li></ul> 
<hr> 
<h4><a id="13_2726"></a>13、海量数据的处理思路问题</h4> 
<h5><a id="131_2727"></a>13.1、大数据量的问题：</h5> 
<p>10w个id，怎么去100亿个id里找数据，怎么做能更快，分库分表？</p> 
<hr> 
<h5><a id="13210G500M1000_2731"></a>13.2、有10G大小的文件，每行记录一条运单信息，机器大小是500M，求出出现次数最多的前1000条运单号，给出思路。</h5> 
<p>典型的Top K算法(分治思想)<br> 1、先对这批海量数据预处理，在O(N)的时间内用Hash表完成分组(相同单号被分配到Hash桶中的同一条链表中) %20 20个文件，每个文件500M 堆的大小取决于机器的内存值500M;<br> 2、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK<br> 3、对每个堆中的TOPk，计算出前k个数（归并排序）</p> 
<h5><a id="133ab50urlurl644Gaburl_2737"></a>13.3、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h5> 
<p>方案1：可以估计每个文件的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。<br> 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M<br> 遍历文件b，采取和a相同的hash函数将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，<br> 不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可<br> 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p> 
<h5><a id="1342525_2744"></a>13.4、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h5> 
<p>方案1：用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存内存，还可以接受。<br> 然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。<br> 方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素</p> 
<h5><a id="135_2749"></a>13.5、怎么在海量数据中找出重复次数最多的一个？</h5> 
<p>方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求100w个数中找出最大的100个数<br> 用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)</p> 
<h5><a id="13650_2753"></a>13.6、如果你所在的省有50万考生，如何通过成绩快速排序得出名次呢？</h5> 
<h5><a id="1371010_2754"></a>13.7、假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</h5> 
<h5><a id="138100081000_100MB_2755"></a>13.8、假设我们有1000万个整型数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过100MB，你会怎么做呢？</h5> 
<h5><a id="139_2757"></a>13.9、如何在海量数据中快速查找某个数据？(索引)(在计算机组成中称为寻址)</h5> 
<p>MySQL底层依赖的是B+树这种数据结构，Redis这样的Key-Value数据库中的索引，又是怎么实现的呢？底层依赖的又是什么数据结构呢？</p> 
<ul><li>索引存储位置：在内存还是硬盘</li><li>单值查找还是区间查找？<br> 单关键词查找还是多关键词组合查找？对于结构化数据的查询需求(MYSQL)，针对多个关键词的组合，建立索引；对于非结构数据的查询需求(搜索引擎)，以针对单个关键词构建索引，然后通过集合操作，比如求并集、求交集等，计算出多个关键词组合的查询结果。<br> 索引的维护成本。因为在原始数据动态增删改的同时，也需要动态的更新索引。</li><li>构建索引常用的数据结构？<br> 对动态数据建立索引：散列表、红黑树、跳表、B+树；位图、布隆过滤器可以作为辅助索引；有序数组可以用来对静态数据构建索引。</li><li>散列表：一些键值数据库，比如Redis、Memcache，就是使用散列表来构建索引的，增删改查的性能非常好，时间复杂度为O(1)，这类索引，一般都构建在内存中；</li><li>红黑树：作为一种常用的平衡二叉查找树，数据插入、删除、查找的时间复杂度是O(logn)，也非常适合用来构建内存索引。Ext文件系统中，对磁盘块的索引，使用的是红黑树；</li><li>B+树：比起红黑树来说，更加适合构建存储在磁盘中的索引，B+树是一个多叉树，所以，对相同个数的数据构建索引，B+树的高度要低于红黑树。当借助索引查询数据的时候，<br> 读取B+树索引，需要的磁盘IO次数非常更少，关系型数据库的索引：如Mysql、oracle，使用的是B+树建立索引</li><li>跳表：支持快速添加、删除、查找数据。而且通过灵活调整索引结点个数和数据个数之间的比例，可以很好地平衡索引对内存的消耗及其查询效率。Redis中的有序集合，就是用跳表来构建的<br> 布隆过滤器：对于判定存在的数据，有可能并不存在，但是对于判定不存在的数据，那肯定就不存在。内存占用非常少<br> 有序数组：如果数据是静态的，也就是不会有插入、删除、更新操作，那我们可以把数据的关键词（查询用的）抽取出来，组织成有序数组，然后利用二分查找算法来快速查找数据</li><li>你知道基础系统、中间件、开源软件等系统中，有哪些用到了索引吗？这些系统的索引是如何实现的呢？<br> 1、区块链拿以太坊来说，存储用的leveldb，数据存储用的数据结构是帕特利夏树，是一种高级的trie树，很好的做了数据的压缩；<br> 2、消息中间件像kafka这种，会去做持久化，每个partition都会有很多数据，会有大量数据存储在磁盘中，所以每个partition也会有个索引，方便去做快速访问。<br> 3、ES中的倒排索引用了trie树(一种专门处理字符串匹配的数据结构),对每个需要索引的key维护了一个trie树,用于定位到这个key在文件中的位置,然后直接用有序列表直接去访问对应的documents<br> trie树(两个操作：一个将字符串插入到Trie树的过程。另一个是在Trie树中查询一个字符串)</li></ul> 
<blockquote> 
 <p>Q:Trie树：如何实现搜索引擎的搜索关键词提示功能？(为了方便快速输入，当你在搜索引擎的搜索框中，输入要搜索的文字的某一部分的时候，搜索引擎就会自动弹出下拉框，里面是各种关键词提示)<br> A:‘字典树’。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题.<br> Trie树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起（感觉有点像霍夫曼编码：左0右1）<br> 时间复杂度：O(k) k为字符串长度<br> 应用场景：自动输入补全，比如输入法自动补全功能、IDE代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等<br> Q:Trie树应用场合对数据要求比较苛刻，比如字符串的字符集不能太大，前缀重合比较多等。如果现在给你一个很大的字符串集合，比如包含1万条记录，如何<br> 通过编程量化分析这组字符串集合是否比较适合用Trie树解决呢？也就是如何统计字符串的字符集大小，以及前缀重合的程度呢？<br> A:依次读取每个字符串的字符构建 Trie 树，用散列表来存储每一个节点。每一层树的所有散列表的元素用一个链表串联起来，求某一长度的前缀重合，在对应树层级上遍历该层链表，<br> 求链表长度，除以字符集大小，值越小前缀重合率越高。遍历所有树层级的链表，存入散列表，最后散列表包含元素的个数，就代表字符集的大小</p> 
</blockquote> 
<p>如何存储一个Trie树？</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">TrieNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//存储无意义字符</span>
	<span class="token comment">//往Trie树中插入一个字符串</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> text<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> index <span class="token operator">=</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">TrieNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		p<span class="token punctuation">.</span>isEndingChar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//在Trie树中查找一个字符串</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> index <span class="token operator">=</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//不存在pattern</span>
			<span class="token punctuation">}</span>
			p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>isEndingChar <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> 
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//不能完全匹配，只是前缀</span>
		<span class="token keyword">else</span> 
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//找到pattern</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span> <span class="token keyword">char</span> data<span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token keyword">boolean</span> isEndingChar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>	
</code></pre> 
<hr> 
<h5><a id="1310_2831"></a>13.10、并行计算：利用并行处理提高算法的执行效率(分治的思想)</h5> 
<p>算法无法再继续优化的情况下，如何来进一步提高执行效率呢？可以使用一种简单但好用的优化方法，那就是并行计算。</p> 
<ul><li>1、并行排序 对时间复杂度为O(nlgn)的三种排序算法：归并/快排/堆排进行并行化处理<br> 如：归并排序时，将8G的数据先划分为16个小的数据集合，然后多线程处理，最后将这16个有序集合合并；快速排序中，先扫描一遍数据，遭到数据所处的范围区间，<br> 同样划分为16个小区间，并行进行排序，等到16个线程都执行借宿之后，得到的数据就是有序数据了。</li><li>2、并行查找 散列表，给动态数据构建索引，在数据不断加入的时候，散列表的装载因子就会越来越大。为了保证散列表性能不下降，我们就需要对散列表进行动态扩容，<br> 可以将数据随机分割成k份（比如16份），每份中的数据只有原来的1/k，然后我们针对这k个小数据集合分别构建散列表，增加存储空间的利用率。</li></ul> 
<hr> 
<h4><a id="14_2840"></a>14、图的应用</h4> 
<h5><a id="141_2841"></a>14.1、如何存储微博、微信等社交网络中的好友关系？</h5> 
<ul><li> <p>微博：有向图(入度代表粉丝数，出度代表关注数)<br> 社交关系存储方法：邻接表(存储用户关注关系)+逆邻接表(存储被关注信息)</p> </li><li> <p>需求：判断用户A是否关注了用户B；判断用户A是否是用户B的粉丝；用户A关注用户B；用户A取消关注用户B；<br> 根据用户名称的首字母排序，分页获取用户的粉丝列表；根据用户名称的首字母排序，分页获取用户的关注列表。</p> </li><li> <p>如何迅速判断俩用户之间的关注关系？<br> 因为需要按首字母排序，获取粉丝列表或关注列表，在邻接表右边使用跳表是最合适的(跳表存储的数据有序)。这是因为，跳表插入、删除、查找都非常高效，时间复杂度是O(logn)，空间复杂度上稍高，是O(n)<br> 如何解决数据量大的问题？<br> 可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。例如：在机器1上存储顶点1，2，3的邻接表，在机器2上，存储顶点4，5的邻接表，当要查询顶点与顶点关系的时候，我们就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。<br> 持久化存储关系？<br> 使用数据库</p> </li><li> <p>微信：无向图(好友间建立一条边)</p> </li><li> <p>QQ：带权图(每条边都有一个权重，可以通过权重表示QQ好友间的亲密度)</p> </li></ul> 
<h5><a id="142_2856"></a>14.2、如何在内存中存储图这种数据结构？</h5> 
<ul><li>邻接矩阵：依赖一个二维数组，A[i][j]=w表示可达，w表示权重 (我们的扫雷游戏就是使用的这种有向图数据结构，带权值(0表示没有操作，1表示地雷，-1表示插上了红旗)下次可以做成PPT<br> 缺点：对于无向图来说，浪费了一半的空间；对于稀疏矩阵，绝大多数的存储空间都被浪费了<br> 优点：基于矩阵，在获取两顶点的关系时，就非常高效；第二是方便计算，如求最短路径</li><li>邻接表：每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点<br> 优点：节省空间<br> 缺点：在邻接表中查询两个顶点间的关系效率较低，改进措施(邻接表右侧的链表可以使用二叉树/红黑树/跳表来表示，跳表最适合)</li></ul> 
<h5><a id="143_2864"></a>14.3、图的其他领域应用？</h5> 
<p>Gradle这个编译工具，内部组织task的方式用的是有向图；<br> Android framework层提供了一个CoordinatorLayout，其内部协调子view的联动，也是用的图；<br> 互联网上网页之间通过超链接连接成一张有向图；<br> 城市乃至全国交通网络是一张加权图；</p> 
<h5><a id="144_2870"></a>14.4、如何找出社交网络中的三度好友关系？(深度优先和广度优先搜索算法)(存储使用邻接表)(无向图)</h5> 
<ul><li>BFS:广度优先搜索：时间复杂度O(V+E) V为顶点个数，E为边的个数(对于一个连通图来说,E肯定要大于等于V-1，所以，广度优先搜索的时间复杂度也可以简写为O(E)。)<br> 广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、prev数组上.所以空间复杂度是O(V)。</li><li>DFS:深度优先搜索(深度优先搜索找出来的路径，并不是顶点s到顶点t的最短路径) 时间复杂度是O(E) 空间复杂度是O(V)<br> 借助 栈来实现 辅助变量visited数组和prev数组</li><li>社交网络中的三度好友关系?<br> 非常适合于图的广度优先搜索算法来解决，因为它是层层往外推进的。首先，遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为2的顶点，也就是二度好友关系，以及与用户距离的边数为3的顶点，也就是三度好友关系。<br> 适用场合：状态空间不大，也就是图不大的搜索，属于基本的搜索算法(高级搜搜算法有A*/IDA*)</li></ul> 
<h5><a id="145__2879"></a>14.5、如何确定代码源文件的编译依赖关系？(拓扑排序 有向无环图)</h5> 
<p>问题阐述：一个完整的项目往往会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。比如，A.cpp依赖B.cpp，那在编译的时候，编译器需要先编译B.cpp，才能编译A.cpp。我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。<br> 算法解析：</p> 
<pre><code class="prism language-java"><span class="token comment">//数据结构：有向无环图，使用邻接表来存储</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span> <span class="token comment">// 顶点的个数</span>
	<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> adj<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 邻接表存放顶点</span>
	<span class="token keyword">public</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span>
		adj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// s先于t，边s-&gt;t</span>
		adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>两种实现方式：Kahn和DFS<br> 1、Kahn基于贪心算法，思路是如果s需要先于t执行，那就添加一条s指向t的边，如果某个顶点入度为0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行。<br> 我们先从图中，找出一个入度为0的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减1）<br> 我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">topoSortByKahn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inDegree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 统计每个顶点的入度</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i-&gt;w   w为  -&gt;w，即被指向的顶点，有某个点或几个点只指向他人，而不会被指向</span>
			inDegree<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//某个顶点的入度是0，将此顶点加入队列</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"-&gt;"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> k <span class="token operator">=</span> adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
			inDegree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>	<span class="token comment">//删除顶点，即此顶点可达的顶点入度都减1</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时，又有一个/多个顶点的入度为0，加入到队列中</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment">//时间复杂度就是O(V+E)（V表示顶点个数，E表示边的个数）</span>
</code></pre> 
<p>2.DFS算法 时间复杂度也是O(V+E)。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">topoSortByDFS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</span>
	<span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> inverseAdj<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//申请空间</span>
		inverseAdj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//通过邻接表生成逆邻接表  为什么这么转换</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i-&gt;w</span>
			inverseAdj<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// w-&gt;i</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//深度优先遍历图   </span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> inverseAdj<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> vertex<span class="token punctuation">,</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> inverseAdj<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inverseAdj<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> w <span class="token operator">=</span> inverseAdj<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
		visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> inverseAdj<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token comment">//先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"-&gt;"</span> <span class="token operator">+</span> vertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3、拓扑排序的应用：需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。<br> 实现拓扑排序的Kahn算法能检测图中环的存在，若果最后输出的顶点个数少于图中顶点个数，说明图中还有入度不是0的顶点，那就说明，图中存在环。<br> 这就是环的检测问题：(只需要记录已经访问过的用户ID，当用户ID第二次被访问的时候，就说明存在环)</p> 
<pre><code class="prism language-java"><span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> hashTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存已经访问过的actorId</span>
<span class="token keyword">long</span> <span class="token function">findRootReferrerId</span><span class="token punctuation">(</span><span class="token keyword">long</span> actorId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>hashTable<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>actorId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 存在环</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	hashTable<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>actorId<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Long</span> referrerId <span class="token operator">=</span> select referrer_id from <span class="token punctuation">[</span>table<span class="token punctuation">]</span> where actor_id <span class="token operator">=</span> actorId<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>referrerId <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> actorId<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token function">findRootReferrerId</span><span class="token punctuation">(</span>referrerId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果想知道数据库中所有用户之间的推荐关系，有没有存在环的情况，需要使用拓扑排序算法，我们把用户之间的推荐关系，从数据库中加载到内存中，然后构建成有向图的数据结构，再利用拓扑排序，就可以快速检测出是否存在环。</p> 
<h5><a id="146_DijkstraA_2978"></a>14.6、最短路径算法 (Dijkstra/A*)</h5> 
<p>建模：将地图抽象成具体的数据结构-图，把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边。这样，整个地图就被抽象成一个有向有权图。<br> 数据结构如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//有向有权图的邻接表表示</span>
	<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> adj<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//邻接表</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span> <span class="token comment">//顶点个数</span>
	<span class="token keyword">public</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>adj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//添加一条边</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> sid<span class="token punctuation">;</span> <span class="token comment">//边的起始顶点编号</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> tid<span class="token punctuation">;</span> <span class="token comment">//边的终止顶点编号</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> w<span class="token punctuation">;</span> 	<span class="token comment">//权重</span>
		<span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> sid<span class="token punctuation">,</span> <span class="token keyword">int</span> tid<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>sid <span class="token operator">=</span> sid<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>tid <span class="token operator">=</span> tid<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//下面这个类是为了dijkstra实现用的</span>
	<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Vertex</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span> <span class="token comment">//顶点编号ID</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> dist<span class="token punctuation">;</span> <span class="token comment">//从起始顶点到这个顶点的距离</span>
		<span class="token keyword">public</span> <span class="token class-name">Vertex</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span><span class="token keyword">int</span> dist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>dist <span class="token operator">=</span> dist<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>最短路径算法实现Dijkstra 时间复杂度是O(E*logV) E为所有边的个数，V表示顶点的个数<br> 思想：1、采用贪婪法：总是选取最接近源点的顶点；2、使用优先队列并按照到s的距离来存储未被访问过的顶点；3、不能用于权值为负的情况。<br> 具体而言：Dijkstra通过回溯穷举所有从s到达t的不同路径，在此基础上，利用动态规划的思想，对回溯搜索进行了剪枝，只保留起点到某个顶点的最短路径，继续往外扩展搜索，能得到最优解。</p> 
<pre><code class="prism language-java"><span class="token comment">// 因为Java提供的优先级队列，没有暴露更新数据的接口，所以我们需要重新实现一个</span>
<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 根据vertex.dist构建小顶堆</span>
<span class="token keyword">private</span> <span class="token class-name">Vertex</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodes<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vertex</span><span class="token punctuation">[</span>v<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">Vertex</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// TODO: 留给读者实现... }</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Vertex</span> vertex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// TODO: 留给读者实现...}</span>
<span class="token comment">// 更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)。</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Vertex</span> vertex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// TODO: 留给读者实现...}</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// TODO: 留给读者实现...}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 从顶点s到顶点t的最短路径</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> predecessor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//用来还原最短路径，用于它记录每个顶点的前驱顶点</span>
	<span class="token class-name">Vertex</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vertexes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vertex</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录从起始顶点到每个顶点的距离（dist），我们更新了某个顶点的dist值之后，如果这个顶点已经在优先级队列中，就不要再将它重复添加进去了</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		vertexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vertex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">PriorityQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 小顶堆</span>
	<span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inqueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 标记是否进入过队列</span>
	vertexes<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span>dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>vertexes<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	inqueue<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Vertex</span> minVertex<span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取堆顶元素并删除</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>minVertex<span class="token punctuation">.</span>id <span class="token operator">==</span> t<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 最短路径产生了</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>minVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Edge</span> e <span class="token operator">=</span> adj<span class="token punctuation">[</span>minVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取出一条minVetex相连的边</span>
			<span class="token class-name">Vertex</span> nextVertex <span class="token operator">=</span> vertexes<span class="token punctuation">[</span>e<span class="token punctuation">.</span>tid<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// minVertex--&gt;nextVertex</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>minVertex<span class="token punctuation">.</span>dist <span class="token operator">+</span> e<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> nextVertex<span class="token punctuation">.</span>dist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 更新next的dist</span>
				nextVertex<span class="token punctuation">.</span>dist <span class="token operator">=</span> minVertex<span class="token punctuation">.</span>dist <span class="token operator">+</span> e<span class="token punctuation">.</span>w<span class="token punctuation">;</span>
				predecessor<span class="token punctuation">[</span>nextVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> minVertex<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>inqueue<span class="token punctuation">[</span>nextVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					queue<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>nextVertex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新队列中的dist值</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
					inqueue<span class="token punctuation">[</span>nextVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 输出最短路径</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> predecessor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> predecessor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> t<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> predecessor<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> predecessor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"-&gt;"</span> <span class="token operator">+</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>实际的应用中，相比Dijkstra算法，地图软件更多的是A*启发式搜索算法</p> 
<ul><li> <p>实例2：在计算最短时间的出行路线中，如何获得通过某条路的时间呢？<br> 与时间相关的变量：1、路径长度；2、路况；3、拥堵情况；4、红绿灯个数，获取这些因素后就可以建立一个回归模型(如线性回归)来评估时间<br> 情况3是数据是动态的，可以通过与交通部门合作获得路段拥堵情况，联合其他导航软件获得该路段的在线人数</p> </li><li> <p>实例3：今天讲的出行路线问题，我假设的是开车出行，那如果是公交出行呢？如果混合地铁、公交、步行，又该如何规划路线呢？<br> 混合公交、地铁和步行时，地铁时刻表是固定的，容易估算。公交虽然没那么准时，大致时间是可以估计的，步行时间受路拥堵状况小，基本与道路长度成正比，也容易估算。总之，公交、地铁、步行，时间估算会比开车更容易，也更准确些。</p> </li><li> <p>实例4：翻译系统。只能针对单个词来做翻译。如果要翻译一整个句子，我们需要将句子拆成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度。我们希望计算出得分最高的前K个翻译结果。<br> 解答：使用Dijkstra最短路径算法</p> </li></ul> 
<h5><a id="147A_3085"></a>14.7、A*搜索算法(实现游戏中的寻路功能)</h5> 
<p>1、与Dijkstra算法的比较：Dijkstra类似BFS算法，它每次找到跟起点最近的顶点，往外扩展<br> 2、曼哈顿距离：两点之间横纵坐标的距离之和，计算过程只涉及加减法，符号位反转，比欧几里得距离高效<br> int hManhattan(Vertex v1, Vertex v2) { //Vertex表示顶点，后面有定义<br> return Math.abs(v1.x - v2.x) + Math.abs(v1.y - v2.y);<br> } //启发函数<br> 3、A*算法是对Dijkstra算法的简单改进</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Vertex</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span> <span class="token comment">//顶点编号ID</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> dist<span class="token punctuation">;</span> <span class="token comment">//从起始顶点，到这个顶点的距离，也就是g(i)</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> f<span class="token punctuation">;</span> <span class="token comment">//新增：f(i)=g(i)+h(i)</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> <span class="token comment">//新增：顶点在地图中的坐标（x, y）</span>
	<span class="token keyword">public</span> <span class="token class-name">Vertex</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>dist <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//Graph类的成员变量，在构造函数中初始化</span>
<span class="token class-name">Vertex</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vertexes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vertex</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//新增一个方法，添加顶点的坐标</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addVetex</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	vertexes<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vertex</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>与Dijkstra算法的三点区别：<br> 1、优先级队列构建的方式不同。A<em>算法是根据f值（也就是刚刚讲到的f(i)=g(i)+h(i)）来构建优先级队列，而Dijkstra算法是根据dist值（也就是刚刚讲到的g(i)）来构建优先级队列；<br> 2、A</em>算法在更新顶点dist值的时候，会同步更新f值；<br> 3、循环结束的条件也不一样。Dijkstra算法是在终点出队列的时候才结束，A<em>算法是一旦遍历到终点就结束。<br> (A</em>每次从f值最小的顶点出队列，一旦搜索到重点就不再继续考察其他顶点和路线，也就不可能找出最短路径)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">astar</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//从顶点s到顶点t的路径</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> predecessor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//用来还原路径</span>
	<span class="token comment">//按照vertex的f值构建的小顶堆，而不是按照dist</span>
	<span class="token class-name">PriorityQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inqueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//标记是否进入过队列</span>
	vertexes<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span>dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	vertexes<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>vertexes<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	inqueue<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Vertex</span> minVertex <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取堆顶元素并删除</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>minVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Edge</span> e <span class="token operator">=</span> adj<span class="token punctuation">[</span>minVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取出一条minVetex相连的边</span>
			<span class="token class-name">Vertex</span> nextVertex <span class="token operator">=</span> vertexes<span class="token punctuation">[</span>e<span class="token punctuation">.</span>tid<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//minVertex--&gt;nextVertex</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>minVertex<span class="token punctuation">.</span>dist <span class="token operator">+</span> e<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> nextVertex<span class="token punctuation">.</span>dist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//更新next的dist,f</span>
				nextVertex<span class="token punctuation">.</span>dist <span class="token operator">=</span> minVertex<span class="token punctuation">.</span>dist <span class="token operator">+</span> e<span class="token punctuation">.</span>w<span class="token punctuation">;</span>
				nextVertex<span class="token punctuation">.</span>f<span class="token operator">=</span> nextVertex<span class="token punctuation">.</span>dist<span class="token operator">+</span><span class="token function">hManhattan</span><span class="token punctuation">(</span>nextVertex<span class="token punctuation">,</span> vertexes<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关键之处，使用f(i)=g(i)+h(i)）来构建优先级队列</span>
				predecessor<span class="token punctuation">[</span>nextVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> minVertex<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token comment">//用于还原路径</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>inqueue<span class="token punctuation">[</span>nextVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					queue<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>nextVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextVertex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//入队</span>
					inqueue<span class="token punctuation">[</span>nextVertex<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>nextVertex<span class="token punctuation">.</span>id <span class="token operator">==</span> t<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//只要到达顶点t，就可以结束while了，no，这个地方王争搞错了</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//输出路径</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> predecessor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// print函数请参看Dijkstra算法的实现</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总结：A<em>算法属于一种启发式搜索算法，还有一些其他的同类型算法：IDA</em>算法、蚁群算法、模拟退火算法等<br> 启发式搜索算法利用估价函数，避免“跑偏”，贪心地朝着最有可能到达终点的方向前进，这种算法找出的路线，并不是最短路线，但是启发式搜索算法能很好地平衡路线质量和执行效率，<br> 它在实际的软件开发中的应用更加广泛。<br> 补充1：break的作用域</p> 
<pre><code class="prism language-java"><span class="token keyword">break</span> 跳出最近的｛｝包裹的代码，如果有标记，就跳出标记的｛｝
上述代码更正为：
<span class="token keyword">if</span><span class="token punctuation">(</span>nextVertex<span class="token punctuation">.</span>id<span class="token operator">==</span>t<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	queue<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="15bitmap_3165"></a>15、位图(bitmap)与推荐算法</h4> 
<ul><li>利用欧几里得公式计算俩用户听歌喜好的距离</li><li>头条的新闻推送，淘宝的猜你喜欢</li><li>bitmap(位图)与布隆过滤器</li></ul> 
<p>bitmap的数据结构：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BitMap</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> nbits<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">BitMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> nbits<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>nbits <span class="token operator">=</span> nbits<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>nbits<span class="token operator">/</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> nbits<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> byteIndex <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> bitIndex <span class="token operator">=</span> k <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">;</span>
		bytes<span class="token punctuation">[</span>byteIndex<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bitIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> nbits<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> byteIndex <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> bitIndex <span class="token operator">=</span> k <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">[</span>byteIndex<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bitIndex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>好处：如果用散列表存储着1千万的数据，数据时32位的整型数，也就是需要4字节的存储空间，那总共至少需要40MB的存储空间，如果我们通过位图的话，数字范围在1到1亿之间，<br> 只需要1亿个二进制位，也就是12MB左右的存储空间即可。</p> 
<h5><a id="151javautilBitSet_False_positive_3196"></a>15.1、什么是布隆过滤器，其实现原理是？（java.util的BitSet类，实现类位图） False positive指的是？（蚂蚁问到）</h5> 
<p>布隆过滤器是由一个很长的二进制向量(位图)加一系列随机映射函数(例如hash函数)组成。它可以用于检索一个元素是否在一个集合中。<br> 例如：我们把hash函数设计成f(x)=x%n,其中，x表示数字，n表示位图的大小(1亿)，也就是，对数字跟位图的大小进行取模求余。<br> hash函数的特殊设计：一个hash函数可能会存在冲突，那使用多个hash函数一块儿定义一个数据，我们把这K个数字作为位图中的下标，降低冲突的概率。当要查询某个数字是否存在的时候，我们用同样的K个哈希函数，对这个数字求哈希值，如果都是true，则说明，这个数字存在。(带来了新的缺点：容易误判)优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误判(即判断一个元素存在，可能被误判，而判断这个元素不存在，则一定不存在)和删除困难<br> 数据结构采用了bitmap 位图 解决缓存击穿的问题，有一个拦截机制，能迅速判断请求是否有效，他的内部维护了一系列合法有效的key，若是请求的元素在这个集合当中，说明请求有效。<br> false-positive (误检率)<br> 布隆过滤器有一定的误检率，即判断一个元素存在，可能被误判(例如布隆过滤器中只存在A和E，但是对B进行过滤时，刚好被定位到了A的上半部分和E的下半部分，被误判为存在)</p> 
<ul><li>应用：<br> 1、ip地址的布隆过滤器(比如统计一个大型网站的每天的UV数) 网页爬虫的url去重<br> 2、redis中的防止缓存穿透(使用bloomFilter来减轻系统负担)<br> 3、比特币(spv客户端访问full比特币客户端时，使用布隆过滤器进行拦截，减轻系统负担)<br> 4、分布式系统MapReduce中，使用布隆过滤器判断某个子任务是否存在某台机器上<br> 例子1：我们用布隆过滤器来记录已经爬取过的网页链接，假设需要判重的网页有10亿，那我们可以用一个10倍大小的位图来存储，也就是100亿个二进制位，换算成字节，<br> 那就是大约1.2GB。之前我们用散列表判重，需要至少100GB的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。<br> 例子2：假设我们有1亿个整数，数据范围是从1到10亿，如何快速并且省内存地给这1亿个数据从小到大排序？ <br> 传统的做法：1亿个整数，存储需要400M空间，排序时间复杂度最优 N×log(N)<br> 使用位图算法：数字范围是1到10亿，用位图存储125M就够了，然后将1亿个数字依次添加到位图中，然后再将位图按下标从小到大输出值为1的下标，排序就完成了，时间复杂度为 N</li></ul> 
<h5><a id="152_3214"></a>15.2、概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？</h5> 
<ul><li>1.基于黑名单的过滤器<br> ①布隆过滤器:如果我们要存储500万个手机号码，我们把位图大小设置为10倍数据大小，也就是5000万，那也只需要使用5000万个二进制位（5000万bits），换算成字节，<br> 也就是不到7MB的存储空间。比起散列表的解决方案，内存的消耗减少了很多。<br> ②我们可以把黑名单存储在服务器端上，把过滤和拦截的核心工作，交给服务器端来做。手机端只负责将要检查的号码发送给服务器端，服务器端通过查黑名单，<br> 判断这个号码是否应该被拦截，并将结果返回给手机端。网络传输的速度较慢(硬性要求：必须联网处理)</li><li>2.基于规则的过滤器<br> 前提：有大量的样本数据（比如1000万条短信），并且每条短信都做好了标记，它是垃圾短信还是非垃圾短信</li><li>3.基于概率统计的过滤器<br> 解决了基于规则的过滤器容易被绕过的缺陷。基于概率统计的基础理论是朴素贝叶斯算法(将一个未知概率的求解，分解成其他三个已知概率的求解)</li><li>总结：可以结合上述3点共同判断一条短信是否为垃圾短信<br> 评论中的观点：机器学习尤其是NLP方向的很多算法可用于anti-spam(反垃圾邮件)，判别式模型(logistic regression)效果通常好于生成式模式(naive-bayes),对于电话号码数字，正则或定时拉黑名单比ML模型简单可靠。</li></ul> 
<h5><a id="153_3227"></a>15.3、推荐系统</h5> 
<ul><li></ul> 
<blockquote> 
 <p>这里是引用</p> 
</blockquote> 
<p>原则：找到跟你口味偏好相似的用户，把他们爱听的歌曲推荐给你；找出跟你喜爱的歌曲特征相似的歌曲，把这些歌曲推荐给你<br> 1.基于相似用户做推荐(基于用户建模的协同过滤算法推荐)<br> 计算多维向量(用户对各首歌曲的喜爱程度作为向量)之间的距离，使用欧几里得计算公式<br> 2.基于相似歌曲做推荐<br> 针对每首歌曲，将每个用户的打分作为向量</p> 
<ul><li>弱点：<br> 1、稀疏性问题：当用户评价项目数少于中项目数时，就很容易造成评价矩阵相当稀疏，导致算法难以找到一个用户的偏好相似邻居。<br> 2、冷启动问题：基于用户协同过滤是建立在有大量用户对某个产品的评价上的，由于在新产品开始阶段没有人购买，也没有对其进行评价，那么在开始阶段也将无法对其进行推荐<br> 3、算法扩展性问题。随着物品数尤其是用户数的剧烈增加，最近邻居算法的计算量也相应增加，所以不太适合数据量大的情况使用，所以推荐系统性能也会大大受影响<br> 4、特殊用户问题。</li></ul> 
<hr> 
<h4><a id="16_3245"></a>16、断点续传思路和算法</h4> 
<p>在http头文件里面保存了content和content-type标签，用于记录传输文件的字节段。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e0fbaa01a68575b9c769ca0487db2567/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GL3510创维一路进四路出HUB芯片方案，扩展坞方案，资源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7fee03d28abb63fce79ee11f68072360/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TextView内容过多，超过n行显示“...全文”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>