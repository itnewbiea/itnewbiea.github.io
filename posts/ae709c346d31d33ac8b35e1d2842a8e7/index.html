<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>遗传算法超详细图解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="遗传算法超详细图解" />
<meta property="og:description" content="遗传算法（Genetic Algorithm）顾名思义，是一种基于自然选择原理和自然遗传机制的启发式搜索算法。该算法通过模拟自然界中生物遗传进化的自然机制（选择、交叉和变异操作），将好的遗传基因（最优目标）不断遗传给子代，使得后代产生最优解的概率增加（后代还是会有一些差的结果）。它的整个算法流程如下：
首先根据具体问题确定可行解域和编码方式，用数值串或字符串的形式表示可行解域中的每一个可行解；构建适应度函数度量每一解，该函数为非负函数；确定种群的大小、选择、交叉和变异的方式、交叉和变异的概率，判断终止条件（可以是某一阈值或者是指定进化的代数）。 在这个过程当中，交叉操作是优化的主要操作，而变异操作可以看成对种群的扰动。根据具体的问题我们构建适应度函数，并优化极值（可以是求最大值，也可以求最小值）。
名词解析 生物遗传概念在遗传算法中的对应关系如下：
生物遗传概念遗传算法中的作用适者生存算法停止时，最优目标值的解大概率被找到个体每个可行解染色体对每个可行解的编码基因可行解中的每个组成部分适应性适应度函数的函数值种群可行解域，根据适应度函数选择的一组解选择保留适应度函数的函数值优的解交叉将两个可行解内的组分随机交叉，产生新解变异随机变异可行解中的某些组分 算法步骤 我们还是以一个简单的例子来讲解整个算法的流程。比如，我们需要寻找函数y=x12&#43;x22&#43;x33&#43;x44在[1,30]之间的最大值。我们很容易就知道，当x1=x2=x3=x4=30时，该函数能取到最大值。
首先我们构建一个叫Gene的类：
1
2
3
4
class Gene:
def __init__(self, **data):
self.__dict__.update(data)
self.size = len(data[&#39;data&#39;]) # length of gene
这个类只有一个初始化方法，该方法就是获得基因里面的内容和大小，在这个例子中，内容就是[1,30]之间的任意4个数字组成的列表。
接着构建一个叫GA的类，这个类包括算法的所有操作方法：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
class GA:
def __init__(self, parameter):
pass
def evaluate(self, geneinfo):
pass
def selectBest(self, pop):
pass
def selection(self, individuals, k):
pass" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ae709c346d31d33ac8b35e1d2842a8e7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-18T09:24:55+08:00" />
<meta property="article:modified_time" content="2023-05-18T09:24:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">遗传算法超详细图解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://zh.wikipedia.org/zh-hans/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95" rel="nofollow" title="       遗传算法">       遗传算法</a>（Genetic Algorithm）顾名思义，是一种基于自然选择原理和自然遗传机制的启发式搜索算法。该算法通过模拟自然界中生物遗传进化的自然机制（<strong>选择、交叉和变异操作</strong>），将好的遗传基因（最优目标）不断遗传给子代，使得后代产生最优解的<strong>概率</strong>增加（后代还是会有一些差的结果）。它的整个算法流程如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/13/2b/9qjDbXlF_o.png"></p> 
<ol><li>首先根据具体问题确定可行解域和编码方式，用数值串或字符串的形式表示可行解域中的每一个可行解；</li><li>构建<strong>适应度函数</strong>度量每一解，该函数为非负函数；</li><li>确定种群的大小、选择、交叉和变异的方式、交叉和变异的概率，判断终止条件（可以是某一阈值或者是指定进化的代数）。</li></ol> 
<p>在这个过程当中，交叉操作是优化的主要操作，而变异操作可以看成对种群的扰动。根据具体的问题我们构建适应度函数，并优化极值（可以是求最大值，也可以求最小值）。</p> 
<h3>名词解析</h3> 
<p>生物遗传概念在遗传算法中的对应关系如下：</p> 
<table id="tablepress-66"><thead><tr><th>生物遗传概念</th><th>遗传算法中的作用</th></tr></thead><tbody><tr><td>适者生存</td><td>算法停止时，最优目标值的解大概率被找到</td></tr><tr><td>个体</td><td>每个可行解</td></tr><tr><td>染色体</td><td>对每个可行解的编码</td></tr><tr><td>基因</td><td>可行解中的每个组成部分</td></tr><tr><td>适应性</td><td>适应度函数的函数值</td></tr><tr><td>种群</td><td>可行解域，根据适应度函数选择的一组解</td></tr><tr><td>选择</td><td>保留适应度函数的函数值优的解</td></tr><tr><td>交叉</td><td>将两个可行解内的组分随机交叉，产生新解</td></tr><tr><td>变异</td><td>随机变异可行解中的某些组分</td></tr></tbody></table> 
<p> </p> 
<h3>算法步骤</h3> 
<p>我们还是以一个简单的例子来讲解整个算法的流程。比如，我们需要寻找函数<code>y=x12+x22+x33+x44</code>在<code>[1,30]</code>之间的最大值。我们很容易就知道，当<code>x1=x2=x3=x4=30</code>时，该函数能取到最大值。</p> 
<p>首先我们构建一个叫<code>Gene</code>的类：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p>class Gene:</p> <p>    def __init__(self, **data):</p> <p>        self.__dict__.update(data)</p> <p>        self.size = len(data['data'])  # length of gene</p> </td></tr></tbody></table> 
<p></p> 
<p>这个类只有一个初始化方法，该方法就是获得基因里面的内容和大小，在这个例子中，内容就是<code>[1,30]</code>之间的任意4个数字组成的列表。</p> 
<p>接着构建一个叫<code>GA</code>的类，这个类包括算法的所有操作方法：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> </td><td> <p>class GA:</p> <p>    def __init__(self, parameter):</p> <p>        pass</p> <p></p> <p>    def evaluate(self, geneinfo):</p> <p>        pass</p> <p></p> <p>    def selectBest(self, pop):</p> <p>        pass</p> <p></p> <p>    def selection(self, individuals, k):</p> <p>        pass</p> <p></p> <p>    def crossoperate(self, offspring):</p> <p>        pass</p> <p></p> <p>    def mutation(self, crossoff, bound):</p> <p>        pass</p> <p></p> <p>    def GA_main(self):</p> <p>        pass</p> </td></tr></tbody></table> 
<p></p> 
<p>使用<code>__init__()</code>方法初始化参数，包括自变量可取的最大值，最小值，种群大小，交叉率，变异率和繁殖代数；使用<code>evaluate()</code>方法作为适应度函数评估该个体的函数值，在这里就是函数<code>y</code>的值；使用<code>selectBest()</code>方法挑选出当前代种群中的最好个体作为历史记录；使用<code>selection()</code>方法按照概率从上一代种群中选择个体，直至形成新的一代；使用<code>crossoperate()</code>方法实现交叉操作；使用<code>mutation()</code>方法实现变异操作；使用<code>GA_main()</code>方法实现整个算法的循环。</p> 
<p>接下来我们会一一对其进行解析。</p> 
<h4>__init__()方法</h4> 
<p><code>__init__()</code>方法的代码如下：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> </td><td> <p>def __init__(self, parameter):</p> <p>    # parameter = [CXPB, MUTPB, NGEN, popsize, low, up]</p> <p>    self.parameter = parameter</p> <p>    low = self.parameter[4]</p> <p>    up = self.parameter[5]</p> <p>    self.bound = []</p> <p>    self.bound.append(low)</p> <p>    self.bound.append(up)</p> <p></p> <p>    pop = []</p> <p>    for i in range(self.parameter[3]):</p> <p>        geneinfo = []</p> <p>        for pos in range(len(low)):</p> <p>            geneinfo.append(random.randint(self.bound[0][pos], self.bound[1][pos]))  # initialise popluation</p> <p></p> <p>        fitness = self.evaluate(geneinfo)  # evaluate each chromosome</p> <p>        pop.append({'Gene': Gene(data=geneinfo), 'fitness': fitness})  # store the chromosome and its fitness</p> <p></p> <p>    self.pop = pop</p> <p>    self.bestindividual = self.selectBest(self.pop)  # store the best chromosome in the population</p> </td></tr></tbody></table> 
<p></p> 
<p>初始化方法接受传入的参数，包括最大值，最小值，种群大小，交叉率，变异率和繁殖代数。通过这些参数随机产生一个种群的列表<code>pop</code>作为首代种群，里面的每一条染色体是一个字典，该字典有两个内容，分别是包含基因的<code>Gene</code>类和适应度函数值<code>fitness</code>。</p> 
<h4>evaluate()方法</h4> 
<p>在初始化方法中，要用到适应度函数计算函数值，它的定义如下：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p>def evaluate(self, geneinfo):</p> <p>    x1 = geneinfo[0]</p> <p>    x2 = geneinfo[1]</p> <p>    x3 = geneinfo[2]</p> <p>    x4 = geneinfo[3]</p> <p>    y = x1**2 + x2**2 + x3**3 + x4**4</p> <p>    return y</p> </td></tr></tbody></table> 
<p></p> 
<h4>selectBest()方法</h4> 
<p>在初始化方法中，需要先将首代中最好的个体保留作为记录，它的定义如下：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p>def selectBest(self, pop):</p> <p>    s_inds = sorted(pop, key=itemgetter("fitness"), reverse=True)          # from large to small, return a pop</p> <p>    return s_inds[0]</p> </td></tr></tbody></table> 
<p></p> 
<p>对整个种群按照适应度函数从大到小排序，返回最大值的个体。</p> 
<h4>selection()方法</h4> 
<p>按照概率从上一代种群中选择个体，直至形成新的一代。我们需要适应度函数值大的个体被选择的概率大，可以使用轮盘赌选择法。该方法的步骤如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/dc/1a/v7aC3d7I_o.png"></p> 
<p>它的代码实现如下：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> </td><td> <p>def selection(self, individuals, k):</p> <p>    s_inds = sorted(individuals, key=itemgetter("fitness"),</p> <p>                    reverse=True)  # sort the pop by the reference of fitness</p> <p>    sum_fits = sum(ind['fitness'] for ind in individuals)  # sum up the fitness of the whole pop</p> <p></p> <p>    chosen = []</p> <p>    for i in range(k):</p> <p>        u = random.random() * sum_fits  # randomly produce a num in the range of [0, sum_fits], as threshold</p> <p>        sum_ = 0</p> <p>        for ind in s_inds:</p> <p>            sum_ += ind['fitness']  # sum up the fitness</p> <p>            if sum_ &gt;= u:</p> <p>                chosen.append(ind)</p> <p>                break</p> <p>    chosen = sorted(chosen, key=itemgetter("fitness"), reverse=False)</p> <p>    return chosen</p> </td></tr></tbody></table> 
<p></p> 
<p>在这里我们对种群按照概率进行选择后代，适应度函数大的个体大概率被选择到下一代，最后我们对重新生成的新一代种群按照适应度从小到大进行排序，方便接下来的交叉操作。</p> 
<h4>crossoperate()方法</h4> 
<p>交叉是指将两个个体的基因片段在某一点或者某几点进行互换，常用的有单点交叉和双点交叉。它的过程如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/84/f9/SQzAJeWj_o.png"></p> 
<p>从图中可以看出，无论是单点交叉还是双点交叉都很大的改变了原来的基因序列，它是实现优化的重要手段。具体的实现代码如下：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> </td><td> <p>def crossoperate(self, offspring):</p> <p>    dim = len(offspring[0]['Gene'].data)</p> <p></p> <p>    geninfo1 = offspring[0]['Gene'].data  # Gene's data of first offspring chosen from the selected pop</p> <p>    geninfo2 = offspring[1]['Gene'].data  # Gene's data of second offspring chosen from the selected pop</p> <p></p> <p>    if dim == 1:</p> <p>        pos1 = 1</p> <p>        pos2 = 1</p> <p>    else:</p> <p>        pos1 = random.randrange(1, dim)  # select a position in the range from 0 to dim-1,</p> <p>        pos2 = random.randrange(1, dim)</p> <p></p> <p>    newoff1 = Gene(data=[])  # offspring1 produced by cross operation</p> <p>    newoff2 = Gene(data=[])  # offspring2 produced by cross operation</p> <p>    temp1 = []</p> <p>    temp2 = []</p> <p>    for i in range(dim):</p> <p>        if min(pos1, pos2) &lt;= i &lt; max(pos1, pos2):</p> <p>            temp2.append(geninfo2[i])</p> <p>            temp1.append(geninfo1[i])</p> <p>        else:</p> <p>            temp2.append(geninfo1[i])</p> <p>            temp1.append(geninfo2[i])</p> <p>    newoff1.data = temp1</p> <p>    newoff2.data = temp2</p> <p></p> <p>    return newoff1, newoff2</p> </td></tr></tbody></table> 
<p></p> 
<p>上面的代码实现了双点交叉，其中为了防止只有一个基因的存在，我们使用一个判断语句。</p> 
<h4>mutation()方法</h4> 
<p>变异在遗传过程中属于小概率事件，但是在种群数量较小的情况下，只通过交叉操作并不能产生优秀的后代，此时变异就显得非常重要了。通过适当的变异甚至能够产生更优秀的后代。变异的方式有很多种，常规的变异有基本位变异和逆转变异。它的过程如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4c/f9/PMImsvv7_o.png"></p> 
<p>在这里我们实现单点变异：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> </td><td> <p>def mutation(self, crossoff, bound):</p> <p>    dim = len(crossoff.data)</p> <p></p> <p>    if dim == 1:</p> <p>        pos = 0</p> <p>    else:</p> <p>        pos = random.randrange(0, dim)  # chose a position in crossoff to perform mutation.</p> <p></p> <p>    crossoff.data[pos] = random.randint(bound[0][pos], bound[1][pos])</p> <p>    return crossoff</p> </td></tr></tbody></table> 
<p></p> 
<p>同样为了防止只有一个基因的情况，使用判断语句。</p> 
<h4>GA_main()方法</h4> 
<p>遗传算法所有的轮子都写好后，我们接下来将它们整合到流程中。代码实现如下：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> </td><td> <p>def GA_main(self):</p> <p>    popsize = self.parameter[3]</p> <p>    print("Start of evolution")</p> <p>    # Begin the evolution</p> <p>    for g in range(NGEN):</p> <p>        print("############### Generation {} ###############".format(g))</p> <p>        # Apply selection based on their converted fitness</p> <p>        selectpop = self.selection(self.pop, popsize)</p> <p>        nextoff = []</p> <p>        while len(nextoff) != popsize:</p> <p>            # Apply crossover and mutation on the offspring</p> <p>            # Select two individuals</p> <p>            offspring = [selectpop.pop() for _ in range(2)]</p> <p>            if random.random() &lt; CXPB:  # cross two individuals with probability CXPB</p> <p>                crossoff1, crossoff2 = self.crossoperate(offspring)</p> <p>                if random.random() &lt; MUTPB:  # mutate an individual with probability MUTPB</p> <p>                    muteoff1 = self.mutation(crossoff1, self.bound)</p> <p>                    muteoff2 = self.mutation(crossoff2, self.bound)</p> <p>                    fit_muteoff1 = self.evaluate(muteoff1.data)  # Evaluate the individuals</p> <p>                    fit_muteoff2 = self.evaluate(muteoff2.data)  # Evaluate the individuals</p> <p>                    nextoff.append({'Gene': muteoff1, 'fitness': fit_muteoff1})</p> <p>                    nextoff.append({'Gene': muteoff2, 'fitness': fit_muteoff2})</p> <p>                else:</p> <p>                    fit_crossoff1 = self.evaluate(crossoff1.data)  # Evaluate the individuals</p> <p>                    fit_crossoff2 = self.evaluate(crossoff2.data)</p> <p>                    nextoff.append({'Gene': crossoff1, 'fitness': fit_crossoff1})</p> <p>                    nextoff.append({'Gene': crossoff2, 'fitness': fit_crossoff2})</p> <p>            else:</p> <p>                nextoff.extend(offspring)</p> <p></p> <p>        # The population is entirely replaced by the offspring</p> <p>        self.pop = nextoff</p> <p></p> <p>        # Gather all the fitnesses in one list and print the stats</p> <p>        fits = [ind['fitness'] for ind in self.pop]</p> <p></p> <p>        best_ind = self.selectBest(self.pop)</p> <p></p> <p>        if best_ind['fitness'] &gt; self.bestindividual['fitness']:</p> <p>            self.bestindividual = best_ind</p> <p></p> <p>        print("Best individual found is {}, {}".format(self.bestindividual['Gene'].data,</p> <p>                                                       self.bestindividual['fitness']))</p> <p>        print("  Max fitness of current pop: {}".format(max(fits)))</p> <p></p> <p>    print("------ End of (successful) evolution ------")</p> </td></tr></tbody></table> 
<p></p> 
<p>在这个流程当中需要注意的是，经过<code>selection()</code>方法产生的新种群<code>selectpop</code>是按照适应度从小到大排列的，通过列表的<code>pop()</code>方法能够优先选择适应度大的两个个体进行后续的交叉操作；因为是<code>pop()</code>两次，所以种群的大小必须是偶数个。</p> 
<p>完整代码如下：</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> <p>70</p> <p>71</p> <p>72</p> <p>73</p> <p>74</p> <p>75</p> <p>76</p> <p>77</p> <p>78</p> <p>79</p> <p>80</p> <p>81</p> <p>82</p> <p>83</p> <p>84</p> <p>85</p> <p>86</p> <p>87</p> <p>88</p> <p>89</p> <p>90</p> <p>91</p> <p>92</p> <p>93</p> <p>94</p> <p>95</p> <p>96</p> <p>97</p> <p>98</p> <p>99</p> <p>100</p> <p>101</p> <p>102</p> <p>103</p> <p>104</p> <p>105</p> <p>106</p> <p>107</p> <p>108</p> <p>109</p> <p>110</p> <p>111</p> <p>112</p> <p>113</p> <p>114</p> <p>115</p> <p>116</p> <p>117</p> <p>118</p> <p>119</p> <p>120</p> <p>121</p> <p>122</p> <p>123</p> <p>124</p> <p>125</p> <p>126</p> <p>127</p> <p>128</p> <p>129</p> <p>130</p> <p>131</p> <p>132</p> <p>133</p> <p>134</p> <p>135</p> <p>136</p> <p>137</p> <p>138</p> <p>139</p> <p>140</p> <p>141</p> <p>142</p> <p>143</p> <p>144</p> <p>145</p> <p>146</p> <p>147</p> <p>148</p> <p>149</p> <p>150</p> <p>151</p> <p>152</p> <p>153</p> <p>154</p> <p>155</p> <p>156</p> <p>157</p> <p>158</p> <p>159</p> <p>160</p> <p>161</p> <p>162</p> <p>163</p> <p>164</p> <p>165</p> <p>166</p> <p>167</p> <p>168</p> <p>169</p> <p>170</p> <p>171</p> <p>172</p> <p>173</p> <p>174</p> <p>175</p> <p>176</p> <p>177</p> <p>178</p> <p>179</p> <p>180</p> <p>181</p> <p>182</p> <p>183</p> <p>184</p> <p>185</p> <p>186</p> <p>187</p> <p>188</p> <p>189</p> <p>190</p> <p>191</p> <p>192</p> <p>193</p> <p>194</p> <p>195</p> <p>196</p> <p>197</p> <p>198</p> <p>199</p> <p>200</p> <p>201</p> <p>202</p> <p>203</p> <p>204</p> <p>205</p> <p>206</p> <p>207</p> <p>208</p> <p>209</p> <p>210</p> <p>211</p> <p>212</p> <p>213</p> <p>214</p> <p>215</p> </td><td> <p>import random</p> <p>from operator import itemgetter</p> <p></p> <p></p> <p>class Gene:</p> <p>    """</p> <p>    This is a class to represent individual(Gene) in GA algorithom</p> <p>    each object of this class have two attribute: data, size</p> <p>    """</p> <p>    def __init__(self, **data):</p> <p>        self.__dict__.update(data)</p> <p>        self.size = len(data['data'])  # length of gene</p> <p></p> <p></p> <p>class GA:</p> <p>    """</p> <p>    This is a class of GA algorithm.</p> <p>    """</p> <p></p> <p>    def __init__(self, parameter):</p> <p>        """</p> <p>        Initialize the pop of GA algorithom and evaluate the pop by computing its' fitness value.</p> <p>        The data structure of pop is composed of several individuals which has the form like that:</p> <p></p> <p></p> <p>        {'Gene':a object of class Gene, 'fitness': 1.02(for example)}</p> <p>        Representation of Gene is a list: [b s0 u0 sita0 s1 u1 sita1 s2 u2 sita2]</p> <p></p> <p>        """</p> <p>        # parameter = [CXPB, MUTPB, NGEN, popsize, low, up]</p> <p>        self.parameter = parameter</p> <p></p> <p>        low = self.parameter[4]</p> <p>        up = self.parameter[5]</p> <p></p> <p>        self.bound = []</p> <p>        self.bound.append(low)</p> <p>        self.bound.append(up)</p> <p></p> <p>        pop = []</p> <p>        for i in range(self.parameter[3]):</p> <p>            geneinfo = []</p> <p>            for pos in range(len(low)):</p> <p>                geneinfo.append(random.randint(self.bound[0][pos], self.bound[1][pos]))  # initialise popluation</p> <p></p> <p>            fitness = self.evaluate(geneinfo)  # evaluate each chromosome</p> <p>            pop.append({'Gene': Gene(data=geneinfo), 'fitness': fitness})  # store the chromosome and its fitness</p> <p></p> <p>        self.pop = pop</p> <p>        self.bestindividual = self.selectBest(self.pop)  # store the best chromosome in the population</p> <p></p> <p>    def evaluate(self, geneinfo):</p> <p>        """</p> <p>        fitness function</p> <p>        """</p> <p>        x1 = geneinfo[0]</p> <p>        x2 = geneinfo[1]</p> <p>        x3 = geneinfo[2]</p> <p>        x4 = geneinfo[3]</p> <p>        y = x1**2 + x2**2 + x3**3 + x4**4</p> <p>        return y</p> <p></p> <p>    def selectBest(self, pop):</p> <p>        """</p> <p>        select the best individual from pop</p> <p>        """</p> <p>        s_inds = sorted(pop, key=itemgetter("fitness"), reverse=True)          # from large to small, return a pop</p> <p>        return s_inds[0]</p> <p></p> <p>    def selection(self, individuals, k):</p> <p>        """</p> <p>        select some good individuals from pop, note that good individuals have greater probability to be choosen</p> <p>        for example: a fitness list like that:[5, 4, 3, 2, 1], sum is 15,</p> <p>        [-----|----|---|--|-]</p> <p>        012345|6789|101112|1314|15</p> <p>        we randomly choose a value in [0, 15],</p> <p>        it belongs to first scale with greatest probability</p> <p>        """</p> <p>        s_inds = sorted(individuals, key=itemgetter("fitness"),</p> <p>                        reverse=True)  # sort the pop by the reference of fitness</p> <p></p> <p>        sum_fits = sum(ind['fitness'] for ind in individuals)  # sum up the fitness of the whole pop</p> <p></p> <p>        chosen = []</p> <p>        for i in range(k):</p> <p>            u = random.random() * sum_fits  # randomly produce a num in the range of [0, sum_fits], as threshold</p> <p>            sum_ = 0</p> <p>            for ind in s_inds:</p> <p>                sum_ += ind['fitness']  # sum up the fitness</p> <p>                if sum_ &gt;= u:</p> <p>                    # when the sum of fitness is bigger than u, choose the one, which means u is in the range of</p> <p>                    # [sum(1,2,...,n-1),sum(1,2,...,n)] and is time to choose the one ,namely n-th individual in the pop</p> <p>                    chosen.append(ind)</p> <p>                    break</p> <p>        # from small to large, due to list.pop() method get the last element</p> <p>        chosen = sorted(chosen, key=itemgetter("fitness"), reverse=False)</p> <p>        return chosen</p> <p></p> <p>    def crossoperate(self, offspring):</p> <p>        """</p> <p>        cross operation</p> <p>        here we use two points crossoperate</p> <p>        for example: gene1: [5, 2, 4, 7], gene2: [3, 6, 9, 2], if pos1=1, pos2=2</p> <p>        5 | 2 | 4  7</p> <p>        3 | 6 | 9  2</p> <p>        =</p> <p>        3 | 2 | 9  2</p> <p>        5 | 6 | 4  7</p> <p>        """</p> <p>        dim = len(offspring[0]['Gene'].data)</p> <p></p> <p>        geninfo1 = offspring[0]['Gene'].data  # Gene's data of first offspring chosen from the selected pop</p> <p>        geninfo2 = offspring[1]['Gene'].data  # Gene's data of second offspring chosen from the selected pop</p> <p></p> <p>        if dim == 1:</p> <p>            pos1 = 1</p> <p>            pos2 = 1</p> <p>        else:</p> <p>            pos1 = random.randrange(1, dim)  # select a position in the range from 0 to dim-1,</p> <p>            pos2 = random.randrange(1, dim)</p> <p></p> <p>        newoff1 = Gene(data=[])  # offspring1 produced by cross operation</p> <p>        newoff2 = Gene(data=[])  # offspring2 produced by cross operation</p> <p>        temp1 = []</p> <p>        temp2 = []</p> <p>        for i in range(dim):</p> <p>            if min(pos1, pos2) &lt;= i &lt; max(pos1, pos2):</p> <p>                temp2.append(geninfo2[i])</p> <p>                temp1.append(geninfo1[i])</p> <p>            else:</p> <p>                temp2.append(geninfo1[i])</p> <p>                temp1.append(geninfo2[i])</p> <p>        newoff1.data = temp1</p> <p>        newoff2.data = temp2</p> <p></p> <p>        return newoff1, newoff2</p> <p></p> <p>    def mutation(self, crossoff, bound):</p> <p>        """</p> <p>        mutation operation</p> <p>        """</p> <p>        dim = len(crossoff.data)</p> <p></p> <p>        if dim == 1:</p> <p>            pos = 0</p> <p>        else:</p> <p>            pos = random.randrange(0, dim)  # chose a position in crossoff to perform mutation.</p> <p></p> <p>        crossoff.data[pos] = random.randint(bound[0][pos], bound[1][pos])</p> <p>        return crossoff</p> <p></p> <p>    def GA_main(self):</p> <p>        """</p> <p>        main frame work of GA</p> <p>        """</p> <p>        popsize = self.parameter[3]</p> <p></p> <p>        print("Start of evolution")</p> <p></p> <p>        # Begin the evolution</p> <p>        for g in range(NGEN):</p> <p></p> <p>            print("############### Generation {} ###############".format(g))</p> <p></p> <p>            # Apply selection based on their converted fitness</p> <p>            selectpop = self.selection(self.pop, popsize)</p> <p></p> <p>            nextoff = []</p> <p>            while len(nextoff) != popsize:</p> <p>                # Apply crossover and mutation on the offspring</p> <p></p> <p>                # Select two individuals</p> <p>                offspring = [selectpop.pop() for _ in range(2)]</p> <p></p> <p>                if random.random() &lt; CXPB:  # cross two individuals with probability CXPB</p> <p>                    crossoff1, crossoff2 = self.crossoperate(offspring)</p> <p>                    if random.random() &lt; MUTPB:  # mutate an individual with probability MUTPB</p> <p>                        muteoff1 = self.mutation(crossoff1, self.bound)</p> <p>                        muteoff2 = self.mutation(crossoff2, self.bound)</p> <p>                        fit_muteoff1 = self.evaluate(muteoff1.data)  # Evaluate the individuals</p> <p>                        fit_muteoff2 = self.evaluate(muteoff2.data)  # Evaluate the individua</p> 
    <table><tbody><tr><td> <p>nextoff.append({'Gene': muteoff1, 'fitness': fit_muteoff1})</p> <p>                        nextoff.append({'Gene': muteoff2, 'fitness': fit_muteoff2})</p> <p>                    else:</p> <p>                        fit_crossoff1 = self.evaluate(crossoff1.data)  # Evaluate the individuals</p> <p>                        fit_crossoff2 = self.evaluate(crossoff2.data)</p> <p>                        nextoff.append({'Gene': crossoff1, 'fitness': fit_crossoff1})</p> <p>                        nextoff.append({'Gene': crossoff2, 'fitness': fit_crossoff2})</p> <p>                else:</p> <p>                    nextoff.extend(offspring)</p> <p></p> <p>            # The population is entirely replaced by the offspring</p> <p>            self.pop = nextoff</p> <p></p> <p>            # Gather all the fitnesses in one list and print the stats</p> <p>            fits = [ind['fitness'] for ind in self.pop]</p> <p></p> <p>            best_ind = self.selectBest(self.pop)</p> <p></p> <p>            if best_ind['fitness'] &gt; self.bestindividual['fitness']:</p> <p>                self.bestindividual = best_ind</p> <p></p> <p>            print("Best individual found is {}, {}".format(self.bestindividual['Gene'].data,</p> <p>                                                           self.bestindividual['fitness']))</p> <p>            print("  Max fitness of current pop: {}".format(max(fits)))</p> <p class="img-center"><img alt="" src="https://images2.imgbox.com/ae/c7/9bhs2tyR_o.png"></p> <p></p> <p>        print("------ End of (successful) evolution ------")</p> <p></p> <p></p> <p>if __name__ == "__main__":</p> <p>    CXPB, MUTPB, NGEN, popsize = 0.8, 0.1, 1000, 100  # popsize must be even number</p> <p></p> <p>    up = [30, 30, 30, 30]  # upper range for variables</p> <p>    low = [1, 1, 1, 1]  # lower range for variables</p> <p>    parameter = [CXPB, MUTPB, NGEN, popsize, low, up]</p> <p>    run = GA(parameter)</p> <p>    run.GA_main()</p> </td></tr></tbody></table><p></p> <p>在<code>if __name__ == "__main__":</code>语句后面，我们设定所有的参数。在这里交叉概率CXPB为0.8，变异概率MUTPB为0.1，总共跑NGEN=1000代，每代的种群大小为100。</p> <p>得到结果如下：</p> <p>事实上按照目前的参数，在第342代的时候已经找到最优解。如果使用枚举法需要30*30*30*30=810000次才能寻找到最优解，通过遗传算法只计算了34200次，大大缩短最优解的搜索空间。</p> <p>参考：<a href="https://finthon.com/python-genetic-algorithm/" rel="nofollow" title="Python手把手构建遗传算法（GA）实现最优化搜索 - FINTHON">Python手把手构建遗传算法（GA）实现最优化搜索 - FINTHON</a></p> <p> </p> </td></tr></tbody></table>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/87a7474490d14e1dee9a7e2f9a3b278c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker相关命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/642276edf355df04227c546987890092/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot整合MyBatis-Plus实现增删改查</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>