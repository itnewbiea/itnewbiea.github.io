<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（操作系统）模拟操作系统的页面置换 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（操作系统）模拟操作系统的页面置换" />
<meta property="og:description" content="一、 需求分析
设计程序模拟先进先出（FIFO）置换算法，最佳（OPT）置换算法和最近最少用（LRU）置换算法的工作过程。假设内存中分配给每个进程的最小物理块数为m，在进程运行过程中要访问的页面个数为n，页面访问序列为P1, … ,Pn，分别利用不同的页面置换算法调度进程的页面访问序列，给出页面访问序列的置换过程，计算每种算法缺页次数和缺页率。
程序的设计主要是测试先进先出FIFO，最佳置换OPT和最近最少用LRU页面置换算法的效率以及过程，对于程序员设计有很多帮助，不同的场合用不同的算法可以提高程序的效率。
二、详细设计
1、数据结构
int a[320];//存放320条指令
int p;//存放页大小
int page[320];//存放合并后要使用的页号
int PageNumber;//存放页号数量
int piece;//存放块数
2、算法流程图
a.先进先出（FIFO）置换算法:
b.最近最少用（LRU）置换算法:
c.最佳（OPT）置换算法:
三、 软件测试 1、如图一所示，通过随机数产生一个指令序列，共320条指令。指令的地址按下述原则生成：
A：50%的指令是顺序执行的 B：25%的指令是均匀分布在前地址部分 C：25%的指令是均匀分布在后地址部分 具体的实施方法是： A：在[0，319]的指令地址之间随机选取一起点m B：顺序执行一条指令，即执行地址为m&#43;1 的指令 C：在前地址[0,m&#43;1]中随机选取一条指令并执行，该指令的地址为m&#39; D：顺序执行一条指令，其地址为m&#39;&#43;1 E：在后地址[m&#39;&#43;2，319]中随机选取一条指令并执行 F：重复步骤A-E，直到320 次指令
图1.指令地址
2、如图2所示，页面大小的取值范围为1K，2K，4K，8K，16K。按照页面大小将指令地址转化化为页号。对于相邻相同的页号，合并为一个。
图2.合并后的页地址流
3.选择不同的块数和不同的页面置换算法会得出不同的缺页率，为了方便观察比较，下面选取相同的块数（4块）和不同的页面置换算法，求出缺页率。如图3-a，3-b，3-c所示：
图3-a.最佳置换算法（节选）
三、 总结
本次实验主要用DOS界面实现模拟操作系统的页面置换功能。在本次实验中，没有用到MFC界面，使得实验数据冗长，不过也更能直观反应是否缺页，便于统计。实现先进先出、最近最少用和最佳置换算法时候，一开始的思路都有初始化进入内存块数的页数的函数，后来再次看的时候发现太冗长而且没有这个必要。
附：源程序
//PageReplacement.cpp
#include&lt;iostream&gt;
#include&lt;time.h&gt;
#include&lt;iomanip&gt;
#include&#34;FIFO.h&#34;
#include&#34;LRU.h&#34;
#include&#34;OPT.h&#34;
using namespace std;
void Random(int a[],int n);
int Translate(int a[],int Page[],intn,int p);
int main()
{
inta[320];//存放320条指令" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/63becc3119a93cc5e451f792c3e63eea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-03-06T23:21:54+08:00" />
<meta property="article:modified_time" content="2015-03-06T23:21:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（操作系统）模拟操作系统的页面置换</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一、   需求分析</strong></p> 
<p>设计程序模拟先进先出（FIFO）置换算法，最佳（OPT）置换算法和最近最少用（LRU）置换算法的工作过程。假设内存中分配给每个进程的最小物理块数为m，在进程运行过程中要访问的页面个数为n，页面访问序列为P1, … ,Pn，分别利用不同的页面置换算法调度进程的页面访问序列，给出页面访问序列的置换过程，计算每种算法缺页次数和缺页率。</p> 
<p>程序的设计主要是测试先进先出FIFO，最佳置换OPT和最近最少用LRU页面置换算法的效率以及过程，对于程序员设计有很多帮助，不同的场合用不同的算法可以提高程序的效率。</p> 
<p><strong>二、详细设计</strong></p> 
<p>1、数据结构</p> 
<p align="left">   int a[320];//存放320条指令</p> 
<p align="left">   int p;//存放页大小</p> 
<p align="left">   int page[320];//存放合并后要使用的页号</p> 
<p align="left">   int PageNumber;//存放页号数量</p> 
<p align="left">   int piece;//存放块数</p> 
<p align="left">2、算法流程图</p> 
<p>a.先进先出（FIFO）置换算法:</p> 
<p><img src="https://images2.imgbox.com/f8/18/xZ7dv2Yb_o.jpg" alt=""><br> </p> 
<p></p> 
<p align="left">b.最近最少用（LRU）置换算法:</p> 
<img src="https://images2.imgbox.com/6a/80/BQ2eWeu1_o.png" alt=""> 
<br> 
<p></p> 
<p align="left">c.最佳（OPT）置换算法:</p> 
<p><img src="https://images2.imgbox.com/85/1f/86oSfPNQ_o.jpg" alt=""><br> </p> 
<p></p> 
<p align="left"><strong>三、 软件测试              </strong></p> 
<p align="left">1、如图一所示，通过随机数产生一个指令序列，共320条指令。指令的地址按下述原则生成：</p> 
<p align="left">A：50%的指令是顺序执行的 </p> 
<p align="left">B：25%的指令是均匀分布在前地址部分 </p> 
<p align="left">C：25%的指令是均匀分布在后地址部分 </p> 
<p align="left">具体的实施方法是： </p> 
<p align="left">A：在[0，319]的指令地址之间随机选取一起点m </p> 
<p align="left">B：顺序执行一条指令，即执行地址为m+1 的指令 </p> 
<p align="left">C：在前地址[0,m+1]中随机选取一条指令并执行，该指令的地址为m' </p> 
<p align="left">D：顺序执行一条指令，其地址为m'+1 </p> 
<p align="left">E：在后地址[m'+2，319]中随机选取一条指令并执行 F：重复步骤A-E，直到320 次指令</p> 
<img src="https://images2.imgbox.com/98/05/kDIfIsGo_o.png" alt=""> 
<br> 
<p></p> 
<p align="center"><strong>图1.指令地址</strong></p> 
<p align="left">2、如图2所示，页面大小的取值范围为1K，2K，4K，8K，16K。按照页面大小将指令地址转化化为页号。对于相邻相同的页号，合并为一个。</p> 
<p><img src="https://images2.imgbox.com/94/39/HW3K4TrQ_o.png" alt=""><br> </p> 
<p></p> 
<p align="center"><strong>图2.合并后的页地址流</strong></p> 
<p align="left">3.选择不同的块数和不同的页面置换算法会得出不同的缺页率，为了方便观察比较，下面选取相同的块数（4块）和不同的页面置换算法，求出缺页率。如图3-a，3-b，3-c所示：</p> 
<img src="https://images2.imgbox.com/0c/6b/vvu5w1P4_o.png" alt=""> 
<br> 
<p></p> 
<p align="center"><strong>图3-a.最佳置换算法（节选）</strong></p> 
<p align="left"><strong>三、 总结</strong></p> 
<p align="left">本次实验主要用DOS界面实现模拟操作系统的页面置换功能。在本次实验中，没有用到MFC界面，使得实验数据冗长，不过也更能直观反应是否缺页，便于统计。实现先进先出、最近最少用和最佳置换算法时候，一开始的思路都有初始化进入内存块数的页数的函数，后来再次看的时候发现太冗长而且没有这个必要。</p> 
<p align="left"><strong>附：源程序</strong></p> 
<p align="left">//PageReplacement.cpp</p> 
<p align="left">#include&lt;iostream&gt;</p> 
<p align="left">#include&lt;time.h&gt;</p> 
<p align="left">#include&lt;iomanip&gt;</p> 
<p align="left">#include"FIFO.h"</p> 
<p align="left">#include"LRU.h"</p> 
<p align="left">#include"OPT.h"</p> 
<p align="left">using namespace std;</p> 
<p align="left">void Random(int a[],int n);</p> 
<p align="left">int Translate(int a[],int Page[],intn,int p);</p> 
<p align="left">int main()</p> 
<p align="left">{<!-- --></p> 
<p align="left">    inta[320];//存放320条指令</p> 
<p align="left">    inti=1;</p> 
<p align="left">    intp;//存放页大小</p> 
<p align="left">    intpage[320];//存放合并后要使用的页号</p> 
<p align="left">    intPageNumber;//存放页号数量</p> 
<p align="left">    intpiece;//存放块数</p> 
<p align="left">    boolflag=true;</p> 
<p align="left">    while(flag)</p> 
<p align="left">    {<!-- --></p> 
<p align="left">    switch(i)</p> 
<p align="left">    {<!-- --></p> 
<p align="left">    case1:</p> 
<p align="left">    Random(a,320);</p> 
<p align="left">    case2:</p> 
<p align="left">    cout&lt;&lt;"请输入页大小（1K、2K、4K、8K、16K、）：";</p> 
<p align="left">    cin&gt;&gt;p;</p> 
<p align="left">    PageNumber=Translate(a,page,320,p);</p> 
<p align="left">    cout&lt;&lt;"将相邻相同的页号合并为一个后要使用到的页号数为"&lt;&lt;PageNumber&lt;&lt;"个"&lt;&lt;endl;</p> 
<p align="left">    case3:</p> 
<p align="left">    cout&lt;&lt;"请输入块数（1~"&lt;&lt;32/p&lt;&lt;"）：";</p> 
<p align="left">    cin&gt;&gt;piece;</p> 
<p align="left">    case4:</p> 
<p align="left">    cout&lt;&lt;"请选择页面置换算法(1~3)"&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"1.最佳置换算法（OPT)"&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"2.先进先出置换算法（FIFO）"&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"3.最近最少用置换算法（LRU）"&lt;&lt;endl;</p> 
<p align="left">    cin&gt;&gt;i;</p> 
<p align="left">    switch(i)</p> 
<p align="left">    {<!-- --></p> 
<p align="left">    case1:OPT(page,PageNumber,piece,32/p);break;</p> 
<p align="left">    case2:FIFO(page,PageNumber,piece,32/p);break;</p> 
<p align="left">   case 3:LRU(page,PageNumber,piece,32/p);break;</p> 
<p align="left">    default:cout&lt;&lt;"输入有误"&lt;&lt;endl;break;</p> 
<p align="left">    }</p> 
<p align="left">    cout&lt;&lt;"*****************************"&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"*****1.重新开始"&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"*****2.返回重新输入页大小"&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"*****3.返回重新输入块数"&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"*****4.返回重新选择页面置换算法"&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"*****5.结束程序"&lt;&lt;endl;</p> 
<p align="left">    cin&gt;&gt;i;break;</p> 
<p align="left">    default:flag=false;</p> 
<p align="left">    }</p> 
<p align="left">    }</p> 
<p align="left">    return0;</p> 
<p align="left">}</p> 
<p align="left">void Random(int a[],int n)</p> 
<p align="left">{<!-- --></p> 
<p align="left">    cout&lt;&lt;"指令如下："&lt;&lt;endl;</p> 
<p align="left">    intm,i=0;</p> 
<p align="left">    srand(unsignedint(time(NULL)));</p> 
<p align="left">    while(i&lt;n)</p> 
<p align="left">    {<!-- --></p> 
<p align="left">       a[i++]=rand()%n;</p> 
<p align="left">       m=a[i]=a[i-1]+1;</p> 
<p align="left">       a[++i]=rand()%(m+1);</p> 
<p align="left">       i++;</p> 
<p align="left">       m=a[i]=a[i-1]+1;</p> 
<p align="left">       a[++i]=rand()%(n-m+1)+m+1;</p> 
<p align="left">       i++;</p> 
<p align="left">    }</p> 
<p align="left">    for(i=0;i&lt;n;i++)</p> 
<p align="left">    {<!-- --></p> 
<p align="left">       cout&lt;&lt;a[i]&lt;&lt;setw(4);</p> 
<p align="left">       if((i+1)%10==0)</p> 
<p align="left">           cout&lt;&lt;endl;</p> 
<p align="left">    }</p> 
<p align="left">    cout&lt;&lt;endl;</p> 
<p align="left">}</p> 
<p align="left">int Translate(int a[],int Page[],intn,int p)</p> 
<p align="left">{<!-- --></p> 
<p align="left">    cout&lt;&lt;"页面调度序列如下："&lt;&lt;endl;</p> 
<p align="left">    inti,j=0;</p> 
<p align="left">    inttemp=-1,result;</p> 
<p align="left">    for(i=0;i&lt;n;i++)</p> 
<p align="left">    {<!-- --></p> 
<p align="left">       result=a[i]/(p*10);</p> 
<p align="left">       if(result!=temp)</p> 
<p align="left">           temp=Page[j++]=result;</p> 
<p align="left">    }</p> 
<p align="left">    for(i=0;i&lt;j;i++)</p> 
<p align="left">    {<!-- --></p> 
<p align="left">       cout&lt;&lt;Page[i]&lt;&lt;setw(4);</p> 
<p align="left">       if((i+1)%10==0)</p> 
<p align="left">           cout&lt;&lt;endl;</p> 
<p align="left">    }</p> 
<p align="left">    cout&lt;&lt;endl;</p> 
<p align="left">    returnj;</p> 
<p align="left">}</p> 
<p align="left"> </p> 
<p align="left">.\FIFO.H</p> 
<p align="left">//先进先出置换算法</p> 
<p align="left">#include&lt;iostream&gt;</p> 
<p align="left">#include&lt;iomanip&gt;</p> 
<p align="left">using namespace std;</p> 
<p align="left">//输出函数</p> 
<p align="left">void Output1(int *p,int n)</p> 
<p align="left">{<!-- --></p> 
<p align="left">    for(inti=0;i&lt;n;i++)</p> 
<p align="left">       cout&lt;&lt;p[i]&lt;&lt;setw(4);</p> 
<p align="left">}</p> 
<p align="left">void FIFO(int Page[],int n,intpiece,int total)</p> 
<p align="left">{<!-- --></p> 
<p align="left">    inti,number=0,j,position=0;</p> 
<p align="left">    intrate=0;</p> 
<p align="left">    int*p=new int [piece];</p> 
<p align="left">    for(i=0;i&lt;piece;i++)</p> 
<p align="left">       p[i]=-1;//内存块数赋初值</p> 
<p align="left">       for(i=0;i&lt;n;i++)</p> 
<p align="left">       {<!-- --></p> 
<p align="left">           cout&lt;&lt;i+1&lt;&lt;"";</p> 
<p align="left">           cout&lt;&lt;Page[i]&lt;&lt;":"&lt;&lt;setw(4);</p> 
<p align="left">           for(j=0;j&lt;piece&amp;&amp;p[j]!=Page[i];j++)//查找是否缺页</p> 
<p align="left">              ;</p> 
<p align="left">           if(p[j]==Page[i])</p> 
<p align="left">           {<!-- --></p> 
<p align="left">              Output1(p,piece);</p> 
<p align="left">              cout&lt;&lt;"不缺页"&lt;&lt;endl;</p> 
<p align="left">           }</p> 
<p align="left">           else</p> 
<p align="left">           {<!-- --></p> 
<p align="left">              rate++;</p> 
<p align="left">              for(j=0;j&lt;piece-1;j++)//缺页处理</p> 
<p align="left">                  p[j]=p[j+1];</p> 
<p align="left">              p[j]=Page[i];</p> 
<p align="left">              Output1(p,piece);</p> 
<p align="left">              cout&lt;&lt;"缺页"&lt;&lt;endl;</p> 
<p align="left">           }</p> 
<p align="left">       }</p> 
<p align="left">       cout&lt;&lt;"缺页次数："&lt;&lt;rate&lt;&lt;""&lt;&lt;"总数"&lt;&lt;n&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"先进先出置换算法（FIFO）缺页率为"&lt;&lt;(double)rate/n*100&lt;&lt;"%"&lt;&lt;endl;</p> 
<p align="left">    delete[]p;</p> 
<p align="left">}</p> 
<p align="left">.\LRU.H</p> 
<p align="left">//最近最少用置换算法</p> 
<p align="left">#include&lt;iostream&gt;</p> 
<p align="left">#include&lt;iomanip&gt;</p> 
<p align="left">using namespace std;</p> 
<p align="left">void LRU(int Page[],int n,int piece,inttotal)</p> 
<p align="left">{<!-- --></p> 
<p align="left">    inti,number=0,j,position=0;</p> 
<p align="left">    intrate=0;</p> 
<p align="left">    inttemp;</p> 
<p align="left">    int*p=new int [piece];</p> 
<p align="left">    for(i=0;i&lt;piece;i++)</p> 
<p align="left">       p[i]=-1;//内存块数赋初值</p> 
<p align="left">       for(i=0;i&lt;n;i++)</p> 
<p align="left">           {<!-- --></p> 
<p align="left">               cout&lt;&lt;i+1&lt;&lt;" ";</p> 
<p align="left">              cout&lt;&lt;Page[i]&lt;&lt;":"&lt;&lt;setw(4);</p> 
<p align="left">              for(j=0;j&lt;piece&amp;&amp;p[j]!=Page[i];j++)//查找是否缺页</p> 
<p align="left">              ;</p> 
<p align="left">               if(p[j]==Page[i])//不缺页处理</p> 
<p align="left">              {<!-- --></p> 
<p align="left">                  temp=p[j];</p> 
<p align="left">                  while(j&lt;piece-1)</p> 
<p align="left">                  {<!-- --></p> 
<p align="left">                     p[j]=p[j+1];</p> 
<p align="left">                     j++;</p> 
<p align="left">                  }</p> 
<p align="left">                  p[j]=temp;</p> 
<p align="left">              Output1(p,piece);</p> 
<p align="left">              cout&lt;&lt;"不缺页"&lt;&lt;endl;</p> 
<p align="left">              }</p> 
<p align="left">              else//缺页处理</p> 
<p align="left">              {<!-- --></p> 
<p align="left">              rate++;</p> 
<p align="left">              for(j=0;j&lt;piece-1;j++)</p> 
<p align="left">                  p[j]=p[j+1];</p> 
<p align="left">              p[j]=Page[i];</p> 
<p align="left">              Output1(p,piece);</p> 
<p align="left">              cout&lt;&lt;"缺页"&lt;&lt;endl;</p> 
<p align="left">              }</p> 
<p align="left">       }</p> 
<p align="left">    cout&lt;&lt;"缺页次数："&lt;&lt;rate&lt;&lt;""&lt;&lt;"总数"&lt;&lt;n&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"最近最少用置换算法（LRU）缺页率为"&lt;&lt;(double)rate/n*100&lt;&lt;"%"&lt;&lt;endl;</p> 
<p align="left">    delete[]p;</p> 
<p align="left">}</p> 
<p align="left"> </p> 
<p align="left">.\OPT.H</p> 
<p align="left">//最佳置换算法</p> 
<p align="left">#include&lt;iostream&gt;</p> 
<p align="left">#include&lt;iomanip&gt;</p> 
<p align="left">using namespace std;</p> 
<p align="left">void OPT(int Page[],int n,int piece,inttotal)</p> 
<p align="left">{<!-- --></p> 
<p align="left">    inti,number=0,j,position=0,temp;</p> 
<p align="left">    intrate=0;</p> 
<p align="left">    int*p=new int [piece];</p> 
<p align="left">    int*flag=new int[total];</p> 
<p align="left">    //标记页数在内存的情况，0：不在内存块，1：在内存块，2：以后会再次访问并且已经在内存块的</p> 
<p align="left">    for(i=0;i&lt;piece;i++)</p> 
<p align="left">       p[i]=-1;//内存块数赋初值</p> 
<p align="left">    for(i=0;i&lt;total;i++)</p> 
<p align="left">       flag[i]=0;</p> 
<p align="left">    for(i=0;i&lt;n;i++)//缺页处理</p> 
<p align="left">    {<!-- --></p> 
<p align="left">       cout&lt;&lt;i+1&lt;&lt;"";</p> 
<p align="left">       if(flag[Page[i]]!=1)</p> 
<p align="left">       {<!-- --></p> 
<p align="left">           rate++;</p> 
<p align="left">           j=i+1;</p> 
<p align="left">           temp=piece;</p> 
<p align="left">           while(temp!=1&amp;&amp;j&lt;n)</p> 
<p align="left">           {<!-- --></p> 
<p align="left">              if(flag[Page[j]]==1)</p> 
<p align="left">              {<!-- --></p> 
<p align="left">                  flag[Page[j]]=2;</p> 
<p align="left">                  temp--;</p> 
<p align="left">              }</p> 
<p align="left">              j++;</p> 
<p align="left">           }</p> 
<p align="left">           for(j=0;j&lt;piece;j++)</p> 
<p align="left">              if(flag[p[j]]==1)</p> 
<p align="left">                  temp=j;</p> 
<p align="left">              elseflag[p[j]]=1;</p> 
<p align="left">           flag[p[temp]]=0;</p> 
<p align="left">           flag[Page[i]]=1;</p> 
<p align="left">           p[temp]=Page[i];</p> 
<p align="left">       cout&lt;&lt;Page[i]&lt;&lt;":"&lt;&lt;setw(4);</p> 
<p align="left">       Output1(p,piece);</p> 
<p align="left">       cout&lt;&lt;"缺页"&lt;&lt;endl;</p> 
<p align="left">       }   </p> 
<p align="left">       else</p> 
<p align="left">       {<!-- --></p> 
<p align="left">           cout&lt;&lt;Page[i]&lt;&lt;":"&lt;&lt;setw(4);</p> 
<p align="left">           Output1(p,piece);</p> 
<p align="left">           cout&lt;&lt;"不缺页"&lt;&lt;endl;</p> 
<p align="left">       }</p> 
<p align="left">    }</p> 
<p align="left">    cout&lt;&lt;"缺页次数："&lt;&lt;rate&lt;&lt;""&lt;&lt;"总数"&lt;&lt;n&lt;&lt;endl;</p> 
<p align="left">    cout&lt;&lt;"最佳置换算法（OPT)缺页率为"&lt;&lt;(double)rate/n*100&lt;&lt;"%"&lt;&lt;endl;</p> 
<p align="left">    delete[]p;</p> 
<p align="left">    delete[]flag;</p> 
<p align="left">}</p> 
<br> 
<p><br> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cff1ace05899d31f5c27475b0e35d6e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Node.js加密算法库Crypto</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b3496f835716b0de529ed79301a1e90d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(单片机原理与应用)大液晶屏的游戏设计（推箱子）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>