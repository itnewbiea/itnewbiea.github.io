<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;（24）STL引入：函数模板、类模板 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;（24）STL引入：函数模板、类模板" />
<meta property="og:description" content="我们在C语言的常规编程工作中，经常会遇到因为形参数据类型，而定义多个函数。比如功能交换A和B的值
//int 类型数据交换 void MySwap(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; } //double 类型数据交换 void MySwap(double &amp;a, double &amp;b) { double temp = a; a = b; b = temp; } 只要A和B 这两个数据的类型不同，我就要重定义一个新函数，而这两个函数除了形参数据类型不一样，其他的逻辑都是一样的。这样就造成了代码的重复，增加维护成本。
为了解决这个问题，c&#43;&#43;引入了 模板。
1、函数模板的基本语法 函数模板使形参类型化，实现定义的时候不关心具体的数据类型，只关心功能的实现。
编译器为了与普通函数区分，使用关键字template。
template&lt;class T&gt; template&lt;typename T&gt; 这两种使用方式表达的意思一样，根据习惯喜欢用哪个就用哪个。如果说需要使用多个类型的参数，那么也可以增加定义
template&lt;typename T1, typename T2, typename T3&gt;
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;memory&gt; using namespace std; //template&lt;class T&gt; // template&lt;typename T&gt; //这两种方式都可以 //如果需要多个类型参数的时候，可以增加定义 //template&lt;typename T1, typename T2, typename T3&gt; //使用template模板函数的时候，当出现template关键字的时候，只对紧接着出现的函数名生效 void MySwap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } //上面template的作用域消失 int main(void) { int a = 10, b = 20; cout &lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0fa9a30aa2a4d66955ed36b99366da87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-29T16:35:37+08:00" />
<meta property="article:modified_time" content="2023-01-29T16:35:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;（24）STL引入：函数模板、类模板</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>我们在C语言的常规编程工作中，经常会遇到因为形参数据类型，而定义多个函数。比如功能交换A和B的值</p> 
<pre><code class="language-cpp">//int 类型数据交换
void MySwap(int &amp;a, int &amp;b)
{
	int temp = a;
	a = b;
	b = temp;
}

//double 类型数据交换
void MySwap(double &amp;a, double &amp;b)
{
	double temp = a;
	a = b;
	b = temp;
}</code></pre> 
<p>只要A和B 这两个数据的类型不同，我就要重定义一个新函数，而这两个函数除了形参数据类型不一样，其他的逻辑都是一样的。这样就造成了代码的重复，增加维护成本。</p> 
<p>为了解决这个问题，c++引入了 <strong>模板。</strong></p> 
<h2><strong>1、函数模板的基本语法</strong></h2> 
<p>函数模板使形参类型化，实现定义的时候不关心具体的数据类型，只关心功能的实现。</p> 
<p>编译器为了与普通函数区分，使用关键字template。</p> 
<p>template&lt;class T&gt;  <br> template&lt;typename T&gt; 这两种使用方式表达的意思一样，根据习惯喜欢用哪个就用哪个。如果说需要使用多个类型的参数，那么也可以增加定义</p> 
<p>template&lt;typename T1, typename T2, typename T3&gt;</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

//template&lt;class T&gt;  // 
template&lt;typename T&gt; //这两种方式都可以  //如果需要多个类型参数的时候，可以增加定义 
//template&lt;typename T1, typename T2, typename T3&gt;
//使用template模板函数的时候，当出现template关键字的时候，只对紧接着出现的函数名生效
void MySwap(T &amp;a, T &amp;b)
{
	T temp = a;
	a = b;
	b = temp;
}
//上面template的作用域消失

int main(void)
{
	int a = 10, b = 20;
	cout &lt;&lt;"a="&lt;&lt;a&lt;&lt;", b="&lt;&lt;b&lt;&lt;endl;
	//调用方式1，传递编译器根据传递的值，自动推导数据类型
	MySwap(a, b);
	cout &lt;&lt;"a="&lt;&lt;a&lt;&lt;", b="&lt;&lt;b&lt;&lt;endl;
	
	double c = 6.66, d = 9.99;
	cout &lt;&lt;"c="&lt;&lt;c&lt;&lt;", d="&lt;&lt;d&lt;&lt;endl;
	//调用方式2，显示的指定数据类型
	MySwap&lt;double&gt;(c, d);
	cout &lt;&lt;"c="&lt;&lt;c&lt;&lt;", d="&lt;&lt;d&lt;&lt;endl;
	
	return 0;
}


</code></pre> 
<p>需要注意的是，当使用template模板函数的时候，当出现template关键字的时候，只对紧接着出现的函数名生效。</p> 
<p>上面的例子，当MySwap函数结束的时候，template模板的作用域也消失。</p> 
<p></p> 
<h2><strong>2、函数模板和普通函数的区别</strong></h2> 
<p>        函数模板不允许自动类型转化，必须严格的类型匹配</p> 
<p>        普通函数能够自动进行类型转化</p> 
<p>比如int类型的数据，在使用的时候也可以用char、short 类型接收，但是函数模板不允许，要严格进程数据类型识别。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

template &lt;class T&gt;
T MyAdd(T a, T b)
{
	cout&lt;&lt;"函数模板"&lt;&lt;endl;
	return (a+b);
}

int MyAdd(int a, char b)
{
	cout&lt;&lt;"普通函数"&lt;&lt;endl;
	return (a+b);
}
int main(void)
{
	int a = 10, b = 20;
	char c = 30;
	
	cout&lt;&lt;MyAdd(a, c)&lt;&lt;endl;
	cout&lt;&lt;MyAdd(a, b)&lt;&lt;endl;
	cout&lt;&lt;MyAdd(c, a)&lt;&lt;endl;
	
	return 0;
}


</code></pre> 
<p><img alt="" height="134" src="https://images2.imgbox.com/96/ba/XhB69Ijr_o.png" width="158"></p> 
<p></p> 
<h2> 3、函数模板和普通函数在一起调用的规则</h2> 
<p>（1）、函数模板可以像普通函数那样被重载</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
void Print(T a)
{
}

template&lt;class t&gt;
void Print(T a, T b)
{
}</code></pre> 
<p>（2）、c++编译器优先考虑普通函数   </p> 
<p>                 MySwap(T a, T b);    MySwap(int a, int b); 当形参都是int时，优先考虑普通。</p> 
<p>（3）、如果函数模板可以产生一个更好的匹配，那么选择模板</p> 
<p>（4）、<strong>可以通过空模板实参列表的语法限定编译器只能通过模板匹配  </strong></p> 
<p><strong>                 </strong>MySwap&lt;&gt;(a, b);限定只调用函数模板   </p> 
<p></p> 
<h2>4、c++编译模板机制剖析，分析函数模板是如何实现的</h2> 
<p><img alt="" height="271" src="https://images2.imgbox.com/9b/94/IIHnfx8a_o.png" width="889"> 当我们需要编译一个test.cpp的时候，他的一个编译过程大概是这样的。首先预编译器会先将宏定义进行展开，生成test.i文件，此时的这个 .i 文件我们还能看得懂。(通过编辑器打开，可以在最下面发现 宏定义展开后的代码)</p> 
<pre><code class="language-cpp">g++ -E test.cpp -o test.i</code></pre> 
<p>之后编译器会将.i文件，进行翻译编译，生成汇编文件test.s，这个时候已经不太能 看得懂了，当然ABCD的字母还是看得懂。</p> 
<pre><code> g++ -S test.i -o test.s</code></pre> 
<p>在之后汇编器，会将.s文件变成二进制文件，也就是目标文件，也就是test.o文件。（在windows下是.obj文件）</p> 
<pre><code> g++ -c test.s -o test.o</code></pre> 
<p>最后到链接器，将很多.o文件和链接库文件，最后都合在一起，生成可执行文件。（linux可执行文件，文件名可自定义。windows下是.exe文件）。</p> 
<pre><code>g++ test.s -o a.out</code></pre> 
<p></p> 
<p> <strong>函数模板的机制，其实是编译器在编译阶段，对函数模板进行了翻译</strong>。将整个工程中，被调用的函数模板翻译成了普通函数。调用了N种数据类型的模板，就会生成N个不同名称的普通函数。</p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/a2/7c/v2g17BmL_o.png" width="931"></p> 
<p> 下面我们来验证一下</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

template &lt;class T&gt; //注意没有分号
T MyAdd(T a, T b)
{
	return (a+b);
}

int main(void)
{
	int nVal1 = 10, nVal2 = 20;
	char chVal1 = 30, chVal2 = 40;
	float fVal1 = 6.66, fVal2 = 9.99;
	
	MyAdd(nVal1, nVal2);
	MyAdd(chVal1, chVal1);
	MyAdd(fVal1, fVal2);
	
	MyAdd(nVal1, nVal1);
	
	return 0;
}


</code></pre> 
<p>上面这个例子一共调用了四次MyAdd模板，我们对源文件直接进行编译g++ -S test.cpp -o test.s，生成 .s 文件。然后直接打开.s文件进行分析</p> 
<p><img alt="" height="786" src="https://images2.imgbox.com/3f/dc/OALoR8Gk_o.png" width="458"></p> 
<p>.s文件还是能让我们稍微看懂一点，但是对与理解原来有很大帮助。我们看到里面有一个熟悉的main函数，在这里面call了四次 MyAdd，我们在.s里也发现了熟悉的MyAdd，只不过名字不太一样，多了一点后缀。</p> 
<p>分别叫<img alt="" height="181" src="https://images2.imgbox.com/c5/6f/1RO42Xus_o.png" width="193"> 细心点可以发现，里面不同的i、c、f、i就是  对应的数据类型的缩写，int、char、float、int。跟我们实际的调用情况也吻合。</p> 
<p><strong>那么我们分析函数模板是如何实现的结论：</strong></p> 
<p>编译器并不是把函数模板处理成能够处理任何类型的函数，而是在编译阶段，函数模板通过具体类型产生的不同函数，编译器对函数模板进行<strong>二次编译，</strong>在声明的地方对模板函数代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p> 
<h2>5、函数模板案例char，int，float数据排序</h2> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

template &lt;class T&gt; 
void MySort(T *a, int len)
{
	int i=0, j=0;
	cout&lt;&lt;"排序之前的数据："&lt;&lt;endl;
	for (i=0; i&lt;len; i++)
	{
		cout&lt;&lt;a[i]&lt;&lt;" ";
	}
	cout&lt;&lt;endl;
	
	//冒泡排序，从小到大
	for(i=0; i&lt;len; i++)
	{
		for(j=i+1; j&lt;len; j++)
		{
			if (a[i] &gt; a[j])
			{
				T temp = a[i];
				a[i] = a[j];
				a[j] = temp;
			}
		}
	}
	
	cout&lt;&lt;"排序之后的数据："&lt;&lt;endl;
	for (i=0; i&lt;len; i++)
	{
		cout&lt;&lt;a[i]&lt;&lt;" ";
	}
	cout&lt;&lt;endl&lt;&lt;"----------------"&lt;&lt;endl;
}

int main(void)
{
	int nArr[] = {3, 4, 1, 5, 2};
	char chArr[] = {'b','d','c','e','a'};
	float fArr[] = {1.1, 3.3, 5.5, 4.4, 2.2};
	
	MySort(nArr, sizeof(nArr)/sizeof(int));
	MySort(chArr, sizeof(chArr)/sizeof(char));
	MySort(fArr, sizeof(fArr)/sizeof(float));
	
	return 0;
}


</code></pre> 
<h2><img alt="" height="332" src="https://images2.imgbox.com/59/98/NfjnV3rx_o.png" width="215"></h2> 
<h2>6、类模板</h2> 
<p>类模板和函数模板很相似，有一点区别。函数模板在调用的时候，可以自动类型推导。但是类模板必须显示的指定类型。</p> 
<p>要注意在<strong>类模板派生普通类</strong>的时候，子类的定义也要指定数据类型。</p> 
<p><strong>类模板派生类模板</strong>的时候，如果不指定类型。那么需要再使用template关键字，定义模板类型。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

template &lt;class T&gt; //注意没有分号
//类模板
class people
{
public:
	people(T age)
	{
		this-&gt;m_Age = age;
	}
public:
	T m_Age;
};

//类模板派生普通类
class student : public people&lt;int&gt;
{
public:
};

//类模板派生类模板
template &lt;class T&gt; //注意没有分号
class adult : public people&lt;T&gt;
{
public:
	//类模板的，类内实现，需要指定模板类people&lt;T&gt;
	adult(T age):people&lt;T&gt;(age)
	{
	}
	
	void show();
};

//类模板的，类外实现，也需要指定模板类people&lt;T&gt;
template &lt;class T&gt; 
void adult&lt;T&gt;::show()
{
	//在类模板中使用成员变量，必须要加上this，或者指定类模板作用域，否则编译报错
	// adult&lt;T&gt;::m_Age
	cout&lt;&lt;"i am adult, my age is "&lt;&lt;this-&gt;m_Age&lt;&lt;endl; 
}

int main(void)
{	
	adult&lt;int&gt; a1(30);
	a1.show();
	
	adult&lt;string&gt; a2("30岁");
	a2.show();
	return 0;
}


</code></pre> 
<p><img alt="" height="49" src="https://images2.imgbox.com/fb/99/wPeclm4U_o.png" width="277"></p> 
<p>这里一定要注意，使用类模板的时候，<strong>类内定义实现和类外定义实现的区别</strong>。其实如果对上面编译器的编译机制理解的比较好的话，就知道在分配内存的时候必要要指定类型，来区分内存大小。</p> 
<p>当他是模板的时候，类型不明确。当变量不指定类型或者模板的时候，就更不知道具体的数据大小了。</p> 
<p></p> 
<h2> 7、类模板重载操作符</h2> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

//还有一种使用比较多的方式，就是下面这种，先声明模板类，但是不常于友元
template&lt;class T1, class T2&gt; class people;
template&lt;class T1, class T2&gt; void print(people&lt;T1, T2&gt; &amp;p);
template&lt;class T1, class T2&gt; ostream &amp; operator&lt;&lt;(ostream &amp;os, people&lt;T1,T2&gt; &amp;p);

template&lt;class T1, class T2&gt;
class people
{
public:
	people(T1 name, T2 age)
	{
		this-&gt;m_name = name;
		this-&gt;m_age = age;
	}
	
	//声明类外友元函数的时候，编译器并不认识T1，T2,所以也要加上template关键字
	//template&lt;class T1, class T2&gt;  //windows下可以直接通过，但是linux下编译不通过
	//friend ostream &amp; operator&lt;&lt;&lt;T1,T2&gt;(ostream &amp;os, people&lt;T1,T2&gt; &amp;p);
	//template&lt;class I1, class I2&gt;//linux下要重新修改T1 和 T2的名称
	//friend ostream &amp; operator&lt;&lt;(ostream &amp;os, people&lt;I1,I2&gt; &amp;p);
	
	//普通友元的使用方法
	//template&lt;class C1, class C2&gt;
	//friend void print(people&lt;C1,C2&gt; &amp;p);
public:
	T1 m_name;
	T2 m_age;
};

//类外友元函数，&lt;&lt;操作符重载
template&lt;class T1, class T2&gt;
ostream &amp; operator&lt;&lt;(ostream &amp;os, people&lt;T1,T2&gt; &amp;p)
{
	os&lt;&lt;"name:"&lt;&lt;p.m_name&lt;&lt;", age:"&lt;&lt;p.m_age;
	return os;
}

template&lt;class T1, class T2&gt;
void print(people&lt;T1,T2&gt; &amp;p)
{
	cout&lt;&lt;"name:"&lt;&lt;p.m_name&lt;&lt;", age:"&lt;&lt;p.m_age&lt;&lt;endl;
}

int main(void)
{	
	people&lt;string, int&gt; a("li4", 18);
	cout&lt;&lt;a&lt;&lt;endl;
	print(a);
	
	return 0;
}


</code></pre> 
<p><img alt="" height="50" src="https://images2.imgbox.com/47/e5/0wQJFg2S_o.png" width="191"></p> 
<h3>警告：我们在实际使用模板的时候，千万要避免使用友元！！！</h3> 
<p>因为一旦友元碰上模板，就会特别麻烦，破坏类的封装性就算了，不同的编译器处理还不同。非常不建议使用！！！</p> 
<h2>8、linux环境中多文件分离编译</h2> 
<p>我们先了解一下c++编译机制  还有 模板的实现机制 </p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/f3/41/D49IOHGG_o.png" width="1200"></p> 
<p>模板定义在编译的时候，不会生成对应的实现函数。只有在调用的时候才会根据数据类型生成对应的具体实现函数。</p> 
<p>所以当我们使用make将几个文件放一起编译的时候，只要main文件中使用了people就会报错。因为编译器在main函数中，没有找模板函数的实现，（类模板的实现）。</p> 
<p>比如people&lt;string, int&gt; p("zhang3", 18);的时候，编译器在构造函数定义在当前的文件中没有找到，编译就会认为这个函数在其他的文件中。会让链接器在链接的时候，去找这个函数的具体位置。</p> 
<p>源文件  4-template.cpp</p> 
<pre><code class="language-cpp">#include "4-template.h"

//函数模板  经过两次编译
//并没有生成具体的函数，因为在此文件中并没有具体使用
template&lt;class T1, class T2&gt;
people&lt;T1, T2&gt;::people(T1 name, T2 age)
{
	this-&gt;m_name = name;
	this-&gt;m_age = age;
}

template&lt;class T1, class T2&gt;
void people&lt;T1, T2&gt;::show()
{
	cout&lt;&lt;"name:"&lt;&lt;this-&gt;m_name&lt;&lt;", age:"&lt;&lt;this-&gt;m_age&lt;&lt;endl;
}</code></pre> 
<p> main.cpp</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//编译器在main函数中，调用people的构造，会由于模板的编译实现机制，而找不到具体数据类型的函数实现。
//会通知链接器在链接的时候 去找实现，而我们的类实现cpp，由于是分开编译的。具体函数实现，是在调用的时候才会生成。
//为了解决这个问题，我们其实就把cpp文件放进来 一起编译就行了


//可以直接放在这里，include
#include "4-template.cpp"

//还有一种方式，就是我们在使用类模板的时候，直接把模板的实现cpp和h文件合成一个，叫做hpp文件
//就相当于将声明和实现  放在一起
//#include "4-template.hpp"

int main(void)
{	
	people&lt;string, int&gt; p("li4", 18);
	p.show();
	
	return 0;
}</code></pre> 
<p>4-template.h</p> 
<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

template&lt;class T1, class T2&gt;
class people
{
public:
	people(T1 name, T2 age);
	void show();
	
public:
	T1 m_name;
	T2 m_age;
};


</code></pre> 
<p>makefile</p> 
<pre><code class="language-bash">TOP := ..
COMM_DIR := .
SRC_DIR := .
INC_DIR := .

APP_TARGET  := template

## Object files that compose the target(s)
COMPILE_FILE := $(SRC_DIR)/4-template \
				$(SRC_DIR)/main

PROJ_FILES := $(foreach obj,$(COMPILE_FILE),$(obj).cpp)
PROJ_OBJS  := $(notdir $(COMPILE_FILE))
PROJ_OBJS  := $(foreach obj,$(PROJ_OBJS),$(obj).o)

## include and lib path in shared object file
INC_PATH += $(INC_DIR)

##rules
CPP := g++

all:$(APP_TARGET)

$(APP_TARGET):
	$(CPP) $(CFLAGS) -c $(PROJ_FILES)
	$(CPP) -o $(APP_TARGET) $(PROJ_OBJS)
	
clean:
	rm -f $(PROJ_OBJS) *.pdb *.map $(APP_TARGET)

</code></pre> 
<p>上面就是使用模板类，当cpp文件h文件分开编译的时候的解决方案。其实我们在实际工作中，很罕见直接include cpp文件的。当我们使用类模板的时候，会直接把模板的实现cpp和h文件合成一个，叫做hpp文件，就相当于将声明和实现  放在一起。在使用的时候，直接包含这个hpp文件，</p> 
<p>这样也方便其他人阅读代码，知道你在这个里面使用了模板<br> #include "4-template.hpp"</p> 
<p>源文件4-template.hpp</p> 
<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

template&lt;class T1, class T2&gt;
class people
{
public:
	people(T1 name, T2 age);
	void show();
	
public:
	T1 m_name;
	T2 m_age;
};

template&lt;class T1, class T2&gt;
people&lt;T1, T2&gt;::people(T1 name, T2 age)
{
	this-&gt;m_name = name;
	this-&gt;m_age = age;
}

template&lt;class T1, class T2&gt;
void people&lt;T1, T2&gt;::show()
{
	cout&lt;&lt;"name:"&lt;&lt;this-&gt;m_name&lt;&lt;", age:"&lt;&lt;this-&gt;m_age&lt;&lt;endl;
}
</code></pre> 
<h2>9、当类模板遇上static关键字</h2> 
<p>一句话，类模板中的static 变量，归<strong>具体类</strong>所有。</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/2a/b0/C6dVDfwY_o.png" width="917"></p> 
<p> 使用方法</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/99/9a/0n1d3ny3_o.png" width="453"></p> 
<p> <img alt="" height="74" src="https://images2.imgbox.com/6e/cf/vb049gHV_o.png" width="316"></p> 
<p>p1 p2 p3 共享int a；</p> 
<p>pp1  pp2  pp3共享int a;且跟上面的a是两个地址空间 </p> 
<p></p> 
<h2>10、MyArray类模板案例</h2> 
<p>写一个自定义数组的模板案例。比较简单，测试程序中使用了常规数据类型int，和自定义数据类型people类。这样的案例，看起来，就比较像STL提供的动态数组了。</p> 
<p>其中还涉及到c++11中关于对右值取引用的内容，可以看代码的注释。下面是源码，有兴趣的可以跟着我的代码敲一遍，加深关于类模板的理解。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;
using namespace std;

//people元素
class people
{
public:
	people()
	{
		this-&gt;m_name = "无名氏";
		this-&gt;m_age = 0;
	}
	
	people(string name, int age)
	{
		this-&gt;m_name = name;
		this-&gt;m_age = age;
	}
	
	people &amp;operator=(const people &amp;another) //=号操作符重载
	{
		if (this == &amp;another)
		{
			return *this;
		}
	
		this-&gt;m_name = another.m_name;
		this-&gt;m_age = another.m_age;
		return *this;
	}
	
	//MyArray模板的show使用cout
	friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const people &amp;p);
public:
	string m_name;
	int m_age;
};

ostream &amp;operator&lt;&lt;(ostream &amp;os, const people &amp;p)
{
	os&lt;&lt;"name:"&lt;&lt;p.m_name&lt;&lt;", age:"&lt;&lt;p.m_age&lt;&lt;endl;
	return os;
}

template&lt;class T&gt;
class MyArray
{
public:
	MyArray(int nCap)
	{
		cout&lt;&lt;"构造：MyArray(int nCap)..."&lt;&lt;endl;
		this-&gt;m_nCap = nCap;
		this-&gt;m_nSize = 0;
		this-&gt;pAddr = new T[this-&gt;m_nCap];
	}
	
	MyArray(const MyArray &amp;another)//拷贝构造
	{
		cout&lt;&lt;"构造：MyArray(const MyArray &amp;another)..."&lt;&lt;endl;
		this-&gt;m_nSize = another.m_nSize;
		this-&gt;m_nCap = another.m_nCap;
		
		this-&gt;pAddr = new T[this-&gt;m_nCap];
		for (int i=0; i&lt;this-&gt;m_nSize; i++)
		{
			this-&gt;pAddr[i] = another.pAddr[i];
		}			
	}
	
	~MyArray()
	{
		cout&lt;&lt;"析构：~MyArray()..."&lt;&lt;endl;
		if (this-&gt;pAddr != NULL)
		{
			delete[] this-&gt;pAddr;
			this-&gt;pAddr = NULL;
			this-&gt;m_nSize = 0;
			this-&gt;m_nCap = 0;
		}
	}
	
	T&amp; operator[](int nIndex)//[]操作符重载
	{
		return this-&gt;pAddr[nIndex];
	}
	
	MyArray&lt;T&gt; operator=(const MyArray &amp;another) //=号操作符重载
	{
		cout&lt;&lt;"=号操作符重载：MyArray&lt;T&gt; &amp;operator=(const MyArray &amp;another)..."&lt;&lt;endl;
		if (this-&gt;pAddr == another.pAddr)
		{
			return *this;
		}
		
		if (this-&gt;pAddr != NULL)
		{
			delete[] this-&gt;pAddr;
			this-&gt;pAddr = NULL;
			this-&gt;m_nSize = 0;
			this-&gt;m_nCap = 0;
		}
	
		this-&gt;m_nSize = another.m_nSize;
		this-&gt;m_nCap = another.m_nCap;
		this-&gt;pAddr = new T[this-&gt;m_nCap];
		for (int i=0; i&lt;this-&gt;m_nSize; i++)
		{
			this-&gt;pAddr[i] = another.pAddr[i];
		}
		return *this;
	}


	void PushBack(T &amp;data)
	{
		if (this-&gt;m_nSize &gt;= this-&gt;m_nCap)
			return ;
		
		this-&gt;pAddr[this-&gt;m_nSize++] = data;
	}

	//这是c++11的新标准，对T &amp;&amp;对右值取引用
	void PushBack(T &amp;&amp;data)
	{
		if (this-&gt;m_nSize &gt;= this-&gt;m_nCap)
			return ;
		
		this-&gt;pAddr[this-&gt;m_nSize++] = data;
	}
	
	void show()
	{
		for (int i=0; i&lt;this-&gt;m_nSize; i++)
		{
			cout&lt;&lt;this-&gt;pAddr[i]&lt;&lt;" ";
		}
		cout&lt;&lt;endl;
	}
	
public:
	int m_nCap; //能够容下元素数量的上限
	int m_nSize;//当前数组有多少元素
	T* pAddr;   //数组首地址
};

int main(void)
{	
	MyArray&lt;int&gt; arr(20);
	int a=10, b=20, c=30, d=40;
	arr.PushBack(a);
	arr.PushBack(b);
	arr.PushBack(c);
	arr.PushBack(d);
	
	//思考：为什么不能直接arr.PushBack(10);arr.PushBack(20);
	//因为声明时是 void PushBack(T &amp;data);形参是引用，是一个左值，而常量不能作为左值。
	//解决方案：重载 void PushBack(T &amp;&amp;data);   这是c++11的新标准，对T &amp;&amp;对右值取引用
	arr.PushBack(100);
	arr.PushBack(200);
	arr.PushBack(300);
	arr.PushBack(400);
	for (int i=0; i&lt;arr.m_nSize; i++)
	{
		cout&lt;&lt;arr[i]&lt;&lt;" ";
	}
	cout&lt;&lt;"-----------------------------"&lt;&lt;endl;
	
	MyArray&lt;int&gt; arr1 = arr;
	arr1.show();
	cout&lt;&lt;"-----------------------------"&lt;&lt;endl;

	MyArray&lt;int&gt; arr2(10);
	arr2 = arr;  //这里有一个值拷贝动作，会有一份临时变量被构造和析构，因为我们的=号操作符重载是返回值，而非引用
	arr2.show();
	cout&lt;&lt;"-----------------------------"&lt;&lt;endl;
	
	people p1("zhang3", 18);
	people p2("li4", 20);
	people p3("wang5", 25);
	MyArray&lt;people&gt; ap(5);
	ap.PushBack(p1);
	ap.PushBack(p2);
	ap.PushBack(p3);
	ap.show();
	cout&lt;&lt;"-----------------------------"&lt;&lt;endl;
	
	MyArray&lt;people&gt; ap1(5);
	ap1 = ap;
	ap1.show();
	cout&lt;&lt;"-----------------------------"&lt;&lt;endl;
	
	return 0;
}
</code></pre> 
<p>执行结果</p> 
<p><img alt="" height="692" src="https://images2.imgbox.com/bd/05/tfwEw4VV_o.png" width="804"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/08761a19e908c6fd7939a92c50ec9af1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js 红绿灯</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f29e8a2662414516f3fd1139625949df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【YOLO学习笔记——数据集】VOC格式转YOLO格式数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>