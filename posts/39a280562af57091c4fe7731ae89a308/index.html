<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【编程之路（007）扫雷游戏】（C语言实现） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【编程之路（007）扫雷游戏】（C语言实现）" />
<meta property="og:description" content="目录
引言
菜单的打印
初始化棋盘
棋盘的打印
布置雷区 确定周围雷数量值
标记雷
取消标记
递归展开空白安全区
统计被正确标记的雷数
扫雷的具体过程
源码
引言 扫雷这个游戏想必大家都不陌生。如果你知道扫雷游戏的规则，那么你可以跳过这一段，直接到main函数的整体逻辑这里开始。如果你还不知道扫雷怎么玩，我也给你复制好了游戏规则。
胜利条件：
在一个9*9方块矩阵中随机布置一定量的地雷10个。由玩家逐个翻开方块，以找出所有地雷为最终游戏目标。如果玩家翻开的方块有地雷，则游戏结束。
游戏主区域由很多个方格组成。使用鼠标左键随机点击一个方格，方格即被打开并显示出方格中的数字；方格中数字则表示其周围的8个方格隐藏了几颗雷。
在判断出不是雷的方块上按下左键（我们的是输入坐标），可以打开该方块。如果方块上出现数字，则该数字表示其周围3×3区域中的地雷数，一般为8个格子，对于边块为5个格子，对于角块为3个格子。所以扫雷中最大的数字为8；如果方块上为空（相当于0），则可以递归地打开与空相邻的方块；如果不幸触雷，则游戏结束。
main函数的整体逻辑
int main() { srand((unsigned int)time(NULL));//暂时不管 int choice = 0; do { printf(&#34; 游戏介绍： \n&#34;); printf(&#34;输入 1 为开始游戏，输入 0 为退出游戏\n&#34;); printf(&#34;游戏最终的胜利即为把全部的雷标记出来\n&#34;); menu(); printf(&#34;请选择\n&#34;); scanf(&#34;%d&#34;, &amp;choice); switch (choice) { case 1: { game(); break; } case 0: { printf(&#34;游戏退出\n&#34;); break; } default: { printf(&#34;选择错误，重新选择\n&#34;); break; } } } while (choice); return 0; } 这里的逻辑与上一篇三子棋【编程之路（006）三子棋游戏】（C语言实现）_p_fly的博客-CSDN博客一样，也很简单，如果不太明白，可以点击链接进去看看。接下来我们便实现游戏各个函数的功能。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/39a280562af57091c4fe7731ae89a308/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-12T11:27:32+08:00" />
<meta property="article:modified_time" content="2022-05-12T11:27:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【编程之路（007）扫雷游戏】（C语言实现）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%BC%95%E8%A8%80" rel="nofollow">引言</a></p> 
<p id="%E8%8F%9C%E5%8D%95%E7%9A%84%E6%89%93%E5%8D%B0-toc" style="margin-left:0px;"><a href="#%E8%8F%9C%E5%8D%95%E7%9A%84%E6%89%93%E5%8D%B0" rel="nofollow">菜单的打印</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%8B%E7%9B%98-toc" style="margin-left:0px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%8B%E7%9B%98" rel="nofollow">初始化棋盘</a></p> 
<p id="%E6%A3%8B%E7%9B%98%E7%9A%84%E6%89%93%E5%8D%B0-toc" style="margin-left:0px;"><a href="#%E6%A3%8B%E7%9B%98%E7%9A%84%E6%89%93%E5%8D%B0" rel="nofollow">棋盘的打印</a></p> 
<p id="%E5%B8%83%E7%BD%AE%E9%9B%B7%E5%8C%BA%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%B8%83%E7%BD%AE%E9%9B%B7%E5%8C%BA%C2%A0" rel="nofollow">布置雷区 </a></p> 
<p id="%E7%A1%AE%E5%AE%9A%E5%91%A8%E5%9B%B4%E9%9B%B7%E6%95%B0%E9%87%8F%E5%80%BC-toc" style="margin-left:0px;"><a href="#%E7%A1%AE%E5%AE%9A%E5%91%A8%E5%9B%B4%E9%9B%B7%E6%95%B0%E9%87%8F%E5%80%BC" rel="nofollow">确定周围雷数量值</a></p> 
<p id="%C2%A0%E6%A0%87%E8%AE%B0%E9%9B%B7-toc" style="margin-left:0px;"><a href="#%C2%A0%E6%A0%87%E8%AE%B0%E9%9B%B7" rel="nofollow"> 标记雷</a></p> 
<p id="%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0-toc" style="margin-left:0px;"><a href="#%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0" rel="nofollow">取消标记</a></p> 
<p id="%E9%80%92%E5%BD%92%E5%B1%95%E5%BC%80%E7%A9%BA%E7%99%BD%E5%AE%89%E5%85%A8%E5%8C%BA-toc" style="margin-left:0px;"><a href="#%E9%80%92%E5%BD%92%E5%B1%95%E5%BC%80%E7%A9%BA%E7%99%BD%E5%AE%89%E5%85%A8%E5%8C%BA" rel="nofollow">递归展开空白安全区</a></p> 
<p id="%E7%BB%9F%E8%AE%A1%E8%A2%AB%E6%AD%A3%E7%A1%AE%E6%A0%87%E8%AE%B0%E7%9A%84%E9%9B%B7%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E7%BB%9F%E8%AE%A1%E8%A2%AB%E6%AD%A3%E7%A1%AE%E6%A0%87%E8%AE%B0%E7%9A%84%E9%9B%B7%E6%95%B0" rel="nofollow">统计被正确标记的雷数</a></p> 
<p id="%E6%89%AB%E9%9B%B7%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E6%89%AB%E9%9B%B7%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B" rel="nofollow">扫雷的具体过程</a></p> 
<p style="margin-left:0px;"></p> 
<p id="%E6%BA%90%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E6%BA%90%E7%A0%81" rel="nofollow">源码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%BC%95%E8%A8%80">引言</h2> 
<p>扫雷这个游戏想必大家都不陌生。如果你知道扫雷游戏的规则，那么你可以跳过这一段，直接到main函数的整体逻辑这里开始。如果你还不知道扫雷怎么玩，我也给你复制好了游戏规则。</p> 
<p>胜利条件：</p> 
<p>在一个9*9方块矩阵中随机布置一定量的地雷10个。由玩家逐个翻开方块，以找出所有地雷为最终游戏目标。如果玩家翻开的方块有地雷，则游戏结束。</p> 
<p>游戏主区域由很多个方格组成。使用鼠标左键随机点击一个方格，方格即被打开并显示出方格中的数字；方格中数字则表示其周围的8个方格隐藏了几颗雷。</p> 
<p>在判断出不是雷的方块上按下左键（我们的是输入坐标），可以打开该方块。如果方块上出现数字，则该数字表示其周围3×3区域中的地雷数，一般为8个格子，对于边块为5个格子，对于角块为3个格子。所以扫雷中最大的数字为8；如果方块上为空（相当于0），则可以递归地打开与空相邻的方块；如果不幸触雷，则游戏结束。</p> 
<hr> 
<p>main函数的整体逻辑</p> 
<pre><code class="language-cpp">int main()
{
	srand((unsigned int)time(NULL));//暂时不管
	int choice = 0;
	do
	{
		printf("            游戏介绍：            \n");
		printf("输入 1 为开始游戏，输入 0 为退出游戏\n");
		printf("游戏最终的胜利即为把全部的雷标记出来\n");
		menu();
		printf("请选择\n");
		scanf("%d", &amp;choice);
		switch (choice)
		{
		case 1:
		{
			game();
			break;
		}
		case 0:
		{
			printf("游戏退出\n");
			break;
		}
		default:
		{
			printf("选择错误，重新选择\n");
			break;
		}
		}
	} while (choice);
	return 0;
}</code></pre> 
<p>这里的逻辑与上一篇三子棋<a href="https://blog.csdn.net/p_fly/article/details/124539736?spm=1001.2014.3001.5501" title="【编程之路（006）三子棋游戏】（C语言实现）_p_fly的博客-CSDN博客">【编程之路（006）三子棋游戏】（C语言实现）_p_fly的博客-CSDN博客</a>一样，也很简单，如果不太明白，可以点击链接进去看看。接下来我们便实现游戏各个函数的功能。</p> 
<hr> 
<h2 id="%E8%8F%9C%E5%8D%95%E7%9A%84%E6%89%93%E5%8D%B0">菜单的打印</h2> 
<pre><code class="language-cpp">void menu()
{
	printf("************************\n");
	printf("*****    1.play    *****\n");
	printf("*****    0.exit    *****\n");
	printf("************************\n");
}</code></pre> 
<hr> 
<h2 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%8B%E7%9B%98">初始化棋盘</h2> 
<pre><code class="language-cpp">void InitBoard(char board[ROWS][COLS], int rows, int cols, char ch)
{
	int i = 0, j = 0;
	for (i = 0; i &lt; rows; i++)
	{
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = ch;
		}
	}
}</code></pre> 
<p>这里要注意的是我们扫雷游戏其实是有两个棋盘（二维数组实现）的。<span style="color:#ff9900;">一个是玩家玩的棋盘界面；另一个是我们布置雷区的棋盘。</span>有了整体的把控，我们对于游戏的实现便有了大致的方向。</p> 
<p>由于扫雷要探索周围一圈的区域，也就是八个格子，对于中间的格子还好，我们可以很好的表示，但是对于边缘和四角的的格子，我们探索周围就会出现越界的情况（如下图）。解决方法是直接定义比棋盘规模多两行的行列。如9*9的规模我们便定义成（9+2）*（9+2）的规模。先说明ROWS和COLS是9+2的规模，ROW和COL是9的规模。那么为什么还要多次一举定义出ROW和COL呢，那是因为虽然我们的规模大，但还是有很多操作是需要用到9*9的。接下来其他功能的实现便可以很直观的看到。</p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/fc/9c/TCk1Z2xB_o.png" width="516"></p> 
<p></p> 
<hr> 
<h2 id="%E6%A3%8B%E7%9B%98%E7%9A%84%E6%89%93%E5%8D%B0">棋盘的打印</h2> 
<pre><code class="language-cpp">void Display(char board[ROWS][COLS], int row, int col)
{
	printf("-------------------\n");
	int i = 0, j = 0;
	for (j = 0; j &lt;= col; j++)//这个for循环是打印棋盘的列坐标
	{
		printf("%d ", j);
	}
	printf("\n");

	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);//这一行语句是打印棋盘的行坐标
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("-------------------\n");
}</code></pre> 
<p>这里所打印出来的棋盘是展示棋盘，而不是雷区棋盘。我们在函数传参的时候把'*'传个展示棋盘，让其保持待探索的感觉。效果如下</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/bb/0e/XDE21l2g_o.png" width="249"></p> 
<hr> 
<h2 id="%E5%B8%83%E7%BD%AE%E9%9B%B7%E5%8C%BA%C2%A0">布置雷区 </h2> 
<pre><code class="language-cpp">void SetMine(char board[ROWS][COLS], int row, int col)
{
	int x = 0, y = 0;
	int count = AMOUNT;//AMOUNT是我们定义的雷的数量
	while (count)
	{
		x = rand() % row + 1;//(0~8)+1==1~9
		y = rand() % col + 1;//(0~8)+1==1~9
		if (board[x][y] == '0')
		{
			board[x][y] = '1';//雷我们用字符'1'来表示，因为形参的类型是char
			count--;
		}
	}
}</code></pre> 
<p>rand（）函数和main（）函数中的srand（）函数随机生成了AMOUNT个雷。</p> 
<p>对于rand函数和srand函数不懂的可以参考这一篇文章</p> 
<p><a href="https://blog.csdn.net/u012763126/article/details/82925842?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165225026516781483780412%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=165225026516781483780412&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-12-82925842-null-null.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&amp;utm_term=rand%28%29%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E7%94%A8&amp;spm=1018.2226.3001.4187" title="rand()和srand()函数的用法_diluosixu的博客-CSDN博客_srand和rand函数怎么用">rand()和srand()函数的用法_diluosixu的博客-CSDN博客_srand和rand函数怎么用</a></p> 
<hr> 
<h2 id="%E7%A1%AE%E5%AE%9A%E5%91%A8%E5%9B%B4%E9%9B%B7%E6%95%B0%E9%87%8F%E5%80%BC">确定周围雷数量值</h2> 
<pre><code class="language-cpp">int AmountMine(char board[ROWS][COLS], int x, int y)
{
	return (board[x - 1][y] +
		board[x - 1][y - 1] +
		board[x][y - 1] +
		board[x + 1][y - 1] +
		board[x + 1][y] +
		board[x + 1][y + 1] +
		board[x][y + 1] +
		board[x - 1][y + 1] - 8 * '0');
       //减去8*'0'：因为我们的雷区中都是字符型的'0'//非雷'1'//雷。
       //所以如果有n个雷，就会产生n*'1'-n*'0'的整数。（'1'-'0'=1）
}
</code></pre> 
<p>对于玩家排查的一个（x，y）的格子，我们应该返回周围一圈有多少雷，如下图</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/da/dd/dyGIE1Tc_o.png" width="626"></p> 
<hr> 
<h2 id="%C2%A0%E6%A0%87%E8%AE%B0%E9%9B%B7"> 标记雷</h2> 
<pre><code class="language-cpp">void FlagMine(char show[ROWS][COLS], char mine[ROWS][COLS], int row, int col, int x, int y)
{
	if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
	{
		show[x][y] = '!';
	}
}
</code></pre> 
<p>我们把标记的雷在展示数组上用'!'标记。</p> 
<hr> 
<h2 id="%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0">取消标记</h2> 
<pre><code class="language-cpp">void FlagCancel(char show[ROWS][COLS], char mine[ROWS][COLS], int row, int col, int x, int y)
{
	if (show[x][y] == '!')
	{
		show[x][y] = '*';
	}
}
</code></pre> 
<p>我们想把原来标记的取消，直接在改成'*'即可。</p> 
<hr> 
<h2 id="%E9%80%92%E5%BD%92%E5%B1%95%E5%BC%80%E7%A9%BA%E7%99%BD%E5%AE%89%E5%85%A8%E5%8C%BA">递归展开空白安全区</h2> 
<pre><code class="language-cpp">void Spread(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)
{
	int around_x = 0;
	int around_y = 0;
	int count = 0;
	//坐标合法
	if (x &gt;= 1 &amp;&amp; x &lt;= 9 &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= 9)
	{
		//遍历周围坐标
		for (around_x = -1; around_x &lt;= 1; around_x++)
		{
			for (around_y = -1; around_y &lt;= 1; around_y++)
			{
				//如果这个坐标不是雷
				if (mine[x + around_x][y + around_y] == '0')
				{
					//统计周围雷的个数
					count = AmountMine(mine, x + around_x, y + around_y);
					if (count == 0)
					{
						if (show[x + around_x][y + around_y] == '*')
						{
							show[x + around_x][y + around_y] = ' ';
							Spread(mine, show, x + around_x, y + around_y);
						}
					}
                    //如果是雷就直接在展示棋盘上显示周围有几个雷的数字
					else
					{
						show[x + around_x][y + around_y] = count + '0';
					}
				}
			}
		}
	}
}
</code></pre> 
<hr> 
<h2 id="%E7%BB%9F%E8%AE%A1%E8%A2%AB%E6%AD%A3%E7%A1%AE%E6%A0%87%E8%AE%B0%E7%9A%84%E9%9B%B7%E6%95%B0">统计被正确标记的雷数</h2> 
<pre><code class="language-cpp">int ClearMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int i = 0, j = 0;
	int end = 0;
	for (i = 1; i &lt;= row; i++)
	{
		for (j = 1; j &lt;= col; j++)
		{
			if (mine[i][j] == '1' &amp;&amp; show[i][j] == '!')
              //在雷区棋盘上是雷并且在展示棋盘上是'!'才是被标记的正确的雷
				end++;
		}
	}
	return end;
}</code></pre> 
<p>如果玩家把所有的雷标记出来，那么就直接胜利了。</p> 
<hr> 
<h2 id="%E6%89%AB%E9%9B%B7%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B">扫雷的具体过程</h2> 
<pre><code class="language-cpp">void FindMine(char show[ROWS][COLS], char mine[ROWS][COLS], int row, int col)
{
	int n = 0, x = 0, y = 0;
	int win = 0;//统计被标记的个数（可能被标记的都是雷，也有可能标错）
	int flag = 0;//falg为0代表未取消标记，为1代表被取消标记//这是我为了方便展示棋盘而设置的
	int fail = 0;//fail为0代表没有被炸死，为1代表被炸死
again:
	while (win &lt; AMOUNT)
	{
		printf("功能 1：排查雷 2：标记雷 3：取消标记\n");
		printf("请选择功能和排查的坐标(功能 横 纵)\n");
		scanf("%d %d %d", &amp;n, &amp;x, &amp;y);
		switch (n)
		{
		case 1:
			break;
		case 2:
		{
			FlagMine(show, mine, row, col, x, y);
			win++;
		    break; 
		}
		case 3:
		{
			FlagCancel(show, mine, row, col, x, y); 
			flag = 1;
			win--;
			break;
		}
		}
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			if (mine[x][y] == '1' &amp;&amp; show[x][y] == '*' &amp;&amp; flag == 0)
			{
				printf("你被炸死了，下面是雷区分布图 1为雷  0非雷\n");
				Display(mine, ROW, COL);
				fail = 1;
				break;
			}
			else if (show[x][y] == '!')
				Display(show, ROW, COL);
			else if (flag == 1)
				Display(show, ROW, COL);
			else 
			{
				int count = AmountMine(mine, x, y);
				if (count == 0)
				{
					show[x][y] = ' ';
					Spread(mine, show, x, y);
					Display(show, ROW, COL);
				}
				else
				{
					show[x][y] = count + '0';
					Display(show, ROW, COL);
				}
			}
		}
		else
		{
			printf("输入错误，请重新输入");
		}
	}
	if (AMOUNT == ClearMine(mine,show,row,col))//如果雷的数量都被标记出来，就成功。
	{
		printf("恭喜你，扫雷成功\n");
	}
	else if(fail == 1)//如果触发到fail为1，则说明爆炸过了，就失败了。
	{
		printf("请选择是否再来一把\n");
	}
	else
	{
		printf("标记的雷有误，请仔细检查，重新标记\n");
        //到这里就是标记了至少一个安全区域，需要重新排雷
		goto again;//goto语句直接跳到重新排雷的地方
	}
}</code></pre> 
<h2></h2> 
<hr> 
<h2 id="%E6%BA%90%E7%A0%81">源码</h2> 
<p>该部分代码为game.h文件中的</p> 
<pre><code class="language-cpp">
#pragma once

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;

#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

#define AMOUNT 10

//菜单
void menu();

//棋盘初始化
void InitBoard(char board[ROWS][COLS], int rows, int cols, char ch);

//展示棋盘
void Display(char board[ROWS][COLS], int row, int col);

//布置雷
void SetMine(char board[ROWS][COLS], int row, int col);

//选择坐标区域雷的数量
int AmountMine(char board[ROWS][COLS], int row, int col);

//扫雷
void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);

//标记雷
void FlagMine(char show[ROWS][COLS], char mine[ROWS][COLS], int row, int col, int x, int y);

//取消标记
void FlagCancel(char show[ROWS][COLS], char mine[ROWS][COLS], int row, int col, int x, int y);

//排查选择坐标区域周围是否安全
void Spread(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y);

//返回被标记的雷的个数
int ClearMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);</code></pre> 
<p>该部分代码为game.c文件中的</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include"game.h"

void menu()
{
	printf("************************\n");
	printf("*****    1.play    *****\n");
	printf("*****    0.exit    *****\n");
	printf("************************\n");
}

void InitBoard(char board[ROWS][COLS], int rows, int cols, char ch)
{
	int i = 0, j = 0;
	for (i = 0; i &lt; rows; i++)
	{
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = ch;
		}
	}
}

void Display(char board[ROWS][COLS], int row, int col)
{
	printf("-------------------\n");
	int i = 0, j = 0;
	for (j = 0; j &lt;= col; j++)//这个for循环是打印棋盘的列坐标
	{
		printf("%d ", j);
	}
	printf("\n");

	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);//这一行语句是打印棋盘的行坐标
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("-------------------\n");
}

void SetMine(char board[ROWS][COLS], int row, int col)
{
	int x = 0, y = 0;
	int count = AMOUNT;
	while (count)
	{
		x = rand() % row + 1;//(0~8)+1==1~9
		y = rand() % col + 1;//(0~8)+1==1~9
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}

int AmountMine(char board[ROWS][COLS], int x, int y)
{
	return (board[x - 1][y] +
		board[x - 1][y - 1] +
		board[x][y - 1] +
		board[x + 1][y - 1] +
		board[x + 1][y] +
		board[x + 1][y + 1] +
		board[x][y + 1] +
		board[x - 1][y + 1] - 8 * '0');
}

void FlagMine(char show[ROWS][COLS], char mine[ROWS][COLS], int row, int col, int x, int y)
{
	if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
	{
		show[x][y] = '!';
	}
}

void FlagCancel(char show[ROWS][COLS], char mine[ROWS][COLS], int row, int col, int x, int y)
{
	if (show[x][y] == '!')
	{
		show[x][y] = '*';
	}
}


void Spread(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)
{
	int around_x = 0;
	int around_y = 0;
	int count = 0;
	//坐标合法
	if (x &gt;= 1 &amp;&amp; x &lt;= 9 &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= 9)
	{
		//遍历周围坐标
		for (around_x = -1; around_x &lt;= 1; around_x++)
		{
			for (around_y = -1; around_y &lt;= 1; around_y++)
			{
				//如果这个坐标不是雷
				if (mine[x + around_x][y + around_y] == '0')
				{
					//统计周围雷的个数
					count = AmountMine(mine, x + around_x, y + around_y);
					if (count == 0)
					{
						if (show[x + around_x][y + around_y] == '*')
						{
							show[x + around_x][y + around_y] = ' ';
							Spread(mine, show, x + around_x, y + around_y);
						}
					}
					else
					{
						show[x + around_x][y + around_y] = count + '0';
					}
				}
			}
		}
	}
}

int ClearMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int i = 0, j = 0;
	int end = 0;
	for (i = 1; i &lt;= row; i++)
	{
		for (j = 1; j &lt;= col; j++)
		{
			if (mine[i][j] == '1' &amp;&amp; show[i][j] == '!')
				end++;
		}
	}
	return end;
}

void FindMine(char show[ROWS][COLS], char mine[ROWS][COLS], int row, int col)
{
	int n = 0, x = 0, y = 0;
	int win = 0;
	int flag = 0;
	int fail = 0;
again:
	while (win &lt; AMOUNT)
	{
		printf("功能 1：排查雷 2：标记雷 3：取消标记\n");
		printf("请选择功能和排查的坐标(功能 横 纵)\n");
		scanf("%d %d %d", &amp;n, &amp;x, &amp;y);
		switch (n)
		{
		case 1:
			break;
		case 2:
		{
			FlagMine(show, mine, row, col, x, y);
			win++;
		    break; 
		}
		case 3:
		{
			FlagCancel(show, mine, row, col, x, y); 
			flag = 1;
			win--;
			break;
		}
		}
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			if (mine[x][y] == '1' &amp;&amp; show[x][y] == '*' &amp;&amp; flag == 0)
			{
				printf("你被炸死了，下面是雷区分布图 1为雷  0非雷\n");
				Display(mine, ROW, COL);
				fail = 1;
				break;
			}
			else if (show[x][y] == '!')
				Display(show, ROW, COL);
			else if (flag == 1)
				Display(show, ROW, COL);
			else 
			{
				int count = AmountMine(mine, x, y);
				if (count == 0)
				{
					show[x][y] = ' ';
					Spread(mine, show, x, y);
					Display(show, ROW, COL);
				}
				else
				{
					show[x][y] = count + '0';
					Display(show, ROW, COL);
				}
			}
		}
		else
		{
			printf("输入错误，请重新输入");
		}
	}
	if (AMOUNT == ClearMine(mine,show,row,col))
	{
		printf("恭喜你，扫雷成功\n");
	}
	else if(fail == 1)
	{
		printf("请选择是否再来一把\n");
	}
	else
	{
		printf("标记的雷有误，请仔细检查，重新标记\n");
		goto again;
	}
}</code></pre> 
<p>该部分代码为test.c文件中的</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include"game.h"

void game()
{
	//存放雷的棋盘  雷为'1',非雷为'0'  这里是字符1，0
	char mine[ROWS][COLS] = { 0 };
	//展示排查后的棋盘  未排查的区域为'*'，排查后显示周围雷的数字（也是字符）
	char show[ROWS][COLS] = { 0 };
	InitBoard(mine, ROWS, COLS, '0');
	InitBoard(show, ROWS, COLS, '*');
	SetMine(mine, ROW, COL);
	Display(show, ROW, COL);
	//Display(mine, ROW, COL);
	FindMine(show, mine, ROW, COL);
}

int main()
{
	srand((unsigned int)time(NULL));
	int choice = 0;
	do
	{
		printf("            游戏介绍：            \n");
		printf("输入 1 为开始游戏，输入 0 为退出游戏\n");
		printf("游戏最终的胜利即为把全部的雷标记出来\n");
		menu();
		printf("请选择\n");
		scanf("%d", &amp;choice);
		switch (choice)
		{
		case 1:
		{
			game();
			break;
		}
		case 0:
		{
			printf("游戏退出\n");
			break;
		}
		default:
		{
			printf("选择错误，重新选择\n");
			break;
		}
		}
	} while (choice);
	return 0;
}</code></pre> 
<p>希望这个扫雷游戏可以帮到你。有什么错误和建议也希望大家可以在评论区发出来。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ac60286310b3f2a481c3ac47a20ada8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue电商后台管理系统功能展示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ef78a24837e7b0c8b3e1ba84a9407db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高速USB转8串口产品设计-TTL串口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>