<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>resnet_v2_101训练自己的数据,完成分类任务之数据制作 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="resnet_v2_101训练自己的数据,完成分类任务之数据制作" />
<meta property="og:description" content="最近做了一个简单的分类任务，作一下记录，适合小白。从数据处理到推理代码都有，没错，我就是这么暖心！本次代码的框架使用了tf1.14版本，喜欢追逐梦想的童鞋可以尝试使用2.0的。主要差别是很多函数的API入口变了，一些旧的模块在2.0里不支持。关于resnet，这里主要使用slim包来实现，虽然我很喜欢造轮子，但是排期不允许。考虑到不是核心模块，直接拿来主义。到这里，可能有人会迷惑，slim包里有v1和v2版本，到底用哪个呢？我印象中，v1是原著的模型,v2在shortcut-connections上进行了改动，V2的残差单元的激活函数变了。从大牛们的测试结果上看，V2比V1准确度更高些。
入手步骤：当然是先准备数据啦，我这里转成了tfrecord格式。图片准备不用我说了吧~直接上数据处理代码。
import tensorflow as tf
import numpy as np
import os
import cv2
import matplotlib.pyplot as plt
import random
from PIL import Image
def _int64_feature(value):
return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))
def _bytes_feature(value):
return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))
def float_list_feature(value):
return tf.train.Feature(float_list=tf.train.FloatList(value=value))
def get_example_nums(tf_records_filenames):
nums= 0
for record in tf.python_io.tf_record_iterator(tf_records_filenames):
nums &#43;= 1
return nums
def show_image(title,image):
plt.imshow(image)
plt.axis(&#39;on&#39;) # 关掉坐标轴为 off
plt.title(title) # 图像题目
plt.show()
def load_labels_file(filename,labels_num=1,shuffle=False):
images=[]
labels=[]
with open(filename) as f:
lines_list=f.readlines()" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/38439bf5e227c6bcd95c39c974a22b41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-29T16:46:20+08:00" />
<meta property="article:modified_time" content="2020-09-29T16:46:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">resnet_v2_101训练自己的数据,完成分类任务之数据制作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近做了一个简单的分类任务，作一下记录，适合小白。从数据处理到推理代码都有，没错，我就是这么暖心！本次代码的框架使用了tf1.14版本，喜欢追逐梦想的童鞋可以尝试使用2.0的。主要差别是很多函数的API入口变了，一些旧的模块在2.0里不支持。关于resnet，这里主要使用slim包来实现，虽然我很喜欢造轮子，但是排期不允许。考虑到不是核心模块，直接拿来主义。到这里，可能有人会迷惑，slim包里有v1和v2版本，到底用哪个呢？我印象中，v1是原著的模型,v2在shortcut-connections上进行了改动，V2的残差单元的激活函数变了。从大牛们的测试结果上看，V2比V1准确度更高些。</p> 
<p>入手步骤：当然是先准备数据啦，我这里转成了tfrecord格式。图片准备不用我说了吧~直接上数据处理代码。</p> 
<p><br> import tensorflow as tf<br> import numpy as np<br> import os<br> import cv2<br> import matplotlib.pyplot as plt<br> import random<br> from PIL import Image</p> 
<p>def _int64_feature(value):<br>     return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))<br> def _bytes_feature(value):<br>     return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))<br> def float_list_feature(value):<br>   return tf.train.Feature(float_list=tf.train.FloatList(value=value))</p> 
<p>def get_example_nums(tf_records_filenames):<br>     nums= 0<br>     for record in tf.python_io.tf_record_iterator(tf_records_filenames):<br>         nums += 1<br>     return nums</p> 
<p>def show_image(title,image):<br>     plt.imshow(image)<br>     plt.axis('on')    # 关掉坐标轴为 off<br>     plt.title(title)  # 图像题目<br>     plt.show()</p> 
<p>def load_labels_file(filename,labels_num=1,shuffle=False):<br>     images=[]<br>     labels=[]<br>     with open(filename) as f:<br>         lines_list=f.readlines()<br>         if shuffle:<br>             random.shuffle(lines_list)</p> 
<p>        for lines in lines_list:<br>             line=lines.rstrip().split(' ')<br>             label=[]<br>             for i in range(labels_num):<br>                 label.append(int(line[i+1]))<br>             images.append(line[0])<br>             labels.append(label)<br>     return images,labels</p> 
<p>def read_image(filename, resize_height, resize_width,normalization=False):<br>     bgr_image = cv2.imread(filename)<br>     if len(bgr_image.shape)==2:#若是灰度图则转为三通道<br>         print("Warning:gray image",filename)<br>         bgr_image = cv2.cvtColor(bgr_image, cv2.COLOR_GRAY2BGR)</p> 
<p>    rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB)#将BGR转为RGB<br>     if resize_height&gt;0 and resize_width&gt;0:<br>         rgb_image=cv2.resize(rgb_image,(resize_width,resize_height))<br>     rgb_image=np.asanyarray(rgb_image)<br>     if normalization:<br>         rgb_image=rgb_image/255.0<br>     return rgb_image</p> 
<p><br> def get_batch_images(images,labels,batch_size,labels_nums,one_hot=False,shuffle=False,num_threads=1):<br>     min_after_dequeue = 200<br>     capacity = min_after_dequeue + 3 * batch_size  # 保证capacity必须大于min_after_dequeue参数值<br>     if shuffle:<br>         images_batch, labels_batch = tf.train.shuffle_batch([images,labels],batch_size=batch_size,capacity=capacity,min_after_dequeue=min_after_dequeue,num_threads=num_threads)<br>     else:<br>         images_batch, labels_batch = tf.train.batch([images,labels],batch_size=batch_size,capacity=capacity,num_threads=num_threads)<br>     if one_hot:<br>         labels_batch = tf.one_hot(labels_batch, labels_nums, 1, 0)<br>     return images_batch,labels_batch</p> 
<p>def read_records(filename,resize_height, resize_width,type=None):<br>     filename_queue = tf.train.string_input_producer([filename])<br>     reader = tf.TFRecordReader()<br>     _, serialized_example = reader.read(filename_queue)<br>     features = tf.parse_single_example(<br>         serialized_example,<br>         features={<!-- --><br>             'image_raw': tf.FixedLenFeature([], tf.string),<br>             'height': tf.FixedLenFeature([], tf.int64),<br>             'width': tf.FixedLenFeature([], tf.int64),<br>             'depth': tf.FixedLenFeature([], tf.int64),<br>             'label': tf.FixedLenFeature([], tf.int64)<br>         }<br>     )<br>     tf_image = tf.decode_raw(features['image_raw'], tf.uint8)#获得图像原始的数据<br>     tf_height = features['height']<br>     tf_width = features['width']<br>     tf_depth = features['depth']<br>     tf_label = tf.cast(features['label'], tf.int32)<br>     # PS:恢复原始图像数据,reshape的大小必须与保存之前的图像shape一致,否则出错<br>     # tf_image=tf.reshape(tf_image, [-1])    # 转换为行向量<br>     tf_image=tf.reshape(tf_image, [resize_height, resize_width, 3]) # 设置图像的维度</p> 
<p>    # 恢复数据后,才可以对图像进行resize_images:输入uint-&gt;输出float32<br>     # tf_image=tf.image.resize_images(tf_image,[224, 224])</p> 
<p>    # 存储的图像类型为uint8,tensorflow训练时数据必须是tf.float32<br>     if type is None:<br>         tf_image = tf.cast(tf_image, tf.float32)<br>     elif type=='normalization':# [1]若需要归一化请使用:<br>         # 仅当输入数据是uint8,才会归一化[0,255]<br>         # tf_image = tf.image.convert_image_dtype(tf_image, tf.float32)<br>         tf_image = tf.cast(tf_image, tf.float32) * (1. / 255.0)  # 归一化<br>     elif type=='centralization':<br>         # 若需要归一化,且中心化,假设均值为0.5,请使用:<br>         tf_image = tf.cast(tf_image, tf.float32) * (1. / 255) - 0.5 #中心化<br>     return tf_image,tf_label</p> 
<p><br> def create_records(image_dir,file, output_record_dir, resize_height, resize_width,shuffle,log=5):<br>     images_list, labels_list=load_labels_file(file,1,shuffle)<br>     writer = tf.python_io.TFRecordWriter(output_record_dir)<br>     for i, [image_name, labels] in enumerate(zip(images_list, labels_list)):<br>         image_path=os.path.join(image_dir,images_list[i])<br>         if not os.path.exists(image_path):<br>             print('Err:no image',image_path)<br>             continue<br>         image = read_image(image_path, resize_height, resize_width)<br>         image_raw = image.tostring()<br>         if i%log==0 or i==len(images_list)-1:<br>             print('------------processing:%d-th------------' % (i))<br>             print('current image_path=%s' % (image_path),'shape:{}'.format(image.shape),'labels:{}'.format(labels))<br>         # 这里仅保存一个label,多label适当增加"'label': _int64_feature(label)"项<br>         label=labels[0]<br>         example = tf.train.Example(features=tf.train.Features(feature={<!-- --><br>             'image_raw': _bytes_feature(image_raw),<br>             'height': _int64_feature(image.shape[0]),<br>             'width': _int64_feature(image.shape[1]),<br>             'depth': _int64_feature(image.shape[2]),<br>             'label': _int64_feature(label)<br>         }))<br>         writer.write(example.SerializeToString())<br>     writer.close()</p> 
<p>def disp_records(record_file,resize_height, resize_width,show_nums=4):<br>     tf_image, tf_label = read_records(record_file,resize_height,resize_width,type='normalization')<br>     # 显示前4个图片<br>     init_op = tf.initialize_all_variables()<br>     with tf.Session() as sess:<br>         sess.run(init_op)<br>         coord = tf.train.Coordinator()<br>         threads = tf.train.start_queue_runners(sess=sess, coord=coord)<br>         for i in range(show_nums):<br>             image,label = sess.run([tf_image,tf_label])  # 在会话中取出image和label<br>             # image = tf_image.eval()<br>             # 直接从record解析的image是一个向量,需要reshape显示<br>             # image = image.reshape([height,width,depth])<br>             print('shape:{},tpye:{},labels:{}'.format(image.shape,image.dtype,label))<br>             # pilimg = Image.fromarray(np.asarray(image_eval_reshape))<br>             # pilimg.show()<br>             show_image("image:%d"%(label),image)<br>         coord.request_stop()<br>         coord.join(threads)</p> 
<p><br> def batch_test(record_file,resize_height, resize_width):<br>     '''<br>     :param record_file: record文件路径<br>     :param resize_height:<br>     :param resize_width:<br>     :return:<br>     :PS:image_batch, label_batch一般作为网络的输入<br>     '''<br>     # 读取record函数<br>     tf_image,tf_label = read_records(record_file,resize_height,resize_width,type='normalization')<br>     image_batch, label_batch= get_batch_images(tf_image,tf_label,batch_size=4,labels_nums=5,one_hot=False,shuffle=False)</p> 
<p>    init = tf.global_variables_initializer()<br>     with tf.Session() as sess:  # 开始一个会话<br>         sess.run(init)<br>         coord = tf.train.Coordinator()<br>         threads = tf.train.start_queue_runners(coord=coord)<br>         for i in range(4):<br>             # 在会话中取出images和labels<br>             images, labels = sess.run([image_batch, label_batch])<br>             # 这里仅显示每个batch里第一张图片<br>             show_image("image", images[0, :, :, :])<br>             print('shape:{},tpye:{},labels:{}'.format(images.shape,images.dtype,labels))</p> 
<p>        # 停止所有线程<br>         coord.request_stop()<br>         coord.join(threads)</p> 
<p><br> if __name__ == '__main__':<br>     resize_height = 224  # 指定存储图片高度<br>     resize_width = 224  # 指定存储图片宽度<br>     shuffle=True<br>     log=5<br>     # 产生train.record文件<br>     image_dir='train'<br>     train_labels = 'train.txt'  # 训练图片路径和标签保存<br>     train_record_output = 'record/train{}.tfrecords'.format(resize_height)<br>     create_records(image_dir,train_labels, train_record_output, resize_height, resize_width,shuffle,log)<br>     train_nums=get_example_nums(train_record_output)<br>     print("save train example nums={}".format(train_nums))</p> 
<p>    # 产生val.record文件<br>     image_dir='validation'<br>     val_labels = 'val.txt'  #验证图片路径和标签保存<br>     val_record_output = 'record/val{}.tfrecords'.format(resize_height)<br>     create_records(image_dir,val_labels, val_record_output, resize_height, resize_width,shuffle,log)<br>     val_nums=get_example_nums(val_record_output)<br>     print("save val example nums={}".format(val_nums))</p> 
<p>    # 测试显示函数<br>     # disp_records(train_record_output,resize_height, resize_width)<br>     batch_test(train_record_output,resize_height, resize_width)</p> 
<p>    <br>  </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47b0b5f1f3392056af58dc81073ddc58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python中给List添加元素的4种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/330fc84828c3116d62e7c16bc557e806/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里（钉钉部门）远程面，三面坐上“直通车”，拿下offer没问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>