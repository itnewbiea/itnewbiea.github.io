<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>flutter绘制流程——rebuild - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="flutter绘制流程——rebuild" />
<meta property="og:description" content="rebuild是Element的方法，有两种场景下会被调用:
element第一次构建mount的时候widget发生变化的时候 void rebuild() { if (_lifecycleState != _ElementLifecycle.active || !_dirty) return; performRebuild(); } 主要逻辑分为2步
判断状态是否是active，_dirty是否为true执行performRebuild()，这是个抽象方法，所以具体rebuild的逻辑由element子类去实现 下面重点来看performRebuild()
performRebuild.png
1 performRebuild() 顾名思义真正执行重新build的地方，因此每个实现类会有所不同，下面看下不同类型Element的实现
1.1 RenderObjectElement 更新renderObject，当然还有一些RenderObjectElement的继承类可能还做了其他逻辑
@override void performRebuild() { widget.updateRenderObject(this, renderObject); _dirty = false; } 1.1.1 SliverMultiBoxAdaptorElement 对于SliverGrid，SliverList，ListView都会用到它，这里逻辑比较多，今天这篇不去细讲，大概了解有关键逻辑 _build(index)和updateChild`，
@override void performRebuild() { super.performRebuild(); final SplayTreeMap&lt;int, Element?&gt; newChildren = SplayTreeMap&lt;int, Element?&gt;(); void processElement(int index) { //省略... final Element? newChild = updateChild(newChildren[index], _build(index), index); //省略... } //省略... newChildren.keys.forEach(processElement); //省略... } 1.2 ComponentElement void performRebuild() { Widget?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/74f00553212046f0ac1a8be528b221fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T17:10:47+08:00" />
<meta property="article:modified_time" content="2023-12-29T17:10:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">flutter绘制流程——rebuild</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>rebuild是Element的方法，有两种场景下会被调用:</p> 
<ol><li>element第一次构建mount的时候</li><li>widget发生变化的时候</li></ol> 
<pre><code class="language-Dart">void rebuild() {
  if (_lifecycleState != _ElementLifecycle.active || !_dirty)
    return;
  performRebuild();
}
</code></pre> 
<p>主要逻辑分为2步</p> 
<ol><li>判断状态是否是active，_dirty是否为true</li><li>执行<strong>performRebuild()</strong>，这是个抽象方法，所以具体rebuild的逻辑由element子类去实现</li></ol> 
<p>下面重点来看performRebuild()</p> 
<p class="img-center"><img alt="" height="1152" src="https://images2.imgbox.com/95/e7/AXhadQKs_o.png" width="1098"></p> 
<p>performRebuild.png</p> 
<h3>1 performRebuild()</h3> 
<p>顾名思义真正执行重新build的地方，因此每个实现类会有所不同，下面看下不同类型Element的实现</p> 
<h4>1.1 RenderObjectElement</h4> 
<p>更新renderObject，当然还有一些RenderObjectElement的继承类可能还做了其他逻辑</p> 
<pre><code class="language-Dart">@override
void performRebuild() {
  widget.updateRenderObject(this, renderObject);
  _dirty = false;
}
</code></pre> 
<h5>1.1.1 SliverMultiBoxAdaptorElement</h5> 
<p>对于SliverGrid，SliverList，ListView都会用到它，这里逻辑比较多，今天这篇不去细讲，大概了解有关键逻辑 <code>_build(index)</code>和updateChild`，</p> 
<pre><code class="language-Dart">@override
void performRebuild() {
  super.performRebuild();
  final SplayTreeMap&lt;int, Element?&gt; newChildren = SplayTreeMap&lt;int, Element?&gt;();
  void processElement(int index) {
    //省略...
    final Element? newChild = updateChild(newChildren[index], _build(index), index);
    //省略...
  }
  //省略...
  newChildren.keys.forEach(processElement);
  //省略...
}
</code></pre> 
<h4>1.2 ComponentElement</h4> 
<pre><code class="language-Dart">void performRebuild() {
  Widget? built;
  try {
    //widget重建 如：StatelessElement
    built = build();
  } catch (e, stack) {
  } finally {
    _dirty = false;
  }
  try {
    _child = updateChild(_child, built, slot);
  } catch (e, stack) {
    //..省略
  }
}
</code></pre> 
<ol><li>执行build()，作为新的newWidget</li><li>_child = updateChild(_child, built, slot);</li></ol> 
<h5>1.2.1 StatelessElement</h5> 
<p>未覆写，逻辑同ComponentElement的performRebuild()</p> 
<h5>1.2.2 StatefulElement</h5> 
<pre><code class="language-Dart">void performRebuild() {
  if (_didChangeDependencies) {
    state.didChangeDependencies();
    _didChangeDependencies = false;
  }
  super.performRebuild();
}
</code></pre> 
<p>在build之前判断需要didChangeDependencies</p> 
<p><strong>总结</strong>:performRebuild()实现分两类，ComponentElement和RenderObjectElement</p> 
<ul><li>RenderObjectElement会updateRenderObject，对于有child的继承类会进行<strong>_build(index)和updateChild</strong></li><li>ComponentElement的performRebuild主要分为两步。<strong>1:build(); 2:updateChild</strong>。下面依次展开</li></ul> 
<h3>2 build()</h3> 
<h4>2.1 ComponentElement</h4> 
<pre><code class="language-Dart">/// Subclasses should override this function to actually call the appropriate
/// `build` function (e.g., [StatelessWidget.build] or [State.build]) for
/// their widget.
@protected
Widget build();
</code></pre> 
<p>用来build返回widget，这个我们就很熟悉了，写UI代码主要围绕在这一块</p> 
<ol><li>StatelessElement调用<code>widget.build(this);</code></li><li>StatefulElement 调用<code>state.build(this);</code></li><li>ProxyElement 直接返回<code>widget.child</code></li></ol> 
<h4>2.2 SliverMultiBoxAdaptorElement</h4> 
<p>在1.1.1中的performRebuild()执行的是<code>_build</code></p> 
<pre><code class="language-Dart">Widget? _build(int index) {
  return widget.delegate.build(this, index);
}
</code></pre> 
<p>看到SliverChildDelegate中的定义,和ComponentElement的build意思差不多，只不是事根据传入index来返回widget</p> 
<pre><code class="language-Dart">/// Returns the child with the given index.
///
/// Should return null if asked to build a widget with a greater
/// index than exists. If this returns null, [estimatedChildCount]
/// must subsequently return a precise non-null value (which is then
/// used to implement [RenderSliverBoxChildManager.childCount]).
///
/// Subclasses typically override this function and wrap their children in
/// [AutomaticKeepAlive], [IndexedSemantics], and [RepaintBoundary] widgets.
///
/// The values returned by this method are cached. To indicate that the
/// widgets have changed, a new delegate must be provided, and the new
/// delegate's [shouldRebuild] method must return true.
Widget? build(BuildContext context, int index);
</code></pre> 
<p><strong>总结</strong>:不管是ComponentElement中的<code>build</code>，还是SliverMultiBoxAdaptorElement中的<code>_build</code>，最终都是用来构建一个Widget。</p> 
<p>下面看到performRebuild的下一步updateChild。</p> 
<h3>3 updateChild</h3> 
<h4>3.1 Element/ComponentElement</h4> 
<p><code>Element? updateChild(Element? child, Widget? newWidget, Object? newSlot)</code>，用来更新子element</p> 
<pre><code class="language-Dart">Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) {
  //如果newWidget是null，并且old child非null，直接deactivateChild
  if (newWidget == null) {
    if (child != null)
      deactivateChild(child);
    return null;
  }
  final Element newChild;
  if (child != null) {
    //新旧widget相同的情况
    if (child.widget == newWidget) {
      if (child.slot != newSlot)
        updateSlotForChild(child, newSlot);
      newChild = child;
    } else if (Widget.canUpdate(child.widget, newWidget)) {
      //可以update的情况，也就是runtimetype和key相同
      if (child.slot != newSlot)
        updateSlotForChild(child, newSlot);
      child.update(newWidget);
      newChild = child;
    } else {
      //其他情况，移除旧的，重新inflateWidget新的widget，会创建element
      deactivateChild(child);
      newChild = inflateWidget(newWidget, newSlot);
    }
  } else {
    //old child是null，这里直接inflate新的widget，会创建element
    newChild = inflateWidget(newWidget, newSlot);
  }
  return newChild;
}
</code></pre> 
<p>总共分以下几种情况</p> 
<ol><li>newWidget是null，则清理掉old child（如果old child不为null），返回null</li><li>新旧widget相同，说明数据没有变化，直接返回旧的child</li><li>widget可以update，<strong>child.update(newWidget);</strong> 直接更新old child即可</li><li>其他情况，重新<strong>inflateWidget</strong>，这里会createElement，清理掉old child（如果old child不为null）</li></ol> 
<h4>3.2 SliverMultiBoxAdaptorElement</h4> 
<p>RenderObjectElement的实现类SliverMultiBoxAdaptorElement额外处理的就是更新child的renderobject的parentData</p> 
<pre><code class="language-Dart">@override
Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) {
  final SliverMultiBoxAdaptorParentData? oldParentData = child?.renderObject?.parentData as SliverMultiBoxAdaptorParentData?;
  final Element? newChild = super.updateChild(child, newWidget, newSlot);
  final SliverMultiBoxAdaptorParentData? newParentData = newChild?.renderObject?.parentData as SliverMultiBoxAdaptorParentData?;

  // Preserve the old layoutOffset if the renderObject was swapped out.
  if (oldParentData != newParentData &amp;&amp; oldParentData != null &amp;&amp; newParentData != null) {
    newParentData.layoutOffset = oldParentData.layoutOffset;
  }
  return newChild;
}
</code></pre> 
<p>下面看到<code>update</code>的逻辑</p> 
<h3>4 update</h3> 
<p>Element中定义，更新widget</p> 
<pre><code class="language-Dart">@mustCallSuper
void update(covariant Widget newWidget) {
  _widget = newWidget;
}
</code></pre> 
<h4>4.1 StatelessElement</h4> 
<pre><code class="language-Dart">void update(StatelessWidget newWidget) {
  super.update(newWidget);
  _dirty = true;
  rebuild();
}
</code></pre> 
<h4>4.2 StatefulElement</h4> 
<pre><code class="language-Dart">void update(StatefulWidget newWidget) {
  super.update(newWidget);
  final StatefulWidget oldWidget = state._widget!;
  _dirty = true;
  state._widget = widget as StatefulWidget;
  state.didUpdateWidget(oldWidget) as dynamic;
  rebuild();
}
</code></pre> 
<h4>4.3 RenderObjectElement</h4> 
<pre><code class="language-Dart">void update(covariant RenderObjectWidget newWidget) {
  super.update(newWidget);
  widget.updateRenderObject(this, renderObject);
  _dirty = false;
}
</code></pre> 
<p>下面看几个典型的实现类</p> 
<h5>4.3.1 SingleChildRenderObjectElement</h5> 
<pre><code class="language-Dart">@override
void update(SingleChildRenderObjectWidget newWidget) {
  super.update(newWidget);
  assert(widget == newWidget);
  _child = updateChild(_child, widget.child, null);
}
</code></pre> 
<h5>4.3.2 MutliChildRenderObjectElement</h5> 
<pre><code class="language-Dart">@override
void update(MultiChildRenderObjectWidget newWidget) {
  super.update(newWidget);
  _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren);
  _forgottenChildren.clear();
}
</code></pre> 
<p><strong>总结</strong>：对于update方法首先一定会做的就是更新_widget。然后对于ComponentElement和RenderObjectElement的逻辑有所不同。</p> 
<ul><li>ComponentElement主要会进行<code>rebuild();</code>这样又回到最初的<code>rebuild</code>，只是到了子节点</li><li>RenderObjectElement则会更新自己的renderObject，然后根据拥有child是否是多个逻辑有所不同，如： 
  <ul><li>SingleChildRenderObjectElement只有一个child，执行<code>updateChild</code> 这样也回到了前面的步骤3</li><li>MutliChildRenderObjectElement可能有多个child，执行<code>updateChildren</code></li></ul></li></ul> 
<p>下面重点开看<code>updateChildren</code></p> 
<h3>5 updateChildren</h3> 
<p>RenderObjectElement中定义，针对可能有多个child的element的更新逻辑</p> 
<h4>5.1 定义新旧children的开始和结束位置，用于后面遍历</h4> 
<pre><code class="language-Dart">//定义old和new的首尾位置
int newChildrenTop = 0;
int oldChildrenTop = 0;
int newChildrenBottom = newWidgets.length - 1;
int oldChildrenBottom = oldChildren.length - 1;
//根据old和new的长度判断，如果相同则newChildren直接使用oldChildren，如果不同，则创建一个长度为newWidgets.length的list，使用_NullElement.instance来填充
final List&lt;Element&gt; newChildren = oldChildren.length == newWidgets.length ?
oldChildren : List&lt;Element&gt;.filled(newWidgets.length, _NullElement.instance, growable: false);
</code></pre> 
<h4>5.2 从开始位置遍历children，主要处理可以直接updateChild的情况，碰到不能update则直接跳出，newChildrenTop和oldChildrenTop会指向不能update的child位置</h4> 
<pre><code class="language-Dart">// Update the top of the list.
while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) {
  //判断oldChild是否被移除
  final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]);
  final Widget newWidget = newWidgets[newChildrenTop];
  //oldChild是空或者newWidget不能直接更新，就跳出
  if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget))
    break;
  //更新child
  final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;
  //设置到newChild中
  newChildren[newChildrenTop] = newChild;
  //设置上一个child
  previousChild = newChild;
  //移动到下一个位置
  newChildrenTop += 1;
  oldChildrenTop += 1;
}
</code></pre> 
<h4>5.3 从底部开始遍历判断canUpdate，知道返回false，跳出，这样oldChildrenBottom和newChildrenBottom指向末尾不能update的child</h4> 
<pre><code class="language-Dart">// Scan the bottom of the list.
while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) {
  final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenBottom]);
  final Widget newWidget = newWidgets[newChildrenBottom];
  if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget))
    break;
  //注意这里和step2的区别是没有去设置previousChild了，并且没有updateChild
  oldChildrenBottom -= 1;
  newChildrenBottom -= 1;
}
</code></pre> 
<h4>5.4 从oldChildrenTop开始遍历oldChildren，取出widget.key不为null的child，存入oldKeyedChildren，后面可能取出进行复用，这里oldChildrenTop应该等于oldChildrenBottom+1</h4> 
<pre><code class="language-Dart">// Scan the old children in the middle of the list.
// 根据top和bottom位置判断是否还存在中间的元素没有处理
final bool haveOldChildren = oldChildrenTop &lt;= oldChildrenBottom;
//用于存放有key的old child
Map&lt;Key, Element&gt;? oldKeyedChildren;
if (haveOldChildren) {
  oldKeyedChildren = &lt;Key, Element&gt;{};
  //从顶部开始遍历oldChildren
  while (oldChildrenTop &lt;= oldChildrenBottom) {
    final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]);
    if (oldChild != null) {
      //如果有key，则存入oldKeyedChildren
      if (oldChild.widget.key != null)
        oldKeyedChildren[oldChild.widget.key!] = oldChild;
      else
        //没有直接废弃oldChild
        deactivateChild(oldChild);
    }
    //注意：这里是old child的位置移动
    oldChildrenTop += 1;
  }
}
</code></pre> 
<h4>5.5 从newChildrenTop开始遍历newWidgets，根据key从oldKeyedChildren取出old child，然后判断是否可以直接update，如果可以则在updateChild的作为oldChild参数传入，否则传null。到这里newChildrenTop应该等于newChildrenBottom+1</h4> 
<pre><code class="language-Dart">// Update the middle of the list.
//从顶部更新newChildren
while (newChildrenTop &lt;= newChildrenBottom) {
  Element? oldChild;
  final Widget newWidget = newWidgets[newChildrenTop];
  if (haveOldChildren) {
    final Key? key = newWidget.key;
    //判断new child是否有key
    if (key != null) {
      //获取old child有相同key的child
      oldChild = oldKeyedChildren![key];
      if (oldChild != null) {
        //如果可以更新则直接更新
        if (Widget.canUpdate(oldChild.widget, newWidget)) {
          // we found a match!
          // remove it from oldKeyedChildren so we don't unsync it later
          //如果可以更新就可以移除掉了
          oldKeyedChildren.remove(key);
        } else {
          // Not a match, let's pretend we didn't see it for now.
          oldChild = null;
        }
      }
    }
  }
  //更新
  final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;
  newChildren[newChildrenTop] = newChild;
  previousChild = newChild;
  newChildrenTop += 1;
}
</code></pre> 
<h4>5.6 在4.3中只是做了newChildrenBottom和oldChildrenBottom的标记，并没有真正的updateChild，所以。下面重置newChildrenBottom和oldChildrenBottom。继续从oldChildrenTop开始遍历，然后updateChild</h4> 
<pre><code class="language-Dart">// We've scanned the whole list.
//重置bottom位置
newChildrenBottom = newWidgets.length - 1;
oldChildrenBottom = oldChildren.length - 1;

// Update the bottom of the list.
while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) {
  final Element oldChild = oldChildren[oldChildrenTop];
  final Widget newWidget = newWidgets[newChildrenTop];
  //更新剩余的child
  final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;
  newChildren[newChildrenTop] = newChild;
  previousChild = newChild;
  newChildrenTop += 1;
  oldChildrenTop += 1;
}
</code></pre> 
<h4>5.7 清理没有复用成功的child</h4> 
<pre><code class="language-Dart">  // Clean up any of the remaining middle nodes from the old list.
  if (haveOldChildren &amp;&amp; oldKeyedChildren!.isNotEmpty) {
    for (final Element oldChild in oldKeyedChildren.values) {
      //将剩下带有key的old child，同时又没能复用的child进行clean
      if (forgottenChildren == null || !forgottenChildren.contains(oldChild))
        deactivateChild(oldChild);
    }
  }
  return newChildren;
}
</code></pre> 
<p><strong>总结</strong>:这么长的流程和逻辑主要是为了对多个children的情况要进行判断是否可以复用，对于不能复用的child进行清理，最终针对child还是会执行到<code>updateChild</code>这样又回到了3</p> 
<h3>6 inflateWidget</h3> 
<p>Element中定义，在第3节中 <code>updateChild</code>如果old child是空或者无法update就需要inflateWidget</p> 
<p>写android的朋友应该很熟悉了，android里有<code>LayoutInflater.from().inflate()</code>,从xml来解析获取到View；同样在这里通过widget来解析返回Element。关于GlobalKey的逻辑，我们先忽略，后面再介绍。下面的逻辑就简单了，创建一个element，然后mount到当前element</p> 
<pre><code class="language-Dart">Element inflateWidget(Widget newWidget, Object? newSlot) {
  final Key? key = newWidget.key;
  if (key is GlobalKey) {
    final Element? newChild = _retakeInactiveElement(key, newWidget);
    if (newChild != null) {
      newChild._activateWithParent(this, newSlot);
      final Element? updatedChild = updateChild(newChild, newWidget, newSlot);
      return updatedChild!;
    }
  }
  //创建子Element
  final Element newChild = newWidget.createElement();
  //将child挂载到当前element
  newChild.mount(this, newSlot);
  //返回child element
  return newChild;
}
</code></pre> 
<h3>7 总结</h3> 
<p>走完上面整个rebuild流程，第一感受就是在于ComponentElement和RenderObjectElement在流程上有明显的区别，这也回到这两类Element的设计，RenderObjectElement不一定包含子child，但它包括renderObject用于渲染，而ComponentElement是一种组成的Element，它并不包含RenderObject，但它会有子 Element。因此在rebuild时ComponentElement只需要关心child的update，而RenderObjectElement还需要关注RenderObject的更新。另外在多child的情况如：第5节，diff的逻辑会稍微复杂一点。</p> 
<p>对于整个流程中的关于方法我们也要熟悉，如：update，inflateWidget，updateChild。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a1943409308dbb26f57e2ab2d18bb34/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">某后台管理系统加密参数逆向分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf2cffde226a0076d7898d0ae9106380/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LeetCode 2706. 购买两块巧克力：一次遍历（O(n) &#43; O(1)）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>