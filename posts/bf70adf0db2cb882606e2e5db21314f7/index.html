<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试3——准备 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试3——准备" />
<meta property="og:description" content="面试3——准备 1 面经2 知识点2.1 语言/C&#43;&#43;2.1.1 特性2.1.2 语法 2.2 数据结构&amp;算法2.3 线程2.4 网络2.4.1 TCP2.4.2 七层网络模型2.4.3 PING2.4.4 socket 2.5 Git2.6 ROS2.7 自动驾驶2.7.1 传感器2.7.2 规划 1 面经 自我介绍自我定位行业理解项目难点软件架构设计的思路Qt使用的模块为什么选择我们单位为什么选择上海/广州优点/缺点最难的项目，碰到的问题，收获与岗位匹配的技能，自己的优势和劣势职业规划加班怎么看两个月任务，时间砍半怎么办能力强，举例兴趣爱好三句话总结自己一直在钻研的事情反问环节 技术面：岗位工作技术二面：部门目前工作方向主管面：需要完成的工作和期望 相关方向的研发阶段HR面：新人培养过程，进入一个公司，如何快速地融入到公司
反问自己有什么问题 2 知识点 2.1 语言/C&#43;&#43; 2.1.1 特性 继承、多态、封装
继承
代码复用、类耦合多态
运行时多态 虚函数
编译期多态 模板、宏定义
代码复用、可维护扩展封装
隐藏属性和实现细节，仅对外提供接口和方法 定义要为变量分配内存空间；而声明不需要为变量分配内存空间。
2.1.2 语法 【关键字】
static 限制文件内，限制函数内，静态类成员final
C&#43;&#43;11的关键字final有两个用途。第一，它阻止了从类继承；第二，阻止一个虚函数的重载。override &amp; overload &amp; overwrite
overload 重载 相同作用域、相同函数名、参数不同（类型、顺序）
override 覆盖 派生类覆盖基类函数，只针对虚函数，在virtual基础上，还要用override是为防止重写错误、提高代码可读性，可以替代virtual
overwrite 派生类函数屏蔽基类同名函数，两种情况：参数不同，无论有无virtual，基类函数被屏蔽；参数相同，且无virtual，基类函数被屏蔽volatile
volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。
为了安全起见，只要是等待别的程序修改某个变量的话，就加上volatile关键字union 大小端问题const 成员函数
在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。
const对象只能调用const成员函数、不能调用非const成员函数，非const对象可以调用const成员函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bf70adf0db2cb882606e2e5db21314f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-08T12:06:33+08:00" />
<meta property="article:modified_time" content="2022-04-08T12:06:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试3——准备</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>面试3——准备</h4> 
 <ul><li><ul><li><a href="#1__2" rel="nofollow">1 面经</a></li><li><a href="#2__28" rel="nofollow">2 知识点</a></li><li><ul><li><a href="#21_C_29" rel="nofollow">2.1 语言/C++</a></li><li><ul><li><a href="#211__30" rel="nofollow">2.1.1 特性</a></li><li><a href="#212__43" rel="nofollow">2.1.2 语法</a></li></ul> 
    </li><li><a href="#22__259" rel="nofollow">2.2 数据结构&amp;算法</a></li><li><a href="#23__266" rel="nofollow">2.3 线程</a></li><li><a href="#24__295" rel="nofollow">2.4 网络</a></li><li><ul><li><a href="#241_TCP_296" rel="nofollow">2.4.1 TCP</a></li><li><a href="#242__335" rel="nofollow">2.4.2 七层网络模型</a></li><li><a href="#243_PING_345" rel="nofollow">2.4.3 PING</a></li><li><a href="#244_socket_360" rel="nofollow">2.4.4 socket</a></li></ul> 
    </li><li><a href="#25_Git_365" rel="nofollow">2.5 Git</a></li><li><a href="#26_ROS_368" rel="nofollow">2.6 ROS</a></li><li><a href="#27__376" rel="nofollow">2.7 自动驾驶</a></li><li><ul><li><a href="#271__377" rel="nofollow">2.7.1 传感器</a></li><li><a href="#272__388" rel="nofollow">2.7.2 规划</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1__2"></a>1 面经</h3> 
<ol><li>自我介绍</li><li>自我定位</li><li>行业理解</li><li>项目难点</li><li>软件架构设计的思路</li><li>Qt使用的模块</li><li>为什么选择我们单位</li><li>为什么选择上海/广州</li><li>优点/缺点</li><li>最难的项目，碰到的问题，收获</li><li>与岗位匹配的技能，自己的优势和劣势</li><li>职业规划</li><li>加班怎么看</li><li>两个月任务，时间砍半怎么办</li><li>能力强，举例</li><li>兴趣爱好</li><li>三句话总结自己</li><li>一直在钻研的事情</li><li>反问环节 
  <blockquote> 
   <ol><li>技术面：岗位工作</li><li>技术二面：部门目前工作方向</li><li>主管面：需要完成的工作和期望 相关方向的研发阶段</li><li>HR面：新人培养过程，进入一个公司，如何快速地融入到公司<br> 反问自己有什么问题</li></ol> 
  </blockquote> </li></ol> 
<h3><a id="2__28"></a>2 知识点</h3> 
<h4><a id="21_C_29"></a>2.1 语言/C++</h4> 
<h5><a id="211__30"></a>2.1.1 特性</h5> 
<blockquote> 
 <p>继承、多态、封装</p> 
 <ol><li>继承<br> 代码复用、类耦合</li><li>多态<br> 运行时多态 虚函数<br> 编译期多态 模板、宏定义<br> 代码复用、可维护扩展</li><li>封装<br> 隐藏属性和实现细节，仅对外提供接口和方法</li></ol> 
</blockquote> 
<p>定义要为变量分配内存空间；而声明不需要为变量分配内存空间。</p> 
<h5><a id="212__43"></a>2.1.2 语法</h5> 
<blockquote> 
 <p>【关键字】</p> 
 <ol><li><a href="https://blog.csdn.net/ypshowm/article/details/89030194">static</a> 限制文件内，限制函数内，静态类成员</li><li>final<br> C++11的关键字final有两个用途。第一，它阻止了从类继承；第二，阻止一个虚函数的重载。</li><li>override &amp; overload &amp; overwrite<br> overload 重载 相同作用域、相同函数名、参数不同（类型、顺序）<br> override 覆盖 派生类覆盖基类函数，只针对虚函数，在virtual基础上，还要用override是为防止重写错误、提高代码可读性，可以替代virtual<br> overwrite 派生类函数屏蔽基类同名函数，两种情况：参数不同，无论有无virtual，基类函数被屏蔽；参数相同，且无virtual，基类函数被屏蔽</li><li>volatile<br> volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。<br> 为了安全起见，只要是等待别的程序修改某个变量的话，就加上volatile关键字</li><li>union 大小端问题</li><li>const 成员函数<br> 在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。<br> const对象只能调用const成员函数、不能调用非const成员函数，非const对象可以调用const成员函数<br> const成员函数可以被对应的具有相同形参列表的非const成员函数重载<br> const成员函数的写法有两种<br> 1、void fun(int a，int b) const{}<br> 2、void const fun(int a,int b){}<br> 这两种写法的本质是：void fun (const 类 *this, int a,int b);</li><li>继承的public、private、protected<br> 任何继承方式下，派生类不可访问基类private，但有继承<br> public继承下，基类的public和protected在派生类不变<br> protected继承下，基类的public和protected在派生类中为protected，作用是对派生类可用，对外不可用<br> private继承下，基类的public和protected在派生类中为private</li><li>typeid<br> <strong>typeid(表达式).name()</strong> 获取一个表达式是类型，返回表达式的类型，表达式可以是类型名称、变量名、数字、字符串、指针、结构体等</li><li>strlen&amp;sizeof<br> <strong>strlen</strong> 计算字符串的长度，以\0’为字符串结束<br> <strong>sizeof</strong> 计算的则是分配内存空间的大小，不受里面存储的内容影响</li><li>const<br> 普通变量，指针，传参，返回值，类成员</li><li>extern<br> extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。<br> 对于变量，区分定义和声明，不加extern是定义，加了也不一定是声明（分配内存），全局变量声明一般不在头文件（重复包含），在源文件中的全局变量引用其他源文件。<br> 对于函数，函数的声明和实现不同（函数体），因此有无extern都行，编译时会去其他地方找实现。<br> extern “C” 按照C风格编译函数，C++有重载，函数名被改动</li><li>引用和指针<br> 引用：别名<br> 指针：地址</li></ol> 
</blockquote> 
<table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>指针</td><td>地址</td><td>初始化后，可重新赋值为另一地址</td><td>可为空</td><td></td></tr><tr><td>引用</td><td>别名</td><td>初始化后，不可重新引用其他对象</td><td>不可为空</td><td></td></tr></tbody></table> 
<blockquote> 
 <p>【面向对象】虚函数、继承<br> 动态绑定 运行时多态</p> 
 <ol><li>虚函数，指向基类的指针在操作派生类对象时，会根据不同对象，调用相应虚函数</li><li><a href="https://blog.csdn.net/o_bvious/article/details/52336307">为什么用基类的指针指向派生类</a><br> 为了避免同名隐藏，使用基类指针变成调用虚函数变成从上往下找；<br> 编译器查找函数时，名字查找优先于类型检查</li><li>纯虚函数怎么执行<br> 一定要在派生类实现该纯虚函数</li><li>虚函数表<br> 1 每个包含虚函数的类，都有一个虚函数表和一个指向虚表的指针__vptr，在编译阶段构造<br> 1 一个类的每个对象使用虚表指针__vptr指向同一个虚函数表<br> 2 有虚函数的类被继承后，继承类也有自己的虚函数表<br> 2 虚表中的指针会指向其继承的最近的一个类的虚函数<br> 3 基类指针指向派生类对象，因为虚表指针的存在，该指针依然指向派生类的的虚表</li><li>析构函数是虚函数<br> 在实现多态时，当用基类指针指向派生类对象时，在析构时防止只析构基类而不析构派生类的状况发生<br> 构造函数不能是虚函数，原因如下：</li><li>虚函数对应一个虚指针，虚指针其实是存储在对象的内存空间的。<strong>如果构造函数是虚函数，就需要通过虚函数表中对应的虚函数指针（编译期间生成属于类）来调用，可对象目前还没有实例化，也即是还没有内存空间，何来的虚指针，所以构造函数不能是虚函数</strong>；<br> 虚函数的作用在于通过父类的指针或者引用来调用它的成员函数的时候，能够根据动态类型来调用子类相应的成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，所以构造函数不能是虚函数；<br> <img src="https://images2.imgbox.com/8a/7a/R1b9BxQa_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<blockquote> 
 <p>【堆和栈】</p> 
 <ol><li>栈，编译器分配，存储局部变量、函数传参等</li><li>堆，程序控制，动态分配、静态变量、常量、全局变量等，分为静态存储区、常量存储区、自由存储区<br> char *p=“helloworld\n” p在栈上，常量字符串在堆上，p[0]不能修改<br> char p[]=“helloworld\n”; p在栈上，常量字符串在堆上，因为拷贝了一份到数组，因此p[0]能修改</li><li>自由存储区<br> 由malloc等分配的内存块，用free来结束自己的生命<br> 当开辟的空间小于 128K 时，调用 brk()函数，数据段（.data）的最高地址指针 _edata 往高地址推<br> 当开辟的空间大于 128K 时，调用mmap()，在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟<br> 两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</li></ol> 
</blockquote> 
<blockquote> 
 <p>【map】</p> 
</blockquote> 
<table><thead><tr><th></th><th>存储</th><th>空间复杂度</th><th>查找、插入</th><th>key需要定义</th><th></th><th></th></tr></thead><tbody><tr><td>map</td><td>二叉搜索树 有序</td><td>低</td><td>中</td><td>重载operator&lt;</td><td></td><td></td></tr><tr><td>unordered_map</td><td>hash值 无序</td><td>高</td><td>低</td><td>hash_value函数、重载operator==</td><td></td><td></td></tr><tr><td><a href="https://blog.csdn.net/weixin_36392230/article/details/112198887">c++ map是有序还是无序的_C++STL : unordered_map详解</a></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table> 
<blockquote> 
 <p>【内存对齐】</p> 
 <ol><li>结构体、共同体、类</li><li>优点：将数据尽量存储在一个步长内，只需要一次寻址，避免跨步长地存储，执行效率和访问范围提升</li></ol> 
</blockquote> 
<blockquote> 
 <p>【函数指针】</p> 
 <ol><li>函数的地址就是函数名，要将函数作为参数进行传递，必须传递函数名</li><li>声明指针时，必须指定指针指向的数据类型，同样，声明指向函数的指针时，必须指定指针指向的函数类型，这意味着声明应当指定函数的返回类型以及函数的参数列表。</li></ol> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">//定义</span>
<span class="token keyword">double</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// prototype</span>
<span class="token keyword">double</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 指针pf指向的函数， 输入参数为int,返回值为double </span>
<span class="token comment">//函数传参</span>
<span class="token keyword">void</span> <span class="token function">estimate</span><span class="token punctuation">(</span><span class="token keyword">int</span> lines<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 函数指针作为参数传递 </span>
<span class="token comment">//调用</span>
<span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 通过指针调用 推荐的写法 </span>
<span class="token comment">//函数指针数组</span>
<span class="token keyword">double</span> <span class="token punctuation">(</span><span class="token operator">*</span>parray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// 声明一个指针数组，存储三个函数的地址 </span>
</code></pre> 
<blockquote> 
 <p>【宏定义】</p> 
 <ol><li>只是替换，在预编译阶段完成</li><li>方便程序修改，提高运行效率（函数调用/返回耗时</li><li>define中的三个特殊符号：#加双引号，##连接，#@加单引号</li></ol> 
</blockquote> 
<blockquote> 
 <p>【智能指针】</p> 
 <ol><li>使用原因：内存泄露、野指针、异常下的内存泄露</li><li>shared_ptr 多个共享指针指向同一对象</li><li>unique_ptr 同一时间仅一个指针指向该对象</li></ol> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
 <span class="token keyword">class</span> <span class="token class-name">SmartPtr</span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">SmartPtr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token operator">~</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>orig<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 浅拷贝</span>
     SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 浅拷贝</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     T <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
     <span class="token comment">// 将use_count声明成指针是为了方便对其的递增或递减操作</span>
     <span class="token keyword">int</span> <span class="token operator">*</span>use_count<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
 <span class="token class-name">SmartPtr</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
         use_count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
 SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// 只在最后一个对象引用ptr时才释放内存</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span>use_count<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
     <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
         <span class="token keyword">delete</span> use_count<span class="token punctuation">;</span>
         ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
         use_count <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
         cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destructor is called!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
 <span class="token class-name">SmartPtr</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>orig<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     ptr <span class="token operator">=</span> orig<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
     use_count <span class="token operator">=</span> orig<span class="token punctuation">.</span>use_count<span class="token punctuation">;</span>
     <span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>use_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
 SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// 从而防止自身赋值”而导致的提早释放内存</span>
     <span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>use_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
     <span class="token comment">// 将左操作数对象的使用计数减1，若该对象的使用计数减至0，则删除该对象</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span>use_count<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
     <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
         <span class="token keyword">delete</span> use_count<span class="token punctuation">;</span>
         cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Left side object is deleted!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 
     ptr <span class="token operator">=</span> rhs<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
     use_count <span class="token operator">=</span> rhs<span class="token punctuation">.</span>use_count<span class="token punctuation">;</span>
     
     <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>【C++11】<br> 智能指针、基于范围的for循环、关键字auto/size_t/、列表初始化、作用域内枚举（同作用域定义同枚举量）</p> 
</blockquote> 
<ol start="3"><li><a href="https://blog.csdn.net/fangfang12138/article/details/112169376">常用库</a></li></ol> 
<blockquote> 
 <p>string、algorithm、vector、list、map、stack、queue、<a href="https://blog.csdn.net/weixin_42462202/article/details/87537503">deque</a>、<br> 更多参见<a href="http://www.cplusplus.com/reference/" rel="nofollow">http://www.cplusplus.com/reference/</a></p> 
 <ol><li>vector emplace_back()<br> push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素；优先选择移动构造<br> emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</li></ol> 
</blockquote> 
<ol start="4"><li><a href="http://c.biancheng.net/view/6557.html" rel="nofollow">STL</a></li></ol> 
<blockquote> 
 <ol><li>容器<br> <img src="https://images2.imgbox.com/a0/77/iviG6nxU_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<table><thead><tr><th>容器</th><th>查找时间复杂度</th><th>插入时间复杂度</th><th></th><th></th></tr></thead><tbody><tr><td>vector</td><td>n</td><td>n/1</td><td></td><td></td></tr><tr><td>list</td><td>n</td><td>1</td><td>频繁添加/删除元素</td><td></td></tr><tr><td>deque</td><td>n</td><td>n/1</td><td></td><td></td></tr><tr><td>set</td><td>logn</td><td>logn</td><td>红黑树</td><td></td></tr><tr><td>map</td><td>logn</td><td>logn</td><td>红黑树</td><td></td></tr><tr><td>unordered_map</td><td>1</td><td>1</td><td>以空间换时间</td><td></td></tr></tbody></table> 
<blockquote> 
 <ol start="2"><li>迭代器<br> <img src="https://images2.imgbox.com/0a/4b/xhFahefj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ea/65/lY2CK99Y_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="3"><li>函数对象/仿函数</li><li>算法</li><li>适配器<br> <img src="https://images2.imgbox.com/17/b1/6i0DIo5Z_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="6"><li>内存分配器…</li></ol> 
</blockquote> 
<h4><a id="22__259"></a>2.2 数据结构&amp;算法</h4> 
<ol><li>数据结构基础知识（只看基础，具体应用看算法部分）</li></ol> 
<blockquote> 
 <p><a href="https://blog.csdn.net/fangfang12138/article/details/112131601">时空复杂度</a>/<a href="https://blog.csdn.net/fangfang12138/article/details/114485655">链表</a>/数组/字符串/栈/队列/<a href="https://blog.csdn.net/fangfang12138/article/details/114749224">树</a>/<a href="https://blog.csdn.net/fangfang12138/article/details/115694994">图</a></p> 
 <ol><li>图的实现 邻接表（稀疏） 邻接矩阵</li></ol> 
</blockquote> 
<ol start="2"><li><a href="https://blog.csdn.net/fangfang12138/article/details/117707316">算法</a></li></ol> 
<blockquote> 
 <p>排序/查找/幷查集/动态规划/…</p> 
</blockquote> 
<h4><a id="23__266"></a>2.3 线程</h4> 
<ol><li><a href="https://blog.csdn.net/fangfang12138/article/details/119034593">基础知识</a></li></ol> 
<blockquote> 
 <p>线程与进程、线程锁、线程池、线程通信</p> 
 <ol><li>线程<br> join，detach，sleep</li><li>线程锁<br> mutex <strong>lock</strong> try lock与unlock，std::<strong>lock_guard</strong>std::mutex lg(mtx)，std::<strong>unique_lock</strong>std::mutex ul(mtx)</li><li>线程池<br> 充分利用线程资源，避免调度开销，任务队列，唤醒线程notify_one()与notify_all()</li><li>线程通信<br> <strong>互斥量</strong> 锁、<strong>条件变量</strong>可以让等待共享数据条件的线程进入休眠，并在条件达成时唤醒等待线程condition_variable、信号量semaphore</li><li>进程<br> 进程是系统进行任务调度和资源分配的最小单位，进程之间可以并发执行。<br> 线程是程序执行流的最小单元，一个进程可以有多个线程，进程内的线程在其他进程不可见。<br> 线程切换快于进程切换。<br> 任务调度：时间片轮转，每个任务执行一个时间片的时间长度，时间片结束后，强制暂停，执行另一个时间片的程序，等到该任务的时间片再次到来。</li><li>进程通信<br> 管道 父进程生成管道，管道有进有出，fork出子进程，关闭父子的某个进或者出的口<br> 信号 signal.h<br> 共享内存（sys/shm.h，依靠信号量sys/sem.h同步，效率高，但没有同步机制）<br> 信号量 原子操作<br> 套接字<br> 消息队列 独立于发送和接收进程而存在，没有同步、阻塞的问题</li></ol> 
</blockquote> 
<ol start="2"><li><a href="https://www.jianshu.com/p/53c03a8c54f5" rel="nofollow">Lock-Free编程</a></li></ol> 
<blockquote> 
 <p>多线程、线程之间使用共享内存、线程之间不会互相阻塞<br> 这里的无锁，指线程之间不会互相阻塞，未必是互斥量导致的阻塞，比如线程调度<br> Lock—free并非是无阻塞的，而是不使用互斥来达到“锁”的目的</p> 
</blockquote> 
<h4><a id="24__295"></a>2.4 网络</h4> 
<h5><a id="241_TCP_296"></a>2.4.1 TCP</h5> 
<p><a href="https://blog.csdn.net/fangfang12138/article/details/120085636">TCP</a></p> 
<ol><li>三次握手与四次挥手</li></ol> 
<blockquote> 
 <p><strong>TIME_WAIT是主动关闭的一方产生的，一般是client</strong><br> TCP连接中，主动关闭的一方在关闭后的一段时间内保持一个TIME_WAIT的状态。<br> 状态维持时间一般是2MSL（Maximum Segment Lifetime，最大分段寿命），作用有两点：<br> （1）保证连接正常终止<br> （2）保证网络中未接收的数据包正常过期<br> <strong>CLOSE_WAIT是被动关闭的一方产生的，一般是server</strong><br> 接收到关闭连接时，在发出ACK的同时，告知上层，并等待上层处理完后的通知，在此期间保持CLOSE_WAIT状态，在接收到上层通知后，发送FIN，并进入LAST_ACK状态。<br> 若大量出现CLOSE_WAIT，可能是程序响应慢、上层没有close连接等原因。<br> <img src="https://images2.imgbox.com/1d/bb/qhVtKaAR_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ol start="2"><li>与UDP差异</li></ol> 
<blockquote> 
 <p>面向数据流/数据包，是否需要建立连接，可靠性</p> 
</blockquote> 
<ol start="3"><li>TCP粘包</li></ol> 
<blockquote> 
 <p>发送方Nagle 一起发送多个包，接收方缓存未及时读取<br> 发送方关闭Nagle ，接收方循环读取缓存全部<br> UDP没有该问题，因为UDP是基于数据包的，有边界的，TCP是基于数据流的</p> 
</blockquote> 
<ol start="4"><li>TCP重传机制</li></ol> 
<blockquote> 
 <ol><li>丢包<br> 数据、应答</li><li>超时重传<br> RTT 发送数据到接收应答的时间 随网络变化 Linux采样计算加权平均和波动范围<br> RTO 超时重发时间，略大于RTT 动态变化 计算式</li><li>快速重传<br> 1 ACK 收到三个相同ACK<br> 1 重传一个还是重传所有（从第一个丢失的包开始所有）<br> 2 SACK/D-SACK 选择性确认/重复接收<br> 正常 ACK 需要的<br> 丢包 需要的+已接收到的，id大于ACK<br> ACK丢包（超时触发） 需要的+已接收到的，id小于ACK 重复<br> 网络延迟（SACK触发） 需要的+已接收到的，id小于ACK 重复</li></ol> 
</blockquote> 
<h5><a id="242__335"></a>2.4.2 七层网络模型</h5> 
<p>Open System Interconnection Reference Model，缩写为 OSI</p> 
<blockquote> 
 <ol><li>应用：HTTP</li><li>表示：图片视频编解码</li><li>会话：验证，会话管理，断点续传</li><li>传输：TCP/UDP/socket</li><li>网络：路由器/IP/防火墙</li><li>数据链路：网卡/网桥</li><li>物理：网线/集线器</li></ol> 
</blockquote> 
<h5><a id="243_PING_345"></a>2.4.3 PING</h5> 
<p>(Packet Internet Grope)因特网包探索器</p> 
<blockquote> 
 <p>ping是一种计算机网络工具，用来测试数据包能否透过IP协议到达特定主机。<br> ping的运作原理是向目标主机传出一个ICMP echo@要求数据包，并等待接收echo回应数据包。<br> 程序会按时间和成功响应的次数估算丢失数据包率（丢包率）和数据包往返时间（网络时延，Round-trip delay time）。</p> 
</blockquote> 
<p><a href="https://blog.csdn.net/howeverpf/article/details/8954845">基于ping命令的网络故障排查方法</a></p> 
<blockquote> 
 <ol><li>ping 127.1.1.1 TCP/IP协议栈</li><li>ping 192.168.1.10 本机网络适配器</li><li>ping 192.168.1.38 内部局域网</li><li>ping 192.168.1.254 路由器</li><li>//ping 202.114.38.62 一个可达的远程IP，确认该主机已开机并且其防火墙未禁止ping</li><li>//ping localhost 本机hosts文件是否可用</li><li>ping www.baidu.com 的DNS服务是否可用</li></ol> 
</blockquote> 
<h5><a id="244_socket_360"></a>2.4.4 socket</h5> 
<blockquote> 
 <p>对TCP/UDP的封装接口，根据协议组织数据<br> <img src="https://images2.imgbox.com/fa/86/WPXw1leo_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="25_Git_365"></a>2.5 Git</h4> 
<p><a href="https://blog.csdn.net/fangfang12138/article/details/119054534">git</a></p> 
<h4><a id="26_ROS_368"></a>2.6 ROS</h4> 
<ol><li>通信<br> 话题、服务、参数服务器、动作（目标服务、反馈、结果服务）</li><li>实时性</li></ol> 
<blockquote> 
 <p>ROS本身是基于Linux，而Linux并非是实时操作系统，因此某些需要在指定时间完成活执行的任务无法得到保证，从而不能满足实时控制的需求。<br> ROS本身对进程是随机调度的，这导致特别紧急的进程无非最快被调度运行，所以ros需要增加调度策略，让紧急任务更具有实时性。<br> ROS2实时性：DDS。DDS的底层通信机制基于UDP协议或者共享内存机制</p> 
</blockquote> 
<h4><a id="27__376"></a>2.7 自动驾驶</h4> 
<h5><a id="271__377"></a>2.7.1 传感器</h5> 
<blockquote> 
 <ol><li>激光雷达<br> 原理：三角测距、TOF、相位、调频连续被FMCW<br> 分类：功能（测距/测速/成像/）、线数、扫描方式（机械旋转/MEMS 反射镜固定光束/Flash/相控阵 实验室）<br> 问题：鬼影（高反板）、噪点（远处高反板）、雨雪天气/结冰…<br> 测评：测距和反射强度（渐变反射板）的精度和准度，有效感知距离，高反板</li><li>RTK<br> 协议：NTRIP RTCM<br> 时钟相锁：NMEA填充PPS GPRMC传输延迟，PPS脉冲更精确，接收到的NMEA样本时间与NMEA接收时间的offset/PPS整秒的纳秒与0的差，PPS的offset和NMEA的offset的差值过大，导致失锁</li><li>V2X<br> asn.1：用抽象语法描述数据的结构形式，与具体的编码格式无关，同时也不涉及这些数据结构在计算机内如何存放。</li></ol> 
</blockquote> 
<h5><a id="272__388"></a>2.7.2 规划</h5> 
<p><img src="https://images2.imgbox.com/3e/3f/r3tPfRge_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/bc/cc/4IPSuYGP_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/89/5d/82TlRA3A_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/39/1a/3iBCoraO_o.png" alt="请添加图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c5ea0b11dff5ae5b0a1c296aae69a34/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">umi config.js整体defineConfig配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5bbf5a2eae7582ab296c2f1b5c86275c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">web buuctf [SUCTF 2019]Pythonginx1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>