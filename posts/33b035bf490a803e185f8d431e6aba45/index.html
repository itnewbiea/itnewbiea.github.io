<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FFmepg视频解码 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FFmepg视频解码" />
<meta property="og:description" content="1 前言 上一篇文章&lt;FFmpeg下载安装及Windows开发环境设置&gt;介绍了FFmpeg的下载安装及环境配置，本文介绍最简单的FFmpeg视频解码示例。
2 视频解码过程 本文只讨论视频解码。
FFmpeg视频解码的过程比较简单，实际就4步：
打开媒体流获取编码格式；循环获取解码帧显示图像关闭流 实际上前两步即已实现视频解码。
2.1 打开媒体流获取编码格式 1 打开流文件
这个函数avformat_open_input打开一个媒体流并读取其头信息，对于实时流或者不包含头信息的视频流，此函数通过几帧数据分析以获取其信息
此函数支持的媒体流非常广泛，包括本地视频文件、RTSP、TCP码流、UDP码流等等都支持。
m_pFmtCtx = nullptr; ret = avformat_open_input(&amp;m_pFmtCtx, sVideoUrl.c_str(), nullptr, nullptr); 2 在媒体流中寻找视频流
一个媒体流中可能包含了视频、音频、字幕、文本等多个流，到底哪个是我们要的视频流，需要首先确定，这个实际有两种方法，方法1是遍历媒体中所有的流，检查流类型判断哪个是视频流，找到视频流后获取其解码器：
m_nIndexVideo = -1; AVCodec* pAVCodec; //method 1 for (i = 0; i &lt; m_pFmtCtx-&gt;nb_streams; i&#43;&#43;) { if (m_pFmtCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) { m_nIndexVideo = i; break; } } if (m_nIndexVideo &lt; 0) return false; pAVCodec = (AVCodec*)avcodec_find_decoder(m_pFmtCtx-&gt;streams[m_nIndexVideo]-&gt;codecpar-&gt;codec_id); 方法2就更简单，直接av_find_best_stream按视频格式查找最符合的流，并直接返回视频流序号及相应的解码器：
m_nIndexVideo = av_find_best_stream(m_pFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, (const AVCodec**)&amp;pAVCodec, 0); 此两种方法结果是同样的，选择其中一种方法使用即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/33b035bf490a803e185f8d431e6aba45/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-06T09:13:44+08:00" />
<meta property="article:modified_time" content="2023-08-06T09:13:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FFmepg视频解码</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1 前言</h2> 
<p>上一篇文章&lt;<a href="https://blog.csdn.net/hangl_ciom/article/details/132037140?spm=1001.2014.3001.5502">FFmpeg下载安装及Windows开发环境设置</a>&gt;介绍了FFmpeg的下载安装及环境配置，本文介绍最简单的FFmpeg视频解码示例。</p> 
<h2><a id="2__2"></a>2 视频解码过程</h2> 
<p>本文只讨论视频解码。<br> FFmpeg视频解码的过程比较简单，实际就4步：</p> 
<ol><li>打开媒体流获取编码格式；</li><li>循环获取解码帧</li><li>显示图像</li><li>关闭流</li></ol> 
<p>实际上前两步即已实现视频解码。</p> 
<h2><a id="21__11"></a>2.1 打开媒体流获取编码格式</h2> 
<p>1 打开流文件<br> 这个函数avformat_open_input打开一个媒体流并读取其头信息，对于实时流或者不包含头信息的视频流，此函数通过几帧数据分析以获取其信息<br> 此函数支持的媒体流非常广泛，包括本地视频文件、RTSP、TCP码流、UDP码流等等都支持。</p> 
<pre><code class="prism language-c++">m_pFmtCtx = nullptr;
ret = avformat_open_input(&amp;m_pFmtCtx, sVideoUrl.c_str(), nullptr, nullptr);
</code></pre> 
<p>2 在媒体流中寻找视频流<br> 一个媒体流中可能包含了视频、音频、字幕、文本等多个流，到底哪个是我们要的视频流，需要首先确定，这个实际有两种方法，方法1是遍历媒体中所有的流，检查流类型判断哪个是视频流，找到视频流后获取其解码器：</p> 
<pre><code class="prism language-c++">	m_nIndexVideo = -1;
	AVCodec* pAVCodec;
	//method 1
	for (i = 0; i &lt; m_pFmtCtx-&gt;nb_streams; i++)
	{
		if (m_pFmtCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
		{
			m_nIndexVideo = i;
			break;
		}
	}
	if (m_nIndexVideo &lt; 0)
		return false;
	pAVCodec = (AVCodec*)avcodec_find_decoder(m_pFmtCtx-&gt;streams[m_nIndexVideo]-&gt;codecpar-&gt;codec_id);
</code></pre> 
<p>方法2就更简单，直接av_find_best_stream按视频格式查找最符合的流，并直接返回视频流序号及相应的解码器：</p> 
<pre><code class="prism language-c++">	m_nIndexVideo = av_find_best_stream(m_pFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, (const AVCodec**)&amp;pAVCodec, 0);
</code></pre> 
<p>此两种方法结果是同样的，选择其中一种方法使用即可。<br> 3 分配解码器<br> 根据视频流解码格式分配及设置解码器，此处得到的解码器m_pAVCodecCtx即可用于后续的连续帧的解码了：</p> 
<pre><code class="prism language-c++">	m_pAVCodecCtx = avcodec_alloc_context3(pAVCodec);
	if (m_pAVCodecCtx == nullptr)return false;
	ret = avcodec_parameters_to_context(m_pAVCodecCtx, m_pFmtCtx-&gt;streams[m_nIndexVideo]-&gt;codecpar);
</code></pre> 
<p>4 准备解码<br> 调用函数avcodec_open2后，即可开始解码：</p> 
<pre><code class="prism language-c++">	ret = avcodec_open2(m_pAVCodecCtx, pAVCodec, nullptr);
</code></pre> 
<p>至此，一个媒体流的视频流解码工作就准备好了，可以进行获取和解码视频帧了。</p> 
<h2><a id="22__55"></a>2.2 获取解码帧</h2> 
<p>获取解码帧的过程是：取一个原始包(AVPacket)，用以上步骤确定的解码器从这个包里解出视频帧(AVFrame），具体过程如下：<br> 1 用函数av_read_frame从流中取出一个帧包，此包为流中的原始数据，未解码的。<br> 前面说过，一个媒体流中可能包含了多个流，所以av_read_frame获取的数据包不一定是我们想要的视频流包，需要根据这个包所在流的序号来判断是不是属于指定视频流的包。</p> 
<pre><code class="prism language-c++">while (1)
{
	ret = av_read_frame(m_pFmtCtx, m_pPkt);
	if (ret &lt; 0)return nullptr;
	if (m_pPkt-&gt;stream_index == m_nIndexVideo)
		break;
}
</code></pre> 
<p>2 解码这个包，获取一帧解码图像<br> 采用如下两个函数的组合，用解码器m_pAVCodecCtx对这个包进行解码，获得AVFrame。</p> 
<pre><code class="prism language-c++">	avcodec_send_packet(m_pAVCodecCtx, m_pPkt);
	avcodec_receive_frame(m_pAVCodecCtx, m_pFrame);
</code></pre> 
<p>此时获得的m_pFrame即为已解码出的一幅视频帧，为一个AVFrame结构，此结构中包含了图像数据、宽高、格式等等信息，可以用于显示、存储等后续工作。</p> 
<h2><a id="23__75"></a>2.3 显示图像帧</h2> 
<p>有很多软件架构支持直接对AVFrame结构进行显示，如SDL、D3DX等等。<br> 我们这里用最基本的RGB图像方式来显示这个AVFrame，但AVFrame的图像数据大多数是YUV格式，需要做YUV-&gt;RGB转换，当然可以自己找公式转换，实际上FFmpeg对此也提供了方便的转换方法sws_scale：</p> 
<pre><code class="prism language-c++">	int ret;
	int wid, hei;
	wid = pFrame-&gt;width;
	hei = pFrame-&gt;height;
	if (m_pSwsCtx == nullptr)
	{
		m_pSwsCtx = sws_getContext(wid, hei, (AVPixelFormat)pFrame-&gt;format, 
			wid, hei, AV_PIX_FMT_RGB24, SWS_POINT, nullptr, nullptr, nullptr);
	}
	uint8_t* data[1];
	data[0] = pDib;
	int lines[1] = { wid * 3 };
	ret = sws_scale(m_pSwsCtx, pFrame-&gt;data, pFrame-&gt;linesize, 0, hei, data, lines);
</code></pre> 
<p>这样转出的pDib就是24位RGB的图像了，之后的显示此处就不再赘述了。</p> 
<h2><a id="24__94"></a>2.4 关闭流</h2> 
<p>以上打开的流，以及分配的各种资源，最后不用时记得要释放，如</p> 
<pre><code class="prism language-c++">	if (m_pFmtCtx != nullptr)
	{
		avformat_close_input(&amp;m_pFmtCtx);
		m_pFmtCtx = nullptr;
	}
	if (m_pAVCodecCtx != nullptr)
	{
		avcodec_close(m_pAVCodecCtx);
		avcodec_free_context(&amp;m_pAVCodecCtx);
		m_pAVCodecCtx = nullptr;
	}
</code></pre> 
<h2><a id="3__109"></a>3 示例</h2> 
<p>下图为程序运行视频解码结果。<br> <img src="https://images2.imgbox.com/61/73/eINnRZOt_o.png" alt="在这里插入图片描述"><br> 以上代码的完整工程供参考：<a href="https://download.csdn.net/download/hangl_ciom/88152736">https://download.csdn.net/download/hangl_ciom/88152736</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/28936f8f0de89de976e0baeed2d7b973/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mediasoup Lite ICE实现说明</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0730e7651127c7e271157e23aa745482/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot实现文件记录日志，日志文件自动归档和压缩</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>