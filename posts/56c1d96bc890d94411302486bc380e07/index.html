<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>激光雷达点云基础-点云滤波算法与点云配准算法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="激光雷达点云基础-点云滤波算法与点云配准算法" />
<meta property="og:description" content="激光雷达点云处理在五年前就做了较多的工作，最近有一些新的接触发现激光雷达代码原理五年前未见重大更新，或许C&#43;&#43;与激光雷达结合本身就是比较高的技术门槛。深度学习调包侠在硬核激光雷达技术面前可以说是完全的自愧不如啊。
1、点云滤波 在获取点云数据时，由于设备精度、操作者经验、环境因素等带来的影响，点云数据中将不可避免地出现一些噪声点。而滤波的作用就是利用数据的低频特性剔除离群数据，并进行数据平滑或者提取特定频段特征。
对应的问题是什么时候需要做点云滤波？大概可以分为以下四个方面：1、点云数据密度不规则需要平滑；2、因为遮挡等问题造成离群点需要去除；3、大量数据需要进行下采样；4、噪音数据需要去除。
1.1 常用的点云滤波器： 直通滤波器 条件滤波器
高斯滤波器 双边滤波器 统计滤波器 半径滤波器 频率滤波器
体素滤波器
从功能层面以上点云滤波器可以分为三类使用：直通和条件滤波用于预处理的最前端提取出感兴趣区域；体素滤波用于对密集点云进行下采样减少数据量；其他滤波器用于平滑点云同时去除离散点。
1.2 点云滤波器介绍： 直通滤波器 原理：在点云的指定维度上设置一个阈值范围，将这个维度上的数据分为在阈值范围内与不在阈值范围内，从而选择过滤与否。能够快速过滤掉用户自定义区间范围内的点云。
在实际应用中，由于激光扫描采集的距离较远，但是根据功能需求的不同可能只关心一定区域内的数据，比如低速物流车的运营场景，可能在X方向只关心前后60米，Y方向只关心左右20米的范围。此时就可以利用直通滤波器提取出感兴趣区域，可较快剔除部分点云，达到第一步粗处理的目的。
条件滤波器 原理：通过设定滤波条件进行滤波，类似于分段函数，判断点云是否在规则的范围则中，如果不在则舍弃。上述的直通滤波器就是一种较简单的条件滤波器。
高斯滤波器 原理：采用加权平均方式的一种非线性滤波器，在指定域内的权重是根据欧式距离的高斯分布，通过权重加权平均的方式得到当前点的滤波后的点。
特点：利用标准差去噪，适用于呈正态分布的数据平滑效果较好，但是边缘角点也会被较大的平滑。
双边滤波器 原理：通过取邻近采样点的加权平均来修正当前采样点的位置，在高斯滤波器只考虑空间域点的位置基础上，增加了维度上的权重。一定程度上弥补了高斯滤波的缺点。
特点：既有效地对空间三维模型表面进行降噪，又可以保持点云数据中的几何特征信息，避免三维点云数据被过渡光滑。但是只适用于有序点云。关于高斯滤波和双边滤波，本身在图像领域其实已经有广泛的应用，具体的算法原理可以参考保边滤波–bilateral filter and guided filter
。
体素滤波器 原理：通过对输入的点云数据创建一个三维体素栅格，然后在每个体素内，用体素中所有点的重心来近似显示体素中的其他点，这样该体素内所有点就用一个重心点最终表示。也有另外一种相似的表达形式：利用每一个体素立方体的中心来近似该体素立方体内的所有点，相比上一种方法计算速度较快，但是损失了原始点云局部形态的精细度。
特点：可以达到向下采样同时不破坏点云本身几何结构的功能。点云几何结构不仅是宏观的几何外形，也包括其微观的排列方式，比如横向相似的尺寸，纵向相同的距离。随机下采样虽然效率比体素网格滤波器高，但会破坏点云微观结构。
以上几种滤波器不会针对离散群点做相关操作，但是实际上离散群点这类噪声点会对整体算法带来比较严重的干扰。离散群点会破坏点云的表达准确性。使得局部点云特征（例如表面法线或曲率变化）的估计变得非常复杂，这往往导致错误的估计结果，从而可能导致点云配准失败。
统计滤波器 原理：对每个点的邻域进行一个统计分析，并修剪掉那些不符合一定标准的点。我们的稀疏离群点移除方法基于在输入数据中对点到临近点的距离分布的计算。
具体方法如下：计算每个点到其最近的k个点平均距离，（假设得到的结果是一个高斯分布，其形状是由均值和标准差决定），那么平均距离在标准范围之外的点，可以被定义为离群点并从数据中去除。
特点：主要是根据密度去除离群点，对密度差异较大的离群点去除效果较好。
半径滤波器 原理：与统计滤波器类似，只是操作更加暴力直观，根据空间点半径范围临近点数量来滤波。
具体方法如下：
在点云数据中以某点为中心画一个圆计算落在该圆中点的数量，当数量大于给定值时，则保留该点，数量小于给定值则剔除该点。此算法运行速度快，依序迭代留下的点一定是最密集的，但是圆的半径和圆内点的数目都需要人工指定。
特点：用于去除离群点，在一定程度上可以用来筛选边缘点。
频率滤波器 原理：在点云处理中，点云法线向量差为点云所表达的信号。用点云的曲率来表示频率信息，如果某处点云曲率大，则点云表达的是一个变化高频的信号。如果点云曲率小，则点云表达的是一个不变低频的信号。例如：地面曲率小，它表达的信息量也小；障碍物处曲率大，频率就会更高。
以DoN算法为例，根据不同尺度下法向量特征的差异性，利用pcl::DifferenceOfNormalsEstimation实现点云分割，在处理有较大尺度变化的场景点云分割效果较好，利用不同支撑半径去估算同一点的两个单位法向量，单位法向量的差定义DoN特征。具体如下：在小尺度上计算点云法线1，在大尺度上计算点云法线2，法线1-法线2，滤去3中值较小的点，根据第三步得到的法线差，进行欧式分割。
特点：在小尺度上是可以对高频信息进行检测的，可以很好的小尺度高频信息。其在大规模点云中优势尤其明显。
DoN特征源于观察到基于所给半径估计的表面法向量可以反映曲面的内在几何特征，因此这种分割算法是基于法线估计的，需要计算点云中某一点的法线估计。而通常在计算法线估计的时候都会用到邻域信息，很明显邻域大小的选取会影响法线估计的结果。
而在DoN算法中，邻域选择的大小就被称为support radius。对点云中某一点选取不同的支持半径，即可以得到不同的法线估计，而法线之间的差异，就是是所说的法线差异。
2、点云配准匹配算法 2.1 什么是点云配准 点云配准是指将多个点云数据集在相同坐标系下进行对齐的过程，使得它们在空间中具有一致的位置和姿态。在点云配准中，需要估计点云之间的转换关系，包括平移、旋转和尺度等变换。点云配准在三维重建、物体检测、环境感知、机器人导航和虚拟现实等领域有着广泛的应用。点云配准的主要目标是最小化点云之间的误差，通常通过匹配点云中的对应点来实现。在匹配点云时，需要考虑到点云中的噪声、不完整性和采样密度等问题，以及在不同的场景下可能出现的变形和运动。常见的点云配准方法包括ICP（Iterative Closest Point）和NDT（Normal Distribution Transform）。
2.2 点云ICP算法 点云ICP算法是一种经典的点云配准算法，其全称为Iterative Closest Point算法，是一种迭代优化的方法，用于将两个或多个点云数据集对齐。该算法通过迭代找到最优的刚体变换矩阵，使得两个点云之间的重叠部分最大化，从而实现点云的配准。
2.2.1 ICP算法简介 ICP算法的基本思路是：假设我们有得到初始的P、Q两部分点云。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/56c1d96bc890d94411302486bc380e07/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-31T15:40:45+08:00" />
<meta property="article:modified_time" content="2023-10-31T15:40:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">激光雷达点云基础-点云滤波算法与点云配准算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>激光雷达点云处理在五年前就做了较多的工作，最近有一些新的接触发现激光雷达代码原理五年前未见重大更新，或许C++与激光雷达结合本身就是比较高的技术门槛。深度学习调包侠在硬核激光雷达技术面前可以说是完全的自愧不如啊。</p> 
<h4><a id="1_1"></a>1、点云滤波</h4> 
<p>在获取点云数据时，由于设备精度、操作者经验、环境因素等带来的影响，点云数据中将不可避免地出现一些噪声点。而滤波的作用就是利用数据的低频特性剔除离群数据，并进行数据平滑或者提取特定频段特征。</p> 
<p>对应的问题是什么时候需要做点云滤波？大概可以分为以下四个方面：1、点云数据密度不规则需要平滑；2、因为遮挡等问题造成离群点需要去除；3、大量数据需要进行下采样；4、噪音数据需要去除。</p> 
<h5><a id="11__6"></a>1.1 常用的点云滤波器：</h5> 
<ul><li> <p>直通滤波器 条件滤波器</p> </li><li> <p>高斯滤波器 双边滤波器 统计滤波器 半径滤波器 频率滤波器</p> </li><li> <p>体素滤波器</p> </li></ul> 
<p>从功能层面以上点云滤波器可以分为三类使用：直通和条件滤波用于预处理的最前端提取出感兴趣区域；体素滤波用于对密集点云进行下采样减少数据量；其他滤波器用于平滑点云同时去除离散点。</p> 
<h5><a id="12__14"></a>1.2 点云滤波器介绍：</h5> 
<ul><li>直通滤波器</li></ul> 
<p>原理：在点云的指定维度上设置一个阈值范围，将这个维度上的数据分为在阈值范围内与不在阈值范围内，从而选择过滤与否。能够快速过滤掉用户自定义区间范围内的点云。</p> 
<p>在实际应用中，由于激光扫描采集的距离较远，但是根据功能需求的不同可能只关心一定区域内的数据，比如低速物流车的运营场景，可能在X方向只关心前后60米，Y方向只关心左右20米的范围。此时就可以利用直通滤波器提取出感兴趣区域，可较快剔除部分点云，达到第一步粗处理的目的。</p> 
<ul><li>条件滤波器</li></ul> 
<p>原理：通过设定滤波条件进行滤波，类似于分段函数，判断点云是否在规则的范围则中，如果不在则舍弃。上述的直通滤波器就是一种较简单的条件滤波器。</p> 
<ul><li>高斯滤波器</li></ul> 
<p>原理：采用加权平均方式的一种非线性滤波器，在指定域内的权重是根据欧式距离的高斯分布，通过权重加权平均的方式得到当前点的滤波后的点。</p> 
<p>特点：利用标准差去噪，适用于呈正态分布的数据平滑效果较好，但是边缘角点也会被较大的平滑。</p> 
<ul><li>双边滤波器</li></ul> 
<p>原理：通过取邻近采样点的加权平均来修正当前采样点的位置，在高斯滤波器只考虑空间域点的位置基础上，增加了维度上的权重。一定程度上弥补了高斯滤波的缺点。</p> 
<p>特点：既有效地对空间三维模型表面进行降噪，又可以保持点云数据中的几何特征信息，避免三维点云数据被过渡光滑。但是只适用于有序点云。关于高斯滤波和双边滤波，本身在图像领域其实已经有广泛的应用，具体的算法原理可以参考<a href="https://blog.csdn.net/NCU_wander/article/details/105945773">保边滤波–bilateral filter and guided filter<br> </a>。</p> 
<ul><li>体素滤波器</li></ul> 
<p>原理：通过对输入的点云数据创建一个三维体素栅格，然后在每个体素内，用体素中所有点的重心来近似显示体素中的其他点，这样该体素内所有点就用一个重心点最终表示。也有另外一种相似的表达形式：利用每一个体素立方体的中心来近似该体素立方体内的所有点，相比上一种方法计算速度较快，但是损失了原始点云局部形态的精细度。</p> 
<p>特点：可以达到向下采样同时不破坏点云本身几何结构的功能。点云几何结构不仅是宏观的几何外形，也包括其微观的排列方式，比如横向相似的尺寸，纵向相同的距离。随机下采样虽然效率比体素网格滤波器高，但会破坏点云微观结构。</p> 
<p><mark>以上几种滤波器不会针对离散群点做相关操作，但是实际上离散群点这类噪声点会对整体算法带来比较严重的干扰。离散群点会破坏点云的表达准确性。使得局部点云特征（例如表面法线或曲率变化）的估计变得非常复杂，这往往导致错误的估计结果，从而可能导致点云配准失败。</mark></p> 
<ul><li>统计滤波器</li></ul> 
<p>原理：对每个点的邻域进行一个统计分析，并修剪掉那些不符合一定标准的点。我们的稀疏离群点移除方法基于在输入数据中对点到临近点的距离分布的计算。</p> 
<p>具体方法如下：计算每个点到其最近的k个点平均距离，（假设得到的结果是一个高斯分布，其形状是由均值和标准差决定），那么平均距离在标准范围之外的点，可以被定义为离群点并从数据中去除。<br> 特点：主要是根据密度去除离群点，对密度差异较大的离群点去除效果较好。</p> 
<ul><li>半径滤波器</li></ul> 
<p>原理：与统计滤波器类似，只是操作更加暴力直观，根据空间点半径范围临近点数量来滤波。</p> 
<p>具体方法如下：</p> 
<p>在点云数据中以某点为中心画一个圆计算落在该圆中点的数量，当数量大于给定值时，则保留该点，数量小于给定值则剔除该点。此算法运行速度快，依序迭代留下的点一定是最密集的，但是圆的半径和圆内点的数目都需要人工指定。</p> 
<p>特点：用于去除离群点，在一定程度上可以用来筛选边缘点。</p> 
<div align="center"> 
 <img width="800" src="https://images2.imgbox.com/c4/18/av7KsCw9_o.png"> 
</div> 
<ul><li>频率滤波器</li></ul> 
<p>原理：在点云处理中，点云法线向量差为点云所表达的信号。用点云的曲率来表示频率信息，如果某处点云曲率大，则点云表达的是一个变化高频的信号。如果点云曲率小，则点云表达的是一个不变低频的信号。例如：地面曲率小，它表达的信息量也小；障碍物处曲率大，频率就会更高。</p> 
<p>以DoN算法为例，根据不同尺度下法向量特征的差异性，利用pcl::DifferenceOfNormalsEstimation实现点云分割，在处理有较大尺度变化的场景点云分割效果较好，利用不同支撑半径去估算同一点的两个单位法向量，单位法向量的差定义DoN特征。具体如下：在小尺度上计算点云法线1，在大尺度上计算点云法线2，法线1-法线2，滤去3中值较小的点，根据第三步得到的法线差，进行欧式分割。</p> 
<p>特点：在小尺度上是可以对高频信息进行检测的，可以很好的小尺度高频信息。其在大规模点云中优势尤其明显。</p> 
<p>DoN特征源于观察到基于所给半径估计的表面法向量可以反映曲面的内在几何特征，因此这种分割算法是基于法线估计的，需要计算点云中某一点的法线估计。而通常在计算法线估计的时候都会用到邻域信息，很明显邻域大小的选取会影响法线估计的结果。</p> 
<p>而在DoN算法中，邻域选择的大小就被称为support radius。对点云中某一点选取不同的支持半径，即可以得到不同的法线估计，而法线之间的差异，就是是所说的法线差异。</p> 
<div align="center"> 
 <img width="800" src="https://images2.imgbox.com/c8/d8/YpmgcRhM_o.png"> 
</div> 
<h4><a id="2_79"></a>2、点云配准匹配算法</h4> 
<h5><a id="21__80"></a>2.1 什么是点云配准</h5> 
<p>点云配准是指将多个点云数据集在相同坐标系下进行对齐的过程，使得它们在空间中具有一致的位置和姿态。在点云配准中，需要估计点云之间的转换关系，包括平移、旋转和尺度等变换。点云配准在三维重建、物体检测、环境感知、机器人导航和虚拟现实等领域有着广泛的应用。点云配准的主要目标是最小化点云之间的误差，通常通过匹配点云中的对应点来实现。在匹配点云时，需要考虑到点云中的噪声、不完整性和采样密度等问题，以及在不同的场景下可能出现的变形和运动。常见的点云配准方法包括ICP（Iterative Closest Point）和NDT（Normal Distribution Transform）。</p> 
<h5><a id="22_ICP_84"></a>2.2 点云ICP算法</h5> 
<p>点云ICP算法是一种经典的点云配准算法，其全称为Iterative Closest Point算法，是一种迭代优化的方法，用于将两个或多个点云数据集对齐。该算法通过迭代找到最优的刚体变换矩阵，使得两个点云之间的重叠部分最大化，从而实现点云的配准。</p> 
<h6><a id="221_ICP_88"></a>2.2.1 ICP算法简介</h6> 
<p>ICP算法的基本思路是：假设我们有得到初始的P、Q两部分点云。</p> 
<ul><li>对P中的每个点，在Q中找到匹配的最近点（涉及到大量点云，会涉及到KD树的点云切割）</li><li>计算两组点的质心和去质心距离，使用SVD分解H求出R，然后用R表示t.（涉及到具体数学原理的推导以及SVD的求解方式方法）</li><li>利用得到的位姿作用于P</li><li>迭代，直到迭代次数上限或者收敛<br> 对于以上四步更为详细的论证过程可以参考博客：<a href="https://zhuanlan.zhihu.com/p/579795520" rel="nofollow">点云配准ICP&amp;NDT<br> </a></li></ul> 
<p>ICP算法迭代停止的条件通常有以下几种：</p> 
<ul><li>最大迭代次数：设定一个最大的迭代次数，当达到该次数后，算法强制停止迭代。</li><li>目标误差：设定一个目标误差阈值，当当前迭代的误差小于该阈值时，算法停止迭代。</li><li>迭代误差的变化率：如果当前迭代与上一次迭代的误差变化率小于设定的阈值，算法停止迭代。</li><li>迭代后的点云匹配误差小于阈值：如果点云匹配误差小于设定的阈值，算法停止迭代。</li></ul> 
<p>根据不同应用场景和需求，选择适合的停止条件可以提高算法的效率和精度。</p> 
<h6><a id="222_ICP_105"></a>2.2.2 ICP算法优缺点以及迭代版本</h6> 
<p>ICP算法的优点：简单易懂、容易实现，并且对于初始位姿的依赖性较低。ICP算法的缺点主要表现在以下几个方面：</p> 
<ul><li>对于变换矩阵初值的敏感度较高，如果初值选的不好，则有可能会陷入局部最优解。</li><li>ICP算法只能对刚性变换进行配准，对于非刚性变换无法适用。</li><li>ICP算法的时间复杂度较高，对于大规模的点云配准需要消耗大量的计算资源和时间。</li><li>当点云之间没有很好的匹配时，ICP算法的配准结果会受到较大的影响，容易出现误匹配。</li></ul> 
<p>当前针对ICP算法已有的缺陷，出现比较多的改进版本的算法，此部分算法不在本文章的核心关切范围之内，在本文仲不予以赘述。</p> 
<h5><a id="23_NDT_115"></a>2.3 点云NDT算法</h5> 
<p>点云NDT算法（Normal Distribution Transform）是一种基于高斯分布的点云配准方法。与ICP算法相比，NDT算法更适用于不规则形状、噪声和部分遮挡的场景。</p> 
<h6><a id="231_NDT_119"></a>2.3.1 NDT算法原理</h6> 
<p>NDT原理：将点云转换为高斯分布的函数形式，通过计算不同高斯分布函数之间的匹配来进行点云配准。具体来说，算法首先将一个点云转换为三维高斯分布函数（即ND分布），然后通过最小化两个点云之间的ND分布函数之间的KL散度来进行点云配准。具体来说，NDT算法首先将原始点云数据离散化为一个三维的网格（voxel grid），并对每个网格中的点云进行采样和特征提取。这里采用了点云法向量作为特征，通过计算每个网格中点云的均值和协方差矩阵，可以得到一个高斯分布，即一个GMM。NDT算法会将目标点云和参考点云都转化成GMM的形式，然后计算两个GMM之间的KL散度，用于评估它们之间的相似度。在计算KL散度时，NDT算法采用了一种高效的方法，即通过将每个网格中心点的高斯分布变换到参考点云坐标系下，可以大大减少计算复杂度。最后，NDT算法通过最小化两个GMM之间的KL散度来计算相对位姿变换，得到一个最优的刚体变换矩阵，从而实现点云配准。由于NDT算法采用了高效的计算方法，因此在处理大规模点云数据时具有较高的效率和精度。</p> 
<div align="center"> 
 <img src="https://images2.imgbox.com/76/f1/IKN2Cvor_o.png"> 
</div> 
<h6><a id="231_ICPNDT_124"></a>2.3.1 ICP与NDT的区别？</h6> 
<p>ICP和NDT是点云配准领域中两种常用的方法，它们在原理和实现方式上有所不同。在原理、适用场景、优缺点等方面有着不同的特点</p> 
<p>算法原理：<br> ICP算法是基于最小二乘法的迭代算法，通过不断迭代计算源点云与目标点云之间的最小距离，直到满足停止条件为止；NDT算法是基于高斯分布的统计配准方法，通过将点云离散化为一组高斯分布，计算目标点云和源点云之间的匹配程度，通过最大化匹配程度来实现配准。</p> 
<p>点云数据处理：<br> ICP算法直接使用点云数据，而NDT算法需要将点云数据转化为高斯分布。<br> 计算效率：在点云数量较少时，ICP算法的计算速度较快，但在点云数量较多时，ICP算法的计算复杂度会急剧增加，计算速度会变慢；NDT算法的计算速度相对较慢，但是它在处理大规模点云数据时有优势。</p> 
<p>适用场景不同：<br> ICP算法适用于点云之间存在较小变形和噪声的场景，如室内环境、车辆周围环境等，对数据噪声和变形比较敏感。<br> NDT算法适用于大型点云数据的配准，能够应对点云之间存在较大变形和噪声的情况，如地图构建、机器人导航等。</p> 
<p>优缺点不同：<br> ICP算法优点在于简单易实现、迭代速度快，但对初始位姿敏感，容易陷入局部最优解。NDT算法优点在于能够处理大型点云数据、对数据噪声和变形不敏感，具有较高的配准精度，但需要进行点云的离散化处理，计算速度相对较慢。ICP和NDT都有各自的优势和适用场景，在实际应用中，应根据具体情况选择合适的方法来进行点云配准。同时，还可以结合两种方法的优点，通过组合使用来提高配准精度和速度。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e140f71ce58a3604660378251f988e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用 docker-compose 部署 SpringBoot 项目 &amp; nginx 部署前端</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/766532c7f1efd9f4de520ebd901a31f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用STM32实现按键控制LED灯</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>