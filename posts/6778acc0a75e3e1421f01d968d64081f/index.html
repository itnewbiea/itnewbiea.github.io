<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CocosCreator-3.6 三步解决2D碰撞监听 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CocosCreator-3.6 三步解决2D碰撞监听" />
<meta property="og:description" content="目录
一，开启碰撞监听
二，开启碰撞回调
三，注册回调函数
测试
其他
之前做的是2.x版本的，最近切到了3.6，记录一下
2D 碰撞回调 · Cocos Creator版本3.6本文只监听，不产生实际碰撞 一，开启碰撞监听 项目-项目设置-功能剪裁
Box2D 物理模块需要先在 Rigidbody 中 开启碰撞监听，才会有相应的回调产生。本文只监听，不产生实际碰撞，选择了内置2D，没有添加Rigidbody2D组件
二，开启碰撞回调 节点添加BoxCollider2D组件
Builtin 物理模块只需要有碰撞体组件就可以产生碰撞回调。（本文） Sensor指明碰撞组件是否为传感器类型，传感器类型的碰撞组件会产生碰撞回调，但是不会发生物理碰撞效果PS:脚本挂在勾选了此项的节点这里Box2D开启方法为，在 Rigidbody2D 的 属性检查器 勾选 EnabledContactListener 属性（需要添加Rigidbody2D组件） 三，注册回调函数 注册方式：
通过指定的 collider 注册通过 2D 物理系统注册一个全局的回调函数 Builtin 2D 物理模块只会发送 BEGIN_CONTACT 和 END_CONTACT 回调消息
创建脚本Player.ts
import { _decorator, Component, Node, BoxCollider2D, Contact2DType, PhysicsSystem2D, Collider2D, IPhysics2DContact } from &#39;cc&#39;; const { ccclass, property } = _decorator; @ccclass(&#39;Player&#39;) export class Player extends Component { start() { // 注册单个碰撞体的回调函数 let collider = this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6778acc0a75e3e1421f01d968d64081f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-20T22:46:32+08:00" />
<meta property="article:modified_time" content="2022-09-20T22:46:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CocosCreator-3.6 三步解决2D碰撞监听</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E5%BC%80%E5%90%AF%E7%A2%B0%E6%92%9E%E7%9B%91%E5%90%AC-toc" style="margin-left:80px;"><a href="#%E4%B8%80%EF%BC%8C%E5%BC%80%E5%90%AF%E7%A2%B0%E6%92%9E%E7%9B%91%E5%90%AC" rel="nofollow">一，开启碰撞监听</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E5%BC%80%E5%90%AF%E7%A2%B0%E6%92%9E%E5%9B%9E%E8%B0%83-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%EF%BC%8C%E5%BC%80%E5%90%AF%E7%A2%B0%E6%92%9E%E5%9B%9E%E8%B0%83" rel="nofollow">二，开启碰撞回调</a></p> 
<p id="%E4%B8%89%EF%BC%8C%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E4%B8%89%EF%BC%8C%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" rel="nofollow">三，注册回调函数</a></p> 
<p id="%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95" rel="nofollow">测试</a></p> 
<p id="%E5%85%B6%E4%BB%96-toc" style="margin-left:80px;"><a href="#%E5%85%B6%E4%BB%96" rel="nofollow">其他</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>之前做的是2.x版本的，最近切到了3.6，记录一下</p> 
<ul><li><a href="https://docs.cocos.com/creator/manual/zh/physics-2d/physics-2d-contact-callback.html" rel="nofollow" title="2D 碰撞回调 · Cocos Creator">2D 碰撞回调 · Cocos Creator</a></li><li>版本3.6</li><li>本文只监听，不产生实际碰撞</li></ul> 
<h4 id="%E4%B8%80%EF%BC%8C%E5%BC%80%E5%90%AF%E7%A2%B0%E6%92%9E%E7%9B%91%E5%90%AC">一，<strong>开启碰撞监听</strong></h4> 
<p>项目-项目设置-功能剪裁</p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/4a/fb/EF9OpWd3_o.png" width="456"></p> 
<p> Box2D 物理模块需要先在 <a href="https://docs.cocos.com/creator/manual/zh/physics-2d/physics-2d-rigid-body.html" rel="nofollow" title="Rigidbody">Rigidbody</a> 中 <strong>开启碰撞监听</strong>，才会有相应的回调产生。本文只监听，不产生实际碰撞，选择了内置2D，没有添加Rigidbody2D<strong>组件</strong></p> 
<h4 id="%E4%BA%8C%EF%BC%8C%E5%BC%80%E5%90%AF%E7%A2%B0%E6%92%9E%E5%9B%9E%E8%B0%83">二，开启碰撞回调</h4> 
<p>节点添加<strong>BoxCollider2D</strong>组件</p> 
<ul><li>Builtin 物理模块只需要有碰撞体组件就可以产生碰撞回调。（本文） 
  <ul><li><img alt="" height="370" src="https://images2.imgbox.com/cc/c1/knd23pfC_o.png" width="462"></li><li><strong>Sensor</strong>指明碰撞组件是否为传感器类型，传感器类型的碰撞组件会产生碰撞回调，但是不会发生物理碰撞效果<span style="color:#fe2c24;">PS:脚本挂在勾选了此项的节点这里</span></li></ul></li><li>Box2D开启方法为，在 <strong>Rigidbody2D</strong> 的 <strong>属性检查器</strong> 勾选 <strong>EnabledContactListener</strong> 属性（需要添加<strong>Rigidbody2D</strong>组件） 
  <ul><li><img alt="" height="227" src="https://images2.imgbox.com/8b/b6/tPas4kWM_o.png" width="166"></li></ul></li></ul> 
<h4 id="%E4%B8%89%EF%BC%8C%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">三，注册回调函数</h4> 
<p>注册方式：</p> 
<ol><li>通过指定的 collider 注册</li><li>通过 2D 物理系统注册一个全局的回调函数</li></ol> 
<p>Builtin 2D 物理模块只会发送 BEGIN_CONTACT 和 END_CONTACT 回调消息</p> 
<p>创建脚本Player.ts</p> 
<pre><code class="language-TypeScript">import { _decorator, Component, Node, BoxCollider2D, Contact2DType, PhysicsSystem2D, Collider2D, IPhysics2DContact } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('Player')
export class Player extends Component {

    start() {

        // 注册单个碰撞体的回调函数
        let collider = this.getComponent(BoxCollider2D);
        if (collider) {
            // Builtin 2D 物理模块只会发送 BEGIN_CONTACT 和 END_CONTACT 回调消息。
            collider.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);
            collider.on(Contact2DType.END_CONTACT, this.onEndContact, this);
            // collider.on(Contact2DType.PRE_SOLVE, this.onPreSolve, this);
            // collider.on(Contact2DType.POST_SOLVE, this.onPostSolve, this);
        }

        // 注册全局碰撞回调函数
        if (PhysicsSystem2D.instance) {
            // Builtin 2D 物理模块只会发送 BEGIN_CONTACT 和 END_CONTACT 回调消息。
            PhysicsSystem2D.instance.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);
            PhysicsSystem2D.instance.on(Contact2DType.END_CONTACT, this.onEndContact, this);
            // PhysicsSystem2D.instance.on(Contact2DType.PRE_SOLVE, this.onPreSolve, this);
            // PhysicsSystem2D.instance.on(Contact2DType.POST_SOLVE, this.onPostSolve, this);
        }
    }

    /**
     * 只在两个碰撞体开始接触时被调用一次
     * @param selfCollider 指的是回调脚本的节点上的碰撞体
     * @param otherCollider 指的是发生碰撞的另一个碰撞体
     * @param contact 碰撞主要的信息, 位置和法向量, 带有刚体的本地坐标来， 
     */
    onBeginContact(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) {
        console.log('onBeginContact');

        // contact.getWorldManifold在 Builtin 物理模块这个参数为空
        // const worldManifold = contact.getWorldManifold();
        // // 碰撞点数组
        // const points = worldManifold.points;
        // // 碰撞点上的法向量
        // const normal = worldManifold.normal;
    }
    onEndContact(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) {
        // 只在两个碰撞体结束接触时被调用一次
        console.log('onEndContact');
    }
    onPreSolve(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) {
        // 每次将要处理碰撞体接触逻辑时被调用
        console.log('onPreSolve');
    }
    onPostSolve(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) {
        // 每次处理完碰撞体接触逻辑时被调用
        console.log('onPostSolve');
    }
}

</code></pre> 
<h4 id="%E6%B5%8B%E8%AF%95">测试</h4> 
<p>当角色和金币相撞时触发</p> 
<p><img alt="" height="382" src="https://images2.imgbox.com/c8/aa/4ZSdHeoq_o.png" width="496"></p> 
<h4 id="%E5%85%B6%E4%BB%96">其他</h4> 
<pre><code class="language-TypeScript">        // 节点名字和标签
        console.log(otherCollider.node.name);
        console.log(otherCollider.tag);</code></pre> 
<p>碰撞后消失的两种方法</p> 
<pre><code class="language-TypeScript">        if (otherCollider.tag == 3) {
            // 不会从内存中释放, 默认传入false, 会清空节点上绑定的事件和 action 
            // 文档：https://docs.cocos.com/creator/manual/zh/scripting/basic-node-api.html?h=removefromparent
            // otherCollider.node.removeFromParent();
            
            // 节点不再使用
            otherCollider.node.destroy();
        }</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2be9256ebf89d3af2ccd5916520a480/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">初学者学python用什么软件,python编程入门软件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b35b6f36e8f6820f71e77ce0d19f28e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JUC第一讲：juc并发包深入理解(P6熟练 P7精通)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>