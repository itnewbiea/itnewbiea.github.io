<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>10个超级实用的Python模块，建议收藏！！ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="10个超级实用的Python模块，建议收藏！！" />
<meta property="og:description" content="Python标准库有超过200个模块，程序员可以在他们的程序中导入和使用，虽然普通程序员对其中许多模块都有一些经验，但很可能有一些好用的模块他们仍然没有注意到。
今天小编就来给大家推荐几个特别好用的Python模块，其中有一部分是在Pandas当中的，方便大家使用了之后更加高效地来进行数据分析。
xmltodict 首先给大家介绍的第三方模块叫做xmltodict，我们从名字上就可以非常直观地看出，该模块的作用在于将xml格式的数据转换成字典，要是没有安装该模块的童鞋，可以通过pip命令来进行安装
pip install xmltodict 假设有如下所示的xml格式的数据
&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt; &lt;mydocument has=&#34;an attribute&#34;&gt; &lt;and&gt; &lt;many&gt;elements&lt;/many&gt; &lt;many&gt;more elements&lt;/many&gt; &lt;/and&gt; &lt;plus a=&#34;complex&#34; b=&#34;hello&#34;&gt; element as well &lt;/plus&gt; &lt;/mydocument&gt; 我们尝试来读取当中的数据，用到xmltodict模块，代码如下
xml_result = open(&#39;testdb.xml&#39;, &#39;r&#39;) xml_dict = xmltodict.parse(xml_result.read()) print(type(xml_dict)) print(xml_dict) output
&lt;class &#39;dict&#39;&gt; {&#39;mydocument&#39;: {&#39;@has&#39;: &#39;an attribute&#39;, &#39;and&#39;: {&#39;many&#39;: [&#39;elements&#39;, &#39;more elements&#39;]}, &#39;plus&#39;: {&#39;@a&#39;: &#39;complex&#39;, &#39;@b&#39;: &#39;hello&#39;, &#39;#text&#39;: &#39;element as well&#39;}}} 我们也可以尝试来读取当中的一些数据，代码如下
xml_dict.get(&#34;mydocument&#34;).get(&#34;and&#34;) output
{&#39;many&#39;: [&#39;elements&#39;, &#39;more elements&#39;]} 当然我们还可以转换回去，转换成xml格式的数据，这里需要用到的是unparse()方法，代码如下
dict_xml = xmltodict.unparse(xml_dict, pretty=True) UltraJSON ultrajson的底层是用C来编写的，因此作为一个超高速的json编码器和解码器，可以用作是其他大多数json解析器的替换，我们先用pip命令来将其安装" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2395303636651b12680675569dbe88f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T11:41:05+08:00" />
<meta property="article:modified_time" content="2023-12-28T11:41:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">10个超级实用的Python模块，建议收藏！！</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><code>Python</code>标准库有超过200个模块，程序员可以在他们的程序中导入和使用，虽然普通程序员对其中许多模块都有一些经验，但很可能有一些好用的模块他们仍然没有注意到。</p> 
 <p>今天小编就来给大家推荐几个特别好用的<code>Python</code>模块，其中有一部分是在<code>Pandas</code>当中的，方便大家使用了之后更加高效地来进行数据分析。</p> 
 <h3>xmltodict</h3> 
 <p style="text-align:left;">首先给大家介绍的第三方模块叫做<code>xmltodict</code>，我们从名字上就可以非常直观地看出，该模块的作用在于将<code>xml</code>格式的数据转换成字典，要是没有安装该模块的童鞋，可以通过<code>pip</code>命令来进行安装</p> 
 <pre class="has"><code class="language-go">pip install xmltodict</code></pre> 
 <p style="text-align:left;">假设有如下所示的<code>xml</code>格式的数据</p> 
 <pre class="has"><code class="language-go">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;mydocument has="an attribute"&gt;
    &lt;and&gt;
        &lt;many&gt;elements&lt;/many&gt;
        &lt;many&gt;more elements&lt;/many&gt;
    &lt;/and&gt;
    &lt;plus a="complex" b="hello"&gt;
        element as well
    &lt;/plus&gt;
&lt;/mydocument&gt;</code></pre> 
 <p style="text-align:left;">我们尝试来读取当中的数据，用到<code>xmltodict</code>模块，代码如下</p> 
 <pre class="has"><code class="language-go">xml_result = open('testdb.xml', 'r')
xml_dict = xmltodict.parse(xml_result.read())
print(type(xml_dict))
print(xml_dict)</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">&lt;class 'dict'&gt;
{'mydocument': {'@has': 'an attribute', 'and': {'many': ['elements', 'more elements']}, 'plus': {'@a': 'complex', '@b': 'hello', '#text': 'element as well'}}}</code></pre> 
 <p style="text-align:left;">我们也可以尝试来读取当中的一些数据，代码如下</p> 
 <pre class="has"><code class="language-go">xml_dict.get("mydocument").get("and")</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">{'many': ['elements', 'more elements']}</code></pre> 
 <p style="text-align:left;">当然我们还可以转换回去，转换成<code>xml</code>格式的数据，这里需要用到的是<code>unparse()</code>方法，代码如下</p> 
 <pre class="has"><code class="language-go">dict_xml = xmltodict.unparse(xml_dict, pretty=True)</code></pre> 
 <h3>UltraJSON</h3> 
 <p style="text-align:left;"><code>ultrajson</code>的底层是用<code>C</code>来编写的，因此作为一个超高速的<code>json</code>编码器和解码器，可以用作是其他大多数<code>json</code>解析器的替换，我们先用<code>pip</code>命令来将其安装</p> 
 <pre class="has"><code class="language-go">pip install ujson</code></pre> 
 <p style="text-align:left;">我们来尝试使用该模块来解析一下如下的数据，代码如下</p> 
 <pre class="has"><code class="language-go">import ujson
ujson.dumps([{"key1": "value1"}, {"key2": "value2"}])</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">'[{"key1":"value1"},{"key2":"value2"}]'</code></pre> 
 <p style="text-align:left;">使用<code>dumps()</code>方法输出的数据就是以字符串的形式来展现的，与此同时呢还有<code>loads()</code>方法针对字符串格式的数据进行转换</p> 
 <pre class="has"><code class="language-go">ujson_result = ujson.loads("""[{"key1": "value1"}, {"key2": "value2"}]""")</code></pre> 
 <p style="text-align:left;">要是我们想要获取列表当中第一个元素的值，就可以这么来做了</p> 
 <pre class="has"><code class="language-go">ujson_result[0].get("key1")</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">value1</code></pre> 
 <h3>arrow</h3> 
 <p style="text-align:left;"><code>Arrow</code>提供了一个友好而且非常易懂的方法，用于创建时间、计算时间、格式化时间，还可以对时间做转化、提取、兼容<code>python datetime</code>类型。根据其文档的描述，<code>Arrow</code>模块旨在帮助使用者用更少的代码来处理日期和时间</p> 
 <p style="text-align:left;">例如我们想要知道当前的时间，代码如下</p> 
 <pre class="has"><code class="language-go">import arrow
now = arrow.now()
print(now)</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">2022-12-05T05:04:19.353774+08:00</code></pre> 
 <p style="text-align:left;">当然我们可以用<code>format()</code>方法来格式化日期和时间，具体代码如下</p> 
 <pre class="has"><code class="language-go">import arrow
now = arrow.now()
year = now.format('YYYY')
print("Year: {0}".format(year))
date = now.format('YYYY-MM-DD')
print("Date: {0}".format(date))
date_time = now.format('YYYY-MM-DD HH:mm:ss')
print("Date and time: {0}".format(date_time))
date_time_zone = now.format('YYYY-MM-DD HH:mm:ss ZZ')
print("Date and time and zone: {0}".format(date_time_zone))</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">Year: 2022
Date: 2022-12-05
Date and time: 2022-12-05 10:41:01
Date and time and zone: 2022-12-05 10:41:01 +08:00</code></pre> 
 <p style="text-align:left;">与此同时，我们还能查看一下当下其他时区中的时间，代码如下</p> 
 <pre class="has"><code class="language-go">utc = arrow.now()
print(utc.to('US/Pacific').format('HH:mm:ss'))
print(utc.to('Europe/Paris').format('HH:mm:ss'))
print(utc.to('Europe/Moscow').format('HH:mm:ss'))</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">18:48:14
03:48:14
05:48:14</code></pre> 
 <h3>fire</h3> 
 <p style="text-align:left;">目前<code>Python</code>的命令行模块有<code>argparse</code>(<code>Python</code>的标准库)、<code>click</code>等，但是这些库在使用上都比较麻烦，本文介绍的<code>Fire</code>模块用起来十分的方便，并且可用于任何<code>Python</code>对象自动生成命令行接口，我们来看下面这个例子</p> 
 <pre class="has"><code class="language-go">import fire

def hello(name="World"):
  return "Hello %s!" % name

if __name__ == '__main__':
  fire.Fire(hello)</code></pre> 
 <p style="text-align:left;">我们可以在命令行中运行<code>python 文件名.py</code>，得到结果<code>Hello World!</code>，或者我们可以添加上相应的参数</p> 
 <pre class="has"><code class="language-go">python 文件名.py --name=Tom</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">Hello Tom!</code></pre> 
 <p style="text-align:left;">而当我们不知道怎么来添加这些参数的时候，就可以通过<code>--help</code>来进行查看，</p> 
 <pre class="has"><code class="language-go">python 文件名.py --help</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">INFO: Showing help with the command '文件名.py -- --help'.

NAME
    文件名.py

SYNOPSIS
    文件名.py &lt;flags&gt;

FLAGS
    --name=NAME
        Default: 'World'</code></pre> 
 <p style="text-align:left;">我们可以来写一个计算器对象来做一个输入数字的平方计算，代码如下</p> 
 <pre class="has"><code class="language-go">class Calculator(object):
  """A simple calculator class."""

  def square(self, number):
    return number ** 2

if __name__ == '__main__':
  fire.Fire(Calculator)</code></pre> 
 <p style="text-align:left;">我们可以这样来尝试，代码如下</p> 
 <pre class="has"><code class="language-go">python 文件名.py square 10</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">100</code></pre> 
 <p style="text-align:left;">或者是</p> 
 <pre class="has"><code class="language-go">python 文件名.py square --number=5</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">25</code></pre> 
 <h3>tinydb</h3> 
 <p style="text-align:left;"><code>tinydb</code>是一个用纯<code>Python</code>编写的轻量级数据库，从名字上面我们就能够看出来它十分的轻便，它的由来就是为了降低小型<code>Python</code>应用程序使用数据库的难度，对于一些简单的程序而言与其是用<code>SQL</code>数据库，还不如就使用<code>Tinydb</code>，我们先用<code>pip</code>命令安装一下</p> 
 <pre class="has"><code class="language-go">pip install tinydb</code></pre> 
 <p style="text-align:left;">我们先初始化一个<code>DB</code>文件，代码如下</p> 
 <pre class="has"><code class="language-go">from tinydb import TinyDB
db = TinyDB('db.json')</code></pre> 
 <p style="text-align:left;">同时我们也可以往里面添加几条数据，调用的方法是<code>insert()</code>或者是<code>insert_multiple()</code>，代码如下</p> 
 <pre class="has"><code class="language-go">db.insert({'type': 'apple', 'count': 10})
db.insert({'type': 'banana', 'count': 20})

db.insert_multiple([
    {'name': 'John', 'age': 22},
    {'name': 'John', 'age': 37}])</code></pre> 
 <p style="text-align:left;">要是我们想要查看所有的数据，调用的就是<code>all()</code>方法了，代码如下</p> 
 <pre class="has"><code class="language-go">from tinydb import TinyDB
db = TinyDB('db.json')
db.all()</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">[{'type': 'apple', 'count': 10}, {'type': 'banana', 'count': 20}, {'name': 'John', 'age': 30}, {'name': 'Tom', 'age': 45}]</code></pre> 
 <p style="text-align:left;">而当我们需要搜索指定的数据时，就需要用到<code>Query()</code>方法，代码如下</p> 
 <pre class="has"><code class="language-go">from tinydb import TinyDB, Query
db = TinyDB('db.json')
Fruit = Query()
db.search(Fruit.type == 'apple')</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">[{'type': 'apple', 'count': 10}]</code></pre> 
 <p style="text-align:left;">或者是要更新数据的时候，就用到<code>update()</code>方法</p> 
 <pre class="has"><code class="language-go">db.update({'type': 'apple', 'count': 40})
Fruit = Query()
db.search(Fruit.type == 'apple')</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">[{'type': 'apple', 'count': 40</code></pre> 
 <p style="text-align:left;">而要是清空整个数据库的话，调用的则是<code>truncate()</code>方法，代码如下</p> 
 <pre class="has"><code class="language-go">from tinydb import TinyDB
db = TinyDB('db.json')
db.truncate()
db.all()</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">[]</code></pre> 
 <p style="text-align:left;">删除某条数据的话，调用的是<code>remove()</code>方法，</p> 
 <pre class="has"><code class="language-go">db.remove(Fruit.count &lt; 15)
db.all()</code></pre> 
 <p style="text-align:left;">output</p> 
 <pre class="has"><code class="language-go">[{'type': 'banana', 'count': 20}]</code></pre> 
 <h3>sidetable</h3> 
 <p><code>sidetable</code>是一种可用于数据分析和探索的工具模块，作为<code>value_counts()</code>和<code>crosstab</code>两者组合来使用的，它能够实现的用途对于<code>Pandas</code>模块而言也都能实现，但是步骤更加简便。</p> 
 <p>首先我们先通过<code>pip</code>命令来安装该模块</p> 
 <pre class="has"><code class="language-go">pip install sidetable</code></pre> 
 <p>紧接着我们读取本次教程需要用到的数据集，代码如下</p> 
 <pre class="has"><code class="language-go">import pandas as pd
import sidetable

sales = pd.read_csv(
  "sales_data_with_stores.csv",
   usecols = ["store", "product_group", "product_code", "cost",  
              "price", "last_week_sales"]
)
sales.head()</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/06/0b/mbAJoBZG_o.png" alt="893a3187f6d3cd9391ca9edd229394ef.png"></p> 
 <h4>初步分析</h4> 
 <p>例如我们看到这个<code>product_group</code>这一栏，也就是产品组，要是我们想要知道总共有哪些产品组？每一组产品总共有多少？占到的比重又是多少，就可以调用其中<code>freq()</code>方法，这个就和<code>Pandas</code>当中的<code>groupby</code>方法十分地类似，代码如下</p> 
 <pre class="has"><code class="language-go">sales.stb.freq(["product_group"])</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/f1/f6/DgPVu4Gg_o.png" alt="0fd6ce1454a34b1f89f4d6700a8a3804.png"></p> 
 <p>那么从上面的结果中我们可以看到，总共有6个产品组以及各自的占比情况如何和累积的占比情况。当然上述的结果本质上是基于表格当中各个产品的行数是多少，而当我们想要看一下各个产品的销量情况时，就需要用到<code>last_week_sales</code>字段了，代码如下</p> 
 <pre class="has"><code class="language-go">sales.stb.freq(["product_group"], value="last_week_sales")</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/28/be/7DxI8jBy_o.png" alt="b6f01dc785f76c12cd122574eb3709d3.png"></p> 
 <p>然后我们要是还想进一步深挖数据集当中的信息，例如想要看一下每一组产品在每一家门店中的销量情况，就需要用到<code>store</code>字段，代码如下</p> 
 <pre class="has"><code class="language-go">sales.stb.freq(["product_group", "store"], value="last_week_sales")</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/35/0d/CqZ5gC9R_o.png" alt="c03eae4af36e847b3cd57e52364eabbf.png"></p> 
 <h4>缺失值</h4> 
 <p>我们来看一下表格当中的缺失值的分布，代码如下</p> 
 <pre class="has"><code class="language-go">sales.stb.missing()</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" width="342" src="https://images2.imgbox.com/d5/d2/T8ZEHzLO_o.png" alt="0b5ad9f0932e5ea9dfc241e1720c24c0.png"></p> 
 <h4>subtotal计算</h4> 
 <p>那么对于分组的结果而言，<code>sidetable</code>还可以计算得出每个分组的<code>subtotal</code>（小计），代码如下</p> 
 <pre class="has"><code class="language-go">sales_filtered = sales[sales["product_group"].isin(["PG1", "PG2"])]
sales_filtered.groupby(["store", "product_group"]).agg(
    total_sales = ("last_week_sales", "sum")
)</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" width="286" src="https://images2.imgbox.com/b5/2c/v6h6L9CJ_o.png" alt="235650410dc1760988816e66c32945fc.png"></p> 
 <p>我们筛选出了一二两组在每家门店当中的销量情况，而对于<code>sidetable</code>而言还能够轻松的计算出每家门店销量的总和，代码如下</p> 
 <pre class="has"><code class="language-go">sales_filtered.groupby(["store", "product_group"]).agg(
    total_sales = ("last_week_sales", "sum")
).stb.subtotal()</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" width="286" src="https://images2.imgbox.com/2d/dd/hkDcZlbn_o.png" alt="cc6036d16f4f81dcc901bc281ec959bc.png"></p> 
 <h3>eval()函数</h3> 
 <p><code>Pandas</code>提供了通过<code>eval()</code>进行表达式计算的功能，我们依次可以写出简洁、易读的代码，例如有下面这么一个数据集</p> 
 <pre class="has"><code class="language-go">df = pd.DataFrame({"animal": ["dog", "cat"], "age": [20, 30]})
df</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" width="213" src="https://images2.imgbox.com/6f/6f/ECIAWgLI_o.png" alt="7e6cf013e69f26b28012e6b8251d90b7.png"></p> 
 <p>我们可以调用<code>pd.eval()</code>方法来新建一列，代码如下</p> 
 <pre class="has"><code class="language-go">pd.eval("double_age = df.age * 2", target=df)</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" width="258" src="https://images2.imgbox.com/86/fe/VxlbJE2X_o.png" alt="7c6fb9009d9bb02578377decc7811bc1.png"></p> 
 <p>该函数仅对列进行操作，而不对特定行或者元素进行操作。我们再来看几个示例，代码如下</p> 
 <pre class="has"><code class="language-go">df = pd.DataFrame(dict(a=range(5), b=range(5, 10)))
df.eval("c = a + b", inplace=True)
df.eval("d = a + b + c", inplace=True)
df.eval("a = 5", inplace=True)
df</code></pre> 
 <p>output</p> 
 <p style="text-align:center;"><img title="" width="202" src="https://images2.imgbox.com/83/10/QAGsNP1i_o.png" alt="35d7fecd0f32170353c69766239f7219.png"></p> 
 <p>因此，我们只需要传入需要计算的表达式字符串即可得到想要的结果。</p> 
 <h3>exec()函数</h3> 
 <p><code>Python</code>内置的<code>exec</code>函数，用来执行一段<code>Python</code>代码，这段代码以字符串的形式传给<code>exec</code>函数执行，例如</p> 
 <pre class="has"><code class="language-go">exec('''
... for i in range(10):
...     print(i)
... ''')</code></pre> 
 <p>output</p> 
 <pre class="has"><code class="language-go">0
1
2
3
4
5
6
7
8
9</code></pre> 
 <p>而该函数的第二个参数具体是用来控制<code>exec</code>函数内执行代码可以访问的全局变量资源，如下代码所示</p> 
 <pre class="has"><code class="language-go">exec('''
print(a)
print(b)
print(d)
c = 3
print(c)''', {'a':111,'b':222,'d':444})</code></pre> 
 <p>output</p> 
 <pre class="has"><code class="language-go">111
222
444
3</code></pre> 
 <p><code>exec()</code>函数除了能执行复杂的代码片段，还可以执行<code>py</code>文件中的<code>Python</code>代码，例如有<code>test.txt</code>文件，内容如下</p> 
 <pre class="has"><code class="language-go"># !usr/bin/env python
# -*- coding:utf-8 _*-

# test.txt

def main():
    x = 30
    y = 40
    print(x*y)
    print("www.baidu.com")

if __name__ == "__main__":
    main()</code></pre> 
 <p>然后使用内置函数<code>exec()</code>执行这个<code>txt</code>文件的<code>Python</code>代码：</p> 
 <pre class="has"><code class="language-go">with open('test.txt','r') as f:
    exec(f.read())</code></pre> 
 <p>output</p> 
 <pre class="has"><code class="language-go">1200
www.baidu.com</code></pre> 
 <p><strong>NO.</strong><strong title="">1</strong></p> 
 <p>往期推荐</p> 
 <p>Historical articles</p> 
 <p><a href="" rel="nofollow">还在接着用Pandas？这个数据处理神器得要了解一下了！</a><br></p> 
 <p><a href="" rel="nofollow">Python办公利器：Python-docx，解放双手、事半功倍！！</a><br></p> 
 <p><a href="" rel="nofollow">【实用原创】20个Python自动化脚本，解放双手、事半功倍</a><br></p> 
 <p><a href="" rel="nofollow">Python数据可视化分析瑞幸和星巴克全国门店分布图</a><br></p> 
 <p>分享、收藏、点赞、在看安排一下？</p> 
 <p><img src="https://images2.imgbox.com/e1/89/q9gc4Umq_o.gif" alt="1cc53cc5853942647b639d3d3f489b59.gif"></p> 
 <p><img src="https://images2.imgbox.com/9c/b8/ETUWoeXj_o.gif" alt="83cacac41092e0c819e4ee0a20cadd08.gif"></p> 
 <p><img src="https://images2.imgbox.com/ef/d6/7AMHpaBQ_o.gif" alt="452b2001792b347b684d2ccd93bdf898.gif"></p> 
 <p><img src="https://images2.imgbox.com/c3/9b/9B8ikT7x_o.gif" alt="dbdaf3201d935c466f1218ae3ea1dde8.gif"></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ad25f7aeaa866fb9c8d98d318e399d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C(C&#43;&#43;)数组越界但能正常运行？关于数组越界和变量内存地址的一点研究：何时地址连续</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36f7b18b7faf032ebd1802d32fd78c30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">搭建简单的GPT聊天机器人</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>