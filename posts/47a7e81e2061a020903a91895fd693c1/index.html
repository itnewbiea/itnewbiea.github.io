<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot项目application配置 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot项目application配置" />
<meta property="og:description" content="启动配置
要加&#34;m&#34;说明是MB，否则就是KB了
-Xms：初始值
-Xmx：最大值
-Xmn：最小值
java -Xms10m -Xmx80m -jar mod.jar &amp;
时区设置 java -jar -Duser.timezone=GMT&#43;08 mod.jar &amp; springboot启动项目配置文件加载顺序
/config, / , classpath:/config，classpath: 找到后不再继续查找
2.核心属性
2.1 BANNER
banner.charset = UTF -8＃横幅文件编码。
banner.location = classpath ：banner.txt＃横幅文件位置。
2.2 LOGGING
logging.config =＃日志记录配置文件的位置。例如对于Logback的“classpath：logback.xml”
logging.exception-conversion-word =％wEx＃记录异常时使用的转换字。
logging.file =＃日志文件名。例如myapp.log
logging.level。* =＃日志级别严重性映射。例如logging.level.org.springframework = DEBUG
logging.path =＃日志文件的位置。例如/ var / log
logging.pattern.console =＃输出到控制台的Appender模式。仅支持默认logback设置。
logging.pattern.file =＃输出到文件的Appender模式。仅支持默认logback设置。
logging.pattern.level =＃日志级别的Appender模式（默认为％5p）。仅支持默认logback设置。
logging.register-shutdown-hook = false ＃在初始化时为日志系统注册一个关闭挂接。
2.3 AOP
spring.aop.auto = true ＃添加@EnableAspectJAutoProxy。
spring.aop.proxy-target-class = false ＃是否要创建基于子类（CGLIB）的代理（true），而不是基于标准Java接口的代理（false）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/47a7e81e2061a020903a91895fd693c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-16T20:58:10+08:00" />
<meta property="article:modified_time" content="2020-04-16T20:58:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot项目application配置</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ol><li>启动配置<br> 要加"m"说明是MB，否则就是KB了<br> -Xms：初始值<br> -Xmx：最大值<br> -Xmn：最小值<br> java -Xms10m -Xmx80m -jar mod.jar &amp;<br> 时区设置 java -jar -Duser.timezone=GMT+08 mod.jar &amp;</li></ol> 
<p>springboot启动项目配置文件加载顺序<br> /config, / , classpath:/config，classpath: 找到后不再继续查找</p> 
<p>2.核心属性<br> 2.1 BANNER<br> banner.charset = UTF -8＃横幅文件编码。<br> banner.location = classpath ：banner.txt＃横幅文件位置。</p> 
<p>2.2 LOGGING<br> logging.config =＃日志记录配置文件的位置。例如对于Logback的“classpath：logback.xml”<br> logging.exception-conversion-word =％wEx＃记录异常时使用的转换字。<br> logging.file =＃日志文件名。例如myapp.log<br> logging.level。* =＃日志级别严重性映射。例如logging.level.org.springframework = DEBUG<br> logging.path =＃日志文件的位置。例如/ var / log<br> logging.pattern.console =＃输出到控制台的Appender模式。仅支持默认logback设置。<br> logging.pattern.file =＃输出到文件的Appender模式。仅支持默认logback设置。<br> logging.pattern.level =＃日志级别的Appender模式（默认为％5p）。仅支持默认logback设置。<br> logging.register-shutdown-hook = false ＃在初始化时为日志系统注册一个关闭挂接。</p> 
<p>2.3 AOP<br> spring.aop.auto = true ＃添加@EnableAspectJAutoProxy。<br> spring.aop.proxy-target-class = false ＃是否要创建基于子类（CGLIB）的代理（true），而不是基于标准Java接口的代理（false）。</p> 
<p>2.4 IDENTITY（ContextIdApplicationContextInitializer）<br> spring.application.index =＃应用程序索引。<br> spring.application.name =＃应用程序名称。</p> 
<p>2.5 ADMIN（SpringApplicationAdminJmxAutoConfiguration）<br> spring.application.admin.enabled = false ＃为应用程序启用管理功能。<br> spring.application.admin.jmx-name = org .springframework.boot：type = Admin ，name = SpringApplication ＃应用程序管理MBean的JMX名称。</p> 
<p>2.6 AUTO-CONFIGURATION<br> spring.autoconfigure.exclude =＃要自动配置要排除的类。</p> 
<p>2.7 SPRING CORE<br> spring.beaninfo.ignore = true ＃跳过搜索BeanInfo类。</p> 
<p>2.8 SPRING CACHE（CacheProperties）<br> spring.cache.cache-names =＃如果底层缓存管理器支持，则创建缓冲区名称的逗号分隔列表。<br> spring.cache.ehcache.config =＃用于初始化EhCache的配置文件的位置。<br> spring.cache.guava.spec =＃用于创建缓存的规范。检查CacheBuilderSpec有关规格格式的更多详细信息。<br> spring.cache.hazelcast.config =＃用于初始化Hazelcast的配置文件的位置。<br> spring.cache.infinispan.config =＃用于初始化Infinispan的配置文件的位置。<br> spring.cache.jcache.config =＃用于初始化缓存管理器的配置文件的位置。<br> spring.cache.jcache.provider =＃用于检索符合JSR-107规范的缓存管理器的CachingProvider实现的完全限定名。只有在类路径上有多个JSR-107实现可用时才需要。<br> spring.cache.type =＃缓存类型，默认情况下根据环境自动检测。</p> 
<p>2.9 SPRING CONFIG - 仅使用环境属性（ConfigFileApplicationListener）<br> spring.config.location =＃配置文件位置。<br> spring.config.name = application ＃配置文件名。</p> 
<p>＃HAZELCAST（HazelcastProperties）<br> spring.hazelcast.config =＃用于初始化Hazelcast的配置文件的位置。</p> 
<p>＃JMX<br> spring.jmx.default-domain =＃JMX域名。<br> spring.jmx.enabled = true ＃将管理bean暴露给JMX域。<br> spring.jmx.server = mbeanServer ＃MBeanServer bean名称。</p> 
<p>＃Email（MailProperties）<br> spring.mail.default-encoding = UTF -8＃默认MimeMessage编码。<br> spring.mail.host =＃SMTP服务器主机。例如smtp.example.com<br> spring.mail.jndi-name =＃Session JNDI名称。设置时，优先于其他邮件设置。<br> spring.mail.password =＃SMTP服务器的登录密码。<br> spring.mail.port =＃SMTP服务器端口。<br> spring.mail.properties。* =＃其他JavaMail会话属性。<br> spring.mail.protocol = smtp ＃SMTP服务器使用的协议。<br> spring.mail.test-connection = false ＃测试邮件服务器在启动时是否可用。<br> spring.mail.username =＃SMTP服务器的登录用户。</p> 
<p>＃APPLICATION SETTINGS（SpringApplication）<br> spring.main.banner-mode = console ＃用于在应用程序运行时显示横幅的模式。<br> spring.main.sources =＃要包括在ApplicationContext中的Sources（类名，包名或XML资源位置）。<br> spring.main.web-environment =＃在Web环境中运行应用程序（默认情况下自动检测）。</p> 
<p>＃FILE ENCODING（FileEncodingApplicationListener）<br> spring.mandatory-file-encoding =＃应用程序必须使用的预期字符编码。</p> 
<p>＃INTERNATIONALIZATION（MessageSourceAutoConfiguration）<br> spring.messages.basename = messages ＃以逗号分隔的基本名称列表，每个名称遵循ResourceBundle约定。<br> spring.messages.cache-seconds = -1＃加载的资源束文件缓存到期时间（以秒为单位）。设置为-1时，捆绑包将被永久缓存。<br> spring.messages.encoding = UTF -8＃消息包编码。<br> spring.messages.fallback-to-system-locale = true ＃设置是否找不到特定区域设置的文件，返回到系统区域设置。</p> 
<p>＃OUTPUT<br> spring.output.ansi.enabled = detect ＃配置ANSI输出（可以是“detect”，“always”，“never”）。</p> 
<p>＃PID FILE（ApplicationPidFileWriter）<br> spring.pid.fail-on-write-error =＃如果使用ApplicationPidFileWriter但不能写入PID文件，则失败。<br> spring.pid.file =＃要写入的PID文件的位置（如果使用ApplicationPidFileWriter）。</p> 
<p>＃PROFILES<br> spring.profiles.active =＃活动配置文件的逗号分隔列表。<br> spring.profiles.include =＃无条件地激活指定的逗号分隔的概要文件。</p> 
<p>＃SENDGRID（SendGridAutoConfiguration）<br> spring.sendgrid.api-key =＃SendGrid api key（用户名/密码的替代）<br> spring.sendgrid.username =＃SendGrid帐户用户名<br> spring.sendgrid.password =＃SendGrid帐户密码<br> spring.sendgrid.proxy.host =＃SendGrid代理主机<br> spring.sendgrid.proxy.port =＃SendGrid代理端口</p> 
<p>＃----------------------------------------<br> ＃WEB PROPERTIES<br> ＃----------------------------------------</p> 
<p>＃MULTIPART（MultipartProperties）<br> multipart.enabled = true ＃启用对多部分上传的支持。<br> multipart.file-size-threshold = 0 ＃将文件写入磁盘的阈值。值可以使用后缀“MB”或“KB”表示兆字节或千字节大小。<br> multipart.location =＃上传文件的中间位置。<br> multipart.max-file-size = 1Mb ＃最大文件大小。值可以使用后缀“MB”或“KB”表示兆字节或千字节大小。<br> multipart.max-request-size = 10Mb ＃最大请求大小。值可以使用后缀“MB”或“KB”表示兆字节或千字节大小。</p> 
<p>＃EMBEDDED SERVER CONFIGURATION（ServerProperties）<br> server.address =＃服务器应绑定到的网络地址。<br> server.compression.enabled = false ＃如果启用了响应压缩。<br> server.compression.excluded-user-agents =＃要从压缩中排除的用户代理的列表。<br> server.compression.mime-types =＃应压缩的MIME类型的逗号分隔列表。例如text / html，text / css，application / json<br> server.compression.min-response-size =＃要执行压缩所需的最小响应大小。例如2048<br> server.context-parameters。* =＃Servlet上下文初始化参数。例如server.context-parameters.a = 阿尔法<br> server.context-path =＃应用程序的上下文路径。<br> server.display-name = application ＃显示应用程序的名称。<br> server.error.include-stacktrace = never ＃何时包含“stacktrace”属性。<br> server.error.path = / error＃错误控制器的路径。<br> server.error.whitelabel.enabled = true ＃在服务器错误的情况下启用浏览器中显示的默认错误页面。<br> server.jsp-servlet.class-name = org .apache.jasper.servlet.JspServlet＃JSP servlet的类名。<br> server.jsp-servlet.init-parameters。* =＃用于配置JSP servlet的初始化参数<br> server.jsp-servlet.registered = true ＃是否注册了JSP servlet<br> server.port = 8080 ＃服务器HTTP端口。<br> server.server-header =＃在服务器响应头中发送的值（如果为空，则使用servlet容器默认值）<br> server.servlet-path = /＃主调度程序servlet的路径。<br> server.session.cookie.comment =＃对会话cookie进行注释。<br> server.session.cookie.domain =＃会话cookie的域。<br> server.session.cookie.http-only =＃“HttpOnly”标志为会话cookie。<br> server.session.cookie.max-age =＃会话Cookie的最大时间（以秒为单位）。<br> server.session.cookie.name =＃会话cookie名称。<br> server.session.cookie.path =＃会话cookie的路径。<br> server.session.cookie.secure =＃“安全”标志的会话cookie。<br> server.session.persistent = false ＃在重新启动之间保持会话数据。<br> server.session.store-dir =＃用于存储会话数据的目录。<br> server.session.timeout =＃会话超时（以秒为单位）。<br> server.session.tracking-modes =＃会话跟踪模式（以下一个或多个：“cookie”，“url”，“ssl”）。<br> server.ssl.ciphers =＃支持的SSL密码。<br> server.ssl.client-auth =＃是否需要客户端身份验证（“需要”）或需要（“需要”）。需要信任存储。<br> server.ssl.enabled =＃<br> server.ssl.key-alias =＃<br> server.ssl.key-password =＃<br> server.ssl.key-store =＃<br> server.ssl.key-store-password =＃<br> server.ssl.key-store-provider =＃<br> server.ssl.key-store-type =＃<br> server.ssl.protocol =＃<br> server.ssl.trust-store =＃<br> server.ssl.trust-store-password =＃<br> server.ssl.trust-store-provider =＃<br> server.ssl.trust-store-type =＃<br> server.tomcat.accesslog.directory = logs ＃创建日志文件的目录。可以相对于tomcat的base dir或绝对。<br> server.tomcat.accesslog.enabled = false ＃启用访问日志。<br> server.tomcat.accesslog.pattern = common ＃访问日志的格式模式。<br> server.tomcat.accesslog.prefix = access_log ＃日志文件名前缀。<br> server.tomcat.accesslog.suffix = .log＃日志文件名后缀。<br> server.tomcat.background-processor-delay = 30 ＃调用backgroundProcess方法之间的延迟（以秒为单位）。<br> server.tomcat.basedir =＃Tomcat基目录。如果未指定，将使用临时目录。<br> server.tomcat.internal-proxies = 10 \。\ d {1,3} \。\ d {1,3} \。\ d {1,3} | <br> 192 \。168 \。\ d {1,3} \。\ d {1,3} | <br> 169 \。254 \。\ d {1,3} \。\ d {1,3} | <br> 127 \。\ d {1,3} \。\ d {1,3} \。\ d {1,3} | <br> 172 \。1 [6-9] {1} \。\ d {1,3} \。\ d {1,3} | <br> 172 \。2 [0-9] {1} \。\ d {1,3} \。\ d {1,3} | <br> 172 \。3 [0-1] {1} \。\ d {1,3} \。\ d {1,3}＃正则表达式匹配可信IP地址。<br> server.tomcat.max-http-header-size = 0 ＃HTTP消息头的最大大小（以字节为单位）。<br> server.tomcat.max-threads = 0 ＃最大工作线程数。<br> server.tomcat.port-header = X -Forwarded-Port＃用于覆盖原始端口值的HTTP头的名称。<br> server.tomcat.protocol-header =＃保存传入协议的头，通常命名为“X-Forwarded-Proto”。<br> server.tomcat.protocol-header-https-value = https ＃指示入局请求使用SSL的协议头的值。<br> server.tomcat.remote-ip-header =＃从中提取远程ip的http标头的名称。例如X-FORWARDED-FOR<br> server.tomcat.uri-encoding = UTF -8＃用于解码URI的字符编码。<br> server.undertow.accesslog.dir =＃访问日志目录。<br> server.undertow.accesslog.enabled = false ＃启用访问日志。<br> server.undertow.accesslog.pattern = common ＃访问日志的格式模式。<br> server.undertow.buffer-size =＃每个缓冲区的大小（以字节为单位）。<br> server.undertow.buffers-per-region =＃每个区域的缓冲区数。<br> server.undertow.direct-buffers =＃在Java堆外分配缓冲区。<br> server.undertow.io-threads =＃为worker创建的I / O线程数。<br> server.undertow.worker-threads =＃工作线程数。<br> server.use-forward-headers =＃如果X-Forwarded- *头应该应用于HttpRequest。</p> 
<p>＃FREEMARKER（FreeMarkerAutoConfiguration）<br> spring.freemarker.allow-request-override = false ＃设置是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。<br> spring.freemarker.allow-session-override = false ＃设置是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。<br> spring.freemarker.cache = false ＃启用模板缓存。<br> spring.freemarker.charset = UTF -8＃模板编码。<br> spring.freemarker.check-template-location = true ＃检查模板位置是否存在。<br> spring.freemarker.content-type = text / html＃Content-Type值。<br> spring.freemarker.enabled = true ＃为此技术启用MVC视图分辨率。<br> spring.freemarker.expose-request-attributes = false ＃设置是否应在与模板合并之前将所有请求属性添加到模型。<br> spring.freemarker.expose-session-attributes = false ＃设置在与模板合并之前是否应将所有HttpSession属性添加到模型。<br> spring.freemarker.expose-spring-macro-helpers = true ＃设置是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。<br> spring.freemarker.prefer-file-system-access = true ＃首选模板加载的文件系统访问。文件系统访问启用对模板更改的热检测。<br> spring.freemarker.prefix =＃在构建URL时，预先查看名称的前缀。<br> spring.freemarker.request-context-attribute =＃所有视图的RequestContext属性的名称。<br> spring.freemarker.settings。* =＃众所周知的FreeMarker键，它将被传递给FreeMarker的配置。<br> spring.freemarker.suffix =＃构建URL时附加到视图名称的后缀。<br> spring.freemarker.template-loader-path = classpath ：/ templates /＃模板路径的逗号分隔列表。<br> spring.freemarker.view-names =＃可以解析的视图名称的白名单。</p> 
<p>＃GROOVY TEMPLATES（GroovyTemplateAutoConfiguration）<br> spring.groovy.template.allow-request-override = false ＃设置是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。<br> spring.groovy.template.allow-session-override = false ＃设置是否允许HttpSession属性覆盖（隐藏）控制器生成的同名的模型属性。<br> spring.groovy.template.cache =＃启用模板缓存。<br> spring.groovy.template.charset = UTF -8＃模板编码。<br> spring.groovy.template.check-template-location = true ＃检查模板位置是否存在。<br> spring.groovy.template.configuration。* =＃参见GroovyMarkupConfigurer<br> spring.groovy.template.content-type = test / html＃Content-Type值。<br> spring.groovy.template.enabled = true ＃为此技术启用MVC视图分辨率。<br> spring.groovy.template.expose-request-attributes = false ＃设置是否应在合并模板之前将所有请求属性添加到模型。<br> spring.groovy.template.expose-session-attributes = false ＃设置在与模板合并之前是否应该将所有HttpSession属性添加到模型。<br> spring.groovy.template.expose-spring-macro-helpers = true ＃设置是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。<br> spring.groovy.template.prefix =＃构建URL时，在前面添加用于查看名称的前缀。<br> spring.groovy.template.request-context-attribute =＃所有视图的RequestContext属性的名称。<br> spring.groovy.template.resource-loader-path = classpath ：/ templates /＃模板路径。<br> spring.groovy.template.suffix = .tpl＃构建URL时附加到视图名称的后缀。<br> spring.groovy.template.view-names =＃可以解析的视图名称的白名单。</p> 
<p>＃SPRING HATEOAS（HateoasProperties）<br> spring.hateoas.use-hal-as-default-json-media-type = true ＃指定是否应该将application / hal + json响应发送到接受application / json的请求。</p> 
<p>＃HTTP消息转换<br> spring.http.converters.preferred-json-mapper = jackson ＃首选用于HTTP消息转换的JSON映射程序。设置为“gson”以强制使用Gson，当它和Jackson都在类路径上时。</p> 
<p>＃HTTP encoding（HttpEncodingProperties）<br> spring.http.encoding.charset = UTF -8＃HTTP请求和响应的字符集。如果未明确设置，则添加到“Content-Type”标题。<br> spring.http.encoding.enabled = true ＃启用http编码支持。<br> spring.http.encoding.force = true ＃强制编码到配置的字符集上HTTP请求和响应。</p> 
<p>＃JACKSON（JacksonProperties）<br> spring.jackson.date-format =＃日期格式字符串或完全限定的日期格式类名称。例如yyyy-MM-dd HH：mm：ss。<br> spring.jackson.deserialization。* =＃Jackson on / off功能影响Java对象的反序列化方式。<br> spring.jackson.generator。* =＃Jackson的on / off功能用于生成器。<br> spring.jackson.joda-date-time-format =＃Joda日期时间格式字符串。如果未配置，如果使用格式字符串配置，“date-format”将用作后备。<br> spring.jackson.locale =＃用于格式化的区域设置。<br> spring.jackson.mapper。* =＃Jackson通用开/关功能。<br> spring.jackson.parser。* =＃Jackson解析器的on / off功能。<br> spring.jackson.property-naming-strategy =＃Jackson的PropertyNamingStrategy上的一个常量。也可以是PropertyNamingStrategy子类的完全限定类名。<br> spring.jackson.serialization。* =＃Jackson on / off功能影响Java对象的序列化方式。<br> spring.jackson.serialization-inclusion =＃控制序列化期间属性的包含。使用Jackson的JsonInclude.Include枚举中的值之一进行配置。<br> spring.jackson.time-zone =＃格式化日期时使用的时区。例如America / Los_Angeles</p> 
<p>＃JERSEY（JerseyProperties）<br> spring.jersey.application-path =＃作为应用程序的基本URI的路径。如果指定，则覆盖“@ApplicationPath”的值。<br> spring.jersey.filter.order = 0 ＃Jersey过滤器链的顺序。<br> spring.jersey.init。* =＃通过servlet或过滤器传递给Jersey的初始参数。<br> spring.jersey.type = servlet ＃Jersey集成类型。可以是“servlet”或“filter”。</p> 
<p>＃SPRING MOBILE DEVICE VIEWS（DeviceDelegatingViewResolverAutoConfiguration）<br> spring.mobile.devicedelegatingviewresolver.enable-fallback = false ＃启用支持回退解析。<br> spring.mobile.devicedelegatingviewresolver.enabled = false ＃启用设备视图解析器。<br> spring.mobile.devicedelegatingviewresolver.mobile-prefix = mobile /＃预先在移动设备上查看名称的前缀。<br> spring.mobile.devicedelegatingviewresolver.mobile-suffix =＃附加到移动设备的视图名称的后缀。<br> spring.mobile.devicedelegatingviewresolver.normal-prefix =＃前缀，用于查看常规设备的名称。<br> spring.mobile.devicedelegatingviewresolver.normal-suffix =＃附加到普通设备的视图名称的后缀。<br> spring.mobile.devicedelegatingviewresolver.tablet-prefix = tablet /＃预先查看平板电脑设备名称的前缀。<br> spring.mobile.devicedelegatingviewresolver.tablet-suffix =＃附加到平板电脑设备的视图名称的后缀。</p> 
<p>＃SPRING MOBILE SITE PREFERENCE（SitePreferenceAutoConfiguration）<br> spring.mobile.sitepreference.enabled = true ＃启用SitePreferenceHandler。</p> 
<p>＃MUSTACHE TEMPLATES（MustacheAutoConfiguration）<br> spring.mustache.cache = false ＃启用模板缓存。<br> spring.mustache.charset = UTF -8＃模板编码。<br> spring.mustache.check-template-location = true ＃检查模板位置是否存在。<br> spring.mustache.content-type = text / html＃Content-Type值。<br> spring.mustache.enabled = true ＃为此技术启用MVC视图分辨率。<br> spring.mustache.prefix = classpath ：/ templates /＃要应用于模板名称的前缀。<br> spring.mustache.suffix = .html＃应用于模板名称的后缀。<br> spring.mustache.view-names =＃可以解析的视图名称的白名单。</p> 
<p>＃SPRING MVC（WebMvcProperties）<br> spring.mvc.async.request-timeout =＃异步请求处理超时之前的时间（以毫秒为单位）。<br> spring.mvc.date-format =＃要使用的日期格式。例如dd / MM / yyyy。<br> spring.mvc.dispatch-trace-request = false ＃将TRACE请求分发到FrameworkServlet doService方法。<br> spring.mvc.dispatch-options-request = false ＃向FrameworkServlet doService方法分发OPTIONS请求。<br> spring.mvc.favicon.enabled = true ＃启用favicon.ico的解析。<br> spring.mvc.ignore-default-model-on-redirect = true ＃如果在重定向场景中应该忽略“默认”模型的内容。<br> spring.mvc.locale =＃要使用的区域设置。<br> spring.mvc.media-types。* =＃将文件扩展名映射到用于内容协商的媒体类型。<br> spring.mvc.message-codes-resolver-format =＃消息代码的格式化策略。例如PREFIX_ERROR_CODE。<br> spring.mvc.static-path-pattern = / **＃用于静态资源的路径模式。<br> spring.mvc.throw-exception-if-no-handler-found = false ＃如果没有找到处理请求的处理程序，应抛出“NoHandlerFoundException”。<br> spring.mvc.view.prefix =＃Spring MVC视图前缀。<br> spring.mvc.view.suffix =＃Spring MVC视图后缀。</p> 
<p>＃SPRING RESOURCES HANDLING（ResourceProperties）<br> spring.resources.add-mappings = true ＃启用默认资源处理。<br> spring.resources.cache-period =＃资源处理程序服务的资源的高速缓存时间段（以秒为单位）。<br> spring.resources.chain.cache = true ＃在资源链中启用缓存。<br> spring.resources.chain.enabled =＃启用Spring资源处理链。默认情况下禁用，除非已启用至少一个策略。<br> spring.resources.chain.html-application-cache = false ＃启用HTML5应用程序缓存清单重写。<br> spring.resources.chain.strategy.content.enabled = false ＃启用内容版本策略。<br> spring.resources.chain.strategy.content.paths = / **＃要应用于版本策略的模式的逗号分隔列表。<br> spring.resources.chain.strategy.fixed.enabled = false ＃启用固定版本策略。<br> spring.resources.chain.strategy.fixed.paths =＃要应用于版本策略的模式的逗号分隔列表。<br> spring.resources.chain.strategy.fixed.version =＃用于版本策略的版本字符串。<br> spring.resources.static-locations = classpath ：/ META-INF / resources /，classpath：/ resources /，classpath：/ static /，classpath：/ public /＃静态资源的位置。</p> 
<p>＃SPRING SOCIAL（SocialWebAutoConfiguration）<br> spring.social.auto-connection-views = false ＃启用支持的提供程序的连接状态视图。</p> 
<p>＃SPRING SOCIAL FACEBOOK（FacebookAutoConfiguration）<br> spring.social.facebook.app-id =＃你的应用程序的Facebook应用程序ID<br> spring.social.facebook.app-secret =＃你的应用程序的Facebook应用程序秘密</p> 
<p>＃SPRING SOCIAL LINKEDIN（LinkedInAutoConfiguration）<br> spring.social.linkedin.app-id =＃您的应用程序的LinkedIn应用程序ID<br> spring.social.linkedin.app-secret =＃你的应用程序的LinkedIn应用程序秘密</p> 
<p>＃SPRING SOCIAL TWITTER（TwitterAutoConfiguration）<br> spring.social.twitter.app-id =＃您应用程序的Twitter应用程序ID<br> spring.social.twitter.app-secret =＃你的应用程序的Twitter应用程序秘密</p> 
<p>＃THYMELEAF（ThymeleafAutoConfiguration）<br> spring.thymeleaf.cache = true ＃启用模板缓存。<br> spring.thymeleaf.check-template-location = true ＃检查模板位置是否存在。<br> spring.thymeleaf.content-type = text / html＃Content-Type值。<br> spring.thymeleaf.enabled = true ＃启用MVC Thymeleaf视图分辨率。<br> spring.thymeleaf.encoding = UTF -8＃模板编码。<br> spring.thymeleaf.excluded-view-names =＃应该从解析中排除的以逗号分隔的视图名称列表。<br> spring.thymeleaf.mode = HTML5 ＃要应用于模板的模板模式。另请参见StandardTemplateModeHandlers。<br> spring.thymeleaf.prefix = classpath ：/ templates /＃构建URL时预先查看名称的前缀。<br> spring.thymeleaf.suffix = .html＃构建URL时附加到视图名称的后缀。<br> spring.thymeleaf.template-resolver-order =＃链中模板解析器的顺序。<br> spring.thymeleaf.view-names =＃可以解析的以逗号分隔的视图名称列表。</p> 
<p>＃VELOCITY TEMPLATES（VelocityAutoConfiguration）<br> spring.velocity.allow-request-override = false ＃设置是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。<br> spring.velocity.allow-session-override = false ＃设置是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。<br> spring.velocity.cache =＃启用模板缓存。<br> spring.velocity.charset = UTF -8＃模板编码。<br> spring.velocity.check-template-location = true ＃检查模板位置是否存在。<br> spring.velocity.content-type = text / html＃Content-Type值。<br> spring.velocity.date-tool-attribute =＃要在视图的Velocity上下文中公开的DateTool辅助对象的名称。<br> spring.velocity.enabled = true ＃为此技术启用MVC视图分辨率。<br> spring.velocity.expose-request-attributes = false ＃设置是否应在与模板合并之前将所有请求属性添加到模型。<br> spring.velocity.expose-session-attributes = false ＃设置在与模板合并之前是否应该将所有HttpSession属性添加到模型。<br> spring.velocity.expose-spring-macro-helpers = true ＃设置是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。<br> spring.velocity.number-tool-attribute =＃要在视图的Velocity上下文中公开的NumberTool辅助对象的名称。<br> spring.velocity.prefer-file-system-access = true ＃首选模板加载的文件系统访问。文件系统访问启用对模板更改的热检测。<br> spring.velocity.prefix =＃构建URL时在前面添加用于查看名称的前缀。<br> spring.velocity.properties。* =＃额外的速度属性。<br> spring.velocity.request-context-attribute =＃所有视图的RequestContext属性的名称。<br> spring.velocity.resource-loader-path = classpath ：/ templates /＃模板路径。<br> spring.velocity.suffix = .vm ＃构建URL时附加到视图名称的后缀。<br> spring.velocity.toolbox-config-location =＃Velocity工具箱配置位置。例如`/ WEB-INF / toolbox.xml<br> spring.velocity.view-names =＃可以解析的视图名称的白名单。</p> 
<p>＃----------------------------------------<br> ＃安全性<br> ＃----------------------------------------<br> ＃SECURITY（SecurityProperties）<br> security.basic.authorize-mode = role ＃应用安全授权模式。<br> security.basic.enabled = true ＃启用基本认证。<br> security.basic.path = / **＃以逗号分隔的安全路径列表。<br> security.basic.realm = Spring ＃HTTP基本领域名称。<br> security.enable-csrf = false ＃启用跨站点请求伪造支持。<br> security.filter-order = 0 ＃安全过滤器链顺序。<br> security.filter-dispatcher-types = ASYNC ，FORWARD，INCLUDE，REQUEST＃安全过滤器链分派器类型。<br> security.headers.cache = true ＃启用缓存控制HTTP头。<br> security.headers.content-type = true ＃启用“X-Content-Type-Options”标头。<br> security.headers.frame = true ＃启用“X-Frame-Options”标头。<br> security.headers.hsts =＃HTTP严格传输安全（HSTS）模式（无，域，全部）。<br> security.headers.xss = true ＃启用跨站点脚本（XSS）保护。<br> security.ignored =＃要从默认安全路径中排除的路径的逗号分隔列表。<br> security.require-ssl = false ＃为所有请求启用安全通道。<br> security.sessions = stateless ＃会话创建策略（始终，从不，if_required，无状态）。<br> security.user.name = user ＃默认用户名。<br> security.user.password =＃默认用户名的密码。默认情况下，在启动时记录随机密码。<br> security.user.role = USER ＃为默认用户名授予角色。</p> 
<p>＃SECURITY OAUTH2 CLIENT（OAuth2ClientProperties<br> security.oauth2.client.client-id =＃OAuth2客户端ID。<br> security.oauth2.client.client-secret =＃OAuth2客户端密钥。默认情况下会生成随机密钥</p> 
<p>＃SECURITY OAUTH2 RESOURCES（ResourceServerProperties<br> security.oauth2.resource.id =＃资源的标识符。<br> security.oauth2.resource.jwt.key-uri =＃JWT令牌的URI。如果值不可用并且密钥为public，则可以设置。<br> security.oauth2.resource.jwt.key-value =＃JWT令牌的验证密钥。可以是对称秘密或PEM编码的RSA公钥。<br> security.oauth2.resource.prefer-token-info = true ＃使用令牌info，可以设置为false来使用用户信息。<br> security.oauth2.resource.service-id = resource ＃<br> security.oauth2.resource.token-info-uri =＃令牌解码端点的URI。<br> security.oauth2.resource.token-type =＃使用userInfoUri时要发送的令牌类型。<br> security.oauth2.resource.user-info-uri =＃用户端点的URI。</p> 
<p>＃SECURITY OAUTH2 SSO（OAuth2SsoProperties<br> security.oauth2.sso.filter-order =＃如果未提供明确的WebSecurityConfigurerAdapter，则应用过滤顺序<br> security.oauth2.sso.login-path = / login＃登录页面的路径，即触发重定向到OAuth2授权服务器的路径</p> 
<p>＃----------------------------------------<br> ＃数据属性<br> ＃----------------------------------------</p> 
<p>＃FLYWAY（FlywayProperties）<br> flyway.baseline-description =＃<br> flyway.baseline-version = 1 ＃版本开始迁移<br> flyway.baseline-on-migrate =＃<br> flyway.check-location = false ＃检查迁移脚本位置是否存在。<br> flyway.clean-on-validation-error =＃<br> flyway.enabled = true ＃启用flyway 。<br> flyway.encoding =＃<br> flyway.ignore-failed-future-migration =＃<br> flyway.init-sqls =＃在获取连接后立即执行初始化连接的SQL语句。<br> flyway.locations = classpath：db / migration＃迁移脚本的位置<br> flyway.out-of-order =＃<br> flyway.password =＃JDBC密码，如果你想让Flyway创建自己的DataSource<br> flyway.placeholder-prefix =＃<br> flyway.placeholder-replacement =＃<br> flyway.placeholder-suffix =＃<br> flyway.placeholders。* =＃<br> flyway.schemas =＃schemas要更新<br> flyway.sql-migration-prefix = V ＃<br> flyway.sql-migration-separator =＃<br> flyway.sql-migration-suffix = .sql＃<br> flyway.table =＃<br> flyway.url =＃要迁移的数据库的JDBC URL。如果未设置，则使用主配置的数据源。<br> flyway.user =＃要迁移的数据库的登录用户。<br> flyway.validate-on-migrate =＃</p> 
<p>＃LIQUIBASE（LiquibaseProperties）<br> liquibase.change-log = classpath ：/db/changelog/db.changelog-master.yaml＃更改日志配置路径。<br> liquibase.check-change-log-location = true ＃检查更改日志位置是否存在。<br> liquibase.contexts =＃要使用的运行时上下文的逗号分隔列表。<br> liquibase.default-schema =＃默认数据库模式。<br> liquibase.drop-first = false ＃删除数据库模式。<br> liquibase.enabled = true ＃启用liquibase支持。<br> liquibase.labels =＃要使用的运行时标签的逗号分隔列表。<br> liquibase.parameters。* =＃更改日志参数。<br> liquibase.password =＃要迁移的数据库的登录密码。<br> liquibase.url =＃要迁移的数据库的JDBC URL。如果未设置，则使用主配置的数据源。<br> liquibase.user =＃要迁移的数据库的登录用户。</p> 
<p>＃DAO（PersistenceExceptionTranslationAutoConfiguration）<br> spring.dao.exceptiontranslation.enabled = true ＃启用PersistenceExceptionTranslationPostProcessor。</p> 
<p>＃CASSANDRA（Cassandra属性）<br> spring.data.cassandra.cluster-name =＃Cassandra集群的名称。<br> spring.data.cassandra.compression =＃Cassandra二进制协议支持的压缩。<br> spring.data.cassandra.connect-timeout-millis =＃套接字选项：连接超时。<br> spring.data.cassandra.consistency-level =＃查询一致性级别。<br> spring.data.cassandra.contact-points = localhost ＃群集节点地址的逗号分隔列表。<br> spring.data.cassandra.fetch-size =＃查询默认抓取大小。<br> spring.data.cassandra.keyspace-name =＃要使用的键空间名称。<br> spring.data.cassandra.load-balancing-policy =＃负载均衡策略的类名称。<br> spring.data.cassandra.port =＃Cassandra服务器的端口。<br> spring.data.cassandra.password =＃服务器的登录密码。<br> spring.data.cassandra.read-timeout-millis =＃Socket选项：读取超时。<br> spring.data.cassandra.reconnection-policy =＃重新连接策略类。<br> spring.data.cassandra.retry-policy =＃重试策略的类名。<br> spring.data.cassandra.serial-consistency-level =＃查询串行一致性级别。<br> spring.data.cassandra.ssl = false ＃启用SSL支持。<br> spring.data.cassandra.username =＃服务器的登录用户。</p> 
<p>＃ELASTICSEARCH（ElasticsearchProperties）<br> spring.data.elasticsearch.cluster-name = elasticsearch ＃Elasticsearch集群名称。<br> spring.data.elasticsearch.cluster-nodes =＃群集节点地址的逗号分隔列表。如果未指定，则启动客户机节点。<br> spring.data.elasticsearch.properties。* =＃用于配置客户端的其他属性。<br> spring.data.elasticsearch.repositories.enabled = true ＃启用Elasticsearch存储库。</p> 
<p>＃MONGODB（MongoProperties）<br> spring.data.mongodb.authentication-database =＃认证数据库名称。<br> spring.data.mongodb.database = test ＃数据库名称。<br> spring.data.mongodb.field命名策略 =＃要使用的FieldNamingStrategy的完全限定名称。<br> spring.data.mongodb.grid-fs-database =＃GridFS数据库名称。<br> spring.data.mongodb.host = localhost ＃Mongo服务器主机。<br> spring.data.mongodb.password =＃mongo服务器的登录密码。<br> spring.data.mongodb.port = 27017 ＃Mongo服务器端口。<br> spring.data.mongodb.repositories.enabled = true ＃启用Mongo存储库。<br> spring.data.mongodb.uri = mongodb ：// localhost / test＃Mongo数据库URI。设置时，将忽略主机和端口。<br> spring.data.mongodb.username =＃mongo服务器的登录用户。</p> 
<p>＃DATA REST（RepositoryRestProperties）<br> spring.data.rest.base-path =＃Spring Data REST用于公开资源库资源的基本路径。<br> spring.data.rest.default-page-size =＃默认的页面大小。<br> spring.data.rest.enable-enum-translation =＃通过Spring Data REST默认资源包启用枚举值转换。<br> spring.data.rest.limit-param-name =＃URL查询字符串参数的名称，指示一次返回的结果数。<br> spring.data.rest.max-page-size =＃最大页面大小。<br> spring.data.rest.page-param-name =＃指示要返回哪个页面的URL查询字符串参数的名称。<br> spring.data.rest.return-body-on-create =＃创建实体后返回响应体。<br> spring.data.rest.return-body-on-update =＃更新实体后返回响应体。<br> spring.data.rest.sort-param-name =＃URL查询字符串参数的名称，指示对结果进行排序的方向。</p> 
<p>＃SOLR（SolrProperties）<br> spring.data.solr.host = HTTP ：//127.0.0.1：8983 / Solr的＃Solr的主机。如果设置了“zk-host”，则忽略。<br> spring.data.solr.repositories.enabled = true ＃启用Solr存储库。<br> spring.data.solr.zk-host =＃ZooKeeper主机地址，格式为HOST：PORT。</p> 
<p>＃DATASOURCE（DataSourceAutoConfiguration＆DataSourceProperties）<br> spring.datasource.continue-on-error = false ＃初始化数据库时发生错误时不要停止。<br> spring.datasource.data =＃Data（DML）脚本资源引用。<br> spring.datasource.driver-class-name =＃JDBC驱动程序的标准名称。默认情况下基于URL自动检测。<br> spring.datasource.initialize = true ＃使用’data.sql’填充数据库。<br> spring.datasource.jmx-enabled = false ＃启用JMX支持（如果由底层池提供）。<br> spring.datasource.jndi-name =＃JNDI数据源的位置。类，url，用户名和密码设置时将被忽略。<br> spring.datasource.max-active =＃例如100<br> spring.datasource.max-idle =＃例8<br> spring.datasource.max-wait =<br> spring .datasource.min-evictable-idle-time-millis =<br> spring .datasource.min-idle = 8<br> spring.datasource.name = testdb ＃数据源的名称。<br> spring.datasource.password =＃数据库的登录密码。<br> spring.datasource.platform = all ＃在模式资源（schema - $ {platform} .sql）中使用的平台。<br> spring.datasource.schema =＃模式（DDL）脚本资源引用。<br> spring.datasource.separator =; ＃SQL初始化脚本中的语句分隔符。<br> spring.datasource.sql-script-encoding =＃SQL脚本编码。<br> spring.datasource.test-on-borrow =＃例如false<br> spring.datasource.test-on-return =＃例如false<br> spring.datasource.test-while-idle =＃<br> spring.datasource.time-between-eviction-runs-millis = 1<br> spring.datasource.type =＃要使用的连接池实现的完全限定名称。默认情况下，它是从类路径自动检测。<br> spring.datasource.url =＃数据库的JDBC url。<br> spring.datasource.username =<br> spring .datasource.validation-query =</p> 
<p>＃H2 Web控制台（H2ConsoleProperties）<br> spring.h2.console.enabled = false ＃启用控制台。<br> spring.h2.console.path = / h2-console＃控制台可用的路径。</p> 
<p>＃JOOQ（JooqAutoConfiguration）<br> spring.jooq.sql-dialect =＃SQLDialect与配置的数据源通信时使用的JOOQ。例如POSTGRES</p> 
<p>＃JPA（JpaBaseConfiguration，HibernateJpaAutoConfiguration）<br> spring.data.jpa.repositories.enabled = true ＃启用JPA存储库。<br> spring.jpa.database =＃要操作的目标数据库，默认情况下自动检测。也可以使用“databasePlatform”属性进行设置。<br> spring.jpa.database-platform =＃要操作的目标数据库的名称，默认情况下自动检测。可以选择使用“数据库”设置枚举。<br> spring.jpa.generate-ddl = false ＃在启动时初始化模式。<br> spring.jpa.hibernate.ddl-auto =＃DDL模式。这实际上是“hibernate.hbm2ddl.auto”属性的快捷方式。使用嵌入式数据库时，默认为“create-drop”，否则为“none”。<br> spring.jpa.hibernate.naming-strategy =＃命名策略完全限定名。<br> spring.jpa.open-in-view = true ＃注册OpenEntityManagerInViewInterceptor。将JPA EntityManager绑定到线程以进行请求的整个处理。<br> spring.jpa.properties。* =＃在JPA提供程序上设置的其他本机属性。<br> spring.jpa.show-sql = false ＃启用SQL语句的日志记录。</p> 
<p>＃JTA（JtaAutoConfiguration）<br> spring.jta。* =＃技术特定配置<br> spring.jta.log-dir =＃事务日志目录。</p> 
<p>＃ATOMIKOS<br> spring.jta.atomikos.connectionfactory.borrow-connection-timeout = 30 ＃从池借用连接的超时（以秒为单位）。<br> spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag = true ＃创建会话时是否忽略事务标志。<br> spring.jta.atomikos.connectionfactory.local-transaction-mode = false ＃是否需要本地事务。<br> spring.jta.atomikos.connectionfactory.maintenance-interval = 60 ＃池维护线程运行之间的时间（以秒为单位）。<br> spring.jta.atomikos.connectionfactory.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。<br> spring.jta.atomikos.connectionfactory.max-lifetime = 0 ＃连接在被销毁之前可以被合并的时间（以秒为单位）。0表示无限制。<br> spring.jta.atomikos.connectionfactory.max-pool-size = 1 ＃池的最大大小。<br> spring.jta.atomikos.connectionfactory.min-pool-size = 1 ＃池的最小大小。<br> spring.jta.atomikos.connectionfactory.reap-timeout = 0 ＃借用连接的收集超时（以秒为单位）。0表示无限制。<br> spring.jta.atomikos.connectionfactory.unique-resource-name = jmsConnectionFactory ＃用于在恢复期间标识资源的唯一名称。<br> spring.jta.atomikos.datasource.borrow-connection-timeout = 30 ＃从池借用连接的超时（以秒为单位）。<br> spring.jta.atomikos.datasource.default-isolation-level =＃池提供的连接的默认隔离级别。<br> spring.jta.atomikos.datasource.login-timeout =＃建立数据库连接的超时（以秒为单位）。<br> spring.jta.atomikos.datasource.maintenance-interval = 60 ＃池维护线程运行之间的时间（以秒为单位）。<br> spring.jta.atomikos.datasource.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。<br> spring.jta.atomikos.datasource.max-lifetime = 0 ＃连接在被销毁之前可以被合并的时间（以秒为单位）。0表示无限制。<br> spring.jta.atomikos.datasource.max-pool-size = 1 ＃池的最大大小。<br> spring.jta.atomikos.datasource.min-pool-size = 1 ＃池的最小大小。<br> spring.jta.atomikos.datasource.reap-timeout = 0 ＃借用连接的收集超时（以秒为单位）。0表示无限制。<br> spring.jta.atomikos.datasource.test-query =＃用于在返回连接之前验证连接的SQL查询或语句。<br> spring.jta.atomikos.datasource.unique-resource-name = dataSource ＃用于在恢复期间标识资源的唯一名称。</p> 
<p>＃BITRONIX<br> spring.jta.bitronix.connectionfactory.acquire-increment = 1 ＃增加池时创建的连接数。<br> spring.jta.bitronix.connectionfactory.acquisition-interval = 1 ＃在获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。<br> spring.jta.bitronix.connectionfactory.acquisition-timeout = 30 ＃从池中获取连接的超时（以秒为单位）。<br> spring.jta.bitronix.connectionfactory.allow-local-transactions = true ＃事务管理器是否应该允许混合XA和非XA事务。<br> spring.jta.bitronix.connectionfactory.apply-transaction-timeout = false ＃是否应该在登记时在XAResource上设置事务超时。<br> spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled = true ＃资源是否应自动注册和删除。<br> spring.jta.bitronix.connectionfactory.cache-producers-consumers = true ＃是否生产和消费者应该被缓存。<br> spring.jta.bitronix.connectionfactory.defer-connection-release = true ＃提供程序是否可以在同一连接上运行多个事务，并支持事务交叉。<br> spring.jta.bitronix.connectionfactory.ignore-recovery-failures = false ＃是否应该忽略恢复失败。<br> spring.jta.bitronix.connectionfactory.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。<br> spring.jta.bitronix.connectionfactory.max-pool-size = 10 ＃池的最大大小。0表示无限制。<br> spring.jta.bitronix.connectionfactory.min-pool-size = 0 ＃池的最小大小。<br> spring.jta.bitronix.connectionfactory.password =＃用于连接到JMS提供程序的密码。<br> spring.jta.bitronix.connectionfactory.share-transaction-connections = false ＃是否可以在事务上下文中共享处于ACCESSIBLE状态的连接。<br> spring.jta.bitronix.connectionfactory.test-connections = true ＃从池中获取连接时是否应该进行测试。<br> spring.jta.bitronix.connectionfactory.two-pc-ordering-position = 1 ＃此资源在两阶段提交期间应采用的位置（始终为Integer.MIN_VALUE，始终为Integer.MAX_VALUE）。<br> spring.jta.bitronix.connectionfactory.unique-name = jmsConnectionFactory ＃用于在恢复期间标识资源的唯一名称。<br> spring.jta.bitronix.connectionfactory.use-tm-join = true 启动XAResources时是否应使用TMJOIN。<br> spring.jta.bitronix.connectionfactory.user =＃用于连接到JMS提供程序的用户。<br> spring.jta.bitronix.datasource.acquire-increment = 1 ＃增加池时创建的连接数。<br> spring.jta.bitronix.datasource.acquisition-interval = 1 ＃在获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。<br> spring.jta.bitronix.datasource.acquisition-timeout = 30 ＃从池中获取连接的超时（以秒为单位）。<br> spring.jta.bitronix.datasource.allow-local-transactions = true ＃事务管理器是否应允许混合XA和非XA事务。<br> spring.jta.bitronix.datasource.apply-transaction-timeout = false ＃是否应该在登记时在XAResource上设置事务超时。<br> spring.jta.bitronix.datasource.automatic-enlisting-enabled = true ＃资源是否应自动注册和删除。<br> spring.jta.bitronix.datasource.cursor-holdability =＃连接的默认游标保留能力。<br> spring.jta.bitronix.datasource.defer-connection-release = true ＃数据库是否可以在同一连接上运行多个事务，并支持事务交叉。<br> spring.jta.bitronix.datasource.enable-jdbc4-connection-test =＃从池中获取连接时是否调用Connection.isValid（）。<br> spring.jta.bitronix.datasource.ignore-recovery-failures = false ＃是否应该忽略恢复失败。<br> spring.jta.bitronix.datasource.isolation-level =＃连接的默认隔离级别。<br> spring.jta.bitronix.datasource.local-auto-commit =＃本地事务的默认自动提交模式。<br> spring.jta.bitronix.datasource.login-timeout =＃建立数据库连接的超时（以秒为单位）。<br> spring.jta.bitronix.datasource.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。<br> spring.jta.bitronix.datasource.max-pool-size = 10 ＃池的最大大小。0表示无限制。<br> spring.jta.bitronix.datasource.min-pool-size = 0 ＃池的最小大小。<br> spring.jta.bitronix.datasource.prepared-statement-cache-size = 0 ＃预准备语句缓存的目标大小。0禁用高速缓存。<br> spring.jta.bitronix.datasource.share-transaction-connections = false ＃是否可以在事务上下文中共享处于ACCESSIBLE状态的连接。<br> spring.jta.bitronix.datasource.test-query =＃用于在返回连接之前验证连接的SQL查询或语句。<br> spring.jta.bitronix.datasource.two-pc-ordering-position = 1 ＃这个资源在两阶段提交期间应该采用的位置（始终为Integer.MIN_VALUE，始终为Integer.MAX_VALUE）。<br> spring.jta.bitronix.datasource.unique-name = dataSource ＃用于在恢复期间标识资源的唯一名称。<br> spring.jta.bitronix.datasource.use-tm-join = true 启动XAResources时是否应使用TMJOIN。</p> 
<p>＃EMBEDDED MONGODB（EmbeddedMongoProperties）<br> spring.mongodb.embedded.features = SYNC_DELAY ＃要启用的功能的逗号分隔列表。<br> spring.mongodb.embedded.version = 2 .6.10＃使用Mongo的版本。</p> 
<p>＃REDIS（RedisProperties）<br> spring.redis.database = 0 ＃连接工厂使用的数据库索引。<br> spring.redis.host = localhost ＃Redis服务器主机。<br> spring.redis.password =＃redis服务器的登录密码。<br> spring.redis.pool.max-active = 8 ＃池在给定时间可以分配的最大连接数。使用负值无限制。<br> spring.redis.pool.max-idle = 8 ＃池中“空闲”连接的最大数量。使用负值来表示无限数量的空闲连接。<br> spring.redis.pool.max-wait = -1＃在池耗尽时抛出异常之前，连接分配应阻止的最大时间量（以毫秒为单位）。使用负值无限期地阻止。<br> spring.redis.pool.min-idle = 0 ＃要在池中维护的空闲连接的最小数目的目标。此设置仅当其为正时才具有效果。<br> spring.redis.port = 6379 ＃Redis服务器端口。<br> spring.redis.sentinel.master =＃Redis服务器的名称。<br> spring.redis.sentinel.nodes =＃主机：端口对的逗号分隔列表。<br> spring.redis.timeout = 0 ＃连接超时，以毫秒为单位。</p> 
<p>＃----------------------------------------<br> ＃集成属性<br> ＃----------------------------------------</p> 
<p>＃ACTIVEMQ（ActiveMQProperties）<br> spring.activemq.broker-url =＃ActiveMQ代理的URL。默认情况下自动生成。例如tcp：// localhost：61616<br> spring.activemq.in-memory = true ＃指定默认代理URL是否应该在内存中。如果指定了显式代理，则忽略。<br> spring.activemq.password =＃代理的登录密码。<br> spring.activemq.pooled = false ＃指定是否应创建PooledConnectionFactory而不是常规ConnectionFactory。<br> spring.activemq.user =＃代理的登录用户。</p> 
<p>＃ARTEMIS（ArtemisProperties）<br> spring.artemis.embedded.cluster-password =＃集群密码。默认情况下，在启动时随机生成。<br> spring.artemis.embedded.data-directory =＃日志文件目录。如果持久性已关闭，则不需要。<br> spring.artemis.embedded.enabled = true ＃如果Artemis服务器API可用，则启用嵌入模式。<br> spring.artemis.embedded.persistent = false ＃启用持久存储。<br> spring.artemis.embedded.queues =＃在启动时创建的逗号分隔的队列列表。<br> spring.artemis.embedded.server-id =＃服务器ID。默认情况下，使用自动递增计数器。<br> spring.artemis.embedded.topics =＃启动时创建的逗号分隔的主题列表。<br> spring.artemis.host = localhost ＃Artemis代理主机。<br> spring.artemis.mode =＃Artemis部署模式，默认情况下自动检测。可以显式设置为“本机”或“嵌入”。<br> spring.artemis.port = 61616 ＃Artemis代理端口。</p> 
<p>＃SPRING BATCH（BatchProperties）<br> spring.batch.initializer.enabled = true ＃如果需要，在启动时创建所需的批处理表。<br> spring.batch.job.enabled = true ＃在启动时在上下文中执行所有Spring Batch作业。<br> spring.batch.job.names =＃在启动时执行的作业名的逗号分隔列表（例如job1，job2）。默认情况下，在上下文中找到的所有作业都将被执行。<br> spring.batch.schema = classpath ：org / springframework / batch / core / schema - @@ platform @@。sql＃用于初始化数据库模式的SQL文件的路径。<br> spring.batch.table-prefix =＃所有批次元数据表的表前缀。</p> 
<p>＃HORNETQ（HornetQProperties）<br> spring.hornetq.embedded.cluster-password =＃群集密码。默认情况下，在启动时随机生成。<br> spring.hornetq.embedded.data-directory =＃日志文件目录。如果持久性已关闭，则不需要。<br> spring.hornetq.embedded.enabled = true ＃如果HornetQ服务器API可用，则启用嵌入模式。<br> spring.hornetq.embedded.persistent = false ＃启用持久存储。<br> spring.hornetq.embedded.queues =＃在启动时创建的逗号分隔的队列列表。<br> spring.hornetq.embedded.server-id =＃服务器ID。默认情况下，使用自动递增计数器。<br> spring.hornetq.embedded.topics =＃启动时创建的逗号分隔的主题列表。<br> spring.hornetq.host = localhost ＃HornetQ代理主机。<br> spring.hornetq.mode =＃HornetQ部署模式，默认情况下自动检测。可以显式设置为“本机”或“嵌入”。<br> spring.hornetq.port = 5445 ＃HornetQ代理端口。</p> 
<p>＃JMS（JmsProperties）<br> spring.jms.jndi-name =＃连接工厂JNDI名称。设置时，优先于其他连接工厂自动配置。<br> spring.jms.listener.acknowledge-mode =＃确认容器的模式。默认情况下，侦听器使用自动确认进行处理。<br> spring.jms.listener.auto-startup = true ＃在启动时自动启动容器。<br> spring.jms.listener.concurrency =＃最小并发消费者数。<br> spring.jms.listener.max-concurrency =＃最大并发消费者数。<br> spring.jms.pub-sub-domain = false ＃指定默认目标类型是否为主题。</p> 
<p>＃RABBIT（RabbitProperties）<br> spring.rabbitmq.addresses =＃客户端应连接到的地址的逗号分隔列表。<br> spring.rabbitmq.dynamic = true ＃创建一个AmqpAdmin bean。<br> spring.rabbitmq.host = localhost ＃RabbitMQ主机。<br> spring.rabbitmq.listener.acknowledge-mode =＃确认容器的模式。<br> spring.rabbitmq.listener.auto-startup = true ＃在启动时自动启动容器。<br> spring.rabbitmq.listener.concurrency =＃最小消费者数。<br> spring.rabbitmq.listener.max-concurrency =＃最大消费者数。<br> spring.rabbitmq.listener.prefetch =＃在单个请求中处理的消息数。它应该大于或等于事务大小（如果使用）。<br> spring.rabbitmq.listener.transaction-size =＃要在事务中处理的消息数。为了获得最佳结果，它应小于或等于预取计数。<br> spring.rabbitmq.password =＃登录以对代理进行身份验证。<br> spring.rabbitmq.port = 5672 ＃RabbitMQ端口。<br> spring.rabbitmq.requested-heartbeat =＃请求的心跳超时，以秒为单位; 零为零。<br> spring.rabbitmq.ssl.enabled = false ＃启用SSL支持。<br> spring.rabbitmq.ssl.key-store =＃包含SSL证书的密钥库的路径。<br> spring.rabbitmq.ssl.key-store-password =＃用于访问密钥库的密码。<br> spring.rabbitmq.ssl.trust-store =＃持有SSL证书的信任存储。<br> spring.rabbitmq.ssl.trust-store-password =＃用于访问信任存储库的密码。<br> spring.rabbitmq.username =＃登录用户以对代理进行身份验证。<br> spring.rabbitmq.virtual-host =＃连接到代理时要使用的虚拟主机。</p> 
<p>＃----------------------------------------<br> ＃执行器特性<br> ＃----------------------------------------</p> 
<p>＃ENDPOINTS（AbstractEndpoint subclasses）<br> endpoints.enabled = true ＃启用端点。<br> endpoints.sensitive =＃默认端点敏感设置。<br> endpoints.actuator.enabled = true ＃启用端点。<br> endpoints.actuator.path =＃端点URL路径。<br> endpoints.actuator.sensitive = false ＃在端点上启用安全性。<br> endpoints.autoconfig.enabled =＃启用端点。<br> endpoints.autoconfig.id =＃端点标识符。<br> endpoints.autoconfig.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.beans.enabled =＃启用端点。<br> endpoints.beans.id =＃端点标识符。<br> endpoints.beans.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.configprops.enabled =＃启用端点。<br> endpoints.configprops.id =＃终端标识符。<br> endpoints.configprops.keys-to-sanitize = password ，secret，key，。* credentials。，vcap_services＃应该进行清理的密钥。键可以是属性结尾的简单字符串或正则表达式。<br> endpoints.configprops.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.docs.curies.enabled = false ＃启用居里生成。<br> endpoints.docs.enabled = true ＃启用执行器docs端点。<br> endpoints.docs.path = / docs＃<br> endpoints.docs.sensitive = false ＃<br> endpoints.dump.enabled =＃启用端点。<br> endpoints.dump.id =＃端点标识符。<br> endpoints.dump.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.env.enabled =＃启用端点。<br> endpoints.env.id =＃端点标识符。<br> endpoints.env.keys-to-sanitize = password ，secret，key，。 credentials。，vcap_services＃应该清理的密钥。键可以是属性结尾的简单字符串或正则表达式。<br> endpoints.env.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.flyway.enabled =＃启用端点。<br> endpoints.flyway.id =＃端点标识符。<br> endpoints.flyway.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.health.enabled =＃启用端点。<br> endpoints.health.id =＃端点标识符。<br> endpoints.health.mapping。 =＃将健康状态映射到HttpStatus代码。默认情况下，注册的健康状态映射到明智的默认值（即UP映射到200）。<br> endpoints.health.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.health.time-to-live = 1000 ＃缓存结果的生存时间（以毫秒为单位）。<br> endpoints.info.enabled =＃启用端点。<br> endpoints.info.id =＃端点标识符。<br> endpoints.info.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.jolokia.enabled = true ＃启用Jolokia端点。<br> endpoints.jolokia.path = / jolokia＃端点URL路径。<br> endpoints.jolokia.sensitive = true ＃在端点上启用安全性。<br> endpoints.liquibase.enabled =＃启用端点。<br> endpoints.liquibase.id =＃端点标识符。<br> endpoints.liquibase.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.logfile.enabled = true ＃启用端点。<br> endpoints.logfile.path = / logfile＃端点URL路径。<br> endpoints.logfile.sensitive = true ＃在端点上启用安全性。<br> endpoints.mappings.enabled =＃启用端点。<br> endpoints.mappings.id =＃端点标识符。<br> endpoints.mappings.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.metrics.enabled =＃启用端点。<br> endpoints.metrics.filter.enabled = true ＃启用metrics servlet筛选器。<br> endpoints.metrics.id =＃端点标识符。<br> endpoints.metrics.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.shutdown.enabled =＃启用端点。<br> endpoints.shutdown.id =＃端点标识符。<br> endpoints.shutdown.sensitive =＃标记端点是否暴露敏感信息。<br> endpoints.trace.enabled =＃启用端点。<br> endpoints.trace.id =＃端点标识符。<br> endpoints.trace.sensitive =＃标记端点是否暴露敏感信息。</p> 
<p>＃ENDPOINTS CORS CONFIGURATION（EndpointCorsProperties）<br> endpoints.cors.allow-credentials =＃设置是否支持凭证。未设置时，不支持凭据。<br> endpoints.cors.allowed-headers =＃在请求中允许的逗号分隔的标头列表。’‘允许所有头。<br> endpoints.cors.allowed-methods = GET ＃允许的逗号分隔的方法列表。’‘允许所有方法。<br> endpoints.cors.allowed-origins =＃允许的逗号分隔的起始列表。’*'允许所有起源。未设置时，禁用CORS支持。<br> endpoints.cors.exposed-headers =＃要在响应中包含的标头的逗号分隔列表。<br> endpoints.cors.max-age = 1800 ＃客户端可以缓存来自预先请求的响应的缓存时间（秒）。</p> 
<p>＃JMX ENDPOINT（EndpointMBeanExportProperties）<br> endpoints.jmx.domain =＃JMX域名。如果设置，则使用’spring.jmx.default-domain’的值初始化。<br> endpoints.jmx.enabled = true ＃启用所有端点的JMX导出。<br> endpoints.jmx.static-names =＃附加到表示端点的MBeans的所有ObjectNames的附加静态属性。<br> endpoints.jmx.unique-names = false ＃确保在冲突的情况下修改ObjectName。</p> 
<p>＃JOLOKIA（JolokiaProperties）<br> jolokia.config。* =＃请参阅Jolokia手册</p> 
<p>＃MANAGEMENT HTTP SERVER（ManagementServerProperties）<br> management.add-application-context-header = true ＃在每个响应中添加“X-Application-Context”HTTP头。<br> management.address =＃管理端点应绑定的网络地址。<br> management.context-path =＃管理端点上下文路径。例如`/ actuator’<br> management.port =＃管理端点HTTP端口。默认情况下，使用与应用程序相同的端口。<br> management.security.enabled = true ＃启用安全性。<br> management.security.role = ADMIN ＃访问管理端点所需的角色。<br> management.security.sessions = stateless ＃会话创建要使用的策略（始终，永远，if_required，无状态）。</p> 
<p>＃健康指数（以前的健康。*）<br> management.health.db.enabled = true ＃启用数据库运行状况检查。<br> management.health.defaults.enabled = true ＃启用默认运行状况指示器。<br> management.health.diskspace.enabled = true ＃启用磁盘空间运行状况检查。<br> management.health.diskspace.path =＃用于计算可用磁盘空间的路径。<br> management.health.diskspace.threshold = 0 ＃应该可用的最小磁盘空间（以字节为单位）。<br> management.health.elasticsearch.enabled = true ＃启用elasticsearch运行状况检查。<br> management.health.elasticsearch.indices =＃逗号分隔的索引名称。<br> management.health.elasticsearch.response-timeout = 100 ＃等待集群响应的时间（以毫秒为单位）。<br> management.health.jms.enabled = true ＃启用JMS运行状况检查。<br> management.health.mail.enabled = true ＃启用邮件运行状况检查。<br> management.health.mongo.enabled = true ＃启用MongoDB运行状况检查。<br> management.health.rabbit.enabled = true ＃启用RabbitMQ运行状况检查。<br> management.health.redis.enabled = true ＃启用Redis运行状况检查。<br> management.health.solr.enabled = true ＃启用Solr运行状况检查。<br> management.health.status.order = DOWN ，OUT_OF_SERVICE，UNKNOWN，UP＃按严重性顺序列出健康状态的逗号分隔列表。</p> 
<p>＃TRACING（（TraceProperties）<br> management.trace.include = request -headers，response-headers，errors＃要包括在跟踪中的项目。</p> 
<p>＃遥控器<br> shell.auth = simple ＃认证类型。根据环境自动检测。<br> shell.auth.jaas.domain = my -domain＃JAAS域。<br> shell.auth.key.path =＃认证密钥的路径。这应该指向一个有效的“.pem”文件。<br> shell.auth.simple.user.name = user ＃登录用户。<br> shell.auth.simple.user.password =＃登录密码。<br> shell.auth.spring.roles = ADMIN ＃登录到CRaSH控制台的必需角色的逗号分隔列表。<br> shell.command-path-patterns = classpath *：/ commands / **，classpath *：/ crash / commands / **＃用于查找命令的模式。<br> shell.command-refresh-interval = -1＃扫描更改并在必要时更新命令（以秒为单位）。<br> shell.config-path-patterns = classpath *：/ crash / *＃用于查找配置的模式。<br> shell.disabled-commands = jpa *，jdbc *，jndi *＃禁用的逗号分隔的命令列表。<br> shell.disabled-plugins =＃禁用的逗号分隔的插件列表。某些插件根据环境默认禁用。<br> shell.ssh.auth-timeout =＃用户将被提示再次登录的毫秒数。<br> shell.ssh.enabled = true ＃启用CRaSH SSH支持。<br> shell.ssh.idle-timeout =＃未使用的连接关闭之前的毫秒数。<br> shell.ssh.key-path =＃SSH服务器密钥的路径。<br> shell.ssh.port = 2000 ＃SSH端口。<br> shell.telnet.enabled = false ＃启用CRaSH telnet支持。如果TelnetPlugin可用，默认情况下启用。<br> shell.telnet.port = 5000 ＃Telnet端口。</p> 
<p>＃GIT INFO<br> spring.git.properties =＃对生成的git信息属性文件的资源引用。</p> 
<p>＃METRICS EXPORT（MetricExportProperties）<br> spring.metrics.export.aggregate.key-pattern =＃告诉聚合器如何处理源存储库中的键的模式。<br> spring.metrics.export.aggregate.prefix =＃如果处于活动状态，则为全局存储库的前缀。<br> spring.metrics.export.delay-millis = 5000 ＃导出ticks之间的延迟（以毫秒为单位）。度量标准将按照此延迟的计划导出到外部源。<br> spring.metrics.export.enabled = true ＃标记以启用度量导出（假设MetricWriter可用）。<br> spring.metrics.export.excludes =＃要排除的指标名称的模式列表。应用后包括。<br> spring.metrics.export.includes =＃要包括的指标名称的模式列表。<br> spring.metrics.export.redis.key = keys .spring.metrics＃redis存储库导出的键（如果为活动状态）。<br> spring.metrics.export.redis.prefix = spring .metrics＃redis存储库的前缀（如果活动）。<br> spring.metrics.export.send-latest =＃根据不导出不变的度量标准值，关闭任何可用的优化。<br> spring.metrics.export.statsd.host =＃接收导出指标的statsd服务器的主机。<br> spring.metrics.export.statsd.port = 8125 ＃用于接收导出指标的statsd服务器的端口。<br> spring.metrics.export.statsd.prefix =＃statsd导出的指标的前缀。<br> spring.metrics.export.triggers。* =＃每个MetricWriter bean名称的特定触发器属性。</p> 
<p>＃----------------------------------------<br> ＃DEVTOOLS PROPERTIES<br> ＃----------------------------------------</p> 
<p>＃DEVTOOLS（DevToolsProperties）<br> spring.devtools.livereload.enabled = true ＃启用livereload.com兼容的服务器。<br> spring.devtools.livereload.port = 35729 ＃服务器端口。<br> spring.devtools.restart.additional-exclude =＃应该排除触发完全重新启动的其他模式。<br> spring.devtools.restart.additional-paths =＃监视更改的其他路径。<br> spring.devtools.restart.enabled = true ＃启用自动重新启动。<br> spring.devtools.restart.exclude = META -INF / maven / **，META-INF / resources / **，resources / **，static / **，public / ，templates / ， / Test.class， / * Tests.class，git.properties＃应该排除触发完全重新启动的模式。<br> spring.devtools.restart.poll-interval = 1000 ＃轮询类路径更改之间等待的时间（以毫秒为单位）。<br> spring.devtools.restart.quiet-period = 400 ＃触发重新启动之前，没有任何类路径更改所需的安静时间量（以毫秒为单位）。<br> spring.devtools.restart.trigger-file =＃更改时将触发重新启动检查的特定文件的名称。如果没有指定任何classpath文件更改将触发重新启动。</p> 
<p>＃REMOTE DEVTOOLS（RemoteDevToolsProperties）<br> spring.devtools.remote.context-path = /。~~ spring-boot！〜＃上下文路径用于处理远程连接。<br> spring.devtools.remote.debug.enabled = true ＃启用远程调试支持。<br> spring.devtools.remote.debug.local-port = 8000 ＃本地远程调试服务器端口。<br> spring.devtools.remote.proxy.host =＃用于连接到远程应用程序的代理的主机。<br> spring.devtools.remote.proxy.port =＃用于连接到远程应用程序的代理端口。<br> spring.devtools.remote.restart.enabled = true ＃启用远程重新启动。<br> spring.devtools.remote.secret =＃建立连接所需的共享密钥（启用远程支持所需）。<br> spring.devtools.remote.secret-header-name = X -AUTH-TOKEN＃用于传输共享密钥的HTTP头。</p> 
<p>作者：斜月86<br> 链接：https://www.jianshu.com/p/e35825907132<br> 来源：简书<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10275a0ae6d5b117704ab0b5dac1167b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file &#34;</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac0397ea7127b8cf5bb44de5d772b2ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里云Code（code.aliyun）提交代码时报错fatal: Authentication failed for‘https://code.aliyun.com/...‘身份验证失败</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>