<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JS中的递归 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JS中的递归" />
<meta property="og:description" content="递归函数 在js中函数自己调用自己，就称为递归。
递归函数的必要条件 递归方程以及递归结束条件，即给递归函数安排出口，否则会造成无限递归，无限递归会造成执行栈溢出，浏览器会报错。
递归的用法 一.利用递归代替for循环 //依次打印1~10 for (var i = 1; i &lt;= 10; i&#43;&#43;) { console.log(i); } //借用递归实现 function fn(e) { console.log(&#43;&#43;e); if (e === 10) { return } fn(e) } fn(0) 以上就利用递归实现了依次输出1~10，e初始化为0，打印e&#43;&#43;所以输出1，当e等与10的时候结束，否则继续调用函数自身，依次类推，直至达到结束条件。
二.经典案例——斐波那契数列 斐波那契数列:1，1，2，3，5，8，13......
即从第三个数开始，每一个数等于前两个数之和
用代码实现：
function f(n) { // 实现代码 if (n === 1 || n === 2) { return 1; } return f(n - 1) &#43; f(n - 2); } console.log(f(8)); //21 即f（n）=f（n-1）&#43;f（n-2）
初始化n为8，判断n是否等于1或2，否则返回f（7）&#43;f（6），继续调用自身，以此类推直至n-1等于2以及n-2=1。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5ff7978aa41024cfb161ef2cd9d31b97/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-20T17:35:47+08:00" />
<meta property="article:modified_time" content="2021-06-20T17:35:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JS中的递归</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>递归函数</h2> 
<p>在js中函数自己调用自己，就称为递归。</p> 
<p> </p> 
<h2>递归函数的必要条件</h2> 
<p>递归方程以及递归结束条件，即给递归函数安排出口，否则会造成无限递归，无限递归会造成执行栈溢出，浏览器会报错。</p> 
<h2>递归的用法</h2> 
<h4>一.利用递归代替for循环</h4> 
<pre><code>        //依次打印1~10
        for (var i = 1; i &lt;= 10; i++) {
            console.log(i);
        }


        //借用递归实现
        function fn(e) {
            console.log(++e);
            if (e === 10) {
                return
            }
            fn(e)
        }
        fn(0)</code></pre> 
<p>以上就利用递归实现了依次输出1~10，e初始化为0，打印e++所以输出1，当e等与10的时候结束，否则继续调用函数自身，依次类推，直至达到结束条件。</p> 
<p> </p> 
<h4>二.经典案例——斐波那契数列</h4> 
<p>斐波那契数列:1，1，2，3，5，8，13......</p> 
<p>即从第三个数开始，每一个数等于前两个数之和</p> 
<p>用代码实现：</p> 
<pre><code>function f(n) {
            // 实现代码
             if (n === 1 || n === 2) {
                 return 1;
             }
            return f(n - 1) + f(n - 2);
        }
        console.log(f(8)); //21


</code></pre> 
<p>即f（n）=f（n-1）+f（n-2）</p> 
<p>初始化n为8，判断n是否等于1或2，否则返回f（7）+f（6），继续调用自身，以此类推直至n-1等于2以及n-2=1。</p> 
<p> </p> 
<h4>三.利用递归实现多级遍历，以及深克隆。</h4> 
<pre><code>//创建一个对象obj，其中的friend属性也是一个对象，friend里的student也是一个对象
var obj = {
            name: 'ls',
            age: 4,
            sex: 'nan',
            friend: {
                name: 'djw',
                age: 24,
                sex: 'nan',
                student: {
                    name: 'xlq',
                    age: 23,
                    sex: 'nan'
                }
            }
        }


function clone(obj) {
            if (typeof obj != 'object') {   //判断目标对象数据类型，不是对象则直接返回
                return obj;
            }
            var newObj = {}    //创建一个空对象，用以存放遍历后克隆的属性
            for (k in obj) {
                newObj[k] = clone(obj[k]);   //用递归实现深克隆
            }
            return newObj;
        }
</code></pre> 
<p>遍历当前对象，判断是否存在其他对象，是则继续遍历，直到没有，利用递归对需要深层遍历的属性再进行遍历。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/784934bad184be2037b3938b1a82c14b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">展开与收起</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9057fb5395a1562a3f387a7a53baefe3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">近20年家用计算机的发展过程,计算机的发展史有哪几个阶段</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>