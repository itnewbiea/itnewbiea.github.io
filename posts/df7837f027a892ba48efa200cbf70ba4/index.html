<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机图形学——利用MFC库绘制直线（DDA算法和Bresenham算法） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机图形学——利用MFC库绘制直线（DDA算法和Bresenham算法）" />
<meta property="og:description" content="问题描述 利用MFC库实现直线的绘制（分别使用DDA算法和Bresenham算法）
求解思路 创建MFC APP项目，选择Dialog Based模板，如下：
1. 对话框设计 利用TOOL BOX中的工具修改主对话框（如果TOOL BOX没有的话，在view中打开）
添加两个绘图框，分别对应DDA算法和Bresenham算法，ID为IDC_STATIC_DRAW_AREA1和IDC_STATIC_DRAW_AREA2
添加两个按钮，ID为IDC_BUTTON_DDA和IDC_BUTTON_BRESENHAM
添加四个文本编辑框便于输入坐标值，ID为IDC_EDIT_START1, IDC_EDIT_START2, IDC_EDIT_END1, IDC_EDIT_END2
添加静态文本框
注：修改ID需要选中对象，点击属性，然后在属性中修改ID
效果如下图：
2. 算法设计 DDA算法 算法描述略
Bresenham算法 获取起点和终点坐标：首先获取直线的起点坐标 (x0, y0) 和终点坐标 (x1, y1)
计算dx和dy：计算 dx = x1 - x0 和 dy = y1 - y0
计算p0初始值： p_0 = 2*dy - dx，这是初始的决策参数。p_k 用于决定下一个要绘制的像素的位置
Bresenham主循环：在每一步中，根据 p_k 的值来决定下一个要绘制的像素
如果 p_k 小于0，则下一个像素位于 (x_k &#43; 1, y_k)，并且 p_{k&#43;1} = p_k &#43; 2*dy
如果 p_k 大于等于0，则下一个像素位于 (x_k &#43; 1, y_k &#43; 1)，并且 p_{k&#43;1} = p_k &#43; 2*dy - 2*dx" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/df7837f027a892ba48efa200cbf70ba4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-27T18:20:48+08:00" />
<meta property="article:modified_time" content="2023-09-27T18:20:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机图形学——利用MFC库绘制直线（DDA算法和Bresenham算法）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>问题描述</h2> 
<p>利用MFC库实现直线的绘制（分别使用DDA算法和Bresenham算法）</p> 
<h2><a id="_4"></a>求解思路</h2> 
<p>创建MFC APP项目，选择Dialog Based模板，如下：</p> 
<p><img src="https://images2.imgbox.com/1a/a9/LXQDOY3B_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__10"></a>1. 对话框设计</h3> 
<p>利用TOOL BOX中的工具修改主对话框（如果TOOL BOX没有的话，在view中打开）</p> 
<ul><li> <p>添加两个绘图框，分别对应DDA算法和Bresenham算法，ID为<code>IDC_STATIC_DRAW_AREA1</code>和<code>IDC_STATIC_DRAW_AREA2</code></p> </li><li> <p>添加两个按钮，ID为<code>IDC_BUTTON_DDA</code>和<code>IDC_BUTTON_BRESENHAM</code></p> </li><li> <p>添加四个文本编辑框便于输入坐标值，ID为<code>IDC_EDIT_START1</code>, <code>IDC_EDIT_START2</code>, <code>IDC_EDIT_END1</code>, <code>IDC_EDIT_END2</code></p> </li><li> <p>添加静态文本框</p> </li></ul> 
<p>注：修改ID需要选中对象，点击属性，然后在属性中修改ID</p> 
<p>效果如下图：</p> 
<p><img src="https://images2.imgbox.com/7a/5e/dMB4BVXB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__27"></a>2. 算法设计</h3> 
<h4><a id="DDA_29"></a>DDA算法</h4> 
<p>算法描述略</p> 
<h4><a id="Bresenham_33"></a>Bresenham算法</h4> 
<ol><li> <p><strong>获取起点和终点坐标</strong>：首先获取直线的起点坐标 <code>(x0, y0)</code> 和终点坐标 <code>(x1, y1)</code></p> </li><li> <p><strong>计算dx和dy</strong>：计算 <code>dx = x1 - x0</code> 和 <code>dy = y1 - y0</code></p> </li><li> <p><strong>计算p0初始值</strong>： <code>p_0 = 2*dy - dx</code>，这是初始的决策参数。<code>p_k</code> 用于决定下一个要绘制的像素的位置</p> </li><li> <p><strong>Bresenham主循环</strong>：在每一步中，根据 <code>p_k</code> 的值来决定下一个要绘制的像素</p> </li></ol> 
<ul><li> <p>如果 <code>p_k</code> 小于0，则下一个像素位于 <code>(x_k + 1, y_k)</code>，并且 <code>p_{k+1} = p_k + 2*dy</code></p> </li><li> <p>如果 <code>p_k</code> 大于等于0，则下一个像素位于 <code>(x_k + 1, y_k + 1)</code>，并且 <code>p_{k+1} = p_k + 2*dy - 2*dx</code></p> </li></ul> 
<ol start="5"><li><strong>重复绘制直线</strong>：重复步骤4的过程，共计算 <code>dx</code> 次，以绘制整条直线</li></ol> 
<h2><a id="_49"></a>程序代码</h2> 
<p>需要修改<code>LineDlg.cpp</code>和<code>LineDlg.h</code>两个文件</p> 
<p>注意：在点击按钮获取坐标后，需要将坐标映射到两个绘图框内，并在坐标超出绘图框范围时给出提示</p> 
<h3><a id="1_LineDlgcpp_55"></a>1. LineDlg.cpp</h3> 
<p>主要需要添加四个函数，分别为两种算法绘制的函数和对应的按钮点击函数，实现代码如下：</p> 
<h4><a id="DDA_59"></a>DDA算法</h4> 
<pre><code class="prism language-C++">// 点击DDA按钮将执行的操作
void CLineDlg::OnBnClickedButtonDDA() {
    // 从编辑框中获取坐标
    CString strX0, strY0, strX1, strY1;
    // 起点坐标
    GetDlgItemText(IDC_EDIT_START1, strX0);
    GetDlgItemText(IDC_EDIT_START2, strY0);
    // 终点坐标
    GetDlgItemText(IDC_EDIT_END1, strX1);
    GetDlgItemText(IDC_EDIT_END2, strY1);

    int startX = _ttoi(strX0);
    int startY = _ttoi(strY0);
    int endX = _ttoi(strX1);
    int endY = _ttoi(strY1);

    // 获取绘图框的边界矩形
    CRect rectDrawArea1;
    GetDlgItem(IDC_STATIC_DRAW_AREA1)-&gt;GetClientRect(rectDrawArea1);

    // 映射坐标到绘图框的坐标系
    startX -= rectDrawArea1.left;
    startY -= rectDrawArea1.top;
    endX -= rectDrawArea1.left;
    endY -= rectDrawArea1.top;

    // 在绘制直线之前检查坐标是否在绘图框内
    if (startX &gt;= 0 &amp;&amp; startX &lt; rectDrawArea1.Width() &amp;&amp;
        startY &gt;= 0 &amp;&amp; startY &lt; rectDrawArea1.Height() &amp;&amp;
        endX &gt;= 0 &amp;&amp; endX &lt; rectDrawArea1.Width() &amp;&amp;
        endY &gt;= 0 &amp;&amp; endY &lt; rectDrawArea1.Height()) {
        // 坐标在绘图框内，可以绘制直线
        // 调用DDA函数
        DrawLineDDA(startX, startY, endX, endY);
    } else {
        // 坐标超出了绘图框的边界，错误提示
        CString message = _T("坐标超出绘图框的边界，请重新输入");
        CString caption = _T("错误");
        MessageBox(message, caption, MB_ICONERROR);
    }
}
</code></pre> 
<pre><code class="prism language-C++">// DDA算法
void CLineDlg::DrawLineDDA(int x1, int y1, int x2, int y2) {
    CDC *pDC = GetDlgItem(IDC_STATIC_DRAW_AREA1)-&gt;GetDC();

    int dx = x2 - x1;
    int dy = y2 - y1;
    int L = abs(dx) &gt; abs(dy) ? abs(dx) : abs(dy);

    float dx = static_cast&lt;float&gt;(dx) / static_cast&lt;float&gt;(L);
    float dy = static_cast&lt;float&gt;(dy) / static_cast&lt;float&gt;(L);

    float x = static_cast&lt;float&gt;(x1);
    float y = static_cast&lt;float&gt;(y1);

    pDC-&gt;MoveTo(x1, y1);

    for (int i = 0; i &lt; L; i++) {
        x += dx;
        y += dy;

        pDC-&gt;LineTo(static_cast&lt;int&gt;(x), static_cast&lt;int&gt;(y));
    }
}
</code></pre> 
<h4><a id="Bresenham_133"></a>Bresenham算法</h4> 
<pre><code class="prism language-C++">// Bresenham算法
void CLineDlg::DrawLineBresenham(int x1, int y1, int x2, int y2) {

        // 计算dx和dy
        int dx = abs(x2 - x1);
        int dy = abs(y2 - y1);

        // 计算步长方向，根据步长方向来决定递增还是递减
        int stepX = (x1 &lt; x2) ? 1 : -1;
        int stepY = (y1 &lt; y2) ? 1 : -1;

        // 初始化p0和起始点
        int p = 2 * dy - dx;
        int x = x1;
        int y = y1;

        // 获取IDC_STATIC_DRAW_AREA2
        CStatic* pStaticDrawArea2 = (CStatic*)GetDlgItem(IDC_STATIC_DRAW_AREA2);
        CDC* pDC = pStaticDrawArea2-&gt;GetDC();

        // 绘制起点
        pDC-&gt;SetPixel(x, y, RGB(0, 0, 0)); // 在指定位置绘制像素点

        // 循环绘制直线
        for (int k = 0; k &lt; dx; k++)
        {
            // 根据pk决定下一个点的位置
            if (p &lt; 0)
            {
                x += stepX;
                p += 2 * dy;
            }
            else
            {
                x += stepX;
                y += stepY;
                p += 2 * (dy - dx);
            }

            // 绘制像素点
            pDC-&gt;SetPixel(x, y, RGB(0, 0, 0));
        }

        // 释放设备
        pStaticDrawArea2-&gt;ReleaseDC(pDC);
}
</code></pre> 
<pre><code class="prism language-C++">// 点击Bresenham按钮将执行的操作
void CLineDlg::OnBnClickedButtonBresenham() {
    // 从编辑框中获取坐标
    CString strX0, strY0, strX1, strY1;
    // 起点坐标
    GetDlgItemText(IDC_EDIT_START1, strX0);
    GetDlgItemText(IDC_EDIT_START2, strY0);
    // 终点坐标
    GetDlgItemText(IDC_EDIT_END1, strX1);
    GetDlgItemText(IDC_EDIT_END2, strY1);

    int startX = _ttoi(strX0);
    int startY = _ttoi(strY0);
    int endX = _ttoi(strX1);
    int endY = _ttoi(strY1);

    // 获取绘图框的边界矩形
    CRect rectDrawArea2;
    GetDlgItem(IDC_STATIC_DRAW_AREA2)-&gt;GetClientRect(rectDrawArea2);

    // 映射坐标到绘图框的坐标系
    startX -= rectDrawArea2.left;
    startY -= rectDrawArea2.top;
    endX -= rectDrawArea2.left;
    endY -= rectDrawArea2.top;

    // 在绘制直线之前检查坐标是否在绘图框内
    if (startX &gt;= 0 &amp;&amp; startX &lt; rectDrawArea2.Width() &amp;&amp;
        startY &gt;= 0 &amp;&amp; startY &lt; rectDrawArea2.Height() &amp;&amp;
        endX &gt;= 0 &amp;&amp; endX &lt; rectDrawArea2.Width() &amp;&amp;
        endY &gt;= 0 &amp;&amp; endY &lt; rectDrawArea2.Height()) {
        // 坐标在绘图框内，可以绘制直线
        // 调用Bresenham函数
        DrawLineBresenham(startX, startY, endX, endY);
    } else {
        // 坐标超出了绘图框的边界，错误提示
        CString message = _T("坐标超出绘图框的边界，请重新输入");
        CString caption = _T("错误");
        MessageBox(message, caption, MB_ICONERROR);
    }
}
</code></pre> 
<h3><a id="2_LineDlgh_230"></a>2. LineDlg.h</h3> 
<p>主要需要增加cpp文件中使用的几个函数（添加到public属性中），见下图红框中的四个函数</p> 
<p><img src="https://images2.imgbox.com/a3/8c/wTff0W6P_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_236"></a>实验结果</h2> 
<p>运行整个项目后，弹出对话框</p> 
<p>分别在文本框中输入起点和终点的坐标，并点击DDA或Bresenham按钮，相应的直线就会在对应的绘图框中展示，如下图：</p> 
<p><img src="https://images2.imgbox.com/ff/57/HzlUtSqX_o.png" alt="在这里插入图片描述"></p> 
<p>如果输入的坐标超出了绘图框的限制，则弹出错误提示，如下图：</p> 
<p><img src="https://images2.imgbox.com/ab/7a/aHwocnis_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/24b4412f1eebefd65e5bfa96b83f4316/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue input输入框限制输入负号、数字、以及两位小数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36320707215917ff321b5af7a6a75957/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电脑出现错误代码0x8004005应该如何解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>