<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java基础】基本类型和包装类的区别 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java基础】基本类型和包装类的区别" />
<meta property="og:description" content="前言 Java 一种静态编程语言，所有变量和表达式是在编译时就确定的。同时，Java 又是一种强类型语言，所有的变量和表达式都有具体的类型，并且每种类型是严格定义的。在 Java 中共有8种基本类型数据，同时每种基本类型又有对应的包装类。
基本数据类型（默认值）包装类（默认值）取值范围byte (0)Byte (null)-128～127short (0)Short (null)-32768～32767int (0)Integer (null)-231 ～ 2(31-1)long (0)Long (null)-263 ~ 2(63-1)float (0.0)Float (null)1.4E-45~3.4028235E38double (0.0)Double (null)4.9E-324~1.7976931348623157E308boolean (false)Boolean (null)true或falsechar (为空)Character (null)0～65535 一、包装类型可以为null，而基本类型不可以 包装类型可以应用于POJO中（POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO 等），而基本类型不行和POJO类似的，还有传输对象DTO（接收前端传参）、视图对象VO（返回给前端的数据）、ENTITY（与数据库表中的字段含义完全对应，表的实体类）为什么POJO的属性必须要用包装类型呢？ 《阿里巴巴Java开发手册》这样说明：数据库的查询结果可能是null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把Integer 对象转换成int值），就会抛出 NullPointerException 的异常。案例：下面的代码可以编译通过，但是会抛出空指针异常（java.lang.NullPointerException）。int b = a 实际上是 int b = a.intValue()，由于 a 的引用值为 null ，在空对象上调用方法就会抛出 NullPointerException 异常。 @Test public void a34() { Integer a = null; int b = a; System.out.println(b); } 二、包装类型可用于泛型，而基本类型不可以 泛型不能使用基本类型，因为使用基本类型时会编译出错。
List&lt;int&gt; list = new ArrayList&lt;&gt;(); // 提示 Syntax error, insert &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/689242dc099f376b5b473c8bbb954c0c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-19T15:50:17+08:00" />
<meta property="article:modified_time" content="2022-07-19T15:50:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java基础】基本类型和包装类的区别</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>Java 一种静态编程语言，所有变量和表达式是在编译时就确定的。同时，Java 又是一种强类型语言，所有的变量和表达式都有具体的类型，并且每种类型是严格定义的。在 Java 中共有8种基本类型数据，同时每种基本类型又有对应的包装类。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:178px;">基本数据类型（默认值）</td><td style="width:163px;">包装类（默认值）</td><td style="width:167px;">取值范围</td></tr><tr><td style="width:178px;">byte (0)</td><td style="width:163px;">Byte (null)</td><td style="width:167px;">-128～127</td></tr><tr><td style="width:178px;">short (0)</td><td style="width:163px;">Short (null)</td><td style="width:167px;">-32768～32767</td></tr><tr><td style="width:178px;">int (0)</td><td style="width:163px;">Integer (null)</td><td style="width:167px;">-231 ～ 2(31-1)</td></tr><tr><td style="width:178px;">long (0)</td><td style="width:163px;">Long (null)</td><td style="width:167px;">-263 ~ 2(63-1)</td></tr><tr><td style="width:178px;">float (0.0)</td><td style="width:163px;">Float (null)</td><td style="width:167px;">1.4E-45~3.4028235E38</td></tr><tr><td style="width:178px;">double (0.0)</td><td style="width:163px;">Double (null)</td><td style="width:167px;">4.9E-324~1.7976931348623157E308</td></tr><tr><td style="width:178px;">boolean (false)</td><td style="width:163px;">Boolean (null)</td><td style="width:167px;">true或false</td></tr><tr><td style="width:178px;">char (为空)</td><td style="width:163px;">Character (null)</td><td style="width:167px;">0～65535</td></tr></tbody></table> 
<h2>一、包装类型可以为null，而基本类型不可以</h2> 
<ul><li>包装类型可以应用于POJO中（POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO 等），而基本类型不行</li><li>和POJO类似的，还有传输对象DTO（接收前端传参）、视图对象VO（返回给前端的数据）、ENTITY（与数据库表中的字段含义完全对应，表的实体类）</li><li>为什么POJO的属性必须要用包装类型呢？ 
  <ul><li>《阿里巴巴Java开发手册》这样说明：数据库的查询结果可能是null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把Integer 对象转换成int值），就会抛出 NullPointerException 的异常。</li></ul></li><li>案例：下面的代码可以编译通过，但是会抛出空指针异常（java.lang.NullPointerException）。int b = a 实际上是 int b = a.intValue()，由于 a 的引用值为 null ，在空对象上调用方法就会抛出 NullPointerException 异常。 
  <ul><li> <pre><code class="language-java">    @Test
    public void a34() {
        Integer a = null;
        int b = a;
        System.out.println(b);
    }</code></pre> </li></ul></li></ul> 
<h2>二、包装类型可用于泛型，而基本类型不可以</h2> 
<p>        泛型不能使用基本类型，因为使用基本类型时会编译出错。</p> 
<pre><code class="language-java">List&lt;int&gt; list = new ArrayList&lt;&gt;(); // 提示 Syntax error, insert "Dimensions" to complete ReferenceType
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></pre> 
<h2>三、基本类型比包装类型更高效</h2> 
<p>        基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。</p> 
<p></p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/94/39/jyeXgT6w_o.png" width="461"></p> 
<p>        很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间（堆中占一块内存，栈中也占用一块内存）。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过new一个包装类型就显得非常笨重。</p> 
<h2> 四、两个包装类型得值可以相同，但却不相等</h2> 
<pre><code class="language-java">    @Test
    public void a31() {
        Integer integer = new Integer(10);
        Integer integer1 = new Integer(10);
        System.out.println(integer == integer1);        // false
        System.out.println(integer.equals(integer1));   // true
    }</code></pre> 
<ul><li>==判断的是是否引用同一个对象（判断基本类型比较的是值，判断引用类型比较的是地址，包装类型就是基本数据类型得引用类型）</li><li>这里==比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象</li><li>为什么 integer.equals(integer1) 的输出结果为true，是因为 equals 方法内部比较的是两个 int 值是否相等。源码如下： 
  <ul><li> <pre><code class="language-java">private final int value;

public int intValue() {
    return value;
}
public boolean equals(Object obj) {
    if (obj instanceof Integer) {
        return value == ((Integer)obj).intValue();
    }
    return false;
}
</code></pre> </li></ul></li></ul> 
<h2> 五、自动装箱和自动拆箱</h2> 
<p>既然有了基本类型和包装类型，肯定有些时候要在它们之间进行转换。把基本类型转换成包装类型的过程叫做装箱（boxing），反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</p> 
<ul><li> 在 Java SE5 之前，开发人员要手动进行装拆箱，比如说：</li></ul> 
<pre><code class="language-java">        Integer a = new Integer(10);  // 手动装箱
        int i = a.intValue();       //  手动拆箱
        System.out.println(i);     //  10</code></pre> 
<ul><li>Java SE5 为了减少开发人员的工作，提供了自动装箱与自动拆箱的功能。</li></ul> 
<pre><code class="language-java">        Integer b = 10;     // 自动装箱
        int c = b;          // 自动拆箱
        System.out.println(c);  // 10</code></pre> 
<p>反编译过程如下：</p> 
<pre><code class="language-java">        Integer d = Integer.valueOf(10);  // 自动装箱
        int e = d.intValue();             // 自动拆箱
        System.out.println(e);  // 10</code></pre> 
<ul><li>也就是说，自动装箱是通过 Integer.valueOf() 完成的，自动拆箱是通过 Integer.intValue() 完成的。</li></ul> 
<h4>1、下面看一道面试题：</h4> 
<pre><code class="language-java">// 1）基本类型和包装类型
int a = 100;
Integer b = 100;
System.out.println(a == b); // true

// 2）两个包装类型
Integer c = 100;
Integer d = 100;
System.out.println(c == d); // true

// 3）
c = 200;
d = 200;
System.out.println(c == d); // false
</code></pre> 
<ul><li>第一段代码，基本类型和包装类型进行 == 比较，这时候 b 会自动拆箱，直接和 a 比较值，所以结果为 true</li><li>第二段代码，两个包装类型都被赋值为了100，这时候会自动装箱。在第四个标题的结论是：将 == 操作符应用于包装类型比较的时候，其结果很可能会和预期的不符。那结果是false？但这次的结果却是 true ，是不是摸不着头脑，有点晕晕的？</li><li>第三段代码，两个包装类型重新被赋值为了200，这时候仍然会进行自动装箱，结果是 true，这里跟第二段代码不同之处就是值不一样，结果就不一样，我们来看看源码： 
  <ul><li>前面已经了解，自动装箱是通过  Integer.valueOf() 完成的，那我们就来看一下这个方法的源码：</li></ul></li></ul> 
<pre><code class="language-java">    public static Integer valueOf(int i) {
        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }</code></pre> 
<p>难不成是 IntegerCache 的影响？继续看源码：</p> 
<pre><code class="language-java">    private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k &lt; cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high &gt;= 127;
        }

        private IntegerCache() {}
    }</code></pre> 
<p> 大致看一下这段源码，-128 到 127 之间的数是从 IntegerCache 中获取，然后比较，所以第二段代码（100 在这个范围之内）的结果为 true，而第三段代码（200不在这个范围之内，所以 new 出来两个 Integer 对象）的结果是false。</p> 
<ul><li>总结一下：<strong>当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不用重新创建一个对象。</strong></li></ul> 
<h2><strong>六、下面看一个性能差异的代码</strong></h2> 
<p>自动装拆箱是一个很好的功能，大大节省了我们开发人员的精力，但也会引发一些麻烦，比如下面这段代码，性能就很差。</p> 
<pre><code class="language-java">    @Test
    public void a33() {
        long t1 = System.currentTimeMillis();
        Long sum = 0L;
        for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
            sum += i;
        }
        long t2 = System.currentTimeMillis();
        System.out.println(t2-t1);  // 6189   678
    }</code></pre> 
<ul><li>sum 由于被声明成了包装类型 Long 而不是基本类型 long，所以 sum += i 进行了大量的拆装箱操作（sum 先拆箱和 i 相加，然后再装箱赋值给 sum），导致这段代码运行完花费的时间足足有 6189 毫秒。如果把 sum 换成基本类型 long，时间就仅有 678 毫秒，完全不一个等量级啊。.</li></ul> 
<h2>七、总结</h2> 
<h3>1、为什么有基本类型还要有包装类型？</h3> 
<p>首先，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型 Collection 时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p> 
<p>另外，集合类（ArrayList，HashMap等）里面保存的必须是 Object 类型的对象，无法保存基本类型。</p> 
<h3>2、那只有包装类型不就可以了？</h3> 
<p>我们知道 Java 中，new 一个对象会存储在堆里，我们通过栈中的引用来使用这些对象。由于基本数据类型很常用，如果我们用 new 将其存储在堆里效率明显降低。</p> 
<h3>3、基本类型和包装类型的异同</h3> 
<ul><li>在 Java 中，一切皆对象，但八大基本类型却不是对象。</li><li>声明方式的不同，基本类型无需通过 new 关键字来创建，而封装类型需 new 关键字。</li><li>存储方式及位置的不同，基本类型是直接把存储变量的值保存在栈中能高效的存取，封装类型需要通过引用指向实例，具体的实例保存在堆中。</li><li>初始值的不同，封装类型的初始值为 null，基本类型的初始值视具体的类型而定，比如 int 类型的初始值为 0，boolean 类型为 false。</li><li>使用方式的不同，比如与集合类合作使用时只能使用包装类型。</li><li>什么时候该用包装类，什么时候用基本类型，看基本的业务来定。这个字段允不允许 null 值，如果允许 null 值，则必需用封装类，否则值类型就可以了。用到比如泛型和反射调用函数，就需要用包装类。</li></ul> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e17268151636255ae3bb526474c3e8f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">接口自动化测试---单接口自动化测试与业务场景自动化测试之间的区别？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43d935dee638fbfdffa22345175da44b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu20.04安装nvidia驱动，解决nvidia-smi报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>