<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL大数据量分页limit优化 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL大数据量分页limit优化" />
<meta property="og:description" content="一、limit用法 SELECT * FROM t LIMIT 10,10;
第一个参数指定第一个返回记录行的偏移量第二个参数指定返回记录行的最大数目如果只给定一个参数：它表示返回最大的记录行数目第二个参数为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行初始记录行的偏移量是 0(而不是 1) 所以上面SQL的含义是查询数据库第10条到第20条数据
对于小的偏移量，直接使用limit来查询没有什么问题，但随着数据量的增大，越往后分页，limit语句的偏移量就会越大，速度也会明显变慢
二、limit在大数据量下的表现 参考网上一个案例：
表说明：
表名：order，订单表字段情况：该表一共37个字段，不包含text等大型数据，最大为varchar(500)，id字段为索引，且为递增数据量：5709294 select * from order_table where userId = 3 order by id limit 10000,10;
三次查询时间分别为：
3040 ms3063 ms3018 ms 针对这种查询方式，下面测试查询记录量对时间的影响：
select * from order_table where userId = 3 order by id limit 10000,1;
select * from order_table where userId = 3 order by id limit 10000,10;
select * from order_table where userId = 3 order by id limit 10000,100;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/39247d32f61f2adaa0d9a2d1a585dbbf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-15T00:08:53+08:00" />
<meta property="article:modified_time" content="2019-11-15T00:08:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL大数据量分页limit优化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="limit_0"></a>一、limit用法</h4> 
<blockquote> 
 <p>SELECT * FROM t LIMIT 10,10;</p> 
</blockquote> 
<ul><li>第一个参数指定第一个返回记录行的偏移量</li><li>第二个参数指定返回记录行的最大数目</li><li>如果只给定一个参数：它表示返回最大的记录行数目</li><li>第二个参数为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行</li><li>初始记录行的偏移量是 0(而不是 1)</li></ul> 
<p>所以上面SQL的含义是查询数据库第10条到第20条数据</p> 
<p>对于小的偏移量，直接使用limit来查询没有什么问题，但随着数据量的增大，越往后分页，limit语句的偏移量就会越大，速度也会明显变慢</p> 
<h4><a id="limit_13"></a>二、limit在大数据量下的表现</h4> 
<p><strong>参考网上一个案例：</strong><br> 表说明：</p> 
<ul><li>表名：order，订单表</li><li>字段情况：该表一共37个字段，不包含text等大型数据，最大为varchar(500)，id字段为索引，且为递增</li><li>数据量：5709294</li></ul> 
<blockquote> 
 <p>select * from order_table where userId = 3 order by id limit 10000,10;</p> 
</blockquote> 
<p><strong>三次查询时间分别为：</strong></p> 
<ul><li>3040 ms</li><li>3063 ms</li><li>3018 ms</li></ul> 
<p>针对这种查询方式，下面测试查询记录量对时间的影响：</p> 
<blockquote> 
 <p>select * from order_table where userId = 3 order by id limit 10000,1;<br> select * from order_table where userId = 3 order by id limit 10000,10;<br> select * from order_table where userId = 3 order by id limit 10000,100;<br> select * from order_table where userId = 3 order by id limit 10000,1000;<br> select * from order_table where userId = 3 order by id limit 10000,10000;</p> 
</blockquote> 
<p><strong>三次查询时间如下：</strong></p> 
<ul><li> <p>查询1条记录：3072ms 3092ms 3002ms</p> </li><li> <p>查询10条记录：3081ms 3077ms 3032ms</p> </li><li> <p>查询100条记录：3118ms 3200ms 3128ms</p> </li><li> <p>查询1000条记录：3412ms 3468ms 3394ms</p> </li><li> <p>查询10000条记录：3749ms 3802ms 3696ms</p> </li></ul> 
<p>在查询记录量低于100时，查询时间基本没有差距，随着查询记录量越来越大，所花费的时间也会越来越多</p> 
<p><strong>针对偏移量的测试：</strong></p> 
<blockquote> 
 <p>select * from order_table where userId = 3 order by id limit 100,100;<br> select * from order_table where userId = 3 order by id limit 1000,100;<br> select * from order_table where userId = 3 order by id limit 10000,100;<br> select * from order_table where userId = 3 order by id limit 100000,100;<br> select * from order_table where userId = 3 order by id limit 100000,100;</p> 
</blockquote> 
<p><strong>三次查询时间如下：</strong></p> 
<ul><li> <p>查询100偏移：25ms 24ms 24ms</p> </li><li> <p>查询1000偏移：78ms 76ms 77ms</p> </li><li> <p>查询10000偏移：3092ms 3212ms 3128ms</p> </li><li> <p>查询100000偏移：3878ms 3812ms 3798ms</p> </li><li> <p>查询1000000偏移：14608ms 14062ms 14700ms</p> </li></ul> 
<p>随着查询偏移的增大，尤其查询偏移大于10万以后，查询时间急剧增加</p> 
<h4><a id="limit_68"></a>三、limit优化</h4> 
<p><strong>1. 使用覆盖索引</strong></p> 
<blockquote> 
 <p>select orderType, orderAmt from order_table limit 10000, 10;</p> 
</blockquote> 
<p>假设我们只需要查询上面两个字段，可以建立联合索引（orderType, orderAmt ），这样可以让查询走联合索引，加快性能。但是我们这个表有37个字段，这么优化明显不合适，而且这种方式加快性能方式并不明显。</p> 
<p><strong>2. 假设数据表的id是连续递增的，可以这样写</strong></p> 
<blockquote> 
 <p>select * from order_table where id &gt;= 1000000 limit 100;<br> select * from order_table where id between 10000000 and 1000100 limit 100</p> 
</blockquote> 
<p>直接将对应的offset计算出来，作为where条件，这样可以利用主键索引，性能提升非常明显。</p> 
<p>上面这种方案存在严重问题，数据库使用自增id，这没问题，但是，可能存在部分数据被删除过，也就是id并不连续，所以查出的数据并不是我们想要的。</p> 
<p>优化方法：<br> <strong>3. 每次分页查询记录上一次分页最后一条id</strong><br> 下次查询：</p> 
<blockquote> 
 <p>select * from order_table where id &gt;= 上页最大id limit 100;</p> 
</blockquote> 
<p>这样处理的话，id就算不是连续也是没有问题的，但是必须自增，由于数据库主键我们一般设置成连续自增，所以这种方式可以大幅度优化性能</p> 
<p><strong>4. 使用子查询</strong><br> 上述方法每次都需要记录上一次分页的最大id，比较麻烦，我们可以使用子查询代替：</p> 
<blockquote> 
 <p>select * from order_table where id in (select id from order_table limit 1000000, 100);</p> 
</blockquote> 
<blockquote> 
 <p>select * from order_table where id &gt;= (select id from order_table limit 1000000, 1) limit 100;</p> 
</blockquote> 
<blockquote> 
 <p>select * from order_table t1 join (select id from order_table limit 1000000, 1) t2 on t1.id &gt;= t2.id limit 100</p> 
</blockquote> 
<p>这种方式之所以能够大幅度优化性能，分析：</p> 
<ul><li> <p>直接分页，不会走索引，全表扫描，其实是遍历主键索引树，但是每次都需要把对应行的数据取出来，要取1000100条数据，然后丢弃前一百万条，太消耗性能。可以通过explain执行计划查看对应索引情况</p> </li><li> <p>使用子查询，会走主键索引，虽然也是遍历主键索引树，但是只需要取id，不需要取出整行数据，最后外层查询拿到对应的100条id，查询对应数据即可。通过根据索引字段定位后，大大减少了查询的数据量，效率自然大大提升</p> </li><li> <p>上述使用in，where条件和连接，性能差距不大</p> </li></ul> 
<p><strong>5. 业务优化</strong><br> 真的会有人翻到第100万条数据吗，一般来说翻页不会查过20页，可以通过限制可以翻页的数量解决这个问题。像百度分页最多只能展示76页。还有一种方式，就是使用滚动，和微博一样，没有分页，只能不断下拉，就是使用之前记录上一页最大offset那个方法就可以做到。ES里面可以使用scroll API</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8976eee6ab18455b6dfb8b7f7ae1c36/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">组合数学</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27239a920380bac5c6a58b9a048cf72b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Github上10个增长最快的开源项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>