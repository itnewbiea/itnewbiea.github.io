<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java SE 基础 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java SE 基础" />
<meta property="og:description" content="目录
一、什么是方法？
1.方法的格式
最简单的方法的定义和调用
带参数的方法的定义和调用
带返回值的方法的定义和调用
2.方法的重载
3.关于方法的两个练习
4.方法的内存
方法调用的基本内存原理
方法传递基本数据类型的内存原理
方法传递引用数据类型的内存原理
5.ststic 关键字
二、面向对象基础
1.类与对象
如何定义类
如何得到类的对象
如何使用对象
定义类的补充注意事项
2.构造方法
构造方法的格式
构造方法的注意事项
3.标准的JavaBean类
4.对象内存图
一个对象的内存图
两个对象的内存图
5.封装
private关键字
get和set方法
6.继承（extends）
继承的构造顺序
7.重写
8.super关键字
9.就近原则和this关键字
就近原则
this关键字的作用
this关键字的本质
10.final 关键字（最终）
11.访问权限
12.克隆
13.抽象类（abstract）
14.接口
三、字符串
字符串常用的一些方法
字符串的比较
StringBuffer 和 StringBuilder 区别
正则表达式
练习1--模拟用户登录
练习2--遍历字符串和统计字符次数
四、常用类
1.常用的数学类
2.包装类
一、什么是方法？ 方法是程序中最小的执行单元
优点：1.提高代码的复用性 2.提高代码的可维护性
1.方法的格式 最简单的方法的定义和调用 定义格式：
public static void 方法名（）{
方法体(就是打包起来的代码)；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/445416bfff0b281e685504b9dd7078f2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-05T15:35:06+08:00" />
<meta property="article:modified_time" content="2023-07-05T15:35:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java SE 基础</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%EF%BC%9F" rel="nofollow">一、什么是方法？</a></p> 
<p id="1.%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F" rel="nofollow">1.方法的格式</a></p> 
<p id="%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8-toc" style="margin-left:120px;"><a href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8" rel="nofollow">最简单的方法的定义和调用</a></p> 
<p id="%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8-toc" style="margin-left:120px;"><a href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8" rel="nofollow">带参数的方法的定义和调用</a></p> 
<p id="%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8-toc" style="margin-left:120px;"><a href="#%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8" rel="nofollow">带返回值的方法的定义和调用</a></p> 
<p id="2.%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#2.%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD" rel="nofollow">2.方法的重载</a></p> 
<p id="3.%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#3.%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%83%E4%B9%A0" rel="nofollow">3.关于方法的两个练习</a></p> 
<p id="4.%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98-toc" style="margin-left:80px;"><a href="#4.%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98" rel="nofollow">4.方法的内存</a></p> 
<p id="%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86-toc" style="margin-left:120px;"><a href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86" rel="nofollow">方法调用的基本内存原理</a></p> 
<p id="%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86-toc" style="margin-left:120px;"><a href="#%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86" rel="nofollow">方法传递基本数据类型的内存原理</a></p> 
<p id="%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86-toc" style="margin-left:120px;"><a href="#%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86" rel="nofollow">方法传递引用数据类型的内存原理</a></p> 
<p id="5.ststic%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#5.ststic%20%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">5.ststic 关键字</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80" rel="nofollow">二、面向对象基础</a></p> 
<p id="1.%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#1.%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1" rel="nofollow">1.类与对象</a></p> 
<p id="%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%B1%BB-toc" style="margin-left:120px;"><a href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%B1%BB" rel="nofollow">如何定义类</a></p> 
<p id="%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1-toc" style="margin-left:120px;"><a href="#%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1" rel="nofollow">如何得到类的对象</a></p> 
<p id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1-toc" style="margin-left:120px;"><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1" rel="nofollow">如何使用对象</a></p> 
<p id="%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E8%A1%A5%E5%85%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:120px;"><a href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E8%A1%A5%E5%85%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">定义类的补充注意事项</a></p> 
<p id="2.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">2.构造方法</a></p> 
<p id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F-toc" style="margin-left:120px;"><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F" rel="nofollow">构造方法的格式</a></p> 
<p id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:120px;"><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">构造方法的注意事项</a></p> 
<p id="3.%E6%A0%87%E5%87%86%E7%9A%84JavaBean%E7%B1%BB-toc" style="margin-left:80px;"><a href="#3.%E6%A0%87%E5%87%86%E7%9A%84JavaBean%E7%B1%BB" rel="nofollow">3.标准的JavaBean类</a></p> 
<p id="4.%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE-toc" style="margin-left:80px;"><a href="#4.%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE" rel="nofollow">4.对象内存图</a></p> 
<p id="%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE-toc" style="margin-left:120px;"><a href="#%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE" rel="nofollow">一个对象的内存图</a></p> 
<p id="%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE-toc" style="margin-left:120px;"><a href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE" rel="nofollow">两个对象的内存图</a></p> 
<p id="5.%E5%B0%81%E8%A3%85-toc" style="margin-left:80px;"><a href="#5.%E5%B0%81%E8%A3%85" rel="nofollow">5.封装</a></p> 
<p id="private%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:120px;"><a href="#private%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">private关键字</a></p> 
<p id="get%E5%92%8Cset%E6%96%B9%E6%B3%95-toc" style="margin-left:120px;"><a href="#get%E5%92%8Cset%E6%96%B9%E6%B3%95" rel="nofollow">get和set方法</a></p> 
<p id="6.%E7%BB%A7%E6%89%BF%EF%BC%88extends%EF%BC%89-toc" style="margin-left:80px;"><a href="#6.%E7%BB%A7%E6%89%BF%EF%BC%88extends%EF%BC%89" rel="nofollow">6.继承（extends）</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F-toc" style="margin-left:120px;"><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F" rel="nofollow">继承的构造顺序</a></p> 
<p id="7.%E9%87%8D%E5%86%99-toc" style="margin-left:80px;"><a href="#7.%E9%87%8D%E5%86%99" rel="nofollow">7.重写</a></p> 
<p id="8.super%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#8.super%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">8.super关键字</a></p> 
<p id="9.%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#9.%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">9.就近原则和this关键字</a></p> 
<p id="%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99-toc" style="margin-left:120px;"><a href="#%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99" rel="nofollow">就近原则</a></p> 
<p id="this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:120px;"><a href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">this关键字的作用</a></p> 
<p id="this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:120px;"><a href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow">this关键字的本质</a></p> 
<p id="10.final%20%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%9C%80%E7%BB%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#10.final%20%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%9C%80%E7%BB%88%EF%BC%89" rel="nofollow">10.final 关键字（最终）</a></p> 
<p id="11.%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-toc" style="margin-left:80px;"><a href="#11.%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90" rel="nofollow">11.访问权限</a></p> 
<p id="12.%E5%85%8B%E9%9A%86-toc" style="margin-left:80px;"><a href="#12.%E5%85%8B%E9%9A%86" rel="nofollow">12.克隆</a></p> 
<p id="13.%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%EF%BC%89-toc" style="margin-left:80px;"><a href="#13.%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%EF%BC%89" rel="nofollow">13.抽象类（abstract）</a></p> 
<p id="14.%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#14.%E6%8E%A5%E5%8F%A3" rel="nofollow">14.接口</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">三、字符串</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95-toc" style="margin-left:120px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95" rel="nofollow">字符串常用的一些方法</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:120px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">字符串的比较</a></p> 
<p id="StringBuffer%20%E5%92%8C%20StringBuilder%20%E5%8C%BA%E5%88%AB-toc" style="margin-left:120px;"><a href="#StringBuffer%20%E5%92%8C%20StringBuilder%20%E5%8C%BA%E5%88%AB" rel="nofollow">StringBuffer 和 StringBuilder 区别</a></p> 
<p id="%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:120px;"><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">正则表达式</a></p> 
<p id="%E7%BB%83%E4%B9%A01--%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95-toc" style="margin-left:120px;"><a href="#%E7%BB%83%E4%B9%A01--%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95" rel="nofollow">练习1--模拟用户登录</a></p> 
<p id="%E7%BB%83%E4%B9%A02--%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E6%AC%A1%E6%95%B0-toc" style="margin-left:120px;"><a href="#%E7%BB%83%E4%B9%A02--%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E6%AC%A1%E6%95%B0" rel="nofollow">练习2--遍历字符串和统计字符次数</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB" rel="nofollow">四、常用类</a></p> 
<p id="1.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E7%B1%BB" rel="nofollow">1.常用的数学类</a></p> 
<p id="2.%E5%8C%85%E8%A3%85%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.%E5%8C%85%E8%A3%85%E7%B1%BB" rel="nofollow">2.包装类</a></p> 
<h3 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%EF%BC%9F">一、什么是方法？</h3> 
<blockquote> 
 <p>方法是程序中最小的执行单元</p> 
 <p>优点：1.提高代码的复用性 2.提高代码的可维护性</p> 
</blockquote> 
<h4 id="1.%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F">1.方法的格式</h4> 
<h5 id="%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">最简单的方法的定义和调用</h5> 
<blockquote> 
 <p>定义格式：</p> 
 <p>public static void 方法名（）{<!-- --></p> 
 <p>方法体(就是打包起来的代码)；</p> 
 <p>}</p> 
 <p>调用格式：</p> 
 <p>方法名()；</p> 
</blockquote> 
<h5 id="%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">带参数的方法的定义和调用</h5> 
<blockquote> 
 <p>定义格式：</p> 
 <p>public static void 方法名（参数1，参数2，…）{ //括号内参数称为行参</p> 
 <p>方法体(就是打包起来的代码)；</p> 
 <p>}</p> 
 <p>调用格式：</p> 
 <p>方法名(参数1，参数2，…)； //括号内参数称为实参</p> 
 <p>注意：形参和实参需要一一对应</p> 
</blockquote> 
<h5 id="%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">带返回值的方法的定义和调用</h5> 
<blockquote> 
 <p>使用场景：在调用处需要根据方法的结果，去编写另一段代码</p> 
</blockquote> 
<blockquote> 
 <p>定义格式：</p> 
 <p>public static 返回值类型 方法名（参数1，参数2，…）{<!-- --></p> 
 <p>方法体(就是打包起来的代码)；</p> 
 <p>return 返回值；</p> 
 <p>}</p> 
 <p>调用格式：</p> 
 <p>直接调用：方法名(参数1，参数2，…)； //一般用在无返回值的调用</p> 
 <p>赋值调用：数据类型 变量名 = 方法名(参数1，参数2，…)；</p> 
 <p>输出调用：system.out.println（方法名(参数1，参数2，…)）；</p> 
</blockquote> 
<h4 id="2.%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD">2.方法的重载</h4> 
<blockquote> 
 <p>定义：在同一个类中，方法名相同，参数不同（个数不同、类型不同、顺序不同）的方法，就是重载。与返回值无关。</p> 
</blockquote> 
<pre><code class="language-java">//方法的重载
 public class MethodDome1 {
     /*需求：使用方法重载的思想，设计比较两个数是否相同的方法
          要求：兼容全整数类型(byte,short,int,long)*/
     public static void main(String[] args) {
         //调用
         compare(10,20);
         
         //compare((byte)20,(byte)30);
     }
 ​
     public static void compare(byte b1,byte b2){
         System.out.println("===byte===");
         System.out.println(b1==b2);
     }
     public static void compare(short s1,short s2){
         System.out.println("===short===");
         System.out.println(s1==s2);
     }
     public static void compare(int i1,int i2){
         System.out.println("===int===");
         System.out.println(i1==i2);
     }
     public static void compare(long l1,long l2){
         System.out.println("===long===");
         System.out.println(l1==l2);
     }
 }</code></pre> 
<h4 id="3.%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%83%E4%B9%A0">3.关于方法的两个练习</h4> 
<pre><code class="language-java"> public class Exercise1 {
     public static void main(String[] args) {
         int[] arr1={11,22,33,44,55};
         //printArr(arr1);
 ​
 ​
         int[] arr2={1,45,7,10,3,6,8};
         //调用方法求最大值
         int max=getMax(arr2);
         System.out.println(max);
     }
 ​
     public static void printArr(int[] arr1){
         //需求：设计一个方法用于数组遍历，要求遍历的数组在一行上，例如：[11,22,33,44,55]
         System.out.print("[");
         for (int i = 0; i &lt; arr1.length; i++) {
             if(i== arr1.length-1){
                 System.out.print(arr1[i]);
             }else {
                 System.out.print(arr1[i]+",");
             }
         }
         System.out.println("]");
     }
 ​
     public static int getMax(int[] arr2){
         //设计一个方法求数组的最大值，并将最大值返回
         int max=arr2[0];
         for (int i = 0; i &lt; arr2.length; i++) {
             if (arr2[i]&gt;max){
                 max=arr2[i];
             }
         }
         return max;
     }
 }</code></pre> 
<blockquote> 
 <p>补充：return和break关键字的区别</p> 
 <p>return：和循环无关，和方法有关，表示1结束方法 2返回结果</p> 
 <p>如果方法执行到return，那么整个方法全部结束，里面的循环也随之结束</p> 
 <p>break：和方法无关，主要作用是结束循环或switch的</p> 
</blockquote> 
<h4 id="4.%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98">4.方法的内存</h4> 
<h5 id="%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86">方法调用的基本内存原理</h5> 
<blockquote> 
 <p>传递基本数据类型时，传递的是真实的数据，形参的改变，不影响实际参数的值</p> 
 <p>传递引用数据类型时，传递的是地址值，形参的改变，影响实际参数的值</p> 
</blockquote> 
<h5 id="%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86">方法传递基本数据类型的内存原理</h5> 
<blockquote> 
 <p>基本数据类型：数据值是存储在自己的空间中</p> 
</blockquote> 
<h5 id="%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86">方法传递引用数据类型的内存原理</h5> 
<blockquote> 
 <p>引用数据类型：使用了其他空间中（堆）的数据，变量中存储的是地址值</p> 
</blockquote> 
<h4 id="5.ststic%20%E5%85%B3%E9%94%AE%E5%AD%97">5.ststic 关键字</h4> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80">二、面向对象基础</h3> 
<h4 id="1.%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1">1.类与对象</h4> 
<blockquote> 
 <p>类（设计图）：是对象共同特征的描述 对象：是真实存在的具体东西</p> 
 <p>在java中，必须先设计类，才能获得对象</p> 
</blockquote> 
<h5 id="%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%B1%BB">如何定义类</h5> 
<blockquote> 
 <p>public class 类名{<!-- --></p> 
 <p>1.成员变量（代表属性，一般是名词）</p> 
 <p>2.成员方法（代表行为，一般是动词）</p> 
 <p>3.构造器</p> 
 <p>4.代码块</p> 
 <p>5.内部类</p> 
 <p>}</p> 
</blockquote> 
<h5 id="%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1">如何得到类的对象</h5> 
<blockquote> 
 <p>类名 对象名 = new 类名()；</p> 
</blockquote> 
<h5 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1">如何使用对象</h5> 
<blockquote> 
 <p>访问属性：对象名.成员变量;</p> 
 <p>访问行为：对象名.方法名(...);</p> 
</blockquote> 
<h5 id="%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E8%A1%A5%E5%85%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">定义类的补充注意事项</h5> 
<blockquote> 
 <ul><li> <p>用来描述一类事物的类，专业叫做：Javabean类</p> </li></ul> 
 <p>在Javabean类中，是不写main方法的</p> 
 <ul><li> <p>编写main方法的类，叫做测试类</p> </li></ul> 
 <p>我们可以在测试类中创建Javabean类的对象并进行赋值调用</p> 
 <ul><li> <p>成员变量的完整定义格式是：</p> </li></ul> 
 <p>修饰符 数据类型 变量名称 = 初始化值；（一般无需指定初始化值，存在默认值）</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cb/98/EtICmIoh_o.png"></p> 
 <p></p> 
</blockquote> 
<h4 id="2.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">2.构造方法</h4> 
<blockquote> 
 <p>构造方法也叫构造器或构造函数。</p> 
 <p>作用：在创建对象的时候给成员变量进行初始化（赋值）的</p> 
</blockquote> 
<h5 id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F">构造方法的格式</h5> 
<blockquote> 
 <p>public class Student{<!-- --></p> 
 <p>修饰符 类名(参数) {<!-- --></p> 
 <p>方法体；</p> 
 <p>}</p> 
 <p>}</p> 
 <p>特点：</p> 
 <ul><li> <p>方法名与类名相同，大小写也要一致</p> </li><li> <p>没有返回值类型，连void都没有</p> </li><li> <p>没有具体的返回值（不能有return带回结果数据）</p> </li></ul> 
</blockquote> 
<h5 id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">构造方法的注意事项</h5> 
<blockquote> 
 <p>构造方法的定义：</p> 
 <ul><li> <p>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</p> </li><li> <p>如果定义了构造方法，系统将不在提供默认的构造方法</p> </li></ul> 
 <p>构造方法的重载：</p> 
 <ul><li> <p>带参构造方法和无参构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载</p> </li></ul> 
 <p>推荐使用方式：</p> 
 <ul><li> <p>无论是否使用，都要手动书写无参数构造方法和带全部参数的构造方法</p> </li></ul> 
</blockquote> 
<h4 id="3.%E6%A0%87%E5%87%86%E7%9A%84JavaBean%E7%B1%BB">3.标准的JavaBean类</h4> 
<blockquote> 
 <ul><li> <p>类名需要见名知意</p> </li><li> <p>成员变量使用private修饰</p> </li><li> <p>提供至少两种构造方法</p> 
   <ul><li> <p>无参构造方法</p> </li><li> <p>带全部参数的构造方法</p> </li></ul></li><li> <p>成员方法</p> 
   <ul><li> <p>提供每一个成员变量对应的setXxx()和getXxx()</p> </li><li> <p>如果还有其他行为，也需要写上</p> </li></ul></li></ul> 
</blockquote> 
<h4 id="4.%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE">4.对象内存图</h4> 
<h5 id="%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE">一个对象的内存图</h5> 
<blockquote> 
 <p>Student s = new Student ( );</p> 
 <ul><li> <p>加载class文件</p> </li><li> <p>声明局部变量</p> </li><li> <p>在堆内存中开辟一个新空间</p> </li><li> <p>默认初始化</p> </li><li> <p>显示初始化</p> </li><li> <p>构造方法初始化</p> </li><li> <p>将堆内存中的地址值赋值给左边的局部变量</p> </li></ul> 
</blockquote> 
<h5 id="%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE">两个对象的内存图</h5> 
<blockquote> 
 <p>注意：第二次在创建一个新对象的时候，不需要在方法区中加载一次字节码文件</p> 
</blockquote> 
<h4 id="5.%E5%B0%81%E8%A3%85">5.封装</h4> 
<blockquote> 
 <p>对象代表什么，就得封装对应的数据，并提供数据对应的行为</p> 
 <p>需要什么对象的时候，可查API帮助文档</p> 
</blockquote> 
<h5 id="private%E5%85%B3%E9%94%AE%E5%AD%97">private关键字</h5> 
<blockquote> 
 <ul><li> <p>是一个权限修饰符</p> </li><li> <p>可以修饰成员（成员变量和成员方法）</p> </li><li> <p>被private修饰的成员只能在本类中才能访问</p> </li></ul> 
</blockquote> 
<h5 id="get%E5%92%8Cset%E6%96%B9%E6%B3%95">get和set方法</h5> 
<p>快捷键：alt+insert</p> 
<blockquote> 
 <ul><li> <p>set方法：给成员变量赋值</p> </li><li> <p>get方法：对外提供成员变量的值</p> </li></ul> 
</blockquote> 
<h4 id="6.%E7%BB%A7%E6%89%BF%EF%BC%88extends%EF%BC%89">6.继承（extends）</h4> 
<blockquote> 
 <p>作用：提高代码的复用性，简化代码</p> 
</blockquote> 
<h5 id="%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F">继承的构造顺序</h5> 
<blockquote> 
 <p>在实例化子类时，先执行父类构造方法，再执行子类构造方法；调用时，默认先调用父类无参构造方法</p> 
 <p><strong>注意</strong>：父类构造方法定义问题，一般需要留上一个无参构造方法。</p> 
 <p>如果父类中只有有参构造，没有无参构造时，子类在构造方法中先去调用父类的构造方法</p> 
 <p><strong>补充</strong>：父类和子类的执行顺序：</p> 
 <p>父类static --- 子类static --- 父类属性和父类代码段 --- 父类构造方法 --- 子类属性和子类代码段 --- 子类构造方法</p> 
</blockquote> 
<h4 id="7.%E9%87%8D%E5%86%99">7.重写</h4> 
<blockquote> 
 <p>多态：</p> 
 <ul><li> <p>静态多态 ---- 重载 ---- 一个类中同名不同参</p> </li><li> <p>动态多态 ---- 重写 ---- 父子类中同名同参</p> </li><li> <p>多态的三个必备条件：1.继承 2.重写 3.父类指向子类对象的引用</p> </li></ul> 
 <p>软件设计原则：</p> 
 <ul><li> <p>OPC：开闭原则 ---- 对修改关闭对扩展开放</p> </li></ul> 
 <p>软件开发生命周期：</p> 
 <ul><li> <p>可行性分析 --- 需求分析 --- 概要设计 --- 详细设计 --- 开发 --- 测试 --- 维护</p> </li></ul> 
</blockquote> 
<blockquote> 
 <ul><li> <p><strong>重写定义</strong>：子类中方法和父类中方法出现同名同参，称之为重写</p> </li><li> <p>@Override注解：用来检查是否符合重写规则</p> </li><li> <p>两大一小原则：</p> 
   <ul><li> <p>一大：子类重写方法访问权限大于或等于父类方法</p> </li><li> <p>一小：子类重写方法返回值类型小于或等于父类方法（可以自动向上转型），不包括基本类型</p> </li><li> <p>一小：子类方法抛出异常类型小于或等于父类方法抛出异常类型</p> </li></ul></li><li> <p>instance of ：运算符，判断实例是否属于指定类型；在判断时，把大类放在后面</p> </li></ul> 
</blockquote> 
<h4 id="8.super%E5%85%B3%E9%94%AE%E5%AD%97">8.super关键字</h4> 
<blockquote> 
 <p>用法:</p> 
 <ul><li> <p>调用父类构造方法：super.([参数列表]); ------------只能用在构造方法第一句</p> </li><li> <p>调用父类普通成员(属性、方法、内部类)：super.propName；super.methodName(); ------------可以用在构造方法也可用在普通方法，位置顺序没有限制</p> </li></ul> 
</blockquote> 
<h4 id="9.%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97">9.就近原则和this关键字</h4> 
<h5 id="%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99">就近原则</h5> 
<blockquote> 
 <ul><li> <p>System.out.println(age) 先到局部变量位置找值，如果没有，再到成员变量位置找值</p> </li><li> <p>System.out.println(this.age) 直接到成员变量位置找值</p> </li></ul> 
</blockquote> 
<h5 id="this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8">this关键字的作用</h5> 
<blockquote> 
 <p>可以区别成员变量和局部变量</p> 
</blockquote> 
<h5 id="this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%9C%AC%E8%B4%A8">this关键字的本质</h5> 
<blockquote> 
 <p>所在方法调用者的地址值</p> 
</blockquote> 
<h4 id="10.final%20%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%9C%80%E7%BB%88%EF%BC%89">10.final 关键字（最终）</h4> 
<blockquote> 
 <ul><li> <p>修饰类：类不能被继承</p> </li><li> <p>修饰方法：方法不能被重写</p> </li><li> <p>修饰变量：变量变成常量，不能多次被修改赋值（常量命名全部大写，多个单词组合时，用下划线分开）。修饰的属性，在声明时，必须要初始化</p> </li></ul> 
</blockquote> 
<p><strong>扩展：</strong></p> 
<blockquote> 
 <ul><li> <p>finalize() 是属于 Object 类中的方法</p> </li><li> <p>作用：在垃圾回收器回收对象时，回去调用执行的方法。</p> </li></ul> 
</blockquote> 
<h4 id="11.%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">11.访问权限</h4> 
<table><thead><tr><th>访问修饰符</th><th>内部类</th><th>同包下的类</th><th>不同包下的类</th><th>其他包的类</th></tr></thead><tbody><tr><td>private</td><td>可以访问</td><td>不可以</td><td>不可以</td><td>不可以</td></tr><tr><td>默认的(同包)</td><td>可以</td><td>可以</td><td>不可以</td><td>不可以</td></tr><tr><td>protected</td><td>可以</td><td>可以</td><td>可以</td><td>不可以</td></tr><tr><td>public</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td></tr></tbody></table> 
<h4 id="12.%E5%85%8B%E9%9A%86">12.克隆</h4> 
<blockquote> 
 <p>克隆方法：</p> 
 <ul><li> <p>重写 Object clone() 方法 ------ 可以把访问修饰权限改成 public</p> 
   <ul><li> <pre><code class="language-java"> @Override
 public Object clone() throws CloneNotSupportedException {
     return super.clone();</code></pre> </li></ul></li><li> <p>实现可克隆的接口 ------- implements Cloneable</p> </li></ul> 
 <p>浅克隆和深克隆：</p> 
 <ul><li> <p>浅克隆：只克隆基本类型或 String 属性，对于依赖的引用类型对象，只克隆了地址。</p> </li><li> <p>深克隆：依赖的引用类型对象，也会进行克隆</p> </li></ul> 
</blockquote> 
<h4 id="13.%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%EF%BC%89">13.抽象类（abstract）</h4> 
<blockquote> 
 <ul><li> <p>abstract关键字修饰的类，称之为抽象类；</p> </li><li> <p>abstract修饰的方法，称之为抽象方法，抽象方法不能有方法体；</p> </li><li> <p>拥有抽象方法的类，必须定义为抽象类，但抽象类中不一定有抽象方法；</p> </li><li> <p>抽象类不能被实例化；</p> </li><li> <p>子类继承抽象类时，要么实现抽象类中所有的抽象方法，要么把子类声明为抽象类；</p> </li><li> <p>抽象类和普通类的区别：</p> 
   <ul><li> <p>抽象类中可以有抽象方法，普通类不可以</p> </li><li> <p>抽象类不能被实例化</p> </li></ul></li></ul> 
</blockquote> 
<h4 id="14.%E6%8E%A5%E5%8F%A3">14.接口</h4> 
<blockquote> 
 <p>接口特点（多实现、多个功能）：</p> 
 <ul><li> <p>定义：interface</p> </li><li> <p>属性：默认是且只能是 public static final 的常量</p> </li><li> <p>方法：默认是且只能是 public abstract，可以省略</p> </li><li> <p>构造：接口没有且不能定义构造方法</p> </li><li> <p>内部类：默认是 public static 的内部类</p> </li><li> <p>代码段：接口中不能使用代码段</p> </li></ul> 
 <p>解耦</p> 
</blockquote> 
<pre><code class="language-java"> /*
 * 接口：规范、功能、标准
 * */
 public class TestInterface {
     public static void main(String[] args) {
         HuaWeiPhone phone=new HuaWeiPhone();
         IPlayer player=phone;   //手机是一个播放器
         phone.net();
         phone.play();
         phone.sendSMS();
         phone.takePhoto();
         phone.call();
     }
 }
 /*生产一个华为手机*/
 class HuaWeiPhone extends Phone implements ICamera,IPlayer,INet{
 ​
     @Override
     public void sendSMS() {
         System.out.println("=====发短信=====");
     }
 ​
     @Override
     public void takePhoto() {
         System.out.println("=====拍照片=====");
     }
 ​
     @Override
     public void play() {
         System.out.println("=====放音乐======");
     }
 ​
     @Override
     public void net() {
         System.out.println("======上网======");
     }
 }
 ​
 abstract class Phone{
     public abstract void sendSMS();
     public void call(){
         System.out.println("=====打电话=====");
     }
 }
 /*相机接口*/
 interface ICamera{
     void takePhoto();
 }
 /*播放器接口*/
 interface IPlayer{
     void play();
 }
 /*网络接口*/
 interface  INet{
     void net();
 }</code></pre> 
<p></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2">三、字符串</h3> 
<blockquote> 
 <p>创建String对象的两种方式</p> 
 <ul><li> <p>直接赋值</p> </li><li> <p>使用new关键字来获取字符串对象</p> </li></ul> 
</blockquote> 
<h5 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95">字符串常用的一些方法</h5> 
<pre><code class="language-java"> public class TestString {
     public static void main(String[] args) {
         String srt = "yay.123.zbx     ";
         System.out.println("length():"+srt.length());  //长度
         System.out.println(srt.contains("zb"));   //是否包含
         System.out.println(srt.concat("xyz"));    //拼接
         System.out.println(srt.replaceAll("3","5"));   //替换
         System.out.println(srt.indexOf("."));    //查找第一个字符 . 所在的位置
         System.out.println(srt.lastIndexOf("."));   //从后面查找最后一个字符 . 所在的位置
         System.out.println(srt.charAt(2));   //给定下标找字符
         System.out.println(srt.substring(4,7));   //截取子串，注意，不包含后面位置的字符
         System.out.println(srt.substring(srt.indexOf(".")+1,srt.lastIndexOf(".")));
         System.out.println(srt.toLowerCase());   //全部转换为小写字母
         System.out.println(srt.toUpperCase());   //全部转换为大写字母
         System.out.println(srt.endsWith(".java"));   //是否以指定字符串结尾
         System.out.println(srt.startsWith("ya"));   //是否以指定字符串开头
         System.out.println("==="+srt.trim()+"===");    //去空格
     }
 }</code></pre> 
<h5 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83">字符串的比较</h5> 
<pre><code class="language-java"> public class StringCompare {
     public static void main(String[] args) {
         //1.创建两个字符串对象
         String s1=new String("abc");  //记录的是堆中的地址
         String s2="abc";   //直接赋值，记录的是串池中的地址
 ​
         //2.==号比较
         //基本数据类型:比的是数据值
         //引用数据类型:比的是地址值
         System.out.println(s1==s2);
         System.out.println("======");
 ​
         //3.比较字符串中对象的内容是否相等，完全一样  boolean equals
         boolean result1 = s1.equals(s2);
         System.out.println(result1);
         System.out.println("======");
 ​
         //4.比较字符串中对象的内容是否相等，忽略大小写  boolean equalsIgnoreCase
         boolean result2 = s1.equalsIgnoreCase(s2);
         System.out.println(result2);
     }
 }</code></pre> 
<h5 id="StringBuffer%20%E5%92%8C%20StringBuilder%20%E5%8C%BA%E5%88%AB">StringBuffer 和 StringBuilder 区别</h5> 
<blockquote> 
 <ul><li> <p>StringBuffer 方法都是有 synchronized 关键字修饰的</p> </li><li> <p>StringBuffer 线程同步的，安全的，效率低，推荐多线程场景使用</p> </li><li> <p>StringBuilder 非线程同步的，不安全的，相对效率高，推荐多线程场景下使用</p> </li></ul> 
</blockquote> 
<h5 id="%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</h5> 
<blockquote> 
 <p>作用：</p> 
 <ul><li> <p>校验字符串是否满足一定的规则</p> </li><li> <p>在一段文本中查找想要的内容</p> </li></ul> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/10/k3Weowcn_o.png"></p> 
<h5 id="%E7%BB%83%E4%B9%A01--%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95">练习1--模拟用户登录</h5> 
<pre><code class="language-java"> /*已知正确的用户名和密码，请用程序模拟实现用户登录
  * 一共三次机会，登录之后，给出相应的提示*/
 public class Exercise1 {
     public static void main(String[] args) {
         //定义两个变量记录正确的用户名和密码
         String rightUsername = "zhangsan";
         String rightPassword = "123456";
 ​
         //键盘录入用户名和密码
         Scanner scanner = new Scanner(System.in);
         for (int i = 0; i &lt; 3; i++) {
             System.out.println("请输入用户名:");
             String username = scanner.next();
             System.out.println("请输入密码:");
             String password = scanner.next();
 ​
             //比较
             if (username.equals(rightUsername) &amp;&amp; password.equals(rightPassword)) {
                 System.out.println("用户登录成功！");
                 break;
             } else {
                 if (i == 2) {
                     //最后一次机会也登录错误，此时要提示账户被锁定
                     System.out.println("三次机会登录失败，账号" + username + "被锁定！");
                 } else {
                     System.out.println("用户登录失败，用户名或密码错误,您还有" + (2 - i) + "次机会！");
                 }
             }
         }
     }
 }</code></pre> 
<h5 id="%E7%BB%83%E4%B9%A02--%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E6%AC%A1%E6%95%B0">练习2--遍历字符串和统计字符次数</h5> 
<blockquote> 
 <p>public char charAt(int index) 根据索引返回字符</p> 
 <p>public int length( ) 返回此字符串的长度</p> 
 <p>数组的长度：数组名.length</p> 
 <p>字符串的长度：字符串对象.length( )</p> 
</blockquote> 
<pre><code class="language-java">public class Exercise2 {
     public static void main(String[] args) {
 //        Test1();
         Test2();
     }
 ​
     public static void Test1() {
         /*字符串遍历
          * 需求:键盘录入一个字符串，使用程序实现在控制台遍历该字符串
          */
         //键盘录入一个字符串
         Scanner scanner = new Scanner(System.in);
         System.out.println("请输入一个字符串:");
         String str = scanner.next();
 ​
         //进行遍历
         for (int i = 0; i &lt; str.length(); i++) {
             //i依次表示字符串中的每个索引
             char c = str.charAt(i);
             System.out.print(c + " ");
         }
     }
 ​
     public static void Test2(){
         /*统计字符次数
         * 键盘录入一个字符串，统计该字符串中大写字母字符，
         * 小写字母字符，数字字符出现的次数（不考虑其他字符）
         */
         //1.键盘录入一个字符串
         Scanner scanner = new Scanner(System.in);
         System.out.println("请输入一个字符串:");
         String str = scanner.next();
         //2.统计---计数器思想++
         //定义三个计数器
         int bigCount=0;
         int smallCount=0;
         int numberCount=0;
         //3.进行遍历
         for (int i = 0; i &lt; str.length(); i++) {
             //i一次表示字符串中的每个索引
             char c = str.charAt(i);
             if (c&gt;='A'&amp;&amp;c&lt;='Z'){
                 bigCount++;
             }else if (c&gt;='a'&amp;&amp;c&lt;='z'){
                 smallCount++;
             }else if (c&gt;='0'&amp;&amp;c&lt;='9'){
                 numberCount++;
             }
         }
         //4.打印
         System.out.println("大写字母有"+bigCount+"个！");
         System.out.println("小写字母有"+smallCount+"个！");
         System.out.println("数字字符有"+numberCount+"个！");
     }
 }</code></pre> 
<h3 id="%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB">四、常用类</h3> 
<h4 id="1.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E7%B1%BB">1.常用的数学类</h4> 
<pre><code class="language-java">public class TestMath {
     public static void main(String[] args) {
         System.out.println(Math.PI);
         System.out.println(Math.max(66,77));    //求两位数的最大值
         System.out.println(Math.min(45,67));    //求两位数的最小值
         System.out.println(Math.abs(-9));       //求绝对值
         System.out.println(Math.random());      //随机数，范围 [0,1)
         System.out.println(Math.pow(2,3));      //次方，2的3 次方
         System.out.println(Math.ceil(1.2));     //向上取整， ceil：天花板
         System.out.println(Math.floor(2.9));    //向下取整， floor：地板
         System.out.println(Math.round(1.6));    //四舍五入
     }
 }</code></pre> 
<h4 id="2.%E5%8C%85%E8%A3%85%E7%B1%BB">2.包装类</h4> 
<blockquote> 
 <p>包装类：基本数据类型对应的引用数据类型</p> 
</blockquote> 
<pre><code class="language-java">/*
  *两种方式获取Integer对象的区别
  * */
 public class TestInteger {
     public static void main(String[] args) {
         //底层原理：
         //因为在实际开发中，-128~127之间的数据用的比较多
         //如果每次使用数据都是new一个新的对象，太浪费内存
         //所以，提前把这个范围中的每个对象创建好内存
         //如果要用到了不会创建新的，而是返回已经创建好的对象
         Integer i1 = Integer.valueOf(127);
         Integer i2 = Integer.valueOf(127);
         System.out.println(i1 == i2);  //true
 ​
         Integer i3 = Integer.valueOf(128);
         Integer i4 = Integer.valueOf(128);
         System.out.println(i3 == i4);  //false
 ​
         //因为有new关键字，在java中，每一次new都是创建了一个新的对象
         //所以下面两个对象都是new出来的，地址不一样
         Integer i5 = new Integer("127");
         Integer i6 = new Integer("127");
         System.out.println(i5 == i6);  //false
 ​
         Integer i7 = new Integer("128");
         Integer i8 = new Integer("128");
         System.out.println(i7 == i8);  //false
     }
 }</code></pre> 
<blockquote> 
 <p>自动装箱：把基本数据类型自动变成其对应的包装类。</p> 
 <p>自动拆箱：把包装类自动变成其对应的基本数据类型。</p> 
 <p><strong>注意：</strong>在 JDK5 以后，int 和 Integer 可以看做是同一个东西，因为他们在内部可以自动转化。</p> 
 <p>如何获取包装类对象？ 不需要 new，不需要调用方法，直接赋值即可。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f2b9d94dd57a7dc0b8767a7aa03de92/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">zzuli大一实训——个人记账管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ef63f59e75305dd51e190b35134faa94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">data和filter协议文件包含</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>