<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android使用logwrapper进行log重定向 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android使用logwrapper进行log重定向" />
<meta property="og:description" content="在Android有一些应用程序的日志输出是通过printf之类的标准函数输出的，这类log是无法记录到的。主要是由于init进程会把0,1,2三个fd指向到/dev/null，而其他进程都是由init fork出来的，所以标准输出和标准错误输出都会继承自父进程，所以默认也都是不打印出来的。
android init的实现在system/core/init/init.c中：
int main(int argc, char** argv) { ...... // At this point we&#39;re in the second stage of init. InitKernelLogging(argv); LOG(INFO) &lt;&lt; &#34;init second stage started!&#34;; ...... } init会执行log初始化动作，也就是把所有的标准输入标准输出和标准错误输出都指向/dev/null：
void InitKernelLogging(char* argv[]) { // Make stdin/stdout/stderr all point to /dev/null. int fd = open(&#34;/sys/fs/selinux/null&#34;, O_RDWR); if (fd == -1) { int saved_errno = errno; android::base::InitLogging(argv, &amp;android::base::KernelLogger); errno = saved_errno; PLOG(FATAL) &lt;&lt; &#34;Couldn&#39;t open /sys/fs/selinux/null&#34;; } dup2(fd, 0); dup2(fd, 1); dup2(fd, 2); if (fd &gt; 2) close(fd); android::base::InitLogging(argv, &amp;android::base::KernelLogger); } android中提供了logwrapper程序用来重定向log的输出，重定向的log可以使用logcat查看，我们来看下他的实现机制又是怎样的呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/48746314bed45ec678f6971b313a8550/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-14T12:13:27+08:00" />
<meta property="article:modified_time" content="2018-05-14T12:13:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android使用logwrapper进行log重定向</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在Android有一些应用程序的日志输出是通过printf之类的标准函数输出的，这类log是无法记录到的。主要是由于init进程会把0,1,2三个fd指向到/dev/null，而其他进程都是由init fork出来的，所以标准输出和标准错误输出都会继承自父进程，所以默认也都是不打印出来的。</p> 
<p>android init的实现在system/core/init/init.c中：</p> 
<pre class="prettyprint"><code class=" hljs asciidoc">
int main(int argc, char** argv) {

<span class="hljs-code">......


 // At this point we're in the second stage of init.

 InitKernelLogging(argv);

 LOG(INFO) &lt;&lt; "init second stage started!";

......</span>
}
</code></pre> 
<p>init会执行log初始化动作，也就是把所有的标准输入标准输出和标准错误输出都指向/dev/null：</p> 
<pre class="prettyprint"><code class=" hljs cs">
<span class="hljs-keyword">void</span> InitKernelLogging(<span class="hljs-keyword">char</span>* argv[]) {

    <span class="hljs-comment">// Make stdin/stdout/stderr all point to /dev/null.</span>

    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">"/sys/fs/selinux/null"</span>, O_RDWR);

    <span class="hljs-keyword">if</span> (fd == -<span class="hljs-number">1</span>) {

        <span class="hljs-keyword">int</span> saved_errno = errno;

        android::<span class="hljs-keyword">base</span>::InitLogging(argv, &amp;android::<span class="hljs-keyword">base</span>::KernelLogger);

        errno = saved_errno;

        PLOG(FATAL) &lt;&lt; <span class="hljs-string">"Couldn't open /sys/fs/selinux/null"</span>;

    }

    dup2(fd, <span class="hljs-number">0</span>);

    dup2(fd, <span class="hljs-number">1</span>);

    dup2(fd, <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">2</span>) close(fd);



    android::<span class="hljs-keyword">base</span>::InitLogging(argv, &amp;android::<span class="hljs-keyword">base</span>::KernelLogger);

}
</code></pre> 
<p>android中提供了logwrapper程序用来重定向log的输出，重定向的log可以使用logcat查看，我们来看下他的实现机制又是怎样的呢？</p> 
<p>logwrapper的源代码实现在system/core/logwrapper中，原理如下：</p> 
<p>通过logwrapper的封装来执行一个command，logwrapper会fork一个子进程，并在子进程中exec执行cmd，父进程负责和子进程通讯，并记录子进程输出的log，父进程会根据logwrapper的参数来选择对应的log输出方式：</p> 
<pre class="prettyprint"><code class=" hljs lasso">
<span class="hljs-comment">/* Log directly to the specified log */</span>

static <span class="hljs-literal">void</span> do_log_line(struct log_info <span class="hljs-subst">*</span>log_info, char <span class="hljs-subst">*</span>line) {

    <span class="hljs-keyword">if</span> (log_info<span class="hljs-subst">-&gt;</span>log_target <span class="hljs-subst">&amp;</span> LOG_KLOG) {

        klog_write(<span class="hljs-number">6</span>, log_info<span class="hljs-subst">-&gt;</span>klog_fmt, line);

    }

    <span class="hljs-keyword">if</span> (log_info<span class="hljs-subst">-&gt;</span>log_target <span class="hljs-subst">&amp;</span> LOG_ALOG) {

        ALOG(LOG_INFO, log_info<span class="hljs-subst">-&gt;</span>btag, <span class="hljs-string">"%s"</span>, line);

    }

    <span class="hljs-keyword">if</span> (log_info<span class="hljs-subst">-&gt;</span>log_target <span class="hljs-subst">&amp;</span> LOG_FILE) {

        fprintf(log_info<span class="hljs-subst">-&gt;</span>fp, <span class="hljs-string">"%s\n"</span>, line);

    }

}
</code></pre> 
<p>父进程起到一个log重定向的作用，它收取子进程输出的log，并通过其他方式输出出来，从上面的一段实现上可以看出，父进程可以通过do_log_line来按照三种方式来输出：</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver">
（<span class="hljs-number">1</span>）LOG_KLOG的方式输出，调用的是klog_write来输出kernel <span class="hljs-built_in">log</span>

（<span class="hljs-number">2</span>）LOG_ALOG，这种是输出给logcat使用的<span class="hljs-built_in">log</span>，默认是LOG INFO级别

（<span class="hljs-number">3</span>）LOG_FILE，输出<span class="hljs-built_in">log</span>到指定<span class="hljs-built_in">file</span>文件，在我看得这个版本代码中，此方法暂时还不可用
</code></pre> 
<p>父进程和子进程采用的是ptty机制来做进程通讯的，具体实现在system/core/logwrapper/logwrap.c中：</p> 
<pre class="prettyprint"><code class=" hljs objectivec">
<span class="hljs-keyword">int</span> android_fork_execvp_ext(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">int</span> *status, <span class="hljs-keyword">bool</span> ignore_int_quit,

        <span class="hljs-keyword">int</span> log_target, <span class="hljs-keyword">bool</span> abbreviated, <span class="hljs-keyword">char</span> *file_path,

        <span class="hljs-keyword">void</span> *unused_opts, <span class="hljs-keyword">int</span> unused_opts_len) {

    pid_t pid;

    <span class="hljs-keyword">int</span> parent_ptty;

    <span class="hljs-keyword">int</span> child_ptty;

    <span class="hljs-keyword">struct</span> sigaction intact;

    <span class="hljs-keyword">struct</span> sigaction quitact;

    sigset_t blockset;

    sigset_t oldset;

    <span class="hljs-keyword">int</span> rc = <span class="hljs-number">0</span>;



    LOG_ALWAYS_FATAL_IF(unused_opts != <span class="hljs-literal">NULL</span>);

    LOG_ALWAYS_FATAL_IF(unused_opts_len != <span class="hljs-number">0</span>);



    rc = pthread_mutex_lock(&amp;fd_mutex);

    <span class="hljs-keyword">if</span> (rc) {

        ERROR(<span class="hljs-string">"failed to lock signal_fd mutex\n"</span>);

        <span class="hljs-keyword">goto</span> err_lock;

    }



    <span class="hljs-comment">/* Use ptty instead of socketpair so that STDOUT is not buffered */</span>          <span class="hljs-comment">//使用ptty代替socket，因为socket是有缓冲的</span>

    parent_ptty = TEMP_FAILURE_RETRY(open(<span class="hljs-string">"/dev/ptmx"</span>, O_RDWR));

    <span class="hljs-keyword">if</span> (parent_ptty &lt; <span class="hljs-number">0</span>) {

        ERROR(<span class="hljs-string">"Cannot create parent ptty\n"</span>);

        rc = -<span class="hljs-number">1</span>;

        <span class="hljs-keyword">goto</span> err_open;

    }



    <span class="hljs-keyword">char</span> child_devname[<span class="hljs-number">64</span>];

    <span class="hljs-keyword">if</span> (grantpt(parent_ptty) || unlockpt(parent_ptty) ||

            ptsname_r(parent_ptty, child_devname, <span class="hljs-keyword">sizeof</span>(child_devname)) != <span class="hljs-number">0</span>) {

        ERROR(<span class="hljs-string">"Problem with /dev/ptmx\n"</span>);

        rc = -<span class="hljs-number">1</span>;

        <span class="hljs-keyword">goto</span> err_ptty;

    }



    child_ptty = TEMP_FAILURE_RETRY(open(child_devname, O_RDWR));

    <span class="hljs-keyword">if</span> (child_ptty &lt; <span class="hljs-number">0</span>) {

        ERROR(<span class="hljs-string">"Cannot open child_ptty\n"</span>);

        rc = -<span class="hljs-number">1</span>;

        <span class="hljs-keyword">goto</span> err_child_ptty;

    }



    sigemptyset(&amp;blockset);

    sigaddset(&amp;blockset, SIGINT);

    sigaddset(&amp;blockset, SIGQUIT);

    pthread_sigmask(SIG_BLOCK, &amp;blockset, &amp;oldset);



    pid = fork();

    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) {

        close(child_ptty);

        ERROR(<span class="hljs-string">"Failed to fork\n"</span>);

        rc = -<span class="hljs-number">1</span>;

        <span class="hljs-keyword">goto</span> err_fork;

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {

        pthread_mutex_unlock(&amp;fd_mutex);

        pthread_sigmask(SIG_SETMASK, &amp;oldset, <span class="hljs-literal">NULL</span>);

        close(parent_ptty);                                       <span class="hljs-comment">//创建的子进程会继承父进程的fd，所以要关闭不需要的fd</span>



        dup2(child_ptty, <span class="hljs-number">1</span>);

        dup2(child_ptty, <span class="hljs-number">2</span>);

        close(child_ptty);



        child(argc, argv);

    } <span class="hljs-keyword">else</span> {

        close(child_ptty);                                            <span class="hljs-comment">//父进程也要关闭不需要的fd，剩余的fd就是用于进程交互的fd了</span>

        <span class="hljs-keyword">if</span> (ignore_int_quit) {

            <span class="hljs-keyword">struct</span> sigaction ignact;



            memset(&amp;ignact, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ignact));

            ignact<span class="hljs-variable">.sa_handler</span> = SIG_IGN;

            sigaction(SIGINT, &amp;ignact, &amp;intact);

            sigaction(SIGQUIT, &amp;ignact, &amp;quitact);

        }



        rc = parent(argv[<span class="hljs-number">0</span>], parent_ptty, pid, status, log_target,

                    abbreviated, file_path);

    }



    <span class="hljs-keyword">if</span> (ignore_int_quit) {

        sigaction(SIGINT, &amp;intact, <span class="hljs-literal">NULL</span>);

        sigaction(SIGQUIT, &amp;quitact, <span class="hljs-literal">NULL</span>);

    }

err_fork:

    pthread_sigmask(SIG_SETMASK, &amp;oldset, <span class="hljs-literal">NULL</span>);

err_child_ptty:

err_ptty:

    close(parent_ptty);

err_open:

    pthread_mutex_unlock(&amp;fd_mutex);

err_lock:

    <span class="hljs-keyword">return</span> rc;

}
</code></pre> 
<h3 id="示例">示例：</h3> 
<pre class="prettyprint"><code class=" hljs livecodeserver">
servcie akmd /<span class="hljs-keyword">system</span>/bin/logwrapper /sbin/akmd
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a8ab531ee8f8ee917b86a135cbdfc0f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">线性代数导读&#43;总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51a6dd67c27976797e4c442fc0c7ec70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决twaver 引起的文本不可复制问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>