<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>都2023了，Android Compose还值得学吗？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="都2023了，Android Compose还值得学吗？" />
<meta property="og:description" content="前言 Android Compose作为去年出来的新技术，本来我也没有想着再写一篇关于这方面的文章，但是有不少人问了这个问题。就把这个问题再提出来聊一次。
Jetpack Compose 简述 Jetpack Compose是用于构建原生Android UI的现代工具包。 Jetpack Compose使用更少的代码，强大的工具和直观的Kotlin API，简化并加速了Android上的UI开发。这是Android Developers 官网对它的描述。
由于Compose基于Kotlin构建，因此可以与Java编程语言完全互操作，并且可以直接访问所有Android和Jetpack API。因此你可以简单地描述UI的外观，而Compose则负责其余的工作-当状态发生改变时，你的UI将自动更新。
它与现有的UI工具包也是完全兼容的，因此你可以混合原来的View和现在新的View，并且从一开始就使用Material和动画进行设计。
据谷歌官方介绍Jetpack Compose 有以下特点
更少的代码：使用更少的代码实现更多的功能，并且可以避免各种错误，从而使代码简洁且易于维护。
直观的 Kotlin API：只需描述界面，Compose 会负责处理剩余的工作。应用状态变化时，界面会自动更新。
加快应用开发：兼容现有的所有代码，方便随时随地采用。借助实时预览和全面的 Android Studio 支持，实现快速迭代
。
功能强大：凭借对 Android 平台 API 的直接访问和对于 Material Design、深色主题、动画等的内置支持，创建精美的应用。
Compose的渲染性能到底怎么样？ Compose列表渲染性能分析
关于Compose的列表的性能问题也是老生常谈了，很多人都说Compose的LazyColumn在低端手机上会卡顿，那么我们就来分析比较一下同一个页面用LazyColumn与RecyclerView分别实现，在性能上有什么差距？
首先来看下页面的样式。
如上，这个页面整体是一个列表，共有4种类型。
可左右滑动的Banner
包含文字与一张图片的item
包含3张图片的复杂item
作为视频封面的大图item
然后我们用LazyColumn与RecyclerView分别实现以上页面，然后在不同手机上分别测量其快速滑动时的FPS，结果如下：
同时在debug包与release包都进行了以上测试，结果基本一致。可以看出，LazyColumn与RecyclerView在性能上的确有一定差距，尤其在低端手机上，LazyColumn快速滑动时掉帧明显，而RecyclerView则都很流畅。
只能说RecyclerView太强了~
/ Compose粒子动画渲染性能分析 /
除了列表，我们也可以通过粒子动画的方式来测量Compose的性能，通过粒子动画我们可以评估在极端情况下Compose与View的渲染性能。首先来看下粒子动画效果：
如上，我们可以在画布上生成随机粒子并且做动画，随着粒子数量的增长，观察应用的FPS，以此评估Compose的渲染性能，我们同时也实现了一个View版本以进行对比，结果如下：
可以看出，随着粒子数从100增长到10000，应用的FPS逐渐降低，在低端手机上尤其明显。而与列表不同的是，Compose与View在粒子动画中的渲染性能几乎一致，可以说是几乎没有区别。
总结
本文主要从FPS的角度分析介绍了Compose的渲染性能，可以看出在画布中随机生成粒子动画时，Compose与View的渲染性能几乎一致。而对于复杂列表，LazyColumn与RecyclerView在性能上有一定差距，在低端手机上尤其明显，在快速滑动时会有明显卡顿。
结合两个实验，看起来应该是LazyColumn组件存在一定性能问题，而Compose本身的渲染性能已经基本与View一致了~
Jetpack Compose VS 传统UI Jetpack compose 提供了现代化的声明式 Kotlin API，取代 Android 传统的命令式开发 xml 布局，可帮助开发者用更少的代码构建美观、响应迅速的应用程序。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3c08ba711b263622cd1da226e0787763/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-30T16:15:00+08:00" />
<meta property="article:modified_time" content="2023-04-30T16:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">都2023了，Android Compose还值得学吗？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_2"></a>前言</h3> 
<p>Android Compose作为去年出来的新技术，本来我也没有想着再写一篇关于这方面的文章，但是有不少人问了这个问题。就把这个问题再提出来聊一次。</p> 
<p><img src="https://images2.imgbox.com/67/5b/SyCQSe3X_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Jetpack_Compose__12"></a>Jetpack Compose 简述</h3> 
<p><img src="https://images2.imgbox.com/68/aa/0oPduydr_o.png" alt="在这里插入图片描述"></p> 
<p>Jetpack Compose是用于构建原生Android UI的现代工具包。 Jetpack Compose使用更少的代码，强大的工具和直观的Kotlin API，简化并加速了Android上的UI开发。这是Android Developers 官网对它的描述。</p> 
<p>由于Compose基于Kotlin构建，因此可以与Java编程语言完全互操作，并且可以直接访问所有Android和Jetpack API。因此你可以简单地描述UI的外观，而Compose则负责其余的工作-当状态发生改变时，你的UI将自动更新。</p> 
<p>它与现有的UI工具包也是完全兼容的，因此你可以混合原来的View和现在新的View，并且从一开始就使用Material和动画进行设计。</p> 
<p>据谷歌官方介绍Jetpack Compose 有以下特点</p> 
<p>更少的代码：使用更少的代码实现更多的功能，并且可以避免各种错误，从而使代码简洁且易于维护。</p> 
<p>直观的 Kotlin API：只需描述界面，Compose 会负责处理剩余的工作。应用状态变化时，界面会自动更新。</p> 
<p>加快应用开发：兼容现有的所有代码，方便随时随地采用。借助实时预览和全面的 Android Studio 支持，实现快速迭代<br> 。<br> 功能强大：凭借对 Android 平台 API 的直接访问和对于 Material Design、深色主题、动画等的内置支持，创建精美的应用。</p> 
<h3><a id="Compose_33"></a>Compose的渲染性能到底怎么样？</h3> 
<p>Compose列表渲染性能分析</p> 
<p>关于Compose的列表的性能问题也是老生常谈了，很多人都说Compose的LazyColumn在低端手机上会卡顿，那么我们就来分析比较一下同一个页面用LazyColumn与RecyclerView分别实现，在性能上有什么差距？</p> 
<p>首先来看下页面的样式。<br> <img src="https://images2.imgbox.com/4c/18/0w9LDqoY_o.png" alt="在这里插入图片描述"></p> 
<p>如上，这个页面整体是一个列表，共有4种类型。</p> 
<p>可左右滑动的Banner</p> 
<p>包含文字与一张图片的item</p> 
<p>包含3张图片的复杂item</p> 
<p>作为视频封面的大图item</p> 
<p>然后我们用LazyColumn与RecyclerView分别实现以上页面，然后在不同手机上分别测量其快速滑动时的FPS，结果如下：</p> 
<p>同时在debug包与release包都进行了以上测试，结果基本一致。可以看出，LazyColumn与RecyclerView在性能上的确有一定差距，尤其在低端手机上，LazyColumn快速滑动时掉帧明显，而RecyclerView则都很流畅。</p> 
<p>只能说RecyclerView太强了~</p> 
<p>/ Compose粒子动画渲染性能分析 /</p> 
<p>除了列表，我们也可以通过粒子动画的方式来测量Compose的性能，通过粒子动画我们可以评估在极端情况下Compose与View的渲染性能。首先来看下粒子动画效果：<br> <img src="https://images2.imgbox.com/b7/62/4dly2lzc_o.png" alt="在这里插入图片描述"></p> 
<p>如上，我们可以在画布上生成随机粒子并且做动画，随着粒子数量的增长，观察应用的FPS，以此评估Compose的渲染性能，我们同时也实现了一个View版本以进行对比，结果如下：</p> 
<p>可以看出，随着粒子数从100增长到10000，应用的FPS逐渐降低，在低端手机上尤其明显。而与列表不同的是，Compose与View在粒子动画中的渲染性能几乎一致，可以说是几乎没有区别。</p> 
<p><strong>总结</strong></p> 
<p>本文主要从FPS的角度分析介绍了Compose的渲染性能，可以看出在画布中随机生成粒子动画时，Compose与View的渲染性能几乎一致。而对于复杂列表，LazyColumn与RecyclerView在性能上有一定差距，在低端手机上尤其明显，在快速滑动时会有明显卡顿。</p> 
<p>结合两个实验，看起来应该是LazyColumn组件存在一定性能问题，而Compose本身的渲染性能已经基本与View一致了~</p> 
<h3><a id="Jetpack_Compose_VS_UI_78"></a>Jetpack Compose VS 传统UI</h3> 
<p>Jetpack compose 提供了现代化的声明式 Kotlin API，取代 Android 传统的命令式开发 xml 布局，可帮助开发者用更少的代码构建美观、响应迅速的应用程序。</p> 
<p>命令式UI特征：</p> 
<p>UI是可变的：控件接受命令后通过变化自身刷新UI<br> UI持有State：控件的变化正是通过改变自身状态实现的</p> 
<p>声明式UI特征：</p> 
<p>UI不可变 : @Composable函数不返回任何可引用句柄，无法被外界改变。<br> UI不持有State: @Composable函数无法持有状态的，显示的数据都需要通过参数传入。</p> 
<p>随着界面越来越复杂，控件越来越多，各控件 State 难以保持同步，UI显示不一致的Bug频发。而声明式UI与命令式UI的特点截然相反，正好可以弥补命令式的缺陷。</p> 
<h3><a id="_96"></a>总结</h3> 
<p>其实一项新的技术点提出来肯定是有这道理的，不然总不能做无用功吧。</p> 
<p>你想在Android的路上走的更远，Compose值得学。</p> 
<p>如果对于Compose没有学习路径，可以扫描下方二维码免费领取资料！<br> <img src="https://images2.imgbox.com/d6/6f/bYX5bQF3_o.png"></p> 
<h3><a id="Android_Compose__107"></a><strong>《<strong><strong>Android Compose 强化实战</strong></strong>》</strong></h3> 
<h4><a id="_109"></a><strong>目录</strong></h4> 
<p><img src="https://images2.imgbox.com/93/ad/KAW1LJVc_o.png" alt="img"></p> 
<h4><a id="_Composebanner_113"></a><strong>第一章 使用Compose实现底部按钮和首页banner以及数据列表</strong></h4> 
<p>​ ● 第一节 Column、Row、ConstraintLayout布局先知</p> 
<p>​ ● 第二节 首页内容的实现</p> 
<p><img src="https://images2.imgbox.com/81/02/m99BijDE_o.png" alt="img"></p> 
<h4><a id="__121"></a><strong>第二章 导航规整并实现登录页个人中心页</strong></h4> 
<p>​ ● 第一节 导航规整</p> 
<p>​ ● 第二节 个人中心的实现</p> 
<p>​ ● 第三节 登录页面的实现</p> 
<p><img src="https://images2.imgbox.com/af/8c/YjL8Z9ry_o.png" alt="img"></p> 
<h4><a id="__131"></a><strong>第三章 实现分类页面</strong></h4> 
<p>​ ● 第一节 Scaffold简单使用</p> 
<p>​ ● 第二节 BottomNavigation和NavHost实现底部导航</p> 
<p>​ ● 第三节 分类页面的实现</p> 
<p>​ ● 第四节 Compose自定义布局实现流式布局</p> 
<p><img src="https://images2.imgbox.com/1a/9b/6GwLQ7of_o.png" alt="img"></p> 
<h4><a id="__143"></a><strong>第四章 实现搜索页面</strong></h4> 
<p>​ ● 第一节 ROOM数据库</p> 
<p>​ ● 第二节 官方Flow Layout</p> 
<p>​ ● 第三节 状态布局</p> 
<p><img src="https://images2.imgbox.com/06/9a/vZOPgE5i_o.png" alt="img"></p> 
<h4><a id="__153"></a><strong>第五章 项目页面的实现</strong></h4> 
<p>​ ● 第一节 获取数据</p> 
<p>​ ● 第二节 Controllable实现顶部滑动菜单</p> 
<p>​ ● 第三节 HorizontalPager 实现页面数据列表</p> 
<p>​ ● 第四节 Compose中Webview的使用</p> 
<p><img src="https://images2.imgbox.com/50/47/Gg552fuc_o.png" alt="img"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbb7c75240ddaefd621b5608c1c623f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VSCode 技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7083d56774419093c3f4edbae583e70a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vite设置代理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>