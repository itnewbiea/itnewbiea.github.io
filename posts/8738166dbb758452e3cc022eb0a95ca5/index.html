<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring-声明式事务 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring-声明式事务" />
<meta property="og:description" content="文章目录 目录
文章目录
前言
一 . 声明式事务概念
1.1 编程式事务
1.2 声明式事务
1.3 spring事务管理器
二 . 基于注解的声明式事务
事务属性: 只读
事务属性: 超时时间
事务属性: 事务异常
事务属性: 事务隔离级别
事务属性: 事务的传播行为
前言 大家好,今天给大家介绍一下spring-tx的相关内容
一 . 声明式事务概念 1.1 编程式事务 编程式事务指手动编写代码来管理事务,即通过编码的方式来控制事务的提交和回滚。
编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。
Connection conn = ...;
try {
// 开启事务：关闭事务的自动提交
conn.setAutoCommit(false);
// 核心操作
// 业务代码
// 提交事务
conn.commit();
}catch(Exception e){
// 回滚事务
conn.rollBack();
}finally{
// 释放数据库连接
conn.close();
}
1.2 声明式事务 声明式事务是通过使用注解或配置文件的方式来实现事务管理的方式。在声明式事务中，开发人员只需要在需要进行事务管理的方法或类上添加相应的注解或配置，由事务管理框架来自动处理事务的开始、提交或回滚。这种方式使得代码更加简洁和易于维护，开发人员无需关注事务管理的细节，只需专注于业务逻辑的编写。
总的来说，编程式事务需要开发人员手动管理事务的细节，适用于对事务管理有较深了解且需要更细粒度控制的场景；而声明式事务通过注解或配置的方式来实现事务管理，减少了开发人员的工作量，适用于简单的事务管理场景。
1.3 spring事务管理器 spring声明式事务管理器对应接口
DataSourceTransactionManager类中的主要方法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8738166dbb758452e3cc022eb0a95ca5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-03T16:54:15+08:00" />
<meta property="article:modified_time" content="2023-11-03T16:54:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring-声明式事务</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<div> 
 <h4 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</h4> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" rel="nofollow">文章目录</a></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%20.%20%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%20.%20%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5" rel="nofollow">一 . 声明式事务概念</a></p> 
 <p id="1.1%20%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1-toc" style="margin-left:40px;"><a href="#1.1%20%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1" rel="nofollow">1.1 编程式事务</a></p> 
 <p id="1.2%20%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-toc" style="margin-left:40px;"><a href="#1.2%20%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1" rel="nofollow">1.2 声明式事务</a></p> 
 <p id="1.3%20spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8-toc" style="margin-left:40px;"><a href="#1.3%20spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8" rel="nofollow">1.3 spring事务管理器</a></p> 
 <p id="%E4%BA%8C%20.%20%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%20.%20%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1" rel="nofollow">二 . 基于注解的声明式事务</a></p> 
 <p id="%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E5%8F%AA%E8%AF%BB-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E5%8F%AA%E8%AF%BB" rel="nofollow">事务属性: 只读</a></p> 
 <p id="%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4" rel="nofollow">事务属性: 超时时间</a></p> 
 <p id="%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8" rel="nofollow">事务属性: 事务异常</a></p> 
 <p id="%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow">事务属性: 事务隔离级别</a></p> 
 <p id="%C2%A0%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA" rel="nofollow"> 事务属性: 事务的传播行为</a></p> 
</div> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<blockquote> 
 <p>大家好,今天给大家介绍一下spring-tx的相关内容</p> 
</blockquote> 
<hr> 
<h2 id="%E4%B8%80%20.%20%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5">一 . 声明式事务概念</h2> 
<h3 id="1.1%20%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1">1.1 编程式事务</h3> 
<p>编程式事务指手动编写代码来管理事务,即通过编码的方式来控制事务的提交和回滚。</p> 
<p>编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。</p> 
<blockquote> 
 <p>Connection conn = ...;<br>   <br> try {<!-- --><br>     // 开启事务：关闭事务的自动提交<br>     conn.setAutoCommit(false);<br>     // 核心操作<br>     // 业务代码<br>     // 提交事务<br>     conn.commit();<br>   <br> }catch(Exception e){<!-- --><br>   <br>     // 回滚事务<br>     conn.rollBack();<br>   <br> }finally{<!-- --><br>   <br>     // 释放数据库连接<br>     conn.close();<br>   <br> }</p> 
</blockquote> 
<h3 id="1.2%20%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">1.2 声明式事务</h3> 
<p>声明式事务是通过使用注解或配置文件的方式来实现事务管理的方式。在声明式事务中，开发人员只需要在需要进行事务管理的方法或类上添加相应的注解或配置，由事务管理框架来自动处理事务的开始、提交或回滚。这种方式使得代码更加简洁和易于维护，开发人员无需关注事务管理的细节，只需专注于业务逻辑的编写。</p> 
<p>总的来说，编程式事务需要开发人员手动管理事务的细节，适用于对事务管理有较深了解且需要更细粒度控制的场景；而声明式事务通过注解或配置的方式来实现事务管理，减少了开发人员的工作量，适用于简单的事务管理场景。</p> 
<h3 id="1.3%20spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8">1.3 spring事务管理器</h3> 
<p>spring声明式事务管理器对应接口</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/dd/ea/kB9CHs3G_o.png" width="940"></p> 
<p>DataSourceTransactionManager类中的主要方法：</p> 
<ul><li>doBegin()：开启事务</li><li>doSuspend()：挂起事务</li><li>doResume()：恢复挂起的事务</li><li>doCommit()：提交事务</li><li>doRollback()：回滚事务</li></ul> 
<p><img alt="" height="761" src="https://images2.imgbox.com/21/16/zic67xW2_o.png" width="1200"></p> 
<p>事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合 JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！</p> 
<h2 id="%E4%BA%8C%20.%20%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">二 . 基于注解的声明式事务</h2> 
<p>Spring声明式事务管理常用的注解包括：</p> 
<ol><li> <p>@Transactional：用于标记需要进行事务管理的方法或类。</p> </li><li> <p>@Propagation：用于设置事务的传播行为，包括REQUIRED（默认值）、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED。</p> </li><li> <p>@ReadOnly：用于设置事务是否为只读事务，如果为只读事务，则不允许进行数据修改操作。</p> </li><li> <p>@RollbackFor：用于设置哪些异常需要回滚事务，可以设置多个异常类型。</p> </li><li> <p>@NoRollbackFor：用于设置哪些异常不需要回滚事务，可以设置多个异常类型。</p> </li></ol> 
<h3 id="%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E5%8F%AA%E8%AF%BB">事务属性: 只读</h3> 
<blockquote> 
 <p>// readOnly = true把当前事务设置为只读 默认是false!</p> 
 <p>@Transactional(readOnly = true)</p> 
</blockquote> 
<p>只读事务是指在事务执行期间，只能读取数据而不能对数据进行修改的事务。只读事务具有以下优势：</p> 
<ol><li> <p>提升性能：只读事务不需要对数据进行修改操作，因此可以减少锁的竞争和冲突，提高并发性能。在高并发读取场景下，只读事务可以更好地满足性能需求。</p> </li><li> <p>减少资源占用：只读事务不需要对数据进行修改，因此不需要为数据的修改操作分配额外的资源，如日志记录、事务日志等。这样可以减少系统的资源占用，提高系统的吞吐量。</p> </li><li> <p>数据一致性：只读事务不会对数据进行修改，因此不会引起数据的不一致性。在某些场景下，只读事务可以提供数据的一致性视图，确保读取到的数据是一致的。</p> </li><li> <p>并发冲突减少：只读事务不会对数据进行修改，因此不会引起并发冲突。多个只读事务可以并发执行而不会互相干扰，提高系统的并发性能。</p> </li><li> <p>降低事务管理的复杂性：只读事务不需要关注事务的提交和回滚，只需要关注数据的读取逻辑。这样可以简化事务管理的复杂性，减少开发人员的工作量。</p> </li></ol> 
<h3 id="%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4">事务属性: 超时时间</h3> 
<p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。</p> 
<p>此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p> 
<p>概括来说就是一句话：超时回滚，释放资源。</p> 
<h3 id="%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8">事务属性: 事务异常</h3> 
<p>事务异常是在事务执行过程中发生的异常。事务异常可以分为两种情况：</p> 
<ol><li> <p>运行时异常（unchecked exception）：这些异常不需要在方法签名中声明，也不需要在事务配置中指定是否回滚。当发生运行时异常时，Spring默认会回滚事务。常见的运行时异常包括NullPointerException、ArrayIndexOutOfBoundsException、ClassCastException等。</p> </li><li> <p>受检异常（checked exception）：这些异常需要在方法签名中声明，并且在事务配置中指定是否回滚。当发生受检异常时，可以根据需要选择是否回滚事务。如果不回滚事务，则异常会被捕获并处理，事务会继续执行。常见的受检异常包括IOException、SQLException等。</p> </li></ol> 
<p>对于事务异常的处理，可以使用以下方式：</p> 
<ol><li> <p>不进行事务回滚：可以通过在@Transactional注解中使用noRollbackFor属性指定不回滚的异常类型，或者在代码中捕获并处理异常，不抛出异常即可。</p> </li><li> <p>进行事务回滚：如果发生异常时需要回滚事务，可以通过在@Transactional注解中使用rollbackFor属性指定需要回滚的异常类型，或者在代码中抛出异常即可。</p> </li><li> <p>自定义异常处理：可以通过实现Spring的TransactionSynchronization接口，在事务提交或回滚时进行自定义的异常处理逻辑。</p> </li></ol> 
<h3 id="%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务属性: 事务隔离级别</h3> 
<p>1. 事务隔离级别</p> 
<p>    数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p> 
<p>    1. 读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。<br>     2. 读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。<br>     3. 可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。<br>     4. 串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</p> 
<p>    不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。</p> 
<p>2.事务隔离级别设置</p> 
<p>在Spring中，可以使用@Transactional注解来设置事务隔离级别。@Transactional注解提供了一个isolation属性，用于设置事务的隔离级别。isolation属性可以设置为以下常量值之一：</p> 
<ol><li> <p>Isolation.DEFAULT：使用数据库默认的隔离级别，通常为READ_COMMITTED。</p> </li><li> <p>Isolation.READ_UNCOMMITTED：读取未提交的数据，可以读取到其他事务未提交的数据，存在脏读、不可重复读和幻读的问题。</p> </li><li> <p>Isolation.READ_COMMITTED：读取已提交的数据，只能读取到已经提交的数据，可以避免脏读问题，但是仍然存在不可重复读和幻读的问题。</p> </li><li> <p><span style="color:#fe2c24;">Isolation.REPEATABLE_READ</span><span style="color:#0d0016;">(mysql默认)</span>：可重复读取数据，确保事务内多次读取同一数据时，结果始终相同，可以避免脏读和不可重复读问题，但仍然存在幻读问题。</p> </li><li> <p>Isolation.SERIALIZABLE：串行化读取数据，保证事务之间的隔离性最高，可以避免脏读、不可重复读和幻读问题，但是会降低并发性能。</p> </li></ol> 
<h3 id="%C2%A0%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%3A%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"> 事务属性: 事务的传播行为</h3> 
<p><img alt="" height="450" src="https://images2.imgbox.com/83/c4/p3aPCqbH_o.png" width="1002"></p> 
<h2 id="%E6%80%BB%E7%BB%93"></h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c699449e07b95c4afaf8fbcc1c0f70f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">启用NTP服务解决Linux系统时间与北京时间不同步问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de6a8deb17740112fbeee5413b1369f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android studio安卓模拟器启动了但是看不到画面解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>