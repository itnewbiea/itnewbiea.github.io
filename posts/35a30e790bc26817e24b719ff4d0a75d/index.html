<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《二十九》自动化构建工具 Gulp - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《二十九》自动化构建工具 Gulp" />
<meta property="og:description" content="基于 Gulp4。
Gulp：是一个工具包，可以帮助自动化和增强工作流。
Gulp 和 Webpack 的区别： Gulp 的核心理念是 task runner。可以定义一系列任务，等到任务被执行；是基于文件Stream 的构建流；可以使用 Gulp 的插件体系来完成任务。Webpack 的核心理念是 module bundler。是一个模块化的打包工具；可以使用各种各样的 Lodaer 来加载不同的模块；可以使用各种各样的插件在打包的生命周期中完成其他的任务。 Gulp 相对于 Webpack 来说更加地简单易用，适合编写一些自动化的任务，让它们挨个自动去执行，但是对于目前大型的项目（React、Vue、Angular 等）并不会使用 Gulp 来构建。
Gulp 默认不支持模块化。
Gulp 的基本使用： 每个 Gulp 任务都是一个异步的 JavaScript 函数；接收一个回调函数作为参数；必须明确地表示被执行完成，可以通过两种方式：执行作为参数的回调函数，或者返回一个 stream、promise、event emitter、child process 或者 observable 类型的函数。
Gulp 中任务可以分为公开任务和私有任务。
公开任务：在 gulpfile.js 文件中导出的任务被称为公开任务，这些任务可以通过 gulp 命令直接调用。私有任务：被设计为在内部使用，通常作为 series() 或者 parallel() 任务组合的组成部分。 Gulp 单个任务： 新建 gulp-demo 文件夹，并 npm init -y 初始化该项目。
在该文件夹下本地安装 Gulp：npm install gulp。
在项目根目录下新建 gulpfile.js 文件，并定义任务。
// gulpfile." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/35a30e790bc26817e24b719ff4d0a75d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-08T08:47:09+08:00" />
<meta property="article:modified_time" content="2023-12-08T08:47:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《二十九》自动化构建工具 Gulp</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>基于 Gulp4。</p> 
</blockquote> 
<p>Gulp：是一个工具包，可以帮助自动化和增强工作流。<br> <img src="https://images2.imgbox.com/bd/1f/6hP0ysxl_o.png" alt="请添加图片描述"></p> 
<h2><a id="Gulp__Webpack__4"></a>Gulp 和 Webpack 的区别：</h2> 
<ol><li>Gulp 的核心理念是 <code>task runner</code>。可以定义一系列任务，等到任务被执行；是基于文件Stream 的构建流；可以使用 Gulp 的插件体系来完成任务。</li><li>Webpack 的核心理念是 <code>module bundler</code>。是一个模块化的打包工具；可以使用各种各样的 Lodaer 来加载不同的模块；可以使用各种各样的插件在打包的生命周期中完成其他的任务。</li></ol> 
<p>Gulp 相对于 Webpack 来说更加地简单易用，适合编写一些自动化的任务，让它们挨个自动去执行，但是对于目前大型的项目（React、Vue、Angular 等）并不会使用 Gulp 来构建。</p> 
<blockquote> 
 <p>Gulp 默认不支持模块化。</p> 
</blockquote> 
<h2><a id="Gulp__10"></a>Gulp 的基本使用：</h2> 
<p>每个 Gulp 任务都是一个异步的 JavaScript 函数；接收一个回调函数作为参数；必须明确地表示被执行完成，可以通过两种方式：执行作为参数的回调函数，或者返回一个 stream、promise、<code>event emitter</code>、<code>child process</code> 或者 observable 类型的函数。</p> 
<p>Gulp 中任务可以分为公开任务和私有任务。</p> 
<ol><li>公开任务：在 <code>gulpfile.js</code> 文件中导出的任务被称为公开任务，这些任务可以通过 gulp 命令直接调用。</li><li>私有任务：被设计为在内部使用，通常作为 <code>series()</code> 或者 <code>parallel()</code> 任务组合的组成部分。</li></ol> 
<h2><a id="Gulp__16"></a>Gulp 单个任务：</h2> 
<ol><li> <p>新建 <code>gulp-demo</code> 文件夹，并 <code>npm init -y</code> 初始化该项目。</p> </li><li> <p>在该文件夹下本地安装 Gulp：<code>npm install gulp</code>。</p> </li><li> <p>在项目根目录下新建 <code>gulpfile.js</code> 文件，并定义任务。</p> <pre><code>// gulpfile.js
// 定义任务
const test = callback =&gt; {
  console.log('test 任务被执行')
  callback()
}

// 导出任务
module.exports = {
  test
}
</code></pre> 
  <blockquote> 
   <p>在 Gulp4 之前，定义任务的写法为：</p> 
   <pre><code>// gulpfile.js
const gulp = require("gulp")
gulp.task('test', callback =&gt; {
 console.log('test 任务被执行')
 callback()
})
</code></pre> 
  </blockquote> </li><li> <p>运行 <code>npx gulp test</code> 命令，会自动去 <code>fulpfile.js</code> 文件中查找对应的任务并执行。</p> <p><img src="https://images2.imgbox.com/26/22/AtaGR0Sh_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<h4><a id="_46"></a>默认任务：</h4> 
<p>如果觉得觉得在 <code>npx gulp</code> 命令还得跟着任务名比较麻烦，可以导出一个 default 任务。直接运行 <code>npx gulp</code> 命令将会自动执行该 default 任务。</p> 
<pre><code>// gulpfile.js
// 定义并导出默认任务
module.exports.default = callback =&gt; {
  console.log('default 任务被执行')
  callback()
}
</code></pre> 
<p><img src="https://images2.imgbox.com/4f/3d/U9olBHFU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Gulp__59"></a>Gulp 多个任务：</h2> 
<p>Gulp 提供了两个组合方法，它们都可以接收任意数量的任务函数或者已经组合的操作。</p> 
<ol><li><code>series()</code>：串行任务组合。多个任务会挨个执行，只有执行完前一个才能执行后一个。</li><li><code>parallel()</code>：并行任务组合。多个任务或同时执行，顺序无法确定。</li></ol> 
<pre><code>const {parallel} = require('gulp')

// 定义任务
const task1 = callback =&gt; {
  setTimeout(() =&gt; {
    console.log('task1 任务被执行')
    callback()
  }, 2000)
}
const task2 = callback =&gt; {
  setTimeout(() =&gt; {
    console.log('task2 任务被执行')
    callback()
  }, 1000)
}
const parallelTask = parallel(task1, task2)

// 导出任务
module.exports = {
  parallelTask
}
</code></pre> 
<p><img src="https://images2.imgbox.com/d5/c8/QIHXHMFO_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Gulp__88"></a>Gulp 读取和写入文件：</h2> 
<p>Gulp 暴露了 <code>src()</code> 和 <code>dest()</code> 方法用于处理计算机上存放的文件。</p> 
<ol><li> <p><code>src()</code>：接收一个 glob 字符串或由多个 glob 字符串组成的数组作为参数，将所有从文件系统中匹配到的文件读取到内存中，并产生一个 Stream 流，通过该 Stream 流进行处理。<code>src()</code> 产生的 Stream 流应当从任务函数中返回，发生异步任务完成的信号。<br> glob 的匹配规则：</p> 
  <ul><li><code>*</code>：在一个字符串中，匹配任意数量的字符。例如 <code>src/*.js</code>。</li><li><code>**</code>：在多个字符串匹配中，匹配任意数量的字符。通常用在匹配某个目录下的文件。例如 <code>src/**/*.js</code>。</li><li><code>!</code>：glob 匹配时是按照在数组中的位置依次进行匹配的，glob 数组中的取反 glob 必须跟在一个非取反 glob 后面，表示后面取反 glob 删除掉前面非取反 glob 匹配到的匹配项中的一部分。例如 <code>['src/**/*.js', 'src/vendor/']</code></li></ul> 
  <blockquote> 
   <p>glob 字符串或者 glob 数组至少需要匹配到一个匹配项，否则 <code>src</code> 将会报错。</p> 
  </blockquote> </li><li> <p><code>dest()</code>：接收一个输出目录作为参数，会产生一个 Node Stream 流，通过该 Stream 流将内容输出到文件中。</p> </li></ol> 
<p>Stream 流提供的主要的 API 就是 <code>pipe()</code> 方法，<code>pipe()</code> 方法接收一个转换流或者可写流。</p> 
<ol><li>新建 <code>src/index.js</code> 文件，并编写代码。<pre><code>const fn = () =&gt; {
  console.log('index')
}
fn()
</code></pre> </li><li>在 <code>gulpfile.js</code> 中编写 Gulp 读取和写入文件的方法。<pre><code>const {src, dest} = require('gulp')

const output = () =&gt; {
  // 读取 src 中的所有内容并输出到 dist 目录下
  return src('./src/*.js').pipe(dest('./dist'))
}

module.exports = {
  output
}
</code></pre> </li><li>运行 <code>npx gulp output</code> 命令，会发现，生成了 dist 目录，并复制了 src 目录下的文件及其内容。<br> <img src="https://images2.imgbox.com/4d/9a/UrsJ5unW_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="Gulp__123"></a>Gulp 中的插件：</h2> 
<p>以 <code>gulp-babel</code> 插件和 <code>gulp-terser</code> 插件为例，可以对 JavaScript 代码进行转换。</p> 
<ol><li>安装 <code>gulp-babel</code> ：<code>npm install gulp-babel -D</code>。</li><li>安装 Babel 的核心代码：<code>npm install @babel/core -D</code>。</li><li>安装 Babel 中的预设：<code>npm install @babel/preset-env -D</code>。</li><li>安装 <code>gulp-terser</code>：<code>npm install gulp-terser -D</code>。</li><li>在 <code>gulpfile.js</code> 文件中编写代码使用插件。<pre><code>const {src, dest} = require('gulp')
const babel = require('gulp-babel')
const terser = require('gulp-terser')

const output = () =&gt; {
  // 读取 src 中的所有内容
  return src('./src/*.js')
    // 使用 babel 进行转换
    .pipe(babel({
      presets: ['@babel/preset-env'],
    }))
    // 对其进行压缩和丑化
    .pipe(terser())
    // 输出到 dist 目录下
    .pipe(dest('./dist'))
}

module.exports = {
  output
}
</code></pre> </li><li>运行 <code>npx gulp output</code> 命令，会发现，生成了 dist 目录，复制了 src 目录下的文件及其内容，并对其进行了压缩和丑化。<br> <img src="https://images2.imgbox.com/99/37/57rxMuBJ_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="Gulp__154"></a>Gulp 的文件监听：</h2> 
<p>可以使用 Gulp 提供的 <code>watch()</code> 函数监听源文件的变化来执行指定的任务。</p> 
<pre><code>const {src, dest, watch} = require('gulp')

const output = () =&gt; {
  return src('./src/*.js').pipe(dest('./dist'))
}

// 监听 src 中所有内容的变化，只要发生变化就执行 output 任务
watch('./src/*.js', output)

module.exports = {
  output
}
</code></pre> 
<p><img src="https://images2.imgbox.com/45/e1/BeayGdk4_o.png" alt="请添加图片描述"></p> 
<h2><a id="Gulp__171"></a>Gulp 案例：</h2> 
<ol><li>新建 <code>src/index.html</code> 文件，并编写代码。<pre><code>// src/index.html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> </li><li>安装 <code>gulp-htmlmin</code> 插件处理 HTML 文件：<code>npm install gulp-htmlmin -D</code>。</li><li>新建 <code>src/css/index.less</code> 文件，并编写代码。<pre><code>@mainSize: 24px;
body{
  size: @mainSize;
  user-select: none;
}
</code></pre> </li><li>安装 <code>gulp-less</code> 插件处理 Less 文件：<code>npm install gulp-less -D</code>。 
  <blockquote> 
   <p>安装 <code>gulp-less</code> 插件会自动安装 Less。</p> 
  </blockquote> </li><li>安装 <code> gulp-postcss</code> 自动给 CSS 属性添加浏览器前缀：<code>npm install gulp-postcss -D</code>。</li><li>安装 PostCSS：<code>npm install postcss -D</code>。</li><li>安装 <code>postcss-preset-env</code> 插件：<code>npm install postcss-preset-env -D</code>。</li><li>新建 <code>src/js/index.js</code> 文件，并编写代码。<pre><code>// src/js/index.js
const fn = () =&gt; {
  console.log('index111')
}
fn()
</code></pre> </li><li>安装 <code>gulp-babel</code> 插件转换 JavaScript 文件：<code>npm install gulp-babel -D</code>。</li><li>安装 Babel 的核心代码：<code>npm install @babel/core -D</code>。</li><li>安装 Babel 中的预设：<code>npm install @babel/preset-env -D</code>。</li><li>安装 <code>gulp-terser</code> 插件压缩丑化 JavaScript 文件：<code>npm install gulp-terser -D</code>。</li><li>安装 <code>gulp-inject</code> 插件将打包后的 CSS、JavaScript 文件注入到 HTML 文件中：<code>npm install gulp-inject -D</code>。</li><li>在 <code>src/index.html </code> 中编写要注入文件的魔法注释。<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;!-- inject:css --&gt;
  &lt;!-- endinject --&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- inject:js --&gt;
  &lt;!-- endinject --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> </li><li>安装 <code>del</code> 插件删除指定的文件夹：<code>npm install del -D</code>。</li><li>安装 <code> browser-sync</code> 插件开启一个本地服务：<code>npm install browser-sync -D</code>。</li><li>新建 <code>gulpfile.js</code> 文件，并编写任务。<pre><code>const {src, dest, watch, series, parallel} = require('gulp')
const htmlMin = require('gulp-htmlmin')
const less  = require('gulp-less')
const postcss = require('gulp-postcss')
const postcssPresetEnv = require('postcss-preset-env')
const babel = require('gulp-babel')
const terser = require('gulp-terser')
const inject = require('gulp-inject')
const del = require('del')
const browseSync = require('browser-sync')

// 处理 HTML 文件的任务
const htmlTask = () =&gt; {
  return src('./src/*.html', {base: './src'})// base：基础文件夹，在输出文件夹下会根据此文件夹下的目录生成同样对应的目录
    // 对 HTML 文件进行压缩
    .pipe(htmlMin({collapseWhitespace: true}))
    .pipe(dest('./dist'))
}

// 处理 Less 文件的任务
const lessTask = () =&gt; {
  return src('./src/css/*.less', {base: './src'})
    // 对 HTML 文件进行压缩
    .pipe(less())
    .pipe(postcss([postcssPresetEnv()]))
    .pipe(dest('./dist'))
}

// 处理 JavaScript 文件的任务
const jsTask = () =&gt; {
  return src('./src/js/*.js', {base: './src'})
    // 对 JS 文件进行转换
    .pipe(babel({presets: ['@babel/preset-env']}))
    // 对 JS 文件进行压缩和丑化
    .pipe(terser({mangle: {toplevel: true}}))
    .pipe(dest('./dist'))
}

// 将打包后的 CSS、JavaScript 文件注入到 HTML 文件中
const injectHtml = () =&gt; {
  return src('./dist/*.html')
    .pipe(inject(src(['./dist/css/*.css', './dist/js/*.js']), {relative: true})) // relative 属性用来配置注入后使用相对路径
    .pipe(dest('./dist'))
}

// 删除指定的文件
const cleanTask = () =&gt; {
  return del(['dist'])
}

// 开启一个本地服务
const bs = browseSync.create() // 创建本地服务器对象
const serveTask = () =&gt; {
  // 监听 src 中的文件发生变化自动重新执行任务进行打包和注入
  watch('./src/*.html', series(htmlTask, injectHtml))
  watch('./src/css/*.less', series(lessTask, injectHtml))
  watch('./src/js/*.js', series(jsTask, injectHtml))

  bs.init({
    port: 8080,
    // 自动打开浏览器
    open: true,
    // dist 中的文件发生变化自动刷新浏览器
    files: './dist/*',
    server: {
      // 服务器服务于哪个文件夹
      baseDir: './dist',
    }
  })
}

// 生产阶段打包
const build = series(cleanTask, parallel(htmlTask, lessTask, jsTask), injectHtml)
// 开发阶段打包并开启本地服务
const serve = series(build, serveTask)

module.exports = {
  build,
  serve
}
</code></pre> </li><li>运行 <code>npx gulp serve</code>，会发现， HTML、CSS、JavaScript 文件都被打包到了 dist 文件夹下，并且 CSS、JavaScript 注入到了 HTML 文件中，而且开启了一个本地父亲。<br> <img src="https://images2.imgbox.com/aa/b3/uTZlCZBN_o.png" alt="请添加图片描述"></li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8928a1c483fd1370551563954cfdc22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Dart设计模式之建造者模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/448f9ae38193d8454f51e95c0de4157d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3 setup 中国省市区三级联动options最简洁写法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>