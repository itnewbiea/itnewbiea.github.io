<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java中常用的几个集合类 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java中常用的几个集合类" />
<meta property="og:description" content="//TODO //未完成 //不过先发了吧 //包含Collection（集合），List，Set，Map（图），以及其Iterator，Comparator ，Cloneable，还有常用的具体实现类 //List&lt;List&lt;String&gt;&gt;集合的嵌套使用 //1、是否允许空 //2、是否允许重复数据 //3、是否有序，有序的意思是读取数据的顺序和存放数据的顺序是否一致 //4、是否线程安全 JAVA SE 8官方文档 JAVA官方文档中集合类的关系 目录
概览
瞎说几句
对第一张图(集合类的关系)的解析
具体的几个集合类（List，Set，Map）
List ArrayList
LinkedList
Set
HashSet
TreeSet
Map
HashMap
TreeMap
概览 瞎说几句 JAVA中有许多的集合，常用的有List，Set，Queue，Map。
其中List，Set，Queue都是Collection（集合），其每个元素都是单独的一个对象，如List&lt;String&gt;，Set&lt;Integer&gt;等，String和Integer就是单独的一个对象。
而Map是一种图，其每个元素都是两个对象的一一对应，如Map&lt;Integer, String&gt;中的Integer是键 (key)，String是这个键所对应的值(value)。每个元素都是一对Integer和String
tip 1: List&lt;String&gt;中&lt;&gt;的内容表示其中元素的类型，是泛型的一种使用。
tip 2: Integer是一个对象(可从首字母大写的命名方式中看出)，可以粗略地将其视作int。
tip 3: 由于这些集合类的元素必须是对象或者由对象构成，所以不能直接使用int这种简单数据类型将Map定义为Map&lt;int, String&gt;，而应该使用Integer将Map定义为Map&lt;Integer, String&gt;。
tip 4: 不能直接使用简单数据类型的更深层次的原因在于：
集合类（比如Set）在进行各种 &#34;操作&#34; ( 如contains()) 时都会调用元素本身提供的 &#34;方法&#34; ( 如hashCode()和equals())，而不是由集合类自身去实现这些 &#34;方法&#34;。这就要求如果某人想要用这个集合执行某些 &#34;操作&#34;，那就必须在要加入集合的元素中实现相应的 &#34;方法&#34;。
由于简单数据类型 (如int)，只是单纯的一个数值，而无法在其中实现方法，所以应该使用实现了各种所需&#34;方法&#34;的类 (如Integer) 作为元素。
对第一张图(集合类的关系)的解析 从第二行 java.util.AbstractCollection&lt;E&gt; (implements java.util.Collection&lt;E&gt;) 看起" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6f6f314c3efe4d2acc3993a0833731d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-10T20:19:24+08:00" />
<meta property="article:modified_time" content="2019-06-10T20:19:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java中常用的几个集合类</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre class="has"><code class="language-java">//TODO

//未完成
//不过先发了吧

//包含Collection（集合），List，Set，Map（图），以及其Iterator，Comparator ，Cloneable，还有常用的具体实现类
//List&lt;List&lt;String&gt;&gt;集合的嵌套使用
//1、是否允许空
//2、是否允许重复数据
//3、是否有序，有序的意思是读取数据的顺序和存放数据的顺序是否一致
//4、是否线程安全</code></pre> 
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" rel="nofollow">JAVA SE 8官方文档</a> </p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/ef/1e/YaAsZLp5_o.png"> 
  <figcaption>
    JAVA官方文档中集合类的关系 
  </figcaption> 
 </figure> 
</div> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A6%82%E8%A7%88-toc" style="margin-left:0px;"><a href="#%E6%A6%82%E8%A7%88" rel="nofollow">概览</a></p> 
<p id="%E6%B3%9B%E6%B3%9B%E8%80%8C%E8%B0%88-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E6%B3%9B%E8%80%8C%E8%B0%88" rel="nofollow">瞎说几句</a></p> 
<p id="%E5%AF%B9%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE(%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB)%E7%9A%84%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E5%AF%B9%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%28%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%29%E7%9A%84%E8%A7%A3%E6%9E%90" rel="nofollow">对第一张图(集合类的关系)的解析</a></p> 
<p id="%E5%85%B7%E4%BD%93%E7%9A%84%E5%87%A0%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%B7%E4%BD%93%E7%9A%84%E5%87%A0%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB%C2%A0" rel="nofollow">具体的几个集合类（List，Set，Map）</a></p> 
<p id="List%C2%A0-toc" style="margin-left:40px;"><a href="#List%C2%A0" rel="nofollow">List </a></p> 
<p id="ArrayList-toc" style="margin-left:80px;"><a href="#ArrayList" rel="nofollow">ArrayList</a></p> 
<p id="LinkedList-toc" style="margin-left:80px;"><a href="#LinkedList" rel="nofollow">LinkedList</a></p> 
<p id="Set-toc" style="margin-left:40px;"><a href="#Set" rel="nofollow">Set</a></p> 
<p id="HashSet-toc" style="margin-left:80px;"><a href="#HashSet" rel="nofollow">HashSet</a></p> 
<p id="TreeSet-toc" style="margin-left:80px;"><a href="#TreeSet" rel="nofollow">TreeSet</a></p> 
<p id="Map-toc" style="margin-left:40px;"><a href="#Map" rel="nofollow">Map</a></p> 
<p id="HashMap-toc" style="margin-left:80px;"><a href="#HashMap" rel="nofollow">HashMap</a></p> 
<p id="TreeMap-toc" style="margin-left:80px;"><a href="#TreeMap" rel="nofollow">TreeMap</a></p> 
<hr> 
<h2 id="%E6%A6%82%E8%A7%88">概览</h2> 
<h3 id="%E6%B3%9B%E6%B3%9B%E8%80%8C%E8%B0%88">瞎说几句</h3> 
<p>JAVA中有许多的集合，常用的有List，Set，Queue，Map。</p> 
<p>其中List，Set，Queue都是Collection（集合），其每个元素都是<span style="color:#f33b45;">单独的</span>一个<span style="color:#f33b45;">对象</span>，如List&lt;String&gt;，Set&lt;Integer&gt;等，String和Integer就是单独的一个对象。</p> 
<p>而Map是一种图，其每个元素都是<span style="color:#f33b45;">两个对象</span>的<span style="color:#f33b45;">一一对应</span>，如Map&lt;Integer, String&gt;中的Integer是键 (key)，String是这个键所对应的值(value)。每个元素都是一对Integer和String</p> 
<blockquote> 
 <p>tip 1: List&lt;String&gt;中&lt;&gt;的内容表示其中元素的类型，是泛型的一种使用。</p> 
 <p>tip 2: Integer是一个对象(可从首字母大写的命名方式中看出)，可以粗略地将其视作int。</p> 
 <p>tip 3: 由于这些集合类的元素必须是对象或者由对象构成，所以不能直接使用int这种简单数据类型将Map定义为Map&lt;int, String&gt;，而应该使用Integer将Map定义为Map&lt;Integer, String&gt;。</p> 
 <p>tip 4: 不能直接使用简单数据类型的更深层次的原因在于：</p> 
 <p>         集合类（比如Set）在进行各种 "操作" ( 如contains()) 时都会调用元素本身提供的 "方法" ( 如hashCode()和equals())，而不是由集合类自身去实现这些 "方法"。这就要求如果某人想要用这个集合执行某些 "操作"，那就必须在要加入集合的元素中实现相应的 "方法"。</p> 
 <p>         由于简单数据类型 (如int)，只是单纯的一个数值，而无法在其中实现方法，所以应该使用实现了各种所需"方法"的类 (如Integer) 作为元素。</p> 
</blockquote> 
<p> </p> 
<h3 id="%E5%AF%B9%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE(%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB)%E7%9A%84%E8%A7%A3%E6%9E%90">对第一张图(集合类的关系)的解析</h3> 
<p>从第二行 java.util.<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" rel="nofollow">AbstractCollection</a>&lt;E&gt; (implements java.util.<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" rel="nofollow">Collection</a>&lt;E&gt;) 看起</p> 
<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" rel="nofollow">AbstractCollection</a>&lt;E&gt;是一个抽象类，实现了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" rel="nofollow">Collection</a>&lt;E&gt;接口，这个抽象类实现了接口中定义的部分方法，同时也有一些抽象方法交由<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" rel="nofollow">AbstractCollection</a>&lt;E&gt;的子类去实现。</li><li>然后看<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" rel="nofollow">AbstractCollection</a>&lt;E&gt;的子类，共有四个。分别是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html" rel="nofollow">AbstractList</a>&lt;E&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractQueue.html" rel="nofollow">AbstractQueue</a>&lt;E&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSet.html" rel="nofollow">AbstractSet</a>&lt;E&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html" rel="nofollow">ArrayDeque</a>&lt;E&gt;。</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html" rel="nofollow">AbstractList</a>&lt;E&gt;：抽象类，继承于<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" rel="nofollow">AbstractCollection</a>&lt;E&gt;，实现了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" rel="nofollow">List</a>&lt;E&gt;接口。其下有一些具体实现类如<a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" rel="nofollow">LinkedList</a>&lt;E&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" rel="nofollow">ArrayList</a>&lt;E&gt;等。</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractQueue.html" rel="nofollow">AbstractQueue</a>&lt;E&gt;：抽象类，继承于<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" rel="nofollow">AbstractCollection</a>&lt;E&gt;，实现了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" rel="nofollow">Queue</a>&lt;E&gt;接口。其下有一个具体实现类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html" rel="nofollow">PriorityQueue</a>&lt;E&gt;</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSet.html" rel="nofollow">AbstractSet</a>&lt;E&gt;：抽象类，继承于<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" rel="nofollow">AbstractCollection</a>&lt;E&gt;，实现了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" rel="nofollow">Set</a>&lt;E&gt;接口。其下有一些具体实现类如<a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html" rel="nofollow">EnumSet</a>&lt;E&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" rel="nofollow">HashSet</a>&lt;E&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html" rel="nofollow">LinkedHashSet</a>&lt;E&gt;（是HashSet&lt;E&gt;的子类），<a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html" rel="nofollow">TreeSet</a>&lt;E&gt;。</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html" rel="nofollow">ArrayDeque</a>&lt;E&gt;：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" rel="nofollow">AbstractCollection</a>&lt;E&gt;的一个具体实现类。是一个双端队列。内部使用数组来进行元素存储，可以高效地进行元素查找和尾部插入取出，可用作队列，双端队列和栈，性能极佳。</li></ul> 
<p> </p> 
<p>接着看 java.util.<a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html" rel="nofollow">AbstractMap</a>&lt;K,V&gt; (implements java.util.<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" rel="nofollow">Map</a>&lt;K,V&gt;) 这一行</p> 
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html" rel="nofollow">AbstractMap</a>&lt;K,V&gt;是一个抽象类，实现了java.util.<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" rel="nofollow">Map</a>&lt;K,V&gt;接口，具有图的功能（即key和value的一一对应）。其下有几个具体的实现类，分别是：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html" rel="nofollow">EnumMap</a>&lt;K,V&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" rel="nofollow">HashMap</a>&lt;K,V&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" rel="nofollow">LinkedHashMap</a>&lt;K,V&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/IdentityHashMap.html" rel="nofollow">IdentityHashMap</a>&lt;K,V&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html" rel="nofollow">TreeMap</a>&lt;K,V&gt;，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html" rel="nofollow">WeakHashMap</a>&lt;K,V&gt;</p> 
<p> </p> 
<h2 id="%E5%85%B7%E4%BD%93%E7%9A%84%E5%87%A0%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB%C2%A0">具体的几个集合类（List，Set，Map）</h2> 
<h3 id="List%C2%A0">List </h3> 
<p>List（列表），相当于数组。长度可变，元素存放有一定的顺序，下标从0开始。</p> 
<blockquote> 
 <p>tip</p> 
 <p>在JDK中，List作为接口，本身已经声明好了所有的方法（比如add(), contains()......），所以不管是选择ArrayList还是LinkedList，完成各种操作的时候依然是使用List中已经声明过的这一套方法，对使用者来说没有区别。</p> 
 <p>二者只是内部实现逻辑不同，所以在不同的应用场景下会有不同的效率。</p> 
</blockquote> 
<h4 id="ArrayList">ArrayList  </h4> 
<p>先回答四个问题：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:left;vertical-align:middle;">是否允许空元素（即null）</td><td style="text-align:center;vertical-align:middle;">是</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否允许重复数据</td><td style="text-align:center;vertical-align:middle;">是</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否有序</td><td style="text-align:center;vertical-align:middle;">是</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否线程安全</td><td style="text-align:center;vertical-align:middle;">否</td></tr></tbody></table> 
<pre class="has"><code class="language-java">//如何使用ArrayList创建一个List
//不指定存放的元素类型

//默认容量为10
List list = new ArrayList();

//容量为6
List list = new ArrayList(6);</code></pre> 
<p> Array即数组，顾名思义，ArrayList是用数组实现的一个List（列表）。它实现了List接口声明的的所有方法，而且允许加入包括null在内的所有元素。除了实现列表接口之外，这个类还提供了一些方法来操作内部用于存储列表的数组的大小。</p> 
<p>在每一个ArrayList实例中，都有专门保存容量的capacity属性，我在jdk1.8中找到了它的默认容量大小是</p> 
<p>DEFAULT_CAPACITY = 10，如下是jdk1.8中对DEFAULT_CAPACITY的定义</p> 
<pre class="has"><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{
    /*
        some code
    */

    private static final int DEFAULT_CAPACITY = 10;

    /*
        some code
    */
}</code></pre> 
<p>接下来讨论ArrayList中对capacity的控制</p> 
<p>举个栗子，ArrayList的add()方法，首先需要说明几个变量的含义，我从jdk1.8中找来了这些变量的声明语句包括其注释：</p> 
<pre class="has"><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    /*
        some code
    */

    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * Shared empty array instance used for empty instances.
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * Shared empty array instance used for default sized empty instances. We
     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
     * first element is added.
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * The array buffer into which the elements of the ArrayList are stored.
     * The capacity of the ArrayList is the length of this array buffer. Any
     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * will be expanded to DEFAULT_CAPACITY when the first element is added.
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * The size of the ArrayList (the number of elements it contains).
     *
     * @serial
     */
    private int size;

    /*
        some code
    */
}</code></pre> 
<p>其中各个变量的含义如下：</p> 
<blockquote> 
 <p>private static final int DEFAULT_CAPACITY = 10;</p> 
 <p>是默认的容量大小。当不指定容量大小的时候，就是用默认容量10</p> 
</blockquote> 
<blockquote> 
 <p>private static final Object[] EMPTY_ELEMENTDATA = {};</p> 
 <p>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</p> 
 <p>这两个作用类似，在创建一个新的ArrayList对象的时候引用。初始化ArrayList中的数组（即elementData变量）。</p> 
 <p>两个Object数组本身并没有区别，定义这样没区别的两个是为了区分使用的是哪种构造方法。在ArrayList()方法中用的是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，而在ArrayList(int initialCapacity)和ArrayList(Collection&lt;? extends E&gt; c)方法中用的是EMPTY_ELEMENTDATA。</p> 
</blockquote> 
<blockquote> 
 <p>transient Object[] elementData;</p> 
 <p>tip：这里有一个transient关键字，是关于序列化和反序列化的。简单说一下，序列化就是把对象转换成字节序列的形式，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可以用于网络传输。一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。序列化之后再反序列化就能得到原来的java对象。而transient修饰的数据将不会被自动序列化。但是，elementData会被writeObject方法手动序列化，这个不多说了。</p> 
 <p>这个变量就是ArrayList中的Array，ArrayList中的元素就是保存在这里。</p> 
</blockquote> 
<blockquote> 
 <p>private int size;</p> 
 <p>数组中元素的个数，当我们调用size()方法的时候返回的就是这个size。跟容量（capacity）是两个不同的概念，不要混淆。</p> 
</blockquote> 
<blockquote> 
 <p>protected transient int modCount = 0;</p> 
 <p>还有一个继承自其父类AbstractList的属性，modCount，表示发生结构化改变的次数。关于结构化改变（Structural modifications），AbstractList中是这样子解释的</p> 
 <p>The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.</p> 
 <p>意即当size改变了，这个modCount就会+1。</p> 
</blockquote> 
<p>测试代码是这样的：</p> 
<pre class="has"><code class="language-java">public class Test{
  public static void main(String[] args) {
    List&lt;String&gt; list = new ArrayList();
    for(int i = 0; i &lt;= 10; i++){
        //向list中依次添加“ii”。
        //例如，当i为0时，向list添加"00"；当i为1时，向list添加"11"。
        StringBuilder sb = new StringBuilder();
        sb.append(i)
          .append(i);
        list.add(sb.toString());
    }
  }
}</code></pre> 
<p>运行结果是ArrayList的size为11，容量为15</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="160" src="https://images2.imgbox.com/cd/f1/1xy4UDxx_o.png" width="860"> 
  <figcaption>
    for循环结束之后的ArrayList​​​​ 
  </figcaption> 
 </figure> 
</div> 
<p> </p> 
<p>下面是ArrayList在执行add()方法的时候所涉及的方法，我给放在一个页面里方便查找。</p> 
<pre class="has"><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{
    /*
        some code
    */

    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /*
        some code
    */

    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }

    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }
    
    /*
        some code
    */

    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    /*
        some code
    */

    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }

    /*
        some code
    */
}</code></pre> 
<p>当i = 0时，此时是第一次向list中添加元素，elementData容量不足，需要加大elementData的容量。初始的list是一个空的Object[]，依次调用add(), ensureCapacityInternal(), ensureExplicitCapacity(), grow(), calculateCapacity()方法。</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/79/5a/9sI1dHP6_o.png"></p> 
<p>在calculateCapacity()方法中，由于list是由ArrayList的无参构造方法构造的，所以elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的结果为true，执行语句：return Math.max(DEFAULT_CAPACITY, minCapacity);会得到DEFAULT_CAPACITY即10。</p> 
<p>返回的结果交给ensureExplicitCapacity()，modCount先自增一次，表示ist必然会做一次结构性修改。此时minCapacity - elementData.length &gt; 0结果为true（nimCapacity = 10, elementData.length = 0），执行grow(minCapacity);</p> 
<p>在grow()方法中，oldCapacity = 0，newCapacity = 0，minCapacity = 10。（oldCapacity &gt;&gt; 1相当于oldCapacity / 2）故会进入if (newCapacity - minCapacity &lt; 0)条件判断体中的语句，执行newCapacity = minCapacity，令newCapacity = 10，再执行Array.copyOf()方法，将elementData扩充到容量为10。</p> 
<p>之后，回到add()方法体中，elementData[size++] = e; 将elemtntData[0]的值赋为"00"，然后size再将赋值为1。</p> 
<p>可见，扩容发生在grow()方法中，而在ensureExplicitCapacity()方法中决定是否要扩容。</p> 
<p>i = 1~9的过程中，elementData的容量都没有发生改变。不做叙述。</p> 
<p>当i = 10时，容量为10的elementData已经被填充满了，需要再次扩容，经过之前提到的方法调用顺序，得到新的容量应该为15。进行扩容。</p> 
<p> </p> 
<h3 id="Set">Set</h3> 
<p>不包含重复元素的集合。更确切地说，是不同时包含使得e1.equals(e2)成立的e1和e2（因为e1与e2的equals()逻辑可以由使用者自己定义）。并且最多包含一个空元素。这个接口是数学集合的一个抽象建模。<br> 注意：如果可变的(mutable)对象用作集合元素，则必须非常小心。当一个对象是集合中的元素时，以影响equals()比较结果的方式更改对象的值，则无法预测集合的行为。有一个特殊情况是，不允许一个集合作为一个元素来包含它自己。所以还是尽量使用immutable的对象作为Set的元素。</p> 
<h4 id="HashSet">HashSet</h4> 
<p>先回答四个问题：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:left;vertical-align:middle;">是否允许空元素（即null）</td><td style="text-align:center;vertical-align:middle;">是</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否允许重复数据</td><td style="text-align:center;vertical-align:middle;">否</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否有序</td><td style="text-align:center;vertical-align:middle;">否</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否线程安全</td><td style="text-align:center;vertical-align:middle;">否</td></tr></tbody></table> 
<pre class="has"><code class="language-java">//如何使用HashSet创建一个Set
//不指定存放的元素类型

//默认容量为16
Set set = new HashSet();

//容量为6
Set set = new HashSet(6);</code></pre> 
<p>HashSet是基于HashMap实现的，所以需要先理解HashMap。但是我希望这篇文章是List，Set，Map的顺序，并且并不打算换序，所以还不理解HashMap的点<a href="#HashMap" rel="nofollow">这里</a>跳转到后面。</p> 
<p>在HashSet中，保存数据的变量名为map：</p> 
<pre class="has"><code class="language-java">private transient HashMap&lt;E,Object&gt; map; </code></pre> 
<p>一个HashMap，map的key是E类型，即HashSet中的元素；每个key的value是Object类型，这是HashSet类中定义的一个常量，名为PRESENT</p> 
<pre class="has"><code class="language-java">// Dummy value to associate with an Object in the backing Map
private static final Object PRESENT = new Object();</code></pre> 
<p>这只是为了使用HashMap而创建的一个Object对象，用来占掉value的位置，无其他意义 。</p> 
<p>HashSet不保证集合的迭代顺序；具体来说，它不保证顺序将随时间保持不变（除非你自己实现一个迭代器去保证迭代顺序）。它的一些基本操作（add()、remove()、contains()和size()）的时间复杂度是常量级的，前提是散列函数在存储桶中正确地分散元素（即要把hashCode()写好，让equals()方法判定为相等的两个对象的hashCode也相等，尽量让equals()方法判定为不等的两个对象的hashCode不等）。</p> 
<p>迭代此集合需要与哈希集实例的大小（即HashSet中元素的个数）加上支持哈希映射实例的“容量”（存储桶数）之和成比例的时间。因此，如果迭代性能很重要，那么不要将初始容量设置得太高（或者负载系数设置得太低）。</p> 
<h4 id="TreeSet">TreeSet</h4> 
<p>先回答四个问题：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:left;vertical-align:middle;">是否允许空元素（即null）</td><td style="text-align:center;vertical-align:middle;">是</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否允许重复数据</td><td style="text-align:center;vertical-align:middle;">否</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否有序</td><td style="text-align:center;vertical-align:middle;">是</td></tr><tr><td style="text-align:left;vertical-align:middle;">是否线程安全</td><td style="text-align:center;vertical-align:middle;">否</td></tr></tbody></table> 
<pre class="has"><code class="language-java">//如何使用TreeSet创建一个Set
//不指定存放的元素类型

//无参构造方法
Set set = new TreeSet();</code></pre> 
<p>同样是借助Map实现的，不过这次是TreeMap。还不理解TreeMap的点<a href="/#TreeMap" rel="nofollow">这里</a>跳转到后面。</p> 
<p>基于TreeMap的NavigableSet实现。元素是使用它们的自然顺序来排序的，或者通过在设置的创建时提供的比较器来排序的，这取决于使用的是哪个构造函数。</p> 
<p>此实现为基本操作（add()、remove()和contains()）提供了保证的log(n)时间成本。</p> 
<p>注意，如果要正确实现集合接口，集合维护的顺序（无论是否提供显式比较器）必须与equals一致。（请参阅Comparable或Comparator以获得与equals一致的精确定义。）这是因为集合接口是根据equals操作定义的，但TreeSet实例使用其CompareTo（或Compare）方法执行所有元素比较，因此从TreeSet的角度来看，该TreeSet认为相等的两个元素应该是equals()方法返回true的两个元素。这个TreeSet的行为是清晰的，即使其中元素的顺序与equals()方法不一致；它只是不遵守Set接口的总规约（即spec）。</p> 
<p>注意，这个实现是不同步的。如果多个线程同时访问一个树集，并且至少有一个线程修改了该集，则必须在外部对其进行同步。这通常是通过在自然封装集合的某个对象上进行同步来完成的。如果不存在此类对象，则应使用collections.synchronizedSortedSet方法“包装”集合。这最好在创建时完成，以防止意外的对集合的非同步访问：</p> 
<p>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));</p> 
<h3 id="Map">Map</h3> 
<p>将key映射到value的对象。Map不能包含重复的key；每个key最多可以映射到一个value</p> 
<h4 id="HashMap">HashMap</h4> 
<h4 id="TreeMap">TreeMap</h4> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/742bf7d77dde725b102fdd581c105bb9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flink  WaterMark的生成以及获取</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/23bebe6512e61c368c7df2522c6651a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【进阶 6-4 期】深入浅出防抖函数 debounce</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>