<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【SFND_Lidar_Obstacle_Detection】代码笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【SFND_Lidar_Obstacle_Detection】代码笔记" />
<meta property="og:description" content="源代码链接：
https://github.com/williamhyin/SFND_Lidar_Obstacle_Detection
激光雷达数据：
x，y，z，indensity（可用于评价物体的材料性质）
数据格式
PCD：点云数据(x, y, z, i)，点云数据的坐标系与汽车的本地坐标系相同，在这个坐标系中, x 轴指向汽车的前部, y 轴指向汽车的左侧. 此外, z轴指向车的上方.
PCL库
广泛应用于机器人技术领域, 用于处理点云数据, 网上有许多教程可供使用. PCL 中有许多内置的功能可以帮助检测障碍物. 本项目后面会使用 PCL内置的分割、提取和聚类函数. 你在这里可以找到PCL库的文档.
Steps For Obstacle Detection
Stream PCD
首先需要流式载入激光点云数据
（question1：如何在线使用？直接读取雷达数据，可以借鉴loam的写法？）
template&lt;typename PointT&gt; std::vector&lt;boost::filesystem::path&gt; ProcessPointClouds&lt;PointT&gt;::streamPcd(std::string dataPath) { std::vector&lt;boost::filesystem::path&gt;　paths(boost::filesystem::directory_iterator{dataPath},boost::filesystem::directory_iterator{}); // sort files in accending order so playback is chronological sort(paths.begin(), paths.end()); return paths; } // #################################################### ProcessPointClouds&lt;pcl::PointXYZI&gt;* pointProcessorI = new ProcessPointClouds&lt;pcl::PointXYZI&gt;(); std::vector&lt;boost::filesystem::path&gt; stream = pointProcessorI &gt;streamPcd(&#34;../src/sensors/data/pcd/data_1&#34;); auto streamIterator = stream." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/05270de6917883718f9feb18080fdc99/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-20T17:11:31+08:00" />
<meta property="article:modified_time" content="2023-01-20T17:11:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【SFND_Lidar_Obstacle_Detection】代码笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>源代码链接：</strong><br> https://github.com/williamhyin/SFND_Lidar_Obstacle_Detection<br> <strong>激光雷达数据：</strong><br> x，y，z，indensity（可用于评价物体的材料性质）<br> <strong>数据格式</strong><br> PCD：点云数据(x, y, z, i)，点云数据的坐标系与汽车的本地坐标系相同，在这个坐标系中, x 轴指向汽车的前部, y 轴指向汽车的左侧. 此外, z轴指向车的上方.<img src="https://images2.imgbox.com/b6/d8/eIdyIDto_o.png" alt="请添加图片描述"><br> <strong>PCL库</strong><br> 广泛应用于机器人技术领域, 用于处理点云数据, 网上有许多教程可供使用. PCL 中有许多内置的功能可以帮助检测障碍物. 本项目后面会使用 PCL内置的分割、提取和聚类函数. 你在这里可以找到<a href="https://link.zhihu.com/?target=http://pointclouds.org/" rel="nofollow">PCL库</a>的文档.<br> <strong>Steps For Obstacle Detection<br> Stream PCD</strong><br> 首先需要流式载入激光点云数据<br> <em><code>（question1：如何在线使用？直接读取雷达数据，可以借鉴loam的写法？）</code></em></p> 
<pre><code class="prism language-css"><span class="token selector">template&lt;typename PointT&gt;
std::vector&lt;boost::filesystem::path&gt; ProcessPointClouds&lt;PointT&gt;::streamPcd(std::string dataPath)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">std::vector&lt;boost::filesystem::path&gt;　		 	
	paths(boost::filesystem::directory_iterator</span><span class="token punctuation">{<!-- --></span>dataPath<span class="token punctuation">}</span><span class="token selector">,boost::filesystem::directory_iterator</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	// sort files in accending order so playback is chronological
	<span class="token function">sort</span><span class="token punctuation">(</span>paths.<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> paths.<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	return paths<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

// ####################################################

ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;* pointProcessorI = new ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;<span class="token property">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">filesystem</span><span class="token punctuation">:</span><span class="token punctuation">:</span>path&gt; stream = pointProcessorI &gt;<span class="token function">streamPcd</span><span class="token punctuation">(</span><span class="token string">"../src/sensors/data/pcd/data_1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
auto streamIterator = stream.<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr inputCloudI<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/31/2b/Q834Lr92_o.png" alt="真实PCD数据"><br> <strong>Point Processing</strong><br> 处理点云数据的第一步就是要创建一个processPointClouds的对象, 这个对象中包含所有处理激光点云数据的模块, 如过滤, 分割, 聚类, 载入、存储PCD数据. 我们需要为不同的点云数据创建一个通用模板: template. 在真实点云数据中, 点云的类型是pcl::PointXYZI. 创建pointProcessor可以建立在Stack上也可以建立在Heap上, 但是建议在Heap上, 毕竟使用指针更加轻便.</p> 
<pre><code class="prism language-css">// Build PointProcessor on the heap
ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt; *pointProcessorI = new ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
// Build PointProcessor on the stack
ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt; pointProcessorI<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="Filtering_41"></a><strong>Filtering</strong></h3> 
<p>点云数据一般有很高的分辨率和相当远的可视距离. 我们希望代码处理管道能够尽可能快地处理点云, 因此需要对点云进行过滤. 这里有两种方法可以用来做到这一点.<br> <strong>1.Voxel Grid</strong><br> <strong>体素网格过滤</strong>将创建一个立方体网格, 过滤点云的方法是每个体素立方体内只留下一个点, 因此立方体每一边的长度越大, 点云的分辨率就越低. 但是如果体素网格太大, 就会损失掉物体原本的特征. 具体实现可以查看PCL-voxel grid filtering的文档 .<br> <strong>2.Region of Interest</strong><br> <strong>定义感兴趣区域, 并删除感兴趣区域外的任何点</strong>：感兴趣区域的选择两侧需要尽量覆盖车道的宽度, 而前后的区域要保证你可以及时检测到前后车辆的移动. 具体实现可以查看PCL-region of interest的文档. 在最终结果中, 我们使用pcl CropBox 查找自身车辆车顶的点云数据索引, 然后将这些索引提供给 pcl ExtractIndices 对象删除, 因为这些对于我们分析点云数据没有用处.<img src="https://images2.imgbox.com/71/cf/fJUVlGqk_o.png" alt="感兴趣区域及体素网格过滤后的结果"><br> 以下是Filtering的代码实现：<br> filterRes是体素网格的大小, minPoint/maxPoint为感兴趣区域的最近点和最远点.<br> 我们首先执行VoxelGrid减少点云数量, 然后设置最近和最远点之间的感兴趣区域, 最后再从中删除车顶的点云.</p> 
<pre><code class="prism language-css"><span class="token selector">// To note, "using PtCdtr = typename pcl::PointCloud::Ptr;"       
template PtCdtr ProcessPointClouds::FilterCloud(PtCdtr cloud, float filterRes, Eigen::Vector4f minPoint,Eigen::Vector4f maxPoint)</span> <span class="token punctuation">{<!-- --></span>
// Time segmentation process
   auto startTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   // <span class="token property">TODO</span><span class="token punctuation">:</span><span class="token punctuation">:</span> Fill in the function to do voxel grid point reduction and region based filtering
   // Create the filtering <span class="token property">object</span><span class="token punctuation">:</span> downsample the dataset using a leaf size of .2m
   <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>VoxelGrid&lt;PointT&gt; vg<span class="token punctuation">;</span>
   PtCdtr&lt;PointT&gt; <span class="token function">cloudFiltered</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span>
   vg.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
   vg.<span class="token function">setLeafSize</span><span class="token punctuation">(</span>filterRes<span class="token punctuation">,</span> filterRes<span class="token punctuation">,</span> filterRes<span class="token punctuation">)</span><span class="token punctuation">;</span>
   vg.<span class="token function">filter</span><span class="token punctuation">(</span>*cloudFiltered<span class="token punctuation">)</span><span class="token punctuation">;</span>

   PtCdtr&lt;PointT&gt; <span class="token function">cloudRegion</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>CropBox&lt;PointT&gt; <span class="token function">region</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
   region.<span class="token function">setMin</span><span class="token punctuation">(</span>minPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
   region.<span class="token function">setMax</span><span class="token punctuation">(</span>maxPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
   region.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloudFiltered<span class="token punctuation">)</span><span class="token punctuation">;</span>
   region.<span class="token function">filter</span><span class="token punctuation">(</span>*cloudRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; indices<span class="token punctuation">;</span>
   <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>CropBox&lt;PointT&gt; <span class="token function">roof</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
   roof.<span class="token function">setMin</span><span class="token punctuation">(</span><span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Vector4f</span><span class="token punctuation">(</span>-1.5<span class="token punctuation">,</span> -1.7<span class="token punctuation">,</span> -1<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   roof.<span class="token function">setMax</span><span class="token punctuation">(</span><span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Vector4f</span><span class="token punctuation">(</span>2.6<span class="token punctuation">,</span> 1.7<span class="token punctuation">,</span> -0.4<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   roof.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloudRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>
   roof.<span class="token function">filter</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token selector">pcl::PointIndices::Ptr inliers</span><span class="token punctuation">{<!-- --></span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointIndices<span class="token punctuation">}</span><span class="token selector">;
   for (int point : indices)</span> <span class="token punctuation">{<!-- --></span>
       inliers-&gt;indices.push_<span class="token function">back</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>ExtractIndices&lt;PointT&gt; extract<span class="token punctuation">;</span>
   extract.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloudRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>
   extract.<span class="token function">setIndices</span><span class="token punctuation">(</span>inliers<span class="token punctuation">)</span><span class="token punctuation">;</span>
   extract.<span class="token function">setNegative</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
   extract.<span class="token function">filter</span><span class="token punctuation">(</span>*cloudRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>

   auto endTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   auto elapsedTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>duration_cast&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>milliseconds&gt;<span class="token punctuation">(</span>endTime - startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"filtering took "</span> &lt;&lt; elapsedTime.<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" milliseconds"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
//    return cloud<span class="token punctuation">;</span>        
   return cloudRegion<span class="token punctuation">;</span>    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>Segmentation</strong><br> Segmentation的任务是将属于道路的点和属于场景的点分开. 点云分割的具体细节推荐查看PCL的官网文档: Segmentation和Extracting indices .<img src="https://images2.imgbox.com/c8/0c/o5d2IYdr_o.png" alt="请添加图片描述"><br> <strong>PCL RANSAC Segmentaion</strong><br> 针对本项目, 我创建了两个函数SegmentPlane和SeparateClouds, 分别用来寻找点云中在道路平面的inliers(内联点)和提取点云中的outliers(物体).<br> 以下是主体代码:</p> 
<pre><code class="prism language-css"><span class="token selector">// To note, "using PtCdtr = typename pcl::PointCloud&lt;PointT&gt;::Ptr;"
template&lt;typename PointT&gt;
std::pair&lt;PtCdtr&lt;PointT&gt;, PtCdtr&lt;PointT&gt;&gt;
ProcessPointClouds&lt;PointT&gt;::SegmentPlane(PtCdtr&lt;PointT&gt; cloud, int maxIterations, float distanceThreshold)</span> <span class="token punctuation">{<!-- --></span>
    // Time segmentation process
    auto startTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//  <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PointIndices</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr inliers<span class="token punctuation">;</span> // Build on the stack
    <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PointIndices</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr <span class="token function">inliers</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointIndices<span class="token punctuation">)</span><span class="token punctuation">;</span> // Build on the heap
    // <span class="token property">TODO</span><span class="token punctuation">:</span><span class="token punctuation">:</span> Fill in this function to find inliers for the cloud.
    <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">ModelCoefficients</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr <span class="token function">coefficient</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>ModelCoefficients<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>SACSegmentation&lt;PointT&gt; seg<span class="token punctuation">;</span>

    seg.<span class="token function">setOptimizeCoefficients</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    seg.<span class="token function">setModelType</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>SACMODEL_PLANE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    seg.<span class="token function">setMethodType</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>SAC_RANSAC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    seg.<span class="token function">setMaxIterations</span><span class="token punctuation">(</span>maxIterations<span class="token punctuation">)</span><span class="token punctuation">;</span>
    seg.<span class="token function">setDistanceThreshold</span><span class="token punctuation">(</span>distanceThreshold<span class="token punctuation">)</span><span class="token punctuation">;</span>

    // Segment the largest planar component from the remaining cloud
    seg.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
    seg.<span class="token function">segment</span><span class="token punctuation">(</span>*inliers<span class="token punctuation">,</span> *coefficient<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token selector">if (inliers-&gt;indices.size() == 0)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cerr &lt;&lt; <span class="token string">"Could not estimate a planar model for the given dataset"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    auto endTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    auto elapsedTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>duration_cast&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>milliseconds&gt;<span class="token punctuation">(</span>endTime - startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"plane segmentation took "</span> &lt;&lt; elapsedTime.<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" milliseconds"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>

    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt; segResult = <span class="token function">SeparateClouds</span><span class="token punctuation">(</span>
            inliers<span class="token punctuation">,</span> cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
    return segResult<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">template&lt;typename PointT&gt;
std::pair&lt;PtCdtr&lt;PointT&gt;, PtCdtr&lt;PointT&gt;&gt;
ProcessPointClouds&lt;PointT&gt;::SeparateClouds(pcl::PointIndices::Ptr inliers, PtCdtr&lt;PointT&gt; cloud)</span> <span class="token punctuation">{<!-- --></span>
    // <span class="token property">TODO</span><span class="token punctuation">:</span> Create two new point clouds<span class="token punctuation">,</span> one cloud with obstacles and other with segmented plane
    PtCdtr&lt;PointT&gt; <span class="token function">obstCloud</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    PtCdtr&lt;PointT&gt; <span class="token function">planeCloud</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token selector">for (int index : inliers-&gt;indices)</span> <span class="token punctuation">{<!-- --></span>
        planeCloud-&gt;points.push_<span class="token function">back</span><span class="token punctuation">(</span>cloud-&gt;points[index]<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    // create extraction object
    <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>ExtractIndices&lt;PointT&gt; extract<span class="token punctuation">;</span>
    extract.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
    extract.<span class="token function">setIndices</span><span class="token punctuation">(</span>inliers<span class="token punctuation">)</span><span class="token punctuation">;</span>
    extract.<span class="token function">setNegative</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    extract.<span class="token function">filter</span><span class="token punctuation">(</span>*obstCloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt; <span class="token function">segResult</span><span class="token punctuation">(</span>obstCloud<span class="token punctuation">,</span>
                                                        planeCloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
//    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt; <span class="token function">segResult</span><span class="token punctuation">(</span>cloud<span class="token punctuation">,</span> cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
    return segResult<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在SegmentPlane函数中我们接受<strong>点云、最大迭代次数</strong>和<strong>距离容忍度</strong>作为参数, 使用std::pair对象来储存物体和道路路面的点云. SeparateClouds 函数提取点云中的非inliers点, 即obstacles点. 粒子分割是一个迭代的过程, 更多的迭代有机会返回更好的结果, 但同时需要更长的时间. 过大的距离容忍度会导致不是一个物体的点云被当成同一个物体, 而过小的距离容忍度会导致一个较长的物体无法被当成同一个物体, 比如卡车.<br> <strong>Manual RANSAC Segmentation</strong><br> 目前粒子分割主要使用RANSAC算法. RANSAC全称Random Sample Consensus, 即随机样本一致性, 是一种检测数据中异常值的方法. RANSAC通过多次迭代, 返回最佳的模型. 每次迭代随机选取数据的一个子集, 并生成一个模型拟合这个子样本, 例如一条直线或一个平面. 然后具有最多inliers(内联点)或最低噪声的拟合模型被作为最佳模型. 如其中一种RANSAC 算法使用数据的最小可能子集作为拟合对象. 对于直线来说是两点, 对于平面来说是三点. 然后通过迭代每个剩余点并计算其到模型的距离来计算 inliers 的个数. 与模型在一定距离内的点被计算为inliers. 具有最高 inliers 数的迭代模型就是最佳模型. 这是我们在这个项目中的实现版本. 也就是说RANSAC算法通过不断迭代, 找到拟合最多inliers的模型, 而outliers被排除在外. RANSAC 的另一种方法对模型点的某个百分比进行采样, 例如20% 的总点, 然后将其拟合成一条直线. 然后计算该直线的误差, 以误差最小的迭代法为最佳模型. 这种方法的优点在于不需要考虑每次迭代每一点. 以下是使用RANSAC算法拟合一条直线的示意图, 真实激光数据下是对一个平面进行拟合, 从而分离物体和路面. 以下将单独对RANSAC平面算法进行实现.<br> <img src="https://images2.imgbox.com/7e/43/v4IfRSzn_o.png" alt="请添加图片描述"><br> RANSAC的平面计算公式：<img src="https://images2.imgbox.com/8f/4a/Jc8F4y2k_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/93/f0/lybsug7s_o.png" alt="请添加图片描述">以下为平面RANSAC的主体代码</p> 
<pre><code class="prism language-css"><span class="token selector">template&lt;typename PointT&gt;
std::unordered_set&lt;int&gt; Ransac&lt;PointT&gt;::Ransac3d(PtCdtr&lt;PointT&gt; cloud)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_set&lt;int&gt; inliersResult<span class="token punctuation">;</span> <span class="token selector">// unordered_set element has been unique
    // For max iterations
    while (maxIterations--)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_set&lt;int&gt; inliers<span class="token punctuation">;</span>
        <span class="token selector">while (inliers.size() &lt; 3)</span> <span class="token punctuation">{<!-- --></span>
            inliers.<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>%num_points<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        // TO define plane<span class="token punctuation">,</span> need 3 points
        float x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> z1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> z2<span class="token punctuation">,</span> x3<span class="token punctuation">,</span> y3<span class="token punctuation">,</span> z3<span class="token punctuation">;</span>
        auto itr = inliers.<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        x1 = cloud-&gt;points[*itr].x<span class="token punctuation">;</span> 　
        y1 = cloud-&gt;points[*itr].y<span class="token punctuation">;</span>
        z1 = cloud-&gt;points[*itr].z<span class="token punctuation">;</span> 　
        itr++<span class="token punctuation">;</span>
        x2 = cloud-&gt;points[*itr].x<span class="token punctuation">;</span>
        y2 = cloud-&gt;points[*itr].y<span class="token punctuation">;</span>
        z2 = cloud-&gt;points[*itr].z<span class="token punctuation">;</span>
        itr++<span class="token punctuation">;</span>
        x3 = cloud-&gt;points[*itr].x<span class="token punctuation">;</span>
        y3 = cloud-&gt;points[*itr].y<span class="token punctuation">;</span>
        z3 = cloud-&gt;points[*itr].z<span class="token punctuation">;</span>
        // Calulate plane coefficient
        float a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> sqrt_abc<span class="token punctuation">;</span>
        a = <span class="token punctuation">(</span>y2 - y1<span class="token punctuation">)</span> * <span class="token punctuation">(</span>z3 - z1<span class="token punctuation">)</span> - <span class="token punctuation">(</span>z2 - z1<span class="token punctuation">)</span> * <span class="token punctuation">(</span>y3 - y1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        b = <span class="token punctuation">(</span>z2 - z1<span class="token punctuation">)</span> * <span class="token punctuation">(</span>x3 - x1<span class="token punctuation">)</span> - <span class="token punctuation">(</span>x2 - x1<span class="token punctuation">)</span> * <span class="token punctuation">(</span>z3 - z1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        c = <span class="token punctuation">(</span>x2 - x1<span class="token punctuation">)</span> * <span class="token punctuation">(</span>y3 - y1<span class="token punctuation">)</span> - <span class="token punctuation">(</span>y2 - y1<span class="token punctuation">)</span> * <span class="token punctuation">(</span>x3 - x1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        d = <span class="token function">-</span><span class="token punctuation">(</span>a * x1 + b * y1 + c * z1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sqrt_abc = <span class="token function">sqrt</span><span class="token punctuation">(</span>a * a + b * b + c * c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        // Check distance from point to plane
        for <span class="token punctuation">(</span>int ind = 0<span class="token punctuation">;</span> ind &lt; num_points<span class="token punctuation">;</span> <span class="token selector">ind++)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token selector">if (inliers.count(ind) &gt; 0)</span> <span class="token punctuation">{<!-- --></span> // that <span class="token property">means</span><span class="token punctuation">:</span> if the inlier in already exist<span class="token punctuation">,</span> we dont need do anymore
                continue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            PointT point = cloud-&gt;points[ind]<span class="token punctuation">;</span>
            float x = point.x<span class="token punctuation">;</span>
            float y = point.y<span class="token punctuation">;</span>
            float z = point.z<span class="token punctuation">;</span>
            float dist = <span class="token function">fabs</span><span class="token punctuation">(</span>a * x + b * y + c * z + d<span class="token punctuation">)</span> / sqrt_abc<span class="token punctuation">;</span> <span class="token selector">// calculate the distance between other points and plane

            if (dist &lt; distanceTol)</span> <span class="token punctuation">{<!-- --></span>
                inliers.<span class="token function">insert</span><span class="token punctuation">(</span>ind<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token selector">if (inliers.size() &gt; inliersResult.size())</span> <span class="token punctuation">{<!-- --></span>
                inliersResult = inliers<span class="token punctuation">;</span>

            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    return inliersResult<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在实际中PCL已经内置了RANSAC函数, 而且比我写的计算速度更快, 所以直接用内置的就行了<br> <strong>Clustering</strong><br> 聚类是指把不同物体的点云分别组合聚集起来, 从而能让你跟踪汽车, 行人等多个目标. 其中一种对点云数据进行分组和聚类的方法称为欧氏聚类.<br> 欧式聚类是指将距离紧密度高的点云聚合起来. 为了有效地进行最近邻搜索, 可以使用 KD-Tree 数据结构, 这种结构平均可以加快从 o (n)到 o (log (n))的查找时间. 这是因为Kd-Tree允许你更好地分割你的搜索空间. 通过将点分组到 KD-Tree 中的区域中, 您可以避免计算可能有数千个点的距离, 因为你知道它们不会被考虑在一个紧邻的区域中.<img src="https://images2.imgbox.com/b2/e7/7PsYsWbH_o.png" alt="欧氏聚类的结果"><br> <strong>PCL Euclidean clustering</strong><br> 首先我们使用PCL内置的欧式聚类函数. 点云聚类的具体细节推荐查看PCL的官网文档Euclidean Cluster.</p> 
<p>欧氏聚类对象 ec 具有距离容忍度. 在这个距离之内的任何点都将被组合在一起. 它还有用于表示集群的点数的 min 和 max 参数. 如果一个集群真的很小, 它可能只是噪音, min参数会限制使用这个集群. 而max参数允许我们更好地分解非常大的集群, 如果一个集群非常大, 可能只是许多其他集群重叠, 最大容差可以帮助我们更好地解决对象检测. 欧式聚类的最后一个参数是 Kd-Tree. Kd-Tree是使用输入点云创建和构建的, 这些输入云点是初始点云过滤分割后得到障碍物点云.</p> 
<p>以下是PCL内置欧式聚类函数的代码:</p> 
<pre><code class="prism language-css"><span class="token selector">// To note, "using PtCdtr = typename pcl::PointCloud&lt;PointT&gt;::Ptr;"
template&lt;typename PointT&gt;
std::vector&lt;PtCtr&lt;PointT&gt;&gt;
ProcessPointClouds&lt;PointT&gt;::Clustering(PtCdtr&lt;PointT&gt; cloud, float clusterTolerance, int minSize, int maxSize)</span> <span class="token punctuation">{<!-- --></span>

    // Time clustering process
    auto startTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;PtCdtr&lt;PointT&gt;&gt; clusters<span class="token punctuation">;</span>

    // <span class="token property">TODO</span><span class="token punctuation">:</span><span class="token punctuation">:</span> Fill in the function to perform euclidean clustering to group detected obstacles
    // Build Kd-Tree Object
    typename <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">search</span><span class="token punctuation">:</span><span class="token punctuation">:</span>KdTree&lt;PointT&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr <span class="token function">tree</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">search</span><span class="token punctuation">:</span><span class="token punctuation">:</span>KdTree&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span>
    // Input obstacle point cloud to create KD-tree
    tree-&gt;<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointIndices&gt; clusterIndices<span class="token punctuation">;</span> // this is point cloud indice type
    <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>EuclideanClusterExtraction&lt;PointT&gt; ec<span class="token punctuation">;</span> // clustering object
    ec.<span class="token function">setClusterTolerance</span><span class="token punctuation">(</span>clusterTolerance<span class="token punctuation">)</span><span class="token punctuation">;</span>//设置聚类点与点之间的距离阈值。
    ec.<span class="token function">setMinClusterSize</span><span class="token punctuation">(</span>minSize<span class="token punctuation">)</span><span class="token punctuation">;</span> //设置聚类点最少数目，排除噪音点的影响。
    ec.<span class="token function">setMaxClusterSize</span><span class="token punctuation">(</span>maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span> //设置聚类点最大数目。只有最小与最大数目之间的聚类才能够返回。
    ec.<span class="token function">setSearchMethod</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>//通过kd-tree的方式搜索。
    ec.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span> // feed point cloud
    ec.<span class="token function">extract</span><span class="token punctuation">(</span>clusterIndices<span class="token punctuation">)</span><span class="token punctuation">;</span>// <span class="token selector">get all clusters Indice 

    // For each cluster indice
    for (pcl::PointIndices getIndices: clusterIndices)</span> <span class="token punctuation">{<!-- --></span>
        PtCdtr&lt;PointT&gt; <span class="token function">cloudCluster</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token selector">// For each point indice in each cluster
        for (int index:getIndices.indices)</span> <span class="token punctuation">{<!-- --></span>
            cloudCluster-&gt;points.push_<span class="token function">back</span><span class="token punctuation">(</span>cloud-&gt;points[index]<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cloudCluster-&gt;width = cloudCluster-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cloudCluster-&gt;height = 1<span class="token punctuation">;</span>
        cloudCluster-&gt;is_dense = true<span class="token punctuation">;</span>
        clusters.push_<span class="token function">back</span><span class="token punctuation">(</span>cloudCluster<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    auto endTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    auto elapsedTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>duration_cast&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>milliseconds&gt;<span class="token punctuation">(</span>endTime - startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"clustering took "</span> &lt;&lt; elapsedTime.<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" milliseconds and found "</span> &lt;&lt; clusters.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>&lt;&lt; <span class="token string">" clusters"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>

    return clusters<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>Manual Euclidean clustering</strong><br> 除此之外我们也可以直接使用KD-Tree进行欧氏聚类.<br> 在此我们首先对KD-Tree的原理进行介绍. KD-Tree是一个数据结构, 由二进制树表示, 在不同维度之间对插入的点的数值进行交替比较, 通过分割区域来分割空间, 如在3D数据中, 需要交替在X,Y,Z不同轴上比较. 这样会使最近邻搜索可以快得多.<br> 首先我们在试着二维空间上建立KD-Tree, 并讲述欧氏聚类的整个在二维空间上的实现过程, 最终我们将扩展到三维空间.<br> 在KD-Tree中插入点(这是将点云输入到树中创建和构建KD-Tree的步骤)<br> 假设我们需要在KD-Tree中插入４个点(-6.3, 8.4), (-6.2, 7), (-5.2, 7.1), (-5.7, 6.3)<br> 首先我们得确定一个根点(-6.2, 7), 第0层为x轴, 需要插入的点为(-6.3, 8.4), (-5.2, 7.1), 因为-6.3&lt;-6.2,(-6.3, 8.4)划分为左子节点, 而-5.2&gt;-6.2, (-5.2, 7.1)划分为右子节点. (-5.7, 6.3)中x轴-5.7&gt;-6.2,所以放在(-5.2, 7.1)节点下, 接下来第1层使用y轴, 6.3&lt;7.1, 因此放在(-5.2, 7.1)的左子节点. 同理, 如果我们想插入第五个点(7.2, 6.1), 你可以交替对比x,y轴数值, (7.2&gt;-6.2)-&gt;(6.1&lt;7.1)-&gt;(7.2&gt;-5.7), 第五点应插入到(-5.7, 6.3)的右子节点C.<br> 下图是KD-Tree的结构.<br> <img src="https://images2.imgbox.com/97/f0/fPdCqia4_o.png" alt="请添加图片描述"><br> KD-Tree的目的是将空间分成不同的区域, 从而减少最紧邻搜索的时间.Kd-Tree是从BST(Binary search tree)发展而来，是一种高维索引树形数据结构，常用于大规模高维数据密集的查找比对的使用场景中，主要是最近邻查找(Nearest Neighbor)以及近似最近邻查找(Approximate Nearest Neighbor)。在计算机视觉(CV)中主要是图像检索和识别中的高维特征向量的查找和比对。<br> 在介绍Kd-Tree之前，首先介绍下它的父系结构——BST。二叉查找树，是一种具有如下性质的二叉树：<br> 1.若它的左子树不为空，则它的左子树节点上的值皆小于它的根节点。<br> 2.若它的右子树不为空，则它的右子树节点上的值皆大于它的根节点。<br> 3.它的左右子树也分别是二叉查找树。</p> 
<p><img src="https://images2.imgbox.com/e6/a0/o5s0hSnW_o.png" alt="请添加图片描述"><br> 它是通过递归的方式使用新插入点更新节点. 其基本思想是遍历树, 直到它到达的节点为 NULL, 在这种情况下, 将创建一个新节点并替换 NULL 节点. 我们可以使用一个双指针来分配一个节点, 也就是说可以从根开始传递一个指向节点的指针, 然后当你想要替换一个节点时, 您可以解引用双指针并将其分配给新创建的节点.<br> 1.在现有的数据中选定一个数据作为根节点的存储数值。（要求尽可能保证左右子树的集合的数量相等，优化查找速度）<br> 2.将其它数据按照左小右大的规则往深层递归，直到叶节点，然后开辟新的叶节点，并存储当前值。<br> 3.新的数据按照上一条进行存储。<br> 以下就是一种二叉查找树结构示例：<br> <img src="https://images2.imgbox.com/87/60/z4ZybOTH_o.jpg" alt="请添加图片描述"></p> 
<p>上面聚类算法中，用到了数据结构kd-tree，采用kd-tree主要是为了加快数据的搜索查找速度。关于kd-tree的基础原理讲解见这里。这里主要通过c++代码来直观的理解kd-tree如何实现二维数据的插入、搜索。<br> 如果是一维数据，我们可以用二叉查找树来进行存储，但是如果是多维的数据，用传统的二叉查找树就不能够满足我们的要求了，因此后来才发展出了满足多维数据的Kd-Tree数据结构。<br> Kd-tree的构造是在BST的基础上升级：<br> 1.选定数据X1的Y1维数值a1做为根节点比对值，对所有的数值在Y1维进行一层BST排列。相当于根据Y1维数值a1对数据集进行分割。<br> 2.选定数据X2的Y2维数值a2做为根节点比对值，对所有的数值在Y2维进行一层BST排列。也即将数据集在Y2维上又做了一层BST。<br> 下图是一个简单的示例：<img src="https://images2.imgbox.com/bf/9c/f58lIVQk_o.jpg" alt="请添加图片描述"><br> 那么问题是：</p> 
<pre><code>1.如何决定每次根据哪个维度对子空间进行划分呢？
直观的来看，我们一般会选择轮流来。先根据第一维，然后是第二维，然后第三……，那么到底轮流来行不行呢，这就要回到最开始我们为什么要研究选择哪一维进行划分的问题。我们研究Kd-Tree是为了优化在一堆数据中高频查找的速度，用树的形式，也是为了尽快的缩小检索范围，所以这个“比对维”就很关键，通常来说，更为分散的维度，我们就更容易的将其分开，是以这里我们通过求方差，用方差最大的维度来进行划分——这也就是最大方差法（max invarince）。
2.如何选定根节点的比对数值呢？
选择何值未比对值，目的也是为了要加快检索速度。一般来说我们在构造一个二叉树的时候，当然是希望它是一棵尽量平衡的树，即左右子树中的结点个数相差不大。所以这里用当前维度的中值是比较合理的。
</code></pre> 
<p>Kd-Tree和BST的区别：<br> BST的每个节点存储的是值，而Kd-Tree的根节点和中间节点存储的是对某个维度的划分信息，只有叶节点里才是存储的值。<strong>（此处存疑）</strong></p> 
<p>我们可以通过代码了解在KD-Tree中插入点的思路:</p> 
<pre><code class="prism language-css"><span class="token selector">struct Node</span> <span class="token punctuation">{<!-- --></span>
    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;float&gt; point<span class="token punctuation">;</span>
    int id<span class="token punctuation">;</span>
    Node *left<span class="token punctuation">;</span>
    Node *right<span class="token punctuation">;</span>

    <span class="token selector">Node(std::vector&lt;float&gt; arr, int setId)
            : point(arr), id(setId), left(NULL), right(NULL)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token selector">;

struct KdTree</span> <span class="token punctuation">{<!-- --></span>
    Node *root<span class="token punctuation">;</span>

    <span class="token selector">KdTree()
            : root(NULL)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token selector">// Kd-Tree insert
    void insertHelper(Node **node, uint depth, std::vector&lt;float&gt; point, int id)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token selector">// Tree is empty
        if (*node == NULL)</span> <span class="token punctuation">{<!-- --></span>
            *node = new <span class="token function">Node</span><span class="token punctuation">(</span>point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
            // calculate current dim <span class="token punctuation">(</span>1 means x axes<span class="token punctuation">,</span> 2means y axes<span class="token punctuation">)</span>
            uint cd = depth % 2<span class="token punctuation">;</span>
            <span class="token selector">if (point[cd] &lt; ((*node)-&gt;point[cd]))</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token punctuation">(</span>*node<span class="token punctuation">)</span>-&gt;left<span class="token punctuation">)</span><span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token punctuation">(</span>*node<span class="token punctuation">)</span>-&gt;right<span class="token punctuation">)</span><span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token selector">void insert(std::vector&lt;float&gt; point, int id)</span> <span class="token punctuation">{<!-- --></span>
        // <span class="token property">TODO</span><span class="token punctuation">:</span> Fill in this function to insert a new point into the tree
        // the function should create a new node and place correctly with in the root
        <span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;root<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token selector">// #############################################################################################################

// Kd-Tree search
    void searchHelper(std::vector&lt;float&gt; target, Node *node, int depth, float distanceTol, std::vector&lt;int&gt; &amp;ids)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token selector">if (node != NULL)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token selector">// Check whether the node inside box  or not, point[0] means x axes,　point[1]means y axes
            if ((node-&gt;point[0] &gt;= (target[0] - distanceTol) &amp;&amp; node-&gt;point[0] &lt;= (target[0] + distanceTol)) &amp;&amp;(node-&gt;point[1] &gt;= (target[1] - distanceTol) &amp;&amp; node-&gt;point[1] &lt;= (target[1] + distanceTol)))</span>
            <span class="token punctuation">{<!-- --></span>
                float distance = <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>node-&gt;point[0] - target[0]<span class="token punctuation">)</span> * <span class="token punctuation">(</span>node-&gt;point[0] - target[0]<span class="token punctuation">)</span> +<span class="token punctuation">(</span>node-&gt;point[1] - target[1]<span class="token punctuation">)</span> * <span class="token punctuation">(</span>node-&gt;point[1] - target[1]<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token selector">if (distance &lt;= distanceTol)</span>
                <span class="token punctuation">{<!-- --></span>
                    ids.push_<span class="token function">back</span><span class="token punctuation">(</span>node-&gt;id<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token selector">// check across boundary
            if ((target[depth % 2] - distanceTol) &lt; node-&gt;point[depth % 2])</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> node-&gt;left<span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token selector">if ((target[depth % 2] + distanceTol) &gt; node-&gt;point[depth % 2])</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> node-&gt;right<span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token selector">// return a list of point ids in the tree that are within distance of target
    std::vector&lt;int&gt; search(std::vector&lt;float&gt; target, float distanceTol)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; ids<span class="token punctuation">;</span>
        <span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> root<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
        return ids<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用KD-Tree分割好的空间进行搜索<br> <img src="https://images2.imgbox.com/75/36/IxCGcLO4_o.png" alt="请添加图片描述"><br> Kd-Tree分割区域并允许某些区域被完全排除, 从而加快了寻找近临点的进程<br> 在上图中我们有8个点, 常规的方法是遍历计算每一个点到根点的距离, 在距离容忍度内的点为近邻点. 现在我们已经在Kd-Tree中插入了所有点, 我们建立一个根点周围２ x distanceTol长度的方框, 如果当前节点位于此框中, 则可以直接计算距离, 并查看是否应该将点 id 添加到紧邻点id 列表中, 然后通过查看方框是否跨越节点分割区域, 确定是否需要比较下一个节点. 递归地执行此操作, 其优点是如果框区域不在某个分割区域内, 则完全跳过该区域. 如上如图所示, 左上, 左下和右边分割区域均不在方框区域内, 直接跳过这些区域, 只需要计算方框内的绿点到根点的距离.<br> 上面的代码块中第二部分为基于Kd-Tree的搜索代码.<br> 一旦实现了用于搜索邻近点的Kd-Tree 方法, 就不难实现基于邻近度对单个聚类指标进行分组的欧氏聚类方法.<br> 执行欧氏聚类需要迭代遍历云中的每个点, 并跟踪已经处理过的点. 对于每个点, 将其添加到一个集群(cluster)的点列表中, 然后使用前面的搜索函数获得该点附近所有点的列表. 对于距离很近但尚未处理的每个点, 将其添加到集群中, 并重复调用proximity的过程. 对于第一个集群, 递归停止后, 创建一个新的集群并移动点列表, 对于新的集群重复上面的过程. 一旦处理完所有的点, 就会找到一定数量的集群, 返回一个集群列表.</p> 
<p>以下是欧氏聚类的伪代码：</p> 
<pre><code class="prism language-css"><span class="token function">Proximity</span><span class="token punctuation">(</span>point<span class="token punctuation">,</span>cluster<span class="token punctuation">)</span><span class="token punctuation">:</span>
    mark point as processed
    add point to cluster
    nearby points = <span class="token function">tree</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span>
    Iterate through each nearby point
        If point has not been processed
            <span class="token function">Proximity</span><span class="token punctuation">(</span>cluster<span class="token punctuation">)</span>

<span class="token function">EuclideanCluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    list of clusters 
    Iterate through each point
        If point has not been processed
            Create cluster
            <span class="token function">Proximity</span><span class="token punctuation">(</span>point<span class="token punctuation">,</span> cluster<span class="token punctuation">)</span>
            cluster add clusters
    return clusters
</code></pre> 
<p>真实代码：</p> 
<pre><code class="prism language-css"><span class="token selector">void clusterHelper(int indice, const std::vector&lt;std::vector&lt;float&gt;&gt; &amp;points, std::vector&lt;int&gt; &amp;cluster,std::vector&lt;bool&gt; &amp;processed, KdTree *tree, float distanceTol)</span> <span class="token punctuation">{<!-- --></span>

    processed[indice] = true<span class="token punctuation">;</span>
    cluster.push_<span class="token function">back</span><span class="token punctuation">(</span>indice<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; nearest = tree-&gt;<span class="token function">search</span><span class="token punctuation">(</span>points[indice]<span class="token punctuation">,</span> distanceTol<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token selector">for (int id:nearest)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token selector">if (!processed[id])</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">clusterHelper</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> points<span class="token punctuation">,</span> cluster<span class="token punctuation">,</span> processed<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> distanceTol<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token selector">//参数里面的 tree为kd-tree,里面存储了点云points.
std::vector&lt;std::vector&lt;int&gt;&gt;euclideanCluster(const std::vector&lt;std::vector&lt;float&gt;&gt; &amp;points, KdTree *tree, float distanceTol)</span> <span class="token punctuation">{<!-- --></span>

    // <span class="token property">TODO</span><span class="token punctuation">:</span> Fill out this function to return list of indices for each cluster

    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt;&gt; clusters<span class="token punctuation">;</span>
    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;bool&gt; <span class="token function">processed</span><span class="token punctuation">(</span>points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>

    int i = 0<span class="token punctuation">;</span>
    <span class="token selector">while (i &lt; points.size())</span> <span class="token punctuation">{<!-- --></span>
        <span class="token selector">if (processed[i])</span> <span class="token punctuation">{<!-- --></span>
            i++<span class="token punctuation">;</span>
            continue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; cluster<span class="token punctuation">;</span>
        <span class="token function">clusterHelper</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> points<span class="token punctuation">,</span> cluster<span class="token punctuation">,</span> processed<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> distanceTol<span class="token punctuation">)</span><span class="token punctuation">;</span>
        clusters.push_<span class="token function">back</span><span class="token punctuation">(</span>cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>
        i++<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    return clusters<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上是在二维空间下欧式聚类的实现, 在真实激光点云数据中我们需要将欧式聚类扩展到三维空间. 具体代码实现可以参考我的GITHUB中的cluster3d/kdtree3d文件. 自己手写欧氏聚类能够增强对概念的理解, 但其实真正项目上直接用PCL内置欧氏聚类函数就行.<br> <strong>Bounding Boxes</strong><br> 在完成点云聚类之后, 我们最后一步需要为点云集添加边界框. 其他物体如车辆, 行人的边界框的体积空间内是禁止进入的, 以免产生碰撞.<br> <img src="https://images2.imgbox.com/db/87/gdBhldae_o.png" alt="请添加图片描述"><br> 以下是生成边界框的代码实现:</p> 
<pre><code class="prism language-css"><span class="token selector">template&lt;typename PointT&gt;
Box ProcessPointClouds&lt;PointT&gt;::BoundingBox(PtCdtr&lt;PointT&gt; cluster)</span> <span class="token punctuation">{<!-- --></span>

    // Find bounding box for one of the clusters
    PointT minPoint<span class="token punctuation">,</span> maxPoint<span class="token punctuation">;</span>
    <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getMinMax3D</span><span class="token punctuation">(</span>*cluster<span class="token punctuation">,</span> minPoint<span class="token punctuation">,</span> maxPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Box box<span class="token punctuation">;</span>
    box.x_min = minPoint.x<span class="token punctuation">;</span>
    box.y_min = minPoint.y<span class="token punctuation">;</span>
    box.z_min = minPoint.z<span class="token punctuation">;</span>
    box.x_max = maxPoint.x<span class="token punctuation">;</span>
    box.y_max = maxPoint.y<span class="token punctuation">;</span>
    box.z_max = maxPoint.z<span class="token punctuation">;</span>

    return box<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

// Calling Bouding box function and render box
//输出BoundingBox，在environment.cpp/ simpleHighway下做如下设置。
Box box = pointProcessor-&gt;<span class="token function">BoundingBox</span><span class="token punctuation">(</span>cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">renderBox</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span>box<span class="token punctuation">,</span>clusterId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>对于Bounding Boxes的生成可以使用PCA主成分分析法生成更小的方框, 实现更高的预测结果精准性. 具体PCL实现可以查看这个链接：PCL-PCA.<img src="https://images2.imgbox.com/8b/2a/62VEV8JV_o.png" alt="请添加图片描述"><br> <strong>SFND_Lidar_Obstacle_Detection代码笔记</strong><br> render.h 文件中实现和构建了用于渲染环境使用的函数和结构体</p> 
<pre><code class="prism language-css"><span class="token selector">// Functions and structs used to render the enviroment 用于环境渲染的函数和结构体
// such as cars and the highway
 
#ifndef RENDER_H
#define RENDER_H
//#endif
//以上三行的定义 是为了避免头文件的重复使用
 
#include &lt;pcl/visualization/pcl_visualizer.h&gt;
#include "box.h"
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
 
struct Color  //结构体中使用构造函数初始化列表</span>
<span class="token punctuation">{<!-- --></span>
	float r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	<span class="token selector">//Color(float setR, float setG, float setB): r(setR), g(setG), b(setB)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token selector">//构造函数初始化列表
	Color(float setR, float setG, float setB)    //含有参数的构造函数，以便创建Color变量时不向其传递参数时，提供默认值</span>
	<span class="token punctuation">{<!-- --></span>
		r = setR<span class="token punctuation">;</span>
		g = setG<span class="token punctuation">;</span>
		b = setB<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token selector">;
 
struct Vect3</span>
<span class="token punctuation">{<!-- --></span>
	double x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
	<span class="token selector">Vect3(double setX, double setY, double setZ): x(setX), y(setY), z(setZ)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token selector">//构造函数初始化列表,给x,y,z赋值
	Vect3 operator+(const Vect3&amp; vec)  //函数重载,将结构体传递给函数</span>
	<span class="token punctuation">{<!-- --></span>
		Vect3 <span class="token function">result</span><span class="token punctuation">(</span>x + vec.x<span class="token punctuation">,</span> y + vec.y<span class="token punctuation">,</span> z + vec.z<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token selector">;
 
enum CameraAngle //枚举类型</span>
<span class="token punctuation">{<!-- --></span>
	XY<span class="token punctuation">,</span> TopDown<span class="token punctuation">,</span> Side<span class="token punctuation">,</span> FPS
<span class="token punctuation">}</span><span class="token selector">;
 
struct Car</span>
<span class="token punctuation">{<!-- --></span>
	// 变量 position （位置）和 dimensions （尺寸大小）两个变量中的xyz的单位为米
	Vect3 position<span class="token punctuation">,</span> dimensions<span class="token punctuation">;</span>
 
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>string name<span class="token punctuation">;</span>
	Color color<span class="token punctuation">;</span>
 
	<span class="token selector">//构造函数初始化列表
	Car(Vect3 setPosition, Vect3 setDimensions, Color setColor, std::string setName)
		: position(setPosition), dimensions(setDimensions), color(setColor), name(setName)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
 
	<span class="token selector">void render(pcl::visualization::PCLVisualizer::Ptr&amp; viewer)</span>
	<span class="token punctuation">{<!-- --></span>
		// render bottom of car  车辆底部的渲染
		//viewer-&gt;addCube 向视图中添加一个立方体模型 
		<span class="token comment">/*
		bool pcl::visualization::PCLVisualizer::addCube  ( float  x_min,  
					float  x_max,  
					float  y_min,  
					float  y_max,  
					float  z_min,  
					float  z_max,  
					double  r = 1.0,  
					double  g = 1.0,  
					double  b = 1.0,  
					const std::string &amp;  id = "cube",  
					int  viewport = 0  
					) 
		*/</span>
		//render bottom of car渲染汽车底部
		viewer-&gt;<span class="token function">addCube</span><span class="token punctuation">(</span>position.x - dimensions.x / 2<span class="token punctuation">,</span> position.x + dimensions.x / 2<span class="token punctuation">,</span> position.y - dimensions.y / 2<span class="token punctuation">,</span> position.y + dimensions.y / 2<span class="token punctuation">,</span> position.z<span class="token punctuation">,</span> position.z + dimensions.z * 2 / 3<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// setShapeRenderingProperties 设置格子的属性
		viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION<span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION_SURFACE<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
		viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_COLOR<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
		viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_OPACITY<span class="token punctuation">,</span> 1.0<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// render top of car  车辆顶部的渲染
		viewer-&gt;<span class="token function">addCube</span><span class="token punctuation">(</span>position.x - dimensions.x / 4<span class="token punctuation">,</span> position.x + dimensions.x / 4<span class="token punctuation">,</span> position.y - dimensions.y / 2<span class="token punctuation">,</span> position.y + dimensions.y / 2<span class="token punctuation">,</span> position.z + dimensions.z * 2 / 3<span class="token punctuation">,</span> position.z + dimensions.z<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> name + <span class="token string">"Top"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION<span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION_SURFACE<span class="token punctuation">,</span> name + <span class="token string">"Top"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_COLOR<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> name + <span class="token string">"Top"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_OPACITY<span class="token punctuation">,</span> 1.0<span class="token punctuation">,</span> name + <span class="token string">"Top"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	<span class="token selector">// collision helper function  初步猜想：检测是否车辆与周围点碰撞
	bool inbetween(double point, double center, double range)</span>
	<span class="token punctuation">{<!-- --></span>
		return <span class="token punctuation">(</span>center - range &lt;= point<span class="token punctuation">)</span> &amp;&amp; <span class="token punctuation">(</span>center + range &gt;= point<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">bool checkCollision(Vect3 point)</span>
	<span class="token punctuation">{<!-- --></span>
		return <span class="token punctuation">(</span><span class="token function">inbetween</span><span class="token punctuation">(</span>point.x<span class="token punctuation">,</span> position.x<span class="token punctuation">,</span> dimensions.x / 2<span class="token punctuation">)</span> &amp;&amp; <span class="token function">inbetween</span><span class="token punctuation">(</span>point.y<span class="token punctuation">,</span> position.y<span class="token punctuation">,</span> dimensions.y / 2<span class="token punctuation">)</span> &amp;&amp; <span class="token function">inbetween</span><span class="token punctuation">(</span>point.z<span class="token punctuation">,</span> position.z + dimensions.z / 3<span class="token punctuation">,</span> dimensions.z / 3<span class="token punctuation">)</span><span class="token punctuation">)</span> ||
			<span class="token punctuation">(</span><span class="token function">inbetween</span><span class="token punctuation">(</span>point.x<span class="token punctuation">,</span> position.x<span class="token punctuation">,</span> dimensions.x / 4<span class="token punctuation">)</span> &amp;&amp; <span class="token function">inbetween</span><span class="token punctuation">(</span>point.y<span class="token punctuation">,</span> position.y<span class="token punctuation">,</span> dimensions.y / 2<span class="token punctuation">)</span> &amp;&amp; <span class="token function">inbetween</span><span class="token punctuation">(</span>point.z<span class="token punctuation">,</span> position.z + dimensions.z * 5 / 6<span class="token punctuation">,</span> dimensions.z / 6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
//函数实现功能待定
void <span class="token function">renderHighway</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PCLVisualizer</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">renderRays</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PCLVisualizer</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; viewer<span class="token punctuation">,</span> const Vect3&amp; origin<span class="token punctuation">,</span> const <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZ&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">clearRays</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PCLVisualizer</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">renderPointCloud</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PCLVisualizer</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; viewer<span class="token punctuation">,</span> const <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZ&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; cloud<span class="token punctuation">,</span> <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>string name<span class="token punctuation">,</span> Color color = <span class="token function">Color</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">renderPointCloud</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PCLVisualizer</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; viewer<span class="token punctuation">,</span> const <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; cloud<span class="token punctuation">,</span> <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>string name<span class="token punctuation">,</span> Color color = <span class="token function">Color</span><span class="token punctuation">(</span>-1<span class="token punctuation">,</span> -1<span class="token punctuation">,</span> -1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">renderBox</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PCLVisualizer</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; viewer<span class="token punctuation">,</span> Box box<span class="token punctuation">,</span> int id<span class="token punctuation">,</span> Color color = <span class="token function">Color</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> float opacity = 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">renderBox</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PCLVisualizer</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&amp; viewer<span class="token punctuation">,</span> BoxQ box<span class="token punctuation">,</span> int id<span class="token punctuation">,</span> Color color = <span class="token function">Color</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> float opacity = 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
#endif
</code></pre> 
<p><strong>render.cpp</strong></p> 
<pre><code class="prism language-css"><span class="token comment">/* \author Aaron Brown */</span>
<span class="token selector">// Functions and structs used to render the enviroment
// such as cars and the highway
 
#include "render.h"
 
void renderHighway(pcl::visualization::PCLVisualizer::Ptr&amp; viewer)</span>
<span class="token punctuation">{<!-- --></span>
 
	// units in meters
	double roadLength = 50.0<span class="token punctuation">;</span>
	double roadWidth = 12.0<span class="token punctuation">;</span>
	double roadHeight = 0.2<span class="token punctuation">;</span>
 
	viewer-&gt;<span class="token function">addCube</span><span class="token punctuation">(</span>-roadLength / 2<span class="token punctuation">,</span> roadLength / 2<span class="token punctuation">,</span> -roadWidth / 2<span class="token punctuation">,</span> roadWidth / 2<span class="token punctuation">,</span> -roadHeight<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> .2<span class="token punctuation">,</span> .2<span class="token punctuation">,</span> .2<span class="token punctuation">,</span> <span class="token string">"highwayPavement"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION<span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION_SURFACE<span class="token punctuation">,</span> <span class="token string">"highwayPavement"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_COLOR<span class="token punctuation">,</span> .2<span class="token punctuation">,</span> .2<span class="token punctuation">,</span> .2<span class="token punctuation">,</span> <span class="token string">"highwayPavement"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_OPACITY<span class="token punctuation">,</span> 1.0<span class="token punctuation">,</span> <span class="token string">"highwayPavement"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">addLine</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">PointXYZ</span><span class="token punctuation">(</span>-roadLength / 2<span class="token punctuation">,</span> -roadWidth / 6<span class="token punctuation">,</span> 0.01<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">PointXYZ</span><span class="token punctuation">(</span>roadLength / 2<span class="token punctuation">,</span> -roadWidth / 6<span class="token punctuation">,</span> 0.01<span class="token punctuation">)</span><span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> <span class="token string">"line1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">addLine</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">PointXYZ</span><span class="token punctuation">(</span>-roadLength / 2<span class="token punctuation">,</span> roadWidth / 6<span class="token punctuation">,</span> 0.01<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">PointXYZ</span><span class="token punctuation">(</span>roadLength / 2<span class="token punctuation">,</span> roadWidth / 6<span class="token punctuation">,</span> 0.01<span class="token punctuation">)</span><span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> <span class="token string">"line2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
int countRays = 0<span class="token punctuation">;</span>
<span class="token selector">void renderRays(pcl::visualization::PCLVisualizer::Ptr&amp; viewer, const Vect3&amp; origin, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&amp; cloud)</span>
<span class="token punctuation">{<!-- --></span>
 
	<span class="token selector">for (pcl::PointXYZ point : cloud-&gt;points)</span>
	<span class="token punctuation">{<!-- --></span>
		viewer-&gt;<span class="token function">addLine</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">PointXYZ</span><span class="token punctuation">(</span>origin.x<span class="token punctuation">,</span> origin.y<span class="token punctuation">,</span> origin.z<span class="token punctuation">)</span><span class="token punctuation">,</span> point<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> <span class="token string">"ray"</span> + <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>to_<span class="token function">string</span><span class="token punctuation">(</span>countRays<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		countRays++<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token selector">void clearRays(pcl::visualization::PCLVisualizer::Ptr&amp; viewer)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token selector">while (countRays)</span>
	<span class="token punctuation">{<!-- --></span>
		countRays--<span class="token punctuation">;</span>
		viewer-&gt;<span class="token function">removeShape</span><span class="token punctuation">(</span><span class="token string">"ray"</span> + <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>to_<span class="token function">string</span><span class="token punctuation">(</span>countRays<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token selector">//选取需要渲染的点云的种类 障碍物 地面 全部点云
void renderPointCloud(pcl::visualization::PCLVisualizer::Ptr&amp; viewer, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&amp; cloud, std::string name, Color color)</span>
<span class="token punctuation">{<!-- --></span>
 
	viewer-&gt;addPointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZ&gt;<span class="token punctuation">(</span>cloud<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setPointCloudRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_POINT_SIZE<span class="token punctuation">,</span> 4<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setPointCloudRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_COLOR<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">void renderPointCloud(pcl::visualization::PCLVisualizer::Ptr&amp; viewer, const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; cloud, std::string name, Color color)</span>
<span class="token punctuation">{<!-- --></span>
 
	<span class="token selector">if (color.r == -1)</span>
	<span class="token punctuation">{<!-- --></span>
		// Select color based off of cloud intensity
		<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloudColorHandlerGenericField&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt; intensity_<span class="token function">distribution</span><span class="token punctuation">(</span>cloud<span class="token punctuation">,</span> <span class="token string">"intensity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		viewer-&gt;addPointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">(</span>cloud<span class="token punctuation">,</span> intensity_distribution<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">else</span>
	<span class="token punctuation">{<!-- --></span>
		// Select color based off input value
		viewer-&gt;addPointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">(</span>cloud<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
		viewer-&gt;<span class="token function">setPointCloudRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_COLOR<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	viewer-&gt;<span class="token function">setPointCloudRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_POINT_SIZE<span class="token punctuation">,</span> 2<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
// Draw wire frame box with filled transparent color 
// <span class="token function">renderBox</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> box<span class="token punctuation">,</span> clusterId<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token selector">对每个点云画框
void renderBox(pcl::visualization::PCLVisualizer::Ptr&amp; viewer, Box box, int id, Color color, float opacity)</span>
<span class="token punctuation">{<!-- --></span>
	if <span class="token punctuation">(</span>opacity &gt; 1.0<span class="token punctuation">)</span>
		opacity = 1.0<span class="token punctuation">;</span>
	if <span class="token punctuation">(</span>opacity &lt; 0.0<span class="token punctuation">)</span>
		opacity = 0.0<span class="token punctuation">;</span>
 
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>string cube = <span class="token string">"box"</span> + <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>to_<span class="token function">string</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	//viewer-&gt;<span class="token function">addCube</span><span class="token punctuation">(</span>box.bboxTransform<span class="token punctuation">,</span> box.bboxQuaternion<span class="token punctuation">,</span> box.cube_length<span class="token punctuation">,</span> box.cube_width<span class="token punctuation">,</span> box.cube_height<span class="token punctuation">,</span> cube<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">addCube</span><span class="token punctuation">(</span>box.x_min<span class="token punctuation">,</span> box.x_max<span class="token punctuation">,</span> box.y_min<span class="token punctuation">,</span> box.y_max<span class="token punctuation">,</span> box.z_min<span class="token punctuation">,</span> box.z_max<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> cube<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION<span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION_WIREFRAME<span class="token punctuation">,</span> cube<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_COLOR<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> cube<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_OPACITY<span class="token punctuation">,</span> opacity<span class="token punctuation">,</span> cube<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>string cubeFill = <span class="token string">"boxFill"</span> + <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>to_<span class="token function">string</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	//viewer-&gt;<span class="token function">addCube</span><span class="token punctuation">(</span>box.bboxTransform<span class="token punctuation">,</span> box.bboxQuaternion<span class="token punctuation">,</span> box.cube_length<span class="token punctuation">,</span> box.cube_width<span class="token punctuation">,</span> box.cube_height<span class="token punctuation">,</span> cubeFill<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">addCube</span><span class="token punctuation">(</span>box.x_min<span class="token punctuation">,</span> box.x_max<span class="token punctuation">,</span> box.y_min<span class="token punctuation">,</span> box.y_max<span class="token punctuation">,</span> box.z_min<span class="token punctuation">,</span> box.z_max<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> cubeFill<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION<span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_REPRESENTATION_SURFACE<span class="token punctuation">,</span> cubeFill<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_COLOR<span class="token punctuation">,</span> color.r<span class="token punctuation">,</span> color.g<span class="token punctuation">,</span> color.b<span class="token punctuation">,</span> cubeFill<span class="token punctuation">)</span><span class="token punctuation">;</span>
	viewer-&gt;<span class="token function">setShapeRenderingProperties</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PCL_VISUALIZER_OPACITY<span class="token punctuation">,</span> opacity*0.3<span class="token punctuation">,</span> cubeFill<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>box.h</strong></p> 
<pre><code class="prism language-css"><span class="token selector">#ifndef BOX_H
#define BOX_H
 
#include &lt;Eigen/Geometry&gt; 
struct BoxQ</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Vector3f bboxTransform<span class="token punctuation">;</span>  // Vector3f 单精度的xyz坐标 与之对应的Vector3D双精度，更加精确，但运行速度也会慢
	//浮点型的四元数  Quaternion <span class="token punctuation">(</span>const Scalar &amp;w<span class="token punctuation">,</span> const Scalar &amp;x<span class="token punctuation">,</span> const Scalar &amp;y<span class="token punctuation">,</span> const Scalar &amp;z<span class="token punctuation">)</span>
	<span class="token comment">/*
	四元数都是由实部w 加上三个虚部 x、y、z 组成
	四元数一般可表示为a + bx+ cy + dz，其中a、b、c 、d是实数
	*/</span>
	<span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Quaternionf bboxQuaternion<span class="token punctuation">;</span>
	float cube_length<span class="token punctuation">;</span>
	float cube_width<span class="token punctuation">;</span>
	float cube_height<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token selector">;
struct Box</span>
<span class="token punctuation">{<!-- --></span>
	float x_min<span class="token punctuation">;</span>
	float y_min<span class="token punctuation">;</span>
	float z_min<span class="token punctuation">;</span>
	float x_max<span class="token punctuation">;</span>
	float y_max<span class="token punctuation">;</span>
	float z_max<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
#endif
</code></pre> 
<p><strong>kdtree3d.h</strong></p> 
<pre><code class="prism language-css"><span class="token selector">#ifndef PLAYBACK_KDTREE3D_H
#define PLAYBACK_KDTREE3D_H
 
#include &lt;pcl/impl/point_types.hpp&gt;
#include &lt;vector&gt;
 
struct Node</span> <span class="token punctuation">{<!-- --></span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI point<span class="token punctuation">;</span>
	int id<span class="token punctuation">;</span>
	Node *left<span class="token punctuation">;</span>
	Node *right<span class="token punctuation">;</span>
	<span class="token selector">Node(pcl::PointXYZI arr, int setId) : point(arr), id(setId), left(NULL), right(NULL)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token selector">;
 
struct KdTree</span> <span class="token punctuation">{<!-- --></span>
	Node *root<span class="token punctuation">;</span>
 
	<span class="token selector">KdTree() : root(NULL)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
 
	<span class="token selector">void insertHelper(Node **node, int depth, pcl::PointXYZI point, int id)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// Tree is empty
		if (*node == NULL)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">*node = new Node</span><span class="token punctuation">{<!-- --></span> point<span class="token punctuation">,</span> id <span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			// calculate current din
			int cd = depth % 3<span class="token punctuation">;</span>
			<span class="token selector">if (cd == 0)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">if (point.x &lt; (*node)-&gt;point.x)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token punctuation">(</span>*node<span class="token punctuation">)</span>-&gt;left<span class="token punctuation">)</span><span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token punctuation">(</span>*node<span class="token punctuation">)</span>-&gt;right<span class="token punctuation">)</span><span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token selector">else if (cd == 1)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">if (point.y &lt; (*node)-&gt;point.y)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token punctuation">(</span>*node<span class="token punctuation">)</span>-&gt;left<span class="token punctuation">)</span><span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token punctuation">(</span>*node<span class="token punctuation">)</span>-&gt;right<span class="token punctuation">)</span><span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">if (point.z &lt; (*node)-&gt;point.z)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token punctuation">(</span>*node<span class="token punctuation">)</span>-&gt;left<span class="token punctuation">)</span><span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token punctuation">(</span>*node<span class="token punctuation">)</span>-&gt;right<span class="token punctuation">)</span><span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
 
	<span class="token selector">void insert(pcl::PointXYZI point, int id)</span> <span class="token punctuation">{<!-- --></span>
		// the function should create a new node and place correctly with in the root
		<span class="token function">insertHelper</span><span class="token punctuation">(</span>&amp;root<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> point<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	<span class="token selector">void searchHelper(pcl::PointXYZI target, Node *node, int depth, float distanceTol, std::vector&lt;int&gt; &amp;ids)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (node != NULL)</span> <span class="token punctuation">{<!-- --></span>
			float delta_x = node-&gt;point.x - target.x<span class="token punctuation">;</span>
			float delta_y = node-&gt;point.y - target.y<span class="token punctuation">;</span>
			float delta_z = node-&gt;point.z - target.z<span class="token punctuation">;</span>
 
			<span class="token selector">if ((delta_x &gt;= -distanceTol &amp;&amp; delta_x &lt;= distanceTol) &amp;&amp;
				(delta_y &gt;= -distanceTol &amp;&amp; delta_y &lt;= distanceTol) &amp;&amp;
				(delta_z &gt;= -distanceTol &amp;&amp; delta_z &lt;= distanceTol))</span> <span class="token punctuation">{<!-- --></span>
				float distance = <span class="token function">sqrt</span><span class="token punctuation">(</span>delta_x * delta_x + delta_y * delta_y + delta_z * delta_z<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token selector">if (distance &lt;= distanceTol)</span> <span class="token punctuation">{<!-- --></span>
					ids.push_<span class="token function">back</span><span class="token punctuation">(</span>node-&gt;id<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token selector">// check across boundary
			if (depth % 3 == 0)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">if (delta_x &gt; -distanceTol)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> node-&gt;left<span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token selector">if (delta_x &lt; distanceTol)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> node-&gt;right<span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token selector">else if (depth % 3 == 1)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">if (delta_y &gt; -distanceTol)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> node-&gt;left<span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token selector">if (delta_y &lt; distanceTol)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> node-&gt;right<span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">if (delta_z &gt; -distanceTol)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> node-&gt;left<span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token selector">if (delta_z &lt; distanceTol)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> node-&gt;right<span class="token punctuation">,</span> depth + 1<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
 
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">// return a list of point ids in the tree that are within distance of target
	std::vector&lt;int&gt; search(pcl::PointXYZI target, float distanceTol)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; ids<span class="token punctuation">;</span>
		<span class="token function">searchHelper</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> root<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return ids<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
 
#endif //PLAYBACK_KDTREE3D_H
</code></pre> 
<p><strong>environment.cpp</strong></p> 
<pre><code class="prism language-css">#include <span class="token string">"lidar.h"</span>
#include <span class="token string">"render.h"</span>
#include <span class="token string">"processPointClouds.h"</span>
// using templates for processPointClouds so also include .cpp to help linker
#include <span class="token string">"processPointClouds.cpp"</span>
using namespace lidar_obstacle_detection<span class="token punctuation">;</span>
 
<span class="token selector">std::vector&lt;Car&gt; initHighway(bool renderScene, pcl::visualization::PCLVisualizer::Ptr &amp;viewer)</span> <span class="token punctuation">{<!-- --></span>
	Car <span class="token function">egoCar</span><span class="token punctuation">(</span><span class="token function">Vect3</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Vect3</span><span class="token punctuation">(</span>4<span class="token punctuation">,</span> 2<span class="token punctuation">,</span> 2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"egoCar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Car <span class="token function">car1</span><span class="token punctuation">(</span><span class="token function">Vect3</span><span class="token punctuation">(</span>15<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Vect3</span><span class="token punctuation">(</span>4<span class="token punctuation">,</span> 2<span class="token punctuation">,</span> 2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"car1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Car <span class="token function">car2</span><span class="token punctuation">(</span><span class="token function">Vect3</span><span class="token punctuation">(</span>8<span class="token punctuation">,</span> -4<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Vect3</span><span class="token punctuation">(</span>4<span class="token punctuation">,</span> 2<span class="token punctuation">,</span> 2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"car2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Car <span class="token function">car3</span><span class="token punctuation">(</span><span class="token function">Vect3</span><span class="token punctuation">(</span>-12<span class="token punctuation">,</span> 4<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Vect3</span><span class="token punctuation">(</span>4<span class="token punctuation">,</span> 2<span class="token punctuation">,</span> 2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"car3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;Car&gt; cars<span class="token punctuation">;</span>
	cars.push_<span class="token function">back</span><span class="token punctuation">(</span>egoCar<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cars.push_<span class="token function">back</span><span class="token punctuation">(</span>car1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cars.push_<span class="token function">back</span><span class="token punctuation">(</span>car2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cars.push_<span class="token function">back</span><span class="token punctuation">(</span>car3<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token selector">if (renderScene)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">renderHighway</span><span class="token punctuation">(</span>viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
		egoCar.<span class="token function">render</span><span class="token punctuation">(</span>viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
		car1.<span class="token function">render</span><span class="token punctuation">(</span>viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
		car2.<span class="token function">render</span><span class="token punctuation">(</span>viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
		car3.<span class="token function">render</span><span class="token punctuation">(</span>viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	return cars<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">// Test load pcd
//void cityBlock(pcl::visualization::PCLVisualizer::Ptr&amp; viewer)</span><span class="token punctuation">{<!-- --></span>
//    ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;pointProcessor<span class="token punctuation">;</span>
//    <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr inputCloud = pointProcessor.<span class="token function">loadPcd</span><span class="token punctuation">(</span><span class="token string">"../src/sensors/data/pcd/data_1/0000000000.pcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//    <span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span>inputCloud<span class="token punctuation">,</span><span class="token string">"cloud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//<span class="token punctuation">}</span>
 
<span class="token selector">// Initialize the simple Highway
 
// Test read Lidar data
void cityBlock(pcl::visualization::PCLVisualizer::Ptr &amp;viewer, ProcessPointClouds&lt;pcl::PointXYZI&gt; *pointProcessorI,const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr &amp;inputCloud)</span> 
<span class="token punctuation">{<!-- --></span>
	// 1、滤波  滤波后点云存入filteredCloud		ok
	float filterRes = 0.4<span class="token punctuation">;</span>
	<span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Vector4f <span class="token function">minpoint</span><span class="token punctuation">(</span>-10<span class="token punctuation">,</span> -6.5<span class="token punctuation">,</span> -2<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Vector4f <span class="token function">maxpoint</span><span class="token punctuation">(</span>30<span class="token punctuation">,</span> 6.5<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr filteredCloud = pointProcessorI-&gt;<span class="token function">FilterCloud</span><span class="token punctuation">(</span>inputCloud<span class="token punctuation">,</span> filterRes<span class="token punctuation">,</span> minpoint<span class="token punctuation">,</span>maxpoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	// 2、将滤波后的点云分割成地面和障碍物 结果存入segmentCloud中		ok
	int maxIterations = 40<span class="token punctuation">;</span>
	float distanceThreshold = 0.3<span class="token punctuation">;</span>
 
	//2.1 返回地面点云 和 障碍物点云 
	//segmentCloud.first<span class="token punctuation">,</span> <span class="token string">"obstCloud"</span> 
	//segmentCloud.second<span class="token punctuation">,</span> <span class="token string">"planeCloud"</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr<span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&gt; segmentCloud = pointProcessorI-&gt;<span class="token function">RansacSegmentPlane</span><span class="token punctuation">(</span>filteredCloud<span class="token punctuation">,</span> maxIterations<span class="token punctuation">,</span> distanceThreshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	//2.2 选取待渲染的点云的种类分别为 障碍物、地面、全部点云
	//<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> segmentCloud.first<span class="token punctuation">,</span> <span class="token string">"obstCloud"</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	//<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> segmentCloud.second<span class="token punctuation">,</span> <span class="token string">"planeCloud"</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span>inputCloud<span class="token punctuation">,</span><span class="token string">"inputCloud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	// 3、对去除地面后的障碍物点云进行聚类  segmentCloud.first<span class="token punctuation">,</span> <span class="token string">"obstCloud"</span> 
	float clusterTolerance = 0.5<span class="token punctuation">;</span>
	int minsize = 10<span class="token punctuation">;</span>
	int maxsize = 140<span class="token punctuation">;</span>
	//<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;PtCdtr&lt;PointT&gt;&gt; cloudClusters 返回了11类 每类中又包含了属于该类的点云
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&gt; cloudClusters = pointProcessorI-&gt;<span class="token function">EuclideanClustering</span><span class="token punctuation">(</span>segmentCloud.first<span class="token punctuation">,</span> clusterTolerance<span class="token punctuation">,</span> minsize<span class="token punctuation">,</span> maxsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
	int clusterId = 0<span class="token punctuation">;</span>
	<span class="token selector">std::vector&lt;Color&gt; colors =</span> <span class="token punctuation">{<!-- --></span> <span class="token function">Color</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token selector">;
	for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr cluster : cloudClusters)  //遍历每一类中的点</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"cluster size"</span><span class="token punctuation">;</span>
		pointProcessorI-&gt;<span class="token function">numPoints</span><span class="token punctuation">(</span>cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>  // cloud-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> cluster<span class="token punctuation">,</span> <span class="token string">"obstCLoud"</span> + <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>to_<span class="token function">string</span><span class="token punctuation">(</span>clusterId<span class="token punctuation">)</span><span class="token punctuation">,</span>colors[clusterId % colors.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>]<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// <span class="token property">Fourth</span><span class="token punctuation">:</span> Find bounding boxes for each obstacle cluster
		Box box = pointProcessorI-&gt;<span class="token function">BoundingBox</span><span class="token punctuation">(</span>cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>  //找到每块点云的xyz轴上的最值
		<span class="token function">renderBox</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> box<span class="token punctuation">,</span> clusterId<span class="token punctuation">)</span><span class="token punctuation">;</span> //根据最值画框
		++clusterId<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token selector">void simpleHighway(pcl::visualization::PCLVisualizer::Ptr &amp;viewer)</span> <span class="token punctuation">{<!-- --></span>
	// ----------------------------------------------------
	// -----Open 3D viewer and display simple highway -----
	// ----------------------------------------------------
	// RENDER OPTIONS
	bool renderScene = false<span class="token punctuation">;</span>
	bool render_obst = false<span class="token punctuation">;</span>
	bool render_plane = false<span class="token punctuation">;</span>
	bool render_cluster = true<span class="token punctuation">;</span>
	bool render_box = true<span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;Car&gt; cars = <span class="token function">initHighway</span><span class="token punctuation">(</span>renderScene<span class="token punctuation">,</span> viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	// <span class="token property">TODO</span><span class="token punctuation">:</span><span class="token punctuation">:</span> Create lidar sensor
	Lidar *lidar = new <span class="token function">Lidar</span><span class="token punctuation">(</span>cars<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZ&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr inputCloud = lidar-&gt;<span class="token function">scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	//    <span class="token function">renderRays</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span>lidar-&gt;position<span class="token punctuation">,</span>inputCloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> inputCloud<span class="token punctuation">,</span> <span class="token string">"inputCloud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	// <span class="token property">TODO</span><span class="token punctuation">:</span><span class="token punctuation">:</span> Create point processor
	ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZ&gt; pointProcessor<span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZ&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr<span class="token punctuation">,</span> <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZ&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&gt; segmentCloud = pointProcessor.<span class="token function">SegmentPlane</span><span class="token punctuation">(</span>
		inputCloud<span class="token punctuation">,</span> 100<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token selector">if (render_obst)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> segmentCloud.first<span class="token punctuation">,</span> <span class="token string">"obstCloud"</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">if (render_plane)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> segmentCloud.second<span class="token punctuation">,</span> <span class="token string">"planeCloud"</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZ&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr&gt; cloudClusters = pointProcessor.<span class="token function">Clustering</span><span class="token punctuation">(</span>segmentCloud.first<span class="token punctuation">,</span> 1.0<span class="token punctuation">,</span>3<span class="token punctuation">,</span> 30<span class="token punctuation">)</span><span class="token punctuation">;</span>
	int clusterId = 0<span class="token punctuation">;</span>
	<span class="token selector">std::vector&lt;Color&gt; colors =</span> <span class="token punctuation">{<!-- --></span> <span class="token function">Color</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Color</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token selector">;
	for (pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cluster : cloudClusters)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (render_cluster)</span> 
		<span class="token punctuation">{<!-- --></span>
			<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"cluster size:  "</span><span class="token punctuation">;</span>
			pointProcessor.<span class="token function">numPoints</span><span class="token punctuation">(</span>cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> cluster<span class="token punctuation">,</span> <span class="token string">"obstCLoud"</span> + <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>to_<span class="token function">string</span><span class="token punctuation">(</span>clusterId<span class="token punctuation">)</span><span class="token punctuation">,</span>
				colors[clusterId % colors.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>]<span class="token punctuation">)</span><span class="token punctuation">;</span>
			++clusterId<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">if (render_box)</span> 
		<span class="token punctuation">{<!-- --></span>
			Box box = pointProcessor.<span class="token function">BoundingBox</span><span class="token punctuation">(</span>cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">renderBox</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> box<span class="token punctuation">,</span> clusterId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		++clusterId<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">renderPointCloud</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> segmentCloud.second<span class="token punctuation">,</span> <span class="token string">"planeCloud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
 
 
<span class="token selector">//setAngle: SWITCH CAMERA ANGLE</span> <span class="token punctuation">{<!-- --></span>XY<span class="token punctuation">,</span> TopDown<span class="token punctuation">,</span> Side<span class="token punctuation">,</span> FPS<span class="token punctuation">}</span>
<span class="token selector">void initCamera(CameraAngle setAngle, pcl::visualization::PCLVisualizer::Ptr &amp;viewer)</span> <span class="token punctuation">{<!-- --></span>
 
	viewer-&gt;<span class="token function">setBackgroundColor</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
	// set camera position and angle
	viewer-&gt;<span class="token function">initCameraParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	// distance away in meters
	int distance = 16<span class="token punctuation">;</span>
	<span class="token selector">switch (setAngle)</span> <span class="token punctuation">{<!-- --></span>
	case <span class="token property">XY</span><span class="token punctuation">:</span>
		viewer-&gt;<span class="token function">setCameraPosition</span><span class="token punctuation">(</span>-distance<span class="token punctuation">,</span> -distance<span class="token punctuation">,</span> distance<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
		break<span class="token punctuation">;</span>
	case <span class="token property">TopDown</span><span class="token punctuation">:</span>
		viewer-&gt;<span class="token function">setCameraPosition</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> distance<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		break<span class="token punctuation">;</span>
	case <span class="token property">Side</span><span class="token punctuation">:</span>
		viewer-&gt;<span class="token function">setCameraPosition</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> -distance<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		break<span class="token punctuation">;</span>
	case <span class="token property">FPS</span><span class="token punctuation">:</span>
		viewer-&gt;<span class="token function">setCameraPosition</span><span class="token punctuation">(</span>-10<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	if <span class="token punctuation">(</span>setAngle != FPS<span class="token punctuation">)</span>
		viewer-&gt;<span class="token function">addCoordinateSystem</span><span class="token punctuation">(</span>1.0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">// char* argv[] means array of char pointers, whereas char** argv means pointer to a char pointer.
int main(int argc, char **argv)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"starting enviroment"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
 
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PCLVisualizer</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr <span class="token function">viewer</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">visualization</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">PCLVisualizer</span><span class="token punctuation">(</span><span class="token string">"3D Viewer"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	CameraAngle setAngle = XY<span class="token punctuation">;</span>
	<span class="token function">initCamera</span><span class="token punctuation">(</span>setAngle<span class="token punctuation">,</span> viewer<span class="token punctuation">)</span><span class="token punctuation">;</span> //设置不同的观察视角
 
	// For simpleHighway function
	//    <span class="token function">simpleHighway</span><span class="token punctuation">(</span>viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	//    <span class="token function">cityBlock</span><span class="token punctuation">(</span>viewer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token selector">//    while (!viewer-&gt;wasStopped ())
	//</span>    <span class="token punctuation">{<!-- --></span>
	//     viewer-&gt;spinOnce <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	//    <span class="token punctuation">}</span>
	//
	//  Stream cityBlock function
	//  ProcessPointClouds 类
	ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt; *pointProcessorI = new ProcessPointClouds&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;<span class="token property">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">filesystem</span><span class="token punctuation">:</span><span class="token punctuation">:</span>path&gt; stream = pointProcessorI-&gt;<span class="token function">streamPcd</span><span class="token punctuation">(</span><span class="token string">"D:\\SFND_Lidar_Obstacle_Detection\\SFND_Lidar_Obstacle_Detection\\data\\pcd\\data_2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	auto streamIterator = stream.<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//从文件中的第一个点云文件开始 
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointXYZI&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr inputCloudI<span class="token punctuation">;</span> <span class="token selector">//创建点云对象
 
	while (!viewer-&gt;wasStopped())</span> <span class="token punctuation">{<!-- --></span>
		// Clear viewer
		viewer-&gt;<span class="token function">removeAllPointClouds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		viewer-&gt;<span class="token function">removeAllShapes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//inputCloudI 为每一帧点云数据
		inputCloudI = pointProcessorI-&gt;<span class="token function">loadPcd</span><span class="token punctuation">(</span><span class="token punctuation">(</span>*streamIterator<span class="token punctuation">)</span>.<span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //对每一个点云进行处理
		<span class="token function">cityBlock</span><span class="token punctuation">(</span>viewer<span class="token punctuation">,</span> pointProcessorI<span class="token punctuation">,</span> inputCloudI<span class="token punctuation">)</span><span class="token punctuation">;</span>//主要处理程序 参数为视窗、点云处理类、点云
		streamIterator++<span class="token punctuation">;</span>
		<span class="token selector">if (streamIterator == stream.end())</span> <span class="token punctuation">{<!-- --></span>
			streamIterator = stream.<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		viewer-&gt;<span class="token function">spinOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>重点部分<br> processPointClouds.h</strong></p> 
<pre><code class="prism language-css"><span class="token selector">// PCL lib Functions for processing point clouds 
 
#ifndef PROCESSPOINTCLOUDS_H_
#define PROCESSPOINTCLOUDS_H_
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/common/common.h&gt;
#include &lt;pcl/filters/extract_indices.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;pcl/filters/crop_box.h&gt;
#include &lt;pcl/kdtree/kdtree.h&gt;
#include &lt;pcl/segmentation/sac_segmentation.h&gt;
#include &lt;pcl/segmentation/extract_clusters.h&gt;
#include &lt;pcl/common/transforms.h&gt;
#include &lt;unordered_set&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;chrono&gt;
#include "box.h"
#include "ransac3d.cpp"
#include "cluster3d.cpp"
 
//命名空间的使用：避免了名字相同函数和变量的冲突
namespace lidar_obstacle_detection</span> <span class="token punctuation">{<!-- --></span>
 
	// shorthand for point cloud pointer
	template&lt;typename PointT&gt;
	using PtCdtr = typename <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr<span class="token punctuation">;</span>
 
	<span class="token selector">template&lt;typename PointT&gt;
	class ProcessPointClouds</span> <span class="token punctuation">{<!-- --></span>
 
	<span class="token property">public</span><span class="token punctuation">:</span>
		//constructor
		<span class="token function">ProcessPointClouds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//deconstructor
		~<span class="token function">ProcessPointClouds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		void <span class="token function">numPoints</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		//1、点云滤波		ok
		PtCdtr&lt;PointT&gt; <span class="token function">FilterCloud</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">,</span> float filterRes<span class="token punctuation">,</span> <span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Vector4f minPoint<span class="token punctuation">,</span> <span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Vector4f maxPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		//——————————————————————————对点云库中的模型分割，将点云保存为两个文件  主程序中依然好像没有用到		ok
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt; <span class="token function">SeparateClouds</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PointIndices</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr inliers<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		//2、地面与障碍物的分割 两块点云分别保存在in_plane（平面外的点）<span class="token punctuation">,</span> out_plane（平面内的点）中	ok
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt; PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt; &gt; <span class="token function">RansacSegmentPlane</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">,</span> int maxIterations<span class="token punctuation">,</span> float distanceTol<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		// ——————————————————————————此处使用了pcl点云库中的模型分割 程序中貌似没有用到			ok
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt; <span class="token function">SegmentPlane</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">,</span> int maxIterations<span class="token punctuation">,</span> float distanceTol<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		//3、重写欧式聚类算法聚类障碍物点云		ok
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;PtCdtr&lt;PointT&gt;&gt; <span class="token function">EuclideanClustering</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">,</span> float clusterTolerance<span class="token punctuation">,</span> int minSize<span class="token punctuation">,</span> int maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		//——————————————————————————此处使用了点云库中的欧氏距离分割模型  程序中没有用到			ok
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;PtCdtr&lt;PointT&gt;&gt; <span class="token function">Clustering</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">,</span> float clusterTolerance<span class="token punctuation">,</span> int minSize<span class="token punctuation">,</span> int maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		Box <span class="token function">BoundingBox</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		void <span class="token function">savePcd</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">,</span> <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>string file<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		PtCdtr&lt;PointT&gt; <span class="token function">loadPcd</span><span class="token punctuation">(</span><span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>string file<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;<span class="token property">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">filesystem</span><span class="token punctuation">:</span><span class="token punctuation">:</span>path&gt; <span class="token function">streamPcd</span><span class="token punctuation">(</span><span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>string dataPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
#endif <span class="token comment">/* PROCESSPOINTCLOUDS_H_ */</span>
</code></pre> 
<p><strong>processPointClouds.cpp</strong></p> 
<pre><code class="prism language-css">// PCL lib Functions for processing point clouds 
 
#include <span class="token string">"processPointClouds.h"</span>
 
using namespace lidar_obstacle_detection<span class="token punctuation">;</span>
 
<span class="token selector">//constructor: 构造函数
template&lt;typename PointT&gt;
ProcessPointClouds&lt;PointT&gt;::ProcessPointClouds()</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
 
<span class="token selector">//de-constructor: 析构函数
template&lt;typename PointT&gt;
ProcessPointClouds&lt;PointT&gt;::~ProcessPointClouds()</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
 
<span class="token selector">template&lt;typename PointT&gt;
void ProcessPointClouds&lt;PointT&gt;::numPoints(PtCdtr&lt;PointT&gt; cloud)</span> <span class="token punctuation">{<!-- --></span> <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; cloud-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 
<span class="token selector">//2、随机采样一致性分割   地面与障碍物的分割 两块点云分别保存在in_plane（平面外的点）, out_plane（平面内的点）中	ok
template&lt;typename PointT&gt;
std::pair&lt;PtCdtr&lt;PointT&gt;, PtCdtr&lt;PointT&gt;&gt;  //pair可以将两种不同类型的值合为一个值
ProcessPointClouds&lt;PointT&gt;::RansacSegmentPlane(PtCdtr&lt;PointT&gt; cloud, int maxIterations, float distanceTol)</span> 
<span class="token punctuation">{<!-- --></span>
	// Count time
	auto startTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	int num_points = cloud-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Ransac&lt;PointT&gt; <span class="token function">RansacSeg</span><span class="token punctuation">(</span>maxIterations<span class="token punctuation">,</span> distanceTol<span class="token punctuation">,</span> num_points<span class="token punctuation">)</span><span class="token punctuation">;</span>  //使用Ransac&lt;PointT&gt;类创建了一个对象RansacSeg
 
	// Get inliers from RANSAC implementation
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_set&lt;int&gt; inliersResult = RansacSeg.<span class="token function">Ransac3d</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span> //使用RansacSeg对象实现函数
 
	auto endTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	auto elapsedTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>duration_cast&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>milliseconds&gt;<span class="token punctuation">(</span>endTime - startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"plane ransac-segment took "</span> &lt;&lt; elapsedTime.<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" milliseconds"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
 
	//此处表示不清  这里out_plane表示平面中的点  in_plane表示平面外中的点
	PtCdtr&lt;PointT&gt; out_<span class="token function">plane</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	PtCdtr&lt;PointT&gt; in_<span class="token function">plane</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; num_points<span class="token punctuation">;</span> <span class="token selector">i++)</span> 
	<span class="token punctuation">{<!-- --></span>
		PointT pt = cloud-&gt;points[i]<span class="token punctuation">;</span>
		<span class="token selector">if (inliersResult.count(i))</span> 
		<span class="token punctuation">{<!-- --></span>
			out_plane-&gt;points.push_<span class="token function">back</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">else</span> 
		<span class="token punctuation">{<!-- --></span>
			in_plane-&gt;points.push_<span class="token function">back</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	return <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt;<span class="token punctuation">(</span>in_plane<span class="token punctuation">,</span> out_plane<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">//1、点云滤波		ok
template&lt;typename PointT&gt;
PtCdtr&lt;PointT&gt; ProcessPointClouds&lt;PointT&gt;::FilterCloud(PtCdtr&lt;PointT&gt; cloud, float filterRes, Eigen::Vector4f minPoint,Eigen::Vector4f maxPoint)</span> 
<span class="token punctuation">{<!-- --></span>
	// Time segmentation process
	auto startTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	//使用体素滤波下采样
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>VoxelGrid&lt;PointT&gt; vg<span class="token punctuation">;</span>   //滤波对象
	PtCdtr&lt;PointT&gt; <span class="token function">cloudFiltered</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span> //创建保存体素滤波后的点对象
	vg.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	vg.<span class="token function">setLeafSize</span><span class="token punctuation">(</span>filterRes<span class="token punctuation">,</span> filterRes<span class="token punctuation">,</span> filterRes<span class="token punctuation">)</span><span class="token punctuation">;</span>
	vg.<span class="token function">filter</span><span class="token punctuation">(</span>*cloudFiltered<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	//过滤掉在用户给定立方体内的点云数据
	//理解：将自身车辆作为坐标轴的中心点，然后在身边自身为中心 ，圈出范围，成为每一次运动时候的感兴趣区域，也就是只关心区域内点的聚类等后续操作
	PtCdtr&lt;PointT&gt; <span class="token function">cloudRegion</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>CropBox&lt;PointT&gt; <span class="token function">region</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
	region.<span class="token function">setMin</span><span class="token punctuation">(</span>minPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
	region.<span class="token function">setMax</span><span class="token punctuation">(</span>maxPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
	region.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloudFiltered<span class="token punctuation">)</span><span class="token punctuation">;</span>
	region.<span class="token function">filter</span><span class="token punctuation">(</span>*cloudRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	//提取车身周围范围内的所有的点，并将提取到的所有点保存在indices中
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; indices<span class="token punctuation">;</span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>CropBox&lt;PointT&gt; <span class="token function">roof</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
	roof.<span class="token function">setMin</span><span class="token punctuation">(</span><span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Vector4f</span><span class="token punctuation">(</span>-1.5<span class="token punctuation">,</span> -1.7<span class="token punctuation">,</span> -1<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	roof.<span class="token function">setMax</span><span class="token punctuation">(</span><span class="token property">Eigen</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Vector4f</span><span class="token punctuation">(</span>2.6<span class="token punctuation">,</span> 1.7<span class="token punctuation">,</span> -0.4<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	roof.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloudRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>
	roof.<span class="token function">filter</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token selector">pcl::PointIndices::Ptr inliers</span><span class="token punctuation">{<!-- --></span> new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointIndices <span class="token punctuation">}</span><span class="token selector">; //创建一个内点对象，将提取到车身周围点，放到内点对象中
	for (int point : indices)</span> 
	<span class="token punctuation">{<!-- --></span>
		inliers-&gt;indices.push_<span class="token function">back</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>ExtractIndices&lt;PointT&gt; extract<span class="token punctuation">;</span>
	extract.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloudRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>
	extract.<span class="token function">setIndices</span><span class="token punctuation">(</span>inliers<span class="token punctuation">)</span><span class="token punctuation">;</span>
	extract.<span class="token function">setNegative</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>  //false 提取内点也就是提取车身周围的几个点，， true提取出了车身周围的点
	extract.<span class="token function">filter</span><span class="token punctuation">(</span>*cloudRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	auto endTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	auto elapsedTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>duration_cast&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>milliseconds&gt;<span class="token punctuation">(</span>endTime - startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"filtering took "</span> &lt;&lt; elapsedTime.<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" milliseconds"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
 
	return cloudRegion<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">//——————————————————————————对点云库中的模型分割，将点云保存为两个文件  主程序中依然好像没有用到  ok
template&lt;typename PointT&gt;
std::pair&lt;PtCdtr&lt;PointT&gt;, PtCdtr&lt;PointT&gt;&gt;
ProcessPointClouds&lt;PointT&gt;::SeparateClouds(pcl::PointIndices::Ptr inliers, PtCdtr&lt;PointT&gt; cloud)</span> 
<span class="token punctuation">{<!-- --></span>
	//创建了两个点云块，一个存放障碍物，一个存放地面 
	PtCdtr&lt;PointT&gt; <span class="token function">obstCloud</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	PtCdtr&lt;PointT&gt; <span class="token function">planeCloud</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token selector">for (int index : inliers-&gt;indices)</span> 
	<span class="token punctuation">{<!-- --></span>
		planeCloud-&gt;points.push_<span class="token function">back</span><span class="token punctuation">(</span>cloud-&gt;points[index]<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	// create extraction object
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>ExtractIndices&lt;PointT&gt; extract<span class="token punctuation">;</span>
	extract.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	extract.<span class="token function">setIndices</span><span class="token punctuation">(</span>inliers<span class="token punctuation">)</span><span class="token punctuation">;</span>
	extract.<span class="token function">setNegative</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
	extract.<span class="token function">filter</span><span class="token punctuation">(</span>*obstCloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt; <span class="token function">segResult</span><span class="token punctuation">(</span>obstCloud<span class="token punctuation">,</span>
		planeCloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	//    <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt; <span class="token function">segResult</span><span class="token punctuation">(</span>cloud<span class="token punctuation">,</span> cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	return segResult<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">//——————————————————————————此处使用了pcl点云库中的模型分割 程序中貌似没有用到   ok
template&lt;typename PointT&gt;
std::pair&lt;PtCdtr&lt;PointT&gt;, PtCdtr&lt;PointT&gt;&gt;
ProcessPointClouds&lt;PointT&gt;::SegmentPlane(PtCdtr&lt;PointT&gt; cloud, int maxIterations, float distanceThreshold)</span> <span class="token punctuation">{<!-- --></span>
	// Time segmentation process
	auto startTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	//	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PointIndices</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr inliers<span class="token punctuation">;</span> // Build on the stack
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">PointIndices</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr <span class="token function">inliers</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointIndices<span class="token punctuation">)</span><span class="token punctuation">;</span> // Build on the heap
														   // <span class="token property">TODO</span><span class="token punctuation">:</span><span class="token punctuation">:</span> Fill in this function to find inliers for the cloud.
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">ModelCoefficients</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr <span class="token function">coefficient</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>ModelCoefficients<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>SACSegmentation&lt;PointT&gt; seg<span class="token punctuation">;</span>
	seg.<span class="token function">setOptimizeCoefficients</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
	seg.<span class="token function">setModelType</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>SACMODEL_PLANE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	seg.<span class="token function">setMethodType</span><span class="token punctuation">(</span><span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>SAC_RANSAC<span class="token punctuation">)</span><span class="token punctuation">;</span>
	seg.<span class="token function">setMaxIterations</span><span class="token punctuation">(</span>maxIterations<span class="token punctuation">)</span><span class="token punctuation">;</span>
	seg.<span class="token function">setDistanceThreshold</span><span class="token punctuation">(</span>distanceThreshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	// Segment the largest planar component from the remaining cloud
	seg.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	seg.<span class="token function">segment</span><span class="token punctuation">(</span>*inliers<span class="token punctuation">,</span> *coefficient<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token selector">if (inliers-&gt;indices.size() == 0)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cerr &lt;&lt; <span class="token string">"Could not estimate a planar model for the given dataset"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	auto endTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	auto elapsedTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>duration_cast&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>milliseconds&gt;<span class="token punctuation">(</span>endTime - startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"plane segmentation took "</span> &lt;&lt; elapsedTime.<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" milliseconds"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>pair&lt;PtCdtr&lt;PointT&gt;<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt;&gt; segResult = <span class="token function">SeparateClouds</span><span class="token punctuation">(</span>inliers<span class="token punctuation">,</span> cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	return segResult<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">//——————————————————————————此处使用了点云库中的欧氏距离分割模型  程序中没有用到   ok
template&lt;typename PointT&gt;
std::vector&lt;PtCdtr&lt;PointT&gt;&gt;
ProcessPointClouds&lt;PointT&gt;::Clustering(PtCdtr&lt;PointT&gt; cloud, float clusterTolerance, int minSize, int maxSize)</span> <span class="token punctuation">{<!-- --></span>
 
	// Time clustering process
	auto startTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;PtCdtr&lt;PointT&gt;&gt; clusters<span class="token punctuation">;</span>  //保存分割后的所有类 每一类为一个点云
	// 欧式聚类对检测到的障碍物进行分组
 
	typename <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">search</span><span class="token punctuation">:</span><span class="token punctuation">:</span>KdTree&lt;PointT&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr <span class="token function">tree</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">search</span><span class="token punctuation">:</span><span class="token punctuation">:</span>KdTree&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span> //对cloud点云创建kdtree
	tree-&gt;<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointIndices&gt; clusterIndices<span class="token punctuation">;</span> // 创建索引类型对象
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>EuclideanClusterExtraction&lt;PointT&gt; ec<span class="token punctuation">;</span> // 欧式聚类对象
	ec.<span class="token function">setClusterTolerance</span><span class="token punctuation">(</span>clusterTolerance<span class="token punctuation">)</span><span class="token punctuation">;</span>  //设置近邻搜索半径
	ec.<span class="token function">setMinClusterSize</span><span class="token punctuation">(</span>minSize<span class="token punctuation">)</span><span class="token punctuation">;</span> //设置一个类需要的最小的点数
	ec.<span class="token function">setMaxClusterSize</span><span class="token punctuation">(</span>maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span> //设置一个类需要的最大的点数
	ec.<span class="token function">setSearchMethod</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> //设置搜索方法
	ec.<span class="token function">setInputCloud</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span> // feed point cloud
	ec.<span class="token function">extract</span><span class="token punctuation">(</span>clusterIndices<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token selector">// 得到所有类别的索引 clusterIndices  
 
	// 将得到的所有类的索引分别在点云中找到，即每一个索引形成了一个类
	for (pcl::PointIndices getIndices : clusterIndices)</span> 
	<span class="token punctuation">{<!-- --></span>
		PtCdtr&lt;PointT&gt; <span class="token function">cloudCluster</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// For each point indice in each cluster
		for (int index : getIndices.indices)</span> 
		<span class="token punctuation">{<!-- --></span>
			cloudCluster-&gt;points.push_<span class="token function">back</span><span class="token punctuation">(</span>cloud-&gt;points[index]<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cloudCluster-&gt;width = cloudCluster-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cloudCluster-&gt;height = 1<span class="token punctuation">;</span>
		cloudCluster-&gt;is_dense = true<span class="token punctuation">;</span>
		clusters.push_<span class="token function">back</span><span class="token punctuation">(</span>cloudCluster<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	auto endTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	auto elapsedTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>duration_cast&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>milliseconds&gt;<span class="token punctuation">(</span>endTime - startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"clustering took "</span> &lt;&lt; elapsedTime.<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" milliseconds and found "</span> &lt;&lt; clusters.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		&lt;&lt; <span class="token string">" clusters"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	return clusters<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">//3、欧式聚类函数：		对分割掉地面点云的障碍物点云进行欧式聚类 传入 segmentCloud.first, "obstCloud"  0.5 10 140 
template&lt;typename PointT&gt;
std::vector&lt;PtCdtr&lt;PointT&gt;&gt;
ProcessPointClouds&lt;PointT&gt;::EuclideanClustering(PtCdtr&lt;PointT&gt; cloud, float clusterTolerance, int minSize,int maxSize)</span> 
<span class="token punctuation">{<!-- --></span>
	// Time clustering process
	auto startTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	// 创建聚类对象  实例化ClusterPts类 创建对象clusterPoints
	ClusterPts&lt;PointT&gt; <span class="token function">clusterPoints</span><span class="token punctuation">(</span>cloud-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> clusterTolerance<span class="token punctuation">,</span> minSize<span class="token punctuation">,</span> maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	//对象调用欧式聚类函数  clusters 保存了类数的所有点云
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;PtCdtr&lt;PointT&gt;&gt; clusters = clusterPoints.<span class="token function">EuclidCluster</span><span class="token punctuation">(</span>cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	auto endTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">steady_clock</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	auto elapsedTime = <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>duration_cast&lt;<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">chrono</span><span class="token punctuation">:</span><span class="token punctuation">:</span>milliseconds&gt;<span class="token punctuation">(</span>endTime - startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cout &lt;&lt; <span class="token string">"KDTree clustering took "</span> &lt;&lt; elapsedTime.<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" milliseconds and found "</span> &lt;&lt; clusters.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>&lt;&lt; <span class="token string">" clusters"</span> &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	return clusters<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
 
<span class="token selector">//4、框出每个类
template&lt;typename PointT&gt;
Box ProcessPointClouds&lt;PointT&gt;::BoundingBox(PtCdtr&lt;PointT&gt; cluster)</span> 
<span class="token punctuation">{<!-- --></span>
 
	// Find bounding box for one of the clusters
	PointT minPoint<span class="token punctuation">,</span> maxPoint<span class="token punctuation">;</span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getMinMax3D</span><span class="token punctuation">(</span>*cluster<span class="token punctuation">,</span> minPoint<span class="token punctuation">,</span> maxPoint<span class="token punctuation">)</span><span class="token punctuation">;</span> //想得到它x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z三个轴上的最大值和最小值
 
	Box box<span class="token punctuation">;</span>
	box.x_min = minPoint.x<span class="token punctuation">;</span>
	box.y_min = minPoint.y<span class="token punctuation">;</span>
	box.z_min = minPoint.z<span class="token punctuation">;</span>
	box.x_max = maxPoint.x<span class="token punctuation">;</span>
	box.y_max = maxPoint.y<span class="token punctuation">;</span>
	box.z_max = maxPoint.z<span class="token punctuation">;</span>
	return box<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">template&lt;typename PointT&gt;
void ProcessPointClouds&lt;PointT&gt;::savePcd(PtCdtr&lt;PointT&gt; cloud, std::string file)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">io</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">savePCDFileASCII</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> *cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cerr &lt;&lt; <span class="token string">"Saved "</span> &lt;&lt; cloud-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" data points to "</span> + file &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">template&lt;typename PointT&gt;//加载点云数据
PtCdtr&lt;PointT&gt; ProcessPointClouds&lt;PointT&gt;::loadPcd(std::string file)</span> <span class="token punctuation">{<!-- --></span>
 
	PtCdtr&lt;PointT&gt; <span class="token function">cloud</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token selector">if (pcl::io::loadPCDFile&lt;PointT&gt;(file, *cloud) == -1)</span> 
	<span class="token punctuation">{<!-- --></span> //* load the file
		PCL_<span class="token function">ERROR</span><span class="token punctuation">(</span><span class="token string">"Couldn't read file \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cerr &lt;&lt; <span class="token string">"Loaded "</span> &lt;&lt; cloud-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &lt;&lt; <span class="token string">" data points from "</span> + file &lt;&lt; <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	return cloud<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">template&lt;typename PointT&gt;
std::vector&lt;boost::filesystem::path&gt; ProcessPointClouds&lt;PointT&gt;::streamPcd(std::string dataPath)</span> 
<span class="token punctuation">{<!-- --></span>
	<span class="token selector">std::vector&lt;boost::filesystem::path&gt; paths(boost::filesystem::directory_iterator</span><span class="token punctuation">{<!-- --></span>dataPath<span class="token punctuation">}</span><span class="token selector">,boost::filesystem::directory_iterator</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	// sort files in accending order so playback is chronological
	<span class="token function">sort</span><span class="token punctuation">(</span>paths.<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> paths.<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	return paths<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>cluster3d.h</strong></p> 
<pre><code class="prism language-css"><span class="token selector">#ifndef PLAYBACK_CLUSTER3D_H
#define PLAYBACK_CLUSTER3D_H
#include &lt;pcl/common/common.h&gt;
#include &lt;chrono&gt;
#include &lt;string&gt;
#include "kdtree3d.h"
 
namespace lidar_obstacle_detection</span> <span class="token punctuation">{<!-- --></span>
	// shorthand for point cloud pointer
	template&lt;typename PointT&gt;
	using PtCdtr = typename <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">:</span><span class="token punctuation">:</span>Ptr<span class="token punctuation">;</span>
	<span class="token selector">template&lt;typename PointT&gt;
	class ClusterPts</span> 
	<span class="token punctuation">{<!-- --></span>
	<span class="token property">private</span><span class="token punctuation">:</span>
		int num_points<span class="token punctuation">;</span>
		float distanceTol<span class="token punctuation">;</span>
		int minClusterSize<span class="token punctuation">;</span>
		int maxClusterSize<span class="token punctuation">;</span>
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;bool&gt; processed<span class="token punctuation">;</span>
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;PtCdtr&lt;PointT&gt;&gt; clusters<span class="token punctuation">;</span>
	<span class="token selector">public:
		//构造函数
		ClusterPts(int nPts, float cTol, int minSize, int maxSize) : num_points(nPts), distanceTol(cTol),minClusterSize(minSize), maxClusterSize(maxSize)</span> 
		<span class="token punctuation">{<!-- --></span>
			processed.<span class="token function">assign</span><span class="token punctuation">(</span>num_points<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		~<span class="token function">ClusterPts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		void <span class="token function">clusterHelper</span><span class="token punctuation">(</span>int ind<span class="token punctuation">,</span> PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">,</span> <span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; &amp;cluster<span class="token punctuation">,</span> KdTree *tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;PtCdtr&lt;PointT&gt;&gt; <span class="token function">EuclidCluster</span><span class="token punctuation">(</span>PtCdtr&lt;PointT&gt; cloud<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
#endif //PLAYBACK_CLUSTER3D_H
</code></pre> 
<p><strong>cluster3d.cpp</strong></p> 
<pre><code class="prism language-css">#include <span class="token string">"cluster3d.h"</span>
using namespace lidar_obstacle_detection<span class="token punctuation">;</span>
<span class="token selector">template&lt;typename PointT&gt;
ClusterPts&lt;PointT&gt;::~ClusterPts()</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token selector">//根据最近邻搜索的阈值，找到了类数，每一类包含了属于该类的点			ok
template&lt;typename PointT&gt;
void ClusterPts&lt;PointT&gt;::clusterHelper(int ind, PtCdtr&lt;PointT&gt; cloud, std::vector&lt;int&gt; &amp;cluster, KdTree *tree)</span> 
<span class="token punctuation">{<!-- --></span>
	//<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;bool&gt; processed<span class="token punctuation">;</span>
	processed[ind] = true<span class="token punctuation">;</span>
	cluster.push_<span class="token function">back</span><span class="token punctuation">(</span>ind<span class="token punctuation">)</span><span class="token punctuation">;</span>
	//ec.<span class="token function">setClusterTolerance</span><span class="token punctuation">(</span>clusterTolerance<span class="token punctuation">)</span><span class="token punctuation">;</span>  设置近邻搜索半径
	<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; nearest_point = tree-&gt;<span class="token function">search</span><span class="token punctuation">(</span>cloud-&gt;points[ind]<span class="token punctuation">,</span> distanceTol<span class="token punctuation">)</span><span class="token punctuation">;</span> 
 
	<span class="token selector">for (int nearest_id : nearest_point)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (!processed[nearest_id])</span> 
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">clusterHelper</span><span class="token punctuation">(</span>nearest_id<span class="token punctuation">,</span> cloud<span class="token punctuation">,</span> cluster<span class="token punctuation">,</span> tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token selector">//重写欧式聚类算法		ok
template&lt;typename PointT&gt;
std::vector&lt;PtCdtr&lt;PointT&gt;&gt; ClusterPts&lt;PointT&gt;::EuclidCluster(PtCdtr&lt;PointT&gt; cloud)</span> 
<span class="token punctuation">{<!-- --></span>
	KdTree *tree = new KdTree<span class="token punctuation">;</span>  //创建重写kdtree的对象
	//对cloud创建kdtree
	for <span class="token punctuation">(</span>int ind = 0<span class="token punctuation">;</span> ind &lt; num_points<span class="token punctuation">;</span> <span class="token selector">ind++)</span> 
	<span class="token punctuation">{<!-- --></span>
		tree-&gt;<span class="token function">insert</span><span class="token punctuation">(</span>cloud-&gt;points[ind]<span class="token punctuation">,</span> ind<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	//<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;bool&gt; processed<span class="token punctuation">;</span>
	for <span class="token punctuation">(</span>int ind = 0<span class="token punctuation">;</span> ind &lt; num_points<span class="token punctuation">;</span> <span class="token selector">ind++)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (processed[ind])</span> 
		<span class="token punctuation">{<!-- --></span>
			ind++<span class="token punctuation">;</span>
			continue<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token property">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span>vector&lt;int&gt; cluster_ind<span class="token punctuation">;</span> //每一类包含点的索引
		PtCdtr&lt;PointT&gt; <span class="token function">cloudCluster</span><span class="token punctuation">(</span>new <span class="token property">pcl</span><span class="token punctuation">:</span><span class="token punctuation">:</span>PointCloud&lt;PointT&gt;<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">clusterHelper</span><span class="token punctuation">(</span>ind<span class="token punctuation">,</span> cloud<span class="token punctuation">,</span> cluster_ind<span class="token punctuation">,</span> tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		int cluster_size = cluster_ind.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token selector">//总类数
		if (cluster_size &gt;= minClusterSize &amp;&amp; cluster_size &lt;= maxClusterSize)</span> 
		<span class="token punctuation">{<!-- --></span>
			for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; cluster_size<span class="token punctuation">;</span> <span class="token selector">i++)</span> 
			<span class="token punctuation">{<!-- --></span>
				cloudCluster-&gt;points.push_<span class="token function">back</span><span class="token punctuation">(</span>cloud-&gt;points[cluster_ind[i]]<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			cloudCluster-&gt;width = cloudCluster-&gt;points.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			cloudCluster-&gt;height = 1<span class="token punctuation">;</span>
			clusters.push_<span class="token function">back</span><span class="token punctuation">(</span>cloudCluster<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	return clusters<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>https://zhuanlan.zhihu.com/p/128511171<br> https://blog.csdn.net/qinlele1994</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51e3bbca1b6630026efb9f9126239966/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Docker打包镜像并发布</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ea14953b02b05b76d7e69834ef0e913/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">指定不同版本的pcl</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>