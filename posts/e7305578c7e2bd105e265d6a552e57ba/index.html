<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WPF属性 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WPF属性" />
<meta property="og:description" content=" (一)依赖属性【源码-09DependencyObj】
依赖属性就是一种可以自己没有值，并能通过使用Binding从数据源获得值(依赖在别人身上)的属性。拥有依赖属性的对象被称为“依赖对象”。与传统的CLR属性和面向对象思想相比依赖属性有很多新颖之处。
①：节省实例对内存的开销
②：属性值可以通过Binding依赖在其他对象上。
依赖属性对内存的使用方式
在传统.NET开发中，一个对象所占用的内存空间在调用new操作符进行实例化的时候已经决定了，而WPF允许对象在被创建的时候并不包含用于存储数据的空间(即字段所占用的空间)、只保留在需要用到数据时能够获得默认值、借用其他对象数据或实时分配空间的能力——这种对象就称为依赖对象(DependencyObject)，而这种实时获取数据的能力则依靠依赖属性(DependencyProperty)来实现。在WPF开发中，必须使用依赖对象(DependencyObject)作为依赖属性(DependencyProperty)的宿主，使二者结合起来，才能形成完整的Binding目标被数据所驱动。
public class Student : DependencyObject{ public string Name { get { return (string)GetValue(NameProperty); } set { SetValue(NameProperty, value); } } public static readonly DependencyProperty NameProperty = DependencyProperty.Register(&#34;Name&#34;,//string类型，用这个参数来指明以哪个CLR属性作为这个依赖属性的包装器 typeof(string), //用来指明此依赖属性用来存储什么类型的值。 typeof(Student));//用来指明此依赖属性的宿主是什么类型，或者说DependencyProperty.Register方法将把这个依赖属性注册关联到那个类型上。} " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e7305578c7e2bd105e265d6a552e57ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-30T17:32:00+08:00" />
<meta property="article:modified_time" content="2021-04-30T17:32:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WPF属性</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <p><strong><font color="#ff0000" size="3">(一)依赖属性【<a href="https://gitee.com/lhl62411570/databinding" rel="nofollow">源码-09DependencyObj</a>】</font></strong><br> 依赖属性就是一种可以自己没有值，并能通过使用<font color="#ff0000">Binding</font>从数据源获得值(依赖在别人身上)的属性。拥有依赖属性的对象被称为“依赖对象”。与传统的CLR属性和面向对象思想相比依赖属性有很多新颖之处。<br> ①：节省实例对内存的开销<br> ②：属性值可以通过<font color="#ff0000">Binding</font>依赖在其他对象上。<br> 依赖属性对内存的使用方式<br> 在传统.NET开发中，一个对象所占用的内存空间在调用new操作符进行实例化的时候已经决定了，而WPF允许对象在被创建的时候并不包含用于存储数据的空间(即字段所占用的空间)、只保留在需要用到数据时能够获得默认值、借用其他对象数据或实时分配空间的能力——这种对象就称为<font color="#ff0000">依赖对象(DependencyObject)</font>，而这种实时获取数据的能力则依靠<font color="#ff0000">依赖属性(DependencyProperty)</font>来实现。在WPF开发中，必须使用<font color="#ff0000">依赖对象(DependencyObject)</font>作为<font color="#ff0000">依赖属性(DependencyProperty)</font>的宿主，使二者结合起来，才能形成完整的<font color="#ff0000">Binding</font>目标被数据所驱动。</p> 
 <pre><code class="has"><pre class="has">public class Student : DependencyObject</pre><pre class="has">{<!-- --></pre><pre class="has">    public string Name</pre><pre class="has">    {<!-- --></pre><pre class="has">        get { return (string)GetValue(NameProperty); }</pre><pre class="has">        set { SetValue(NameProperty, value); }</pre><pre class="has">    }</pre><pre class="has"></pre><pre class="has">    <strong>public</strong> <strong>static</strong> <strong>readonly</strong> DependencyProperty NameProperty = </pre><pre class="has">        DependencyProperty.Register("Name",//string类型，用这个参数来指明以哪个CLR属性作为这个依赖属性的包装器</pre><pre class="has">        typeof(string), //用来指明此依赖属性用来存储什么类型的值。</pre><pre class="has">        typeof(Student));//用来指明此依赖属性的宿主是什么类型，或者说DependencyProperty.Register方法将把这个依赖属性注册关联到那个类型上。</pre><pre class="has">}</pre></code></pre> 
 <p></p> 
 <div style="text-align: center;"> 
  <img width="923" height="808" title="image" alt="image" src="https://images2.imgbox.com/46/3a/eWmMUS6U_o.png" border="0" style="outline: none;"> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2555eaa29c114298a49a733bc736599/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Postgresql、Hologres表结构查询语句</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0adc5f14ded2cfffb72f301d5f189375/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux superblock 时间,e2fsck: Bad magic number in super-block_Linux</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>