<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>文件描述符表 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="文件描述符表" />
<meta property="og:description" content="文章目录 1. 文件描述符1.1 前言1.2 理解文件1.3 文件描述附表1.4 打开文件时1.5 默认打开的三个文件 2. 重定向2.1 瞅瞅2.2 dup22.3 实现原理 3. 一切皆文件 1. 文件描述符 1.1 前言 环境：Linux 2.6
在 Linux 中，有句话叫做「一切皆文件」，指的是在 Linux 中的设备，资源等几乎一切资源都抽象成了文件，然后只需要提供对文件进行操作的接口，就可以让我们用统一的方式来读取，写入等各种操作，从而来管理 Linux 中的各种资源和数据。这种设计模式不仅简化了 Linux 架构，还简化了开发人员对资源的操作
1.2 理解文件 当进程打开一个文件的时候，操作系统会为其分配一个文件描述符（先了解，下文讲），当我们获取这个文件描述符之后，就可以对这个文件进行读写等各种操作了
并且这个文件被打开后，在操作系统内核中会为其创建一个结构体 struct file 来进行管理（这和 C 语言的 FILE 结构体不一样），它记录了文件的状态，读写位置等文件信息，它是在内核空间中的，而 C 语言的 struct FILE 是在用户空间中的
并且在 struct file 中存在一个指向缓冲区的指针，可以将数据暂存在缓冲区中，而文件通常会被划分成若干个页（4KB），在打开文件 / 读取文件的时候，操作系统会读取相应的块到该文件的缓冲区中
1.3 文件描述附表 在 Linux 中，进程被描述成 task_struct 进行管理（PCB），而task_struct 中有个指针 struct files_struct* files，该指针负责描述该进程的文件相关数据信息 struct task_struct { volatile long state;	/* -1 unrunnable, 0 runnable, &gt;0 stopped */ void *stack; ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9e46f32ab48239ad0a37878395f91f02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-07T17:50:21+08:00" />
<meta property="article:modified_time" content="2023-06-07T17:50:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">文件描述符表</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 文件描述符</a></li><li><ul><li><a href="#11__2" rel="nofollow">1.1 前言</a></li><li><a href="#12__8" rel="nofollow">1.2 理解文件</a></li><li><a href="#13__15" rel="nofollow">1.3 文件描述附表</a></li><li><a href="#14__45" rel="nofollow">1.4 打开文件时</a></li><li><a href="#15__52" rel="nofollow">1.5 默认打开的三个文件</a></li></ul> 
  </li><li><a href="#2__67" rel="nofollow">2. 重定向</a></li><li><ul><li><a href="#21__68" rel="nofollow">2.1 瞅瞅</a></li><li><a href="#22_dup2_83" rel="nofollow">2.2 dup2</a></li><li><a href="#23__113" rel="nofollow">2.3 实现原理</a></li></ul> 
  </li><li><a href="#3__122" rel="nofollow">3. 一切皆文件</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 文件描述符</h2> 
<h3><a id="11__2"></a>1.1 前言</h3> 
<p>环境：Linux 2.6</p> 
<p>在 Linux 中，有句话叫做「一切皆文件」，指的是在 Linux 中的设备，资源等几乎一切资源都抽象成了文件，然后只需要提供对文件进行操作的接口，就可以让我们用统一的方式来读取，写入等各种操作，从而来管理 Linux 中的各种资源和数据。这种设计模式不仅简化了 Linux 架构，还简化了开发人员对资源的操作</p> 
<h3><a id="12__8"></a>1.2 理解文件</h3> 
<p>当进程打开一个文件的时候，操作系统会为其分配一个文件描述符（先了解，下文讲），当我们获取这个文件描述符之后，就可以对这个文件进行读写等各种操作了</p> 
<p>并且这个文件被打开后，在操作系统内核中会为其创建一个结构体 <code>struct file</code> 来进行管理（这和 C 语言的 <code>FILE</code> 结构体不一样），它记录了文件的状态，读写位置等文件信息，它是在内核空间中的，而 C 语言的 <code>struct FILE</code> 是在用户空间中的</p> 
<p>并且在 <code>struct file</code> 中存在一个指向缓冲区的指针，可以将数据暂存在缓冲区中，而文件通常会被划分成若干个页（4KB），在打开文件 / 读取文件的时候，操作系统会读取相应的块到该文件的缓冲区中</p> 
<h3><a id="13__15"></a>1.3 文件描述附表</h3> 
<ul><li>在 <code>Linux</code> 中，进程被描述成 <code>task_struct</code> 进行管理（PCB），而<code>task_struct</code> 中有个指针 <code>struct files_struct* files</code>，该指针负责描述该进程的文件相关数据信息</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">volatile</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span>	<span class="token comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>stack<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token operator">*</span>files<span class="token punctuation">;</span>   <span class="token comment">// 负责描述进程的文件信息数据</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>而 <code>struct files_struct* files</code> 指向的结构体中有一个成员 <code>struct file* fd_array</code>，就是「文件描述符表」（新版本的内核版本可能称为 <code>fdt</code>）</li></ul> 
<p><img src="https://images2.imgbox.com/f3/bb/XItQ4NHK_o.png" alt="在这里插入图片描述"></p> 
<ul><li>这个文件描述符表，的下标（准确来说是索引）就称为「文件描述符」，而文件描述符表下标对应的对象<code>fd_array[i]</code>就是 <code>struct file*</code>，是指向内核中用来描述被打开文件的结构体</li><li>并且在修改相关配置的情况下，一个进程默认可以打开 32 或者 64 个文件，在修改的情况下，可以达到 10w 个，也就是文件描述符表的大小可以达到的大小</li></ul> 
<p>注意：</p> 
<ul><li>每个进程都会有文件描述符表，并且子进程的创建也会拷贝父进程的文件描述符表，打开相应的文件</li></ul> 
<p>综上所述，这里画个图：</p> 
<p><img src="https://images2.imgbox.com/62/96/VYlrt9Tl_o.png" alt="在这里插入图片描述"><br> ⭐实际上，Linux 在操作文件时，大部分是通过<strong>文件描述符表中的下标</strong>来进行操作的，而这个下标就是文件描述符 <code>fd</code>，这个很重要，比如 <code>wrtie</code> ，<code>read</code>，<code>send</code> 等系统调用接口都是对 <code>fd</code> 进行操作的。</p> 
<h3><a id="14__45"></a>1.4 打开文件时</h3> 
<p>当进程打开一个文件的时候，在内核中，会创建这个文件对应的 <code>struct file</code> ，然后在文件描述符表中分配一个没有被使用下标 <code>chosenIndex</code>，然后让 <code>fd_array[chosenIndex]</code> 中填入这个 <code>struct file</code> 的地址，再将这个下标 <code>chosenIndex</code> 返回给用户</p> 
<ul><li>分配原则：文件描述符表会从头开始遍历，找到一个最小，没被使用的文件描述符并返回。</li><li>在 Linux 中，大部分对文件的操作，都是对文件描述符 <code>fd</code> 作操作</li></ul> 
<p><img src="https://images2.imgbox.com/73/db/q4GVZkl4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="15__52"></a>1.5 默认打开的三个文件</h3> 
<p>Linux 中所有的进程都会默认打开 3 个文件，分别是 <code>stdin</code>（标准输入），<code>stdout</code>（标准输出），<code>stderr</code>（标准错误），它们所占用的文件描述符分别是 0，1，2</p> 
<p>一般情况下，标准输入就是键盘，标准输出和标准错误都是和显示器绑定，所以向标准输出和标准错误中输出，都会在显示屏上显示</p> 
<p>标准输出一般是接收程序的正常打印结果，标准错误一般是接收程序的错误或者异常结果</p> 
<p>这里可以试试，我直接往 1 号和 2 号文件描述符中写入数据：</p> 
<p><img src="https://images2.imgbox.com/fb/05/V04vviYY_o.png" alt="在这里插入图片描述">可以看出，向 1 号和 2 号打印的数据都往显示屏上打印了，</p> 
<p>所以我们在程序中，打开文件获取到的文件描述符通常是从 3 开始</p> 
<p><img src="https://images2.imgbox.com/c2/17/aiixRtLe_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2__67"></a>2. 重定向</h2> 
<h3><a id="21__68"></a>2.1 瞅瞅</h3> 
<p>先了解什么是重定向：是一种改变输入源或者输出目标的方式，允许就输入或输出从默认的位置转移到其他位置。还是晦涩的话，这么理解就好了：本来应该写到 xxx 中，现在写到了 yyy 中</p> 
<p>举例子：<code>echo</code> 是向显示屏中打印数据：</p> 
<p><img src="https://images2.imgbox.com/99/80/ZilxKSmD_o.png" alt="在这里插入图片描述"><br> 这直接打印到了屏幕上对吧</p> 
<p>我们现在使用 <code>&gt;</code> ，它在 <code>Linux</code> 命令行中是<strong>输出重定向</strong>（类似的<code>&gt;&gt;</code> 是追加重定向）<br> 现在我将上面那段输出 重定向 到文件中：</p> 
<p><img src="https://images2.imgbox.com/68/22/YNbgj9GI_o.png" alt="在这里插入图片描述"></p> 
<p>可以看出本来是打印到显示屏上的，现在写到了 <code>hello.c</code> 文件中，这也就是重定向了</p> 
<h3><a id="22_dup2_83"></a>2.2 dup2</h3> 
<p>首先我们先了解关于重定向的一个接口 <code>dup2</code></p> 
<p><img src="https://images2.imgbox.com/5b/30/rIYvsnYc_o.png" alt="在这里插入图片描述"><br> 这个接口要求传入两个文件描述符，这个函数的作用简单来说可以这么理解：</p> 
<ul><li>⭐<code>fd_array[newfd] = fd_array[oldfd]</code>，就是将文件描述符表中，<code>oldfd</code> 对应的内容拷贝给 <code>newfd</code> 对应的位置。也就是会有两个文件描述符指向同一个文件</li></ul> 
<p>比如下面这个代码，我打开了一个文件，然后执行 <code>dup2(fd, 1)</code>，那么文件描述符表发生了啥 o.0?</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"hello.c"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">dup2</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如下图，</p> 
<ol><li>打开文件的时候，在内核为这个文件创建 <code>struct file</code> 数据结构，然后为其分配文件描述符，并放到 <code>fd_array</code> 中管理，再返回文件描述符</li><li>将 <code>fd_array[1]</code> 中的指针指向这个文件的 <code>struct file</code> 中</li></ol> 
<p><img src="https://images2.imgbox.com/67/b8/QmiZgpOm_o.png" alt="在这里插入图片描述"><br> ⭐关键点就是将 <code>fd_array[newfd]</code> 的指针改成成指定的 <code>struct file</code></p> 
<p>然后看看下面代码演示一下：重定向之后，原本写在 1 号文件（也就是显示屏）中的数据现在写到了文件 <code>hello.c</code> 文件中。</p> 
<p><img src="https://images2.imgbox.com/7c/b7/D4Qsu761_o.png" alt="在这里插入图片描述">其实到这里，重定向的实现原理就七七八八了，我们下面再梳理一下应该就晓得了</p> 
<h3><a id="23__113"></a>2.3 实现原理</h3> 
<ul><li>当执行 <code>dup2(fd, 1)</code> 的时候，将文件描述符 <code>fd</code> 的内容拷贝给 <code>1</code> 号，这时候 <code>fd</code> 和 <code>1</code> 对应的指针都指向 <code>hello.c</code></li><li>文章开头说过，Linux 中大部分对文件的操作都是对文件描述符的操作</li><li>⭐在这个例子中，<code>write / read</code>同样是对文件描述符作操作，通俗点，就是操作系统只会对 <code>fd</code> 下标操作，并不关心<code>fd_array[fd]</code>里面是谁</li><li>所以当执行 <code>write(1, str, strlen(str))</code> 的时候，操作系统就直接往 1 号下标对应的文件进行写入了，<strong>它并不关心 1 号下标的文件是不是<code>stdout</code></strong> （强调）</li><li>所以最终表现出来的情况就是「本该向显示屏中输出，现在输出到了 <code>hello.c</code> 文件中」</li></ul> 
<p><img src="https://images2.imgbox.com/fc/c3/G4QOae4F_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3__122"></a>3. 一切皆文件</h2> 
<p>众所周知，电脑可以有很多外设，比如键盘，鼠标，声卡，音响，显示屏，网卡，磁盘…，而 Linux 怎么将这些看起来就离谱的硬件也抽象成文件的</p> 
<p>这些外设，大都有自己的读操作和写操作，而 Linux 不应该专门为每个硬件设计相应的读写方法，甚至设计相应的数据结构，这样不便于维护和管理，而且很麻烦，如果统一起来就好了</p> 
<ul><li>实际上在操作系统和硬件之间，还有一层软件层 —— 驱动，每个硬件通常都有配置一个特定的驱动，驱动可以和硬件交互控制，也可以将操作系统的指令翻译成硬件可以理解的指令 / 命令</li><li>所以驱动可以理解成操作系统和硬件交互的桥梁<br> 它可以为操作系统提供统一的接口（比如读写接口，下文也以读写接口举例子），借此操作系统可以实现对硬件的间接控制，以及完成两者之间的交互<br> <img src="https://images2.imgbox.com/fa/7e/db7vch36_o.png" alt="在这里插入图片描述"></li></ul> 
<p>还记得 <code>struct file</code> 结构体吗，前面说了这是一个操作系统内核中描述 / 管理文件的结构体，那么要怎么利用这个结构体来将底层硬件结合 / 统一起来？</p> 
<p>可以在 <code>struct file</code> 中提供若干个函数指针，比如 <code>ssize_t (*read)()</code>，<code>ssize_t (*write)()</code>，然后这些函数指针直接指向驱动层提供的读写接口，指针不必关心自己到底指向了哪个函数，对于 Linux 来说，它只知道只要调用 <code>struct file</code> 中的 <code>write</code> 函数，就一定会执行对应驱动提供的写操作接口，从而以管理文件的方式，实现从底层硬件的控制</p> 
<p><img src="https://images2.imgbox.com/da/4e/9KhDMZTT_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f478d0c78d4cb68a2b9f9f101394ee83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3使用拖拽组件draggable-next的使用教程【保姆级】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25fb196da2ae00e3c779321c467fb202/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络协议——什么是RIP协议？工作原理是什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>