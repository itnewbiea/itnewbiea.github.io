<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32G070 使用 OpenBLT 记录。 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32G070 使用 OpenBLT 记录。" />
<meta property="og:description" content="一个项目需要使用UART来更新程序。(因为设备组装好之后，拆开就非常麻烦了)
在网上找到了开源的OpenBLT。具体的资料自行百度。
这里记录下使用的流程。
0.下载源码 Feaser - OpenBLT Bootloader
1. 创建boot工程 使用STM32CUBE来创建，使用内部晶振，配置UART口。UART需要使用LL库。
LED 和看门口根据需要进行添加。
参考源码目录下的DEMO进行来添加所需的文件：
openblt\Target\Demo
支持很多MCU。
创建三个组：
core里面的代码貌似适合硬件无关的 直接添加即可。
位置：X:\openblt\Target\Source
App里面的代码是参考demo里面的。
主要是配置openblt的功能，使用UART CAN或者网口进行程序下载。
blt_conf.h就是配置文件。
led可以根据需要进行添加。
myApp.c直接参考demo的main函数写的。
代码位置：X:\openblt\Target\Demo\ARMCM0_STM32G0_Nucleo_G071RB_Keil\Boot
ARMCM0_STM32G0组里面的文件是和硬件相关的，直接拷贝移植到的文件就行。
使用的MCU是STM32G070，因此直接看考作者移植好的文件就行。
代码位置：X:\openblt\Target\Source\ARMCM0_STM32G0
最后在main函数的最后调用：MyAppMain(); 就可以了。
根据自己的需要进行的修改：
我这边需要的功能是，boot启动以后，进入程序更新操作，等待上位机发送更新指令。超时时间为5秒钟。超过5秒后，直接进入到APP程序。
需要修改一个宏：
#define BOOT_BACKDOOR_ENTRY_TIMEOUT_MS (5000)//(500) 在flash.c文件添加一个函数:
blt_bool iap_load_app(void) { unsigned int appRunAddr = flashLayout[0].sector_start; /* Test if user code is programmed starting from address &#34;APPLICATION_ADDRESS&#34; */ if (((*(volatile unsigned int*)appRunAddr) &amp; 0x2FFE0000 ) == 0x20000000) { return BLT_TRUE; }	else { return BLT_FALSE; } } 主要是因为我没看懂 FlashVerifyChecksum()这个函数。原版的代码使用MicroBoot可以让程序启动，但是使用JTAK烧写的程序就无法启动，也无法进行调试。感觉太麻烦了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9b26938b416aea39da5c3a9a8e53b1ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-18T13:37:55+08:00" />
<meta property="article:modified_time" content="2023-03-18T13:37:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32G070 使用 OpenBLT 记录。</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>一个项目需要使用UART来更新程序。(因为设备组装好之后，拆开就非常麻烦了)</p> 
<p>在网上找到了开源的OpenBLT。具体的资料自行百度。</p> 
<p>这里记录下使用的流程。</p> 
<h2><strong>0.下载源码</strong></h2> 
<p><a href="https://www.feaser.com/en/openblt.php" rel="nofollow" title="Feaser - OpenBLT Bootloader">Feaser - OpenBLT Bootloader</a></p> 
<h2><strong>1. 创建boot工程</strong></h2> 
<p>使用STM32CUBE来创建，使用内部晶振，配置UART口。UART需要使用LL库。</p> 
<p>LED 和看门口根据需要进行添加。</p> 
<p>参考源码目录下的DEMO进行来添加所需的文件：</p> 
<p>openblt\Target\Demo</p> 
<p><img alt="" height="768" src="https://images2.imgbox.com/15/fa/mEK6p13e_o.png" width="1200"></p> 
<p>支持很多MCU。</p> 
<p>创建三个组：</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/4f/d7/0njWHIIe_o.png" width="826"></p> 
<p> core里面的代码貌似适合硬件无关的 直接添加即可。</p> 
<p>位置：X:\openblt\Target\Source</p> 
<p></p> 
<p>App里面的代码是参考demo里面的。</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/0c/48/p2kAAbQn_o.png" width="793"></p> 
<p></p> 
<p>主要是配置openblt的功能，使用UART  CAN或者网口进行程序下载。</p> 
<p>blt_conf.h就是配置文件。</p> 
<p>led可以根据需要进行添加。</p> 
<p>myApp.c直接参考demo的main函数写的。</p> 
<p><img alt="" height="261" src="https://images2.imgbox.com/0e/63/WexAYc92_o.png" width="409"></p> 
<p>代码位置：X:\openblt\Target\Demo\ARMCM0_STM32G0_Nucleo_G071RB_Keil\Boot</p> 
<p></p> 
<p>ARMCM0_STM32G0组里面的文件是和硬件相关的，直接拷贝移植到的文件就行。</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/5a/0f/FU48Yq5J_o.png" width="808"></p> 
<p></p> 
<p>使用的MCU是STM32G070，因此直接看考作者移植好的文件就行。</p> 
<p>代码位置：X:\openblt\Target\Source\ARMCM0_STM32G0</p> 
<p>最后在main函数的最后调用：MyAppMain(); 就可以了。</p> 
<p></p> 
<p>根据自己的需要进行的修改：</p> 
<p>我这边需要的功能是，boot启动以后，进入程序更新操作，等待上位机发送更新指令。超时时间为5秒钟。超过5秒后，直接进入到APP程序。</p> 
<p>需要修改一个宏：</p> 
<pre><code class="language-cpp">#define BOOT_BACKDOOR_ENTRY_TIMEOUT_MS  (5000)//(500)</code></pre> 
<p>在flash.c文件添加一个函数:</p> 
<pre><code class="language-cpp">blt_bool iap_load_app(void)
{
	unsigned int appRunAddr = flashLayout[0].sector_start;
    /* Test if user code is programmed starting from address "APPLICATION_ADDRESS" */
    if (((*(volatile unsigned int*)appRunAddr) &amp; 0x2FFE0000 ) == 0x20000000)
    {
	  return BLT_TRUE;
    }	
	else
	{
		return BLT_FALSE;
	}
}</code></pre> 
<p>主要是因为我没看懂 FlashVerifyChecksum()这个函数。原版的代码使用MicroBoot可以让程序启动，但是使用JTAK烧写的程序就无法启动，也无法进行调试。感觉太麻烦了。</p> 
<p>修改nvm.c代码,屏蔽掉FlashVerifyChecksum函数，改调用iap_load_app。</p> 
<pre><code class="language-cpp">extern blt_bool iap_load_app(void);
/************************************************************************************//**
** \brief     Verifies the checksum, which indicates that a valid user program is
**            present and can be started.
** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
**
****************************************************************************************/
blt_bool NvmVerifyChecksum(void)
{
#if (BOOT_NVM_CHECKSUM_HOOKS_ENABLE &gt; 0)
  /* check checksum using the application specific method. */
  return NvmVerifyChecksumHook();
#else
  /* check checksum using the interally supported method. */
  //return FlashVerifyChecksum();
  return iap_load_app();
#endif
} /*** end of NvmVerifyChecksum ***/</code></pre> 
<p>这样就可以使用JTAG烧写APP，并且可以进行代码调试。</p> 
<h2><strong>2. 创建APP工程</strong></h2> 
<p>以前怎么弄现在还怎么弄，需要修改下FLASH的位置。</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/72/d1/5L7dizxO_o.png" width="826"></p> 
<p>然后在代码中添加一个函数：</p> 
<pre><code class="language-cpp">/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
static void VectorBase_Config(void)
{
  /* The constant array with vectors of the vector table is declared externally in the
   * c-startup code.
   */
  extern const unsigned long __Vectors[];

  /* Remap the vector table to where the vector table is located for this program. */
  SCB-&gt;VTOR = (unsigned long)&amp;__Vectors[0];
} /*** end of VectorBase_Config ***/
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
  VectorBase_Config();
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();</code></pre> 
<p>貌似不加也是可以用的，SCB-&gt;VTOR 的位置不需要像以前那样需要用户自己修改，boot里面已经帮用户修改了。</p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/eb/36/Y8M2xp4D_o.png" width="801"></p> 
<p> 在添加一个hex转srec文件的命令：</p> 
<p>fromelf #L --m32 --output=$L@L.srec</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/b6/cc/cJWkbh2x_o.png" width="826"></p> 
<p>代码编译后会生成srec文件。</p> 
<p></p> 
<p>3.使用MicroBoot进行程序更新：</p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/9f/a2/iPwZEyWF_o.png" width="1178"></p> 
<p>配置串口和波特率。选择固件文件即可。</p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/03/8c/3yvq9qiG_o.png" width="652"></p> 
<p></p> 
<p></p> 
<p>程序升级完以后，这个软件直接就退出了。</p> 
<p>有要例程的，我直接把测试过的打包发下：</p> 
<p><a href="https://download.csdn.net/download/qianxilin/86248297" title="STM32G070使用OpenBLT配套例程。-单片机文档类资源-CSDN下载">STM32G070使用OpenBLT配套例程。-单片机文档类资源-CSDN下载</a></p> 
<p><strong><span style="color:#fe2c24;">这里要特别注意的是，固件文件的位置不支持中文路径。</span></strong></p> 
<p><span style="color:#fe2c24;"><strong>2023-03-18 今天测试发现有个问题：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>FlashWriteChecksum 这个函数会操作FLASH，导致启动失败。 写完固件就不要调用了。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>另外对应的FlashVerifyChecksum 也不要调用了。</strong></span></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/896cda4155379db7c1537a31ec7afe66/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">正则替换replace中$1的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/780b53fb513fd50a7e29c76daef79cc8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python接口自动化脚本业务框架总概（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>