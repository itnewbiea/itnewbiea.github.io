<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>unity3d自定义Toggle组件，解决设置isOn自动调用方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="unity3d自定义Toggle组件，解决设置isOn自动调用方法" />
<meta property="og:description" content="当我们在使用unity自带的Toggle组件的时候，我们是通过Toggle组件上的isOn属性得知是开启我们的功能面板还是关闭，这时候通常我们会给toggle绑定一个方法，当我们点击toggle的时候，调用方法，同时播放点击音效，可是有些时候，需要我们在切换界面的时候通过其它方法来关闭我们的属性isOn为false，方便我们下次点击的时候，isOn为true，这时候，我们单独对toggle的isOn属性赋值时会调用一次我们的方法，同时还会播放一次声音，恶心的事情就此发生，所以在项目中不得不重写了此组件，以方便项目中多处使用，下面是MyToggle脚本，挂载到对象身上即可，和unity自带的Toggle用法一样，只是在手动设置isOn属性的时候不会自动调用方法。
using System; using UnityEditor; using UnityEngine; using UnityEngine.Events; using UnityEngine.EventSystems; using UnityEngine.Serialization; using UnityEngine.UI; /// &lt;summary&gt; /// 自定义Toggle组件 /// &lt;/summary&gt; [RequireComponent(typeof(RectTransform))] public class MyToggle : Selectable, IEventSystemHandler, IPointerClickHandler, ISubmitHandler, ICanvasElement { /// &lt;summary&gt; /// toggle为true时切换显示的底图 /// &lt;/summary&gt; public Graphic m_ChangeImage; [SerializeField] [FormerlySerializedAs(&#34;m_IsActive&#34;)] private bool m_IsOn; public MyToggle.ToggleTransition toggleTransition = MyToggle.ToggleTransition.Fade; public Toggle.ToggleEvent onValueChanged = new Toggle.ToggleEvent(); /// &lt;summary&gt; /// 设置ison属性（自动调用一次方法） /// &lt;/summary&gt; public bool isOn { get { return this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4f78883ed6a4350c9bbc4b81d5d47e57/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-27T21:33:00+08:00" />
<meta property="article:modified_time" content="2016-12-27T21:33:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">unity3d自定义Toggle组件，解决设置isOn自动调用方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="content-detail markdown-body"> 
 <div class="show-content-free"> 
  <p>当我们在使用unity自带的Toggle组件的时候，我们是通过Toggle组件上的isOn属性得知是开启我们的功能面板还是关闭，这时候通常我们会给toggle绑定一个方法，当我们点击toggle的时候，调用方法，同时播放点击音效，可是有些时候，需要我们在切换界面的时候通过其它方法来关闭我们的属性isOn为false，方便我们下次点击的时候，isOn为true，这时候，我们单独对toggle的isOn属性赋值时会调用一次我们的方法，同时还会播放一次声音，恶心的事情就此发生，所以在项目中不得不重写了此组件，以方便项目中多处使用，下面是MyToggle脚本，挂载到对象身上即可，和unity自带的Toggle用法一样，只是在手动设置isOn属性的时候不会自动调用方法。</p> 
  <pre><code>using System;
using UnityEditor;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.Serialization;
using UnityEngine.UI;

/// &lt;summary&gt;
/// 自定义Toggle组件
/// &lt;/summary&gt;
[RequireComponent(typeof(RectTransform))]
public class MyToggle : Selectable, IEventSystemHandler, IPointerClickHandler, ISubmitHandler, ICanvasElement
{

    /// &lt;summary&gt;
    /// toggle为true时切换显示的底图
    /// &lt;/summary&gt;
    public Graphic m_ChangeImage;

    [SerializeField]
    [FormerlySerializedAs("m_IsActive")]
    private bool m_IsOn;

    public MyToggle.ToggleTransition toggleTransition = MyToggle.ToggleTransition.Fade;

    public Toggle.ToggleEvent onValueChanged = new Toggle.ToggleEvent();
    
    /// &lt;summary&gt;
    /// 设置ison属性（自动调用一次方法）
    /// &lt;/summary&gt;
    public bool isOn
    {
        get
        {
            return this.m_IsOn;
        }
        set
        {
            this.Set(value);
        }
    }

    /// &lt;summary&gt;
    /// 设置ison属性（不会自动调用方法）
    /// &lt;/summary&gt;
    public bool IsOn
    {
        get
        {
            return this.m_IsOn;
        }
        set
        {
            this.Set(value, value, value);
        }
    }


    protected MyToggle()
    {
    }

    public virtual void Rebuild(CanvasUpdate executing)
    {
        if (executing != CanvasUpdate.Prelayout)
            return;
        this.onValueChanged.Invoke(this.m_IsOn);
    }


    public virtual void LayoutComplete()
    {
    }


    public virtual void GraphicUpdateComplete()
    {
    }

    protected override void OnEnable()
    {
        base.OnEnable();
        this.PlayEffect(true);
        this.IsOn = false;
    }


    protected override void OnDisable()
    {
        base.OnDisable();
        this.IsOn = false;
    }


    private void Set(bool value)
    {
        this.Set(value, true);
    }

    private void Set(bool value, bool sendCallback)
    {
        if (this.m_IsOn == value)
            return;
        this.m_IsOn = value;
        this.PlayEffect(this.toggleTransition == MyToggle.ToggleTransition.None);

        if (!sendCallback)
            return;
        this.onValueChanged.Invoke(this.m_IsOn);
    }

    private void Set(bool value, bool sendCallback, bool call)
    {
        if (this.m_IsOn == value)
            return;
        this.m_IsOn = value;
        this.PlayEffect(this.toggleTransition == MyToggle.ToggleTransition.None);

        if (!sendCallback)
            return;
    }

    private void InternalToggle()
    {
        if (!this.IsActive() || !this.IsInteractable())
            return;
        this.isOn = !this.isOn;
    }

    /// &lt;summary&gt;
    /// 点击事件
    /// &lt;/summary&gt;
    /// &lt;param name="eventData"&gt;Current event.&lt;/param&gt;
    public virtual void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.button != PointerEventData.InputButton.Left)
            return;
        this.InternalToggle();
    }

    public virtual void OnSubmit(BaseEventData eventData)
    {
        this.InternalToggle();
    }
     

    public enum ToggleTransition
    {
        None,
        Fade,
    }


    [Serializable]
    public class ToggleEvent : UnityEvent&lt;bool&gt;
    {
    }

    protected override void OnDidApplyAnimationProperties()
    {
        if ((UnityEngine.Object)this.m_ChangeImage != (UnityEngine.Object)null)
        {
            bool flag = !Mathf.Approximately(this.m_ChangeImage.canvasRenderer.GetColor().a, 0.0f);
            if (this.m_IsOn != flag)
            {
                this.m_IsOn = flag;
                this.Set(!flag);
            }
        }
        base.OnDidApplyAnimationProperties();
    }

    private void PlayEffect(bool instant)
    {
        if ((UnityEngine.Object)this.m_ChangeImage == (UnityEngine.Object)null)
            return;
        if (!Application.isPlaying)
            this.m_ChangeImage.canvasRenderer.SetAlpha(!this.m_IsOn ? 0.0f : 1f);
        else
            this.m_ChangeImage.CrossFadeAlpha(!this.m_IsOn ? 0.0f : 1f, !instant ? 0.1f : 0.0f, true);
    }
    protected override void Start()
    {
        this.PlayEffect(true);
    }
    protected override void OnValidate()
    {
        base.OnValidate();
        this.Set(this.m_IsOn, false);
        this.PlayEffect(this.toggleTransition == MyToggle.ToggleTransition.None);
        if (PrefabUtility.GetPrefabType((UnityEngine.Object)this) == PrefabType.Prefab || Application.isPlaying)
            return;
        CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild((ICanvasElement)this);
    }
 

}

</code></pre> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6efa895c31577be547d0276909c7127e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Extjs动画效果(自定义动画)  Ext Core 预置的 12 个动画功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d003b80e46650906a536fd68a25772a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android防止点击过快造成多次响应事件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>