<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【28】Kotlin语法进阶——使用协程编写高效的并发程序 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【28】Kotlin语法进阶——使用协程编写高效的并发程序" />
<meta property="og:description" content="提示：此文章仅作为本人记录日常学习使用，若有存在错误或者不严谨得地方欢迎指正。
文章目录 一、Kotlin中的协程1.1 协程的基本用法1.1.1协程与协程作用域1.1.2 使用launch函数创建子协程1.1.3 通过suspend关键声明挂起函数1.1.4 coroutineScope函数 1.2 更多的作用域构建器1.2.1 项目中创建协程的常用方法1.2.2 获取协程的返回值1.2.3 withContext函数 一、Kotlin中的协程 协程是Kotlin语言中很有代表性的一种并发设计模式，用于简化异步执行的代码。协程和线程有点类似，可以简单地将它理解成一种轻量级的线程。我们前面学习的线程是属于重量级的，这是因为线程需要依靠操作系统的调度来实现不同线程之间的切换。而协程仅在编程语言的层面就能实现不同协程之间的切换，无需操作系统的介入，从而极大提高了并发编程的运行效率。
举一个具体的例子，例如我们有foo()和bar()这两个方法：
fun foo(){ a() b() c() } fun bar(){ x() y() z() } 在没有开启线程的情况下，先调用foo()方法后调用bar()方法，理论上结果一定是a()、b()、c()执行完了以后，x()、y()、z()才能够得到执行。而如果在协程A中调用foo()方法，在协程B中调用bar()方法。虽然它们仍运行在同一个线程中，但在执行foo()方法时随时都有可能被挂起而去执行bar()方法；同理在执行bar()方法时也随时都有可能被挂起转而继续执行foo()方法，这就使得最终输出的结果变得不确定了。
可以看出，协程允许我们在单线程模式下模拟多线程编程的效果，代码执行时的挂起与恢复完全是由编程语言来控制的，和操作系统无关。
1.1 协程的基本用法 如果我们需要在项目中使用协程功能，需要在build.gradle.kts(:app)中添加以下依赖：
dependencies { · · · implementation(&#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9&#34;) // 适用于Android项目 implementation(&#34;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9&#34;) // 适用于非Android项目 } 创建一个CoroutinesTest.kt文件并在其中定义一个main()函数，然后在main()函数中使用GlobalScope.launch函数：
fun main() { GlobalScope.launch { println(&#34;codes run in coroutine scope&#34;) } } GlobalScope.launch函数可以创建一个协程的作用域，这样代码块中的代码就是在协程中运行的了。按照我们的理解，现在运行main()函数，应该会打印一句话才对。可是当你运行main()函数后却发现控制台中没有任何日志输出：
这是因为GlobalScope.launch函数每次创建的都是一个顶层协程，当应用程序运行结束时顶层协程也会跟着一起结束。刚才的日志之所以无法打印出来，正是因为代码块中的代码还没来得及运行，应用程序就结束了。为了解决这个问题，我们让程序延迟一段时间再结束就行了：
fun main() { GlobalScope.launch { println(&#34;codes run in coroutine scope&#34;) } // 让主线程休眠1s(1s后再关闭应用程序) Thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5c1629619bf85372f477a2117766fb2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T10:42:35+08:00" />
<meta property="article:modified_time" content="2023-12-28T10:42:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【28】Kotlin语法进阶——使用协程编写高效的并发程序</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>提示：此文章仅作为本人记录日常学习使用，若有存在错误或者不严谨得地方欢迎指正。</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Kotlin_3" rel="nofollow">一、Kotlin中的协程</a></li><li><ul><li><a href="#11__20" rel="nofollow">1.1 协程的基本用法</a></li><li><ul><li><a href="#111_79" rel="nofollow">1.1.1协程与协程作用域</a></li><li><a href="#112_launch_85" rel="nofollow">1.1.2 使用launch函数创建子协程</a></li><li><a href="#113_suspend_127" rel="nofollow">1.1.3 通过suspend关键声明挂起函数</a></li><li><a href="#114_coroutineScope_153" rel="nofollow">1.1.4 coroutineScope函数</a></li></ul> 
   </li><li><a href="#12__186" rel="nofollow">1.2 更多的作用域构建器</a></li><li><ul><li><a href="#121__209" rel="nofollow">1.2.1 项目中创建协程的常用方法</a></li><li><a href="#122__227" rel="nofollow">1.2.2 获取协程的返回值</a></li><li><a href="#123_withContext_290" rel="nofollow">1.2.3 withContext函数</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Kotlin_3"></a>一、Kotlin中的协程</h2> 
<p>协程是Kotlin语言中很有代表性的一种并发设计模式，用于简化异步执行的代码。<strong>协程和线程有点类似，可以简单地将它理解成一种轻量级的线程</strong>。我们前面学习的线程是属于重量级的，这是因为<strong>线程需要依靠操作系统的调度来实现不同线程之间的切换</strong>。而<strong>协程仅在编程语言的层面就能实现不同协程之间的切换</strong>，无需操作系统的介入，从而极大提高了并发编程的运行效率。<br> 举一个具体的例子，例如我们有foo()和bar()这两个方法：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fun</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在没有开启线程的情况下，先调用foo()方法后调用bar()方法，理论上结果一定是a()、b()、c()执行完了以后，x()、y()、z()才能够得到执行。而如果在协程A中调用foo()方法，在协程B中调用bar()方法。虽然<strong>它们仍运行在同一个线程中</strong>，但在执行foo()方法时随时都有可能被挂起而去执行bar()方法；同理在执行bar()方法时也随时都有可能被挂起转而继续执行foo()方法，这就使得最终输出的结果变得不确定了。<br> 可以看出，协程允许我们在单线程模式下模拟多线程编程的效果，代码执行时的挂起与恢复完全是由编程语言来控制的，和操作系统无关。</p> 
<h3><a id="11__20"></a>1.1 协程的基本用法</h3> 
<p>如果我们需要在项目中使用协程功能，需要在build.gradle.kts(:app)中添加以下依赖：</p> 
<pre><code class="prism language-kotlin">dependencies <span class="token punctuation">{<!-- --></span>
	· · ·
    <span class="token function">implementation</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9"</span></span><span class="token punctuation">)</span> <span class="token comment">// 适用于Android项目</span>
    <span class="token function">implementation</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9"</span></span><span class="token punctuation">)</span> <span class="token comment">// 适用于非Android项目</span>
<span class="token punctuation">}</span>    
</code></pre> 
<p>创建一个CoroutinesTest.kt文件并在其中定义一个main()函数，然后在main()函数中使用GlobalScope.launch函数：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"codes run in coroutine scope"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>GlobalScope.launch函数可以创建一个协程的作用域</strong>，这样<strong>代码块中的代码就是在协程中运行的了</strong>。按照我们的理解，现在运行main()函数，应该会打印一句话才对。可是当你运行main()函数后却发现控制台中没有任何日志输出：<br> <img src="https://images2.imgbox.com/69/72/hULUsGv9_o.png" alt="在这里插入图片描述"></p> 
<p>这是因为<strong>GlobalScope.launch函数每次创建的都是一个顶层协程，当应用程序运行结束时顶层协程也会跟着一起结束</strong>。刚才的日志之所以无法打印出来，正是因为代码块中的代码还没来得及运行，应用程序就结束了。为了解决这个问题，我们让程序延迟一段时间再结束就行了：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"codes run in coroutine scope"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 让主线程休眠1s(1s后再关闭应用程序)</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，在使用Thread.sleep(1000)让主线程休眠1s后，日志可以正常打印出来了。<br> <img src="https://images2.imgbox.com/7b/bf/8qnR504S_o.png" alt="在这里插入图片描述"><br> 可是这种写法还是存在一些问题的，如果代码块中的代码在1秒钟内不能运行结束，那么就会被强制中断：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"codes run in coroutine scope"</span></span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"codes run in coroutine finished"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们在代码块中加入了一个delay()函数，并在它后面又追加了一条打印。<strong>delay()函数可以让当前协程延迟一段时间后再运行</strong>，但它和Thread.sleep()方法不同。<strong>delay()函数只会挂起当前协程，并不会影响其他协程的运行。而Thread.sleep()方法会阻塞当前的线程，这样所有运行在该线程下的协程都会被阻塞</strong>。</p> 
<blockquote> 
 <p>注意：delay()函数只能在协程的作用域或其他挂起函数中调用。</p> 
</blockquote> 
<p>这里我们让协程挂起1.5s(打印第一行日志1.5s后再打印第二行日志)，让主线程休眠1s(应用程序1s后结束)。重新运行程序，你会发现代码块中新增加的一条日志并没有打印出来，因为它还没来得及运行，应用程序就已经结束了。为了解决这个问题，我们可以<strong>借助runBlocking函数让应用程序在协程中所有代码都运行完了之后再结束</strong>：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"codes run in coroutine scope"</span></span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"codes run in coroutine finished"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>runBlocking函数同样会创建一个协程的作用域</strong>，但它可以保证<strong>所有该协程作用域内的代码和子协程，在执行完毕之前会一直阻塞当前线程</strong>。需要注意的是runBlocking函数通常只应该在测试环境下使用，在正式环境中使用容易产生一些性能问题。重新运行程序，可以看到两条日志都能够正常打印出来了：<br> <img src="https://images2.imgbox.com/1e/28/eaMCSAkz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="111_79"></a>1.1.1协程与协程作用域</h4> 
<ul><li><strong>协程(Coroutine)是一种轻量级的并发单元，可以在其执行过程中挂起并返回到其父协程或顶层协程</strong>。协程的主要特点是它们能够被挂起并恢复，这使得它们可以用来实现并发和异步编程。</li><li><strong>协程作用域(Coroutine Scope)则是一种定义协程生命周期范围的对象</strong>。每个协程都必须在某个作用域内运行，当作用域被销毁时，它内部的所有协程都会被自动取消。协程作用域可以用来<strong>管理协程的启动、取消和结构化并发</strong>。</li></ul> 
<p>简单来说，协程是轻量级的并发单元，而协程作用域则是定义协程生命周期范围的对象，它可以用来管理和控制协程的执行。</p> 
<h4><a id="112_launch_85"></a>1.1.2 使用launch函数创建子协程</h4> 
<p>接下来我们学习一下如何<strong>使用launch函数创建多个协程</strong>：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        launch <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"launch1"</span></span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"launch1 finished"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        launch <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"launch2"</span></span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"launch2 finished"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的launch函数和我们前面所使用的GlobalScope.launch函数不同。首先<strong>①launch函数必须在协程的作用域中才能调用</strong>，其次<strong>②launch函数会在当前协程的作用域下创建子协程</strong>。<strong>子协程的特点是如果外层作用域的协程结束了，该作用域下的所有子协程也会一同结束</strong>，而<strong>GlobalScope.launch函数创建的永远是顶层协程</strong>。<br> 我们在runBlocking函数结构中调用了两次launch函数，也就相当于创建了两个子协程。重新运行程序，结果如下：<br> <img src="https://images2.imgbox.com/70/d2/d3YYcxBG_o.png" alt="在这里插入图片描述"><br> 可以看到两个子协程中的日志是交替打印的，说明它们确实是像多线程一样并发运行的。然而这两个协程实际却<strong>运行在同一个线程当中</strong>，只是<strong>由编程语言来决定如何在多个协程之间进行调度</strong>。调度的过程完全不需要操作系统参与，这也就使得协程的并发效率会更高。<br> 为了直观的体验到协程在处理并发事件时的效率，我们进行以下实验：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 协程开始执行的时间</span>
    <span class="token keyword">val</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            launch <span class="token punctuation">{<!-- --></span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"."</span></span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 协程执行完毕的时间</span>
    <span class="token keyword">val</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"协程执行时间：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">end <span class="token operator">-</span> start</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们使用repeat()函数创建了10万个协程，并让每个协程打印一行日志，然后记录下整个操作的耗时。重新运行程序，可以看到我们仅耗时348毫秒，这足以看出协程是多么的高效。试想一下，如果我们开启的是10万个线程，程序或许早都因为内存泄露而崩溃了。<br> <img src="https://images2.imgbox.com/02/e2/kwRggKVe_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="113_suspend_127"></a>1.1.3 通过suspend关键声明挂起函数</h4> 
<p>随着launch函数中的逻辑越来越复杂，可能你需要<strong>将部分launch函数中的代码提取到一个单独的函数中</strong>。这个时候就产生了另一个问题：我们在launch函数中编写的代码是拥有协程作用域的，但是如果将其提取到一个单独的函数中就没有协程作用域了，那么我们该如何调用像delay()这样的挂起函数呢？<br> 为此Kotlin提供了一个suspend关键字，<strong>使用suspend关键字可以将任意函数声明成挂起函数</strong>，而<strong>挂起函数之间都是可以相互调用</strong>的：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 协程开始执行的时间</span>
    <span class="token keyword">val</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            launch <span class="token punctuation">{<!-- --></span>
                <span class="token function">printDot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 协程执行完毕的时间</span>
    <span class="token keyword">val</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"协程执行时间：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">end <span class="token operator">-</span> start</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过suspend关键字将printDot()声明成挂起函数</span>
<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">printDot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"."</span></span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样printDot()函数就是一个挂起函数了，我们也就可以在printDot()函数中调用delay()函数。但suspend关键字只能将一个函数声明成挂起函数，却无法给他提供协程作用域的。例如你现在尝试在printDot()函数中调用launch函数，一定是无法调用成功的，因为<strong>launch函数要求必须在协程作用域当中才能调用</strong>。</p> 
<h4><a id="114_coroutineScope_153"></a>1.1.4 coroutineScope函数</h4> 
<p>为了解决suspend关键字作用域的问题，我们可以借助coroutineScope函数来解决。由于coroutineScope函数也是一个挂起函数，因此可以在其他挂起函数中调用它。<strong>coroutineScope函数的特点是会继承外部协程的作用域并创建一个子协程</strong>，借助这个特性，我们<strong>可以给任意挂起函数提供协程作用域</strong>：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">printDot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> coroutineScope <span class="token punctuation">{<!-- --></span>
    launch <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"."</span></span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过在printDot()内部使用coroutineScope函数，使得coroutineScope函数内部启动的协程（由launch创建）继承了printDot()函数的父作用域（也就是调用printDot()函数的外部作用域）。<br> 可以看到，现在我们可以在printDot()这个挂起函数中调用launch函数了。coroutineScope函数和runBlocking函数有点类似，它可以保证其作用域内的所有代码和子协程在全部执行完之前，外部的协程会一直被挂起。例如下面的示例代码：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// runBlocking确保其作用域内所有代码和子协程都执行完毕前会阻塞当前线程</span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// coroutineScope确保其作用域内所有代码和子协程都执行完毕前会阻塞当前线程</span>
        coroutineScope <span class="token punctuation">{<!-- --></span>
            launch <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"."</span></span><span class="token punctuation">)</span>
                    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"coroutineScope finished"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"runBlocking finished"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们先使用runBlocking函数创建了一个协程作用域，然后这个主协程作用域内又调用了coroutineScope函数创建了另一个新的协程作用域，并等待该作用域内的所有子协程执行完毕。运行结果如下：<br> <img src="https://images2.imgbox.com/cf/54/HF1FdqDl_o.png" alt="在这里插入图片描述"><br> 由此可见<strong>coroutineScope函数确实是将外部runBlocking协程挂起了</strong>。只有当coroutineScope作用域内所有的代码和子协程都执行完毕后，才会执行它之后的代码。需要注意，虽然coroutineScope函数和runBlocking函数很类似，但<strong>coroutineScope函数只会阻塞当前协程，既不会影响其他协程，也不会影响任何线程</strong>，因此是不会造成任何性能上的问题的。而<strong>runBlocking函数则会挂起外部线程，如果你恰好又在主线程中调用runBlocking函数的话，很可能会造成界面卡死</strong>，所以不推荐在实际项目中体验。</p> 
<h3><a id="12__186"></a>1.2 更多的作用域构建器</h3> 
<p>在上一小节的内容中，我们学习了GlobalScope.launch、runBlocking、launch、coroutineScope这几种作用域构建器。它们之间的调用方法还是有些许不同的：</p> 
<ul><li>GlobalScope.launch{ }函数、runBlocking{ }函数可以在任意地方调用。（<em>实际项目中不推荐使用</em>）</li><li>coroutineScope{ }函数可以在协程作用域或者挂起函数中调用。</li><li>launch{ }函数只能在协程作用域中调用。</li></ul> 
<p>注意：<br> ①由于<strong>runBlocking{ }函数会阻塞当前线程</strong>，因此只建议在测试环境下使用，不建议在实际项目中使用。<br> ②而<strong>GlobalScope.launch{ }函数每次创建的都是顶层协程(当应用程序结束时顶层协程也会结束)，除非明确需要创建顶层协程，否则也不建议在实际项目中使用</strong>。</p> 
<hr> 
<p>这里将讲一下为什么不建议在实际项目中使用顶层协程：<br> 不建议使用的原因是它的管理成本太高了。例如我们在某个Activity中使用协程发起了一条网络请求，由于网络请求是耗时的，当用户在服务器还没来得及响应的情况下就关闭了当前Activity，按理说此时应该取消这条网络请求或者不应该进行回调操作。因为Activity已经被用户关闭了，此时就算服务器返回了数据也没有任何意义。<br> 然而为了取消顶层协程，不管是GlobalScope.launch{ }函数还是launch{ }函数，它们都会返回一个Job对象，我们需要调用Job对象的cancel()方法来取消协程：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
    · · ·
<span class="token punctuation">}</span>
job<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果我们每次创建的都是顶层协程，那么当Activity关闭时，我们就需要逐个调用所有已创建协程的cancel()方法，这简直是一种灾难！因此GlobalScope.launch{ }这种协程作用域构建器在实际项目中也不太常用。</p> 
<hr> 
<h4><a id="121__209"></a>1.2.1 项目中创建协程的常用方法</h4> 
<p>下面是实际项目中比较常见的写法：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 创建Job对象</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> <span class="token function">Job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 通过Job对象创建CoroutineScope对象</span>
    <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
    <span class="token comment">// 通过CoroutineScope对象的launch{}函数创建协程</span>
    scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//处理具体逻辑</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 关闭协程</span>
    job<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们先是创建了一个Job对象，然后通过这个Job对象来创建一个CoroutineScope对象。之后我们就可以通过调用这个CoroutineScope对象的launch{ }函数来创建一个协程了。现在所有调用CoroutineScope的launch{ }函数所创建协程，都会被关联在Job对象的作用域下面。现在我们<strong>只需要调用一次Job对象中的cancel()方法，就可以将同一作用域内的所有协程全部取消</strong>，从而很大程度上降低了协程管理的成本。<br> 总而言之，CoroutineScope( )函数更适合实际项目当中使用。如果你只是在Main()函数中编写一些学习测试用的代码，还是使用runBlocking{ }函数最为方便。</p> 
<h4><a id="122__227"></a>1.2.2 获取协程的返回值</h4> 
<p>通过前面的学习你已经知道了调用launch{ }函数可以创建一个新的协程，但是launch{ }函数只能用于执行一段逻辑，却不能获取执行的结果，因为他的返回值永远是一个Job对象。那么如何能够创建一个协程并获取它的执行结果呢？<br> 其实我们通过async函数就可以实现，<strong>async函数必须在协程作用域当中才能调用。async函数会创建一个新的协程并返回一个Deferred对象，如果我们想要获取async函数代码块的执行结果，只需要调用Deferred对象的await()方法即可</strong>。下面是一段示例代码：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> result <span class="token operator">=</span> async <span class="token punctuation">{<!-- --></span>
            <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">5</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们通过async()函数将运算结果保存了下来，然后打印到日志中。<br> <img src="https://images2.imgbox.com/0f/5c/GPaw8djA_o.png" alt="在这里插入图片描述"><br> 在调用了async函数之后，代码块中的代码就会立刻开始执行。<strong>当调用await()方法时，如果async函数体中的代码还没有执行完毕，那么当前协程(即 runBlocking 函数内的协程)会被挂起，直到可以获得async函数的执行结果</strong>。我们接下来编写一段代码进行验证：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 开始时间</span>
        <span class="token keyword">val</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// result1延时1s</span>
        <span class="token keyword">val</span> result1 <span class="token operator">=</span> async <span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">5</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// result2延时1s</span>
        <span class="token keyword">val</span> result2 <span class="token operator">=</span> async <span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">6</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"result is : </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">result1 <span class="token operator">+</span> result2</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token comment">// 结束时间</span>
        <span class="token keyword">val</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"一共耗时 : </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">end <span class="token operator">-</span> start</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里我们使用了两个async函数来执行任务，在每个async代码块中调用delay()方法进行1秒的延时，然后在async代码块执行完毕后都调用了await()方法。按照我们之前的学习，<strong>await()方法使得async代码块中的代码在执行完毕之前会一直阻塞当前协程</strong>。运行程序后可以看到如下打印，足以说明协程是顺序执行的，即等待result1执行完毕后再执行result2的。<br> <img src="https://images2.imgbox.com/8a/d4/LyuxY0R0_o.png" alt="在这里插入图片描述"><br> 但是上面这种写法效率是很低的，因为每个async块执行完后都调用了await()方法。这意味着，第一个async块中的代码在执行完毕后必须等待1秒后才去执行第二个async块。而第二个async块同样会等待1秒后才去执行主线程中的其他代码，所以总的执行时间约为2秒。其实两个async函数完全可以同时执行，从而提高运行效率。现在对上述代码进行优化：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">val</span> deferred1 <span class="token operator">=</span> async <span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">5</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">val</span> deferred2 <span class="token operator">=</span> async <span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">6</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 在使用返回值的地方再调用await()方法</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"result is : </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">deferred1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> deferred2<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token keyword">val</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"一共耗时 : </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">end <span class="token operator">-</span> start</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到在这段代码中，我们改变了调用await()函数的时机，仅在需要用到async代码块的执行结果时才调用await()方法去获取。这样两个async函数就可以并行执行了，第二个async再也不用等待第一个async完成之后才能执行了。这次重新运行程序：<br> <img src="https://images2.imgbox.com/a5/87/n6sWGONE_o.png" alt="在这里插入图片描述"><br> 可以看到我们的代码耗时从2015ms缩短为了1015ms，运行效率显著提升。这也就说明我们两个async中的代码确实是并行执行的，并且成功将他们的结果输出到日志中了。</p> 
<h4><a id="123_withContext_290"></a>1.2.3 withContext函数</h4> 
<p>最后我们再来学习一个比较特殊的作用域构建器——withContext( )函数。withContext()函数也是一个挂起函数，可以将其理解成async函数的一种简化版写法。示例代码如下：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Default<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">5</span>
        <span class="token punctuation">}</span>
        <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当我们调用withContext()函数后，会立即执行代码块中的代码，同时会将外部协程(runBlocking{ })挂起。当代码块中的代码全部执行完毕后，会将最后一行的执行结果作为withContext()函数的返回值进行返回。因此基本相当于val result = async{ 5 + 5 }.await()的写法，唯一不同的是withContext()函数会强制要求我们指定一个线程参数。<br> 你已经知道协程是一种轻量级的线程，因此很多传统编程情况下需要开启多线程执行并发任务。然而借助协程，我们只需要在一个线程中开启多个协程来执行就可以了。这并不意味着我们就永远不需要开启线程了，比如说Android中的网络请求必须要在子线程中进行，即使你开启了协程去执行网络请求，假如它是主线程当中的协程，那么程序依然会报错。这个时候我们就应该通过线程参数给协程指定一个具体运行的线程。<br> 线程参数主要有以下3种值可以选择：Dispatchers.Default、Dispatchers.IO、Dispatchers.Main。</p> 
<ul><li>Dispatchers.Default：使用一种默认低并发的线程策略，当你要执行的代码属于计算密集型任务时，开启过高的并发反而可能会影响任务的运行效率，因此就可以使用Dispatchers.Default。</li><li>Dispatchers.IO：使用一种较高并发的线程策略，当你要执行的代码大多数时间是在阻塞和等待中，比如说要执行网络请求时，为了能够支持更高的并发数量，此时就可以使用Dispatchers.IO。</li><li>Dispatchers.Main：表示不会开启子线程，而是在Android主线程中执行代码，但是这个值只能在Android项目中使用，纯Kotlin程序使用这种类型的线程参数会报错。</li></ul> 
<p>事实上除了coroutineScope{ }函数之外，其他所有的函数都是可以指定这样一个线程参数的，只不过withContext()函数是强制要求指定的，而其他函数则是可选的。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0adace642e236e6561b173b16dd17f42/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Microsoft托管密钥的Azure信息保护云退出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5ae9b6990bb6a40abefbc0d6713d789a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL 核心模块揭秘 |《发刊词》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>