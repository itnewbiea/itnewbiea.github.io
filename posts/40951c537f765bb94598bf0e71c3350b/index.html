<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>golang中级进阶（五）：接口接收者、结构体多接口、接口嵌套、空接口类型断言使用细节 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="golang中级进阶（五）：接口接收者、结构体多接口、接口嵌套、空接口类型断言使用细节" />
<meta property="og:description" content="目录
一、结构体值接收者和指针接收者实现接口的区别
1. 值接收者
2. 指针接收者
二、结构体实现多接口
三、接口嵌套
四、空接口和类型断言使用细节
一、结构体值接收者和指针接收者实现接口的区别 1. 值接收者 如果结构体中的方法是值接收者，那么实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量
package main import &#34;fmt&#34; // 结构体值接收者和指针接收者实现接口的区别 type Usber interface { Start() Stop() } //值接收者 type Phone struct { Name string } func (p Phone) Start() { fmt.Println(p.Name, &#34;启动&#34;) } func (p Phone) Stop() { fmt.Println(p.Name, &#34;关机&#34;) } func main() { // 值接收者 如果结构体中的方法是值接收者，那么实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量 var p1 = Phone{ Name: &#34;小米手机&#34;, } var p2 Usber = p1 p2.Start() // 小米手机 启动 p2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/40951c537f765bb94598bf0e71c3350b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-21T11:39:29+08:00" />
<meta property="article:modified_time" content="2022-04-21T11:39:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">golang中级进阶（五）：接口接收者、结构体多接口、接口嵌套、空接口类型断言使用细节</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">一、结构体值接收者和指针接收者实现接口的区别</a></p> 
<p id="1.%20%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85-toc" style="margin-left:80px;"><a href="#1.%20%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85" rel="nofollow">1. 值接收者</a></p> 
<p id="2.%20%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85-toc" style="margin-left:80px;"><a href="#2.%20%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85" rel="nofollow">2. 指针接收者</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%8E%A5%E5%8F%A3" rel="nofollow">二、结构体实现多接口</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97" rel="nofollow">三、接口嵌套</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82" rel="nofollow">四、空接口和类型断言使用细节</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3>一、结构体值接收者和指针接收者实现接口的区别</h3> 
<h4 id="1.%20%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85">1. 值接收者</h4> 
<p><span style="color:#fe2c24;">如果结构</span>体中<span style="color:#fe2c24;">的方法是值接收者，那么实例化后的结构</span>体值<span style="color:#fe2c24;">类型和结构体指针类型都可以赋值给接口变量</span></p> 
<pre><code class="language-Go">package main

import "fmt"

// 结构体值接收者和指针接收者实现接口的区别
type Usber interface {
	Start()
	Stop()
}

//值接收者
type Phone struct {
	Name string
}

func (p Phone) Start() {
	fmt.Println(p.Name, "启动")
}

func (p Phone) Stop() {
	fmt.Println(p.Name, "关机")
}

func main() {
    // 值接收者 如果结构体中的方法是值接收者，那么实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量
	var p1 = Phone{
		Name: "小米手机",
	}
	var p2 Usber = p1
	p2.Start() // 小米手机 启动
	p2.Stop()  // 小米手机 关机

	var p3 = &amp;Phone{
		Name: "华为",
	}
	var p4 Usber = p3
	p4.Start() // 华为 启动
	p4.Stop()  // 华为 关机
}</code></pre> 
<h4 id="2.%20%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85">2. 指针接收者</h4> 
<p><span style="color:#fe2c24;">如果结构体中的方法是指针接收者，那么实例化后结构体指针类型都可以赋值给接口变量， 结构体值类型没法赋值给接口变量。</span></p> 
<pre><code class="language-Go">package main

import "fmt"

// 结构体值接收者和指针接收者实现接口的区别
type Usber interface {
	Start()
	Stop()
}

// 指针接收者
type Phone2 struct {
	Name string
}

func (p *Phone2) Start() {
	fmt.Println(p.Name, "指针接收者启动")
}

func (p *Phone2) Stop() {
	fmt.Println(p.Name, "指针接收者关机")
}

func main() {
    // 指针接收者 如果结构体中的方法是指针接收者，那么实例化后结构体指针类型都可以赋值给接口变量， 结构体值类型没法赋值给接口变量。
	/*
		错误示范
		var p5 = Phone2{
			Name: "错误",
		}
		var p6 Usber = p5 // Phone2 does not implement Usber (Start method has pointer receiver)
		p6.Start()
		p6.Stop()
	*/
	var p5 = &amp;Phone2{
		Name: "魅族",
	}
	var p6 Usber = p5
	p6.Start() // 魅族 指针接收者启动
	p6.Stop()  // 魅族 指针接收者关机
}</code></pre> 
<h3 id="%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%8E%A5%E5%8F%A3">二、结构体实现多接口</h3> 
<pre><code class="language-Go">package main

import "fmt"

// 一个结构体实现多个接口
type Seter interface {
	setName(string)
}

type Geter interface {
	getName() string
}

type Dog struct {
	Name string
}

func (d *Dog) setName(name string) {
	d.Name = name
}

func (d Dog) getName() string {
	return d.Name
}

func main() {
    // 一个结构体实现多个接口
	var d1 = &amp;Dog{
		Name: "小花",
	}
	var d2 Seter = d1
	d2.setName("大黄")
	var d3 Geter = d1
	fmt.Println(d3.getName()) // 大黄
}</code></pre> 
<h3 id="%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97">三、接口嵌套</h3> 
<p><span style="color:#fe2c24;">接口嵌套不用标点符号</span></p> 
<pre><code class="language-Go">package main

import "fmt"

// 接口嵌套
type Aer interface {
	Say()
}

type Ber interface {
	Move()
}

type Anyer interface { // 接口嵌套不用标点符号
	Aer
	Ber
}

type Cat struct {
	Name string
}

func (c Cat) Say() {
	fmt.Println(c.Name, "喵喵喵")
}

func (c Cat) Move() {
	fmt.Println(c.Name, "移动")
}

func main() {
    // 接口嵌套
	var c = Cat{
		Name: "猫猫",
	}

	var c1 Anyer = c
	c1.Say()  // 猫猫 喵喵喵
	c1.Move() // 猫猫 移动
}</code></pre> 
<h3 id="%E5%9B%9B%E3%80%81%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82">四、空接口和类型断言使用细节</h3> 
<p><span style="color:#fe2c24;">空接口是没有索引的，不允许[0]或者.xxx进行获取，解决方案使用类型断言进行获取。</span></p> 
<pre><code class="language-Go">package main

import "fmt"

// 空接口类型断言
type Address struct {
	Info  string
	Phone int
}

func main() {
    // 空接口类型断言使用细节
	var user = make(map[string]interface{})
	user["username"] = "张三"
	user["age"] = 20
	user["hobby"] = []string{"吃饭", "睡觉"}

	fmt.Println(user)          // map[age:20 hobby:[吃饭 睡觉] username:张三]
	fmt.Println(user["hobby"]) // [吃饭 睡觉]
	// 空接口是没有索引的，不允许下方这样调用
	//fmt.Println(user["hobby"][1]) // map index expression of type interface{}

	// 解决方案，使用类型断言
	hobby, ok := user["hobby"].([]string)
	if ok {
		fmt.Println(hobby[1]) // 睡觉
	}

	address := Address{
		Info:  "济南市",
		Phone: 15122332233,
	}
	user["address"] = address
	fmt.Println(user["address"]) // {济南市 15122332233}
	// 空接口是没有索引的，不允许下方这样调用
	//fmt.Println(user["address"].Info) // type interface{} has no field or method Info

	// 解决方案，同样使用类型断言
	userInfo, ok := user["address"].(Address)
	if ok {
		fmt.Println(userInfo.Info) // 济南市
	}
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c2daea2835811c81a5cf9852e68aa5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">提取CNN模型中间层输出方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9c24f69179efae18fb6f62f2abe0614/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3&#43;element-plus配置cdn</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>