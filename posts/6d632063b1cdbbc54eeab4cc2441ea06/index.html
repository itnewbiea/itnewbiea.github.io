<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Windows Sockets 网络编程及UR机器人通信数据解析代码 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Windows Sockets 网络编程及UR机器人通信数据解析代码" />
<meta property="og:description" content="1 前言 之前写了几篇关于UR机器人网络控制的文章：《UR机器人返回信息格式解析》、《UR机器人通信端口和协议》，有不少读者问关于编程实现方面的问题，因此，这里上传有关的代码，供同行参考。
2 包含内容 我这里是用VS2015编译环境，用C/C&#43;&#43;语言实现的。
实际上没有高深的技术，涉及到两个内容：
Windows Sockets网络编程；UR机器人返回数据内容解析，包括数据字节的转换。 3 程序实现 3.1 Windows Sockets网络编程 1) Windows Sockets初始化 在程序的开始，进行Windows Sockets初始化。WSAStartup必须是应用程序或DLL调用的第一个Windows Sockets函数。它允许应用程序或DLL指明Windows Sockets API的版本号及获得特定Windows Sockets实现的细节。应用程序或DLL只能在一次成功的WSAStartup()调用之后才能调用进一步的Windows Sockets API函数。
WSADATA wsaData; if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) { printf(&#34;Failed to load Winsock&#34;); return; } 对应的，在程序结束前，调用以下语句
WSACleanup(); 2) 建立和断开与服务器的连接 通过IP和端口与服务器建立Socket通信通道，对于UR机器人，缺省的IP和端口为192.168.0.77:30003。
首先建立连接：
char* pIp = &#34;192.168.0.77&#34;; int nPort = 30003; SOCKADDR_IN addrSrv; addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(nPort); //	addrSrv.sin_addr.S_un.S_addr = inet_addr(pIp); inet_pton(AF_INET, pIp, &amp;addrSrv.sin_addr); //创建套接字 m_sockData = socket(AF_INET, SOCK_STREAM, 0); if (INVALID_SOCKET == m_sockData) { m_nError = WSAGetLastError(); return; } //向服务器发出连接请求 if (connect(m_sockData, (struct sockaddr*)&amp;addrSrv, sizeof(addrSrv)) == INVALID_SOCKET) { m_nError = WSAGetLastError(); CString msg; msg." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6d632063b1cdbbc54eeab4cc2441ea06/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-22T10:09:26+08:00" />
<meta property="article:modified_time" content="2020-02-22T10:09:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Windows Sockets 网络编程及UR机器人通信数据解析代码</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1 前言</h2> 
<p>之前写了几篇关于UR机器人网络控制的文章：《<a href="https://blog.csdn.net/hangl_ciom/article/details/97612246">UR机器人返回信息格式解析</a>》、《<a href="https://blog.csdn.net/hangl_ciom/article/details/97610882">UR机器人通信端口和协议</a>》，有不少读者问关于编程实现方面的问题，因此，这里上传有关的代码，供同行参考。</p> 
<h2><a id="2__2"></a>2 包含内容</h2> 
<p>我这里是用VS2015编译环境，用C/C++语言实现的。<br> 实际上没有高深的技术，涉及到两个内容：</p> 
<ol><li>Windows Sockets网络编程；</li><li>UR机器人返回数据内容解析，包括数据字节的转换。</li></ol> 
<h2><a id="3__7"></a>3 程序实现</h2> 
<h3><a id="31_Windows_Sockets_8"></a>3.1 Windows Sockets网络编程</h3> 
<h4><a id="1_Windows_Sockets_9"></a>1) Windows Sockets初始化</h4> 
<p>在程序的开始，进行Windows Sockets初始化。WSAStartup必须是应用程序或DLL调用的第一个Windows Sockets函数。它允许应用程序或DLL指明Windows Sockets API的版本号及获得特定Windows Sockets实现的细节。应用程序或DLL只能在一次成功的WSAStartup()调用之后才能调用进一步的Windows Sockets API函数。</p> 
<pre><code class="prism language-C++">	WSADATA wsaData;
	if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)
	{
		printf("Failed to load Winsock");
		return;
	}
</code></pre> 
<p>对应的，在程序结束前，调用以下语句</p> 
<pre><code class="prism language-C++">	WSACleanup();
</code></pre> 
<h4><a id="2__23"></a>2) 建立和断开与服务器的连接</h4> 
<p>通过IP和端口与服务器建立Socket通信通道，对于UR机器人，缺省的IP和端口为192.168.0.77:30003。<br> 首先建立连接：</p> 
<pre><code class="prism language-C++">	char* pIp = "192.168.0.77";
	int nPort = 30003;
	SOCKADDR_IN addrSrv;
	addrSrv.sin_family = AF_INET;
	addrSrv.sin_port = htons(nPort);
	//	addrSrv.sin_addr.S_un.S_addr = inet_addr(pIp);
	inet_pton(AF_INET, pIp, &amp;addrSrv.sin_addr);

	//创建套接字
	m_sockData = socket(AF_INET, SOCK_STREAM, 0);
	if (INVALID_SOCKET == m_sockData) {
		m_nError = WSAGetLastError();
		return;
	}

	//向服务器发出连接请求
	if (connect(m_sockData, (struct  sockaddr*)&amp;addrSrv, sizeof(addrSrv)) == INVALID_SOCKET)
	{
		m_nError = WSAGetLastError();
		CString msg;
		msg.Format(_T("Connect Error=%d"), m_nError);
		AfxMessageBox(msg);
		return;
	}
	//启动接收线程
	m_bThread=true;
	AfxBeginThread(Thread_RecvData, this, THREAD_PRIORITY_IDLE);
</code></pre> 
<p>对应的，最后程序退出或不再使用此通道时，断开连接：</p> 
<pre><code>	if (m_sockData != INVALID_SOCKET)
	{
		shutdown(m_sockData, 0);
		closesocket(m_sockData);
		m_sockData = INVALID_SOCKET;
	}
</code></pre> 
<h4><a id="3__64"></a>3) 数据接收</h4> 
<p>网络Sockets数据是异步传送的，且使用的接收函数recv()是阻塞式的，即在没有接收事件发生（正常接收到数据、发生错误、接收超时、……）前，该函数是不返回的，所以我把数据接收放在一个专门的接收线程里。</p> 
<pre><code class="prism language-C++">UINT CURCommDlg::Thread_RecvData(PVOID pParam)
{
	CURCommDlg* pDlg = (CURCommDlg*)pParam;
	int nLen = 1024;
	char* recvBuf = new char[nLen];
	memset(recvBuf, 0, nLen);
	while (pDlg-&gt;m_bThread)
	{
		//	//接收数据
		int ret = recv(pDlg-&gt;m_sockData, recvBuf, nLen, 0);
		if (ret&gt;0)
		{
			pDlg-&gt;OnRecvData(recvBuf, ret);
		}
		else
		{
			//recv error
			pDlg-&gt;m_nError = WSAGetLastError();
			closesocket(pDlg-&gt;m_sockData);
			break;
		}
	}
	delete[]recvBuf;
	pDlg-&gt;m_bThread = false;
	return 1;
}
</code></pre> 
<h3><a id="32__94"></a>3.2 数据内容解析</h3> 
<p>以上网络接收到的数据，发送到OnRecvData函数中进行数据解析。<br> 这里按照UR机器人的30003端口返回数据格式进行解析，具体数据格式见《<a href="https://blog.csdn.net/hangl_ciom/article/details/97612246">UR机器人返回信息格式解析</a>》。</p> 
<pre><code class="prism language-C++">void CURCommDlg::OnRecvData(char* pData, int nLen)
{
	DWORD dwPackLen;
	dwPackLen = GetDword((PBYTE)pData);
	double data1[54];
	int n;
	for (n = 0; n &lt; 54; n++)
	{
		data1[n] = GetDouble((PBYTE)(pData + 12 + n * 8));
	}
	double data2[30];
	for (n = 0; n &lt; 30; n++)
	{
		data2[n] = GetDouble((PBYTE)(pData + 444 + n * 8));
	}
	for (n = 0; n &lt; 6; n++)
		m_dCurPos[n] = data2[n];
}
</code></pre> 
<p>其中，由于UR返回数据为Big-Endian，而计算机中的数据为Little-Endian，必须进行数据字节转换，所以编了以下两个函数完成，实际上以下的GetDword函数和htonl()函数功能一样。</p> 
<pre><code class="prism language-C++">double GetDouble(PBYTE pData)
{
	double t;
	PBYTE p = (PBYTE)&amp;t;
	int i;
	for (i = 0; i &lt; 8; i++)
	{
		p[i] = pData[7 - i];
	}
	return t;
}

DWORD GetDword(PBYTE pData)
{
	DWORD t;
	PBYTE p = (PBYTE)&amp;t;
	int i;
	for (i = 0; i &lt; 4; i++)
	{
		p[i] = pData[3 - i];
	}
	return t;
}
</code></pre> 
<p>解析出来的数据就可以用于程序的其他用途了，例如以上解析函数中的m_dCurPos[6]就是机器人的当前实时位姿的六个数据。<br> 以上代码的完整工程可查看<a href="https://download.csdn.net/download/hangl_ciom/12181385">下载页面</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/24213ec7d317f79bcddbb6d7ee8ff89f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【JAVA - Druid】Druid数据库连接池 -- 快速入门使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f69df1161a46e665ec509e2105190df3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; 函数返回值为对象时调用复制构造函数的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>