<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React生命周期方法和错误处理方法（挂载、更新、卸载、函数组件中生命周期替代方法useEffect、纯函数、副作用等） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="React生命周期方法和错误处理方法（挂载、更新、卸载、函数组件中生命周期替代方法useEffect、纯函数、副作用等）" />
<meta property="og:description" content="目录
React生命周期方法
挂载
contructor()
static getDerivedStateFromProps(props,state)
render()
componentDidMount()
更新
static getDerivedStateFromProps(props,state)
shouldComponentUpdate(nextProps,nextState)
render()
getSnapshotBeforeUpdate(prevProps,prevState)
componentDidUpdate(prevProps, prevState, snapshot)
卸载
componentWillUnmount()
函数组建中生命周期替代方法 useEffect
代替componentDidMount
代替componentDidUpdate
代替 componentWillUnmount
生命周期错误处理方法
相关概念
纯函数
副作用
static getDerivedStateFromError(error)
componentDidCatch(error,info)
React生命周期方法 以下生命周期方法按写的先后顺序被调用。
挂载 当组件实例被创建并插入 DOM 中时调用。
contructor() 如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。
一般只用于以下两种情况
通过给 this.state 赋值对象来初始化内部state。为事件处理函数绑定实例。 constructor(props) { super(props); // 不要在这里调用 this.setState() this.state = { counter: 0 }; this.handleClick = this.handleClick.bind(this); } 注意
调用了super(props) 后才能在构造函数里使用props变量。将props属性赋值给state后，props改变不会引起state的改变，应该在render函数中直接使用this.props.属性名。 static getDerivedStateFromProps(props,state) 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。参数props,state都为更新后的内容，最后的返回的对象用于更新state。如果返回 null 则不更新任何内容。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7d4ce96be7798634265ab0dc7297780c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-08T10:13:52+08:00" />
<meta property="article:modified_time" content="2022-03-08T10:13:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React生命周期方法和错误处理方法（挂载、更新、卸载、函数组件中生命周期替代方法useEffect、纯函数、副作用等）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95" rel="nofollow">React生命周期方法</a></p> 
<p id="%E6%8C%82%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%E6%8C%82%E8%BD%BD" rel="nofollow">挂载</a></p> 
<p id="contructor()-toc" style="margin-left:80px;"><a href="#contructor%28%29" rel="nofollow">contructor()</a></p> 
<p id="static%20getDerivedStateFromProps(props%2Cstate)-toc" style="margin-left:80px;"><a href="#static%20getDerivedStateFromProps%28props%2Cstate%29" rel="nofollow">static getDerivedStateFromProps(props,state)</a></p> 
<p id="render()-toc" style="margin-left:80px;"><a href="#render%28%29" rel="nofollow">render()</a></p> 
<p id="componentDidMount()-toc" style="margin-left:80px;"><a href="#componentDidMount%28%29" rel="nofollow">componentDidMount()</a></p> 
<p id="%E6%9B%B4%E6%96%B0-toc" style="margin-left:40px;"><a href="#%E6%9B%B4%E6%96%B0" rel="nofollow">更新</a></p> 
<p id="static%20getDerivedStateFromProps(props%2Cstate)-toc" style="margin-left:80px;"><a href="#static%20getDerivedStateFromProps%28props%2Cstate%29" rel="nofollow">static getDerivedStateFromProps(props,state)</a></p> 
<p id="shouldcomponentupdate-toc" style="margin-left:80px;"><a href="#shouldcomponentupdate" rel="nofollow">shouldComponentUpdate(nextProps,nextState)</a></p> 
<p id="render()-toc" style="margin-left:80px;"><a href="#render%28%29" rel="nofollow">render()</a></p> 
<p id="getSnapshotBeforeUpdate(prevProps%2CprevState)-toc" style="margin-left:80px;"><a href="#getSnapshotBeforeUpdate%28prevProps%2CprevState%29" rel="nofollow">getSnapshotBeforeUpdate(prevProps,prevState)</a></p> 
<p id="componentDidUpdate(prevProps%2C%20prevState%2C%20snapshot)-toc" style="margin-left:80px;"><a href="#componentDidUpdate%28prevProps%2C%20prevState%2C%20snapshot%29" rel="nofollow">componentDidUpdate(prevProps, prevState, snapshot)</a></p> 
<p id="%E5%8D%B8%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%E5%8D%B8%E8%BD%BD" rel="nofollow">卸载</a></p> 
<p id="componentwillunmount-toc" style="margin-left:80px;"><a href="#componentwillunmount" rel="nofollow">componentWillUnmount()</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%BB%84%E5%BB%BA%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95%20useEffect-toc" style="margin-left:40px;"><a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E5%BB%BA%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95%20useEffect" rel="nofollow">函数组建中生命周期替代方法 useEffect</a></p> 
<p id="%E4%BB%A3%E6%9B%BFcomponentDidMount-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E6%9B%BFcomponentDidMount" rel="nofollow">代替componentDidMount</a></p> 
<p id="%E4%BB%A3%E6%9B%BFcomponentDidUpdate-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E6%9B%BFcomponentDidUpdate" rel="nofollow">代替componentDidUpdate</a></p> 
<p id="%E4%BB%A3%E6%9B%BF%C2%A0componentWillUnmount-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E6%9B%BF%C2%A0componentWillUnmount" rel="nofollow">代替 componentWillUnmount</a></p> 
<p id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" rel="nofollow">生命周期错误处理方法</a></p> 
<p id="%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">相关概念</a></p> 
<p id="%E7%BA%AF%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E7%BA%AF%E5%87%BD%E6%95%B0" rel="nofollow">纯函数</a></p> 
<p id="%E5%89%AF%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E5%89%AF%E4%BD%9C%E7%94%A8" rel="nofollow">副作用</a></p> 
<p id="static%20getDerivedStateFromError(error)-toc" style="margin-left:80px;"><a href="#static%20getDerivedStateFromError%28error%29" rel="nofollow">static getDerivedStateFromError(error)</a></p> 
<p id="componentDidCatch(error%2Cinfo)-toc" style="margin-left:80px;"><a href="#componentDidCatch%28error%2Cinfo%29" rel="nofollow">componentDidCatch(error,info)</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95">React生命周期方法</h2> 
<p>以下生命周期方法按写的先后顺序被调用。</p> 
<h3 id="%E6%8C%82%E8%BD%BD">挂载</h3> 
<p>当组件实例被创建并插入 DOM 中时调用。</p> 
<h4 id="contructor()">contructor()</h4> 
<p><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p> 
<p>一般只用于以下两种情况</p> 
<ul><li><strong>通过给 <code>this.state</code> 赋值对象来初始化内部state</strong>。</li><li><strong>为事件处理函数绑定实例</strong>。</li></ul> 
<pre><code class="language-TypeScript">constructor(props) {
  super(props);
  // 不要在这里调用 this.setState()
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}</code></pre> 
<p>注意</p> 
<ul><li><strong>调用了super(props) 后才能在构造函数里使用props变量</strong>。</li><li><strong>将props属性赋值给state后，props改变不会引起state的改变</strong>，应该在render函数中直接使用this.props.属性名。</li></ul> 
<p></p> 
<h4 id="static%20getDerivedStateFromProps(props%2Cstate)">static getDerivedStateFromProps(props,state)</h4> 
<p>在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。参数props,state都为更新后的内容，最后的返回的对象用于更新state。如果返回 <code>null</code> 则不更新任何内容。</p> 
<p></p> 
<h4 id="render()">render()</h4> 
<p><code>render()</code> 方法是 class 组件中唯一<strong>必须实现</strong>的方法。</p> 
<p>当 <code>render</code> 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回以下类型之一：</p> 
<ul><li><strong>React 元素</strong>。通常通过 JSX 创建。例如，<code>&lt;div /&gt;</code> 会被 React 渲染为 DOM 节点，<code>&lt;MyComponent /&gt;</code> 会被 React 渲染为自定义组件，无论是 <code>&lt;div /&gt;</code> 还是 <code>&lt;MyComponent /&gt;</code> 均为 React 元素。</li><li><strong>数组或 fragments</strong>。 用于返回多个元素。 <a href="https://zh-hans.reactjs.org/docs/fragments.html" rel="nofollow" title="Fragments">Fragments</a>相当于一个容器，但不用增加任何dom节点。</li><li><strong>Portals</strong>。可以渲染子节点到不同的 DOM 子树中。 <p><a href="https://zh-hans.reactjs.org/docs/portals.html" rel="nofollow" title="Portals">Portals</a> 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点方法。本身react父子组件上dom的关系是包含关系，而portal可以将子组件的dom渲染到外层窗口，比如将dom渲染成兄弟关系。常用语对话框、悬浮卡以及提示框。</p> </li><li><strong>字符串或数值类型</strong>。它们在 DOM 中会被渲染为文本节点</li><li><strong>布尔类型或 <code>null</code></strong>。什么都不渲染。（主要用于支持返回 <code>test &amp;&amp; &lt;Child /&gt;</code> 的模式，其中 test 为布尔类型。)</li></ul> 
<p></p> 
<h4 id="componentDidMount()">componentDidMount()</h4> 
<p>会在组件挂载后（插入 DOM 树中）立即调用。这里可以<strong>调用 <code>setState()</code></strong>。它将触发<strong>额外渲染</strong>，但此渲染会<strong>发生在浏览器更新屏幕之前</strong>。如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</p> 
<p></p> 
<h3 id="%E6%9B%B4%E6%96%B0">更新</h3> 
<p><strong>当组件的 props 或 state 发生变化时会触发更新</strong>。</p> 
<h4>static getDerivedStateFromProps(props,state)</h4> 
<p>同上</p> 
<p></p> 
<h4 id="shouldcomponentupdate"><code>shouldComponentUpdate(nextProps,nextState)</code></h4> 
<p><strong>根据函数的返回值判断是否更新组件</strong>，返回false时，后面的生命周期方法都不会执行了。</p> 
<p><strong>此时this.state、this.props还未改变</strong>，参数中的nextProps和nextState是将要改变成的值，默认返回true（更新组件）。</p> 
<p>注意<strong>首次渲染（挂载时）或使用 <code>forceUpdate()</code> 时不会调用该方法</strong>。</p> 
<p></p> 
<h4>render()</h4> 
<p>同上</p> 
<p></p> 
<h4 id="getSnapshotBeforeUpdate(prevProps%2CprevState)"><code>getSnapshotBeforeUpdate(prevProps,prevState)</code></h4> 
<p>此时this.state、this.props已经改变了，参数中preProps、prevState是改变之前的值。 返回值为componentDidUpdate中的第三个参数。</p> 
<p>用于组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。 </p> 
<p></p> 
<h4 id="componentDidUpdate(prevProps%2C%20prevState%2C%20snapshot)">componentDidUpdate(prevProps, prevState, snapshot)</h4> 
<p>参数见上getSnapshotBeforeUpdate。</p> 
<p>注意：可以在 <code>componentDidUpdate()</code> 中<strong>直接调用 <code>setState()</code></strong>，但请注意<strong>它必须被包裹在一个条件语句里</strong>，正如上述的例子那样进行处理，否则会导致死循环。</p> 
<p></p> 
<h3 id="%E5%8D%B8%E8%BD%BD">卸载</h3> 
<p>当组件从 DOM 中移除时会调用。</p> 
<h4 id="componentwillunmount"><code>componentWillUnmount()</code></h4> 
<p>组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</p> 
<p>注意这里<strong>不应调用 <code>setState()</code></strong>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p> 
<p></p> 
<h3 id="%E5%87%BD%E6%95%B0%E7%BB%84%E5%BB%BA%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95%20useEffect">函数组建中生命周期替代方法 useEffect</h3> 
<p>相当于<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的组合体。</p> 
<h4 id="%E4%BB%A3%E6%9B%BFcomponentDidMount">代替<code>componentDidMount</code></h4> 
<p>传递一个空数组（[]）作为第二个参数，这个 Effect 将永远不会重复执行，因此可以达到<code>componentDidMount</code>的效果。</p> 
<pre><code class="language-TypeScript">function AComponent(){
    React.useEffect(()=&gt;{
        console.log("componentDidMount");
    },[]);
}</code></pre> 
<h4 id="%E4%BB%A3%E6%9B%BFcomponentDidUpdate">代替<code>componentDidUpdate</code></h4> 
<p><code>不传第二个参数</code></p> 
<pre><code class="language-TypeScript">function AComponent(props){
    React.useEffect(()=&gt;{
        console.log("每次更新后对会执行");
    });
}</code></pre> 
<h4 id="%E4%BB%A3%E6%9B%BF%C2%A0componentWillUnmount">代替 <code>componentWillUnmount</code></h4> 
<p><code>useEffect</code>可以返回一个函数，该函数将在组件被卸载时的执行，可以等效于<code>componentWillUnmount</code>。</p> 
<pre><code class="language-TypeScript">function AComponent(){
    React.useEffect(()=&gt;{
        return function cleanup() { console.log("组件被卸载componentWillUnmount")};
    },[]);
}</code></pre> 
<p></p> 
<h2 id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">生命周期错误处理方法</h2> 
<p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时调用。 </p> 
<h3 id="%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">相关概念</h3> 
<h4 id="%E7%BA%AF%E5%87%BD%E6%95%B0">纯函数</h4> 
<ul><li>确定的输入，产生确定的输出，与执行次数、时间无关</li><li>不产生副作用</li></ul> 
<p>例子:const add=x=&gt; x+1</p> 
<h4 id="%E5%89%AF%E4%BD%9C%E7%94%A8">副作用</h4> 
<p>具有不确定性的操作，你都可以理解为是不纯的，不纯的那么意味可能带来副作用。</p> 
<p>常见副作用：</p> 
<ul><li>系统IO相关API</li><li>Date.now()、Math.random()等不确定性方法</li><li>在函数体内修改函数体外变量的值</li><li>在函数体内修改函数参数的值</li><li>调用会产生副作用的函数</li><li>http请求等</li></ul> 
<h4 id="static%20getDerivedStateFromError(error)">static getDerivedStateFromError(error)</h4> 
<p>在后代组件抛出错误后被调用。 它将抛出的错误作为error参数，并返回一个对象更新 state。</p> 
<p><code>注意该方法<strong>会</strong></code><strong>在<code>渲染</code>阶段调用，因此不允许出现副作用</strong>。理解为在render之前调用，有副作用的话可能会导致死循环。</p> 
<p></p> 
<h4 id="componentDidCatch(error%2Cinfo)">componentDidCatch(error,info)</h4> 
<p>在后代组件抛出错误后被调用，<strong>用于记录错误</strong>。参数<code>error为</code>抛出的错误，<code>info为</code>带有 <code>componentStack</code> key 的对象，其中包含<a href="https://zh-hans.reactjs.org/docs/error-boundaries.html#component-stack-traces" rel="nofollow" title="有关组件引发错误的栈信息">有关组件引发错误的栈信息</a>。</p> 
<p>注意该方法<strong>在“提交”阶段被调用，因此允许执行副作用</strong>。render之后调用，不会导致死循环。</p> 
<p>在开发模式下，错误会冒泡至 <code>window</code>，这意味着任何 <code>window.onerror</code> 或 <code>window.addEventListener('error', callback)</code> 会中断这些已经被 <code>componentDidCatch()</code> 捕获的错误。</p> 
<p>相反，在生产模式下，错误不会冒泡，这意味着任何根错误处理器只会接受那些没有显式地被 <code>componentDidCatch()</code> 捕获的错误。</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb41ac541db45c97c0ec56ffcb1bae70/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对接抖店API-03 获取订单列表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ad3100bfe81c986ce4f7b0232fbd4de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[hive]去掉字段中的空格</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>