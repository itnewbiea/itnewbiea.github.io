<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>理解Python协程:从yield/send到yield from再到async/await - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="理解Python协程:从yield/send到yield from再到async/await" />
<meta property="og:description" content="Python中的协程大概经历了如下三个阶段： 1. 最初的生成器变形yield/send 2. 引入@asyncio.coroutine和yield from 3. 在最近的Python3.5版本中引入async/await关键字
一、生成器变形yield/send 普通函数中如果出现了yield关键字，那么该函数就不再是普通函数，而是一个生成器。
def mygen(alist): while len(alist) &gt; 0: c = randint(0, len(alist)-1) yield alist.pop(c) a = [&#34;aa&#34;,&#34;bb&#34;,&#34;cc&#34;] c=mygen(a) print(c) 输出：&lt;generator object mygen at 0x02E5BF00&gt; 像上面代码中的c就是一个生成器。生成器就是一种迭代器，可以使用for进行迭代。生成器函数最大的特点是可以接受外部传入的一个变量，并根据变量内容计算结果后返回。 这一切都是靠生成器内部的send()函数实现的。
def gen(): value=0 while True: receive=yield value if receive==&#39;e&#39;: break value = &#39;got: %s&#39; % receive g=gen() print(g.send(None)) print(g.send(&#39;hello&#39;)) print(g.send(123456)) print(g.send(&#39;e&#39;)) 上面生成器函数中最关键也是最易理解错的，就是receive=yield value这句,如果对循环体的执行步骤理解错误，就会失之毫厘，差之千里。 其实receive=yield value包含了3个步骤： 1、向函数外抛出（返回）value 2、暂停(pause)，等待next()或send()恢复 3、赋值receive=MockGetValue() 。 这个MockGetValue()是假想函数，用来接收send()发送进来的值
执行流程： 1、通过g.send(None)或者next(g)启动生成器函数，并执行到第一个yield语句结束的位置。这里是关键，很多人就是在这里搞糊涂的。运行receive=yield value语句时，我们按照开始说的拆开来看，实际程序只执行了1，2两步，程序返回了value值，并暂停(pause)，并没有执行第3步给receive赋值。因此yield value会输出初始值0。这里要特别注意：在启动生成器函数时只能send(None),如果试图输入其它的值都会得到错误提示信息。
2、通过g.send(&#39;hello&#39;)，会传入hello，从上次暂停的位置继续执行，那么就是运行第3步，赋值给receive。然后计算出value的值，并回到while头部，遇到yield value，程序再次执行了1，2两步，程序返回了value值，并暂停(pause)。此时yield value会输出”got: hello”，并等待send()激活。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8a2c11e8144a2323ac76153f69e75a11/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-27T10:16:20+08:00" />
<meta property="article:modified_time" content="2017-10-27T10:16:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">理解Python协程:从yield/send到yield from再到async/await</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Python中的协程大概经历了如下三个阶段： <br> 1. 最初的生成器变形yield/send <br> 2. 引入@asyncio.coroutine和yield from <br> 3. 在最近的Python3.5版本中引入async/await关键字</p> 
<h2 id="一生成器变形yieldsend">一、生成器变形yield/send</h2> 
<p>普通函数中如果出现了yield关键字，那么该函数就不再是普通函数，而是一个生成器。</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mygen</span><span class="hljs-params">(alist)</span>:</span>
    <span class="hljs-keyword">while</span> len(alist) &gt; <span class="hljs-number">0</span>:
        c = randint(<span class="hljs-number">0</span>, len(alist)-<span class="hljs-number">1</span>)
        <span class="hljs-keyword">yield</span> alist.pop(c)
a = [<span class="hljs-string">"aa"</span>,<span class="hljs-string">"bb"</span>,<span class="hljs-string">"cc"</span>]
c=mygen(a)
print(c)

输出：&lt;generator object mygen at <span class="hljs-number">0x02E5BF00</span>&gt;</code></pre> 
<p>像上面代码中的c就是一个生成器。生成器就是一种迭代器，可以使用for进行迭代。生成器函数最大的特点是可以接受外部传入的一个变量，并根据变量内容计算结果后返回。 <br> 这一切都是靠生成器内部的send()函数实现的。</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen</span><span class="hljs-params">()</span>:</span>
    value=<span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        receive=<span class="hljs-keyword">yield</span> value
        <span class="hljs-keyword">if</span> receive==<span class="hljs-string">'e'</span>:
            <span class="hljs-keyword">break</span>
        value = <span class="hljs-string">'got: %s'</span> % receive

g=gen()
print(g.send(<span class="hljs-keyword">None</span>))    
print(g.send(<span class="hljs-string">'hello'</span>))
print(g.send(<span class="hljs-number">123456</span>))
print(g.send(<span class="hljs-string">'e'</span>))</code></pre> 
<p>上面生成器函数中最关键也是最易理解错的，就是receive=yield value这句,如果对循环体的执行步骤理解错误，就会失之毫厘，差之千里。 <br> 其实receive=yield value包含了3个步骤： <br> 1、向函数外抛出（返回）value <br> 2、暂停(pause)，等待next()或send()恢复 <br> 3、赋值receive=MockGetValue() 。 这个MockGetValue()是假想函数，用来接收send()发送进来的值</p> 
<p>执行流程： <br> 1、通过g.send(None)或者next(g)启动生成器函数，并执行到第一个yield语句结束的位置。这里是关键，很多人就是在这里搞糊涂的。运行<code>receive=yield value</code>语句时，我们按照开始说的拆开来看，实际程序只执行了1，2两步，程序返回了value值，并暂停(pause)，并没有执行第3步给receive赋值。因此yield value会输出初始值0。<strong>这里要特别注意：在启动生成器函数时只能send(None),如果试图输入其它的值都会得到错误提示信息。</strong></p> 
<p>2、通过<code>g.send('hello')</code>，会传入hello，从上次暂停的位置继续执行，那么就是运行第3步，赋值给receive。然后计算出value的值，并回到while头部，遇到yield value，程序再次执行了1，2两步，程序返回了value值，并暂停(pause)。此时yield value会输出”got: hello”，并等待send()激活。</p> 
<p>3、通过g.send(123456)，会重复第2步，最后输出结果为”got: 123456″。</p> 
<p>4、当我们g.send(‘e’)时，程序会执行break然后推出循环，最后整个函数执行完毕，所以会得到StopIteration异常。</p> 
<p>从上面可以看出， 在第一次send(None)启动生成器（执行1–&gt;2，通常第一次返回的值没有什么用）之后，对于外部的每一次send()，生成器的实际在循环中的运行顺序是3–&gt;1–&gt;2，也就是先获取值，然后dosomething，然后返回一个值，再暂停等待。</p> 
<h2 id="二yield-from">二、yield from</h2> 
<p>看一段代码：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g1</span><span class="hljs-params">()</span>:</span>     
     <span class="hljs-keyword">yield</span>  range(<span class="hljs-number">5</span>)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g2</span><span class="hljs-params">()</span>:</span>
     <span class="hljs-keyword">yield</span>  <span class="hljs-keyword">from</span> range(<span class="hljs-number">5</span>)

it1 = g1()
it2 = g2()
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> it1:
    print(x)

<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> it2:
    print(x)</code></pre> 
<p>输出： <br> range(0, 5) <br> 0 <br> 1 <br> 2 <br> 3 <br> 4</p> 
<p>这说明yield就是将range这个可迭代对象直接返回了。 <br> 而yield from解析了range对象，将其中每一个item返回了。 <br> <code>yield from iterable</code>本质上等于<code>for item in iterable: yield item</code>的缩写版 <br> 来看一下例子，假设我们已经编写好一个斐波那契数列函数</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fab</span><span class="hljs-params">(max)</span>:</span>
     n,a,b = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>
     <span class="hljs-keyword">while</span> n &lt; max:
          <span class="hljs-keyword">yield</span> b
          <span class="hljs-comment"># print b</span>
          a, b = b, a + b
          n = n + <span class="hljs-number">1</span>
f=fab(<span class="hljs-number">5</span>) </code></pre> 
<p>fab不是一个普通函数，而是一个生成器。因此fab(5)并没有执行函数，而是返回一个生成器对象(生成器一定是迭代器iterator，迭代器一定是可迭代对象iterable) <br> 现在我们来看一下，假设要在fab()的基础上实现一个函数，调用起始都要记录日志</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f_wrapper</span><span class="hljs-params">(fun_iterable)</span>:</span>
    print(<span class="hljs-string">'start'</span>)
    <span class="hljs-keyword">for</span> item  <span class="hljs-keyword">in</span> fun_iterable:
        <span class="hljs-keyword">yield</span> item
     print(<span class="hljs-string">'end'</span>)
wrap = f_wrapper(fab(<span class="hljs-number">5</span>))
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> wrap:
    print(i,end=<span class="hljs-string">' '</span>)</code></pre> 
<p>现在使用yield from代替for循环</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> logging
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f_wrapper2</span><span class="hljs-params">(fun_iterable)</span>:</span>
    print(<span class="hljs-string">'start'</span>)
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> fun_iterable  <span class="hljs-comment">#注意此处必须是一个可生成对象</span>
    print(<span class="hljs-string">'end'</span>)
wrap = f_wrapper2(fab(<span class="hljs-number">5</span>))
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> wrap:
    print(i,end=<span class="hljs-string">' '</span>)</code></pre> 
<p>再强调一遍：yield from后面必须跟iterable对象(可以是生成器，迭代器)</p> 
<h2 id="三asynciocoroutine和yield-from">三、asyncio.coroutine和yield from</h2> 
<p>yield from在asyncio模块中得以发扬光大。之前都是我们手工切换协程，现在当声明函数为协程后，我们通过事件循环来调度协程。</p> 
<p>先看示例代码：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> asyncio,random
<span class="hljs-decorator">@asyncio.coroutine</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smart_fib</span><span class="hljs-params">(n)</span>:</span>
    index = <span class="hljs-number">0</span>
    a = <span class="hljs-number">0</span>
    b = <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> index &lt; n:
        sleep_secs = random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>)
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> asyncio.sleep(sleep_secs) <span class="hljs-comment">#通常yield from后都是接的耗时操作</span>
        print(<span class="hljs-string">'Smart one think {} secs to get {}'</span>.format(sleep_secs, b))
        a, b = b, a + b
        index += <span class="hljs-number">1</span>

<span class="hljs-decorator">@asyncio.coroutine</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stupid_fib</span><span class="hljs-params">(n)</span>:</span>
    index = <span class="hljs-number">0</span>
    a = <span class="hljs-number">0</span>
    b = <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> index &lt; n:
        sleep_secs = random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>)
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> asyncio.sleep(sleep_secs) <span class="hljs-comment">#通常yield from后都是接的耗时操作</span>
        print(<span class="hljs-string">'Stupid one think {} secs to get {}'</span>.format(sleep_secs, b))
        a, b = b, a + b
        index += <span class="hljs-number">1</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    loop = asyncio.get_event_loop()
    tasks = [
        smart_fib(<span class="hljs-number">10</span>),
        stupid_fib(<span class="hljs-number">10</span>),
    ]
    loop.run_until_complete(asyncio.wait(tasks))
    print(<span class="hljs-string">'All fib finished.'</span>)
    loop.close()</code></pre> 
<p>yield from语法可以让我们方便地调用另一个generator。 <br> 本例中yield from后面接的asyncio.sleep()是一个coroutine(里面也用了yield from)，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。 <br> asyncio是一个基于事件循环的实现异步I/O的模块。通过yield from，我们可以将协程asyncio.sleep的控制权交给事件循环，然后挂起当前协程；之后，由事件循环决定何时唤醒asyncio.sleep,接着向后执行代码。 <br> 协程之间的调度都是由事件循环决定。 <br> <code>yield from asyncio.sleep(sleep_secs)</code> 这里不能用<code>time.sleep(1)</code>因为time.sleep()返回的是None，它不是iterable，还记得前面说的yield from后面必须跟iterable对象(可以是生成器，迭代器)。 <br> 所以会报错：</p> 
<blockquote> 
 <p>yield from time.sleep(sleep_secs) <br> TypeError: ‘NoneType’ object is not iterable</p> 
</blockquote> 
<h2 id="四async和await">四、async和await</h2> 
<p>弄清楚了asyncio.coroutine和yield from之后，在Python3.5中引入的async和await就不难理解了：可以将他们理解成asyncio.coroutine/yield from的完美替身。当然，从Python设计的角度来说，async/await让协程表面上独立于生成器而存在，将细节都隐藏于asyncio模块之下，语法更清晰明了。 <br> 加入新的关键字 async ，可以将任何一个普通函数变成协程</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> time,asyncio,random
async <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mygen</span><span class="hljs-params">(alist)</span>:</span>
    <span class="hljs-keyword">while</span> len(alist) &gt; <span class="hljs-number">0</span>:
        c = randint(<span class="hljs-number">0</span>, len(alist)-<span class="hljs-number">1</span>)
        print(alist.pop(c))
a = [<span class="hljs-string">"aa"</span>,<span class="hljs-string">"bb"</span>,<span class="hljs-string">"cc"</span>]
c=mygen(a)
print(c)
输出：
&lt;coroutine object mygen at <span class="hljs-number">0x02C6BED0</span>&gt;</code></pre> 
<p>在上面程序中，我们在前面加上async，该函数就变成一个协程了。</p> 
<p>但是async对生成器是无效的。async无法将一个生成器转换成协程。 <br> 还是刚才那段代码，我们把print改成yield</p> 
<pre class="prettyprint"><code class="language-python hljs ">async <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mygen</span><span class="hljs-params">(alist)</span>:</span>
    <span class="hljs-keyword">while</span> len(alist) &gt; <span class="hljs-number">0</span>:
        c = randint(<span class="hljs-number">0</span>, len(alist)-<span class="hljs-number">1</span>)
        <span class="hljs-keyword">yield</span> alist.pop(c)
a = [<span class="hljs-string">"ss"</span>,<span class="hljs-string">"dd"</span>,<span class="hljs-string">"gg"</span>]
c=mygen(a)
print(c)
</code></pre> 
<p>可以看到输出</p> 
<pre class="prettyprint"><code class=" hljs scala">&lt;async_generator <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">mygen</span> <span class="hljs-title">at</span> 0<span class="hljs-title">x02AA7170</span>&gt;</span></code></pre> 
<p>并不是coroutine 协程对象</p> 
<p>所以我们的协程代码应该是这样的</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> time,asyncio,random
async <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mygen</span><span class="hljs-params">(alist)</span>:</span>
    <span class="hljs-keyword">while</span> len(alist) &gt; <span class="hljs-number">0</span>:
        c = random.randint(<span class="hljs-number">0</span>, len(alist)-<span class="hljs-number">1</span>)
        print(alist.pop(c))
        await asyncio.sleep(<span class="hljs-number">1</span>) 
strlist = [<span class="hljs-string">"ss"</span>,<span class="hljs-string">"dd"</span>,<span class="hljs-string">"gg"</span>]
intlist=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
c1=mygen(strlist)
c2=mygen(intlist)
print(c1)</code></pre> 
<p>要运行协程，要用事件循环 <br> 在上面的代码下面加上：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
        loop = asyncio.get_event_loop()
        tasks = [
        c1,
        c2
        ]
        loop.run_until_complete(asyncio.wait(tasks))
        print(<span class="hljs-string">'All fib finished.'</span>)
        loop.close()</code></pre> 
<p>就可以看到交替执行的效果。</p> 
<p>本文参考 <br> <a href="http://python.jobbole.com/81911/" rel="nofollow noopener noreferrer" target="_blank">http://python.jobbole.com/81911/</a> <br> <a href="http://python.jobbole.com/86069/" rel="nofollow noopener noreferrer" target="_blank">http://python.jobbole.com/86069/</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e15b502e2d1c2b6e6b429a3a6896ce85/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python学习—matplotlib使用—plt.tick_params中which用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6083ae3ebe5983bd7ce0880f1ef6d86/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WebView match_parent wrap_content 无法显示，或显示特别小</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>