<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《Ensemble deep learning: A review》阅读笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《Ensemble deep learning: A review》阅读笔记" />
<meta property="og:description" content="论文标题 《Ensemble deep learning: A review》
集成深度学习： 综述
作者 M.A. Ganaie 和 Minghui Hu
来自印度理工学院印多尔分校数学系和南洋理工大学电气与电子工程学院
本文写的大而全。
初读 摘要 集成学习思想：
结合几个单独的模型以获得更好的泛化性能。
目前，深度学习架构与浅层或传统模型相比表现更好。深度集成学习模型结合了深度学习模型和集成学习的优点，使最终模型具有更好的泛化性能。
集成模型大致分类：
袋装法（bagging）提升法（boosting）堆叠法（stacking）基于负相关的深度集成模型（negative correlation based）显式/隐式集成（explicit/implicit）同质/异质集成（homogeneous/heterogeneous）基于决策融合策略的深度集成模型（decision fusion strategies based deep） 本文贡献：
本文回顾了最先进的深度集合模型，从而为研究人员提供了一个广泛的总结。本文还简要讨论了深度集成模型在不同领域的应用。最后，我们总结了这篇文章，并提出了未来的一些研究方向。 结论 这篇文章主要是总结和展望，后面写。
再读 Section 1 Introduction 深度学习（Deep learning）：
深度学习架构已成功应用于从图像、视频分类到医疗保健等广泛领域。这些模型的成功归功于多层处理架构更好的特征表示。
深度学习模型主要用于分类、回归和聚类问题：
**分类（classification）**问题：
分类问题被定义为根据从一组训练数据中学习到的假设 h h h 对新观察结果进行分类。假设 h h h 表示输入数据特征到适当目标标签/类别的映射。学习假设 h h h 的主要目的是尽可能接近真实的未知函数，以减少泛化误差。这些分类算法有多种应用，从医疗诊断到遥感都有。从数学上来看：
O c = h ( x , θ c ) , O c ∈ Z O_c=h(x,\theta_c),\ O_c\in\Z Oc​=h(x,θc​), Oc​∈Z" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/565bbc1fe033057685bf939f706c8a49/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T20:26:15+08:00" />
<meta property="article:modified_time" content="2024-01-02T20:26:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《Ensemble deep learning: A review》阅读笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>论文标题</h2> 
<p>《Ensemble deep learning: A review》</p> 
<p>集成深度学习： 综述</p> 
<h2><a id="_6"></a>作者</h2> 
<p>M.A. Ganaie 和 Minghui Hu</p> 
<p>来自印度理工学院印多尔分校数学系和南洋理工大学电气与电子工程学院</p> 
<p>本文写的大而全。</p> 
<h2><a id="_14"></a>初读</h2> 
<h3><a id="_16"></a>摘要</h3> 
<ul><li> <p>集成学习思想：</p> <p><strong>结合几个单独的模型以获得更好的泛化性能</strong>。</p> </li><li> <p>目前，深度学习架构与浅层或传统模型相比表现更好。深度集成学习模型结合了深度学习模型和集成学习的优点，使最终模型具有更好的泛化性能。</p> </li><li> <p><strong>集成模型大致分类</strong>：</p> 
  <ul><li>袋装法（bagging）</li><li>提升法（boosting）</li><li>堆叠法（stacking）</li><li>基于负相关的深度集成模型（negative correlation based）</li><li>显式/隐式集成（explicit/implicit）</li><li>同质/异质集成（homogeneous/heterogeneous）</li><li>基于决策融合策略的深度集成模型（decision fusion strategies based deep）</li></ul> </li><li> <p><strong>本文贡献</strong>：</p> 
  <ul><li>本文回顾了最先进的深度集合模型，从而为研究人员提供了一个广泛的总结。</li><li>本文还简要讨论了深度集成模型在不同领域的应用。最后，我们总结了这篇文章，并提出了未来的一些研究方向。</li></ul> </li></ul> 
<h3><a id="_40"></a>结论</h3> 
<p>这篇文章主要是总结和展望，后面写。</p> 
<h2><a id="_44"></a>再读</h2> 
<h3><a id="Section_1_Introduction_46"></a>Section 1 Introduction</h3> 
<ul><li> <p><strong>深度学习（Deep learning）</strong>：</p> 
  <ul><li> <p>深度学习架构已成功应用于从图像、视频分类到医疗保健等广泛领域。这些模型的成功归功于<strong>多层处理架构更好的特征表示</strong>。</p> </li><li> <p>深度学习模型主要用于分类、回归和聚类问题：</p> 
    <ul><li> <p>**分类（classification）**问题：</p> <p>分类问题被定义为<strong>根据从一组训练数据中学习到的假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                h 
               
              
             
               h 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 对新观察结果进行分类</strong>。假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
           
            
             
             
               h 
              
             
            
              h 
             
            
          </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 表示输入数据特征到适当目标标签/类别的映射。学习假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
           
            
             
             
               h 
              
             
            
              h 
             
            
          </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 的主要目的是尽可能接近真实的未知函数，以减少泛化误差。这些分类算法有多种应用，从医疗诊断到遥感都有。从数学上来看：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
            
             
              
               
               
                 O 
                
               
                 c 
                
               
              
                = 
               
              
                h 
               
              
                ( 
               
              
                x 
               
              
                , 
               
               
               
                 θ 
                
               
                 c 
                
               
              
                ) 
               
              
                , 
               
              
                  
               
               
               
                 O 
                
               
                 c 
                
               
              
                ∈ 
               
              
                Z 
               
              
             
               O_c=h(x,\theta_c),\ O_c\in\Z 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span></span></span><br> 参数字典：</p> 
      <ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                x 
               
              
             
               x 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 是输入特征向量，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
               
               
                 O 
                
               
                 c 
                
               
              
             
               O_c 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是样本 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                x 
               
              
             
               x 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 的类别，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                θ 
               
              
             
               \theta 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span></span></span></span></span> 是假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                h 
               
              
             
               h 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 的学习参数集，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                Z 
               
              
             
               Z 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">Z</span></span></span></span></span> 是类别标签集。</li></ul> </li><li> <p>**回归（regression）**问题</p> <p>回归问题<strong>处理的是连续决策，而不是离散类别</strong>。从数学上来看：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
            
             
              
               
               
                 O 
                
               
                 r 
                
               
              
                = 
               
              
                h 
               
              
                ( 
               
              
                x 
               
              
                , 
               
               
               
                 θ 
                
               
                 r 
                
               
              
                ) 
               
              
                , 
               
              
                  
               
               
               
                 O 
                
               
                 r 
                
               
              
                ∈ 
               
              
                R 
               
              
             
               O_r=h(x,\theta_r),\ O_r\in\R 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span></span><br> 参数字典：</p> 
      <ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                x 
               
              
             
               x 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 是观测向量，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
               
               
                 O 
                
               
                 r 
                
               
              
             
               O_r 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是输出，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
               
               
                 θ 
                
               
                 r 
                
               
              
             
               \theta_r 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                h 
               
              
             
               h 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 的学习参数集。</li></ul> </li><li> <p>**聚类（clustering）**问题</p> <p>从广义上讲，有监督分类、无监督分类、少量分类、一次分类等不同的分类方法。在此，我们只讨论有监督和无监督分类问题。在有监督学习中，假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
           
            
             
             
               h 
              
             
            
              h 
             
            
          </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 的建立是基于训练数据样本中提供的已知输出标签进行监督的，而<strong>在无监督学习中，由于训练数据中没有已知输出值，因此假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                h 
               
              
             
               h 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 的生成不需要任何监督。这种方法也称为聚类，根据训练数据中存在的相似性和不相似性生成假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                h 
               
              
             
               h 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span>。</strong></p> </li></ul> </li></ul> </li><li> <p><strong>集成学习（ensemble learning）</strong>：</p> 
  <ul><li> <p>机器学习的目的——<strong>泛化</strong>：</p> <p>一般来说，在机器学习领域生成假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             h 
            
           
          
            h 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 的目的是，在应用于未知数据时，假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             h 
            
           
          
            h 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 应该表现得更好。模型的性能是根据模型应用的领域来衡量的。</p> </li><li> <p>集成学习定义：</p> <p>事实证明，结合多个模型的预测结果是提高模型性能的有效方法。<strong>将来自不同模型的几种不同预测结果组合起来进行最终预测</strong>，被称为集成学习或集成模型。集成学习涉及多个模型以某种方式（如平均、投票）进行组合，从而<strong>使集成模型优于任何单个模型</strong>。</p> </li><li> <p>集成的<strong>理论依据</strong>：</p> <p>为了证明集成投票的平均值优于个人模式，孔多塞侯爵（Marquis de Condorcet）提出了一个定理，证明<strong>如果每个投票人正确的概率高于 0.5 且投票人是独立的，那么增加更多投票人就会增加多数票正确的概率，直到接近 1</strong>。虽然孔多塞侯爵是在政治学领域提出这个定理的，对机器学习领域并不了解，但正是类似的机制导致了集成模型的更好表现。孔多塞侯爵定理的假设也适用于集成。</p> </li><li> <p>集成学习取得成功的原因包括：统计（statistical）、计算（computational）和表征学习（representation learning）、偏差-方差分解（bias-variance decomposition）和强度-相关性（strength-correlation）。</p> </li></ul> </li><li> <p><strong>深度集成学习（deep ensemble learning）</strong>：</p> 
  <ul><li><strong>深度</strong>方面 
    <ul><li>在这个机器学习时代，深度学习通过分层特征学习机制自动提取高级特征，其中上层特征是在上一层/上几层的基础上生成的。自 ImageNet 大规模识别挑战赛（ILSVRC）比赛以来，深度学习已成功应用于不同领域，并取得了一流的性能。它在物体检测、语义分割、边缘检测和其他一些领域都取得了可喜的成果。</li><li>人们提出了不同的观点来理解深度学习模型如何学习特征，比如通过多层次的表征来学习概念的层次结构。虽然深度学习模型具有来自深度架构的优势，但仍存在一些瓶颈，如梯度消失/爆炸和退化问题，这些都阻碍了深度学习模型实现这一目标。</li><li>最近，通过高速公路（Highway）网络和残差（Residual）网络训练深度网络变得可行。这两种网络都能训练非常深度的网络。</li></ul> </li><li><strong>集成</strong>方面： 
    <ul><li>然而，考虑到计算成本，深度集成集合模型的训练是一项艰巨的任务。</li><li>众所周知，集成学习是提高深度学习模型性能的重要原因。因此，深度集成模型的目标是<strong>获得集成模型和深度模型的最佳模型</strong>。</li></ul> </li></ul> </li><li> <p><strong>相关工作</strong>：</p> <p>文献中有许多研究主要集中于集成学习的综述，如分类问题、回归问题和聚类问题中的集成模型学习。</p> 
  <ul><li>文献[23]对分类和回归模型进行了综述。</li><li>文献[24]全面回顾了集成方法和面临的挑战。虽然[24]提供了一些关于深度集成模型的见解，但未能全面评述深度集成学习，</li><li>而[25]则评述了生物信息学背景下的集成深度模型。过去十年间，不同的深度学习策略相继问世，促使这些模型在医疗保健、语音、图像分类、预测和其他应用等多个领域进行探索和创新。</li></ul> </li><li> <p><strong>本文贡献</strong>：</p> 
  <ul><li>从广义上讲，<strong>集成学习方法遵循经典方法、通用方法和不同的融合策略，以提高模型的性能</strong>。由于深度学习模型需要大量的计算和数据，因此在将多种算法的互补信息整合到一个统一框架中时，需要特别关注集成深度学习模型。</li><li><strong>集成深度学习模型需要处理多个问题</strong>，如如何在基线模型中诱导多样性，如何在实际应用中保持较低的训练时间和模型复杂度，如何融合互补算法的预测结果。多项研究以不同的方式处理了这些问题。</li><li>在这篇综述论文中，我们全面回顾了用于处理上述问题的不同方法。在本文中，我们将对深度集成模型进行全面评述。据我们所知，这是第一篇关于深度集成模型的全面综述论文。</li></ul> </li></ul> 
<p>本文接下来的内容安排如下： 第3节讨论了深度集成学习的理论方面，第4节讨论了深度集成策略中使用的不同方法，第5节给出了深度集成方法的应用，最后第6节给出了结论和未来方向。</p> 
<p><img src="https://images2.imgbox.com/56/9f/RClgnnko_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Section_2_Research_Methodology_128"></a>Section 2 Research Methodology</h3> 
<p>本综述中的研究是从谷歌学术（Google Scholar）和斯科普斯（Scopus）搜索引擎中搜索的。这些论文是以集成学习、集成深度学习、深度集成学习、深度集成为关键词的结果。根据标题和摘要对文章进行筛选，然后筛选全文版本。这些文章基于集成学习和深度学习方法进行阐述。</p> 
<h3><a id="Section_3_Theory_132"></a>Section 3 Theory</h3> 
<h4><a id="31_BiasVariance_Decomposition_134"></a>3.1 Bias-Variance Decomposition</h4> 
<p>偏差-方差分解</p> 
<p>最初，人们从理论上研究了针对回归问题的集成方法是否成功。</p> 
<ul><li> <p>Krogh 和 Vedelsby、Brown 等人通过<strong>模糊分解证明</strong>，与分类器的单个预测因子相比，适当的集成分类器能保证较小的平方误差。模糊性分解是针对<strong>基于单一数据集</strong>的集合方法给出的。</p> </li><li> <p>后来，[27, 28, 29, 30] 中引入了<strong>多数据集偏差-方差-协方差分解</strong>，其公式为：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
            
            
             
              
              
                E 
               
              
                [ 
               
              
                o 
               
              
                − 
               
              
                t 
               
               
               
                 ] 
                
               
                 2 
                
               
              
             
            
            
             
              
               
              
                = 
               
              
                b 
               
              
                i 
               
              
                a 
               
               
               
                 s 
                
               
                 2 
                
               
              
                + 
               
               
               
                 1 
                
               
                 M 
                
               
              
                v 
               
              
                a 
               
              
                r 
               
              
                + 
               
              
                ( 
               
              
                1 
               
              
                − 
               
               
               
                 1 
                
               
                 M 
                
               
              
                ) 
               
              
                c 
               
              
                o 
               
              
                v 
               
              
                a 
               
              
                r 
               
              
                , 
               
              
             
            
            
            
           
           
            
            
             
              
              
                b 
               
              
                i 
               
              
                a 
               
              
                s 
               
              
             
            
            
             
              
               
              
                = 
               
               
               
                 1 
                
               
                 M 
                
               
               
               
                 ∑ 
                
               
                 i 
                
               
              
                ( 
               
              
                E 
               
              
                [ 
               
               
               
                 o 
                
               
                 i 
                
               
              
                − 
               
              
                t 
               
              
                ] 
               
              
                ) 
               
              
                , 
               
              
             
            
            
            
           
           
            
            
             
              
              
                v 
               
              
                a 
               
              
                r 
               
              
             
            
            
             
              
               
              
                = 
               
               
               
                 1 
                
               
                 M 
                
               
               
               
                 ∑ 
                
               
                 i 
                
               
              
                E 
               
              
                [ 
               
               
               
                 o 
                
               
                 i 
                
               
              
                − 
               
              
                E 
               
              
                [ 
               
               
               
                 o 
                
               
                 i 
                
               
              
                ] 
               
               
               
                 ] 
                
               
                 2 
                
               
              
                , 
               
              
             
            
            
            
           
           
            
            
             
              
              
                c 
               
              
                o 
               
              
                v 
               
              
                a 
               
              
                r 
               
              
             
            
            
             
              
               
              
                = 
               
               
               
                 1 
                
                
                
                  M 
                 
                
                  ( 
                 
                
                  M 
                 
                
                  − 
                 
                
                  1 
                 
                
                  ) 
                 
                
               
               
               
                 ∑ 
                
               
                 i 
                
               
               
               
                 ∑ 
                
                
                
                  i 
                 
                
                  ≠ 
                 
                
                  j 
                 
                
               
              
                E 
               
              
                [ 
               
               
               
                 o 
                
               
                 i 
                
               
              
                − 
               
              
                E 
               
              
                [ 
               
               
               
                 o 
                
               
                 i 
                
               
              
                ] 
               
              
                ] 
               
              
                [ 
               
               
               
                 o 
                
               
                 j 
                
               
              
                − 
               
              
                E 
               
              
                [ 
               
               
               
                 o 
                
               
                 j 
                
               
              
                ] 
               
              
                ] 
               
              
                , 
               
              
             
            
            
            
           
          
         
           \begin{align} E[o-t]^2&amp;=bias^2+\frac{1}{M}var+(1-\frac{1}{M})covar,\\ bias&amp;=\frac{1}{M}\sum_i(E[o_i-t]),\\ var&amp;=\frac{1}{M}\sum_iE[o_i-E[o_i]]^2,\\ covar&amp;=\frac{1}{M(M-1)}\sum_i\sum_{i\ne j}E[o_i-E[o_i]][o_j-E[o_j]], \end{align} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 11.1653em; vertical-align: -5.3327em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 5.8327em;"><span class="" style="top: -7.8327em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">[</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal">t</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span class="" style="top: -5.5252em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="mord"><span class="mord mathnormal">bia</span><span class="mord mathnormal">s</span></span></span><span class="" style="top: -2.6261em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span><span class="" style="top: 0.273em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="mord"><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 5.3327em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 5.8327em;"><span class="" style="top: -7.8327em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord mathnormal">bia</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3214em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">M</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3214em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">M</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mpunct">,</span></span></span><span class="" style="top: -5.5252em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3214em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">M</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.8723em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.2777em;"><span class=""></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal">t</span><span class="mclose">])</span><span class="mpunct">,</span></span></span><span class="" style="top: -2.6261em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3214em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">M</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.8723em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.2777em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span><span class="" style="top: 0.273em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3214em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.8723em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.2777em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.8479em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord vbox mtight"><span class="thinbox mtight"><span class="rlap mtight"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="inner"><span class="mord mtight"><span class="mrel mtight"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.4382em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">]]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">]]</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 5.3327em;"><span class=""></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 5.8327em;"><span class="" style="top: -7.8327em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="eqn-num"></span></span><span class="" style="top: -5.5252em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="eqn-num"></span></span><span class="" style="top: -2.6261em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="eqn-num"></span></span><span class="" style="top: 0.273em;"><span class="pstrut" style="height: 3.3214em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 5.3327em;"><span class=""></span></span></span></span></span></span></span></span></span><br> 参数列表：</p> 
  <ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            t 
           
          
         
           t 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></span> 是目标值，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             o 
            
           
             i 
            
           
          
         
           o_i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            i 
           
          
         
           i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 个模型的输出值，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            M 
           
          
         
           M 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span></span></span></span></span> 是集成规模。</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            b 
           
          
            i 
           
          
            a 
           
          
            s 
           
          
         
           bias 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">bia</span><span class="mord mathnormal">s</span></span></span></span></span> 项衡量基础学习器和模型输出之间的平均差异，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            v 
           
          
            a 
           
          
            r 
           
          
         
           var 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 表示它们的平均方差，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            c 
           
          
            o 
           
          
            v 
           
          
            a 
           
          
            r 
           
          
         
           covar 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 是协方差项，衡量基础学习器的成对差异。</li></ul> </li><li> <p><strong>其他理论支持</strong>：</p> <p>集成方法得到了偏差-方差（bias-variance）、强度相关（strength correlation）、随机判别（stochastic discrimination）和边际理论（margin theory）等多种理论的支持。这些理论提供了等效的偏差-方差-协方差分解[34]。</p> </li><li> <p><strong>离散类标签</strong></p> <p>由于离散类标签的分类性质，上述给定的误差分解方程不能直接应用于离散类标签的数据集。不过，[4, 35, 36, 37, 38]中给出了分类问题中分解误差的其他方法。</p> </li><li> <p>为生成集成方法，人们提出了多种方法，如：</p> 
  <ul><li> <p><strong>袋装法（bagging）</strong></p> <p>袋装法可减少基础分类器之间的方差，</p> </li><li> <p><strong>提升法（boosting）</strong></p> <p>基于提升法的集成则可减少偏差和方差。</p> </li></ul> </li></ul> 
<h4><a id="32_Statistical_Computational_and_Representational_Aspects_178"></a>3.2 Statistical, Computational and Representational Aspects</h4> 
<p>统计、计算和表征方面</p> 
<p>迪特里希（Dietterich）提出了集成模型成功的统计、计算和表征原因。</p> 
<p>学习模型被视为在搜索空间的多个假设中寻找最优假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         h 
        
       
      
        h 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span>。当<strong>可用于训练的数据量小于假设空间的大小时</strong>，就会出现统计问题。</p> 
<ul><li> <p><strong>统计问题</strong>：</p> <p>由于这个统计问题，学习算法会找出在训练样本上表现相同的不同假设。</p> 
  <ul><li>对这些假设进行集成后，算法就能降低成为错误分类器的风险。</li></ul> </li><li> <p><strong>计算问题</strong>：</p> <p>第二个原因是计算方面的，由于某种形式的局部搜索，学习算法会陷入局部最优状态。</p> 
  <ul><li>集成模型通过<strong>不同的起点</strong>进行某种形式的<strong>局部搜索</strong>，从而更好地逼近真实的未知函数，从而克服了这一问题。</li></ul> </li><li> <p><strong>代表性问题</strong>：</p> <p>另一个原因是代表性，即假设集合中没有一个假设能够代表真正的未知函数。</p> 
  <ul><li>因此，通过某种<strong>加权</strong>技术对这些假设进行集成，就能得到扩大可表示函数空间的假设。</li></ul> </li></ul> 
<h4><a id="33_Diversity_204"></a>3.3 Diversity</h4> 
<p>多样性</p> 
<p>集成方法取得成功的主要原因之一是<strong>增加了基础分类器的多样性</strong>，这一点在 [3] 中也得到了强调。</p> 
<ul><li>为了生成多样化的分类器，人们采用了不同的方法。 
  <ul><li>在<strong>从原始数据集生成多个数据集以训练不同的预测器时</strong>，会采用不同的方法，如引导聚合（bagging）、自适应提升（AdaBoost）、随机子空间（random subspace）和随机森林（random forest）等方法，从而使预测器的输出多样化。</li><li>有人尝试<strong>增加输出数据的多样性</strong>，即创建多个输出而不是多个数据集来监督基础学习者。“输出涂抹（Output smearing）”就是其中一种，它通过诱导随机噪声来引入输出空间的多样性。</li></ul> </li></ul> 
<h3><a id="Section_4_Ensemble_Strategies_214"></a>Section 4 Ensemble Strategies</h3> 
<h4><a id="41_Bagging_216"></a>4.1 Bagging</h4> 
<p>袋装法</p> 
<ul><li> <p>**袋装法（Bagging）**介绍：</p> 
  <ul><li> <p>袋装法又称引导聚合法，是生成基于集合的算法的标准技术之一。袋装法用于提高集成分类器的性能。</p> </li><li> <p>袋装的主要思想是<strong>生成一系列独立的观测数据，其大小和分布与原始数据相同。给定一系列观察结果，生成一个比在原始数据上生成的单一预测器更好的集成预测器</strong>。</p> </li><li> <p>袋装法在原始模型中增加了两个步骤：</p> 
    <ul><li>第一，生成袋装样本并将每个样本袋传递给基础模型；</li><li>第二，综合多个预测因子预测结果的策略。生成的袋样本可以进行替换，也可以不进行替换。</li></ul> </li><li> <p>组合基础预测器的输出可能会有所不同，因为分类问题大多采用多数投票法，而回归问题则采用平均策略来生成集成输出。图 2 显示了袋集技术的示意图。其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
            
            
              D 
             
            
              i 
             
            
           
          
            D_i 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 代表袋装数据集，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
            
            
              C 
             
            
              i 
             
            
           
          
            C_i 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0715em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 代表算法，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             F 
            
           
             e 
            
           
             n 
            
           
             s 
            
           
          
            Fens 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span></span></span></span></span> 计算最终结果。</p> <p><img src="https://images2.imgbox.com/c7/3d/U6QdnKW2_o.png" alt="在这里插入图片描述"></p> </li></ul> </li><li> <p><strong>决策树＋袋装法=随机森林</strong></p> <p>随机森林是决策树的改进版，它使用袋装策略来改进基础分类器（即决策树）的预测结果。这两种方法的根本区别在于，在随机森林中，每次树分裂时，只随机选择一个特征子集并考虑进行分裂。这种方法的目的是对树进行装饰，防止过度拟合。</p> </li><li> <p><strong>袋装法与数据维度</strong></p> <p>Breiman 通过启发式研究发现，袋装预测因子的方差小于原始预测因子，并提出袋装法在高维数据中效果更好。然而，对袋装法平滑效果的分析 [45] 表明，袋装法并不依赖于数据维度。</p> <p>Bühlmann 和 Yu 从理论上解释了套袋法如何提供平滑的硬决策、较小的方差和均方误差。由于袋装法计算成本高，因此引入了子袋法和半子袋法。半子袋装计算效率高，精度与袋装一样高。</p> </li><li> <p><strong>现状：袋装法＋其他</strong></p> <p>有一些尝试将袋集与其他机器学习算法相结合。</p> 
  <ul><li>Kim 等人使用袋装法生成了多个数据集袋，并以每个数据袋为输入独立训练了多个支持向量机。模型的输出通过多数投票法、最小二乘估计加权法和双层分级法进行组合。在双层分级方法中，使用另一个支持向量机（SVM）来有效地组合多个 SVM 的结果。</li><li>Tao 等人使用非对称袋化策略生成集成模型来处理类不平衡问题。</li><li>对袋集、提升和基本集成进行的案例研究发现，在样本剔除率较高的情况下，提升与袋集和基本集成相比效果更好。然而，随着拒绝率的增加，提升、袋装和基本集合之间的差异消失了。基于袋化的多层感知器结合袋化训练多个感知器与相应的袋，结果表明，与单个多层感知器相比，基于袋化的集成模型表现更好。</li><li>文献[51]分析了袋化方法和其他正则化技术，发现袋化正则化了神经网络，从而提供了更好的泛化效果。</li><li>文献[52]提出了袋式神经网络（BNNs），其中每个神经网络都是在不同的数据集上进行训练的，这些数据集是从原始数据集中随机抽样并替换的，用于短期负荷预测。</li><li>随机森林[5]使用多数表决来聚合决策树集成，与之不同的是，基于袋集的生存树[53]使用 Kaplan-Meier 曲线来预测乳腺癌和淋巴瘤患者的集成输出。在[54]中，用于分类的堆叠去噪自编码器集合表明，一般深度机器中的袋装和切换技术能带来更好的多样性。</li></ul> </li><li> <p><strong>袋装法与数据不平衡</strong></p> <p>Bagging 也被用于解决不平衡数据问题。</p> 
  <ul><li>Roughly Balanced Bagging（Hido 等人，2009 年）试图在二元类问题中均衡每个类的抽样概率，其中负类样本通过负二项分布进行抽样，而不是保持每个类的样本量相同。</li><li>邻域平衡袋装法（Błaszczyński 和 Stefanowski，2015 年）结合了邻域信息，用于生成类不平衡问题的袋装样本。Błaszczyński 和 Stefanowski（2015）得出的结论是，在最后一种分类方法中应用传统的多样化方法更为有效。在深度学习架构中，大致平衡袋式分类法和邻域平衡袋式分类法都还没有被探索过。因此，可以利用这些方法通过深度集成模型来处理类不平衡问题。</li></ul> </li><li> <p><strong>袋装法性能</strong></p> <p>对在线袋式算法和提升算法的理论和实验分析（Oza，2005 年）表明，在线袋式算法可以达到与批量袋式算法相似的准确率，而只需要多花一点训练时间。不过，当由于内存问题无法将所有训练样本加载到内存中时，在线袋式算法也是一种选择。</p> <p>虽然集成可能会导致计算复杂度的增加，但袋装具有可以并行的特性，可以有效减少训练时间，但这取决于是否有运行并行模型的硬件。由于深度学习模型的训练时间较长，因此在不同的训练包上优化多个深度模型并不可行（见表 1）。</p> <p><img src="https://images2.imgbox.com/70/cc/T0nCE3QQ_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="42_Boosting_273"></a>4.2 Boosting</h4> 
<ul><li> <p>**提升（boosting）**简介：</p> <p>提升技术用于集成模型，<strong>将弱学习模型转化为具有更好泛化能力的学习模型</strong>。图 3 显示了提升技术的示意图。</p> <p><img src="https://images2.imgbox.com/ab/f8/Ud08eIFo_o.png" alt="在这里插入图片描述"></p> <p><strong>与单个弱学习器相比，分类问题中的多数投票或回归问题中的弱学习器线性组合等技术能带来更好的预测效果</strong>。AdaBoost（Freund 和 Schapire，1996 年）和梯度提升（Friedman，2001 年）等提升方法已被用于不同领域。</p> 
  <ul><li>AdaBoost 采用一种<strong>贪婪技术</strong>，通过在每次迭代中使用适当加权的预测因子来增强当前模型，从而最小化以误判损失为上界的凸代理函数。AdaBoost 可以学习有效的集成分类器，因为它在每个学习阶段都会利用错误分类的样本。</li><li>AdaBoost <strong>将指数损失函数最小化</strong>，而梯度提升则将此框架推广到任意差分损失函数。</li></ul> </li><li> <p><strong>现状：提升法＋深度模型</strong></p> <p>提升（Boosting）又称前向分阶段加法建模，最初是为了提高分类树的性能而提出的。最近，深度学习模型也采用了这种方法，以进一步提高其性能。</p> 
  <ul><li>用于面部表情识别的助推深度信念网络（DBN）（Liu 等人，2014 年）<strong>通过目标函数将助推技术和多个 DBN 统一起来</strong>，从而形成了一个强大的分类器。该模型以迭代的方式学习复杂的特征表示，从而建立一个强大的分类器。</li><li>深度提升（Cortes 等人，2014 年）是一种使用深度决策树的集成模型。它还可以与任何其他丰富的家族分类器结合使用，以提高泛化性能。在深度提升的每个阶段，决定添加哪个分类器以及选择什么样的权重取决于其所属分类器的（取决于数据的）复杂性。深度提升分类器在每个学习阶段都通过<strong>结构风险最小化原理</strong>进行解释。</li><li>多类深度提升（Kuznetsov 等人，2014 年）将深度提升（Cortes 等人，2014 年）算法的理论、算法和实证结果扩展到多类问题。由于每个小批量训练数据的限制，Boosting CNN <strong>可能会过拟合数据</strong>。</li><li>为了避免过拟合，增量提升 CNN（IBCNN）（Han 等人，2016 年）<strong>积累了多批训练数据样本的信息</strong>。IBCNN 使用单个神经元顶部的决策桩作为弱学习器，并在每个小批次中通过 AdaBoost 方法学习权重。与 DBN（Liu 等人，2014 年）使用图像片段来学习弱分类器不同，IBCNN 从全连接层训练弱分类器，即使用整个图像来学习弱分类器。为了提高 IBCNN 模型的效率，弱学习者损失函数与全局损失函数相结合。</li><li>助推式 CNN（Moghimi 等人，2016 年）使用助推法训练深度 CNN。在将助推权重纳入 CNN 时，使用了<strong>最小二乘法目标函数</strong>而不是平均值。 
    <ul><li>Moghimi 等人（2016 年）还表明，在他们的助推框架内，可以用网络结构代替 CNN，以提高基础分类器的性能。提升会增加网络训练的复杂性，因此在深度提升框架中引入了<strong>密集连接</strong>的概念，以克服图像去噪中的梯度消失问题（Chen 等，2018b）。</li><li>Chen 等人（2019b）将深度提升框架扩展到了图像复原领域，其中使用了扩张密集融合网络来提升性能。</li></ul> </li><li>卷积通道特征（Yang 等人，2015 年）<strong>通过 CNN 生成高级特征，然后使用提升森林进行最终分类</strong>。由于 CNN 的超参数数量比提升森林多，因此该模型在性能和时间上都比 CNN 模型的端到端训练有效。 
    <ul><li>Yang 等人（2015 年）展示了其在边缘检测、对象建议生成、行人和人脸检测中的应用。</li><li>分阶段提升深度 CNN（Walach 和 Wolf，2016 年）在离线范式提升框架内训练多个 CNN 模型。为了<strong>将增强概念扩展到在线场景</strong>中，即在给定时间内只有大块数据可用，有人提出了稳健增强独立嵌入模型（BIER）（Opitz 等人，2017 年）来应对在线场景。在 BIER 中，单个 CNN 模型通过在线提升技术进行端到端训练。BIER 中的训练集<strong>通过损失函数的负梯度进行重权重</strong>，从而将输入空间（图像）投射到一系列独立的输出空间中。</li><li>为了使 BIER 更加<strong>稳健</strong>，分层提升深度度量学习（Hierarchical Boosted deep metric learning，Waltner 等人，2019 年）<strong>将分层标签信息集成到嵌入式集成</strong>中，从而提高了模型在大规模图像检索应用中的性能。</li><li>使用深度提升会导致更长的训练时间，为了<strong>减少从零开始训练分类器的热身阶段</strong>，深度增量提升（Mosca 和 Magoulas，2017 年）采用了<strong>迁移学习方法</strong>。这种方法利用了网络训练过程中集成的每个增量基础模型的初始预热阶段。</li><li>为了<strong>减少基于 boosting 的集合的训练时间</strong>，快照 boosting（Zhang 等人，2020a）结合了快照集成和 boosting 的优点，在不增加训练成本的情况下提高了泛化效果。快照提升<strong>训练每个基础网络，并通过元学习器合并输出</strong>，从而更高效地合并基础学习器的输出。</li></ul> </li><li>文献显示，助推概念是深度残差网络（He等人，2016；Siu，2019）、AdaNet（Cortes等人，2017）等知名架构背后的支柱。 
    <ul><li>深度残差网络（DeepResNet）（He 等人，2016 年）成功的理论背景在提升理论（Huang 等人，2018 年）中得到了解释。作者提出了多通道伸缩和提升学习框架，即 BoostResNet，其中每个通道都是在一轮提升过程中更新的标量值，以最小化多类错误率。</li><li>AdaNet 和 BoostResnet 的根本区别在于，前者将特征向量映射到分类器空间并提升弱分类器，而后者则使用多通道表示提升。此外，就计算时间而言，BoostResNet 比 DeepResnet 更高效。</li></ul> </li><li>Beygelzimer 等人（2015 年）将提升理论扩展到在线提升，并提供了理论上的收敛保证。在线提升显示了对批量提升算法的收敛保证的改进。</li><li>González 等人（2020 年）对袋选和提升的集成进行了评估。该研究评估了基于袋集和提升概念的不同算法以及软件工具的可用性。该研究强调了它们在集成建模中可行性的实际问题和机遇（见表 2）。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/ba/8b/t7hXgEv7_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="43_Stacking_313"></a>4.3 Stacking</h4> 
<p>堆叠法</p> 
<ul><li> <p><strong>堆叠法</strong>（stacking）简介：</p> <p>集成可以通过某种方式将多个基础模型的输出结果组合起来，或者使用某种方法选择 "最佳 "基础模型。图 4 显示了堆叠技术。</p> <p><img src="https://images2.imgbox.com/5a/7e/XMtcjCXj_o.png" alt="在这里插入图片描述"></p> <p>堆叠是一种<strong>整合技术</strong>，其中元学习模型用于整合基础模型的输出。如果最终决策部分是一个线性模型，堆叠通常被称为 "模型混合 "或简单的 “混合”。堆叠或堆叠回归的概念最初由 Wolpert（1992 年）提出。在这项技术中，数据集被随机分割成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           J 
          
         
        
          J 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0962em;">J</span></span></span></span></span> 个相等的部分。在第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           j 
          
         
        
          j 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 倍交叉验证中，一组用于测试，其余用于训练。通过这些训练测试对子集，我们可以得到不同学习模型的预测结果，并将其作为元数据来建立元模型。元模型做出最终预测，这也被称为 <strong>"赢家通吃 "策略</strong>。</p> </li><li> <p><strong>现状：堆叠法</strong>：</p> 
  <ul><li>堆叠是一种减少偏差的技术（Leblanc 和 Tibshirani，1996 年）。</li><li>继 Wolpert（1992 年）之后，有人提出了深度凸网（DCN）（Deng 和 Yu，2011 年），这是一种深度学习架构，由<strong>数量可变的模块堆叠</strong>在一起形成深度架构。DCN 中的每个学习模块都是凸的。DCN 是由多个模块堆叠而成，包括线性输入单元、隐藏层非线性单元和第二线性层，单元数量与目标分类类别相同。这些模块是<strong>逐层连接</strong>的，因为除了原始输入数据外，较低模块的输出也作为相邻较高模块的输入。</li><li>Deng 等人（2012c）提出了可在<strong>超大规模数据集</strong>上进行并行训练的深度堆积网络（DSN），该网络被命名为基于堆积的网络，因为它共享 “堆积泛化”（Wolpert，1992）的概念。</li><li>Deng 等人（2012a）给出了 DCN 的核化版本，即核深度凸网络（K-DCN），这里通<strong>过核技巧使隐层数接近无穷大</strong>。Deng 等人（2012a）的研究表明，与 DCN 相比，K-DCN 的性能更好。但是，由于采用了内核技巧，内存需求增加，因此可能无法扩展到大规模数据集。此外，我们还需要优化超参数，如堆叠网络中的层数、核参数等，以获得最佳的网络性能。</li><li>为了充分利用内存需求，基于随机傅立叶特征的核深凸网络（Huang 等人，2013 年）近似于高斯核，从而<strong>缩短了训练时间</strong>，并有助于在大规模数据集上评估 K-DCN 的效果。</li><li>核深度堆积网络中的参数估计和模型选择框架（Welchowski 和 Schmid，2016 年）基于模型的优化和爬山方法的结合。Welchowski 和 Schmid（2016）在核深度堆积网络中使用<strong>数据驱动框架</strong>进行参数估计、超参数调整和模型选择。</li><li>张量深度堆叠网络（T-DSN）（Hutchinson 等人，2012 年）是对 DSN 的另一项改进，在堆叠网络的每个区块中，<strong>大型单隐层被分割成两个较小的隐层</strong>，然后进行双线性映射，以捕捉特征之间的高阶交互。</li><li>Hutchinson 等人（2013 年）对学习算法和 T-DSN 实现进行了全面评估和详细分析。<strong>稀疏编码</strong>是深度学习领域使用的另一种流行方法。稀疏表示的优势有很多，包括对噪声的鲁棒性、学习有用特征的有效性等。稀疏深度堆积网络（S-DSN）被提出用于图像分类和异常检测（Li 等人，2015；Sun 等人，2018）。</li><li>Li 等人（2015 年）和 Sun 等人（2018 年）将许多稀疏简化神经网络模块（SNNM）与混合规范正则化堆叠在一起，其中权重通过凸优化和梯度下降算法求解。为了让稀疏 SNNM 学习隐单元之间的局部依赖关系，Li 等人（2017a）将隐单元或表征分成不同的组，这被称为组稀疏 DSN（GS-DSN）。</li><li>Deep Reinforcement Learning（深度强化学习）领域也采用了 DSN 的思想。</li><li>Zhang 等人（2020b）采用 DSN 方法来整合来自正式网络的观察结果： 
    <ul><li>基于 Qlearning 算法的抓取网络和堆叠网络，使一体化机械臂系统能够完成抓取和放置动作。</li><li>Wang 等人（2020）通过多次堆叠块来提高神经架构搜索任务的性能。</li><li>Zhang 等人（2019a）提出了一种通过堆叠方法进行图像去模糊的深度分层多补丁网络。</li></ul> </li><li>由于 DSN 中没有数据的时间表示，因此对输入数据中存在时间依赖性的问题不太有效。为了在 DSN 中<strong>嵌入时间信息</strong>，递归深度堆积网络（R-DSN）（Palangi 等人，2014 年）结合了 DSN 和递归神经网络（RNN）的优点。RNN 使用时间反向传播来训练网络，而 RDSNs 则不同，它使用回声状态网络（ESN）来初始化权重，然后通过批量模式梯度下降来微调权重。</li><li>Zhou 等人（2015 年）提出了一种堆叠式极限学习机。在这里，网络的每一级都使用减少了隐藏节点数量的 ELM 来解决大规模问题。<strong>通过主成分分析（PCA）缩减技术减少了隐藏节点的数量</strong>。</li><li>考虑到堆叠模型的效率，人们提出了<strong>基于支持向量机的堆叠模型</strong>（Wang 等人，2019d,a；Li 等人，2019b）。随机森林（Random Forests）等传统模型也通过堆叠概念扩展到了深度架构，即深层森林（Zhou and Feng, 2017）。</li><li>除了 DSN，还有一些基于堆叠方法的新型网络架构被提出， 
    <ul><li>Low 等人（2019）提出了一种基于堆叠的深度神经网络（S-DNN），它的训练<strong>无需反向传播算法</strong>。</li><li>Kang 等人（2020）提出了一种通过<strong>堆叠条件受限玻尔兹曼机和深度神经网络的模型</strong>，该模型以更少的参数和更少的训练样本取得了显著的优越性能。</li></ul> </li></ul> </li></ul> 
<h4><a id="44_Negative_Correlation_Based_Deep_Ensemble_Methods_349"></a>4.4 Negative Correlation Based Deep Ensemble Methods</h4> 
<p>基于负相关的深度集成方法</p> 
<ul><li>**负相关学习（Negative correlation learning）**简介 
  <ul><li>负相关学习（NCL）（Liu 和 Yao，1999 年）是训练学习算法的一项重要技术。NCL 背后的主要概念是<strong>鼓励集成中各个模型之间的多样性，以学习训练数据的不同方面</strong>。NCL 通过<strong>最小化单个网络的误差函数</strong>来最小化集合模型的经验风险函数。</li><li>对 NCL（Liu 和 Yao，1999 年）的回归和分类任务进行了评估。评估采用了不同的方法，如分类任务中的简单平均法和赢家通吃法，以及回归问题中的简单平均组合法。作者发现，在 NCL 集成模型中，赢家通吃比简单平均更好。</li></ul> </li><li><strong>现状：负相关学习</strong> 
  <ul><li>Shi 等人（2018）提出了用于人群计数的深度负相关学习架构，称为 D-ConvNet，即装饰相关卷积网络。在这里，计数是基于卷积特征映射弱回归子池的回归式集成学习完成的。这背后的主要想法是<strong>在深度架构中引入 NCL 概念</strong>。通过深度 NCL 实现鲁棒回归（Zhang 等人，2019b）是 Shi 等人（2018）的扩展，其中给出了关于 Rademacher 复杂性的理论见解，并扩展到更多基于回归的问题。</li><li>Buschjäger 等人（2020 年）提出了一种<strong>广义偏差-方差分解法来控制多样性和平滑插值</strong>。他们提出了广义负相关学习（GNCL）算法，该算法可以囊括许多现有文献中的研究成果，并取得了卓越的性能。</li><li>NCL 也可用于增量学习任务。Muhlbaier 和 Polikar（2007 年）采用动态修改的加权多数表决策略来组合子分类器。Tang 等人（2009 年）提出了一种基于负相关学习（NCL）的集成增量学习方法。</li></ul> </li></ul> 
<h4><a id="45_Explicit__Implicit_Ensembles_361"></a>4.5 Explicit / Implicit Ensembles</h4> 
<p>显式/隐式集成</p> 
<ul><li> <p><strong>显示/隐式（Explicit / Implicit）集成简介</strong>：深度集成之难</p> 
  <ul><li>深度神经网络的集成似乎并不是一个简单的选择，因为它<strong>可能会因为训练多个神经网络而导致计算成本大幅增加</strong>。使用 GPU 加速的高性能硬件可能需要数周的时间来训练深度网络。</li><li>而隐式/显式集成则可以实现这一矛盾的目标，即在<strong>不产生额外成本或尽可能降低额外成本的情况下，以类似于集成训练多个神经网络的方式训练单个模型</strong>。在这里，集成的训练时间与单个模型的训练时间相同。</li><li>在隐式集成中，模型参数是<strong>共享</strong>的，测试时的单个未细化网络近似于集成模型的模型平均值。</li><li>然而，在显式集合中，模型参数并<strong>不共享</strong>，集合输出是通过不同的方法（如多数投票、平均等）将集合模型的预测结果综合起来。</li></ul> </li><li> <p>现状：通过<strong>共享权重</strong>来提供<strong>隐式</strong>的网络集成：</p> 
  <ul><li>Dropout （Srivastava 等人，2014 年）通过<strong>在网络训练期间随机丢弃网络中的隐藏节点来创建集成网络</strong>。在测试期间，所有节点都处于活动状态。丢弃为网络提供了正则化，以避免过拟合，并在输出向量中引入稀疏性。由于它能训练具有共享权重的指数数量模型，并在测试期间提供隐式网络集成，因此能减少过拟合。随机丢弃单元可避免单元间的共同适应，使特定单元的存在变得不可靠。与标准神经网络相比，带剔除功能的网络需要多花 2-3 倍的时间进行训练。因此，需要在网络的训练时间和过度拟合之间取得适当的平衡。</li><li>DropConnect （Wan 等人，2013 年）对 DropOut 进行了泛化。与 DropOut 丢弃每个输出单元不同，DropConnect 会<strong>随机丢弃每个连接，从而在模型的权重参数中引入稀疏性</strong>。与 DropOut 相似，DropConnect 在训练过程中丢弃连接（将权重设置为零），从而在测试期间创建隐式集成。</li><li>DropOut 和 DropConnect 都存在训练时间长的问题。为了缓解这一问题，采用随机深度的深度网络（Huang 等人，2016b）旨在<strong>减少训练期间的网络深度，同时在网络测试期间保持深度不变</strong>。随机深度是对 ResNet（He 等人，2016 年）的改进，即在训练过程中随机丢弃残余块，并通过跳过连接绕过这些转换块连接。</li><li>Swapout（Singh 等人，2016 年）是 DropOut 和随机深度的泛化。<strong>调换则是丢弃单个单元或随机跳过区块</strong>。为了缩短测试时间，提炼网络中的知识（Hinton 等人，2015 年）采用了一种独特的方法，将 "知识 "从集成转移到单一模型中。</li><li>Gradual DropIn 或正则化 DropIn（Smith 等人，2016 年）的层数从浅层网络开始，层数逐渐增加。DropIN 训练的是指数数量的较薄网络，与 DropOut 类似，也是较浅的网络。</li></ul> </li><li> <p><strong>现状：显式集成</strong>：</p> <p>上述所有方法都是通过共享权重来提供网络集成。有人尝试探索<strong>显式集成，其中模型不共享权重</strong>。</p> 
  <ul><li>快照集成（Huang 等人，2017a）开发了一种不共享权重的显式集成。作者利用好的和坏的局部最小值，让随机梯度下降（SGD）沿优化路径收敛𝑀次到局部最小值，并仅在模型达到最小值时拍摄快照。然后，通过在多个局部最小值处取平均值，对这些快照进行集成，以进行物体识别。集合的训练时间与单一模型的训练时间相同。集合输出取多个局部最小值处快照输出的平均值。</li><li>随机向量功能链接网络（Pao 等人，1994 年；Malik 等人，2022 年）也被用于创建显式集合（Shi 等人，2021 年），其中层次结构中隐藏层权重的不同随机初始化使集合预测多样化。</li></ul> </li><li> <p><strong>进一步的深度集成</strong>：</p> <p>显式/隐式从单个网络中产生集成，但却<strong>牺牲了基础模型的多样性</strong>（Cao 等人，2020），因为各模型的低层特征很可能是相同的。</p> 
  <ul><li> <p>为了缓解这一问题，基于分支的深度模型（Han 等人，2017 年）对网络进行分支，以诱导更多的多样性。</p> </li><li> <p>神经网络的不同初始化会导致不同的局部最小值，受此启发，薛等人（2021 年）提出了深度集成模型，在该模型中，带有粗精细补偿模块的多损失模块上的全卷积神经网络的集成能更好地分割中央浆液性脉络膜视网膜病变。具有不同初始化和多种损失函数的多个神经网络在一个集成中产生了更好的多样性（见表 3）。</p> <p><img src="https://images2.imgbox.com/61/5e/UalN5sFI_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> 
<h4><a id="46_Homogeneous__Heterogeneous_ensembles_397"></a>4.6 Homogeneous &amp; Heterogeneous ensembles</h4> 
<p>同质和异质集成</p> 
<ul><li> <p><strong>同质和异质（Homogeneous &amp; Heterogeneous）集成简介</strong>：</p> <p>同质集成（HOE）和异质集成（HEE）**涉及训练一组基础学习器，它们或来自同一族，或来自不同族，**分别如图 5 和图 6 所示。因此，集成的每个模型必须尽可能多样化，而且每个基础模型的表现必须优于随机猜测。基础学习器可以是决策树、神经网络或任何其他学习模型。</p> </li><li> <p><strong>同质集合</strong>：</p> 
  <ul><li> <p>同质集合中的<strong>随机性诱导</strong>：</p> <p>在同质集成中，同一个基础学习器会被多次使用，以生成基础分类器系列。然而，关键问题是训练每个基础模型，使集成模型尽可能多样化，即没有两个模型在特定数据样本上出现相同的错误。在同质集合中诱导随机性的两种最常见方法是：</p> 
    <ul><li>对训练集进行<strong>多次采样</strong>，从而在训练数据的不同引导样本上训练每个模型；</li><li>或者<strong>对训练数据的特征空间进行采样</strong>，在训练数据的不同特征子集上训练每个模型。</li></ul> </li><li> <p>现状：</p> <p>在一些集成模型中，如随机森林（Breiman，2001 年）就同时使用了这两种技术，在决策树的集成中引入多样性。在神经网络中，通过对模型进行不同的初始化来独立训练模型也会产生多样性。</p> </li><li> <p>在深度集成中的现状：</p> <p>然而，深度学习模型的训练成本很高，因此训练多个深度学习模型并不可行。已有一些尝试，</p> 
    <ul><li>如深度集成的水平垂直投票（Xie 等人，2013 年），无需独立训练即可获得深度模型的集成。Temporal ensemble（Laine 和 Aila，2016 年）用不同的输入增强、不同的正则化和不同的训练历时来训练多个模型。</li><li>对用于图像分类（Ciregan 等人，2012 年）和疾病预测（Grassmann 等人，2018 年）的多个深度神经网络的训练表明，通过多个网络的集成并对输出进行平均，可以获得更好的性能。</li></ul> </li></ul> </li><li> <p><strong>现状：异构集成</strong>：</p> <p>尽管有这些模型，但训练多个深度学习模型进行集成是一项艰巨的任务，因为需要优化数百万或数十亿个参数。因此，一些研究将深度学习与传统模型结合使用，构建异构集成模型，<strong>享受更低计算量和更高多样性的好处</strong>。</p> 
  <ul><li>用于违约预测的异构集合（Li 等，2018）是极梯度提升、深度神经网络和逻辑回归的集合。</li><li>用于文本分类的异构集成（Kilimci 和 Akyokus，2018 年）是多变量伯努利天真贝叶斯（MVNB）、多项式天真贝叶斯（MNB）、支持向量机（SVM）、随机森林（RF）和卷积神经网络（CNN）学习算法的集成。</li><li>异构深度网络融合（Tabik 等人，2020 年）从数据、模型和决策融合的不同角度出发，表明复杂的异构融合架构更加多样化，因此显示出更好的泛化性能。</li><li>此外，Seijo-Pardo 等人（2017）采用了同构和异构集成来进行特征选择。</li><li>Zhao 等人（2010 年）提出，与基于 boosting 的 Learn++ 算法和其他一些 NCL 方法相比，基于异构 bagging 的集成策略表现更好。</li><li>其他采用同质集成方法的例子则用于处理存在增量的任务， 
    <ul><li>概念漂移（Minku 等，2009）</li><li>电力负荷预测（Qiu 等，2018；Grmanová 等，2016）</li><li>肌电假手表面肌电图特征（Duan 和 Dai，2017）等。</li><li>Das 等人（2016）提出了一种具有伪外积模糊神经网络的集成增量学习，用于交通流量预测、实盘股价、波动率预测等。</li></ul> </li></ul> </li></ul> 
<h4><a id="47_Decision_Fusion_Strategies_440"></a>4.7 Decision Fusion Strategies</h4> 
<p>决策融合战略</p> 
<ul><li><strong>决策融合（Decision Fusion Strategies）现状</strong>： 
  <ul><li>集成学习训练多个基础学习器，并利用一些规则汇总基础学习器的输出。用于组合输出的规则决定了集合的有效性能。</li><li>大多数集合模型都专注于集合架构，然后对其进行天真平均，以预测集合输出。然而，大多数集合模型所遵循的模型天真平均并不是数据自适应的，会导致性能不太理想（Ju 等人，2018 年），因为它对有偏差的学习者的性能很敏感。</li><li>由于深度学习架构中有数十亿超参数，过拟合问题可能会导致一些基础学习器失效。因此，为了克服这些问题，人们采用了贝叶斯最优分类器和超级学习器等方法（Ju 等人，2018 年）。</li></ul> </li></ul> 
<p>文献中采用的集成模型输出结果的不同方法有：</p> 
<h5><a id="471_Unweighted_Model_Averaging_451"></a>4.7.1 Unweighted Model Averaging</h5> 
<p>非加权模型平均</p> 
<ul><li> <p><strong>非加权模型平均（Unweighted Model Averaging）简介</strong>：</p> 
  <ul><li>对集合中基础学习者的输出进行非加权平均是文献中最常用的决策融合方法。在这里，<strong>对基础学习者的结果进行平均，从而得到集成模型的最终预测结果</strong>。</li><li>深度学习架构具有<strong>高方差和低偏差</strong>的特点，因此，对集合模型<strong>进行简单的平均可以减少模型之间的方差，从而提高泛化性能</strong>。</li></ul> </li><li> <p>基础学习器的平均化可以直接在基础学习器的输出上进行，也可以通过 softmax 函数在预测的类别概率上进行：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             P 
            
           
             i 
            
           
             j 
            
           
          
            = 
           
          
            s 
           
          
            o 
           
          
            f 
           
          
            t 
           
          
            m 
           
          
            a 
           
           
           
             x 
            
           
             j 
            
           
          
            ( 
           
           
           
             O 
            
           
             i 
            
           
          
            ) 
           
          
            = 
           
           
            
            
              O 
             
            
              i 
             
            
              j 
             
            
            
             
             
               ∑ 
              
              
              
                k 
               
              
                = 
               
              
                1 
               
              
             
               K 
              
             
            
              e 
             
            
              x 
             
            
              p 
             
            
              ( 
             
             
             
               O 
              
             
               k 
              
             
               j 
              
             
            
              ) 
             
            
           
          
         
           P^j_i=softmax^j(O_i)=\frac{O^j_i}{\sum^K_{k=1}exp(O^j_k)} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2194em; vertical-align: -0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9426em;"><span class="" style="top: -2.4231em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.1809em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2769em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.1247em; vertical-align: -0.25em;"></span><span class="mord mathnormal">so</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ma</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8747em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7921em; vertical-align: -1.1725em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6196em;"><span class="" style="top: -2.1288em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9812em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0715em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2997em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9426em;"><span class="" style="top: -2.3987em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span><span class="" style="top: -3.1809em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3013em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9426em;"><span class="" style="top: -2.4231em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.1809em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2769em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1725em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br> 参数列表：</p> 
  <ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             P 
            
           
             i 
            
           
             j 
            
           
          
         
           P^j_i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2194em; vertical-align: -0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9426em;"><span class="" style="top: -2.4231em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.1809em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2769em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            i 
           
          
         
           i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 个单元在第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            j 
           
          
         
           j 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 个基础学习器上的概率结果，</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             O 
            
           
             j 
            
           
             i 
            
           
          
         
           O^i_j 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2194em; vertical-align: -0.3948em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8247em;"><span class="" style="top: -2.4413em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3948em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            j 
           
          
         
           j 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 个基础学习器的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            i 
           
          
         
           i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 个单元的输出，而 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            j 
           
          
         
           j 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 是类别数。</li></ul> </li><li> <p>局限性：</p> 
  <ul><li>正如 He 等人（2016）、Simonyan 和 Zisserman（2014）以及 Szegedy 等人（2015）所建议的那样，当<strong>基础学习者的表现相当时，非加权平均是一种合理的选择</strong>。</li><li>然而，<strong>当集成包含异质基础学习者时，天真的非加权平均可能会导致次优性能</strong>，因为它会受到弱学习者和过度自信学习者性能的影响（Ju 等人，2018 年）。自适应金属学习器应该足以自适应地结合基础学习器的优势，因为有些学习器的整体性能可能较低，但可能擅长某些子类的分类，从而带来更好的整体性能。</li></ul> </li></ul> 
<h5><a id="472_Majority_Voting_473"></a>4.7.2 Majority Voting</h5> 
<p>多数票表决</p> 
<ul><li> <p><strong>多数票表决（Majority Voting）简介</strong>：</p> 
  <ul><li>与非加权平均法类似，多数投票法将基础学习者的输出结果合并在一起。不过，多数投票法不是取概率结果的平均值，而是<strong>计算基础学习器的得票数，并以得票最多的标签预测最终标签</strong>。</li><li>与非加权平均法相比，多数投票法对特定基础学习器结果的<strong>偏向性更小，因为多数票数的影响得到了缓解</strong>。</li><li>然而，<strong>大多数相似基础学习器或依赖基础学习器对某一事件的偏爱会导致该事件在集成模型中占主导地位</strong>。在多数投票中，Kuncheva 等人（2003 年）的分析表明，基础学习器之间的成对依赖性起着重要作用，对于图像分类而言，浅层网络的预测与深层网络相比更具多样性（Choromanska 等人，2015 年）。因此，Ju 等人（2018）假设，与基于多数投票的深度集合模型相比，基于多数投票的浅层集合模型性能更好。</li></ul> </li><li> <p><strong>现状：投票方法+半监督深度学习</strong></p> <p>投票方法也开始与半监督深度学习相结合。</p> 
  <ul><li>Li 等（2017b）提出了一种用于自动语音识别中的集成半监督深度声学模型。</li><li>Wang 等（2019c）在 Liu 等（2018）中探索了一种集成自学习方法来增强半监督性能，并从社交媒体中提取药物不良事件。</li><li>在半监督分类领域，作者提出了一种深度耦合的集成学习方法，该方法与互补一致性正则化相结合，在Li等（2019a）中获得了最先进的性能。</li><li>在一些标注成本较高的数据集上，半监督集成学习也取得了一些成果。Pio 等人（2014）采用了一种集成方法来提高 miRNA:miRNA 预测相互作用的可靠性。</li></ul> </li><li> <p><strong>现状：投票方法+多标签分类</strong></p> <p>此外，多标签分类（Tsoumakas 和 Katakis，2007 年）问题也是投票法要解决的一个重点，</p> 
  <ul><li>其典型应用是 RAndom k-labELsets (RAKEL) 算法（Tsoumakas 和 Vlahavas，2007 年）。作者使用实际标签的小随机子集训练了多个单标签分类器。然后根据这些单一分类器的预测结果，通过投票方案进行最终输出。</li><li>近年来还提出了许多 RAKEL 的变体（Moyano 等人，2019 年；Kimura 等人，2016 年；Wang 等人，2021 年）。</li><li>Shi 等人（2011）提出了一种多标签集成学习问题的解决方案，该方案构建了多个准确且多样化的基于多标签的基础分类器，并采用两个目标函数来评价多标签基础学习器的准确性和多样性。</li><li>另一项工作（Li 等人，2013 年）提出了一种基于变量配对约束投影的集合多标签分类框架。</li><li>Xia 等人（2021 年）提出了一种加权堆叠集成方案，采用稀疏正则化来促进分类器选择和集成构建。</li><li>除此之外，集成多标签方法还有很多应用。 
    <ul><li>一些出版物采用多标签集成分类器来探索蛋白质，如蛋白质亚细胞定位（Guo 等，2016）、蛋白质功能预测（Yu 等，2012）等。</li><li>Muli-label 分类器还被用于预测药物副作用（Zhang 等人，2015 年）、预测基因预测（Schietgat 等人，2010 年）等。</li></ul> </li><li>此外，还有一种关键的集成多标签算法，称为集成分类器链（ECC）（Read 等人，2011 年）。这种方法涉及沿着链条链接的二进制分类器。 
    <ul><li>第一个分类器仅使用输入数据进行训练，</li><li>然后每个后续分类器在输入空间和链中所有前一个分类器的基础上进行训练。</li><li>最终的预测结果由预测结果的整合和高于人工设定阈值的选择得出。</li></ul> </li><li>Chen 等人（2017）提出了卷积神经网络和递归神经网络的集成应用，以捕捉全局和局部文本语义，并对高阶标签相关性进行建模。</li></ul> </li></ul> 
<h5><a id="473_Bayes_Optimal_Classifier_510"></a>4.7.3 Bayes Optimal Classifier</h5> 
<p>贝叶斯最佳分类器</p> 
<ul><li> <p>在贝叶斯方法中，每个基础学习者的假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           j 
          
         
        
          j 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 与给定 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           x 
          
         
        
          x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 的目标标签 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           t 
          
         
        
          t 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></span> 的条件分布相关。假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           j 
          
         
        
          j 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 是在测试数据 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
         
           x 
          
         
           , 
          
         
           t 
          
         
           ) 
          
         
        
          (x,t) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span> 上评估训练数据 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           D 
          
         
        
          D 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span></span></span></span></span> 所生成的假设，数学上，假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            h 
           
          
            j 
           
          
         
           ( 
          
         
           t 
          
         
           ∣ 
          
         
           x 
          
         
           ) 
          
         
           = 
          
         
           P 
          
         
           [ 
          
         
           y 
          
         
           ∣ 
          
         
           x 
          
         
           , 
          
          
          
            h 
           
          
            j 
           
          
         
           , 
          
         
           D 
          
         
           ] 
          
         
        
          h_j(t|x)=P[y|x,h_j,D] 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mclose">]</span></span></span></span></span>。根据贝叶斯法则，我们可以得出：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            P 
           
          
            ( 
           
          
            t 
           
          
            ∣ 
           
          
            x 
           
          
            , 
           
          
            D 
           
          
            ) 
           
          
            ∝ 
           
           
           
             ∑ 
            
            
            
              h 
             
            
              j 
             
            
           
          
            P 
           
          
            [ 
           
          
            t 
           
          
            ∣ 
           
           
           
             h 
            
           
             j 
            
           
          
            , 
           
          
            x 
           
          
            , 
           
          
            D 
           
          
            ] 
           
          
            P 
           
          
            [ 
           
          
            D 
           
          
            ∣ 
           
           
           
             h 
            
           
             j 
            
           
          
            ] 
           
          
            P 
           
          
            [ 
           
           
           
             h 
            
           
             j 
            
           
          
            ] 
           
          
         
           P(t|x,D)\propto\sum_{h_j}P[t|h_j,x,D]P[D|h_j]P[h_j] 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∝</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.5494em; vertical-align: -1.4994em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.8479em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3281em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2819em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.4994em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span></p> </li><li> <p>贝叶斯最优分类器的计算公式为:<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
            
             
             
               a 
              
             
               r 
              
             
               g 
              
             
               m 
              
             
               a 
              
             
               x 
              
             
            
              t 
             
            
           
           
           
           
             ∑ 
            
            
            
              h 
             
            
              j 
             
            
           
          
            P 
           
          
            [ 
           
          
            t 
           
          
            ∣ 
           
           
           
             h 
            
           
             j 
            
           
          
            , 
           
          
            x 
           
          
            , 
           
          
            D 
           
          
            ] 
           
          
            P 
           
          
            [ 
           
          
            D 
           
          
            ∣ 
           
           
           
             h 
            
           
             j 
            
           
          
            ] 
           
          
            P 
           
          
            [ 
           
           
           
             h 
            
           
             j 
            
           
          
            ] 
           
          
         
           \underset{t}{argmax}\quad\sum_{h_j}P[t|h_j,x,D]P[D|h_j]P[h_j] 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 2.5494em; vertical-align: -1.4994em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.4306em;"><span class="" style="top: -2.2056em; margin-left: 0em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class=""><span class="mop"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.8944em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.8479em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3281em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2819em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.4994em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span></p> 
  <ul><li>其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            P 
           
          
            [ 
           
          
            D 
           
          
            ∣ 
           
           
           
             h 
            
           
             j 
            
           
          
            ] 
           
          
            = 
           
           
           
             ∏ 
            
            
            
              ( 
             
            
              t 
             
            
              , 
             
            
              x 
             
            
              ) 
             
            
              ∈ 
             
            
              D 
             
            
           
           
           
             h 
            
           
             j 
            
           
          
            ( 
           
          
            t 
           
          
            ∣ 
           
          
            x 
           
          
            ) 
           
          
         
           P[D|h_j]=\prod_{(t,x)\in D}h_j(t|x) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2247em; vertical-align: -0.4747em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.2253em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4747em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span> 是数据在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             h 
            
           
             j 
            
           
          
         
           h_j 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 下的可能性。</li><li>然而，由于过拟合问题，这可能不是一个好的衡量标准。因此，训练数据分为两组，一组用于训练模型，另一组用于评估模型。通常，验证集用于调整模型的超参数。</li></ul> </li><li> <p>在贝叶斯最优分类器中<strong>选择先验概率很困难，因此为了简单起见，通常设置为均匀分布</strong>。在样本量较大的情况下，一种假设的后验概率往往大于其他假设，因此权重向量会被单一的基础学习器所支配，贝叶斯最优分类器也就表现为具有负可能性损失函数的离散超级学习器。</p> </li></ul> 
<h5><a id="474_Stacked_Generalization_529"></a>4.7.4 Stacked Generalization</h5> 
<p>堆叠法概述</p> 
<p>堆叠泛化法（Wolpert，1992 年）<strong>通过推导泛化器对所提供学习集的偏差来实现</strong>。为了在回归中获得基础学习者的良好线性组合，交叉验证数据和非负性约束下的最小二乘法被用来获得最佳的组合权重（Breiman，1996c）。考虑基础学习者预测结果的线性组合 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          1 
         
        
       
         , 
        
        
        
          f 
         
        
          2 
         
        
       
         , 
        
       
         … 
        
       
         , 
        
        
        
          f 
         
        
          m 
         
        
       
      
        f_1,f_2,\dots,f_m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 如下：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           f 
          
          
          
            s 
           
          
            t 
           
          
            a 
           
          
            c 
           
          
            k 
           
          
            i 
           
          
            n 
           
          
            g 
           
          
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            j 
           
          
            = 
           
          
            1 
           
          
         
           m 
          
         
         
         
           w 
          
         
           j 
          
         
         
         
           f 
          
         
           j 
          
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
       
         f_{stacking}(x)=\sum^m_{j=1}w_jf_j(x) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">kin</span><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 3.0652em; vertical-align: -1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.8723em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.4138em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></span><br> 其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
      
        w 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span></span></span></span></span> 是元学习器学习到的最优权重向量。</p> 
<h5><a id="475_Super_Learner_539"></a>4.7.5 Super Learner</h5> 
<p>超级学习器</p> 
<ul><li> <p><strong>超级学习器（Super Learner）设计思想</strong>：</p> 
  <ul><li>Van der Laan 等人（2007 年）受交叉验证选择最佳分类器的启发，提出了超级学习器，它是基础学习器预测结果的加权组合。与堆叠方法不同的是，它<strong>使用交叉验证方法来选择最佳权重，以组合基础学习器的预测结果</strong>。</li><li>对于较小的数据集，可以使用交叉验证法来优化权重。然而，随着数据规模和模型中基础学习者数量的增加，这可能不是一个可行的选择。除了优化 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            V 
           
          
         
           V 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span></span></span></span></span> 折交叉验证外，还可以使用单分裂交叉验证来优化权重，以实现最优组合（Ju 等人，2019 年）。在深度学习模型中，通常使用验证集来评估性能，而不是使用交叉验证。</li></ul> </li><li> <p><strong>现状：超级学习器与深度学习</strong>：</p> <p>超级学习器的另一个应用领域是强化学习随着深度学习的发展，一些研究人员已经实现了深度强化学习，</p> 
  <ul><li>它将深度学习与 Q-learning 算法相结合（Mnih 等人，2013 年）。深度 Q 学习中的集成方法具有不错的性能。</li><li>Chen 等人（2018a）提出了一种用于深度强化学习的集成网络架构。集成网络包括时序集合（Temporal Ensemble）和目标值集合（Target Values Ensemble）。</li><li>开发类人聊天机器人是一项具有挑战性的工作，通过集成深度强化学习和集合方法， 
    <ul><li>Cuayáhuitl 等人（2019）集成了 100 个深度强化学习代理，代理基于聚类对话进行训练。</li><li>他们还证明了 DRL 代理的集合比单一变体或 Seq2Seq 模型具有更好的性能。</li></ul> </li><li>股票交易是另一个集成深度强化学习取得可喜成果的课题。 
    <ul><li>Carta 等人（2020 年）发现，单一监督分类器不足以应对复杂多变的股票市场。他们采用了数百个神经网络对数据进行预处理，然后将多个基于奖励的元学习器组合起来作为交易机构。</li><li>此外，Yang 等人（2020 年）基于三种不同的指标训练了一个集成交易机构： 近端策略优化（PPO）、优势行为批判（A2C）和深度确定性策略梯度（DDPG）。集成策略综合了三种不同算法的优势。</li></ul> </li><li>此外，一些研究人员尝试使用集成策略来解决疾病预测问题。Tang 等人（2016）提出的模型由多个子模型组成，这些子模型响应不同的解剖部位。</li></ul> </li></ul> 
<h5><a id="476_Consensus_561"></a>4.7.6 Consensus</h5> 
<p>共识</p> 
<ul><li> <p><strong>无监督学习（Unsupervised learning）简介</strong>：</p> 
  <ul><li> <p>无监督学习是另一类机器学习技术。它与有监督学习的根本区别在于，<strong>无监督学习通常处理没有相应标签的训练样本</strong>。因此，无监督学习的主要用途是进行聚类。之所以采用集成方法，是为了将一些弱聚类合并成强聚类。</p> </li><li> <p>要创建不同的聚类，可以采用以下几种方法：</p> 
    <ul><li> <p>使用不同的采样数据</p> </li><li> <p>使用原始特征的不同子集以及采用不同的聚类方法（Şenbabaoğlu 等人，2014 年）。</p> </li><li> <p>有时，甚至可以在这些基础模型中加入一些随机噪声以增加随机性，根据 Bian 和 Wang（2007）的说法，这对集成方法很有好处。</p> </li><li> <p>在收到每个聚类的所有输出后，可以根据用户的要求选择各种共识函数来获得最终输出（Vega-Pons 和 RuizShulcloper，2011 年）。集成聚类也称为共识聚类 图 7.</p> <p><img src="https://images2.imgbox.com/a7/e6/IUolAP8W_o.png" alt="在这里插入图片描述"></p> <p>图片注解：共识聚类过程。不同聚类结果的集成可以通过共识方法进行组合。</p> </li></ul> </li></ul> </li><li> <p><strong>无监督学习现状</strong>：</p> 
  <ul><li>Zhou 和 Tang（2006 年）探索了无监督学习的集合方法，并开发了四种不同的方法来组合这些聚类的输出。</li><li>近年来，一些新的集合聚类方法被提出，说明了集合学习的优先性（Huang 等人，2017b；Zheng 等人，2010；Huang 等人，2016a）。 
    <ul><li>大多数聚类集成方法都是基于共关联矩阵求解的，这可以看作是一个图划分问题。</li><li>此外，也有一些研究聚焦于将深度结构与集合聚类方法进行集成。Liu等人（2015，2016）首次表明，具有深度结构的集成无监督表示学习可以应用于大规模数据中。随后，作者将该方法与自动编码器相结合，并扩展到视觉领域。</li><li>Shaham 等人（2016）首先证明了一些众包算法可以用具有单个隐藏神经元的受限玻尔兹曼机（Restricted Boltzmann Machine）来代替，然后提出了一种基于 RBM 的深度神经网络（Deep Neural Net，DNN）用于无监督集合学习。</li></ul> </li><li>无监督集成方法也为自然语言处理领域做出了一些贡献。 
    <ul><li>Alami 等人（2019）根据实验证明，使用 Sentence2Vec 表示法作为输入的无监督深度神经网络模型的集成具有最佳性能。</li><li>Hassan 等人（2019）提出了一种包含四种语义相似性度量的模块，它提高了语义文本相似性（STS）任务的性能。</li></ul> </li><li>无监督集成方法也广泛应用于缺乏注释的任务，如医学图像。 
    <ul><li>Ahn 等人（2019）提出了一种将集合方法与传统卷积神经网络集成的无监督特征学习方法。</li><li>Lahiri 等人（2016）在视网膜血管分割任务中采用了无监督分层特征学习与集合稀疏自编码器，同时，Liu 等人（2019）也提出了一种无监督集合架构来自动分割视网膜血管。</li><li>除此之外，还有一些集成深度方法致力于长非编码 RNA 的定位预测 Cao 等（2018）。</li><li>Hu 和 Suganthan（2022 年）将集成随机向量功能链接扩展到了无监督任务。作者采用流形正则化（manifold regularization）重新表示原始特征，然后使用库恩-蒙克雷算法（Kuhn-Munkre algorithm）与共识聚类（consensus clustering）对多个隐藏层的聚类结果进行集成。</li></ul> </li></ul> </li></ul> 
<h5><a id="477_QueryByCommittee_599"></a>4.7.7 Query-By-Committee</h5> 
<p>委员会查询</p> 
<ul><li> <p><strong>委员会查询（Query-By-Committee）设计思想</strong>：</p> 
  <ul><li>主动学习（Active Learning）是深度学习领域的另一个热门话题，它也经常与半监督学习和集成学习结合使用。</li><li>其主要目的是<strong>让算法从注释较少的数据中学习</strong>。</li></ul> </li><li> <p>实例：</p> 
  <ul><li> <p>一些传统的主动学习算法，如 Query-By-Committee（如图 8 所示），已经采用了集成学习的思想。</p> <p><img src="https://images2.imgbox.com/2e/de/Kg20qCOp_o.png" alt="在这里插入图片描述"></p> <p>图片注解：主动学习中的按委员会查询。使用替换抽样法将已标注的训练数据集分割成训练片段。委员会根据几种算法的输出结果来决定是否对数据进行标注。</p> </li><li> <p>Melville 和 Mooney（2003，2004）探索了一种建立多样化委员会的集成方法。</p> </li><li> <p>Beluch 等人（2018）讨论了集合的主动学习能力明显优于蒙特卡洛辍学（Monte-Carlo Dropout）和几何方法。</p> </li><li> <p>Sharma 和 Rani（2018）展示了药物靶标相互作用预测中的一些应用。集成主动学习也可用于征服概念漂移和类不平衡问题（Zhang 等，2018）。</p> </li></ul> </li></ul> 
<h3><a id="Section_5_Applications_623"></a>Section 5 Applications</h3> 
<p>应用</p> 
<ul><li> <p>在本节中，我们将以表格形式简要介绍深度集成模型在不同领域的应用。集成深度模型已在多个领域得到应用，因此，从广义上讲，我们将应用领域分为五类，即<strong>医疗保健、语音、图像分类、预测</strong>，其余模型则被列入其他类别。</p> </li><li> <p><strong>医疗保健</strong>：</p> <p>表 4 列出了已在医疗保健领域实施的集成深度模型的相关信息。这里有几篇论文基于异构集成技术。它揭示了在一个框架中使用不同系列的模型在医疗保健领域会有更好的表现。最近，深度集成技术在医疗保健领域取得了成功，并显示出良好的性能。</p> <p><img src="https://images2.imgbox.com/5d/e1/WPEyTgL7_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>语音</strong>：</p> <p>表 5 列出了已用于语音任务的模型，其中大多数集成方法都基于堆叠技术。</p> <p><img src="https://images2.imgbox.com/72/7f/7Ltvz5pG_o.png" alt="在这里插入图片描述"></p> <p>表 6 列出了在语音领域应用的集成深度模型。</p> <p><img src="https://images2.imgbox.com/cb/e1/14wpB3l8_o.png" alt="在这里插入图片描述"></p> </li><li> <p>表 7 和表 8 分别列出了<strong>在预测和其他领域应用的模型</strong>。</p> <p><img src="https://images2.imgbox.com/94/7b/2O3vfbDK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a7/5b/d1jnvE9R_o.png" alt="在这里插入图片描述"></p> </li><li> <p>图 9 显示了<strong>应用领域的百分比</strong>。统计结果显示，不同的集成深度技术被应用于不同的领域。较多的模型（即 27% 的集成深度模型）被应用于医疗保健领域，5.6% 的模型被应用于语音领域，22.5% 的模型被应用于图像分类任务。此外，9%的模型用于预测，36%的模型用于其他应用领域，如信息检索、情感识别、文本分类等。</p> <p><img src="https://images2.imgbox.com/b5/f5/ZFP4zY75_o.png" alt="在这里插入图片描述"></p> </li><li> <p>图 10 显示了<strong>按百分比计算的集成策略</strong>。在集合学习中，有多种方法可以将模型的结果集成在一个集合中。在文献中，研究人员根据不同的应用领域提出了不同的决策融合技术。Bagging, boosting 和 stacking 是经典的集合技术。在这三种技术的基础上，研究人员还开发了其他几种技术。提升（18.2%）、堆叠（12.5%）和袋聚（4.5%）技术已在集成深度框架中实现。异构集成和隐式集成也是制作高效集成模型的常用方法，它们的贡献率分别为 11.4% 和 10.2%。其余的集成技术有：无监督（3.4%）、NCL（3.4%）、强化（1.1%）、主动学习（1.1%）、显式集成（1.1%）和同构集成（3.4%）。</p> <p><img src="https://images2.imgbox.com/4c/d2/VqoFbUx2_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h3><a id="Section_6_Conclusions_and_future_works_663"></a>Section 6 Conclusions and future works</h3> 
<p>结论和未来工作</p> 
<ul><li> <p><strong>本文工作</strong>：</p> <p>本文回顾了近年来集成深度学习模型的发展。我们阐述了集合学习的理论背景，以了解集合学习的成功之处。从传统的装袋法（bagging）、提升学习（boosting）到最近的隐式/显式集成、异构集成等新方法，各种方法都为深度集成模型带来了更好的性能。我们还回顾了深度集成模型在不同领域的应用。</p> </li><li> <p><strong>未来工作</strong>：</p> <p>管深度集成模型已被应用于不同领域，但未来仍有几个开放性问题可以探索，以填补空白。大数据（Zhou 等人，2014 年）仍然是一个具有挑战性的问题，人们可以利用隐式深度集成等技术探索深度集成模型学习模式的优势，从而在时间和泛化两方面实现性能最大化。</p> </li><li> <p><strong>深度集成模型</strong>：</p> 
  <ul><li> <p><strong>深度集成训练困难问题</strong>：</p> 
    <ul><li>深度学习模型比浅层模型更难训练，因为需要调整不同层对应的大量权重。<strong>创建深度集成模型可能会使问题进一步复杂化</strong>。因此，可以探索<strong>随机模型</strong>来克服训练成本。基于 Bagging 的深度集成可能会花费大量的训练时间来优化集成模型。因此，我们可以研究其他方法，以较低的训练成本在基础模型中引入多样性。</li><li>随机化学习模块，如： 
      <ul><li>随机向量功能链接网络（Pao 等人，1994 年），最适合用于创建集合模型，因为随机化模型能显著减少方差。而且，隐藏层是随机初始化的，因此，可用于创建深度集成，而不会产生任何额外的训练成本（Shi 等人，2021 年）。</li><li>可以使用不同的技术进一步探索随机化模块，比如隐式/显式集成（Shi 等人，2021 年）、基于堆叠的集成（Katuwal 和 Suganthan，2019 年）。 
        <ul><li>与训练多个深度模型相比，隐式/显式集成速度更快。然而，在单个模型中创建多样性是一个巨大的挑战。人们可以探索在这些集成中诱导学习者之间更多多样性的方法，比如基于分支的深度模型（Han 等，2017）。研究将显式/隐式集成扩展到传统模型。</li><li>继基于堆叠的方法–深度凸网（DCN）（Deng and Yu，2011）之后，随机森林（Breiman，2001；Zhou and Feng，2017）、支持向量机（Wang et al.，2019d,a；Li et al.，2019b）等传统方法也被扩展到深度学习架构，从而提高了性能。人们可以研究这些传统模型来创建深度集成模型。</li></ul> </li><li>不过，还有一些开放的方向可以研究，比如负相关学习、异构集成等。</li></ul> </li></ul> </li><li> <p><strong>模型选择问题</strong>：</p> <p>集合深度学习的另一大挑战在于构建集合架构的模型选择，同构集合和异构集合代表了两种不同的模型选择方式。然而，要回答在集成架构中有多少种不同的算法，以及有多少个基础学习器，仍然要<strong>视问题而定</strong>。找到集成深度学习中<strong>模型选择的标准</strong>，应该是研究人员未来几年的重要目标。由于大多数模型都专注于开发架构，而很少关注如何组合基础学习器，因此预测问题仍然没有答案。因此，我们可以研究不同的融合策略对集成输出预测的影响。</p> </li></ul> </li><li> <p><strong>无监督集成学习与共识聚类</strong></p> 
  <ul><li>对于无监督集成学习或共识聚类，集合方法包括但不限于以下几种： 超图分割法、投票法、互信息法等。</li><li>共识聚类是一种强大的工具，在大多数情况下都能提高性能。但是，共识聚类仍有许多问题需要解决，如 
    <ul><li>共识聚类<strong>非常敏感</strong>， 
      <ul><li>可能会出现明显的结构却没有明显的分界线，</li><li>或者宣布聚类稳定却没有聚类阻力。</li></ul> </li><li>此外，目前的方法<strong>无法处理一些复杂但可能出现的情况</strong>，如边界样本被分配到单个聚类、聚类不相交、方法无法表示异常值等。这些都是未来工作可能的研究方向。</li></ul> </li></ul> </li><li> <p><strong>半监督集成领域</strong>：</p> <p>目前，半监督集成域的问题还没有得到广泛的研究，大多数文献显示，半监督集成方法主要用于标注数据不足的情况。此外，将半监督与其他一些机器学习方法（如主动学习）相结合也是未来研究的一个方向。</p> </li><li> <p><strong>强化学习</strong>：</p> <p>强化学习是最近另一个热门话题。将基于模型的强化学习与集成学习相结合的想法已在许多应用中取得了可喜的成果，但很少有人将基于规划与学习的强化学习与集成学习方法相结合。</p> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c830ed022feee6300436dbd32eb89751/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RobotFrameWork自动化测试框架如何搭建环境？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0199aa2f61517e777d95d8c6c7207181/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于物理表面张力-神经网络分类方法实现对教师学校心理社会风险水平的预测研究（Matlab代码实现）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>