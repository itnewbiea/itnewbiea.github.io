<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C# Task和异步方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C# Task和异步方法" />
<meta property="og:description" content="ThreadPool中有若干数量的线程。当有任务需要处理时，会从线程池中获取一个空闲的线程来执行任务，任务执行完毕后线程不会销毁，而是被线程池回收以供后续任务使用。当线程池中所有的线程都被占用，又有新任务要处理时，线程池会新建一个线程来处理该任务。如果线程数量达到设置的最大值，任务会排队，等待其他任务释放线程后再执行。ThreadPool相对于Thread来说可以减少线程的创建，有效减小系统开销。但是ThreadPool不能控制线程的执行顺序，也不能获取线程池内线程取消/异常/完成的通知，即不能有效监控和控制线程池中的线程。因此NET4.0在ThreadPool的基础上推出了Task。Task拥有线程池的优点，同时也解决了使用线程池不易控制的弊端。
1.无返回值的Task的创建和执行
using System; using System.Threading.Tasks; using System.Threading; namespace TaskDemo { class Program { static void Main(string[] args) { // 实例化一个Task，通过Start方法启动 Task task = new Task( () =&gt; { Thread.Sleep(1000); Console.WriteLine($&#34;NEW实例化一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}&#34;); } ); task.Start(); // Task.Factory.StartNew(Action action)创建和启动一个Task Task task2 = Task.Factory.StartNew( () =&gt; { Thread.Sleep(500); Console.WriteLine($&#34;Task.Factory.StartNew方式创建一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}&#34;); }); // Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task Task task3 = Task.Run( () =&gt; { Thread.Sleep(200); Console.WriteLine($&#34;Task.Run方式创建一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}&#34;); }); Console.WriteLine(&#34;执行主线程&#34;); Console.Read(); } } } 运行结果：
2.用Task.Result获取返回值的Task的创建和执行
namespace TaskDemo { class Program { static void Main(string[] args) { // 有返回值的启动task Task&lt;string&gt; task = new Task&lt;string&gt;( () =&gt; { Thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a6253fac74a014206c298f05558a2f02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-17T16:46:36+08:00" />
<meta property="article:modified_time" content="2021-11-17T16:46:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C# Task和异步方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>ThreadPool中有若干数量的线程。当有任务需要处理时，会从线程池中获取一个空闲的线程来执行任务，任务执行完毕后线程不会销毁，而是被线程池回收以供后续任务使用。当线程池中所有的线程都被占用，又有新任务要处理时，线程池会新建一个线程来处理该任务。如果线程数量达到设置的最大值，任务会排队，等待其他任务释放线程后再执行。ThreadPool相对于Thread来说可以减少线程的创建，有效减小系统开销。但是ThreadPool不能控制线程的执行顺序，也不能获取线程池内线程取消/异常/完成的通知，即不能有效监控和控制线程池中的线程。因此NET4.0在ThreadPool的基础上推出了Task。Task拥有线程池的优点，同时也解决了使用线程池不易控制的弊端。</p> 
<p>1.无返回值的Task的创建和执行</p> 
<pre><code>using System;
using System.Threading.Tasks;
using System.Threading;

namespace TaskDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            // 实例化一个Task，通过Start方法启动
            Task task = new Task(
                () =&gt;
                {
                    Thread.Sleep(1000);
                    Console.WriteLine($"NEW实例化一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}");
                }
                );

            task.Start();

            // Task.Factory.StartNew(Action action)创建和启动一个Task
            Task task2 = Task.Factory.StartNew(
                () =&gt;
                {
                    Thread.Sleep(500);
                    Console.WriteLine($"Task.Factory.StartNew方式创建一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}");
                });
            
            // Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task
            Task task3 = Task.Run(
                () =&gt;
                {
                    Thread.Sleep(200);
                    Console.WriteLine($"Task.Run方式创建一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}");
                });

            Console.WriteLine("执行主线程");
            Console.Read();
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bc/89/N4llRE8k_o.png"></p> 
<p> 2.用Task.Result获取返回值的Task的创建和执行</p> 
<pre><code>namespace TaskDemo
{
    class Program
    {
        static void Main(string[] args)
        {

            // 有返回值的启动task
            Task&lt;string&gt; task = new Task&lt;string&gt;(
                () =&gt;
                {
                    Thread.Sleep(1000);
                    return $"NEW实例化一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}";
                }
                );

            task.Start();

            // Task.Factory.StartNew(Action action)创建和启动一个Task

            Task&lt;string&gt; task2 = Task.Factory.StartNew(
                () =&gt;
                {
                    Thread.Sleep(3000);
                    return $"Task.Factory.StartNew方式创建一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}";
                });

            // Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task

            Task&lt;string&gt; task3 = Task.Run(
                () =&gt;
                {
                    Thread.Sleep(2000);
                    return $"Task.Run方式创建一个task，线程ID为{Thread.CurrentThread.ManagedThreadId}";
                });

            Console.WriteLine("执行主线程");
            Console.WriteLine(task.Result);
            Console.WriteLine(task2.Result);
            Console.WriteLine(task3.Result);
            Console.Read();
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f7/2e/oYvoFSNG_o.png"></p> 
<p>可见Task.Result获取返回值时会阻塞线程。本例中，必须等到task2执行完成，获取到返回值后，才能继续执行task3。但是上面两个例子中的Task的执行都是异步的，不会阻塞主线程。</p> 
<p>3.同步执行Task，会阻塞主线程</p> 
<pre><code>namespace TaskDemo
{
    class Program
    {
        static void Main(string[] args)
        {

            Task task = new Task(
                () =&gt;
                {
                    Thread.Sleep(1000);
                    Console.WriteLine("执行Task结束");
                }
                );           

            // 同步执行，会阻碍主线程
            task.RunSynchronously();
            Console.WriteLine("执行主线程");
            Console.Read();
        }
    }
}</code></pre> 
<p> 运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b4/85/jSlcy2Ki_o.png"></p> 
<p> 4.Task的阻塞方法（Wait/WaitAll/WaitAny）</p> 
<p>使用Task Wait/WaitAll/WaitAny方法，实现阻塞线程</p> 
<ul><li>task.Wait()表示等待task执行完毕，类似于thread.Join()</li><li>task.WaitAll(Task[] tasks)表示只有所有的task都执行完毕再解除阻塞</li><li>task.WaitAny(Task[] tasks)表示只要有一个task执行完毕就解除阻塞</li></ul> 
<pre><code>Task task1 = new Task(
                () =&gt;
                {
                    Thread.Sleep(1000);
                    Console.WriteLine("线程1执行完毕");
                });
            task1.Start();

            Task task2 = new Task(
                () =&gt;
                {
                    Thread.Sleep(2000);
                    Console.WriteLine("线程2执行完毕");
                });
            task2.Start();

            // 阻塞主线程。task1和task2都执行完毕再执行主线程
            //task1.Wait();
            //task2.Wait();
            Task.WaitAll(new Task[] { task1, task2 });
            Console.WriteLine("主线程执行完毕");
            Console.Read();</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b9/c0/e2FbtiY9_o.png"></p> 
<p> 使用task1.Wait(); task2.Wait()可以达到同样的目的。如果把WaitAll改成WaitAny，则运行结果如下所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e0/0a/5P3Fqiuw_o.png"></p> 
<p> </p> 
<p>5.Task的延续操作（WhenAny/WhenAll/ContinueWith）</p> 
<p>Wait/WaitAll/WaitAny方法返回值都是void，这些方法只是单纯的实现阻塞线程。使用WhenAny/WhenAll/ContinueWith方法可以让task执行完毕后，继续执行后续操作，这些方法执行完成返回一个task实例。</p> 
<p>task.WhenAll(Task[] tasks)表示所有的task都执行完毕后再去执行后续的操作</p> 
<p>task.WhenAny(Task[] tasks)表示任一task执行完毕后就开始执行后续操作</p> 
<pre><code>Task task1 = new Task(
                () =&gt;
                {
                    Thread.Sleep(1000);
                    Console.WriteLine("线程1执行完毕");
                });
            task1.Start();

            Task task2 = new Task(
                () =&gt;
                {
                    Thread.Sleep(2000);
                    Console.WriteLine("线程2执行完毕");
                });
            task2.Start();

            Task.WhenAll(new Task[] { task1, task2 }).ContinueWith(
                (t) =&gt;
                {
                    Thread.Sleep(1000);
                    Console.WriteLine("执行后续操作完毕");
                });

            Console.WriteLine("主线程执行完毕");
            Console.Read();</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/97/91/8NSZqpMZ_o.png"></p> 
<p> WhenAll/WhenAny方法并不会阻塞主线程。也可以使用Task.Factory.ContinueWhenAll来实现</p> 
<pre><code>Task.Factory.ContinueWhenAll(new Task[] { task1, task2 }, (t) =&gt;
            {
                Thread.Sleep(1000);
                Console.WriteLine("执行后续操作完毕");
            });</code></pre> 
<p>6.Task的任务取消（CancellationTokenSource）</p> 
<p>使用专门类CancellationTokenSource来取消任务执行。</p> 
<pre><code>CancellationTokenSource source = new CancellationTokenSource();
            int index = 0;
            Task task1 = new Task(
                () =&gt;
                {
                    while (!source.IsCancellationRequested)
                    {
                        Thread.Sleep(1000);
                        Console.WriteLine($"第{++index}次执行，线程运行中...");
                    }

                });
            task1.Start();
            Console.WriteLine("主线程开始执行");
            Thread.Sleep(5000);
            source.Cancel();
            Console.WriteLine("主线程执行完毕");
            Console.Read();</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2c/95/2DyZTgJE_o.png"></p> 
<p> 还可以使用source.CancelAfter(5000)实现5s后自动取消任务，即Thread.Sleep(5000); source.Cancel();这两条代码由source.CancelAfter(5000)取代。运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/25/09/2fwwNuyb_o.png"></p> 
<p> 注意这两次运行结果中，“主线程执行完毕”的区别。也可以通过source.Token.Register(Action action)注册取消任务触发的回调函数。</p> 
<pre><code>CancellationTokenSource source = new CancellationTokenSource();
            source.Token.Register(
                () =&gt;
                {
                    Console.WriteLine("任务被取消后执行的操作");
                });
            int index = 0;
            Task task1 = new Task(
                () =&gt;
                {
                    Console.WriteLine($"task1的线程ID是{Thread.CurrentThread.ManagedThreadId}");
                    while (!source.IsCancellationRequested)
                    {
                        Thread.Sleep(1000);
                        Console.WriteLine($"第{++index}次执行，线程运行中...");
                    }

                });
            task1.Start();
            Console.WriteLine($"主线程开始执行,主线程的ID是{Thread.CurrentThread.ManagedThreadId}");
            source.CancelAfter(5000);
            Console.WriteLine("主线程执行完毕");
            
            Console.Read();</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/2c/4j8qA7Gh_o.png"></p> 
<p>7.异步方法（async/await）</p> 
<pre><code>async static Task&lt;string&gt;GetContentAsync(string fileName)
        {
            Console.WriteLine($"当前线程ID是{Thread.CurrentThread.ManagedThreadId}");
            Console.WriteLine($"开始读取文件:{DateTime.Now}");
            Thread.Sleep(1000);
            using(StreamReader sr = new StreamReader(fileName))
            {
                string program = await sr.ReadToEndAsync();
                Console.WriteLine($"读取文件结束:{DateTime.Now}");
                return program;
            }
        }

        // 同步读取文件内容
        static string GetContent(string fileName)
        {
            using (StreamReader sr = new StreamReader(fileName))
            {
                string program = sr.ReadToEnd();
                return program;
            }
        }
        static void Main(string[] args)
        {
            string path = @"D:\Demos\TaskDemo\postdata.txt";
            Console.WriteLine($"主线程ID是{Thread.CurrentThread.ManagedThreadId}");
            Console.WriteLine($"主程序执行开始：{DateTime.Now}");
            string content = GetContentAsync(path).Result;
            Console.WriteLine($"主程序输入结果：{content}");
            Console.WriteLine($"主程序执行结束：{DateTime.Now}");
            Console.Read();
        }</code></pre> 
<p> 运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4c/7a/6X9G1IaE_o.png"></p> 
<p> 主程序等待GetContentAsync方法执行完毕后，获取到返回值后才继续执行。这说明，如果调用方法要从调用中获取一个T类型的值，异步方法的返回类型必须是Task&lt;T&gt;，而且调用会获取到返回值后才会继续执行下去。如果仅仅是调用一下异步方法，不和异步方法做其他交互，则将异步方法签名返回值为void，这种调用形式也被称为“调用并忘记”。</p> 
<pre><code>async static void GetContentAsync(string fileName)
        {
            Console.WriteLine($"当前线程ID是{Thread.CurrentThread.ManagedThreadId}");
            Console.WriteLine($"开始读取文件:{DateTime.Now}");
            Thread.Sleep(1000);
            using(StreamReader sr = new StreamReader(fileName))
            {
                string program = await sr.ReadToEndAsync();
                Console.WriteLine($"读取文件结束:{DateTime.Now}");
            }
        }

static void Main(string[] args)
        {
            string path = @"D:\Demos\TaskDemo\postdata.txt";
            Console.WriteLine($"主线程ID是{Thread.CurrentThread.ManagedThreadId}");
            Console.WriteLine($"主程序执行开始：{DateTime.Now}");
            GetContentAsync(path);
            Console.WriteLine($"主程序执行结束：{DateTime.Now}");
            Console.Read();
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/eb/2b/wZcCmGbw_o.png"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/250c31d7fb785e8ec149b362621e8bfa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">webpack及babel配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b27e220746f711bc06a986d1faebcf2e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">turtle标准库的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>