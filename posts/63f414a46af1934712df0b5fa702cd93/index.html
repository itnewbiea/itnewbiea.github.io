<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>桶排序及一些其应用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="桶排序及一些其应用" />
<meta property="og:description" content="海量数据 一年的全国高考考生人数为500 万，分数使用标准分，最低100 ，最高900 ，没有小数，要求对这500 万元素的 数组进行排序。 分析：对500W 数据排序，如果基于比较的先进排序，平均比较次数为O(5000000*log5000000)≈1.112亿。但是我们发现，这些数据都有特殊的条件： 100=&lt;score&lt;=900。那么我们就可以考虑桶排序这样一个“投机取巧”的办法、让其在毫秒级别就完成500万排序。 方法：创建801(900-100)个桶。将每个考生的分数丢进f(score)=score-100的桶中。这个过程从头到尾遍历一遍数据只需要500W次。然后根据桶号大小依次将桶中数值输出，即可以得到一个有序的序列。而且可以很容易的得到100分有***人，501分有***人。 实际上，桶排序对数据的条件有特殊要求，如果上面的分数不是从100-900，而是从0-2亿，那么分配2亿个桶显然是不可能的。所以桶排序有其局限性，适合元素值集合并不大的情况。 典型 这个算法的精妙之处在于第三步中,似乎和分治法的思想有些像,通过不断缩小判断方法来不断降低目标数的位置的模糊度
在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。只写出思路即可（内存限制为2G意思是可以使用2G空间来运行程序，而不考虑本机上其他软件内存占用情况。） 关于中位数：数据排序后，位置在最中间的数值。即将数据分成两部分，一部分大于该数值，一部分小于该数值。中位数的位置：当样本数为奇数时，中位数=(N&#43;1)/2 ; 当样本数为偶数时，中位数为N/2与1&#43;N/2的均值（那么10G个数的中位数，就第5G大的数与第5G&#43;1大的数的均值了）。 分析：既然要找中位数，很简单就是排序的想法。那么基于 字节的桶排序是一个可行的方法。 思想：将整型的每1byte作为一个关键字，也就是说一个整形可以拆成4个keys，而且最高位的keys越大，整数越大。如果高位keys相同，则比较次高位的keys。整个比较过程类似于字符串的 字典序。 第一步:把10G整数每2G读入一次内存，然后一次遍历这536,870,912即（1024*1024*1024）*2 /4个数据。每个数据用位运算&#34;&gt;&gt;&#34;取出最高8位(31-24)。这8bits(0-255)最多表示256个桶，那么可以根据8bit的值来确定丢入第几个桶。最后把每个桶写入一个磁盘文件中，同时在内存中统计每个桶内数据的数量NUM[256]。 代价：(1) 10G数据依次读入内存的IO代价(这个是无法避免的，CPU不能直接在 磁盘上运算)。(2)在内存中遍历536,870,912个数据，这是一个O(n)的线性 时间复杂度。(3)把256个桶写回到256个磁盘文件空间中，这个代价是额外的，也就是多付出一倍的10G数据转移的时间。 第二步：根据内存中256个桶内的数量NUM[256]，计算中位数在第几个桶中。很显然，2,684,354,560个数中位数是第1,342,177,280个。假设前127个桶的数据量相加，发现少于1,342,177,280，把第128个桶数据量加上，大于1,342,177,280。说明，中位数必在 磁盘的第128个桶中。而且在这个桶的第1,342,177,280-N(0-127)个数位上。N(0-127)表示前127个桶的数据量之和。然后把第128个文件中的整数读入内存。(若数据大致是均匀分布的，每个文件的大小估计在10G/256=40M左右，当然也不一定，但是超过2G的可能性很小)。注意，变态的情况下，这个需要读入的第128号文件仍然大于2G，那么整个读入仍然可以按照第一步分批来进行读取。 代价：(1)循环计算255个桶中的数据量累加，需要O(M)的代价，其中m&lt;255。(2)读入一个大概80M左右文件大小的IO代价。 第三步：继续以内存中的某个桶内整数的次高8bit（他们的最高8bit是一样的）进行桶排序(23-16)。过程和第一步相同，也是256个桶。 第四步：一直下去，直到最低字节(7-0bit)的桶排序结束。我相信这个时候完全可以在内存中使用一次快排就可以了。 整个过程的 时间复杂度在O(n)的线性级别上(没有任何 循环嵌套)。但主要时间消耗在第一步的第二次内存-磁盘数据交换上，即10G数据分255个文件写回磁盘上。一般而言，如果第二步过后，内存可以容纳下存在中位数的某一个文件的话，直接快排就可以了（修改者注：我想，继续桶排序但不写回磁盘，效率会更高？）。 [2] 转载于:https://www.cnblogs.com/Gaoqiking/p/11127690.html" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/63f414a46af1934712df0b5fa702cd93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T17:12:00+08:00" />
<meta property="article:modified_time" content="2019-07-03T17:12:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">桶排序及一些其应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div class="para-title level-3"> 
  <h4 class="title-text">海量数据</h4> 
 </div> 
 <div class="para">
   一年的全国高考考生人数为500 万，分数使用标准分，最低100 ，最高900 ，没有小数，要求对这500 万元素的 
  <a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" rel="nofollow">数组</a>进行排序。 
 </div> 
 <div class="para">
   分析：对500W 
  <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F" rel="nofollow">数据排序</a>，如果基于比较的先进排序，平均比较次数为O(5000000*log5000000)≈1.112亿。但是我们发现，这些数据都有特殊的条件： 100=&lt;score&lt;=900。那么我们就可以考虑桶排序这样一个“投机取巧”的办法、让其在毫秒级别就完成500万排序。 
 </div> 
 <div class="para">
   方法：创建801(900-100)个桶。将每个考生的分数丢进f(score)=score-100的桶中。这个过程从头到尾遍历一遍数据只需要500W次。然后根据桶号大小依次将桶中数值输出，即可以得到一个有序的序列。而且可以很容易的得到100分有***人，501分有***人。 
 </div> 
 <div class="para">
   实际上，桶排序对数据的条件有特殊要求，如果上面的分数不是从100-900，而是从0-2亿，那么分配2亿个桶显然是不可能的。所以桶排序有其局限性，适合元素值集合并不大的情况。 
 </div> 
 <div class="para"> 
  <div class="para-title level-3"> 
   <h4 class="title-text">典型</h4> 
   <p>这个算法的精妙之处在于第三步中,似乎和分治法的思想有些像,通过不断缩小判断方法来不断降低目标数的位置的模糊度</p> 
  </div> 
  <div class="para">
    在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。只写出思路即可（内存限制为2G意思是可以使用2G空间来运行程序，而不考虑本机上其他软件内存占用情况。） 关于中位数：数据排序后，位置在最中间的数值。即将数据分成两部分，一部分大于该数值，一部分小于该数值。中位数的位置：当样本数为奇数时，中位数=(N+1)/2 ; 当样本数为偶数时，中位数为N/2与1+N/2的均值（那么10G个数的中位数，就第5G大的数与第5G+1大的数的均值了）。 
  </div> 
  <div class="para">
    分析：既然要找中位数，很简单就是排序的想法。那么基于 
   <a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" rel="nofollow">字节</a>的桶排序是一个可行的方法。 
  </div> 
  <div class="para">
    思想：将整型的每1byte作为一个关键字，也就是说一个整形可以拆成4个keys，而且最高位的keys越大，整数越大。如果高位keys相同，则比较次高位的keys。整个比较过程类似于字符串的 
   <a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F" rel="nofollow">字典序</a>。 
  </div> 
  <div class="para">
    第一步:把10G整数每2G读入一次内存，然后一次遍历这536,870,912即（1024*1024*1024）*2 /4个数据。每个数据用位运算"&gt;&gt;"取出最高8位(31-24)。这8bits(0-255)最多表示256个桶，那么可以根据8bit的值来确定丢入第几个桶。最后把每个桶写入一个磁盘文件中，同时在内存中统计每个桶内数据的数量NUM[256]。 
  </div> 
  <div class="para">
    代价：(1) 10G数据依次读入内存的IO代价(这个是无法避免的，CPU不能直接在 
   <a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98" rel="nofollow">磁盘</a>上运算)。(2)在内存中遍历536,870,912个数据，这是一个O(n)的线性 
   <a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">时间复杂度</a>。(3)把256个桶写回到256个磁盘文件空间中，这个代价是额外的，也就是多付出一倍的10G数据转移的时间。 
  </div> 
  <div class="para">
    第二步：根据内存中256个桶内的数量NUM[256]，计算中位数在第几个桶中。很显然，2,684,354,560个数中位数是第1,342,177,280个。假设前127个桶的数据量相加，发现少于1,342,177,280，把第128个桶数据量加上，大于1,342,177,280。说明，中位数必在 
   <a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98" rel="nofollow">磁盘</a>的第128个桶中。而且在这个桶的第1,342,177,280-N(0-127)个数位上。N(0-127)表示前127个桶的数据量之和。然后把第128个文件中的整数读入内存。(若数据大致是均匀分布的，每个文件的大小估计在10G/256=40M左右，当然也不一定，但是超过2G的可能性很小)。注意，变态的情况下，这个需要读入的第128号文件仍然大于2G，那么整个读入仍然可以按照第一步分批来进行读取。 
  </div> 
  <div class="para">
    代价：(1)循环计算255个桶中的数据量累加，需要O(M)的代价，其中m&lt;255。(2)读入一个大概80M左右文件大小的IO代价。 
  </div> 
  <div class="para">
    第三步：继续以内存中的某个桶内整数的次高8bit（他们的最高8bit是一样的）进行桶排序(23-16)。过程和第一步相同，也是256个桶。 
  </div> 
  <div class="para">
    第四步：一直下去，直到最低字节(7-0bit)的桶排序结束。我相信这个时候完全可以在内存中使用一次快排就可以了。 
  </div> 
  <div class="para">
    整个过程的 
   <a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">时间复杂度</a>在O(n)的线性级别上(没有任何 
   <a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97" rel="nofollow">循环嵌套</a>)。但主要时间消耗在第一步的第二次内存-磁盘数据交换上，即10G数据分255个文件写回磁盘上。一般而言，如果第二步过后，内存可以容纳下存在中位数的某一个文件的话，直接快排就可以了（修改者注：我想，继续桶排序但不写回磁盘，效率会更高？）。 
   <span class="sup--normal"> [2]<a class="sup-anchor" name="ref_%5B2%5D_1784217"></a> </span> 
  </div> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/Gaoqiking/p/11127690.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d1c4b8b5e89ead8ea42d0ee94a0c7e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Git_Windows 系统下Git安装图解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/693452f80b2787668b4e517619198596/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">found for dependency: expected at least 1 bean which qualifies as autowire candidate for this depend</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>