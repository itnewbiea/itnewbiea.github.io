<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>rebar3使用介绍（二）配置项 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="rebar3使用介绍（二）配置项" />
<meta property="og:description" content="rebar3使用介绍（二） 全局配置Alias 别名ArtifactsCompilation测试选项CoverDialyzerDistributionDirectories 目录EDocEscriptEUnit最小OTP版本检查OverridesHook 钩子shell钩子功能钩子自写功能中可以hook的点 RELXSHELLXRef 本篇主要介绍rebar3的配置部分 全局配置 rebar3支持全局配置，这也配置生效于环境中的所有rebar3，配置在操作系统的环境变量中，有以下内容：
REBAR_PROFILE=“term” # force a base profile
HEX_CDN=“https://…” # change the Hex endpoint for a private one
REBAR_CONFIG=“rebar3.config” # changes the name of rebar.config files
QUIET=1 # only display errors
DEBUG=1 # show debug output
# “QUIET=1 DEBUG=1” displays both errors and warnings
REBAR_COLOR=“low” # reduces amount of color in output if supported
REBAR_CACHE_DIR # override where rebar3 stores config and cache data" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c4c108997ffdf872c7a4e027befdba7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-12T16:56:33+08:00" />
<meta property="article:modified_time" content="2018-11-12T16:56:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">rebar3使用介绍（二）配置项</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>rebar3使用介绍（二）</h4> 
 <ul><li><a href="#_3" rel="nofollow">全局配置</a></li><li><a href="#Alias__17" rel="nofollow">Alias 别名</a></li><li><a href="#Artifacts_24" rel="nofollow">Artifacts</a></li><li><a href="#Compilation_53" rel="nofollow">Compilation</a></li><li><a href="#_99" rel="nofollow">测试选项</a></li><li><a href="#Cover_107" rel="nofollow">Cover</a></li><li><a href="#Dialyzer_110" rel="nofollow">Dialyzer</a></li><li><a href="#Distribution_116" rel="nofollow">Distribution</a></li><li><a href="#Directories__125" rel="nofollow">Directories 目录</a></li><li><a href="#EDoc_150" rel="nofollow">EDoc</a></li><li><a href="#Escript_153" rel="nofollow">Escript</a></li><li><a href="#EUnit_156" rel="nofollow">EUnit</a></li><li><a href="#OTP_164" rel="nofollow">最小OTP版本检查</a></li><li><a href="#Overrides_169" rel="nofollow">Overrides</a></li><li><a href="#Hook__184" rel="nofollow">Hook 钩子</a></li><li><ul><li><a href="#shell_186" rel="nofollow">shell钩子</a></li><li><a href="#_201" rel="nofollow">功能钩子</a></li><li><a href="#hook_211" rel="nofollow">自写功能中可以hook的点</a></li></ul> 
  </li><li><a href="#RELX_238" rel="nofollow">RELX</a></li><li><a href="#SHELL_241" rel="nofollow">SHELL</a></li><li><a href="#XRef_251" rel="nofollow">XRef</a></li></ul> 
</div> 
<br> 本篇主要介绍rebar3的配置部分 
<p></p> 
<h2><a id="_3"></a>全局配置</h2> 
<p>rebar3支持全局配置，这也配置生效于环境中的所有rebar3，配置在操作系统的环境变量中，有以下内容：</p> 
<blockquote> 
 <p>REBAR_PROFILE=“term” # force a base profile<br> HEX_CDN=“https://…” # change the Hex endpoint for a private one<br> REBAR_CONFIG=“rebar3.config” # changes the name of rebar.config files<br> QUIET=1 # only display errors<br> DEBUG=1 # show debug output<br> # “QUIET=1 DEBUG=1” displays both errors and warnings<br> REBAR_COLOR=“low” # reduces amount of color in output if supported<br> REBAR_CACHE_DIR # override where rebar3 stores config and cache data<br> http_proxy # standard proxy ENV variable is respected<br> https_proxy # standard proxy ENV variable is respected</p> 
</blockquote> 
<h2><a id="Alias__17"></a>Alias 别名</h2> 
<p>别名允许你根据现有命令，创造一个新的命令出来，当然他们必须有固定的执行顺序才行，比如</p> 
<pre><code class="prism language-erlang">{alias, [{check, [eunit, {ct, "--sys_config=config/app.config"}]}]}.
</code></pre> 
<p>配置中的元素可以是check这种单个atom代表一个动作，也可以是 {ct, “–sys_config=config/app.config”} 这种代表一个带参的动作，执行顺序永远是从左到右串行执行。</p> 
<h2><a id="Artifacts_24"></a>Artifacts</h2> 
<p>Artifacts可以理解成一个项目编译完成后的资源的集合体，这在你的项目中有非erlang的模块时会非常实用，比如你用C编写了共享库，将它的产出文件配置进去，就可以判断编译是否成功。<br> 如果发现已经构建了一个依赖项（意味着它的.app文件的模块列表与其.beam文件匹配）那么在随后的rebar3调用中就都不会编译这部分，也就不会触发这部分的hook。</p> 
<p>相对路径于取决于它是否在伞状项目的顶层定义。例如，假设我们有一个项目my_project包含应用程序my_app在apps/my_app/下，my_app会创建一个escript。在rebar3不要在意配置在my_project/rebar.config中，因为它是整个项目的顶级rebar.config。该artifact会相对profile_dir，默认情况下是_build/default/：</p> 
<pre><code class="prism language-erlang">{artifacts, ["bin/rebar3"]}.
</code></pre> 
<p>像上面我们检查的就是 _build/default/bin/rebar3<br> 如果不是在顶层，比如my_app有自己的rebar.config,那么定义在这个rebar.config中的相对目录就是_build/default/lib/my_app/ 而不是 _build/default，因为rebar的伞状构建特性，必须要确保子项目能自己完成自己的检查，这样的设定也是合理的</p> 
<p>相反的如果项目不是伞状项目，即使my_app是在顶层，rebar.config在根目录下，Artifacts项的相对目录也是_build/default/lib/my_app/</p> 
<p>rebar3提供了几个宏来扩展相对目录如下：</p> 
<table><thead><tr><th>Key</th><th>描述</th></tr></thead><tbody><tr><td>profile_dir</td><td>The base output directory with the profile string appended, default: <code>_build/default/</code>.</td></tr><tr><td>base_dir</td><td>The base output directory, default: <code>_build</code>.</td></tr><tr><td>out_dir</td><td>The application’s output directory, default:<code>_build/default/lib/&lt;application&gt;/</code>.</td></tr></tbody></table> 
<p>再举一个实例，eleveldb</p> 
<pre><code class="prism language-erlang">{overrides,
 [{override, eleveldb, [{artifacts, ["priv/eleveldb.so"]},
                        ...
                       ]
  }]}.
</code></pre> 
<p>因为这个是eleveldb自己的rebar.config，所以<code>"priv/eleveldb.so"</code> 就相当于<code>"{<!-- -->{out_dir}}priv/eleveldb.so"</code></p> 
<h2><a id="Compilation_53"></a>Compilation</h2> 
<p>编译选项定义在erl_opts字段下，具体可使用的字段和值参照<a href="http://erlang.org/doc/man/compile.html" rel="nofollow">erlang的编译选项</a></p> 
<pre><code class="prism language-erlang">{erl_opts, [
  debug_info,
  {parse_transform, lager_transform},
  warn_export_all,
  warn_unused_import,
  {i, "include"},
  {src_dirs, ["src"]}]}.
</code></pre> 
<p>除此之外，还可以设置特定于平台的选项。</p> 
<pre><code class="prism language-erlang"> {erl_opts, [{platform_define,
               "(linux|solaris|freebsd|darwin)",
               'HAVE_SENDFILE'},
              {platform_define, "(linux|freebsd)",
                'BACKLOG', 128},
              {platform_define, "R13",
                'old_inets'}]
}.
</code></pre> 
<p>这里支持匹配例如</p> 
<pre><code class="prism language-erlang">{platform_define, "^((?!R1[456]).)*$", 'maps_support'}
</code></pre> 
<p>一个单独的编译选项是声明模块在所有其他模块之前编译的选项：</p> 
<pre><code class="prism language-erlang">{erl_first_files, ["src/lager_util.erl"]}.
</code></pre> 
<p>还有一些额外的单独编译选项</p> 
<pre><code class="prism language-erlang">{validate_app_modules, true}. % Make sure modules in .app match those found in code
{app_vars_file, undefined | Path}. % file containing elements to put in all generated app files
%% Paths the compiler outputs when reporting warnings or errors
%% relative (default), build (all paths are in _build, default prior
%% to 3.2.0, and absolute are valid options
{compiler_source_format, relative}.
</code></pre> 
<p>其他与Erlang相关的编译器支持自己的配置选项：</p> 
<ul><li>Leex编译器与{xrl_opts, […]}</li><li>SNMP MIB编译器与{mib_opts, […]}</li><li>Yecc编译器与{yrl_opts, […]}</li></ul> 
<h2><a id="_99"></a>测试选项</h2> 
<pre><code class="prism language-erlang">{ct_first_files, [...]}. % {erl_first_files, ...} but for CT
{ct_opts, [...]}. % same as options for ct:run_test(...)
{ct_readable, true | false}. % disable rebar3 modifying CT output in the shell
</code></pre> 
<p>ct_opts支持的字段可以在<a href="http://www.erlang.org/doc/man/ct.html#run_test-1" rel="nofollow">这里</a>找到</p> 
<h2><a id="Cover_107"></a>Cover</h2> 
<p>具体看<a href="http://www.rebar3.org/docs/running-tests" rel="nofollow">这</a></p> 
<h2><a id="Dialyzer_110"></a>Dialyzer</h2> 
<pre><code class="prism language-erlang">{dialyzer, [Opts]}
</code></pre> 
<p>支持选项看<a href="http://erlang.org/doc/man/dialyzer.html" rel="nofollow">这</a></p> 
<h2><a id="Distribution_116"></a>Distribution</h2> 
<p>多个功能和插件可能需要支持分布式Erlang。通常，所有此类命令（例如ct和shell）的配置都遵循以下配置值：</p> 
<pre><code class="prism language-erlang">{dist_node, [
    {setcookie, 'atom-cookie'},
    {name | sname, 'nodename'},
]}.
</code></pre> 
<h2><a id="Directories__125"></a>Directories 目录</h2> 
<p>可支持选项和默认值如下:</p> 
<pre><code class="prism language-erlang">%% directory for artifacts produced by rebar3
{base_dir, "_build"}.
%% directory in '&lt;base_dir&gt;/&lt;profile&gt;/' where deps go
{deps_dir, "lib"}.
%% where rebar3 operates from; defaults to the current working directory
{root_dir, "."}.
%% where checkout dependencies are to be located
{checkouts_dir, "_checkouts"}.
%% directory in '&lt;base_dir&gt;/&lt;profile&gt;/' where plugins go
{plugins_dir, "plugins"}.
%% directories where OTP applications for the project can be located
{project_app_dirs, ["apps/*", "lib/*", "."]}.
%% Directories where source files for an OTP application can be found
{src_dirs, ["src"]}.
%% Paths to miscellaneous Erlang files to compile for an app
%% without including them in its modules list
{extra_src_dirs, []}. 
%% Paths the compiler outputs when reporting warnings or errors
%% relative (default), build (all paths are in _build, default prior
%% to 3.2.0, and absolute are valid options
{compiler_source_format, relative}.
</code></pre> 
<h2><a id="EDoc_150"></a>EDoc</h2> 
<p>配置项看<a href="http://www.erlang.org/doc/man/edoc.html#run-3" rel="nofollow">这里</a></p> 
<h2><a id="Escript_153"></a>Escript</h2> 
<p><a href="http://www.rebar3.org/v3/docs/commands#escriptizehttps://note.youdao.com/" rel="nofollow">参看</a></p> 
<h2><a id="EUnit_156"></a>EUnit</h2> 
<pre><code class="prism language-erlang">{eunit_first_files, [...]}. % {erl_first_files, ...} but for CT
{eunit_opts, [...]}. % same as options for eunit:test(Tests, ...)
{eunit_tests, [...]}. % same as Tests argument in eunit:test(Tests, ...)
</code></pre> 
<p><a href="http://www.erlang.org/doc/man/eunit.html#test-2" rel="nofollow">opts选项参看这里</a></p> 
<h2><a id="OTP_164"></a>最小OTP版本检查</h2> 
<pre><code class="prism language-erlang">{minimum_otp_vsn, "17.4"}.
</code></pre> 
<h2><a id="Overrides_169"></a>Overrides</h2> 
<p>覆盖是出于自己的项目需要对依赖项目作出改动，但是这个改动又不想套用到库上，所以选作上层覆盖，Overrides支持add, override, del操作</p> 
<pre><code class="prism language-erlang">{overrides, [{add, app_name(), [{atom(), any()}]},
             {del, app_name(), [{atom(), any()}]},
             {override, app_name(), [{atom(), any()}]},
             {add, [{atom(), any()}]},
             {del, [{atom(), any()}]},
             {override, [{atom(), any()}]}]}.
</code></pre> 
<p>app_name有的时候只会对指定app进行操作，如果没有指定，则会对所有app进行指定</p> 
<p>这个特性允许你在不修改库的前提下，强制同意一些编译配置之类，或者针对自己的项目或者平台进行扩展</p> 
<h2><a id="Hook__184"></a>Hook 钩子</h2> 
<p>有两种类型的钩子：shell钩子和功能钩子</p> 
<h3><a id="shell_186"></a>shell钩子</h3> 
<pre><code class="prism language-erlang">{pre_hooks, [{clean, "./prepare_package_files.sh"},
             {"linux", compile, "c_src/build_linux.sh"},
             {compile, "escript generate_headers"},
             {compile, "escript check_headers"}]}.

{post_hooks, [{clean, "touch file1.out"},
              {"freebsd", compile, "c_src/freebsd_tweaks.sh"},
              {eunit, "touch file2.out"},
              {compile, "touch postcompile.out"}]}.
</code></pre> 
<p>如果命令内容比较复杂，最好还是用脚本包装起来后调用脚本，而不是在配置里写一大推<br> post_hooks 在调用失败的情况下是不会调用的，比如clean操作本身失败了，那么post_hooks指定的动作也就不会执行</p> 
<h3><a id="_201"></a>功能钩子</h3> 
<p>功能钩子，一般指的是通过用插件扩展的功能，不止局限于rebar本身提供的功能<br> 以下钩子在运行clean之前compile运行。</p> 
<pre><code class="prism language-erlang">{provider_hooks, [{pre, [{compile, clean}]}
                  {post, [{compile, {erlydtl, compile}}]}]}
</code></pre> 
<p>不需要参数就只需要填写命令的atom，如果需要用tuple带入<br> 功能钩子都是在shell钩子之前执行的</p> 
<h3><a id="hook_211"></a>自写功能中可以hook的点</h3> 
<p>只有部分功能支持附着钩子，</p> 
<table><thead><tr><th>Hook</th><th>before and after</th></tr></thead><tbody><tr><td>clean</td><td>每个应用程序和依赖项，和/或编译所有顶级应用程序之前和之后</td></tr><tr><td>compile</td><td>每个应用程序和依赖项，和/或编译所有顶级应用程序之前和之后</td></tr><tr><td>erlc_compile</td><td>编译应用程序的梁文件</td></tr><tr><td>app_compile</td><td>从.app.src为应用程序构建.app文件</td></tr><tr><td>ct</td><td>整个运行前后</td></tr><tr><td>edoc</td><td>整个运行前后</td></tr><tr><td>escriptize</td><td>整个运行前后</td></tr><tr><td>eunit</td><td>整个运行前后</td></tr><tr><td>release</td><td>整个运行前后</td></tr><tr><td>tar</td><td>整个运行前后</td></tr></tbody></table> 
<p>*默认情况下，这些钩子为每个应用程序运行，因为依赖项可以在它们自己的上下文中指定它们自己的钩子。区别在于，在某些情况下（伞形应用程序），钩子可以在许多级别上定义（省略覆盖）：</p> 
<ul><li>应用程序根目录下的rebar.config文件</li><li>每个顶级应用程序（在apps/或中libs/）rebar.config</li><li>每个依赖项的rebar.config</li></ul> 
<p>默认情况下，当没有伞形应用程序时，顶级rebar.config中定义的钩子将被归为顶级应用程序的一部分。这允许钩子在以后发布库时继续为依赖项工作。</p> 
<p>但是，如果钩子是在具有伞形应用程序的项目的根目录下的rebar.config中定义的，则钩子将在任务运行之前/之后为所有顶级应用程序运行。</p> 
<p>要保留伞状项目中的每个应用程序行为，必须在每个应用程序的rebar.config中定义钩子。</p> 
<h2><a id="RELX_238"></a>RELX</h2> 
<p><a href="http://www.rebar3.org/docs/releases" rel="nofollow">看这里</a></p> 
<h2><a id="SHELL_241"></a>SHELL</h2> 
<p>rebar3 shell如果relx找到条目，REPL将自动启动应用程序，但可以使用显式指定由shell启动的应用程序{shell, [{apps, [App]}]}。</p> 
<p>以下为扩展配置：</p> 
<table><thead><tr><th>Option</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>apps</td><td>[app1, app2, …]</td><td>要启动的app列表，追加在relx的配置后</td></tr><tr><td>config</td><td>“path/to/a/file.config”</td><td>加载指定配置</td></tr><tr><td>script_file</td><td>“path/to/a/file.escript”</td><td>执行自定义脚本</td></tr></tbody></table> 
<h2><a id="XRef_251"></a>XRef</h2> 
<pre><code class="prism language-erlang">{xref_warnings,false}.
{xref_extra_paths,[]}.
{xref_checks,[undefined_function_calls,undefined_functions,locals_not_used,
              exports_not_used,deprecated_function_calls,
              deprecated_functions]}.
{xref_queries,[{"(xc - uc) || (xu - x - b - (\"mod\":\".*foo\"/\"4\"))", []}]}.
{xref_ignores, [{M, F}, {M, F, A}]}.
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd397ae4a0716137b3cbc6c2f19bf271/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows10系统下软件丢失msvcr110.dll如何解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/710bcfc4eb7ea38044288b71b1fd23df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">rebar3使用介绍（三）命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>