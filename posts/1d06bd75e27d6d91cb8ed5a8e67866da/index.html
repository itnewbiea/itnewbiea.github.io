<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android开发之 SwipeRefreshLayout - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android开发之 SwipeRefreshLayout" />
<meta property="og:description" content="SwipeRefreshLayout概述 用户通过手势或者点击某个按钮实现内容视图的刷新，布局里加入SwipeRefreshLayout嵌套一个子视图如ListView、RecyclerView等，触发刷新会通过OnRefreshListener的onRefresh方法回调，我们在这里执行页面数据的刷新，每次手势的完成都会执行一次通知，根据滑动距离判断是否需要回调。setRefreshing（false）通过代码直接取消刷新，true则手动设置刷新调出刷新视图。setEnabled（false）通过boolean控制是否禁用手势刷新
SwipeRefreshLayout用法 xml布局 &lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:id=&#34;@&#43;id/swiperefresh&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34;&gt; &lt;ListView android:id=&#34;@android:id/list&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 代码调用 public class SwipeRefreshLayoutBasicFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { //...........=略................ mSwipeRefreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.swiperefresh); // 设置下拉刷新的圆的颜色 mSwipeRefreshLayout.setColorScheme( R.color.swipe_color_1, R.color.swipe_color_2, R.color.swipe_color_3, R.color.swipe_color_4); return view; } @Override public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); //初始化ListView布局 mListView.setAdapter(adapter); //绑定视图刷新的监听 mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { //TODO //重新获取完网络数据刷新Adapter，完成后需要调用onRefreshComplete方法取消滑出来的圆形进度 } }); } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1d06bd75e27d6d91cb8ed5a8e67866da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-05-03T15:50:02+08:00" />
<meta property="article:modified_time" content="2016-05-03T15:50:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android开发之 SwipeRefreshLayout</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5 id="swiperefreshlayout概述"><strong><em>SwipeRefreshLayout概述</em></strong></h5> 
<blockquote> 
 <p><strong><em>用户通过手势或者点击某个按钮实现内容视图的刷新，布局里加入SwipeRefreshLayout嵌套一个子视图如ListView、RecyclerView等，触发刷新会通过OnRefreshListener的onRefresh方法回调，我们在这里执行页面数据的刷新，每次手势的完成都会执行一次通知，根据滑动距离判断是否需要回调。setRefreshing（false）通过代码直接取消刷新，true则手动设置刷新调出刷新视图。setEnabled（false）通过boolean控制是否禁用手势刷新</em></strong></p> 
</blockquote> 
<h5 id="swiperefreshlayout用法"><strong><em>SwipeRefreshLayout用法</em></strong></h5> 
<h6 id="xml布局"><strong><em>xml布局</em></strong></h6> 
<pre class="prettyprint"><code class=" hljs avrasm">&lt;android<span class="hljs-preprocessor">.support</span><span class="hljs-preprocessor">.v</span>4<span class="hljs-preprocessor">.widget</span><span class="hljs-preprocessor">.SwipeRefreshLayout</span>
      xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
      android:id=<span class="hljs-string">"@+id/swiperefresh"</span>
      android:layout_width=<span class="hljs-string">"match_parent"</span>
      android:layout_height=<span class="hljs-string">"match_parent"</span>&gt;

    &lt;ListView
          android:id=<span class="hljs-string">"@android:id/list"</span>
          android:layout_width=<span class="hljs-string">"match_parent"</span>
          android:layout_height=<span class="hljs-string">"match_parent"</span> /&gt;

&lt;/android<span class="hljs-preprocessor">.support</span><span class="hljs-preprocessor">.v</span>4<span class="hljs-preprocessor">.widget</span><span class="hljs-preprocessor">.SwipeRefreshLayout</span>&gt;</code></pre> 
<h6 id="代码调用"><strong><em>代码调用</em></strong></h6> 
<pre class="prettyprint"><code class=" hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwipeRefreshLayoutBasicFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> {<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span>(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        <span class="hljs-comment">//...........=略................</span>
        mSwipeRefreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.swiperefresh);

        <span class="hljs-comment">// 设置下拉刷新的圆的颜色</span>
        mSwipeRefreshLayout.setColorScheme(
                R.color.swipe_color_1, R.color.swipe_color_2,
                R.color.swipe_color_3, R.color.swipe_color_4);

        <span class="hljs-keyword">return</span> view;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewCreated</span>(View view, Bundle savedInstanceState) {
        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState);
        <span class="hljs-comment">//初始化ListView布局</span>
        mListView.setAdapter(adapter);
        <span class="hljs-comment">//绑定视图刷新的监听</span>
        mSwipeRefreshLayout.setOnRefreshListener(<span class="hljs-keyword">new</span> SwipeRefreshLayout.OnRefreshListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span>() {
                <span class="hljs-comment">//TODO </span>
                <span class="hljs-comment">//重新获取完网络数据刷新Adapter，完成后需要调用onRefreshComplete方法取消滑出来的圆形进度</span>
            }
        });
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onOptionsItemSelected</span>(MenuItem item) {
        <span class="hljs-keyword">switch</span> (item.getItemId()) {
            <span class="hljs-keyword">case</span> R.id.menu_refresh:
                 <span class="hljs-comment">//手动点击按钮刷新视图如果当前视图状态没有刷新需要调用setRefreshing（true）</span>
                <span class="hljs-keyword">if</span> (!mSwipeRefreshLayout.isRefreshing()) {
                    mSwipeRefreshLayout.setRefreshing(<span class="hljs-keyword">true</span>);
                }
                initiateRefresh();
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onOptionsItemSelected(item);
    }

    <span class="hljs-javadoc">/**
     * 刷新Adapter并且取消刷新滑出来的进度视图
     **/</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefreshComplete</span>(List&lt;String&gt; result) {
        mSwipeRefreshLayout.setRefreshing(<span class="hljs-keyword">false</span>);
        adapter.onRefresh(result)
    }
}
</code></pre> 
<h5 id="swiperefreshlayout官方实践demo"><strong><em>SwipeRefreshLayout官方实践Demo</em></strong></h5> 
<p><em>在官网找到三个simple，前面两个simple主要是上面提到的基本用法，对我们来说用处不大</em></p> 
<ol><li><p><strong><em>SwipeRefreshLayoutBasic</em></strong></p></li><li><p><strong><em>SwipeRefreshListFragment</em></strong></p></li><li><p><strong><em>SwipeRefreshMultipleViews</em></strong></p></li></ol> 
<h6 id="multiswiperefreshlayout源码"><strong><em>MultiSwipeRefreshLayout源码</em></strong></h6> 
<p><em>在SwipeRefreshMultipleViews Simple里面提供了一个SwipeRefreshLayout的继承类MultiSwipeRefreshLayout，该类的作用用于子视图列表添加EmptyView，v4包里面没有这里贴上源码：</em></p> 
<pre class="prettyprint"><code class=" hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiSwipeRefreshLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SwipeRefreshLayout</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> View[] mSwipeableChildren;

    <span class="hljs-keyword">public</span> <span class="hljs-title">MultiSwipeRefreshLayout</span>(Context context) {
        <span class="hljs-keyword">super</span>(context);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">MultiSwipeRefreshLayout</span>(Context context, AttributeSet attrs) {
        <span class="hljs-keyword">super</span>(context, attrs);
    }

    <span class="hljs-javadoc">/**
     * Set the children which can trigger a refresh by swiping down when they are visible. These
     * views need to be a descendant of this view.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSwipeableChildren</span>(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>... ids) {
        <span class="hljs-keyword">assert</span> ids != <span class="hljs-keyword">null</span>;

        mSwipeableChildren = <span class="hljs-keyword">new</span> View[ids.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ids.length; i++) {
            mSwipeableChildren[i] = findViewById(ids[i]);
        }
    }

    <span class="hljs-javadoc">/**
     * This method controls when the swipe-to-refresh gesture is triggered. By returning false here
     * we are signifying that the view is in a state where a refresh gesture can start.
     *
     * &lt;p&gt;As {@link android.support.v4.widget.SwipeRefreshLayout} only supports one direct child by
     * default, we need to manually iterate through our swipeable children to see if any are in a
     * state to trigger the gesture. If so we return false to start the gesture.
     */</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canChildScrollUp</span>() {
        <span class="hljs-keyword">if</span> (mSwipeableChildren != <span class="hljs-keyword">null</span> &amp;&amp; mSwipeableChildren.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">for</span> (View view : mSwipeableChildren) {
                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span> &amp;&amp; view.isShown() &amp;&amp; !canViewScrollUp(view)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-javadoc">/**
     * Utility method to check whether a {@link View} can scroll up from it's current position.
     * Handles platform version differences, providing backwards compatible functionality where
     * needed.
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canViewScrollUp</span>(View view) {
        <span class="hljs-keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= <span class="hljs-number">14</span>) {
            <span class="hljs-keyword">return</span> ViewCompat.canScrollVertically(view, -<span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> AbsListView) {
                <span class="hljs-keyword">final</span> AbsListView listView = (AbsListView) view;
                <span class="hljs-keyword">return</span> listView.getChildCount() &gt; <span class="hljs-number">0</span> &amp;&amp;
                        (listView.getFirstVisiblePosition() &gt; <span class="hljs-number">0</span>
                                || listView.getChildAt(<span class="hljs-number">0</span>).getTop() &lt; listView.getPaddingTop());
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> view.getScrollY() &gt; <span class="hljs-number">0</span>;
            }
        }
    }
}</code></pre> 
<h6 id="multiswiperefreshlayout-xml布局"><strong><em>MultiSwipeRefreshLayout xml布局</em></strong></h6> 
<pre class="prettyprint"><code class=" hljs avrasm">
&lt;<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.android</span><span class="hljs-preprocessor">.swiperefreshmultipleviews</span><span class="hljs-preprocessor">.MultiSwipeRefreshLayout</span>
      xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
      android:id=<span class="hljs-string">"@+id/swiperefresh"</span>
      android:layout_width=<span class="hljs-string">"match_parent"</span>
      android:layout_height=<span class="hljs-string">"match_parent"</span>&gt;

    &lt;FrameLayout
          android:layout_width=<span class="hljs-string">"match_parent"</span>
          android:layout_height=<span class="hljs-string">"match_parent"</span>&gt;

        &lt;GridView
              android:id=<span class="hljs-string">"@android:id/list"</span>
              android:layout_width=<span class="hljs-string">"match_parent"</span>
              android:layout_height=<span class="hljs-string">"match_parent"</span>
              android:numColumns=<span class="hljs-string">"2"</span> /&gt;

        &lt;TextView
              android:id=<span class="hljs-string">"@android:id/empty"</span>
              android:layout_width=<span class="hljs-string">"wrap_content"</span>
              android:layout_height=<span class="hljs-string">"wrap_content"</span>
              android:text=<span class="hljs-string">"@string/empty_text"</span>
              android:layout_gravity=<span class="hljs-string">"center"</span>/&gt;

    &lt;/FrameLayout&gt;

&lt;/<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.android</span><span class="hljs-preprocessor">.swiperefreshmultipleviews</span><span class="hljs-preprocessor">.MultiSwipeRefreshLayout</span>&gt;</code></pre> 
<h6 id="multiswiperefreshlayout代码调用"><strong><em>MultiSwipeRefreshLayout代码调用</em></strong></h6> 
<pre class="prettyprint"><code class=" hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwipeRefreshMultipleViewsFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> {<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span>(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
       <span class="hljs-comment">//.............略...........</span>
        mSwipeRefreshLayout = (MultiSwipeRefreshLayout) view.findViewById(R.id.swiperefresh);
        <span class="hljs-comment">//设置进度圆形的颜色</span>
        mSwipeRefreshLayout.setColorScheme(
                R.color.swipe_color_1, R.color.swipe_color_2,
                R.color.swipe_color_3, R.color.swipe_color_4);

        mGridView = (GridView) view.findViewById(android.R.id.list);
        mEmptyView = view.findViewById(android.R.id.empty);

        <span class="hljs-keyword">return</span> view;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewCreated</span>(View view, Bundle savedInstanceState) {
        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState);

        mGridView.setAdapter(adapter);

        <span class="hljs-comment">// 当GridView没有数据时显示EmptyView</span>
        mGridView.setEmptyView(mEmptyView);

        <span class="hljs-comment">//设置需要Refresh视图</span>
        mSwipeRefreshLayout.setSwipeableChildren(android.R.id.list, android.R.id.empty);

        mSwipeRefreshLayout.setOnRefreshListener(<span class="hljs-keyword">new</span> SwipeRefreshLayout.OnRefreshListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span>() {
                <span class="hljs-comment">//TODO</span>
            }
        });
    }

}</code></pre> 
<h6 id="multiswiperefreshlayout实践"><strong><em>MultiSwipeRefreshLayout实践</em></strong></h6> 
<p><em>在官方提供的simple里面发现，EmptyView显示时，进度视图可能无法显示处理，但是OnRefreshListener的回调还是执行了，根据我的怀疑做了一个小小的实验，取消了setEmpty方法，发现就没问题，不过叠加显示会有问题了，需要手动控制Visibility，根据以上知识做了一个简单的demo实践（鸡汤：主题报错A TaskDescription’s primary color should be opaque，原因是颜色值缺损，需要补齐00-FF），效果图如下，奉上源码：<a href="http://download.csdn.net/detail/analyzesystem/9508674">http://download.csdn.net/detail/analyzesystem/9508674</a></em></p> 
<p><img src="https://images2.imgbox.com/46/f2/V4Do8IYa_o.gif" alt="" title=""></p> 
<h5 id="swiperefreshlayout源码剖析"><strong><em>SwipeRefreshLayout源码剖析</em></strong></h5> 
<p><img src="https://images2.imgbox.com/5e/a1/DsYXrCUk_o.png" alt="" title=""></p> 
<p><em>自定义控件SwipeRefreshLayout是一个自定义ViewGroup，这里面用到的NestedScrolling系列之前<a href="http://blog.csdn.net/analyzesystem/article/details/51122653">BottomBar篇</a>提到过这里就不再累赘叙述，自定义的ViewGroup内部涉及到MaterialProgressDrawable进度图片、CircleImageView（v4包里面的不是开源库那个），圆形进度图片的一些方法在SwipeRefreshLayout里面间接调用，下面从SwipeRefreshLayout的相关方法简单理解。</em></p> 
<hr> 
<p><em>reset方法就是调用子view的方法取消相应的动画，并且隐藏view,setProgressViewOffset方法对我们来说还是非常有用的，用于设置CircleView的进出动画是否执行缩放（API 11有兼容，向下无法执行缩放透明,开发兼容个人4.0+所以不存在任何问题）、以及下拉出现的位置和最大的下拉位置。</em></p> 
<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-javadoc">/**
  *<span class="hljs-javadoctag"> @param</span> 设置下拉出现小圆圈是否是缩放出现
  *<span class="hljs-javadoctag"> @param</span> 出现的位置
  *<span class="hljs-javadoctag"> @param</span> 最大的下拉位置
  **/</span>
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProgressViewOffset</span>(<span class="hljs-keyword">boolean</span> scale, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end) {
        mScale = scale;
        mCircleView.setVisibility(View.GONE);
        mOriginalOffsetTop = mCurrentTargetOffsetTop = start;
        mSpinnerFinalOffset = end;
        mUsingCustomStart = <span class="hljs-keyword">true</span>;
        mCircleView.invalidate();
    }</code></pre> 
<p><em>设置下拉圆圈的大小，通过注解ProgressDrawableSize两个类型： LARGE， DEFAULT，在SwipeRefreshLayout里面根据这两种类型选择不同的大小：CIRCLE_DIAMETER 、CIRCLE_DIAMETER_LARGE </em></p> 
<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CIRCLE_DIAMETER = <span class="hljs-number">40</span>;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CIRCLE_DIAMETER_LARGE = <span class="hljs-number">56</span>;

 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSize</span>(<span class="hljs-keyword">int</span> size) {
        <span class="hljs-keyword">if</span> (size != MaterialProgressDrawable.LARGE &amp;&amp; size != MaterialProgressDrawable.DEFAULT) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">final</span> DisplayMetrics metrics = getResources().getDisplayMetrics();
        <span class="hljs-keyword">if</span> (size == MaterialProgressDrawable.LARGE) {
            mCircleHeight = mCircleWidth = (<span class="hljs-keyword">int</span>) (CIRCLE_DIAMETER_LARGE * metrics.density);
        } <span class="hljs-keyword">else</span> {
            mCircleHeight = mCircleWidth = (<span class="hljs-keyword">int</span>) (CIRCLE_DIAMETER * metrics.density);
        }
        <span class="hljs-comment">// force the bounds of the progress circle inside the circle view to</span>
        <span class="hljs-comment">// update by setting it to null before updating its size and then</span>
        <span class="hljs-comment">// re-setting it</span>
        mCircleView.setImageDrawable(<span class="hljs-keyword">null</span>);
        mProgress.updateSizes(size);
        mCircleView.setImageDrawable(mProgress);
    }</code></pre> 
<p><em>在构造函数内部初始化必须变量，并为ViewGroup添加一个CircleView</em></p> 
<pre class="prettyprint"><code class=" hljs java">   <span class="hljs-javadoc">/**
     * Constructor that is called when inflating SwipeRefreshLayout from XML.
     *
     *<span class="hljs-javadoctag"> @param</span> context
     *<span class="hljs-javadoctag"> @param</span> attrs
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">SwipeRefreshLayout</span>(Context context, AttributeSet attrs) {
        <span class="hljs-keyword">super</span>(context, attrs);
        <span class="hljs-comment">//系统默认的最小滑动系数值</span>
        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
        <span class="hljs-comment">//默认动画时常400</span>
        mMediumAnimationDuration = getResources().getInteger(
                android.R.integer.config_mediumAnimTime);

        setWillNotDraw(<span class="hljs-keyword">false</span>);
        mDecelerateInterpolator = <span class="hljs-keyword">new</span> DecelerateInterpolator(DECELERATE_INTERPOLATION_FACTOR);

        <span class="hljs-keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs, LAYOUT_ATTRS);
        setEnabled(a.getBoolean(<span class="hljs-number">0</span>, <span class="hljs-keyword">true</span>));
        a.recycle();

        <span class="hljs-keyword">final</span> DisplayMetrics metrics = getResources().getDisplayMetrics();
        mCircleWidth = (<span class="hljs-keyword">int</span>) (CIRCLE_DIAMETER * metrics.density);
        mCircleHeight = (<span class="hljs-keyword">int</span>) (CIRCLE_DIAMETER * metrics.density);
        <span class="hljs-comment">//创建CircleView并添加到ViewGroup</span>
        createProgressView();
        ViewCompat.setChildrenDrawingOrderEnabled(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);
        <span class="hljs-comment">// the absolute offset has to take into account that the circle starts at an offset</span>
        mSpinnerFinalOffset = DEFAULT_CIRCLE_TARGET * metrics.density;
        mTotalDragDistance = mSpinnerFinalOffset;
        <span class="hljs-comment">//通过 NestedScrolling 处理嵌套滑动</span>
        mNestedScrollingParentHelper = <span class="hljs-keyword">new</span> NestedScrollingParentHelper(<span class="hljs-keyword">this</span>);
        mNestedScrollingChildHelper = <span class="hljs-keyword">new</span> NestedScrollingChildHelper(<span class="hljs-keyword">this</span>);
        setNestedScrollingEnabled(<span class="hljs-keyword">true</span>);
    }</code></pre> 
<p><em>判断字视图是否支持滑动刷新,根据View类型和ViewCompat调用底层方法判断，如果你要自定义SwipeRefreshLayout需要重写方法，参考示例如MultiSwipeRefreshLayout内部具体实现</em></p> 
<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-javadoc">/**
     *<span class="hljs-javadoctag"> @return</span> Whether it is possible for the child view of this layout to
     *         scroll up. Override this if the child view is a custom view.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canChildScrollUp</span>() {
        <span class="hljs-keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class="hljs-number">14</span>) {
            <span class="hljs-keyword">if</span> (mTarget <span class="hljs-keyword">instanceof</span> AbsListView) {
                <span class="hljs-keyword">final</span> AbsListView absListView = (AbsListView) mTarget;
                <span class="hljs-keyword">return</span> absListView.getChildCount() &gt; <span class="hljs-number">0</span>
                        &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class="hljs-number">0</span> || absListView.getChildAt(<span class="hljs-number">0</span>)
                                .getTop() &lt; absListView.getPaddingTop());
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> ViewCompat.canScrollVertically(mTarget, -<span class="hljs-number">1</span>) || mTarget.getScrollY() &gt; <span class="hljs-number">0</span>;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> ViewCompat.canScrollVertically(mTarget, -<span class="hljs-number">1</span>);
        }
    }</code></pre> 
<p><em>内部提供了几个setColor系列的方法，其实本质在调用子View进行赋值，这里不累赘叙述以mProgress为例</em></p> 
<pre class="prettyprint"><code class=" hljs java">  <span class="hljs-javadoc">/**
     * Set the colors used in the progress animation. The first
     * color will also be the color of the bar that grows in response to a user
     * swipe gesture.
     *
     *<span class="hljs-javadoctag"> @param</span> colors
     */</span>
    <span class="hljs-annotation">@ColorInt</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColorSchemeColors</span>(<span class="hljs-keyword">int</span>... colors) {
        ensureTarget();
        mProgress.setColorSchemeColors(colors);
    }
</code></pre> 
<p>再过完一遍代码后发现，很多发放与我们使用都无关，就不细解了，如果你还想了解更多，在这里奉上我在github搜到的关于SwipeRefreshLayout源码分析一篇：<a href="https://github.com/hanks-zyh/SwipeRefreshLayout">https://github.com/hanks-zyh/SwipeRefreshLayout</a></p> 
<h5 id="swiperefreshlayout开源项目推荐"><strong><em>SwipeRefreshLayout开源项目推荐</em></strong></h5> 
<p>SwipeRefresh开源库推荐两个，一个是基于ListView支持下拉刷新上啦加载更多的，一个是使用Builder构建，基于RecyclerView实现，并且同样支持下拉刷新上啦加载更多，下面是相关链接</p> 
<ul><li><p><a href="https://github.com/kodyan/SwipeRefreshLayout">SwipeRefreshLayout</a></p> <p><img src="https://images2.imgbox.com/57/25/76lPARpN_o.gif" alt="" title=""></p> <p><em>代码调用风格：</em> </p></li></ul> 
<pre class="prettyprint"><code class=" hljs avrasm">    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super<span class="hljs-preprocessor">.onCreate</span>(savedInstanceState)<span class="hljs-comment">;</span>
        setContentView(R<span class="hljs-preprocessor">.layout</span><span class="hljs-preprocessor">.activity</span>_main)<span class="hljs-comment">;</span>

        mRefreshLayout = (RefreshLayout) findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.swipe</span>_container)<span class="hljs-comment">;</span>
        mListView = (ListView) findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.list</span>)<span class="hljs-comment">;</span>
        footerLayout = getLayoutInflater()<span class="hljs-preprocessor">.inflate</span>(R<span class="hljs-preprocessor">.layout</span><span class="hljs-preprocessor">.listview</span>_footer, null)<span class="hljs-comment">;</span>

        mListView<span class="hljs-preprocessor">.addFooterView</span>(footerLayout)<span class="hljs-comment">;</span>
        mRefreshLayout<span class="hljs-preprocessor">.setChildView</span>(mListView)<span class="hljs-comment">;</span>

        mListView<span class="hljs-preprocessor">.setAdapter</span>(mAdapter)<span class="hljs-comment">;</span>

        mRefreshLayout<span class="hljs-preprocessor">.setColorSchemeResources</span>(R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.google</span>_blue,
                R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.google</span>_green,
                R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.google</span>_red,
                R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.google</span>_yellow)<span class="hljs-comment">;</span>

        mRefreshLayout<span class="hljs-preprocessor">.setOnRefreshListener</span>(new RefreshLayout<span class="hljs-preprocessor">.OnRefreshListener</span>() {
            @Override
            public void onRefresh() {
             // start to refresh
            }
        })<span class="hljs-comment">;</span>
        mRefreshLayout<span class="hljs-preprocessor">.setOnLoadListener</span>(new RefreshLayout<span class="hljs-preprocessor">.OnLoadListener</span>() {
            @Override
            public void onLoad() {
                // start to load   
            }
        })<span class="hljs-comment">;</span>
    }</code></pre> 
<p><strong><em>在本篇博客发表一段时间后，在此实战了该库，发现每次都要调用一些基本配置，个人感觉很麻烦，于是乎RefreshLayoutHelper类诞生</em></strong></p> 
<pre class="prettyprint"><code class=" hljs java">
<span class="hljs-javadoc">/**
 * Created by idea on 2016/5/20.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefreshLayoutHelper</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> View footerLayout;
    <span class="hljs-keyword">private</span> TextView footerLable;
    <span class="hljs-keyword">private</span> ProgressBar progressBar;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RefreshLayoutHelper instance;
    <span class="hljs-keyword">private</span> RefreshLayout refreshLayout;
    <span class="hljs-keyword">private</span> ListView mListView;
    <span class="hljs-keyword">private</span> RefreshLayout.OnRefreshListener onRefreshListener;
    <span class="hljs-keyword">private</span> RefreshLayout.OnLoadListener onLoadMoreListener;
    <span class="hljs-keyword">private</span> BaseActivity mActivity;

    <span class="hljs-keyword">private</span> <span class="hljs-title">RefreshLayoutHelper</span>() {

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RefreshLayoutHelper <span class="hljs-title">getInstance</span>() {

        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">synchronized</span> (RefreshLayoutHelper.class) {
                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
                    instance = <span class="hljs-keyword">new</span> RefreshLayoutHelper();
                }
            }
        }
        <span class="hljs-keyword">return</span> instance;
    }
    <span class="hljs-javadoc">/***
     * Activity初始化调用
     **/</span>
    <span class="hljs-keyword">public</span> RefreshLayoutHelper <span class="hljs-title">init</span>(BaseActivity mActivity,RefreshLayout refreshLayout,ListView mListView,RefreshLayout.OnRefreshListener onRefreshListener,RefreshLayout.OnLoadListener onLoadListener){
        <span class="hljs-keyword">this</span>.mActivity = mActivity;
        <span class="hljs-keyword">this</span>.refreshLayout = refreshLayout;
        <span class="hljs-keyword">this</span>.mListView = mListView;
        <span class="hljs-keyword">this</span>.onRefreshListener = onRefreshListener;
        <span class="hljs-keyword">this</span>.onLoadMoreListener = onLoadListener;
        <span class="hljs-keyword">return</span> instance;
    }

    <span class="hljs-javadoc">/***
     * 添加加载更多footer
     **/</span>
    <span class="hljs-keyword">public</span> RefreshLayoutHelper <span class="hljs-title">configFooterView</span>(){
        footerLayout = mActivity.getLayoutInflater().inflate(R.layout.footer, <span class="hljs-keyword">null</span>);
        footerLayout.setVisibility(View.GONE);
        footerLable = (TextView) footerLayout.findViewById(R.id.text_more);
        progressBar = (ProgressBar) footerLayout.findViewById(R.id.load_progress_bar);
        footerLable.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(View v) {
                showLoadMoreView();
                onLoadMoreListener.onLoad();
            }
        });

        <span class="hljs-comment">//这里可以替换为自定义的footer布局</span>
        <span class="hljs-comment">//you can custom FooterView</span>
        mListView.addFooterView(footerLayout);
        refreshLayout.setChildView(mListView);
        <span class="hljs-keyword">return</span> instance;
    }

    <span class="hljs-javadoc">/**
     * 初始化配置直接弹出刷新动画转圈
     *<span class="hljs-javadoctag"> @param</span> colorResIds
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSwipeRefreshLayout</span>(<span class="hljs-keyword">int</span>... colorResIds){
        refreshLayout.setColorSchemeResources(colorResIds);
        refreshLayout.setProgressViewOffset(<span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">24</span>);

        refreshLayout.setOnRefreshListener(onRefreshListener);
        refreshLayout.setOnLoadListener(onLoadMoreListener);

        refreshLayout.setRefreshing(<span class="hljs-keyword">true</span>);
        onRefreshListener.onRefresh();
    }

    <span class="hljs-javadoc">/**
     * footer显示加载进度
     **/</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showLoadMoreView</span>() {
        footerLable.setVisibility(View.GONE);
        progressBar.setVisibility(View.VISIBLE);
    }

    <span class="hljs-javadoc">/**
     * 显示加载更多
     **/</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelLoadMoreView</span>() {
        footerLable.setVisibility(View.VISIBLE);
        progressBar.setVisibility(View.GONE);
    }

    <span class="hljs-javadoc">/**
     * 判断是否还有下一页，选择是否隐藏加载更多
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completeRefreshView</span>(<span class="hljs-keyword">final</span> BaseAdapter adapter,<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pageSize){

        refreshLayout.postDelayed(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
                refreshLayout.setRefreshing(<span class="hljs-keyword">false</span>);
                refreshLayout.setLoading(<span class="hljs-keyword">false</span>);
                cancelLoadMoreView();
                <span class="hljs-keyword">if</span> (adapter.getCount() != <span class="hljs-number">0</span> &amp;&amp; adapter.getCount() % pageSize == <span class="hljs-number">0</span>) {
                    footerLayout.setVisibility(View.VISIBLE);
                } <span class="hljs-keyword">else</span> {
                    footerLayout.setVisibility(View.INVISIBLE);
                }
            }
        }, <span class="hljs-number">1000</span>);

    }
}
</code></pre> 
<p><em>调用流程如下：</em></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXXActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RefreshLayout</span>.<span class="hljs-title">OnRefreshListener</span>, <span class="hljs-title">RefreshLayout</span>.<span class="hljs-title">OnLoadListener</span> {<!-- --></span>

  protect <span class="hljs-keyword">void</span> onCreat(..){
    setContentView..
      refreshLayoutHelper = RefreshLayoutHelper.getInstance()
                              .init(<span class="hljs-keyword">this</span>,refreshLayout,mListView,<span class="hljs-keyword">this</span>,<span class="hljs-keyword">this</span>)
                              .configFooterView();
      <span class="hljs-comment">//.................略...................                        </span>
      mListView.setAdapter(adapter)
      refreshLayoutHelper.initSwipeRefreshLayout(R.color.swipe_color_1, R.color.swipe_color_2,
                R.color.swipe_color_3, R.color.swipe_color_4);

   }

}</code></pre> 
<ul><li><p><a href="https://github.com/undownding/SwipePresenter">SwipePresenter</a></p> <p><em>代码调用风格：</em></p></li></ul> 
<pre class="prettyprint"><code class=" hljs java">presenter = <span class="hljs-keyword">new</span> SwipePresenter.Builder()
        .onCreated(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
                recyclerview.setLayoutManager(<span class="hljs-keyword">new</span> StaggeredGridLayoutManager(
                        <span class="hljs-number">2</span>, StaggeredGridLayoutManager.VERTICAL)
                );
                recyclerview.setAdapter(adapter);
            }
        })
        .swipeRefreshLayout(swipeRefreshLayout)
        .recyclerView(recyclerview)
        .emptyView(emptyView)
        .onRefresh(<span class="hljs-keyword">new</span> SwipeRefreshLayout.OnRefreshListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span>() {
                presenter.stopRefresh();
            }
        })
        .onLoadMore(<span class="hljs-keyword">new</span> SwipePresenter.AutoLoadMoreListener(<span class="hljs-number">4</span>) {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoadMore</span>(RecyclerView recyclerView) {
                finishLoadingMore(); <span class="hljs-comment">// or you can replace this with presenter.finishLoadingMore();</span>
            }
        })
        .build();</code></pre> 
<hr> 
<h5 id="结语"><strong><em>结语</em></strong></h5> 
<p><strong><em>花了一点时间整理SwipeRefreshLayout这块的知识还是值得的，收获也有不少，以前没用过的方法比如setProgressViewOffset以前就没用过，再比如MultiSwipeRefreshLayout这个意外收获，此刻的心情是开森的，在此，借古人一句话送给大家：时而学习之不亦说乎！</em></strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21610f77a2f8c4aa33ec19810981c32f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mongoose（三）：数据类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b95e3610e442ea847bd0bfb3b9984cb7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JQuery插件iScroll实现下拉刷新，滚动翻页特效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>