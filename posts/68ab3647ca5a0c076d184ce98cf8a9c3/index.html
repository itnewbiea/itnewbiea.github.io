<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Yocto（一）-介绍 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Yocto（一）-介绍" />
<meta property="og:description" content="1. 背景 在嵌入式产品开发中，通常都会定制自己公司的Linux发行版，所谓发行版，即根据自家产品的功能和特性定制bootloader、kernel、rootfs，最后得到这三个的镜像文件。
定制Linux发行版是一件耗时耗力、技术含量比较高的一项大工程，对于很多公司来说，是没有这个人力和财力来做这件事的，所以大多数公司会选择现有的开源工具来定制自己家的 Linux 发行版。
据我所知，当前比较主流的开源工具有两款，分别是 Buildroot 和 Yocto，它们都是开源的工程，思想也大体相同，就是将很多的开发包集成到开源工具中，然后根据自家产品的功能和特性进行配置，配置完成后进行编译时就会只编译并集成被配置的开发包，没被配置的开发包不会下载或者不会被集成到最终的镜像文件中。
在汽车电子行业，Yocto 是主流，至于为啥我也不知道，Buildroot 和 Yocto 我都有研究过一点点，但是在工作中目前只接触过 Yocto，所谓“没有实践就没有发言权”，所以本章就只介绍一下Yocto。
2. 官方资源 官网：https://www.yoctoproject.org/
yocto项目快速开始手册：https://www.yoctoproject.org/docs/2.1/yocto-project-qs/yocto-project-qs.html
yocto项目开发参考手册：https://www.yoctoproject.org/docs/1.5/ref-manual/ref-manual.html
3. 组成 Recipes：.bb/.bbappend文件，即配方文件，描述了从哪获取软件源码，如何配置，如何编译。bbappend和bb的区别主要在于bbappend是基于bb的，功能是对相应的bb文件作补充和覆盖，有点类似于“重写”的概念。
Class：.bbclass文件，即类文件，包含在配方文件之间共享的有用信息。比如autotools该类，其中包含Autotools使用的任何应用程序的常用设置。Yocto项目参考手册中的“ 类 ”一章提供了有关类及其使用方法的详细信息。https://www.yoctoproject.org/docs/2.5/ref-manual/ref-manual.html#ref-classes
Configuration：.conf文件，即配置文件，我们可以用它来改变构建方式，比如conf/local.conf可以配置机器配置选项，分发配置选项，编译器调整选项，常规通用配置选项和用户配置选项 。
conf/bblayers.conf中可以添加用到的layer层路径，从而在编译时将他们添加进去。层是组织文件和目录结构的元数据（配置文件、配方）集合。
4. 配置 Yocto的目的很简单，它要经过一级一级配置，逐步缩小配方，直至得到uboot、kernel、rootfs这三个image。每一级需要哪些配方，由该级对应的配置文件（conf/bb）决定。越上级的配置是越笼统的，越下级的配置越细致。如果下级的配置项相对于上级有补充或者冲突，则以下级的内容为准，可以认为下级会对上级进行“重写”。
有关构建的路线和流程：对于整个发行版构建，虽然每一级的配方由（conf/bb）决定，但是每一级路线和方向的选择，是由我们最终bitbake的对象决定的，BitBake需要一些基本配置文件才能完成构建。这些文件是*.conf文件。最低限度必需的文件作为示例文件驻留 在build/conf。比如我们最终bitbake avi-image-core，我们想要获得rootfs.img，那么：
第一步Poky就会从local.conf开始，一路向下，一级一级配置，直到配置到和rootfs有关的那一堆bb，最终形成完整完全的配方 第二步获取配方需要的资源，比如各种软件包，比如kernel的源码 第三步把所有的资源编译出我们需要的镜像 在conf/local.conf文件提供了许多定义构建环境的基本变量：
Target Machine Selection（目标机器选择）: 由 MACHINE 控制 Download Directory（下载目录）: 由 DL_DIR 控制 Shared State Directory（共享状态目录）:	由 SSTATE_DIR 控制 Build Output（构建输出）: 由 TMPDIR 控制 Distribution Policy（分配策略）: 由 DISTRO 控制 Packaging Format（打包格式）: 由 PACKAGE_CLASSES 控制 SDK Target Architecture（SDK目标架构）: 由 SDKMACHINE 控制 Extra Image Packages（额外的image包）: 由 EXTRA_IMAGE_FEATURES 控制 5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/68ab3647ca5a0c076d184ce98cf8a9c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-25T23:34:45+08:00" />
<meta property="article:modified_time" content="2021-05-25T23:34:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Yocto（一）-介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1. 背景</h4> 
<p style="text-indent:33px;">在嵌入式产品开发中，通常都会定制自己公司的Linux发行版，所谓发行版，即根据自家产品的功能和特性定制bootloader、kernel、rootfs，最后得到这三个的镜像文件。</p> 
<p style="text-indent:33px;">定制Linux发行版是一件耗时耗力、技术含量比较高的一项大工程，对于很多公司来说，是没有这个人力和财力来做这件事的，所以大多数公司会选择现有的开源工具来定制自己家的 Linux 发行版。</p> 
<p style="text-indent:33px;">据我所知，当前比较主流的开源工具有两款，分别是 Buildroot 和 Yocto，它们都是开源的工程，思想也大体相同，就是将很多的开发包集成到开源工具中，然后根据自家产品的功能和特性进行配置，配置完成后进行编译时就会只编译并集成被配置的开发包，没被配置的开发包不会下载或者不会被集成到最终的镜像文件中。</p> 
<p style="text-indent:33px;">在汽车电子行业，Yocto 是主流，至于为啥我也不知道，Buildroot 和 Yocto 我都有研究过一点点，但是在工作中目前只接触过 Yocto，所谓“没有实践就没有发言权”，所以本章就只介绍一下Yocto。</p> 
<p style="text-indent:33px;"> </p> 
<h4>2. 官方资源</h4> 
<p style="text-indent:33px;">官网：<a href="https://www.yoctoproject.org/" rel="nofollow">https://www.yoctoproject.org/</a></p> 
<p style="text-indent:33px;">yocto项目快速开始手册：<a href="https://www.yoctoproject.org/docs/2.1/yocto-project-qs/yocto-project-qs.html" rel="nofollow">https://www.yoctoproject.org/docs/2.1/yocto-project-qs/yocto-project-qs.html</a></p> 
<p style="text-indent:33px;">yocto项目开发参考手册：<a href="https://www.yoctoproject.org/docs/1.5/ref-manual/ref-manual.html" rel="nofollow">https://www.yoctoproject.org/docs/1.5/ref-manual/ref-manual.html</a></p> 
<p style="text-indent:33px;"> </p> 
<h4>3. 组成</h4> 
<p style="text-indent:33px;">Recipes：.bb/.bbappend文件，即配方文件，描述了从哪获取软件源码，如何配置，如何编译。bbappend和bb的区别主要在于bbappend是基于bb的，功能是对相应的bb文件作补充和覆盖，有点类似于“重写”的概念。</p> 
<p style="text-indent:33px;">Class：.bbclass文件，即类文件，包含在配方文件之间共享的有用信息。比如autotools该类，其中包含Autotools使用的任何应用程序的常用设置。Yocto项目参考手册中的“ 类 ”一章提供了有关类及其使用方法的详细信息。https://www.yoctoproject.org/docs/2.5/ref-manual/ref-manual.html#ref-classes</p> 
<p style="text-indent:33px;">Configuration：.conf文件，即配置文件，我们可以用它来改变构建方式，比如conf/local.conf可以配置机器配置选项，分发配置选项，编译器调整选项，常规通用配置选项和用户配置选项 。</p> 
<p style="text-indent:33px;">conf/bblayers.conf中可以添加用到的layer层路径，从而在编译时将他们添加进去。层是组织文件和目录结构的元数据（配置文件、配方）集合。</p> 
<p style="text-indent:33px;"> </p> 
<h4>4. 配置</h4> 
<p style="text-indent:33px;">Yocto的目的很简单，它要经过一级一级配置，逐步缩小配方，直至得到uboot、kernel、rootfs这三个image。每一级需要哪些配方，由该级对应的配置文件（conf/bb）决定。越上级的配置是越笼统的，越下级的配置越细致。如果下级的配置项相对于上级有补充或者冲突，则以下级的内容为准，可以认为下级会对上级进行“重写”。</p> 
<p style="text-indent:33px;">有关构建的路线和流程：对于整个发行版构建，虽然每一级的配方由（conf/bb）决定，但是每一级路线和方向的选择，是由我们最终bitbake的对象决定的，BitBake需要一些基本配置文件才能完成构建。这些文件是*.conf文件。最低限度必需的文件作为示例文件驻留 在build/conf。比如我们最终bitbake avi-image-core，我们想要获得rootfs.img，那么：</p> 
<pre><code>第一步Poky就会从local.conf开始，一路向下，一级一级配置，直到配置到和rootfs有关的那一堆bb，最终形成完整完全的配方
第二步获取配方需要的资源，比如各种软件包，比如kernel的源码
第三步把所有的资源编译出我们需要的镜像 </code></pre> 
<p style="text-indent:33px;">在conf/local.conf文件提供了许多定义构建环境的基本变量：</p> 
<pre><code>Target Machine Selection（目标机器选择）: 	    由 MACHINE 控制
Download Directory（下载目录）: 		        由 DL_DIR 控制
Shared State Directory（共享状态目录）:	    由 SSTATE_DIR 控制
Build Output（构建输出）: 			        由 TMPDIR 控制
Distribution Policy（分配策略）: 		        由 DISTRO 控制
Packaging Format（打包格式）: 		        由 PACKAGE_CLASSES 控制
SDK Target Architecture（SDK目标架构）: 	    由 SDKMACHINE 控制
Extra Image Packages（额外的image包）: 	    由 EXTRA_IMAGE_FEATURES 控制</code></pre> 
<h4>5. 构建工具</h4> 
<p style="text-indent:33px;">Bitbake：BitBake是OpenEmbedded构建系统的核心工具，负责解析元数据，从中生成任务列表，然后执行这些任务。【BitBake是一种类似make的构建工具】</p> 
<p>5.1 要查看BitBake支持的选项列表，请使用以下命令之一<br> bitbake -h<br> bitbake --help</p> 
<p>5.2 显示所有可以bitbake的包<br> bitbake -s</p> 
<p>5.3 仅对某组配方文件执行任务(比如需要构建的配方的名称为matchbox-desktop_1.2.3.bb)<br> bitbake matchbox-desktop</p> 
<p>5.4 完成某项特定任务清除该任务<br> bitbake matchbox-desktop -c clean</p> 
<p>5.5 使用“-k”忽略错误，继续执行其它任务：最常用场景，在您构建系统时，使用 -k 选项，可忽略某个出错任务，继续执行其它构建任务<br> bitbake -k core-image-staoBitBake</p> 
<p>5.6 一次性编译所有内容，内核、文件系统等<br> bitbake core-image-minimal</p> 
<p>5.7 生成内核镜像和设备树文件<br> bitbake linux-xlnx -C compile</p> 
<p>5.8 单独编译u-boot，u-boot-imx（指定编译生成的u-boot镜像到deploy）<br> bitbake -c compile -f u-boot-imx；bitbake -c deploy -f</p> 
<p>5.9 单独编译交叉开发工具链（可扩展SDK）<br> bitbake -c populate_sdk_ext imagename</p> 
<p>5.10 单独编译交叉开发工具链（标准SDK）<br> bitbake -c populate_sdk imagename</p> 
<p>5.11 执行某个任务的编译<br> bitbake optee_example -c compile</p> 
<p>5.12 在构建系统时，先下载不构建<br> bitbake -c fetchall core-image-stao</p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:0;"> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00aa31c9d926b46ab48a450de2185400/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">USB Type-C接口便携显示器的应用场景，市面上兼容性最好的LDR6282&#43;RTD2556方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dcde80c154cc8d16ea1c8b8e3979eacd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python快速入门多线程与多进程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>