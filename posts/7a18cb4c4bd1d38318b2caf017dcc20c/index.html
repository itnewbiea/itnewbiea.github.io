<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度学习AI编译器-LLVM简介 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度学习AI编译器-LLVM简介" />
<meta property="og:description" content="1、什么是LLVM LLVM的命名最早来源于底层语言虚拟机（Low Level Virtual Machine）的缩写。它是一个用于建立编译器的基础框架，以C&#43;&#43;编写。创建此工程的目的是对于任意的编程语言，利用该基础框架，构建一个包括编译时、链接时、执行时等的语言执行器。目前官方的LLVM只支持处理C/C&#43;&#43;，Objective-C三种语言，当然也有一些非官方的扩展，使其支持ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java bytecode、Objective-C、Python、Ruby、Rust、Scala以及C#。
LLVM是一个编译器框架。LLVM作为编译器框架，是需要各种功能模块支撑起来的，你可以将clang和lld都看做是LLVM的组成部分，框架的意思是，你可以基于LLVM提供的功能开发自己的模块，并集成在LLVM系统上，增加它的功能，或者就单纯自己开发软件工具，而利用LLVM来支撑底层实现。LLVM由一些库和工具组成，正因为它的这种设计思想，使它可以很容易和IDE集成（因为IDE软件可以直接调用库来实现一些如静态检查这些功能），也很容易构建生成各种功能的工具（因为新的工具只需要调用需要的库就行）。
常见的结构如下图
主要由三个部分组成。
前端：将高级语言例如C或者其他语言转换成LLVM定义的中间表达方式 LLVM IR。例如非常有名的clang, 就是一个转换C/C&#43;&#43;的前端。
中端：中端主要是对LLVM IR本身进行一下优化，输入是LLVM, 输出还是LLVM， 主要是消除无用代码等工作，一般来讲这个部分是不需要动的，可以不管他。
后端：后端输入是LLVM IR， 输出是我们的机器码。我们通常说的编译器应该主要是指这个部分。大部分优化都从这个地方实现。
至此，LLVM架构的模块化应该说的比较清楚了。很大的一个特点是隔离了前后端。
如果你想支持一个新语言，就重新实现一个前端，例如华为“仓颉”就有自己的前端来替换clang。
如果你想支持一个新硬件，那你就重行实现一个后端，让它可以正确的把LLVM IR映射到自己的芯片。
前端 经过词法分析、语法分析、语义分析、LLVM IR生产，最终将C&#43;&#43;转化成后端认可的LLVM IR。
词法分析：将编程语言取出一个个词，遇到不认识的字符就报错。例如将a=b&#43;c 拆成a,= ,b ,&#43;, c
语法分析：将语法提取出来，例如你写了个a&#43;b=c, 明显不符合语法，直接报错
语义分析：分析一下你写的代码实际含义是不是对，例如a=b&#43;c, a,b,c有没有定义，类型是不是对的
LLVM IR生产：经过上述三步，将你写的代码转化成树状描述（抽象语法树），然后再转化成IR定义的IR即可。
举个直观的栗子，你写的C&#43;&#43;
// add.cpp int add(int a, int b) { return a &#43; b; } 生产的LLVM IR
（这个地方你不需要看懂每个细节，知道大概想类汇编的语言就行了， 专业的形式叫SSA, Static Single Assignment (SSA）
; ModuleID = &#39;add.cpp&#39; source_filename = &#34;add.cpp&#34; target datalayout = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7a18cb4c4bd1d38318b2caf017dcc20c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-03T15:52:51+08:00" />
<meta property="article:modified_time" content="2023-06-03T15:52:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度学习AI编译器-LLVM简介</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1LLVM_0"></a>1、什么是LLVM</h2> 
<p>LLVM的命名最早来源于底层语言虚拟机（Low Level Virtual Machine）的缩写。它是一个用于建立编译器的基础框架，以C++编写。创建此工程的目的是对于任意的编程语言，利用该基础框架，构建一个包括编译时、链接时、执行时等的语言执行器。目前官方的LLVM只支持处理C/C++，Objective-C三种语言，当然也有一些非官方的扩展，使其支持ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java bytecode、Objective-C、Python、Ruby、Rust、Scala以及C#。</p> 
<p>LLVM是一个编译器框架。LLVM作为编译器框架，是需要各种功能模块支撑起来的，你可以将clang和lld都看做是LLVM的组成部分，框架的意思是，你可以基于LLVM提供的功能开发自己的模块，并集成在LLVM系统上，增加它的功能，或者就单纯自己开发软件工具，而利用LLVM来支撑底层实现。LLVM由一些库和工具组成，正因为它的这种设计思想，使它可以很容易和IDE集成（因为IDE软件可以直接调用库来实现一些如静态检查这些功能），也很容易构建生成各种功能的工具（因为新的工具只需要调用需要的库就行）。<img src="https://images2.imgbox.com/1e/92/8Dik6M4j_o.png" alt="在这里插入图片描述"><br> 常见的结构如下图<br> <img src="https://images2.imgbox.com/ba/14/Dd46R0tr_o.png" alt="在这里插入图片描述"></p> 
<p>主要由三个部分组成。</p> 
<p>前端：将高级语言例如C或者其他语言转换成LLVM定义的中间表达方式 LLVM IR。例如非常有名的clang, 就是一个转换C/C++的前端。</p> 
<p>中端：中端主要是对LLVM IR本身进行一下优化，输入是LLVM, 输出还是LLVM， 主要是消除无用代码等工作，一般来讲这个部分是不需要动的，可以不管他。</p> 
<p>后端：后端输入是LLVM IR， 输出是我们的机器码。我们通常说的编译器应该主要是指这个部分。大部分优化都从这个地方实现。</p> 
<p>至此，LLVM架构的模块化应该说的比较清楚了。很大的一个特点是隔离了前后端。</p> 
<p>如果你想支持一个新语言，就重新实现一个前端，例如华为“仓颉”就有自己的前端来替换clang。</p> 
<p>如果你想支持一个新硬件，那你就重行实现一个后端，让它可以正确的把LLVM IR映射到自己的芯片。</p> 
<h3><a id="_21"></a>前端</h3> 
<p><img src="https://images2.imgbox.com/28/28/vGTKCFHX_o.png" alt="在这里插入图片描述"></p> 
<p>经过词法分析、语法分析、语义分析、LLVM IR生产，最终将C++转化成后端认可的LLVM IR。</p> 
<p>词法分析：将编程语言取出一个个词，遇到不认识的字符就报错。例如将a=b+c 拆成a,= ,b ,+, c</p> 
<p>语法分析：将语法提取出来，例如你写了个a+b=c, 明显不符合语法，直接报错</p> 
<p>语义分析：分析一下你写的代码实际含义是不是对，例如a=b+c, a,b,c有没有定义，类型是不是对的</p> 
<p>LLVM IR生产：经过上述三步，将你写的代码转化成树状描述（抽象语法树），然后再转化成IR定义的IR即可。</p> 
<p>举个直观的栗子，你写的C++</p> 
<pre><code class="prism language-c"><span class="token comment">// add.cpp</span>
<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>生产的LLVM IR</p> 
<p>（这个地方你不需要看懂每个细节，知道大概想类汇编的语言就行了， 专业的形式叫SSA, Static Single Assignment (SSA）</p> 
<pre><code class="prism language-c"><span class="token punctuation">;</span> ModuleID <span class="token operator">=</span> <span class="token char">'add.cpp'</span>
source_filename <span class="token operator">=</span> <span class="token string">"add.cpp"</span>
target datalayout <span class="token operator">=</span> <span class="token string">"e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span>
target triple <span class="token operator">=</span> <span class="token string">"x86_64-apple-macosx10.15.0"</span>


<span class="token punctuation">;</span> Function Attrs<span class="token operator">:</span> noinline nounwind optnone ssp uwtable
define i32 @<span class="token function">_Z3addii</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> i32<span class="token punctuation">)</span> #<span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">=</span> alloca i32<span class="token punctuation">,</span> align <span class="token number">4</span>
<span class="token operator">%</span><span class="token number">4</span> <span class="token operator">=</span> alloca i32<span class="token punctuation">,</span> align <span class="token number">4</span>
store i32 <span class="token operator">%</span><span class="token number">0</span><span class="token punctuation">,</span> i32<span class="token operator">*</span> <span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">,</span> align <span class="token number">4</span>
store i32 <span class="token operator">%</span><span class="token number">1</span><span class="token punctuation">,</span> i32<span class="token operator">*</span> <span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">,</span> align <span class="token number">4</span>
<span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> load i32<span class="token punctuation">,</span> i32<span class="token operator">*</span> <span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">,</span> align <span class="token number">4</span>
<span class="token operator">%</span><span class="token number">6</span> <span class="token operator">=</span> load i32<span class="token punctuation">,</span> i32<span class="token operator">*</span> <span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">,</span> align <span class="token number">4</span>
<span class="token operator">%</span><span class="token number">7</span> <span class="token operator">=</span> add nsw i32 <span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">%</span><span class="token number">6</span>
ret i32 <span class="token operator">%</span><span class="token number">7</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_68"></a>后端</h3> 
<p>后端把你的LLVM转换成真正的汇编（或者机器码）。主要的流程如下。这个我们要重点讲讲，因为后续我们就是要实现一个这个东西支持一个新的芯片。<br> <img src="https://images2.imgbox.com/29/44/GUgnVmwd_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="DAG_Lowering_71"></a>DAG Lowering</h4> 
<p>这个主要负责将你的LLVM IR转换为有向无环图，便于后续利用图算法优化。</p> 
<p>例如将下面的LLVM IR 转换成图，每个节点是一个指令。</p> 
<p><img src="https://images2.imgbox.com/95/19/DdUZEkZX_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/12/79/6iAzRogR_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="DAG_Legalization_80"></a>DAG Legalization</h4> 
<p>DAG图合法化，3.1中的DAG图都是LLVM IR指令，但实际上LLVM IR指令不可能被芯片全部支持，这个步骤就是替换这些不合法的指令。</p> 
<h4><a id="Instruction_Selection_83"></a>Instruction Selection</h4> 
<p>这个步骤其实和3.2算是一起的功能，都是为了将LLVM IR转换成机器支持的Machine DAG.<br> <img src="https://images2.imgbox.com/e3/db/IWRZNg1H_o.png" alt="在这里插入图片描述"></p> 
<p>如上图，将store换成机器仍可的st, 将16位的寄存器转向32位。一切向机器指令靠拢。</p> 
<h4><a id="Scheduling_90"></a>Scheduling</h4> 
<p>这个步骤主要是调整指令顺序的，从有向无环图再展开成顺序的指令。</p> 
<p>例如把下面的指令调成这样的。</p> 
<p><img src="https://images2.imgbox.com/a8/24/OHdSQvPc_o.png" alt="在这里插入图片描述"></p> 
<p>把%C的store提前一些，因为下一条ld要用C啦。</p> 
<h4><a id="SSAbased_Machine_Code_Optimization_100"></a>SSA-based Machine Code Optimization</h4> 
<p>这一步骤主要是做一些公共表达式合并啊去除的操作。</p> 
<h4><a id="Register_Allocation_103"></a>Register Allocation</h4> 
<p>这一步就要分配寄存器了。在3.5之前我们认为寄存器其实是可以无限用的，但实际硬件的寄存器有限的。所以我们得考虑寄存器数量与寄存器值的生命周期，将虚拟的寄存器替换成实际的寄存器。这个一般会用到图着色等等算法，贼复杂，好在LLVM都实现好了，不用在重复造轮子。</p> 
<p>例如一个芯片，有32个可用的寄存器，如果函数使用到了64个，多的就只能压如堆栈或者等着了。</p> 
<p>具体怎么分配的，知乎有专家研究，见下面的文章。Frank Wang：LLVM寄存器分配（一）</p> 
<h4><a id="PrologueEpilogue_Code_Insertion_110"></a>Prologue/Epilogue Code Insertion</h4> 
<p>这个主要是加上函数调用前的指令和函数结束后的指令。主要是调用前把参数存下来，调用后把结果写到固定的寄存器里。</p> 
<h4><a id="Peephole_optimizations_113"></a>Peephole optimizations</h4> 
<p>这个步骤主要是对代码再最后抢救一番。比如把x*2换成x&lt;1</p> 
<p>再比如下面这样<br> <img src="https://images2.imgbox.com/00/ce/r26V00yC_o.png" alt="在这里插入图片描述"></p> 
<p>将两个32bit的存储换成一个64bit的存储</p> 
<h4><a id="Code_Emission_122"></a>Code Emission</h4> 
<p>最后一步显然，将上述优化好的中间格式转换成我们真正需要的汇编，由汇编器翻译成机器码，大功告成。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53debf43692806d604b4f66d5a55a6cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基因名称转换-在线工具版</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b14fac05f1b6d5aa73719a7f05ec0385/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BP-LSTM-Attention-transformer，含数据，可直接运行，TensorFlow</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>