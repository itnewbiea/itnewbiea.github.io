<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux驱动之INPUT子系统框架 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux驱动之INPUT子系统框架" />
<meta property="og:description" content="目录
一、input 子系统简介
二、input 驱动编写流程
1、注册 input_dev
2、上报输入事件
三、input_event 结构体
按键、鼠标、键盘、触摸屏等都属于输入(input)设备， Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息， input 核心层负责处理这些事件。本章就来学习一下 Linux 内核中的 input 子系统框架。
一、input 子系统简介 input 就是输入的意思，因此 input 子系统就是管理输入的子系统，和 pinctrl、 gpio 子系统一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同，对于驱动编写者而言不需要去关心应用层的事情，只需要按照要求上报这些输入事件即可。
为此 input 子系统分为 input 驱动层、 input 核心层、 input 事件处理层，最终给用户空间提供可访问的设备节点， input 子系统框架如下图所示：
上图中左边就是最底层的具体设备，比如按键、 USB 键盘/鼠标等，中间部分属于Linux 内核空间，分为驱动层、核心层和事件层，最右边的就是用户空间，所有的输入设备以文件的形式供用户应用程序使用。可以看出 input 子系统用到了前面讲解的驱动分层模型，编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下：
驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。
核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。
事件层：主要和用户空间进行交互。
二、input 驱动编写流程 input 核心层会向 Linux 内核注册一个字符设备，大家找到 drivers/input/input.c 这个文件，input.c 就是 input 输入子系统的核心层，此文件里面有如下所示代码：
struct class input_class = { ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0cbeebffc530fc4c271d1ed5e1716f81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-18T07:50:38+08:00" />
<meta property="article:modified_time" content="2023-09-18T07:50:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux驱动之INPUT子系统框架</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81input%20%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B" rel="nofollow">一、input 子系统简介</a></p> 
<p style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81input%20%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B" rel="nofollow">二、input 驱动编写流程</a></p> 
<p style="margin-left:40px;"><a href="#1%E3%80%81%E6%B3%A8%E5%86%8C%20input_dev" rel="nofollow">        </a><a href="#1%E3%80%81%E6%B3%A8%E5%86%8C%20input_dev" rel="nofollow">1、注册 input_dev</a></p> 
<p style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%8A%E6%8A%A5%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6" rel="nofollow">        </a><a href="#2%E3%80%81%E4%B8%8A%E6%8A%A5%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6" rel="nofollow">2、上报输入事件</a></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81input_event%20%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">三、input_event 结构体</a></p> 
<hr> 
<p>        按键、鼠标、键盘、触摸屏等都属于输入(input)设备， Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息， input 核心层负责处理这些事件。本章就来学习一下 Linux 内核中的 input 子系统框架。</p> 
<h3>一、input 子系统简介</h3> 
<p>        input 就是输入的意思，因此 input 子系统就是管理输入的子系统，和 pinctrl、 gpio 子系统一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同，对于驱动编写者而言不需要去关心应用层的事情，只需要按照要求上报这些输入事件即可。</p> 
<p>        为此 input 子系统分为 input 驱动层、 input 核心层、 input 事件处理层，最终给用户空间提供可访问的设备节点， input 子系统框架如下图所示：</p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/07/cb/8gXoT5rn_o.png" alt="ee76c258ab3861aa601ac06748c338f6.png"></p> 
<p>        上图中左边就是最底层的具体设备，比如按键、 USB 键盘/鼠标等，中间部分属于Linux 内核空间，分为驱动层、核心层和事件层，最右边的就是用户空间，所有的输入设备以文件的形式供用户应用程序使用。可以看出 input 子系统用到了前面讲解的驱动分层模型，编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下：</p> 
<ul><li> <p>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。</p> </li><li> <p>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。</p> </li><li> <p>事件层：主要和用户空间进行交互。</p> </li></ul> 
<h3>二、input 驱动编写流程</h3> 
<p>        input 核心层会向 Linux 内核注册一个字符设备，大家找到 drivers/input/input.c 这个文件，input.c 就是 input 输入子系统的核心层，此文件里面有如下所示代码：</p> 
<pre><code class="language-objectivec">struct class input_class = {
    .name       = "input",
    .devnode    = input_devnode,
};
EXPORT_SYMBOL_GPL(input_class);
...
static int __init input_init(void)
{
    int err;

    err = class_register(&amp;input_class);
    if (err) {
        pr_err("unable to register input_dev class\n");
        return err;
    }

    err = input_proc_init();
    if (err)
        goto fail1;

    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),
                     INPUT_MAX_CHAR_DEVICES, "input");
    if (err) {
        pr_err("unable to register char major %d", INPUT_MAJOR);
        goto fail2;
    }

    return 0;

 fail2: input_proc_exit();
 fail1: class_unregister(&amp;input_class);
    return err;
}
</code></pre> 
<p>        第 11 行，注册一个 input 类，这样系统启动以后就会在/sys/class 目录下有一个 input 子目录，如下图所示：</p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/75/44/S7OvwPPp_o.png" alt="7565283a9e808f23e5ff72d587fd0014.png"></p> 
<p>        第 21~22 行，注册一个字符设备，主设备号为 INPUT_MAJOR，INPUT_MAJOR 定义在 include/uapi/linux/major.h 文件中，定义如下：</p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/59/9e/EOzbS17B_o.png" alt="79c08b8591191df8aaa2c8c8bcd3c046.png"></p> 
<p>        因此， input 子系统的所有设备主设备号都为 13，我们在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，我们只需要向系统注册一个 input_device 即可。</p> 
<p>1、注册 input_dev</p> 
<p>        在使用 input 子系统的时候我们只需要注册一个 input 设备即可，input_dev 结构体表示 input设备，此结构体定义在 include/linux/input.h 文件中，定义如下(有省略)：</p> 
<pre><code class="language-objectivec">struct input_dev {
    const char *name;
    const char *phys;
    const char *uniq;
    struct input_id id;

    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];

    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];   /* 事件类型的位图 */
    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; /* 按键值的位图 */ 
    unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; /* 相对坐标的位图 */
    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; /* 绝对坐标的位图 */
    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; /* 杂项事件的位图 */
    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; /*LED 相关的位图 */
    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; /* sound 有关的位图 */
    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];   /* 压力反馈的位图 */
    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];   /*开关状态的位图 */

    unsigned int hint_events_per_packet;

    unsigned int keycodemax;
    unsigned int keycodesize;
    void *keycode;
    ......
    unsigned long key[BITS_TO_LONGS(KEY_CNT)];
    unsigned long led[BITS_TO_LONGS(LED_CNT)];
    unsigned long snd[BITS_TO_LONGS(SND_CNT)];
    unsigned long sw[BITS_TO_LONGS(SW_CNT)];
    ......
    bool inhibited;
};
</code></pre> 
<p>        第 9 行， evbit 表示输入事件类型，可选的事件类型定义在 include/uapi/linux/input-event-codes.h 文件中，事件类型如下：</p> 
<pre><code class="language-objectivec">/*
 * Event types
 */

#define EV_SYN          0x00    /* 同步事件 */
#define EV_KEY          0x01    /* 按键事件 */
#define EV_REL          0x02    /* 相对坐标事件 */
#define EV_ABS          0x03    /* 绝对坐标事件 */
#define EV_MSC          0x04    /* 杂项(其他)事件 */
#define EV_SW           0x05    /* 开关事件 */
#define EV_LED          0x11    /* LED */
#define EV_SND          0x12    /* sound(声音) */
#define EV_REP          0x14    /* 重复事件 */
#define EV_FF           0x15    /* 压力事件 */
#define EV_PWR          0x16    /* 电源事件 */
#define EV_FF_STATUS    0x17    /* 压力状态事件 */
#define EV_MAX          0x1f
#define EV_CNT          (EV_MAX+1)
</code></pre> 
<p>        比如我们要使用到按键，那么就需要注册 EV_KEY 事件，如果要使用连按功能的话还需要注册 EV_REP 事件。</p> 
<p>        继续回到示例代码中，第 9 行~17 行的 evbit、 keybit、 relbit 等等都是存放不同事件对应的值。比如我们本章要使用按键事件，因此要用到 keybit， keybit 就是按键事件使用的位图， Linux 内核定义了很多按键值，这些按键值定义在 include/uapi/linux/input-event-codes.h 文件中，按键值如下：</p> 
<pre><code class="language-objectivec">#define KEY_RESERVED    0
#define KEY_ESC         1
#define KEY_1           2
#define KEY_2           3
#define KEY_3           4
#define KEY_4           5
#define KEY_5           6
#define KEY_6           7
#define KEY_7           8
#define KEY_8           9
#define KEY_9           10
#define KEY_0           11
#define KEY_MINUS       12
......
#define BTN_TRIGGER_HAPPY39     0x2e6
#define BTN_TRIGGER_HAPPY40     0x2e7
</code></pre> 
<p>        我们可以将开发板上的按键值设置为上述宏定义中的任意一个，比如我们本章实验会将 I.MX6U-ALPHA 开发板上的 KEY 按键值设置为 KEY_0。在编写 input 设备驱动的时候我们需要先申请一个 input_dev 结构体变量，使用input_allocate_device 函数来申请一个 input_dev，此函数原型如下所示：</p> 
<pre><code class="language-objectivec">struct input_dev *input_allocate_device(void)
函数参数和返回值含义如下：
- 参数：无
- 返回值： 申请到的 input_dev
</code></pre> 
<p>        如果要注销的 input 设备的话需要使用 input_free_device 函数来释放掉前面申请到的input_dev， input_free_device 函数原型如下：</p> 
<pre><code class="language-objectivec">void input_free_device(struct input_dev *dev)
函数参数和返回值含义如下：
- dev：需要释放的 input_dev
- 返回值： 无
</code></pre> 
<p>        申请好一个 input_dev 以后就需要初始化这个 input_dev，需要初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。 input_dev 初始化完成以后就需要向 Linux 内核注册 input_dev了，需要用到 input_register_device 函数，此函数原型如下：</p> 
<pre><code class="language-objectivec">int input_register_device(struct input_dev *dev)
函数参数和返回值含义如下：
- dev：要注册的 input_dev 
- 返回值： 0， input_dev 注册成功；负值， input_dev 注册失败
</code></pre> 
<p>        同样的，注销 input 驱动的时候也需要使用 input_unregister_device 函数来注销掉前面注册的 input_dev， input_unregister_device 函数原型如下：</p> 
<pre><code class="language-objectivec">void input_unregister_device(struct input_dev *dev)
函数参数和返回值含义如下：
- dev：要注销的 input_dev 
- 返回值： 无
</code></pre> 
<p>综上所述， input_dev 注册过程如下：</p> 
<ul><li> <p>①、使用 input_allocate_device 函数申请一个 input_dev。</p> </li><li> <p>②、初始化 input_dev 的事件类型以及事件值。</p> </li><li> <p>③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。</p> </li><li> <p>④、卸载 input驱动的时候需要先使用 input_unregister_device 函数注销掉注册的 input_dev，然后使用 input_free_device 函数释放掉前面申请的 input_dev。 input_dev 注册过程示例代码如下所示：</p> </li></ul> 
<pre><code class="language-objectivec">struct input_dev *inputdev; /* input 结构体变量 */

/* 驱动入口函数 */
static int __init xxx_init(void)
{
    .....
    nputdev = input_allocate_device();   /* 申请 input_dev */
    nputdev-&gt;name = "test_inputdev";     /* 设置 input_dev 名字 */
    
    /*********第一种设置事件和事件值的方法***********/
    __set_bit(EV_KEY, inputdev-&gt;evbit); /* 设置产生按键事件 */
    __set_bit(EV_REP, inputdev-&gt;evbit); /* 重复事件 */
    __set_bit(KEY_0, inputdev-&gt;keybit); /*设置产生哪些按键值 */
    /************************************************/
    
    /*********第二种设置事件和事件值的方法***********/
    keyinputdev.inputdev-&gt;evbit[0] = BIT_MASK(EV_KEY) |
                                     BIT_MASK(EV_REP);
    keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |=
                                      BIT_MASK(KEY_0);
    /************************************************/
    
    /*********第三种设置事件和事件值的方法***********/
    keyinputdev.inputdev-&gt;evbit[0] = BIT_MASK(EV_KEY) |
                                     BIT_MASK(EV_REP);
    input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);
    /************************************************/
    
    /* 注册 input_dev */
    input_register_device(inputdev);
    ......
    return 0;
}

/* 驱动出口函数 */
static void __exit xxx_exit(void)
{
    input_unregister_device(inputdev); /* 注销 input_dev */
    input_free_device(inputdev);       /* 删除 input_dev */
}
</code></pre> 
<ul><li> <p>第 1 行，定义一个 input_dev 结构体指针变量。</p> </li><li> <p>第 4~30 行，驱动入口函数，在此函数中完成 input_dev 的申请、设置、注册等工作。第 7行调用 input_allocate_device 函数申请一个 input_dev。第 10~23 行都是设置 input 设备事件和按键值，这里用了三种方法来设置事件和按键值。第 27 行调用 input_register_device 函数向 Linux内核注册 inputdev。</p> </li><li> <p>第 33~37 行，驱动出口函数，第 35 行调用 input_unregister_device 函数注销前面注册的input_dev，第 36 行调用 input_free_device 函数删除前面申请的 input_dev。</p> </li></ul> 
<p>2、上报输入事件</p> 
<p>        当向 Linux 内核注册好 input_dev 以后还不能高枕无忧的使用 input 设备， input 设备都是具有输入功能的，但是具体是什么样的输入值 Linux 内核是不知道的，需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。</p> 
<p>        比如按键，需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。不同的事件，其上报事件的 API 函数不同，依次来看一下一些常用的事件上报 API 函数。</p> 
<p>        首先是 input_event 函数，此函数用于上报指定的事件以及对应的值，函数原型如下：</p> 
<pre><code class="language-objectivec">void input_event(struct input_dev *dev,
         unsigned int type, unsigned int code, int value)
函数参数和返回值含义如下：
- dev：需要上报的 input_dev
- type: 上报的事件类型，比如 EV_KEY
- code： 事件码，也就是我们注册的按键值，比如 KEY_0、 KEY_1 等等
- value：事件值，比如 1 表示按键按下， 0 表示按键松开。返回值： 无
</code></pre> 
<p>        input_event 函数可以上报所有的事件类型和事件值， Linux 内核也提供了其他的针对具体事件的上报函数，这些函数其实都用到了 input_event 函数。比如上报按键所使用的input_report_key 函数，此函数内容如下：</p> 
<pre><code class="language-objectivec">static inline void input_report_key(struct input_dev *dev, unsigned int code, int value)
{
    input_event(dev, EV_KEY, code, !!value);
}
</code></pre> 
<p>        从上面函数定义可以看出， input_report_key 函数的本质就是 input_event 函数，如果要上报按键事件的话还是建议大家使用 input_report_key 函数。同样的还有一些其他的事件上报函数，这些函数如下所示：</p> 
<pre><code class="language-objectivec">static inline void input_report_rel(struct input_dev *dev, unsigned int code, int value)
static inline void input_report_abs(struct input_dev *dev, unsigned int code, int value)
static inline void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)
static inline void input_report_switch(struct input_dev *dev, unsigned int code, int value)
static inline void input_sync(struct input_dev *dev)
static inline void input_mt_sync(struct input_dev *dev)
</code></pre> 
<p>当我们上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束，input_sync 函数本质是上报一个同步事件，此函数原型如下所示：</p> 
<pre><code class="language-objectivec">static inline void input_sync(struct input_dev *dev)
{
    input_event(dev, EV_SYN, SYN_REPORT, 0);
}
函数参数和返回值含义如下：
- dev：需要上报同步事件的 input_dev。
- 返回值： 无。
</code></pre> 
<p>综上所述，按键的上报事件的参考代码如下所示：</p> 
<pre><code class="language-objectivec">/* 用于按键消抖的定时器服务函数 */
void timer_function(unsigned long arg)
{
    unsigned char value;

    value = gpio_get_value(keydesc-&gt;gpio);    /* 读取 IO 值 */
    if(value == 0){                           /* 按下按键 */
        /* 上报按键值 */
        input_report_key(inputdev, KEY_0, 1); /* 最后一个参数 1， 按下 */
        input_sync(inputdev);                 /* 同步事件 */
    } else { /* 按键松开 */
        input_report_key(inputdev, KEY_0, 0); /* 最后一个参数 0， 松开 */
        input_sync(inputdev);                 /* 同步事件 */
    }
}
</code></pre> 
<ul><li> <p>第 6 行，获取按键值，判断按键是否按下。</p> </li><li> <p>第 9~10 行，如果按键值为 0 那么表示按键被按下了，如果按键按下的话就要使用input_report_key 函数向 Linux 系统上报按键值，比如向 Linux 系统通知 KEY_0 这个按键按下了。</p> </li><li> <p>第 12~13 行，如果按键值为 1 的话就表示按键没有按下，是松开的。向 Linux 系统通知KEY_0 这个按键没有按下或松开了。</p> </li></ul> 
<h3>三、input_event 结构体</h3> 
<p>        Linux 内核使用 input_event 这个结构体来表示所有的输入事件， input_envent 结构体定义在include/uapi/linux/input.h 文件中，结构体内容如下：</p> 
<pre><code class="language-objectivec">struct input_event {
#if (__BITS_PER_LONG != 32 || !defined(__USE_TIME_BITS64)) &amp;&amp; !defined(__KERNEL__)
    struct timeval time;
#define input_event_sec time.tv_sec
#define input_event_usec time.tv_usec
#else
    __kernel_ulong_t __sec;
#if defined(__sparc__) &amp;&amp; defined(__arch64__)
    unsigned int __usec;
    unsigned int __pad;
#else
    __kernel_ulong_t __usec;
#endif
#define input_event_sec  __sec
#define input_event_usec __usec
#endif
    __u16 type;
    __u16 code;
    __s32 value;
};
</code></pre> 
<p>        依次来看一下 input_event 结构体中的各个成员变量： time：时间，也就是此事件发生的时间，为 timeval 结构体类型， timeval 结构体定义如下：</p> 
<pre><code class="language-objectivec">typedef long __kernel_long_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_suseconds_t;

struct timeval {
    __kernel_time_t tv_sec;        /* 秒 */
    __kernel_suseconds_t tv_usec;  /* 微秒 */
};
</code></pre> 
<p>        从上面可以看出， tv_sec 和 tv_usec 这两个成员变量都为 long 类型，也就是 32位，这个一定要记住，后面我们分析 event 事件上报数据的时候要用到。</p> 
<ul><li> <p>type： 事件类型，比如 EV_KEY，表示此次事件为按键事件，此成员变量为 16 位。</p> </li><li> <p>code： 事件码，比如在 EV_KEY 事件中 code 就表示具体的按键码，如： KEY_0、 KEY_1等等这些按键。此成员变量为 16 位。</p> </li><li> <p>value： 值，比如 EV_KEY 事件中 value 就是按键值，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了。</p> </li></ul> 
<p>        input_envent 这个结构体非常重要，因为所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值，比如按键值等。关于 input 子系统就讲解到这里，x下一章以开发板上的 KEY0 按键为例，讲解一下如何编写 input 驱动。</p> 
<hr> 
<p><strong><strong>        关于更多嵌入式C语言、FreeRTOS、RT-Thread、Linux应用编程、linux驱动等相关知识，关注公众号【嵌入式Linux知识共享】，后续精彩内容及时收看了解。</strong></strong></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a5e7fb086cf53c113160300de114b7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux驱动之MISC设备驱动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67694476d1a43e254a22ad508f78942d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux驱动之INPUT设备驱动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>