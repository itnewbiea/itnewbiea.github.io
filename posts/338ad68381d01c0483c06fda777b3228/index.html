<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android——Activity - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android——Activity" />
<meta property="og:description" content="文章目录 碎碎念部分activity是什么创建一个新的activity在活动中使用Toast在活动中使用Menu使用Intent在活动之间穿梭（转换界面）显式使用Intent隐式使用Intent更多用法尽在掌握向下一个活动传递数据 活动的生命周期活动状态活动的生存期（7个回调方法，3种生存期）在活动被回收之前抢救数据 活动的启动模式 碎碎念部分 长达一个学期的摆烂之后，终于下定决心把碎碎念博客继续规律更新啦，从c语言直接快进到android，跳过Java这个磨人的玩意！！
规律更新博客也希望对暑假还在挣扎学习的自己起到一点点督促的作用吧
新的征程开始咯！
activity是什么 在讲活动之前呢，要先提一嘴Android的四大组件——
活动（Activity）、服务（Service）、广播接收器（Breadcast Receiver）和内容提供器（Content Provider）。这篇博客就先讲讲活动，剩下三个组件且看下回分解~
那么活动究竟是什么东西呢，在我看来活动就是界面或者说是用来放组件的载体，一个空白的活动就是一个没有东西的界面，而我们要做的就是往这个空白的界面里塞东西（组件），来让界面变得更好看、更实用。
创建一个新的activity 懒人方法：右键→new→Activity→选择想要的活动类型→设置活动名等属性→finish手动创建活动：新建一个类→让这个类继承AppCompatActivity（不继承就是普通的类，不是活动哦）→重写onCreate()方法→在layout文件夹里面为这个活动新建一个布局文件→在onCreate()方法中引入新建的布局→在清单里面注册（所有组件都要在清单里面注册）→活动基本创建完成
手动创建的流程大概是这样，因为常用创建方式是第一种，这里对手动创建的细节就不做过多阐述了 在活动中使用Toast Toast是一种提醒方式，会在一段时间后自动消失并且不占任何屏幕空间（就是平常使用手机的时候，屏幕偏下方会弹出的灰色框）Toast的触发一般和按钮的点击事件结合在一起（把代码写在按钮的onClick()方法中），比如这样👇
（小小提一句，这一段是在对应活动的onCreate()方法中放着的）
解释一下这行关键代码：通过静态方法makeTaxt创建一个Toast对象，然后调用show()将Toast显示出来就完成了
这里makeText方法需要传三个参数。第一个是Context，也就是Toast要求的上下文。（由于活动本身就是一个context对象，所以直接传活动.this;第二个参数是Toast显示文本的内容，第三个参数是Toast显示的时长（有Toast.LENGTH_SHORT 和Toast.LENGTH_LONG两个内置常量可选） 在活动中使用Menu Menu其实就是把菜单隐藏起来做展示的一种方法，实现起来有点类似微信主页面右上角那个“＋”号的效果：既能展示菜单又不占用屏幕空间。
创建过程如下👇
先在res目录下新建一个menu文件夹，再在这个文件夹下再新建一个名叫main的菜单文件
然后在main.xml里面创建两个菜单项：
接着重新回到对应活动中来重写onCreateOptionsMenu()方法（快捷键Ctrl&#43;O）
通过getMenuInflater()方法能够得到MenuInflater对象，再调用它的inflate()方法就可以给当前活动创建菜单了。
inflate方法接收两个参数，第一个参数用于指定我们通过哪一个资源文件来创建菜单（这里肯定传入R.main.menu)第二个参数用于指定我们的菜单项；第二个参数用于指定我们的菜单项将添加到哪一个Menu对象中（这里直接使用了传入的参数menu）。然后给这个方法返回true，表示允许创建的菜单显示出来，若是返回false，则菜单无法显示。 定义菜单响应事件（在对应活动中重写onOptionsItemSelected()方法）
调用item.getItemId()来判断点击的是哪一个菜单，给菜单项加入自己的逻辑处理（例如这里的Toast，点击菜单之后就会出现灰框提醒）
使用Intent在活动之间穿梭（转换界面） Intent一般用于android中各组件之间的交互，不仅指明当前组件想要执行的动作，还可以在不同组件之间传递数据。
• Intent有多个函数的重载，其中一个是Intent(Context packageContext, Class&lt;?&gt;cls)，这个构造函数接收两个参数，第一个参数Context要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动，通过这个构造函数就可以构建出Intent的意图
Intent一般分为显式Intent和隐式Intent两种使用方法，下文会分别介绍 显式使用Intent 修改某按钮的点击事件为👇（点击跳转另一个界面）
构建一个Intent，传入MainActivity.this作为上下文，传入MainActivity2.class作为目标活动，意图为在MainActivity的基础上打开MainActivity2这个活动
然后通过startActivity()方法来执行这个Intent
隐式使用Intent 通过在&lt;activity&gt;标签下配置&lt;intent-filter&gt;内容，指定当前活动能够响应的action和category
❗只有&lt;action&gt;和&lt;category&gt;中的内容能够同时匹配上指定的action和category时，这个活动才能响应该Intent
然后再把MainActivity的点击事件改成👇
· 隐式和显式的区别就是用的不是同一个构造方法，上面设置的category这个内容是默认的，会在startActivity()被调用的时候自动将这个category添加到Intent中，所以上面只传了一个action进去
每个Intent中只能指定一个action，但却能指定多个category（使用addCategory()添加），当然了在匹配时这些category也要一一对应，活动和Intent才能响应
更多用法尽在掌握 隐式Intent不仅可以启动自己程序内的活动，还可以启动其他程序的活动比如调用系统的浏览器来打开一个网页：
将点击事件设置为👇 指定了Intent的action是Intent.ACTION_VIEW(这是一个Android系统内置的动作）；然后通过Uri.parse()方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个Uri对象传进去
这样点击这个按钮就会打开网址对应的网页啦
向下一个活动传递数据 这个操作的主要思路就是：通过putExtra()方法的重载，将想要传递的数据暂存在Intent中，启动另一个活动后再把这些数据从Intent中取出就可以了
将数据暂存到第一个活动Intent中：
使用显示的方式启动MainActivity2，并通过putExtra()方法传递一个字符串
这里putExtra()接收两个参数，第一个参数是键用于后面从Intent中取值，第二个参数才是真正要传递的数据
在第二个活动中把数据取出来：
首先使用getIntent()方法取到用于启动MainActivity2的Intent，然后调用getXxxExtra()方法来获取传递的数据（这里的Xxx根据数据类型灵活调整）
活动的生命周期 Android中的活动是可以层叠的，每启动一个新的活动就会覆盖在原活动之上，然后点击Back键会销毁最上面的活动，下面的活动就会重新显示。联想一下很容易发现：这个操作有点类似数据出入栈。
而事实上Android是用Task来管理活动的，一个Task就是一组存放在栈里的活动的集合，这个栈也被称作返回栈，系统总是会显示处于栈顶的活动给用户。
活动状态 一个活动的生命周期最多会有四种状态：运行状态、暂停状态、停止状态和销毁状态。
活动的生存期（7个回调方法，3种生存期） Activity类中定义了7个回调方法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/338ad68381d01c0483c06fda777b3228/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-24T23:11:30+08:00" />
<meta property="article:modified_time" content="2022-07-24T23:11:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android——Activity</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">碎碎念部分</a></li><li><a href="#activity_5" rel="nofollow">activity是什么</a></li><li><a href="#activity_9" rel="nofollow">创建一个新的activity</a></li><li><a href="#Toast_13" rel="nofollow">在活动中使用Toast</a></li><li><a href="#Menu_20" rel="nofollow">在活动中使用Menu</a></li><li><a href="#Intent_39" rel="nofollow">使用Intent在活动之间穿梭（转换界面）</a></li><li><ul><li><ul><li><a href="#Intent_43" rel="nofollow">显式使用Intent</a></li><li><a href="#Intent_49" rel="nofollow">隐式使用Intent</a></li><li><a href="#_58" rel="nofollow">更多用法尽在掌握</a></li><li><a href="#_65" rel="nofollow">向下一个活动传递数据</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_77" rel="nofollow">活动的生命周期</a></li><li><ul><li><ul><li><a href="#_80" rel="nofollow">活动状态</a></li><li><a href="#73_82" rel="nofollow">活动的生存期（7个回调方法，3种生存期）</a></li><li><a href="#_96" rel="nofollow">在活动被回收之前抢救数据</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_102" rel="nofollow">活动的启动模式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>碎碎念部分</h3> 
<p>长达一个学期的摆烂之后，终于下定决心把碎碎念博客继续规律更新啦，从c语言直接快进到android，跳过Java这个磨人的玩意！！<br> 规律更新博客也希望对暑假还在挣扎学习的自己起到一点点督促的作用吧<br> 新的征程开始咯！</p> 
<h3><a id="activity_5"></a>activity是什么</h3> 
<p>在讲活动之前呢，要先提一嘴Android的四大组件——<br> 活动（Activity）、服务（Service）、广播接收器（Breadcast Receiver）和内容提供器（Content Provider）。这篇博客就先讲讲活动，剩下三个组件且看下回分解~<br> 那么活动究竟是什么东西呢，在我看来活动就是<strong>界面</strong>或者说是用来放组件的载体，一个空白的活动就是一个没有东西的界面，而我们要做的就是往这个空白的界面里塞东西（组件），来让界面变得更好看、更实用。</p> 
<h3><a id="activity_9"></a>创建一个新的activity</h3> 
<ul><li>懒人方法：右键→new→Activity→选择想要的活动类型→设置活动名等属性→finish</li><li>手动创建活动：新建一个类→让这个类继承<code>AppCompatActivity</code>（不继承就是普通的类，不是活动哦）→重写<code>onCreate()</code>方法→在layout文件夹里面为这个活动新建一个布局文件→在<code>onCreate()</code>方法中引入新建的布局→在清单里面注册（所有组件都要在清单里面注册）→活动基本创建完成<br> 手动创建的流程大概是这样，因为常用创建方式是第一种，这里对手动创建的细节就不做过多阐述了</li></ul> 
<h3><a id="Toast_13"></a>在活动中使用Toast</h3> 
<ul><li>Toast是一种提醒方式，会在一段时间后自动消失并且不占任何屏幕空间（就是平常使用手机的时候，屏幕偏下方会弹出的灰色框）</li><li>Toast的触发一般和按钮的点击事件结合在一起（把代码写在按钮的<code>onClick()</code>方法中），比如这样👇<br> （小小提一句，这一段是在对应活动的<code>onCreate()</code>方法中放着的）<br> <img src="https://images2.imgbox.com/f3/02/aHO5HQRw_o.png" alt="在这里插入图片描述"></li><li>解释一下这行关键代码：<strong>通过静态方法<code>makeTaxt</code>创建一个Toast对象，然后调用<code>show()</code>将Toast显示出来就完成了</strong><br> 这里makeText方法需要传三个参数。第一个是Context，也就是Toast要求的上下文。（由于活动本身就是一个context对象，所以直接传活动.this;第二个参数是Toast显示文本的内容，第三个参数是Toast显示的时长（有<code>Toast.LENGTH_SHORT</code> 和<code>Toast.LENGTH_LONG</code>两个内置常量可选）</li></ul> 
<h3><a id="Menu_20"></a>在活动中使用Menu</h3> 
<p>Menu其实就是把菜单隐藏起来做展示的一种方法，实现起来有点类似微信主页面右上角那个“＋”号的效果：既能展示菜单又不占用屏幕空间。<br> 创建过程如下👇</p> 
<ul><li> <p>先在res目录下新建一个menu文件夹，再在这个文件夹下再新建一个名叫main的菜单文件<br> <img src="https://images2.imgbox.com/89/9d/0YArSMbz_o.png" alt="在这里插入图片描述"></p> </li><li> <p>然后在main.xml里面创建两个菜单项：<br> <img src="https://images2.imgbox.com/e4/b9/R0JpLmJa_o.png" alt="在这里插入图片描述"></p> </li><li> <p>接着重新回到对应活动中来重写<code>onCreateOptionsMenu()</code>方法（快捷键Ctrl+O）<br> <img src="https://images2.imgbox.com/8e/0e/MwDCBJbX_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<p>通过<code>getMenuInflater()</code>方法能够得到MenuInflater对象，再调用它的<code>inflate()</code>方法就可以给当前活动创建菜单了。</p> 
<pre><code>inflate方法接收两个参数，第一个参数用于指定我们通过哪一个资源文件来创建菜单（这里肯定传入R.main.menu)第二个参数用于指定我们的菜单项；第二个参数用于指定我们的菜单项将添加到哪一个Menu对象中（这里直接使用了传入的参数menu）。然后给这个方法返回true，表示允许创建的菜单显示出来，若是返回false，则菜单无法显示。
</code></pre> 
<ul><li>定义菜单响应事件（在对应活动中重写<code>onOptionsItemSelected()</code>方法）<br> <img src="https://images2.imgbox.com/f4/8f/kJrKIE5x_o.png" alt="在这里插入图片描述"></li></ul> 
<p>调用<code>item.getItemId()</code>来判断点击的是哪一个菜单，给菜单项加入自己的逻辑处理（例如这里的Toast，点击菜单之后就会出现灰框提醒）</p> 
<h3><a id="Intent_39"></a>使用Intent在活动之间穿梭（转换界面）</h3> 
<p>Intent一般用于android中各组件之间的交互，不仅指明当前组件想要执行的动作，还可以在不同组件之间传递数据。<br> • Intent有多个函数的重载，其中一个是<code>Intent(Context packageContext, Class&lt;?&gt;cls)</code>，这个构造函数接收两个参数，第一个参数Context要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动，通过这个构造函数就可以构建出Intent的意图</p> 
<ul><li>Intent一般分为显式Intent和隐式Intent两种使用方法，下文会分别介绍</li></ul> 
<h5><a id="Intent_43"></a>显式使用Intent</h5> 
<p>修改某按钮的点击事件为👇（点击跳转另一个界面）<br> <img src="https://images2.imgbox.com/5a/64/OIy0v77s_o.png" alt="在这里插入图片描述"></p> 
<p>构建一个Intent，传入<code>MainActivity.this</code>作为上下文，传入<code>MainActivity2.class</code>作为目标活动，意图为在<code>MainActivity</code>的基础上打开<code>MainActivity2</code>这个活动<br> 然后通过<code>startActivity()</code>方法来执行这个Intent</p> 
<h5><a id="Intent_49"></a>隐式使用Intent</h5> 
<ul><li> <p>通过在<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>内容，指定当前活动能够响应的action和category<br> <img src="https://images2.imgbox.com/71/2a/afJbpGxc_o.png" alt="在这里插入图片描述"><br> ❗只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>中的内容能够同时匹配上指定的action和category时，这个活动才能响应该Intent</p> </li><li> <p>然后再把MainActivity的点击事件改成👇<br> <img src="https://images2.imgbox.com/cc/54/j83u1FfI_o.png" alt="在这里插入图片描述"><br> · 隐式和显式的区别就是用的不是同一个构造方法，上面设置的category这个内容是默认的，会在<code>startActivity()</code>被调用的时候自动将这个category添加到Intent中，所以上面只传了一个action进去<br> 每个Intent中只能指定一个action，但却能指定多个category（使用<code>addCategory()</code>添加），当然了在匹配时这些category也要一一对应，活动和Intent才能响应</p> </li></ul> 
<h5><a id="_58"></a>更多用法尽在掌握</h5> 
<p>隐式Intent不仅可以启动自己程序内的活动，还可以启动其他程序的活动比如调用系统的浏览器来打开一个网页：</p> 
<ul><li> <p>将点击事件设置为👇 <img src="https://images2.imgbox.com/c4/22/6wWhhCzN_o.png" alt="在这里插入图片描述"></p> <p>指定了Intent的action是<code>Intent.ACTION_VIEW</code>(这是一个Android系统内置的动作）；然后通过<code>Uri.parse()</code>方法，将一个网址字符串解析成一个Uri对象，再调用Intent的<code>setData()</code>方法将这个Uri对象传进去</p> </li></ul> 
<p>这样点击这个按钮就会打开网址对应的网页啦</p> 
<h5><a id="_65"></a>向下一个活动传递数据</h5> 
<p>这个操作的主要思路就是：通过<code>putExtra()</code>方法的重载，将想要传递的数据暂存在Intent中，启动另一个活动后再把这些数据从Intent中取出就可以了</p> 
<ul><li> <p>将数据暂存到第一个活动Intent中：<br> <img src="https://images2.imgbox.com/e9/6f/qshOjvg0_o.png" alt="在这里插入图片描述"><br> 使用显示的方式启动MainActivity2，并通过<code>putExtra()</code>方法传递一个字符串<br> 这里<code>putExtra()</code>接收两个参数，第一个参数是<strong>键</strong>用于后面从Intent中取值，第二个参数才是真正要传递的数据</p> </li><li> <p>在第二个活动中把数据取出来：<br> <img src="https://images2.imgbox.com/41/c7/pV5aFTHX_o.png" alt="在这里插入图片描述"></p> <p>首先使用<code>getIntent()</code>方法取到用于启动MainActivity2的Intent，然后调用<code>getXxxExtra()</code>方法来获取传递的数据（这里的Xxx根据数据类型灵活调整）</p> </li></ul> 
<h3><a id="_77"></a>活动的生命周期</h3> 
<p>Android中的活动是可以层叠的，每启动一个新的活动就会覆盖在原活动之上，然后点击Back键会销毁最上面的活动，下面的活动就会重新显示。联想一下很容易发现：这个操作有点类似数据出入栈。<br> 而事实上Android是用Task来管理活动的，一个Task就是一组存放在栈里的活动的集合，这个栈也被称作返回栈，系统总是会显示处于栈顶的活动给用户。</p> 
<h5><a id="_80"></a>活动状态</h5> 
<p>一个活动的生命周期最多会有四种状态：运行状态、暂停状态、停止状态和销毁状态。</p> 
<h5><a id="73_82"></a>活动的生存期（7个回调方法，3种生存期）</h5> 
<ul><li><strong>Activity类中定义了7个回调方法：</strong><br> ○ onCreate() ：会在活动第一次被创建的时候调用，一般在这里完成活动的初始化操作（加载布局、绑定事件等）<br> ○ onStart()：这个方法在活动由可见变为不可见的时候调用<br> ○ onResume()：这个方法在活动准备好和用户进行交互的时候调用。此时活动一定位于返回栈栈顶并处于运行状态<br> ○ onPause()：这个方法在系统准备去启动或者恢复另一个活动的时候调用<br> ○ onStop()：这个方法在活动完全不可见的时候调用<br> ○ onDestroy()：在活动被销毁之前调用，调用之后活动状态将变为销毁状态<br> ○ onRestart()：在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了</li><li><strong>除了onRestart()之外，其他都是两两相对的，把活动分成了三种生存期：</strong><br> ○ 完整生存期：在<code>onCreate()</code>方法和<code>onDestory()</code>方法之间所经历的就是完整生存期。一般情况下，一个活动会在onCreate方法中完成各种初始化操作，在onDestroy()方法中完成释放内存的操作<br> ○ 可见生存期：在<code>onStart()</code>方法和<code>onStop()</code>方法之间所经历的，就是可见生存期。我们一般通过这两个方法合理地管理那些对用户可见的资源。<br> ○ 前台生存期：在<code>onResume()</code>方法和<code>onPause()</code>方法之间所经历的就是前台生存期。前台生存期内活动总是处于运行状态的，此时的活动是可以与用户进行交互的</li></ul> 
<h5><a id="_96"></a>在活动被回收之前抢救数据</h5> 
<p>为了防止上一个活动被内存不够的系统回收导致数据丢失，这里有一些抢救措施可以使用。其主要逻辑就是先把数据存在一个地方，安全了再取出来：</p> 
<ul><li> <p><strong>保存数据</strong>：Activity提供了一个<code>onSaveInstanceState()</code>回调方法，这个方法可以保证在活动被回收之前一定会被调用，所以我们在这个方法里面操作保存数据。<code>onSaveInstanceState()</code>方法携带一个Bundle类型的参数，提供了putXxx()的方法（Xxx由数据类型决定）这个方法需要传入两个参数，第一个参数是键，用于后面从Bundle中取值，第二个参数是真正要保存的内容<img src="https://images2.imgbox.com/94/1e/G5aIj7iR_o.png" alt="在这里插入图片描述"></p> </li><li> <p>提取数据：在安全的活动的<code>onCreat()</code>方法中用相应的方法取出数据<br> <img src="https://images2.imgbox.com/0e/d3/iXWlPmbu_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h3><a id="_102"></a>活动的启动模式</h3> 
<p>在Android 12中，启动模式已经从4种升级到了5种，分别是：<code>standard</code>、<code>singleTop</code>、<code>singleTask</code>、<code>singleInstance</code>和<code>singleInstancePerTask</code><br> 五种启动模式👇</p> 
<ul><li>standard：无论这个活动是否在返回栈中出现，每次启动都会创建该活动的一个新的实例（在不进行显示指定的情况下，所有Activity都会自动使用这种模式）</li><li>singleTop：如若发现返回栈的栈顶已经是该活动，则直接使用，不会再创造新的活动实例</li><li>singleTask：若活动已在栈中，挪到栈顶直接使用并<strong>将这个活动之上的活动全部出栈</strong>，没有就建一个新的实例（但是若没有显示指定taskAffinity，则一般不会开新栈，只是新建一个实例）</li><li>singleInstance：使用这种模式的活动会被一个单独的返回栈管理，其他应用来访问这个活动都会共用这个返回栈</li><li>singleInstancePerTask：若活动不在栈中，会为该活动创建一个新的栈；若活动在栈中，则与singleTask一样会把这个活动之上的活动全部出栈，自己到栈顶</li></ul> 
<p>❗可以在AndroidManifest.xml中通过给<code>&lt;activity&gt;</code>标签指定<code>android:launchMode</code>属性来选择启动模式</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1541ee8f50f0e8378bb7546956b2828c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">晶振的等效电路模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f085f51d7ed0725b8e223f2438c2391/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Web学习笔记8-【过滤器Filter：功能、使用方法、生命周期、使用场景，文件的上传，文件的下载】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>