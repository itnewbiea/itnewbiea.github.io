<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>汇编语言-王爽（学习笔记）-12章 中断 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="汇编语言-王爽（学习笔记）-12章 中断" />
<meta property="og:description" content="第12章：内中断
中断：CPU在执行当前正在执行的指令后，检测到从CPU内部或者外部产生的信息，便立即执行收到的信息。用来处理中断信息的程序是中断处理程序。
CPU收到中断信息后，要知道中断信息的来源（CS,IP值）。中断来源由中断类型码标识。中断类型码为一个字节的数据，所以可以有256种中断信息来源。CPU由8位的中断类型码，在中断向量表中查找，找到中断处理函数的入口地址（CS,IP）。中断向量表指定从内存地址0开始，256*4=1024单元（0000：0000~0000：03ffh）的内容是中断向量表。
CPU在以下情况产生中断：
（1）除法错误，比如，执行div指令产生除法溢出。：中断类型码：0
（2）单步执行：中断类型码：1
（3）执行into指令：中断类型码：4
（4）执行int指令。：指令格式为int n，n为字节型立即数，提供给CPU的中断类型码。
/
中断过程：
使用中断类型码，在中断向量表中找到中断处理程序的入口，设置CS:IP。这工作由CPU硬件自动完成。
8086CPU收到中断信息后：
（1）取得中断类型码N
（2）pushf
（3）TF=0,IF=0
（4）push cs
（5）push ip
（6）ip=(N*4),CS=(N*4&#43;2)
以上CPU硬件自动完成，完成最后一步后，CPU执行由程序员编写的中断处理程序。
中断处理程序编写：
（1）保存用到的寄存器（2）处理中断（3）回复寄存器（4）iret指令返回。
iret&lt;=&gt;pop ip pop cs popf
编写0中断处理函数（实验12）
CODES SEGMENT START: ;将中断处理函数放入安全的内存区 mov ax,cs mov ds,ax mov ax,offset d0 mov si,ax mov ax,0 mov es,ax mov di,200h mov cx,offset d0end - offset d0 cld rep movsb d0:;中断处理函数 jmp short d0start db &#34;overflow!&#34; d0start:;中断处理函数，将字符串送进显存 mov ax,cs mov ds,ax mov si,202h mov ax,0b800h mov es,ax mov di,12*160&#43;36*2 mov cx,9 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21h d0end: nop CODES ENDS END START 单步中断：执行一条语句后，进入中断，为实现单步跟踪提供机制。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/49aa7fcf81ac2b54407691d0f1bf74cc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-11T21:25:22+08:00" />
<meta property="article:modified_time" content="2019-01-11T21:25:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">汇编语言-王爽（学习笔记）-12章 中断</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>第12章：内中断</p> 
<p>中断：CPU在执行当前正在执行的指令后，检测到从CPU内部或者外部产生的信息，便立即执行收到的信息。用来处理中断信息的程序是中断处理程序。</p> 
<p>CPU收到中断信息后，要知道中断信息的来源（CS,IP值）。中断来源由中断类型码标识。中断类型码为一个字节的数据，所以可以有256种中断信息来源。CPU由8位的中断类型码，在中断向量表中查找，找到中断处理函数的入口地址（CS,IP）。中断向量表指定从内存地址0开始，256*4=1024单元（0000：0000~0000：03ffh）的内容是中断向量表。</p> 
<p>CPU在以下情况产生中断：</p> 
<p>（1）除法错误，比如，执行div指令产生除法溢出。：中断类型码：0</p> 
<p>（2）单步执行：中断类型码：1</p> 
<p>（3）执行into指令：中断类型码：4</p> 
<p>（4）执行int指令。：指令格式为int n，n为字节型立即数，提供给CPU的中断类型码。</p> 
<p>/</p> 
<p>中断过程：</p> 
<p>使用中断类型码，在中断向量表中找到中断处理程序的入口，设置CS:IP。这工作由CPU硬件自动完成。</p> 
<p>8086CPU收到中断信息后：</p> 
<p>（1）取得中断类型码N</p> 
<p>（2）pushf</p> 
<p>（3）TF=0,IF=0</p> 
<p>（4）push cs</p> 
<p>（5）push ip</p> 
<p>（6）ip=(N*4),CS=(N*4+2)</p> 
<p>以上CPU硬件自动完成，完成最后一步后，CPU执行由程序员编写的中断处理程序。</p> 
<p>中断处理程序编写：</p> 
<p>（1）保存用到的寄存器（2）处理中断（3）回复寄存器（4）iret指令返回。</p> 
<p>iret&lt;=&gt;pop ip    pop cs    popf</p> 
<p>编写0中断处理函数（实验12）</p> 
<pre class="has"><code>CODES SEGMENT
    
START:
   ;将中断处理函数放入安全的内存区
    mov ax,cs
    mov ds,ax
    mov ax,offset d0
    mov si,ax
    mov ax,0
    mov es,ax
    mov di,200h
    
    mov cx,offset d0end - offset d0
    cld
    rep movsb
   
    d0:;中断处理函数
    
    jmp short  d0start
    
    db "overflow!"
    
    d0start:;中断处理函数，将字符串送进显存
    
    mov ax,cs
    mov ds,ax
    mov si,202h
    mov ax,0b800h
    mov es,ax
    mov di,12*160+36*2
    mov cx,9
    
    s:
    mov al,[si]
    mov es:[di],al
    inc si
    add di,2
    loop s
    
    mov ax,4c00h
    int 21h
    d0end:
    nop
  
CODES ENDS
    END START
</code></pre> 
<p>单步中断：执行一条语句后，进入中断，为实现单步跟踪提供机制。</p> 
<p>CPU在执行一条指令后，如果检测到TF=1，则执行单步中断。如果在进入中断处理程序之前没有将TF位置零，CPU在执行一条指令后，又将进入中断，无限轮回233，所以这是将TF位清零的原因。</p> 
<p>响应中断特殊情况：。执行完向ss寄存器传入数据指令后，即便发生中断，CPU也不响应。因此我们要将设置ss和设置sp连续存放。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4443c7b0c5021b460ca24bbead219db5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Window 硬件】检测哪个程序占用了串口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc964ae72d68da36dac23f31ea11afa1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">汇编语言-（王爽）-学习笔记（第13章 int指令）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>