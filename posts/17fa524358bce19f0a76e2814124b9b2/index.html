<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis的事务及Spring Data Redis的实现 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis的事务及Spring Data Redis的实现" />
<meta property="og:description" content="Redis的事务及Spring Data Redis的实现 Redis的事务 简介 Redis的事务基于MULTI，EXEC，DISCARD和WATCH这四个命令实现。这四个命令组合允许在一步中同时执行多个命令。
Redis的事务主要保证了一下两个方面：
事务中的多个命令是按照添加到队列中的顺序执行的。并且在事务进行中，不会被另一个客户端的请求打断。也就是说，事务中的多个命令可以看作单个隔离的操作。事务可以保证原子性。事务的执行由EXEC命令触发，当客户端在发送EXEC命令前丢失了该事务的连接，该事务中的命令将不会被执行。如果在客户端在调用EXEC命令后丢失连接，事务的命令队列依然会被执行。Redis事务会写入磁盘文件。若Redis在事务中异常停止，在重启时会报错，可以使用redis-check-aof工具修复后再重新启动。从2.2版本开始，可以使用乐观锁对上述两种情况添加额外保证。类似与CAS操作。 事务的使用 通过MULTI进入一个事务。这个命令总是返回OK。客户端发起多个命令。Redis将这些命令依次放入队列，并不会执行。所有命令都会返回字符串QUEUED回复。当客户端执行EXEC命令后，开始执行事务。EXEC命令会返回多个结果的数组，每个元素对应事务中的一个命令，且顺序与命令顺序一致。当客户端调用DISCARD命令后，清空事务队列并退出当前事务。 事务对于错误的处理 事务中可能会碰到的错误如下：
命令排队失败。例如：命令的语法错误或者该命令可能导致一些危险，例如当设置Redis可以使用的最大内存时可能碰到内存不足的情况。调用EXEC后命令可能会执行失败。例如，因为我们对一个具有错误值的键执行了一个操作（比如对一个字符串值调用一个列表操作）。 对于第一种错误，客户端应该判断返回值是否返回字符串QUEUED来处理，例如中止并丢弃该事务。
从Redis 2.6.5开始，Redis服务器会记住在命令排队时的错误，并且拒绝执行事务，在EXEC期间返回错误，并自动丢弃事务。
在2.6.5之前，如果客户端不处理错误，继续执行EXEC，服务器将会仅执行命令队列中的正确命令。
对于第二种错误，Redis服务器不会做特殊处理，所有的命令都将会执行，即使某些命令执行错误。对于出错命令返回-ERR。
重要：在EXEC之后，事务开始执行队列中所有命令，即使碰到错误也不会中止！只会对发生执行错误的命令返回-ERR
重要：Redis事务不支持回滚！
check-and-set 乐观锁 乐观锁通过WATCH命令实现。WATCH可以用来监视一个key的变化。如果在EXEC执行前，至少一个被监视的key被修改，事务将会中止，EXEC命令返回Null来通知事务失败。
当返回事务失败时可以重复操作，直到成功。这种锁即为乐观锁。
Redis脚本和事务 Redis脚本是事务性的，因此可以使用脚本执行操作，通常脚本将更简单，更快速。
Spring Data Redis（2.1）对Redis事务的支持 RedisTemplate提供了对multi、exec和discard命令的支持。但是，RedisTemplat不会在一个连接上执行多个redis命令。Spring Data Redis提供了SessionCallback接口，支持一个连接执行多个redis命令。
因此，Spring Data Redis支持redis的事务需要依赖SessionCallback接口。
List&lt;Object&gt; txResults = redisTemplate.execute(new SessionCallback&lt;List&lt;Object&gt;&gt;() { public List&lt;Object&gt; execute(RedisOperations operations) throws DataAccessException { operations.multi(); operations.opsForSet().add(&#34;key&#34;, &#34;value1&#34;); // This will contain the results of all operations in the transaction return operations.exec(); } }); System.out.println(&#34;Number of items added to set: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/17fa524358bce19f0a76e2814124b9b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-13T15:25:33+08:00" />
<meta property="article:modified_time" content="2020-01-13T15:25:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis的事务及Spring Data Redis的实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="RedisSpring_Data_Redis_0"></a>Redis的事务及Spring Data Redis的实现</h2> 
<h3><a id="Redis_2"></a>Redis的事务</h3> 
<h4><a id="_4"></a>简介</h4> 
<p>Redis的事务基于MULTI，EXEC，DISCARD和WATCH这四个命令实现。这四个命令组合允许在一步中同时执行多个命令。<br> Redis的事务主要保证了一下两个方面：</p> 
<ul><li>事务中的多个命令是按照添加到队列中的顺序执行的。并且在事务进行中，不会被另一个客户端的请求打断。也就是说，事务中的多个命令可以看作单个隔离的操作。</li><li>事务可以保证原子性。事务的执行由EXEC命令触发，当客户端在发送EXEC命令前丢失了该事务的连接，该事务中的命令将不会被执行。如果在客户端在调用EXEC命令后丢失连接，事务的命令队列依然会被执行。Redis事务会写入磁盘文件。若Redis在事务中异常停止，在重启时会报错，可以使用redis-check-aof工具修复后再重新启动。</li><li>从2.2版本开始，可以使用乐观锁对上述两种情况添加额外保证。类似与CAS操作。</li></ul> 
<h4><a id="_13"></a>事务的使用</h4> 
<ol><li>通过MULTI进入一个事务。这个命令总是返回OK。</li><li>客户端发起多个命令。Redis将这些命令依次放入队列，并不会执行。所有命令都会返回字符串QUEUED回复。</li><li>当客户端执行EXEC命令后，开始执行事务。EXEC命令会返回多个结果的数组，每个元素对应事务中的一个命令，且顺序与命令顺序一致。</li><li>当客户端调用DISCARD命令后，清空事务队列并退出当前事务。</li></ol> 
<h4><a id="_20"></a>事务对于错误的处理</h4> 
<p>事务中可能会碰到的错误如下：</p> 
<ul><li>命令排队失败。例如：命令的语法错误或者该命令可能导致一些危险，例如当设置Redis可以使用的最大内存时可能碰到内存不足的情况。</li><li>调用EXEC后命令可能会执行失败。例如，因为我们对一个具有错误值的键执行了一个操作（比如对一个字符串值调用一个列表操作）。</li></ul> 
<p>对于第一种错误，客户端应该判断返回值是否返回字符串QUEUED来处理，例如中止并丢弃该事务。<br> 从Redis 2.6.5开始，Redis服务器会记住在命令排队时的错误，并且拒绝执行事务，在EXEC期间返回错误，并自动丢弃事务。<br> 在2.6.5之前，如果客户端不处理错误，继续执行EXEC，服务器将会仅执行命令队列中的正确命令。<br> 对于第二种错误，Redis服务器不会做特殊处理，所有的命令都将会执行，即使某些命令执行错误。对于出错命令返回-ERR。</p> 
<p><em>重要：在EXEC之后，事务开始执行队列中所有命令，即使碰到错误也不会中止！只会对发生执行错误的命令返回-ERR</em></p> 
<p><em>重要：Redis事务不支持回滚！</em></p> 
<h4><a id="checkandset__36"></a>check-and-set 乐观锁</h4> 
<p>乐观锁通过WATCH命令实现。WATCH可以用来监视一个key的变化。如果在EXEC执行前，至少一个被监视的key被修改，事务将会中止，EXEC命令返回Null来通知事务失败。<br> 当返回事务失败时可以重复操作，直到成功。这种锁即为乐观锁。</p> 
<h4><a id="Redis_41"></a>Redis脚本和事务</h4> 
<p>Redis脚本是事务性的，因此可以使用脚本执行操作，通常脚本将更简单，更快速。</p> 
<h3><a id="Spring_Data_Redis21Redis_45"></a>Spring Data Redis（2.1）对Redis事务的支持</h3> 
<p>RedisTemplate提供了对multi、exec和discard命令的支持。但是，RedisTemplat不会在一个连接上执行多个redis命令。Spring Data Redis提供了SessionCallback接口，支持一个连接执行多个redis命令。<br> 因此，Spring Data Redis支持redis的事务需要依赖SessionCallback接口。</p> 
<pre><code class="prism language-Java">
List&lt;Object&gt; txResults = redisTemplate.execute(new SessionCallback&lt;List&lt;Object&gt;&gt;() {
  public List&lt;Object&gt; execute(RedisOperations operations) throws DataAccessException {
    operations.multi();
    operations.opsForSet().add("key", "value1");

    // This will contain the results of all operations in the transaction
    return operations.exec();
  }
});
System.out.println("Number of items added to set: " + txResults.get(0));

</code></pre> 
<h4><a id="Transactional_65"></a>使用@Transactional</h4> 
<p>默认情况下，事务支持是禁用的，必须通过设置setEnableTransactionSupport（true）为正在使用的每个RedisTemplate显式启用。这样做会强制将当前RedisConnection绑定到触发MULTI的当前线程。如果事务顺利完成，则调用EXEC。否则调用DISCARD。进入MULTI后，RedisConnection会将写操作排队。所有只读操作（例如KEYS）都传递到新的（非线程绑定）RedisConnection。<br> 以下示例显示如何配置事务管理：</p> 
<pre><code class="prism language-Java">@Configuration
@EnableTransactionManagement
public class RedisTxContextConfiguration {

  @Bean
  public StringRedisTemplate redisTemplate() {
    StringRedisTemplate template = new StringRedisTemplate(redisConnectionFactory());
    // 启用事务
    template.setEnableTransactionSupport(true);
    return template;
  }

  @Bean
  public RedisConnectionFactory redisConnectionFactory() {
    // jedis || Lettuce
  }

  @Bean
  public PlatformTransactionManager transactionManager() throws SQLException {
    return new DataSourceTransactionManager(dataSource());
  }

  @Bean
  public DataSource dataSource() throws SQLException {
    // ...
  }
}
</code></pre> 
<p>配置说明：</p> 
<ul><li>@EnableTransactionManagement: 注解开启了声明式事务管理</li><li>template.setEnableTransactionSupport(true): 明确开启redis事务</li><li>return new DataSourceTransactionManager(dataSource()): 事务管理需要一个PlatformTransactionManager。Spring Data Redis不包含PlatformTransactionManager实现。假设应用程序中使用了JDBC，Spring Data Redis可以使用现有的事务管理器参与事务。</li></ul> 
<p>需要注意的是，通过这种方式使用事务，<em>所有的只读操作会在另一个不与线程绑定的连接中完成</em>。并且这种方式使用的是<em>复合事务</em>。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c211050bf8f55fbf184f1ffceb3429ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Intel qsv &#43; ffmpeg 硬解h264</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6b1f3b5b9b37d4242bea454c661f769/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">程序员成长之旅——文件操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>