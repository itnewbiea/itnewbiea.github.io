<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何解决Java应用程序的Jar包冲突问题，看这一篇就够了 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何解决Java应用程序的Jar包冲突问题，看这一篇就够了" />
<meta property="og:description" content="提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
目录
前言
一、Jar包冲突问题
1. 什么是Jar包冲突问题
1.1 同一个Jar包出现了多个不一样版本
1.2 同一个类出现在多个不一样Jar包中
2. 为什么会产生Jar包冲突
2.1 maven仲裁机制
2.2 Jar包的加载顺序
3. Jar包冲突会导致什么问题
二、解决方案
1、问题排查和解决
2、如何有效避免
2.1 良好的习惯：依赖管理
2.2 冲突检测插件
总结
前言 我们在java应用程序的编译或者运行时可能会遇到抛出java.lang.ClassNotFoundException、java.lang.NoSuchMethodError、java.lang.NoClassDefFoundError这类的异常。这类异常一般都是jar包冲突导致的。那么jar包冲突的原因是什么？如何解决jar包冲突呢？我们一起来看下。
一、Jar包冲突问题 1. 什么是Jar包冲突问题 Jar包冲突问题的本质：Java应用程序因某种因素，加载不到正确的类而致使其行为跟预期不一致。
具体来讲可分为两种状况：
1）第一类Jar包冲突问题：应用程序依赖的同一个Jar包出现了多个不一样版本，并选择了错误的版本而致使JVM加载不到需要的类或加载了错误版本的类；
2）第二类Jar包冲突问题：一样的类（类的全限定名彻底同样）出现在多个不一样的依赖Jar包中，即该类有多个版本，并因为Jar包加载的前后顺序致使JVM加载了错误版本的类。
这两种状况所致使的结果实际上是同样的，都会使应用程序加载不到正确的类，那么其行为就会跟预期不一致了，下面对这两种类型进行详细分析。
1.1 同一个Jar包出现了多个不一样版本 随着Jar包迭代升级，应用程序所依赖的开源的或公司内部的Jar包工具都会存在若干不一样的版本，而版本升级天然就避免不了类的方法签名变动，甚至于类名的更替，而当前的应用程序依赖特定版本的某个类M ，因为maven的传递依赖而致使同一个Jar包出现了多个版本，当maven的仲裁机制选择了错误的版本时，而刚好类M在该版本中被去掉了，或者方法签名改了，致使应用程序因找不到所需的类M或找不到类M中的特定方法，就会出现第一类Jar冲突问题。可总结出该类冲突问题发生的如下三个必要条件：
因为maven的传递依赖致使依赖树中出现了同一个Jar包的多个版本该Jar包的多个版本之间存在接口差别，如类名更替，方法签名更替等，且应用程序依赖了其中有变动的类或方法maven的仲裁机制选择了错误的版本 1.2 同一个类出现在多个不一样Jar包中 一样的类出现在应用程序所依赖的两个及以上的不一样Jar包中，这会致使什么问题呢？我们知道，同一个类加载器对于同一个类只会加载一次（多个不一样类加载器就另说了，这也是解决Jar包冲突的一个思路，后面会谈到），那么当一个类出现在多个Jar包中，假设有 A 、 B 、 C 等，因为Jar包依赖的路径长短、声明的前后顺序或文件系统的文件加载顺序等缘由，类加载器首先从Jar包 A 中加载了该类后，就不会加载其他Jar包中的这个类了，那么问题来了：若是应用程序此时需要的是Jar包 B 中的类版本，而且该类在Jar包 A 和 B 中有差别（方法不一样、成员不一样等等），而JVM却加载了Jar包 A 的中的类版本，与期望不一致，自然就会出现各类诡异的问题。
从上面的描述中，能够发现出现不一样Jar包的冲突问题有如下三个必要条件：
同一个类 M 出现在多个依赖的Jar包中，为了叙述方便，假设仍是两个： A 和 BJar包 A 和 B 中的该类 M 有差别，不管是方法签名不一样也好，成员变量不一样也好，只要能够形成实际加载的类的行为和指望不一致都行。若是说Jar包 A 和 B 中的该类彻底同样，那么类加载器不管先加载哪一个Jar包，获得的都是一样版本的类 M ，不会有任何影响，也就不会出现Jar包冲突带来的诡异问题。加载的类 M 不是所指望的版本，即加载了错误的Jar包 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9ecd3c9c24045a795ee5f4ec94b522a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-26T18:23:10+08:00" />
<meta property="article:modified_time" content="2023-11-26T18:23:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何解决Java应用程序的Jar包冲突问题，看这一篇就够了</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档</p> 
</blockquote> 
<p></p> 
<div> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="-toc" style="margin-left:80px;"></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81Jar%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Jar%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98" rel="nofollow">一、Jar包冲突问题</a></p> 
 <p id="1.%20%E4%BB%80%E4%B9%88%E6%98%AFJar%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#1.%20%E4%BB%80%E4%B9%88%E6%98%AFJar%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98" rel="nofollow">1. 什么是Jar包冲突问题</a></p> 
 <p id="1.1%20%E5%90%8C%E4%B8%80%E4%B8%AAJar%E5%8C%85%E5%87%BA%E7%8E%B0%E4%BA%86%E5%A4%9A%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%89%88%E6%9C%AC-toc" style="margin-left:80px;"><a href="#1.1%20%E5%90%8C%E4%B8%80%E4%B8%AAJar%E5%8C%85%E5%87%BA%E7%8E%B0%E4%BA%86%E5%A4%9A%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%89%88%E6%9C%AC" rel="nofollow">1.1 同一个Jar包出现了多个不一样版本</a></p> 
 <p id="1.2%20%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%A4%9A%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7Jar%E5%8C%85%E4%B8%AD-toc" style="margin-left:80px;"><a href="#1.2%20%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%A4%9A%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7Jar%E5%8C%85%E4%B8%AD" rel="nofollow">1.2 同一个类出现在多个不一样Jar包中</a></p> 
 <p id="2.%C2%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9FJar%E5%8C%85%E5%86%B2%E7%AA%81-toc" style="margin-left:40px;"><a href="#2.%C2%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9FJar%E5%8C%85%E5%86%B2%E7%AA%81" rel="nofollow">2. 为什么会产生Jar包冲突</a></p> 
 <p id="2.1%20maven%E4%BB%B2%E8%A3%81%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#2.1%20maven%E4%BB%B2%E8%A3%81%E6%9C%BA%E5%88%B6" rel="nofollow">2.1 maven仲裁机制</a></p> 
 <p id="2.2%20Jar%E5%8C%85%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.2%20Jar%E5%8C%85%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F" rel="nofollow">2.2 Jar包的加载顺序</a></p> 
 <p id="3.%C2%A0Jar%E5%8C%85%E5%86%B2%E7%AA%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#3.%C2%A0Jar%E5%8C%85%E5%86%B2%E7%AA%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98" rel="nofollow">3. Jar包冲突会导致什么问题</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">二、解决方案</a></p> 
 <p id="1%E3%80%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3" rel="nofollow">1、问题排查和解决</a></p> 
 <p id="2%E3%80%81%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%81%BF%E5%85%8D-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%81%BF%E5%85%8D" rel="nofollow">2、如何有效避免</a></p> 
 <p id="2.1%20%E8%89%AF%E5%A5%BD%E7%9A%84%E4%B9%A0%E6%83%AF%EF%BC%9A%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#2.1%20%E8%89%AF%E5%A5%BD%E7%9A%84%E4%B9%A0%E6%83%AF%EF%BC%9A%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86" rel="nofollow">2.1 良好的习惯：依赖管理</a></p> 
 <p id="2.2%20%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.2%20%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6" rel="nofollow">2.2 冲突检测插件</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
 <p></p> 
</div> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<p><font face="monospace">我们在java应用程序的编译或者运行时可能会遇到抛出</font>java.lang.ClassNotFoundException、java.lang.NoSuchMethodError、java.lang.NoClassDefFoundError这类的异常。这类异常一般都是jar包冲突导致的。那么jar包冲突的原因是什么？如何解决jar包冲突呢？我们一起来看下。</p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81Jar%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><strong style="color:#4f4f4f;font-size:24px;font-weight:bold;">一、</strong>Jar包冲突问题</h2> 
<h3 id="1.%20%E4%BB%80%E4%B9%88%E6%98%AFJar%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><strong style="color:#4f4f4f;font-size:22px;font-weight:bold;">1. 什么是Jar包</strong>冲突问题</h3> 
<blockquote> 
 <p>Jar包冲突问题的本质：Java应用程序因某种因素，加载不到正确的类而致使其行为跟预期不一致。</p> 
</blockquote> 
<p>具体来讲可分为两种状况：</p> 
<p>1）第一类Jar包冲突问题：应用程序依赖的同一个Jar包出现了多个不一样版本，并选择了错误的版本而致使JVM加载不到需要的类或加载了错误版本的类；</p> 
<p>2）第二类Jar包冲突问题：一样的类（类的全限定名彻底同样）出现在多个不一样的依赖Jar包中，即该类有多个版本，并因为Jar包加载的前后顺序致使JVM加载了错误版本的类。</p> 
<p>这两种状况所致使的结果实际上是同样的，都会使应用程序加载不到正确的类，那么其行为就会跟预期不一致了，下面对这两种类型进行详细分析。</p> 
<h4 id="1.1%20%E5%90%8C%E4%B8%80%E4%B8%AAJar%E5%8C%85%E5%87%BA%E7%8E%B0%E4%BA%86%E5%A4%9A%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%89%88%E6%9C%AC">1.1 同一个Jar包出现了多个不一样版本</h4> 
<p>随着Jar包迭代升级，应用程序所依赖的开源的或公司内部的Jar包工具都会存在若干不一样的版本，而版本升级天然就避免不了类的方法签名变动，甚至于类名的更替，而当前的应用程序依赖特定版本的某个类M ，因为maven的传递依赖而致使同一个Jar包出现了多个版本，当maven的仲裁机制选择了错误的版本时，而刚好类M在该版本中被去掉了，或者方法签名改了，致使应用程序因找不到所需的类M或找不到类M中的特定方法，就会出现第一类Jar冲突问题。可总结出该类冲突问题发生的如下三个必要条件：</p> 
<ul><li>因为maven的传递依赖致使依赖树中出现了同一个Jar包的多个版本</li><li>该Jar包的多个版本之间存在接口差别，如类名更替，方法签名更替等，且应用程序依赖了其中有变动的类或方法</li><li>maven的仲裁机制选择了错误的版本</li></ul> 
<h4 id="1.2%20%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%A4%9A%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7Jar%E5%8C%85%E4%B8%AD">1.2 同一个类出现在多个不一样Jar包中</h4> 
<p>一样的类出现在应用程序所依赖的两个及以上的不一样Jar包中，这会致使什么问题呢？我们知道，同一个类加载器对于同一个类只会加载一次（多个不一样类加载器就另说了，这也是解决Jar包冲突的一个思路，后面会谈到），那么当一个类出现在多个Jar包中，假设有 A 、 B 、 C 等，因为Jar包依赖的路径长短、声明的前后顺序或文件系统的文件加载顺序等缘由，类加载器首先从Jar包 A 中加载了该类后，就不会加载其他Jar包中的这个类了，那么问题来了：若是应用程序此时需要的是Jar包 B 中的类版本，而且该类在Jar包 A 和 B 中有差别（方法不一样、成员不一样等等），而JVM却加载了Jar包 A 的中的类版本，与期望不一致，自然就会出现各类诡异的问题。</p> 
<p>从上面的描述中，能够发现出现不一样Jar包的冲突问题有如下三个必要条件：</p> 
<ul><li>同一个类 M 出现在多个依赖的Jar包中，为了叙述方便，假设仍是两个： A 和 B</li><li>Jar包 A 和 B 中的该类 M 有差别，不管是方法签名不一样也好，成员变量不一样也好，只要能够形成实际加载的类的行为和指望不一致都行。若是说Jar包 A 和 B 中的该类彻底同样，那么类加载器不管先加载哪一个Jar包，获得的都是一样版本的类 M ，不会有任何影响，也就不会出现Jar包冲突带来的诡异问题。</li><li>加载的类 M 不是所指望的版本，即加载了错误的Jar包</li></ul> 
<p></p> 
<h3 id="2.%C2%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9FJar%E5%8C%85%E5%86%B2%E7%AA%81"><a id="2_34"></a>2.<strong> 为什么会产生Jar包</strong>冲突</h3> 
<h4 id="2.1%20maven%E4%BB%B2%E8%A3%81%E6%9C%BA%E5%88%B6">2.1 maven仲裁机制</h4> 
<p>传递性依赖是Maven2.0引入的新特性，让开发人员只需关注直接依赖的Jar包，对于间接依赖的Jar包，Maven会经过解析从远程仓库获取的依赖包的pom文件来隐式地将其引入，为开发带来了极大的便利。但同时也带来了版本冲突的问题，即同一个Jar包出现了多个不一样的版本。针对该问题Maven也有一套仲裁机制来决定最终选用哪一个版本，但Maven的选择不一定是开发人员所指望的，这也是产生Jar包冲突最多见的原因。先来看下Maven的仲裁机制：</p> 
<ul><li>优先按照依赖管理**&lt;dependencyManagement&gt;**元素中指定的版本声明进行仲裁，此时下面的两个原则都无效了</li><li>若无版本声明，则按照“短路径优先”的原则（Maven2.0）进行仲裁，即选择依赖树中路径最短的版本</li><li>若路径长度一致，则按照“第一声明优先”的原则进行仲裁，即选择POM中最早声明的版本</li></ul> 
<p>从maven的仲裁机制中能够发现，除了第一条仲裁规则（这也是解决Jar包冲突的经常使用手段之一）外，后面的两条原则，对于同一个Jar包不一样版本的选择，也许是maven研发团队在总结了大量的项目依赖管理经验后得出的两条结论，又或者是发现根本找不到一种统一的方式来知足全部场景以后的无奈之举。可能这对于多数场景是适用的，可是它不一定适合我们当前的应用。由于每一个应用都有其特殊性，该依赖哪一个版本，maven没办法帮你彻底搞定，如果你没有规规矩矩地使用**&lt;dependencyManagement&gt;**来进行依赖管理，就注定了逃脱不了第一类Jar包冲突问题。</p> 
<h4 id="2.2%20Jar%E5%8C%85%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F" style="background-color:transparent;">2.2 Jar包的加载顺序</h4> 
<p>对于第二类Jar包冲突问题，即多个不一样的Jar包有类冲突，这相对于第一类问题就显得更为棘手。为什么这么说呢？在这种状况下，两个不一样的Jar包，假设为 A、 B，它们的名称互不相同，甚至可能彻底不沾边，若是不是出现冲突问题，你可能都不会发现它们有共有的类！对于A、B这两个Jar包，maven就显得无能为力了，由于maven只会为你针对同一个Jar包的不一样版本进行仲裁，而这俩是属于不一样的Jar包，超出了maven的依赖管理范畴。此时，当A、B都出现在应用程序的类路径下时，就会存在潜在的冲突风险，即A、B的加载前后顺序就决定着JVM最终选择的类版本，若是选错了，就会出现诡异的第二类冲突问题。</p> 
<p>那么Jar包的加载顺序都由哪些因素决定的呢？具体以下：</p> 
<ul><li>Jar包所处的加载路径，或者换个说法就是加载该Jar包的类加载器在JVM类加载器树结构中所处层级。因为JVM类加载的双亲委派机制，层级越高的类加载器越先加载其加载路径下的类，顾名思义，引导类加载器（bootstrap ClassLoader，也叫启动类加载器）是最早加载其路径下Jar包的，其次是扩展类加载器（extension ClassLoader），再次是系统类加载器（system ClassLoader，也就是应用加载器appClassLoader），Jar包所处加载路径的不一样，就决定了它的加载顺序的不一样。</li><li>文件系统的文件加载顺序。这个因素很容易被忽略，也是因环境不一致而致使各类诡异冲突问题的罪魁祸首。因tomcat、resin等容器的ClassLoader获取加载路径下的文件列表时是不排序的，这就依赖于底层文件系统返回的顺序，那么当不一样环境之间的文件系统不一致时，就会出现有的环境没问题，有的环境出现冲突。例如，对于Linux操做系统，返回顺序则是由iNode的顺序来决定的，若是说测试环境的Linux系统与线上环境不一致时，就极有可能出现典型案例：测试环境怎么测都没问题，但一上线就出现冲突问题，规避这种问题的最佳办法就是尽可能保证测试环境与线上一致。</li></ul> 
<h3 id="3.%C2%A0Jar%E5%8C%85%E5%86%B2%E7%AA%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">3.<strong> Jar包</strong>冲突会导致什么问题</h3> 
<p>Jar包冲突可能会导致哪些问题？一般发生在编译或运行时，主要分为两类问题：一类是比较直观的也是最为常见的错误是抛出各类运行时异常，还有一类就是比较隐晦的问题，它不会报错，其表现形式是应用程序的行为跟预期不一致，具体问题如下：</p> 
<ul><li>java.lang.ClassNotFoundException，即java类找不到。这类典型异常一般是因为，没有在依赖管理中声明版本，maven的仲裁的时候选取了错误的版本，而这个版本缺乏应用程序需要的某个class而致使该错误。例如httpclient-4.4.jar升级到httpclient-4.36.jar时，类org.apache.http.conn.ssl.NoopHostnameVerifier被去掉了，如果原本需要的是4.4版本，且用到了NoopHostnameVerifier这个类，而maven仲裁时选择了4.6，则会致使ClassNotFoundException异常。</li><li>java.lang.NoSuchMethodError，即找不到特定方法，第一类冲突和第二类冲突均可能致使该问题——加载的类不正确。如果第一类冲突，则是因为错误版本的Jar包与所需要版本的Jar包中的类接口不一致致使，例如antlr-2.7.2.jar升级到antlr-2.7.6.Jar时，接口antlr.collections.AST.getLine()发生变更，当maven仲裁选择了错误版本而加载了错误版本的类AST，则会致使该异常；如果第二类冲突，则是因为不一样Jar包含有的同名类接口不一致致使，典型的案例：Apache的commons-lang包，2.x升级到3.x时，包名直接从commons-lang改成commons-lang3，部分接口也有所改动，因为包名不一样和传递性依赖，常常会出现两种Jar包同时在classpath下，org.apache.commons.lang.StringUtils.isBlank就是其中有差别的接口之一，因为Jar包的加载顺序，致使加载了错误版本的StringUtils类，就可能出现NoSuchMethodError异常。</li><li>java.lang.NoClassDefFoundError，java.lang.LinkageError等，原因和上述雷同，就不做具体案例分析了。</li><li>没有报错异常，但应用的行为跟预期不一致。这类问题一样也是因为运行时加载了错误版本的类致使，但跟前面不一样的是，冲突的类接口都是一致的，但具体实现逻辑有差别，当应用程序加载的类版本不是实现逻辑，就会出现行为跟预期不一致问题。这类问题一般发生在应用程序本身内部实现的多个Jar包中，因为包路径和类名命名不规范等问题，致使两个不一样的Jar包出现了接口一致但实现逻辑又各不相同的同名类，从而引起此问题。</li></ul> 
<h2 id="%E4%BA%8C%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">二、解决方案</h2> 
<h3 id="1%E3%80%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3">1、问题排查和解决</h3> 
<p>1） 如果有异常堆栈信息，根据错误信息便可定位致使冲突的类名，而后在eclipse中<code>CTRL+SHIFT+T</code>或者在idea中<code>CTRL+N</code>就可发现该类存在于多个依赖Jar包中</p> 
<p>2）如果步骤1没法定位冲突的类来自哪一个Jar包，可在应用程序启动时加上JVM参数<code>-verbose:class</code>或者<code>-XX:+TraceClassLoading</code>，日志里会打印出每一个类的加载信息，如来自哪一个Jar包</p> 
<p>3）定位了冲突类的Jar包以后，经过<code>mvn dependency:tree -Dverbose -Dincludes=&lt;groupId&gt;:&lt;artifactId&gt;</code>查看是哪些地方引入的Jar包的这个版本</p> 
<p>4）肯定Jar包来源以后，如果是第一类Jar包冲突，则可用**&lt;excludes&gt;排除不须要的Jar包版本或者在依赖管理&lt;dependencyManagement&gt;中申明版本；如果第二类Jar包冲突，可以排除的话，则用&lt;excludes&gt;**排掉不须要的那个Jar包，如果不能排除，则需考虑Jar包的升级或换个别的Jar包。</p> 
<h3 id="2%E3%80%81%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%81%BF%E5%85%8D" style="background-color:transparent;">2、如何有效避免</h3> 
<p>从上一节的解决方案能够发现，当出现第二类Jar包冲突，且冲突的Jar包又没法排除时，问题变得至关棘手，这时候要处理该冲突问题就须要较大成本了，因此，最好的方式是在冲突发生以前能有效地规避。那么怎样才能有效地规避Jar包冲突呢？</p> 
<h4 id="2.1%20%E8%89%AF%E5%A5%BD%E7%9A%84%E4%B9%A0%E6%83%AF%EF%BC%9A%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">2.1 良好的习惯：依赖管理</h4> 
<p>对于第一类Jar包冲突问题，一般的作法是用**&lt;excludes&gt;排除不须要的版本，但这种作法带来的问题是每次引入带有传递性依赖的Jar包时，都需要一一进行排除，很麻烦。maven为此提供了集中管理依赖信息的机制，即依赖管理元素&lt;dependencyManagement&gt;**，对依赖Jar包进行统一版本管理，一劳永逸。一般的作法是，在parent模块的pom文件中尽量地声明全部相关依赖Jar包的版本，并在子pom中简单引用该构件便可。</p> 
<p>来看个示例，当确定开发时使用的httpclient版本为4.5.1时，可在父pom中配置以下：</p> 
<pre><code class="language-XML">    &lt;properties&gt;
      &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt;
    &lt;/properties&gt;
    &lt;dependencyManagement&gt;
      &lt;dependencies&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
          &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
          &lt;version&gt;${httpclient.version}&lt;/version&gt;
        &lt;/dependency&gt;
      &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;</code></pre> 
<p>而后各个需要依赖该Jar包的子pom中配置以下依赖：</p> 
<pre><code class="language-XML">    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<h4 id="2.2%20%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6">2.2 冲突检测插件</h4> 
<p>对于第二类Jar包冲突问题，前面也提到过，其核心在于同名类出现在多个不一样的Jar包中，若是人工来排查该问题，则需要逐个点开每一个Jar包，而后相互对比看有没同名的类，那得多么浪费精力啊？！好在这种费时费力的体力活能交给程序去干。maven-enforcer-plugin，这个强大的maven插件，配合extra-enforcer-rules工具，能自动扫描Jar包将冲突检测并打印出来。其原理其实也比较简单，经过扫描Jar包中的class，记录每一个class对应的Jar包列表，如果有多个就是冲突了。</p> 
<p>在最终需要打包运行的应用模块pom中，引入maven-enforcer-plugin的依赖，在build阶段便可发现问题，并解决它。好比对于具备parent pom的多模块项目，需要将插件依赖声明在应用模块的pom中。这里有童鞋可能会疑问，为何不把插件依赖声明在parent pom中呢？那样依赖它的应用子模块岂不是都能复用了？这里之因此强调“打包运行的应用模块pom”，是由于冲突检测针对的是最终集成的应用，关注的是应用运行时是否会出现冲突问题，而每一个不一样的应用模块，各自依赖的Jar包集合是不一样的，由此而产生的**&lt;ignoreClasses&gt;**列表也是有差别的，所以只能针对应用模块pom分别引入该插件。</p> 
<p>先看示例用法以下：</p> 
<pre><code class="language-XML">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.4.1&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;enforce&lt;/id&gt;
      &lt;configuration&gt;
        &lt;rules&gt;
          &lt;dependencyConvergence/&gt;
        &lt;/rules&gt;
      &lt;/configuration&gt;
      &lt;goals&gt;
        &lt;goal&gt;enforce&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
    &lt;execution&gt;
      &lt;id&gt;enforce-ban-duplicate-classes&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;enforce&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;rules&gt;
          &lt;banDuplicateClasses&gt;
            &lt;ignoreClasses&gt;
              &lt;ignoreClass&gt;javax.*&lt;/ignoreClass&gt;
              &lt;ignoreClass&gt;org.junit.*&lt;/ignoreClass&gt;
              &lt;ignoreClass&gt;net.sf.cglib.*&lt;/ignoreClass&gt;
              &lt;ignoreClass&gt;org.apache.commons.logging.*&lt;/ignoreClass&gt;
              &lt;ignoreClass&gt;org.springframework.remoting.rmi.RmiInvocationHandler&lt;/ignoreClass&gt;
            &lt;/ignoreClasses&gt;
            &lt;findAllDuplicates&gt;true&lt;/findAllDuplicates&gt;
          &lt;/banDuplicateClasses&gt;
        &lt;/rules&gt;
        &lt;fail&gt;true&lt;/fail&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
      &lt;artifactId&gt;extra-enforcer-rules&lt;/artifactId&gt;
      &lt;version&gt;1.0-beta-6&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre> 
<p>maven-enforcer-plugin是经过不少预约义的标准规则（<a href="http://maven.apache.org/enforcer/enforcer-rules/index.html" rel="nofollow" title="standard rules">standard rules</a>）和用户自定义规则，来约束maven的环境因素，如maven版本、JDK版本等等，它有不少好用的特性，具体可参见<a href="http://maven.apache.org/enforcer/maven-enforcer-plugin/" rel="nofollow" title="官网">官网</a>。而Extra Enforcer Rules则是<em>MojoHaus</em>项目下的针对maven-enforcer-plugin而开发的提供额外规则的插件，这其中就包含前面所提的重复类检测功能，具体用法可参见<a href="http://www.mojohaus.org/extra-enforcer-rules/" rel="nofollow" title="官网">官网</a>，这里就不详细叙述了。</p> 
<p></p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93" style="background-color:transparent;"><a id="_45"></a>总结</h2> 
<p>本文首先介绍了两类Jar包冲突问题：第一类是同一个Jar包出现了多个不一样版本，第二类是同一个类出现在多个不同的Jar包中。</p> 
<p>然后介绍了第一类Jar包冲突问题的原因是是因为Maven仲裁机制并不能只能的判断应用真正需要的Jar包版本，第二类Jar包冲突问题的原因是受到Jar包的类加载器的加载顺序和操作系统的文件加载顺序的影响。</p> 
<p>最后提出了问题排除和解决的方案，以及如何有效避免Jar包冲突问题的发生。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e31038d0887dbf533dc87dba99d02a92/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【IJCAI2022】Uncertainty-Guided Pixel Contrastive Learning for Semi-Supervised Medical Image Segmentat</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99424670e190cb1807361d26399aec29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 虚拟机与类加载机制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>