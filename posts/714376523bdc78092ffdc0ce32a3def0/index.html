<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue3中pinia用法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue3中pinia用法" />
<meta property="og:description" content="安装
npm install pinia --save 1.在main.js中
import { createApp } from &#34;vue&#34;; import App from &#34;./App.vue&#34;; import { createPinia } from &#34;pinia&#34;; const pinia = createPinia(); createApp(App).use(pinia).mount(&#34;#app&#34;); 2.创建文件 store/index.js
也存在另一种定义 store 的可用语法。与 Vue 组合式 API 的 setup 函数 相似，我们可以传入一个函数，该函数定义了一些响应式属性和方法，并且返回一个带有我们想暴露出去的属性和方法的对象。我感觉这种形式写着更方便简单。
import { defineStore } from &#34;pinia&#34;; import { ref } from &#39;vue&#39; export const useStore = defineStore(&#39;main&#39;,() =&gt; { const searchValue = ref(&#39;&#39;); const count = ref(0); function onSearchValue() { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/714376523bdc78092ffdc0ce32a3def0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-01T21:41:06+08:00" />
<meta property="article:modified_time" content="2023-08-01T21:41:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue3中pinia用法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>安装</p> 
<pre><code class="language-javascript">npm install pinia --save</code></pre> 
<p>1.在main.js中</p> 
<pre><code class="language-javascript">import { createApp } from "vue";
import App from "./App.vue";
import { createPinia } from "pinia";
const pinia = createPinia();

createApp(App).use(pinia).mount("#app");</code></pre> 
<p>2.创建文件 store/index.js</p> 
<p>也存在另一种定义 store 的可用语法。与 Vue 组合式 API 的 <a href="https://cn.vuejs.org/api/composition-api-setup.html" rel="nofollow" title="setup 函数">setup 函数</a> 相似，我们可以传入一个函数，该函数定义了一些响应式属性和方法，并且返回一个带有我们想暴露出去的属性和方法的对象。我感觉这种形式写着更方便简单。</p> 
<pre><code class="language-javascript">import { defineStore } from "pinia";
import { ref } from 'vue'

export const useStore = defineStore('main',() =&gt; {
    const searchValue = ref('');
    const count = ref(0);
    function onSearchValue() {
        console.log(searchValue,'这里是store');
    }

    return { searchValue,onSearchValue }
})</code></pre> 
<p>在 <em>Setup Store</em> 中：</p> 
<ul><li><code>ref()</code> 就是 <code>state</code> 属性</li><li><code>computed()</code> 就是 <code>getters</code></li><li><code>function()</code> 就是 <code>actions</code></li></ul> 
<p><code>3.页面中的使用</code></p> 
<pre><code class="language-javascript">&lt;/template&gt;
    &lt;div&gt;数据显示：{<!-- -->{store.searchValue}}&lt;/div&gt;
    &lt;button @click="onSearchValue"&gt;pinia事件&lt;/button&gt;
&lt;template&gt;

&lt;script&gt;
    import { useStore } from '@/store/index'
    import { storeToRefs } from 'pinia'

    export default defineComponent({
      setup() {
        const store = useStore();
        const { searchValue,onSearchValue } = storeToRefs(store);

        //数据监听
        store.$subscribe((mutation, state) =&gt; {
            console.log(mutation, state.searchValue,'------------')
        })
        return {
            searchValue,
            onSearchValue:store.onSearchValue,
        }
      }
    })
&lt;/script&gt;</code></pre> 
<p>4.Pinia修改数据状态</p> 
<p>简单数据直接通过 store.属性名修改，如store.searchValue = '文章';修改</p> 
<pre><code class="language-javascript">&lt;/template&gt;
    &lt;div&gt;数据显示：{<!-- -->{store.searchValue}}&lt;/div&gt;
    &lt;button @click="onSearchValue"&gt;pinia事件&lt;/button&gt;
    &lt;button @click="onmodify"&gt;赋值&lt;/button&gt;
&lt;template&gt;

&lt;script&gt;
    import { useStore } from '@/store/index'
    import { storeToRefs } from 'pinia'

    export default defineComponent({
      setup() {
        const store = useStore();
        const { searchValue,onSearchValue } = storeToRefs(store);

        //数据监听
        store.$subscribe((mutation, state) =&gt; {
            console.log(mutation, state.searchValue,'------------')
        })
        //直接修改pinia中变量
        const onmodify = () =&gt; {
            store.searchValue = '测试';
        }
        return {
            searchValue,
            onmodify,
            onSearchValue:store.onSearchValue,
        }
      }
    })
&lt;/script&gt;</code></pre> 
<p>5.使用$patch修改多条数据</p> 
<p>通过基础数据修改方式去修改多条数据也是可行的，但是在 <code>pinia</code> 官网中，已经明确表示<code>$patch</code> 的方式是经过优化的，会加快修改速度，对性能有很大好处，所以在进行多条数据修改的时候，更推荐使用 <code>$patch</code></p> 
<p><code>$patch</code> 方法可以接受两个类型的参数，函数 和 对象</p> 
<ul><li><strong>$patch + 对象</strong></li><li><strong>$patch + 函数：</strong> 通过函数方式去使用的时候，函数接受一个 state 的参数，state 就是 store 仓库中的 state</li></ul> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div&gt;
        &lt;button @click='onObj'&gt;对象形式修改&lt;/button&gt;
        &lt;button @click='onFun'&gt;函数形式修改&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang='ts'&gt;
    import {} '../store/index'
    const store = mainStore();

    //$patch 对象形式修改
    const onObj = （）=&gt; {
        store.$patch({
            count:store.count + 2,
            searchValue:store.searchValue? '有数据':'没有数据'
        })
    }

    //$patch 函数形式修改
    const onFun = （）=&gt; {
        store.$patch(() =&gt; {
            count:store.count + 2,
            searchValue:store.searchValue? '有数据':'没有数据'
        })
    }
&lt;/script&gt;</code></pre> 
<h4>6.Pinia中的Getters</h4> 
<p>Pinia 中的 getter 和 Vue 中的计算属性几乎一样，在获取 State值之前做一些逻辑处理</p> 
<ol><li> <p>getter 中的值有缓存特性，如果值没有改变，多次使用也只会调用一次</p> 
  <ul><li>添加 getter方法</li></ul><p class="img-center"><img alt="" src="https://images2.imgbox.com/42/78/mfgnfCp4_o.png"></p> 
  <ul><li>组件内多次调用</li></ul><p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/a5/QH1nOMyL_o.png"></p> <p class="img-center"><img alt="" src="https://images2.imgbox.com/af/20/gKgXolN2_o.png"></p> </li><li> <p>getter 中不仅可以传递 <code>state</code> 直接改变数据状态，还可以使用 <code>this</code> 来改变数据</p> <p class="img-center"><img alt="" src="https://images2.imgbox.com/73/96/pggxVxYC_o.png"></p> </li></ol> 
<h3>store之间的相互调用</h3> 
<p>在 Pinia 中，可以在一个 <code>store</code> 中 <code>import</code> 另外一个 <code>store</code> ，然后通过调用引入 store 方法的形式，获取引入 <code>store</code> 的状态</p> 
<ul><li>新建 store</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/78/ee/KCgeOvyh_o.png"></p> 
<ul><li>在原 store 中引入 allanStore，并获取 <code>moveList</code></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/07/3b/9SvkRE7e_o.png"></p> 
<ul><li>组件中使用 <code>mainStore.getAllanStoreList</code></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4e/68/OhAPjG7T_o.png"></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/877b011b1c51789fc52cdf13023c4da9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法题--二叉树（二叉树的最近公共祖先、重建二叉树、二叉搜索树的后序遍历序列）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/23e0a6b6f54bcf873908b76872a01ef6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Jinjia模板语法将数据传递给JavaScript变量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>