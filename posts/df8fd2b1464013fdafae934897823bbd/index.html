<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java #类的加载过程 #类加载子系统 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java #类的加载过程 #类加载子系统" />
<meta property="og:description" content="类加载子系统 类的加载阶段可以分为三个阶段，这三个阶段为加载阶段、链接阶段、初始化阶段。
阶段一（加载阶段 Loading）： 通过一个类的获取定义此类的二进制字节流转化为方法区的运行时数据结构在内存中生成一个代表这个类的 java.lang.Class 对象，作为该类的访问入口 阶段二（链接阶段 Linking）： 验证：目的在于确保Class文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全准备：为类变量分配内存并且设置该类变量的默认初始值，即零值。 注：在链接阶段如果变量被final修饰，则直接被赋值
private static int a = 1; private static final int b = 2; 小编用代码和字节码文件来说明一下： 查看字节码文件，由于&lt;clinit&gt;是初始化阶段发生的（也就是在阶段三），只能看到a被赋值为1，说明b是在链接阶段被赋值的（在阶段三中看不到b被赋值），所以证明final是在链接阶段发生的
（这里在IDEA中装上jclasslib插件就可以看到字节码文件了，View-Show Bytecode With Jclasslib就可以看到当前类的字节码文件啦）
阶段三（初始化阶段 Initialization）： 初始化阶段就是执行类构造器方法 &lt;clinit&gt;()的过程。该方法体是编译器自动收集类中的所有类变量（静态成员）的赋值动作和静态代码块中的语句合并而来（简单的说：&lt;clinit&gt;()为static的动作的合并语句），&lt;clinit&gt;() 执行前，父类的&lt;clinit&gt;() 已经执行完毕。&lt;clinit&gt;() 方法在多线程下被同步加锁。 例：说明一下&lt;clinit&gt;()
在&lt;clinit&gt;()里可以看到，num --&gt;1--&gt;2，number --&gt;20 --&gt;10，按照顺序执行，除此之外，我们还发现声明可以放在后面，但是调用变量必须在声明后调用
为了说明&lt;clinit&gt;是被同步加锁的，来看下面的代码的执行结果：
public class ClinitThreadTest { public static void main(String[] args) { Thread t1 = new Thread(&#34;线程1&#34;){ @Override public void run() { System.out.println(Thread.currentThread().getName() &#43; &#34;开始&#34;); C c = new C(); System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/df8fd2b1464013fdafae934897823bbd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-24T21:29:12+08:00" />
<meta property="article:modified_time" content="2021-05-24T21:29:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java #类的加载过程 #类加载子系统</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#86ca5e;">类加载子系统</span></h2> 
<p>类的加载阶段可以分为三个阶段，这三个阶段为加载阶段、链接阶段、初始化阶段。</p> 
<h4>阶段一（加载阶段 Loading）：</h4> 
<ol><li>通过一个类的获取定义此类的二进制字节流</li><li>转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的  java.lang.Class 对象，作为该类的访问入口</li></ol> 
<h4>阶段二（链接阶段 Linking）：</h4> 
<ol><li>验证：目的在于确保Class文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>准备：为类变量分配内存并且设置该类变量的默认初始值，即零值。</li></ol> 
<blockquote> 
 <p>注：在链接阶段如果变量被final修饰，则直接被赋值</p> 
 <pre><code class="language-java">private static int a = 1;
private static final int b = 2;</code></pre> 
 <p>小编用代码和字节码文件来说明一下： </p> 
 <p><img alt="" height="244" src="https://images2.imgbox.com/8f/26/49IlAQ7m_o.png" width="1200"></p> 
 <p> 查看字节码文件，由于&lt;clinit&gt;是初始化阶段发生的（也就是在阶段三），只能看到a被赋值为1，说明b是在链接阶段被赋值的（在阶段三中看不到b被赋值），所以证明final是在链接阶段发生的</p> 
 <p>（这里在IDEA中装上jclasslib插件就可以看到字节码文件了，View-Show Bytecode With Jclasslib就可以看到当前类的字节码文件啦）</p> 
</blockquote> 
<h4>阶段三（初始化阶段 Initialization）：</h4> 
<ol><li>初始化阶段就是执行类构造器方法 &lt;clinit&gt;()的过程。该方法体是编译器自动收集类中的所有类变量（静态成员）的赋值动作和静态代码块中的语句合并而来（简单的说：&lt;clinit&gt;()为static的动作的合并语句），&lt;clinit&gt;() 执行前，父类的&lt;clinit&gt;() 已经执行完毕。&lt;clinit&gt;() 方法在多线程下被同步加锁。</li></ol> 
<blockquote> 
 <p>例：说明一下&lt;clinit&gt;()</p> 
 <p><img alt="" height="438" src="https://images2.imgbox.com/86/07/WGX9Fk8Y_o.png" width="1200"></p> 
 <p>在&lt;clinit&gt;()里可以看到，num --&gt;1--&gt;2，number --&gt;20 --&gt;10，按照顺序执行，除此之外，我们还发现声明可以放在后面，但是调用变量必须在声明后调用</p> 
</blockquote> 
<blockquote> 
 <p> 为了说明&lt;clinit&gt;是被同步加锁的，来看下面的代码的执行结果：</p> 
 <pre><code class="language-java">public class ClinitThreadTest {
    public static void main(String[] args) {
        Thread t1 = new Thread("线程1"){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "开始");
                C c = new C();
                System.out.println(Thread.currentThread().getName() + "结束");
            }
        };
        Thread t2 = new Thread("线程2"){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "开始");
                C c = new C();
                System.out.println(Thread.currentThread().getName() + "结束");
            }
        };
        t1.start();
        t2.start();
    }
}
class C{
    static {
        System.out.println(Thread.currentThread().getName() + "&lt;clinit&gt;()初始化类C");
        try {
            Thread.currentThread().sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
 <p>执行结果为： </p> 
 <pre><code>线程1开始
线程2开始
线程2&lt;clinit&gt;()初始化类C
线程2结束
线程1结束</code></pre> 
 <p>解释一下代码：</p> 
 <p>创建了两个线程1、2，线程2进入到类C的static代码块时也就是执行&lt;clinit&gt;()方法，执行输出sysout语句，线程进入睡眠，sleep()不会释放锁，我们看到线程1没有进入&lt;clinit&gt;方法，说明&lt;clinit&gt;()方法被加锁了，而且等线程2将&lt;clinit&gt;()执行完后，线程1没有执行，说明线程1已经知道C的&lt;clinit&gt;方法被执行过了，由此也说明&lt;clinit&gt;不但被加锁，而且是被同步加锁的。（到这里就更加理解了：wow原来静态成员和代码块只能被加载一次是这么回事）</p> 
</blockquote> 
<p>经过了类加载子系统后，将它们加载进了运行时数据区</p> 
<p>小编来配一张图，更直观：</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/27/45/xxXPDBIz_o.png" width="732"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38321817647d19ace3877ace6aac95ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端常见的面试题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0dcf06624f34b106079c71d24d861f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pytorch函数mm() mul() matmul()区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>