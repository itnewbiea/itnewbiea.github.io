<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>蓝桥杯模块学习4——数码管（深夜学习——单片机） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="蓝桥杯模块学习4——数码管（深夜学习——单片机）" />
<meta property="og:description" content="目录
一、硬件部分：
1、573锁存器：
2、共阳极数码管：​编辑
3、总体思路：
二、静态数码管： 1、代码思路：
2、参考代码：
3、参考代码（模块化）：
三、动态数码管：
1、代码思路：
2、参考代码：
（1）宏定义函数：
（2）主函数：
四、动态数码管（优化）：
五、动态数码管（中断显示）：（建议学习过定时器后再来看以下代码）
一、硬件部分： 1、573锁存器： 如果还不懂可以参考之前的点亮LED灯的文章
蓝桥杯模块学习2——LED灯（深夜学习——单片机）_佛科院深夜学习的博客-CSDN博客https://blog.csdn.net/weixin_63568691/article/details/128431461
2、共阳极数码管： 图1
（1）其实可以把数码管可以看作多个LED灯组成的电路，每个数字由8个LED组成
（2）什么叫共阳极？
可以理解为LED灯的一端接了VCC，只需要在另一端输入低电平就能将他点亮
（3）封装好的共阳极数码管1-F对应的十六进制数：
//定义一个数组存放从0-f对应的16进制数 //code 关键字的作用是我定义的数据要存放到ROM区，写入后不可以被改变 //输入16为分隔符号 u8 code transistor_positive[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8, 0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e, 0xfd }; //带小数点 u8 code transistor_positive_point[]= { 0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78, 0x00,0x10,0x08,0x03,0x46,0x21,0x06,0x0e }; 3、总体思路： 图2
（1）由图1可知，我们先通过右边com口（位选）选择需要亮的数码管，再通过左边八个口（段选）确定要选择的数字
（2）由图2可知，单片机通过两个573锁存器控制数码管的位选和段选，只需要按照之前的方法对锁存器进行选择再输入数据即可
二、静态数码管： 实现功能：8个数码管分别单独逐次显示1-8，然后所有数码管同时逐次显示0-F 1、代码思路： 由上述硬件电路可知只需要选择相应的锁存器和输入相应的数据就行了
2、参考代码： // 使用程序前，将J13调整为IO模式（2-3脚短接） #include &#34;reg52.h&#34; #include &#34;Public.h&#34; //定义一个数组存放从1-f对应的16进制数 //code 关键字的作用是我定义的数据要存放到ROM区，写入后不可以被改变 u8 code transistor_positive[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8, 0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e }; //带小数点 u8 code transistor_positive_point[]= { 0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78, 0x00,0x10,0x08,0x03,0x46,0x21,0x06,0x0e }; void HC138_Y(u8 num); void Close_All(void); void main(void) // 主函数 { u8 i; while(1) { Close_All(); //8个数码管分别单独逐次显示1-8 for(i=1;i&lt;=8;i&#43;&#43;) { //改变数据 HC138_Y(7); P0 = transistor_positive[i]; //改变显示位置 HC138_Y(6); P0 = 0x01&lt;&lt;(i-1); Delay_1ms(500); } //数码管同时逐次显示0-F for(i=0;i&lt;16;i&#43;&#43;) { //改变数据 HC138_Y(7); P0 = transistor_positive[i]; //改变显示位置 HC138_Y(6); P0 = 0xff; Delay_1ms(500); } } } /* 输入变量：4-7 输出变量：无 功能：操作138译码器，4-7分别对应Y4-Y7，其余都会使译码器不起作用 */ void HC138_Y(u8 num) { switch(num) { case 4:P2 = (P2 &amp; 0x1f) | 0x80;break; case 5:P2 = (P2 &amp; 0x1f) | 0xA0;break; case 6:P2 = (P2 &amp; 0x1f) | 0xC0;break; case 7:P2 = (P2 &amp; 0x1f) | 0xE0;break; default:P2 = (P2 &amp; 0x1f) | 0x00; } } /* 输入变量：无 输出变量：无 功能：关闭蜂鸣器和继电器 */ void Close_All(void) { P2 = (P2 &amp; 0x1f) | 0xA0; P0 = 0x00; } 3、参考代码（模块化）： // 使用程序前，将J13调整为IO模式（2-3脚短接） #include &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/07e69728071c3c80a241e04c3e804c2b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-28T13:24:46+08:00" />
<meta property="article:modified_time" content="2023-01-28T13:24:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">蓝桥杯模块学习4——数码管（深夜学习——单片机）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86%EF%BC%9A" rel="nofollow">一、硬件部分：</a></p> 
<p id="1%E3%80%81573%E9%94%81%E5%AD%98%E5%99%A8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1%E3%80%81573%E9%94%81%E5%AD%98%E5%99%A8%EF%BC%9A" rel="nofollow">1、573锁存器：</a></p> 
<p id="2%E3%80%81%E5%85%B1%E9%98%B3%E6%9E%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%85%B1%E9%98%B3%E6%9E%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">2、共阳极数码管：​编辑</a></p> 
<p id="3%E3%80%81%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow">3、总体思路：</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0" rel="nofollow">二、静态数码管：         </a></p> 
<p id="%C2%A01%E3%80%81%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A01%E3%80%81%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow"> 1、代码思路：</a></p> 
<p id="2%E3%80%81%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">2、参考代码：</a></p> 
<p id="3%E3%80%81%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89%EF%BC%9A" rel="nofollow">3、参考代码（模块化）：</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A" rel="nofollow">三、动态数码管：</a></p> 
<p id="1%E3%80%81%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow">1、代码思路：</a></p> 
<p id="2%E3%80%81%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">2、参考代码：</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">（1）宏定义函数：</a></p> 
<p id="%EF%BC%882%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">（2）主函数：</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%88%E4%BC%98%E5%8C%96%EF%BC%89%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%88%E4%BC%98%E5%8C%96%EF%BC%89%EF%BC%9A" rel="nofollow">四、动态数码管（优化）：</a></p> 
<p style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%88%E4%B8%AD%E6%96%AD%E6%98%BE%E7%A4%BA%EF%BC%89%EF%BC%9A%EF%BC%88%E5%BB%BA%E8%AE%AE%E5%AD%A6%E4%B9%A0%E8%BF%87%E5%AE%9A%E6%97%B6%E5%99%A8%E5%90%8E%E5%86%8D%E6%9D%A5%E7%9C%8B%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%89" rel="nofollow">五、动态数码管（中断显示）：（建议学习过定时器后再来看以下代码）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86%EF%BC%9A">一、硬件部分：</h2> 
<p></p> 
<h3 id="1%E3%80%81573%E9%94%81%E5%AD%98%E5%99%A8%EF%BC%9A">1、573锁存器：</h3> 
<p><em>如果还不懂可以参考之前的点亮LED灯的文章</em></p> 
<p><a class="has-card" href="https://blog.csdn.net/weixin_63568691/article/details/128431461" title="蓝桥杯模块学习2——LED灯（深夜学习——单片机）_佛科院深夜学习的博客-CSDN博客"><span class="link-card-box"><span class="link-title">蓝桥杯模块学习2——LED灯（深夜学习——单片机）_佛科院深夜学习的博客-CSDN博客</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/c7/fd/FxEiyRHF_o.png">https://blog.csdn.net/weixin_63568691/article/details/128431461</span></span></a></p> 
<h3 id="2%E3%80%81%E5%85%B1%E9%98%B3%E6%9E%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A%E2%80%8B%E7%BC%96%E8%BE%91">2、共阳极数码管：<img alt="" height="611" src="https://images2.imgbox.com/08/de/OBH7Mtnv_o.png" width="1200"></h3> 
<p style="text-align:center;">图1</p> 
<p>（1）其实可以把数码管可以看作多个LED灯组成的电路，每个数字由8个LED组成</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/99/4b/5I2uaI4A_o.png" width="124"></p> 
<p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/36/4c/A2TgdVV9_o.png" width="139"></p> 
<p> </p> 
<p> （2）什么叫共阳极？</p> 
<p>        可以理解为LED灯的一端接了VCC，只需要在另一端输入低电平就能将他点亮</p> 
<p>（3）封装好的共阳极数码管1-F对应的十六进制数：</p> 
<pre><code class="language-cpp">//定义一个数组存放从0-f对应的16进制数
//code 关键字的作用是我定义的数据要存放到ROM区，写入后不可以被改变
//输入16为分隔符号
u8 code transistor_positive[]=
{
	0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,
	0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e,
	0xfd
};
//带小数点
u8 code transistor_positive_point[]=
{
	0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,
	0x00,0x10,0x08,0x03,0x46,0x21,0x06,0x0e
};</code></pre> 
<h3 id="3%E3%80%81%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF%EF%BC%9A">3、总体思路：</h3> 
<p><img alt="" height="198" src="https://images2.imgbox.com/18/e9/GPnawjYi_o.png" width="271">   <img alt="" height="183" src="https://images2.imgbox.com/53/0a/n3ei5ni9_o.png" width="325"></p> 
<p style="text-align:center;">图2</p> 
<p>（1）由图1可知，我们先通过右边com口（位选）选择需要亮的数码管，再通过左边八个口（段选）确定要选择的数字</p> 
<p>（2）由图2可知，单片机通过两个573锁存器控制数码管的位选和段选，只需要按照之前的方法对锁存器进行选择再输入数据即可</p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0">二、静态数码管：         </h2> 
<p>         实现功能：8个数码管分别单独逐次显示1-8，然后所有数码管同时逐次显示0-F        </p> 
<h3 id="%C2%A01%E3%80%81%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%EF%BC%9A"> 1、代码思路：</h3> 
<p>        由上述硬件电路可知只需要选择相应的锁存器和输入相应的数据就行了</p> 
<h3 id="2%E3%80%81%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%EF%BC%9A">2、参考代码：</h3> 
<pre><code class="language-cpp">// 使用程序前，将J13调整为IO模式（2-3脚短接）
#include "reg52.h"
#include "Public.h"

//定义一个数组存放从1-f对应的16进制数
//code 关键字的作用是我定义的数据要存放到ROM区，写入后不可以被改变
u8 code transistor_positive[]=
{
	0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,
	0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e
};
//带小数点
u8 code transistor_positive_point[]=
{
	0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,
	0x00,0x10,0x08,0x03,0x46,0x21,0x06,0x0e
};


void HC138_Y(u8 num);
void Close_All(void);

void main(void)
// 主函数
{
	u8 i;
  while(1)
  { 
		Close_All();
		//8个数码管分别单独逐次显示1-8
		for(i=1;i&lt;=8;i++)
		{
			//改变数据
			HC138_Y(7);
			P0 = transistor_positive[i];
			//改变显示位置
			HC138_Y(6);
			P0 = 0x01&lt;&lt;(i-1);
			Delay_1ms(500);
		}
		//数码管同时逐次显示0-F
		for(i=0;i&lt;16;i++)
		{
			//改变数据
			HC138_Y(7);
			P0 = transistor_positive[i];
			//改变显示位置
			HC138_Y(6);
			P0 = 0xff;
			Delay_1ms(500);
		}
  }
}

/*
	输入变量：4-7
	输出变量：无
	功能：操作138译码器，4-7分别对应Y4-Y7，其余都会使译码器不起作用
*/
void HC138_Y(u8 num)
{
	 switch(num)
	 {
		 case 4:P2 = (P2 &amp; 0x1f) | 0x80;break;
		 case 5:P2 = (P2 &amp; 0x1f) | 0xA0;break;
		 case 6:P2 = (P2 &amp; 0x1f) | 0xC0;break;
		 case 7:P2 = (P2 &amp; 0x1f) | 0xE0;break;
		 default:P2 = (P2 &amp; 0x1f) | 0x00;
	 }
}

/*
	输入变量：无
	输出变量：无
	功能：关闭蜂鸣器和继电器
*/
void Close_All(void)
{
	P2 = (P2 &amp; 0x1f) | 0xA0;
	P0 = 0x00;
}</code></pre> 
<h3 id="3%E3%80%81%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89%EF%BC%9A">3、参考代码（模块化）：</h3> 
<pre><code class="language-cpp">// 使用程序前，将J13调整为IO模式（2-3脚短接）
#include "reg52.h"
#include "Public.h"

//定义一个数组存放从1-f对应的16进制数
//code 关键字的作用是我定义的数据要存放到ROM区，写入后不可以被改变
u8 code transistor_positive[]=
{
	0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,
	0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e
};
//带小数点
u8 code transistor_positive_point[]=
{
	0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,
	0x00,0x10,0x08,0x03,0x46,0x21,0x06,0x0e
};


void HC138_Y(u8 num);
void Close_All(void);
void Transistor_Show(u8 num,u16 PIS);
void main(void)
// 主函数
{
	u8 i;
  while(1)
  { 
		Close_All();
		//8个数码管分别单独逐次显示1-8
		for(i=1;i&lt;=8;i++)
		{
			Transistor_Show(i,0x01&lt;&lt;(i-1));
			Delay_1ms(500);
		}
		//数码管同时逐次显示0-F
		for(i=0;i&lt;16;i++)
		{
			Transistor_Show(i,0xff);
			Delay_1ms(500);
		}
  }
}


/*
	输入变量：num，显示数字；PIS，显示位置
	输出变量：无
	功能：操作138译码器，4-7分别对应Y4-Y7，其余都会使译码器不起作用
	注意：需要把存放从1-f对应的16进制数数组也移植
*/
void Transistor_Show(u8 num,u16 PIS)
{
		//改变数据
		P2 = (P2 &amp; 0x1f) | 0xE0;
		P0 = transistor_positive[num];//需要显示小数点修改这里
		//改变显示位置
		P2 = (P2 &amp; 0x1f) | 0xC0;
		P0 = PIS;
}


/*
	输入变量：4-7
	输出变量：无
	功能：操作138译码器，4-7分别对应Y4-Y7，其余都会使译码器不起作用
*/
void HC138_Y(u8 num)
{
	 switch(num)
	 {
		 case 4:P2 = (P2 &amp; 0x1f) | 0x80;break;
		 case 5:P2 = (P2 &amp; 0x1f) | 0xA0;break;
		 case 6:P2 = (P2 &amp; 0x1f) | 0xC0;break;
		 case 7:P2 = (P2 &amp; 0x1f) | 0xE0;break;
		 default:P2 = (P2 &amp; 0x1f) | 0x00;
	 }
}

/*
	输入变量：无
	输出变量：无
	功能：关闭蜂鸣器和继电器
*/
void Close_All(void)
{
	P2 = (P2 &amp; 0x1f) | 0xA0;
	P0 = 0x00;
}</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%9A">三、动态数码管：</h2> 
<p>         实现功能：前四位显示年份“2022”，接着两位是分隔符“--”,最后两位是月份从一月份开始增加到十二月份，最后循环往复。</p> 
<h3 id="1%E3%80%81%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%EF%BC%9A">1、代码思路：</h3> 
<p>（1）我们如果曾经用过手机照一些分辨率较低屏幕，应该会见到闪烁的屏幕，也就会理解我们最常用的还是是用动态显示思路</p> 
<p>（2）为什么我们一定要用动态显示呢？</p> 
<p>        如果用静态显示思路，那么每个显示部分都有独立的段选端口和独立的位选端口，以我们八位数码管为例：每一位都要八位的段选和一位的位选，一共就需要七十二位，这样就太浪费资源了</p> 
<p>（3）利用人的视觉残留和数码管的余辉效应（1-2ms），我们可以让每个显示部分公用一个段选端口，只需要在极短时间不断改变位选，在人的眼中就会出现八位同时显示的情况</p> 
<h3>2、参考代码：</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%EF%BC%9A">（1）宏定义函数：</h4> 
<pre><code class="language-cpp">#ifndef _PUBLIC_H
#define _PUBLIC_H

#include &lt;reg52.h&gt;

#define u8 unsigned char
#define u16 unsigned int

void Delay_1ms(u16 num);
void Delay_10us(u16 num);
void Close_All(void);
#endif
</code></pre> 
<pre><code class="language-cpp">#include "Public.h"
// 延时函数（最小约1ms@12MHz）
void Delay_1ms(u16 num)
{
  u16  i;
  while(num--)
    for(i=0; i&lt;628; i++);
}

void Delay_10us(u16 num)
{
  u16 i;
  while(num--)
    for(i=0; i&lt;3; i++);
}
/*
	输入变量：无
	输出变量：无
	功能：关闭所有外设
*/
void Close_All(void)
{	
	//关闭蜂鸣器和继电器
	P0 = 0x00;
	P2 = (P2 &amp; 0x1f) | 0xA0;
	P2 &amp;= 0x1f;
	//关闭LED灯
	P0 = 0xff;
	P2 = (P2 &amp; 0x1F) | 0x80;
	P2 &amp;= 0x1f;	
}</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0%EF%BC%9A">（2）主函数：</h4> 
<pre><code class="language-cpp">// 使用程序前，将J13调整为IO模式（2-3脚短接）
#include "reg52.h"
#include "Public.h"

u8 show_content[8]={2,0,2,3,16,16,0,1};

#define divide_num 16
//定义一个数组存放从0-f对应的16进制数
//code 关键字的作用是我定义的数据要存放到ROM区，写入后不可以被改变
//输入16为分隔符号
u8 code transistor_positive[]=
{
	0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,
	0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e,
	0xbf
};
//带小数点
u8 code transistor_positive_point[]=
{
	0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,
	0x00,0x10,0x08,0x03,0x46,0x21,0x06,0x0e
};

void Divide_NUM_16(u16 num,u8 D_num[5]);
void Transistor_Show(u8 num,u16 PIS);
// 主函数
void main(void)
{
	u8 i,temp[5],j,k;
	u16 year = 2023;
	u8 divide = 16;
  u8 month;
	Close_All();
  while(1)
  { 
		month=1;
		//年份
		Divide_NUM_16(year,temp);
		for(i=0;i&lt;4;i++)
			show_content[i] = temp[3-i];
		//分隔符
		for(i=4;i&lt;6;i++)
			show_content[i] = divide_num;
		for(i=0;i&lt;12;i++)
		{
			//月份
			Divide_NUM_16(month,temp);
			for(j=6;j&lt;8;j++)
				show_content[j] = temp[1-(j-6)];
			for(j=0;j&lt;100;j++)
				for(k=0;k&lt;8;k++)
				{
					Transistor_Show(transistor_positive[show_content[k]],k);	
					Delay_1ms(2);
				}
			month++;
		}
  }
}

/*
	输入变量：num,一个小于65535的数;D_num,存放分割好数据的数组
	输出变量：
	功能：将一个小于65535数的每一位分割出来
*/
void Divide_NUM_16(u16 num,u8 D_num[5])
{
	u8 C_MTP = 10;
	u16 D_MTP = 1;
	u8 i;
	for(i=0;i&lt;5;i++)
	{
		D_num[i] = num/D_MTP%C_MTP;
		D_MTP*=10;
	}
}

/*
	输入变量：num，要显示数据；PIS，显示位置,从左到右分别为0-7
	输出变量：无
	功能：操作138译码器，4-7分别对应Y4-Y7，其余都会使译码器不起作用
	注意：需要把存放从1-f对应的16进制数数组也移植
*/
void Transistor_Show(u8 num,u16 PIS)
{
		//改变数据
  	P0 = num;
		P2 = (P2 &amp; 0x1f) | 0xE0;
    P2 &amp;= 0x1f;
		//改变显示位置
  	P0 = 0x01&lt;&lt;PIS;
		P2 = (P2 &amp; 0x1f) | 0xC0;
	  P2 &amp;= 0x1f;
}

</code></pre> 
<p><em>更新：</em></p> 
<p>在学习了其他代码后，感觉到用spritf函数可以极大优化数据处理过程，如果对该函数不了解可以参考以下文章：</p> 
<p><a class="has-card" href="https://blog.csdn.net/weixin_63568691/article/details/128227345?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128227345%22%2C%22source%22%3A%22weixin_63568691%22%7D" title="(1条消息) keil中c语言问题汇总（佛科院——深夜学习）_佛科院深夜学习的博客-CSDN博客"><span class="link-card-box"><span class="link-title">(1条消息) keil中c语言问题汇总（佛科院——深夜学习）_佛科院深夜学习的博客-CSDN博客</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/b8/e3/ww0CiA3B_o.png">https://blog.csdn.net/weixin_63568691/article/details/128227345?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128227345%22%2C%22source%22%3A%22weixin_63568691%22%7D</span></span></a></p> 
<h2 id="%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%88%E4%BC%98%E5%8C%96%EF%BC%89%EF%BC%9A">四、动态数码管（优化）：</h2> 
<pre><code>// 使用程序前，将J13调整为IO模式（2-3脚短接）
#include "reg52.h"
#include "Public.h"
#include "stdio.h"

u8 SEG_COT[9];
u8 SEG_Code[8];

void SEG_TSL(u8 *input,u8 *output);
void SEG_Show(u8 num,u16 PIS);
// 主函数
void main(void)
{
	u8 k,i;
	u16 year = 2023;
	u8 divide = 16;
  u8 month=1;
	Close_All();
  while(1)
  { 
		sprintf(SEG_COT, "%4u--%02u", year,(u16)month);
		SEG_TSL(SEG_COT,SEG_Code);
		for(i=0;i&lt;50;i++)
		{
			for(k=0;k&lt;8;k++)
			{
				SEG_Show(SEG_Code[k],k);	
				Delay_1ms(2);
			}
			Delay_1ms(2);
	  }
		if(month == 12)
			month = 0;
	  month++;

	}
}

/*
	输入变量：num,一个小于65535的数;D_num,存放分割好数据的数组
	输出变量：
	功能：将一个小于65535数的每一位分割出来
*/
void SEG_TSL(u8 *input,u8 *output)
{
	u8 i,temp,j;
	for(i=0;i&lt;8;i++,j++)
	{
		switch(input[j])
		{
			case '0': temp = 0xc0; break;
      case '1': temp = 0xf9; break;
      case '2': temp = 0xa4; break;
      case '3': temp = 0xb0; break;
      case '4': temp = 0x99; break;
      case '5': temp = 0x92; break;
      case '6': temp = 0x82; break;
      case '7': temp = 0xf8; break;
      case '8': temp = 0x80; break;
      case '9': temp = 0x90; break;
      case 'A': temp = 0x88; break;
      case 'B': temp = 0x83; break;
      case 'C': temp = 0xc6; break;
      case 'D': temp = 0xA1; break;
      case 'E': temp = 0x86; break;
      case 'F': temp = 0x8E; break;
      case 'H': temp = 0x89; break;
      case 'L': temp = 0xC7; break;
      case 'N': temp = 0xC8; break;
      case 'P': temp = 0x8c; break;
      case 'U': temp = 0xC1; break;
      case '-': temp = 0xbf; break;
      case ' ': temp = 0xff; break;
      default: temp = 0xff;
		}
		if(input[j+1] == ".")
		{
			temp &amp;= 0x7f;
			j++;
		}
		output[i] = temp;
	}
}

/*
	输入变量：num，要显示数据；PIS，显示位置,从左到右分别为0-7
	输出变量：无
	功能：操作138译码器，4-7分别对应Y4-Y7，其余都会使译码器不起作用
	注意：需要把存放从1-f对应的16进制数数组也移植
*/
void SEG_Show(u8 num,u16 PIS)
{
		//消影
  	P0 = 0xff;
		P2 = (P2 &amp; 0x1f) | 0xE0;
    P2 &amp;= 0x1f;
		//改变显示位置
  	P0 = 0x01&lt;&lt;PIS;
		P2 = (P2 &amp; 0x1f) | 0xC0;
	  P2 &amp;= 0x1f;
		//改变数据
  	P0 = num;
		P2 = (P2 &amp; 0x1f) | 0xE0;
    P2 &amp;= 0x1f;
}

</code></pre> 
<p><em>更新：在使用多个外设的情况下，如果还是按照之前的代码，采用轮询的方法显示，会导致每次显示间隔过长，在学过定时器后，我们可以采用中断的方法显示</em></p> 
<h3 id="%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%EF%BC%88%E4%B8%AD%E6%96%AD%E6%98%BE%E7%A4%BA%EF%BC%89%EF%BC%9A%EF%BC%88%E5%BB%BA%E8%AE%AE%E5%AD%A6%E4%B9%A0%E8%BF%87%E5%AE%9A%E6%97%B6%E5%99%A8%E5%90%8E%E5%86%8D%E6%9D%A5%E7%9C%8B%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%89">五、动态数码管（中断显示）：（建议学习过定时器后再来看以下代码）</h3> 
<pre><code class="language-cpp">// 使用程序前，将J13调整为IO模式（2-3脚短接）
#include "Public.h"
#include "stdio.h"

u8 SEG_COT[9];
u8 SEG_Code[8];
u8 SEF_POS = 0;
u16 count;
void SEG_TSL(u8 *input,u8 *output);
void SEG_Show(u8 num,u16 PIS);
void Timer_0_Init(u16 time);
// 主函数
void main(void)
{
	u16 year = 2023;
  u8 month=1;
	Close_All();
	Timer_0_Init(1000);//1ms
	sprintf(SEG_COT, "%4u--%02u", year,(u16)month);
	SEG_TSL(SEG_COT,SEG_Code);
  while(1)
  { 
		if(count == 1000)//1s
		{
			sprintf(SEG_COT, "%4u--%02u", year,(u16)month);
			SEG_TSL(SEG_COT,SEG_Code);
			if(month == 12)
				month = 0;
			month++; 
			count = 0;
	 }
	}
}
/***************************数码管*****************************/
/*
    输入变量：input,输入字符数组；output：输出16进制数数组
	输出变量：
	功能：将字符串转化为对应数码管显示的16进制数
*/
void SEG_TSL(u8 *input,u8 *output)
{
	u8 i,temp,j;
	for(i=0;i&lt;8;i++,j++)
	{
		switch(input[j])
		{
			case '0': temp = 0xc0; break;
      case '1': temp = 0xf9; break;
      case '2': temp = 0xa4; break;
      case '3': temp = 0xb0; break;
      case '4': temp = 0x99; break;
      case '5': temp = 0x92; break;
      case '6': temp = 0x82; break;
      case '7': temp = 0xf8; break;
      case '8': temp = 0x80; break;
      case '9': temp = 0x90; break;
      case 'A': temp = 0x88; break;
      case 'B': temp = 0x83; break;
      case 'C': temp = 0xc6; break;
      case 'D': temp = 0xA1; break;
      case 'E': temp = 0x86; break;
      case 'F': temp = 0x8E; break;
      case 'H': temp = 0x89; break;
      case 'L': temp = 0xC7; break;
      case 'N': temp = 0xC8; break;
      case 'P': temp = 0x8c; break;
      case 'U': temp = 0xC1; break;
      case '-': temp = 0xbf; break;
      case ' ': temp = 0xff; break;
      default: temp = 0xff;
		}
		if(input[j+1] == ".")
		{
			temp &amp;= 0x7f;
			j++;
		}
		output[i] = temp;
	}
}

/*
	输入变量：num，要显示数据；PIS，显示位置,从左到右分别为0-7
	输出变量：无
	功能：操作138译码器，4-7分别对应Y4-Y7，其余都会使译码器不起作用
	注意：需要把存放从1-f对应的16进制数数组也移植
*/
void SEG_Show(u8 num,u16 PIS)
{
		//消影
  	P0 = 0xff;
		P2 = (P2 &amp; 0x1f) | 0xE0;
    P2 &amp;= 0x1f;
		//改变显示位置
  	P0 = 0x01&lt;&lt;PIS;
		P2 = (P2 &amp; 0x1f) | 0xC0;
	  P2 &amp;= 0x1f;
		//改变数据
  	P0 = num;
		P2 = (P2 &amp; 0x1f) | 0xE0;
    P2 &amp;= 0x1f;
}
/***************************定时器*****************************/
/*
	输入变量：定时时长___us
	输出变量：无
	功能：配置并开启定时器0
*/
void Timer_0_Init(u16 time)
{
	//12T模式
	AUXR &amp;= 0x7f;
	//定时器0 模式0
	TMOD &amp;= 0xf0;
	//设置初值
	TH0 = (65536-time)/256;
	TL0 = (65536-time)%256;
	//打开中断
	ET0 = 1;
	EA = 1;
	//开始计数
	TR0 = 1;
}

void Timer_0_IT(void) interrupt 1
{
	count++;
	SEG_Show(SEG_Code[SEF_POS],SEF_POS);
	if(++SEF_POS == 8)SEF_POS = 0;
}
</code></pre> 
<p><em>更新：进一步模块化</em></p> 
<pre><code class="language-cpp">// 使用程序前，将J13调整为IO模式（2-3脚短接）
#include "Public.h"
#include "stdio.h"

u8 SEG_COT[9];
u8 SEG_Code[8];
u8 SEF_POS = 0;
u16 SEG_delay;
void SEG_TSL(u8 *input,u8 *output);
void SEG_Show(u8 num,u16 PIS);
void Timer_0_Init(u16 time);
void SEG_Proc();
// 主函数
void main(void)
{
	Close_All();
	Timer_0_Init(1000);//1ms
  while(1)
  {
		SEG_Proc();
	}
}

void SEG_Proc()
{
	u16 year = 2023;
  static u8 month=1;
	if(SEG_delay)return;
	SEG_delay = 1;
	
	sprintf(SEG_COT, "%4u--%02u", year,(u16)month);
	SEG_TSL(SEG_COT,SEG_Code);
	if(month == 12)
		month = 0;
	month++; 
}
/***************************数码管*****************************/
/*
  输入变量：input,输入字符数组；output：输出16进制数数组
	输出变量：无
	功能：将字符串转化为对应数码管显示的16进制数
	注意：记得定义数组——u8 SEG_COT[9];u8 SEG_Code[8];
*/
void SEG_TSL(u8 *input,u8 *output)
{
	u8 i=0,temp=0,j=0;
	for(i=0;i&lt;8;i++,j++)
	{
		switch(input[j])
		{
			case '0': temp = 0xc0; break;
      case '1': temp = 0xf9; break;
      case '2': temp = 0xa4; break;
      case '3': temp = 0xb0; break;
      case '4': temp = 0x99; break;
      case '5': temp = 0x92; break;
      case '6': temp = 0x82; break;
      case '7': temp = 0xf8; break;
      case '8': temp = 0x80; break;
      case '9': temp = 0x90; break;
      case 'A': temp = 0x88; break;
      case 'B': temp = 0x83; break;
      case 'C': temp = 0xc6; break;
      case 'D': temp = 0xA1; break;
      case 'E': temp = 0x86; break;
      case 'F': temp = 0x8E; break;
      case 'H': temp = 0x89; break;
      case 'L': temp = 0xC7; break;
      case 'N': temp = 0xC8; break;
      case 'P': temp = 0x8c; break;
      case 'U': temp = 0xC1; break;
      case '-': temp = 0xbf; break;
      case ' ': temp = 0xff; break;
      default: temp = 0xff;
		}
		if(input[j+1] == ".")
		{
			temp &amp;= 0x7f;
			j++;
		}
		output[i] = temp;
	}
}

/*
	输入变量：num，要显示数据；PIS，显示位置,从左到右分别为0-7
	输出变量：无
	功能：操作138译码器，4-7分别对应Y4-Y7，其余都会使译码器不起作用
	注意：需要把存放从1-f对应的16进制数数组也移植
*/
void SEG_Show(u8 num,u16 PIS)
{
		//消影
  	P0 = 0xff;
		P2 = (P2 &amp; 0x1f) | 0xE0;
    P2 &amp;= 0x1f;
		//改变显示位置
  	P0 = 0x01&lt;&lt;PIS;
		P2 = (P2 &amp; 0x1f) | 0xC0;
	  P2 &amp;= 0x1f;
		//改变数据
  	P0 = num;
		P2 = (P2 &amp; 0x1f) | 0xE0;
    P2 &amp;= 0x1f;
}
/***************************定时器*****************************/
/*
	输入变量：定时时长___us
	输出变量：无
	功能：配置并开启定时器0
*/
void Timer_0_Init(u16 time)
{
	//12T模式
	AUXR &amp;= 0x7f;
	//定时器0 模式0
	TMOD &amp;= 0xf0;
	//设置初值
	TH0 = (65536-time)/256;
	TL0 = (65536-time)%256;
	//打开中断
	ET0 = 1;
	EA = 1;
	//开始计数
	TR0 = 1;
}

void Timer_0_IT(void) interrupt 1
{
	if(SEG_delay++ == 1000)SEG_delay = 0;//1s
	
	SEG_Show(SEG_Code[SEF_POS],SEF_POS);
	if(++SEF_POS == 8 )SEF_POS = 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/044960215bc7aeeee4655f2fb361302c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【HBase——陌陌海量存储案例】2. HBase表结构设计（中）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b72474fd84dac777a06ba47af73e643a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hbase股票数据分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>