<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[LUA】元表、元方法、面向对象 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[LUA】元表、元方法、面向对象" />
<meta property="og:description" content="提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、元表二、元方法三、面向对象总结 前言 面试腾讯的时候有问到lua的内容，其中主要集中在热更新和元表、元方法上面，因为踩过了坑所以打算写一篇来记录一下
一、元表
本篇介绍的是元表、元表table是lua中唯一的数据结构，table在我使用来说可以当成很多东西，能够实现类、继承、又能像结构体，table里面能够添加任意元素
t= { a = 10, b = 100, c = &#34;abc&#34; } 这样table就有点像结构体
二、元方法 元方法的存在是为了让我们的元表之间能够相互交互，元方法能够让被赋予的元表之间能够执行特定操作
t = { a = 10, b = 100, c = &#34;abc&#34; } mt = { __add = function(a,b) return a.a &#43; b end, } setmetatable(t, mt) print(t &#43; 2) 其中mt为元方法，setmetatable的方法会将mt中的方法赋予给t元表，这样的话t方法就能够进行操作，这里是lua文档，详细的元方法内容可以看lua文档，在我看来有点像回调，元方法其实是元表，但是在里面写的是函数方法，有需要的元表能够订阅元方法，要注意一点，只有订阅了相同元方法的元表之间才能够相互交互，不然会返回nill或者报错,元表里面还能够在表里面写自己的函数
t = { a = 10, b = 4, c = &#34;abc&#34;, __my = function(a,b) return a &#43; b end } print(t." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ddcc939fc64953ff70fc24de489cba86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-04T18:13:21+08:00" />
<meta property="article:modified_time" content="2022-12-04T18:13:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[LUA】元表、元方法、面向对象</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档</p> 
</blockquote> 
<div> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li>一、元表</li><li>二、元方法</li><li>三、面向对象</li><li><a href="#_45" rel="nofollow">总结</a></li></ul> 
</div> 
<hr> 
<h2><a id="_7"></a>前言</h2> 
<p><font face="monospace">面试腾讯的时候有问到lua的内容，其中主要集中在热更新和元表、元方法上面，因为踩过了坑所以打算写一篇来记录一下</font></p> 
<hr> 
<p><strong style="color:#4f4f4f;font-size:24px;font-weight:bold;">一、元表</strong></p> 
<p>本篇介绍的是元表、元表table是lua中唯一的数据结构，table在我使用来说可以当成很多东西，能够实现类、继承、又能像结构体，table里面能够添加任意元素</p> 
<pre><code>t= {

    a = 10,

    b = 100,

    c = "abc"

}</code></pre> 
<p>这样table就有点像结构体</p> 
<h3>二、元方法</h3> 
<p>元方法的存在是为了让我们的元表之间能够相互交互，元方法能够让被赋予的元表之间能够执行特定操作</p> 
<pre><code>t = {
    a = 10,
    b = 100,
    c = "abc"
}
mt = {
    __add = function(a,b)
        return a.a + b
    end,
}
setmetatable(t, mt)

print(t + 2)</code></pre> 
<p>其中mt为元方法，setmetatable的方法会将mt中的方法赋予给t元表，这样的话t方法就能够进行操作，<a class="link-info" href="https://www.runoob.com/manual/lua53doc/contents.html" rel="nofollow" title="这里是lua文档">这里是lua文档</a>，详细的元方法内容可以看lua文档，在我看来有点像回调，元方法其实是元表，但是在里面写的是函数方法，有需要的元表能够订阅元方法，要注意一点，只有订阅了相同元方法的元表之间才能够相互交互，不然会返回nill或者报错,<span style="color:#38d8f0;">元表里面还能够在表里面写自己的函数</span></p> 
<pre><code class="hljs">t = {
    a = 10,
    b = 4,
    c = "abc",
    __my = function(a,b)
        return a + b
    end
}
print(t.__my(t.a,t.b))</code></pre> 
<h3>个人见解</h3> 
<p>lua在我的认知里面是一种调用者的角色，因为lua作为脚本语言最大的特色是不需要进行编译的过程，因此每次修改都不需要重新执行一次，这个特性在已经上架了的游戏来说十分重要，线上的项目每次修改都需要重新经过审核，调用lua之后不需要编译的特性省去了很多麻烦，需要修改bug上传资源都不需要重新经过审核，而在实际开发中可以让lua调用C#等文件，可以理解为C#脚本编写了对应的功能，再用lua去组合调用，结合不需要编译能省去很多调试的时间.</p> 
<h3>三、面向对象</h3> 
<p>上面我们讲了元表和元方法，我们将元表视为对象，而我们在元方法中编写函数，将元方法赋予对象即可完成面向对象，先上例子</p> 
<pre><code class="hljs">bag = {}
bagmt = {--元方法
    put = function(t,item)
        table.insert(t.items,item)
    end,
    take = function(t)
        return table.remove(t.items,item)
    end,
    list = function(t)
        return table.concat(t.items,",")
    end,
    clear = function(t)
        t.items = {}
    end,
}
bagmt["__index"] = bagmt--这里是将index元方法赋予自己，作用是调用不存在的函数时会在bagmt里找
function  bag.new()--构造函数
    local t = {
        items = {}
    }
    setmetatable(t,bagmt)
    return t
end
local b = bag.new()
b:put("apple")
b:put(666)
b:put(1)
print(b:list())
</code></pre> 
<h3></h3> 
<p><a id="_45"></a>这里可以看出编写了构造函数之后，在构造函数里面对构造的元表赋予元方法之后该表就成了对象，就能完成面向对象操作，笔者之前是学c++的，在这里就会发现其实在构造函数这一块比较相同，就是构造函数如果是最初的父类那么还是要在里面编写函数，但lua的话是在外面写完之后再赋予，结果上来说是相同的。</p> 
<p>如果需要对象之间相互交互<span style="color:#ffd900;">就可能需要源自同一构造函数，</span><span style="color:#0d0016;">再编写对应的元方法。</span></p> 
<h2>总结</h2> 
<p>在我看来元表是lua唯一数据结构，但这个数据结构能够作为类、结构体，在元方法调用之后还能够赋予对应的操作函数，从而达到将元表作为对象操作，达到面向对象的操作。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a573cef007c17686817c9cf75666067f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网站实现变灰</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb6a5bf374c46506b05f46ba0a34135c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3element如何通过表格外的按钮来控制表格内部的所有状态全选全不选</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>