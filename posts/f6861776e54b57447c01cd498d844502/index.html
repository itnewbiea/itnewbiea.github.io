<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#编程，异步中的等待处理Task.Delay - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#编程，异步中的等待处理Task.Delay" />
<meta property="og:description" content="一、总结 1.Task.Delay实质是创建一个任务，再任务中开启一个定时间，然后延时指定的时间
2.Task.Delay不和await一起使用情况，当代码遇到Task.Delay一句时，创建了了一个新的任务去执行延时去了，当前代码继续往下执行
3.Task.Delay和await一起使用，当代码遇到await Task.Delay时候，当前线程要等该行代码执行完成后，再继续执行后面的代码
4、Thread.Sleep 是同步延迟，Task.Delay异步延迟。
5、Thread.Sleep 会阻塞线程，Task.Delay不会。
6、Thread.Sleep不能取消，Task.Delay可以。
7、Task.Delay() 比 Thread.Sleep() 消耗更多的资源，但是Task.Delay()可用于为方法返回Task类型；或者根据CancellationToken取消标记动态取消等待
8、Task.Delay() 实质创建一个运行给定时间的任务， Thread.Sleep() 使当前线程休眠给定时间。
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; using System.Windows.Forms; namespace _006__Task.Delay { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void btnDelayNoAwait_Click(object sender, EventArgs e) { Task task = Task.Factory.StartNew(() =&gt; { Console.WriteLine($&#34; Task.Delay开始：{DateTime.Now.ToString(&#34; HH:mm:ss.fff&#34;)}&#34;); for (int i = 0; i &lt; 10; i&#43;&#43;) { Console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f6861776e54b57447c01cd498d844502/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-10T15:20:27+08:00" />
<meta property="article:modified_time" content="2023-02-10T15:20:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#编程，异步中的等待处理Task.Delay</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、总结</h4> 
<p>1.Task.Delay实质是创建一个任务，再任务中开启一个定时间，然后延时指定的时间<br> 2.Task.Delay不和await一起使用情况，当代码遇到Task.Delay一句时，创建了了一个新的任务去执行延时去了，当前代码继续往下执行<br> 3.Task.Delay和await一起使用，当代码遇到await Task.Delay时候，当前线程要等该行代码执行完成后，再继续执行后面的代码</p> 
<p>4、Thread.Sleep 是同步延迟，Task.Delay异步延迟。<br> 5、Thread.Sleep 会阻塞线程，Task.Delay不会。<br> 6、Thread.Sleep不能取消，Task.Delay可以。<br> 7、Task.Delay() 比 Thread.Sleep() 消耗更多的资源，但是Task.Delay()可用于为方法返回Task类型；或者根据CancellationToken取消标记动态取消等待<br> 8、Task.Delay() 实质创建一个运行给定时间的任务， Thread.Sleep() 使当前线程休眠给定时间。</p> 
<p><img alt="" src="https://images2.imgbox.com/ff/ee/pNCncX4C_o.png"></p> 
<p> </p> 
<pre><code class="hljs">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace _006__Task.Delay
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void btnDelayNoAwait_Click(object sender, EventArgs e)
        {
            Task task = Task.Factory.StartNew(() =&gt;
            {
                Console.WriteLine($" Task.Delay开始：{DateTime.Now.ToString(" HH:mm:ss.fff")}");
                for (int i = 0; i &lt; 10; i++)
                {
                    Console.WriteLine($" {DateTime.Now.ToString("HH:mm:ss.fff")} 正在进行：{i}");
                    Task.Delay(2000);
                }
                Console.WriteLine($" Task.Delay结束：{DateTime.Now.ToString("HH:mm:ss.fff")}");
                Console.ReadKey();
            });

        }

        private void btnDelayHaveAwait_Click(object sender, EventArgs e)
        {
            Task task = Task.Factory.StartNew(async () =&gt;
            {
                Console.WriteLine($" Task.Delay 有await 开始：{DateTime.Now.ToString("HH:mm:ss.fff")}");
                for (int i = 0; i &lt; 10; i++)
                {
                    Console.WriteLine($" {DateTime.Now.ToString("HH:mm:ss.fff")} 有await正在进行：{i}");
                    await Task.Delay(2000);
                }
                Console.WriteLine($" Task.Delay 有await 结束：{DateTime.Now.ToString("HH:mm:ss.fff")}");
                Console.ReadKey();
            });
        }

        private void btnThreadSleep_Click(object sender, EventArgs e)
        {
            Task task = Task.Factory.StartNew(() =&gt;
           {
               Console.WriteLine($" Task.Delay 有await 开始：{DateTime.Now.ToString("HH:mm:ss.fff")}");
               for (int i = 0; i &lt; 10; i++)
               {
                   Console.WriteLine($" {DateTime.Now.ToString("HH:mm:ss.fff")} 有await正在进行：{i}");
                   Thread.Sleep(2000);
               }
               Console.WriteLine($" Task.Delay 有await 结束：{DateTime.Now.ToString("HH:mm:ss.fff")}");
               Console.ReadKey();
           });
        }
    }
}
</code></pre> 
<p>按钮【Task.Delay(不带await)】执行结果：</p> 
<p>当程序遇到 Task.Delay(2000);时候，程序创建一个新的任务去执行延时2000了，当前任务继续向下执行，所以看起来并没有延时2秒的现象。</p> 
<p>例如：你只有先写完作业，然后才能看电视。但是到写作业的时候，你让其他人帮你写(开启新的任务去执行延时)，你继续去看电视(继续当前任务)。</p> 
<p><img alt="" src="https://images2.imgbox.com/f3/5e/qX6U6Hme_o.png"></p> 
<p> </p> 
<p>钮【Task.Delay(带await)】执行结果（推荐）：</p> 
<p>当程序遇到 await Task.Delay(2000);时候，当前任务，要等到新创建的任务执行完延时2000后，才继续后面的代码<br> 例如：你只有先写完作业，然后才能看电视。但是到写作业的时候，你mother在旁边看着你，直到你写完作业(开启新的任务去执行延时)，你才可以继续去看电视(继续当前任务)。</p> 
<p><img alt="" src="https://images2.imgbox.com/27/48/cDhsR1u8_o.png"></p> 
<p>按钮【Thread.Sleep()】执行结果(不推荐)：</p> 
<p>Thread.Sleep 是让当前线程休眠指定的时间。在异步中是不推荐使用Thread.Sleep 的。<br> 因为Task.Delay 多开一个线程所以消耗更多，然而实际使用中一般用Task.Delay，因为高并发不希望线程堵塞，而且Task.Delay 可以取消</p> 
<p><img alt="" src="https://images2.imgbox.com/3d/50/tt5Ig4qg_o.png"></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9bbdc490509268b741b589139e35ff24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基础篇（二）：内存屏障是什么</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0e6cd1c7a8dd48c78a3ff3b36f8b7713/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js去掉所有的html 标签（正则）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>