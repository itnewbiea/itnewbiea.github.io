<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android  ScrollView 嵌套RecyclerView 解决滑动冲突 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android  ScrollView 嵌套RecyclerView 解决滑动冲突" />
<meta property="og:description" content="为了解决滑动事件的冲突需要重写ScrollView /* * Copyright 2014 Soichiro Kashima * * Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &#34;AS IS&#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/dc70d2271e154d739de48ad79cad5776/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-30T09:57:17+08:00" />
<meta property="article:modified_time" content="2016-09-30T09:57:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android  ScrollView 嵌套RecyclerView 解决滑动冲突</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>为了解决滑动事件的冲突需要重写ScrollView </p> 
<p></p> 
<pre style="font-family:宋体; font-size:9.6pt; background-color:rgb(255,255,255)"><span style="color:#808080"><em>/*
</em></span><span style="color:#808080"><em> * Copyright 2014 Soichiro Kashima
</em></span><span style="color:#808080"><em> *
</em></span><span style="color:#808080"><em> * Licensed under the Apache License, Version 2.0 (the "License");
</em></span><span style="color:#808080"><em> * you may not use this file except in compliance with the License.
</em></span><span style="color:#808080"><em> * You may obtain a copy of the License at
</em></span><span style="color:#808080"><em> *
</em></span><span style="color:#808080"><em> *     http://www.apache.org/licenses/LICENSE-2.0
</em></span><span style="color:#808080"><em> *
</em></span><span style="color:#808080"><em> * Unless required by applicable law or agreed to in writing, software
</em></span><span style="color:#808080"><em> * distributed under the License is distributed on an "AS IS" BASIS,
</em></span><span style="color:#808080"><em> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</em></span><span style="color:#808080"><em> * See the License for the specific language governing permissions and
</em></span><span style="color:#808080"><em> * limitations under the License.
</em></span><span style="color:#808080"><em> */
</em></span><span style="color:#808080"><em>
</em></span><span style="color:#000080"><strong>package </strong></span>observablescrollview;

<span style="color:#000080"><strong>import </strong></span>android.content.Context;
<span style="color:#000080"><strong>import </strong></span>android.os.Parcel;
<span style="color:#000080"><strong>import </strong></span>android.os.Parcelable;
<span style="color:#000080"><strong>import </strong></span>android.util.AttributeSet;
<span style="color:#000080"><strong>import </strong></span>android.view.MotionEvent;
<span style="color:#000080"><strong>import </strong></span>android.view.View;
<span style="color:#000080"><strong>import </strong></span>android.view.ViewConfiguration;
<span style="color:#000080"><strong>import </strong></span>android.view.ViewGroup;
<span style="color:#000080"><strong>import </strong></span>android.widget.ScrollView;

<span style="color:#000080"><strong>import </strong></span>java.util.ArrayList;
<span style="color:#000080"><strong>import </strong></span>java.util.List;

<span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em> * ScrollView that its scroll position can be observed.
</em></span><span style="color:#808080"><em> */
</em></span><span style="color:#000080"><strong>public class </strong></span>ObservableScrollView <span style="color:#000080"><strong>extends </strong></span>ScrollView <span style="color:#000080"><strong>implements </strong></span>Scrollable {

    <span style="color:#808080"><em>// Fields that should be saved onSaveInstanceState
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#000080"><strong>private int </strong></span><span style="color:#660e7a"><strong>mPrevScrollY</strong></span>;
    <span style="color:#000080"><strong>private int </strong></span><span style="color:#660e7a"><strong>mScrollY</strong></span>;

    <span style="color:#808080"><em>// Fields that don't need to be saved onSaveInstanceState
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#000080"><strong>private </strong></span>ObservableScrollViewCallbacks <span style="color:#660e7a"><strong>mCallbacks</strong></span>;
    <span style="color:#000080"><strong>private </strong></span>List&lt;ObservableScrollViewCallbacks&gt; <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>;
    <span style="color:#000080"><strong>private </strong></span>ScrollState <span style="color:#660e7a"><strong>mScrollState</strong></span>;
    <span style="color:#000080"><strong>private boolean </strong></span><span style="color:#660e7a"><strong>mFirstScroll</strong></span>;
    <span style="color:#000080"><strong>private boolean </strong></span><span style="color:#660e7a"><strong>mDragging</strong></span>;
    <span style="color:#000080"><strong>private boolean </strong></span><span style="color:#660e7a"><strong>mIntercepted</strong></span>;
    <span style="color:#000080"><strong>private </strong></span>MotionEvent <span style="color:#660e7a"><strong>mPrevMoveEvent</strong></span>;
    <span style="color:#000080"><strong>private </strong></span>ViewGroup <span style="color:#660e7a"><strong>mTouchInterceptionViewGroup</strong></span>;

    <span style="color:#000080"><strong>public void </strong></span>setViewMove(<span style="color:#000080"><strong>boolean </strong></span>viewMove) {
        <span style="color:#660e7a"><strong>isViewMove </strong></span>= viewMove;
    }

    <span style="color:#000080"><strong>private boolean </strong></span><span style="color:#660e7a"><strong>isViewMove</strong></span>=<span style="color:#000080"><strong>true</strong></span>;
    <span style="color:#000080"><strong>private int </strong></span><span style="color:#660e7a"><strong>downX</strong></span>;
    <span style="color:#000080"><strong>private int </strong></span><span style="color:#660e7a"><strong>downY</strong></span>;
    <span style="color:#000080"><strong>private int </strong></span><span style="color:#660e7a"><strong>mTouchSlop</strong></span>;

    <span style="color:#000080"><strong>public </strong></span>ObservableScrollView(Context context) {
        <span style="color:#000080"><strong>super</strong></span>(context);
        <span style="color:#660e7a"><strong>mTouchSlop </strong></span>= ViewConfiguration.<span style="font-style:italic">get</span>(context).getScaledTouchSlop();
    }

    <span style="color:#000080"><strong>public </strong></span>ObservableScrollView(Context context, AttributeSet attrs) {
        <span style="color:#000080"><strong>super</strong></span>(context, attrs);
        <span style="color:#660e7a"><strong>mTouchSlop </strong></span>= ViewConfiguration.<span style="font-style:italic">get</span>(context).getScaledTouchSlop();
    }

    <span style="color:#000080"><strong>public </strong></span>ObservableScrollView(Context context, AttributeSet attrs, <span style="color:#000080"><strong>int </strong></span>defStyle) {
        <span style="color:#000080"><strong>super</strong></span>(context, attrs, defStyle);
        <span style="color:#660e7a"><strong>mTouchSlop </strong></span>= ViewConfiguration.<span style="font-style:italic">get</span>(context).getScaledTouchSlop();
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public void </strong></span>onRestoreInstanceState(Parcelable state) {
        SavedState ss = (SavedState) state;
        <span style="color:#660e7a"><strong>mPrevScrollY </strong></span>= ss.<span style="color:#660e7a"><strong>prevScrollY</strong></span>;
        <span style="color:#660e7a"><strong>mScrollY </strong></span>= ss.<span style="color:#660e7a"><strong>scrollY</strong></span>;
        <span style="color:#000080"><strong>super</strong></span>.onRestoreInstanceState(ss.getSuperState());
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public </strong></span>Parcelable onSaveInstanceState() {
        Parcelable superState = <span style="color:#000080"><strong>super</strong></span>.onSaveInstanceState();
        SavedState ss = <span style="color:#000080"><strong>new </strong></span>SavedState(superState);
        ss.<span style="color:#660e7a"><strong>prevScrollY </strong></span>= <span style="color:#660e7a"><strong>mPrevScrollY</strong></span>;
        ss.<span style="color:#660e7a"><strong>scrollY </strong></span>= <span style="color:#660e7a"><strong>mScrollY</strong></span>;
        <span style="color:#000080"><strong>return </strong></span>ss;
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>protected void </strong></span>onScrollChanged(<span style="color:#000080"><strong>int </strong></span>l, <span style="color:#000080"><strong>int </strong></span>t, <span style="color:#000080"><strong>int </strong></span>oldl, <span style="color:#000080"><strong>int </strong></span>oldt) {
        <span style="color:#000080"><strong>super</strong></span>.onScrollChanged(l, t, oldl, oldt);
        <span style="color:#000080"><strong>if </strong></span>(hasNoCallbacks()) {
            <span style="color:#000080"><strong>return</strong></span>;
        }
        <span style="color:#660e7a"><strong>mScrollY </strong></span>= t;

        dispatchOnScrollChanged(t, <span style="color:#660e7a"><strong>mFirstScroll</strong></span>, <span style="color:#660e7a"><strong>mDragging</strong></span>);
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mFirstScroll</strong></span>) {
            <span style="color:#660e7a"><strong>mFirstScroll </strong></span>= <span style="color:#000080"><strong>false</strong></span>;
        }

        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mPrevScrollY </strong></span>&lt; t) {
            <span style="color:#660e7a"><strong>mScrollState </strong></span>= ScrollState.<span style="color:#660e7a"><strong><em>UP</em></strong></span>;
        } <span style="color:#000080"><strong>else if </strong></span>(t &lt; <span style="color:#660e7a"><strong>mPrevScrollY</strong></span>) {
            <span style="color:#660e7a"><strong>mScrollState </strong></span>= ScrollState.<span style="color:#660e7a"><strong><em>DOWN</em></strong></span>;
            <span style="color:#808080"><em>//} else {
</em></span><span style="color:#808080"><em>            // Keep previous state while dragging.
</em></span><span style="color:#808080"><em>            // Never makes it STOP even if scrollY not changed.
</em></span><span style="color:#808080"><em>            // Before Android 4.4, onTouchEvent calls onScrollChanged directly for ACTION_MOVE,
</em></span><span style="color:#808080"><em>            // which makes mScrollState always STOP when onUpOrCancelMotionEvent is called.
</em></span><span style="color:#808080"><em>            // STOP state is now meaningless for ScrollView.
</em></span><span style="color:#808080"><em>        </em></span>}
        <span style="color:#660e7a"><strong>mPrevScrollY </strong></span>= t;
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public boolean </strong></span>onInterceptTouchEvent(MotionEvent ev) {
        <span style="color:#000080"><strong>if </strong></span>(hasNoCallbacks()) {
            <span style="color:#000080"><strong>return super</strong></span>.onInterceptTouchEvent(ev);
        }
        <span style="color:#000080"><strong>switch </strong></span>(ev.getActionMasked()) {
            <span style="color:#000080"><strong>case </strong></span>MotionEvent.<span style="color:#660e7a"><strong><em>ACTION_DOWN</em></strong></span>:
                <span style="color:#808080"><em>// Whether or not motion events are consumed by children,
</em></span><span style="color:#808080"><em>                // flag initializations which are related to ACTION_DOWN events should be executed.
</em></span><span style="color:#808080"><em>                // Because if the ACTION_DOWN is consumed by children and only ACTION_MOVEs are
</em></span><span style="color:#808080"><em>                // passed to parent (this view), the flags will be invalid.
</em></span><span style="color:#808080"><em>                // Also, applications might implement initialization codes to onDownMotionEvent,
</em></span><span style="color:#808080"><em>                // so call it here.
</em></span><span style="color:#808080"><em>                </em></span><span style="color:#660e7a"><strong>downX </strong></span>= (<span style="color:#000080"><strong>int</strong></span>) ev.getRawX();
                <span style="color:#660e7a"><strong>downY </strong></span>= (<span style="color:#000080"><strong>int</strong></span>) ev.getRawY();
                <span style="color:#660e7a"><strong>mFirstScroll </strong></span>= <span style="color:#660e7a"><strong>mDragging </strong></span>= <span style="color:#000080"><strong>true</strong></span>;
                dispatchOnDownMotionEvent();
                <span style="color:#000080"><strong>break</strong></span>;
            <span style="color:#000080"><strong>case </strong></span>MotionEvent.<span style="color:#660e7a"><strong><em>ACTION_MOVE</em></strong></span>:
                <span style="color:#000080"><strong>if</strong></span>(!<span style="color:#660e7a"><strong>isViewMove</strong></span>){
                    <span style="color:#000080"><strong>int </strong></span>moveY = (<span style="color:#000080"><strong>int</strong></span>) ev.getRawY();
                    <span style="color:#000080"><strong>if </strong></span>(Math.<span style="font-style:italic">abs</span>(moveY - <span style="color:#660e7a"><strong>downY</strong></span>) &gt; <span style="color:#660e7a"><strong>mTouchSlop</strong></span>) {
                        <span style="color:#000080"><strong>return true</strong></span>;
                    }
                }

        }
        <span style="color:#000080"><strong>return super</strong></span>.onInterceptTouchEvent(ev);
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public boolean </strong></span>onTouchEvent(MotionEvent ev) {
        <span style="color:#000080"><strong>if </strong></span>(hasNoCallbacks()) {
            <span style="color:#000080"><strong>return super</strong></span>.onTouchEvent(ev);
        }
        <span style="color:#000080"><strong>switch </strong></span>(ev.getActionMasked()) {
            <span style="color:#000080"><strong>case </strong></span>MotionEvent.<span style="color:#660e7a"><strong><em>ACTION_UP</em></strong></span>:
            <span style="color:#000080"><strong>case </strong></span>MotionEvent.<span style="color:#660e7a"><strong><em>ACTION_CANCEL</em></strong></span>:
                <span style="color:#660e7a"><strong>mIntercepted </strong></span>= <span style="color:#000080"><strong>false</strong></span>;
                <span style="color:#660e7a"><strong>mDragging </strong></span>= <span style="color:#000080"><strong>false</strong></span>;
                dispatchOnUpOrCancelMotionEvent(<span style="color:#660e7a"><strong>mScrollState</strong></span>);
                <span style="color:#000080"><strong>break</strong></span>;
            <span style="color:#000080"><strong>case </strong></span>MotionEvent.<span style="color:#660e7a"><strong><em>ACTION_MOVE</em></strong></span>:
                <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mPrevMoveEvent </strong></span>== <span style="color:#000080"><strong>null</strong></span>) {
                    <span style="color:#660e7a"><strong>mPrevMoveEvent </strong></span>= ev;
                }
                <span style="color:#000080"><strong>float </strong></span>diffY = ev.getY() - <span style="color:#660e7a"><strong>mPrevMoveEvent</strong></span>.getY();
                <span style="color:#660e7a"><strong>mPrevMoveEvent </strong></span>= MotionEvent.<span style="font-style:italic">obtainNoHistory</span>(ev);
                <span style="color:#000080"><strong>if </strong></span>(getCurrentScrollY() - diffY &lt;= <span style="color:#0000ff">0</span>) {
                    <span style="color:#808080"><em>// Can't scroll anymore.
</em></span><span style="color:#808080"><em>
</em></span><span style="color:#808080"><em>                    </em></span><span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mIntercepted</strong></span>) {
                        <span style="color:#808080"><em>// Already dispatched ACTION_DOWN event to parents, so stop here.
</em></span><span style="color:#808080"><em>                        </em></span><span style="color:#000080"><strong>return false</strong></span>;
                    }

                    <span style="color:#808080"><em>// Apps can set the interception target other than the direct parent.
</em></span><span style="color:#808080"><em>                    </em></span><span style="color:#000080"><strong>final </strong></span>ViewGroup parent;
                    <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mTouchInterceptionViewGroup </strong></span>== <span style="color:#000080"><strong>null</strong></span>) {
                        parent = (ViewGroup) getParent();
                    } <span style="color:#000080"><strong>else </strong></span>{
                        parent = <span style="color:#660e7a"><strong>mTouchInterceptionViewGroup</strong></span>;
                    }

                    <span style="color:#808080"><em>// Get offset to parents. If the parent is not the direct parent,
</em></span><span style="color:#808080"><em>                    // we should aggregate offsets from all of the parents.
</em></span><span style="color:#808080"><em>                    </em></span><span style="color:#000080"><strong>float </strong></span>offsetX = <span style="color:#0000ff">0</span>;
                    <span style="color:#000080"><strong>float </strong></span>offsetY = <span style="color:#0000ff">0</span>;
                    <span style="color:#000080"><strong>for </strong></span>(View v = <span style="color:#000080"><strong>this</strong></span>; v != <span style="color:#000080"><strong>null </strong></span>&amp;&amp; v != parent; v = (View) v.getParent()) {
                        offsetX += v.getLeft() - v.getScrollX();
                        offsetY += v.getTop() - v.getScrollY();
                    }
                    <span style="color:#000080"><strong>final </strong></span>MotionEvent event = MotionEvent.<span style="font-style:italic">obtainNoHistory</span>(ev);
                    event.offsetLocation(offsetX, offsetY);

                    <span style="color:#000080"><strong>if </strong></span>(parent.onInterceptTouchEvent(event)) {
                        <span style="color:#660e7a"><strong>mIntercepted </strong></span>= <span style="color:#000080"><strong>true</strong></span>;

                        <span style="color:#808080"><em>// If the parent wants to intercept ACTION_MOVE events,
</em></span><span style="color:#808080"><em>                        // we pass ACTION_DOWN event to the parent
</em></span><span style="color:#808080"><em>                        // as if these touch events just have began now.
</em></span><span style="color:#808080"><em>                        </em></span>event.setAction(MotionEvent.<span style="color:#660e7a"><strong><em>ACTION_DOWN</em></strong></span>);

                        <span style="color:#808080"><em>// Return this onTouchEvent() first and set ACTION_DOWN event for parent
</em></span><span style="color:#808080"><em>                        // to the queue, to keep events sequence.
</em></span><span style="color:#808080"><em>                        </em></span>post(<span style="color:#000080"><strong>new </strong></span>Runnable() {
                            <span style="color:#808000">@Override
</span><span style="color:#808000">                            </span><span style="color:#000080"><strong>public void </strong></span>run() {
                                <span style="color:#660e7a">parent</span>.dispatchTouchEvent(<span style="color:#660e7a">event</span>);
                            }
                        });
                        <span style="color:#000080"><strong>return false</strong></span>;
                    }
                    <span style="color:#808080"><em>// Even when this can't be scrolled anymore,
</em></span><span style="color:#808080"><em>                    // simply returning false here may cause subView's click,
</em></span><span style="color:#808080"><em>                    // so delegate it to super.
</em></span><span style="color:#808080"><em>                    </em></span><span style="color:#000080"><strong>return super</strong></span>.onTouchEvent(ev);
                }
                <span style="color:#000080"><strong>break</strong></span>;
        }
        <span style="color:#000080"><strong>return super</strong></span>.onTouchEvent(ev);
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public void </strong></span>setScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        <span style="color:#660e7a"><strong>mCallbacks </strong></span>= listener;
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public void </strong></span>addScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbackCollection </strong></span>== <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#660e7a"><strong>mCallbackCollection </strong></span>= <span style="color:#000080"><strong>new </strong></span>ArrayList&lt;&gt;();
        }
        <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.add(listener);
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public void </strong></span>removeScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbackCollection </strong></span>!= <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.remove(listener);
        }
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public void </strong></span>clearScrollViewCallbacks() {
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbackCollection </strong></span>!= <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.clear();
        }
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public void </strong></span>setTouchInterceptionViewGroup(ViewGroup viewGroup) {
        <span style="color:#660e7a"><strong>mTouchInterceptionViewGroup </strong></span>= viewGroup;
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public void </strong></span>scrollVerticallyTo(<span style="color:#000080"><strong>int </strong></span>y) {
        scrollTo(<span style="color:#0000ff">0</span>, y);
    }

    <span style="color:#808000">@Override
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>public int </strong></span>getCurrentScrollY() {
        <span style="color:#000080"><strong>return </strong></span><span style="color:#660e7a"><strong>mScrollY</strong></span>;
    }

    <span style="color:#000080"><strong>private void </strong></span>dispatchOnDownMotionEvent() {
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbacks </strong></span>!= <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#660e7a"><strong>mCallbacks</strong></span>.onDownMotionEvent();
        }
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbackCollection </strong></span>!= <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#000080"><strong>for </strong></span>(<span style="color:#000080"><strong>int </strong></span>i = <span style="color:#0000ff">0</span>; i &lt; <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.size(); i++) {
                ObservableScrollViewCallbacks callbacks = <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.get(i);
                callbacks.onDownMotionEvent();
            }
        }
    }

    <span style="color:#000080"><strong>private void </strong></span>dispatchOnScrollChanged(<span style="color:#000080"><strong>int </strong></span>scrollY, <span style="color:#000080"><strong>boolean </strong></span>firstScroll, <span style="color:#000080"><strong>boolean </strong></span>dragging) {
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbacks </strong></span>!= <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#660e7a"><strong>mCallbacks</strong></span>.onScrollChanged(scrollY, firstScroll, dragging);
        }
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbackCollection </strong></span>!= <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#000080"><strong>for </strong></span>(<span style="color:#000080"><strong>int </strong></span>i = <span style="color:#0000ff">0</span>; i &lt; <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.size(); i++) {
                ObservableScrollViewCallbacks callbacks = <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.get(i);
                callbacks.onScrollChanged(scrollY, firstScroll, dragging);
            }
        }
    }

    <span style="color:#000080"><strong>private void </strong></span>dispatchOnUpOrCancelMotionEvent(ScrollState scrollState) {
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbacks </strong></span>!= <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#660e7a"><strong>mCallbacks</strong></span>.onUpOrCancelMotionEvent(scrollState);
        }
        <span style="color:#000080"><strong>if </strong></span>(<span style="color:#660e7a"><strong>mCallbackCollection </strong></span>!= <span style="color:#000080"><strong>null</strong></span>) {
            <span style="color:#000080"><strong>for </strong></span>(<span style="color:#000080"><strong>int </strong></span>i = <span style="color:#0000ff">0</span>; i &lt; <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.size(); i++) {
                ObservableScrollViewCallbacks callbacks = <span style="color:#660e7a"><strong>mCallbackCollection</strong></span>.get(i);
                callbacks.onUpOrCancelMotionEvent(scrollState);
            }
        }
    }

    <span style="color:#000080"><strong>private boolean </strong></span>hasNoCallbacks() {
        <span style="color:#000080"><strong>return </strong></span><span style="color:#660e7a"><strong>mCallbacks </strong></span>== <span style="color:#000080"><strong>null </strong></span>&amp;&amp; <span style="color:#660e7a"><strong>mCallbackCollection </strong></span>== <span style="color:#000080"><strong>null</strong></span>;
    }

    <span style="color:#000080"><strong>static class </strong></span>SavedState <span style="color:#000080"><strong>extends </strong></span>BaseSavedState {
        <span style="color:#000080"><strong>int </strong></span><span style="color:#660e7a"><strong>prevScrollY</strong></span>;
        <span style="color:#000080"><strong>int </strong></span><span style="color:#660e7a"><strong>scrollY</strong></span>;

        <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>         * Called by onSaveInstanceState.
</em></span><span style="color:#808080"><em>         */
</em></span><span style="color:#808080"><em>        </em></span>SavedState(Parcelable superState) {
            <span style="color:#000080"><strong>super</strong></span>(superState);
        }

        <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>         * Called by CREATOR.
</em></span><span style="color:#808080"><em>         */
</em></span><span style="color:#808080"><em>        </em></span><span style="color:#000080"><strong>private </strong></span>SavedState(Parcel in) {
            <span style="color:#000080"><strong>super</strong></span>(in);
            <span style="color:#660e7a"><strong>prevScrollY </strong></span>= in.readInt();
            <span style="color:#660e7a"><strong>scrollY </strong></span>= in.readInt();
        }

        <span style="color:#808000">@Override
</span><span style="color:#808000">        </span><span style="color:#000080"><strong>public void </strong></span>writeToParcel(Parcel out, <span style="color:#000080"><strong>int </strong></span>flags) {
            <span style="color:#000080"><strong>super</strong></span>.writeToParcel(out, flags);
            out.writeInt(<span style="color:#660e7a"><strong>prevScrollY</strong></span>);
            out.writeInt(<span style="color:#660e7a"><strong>scrollY</strong></span>);
        }

        <span style="color:#000080"><strong>public static final </strong></span>Creator&lt;SavedState&gt; <span style="color:#660e7a"><strong><em>CREATOR
</em></strong></span><span style="color:#660e7a"><strong><em>            </em></strong></span>= <span style="color:#000080"><strong>new </strong></span>Creator&lt;SavedState&gt;() {
            <span style="color:#808000">@Override
</span><span style="color:#808000">            </span><span style="color:#000080"><strong>public </strong></span>SavedState createFromParcel(Parcel in) {
                <span style="color:#000080"><strong>return new </strong></span>SavedState(in);
            }

            <span style="color:#808000">@Override
</span><span style="color:#808000">            </span><span style="color:#000080"><strong>public </strong></span>SavedState[] newArray(<span style="color:#000080"><strong>int </strong></span>size) {
                <span style="color:#000080"><strong>return new </strong></span>SavedState[size];
            }
        };
    }
}
</pre> 
<br> 
<p></p> 
<p>上面的是修改的 ScrollView，为了监听滑动的位置，和解决冲突。可以有效的解决RecyclerView 不需要滑动的冲突。贴上接口</p> 
<p></p> 
<pre style="font-family:宋体; font-size:9.6pt; background-color:rgb(255,255,255)"><span style="color:#808080"><em>/*
</em></span><span style="color:#808080"><em> * Copyright 2014 Soichiro Kashima
</em></span><span style="color:#808080"><em> *
</em></span><span style="color:#808080"><em> * Licensed under the Apache License, Version 2.0 (the "License");
</em></span><span style="color:#808080"><em> * you may not use this file except in compliance with the License.
</em></span><span style="color:#808080"><em> * You may obtain a copy of the License at
</em></span><span style="color:#808080"><em> *
</em></span><span style="color:#808080"><em> *     http://www.apache.org/licenses/LICENSE-2.0
</em></span><span style="color:#808080"><em> *
</em></span><span style="color:#808080"><em> * Unless required by applicable law or agreed to in writing, software
</em></span><span style="color:#808080"><em> * distributed under the License is distributed on an "AS IS" BASIS,
</em></span><span style="color:#808080"><em> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</em></span><span style="color:#808080"><em> * See the License for the specific language governing permissions and
</em></span><span style="color:#808080"><em> * limitations under the License.
</em></span><span style="color:#808080"><em> */
</em></span><span style="color:#808080"><em>
</em></span><span style="color:#000080"><strong>package </strong></span>observablescrollview;

<span style="color:#000080"><strong>import </strong></span>android.view.ViewGroup;

<span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em> * Interface for providing common API for observable and scrollable widgets.
</em></span><span style="color:#808080"><em> */
</em></span><span style="color:#000080"><strong>public interface </strong></span>Scrollable {
    <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>     * Set a callback listener.</em></span><span style="color:#808080; background-color:#e2ffe2"><em>&lt;br&gt;</em></span><span style="color:#808080"><em>
</em></span><span style="color:#808080"><em>     * Developers should use {<!-- --></em></span><span style="color:#808080"><strong><em>@link </em></strong></span><span style="color:#808080"><em>#addScrollViewCallbacks(ObservableScrollViewCallbacks)}
</em></span><span style="color:#808080"><em>     * and {<!-- --></em></span><span style="color:#808080"><strong><em>@link </em></strong></span><span style="color:#808080"><em>#removeScrollViewCallbacks(ObservableScrollViewCallbacks)}.
</em></span><span style="color:#808080"><em>     *
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@param </em></strong></span><span style="color:#3d3d3d"><strong><em>listener </em></strong></span><span style="color:#808080"><em>Listener to set.
</em></span><span style="color:#808080"><em>     */
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#808000">@Deprecated
</span><span style="color:#808000">    </span><span style="color:#000080"><strong>void </strong></span>setScrollViewCallbacks(ObservableScrollViewCallbacks listener);

    <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>     * Add a callback listener.
</em></span><span style="color:#808080"><em>     *
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@param </em></strong></span><span style="color:#3d3d3d"><strong><em>listener </em></strong></span><span style="color:#808080"><em>Listener to add.
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@since </em></strong></span><span style="color:#808080"><em>1.7.0
</em></span><span style="color:#808080"><em>     */
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#000080"><strong>void </strong></span>addScrollViewCallbacks(ObservableScrollViewCallbacks listener);

    <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>     * Remove a callback listener.
</em></span><span style="color:#808080"><em>     *
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@param </em></strong></span><span style="color:#3d3d3d"><strong><em>listener </em></strong></span><span style="color:#808080"><em>Listener to remove.
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@since </em></strong></span><span style="color:#808080"><em>1.7.0
</em></span><span style="color:#808080"><em>     */
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#000080"><strong>void </strong></span>removeScrollViewCallbacks(ObservableScrollViewCallbacks listener);

    <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>     * Clear callback listeners.
</em></span><span style="color:#808080"><em>     *
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@since </em></strong></span><span style="color:#808080"><em>1.7.0
</em></span><span style="color:#808080"><em>     */
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#000080"><strong>void </strong></span>clearScrollViewCallbacks();

    <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>     * Scroll vertically to the absolute Y.</em></span><span style="color:#808080; background-color:#e2ffe2"><em>&lt;br&gt;</em></span><span style="color:#808080"><em>
</em></span><span style="color:#808080"><em>     * Implemented classes are expected to scroll to the exact Y pixels from the top,
</em></span><span style="color:#808080"><em>     * but it depends on the type of the widget.
</em></span><span style="color:#808080"><em>     *
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@param </em></strong></span><span style="color:#3d3d3d"><strong><em>y </em></strong></span><span style="color:#808080"><em>Vertical position to scroll to.
</em></span><span style="color:#808080"><em>     */
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#000080"><strong>void </strong></span>scrollVerticallyTo(<span style="color:#000080"><strong>int </strong></span>y);

    <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>     * Return the current Y of the scrollable view.
</em></span><span style="color:#808080"><em>     *
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@return </em></strong></span><span style="color:#808080"><em>Current Y pixel.
</em></span><span style="color:#808080"><em>     */
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#000080"><strong>int </strong></span>getCurrentScrollY();

    <span style="color:#808080"><em>/**
</em></span><span style="color:#808080"><em>     * Set a touch motion event delegation ViewGroup.</em></span><span style="color:#808080; background-color:#e2ffe2"><em>&lt;br&gt;</em></span><span style="color:#808080"><em>
</em></span><span style="color:#808080"><em>     * This is used to pass motion events back to parent view.
</em></span><span style="color:#808080"><em>     * It's up to the implementation classes whether or not it works.
</em></span><span style="color:#808080"><em>     *
</em></span><span style="color:#808080"><em>     * </em></span><span style="color:#808080"><strong><em>@param </em></strong></span><span style="color:#3d3d3d"><strong><em>viewGroup </em></strong></span><span style="color:#808080"><em>ViewGroup object to dispatch motion events.
</em></span><span style="color:#808080"><em>     */
</em></span><span style="color:#808080"><em>    </em></span><span style="color:#000080"><strong>void </strong></span>setTouchInterceptionViewGroup(ViewGroup viewGroup);
}
</pre> 上面只是列子，请大家自行的修改。 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f4951fe73c4a96c17f89dc3a6ec35867/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql单列索引、多列索引的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c486d45f3781f54b00ab61bf3031c0c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HyBrid App框架介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>