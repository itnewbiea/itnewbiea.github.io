<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux/C&#43;&#43;:modebus通信示例】（带初习配置概括） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux/C&#43;&#43;:modebus通信示例】（带初习配置概括）" />
<meta property="og:description" content="以modbus RTU为例，模拟modbus简单通信原理的代码实现
首先需要配置串口。
这里使用的为Configure Virtual Serial Port Driver虚拟串口调试工具
创建COM1,COM2虚拟端口，或另创建一对串口互作收发信号端。
创建完成后虚拟工具COM后会有已启动端口的状态，这里我们以波特率9600 8N1为基准进行设定。
接着，我对modbus slave开始设定，这里用slave而不用poll，我们后面会用虚拟机做主机，而slave为从机服务器。一般slave使用COM2端口
简单模拟，就以03保存寄存器和01线圈为例。
按规格设定好后，进入linux ubuntu，进行串口配置，在开机之前，需先添加串口。
后选择COM1端口，一般约定主机COM1连接。要在VMware上面菜单中找到对应的串口组件并点击连接。
//P.S.modbus TCP设定是网络设定，检验连接可用wireshark抓包检测连通，一般slave使用502端口，假如使用虚拟机与PC做连通测试，要注意填写ip为相应虚拟机或PC的ip，而127.0.0.1本地回环测试的本质是本机回环，虚拟机也是独立的。
接着我们进入linux，下载minicom模块。
终端输入：
sudo apt-get install minicom 当连接上虚拟串口后，在终端输入dmesg | grep tty，可以查看到对应的设备文件，其中默认的会有ttyS0文件，剩下的就是虚拟串口对应的设备文件。
虚拟机在终端执行sudo minicom -s
主要使用setup进行波特率等属性设置，并记得保存。
配置完成，可先使用 UartAssist串口调试工具通信测试。
调试助手关闭时尽量选关闭而不是最小化，不然频繁使用造成打开一堆在后台，占用资源
接着就可以进行真正的通信了。
这里是基于C&#43;&#43;的通信，故要使用对应的类库
基类.h
#include &lt;stdint.h&gt; //uint class AbsPoll { protected: //从机地址 int sid; //打开文件需要打文件描述符 int fd; public: AbsPoll(); ~AbsPoll(); //从Ｃ&#43;&#43;相应库modbus相关类函数里找到需要的函数 int setSlave(int id); //初始id //以下多个纯虚函数，代表这是抽象类，之后派生类使用，不能直接创建对象，所以函数定义写在派生类 virtual int Connect() = 0; //连接，打开文件 virtual int writeData(uint8_t *data, int len) = 0; //写数据（发送 virtual int readData(uint8_t *data, int len) = 0; //读数据（接受 virtual int buildRequest(int func, int addr, int nb, uint8_t *req) = 0; //封装请求码 int read_registers(int addr, int nb, uint16_t *dest); //读寄存器数据并存放于指定数组 int write_bit(int addr, int status); //如05写线圈状态时可以写一种 }; 基类." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/73533aff4d949d10b92ff604ff955c48/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-15T11:44:00+08:00" />
<meta property="article:modified_time" content="2023-04-15T11:44:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux/C&#43;&#43;:modebus通信示例】（带初习配置概括）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="color:#fe2c24;"><span style="background-color:#a2e043;">        以modbus RTU为例，模拟modbus简单通信原理的代码实现</span></span></strong></p> 
<p></p> 
<p>        首先需要配置串口。</p> 
<p>        这里使用的为Configure Virtual Serial Port Driver虚拟串口调试工具</p> 
<p><img alt="" height="122" src="https://images2.imgbox.com/01/cc/uDxxShgp_o.png" width="97"></p> 
<p class="img-center"><img alt="" height="257" src="https://images2.imgbox.com/67/0f/4UBpxyaZ_o.png" width="462"></p> 
<p> 创建COM1,COM2虚拟端口，或另创建一对串口互作收发信号端。</p> 
<p>创建完成后虚拟工具COM后会有已启动端口的状态，这里我们以<strong><span style="color:#fe2c24;">波特率9600 8N1</span></strong>为基准进行设定。</p> 
<p></p> 
<p>        接着，我对modbus slave开始设定，这里用slave而不用poll，我们后面会用虚拟机做主机，而slave为从机服务器。一般slave使用COM2端口</p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/90/a0/jOQocRVG_o.png" width="94"> </p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/1a/84/w0UTQhCO_o.png" width="779"></p> 
<p>简单模拟，就以<span style="color:#a2e043;">03保存寄存器</span>和<span style="color:#38d8f0;">01线圈</span>为例。</p> 
<p></p> 
<p>按规格设定好后，进入linux ubuntu，进行<strong><span style="color:#fe2c24;">串口配置</span></strong>，在开机之前，需先添加串口。</p> 
<p><img alt="" height="1000" src="https://images2.imgbox.com/fd/a3/NWzMw2Tu_o.png" width="847"></p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/7d/ca/mzQeMouP_o.png" width="604"></p> 
<p></p> 
<p>后选择COM1端口，一般约定主机COM1连接。要在VMware上面菜单中找到对应的串口组件并点击连接。</p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/76/b8/3WQqYGSj_o.png" width="1026"></p> 
<p> </p> 
<p></p> 
<p><strong><span style="color:#956fe7;">//P.S.modbus TCP设定是网络设定，检验连接可用wireshark抓包检测连通，一般slave使用502端口，假如使用虚拟机与PC做连通测试，要注意填写ip为相应虚拟机或PC的ip，而127.0.0.1本地回环测试的本质是本机回环，虚拟机也是独立的。</span></strong></p> 
<p></p> 
<p>接着我们进入linux，下载minicom模块。</p> 
<p></p> 
<p>终端输入：</p> 
<pre><code class="hljs">sudo apt-get install minicom</code></pre> 
<p></p> 
<p style="text-align:justify;">当连接上虚拟串口后，在终端输入dmesg | grep tty，可以查看到对应的设备文件，其中默认的会有ttyS0文件，剩下的就是虚拟串口对应的设备文件。</p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;">虚拟机在终端执行sudo minicom -s</p> 
<p style="text-align:justify;">主要使用setup进行波特率等属性设置，并记得保存。</p> 
<p style="text-align:justify;"></p> 
<p> <img alt="" height="181" src="https://images2.imgbox.com/cb/47/pyRMn4Pa_o.png" width="257"></p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/9a/15/0ZUfH9wP_o.png" width="411"></p> 
<p></p> 
<p>配置完成，可先使用 UartAssist串口调试工具通信测试。</p> 
<p><img alt="" height="108" src="https://images2.imgbox.com/6e/8f/ZGA72ail_o.png" width="91"></p> 
<p></p> 
<p><img alt="" height="732" src="https://images2.imgbox.com/69/51/Q8YGel5k_o.png" width="830"></p> 
<p></p> 
<p>调试助手关闭时尽量选关闭而不是最小化，不然频繁使用造成打开一堆在后台，占用资源</p> 
<p></p> 
<p>接着就可以进行真正的通信了。</p> 
<p></p> 
<p></p> 
<p>这里是基于C++的通信，故要使用对应的类库</p> 
<p></p> 
<p> 基类.h</p> 
<pre><code class="language-cpp">#include &lt;stdint.h&gt;             //uint

class AbsPoll   
{
protected:
    //从机地址
    int sid;
    //打开文件需要打文件描述符
    int fd; 
public:
    AbsPoll();
    ~AbsPoll();

    //从Ｃ++相应库modbus相关类函数里找到需要的函数

    int setSlave(int id);                             //初始id
    //以下多个纯虚函数，代表这是抽象类，之后派生类使用，不能直接创建对象，所以函数定义写在派生类
    virtual int Connect() = 0;                           //连接，打开文件
    virtual int writeData(uint8_t *data, int len) = 0;     //写数据（发送
    virtual int readData(uint8_t *data, int len) = 0;       //读数据（接受
    virtual int buildRequest(int func, int addr, int nb, uint8_t *req) = 0;     //封装请求码
    int read_registers(int addr, int nb, uint16_t *dest);           //读寄存器数据并存放于指定数组
    int write_bit(int addr, int status);        //如05写线圈状态时可以写一种
};</code></pre> 
<p></p> 
<p>基类.cpp</p> 
<pre><code class="language-cpp">#include "AbsPoll.h"

AbsPoll::AbsPoll()
{
}

AbsPoll::~AbsPoll()
{
}

//初始化ｉｄ（从机地址）
int AbsPoll::setSlave(int id)
{
    sid = id;
}


//读寄存器数据操作
int AbsPoll::read_registers(int addr, int nb, uint16_t *dest)
{
    uint8_t req[32] = "";       
    uint8_t data[32] = "";
    int len;                             
    len = buildRequest(3, addr, nb, req); //请求码的实际长度
    writeData(req, len);//写数据
    readData(data, 32); //1:tcp:7+1+4=12 RTU:1+1+4+2=8      读数据
    //modebus TCP和RTU格式和长度是不同的，读取位置也是不同的
    if(len == 8)//RTU
    {
        for(int i = 0,j = 0; i &lt; data[2]; i+=2,j++)
            dest[j] = data[3+i] &lt;&lt; 8 | data[4+i];   
    }
    else //TCP
    {
        for(int i = 0,j = 0; i &lt; data[8]; i+=2,j++)
            dest[j] = data[9+i] &lt;&lt; 8 | data[10+i];
    } 
}
int write_bit(int addr, int status)
{

}</code></pre> 
<p>派生.h(RTU样例)</p> 
<pre><code class="language-cpp">
#include "AbsPoll.h"
#include "Crc_Calc.h"
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include "head.h"
#include &lt;iostream&gt;

using namespace std;

class RTUPoll : public AbsPoll                        //使用抽象类创建派生类
{
private:
    string devname;         //注意string类型

public:
    RTUPoll(string name);           //直接构造初始化文件路径
    ~RTUPoll();
    //下在基类为纯虚函数继承下来要写声明，并定义
    int Connect();                  
    int writeData(uint8_t *data, int len);
    int readData(uint8_t *data, int len);
    int buildRequest(int func, int addr, int nb, uint8_t *req);
};

</code></pre> 
<p> </p> 
<p> 派生.cpp</p> 
<p> </p> 
<pre><code class="language-cpp">#include "RTUPoll.h"

//初始化设备路径
RTUPoll::RTUPoll(string name)
{
    devname = name;
}

RTUPoll::~RTUPoll()
{
}

//连接
int RTUPoll::Connect()
{
    fd = open(devname.c_str(), O_RDWR);
    //这里注意devname为string类型，而open参数为char*类型,所以使用c_str（）转数据类型char
        if (fd &lt; 0)
    {
        cout &lt;&lt; "open err" &lt;&lt; endl; //错误信息设置
        return -1;
    }
    //
    uart_init(fd); //这个地方是个初始化串口的函数，代码可以自己查查，我之后也会给一种示例。
    return 0;
}


int RTUPoll::writeData(uint8_t *data, int len)
{
    return write(fd, data, len); //写数据
}


int RTUPoll::readData(uint8_t *data, int len)
{
    return read(fd, data, len); //读数据
}

//封装请求码
int RTUPoll::buildRequest(int func, int addr, int nb, uint8_t *req)
{
    //这里控制的就是外部定义的req数组。下面按ＲＴＵ的数据格式填充
    req[0] = sid;                  //从机地址
    req[1] = func;                 //功能码
    req[2] = (uint8_t)(addr &gt;&gt; 8); //理论上，有要分大小端存储的数，都可以拆分开。
    req[3] = (uint8_t)(addr &amp; 0xff);

    if (func == 3)
    {
        req[4] = (uint8_t)(nb &gt;&gt; 8); //当功能码是03时完成的任务
        req[5] = (uint8_t)(nb &amp; 0xff);
    }
    unsigned short crc = GetCRC16(req, 6); //这里是一个ＣＳＣ校验，形成两字节的校验位
    req[6] = (uint8_t)(crc &gt;&gt; 8);          //上返回的unsigned short类型,转为uint8_t
    req[7] = (uint8_t)(crc &amp; 0xff);
    return 8;
}</code></pre> 
<p></p> 
<p></p> 
<p>串口初始化</p> 
<pre><code class="language-cpp">#include &lt;termios.h&gt;

void uart_init(int fd)
{
    struct termios options;
    //设置串口属性
	//获取串口原有属性
    tcgetattr(fd, &amp;options);
	//激活选项CLOCAL(本地连接)和CREAD(接受使能)
    options.c_cflag |= ( CLOCAL | CREAD );
	//设置字符大小
    options.c_cflag &amp;= ~CSIZE;
    //设置流控
    options.c_cflag &amp;= ~CRTSCTS;
	//设置8位数据位
    options.c_cflag |= CS8;
	//设置停止位
    options.c_cflag &amp;= ~CSTOPB;
    //忽略奇偶错字符
    options.c_iflag |= IGNPAR;
    //将输入的CR转换为NL和停止输出控制流起作用
    options.c_iflag &amp;= ~(ICRNL | IXON);
    options.c_oflag = 0;
    options.c_lflag = 0;
	//设置波特率(输入和输出的波特率)
    cfsetispeed(&amp;options, B9600);
    cfsetospeed(&amp;options, B9600);
	//激活配置
    tcsetattr(fd, TCSANOW, &amp;options);
}</code></pre> 
<p></p> 
<p>接着就可以尝试互通消息了</p> 
<p>modbus收发为一问一答，基于linux特性，可用直接读写串口文件来进行通信。</p> 
<p>当这样的通信框架建成，就可融合其他功能了，如接入webserver等。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f2ab0d55ec3abe48dbbfc52a4df2698/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nopepad&#43;&#43;使用教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e6807ac9f2505ef7c61f55afb712ed5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在React中使用setState修改数组的值时，为什么不能使用数组的可变方法(push、unshift等)? 但在vue中可以</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>