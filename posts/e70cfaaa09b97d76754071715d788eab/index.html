<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024最新Java基础面试题大全（六） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2024最新Java基础面试题大全（六）" />
<meta property="og:description" content="文章目录 1、Session 和 Cookie 有何区别1.1、Session1.2、Cookie1.3、cookie 和 session 的区别 2、equals 和 == 的区别3、netty 和 WebSocket 区别4、WebService5、B/S C/S 什么意思5.1、 什么是B/S ？5.1.1、 B/S的优点和缺点5.2、 什么是C/S呢？5.2.1、 C/S的优点和缺点 6、连接池是什么，有什么作用7、所了解的数据源8、日志级别有几个9、日志是什么？ 有什么作用？9.1日志是什么9.2日志的作用 1、Session 和 Cookie 有何区别 1.1、Session 会话，当用户打开某个web应用时，便与 web 服务器产生了一次 session。服务器使用 session 把用户的信息临时保存在服务器上，用户离开网站后，session 就会被销毁。这种用户信息存储方式相对 cookie 来说，更安全，可是 session 有一个缺陷，如果 web 服务器做了负载均衡，那么下个请求到另一台服务器的时候，session 会丢失
1.2、Cookie cookie是保存在本地终端的数据，cookie 由服务器生成，发送给浏览器，浏览器把 cookie 以 kv 形式保存到某个目录下的文本内，下一次请求网站，会把 cookie 发给服务器，由于 cookie 是存在客户端上，所以浏览器加入了一些限制取保 cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的 cookie 都是有限的。
1.3、cookie 和 session 的区别 cookie 数据存放在客户的浏览器上，session 数据放在服务器上cookie 不是很安全，别人可以分析存放在本地 COOKIE 进行 COOKIE 欺骗，考虑安全应当使用 sessionsession 会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器性能，考虑到减轻服务器性能方面，应当使用COOKIE单个 cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存 20 个 cookie。建议： 将登陆信息等重要的信息存放在 session 中其他信息如果需要保留，可以放在 cookie 中 2、equals 和 == 的区别 初步认识 equals 和 == 的区别 == 是判断两个变量或实例是不是指向同一个内存空间，equals 是判断两个变量或实例指向的内存空间中的值 是不是相同的== 是指对内存地址进行比较，equals() 是对字符串的内容进行比较== 指引用是否相同，equals() 指的是值是否相同 详解：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e70cfaaa09b97d76754071715d788eab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T17:48:14+08:00" />
<meta property="article:modified_time" content="2024-01-05T17:48:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024最新Java基础面试题大全（六）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1Session__Cookie__1" rel="nofollow">1、Session 和 Cookie 有何区别</a></li><li><ul><li><ul><li><a href="#11Session_3" rel="nofollow">1.1、Session</a></li><li><a href="#12Cookie_7" rel="nofollow">1.2、Cookie</a></li><li><a href="#13cookie__session__11" rel="nofollow">1.3、cookie 和 session 的区别</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2equals____21" rel="nofollow">2、equals 和 == 的区别</a></li><li><a href="#3netty__WebSocket__49" rel="nofollow">3、netty 和 WebSocket 区别</a></li><li><a href="#4WebService_64" rel="nofollow">4、WebService</a></li><li><a href="#5BS__CS__94" rel="nofollow">5、B/S C/S 什么意思</a></li><li><ul><li><a href="#51_BS__95" rel="nofollow">5.1、 什么是B/S ？</a></li><li><a href="#511_BS_102" rel="nofollow">5.1.1、 B/S的优点和缺点</a></li><li><a href="#52_CS_115" rel="nofollow">5.2、 什么是C/S呢？</a></li><li><a href="#521_CS_120" rel="nofollow">5.2.1、 C/S的优点和缺点</a></li></ul> 
   </li><li><a href="#6_132" rel="nofollow">6、连接池是什么，有什么作用</a></li><li><a href="#7_151" rel="nofollow">7、所了解的数据源</a></li><li><a href="#8_153" rel="nofollow">8、日志级别有几个</a></li><li><a href="#9__166" rel="nofollow">9、日志是什么？ 有什么作用？</a></li><li><ul><li><a href="#91_167" rel="nofollow">9.1日志是什么</a></li><li><a href="#92_170" rel="nofollow">9.2日志的作用</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1Session__Cookie__1"></a>1、Session 和 Cookie 有何区别</h3> 
<h5><a id="11Session_3"></a>1.1、Session</h5> 
<p>会话，当用户打开某个web应用时，便与 web 服务器产生了一次 session。服务器使用 session 把用户的信息临时保存在服务器上，用户离开网站后，session 就会被销毁。这种用户信息存储方式相对 cookie 来说，更安全，可是 session 有一个缺陷，如果 web 服务器做了负载均衡，那么下个请求到另一台服务器的时候，session 会丢失</p> 
<h5><a id="12Cookie_7"></a>1.2、Cookie</h5> 
<p>cookie是保存在本地终端的数据，cookie 由服务器生成，发送给浏览器，浏览器把 cookie 以 kv 形式保存到某个目录下的文本内，下一次请求网站，会把 cookie 发给服务器，由于 cookie 是存在客户端上，所以浏览器加入了一些限制取保 cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的 cookie 都是有限的。</p> 
<h5><a id="13cookie__session__11"></a>1.3、cookie 和 session 的区别</h5> 
<ol><li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上</li><li>cookie 不是很安全，别人可以分析存放在本地 COOKIE 进行 COOKIE 欺骗，考虑安全应当使用 session</li><li>session 会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器性能，考虑到减轻服务器性能方面，应当使用COOKIE</li><li>单个 cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</li><li>建议： 
  <ul><li>将登陆信息等重要的信息存放在 session 中</li><li>其他信息如果需要保留，可以放在 cookie 中</li></ul> </li></ol> 
<h3><a id="2equals____21"></a>2、equals 和 == 的区别</h3> 
<ol><li>初步认识 equals 和 == 的区别 
  <ul><li>== 是判断两个变量或实例是不是指向同一个内存空间，equals 是判断两个变量或实例指向的内存空间中的值 是不是相同的</li><li>== 是指对内存地址进行比较，equals() 是对字符串的内容进行比较</li><li>== 指引用是否相同，equals() 指的是值是否相同</li></ul> </li></ol> 
<blockquote> 
 <p>详解：<br> == 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的地址值是否相同，即是否指向同一个对象，比较的是真正意义上的指针操作。equals用来比较的是两个对象的内容是否相同，由于所有的类都是继承自 java.lang.Objec 类的，所以适用于所有对象，如果没有该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而Object 中的 equals方法返回却是 == 的判断。String s = “abcd” 是一种非常特殊的形式，和 new 有本质的区别，它是 java 中唯一不需要 new 就可以产生对象的途径。以 String = “abcd” 形式赋值在 java 中叫直接量，它是常量池中而不是象new 一样放进压缩堆中，这种形式的字符串，在 JVM 内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有没有一个值是 “abcd"的对象，如果有，就会把它赋给当前引用，即原来那个引用和现在这个引用指点向了同一个对象，如果没有，如果没有，则在常量池中创建一个“abcd“，下一次如果有 Sring s1 = ”abcd“，又会将S1 指向 abcd 这个对象，即以这样形式声明的字符串，只有值相等，任何多个引用都指向同一个对象。</p> 
</blockquote> 
<blockquote> 
 <p>而String s = new String（“abcd”） 和其他任何对象一样，每次调用一次就产生一个对象，只要他们调用。</p> 
</blockquote> 
<blockquote> 
 <p>也可以这么理解 String str = “hello” 先在内存中找是不是有 “hello” 这个对象，如果有，就指向那个“hello”，如果没有，就创建一个新的对象保存 ”hello“ ，String str = new String（”hello“）就是不管内存里是不是有 ”hello“ 这个对象，都新建一个对象保存”hello“</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// a 为另一个引用</span>
<span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// b 为另一个引用，a跟b的对象内容是一致的</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 把 “abcd” 放在常量池中</span>
<span class="token class-name">String</span> c <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>
<span class="token comment">// 从常量池中查找 “abcd”</span>
<span class="token class-name">String</span> d <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span> <span class="token comment">// false 非同一个对象;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true,在String 中 equals 方法被重写当物理地址不同时，会进一步比较值，此时 equals 方法不单单是比较</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
</code></pre> 
<h3><a id="3netty__WebSocket__49"></a>3、netty 和 WebSocket 区别</h3> 
<blockquote> 
 <p>Netty 和 WebSocket 没有直接可比性，因为它们在网络编程环境中具有不同的用途。</p> 
</blockquote> 
<p><strong>Netty：</strong></p> 
<p>Netty 是一个高性能、事件驱动的网络框架，用于用 Java 构建网络应用程序。<br> 它提供了一组用于处理各种网络协议（例如 TCP 和 UDP）的工具和抽象。<br> Netty 通常用于构建需要低延迟、高吞吐量通信的服务器和客户端。</p> 
<p><strong>Websocket：</strong><br> WebSocket 是一种通信协议，可通过单个长期连接提供全双工通信通道。<br> 它被设计为在 Web 浏览器和 Web 服务器中实现，但也可以在其他环境中使用。<br> WebSocket 构建在 TCP 协议之上，用于实现客户端和服务器之间的实时通信。<br> 总而言之，Netty 是一个用于在 Java 中构建网络应用程序的网络框架，而 WebSocket 是一种在网络上运行的通信协议，通常使用 Netty 等框架来实现。Netty 可用于构建使用 WebSocket 等协议进行实时通信的应用程序。因此，它们是互补技术而不是替代技术。</p> 
<h3><a id="4WebService_64"></a>4、WebService</h3> 
<blockquote> 
 <p>Java 中共有三种WebService 规范，分别是JAXM&amp;SAAJ、JAX-WS（JAX-RPC）、JAX-RS。</p> 
</blockquote> 
<ul><li> <p>JAX-WS：</p> <p>JAX-WS（Java API For XML-WebService）。早期的基于SOAP 的JAVA 的Web<br> 服务规范JAX-RPC（java API For XML-Remote Procedure Call）目前已经被JAX-WS<br> 规范取代，JAX-WS 是JAX-RPC 的演进版本，但JAX-WS<br> 并不完全向后兼容JAX-RPC，二者最大的区别就是RPC/encoded 样式的WSDL，JAX-WS 已经不提供这种支持。JAX-RPC<br> 的API 从JAVA EE5 开始已经移除，如果你使用J2EE1.4，其API 位于javax.xml.rpc.包。JAX-WS（JSR<br> 224）规范的API 位于javax.xml.ws.包，其中大部分都是注解，提供API 操作Web<br> 服务（通常在客户端使用的较多，由于客户端可以借助SDK 生成，因此这个包中的API 我们较少会直接使用）。</p> </li><li> <p>JAXM&amp;SAAJ：</p> <p>JAXM（JAVA API For XML Message）主要定义了包含了发送和接收消息所需的API，相当于Web<br> 服务的服务器端，其API 位于javax.messaging.*包，它是Java EE 的可选包，因此你需要单独下载。</p> <p>SAAJ（SOAP With Attachment API For Java，JSR 67）是与JAXM 搭配使用的API，为构建SOAP<br> 包和解析SOAP 包提供了重要的支持，支持附件传输，它在服务器端、客户端都需要使用。这里还要提到的是SAAJ 规范，其API<br> 位于javax.xml.soap.*包。</p> <p>JAXM&amp;SAAJ 与JAX-WS 都是基于SOAP 的Web 服务，相比之下JAXM&amp;SAAJ<br> 暴漏了SOAP更多的底层细节，编码比较麻烦，而JAX-WS 更加抽象，隐藏了更多的细节，更加面向对象，实现起来你基本上不需要关心SOAP<br> 的任何细节。那么如果你想控制SOAP 消息的更多细节，可以使用JAXM&amp;SAAJ。</p> </li><li> <p>JAX-RS：</p> <p>JAX-RS 是JAVA 针对REST(Representation State Transfer)风格制定的一套Web<br> 服务规范，由于推出的较晚，该规范（JSR 311，目前JAX-RS 的版本为1.0）并未随JDK1.6 一起发行。</p> </li></ul> 
<h3><a id="5BS__CS__94"></a>5、B/S C/S 什么意思</h3> 
<h4><a id="51_BS__95"></a>5.1、 什么是B/S ？</h4> 
<p><strong>定义</strong>：浏览器-服务器（Browser/Server）结构，简称B/S结构。是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如Chrome、Safari、Microsoft Edge、Netscape Navigator或Internet Explorer，服务器安装SQL Server、Oracle、MYSQL等数据库。浏览器通过Web Server 同数据库进行数据交互。</p> 
<blockquote> 
 <p>一句话概括：B/S就是在浏览器中打开的应用系统，即WEB 系统。不需要下载客户端，在网页上即可运行。</p> 
</blockquote> 
<p>那了解了B/S的概念，那它有什么优点和缺点呢？</p> 
<h4><a id="511_BS_102"></a>5.1.1、 B/S的优点和缺点</h4> 
<blockquote> 
 <p><strong>优点：</strong><br> 分布性强，客户端零维护。只要有网络、浏览器，可以随时随地进行查询、浏览等业务处理。<br> 业务扩展简单方便，通过增加网页即可增加服务器功能。<br> 维护简单方便，只需要改变网页，即可实现所有用户的同步更新。<br> 开发简单，共享性强。</p> 
</blockquote> 
<blockquote> 
 <p><strong>缺点：</strong><br> 个性化特点明显降低，无法实现具有个性化的功能要求（但能通过账号体系进行个性化设置）。<br> 在跨浏览器上，B/S架构不尽如人意(在不同浏览器上会产生兼容问题)。<br> 客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度明显降低(Ajax可以一定程度上解决这个问题)。无法实现分页显示，给数据库访问造成较大的压力。<br> 在速度和安全性上需要花费巨大的设计成本（可以使用安全的 HTTPS 协议，安装控件的方式实现较好的安全性）。<br> 功能弱化，难以实现传统模式下的特殊功能要求。</p> 
</blockquote> 
<h4><a id="52_CS_115"></a>5.2、 什么是C/S呢？</h4> 
<p>C/S分布式模式，是计算机用语。C是指Client，S是指Server，C/S模式就是指客户端/服务器模式。是计算机软件协同工作的一种模式，通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。客户端是需要安装专用的客户端软件。</p> 
<blockquote> 
 <p>总结：C/S就是在终端需要安装一个应用程序方可访问的应用系统。一般在手机上极为常见，App 就是一种特殊的 CS 架构，一些桌面应用也是属于C/S的范畴。</p> 
</blockquote> 
<h4><a id="521_CS_120"></a>5.2.1、 C/S的优点和缺点</h4> 
<blockquote> 
 <p><strong>优点：</strong><br> 能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器，所以C/S客户端响应速度快。<br> 操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求。<br> C/S结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程。<br> 安全性能可以很容易保证，C/S一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强。一般高度机密的信息系统采用C/S结构适宜。</p> 
</blockquote> 
<blockquote> 
 <p><strong>缺点:</strong><br> 需要专门的客户端安装程序，分布功能弱，针对点多面广且不具备网络条件的用户群体，不能够实现快速部署安装和配置。<br> 兼容性差，对于不同的开发工具，具有较大的局限性。若采用不同工具，需要重新改写程序。<br> 开发、维护成本较高，需要具有一定专业水准的技术人员才能完成，发生一次升级，则所有客户端的程序都需要改变。。<br> 用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户，所以适用面窄，通常用于局域网中。</p> 
</blockquote> 
<h3><a id="6_132"></a>6、连接池是什么，有什么作用</h3> 
<p>1.什么是数据库连接池?<br> <code>DBCP(DataBase Connection Pool) </code><br> 数据库连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。</p> 
<p>2.数据库连接池的作用</p> 
<blockquote> 
 <p>1.资源复用，避免了重复创建，释放连接的大量资源消耗。<br> 2.更快的响应，数据库连接池初始化的时候往往已经创建了若干数据库连接置于池中，当进行业务请求时，避免了重新创建数据库连接和释放的时间。<br> 3.统一的数据库连接管理，避免资源泄露。</p> 
</blockquote> 
<p>3.常用的数据库连接池</p> 
<blockquote> 
 <p><strong>C3P0</strong> 是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate 一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。</p> 
</blockquote> 
<blockquote> 
 <p><strong>DBCP</strong>（DataBase Connection Pool）数据库连接池，<br> 是Java数据库连接池的一种，由Apache开发，通过数据库连接池，<br> 可以让程序自动管理数据库连接的释放和断开</p> 
</blockquote> 
<blockquote> 
 <p><strong>DRUID</strong> 是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池。</p> 
</blockquote> 
<h3><a id="7_151"></a>7、所了解的数据源</h3> 
<blockquote> 
 <p>待补充…</p> 
</blockquote> 
<h3><a id="8_153"></a>8、日志级别有几个</h3> 
<blockquote> 
 <p>1.DEBUG<br>  指出细粒度信息事件，主要用来调试应用程序。<br> 2.INFO<br>   表明粗粒度级别，上强调应用程序的运行过程，比如进入某个业务分支。<br> 3.WARN<br>   表明出现潜在错误。<br> 4.ERROR<br>   指出虽然发生错误事件，但不影响系统的继续运行。<br> 5.FATAL<br>   指出每个严重的错误事件将会导致应用程序的退出。</p> 
</blockquote> 
<p>Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。 等于或高于日志记录器当前配置级别的日志的将被打印出来。</p> 
<h3><a id="9__166"></a>9、日志是什么？ 有什么作用？</h3> 
<h4><a id="91_167"></a>9.1日志是什么</h4> 
<p>日志：记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题</p> 
<h4><a id="92_170"></a>9.2日志的作用</h4> 
<p>不管是使用何种编程语言，日志输出几乎无处不再。总结起来，日志大致有以下几种用途：</p> 
<ul><li><strong>「问题追踪」</strong>：辅助排查和定位线上问题，优化程序运行性能</li><li><strong>「状态监控」</strong>：通过日志分析，可以监控系统的运行状态</li><li><strong>「安全审计」</strong>：审计主要体现在安全上，可以发现非授权的操作</li></ul> 
<p>总结：日志在应用程序中是非常非常重要的，好的日志信息能有助于我们在程序出现BUG时能快速进行定位，并能找出其中的原因。在平时的工作中对日志这个东西应当引起足够的重视。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9b62278dddba9c760a208a26dd400bd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一起来看看Solr全量更新和增量更新的那些事</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84091893546f3505e2715fe1a4b5af07/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RFC3261: SIP:12对话</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>