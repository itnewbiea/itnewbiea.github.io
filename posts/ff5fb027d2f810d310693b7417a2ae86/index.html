<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mybatis——select、insert、update、delete - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mybatis——select、insert、update、delete" />
<meta property="og:description" content="一、select &lt;!-- 查询学生，根据id --&gt; &lt;select id=&#34;getStudent&#34; parameterType=&#34;String&#34; resultMap=&#34;studentResultMap&#34;&gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.CLASS_ID FROM STUDENT_TBL ST WHERE ST.STUDENT_ID = #{studentID} &lt;/select&gt; 这条语句就叫做‘getStudent，有一个String参数，并返回一个StudentEntity类型的对象。 注意参数的标识是：#{studentID}。
select 语句属性配置细节： 属性描述取值默认id在这个模式下唯一的标识符，可被其它语句引用parameterType传给此语句的参数的完整类名或别名resultType语句返回值类型的整类名或别名。注意，如果是集合，那么这里填写的是集合的项的整类名或别名，而不是集合本身的类名。（resultType 与resultMap 不能并用）resultMap引用的外部resultMap 名。结果集映射是MyBatis 中最强大的特性。许多复杂的映射都可以轻松解决。（resultType 与resultMap 不能并用）flushCache如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为falsetrue/falsefalseuseCache如果设为true，则语句的结果集将被缓存。select 语句默认设为falsetrue/falsefalsetimeout设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定正整数未设置fetchSize设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定正整数驱动器决定statementTypestatement，preparedstatement，callablestatement。预准备语句、可调用语句STATEMENT、PREPARED、CALLABLEPREPAREDresultSetTypeforward_only、scroll_sensitive、scroll_insensitive 只转发，滚动敏感，不区分大小写的滚动FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE驱动器决定 二、insert 一个简单的insert语句：
&lt;!-- 插入学生 --&gt; &lt;insert id=&#34;insertStudent&#34; parameterType=&#34;StudentEntity&#34;&gt; INSERT INTO STUDENT_TBL (STUDENT_ID, STUDENT_NAME, STUDENT_SEX, STUDENT_BIRTHDAY, CLASS_ID) VALUES (#{studentID}, #{studentName}, #{studentSex}, #{studentBirthday}, #{classEntity.classID}) &lt;/insert&gt; insert可以使用数据库支持的自动生成主键策略，设置useGeneratedKeys=”true”，然后把keyProperty 设成对应的列，就搞定了。比如说上面的StudentEntity 使用auto-generated 为id 列生成主键.
&lt;insert id=&#34;insertStudent&#34; parameterType=&#34;StudentEntity&#34; useGeneratedKeys=&#34;true&#34; keyProperty=&#34;studentID&#34;&gt; 推荐使用这种用法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ff5fb027d2f810d310693b7417a2ae86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-08-31T16:22:12+08:00" />
<meta property="article:modified_time" content="2016-08-31T16:22:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mybatis——select、insert、update、delete</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="一select">一、select</h3> 
<pre class="prettyprint"><code class=" hljs avrasm">&lt;!-- 查询学生，根据id --&gt;  
&lt;select id=<span class="hljs-string">"getStudent"</span> parameterType=<span class="hljs-string">"String"</span> resultMap=<span class="hljs-string">"studentResultMap"</span>&gt;  
    SELECT <span class="hljs-keyword">ST</span><span class="hljs-preprocessor">.STUDENT</span>_ID,  
               <span class="hljs-keyword">ST</span><span class="hljs-preprocessor">.STUDENT</span>_NAME,  
               <span class="hljs-keyword">ST</span><span class="hljs-preprocessor">.STUDENT</span>_SEX,  
               <span class="hljs-keyword">ST</span><span class="hljs-preprocessor">.STUDENT</span>_BIRTHDAY,  
               <span class="hljs-keyword">ST</span><span class="hljs-preprocessor">.CLASS</span>_ID  
          FROM STUDENT_TBL <span class="hljs-keyword">ST</span>  
         WHERE <span class="hljs-keyword">ST</span><span class="hljs-preprocessor">.STUDENT</span>_ID = <span class="hljs-preprocessor">#{studentID}  </span>
&lt;/select&gt;  </code></pre> 
<p>这条语句就叫做‘getStudent，有一个String参数，并返回一个StudentEntity类型的对象。 <br> 注意参数的标识是：#{studentID}。</p> 
<p><strong>select 语句属性配置细节：</strong> </p> 
<table><thead><tr><th>属性</th><th>描述</th><th>取值</th><th>默认</th></tr></thead><tbody><tr><td>id</td><td>在这个模式下唯一的标识符，可被其它语句引用</td><td></td><td></td></tr><tr><td>parameterType</td><td>传给此语句的参数的完整类名或别名</td><td></td><td></td></tr><tr><td>resultType</td><td>语句返回值类型的整类名或别名。注意，如果是集合，那么这里填写的是集合的项的整类名或别名，而不是集合本身的类名。（resultType 与resultMap 不能并用）</td><td></td><td></td></tr><tr><td>resultMap</td><td>引用的外部resultMap 名。结果集映射是MyBatis 中最强大的特性。许多复杂的映射都可以轻松解决。（resultType 与resultMap 不能并用）</td><td></td><td></td></tr><tr><td>flushCache</td><td>如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false</td><td>true/false</td><td>false</td></tr><tr><td>useCache</td><td>如果设为true，则语句的结果集将被缓存。select 语句默认设为false</td><td>true/false</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>未设置</td></tr><tr><td>fetchSize</td><td>设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>驱动器决定</td></tr><tr><td>statementType</td><td>statement，preparedstatement，callablestatement。预准备语句、可调用语句</td><td>STATEMENT、PREPARED、CALLABLE</td><td>PREPARED</td></tr><tr><td>resultSetType</td><td>forward_only、scroll_sensitive、scroll_insensitive 只转发，滚动敏感，不区分大小写的滚动</td><td>FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE</td><td>驱动器决定</td></tr></tbody></table> 
<h3 id="二insert">二、insert</h3> 
<p>一个简单的insert语句：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 插入学生 --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">insert</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"insertStudent"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"StudentEntity"</span>&gt;</span>  
        INSERT INTO STUDENT_TBL (STUDENT_ID,  
                                          STUDENT_NAME,  
                                          STUDENT_SEX,  
                                          STUDENT_BIRTHDAY,  
                                          CLASS_ID)  
              VALUES   (#{studentID},  
                          #{studentName},  
                          #{studentSex},  
                          #{studentBirthday},  
                          #{classEntity.classID})  
<span class="hljs-tag">&lt;/<span class="hljs-title">insert</span>&gt;</span>  </code></pre> 
<p>insert可以使用数据库支持的自动生成主键策略，设置useGeneratedKeys=”true”，然后把keyProperty 设成对应的列，就搞定了。比如说上面的StudentEntity 使用auto-generated 为id 列生成主键.</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">insert</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"insertStudent"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"StudentEntity"</span> <span class="hljs-attribute">useGeneratedKeys</span>=<span class="hljs-value">"true"</span> <span class="hljs-attribute">keyProperty</span>=<span class="hljs-value">"studentID"</span>&gt;</span></code></pre> 
<p>推荐使用这种用法。</p> 
<p>另外，还可以使用selectKey元素。下面例子，使用mysql数据库nextval(‘student’)为自定义函数，用来生成一个key。</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 插入学生 自动主键--&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">insert</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"insertStudentAutoKey"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"StudentEntity"</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-title">selectKey</span> <span class="hljs-attribute">keyProperty</span>=<span class="hljs-value">"studentID"</span> <span class="hljs-attribute">resultType</span>=<span class="hljs-value">"String"</span> <span class="hljs-attribute">order</span>=<span class="hljs-value">"BEFORE"</span>&gt;</span>  
            select nextval('student')  
    <span class="hljs-tag">&lt;/<span class="hljs-title">selectKey</span>&gt;</span>  
        INSERT INTO STUDENT_TBL (STUDENT_ID,  
                                 STUDENT_NAME,  
                                 STUDENT_SEX,  
                                 STUDENT_BIRTHDAY,  
                                 CLASS_ID)  
              VALUES   (#{studentID},  
                        #{studentName},  
                        #{studentSex},  
                        #{studentBirthday},  
                        #{classEntity.classID})      
<span class="hljs-tag">&lt;/<span class="hljs-title">insert</span>&gt;</span>  </code></pre> 
<p><strong>insert语句属性配置细节：</strong></p> 
<table><thead><tr><th>属性</th><th>描述</th><th>取值</th><th>默认</th></tr></thead><tbody><tr><td>id</td><td>在这个模式下唯一的标识符，可被其它语句引用</td><td></td><td></td></tr><tr><td>parameterType</td><td>传给此语句的参数的完整类名或别名</td><td></td><td></td></tr><tr><td>flushCache</td><td>如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false</td><td>true/false</td><td>false</td></tr><tr><td>useCache</td><td>如果设为true，则语句的结果集将被缓存。select 语句默认设为false</td><td>true/false</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>未设置</td></tr><tr><td>fetchSize</td><td>设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>驱动器决定</td></tr><tr><td>statementType</td><td>statement、preparedstatement、callablestatement。预准备语句、可调用语句</td><td>STATEMENT、PREPARED、CALLABLE</td><td>PREPARED</td></tr><tr><td>useGeneratedKeys</td><td>告诉MyBatis 使用JDBC 的getGeneratedKeys 方法来获取数据库自己生成的主键（MySQL、SQLSERVER 等关系型数据库会有自动生成的字段）。默认：false</td><td>true/false</td><td>false</td></tr><tr><td>keyProperty</td><td>标识一个将要被MyBatis设置进getGeneratedKeys的key 所返回的值，或者为insert 语句使用一个selectKey子元素。</td><td></td><td></td></tr></tbody></table> 
<p><strong>selectKey语句属性配置细节：</strong></p> 
<table><thead><tr><th>属性</th><th>描述</th><th>取值</th></tr></thead><tbody><tr><td>keyProperty</td><td>selectKey 语句生成结果需要设置的属性。</td><td></td></tr><tr><td>resultType</td><td>生成结果类型，MyBatis 允许使用基本的数据类型，包括String 、int类型。</td><td></td></tr><tr><td>order</td><td>可以设成BEFORE 或者AFTER，如果设为BEFORE，那它会先选择主键，然后设置keyProperty，再执行insert语句；如果设为AFTER，它就先运行insert 语句再运行selectKey 语句，通常是insert 语句中内部调用数据库（像Oracle）内嵌的序列机制。</td><td>BEFORE/AFTER</td></tr><tr><td>statementType</td><td>像上面的那样， MyBatis 支持STATEMENT，PREPARED和CALLABLE 的语句形式， 对应Statement ，PreparedStatement 和CallableStatement 响应</td><td>STATEMENT、PREPARED、CALLABLE</td></tr></tbody></table> 
<h5 id="批量插入"><strong>批量插入</strong></h5> 
<p>方法一：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">insert</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"add"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"EStudent"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">foreach</span> <span class="hljs-attribute">collection</span>=<span class="hljs-value">"list"</span> <span class="hljs-attribute">item</span>=<span class="hljs-value">"item"</span> <span class="hljs-attribute">index</span>=<span class="hljs-value">"index"</span> <span class="hljs-attribute">separator</span>=<span class="hljs-value">";"</span>&gt;</span>
    INSERT INTO TStudent(name,age) VALUES(#{item.name}, #{item.age})
  <span class="hljs-tag">&lt;/<span class="hljs-title">foreach</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">insert</span>&gt;</span></code></pre> 
<p>上述方式相当语句逐条INSERT语句执行，将出现如下问题： <br> 1. mapper接口的add方法返回值将是最一条INSERT语句的操作成功的记录数目（就是0或1），而不是所有INSERT语句的操作成功的总记录数目 <br> 2. 当其中一条不成功时，不会进行整体回滚。</p> 
<p>方法二：</p> 
<pre class="prettyprint"><code class=" hljs xml">
<span class="hljs-tag">&lt;<span class="hljs-title">insert</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"insertStudentAutoKey"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"java.util.List"</span>&gt;</span>
    INSERT INTO STUDENT_TBL (STUDENT_NAME,  
                                 STUDENT_SEX,  
                                 STUDENT_BIRTHDAY,  
                                 CLASS_ID)  
                              VALUES   
  <span class="hljs-tag">&lt;<span class="hljs-title">foreach</span> <span class="hljs-attribute">collection</span>=<span class="hljs-value">"list"</span> <span class="hljs-attribute">item</span>=<span class="hljs-value">"item"</span> <span class="hljs-attribute">index</span>=<span class="hljs-value">"index"</span> <span class="hljs-attribute">separator</span>=<span class="hljs-value">","</span>&gt;</span>
      ( #{item.studentName},#{item.studentSex},#{item.studentBirthday},#{item.classEntity.classID})
  <span class="hljs-tag">&lt;/<span class="hljs-title">foreach</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">insert</span>&gt;</span></code></pre> 
<h3 id="三update">三、update</h3> 
<p>一个简单的update：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 更新学生信息 --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">update</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"updateStudent"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"StudentEntity"</span>&gt;</span>  
        UPDATE STUDENT_TBL  
            SET STUDENT_TBL.STUDENT_NAME = #{studentName},   
                STUDENT_TBL.STUDENT_SEX = #{studentSex},  
                STUDENT_TBL.STUDENT_BIRTHDAY = #{studentBirthday},  
                STUDENT_TBL.CLASS_ID = #{classEntity.classID}  
         WHERE STUDENT_TBL.STUDENT_ID = #{studentID};     
<span class="hljs-tag">&lt;/<span class="hljs-title">update</span>&gt;</span>  </code></pre> 
<p><strong>update语句属性配置细节：</strong></p> 
<table><thead><tr><th>属性</th><th>描述</th><th>取值</th><th>默认</th></tr></thead><tbody><tr><td>id</td><td>在这个模式下唯一的标识符，可被其它语句引用</td><td></td><td></td></tr><tr><td>parameterType</td><td>传给此语句的参数的完整类名或别名</td><td></td><td></td></tr><tr><td>flushCache</td><td>如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false</td><td>true/false</td><td>false</td></tr><tr><td>useCache</td><td>如果设为true，则语句的结果集将被缓存。select 语句默认设为false</td><td>true/false</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>未设置</td></tr><tr><td>fetchSize</td><td>设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>驱动器决定</td></tr><tr><td>statementType</td><td>statement、preparedstatement、callablestatement。预准备语句、可调用语句</td><td>STATEMENT、PREPARED、CALLABLE</td><td>PREPARED</td></tr></tbody></table> 
<h5 id="批量更新"><strong>批量更新</strong></h5> 
<p>情景一：更新多条记录为多个字段为不同的值 <br> 方法一：</p> 
<pre class="prettyprint"><code class=" hljs applescript">&lt;update <span class="hljs-property">id</span>=<span class="hljs-string">"updateBatch"</span>  parameterType=<span class="hljs-string">"java.util.List"</span>&gt;  
    &lt;foreach collection=<span class="hljs-string">"list"</span> <span class="hljs-property">item</span>=<span class="hljs-string">"item"</span> index=<span class="hljs-string">"index"</span> open=<span class="hljs-string">""</span> close=<span class="hljs-string">""</span> separator=<span class="hljs-string">";"</span>&gt;
        update course
        &lt;<span class="hljs-keyword">set</span>&gt;
            <span class="hljs-property">name</span>=${<!-- --><span class="hljs-property">item</span>.<span class="hljs-property">name</span>}
        &lt;/<span class="hljs-keyword">set</span>&gt;
        <span class="hljs-keyword">where</span> <span class="hljs-property">id</span> = ${<!-- --><span class="hljs-property">item</span>.<span class="hljs-property">id</span>}
    &lt;/foreach&gt;      
&lt;/update&gt;</code></pre> 
<p>比较普通的写法，是通过循环，依次执行update语句。</p> 
<p>方法二：</p> 
<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-operator"><span class="hljs-keyword">UPDATE</span> TStudent <span class="hljs-keyword">SET</span> Name = R.name, Age = R.age
<span class="hljs-keyword">from</span> (
<span class="hljs-keyword">SELECT</span> <span class="hljs-string">'Mary'</span> <span class="hljs-keyword">as</span> name, <span class="hljs-number">12</span> <span class="hljs-keyword">as</span> age, <span class="hljs-number">42</span> <span class="hljs-keyword">as</span> id
<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
<span class="hljs-keyword">select</span> <span class="hljs-string">'John'</span> <span class="hljs-keyword">as</span> name , <span class="hljs-number">16</span> <span class="hljs-keyword">as</span> age, <span class="hljs-number">43</span> <span class="hljs-keyword">as</span> id
) <span class="hljs-keyword">as</span> r 
<span class="hljs-keyword">where</span> ID = R.id</span></code></pre> 
<p>情景二：更新多条记录的同一个字段为同一个值</p> 
<pre class="prettyprint"><code class=" hljs cs"> &lt;update id=<span class="hljs-string">"updateOrders"</span> parameterType=<span class="hljs-string">"java.util.List"</span>&gt;
     update orders <span class="hljs-keyword">set</span> state = <span class="hljs-string">'0'</span> <span class="hljs-keyword">where</span> no <span class="hljs-keyword">in</span>
     &lt;<span class="hljs-keyword">foreach</span> collection=<span class="hljs-string">"list"</span> item=<span class="hljs-string">"id"</span> open=<span class="hljs-string">"("</span> separator=<span class="hljs-string">","</span> close=<span class="hljs-string">")"</span>&gt;
   <span class="hljs-preprocessor">#{id}</span>
     &lt;/<span class="hljs-keyword">foreach</span>&gt;
 &lt;/update&gt;</code></pre> 
<h3 id="四delete">四、delete</h3> 
<p>一个简单的delete：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 删除学生 --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">delete</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"deleteStudent"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"StudentEntity"</span>&gt;</span>  
        DELETE FROM STUDENT_TBL WHERE STUDENT_ID = #{studentID}  
<span class="hljs-tag">&lt;/<span class="hljs-title">delete</span>&gt;</span>  </code></pre> 
<p><strong>delete语句属性配置细节同update</strong></p> 
<h5 id="批量删除"><strong>批量删除：</strong></h5> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 通过主键集合批量删除记录 --&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">delete</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"batchRemoveUserByPks"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"java.util.List"</span>&gt;</span>

DELETE FROM LD_USER WHERE ID in 

<span class="hljs-tag">&lt;<span class="hljs-title">foreach</span> <span class="hljs-attribute">item</span>=<span class="hljs-value">"item"</span> <span class="hljs-attribute">index</span>=<span class="hljs-value">"index"</span> <span class="hljs-attribute">collection</span>=<span class="hljs-value">"list"</span> <span class="hljs-attribute">open</span>=<span class="hljs-value">"("</span> <span class="hljs-attribute">separator</span>=<span class="hljs-value">","</span> <span class="hljs-attribute">close</span>=<span class="hljs-value">")"</span>&gt;</span>

#{item}

<span class="hljs-tag">&lt;/<span class="hljs-title">foreach</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">delete</span>&gt;</span></code></pre> 
<h3 id="五sql">五、sql</h3> 
<p>Sql元素用来定义一个可以复用的SQL 语句段，供其它语句调用。比如：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 复用sql语句  查询student表所有字段 --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">sql</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"selectStudentAll"</span>&gt;</span>  
        SELECT ST.STUDENT_ID,  
                   ST.STUDENT_NAME,  
                   ST.STUDENT_SEX,  
                   ST.STUDENT_BIRTHDAY,  
                   ST.CLASS_ID  
              FROM STUDENT_TBL ST  
<span class="hljs-tag">&lt;/<span class="hljs-title">sql</span>&gt;</span>  </code></pre> 
<p>这样，在select的语句中就可以直接引用使用了，将上面select语句改成：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 查询学生，根据id --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"getStudent"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"String"</span> <span class="hljs-attribute">resultMap</span>=<span class="hljs-value">"studentResultMap"</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-title">include</span> <span class="hljs-attribute">refid</span>=<span class="hljs-value">"selectStudentAll"</span>/&gt;</span>  
            WHERE ST.STUDENT_ID = #{studentID}   
<span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span>  </code></pre> 
<h3 id="六parameters">六、parameters</h3> 
<p>上面很多地方已经用到了参数，比如查询、修改、删除的条件，插入，修改的数据等，MyBatis可以使用Java的基本数据类型和Java的复杂数据类型。如：基本数据类型，String，int，date等。</p> 
<p>但是使用基本数据类型，只能提供一个参数，所以需要使用Java实体类，或Map类型做参数类型。通过#{}可以直接得到其属性。</p> 
<h5 id="1基本类型参数"><strong>1、基本类型参数</strong></h5> 
<p>根据入学时间，检索学生列表：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 查询学生list，根据入学时间  --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"getStudentListByDate"</span>  <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"Date"</span> <span class="hljs-attribute">resultMap</span>=<span class="hljs-value">"studentResultMap"</span>&gt;</span>  
    SELECT *  
      FROM STUDENT_TBL ST LEFT JOIN CLASS_TBL CT ON ST.CLASS_ID = CT.CLASS_ID  
     WHERE CT.CLASS_YEAR = #{classYear};      
<span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span>  </code></pre> 
<pre class="prettyprint"><code class=" hljs avrasm">List&lt;StudentEntity&gt; studentList = studentMapper<span class="hljs-preprocessor">.getStudentListByClassYear</span>(StringUtil<span class="hljs-preprocessor">.parse</span>(<span class="hljs-string">"2007-9-1"</span>))<span class="hljs-comment">;  </span>
for (StudentEntity entityTemp : studentList) {  
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(entityTemp<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;  </span>
} </code></pre> 
<h5 id="2java实体类型参数"><strong>2、Java实体类型参数</strong></h5> 
<p>根据姓名和性别，检索学生列表。使用实体类做参数：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 查询学生list，like姓名、=性别，参数entity类型 --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"getStudentListWhereEntity"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"StudentEntity"</span> <span class="hljs-attribute">resultMap</span>=<span class="hljs-value">"studentResultMap"</span>&gt;</span>  
    SELECT * from STUDENT_TBL ST  
        WHERE ST.STUDENT_NAME LIKE CONCAT(CONCAT('%', #{studentName}),'%')  
          AND ST.STUDENT_SEX = #{studentSex}  
<span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span>  </code></pre> 
<pre class="prettyprint"><code class=" hljs avrasm">StudentEntity entity = new StudentEntity()<span class="hljs-comment">;  </span>
entity<span class="hljs-preprocessor">.setStudentName</span>(<span class="hljs-string">"李"</span>)<span class="hljs-comment">;  </span>
entity<span class="hljs-preprocessor">.setStudentSex</span>(<span class="hljs-string">"男"</span>)<span class="hljs-comment">;  </span>
List&lt;StudentEntity&gt; studentList = studentMapper<span class="hljs-preprocessor">.getStudentListWhereEntity</span>(entity)<span class="hljs-comment">;  </span>
for (StudentEntity entityTemp : studentList) {  
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(entityTemp<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;  </span>
}  </code></pre> 
<h5 id="3map参数"><strong>3、Map参数</strong></h5> 
<p>根据姓名和性别，检索学生列表。使用Map做参数：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 查询学生list，=性别，参数map类型 --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"getStudentListWhereMap"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"Map"</span> <span class="hljs-attribute">resultMap</span>=<span class="hljs-value">"studentResultMap"</span>&gt;</span>  
    SELECT * from STUDENT_TBL ST  
     WHERE ST.STUDENT_SEX = #{sex}  
          AND ST.STUDENT_SEX = #{sex}  
<span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span>  </code></pre> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-built_in">Map</span><span class="hljs-subst">&lt;</span><span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span><span class="hljs-subst">&gt;</span> <span class="hljs-built_in">map</span> <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> HashMap<span class="hljs-subst">&lt;</span><span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span><span class="hljs-subst">&gt;</span>();  
<span class="hljs-built_in">map</span><span class="hljs-built_in">.</span>put(<span class="hljs-string">"sex"</span>, <span class="hljs-string">"女"</span>);  
<span class="hljs-built_in">map</span><span class="hljs-built_in">.</span>put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"李"</span>);  
<span class="hljs-built_in">List</span><span class="hljs-subst">&lt;</span>StudentEntity<span class="hljs-subst">&gt;</span> studentList <span class="hljs-subst">=</span> studentMapper<span class="hljs-built_in">.</span>getStudentListWhereMap(<span class="hljs-built_in">map</span>);  
for (StudentEntity entityTemp : studentList) {  
    System<span class="hljs-built_in">.</span>out<span class="hljs-built_in">.</span>println(entityTemp<span class="hljs-built_in">.</span>toString());  
}  </code></pre> 
<h5 id="4多参数的实现"><strong>4、多参数的实现</strong></h5> 
<p>如果想传入多个参数，则需要在接口的参数上添加@Param注解。给出一个实例： <br> 接口写法：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> List&lt;StudentEntity&gt; <span class="hljs-title">getStudentListWhereParam</span>(@<span class="hljs-title">Param</span>(<span class="hljs-keyword">value</span> = <span class="hljs-string">"name"</span>) String name, @Param(<span class="hljs-keyword">value</span> = <span class="hljs-string">"sex"</span>) String sex, @Param(<span class="hljs-keyword">value</span> = <span class="hljs-string">"birthday"</span>) Date birthdar, @Param(<span class="hljs-keyword">value</span> = <span class="hljs-string">"classEntity"</span>) ClassEntity classEntity);  </code></pre> 
<p>sql写法：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">&lt;!-- 查询学生list，<span class="hljs-keyword">like</span>姓名、=性别、=生日、=班级，多参数方式 --&gt;  
&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">"getStudentListWhereParam"</span> resultMap=<span class="hljs-string">"studentResultMap"</span>&gt;  
    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> STUDENT_TBL ST  
    &lt;<span class="hljs-keyword">where</span>&gt;  
        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">"name!=null and name!='' "</span>&gt;  
            ST.STUDENT_NAME <span class="hljs-keyword">LIKE</span> CONCAT(CONCAT(<span class="hljs-comment">'%', #{name}),'%')  </span>
        &lt;/<span class="hljs-keyword">if</span>&gt;  
        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">"sex!= null and sex!= '' "</span>&gt;  
            <span class="hljs-keyword">AND</span> ST.STUDENT_SEX = <span class="hljs-preprocessor">#{sex}  </span>
        &lt;/<span class="hljs-keyword">if</span>&gt;  
        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">"birthday!=null"</span>&gt;  
            <span class="hljs-keyword">AND</span> ST.STUDENT_BIRTHDAY = <span class="hljs-preprocessor">#{birthday}  </span>
        &lt;/<span class="hljs-keyword">if</span>&gt;  
        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">"classEntity!=null and classEntity.classID !=null and classEntity.classID!='' "</span>&gt;  
            <span class="hljs-keyword">AND</span> ST.CLASS_ID = <span class="hljs-preprocessor">#{classEntity.classID}  </span>
        &lt;/<span class="hljs-keyword">if</span>&gt;  
    &lt;/<span class="hljs-keyword">where</span>&gt;  
&lt;/<span class="hljs-keyword">select</span>&gt;  </code></pre> 
<p>进行查询：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">List&lt;StudentEntity&gt; studentList = studentMapper<span class="hljs-preprocessor">.getStudentListWhereParam</span>(<span class="hljs-string">""</span>,<span class="hljs-string">""</span>,StringUtil<span class="hljs-preprocessor">.parse</span>(<span class="hljs-string">"1985-05-28"</span>), classMapper<span class="hljs-preprocessor">.getClassByID</span>(<span class="hljs-string">"20000002"</span>))<span class="hljs-comment">;  </span>
for (StudentEntity entityTemp : studentList) {  
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(entityTemp<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;  </span>
}  </code></pre> 
<h3 id="七与的区别">七、#{}与${}的区别</h3> 
<p>默认情况下,使用#{}语法,MyBatis会产生PreparedStatement语句中，并且安全的设置PreparedStatement参数，这个过程中MyBatis会进行必要的安全检查和转义。 <br> 示例1： <br> 执行SQL：Select * from emp where name = #{employeeName} <br> 参数：employeeName=&gt;Smith <br> 解析后执行的SQL：Select * from emp where name = ？ <br> 执行SQL：Select * from emp where name = ${employeeName} <br> 参数：employeeName传入值为：Smith <br> 解析后执行的SQL：Select * from emp where name =Smith</p> 
<p>说明： <br> 1. <code>#</code>将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #{user_id}，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”. <br> 2. <code>$</code>将传入的数据直接显示生成在sql中。如：order by ${user_id}，如果传入的值是111,那么解析成sql时的值为order by 111, 如果传入的值是id，则解析成的sql为order by id.</p> 
<p>综上所述,<code>${}</code>方式会引发SQL注入的问题、同时也会影响SQL语句的预编译，所以从安全性和性能的角度出发，能使用#{}的情况下就不要使用${}。</p> 
<p>${}在什么情况下使用呢？</p> 
<p>有时候可能需要直接插入一个不做任何修改的字符串到SQL语句中。这时候应该使用${}语法。</p> 
<p>比如，动态SQL中的字段名，如：ORDER BY ${columnName}</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-subst">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-subst">=</span><span class="hljs-string">"queryMetaList"</span> resultType<span class="hljs-subst">=</span><span class="hljs-string">"Map"</span> statementType<span class="hljs-subst">=</span><span class="hljs-string">"STATEMENT"</span><span class="hljs-subst">&gt;</span>
    <span class="hljs-keyword">Select</span> <span class="hljs-subst">*</span> from emp <span class="hljs-keyword">where</span> name <span class="hljs-subst">=</span> ${employeeName} <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ${columnName}
<span class="hljs-subst">&lt;</span>/<span class="hljs-keyword">select</span><span class="hljs-subst">&gt;</span> </code></pre> 
<p>由于<code>${}</code>仅仅是简单的取值,所以以前sql注入的方法适用此处,如果我们order by语句后用了${},那么不做任何处理的时候是存在sql注入危险的。</p> 
<blockquote> 
 <p>参考文章：<a href="http://limingnihao.iteye.com/blog/781911" rel="nofollow">http://limingnihao.iteye.com/blog/781911</a> <br> <a href="http://www.tuicool.com/articles/zyUjqiJ" rel="nofollow">http://www.tuicool.com/articles/zyUjqiJ</a> <br> <a href="http://blog.csdn.net/szwangdf/article/details/26714603">http://blog.csdn.net/szwangdf/article/details/26714603</a></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80fe48099457becadb262a277a9674d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java对象和引用变量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9dad02c6b707dfbfb73793b86972e787/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MyBatis——动态SQL讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>