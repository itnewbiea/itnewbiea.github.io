<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之桥接模式（Bridge模式） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之桥接模式（Bridge模式）" />
<meta property="og:description" content="一、模式动机 设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：
• 第一种设计方案是为每一种形状都提供一套各种颜色的版本。
• 第二种设计方案是根据实际需要对形状和颜色进行组合。
对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。
当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。
二、桥接模式的定义 桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。通过上面的讲解，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。
结构如下：
桥接模式包含如下角色：
• Abstraction：抽象类
• RefinedAbstraction：扩充抽象类
• Implementor：实现类接口
• ConcreteImplementor：具体实现类
三、具体实例 实例一：模拟毛笔
• 现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3&#43;5=8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。
/// &lt;summary&gt; /// 定义颜色类接口 /// &lt;/summary&gt; public interface Color { void bepaint(String penType, String name); } /// &lt;summary&gt; /// 定义笔抽象类 /// &lt;/summary&gt; public abstract class Pen { protected Color color; public void setColor(Color color) { this.color = color; } public abstract void draw(String name); } //扩充抽象类 public class SmallPen : Pen { public override void draw(String name) { String penType = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5639b441832aaa58c6c98c410d427652/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-13T11:27:59+08:00" />
<meta property="article:modified_time" content="2020-10-13T11:27:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之桥接模式（Bridge模式）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、模式动机</h4> 
<p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p> 
<p>        • 第一种设计方案是为每一种形状都提供一套各种颜色的版本。</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/c2/78/o7S6ticp_o.png" width="368"></p> 
<p>  • 第二种设计方案是根据实际需要对形状和颜色进行组合。</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/95/05/OWAXe4eo_o.png" width="594"> </p> 
<p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p> 
<p>当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。</p> 
<h4>二、桥接模式的定义</h4> 
<p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。通过上面的讲解，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。</p> 
<p>结构如下：</p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/50/c7/ZATW53gi_o.png" width="742"></p> 
<p>桥接模式包含如下角色：</p> 
<p>    • <strong>Abstraction</strong>：抽象类</p> 
<p>    • <strong>RefinedAbstraction</strong>：扩充抽象类</p> 
<p>    • <strong>Implementor</strong>：实现类接口</p> 
<p>    • <strong>ConcreteImplementor</strong>：具体实现类</p> 
<h4>三、具体实例</h4> 
<p><strong>实例一：模拟毛笔</strong></p> 
<p>    • 现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。</p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/1a/da/7qNyBGgx_o.png" width="949"></p> 
<pre><code class="language-cs">   /// &lt;summary&gt;
    /// 定义颜色类接口
    /// &lt;/summary&gt;
    public interface Color
    {
        void bepaint(String penType, String name);
    }
    /// &lt;summary&gt;
    /// 定义笔抽象类
    /// &lt;/summary&gt;
    public abstract class Pen
    {
        protected Color color;
        public void setColor(Color color)
        {
            this.color = color;
        }
        public abstract void draw(String name);
    }

    //扩充抽象类
    public class SmallPen : Pen
    {
        public override void draw(String name)
        {
            String penType = "小号毛笔绘制";
            this.color.bepaint(penType, name);
        }

    }

    //扩充抽象类
    public class MiddlePen : Pen
    {
        public override void draw(String name)
        {
            String penType = "中号毛笔绘制";
            this.color.bepaint(penType, name);
        }
    }

    //扩充抽象类
    public class BigPen : Pen
    {
        public override void draw(String name)
        {
            String penType = "大号毛笔绘制";
            this.color.bepaint(penType, name);
        }
    }



    //扩充颜色类
    public class Red : Color
    {
        public void bepaint(String penType, String name)
        {
            Console.WriteLine(penType + "红色的" + name + ".");
        }
    }

    //扩充颜色类
    public class Green : Color
    {
        public void bepaint(String penType, String name)
        {
            Console.WriteLine(penType + "绿色的" + name + ".");
        }
    }

    // 扩充颜色类
    public class Blue : Color
    {
        public void bepaint(String penType, String name)
        {
            Console.WriteLine(penType + "蓝色的" + name + ".");
        }
    }

    //扩充实现类
    public class White : Color
    {
        public void bepaint(String penType, String name)
        {
            Console.WriteLine(penType + "白色的" + name + ".");
        }
    }


    public class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Color color1 = new Red();
                Pen pen = new SmallPen();
                pen.setColor(color1);
                pen.draw("鲜花");

                Color color2 = new Green();
                pen = new BigPen();
                pen.setColor(color2);
                pen.draw("叶子");
                Console.ReadKey();
            }
            catch (Exception e)
            {

            }
        }
    }
</code></pre> 
<p> <img alt="" height="261" src="https://images2.imgbox.com/25/31/en3q5sgI_o.png" width="511"></p> 
<p><strong>实例二：跨平台视频播放器</strong></p> 
<p>    • 如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。</p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/cc/60/Ghus6JV1_o.png" width="915"></p> 
<h4>四、模式使用场景</h4> 
<ul><li>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li><li>3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li></ul> 
<h4>五、总结</h4> 
<p>通过上面的讲解，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。这里将桥接模式的优缺点总结如下。<br><br> 桥接（Bridge）模式的优点是：</p> 
<ul><li>抽象与实现分离，扩展能力强</li><li>符合开闭原则</li><li>符合合成复用原则</li><li>其实现细节对客户透明</li></ul> 
<p><br> 缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</p> 
<p>参考：</p> 
<p><a href="https://www.cnblogs.com/WindSun/p/10260547.html" rel="nofollow">https://www.cnblogs.com/WindSun/p/10260547.html</a></p> 
<p><a href="http://c.biancheng.net/view/1364.html" rel="nofollow">http://c.biancheng.net/view/1364.html</a></p> 
<p><a href="https://www.runoob.com/w3cnote/bridge-pattern2.html" rel="nofollow">https://www.runoob.com/w3cnote/bridge-pattern2.html</a></p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96ea80b7967d79776160966ac13ae2e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uiscrollview  取消顶部默认间距</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c2a9ef5748294c82ef783cdca113fe2b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CSS-事件 -单击双击、失去or获得焦点、加载事件、鼠标事件、键盘事件、选择与改变、表单事件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>