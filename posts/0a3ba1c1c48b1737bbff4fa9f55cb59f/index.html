<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue跨域实现：proxy配置 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue跨域实现：proxy配置" />
<meta property="og:description" content="一、什么是跨域 要了解跨域，首先得知道浏览器的同源策略。
同源策略：是由Netscape提出的一个安全策略，能够阻挡恶意文档，保护本地数据。它能限制一个源的文档或脚本对另一个源的交互，使得其它源的文档或脚本，无法读取或修改当前源。
是否同源：当两个url的域名、协议和端口均相同。
举例来说：url： http://127.0.0.1:80/demo/01.html 中组成部分如下图所示：
url是否同源原因 http://127.0.0.1:80/demo/02.html http://127.0.0.1:80/demo2/01.html 同源协议、域名、端口均相同，只是文件地址不同http://127.0.0.1:90/demo/01.html不同源端口不同http://127.1.1.1:80/demo/01.html不同源域名不同https://127.0.0.1:80/demo/01.html不同源协议不同http://127.0.0.1/demo/01.html同源http:// 默认端口是 80 不同协议有不同的默认端口，当未指定端口时，则使用默认端口。
跨域：能实现在不同源之间的资源交互。
为什么要跨域：因为所有的资源有可能不在同一个域内，比如一个公司有很多子域，中间的通信就需要跨域。
二、vue项目跨域vue.config.js文件配置 1. publicPath配置
publicPath是部署时的基本url，一般情况下vue项目起什么名称，publicPath就赋值什么名称。
假设一个项目的初始地址为： http://127.0.0.1:80/，若是配置上publicPath: &#34;/demo&#34;，则项目的初始地址则会变成http://127.0.0.1:80/demo/。
vue打包后的静态文件资源需要访问，所以需要一个文件路径放置vue的打包文件，后端nginx中对应配置的也是这个地址。
2. devServer.proxy代理配置
该字段主要是为了实现前后端通信的，当前后端分离开发，为了让前端开发人员在开发时访问到后端的接口，需要进行nginx配置实现跨域请求。
参考这个同学的文章：vue配置反向代理 devServer配置proxy，说明如下：
// vue.config.js文件 module.exports = { //..... devServer: { host: &#39;localhost&#39;, port: 8080, proxy: { &#34;/api&#34;: { target: &#34;http://www.xxx.com&#34;, // 请求到/api/xx 就会被代理http://www.xxx.com/api/xxx // secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 接口跨域 需打开这个参数 pathRewrite: { &#39;^/api&#39;: &#39;&#39;, // 忽略前缀/api 则会被代理到http://www.xxx.com/xxx }, } } }, } 其实很好理解，简单来说就是给实际的接口路径做了一层代理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0a3ba1c1c48b1737bbff4fa9f55cb59f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-20T17:42:43+08:00" />
<meta property="article:modified_time" content="2023-06-20T17:42:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue跨域实现：proxy配置</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、什么是跨域</h4> 
<p>要了解跨域，首先得知道浏览器的<strong>同源策略。</strong></p> 
<p><strong>同源策略：</strong>是由<a href="https://baike.baidu.com/item/Netscape/2778944?fromModule=lemma_inlink" rel="nofollow" title="Netscape">Netscape</a>提出的一个安全策略，能够阻挡恶意文档，保护本地数据。它能限制一个源的文档或脚本对另一个源的交互，使得其它源的文档或脚本，无法读取或修改当前源。</p> 
<p><strong>是否同源：</strong>当两个url的域名、协议和端口均相同。</p> 
<p><strong>举例来说</strong>：url： <span style="text-align:center;">http://127.0.0.1:80</span><span style="text-align:center;">/demo/01.html </span>中组成部分如下图所示：</p> 
<p class="img-center"><img alt="" height="77" src="https://images2.imgbox.com/54/de/0OfLwHvX_o.png" width="316"></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>url</td><td style="width:86px;">是否同源</td><td style="width:177px;">原因</td></tr><tr><td> <p> http://127.0.0.1:80/demo/02.html </p> <p> http://127.0.0.1:80/demo2/01.html </p> </td><td style="width:86px;">同源</td><td style="width:177px;">协议、域名、端口均相同，只是文件地址不同</td></tr><tr><td>http://127.0.0.1:90/demo/01.html</td><td style="width:86px;">不同源</td><td style="width:177px;">端口不同</td></tr><tr><td>http://127.1.1.1:80/demo/01.html</td><td style="width:86px;">不同源</td><td style="width:177px;">域名不同</td></tr><tr><td>https://127.0.0.1:80/demo/01.html</td><td style="width:86px;">不同源</td><td style="width:177px;">协议不同</td></tr><tr><td>http://127.0.0.1/demo/01.html</td><td style="width:86px;">同源</td><td style="width:177px;"><code>http://</code> 默认端口是 80</td></tr></tbody></table> 
<p>不同协议有不同的默认端口，当未指定端口时，则使用默认端口。</p> 
<p><strong>跨域：</strong>能实现在不同源之间的资源交互。</p> 
<p><strong>为什么要跨域：</strong>因为所有的资源有可能不在同一个域内，比如一个公司有很多子域，中间的通信就需要跨域。</p> 
<h4>二、vue项目跨域vue.config.js文件配置</h4> 
<p><strong>1. publicPath配置</strong></p> 
<p>publicPath是部署时的基本url，一般情况下vue项目起什么名称，publicPath就赋值什么名称。</p> 
<p>假设一个项目的初始地址为： http://127.0.0.1:80/，若是配置上publicPath: "/demo"，则项目的初始地址则会变成http://127.0.0.1:80/demo/。</p> 
<p>vue打包后的静态文件资源需要访问，所以需要一个文件路径放置vue的打包文件，后端nginx中对应配置的也是这个地址。</p> 
<p><strong>2. devServer.proxy代理配置</strong></p> 
<p>该字段主要是为了实现前后端通信的，当前后端分离开发，为了让前端开发人员在开发时访问到后端的接口，需要进行nginx配置实现跨域请求。</p> 
<p>参考这个同学的文章：<a class="link-info" href="https://www.jianshu.com/p/d82d673b714d" rel="nofollow" title="vue配置反向代理 devServer配置proxy">vue配置反向代理 devServer配置proxy</a>，说明如下：</p> 
<pre><code class="hljs">// vue.config.js文件
module.exports = {
//.....
  devServer: {
    host: 'localhost',
    port: 8080,
    proxy: {
      "/api": {
        target: "http://www.xxx.com", // 请求到/api/xx 就会被代理http://www.xxx.com/api/xxx
        //  secure: false, // 如果是https接口，需要配置这个参数
        changeOrigin: true, // 接口跨域 需打开这个参数
        pathRewrite: {
          '^/api': '', // 忽略前缀/api  则会被代理到http://www.xxx.com/xxx
        },
      }
    }
  },
}</code></pre> 
<p>其实很好理解，简单来说就是给实际的接口路径做了一层代理。</p> 
<p><strong>”/api”含义：</strong>匹配以”/api”开头接口，</p> 
<p><strong>target参数含义：</strong>默认将上面的"/api"拼接到该值的后面，映射成代理的实际路径。</p> 
<p>举例：请求接口时如果写的是“/api/xxx”，使用代理后生成的实际请求路径就是’http://www.xxx.com/api/xxx’。</p> 
<p><strong>pathRewrite参数含义：</strong>路径重写，如果要请求的接口里面没有公共的api，直接从根目录开始的，那就需要把"/api"去掉或换成其它别的字符。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a96f8ee18556541e503311d5a1cd38a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32 RGB屏幕</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/acc8c0cf778d3a4871f7fe264c1c0ab1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java使用jna调用c开发的动态库dll文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>