<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件测试中单元测试，集成测试，系统测试，验收测试的区别 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件测试中单元测试，集成测试，系统测试，验收测试的区别" />
<meta property="og:description" content="软件测试按照研发阶段一般分为5个部分：单元测试、集成测试、确认测试、系统测试、验收测试，下面将不同阶段需要的一些工作内容做一下梳理希望可以帮助到大家。
单元测试（是指对软件中的最小可测试单元进行检查和验证，测试方法：白盒测试）
单元测试又称为模块测试，是针对软件设计的最小单位程序模块进行正确性检查的测试工作，单元测试需要从程序内部结构出发设计测试用例，多个模块可以平行地独立进行单元测试。
一、单元测试的内容：
1、模块接口测试
应对通过所测模块的数据流进行测试
调用所测模块时的输入参数与模块的形式参数的个数、属性和顺序是否匹配
所测模块调用子模块时，输入子模块的参数与子模块的形式参数在个数、属性和顺序上是否匹配。
输出给标准函数的参数的个数、属性和顺序是否正确。
全局变量的定义在各个模块中是否一致。
当模块通过外部设备进行输入/输出操作，文件属性是否正确、open和close语句是否正确，规定的I/O格式说明与I/O语句是否匹配；缓冲区容量是否与记录长度匹配，在读写之前是否打开了文件，读写之后是否关闭了文件，对I/O错误是否做了处理。
2、 局部数据结构测试
局部数据结构是最常见的错误来源
不一致的数据类型
不正确或不一致的数据说明
使用尚未赋值或尚未初始化的变量
错误的初始值或错误的缺省值
3、 路径测试
运算的优先次序、常见的比较和控制流
4、错误处理测试
遇见出错的条件，并设置适当的出错处理
5、边界测试
例如循环的次数，最大或最小值
二、单元测试步骤：
利用设计文档设计测试用例；
创建被测模块的桩模块或驱动模块；
利用被测试模块、驱动模块和桩模块来建立测试环境，进行测试
驱动模块：相当于所测模块的主程序，它接收测试数据，把这些数据传送给所测模块，最后再输出实际结果
桩模块：用以代替所测模块调用的子模块。
集成测试（也叫组装测试或联合测试，测试方法：灰盒测试）
在单元测试的基础上，需要将所有模块按照概要设计说明书和详细设计说明书的要求进行组装。
在把各个模块连接起来的时候，穿越各个模块的接口的数据时候会丢失
一个模块的功能是否会对另一个模块的功能产生不利的影响
各个子功能组装完成后，能否达到预期的父功能
全局数据结构是否有问题
单个模块产生的误差累计起来是否会放大
模块组装成系统的方式：一次性组装方式和增殖式组装方式
一、一次性组装方式
先对模块分别进行测试，再把所有模块组装进行测试
缺点：发现错误不容易定位 二、增值式组装测试
先对一个个模块进行模块测试，然后将这些模块逐步组装成系统，分为两种方式：自顶向下的增殖方式和自底向上的增殖方式
1、自顶向下的增殖方式（不需要驱动模块）
将模块铵系统程序结构，严控制层次自顶向下进行组装。
首先以主模块作为被测模块兼驱动模块，所有直属主模块的下属模块全部用桩模块代替，对主模块进行测试。再采用深度优先或广度优先的策略，用实际模块代替桩模块，再用桩模块代替它们的直接下属模块，与已经测试的模块构成新的子系统。然后进行回归测试。
2、自底向上的增殖方式（不需要驱动模块）
由驱动模块控制最底层模块的并行测试。
3、混合增殖式
自顶向下增殖方式：
优点：能够较早的发现主要控制方面的问题
缺点：需要建立桩模块，增加了一些附加的测试，涉及算法和输入输出的模块一般在底层，这些底层模块要到组装和测试的后期才能发现。一旦发现问题就会出现过多的回归测试。
自底向上增殖方式：
优点：不需要建立桩模块，建立驱动模块要比建立桩模块要简单得多，同时涉及到算法已近输入输出的模块要先测试，把最容易出现问题的部分在早期解决。
缺点：程序一直未能作为一个实体存在，直到最后一个模块加上才能形成一个实体,控制方面最后才能接触。
三、集成测试完成的标志：
1、成功执行了测试计划中规定的所有集成测试
2、修改了所发现的错误
3、测试结果通过专门小组的评审
4、集成测试需要提交的测试报告：
5、集成测试计划、集成测试规格说明书以及集成测试分析报告
四、集成测试策略： 1) 大爆炸集成 2) 自顶向下集成 3) 自底向上集成 4) 三明治（混合式）集成 5) 基干集成 6) 分层集成 7) 基于功能的集成 8) 基于消息的集成 9) 基于进度的集成 10) 基于风险的集成" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8e7c5fa88bbabcac0b53f05d30d843de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-16T17:15:04+08:00" />
<meta property="article:modified_time" content="2019-09-16T17:15:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件测试中单元测试，集成测试，系统测试，验收测试的区别</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>软件测试按照研发阶段一般分为5个部分：单元测试、集成测试、确认测试、系统测试、验收测试，下面将不同阶段需要的一些工作内容做一下梳理希望可以帮助到大家。</p> 
<p><span style="color:#f33b45;"><strong>单元测试（</strong></span>是指对软件中的最小可测试单元进行检查和验证，<span style="color:#ffbb66;">测试方法：白盒测试</span><span style="color:#f33b45;"><strong>）</strong></span></p> 
<p>单元测试又称为模块测试，是针对软件设计的最小单位程序模块进行正确性检查的测试工作，单元测试需要从程序内部结构出发设计测试用例，多个模块可以平行地独立进行单元测试。</p> 
<p>一、单元测试的内容：</p> 
<p>1<span style="color:#e579b6;">、模块接口测试</span></p> 
<ul><li> <p>应对通过所测模块的数据流进行测试</p> </li><li> <p>调用所测模块时的输入参数与模块的形式参数的个数、属性和顺序是否匹配</p> </li><li> <p>所测模块调用子模块时，输入子模块的参数与子模块的形式参数在个数、属性和顺序上是否匹配。</p> </li><li> <p>输出给标准函数的参数的个数、属性和顺序是否正确。</p> </li><li> <p>全局变量的定义在各个模块中是否一致。</p> </li><li> <p>当模块通过外部设备进行输入/输出操作，文件属性是否正确、open和close语句是否正确，规定的I/O格式说明与I/O语句是否匹配；缓冲区容量是否与记录长度匹配，在读写之前是否打开了文件，读写之后是否关闭了文件，对I/O错误是否做了处理。</p> </li></ul> 
<p>2、<span style="color:#e579b6;"> 局部数据结构测试</span></p> 
<ul><li> <p>局部数据结构是最常见的错误来源</p> </li><li> <p>不一致的数据类型</p> </li><li> <p>不正确或不一致的数据说明</p> </li><li> <p>使用尚未赋值或尚未初始化的变量</p> </li><li> <p>错误的初始值或错误的缺省值</p> </li></ul> 
<p>3<span style="color:#e579b6;">、 路径测试</span></p> 
<p>运算的优先次序、常见的比较和控制流</p> 
<p>4、<span style="color:#e579b6;">错误处理测试</span></p> 
<p>遇见出错的条件，并设置适当的出错处理</p> 
<p>5、<span style="color:#e579b6;">边界测试</span></p> 
<p>例如循环的次数，最大或最小值</p> 
<p> </p> 
<p>二、单元测试步骤：</p> 
<p>利用设计文档设计测试用例；</p> 
<ul><li> <p>创建被测模块的桩模块或驱动模块；</p> </li><li> <p>利用被测试模块、驱动模块和桩模块来建立测试环境，进行测试</p> </li><li> <p>驱动模块：相当于所测模块的主程序，它接收测试数据，把这些数据传送给所测模块，最后再输出实际结果</p> </li><li> <p>桩模块：用以代替所测模块调用的子模块。</p> </li></ul> 
<p> </p> 
<p><span style="color:#f33b45;"><strong>集成测试（</strong></span>也叫<a href="https://www.baidu.com/s?wd=%E7%BB%84%E8%A3%85%E6%B5%8B%E8%AF%95&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">组装测试</a>或联合测试，<span style="color:#ffbb66;">测试方法：灰盒测试</span><span style="color:#f33b45;"><strong>）</strong></span></p> 
<p>  在单元测试的基础上，需要将所有模块按照概要设计说明书和详细设计说明书的要求进行组装。</p> 
<ul><li> <p>在把各个模块连接起来的时候，穿越各个模块的接口的数据时候会丢失</p> </li><li> <p>一个模块的功能是否会对另一个模块的功能产生不利的影响</p> </li><li> <p>各个子功能组装完成后，能否达到预期的父功能</p> </li><li> <p>全局数据结构是否有问题</p> </li><li> <p>单个模块产生的误差累计起来是否会放大</p> </li></ul> 
<p>模块组装成系统的方式：一次性组装方式和增殖式组装方式</p> 
<p>一、一次性组装方式</p> 
<p>先对模块分别进行测试，再把所有模块组装进行测试</p> 
<p>  缺点：发现错误不容易定位 </p> 
<p>二、增值式组装测试</p> 
<p>先对一个个模块进行模块测试，然后将这些模块逐步组装成系统，分为两种方式：自顶向下的增殖方式和自底向上的增殖方式</p> 
<p>1、自顶向下的增殖方式（不需要驱动模块）</p> 
<p>将模块铵系统程序结构，严控制层次自顶向下进行组装。</p> 
<p>首先以主模块作为被测模块兼驱动模块，所有直属主模块的下属模块全部用桩模块代替，对主模块进行测试。再采用深度优先或广度优先的策略，用实际模块代替桩模块，再用桩模块代替它们的直接下属模块，与已经测试的模块构成新的子系统。然后进行回归测试。</p> 
<p>2、自底向上的增殖方式（不需要驱动模块）</p> 
<p>由驱动模块控制最底层模块的并行测试。</p> 
<p>3、混合增殖式</p> 
<ul><li> <p>自顶向下增殖方式：</p> </li></ul> 
<p>优点：能够较早的发现主要控制方面的问题</p> 
<p>缺点：需要建立桩模块，增加了一些附加的测试，涉及算法和输入输出的模块一般在底层，这些底层模块要到组装和测试的后期才能发现。一旦发现问题就会出现过多的回归测试。</p> 
<ul><li> <p>自底向上增殖方式：</p> </li></ul> 
<p>优点：不需要建立桩模块，建立驱动模块要比建立桩模块要简单得多，同时涉及到算法已近输入输出的模块要先测试，把最容易出现问题的部分在早期解决。</p> 
<p>缺点：程序一直未能作为一个实体存在，直到最后一个模块加上才能形成一个实体,控制方面最后才能接触。</p> 
<p>三、集成测试完成的标志：</p> 
<p>1、成功执行了测试计划中规定的所有集成测试</p> 
<p>2、修改了所发现的错误</p> 
<p>3、测试结果通过专门小组的评审</p> 
<p>4、集成测试需要提交的测试报告：</p> 
<p>5、集成测试计划、集成测试规格说明书以及集成测试分析报告</p> 
<p>四、集成测试策略： <br> 1) 大爆炸集成 2) 自顶向下集成 3) 自底向上集成 4) 三明治（混合式）集成 5) 基干集成 6) 分层集成 7) 基于功能的集成 8) 基于消息的集成 9) 基于进度的集成 10) 基于风险的集成</p> 
<p><span style="color:#f33b45;"><strong>确认测试</strong></span></p> 
<p>确认测试的目标是验证软件的功能和性能以及其他特性是否与用户的要求一致。确认测试一般包括有效性测试和软件配置复查。一般有第三方测试机构进行。</p> 
<p> 一、进行有效性测试</p> 
<p>现软件确认要通过一系列黑盒测试。确认测试同样需要制订测试计划和过程，测试计划应规定测试的种类和测试进度，测试过程则定义一些特殊的测试用例，旨在说明软件与需求是否一致。</p> 
<p>无是计划还是过程，都应该着重考虑软件是否满足合同规定的所有功能和性能，文档资料是否完整、准确人机界面和其他方面（例如，可移植性、兼容性、错误恢复能力和可维护性等）是否令用户满意。</p> 
<p>确认测试的结果有两种可能，一种是功能和性能指标满足软件需求说明的要求，用户可以接受；</p> 
<p>另一种是软件不满足软件需求说明的要求，用户无法接受。项目进行到这个阶段才发现严重错误和偏差一般很难在预定的工期内改正，因此必须与用户协商，寻求一个妥善解决问题的方法</p> 
<p>二、软件配置复查</p> 
<p>保证软件配置的所有成分齐全，质量都符合要求。应该遵守用户手册和操作手册中的规定步骤。</p> 
<p><span style="color:#f33b45;"><strong>系统测试</strong></span></p> 
<p>软件作为计算机系统的一部分，与硬件、网络、外设、支撑软件、数据以及人员结合在一起，在实际或模拟环境下，对计算机系统进行测试，</p> 
<p>目的在于与系统需求比较，发现问题；</p> 
<p>集成测试和系统测试之间的比较： <br> 1、测试内容：集成测试是测试各个单元模块之间的接口，<span style="color:#3399ea;">系统测试是测试整个系统的功能和性能</span>； <br> 2、测试角度：集成测试偏重于技术的角度进行测试，<span style="color:#3399ea;">系统测试是偏重于业务的角度进行测试</span>。</p> 
<p><span style="color:#f33b45;"><strong>验收测试（</strong></span>也称交付测试<span style="color:#f33b45;"><strong>）</strong></span></p> 
<p>以用户为主的测试，软件开发人员和质量保证人员参加，由用户设计测试用例。</p> 
<p>不是对系统进行全覆盖测试<span style="color:#3399ea;">，而是对核心业务流程进行测试；</span></p> 
<p>验收测试包括alpha测试和beta测试，alpha测试是由开发者进行的软件测试，beta测试是由用户在脱离开发环境下进行的软件测试。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e75d7a51082c67f0ab28f28ac66bfbe2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">hive中提高代码运行效率的参数配置及代码优化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86a6b662e6f12095abf7b60ba72dcdfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">十种算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>