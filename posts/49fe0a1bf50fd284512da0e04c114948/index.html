<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>论文浅尝 | 异构图 Transformer - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="论文浅尝 | 异构图 Transformer" />
<meta property="og:description" content="笔记整理：许泽众，浙江大学博士在读
论文链接：https://arxiv.org/abs/2003.01332
本文主要提出一种处理异构图的方法，所谓异构图（Heterogeneous graph）是指在一个图中会出现不同类型的边和节点的图。早期对于图的处理图的方法一般集中于同构图的处理。近年来开始关注对异构图的处理，但是一般都具有以下缺点：
1.大多涉及到为每种类型的异构图设计元路径（meta-path），但是这种元路径需要手工定义，这不仅需要领域知识，同时降低了效率；2.或者假设不同类型的节点/边共享相同的特征和表示空间，这显然是不合适的；或者单独为不同节点类型或边类型保留各自单独的非共享权重，这忽略了异构图之间的交互性；3.大多忽略了每一个（异构）图的动态特性（个人觉得这一点和之前的两点不是在解决同一个问题，应该知只是为了丰富文章内容）；4.无法对Web规模的异构图进行建模。
为了处理异构图，文章的核心思想是将每条边的模型参数分解为三个矩阵相乘。其分解根据每条边的三元组 &lt;初始节点类型，边类型，目标节点类型&gt;来定义。这就是文中所提的元关系（meta-relation）。整体的计算参照transformer。以下图为例：
对于左图这样的异构图，可以定义出不同的元关系，每个meta-relation由三部分组成。文中提出相比于R-GCN，HGT的优势在于因为使用了三部分来定义元关系，这使得模型对于出现频次较低的关系的学习能力更强（因为另外两部分出现的频次可能不低）。
整个模型的框架可以分为三部分：Heterogeneous Mutual Attention，Heterogeneous Message Passing 和 Target-Specific Aggregation。分别用来计算attention，传递信息，信息聚合。
第一部分 受transformer的启发，将目标节点映射为query，源节点映射为Key。
与传统Transformer不同的点在于：HGT中每个元关系都有一组不同的投影权重W，传统Transformer是所有单词使用同一组权重。
ATT-head表示第i个注意力头；K(s) 代表源节点s投影成的第i个Key向量；Q(t) 代表目标节点t投影成第i个Query向量；μ(·) 表示每个关系三元组的一般意义，作为对注意力自适应缩放；
Attention(·) 的操作主要是把h个 ATT-head 连接，得到每个节点对（s,t）的注意力向量；从本质上说，该操作就是对于每个目标节点t，从邻接节点N(t)收集的注意力向量，再进行一次softmax得到概率分布。
第二部分 与第一步类似，这一步也将元关系融入信息传递过程来缓解不同类型节点和边的分布差异。
第三部分 最后一部分依据前两部分的计算结果将表示更新。
文章的第二部分主要是提出相对时间编码（RTE）技术处理动态图。
传统的方法是为每个小时间片（time slot）构建图，但这种方法会丢失大量的不同时间片间的结构依赖信息。
因此，受Transformer的位置编码（position embedding）启发，作者提出RTE机制，建模异质图上的动态依赖关系。
主要思想就是将时间差的信息编码到表示中从而引入时间对表示的影响。这里有一点在于train的时候见过的时间差不能覆盖所有可能的时间差，所以作者引入以下偏置函数将时间差泛化到可见范围。
为了处理web规模的数据，设计了针对异构图的采样算法 HGSampling。它的主要思想是样本异构子图中不同类型的节点以相同的比例，并利用重要性采样降低采样中的信息损失。
本文在其之前举例的开放学术图谱上进行实验：
但是这里值得注意的是，在对各种entity进行embedding的初始化的时候，实际上添加了相当多的信息，例如对field、venue等节点，就采用了自己argue的metapath2vec模型来进行初始化，所以实验结果的有效性应该也与这种设定有较强的关系。以下是部分实验结果：
同时还给出了一个根据计算的attention自动构建的meta-path的样例：
OpenKG
OpenKG（中文开放知识图谱）旨在推动以中文为核心的知识图谱数据的开放、互联及众包，并促进知识图谱算法、工具及平台的开源开放。
点击阅读原文，进入 OpenKG 网站。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/49fe0a1bf50fd284512da0e04c114948/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-13T21:10:00+08:00" />
<meta property="article:modified_time" content="2021-10-13T21:10:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">论文浅尝 | 异构图 Transformer</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <blockquote> 
  <p style="text-align:left;">笔记整理：许泽众，浙江大学博士在读</p> 
  <p style="text-align:left;">论文链接：https://arxiv.org/abs/2003.01332</p> 
 </blockquote> 
 <p style="text-align:left;">本文主要提出一种处理异构图的方法，所谓异构图（Heterogeneous graph）是指在一个图中会出现不同类型的边和节点的图。早期对于图的处理图的方法一般集中于同构图的处理。近年来开始关注对异构图的处理，但是一般都具有以下缺点：</p> 
 <p style="text-align:left;">1.大多涉及到为每种类型的异构图设计元路径（meta-path），但是这种元路径需要手工定义，这不仅需要领域知识，同时降低了效率；2.或者假设不同类型的节点/边共享相同的特征和表示空间，这显然是不合适的；或者单独为不同节点类型或边类型保留各自单独的非共享权重，这忽略了异构图之间的交互性；3.大多忽略了每一个（异构）图的动态特性（个人觉得这一点和之前的两点不是在解决同一个问题，应该知只是为了丰富文章内容）；4.无法对Web规模的异构图进行建模。</p> 
 <p style="text-align:left;">为了处理异构图，文章的核心思想是将每条边的模型参数分解为三个矩阵相乘。其分解根据每条边的三元组 &lt;初始节点类型，边类型，目标节点类型&gt;来定义。这就是文中所提的元关系（meta-relation）。整体的计算参照transformer。以下图为例：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/66/ed/0lIqgkau_o.png" alt="e1b4f39b478037ab2fc667cfc878340f.png"></p> 
 <p style="text-align:left;">对于左图这样的异构图，可以定义出不同的元关系，每个meta-relation由三部分组成。文中提出相比于R-GCN，HGT的优势在于因为使用了三部分来定义元关系，这使得模型对于出现频次较低的关系的学习能力更强（因为另外两部分出现的频次可能不低）。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/46/82/6w0tAgu2_o.png" alt="0bedc228ffbb54efc4f819e5542a3b6d.png"></p> 
 <p style="text-align:left;">整个模型的框架可以分为三部分：Heterogeneous Mutual Attention，Heterogeneous Message Passing 和 Target-Specific Aggregation。分别用来计算attention，传递信息，信息聚合。</p> 
 <h4>第一部分</h4> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/3b/7d/rZlxusuS_o.png" alt="9b03d10b9899a45259cd0809fc06e241.png"></p> 
 <p style="text-align:left;">受transformer的启发，将目标节点映射为query，源节点映射为Key。</p> 
 <p style="text-align:left;">与传统Transformer不同的点在于：HGT中每个元关系都有一组不同的投影权重W，传统Transformer是所有单词使用同一组权重。</p> 
 <p style="text-align:left;">ATT-head表示第i个注意力头；K(s) 代表源节点s投影成的第i个Key向量；Q(t) 代表目标节点t投影成第i个Query向量；μ(·) 表示每个关系三元组的一般意义，作为对注意力自适应缩放；</p> 
 <p style="text-align:left;">Attention(·) 的操作主要是把h个 ATT-head 连接，得到每个节点对（s,t）的注意力向量；从本质上说，该操作就是对于每个目标节点t，从邻接节点N(t)收集的注意力向量，再进行一次softmax得到概率分布。</p> 
 <h4>第二部分</h4> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/44/5a/lSB0t3mh_o.png" alt="e48b9164576cc5c2240f2356eccbfc25.png"></p> 
 <p style="text-align:left;">与第一步类似，这一步也将元关系融入信息传递过程来缓解不同类型节点和边的分布差异。</p> 
 <h4>第三部分</h4> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/ca/7a/fOxgD9WT_o.png" alt="2e0b6eccb7710f6b8c007175695c8686.png"></p> 
 <p style="text-align:left;">最后一部分依据前两部分的计算结果将表示更新。</p> 
 <p style="text-align:left;">文章的第二部分主要是提出相对时间编码（RTE）技术处理动态图。</p> 
 <p style="text-align:left;">传统的方法是为每个小时间片（time slot）构建图，但这种方法会丢失大量的不同时间片间的结构依赖信息。</p> 
 <p style="text-align:left;">因此，受Transformer的位置编码（position embedding）启发，作者提出RTE机制，建模异质图上的动态依赖关系。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/57/fb/8RjCjtps_o.png" alt="5bcf0aab2dc2035658616982a4c98b58.png"></p> 
 <p style="text-align:left;">主要思想就是将时间差的信息编码到表示中从而引入时间对表示的影响。这里有一点在于train的时候见过的时间差不能覆盖所有可能的时间差，所以作者引入以下偏置函数将时间差泛化到可见范围。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/c0/67/R0Atd788_o.png" alt="0e32a0b20a973589ddebcb7645904ecd.png"></p> 
 <p style="text-align:left;">为了处理web规模的数据，设计了针对异构图的采样算法 HGSampling。它的主要思想是样本异构子图中不同类型的节点以相同的比例，并利用重要性采样降低采样中的信息损失。</p> 
 <p style="text-align:left;">本文在其之前举例的开放学术图谱上进行实验：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/59/14/OnunsdrL_o.png" alt="e9db323b04e7bce662bd64aecb600f2a.png"></p> 
 <p style="text-align:left;">但是这里值得注意的是，在对各种entity进行embedding的初始化的时候，实际上添加了相当多的信息，例如对field、venue等节点，就采用了自己argue的metapath2vec模型来进行初始化，所以实验结果的有效性应该也与这种设定有较强的关系。以下是部分实验结果：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/38/0e/XE4f2Hw9_o.png" alt="5d7333c9158d9480659c57f21d06d525.png"></p> 
 <p style="text-align:left;">同时还给出了一个根据计算的attention自动构建的meta-path的样例：</p> 
 <hr> 
 <p><strong>OpenKG</strong><br></p> 
 <p>OpenKG（中文开放知识图谱）旨在推动以中文为核心的知识图谱数据的开放、互联及众包，并促进知识图谱算法、工具及平台的开源开放。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/8b/ef/FRAODpSi_o.png" alt="d3b239f83286b4545433862d6cf64e5f.png"></p> 
 <p>点击<strong>阅读原文</strong>，进入 OpenKG 网站。<br><br></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8ab747f8dd18ee2865774bcc99f42f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">flask多进程多线程配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f6d1d244030e8408e2d42245dc80d81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入理解Java虚拟机之JVM内存布局篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>