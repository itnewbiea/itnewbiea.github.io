<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySql】C语言连接mysql|图形化工具 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【MySql】C语言连接mysql|图形化工具" />
<meta property="og:description" content="文章目录 Connector/C 使用mysql接口介绍Navicat远程连接数据库 Connector/C 使用 说完了mysql的基础,后面我们只关心使用，要使用C语言连接mysql，需要使用mysql官网提供的库，前往官网下载即可。
但是实际上我们并不需要这样去做，我们之前用yum安装mysql的时候就已经包含了，我们前往lib64/mysql/下查看即可：直接用就行了
现在，我们直接来对相关的API进行调用即可。
我们来通过 mysql_get_client_info() 函数，来验证我们的引入是否成功
#include &lt;iostream&gt; #include &lt;mysql/mysql.h&gt; int main() { std::cout&lt;&lt;&#34;mysql cilent version: &#34;&lt;&lt;mysql_get_client_info()&lt;&lt;std::endl; return 0; } 进行编译：记得带上-L库的位置与-l库的名称
测试运行：运行成功，结果如下
mysql接口介绍 我们可以先看一看官方文档：
初始化mysql_init() 要使用库，必须先进行初始化！
MYSQL *mysql_init(MYSQL *mysql); 关闭mysql链接mysql_close void mysql_close(MYSQL *sock); 初始化与关闭是最基础的操作：
#include &lt;iostream&gt; #include &lt;mysql/mysql.h&gt; int main() { MYSQL* my = mysql_init(nullptr); if(nullptr == my) { std::cerr&lt;&lt;&#34;init MySQL error&#34;&lt;&lt;std::endl; return 1; } mysql_close(my); return 0; } 链接数据库mysql_real_connect 初始化完毕之后，必须先链接数据库，在进行后续操作。（mysql网络部分是基于TCP/IP的)
MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long clientflag); //建立好链接之后，获取英文没有问题，如果获取中文是乱码： //设置链接的默认字符集是utf8，原始默认是latin1 mysql_set_character_set(myfd, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/98915ca0dee6111d0c78f1ef5f2fb001/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-28T13:44:32+08:00" />
<meta property="article:modified_time" content="2023-06-28T13:44:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySql】C语言连接mysql|图形化工具</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#ConnectorC__1" rel="nofollow">Connector/C 使用</a></li><li><a href="#mysql_34" rel="nofollow">mysql接口介绍</a></li><li><a href="#Navicat_246" rel="nofollow">Navicat远程连接数据库</a></li></ul> 
</div> 
<p></p> 
<h2><a id="ConnectorC__1"></a>Connector/C 使用</h2> 
<p>说完了mysql的基础,后面我们只关心使用，要使用C语言连接mysql，需要使用mysql官网提供的库，前往官网下载即可。</p> 
<p><img src="https://images2.imgbox.com/fa/d6/rk02BE58_o.png" alt="image-20230625185446125"></p> 
<p>但是实际上我们并不需要这样去做，我们之前用yum安装mysql的时候就已经包含了，我们前往lib64/mysql/下查看即可：直接用就行了</p> 
<p><img src="https://images2.imgbox.com/33/45/zjJVe8nl_o.png" alt="image-20230625192007704"></p> 
<p>现在，我们直接来对相关的API进行调用即可。</p> 
<p>我们来通过 mysql_get_client_info() 函数，来验证我们的引入是否成功</p> 
<pre><code class="prism language-mysql">#include &lt;iostream&gt;
#include &lt;mysql/mysql.h&gt;

int main()
{
    std::cout&lt;&lt;"mysql cilent version: "&lt;&lt;mysql_get_client_info()&lt;&lt;std::endl;
    return 0;
}
</code></pre> 
<p>进行编译：记得带上-L库的位置与-l库的名称</p> 
<p><img src="https://images2.imgbox.com/94/0d/CMAnI10c_o.png" alt="image-20230625194115886"></p> 
<p>测试运行：运行成功，结果如下</p> 
<p><img src="https://images2.imgbox.com/96/99/AbKasbML_o.png" alt="image-20230625194148650"></p> 
<h2><a id="mysql_34"></a>mysql接口介绍</h2> 
<p>我们可以先看一看官方文档：</p> 
<p><img src="https://images2.imgbox.com/7a/52/SULHY73U_o.png" alt="image-20230625195447739"></p> 
<p><img src="https://images2.imgbox.com/f1/4d/hrI8su7x_o.png" alt="image-20230625195549329"></p> 
<ul><li><strong>初始化mysql_init()</strong></li></ul> 
<p>要使用库，必须先进行初始化！</p> 
<pre><code class="prism language-mysql">MYSQL *mysql_init(MYSQL *mysql);  
</code></pre> 
<ul><li><strong>关闭mysql链接mysql_close</strong></li></ul> 
<pre><code class="prism language-mysql">void mysql_close(MYSQL *sock);
</code></pre> 
<p>初始化与关闭是最基础的操作：</p> 
<pre><code class="prism language-mysql">#include &lt;iostream&gt;
#include &lt;mysql/mysql.h&gt;
int main()
{
    MYSQL* my = mysql_init(nullptr);
    if(nullptr == my)
    {
        std::cerr&lt;&lt;"init MySQL error"&lt;&lt;std::endl;
        return 1;
    }
    mysql_close(my);
    return 0;
}
</code></pre> 
<ul><li><strong>链接数据库mysql_real_connect</strong></li></ul> 
<p>初始化完毕之后，必须先链接数据库，在进行后续操作。（mysql网络部分是基于TCP/IP的)</p> 
<pre><code class="prism language-mysql">MYSQL *mysql_real_connect(MYSQL *mysql, const char *host,
const char *user,
const char *passwd,
const char *db,
unsigned int port,
const char *unix_socket,
unsigned long clientflag);
//建立好链接之后，获取英文没有问题，如果获取中文是乱码：
//设置链接的默认字符集是utf8，原始默认是latin1
mysql_set_character_set(myfd, "utf8");
</code></pre> 
<p>第一个参数 MYSQL是 C api中一个非常重要的变量（mysql_init的返回值），里面内存非常丰富，有port,dbname,charset等连接基本参数。它也包含了一个叫 st_mysql_methods的结构体变量，该变量里面保存着很多函数指针，这些函数指针将会在数据库连接成功以后的各种数据操作中被调用。mysql_real_connect函数中各参数，基本都是顾名思意</p> 
<ul><li><strong>下发mysql命令mysql_query</strong></li></ul> 
<pre><code class="prism language-mysql">int mysql_query(MYSQL *mysql, const char *q);
</code></pre> 
<p>第一个参数上面已经介绍过，第二个参数为要执行的sql语句,如“select * from table”</p> 
<p>举个例子，直接更新数据库表中的数据：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;mysql/mysql.h&gt;
#include &lt;string&gt;
#include &lt;unistd.h&gt;
const std::string host="127.0.0.1";
const std::string user = "connector";
const std::string passwd="123456";
const std::string db="conn";
const unsigned int port = 3306;
int main()
{
    MYSQL* my = mysql_init(nullptr);
    if(nullptr == my)
    {
        std::cerr&lt;&lt;"init MySQL error"&lt;&lt;std::endl;
        return 1;
    }
    if(mysql_real_connect(my,host.c_str(),user.c_str(),passwd.c_str(),db.c_str(),port,nullptr,0) == nullptr)
    {
        std::cerr&lt;&lt;"connect MySQL error"&lt;&lt;std::endl;
        return 2;
    }
    mysql_set_character_set(my,"utf8");
    std::string sql="update user set name='Jimmy' where id=2";
    int n = mysql_query(my,sql.c_str());
    if(n==0) std::cout&lt;&lt;sql&lt;&lt;"success"&lt;&lt;std::endl;
    else std::cout&lt;&lt;sql&lt;&lt;"failed"&lt;&lt;std::endl;
    mysql_free_result(res);
    mysql_close(my);
    return 0;
}
</code></pre> 
<p>结果如下，更新成功</p> 
<p><img src="https://images2.imgbox.com/d4/19/PR0mndRi_o.png" alt="image-20230626204951000"></p> 
<ul><li><strong>获取执行结果mysql_store_result</strong></li></ul> 
<p>sql执行完以后，如果是查询语句，我们当然还要读取数据，如果update，insert等语句，那么就看下操作成功与否即可。我们来看看如何获取查询结果： 如果mysql_query返回成功，那么我们就通过mysql_store_result这个函数来读取结果。原型如下 ：</p> 
<pre><code class="prism language-mysql">MYSQL_RES *mysql_store_result(MYSQL *mysql);
</code></pre> 
<p>该函数会调用MYSQL变量中的st_mysql_methods中的 read_rows 函数指针来获取查询的结果。同时该函数会返回MYSQL_RES 这样一个变量，该变量主要用于保存查询的结果。同时该函数malloc了一片内存空间来存储查询过来的数据，所以我们一定要记的 free(result),<strong>不然是肯定会造成内存泄漏的</strong>。 执行完mysql_store_result以后，其实数据都已经在MYSQL_RES 变量中了，下面的api基本就是读取<br> MYSQL_RES 中的数据</p> 
<ul><li><strong>获取结果行数mysql_num_rows</strong></li></ul> 
<pre><code class="prism language-mysql">my_ulonglong mysql_num_rows(MYSQL_RES *res);
</code></pre> 
<ul><li><strong>获取结果列数mysql_num_fields</strong></li></ul> 
<pre><code class="prism language-mysql">unsigned int mysql_num_fields(MYSQL_RES *res);
</code></pre> 
<ul><li><strong>获取列名mysql_fetch_fields</strong></li></ul> 
<pre><code class="prism language-mysql">MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *res);
</code></pre> 
<ul><li><strong>获取结果内容mysql_fetch_row</strong></li></ul> 
<pre><code class="prism language-mysql">MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);
</code></pre> 
<p>返回一个MYSQL_ROW变量，MYSQL_ROW其实就是char **.当成一个二维数组来用吧</p> 
<p>举个例子：</p> 
<pre><code class="prism language-mysql">const std::string host="127.0.0.1";
const std::string user = "connector";
const std::string passwd="123456";
const std::string db="conn";
const unsigned int port = 3306;
int main()
{
    MYSQL* my = mysql_init(nullptr);
    if(nullptr == my)
    {
        std::cerr&lt;&lt;"init MySQL error"&lt;&lt;std::endl;
        return 1;
    }
    if(mysql_real_connect(my,host.c_str(),user.c_str(),passwd.c_str(),db.c_str(),port,nullptr,0) == nullptr)
    {
        std::cerr&lt;&lt;"connect MySQL error"&lt;&lt;std::endl;
        return 2;
    }
    mysql_set_character_set(my,"utf8");
    std::string sql = "select * from user";
    int n = mysql_query(my,sql.c_str());
    if(n==0) std::cout&lt;&lt;sql&lt;&lt;"success"&lt;&lt;std::endl;
    else 
    {
        std::cout&lt;&lt;sql&lt;&lt;"failed"&lt;&lt;std::endl;
        return 3;
    }
    MYSQL_RES * res = mysql_store_result(my);
    if(res==nullptr)
    {
        std::cerr&lt;&lt;"mysql_store_result_error"&lt;&lt;std::endl;
    }
    int rows = mysql_num_rows(res);
    int fields = mysql_num_fields(res);
    std::cout&lt;&lt;"行: "&lt;&lt;rows&lt;&lt;std::endl;
    std::cout&lt;&lt;"列："&lt;&lt;fields&lt;&lt;std::endl;

    //属性
    MYSQL_FIELD * fields_array = mysql_fetch_fields(res);
    for(int i =0;i&lt;fields;i++)
    {
        std::cout&lt;&lt;fields_array[i].name&lt;&lt;"\t";
    }
    std::cout&lt;&lt;"\n";
    //内容
    for(int i = 0;i&lt;rows;i++)
    {
        MYSQL_ROW row = mysql_fetch_row(res);
        for(int j = 0;j&lt;fields;j++)
        {
            std::cout&lt;&lt;row[j]&lt;&lt;"\t";
        }
        std::cout&lt;&lt;"\n";
    }
    std::cout&lt;&lt;fields_array[0].db&lt;&lt;" "&lt;&lt;fields_array[0].table&lt;&lt;std::endl;
    mysql_free_result(res);
    mysql_close(my);
    return 0;
}
</code></pre> 
<p>结果如下：</p> 
<p><img src="https://images2.imgbox.com/67/a6/gnpF1qBj_o.png" alt="image-20230627213240361"></p> 
<h2><a id="Navicat_246"></a>Navicat远程连接数据库</h2> 
<p>图形化管理mysql的工具有挺多，这里使用的是Navicat，下面进行连接的演示，</p> 
<ul><li><strong>准备工作</strong></li></ul> 
<p>首先，在服务器端创建mysql用于远程连接的账户worjkbench：</p> 
<pre><code class="prism language-mysql">create user 'workbench'@'%' identified by '123456';
</code></pre> 
<p>同时，创建完毕之后，我们把数据库conn的权限下放给这个账户：</p> 
<pre><code class="prism language-mysql">grant all on conn.* to 'workbench'@'%';
</code></pre> 
<pre><code class="prism language-mysql">flush privileges;
</code></pre> 
<p>查看创建的信息：</p> 
<p><img src="https://images2.imgbox.com/44/25/k6K9Ruhf_o.png" alt="image-20230628123045572"></p> 
<p>在这个账户下就可以看到这个数据库了：</p> 
<p><img src="https://images2.imgbox.com/84/81/TYA2k2Oc_o.png" alt="image-20230628123655147"></p> 
<ul><li><strong>进行Navicat连接</strong></li></ul> 
<p><img src="https://images2.imgbox.com/e5/98/o3AD4OfO_o.png" alt="image-20230628123933367"></p> 
<p>进行测试连接：连接成功</p> 
<p><img src="https://images2.imgbox.com/cc/5d/rGk8SrHg_o.png" alt="image-20230628123949830"></p> 
<p><img src="https://images2.imgbox.com/b5/2e/ide72Tkm_o.png" alt="image-20230628124118942"></p> 
<p>这就连接成功了。现在我们可以直接来写sql语句：</p> 
<p><img src="https://images2.imgbox.com/e6/c4/N9DmarB1_o.png" alt="image-20230628125719192"></p> 
<p>也可以直接进行图形化进行增删改操作等等：这是图形化带来的好处</p> 
<p><img src="https://images2.imgbox.com/e3/4c/Pj5JHFin_o.png" alt="image-20230628125758732"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/acfb23265026800269132d9581a6530f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Selenium爬取数据写入csv文件中文乱码的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9854bdae98248b329a2c065f077e0b24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">年轻人储蓄难题：平衡生活与未来规划的挑战​​​​​​​</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>