<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【STM32训练—WiFi模块】第二篇、STM32驱动ESP8266WiFi模块获取天气 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【STM32训练—WiFi模块】第二篇、STM32驱动ESP8266WiFi模块获取天气" />
<meta property="og:description" content="目录
第一部分、前言
1、获取心知天气API接口
2、硬件准备
第二部分、电脑串口助手调试WIFI模块获取天气
1、ESP8266获取天气的流程
2、具体步骤
第三部分、STM32驱动ESP8266模块获取天气数据
1、天气数据的解析
1.1、什么函数来解析天气数据？
2.1、解析后的数据如何使用？
2、相关代码
2.1、main.c文件
2.2、esp8266.c文件
第四部分、总结
1、效果展示
2、完整的工程
3、补充
第一部分、前言 这篇博客拖了很久很久，本来是打算和前面一篇一起发出来的，但是那段时间因为一些事情耽搁了，这篇博客写了一半，剩下的一直都没有写，其次就是人也有点懒，也不太想动🤪🤪。
这几天考试周来了，复习又不想复习，不如把这篇内容更新完整，这篇更新完之后，STM32专栏应该不会再更新了。
然后，后面我打算出一期C语言的学习笔记专栏，再后面就是FPGA的学习笔记专栏。想是这么想的，不知道能不能做好，哈哈🤭。
1、获取心知天气API接口 这里还是希望大家先去看我的第一篇博客：【STM32训练—WiFi模块】第一篇、STM32驱动ESP8266WiFi模块获取网络时间通过这篇博客你会明白WIFI模块获取网络流程是什么样子的，搞懂了这个，你会发现获取天气和获取时间的步骤完全一样，代码也没有什么大的变化。
接着再来说一下心知天气，上一篇文章提到时间的接口是由苏宁后台提供的“quan.suning.com/getSysTime.do”，那么这里想获取天气，那么也需要一个API的接口，这里的API接口由心知天气给我们提供。
因此需要注册一个心知天气，获取自己的密钥。关于注册的过程可以参考心知天气提供的文档：注册与登陆 | 心知天气文档 (seniverse.com)
注册完成后，如何获取属于自己的API接口呢，参考文档如下：查看/修改你的API密钥 (yuque.com)
这是我的API接口，点进去之后就会看到目前杭州的天气数据：https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=hangzhou&amp;language=zh-Hans&amp;unit=c
点击上面的链接，就会获取到天气数据，接下来的步骤就和前面获取时间一样，主要区别就是将时间的API接口换成刚刚注册得到的心知天气的API接口即可，是不是发现原来也就这么回事。
2、硬件准备 STM32选用核心板F103C8T6，然后再加一个ESP8266 WiFi模块（任何型号应该都可以，我这次用的ESP-01s），最后需要一个USB-TTL模块用来打印串口数据。
需要注意的是：我的这个ESP-01S，有一个EN使能端，必须要给高电平才能用，上一篇博客用的那个WIFI模块没有EN使能端。所以希望大家注意自己的模块。
第二部分、电脑串口助手调试WIFI模块获取天气 1、ESP8266获取天气的流程 流程和获取时间的流程大致一样，只不过这里获取的为天气数据。
2、具体步骤 第一步、AT指令集
0：AT 1：AT&#43;RST 2：AT&#43;CWMODE=1 3：AT&#43;CIPMUX=0 4：AT&#43;CWJAP=&#34;你的WiFi名称&#34;,&#34;你的WiFi密码&#34; 5：AT&#43;CIPMODE=1 6：AT&#43;CIPSTART=&#34;TCP&#34;,&#34;api.seniverse.com&#34;,80 7：AT&#43;CIPSEND 8：GET https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=hangzhou&amp;language=en&amp;unit=c 9：&#43;&#43;&#43; 注意：所有串口步骤同前一篇文章，这里直接有区别的步骤为第八步，因此这里直接跳转到第八步
第八步、连接目标的服务器，TCP是传输协议,api.seniverse.com是心知天气服务器的IP地址，80是服务器端口。
第十步、第九步和前文一样，接着再发送获取数据的请求，得到天气数据
第十一步、关于退出透传的方式也和前面博客完全一样，这里就不再展示，所以一定要看第一篇文章，那个文章介绍的太详细了。
第三部分、STM32驱动ESP8266模块获取天气数据 1、天气数据的解析 这里天气的解析我调用了cJSON的库，你不用管这个库怎么写的，原理是啥，知道它是怎么用的就可以了，例如调用什么函数来解析天气数据？解析后的数据如何使用？弄明白这两个问题，就够了。
1.1、什么函数来解析天气数据？ 时间太久了，我都不知道我哪里弄来的这个函数，反正挺好用的，侵权联系我删除!
这个函数我放在我工程的&#34;cJSON.c&#34;文件最下面。
/********************************************************************************* * Function Name ： cJSON_WeatherParse,解析天气数据 * Parameter	： JSON：天气数据包 results：保存解析后得到的有用的数据 * Return Value ： 0：成功 其他:错误 * Function Explain ： * Create Date ： 2017." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/01e5167c1f229ffbae7b4c877566e483/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-15T21:45:53+08:00" />
<meta property="article:modified_time" content="2023-06-15T21:45:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【STM32训练—WiFi模块】第二篇、STM32驱动ESP8266WiFi模块获取天气</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">第一部分、前言</a></p> 
<p id="1%E3%80%81%E8%8E%B7%E5%8F%96%E5%BF%83%E7%9F%A5%E5%A4%A9%E6%B0%94API%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%8E%B7%E5%8F%96%E5%BF%83%E7%9F%A5%E5%A4%A9%E6%B0%94API%E6%8E%A5%E5%8F%A3" rel="nofollow">1、获取心知天气API接口</a></p> 
<p id="1%E3%80%81%E7%A1%AC%E4%BB%B6%E5%87%86%E5%A4%87-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%A1%AC%E4%BB%B6%E5%87%86%E5%A4%87" rel="nofollow">2、硬件准备</a></p> 
<p id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E3%80%81%E7%94%B5%E8%84%91%E4%B8%B2%E5%8F%A3%E5%8A%A9%E6%89%8B%E8%B0%83%E8%AF%95WIFI%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E3%80%81%E7%94%B5%E8%84%91%E4%B8%B2%E5%8F%A3%E5%8A%A9%E6%89%8B%E8%B0%83%E8%AF%95WIFI%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94" rel="nofollow">第二部分、电脑串口助手调试WIFI模块获取天气</a></p> 
<p id="1%E3%80%81ESP8266%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E7%9A%84%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81ESP8266%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E7%9A%84%E6%B5%81%E7%A8%8B" rel="nofollow">1、ESP8266获取天气的流程</a></p> 
<p id="2%E3%80%81%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4" rel="nofollow">2、具体步骤</a></p> 
<p id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E3%80%81STM32%E9%A9%B1%E5%8A%A8ESP8266%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E3%80%81STM32%E9%A9%B1%E5%8A%A8ESP8266%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE" rel="nofollow">第三部分、STM32驱动ESP8266模块获取天气数据</a></p> 
<p id="1%E3%80%81%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E6%9E%90" rel="nofollow">1、天气数据的解析</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%E3%80%81%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E6%9D%A5%E8%A7%A3%E6%9E%90%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%E3%80%81%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E6%9D%A5%E8%A7%A3%E6%9E%90%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%EF%BC%9F" rel="nofollow">1.1、什么函数来解析天气数据？</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.1%E3%80%81%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.1%E3%80%81%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F" rel="nofollow">2.1、解析后的数据如何使用？</a></p> 
<p id="%C2%A02%E3%80%81%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%C2%A02%E3%80%81%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81" rel="nofollow"> 2、相关代码</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%E3%80%81main.c%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%E3%80%81main.c%E6%96%87%E4%BB%B6" rel="nofollow">2.1、main.c文件</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%E3%80%81esp8266.c%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%E3%80%81esp8266.c%E6%96%87%E4%BB%B6" rel="nofollow">2.2、esp8266.c文件</a></p> 
<p id="%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">第四部分、总结</a></p> 
<p id="1%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow">1、效果展示</a></p> 
<p id="2%E3%80%81%E5%AE%8C%E6%95%B4%E7%9A%84%E5%B7%A5%E7%A8%8B-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%AE%8C%E6%95%B4%E7%9A%84%E5%B7%A5%E7%A8%8B" rel="nofollow">2、完整的工程</a></p> 
<p id="3%E3%80%81%E8%A1%A5%E5%85%85-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%A1%A5%E5%85%85" rel="nofollow">3、补充</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E3%80%81%E5%89%8D%E8%A8%80">第一部分、前言</h2> 
<p>        这篇博客拖了很久很久，本来是打算和前面一篇一起发出来的，但是那段时间因为一些事情耽搁了，这篇博客写了一半，剩下的一直都没有写，<strong>其次就是人也有点懒，也不太想动</strong>🤪🤪。</p> 
<p>        这几天考试周来了，复习又不想复习，不如把这篇内容更新完整，这篇更新完之后，STM32专栏应该不会再更新了。</p> 
<p>        然后，后面我打算出一期C语言的学习笔记专栏，再后面就是FPGA的学习笔记专栏。想是这么想的，不知道能不能做好，哈哈🤭。</p> 
<h3 id="1%E3%80%81%E8%8E%B7%E5%8F%96%E5%BF%83%E7%9F%A5%E5%A4%A9%E6%B0%94API%E6%8E%A5%E5%8F%A3">1、获取心知天气API接口</h3> 
<p>        这里还是希望大家先去看我的第一篇博客：<a class="link-info" href="http://t.csdn.cn/IfdYG" rel="nofollow" title="【STM32训练—WiFi模块】第一篇、STM32驱动ESP8266WiFi模块获取网络时间">【STM32训练—WiFi模块】第一篇、STM32驱动ESP8266WiFi模块获取网络时间</a><strong>通过这篇博客你会明白WIFI模块获取网络流程是什么样子的</strong>，搞懂了这个，<span style="color:#956fe7;"><strong>你会发现获取天气和获取时间的步骤完全一样，代码也没有什么大的变化。</strong></span></p> 
<p>        接着再来说一下心知天气，上一篇文章提到时间的接口是由苏宁后台提供的“<a href="http://quan.suning.com/getSysTime.do" rel="nofollow" title="quan.suning.com/getSysTime.do">quan.suning.com/getSysTime.do</a>”，那么这里想获取天气，那么也需要一个API的接口，这里的API接口由心知天气给我们提供。</p> 
<p>        因此需要注册一个心知天气，获取<span style="color:#ff9900;"><strong>自己的密钥</strong></span>。关于注册的过程可以参考心知天气提供的文档：<a href="https://docs.seniverse.com/account/profile/register.html" rel="nofollow" title="注册与登陆 | 心知天气文档 (seniverse.com)">注册与登陆 | 心知天气文档 (seniverse.com)</a></p> 
<p class="img-center"><img alt="" height="370" src="https://images2.imgbox.com/92/2a/5uhA1SOC_o.png" width="684"></p> 
<p>        注册完成后，如何获取属于自己的API接口呢，参考文档如下：<a href="https://seniverse.yuque.com/hyper_data/api_v3/gc03wk" rel="nofollow" title="查看/修改你的API密钥 (yuque.com)">查看/修改你的API密钥 (yuque.com)</a></p> 
<p>        <strong>这是我的API接口，点进去之后就会看到目前杭州的天气数据：</strong><a href="https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=hangzhou&amp;language=zh-Hans&amp;unit=c" rel="nofollow" title="https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=hangzhou&amp;language=zh-Hans&amp;unit=c">https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=hangzhou&amp;language=zh-Hans&amp;unit=c</a></p> 
<p class="img-center"><img alt="" height="446" src="https://images2.imgbox.com/2a/39/ngTgQM0h_o.png" width="677"></p> 
<p>        点击上面的链接，就会获取到天气数据，接下来的步骤就和前面获取时间一样，<span style="color:#956fe7;"><strong>主要区别就是将时间的API接口换成刚刚注册得到的心知天气的API接口即可</strong></span>，<strong>是不是发现原来也就这么回事。</strong></p> 
<p class="img-center"><img alt="" height="225" src="https://images2.imgbox.com/cc/c2/zwF4As6d_o.png" width="683"></p> 
<h3 id="1%E3%80%81%E7%A1%AC%E4%BB%B6%E5%87%86%E5%A4%87">2、硬件准备</h3> 
<p>         STM32选用核心板<strong>F103C8T6</strong>，然后再加一个<strong>ESP8266 WiFi模块</strong>（任何型号应该都可以，我这次用的<span style="color:#ff9900;"><strong>ESP-01s</strong></span>），最后需要一个<strong>USB-TTL模块</strong>用来打印串口数据。</p> 
<p>       <span style="color:#fe2c24;"><strong> 需要注意的是：</strong></span><strong>我的这个ESP-01S，有一个EN使能端，必须要给高电平才能用，上一篇博客用的那个WIFI模块没有EN使能端。所以希望大家注意自己的模块。</strong></p> 
<p class="img-center"><img alt="" height="384" src="https://images2.imgbox.com/3c/8f/j2dKOoqJ_o.png" width="654"></p> 
<h2 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E3%80%81%E7%94%B5%E8%84%91%E4%B8%B2%E5%8F%A3%E5%8A%A9%E6%89%8B%E8%B0%83%E8%AF%95WIFI%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94">第二部分、电脑串口助手调试WIFI模块获取天气</h2> 
<h3 id="1%E3%80%81ESP8266%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E7%9A%84%E6%B5%81%E7%A8%8B">1、ESP8266获取天气的流程</h3> 
<p>        流程和获取时间的流程大致一样，只不过这里获取的为<strong>天气数据。</strong></p> 
<p class="img-center"><img alt="" height="446" src="https://images2.imgbox.com/6f/6d/c9JdODBo_o.png" width="630"></p> 
<h3 id="2%E3%80%81%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4">2、具体步骤</h3> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong> 第一步、AT指令集</strong></span></p> 
</blockquote> 
<pre><code>0：AT
1：AT+RST
2：AT+CWMODE=1
3：AT+CIPMUX=0
4：AT+CWJAP="你的WiFi名称","你的WiFi密码"
5：AT+CIPMODE=1
6：AT+CIPSTART="TCP","api.seniverse.com",80
7：AT+CIPSEND
8：GET https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=hangzhou&amp;language=en&amp;unit=c
9：+++
</code></pre> 
<p>       <span style="color:#fe2c24;"><strong> 注意：</strong></span><strong>所有串口步骤同前一篇文章，这里直接有区别的步骤为第八步，因此这里直接跳转到第八步</strong></p> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong> 第八步、连接目标的服务器，TCP是传输协议,api.seniverse.com是心知天气服务器的IP地址，80是服务器端口。</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="532" src="https://images2.imgbox.com/6c/d2/G2bdybUe_o.png" width="676"></p> 
<blockquote> 
 <p><span style="color:#1c7331;"> <strong>第十步、第九步和前文一样，接着再发送获取数据的请求，得到天气数据</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="540" src="https://images2.imgbox.com/80/92/EB8CtBEg_o.png" width="681"></p> 
<blockquote> 
 <p> <span style="color:#1c7331;"><strong>第十一步、关于退出透传的方式也和前面博客完全一样，这里就不再展示，所以一定要看第一篇文章，那个文章介绍的太详细了。</strong></span></p> 
</blockquote> 
<h2 id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E3%80%81STM32%E9%A9%B1%E5%8A%A8ESP8266%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE">第三部分、STM32驱动ESP8266模块获取天气数据</h2> 
<h3 id="1%E3%80%81%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E6%9E%90">1、天气数据的解析</h3> 
<p>        这里天气的解析我调用了cJSON的库，你不用管这个库怎么写的，原理是啥，知道它是怎么用的就可以了，例如调用什么函数来解析天气数据？解析后的数据如何使用？弄明白这两个问题，就够了。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%E3%80%81%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E6%9D%A5%E8%A7%A3%E6%9E%90%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%EF%BC%9F">      <strong>  1.1、</strong>什么函数来解析天气数据？</h4> 
<p>        <span style="color:#956fe7;">时间太久了，我都不知道我哪里弄来的这个函数，反正挺好用的，</span><strong><span style="color:#fe2c24;">侵权联系我删除!</span></strong></p> 
<p><strong>        这个函数我放在我工程的"cJSON.c"文件最下面。</strong></p> 
<pre><code class="language-cpp">/*********************************************************************************
* Function Name    ： cJSON_WeatherParse,解析天气数据
* Parameter		   ： JSON：天气数据包  results：保存解析后得到的有用的数据
* Return Value     ： 0：成功 其他:错误
* Function Explain ： 
* Create Date      ： 2017.12.6 by lzn
**********************************************************************************/
int cJSON_WeatherParse(char *JSON, Results *results)
{
	cJSON *json,*arrayItem,*object,*subobject,*item;
	
	json = cJSON_Parse(JSON); //解析JSON数据包
	if(json == NULL)		  //检测JSON数据包是否存在语法上的错误，返回NULL表示数据包无效
	{
		printf("Error before: [%s] \r\n",cJSON_GetErrorPtr()); //打印数据包语法错误的位置
		return 1;
	}
	else
	{
		if((arrayItem = cJSON_GetObjectItem(json,"results")) != NULL); //匹配字符串"results",获取数组内容
		{
			int size = cJSON_GetArraySize(arrayItem);     //获取数组中对象个数
			printf("cJSON_GetArraySize: size=%d \r\n",size); 
			
			if((object = cJSON_GetArrayItem(arrayItem,0)) != NULL)//获取父对象内容
			{
				/* 匹配子对象1 */
				if((subobject = cJSON_GetObjectItem(object,"location")) != NULL)
				{
					printf("---------------------------------subobject1-------------------------------\r\n");
					if((item = cJSON_GetObjectItem(subobject,"id")) != NULL)   //匹配子对象1成员"id"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].location.id,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
					if((item = cJSON_GetObjectItem(subobject,"name")) != NULL) //匹配子对象1成员"name"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].location.name,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
					if((item = cJSON_GetObjectItem(subobject,"country")) != NULL)//匹配子对象1成员"country"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].location.country,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
					if((item = cJSON_GetObjectItem(subobject,"path")) != NULL)  //匹配子对象1成员"path"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].location.path,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
					if((item = cJSON_GetObjectItem(subobject,"timezone")) != NULL)//匹配子对象1成员"timezone"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].location.timezone,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
					if((item = cJSON_GetObjectItem(subobject,"timezone_offset")) != NULL)//匹配子对象1成员"timezone_offset"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].location.timezone_offset,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
				}
				/* 匹配子对象2 */
				if((subobject = cJSON_GetObjectItem(object,"now")) != NULL)
				{
					printf("---------------------------------subobject2-------------------------------\r\n");
					if((item = cJSON_GetObjectItem(subobject,"text")) != NULL)//匹配子对象2成员"text"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].now.text,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
					if((item = cJSON_GetObjectItem(subobject,"code")) != NULL)//匹配子对象2成员"code"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].now.code,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
					if((item = cJSON_GetObjectItem(subobject,"temperature")) != NULL) //匹配子对象2成员"temperature"
					{
						printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",item-&gt;type,item-&gt;string,item-&gt;valuestring);
						memcpy(results[0].now.temperature,item-&gt;valuestring,strlen(item-&gt;valuestring));
					}
				}
				/* 匹配子对象3 */
				if((subobject = cJSON_GetObjectItem(object,"last_update")) != NULL)
				{
					printf("---------------------------------subobject3-------------------------------\r\n");
					printf("cJSON_GetObjectItem: type=%d, string is %s,valuestring=%s \r\n",subobject-&gt;type,subobject-&gt;string,subobject-&gt;valuestring);
					memcpy(results[0].last_update,item-&gt;valuestring,strlen(subobject-&gt;valuestring));
				}
			} 
		}
	}
	
	cJSON_Delete(json); //释放cJSON_Parse()分配出来的内存空间
	
	return 0;
}</code></pre> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.1%E3%80%81%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F">        2.1、解析后的数据如何使用？</h4> 
<p>        调用上面那个函数后，解析的数据存放在一个<strong>双层结构体</strong>当中，因此只需访问结构体的成员就可以，每个成员的名称与心知天气返回的名称相匹配。</p> 
<p>        具体的信息参考心知天气的文档：<a href="https://seniverse.yuque.com/hyper_data/api_v3/moment" rel="nofollow" title="极速实况 (yuque.com)">极速实况 (yuque.com)</a></p> 
<p class="img-center"><img alt="" height="563" src="https://images2.imgbox.com/4b/da/nqR9AeOr_o.png" width="1200"></p> 
<h3 id="%C2%A02%E3%80%81%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"> 2、相关代码</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%E3%80%81main.c%E6%96%87%E4%BB%B6">        2.1、main.c文件</h4> 
<pre><code class="language-cpp">#include "sys.h"
#include "led.h"
#include "delay.h"
#include "usart.h"
#include "esp8266.h"
#include "cJSON.h" //解析天气

//天气数据
extern unsigned char Weather_buff[300];
//天气解析
Results Weather_results[] = {<!-- -->{0}};

int main()
{
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//中断控制器分组设置
	Usart1_Init(115200);
	Usart2_Init(115200);

	LED_Init();
	delay_init();//初始化很重要//用不了的函数一般都是没有初始化
														
	ESP8266_Init();
	Get_current_weather();//获取天气
	while(1)
	{
		LED0 = 0;
		delay_ms(500);
		delay_ms(500);
		delay_ms(500);
		delay_ms(500);
		LED0 = 1;
		delay_ms(500);
		delay_ms(500);
		delay_ms(500);
		delay_ms(500);
		cJSON_WeatherParse((char *)Weather_buff, Weather_results);
		printf("%s",Weather_buff);	
		//打印结构体内内容
		printf("\r\n 打印结构体内内容如下： \r\n");
		printf("%s \r\n",Weather_results[0].now.text);
		printf("%s \r\n",Weather_results[0].now.temperature);
		printf("%s \r\n",Weather_results[0].location.path);
		printf("%s \r\n",Weather_results[0].location.country);

	}

}</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%E3%80%81esp8266.c%E6%96%87%E4%BB%B6">        2.2、esp8266.c文件</h4> 
<pre><code class="language-cpp">#include "stm32f10x.h"
#include "sys.h"
#include "string.h"
#include "stdlib.h"
#include "esp8266.h"

#include "usart.h"
#include "delay.h"
#include "led.h"

//WIFI和密码·
#define ESP8266_WIFI_INFO		"AT+CWJAP=\"iPhone111\",\"123456789\"\r\n"
//心知天气的API
#define Weather_TCP		"AT+CIPSTART=\"TCP\",\"api.seniverse.com\",80\r\n"
//心知天气GET报文
/*这里城市  恩施    语言为  英文*/
#define Weather_GET		"GET https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=enshi&amp;language=en&amp;unit=c\r\n"


//ESP8266数据存放
unsigned char esp8266_buf[300] = {0};
unsigned short esp8266_cnt = 0, esp8266_cntPre = 0;
//存放天气数据
unsigned char Weather_buff[300];   //位数是随机确定的



/**************************************************************************/
//函数作用：ESP8266_Init初始化函数
//函数名称：ESP8266_Init(void);
//内部参数：
//修改日期：2022年4月18日  下午16：18
//作者：    大屁桃
/**************************************************************************/
void ESP8266_Init(void)
{
		
	ESP8266_Clear();
	
 /*让WIFI推出透传模式*/
	while(ESP8266_SendCmd("+++", ""))  
	delay_ms(500);
	
	UsartPrintf(USART_DEBUG, "1.AT\r\n");
	while(ESP8266_SendCmd("AT\r\n", "OK"))
		delay_ms(500);
	
	//
	//加一步ESP8266复位操作
	
	UsartPrintf(USART_DEBUG, "2.RST\r\n");
	ESP8266_SendCmd("AT+RST\r\n", "");
	delay_ms(500);
	ESP8266_SendCmd("AT+CIPCLOSE\r\n", "");
	delay_ms(500);
	/
	
	UsartPrintf(USART_DEBUG, "3.CWMODE\r\n");
	while(ESP8266_SendCmd("AT+CWMODE=1\r\n", "OK"))
		delay_ms(500);
	
	UsartPrintf(USART_DEBUG, "4.AT+CIPMUX\r\n");
	while(ESP8266_SendCmd("AT+CIPMUX=0\r\n", "OK"))
		delay_ms(500);
	
	UsartPrintf(USART_DEBUG, "5.CWJAP\r\n");
	while(ESP8266_SendCmd(ESP8266_WIFI_INFO, "WIFI GOT IP"))
	delay_ms(500);
	delay_ms(500);
	delay_ms(500);
	UsartPrintf(USART_DEBUG, "ESP8266_Init OK\r\n");
}


/*获取网络天气数据*/
/**************************************************************************/
//函数作用：获取心知天气函数
//函数名称：Get_current_weather(void);
//内部参数：
//修改日期：2022年4月18日  下午16：18
//作者：    大屁桃
/**************************************************************************/
void Get_current_weather(void)
{
	ESP8266_Clear();
	
	UsartPrintf(USART_DEBUG, "6.Weather_TCP OK\r\n");	
	while(ESP8266_SendCmd(Weather_TCP, "CONNECT"))
	delay_ms(500);
	delay_ms(500);
	
	UsartPrintf(USART_DEBUG, "7.AT+CIPMODE=1 OK\r\n");		
	while(ESP8266_SendCmd("AT+CIPMODE=1\r\n", "OK"))
	delay_ms(500);
	delay_ms(500);
	delay_ms(500);
/*sizeof(Weather_GET)，必须用sizeof函数，用strlen没有用*/  	
	ESP8266_SendData((u8 *)Weather_GET, sizeof(Weather_GET)); //发送AT+CIPSEND  以及 Weather_GET
	
	ESP8266_GetIPD_GET(200,Weather_buff);
	ESP8266_Clear();//清除缓存数据	

	delay_ms(500);
	delay_ms(500);
	while(ESP8266_SendCmd("+++", ""))      /*退出透传模式*/
	delay_ms(500);
	UsartPrintf(USART_DEBUG, "+++ OK\r\n");	

	while(ESP8266_SendCmd("AT\r\n", "OK"))   //验证是否退出透传模式
		delay_ms(500);
	UsartPrintf(USART_DEBUG, "1.AT\r\n");
}




/**************************************************************************/
//函数作用：串口二中断函数
//函数名称：USART2_IRQHandler();
//内部参数：
//修改日期：2022年4月18日  下午4：18
//作者：    大屁桃
/**************************************************************************/
void USART2_IRQHandler(void)
{

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收中断
	{

		if(esp8266_cnt &gt;= sizeof(esp8266_buf))	esp8266_cnt = 0; //防止串口被刷爆				
		esp8266_buf[esp8266_cnt++] = USART2-&gt;DR;  

//		USART_SendData(USART1,USART2-&gt;DR);      //让接收到的数据打印在串口一上
		
		USART_ClearFlag(USART2, USART_FLAG_RXNE);
	}
}



//==========================================================
//	函数名称：	ESP8266_Clear
//
//	函数功能：	清空缓存
//
//	入口参数：	无
//
//	返回参数：	无
//
//	说明：		
//==========================================================
void ESP8266_Clear(void)
{

	memset(esp8266_buf, 0, sizeof(esp8266_buf));
	esp8266_cnt = 0;

}
//==========================================================
//	函数名称：	ESP8266_WaitRecive
//
//	函数功能：	等待接收完成
//
//	入口参数：	无
//
//	返回参数：	REV_OK-接收完成		REV_WAIT-接收超时未完成
//
//	说明：		循环调用检测是否接收完成
//==========================================================
_Bool ESP8266_WaitRecive(void)
{

	if(esp8266_cnt == 0) 							//如果接收计数为0 则说明没有处于接收数据中，所以直接跳出，结束函数
		return REV_WAIT;
		
	if(esp8266_cnt == esp8266_cntPre)				//如果上一次的值和这次相同，则说明接收完毕
	{
		esp8266_cnt = 0;							//清0接收计数
			
		return REV_OK;								//返回接收完成标志
	}
		
	esp8266_cntPre = esp8266_cnt;					//置为相同
	
	return REV_WAIT;								//返回接收未完成标志

}




//==========================================================
//	函数名称：	ESP8266_GetIPD
//
//	函数功能：	copy天气数据到Weather_buff数组里面
//
//	返回参数：	平台返回的原始数据
//
//	说明：		copy天气数据到Weather_buff
//==========================================================

unsigned char *ESP8266_GetIPD_GET(unsigned short timeOut,u8 *buff)//这里我用了一个全局变量将esp8266buf储存到这个全局变量里面
{
	do
	{
		delay_ms(5);													
	} while(timeOut--);
	strcpy((char*)buff,(char*)esp8266_buf);
	return buff;														
}

/*还未用到*/
//==========================================================
//	函数名称：	ESP8266_GetIPD
//
//	函数功能：	获取平台返回的数据
//
//	入口参数：	等待的时间(乘以10ms)
//
//	返回参数：	平台返回的原始数据
//
//	说明：		不同网络设备返回的格式不同，需要去调试
//				如ESP8266的返回格式为	"+IPD,x:yyy"	x代表数据长度，yyy是数据内容
//==========================================================
unsigned char *ESP8266_GetIPD(unsigned short timeOut)
{

	char *ptrIPD = NULL;
	
	do
	{
		if(ESP8266_WaitRecive() == REV_OK)								//如果接收完成
		{
			ptrIPD = strstr((char *)esp8266_buf, "IPD,");				//搜索“IPD”头
			if(ptrIPD == NULL)											//如果没找到，可能是IPD头的延迟，还是需要等待一会，但不会超过设定的时间
			{
				//UsartPrintf(USART_DEBUG, "\"IPD\" not found\r\n");
			}
			else
			{
				ptrIPD = strchr(ptrIPD, ':');							//找到':'
				if(ptrIPD != NULL)
				{
					ptrIPD++;
					return (unsigned char *)(ptrIPD);
				}
				else
					return NULL;
				
			}
		}
		
		delay_ms(5);													//延时等待
	} while(timeOut--);
	
	return NULL;														//超时还未找到，返回空指针

}
//==========================================================
//	函数名称：	ESP8266_SendCmd
//
//	函数功能：	发送命令
//
//	入口参数：	cmd：命令
//				res：需要检查的返回指令
//
//	返回参数：	0-成功	1-失败
//
//	说明：		
//==========================================================
_Bool ESP8266_SendCmd(char *cmd, char *res)
{
	
	unsigned char timeOut = 250;

	Usart_SendString(USART2, (unsigned char *)cmd, strlen((const char *)cmd));
	
	while(timeOut--)
	{
		if(ESP8266_WaitRecive() == REV_OK)							//如果收到数据
		{		
			if(strstr((const char *)esp8266_buf, res) != NULL)		//如果检索到关键词
			{
				ESP8266_Clear();									//清空缓存
				
				return 0;
			}
		}
		
		delay_ms(10);
	}
	
	return 1;

}

//==========================================================
//	函数名称：	ESP8266_SendData
//
//	函数功能：	发送数据
//
//	入口参数：	data：数据
//				len：长度
//
//	返回参数：	无
//
//	说明：		
//==========================================================
void ESP8266_SendData(unsigned char *data, unsigned short len)
{

	char cmdBuf[32];
	
	ESP8266_Clear();								//清空接收缓存
	sprintf(cmdBuf, "AT+CIPSEND\r\n");		//发送命令
	if(!ESP8266_SendCmd(cmdBuf, "&gt;"))				//收到‘&gt;’时可以发送数据
	{
		UsartPrintf(USART_DEBUG, "8.AT+CIPSEND\r\n");
		/*发送请求数据*/
		Usart_SendString(USART2, data, len);		//发送设备连接请求数据		
	}
}


</code></pre> 
<h2 id="%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E3%80%81%E6%80%BB%E7%BB%93">第四部分、总结</h2> 
<h3 id="1%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">1、效果展示</h3> 
<p>       <span style="color:#b95514;"> <strong>这是连接单片机后，单片机通过串口返回的数据</strong></span>，这里串口只展示了<strong>当前天气、当前温度，所在地区和所在国家的数据，</strong>若想增加在主程序中增加即可。</p> 
<p>    <strong>    单片机通过串口返回的数据和网址上显示的一致。</strong></p> 
<p class="img-center"><img alt="" height="357" src="https://images2.imgbox.com/25/ca/KqaaxG5b_o.png" width="660"></p> 
<h3> 2、完整的工程</h3> 
<p>        完整的工程代码点击该链接下载，<span style="color:#1c7331;"><strong>无需积分，直接下载</strong></span>：<a class="link-info" href="https://download.csdn.net/download/Learning1232/87902066" title="STM32工程文件">STM32工程文件</a>​​​​​​​</p> 
<h3 id="3%E3%80%81%E8%A1%A5%E5%85%85">3、补充</h3> 
<p>        这篇博客<strong>说明了天气的获取方式，天气的读取，</strong>后面想做天气显示等应用，只需要加上LCD的驱动程序即可，花里胡哨的功能要靠自己去琢磨噻。</p> 
<p>        最后希望博客对你有帮助，喜欢的话可以点个赞呢👍👍👍。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b091c94d19d308d3aa0e521eca4ab17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sublime text 4 使用技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09b98b4c90a727cce6f094c0fa051cdd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java实现简单五子棋</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>