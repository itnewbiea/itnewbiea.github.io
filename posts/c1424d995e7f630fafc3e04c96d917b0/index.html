<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BMS开发之面向对象思想（adbms1818） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BMS开发之面向对象思想（adbms1818）" />
<meta property="og:description" content="借鉴adbms1818的底层驱动代码
前言：adbms1818的主要用途就是不同种类的寄存器里面存储不同的数据，程序员需要通过特定的协议往寄存器里面写入或者读出数据
（1）定义一个结构体 里面存储了adbms1818的所有寄存器的信息。然后我们看定义，首先就是配置寄存器config，其次是配置寄存器configB，然后就是电压寄存器cells,辅助寄存器aux，状态寄存器stat，COMM寄存器组com......，但是我们不知道最前面的数据类型，他并不是我们熟知的int , char,short等等。
/*! Cell variable structure */ typedef struct { ic_register config; ic_register configb; cv cells; ax aux; st stat; ic_register com; ic_register pwm; ic_register pwmb; ic_register sctrl; ic_register sctrlb; uint8_t sid[6]; BOOL isospi_reverse; pec_counter crc_count; register_cfg ic_reg; long system_open_wire; }cell_asic; （2）跳转到ic_register定义 已知信息是配置寄存器组A占48个位，6个字节，其次协议规定的发送数据格式是 CMD0 CMD1 PEC0 PEC1 6个字节数据 PEC0 PEC1，此处我们只需要考虑红色字体，PEC0,PEC1类似于CRC校验码。
再次返回来看结构体，首先tx_data[6]里面存储的就是寄存器里面所有位的数据，rx_data[8]收到的数据（包括PEC0 PEC1),rx_pec_match是标志位，判断接收到的PEC和根据6位数据计算出来的PEC是否相同，相同数据接收正确，不同数据接收错误。
typedef struct { uint8_t tx_data[6]; //!&lt; Stores data to be transmitted uint8_t rx_data[8]; //!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c1424d995e7f630fafc3e04c96d917b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T10:18:30+08:00" />
<meta property="article:modified_time" content="2024-01-04T10:18:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BMS开发之面向对象思想（adbms1818）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>借鉴adbms1818的底层驱动代码</p> 
<p>前言：adbms1818的主要用途就是不同种类的寄存器里面存储不同的数据，程序员需要通过特定的协议往寄存器里面写入或者读出数据</p> 
<h2>（1）定义一个结构体</h2> 
<p>        里面存储了adbms1818的所有寄存器的信息。然后我们看定义，首先就是配置寄存器config，其次是配置寄存器configB，然后就是电压寄存器cells,辅助寄存器aux，状态寄存器stat，COMM寄存器组com......，但是我们不知道最前面的数据类型，他并不是我们熟知的int , char,short等等。</p> 
<pre><code class="language-cpp">/*! Cell variable structure */
typedef struct
{
  ic_register config;
  ic_register configb;
  cv  cells;
  ax  aux;
  st  stat;
  ic_register com;
  ic_register pwm;
  ic_register pwmb;
  ic_register sctrl;
  ic_register sctrlb;
  uint8_t sid[6];
  BOOL isospi_reverse;
  pec_counter crc_count;
  register_cfg ic_reg;
  long system_open_wire;
}cell_asic;</code></pre> 
<h2>（2）跳转到ic_register定义</h2> 
<p>        已知信息是配置寄存器组A占48个位，6个字节，其次协议规定的发送数据格式是 CMD0 CMD1 PEC0 PEC1<span style="color:#fe2c24;"> 6个字节数据 PEC0 PEC1</span><span style="color:#0d0016;">，此处我们只需要考虑红色字体，PEC0,PEC1类似于CRC校验码。</span></p> 
<p><span style="color:#0d0016;">        再次返回来看结构体，首先tx_data[6]里面存储的就是寄存器里面所有位的数据，rx_data[8]收到的数据（包括PEC0 PEC1),rx_pec_match是标志位，判断接收到的PEC和根据6位数据计算出来的PEC是否相同，相同数据接收正确，不同数据接收错误。</span></p> 
<p><img alt="" height="237" src="https://images2.imgbox.com/6f/da/Z3qYe4dV_o.png" width="1200"></p> 
<pre><code class="language-cpp">typedef struct
{
  uint8_t tx_data[6];  //!&lt; Stores data to be transmitted 
  uint8_t rx_data[8];  //!&lt; Stores received data 
  uint8_t rx_pec_match; //!&lt; If a PEC error was detected during most recent read cmd
} ic_register;</code></pre> 
<h2>（3）跳转cv定义</h2> 
<p>        已知信息：电池电压寄存器组总共有A-F，总共6组。每组存放3个电池的电压值，每一个电池的电压值用16位表示。并且电压值我们只会读，不会写，因此只需要定义一块内存用来存储电池电压。</p> 
<p>        c_code[0]存储电池1电压，c_code[1]存储电池2电压......，c_code[17]存储电池18电压。pec_match[0]存储电池电压寄存器A是否读取错误......pec_match[5]存储电池电压寄存器F是否读取错误</p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/cc/d1/1AXwtrzU_o.png" width="1200"></p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/de/99/MZUJD2E1_o.png" width="1200"></p> 
<pre><code class="language-cpp">/*! Cell Voltage data structure. */
typedef struct
{
  uint16_t c_codes[18]; //!&lt; Cell Voltage Codes
  uint8_t pec_match[6]; //!&lt; If a PEC error was detected during most recent read cmd
} cv;</code></pre> 
<p>处理数据的办法有两种，我们已知有6组数据，每一组数据有3个</p> 
<ul><li>方法一：定义一个二维数组 uint16_t arr[6][3];</li></ul> 
<pre><code class="language-cpp">for(int i=0;i&lt;6;i++)
{
    for(int j=0;j&lt;3;j++)
    {
        arr[i][j]表示电池电压寄存器组i的第j个电池
    }
}</code></pre> 
<ul><li>方法二：定义一个一维数组arr[18]；</li></ul> 
<pre><code class="language-cpp">cur_reg//我要读取的电池电压寄存器cur_reg(范围：012345)
cur_num//我要读取的电池电压寄存器的第几个电池电压(范围：012)
arr[(cur_reg-1)*3+cur_num]//我要读取的电池电压寄存器cur_reg的第cur_num个电池电压</code></pre> 
<h2>（4）跳转st定义</h2> 
<p><img alt="" height="487" src="https://images2.imgbox.com/89/66/ZogKnYRP_o.png" width="1200"></p> 
<pre><code class="language-cpp">/*! Status Reg data structure. */
typedef struct
{
  uint16_t stat_codes[4]; //!&lt; Status codes.SC ITMP VA VD
  uint8_t flags[3]; //!&lt; flag[0]:C4OV C4UV C3OV C3UV C2OV C2UV C1OV C1UV 依此内推
  uint8_t mux_fail[1]; //!&lt; Mux self test status flag  MUXFAIL
  uint8_t thsd[1]; //!&lt; Thermal shutdown status	THSD
  uint8_t pec_match[2]; //!&lt; pec_match[0]记录状态寄存器A是否读取错误  pec_match[1]记录状态寄存器B是否读取错误
} st;</code></pre> 
<h2>（5）总结</h2> 
<p>        由上述的结构可以看出，把寄存器当成一个对象，寄存器里面存放的不同内容就是他的属性。把adbms1818当成一个对象，不同的寄存器就是它的属性。因此在阅读别人的代码时，你就可以看结构体，这样可以更快的入手此芯片的作用</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88cecb6b58d448d789b6b514e0000b2f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS新手入门笔记整理：JS语法基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6cb3f095c1ee2b51af449af2c7cb8d32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MybatisPlus—IService接口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>