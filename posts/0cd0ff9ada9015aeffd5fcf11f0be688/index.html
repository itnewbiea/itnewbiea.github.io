<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉树的概念及堆 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】二叉树的概念及堆" />
<meta property="og:description" content="前言 我们已经学过了顺序表、链表、栈和队列这些属于线性结构的数据结构，那么下面我们就要学习我们第一个非线性结构，非线性结构又有哪些值得我们使用的呢？那么接下来我们就将谈谈树的概念了。
1.树的概念与结构 1.1树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点。除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继。树是递归定义的。 注意：树形结构中，子树之间不能有交集，否则就不是树形结构，那样可能是图了，后续还会学习。
1.2树的相关概念 节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
树的高度或深度：树中节点的最大层次； 如上图：树的高度为4
堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点
节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
1.3树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既要保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
typedef int DataType;
struct Node
{
struct Node* firstchild; //第一个孩子节点
struct Node* pnextbrother; //指向其下一个兄弟节点
DataType data; //结点中的数据域
};
1.4树在实际中的运用（表示文件系统的目录树结构） Linux中的文件目录就是按照一种树形结构来实现的。
2.二叉树的概念与结构 2.1概念 一棵二叉树是结点的一个有限集合，该集合:
或者为空由一个根节点加上两棵别称为左子树和右子树的二叉树组成 从上图可以明显看出：
二叉树不存在度大于2的结点 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树注意：对于任意的二叉树都是由以下几种情况复合而成的： 2.2现实中的二叉树 简直是大自然的奇迹，相信当我们程序员看到这样一颗树，呼之欲出的就是二叉树啦。 2.3特殊的二叉树 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是 2^k-1，则它就是满二叉树。完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。 2.4二叉树的性质 1. 若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有 2^（i-1）个结点." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0cd0ff9ada9015aeffd5fcf11f0be688/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T21:28:15+08:00" />
<meta property="article:modified_time" content="2024-01-06T21:28:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉树的概念及堆</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2> 前言</h2> 
<blockquote> 
 <p>我们已经学过了<span style="color:#956fe7;">顺序表、链表、栈和队列</span>这些属于<span style="color:#956fe7;">线性结构</span>的数据结构，那么下面我们就要学习我们第一个非<span style="color:#956fe7;">线性结构</span>，非线性结构又有哪些值得我们使用的呢？那么接下来我们就将谈谈树的概念了。</p> 
</blockquote> 
<h2>1.树的概念与结构</h2> 
<h3>1.1树的概念</h3> 
<blockquote> 
 <p>树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p> 
</blockquote> 
<ul><li> 有一个特殊的结点，称为根结点，根节点没有前驱结点。</li><li>除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继。</li><li>树是递归定义的。</li></ul> 
<p><img alt="" height="402" src="https://images2.imgbox.com/21/32/aMwZNtKP_o.png" width="1046"></p> 
<p><span style="color:#956fe7;"> 注意：树形结构中，子树之间不能有交集，否则就不是树形结构，那样可能是图了，后续还会学习。</span></p> 
<h3>1.2树的相关概念</h3> 
<p><img alt="" height="274" src="https://images2.imgbox.com/fc/3d/FbwItQcZ_o.png" width="516"></p> 
<p><span style="color:#956fe7;"> 节点的度：</span>一个节点含有的子树的个数称为该节点的度； 如上图：A的为6<br><span style="color:#956fe7;">叶节点或终端节点：</span>度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点<br><span style="color:#956fe7;">非终端节点或分支节点：</span>度不为0的节点； 如上图：D、E、F、G...等节点为分支节点<br><span style="color:#956fe7;">双亲节点或父节点：</span><span style="color:#fe2c24;">若一个节点含有子节点，则这个节点称为其子节点的父节点；</span> 如上图：A是B<span style="color:#956fe7;">的父节点孩子节点或子节点：</span>一<span style="color:#fe2c24;">个节点含有的子树的根节点称为该节点的子节点</span>； 如上图：B是A的孩子节点<br><span style="color:#956fe7;">兄弟节点：</span><span style="color:#fe2c24;">具有相同父节点的节点互称为兄弟节点</span>； 如上图：B、C是兄弟节点<br><span style="color:#956fe7;">树的度：</span>一棵树中，最<span style="color:#fe2c24;">大的节点的度称为树的度</span>； 如上图：树的度为6<br><span style="color:#956fe7;">节点的层次：</span>从根开始定义起，<span style="color:#fe2c24;">根为第1层，根的子节点为第2层</span>，以此类推；<br><span style="color:#956fe7;">树的高度或深度：</span><span style="color:#fe2c24;">树中节点的最大层次</span>； 如上图：树的高度为4<br><span style="color:#956fe7;">堂兄弟节点：</span><span style="color:#fe2c24;">双亲在同一层的节点互为堂兄弟</span>；如上图：H、I互为兄弟节点<br><span style="color:#956fe7;">节点的祖先：</span>从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先<br><span style="color:#956fe7;">子孙：</span>以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙<br><span style="color:#956fe7;">森林：</span>由m（m&gt;0）棵互不相交的树的集合称为森林；</p> 
<h3>1.3树的表示</h3> 
<blockquote> 
 <p>树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，<span style="color:#fe2c24;">既要保存值域，也要保存结点和结点之间的关系</span>，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的<span style="color:#fe2c24;">孩子兄弟表示法。</span></p> 
</blockquote> 
<blockquote> 
 <p> typedef int DataType;<br> struct Node<br> {<!-- --><br>     struct Node* firstchild;   //第一个孩子节点<br>     struct Node* pnextbrother;  //指向其下一个兄弟节点<br>     DataType data;                //结点中的数据域<br> };</p> 
</blockquote> 
<p> <img alt="" height="320" src="https://images2.imgbox.com/52/e4/Eor67uqq_o.png" width="1117"></p> 
<h3>1.4树在实际中的运用（表示文件系统的目录树结构）</h3> 
<p>Linux中的文件目录就是按照一种树形结构来实现的。</p> 
<p><img alt="" height="687" src="https://images2.imgbox.com/ff/3e/bKGAznGm_o.png" width="1200"></p> 
<h2>2.二叉树的概念与结构</h2> 
<h3>2.1概念</h3> 
<p><strong>一棵二叉树是结点的一个有限集合，该集合:</strong></p> 
<ul><li>或者为空</li><li>由一个根节点加上两棵别称为左子树和右子树的二叉树组成</li></ul> 
<p><img alt="" height="414" src="https://images2.imgbox.com/b3/02/aAn0WXRH_o.png" width="861"></p> 
<p> 从上图可以明显看出：</p> 
<ul><li> 二叉树不存在度大于2的结点</li><li> 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树</li><li>注意：对于任意的二叉树都是由以下几种情况复合而成的：</li></ul> 
<p><img alt="" height="263" src="https://images2.imgbox.com/fe/c8/0Tbaz7oH_o.png" width="813"></p> 
<h3>2.2现实中的二叉树</h3> 
<p><img alt="" height="605" src="https://images2.imgbox.com/76/c6/xVoxABNl_o.png" width="720"></p> 
<p>简直是大自然的奇迹，相信当我们程序员看到这样一颗树，呼之欲出的就是二叉树啦。 </p> 
<h3>2.3特殊的二叉树</h3> 
<ol><li>满二叉树：一个二叉树，如果<span style="color:#956fe7;">每一个层的结点数都达到最大值</span>，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是 2^k-1，则它就是满二叉树。</li><li>完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</li></ol> 
<p> <img alt="" height="392" src="https://images2.imgbox.com/28/a2/Mfudi5uK_o.png" width="1117"></p> 
<h3>2.4二叉树的性质</h3> 
<p>1. 若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有 2^（i-1）个结点.<br> 2. 若规定根节点的层数为1，则深度为h的二叉树的最大结点数是2^h-1.<br> 3. 对任何一棵二叉树, 如果度为0其叶结点个数为n0 , 度为2的分支结点个数为n2,则有 n0＝n2 ＋1<br> 4. 若规定根节点的层数为1，具有n个结点的满二叉树的深度，h=log2（n+1)<br> 是log以2为底n+1的对数。<br> 5. 对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的结点有：</p> 
<ul><li>若i&gt;0，i位置节点的双亲序号：(i-1)/2；i=0，i为根节点编号，无双亲节点</li><li>若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;=n否则无左孩子</li><li>若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;=n否则无右孩子</li></ul> 
<blockquote> 
 <p>1. 某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二叉树中的叶子结点数为（ ）<br> A 不存在这样的二叉树<br> B 200<br> C 198<br> D 199<br> 2.下列数据结构中，不适合采用顺序存储结构的是（ ）<br> A 非完全二叉树<br> B 堆<br> C 队列<br> D 栈<br> 3.在具有 2n 个结点的完全二叉树中，叶子结点个数为（ ）<br> A n<br> B n+1<br> C n-1<br> D n/2<br> 4.一棵完全二叉树的节点数位为531个，那么这棵树的高度为（ ）<br> A 11<br> B 10<br> C 8<br> D 12<br> 5.一个具有767个节点的完全二叉树，其叶子节点个数为（）<br> A 383<br> B 384<br> C 385<br> D 386<br> 答案：<br> 1.B<br> 2.A<br> 3.A<br> 4.B<br> 5.B</p> 
</blockquote> 
<h3>2.5二叉树的存储结构</h3> 
<p>二叉树一般可以使用两种存储方式，一种是顺序存储、一种是链式存储。</p> 
<h4>2.5.1顺序存储</h4> 
<p>顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。</p> 
<p>而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</p> 
<p><img alt="" height="570" src="https://images2.imgbox.com/20/8a/HzfCxZYw_o.png" width="1200"></p> 
<h4>2.5.2链式存储</h4> 
<p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程学到高阶数据结构如红黑树等会用到三叉链。</p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/2f/ef/hI2RpD7q_o.png" width="479"></p> 
<p> <img alt="" height="260" src="https://images2.imgbox.com/05/de/7RdDSumC_o.png" width="674"></p> 
<blockquote> 
 <p> typedef int BTDataType;<br> // 二叉链<br> struct BinaryTreeNode<br> {<!-- --><br>     struct BinTreeNode* pLeft; // 指向当前节点左孩子<br>     struct BinTreeNode* pRight; // 指向当前节点右孩子<br>     BTDataType data; // 当前节点值域<br> };<br> // 三叉链<br> struct BinaryTreeNode<br> {<!-- --><br>     struct BinTreeNode* pParent; // 指向当前节点的双亲<br>     struct BinTreeNode* pLeft; // 指向当前节点左孩子<br>     struct BinTreeNode* pRight; // 指向当前节点右孩子<br>     BTDataType data; // 当前节点值域<br> };</p> 
</blockquote> 
<h2>3.二叉树的顺序结构及其实现代码</h2> 
<h3>3.1二叉树的顺序结构</h3> 
<p><span style="color:#fe2c24;">普通的二叉树</span>是<span style="color:#fe2c24;">不适合用数组来存储的</span>，因为可能会存在<span style="color:#fe2c24;">大量的空间浪费</span>。而完全二叉树更适合使用顺序结构存储。现实中我们通常把<span style="color:#fe2c24;">堆</span>(一种二叉树)使用顺序结构的数组来存储，<span style="color:#956fe7;">需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。</span></p> 
<h3>3.2堆的概念及结构</h3> 
<blockquote> 
 <p>如果有一个关键码的集合K = { k0，k1 ，k2 ，…，kn-1 }，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足：Ki &lt;= K2*i+1且 Ki&lt;=K2*i+2  (Ki &gt;= K2*i+1且 Ki&gt;=K2*i+2,K后内容均为下标 ) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p> 
</blockquote> 
<p><strong> 堆的性质</strong>：</p> 
<blockquote> 
 <ul><li> <p>堆总是一棵完全二叉树。</p> </li><li>堆中某个节点的值总是不大于或不小于其父节点的值；</li></ul> 
</blockquote> 
<p> <img alt="" height="359" src="https://images2.imgbox.com/1b/2c/9QivYUwt_o.png" width="411"></p> 
<blockquote> 
 <p> 1.下列关键字序列为堆的是：（）<br> A 100,60,70,50,32,65<br> B 60,70,65,50,32,100<br> C 65,100,70,32,50,60<br> D 70,65,100,32,50,60<br> E 32,50,100,70,65,60<br> F 50,100,70,65,60,32<br> 2.已知小根堆为8,15,10,21,34,16,12，删除关键字 8 之后需重建堆，在此过程中，关键字之间的比较次数是（）。<br> A 1<br> B 2<br> C 3<br> D 4<br> 3.一组记录排序码为(5 11 7 2 3 17),则利用堆排序方法建立的初始堆为<br> A(11 5 7 2 3 17)<br> B(11 5 7 2 17 3)<br> C(17 11 7 2 3 5)<br> D(17 11 7 5 3 2)<br> E(17 7 11 3 5 2)<br> F(17 7 11 3 2 5)<br> 4.最小堆[0,3,2,5,7,4,6,8],在删除堆顶元素0之后，其结果是（）<br> A[3，2，5，7，4，6，8]<br> B[2，3，5，7，4，6，8]<br> C[2，3，4，5，7，8，6]<br> D[2，3，4，5，6，7，8]</p> 
 <p></p> 
</blockquote> 
<p><br><strong>选择题答案</strong>：</p> 
<blockquote> 
 <p><br> 1.A<br> 2.C<br> 3.C<br> 4.C</p> 
</blockquote> 
<p></p> 
<h3>3.3堆的实现</h3> 
<h4>3.3.1堆的调整算法</h4> 
<p><strong>向下调整</strong></p> 
<blockquote> 
 <p>现在我们给出一个数组，逻辑上看做一颗完全二叉树。我们通过从根节点开始的向下调整算法可以把它调整成一个小堆。向下调整算法有一个前提：左右子树必须是一个堆，才能调整。</p> 
 <p>     int array[] = {27,15,19,18,28,34,65,49,25,37};</p> 
</blockquote> 
<p> <img alt="" height="671" src="https://images2.imgbox.com/ec/c1/ZkaShWX3_o.png" width="1200"></p> 
<p><strong> 向下调整算法代码实现</strong>：</p> 
<pre><code class="language-cpp">void Swap(HPDatetype* pa, HPDatetype* pb)
{
	HPDatetype tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}
void AdjustDown(HPDatetype* a, int size, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; size)
	{
		//若假设的左孩子小，若假设是错的，更新一下
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &lt; a[child])
		{
			child++;
		}
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = child * 2 + 1;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<p> 向上与向下调整算法类似。</p> 
<pre><code class="language-cpp">void Swap(HPDatetype* pa, HPDatetype* pb)
{
	HPDatetype tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}
void AdjustUp(HPDatetype* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (parent - 1) / 2;
		}
		else
		{
			break;
		}
	}

}</code></pre> 
<h4>3.3.2堆的创建</h4> 
<blockquote> 
 <p>下面我们给出一个数组，这个数组逻辑上可以看做一颗完全二叉树，但是还不是一个堆，现在我们通过算法，把它构建成一个堆。根节点左右子树不是堆，我们怎么调整呢？这里我们从倒数的第一个非叶子节点的子树开始调整，一直调整到根节点的树，就可以调整成堆。</p> 
 <p>int a[] = {1,5,3,8,7,6}; </p> 
</blockquote> 
<p> <img alt="" height="606" src="https://images2.imgbox.com/4d/6f/cGoufvZ9_o.png" width="1003"></p> 
<p></p> 
<h4>3.3.3堆建时间复杂度</h4> 
<p>因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明(时间复杂度本来看的就是近似值，多几个节点不影响最终结果)：</p> 
<p><img alt="" height="719" src="https://images2.imgbox.com/3e/7d/RYuVK9i0_o.png" width="1200"></p> 
<p>故建堆的时间复杂度为O（n）。 </p> 
<h4>3.3.4堆的插入</h4> 
<p>先插入一个数到数组的尾上，再进行向上调整算法，直到满足堆。</p> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="language-cpp">void HeapPush(HP* php, int x)
{
	assert(php);
	if (php-&gt;capacity == php-&gt;size)
	{
		int newcapacity = php-&gt;capacity == 0 ? 4 : sizeof(php-&gt;a) * 2;
		HPDatetype * tmp = (HPDatetype*)realloc(php-&gt;a, newcapacity*sizeof(HPDatetype));
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(-1);
		}
		php-&gt;a = tmp;
		php-&gt;capacity = newcapacity;
	}
	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;
	
	AdjustUp(php-&gt;a, php-&gt;size - 1);
}</code></pre> 
<h4>3.3.5堆的删除</h4> 
<p>删除堆是删除堆顶的数据，将堆顶的数据跟最后一个数据一换，然后删除数组最后一个数据，再进行向下调整算法。</p> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="language-cpp">void HeapPop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);

	Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
	php-&gt;size--;
	AdjustDown(php-&gt;a, php-&gt;size, 0);
}</code></pre> 
<h4>3.3.6堆的代码实现</h4> 
<p>Heap.h</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;time.h&gt;

typedef int HPDatetype;

typedef struct Heap
{
	int* a;
	int size;
	int capacity;
}HP;

//堆的初始化
void HeapIint(HP* php);

//堆的销毁
void HeapDestroy(HP* php);

//堆的插入
void HeapPush(HP* php, int child);

//堆的删除
void HeapPop(HP* php);

//取堆顶元素
HPDatetype HeapTop(HP* php);

//堆的数据个数
int HeapSize(HP* php);

//堆的判空
bool HeapEmpty(HP* php);</code></pre> 
<p>Heap.c</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include"Heap.h"

void HeapIint(HP* php)
{
	assert(php);
	php-&gt;a = NULL;
	php-&gt;size = 0;
	php-&gt;capacity = 0;
}

void HeapDestroy(HP* php)
{
	assert(php);
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;capacity = 0;
	php-&gt;size = 0;
}
void Swap(HPDatetype* pa, HPDatetype* pb)
{
	HPDatetype tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}
void AdjustUp(HPDatetype* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (parent - 1) / 2;
		}
		else
		{
			break;
		}
	}

}
void HeapPush(HP* php, int x)
{
	assert(php);
	if (php-&gt;capacity == php-&gt;size)
	{
		int newcapacity = php-&gt;capacity == 0 ? 4 : sizeof(php-&gt;a) * 2;
		HPDatetype * tmp = (HPDatetype*)realloc(php-&gt;a, newcapacity*sizeof(HPDatetype));
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(-1);
		}
		php-&gt;a = tmp;
		php-&gt;capacity = newcapacity;
	}
	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;
	
	AdjustUp(php-&gt;a, php-&gt;size - 1);
}
void AdjustDown(HPDatetype* a, int size, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; size)
	{
		//若假设的左孩子小，若假设是错的，更新一下
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &lt; a[child])
		{
			child++;
		}
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = child * 2 + 1;
		}
		else
		{
			break;
		}
	}
}
void HeapPop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);

	Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
	php-&gt;size--;
	AdjustDown(php-&gt;a, php-&gt;size, 0);
}

HPDatetype HeapTop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);

	return php-&gt;a[0];
}

int HeapSize(HP* php)
{
	assert(php);

	return php-&gt;size;
}

bool HeapEmpty(HP* php)
{
	assert(php);

	return php-&gt;size == 0;
}</code></pre> 
<h3>3.4堆的应用</h3> 
<h4>3.4.1 堆排序</h4> 
<h5>1.建堆</h5> 
<blockquote> 
 <p>根据升序和降序来决定是建大堆还是建小堆，</p> 
 <p>升序建大堆，反之建小堆。</p> 
</blockquote> 
<h5>2.利用堆删除思想来进行排序</h5> 
<p><img alt="" height="793" src="https://images2.imgbox.com/f6/9d/wzfCRcVQ_o.png" width="819"></p> 
<p></p> 
<p> <strong>代码实现堆排序</strong>：</p> 
<pre><code class="language-cpp">void HeapSort(int* a, int n)
{
	//升序
	//建大堆
	//降序
	//建小堆
	/*for (int i = 1; i &lt; n; i++)
	{
		AdjustUp(a, i);
	}*/
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)
	{
		AdjustDown(a, n, i);
	}
	//选数
	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);
		end--;
	}
}</code></pre> 
<h4>3.4.2 TOP-K问题</h4> 
<blockquote> 
 <p>TOP-K问题：即求数据结合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。<br> 比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等。<br> 对于Top-K问题，能想到的最简单直接的方式就是排序，但是：如果数据量非常大，排序就不太可取了(可能数据都不能一下子全部加载到内存中)。最佳的方式就是用堆来解决，基本思路如下：</p> 
</blockquote> 
<h5>1. 用数据集合中前K个元素来建堆</h5> 
<blockquote> 
 <p><br> 前k个最大的元素，则建小堆<br> 前k个最小的元素，则建大堆</p> 
</blockquote> 
<h5><br> 2. 用剩余的N-K个元素依次与堆顶元素来比较，不满足则替换堆顶元素</h5> 
<blockquote> 
 <p><br> 将剩余N-K个元素依次与堆顶元素比完之后，堆中剩余的K个元素就是所求的前K个最小或者最大的元素。</p> 
</blockquote> 
<p></p> 
<p><strong>代码实现</strong>： </p> 
<pre><code class="language-cpp">void CreateNDate()
{
	// 造数据
	int n = 10000;
	srand(time(0));
	const char* file = "data.txt";
	FILE* fin = fopen(file, "w");
	if (fin == NULL)
	{
		perror("fopen error");
		return;
	}

	for (size_t i = 0; i &lt; n; ++i)
	{
		int x = rand() % 1000000;
		fprintf(fin, "%d\n", x);
	}

	fclose(fin);
}

void PrintTopK(int k)
{
	FILE* fout = fopen("data.txt", "r");
	if (fout == NULL)
	{
		perror("fopen fail");
		return;
	}
	//建立k个数的小堆
	int* minheap = (int*)malloc(sizeof(int) * k);
	if (minheap == NULL)
	{
		perror("malloc fail");
		return;
	}
	for (int i = 0; i &lt; k; i++)
	{
		fscanf(fout, "%d", &amp;minheap[i]);
		AdjustUp(minheap,i);
	}
	int x = 0;
	while (fscanf(fout, "%d", &amp;x) != EOF)
	{
		if (x &gt; minheap[0])
		{
			minheap[0] = x;
			AdjustDown(minheap, k, 0);
		}
	}
	for (int i = 0; i &lt; k; i++)
	{
		printf("%d ", minheap[i]);
	}
	printf("\n");

	free(minheap);
	minheap = NULL;
	fclose(fout);
}

int main()
{
	int k = 5;
	CreateNDate();
	PrintTopK(k);
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f808f7992fba781f2d73d9b3c7e74bd8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小家电type-c接口PD诱骗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/914e883938704683137a5229c462c677/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Springboot整合RocketMQ 基本消息处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>