<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JUC第一讲：juc并发包深入理解(P6熟练 P7精通) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JUC第一讲：juc并发包深入理解(P6熟练 P7精通)" />
<meta property="og:description" content="并发编程并不是 Java 特有的语言特性，它是一个通用且早已成熟的领域。Java 只是根据自身情况做了实现罢了。并发编程可以总结为三个核心问题：分工、同步、互斥。分工指的是如何高效地拆解任务并分配给线程，而同步指的是线程之间如何协作，互斥则是保证同一时刻只允许一个线程访问共享资源。 例如： Fork/Join 框架就是一种分工模式，CountDownLatch 就是一种典型的同步方式，而可重入锁则是一种互斥手段。当你理解或学习并发编程的时候，如果能够站在较高层面，系统且有体系地思考问题，那就会容易很多。本文是JUC第一讲：并发包深入理解
juc并发包，用过哪些？ 参考 并发编程的艺术 方腾飞 先来一道面试题书籍推荐关于java并发包concurrentHashmap1.1、不同版本的并发hashmap区别 美团1.2、属性1.3、concurrentHashmap组成1.4、put操作1.5、get(key)1.6、扩容时要注意的？1.7、为什么使用ConcurrentHashMap1.8、ConcurrentHashMap使用案例 1、JUC基础知识点1.2、创建线程的三个方法是什么？ 阿里1.3、Java 怎么获取多线程的返回值？ 2、线程池 Executor/ThreadPoolExecute3、阻塞队列 blockingqueue3.1、实现类：（共6种） 4、locks 同步锁(多线程的锁机制) ****5、CopyOnWriteArrayList6、copyonwriteArrayset7、Atomic类 （多线程的原子性操作提供的工具类）8、volatile关键字 详解可以看多线程部分9、cas乐观锁：（非阻塞算法） java中的并发工具类 10/11/12/1310、闭锁countdownlatch （等待多线程完成）实现了join的功能10.1、概念：10.2、可以实现的需求10.3、分析CountDownLatch的实现原理10.5、什么是AQS？******10.6、AQS与锁（如LOCK）的对比10.7、CountDownLatch中的方法？ 11、cyclicBarrier（同步屏障）11.1、cyclicBarrier是什么？11.2、cyclicBarrier底层原理？11.3、cyclicBarrier的应用场景11.4、cyclicBarrier和countDownLatch的区别 12、Semaphore详解（控制并发线程数）13、Exchanger详解（线程间交换数据）14、公平锁和非公平锁15、并发队列-非阻塞队列Action1：获取单例对象需要保证线程安全，其中的方法也要保证线程安全。Action2：创建线程或线程池时请指定有意义的线程名称，方便出错时排查Action3、线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。Action4、线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险。Action5、`SimpleDateFormat` 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils工具类。Action6、高并发时，同步调用应该去考量锁的性能损耗，能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。Action7、对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。Action8、并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version作为更新依据Action9、多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，使用 `ScheduledExecutorService` 则没有这个问题。Action10、使用CountDownLatch 进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果。Action11、避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致性能下降Action12、在并发场景下，通过双重检查锁(double-checked locking) 实现延迟初始化的优化问题隐患，推荐解决方案中较为简单的一种，将目标属性声明为volatile型 （比如修改 helper 的属性声明为 `private volatile Helper helper = null;`）Action13、volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。Action14、HashMap在容量不够进行 resize 时，由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其他数据结构或加锁来规避此风险Action15、ThreadLocal 无法解决共享对象的更新问题，ThreadLocal对象建议使用 static 修饰。Action16、必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收Action17、在使用阻塞等待获取锁的方式中， 必须在 try 代码块之外， 并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用， 避免加锁成功后， 在 finally 中无法解锁。Action18、资金相关的金融敏感信息， 使用悲观锁策略。 先来一道面试题 面试题1：如何使线程按序交替？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0b35b6f36e8f6820f71e77ce0d19f28e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-21T01:47:26+08:00" />
<meta property="article:modified_time" content="2022-09-21T01:47:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JUC第一讲：juc并发包深入理解(P6熟练 P7精通)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>并发编程并不是 Java 特有的语言特性，它是一个通用且早已成熟的领域。Java 只是根据自身情况做了实现罢了。并发编程可以总结为三个核心问题：<strong>分工、同步、互斥</strong>。<mark><strong>分工</strong>指的是如何高效地拆解任务并分配给线程，而<strong>同步</strong>指的是线程之间如何协作，<strong>互斥</strong>则是保证同一时刻只允许一个线程访问共享资源。</mark> 例如： <strong>Fork/Join 框架就是一种分工模式，CountDownLatch 就是一种典型的同步方式，而可重入锁则是一种互斥手段</strong>。当你理解或学习并发编程的时候，如果能够站在较高层面，系统且有体系地思考问题，那就会容易很多。<mark>本文是JUC第一讲：并发包深入理解</mark></p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>juc并发包，用过哪些？ 参考 并发编程的艺术 方腾飞</h4> 
 <ul><li><a href="#_4" rel="nofollow">先来一道面试题</a></li><li><ul><li><a href="#_11" rel="nofollow">书籍推荐</a></li><li><a href="#java_19" rel="nofollow">关于java并发包</a></li><li><a href="#concurrentHashmap_28" rel="nofollow">concurrentHashmap</a></li><li><ul><li><ul><li><a href="#11hashmap____31" rel="nofollow">1.1、不同版本的并发hashmap区别 美团</a></li><li><a href="#12_39" rel="nofollow">1.2、属性</a></li><li><a href="#13concurrentHashmap_51" rel="nofollow">1.3、concurrentHashmap组成</a></li><li><a href="#14put_53" rel="nofollow">1.4、put操作</a></li><li><a href="#15getkey_69" rel="nofollow">1.5、get(key)</a></li><li><a href="#16_72" rel="nofollow">1.6、扩容时要注意的？</a></li><li><a href="#17ConcurrentHashMap_83" rel="nofollow">1.7、为什么使用ConcurrentHashMap</a></li><li><a href="#18ConcurrentHashMap_86" rel="nofollow">1.8、ConcurrentHashMap使用案例</a></li></ul> 
   </li></ul> 
   </li><li><a href="#1JUC_124" rel="nofollow">1、JUC基础知识点</a></li><li><ul><li><a href="#12__244" rel="nofollow">1.2、创建线程的三个方法是什么？ 阿里</a></li><li><a href="#13Java__292" rel="nofollow">1.3、Java 怎么获取多线程的返回值？</a></li></ul> 
   </li><li><a href="#2_ExecutorThreadPoolExecute_334" rel="nofollow">2、线程池 Executor/ThreadPoolExecute</a></li><li><a href="#3___blockingqueue_345" rel="nofollow">3、阻塞队列 blockingqueue</a></li><li><ul><li><ul><li><a href="#316_361" rel="nofollow">3.1、实现类：（共6种）</a></li></ul> 
   </li></ul> 
   </li><li><a href="#4locks_____426" rel="nofollow">4、locks 同步锁(多线程的锁机制) ****</a></li><li><a href="#5CopyOnWriteArrayList_516" rel="nofollow">5、CopyOnWriteArrayList</a></li><li><a href="#6copyonwriteArrayset_527" rel="nofollow">6、copyonwriteArrayset</a></li><li><a href="#7Atomic__552" rel="nofollow">7、Atomic类 （多线程的原子性操作提供的工具类）</a></li><li><a href="#8volatile___605" rel="nofollow">8、volatile关键字 详解可以看多线程部分</a></li><li><a href="#9cas_612" rel="nofollow">9、cas乐观锁：（非阻塞算法）</a></li></ul> 
  </li><li><a href="#java_10111213_706" rel="nofollow">java中的并发工具类 10/11/12/13</a></li><li><ul><li><a href="#10countdownlatch_join_707" rel="nofollow">10、闭锁countdownlatch （等待多线程完成）实现了join的功能</a></li><li><ul><li><ul><li><a href="#101_708" rel="nofollow">10.1、概念：</a></li><li><a href="#102_713" rel="nofollow">10.2、可以实现的需求</a></li><li><a href="#103CountDownLatch_719" rel="nofollow">10.3、分析CountDownLatch的实现原理</a></li><li><a href="#105AQS_724" rel="nofollow">10.5、什么是AQS？******</a></li><li><a href="#106AQSLOCK_755" rel="nofollow">10.6、AQS与锁（如LOCK）的对比</a></li><li><a href="#107CountDownLatch_760" rel="nofollow">10.7、CountDownLatch中的方法？</a></li></ul> 
   </li></ul> 
   </li><li><a href="#11cyclicBarrier_770" rel="nofollow">11、cyclicBarrier（同步屏障）</a></li><li><ul><li><ul><li><a href="#111cyclicBarrier_771" rel="nofollow">11.1、cyclicBarrier是什么？</a></li><li><a href="#112cyclicBarrier_776" rel="nofollow">11.2、cyclicBarrier底层原理？</a></li><li><a href="#113cyclicBarrier_782" rel="nofollow">11.3、cyclicBarrier的应用场景</a></li><li><a href="#114cyclicBarriercountDownLatch_786" rel="nofollow">11.4、cyclicBarrier和countDownLatch的区别</a></li></ul> 
   </li></ul> 
   </li><li><a href="#12Semaphore_794" rel="nofollow">12、Semaphore详解（控制并发线程数）</a></li><li><a href="#13Exchanger_809" rel="nofollow">13、Exchanger详解（线程间交换数据）</a></li><li><a href="#14_817" rel="nofollow">14、公平锁和非公平锁</a></li><li><a href="#15_826" rel="nofollow">15、并发队列-非阻塞队列</a></li><li><a href="#Action1_839" rel="nofollow">Action1：获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</a></li><li><a href="#Action2_842" rel="nofollow">Action2：创建线程或线程池时请指定有意义的线程名称，方便出错时排查</a></li><li><a href="#Action3_863" rel="nofollow">Action3、线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</a></li><li><a href="#Action4ExecutorsThreadPoolExecutor__866" rel="nofollow">Action4、线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险。</a></li><li><a href="#Action5SimpleDateFormat__static__static_DateUtils_875" rel="nofollow">Action5、`SimpleDateFormat` 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils工具类。</a></li><li><a href="#Action6_897" rel="nofollow">Action6、高并发时，同步调用应该去考量锁的性能损耗，能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</a></li><li><a href="#Action7_900" rel="nofollow">Action7、对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</a></li><li><a href="#Action8_version_903" rel="nofollow">Action8、并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version作为更新依据</a></li><li><a href="#Action9TimerTimeTask_ScheduledExecutorService__906" rel="nofollow">Action9、多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，使用 `ScheduledExecutorService` 则没有这个问题。</a></li><li><a href="#Action10CountDownLatch_countDowncatch_countDown__await__907" rel="nofollow">Action10、使用CountDownLatch 进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果。</a></li><li><a href="#Action11Randomseed__910" rel="nofollow">Action11、避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致性能下降</a></li><li><a href="#Action12doublechecked_locking_volatile__helper__private_volatile_Helper_helper__null_914" rel="nofollow">Action12、在并发场景下，通过双重检查锁(double-checked locking) 实现延迟初始化的优化问题隐患，推荐解决方案中较为简单的一种，将目标属性声明为volatile型 （比如修改 helper 的属性声明为 `private volatile Helper helper = null;`）</a></li><li><a href="#Action13volatile__933" rel="nofollow">Action13、volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</a></li><li><a href="#Action14HashMap_resize__CPU__945" rel="nofollow">Action14、HashMap在容量不够进行 resize 时，由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其他数据结构或加锁来规避此风险</a></li><li><a href="#Action15ThreadLocal_ThreadLocal_static__949" rel="nofollow">Action15、ThreadLocal 无法解决共享对象的更新问题，ThreadLocal对象建议使用 static 修饰。</a></li><li><a href="#Action16_ThreadLocal__ThreadLocal__tryfinally__952" rel="nofollow">Action16、必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收</a></li><li><a href="#Action17__try___try____finally__963" rel="nofollow">Action17、在使用阻塞等待获取锁的方式中， 必须在 try 代码块之外， 并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用， 避免加锁成功后， 在 finally 中无法解锁。</a></li><li><a href="#Action18__994" rel="nofollow">Action18、资金相关的金融敏感信息， 使用悲观锁策略。</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_4"></a>先来一道面试题</h2> 
<p>面试题1：如何使线程按序交替？</p> 
<blockquote> 
 <ul><li>实现方式：先做一个标记number=1；定义三个方法，先判断是否number为1，阻塞其他线程，打印当前线程，唤醒2号线程</li></ul> 
</blockquote> 
<h3><a id="_11"></a>书籍推荐</h3> 
<p>1、《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea(<strong>基础篇</strong>)<br> 2、《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增(<strong>高段位</strong>)<br> 3、《图解Java多线程设计模式》并发编程设计模式方面的经典书籍<br> 4、《操作系统：精髓与设计原理》经典操作系统教材<br> 5、http://ifeve.com 国内专业并发编程网站<br> 6、http://www.cs.umd.edu/~pugh/java/memoryModel/ 很多并发编程的早期资料都在这里</p> 
<h3><a id="java_19"></a>关于java并发包</h3> 
<p>JUC就是 java.util .concurrent 工具包的简称。这是一个处理线程的工具包， JDK1.5 开始出现的。它加了一些在并发编程中常用的工具类，用于定义类似线程的自定义子系统，包括线程池，异步io，轻量级任务框架等。</p> 
<h3><a id="concurrentHashmap_28"></a>concurrentHashmap</h3> 
<p><mark>一种线程安全的hash表，对于多线程的操作，性能介于hashmap和hashtable之间</mark></p> 
<h5><a id="11hashmap____31"></a>1.1、不同版本的并发hashmap区别 美团</h5> 
<table><thead><tr><th>版本</th><th>数据结构</th></tr></thead><tbody><tr><td>jdk1.7</td><td>内部采用了锁分段机制来替代 hashtable 的独占锁(<strong>也就是每一个 Segment 上同时只有一个线程可以操作</strong>)，从而提高了性能 segment[] 数组和HashEntry[] 数组， Segment 的个数一但初始化就不能改变， 默认 Segment的个数是 16 个</td></tr><tr><td>jdk1.8</td><td>进行put操作时：<mark>上面的segment采用的是 cas 机制来保证线程安全的</mark>。<strong>使用的 Synchronized 锁加 CAS 的机制</strong>。 结构也由Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树）。Node 是类似于一个 HashEntry 的结构。 它的冲突再达到一定大小时会转化成红黑树， 在冲突小于一定数量时又退回链表</td></tr></tbody></table> 
<h5><a id="12_39"></a>1.2、属性</h5> 
<table><thead><tr><th>initialCapacity初始容量</th><th>16</th></tr></thead><tbody><tr><td>loadFactor 加载因子</td><td>0.75</td></tr><tr><td>concurrencyLevel 并发级别</td><td>16</td></tr><tr><td>table</td><td>默认为null，初始化发生在第一次put操作，默认大小为16的数组</td></tr><tr><td>nextTable</td><td>默认为null，扩容时新生成的数组，其大小为原数组的两倍</td></tr><tr><td>sizeCtl</td><td>默认为0，用来控制table的初始化和扩容操作（-1代表table正在初始化，-N表示n-1个线程正在扩容操作）</td></tr><tr><td>Node</td><td>保存key，value及key的hash值的数据结构（Node：保存key，value及key的hash值的数据结构）</td></tr><tr><td>Segment的数组大小一定是2的次幂？</td><td></td></tr></tbody></table> 
<blockquote> 
 <p>主要是便于通过按位与的散列算法来定位Segment的index,保证存储空间的充分利用。</p> 
</blockquote> 
<h5><a id="13concurrentHashmap_51"></a>1.3、concurrentHashmap组成</h5> 
<p><em>由Segment的数组结构（一种可重入的reentrantLock）和HashEntry数组结构（存储键值对数据）组成，对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁</em></p> 
<h5><a id="14put_53"></a>1.4、put操作</h5> 
<p>1、假设table已经初始化完成，put操作采用CAS+synchronized实现并发插入或更新操作<br> 2、首先对key.hashcode进行hash操作，得到key的hash值，定位索引位置，index = hash &amp;(length-1)<br> 3、获取table中对应索引的对象f，node类型：Unsafe.getObjectVolatile来获取 tabAt[index]，获取指定内存的数据，保证每次拿到数据都是最新<br> 4、如果f为null，说明table中该位置第一次插入元素，利用CAS方法插入Node节点</p> 
<blockquote> 
 <ol><li>CAS成功，说明Node节点已经插入，随后检查是否需要进行扩容</li><li>CAS失败，说明有其它线程提前插入了节点，自旋重新尝试插入节点 <br> <mark><em>如果f的hash值为-1，意味有其它线程正在扩容，则一起进行扩容操作</em></mark></li></ol> 
</blockquote> 
<p>5、f不为null的其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发（Synchronized锁住Node，减少了锁粒度）</p> 
<blockquote> 
 <ol><li>在节点f上进行同步，节点插入之前，再次利用tabAt(tab, i) == f判断，防止被其它线程修改</li><li>如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点</li><li>如果f是TreeBin类型节点if（f instanceof TreeBin），说明f是红黑树根节点，则在树结构上遍历元素，更新或增加节点</li><li>如果链表中节点数binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构</li></ol> 
</blockquote> 
<h5><a id="15getkey_69"></a>1.5、get(key)</h5> 
<p>无需加锁，涉及的共享变量都使用volatile修饰，volatile保证内存可见性。<br> 获取索引的对象f=tabAt[index]，遍历key，找到相等的，cas来保证变量的原子性读取</p> 
<h5><a id="16_72"></a>1.6、扩容时要注意的？</h5> 
<p>元素数量达到容量阈值sizeCtl（长度*0.75），扩容分为两部分：<br> 1、构建一个nextTable，大小为table的两倍<br> 2、Unsafe.compareAndSwapInt修改sizeCtl值-1，保证只有一个线程初始化，扩容后的数组长度为原来的两倍，但是容量是原来的1.5<br> 3、把table的数据复制到nextTable中：扩容操作支持并发插入，支持节点的并发复制</p> 
<ul><li> <p>ConcurrentHashMap 在扩容时会计算出一个步长（stride），最小值是16，然后给当前扩容线程分配“一个步长”的节点数，例如16个，让该线程去对这16个节点进行扩容操作（将节点从老表移动到新表）。</p> </li><li> <p>如果在扩容结束前又来一个线程，则也会给该线程分配一个步长的节点数让该线程去扩容。依次类推，以达到多线程并发扩容的效果。</p> </li></ul> 
<h5><a id="17ConcurrentHashMap_83"></a>1.7、为什么使用ConcurrentHashMap</h5> 
<p>因为hashmap的线程不安全，在并发环境下，可能会形成环状链表（扩容时造成的，<mark>与transfer函数有关</mark>），导致get操作时，cpu空转。而hashtable实现线程安全的代价太大了，get/put所有相关操作都是基于synchronized的（全表锁）</p> 
<h5><a id="18ConcurrentHashMap_86"></a>1.8、ConcurrentHashMap使用案例</h5> 
<p>这个案例是来演示session会话续期策略的，倘若是用户再次登录系统，会更新其sessionKey的超期时间。renewal为延续session会话，使用的数据结构为ReentrantReadWriteLock读写锁以及ConcurrentHashMap来保存会话信息。</p> 
<pre><code class="prism language-java"><span class="token comment">// redis session读取，会话续期</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisSessionManager</span> <span class="token punctuation">{<!-- --></span>
	 <span class="token comment">/**
     * 会话map   ReentrantReadWriteLock 读锁共享  写锁互斥
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> sessionKeyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addToReNewMap</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token keyword">long</span> lastAccessAt<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>sessionKeyMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">102400</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
               sessionKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> lastAccessAt<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
           rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">renewal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> localSessionKeyMap<span class="token punctuation">;</span>
       rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
           localSessionKeyMap <span class="token operator">=</span> sessionKeyMap<span class="token punctuation">;</span>
           sessionKeyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
           rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       localSessionKeyMap <span class="token operator">=</span> <span class="token class-name">Iters</span><span class="token punctuation">.</span><span class="token function">nullToEmpty</span><span class="token punctuation">(</span>localSessionKeyMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>localSessionKeyMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
           LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"renewal session size = {}"</span><span class="token punctuation">,</span> localSessionKeyMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           localSessionKeyMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>expirationPolicy<span class="token operator">::</span><span class="token function">onExpirationUpdated</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="1JUC_124"></a>1、JUC基础知识点</h3> 
<p>1.2 进程与线程<br> 进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，<strong>是系统进行资源分配和调度的基本单位</strong>，是操作系统结构的基础。</p> 
<p>在当代面向线程设计的计算机结构中，<strong>进程是线程的容器</strong>。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p> 
<p>线程（thread） 是操作系统能够<strong>进行运算调度的最小单位</strong>。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p> 
<p>总结来说:</p> 
<ul><li>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</li><li>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</li></ul> 
<p>1.3 线程的状态<br> 枚举：<code>Thread.State</code></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">/**
	* Thread state for a thread which has not yet started.
	*/</span>
	NEW<span class="token punctuation">,</span><span class="token punctuation">(</span>新建<span class="token punctuation">)</span>
	<span class="token comment">/**
	* Thread state for a runnable thread. A thread in the runnable
	* state is executing in the Java virtual machine but it may
	* be waiting for other resources from the operating system
	* such as processor.
	*/</span>
	RUNNABLE<span class="token punctuation">,</span>（准备就绪）
	<span class="token comment">/**
	* Thread state for a thread blocked waiting for a monitor lock.
	* A thread in the blocked state is waiting for a monitor lock
	* to enter a synchronized block/method or
	* reenter a synchronized block/method after calling
	* {@link Object#wait() Object.wait}.
	*/</span>
	BLOCKED<span class="token punctuation">,</span>（阻塞）
	<span class="token comment">/**
	* Thread state for a waiting thread.
	* A thread is in the waiting state due to calling one of the
	* following methods:
	* &lt;ul&gt;
	* &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
	* &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
	* &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
	* &lt;/ul&gt;
	* *
	&lt;p&gt;A thread in the waiting state is waiting for another thread to
	* perform a particular action.
	*
	* For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;
	* on an object is waiting for another thread to call
	* &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on
	* that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;
	* is waiting for a specified thread to terminate.
	*/</span>
	WAITING<span class="token punctuation">,</span>（不见不散）
	<span class="token comment">/**
	* Thread state for a waiting thread with a specified waiting time.
	* A thread is in the timed waiting state due to calling one of
	* the following methods with a specified positive waiting time:
	* &lt;ul&gt;
	* &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
	* &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
	* &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
	* &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
	* &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
	* &lt;/ul&gt;
	*/</span>
	TIMED_WAITING<span class="token punctuation">,</span>（过时不候）
	<span class="token comment">/**
	* Thread state for a terminated thread.
	* The thread has completed execution.
	*/</span>
	TERMINATED<span class="token punctuation">;</span><span class="token punctuation">(</span>终结<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>wait/sleep 的区别？<br> （1） sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用。<br> （2） sleep 不会释放锁，它也不需要占用锁。 wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在 synchronized 中)。<br> （3） 它们都可以被 interrupted 方法中断</p> 
<p><strong>并发与并行</strong><br> 串行模式</p> 
<ul><li>串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。</li><li><strong>串行是一次只能取得一个任务，并执行这个任务。</strong></li></ul> 
<p><strong>并行模式</strong></p> 
<ul><li>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上则依赖于多核 CPU。</li></ul> 
<p><strong>并发</strong><br> 并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行。 <mark>并发的重点在于它是一种现象</mark>, <mark>并发描述的是多进程同时运行的现象</mark>。但实际上，对于单核心 CPU 来说，同一时刻只能运行一个线程。所以，这里的"同时运行"表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一会停一会。<br> <strong>要解决大并发问题，通常是将大任务分解成多个小任务</strong>, 由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象：</p> 
<ul><li>可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用队列或类似的数据结构来存放各个小任务的成果</li><li>可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或异步的方式，比如只有准备好产生了事件通知才执行某个任务。</li><li>可以多进程/多线程的方式并行执行这些小任务。也可以单进程/单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率</li></ul> 
<p>并发： 同一时刻多个线程在访问同一个资源，多个线程对一个点</p> 
<ul><li>例子：春运抢票 电商秒杀…</li></ul> 
<p>并行： 多项工作一起执行，之后再汇总</p> 
<ul><li>例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</li></ul> 
<p><strong>1.5 管程</strong><br> 管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行</p> 
<p>JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁</p> 
<p>执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程</p> 
<p><strong>1.6 用户线程和守护线程</strong></p> 
<ul><li>用户线程:平时用到的普通线程,自定义线程</li><li>守护线程:运行在后台,是一种特殊的线程,比如垃圾回收</li><li>当主线程结束后,用户线程还在运行,JVM 存活</li><li>如果没有用户线程,都是守护线程,JVM 结束</li></ul> 
<h4><a id="12__244"></a>1.2、创建线程的三个方法是什么？ 阿里</h4> 
<p>常见的Java线程的4种创建方式分别为：继承Thread类、实现Runnable接口、通过ExecutorService和Callable实现有返回值的线程、基于线程池，如下图所示：<br> <img src="https://images2.imgbox.com/54/c4/GMwufMoA_o.png" alt="在这里插入图片描述"></p> 
<ul><li>通过继承 Thread 类创建线程类，该子类重写Thread类的 <code>run</code>方法，Thread类实现了Runnable接口并定义了操作线程的一些方法，我们可以通过继承Thread类的方式创建一个线程 
  <ul><li><strong>优点</strong>：编写简单，如果需要访问当前线程，无需使用 <code>Thread.currentThread()</code>方法，直接使用this，即可获得当前线程；</li><li><strong>缺点</strong>：因为线程类已经继承了Thread类，所以不能再继承其他的父类。</li></ul> </li><li>实现 Runnable 接口创建线程类，实现该类的 <code>run()</code>方法，基于Java编程语言的规范，如果子类已经继承（extends）了一个类，就无法再直接继承Thread类，此时可以通过实现Runnable接口创建线程。具体的实现过程为：通过实现Runnable接口创建ChildrenClassThread 线程，实例化名称为childrenThread的线程实例，创建Thread类的实例并传入childrenThread线程实例，调用线程的start方法启动线程。 
  <ul><li><strong>优点</strong>：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想；</li><li><strong>缺点</strong>：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法</li></ul> </li><li>通过 Callable 和 Future 接口创建线程。</li></ul> 
<p><strong>继承 Thread 类创建线程Demo如下</strong>， 创建一个类并继承Thread接口，然后实例化线程对象并调用<code>start方法</code>启动线程，start方法是一个native方法，通过在操作系统上启动一个新线程，并最终执行run方法来启动一个线程。<strong>run方法内的代码是线程类的具体实现逻辑</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token operator">/</span><span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span><span class="token number">60</span><span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"子线程运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//System.out.println(Thread.currentThread().getName()+" : "+ x);</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//1,继承方式：extends</span>
		<span class="token class-name">ThreadDemo</span> threadDemo<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		threadDemo<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span><span class="token number">60</span><span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"主线程运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/**2,实现接口方式测试：implements
		ThreadDemo threadDemo= new ThreadDemo();
		Thread td1 = new Thread(threadDemo);
		Thread td2 = new Thread(threadDemo);
		Thread td3 = new Thread(threadDemo);
		td1.start();
		td2.start();
		td3.start();
		**/</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码定义了一个名为ThreadDemo的线程类，该类继承了Thread, run方法内的代码为线程的具体执行逻辑，在使用该线程时只需新建一个该线程的对象并调用其start方法即可。</p> 
<p>在JDK源码中，run方法的实现代码如下：<br> <img src="https://images2.imgbox.com/d7/f4/dVUQvS98_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="13Java__292"></a>1.3、Java 怎么获取多线程的返回值？</h4> 
<p>有时，我们需要在主线程中开启多个线程并发执行一个任务，然后收集各个线程执行返回的结果并将最终结果汇总起来，这时就要用到Callable接口。<strong>具体的实现方法为</strong>：创建一个类并实现Callable接口，在call方法中实现具体的运算逻辑并返回计算结果。具体的调用过程为：<mark>创建一个线程池、一个用于接收返回结果的Future List及Callable线程实例，使用线程池提交任务并将线程执行之后的结果保存在Future中，在线程执行结束后遍历Future List中的Future对象，在该对象上调用get方法就可以获取Callable线程任务返回的数据并汇总结果</mark></p> 
<ul><li>通过ExecutorService和Callable实现有返回值的线程</li><li>使用 Thread 的 join 阻塞当前线程等待。</li><li><strong>实现 Callable 接口</strong>（ 通过 FutureTask 或线程池的 Future）</li></ul> 
<p>使用 FutureTask 来获取多线程返回值 Demo<br> <img src="https://images2.imgbox.com/0f/41/5iPInqU1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>通过 Future 接口创建线程 Demo</strong></p> 
<pre><code class="prism language-java"><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Response</span><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildItemTaskCache</span><span class="token punctuation">(</span>paramDTO<span class="token punctuation">.</span><span class="token function">getDistrictIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> itemIds<span class="token punctuation">,</span> itemReadContext<span class="token punctuation">.</span><span class="token function">getIncludeRewriteSaleQuantity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> itemReadContext<span class="token punctuation">.</span><span class="token function">getIncludeRewriteStockQuantity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> consumerAppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
            taskMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ITEM_TASK<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
            microReadThreadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">FutureTask</span><span class="token punctuation">&gt;</span></span> taskEntry <span class="token operator">:</span> taskMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token class-name">String</span> key <span class="token operator">=</span> taskEntry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">FutureTask</span> value <span class="token operator">=</span> taskEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">Response</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> itemResp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Response</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>batchFindFullDetailTaskTimeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>通过 CompletableFuture 创建线程 Demo</strong></p> 
<pre><code class="prism language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Response</span><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> itemFuture <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Response</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> mapResponse <span class="token operator">=</span> <span class="token function">itemMap</span><span class="token punctuation">(</span>itemIds<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> mapResponse<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> microReadThreadPool<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Response</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> itemResp <span class="token operator">=</span> itemFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h3><a id="2_ExecutorThreadPoolExecute_334"></a>2、线程池 Executor/ThreadPoolExecute</h3> 
<p>基于线程池</p> 
<ul><li>线程是非常宝贵的计算资源，在每次需要时创建并在运行结束后销毁是非常浪费资源的。我们可以使用缓存策略并使用线程池来创建线程，具体过程为创建一个线程池并用该线程池提交线程任务，实现代码如下：<br> <img src="https://images2.imgbox.com/ec/5a/WNw5irfP_o.png" alt="在这里插入图片描述"></li></ul> 
<p>提供了一个线程队列，队列中保存着所有等待状态的线程，避免了创建和销毁的额外开销，提高了程序响应的速度<br> 下一篇文章：java中的线程池会详细讲到</p> 
<blockquote> 
 <p>callble和runnable的区别<br> 创建线程的4种方式</p> 
</blockquote> 
<h3><a id="3___blockingqueue_345"></a>3、阻塞队列 blockingqueue</h3> 
<p>当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空<br> <strong>具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查</strong></p> 
<table><thead><tr><th>组别</th><th>插入</th><th>移除</th><th>检查</th><th>处理</th></tr></thead><tbody><tr><td>第一组</td><td>插入 add（e）</td><td>移除 remove（）</td><td>检查 element（）</td><td>处理方式：抛出异常</td></tr><tr><td>第二组</td><td>插入 offer（e）</td><td>移除 poll（）</td><td>检查 peek（）</td><td>处理方式：返回特殊值</td></tr><tr><td>第三组</td><td>插入 put（e）</td><td>移除take（）</td><td>检查 不可用</td><td>处理方式： 一直阻塞</td></tr><tr><td>第四组</td><td>插入 offer(e,time,unit)</td><td>移除 poll（time，unit）</td><td>检查 不可用</td><td>处理方式：超时退出</td></tr><tr><td>对四组不同的行为方式解释：</td><td></td><td></td><td></td><td></td></tr><tr><td>抛出异常</td><td>如果试图的操作无法立即执行，抛一个异常</td><td></td><td></td><td></td></tr><tr><td>–</td><td>–</td><td></td><td></td><td></td></tr><tr><td>特定值</td><td>如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</td><td></td><td></td><td></td></tr><tr><td>阻塞</td><td>如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</td><td></td><td></td><td></td></tr><tr><td>超时</td><td>如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是true / false)</td><td></td><td></td><td></td></tr><tr><td>注意：无法向一个BlockingQueue中插入 null。如果你试图插入null，BlockingQueue将会抛出一个NullPointerException</td><td></td><td></td><td></td><td></td></tr></tbody></table> 
<h5><a id="316_361"></a>3.1、实现类：（共6种）</h5> 
<p><strong>1、ArrayBlockingQueue 有界的阻塞队列</strong> 其内部实现是将对象放到一个数组里<br> 细节：</p> 
<table><thead><tr><th>1</th><th align="left">内部有个数组 items 用来存放队列元素；</th></tr></thead><tbody><tr><td>2</td><td align="left">putindex 下标标示入队元素下标</td></tr><tr><td>3</td><td align="left">takeIndex是出队下标，count统计队列元素个数</td></tr><tr><td>4</td><td align="left">独占锁lock用来对出入队操作加锁</td></tr><tr><td>5</td><td align="left">notEmpty，notFull条件变量用来进行出入队的同步</td></tr></tbody></table> 
<p>方法：</p> 
<table><thead><tr><th>1</th><th>offer方法</th><th>在队尾插入元素，如果队列满则返回false，否者入队返回true</th></tr></thead><tbody><tr><td>2</td><td>Put操作</td><td>在队列尾部添加元素，如果队列满则等待队列有空位置插入后返回</td></tr><tr><td>3</td><td>Poll操作</td><td>从队头获取并移除元素，队列为空，则返回null</td></tr><tr><td>4</td><td>Take操作</td><td>从队头获取元素，如果队列为空则阻塞直到队列有元素。 （当前线程会被挂起放到 notEmpty 的条件队列里面，直到入队操作执行调用notEmpty.signal后当前线程才会被激活，）</td></tr><tr><td>5</td><td>Peek操作</td><td>返回队列头元素但不移除该元素，队列为空，返回null</td></tr><tr><td>6</td><td>Size操作</td><td>获取队列元素个数，非常精确因为计算size时候加了独占锁，其他线程不能入队或者出队或者删除元素</td></tr><tr><td>总结 锁的粒度比较大 类似在方法上添加synchronized</td><td></td><td></td></tr></tbody></table> 
<p><strong>2、DelayQueue 延迟无界阻塞队列</strong><br> 只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的Delayed 元素<br> 运用：缓存系统的设计，缓存中的对象，超过了空闲时间，需要从缓存中移出<br> 1、take()和offer()都是lock了重入锁，按照synchronized的公平锁，两个方法是互斥<br> 2、take()方法需要等待1个小时才能返回，offer()需要马上提交一个10秒后运行的任务，此时offer()可以插队获取锁<br> 3、原理：A执行时，B lock()锁，并休眠；当锁被A释放处于可用状态时，B线程却还处于被唤醒的过程中，此时C线程请求锁，可以优先C得到锁</p> 
<p><strong>3、LinkedBlockingQueue 有界/无界链表阻塞队列（线程池默认使用）</strong><br> 内部以一个链式结构(链接节点)对其元素进行存储,这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限<br> 细节：</p> 
<table><thead><tr><th>1</th><th align="left">两个 Node 分别用来存放首尾节点</th></tr></thead><tbody><tr><td>2</td><td align="left">初始值为 0 的原子变量 count用来记录队列元素个数</td></tr><tr><td>3</td><td align="left">两个ReentrantLock的独占锁，分别用来控制元素入队和出队加锁（takeLock取元素，putLock添加元素）</td></tr><tr><td>4</td><td align="left">notEmpty和notFull用来实现入队和出队的同步</td></tr><tr><td>5</td><td align="left">可以同时又一个线程入队和一个线程出队</td></tr><tr><td>方法：</td><td align="left"></td></tr><tr><td>1</td><td align="left">带时间的Offer操作-生产者</td></tr><tr><td>–</td><td align="left">:–</td></tr><tr><td>2</td><td align="left">带时间的poll操作-消费者 （获取并移除队首元素，在指定的时间内去轮询队列看有没有首元素有则返回，否者超时后返回null）</td></tr><tr><td>3</td><td align="left">put操作-生产者 （与带超时时间的poll类似不同在于put时候如果当前队列满了它会一直等待其他线程调用notFull.signal才会被唤醒）</td></tr><tr><td>4</td><td align="left">take操作-消费者 （与带超时时间的poll类似不同在于take时候如果当前队列空了它会一直等待其他线程调用notEmpty.signal()才会被唤醒）</td></tr><tr><td>5</td><td align="left">size操作-消费者 （当前队列元素个数，如代码直接使用原子变量count获取）</td></tr><tr><td>6</td><td align="left">peek操作 （获取但是不移除当前队列的头元素，没有则返回null。 ）</td></tr><tr><td>7</td><td align="left">remove操作 删除队列里面的一个元素，有则删除返回true，没有则返回false</td></tr></tbody></table> 
<p><strong>4、PriorityBlockingQueue 无界的并发队列</strong><br> 可以实现comparable接口中的方法来排序队列中的元素 //是二叉树最小堆的实现<br> <strong>5、synchronizedQueue 不存储元素的BlockingQueue</strong><br> 每一个put操作必须要等待一个take操作，否则不能继续添加元素；适合做交换工作</p> 
<p><strong>面试题2：</strong><br> 在多线程操作下，一个数组中最多只能存入 3 个元素。多放入不可以存入数组，或等待某线程对数组中某个元素取走才能放入，要求使用java的多线程来实现。</p> 
<blockquote> 
 <p>使用阻塞队列中的ArrayBlockingQueue队列来实现。<br> 存数据使用put（e）方法，取数据使用take（）方法。处理方式： 一直阻塞</p> 
</blockquote> 
<p>面试题3：<br> 如果提交任务时，线程池队列已满，这时会发生什么？</p> 
<blockquote> 
 <p>1、如果使用的是LinkedBlockingQueue，也就是无界队列，可以继续添加任务到阻塞队列中等待执行，可以无限存放任务；<br> 2、如果使用的是有界队列，如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，满了后，会使用拒绝策略rejectedExecutionHandler处理满了的任务，<br> <strong>Abort（直接抛出rejectedExecutionException）、 默认</strong><br> <strong>Discard（按照LIFO丢弃）、</strong><br> <strong>DiscardOldest（按照LRU丢弃）、<br> CallsRun（主线程执行）</strong></p> 
</blockquote> 
<h3><a id="4locks_____426"></a>4、locks 同步锁(多线程的锁机制) ****</h3> 
<p>多线程安全的解决方案 同步代码块，同步方法，同步锁lock（是一个显示锁，必须通过unlock方法进行释放锁，放在finally操作中）</p> 
<p><strong>Synchronized关键字</strong><br> synchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</p> 
<ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li></ol> 
<ul><li>虽然可以使用 synchronized 来定义方法，<strong>但 synchronized 并不属于方法定义的一部分</strong>，因此， synchronized 关键字不能被继承。如果在父类中的某个方法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上 synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</li></ul> 
<ol start="3"><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li><li>修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主的对象是这个类的所有对象。</li></ol> 
<p>Demo1 售票系统</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Ticket</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//票数</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
	<span class="token comment">//操作方法： 卖票</span>
	<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//判断：是否有票</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>number <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" : "</span><span class="token operator">+</span><span class="token punctuation">(</span>number<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：<br> ①获取锁的线程执行完了该代码块，然后线程释放对锁的占有；<br> ②线程执行发生异常，此时 JVM 会让线程自动释放锁。</p> 
<p>那么如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过 Lock 就可以办到。</p> 
<p><strong>2.2 什么是 Lock</strong></p> 
<ul><li>Lock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。 Lock 提供了比 synchronized 更多的功能。</li></ul> 
<p><strong>Lock 与的 Synchronized 区别</strong></p> 
<ul><li>Lock 不是 Java 语言内置的， synchronized 是 Java 语言的关键字，因此是内置特性。 Lock 是一个类，通过这个类可以实现同步访问；</li><li>Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象</li></ul> 
<p>Lock 接口定义如 Demo 所示</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>ReentrantLock 可重入锁</p> 
<ul><li>举例来说明锁的可重入性Demo</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnReentrant</span><span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//do something</span>
		lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>outer 中调用了 inner， outer 先锁住了 lock， 这样 inner 就不能再获取 lock。 其实调用outer 的线程已经获取了 lock 锁， 但是不能在 inner 中重复利用已经获取的锁资源， 这种锁即称之为不可重入。<br> <strong>可重入就意味着： 线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。</p> 
<ul><li>synchronized、 ReentrantLock 都是可重入的锁， 可重入锁相对来说简化了并发编程的开<br> 发。</li></ul> 
<p><strong>重点：消费者/生产者问题</strong><br> 解决方案：为了避免虚假唤醒问题，应该把代码放在循环中。<br> 可以使用synchronized和wait，notifyall机制，也可以使用lock锁加上condition（控制线程通信）机制。<br> <strong>condition接口：</strong><br> <mark>描述了可能会与锁有关的条件变量</mark>，这些变量在用法上与使用Object描述了可能会与锁有关的条件变量，这些变量在用法上与使用Object.wait访问的隐式监视器类似，但提供了更强大的功能。await，signal，signalall</p> 
<hr> 
<h3><a id="5CopyOnWriteArrayList_516"></a>5、CopyOnWriteArrayList</h3> 
<p>写入并复制，不适合添加操作多的场景，每次添加都会进行复制，开销大。适合并发迭代操作多的场景<br> 特点：<br> 1、线程安全版本的ArrayList，每次增加的时候，需要新创建一个比原来容量+1大小的数组<br> 2、拷贝原来的元素到新的数组中，同时将新插入的元素放在最末端<br> 3、然后切换引用<br> 4、迭代时生成快照数组；适合读多写少</p> 
<h3><a id="6copyonwriteArrayset_527"></a>6、copyonwriteArrayset</h3> 
<blockquote> 
 <ol><li>基于CopyOnWriteArrayList实现</li><li>不能插入重复数据，每次add的时候都要遍历数据，性能略低于CopyOnWriteArrayList</li></ol> 
</blockquote> 
<p>CopyOnWrite特点</p> 
<blockquote> 
 <ol><li>添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器</li><li>如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据</li></ol> 
</blockquote> 
<table><thead><tr><th>优点</th><th>1、对CopyOnWrite容器进行并发的读，而不需要加锁，是一种读写分离的思想 2、适合读多写少的并发场景。比如白名单，黑名单</th></tr></thead><tbody><tr><td>缺点</td><td>1、内存占用问题 写操作的时候，内存里会同时驻扎两个对象的内存 2、数据一致性问题 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性</td></tr></tbody></table> 
<p><strong>CopyOnWrite使用Demo：</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Response</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">generateXxx</span><span class="token punctuation">(</span><span class="token class-name">XxxDTO</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> details<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> updates <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newCopyOnWriteArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>details<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>detail <span class="token operator">-&gt;</span> updates<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">toXxx</span><span class="token punctuation">(</span>detail<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">saveSnapshots</span><span class="token punctuation">(</span>updates<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GoodsSnapshot</span><span class="token punctuation">[</span>updates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="7Atomic__552"></a>7、Atomic类 （多线程的原子性操作提供的工具类）</h3> 
<p>背景：我们知道，在多线程程序中，诸如++i或i++等运算不具有原子性，因此不是安全的线程操作。可以通过synchronized或ReentrantLock将该操作变成一个原子操作，但是synchronized和ReentrantLock均属于重量级锁。因此JVM为此类原子操作提供了一些原子操作同步类，使得同步操作（线程安全操作）更加方便、高效，它便是AtomicInteger。</p> 
<p>AtomicInteger为提供原子操作的Integer的类，常见的原子操作类还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference等，它们的实现原理相同，区别在于运算对象的类型不同。还可以通过AtomicReference将一个对象的所有操作都转化成原子操作。AtomicInteger的性能通常是synchronized和ReentrantLock的好几倍。</p> 
<p>Atomic 是指一个操作是不可中断的。并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic下,如下图所示<br> <img src="https://images2.imgbox.com/8f/3f/B1Kr6zba_o.png" alt="在这里插入图片描述"></p> 
<p><strong>基本类型</strong></p> 
<p>使用原子的方式更新基本类型</p> 
<ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul> 
<p>如AtomicInteger，AtomicBoolean i++变成原子操作，底层是cas。</p> 
<p>数组类型<br> 使用原子的方式更新数组里的某个元素</p> 
<ul><li>AtomicIntegerArray：整型数组原子类</li><li>AtomicLongArray：长整型数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul> 
<p>引用类型</p> 
<ul><li>AtomicReference：引用类型原子类</li><li>AtomicMarkableReference：原子更新带有标记的引用类型。<mark>该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题</mark>。 
  <ul><li>issue#626：不能解决 ABA 问题</li></ul> </li><li>AtomicStampedReference ：原子更新带有版本号的引用类型。<strong>该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题</strong></li></ul> 
<p><strong>AtomicReference 类使用示例</strong>：首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicReferenceTest</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> ar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"SnailClimb"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Person</span> updatePerson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Daisy"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ar<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> updatePerson<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Daisy</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 20</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用场景：需要原子性</p> 
<p><strong>对象的属性修改类型</strong></p> 
<ul><li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ul> 
<hr> 
<h3><a id="8volatile___605"></a>8、volatile关键字 详解可以看多线程部分</h3> 
<blockquote> 
 <p>作用：保证内存的可见性，线程每次都从主存中读取数据。<br> 缺点：不具备“互斥性”：多个线程能同时读写主存，不能保证变量的“原子性”：<br> （i++不能作为一个整体，分为3个步骤读-改-写），可以使用cas算法保证数据可原子性。</p> 
</blockquote> 
<hr> 
<h3><a id="9cas_612"></a>9、cas乐观锁：（非阻塞算法）</h3> 
<p><strong>是一种硬件对并发的支持，用于管理对共享数据的访问。相当于是无锁的非阻塞实现。</strong><br> 包含三个操作数，内存值V，预估值A，更新值B，当且仅当V==A，V=B；否则，不做任何操作。</p> 
<p>悲观锁：</p> 
<ul><li>假定并发环境是悲观的，如果发生并发冲突，就会破坏一致性，所以要通过独占锁彻底禁止冲突发生</li></ul> 
<p>乐观锁：（锁的粒度小）</p> 
<ul><li>假定并发环境是乐观的，即，虽然会有并发冲突，但冲突可发现且不会造成损害，所以，可以不加任何保护，等发现并发冲突后再决定放弃操作还是重试。</li></ul> 
<p><strong>CAS算法 ：</strong><br> 乐观锁的实现往往需要硬件的支持，多数处理器都都实现了一个CAS指令，实现“Compare And Swap”的语义</p> 
<blockquote> 
 <p><strong>CAS包含3个操作数：</strong><br> 1 需要读写的内存位置V<br> 2 进行比较的值A<br> 3 拟写入的新值B<br> 当且仅当位置 V 的值等于 A 时，CAS 才会通过原子方式用新值 B 来更新位置 V 的值；否则不会执行任何操作</p> 
</blockquote> 
<p><strong>CAS乐观锁的缺点</strong><br> <mark>ABA问题</mark>：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化</p> 
<p>代码示例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicIntegerDefectDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">defectOfABA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ABA缺陷</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">defectOfABA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> coreThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>
                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">final</span> <span class="token keyword">int</span> currentValue <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ------ currentValue="</span> <span class="token operator">+</span> currentValue<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment">// 这段目的：模拟处理其他业务花费的时间</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>

                    <span class="token keyword">boolean</span> casResult <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            <span class="token operator">+</span> <span class="token string">" ------ currentValue="</span> <span class="token operator">+</span> currentValue
                            <span class="token operator">+</span> <span class="token string">", finalValue="</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            <span class="token operator">+</span> <span class="token string">", compareAndSet Result="</span> <span class="token operator">+</span> casResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        coreThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 这段目的：为了让 coreThread 线程先跑起来</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Thread</span> amateurThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>
                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">int</span> currentValue <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">boolean</span> casResult <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            <span class="token operator">+</span> <span class="token string">" ------ currentValue="</span> <span class="token operator">+</span> currentValue
                            <span class="token operator">+</span> <span class="token string">", finalValue="</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            <span class="token operator">+</span> <span class="token string">", compareAndSet Result="</span> <span class="token operator">+</span> casResult<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    currentValue <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    casResult <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            <span class="token operator">+</span> <span class="token string">" ------ currentValue="</span> <span class="token operator">+</span> currentValue
                            <span class="token operator">+</span> <span class="token string">", finalValue="</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            <span class="token operator">+</span> <span class="token string">", compareAndSet Result="</span> <span class="token operator">+</span> casResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        amateurThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>Thread-0 ------ currentValue=1<br> Thread-1 ------ currentValue=1, finalValue=2, compareAndSet Result=true<br> Thread-1 ------ currentValue=2, finalValue=1, compareAndSet Result=true<br> Thread-0 ------ currentValue=1, finalValue=2, <mark>compareAndSet Result=true</mark></p> 
</blockquote> 
<p>如何解决ABA问题：用另一个标识判断某值是否有改变过。</p> 
<blockquote> 
 <p>乐观锁的业务场景及实现方式 20181222 以后再补</p> 
</blockquote> 
<h2><a id="java_10111213_706"></a>java中的并发工具类 10/11/12/13</h2> 
<h3><a id="10countdownlatch_join_707"></a>10、闭锁countdownlatch （等待多线程完成）实现了join的功能</h3> 
<h5><a id="101_708"></a>10.1、概念：</h5> 
<p>在完成某些运算时，只有其他所有线程的运算全部完成，当前运算才继续执行，<br> 可以用于统计多线程执行的时间。<br> 可被多个线程并发的实现减1操作，并在计数器为0后调用await方法的线程被唤醒，从而实现多线程间的协作</p> 
<h5><a id="102_713"></a>10.2、可以实现的需求</h5> 
<blockquote> 
 <p>现需要解析一个excel里的多个sheet数据，使用多线程，每个线程解析其中一个sheet的数据，等到所有sheet解析完，程序提示解析完成构造函数传入int型参数做改为计数器，countDown被调用，计数器减1，await会一直阻塞程序，直至计数为0.<br> 如果某个sheet解析较慢，可以使用带时间参数的await方法，到时间后，不再阻塞当前线程</p> 
</blockquote> 
<h5><a id="103CountDownLatch_719"></a>10.3、分析CountDownLatch的实现原理</h5> 
<p>1、在AQS队列中，将线程包装为Node.SHARED节点，即标志位共享锁<br> 2、当头节点获得共享锁后，唤醒下一个共享类型结点的操作</p> 
<blockquote> 
 <ul><li>1、头节点node1,调用unparkSuccessor()方法唤醒了Node2，并且调用tryAcquireShared方法，检查下一个节点是共享节点</li><li>2、如果是，更改头结点，重复以上步骤，以实现节点自身获取共享锁成功后，唤醒下一个共享类型结点的操作</li></ul> 
</blockquote> 
<h5><a id="105AQS_724"></a>10.5、什么是AQS？******</h5> 
<p>1、提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架<br> 使用方式是继承：</p> 
<blockquote> 
 <p>子类通过继承同步器并需要实现它的方法来管理其状态，管理方式是通过acquire和release方式操纵状态<br> 在多线程环境中对状态的操作必须保证原子性，需要使用这个同步器提供的以下三个方法对状态进行操作<br> 1、AbstractQueuedSynchronizer.getState()<br> 2、AbstractQueuedSynchronizer.setState(int)<br> 3、AbstractQueuedSynchronizer.compareAndSetState(int, int)</p> 
</blockquote> 
<p><strong>同步器是实现锁的关键</strong><br> 同步器面向的是线程访问和资源控制，他定义了线程对资源是否能够获取以及线程的排队等操作。<br> 依赖于FIFO队列，队列中的node就是保存着线程引用和线程状态的容器。<br> <em>对于一个排它锁的获取和释放</em></p> 
<blockquote> 
 <p>//获取：<br> while(获取锁){<!-- --><br> if(获取到)<br> 退出while循环<br> else{<!-- --><br> if(当前线程没有入队)<br> 入队<br> 阻塞当前线程<br> }<br> }<br> //释放：<br> if(释放成功){<!-- --><br> 删除头结点<br> 激活原头结点的后继结点<br> };</p> 
</blockquote> 
<h5><a id="106AQSLOCK_755"></a>10.6、AQS与锁（如LOCK）的对比</h5> 
<p>1、锁是面向使用者的，定义了用户调用的接口，隐藏了实现细节；<br> 2、AQS是锁的实现者，屏蔽了同步状态管理，线程的排队，等待唤醒的底层操作；<br> 3、锁是面向使用者，AQS是锁的具体实现者</p> 
<h5><a id="107CountDownLatch_760"></a>10.7、CountDownLatch中的方法？</h5> 
<p>1、countDownLatch.await()发生什么？</p> 
<blockquote> 
 <p>直接调用了AQS的acquireSharedInterruptibly<br> 当前线程就会进入了一个死循环当中，在这个死循环里面，会不断的进行判断，通过调用tryAcquireShared方法，如果值为0(说明共享锁没有了),会跳出循环</p> 
</blockquote> 
<p>2、释放操作 //countDown操作实际就是释放锁的操作,每调用一次,计数值减少1<br> 3、限定时间的await方法 await(long timeout, TimeUnit unit)<br> <em>spinForTimeoutThreshold写死了1000ns，这就是所谓的自旋操作，让线程在循环中自旋，否则阻塞线程</em></p> 
<blockquote> 
 <p>代码：参考并发编程的艺术第8章 8.1/8.2</p> 
</blockquote> 
<h3><a id="11cyclicBarrier_770"></a>11、cyclicBarrier（同步屏障）</h3> 
<h5><a id="111cyclicBarrier_771"></a>11.1、cyclicBarrier是什么？</h5> 
<p>让一组线程到达一个屏障（也称同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续工作</p> 
<ul><li>线程进入屏障通过cyclicBarrier的await()方法</li></ul> 
<h5><a id="112cyclicBarrier_776"></a>11.2、cyclicBarrier底层原理？</h5> 
<p>由ReentrantLock可重入锁和Condition共同实现的</p> 
<blockquote> 
 <p>注意：<br> 1、前面四个线程等待最后一个线程超时了，这个时候这四个线程不会再等待最后一个线程写入完毕，而是直接抛出BrokenBarrierException异常，继续执行后续的动作。最后一个线程完成写入数据操作后也继续了后续的动作<br> 2、构造函数的参数表示屏障拦截的线程数量，还有一个高级的构造函数CyclicBarrier(int parties,Runnable barrierAction):在线程达到屏障后，优先执行barrierAction</p> 
</blockquote> 
<h5><a id="113cyclicBarrier_782"></a>11.3、cyclicBarrier的应用场景</h5> 
<p>用于多线程计算数据，最后合并计算结果的场景</p> 
<blockquote> 
 <p>例如：excel保存了用户所有的银行流水，每一个sheet保存一个账户近一年的每笔流水，现需要统计用户的日均银行流水，先用多线程处理每个sheet的银行流水，再用barrierAction计算最后结果，计算整个日均流水</p> 
</blockquote> 
<h5><a id="114cyclicBarriercountDownLatch_786"></a>11.4、cyclicBarrier和countDownLatch的区别</h5> 
<p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同</p> 
<ul><li>1、CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行</li><li>2、CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的</li></ul> 
<p>代码：参考并发编程8.2 P191</p> 
<h3><a id="12Semaphore_794"></a>12、Semaphore详解（控制并发线程数）</h3> 
<p>Semaphore可以控同时访问的线程个数，通过acquire()获取一个许可，如果没有就等待，而release()可以释放一个许可<br> Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限 //操作系统中讲过</p> 
<blockquote> 
 <p>应用场景：<br> semaphore可以用作流量控制，特别是公用资源有限的应用场景，如数据库连接。现在要读取几万个文件的数据，IO密集型任务，可以启动几十个线程去并发读取，读到内存后，还需要保存到数据库中，而数据库的连接数只有10个，这时必须并发控制10个线程同时获取数据库连接，来保存数据，否则报错无法获取数据库连接</p> 
</blockquote> 
<p>方法：</p> 
<ul><li>1、semaphore(int permits) //许可证数量</li><li>2、acquire()/tryAcquire() //获取许可证</li><li>3、release() //归还许可证</li><li>4、intavailablePermits() //返回此信号量中当前可用的许可证数</li><li>5、intgetQueueLength() //返回正在等待获取许可证的线程数</li></ul> 
<p>代码：参考并发编程P196</p> 
<h3><a id="13Exchanger_809"></a>13、Exchanger详解（线程间交换数据）</h3> 
<p>提供了在线程间交换数据的一种手段，它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，他会一直等待第二个线程也执行此方法，当两个线程都到达同步点时，这两个线程就交换数据。</p> 
<blockquote> 
 <p>应用场景：<br> 1、用于遗传算法：选两个人作为交配对象，需要交换两人的数据，并使用交叉规则得出2个交配结果<br> 2、用于校对工作：我们需要将纸质银行流水通过人功能的方式录入成电子银行流水，为避免错误，采用AB岗录入，对两个excel数据进行校对，看是否录入一致</p> 
</blockquote> 
<pre><code>		可以使用exchange(V x,long timeout,TimeUnit unit)  //设置最大等待时长
</code></pre> 
<p>代码：参考并发编程P198</p> 
<h3><a id="14_817"></a>14、公平锁和非公平锁</h3> 
<p><strong>公平锁：</strong><br> 就是在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等待队列的第一个，就占有锁<br> 否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己<br> <strong>非公平锁：</strong><br> 比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式</p> 
<h3><a id="15_826"></a>15、并发队列-非阻塞队列</h3> 
<p>非阻塞队列使用的是CAS(compare and swap)来实现线程执行的非阻塞</p> 
<p>入队：</p> 
<ul><li>1、add()：底层调用offer();</li><li>2、offer()：Queue接口继承下来的方法，实现队列的入队操作，不会阻碍线程的执行，插入成功返回true</li></ul> 
<p>出队：</p> 
<ul><li>1、poll()：移动头结点指针，返回头结点元素，并将头结点元素出队；队列为空，则返回null</li><li>2、peek()：移动头结点指针，返回头结点元素，并不会将头结点元素出队；队列为空，则返回null</li></ul> 
<h3><a id="Action1_839"></a>Action1：获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h3> 
<ul><li>说明：资源驱动类、工具类、单例工厂类都需要注意。</li></ul> 
<h3><a id="Action2_842"></a>Action2：创建线程或线程池时请指定有意义的线程名称，方便出错时排查</h3> 
<p>正例： 自定义线程工厂， 并且根据外部特征进行分组， 比如， 来自同一机房的调用， 把机房编号赋值给whatFeatureOfGroup：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> namePrefix<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> nextId <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 定义线程组名称， 在利用 jstack 来排查问题时， 非常有帮助</span>
	<span class="token class-name">UserThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">String</span> whatFeatureOfGroup<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		namePrefix <span class="token operator">=</span> <span class="token string">"FromUserThreadFactory's"</span> <span class="token operator">+</span> whatFeatureOfGroup <span class="token operator">+</span> <span class="token string">"-Worker-"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">String</span> name <span class="token operator">=</span> namePrefix <span class="token operator">+</span> nextId<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> task<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> thread<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Action3_863"></a>Action3、线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</h3> 
<ul><li>说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</li></ul> 
<h3><a id="Action4ExecutorsThreadPoolExecutor__866"></a>Action4、线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险。</h3> 
<ul><li>说明：Executors 返回的线程池对象的弊端如下：</li><li>1、<code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>： 
  <ul><li>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM；</li></ul> </li><li>2、<code>CachedThreadPool</code> ： 
  <ul><li>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM；</li></ul> </li><li>3、<code>ScheduledThreadPool</code>： 
  <ul><li>允许的请求队列长度为 Integer.MAX_VALUE， 可能会堆积大量的请求， 从而导致 OOM</li></ul> </li></ul> 
<h3><a id="Action5SimpleDateFormat__static__static_DateUtils_875"></a>Action5、<code>SimpleDateFormat</code> 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils工具类。</h3> 
<ul><li> <p>正例：注意线程安全，使用DateUtils。或者如下处理</p> <pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormat</span><span class="token punctuation">&gt;</span></span> df <span class="token operator">=</span> <span class="token keyword">new</span>  <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormat</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">protected</span> <span class="token class-name">DateFormat</span> initialValue <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>说明：如果是JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe.</p> <pre><code class="prism language-java"><span class="token class-name">String</span> createAt <span class="token operator">=</span> <span class="token class-name">DateUtils</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>logRecordPushMq<span class="token punctuation">.</span><span class="token function">getCreatedAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">DateUtils</span><span class="token punctuation">.</span>FORMAT_YMD<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">Date</span> dateDate<span class="token punctuation">,</span> <span class="token class-name">String</span> format<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SimpleDateFormat</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> dateString <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>dateDate<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dateString<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h3><a id="Action6_897"></a>Action6、高并发时，同步调用应该去考量锁的性能损耗，能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</h3> 
<ul><li>说明：尽可能使锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</li></ul> 
<h3><a id="Action7_900"></a>Action7、对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</h3> 
<ul><li>说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。</li></ul> 
<h3><a id="Action8_version_903"></a>Action8、并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version作为更新依据</h3> 
<ul><li>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁，乐观锁的重试次数不得小于3次。</li></ul> 
<h3><a id="Action9TimerTimeTask_ScheduledExecutorService__906"></a>Action9、多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，使用 <code>ScheduledExecutorService</code> 则没有这个问题。</h3> 
<h3><a id="Action10CountDownLatch_countDowncatch_countDown__await__907"></a>Action10、使用CountDownLatch 进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果。</h3> 
<ul><li>说明：注意：子线程抛出异常堆栈，不能在主线程try-catch到。</li></ul> 
<h3><a id="Action11Randomseed__910"></a>Action11、避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致性能下降</h3> 
<ul><li>说明：Random 实例包括java.util.Random 的实例或者 Math.random() 方式</li><li>正例：在JDK7之后，可以直接使用API <code>ThreadLocalRandom</code>，而在JDK7 之前，需要编码保证每个线程持有一个实例。</li></ul> 
<h3><a id="Action12doublechecked_locking_volatile__helper__private_volatile_Helper_helper__null_914"></a>Action12、在并发场景下，通过双重检查锁(double-checked locking) 实现延迟初始化的优化问题隐患，推荐解决方案中较为简单的一种，将目标属性声明为volatile型 （比如修改 helper 的属性声明为 <code>private volatile Helper helper = null;</code>）</h3> 
<p>正例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyInitDemo</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Helper</span> helper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Helper</span> <span class="token function">getHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>helper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>helper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					helper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> helper<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// other methods and fields...</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Action13volatile__933"></a>Action13、volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</h3> 
<p>如果是 count++ 操作，使用如下类实现：</p> 
<pre><code class="prism language-java"><span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
count<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>如果是 JDK8，推荐使用 LongAdder 对象， 比 AtomicLong 性能更好（减少乐观锁的重试次数）。<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LongAdder</span> BATCH_FIND_BRAND_BY_ID_HIT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
BATCH_FIND_BRAND_BY_ID_HIT<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h3><a id="Action14HashMap_resize__CPU__945"></a>Action14、HashMap在容量不够进行 resize 时，由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其他数据结构或加锁来规避此风险</h3> 
<ul><li>JDK1.7 版本会有这个问题吧，JDK1.8已经修复了</li></ul> 
<h3><a id="Action15ThreadLocal_ThreadLocal_static__949"></a>Action15、ThreadLocal 无法解决共享对象的更新问题，ThreadLocal对象建议使用 static 修饰。</h3> 
<ul><li>这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操纵这个变量。</li></ul> 
<h3><a id="Action16_ThreadLocal__ThreadLocal__tryfinally__952"></a>Action16、必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收</h3> 
<p>正例：</p> 
<pre><code class="prism language-java">objectThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
	objectThreadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Action17__try___try____finally__963"></a>Action17、在使用阻塞等待获取锁的方式中， 必须在 try 代码块之外， 并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用， 避免加锁成功后， 在 finally 中无法解锁。</h3> 
<p>说明一： 在 lock 方法与 try 代码块之间的方法调用抛出异常， 无法解锁， 造成其它线程无法成功获取锁。<br> 说明二： 如果 lock 方法在 try 代码块之内， 可能由于其它方法抛出异常， 导致在 finally 代码块中， <strong>unlock 对未加锁的对象解锁， 它会调用 AQS 的 tryRelease 方法（取决于具体实现类） ， 抛出 <code>IllegalMonitorStateException</code> 异常</strong>。<br> 说明三： 在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常， 产生的后果与说明二相同。<br> 正例：</p> 
<pre><code class="prism language-java"><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XxxLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">doOthers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>反例：</p> 
<pre><code class="prism language-java"><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XxxLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 如果此处抛出异常， 则直接执行 finally 代码块</span>
	<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 无论加锁是否成功， finally 代码块都会执行</span>
	lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">doOthers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Action18__994"></a>Action18、资金相关的金融敏感信息， 使用悲观锁策略。</h3> 
<p>说明： 乐观锁在获得锁的同时已经完成了更新操作， 校验逻辑容易出现漏洞， 另外， 乐观锁对冲突的解决策略有较复杂的要求， 处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</p> 
<ul><li>正例： 悲观锁遵循一锁二判三更新四释放的原则。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6778acc0a75e3e1421f01d968d64081f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CocosCreator-3.6 三步解决2D碰撞监听</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b2c55413ba283fdf4517d5bfde103daf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows10神州网信政府版的配置修改</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>