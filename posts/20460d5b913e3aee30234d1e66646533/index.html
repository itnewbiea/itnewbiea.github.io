<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java学习——设计模式——行为型模式1 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java学习——设计模式——行为型模式1" />
<meta property="og:description" content="文章目录 行为型模式模板方法策略模式命令模式责任链模式 行为型模式 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，涉及算法与对象间职责的分配。
行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分配行为，后者采用组合或聚合在对象间分配行为。由于组合或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。
包括：
1、模板方法
2、策略模式
3、命令模式
4、职责链模式
5、状态模式
6、观察者模式
7、中介者模式
8、迭代器模式
9、访问者模式
10、备忘录模式
11、解释器模式
除了模板方法和解释器模式是类行为型模式，其余都是对象行为型模式
模板方法 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
结构
1、抽象类：给出算法轮廓和骨架
模板方法：定义算法骨架，按顺序调用包含的基本方法基本方法：实现算法各个步骤的方法，是模板方法的组成部分。 抽象方法：由抽象类声明、由其具体子类实现具体方法：由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种 2、 具体子类：实现抽象类中所定义的抽象方法和钩子方法，是一个顶级逻辑的组成步骤
优点
提高代码复用性实现反向控制
通过一个父类调用子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则” 缺点
对每个不同实现都需要定义一个子类，导致类的个数增加，系统更加庞大，设计也更加抽象父类中的抽象方法由子类实现，子类的执行结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度 策略模式 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的用户。
属于对象行为模式，通过堆算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象堆这些算法进行管理。
结构
1、抽象策略类
2、具体策略类
3、环境类
优点
1、策略类之间可以自由切换
2、易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码
3、避免使用多重条件选择语句
缺点：
1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类
2、策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量
命令模式 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。
结构
1、抽象命令类
2、具体命令类
3、实现者/接收者
4、调用者/请求者
优点
1、降低系统耦合度，命令模式能将调用操作的对象与实现该操作的对象解耦
2、增加或删除操作非常方便。
3、可以实现宏命令。
4、方便实现undo和redo操作。
缺点：
1、可能会导致某些系统有过多的具体命令类
2、系统结构更加复杂
责任链模式 又叫职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
结构
1、抽象处理者
2、具体处理者
3、客户类
优点：
缺点：
开始摆烂，学到这里好混乱，感觉学每一种好像懂了，但跟其他的区别又说不上来，又感觉每种模式差不多。。。。。。唉。。。。。。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/20460d5b913e3aee30234d1e66646533/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T16:34:28+08:00" />
<meta property="article:modified_time" content="2024-01-05T16:34:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java学习——设计模式——行为型模式1</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">行为型模式</a></li><li><ul><li><a href="#_23" rel="nofollow">模板方法</a></li><li><a href="#_47" rel="nofollow">策略模式</a></li><li><a href="#_68" rel="nofollow">命令模式</a></li><li><a href="#_88" rel="nofollow">责任链模式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>行为型模式</h2> 
<blockquote> 
 <p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，涉及算法与对象间职责的分配。</p> 
 <hr> 
 <p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分配行为，后者采用组合或聚合在对象间分配行为。由于组合或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p> 
</blockquote> 
<p>包括：<br> 1、模板方法<br> 2、策略模式<br> 3、命令模式<br> 4、职责链模式<br> 5、状态模式<br> 6、观察者模式<br> 7、中介者模式<br> 8、迭代器模式<br> 9、访问者模式<br> 10、备忘录模式<br> 11、解释器模式</p> 
<p>除了模板方法和解释器模式是类行为型模式，其余都是对象行为型模式</p> 
<h3><a id="_23"></a>模板方法</h3> 
<blockquote> 
 <p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p> 
</blockquote> 
<p><strong>结构</strong><br> 1、抽象类：给出算法轮廓和骨架</p> 
<ul><li>模板方法：定义算法骨架，按顺序调用包含的基本方法</li><li>基本方法：实现算法各个步骤的方法，是模板方法的组成部分。 
  <ul><li>抽象方法：由抽象类声明、由其具体子类实现</li><li>具体方法：由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承</li><li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种</li></ul> </li></ul> 
<p>2、 具体子类：实现抽象类中所定义的抽象方法和钩子方法，是一个顶级逻辑的组成步骤<br> <img src="https://images2.imgbox.com/cc/c3/zlAnBpEB_o.png" alt="在这里插入图片描述"><br> <strong>优点</strong></p> 
<blockquote> 
 <ul><li>提高代码复用性</li><li>实现反向控制<br> 通过一个父类调用子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则”</li></ul> 
</blockquote> 
<p><strong>缺点</strong></p> 
<blockquote> 
 <ul><li>对每个不同实现都需要定义一个子类，导致类的个数增加，系统更加庞大，设计也更加抽象</li><li>父类中的抽象方法由子类实现，子类的执行结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度</li></ul> 
</blockquote> 
<h3><a id="_47"></a>策略模式</h3> 
<blockquote> 
 <p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的用户。<br> 属于对象行为模式，通过堆算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象堆这些算法进行管理。</p> 
</blockquote> 
<p><strong>结构</strong><br> 1、抽象策略类<br> 2、具体策略类<br> 3、环境类</p> 
<p><img src="https://images2.imgbox.com/d8/23/PVYs6wyr_o.png" alt="在这里插入图片描述"><br> <strong>优点</strong><br> 1、策略类之间可以自由切换<br> 2、易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码<br> 3、避免使用多重条件选择语句</p> 
<p>缺点：<br> 1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类<br> 2、策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量</p> 
<h3><a id="_68"></a>命令模式</h3> 
<blockquote> 
 <p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p> 
</blockquote> 
<p><strong>结构</strong><br> 1、抽象命令类<br> 2、具体命令类<br> 3、实现者/接收者<br> 4、调用者/请求者</p> 
<p><img src="https://images2.imgbox.com/bd/7e/OcmY24Kh_o.png" alt="在这里插入图片描述"><br> <strong>优点</strong><br> 1、降低系统耦合度，命令模式能将调用操作的对象与实现该操作的对象解耦<br> 2、增加或删除操作非常方便。<br> 3、可以实现宏命令。<br> 4、方便实现undo和redo操作。</p> 
<p>缺点：<br> 1、可能会导致某些系统有过多的具体命令类<br> 2、系统结构更加复杂</p> 
<h3><a id="_88"></a>责任链模式</h3> 
<blockquote> 
 <p>又叫职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p> 
</blockquote> 
<p><strong>结构</strong><br> 1、抽象处理者<br> 2、具体处理者<br> 3、客户类</p> 
<p><img src="https://images2.imgbox.com/fc/19/DBOnpElQ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>优点</strong>：<br> <img src="https://images2.imgbox.com/6f/ec/nTuWFegp_o.png" alt="在这里插入图片描述"></p> 
<p>缺点：</p> 
<p><img src="https://images2.imgbox.com/44/fe/2aSe0qTu_o.png" alt="在这里插入图片描述"></p> 
<p>开始摆烂，学到这里好混乱，感觉学每一种好像懂了，但跟其他的区别又说不上来，又感觉每种模式差不多。。。。。。唉。。。。。。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39936b7e7969af6782b8d3c87ef6ad6c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第一章 引言-HTTP协议基础概念和前后端分离架构请求交互概述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b2dffe47b3621323c27597e62a27569e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IMU预计分公式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>