<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JS闭包问题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JS闭包问题" />
<meta property="og:description" content="JS闭包 基本知识作用域函数作用域和全局作用域块级作用域和暂时性死区 执行上下文和调用栈代码执行的两个阶段调用栈 闭包内存管理内存管理基本概念内存泄漏场景举例浏览器垃圾回收内存泄漏和垃圾回收注意事项 例题分析实战例题1实战例题2实战例题3实战例题4 总结 基本知识 作用域 作用域可以理解为某种规则下的限定范围，该规则用于指导开发者如何在特定场景下查找变量。
函数作用域和全局作用域 function foo () { var a = &#39;bar&#39; console.log(a); } foo(); 对以上代码改动：
var b = &#39;bar&#39;; function foo(){ console.log(b); } foo(); 执行时，foo函数在自身作用域内未找到b变量，会继续向外扩大查找范围，在全局作用域中找到了变量b。
function bar(){ var b = &#39;bar&#39;; } function foo(){ console.log(b); // b is not defined } foo(); foo和bar分属两个彼此独立的函数作用域，foo无法访问bar中定义的变量b，foo作用域链内(直到上层全局作用域中)也不存在相应的变量，报错。
在Js执行函数时，遇见变量且需要读取其值，就会“就近”先在函数内部查找该变量的声明和赋值。如果在函数内部无法找到，就跳出函数作用域，到更上层作用域中查找。
function bar(){ var b= &#39;bar&#39;; function foo(){ console.log(b); } foo(); } bar(); foo执行时，变量b的声明和赋值是在foo的上层函数bar的作用域中获取的。
var b= &#39;bar&#39;; function bar(){ function foo(){ console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e08fa3c6b7f516094d938098f979d779/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-11T16:04:24+08:00" />
<meta property="article:modified_time" content="2022-04-11T16:04:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JS闭包问题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>JS闭包</h4> 
 <ul><li><a href="#_2" rel="nofollow">基本知识</a></li><li><ul><li><a href="#_3" rel="nofollow">作用域</a></li><li><ul><li><a href="#_7" rel="nofollow">函数作用域和全局作用域</a></li><li><a href="#_71" rel="nofollow">块级作用域和暂时性死区</a></li></ul> 
   </li><li><a href="#_175" rel="nofollow">执行上下文和调用栈</a></li><li><ul><li><a href="#_179" rel="nofollow">代码执行的两个阶段</a></li><li><a href="#_247" rel="nofollow">调用栈</a></li></ul> 
   </li><li><a href="#_271" rel="nofollow">闭包</a></li><li><a href="#_294" rel="nofollow">内存管理</a></li><li><ul><li><a href="#_304" rel="nofollow">内存管理基本概念</a></li><li><a href="#_322" rel="nofollow">内存泄漏场景举例</a></li><li><a href="#_364" rel="nofollow">浏览器垃圾回收</a></li><li><a href="#_366" rel="nofollow">内存泄漏和垃圾回收注意事项</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_441" rel="nofollow">例题分析</a></li><li><ul><li><a href="#1_443" rel="nofollow">实战例题1</a></li><li><a href="#2_480" rel="nofollow">实战例题2</a></li><li><a href="#3_497" rel="nofollow">实战例题3</a></li><li><a href="#4_517" rel="nofollow">实战例题4</a></li></ul> 
  </li><li><a href="#_539" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>基本知识</h2> 
<h3><a id="_3"></a>作用域</h3> 
<p>  作用域可以理解为某种规则下的限定范围，该规则用于指导开发者如何在特定场景下查找变量。</p> 
<h4><a id="_7"></a>函数作用域和全局作用域</h4> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'bar'</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>对以上代码改动：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>执行时，foo函数在自身作用域内未找到b变量，会继续向外扩大查找范围，在全局作用域中找到了变量b。</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b is not defined</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>foo和bar分属两个彼此独立的函数作用域，foo无法访问bar中定义的变量b，foo作用域链内(直到上层全局作用域中)也不存在相应的变量，报错。</p> 
<blockquote> 
 <p>在Js执行函数时，遇见变量且需要读取其值，就会“就近”先在函数内部查找该变量的声明和赋值。如果在函数内部无法找到，就跳出函数作用域，到更上层作用域中查找。</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> b<span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>foo执行时，变量b的声明和赋值是在foo的上层函数bar的作用域中获取的。</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> b<span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>更上层作用域也可以顺着作用域范围向外扩散，直到全局作用域。</p> 
<p>  变量作用域的查找是一个扩散的过程，像是链条：环环相扣、逐次递进。</p> 
<h4><a id="_71"></a>块级作用域和暂时性死区</h4> 
<p>ES6新增<code>let</code>和<code>const</code>声明变量块级作用域。块级作用域是指作用域范围局限在代码块中。</p> 
<p>新特性的出现带来了新的概念：暂时性死区，暂时性死区得从“变量提升”说起。</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>输出<code>undefined</code>,因为变量<code>bar</code>在函数内进行了提升，以上代码可理解为：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> b<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
    b <span class="token operator">=</span> <span class="token string">'bar'</span> 
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在使用<code>let</code>对b进行声明是，会报错：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cannot access 'b' before initialization</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>let</code>和<code>cons</code>声明变量时，会针对这个变量形成一个封闭的块级作用域。在块级作用域内，声明变量之前访问变量，就会报错</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在<code>{}</code>的作用域中存在一个“死区”，函数开头开始，终止与相关变量声明语句的所在行。在这个范围内无妨访问使用<code>let</code>和<code>const</code>声明的变量，这块区域的专业名词是：TDZ(Temporal Dead Zone)。</p> 
<p>在理解上述内容后，来看一下代码：除了自身作用域内的<code>foo3</code>，<code>bar2</code>还可以访问<code>foo2</code>、<code>foo1</code>；但是<code>bar1</code>无妨访问<code>bar2</code>函数内部定义的<code>foo3</code></p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> foo1 <span class="token operator">=</span> <span class="token string">'fool'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> foo2 <span class="token operator">=</span> <span class="token string">'foo2'</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">bar2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">var</span> foo3 <span class="token operator">=</span> <span class="token string">'foo3'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>死区问题理解看一下代码：在<code>bar1</code>中，<code>let b = 'bar'</code>这一行前面的区域是“死区”,在“死区”中访问<code>b</code>会报错。</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>对于上述暂时性死区，极端情况是：函数的参数默认值设置也会收到影响</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg1<span class="token operator">=</span>arg2<span class="token punctuation">,</span>arg2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'bar1'</span><span class="token punctuation">,</span><span class="token string">'bar2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在<code>foo</code>中，如果没有传第一个参数，则会使用第二个参数作为第一个实参；但当第一个参数为默认值时，执行<code>arg1=arg2</code>会被当做暂时性死区处理。</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg1<span class="token operator">=</span>arg2<span class="token punctuation">,</span>arg2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span><span class="token string">'bar2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cannot access 'arg2' before initialization</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token string">'bar2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null bar2</span>
</code></pre> 
<p>报错是因为除了块级作用域，函数参数默认值也会受到暂时性死区的影响。输出<code>null bar2</code>是因为在执行<code>foo(null,'bar2');</code>时，不会认为“函数第一个参数为默认值”，而会直接接受<code>null</code>作为第一个参数的值。</p> 
<p>思考一下代码的输出结果时什么：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> arg1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'bar1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>代码会报错：<code>Identifier 'arg1' has already been declared</code>，这是因为函数参数名出现在其“执行上下文/作用域”中导致的。</p> 
<p>以上的例子是为了引出新的知识点：“执行上下文”，下面一起来看看吧。</p> 
<h3><a id="_175"></a>执行上下文和调用栈</h3> 
<p>  执行上下文就是当前代码的执行环境/作用域，和之前介绍的作用域链有很大的联系，但有完全不同的两个概念。执行上下文包含了作用域链，同时又是递进的：有了作用域链才会执行上下文部分。</p> 
<h4><a id="_179"></a>代码执行的两个阶段</h4> 
<ul><li>代码预编译阶段</li><li>代码执行阶段</li></ul> 
<p>预编译阶段注意的问题：</p> 
<ul><li>在预编译阶段声明变量</li><li>对变量声明提升，值为<code>undefined</code></li><li>对所有非表达式的函数声明进行提升</li></ul> 
<p>注意以上3点，在正确理解和判断代码逻辑时有很大的帮助：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'first'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'second'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// second</span>
</code></pre> 
<pre><code class="prism language-js"><span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'second'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'first'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// second</span>
</code></pre> 
<p>两个代码片的输出结果都是<code>second</code>，原因是在预编译阶段虽然对变量<code>bar</code>进行了声明，但是不会对其进行赋值；函数<code>bar</code>则被创建并提升。在代码执行阶段，变量bar才会被赋值（通过表达式赋值）。</p> 
<p>继续看代码思考问题：</p> 
<pre><code class="prism language-js"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    foo <span class="token operator">=</span> num<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> foo<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
foo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>执行结果:</p> 
<pre><code class="prism language-js"><span class="token keyword">undefined</span>
<span class="token number">10</span>
<span class="token punctuation">[</span>Function<span class="token operator">:</span> foo<span class="token punctuation">]</span>
<span class="token number">1</span> 
</code></pre> 
<p>在<code>foo(10)</code>执行时，会在函数体内进行变量提升，此时执行函数体内的第一行会输出<code>undefined</code>，执行函数体内的第三行会输出<code>foo</code>，接着运行代码，运行到函数体外的<code>console.log(foo)</code>语句时，会输出<code>foo</code>函数的内容(因为<code>foo</code>函数内的<code>foo = num</code>,<code>num</code>被赋值给函数作用域内的<code>foo</code>变量)。</p> 
<blockquote> 
 <p>结论：作用域在调用栈预编译阶段确定，但是作用域链实在执行上下文的创建阶段完成生成的，因为函数在调用时才会开始创建对应的执行上下文，执行上下文包括变量对象、作用域链、this的指向。</p> 
</blockquote> 
<p>代码执行过程：</p> 
<ol><li>预编译阶段创建变量对象(VO,Variable Object)，此时只是创建，而未进行赋值。</li><li>代码执行阶段，变量对象转为激活对象(AO,Active Object)，完成VO到AO的转换，此时，作用域链也将被确定，它由当前执行环境的变量对象和所有外层已经完成的激活对象组成。这道工序保证了变量和函数的有序访问，如果未在当前作用域中找到变量，则会继续向上查找直到全局作用域。</li></ol> 
<h4><a id="_247"></a>调用栈</h4> 
<p>在理解执行上下文的基础上，函数调用栈就很容易理解了。在执行函数时，如果这个函数又调用了另外一个函数，而这“另外一个函数”又调用了另外一个函数 (开启套娃模式)，这样便形成了一系列的调用栈</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo4'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>foo1</code>先入栈，紧接着<code>foo1</code>调用<code>foo2</code>，<code>foo2</code>再入栈，以此类推，直到<code>foo4</code>执行完；然后<code>foo4</code>先出栈，接着<code>foo3</code>出栈，以此类推。这个过程满足先进后出（后进先出）的规则，因此形成调用栈。</p> 
<p>  正常来讲，在函数执行完毕并处栈时，函数内的局部变量再下一个垃圾回收(GC)节点会被回收，该函数对应的执行上下文将会被销毁，这也是我们在外界无妨访问函数内定义变量的原因。也就是说，只有在函数执行时，相关函数才可以访问该变量，该变量会在预编译阶段被创建，再执行阶段被激活，在函数执行完毕后，其相关上下文会被销毁。</p> 
<h3><a id="_271"></a>闭包</h3> 
<p>  前面解释了：作用域、执行上下文、调用栈，目的还是为闭包知识做准备，终于到了闭包环节了。<br>   匿名函数经常被人误认为是闭包（closure）。闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。(红宝书第四版)</p> 
<p>通俗来讲：函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可以访问，进而形成闭包。</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">numGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    num<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> getNum <span class="token operator">=</span> <span class="token function">numGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>numGenerator</code>创建一个变量num,接着返回打印num值的匿名函数，宰割函数引用了变量num，使得在外部通过调用<code>getNum</code>方法访问变量num，因此在<code>numGenerator</code>执行完毕之后，即相关调用栈出栈之后，变量num不会消失，任然有机会被外界访问。</p> 
<p>  在正常情况下，外界是无妨访问函数内部的变量的，函数执行之后，上下文被销毁。但是在函数（外层）中，如果我们返回了另一个函数，且这个返回的函数使用了函数（外层）内的变量，那么外界便能够通过这个返回的函数获取原函数（外层）内部的变量值。这就是闭包的基本原理。</p> 
<h3><a id="_294"></a>内存管理</h3> 
<p>  内存管理都是指对内存生命周期的管理，而内存的生命周期无外乎分配内存、读写内存、释放内存。</p> 
<pre><code class="prism language-js"><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token string">'bar'</span> <span class="token comment">// 分配内存  </span>
<span class="token function">alert</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">//读写内存 </span>
foo <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">//释放内存</span>
</code></pre> 
<h4><a id="_304"></a>内存管理基本概念</h4> 
<p>内存空间：</p> 
<ul><li>栈空间：由计算机自动分配释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈</li><li>堆空间：开发者分配释放，关于这部分空间要考虑垃圾回收的问题。</li></ul> 
<p>数据类型：</p> 
<ul><li>基本数据类型：<code>undefined</code>、<code>null</code>、<code>number</code>、<code>boolean</code>、<code>string</code>等</li><li>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code>等</li></ul> 
<p>  一般情况下，基本数据类型按照值大小保存在栈空间中，占有固定大小的内存空间；引用类型保存在堆空间中，内存空间大小并不固定，需按引用情况来进行访问。</p> 
<p>  Js依赖宿主浏览器的垃圾回收机制，一般情况下不用开发者操行。但这并不代表在释放内存方面就万事大吉了，某些情况下依然会出现内存泄漏现象。</p> 
<p>   内存泄漏是指内存空间已经不再使用，但由于某种原因并没有被释放的现象（这是一个“玄学”的概念）。因为内存空间是否还在使用在某种程度上是不可判定的，或者判定成本很高。内存泄漏会导致程序运行缓慢、崩溃。</p> 
<h4><a id="_322"></a>内存泄漏场景举例</h4> 
<pre><code class="prism language-js"><span class="token keyword">let</span> <span class="token literal-property property">element</span><span class="token operator">:</span>any <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"element"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span>mark <span class="token operator">=</span> <span class="token string">"marked"</span><span class="token punctuation">;</span>

<span class="token comment">// 移除element节点  </span>
element<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 优化加  </span>
element<span class="token operator">=</span><span class="token keyword">null</span>
</code></pre> 
<p>删除了id为element的节点，到那时变量element存在，该节点占有的内存无法释放，为了解决这个问题，需要在<code>remove</code>方法中添加<code>element=null</code>，这样更稳妥。</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> <span class="token literal-property property">element</span><span class="token operator">:</span>any <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"element"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;Button id='button'&gt;点击&lt;/Button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
button<span class="token operator">?.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'first'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
<span class="token comment">// 优化</span>
button<span class="token operator">?.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'first'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>因为<code>element.innerHTML = '';</code>,Button元素已经从DOM删除了，但是由于事件处理句柄还在，所以该节点变量依然无法被回收。因此还需要移除事件，防止内存泄漏。</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'mark'</span><span class="token punctuation">;</span>
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>由于存在<code>setInterval</code>，所以name内存空间始终无法被释放，如果不是业务要求的话，一定记得在合适的时机使用<code>clearInterval</code>清除。</p> 
<h4><a id="_364"></a>浏览器垃圾回收</h4> 
<h4><a id="_366"></a>内存泄漏和垃圾回收注意事项</h4> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码中，变量value将会被保存在内存中，如果加上<code>bar = null</code>，则随着<code>bar</code>不再被引用，<code>value</code>也会被清除。</p> 
<p>结合浏览器引擎优化，修改代码：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">debugger</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在浏览器中执行代码，并在函数<code>bar</code>中设置断点，会发现<code>value</code>没有被引用</p> 
<p>在<code>bar</code>函数中加入对value的引用</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">debugger</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此时在引擎中存在闭包变量value值</p> 
<p>通过实例借助<code>Chrome devtool</code>排查内存泄漏的具体位置，代码如下：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">createNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> div<span class="token punctuation">;</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> frag <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        div<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        frag<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>frag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">badCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">createNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>badCode<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">badCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码递归调用了<code>badCode</code>，这个函数每次向<code>array</code>数组中写入新的由100000项0~1数字组成的新数组，<code>badCode</code>函数使用全局变量<code>array</code>后并没有手动释放内存，垃圾回收机制不会处理<code>array</code>,因此会导致内存泄漏；同时，<code>badCode</code>函数调用了<code>createNodes</code>函数，每秒会创建100个div节点。</p> 
<p>打开<code>Chrome devtool</code>,选中<code>Perfonnance</code>拍下快照，可以看到<code>JS Heap</code>和<code>Nodes</code>线随着时间线一直在上升，并没有被垃圾回收机制回收。</p> 
<h2><a id="_441"></a>例题分析</h2> 
<h3><a id="1_443"></a>实战例题1</h3> 
<pre><code class="prism language-js"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> v<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>foo是一个立即执行函数，尝试打印<code>foo</code>时，要执行代码：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> v<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>输出结果：</p> 
<pre><code class="prism language-js"><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> v<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在循环执行<code>foo</code>时，引用自由变量10次，最后执行foo时，得到10.这里的自由变量是指在没有相关函数作用域中声明，但却被使用了的变量。</p> 
<h3><a id="2_480"></a>实战例题2</h3> 
<pre><code class="prism language-js"><span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>自由变量为i，执行foo返回的是<code>arr[0]</code>,<code>arr[0]</code>此时是函数，其中变量i的值是10</p> 
<h3><a id="3_497"></a>实战例题3</h3> 
<pre><code class="prism language-js"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">innerFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    fn <span class="token operator">=</span> innerFoo<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>正常来讲，根据调用栈的知识，foo函数执行完毕后，其执行环境生命周期会结束，所占用的内存会被垃圾收集器释放，上下文消失。但是通过讲<code>innerFoo</code>函数赋值给全局变量<code>fn</code>，<code>foo</code>的变量对像<code>a</code>也会被保留下来。所以，函数<code>fn</code>在函数<code>bar</code>内部执行时，依然可以访问这个被保留下来的变量对象，输出结果为2。</p> 
<h3><a id="4_517"></a>实战例题4</h3> 
<pre><code class="prism language-js"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">foo</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">innerFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    fn <span class="token operator">=</span> innerFoo<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">100</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>报错：<code>c is not defined</code>，在bar中执行fn时，fn已经被复制为<code>innerFoo</code>,变量c并不在其作用域链上，c只是bar函数的内部变量。</p> 
<h2><a id="_539"></a>总结</h2> 
<p>  做为合格的前端工程师并不是要背诵晦涩难懂的“闭包和垃圾回收机制”，而是根据面临的场景，凭借扎实的基础，能够通过查阅文档和资料提升应用性能，分析内存事故原因从而突破瓶颈。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da40bf7e28a862f575459b8d04db4eef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;_4——关键字（extern）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d17c5e11be9b0fd2a06b30541e57781/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第一个Unity项目——Flappy Bird</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>