<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构作业——1单向链表的基本操作 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构作业——1单向链表的基本操作" />
<meta property="og:description" content="数据结构，严蔚敏C语言版。书上的基本实现。
1.h：//预定义头文件 和 宏定义（函数结果状态代码）。
#pragma once #include&lt;iostream&gt; #include&lt;malloc.h&gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVER -2 #define n 10 typedef int Santus; 2.h：定义单向链表的结构体。
采用递归定义，next指向下一个结构体。
#pragma once typedef int Elemtype; typedef struct Lnode { Elemtype data; struct Lnode *next; }Lnode,*Linklist; 3.h：
#pragma once #include&#34;1.h&#34; #include&#34;2.h&#34; using namespace std; void show() { cout &lt;&lt; &#34;1.取出第i个元素&#34; &lt;&lt; endl &lt;&lt; &#34;2.插入节点&#34; &lt;&lt; endl// &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/98cee4a3ea57c244a45c5bc5aecd765a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-12T00:05:49+08:00" />
<meta property="article:modified_time" content="2018-09-12T00:05:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构作业——1单向链表的基本操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>数据结构，严蔚敏C语言版。书上的基本实现。</p> 
<p> </p> 
<p>1.h：//预定义头文件 和 宏定义（函数结果状态代码）。</p> 
<p> </p> 
<p> </p> 
<pre class="has"><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;malloc.h&gt;
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVER -2
#define n 10
typedef int Santus;
</code></pre> 
<p> </p> 
<p> </p> 
<p>2.h：定义单向链表的结构体。</p> 
<p>采用递归定义，next指向下一个结构体。</p> 
<pre class="has"><code>#pragma once
typedef int Elemtype;
typedef struct Lnode {
	Elemtype data;
	struct Lnode *next;
}Lnode,*Linklist;</code></pre> 
<p>3.h：</p> 
<pre class="has"><code>#pragma once
#include"1.h"
#include"2.h"
using namespace std;
void show() {
	cout &lt;&lt; "1.取出第i个元素" &lt;&lt; endl

		&lt;&lt; "2.插入节点" &lt;&lt; endl//
		&lt;&lt; "3.删除节点" &lt;&lt; endl
		&lt;&lt; "4.清空链表" &lt;&lt; endl
		&lt;&lt; "5.读链表" &lt;&lt; endl
		&lt;&lt; "6.是否为空" &lt;&lt; endl
		&lt;&lt; "7.链表元素个数" &lt;&lt; endl
		&lt;&lt; "8.第一个与e满足compare关系" &lt;&lt; endl
		&lt;&lt; "9.销毁链表" &lt;&lt; endl
		&lt;&lt; "10.返回前驱" &lt;&lt; endl
		&lt;&lt; "11.返回后继" &lt;&lt; endl;
}
//Santus list_creat2(Linklist &amp;l) {//头插建立链表


//}
Santus list_creat(Linklist &amp; l, Elemtype a[n]) {//尾插建立链表
	l = (Linklist)malloc(sizeof(Lnode));
	if (!l) {
		cout &lt;&lt; "建立失败" &lt;&lt; endl;
		return ERROR;
	}
	l-&gt;next = NULL;
	Linklist l1 = l;
	for (int j = 0; j &lt; n; j++) {
		Linklist p= (Linklist)malloc(sizeof(Lnode));
		if (!p) {
			cout &lt;&lt; "建立失败" &lt;&lt; endl;
			return ERROR;
		}
		p-&gt;data = a[j];
		p-&gt;next = nullptr;
		l1-&gt;next = p;
		l1 = l1-&gt;next;

	}
	return OK;
}
void LinkedListCreateTailL(Linklist&amp; L, Elemtype a[n])

{

	L = (Lnode *)malloc(sizeof(Lnode));

	if (L == NULL)

	{

		printf("申请空间失败！");

		exit(0);

	}

	L-&gt;next = NULL;

	Linklist tail = L;         //设置尾指针，方便插入



	for (int j = 0; j&lt;n; j++)

	{

		Linklist p = (Lnode *)malloc(sizeof(Lnode));

		if (p == NULL)

		{

			printf("申请空间失败！");

			exit(0);

		}



		p-&gt;data = a[j];

		p-&gt;next = NULL;

		tail-&gt;next = p;

		tail = p;

	}

}
Santus Getelem(Linklist l, int i, Elemtype&amp;e) {//取出元素
	Linklist p = l-&gt;next;
	int j = 1;
	while (p  &amp;&amp; j &lt; i) {
		p = p-&gt;next;
		++j;

	}
	if (!p||j&gt;i)
		return ERROR;
	e = p-&gt;data;
	return OK;
	
}
Santus list_insert(Linklist &amp; l,int i,Elemtype e) {//插入元素
	Linklist p=l ;
	int j = 0;
	while (p&amp;&amp;j &lt; i - 1) {
		p = p-&gt;next;
		++j;
	}
	if (!p || j &gt; i - 1)
		return ERROR;
	Linklist q = (Linklist)malloc(sizeof(Lnode));
	if (!q)
		return ERROR;
	q-&gt;data = e;
	q-&gt;next = p-&gt;next;
	p-&gt;next = q;
	return OK;

}
void read(Linklist l) {//read list
	if (l-&gt;next == NULL)
		cout &lt;&lt; "没有数据" &lt;&lt; endl;
	else {
		Linklist p = l-&gt;next;
		while (p != NULL) {
			cout &lt;&lt; p-&gt;data &lt;&lt; "   ";
			p = p-&gt;next;
		}
	}
}
Santus list_delet(Linklist &amp;l, int i, Elemtype &amp;e) {//删除节点
	Linklist p = l;
	int j = 0;
	while (p-&gt;next&amp;&amp;j &lt; i - 1) {
		p = p-&gt;next;
		++j;
	}
	if (!p-&gt;next || j &gt; i - 1)
		return ERROR;
	Linklist q = p-&gt;next;
	e = q-&gt;data;
	p-&gt;next = q-&gt;next;
	return OK;
	
}
Santus  clear_list(Linklist&amp;l) {//清空链表
	Linklist p = l-&gt;next,q=p;
	while (p) {
		p = p-&gt;next;
		free(q);
		q = p;
	}
	free(q);
	l-&gt;next = NULL;
	return OK;
}
Santus destory_list(Linklist&amp; l) {//销毁链表，销毁头结点
	Linklist p = l;
	while (p) {
		l = l-&gt;next;
		free(p);
		p = l;
		
	}
	return OK;
}
Santus list_empty(Linklist l) {//是否为空链表
	if (l-&gt;next == NULL)
		return TRUE;
	else
		return FALSE;
}
int list_length(Linklist l) {//链表元素个数
	Linklist p = l;
	int j = 0;
	while (p-&gt;next) {
		p = p-&gt;next;
		j++;
	}
	return j;
}
Santus compare(Elemtype e1, Elemtype e2 ) {
	if (e1 == e2)
		return OK;
	else
		return FALSE;

}

int locate_elem(Linklist l, Elemtype e) {//返回第一个与e满足compare的元素位序
	Linklist p = l-&gt;next;
	int j = 1;
	while (p &amp;&amp; !((*compare)(p-&gt;data, e))) {
		p = p-&gt;next;

			j++;
	}
	if (!p)
		return 0;
	return j;

}
Santus prior_elem(Linklist l, Elemtype cur_e, Elemtype &amp;pre_e) {//返回前驱节点
	Linklist p = l-&gt;next;
	int j = 1;
	while (p&amp;&amp;j &lt; locate_elem(l, cur_e) - 1) {
		p = p-&gt;next;
		j++;
	}
	if (!p||j&gt;locate_elem(l, cur_e) - 1)
		return ERROR;
	pre_e = p-&gt;data;
	return OK;
}
Santus next_elem(Linklist l, Elemtype cur_e, Elemtype &amp;next_e) {//返回节点后继
	Linklist p = l-&gt;next;
	int j =1;
	while (p-&gt;next&amp;&amp;j &lt; locate_elem(l, cur_e)) {
		p = p-&gt;next;
		j++;
	}
	if (!p-&gt;next || j &gt; locate_elem(l, cur_e))
		return ERROR;
	next_e = p-&gt;next-&gt;data;
	return OK;
}
</code></pre> 
<p>text.cpp:</p> 
<pre class="has"><code>#include"1.h"
#include"2.h"
#include"3.h"
using namespace std;



int main() {
	Linklist l;
	Elemtype a[n] = { 1,2,3,4,5,6,7,8,9,10 },e,e2;
	list_creat(l, a);
	//LinkedListCreateTailL(l, a);
	int i;
	
	 show();
	do {
		

		int select;
		cout &lt;&lt; "input caozuo" &lt;&lt; endl;
		cin &gt;&gt; select;
		switch (select)
		{
		case 1:
			cout &lt;&lt; "取出第几个" &lt;&lt; endl;
			cin &gt;&gt; i;
			Getelem(l, i, e);
			if (Getelem(l, i, e) == ERROR)
				cout &lt;&lt; "读取失败" &lt;&lt; endl;
			else {
				cout &lt;&lt; e &lt;&lt; endl;
				read(l);
				cout &lt;&lt; endl;
			}
			
			break;
		case 2:
			cout&lt;&lt;"input set" &lt;&lt; endl;
			cin &gt;&gt; i;
			cout &lt;&lt; "input num" &lt;&lt; endl;
			cin &gt;&gt; e;
			
			if (list_insert(l, i, e) == ERROR)
				cout &lt;&lt; "插入失败" &lt;&lt; endl;
			else {
				read(l);
				cout &lt;&lt; endl;
			}
			break;
		case 3:
			cout &lt;&lt; "input set" &lt;&lt; endl;
			cin &gt;&gt; i;
			if (list_delet(l, i, e) == ERROR) {
				cout &lt;&lt; "失败" &lt;&lt; endl;
				
			}
			else {
				read(l);//读链表
				cout &lt;&lt; endl;
				cout &lt;&lt; e &lt;&lt; endl;
			}
			break;
		case 4://清空链表
			if (clear_list(l))
				cout&lt;&lt;"清空成功"&lt;&lt;endl;

				
			break;
		case 5:
			read(l);
			cout &lt;&lt; endl;
			break;
		case 6:
			if (list_empty(l))
				cout &lt;&lt; "空链表" &lt;&lt; endl;
			else
				cout &lt;&lt; "非空链表" &lt;&lt; endl;
			
			break;
		case 7:
			cout &lt;&lt; "元素个数为：" &lt;&lt; list_length(l) &lt;&lt; endl;
			break;
		case 8:
			cout &lt;&lt; "input e:";
			cin &gt;&gt; e;
			if (locate_elem(l, e) != 0)
				cout &lt;&lt; "存在于" &lt;&lt; locate_elem(l, e) &lt;&lt;"位置"&lt;&lt; endl;
			else
				cout &lt;&lt; "不存在" &lt;&lt; endl;
			break;
		case 9:
			if (destory_list(l))
				cout &lt;&lt; "销毁成功" &lt;&lt; endl;
			break;
		case 10:
			cout &lt;&lt; "input number" &lt;&lt; endl;
			cin &gt;&gt; e;
			if (prior_elem(l, e, e2) != ERROR)
				cout &lt;&lt; e2 &lt;&lt; endl;
			else
				cout &lt;&lt; "错误" &lt;&lt; endl;
			break;
		case 11:
			cout &lt;&lt; "input number" &lt;&lt; endl;
			cin &gt;&gt; e;
			if (next_elem(l, e, e2) != ERROR)
				cout &lt;&lt; e2 &lt;&lt; endl;
			else
				cout &lt;&lt; "错误" &lt;&lt; endl;
			break;
		default:
			cout &lt;&lt; "input right select" &lt;&lt; endl;
			break;
		}


	} while (1);



	
	

	system("pause");
	return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81c4d7bb872e9facbe332543fb2ef4a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">别人遇到的两条前端面试题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b3c133087c04ef76ce4e0e7c333659d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue 组件中监听路由变化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>