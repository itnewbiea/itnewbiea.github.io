<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Oracle进阶篇之查看执行计划 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Oracle进阶篇之查看执行计划" />
<meta property="og:description" content="目录
一、查看执行计划的方式
1.1、设置autotrace
1.2、使用第三方工具
1.3、EXPLAIN PLAN FOR
二、清除SGA缓存
三、分析执行计划
3.1、创建测试表
3.2、查看执行计划
3.2.1、执行计划
3.2.2、谓词说明：
3.2.3、统计信息
四、部分信息解释
4.1、SQL*Net roundtrips to/from client的计算方式
4.2、consistent gets
今天谈一谈Oracle查看执行计划的方式，以及怎样看执行计划。
一、查看执行计划的方式 1.1、设置autotrace autotrace命令如下
序号
命令
解释
1
SET AUTOTRACE OFF
此为默认值，即关闭Autotrace
2
SET AUTOTRACE ON EXPLAIN
只显示执行计划
3
SET AUTOTRACE ON STATISTICS
只显示执行的统计信息
4
SET AUTOTRACE ON
包含2,3两项内容
5
SET AUTOTRACE TRACEONLY
与ON相似，但不显示语句的执行结果
1.2、使用第三方工具 比如PL/SQL Develop的explain窗口
1.3、EXPLAIN PLAN FOR 据说在执行的SQL前加上 EXPLAIN PLAN FOR 可以查看执行计划，还没搞明白，后续补上
举例：
SQL&gt; EXPLAIN PLAN FOR SELECT * FROM EMP;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b2e4ad6309d3495a427ae4d0dc9c0ae0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-08T17:33:58+08:00" />
<meta property="article:modified_time" content="2021-12-08T17:33:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Oracle进阶篇之查看执行计划</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E6%96%B9%E5%BC%8F" rel="nofollow" title="一、查看执行计划的方式">一、查看执行计划的方式</a></p> 
<p id="1.1%E3%80%81%E8%AE%BE%E7%BD%AEautotrace-toc" style="margin-left:40px;"><a href="#1.1%E3%80%81%E8%AE%BE%E7%BD%AEautotrace" rel="nofollow" title="1.1、设置autotrace">1.1、设置autotrace</a></p> 
<p id="1.2%E3%80%81%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7-toc" style="margin-left:40px;"><a href="#1.2%E3%80%81%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7" rel="nofollow" title="1.2、使用第三方工具">1.2、使用第三方工具</a></p> 
<p id="1.3%E3%80%81EXPLAIN%20PLAN%20FOR-toc" style="margin-left:40px;"><a href="#1.3%E3%80%81EXPLAIN%20PLAN%20FOR" rel="nofollow" title="1.3、EXPLAIN PLAN FOR">1.3、EXPLAIN PLAN FOR</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%B8%85%E9%99%A4SGA%E7%BC%93%E5%AD%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%B8%85%E9%99%A4SGA%E7%BC%93%E5%AD%98" rel="nofollow" title="二、清除SGA缓存">二、清除SGA缓存</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92" rel="nofollow" title="三、分析执行计划">三、分析执行计划</a></p> 
<p id="3.1%E3%80%81%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E8%A1%A8-toc" style="margin-left:40px;"><a href="#3.1%E3%80%81%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E8%A1%A8" rel="nofollow" title="3.1、创建测试表">3.1、创建测试表</a></p> 
<p id="3.2%E3%80%81%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92-toc" style="margin-left:40px;"><a href="#3.2%E3%80%81%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92" rel="nofollow" title="3.2、查看执行计划">3.2、查看执行计划</a></p> 
<p id="3.2.1%E3%80%81%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92-toc" style="margin-left:80px;"><a href="#3.2.1%E3%80%81%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92" rel="nofollow" title="3.2.1、执行计划">3.2.1、执行计划</a></p> 
<p id="3.2.2%E3%80%81%E8%B0%93%E8%AF%8D%E8%AF%B4%E6%98%8E%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.2.2%E3%80%81%E8%B0%93%E8%AF%8D%E8%AF%B4%E6%98%8E%EF%BC%9A" rel="nofollow" title="3.2.2、谓词说明：">3.2.2、谓词说明：</a></p> 
<p id="3.2.3%E3%80%81%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#3.2.3%E3%80%81%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF" rel="nofollow" title="3.2.3、统计信息">3.2.3、统计信息</a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%83%A8%E5%88%86%E4%BF%A1%E6%81%AF%E8%A7%A3%E9%87%8A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%83%A8%E5%88%86%E4%BF%A1%E6%81%AF%E8%A7%A3%E9%87%8A" rel="nofollow" title="四、部分信息解释">四、部分信息解释</a></p> 
<p id="4.1%E3%80%81SQL*Net%20roundtrips%20to%2Ffrom%20client%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#4.1%E3%80%81SQL*Net%20roundtrips%20to%2Ffrom%20client%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F" rel="nofollow" title="4.1、SQL*Net roundtrips to/from client的计算方式">4.1、SQL*Net roundtrips to/from client的计算方式</a></p> 
<p id="4.2%E3%80%81consistent%20gets-toc" style="margin-left:40px;"><a href="#4.2%E3%80%81consistent%20gets" rel="nofollow" title="4.2、consistent gets">4.2、consistent gets</a></p> 
<hr id="hr-toc"> 
<p>今天谈一谈Oracle查看执行计划的方式，以及怎样看执行计划。</p> 
<h2 id="%E4%B8%80%E3%80%81%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E6%96%B9%E5%BC%8F">一、查看执行计划的方式</h2> 
<h3 id="1.1%E3%80%81%E8%AE%BE%E7%BD%AEautotrace">1.1、设置autotrace</h3> 
<p>autotrace命令如下</p> 
<div> 
 <table border="1" cellspacing="0"><tbody><tr><td style="border-color:rgba(0,0,0,1);"> <p style="margin-left:0;"><span style="color:rgba(255,0,0,1);">序号</span></p> </td><td> <p style="margin-left:0;"><span style="color:rgba(255,0,0,1);">命令</span></p> </td><td> <p style="margin-left:0;"><span style="color:rgba(255,0,0,1);">解释</span></p> </td></tr><tr><td> <p style="margin-left:0;">1</p> </td><td> <p style="margin-left:0;">SET AUTOTRACE OFF</p> </td><td> <p style="margin-left:0;">此为默认值，即关闭Autotrace</p> </td></tr><tr><td> <p style="margin-left:0;">2</p> </td><td> <p style="margin-left:0;">SET AUTOTRACE ON EXPLAIN</p> </td><td> <p style="margin-left:0;">只显示执行计划</p> </td></tr><tr><td> <p style="margin-left:0;">3</p> </td><td> <p style="margin-left:0;">SET AUTOTRACE ON STATISTICS</p> </td><td> <p style="margin-left:0;">只显示执行的统计信息</p> </td></tr><tr><td> <p style="margin-left:0;">4</p> </td><td> <p style="margin-left:0;">SET AUTOTRACE ON</p> </td><td> <p style="margin-left:0;">包含2,3两项内容</p> </td></tr><tr><td> <p style="margin-left:0;">5</p> </td><td> <p style="margin-left:0;">SET AUTOTRACE TRACEONLY</p> </td><td> <p style="margin-left:0;">与ON相似，但不显示语句的执行结果</p> </td></tr></tbody></table> 
</div> 
<h3 id="1.2%E3%80%81%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7">1.2、使用第三方工具</h3> 
<p>比如PL/SQL Develop的explain窗口</p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/ff/f6/tiMdYuLI_o.png" width="1167"></p> 
<h3 id="1.3%E3%80%81EXPLAIN%20PLAN%20FOR">1.3、EXPLAIN PLAN FOR</h3> 
<p><span style="color:#fe2c24;">据说在执行的SQL前加上 EXPLAIN PLAN FOR 可以查看执行计划，还没搞明白，后续补上</span></p> 
<p>举例：</p> 
<blockquote> 
 <p>SQL&gt; EXPLAIN PLAN FOR SELECT * FROM EMP;</p> 
 <p>已解释。</p> 
 <p>SQL&gt; SELECT plan_table_output FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE'));</p> 
 <p>或者：</p> 
 <p>SQL&gt; select * from table(dbms_xplan.display);</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E6%B8%85%E9%99%A4SGA%E7%BC%93%E5%AD%98">二、清除SGA缓存</h2> 
<p>因为在sql执行时，sql的执行计划、从磁盘读取的数据库等信息会在SGA的某些缓存中保存一段时间，为了查看语句第一次执行的效果，就需要清空这些缓存。</p> 
<blockquote> 
 <p>ALTER SYSTEM FLUSH SHARED_POOL;<br> ALTER SYSTEM FLUSH BUFFER_CACHE;<br> ALTER SYSTEM FLUSH GLOBAL CONTEXT;</p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">三、分析执行计划</h2> 
<h3 id="3.1%E3%80%81%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E8%A1%A8">3.1、创建测试表</h3> 
<p>新建两张表cust_info、cst_tran（单纯用来测试，没有实际意义）</p> 
<blockquote> 
 <p>CREATE TABLE CUST_INFO<br> (CST_NO NUMBER,<br> CST_NAME VARCHAR2(50),<br> AGE SMALLINT);</p> 
 <p>CREATE TABLE CST_TRAN<br> (<br> CST_NO NUMBER,<br> TRAN_DATE VARCHAR2(8),<br> TRAN_AMT NUMBER(19,3)<br> );</p> 
</blockquote> 
<p>插入一些数据，CUST_INFO表1万，CST_TRAN表100万。</p> 
<blockquote> 
 <p>INSERT INTO CUST_INFO<br> SELECT 100000+LEVEL,<br>        'test'||LEVEL,<br>        ROUND(DBMS_RANDOM.VALUE(1,100))<br> FROM DUAL<br> CONNECT BY LEVEL&lt;=10000;</p> 
 <p><br> INSERT INTO CST_TRAN<br> WITH AA AS<br> (SELECT LEVEL FROM DUAL CONNECT BY LEVEL&lt;=100)<br> SELECT T.CST_NO,<br>        TO_CHAR(SYSDATE - DBMS_RANDOM.VALUE(1,1000),'yyyymmdd'),<br>        ROUND(DBMS_RANDOM.VALUE(1,999999999),3)<br> FROM CUST_INFO T<br> INNER JOIN AA<br> ON 1=1;</p> 
</blockquote> 
<h3 id="3.2%E3%80%81%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">3.2、查看执行计划</h3> 
<p>查看这两个表关联的执行计划</p> 
<blockquote> 
 <p>SQL&gt; SELECT T.CST_NO, T.CST_NAME, G.TRAN_DATE, G.TRAN_AMT FROM CUST_INFO T INNER JOIN CST_TRAN G ON G.CST_NO = T.CST_NO;</p> 
 <p>1000000 rows selected.</p> 
 <p><br> Execution Plan<br> ----------------------------------------------------------<br> Plan hash value: 2290587575</p> 
 <p>--------------------------------------------------------------------------------<br> | Id  | Operation                        | Name          | Rows  | Bytes | Cost (%CPU)| Time     |<br> --------------------------------------------------------------------------------<br> |   0 | SELECT STATEMENT   |                     |   996K|    68M|  1079     (2)| 00:00:13 |<br> |*  1 |  HASH JOIN                   |                     |   996K|    68M|  1079     (2)| 00:00:13 |<br> |   2 |   TABLE ACCESS FULL | CUST_INFO | 10000 |   390K|    11     (0)| 00:00:01 |<br> |   3 |   TABLE ACCESS FULL | CST_TRAN  |  1065K|    32M|  1064     (1)| 00:00:13 |<br> --------------------------------------------------------------------------------</p> 
 <p>Predicate Information (identified by operation id):<br> ---------------------------------------------------</p> 
 <p>   1 - access("G"."CST_NO"="T"."CST_NO")</p> 
 <p>Note<br> -----<br>    - dynamic sampling used for this statement (level=2)</p> 
 <p><br> Statistics<br> ----------------------------------------------------------<br>     561  recursive calls<br>       0  db block gets<br>       70483  consistent gets<br>        4389  physical reads<br>       0  redo size<br>    45078003  bytes sent via SQL*Net to client<br>      733845  bytes received via SQL*Net from client<br>       66668  SQL*Net roundtrips to/from client<br>      10  sorts (memory)<br>       0  sorts (disk)<br>     1000000  rows processed</p> 
</blockquote> 
<h4 id="3.2.1%E3%80%81%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">3.2.1、执行计划</h4> 
<p>首先我们看一下第一部分</p> 
<blockquote> 
 <p>--------------------------------------------------------------------------------<br> | Id  | Operation                        | Name          | Rows  | Bytes | Cost (%CPU)| Time     |<br> --------------------------------------------------------------------------------<br> |   0 | SELECT STATEMENT   |                     |   996K|    68M|  1079     (2)| 00:00:13 |<br> |*  1 |  HASH JOIN                   |                     |   996K|    68M|  1079     (2)| 00:00:13 |<br> |   2 |   TABLE ACCESS FULL | CUST_INFO | 10000 |   390K|    11     (0)| 00:00:01 |<br> |   3 |   TABLE ACCESS FULL | CST_TRAN  |  1065K|    32M|  1064     (1)| 00:00:13 |<br> --------------------------------------------------------------------------------</p> 
</blockquote> 
<p style="margin-left:0;"><span style="color:#0d0016;"><strong>执行计划中字段解释：</strong></span></p> 
<ul><li style="margin-left:0px;">       ID: 一个序号，但不是执行的先后顺序。执行的先后根据缩进来判断。</li><li style="margin-left:0px;">       Operation： 当前操作的内容。</li><li style="margin-left:0px;">       Rows： 当前操作的Cardinality，Oracle估计当前操作的返回结果集。</li><li style="margin-left:0px;">       Cost（CPU）：Oracle 计算出来的一个数值（代价），用于说明SQL执行的代价。</li><li style="margin-left:0px;">       Time：Oracle 估计当前操作的时间。</li></ul> 
<p><strong>说明：</strong></p> 
<p>1、Operation</p> 
<p>记录每一步的操作，按照缩进的程度判断执行的先后顺序。</p> 
<p>在OLAP数据库中，HASH JOIN连接较多，特别是返回数据集大的时候，基本都是HASH JOIN。</p> 
<p>2、Rows</p> 
<p style="margin-left:0;">rows值表示CBO预期从一个行源（row source）返回的记录数，这个行源可能是一个表，一个索引，也可能是一个子查询。   在Oracle 9i中的执行计划中，Cardinality缩写成Card。 在10g中，Card值被rows替换。</p> 
<p style="margin-left:0;"><span style="color:#fe2c24;">rows</span><span style="color:#ff0000;">值对于CBO</span><span style="color:#ff0000;">做出正确的执行计划来说至关重要。</span> 如果CBO获得的rows值不够准确（通常是没有做分析或者分析数据过旧造成），在执行计划成本计算上就会出现偏差，从而导致CBO错误的制定出执行计划。</p> 
<p style="margin-left:0;">在多表关联查询或者SQL中有子查询时，每个关联表或子查询的rows的值对主查询的影响都非常大，甚至可以说，CBO就是依赖于各个关联表或者子查询rows值计算出最后的执行计划。</p> 
<p style="margin-left:0;">对于多表查询，CBO使用每个关联表返回的行数（rows）决定用什么样的访问方式来做表关联（如Nested loops Join 或 hash Join）</p> 
<p style="margin-left:0;">3、Cost（CPU）和Time是执行计划的重要参考值</p> 
<h4 id="3.2.2%E3%80%81%E8%B0%93%E8%AF%8D%E8%AF%B4%E6%98%8E%EF%BC%9A" style="margin-left:0px;"><span style="color:#0d0016;">3.2.2、谓词说明：</span></h4> 
<blockquote> 
 <p>Predicate Information (identified by operation id):<br> ---------------------------------------------------</p> 
 <p>   1 - access("G"."CST_NO"="T"."CST_NO")</p> 
 <p>Note<br> -----<br>    - dynamic sampling used for this statement (level=2)</p> 
</blockquote> 
<p style="margin-left:0;">       Access: 表示这个谓词条件的值将会影响数据的访问路劲（表还是索引）。</p> 
<p style="margin-left:0;">       Filter：表示谓词条件的值不会影响数据的访问路劲，只起过滤的作用。（此例中没有）</p> 
<p style="margin-left:0;"><span style="color:#ff0000;">注意：在谓词中主要注意</span><span style="color:#ff0000;">access</span><span style="color:#ff0000;">，要考虑谓词的条件，使用的访问路径是否正确。</span></p> 
<h4 id="3.2.3%E3%80%81%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF" style="margin-left:0px;">3.2.3、统计信息</h4> 
<p></p> 
<blockquote> 
 <p>Statistics<br> ----------------------------------------------------------<br>     561  recursive calls<br>       0  db block gets<br>       70483  consistent gets<br>        4389  physical reads<br>       0  redo size<br>    45078003  bytes sent via SQL*Net to client<br>      733845  bytes received via SQL*Net from client<br>       66668  SQL*Net roundtrips to/from client<br>      10  sorts (memory)<br>       0  sorts (disk)<br>     1000000  rows processed</p> 
</blockquote> 
<p>参数说明：</p> 
<ul><li>recursive calls   :递归调用。一般原因：dictionary cache未命中；动态存储扩展；PL/SQL语句</li><li>db block gets    :bufer中读取的block数量，用于insert,update,delete,selectfor update</li><li>consistent gets   :这里是一致读次数（一个block可能会被读多次），bufer中读取的用于查询（除掉select forupdate）的block数量。                </li><li>physical reads    :从磁盘上读取的block数量,敬请关注每周五晚免费网络公开课。</li><li>redo size      :bytes，写到redo logs的数据量</li><li>bytes sent via SQL*Net to client ：发送给客户端的字节数</li><li>bytes received via SQL*Net from client ：从客户端接收的字节数</li><li>SQL*Net roundtrips to/from client ：与客户端的交互次数（<span style="color:#fe2c24;">个人理解接收一条SQL语句，执行结果分多次发送给客户端，如有问题请指正</span>）</li><li>sorts (memory)    :内存排序次数</li><li>sorts (disk)     :磁盘排序次数；与sort_area_size有关 </li><li>rows processed ：执行完SQL后返回结果集的行数</li></ul> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81%E9%83%A8%E5%88%86%E4%BF%A1%E6%81%AF%E8%A7%A3%E9%87%8A">四、部分信息解释</h2> 
<h3 id="4.1%E3%80%81SQL*Net%20roundtrips%20to%2Ffrom%20client%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><strong>4.1、SQL*Net roundtrips to/from client的计算方式</strong></h3> 
<p>这个指标的计算方式和一个参数息息相关，<strong>arraysize</strong>。</p> 
<p>arraysize是什么呢？</p> 
<p>请查阅大牛博文：<a class="link-info" href="https://blog.csdn.net/tianlesoftware/article/details/6579913" title="Oracle arraysize 和 fetch size 参数 与 性能优化 说明">Oracle arraysize 和 fetch size 参数 与 性能优化 说明</a></p> 
<p>arraysize定义了一次返回到客户端的行数，取值范围【1-5000】，默认15。</p> 
<p>使用命令在数据库中查看arraysize的值。</p> 
<blockquote> 
 <p>show arraysize</p> 
</blockquote> 
<p>还可以修改这个值</p> 
<blockquote> 
 <p>set arraysize 5000;</p> 
</blockquote> 
<p>明白了arraysize这个参数就可以计算SQL*Net roundtrips to/from client的值了。上例中，返回客户端结果集的行数是1000000，默认arraysize值是15，1000000/15向上取整等于66667。</p> 
<p>为啥要向上取整？</p> 
<p>举个栗子，如果有10个苹果，一个只能拿3个，几次可以拿完，3次可以拿9个，还剩1个，所以还需要再拿一次，共4次。</p> 
<p>统计分析中的值是66668，为什么我们计算的值是66667？</p> 
<p>就要看这个指标本身了，再粘贴一次：SQL*Net roundtrips<span style="background-color:#fe2c24;"> to/from </span>client  重点看from，意思是我们还要接受一次客户端发来的SQL语句，因此是：66667+1，本问题纯属个人臆断，无真凭实据，受限于本人的知识水平，如有误，请指出。</p> 
<p>将arraysize的值修改为5000后，再观察SQL*Net roundtrips to/from client的变化，结果为201。</p> 
<p>前面提到 arraysize的取值范围是【1-5000】，我们可以试一下改为不在这个区间的值，比如改为0，结果报错了</p> 
<blockquote> 
 <p>SQL&gt; set arraysize 0;<br> SP2-0267: arraysize option 0 out of range (1 through 5000)</p> 
</blockquote> 
<h3 id="4.2%E3%80%81consistent%20gets"><strong>4.2、consistent gets</strong></h3> 
<p>译为中文就是：一致性读， 好抽象的一个指标，啥叫一致性读，心中无数羊驼驼在大海中狂奔。</p> 
<p><strong>官网对consistent gets 的解释：</strong></p> 
<p>consistent gets：Number of times a consistent read wasrequested for a block.</p> 
<p>通常我们执行SQL查询时涉及的每一block都是Consistent Read, 只是有些CR(Consistent Read)需要使用undo 来进行构造, 大部分CR(Consistent Read)并不涉及到undo block的读.</p> 
<p>还有就是每次读这个block都是一次CR(可能每个block上有多个数据row), 也就是如果某个block被读了10次, 系统会记录10个Consistent Read.</p> 
<p>如果想深入学习，请参考大佬博文：<a href="https://www.cndba.cn/Dave/article/1081" rel="nofollow" title="Oracle 有关 Consistent gets 的测试 -- cnDBA.cn_中国DBA社区">Oracle 有关 Consistent gets 的测试 -- cnDBA.cn_中国DBA社区</a></p> 
<p>接来下测试下， consistent gets是从哪来的，需要使用有sysdba权限的用户，因为oradebug工具需要sysdba权限。</p> 
<p>oradebug工具介绍：<a class="link-info" href="https://blog.csdn.net/dba_waterbin/article/details/7874558">oracle实用工具：oradebug</a></p> 
<p>使用10046对同一条数据跟踪两次，注意观察 consistent gets的不同</p> 
<p><strong>为了不影响测试结果，首先清空缓存</strong></p> 
<blockquote> 
 <p>SQL&gt; ALTER SYSTEM FLUSH SHARED_POOL;</p> 
 <p>System altered.</p> 
 <p>SQL&gt; ALTER SYSTEM FLUSH BUFFER_CACHE;</p> 
 <p>System altered.</p> 
 <p>SQL&gt; ALTER SYSTEM FLUSH GLOBAL CONTEXT;</p> 
 <p>System altered.</p> 
</blockquote> 
<p><strong>第一次执行 </strong></p> 
<blockquote> 
 <p>SQL&gt; set tim on timing on<br> 00:42:30 SQL&gt; set autot trace stat<br> 00:42:36 SQL&gt; oradebug setmypid<br> Statement processed.<br> 00:42:42 SQL&gt; alter session set tracefile_identifier='chf1';</p> 
 <p>Session altered.</p> 
 <p>Elapsed: 00:00:00.01<br> 00:42:50 SQL&gt; oradebug event 10046 trace name context forever,level 12;<br> Statement processed.<br> 00:42:57 SQL&gt; SELECT T.CST_NO, T.CST_NAME, G.TRAN_DATE, G.TRAN_AMT FROM CHF.CUST_INFO T INNER JOIN CHF.CST_TRAN G ON G.CST_NO = T.CST_NO;</p> 
 <p>1000000 rows selected.</p> 
 <p>Elapsed: 00:00:22.71</p> 
 <p>Statistics<br> ----------------------------------------------------------<br>     547  recursive calls<br>       0  db block gets<br>       70368  consistent gets<br>        3898  physical reads<br>       0  redo size<br>    45078003  bytes sent via SQL*Net to client<br>      733845  bytes received via SQL*Net from client<br>       66668  SQL*Net roundtrips to/from client<br>      10  sorts (memory)<br>       0  sorts (disk)<br>     1000000  rows processed</p> 
 <p>00:44:24 SQL&gt; oradebug event 10046 trace name context off;<br> Statement processed.<br> 00:45:54 SQL&gt; oradebug tracefile_name<br> /u01/app/oracle/diag/rdbms/orcl/bpas/trace/bpas_ora_7715_chf1.trc</p> 
</blockquote> 
<p><strong>第二次执行 </strong></p> 
<blockquote> 
 <p>00:46:04 SQL&gt; alter session set tracefile_identifier='chf2';</p> 
 <p>Session altered.</p> 
 <p>Elapsed: 00:00:00.00<br> 00:46:35 SQL&gt; oradebug event 10046 trace name context forever,level 12;<br> Statement processed.<br> 00:46:43 SQL&gt; SELECT T.CST_NO, T.CST_NAME, G.TRAN_DATE, G.TRAN_AMT FROM CHF.CUST_INFO T INNER JOIN CHF.CST_TRAN G ON G.CST_NO = T.CST_NO;</p> 
 <p>1000000 rows selected.</p> 
 <p>Elapsed: 00:00:21.62</p> 
 <p>Statistics<br> ----------------------------------------------------------<br>       0  recursive calls<br>       0  db block gets<br>       70301  consistent gets<br>        3850  physical reads<br>       0  redo size<br>    45078003  bytes sent via SQL*Net to client<br>      733845  bytes received via SQL*Net from client<br>       66668  SQL*Net roundtrips to/from client<br>       0  sorts (memory)<br>       0  sorts (disk)<br>     1000000  rows processed</p> 
 <p>00:47:11 SQL&gt; oradebug event 10046 trace name context off;<br> Statement processed.<br> 00:49:03 SQL&gt; oradebug tracefile_name<br> /u01/app/oracle/diag/rdbms/orcl/bpas/trace/bpas_ora_7715_chf2.trc</p> 
</blockquote> 
<p>通过对比两次执行，发现consistent gets、physical reads、sorts (memory)都有变化，这是因为SGA中已经缓存了部分数据块。</p> 
<p>再对比下我们刚才生产的两个跟踪日志，为方便查看，先将其格式转换以下</p> 
<blockquote> 
 <p>[oracle@localhost ~]$ tkprof /u01/app/oracle/diag/rdbms/orcl/bpas/trace/bpas_ora_7715_chf1.trc /u01/chf1.trc</p> 
 <p>TKPROF: Release 11.2.0.1.0 - Development on Wed Dec 8 00:53:37 2021</p> 
 <p>Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.</p> 
 <p><br> [oracle@localhost ~]$ tkprof /u01/app/oracle/diag/rdbms/orcl/bpas/trace/bpas_ora_7715_chf2.trc /u01/chf2.trc</p> 
 <p>TKPROF: Release 11.2.0.1.0 - Development on Wed Dec 8 00:53:48 2021</p> 
 <p>Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.</p> 
</blockquote> 
<p>打开 /u01/chf1.trc，下面贴出部分重要信息</p> 
<blockquote> 
 <p>OVERALL TOTALS FOR ALL NON-RECURSIVE STATEMENTS</p> 
 <p>call     count       cpu    elapsed       disk      query    current        rows<br> ------- ------  -------- ---------- ---------- ---------- ----------  ----------<br> Parse        1      0.03       0.03          8         <strong>67 </strong>         0           0<br> Execute      1      0.00       0.00          0          0          0           0<br> Fetch    66668      0.76       3.24       3890      <strong>70301</strong>          0     1000000<br> ------- ------  -------- ---------- ---------- ---------- ----------  ----------<br> total    66670      0.79       3.28       3898      <strong>70368</strong>          0     1000000</p> 
 <p>Misses in library cache during parse: 1</p> 
 <p>Elapsed times include waiting on following events:<br>   Event waited on                             Times   Max. Wait  Total Waited<br>   ----------------------------------------   Waited  ----------  ------------<br>   SQL*Net message to client                   66670        0.01          0.14<br>   SQL*Net message from client                 66670       64.54         79.11<br>   db file sequential read                         5        0.00          0.00<br>   Disk file operations I/O                        1        0.00          0.00<br>   db file scattered read                          5        0.00          0.00<br>   asynch descriptor resize                        4        0.00          0.00<br>   direct path read                               69        0.00          0.02</p> 
 <p><br> OVERALL TOTALS FOR ALL RECURSIVE STATEMENTS</p> 
 <p>call     count       cpu    elapsed       disk      query    current        rows<br> ------- ------  -------- ---------- ---------- ---------- ----------  ----------<br> Parse       12      0.00       0.00          0          0          0           0<br> Execute     24      0.01       0.01          0          0          0           0<br> Fetch       30      0.00       0.00          8        <strong> 67</strong>          0          18<br> ------- ------  -------- ---------- ---------- ---------- ----------  ----------<br> total       66      0.02       0.02          8         <strong>67</strong>          0          18</p> 
</blockquote> 
<p>打开 /u01/chf2.trc，下面贴出部分重要信息</p> 
<blockquote> 
 <p>OVERALL TOTALS FOR ALL NON-RECURSIVE STATEMENTS</p> 
 <p>call     count       cpu    elapsed       disk      query    current        rows<br> ------- ------  -------- ---------- ---------- ---------- ----------  ----------<br> Parse        1      0.00       0.00          0         <strong> 0</strong>          0           0<br> Execute      1      0.00       0.00          0          0          0           0<br> Fetch    66668      1.57       3.73       3850     <strong> 70301</strong>          0     1000000<br> ------- ------  -------- ---------- ---------- ---------- ----------  ----------<br> total    66670      1.57       3.73       3850     <strong> 70301 </strong>         0     1000000</p> 
 <p>Misses in library cache during parse: 0</p> 
 <p>Elapsed times include waiting on following events:<br>   Event waited on                             Times   Max. Wait  Total Waited<br>   ----------------------------------------   Waited  ----------  ------------<br>   SQL*Net message to client                   66670        0.00          0.10<br>   SQL*Net message from client                 66670        6.83         19.93<br>   asynch descriptor resize                        4        0.00          0.00<br>   direct path read                               69        0.00          0.01</p> 
 <p><br> OVERALL TOTALS FOR ALL RECURSIVE STATEMENTS</p> 
 <p>call     count       cpu    elapsed       disk      query    current        rows<br> ------- ------  -------- ---------- ---------- ---------- ----------  ----------<br> Parse        0      0.00       0.00          0          0          0           0<br> Execute      0      0.00       0.00          0          0          0           0<br> Fetch        0      0.00       0.00          0          0          0           0<br> ------- ------  -------- ---------- ---------- ---------- ----------  ----------<br> total        0      0.00       0.00          0          0          0           0</p> 
</blockquote> 
<p>比较发现，第一次执行解析SQL语句，生产执行计划时，consistent gets发生67次，执行SQL语句时发生70301。第一次执行解析SQL语句，生产执行计划时，因已经有缓存，所以consistent gets发生0次，执行SQL语句时发生70301。</p> 
<p></p> 
<p>参考：</p> 
<p><a href="https://www.cndba.cn/Dave/article/1081" rel="nofollow" title="Oracle 有关 Consistent gets 的测试 -- cnDBA.cn_中国DBA社区">Oracle 有关 Consistent gets 的测试 -- cnDBA.cn_中国DBA社区</a></p> 
<p><a href="https://blog.csdn.net/tianlesoftware/article/details/6579913" title="Oracle arraysize 和 fetch size 参数 与 性能优化 说明_David Dai -- Focus on Oracle-CSDN博客_oracle查询arraysize">Oracle arraysize 和 fetch size 参数 与 性能优化 说明_David Dai -- Focus on Oracle-CSDN博客_oracle查询arraysize</a></p> 
<p><a href="https://blog.csdn.net/dba_waterbin/article/details/7874558" title="oracle实用工具：oradebug_记录创业路上的一些想法-CSDN博客_oradebug setmypid">oracle实用工具：oradebug_记录创业路上的一些想法-CSDN博客_oradebug setmypid</a> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2aa9ac6671c62233c202fa3e93e15e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">你不知道的并发/继发请求操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3463326f97e1f2465f4c4540a4a3908e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[零基础算法入门①] 双指针法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>