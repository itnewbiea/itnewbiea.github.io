<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多线程 | 多线程实现方式和差异 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多线程 | 多线程实现方式和差异" />
<meta property="og:description" content="1、为什么要使用多线程呢? 从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成本远远⼩于进程。
现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。
提高CPU的利用率 目前大多数CPU都是多核的 可以都利用起来。
耗时的操作使用多线程，可以异步执行提高应用程序响应。
常用场景：客户端请求后可以异步执行不用返回给客户端的数据处理、后台定时任务中的异步分批执行任务、优化复杂查询（FutureTask）等等。
2、线程的生命周期和状态? 3、使用多线程可能带来什么问题? 并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。
4、线程创建方式？ 继承 Thread private static void thread() { Thread thread = new Thread(() -&gt; { try { // 业务代码 。。。 //加sleep 试一下执行顺序 Thread.sleep(100); System.out.println(&#34;Thread方式执行 新 线程:&#34; &#43; Thread.currentThread().getName()); } catch (InterruptedException e) { e.printStackTrace(); } }); //调用 start 才会执行线程中的 run()方法中的业务代码 thread.start(); System.out.println(&#34;Thread方式执行 主 线程:&#34;&#43;Thread.currentThread().getName()); } 通过实现Thread类型创建线程（实际开发中用到的不多,直接用线程池，只是为了单开一个线程可以使用）
执行结果:可以看出没有按照顺序执行，异步的。主线程比新开线程先执行。
实现 Runnable private static void runnable() { Runnable runnable = ()-&gt; { // 业务代码 。。。 try { //加sleep 试一下执行顺序 Thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ab54ba4fe02a4767e5ed1dd524d300fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-21T11:58:37+08:00" />
<meta property="article:modified_time" content="2023-02-21T11:58:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多线程 | 多线程实现方式和差异</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1、为什么要使用多线程呢?</span></h2> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成本远远⼩于进程。</span></p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。</span></p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">提高CPU的利用率 目前大多数CPU都是多核的 可以都利用起来。</span></p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">耗时的操作使用多线程，可以异步执行提高应用程序响应。</span></p></li></ol> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">常用场景</span>：客户端请求后可以异步执行不用返回给客户端的数据处理、后台定时任务中的异步分批执行任务、优化复杂查询（FutureTask）等等。</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2、线程的生命周期和状态?</span></h2> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:15.27027%;height:0;"> 
    <img src="https://images2.imgbox.com/31/c0/wpvtOiOk_o.png" style="margin-left:;display:block;width:740px;margin-top:-15.27027%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3、使用多线程可能带来什么问题?</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4、线程创建方式？</span></h2> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><h3><span class="kdocs-bold" style="font-weight:bold;">继承 Thread</span></h3></li></ol> 
 <pre class="kdocs-java"><code class="language-java"> private static void thread() {
        Thread thread = new Thread(() -&gt; {
            try {
                // 业务代码 。。。
                //加sleep 试一下执行顺序
                Thread.sleep(100);
                System.out.println("Thread方式执行 新 线程:" + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        //调用 start 才会执行线程中的 run()方法中的业务代码
        thread.start();
        System.out.println("Thread方式执行 主 线程:"+Thread.currentThread().getName());
    }</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">通过实现Thread类型创建线程（实际开发中用到的不多,直接用线程池，只是为了单开一个线程可以使用）</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">执行结果:可以看出没有按照顺序执行，异步的。主线程比新开线程先执行。</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:347px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:22.1902%;height:0;"> 
    <img src="https://images2.imgbox.com/57/72/fP6MERt4_o.png" style="margin-left:;display:block;width:347px;margin-top:-22.1902%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><h3><span class="kdocs-bold" style="font-weight:bold;">实现 Runnable</span></h3></li></ol> 
 <pre class="kdocs-java"><code class="language-java">private static void runnable() {
        Runnable runnable = ()-&gt; {
            // 业务代码 。。。
            try {
                //加sleep 试一下执行顺序
                Thread.sleep(100);
                System.out.println("Runnable 方式执行 新 线程:" + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        //调用 start 才会执行线程中的 run()方法中的业务代码
        new Thread(runnable).start();
        System.out.println("Runnable 方式执行 主 线程:"+Thread.currentThread().getName());
    }</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">通过实现Runnable和Thread的结果是一样的。</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:325px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:24.307692%;height:0;"> 
    <img src="https://images2.imgbox.com/6b/2a/AS0S2uNg_o.png" style="margin-left:;display:block;width:325px;margin-top:-24.307692%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3、实现Callable</span></h3> 
 <pre class="kdocs-java"><code class="language-java"> private static void callable() throws ExecutionException, InterruptedException {
        Callable callable = ()-&gt; {
            // 业务代码 。。。
            //加sleep 试一下执行顺序
            Thread.sleep(100);
            System.out.println("Callable 方式执行 新 线程:" + Thread.currentThread().getName());
            return 1;
        };
        //要使用Callable还不能直接像 Runnable 一样，而是要借助 FutureTask
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(callable);
        new Thread(futureTask).start();
        //获取返回值
        System.out.println(futureTask.get() );
        System.out.println("Callable 方式执行 主 线程:"+Thread.currentThread().getName());
    }</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">通过实现Runnable ，使用callable还不能直接像 runnable 一样，而是要借助 FutureTask。可以得到新线程的结果，且异常可以抛到主线程种</span>（这里也有个坑，就是如果新新线程种出现异常抛到主线程，可能不是很容易定位）</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:347px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:26.801153%;height:0;"> 
    <img src="https://images2.imgbox.com/25/ac/kHbOxXve_o.png" style="margin-left:;display:block;width:347px;margin-top:-26.801153%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4、线程池创建方式</span></h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:20.675676%;height:0;"> 
    <img src="https://images2.imgbox.com/3f/d7/xxBp9Zvl_o.png" style="margin-left:;display:block;width:740px;margin-top:-20.675676%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">线程池的4种创建方式</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Executors.newCachedThreadPool() 创建一个可缓存的线程池</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue());</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Executors.newFixedThreadPool(3) 创建固定大小的线程池</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">LinkedBlockingQueue 核心线程和最大线程是相同的</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Executors.newSingleThreadExecutor() 创建一个单线程化的线程池</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">核心线程和最大都是一个 LinkedBlockingQueue </span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Executors.newScheduledThreadPool(5) 创建一个定长线程池。</span>此线程池支持定时以及周期性执行任务的需求。— 延迟执行</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">ThreadPoolExecutor的方式程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写更加明确线程池的运行规则，规避资源耗尽的风险。</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">基于ThreadPoolExecutor线程池工具类</span></p> 
 <pre class="kdocs-java"><code class="language-java">public class ThreadPoolUtils {
    //可用处理器的Java虚拟机的数量
    private static int CORE_SIZE  =  Runtime.getRuntime().availableProcessors();
    private static int CORE_MAX_SIZE =  Runtime.getRuntime().availableProcessors()*2;
    // volatile 保证线程的存可见性
    private static volatile ExecutorService executorService ;
    private static ExecutorService getInstance(){
        synchronized (ThreadPoolUtils.class){
            if(executorService == null){
                synchronized (ThreadPoolUtils.class){
                    return executorService = new ThreadPoolExecutor(CORE_SIZE, CORE_MAX_SIZE , 10, TimeUnit.SECONDS,
                            new LinkedBlockingQueue&lt;&gt;(), Executors.defaultThreadFactory(),
                            new ThreadPoolExecutor.AbortPolicy());
                }
            }
            return executorService;
        }
    }

    public static void submit(Runnable runnable) {
        getInstance().submit(runnable);
    }

    public static &lt;T&gt; Future&lt;T&gt; submitCall(Callable&lt;T&gt; callable) {
        return getInstance().submit(callable);
    }

    public static void synCall(Runnable... runnableSet) {
        for (Runnable runnable : runnableSet) {
            getInstance().submit(runnable);
        }
    }
}
</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5、SpringBoot 中的多线程开启</span></h3> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">在SpringBootApplication启动类上开启这个异步注解@EnableAsync。</span></span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">配置 Configuration 配置线程池的参数</span></span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">在需要开启异步的方法上面加注解 @Async 【<span class="kdocs-italic" style="font-style:italic;">异步方法不要和主线程在同一个类，不然可能会不生效哦</span>】</span></span></p></li></ul> 
 <pre class="kdocs-java"><code class="language-java"> @Bean("scheduledTaskExecutor")
    public Executor asyncSendCouponsScheduledTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        //配置核心线程数
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());
        //配置最大线程数
        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 2);
        //配置队列大小
        executor.setQueueCapacity(500000);
        //配置线程池中的线程的名称前缀
        executor.setThreadNamePrefix("scheduled-task-executor-");
        // rejection-policy：当pool已经达到max size的时候，如何处理新任务
        // CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        //执行初始化
        executor.initialize();
        return executor;
    }</code></pre> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5、为什么要⽤线程池？</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">降低资源消耗</span>：通过重复利用已创建的线程减少线程的创建和销毁造成的消耗。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">提高响应速度</span>：当任务到达时，可以不用等待线程创建就可以直接执行。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">提⾼线程的可管理性</span>：线程时稀缺资源，不断地无限制创建，不仅会消耗系统的资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优、监管。</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">总结</span></h2> 
 <p style="text-align:left;"><span class="kdocs-color" style="color:#116AF0;"><span class="kdocs-bold" style="font-weight:bold;">1、Thread和Runnable的异同：</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Thread 和 Runnable本质上没有什么区别，看源码可以看见Thread是 类，Runnable是 接口，Thread实现了Runnable接口（只有一个run()方法）</span>。</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Thread作为实现类扩展了很多实现方法</span>。</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:38.243244%;height:0;"> 
    <img src="https://images2.imgbox.com/d1/65/HJexUcFx_o.png" style="margin-left:;display:block;width:740px;margin-top:-38.243244%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">在使用上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现Runnable 。</span></span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-color" style="color:#116AF0;"><span class="kdocs-bold" style="font-weight:bold;">2、Runnable与Callable的异同</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">相同点</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">都是接口</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">都可以编写多线程程序</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">都采用Thread.start()启动线程</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">不同点</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">Runnable没有返回值；Callable可以返回执行结果</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">Callable接口的call()允许抛出异常；Runnable的run()不能抛出</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">要使用Callable还不能直接像 Runnable 一样，而是要借助</span><a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/weixin_43882141/article/details/118417400" target="_blank" rel="noopener noreferrer"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-underline" style="text-decoration:underline;"> FutureTask</span></span></a></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-color" style="color:#116AF0;"><span class="kdocs-bold" style="font-weight:bold;">3、相比new Thread，Java提供的四种线程池的好处在于：</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"> 每次new Thread新建对象性能差。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">缺乏更多功能，如定时执行、定期执行、线程中断。</span></p></li></ul> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"> 线程池重用存在的线程，减少对象创建、消亡的开销，性能佳。</span></p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"> 线程池可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</span></p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">线程池提供定时执行、定期执行、单线程、并发数控制等功能。</span></p></li></ol> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8bba99fe158c7f0702d0a64a367371e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【华为云-开发者专属集市】使用ECS搭建WordPress博客平台</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a41f633af9301e578655b6e5a338ce04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何使用Python批量下载图片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>