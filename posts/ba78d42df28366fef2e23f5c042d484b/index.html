<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HDU3790--最短路径问题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HDU3790--最短路径问题" />
<meta property="og:description" content="Problem Description 给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。 Input 输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点。n和m为0时输入结束。 (1&lt;n&lt;=1000, 0&lt;m&lt;100000, s != t) Output 输出 一行有两个数， 最短距离及其花费。 Sample Input 3 2 1 2 5 6 2 3 4 5 1 3 0 0 Sample Output 9 11 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; #define maxn 1008 int W[maxn][maxn]; int Wc[maxn][maxn]; int dis[maxn]; int cost[maxn]; inline int min(int a,int b) { return a&gt;b?b:a; } int main() { int n,m; while(scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ba78d42df28366fef2e23f5c042d484b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-04-29T17:16:58+08:00" />
<meta property="article:modified_time" content="2013-04-29T17:16:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HDU3790--最短路径问题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="panel_title" align="left">
  Problem Description 
</div> 
<div class="panel_content">
  给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。 
</div> 
<div class="panel_bottom"></div> 
<br> 
<div class="panel_title" align="left">
  Input 
</div> 
<div class="panel_content">
  输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点。n和m为0时输入结束。 
 <br> (1&lt;n&lt;=1000, 0&lt;m&lt;100000, s != t) 
</div> 
<div class="panel_bottom"></div> 
<br> 
<div class="panel_title" align="left">
  Output 
</div> 
<div class="panel_content">
  输出 一行有两个数， 最短距离及其花费。 
</div> 
<div class="panel_bottom"></div> 
<br> 
<div class="panel_title" align="left">
  Sample Input 
</div> 
<div class="panel_content"> 
 <pre>  
  <div style="font-family:Courier New,Courier,monospace">
   
   3 2
1 2 5 6
2 3 4 5
1 3
0 0
  
  </div></pre> 
</div> 
<div class="panel_bottom"></div> 
<br> 
<div class="panel_title" align="left">
  Sample Output 
</div> 
<div class="panel_content"> 
 <pre style="font-family:Courier New,Courier,monospace">9 11</pre> 
</div> 
<p> </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 1008
int W[maxn][maxn];
int Wc[maxn][maxn];
int dis[maxn];
int cost[maxn];
inline int min(int a,int b)
{
	return a&gt;b?b:a;
}
int main()
{
	int n,m;
	while(scanf("%d%d",&amp;n,&amp;m)==2 &amp;&amp;(n||m))
	{
		memset(W,0x3f,sizeof(W));
		memset(dis,0x3f,sizeof(dis));
		memset(cost,0x3f,sizeof(cost));
		memset(Wc,0x3f,sizeof(Wc));
		for(int i=1;i&lt;=m;i++)
		{
			int a,b,d,p;
			scanf("%d%d%d%d",&amp;a,&amp;b,&amp;d,&amp;p);
			if(W[a][b] &gt; d)
			{
				W[a][b] = W[b][a] = d;
				Wc[a][b] = Wc[b][a] = p;
			}
			else if(W[a][b] == d)
			Wc[a][b] = Wc[b][a] = min(Wc[a][b],p);
		}
		queue &lt;int&gt; q;
		int s,t;
		scanf("%d%d",&amp;s,&amp;t);
		dis[s] = cost[s] = 0;
		q.push(s);
		while(!q.empty())///等下如果超时就用邻接表
		{
			int p = q.front();
			q.pop();
			for(int i=1;i&lt;=n;i++)
			{
				if(dis[p] + W[p][i] &lt; dis[i] || (dis[p] + W[p][i] == dis[i] &amp;&amp; cost[p] + Wc[p][i] &lt; cost[i]))
				{
					dis[i] = dis[p] + W[p][i];
					cost[i] = cost[p] + Wc[p][i];
					q.push(i);
				}
			}
		}
		printf("%d %d\n",dis[t],cost[t]);
	}
	return 0;
}</code></pre> 
<p><br>  </p> 
<p>下面是用邻接表的SPFA。。显然会快一些。187MS。上面的一半还少</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 1008
int dis[maxn];
int key[maxn];
struct Edge
{
	int v,dis,cost;
}edge;
vector &lt;Edge&gt; ans[maxn];
int main()
{
	int n,m;
	while(scanf("%d%d",&amp;n,&amp;m)==2 &amp;&amp;(n||m))
	{
		memset(dis,0x3f,sizeof(dis));
		memset(key,0x3f,sizeof(key));
		for(int i=1;i&lt;=n;i++) 
		{
			ans[i].clear();
		}
		for(int i=1;i&lt;=m;i++)
		{
			int u,v,d,p;
			scanf("%d%d%d%d",&amp;u,&amp;v,&amp;p,&amp;d);
			edge.v = v;
			edge.dis = p;
			edge.cost = d;
			ans[u].push_back(edge);
			edge.v = u;
			ans[v].push_back(edge);
		}
		int s,t;
		scanf("%d%d",&amp;s,&amp;t);
		dis[s] = 0;
		key[s] = 0;
		queue &lt;int&gt; q;
		q.push(s);
		while(!q.empty())
		{
			int p = q.front();
			q.pop();
			for(int i=0;i&lt;ans[p].size();i++)
			{
				if(dis[p] + ans[p][i].dis &lt; dis[ans[p][i].v] ||(dis[p] + ans[p][i].dis == dis[ans[p][i].v] &amp;&amp; key[p] + ans[p][i].cost &lt; key[ans[p][i].v]))
				{
					dis[ans[p][i].v] = dis[p] + ans[p][i].dis;
					key[ans[p][i].v] = key[p] + ans[p][i].cost;
					q.push(ans[p][i].v);
				}
			}
		}
		printf("%d %d\n",dis[t],key[t]);
	}
	return 0;
}</code></pre> 
<p>接下来是优先队列优化的Dijkstra算法i：注意和Prim算法还是有点不同的，Prim是每次找终点为标记的最短的边。而优先队列优化的Dijkstra算法</p> 
<p>每次是要找到不在森林中的距离最短的点。所以赶脚Edge需要起点和终点</p> 
<pre><code class="language-cpp">/* 
接下来用Dijkstra算法
优先队列优化一下帅一点
*/
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 1008
bool vis[maxn];
int Dis[maxn];
int Cost[maxn];
int n,m,s,t;
struct Edge
{
	int ss,v,dis,cost;
	bool operator &lt; (const Edge &amp; a) const
	{
		if(Dis[ss]+dis &gt; Dis[a.ss]+a.dis) return 1;
		if(Dis[ss]+dis &lt; Dis[a.ss]+a.dis) return 0;
		if(Dis[ss]+dis == Dis[a.ss]+a.dis)
		{
			return Cost[ss]+cost &gt; Cost[a.ss]+a.cost;
		}
	}
}edge;
vector &lt;Edge&gt; ans[maxn];
void Dijkstra()
{
	priority_queue &lt;Edge&gt; q;
	edge.cost = 0;
	edge.dis = 0;
	edge.ss = s;
	edge.v = s;
	q.push(edge);
	while(!vis[t] &amp;&amp; !q.empty())
	{
L:
		edge = q.top();
		q.pop();
		while(vis[edge.v] &amp;&amp; !q.empty()) goto L;
		if(!vis[edge.v])
		{
			int nowv = edge.v;
			vis[edge.v] = 1;
			for(int i=0;i&lt;ans[nowv].size();i++)
			{
				if(!vis[ans[nowv][i].v])
				{
					if(Dis[nowv] + ans[nowv][i].dis &lt; Dis[ans[nowv][i].v] ||(Dis[nowv] + ans[nowv][i].dis == Dis[ans[nowv][i].v]
						&amp;&amp; Cost[nowv] + ans[nowv][i].cost &lt; Cost[ans[nowv][i].v] ))
					{
						Dis[ans[nowv][i].v] = Dis[nowv] + ans[nowv][i].dis;
						Cost[ans[nowv][i].v] = Cost[nowv] + ans[nowv][i].cost;
						edge.ss = nowv;
						edge.v = ans[nowv][i].v;
						edge.dis = ans[nowv][i].dis;
						edge.cost = ans[nowv][i].cost;
						q.push(edge);
					}
				}
			}
		}
	}
}
int main()
{
	while(scanf("%d%d",&amp;n,&amp;m)==2 &amp;&amp;(n||m))
	{
		for(int i=1;i&lt;=n;i++) ans[i].clear();
		memset(vis,0,sizeof(vis));
		memset(Dis,0x3f,sizeof(Dis));
		memset(Cost,0x3f,sizeof(Cost));
		for(int i=1;i&lt;=m;i++)
		{
			int u,v,d,p;
			scanf("%d%d%d%d",&amp;u,&amp;v,&amp;d,&amp;p);
			edge.dis = d;
			edge.cost = p;
			edge.ss = u;
			edge.v = v;
			ans[u].push_back(edge);
			edge.v = u;
			edge.ss = v;
			ans[v].push_back(edge);
		}
		scanf("%d%d",&amp;s,&amp;t);
		Dis[s] = Cost[s] = 0;
		Dijkstra();
		printf("%d %d\n",Dis[t],Cost[t]);
	}
	return 0;
}
		</code></pre> 
<p><br> <br>  </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd07ca64e52cca6b89fc6a9fd9afb645/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HDU1301--Jungle Roads</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a339077b3eeb020f8c85797000b6727b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【LaTeX入门】15、在文章中添加脚注</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>