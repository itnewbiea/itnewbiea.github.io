<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LSTM对比Bi-LSTM的电力负荷时间序列预测（Matlab） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LSTM对比Bi-LSTM的电力负荷时间序列预测（Matlab）" />
<meta property="og:description" content="目录
摘要：
1.电力负荷预测：
2.滑动窗输入结构的构建
3.LSTM
4.Bi-LSTM
5.程序运行结果：
6.代码展示
摘要： 本文使用LSTM和Bi-LSTM，以电力负荷预测为例对比了两者的预测性能，其中将电力负荷构造为滑动时间窗的形式作为网络输出输入，实现LSTM与Bi-LSTM网络的多输入单输出模型，相比于单输入单输出的模型有更高的准确性。本文的电力负荷滑动窗输入构建方式具有一定的参考价值。
1.电力负荷预测： 电力负荷预测是一种典型的时间序列回归预测任务。电力负荷预测是保证电力供需平衡的基础,并为电网、电源的规划建设以及电网企业、电网使用者的经营决策提供信息和依据。负荷预测分为长期、中期、短期和超短期负荷预测,预测对象包括系统负荷和母线负荷,由电网企业负责组织编制。大用户应根据有关规定,按时报送其主要接装容量和年、月用电量预测及日用电负荷变化过程。
2.滑动窗输入结构的构建 由于电力负荷具有很强的时间相关性，仅通过上一时刻的负荷预测下一时刻的负荷并不能有效的反应复杂的时间关系，同时也没有充分的利用历史负荷数据的全部信息。所以本文通过滑动时间窗技术将多个历史时间内的负荷情况组合起来，预测下一时刻的负荷情况，并不断向前移动，以完成全天内的负荷预测。具体的构造方法如下：
如上图所示，在t时刻时黄色每一个小框都表示一个时间节点的输入数据，蓝色的小框表示输出数据，将3个黄色小框作为输入预测蓝色小框中的数据；而在t&#43;1时刻，整体往前移动一个时间节点，以此不断前进，直到预测完全体的数据。
3.LSTM 传统RNN网络由于结构存在固有缺陷，在参数更新时会存在梯度消失以及梯度爆炸的问题，导致长距离的历史信息丢失，进一步造成网络极难收敛，无法训练出理想的模型。LSTM作为一种改进的循环神经网络，在原有网络结构的基础上加入了细胞状态(cell state)的结构来控制全局信息的传输，并通过遗忘门，输入门，输出门三种门控单元控制细胞状态信息值的更新。LSTM在极大程度上缓解了传统RNN模型存在的长期依赖问题，减少了长距离历史信息的丢失，输出的预测结果更准确 。LSTM的具体模型如下：
LSTM通过以下公式进行更新权值矩阵和偏置参数等网络信息：
4.Bi-LSTM Bi-LSTM 神经⽹络结构模型分2个独⽴LSTM，输⼊序列分别以正序和逆序输⼊⾄2个LSTM神经⽹络进⾏特征提取，将2个输出向量（即提取后的特征向量）进⾏拼接后形成的词向量作为该词的最终特征表达。Bi-LSTM 的模型设计理念是使 t 时刻所获得特征数据同时拥有过去和将来之间的信息，实验证明，这种神经⽹络结构模型对⽂本特征提取效率和性能要优于单个 LSTM 结构模型。
5.程序运行结果： 本文的数据集是一个包含60日的电力时间序列负荷数据，数据的颗粒度为15min，一天中共有96个点，使用前59日的数据进行训练，用最后一日的数据作为测试集进行负荷预测。滑动时间窗口大小设置为8，即过去两个小时内的负荷预测下一时刻的负荷。
6.代码展示 代码中的输入与输出改为自己的数据即可实现不同的功能，其中滑动窗的大小设置也可根据自己的需要修改。
部分代码：
clc; clear; close all; %% 导入数据 load DATA; % 导入60天的负荷数据 figure(1); plot(fuhe); legend(&#39;电力负荷&#39;); xlabel(&#39;时间(15min)&#39;); ylabel(&#39;功率(Kw)&#39;); title(&#39;60日总负荷数据&#39;); %% 数据归一化处理 % 归一化到0-1之间 Temp = fuhe; [~,PS] = mapminmax(fuhe,0,1); Temp = mapminmax(&#39;apply&#39;,Temp,PS); %% 输入输出构建及滑动时间窗输入结构构建 %数据分组 Windows = 8; %时间窗长度 T = 96; %预测未来一天(15min一次) %各个输入集合大小 X_Train = cell(size(Temp,2)-T-Windows,1); % 训练数据 Y_Train = cell(size(Temp,2)-T-Windows,1); % 测试数据 X_Test = cell(T,1); Y_Test = cell(T,1); % 训练数据构建 clc;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/327499f7d1ea8dc1201dc0df032c6980/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-30T09:13:26+08:00" />
<meta property="article:modified_time" content="2022-11-30T09:13:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LSTM对比Bi-LSTM的电力负荷时间序列预测（Matlab）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%91%98%E8%A6%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%91%98%E8%A6%81%EF%BC%9A" rel="nofollow">摘要：</a></p> 
<p id="1.%E7%94%B5%E5%8A%9B%E8%B4%9F%E8%8D%B7%E9%A2%84%E6%B5%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#1.%E7%94%B5%E5%8A%9B%E8%B4%9F%E8%8D%B7%E9%A2%84%E6%B5%8B%EF%BC%9A" rel="nofollow">1.电力负荷预测：</a></p> 
<p id="2.%E6%BB%91%E5%8A%A8%E7%AA%97%E8%BE%93%E5%85%A5%E7%BB%93%E6%9E%84%E7%9A%84%E6%9E%84%E5%BB%BA-toc" style="margin-left:0px;"><a href="#2.%E6%BB%91%E5%8A%A8%E7%AA%97%E8%BE%93%E5%85%A5%E7%BB%93%E6%9E%84%E7%9A%84%E6%9E%84%E5%BB%BA" rel="nofollow">2.滑动窗输入结构的构建</a></p> 
<p id="3.LSTM-toc" style="margin-left:0px;"><a href="#3.LSTM" rel="nofollow">3.LSTM</a></p> 
<p id="4.Bi-LSTM-toc" style="margin-left:0px;"><a href="#4.Bi-LSTM" rel="nofollow">4.Bi-LSTM</a></p> 
<p id="5.%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A-toc" style="margin-left:0px;"><a href="#5.%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A" rel="nofollow">5.程序运行结果：</a></p> 
<p id="6.%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-toc" style="margin-left:0px;"><a href="#6.%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" rel="nofollow">6.代码展示</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%91%98%E8%A6%81%EF%BC%9A"><strong>摘要：</strong></h2> 
<p>本文使用LSTM和Bi-LSTM，以电力负荷预测为例对比了两者的预测性能，其中将电力负荷构造为滑动时间窗的形式作为网络输出输入，实现LSTM与Bi-LSTM网络的多输入单输出模型，相比于单输入单输出的模型有更高的准确性。本文的电力负荷滑动窗输入构建方式具有一定的参考价值。</p> 
<h2 id="1.%E7%94%B5%E5%8A%9B%E8%B4%9F%E8%8D%B7%E9%A2%84%E6%B5%8B%EF%BC%9A"><strong>1.</strong><strong>电力负荷预测：</strong></h2> 
<p>电力负荷预测是一种典型的时间序列回归预测任务。电力负荷预测是保证电力供需平衡的基础,并为电网、电源的规划建设以及电网企业、电网使用者的经营决策提供信息和依据。负荷预测分为长期、中期、短期和超短期负荷预测,预测对象包括系统负荷和母线负荷,由电网企业负责组织编制。大用户应根据有关规定,按时报送其主要接装容量和年、月用电量预测及日用电负荷变化过程。</p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/eb/16/O1hITv2w_o.png" width="375"></p> 
<h2 id="2.%E6%BB%91%E5%8A%A8%E7%AA%97%E8%BE%93%E5%85%A5%E7%BB%93%E6%9E%84%E7%9A%84%E6%9E%84%E5%BB%BA"><strong>2.</strong><strong>滑动窗输入结构的构建</strong></h2> 
<p>由于电力负荷具有很强的时间相关性，仅通过上一时刻的负荷预测下一时刻的负荷并不能有效的反应复杂的时间关系，同时也没有充分的利用历史负荷数据的全部信息。所以本文通过滑动时间窗技术将多个历史时间内的负荷情况组合起来，预测下一时刻的负荷情况，并不断向前移动，以完成全天内的负荷预测。具体的构造方法如下：</p> 
<p><img alt="" height="294" src="https://images2.imgbox.com/a7/e2/uEyS4HrZ_o.png" width="565"></p> 
<p>如上图所示，在t时刻时黄色每一个小框都表示一个时间节点的输入数据，蓝色的小框表示输出数据，将3个黄色小框作为输入预测蓝色小框中的数据；而在t+1时刻，整体往前移动一个时间节点，以此不断前进，直到预测完全体的数据。</p> 
<h2 id="3.LSTM"><strong>3.LSTM</strong></h2> 
<p>传统RNN网络由于结构存在固有缺陷，在参数更新时会存在梯度消失以及梯度爆炸的问题，导致长距离的历史信息丢失，进一步造成网络极难收敛，无法训练出理想的模型。LSTM作为一种改进的循环神经网络，在原有网络结构的基础上加入了细胞状态(cell state)的结构来控制全局信息的传输，并通过遗忘门，输入门，输出门三种门控单元控制细胞状态信息值的更新。LSTM在极大程度上缓解了传统RNN模型存在的长期依赖问题，减少了长距离历史信息的丢失，输出的预测结果更准确 。LSTM的具体模型如下：</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/58/16/ra8Qtp5g_o.png" width="419"></p> 
<p>LSTM通过以下公式进行更新权值矩阵和偏置参数等网络信息：</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/19/b9/JEBHbKhT_o.png" width="354"></p> 
<h2 id="4.Bi-LSTM"><strong>4.Bi-LSTM</strong></h2> 
<p>Bi-LSTM 神经⽹络结构模型分2个独⽴LSTM，输⼊序列分别以正序和逆序输⼊⾄2个LSTM神经⽹络进⾏特征提取，将2个输出向量（即提取后的特征向量）进⾏拼接后形成的词向量作为该词的最终特征表达。Bi-LSTM 的模型设计理念是使 t 时刻所获得特征数据同时拥有过去和将来之间的信息，实验证明，这种神经⽹络结构模型对⽂本特征提取效率和性能要优于单个 LSTM 结构模型。</p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/91/9d/H0JeK7PC_o.png" width="629"></p> 
<h2 id="5.%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A"><strong>5.程序运行结果：</strong></h2> 
<p><strong>本文的数据集是一个包含60日的电力时间序列负荷数据，数据的颗粒度为15min，一天中共有96个点，使用前59日的数据进行训练，用最后一日的数据作为测试集进行负荷预测。滑动时间窗口大小设置为8，即过去两个小时内的负荷预测下一时刻的负荷。</strong></p> 
<p class="img-center"><img alt="" height="369" src="https://images2.imgbox.com/b2/27/uUQaKSoK_o.png" width="419"></p> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/a3/a7/taCwwwxN_o.png" width="545"></p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/18/b9/qncmJNsU_o.png" width="864"></p> 
<h2 id="6.%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA"><strong>6.代码展示</strong></h2> 
<p><strong>代码中的输入与输出改为自己的数据即可实现不同的功能，其中滑动窗的大小设置也可根据自己的需要修改。</strong></p> 
<p>部分代码：</p> 
<pre><code>clc;
clear;
close all;
%% 导入数据
load DATA; % 导入60天的负荷数据
figure(1);
plot(fuhe);
legend('电力负荷');
xlabel('时间(15min)');
ylabel('功率(Kw)');
title('60日总负荷数据');
%% 数据归一化处理
% 归一化到0-1之间
Temp = fuhe;
[~,PS] = mapminmax(fuhe,0,1); 
Temp = mapminmax('apply',Temp,PS);
%% 输入输出构建及滑动时间窗输入结构构建
%数据分组
Windows = 8; %时间窗长度
T = 96; %预测未来一天(15min一次)
%各个输入集合大小
X_Train = cell(size(Temp,2)-T-Windows,1); % 训练数据
Y_Train = cell(size(Temp,2)-T-Windows,1); % 测试数据
X_Test = cell(T,1);
Y_Test = cell(T,1);
% 训练数据构建</code></pre> 
<p>clc;<br> clear;<br> close all;<br> %% 导入数据<br> load DATA; % 导入60天的负荷数据<br> figure(1);<br> plot(fuhe);<br> legend('电力负荷');<br> xlabel('时间(15min)');<br> ylabel('功率(Kw)');<br> title('60日总负荷数据');<br> %% 数据归一化处理<br> % 归一化到0-1之间<br> Temp = fuhe;<br> [~,PS] = mapminmax(fuhe,0,1); <br> Temp = mapminmax('apply',Temp,PS);<br> %% 输入输出构建及滑动时间窗输入结构构建<br> %数据分组<br> Windows = 8; %时间窗长度<br> T = 96; %预测未来一天(15min一次)<br> %各个输入集合大小<br> X_Train = cell(size(Temp,2)-T-Windows,1); % 训练数据<br> Y_Train = cell(size(Temp,2)-T-Windows,1); % 测试数据<br> X_Test = cell(T,1);<br> Y_Test = cell(T,1);<br> % 训练数据构建</p> 
<p></p> 
<p>clc;<br> clear;<br> close all;<br> %% 导入数据<br> load DATA; % 导入60天的负荷数据<br> figure(1);<br> plot(fuhe);<br> legend('电力负荷');<br> xlabel('时间(15min)');<br> ylabel('功率(Kw)');<br> title('60日总负荷数据');<br> %% 数据归一化处理<br> % 归一化到0-1之间<br> Temp = fuhe;<br> [~,PS] = mapminmax(fuhe,0,1); <br> Temp = mapminmax('apply',Temp,PS);<br> %% 输入输出构建及滑动时间窗输入结构构建<br> %数据分组<br> Windows = 8; %时间窗长度<br> T = 96; %预测未来一天(15min一次)<br> %各个输入集合大小<br> X_Train = cell(size(Temp,2)-T-Windows,1); % 训练数据<br> Y_Train = cell(size(Temp,2)-T-Windows,1); % 测试数据<br> X_Test = cell(T,1);<br> Y_Test = cell(T,1);<br> % 训练数据构建</p> 
<p></p> 
<p>clc;<br> clear;<br> close all;<br> %% 导入数据<br> load DATA; % 导入60天的负荷数据<br> figure(1);<br> plot(fuhe);<br> legend('电力负荷');<br> xlabel('时间(15min)');<br> ylabel('功率(Kw)');<br> title('60日总负荷数据');<br> %% 数据归一化处理<br> % 归一化到0-1之间<br> Temp = fuhe;<br> [~,PS] = mapminmax(fuhe,0,1); <br> Temp = mapminmax('apply',Temp,PS);<br> %% 输入输出构建及滑动时间窗输入结构构建<br> %数据分组<br> Windows = 8; %时间窗长度<br> T = 96; %预测未来一天(15min一次)<br> %各个输入集合大小<br> X_Train = cell(size(Temp,2)-T-Windows,1); % 训练数据<br> Y_Train = cell(size(Temp,2)-T-Windows,1); % 测试数据<br> X_Test = cell(T,1);<br> Y_Test = cell(T,1);<br> % 训练数据构建</p> 
<p></p> 
<p>clc;<br> clear;<br> close all;<br> %% 导入数据<br> load DATA; % 导入60天的负荷数据<br> figure(1);<br> plot(fuhe);<br> legend('电力负荷');<br> xlabel('时间(15min)');<br> ylabel('功率(Kw)');<br> title('60日总负荷数据');<br> %% 数据归一化处理<br> % 归一化到0-1之间<br> Temp = fuhe;<br> [~,PS] = mapminmax(fuhe,0,1); <br> Temp = mapminmax('apply',Temp,PS);<br> %% 输入输出构建及滑动时间窗输入结构构建<br> %数据分组<br> Windows = 8; %时间窗长度<br> T = 96; %预测未来一天(15min一次)<br> %各个输入集合大小<br> X_Train = cell(size(Temp,2)-T-Windows,1); % 训练数据<br> Y_Train = cell(size(Temp,2)-T-Windows,1); % 测试数据<br> X_Test = cell(T,1);<br> Y_Test = cell(T,1);<br> % 训练数据构建</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fcd821bcbe5a0c7c4c90e0100b1f0cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Go语言 映射(Map)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75d28b0c5bce0fc525a1f3a7e3919b89/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">websocket-前端代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>