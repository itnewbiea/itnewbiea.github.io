<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——非线性结构（树与二叉树） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——非线性结构（树与二叉树）" />
<meta property="og:description" content="文章目录 一. 非线性结构的概述二. 树的基本概念1. 树的定义2. 专业术语3. 树的性质 三. 树的分类1. 一般树2. 二叉树（是有序树）2.1 概念2.2 分类1. 一般二叉树2. 满二叉树3. 完全二叉树 2.3 二叉树的性质2.3.1 二叉树的常考性质2.3.2 完全二叉树的常考性质 3. 森林 四. 树的存储1. 来源2. 二叉树的存储2.1 连续存储（必须转化为完全二叉树）2.2 链式存储2.2.1 二叉树链式存储结构描述 3. 一般树的存储（用线性来存储非线性结构方法）3.1 双亲表示法（求父节点方便）3.2 孩子表示法（求子节点方便）3.3 双亲孩子表示法（求父节点和子节点都很方便）3.4 孩子兄弟表示法（二叉树表示法） 4. 森林的存储4.1 森林转化为二叉树4.2 存储方法4.3 转化方法 五. 树的操作1. 二叉树的遍历1.1 先序遍历（先访问根节点）1.2 中序遍历（中间访问根节点）1.3 后序遍历（最后访问根节点）1.4 层次遍历1.5 已知两种遍历序列求原始二叉树 2. 森林的遍历2.1 先序遍历森林2.2 中序遍历森林 六. 树与二叉树的应用1. 树是数据库中数据组织的一种重要形式2. 操作系统子父进程关系本身就是一棵树3. 面向对象语言中类的继承关系本身就是一棵树4. 线索二叉树4.1 线索二叉树的基本概念4.2 二叉树的基本操作4.2.1 二叉树的线索化构造4.2.2 线索二叉树找前驱/后继 7. 哈夫曼树（最优二叉树）7.1 基本概念7.1.1 节点的权、带权路径长度7.1.2 哈夫曼树的定义 7.2 哈夫曼树的构造7.3 哈夫曼编码 一." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b71c431942950133281a09ded134eb8b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-20T19:46:11+08:00" />
<meta property="article:modified_time" content="2022-08-20T19:46:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——非线性结构（树与二叉树）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__1" rel="nofollow">一. 非线性结构的概述</a></li><li><a href="#__3" rel="nofollow">二. 树的基本概念</a></li><li><ul><li><a href="#1__4" rel="nofollow">1. 树的定义</a></li><li><a href="#2__14" rel="nofollow">2. 专业术语</a></li><li><a href="#3__35" rel="nofollow">3. 树的性质</a></li></ul> 
  </li><li><a href="#__43" rel="nofollow">三. 树的分类</a></li><li><ul><li><a href="#1__44" rel="nofollow">1. 一般树</a></li><li><a href="#2__48" rel="nofollow">2. 二叉树（是有序树）</a></li><li><ul><li><a href="#21__49" rel="nofollow">2.1 概念</a></li><li><a href="#22__53" rel="nofollow">2.2 分类</a></li><li><ul><li><a href="#1__54" rel="nofollow">1. 一般二叉树</a></li><li><a href="#2__56" rel="nofollow">2. 满二叉树</a></li><li><a href="#3__62" rel="nofollow">3. 完全二叉树</a></li></ul> 
    </li><li><a href="#23__75" rel="nofollow">2.3 二叉树的性质</a></li><li><ul><li><a href="#231__76" rel="nofollow">2.3.1 二叉树的常考性质</a></li><li><a href="#232__80" rel="nofollow">2.3.2 完全二叉树的常考性质</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3__84" rel="nofollow">3. 森林</a></li></ul> 
  </li><li><a href="#__88" rel="nofollow">四. 树的存储</a></li><li><ul><li><a href="#1__89" rel="nofollow">1. 来源</a></li><li><a href="#2__98" rel="nofollow">2. 二叉树的存储</a></li><li><ul><li><a href="#21__99" rel="nofollow">2.1 连续存储（必须转化为完全二叉树）</a></li><li><a href="#22__119" rel="nofollow">2.2 链式存储</a></li><li><ul><li><a href="#221__120" rel="nofollow">2.2.1 二叉树链式存储结构描述</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3__136" rel="nofollow">3. 一般树的存储（用线性来存储非线性结构方法）</a></li><li><ul><li><a href="#31__137" rel="nofollow">3.1 双亲表示法（求父节点方便）</a></li><li><a href="#32__141" rel="nofollow">3.2 孩子表示法（求子节点方便）</a></li><li><a href="#33__147" rel="nofollow">3.3 双亲孩子表示法（求父节点和子节点都很方便）</a></li><li><a href="#34__154" rel="nofollow">3.4 孩子兄弟表示法（二叉树表示法）</a></li></ul> 
   </li><li><a href="#4__165" rel="nofollow">4. 森林的存储</a></li><li><ul><li><a href="#41__166" rel="nofollow">4.1 森林转化为二叉树</a></li><li><a href="#42__169" rel="nofollow">4.2 存储方法</a></li><li><a href="#43__172" rel="nofollow">4.3 转化方法</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__175" rel="nofollow">五. 树的操作</a></li><li><ul><li><a href="#1__180" rel="nofollow">1. 二叉树的遍历</a></li><li><ul><li><a href="#11__181" rel="nofollow">1.1 先序遍历（先访问根节点）</a></li><li><a href="#12__192" rel="nofollow">1.2 中序遍历（中间访问根节点）</a></li><li><a href="#13__200" rel="nofollow">1.3 后序遍历（最后访问根节点）</a></li><li><a href="#14__213" rel="nofollow">1.4 层次遍历</a></li><li><a href="#15__223" rel="nofollow">1.5 已知两种遍历序列求原始二叉树</a></li></ul> 
   </li><li><a href="#2__255" rel="nofollow">2. 森林的遍历</a></li><li><ul><li><a href="#21__256" rel="nofollow">2.1 先序遍历森林</a></li><li><a href="#22__257" rel="nofollow">2.2 中序遍历森林</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__259" rel="nofollow">六. 树与二叉树的应用</a></li><li><ul><li><a href="#1__260" rel="nofollow">1. 树是数据库中数据组织的一种重要形式</a></li><li><a href="#2__261" rel="nofollow">2. 操作系统子父进程关系本身就是一棵树</a></li><li><a href="#3__262" rel="nofollow">3. 面向对象语言中类的继承关系本身就是一棵树</a></li><li><a href="#4__264" rel="nofollow">4. 线索二叉树</a></li><li><ul><li><a href="#41__265" rel="nofollow">4.1 线索二叉树的基本概念</a></li><li><a href="#42__288" rel="nofollow">4.2 二叉树的基本操作</a></li><li><ul><li><a href="#421__290" rel="nofollow">4.2.1 二叉树的线索化构造</a></li><li><a href="#422__329" rel="nofollow">4.2.2 线索二叉树找前驱/后继</a></li></ul> 
   </li></ul> 
   </li><li><a href="#7__333" rel="nofollow">7. 哈夫曼树（最优二叉树）</a></li><li><ul><li><a href="#71__334" rel="nofollow">7.1 基本概念</a></li><li><ul><li><a href="#711__335" rel="nofollow">7.1.1 节点的权、带权路径长度</a></li><li><a href="#712__337" rel="nofollow">7.1.2 哈夫曼树的定义</a></li></ul> 
    </li><li><a href="#72__340" rel="nofollow">7.2 哈夫曼树的构造</a></li><li><a href="#73__346" rel="nofollow">7.3 哈夫曼编码</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="__1"></a>一. 非线性结构的概述</h2> 
<p><img src="https://images2.imgbox.com/a3/8b/F9xHscaA_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__3"></a>二. 树的基本概念</h2> 
<h3><a id="1__4"></a>1. 树的定义</h3> 
<p>专业定义：</p> 
<ul><li>1）有且只有一个称为根的节点</li><li>2）有若干个互不相交的子树，这些子树本身也是一棵树（递归定义）</li></ul> 
<p>通俗定义：</p> 
<ul><li>1）树是由节点和边组成</li><li>2）每个节点只有一个父节点但可以有多个子节点</li><li>3）但有一个节点除外，该节点没有父节点，此节点称为根节点（n个节点的树中有n-1条边）</li></ul> 
<h3><a id="2__14"></a>2. 专业术语</h3> 
<ul><li>节点：一个个圈</li><li>父节点：和它紧挨着的上面的节点（只有一个）</li><li>子节点：父节点的下层节点</li><li>深度：从根节点（第一层）到最底层节点的最大层数</li><li>高度：从叶子节点开始自底向上逐层累加，数值等于深度</li><li>叶子节点：没有子节点的节点</li><li>非终端节点（分支节点）：实际就是非叶子节点</li><li>根节点：既可以是叶子结点，又可以是非叶子节点</li><li>节点的度：这个节点拥有子节点的个数</li><li>树的度：树内各节点度的最大值</li><li>子孙：他下面所有的节点</li><li>堂兄弟：父亲是兄弟，他们就是堂兄弟</li><li>有序树和无序树：树中节点每个子树从左到右有次序，不能互换，称此树为有序树，否则称为无序树</li><li>路径：两节点的路径由这两个节点之间所经过节点序列构成</li><li>路径长度：路径上经过边的个数</li><li>树的路径长度：树根到每个节点路径长度之和</li></ul> 
<p><img src="https://images2.imgbox.com/81/dd/0pxHu0xR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/75/32/99PkiTmV_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__35"></a>3. 树的性质</h3> 
<p><img src="https://images2.imgbox.com/15/56/f9Rs38Xg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/50/1f/0ZLCrIBs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3b/49/JEbiGSTO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/02/01/VUM7Ysx2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9e/9b/D1NxGuWK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/02/56/5rsAj0zz_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__43"></a>三. 树的分类</h2> 
<h3><a id="1__44"></a>1. 一般树</h3> 
<p>定义：任意一个节点的子节点的个数都不受限制<br> <img src="https://images2.imgbox.com/a9/51/3EAybLL5_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__48"></a>2. 二叉树（是有序树）</h3> 
<h4><a id="21__49"></a>2.1 概念</h4> 
<p>定义：任意一个节点的节点个数最多两个，且子节点的位置不可更改（有左右之分）<br> <img src="https://images2.imgbox.com/5e/09/nhb1P3xX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22__53"></a>2.2 分类</h4> 
<h5><a id="1__54"></a>1. 一般二叉树</h5> 
<p><img src="https://images2.imgbox.com/72/db/jxp85Qkq_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__56"></a>2. 满二叉树</h5> 
<p>定义：在不增加树的层数的前提下，无法再多添加一个节点的二叉树<br> <img src="https://images2.imgbox.com/0e/18/M1xArBD3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f8/02/4lQTQYeK_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__62"></a>3. 完全二叉树</h5> 
<p>定义：</p> 
<ul><li>如果只是删除了满二叉树最底层最右边的连续若干节点，这样形成的二叉树<br> <img src="https://images2.imgbox.com/9a/f7/5HGzg1Nr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/19/d0/h1ctTiuy_o.png" alt="在这里插入图片描述"></li></ul> 
<p>性质：</p> 
<ul><li>完全二叉树的一个特例是满二叉树</li></ul> 
<p>目的：</p> 
<ul><li>为了解决树以数组方式的存储问题</li></ul> 
<h4><a id="23__75"></a>2.3 二叉树的性质</h4> 
<h5><a id="231__76"></a>2.3.1 二叉树的常考性质</h5> 
<p><img src="https://images2.imgbox.com/30/ba/z8okyQMM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ea/68/ujXMwmO8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e9/c7/LHT24MHy_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="232__80"></a>2.3.2 完全二叉树的常考性质</h5> 
<p><img src="https://images2.imgbox.com/af/7d/cHFAdW9e_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e9/0d/oDIfl6E6_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__84"></a>3. 森林</h3> 
<p>定义：n(n≥0)个互不相交的树的集合<br> <img src="https://images2.imgbox.com/16/a5/PAwPrMVq_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__88"></a>四. 树的存储</h2> 
<h3><a id="1__89"></a>1. 来源</h3> 
<ul><li>由于内存是一个线性一维的，想要用线性结构存储非线性结构比较困难</li><li>所以我们学习树这种存储，就是为了学会如何将树这种类型的数据结构存储到计算机上面</li></ul> 
<p>树的存储最核心的是：以二叉树存储<br> 二叉树的算法比较成熟：<br> 所以<br> <img src="https://images2.imgbox.com/ac/00/kzRkj8qa_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__98"></a>2. 二叉树的存储</h3> 
<h4><a id="21__99"></a>2.1 连续存储（必须转化为完全二叉树）</h4> 
<p>1）想要将一般的二叉树以数组方式存储的话，必须先将一般二叉树转化为完全二叉树再存储<br> <img src="https://images2.imgbox.com/7f/59/8TFFjdpA_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/08/cc/FG3Wc2eL_o.png" alt="在这里插入图片描述"><br> 为什么要添加无效节点（0表示空节点）？</p> 
<ul><li>因为若只存储有效节点，不添加额外无用的节点，就无法确定以前的树的构造形态（也就是无法还原树的形态）</li></ul> 
<p>存储有效节点方式？</p> 
<ul><li>因为树是非线性结构，而内存是线性结构来存储，所有只有将非线性结构转化为线性结构</li><li>所有人们造出了三种规定：先序、中序、后序遍历来转化为三种不同的线性结构。但若一个二叉树只存放有效节点，无论以哪一种遍历方式转化的线性结构来存储都无法还原到原来的二叉树形态（tip：这里系统一般只存储一种遍历方式，与后面已知两种遍历方式推出二叉树结构不同）</li></ul> 
<p>2）以完全二叉树来存储优缺点<br> 优点：</p> 
<ul><li>知道了节点的个数就知道这棵树有几层</li><li>已知任何一个节点，就可知道它的父节点是谁，它的子节点是谁，以及它有没有子节点</li></ul> 
<p>缺点：</p> 
<ul><li>耗费内存</li></ul> 
<h4><a id="22__119"></a>2.2 链式存储</h4> 
<h5><a id="221__120"></a>2.2.1 二叉树链式存储结构描述</h5> 
<p><img src="https://images2.imgbox.com/5d/50/MgFRABIK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8d/f6/MaiGDf4r_o.png" alt="在这里插入图片描述"><br> 节点结构包含3个域：数据域 data、左指针域 lchild、右指针域 rchild</p> 
<p><img src="https://images2.imgbox.com/61/ef/ABKbSLGF_o.png" alt="在这里插入图片描述"><br> 二叉树链式存储的优缺点：<br> 缺点：</p> 
<ul><li>浪费一点空间，即空指针域</li><li><font color="red"> 在含有n个节点的二叉链表中，含有n+1个空链域</font></li></ul> 
<p>优点：</p> 
<ul><li>求子节点很方便</li><li>空间利用率高</li><li>解决了在计算机中存储非连续结构的二叉树（通过用指针域链成一个有层次的树）</li></ul> 
<h3><a id="3__136"></a>3. 一般树的存储（用线性来存储非线性结构方法）</h3> 
<h4><a id="31__137"></a>3.1 双亲表示法（求父节点方便）</h4> 
<p><img src="https://images2.imgbox.com/6e/bb/9rCfFkpk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ed/5e/4t8j6q3J_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="32__141"></a>3.2 孩子表示法（求子节点方便）</h4> 
<p><img src="https://images2.imgbox.com/a2/e0/SfD3NXOI_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/41/05/etwrbrEO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="33__147"></a>3.3 双亲孩子表示法（求父节点和子节点都很方便）</h4> 
<p><img src="https://images2.imgbox.com/93/63/Q9QTt41L_o.png" alt="在这里插入图片描述"></p> 
<ul><li>操作较为复杂</li><li>不能使用子节点下标，必须使用子节点指针域</li><li>子节点可能为多个，也可能没有</li></ul> 
<h4><a id="34__154"></a>3.4 孩子兄弟表示法（二叉树表示法）</h4> 
<p><strong>把一个普通树转化成二叉树来存储具体转化方法：</strong></p> 
<ul><li>设法保证任意一个节点的：左指针域指向它的第一个孩子、右指针域指向它的第一个兄弟</li></ul> 
<p>只要能满足此条件，就可以把一个普通树转化为二叉树</p> 
<p><img src="https://images2.imgbox.com/60/c9/rfbHj2Fb_o.png" alt="在这里插入图片描述"><br> tip：一个普通树转化成的二叉树，一定没有右子树</p> 
<p><img src="https://images2.imgbox.com/aa/01/74VBWJeJ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__165"></a>4. 森林的存储</h3> 
<h4><a id="41__166"></a>4.1 森林转化为二叉树</h4> 
<p><img src="https://images2.imgbox.com/c9/a9/wExrXO01_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="42__169"></a>4.2 存储方法</h4> 
<p>先把森林转化为二叉树，再去存储二叉树</p> 
<h4><a id="43__172"></a>4.3 转化方法</h4> 
<p>把B和G当做A的兄弟，再用一般树转化为二叉树方法即可</p> 
<h2><a id="__175"></a>五. 树的操作</h2> 
<p>人类造出三种规则：先序、中序、后序这三种遍历，都可以把一个非线性的树转化成一个线性序列</p> 
<p>这样方便可以在我们硬件上存储（因为现实中很多问题是非线性的，但硬件的内存条存储是线性的，故想要在内存上存储必须先线性化）</p> 
<h3><a id="1__180"></a>1. 二叉树的遍历</h3> 
<h4><a id="11__181"></a>1.1 先序遍历（先访问根节点）</h4> 
<ul><li>先访问根节点</li><li>再先序访问左子树</li><li>再先序访问右子树</li></ul> 
<p>本质：递归访问</p> 
<p><img src="https://images2.imgbox.com/23/32/ko8B4sFO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="12__192"></a>1.2 中序遍历（中间访问根节点）</h4> 
<ul><li>中序遍历左子树</li><li>再访问根节点</li><li>再中序遍历右子树</li></ul> 
<p><img src="https://images2.imgbox.com/91/7d/cq0l8tes_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="13__200"></a>1.3 后序遍历（最后访问根节点）</h4> 
<ul><li>后序遍历左子树</li><li>后序遍历右子树</li><li>再访问根节点</li></ul> 
<p><img src="https://images2.imgbox.com/4a/c8/0rQgMpia_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><font color="red">三种遍历算法的总结：</font></p> 
<ul><li>递归遍历左右子树顺序是固定的，只是访问根的顺序不同。</li><li>时间复杂度O(n)：因为不管采用哪种遍历算法，每个节点都访问一次</li><li>空间复杂度：为递归工作栈的深度 = 树的深度，所以最坏情况下，二叉树n个节点的深度为n的单分支，那么空间复杂度为O(n)</li></ul> 
<h4><a id="14__213"></a>1.4 层次遍历</h4> 
<p>按照1,2,3,4的层次顺序，对二叉树中的各个结点进行访问<br> <img src="https://images2.imgbox.com/4b/8d/t2yPlpFY_o.png" alt="在这里插入图片描述"></p> 
<p>层次遍历需要借助一个队列</p> 
<ul><li>先将根节点入队、再出队、再访问出队元素</li><li>若有左子树，将左子树根节点入队、在出队、再访问出队元素</li><li>若也有右子树，将右子树根节点入队、在出队、再访问出队元素</li><li>…直到队列为空</li></ul> 
<h4><a id="15__223"></a>1.5 已知两种遍历序列求原始二叉树</h4> 
<p>若我们已知一课二叉树的先序、中序、后序中的任何一种，都不能把原始二叉树给还原出来。</p> 
<p>我们只有通过（<strong>先序和中序</strong>） 或 （<strong>中序和后序</strong>）可以还原出原始的二叉树，但是通过先序和后序是无法还原出原始的二叉树的。</p> 
<p><strong>1）已知先序和中序求后序</strong><br> <img src="https://images2.imgbox.com/5f/74/cvHB1XFT_o.png" alt="在这里插入图片描述"><br> 解释：<br> 先看先序，第一个出现A即为根节点<br> 然后看中序，找A的位置，来确定左、右子树</p> 
<ul><li>那么BDCE为左子树、FHG为右子树，但又不知道哪个是根，不知道左边第一个写啥</li><li>所以再看先序中BDCE哪个先出现，哪个就是根，可见B先出现为根，再看中序，再来确定B为根的话，那他两边左、右子树又是谁？</li><li>有因为B只有右边有数，可见B没有左子树，只有右子树DCE，再同理，继续确定B左子树的根</li></ul> 
<p><font color="red">先序找根，中序找左右子树</font></p> 
<p><strong>2）已知中序和后序求先序</strong><br> <img src="https://images2.imgbox.com/d7/7e/rtE7bI4C_o.png" alt="在这里插入图片描述"><br> 解释一下：<br> 先看后序最后出现是根节点A<br> 再看中序可知左、右子树，想确定左、右子树的根节点</p> 
<ul><li>所以看后序中左、右子树对应部分中哪个最后出现则为根</li></ul> 
<p>同理，再确定左、右子树</p> 
<p><strong>3）总结：</strong></p> 
<p>已知（<strong>中序+后序</strong>）或（<strong>中序+前序</strong>）或（<strong>中序+层序</strong>）可得一颗二叉树</p> 
<ul><li>其中中序只能确定大体的某根节点左右两侧节点的大致情况，除非左右两侧只有一个节点，否则不好确定左右两侧节点位置</li><li>通过：后/前/层序来确定每一个具体的根节点的位置</li></ul> 
<h3><a id="2__255"></a>2. 森林的遍历</h3> 
<h4><a id="21__256"></a>2.1 先序遍历森林</h4> 
<h4><a id="22__257"></a>2.2 中序遍历森林</h4> 
<h2><a id="__259"></a>六. 树与二叉树的应用</h2> 
<h3><a id="1__260"></a>1. 树是数据库中数据组织的一种重要形式</h3> 
<h3><a id="2__261"></a>2. 操作系统子父进程关系本身就是一棵树</h3> 
<h3><a id="3__262"></a>3. 面向对象语言中类的继承关系本身就是一棵树</h3> 
<h3><a id="4__264"></a>4. 线索二叉树</h3> 
<h4><a id="41__265"></a>4.1 线索二叉树的基本概念</h4> 
<p>1）线索二叉树的来源</p> 
<ul><li>传统的二叉树找前驱、后继很不方便，遍历操作必须从根开始</li><li>传统二叉链表只能体现父子关系，不能得到遍历中的节点的前驱和后继节点</li><li>且传统的含有n个节点的二叉链表有n+1个空指针</li><li>因此想利用这些空指针来存放指向前驱或后继的指针</li></ul> 
<p>2）引入线索二叉树的目的：</p> 
<ul><li>加快查找前驱节点和后继节点的速度</li></ul> 
<p>3）线索二叉树的节点结构<br> <img src="https://images2.imgbox.com/33/96/H7g9ytaB_o.png" alt="在这里插入图片描述"> <img src="https://images2.imgbox.com/55/9f/Zfj9wIcw_o.png" alt="在这里插入图片描述"></p> 
<ul><li>规定：若无左子树，令lchild指向其前驱节点；若无右子树，令rchild指向其后继节点，标志域指示节点的指向。</li></ul> 
<p>4）线索二叉树的存储结构<br> <img src="https://images2.imgbox.com/bf/26/leIQe87P_o.png" alt="在这里插入图片描述"></p> 
<p>5）线索二叉树的分类</p> 
<ul><li>中序线索二叉树：按照中序遍历进行线索化</li><li>先序线索二叉树：按照先序遍历进行线索化</li><li>后序线索二叉树：按照后序遍历进行线索化</li></ul> 
<h4><a id="42__288"></a>4.2 二叉树的基本操作</h4> 
<h5><a id="421__290"></a>4.2.1 二叉树的线索化构造</h5> 
<p>定义：</p> 
<ul><li>将原始二叉链表中的空指针改为指向前驱或后继的线索。（由于想知道前驱和后继的信息，必须遍历一遍二叉树）。所以线索化的本质：遍历一次二叉树</li></ul> 
<p><strong>一、中序线索二叉树</strong></p> 
<p>1）定义：</p> 
<ul><li>按照二叉树中序遍历序列画线索</li></ul> 
<p>2）构造中序线索二叉树<br> <img src="https://images2.imgbox.com/1f/d0/PkxVH5sC_o.png" alt="在这里插入图片描述"></p> 
<p>3）中序线索二叉树的存储</p> 
<p><img src="https://images2.imgbox.com/52/ee/dVckmzuM_o.png" alt="在这里插入图片描述"></p> 
<p><strong>二、先序线索二叉树</strong></p> 
<p>1）定义：</p> 
<ul><li>按照先序序列，依次判断每个节点左右链域，若为空则将其改造为线索</li></ul> 
<p>2）构造先序线索二叉树<br> <img src="https://images2.imgbox.com/89/6e/gDVCLoXm_o.png" alt="在这里插入图片描述"></p> 
<p>3）先序线索二叉树的存储<br> <img src="https://images2.imgbox.com/b3/70/TF1zrlnu_o.png" alt="在这里插入图片描述"></p> 
<p><strong>三、后序线索二叉树</strong></p> 
<p>1）定义：</p> 
<ul><li>按照后序序列，依次判断每个节点左右链域，若为空则将其改造为线索</li></ul> 
<p>2）构造后序线索二叉树<br> <img src="https://images2.imgbox.com/be/d1/i6f1pUK0_o.png" alt="在这里插入图片描述"></p> 
<p>3）后序线索二叉树的存储<br> <img src="https://images2.imgbox.com/73/a8/HL3lsCdk_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="422__329"></a>4.2.2 线索二叉树找前驱/后继</h5> 
<p><img src="https://images2.imgbox.com/c5/17/dZOMr4yU_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7__333"></a>7. 哈夫曼树（最优二叉树）</h3> 
<h4><a id="71__334"></a>7.1 基本概念</h4> 
<h5><a id="711__335"></a>7.1.1 节点的权、带权路径长度</h5> 
<p><img src="https://images2.imgbox.com/e5/16/6BgCNL7R_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="712__337"></a>7.1.2 哈夫曼树的定义</h5> 
<p><img src="https://images2.imgbox.com/65/e7/AiDwtLCQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="72__340"></a>7.2 哈夫曼树的构造</h4> 
<p><img src="https://images2.imgbox.com/db/dd/PzygYDyf_o.png" alt="在这里插入图片描述"><br> tip</p> 
<ul><li>左右孩子节点的顺序是任意的，所有构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优</li><li>但建议每一层编号按从小到大进行排序</li></ul> 
<h4><a id="73__346"></a>7.3 哈夫曼编码</h4> 
<p><img src="https://images2.imgbox.com/0b/60/LAyU2eLZ_o.png" alt="在这里插入图片描述"><br> tip</p> 
<ul><li>利用哈夫曼树可以设计出总长度最短的二进制前缀编码</li><li>0/1究竟是表示左子树还是右子树没有明确规定</li></ul> 
<hr> 
<p>参考文献</p> 
<ul><li>郝斌&lt;数据结构&gt;</li><li>王道考研&lt;数据结构&gt;</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3bd20c1fe36727676663c0fc46844d79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sql注入之or 1 = 1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00af2af3150bbae0fe2f103034fca222/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">KNN分类算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>