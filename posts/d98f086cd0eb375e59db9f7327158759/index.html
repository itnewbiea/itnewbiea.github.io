<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenCV入门十：静态图片人脸检测和摄像头人脸检测 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenCV入门十：静态图片人脸检测和摄像头人脸检测" />
<meta property="og:description" content="主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好
void CascadeClassifier::detectMultiScale(InputArray image, vector&lt;Rect&gt;&amp; objects, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size()) 总共有7个参数，分别是
第一个参数image: 要检测的图片，一般为灰度图
第二个参数objects: Rect型的容器，存放所有检测出的人脸，每个人脸是一个矩形
第三个参数scaleFactor: 缩放因子，对图片进行缩放，默认为1.1
第四个参数minNeighbors： 最小邻居数，默认为3
第五个参数flags: 兼容老版本的一个参数，在3.0版本中没用处。默认为0
第六个参数minSize: 最小尺寸，检测出的人脸最小尺寸
第七个参数maxSize： 最大尺寸，检测出的人脸最大尺寸
（1）静态图片上的人脸检测
#include &#34;opencv2/core/core.hpp&#34; #include &#34;opencv2/objdetect/objdetect.hpp&#34; #include &#34;opencv2/highgui/highgui.hpp&#34; #include &#34;opencv2/imgproc/imgproc.hpp&#34; #include &lt;iostream&gt; #include &lt;stdio.h&gt; using namespace std; using namespace cv; string face_cascade_name = &#34;D:\\Program Files\\opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_default.xml&#34;; CascadeClassifier face_cascade; void detectAndDisplay( Mat frame ); int main( int argc, char** argv ){ Mat image; image =imread(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d98f086cd0eb375e59db9f7327158759/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-29T22:10:41+08:00" />
<meta property="article:modified_time" content="2017-03-29T22:10:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenCV入门十：静态图片人脸检测和摄像头人脸检测</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好</p> 
<p>    </p> 
<pre class="has"><code class="language-cpp">void CascadeClassifier::detectMultiScale(InputArray image, vector&lt;Rect&gt;&amp; objects, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size())</code></pre> 
<p> </p> 
<p> </p> 
<p style="margin-left:10px;">总共有7个参数，分别是</p> 
<p style="margin-left:10px;">第一个参数image:  要检测的图片，一般为灰度图</p> 
<p style="margin-left:10px;">第二个参数objects:  Rect型的容器，存放所有检测出的人脸，每个人脸是一个矩形</p> 
<p style="margin-left:10px;">第三个参数scaleFactor:  缩放因子，对图片进行缩放，默认为1.1</p> 
<p style="margin-left:10px;">第四个参数minNeighbors： 最小邻居数，默认为3</p> 
<p style="margin-left:10px;">第五个参数flags:  兼容老版本的一个参数，在3.0版本中没用处。默认为0</p> 
<p style="margin-left:10px;">第六个参数minSize: 最小尺寸，检测出的人脸最小尺寸</p> 
<p style="margin-left:10px;">第七个参数maxSize： 最大尺寸，检测出的人脸最大尺寸</p> 
<p> </p> 
<p>（1）静态图片上的人脸检测</p> 
<p> </p> 
<p> </p> 
<pre class="has"><code class="language-cpp">
#include "opencv2/core/core.hpp" 
#include "opencv2/objdetect/objdetect.hpp" 
#include "opencv2/highgui/highgui.hpp" 
#include "opencv2/imgproc/imgproc.hpp" 

#include &lt;iostream&gt; 
#include &lt;stdio.h&gt; 

using namespace std; 
using namespace cv; 
string face_cascade_name = "D:\\Program Files\\opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_default.xml"; 

CascadeClassifier face_cascade; 
void detectAndDisplay( Mat frame ); 
int main( int argc, char** argv ){ 
	Mat image; 
	image =imread("E:/snsd.jpg",1);  //当前工程的image目录下的mm.jpg文件，注意目录符号
	if( !face_cascade.load( face_cascade_name ) ){  
		cout&lt;&lt;"xml文件加载失败"&lt;&lt;endl; 
		return -1;  
	} 
	detectAndDisplay(image); //调用人脸检测函数
	waitKey(0);  
} 

void detectAndDisplay( Mat face ){ 
	std::vector&lt;Rect&gt; faces; 
	Mat face_gray; 

	cvtColor( face, face_gray, CV_BGR2GRAY );  
	equalizeHist( face_gray, face_gray );   

	face_cascade.detectMultiScale( face_gray, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(1, 1) ); 

	for( int i = 0; i &lt; faces.size(); i++ ){ 
		Point center( faces[i].x + faces[i].width*0.5, faces[i].y + faces[i].height*0.5 ); 
		ellipse( face, center, Size( faces[i].width*0.5, faces[i].height*0.5), 0, 0, 360, Scalar( 255, 0, 0), 2,7, 0 ); 
	} 

	imshow("静态图片人脸识别", face ); 
} </code></pre> 
<p>或者</p> 
<p> </p> 
<p> </p> 
<pre class="has"><code class="language-cpp">
#include "opencv2\opencv.hpp"
#include &lt;iostream&gt;
using namespace std;
using namespace cv;

int main()
{
	string xmlPath="D:\\Program Files\\opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_default.xml"; 
	CascadeClassifier ccf;   //创建分类器对象
	Mat img=imread("E:/snsd.jpg");   
	if(!ccf.load(xmlPath))   //加载训练文件
	{
		cout&lt;&lt;"不能加载指定的xml文件"&lt;&lt;endl;
		return 0;
	}
	vector&lt;Rect&gt; faces;  //创建一个容器保存检测出来的脸
	Mat gray;
	cvtColor(img,gray,CV_BGR2GRAY); //转换成灰度图，因为harr特征从灰度图中提取
	equalizeHist(gray,gray);  //直方图均衡行
	ccf.detectMultiScale(gray,faces,1.1,3,0,Size(10,10),Size(100,100)); //检测人脸
	for(vector&lt;Rect&gt;::const_iterator iter=faces.begin();iter!=faces.end();iter++)
	{
		rectangle(img,*iter,Scalar(0,0,255),2,8); //画出脸部矩形
	}
	imshow("faces",img);
	waitKey(0);
	return 1;
}</code></pre> 
<p><br> 结果</p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/00/3b/9aPfAsBq_o.jpg"><br>  </p> 
<p>可以看出，有些人脸没有检测出来，或者是检测出来有位置错误。</p> 
<p>（2）摄像头人脸检测</p> 
<p> </p> 
<pre class="has"><code class="language-cpp">#include "opencv2/objdetect/objdetect.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

//命名空间
using namespace std;
using namespace cv;

//函数声明
void detectAndDisplay( Mat frame );

//全局变量
//-- Note, either copy these two files from opencv/data/haarscascades to your current folder, or change these locations
string face_cascade_name = "D:\\Program Files\\opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_alt.xml";
string eyes_cascade_name = "D:\\Program Files\\opencv\\sources\\data\\haarcascades\\haarcascade_eye_tree_eyeglasses.xml";
CascadeClassifier face_cascade;
CascadeClassifier eyes_cascade;
string window_name = "Capture - Face detection";
RNG rng(12345);

int main( void )
{
	CvCapture* capture;
	Mat frame;

	//-- 1. Load the cascades
	if( !face_cascade.load( face_cascade_name ) ){ printf("--(!)Error loading\n"); return -1; };
	if( !eyes_cascade.load( eyes_cascade_name ) ){ printf("--(!)Error loading\n"); return -1; };

	//-- 2. Read the video stream
	capture = cvCaptureFromCAM( 0);
	if( capture )
	{
		for(;;)
		{
			frame = cvQueryFrame( capture );

			//-- 3. Apply the classifier to the frame
			if( !frame.empty() )
			{ detectAndDisplay( frame ); }
			else
			{ printf(" --(!) No captured frame -- Break!"); break; }

			int c = waitKey(10);
			if( (char)c == 'c' ) { break; }

		}
	}
	return 0;
}

void detectAndDisplay( Mat frame )
{
	std::vector&lt;Rect&gt; faces;
	Mat frame_gray;

	cvtColor( frame, frame_gray, CV_BGR2GRAY );
	equalizeHist( frame_gray, frame_gray );
	//-- Detect faces
	face_cascade.detectMultiScale( frame_gray, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30) );

	for( size_t i = 0; i &lt; faces.size(); i++ )
	{
		Point center( faces[i].x + faces[i].width/2, faces[i].y + faces[i].height/2 );
		ellipse( frame, center, Size( faces[i].width/2, faces[i].height/2), 0, 0, 360, Scalar( 255, 0, 255 ), 2, 8, 0 );

		Mat faceROI = frame_gray( faces[i] );
		std::vector&lt;Rect&gt; eyes;

		//-- In each face, detect eyes
		eyes_cascade.detectMultiScale( faceROI, eyes, 1.1, 2, 0 |CV_HAAR_SCALE_IMAGE, Size(30, 30) );

		for( size_t j = 0; j &lt; eyes.size(); j++ )
		{
			Point eye_center( faces[i].x + eyes[j].x + eyes[j].width/2, faces[i].y + eyes[j].y + eyes[j].height/2 );
			int radius = cvRound( (eyes[j].width + eyes[j].height)*0.25 );
			circle( frame, eye_center, radius, Scalar( 255, 0, 0 ), 3, 8, 0 );
		}
	}
	//-- Show what you got
	imshow( window_name, frame );
}
</code></pre> 
<p><br> 结果</p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/92/ea/ry9xeVOn_o.jpg"></p> 
<p>如果您觉得这篇博文有用，请访问我的个人站：<a href="http://www.stubbornhuang.com" rel="nofollow">http://www.stubbornhuang.com</a>，更多博文干货等着您。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43c602aac3bd093033605d7c3db66828/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity中不用自带重力实现跳跃的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35e68ff36037e0817bcb4270d647d87a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux下还原oracle数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>