<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android的碎片fragment和activity之前的关系 以及MVP模式详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android的碎片fragment和activity之前的关系 以及MVP模式详解" />
<meta property="og:description" content="参考原文：https://www.jianshu.com/p/bbb3b77d47eb
GoogleMVP机制：https://blog.csdn.net/jungle_pig/article/details/65626469
1、activity与fragment传值
当activity动态加载fragment时可以通过fragment的setArguments()传入值；
在fragment类中通过fragment的getArguments()方法获得传入的值 ；
MVP结构图：
参考原文：https://blog.csdn.net/swust_zeng_zhuo_k/article/details/78760947 创建MVP模式是需要经过一下几个步骤： 1、创建IPresenter接口，把所有的业务逻辑的接口搜放在这里，并创建他的实现PresenterImpl, 2、创建IView接口，把所有的视图逻辑的接口都放在这里，其实现类是Activity/Fragment 3、由UML试图可以看出，Activity包含了一个IPresenter，而PresenterImpl包含了IVew并依赖了Model, Activity只保留了对IPresenter的调用，其他的都放在PresenterImpl中实现， 4、model并不是必须有的，但是一定会有Presenter和View 注意：虚线三角箭头：实现；虚线箭头：依赖； 实线三角：关联
Google提出的一种MVP实现方式，步骤：
1.BasePresenter
2.BaseView
两个接口分别作为Presenter和View的基类，仅定义了最基本的方法，具体页面的view和presenter则分别定义继承的接口，添加属于自己页面的方法。
3.Contract 契约类
这是Google MVP与其他实现方式的不同之一，契约类用于定义同一个界面的view和presenter的接口，通过规范的方法命名或注释，可以清晰的看到整个页面的逻辑。
4.具体的Impl类
Fragment实现View接口，这里使用Google推荐的创建Fragment实例的static方法newInstance()，将fragment必备的参数传入。
Presenter实现类，提供一个参数为对应View的构造器，持有View的引用，并调用View的setPresenter()方法，让View也持有Presenter的引用，方便View调用Presenter的方法。
5.最后就是Activity
创建view以及presenter实例，并将二者联系起来。
下图是Google官方Demo：todo-mvp模式的架构图" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3a8e7c5fdff10ba98a82dbed45d73f41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-25T15:33:11+08:00" />
<meta property="article:modified_time" content="2018-09-25T15:33:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android的碎片fragment和activity之前的关系 以及MVP模式详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考原文：<a href="https://www.jianshu.com/p/bbb3b77d47eb" rel="nofollow">https://www.jianshu.com/p/bbb3b77d47eb</a></p> 
<p>GoogleMVP机制：<a href="https://blog.csdn.net/jungle_pig/article/details/65626469">https://blog.csdn.net/jungle_pig/article/details/65626469</a></p> 
<p>1、activity与fragment传值</p> 
<p>当activity动态加载fragment时可以通过fragment的setArguments()传入值；</p> 
<p>在fragment类中通过fragment的getArguments()方法获得传入的值 ；</p> 
<p>MVP结构图：</p> 
<p><img alt="" class="has" height="349" src="https://images2.imgbox.com/ad/04/TFdidB7E_o.png" width="521"></p> 
<pre class="has"><code class="language-html">参考原文：https://blog.csdn.net/swust_zeng_zhuo_k/article/details/78760947
 创建MVP模式是需要经过一下几个步骤：
 1、创建IPresenter接口，把所有的业务逻辑的接口搜放在这里，并创建他的实现PresenterImpl,
 2、创建IView接口，把所有的视图逻辑的接口都放在这里，其实现类是Activity/Fragment
 3、由UML试图可以看出，Activity包含了一个IPresenter，而PresenterImpl包含了IVew并依赖了Model,
     Activity只保留了对IPresenter的调用，其他的都放在PresenterImpl中实现，
 4、model并不是必须有的，但是一定会有Presenter和View
 </code></pre> 
<p>注意：虚线三角箭头<img alt="" class="has" height="21" src="https://images2.imgbox.com/d4/70/lqpDos6P_o.png" width="23">：实现；虚线箭头<img alt="" class="has" height="15" src="https://images2.imgbox.com/dd/33/lzLJXT4k_o.png" width="24">：依赖； 实线三角<img alt="" class="has" height="18" src="https://images2.imgbox.com/b3/2a/EL53UOz2_o.png" width="23">：关联</p> 
<p> </p> 
<p>Google提出的一种MVP实现方式，步骤：</p> 
<p>1.BasePresenter</p> 
<p><img alt="" class="has" height="64" src="https://images2.imgbox.com/5e/08/aQxoh4Bf_o.png" width="236"></p> 
<p>2.BaseView</p> 
<p><img alt="" class="has" height="58" src="https://images2.imgbox.com/29/1d/NIr8ZT9z_o.png" width="396"></p> 
<p>两个接口分别作为Presenter和View的基类，仅定义了最基本的方法，具体页面的view和presenter则分别定义继承的接口，添加属于自己页面的方法。</p> 
<p>3.Contract 契约类</p> 
<p>这是Google MVP与其他实现方式的不同之一，契约类用于定义同一个界面的view和presenter的接口，通过规范的方法命名或注释，可以清晰的看到整个页面的逻辑。</p> 
<p><img alt="" class="has" height="419" src="https://images2.imgbox.com/db/8b/8ti5XQEv_o.png" width="450"></p> 
<p>4.具体的Impl类</p> 
<p>Fragment实现View接口，这里使用Google推荐的创建Fragment实例的static方法newInstance()，将fragment必备的参数传入。</p> 
<p> </p> 
<p>Presenter实现类，提供一个参数为对应View的构造器，持有View的引用，并调用View的setPresenter()方法，让View也持有Presenter的引用，方便View调用Presenter的方法。</p> 
<p><img alt="" class="has" height="229" src="https://images2.imgbox.com/b6/fb/U6t4CEHn_o.png" width="529"></p> 
<p>5.最后就是Activity</p> 
<p>创建view以及presenter实例，并将二者联系起来。</p> 
<p><img alt="" class="has" height="484" src="https://images2.imgbox.com/68/f8/yOuqlugG_o.png" width="620"></p> 
<p> <strong>下图是Google官方Demo：todo-mvp模式的架构图</strong></p> 
<p><img alt="" class="has" height="570" src="https://images2.imgbox.com/e5/88/0MYdpZna_o.png" width="666"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/853c5145860529591f98e9bba60c765b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Visual Studio 2017安装时共享组件、工具和 SDK安装位置不能更改的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a5d7e8f20d409266eb0e3e0f23bce87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;基础之string类型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>