<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Reactor 第九篇 WebFlux重构个人中心，效果显著 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Reactor 第九篇 WebFlux重构个人中心，效果显著" />
<meta property="og:description" content="1 重构背景 原有的开发人员早已离职，代码细节没人知道，经过了一段时间的维护，发现有以下问题：
个人中心系统的特征就是组装各个业务的接口，输出个人中心业务需要的数据，整个系统调用了几十个第三方业务线的接口，如果编排不合理，可能会导致响应时间急剧上涨，尤其是弹窗业务，新的弹窗会不断接入，整个接口可能会不可用。
2 整体架构 service：是最小的业务编排单元，request方法对infrastructure第三方接口进行编排调用；apply 方法对第三方接口调用的结果进行组装，结果是service的业务返回；
infrastructure：是对第三方的异步非阻塞调用，不包含业务逻辑。一个service内部根据实际业务可以编排0个或者多个infrastructure服务。
在实际优化过程中我们抽象了30多个infrastructure第三方调用，40多个service。他们都是小而且独立的类，减轻了开发同学尤其是新同学熟悉的成本。边界也比较清晰，逻辑内聚。
2 编排举例 每个 service 内部都是由一个或者多个 infrastructure 第三方调用组装编排的业务单元，内部处理能异步处理的全是使用异步处理，实在不能异步处理的使用串行&#43;并行的方式。
2.1 串行 需要串行的可以使用 flatMap 方法，可以参考以下格式。
这种方式会执行S1，然后S2。
伪代码如下：
Mono.from(service1.func()) .flatMap(service1Res-&gt; { return service2.func(); }) 2.2 并行 zip 和 zipWith，zipWith一次组装一个Mono，zip 一次可以组装多个Mono。
示例代码如下：
service1.zipWith(service2) Mono.zip(service1, service2, service3) 一个使用 zip 组装多个service的示例代码，并行执行service1, service2, …, service6，使用doOnError处理错误，onErrorReturn 处理异常返回，doOnFinally 监控整个接口调用量、耗时情况。
Mono.zip(service1, service2, service3, service4, service5, service6) .map(t -&gt; { String service1Ret = t.getT1(); String service2Ret = t.getT2(); // .... return &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fbeb181613a8adf735af30af4a4e2388/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-04T11:51:03+08:00" />
<meta property="article:modified_time" content="2023-05-04T11:51:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Reactor 第九篇 WebFlux重构个人中心，效果显著</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1 重构背景</h3> 
<p>原有的开发人员早已离职，代码细节没人知道，经过了一段时间的维护，发现有以下问题：</p> 
<p><img src="https://images2.imgbox.com/70/2f/x92mJ9oF_o.png" alt=""></p> 
<p>个人中心系统的特征就是组装各个业务的接口，输出个人中心业务需要的数据，整个系统调用了几十个第三方业务线的接口，如果编排不合理，可能会导致响应时间急剧上涨，尤其是弹窗业务，新的弹窗会不断接入，整个接口可能会不可用。</p> 
<h3><a id="2__8"></a>2 整体架构</h3> 
<p><img src="https://images2.imgbox.com/17/85/fzLzT9lT_o.png" alt=""></p> 
<p>service：是最小的业务编排单元，request方法对infrastructure第三方接口进行编排调用；apply 方法对第三方接口调用的结果进行组装，结果是service的业务返回；</p> 
<p>infrastructure：是对第三方的异步非阻塞调用，不包含业务逻辑。一个service内部根据实际业务可以编排0个或者多个infrastructure服务。</p> 
<p>在实际优化过程中我们抽象了30多个infrastructure第三方调用，40多个service。他们都是小而且独立的类，减轻了开发同学尤其是新同学熟悉的成本。边界也比较清晰，逻辑内聚。</p> 
<h3><a id="2__18"></a>2 编排举例</h3> 
<p>每个 service 内部都是由一个或者多个 infrastructure 第三方调用组装编排的业务单元，内部处理能异步处理的全是使用异步处理，实在不能异步处理的使用串行+并行的方式。</p> 
<h4><a id="21__24"></a>2.1 串行</h4> 
<p>需要串行的可以使用 flatMap 方法，可以参考以下格式。</p> 
<p>这种方式会执行S1，然后S2。</p> 
<p><img src="https://images2.imgbox.com/9f/56/cGKF4urf_o.png" alt=""></p> 
<p>伪代码如下：</p> 
<pre><code class="prism language-java"><span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>service1<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>service1Res<span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">return</span> service2<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="22__41"></a>2.2 并行</h4> 
<p>zip 和 zipWith，zipWith一次组装一个Mono，zip 一次可以组装多个Mono。</p> 
<p><img src="https://images2.imgbox.com/07/b1/hW0yTP1D_o.png" alt=""></p> 
<p>示例代码如下：</p> 
<pre><code class="prism language-java">service1<span class="token punctuation">.</span><span class="token function">zipWith</span><span class="token punctuation">(</span>service2<span class="token punctuation">)</span>

<span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">zip</span><span class="token punctuation">(</span>service1<span class="token punctuation">,</span> service2<span class="token punctuation">,</span> service3<span class="token punctuation">)</span>
</code></pre> 
<p>一个使用 zip 组装多个service的示例代码，并行执行service1, service2, …, service6，使用doOnError处理错误，onErrorReturn 处理异常返回，doOnFinally 监控整个接口调用量、耗时情况。</p> 
<pre><code class="prism language-java"><span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">zip</span><span class="token punctuation">(</span>service1<span class="token punctuation">,</span> service2<span class="token punctuation">,</span> service3<span class="token punctuation">,</span> service4<span class="token punctuation">,</span> service5<span class="token punctuation">,</span> service6<span class="token punctuation">)</span>
				<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
					<span class="token class-name">String</span> service1Ret <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getT1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token class-name">String</span> service2Ret <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getT2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// ....</span>
					<span class="token keyword">return</span> <span class="token string">"组合结果"</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment">// 异常返回</span>
				<span class="token punctuation">.</span><span class="token function">onErrorReturn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">DTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">.</span><span class="token function">doOnError</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 异常详情日志；异常请求量监控</span>
				<span class="token punctuation">}</span><span class="token punctuation">)</span>
				<span class="token punctuation">.</span><span class="token function">doFinally</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 请求量、耗时监控</span>
				<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="23__75"></a>2.3 并行-但只取第一个有数据的结果</h4> 
<p>弹窗类业务与一般service不通，它需要调用很多的业务的数据出不同的弹窗，但是每次都只能给用户展示确定的一个。但是如果串行的话，随着上线的弹窗越来越多，整个弹窗接口的耗时会越来越长。</p> 
<p>但是如果改成异步的话，又无法控制弹窗之间的优先级，优先级对于公司整体业务来说是必要的，把重要的业务放在高优的位置上，做到资源最大利用，才能实现利润的最大化，从而做到基业长青。</p> 
<p>Flux 有个flatMapSequential方法，它能完美解决这个问题，看看它的注释：</p> 
<blockquote> 
 <p>Transform the elements emitted by this Flux asynchronously into Publishers, then flatten these inner publishers into a single Flux, but merge them in the order of their source element.</p> 
</blockquote> 
<p>将此Flux发出的元素异步地转换为 publisher，然后将这些内部 publisher 扁平化为单个Flux，但<strong>按照源元素的顺序</strong>合并它们。</p> 
<p><img src="https://images2.imgbox.com/9d/e4/VG23sMPY_o.png" alt=""></p> 
<p>如上图所示，总共有S1、S2、S3、S4按顺序的四个弹窗，会并行执行S1到S4，如果S1和S2没有数据，S3有数据，则会返回S3。</p> 
<p>伪代码如下：</p> 
<pre><code class="prism language-java"><span class="token class-name">Flux</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> monoFlux <span class="token operator">=</span> <span class="token class-name">Flux</span><span class="token punctuation">.</span><span class="token function">fromIterable</span><span class="token punctuation">(</span>serviceList<span class="token punctuation">)</span>
				<span class="token punctuation">.</span><span class="token function">flatMapSequential</span><span class="token punctuation">(</span>serviceName <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
					    
							<span class="token punctuation">}</span><span class="token punctuation">)</span>
							<span class="token punctuation">.</span><span class="token function">onErrorContinue</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                  <span class="token comment">// 某个service异常或者无数据，继续执行</span>
							<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span><span class="token punctuation">)</span>
				<span class="token punctuation">.</span><span class="token function">onErrorContinue</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 服务异常，继续执行</span>
				<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> mono <span class="token operator">=</span> monoFlux<span class="token punctuation">.</span><span class="token function">elementAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
</code></pre> 
<p>这里就是异步执行所有弹窗service，运行过程中某个弹窗异常或者无数据返回，则继续下一个。通过<code>monoFlux.elementAt(0, Maps.newHashMap())</code>获取第一个有数据的弹窗。</p> 
<h3><a id="4__111"></a>4 重构效果</h3> 
<h4><a id="41__113"></a>4.1 后端指标</h4> 
<p>相比于原来的后端系统，所有接口耗时都有大幅度降低，：</p> 
<ul><li>头部身份信息接口响应速度提升：26%。</li><li>卡片各业务线入口接口响应速度提升：87%。</li><li>弹窗和浮标接口响应速度提升：146%。</li></ul> 
<p>经过 flatMapSequential 编排弹窗之后，耗时从220ms，降到160ms，绝对值下降了60ms，下降了 28%；</p> 
<p><img src="https://images2.imgbox.com/a1/3c/90CXrxRs_o.png" alt=""></p> 
<h4><a id="42__126"></a>4.2 新需求开发和维护</h4> 
<p>新需求开发更快，QA 测试更快。</p> 
<p>原来开发一个弹窗，需要考虑的事情很多：</p> 
<ol><li>开发的时候需要考虑代码放在哪个层级上，是否与其他弹窗有耦合，</li><li>弹窗优先级需要通过if-else实现，很容易出错；</li><li>弹窗自测很麻烦，需要注释调其他弹窗；</li><li>QA 需要测试所有弹窗的优先级是否有问题；</li></ol> 
<p>现在开发一个弹窗，只需要增加一个service类，然后把service配置再优先级列表中即可。</p> 
<h4><a id="43__139"></a>4.3 其他</h4> 
<p>框架使用了响应式框架 Spring WebFlux，也支持本地启动，编写了service层和基础设施层的单测case，提升开发效率。</p> 
<p>删除了原来的业务网关层，使用公司层面的网关系统，配置即生效；删除了原来业务网关中的业务逻辑代码，把相关逻辑移动到业务层中，解除了原来的多层之间的耦合关系。</p> 
<p>现在各个service之前相互独立，异常不会相互影响。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f276b95d85dfc6fa95b167d5972aa9eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">html面经——css</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38e9735322d29c60694c5ea4b8ef1b23/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RBAC96 详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>