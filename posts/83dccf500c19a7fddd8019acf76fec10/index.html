<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>插件化基础（一）——加载插件的类 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="插件化基础（一）——加载插件的类" />
<meta property="og:description" content="系列文章目录：
插件化基础（一）——加载插件的类
插件化基础（二）——加载插件资源
插件化基础（三）——启动插件组件
一、插件化概述 1.1 了解插件化 插件化技术最初源于免安装运行 apk 的想法，免安装的 apk 我们称之为插件，支持插件的 app 我们称之为宿主。宿主可以在运行时加载和运行插件，这样便可以将 app 中一些不常用的功能模块做成插件，既减小了安装包的体积，又实现了 app 功能的动态扩展。
插件化解决的问题：
app 的功能模块越来越多，体积越来越大模块之间的耦合度高，协同开发沟通成本越来越大方法数目可能超过 65535，app 占用的内存过大应用之间的互相调用 插件化与组件化的区别：
组件化开发就是将一个 app 分成多个模块，每个模块都是一个组件，开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件统一合并成一个 apk，这就是组件化开发插件化开发和组件化略有不同，插件化开发是将整个 app 拆分成多个模块，这些模块包括一个宿主和多个插件，每个模块都是一个 apk，最终打包的时候宿主 apk 和插件 apk 分开打包 各个插件化框架对比：
插件化成本高，几乎每个源码版本都要适配。
同时，我们需要清楚，反射是插件化的基础，大量使用反射会影响性能，主要是因为：
产生大量的临时对象过程中会进行可见性检查会生成没有优化过的字节码类型转换（基本类型的装箱拆箱） 1.2 插件化的实现思路 想要实现插件化需要解决以下三个问题：
如何加载插件的类？如何加载插件的资源？如何启动插件的四大组件？ 文章也是围绕这三个问题展开的，总体大纲如下：
本篇文章先来看如何加载插件中的类，其实就是各种方式折腾 ClassLoader。
本系列文章所涉及的源码和运行环境默认为 Android 8.0（API 26），部分章节会涉及到对 8.0 以上系统的兼容适配，这部分会特别指出，没特殊说明的就默认为 8.0。
二、Android 的类加载机制 2.1 类的生命周期 先来看类的生命周期：
在加载阶段，虚拟机主要完成三件事：
通过一个类的全类名来获取定义此类的二进制字节流将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构在 Java 堆中生成一个代表这个类的 Class 对象，作为方法区数据的访问入口 2.2 Android 类加载器体系 Android 的类加载器与 Java 的类加载器有不同之处，前者用来加载 dex 文件，后者用来加载 Class 字节码文件。那么 Android 中的类加载器体系是怎样的呢？看下图：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/83dccf500c19a7fddd8019acf76fec10/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-22T17:21:34+08:00" />
<meta property="article:modified_time" content="2023-09-22T17:21:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">插件化基础（一）——加载插件的类</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>系列文章目录：</p> 
<p><a href="https://blog.csdn.net/tmacfrank/article/details/124089765">插件化基础（一）——加载插件的类</a><br> <a href="https://blog.csdn.net/tmacfrank/article/details/124257616">插件化基础（二）——加载插件资源</a><br> <a href="https://blog.csdn.net/tmacfrank/article/details/124346720">插件化基础（三）——启动插件组件</a></p> 
<hr> 
<h2><a id="_9"></a>一、插件化概述</h2> 
<h3><a id="11__11"></a>1.1 了解插件化</h3> 
<p>插件化技术最初源于免安装运行 apk 的想法，免安装的 apk 我们称之为<strong>插件</strong>，支持插件的 app 我们称之为<strong>宿主</strong>。宿主可以在<strong>运行时</strong>加载和运行插件，这样便可以将 app 中一些不常用的功能模块做成插件，既减小了安装包的体积，又实现了 app 功能的动态扩展。</p> 
<p>插件化解决的问题：</p> 
<ol><li>app 的功能模块越来越多，体积越来越大</li><li>模块之间的耦合度高，协同开发沟通成本越来越大</li><li>方法数目可能超过 65535，app 占用的内存过大</li><li>应用之间的互相调用</li></ol> 
<p>插件化与组件化的区别：</p> 
<ul><li>组件化开发就是将一个 app 分成多个模块，每个模块都是一个组件，开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件统一合并成一个 apk，这就是组件化开发</li><li>插件化开发和组件化略有不同，插件化开发是将整个 app 拆分成多个模块，这些模块包括一个宿主和多个插件，每个模块都是一个 apk，最终打包的时候宿主 apk 和插件 apk 分开打包</li></ul> 
<p>各个插件化框架对比：</p> 
<p><img src="https://images2.imgbox.com/9d/b4/zqlNfvvr_o.jpg" alt=""></p> 
<p>插件化成本高，几乎每个源码版本都要适配。</p> 
<p>同时，我们需要清楚，反射是插件化的基础，大量使用反射会影响性能，主要是因为：</p> 
<ol><li>产生大量的临时对象</li><li>过程中会进行可见性检查</li><li>会生成没有优化过的字节码</li><li>类型转换（基本类型的装箱拆箱）</li></ol> 
<h3><a id="12__40"></a>1.2 插件化的实现思路</h3> 
<p>想要实现插件化需要解决以下三个问题：</p> 
<ol><li>如何加载插件的类？</li><li>如何加载插件的资源？</li><li>如何启动插件的四大组件？</li></ol> 
<p>文章也是围绕这三个问题展开的，总体大纲如下：</p> 
<p><img src="https://images2.imgbox.com/cc/83/ot0FubGK_o.png" alt=""></p> 
<p>本篇文章先来看如何加载插件中的类，其实就是各种方式折腾 ClassLoader。</p> 
<blockquote> 
 <p>本系列文章所涉及的源码和运行环境默认为 Android 8.0（API 26），部分章节会涉及到对 8.0 以上系统的兼容适配，这部分会特别指出，没特殊说明的就默认为 8.0。</p> 
</blockquote> 
<h2><a id="Android__56"></a>二、Android 的类加载机制</h2> 
<h3><a id="21__58"></a>2.1 类的生命周期</h3> 
<p>先来看类的生命周期：</p> 
<p><img src="https://images2.imgbox.com/24/bd/ffk5THhq_o.png" alt=""></p> 
<p>在加载阶段，虚拟机主要完成三件事：</p> 
<ol><li>通过一个类的全类名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在 Java 堆中生成一个代表这个类的 Class 对象，作为方法区数据的访问入口</li></ol> 
<h3><a id="22_Android__70"></a>2.2 Android 类加载器体系</h3> 
<p>Android 的类加载器与 Java 的类加载器有不同之处，前者用来加载 dex 文件，后者用来加载 Class 字节码文件。那么 Android 中的类加载器体系是怎样的呢？看下图：</p> 
<p><img src="https://images2.imgbox.com/be/d3/wnFwANCV_o.png" alt=""></p> 
<h4><a id="PathClassLoader__DexClassLoader_76"></a>PathClassLoader 与 DexClassLoader</h4> 
<p>PathClassLoader 和 DexClassLoader 其实非常相似，特别是 8.0 以后，二者的差别微乎其微。它们都可以用来加载 dex（应用内外皆可）/ apk（无论是否安装） 文件，只不过在 8.1 之前，DexClassLoader 的构造方法需要指定由 dex 优化而来的 odex（dex2oat 的产物）目录的路径：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DexClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">BaseDexClassLoader</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// optimizedDirectory 就是优化 dex 所需要的目录</span>
    <span class="token keyword">public</span> <span class="token class-name">DexClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> dexPath<span class="token punctuation">,</span> <span class="token class-name">String</span> optimizedDirectory<span class="token punctuation">,</span>
            <span class="token class-name">String</span> librarySearchPath<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>dexPath<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>optimizedDirectory<span class="token punctuation">)</span><span class="token punctuation">,</span> librarySearchPath<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>而 PathClassLoader 直接用系统指定的路径，不用我们来指定：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PathClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">BaseDexClassLoader</span> <span class="token punctuation">{<!-- --></span>

	<span class="token keyword">public</span> <span class="token class-name">PathClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> dexPath<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>dexPath<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	
	<span class="token keyword">public</span> <span class="token class-name">PathClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> dexPath<span class="token punctuation">,</span> <span class="token class-name">String</span> librarySearchPath<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>dexPath<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> librarySearchPath<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>DexClassLoader 和 PathClassLoader 的全部内容就只是以上的构造方法，它们加载类的逻辑都在父类的 BaseDexClassLoader 中，所以表面上看起来它们的差别就只有 optimizedDirectory 这个参数了。</p> 
</blockquote> 
<p>实际上，在 8.0 的 BaseDexClassLoader 中，就已经不再使用 optimizedDirectory 这个参数了：</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token class-name">BaseDexClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> dexPath<span class="token punctuation">,</span> <span class="token class-name">File</span> optimizedDirectory<span class="token punctuation">,</span>
            <span class="token class-name">String</span> librarySearchPath<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 8.0 中第 4 个传的参数是 null ，在之前传的都是 optimizedDirectory</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pathList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DexPathList</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> dexPath<span class="token punctuation">,</span> librarySearchPath<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>reporter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            reporter<span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>pathList<span class="token punctuation">.</span><span class="token function">getDexPaths</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>只不过在 8.0 上创建 DexClassLoader 时给 optimizedDirectory 传 null 会抛出异常而已，而到了 8.1，DexClassLoader 在构造方法中也直接把第二个参数传了 null：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DexClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">BaseDexClassLoader</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token class-name">DexClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> dexPath<span class="token punctuation">,</span> <span class="token class-name">String</span> optimizedDirectory<span class="token punctuation">,</span>
            <span class="token class-name">String</span> librarySearchPath<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>dexPath<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> librarySearchPath<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>所以综合来看，在 8.0 以上，PathClassLoader 和 DexClassLoader 的区别很小，但是有一点不可忽视，就是 PathClassLoader 被用作系统的类加载器，这里要看一下顶级父类 ClassLoader 的源码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{<!-- --></span>

	<span class="token keyword">static</span> <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SystemClassLoader</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ClassLoader</span> loader <span class="token operator">=</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">createSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// 当前 ClassLoader 对象的父 ClassLoader</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ClassLoader</span> <span class="token function">createSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> classPath <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.class.path"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> librarySearchPath <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.library.path"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 第三个参数，给这个 PathClassLoader 的 parent 指定为 BootClassLoader</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PathClassLoader</span><span class="token punctuation">(</span>classPath<span class="token punctuation">,</span> librarySearchPath<span class="token punctuation">,</span> <span class="token class-name">BootClassLoader</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token keyword">private</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token class-name">Void</span> unused<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token keyword">protected</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token function">checkCreateClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token keyword">protected</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token function">checkCreateClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	
	<span class="token annotation punctuation">@CallerSensitive</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ClassLoader</span> <span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">SystemClassLoader</span><span class="token punctuation">.</span>loader<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>每个 ClassLoader 对象内部都有一个父加载器 parent，这个“父”表示的不是继承关系上的父类子类，而是加载顺序的优先关系，一般都会先让自己的父加载器先执行加载，这一点在下面介绍“双亲委派机制”时会详细说。</p> 
<p>以上源码能清晰的看到两点：</p> 
<ol><li>PathClassLoader 被用作系统的类加载器，保存在 SystemClassLoader 类中，可以通过 getSystemClassLoader() 获取</li><li>该 PathClassLoader 的父加载器 parent 被指定为 BootClassLoader</li></ol> 
<p>也就是说，在 Context 环境下通过 getClassLoader() 得到的是一个 PathClassLoader，且这个 PathClassLoader 的父加载器是 BootClassLoader。</p> 
<p>总结一下 PathClassLoader 和 DexClassLoader 的差别：</p> 
<ol><li>通过构造方法创建两个类加载器对象时，DexClassLoader 需要比 PathClassLoader 多传一个 optimizedDirectory 参数：<br> ① 8.0 之前，必须要给 DexClassLoader 传 optimizedDirectory 参数，否则抛出异常<br> ② 8.0 系统，也是必须要传 optimizedDirectory，但是内部已经不再使用该参数了，无实际意义<br> ③ 8.1 开始，optimizedDirectory 可以传 null，不会抛出异常</li><li>通过构造方法创建两个类加载器对象时，可以在参数中指定它们的父加载器，当然如果没有需要也可以传 null</li><li>系统使用的 PathClassLoader 被指定了一个父加载器 BootClassLoader</li></ol> 
<h4><a id="BootClassLoader_191"></a>BootClassLoader</h4> 
<p>BootClassLoader 是 ClassLoader 的直接子类，其源码就在 ClassLoader.java 中，它是一个单例类并且没有父加载器 parent：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">BootClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">BootClassLoader</span> instance<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@FindBugsSuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">BootClassLoader</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BootClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">BootClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// parent 传 null，即没有父加载器</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>前面提到过，BootClassLoader 是系统的 PathClassLoader 的父加载器，二者加载的类也是不同的：</p> 
<ul><li>PathClassLoader 加载应用中的类（如我们写的 app 中的类，还有第三方依赖库中的类等）</li><li>BootClassLoader 加载 SDK（包括 Framework）的类（如 android.app 包下的 Activity）</li></ul> 
<h3><a id="23__221"></a>2.3 类加载器的使用</h3> 
<p>创建一个 DexClassLoader 对象并调用其 loadClass 方法。</p> 
<p>DexClassLoader 的构造方法需要指定 dex/apk/jar 文件的路径，这里我们以 dex 文件为例。先用 build-tools 下的 dx.bat 工具（\Android\Sdk\build-tools\【build-tools版本】\dx.bat）将 Class 文件打包成 dex 文件：</p> 
<pre><code class="prism language-shell"><span class="token comment"># dx --dex --output=[输出文件名] [输入的Class文件路径，需与包名匹配]</span>
F:<span class="token punctuation">\</span><span class="token punctuation">..</span>.<span class="token punctuation">\</span>build<span class="token punctuation">\</span>intermediates<span class="token punctuation">\</span>javac<span class="token punctuation">\</span>debug<span class="token punctuation">\</span>classes<span class="token operator">&gt;</span>dx <span class="token parameter variable">--dex</span> <span class="token parameter variable">--output</span><span class="token operator">=</span>test.dex com/demo/mylibrary/Test.class
</code></pre> 
<p>运行该命令前需要将工作目录切换到输入文件路径的上一层级，示例命令中就是 com 文件夹的上一层：classes，输出的 test.dex 也就是在 classes 目录下：</p> 
<p><img src="https://images2.imgbox.com/c7/1b/6D5OIxA0_o.png" alt=""></p> 
<p>将 dex 文件存入 /sdcard/ 目录下，通过 ClassLoader 加载该 dex 中的类：</p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里读取文件需要用到 STORAGE 权限，此外第一个参数除了 dex 文件以外也可以是 apk 文件。</span>
        <span class="token comment">// 最后一个参数是指定 dexClassLoader 的 parent，可以是 PathClassLoader，7.0 以上系统也可以是 null</span>
        <span class="token class-name">DexClassLoader</span> dexClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DexClassLoader</span><span class="token punctuation">(</span><span class="token string">"/sdcard/test.dex"</span><span class="token punctuation">,</span>
                <span class="token function">getCacheDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// loadClass() 只能加载指定的 dex 文件中的类，并通过反射调用其中的方法</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> dexClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"com.demo.mylibrary.Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Method</span> method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"printLog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="24__256"></a>2.4 双亲委派机制</h3> 
<h4><a id="_258"></a>源码分析</h4> 
<p>ClassLoader 的 loadClass() 是如何加载一个类的？来看 ClassLoader 源码：</p> 
<pre><code class="prism language-java">	<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
    <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 先检查这个类是否已经加载过</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果没加载过</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    	<span class="token comment">// 如果有 parent，就先委派 parent 调用其 loadClass() 去加载，</span>
                    	<span class="token comment">// 这也就是“双亲委派”这个词的由来</span>
                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    	<span class="token comment">// findBootstrapClassOrNull() 其实就返回 null，因为该方法在</span>
                    	<span class="token comment">// ClassLoader 类中返回 null，且所有子类没有重写该方法</span>
                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token punctuation">}</span>

			   <span class="token comment">// 如果 parent 也没找到，才自己去查找</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>过程是：</p> 
<ol><li>先检查 name 表示的类是否已经被加载过，如果已经加载了，直接获取并返回</li><li>如果没有被加载过，且 parent 不为 null，就先让 parent 去加载，如果 parent 没加载到这个类才自己去加载</li></ol> 
<p>回看 Android 类加载器的体系图，BaseDexClassLoader 及其子类 DexClassLoader、PathClassLoader 都没有重写 ClassLoader 中的 loadClass()，也就是说它们都用的是这种加载机制。这种先由父加载器去加载一个类的机制被称为<strong>双亲委派机制</strong>。</p> 
<p>注意 ClassLoader 另一个子类 BootClassLoader 因为没有父加载器，所以加载过程略有不同：</p> 
<pre><code class="prism language-java">	<span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
           <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 检查是否已经加载过 className 表示的类</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 如果没加载过，直接由自己去查找</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            clazz <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>总体来说，类加载的流程图：</p> 
<p><img src="https://images2.imgbox.com/c6/f9/s9CYJ7f6_o.png" alt=""></p> 
<p>假如一个 DexClassLoader 在创建时指定系统的 PathClassLoader 为其 parent，又由于系统的 PathClassLoader 的 parent 为 BootClassLoader，所以整个双亲委派加载类的示意图如下（当然 DexClassLoader 也可以指定非系统的 PathClassLoader 为 parent，只要再额外指定这个 PathClassLoader 的 parent 为 BootClassLoader 也能构造出下图的关系）：</p> 
<p><img src="https://images2.imgbox.com/a9/b0/i1m0Jehq_o.png" alt=""></p> 
<h4><a id="_326"></a>使用双亲委派机制的原因</h4> 
<p>原因有二：</p> 
<ol><li>避免重复加载，当父加载器已经加载了该类的时候，就没有必要让子加载器再加载一次</li><li>安全性考虑，防止核心 API 库被随意篡改（保证系统类都是由系统的类加载器加载的）</li></ol> 
<p>关于第二点，稍微解释一下。比如像 Activity、String 这样系统中的类，开发者是不能自己创建一个包名与类名相同的类去让系统加载以达到篡改系统代码的目的，因为系统类会先由系统的 ClassLoader 加载，并且加载过的类不会再次加载。</p> 
<h3><a id="25__335"></a>2.5 类的加载</h3> 
<p>最终执行类加载的还是 ClassLoader 中的 findClass 方法，我们需要了解体系中各个 findClass() 都是如何执行的。</p> 
<p>基类 ClassLoader 的 findClass() 会直接抛异常，等待子类的重写：</p> 
<pre><code class="prism language-java">	<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>BootClassLoader 会调用 Class 类的 native 方法去加载：</p> 
<pre><code class="prism language-java">	<span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">classForName</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>而 BaseDexClassLoader 会执行 DexPathList 的同名方法，如果没找到会抛出 ClassNotFoundException：</p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">DexPathList</span> pathList<span class="token punctuation">;</span>
	
	<span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> suppressedExceptions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Class</span> c <span class="token operator">=</span> pathList<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> suppressedExceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">ClassNotFoundException</span> cnfe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>
                    <span class="token string">"Didn't find class \""</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"\" on path: "</span> <span class="token operator">+</span> pathList<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t <span class="token operator">:</span> suppressedExceptions<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                cnfe<span class="token punctuation">.</span><span class="token function">addSuppressed</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">throw</span> cnfe<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>DexPathList 会遍历 dexElements 集合：</p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> <span class="token class-name">Element</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dexElements<span class="token punctuation">;</span>
	
	<span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> suppressed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Element</span> element <span class="token operator">:</span> dexElements<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 去 Element 中查找类</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> definingContext<span class="token punctuation">,</span> suppressed<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>dexElementsSuppressedExceptions <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            suppressed<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>dexElementsSuppressedExceptions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>其实 dexElements 中的元素 Element 表示的就是 dex 文件，或者是包含 dex 文件的 jar 包，我们可以通过将插件 apk 添加到 dexElements 中的方式实现插件类的加载。</p> 
<p>这样类加载的流程就说完了，最后再总结一下吧：</p> 
<p><img src="https://images2.imgbox.com/1b/67/6glbA1rh_o.png" alt="在这里插入图片描述"></p> 
<p>过程概述：</p> 
<ol><li>DexClassLoader/PathClassLoader 调用 loadClass() 进行类加载</li><li>直接进入父类 ClassLoader 的 loadClass()，开启“三步走”流程（对应 ClassLoader 触发的 1、2、3 号方法）</li><li>执行 ClassLoader 的 1 号方法 findLoadedClass() 看看待加载类是否已经被加载过，最终会调用到 VMClassLoader 的 native 方法，如果被加载过就直接返回给调用者 DexClassLoader/PathClassLoader</li><li>如果第 3 步没找到，就执行 ClassLoader 的 2 号方法，调用父类 BootClassLoader 的 loadClass()，如果加载到就返回给调用者</li><li>如果第 4 步没找到，就调用自己的 findClass() 去加载，拿到 DexPathList 中的 dexElements 集合，遍历其中的 Element 元素，执行 loadClassBinaryName()，如果没找到就抛出 ClassNotFoundException</li></ol> 
<h2><a id="_412"></a>三、加载插件中的类</h2> 
<p>有两种方案可以加载插件中的类：单 ClassLoader 和多 ClassLoader：</p> 
<ul><li>单 ClassLoader：将插件 ClassLoader 中的 pathList 字段合并到宿主的 ClassLoader 中，宿主与插件之间可以直接互相调用类和方法</li><li>多 ClassLoader：为每个插件都生成一个 ClassLoader，加载插件中的类时要使用对应的 ClassLoader</li></ul> 
<h3><a id="31__ClassLoader_419"></a>3.1 单 ClassLoader</h3> 
<p>灵感来自于【2.5 类的加载】，Element[] dexElements 包含了 app 中所有的 class 文件，想办法将插件的 dexElements 与宿主的 dexElements 合并后再设置给宿主即可。</p> 
<p>代码实现：</p> 
<pre><code class="prism language-java">	<span class="token comment">/**
     * 思路是将插件的 dexElements 与宿主的 dexElements 合并形成一个新的 
     * dexElements，再设置给宿主，这样宿主再通过 ClassLoader 加载时就可
     * 以加载插件中的类了。
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadPluginClass</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 1.获取宿主的 dexElements</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"dalvik.system.BaseDexClassLoader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Field</span> pathListField <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"pathList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathListField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> dexPathListClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"dalvik.system.DexPathList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Field</span> dexElements <span class="token operator">=</span> dexPathListClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"dexElements"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            dexElements<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		   <span class="token comment">// 拿到系统使用的那个 PathClassLoader 的 dexElements</span>
            <span class="token class-name">ClassLoader</span> pathClassLoader <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Object</span> dexPathList <span class="token operator">=</span> pathListField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pathClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hostElements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dexElements<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>dexPathList<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 2.获取插件的 dexElements</span>
            <span class="token class-name">DexClassLoader</span> dexClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DexClassLoader</span><span class="token punctuation">(</span><span class="token constant">PLUGIN_APK_PATH</span><span class="token punctuation">,</span>
                    context<span class="token punctuation">.</span><span class="token function">getCacheDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> pathClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Object</span> pluginPathList <span class="token operator">=</span> pathListField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>dexClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pluginElements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dexElements<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pluginPathList<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 3.合并到新的 Element[] 中，先创建一个新数组</span>
            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>hostElements<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    hostElements<span class="token punctuation">.</span>length <span class="token operator">+</span> pluginElements<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 宿主的 dexElements 放在插件的 dexElements 之前，而热修复时就刚好相反了</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>hostElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> hostElements<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>pluginElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> hostElements<span class="token punctuation">.</span>length<span class="token punctuation">,</span> pluginElements<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 4.赋值</span>
            dexElements<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>dexPathList<span class="token punctuation">,</span> newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>这种方式的优点是，宿主与插件之间可以直接互相调用类和方法，还可以将多个插件的公共模块抽取到一个 common 插件中供其它插件使用。</p> 
<p>缺点也很明显，不同插件引用同一个库的不同版本时，可能会导致程序出错，需要进行特殊处理规避：</p> 
<p><img src="https://images2.imgbox.com/db/71/1wilbjKr_o.png" alt=""></p> 
<p>以上图为例，宿主和插件的 AppCompat 的版本不同，由于这个包中的类是系统的 PathClassLoader 进行加载的，那么一定是先加载了宿主的，而由于双亲委托机制的存在，已经加载过的类不会重复加载，导致插件中的 AppCompat 的类就不会加载，那么调用到 v1.0 与 v2.0 的差异代码时，就可能出现问题。</p> 
<p>此外，当插件数量过多时，会造成宿主的 dexElements 数组体积增大。</p> 
<h3><a id="32__ClassLoader_478"></a>3.2 多 ClassLoader</h3> 
<p>为每个插件都生成一个 ClassLoader，加载插件中的类时要使用对应的 ClassLoader 对象，这样可以使不同插件的类隔离，当不同插件引用同一个类库的不同版本时，不会发生问题。参考代码如下：</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token class-name">DexClassLoader</span> <span class="token function">getPluginClassLoader</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">,</span> <span class="token class-name">String</span> pluginPath<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">TextUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>pluginPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"插件路径不能拿为空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">File</span> pluginFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>pluginPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pluginFile<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Log</span><span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token constant">TAG</span><span class="token punctuation">,</span> <span class="token string">"插件文件不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">File</span> optDir <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getDir</span><span class="token punctuation">(</span><span class="token string">"optDir"</span><span class="token punctuation">,</span> <span class="token class-name">Context</span><span class="token punctuation">.</span><span class="token constant">MODE_PRIVATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DexClassLoader</span><span class="token punctuation">(</span>pluginPath<span class="token punctuation">,</span> optDir<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9b17cfedd796aecca4736e37f65482d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue new Date() 转换为年月日时分秒以及星期几(padStart补零) - 附完整示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/97ae4ed4682cc26d5b997d02d8e71ebc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是Apollo自动驾驶平台？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>