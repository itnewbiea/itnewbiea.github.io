<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux系统php源码包安装教程,Linux软件源码包的安装（Tarball的安装） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux系统php源码包安装教程,Linux软件源码包的安装（Tarball的安装）" />
<meta property="og:description" content="软件源码包安装背景
接触过Linux的人都知道要在Linux上安装软件通常使用rpm或yum，这两种工具的出现确实大大减少我们在Linux系统上安装软件的工作量，但是rpm及yum的安装的软件都是基于某种平台事先编译好的成品，这个成品中制作者考虑种种因素可能会对这个软件的功能进行一定程度的剪裁，也就是说现成的rpm包或yum包不是最全的软件包。而如果我们想要添加这个软件的rpm或yum中未包含的功能该怎么办？为了解决这个问题，我们就要使用软件源码包进行安装。
什么是软件源码包？
Linux软件的源代码分发是指提供了该软件所有程序源代码的发布形式，需要用户自己编译成可执行的二进制码并进行安装。其优点是配置灵活，可以随意去掉或保留某些功能/模
块，适应多种硬件/操作系统平台及编译环境；缺点是难度较大，一般不适合初学者使用
源码包格式有两种：
1．*.src.rpm形式的源代码软件包
2．*.tar.gz/*.xz/*.bz2形式的源代码软件包
软件源码包的安装
1．*.src.rpm形式的源代码软件包
(该类型由于还是以rpm功能实现的软件安装，这里只是简单介绍下其方法，具体如何实验就不再演示。)
假设此*.src.rpm文件在/usr/local/src下，在该目录下执行rpmbuild --rebuild *.src.rpm，若命令顺利执行则会在/usr/src/dist/RPMS下出现*.rpm
大致过程如下：
安装：
rpm -rebuild *.src.rpm(会自动根据所在平台转换成相应的平台rpm包)
cd /usr/src/dist/RPMS
rpm -ivh *.rpm
卸载：
rpm -e packagename
2．*.tar.gz/*.xz/*.bz2形式的源代码软件包
以tar.gz或tgz或tar.bz2等格式结尾的软件包一般都是以源代码方式发布的软件，安装这类软件首先需要对软件进行解压：
# tar -zxvf filename.tar.gz
# tar -Jxvf filename.tar.xz
# tar -jxvf filename.tar.bz2
解压以后，就可以进入解压后的目录：
# cd filename/
对于这类文档，常见的安装步骤是：配置、编译和安装3步，其中最麻烦的就是配置，因为所有和软件安装相关的配置都是在这一步指定的：比如软件安装位置等。
配置：./configure
编译：make
安装：make install
卸载：make uninstall 或手动删除
说明：建议解压后先阅读说明文件(ReadMe和Install)，了解安装的需求，有必要时还需改动编译配置。有些软件包的源代码在编译安装后可以用make uninstall命令来进行卸载，如果不提供此功能，则软件的卸载必须手动进行。由于软件可能将文件分散地安装在系统的多个目录中，往往很难把它删除干净，那你应该在编译前进行配置，指定软件将要安装到目标路径：./configure --prefix=目录名，这样可以使用“rm -rf 软件目录名”命令来进行干净彻底的卸载。
Tarball形式的源代码软件包安装实验详解
该实验以httpd-2.2.29.tar.bz2为例进行实验
实验环境
实验准备：
1、确认httpd-2.2.29.tar.bz2已下载，通常会把源码包保存在/usr/local/src路径下
2、确认make工具存在,rpm -q make检查即可，若不存在安装之。
3、为确保编译环境没有问题，我们最好使用yum groupinstall &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6e83e0c2124cbf36f8e047b0346a0161/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-04T08:43:52+08:00" />
<meta property="article:modified_time" content="2021-04-04T08:43:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux系统php源码包安装教程,Linux软件源码包的安装（Tarball的安装）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>软件源码包安装背景</p> 
 <p>接触过Linux的人都知道要在Linux上安装软件通常使用rpm或yum，这两种工具的出现确实大大减少我们在Linux系统上安装软件的工作量，但是rpm及yum的安装的软件都是基于某种平台事先编译好的成品，这个成品中制作者考虑种种因素可能会对这个软件的功能进行一定程度的剪裁，也就是说现成的rpm包或yum包不是最全的软件包。而如果我们想要添加这个软件的rpm或yum中未包含的功能该怎么办？为了解决这个问题，我们就要使用软件源码包进行安装。</p> 
 <p>什么是软件源码包？</p> 
 <p>Linux软件的源代码分发是指提供了该软件所有程序源代码的发布形式，需要用户自己编译成可执行的二进制码并进行安装。其优点是配置灵活，可以随意去掉或保留某些功能/模</p> 
 <p>块，适应多种硬件/操作系统平台及编译环境；缺点是难度较大，一般不适合初学者使用</p> 
 <p>源码包格式有两种：</p> 
 <p>1．*.src.rpm形式的源代码软件包</p> 
 <p>2．*.tar.gz/*.xz/*.bz2形式的源代码软件包</p> 
 <p>软件源码包的安装</p> 
 <p>1．*.src.rpm形式的源代码软件包</p> 
 <p>(该类型由于还是以rpm功能实现的软件安装，这里只是简单介绍下其方法，具体如何实验就不再演示。)</p> 
 <p>假设此*.src.rpm文件在/usr/local/src下，在该目录下执行rpmbuild --rebuild  *.src.rpm，若命令顺利执行则会在/usr/src/dist/RPMS下出现*.rpm</p> 
 <p>大致过程如下：</p> 
 <p>安装：</p> 
 <p>rpm -rebuild *.src.rpm(会自动根据所在平台转换成相应的平台rpm包)</p> 
 <p>cd /usr/src/dist/RPMS</p> 
 <p>rpm -ivh *.rpm</p> 
 <p>卸载：</p> 
 <p>rpm -e packagename</p> 
 <p>2．*.tar.gz/*.xz/*.bz2形式的源代码软件包</p> 
 <p>以tar.gz或tgz或tar.bz2等格式结尾的软件包一般都是以源代码方式发布的软件，安装这类软件首先需要对软件进行解压：</p> 
 <p># tar -zxvf filename.tar.gz</p> 
 <p># tar -Jxvf filename.tar.xz</p> 
 <p># tar -jxvf filename.tar.bz2</p> 
 <p>解压以后，就可以进入解压后的目录：</p> 
 <p># cd filename/</p> 
 <p>对于这类文档，常见的安装步骤是：配置、编译和安装3步，其中最麻烦的就是配置，因为所有和软件安装相关的配置都是在这一步指定的：比如软件安装位置等。</p> 
 <p>配置：./configure</p> 
 <p>编译：make</p> 
 <p>安装：make install</p> 
 <p>卸载：make uninstall 或手动删除</p> 
 <p>说明：建议解压后先阅读说明文件(ReadMe和Install)，了解安装的需求，有必要时还需改动编译配置。有些软件包的源代码在编译安装后可以用make uninstall命令来进行卸载，如果不提供此功能，则软件的卸载必须手动进行。由于软件可能将文件分散地安装在系统的多个目录中，往往很难把它删除干净，那你应该在编译前进行配置，指定软件将要安装到目标路径：./configure --prefix=目录名，这样可以使用“rm -rf 软件目录名”命令来进行干净彻底的卸载。</p> 
 <p>Tarball形式的源代码软件包安装实验详解</p> 
 <p>该实验以httpd-2.2.29.tar.bz2为例进行实验</p> 
 <p>实验环境</p> 
 <p>实验准备：</p> 
 <p>1、确认httpd-2.2.29.tar.bz2已下载，通常会把源码包保存在/usr/local/src路径下</p> 
 <p>2、确认make工具存在,rpm -q make检查即可，若不存在安装之。</p> 
 <p>3、为确保编译环境没有问题，我们最好使用yum groupinstall "Development Tools"将开发环境部署好，新手建议安装Development Tools，不过事实上该包的安装只需要gcc这个组件系统中存在即可，因此也可以只进行yum install gcc。至于yum仓库如何设置本文在此不介绍。</p> 
 <p align="center"><img src="https://images2.imgbox.com/95/12/hEHn2iJd_o.gif" alt="73e2c57cc917a025318d750a28b8e768.gif"></p> 
 <p>……………………………………………………………………………………………………………………</p> 
 <p>实验步骤：</p> 
 <p>1、解压httpd-2.2.29.tar.bz2，查看源文件夹的文件及其个数。</p> 
 <p align="center"><img src="https://images2.imgbox.com/39/5f/h2HmCiPt_o.gif" alt="f24994cc96107b0e3b0ecbb5b2caea50.gif"></p> 
 <p>刚加压过的httpd-2.2.29有40个文件。</p> 
 <p>2、我们先看看INSTALL、README文件</p> 
 <p align="center"><img src="https://images2.imgbox.com/53/00/LDQqkWLB_o.gif" alt="1e9cf49e84f789d62655383ee4d414f5.gif"></p> 
 <p>该文件主要介绍此源码包的安装步骤</p> 
 <p align="center"><img src="https://images2.imgbox.com/02/be/8ONKpmg7_o.gif" alt="cd8f4515bfdf0f81192c8e716e9150e4.gif"></p> 
 <p>该文件主要介绍个这个软件，是什么，作用，功能等信息。</p> 
 <p>3、./configure --help查看配置的使用帮助信息</p> 
 <p>这里面的信息涉及软件安装位置，配置文件存放位置等等。根据需要进行选择，这里面比INSTALL安装文件要全。</p> 
 <p align="center"><img src="https://images2.imgbox.com/e3/4c/TX0S5UwY_o.gif" alt="6e7fe639110ccad4cfe3b7c1e690cb35.gif"></p> 
 <p>4、设置软件安装路径为/usr/local/apache2，配置文件路径为/etc/apache2，因为是实验这里就不再指定其他额外设置。现实工作中根据实际情况进行选择。</p> 
 <p>等待几分钟，环境检测结束。</p> 
 <p align="center"><img src="https://images2.imgbox.com/f1/4b/CNoyoFs9_o.gif" alt="4b53b7e8d952728b6c6ee4189772887d.gif"></p> 
 <p>首先我们echo $?可以知道第一步的命令成功执行，在命令成功执行后，源文件多了5个文件分别为：config.log、config.nice、config.status、Makefile、modules.c</p> 
 <p>以.c结尾的为原始码，config.log是在检测过程中产生的日志，config.nice与config.status均为检测后产生的成功及状态信息。</p> 
 <p>其中Makefile对于下一步的编译至关重要，它里面包含了编译工作的预设行为，(比如程序之间的链接顺序，哪个先执行哪个后执行)make的编译过程就是按照Makefile文件进行的。</p> 
 <p align="center"><img src="https://images2.imgbox.com/e3/d9/eglmC13Q_o.gif" alt="fa7d1dbcb0decca23cb3d91210c59b38.gif"></p> 
 <p>以上为截取的Makefile文件的部分内容。</p> 
 <p>5、编译，以 make 这个程序并使用该目录下的 Makefile 做为他的参数配置文件，来进行 make (编译或其他)的动作。</p> 
 <p>直接键入make命令即可，等待几分钟直至编译结束。</p> 
 <p align="center"><img src="https://images2.imgbox.com/50/b4/LHNZhttc_o.gif" alt="978b767556b22a1b5638b9510744f70e.gif"></p> 
 <p>这步进行结束后，又多了4个文件modules.lo、modules.o、httpd、buildmark.o。</p> 
 <p>以.lo或.o结束的文件是源码经gcc编译后产生的目标文件。</p> 
 <p>httpd这个文件的作用是为产生httpd的链接库的暂时性脚本，其英文解释如下图。</p> 
 <p align="center"><img src="https://images2.imgbox.com/42/ae/hhFNYJMi_o.gif" alt="914062827a848c5a2a013feb8ecc753f.gif"></p> 
 <p>6、make install 这就是最后的安装步骤了，make 会依据 Makefile 这个档案里面关亍 install 的项目，将上一个步骤所编译完成的数据给他安装到预定的目录中。</p> 
 <p>安装到这里源码包安装已经结束，只不过现在还有些问题：1)我们无法man apachectl这个命令；2)apachectl这个命令没法使用tab补全。怎么办？</p> 
 <p>看来我们虽然安装了，但是做的还不够完善。</p> 
 <p>下面我们来解决上面的两个问题。</p> 
 <p>安装后的配置</p> 
 <p>先按我们指定的安装路径找到已安装的软件</p> 
 <p align="center"><img src="https://images2.imgbox.com/51/1e/ZCd0qlDN_o.gif" alt="b745ae8d4637ed495e3ea140d5c3b9b1.gif"></p> 
 <p>要解决man问题，我们需要将该软件中的man目录及其所在路径加入/etc/man_db.conf文件。</p> 
 <p>1、man apachectl问题</p> 
 <p>编辑/etc/man_db.conf，并将软件man目录的路径加入该文件。</p> 
 <p align="center"><img src="https://images2.imgbox.com/96/a2/fa09578m_o.gif" alt="d8e36552ddf58e9ee50c3ad87b9f14b0.gif"></p> 
 <p>之后我们需要重读/etc/man_db.conf文件</p> 
 <p>source /etc/man_db.conf即可</p> 
 <p>之后man apachectl成功显示其帮助文档。</p> 
 <p>2、解决tab补全命令问题</p> 
 <p>编辑文件/etc/profile.d/NAME.sh</p> 
 <p>在此文件中添加如下内容export PATH=$PATH:/PATH/TO/BIN/</p> 
 <p align="center"><img src="https://images2.imgbox.com/e3/f6/tITU8GjU_o.gif" alt="440ec3d68b3616ca2b784730fcec8427.gif"></p> 
 <p>之后重读此文件即可解决tab补全命令问题。</p> 
 <p>看样子，我们的安装到此已经圆满结束，不过还有一点的小缺憾，不过对于现在这种实验环境确实无关紧要，如果是在实际工作中，我们还要考虑库文件，及头文件问题。因为实际工作中这个服务并不是以个体出现的而是与很多服务协同工作，因此免不了会涉及开发问题，及函数库读取效能问题。</p> 
 <p>有关开发的配置</p> 
 <p>如何提升函数库读取效能？</p> 
 <p>将常用的动态函数库先加载至内存当中可以解决函数库读取效能问题，不过如何将其加载到内存中？这两步就涉及到ldconfig命令及/etc/ld.so.conf.d/目录</p> 
 <p>编辑/etc/ld.so.conf.d/NAME.conf，将需要模块的库文件所在目录添加至此文件中，之后让系统重新生成缓存，使用ldconfig命令即可。</p> 
 <p>对于开发人员他们会用到各种各样的头文件，系统为了方便期间会将头文件统一到一个目录便于程序员调用，这个目录一般为/usr/include</p> 
 <p>所以为了今后开发方便，我们还会将软件的头文件夹给映射至该目录</p> 
 <p align="center"><img src="https://images2.imgbox.com/8e/c8/fZL2GyLj_o.gif" alt="311f57728a5b294937cc580d2c12f05a.gif"></p> 
 <p>源码包的安装至此已经结束，整个安装过程，其实只要前期准备完善，制定好相应的安装策略，比如安装路径，配置文件路径等问题，整个安装过程其实挺简单。</p> 
 <p align="center"><img src="https://images2.imgbox.com/1c/d5/5BUI0ZS2_o.png" alt="0b1331709591d260c1c78e86d0c51c18.png"></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e852f91f5e97fae0b93fbdbe7b366c63/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTTP状态 500 - 内部服务器错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d5c57ffa6ccc349b95c7dc878cc0169/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">arcgis oracle srid,查询oracle srid 对应的EPSG代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>