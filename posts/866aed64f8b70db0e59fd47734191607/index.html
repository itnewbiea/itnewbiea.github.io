<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring 6（二）【IOC原理】 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring 6（二）【IOC原理】" />
<meta property="og:description" content="前言 IOC 是Spring的两大核心概念之一，它是一种思想，需要极其熟练的掌握。
今日摘录：
低能无聊的人太多。说他们勤勉，不过是因困为不会合理分配时间；说他们积极，不过是逃避其他困难工作而已。即便说工作只是生存手段，也没见他们有什么拿得出手的爱好或特长。我真是每天都在失望。低能无聊的人要是边不满边骂着自己的低能无聊却不愿做出任何改变，那就真是自寻烦恼自掘坟墓了。
——东野圭吾《变身》
1、IOC IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。
1.1、控制反转 控制反转不是技术，而是一种思想。
控制反转是为了降低程序耦合度，提高程序扩展力。
控制反转，反转的是什么？
将对象的创建权利交出去，交给第三方容器（IOC 容器）负责。
将对象和对象之间关系的维护权交出去，交给第三方容器负责。
控制反转这种思想如何实现呢？
DI（Dependency Injection）：依赖注入
依赖注入（DI）：
指Spring创建对象的过程中，将对象依赖属性通过配置进行注入
依赖注入常见的实现方式包括两种：
第一种：set注入
第二种：构造器注入
所以，IOC 就是一种控制反转的思想， 而 DI 是对 IOC的一种具体实现。
1.2、获取 Bean 的 3 种方式 其实也就是 getBean() 的三种传参方式，下面对我们上一节的 User 类进行测试。
&lt;bean id=&#34;user&#34; class=&#34;com.lyh.study.User&#34;/&gt; 1.2.1、getBean（String id） 因为返回的是一个 Object 类型所以需要强转一下。 @Test public void testHelloWorld1(){ ApplicationContext ac = new ClassPathXmlApplicationContext(&#34;beans.xml&#34;); User user = (User)ac.getBean(&#34;user&#34;); user.add(); } 1.2.2、 getBean（Class&lt;? extends Object&gt; requiredType） 因为传入的就是一个类，所以可以自动推断出返回的类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/866aed64f8b70db0e59fd47734191607/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-17T15:09:29+08:00" />
<meta property="article:modified_time" content="2023-12-17T15:09:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring 6（二）【IOC原理】</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>        IOC 是Spring的两大核心概念之一，它是一种思想，需要极其熟练的掌握。</p> 
<p>今日摘录：</p> 
<blockquote> 
 <p>低能无聊的人太多。说他们勤勉，不过是因困为不会合理分配时间；说他们积极，不过是逃避其他困难工作而已。即便说工作只是生存手段，也没见他们有什么拿得出手的爱好或特长。我真是每天都在失望。低能无聊的人要是边不满边骂着自己的低能无聊却不愿做出任何改变，那就真是自寻烦恼自掘坟墓了。</p> 
 <p>——东野圭吾《变身》</p> 
</blockquote> 
<h2>1、IOC</h2> 
<p>IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。</p> 
<h3>1.1、控制反转</h3> 
<ul><li> <p>控制反转不是技术，而是一种思想。</p> </li><li> <p>控制反转是为了降低程序耦合度，提高程序扩展力。</p> </li><li> <p>控制反转，反转的是什么？</p> 
  <ul><li> <p>将对象的创建权利交出去，交给第三方容器（IOC 容器）负责。</p> </li><li> <p>将对象和对象之间关系的维护权交出去，交给第三方容器负责。</p> </li></ul></li><li> <p>控制反转这种思想如何实现呢？</p> 
  <ul><li> <p>DI（Dependency Injection）：依赖注入</p> </li></ul></li></ul> 
<p><strong>依赖注入（DI）：</strong></p> 
<ul><li> <p><strong>指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</strong></p> </li></ul> 
<p>依赖注入常见的实现方式包括两种：</p> 
<ul><li> <p>第一种：set注入</p> </li><li> <p>第二种：构造器注入</p> </li></ul> 
<p>所以，IOC 就是一种控制反转的思想， 而 DI 是对 IOC的一种具体实现。</p> 
<h3>1.2、获取 Bean 的 3 种方式</h3> 
<p>其实也就是 getBean() 的三种传参方式，下面对我们上一节的 User 类进行测试。</p> 
<pre><code class="language-XML">&lt;bean id="user" class="com.lyh.study.User"/&gt;</code></pre> 
<h4>1.2.1、getBean（String id）</h4> 
<div>
  因为返回的是一个 Object 类型所以需要强转一下。 
</div> 
<pre><code class="language-java">@Test
public void testHelloWorld1(){
	ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
    User user = (User)ac.getBean("user");
    user.add();
}</code></pre> 
<h4>1.2.2、 getBean（Class&lt;? extends Object&gt;  requiredType）</h4> 
<p>因为传入的就是一个类，所以可以自动推断出返回的类型。</p> 
<p><span style="color:#fe2c24;">注意</span>：这种方式的配置文件中属于该类（com.lyh.study.User）的 bean 只能有一个，这个很好理解，如果有多个，它怎么知道你到底要取哪一个 bean。</p> 
<pre><code class="language-java">@Test
public void testHelloWorld1(){
	ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
    User user = ac.getBean(User.class);
    user.add();
}</code></pre> 
<h4>1.2.3、getBean（String id，Class&lt;? extends Object&gt;  requiredType）</h4> 
<p>这种方式同样指定了 bean 的类型，所以返回的直接就是该类型的 bean 对象。</p> 
<pre><code class="language-java">@Test
public void testHelloWorld1(){
	ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
    User user = ac.getBean("user",User.class);
    user.add();
}</code></pre> 
<p>个人建议使用这种方式，不用咱们自己强转，代码看起来也比较直观。 </p> 
<h3>1.3、依赖注入的 2 种方式</h3> 
<h4> 1.3.1、setter 注入</h4> 
<p>（1）创建 bean 目录，编写 Student 类：</p> 
<pre><code class="language-java">package com.lyh.study.bean;

public class Student {

    private Integer id;

    private String name;

    private Integer age;

    private String sex;

    public Student() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", sex='" + sex + '\'' +
                '}';
    }

}
</code></pre> 
<p>注意：这里的 Bean 必须有 setter 方法，否则属性无法注入（idea 直接就会在配置文件中爆红）；如果不设置 getter 方法，我们的私有属性无法获取（被public 修饰的属性可以通过 对象.属性（比如 student1.id） 直接获取，但是被 private 修饰的属性必须通过显示的方法（比如 student1.getId()）来获取）。</p> 
<p>（2）配置 bean 时给属性赋值：</p> 
<pre><code class="language-XML">&lt;bean id="student1" class="com.lyh.study.bean.Student"&gt;
        &lt;property name="id" value="1001"/&gt;
        &lt;property name="name" value="lyh"/&gt;
        &lt;property name="age" value="20"/&gt;
        &lt;property name="sex" value="男"/&gt;
    &lt;/bean&gt;</code></pre> 
<p>（3）测试：</p> 
<pre><code class="language-java">    @Test
    public void testStudent(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
        Student student1 = ac.getBean("student1", Student.class);
        System.out.println(student1);
    }</code></pre> 
<p>（4）运行结果：</p> 
<pre><code class="language-java">Student{id=1001, name='lyh', age=20, sex='男'}</code></pre> 
<h4>1.3.2、构造器注入</h4> 
<p>（1）在我们的 JavaBean 中添加有参构造器：</p> 
<pre><code class="language-java">public Student(Integer id, String name, Integer age, String sex) {
    this.id = id;
    this.name = name;
    this.age = age;
    this.sex = sex;
}</code></pre> 
<p>（2）配置 bean </p> 
<p>默认是按照我们构造器的顺序直接赋值：</p> 
<pre><code class="language-XML">&lt;bean id="student2" class="com.lyh.study.bean.Student"&gt;
        &lt;constructor-arg value="1002"/&gt;
        &lt;constructor-arg value="燕双鹰"/&gt;
        &lt;constructor-arg value="28"/&gt;
        &lt;constructor-arg value="男"/&gt;
    &lt;/bean&gt;</code></pre> 
<p>也可以通过属性来指定属性的顺序：</p> 
<ul><li>index 属性：从 0 开始（分别对应 id、name、age、sex）</li><li>name 属性：直接指定参数名，然后通过 value 赋值</li></ul> 
<p>（3）测试</p> 
<pre><code class="language-java">    @Test
    public void testStudent(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
        Student student2 = ac.getBean("student2", Student.class);
        System.out.println(student2);
    }</code></pre> 
<p>（4）运行结果：</p> 
<pre><code class="language-java">Student{id=1002, name='燕双鹰', age=28, sex='男'}</code></pre> 
<h3>1.4、给对象类型的属性注入的 3 种方式</h3> 
<p>给 Student 类添加一个 Address 类型的属性：</p> 
<p>（1）创建 Address 类</p> 
<pre><code class="language-java">package com.lyh.study.bean;

public class Address {
    private String province;
    private String county;
    private String village;

    public Address(){
    }

    public Address(String province, String county, String village) {
        this.province = province;
        this.county = county;
        this.village = village;
    }

    public String getProvince() {
        return province;
    }

    public void setProvince(String province) {
        this.province = province;
    }

    public String getCounty() {
        return county;
    }

    public void setCounty(String county) {
        this.county = county;
    }

    public String getVillage() {
        return village;
    }

    public void setVillage(String village) {
        this.village = village;
    }

    @Override
    public String toString() {
        return "Address{" +
                "province='" + province + '\'' +
                ", county='" + county + '\'' +
                ", village='" + village + '\'' +
                '}';
    }
}
</code></pre> 
<p>完了给我们的 Student 类添加一个 Adress 类型的属性，并设置 getter 和 setter 方法。 </p> 
<h4>1.4.1、外部引用 Bean</h4> 
<p>第一种方式：我们通过外部 Bean 引用来给我们的属性赋值：</p> 
<p>（1）配置文件添加（使用 ref 属性来引用其它 bean）：</p> 
<pre><code class="language-XML">&lt;bean id="address1" class="com.lyh.study.bean.Address"&gt;
        &lt;property name="province" value="山西省"/&gt;
        &lt;property name="county" value="天水县"/&gt;
        &lt;property name="village" value="英雄村"/&gt;
    &lt;/bean&gt;

    &lt;bean id="student3" class="com.lyh.study.bean.Student"&gt;
        &lt;property name="id" value="1003"/&gt;
        &lt;property name="name" value="姜伯约"/&gt;
        &lt;property name="age" value="26"/&gt;
        &lt;property name="sex" value="男"/&gt;
        &lt;property name="address" ref="address1"/&gt;
    &lt;/bean&gt;</code></pre> 
<p>（2）测试：</p> 
<pre><code class="language-java">@Test
public void testStudent(){
    ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
    Student student3 = ac.getBean("student3", Student.class);
    System.out.println(student3);
    System.out.println(student3.getAddress());
}</code></pre> 
<p>（3）运行结果： </p> 
<pre><code class="language-java">Student{id=1003, name='姜伯约', age=26, sex='男'}
Address{province='山西省', county='天水县', village='英雄村'}</code></pre> 
<h4>1.4.2、内部 Bean</h4> 
<p>（1）配置文件：</p> 
<pre><code class="language-XML">&lt;bean id="student4" class="com.lyh.study.bean.Student"&gt;
        &lt;property name="id" value="1004"/&gt;
        &lt;property name="name" value="李大喜"/&gt;
        &lt;property name="age" value="20"/&gt;
        &lt;property name="sex" value="男"/&gt;
        &lt;property name="address"&gt;
            &lt;!-- 内部bean不能给外部使用,所以可以省略 id 属性 --&gt;
            &lt;bean class="com.lyh.study.bean.Address"&gt;
                &lt;property name="province" value="山西省"/&gt;
                &lt;property name="county" value="英雄县"/&gt;
                &lt;property name="village" value="农民村"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</code></pre> 
<p>这里省略测试，和上面的结果是一样的。 </p> 
<h4>1.4.3、级联属性赋值</h4> 
<p>使用外部 bean 重新给属性赋值:</p> 
<pre><code class="language-XML">&lt;bean id="address1" class="com.lyh.study.bean.Address"&gt;
        &lt;property name="province" value="山西省"/&gt;
        &lt;property name="county" value="天水县"/&gt;
        &lt;property name="village" value="英雄村"/&gt;
    &lt;/bean&gt;

    &lt;bean id="student5" class="com.lyh.study.bean.Student"&gt;
        &lt;property name="id" value="1005"/&gt;
        &lt;property name="name" value="狄仁杰"/&gt;
        &lt;property name="age" value="28"/&gt;
        &lt;property name="sex" value="男"/&gt;
        &lt;property name="address" ref="address1"/&gt;
        &lt;property name="address.province" value="山西省"/&gt;
        &lt;property name="address.county" value="杨柳县"/&gt;
        &lt;property name="address.village" value="大柳树村"/&gt;
    &lt;/bean&gt;</code></pre> 
<h3>1.5、特殊类型属性的注入</h3> 
<p>我们的对象类型还可能是其它类型，比如数组、集合类型。这些特殊类型属性的注入无非就是配置文件的写法变化罢了。</p> 
<h4>1.5.1、数组类型</h4> 
<p>我们给上面的 Student 类添加一个 Int[] 类型的 hobbies 属性，记得添加 setter （没有 setter 方法就无法注入）和 getter 方法。</p> 
<pre><code class="language-XML">&lt;bean id="student6" class="com.lyh.study.bean.Student"&gt;
    &lt;property name="id" value="1006"/&gt;
    &lt;property name="name" value="狄如燕"/&gt;
    &lt;property name="age" value="19"/&gt;
    &lt;property name="sex" value="女"/&gt;
    &lt;property name="address" ref="address1"/&gt;
    &lt;property name="hobbies"&gt;
        &lt;array&gt;
            &lt;value&gt;唱歌&lt;/value&gt;
            &lt;value&gt;舞剑&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre> 
<h4>1.5.2、集合类型</h4> 
<p>（1）List 类型</p> 
<p>我们给上面的 Student 类添加一个 List&lt;Student&gt; 类型的 students 属性并添加 setter 和 getter 方法。</p> 
<pre><code class="language-XML">&lt;bean id="student7" class="com.lyh.study.bean.Student"&gt;
        &lt;property name="id" value="1006"/&gt;
        &lt;property name="name" value="狄如燕"/&gt;
        &lt;property name="age" value="19"/&gt;
        &lt;property name="sex" value="女"/&gt;
        &lt;property name="address" ref="address1"/&gt;
        &lt;property name="students"&gt;
            &lt;list&gt;
                &lt;ref bean="student4"/&gt;
                &lt;ref bean="student5"/&gt;
                &lt;ref bean="student6"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</code></pre> 
<p><span style="color:#fe2c24;">注意</span>：如果是 Set 集合，只需要将其中的list标签改为set标签即可。</p> 
<p>（2）Map 类型</p> 
<p>我们给上面的 Student 类添加一个 Map&lt;String,Student&gt; 类型的 studentMap 属性并添加 setter 和 getter 方法。</p> 
<pre><code class="language-XML">&lt;bean id="student8" class="com.lyh.study.bean.Student"&gt;
        &lt;property name="id" value="1006"/&gt;
        &lt;property name="name" value="狄如燕"/&gt;
        &lt;property name="age" value="19"/&gt;
        &lt;property name="sex" value="女"/&gt;
        &lt;property name="address" ref="address1"/&gt;
        &lt;property name="studentMap"&gt;
            &lt;map&gt;
                &lt;entry&gt;
                   &lt;key&gt;
                       &lt;value&gt;1001&lt;/value&gt;
                   &lt;/key&gt;
                    &lt;!-- 如果value是基本类型，直接使用&lt;value&gt;标签即可 --&gt;
                    &lt;ref bean="student1"/&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;
                        &lt;value&gt;1002&lt;/value&gt;
                    &lt;/key&gt;
                    &lt;ref bean="student2"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</code></pre> 
<h4>1.5.3、通过 &lt;util:&gt; 标签实现集合类型属性的注入</h4> 
<p>要使用 util 标签就必须先引入它，在配置文件头部需要加入以下内容：</p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/35/cf/XHddsdsH_o.png" width="948"></p> 
<p>使用 util 标签实现 Map 集合类型注入：</p> 
<pre><code class="language-XML">    &lt;bean id="student8" class="com.lyh.study.bean.Student"&gt;
        &lt;property name="id" value="1008"/&gt;
        &lt;property name="name" value="狄如燕"/&gt;
        &lt;property name="age" value="19"/&gt;
        &lt;property name="sex" value="女"/&gt;
        &lt;property name="address" ref="address1"/&gt;
        &lt;property name="studentMap" ref="map"/&gt;
    &lt;/bean&gt;

    &lt;util:map id="map"&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;1001&lt;/value&gt;
            &lt;/key&gt;
            &lt;ref bean="student1"/&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;1002&lt;/value&gt;
            &lt;/key&gt;
            &lt;ref bean="student2"/&gt;
        &lt;/entry&gt;
    &lt;/util:map&gt;</code></pre> 
<p>可以看到，效果和上面直接通过 &lt;map&gt; 标签注入是一样的，这个 &lt;util:map&gt; 标签就相当于一个 Map 对象。</p> 
<h3>1.6、P 命名空间注入</h3> 
<p>命名空间是啥东西，其实就是我们 Spring 配置文件的头部那些带有 xlms: xxx 的部分（比如 xmls:util 就是 util 命名空间），所以 P 命名空间注入其实就是加这么一行：</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/7e/05/CqfSwW4A_o.png" width="796"></p> 
<p>有啥用呢？其实也就是用来简化配置文件的代码量：</p> 
<pre><code class="language-XML">&lt;bean id="student10" class="com.lyh.study.bean.Student" p:id="1010" p:name="武则天" p:age="58" p:address-ref="address1" p:studentMap-ref="map"/&gt;</code></pre> 
<p>可以看到，引入 p命名空间后，我们的属性直接变成了 bean 标签的一个属性值 <span style="color:#fe2c24;">p:属性名</span>，引用类型的属性也可以通过 <span style="color:#fe2c24;">p:属性名-ref</span> 的方式来引用。</p> 
<h3>1.7、引入外部属性文件</h3> 
<p>我们经常需要把一些常用但是又经常需要修改的类写入到 Spring 配置文件（比如 MySQL 工具类），而这些 Bean 的属性值的修改就需要通过外部属性文件来进行注入了，这样更加灵活，方便维护。</p> 
<p>（1）需求：</p> 
<p>        把一些特定的固定值，放到一个特定的外部文件中去（比如 db.properties），在 Spring 配置文件中进行引入，这样我们要进行修改时，只需要修改外部文件，而不需要修改代码。</p> 
<p>（2）导入依赖：</p> 
<pre><code class="language-XML"> &lt;!-- MySQL驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.30&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- 数据源-连接池 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.2.15&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>（3）创建外部属性文件 db.properties</p> 
<pre><code class="language-XML">jdbc.user=root
jdbc.password=Yan1029.
jdbc.url=jdbc:mysql://localhost:3306/flink?serverTimezone=UTC
jdbc.driver=com.mysql.cj.jdbc.Driver</code></pre> 
<h4>1.7.1、引入属性文件</h4> 
<p>（1）引入 context 名称空间：</p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/15/58/PLfCyoZX_o.png" width="922"></p> 
<p>（2）引入外部属性文件（db.properties）</p> 
<pre><code class="language-XML">    &lt;context:property-placeholder location="db.properties"/&gt;</code></pre> 
<p>（3）配置连接池对应的 Bean</p> 
<p>这个 Bean druid已经帮我们实现了，相当于一个工具类，我们都不用自己实现，只需要让 Spring 帮我管理即可。</p> 
<pre><code class="language-XML">&lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="driverClassName" value="${jdbc.driver}"/&gt;
    &lt;property name="username" value="${jdbc.user}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;</code></pre> 
<p>（4）测试：</p> 
<pre><code class="language-java">    @Test
    public void testDataSource() throws SQLException {
        ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
        DataSource druidDataSource = ac.getBean("druidDataSource", DataSource.class);
        Connection connection = druidDataSource.getConnection();
        System.out.println(connection);
        connection.close();
    }</code></pre> 
<p>（5）运行结果：</p> 
<pre><code class="language-java">com.mysql.cj.jdbc.ConnectionImpl@5b56b654</code></pre> 
<h3>1.8、Bean 的作用域</h3> 
<p>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围：</p> 
<table><thead><tr><th>取值</th><th>含义</th><th>创建对象的时机</th></tr></thead><tbody><tr><td>singleton（默认）</td><td>在IOC容器中，这个bean的对象始终为单实例</td><td>IOC容器初始化时</td></tr><tr><td>prototype</td><td>这个bean在IOC容器中有多个实例</td><td>获取bean时</td></tr></tbody></table> 
<p>也就是我上一节说的，单例对象和多例对象的区别。</p> 
<p>如果是在 WebApplicationContext 环境下还会有另外几个作用域（但不常用）：</p> 
<table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>request</td><td>在一个请求范围内有效</td></tr><tr><td>session</td><td>在一个会话范围内有效</td></tr></tbody></table> 
<p>我是应该用不上了。</p> 
<p>这里说一下单例模式（singleton）和非单例模式（prototype）的区别：</p> 
<ul><li>单例模式下，每次 getBean 都会返回同一个对象（在内存中的地址相同，可以用 == 进行测试）</li><li>非单例模式下，每次 getBena 都会创建一个新的对象，尽管我们在配置文件中设置的它们的属性是一样的，但是它们指向的是不同的内存地址。</li></ul> 
<h3>1.9、Bean 的生命周期</h3> 
<ol><li>bean对象创建（调用无参构造器）</li><li>给bean对象设置属性（调用我们自己写的 setter 方法）</li><li>bean的后置处理器（初始化之前）</li><li>bean对象初始化（需在配置bean时指定初始化方法）</li><li>bean的后置处理器（初始化之后）</li><li>bean对象就绪可以使用</li><li>bean对象销毁（需在配置bean时指定销毁方法）</li><li>IOC容器关闭</li></ol> 
<h4>1.9.1、初始化和销毁方法</h4> 
<p>上面的 Bean 对象的初始化方法和销毁方法是我们自己实现的，然后通过给 &lt;bean&gt; 标签添加属性来实现：</p> 
<pre><code class="language-XML">&lt;!-- 使用init-method属性指定初始化方法 --&gt;
&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;
&lt;bean class="com.lyh.study.bean.User" scope="prototype" init-method="initMethod" destroy-method="destroyMethod"&gt;
    &lt;property name="id" value="1001"&gt;&lt;/property&gt;
    &lt;property name="name" value="朱重八"&gt;&lt;/property&gt;
    &lt;property name="age" value="18"&gt;&lt;/property&gt;
    &lt;property name="sex" value="男"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre> 
<h4>1.8.2、后置处理器</h4> 
<p>bean 的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现 BeanPostProcessor 接口，且配置到IOC容器中。</p> 
<p>需要注意的是：<span style="color:#fe2c24;">bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行</span>  </p> 
<pre><code class="language-java">package com.lyh.study;
    
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class MyBeanProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        // 初始化之前的处理代码
        return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        // 初始化之后的处理代码
        return bean;
    }
}</code></pre> 
<p> 在 IOC 容器内配置后置处理器（放进去就行了）：</p> 
<pre><code class="language-XML">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;
&lt;bean id="myBeanProcessor" class="com.lyh.study.MyBeanProcessor"/&gt;</code></pre> 
<h3> 1.10、FactoryBean</h3> 
<p>        FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean 类型的 bean（FactoryBean 是一个接口，所以这里说 FactoryBean类型的Bean 指的其实是 它的实现类），在获取 bean 的时候得到的并不是 class 属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p> 
<p>        其实我们整合 Spring + Mybatis 时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。</p> 
<pre><code class="language-java">public interface FactoryBean&lt;T&gt; {
    String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";

    @Nullable
    T getObject() throws Exception;

    @Nullable
    Class&lt;?&gt; getObjectType();

    default boolean isSingleton() {
        return true;
    }
}</code></pre> 
<p>（1）实现 FactoryBean 接口：</p> 
<pre><code class="language-java">package com.lyh.study;

import com.lyh.study.bean.Student;
import org.springframework.beans.factory.FactoryBean;

public class StudentFactoryBean implements FactoryBean&lt;Student&gt; {

    @Override
    public Student getObject() throws Exception {
        return new Student();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return Student.class;
    }
}
</code></pre> 
<p>（2）添加到 IOC 容器：</p> 
<pre><code class="language-java">&lt;bean id="studentFactoryBean" class="com.lyh.study.StudentFactoryBean"/&gt;</code></pre> 
<p>（3）测试：</p> 
<pre><code class="language-java">    @Test
    public void testBeanFactory(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
        // 转换出来的不是 StudentBeanFactory 对象，而是 Student 对象
        Student studentBeanFactory = (Student) ac.getBean("studentFactoryBean");
        System.out.println(studentBeanFactory);
    }</code></pre> 
<p>（4）运行结果：</p> 
<pre><code class="language-java">Student{id=null, name='null', age=null, sex='null'}</code></pre> 
<p>当 Spring 容器遇到一个实现了 FactoryBean 接口的 Bean 时，它不会直接实例化这个 Bean，而是会调用该 Bean 的 getObject() 方法来获取对象。这样，我们就可以在 getObject() 方法中编写自定义的对象创建逻辑，从而实现与第三方框架的整合。</p> 
<h3>1.11、基于 XML 的自动装配</h3> 
<p>所谓自动装配其实就是为了减少我们配置 Spring 配置文件的工作量，比较一个 JavaBean 如果有很多属性的话，我们自己一个一个去配置添加属性太复杂了，所以就有了自动装配这个概念。</p> 
<p>自动装配有两种方式：通过属性类型来自动装配（byType），通过属性名来自动装配（byName）。</p> 
<ul><li>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值 
  <ul><li>如果在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值 null</li><li>如果在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常<span style="color:#fe2c24;">NoUniqueBeanDefinitionException</span></li></ul></li><li><span style="color:#0d0016;">byName</span>：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</li></ul> 
<p>这里我们写一个测试模拟我们开发的一个的场景，controller 负责响应通过 service 来实现，service 会调用 dao 层来实现持久化。</p> 
<p>（1）编写 Service 层代码：</p> 
<pre><code class="language-java">package com.lyh.study.service;

public interface UserService {
    void addUser();
}
</code></pre> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;

public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<p>（2）编写 Dao 层代码 :</p> 
<pre><code class="language-java">package com.lyh.study.dao;

public interface UserDao {
    void addUser();
}
</code></pre> 
<pre><code class="language-java">package com.lyh.study.dao;

public class UserDaoImpl implements UserDao{

    @Override
    public void addUser() {
        System.out.println("添加成功");
    }
}
</code></pre> 
<p>（3）编写 controller 层代码： </p> 
<pre><code class="language-java">package com.lyh.study.controller;

import com.lyh.study.service.UserService;

public class UserController {

    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void addUser(){
        userService.addUser();
    }

}
</code></pre> 
<h4>1.11.1、byType 自动装配</h4> 
<pre><code class="language-XML">&lt;bean id="userController" class="com.lyh.study.controller.UserController" autowire="byType"/&gt;
    &lt;bean id="userService" class="com.lyh.study.service.UserServiceImpl" autowire="byType"/&gt;
    &lt;bean id="userDao" class="com.lyh.study.dao.UserDaoImpl"/&gt;
</code></pre> 
<h4>1.11.2、byName 自动装配</h4> 
<pre><code class="language-XML">&lt;bean id="userController" class="com.lyh.study.controller.UserController" autowire="byName"/&gt;
    &lt;bean id="userService" class="com.lyh.study.service.UserServiceImpl" autowire="byName"/&gt;
    &lt;bean id="userDao" class="com.lyh.study.dao.UserDaoImpl"/&gt;
</code></pre> 
<p>测试：</p> 
<pre><code class="language-java">    @Test
    public void testAutoWireByType(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
        UserController userController = ac.getBean(UserController.class);
        userController.addUser();
    }</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-java">addUser() 方法执行
添加成功</code></pre> 
<hr> 
<h2 style="background-color:transparent;"> 2、基于注解管理 Bean</h2> 
<p>除了上面的直接手动配置 Spring 配置文件以外，我们实际用的更多应该就是使用注解注入了。</p> 
<h3>2.1、开启扫描组件</h3> 
<p>        Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 context:component-scan 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。</p> 
<p>也就是在 Spring 配置文件中加这么一行：</p> 
<pre><code class="language-java">&lt;context:component-scan base-package="com.lyh.study"/&gt;</code></pre> 
<p> <span style="color:#fe2c24;">注意</span>：在使用 context:component-scan 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 &lt;beans&gt; 中添加 context 相关的约束。</p> 
<h4>2.1.1、默认扫描方式</h4> 
<pre><code class="language-java">&lt;context:component-scan base-package="com.lyh.study"/&gt;</code></pre> 
<p>也就是我们上面演示的，它会扫描 com.lyh.study 包下所有被 @Component 注解标注的类并帮我们注册到 IOC 容器中管理。</p> 
<h4>2.1.2、指定要排除的组件</h4> 
<p>&lt;context:exclude&gt;标签</p> 
<pre><code class="language-java">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;
    &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;
    &lt;context:component-scan base-package="com.lyh.study" use-default-filters="false"&gt;
        &lt;!--
 		type：设置包含的依据
		type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
		type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
	    --&gt;
        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;
        &lt;context:exclude-filter type="assignable" expression="com.lyh.study.controller.UserController"/&gt;
    &lt;/context:component-scan&gt;</code></pre> 
<h4>2.1.3、仅扫描指定组件</h4> 
<p>&lt;context:include&gt; 标签</p> 
<pre><code class="language-java">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;
    &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;
    &lt;context:component-scan base-package="com.lyh.study" use-default-filters="false"&gt;
        &lt;!--
 		type：设置排除的依据
		type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
		type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
	    --&gt;
        &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;
        &lt;context:include-filter type="assignable" expression="com.lyh.study.controller.UserController"/&gt;
    &lt;/context:component-scan&gt;</code></pre> 
<h3>2.2、使用注解定义 Bean</h3> 
<p>Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。</p> 
<table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td></tr><tr><td>@Repository</td><td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Service</td><td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Controller</td><td>该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr></tbody></table> 
<p></p> 
<p></p> 
<h3>2.3、@Autowired 注入</h3> 
<p>单独使用 @Autowired注解时，<span style="color:#fe2c24;">默认根据类型装配（byType）</span>。</p> 
<h4>2.3.1、属性注入</h4> 
<p>上面 2.1 中我们的 UserController 中有一个属性是 UserService 类型的对象，而 UserService 这个类当中也有一个类型为 UserDao 的属性；所以我们当时必须提供 setter 方法，因为它是是通过 setter 方法进行注入的；但是现在使用注解开发我们就可以省去 setter 方法：</p> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<pre><code class="language-java">import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao{

    @Override
    public void addUser() {
        System.out.println("添加成功");
    }
}</code></pre> 
<pre><code class="language-java">package com.lyh.study.controller;

import com.lyh.study.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class UserController {

    @Autowired
    private UserService userService;

    public void addUser(){
        userService.addUser();
    }

}</code></pre> 
<p>这次我们使用了注解 @Service、Repository、Controller 分别标注了我们的 UserController、UserDao 和 UserController ，而且即使它们的 Bean 中包含了一些属性，我们并没有提供 setter 方法，因为<span style="color:#fe2c24;">使用注解开发时，不需要给 Bean 提供 setter 方法</span>。</p> 
<p>测试：</p> 
<pre><code class="language-java">    @Test
    public void testAutoWireByType(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
        UserController userController = ac.getBean("userController",UserController.class);
        userController.addUser();
    }</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-java">addUser() 方法执行
添加成功</code></pre> 
<h4>2.3.2、set 注入</h4> 
<p>上面的属性注入中，我们把 @Autowired 这个注解标注在了属性上，这种方式不需要我们实现属性的 setter 方法；而 set 注入是直接把 @Autowired 这个注解标注在方法上：</p> 
<pre><code class="language-java">package com.lyh.study.controller;

import com.lyh.study.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class UserController {
    
    private UserService userService;

    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void addUser(){
        userService.addUser();
    }

}
</code></pre> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {
    
    private UserDao userDao;

    @Autowired
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<p>这里不再测试运行结果了，效果和属性注入是一样的。个人推荐这种方式，尽量养成一个给属性添加 setter 方法的好习惯，而且属性注入 Idea 会给一个警告提示，虽然也用起来没问题，但是强迫症实在受不了。</p> 
<h4>2.3.3、构造方法注入</h4> 
<p>和上面两种方法的注入方式差不多，就是把 @Autowired 这个注解标注在了构造器上，这种方式同样不需要给属性提供 setter 方法。</p> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import com.lyh.study.dao.UserDaoImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Autowired
    public UserServiceImpl(UserDao userDao){
        this.userDao = userDao;
    }

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<pre><code class="language-java">package com.lyh.study.controller;

import com.lyh.study.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class UserController {

    private UserService userService;

    @Autowired
    public UserController(UserService userService){
        this.userService = userService;
    }

    public void addUser(){
        userService.addUser();
    }

}
</code></pre> 
<p>效果和上面一致，不做演示。</p> 
<h4>2.3.4、形参注入</h4> 
<p>把 @Autowired 标注在形参上。</p> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import com.lyh.study.dao.UserDaoImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public UserServiceImpl(@Autowired UserDao userDao){
        this.userDao = userDao;
    }

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<pre><code class="language-java">package com.lyh.study.controller;

import com.lyh.study.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class UserController {

    private UserService userService;

    public UserController(@Autowired UserService userService){
        this.userService = userService;
    }

    public void addUser(){
        userService.addUser();
    }

}
</code></pre> 
<p>同样不做测试。</p> 
<h4>2.4.5、只有一个构造函数，无注解</h4> 
<p>当我们的 Bean 只有一个构造函数时，可以不需要注解。我们也可以从 Idea 的只能提示中看出来，当只有一个构造函数时它会自动被 Spring IOC 容器所管理（当然，我们的 Service 类上的 @Service 还是得有的）。</p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/eb/66/OsQbdpAk_o.png" width="589"></p> 
<p><span style="color:#fe2c24;">注意：再添加一个无参构造函数就失效了（有参构造和无参构造只能有一个）！！！</span></p> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import com.lyh.study.dao.UserDaoImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public UserServiceImpl(UserDao userDao){
        this.userDao = userDao;
    }

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<pre><code class="language-java">​
package com.lyh.study.controller;

import com.lyh.study.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class UserController {

    private UserService userService;

    public UserController(UserService userService){
        this.userService = userService;
    }

    public void addUser(){
        userService.addUser();
    }

}

​</code></pre> 
<h4>2.4.6、@Autowired注解和@Qualifier注解联合</h4> 
<p>假设我们需要扩展一个名为 UserOracleDaoImpl 的类，用来把数据持久化到 Oracle 数据库中。</p> 
<pre><code class="language-java">package com.lyh.study.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserOracleDaoImpl implements UserDao{
    
    @Override
    public void addUser() {
        System.out.println("用户被添加到 Oracle 数据库中");
    }
}</code></pre> 
<p>当我们进行测试的时候，会发现报错，甚至 Idea 自动会检测到异常不允许编译通过。原因就是 UerDao 类型的类 = 2 ，根本原因其实就是我们使用的 byType 自动装配，它要求我们的 IOC 容器中只能包含一个这种类型的 Bean。</p> 
<p>怎么解决呢？其实很简单，换 byName 自动装配就 OK 了，也就是把 @Autowired注解和@Qualifier注解联合使用（标注在 setter 方法或者 属性上都是可以的）：</p> 
<p>因为我们上面的 UserDaoImpl 和 UserOracleDaoImpl 都已经被 @Respository 标注过了，所以它俩已经都被注册进了我们的 IOC 容器中，切换不同的实现类只需要修改 id ：</p> 
<p>使用 userDaoImpl ：</p> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Autowired
    @Qualifier("userDaoImpl")
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<p>要换用 userOrcaleDaoImpl 直接修改 id 即可：</p> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Autowired
    @Qualifier("userOracleDaoImpl")
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<p><strong>总结</strong></p> 
<ul><li> <p>@Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上。</p> </li><li> <p>当带参数的构造方法只有一个，@Autowired注解可以省略。</p> </li><li> <p>@Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。</p> </li></ul> 
<h3 style="background-color:transparent;">2.4、@Resource 注入</h3> 
<p>和上面的 @Autowired 一样，@Resource 也可以完成属性的注入。</p> 
<ul><li> <p>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)</p> </li><li> <p>@Autowired注解是Spring框架自己的。</p> </li><li> <p><span style="color:#fe2c24;">@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。</span></p> </li><li> <p><span style="color:#fe2c24;">@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。</span></p> </li><li> <p>@Resource注解用在属性上、setter方法上。</p> </li><li> <p>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</p> </li></ul> 
<p>@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：<span style="color:#fe2c24;">【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】</span></p> 
<pre><code class="language-XML">&lt;dependency&gt;    
    &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<h4>2.4.1、根据 name 注入</h4> 
<p>也就是根据 @Resource(name = "xxx") 的方式来找到对应的引用 Bean</p> 
<pre><code class="language-java">package com.lyh.study.dao;

import org.springframework.stereotype.Repository;

@Repository("myUserDao")
public class UserDaoImpl implements UserDao{

    @Override
    public void addUser() {
        System.out.println("添加成功");
    }
}
</code></pre> 
<p>需要和引用的类指定的 id 对应上（要引用上面的实现类就得指定 name = "myUserDao"）:</p> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Resource(name = "myUserDao")
    private UserDao userDao;

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<p>测试通过。</p> 
<h4>2.4.2、未知 name 注入</h4> 
<p>这次这里的 @Resource 不指定name，如果没有指定 name 它首先会去 IOC 容器中找 id = 该属性名（也就是 userDao）的 Bean，如果没有，再按照 byType 去找。</p> 
<p>注意：这里我们定义的属性名 userDao 实际 IOC 容器中并没有 id = "userDao" 这么个 Bean，所以，它会继续按照类型去找，但是如果我们有两个 Bean 它们都实现了 UserDao 接口，那么它就会报错。</p> 
<pre><code class="language-java">package com.lyh.study.service;

import com.lyh.study.dao.UserDao;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Resource
    private UserDao userDao;

    @Override
    public void addUser() {
        System.out.println("addUser() 方法执行");
        userDao.addUser();
    }
}
</code></pre> 
<p>测试通过。</p> 
<h3>2.5、Spring 全注解开发</h3> 
<p>全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件，这个配置类需要被 @Configuration 注解标注。</p> 
<p>编写一个配置类，扫描 "com.lyh.study" 包下所有被 IOC 容器管理注的类：</p> 
<pre><code class="language-java">package com.lyh.study.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("com.lyh.study")
public class SpringConfig01 {

}
</code></pre> 
<p>测试：</p> 
<p>这里获取上下文对象使用的是 AnnotationConfigApplicationContext ，之前我们用的是 ClassPathXmlApplicationContext ，需要注意一下。</p> 
<pre><code class="language-java">    @Test
    public void testAllAnnotation(){
        ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig01.class);
        UserController userController = ac.getBean("userController", UserController.class);
        userController.addUser();
    }</code></pre> 
<p>测试成功。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b00434facc850c7740de2a87d50c402/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI项目十八：YOLOV8自训练关键点检测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b15c674f54f4df208668398719363ba8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RuntimeError: Expected to have finished reduction in the prior iteration before starting a new one.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>