<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是虚拟机（virtual machine） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么是虚拟机（virtual machine）" />
<meta property="og:description" content="虚拟机（virtual machine ）是一种说明计算机硬件和软件关系的有效方法。
在安德鲁 · 塔嫩鲍姆（Andrew Tanenbaum）的书《结构化计算机组织》（Structured Computer Organization）中可以找到对这个模型广为人知的解释。要说明这个概念，先从计算机的最基本功能开始，即执行程序。
计算机通常可以执行用其原生机器语言编写的程序。这种语言中的每一条指令都简单到可以用相对少量的电子电路来执行。为了简便，称这种语言为 L0。
由于 L0 极其详细，并且只由数字组成，因此，程序员用其编写程序就非常困难。如果能够构造一种较易使用的新语言 L1，那么就可以用 L1 编写程序。有两种实现方法：
解释（Interpretation）：运行 L1 程序时，它的每一条指令都由一个用 L0 语言编写的程序进行译码和执行。L1 程序可以立即开始运行，但是在执行之前，必须对每条指令进行译码。翻译（Translation）：由一个专门设计的 L0 程序将整个 L1 程序转换为 L0 程序。然后，得到的 L0 程序就可以直接在计算机硬件上执行。 虚拟机 与只使用语言描述相比，把每一层都想象成有一台假设的计算机或者虚拟机会更容易一些。通俗地说，虚拟机可以定义为一个软件程序，用来模拟一些其他的物理或虚拟计算机的功能。
虚拟机，将其称为 VM1，可以执行 L1 语言编写的指令。虚拟机 VM0 可以执行 L0 语言编写的指令：
每一个虚拟机既可以用硬件构成也可以用软件构成。程序员可以为虚拟机 VM1 编写程序，如果能把 VM1 当作真实计算机予以实现，那么，程序就能直接在这个硬件上执行。否则，用 VM1 写出的程序就被翻译 / 解释为 VM0 程序，并在机器 VM0 上执行。
机器 VM1 与 VM0 之间的差异不能太大，否则，翻译或解释花费的时间就会非常多。如果 VM1 语言对程序员来说还不够友好到足以用于应用程序的开发呢？
可以为此设计另一个更加易于理解的虚拟机 VM2。这个过程能够不断重复，直到虚拟机 VMn 足够支持功能强大、使用方便的语言。
Java 编程语言就是以虚拟机概念为基础的。Java 编译器把用 Java 语言编写的程序翻译为 Java 字节码（Java byte code）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3e40e41a364f4cb078b6eff915369305/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-26T18:59:00+08:00" />
<meta property="article:modified_time" content="2019-05-26T18:59:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是虚拟机（virtual machine）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>虚拟机（virtual machine ）是<span style="color:#f33b45;">一种说明计算机硬件和软件关系的有效方法</span>。</strong><br><br> 在安德鲁 · 塔嫩鲍姆（Andrew Tanenbaum）的书《结构化计算机组织》（Structured Computer Organization）中可以找到对这个模型广为人知的解释。要说明这个概念，先从计算机的最基本功能开始，即执行程序。<br><br><strong>计算机通常可以执行用其原生机器语言编写的程序</strong>。这种语言中的每一条指令都简单到可以用相对少量的电子电路来执行。为了简便，称这种语言为<strong><span style="color:#f33b45;"> L0</span></strong>。<br><br> 由于 L0 极其详细，并且只由数字组成，因此，程序员用其编写程序就非常困难。如果能够构造一种较易使用的新语言 L1，那么就可以用 L1 编写程序。有两种实现方法：</p> 
<ul><li><strong><span style="color:#f33b45;">解释（Interpretation）</span>：运行 L1 程序时，它的每一条指令都由一个用 L0 语言编写的程序进行译码和执行</strong>。L1 程序可以立即开始运行，但是在执行之前，必须对每条指令进行译码。</li><li><strong><span style="color:#f33b45;">翻译（Translation）</span>：由一个专门设计的 L0 程序将整个 L1 程序转换为 L0 程序</strong>。然后，得到的 L0 程序就可以直接在计算机硬件上执行。</li></ul> 
<h3>虚拟机</h3> 
<p>与只使用语言描述相比，把每一层都想象成有一台假设的计算机或者虚拟机会更容易一些。通俗地说，虚拟机可以定义为一个软件程序，用来模拟一些其他的物理或虚拟计算机的功能。<br><br> 虚拟机，将其称为 VM1，可以执行 L1 语言编写的指令。虚拟机 VM0 可以执行 L0 语言编写的指令：<br>  </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/f0/dc/1W0GbudI_o.gif"></p> 
<p><br> 每一个虚拟机既可以用硬件构成也可以用软件构成。程序员可以为虚拟机 VM1 编写程序，如果能把 VM1 当作真实计算机予以实现，那么，程序就能直接在这个硬件上执行。否则，用 VM1 写出的程序就被翻译 / 解释为 VM0 程序，并在机器 VM0 上执行。<br><br> 机器 VM1 与 VM0 之间的差异不能太大，否则，翻译或解释花费的时间就会非常多。如果 VM1 语言对程序员来说还不够友好到足以用于应用程序的开发呢？<br><br> 可以为此设计另一个更加易于理解的虚拟机 VM2。这个过程能够不断重复，直到虚拟机 VMn 足够支持功能强大、使用方便的语言。<br><br><strong>Java 编程语言就是以虚拟机概念为基础的。Java 编译器把用 Java 语言编写的程序翻译为 <span style="color:#f33b45;">Java 字节码（Java byte code）</span>。</strong><br><br> 后者是一种低级语言，能够在运行时由<strong> Java 虚拟机（JVM）</strong>程序快速执行。JVM 已经在许多不同的计算机系统上实现了，这使得 Java 程序相对而言独立于系统。</p> 
<h3>特定的机器</h3> 
<p>与实际机器和语言相对，用 Level 2 表示 VM2，Level 1 表示 VM1，如下图所示。计算机数字逻辑硬件表示为 Level 1 机器。其上是 Level 2，称为指令集架构（ISA, Instruction Set Architecture） 。通常，这是用户可以编程的第一个层次，尽管这种程序包含的是被称为机器语言的二进制数值。<br>  </p> 
<p><img alt="虚拟机层次结构" class="has" src="https://images2.imgbox.com/51/bf/jowqvggG_o.gif"></p> 
<p><br> 指令集架构（Level 2）计算机芯片制造商在处理器内部设计一个指令集来实现基本操作，如传送、加法或乘法。这个指令集也被称为机器语言。每一个机器语言指令或者直接在机器硬件上执行，或者由嵌入到微处理器芯片的程序来执行，该程序被称为微程序。<br><br> 汇编语言（Level 3）在 ISA 层，编程语言提供了一个翻译层，来实践大规模软件开发。汇编语言出现在 Level 3，使用短助记符，如 ADD、SUB 和 MOV，易于转换到 ISA 层。汇编语言程序在执行之前要全部翻译（汇编）为机器语言。<br><br> 高级语言（Level 4）Level 4 是高级编程语言，如 C、C++ 和 Java。这些语言程序所包含的语句功能强大，并翻译为多条汇编语言指令。比如，查看 C++ 编译器生成的列表文件输出，就可以看到这样的翻译。汇编语言代码由编译器自动汇编为机器语言。</p> 
<h3><span style="color:#f33b45;">虚拟机是以什么形式存在的</span>：</h3> 
<p><br> 　　vm的具体存在形式是一个文件夹。文件夹中包含虚拟机必要的文件，也正是这些文件组成了虚拟机。 <br> 　　一句话解释：虚拟机是运行在物理平台基础之上的由一堆文件构成的文件夹。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/35/d1/FHQmgiK3_o.jpg"></p> 
<p>　　这样我们的创建的虚拟机，都以文件的形式存放在我们的存储当中。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ff/52/iOxPLkq5_o.jpg"></p> 
<p>　　接下来看看我们的vm中的文件构成： </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/5b/54/X716jE64_o.jpg"><br> 　　<span style="color:#f33b45;">下面来介绍几个主要的文件： </span><br><strong>1、configuration file： </strong><br> 　　这是<span style="color:#f33b45;">一个以<strong>vm_name.vmx命名</strong>的<strong>vmx格式的文件</strong>。</span>与虚拟机所以相关的东西都写在这个文件中，这<span style="color:#3399ea;">是虚拟机的核心配置文件，如果它丢失了，那么我们的虚拟机也就报废了</span>。 <br><strong>2、swap file : </strong><br> 　　这是<span style="color:#f33b45;">一个以<strong>vm_name.vswp命名</strong>和<strong>vmx-vm_name.vswp命名</strong>的<strong>vswp格式</strong>的两个文件。</span>这是一个<span style="color:#3399ea;">交换文件。 </span><br> 　　<span style="color:#f33b45;"><strong>Vm_name.vswp 文件</strong></span><span style="color:#3399ea;">作为虚拟机虚拟内存的补充文件，当虚拟机内存不够的时候，会以这个文件当做内存来使用</span>。 <br> 　　<span style="color:#f33b45;"><strong>Vmx_vm_name.vswp文件</strong></span>时esxi运行虚拟机产生的内存开销文件。它是<span style="color:#3399ea;">exsi运行vm时当内存不够时产生的物理补充文件。</span>类似一个QQ程序，他会在运行的不同时刻消耗不同的开销，当物理开销不足时，就会用这个文件来补充。 <br> 　<span style="color:#e579b6;">　Ps:这两个文件是随着虚拟机开机而存在，关机而消失的。第一个文件在正常情况下士与我们的虚拟机的匹配内存的大小几乎一致的，第二个文件时浮动变化大小的。 </span><br><strong>3、bios file ： </strong><br> 　　这是<span style="color:#f33b45;">一个<strong>以vm_name.nvram命名</strong>的<strong>nvram格式的文件</strong></span>。BIOS 文件相信大家都已经熟悉的不能再熟悉了。 <br><strong>4、log file </strong><br> 　　这是<span style="color:#f33b45;">一个<strong>以Vmware.log命名</strong>的<strong>log格式的文件</strong></span>，<span style="color:#3399ea;">主要记录vm的开机关机日志，和一下基本操作日志等</span>。 <br><strong>5、template file </strong><br> 　　这是<span style="color:#f33b45;">一个<strong>以vm_name.vmtx命名</strong>的<strong>vmtx格式的文件</strong></span>。<span style="color:#3399ea;">被称为模板文件，</span>我们可以使用母版文件来快速创建大量虚拟机，其配置与这个虚拟机相同。但是他与configuration file“不共存”。 <br> 　　他俩的关系是这样的：通过模板文件来创建虚拟机时，<strong>vm_name.vmx文件</strong>时通过<strong>vm_name.vmtx文件</strong>改名而来的。在一个文件夹中不可能同时存在vm_name.vmx文件和vm_name.vmtx文件。如果一个文件夹中包含vm_name.vmtx文件，就说明这是一个模板。 <br><strong>6、raw device map file </strong><br> 　　这是<span style="color:#f33b45;"><strong>一个以vm_name-rdm.vmdk命名</strong>的<strong>vmdk格式的文件</strong></span>，是<span style="color:#3399ea;">以裸设备映射挂在到虚拟机上的磁盘。</span></p> 
<p>　　经过上面的大致的讲解我们不难看出，vm和传统物理机的区别，下面我们来大致的说一下：</p> 
<h3>vm和我们传统物理机的对比</h3> 
<p><br><strong><span style="color:#3399ea;">１. 在传统的物理机中： </span></strong><br> 　　a. 传统的物理机架构中：操作系统独占我们的硬件资源，比如网卡，硬盘，内存。 <br> 　　b. 操作系统上面的程序也是独占我们的硬件资源。</p> 
<p><img alt="è¿éåå¾çæè¿°" class="has" src="https://images2.imgbox.com/50/d6/3WEcL0VU_o.jpg"></p> 
<p><span style="color:#3399ea;"><strong>２. 在虚拟机中 </strong></span><br> 　　a. esxi独占我们的物理资源，包括cup，内存，网卡等。 <br> 　　b. 而我们的虚拟机通过vsphere共享我们底层的物理资源，包括cup等。 </p> 
<h3><img alt="è¿éåå¾çæè¿°" class="has" src="https://images2.imgbox.com/80/58/uVSKip83_o.jpg"><br> vm和传统物理机的最大的区别：</h3> 
<p><br> 　<span style="color:#f33b45;">　1、vm不是直接运行在物理层上面。 <br> 　　2、vm是现在物理机上插入一个VMware层，插入VMware后，然后分割物理资源，转换为虚拟机资源，</span>比如虚拟内存，虚拟硬盘等等。分割资源以后安装系统，安装系统之后在安装相关的应用。</p> 
<p><img alt="è¿éåå¾çæè¿°" class="has" src="https://images2.imgbox.com/22/7a/H8VdwlIg_o.jpg"></p> 
<p>　　通过对比，我们不难发现vm的优点：</p> 
<h3>使用虚拟机的优点：</h3> 
<p><strong><span style="color:#3399ea;">1. 使用物理机： </span></strong><br> 　<strong>a. 设备移动 </strong><br> 　　i. 停机：如果我们一台运行的物理需要移动位置，我们必然需要关机，那么此时我们就将面临着业务中断等问题。 <br> 　　ii. 受限于我们设备本身的一些问题：如果一台设备运行很久了，可能一关机就无法再次开启机器。相信做过运维的小伙伴都遇到过。 <br><strong>　b. 难管理 </strong><br> 　　i. 设备管理需要停机：如升级硬件资源。 <br> 　　ii. 设备故障：设备故障，需要停机维护，时间花费太长，同时带来业务中断。 <br><strong>　c. 硬件限制 </strong><br> 　　i. 设备之间是相互隔离的。 <br> 　　ii. 硬件更好时需要考虑应用程序与硬件的兼容性。<br><strong><span style="color:#3399ea;">2. 使用虚拟机： </span></strong><br> 　<strong>a. 移动方便</strong><br> 　　i. 虚拟机被封装成文件，便于移动。 <br> 　　ii. 虚拟机建立在vsphere层之上的，因此vm是独立于物理硬件之外的。为此我们无论吧虚拟机移动到什么地方，只要有vsphere层即可运行。 <br> 　<strong>b. 简单管理 </strong><br> 　　i. 虚拟机之间是相互逻辑隔离的，方便管理。 <br> 　　ii. 不受限于硬件变更的影响，因为我们vm使用的cup，内存，都是vsphere层虚拟机出来的标准格式，不需要考虑兼容性问题。 <br> 　<strong>c. 兼容比较古老的程序 </strong><br> 　<strong>ｄ.服务器的整合比很高</strong><br>  </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a738dbfae4a69f885cb8d7be874dccf3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MQTT学习】lesson6.详解 QoS0 和 QoS1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8019fc41f99fe353c0fa63bce3865a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序事件传参</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>