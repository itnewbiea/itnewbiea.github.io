<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springmvc 利用AOP实现多数据源动态切换 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springmvc 利用AOP实现多数据源动态切换" />
<meta property="og:description" content="多数据源说白了就是项目里连接多个数据库；常见于分库查询(主从库)，分库操作-增删改查(多库多表)等。
下面说下具体步骤：
1.配置db.properties文件 pay.jdbc.url=jdbc:mysql://192.168.0.2:3306/pay?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC pay.jdbc.password=root pay.jdbc.username=root model.jdbc.url=jdbc:mysql://192.168.0.2:3306/model?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC model.jdbc.password=root model.jdbc.username=root 2.1在spring配置文件中配置多个数据源 &lt;!-- 配置数据源 使用的是Druid数据源 --&gt; &lt;bean name=&#34;dsPay&#34; class=&#34;com.alibaba.druid.pool.DruidDataSource&#34; init-method=&#34;init&#34; destroy-method=&#34;close&#34;&gt; &lt;property name=&#34;url&#34; value=&#34;${pay.jdbc.url}&#34; /&gt; &lt;property name=&#34;username&#34; value=&#34;${pay.jdbc.username}&#34; /&gt; &lt;property name=&#34;password&#34; value=&#34;${pay.jdbc.password}&#34; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&#34;initialSize&#34; value=&#34;${pool.initialSize}&#34; /&gt; &lt;!-- 连接池最大使用连接数量 --&gt; &lt;property name=&#34;maxActive&#34; value=&#34;${pool.maxActive}&#34; /&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&#34;minIdle&#34; value=&#34;${pool.minIdle}&#34; /&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&#34;maxWait&#34; value=&#34;${pool.maxWait}&#34; /&gt; &lt;property name=&#34;poolPreparedStatements&#34; value=&#34;${pool.poolPreparedStatements}&#34; /&gt; &lt;property name=&#34;maxPoolPreparedStatementPerConnectionSize&#34; value=&#34;${pool.maxPoolPreparedStatementPerConnectionSize}&#34; /&gt; &lt;!-- 用来检测有效sql --&gt; &lt;property name=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/62408fa4d443f0089be7b4a895f43b87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-03T19:16:14+08:00" />
<meta property="article:modified_time" content="2019-09-03T19:16:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springmvc 利用AOP实现多数据源动态切换</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>多数据源说白了就是项目里连接多个数据库；常见于分库查询(主从库)，分库操作-增删改查(多库多表)等。</p> 
<p>下面说下具体步骤：</p> 
<h4>1.配置db.properties文件</h4> 
<pre class="has"><code class="language-java">pay.jdbc.url=jdbc:mysql://192.168.0.2:3306/pay?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC
pay.jdbc.password=root
pay.jdbc.username=root

model.jdbc.url=jdbc:mysql://192.168.0.2:3306/model?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC
model.jdbc.password=root
model.jdbc.username=root</code></pre> 
<h4>2.1在spring配置文件中配置多个数据源</h4> 
<pre class="has"><code class="language-java">&lt;!-- 配置数据源 使用的是Druid数据源 --&gt;
    &lt;bean name="dsPay" class="com.alibaba.druid.pool.DruidDataSource"
        init-method="init" destroy-method="close"&gt;
        &lt;property name="url" value="${pay.jdbc.url}" /&gt;
        &lt;property name="username" value="${pay.jdbc.username}" /&gt;
        &lt;property name="password" value="${pay.jdbc.password}" /&gt;
        &lt;!-- 初始化连接大小 --&gt;
        &lt;property name="initialSize" value="${pool.initialSize}" /&gt;
        &lt;!-- 连接池最大使用连接数量 --&gt;
        &lt;property name="maxActive" value="${pool.maxActive}" /&gt;
        
        &lt;!-- 连接池最小空闲 --&gt;
        &lt;property name="minIdle" value="${pool.minIdle}" /&gt;
        &lt;!-- 获取连接最大等待时间 --&gt;
        &lt;property name="maxWait" value="${pool.maxWait}" /&gt;
        &lt;property name="poolPreparedStatements" value="${pool.poolPreparedStatements}" /&gt;
        &lt;property name="maxPoolPreparedStatementPerConnectionSize"
            value="${pool.maxPoolPreparedStatementPerConnectionSize}" /&gt;
        &lt;!-- 用来检测有效sql --&gt;
        &lt;property name="validationQuery" value="${pool.validationQuery}" /&gt;
        &lt;property name="testOnBorrow" value="${pool.testOnBorrow}" /&gt;
        &lt;property name="testOnReturn" value="${pool.testOnReturn}" /&gt;
        &lt;property name="testWhileIdle" value="${pool.testWhileIdle}" /&gt;
        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;  
        &lt;property name="timeBetweenEvictionRunsMillis" value="${pool.timeBetweenEvictionRunsMillis}" /&gt;  
        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;
        &lt;property name="minEvictableIdleTimeMillis" value="${pool.minEvictableIdleTimeMillis}" /&gt;
        &lt;!-- 打开removeAbandoned功能 --&gt;
        &lt;property name="removeAbandoned" value="${pool.removeAbandoned}" /&gt;
        &lt;!-- 1800秒，也就是30分钟 --&gt;
        &lt;property name="removeAbandonedTimeout" value="${pool.removeAbandonedTimeout}" /&gt;
        &lt;!-- 关闭abanded连接时输出错误日志 --&gt;
        &lt;property name="logAbandoned" value="${pool.logAbandoned}" /&gt;
        &lt;!-- 监控数据库 --&gt;
        &lt;property name="filters" value="${pool.filters}" /&gt;
    &lt;/bean&gt;
  
  &lt;!-- 配置数据源 使用的是Druid数据源 --&gt;
    &lt;bean name="dsModel" class="com.alibaba.druid.pool.DruidDataSource"
        init-method="init" destroy-method="close"&gt;
        &lt;property name="url" value="${model.jdbc.url}" /&gt;
        &lt;property name="username" value="${model.jdbc.username}" /&gt;
        &lt;property name="password" value="${model.jdbc.password}" /&gt;
        &lt;!-- 初始化连接大小 --&gt;
        &lt;property name="initialSize" value="${pool.initialSize}" /&gt;
        &lt;!-- 连接池最大使用连接数量 --&gt;
        &lt;property name="maxActive" value="${pool.maxActive}" /&gt;
        
        &lt;!-- 连接池最小空闲 --&gt;
        &lt;property name="minIdle" value="${pool.minIdle}" /&gt;
        &lt;!-- 获取连接最大等待时间 --&gt;
        &lt;property name="maxWait" value="${pool.maxWait}" /&gt;
        &lt;property name="poolPreparedStatements" value="${pool.poolPreparedStatements}" /&gt;
        &lt;property name="maxPoolPreparedStatementPerConnectionSize"
            value="${pool.maxPoolPreparedStatementPerConnectionSize}" /&gt;
        &lt;!-- 用来检测有效sql --&gt;
        &lt;property name="validationQuery" value="${pool.validationQuery}" /&gt;
        &lt;property name="testOnBorrow" value="${pool.testOnBorrow}" /&gt;
        &lt;property name="testOnReturn" value="${pool.testOnReturn}" /&gt;
        &lt;property name="testWhileIdle" value="${pool.testWhileIdle}" /&gt;
        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;  
        &lt;property name="timeBetweenEvictionRunsMillis" value="${pool.timeBetweenEvictionRunsMillis}" /&gt;  
        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;
        &lt;property name="minEvictableIdleTimeMillis" value="${pool.minEvictableIdleTimeMillis}" /&gt;
        &lt;!-- 打开removeAbandoned功能 --&gt;
        &lt;property name="removeAbandoned" value="${pool.removeAbandoned}" /&gt;
        &lt;!-- 1800秒，也就是30分钟 --&gt;
        &lt;property name="removeAbandonedTimeout" value="${pool.removeAbandonedTimeout}" /&gt;
        &lt;!-- 关闭abanded连接时输出错误日志 --&gt;
        &lt;property name="logAbandoned" value="${pool.logAbandoned}" /&gt;
        &lt;!-- 监控数据库 --&gt;
        &lt;property name="filters" value="${pool.filters}" /&gt;
    &lt;/bean&gt;
</code></pre> 
<h4>2.2 配置<strong>数据源选择器</strong></h4> 
<pre class="has"><code class="language-java">&lt;!--配置多数据源选择器--&gt;
	&lt;bean id="dataSource" class="lzs.common.datasource.DynamicDataSource"&gt;
		&lt;property name="targetDataSources"&gt;
			&lt;map key-type="java.lang.String"&gt;
				&lt;entry key="dsModel" value-ref="dsModel"/&gt;
			&lt;/map&gt;
		&lt;/property&gt;
		&lt;!--默认数据源--&gt;
		&lt;property name="defaultTargetDataSource" ref="dsPay"/&gt;
  	&lt;/bean&gt;</code></pre> 
<h4>2.3 配置<strong>数据源选择器</strong></h4> 
<pre class="has"><code class="language-java">import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

public class DynamicDataSource extends AbstractRoutingDataSource {

	/**
	 * 取得当前使用那个数据源。
	 */
    @Override
	protected Object determineCurrentLookupKey() {
    	return DataSourceHolder.getDataSources();
    }
}
 
	
	

public class DataSourceHolder {
       /* ThreadLocal,叫线程本地变量或线程本地存储。
	 * ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。
	 * 这里使用它的子类InheritableThreadLocal用来保证父子线程都能拿到值。
	 */
    private static final ThreadLocal&lt;String&gt; dataSources = new InheritableThreadLocal&lt;&gt;();

    public static void setDataSources(String dataSource) {
        dataSources.set(dataSource);
    }

    public static String getDataSources() {
        return dataSources.get();
    }
    //还原数据源
    public static void clearDataSource() {
        return dataSources.remove();
    }
}</code></pre> 
<p> 对于ThreadLocal不太清楚的可以看这个大神的博客<a href="http://www.linhao007.com/2017/04/13/01/" rel="nofollow">《ThreadLocal是什么》http://www.linhao007.com/2017/04/13/01/</a></p> 
<h4>3.1手动切换使用</h4> 
<pre class="has"><code class="language-java">public static void main(String[] args) {
    	/**
    	 * 数据源切换标识 与spring-db.xml 配置文件中的key 配置一致
    	 */
    	DataSourceHolder.setDataSources("dsPay");
    	//业务逻辑编写
    	DataSourceHolder.clearDataSource();//切换的时候最好清空一下


        DataSourceHolder.setDataSources("dsModel");
    	//业务逻辑编写
    	DataSourceHolder.clearDataSource();// 
    	
	}</code></pre> 
<h4>3.2手动切换在正式业务里不建议用，那就可以利用Sping的AOP 实现动态切换数据源，本例是aop的切入点设置在了service层，可以根据自己的业务进行调整</h4> 
<pre class="has"><code class="language-java">
 &lt;!--利用aop的切入功能拦截--&gt;
	&lt;bean id="dataSourceExchange" class="lzs.common.datasource.DataSourceExchange"/&gt;
	&lt;aop:config proxy-target-class="true"&gt;
		&lt;aop:aspect ref="dataSourceExchange" order="1"&gt;
			&lt;!-- &lt;aop:pointcut id="dataSourcePointcut" expression="execution(* lzs.user.*.service.*.*(..)) || execution(* lzs.model.*.service.*.*(..))"/&gt; --&gt;
              &lt;aop:pointcut id="dataSourcePointcut" expression="execution(* lzs.model.*.service.*.*(..))"/&gt;
			&lt;aop:before pointcut-ref="dataSourcePointcut" method="before"/&gt;
			&lt;aop:after pointcut-ref="dataSourcePointcut" method="after"/&gt;
		&lt;/aop:aspect&gt;
	&lt;/aop:config&gt;</code></pre> 
<pre class="has"><code class="language-java">
import org.aspectj.lang.JoinPoint;

public class DataSourceExchange {

    /**
     *执行之前的方法
     * @param point
     */
    public void before(JoinPoint point) {

       //获取目标对象的类类型 名称，形如：//lzs.model.authcode.service.impl.xxServiceImpl
	   String nameClass = point.getTarget().getClass().getName().toString();
	   if(nameClass.contains(".model.")){
           DataSourceHolder.setDataSources("dsModel");
           System.out.println("切换库model=="+DataSourceHolder.getDataSources());
       } 

    }


    /**
     * 执行后将数据源置为空
     */
    public void after() {
        DataSourceHolder.setDataSources(null);
        System.out.println("还原默认库=="+DataSourceHolder.getDataSources());
    }
</code></pre> 
<p>这样配置完后，当在controller层调用model包下的service时，就会触发切换数据源到dsModel，使用完后 会自动清空还原默认的数据源。</p> 
<h4>4.后记,踩过的坑：</h4> 
<p>以上弄好后启动项目测试，发现AOP织入不成功，前置通知根本就没有执行！！！这个问题坑了我一天！！后来网上各种搜资料发现有这么说的：<br> 这是由于Spring与SpringMVC是2个不同的父子容器， @Aspect如果被spring容器加载的话，而@Controller注解的这些类的实例化以及注入却是由SpringMVC来完成。 @Aspect如果被spring容器加载的时候，可能Spring MVC容器还未初始化， Controller类还未初始化，所以无法正常织入。<br> 解决办法是：把aop的配置()放到springmvc的配置文件中。</p> 
<p><img alt="" class="has" height="176" src="https://images2.imgbox.com/d9/54/mGmj1ADM_o.png" width="507"></p> 
<p>重启后，发现可以了。。</p> 
<p>参考博客：</p> 
<p><a href="http://www.linhao007.com/2017/11/23/01/" rel="nofollow">http://www.linhao007.com/2017/11/23/01/</a></p> 
<p><a href="https://blog.csdn.net/weixin_44364953/article/details/86309803">https://blog.csdn.net/weixin_44364953/article/details/86309803</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/acfd5d6818ff4d02820804ac81daa513/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 单引号、双引号和三引号混用时一定要注意！！！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec76a2f6b25f3a5ff3e0d53dbc745e22/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">移动端适配第二弹！Flexible实现H5页面的终端适配！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>