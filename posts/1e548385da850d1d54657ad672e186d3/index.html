<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代码随想录day20 开始二叉搜索树 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="代码随想录day20 开始二叉搜索树" />
<meta property="og:description" content="654.最大二叉树 题目 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
二叉树的根是数组中的最大元素。左子树是通过数组中最大值左边部分构造出的最大二叉树。右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。
示例 ：
思考 本题也是通过递归的方式构造二叉树：找到数组中最大的数，然后最大数左部分变成一个数组，右部分变成一个数组，继续node-&gt;left、node-&gt;right递归两个数组，注意创建左右数组的时候需要跳过node
代码 class Solution {
public:
TreeNode* traversal(vector&lt;int&gt;&amp; nums) {
if(nums.size() == 0) return nullptr;
int maxValue = INT_MIN;
for(auto i : nums) {
maxValue = max(maxValue, i);
}
TreeNode* node = new TreeNode(maxValue);
int pos = 0;
for(; pos &lt; nums.size(); pos&#43;&#43;) {
if(nums[pos] == maxValue) break;
}
vector&lt;int&gt; left(nums.begin(), nums.begin() &#43; pos);
vector&lt;int&gt; right(nums.begin() &#43; pos &#43; 1, nums.end());" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1e548385da850d1d54657ad672e186d3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T22:56:19+08:00" />
<meta property="article:modified_time" content="2024-01-04T22:56:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代码随想录day20 开始二叉搜索树</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="_654-最大二叉树">654.最大二叉树</h2> 
<h3>题目</h3> 
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p> 
<ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul> 
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p> 
<p>示例 ：</p> 
<p></p> 
<p class="img-center"><img alt="654.最大二叉树" height="432" src="https://images2.imgbox.com/f2/d1/5ryNZye6_o.png" width="928"></p> 
<h3>思考</h3> 
<p>本题也是通过递归的方式构造二叉树：找到数组中最大的数，然后最大数左部分变成一个数组，右部分变成一个数组，继续node-&gt;left、node-&gt;right递归两个数组，注意创建左右数组的时候需要跳过node</p> 
<h3>代码</h3> 
<p>class Solution {<!-- --></p> 
<p>public:</p> 
<p>    TreeNode* traversal(vector&lt;int&gt;&amp; nums) {<!-- --></p> 
<p>        if(nums.size() == 0) return nullptr;</p> 
<p>        int maxValue = INT_MIN;</p> 
<p>        for(auto i : nums) {<!-- --></p> 
<p>            maxValue = max(maxValue, i);</p> 
<p>        }</p> 
<p>        TreeNode* node = new TreeNode(maxValue);</p> 
<p>        int pos = 0;</p> 
<p>        for(; pos &lt; nums.size(); pos++) {<!-- --></p> 
<p>            if(nums[pos] == maxValue) break;</p> 
<p>        }</p> 
<p>        vector&lt;int&gt; left(nums.begin(), nums.begin() + pos);</p> 
<p>        vector&lt;int&gt; right(nums.begin() + pos + 1, nums.end());</p> 
<p>        node-&gt;left = traversal(left);</p> 
<p>        node-&gt;right = traversal(right);</p> 
<p>        return node;</p> 
<p>    }</p> 
<p>    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {<!-- --></p> 
<p>        return traversal(nums);</p> 
<p>    }</p> 
<p>};</p> 
<h2 id="_617-合并二叉树">617.合并二叉树</h2> 
<h3>题目</h3> 
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p> 
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p> 
<p>示例 1:</p> 
<p></p> 
<p class="img-center"><img alt="617.合并二叉树" height="594" src="https://images2.imgbox.com/ca/25/kvAEHZLS_o.png" width="964"></p> 
<p>注意: 合并必须从两个树的根节点开始。</p> 
<h3 id="算法公开课">思考</h3> 
<p>想了很久怎么用层序遍历做，卡在了如果tree1和tree2的层数不一样该怎么遍历，看了解题答案发现其实就是把tree1和tree2的两个结点都存入que即可，同时并不需要计算size，因为可以用tree1来代替new TreeNode，这里需要判断四个情况，node1-&gt;left != nullptr &amp;&amp; node2-&gt;left != nullptr、node1-&gt;right != nullptr &amp;&amp; node2-&gt;right != nullptr、node1-&gt;left == nullptr &amp;&amp; node2-&gt;left != nullptr、node1-&gt;right == nullptr &amp;&amp; node2-&gt;right != nullptr。</p> 
<h3>代码</h3> 
<p>class Solution {<!-- --></p> 
<p>public:</p> 
<p>    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {<!-- --></p> 
<p>        if(root1 == nullptr) return root2;</p> 
<p>        if(root2 == nullptr) return root1;</p> 
<p>        queue&lt;TreeNode*&gt; que;</p> 
<p>        que.push(root1);</p> 
<p>        que.push(root2);</p> 
<p>        while(!que.empty()) {<!-- --></p> 
<p>            TreeNode* node1 = que.front();</p> 
<p>            que.pop();</p> 
<p>            TreeNode* node2 = que.front();</p> 
<p>            que.pop();</p> 
<p>            node1-&gt;val += node2-&gt;val;</p> 
<p>            if(node1-&gt;left != nullptr &amp;&amp; node2-&gt;left != nullptr) {<!-- --></p> 
<p>                que.push(node1-&gt;left);</p> 
<p>                que.push(node2-&gt;left);</p> 
<p>            }</p> 
<p>            if(node1-&gt;right != nullptr &amp;&amp; node2-&gt;right != nullptr) {<!-- --></p> 
<p>                que.push(node1-&gt;right);</p> 
<p>                que.push(node2-&gt;right);                    </p> 
<p>            }</p> 
<p>            if(node1-&gt;left == nullptr &amp;&amp; node2-&gt;left != nullptr) node1-&gt;left = node2-&gt;left;</p> 
<p>            if(node1-&gt;right == nullptr &amp;&amp; node2-&gt;right != nullptr) node1-&gt;right = node2-&gt;right;</p> 
<p>            }</p> 
<p>        return root1;</p> 
<p>    }  </p> 
<p>};</p> 
<h2 id="_700-二叉搜索树中的搜索">700.二叉搜索树中的搜索</h2> 
<h3>题目</h3> 
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p> 
<p>例如，</p> 
<p></p> 
<p class="img-center"><img alt="700.二叉搜索树中的搜索" height="646" src="https://images2.imgbox.com/f5/ae/6RcbMk7F_o.png" width="968"></p> 
<p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p> 
<h3>思考</h3> 
<p>开始二叉搜索树啦，其实二叉搜索树定义很简单，一个结点的左子树所有结点都比它小，右子树的所有结点都比它大，本题其实就是找到一个二叉搜索树的子树，如果这个结点大于给定val，那么root = root-&gt;right，如果小于，那么root = root-&gt;left，如果等于就return root; 注意这里要用while(root != null)来做循环持续判断root</p> 
<h3>代码</h3> 
<p>class Solution {<!-- --></p> 
<p>public:</p> 
<p>    TreeNode* searchBST(TreeNode* root, int val) {<!-- --></p> 
<p>        while(root != NULL) {<!-- --></p> 
<p>            if(root-&gt;val &gt; val) root = root-&gt;left;</p> 
<p>            else if(root-&gt;val &lt; val) root = root-&gt; right;</p> 
<p>            else return root;</p> 
<p>        }</p> 
<p>        return NULL;</p> 
<p>    }</p> 
<p>};</p> 
<h2 id="_98-验证二叉搜索树">98.验证二叉搜索树</h2> 
<h3>题目</h3> 
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p> 
<p>假设一个二叉搜索树具有如下特征：</p> 
<ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul> 
<p></p> 
<p class="img-center"><img alt="98.验证二叉搜索树" height="790" src="https://images2.imgbox.com/77/6b/Lvk5bRax_o.png" width="946"></p> 
<h3>思考</h3> 
<p>这题陷入了一个常见的误区，就是没有判断该结点左右子树的所有元素都小于或大于该结点，而仅仅判断了该结点的左右结点，看了卡哥的视频，才发现二叉搜索树需要用中序遍历来写：</p> 
<p>1、用中序遍历来将二叉树变成一个数组，然后判断这个数组是不是递增排布的</p> 
<p>2、创建一个值为最小值的maxValue，用中序遍历来将每一个结点都与maxValue进行判断，如果大于它，那么mavValue的值就被该结点的值取代，如果小于，就return false，因为二叉搜索树左中右是递增关系</p> 
<h3>代码</h3> 
<p>class Solution {<!-- --></p> 
<p>public:</p> 
<p>    long long maxValue = LONG_MIN;</p> 
<p>    bool isValidBST(TreeNode* root) {<!-- --></p> 
<p>        if(root == nullptr) return true;</p> 
<p>        bool left = isValidBST(root-&gt;left);</p> 
<p>        if(root-&gt;val &gt; maxValue) maxValue = root-&gt;val;</p> 
<p>        else return false;</p> 
<p>        bool right = isValidBST(root-&gt;right);</p> 
<p>        return left &amp;&amp; right;</p> 
<p>    }</p> 
<p>};</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb0bf8e3daac0068b6802356455af995/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大模型上下文长度的超强扩展：从LongLoRA到LongQLoRA</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f618fb30318f6a1a42d063c32e11ab99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">题解 | #在二叉树中找到两个节点的最近公共祖先#</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>