<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32Cube的串口设置（二）一个串口接收另一个串口发送 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32Cube的串口设置（二）一个串口接收另一个串口发送" />
<meta property="og:description" content="串口系列
STM32Cube的串口设置（一）即学即用
通过串口设置第一部分大家应该基本会使用单个串口进行收发了
所以本次介绍通过串口进行转发
【适合情景为一个串口设备波特率为38400，但是接收模块仅支持115200波特率】
一、基本思路 在以上情况下，我们就需要两个串口和一个存储位置，在一个串口接收一个信号之后通过MCU转发到另一个串口以不同的波特率输出。
二、操作步骤 要求：通过串口向PC发送一段字符
1、根据自己的stm32的芯片型号来选择，我这里是STM32F767IGTx 2、选好芯片之后照旧设置RCC为外部时钟 3、使能串口1、3（usart1、usart3），如图： 模式设为异步（Asynchronous）其他默认，波特率可以自己改，USART1为115200Bits/s，USART3为38400Bits/s。
之后再使能串口1、3中断
4、设置中断优先级，如图： 设置中断优先级
5、看原理图，找到串口对应引脚，如图： 我这里是
PA10——&gt;USART1_RX PA9——&gt;USART1_TX PB11——&gt;USART3_RX PB10——&gt;USART3_TX 6、根据对应引脚设置串口引脚，如图： 找到PA9、PA10引脚左键点击分别选择USART1_TX和USART1_RX
（不用担心选错选反，针脚的功能是ST公司已经定义好了的）
7、设置时钟树，如图： 这里会搞的按自己习惯搞，不会搞的默认就好，但是不能有里面是红色的框（红色框就是错了意思）
8、项目设置，如图： 红框里的按照自己的Keil版本来
个人喜欢把.c/.h文件分开
9、点击右上角的‘GENERATE CODE’直接生成代码，如图： 10、生成代码后用Keil打开项目并在Application/User中找到usart.c并在/USER CODE BEGIN 0/后添加如下代码，如图： #include &lt;stdio.h&gt; struct __FILE { int handle; }; FILE __stdout; void _sys_exit(int x) { x = x; } int fputc(int ch, FILE *f) { while((USART3-&gt;ISR&amp;0X40)==0); USART3-&gt;TDR=(uint8_t)ch; return ch; } uint16_t USART3_RX_STA=0; uint8_t USART3_RX_BUF[800];//串口转存空间 11、生成代码后用Keil打开项目并在Application/User中找到main." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eb99651f4c6161d706680ea94949276f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-29T10:09:28+08:00" />
<meta property="article:modified_time" content="2019-08-29T10:09:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32Cube的串口设置（二）一个串口接收另一个串口发送</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>串口系列<br> <a href="https://blog.csdn.net/ASWaterbenben/article/details/100041284">STM32Cube的串口设置（一）即学即用</a></p> 
<p>通过串口设置第一部分大家应该基本会使用单个串口进行收发了</p> 
<p>所以本次介绍通过串口进行转发<br> 【适合情景为一个串口设备波特率为38400，但是接收模块仅支持115200波特率】</p> 
<h3><a id="_8"></a>一、基本思路</h3> 
<p>在以上情况下，我们就需要两个串口和一个存储位置，在一个串口接收一个信号之后通过MCU转发到另一个串口以不同的波特率输出。</p> 
<h3><a id="_11"></a>二、操作步骤</h3> 
<p><em><strong>要求：通过串口向PC发送一段字符</strong></em></p> 
<h4><a id="1stm32STM32F767IGTx_13"></a>1、根据自己的stm32的芯片型号来选择，我这里是STM32F767IGTx</h4> 
<p><img src="https://images2.imgbox.com/da/89/3QBrN8SX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2RCC_15"></a>2、选好芯片之后照旧设置RCC为外部时钟</h4> 
<p><img src="https://images2.imgbox.com/b2/02/tSR9lWuz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="313usart1usart3_18"></a>3、使能串口1、3（usart1、usart3），如图：</h4> 
<p>模式设为异步（Asynchronous）其他默认，波特率可以自己改，USART1为115200Bits/s，USART3为38400Bits/s。<br> <img src="https://images2.imgbox.com/49/fd/nBmxbTFs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5c/d0/nZgV64hq_o.png" alt="在这里插入图片描述"><br> 之后再使能串口1、3中断<br> <img src="https://images2.imgbox.com/2b/6e/6o8AA97v_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_24"></a>4、设置中断优先级，如图：</h4> 
<p><img src="https://images2.imgbox.com/d8/a4/iNY3Px75_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/39/99/pFWnbdVk_o.png" alt="在这里插入图片描述"></p> 
<p>设置中断优先级<img src="https://images2.imgbox.com/cd/04/ABo6CsO2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5_29"></a>5、看原理图，找到串口对应引脚，如图：</h4> 
<p>我这里是</p> 
<pre><code>PA10——&gt;USART1_RX  
PA9——&gt;USART1_TX

PB11——&gt;USART3_RX  
PB10——&gt;USART3_TX
</code></pre> 
<p><img src="https://images2.imgbox.com/50/d4/9Mtfti0x_o.png" alt="串口1"><br> <img src="https://images2.imgbox.com/2e/02/5pXBYflh_o.png" alt="串口3"></p> 
<h4><a id="6_40"></a>6、根据对应引脚设置串口引脚，如图：</h4> 
<p>找到PA9、PA10引脚左键点击分别选择USART1_TX和USART1_RX<br> （不用担心选错选反，针脚的功能是ST公司已经定义好了的）<br> <img src="https://images2.imgbox.com/af/e4/IhMLu3fD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ba/38/cjFakAT2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="7_45"></a>7、设置时钟树，如图：</h4> 
<p>这里会搞的按自己习惯搞，不会搞的默认就好，但是不能有里面是红色的框（红色框就是错了意思）<br> <img src="https://images2.imgbox.com/13/4d/NOP2smf4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="8_48"></a>8、项目设置，如图：</h4> 
<p>红框里的按照自己的Keil版本来<br> <img src="https://images2.imgbox.com/6b/23/p41J3XsZ_o.png" alt="在这里插入图片描述"><br> 个人喜欢把.c/.h文件分开<br> <img src="https://images2.imgbox.com/73/a5/sTos5rWX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="9GENERATE_CODE_53"></a>9、点击右上角的‘GENERATE CODE’直接生成代码，如图：</h4> 
<p><img src="https://images2.imgbox.com/f6/ad/kGc4sdOX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="10KeilApplicationUserusartcUSER_CODE_BEGIN_0_55"></a>10、生成代码后用Keil打开项目并在Application/User中找到usart.c并在/<em>USER CODE BEGIN 0</em>/后添加如下代码，如图：</h4> 
<pre><code>#include &lt;stdio.h&gt;
struct __FILE 
{ 
	int handle; 
}; 

FILE __stdout;       
void _sys_exit(int x) 
{ 
	x = x; 
} 
int fputc(int ch, FILE *f)
{ 	
	while((USART3-&gt;ISR&amp;0X40)==0);
	USART3-&gt;TDR=(uint8_t)ch;      
	return ch;
}

uint16_t USART3_RX_STA=0;
uint8_t USART3_RX_BUF[800];//串口转存空间
</code></pre> 
<p><img src="https://images2.imgbox.com/4f/b2/jKQrP4IK_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="11KeilApplicationUsermainc_80"></a>11、生成代码后用Keil打开项目并在Application/User中找到main.c：</h4> 
<p>在/<em>USER CODE BEGIN PV</em>/后添加如下代码</p> 
<pre><code>extern uint8_t USART3_RX_BUF[800];//重申明外部转存空间
</code></pre> 
<p>在/* USER CODE BEGIN WHILE */后添加如下代码</p> 
<pre><code>	HAL_UART_Receive_IT(&amp;huart3,USART3_RX_BUF,1);	
	HAL_UART_Transmit(&amp;huart1,USART3_RX_BUF,sizeof(USART3_RX_BUF),100);
	\\开启中断
</code></pre> 
<p>在/* USER CODE BEGIN 4 */后添加回调函数</p> 
<pre><code>void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{

	if(huart-&gt;Instance == USART3)
	{
		HAL_UART_Transmit(&amp;huart1,USART3_RX_BUF,1,100);//串口1发送接收buff里的东西	
		HAL_UART_Receive_IT(&amp;huart3,USART3_RX_BUF,1);	//重新开启串口3接收中断	
	}
}
</code></pre> 
<p>编译、下载</p> 
<h3><a id="_106"></a>三、实验验证</h3> 
<p>正所谓没有实验结果的教程都是耍流氓，出结果</p> 
<p>目的是USART3接收后通过USART1发送出来，为了正确表达实验内容，首先我将USART3的输入直连在USB，在PC端展示一下USART3的发送内容（这里用了GPS+BD模块）：<br> <img src="https://images2.imgbox.com/0d/cc/MUwLzLRD_o.png" alt="直连"><br> 上图相当于把GPS输出直连USB，所以打开串口调试助手，波特率设置为38400Bits/s<br> <img src="https://images2.imgbox.com/06/90/zKlB4yi2_o.png" alt="串口三接收的数据"><br> 改回原样后重新连接SUART1看情况，USART1的比特率为115200Bits/s，所以串口调试助手波特率也相应进行修改<br> <img src="https://images2.imgbox.com/60/80/3FE6DHjr_o.png" alt="USART1"><br> 可知USART1输出和USART3接收的数据一致，到此试验成功。</p> 
<pre><code>		  Good Game！！！！！！

接下来会推出一系列的关于串口使用的分享，有需要的猿们敬请关注！！！！！
</code></pre> 
<p>以上内容欢迎大家转载引用，标明出处即可！！！！！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b5c1b71434b9e5edacf3368f886bfd3a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">phpStudy &#43; PhpStorm &#43; XDebug调试【绝对能用】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce9198090d8ccdd6f5c7e878dfff2fd3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DOM0级与DOM2级的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>