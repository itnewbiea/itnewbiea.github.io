<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JS对象】看这一篇就够！从实践到底层JS对象详解！ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JS对象】看这一篇就够！从实践到底层JS对象详解！" />
<meta property="og:description" content="目录
一、对象定义的三大方法
1、直接以对象类型定义
2、通过函数构建
3、通过Object构造器自定义
二、对象属性名和属性值的获取与删除
1、获取方法
2、属性删除
3、getters和setters
三、this引用对象
四、对象的继承
1、原型对象和原型链
2、基于原型链的继承方法
3、prototype的使用
五、对象的比较（从内存角度理解）
1、比较对象怪象
2、解释该现象
一、对象定义的三大方法 1、直接以对象类型定义 此方法即是按照我们所理解的对象形式，直接按照{}组织定义，如下：但是这样构造出来的对象无法调用其原型prototype也无法基于原型链创造孩子。
var test={ aIndex:&#39;1&#39;, bIndex:0, cIndex:&#39;hello&#39; displayType : function() { console.log(this.aIndex); } }; 2、通过函数构建 函数方法就是将定义的函数作为对象去处理，如下：
function Car(make, model, year) { this.make = make; this.model = model; this.year = year; //this引用，定义属性的属性值 //也可以定义方法 this.displayType = function() { console.log(this.make); } } var mycar = new Car(&#34;Eagle&#34;, &#34;Talon TSi&#34;, 1993); //创建对象实例 mycar.displayType(); //调用方法 3、通过Object构造器自定义 利用原型对象Object的构造器进行定义，如下：但是这样构造出来的对象无法调用其原型prototype也无法基于原型链创造孩子。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/853c99229106b3f01feb7646f9bbb64f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-12T11:21:55+08:00" />
<meta property="article:modified_time" content="2023-01-12T11:21:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JS对象】看这一篇就够！从实践到底层JS对象详解！</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%96%B9%E6%B3%95" rel="nofollow">一、对象定义的三大方法</a></p> 
<p id="1%E3%80%81%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89" rel="nofollow">1、直接以对象类型定义</a></p> 
<p id="2%E3%80%81%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA" rel="nofollow">2、通过函数构建</a></p> 
<p id="3%E3%80%81%E9%80%9A%E8%BF%87Object%E6%9E%84%E9%80%A0%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E9%80%9A%E8%BF%87Object%E6%9E%84%E9%80%A0%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89" rel="nofollow">3、通过Object构造器自定义</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4" rel="nofollow">二、对象属性名和属性值的获取与删除</a></p> 
<p id="1%E3%80%81%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95" rel="nofollow">1、获取方法</a></p> 
<p id="2%E3%80%81%E5%B1%9E%E6%80%A7%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%B1%9E%E6%80%A7%E5%88%A0%E9%99%A4" rel="nofollow">2、属性删除</a></p> 
<p id="3%E3%80%81getters%E5%92%8Csetters-toc" style="margin-left:80px;"><a href="#3%E3%80%81getters%E5%92%8Csetters" rel="nofollow">3、getters和setters</a></p> 
<p id="%E4%B8%89%E3%80%81this%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81this%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1" rel="nofollow">三、this引用对象</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF" rel="nofollow">四、对象的继承</a></p> 
<p id="1%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="nofollow">1、原型对象和原型链</a></p> 
<p id="2%E3%80%81%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95" rel="nofollow">2、基于原型链的继承方法</a></p> 
<p id="3%E3%80%81prototype%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#3%E3%80%81prototype%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">3、prototype的使用</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E4%BB%8E%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E4%BB%8E%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">五、对象的比较（从内存角度理解）</a></p> 
<p id="1%E3%80%81%E6%AF%94%E8%BE%83%E5%AF%B9%E8%B1%A1%E6%80%AA%E8%B1%A1-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E6%AF%94%E8%BE%83%E5%AF%B9%E8%B1%A1%E6%80%AA%E8%B1%A1" rel="nofollow">1、比较对象怪象</a></p> 
<p id="2%E3%80%81%E8%A7%A3%E9%87%8A%E8%AF%A5%E7%8E%B0%E8%B1%A1-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E8%A7%A3%E9%87%8A%E8%AF%A5%E7%8E%B0%E8%B1%A1" rel="nofollow">2、解释该现象</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%96%B9%E6%B3%95">一、对象定义的三大方法</h3> 
<h4 id="1%E3%80%81%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">1、直接以对象类型定义</h4> 
<p>此方法即是按照我们所理解的对象形式，直接按照{}组织定义，如下：但是这样构造出来的对象无法调用其原型prototype也无法基于原型链创造孩子。</p> 
<pre><code class="language-javascript">var test={
    aIndex:'1',
    bIndex:0,
    cIndex:'hello'
    displayType : function() { 
        console.log(this.aIndex);
    }
};
    </code></pre> 
<h4 id="2%E3%80%81%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA">2、通过函数构建</h4> 
<p>函数方法就是将定义的函数作为对象去处理，如下：</p> 
<pre><code class="language-javascript">function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year; //this引用，定义属性的属性值

  //也可以定义方法
  this.displayType = function() { 
    console.log(this.make);
  }
}

var mycar = new Car("Eagle", "Talon TSi", 1993);  //创建对象实例
mycar.displayType();  //调用方法</code></pre> 
<h4 id="3%E3%80%81%E9%80%9A%E8%BF%87Object%E6%9E%84%E9%80%A0%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89">3、通过Object构造器自定义</h4> 
<p>利用原型对象Object的构造器进行定义，如下：但是这样构造出来的对象无法调用其原型prototype也无法基于原型链创造孩子。</p> 
<pre><code class="language-javascript">var myObj = new Object();

var  str = "myString",
    rand = Math.random(),
    obj = new Object();

//点 法
myObj.type              = "Dot syntax";
myObj.name              = 10;

//索引 法
myObj["date created"]   = "String with space";
myObj[str]              = "String value";
myObj[rand]             = "Random Number";
myObj[obj]              = "Object";
myObj[""]               = "Even an empty string";

console.log(myObj);</code></pre> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4">二、对象属性名和属性值的获取与删除</h3> 
<h4 id="1%E3%80%81%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95">1、获取方法</h4> 
<p>对象的属性名相对来说好获取，属性值一般是在获取到属性名后通过<strong>obj[属性名]</strong>来获得，但也有方法可以直接获取，常用方法如下：</p> 
<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" rel="nofollow" title="for...in">for...in</a> 循环获取属性名   【注意:forEach只能用来<span style="color:#fe2c24;">遍历数组</span>而不可以遍历对象】 <pre><code class="language-javascript">var obj = {a:1, b:2, c:3};

for (var prop in obj) { 
  console.log("obj." + prop + " = " + obj[prop]);
}</code></pre> </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" rel="nofollow" title="Object.keys(o)">Object.keys(o)</a> 获取对象中所有属性名组成的数组，<a class="link-info" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values" rel="nofollow" title="Object.values(o)">Object.values(o)</a> 则用于获取对象中所有属性值组成的数组 <pre><code class="language-javascript">//keys
const object1 = {
  a: 'somestring',
  b: 42,
  c: false
};

console.log(Object.keys(object1)); // expected output: Array ["a", "b", "c"]


//values
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.values(obj)); // ['a', 'b', 'c']</code></pre> <p></p> </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" rel="nofollow" title="Object.getOwnPropertyNames(o)">Object.getOwnPropertyNames(o)</a> 该方法返回对象 <code>o</code> 自身包含的所有属性<span style="color:#fe2c24;"> (无论是否可枚举)</span> 的名称的数组。 <pre><code class="language-javascript">var arr = ["a", "b", "c"];
console.log(Object.getOwnPropertyNames(arr).sort()); // ["0", "1", "2", "length"]

// 类数组对象
var obj = { 0: "a", 1: "b", 2: "c"};
console.log(Object.getOwnPropertyNames(obj).sort()); // ["0", "1", "2"]

// 使用 Array.forEach 输出属性名和属性值
Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) {
  console.log(val + " -&gt; " + obj[val]);
});
// 输出
// 0 -&gt; a
// 1 -&gt; b
// 2 -&gt; c

//不可枚举属性，create是利用了继承的方法，第二个参数中的方法将继承到第一个空对象参数中
var my_obj = Object.create({}, {
  getFoo: {
    value: function() { return this.foo; },
    enumerable: false
  }
});
my_obj.foo = 1;

console.log(Object.getOwnPropertyNames(my_obj).sort());   // ["foo", "getFoo"]</code></pre> </li></ul> 
<p></p> 
<p>注意~：</p> 
<p>上述方法获取到的属性都是对象本身中的，<strong>不包含原型对象/原型链中定义的其他属性和方法</strong></p> 
<p>下文会详细介绍原型对象和原型链</p> 
<h4 id="2%E3%80%81%E5%B1%9E%E6%80%A7%E5%88%A0%E9%99%A4">2、属性删除</h4> 
<p>delete关键字删除即可：</p> 
<pre><code class="language-javascript">//Creates a new object, myobj, with two properties, a and b.
var myobj = new Object;
myobj.a = 5;
myobj.b = 12;

//Removes the a property, leaving myobj with only the b property.
delete myobj.a;</code></pre> 
<h4 id="3%E3%80%81getters%E5%92%8Csetters">3、getters和setters</h4> 
<p>一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" rel="nofollow" title="getter">getter</a> 是一个获取某个特定属性的值的方法。一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" rel="nofollow" title="setter">setter</a> 是一个设定某个属性的值的方法。在对象中定义getter和setter，可以封装对象，实现OOP编程，减少内部成员的直接暴露。</p> 
<p>关于getter和setter的定义方式有如下两种：</p> 
<ul><li>直接构造访问器属性： <pre><code class="language-javascript">var o = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2
  }
};

console.log(o.a); // 7
console.log(o.b); // 8

o.c = 50;  // 可以setter修改

console.log(o.a); // 25</code></pre> </li><li>使用Object.defineProperty方法 <pre><code class="language-javascript">var book = {
    _year: 2004,
    edition: 1
}

Object.defineProperty(book, "year", {
    get: function () {
        return this._year;
    },
    set: function (newValue) {
        if (newValue &gt; 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});

console.log(book._year + "." + book.edition);   // 2004.1

book._year = 1900;

console.log(book._year + "." + book.edition);   //1900.1

book.year = 2005;

console.log(book.year + "." + book.edition);    //2005.2
</code></pre> <p></p> </li></ul> 
<h3 id="%E4%B8%89%E3%80%81this%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">三、this引用对象</h3> 
<p>this指向当前对象，一般应用于与HTML语言结合使用时。我们可以将每个标签理解为一个对象，其中定义的属性都是对象中可获取的属性名和值，那么就可以与JS方法绑定应用啦~看个例子：</p> 
<pre><code class="language-javascript">// 1、this指向标签自身，以参数形式传入绑定的方法中
function validate(obj, lowval, hival) {
  if ((obj.value &lt; lowval) || (obj.value &gt; hival)) {
    alert("Invalid Value!");
  }
}


&lt;input type="text" name="age" size="3"
  onChange="validate(this, 18, 99)"&gt;


// 2、this.form指向父元素form（name="myForm"）,this.form.text1指向父元素下name为text1的元素，所以在获取子元素时，name属性作为元素的键值

&lt;form name="myForm"&gt;
&lt;p&gt;&lt;label&gt;Form name:&lt;input type="text" name="text1" value="Beluga"&gt;&lt;/label&gt;
&lt;p&gt;&lt;input name="button1" type="button" value="Show Form Name"
     onclick="this.form.text1.value = this.form.name"&gt;
&lt;/p&gt;
&lt;/form&gt;

</code></pre> 
<h3 id="%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF">四、对象的继承</h3> 
<p>对象的继承，是基于原型（链）的继承。</p> 
<h4 id="1%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE">1、原型对象和原型链</h4> 
<p>JavaScript 是动态的，本身不提供一个 <code>class</code> 的实现。即便是在 ES2015/ES6 中引入了 <code>class</code> 关键字，但那也只是<strong>语法糖（语法的简洁表达）</strong>，JavaScript 仍然是基于原型的。所以当谈到继承时，JavaScript 只有一种结构：对象。</p> 
<p>每个实例对象（object）都有一个私有属性（称之为 <strong>__proto__ </strong>）指向它的构造函数的原型对象（<strong>prototype</strong>）。该原型对象也有一个自己的原型对象（__proto__），层层向上直到一个对象的原型对象为 <strong><code>null</code></strong>。这种对象间的层级关系就构成了原型链， 且原型链的终端是null。</p> 
<p>像数组(array）、字符串（string）这两个JS基本数据类型，用typeof 关键字打印出的其类型为object</p> 
<pre><code class="language-javascript">var s="ssss";
console.log(typeof s);  //object

var arr=[1,2,3];
console.log(typeof arr); //object</code></pre> 
<p>这是因为<strong>数组和字符串的原型对象为Object,是从object对象中继承而来的。</strong></p> 
<p>所以如果要准确区分出数据类型究竟是数组、字符串还是对象，需要用<span style="color:#fe2c24;"><strong>Object.prototype.toString.call(obj)方法</strong></span></p> 
<pre><code class="language-javascript">console.log(Object.prototype.toString.call("jerry"));//[object String]
console.log(Object.prototype.toString.call(12));//[object Number]
console.log(Object.prototype.toString.call(true));//[object Boolean]
console.log(Object.prototype.toString.call(undefined));//[object Undefined]
console.log(Object.prototype.toString.call(null));//[object Null]
console.log(Object.prototype.toString.call({name: "jerry"}));//[object Object]
console.log(Object.prototype.toString.call(function(){}));//[object Function]
console.log(Object.prototype.toString.call([]));//[object Array]
console.log(Object.prototype.toString.call(new Date));//[object Date]
console.log(Object.prototype.toString.call(/\d/));//[object RegExp]

function Person(){};
console.log(Object.prototype.toString.call(new Person));//[object Object]
</code></pre> 
<h4></h4> 
<h4 id="2%E3%80%81%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95">2、基于原型链的继承方法</h4> 
<ul><li><strong>new方法</strong></li></ul> 
<p>比如以下两个对象doSomething 和 doSomeInstancing之间就存在继承，其中 doSomeInstancing是通过new 一个doSomething对象的实例构造出来的，会继承doSomething对象中的属性和方法</p> 
<pre><code class="language-javascript">function doSomething(){}
doSomething.prototype.foo = "bar"; // add a property onto the prototype
var doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value"; // add a property onto the object
console.log( doSomeInstancing );
</code></pre> 
<p>查看doSomeInstancing对象结构，如下：</p> 
<pre><code class="language-javascript">{
    prop: "some value",
    __proto__: {
        foo: "bar",
        constructor: ƒ doSomething(),
        __proto__: {
            constructor: ƒ Object(),
            hasOwnProperty: ƒ hasOwnProperty(),
            isPrototypeOf: ƒ isPrototypeOf(),
            propertyIsEnumerable: ƒ propertyIsEnumerable(),
            toLocaleString: ƒ toLocaleString(),
            toString: ƒ toString(),
            valueOf: ƒ valueOf()
        }
    }
}
</code></pre> 
<p>可见原型链由下至上为 doSomeInstancing -&gt;  doSomething -&gt; Object</p> 
<p></p> 
<ul><li><strong>使用Object.create()方法基于原型创建新对象</strong></li></ul> 
<p>该方法是基于现有对象为原型创建新的对象，语法参数如下：</p> 
<pre><code class="language-javascript">Object.create(proto)
Object.create(proto, propertiesObject)
</code></pre> 
<p><img alt="" height="358" src="https://images2.imgbox.com/38/a6/GeNSLMVT_o.png" width="1151"></p> 
<p> 分别举一个例子：</p> 
<pre><code class="language-javascript">// 无第二个参数
var a = {test: 1};

var b = Object.create(a);   //原型链为: b ---&gt; a ---&gt; Object.prototype ---&gt; null
console.log(b.test); // 1 (从对象a中继承而来)


//有第二个参数
var o = Object.create(null, {
  foo: {
    writable: true,
    configurable: true,
    value: 'hello'
  },
  bar: 'myBar',
});</code></pre> 
<h4 id="3%E3%80%81prototype%E7%9A%84%E4%BD%BF%E7%94%A8">3、prototype的使用</h4> 
<p>下述例子中，通过 <code>prototype</code>属性给之前定义的Car对象类型增加color属性。这为继承Car类型的所有对象都增加了color属性。但如果子对象自己又定义了color属性的属性值，则会覆盖之前继承而来的color属性值。</p> 
<pre><code class="language-javascript">function Car(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year; //this引用，定义属性的属性值

    //也可以定义方法
    this.displayType = function () {
        console.log(this.make);
    }
}

Car.prototype.color = "black";    //原型对象加属性

var mycar = new Car("Eagle", "Talon TSi", 1993);  //Car类型实例1
mycar.color = "white";
console.log(mycar.color);    //输出white  

var t = new Car("Eagle", "Talon TSi", 1993);  //Car类型实例2
console.log(t.color);       //输出black  color属性继承而来</code></pre> 
<h3></h3> 
<h3 id="%E4%BA%94%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E4%BB%8E%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%EF%BC%89">五、对象的比较（从内存角度理解）</h3> 
<h4 id="1%E3%80%81%E6%AF%94%E8%BE%83%E5%AF%B9%E8%B1%A1%E6%80%AA%E8%B1%A1">1、比较对象怪象</h4> 
<p>在 JavaScript 中 objects 是一种<strong>引用类型</strong>。<span style="color:#fe2c24;">两个独立声明的对象永远也不会相等</span>，即使他们有相同的属性，只有在比较一个对象和这个对象的引用时，才会返回 true.</p> 
<pre><code class="language-javascript">// 两个变量，两个具有同样的属性、但不相同的对象
var fruit = {name: "apple"};
var fruitbear = {name: "apple"};

fruit == fruitbear // return false
fruit === fruitbear // return false
</code></pre> 
<p>如果为引用，</p> 
<pre><code class="language-javascript">// 两个变量，同一个对象
var fruit = {name: "apple"};
var fruitbear = fruit;  // 将 fruit 的对象引用(reference) 赋值给 fruitbear
                        // 也称为将 fruitbear“指向”fruit 对象
// fruit 与 fruitbear 都指向同样的对象
fruit == fruitbear // return true
fruit === fruitbear // return true
</code></pre> 
<h4 id="2%E3%80%81%E8%A7%A3%E9%87%8A%E8%AF%A5%E7%8E%B0%E8%B1%A1">2、解释该现象</h4> 
<p>导致上述现象的主要原因是对象其实赋值给变量的不是值，而是内存地址。因此<strong>我们比较对象时不仅比较内容，还比较着变量地址</strong>。这就是对象作为引用类型的特别之处。</p> 
<p>我们知道，JS中有七种基本数据类型（number string object等等），这七种基本数据类型又可以按照存储方式分为两大类型：<strong>原始类型和引用类型。</strong>这两个究竟有啥区别呢？</p> 
<p>首先我们要了解，JS内存分为三大块：<strong>代码空间、栈空间、堆空间</strong>。而原始类型保存在栈空间，引用类型保存堆空间。这就导致我们定义变量时，Javascript引擎将自动把不同类型的变量分配到合适的空间内。</p> 
<p>如，有以下代码：</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/7a/2d/Kfc5bB8j_o.png" width="420"></p> 
<p> 解析后变量环境存储情况为：</p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/35/a1/WTI3wtqZ_o.png" width="564"></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/320cb0768a61d7cd3cfc90274abe13fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">elementui的表格实现滚动到底部加载更多</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85e6160f92527c504f49154f3c82b10d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">arthas热更新代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>