<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaWeb知识点小结: - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaWeb知识点小结:" />
<meta property="og:description" content="什么是Maven坐标： Maven坐标是Maven中的一个重要概念，用于唯一标识一个Maven项目的依赖关系。
什么是坐标： Maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置使用坐标来定义当前项目或引入项目中需要的依赖 它由以下几部分组成： groupId标识项目所属的组织或者公司，一般是倒序的域名，例如org.apache.maven；artifactId标识项目的唯一标识符，例如maven-core；version表示项目的版本号 Maven生命周期： Maven生命周期，也叫lifecycle，是Maven对构建过程的抽象。它通过定义一系列阶段来组织和管理构建任务，这些阶段依次执行，以完成从清理、初始化、编译、测试、打包、集成测试、验证、部署到生成站点等几乎所有构建步骤。
具体来说，Maven的生命周期可以划分为以下三个主要阶段：
Clean生命周期：这一阶段的目标是清理项目，移除所有上一次构建生成的文件。它进一步分为pre-clean（执行一些需要在clean之前完成的工作）、clean（执行清理操作）和post-clean（执行一些需要在clean之后立刻完成的工作）三个子阶段。
Default生命周期（也称为Build生命周期）：这是Maven的主要生命周期，被用于构建应用。这个阶段包括了诸如验证项目的正确性（validate），编译项目的源代码（compile），运行项目的单元测试（test），将编译后的代码打包成可分发的格式（package），对项目进行额外的检查以确保质量（verify），以及将项目的构建结果安装到本地Maven仓库中，以供其他项目使用（install）等一系列步骤。
Site生命周期：这个阶段的目标是生成项目站点，包含了如报告生成，文档生成等步骤。
值得注意的是，Maven的生命周期是抽象的，因此它不做任何的实际工作，所有的任务都由插件（plugin）完成。
HTTP-请求数据格式： 请求方式-GET： 请求参数在请求行中，没有请求体，如: /brand/findAll?name=OPPO&amp;staus=1。GET请求大小是有限制的。
请求方式-POST： 请求参数在请求体中，POST请求大小是没有限制的。
两种请求方式的异同： 在HTTP请求中，GET和POST是两种最常被使用的请求方式。GET是从指定的资源请求数据，而POST则是向指定的资源提交要被处理的数据。
原理上，GET和HEAD方法被称为安全方法，因为它们不会修改服务器上的信息。这意味着使用GET和HEAD的HTTP请求不会在服务器上产生任何实质性的结果。然而，这并不意味着这些安全方法不会执行任何操作，只是它们不会修改信息。相较之下，根据HTTP规范，POST可能会修改服务器上的资源。
此外，GET和POST方法在使用上有一些明显的区别。例如，GET提交参数一般会显示在URL上，而POST通过表单提交，其内容则不会显示在URL上，因此POST更具隐蔽性。同时，GET请求可被缓存、保留在浏览器历史记录中、收藏为书签，但不应该在处理敏感数据时使用。相对地，POST方法不能被缓存、收藏为书签或保留在浏览器历史记录中。
从实际应用的角度来看，由于GET请求把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，因此在URL中可以看到。与此相反，POST方法是通过HTTP post机制，将表单内各个字段与其内容一起传送到ACTION属性所指的URL地址，对于用户来说这个过程是看不到的。
最后，需要注意的是，虽然理论上GET和POST方法都没有数据量限制，但实际上受浏览器、操作系统以及服务器的限制，GET传送的数据量较小，一般不能大于2KB；而POST传送的数据量较大，通常被默认为不受限制。
请求相应介绍-HTTP响应格式： HTTP 状态码分类 HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：
1XX响应中-临时状态码，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它2XX 成功-表示请求已经被成功接受，处理已完成
3XX重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理4XX客户端错误--处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等5XX服务器端错误--处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 HTTP状态码列表: 着重记住：
200：客户端请求成功
404：请求资源不存在，一般是URL输入有误，或者网站资源被删除了
500：服务端发生不可预期的错误
为什么使用list请求参数t时一定要加上@RequestParm？ 在Spring MVC中，@RequestParam注解用于将请求参数绑定到方法参数上。当你使用List&lt;String&gt; hobby作为方法参数时，Spring会自动将请求中的多个相同名称的参数值收集到一个列表中，并将这个列表作为hobby参数的值。
如果不使用@RequestParam注解，Spring无法正确地将请求参数绑定到方法参数上。例如，如果你的请求URL是/listParam?hobby=reading&amp;hobby=swimming，如果没有使用@RequestParam注解，那么hobby参数的值将会是一个包含两个字符串&#34;reading&#34;和&#34;swimming&#34;的列表，而不是一个只包含一个字符串&#34;reading,swimming&#34;的列表。
因此，为了确保请求参数能够正确地绑定到方法参数上，你需要在方法参数前加上@RequestParam注解。
Spring框架中IOC中常用注解： bean是什么？ Bean 是一个由 Spring IoC（控制反转）容器管理的对象。Spring Boot 使用注解来定义和配置 Bean，这些注解包括 @Component、@Service、@Repository、@Controller 等。
当 Spring Boot 启动时，它会扫描项目中的类，查找带有特定注解的类，并将这些类实例化为 Bean。然后，Spring IoC 容器会管理这些 Bean，负责它们的生命周期和依赖注入。
依赖注入的注解：
@Autowired：默认按照类型自动装配
如果同类型的bean存在多个： @Primary 在同类型的类名之前，添加该注解，会提高该类的优先级@Avutowired &#43; @Qualifer(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8d97e6cd8d87bdb01b80f9dcaefc2b35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-07T17:19:31+08:00" />
<meta property="article:modified_time" content="2023-12-07T17:19:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaWeb知识点小结:</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>什么是Maven坐标：</h4> 
<p>Maven坐标是Maven中的一个重要概念，用于唯一标识一个Maven项目的依赖关系。</p> 
<h5>什么是坐标：</h5> 
<ul><li>Maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置</li><li>使用坐标来定义当前项目或引入项目中需要的依赖</li></ul> 
<h5>它由以下几部分组成：</h5> 
<ul><li>groupId标识项目所属的组织或者公司，一般是倒序的域名，例如org.apache.maven；</li><li>artifactId标识项目的唯一标识符，例如maven-core；</li><li>version表示项目的版本号</li></ul> 
<h4>Maven生命周期：</h4> 
<p>Maven生命周期，也叫lifecycle，是Maven对构建过程的抽象。它通过定义一系列阶段来组织和管理构建任务，这些阶段依次执行，以完成从清理、初始化、编译、测试、打包、集成测试、验证、部署到生成站点等几乎所有构建步骤。</p> 
<p>具体来说，Maven的生命周期可以划分为以下三个主要阶段：</p> 
<ol><li> <p>Clean生命周期：这一阶段的目标是清理项目，移除所有上一次构建生成的文件。它进一步分为pre-clean（执行一些需要在clean之前完成的工作）、clean（执行清理操作）和post-clean（执行一些需要在clean之后立刻完成的工作）三个子阶段。</p> </li><li> <p>Default生命周期（也称为Build生命周期）：这是Maven的主要生命周期，被用于构建应用。这个阶段包括了诸如验证项目的正确性（validate），编译项目的源代码（compile），运行项目的单元测试（test），将编译后的代码打包成可分发的格式（package），对项目进行额外的检查以确保质量（verify），以及将项目的构建结果安装到本地Maven仓库中，以供其他项目使用（install）等一系列步骤。</p> </li><li> <p>Site生命周期：这个阶段的目标是生成项目站点，包含了如报告生成，文档生成等步骤。</p> </li></ol> 
<p>        值得注意的是，Maven的生命周期是抽象的，因此它不做任何的实际工作，所有的任务都由插件（plugin）完成。</p> 
<h4>HTTP-请求数据格式：</h4> 
<h5>请求方式-GET：</h5> 
<p>        请求参数在请求行中，没有请求体，如: /brand/findAll?name=OPPO&amp;staus=1。GET请求大小是有限制的。</p> 
<h5>请求方式-POST：</h5> 
<p>        请求参数在请求体中，POST请求大小是没有限制的。</p> 
<h5>两种请求方式的异同：</h5> 
<p>        在HTTP请求中，GET和POST是两种最常被使用的请求方式。GET是从指定的资源请求数据，而POST则是向指定的资源提交要被处理的数据。</p> 
<p>        原理上，<strong>GET和HEAD方法被称为安全方法</strong>，因为它们不会修改服务器上的信息。这意味着使用GET和HEAD的HTTP请求不会在服务器上产生任何实质性的结果。然而，这并不意味着这些安全方法不会执行任何操作，只是它们不会修改信息。相较之下，根据HTTP规范，<strong>POST可能会修改服务器上的资源</strong>。</p> 
<p>        此外，GET和POST方法在使用上有一些明显的区别。例如，GET提交参数一般会显示在URL上，而POST通过表单提交，其内容则不会显示在URL上，因此<strong>POST更具隐蔽性</strong>。同时，GET请求可被缓存、保留在浏览器历史记录中、收藏为书签，但不应该在处理敏感数据时使用。相对地，POST方法不能被缓存、收藏为书签或保留在浏览器历史记录中。</p> 
<p>        从实际应用的角度来看，由于GET请求把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，因此在URL中可以看到。与此相反，POST方法是通过HTTP post机制，将表单内各个字段与其内容一起传送到ACTION属性所指的URL地址，对于用户来说这个过程是看不到的。</p> 
<p>        最后，需要注意的是，虽然理论上GET和POST方法都没有数据量限制，但实际上受浏览器、操作系统以及服务器的限制，<strong>GET</strong>传送的数据量较小，一般<strong>不能大于2KB</strong>；而<strong>POST</strong>传送的数据量较大，通常被默认为<strong>不受限制</strong>。</p> 
<h4>请求相应介绍-HTTP响应格式：</h4> 
<h5>HTTP 状态码分类</h5> 
<p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td>1XX</td><td><strong>响应中</strong>-临时状态码，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2XX</td><td> <p><strong>成功</strong>-表示请求已经被成功接受，处理已完成</p> </td></tr><tr><td>3XX</td><td><strong>重定</strong>向-重定向到其他地方；让客户端再发起一次请求以完成整个处理</td></tr><tr><td>4XX</td><td><strong>客户端错误</strong>--处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5XX</td><td><strong>服务器端错误</strong>--处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table> 
<h5>HTTP状态码列表:</h5> 
<p class="img-center"><img alt="" height="319" src="https://images2.imgbox.com/90/c2/MsEXyUgx_o.png" width="550"></p> 
<p class="img-center"><img alt="" height="283" src="https://images2.imgbox.com/52/bf/OQ5x0RYS_o.png" width="555"></p> 
<p></p> 
<p class="img-center"><img alt="" height="465" src="https://images2.imgbox.com/c6/25/VF4H5XmE_o.png" width="559"></p> 
<p class="img-center"><img alt="" height="391" src="https://images2.imgbox.com/38/40/FTkN6eZo_o.png" width="554"></p> 
<p> 着重记住：</p> 
<p>200：客户端请求成功</p> 
<p>404：请求资源不存在，一般是URL输入有误，或者网站资源被删除了</p> 
<p>500：服务端发生不可预期的错误</p> 
<h5>为什么使用list请求参数t时一定要加上@RequestParm？</h5> 
<p>         在Spring MVC中，<code>@RequestParam</code>注解用于将请求参数绑定到方法参数上。当你使用<code>List&lt;String&gt; hobby</code>作为方法参数时，Spring会自动将请求中的多个相同名称的参数值收集到一个列表中，并将这个列表作为<code>hobby</code>参数的值。</p> 
<p>        如果不使用<code>@RequestParam</code>注解，Spring无法正确地将请求参数绑定到方法参数上。例如，如果你的请求URL是<code>/listParam?hobby=reading&amp;hobby=swimming</code>，如果没有使用<code>@RequestParam</code>注解，那么<code>hobby</code>参数的值将会是一个包含两个字符串"reading"和"swimming"的列表，而不是一个只包含一个字符串"reading,swimming"的列表。</p> 
<p>        因此，为了确保请求参数能够正确地绑定到方法参数上，你需要在方法参数前加上<code>@RequestParam</code>注解。</p> 
<h4>Spring框架中IOC中常用注解：</h4> 
<h5>bean是什么？</h5> 
<p>        Bean 是一个由 Spring IoC（控制反转）容器管理的对象。Spring Boot 使用注解来定义和配置 Bean，这些注解包括 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等。</p> 
<p>        当 Spring Boot 启动时，它会扫描项目中的类，查找带有特定注解的类，并将这些类实例化为 Bean。然后，Spring IoC 容器会管理这些 Bean，负责它们的生命周期和依赖注入。</p> 
<p> 依赖注入的注解：</p> 
<p>@Autowired：默认按照类型自动装配</p> 
<h5>如果同类型的bean存在多个：</h5> 
<ul><li>@Primary 在同类型的类名之前，添加该注解，会提高该类的优先级</li><li>@Avutowired + @Qualifer("bean的名称")</li><li>@Resource(name="bean的名称")</li></ul> 
<p>一般bean的名称是使用类名的首字母小写的形式指定：类如我们有一个名为 <code>UserService</code> 的类，它可能包含一些业务逻辑方法。此时的bean名为：userService</p> 
<h5><strong>@Resource 与 @Autowired的区别：</strong></h5> 
<ol><li>来源不同：<code>@Autowired</code> 是 <strong>Spring 框架提供</strong>的注解，而 <strong><code>@Resource</code> 是 JDK</strong>（Java 开发套件）提供的注解，它来自于 JSR-250（Java 250 规范提案）。</li><li>默认注入方式不同：<code>@Autowired</code> 默认的注入方式是<strong>按类型</strong>（ByType），而 <code>@Resource</code> 默认的注入方式是<strong>按名称</strong>（ByName）。</li><li> <p>支持的参数不同：<code>@Autowired</code> 注解只支持 byType 和 byName 两种方式的自动装配，而 <code>@Resource</code> 注解除了支持 byName 和 byType 外，还支持通过字段名或设置方法名来指定名称进行装配。</p> </li><li> <p>@Autowired 还可用于类成员变量、方法及构造函数的标注完成自动装配的工作，而 @Resource 在语义上被定义为通过其唯一的名称来标识特定的目标组件，其中声明的类型与匹配过程无关。</p> </li></ol> 
<h5>在Spring框架中，Mapper、Service和Controller指的是：</h5> 
<ol><li> <p>Mapper：Mapper是一个接口，用于定义数据库操作的方法。它通常与MyBatis框架一起使用，将SQL语句映射到Java方法上。Mapper接口中的每个方法对应一个SQL语句，通过传入的参数来执行相应的数据库操作。</p> </li><li> <p>Service：Service是一个接口或类，用于处理业务逻辑。它通常包含一些业务方法，如添加、删除、更新和查询等。Service接口或类可以调用Mapper接口中定义的方法来完成具体的数据库操作。</p> </li><li> <p>Controller：Controller是一个控制器类，用于处理HTTP请求。它通常包含一些处理请求的方法，如GET、POST、PUT和DELETE等。Controller类可以调用Service接口中定义的方法来完成具体的业务逻辑处理。同时，Controller类还可以返回视图（View）给客户端，展示数据给用户。</p> </li></ol> 
<h4>Java配置属性：</h4> 
<p>优先级(低  - -&gt; 高)</p> 
<ul><li>application.yaml(忽略)</li><li>application.yml</li><li>application.properties</li><li>java系统属性(-Dxxx=xxxx)</li><li>命令行参数(---xxx=xxx)</li></ul> 
<h5>bean的作用域以及配置：</h5> 
<p>在Spring框架中，bean的作用域决定了bean的生命周期和创建方式。Spring支持多种作用域类型，具体如下：</p> 
<ul><li>singleton：这是默认的作用域类型，这种类型的bean在整个应用程序中只有一个实例。Spring IoC容器只会创建一个共享的bean实例。对于所有的bean请求，只要id与该bean定义的相匹配，那么Spring在每次需要时都返回同一个bean实例。</li><li>prototype：这种作用域意味着每次请求都会创建一个新的bean实例。</li><li>request、session、globalSession：这些作用域分别表示在一次HTTP请求、一个HTTP会话和全局会话中的bean。它们在Web应用中使用较多。</li><li>application：在一个Web应用中，一个application context对应一个application bean，它会在所有用户间共享。它与singleton很相似，但启动时机不同。</li><li>websocket：这个作用域是为WebSocket通信设计的，它允许每个WebSocket连接有一个独立的bean实例。</li></ul> 
<h5>bean的作用域中Lazy注解的使用：</h5> 
<p>        在Spring框架中，"@Lazy"注解被用于延迟加载bean。它作用于"singleton"作用域的bean，意味着这些bean在Spring IoC容器启动时不会被立即实例化，而只有在第一次被使用时才进行实例化。</p> 
<p>        这种延迟加载的特性可以解决一些特定问题，比如循环依赖问题。因为在bean的生命周期中，如果A依赖于B，B又依赖于C，而C又依赖于A，那么就形成了循环依赖。如果没有有效的解决机制，将会导致程序无法正常运行。使用"@Lazy"注解可以推迟bean的创建和初始化过程，从而为解决这类问题提供了可能。</p> 
<p>        需要注意的是，"@Lazy"注解只对"singleton"作用域的bean有效。对于"prototype"作用域的bean，每次通过getBean获取该bean都会新产生一个实例，因此没有必要使用延迟加载。</p> 
<h5>Gson的作用：</h5> 
<p>        Gson是Google公司发布的一个开放源代码的Java库，主要用于在Java对象和JSON数据之间进行映射。其主要功能包括将Json字符转成一个Java对象，以及将Java对象转化为Json字符串。Gson是目前功能最强的JSON解析器之一，并且不需要依赖额外的jar包，能够直接运行在Java平台。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e33f23ca06a5f9d5dedae7536460b70/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【STM32单片机】简易电子琴设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d082115837c65323f0fdd98d4e9e1cbc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">flex布局的flex为1到底是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>