<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue3.0 新特性以及使用经验总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue3.0 新特性以及使用经验总结" />
<meta property="og:description" content="前言 Vue3.0 在去年 9 月正式发布了，看大家都有在热情的拥抱 Vue3.0。今年初新项目也开始使用 Vue3.0 来开发，这篇文章就是在使用后的一个总结， 包含 Vue3 新特性的使用以及一些使用经验分享。
为什么要升级 Vue3 使用 Vue2.x 的小伙伴都熟悉，Vue2.x 中所有数据都是定义在data中，方法定义在methods中的，并且使用this来调用对应的数据和方法。那 Vue3.x 中就可以不这么玩了， 具体怎么玩我们后续再说， 先说一下 Vue2.x 版本这么写有什么缺陷，所有才会进行升级变更的。
回顾 Vue2.x 实现加减 &lt;template&gt; &lt;div class=&#34;homePage&#34;&gt; &lt;p&gt;count: {{ count }}&lt;/p&gt; &lt;p&gt;倍数： {{ multiple }}&lt;/p&gt; &lt;div&gt; &lt;button style=&#34;margin-right: 10px&#34; @click=&#34;increase&#34;&gt;加1&lt;/button&gt; &lt;button @click=&#34;decrease&#34;&gt;减一&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { count: 0 }; }, computed: { multiple() { return 2 * this.count; }, }, methods: { increase() { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a2ea57189c6b52ef5bd225730cdc88f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-08T10:55:17+08:00" />
<meta property="article:modified_time" content="2023-10-08T10:55:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue3.0 新特性以及使用经验总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body"> 
 <div> 
  <h3>前言</h3> 
  <p>Vue3.0 在去年 9 月正式发布了，看大家都有在热情的拥抱 Vue3.0。今年初新项目也开始使用 Vue3.0 来开发，这篇文章就是在使用后的一个总结， 包含 Vue3 新特性的使用以及一些使用经验分享。</p> 
  <p><img alt="" src="https://images2.imgbox.com/23/fc/IpErqZa5_o.png"></p> 
  <h3>为什么要升级 Vue3</h3> 
  <p>使用 Vue2.x 的小伙伴都熟悉，Vue2.x 中所有数据都是定义在<code>data</code>中，方法定义在<code>methods</code>中的，并且使用<code>this</code>来调用对应的数据和方法。那 Vue3.x 中就可以不这么玩了， 具体怎么玩我们后续再说， 先说一下 Vue2.x 版本这么写有什么缺陷，所有才会进行升级变更的。</p> 
  <h4>回顾 Vue2.x 实现加减</h4> 
  <pre class="has"><code>&lt;template&gt;
  &lt;div class="homePage"&gt;
    &lt;p&gt;count: {<!-- -->{ count }}&lt;/p&gt;   
    &lt;p&gt;倍数： {<!-- -->{ multiple }}&lt;/p&gt;        
    &lt;div&gt;
      &lt;button style="margin-right: 10px" @click="increase"&gt;加1&lt;/button&gt;
      &lt;button @click="decrease"&gt;减一&lt;/button&gt;    
    &lt;/div&gt;      
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return { count: 0 };
  },
  computed: {
    multiple() {
      return 2 * this.count;
    },
  },
  methods: {
    increase() {
      this.count++;
    },
    decrease() {
      this.count--;
    },
  },
};
&lt;/script&gt;复制代码</code></pre> 
  <p>上面代码只是实现了对<code>count</code>的加减以及显示倍数， 就需要分别在 data、methods、computed 中进行操作，当我们增加一个需求，就会出现下图的情况：</p> 
  <p><img alt="" src="https://images2.imgbox.com/b3/d7/5bQv265e_o.png"></p> 
  <p>当我们业务复杂了就会大量出现上面的情况， 随着复杂度上升，就会出现这样一张图， 每个颜色的方块表示一个功能：</p> 
  <p><img alt="" src="https://images2.imgbox.com/fe/12/Viq881GP_o.png"></p> 
  <p>甚至一个功能还有会依赖其他功能，全搅合在一起。</p> 
  <p>当这个组件的代码超过几百行时，这时增加或者修改某个需求， 就要在 data、methods、computed 以及 mounted 中反复的跳转，这其中的的痛苦写过的都知道。</p> 
  <p>那我们就想啊， 如果可以按照逻辑进行分割，将上面这张图变成下边这张图，是不是就清晰很多了呢, 这样的代码可读性和可维护性都更高：</p> 
  <p><img alt="" src="https://images2.imgbox.com/e4/89/vaXiibxK_o.png"></p> 
  <p>那么 vue2.x 版本给出的解决方案就是 Mixin, 但是使用 Mixin 也会遇到让人苦恼的问题：</p> 
  <ol><li>命名冲突问题</li><li>不清楚暴露出来的变量的作用</li><li>逻辑重用到其他 component 经常遇到问题</li></ol> 
  <p>关于上面经常出现的问题我就不一一举例了，使用过的小伙伴多多少少都会遇到。文章的重点不是 Mixin, 如果确实想知道的就留言啦~</p> 
  <p>所以，我们 Vue3.x 就推出了<code>Composition API</code>主要就是为了解决上面的问题，将零散分布的逻辑组合在一起来维护，并且还可以将单独的功能逻辑拆分成单独的文件。接下来我们就重点认识<code>Composition API</code>。</p> 
  <h3>Composition API</h3> 
  <p><img alt="" src="https://images2.imgbox.com/c5/91/CQiLEiEb_o.png"></p> 
  <h4>setup</h4> 
  <p>setup 是 Vue3.x 新增的一个选项， 他是组件内使用 <code>Composition API</code>的入口。</p> 
  <p><strong>setup 执行时机</strong></p> 
  <p>我在学习过程中看到很多文章都说 setup 是在 <code>beforeCreate</code>和<code>created</code>之间， 这个结论是错误的。实践是检验真理的唯一标准， 于是自己去检验了一下：</p> 
  <pre class="has"><code>export default defineComponent({
  beforeCreate() {
    console.log("----beforeCreate----");
  },
  created() {
    console.log("----created----");
  },
  setup() {
    console.log("----setup----");
  },
});复制代码</code></pre> 
  <p><img alt="" src="https://images2.imgbox.com/22/da/sKqcWkvs_o.png"></p> 
  <p>setup 执行时机是在 beforeCreate 之前执行，详细的可以看后面生命周期讲解。</p> 
  <h5>setup 参数</h5> 
  <p>使用<code>setup</code>时，它接受两个参数：</p> 
  <ol><li>props: 组件传入的属性</li><li>context</li></ol> 
  <p>setup 中接受的<code>props</code>是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以<strong>不可以使用 ES6 解构</strong>，解构会消除它的响应式。 <strong>错误代码示例</strong>， 这段代码会让 props 不再支持响应式：</p> 
  <pre class="has"><code>// demo.vue
export default defineComponent ({
    setup(props, context) {
        const { name } = props
        console.log(name)
    },
})复制代码</code></pre> 
  <p>那在开发中我们<strong>想要使用解构，还能保持<code>props</code>的响应式</strong>，有没有办法解决呢？大家可以思考一下，在后面<code>toRefs</code>学习的地方为大家解答。 接下来我们来说一下<code>setup</code>接受的第二个参数<code>context</code>，我们前面说了<code>setup</code>中不能访问 Vue2 中最常用的<code>this</code>对象，所以<code>context</code>中就提供了<code>this</code>中最常用的三个属性：<code>attrs</code>、<code>slot</code> 和<code>emit</code>，分别对应 Vue2.x 中的 <code>$attr</code>属性、<code>slot</code>插槽 和<code>$emit</code>发射事件。并且这几个属性都是自动同步最新的值，所以我们每次使用拿到的都是最新值。</p> 
  <h4>reactive、ref 与 toRefs</h4> 
  <p>在 vue2.x 中， 定义数据都是在<code>data</code>中， 但是 Vue3.x 可以使用<code>reactive</code>和<code>ref</code>来进行数据定义。 那么<code>ref</code>和<code>reactive</code>他们有什么区别呢？分别什么时候使用呢？说到这里，我又不得不提一下，看到很多网上不少文章说 (<code>reactive</code>用于处理对象的双向绑定，<code>ref</code>则处理 js 基础类型的双向绑定)。我其实不太赞同这样的说法，这样很容易初学者认为<code>ref</code>就能处理 js 基本类型， 比如<code>ref</code>也是可以定义对象的双向绑定的啊， 上段代码：</p> 
  <pre class="has"><code>setup() {
    const obj = ref({count:1, name:"张三"})
    setTimeout(() =&gt;{
        obj.value.count = obj.value.count + 1
        obj.value.name = "李四"
    }, 1000)
    return{
        obj
    }
  }复制代码</code></pre> 
  <p>我们将<code>obj.count</code>和<code>obj.name</code>绑定到页面上也是可以的；但是<code>reactive</code>函数确实可以代理一个对象， 但是不能代理基本类型，例如字符串、数字、boolean 等。 接下来使用代码展示一下<code>ref</code>、<code>reactive</code>的使用： <img alt="" src="https://images2.imgbox.com/7f/bf/v1zpDrT4_o.png"> 运行效果: <img alt="" src="https://images2.imgbox.com/96/57/TESFkHmr_o.gif"> 上面的代码中，我们绑定到页面是通过<code>user.name</code>,<code>user.age</code>；这样写感觉很繁琐，我们能不能直接将<code>user</code>中的属性解构出来使用呢? 答案是不能直接对<code>user</code>进行结构， 这样会消除它的响应式， 这里就和上面我们说<code>props</code>不能使用 ES6 直接解构就呼应上了。那我们就想使用解构后的数据怎么办，解决办法就是<strong>使用<code>toRefs</code></strong>。 toRefs 用于将一个 reactive 对象转化为属性全部为 ref 对象的普通对象。具体使用方式如下：</p> 
  <pre class="has"><code class="language-vue">&lt;template&gt;
  &lt;div class="homePage"&gt;
    &lt;p&gt;第 {<!-- -->{ year }} 年&lt;/p&gt;
    &lt;p&gt;姓名： {<!-- -->{ nickname }}&lt;/p&gt;
    &lt;p&gt;年龄： {<!-- -->{ age }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { defineComponent, reactive, ref, toRefs } from "vue";
export default defineComponent({
  setup() {
    const year = ref(0);
    const user = reactive({ nickname: "xiaofan", age: 26, gender: "女" });
    setInterval(() =&gt; {
      year.value++;
      user.age++;
    }, 1000);
    return {
      year,
      // 使用reRefs
      ...toRefs(user),
    };
  },
});
&lt;/script&gt;复制代码</code></pre> 
  <h4>生命周期钩子</h4> 
  <p>我们可以直接看生命周期图来认识都有哪些生命周期钩子 (图片是根据官网翻译后绘制的)： <img alt="" src="https://images2.imgbox.com/18/77/hdZjAOvu_o.png"> 从图中我们可以看到 Vue3.0 新增了<code>setup</code>，这个在前面我们也详细说了， 然后是将 Vue2.x 中的<code>beforeDestroy</code>名称变更成<code>beforeUnmount</code>; <code>destroyed</code> 表更为 <code>unmounted</code>，作者说这么变更纯粹是为了更加语义化，因为一个组件是一个<code>mount</code>和<code>unmount</code>的过程。其他 Vue2 中的生命周期仍然保留。 上边<code>生命周期图</code>中并没包含全部的生命周期钩子， 还有其他的几个， 全部生命周期钩子如图所示： <img alt="" src="https://images2.imgbox.com/48/0f/8d5JKsuZ_o.png"> 我们可以看到<code>beforeCreate</code>和<code>created</code>被<code>setup</code>替换了(但是 Vue3 中你仍然可以使用， 因为 Vue3 是向下兼容的， 也就是你实际使用的是 vue2 的)。其次，钩子命名都增加了<code>on</code>; Vue3.x 还新增用于调试的钩子函数<code>onRenderTriggered</code>和<code>onRenderTricked</code> 下面我们简单使用几个钩子， 方便大家学习如何使用，Vue3.x 中的钩子是需要从 vue 中导入的：</p> 
  <pre class="has"><code class="language-vue">import { defineComponent, onBeforeMount, onMounted, onBeforeUpdate,onUpdated,
onBeforeUnmount, onUnmounted, onErrorCaptured, onRenderTracked,
onRenderTriggered } from "vue"; export default defineComponent({ //
beforeCreate和created是vue2的 beforeCreate() {
console.log("------beforeCreate-----"); }, created() {
console.log("------created-----"); }, setup() { console.log("------setup-----");
// vue3.x生命周期写在setup中 onBeforeMount(() =&gt; {
console.log("------onBeforeMount-----"); }); onMounted(() =&gt; {
console.log("------onMounted-----"); }); // 调试哪些数据发生了变化
onRenderTriggered((event) =&gt;{ console.log("------onRenderTriggered-----",event);
}) }, });复制代码</code></pre> 
  <p>关于生命周期相关的内容就介绍到这里，下面我们介绍一下 Vue3.x 中<code>watch</code>有什么不同。</p> 
  <h4>watch 与 watchEffect 的用法</h4> 
  <blockquote> 
   <p>watch 函数用来侦听特定的数据源，并在回调函数中执行副作用。默认情况是惰性的，也就是说仅在侦听的源数据变更时才执行回调。</p> 
  </blockquote> 
  <pre class="has"><code class="language-vue">watch(source, callback, [options])复制代码</code></pre> 
  <p>参数说明：</p> 
  <ul><li>source: 可以支持 string,Object,Function,Array; 用于指定要侦听的响应式变量</li><li>callback: 执行的回调函数</li><li>options：支持 deep、immediate 和 flush 选项。</li></ul> 
  <p>接下来我会分别介绍这个三个参数都是如何使用的， 如果你对 watch 的使用不明白的请往下看：</p> 
  <h5>侦听 reactive 定义的数据</h5> 
  <pre class="has"><code class="language-js">import { defineComponent, ref, reactive, toRefs, watch } from "vue";
export default defineComponent({
  setup() {
    const state = reactive({ nickname: "xiaofan", age: 20 });

    setTimeout(() =&gt; {
      state.age++;
    }, 1000);

    // 修改age值时会触发 watch的回调
    watch(
      () =&gt; state.age,
      (curAge, preAge) =&gt; {
        console.log("新值:", curAge, "老值:", preAge);
      }
    );

    return {
      ...toRefs(state),
    };
  },
});
复制代码</code></pre> 
  <h5>侦听 ref 定义的数据</h5> 
  <pre class="has"><code class="language-js">const year = ref(0);

setTimeout(() =&gt; {
  year.value++;
}, 1000);

watch(year, (newVal, oldVal) =&gt; {
  console.log("新值:", newVal, "老值:", oldVal);
});
复制代码</code></pre> 
  <h5>侦听多个数据</h5> 
  <p>上面两个例子中，我们分别使用了两个 watch, 当我们需要侦听多个数据源时， 可以进行合并， 同时侦听多个数据：</p> 
  <pre class="has"><code class="language-vue">watch([() =&gt; state.age, year], ([curAge, newVal], [preAge, oldVal]) =&gt; {
console.log("新值:", curAge, "老值:", preAge); console.log("新值:", newVal,
"老值:", oldVal); });复制代码</code></pre> 
  <h5>侦听复杂的嵌套对象</h5> 
  <p>我们实际开发中，复杂数据随处可见， 比如：</p> 
  <pre class="has"><code class="language-js">const state = reactive({
  room: {
    id: 100,
    attrs: {
      size: "140平方米",
      type: "三室两厅",
    },
  },
});
watch(
  () =&gt; state.room,
  (newType, oldType) =&gt; {
    console.log("新值:", newType, "老值:", oldType);
  },
  { deep: true }
);
复制代码</code></pre> 
  <p>如果不使用第三个参数<code>deep:true</code>， 是无法监听到数据变化的。 前面我们提到，<strong>默认情况下，watch 是惰性的</strong>, 那什么情况下不是惰性的， 可以立即执行回调函数呢？其实使用也很简单， 给第三个参数中设置<code>immediate: true</code>即可。关于<code>flush</code>配置，还在学习，后期会补充</p> 
  <h5>stop 停止监听</h5> 
  <p>我们在组件中创建的<code>watch</code>监听，会在组件被销毁时自动停止。如果在组件销毁之前我们想要停止掉某个监听， 可以调用<code>watch()</code>函数的返回值，操作如下：</p> 
  <pre class="has"><code>const stopWatchRoom = watch(() =&gt; state.room, (newType, oldType) =&gt; {
    console.log("新值:", newType, "老值:", oldType);
}, {deep:true});

setTimeout(()=&gt;{
    // 停止监听
    stopWatchRoom()
}, 3000)复制代码</code></pre> 
  <p>还有一个监听函数<code>watchEffect</code>, 在我看来<code>watch</code>已经能满足监听的需求，为什么还要有<code>watchEffect</code>呢？虽然我没有 get 到它的必要性，但是还是要介绍一下<code>watchEffect</code>，首先看看它的使用和<code>watch</code>究竟有何不同。</p> 
  <pre class="has"><code>import { defineComponent, ref, reactive, toRefs, watchEffect } from "vue";
export default defineComponent({
  setup() {
    const state = reactive({ nickname: "xiaofan", age: 20 });
    let year = ref(0)

    setInterval(() =&gt;{
        state.age++
        year.value++
    },1000)

    watchEffect(() =&gt; {
        console.log(state);
        console.log(year);
      }
    );

    return {
        ...toRefs(state)
    }
  },
});复制代码</code></pre> 
  <p>执行结果首先打印一次<code>state</code>和<code>year</code>值；然后每隔一秒，打印<code>state</code>和<code>year</code>值。 从上面的代码可以看出， 并没有像<code>watch</code>一样需要先传入依赖，<code>watchEffect</code>会自动收集依赖, 只要指定一个回调函数。在组件初始化时， 会先执行一次来收集依赖， 然后当收集到的依赖中数据发生变化时， 就会再次执行回调函数。所以总结对比如下：</p> 
  <ol><li>watchEffect 不需要手动传入依赖</li><li>watchEffect 会先执行一次用来自动收集依赖</li><li>watchEffect 无法获取到变化前的值， 只能获取变化后的值</li></ol> 
  <p>上面介绍了 Vue3 <code>Composition API</code>的部分内容, 还有很多非常好用的 API, 建议直接查看官网 composition-api。 其实我们也能进行自定义封装。</p> 
  <h3>自定义 Hooks</h3> 
  <p>开篇的时候我们使用 Vue2.x 写了一个实现加减的例子， 这里可以将其封装成一个 hook, 我们约定这些「自定义 Hook」以 use 作为前缀，和普通的函数加以区分。 <code>useCount.ts</code> 实现：</p> 
  <pre class="has"><code class="language-ts">import { ref, Ref, computed } from "vue";

type CountResultProps = {
  count: Ref&lt;number&gt;;
  multiple: Ref&lt;number&gt;;
  increase: (delta?: number) =&gt; void;
  decrease: (delta?: number) =&gt; void;
};

export default function useCount(initValue = 1): CountResultProps {
  const count = ref(initValue);

  const increase = (delta?: number): void =&gt; {
    if (typeof delta !== "undefined") {
      count.value += delta;
    } else {
      count.value += 1;
    }
  };
  const multiple = computed(() =&gt; count.value * 2);

  const decrease = (delta?: number): void =&gt; {
    if (typeof delta !== "undefined") {
      count.value -= delta;
    } else {
      count.value -= 1;
    }
  };

  return {
    count,
    multiple,
    increase,
    decrease,
  };
}
复制代码</code></pre> 
  <p>接下来看一下在组件中使用<code>useCount</code>这个 <code>hook</code>:</p> 
  <pre class="has"><code class="language-ts">&lt;template&gt;&lt;p&gt;count: {<!-- -->{ count }}&lt;/p&gt;
  &lt;p&gt;倍数： {<!-- -->{ multiple }}&lt;/p&gt;
  &lt;div&gt;
    &lt;button @click="increase()"&gt;加1&lt;/button&gt;
    &lt;button @click="decrease()"&gt;减一&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
import useCount from "../hooks/useCount";
 setup() {
    const { count, multiple, increase, decrease } = useCount(10);
        return {
            count,
            multiple,
            increase,
            decrease,
        };
    },
&lt;/script&gt;
复制代码</code></pre> 
  <p>开篇 Vue2.x 实现，分散在<code>data</code>,<code>method</code>,<code>computed</code>等， 如果刚接手项目，实在无法快速将<code>data</code>字段和<code>method</code>关联起来，而 Vue3 的方式可以很明确的看出，将 count 相关的逻辑聚合在一起， 看起来舒服多了， 而且<code>useCount</code>还可以扩展更多的功能。 项目开发完之后，后续还会写一篇总结项目中使用到的「自定义 Hooks 的文章」，帮助大家更高效的开发， 关于<code>Composition API</code>和自定义 Hooks 就介绍到这里， 接下来简单介绍一下 vue2.x 与 vue3 响应式对比。</p> 
  <h3>简单对比 vue2.x 与 vue3.x 响应式</h3> 
  <p>其实在 Vue3.x 还没有发布 bate 的时候， 很火的一个话题就是<code>Vue3.x 将使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty</code>。 没有无缘无故的爱，也没有无缘无故的恨。为何要将<code>Object.defineProperty</code>换掉呢，咋们可以简单聊一下。 我刚上手 Vue2.x 的时候就经常遇到一个问题，数据更新了啊，为何页面不更新呢？什么时候用<code>$set</code>更新，什么时候用<code>$forceUpdate</code>强制更新，你是否也一度陷入困境。后来的学习过程中开始接触源码，才知道一切的根源都是 <code>Object.defineProperty</code>。 对这块想要深入了解的小伙伴可以看这篇文章 为什么 Vue3.0 不再使用 defineProperty 实现数据监听？要详细解释又是一篇文章，这里就简单对比一下<code>Object.defineProperty</code> 与 Proxy</p> 
  <ol><li><code>Object.defineProperty</code>只能劫持对象的属性， 而 Proxy 是直接代理对象</li></ol> 
  <p>由于<code>Object.defineProperty</code>只能劫持对象属性，需要遍历对象的每一个属性，如果属性值也是对象，就需要递归进行深度遍历。但是 Proxy 直接代理对象， 不需要遍历操作</p> 
  <ol><li><code>Object.defineProperty</code>对新增属性需要手动进行<code>Observe</code></li></ol> 
  <p>因为<code>Object.defineProperty</code>劫持的是对象的属性，所以新增属性时，需要重新遍历对象， 对其新增属性再次使用<code>Object.defineProperty</code>进行劫持。也就是 Vue2.x 中给数组和对象新增属性时，需要使用<code>$set</code>才能保证新增的属性也是响应式的, <code>$set</code>内部也是通过调用<code>Object.defineProperty</code>去处理的。</p> 
  <h3>Teleport</h3> 
  <p>Teleport 是 Vue3.x 新推出的功能， 没听过这个词的小伙伴可能会感到陌生；翻译过来是<code>传送</code>的意思，可能还是觉得不知所以，没事下边我就给大家形象的描述一下。</p> 
  <h4>Teleport 是什么呢？</h4> 
  <p>Teleport 就像是哆啦 A 梦中的「任意门」，任意门的作用就是可以将人瞬间传送到另一个地方。有了这个认识，我们再来看一下为什么需要用到 Teleport 的特性呢，看一个小例子： 在子组件<code>Header</code>中使用到<code>Dialog</code>组件，我们实际开发中经常会在类似的情形下使用到 <code>Dialog</code> ，此时<code>Dialog</code>就被渲染到一层层子组件内部，处理嵌套组件的定位、<code>z-index</code>和样式都变得困难。 <code>Dialog</code>从用户感知的层面，应该是一个独立的组件，从 dom 结构应该完全剥离 Vue 顶层组件挂载的 DOM；同时还可以使用到 Vue 组件内的状态(<code>data</code>或者<code>props</code>)的值。简单来说就是,<strong>即希望继续在组件内部使用<code>Dialog</code>, 又希望渲染的 DOM 结构不嵌套在组件的 DOM 中</strong>。 此时就需要 Teleport 上场，我们可以用<code>&lt;Teleport&gt;</code>包裹<code>Dialog</code>, 此时就建立了一个传送门，可以将<code>Dialog</code>渲染的内容传送到任何指定的地方。 接下来就举个小例子，看看 Teleport 的使用方式</p> 
  <h4>Teleport 的使用</h4> 
  <p>我们希望 Dialog 渲染的 dom 和顶层组件是兄弟节点关系, 在<code>index.html</code>文件中定义一个供挂载的元素:</p> 
  <pre class="has"><code class="language-html">&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
  &lt;div id="dialog"&gt;&lt;/div&gt;
&lt;/body&gt;
复制代码</code></pre> 
  <p>定义一个<code>Dialog</code>组件<code>Dialog.vue</code>, 留意 <code>to</code> 属性， 与上面的<code>id</code>选择器一致：</p> 
  <pre class="has"><code class="language-vue">&lt;template&gt;
  &lt;teleport to="#dialog"&gt;
    &lt;div class="dialog"&gt;
      &lt;div class="dialog_wrapper"&gt;
        &lt;div class="dialog_header" v-if="title"&gt;
          &lt;slot name="header"&gt;
            &lt;span&gt;{<!-- -->{ title }}&lt;/span&gt;
          &lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="dialog_content"&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div class="dialog_footer"&gt;
        &lt;slot name="footer"&gt;&lt;/slot&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/teleport&gt;
&lt;/template&gt;复制代码</code></pre> 
  <p>最后在一个子组件<code>Header.vue</code>中使用<code>Dialog</code>组件, 这里主要演示 Teleport 的使用，不相关的代码就省略了。<code>header</code>组件</p> 
  <pre class="has"><code>&lt;div class="header"&gt;
    ...
    &lt;navbar /&gt;
    &lt;Dialog v-if="dialogVisible"&gt;&lt;/Dialog&gt;
&lt;/div&gt;
...复制代码</code></pre> 
  <p>Dom 渲染效果如下： <img alt="" src="https://images2.imgbox.com/c6/51/t9POfPzq_o.png"> 图片. png 可以看到，我们使用 <code>teleport</code> 组件，通过 <code>to</code> 属性，指定该组件渲染的位置与 <code>&lt;div id="app"&gt;&lt;/div&gt;</code> 同级，也就是在 <code>body</code> 下，但是 <code>Dialog</code> 的状态 <code>dialogVisible</code> 又是完全由内部 Vue 组件控制.</p> 
  <h3>Suspense</h3> 
  <p><code>Suspense</code>是 Vue3.x 中新增的特性， 那它有什么用呢？别急，我们通过 Vue2.x 中的一些场景来认识它的作用。 Vue2.x 中应该经常遇到这样的场景：</p> 
  <pre class="has"><code>&lt;template&gt;
&lt;div&gt;
    &lt;div v-if="!loading"&gt;
        ...
    &lt;/div&gt;
    &lt;div v-if="loading"&gt;
        加载中...
    &lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;复制代码</code></pre> 
  <p>在前后端交互获取数据时， 是一个异步过程，一般我们都会提供一个加载中的动画，当数据返回时配合<code>v-if</code>来控制数据显示。 如果你使用过<code>vue-async-manager</code>这个插件来完成上面的需求， 你对<code>Suspense</code>可能不会陌生，Vue3.x 感觉就是参考了<code>vue-async-manager</code>. Vue3.x 新出的内置组件<code>Suspense</code>, 它提供两个<code>template</code> slot, 刚开始会渲染一个 fallback 状态下的内容， 直到到达某个条件后才会渲染 default 状态的正式内容， 通过使用<code>Suspense</code>组件进行展示异步渲染就更加的简单。:::warning 如果使用 <code>Suspense</code>, 要返回一个 promise :::<code>Suspense</code> 组件的使用：</p> 
  <pre class="has"><code>&lt;Suspense&gt;
        &lt;template #default&gt;
            &lt;async-component&gt;&lt;/async-component&gt;
        &lt;/template&gt;
        &lt;template #fallback&gt;
            &lt;div&gt;
                Loading...
            &lt;/div&gt;
        &lt;/template&gt;
  &lt;/Suspense&gt;复制代码</code></pre> 
  <p><code>asyncComponent.vue</code>:</p> 
  <pre class="has"><code>&lt;&lt;template&gt;
&lt;div&gt;
    &lt;h4&gt;这个是一个异步加载数据&lt;/h4&gt;
    &lt;p&gt;用户名：{<!-- -->{user.nickname}}&lt;/p&gt;
    &lt;p&gt;年龄：{<!-- -->{user.age}}&lt;/p&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { defineComponent } from "vue"
import axios from "axios"
export default defineComponent({
    setup(){
        const rawData = await axios.get("http://xxx.xinp.cn/user")
        return {
            user: rawData.data
        }
    }
})
&lt;/script&gt;复制代码</code></pre> 
  <p>从上面代码来看，<code>Suspense</code> 只是一个带插槽的组件，只是它的插槽指定了<code>default</code> 和 <code>fallback</code> 两种状态。</p> 
  <h3>片段(Fragment)</h3> 
  <p>在 Vue2.x 中， <code>template</code>中只允许有一个根节点：</p> 
  <pre class="has"><code>&lt;template&gt;
    &lt;div&gt;
        &lt;span&gt;&lt;/span&gt;
        &lt;span&gt;&lt;/span&gt;
    &lt;/div&gt;
&lt;/template&gt;复制代码</code></pre> 
  <p>但是在 Vue3.x 中，你可以直接写多个根节点， 是不是很爽：</p> 
  <pre class="has"><code>&lt;template&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
&lt;/template&gt;复制代码</code></pre> 
  <h3>更好的 Tree-Shaking</h3> 
  <p>Vue3.x 在考虑到 <code>tree-shaking</code>的基础上重构了全局和内部 API, 表现结果就是现在的全局 API 需要通过 <code>ES Module</code>的引用方式进行具名引用， 比如在 Vue2.x 中，我们要使用 <code>nextTick</code>:</p> 
  <pre class="has"><code>// vue2.x
import Vue from "vue"

Vue.nextTick(()=&gt;{
    ...
})复制代码</code></pre> 
  <p><code>Vue.nextTick()</code> 是一个从 Vue 对象直接暴露出来的全局 API，其实 <code>$nextTick()</code> 只是 <code>Vue.nextTick()</code> 的一个简易包装，只是为了方便而把后者的回调函数的 <code>this</code> 绑定到了当前的实例。虽然我们借助<code>webpack</code>的<code>tree-shaking</code>, 但是不管我们实际上是否使用<code>Vue.nextTick()</code>, 最终都会进入我们的生产代码， 因为 Vue 实例是作为单个对象导出的， 打包器无法坚持出代码总使用了对象的哪些属性。 在 Vue3.x 中改写成这样：</p> 
  <pre class="has"><code>import { nextTick } from "vue"

nextTick(() =&gt;{
    ...
})复制代码</code></pre> 
  <h4>受影响的 API</h4> 
  <p>这是一个比较大的变化， 因为以前的全局 API 现在只能通过具名导入，这一更改会对以下 API 有影响：</p> 
  <ul><li><code>Vue.nextTick</code></li><li><code>Vue.observable</code>(用 <code>Vue.reactive</code> 替换)</li><li><code>Vue.version</code></li><li><code>Vue.compile</code>(仅限完整版本时可用)</li><li><code>Vue.set</code>(仅在 2.x 兼容版本中可用)</li><li><code>Vue.delete</code>(与上同)</li></ul> 
  <h4>内置工具</h4> 
  <p>出来上面的 API 外， 还有许多内置的组件 以上仅适用于 <code>ES Modules</code> builds，用于支持 tree-shaking 的绑定器——UMD 构建仍然包括所有特性，并暴露 Vue 全局变量上的所有内容 (编译器将生成适当的输出，以使用全局外的 api 而不是导入)。::: 前面都是 Vue3.0 的一些新特性，后面着重介绍一下相对于 Vue2.x 来说， 有什么变更呢？</p> 
  <h3>变更</h3> 
  <h4>slot 具名插槽语法</h4> 
  <p>在 Vue2.x 中， 具名插槽的写法：</p> 
  <pre class="has"><code>&lt;!--  子组件中：--&gt;
&lt;slot name="title"&gt;&lt;/slot&gt;复制代码</code></pre> 
  <p>在父组件中使用：</p> 
  <pre class="has"><code>&lt;template slot="title"&gt;
    &lt;h1&gt;歌曲：成都&lt;/h1&gt;
&lt;template&gt;复制代码</code></pre> 
  <p>如果我们要<strong>在 slot 上面绑定数据，可以使用作用域插槽</strong>，实现如下：</p> 
  <pre class="has"><code>// 子组件
&lt;slot name="content" :data="data"&gt;&lt;/slot&gt;
export default {
    data(){
        return{
            data:["走过来人来人往","不喜欢也得欣赏","陪伴是最长情的告白"]
        }
    }
}复制代码</code></pre> 
  <pre class="has"><code>&lt;!-- 父组件中使用 --&gt;
&lt;template slot="content" slot-scope="scoped"&gt;
    &lt;div v-for="item in scoped.data"&gt;{<!-- -->{item}}&lt;/div&gt;
&lt;template&gt;复制代码</code></pre> 
  <p>在 Vue2.x 中具名插槽和作用域插槽分别使用<code>slot</code>和<code>slot-scope</code>来实现， 在 Vue3.0 中将<code>slot</code>和<code>slot-scope</code>进行了合并同意使用。 Vue3.0 中<code>v-slot</code>：</p> 
  <pre class="has"><code>&lt;!-- 父组件中使用 --&gt;
 &lt;template v-slot:content="scoped"&gt;
   &lt;div v-for="item in scoped.data"&gt;{<!-- -->{item}}&lt;/div&gt;
&lt;/template&gt;

&lt;!-- 也可以简写成： --&gt;
&lt;template #content="{data}"&gt;
    &lt;div v-for="item in data"&gt;{<!-- -->{item}}&lt;/div&gt;
&lt;/template&gt;复制代码</code></pre> 
  <h4>自定义指令</h4> 
  <p>首先回顾一下 Vue 2 中实现一个自定义指令：</p> 
  <pre class="has"><code>// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})复制代码</code></pre> 
  <p>在 Vue 2 中， 自定义指令通过以下几个可选钩子创建：</p> 
  <ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li><li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li>unbind：只调用一次，指令与元素解绑时调用。</li></ul> 
  <p>在 Vue 3 中对自定义指令的 API 进行了更加语义化的修改， 就如组件生命周期变更一样， 都是为了更好的语义化， 变更如下： <img alt="" src="https://images2.imgbox.com/89/07/3T94qIXr_o.png"> 所以在 Vue3 中， 可以这样来自定义指令：</p> 
  <pre class="has"><code>const { createApp } from "vue"

const app = createApp({})
app.directive('focus', {
    mounted(el) {
        el.focus()
    }
})复制代码</code></pre> 
  <p>然后可以在模板中任何元素上使用新的 <code>v-focus</code>指令， 如下：</p> 
  <pre class="has"><code>&lt;input v-focus /&gt;复制代码</code></pre> 
  <h4>v-model 升级</h4> 
  <p>在使用 Vue 3 之前就了解到 <code>v-model</code> 发生了很大的变化， 使用过了之后才真正的 get 到这些变化， 我们先纵观一下发生了哪些变化， 然后再针对的说一下如何使用：</p> 
  <ul><li>变更：在自定义组件上使用<code>v-model</code>时， 属性以及事件的默认名称变了</li><li>变更：<code>v-bind</code>的<code>.sync</code>修饰符在 Vue 3 中又被去掉了, 合并到了<code>v-model</code>里</li><li>新增：同一组件可以同时设置多个 <code>v-model</code></li><li>新增：开发者可以自定义 <code>v-model</code>修饰符</li></ul> 
  <p>有点懵？别着急，往下看 在 Vue2 中， 在组件上使用 <code>v-model</code>其实就相当于传递了<code>value</code>属性， 并触发了<code>input</code>事件：</p> 
  <pre class="has"><code>&lt;!-- Vue 2 --&gt;
&lt;search-input v-model="searchValue"&gt;&lt;search-input&gt;

&lt;!-- 相当于 --&gt;
&lt;search-input :value="searchValue" @input="searchValue=$event"&gt;&lt;search-input&gt;复制代码</code></pre> 
  <p>这时<code>v-model</code>只能绑定在组件的<code>value</code>属性上，那我们就不开心了， 我们就像给自己的组件用一个别的属性，并且我们不想通过触发<code>input</code>来更新值，在<code>.async</code>出来之前，Vue 2 中这样实现：</p> 
  <pre class="has"><code>// 子组件：searchInput.vue
export default {
    model:{
        prop: 'search',
        event:'change'
    }
}复制代码</code></pre> 
  <p>修改后， searchInput 组件使用<code>v-model</code>就相当于这样：</p> 
  <pre class="has"><code>&lt;search-input v-model="searchValue"&gt;&lt;search-input&gt;
&lt;!-- 相当于 --&gt;
&lt;search-input :search="searchValue" @change="searchValue=$event"&gt;&lt;search-input&gt;复制代码</code></pre> 
  <p>但是在实际开发中，有些场景我们可能需要对一个 prop 进行 “双向绑定”， 这里以最常见的 modal 为例子：modal 挺合适属性双向绑定的，外部可以控制组件的<code>visible</code>显示或者隐藏，组件内部关闭可以控制 <code>visible</code>属性隐藏，同时 visible 属性同步传输到外部。组件内部， 当我们关闭<code>modal</code>时, 在子组件中以 update:PropName 模式触发事件：</p> 
  <pre class="has"><code>this.$emit('update:visible', false)复制代码</code></pre> 
  <p>然后在父组件中可以监听这个事件进行数据更新：</p> 
  <pre class="has"><code>&lt;modal :visible="isVisible" @update:visible="isVisible = $event"&gt;&lt;/modal&gt;复制代码</code></pre> 
  <p>此时我们也可以使用<code>v-bind.async</code>来简化实现：</p> 
  <pre class="has"><code>&lt;modal :visible.async="isVisible"&gt;&lt;/modal&gt;复制代码</code></pre> 
  <p>上面回顾了 Vue2 中<code>v-model</code>实现以及组件属性的双向绑定，那么<strong>在 Vue 3 中应该怎样实现的呢？</strong> 在 Vue3 中, 在自定义组件上使用<code>v-model</code>, 相当于传递一个<code>modelValue</code> 属性， 同时触发一个<code>update:modelValue</code>事件：</p> 
  <pre class="has"><code>&lt;modal v-model="isVisible"&gt;&lt;/modal&gt;
&lt;!-- 相当于 --&gt;
&lt;modal :modelValue="isVisible" @update:modelValue="isVisible = $event"&gt;&lt;/modal&gt;复制代码</code></pre> 
  <p>如果要绑定属性名， 只需要给<code>v-model</code>传递一个参数就行, 同时可以绑定多个<code>v-model</code>：</p> 
  <pre class="has"><code>&lt;modal v-model:visible="isVisible" v-model:content="content"&gt;&lt;/modal&gt;

&lt;!-- 相当于 --&gt;
&lt;modal
    :visible="isVisible"
    :content="content"
    @update:visible="isVisible"
    @update:content="content"
/&gt;复制代码</code></pre> 
  <p>不知道你有没有发现，这个写法完全没有<code>.async</code>什么事儿了， 所以啊，Vue 3 中又抛弃了<code>.async</code>写法， 统一使用<code>v-model</code></p> 
  <h4>异步组件</h4> 
  <p>Vue3 中 使用 <code>defineAsyncComponent</code> 定义异步组件，配置选项 <code>component</code> 替换为 <code>loader</code> ,Loader 函数本身不再接收 resolve 和 reject 参数，且必须返回一个 Promise，用法如下：</p> 
  <pre class="has"><code>&lt;template&gt;
  &lt;!-- 异步组件的使用 --&gt;
  &lt;AsyncPage /&gt;
&lt;/tempate&gt;

&lt;script&gt;
import { defineAsyncComponent } from "vue";

export default {
  components: {
    // 无配置项异步组件
    AsyncPage: defineAsyncComponent(() =&gt; import("./NextPage.vue")),

    // 有配置项异步组件
    AsyncPageWithOptions: defineAsyncComponent({
   loader: () =&gt; import(".NextPage.vue"),
   delay: 200,
   timeout: 3000,
   errorComponent: () =&gt; import("./ErrorComponent.vue"),
   loadingComponent: () =&gt; import("./LoadingComponent.vue"),
 })
  },
}
&lt;/script&gt;</code></pre> 
 </div> 
 <p>链接：https://juejin.cn/post/6940454764421316644</p> 
 <hr> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7dfde9c9554915e35083a99aaf422e98/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java公式计算（字符串）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b92cbe3eb42e158566785dd9b3d66329/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何启动一个vue2项目？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>