<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Object Detection 之基础知识 (02) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Object Detection 之基础知识 (02)" />
<meta property="og:description" content="以下知识来自网易云课堂：深度学习：算法到实战
目录
一、评价标准
二、滑动窗口
三、目标候选框生成（Object Proposal generation）
四、难负样本挖掘（Hard Negative Mining）
五、 非极大值拟制（Non-Maximum Suppression）
六、边界框回归（Bounding Box Regression）
一、评价标准 1，准确率（Precision）: 正确预测为正类的样本占所有预测为正类的比例 （所有预测为正类的样本中有多少是真正为正类）
2，召回率（Recall）：正确预测为正类的样本占所有实际为正类样本的比例（所有为正类的样本中有多少被预测为正类）
其中P为预测结果区域Prediction，G 为目标区域Ground Truth
3，交并比（IOU, Intersection-over-Union）: 二、滑动窗口 传统的方法是用一个滑动窗口，从左到右，从上到下滑动，匹配窗口内是否含有目标。下面的需要滑动512x512次（上下步长为1）
三、目标候选框生成（Object Proposal generation） 使用一些方法去生成目标候选框，可能就几百个或几千个候选框，而传统的滑动窗口法，窗口可能会有几万个或是几十万个。
目标候选框生成方法，代表算法有：
其中SS常用在经典目标检测算法中，比如R-CNN，Fast-RCNN
SS：首先，对输入图像进行分割算法（Graph-Based Image Segmentation）产生许多小的子区域。其次，根据这些子区域之间相似性(相似性标准主要有颜色、纹理、大小等等)进行区域合并，不断的进行区域迭代合并。每次迭代过程中对这些合并的子区域做bounding boxes(外切矩形)，这些子区域外切矩形就是通常所说的候选框。
四、难负样本挖掘（Hard Negative Mining） negative相对于positive，是相对于正样本来说，不含有目标的负样本。但是，negative包括很多，有完全不包含目标的的，也有部分含有的，其中比较容易被判定是负样本（比如全是背景）的对于训练并不能起到很好的监督作用。我们需要找一些难划分的负样本，也就是hard negative，来增强网络的判别性能。
1，我们先用初始的正负样本(一般是正样本&#43;与正样本同规模的负样本的一个子集)训练分类器,；
2，然后再用训练出的分类器对样本进行分类, 把其中负样本中错误分类的那些样本(hard negative)放入负样本集合, 再继续训练分类器；
3， 如此反复, 直到达到停止条件(比如分类器性能不再提升). 这个过程就是 Hard Negative Mining。
五、 非极大值拟制（Non-Maximum Suppression） NMS:
1，在进行目标检测时一般会采取窗口滑动的方式，在图像上生成很多的候选框，然后把这些候选框进行特征提取后送入分类器，一般会得出一个得分（score），比如人脸检测，会在很多框上都有得分;
2，然后把这些得分全部排序。选取得分最高的那个框，接下来计算其他的框与当前框的重合程度（overlap）；
3，如果重合程度大于一定阈值就删除，因为在同一个脸上可能会有好几个高得分的框，都是人脸但是不需要那么框我们只需要一个就够了。
注：那么肯定有人会好奇，如果图片中有好几个人脸，你这选取一个最大的，那第二个人脸怎么办呢。
实际上这是一个迭代的过程，第一步的非极大值抑制就是选取了某一个最大的得分，然后删除了他周边的几个框，第二次迭代的时候在剩下的框里面选取一个最大的，然后再删除它周围重叠区域大于一定阈值的，这样不停的迭代下去就会得到所有想要找到的目标物体的区域。
六、边界框回归（Bounding Box Regression） 红色框口P表示建议框Region Proposal，绿色窗口G表示实际框Ground Truth，红色窗口G^表示Region Proposal进行回归后的预测窗口，现在的目标是找到P到G^的线性变换，使得G^与G越相近，这就相当于一个简单的可以用最小二乘法解决的线性回归问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5d3113e74dda070b434b92b79edfdf02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-08T09:47:44+08:00" />
<meta property="article:modified_time" content="2019-03-08T09:47:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Object Detection 之基础知识 (02)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>以下知识来自<a href="https://study.163.com/course/courseMain.htm?courseId=1006498024&amp;share=1&amp;shareId=1151466060" rel="nofollow">网易云课堂：深度学习：算法到实战</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86" rel="nofollow">一、评价标准</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" rel="nofollow">二、滑动窗口</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%9B%AE%E6%A0%87%E5%80%99%E9%80%89%E6%A1%86%E7%94%9F%E6%88%90%EF%BC%88Object%20Proposal%20generation%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E7%9B%AE%E6%A0%87%E5%80%99%E9%80%89%E6%A1%86%E7%94%9F%E6%88%90%EF%BC%88Object%20Proposal%20generation%EF%BC%89" rel="nofollow">三、目标候选框生成（Object Proposal generation）</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81%E9%9A%BE%E8%B4%9F%E6%A0%B7%E6%9C%AC%E6%8C%96%E6%8E%98%EF%BC%88Hard%20Negative%20Mining%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E9%9A%BE%E8%B4%9F%E6%A0%B7%E6%9C%AC%E6%8C%96%E6%8E%98%EF%BC%88Hard%20Negative%20Mining%EF%BC%89" rel="nofollow"> 四、难负样本挖掘（Hard Negative Mining）</a></p> 
<p id="%E4%BA%94%E3%80%81%20%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8B%9F%E5%88%B6%EF%BC%88Non-Maximum%20Suppression%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%BA%94%E3%80%81%20%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8B%9F%E5%88%B6%EF%BC%88Non-Maximum%20Suppression%EF%BC%89" rel="nofollow">五、 非极大值拟制（Non-Maximum Suppression）</a></p> 
<p id="%E5%85%AD%E3%80%81%E8%BE%B9%E7%95%8C%E6%A1%86%E5%9B%9E%E5%BD%92%EF%BC%88Bounding%20Box%20Regression%EF%BC%89%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B-toc" style="margin-left:80px;"><a href="#%E5%85%AD%E3%80%81%E8%BE%B9%E7%95%8C%E6%A1%86%E5%9B%9E%E5%BD%92%EF%BC%88Bounding%20Box%20Regression%EF%BC%89%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B" rel="nofollow">六、边界框回归（Bounding Box Regression）</a></p> 
<hr id="hr-toc"> 
<h4 id="%E4%B8%80%E3%80%81%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86">一、评价标准</h4> 
<p>1，准确率（Precision）: 正确预测为正类的样本占所有预测为正类的比例 （所有预测为正类的样本中有多少是真正为正类）</p> 
<p>2，召回率（Recall）：正确预测为正类的样本占所有实际为正类样本的比例（所有为正类的样本中有多少被预测为正类）</p> 
<p style="text-align:center;"><img alt="" class="has" height="72" src="https://images2.imgbox.com/7d/0c/1bDycBrX_o.png" width="371"></p> 
<p>      其中P为预测结果区域Prediction，G 为目标区域Ground Truth</p> 
<p>3，交并比（IOU, Intersection-over-Union）: </p> 
<p style="text-align:center;"><img alt="" class="has" height="194" src="https://images2.imgbox.com/01/51/oKxfOkhQ_o.png" width="438"></p> 
<p> </p> 
<h4 id="%E4%BA%8C%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">二、滑动窗口</h4> 
<p>传统的方法是用一个滑动窗口，从左到右，从上到下滑动，匹配窗口内是否含有目标。下面的需要滑动512x512次（上下步长为1）</p> 
<p style="text-align:center;"><img alt="" class="has" height="214" src="https://images2.imgbox.com/48/e5/D5O2ZqZs_o.png" width="427"></p> 
<h4 id="%E4%B8%89%E3%80%81%E7%9B%AE%E6%A0%87%E5%80%99%E9%80%89%E6%A1%86%E7%94%9F%E6%88%90%EF%BC%88Object%20Proposal%20generation%EF%BC%89">三、目标候选框生成（Object Proposal generation）</h4> 
<p>使用一些方法去生成目标候选框，可能就几百个或几千个候选框，而传统的滑动窗口法，窗口可能会有几万个或是几十万个。</p> 
<p>目标候选框生成方法，代表算法有：</p> 
<p style="text-align:center;"><img alt="" class="has" height="278" src="https://images2.imgbox.com/3f/23/XZkm0Bil_o.png" width="419"></p> 
<p> </p> 
<p>其中SS常用在经典目标检测算法中，比如R-CNN，Fast-RCNN</p> 
<p>SS：<span style="color:#4f4f4f;">首先，对输入图像进行分割算法（</span><a href="https://blog.csdn.net/guoyunfei20/article/details/78727972">Graph-Based Image Segmentation</a><span style="color:#4f4f4f;">）产生许多小的子区域。其次，根据这些子区域之间相似性</span><strong>(相似性标准主要有颜色、纹理、大小等等)</strong><span style="color:#4f4f4f;">进行区域合并，不断的进行区域迭代合并。每次迭代过程中对这些合并的子区域做bounding boxes(外切矩形)，这些子区域外切矩形就是通常所说的候选框。</span></p> 
<h4 id="%C2%A0%E5%9B%9B%E3%80%81%E9%9A%BE%E8%B4%9F%E6%A0%B7%E6%9C%AC%E6%8C%96%E6%8E%98%EF%BC%88Hard%20Negative%20Mining%EF%BC%89"> 四、难负样本挖掘（Hard Negative Mining）</h4> 
<p style="text-align:center;"><img alt="" class="has" height="205" src="https://images2.imgbox.com/c8/e3/olWLh9Qi_o.png" width="369"></p> 
<p> </p> 
<p>negative相对于positive，是相对于正样本来说，不含有目标的负样本。但是，negative包括很多，有完全不包含目标的的，也有部分含有的，其中比较容易被判定是负样本（比如全是背景）的对于训练并不能起到很好的监督作用。我们需要找一些难划分的负样本，也就是hard negative，来增强网络的判别性能。</p> 
<p>1，我们先用初始的正负样本(一般是正样本+与正样本同规模的负样本的一个子集)训练分类器,；</p> 
<p>2，然后再用训练出的分类器对样本进行分类, 把其中负样本中错误分类的那些样本(hard negative)放入负样本集合, 再继续训练分类器；</p> 
<p>3， 如此反复, 直到达到停止条件(比如分类器性能不再提升). 这个过程就是 Hard Negative Mining。</p> 
<h4 id="%E4%BA%94%E3%80%81%20%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8B%9F%E5%88%B6%EF%BC%88Non-Maximum%20Suppression%EF%BC%89"><a href="https://www.cnblogs.com/zf-blog/p/6740736.html" rel="nofollow">五、 非极大值拟制（Non-Maximum Suppression）</a></h4> 
<p style="text-align:center;"><img alt="" class="has" height="249" src="https://images2.imgbox.com/a1/4f/0JmD0D73_o.png" width="423"></p> 
<p><a href="https://blog.csdn.net/xiexu911/article/details/80609298">NMS:</a></p> 
<p>1，在进行目标检测时一般会采取窗口滑动的方式，在图像上生成很多的候选框，然后把这些候选框进行特征提取后送入分类器，一般会得出一个得分（score），比如人脸检测，会在很多框上都有得分;</p> 
<p>2，然后把这些得分全部排序。选取得分最高的那个框，接下来计算其他的框与当前框的重合程度（overlap）；</p> 
<p>3，如果重合程度大于一定阈值就删除，因为在同一个脸上可能会有好几个高得分的框，都是人脸但是不需要那么框我们只需要一个就够了。</p> 
<p>注：那么肯定有人会好奇，如果图片中有好几个人脸，你这选取一个最大的，那第二个人脸怎么办呢。</p> 
<p>实际上这是一个迭代的过程，第一步的非极大值抑制就是选取了某一个最大的得分，然后删除了他周边的几个框，第二次迭代的时候在剩下的框里面选取一个最大的，然后再删除它周围重叠区域大于一定阈值的，这样不停的迭代下去就会得到所有想要找到的目标物体的区域。</p> 
<h4 id="%E5%85%AD%E3%80%81%E8%BE%B9%E7%95%8C%E6%A1%86%E5%9B%9E%E5%BD%92%EF%BC%88Bounding%20Box%20Regression%EF%BC%89%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B"><a href="https://www.cnblogs.com/zf-blog/p/6740736.html" rel="nofollow">六、边界框回归（Bounding Box Regression）</a></h4> 
<p style="text-align:center;"><img alt="" class="has" height="361" src="https://images2.imgbox.com/71/34/wvD30NKA_o.png" width="562"></p> 
<p>红色框口P表示建议框Region Proposal，绿色窗口G表示实际框Ground Truth，红色窗口G^表示Region Proposal进行回归后的预测窗口，现在的目标是找到P到G^的线性变换，使得G^与G越相近，这就相当于一个简单的可以用最小二乘法解决的线性回归问题。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac4e6ba0257e585f00e0b71c1575c4ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何向maven 项目中导入依赖，并且完成测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8bbcf92af8e00cda660482e6d69a961e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">产品的10大设计原则</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>