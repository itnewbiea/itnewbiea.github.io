<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>USART_ClearITPendingBith和 USART_ClearFlag的区别 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="USART_ClearITPendingBith和 USART_ClearFlag的区别" />
<meta property="og:description" content="起初 stm32 v3.5 库函数里面，对于串口USART有这样两个函数：
USART_ClearFlag()和USART_ClearITPendingBit()
查库函数定义，说一个是清除标志，一个是清除中断预处理位。然后我看了stm32f10x_usart.c文件，发现两个函数都操作的是USART-&gt;SR寄存器，但是这个寄存器只有一组标志位，没有什么中断预处理位。。
实际上两个函数实现的功能是一样的，都是清除相对应的标志位，只是标志位和中断位含义不一样，是标志位但 是不一定会产生中断。例如： #define USART_IT_TXE ((uint16_t)0x0727) #define USART_IT_TC ((uint16_t)0x0626) #define USART_IT_RXNE ((uint16_t)0x0525) 这是中断位，可以产生中断 #define USART_FLAG_TXE ((uint16_t)0x0080) #define USART_FLAG_TC ((uint16_t)0x0040) #define USART_FLAG_RXNE ((uint16_t)0x0020) 这是标志位，有的标志位不能产生中断 标志位在程序中可以作为判定条件，支持程序的运行，中断则是跳转到中断函数执行。两个函数实现的功能是一 样的，在中断程序中可以用两个中的任一个。我想区分两个函数是为了更清晰吧。 还有 #define USART_IT_TC ((uint16_t)0x0626) #define USART_FLAG_TC ((uint16_t)0x0040) 这两个数值不同是因为标志位只是为了清除标志位而设的，而中断位设置成这个值是因为在其他函数中这一位还 有其他用途。而且还要注意： void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG) { /* Check the parameters */ assert_param(IS_USART_ALL_PERIPH(USARTx)); assert_param(IS_USART_CLEAR_FLAG(USART_FLAG)); assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */ USARTx-&gt;SR = (uint16_t)~USART_FLAG; } 这一步 USARTx-&gt;SR = (uint16_t)~USART_FLAG; 似乎应该是 USARTx-&gt;SR &amp;= (uint16_t)~USART_FLAG; 其实状态位只能有硬件置位，软件只能读和清零，所以这样写也是正确的。 没有很明白，所以转在这里，等我哪天灵光乍现了，再来加上我的理解" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/096fee44e00bc18e34412a7f0b005ade/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-02T09:00:38+08:00" />
<meta property="article:modified_time" content="2018-07-02T09:00:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">USART_ClearITPendingBith和 USART_ClearFlag的区别</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>起初</h2> 
<p><span style="color:#333333;">stm32 v3.5 库函数里面，对于串口USART有这样两个函数：</span><br><span style="color:#333333;">                USART_ClearFlag()和USART_ClearITPendingBit()</span></p> 
<p><br><span style="color:#333333;">查库函数定义，说一个是清除标志，一个是清除中断预处理位。</span><span style="color:#333333;">然后我看了stm32f10x_usart.c文件，发现两个函数都操作的是USART-&gt;SR寄存器，</span><span style="color:#333333;">但是这个寄存器只有一组标志位，没有什么中断预处理位。。</span></p> 
<pre class="has"><code class="language-html">实际上两个函数实现的功能是一样的，都是清除相对应的标志位，只是标志位和中断位含义不一样，是标志位但
是不一定会产生中断。例如：
#define USART_IT_TXE                         ((uint16_t)0x0727)
#define USART_IT_TC                          ((uint16_t)0x0626)
#define USART_IT_RXNE                        ((uint16_t)0x0525)
这是中断位，可以产生中断

#define USART_FLAG_TXE                       ((uint16_t)0x0080)
#define USART_FLAG_TC                        ((uint16_t)0x0040)
#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
这是标志位，有的标志位不能产生中断

标志位在程序中可以作为判定条件，支持程序的运行，中断则是跳转到中断函数执行。两个函数实现的功能是一
样的，在中断程序中可以用两个中的任一个。我想区分两个函数是为了更清晰吧。
还有
#define USART_IT_TC                          ((uint16_t)0x0626)
#define USART_FLAG_TC                        ((uint16_t)0x0040)

这两个数值不同是因为标志位只是为了清除标志位而设的，而中断位设置成这个值是因为在其他函数中这一位还
有其他用途。而且还要注意：
void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
   
  USARTx-&gt;SR = (uint16_t)~USART_FLAG;
}

 这一步 USARTx-&gt;SR = (uint16_t)~USART_FLAG; 似乎应该是  USARTx-&gt;SR &amp;= (uint16_t)~USART_FLAG;
其实状态位只能有硬件置位，软件只能读和清零，所以这样写也是正确的。</code></pre> 
<blockquote> 
 <p>没有很明白，所以转在这里，等我哪天灵光乍现了，再来加上我的理解<br> 上面的内容是别人的，我略作修改，下面的内容是我原创。不知道本文到底是属于原创还是转载，但是......我的更简洁、精辟</p> 
</blockquote> 
<p> -----------------------------------------------------------------------------------------------------------------------</p> 
<h2>灵光乍现了</h2> 
<p>我是在使用TC的时候遇见这个问题的，所以这里就只分析TC这个位</p> 
<p>先研究简单点的USART_ClearFlag函数</p> 
<pre class="has"><code class="language-cpp">//调用形式
USART_ClearFlag(USART3,USART_FLAG_TC);

//USART_FLAG_TC的定义
#define USART_FLAG_TC               ((uint16_t)0x0040)

//USART_ClearFlag函数的原型
void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
   
  USARTx-&gt;SR = (uint16_t)~USART_FLAG;
}</code></pre> 
<p>一目了然，最后USARTx-&gt;SR = ~(0100'0000);</p> 
<p>再来研究复杂点的USART_ClearITPendingBit函数（注意，这两个函数的第二个参数，<u><em><strong>是不一样的</strong></em></u>）</p> 
<pre class="has"><code class="language-cpp">//调用形式
USART_ClearITPendingBit(USART3,USART_IT_TC);

//USART_IT_TC的定义
#define USART_IT_TC           ((uint16_t)0x0626)//=0000'0110'0010'0110

//USART_ClearITPendingBit的函数原型
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
{
  uint16_t bitpos = 0x00, itmask = 0x00;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_IT(USART_IT));
  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
  
  bitpos = USART_IT &gt;&gt; 0x08;                     //=0000'0110
  itmask = (uint16_t)((uint16_t)0x01 &lt;&lt; bitpos); //=0100'0000
  USARTx-&gt;SR = (uint16_t)~itmask;                //=~(0100'0000)
}</code></pre> 
<p>可以看到最后还是USARTx-&gt;SR=~(0100'0000)；</p> 
<p>对比一下USART_ClearFlag和USART_ClearITPendingBit的参数</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:254px;">USART_ClearFlag的参数</td><td style="width:298px;">USART_ClearITPendingBit的参数</td></tr><tr><td style="width:254px;">USART_FLAG_CTS    = 0x0200</td><td style="width:298px;">USART_IT_CTS   = 0x0<span style="color:#f33b45;">9</span>6A</td></tr><tr><td style="width:254px;">USART_FLAG_LBD    = 0x0100</td><td style="width:298px;">USART_IT_LBD    = 0x0<span style="color:#f33b45;">8</span>46</td></tr><tr><td>USART_FLAG_TC      = 0x0040</td><td>USART_IT_TC      = 0x0<span style="color:#f33b45;">6</span>26</td></tr><tr><td>USART_FLAG_RXNE = 0x0020</td><td>USART_IT_RXNE = 0x0<span style="color:#f33b45;">5</span>25</td></tr></tbody></table> 
<p><span style="color:#4f4f4f;">这里可以发现一个规律USART_ClearFlag参数只有一个位是“1”，其位置正好等于USART_ClearITPendingBit的参数左移八位后的结果，所以这里可以非常非常肯定的讲：函数USART_ClearFlag和函数USART_ClearITPendingBit的</span><span style="color:#ff0000;">功能</span><span style="color:#f33b45;">totally一样</span></p> 
<p>----------------------------------------------------------------------------------------------------------------------------</p> 
<h2 id="%E6%B6%89%E5%8F%8A%E5%86%85%E5%AE%B9%E6%89%A9%E5%B1%95%EF%BC%9A">涉及内容扩展：</h2> 
<p>STM32的USART发送数据时如何使用TXE和TC标志</p> 
<p><span style="color:#333333;">     在USART的发送端有2个寄存器，一个是程序可以看到的<span style="color:#333333;">寄存器——发送数据寄存器（通过</span></span><span style="color:#333333;">USART_DR</span><span style="color:#333333;">查看</span><span style="color:#333333;">）,另一个是程序看不到的寄存器——发送移位寄存器,对应的</span><span style="color:#333333;">有</span><span style="color:#333333;">两个</span><span style="color:#333333;">USART数据发送标志，</span><span style="color:#ff0000;">一个是TXE=发送数据寄存器空，另一个是TC=发送移位寄存器空</span><span style="color:#333333;">。</span></p> 
<p><span style="color:#333333;"><img alt="" class="has" src="https://images2.imgbox.com/45/3b/lfiK1YYn_o.png"></span></p> 
<p><span style="color:#333333;">（这粗箭头和这细箭头，简直不要太形象哦，粗箭头是八位八位的传，细箭头是一位一位的传）</span></p> 
<p><span style="color:#ff0000;">    当USART_DR中的数据传送到移位寄存器后，TXE被设置</span>，此时移位寄存器开始向TX信号线按位传输数据，但因为TDR已经变空，所以程序可以把下一个要发送的字节(操作USART_DR)写入TDR中，而不必等到移位寄存器中所有位发送结束，<span style="color:#ff0000;">所有位发送结束时(送出停止位后)硬件会设置TC标志</span>。</p> 
<p>　　另一方面，在<span style="color:#ff0000;">刚刚初始化好USART还没有发送任何数据时，也会有TXE标志，因为这时发送数据寄存器是空的</span>。TXEIE和TCIE的意义很简单，TXEIE允许在TXE标志为'1'时产生中断，而TCIE允许在TC标志为'1'时产生中断。</p> 
<p>　　至于什么时候使用哪个标志，需要根据你的需要自己决定。但我认为TXE允许程序有更充裕的时间填写TDR寄存器，保证发送的数据流不间断。TC可以让程序知道发送结束的确切时间，有利于程序控制外部数据流的时序。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/a7/85/T4OExoWA_o.png"></p> 
<p> </p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:40px;">位7</td><td> <p>TXE:发送数据寄存器空 (Transmit data register empty)</p> <p>当TDR寄存器中的数据被硬件转移到移位寄存器的时候，该位被硬件置位。如果USART_CR1寄存器中的TXEIE为1，则产生中断。<span style="color:#f33b45;">对USART_DR的写操作，将该位清零</span>。</p> 0：数据还没有被转移到移位寄存器；<br> 1：数据已经被转移到移位寄存器。<br> 注意：单缓冲器传输中使用该位。</td></tr><tr><td style="width:40px;">位6</td><td> <p>TC：发送完成 (Transmission complete)</p> <p>当包含有数据的一帧发送完成后，并且TXE=1时，由硬件将该位置’1’。如果USART_CR1中的TCIE为’1’，则产生中断。由软件序列清除该位(先读USART_SR，然后写入USART_DR)。 TC位也可以通过写入’0’来清除，只有在多缓存通讯中才推荐这种清除程序。</p> 0：发送还未完成；<br> 1：发送完成</td></tr><tr><td style="width:40px;">位5</td><td>RXNE：读数据寄存器非空 (Read data register not empty)<br> 当RDR移位寄存器中的数据被转移到USART_DR寄存器中，该位被硬件置位。如果USART_CR1寄存器中的RXNEIE为1，则产生中断。<span style="color:#f33b45;">对USART_DR的读操作可以将该位清零</span>。 RXNE位也可以通过写入0来清除，只有在多缓存通讯中才推荐这种清除程序。<br> 0：数据没有收到；<br> 1：收到数据，可以读出。</td></tr></tbody></table> 
<h2 id="%E4%B8%89%E7%A7%8D%E5%8F%91%E9%80%81%E6%96%B9%E6%B3%95">三种发送方法</h2> 
<h4 id="1%E3%80%81%E4%B8%8D%E5%BC%80%E5%8F%91%E9%80%81%E5%AE%8C%E6%88%90%E4%B8%AD%E6%96%AD%EF%BC%9A">1、不开发送完成中断：</h4> 
<pre class="has"><code class="language-cpp">/*******************************************************************************
* 函数名  : UART1_SendString
* 描述    : USART1发送字符串
* 输入    : *s字符串指针
* 注释    ：0==RESET,表示发送还未完成
USART_FLAG_TC!=RESET，就是=SET，表示发送完成，此时执行USART_GetFlagStatus会把USART_FLAG_TC清零（未证实）
*******************************************************************************/
void UART1_SendString(u8* s)
{
  while(*s)//检测字符串结束符
  {
   //USART_FLAG_TC==RESET时，表示发送还未完成。
    while(USART_GetFlagStatus(USART1, USART_FLAG_TC)==RESET); 
    USART_SendData(USART1 ,*s++);//发送当前字符
  }
}</code></pre> 
<h4>2、开中断，额外设置一个标志：</h4> 
<pre class="has"><code class="language-cpp">u8 FLAG_TC=0;//定义全局变量
/*******************************************************************************
* 函数名  : UART1_SendString
* 描述    : USART1发送字符串
* 输入    : *s字符串指针
*******************************************************************************/
void UART1_SendString(char* s)
{
  FLAG_TC=0;//提前准备一下
  while(*s)//检测字符串结束符
  {
    USART_SendData(USART1 ,*s++);//发送当前字符
    while( FLAG_TC==0);	//0：发送还未完成；1：发送完成
    FLAG_TC=0;
  }
}


void USART1_IRQHandler(void)
{
  if (USART_GetITStatus(USART1, USART_IT_TC) != RESET)//发送完成中断,= SET
  {
    USART_ClearITPendingBit(USART1,USART_IT_TC);
    FLAG_TC=1;
  }
}</code></pre> 
<p> </p> 
<blockquote> 
 <p>开中断时，就不能通过简单的判断标志位USART_FLAG_TC的状态去决定能否发送下一个字符。比方说，<span style="color:#4f4f4f;">使用 </span></p> 
 <pre class="has"><code class="language-cpp">while(*s)
{

   USART_SendData(USART1 ,*s++);//发送字符

   while(USART_GetFlagStatus(USART1, USART_FLAG_TC)==RESET); 

   ...
}</code></pre> 
 <p>执行完发送字符的语句后，因为不可能这么快完成发送，所以程序接下来执行的是while语句。在等待期间，字符发送完毕，这时就会进入到中断，如果在中断里清除标志位，退出中断后，标志位USART_FLAG_TC仍然是RESET；如果不在中断里清除标志位，就不能退出中断。所以程序就会死在while里。</p> 
 <p>所以这里就需要额外设置一个标志。</p> 
</blockquote> 
<h4 id="3%E3%80%81%E5%BC%80%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%98%AF%E7%94%B1%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%EF%BC%8C%E5%9C%A8%E4%B8%AD%E6%96%AD%E9%87%8C%E5%AE%8C%E6%88%90%EF%BC%9A">3、开中断，数据发送由函数启动，在中断里完成：</h4> 
<pre class="has"><code class="language-cpp">//定义全局变量。也可以为了简化，把这四个参数结合起来包含在一个结构体里
u8 TxLength;   //发送数据长度
u8 TxIndicator;//发送指示器，表示目前发送完成哪一位了，下面要发送的是第（TxIndicator+1）位
u8 TxBuff[256];//Data 
u8 TxFnd;      //发送完成标志
     
/*************************************************************************
*程序名称    :   SendFirstByte
*功能        :   启动发送第一个字节
*@Notes     ：   鸡贼啊，剩下的都放在USART_FLAG_TC中断里面，因为这个中断是
                 发送完成中断，是利用“发送第一个字节”来“启动发送”
*@Notes     :   需要注意，如果发送结果是乱码的话，一种供参考的解决方案是
                把数据直接赋值给TxBuff，而不要通过函数的形参传递
*输入参数    :   u8 txbuf[]: 需要发送的数据,u8 len : 数据中的字节数
*返回值      :   无
*************************************************************************/
void SendFirstByte( u8 txbuf[], u8 len )
{
	TxBuff      = txbuf;//需要发送的数据
	TxLength    = len  ;//发送数据长度
	TxIndicator = 1    ;//0已经发送，也是用来启动发送的

	USART_SendData(USART1, txbuf[0]);  /**@Notes：只发送了txbuf的第一个字节*/
}

/*************************************************************************
*程序名称    :   USART1_IRQHandler
*功能        :   完成发送数据   
*************************************************************************/
void USART1_IRQHandler(void)
{
	if (USART_GetITStatus(USART1, USART_IT_TC) != RESET)
	{
		USART_ClearITPendingBit(USART1,USART_IT_TC);
		if( TxIndicator &lt; TxLength  )//数组的索引max永远小于数组元素的个数
		{
			USART_SendData(USART1, TxBuff[TxIndicator++]);
		}
		else//最后一字节数据发送完成
		{
			TxFnd = 0;
			TxIndicator = 0;
		}
	}
}</code></pre> 
<h2 id="USART%E6%94%B6%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B8%B8%E9%81%87%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%9A">USART收发过程中常遇问题总结：</h2> 
<h4 id="Q%3A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8USART%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6%EF%BC%8C%E6%9C%80%E5%90%8E%E8%87%AA%E6%8E%A5%E6%94%B6%E5%88%B0%E4%BA%86%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%EF%BC%9F"><strong><em>Q:为什么使用USART发送一串字符，最后自接收到了最后一个？</em></strong></h4> 
<p>A:是因为发送的间隔太短了，可以在发送每个字符之前先判断一下上一个字符是否发送完成，可以参考上面的“三种发送方法”</p> 
<h4 id="Q%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8USART%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6%EF%BC%8C%E6%9C%89%E6%97%B6%E5%80%99%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E6%9C%89%E6%97%B6%E5%80%99%E5%8F%88%E5%8F%AF%E4%BB%A5%E6%8E%A5%E6%94%B6%E5%BE%97%E5%88%B0%EF%BC%9F"><strong><em>Q：为什么使用USART发送一串字符，有时候接收不到第一个字符，有时候又可以接收得到？</em></strong></h4> 
<p>A：解决方案是把判断能否发送的语句放在发送数据之前</p> 
<h2>功德圆满</h2> 
<p>这下算是功德圆满了吧</p> 
<p style="text-indent:0;"> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb67a44c4e93dc4d01886d61c7b3f505/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在react中正确修改state</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d851a143762467706f93c4a354ee3ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">简单地使用webpack进行打包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>