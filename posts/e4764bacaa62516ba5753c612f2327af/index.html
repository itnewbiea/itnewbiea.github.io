<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>消息中间件——RabbitMQ（七）高级特性 2 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="消息中间件——RabbitMQ（七）高级特性 2" />
<meta property="og:description" content="前言 上一篇消息中间件——RabbitMQ（七）高级特性 1中我们介绍了消息如何保障100%的投递成功？,幂等性概念详解,在海量订单产生的业务高峰期，如何避免消息的重复消费的问题？,Confirm确认消息、Return返回消息。这篇我们来介绍下下面内容。
自定义消费者消息的限流（防止占用内存过多，节点宕机）消息的ACK与重回队列TTL消息死信队列 1. 自定义消费者 1.1 消费端自定义监听 我们一般就在代码中编写while循环，进行consumer.nextDelivery方法进行获取下一条消息，然后进行消费处理！
但是这种轮训的方式肯定是不好的，代码也比较low。
我们使用自定义的Consumer更加的方便，解耦性更加的强，也是在实际工作中最常见的使用方式！ 1.2 代码演示 1.2.1 生产者 public class Producer { public static void main(String[] args) throws Exception { //1 创建ConnectionFactory Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); String exchange = &#34;test_consumer_exchange&#34;; String routingKey = &#34;consumer.save&#34;; String msg = &#34;Hello RabbitMQ Consumer Message&#34;; for(int i =0; i&lt;5; i &#43;&#43;){ channel.basicPublish(exchange, routingKey, true, null, msg.getBytes()); } } } 1.2.2 消费者 public class Consumer { public static void main(String[] args) throws Exception { // 创建ConnectionFactory Connection connection = ConnectionUtils." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e4764bacaa62516ba5753c612f2327af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-29T17:23:34+08:00" />
<meta property="article:modified_time" content="2023-11-29T17:23:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">消息中间件——RabbitMQ（七）高级特性 2</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><img alt="" height="389" src="https://images2.imgbox.com/d2/dc/98AcfnX4_o.png" width="702"></h3> 
<h3 id="前言">前言</h3> 
<p>上一篇<a href="https://blog.csdn.net/vc33569/article/details/134693566" title="消息中间件——RabbitMQ（七）高级特性 1">消息中间件——RabbitMQ（七）高级特性 1</a>中我们介绍了<code>消息如何保障100%的投递成功？</code>,<code>幂等性概念详解</code>,<code>在海量订单产生的业务高峰期，如何避免消息的重复消费的问题？</code>,<code>Confirm确认消息、Return返回消息</code>。这篇我们来介绍下下面内容。</p> 
<ul><li>自定义消费者</li><li>消息的限流（防止占用内存过多，节点宕机）</li><li>消息的ACK与重回队列</li><li>TTL消息</li><li>死信队列</li></ul> 
<h3 id="1-自定义消费者">1. 自定义消费者</h3> 
<h4 id="11-消费端自定义监听">1.1 消费端自定义监听</h4> 
<p>我们一般就在代码中编写while循环，进行consumer.nextDelivery方法进行获取下一条消息，然后进行消费处理！</p> 
<p>但是这种轮训的方式肯定是不好的，代码也比较low。</p> 
<ul><li>我们使用自定义的Consumer更加的方便，解耦性更加的强，也是在实际工作中最常见的使用方式！</li></ul> 
<p><img alt="" height="607" src="https://images2.imgbox.com/b3/17/lbzknOyR_o.png" width="1200"></p> 
<p></p> 
<h4 id="12-代码演示">1.2 代码演示</h4> 
<h5 id="121-生产者">1.2.1 生产者</h5> 
<pre><code class="language-java">public class Producer {

	
	public static void main(String[] args) throws Exception {
		
		//1 创建ConnectionFactory
		Connection connection = ConnectionUtils.getConnection();
		Channel channel = connection.createChannel();
		
		String exchange = "test_consumer_exchange";
		String routingKey = "consumer.save";
		
		String msg = "Hello RabbitMQ Consumer Message";
		
		for(int i =0; i&lt;5; i ++){
			channel.basicPublish(exchange, routingKey, true, null, msg.getBytes());
		}
		
	}
}

</code></pre> 
<h5 id="122-消费者">1.2.2 消费者</h5> 
<pre><code class="language-java">public class Consumer {

	
	public static void main(String[] args) throws Exception {
		
		
		// 创建ConnectionFactory
		Connection connection = ConnectionUtils.getConnection();
		Channel channel = connection.createChannel();
		
		
		String exchangeName = "test_consumer_exchange";
		String routingKey = "consumer.#";
		String queueName = "test_consumer_queue";
		
		channel.exchangeDeclare(exchangeName, "topic", true, false, null);
		channel.queueDeclare(queueName, true, false, false, null);
		channel.queueBind(queueName, exchangeName, routingKey);
		
		//实现自己的MyConsumer()
		channel.basicConsume(queueName, true, new MyConsumer(channel));
	}
}

</code></pre> 
<h5 id="123-自定义类：myconsumer">1.2.3 自定义类：MyConsumer</h5> 
<pre><code class="language-java">public class MyConsumer extends DefaultConsumer {

    public MyConsumer(Channel channel) {
        super(channel);
    }

    //根据需求，重写自己需要的方法。
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, 
                               AMQP.BasicProperties properties, byte[] body) 
                               throws IOException {
        System.err.println("-----------consume message----------");
        //消费标签
        System.err.println("consumerTag: " + consumerTag);
        //这个对象包含许多关键信息
        System.err.println("envelope: " + envelope);
        System.err.println("properties: " + properties);
        System.err.println("body: " + new String(body));
    }

}
</code></pre> 
<h4 id="13-打印结果">1.3 打印结果<img alt="" height="381" src="https://images2.imgbox.com/34/26/6WELkTJ0_o.png" width="1183"></h4> 
<p></p> 
<h3 id="2-消费端限流">2. 消费端限流</h3> 
<h4 id="21-什么是消费端的限流？">2.1 什么是消费端的限流？</h4> 
<ul><li>假设一个场景，首先，我们Rabbitmq服务器有上万条未处理的消息，我们随便打开一个消费者客户端，会出现下面情况：</li><li>巨量的消息瞬间全部推送过来，但是我们单个客户端无法同时处理这么多数据！这个时候很容易导致服务器崩溃，出现故障。</li></ul> 
<p><strong>为什么不在生产端进行限流呢？</strong></p> 
<p>因为在高并发的情况下，客户量就是非常大，所以很难在生产端做限制。因此我们可以用MQ在消费端做限流。</p> 
<ul><li>RabbitMQ提供了一种qos(服务质量保证)功能，即在非自动确认消息的前提下，如果一定数目的消息（通过基于consume或者channel设置Qos的值）未被确认前，不进行消费新的消息。<br> 在限流的情况下，<strong>千万不要设置自动签收，要设置为手动签收</strong>。</li><li>void BasicQos(uint prfetchSize,ushort prefetchCount,bool global);</li></ul> 
<p><strong>参数解释：</strong><br> prefetchSize:0<br> prefetchCount:会告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack。<br> global: true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别还是consumer级别。<br> prefetchSize和global这两项，rabbitmq没有实现，暂且不研究prefetch_count在no_ask = false的情况下生效，即在自动应答的情况下这两个值是不生效的。</p> 
<p>第一个参数：消息的限制大小，消息多少兆。一般不做限制，设置为0<br> 第二个参数：一次最多处理多少条，实际工作中设置为1就好<br> 第三个参数：限流策略在什么上应用。在RabbitMQ一般有两个应用级别：1.通道 2.Consumer级别。一般设置为false，true 表示channel级别，false表示在consumer级别</p> 
<h4 id="22-代码演示">2.2 代码演示</h4> 
<h5 id="221-生产者">2.2.1 生产者</h5> 
<pre><code class="language-java">public class Producer {

	
	public static void main(String[] args) throws Exception {
		
		//1 创建ConnectionFactory
		Connection connection = ConnectionUtils.getConnection();
		Channel channel = connection.createChannel();
		
		String exchange = "test_qos_exchange";
		String routingKey = "qos.save";
		
		String msg = "Hello RabbitMQ QOS Message";
		
		for(int i =0; i&lt;5; i ++){
			channel.basicPublish(exchange, routingKey, true, null, msg.getBytes());
		}
		
	}
}

</code></pre> 
<h5 id="222-消费者">2.2.2 消费者</h5> 
<pre><code class="language-java">public class Consumer {
	
	public static void main(String[] args) throws Exception {		
		
		//1 创建ConnectionFactory
		Connection connection = ConnectionUtils.getConnection();
		Channel channel = connection.createChannel();		
		
		String exchangeName = "test_qos_exchange";
		String queueName = "test_qos_queue";
		String routingKey = "qos.#";
		
		channel.exchangeDeclare(exchangeName, "topic", true, false, null);
		channel.queueDeclare(queueName, true, false, false, null);
		channel.queueBind(queueName, exchangeName, routingKey);
		
		//1 限流方式  第一件事就是 autoAck设置为 false
        //设置为1，表示一条一条数据处理
		channel.basicQos(0, 1, false);
		
		channel.basicConsume(queueName, false, new MyConsumer(channel));		
		
	}
}

</code></pre> 
<h5 id="223-自定义类：myconsumer">2.2.3 自定义类：MyConsumer</h5> 
<pre><code class="language-java">public class MyConsumer extends DefaultConsumer {


	private Channel channel ;
	
	public MyConsumer(Channel channel) {
		super(channel);
		this.channel = channel;
	}

	@Override
public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties 
                                        properties, byte[] body) throws IOException {

		System.err.println("-----------consume message----------");
		System.err.println("consumerTag: " + consumerTag);
		System.err.println("envelope: " + envelope);
		System.err.println("properties: " + properties);
		System.err.println("body: " + new String(body));
		
		//需要做签收,false表示不支持批量签收
		channel.basicAck(envelope.getDeliveryTag(), false);
		
	}


}

</code></pre> 
<h5 id="224-测试结果">2.2.4 测试结果</h5> 
<p>我们先注释掉：channel.basicAck(envelope.getDeliveryTag(), false);然后启动Consumer。<br> 查看Exchange</p> 
<p><img alt="" height="642" src="https://images2.imgbox.com/f7/e2/Od8B2fKc_o.png" width="557"></p> 
<p></p> 
<p>查看Queues</p> 
<p><img alt="" height="595" src="https://images2.imgbox.com/37/da/HIxnN1WM_o.png" width="667"></p> 
<p></p> 
<p>然后再启动Producer。查看打印结果：</p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/88/54/SQ2OpW70_o.png" width="1200"></p> 
<p></p> 
<p>我们会发现消费端，只收到了一条消息。这是为什么呢？</p> 
<p>第一点因为我们在consumer中</p> 
<pre><code>channel.basicConsume(queueName, false, new MyConsumer(channel));</code></pre> 
<p>第二个参数设置为false为手动签收。</p> 
<p>第二点在qos中设置只接受一条消息。如果这一条消息不给Broker Ack应答的话，那么Broker会认为你并没有消费完这一条消息，那么就不会继续发送消息。</p> 
<pre><code>channel.basicQos(0, 1, false);
</code></pre> 
<p>可以看下管控台，unack=1，Ready=4，total=5.</p> 
<p><img alt="" height="293" src="https://images2.imgbox.com/01/d6/aRiMitCy_o.png" width="804"></p> 
<p></p> 
<hr> 
<p>接下来我们放开注释channel.basicAck(envelope.getDeliveryTag(), false); 进行消息签收。重启服务。</p> 
<h4 id="31-打印结果">3.1 打印结果</h4> 
<p><img alt="" height="375" src="https://images2.imgbox.com/6f/72/B8zb11X1_o.png" width="1200"></p> 
<p></p> 
<p>可以看到正常打印五条结果</p> 
<h3 id="4-消费端ack与重回队列">4. 消费端ACK与重回队列</h3> 
<h4 id="41-消费端的手工ack和nack">4.1 消费端的手工ACK和NACK</h4> 
<p>消费端进行消费的时候，如果由于业务异常我们可以进行日志的记录，然后进行补偿！</p> 
<p>如果由于服务器宕机等严重问题，那我们就需要手工进行ACK保障消费端消费成功！</p> 
<h4 id="42-消费端的重回队列">4.2 消费端的重回队列</h4> 
<p>消费端重回队列是为了对没有处理成功的消息，把消息重新传递给Broker!</p> 
<p>一般我们在实际应用中，都会关闭重回队列，也就是设置为False.</p> 
<h4 id="43-代码演示">4.3 代码演示</h4> 
<h5 id="431-生产者">4.3.1 生产者</h5> 
<pre><code class="language-java">public class Producer {
	
	public static void main(String[] args) throws Exception {
		
		//1创建ConnectionFactory
		Connection connection = ConnectionUtils.getConnection();
		Channel channel = connection.createChannel();
		
		String exchange = "test_ack_exchange";
		String routingKey = "ack.save";		
		
		
		for(int i =0; i&lt;5; i ++){
			
			Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();
			headers.put("num", i);
			
			//添加属性，后续会使用到
			AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
					.deliveryMode(2) //投递模式，持久化
					.contentEncoding("UTF-8")
					.headers(headers)
					.build();
			String msg = "Hello RabbitMQ ACK Message " + i;
			channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes());
		}
		
	}
}

</code></pre> 
<h5 id="432-消费者">4.3.2 消费者</h5> 
<pre><code class="language-java">public class Consumer {
	
	public static void main(String[] args) throws Exception {
		
		
		//1创建ConnectionFactory
		Connection connection = ConnectionUtils.getConnection();
		Channel channel = connection.createChannel();
		
		
		String exchangeName = "test_ack_exchange";
		String queueName = "test_ack_queue";
		String routingKey = "ack.#";
		
		channel.exchangeDeclare(exchangeName, "topic", true, false, null);
		channel.queueDeclare(queueName, true, false, false, null);
		channel.queueBind(queueName, exchangeName, routingKey);
		
		// 手工签收 必须要关闭 autoAck = false
		channel.basicConsume(queueName, false, new MyConsumer(channel));
		
		
	}
}

</code></pre> 
<h5 id="433-自定义类：myconsumer">4.3.3 自定义类：MyConsumer</h5> 
<pre><code class="language-java">public class MyConsumer extends DefaultConsumer {


	private Channel channel ;
	
	public MyConsumer(Channel channel) {
		super(channel);
		this.channel = channel;
	}

	@Override
public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
		System.err.println("-----------consume message----------");
		System.err.println("body: " + new String(body));
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		if((Integer)properties.getHeaders().get("num") == 0) {
			//Nack三个参数  第二个参数：是否是批量，第三个参数：是否重回队列（需要注意可能会发生重复消费，造成死循环）
			channel.basicNack(envelope.getDeliveryTag(), false, true);
		} else {
			channel.basicAck(envelope.getDeliveryTag(), false);
		}
		
	}


}

</code></pre> 
<h4 id="51-打印结果：">5.1 打印结果：</h4> 
<p><img alt="" height="427" src="https://images2.imgbox.com/21/08/ZtUVFtgE_o.png" width="515"></p> 
<p></p> 
<blockquote> 
 <p>注意：<br> 可以看到重回队列会出现重复消费导致死循环的问题，这时候最好设置重试次数，比如超过三次后，消息还是消费失败，就将消息丢弃。</p> 
</blockquote> 
<h3 id="6-ttl队列消息">6. TTL队列/消息</h3> 
<h4 id="61-ttl">6.1 TTL</h4> 
<ul><li>TTL是Time To Live的缩写，也就是生存时间</li><li>RabbitMQ支持消息的过期时间，在消息发送时可以进行指定</li><li>RabbitMQ支持队列的过期时间，从消息入队列开始计算，只要超过了队列的超时时间配置，那么消息会自动的清除</li></ul> 
<h4 id="62-代码演示">6.2 代码演示</h4> 
<h5 id="621-直接通过管控台进行演示">6.2.1 直接通过管控台进行演示</h5> 
<p><img alt="" height="305" src="https://images2.imgbox.com/6b/fb/bAS5fNRn_o.png" width="846"></p> 
<p></p> 
<p>通过管控台创建一个队列</p> 
<p>x-max-length 队列的最大大小<br> x-message-ttl 设置10秒钟，如果消息还没有被消费的话，就会被清除。</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/1f/9f/oMVkxyTn_o.png" width="1054"></p> 
<p></p> 
<p><strong>添加exchange</strong></p> 
<p><img alt="" height="925" src="https://images2.imgbox.com/46/6c/lJSWndLO_o.png" width="1180"></p> 
<p></p> 
<p><strong>Queue与Exchange进行绑定</strong></p> 
<p>点击 test_ttl_exchange 进行绑定</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/af/62/55gyIifp_o.png" width="713"></p> 
<p></p> 
<p><strong>查看是否绑定成功</strong></p> 
<p><img alt="" height="799" src="https://images2.imgbox.com/de/d7/qA2T8IF9_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p><strong>通过管控台发送消息</strong></p> 
<p><img alt="" height="856" src="https://images2.imgbox.com/d1/ae/O1fceDSJ_o.png" width="1200"><img alt="" height="507" src="https://images2.imgbox.com/01/a3/1TeRhv7S_o.png" width="1075"></p> 
<p></p> 
<p></p> 
<p><strong>消息未处理自动清除</strong><img alt="" height="55" src="https://images2.imgbox.com/75/a0/I1FZ4DVn_o.png" width="926"></p> 
<p><strong>生产端设置过期时间</strong></p> 
<pre><code>AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
				.deliveryMode(2)
				.contentEncoding("UTF-8")
				.expiration("10000")
				.headers(headers)
				.build();
</code></pre> 
<p>这两个属性并不相同，一个对应的是消息体，一个对应的是队列的过期。</p> 
<h3 id="7-死信队列">7. 死信队列</h3> 
<h4 id="71-概念理解">7.1 概念理解</h4> 
<p>死信队列：DLX,Dead-Letter-Exchange<br> RabbitMQ的死信队里与Exchange息息相关</p> 
<ul><li>利用DLX,当消息在一个队列中变成死信（dead message）之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX</li></ul> 
<p>消息变成死信有以下几种情况</p> 
<ul><li>消息被拒绝（basic.reject/basic.nack）并且requeue=false</li><li>消息TTL过期</li><li>队列达到最大长度</li></ul> 
<p>DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性</p> 
<p>当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。</p> 
<p></p> 
<p>可以监听这个队列中消息做相应的处理，这个特征可以弥补RabbitMQ3.0以前支持的immediate参数的功能。</p> 
<h4 id="72-代码演示">7.2 代码演示</h4> 
<ul><li>死信队列设置：</li><li>首先需要设置死信队列的exchange和queue,然后进行绑定：<br> Exchange:dlx.exchange<br> Queue:dlx.queue<br> RoutingKey:#</li><li>然后我们进行正常声明交换机、队列、绑定，只不过我们需要在队列加上一个参数即可：arguments.put(“x-dead-letter-exchange”,”dlx.exchange”);</li><li>这样消息在过期、requeue、队列在达到最大长度时，消息就可以直接路由到死信队列！</li></ul> 
<h5 id="721-生产者">7.2.1 生产者</h5> 
<pre><code class="language-java">public class Producer {

	
	public static void main(String[] args) throws Exception {
		
		//创建ConnectionFactory
		Connection connection = ConnectionUtils.getConnection();
		Channel channel = connection.createChannel();
		
		String exchange = "test_dlx_exchange";
		String routingKey = "dlx.save";
		
		String msg = "Hello RabbitMQ DLX Message";
		
		for(int i =0; i&lt;1; i ++){
			
			AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
					.deliveryMode(2)
					.contentEncoding("UTF-8")
					.expiration("10000")
					.build();
			channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes());
		}
		
	}
}

</code></pre> 
<h5 id="722-消费者">7.2.2 消费者</h5> 
<pre><code class="language-java">
public class Consumer {

	
	public static void main(String[] args) throws Exception {
		
		
		//创建ConnectionFactory
		Connection connection = ConnectionUtils.getConnection();
		Channel channel = connection.createChannel();
		
		// 这就是一个普通的交换机 和 队列 以及路由
		String exchangeName = "test_dlx_exchange";
		String routingKey = "dlx.#";
		String queueName = "test_dlx_queue";
		
		channel.exchangeDeclare(exchangeName, "topic", true, false, null);
		
		Map&lt;String, Object&gt; agruments = new HashMap&lt;String, Object&gt;();
		agruments.put("x-dead-letter-exchange", "dlx.exchange");
		//这个agruments属性，要设置到声明队列上
		channel.queueDeclare(queueName, true, false, false, agruments);
		channel.queueBind(queueName, exchangeName, routingKey);
		
		//要进行死信队列的声明:
		channel.exchangeDeclare("dlx.exchange", "topic", true, false, null);
		channel.queueDeclare("dlx.queue", true, false, false, null);
		channel.queueBind("dlx.queue", "dlx.exchange", "#");
		
		channel.basicConsume(queueName, true, new MyConsumer(channel));
		
		
	}
}

</code></pre> 
<h5 id="723-自定义类：myconsumer">7.2.3 自定义类：MyConsumer</h5> 
<pre><code class="language-java">public class MyConsumer extends DefaultConsumer {


	public MyConsumer(Channel channel) {
		super(channel);
	}

	@Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties 
                           properties, byte[] body) throws IOException {
		
        System.err.println("-----------consume message----------");
		System.err.println("consumerTag: " + consumerTag);
		System.err.println("envelope: " + envelope);
		System.err.println("properties: " + properties);
		System.err.println("body: " + new String(body));
	}
}
</code></pre> 
<h5 id="724-测试结果">7.2.4 测试结果</h5> 
<p>运行Consumer，查看管控台</p> 
<p><br><strong>查看Exchanges</strong></p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/0d/dd/tT7huAf2_o.png" width="500"></p> 
<p></p> 
<p><strong>查看queue</strong></p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/40/9b/4hdQKEDp_o.png" width="1003"></p> 
<p></p> 
<p>可以看到test_dlx_queue多了DLX的标识，表示当队列中出现死信的时候，会将消息发送到死信队列dlx_queue中</p> 
<p>关闭Consumer，<strong>只运行Producer</strong></p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/8e/27/T0tAkY8F_o.png" width="979"></p> 
<p></p> 
<p>过10秒钟后，消息过期</p> 
<p>在我们工作中，死信队列非常重要，用于消息没有消费者，处于死信状态。我们可以才用补偿机制。</p> 
<h3 id="小结">小结</h3> 
<p>本次主要介绍了RabbitMQ的高级特性，首先介绍了互联网大厂在实际使用中如何保障100%的消息投递成功和幂等性的，以及对RabbitMQ的确认消息、返回消息、ACK与重回队列、消息的限流，以及对超时时间、死信队列的使用</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f78ddb460a8893092801930195f4a0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">消息中间件——RabbitMQ（七）高级特性 1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43a1e50379d5b4efc5faf18b27067ef4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uni-app 自定义宫格布局</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>