<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux驱动-设备树 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux驱动-设备树" />
<meta property="og:description" content="背景 在Linux内核没有引进设备树之前，每一个具体的硬件平台都会在 linux 源码包 arch/arm/mach-xxx/ 目录下存在一个硬件信息描述的源码包，其中定义了 GPIO、I2C 等外设和系统信息。这些信息也定义为 .h、.c 文件，内容多为描述设备信息的结构体，同驱动源码一起编译。这就会在内核中增加了许多没有技术含量的.c文件。Linux的祖师爷Linus看到这种现象后就大发雷霆：&#34;this whole ARM thing is a f*cking pain in the ass&#34;，所以为了解决这种现象，从linux-3.x版本开始引进了设备树。
什么是设备树？ 设备树（Device Tree）将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等。 在Linux内核源码中，ARM架构的设备树文件一般位于 linux 源码的 arch/arm/boot/dts 目录，对应 .dts(device tree source) 后缀的文件。dts 文件可以通过make dtbs 命令编译成 .dtb(device tree blob) 后缀的二进制文件，以供内核驱动使用。
概念 dts (device tree source) 设备树描述文件，硬件的相应信息都会写在.dts为后缀的文件中，每一款硬件可以单独写一份xxxx.dts，一般在Linux源码中存在大量的dts文件，对于 arm 架构可以在 arch/arm/boot/dts 目录下找到相应dts文件。
dtsi (device tree sourceinclude) 设备树头文件，对于一些相同的dts配置可以抽象到dtsi文件中，然后类似于 C 语言的方式可以include到dts文件中，对于同一个节点的设置情况，dts中的配置会覆盖dtsi中的配置；dtsi是关于芯片级别的描述。
dtc (device tree compiler) 设备树编译器，编写 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4279cfb4cca78926a100ba6fba74a6d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-08T14:25:54+08:00" />
<meta property="article:modified_time" content="2022-09-08T14:25:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux驱动-设备树</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="%E8%83%8C%E6%99%AF">背景 </h3> 
<p>        在Linux内核没有引进设备树之前，每一个具体的硬件平台都会在 linux 源码包 arch/arm/mach-xxx/ 目录下存在一个硬件信息描述的源码包，其中定义了 GPIO、I2C 等外设和系统信息。这些信息也定义为 .h、.c 文件，内容多为描述设备信息的结构体，同驱动源码一起编译。这就会在内核中增加了许多没有技术含量的.c文件。Linux的祖师爷Linus看到这种现象后就大发雷霆："this whole ARM thing is a f*cking pain in the ass"，所以为了解决这种现象，从linux-3.x版本开始引进了设备树。</p> 
<h3>什么是设备树？</h3> 
<p><strong>        设备树（Device Tree）</strong>将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等。 在Linux内核源码中，ARM架构的设备树文件一般位于 linux 源码的 arch/arm/boot/dts 目录，对应 .dts(device tree source) 后缀的文件。dts 文件可以通过<span style="background-color:#d7d8d9;">make dtbs</span><span style="background-color:#d7d8d9;"> </span>命令编译成 .dtb(device tree blob) 后缀的二进制文件，以供内核驱动使用。</p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/40/be/KUbKsrvC_o.jpg"></p> 
<p></p> 
<h3 id="%E6%A6%82%E5%BF%B5">概念</h3> 
<h4 id="dts(device%20tree%20source)">dts (device tree source)</h4> 
<p>         设备树描述文件，硬件的相应信息都会写在.dts为后缀的文件中，每一款硬件可以单独写一份xxxx.dts，一般在Linux源码中存在大量的dts文件，对于 arm 架构可以在 arch/arm/boot/dts 目录下找到相应dts文件。</p> 
<h4>dtsi (<strong>device tree sourceinclude)</strong></h4> 
<p><strong>        </strong>设备树头文件，对于一些相同的dts配置可以抽象到dtsi文件中，然后类似于 C 语言的方式可以include到dts文件中，对于同一个节点的设置情况，dts中的配置会覆盖dtsi中的配置；dtsi是关于芯片级别的描述。</p> 
<h4>dtc (<strong>device tree compiler</strong>)</h4> 
<p>        设备树编译器，编写 .dtc 使用设备树语法，则需要一个特定的编译器来编译，称为dtc工具，源码在 Linux 内核的 scripts/dtc 目录下。</p> 
<p style="text-align:center;"><img alt="" height="217" src="https://images2.imgbox.com/41/0f/WHQtw6aB_o.png" width="691"></p> 
<h4>dtb (device tree blob)</h4> 
<p>        dts 编译后的二进制文件，内核使用的是dtb文件。</p> 
<h3>设备树语法</h3> 
<ul><li> <h4>设备树版本</h4> </li></ul> 
<pre><code class="language-cpp">/dts-v1/</code></pre> 
<ul><li> <h4> 设备树节点(node)格式</h4> </li></ul> 
<p>        设备树是由一个个节点组成的，每个节点相当于树上的一片叶子，节点的结构和约定如下。</p> 
<pre><code class="language-cpp">[label:] node-name[@unit-address] {
    [properties definitions]
    [child nodes]
};
</code></pre> 
<p>        label是标号，可以省略。label的作用是为了方便地引用节点；node-name是节点名字，用于全路径引用节点；unit-address表示设备地址或者寄存器首地址（具体节点具体分析，不一定是绝对地址），必须与节点 reg 属性中指定的首地址匹配。</p> 
<p>eg. imx6ull.dtsi 中描述的 uart1 控制器节点：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/af/68/Qbpn7bAS_o.png"></p> 
<p>        该节点 label 为 uart1，节点名称为 serial，设备地址（寄存器首地址）为 02020000，正是 imx6ull uart1 外设寄存器的首地址。</p> 
<p>引用节点的两种方式如下：</p> 
<p>节点示例：</p> 
<pre><code class="language-cpp">/dts-v1/;

/ {
	uart0: uart@fe001000 {
        compatible="fsl,imx6ul-uart";
        reg=&lt;0xfe001000 0x100&gt;;
	};
};

</code></pre> 
<ol><li>通过label引用 <pre><code class="language-cpp">// 在根节点之外使用label引用node：
&amp;uart0 {
    status = “disabled”;
};
</code></pre> </li><li> <p>通过指定从根节点到所有子节点到所需节点的完整路径，可以唯一地标识设备树中的节点</p> <pre><code class="language-cpp">在根节点之外使用全路径：
&amp;{/uart@fe001000}  {
    status = “disabled”;
};
</code></pre> </li></ol> 
<ul><li> <h4>节点属性</h4> </li></ul> 
<p>        节点属性的格式：</p> 
<p>        简单地说，properties就是“name=value”，value有多种取值方式。</p> 
<pre><code class="language-cpp">格式一：
[label:] property-name = value; //有值

格式二：
[label:] property-name;  //无值</code></pre> 
<p>        value的取值方式：</p> 
<pre><code class="language-cpp">a. Arrays of cells : cell就是一个32位的数据，用尖括号包围起来
    interrupts = &lt;17 0xc&gt;;

b. 64bit数据使用2个cell来表示，用尖括号包围起来:
    clock-frequency = &lt;0x00000001 0x00000000&gt;;

c. A null-terminated string (有结束符的字符串)，用双引号包围起来:
    compatible = "simple-bus";

d. A bytestring(字节序列) ，用中括号包围起来:
    local-mac-address = [00 00 12 34 56 78];  // 每个byte使用2个16进制数来表示
    local-mac-address = [000012345678];       // 每个byte使用2个16进制数来表示

e. 可以是各种值的组合, 用逗号隔开:
    compatible = "ns16550", "ns8250";
    example = &lt;0xf00f0000 19&gt;, "a strange property format";


</code></pre> 
<h4>  常用属性：</h4> 
<ul><li>#address-cells、#size-cells</li></ul> 
<p style="margin-left:0;text-align:justify;">        cell指一个32位的数值，</p> 
<p style="margin-left:0;text-align:justify;">        address-cells：address要用多少个32位数来表示；</p> 
<p style="margin-left:0;text-align:justify;">        size-cells：size要用多少个32位数来表示。</p> 
<p style="margin-left:0;text-align:justify;">示例：</p> 
<pre><code class="language-cpp">/ {
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    memory {
            reg = &lt;0x80000000 0x20000000&gt;;
        };
};
</code></pre> 
<p style="margin-left:0;text-align:justify;">        上述例子描述了内存的大小，address-cells为1，所以reg中用1个数来表示地址，即用0x80000000来表示地址；size-cells为1，所以reg中用1个数来表示大小，即用0x20000000表示大小：</p> 
<ul><li>compatible</li></ul> 
<p>        compatible 属性值由 string list 组成，定义了设备的兼容性，compatible的值，建议取这样的形式："manufacturer,model"，即“厂家名,模块名”。</p> 
<pre><code class="language-cpp">compatible = "fsl,imx6ull-14x14-evk", "fsl,imx6ull";</code></pre> 
<p>示例</p> 
<pre><code class="language-cpp">led {
compatible = “A”, “B”, “C”;
};
</code></pre> 
<p>        对于某个LED，内核中可能有A、B、C三个驱动都支持它，内核启动时，就会为这个LED按这样的优先顺序为它找到驱动程序：A、B、C。</p> 
<p>        一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值核 OF 匹配表中的任何一个值相等，那么就表示这个设备可以使用这个驱动。比如在文件<code>imx-wm8960.c</code>文件中：</p> 
<pre><code class="language-cpp">static const struct of_device_id imx_wm8960_dt_ids[] = {
 { .compatible = "fsl,imx-audio-wm8960", },
 { /* sentinel */ }
};</code></pre> 
<p>这个数组就是<code>imx-wm8960.c</code>这个驱动文件的匹配表。</p> 
<ul><li>model</li></ul> 
<p>        model 属性值是一个 string，model属性与compatible属性有些类似，但是有差别。compatible属性是一个字符串列表，表示可以你的硬件兼容A、B、C等驱动；model用来准确地定义这个硬件是什么。</p> 
<p>        比如根节点中可以这样写：</p> 
<pre><code class="language-cpp">/ {
	compatible = "samsung,smdk2440", "samsung,mini2440";
	model = "jz2440_v3";
};
</code></pre> 
<p>        它表示这个单板，可以兼容内核中的“smdk2440”，也兼容“mini2440”。从compatible属性中可以知道它兼容哪些板，但是它到底是什么板？用model属性来明确，model属性指明了设备的厂商和型号。</p> 
<ul><li>status</li></ul> 
<p>        status 属性值是一个 string，表示设备的运行状态，dtsi文件中定义了很多设备，但是在你的板子上某些设备是没有的。这时你可以给这个设备节点添加一个status属性，设置为 "disabled"</p> 
<pre><code class="language-cpp">&amp;uart1 {
      status = "disabled";
};
</code></pre> 
<p>status 属性可用值如下表:</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/34/a8/mIn1Dty3_o.png"></p> 
<ul><li> reg</li></ul> 
<p>        reg 属性值是一个 prop-encoded-array，用来描述设备地址空间资源信息，一般是某个外设的寄存器地址范围信息，包括起始地址和地址长度。</p> 
<pre><code class="language-cpp">reg = &lt;address1 length1 address2 length2 address3 length3……&gt;</code></pre> 
<p>        reg属性的值，是一系列的“address  size”，用多少个32位的数来表示address和size，由其父节点的#address-cells、#size-cells决定。</p> 
<p>示例:</p> 
<pre><code class="language-cpp">/dts-v1/;
/ {
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;; 
    memory {
        reg = &lt;0x80000000 0x20000000&gt;;
    };
};
</code></pre> 
<h4> 常用节点</h4> 
<ul><li>根节点</li></ul> 
<p style="margin-left:0;text-align:justify;">        dts文件中必须有一个根节点：</p> 
<pre><code class="language-cpp">/dts-v1/;
/ {
model = "SMDK24440";
compatible = "samsung,smdk2440";

#address-cells = &lt;1&gt;;
#size-cells = &lt;1&gt;; 
};
</code></pre> 
<p>        根节点中必须有这些属性：</p> 
<pre><code class="language-cpp">#address-cells /* 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)*/
#size-cells   /* 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)*/
compatible   /* 定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备
                即这个板子兼容哪些平台 
                uImage : smdk2410 smdk2440 mini2440     ==&gt; machine_desc  */
model       /* 咱这个板子是什么
              比如有2款板子配置基本一致, 它们的compatible是一样的
              那么就通过model来分辨这2款板子*/
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d5/82/iCt1w4Tb_o.png"></p> 
<ul><li>CPU节点</li></ul> 
<p>        一般不需要我们设置，在dtsi文件中都定义好了： </p> 
<pre><code class="language-cpp">cpus {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;

		cpu0: cpu@0 {
		    .......
        }
};
</code></pre> 
<ul><li>memory节点</li></ul> 
<p style="margin-left:0;text-align:justify;">        芯片厂家不可能事先确定你的板子使用多大的内存，所以memory节点需要板厂设置，比如：</p> 
<pre><code class="language-cpp">memory {
    reg = &lt;0x80000000 0x20000000&gt;;
};
</code></pre> 
<ul><li>chosen 节点</li></ul> 
<p>        chosen 节点是为了uboot 向 Linux 内核传递数据，重点是 bootargs 参数，一般.dts 文件中 chosen 节点通常为空或者内容很少。</p> 
<pre><code class="language-cpp">chosen {
    bootargs = "noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200";
};
</code></pre> 
<h4>向节点追加内容</h4> 
<ul><li>向根节点追加内容</li></ul> 
<pre><code class="language-cpp">/ {
 //要补充的内容
};</code></pre> 
<ul><li>向子节点追加内容</li></ul> 
<pre><code class="language-cpp">&amp;node-label {
 //追加内容
};</code></pre> 
<h3>设备树编译</h3> 
<ol><li>简单粗暴，编译内核 <pre><code class="language-cpp">make</code></pre> </li><li>编译全部设备树文件 <pre><code class="language-cpp">make dtbs</code></pre> </li><li>编译指定的设备树文件 <pre><code class="language-cpp">make &lt;xxx.dtb&gt;</code></pre> </li></ol> 
<p></p> 
<h3>内核对设备树的处理</h3> 
<p>        从设备树dts源文件开始，处理过程如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/63/80/NQXmeTCu_o.png"></p> 
<p style="text-align:center;"></p> 
<ol><li>dts在PC机上被编译为dtb文件；</li><li>u-boot把dtb文件传给内核解析，内核将每个设备树节点解析为struct device_node 结构体；</li><li>对于某些device_node结构体，会被转换为platform_device结构体。</li></ol> 
<ul><li><span style="color:#fe2c24;"><strong>note</strong></span><br><strong><span style="color:#fe2c24;"> 设备树的根节点被保存在全局变量of_root中，从of_root中可以访问到任意节点</span></strong><br>  </li><li>struct device_node 结构体</li></ul> 
<pre><code class="language-cpp">struct device_node {
	const char *name;       //来自设备树节点的name属性
	const char *type;       //来自设备树节点的device_type属性
	phandle phandle;
	char	*full_name;     //节点全名

	struct	property *properties; //含有设备树节点的compatible属性
	struct	property *deadprops;	/* removed properties */
	struct	device_node *parent;
	struct	device_node *child;
	struct	device_node *sibling;
	struct	device_node *next;	/* next device of same type */
	struct	device_node *allnext;	/* next in list of all nodes */
	struct	proc_dir_entry *pde;	/* this node's proc directory */
	struct	kref kref;
	unsigned long _flags;
	void	*data;
#if defined(CONFIG_SPARC)
	char	*path_component_name;
	unsigned int unique_id;
	struct of_irq_controller *irq_trans;
#endif
};</code></pre> 
<ul><li>struct property 结构体</li></ul> 
<pre><code class="language-cpp">struct property {
	char	*name;        //属性名字  compatible 就是属性名字
	int	length;           //属性长度	compatible = "test"  长度为5
	void	*value;       //属性值   t例如 test
	struct property *next; //下一个属性
	unsigned long _flags;
	unsigned int unique_id;
};</code></pre> 
<h4>哪些device_node可以被转换成platform_device结构体？</h4> 
<ul><li>根节点下含有compatile属性的<span style="color:#ff0000;">子节点</span><br>  </li><li>根节点下含有特定compatile属性的<span style="color:#fe2c24;">节点的子节点</span><br><br> 如果一个节点的compatile属性，它的值是这4者之一："simple--bus"、"simple-mfd"、"isa"、"arm,amba-bus"。那么它的<span style="color:#ff0000;">子结点</span>(需含compatile属性)也可以转换为platform_device。</li></ul> 
<ul><li>总线I2C、SPI节点可以转换成platform_device，但它们的子节点：<span style="color:#ff0000;">不转换</span>为platform_device。</li></ul> 
<p>示例：</p> 
<pre><code class="language-cpp">/ {
	  mytest {
		  compatile = "mytest", "simple-bus";
		  mytest@0 {
				compatile = "mytest_0";
		  };
	  };
	  
	  i2c {
		  compatile = "samsung,i2c";
		  at24c02 {
				compatile = "at24c02";                      
		  };
	  };

	  spi {
		  compatile = "samsung,spi";              
		  flash@0 {
				compatible = "winbond,w25q32dw";
				spi-max-frequency = &lt;25000000&gt;;
				reg = &lt;0&gt;;
			  };
	  };
  };      
</code></pre> 
<p style="margin-left:0;text-align:justify;">    /mytest会被转换为platform_device；因为它兼容"simple-bus"，所以它的子节点 /mytest/mytest@0 也会被转换为platform_device。</p> 
<p style="margin-left:0;text-align:justify;">     /i2c节点一般表示 i2c 控制器, 它会被转换为 platform_device, 在内核中有对应的platform_driver；它的子节点 /i2c/at24c02 节点不会被转换为 platform_device，它被如何处理完全由父节点的platform_driver决定，一般是被创建为一个i2c_client。</p> 
<p style="margin-left:0;text-align:justify;">        类似的也有 /spi 节点，它一般也是用来表示SPI控制器，它会被转换为 platform_device，在内核中有对应的 platform_driver；它的子节点 /spi/flash@0 节点不会被转换为 platform_device，它被如何处理完全由父节点的platform_driver决定，一般是被创建为一个spi_device。</p> 
<h4 style="margin-left:0px;text-align:justify;">note:</h4> 
<ul><li>platform_device中含有resource数组, 它来自device_node的reg, interrupts属性;</li><li> <p style="margin-left:0;text-align:justify;"><span style="color:#0d0016;">struct platform_device里面有struct device，struct device里面有struct device_node ；platform_device.dev.of_node指向device_node, 可以通过它获得设备树其他属性。</span></p> </li></ul> 
<h4 style="margin-left:0px;text-align:justify;">由设备树节点转换得到的platform_device如何与platform_driver配对？</h4> 
<p>        从设备树转换得来的platform_device会被注册进内核里，以后当我们每注册一个platform_driver时，它们就会两两确定能否配对，如果能配对成功就调用platform_driver的probe函数，注册和匹配的具体流程可看一下我之前发的platform总线设备模型文章<a href="https://blog.csdn.net/weixin_51703421/article/details/126192654" title="(51条消息) platform总线设备模型_cola冲冲冲的博客-CSDN博客_platform总线模型">(51条消息) platform总线设备模型_cola冲冲冲的博客-CSDN博客_platform总线模型</a><br> 但是那篇文章里没有引进设备树的匹配流程，我在这里完善一下。</p> 
<p>每当有新的platform_device 或 platform_driver 注册时，最终都会调用最终会调用drivers\base\platform.c下的platform_match函数</p> 
<pre><code class="language-cpp">static int platform_match(struct device *dev, struct device_driver *drv)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct platform_driver *pdrv = to_platform_driver(drv);
 
	匹配第一优先级、/* When driver_override is set, only bind to the matching driver */
	if (pdev-&gt;driver_override)
		return !strcmp(pdev-&gt;driver_override, drv-&gt;name);
    
    匹配第二优先级、/*用于设备树节点匹配*/
	/* Attempt an OF style match first */
	if (of_driver_match_device(dev, drv))
		return 1;
 
	/* Then try ACPI style match */
	if (acpi_driver_match_device(dev, drv))
		return 1;
 
	匹配第三优先级、/* Then try to match against the id table */
	if (pdrv-&gt;id_table)
		return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;
 
	匹配第四优先级、/* fall-back to driver name match */
	return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);
}
</code></pre> 
<h4><strong>匹配规则</strong></h4> 
<p>     <strong>1.</strong> <strong>最先比较：platform_device. driver_override和platform_driver.driver.name</strong><br>          可以设置platform_device的driver_override，强制选择某个platform_driver。</p> 
<p>    <strong> 2.</strong> <strong>然后比较：设备树信息</strong><br>          比较platform_device. dev.of_node和platform_driver.driver.of_match_table</p> 
<p>        platform_device. dev.of_node对应的数据结构为：</p> 
<pre><code class="language-cpp">struct device_node {
	const char *name;       //来自设备树节点的name属性
	const char *type;       //来自设备树节点的device_type属性
	phandle phandle;
	char	*full_name;     //节点全名

	struct	property *properties; //含有设备树节点的compatible属性
    ......
};

struct property {
	char	*name;        //属性名字  compatible 就是属性名字
	int	length;           //属性长度	compatible = "test"  长度为5
	void	*value;       //属性值   t例如 test
	struct property *next; //下一个属性
	unsigned long _flags;
	unsigned int unique_id;
};</code></pre> 
<p>        platform_driver.driver.of_match_table 依次对应的数据结构为：</p> 
<pre><code class="language-cpp">struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t state);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
};

struct device_driver {
	const char		*name;
	struct bus_type		*bus;
    ......
	const struct of_device_id	*of_match_table;
    ......
};

struct of_device_id
{
	char	name[32];
	char	type[32];
	char	compatible[128];
#ifdef __KERNEL__
	void	*data;
#else
	kernel_ulong_t data;
#endif
};</code></pre> 
<p>使用设备树信息来判断dev和drv是否配对时：</p> 
<ol><li> <span style="color:#0d0016;">首先</span>，如果of_match_table中含有compatible值，就跟dev的compatile属性比较，若一致则成功，否则返回失败 ；</li><li><span style="color:#0d0016;">其次</span>，如果of_match_table中含有type值，就跟dev的device_type属性比较，若一致则成功，否则返回失败  ；</li><li><span style="color:#0d0016;">最后</span>，如果of_match_table中含有name值，就跟dev的name属性比较，若一致则成功，否则返回失败。</li></ol> 
<p>        现在都不再建议使用devcie_type和name属性，所以基本上只使用设备节点的compatible属性来寻找匹配的platform_driver。</p> 
<p><strong>     3. 接下来比较：platform_device. name和platform_driver.id_table[i].name</strong><br>         Platform_driver.id_table是“platform_device_id”指针，表示该drv支持若干个device，它里面列出了各个device的{.name, .driver_data}，其中的“name”表示该drv支持的设备的名字，driver_data是些提供给该device的私有数据。</p> 
<p>     <strong>4. 最后比较：platform_device.name和platform_driver.driver.name<br>         </strong>platform_driver.id_table可能为空，这时可以根据platform_driver.driver.name来寻找同名的platform_device。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/56/f3/n2fMY6Vf_o.png"></p> 
<h4></h4> 
<h4 style="margin-left:0;text-align:justify;">内核里操作设备树的常用函数</h4> 
<p>        内核源码中include/linux/目录下有很多of开头的头文件，of表示“open firmware”即开放固件。</p> 
<ul><li>处理device_node</li></ul> 
<pre><code class="language-cpp">of.h               // 提供设备树的一般处理函数, 
// 比如 of_property_read_u32(读取某个属性的u32值),
// of_get_child_count(获取某个device_node的子节点数)
of_address.h       // 地址相关的函数, 
// 比如 of_get_address(获得reg属性中的addr, size值)
// of_match_device (从matches数组中取出与当前设备最匹配的一项)
of_dma.h           // 设备树中DMA相关属性的函数
of_gpio.h          // GPIO相关的函数
of_graph.h         // GPU相关驱动中用到的函数, 从设备树中获得GPU信息
of_iommu.h         // 很少用到
of_irq.h           // 中断相关的函数
of_mdio.h          // MDIO (Ethernet PHY) API
of_net.h           // OF helpers for network devices. 
of_pci.h           // PCI相关函数
of_pdt.h           // 很少用到
of_reserved_mem.h  // reserved_mem的相关函数</code></pre> 
<ul><li>处理 platform_device</li></ul> 
<pre><code class="language-cpp">of_platform.h      // 把device_node转换为platform_device时用到的函数, 
                   // 比如of_device_alloc(根据device_node分配设置platform_device), 
                   // of_find_device_by_node (根据device_node查找到platform_device),
                   //   of_platform_bus_probe (处理device_node及它的子节点)
of_device.h        // 设备相关的函数, 比如 of_match_device
</code></pre> 
<p>platform_device相关的函数：</p> 
<p>        <strong>of_find_device_by_node函数</strong><br>         函数原型：</p> 
<pre><code class="language-cpp">extern struct platform_device *of_find_device_by_node(struct device_node *np);</code></pre> 
<p> <span style="color:#000000;">       </span>设备树中的每一个节点，在内核里都有一个device_node；你可以使用device_node去找到对应的platform_device。</p> 
<p>        <strong>platform_get_resource函数</strong><br>         函数原型：</p> 
<pre><code class="language-cpp">/**
 * platform_get_resource - get a resource for a device
 * @dev: platform device
 * @type: resource type   // 取哪类资源？IORESOURCE_MEM、IORESOURCE_REG
*                      // IORESOURCE_IRQ等
 * @num: resource index  // 这类资源中的哪一个？
 */
struct resource *platform_get_resource(struct platform_device *dev,
				       unsigned int type, unsigned int num);
</code></pre> 
<p>        设备树中的节点被转换为platform_device后，设备树节点中的reg属性，对应IORESOURCE_MEM类型的资源；interrupts属性，对应IORESOURCE_IRQ类型的资源。</p> 
<h4>有些节点不会生成platform_device，怎么访问它们?</h4> 
<p style="margin-left:0;text-align:justify;">        内核会把dtb文件解析出一系列的device_node结构体，我们可以直接访问这些device_node。内核源码incldue/linux/of.h中声明了device_node和属性property的操作函数。</p> 
<p style="margin-left:0;text-align:justify;"><strong>找到节点：</strong></p> 
<ul><li style="margin-left:0px;text-align:justify;"><strong>        of_find_node_by_path函数<br>         </strong>作用：根据路径找到节点，比如“/”就对应根节点，“/memory”对应memory节点。<br><strong>        </strong>函数原型： <pre><code class="language-cpp">static inline struct device_node *of_find_node_by_path(const char *path);</code></pre> <p>       <span style="color:#0d0016;"><strong>of_find_node_by_name函数</strong><br>         作用<strong>：</strong></span>根据名字找到节点，节点如果定义了name属性，那我们可以根据名字找到它<br>         函数原型：</p> <pre><code class="language-cpp">extern struct device_node *of_find_node_by_name(struct device_node *from,
	const char *name);
参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。
但是在设备树的官方规范中不建议使用“name”属性，所以这函数也不建议使用。
</code></pre> <p><span style="color:#0d0016;">        <strong>of_find_node_by_type函数<br>        </strong> 作用：</span>根据类型找到节点，节点如果定义了device_type属性，那我们可以根据类型找到它<br>         函数原型：</p> <pre><code class="language-cpp">extern struct device_node *of_find_node_by_type(struct device_node *from,
	const char *type);
参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。
但是在设备树的官方规范中不建议使用“device_type”属性，所以这函数也不建议使用
</code></pre> <p><span style="color:#0d0016;">        </span><strong>of_find_compatible_node函数<br>       </strong>作用：根据compatible找到节点，节点如果定义了compatible属性，那我们可以根据compatible属性找到它。<br>         函数原型：</p> <pre><code class="language-cpp">extern struct device_node *of_find_compatible_node(struct device_node *from,
	const char *type, const char *compat);

参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。
参数compat是一个字符串，用来指定compatible属性的值；
参数type是一个字符串，用来指定device_type属性的值，可以传入NULL。
</code></pre> <p><span style="color:#0d0016;">        </span><strong>of_find_node_by_phandle函数<br>         </strong>作用：根据phandle找到节点。dts文件被编译为dtb文件时，每一个节点都有一个数字ID，这些数字ID彼此不同。可以使用数字ID来找到device_node。这些数字ID就是phandle<br>         函数原型：</p> <pre><code class="language-cpp">extern struct device_node *of_find_node_by_phandle(phandle handle);

参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。
</code></pre> <p></p> </li></ul> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58a9e946b0be828adef68988050a445b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Pyside2&amp;PyQt5设置背景图片不影响其它控件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4522c227c3b45f674865e675aad3d1a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java的.replace()优化（重写）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>