<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python对象与类型之函数 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python对象与类型之函数" />
<meta property="og:description" content="开始语：
在python软件中，为了便于维护以及更好地实现模块化，好的程序都被分解成多个函数。
各个函数都有它的功能，我们可以通过自己定义的一系列函数来实现自己想要的功能。
（1）定义 使用def语句定义函数。
格式：
def 函数名(参数列表): &#34;函数_文档字符串&#34; # 函数说明，定义完成后，可通过.__doc__来获取 函数体 return 表达式 # 结束函数，不带表达式的return相当于返回None 函数体就是在调用函数时执行的一系列语句。
例子：
def add_abs(x,y = 0): if x&gt;=0: return x&#43;y else: return y-x 注：
如果定义的函数中带有默认参数（有默认值的参数，如y = 0），该参数及其后面所有参数都是可选的。如果忘记给函数定义中的所有可选参数（*args，**kwargs）赋值，就会引发语法错误。定义了函数之后，默认的参数值会传递给：以值的方式提供的对象。
如: a = 10 def foo(x = a): return x a = 5 print(foo()) # 10 以下情况若使用可变对象作为默认值，默认参数将保留前面调用进行的修改。
def foo(x,items=[]): items.append(x) return items print(foo(1)) # [1] print(foo(2)) # [1, 2] print(foo(3)) # [1, 2, 3] 为防止出现这种状况，可设置None值，并附上相应的检查代码：
def foo(x,items=None): if items is None: items = [] items." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c39f7b26b6d018750d0893d61245a45f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-11T12:31:31+08:00" />
<meta property="article:modified_time" content="2020-05-11T12:31:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python对象与类型之函数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>开始语：</strong><br> 在python软件中，为了便于维护以及更好地实现模块化，好的程序都被分解成多个函数。<br> 各个函数都有它的功能，我们可以通过自己定义的一系列函数来实现自己想要的功能。</p> 
<h5><a id="1_3"></a>（1）定义</h5> 
<p>使用<code>def</code>语句定义函数。<br> 格式：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> 函数名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">"函数_文档字符串"</span> <span class="token comment"># 函数说明，定义完成后，可通过.__doc__来获取</span>
     函数体
     <span class="token keyword">return</span> 表达式 <span class="token comment"># 结束函数，不带表达式的return相当于返回None</span>
</code></pre> 
<p>函数体就是在调用函数时执行的一系列语句。<br> 例子：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">add_abs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> x<span class="token operator">+</span>y
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> y<span class="token operator">-</span>x
</code></pre> 
<p><strong>注：</strong></p> 
<ul><li>如果定义的函数中带有默认参数（有默认值的参数，如<code>y = 0</code>），该参数及其后面所有参数都是可选的。</li><li>如果忘记给函数定义中的所有可选参数<code>（*args，**kwargs）</code>赋值，就会引发语法错误。</li><li>定义了函数之后，默认的参数值会传递给：以值的方式提供的对象。<br> 如:</li></ul> 
<pre><code class="prism language-python">a <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x
a <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 10</span>
</code></pre> 
<p>以下情况若使用可变对象作为默认值，默认参数将保留前面调用进行的修改。</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>items<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    items<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">return</span> items
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># [1]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># [1, 2]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># [1, 2, 3]</span>
</code></pre> 
<p>为防止出现这种状况，可设置<code>None</code>值，并附上相应的检查代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>items<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> items <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    items<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">return</span> items
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># [1]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># [2]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># [3]</span>
</code></pre> 
<h5><a id="2_58"></a>（2）调用</h5> 
<ul><li>定义了一个函数之后，需要调用函数，即在函数名称后面加上参数元组，如<code>foo(1)</code></li><li><strong>调用函数时，参数的数量及顺序必须与函数定义中相匹配</strong>，不然会引发<code>TypeError</code>。</li><li>位置参数必须位于默认参数等其他参数之前；</li><li>位置参数顺序必须与函数定义中相匹配；</li><li>默认参数的顺序可以不与函数定义中相一致，若不指明参数名称，就必须与位置参数那样与定义中相匹配；</li><li><strong>使用关键字参数时，参数顺序不影响。</strong><br> 注：<br> <strong>关键词参数：</strong> 即在调用函数时，提供函数参数，可以用显示的为每个参数指定一个值，如<code>foo(x =1,y = 0)</code>这种形式。</li></ul> 
<h5><a id="3_69"></a>（3）参数</h5> 
<p>如果函数定义了多个参数，那么在调用函数的时候，传递的数据要和定义的参数一一对应。（同上）<br> 参数分为可变参数、默认参数以及不定长参数。</p> 
<h6><a id="_72"></a>可变参数（位置参数）</h6> 
<p>即上面出现在默认参数之前的不带默认值的参数，如<code>foo(x,y=0)</code>中的参数<code>x</code>。</p> 
<h6><a id="_74"></a>默认参数</h6> 
<p>定义函数时，可以给参数设置默认值，这个参数就被称为默认参数；<br> 如果默认参数没有传入值，则直接使用默认值，反之，则使用传入的新值；<br> 默认参数可被忽略，其他参数必须要传入值；</p> 
<h6><a id="_78"></a>不定长参数（任意数量）</h6> 
<p>若希望能够处理的参数个数比当初定义的参数个数多，此时可以在函数中使用不定长参数；<br> 格式如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> 函数名<span class="token punctuation">(</span><span class="token punctuation">[</span>formal_args<span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    函数体
    <span class="token keyword">return</span> 表达式
</code></pre> 
<p>调用函数时，参数个数会优先匹配formal_args参数的个数，若个数相同，不定长参数返回空的元组或字典；若个数比formal_args多，分两种情况：</p> 
<ul><li>如果多余的传入的参数没有指定名称（如 2），<em>args会以元组的形式存放这些多余的参数，即</em>args是位置参数元组；</li><li>如果多余的传入的参数指定了名称（如a = 2），<strong>kwargs会以字典的形式存放这些多余的参数，即</strong>kwargs是关键字参数字典。</li></ul> 
<p><strong>如果编写的函数接受大量可扩充的配置选项作为参数，但列出这些参数又显得过款时，使用双星号开头的参数就很有用</strong>。</p> 
<h5><a id="4_92"></a>（4）变量作用域</h5> 
<p><strong>每次调用函数，函数内部都会创建一个局部命名空间，该局部环境包含函数参数名称以及在函数内定义赋值的变量名称。</strong><br> 在使用变量时，需要对函数中变量进行解析，<strong>解释器的解析原则是Local &lt;- Enclosed &lt;- Global &lt;- Built-in。此为变量使用先后顺序。</strong><br> 下面对此进行解释：<br> 首先搜索局部命名空间，即函数内部（参数及变量），若没有找到相应名称，接着找嵌套的闭包函数（<strong>闭包：将组成函数的语句和这些语句的执行环境打包在一起</strong>）中是否能查找到相应的名称，若还没找到，就尝试在定义该函数的模块中查找，即全局命名空间，如果也没匹配到，则在python内置命名空间中进行查找。若仍然未查找到，就引发<code>NameError</code>异常。<br> 下面见一个例子，用于理解声明变量作用域的关键字（先自己思考一下结果）：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">scope_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">do_local</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        spam <span class="token operator">=</span> <span class="token string">'local spam'</span>
    <span class="token keyword">def</span> <span class="token function">do_nonlocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">nonlocal</span> spam
        spam <span class="token operator">=</span> <span class="token string">'nonlocal spam'</span>
    <span class="token keyword">def</span> <span class="token function">do_global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">global</span> spam
        spam <span class="token operator">=</span> <span class="token string">'global spam'</span>
    spam <span class="token operator">=</span> <span class="token string">'text spam'</span>
    do_local<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'after local assignment:'</span><span class="token punctuation">,</span>spam<span class="token punctuation">)</span>
    do_nonlocal<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'after nonlocal assignment:'</span><span class="token punctuation">,</span>spam<span class="token punctuation">)</span>
    do_global<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'after global assignment:'</span><span class="token punctuation">,</span>spam<span class="token punctuation">)</span>
scope_test<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'In global scope:'</span><span class="token punctuation">,</span>spam<span class="token punctuation">)</span>
</code></pre> 
<p>结果为：</p> 
<pre><code class="prism language-python">afterlocal assignment<span class="token punctuation">:</span> text spam
after <span class="token keyword">nonlocal</span> assignment<span class="token punctuation">:</span> <span class="token keyword">nonlocal</span> spam
after <span class="token keyword">global</span> assignment<span class="token punctuation">:</span> <span class="token keyword">nonlocal</span> spam
In <span class="token keyword">global</span> scope<span class="token punctuation">:</span> <span class="token keyword">global</span> spam
</code></pre> 
<p><strong>解释：</strong><br> 第一个结果很好理解，<code>do_local()</code>函数里没有return函数，因此spam变量用的是嵌套的闭包函数中的变量<code>spam = 'text spam'</code>（即Local中没有，即用Enclosed中的）；<br> 第二个结果，<code>do_nonlocal()</code>函数里有<code>nonlocal</code>关键字声明，即说明函数里面的<code>spam = 'nonlocal spam'</code>是对闭包中的<code>spam = 'text spam'</code>进行重新赋值，因而其值为nonlocal spam（print输出的总是处于同层次变量的值）；<br> 第三个结果，<code>do_global()</code>函数里有<code>global</code>关键字声明，由于全局命名空间中并没有spam变量，因此<code>spam = 'global spam'</code>在全局命名空间中建立spam变量并对其进行赋值，不对闭包中spam变量产生影响，因此print函数输出变量spam的值仍然为nonlocal spam；<br> 第四个结果，print函数位于全局命名空间中，因此输出的spam为全局变量，其值为global spam。</p> 
<h5><a id="5_131"></a>（5）装饰器</h5> 
<p><strong>装饰器是一个函数，其主要用途是包装另一个函数或类。</strong><br> 首要目的是透明地修改或增强被包装对象的行为，也可以理解为<strong>增加被包装对象的功能</strong>。<br> <strong>举例：</strong><br> 假如有多个函数，都希望可以输出函数的执行日志这么一个需求，为减少代码重复，我们可以创建一个新的函数专门记录函数执行日志，谁需要记录执行日志，就将谁作为参数传递；并且对已经实现的函数，要遵守“封闭开放”的原则，不允许在函数内部进行修改，装饰器可以满足上述需求。<br> <strong>表示装饰器的语法是特殊符号@。</strong><br> 使用介绍：</p> 
<pre><code class="prism language-python">@trace <span class="token comment"># 假设这个trace函数为一个记录执行日志的函数</span>
<span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 函数square需要执行日志，因此在其上方加上一个装饰器</span>
    <span class="token keyword">return</span> x<span class="token operator">**</span><span class="token number">2</span>
</code></pre> 
<p>上述代码相当于：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x<span class="token operator">**</span><span class="token number">2</span>
square <span class="token operator">=</span> trace<span class="token punctuation">(</span>square<span class="token punctuation">)</span> <span class="token comment"># 函数对象本身传递给函数trace作为参数，并返回一个对象代替原来的square</span>
</code></pre> 
<p>实例：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">wrap</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'正在装饰'</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span>  <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'正在验证权限'</span><span class="token punctuation">)</span>
        func<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> inner
@wrap
<span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>
test<span class="token punctuation">(</span><span class="token punctuation">)</span> 
</code></pre> 
<p>执行过程：<br> （1）执行test()时，发现函数test()上面有装饰器@wrap，所以先执行@wrap;<br> 此时，<strong><code>@wrap</code>相当于<code>wrap(test)</code></strong>；<br> （2）执行wrap(test)，首先执行<code>print</code>语句，输出“正在装饰”，接着执行定义函数<code>inner</code>，最后将<code>inner()</code>函数的引用作为返回值返回给<code>wrap(test)</code>，然后根据 <code>test = wrap(test)</code>， wrap(test)将其返回值赋给<code>test</code>，因而此时，<strong>test指向inner函数</strong>；<br> （3）调用<code>test()</code>，<strong>因为test指向inner函数的引用，test()函数相当于调用<code>inner()</code>函数</strong>，输出“正在验证权限”，并输出“test”。<br> <strong>因此，既保证运行了装饰器函数，又不影响输出函数test()，很明显增强了test()函数的功能</strong></p> 
<p><strong>当然，也可以有多个解释器：</strong></p> 
<pre><code class="prism language-python">@a
@b
@c
<span class="token keyword">def</span> <span class="token function">d</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'I'</span>m the d<span class="token punctuation">.</span>'<span class="token punctuation">)</span>
</code></pre> 
<p>相当于：</p> 
<pre><code class="prism language-python">d <span class="token operator">=</span> a<span class="token punctuation">(</span>b<span class="token punctuation">(</span>c<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>装饰器也可以带有参数：</strong><br> 如果我们给装饰器添加参数，需要增加一层封装，先传递参数，然后再传递函数名。</p> 
<pre><code class="prism language-python">@trace<span class="token punctuation">(</span><span class="token string">'length'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x<span class="token operator">**</span><span class="token number">2</span>
</code></pre> 
<p>相当于：</p> 
<pre><code class="prism language-python">temp <span class="token operator">=</span> trace<span class="token punctuation">(</span><span class="token string">'length'</span><span class="token punctuation">)</span> <span class="token comment"># 使用提供的参数调用装饰器</span>
square <span class="token operator">=</span> temp<span class="token punctuation">(</span>square<span class="token punctuation">)</span> <span class="token comment"># 调用装饰器返回的函数</span>
</code></pre> 
<h5><a id="6yield_202"></a>（6）生成器与yield</h5> 
<p>函数使用关键字<code>yield</code>定义生成器对象。<br> <strong>生成器是一个函数，它生成一个值的序列，可用于迭代。</strong><br> 见例子：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">self_range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''
    This is a self-definition range function.
    '''</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'decresing %d step by step'</span><span class="token operator">%</span>n<span class="token punctuation">)</span>
    <span class="token keyword">while</span> n<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
        <span class="token keyword">yield</span> n
        <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
        n <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
sr <span class="token operator">=</span> self_range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre> 
<p>我们发现直接调用该函数，其中的代码是没有运行的，因为它返回的是一个生成器对象。<br> <strong>原因：</strong></p> 
<blockquote> 
 <p><strong>生成器对象只在调用__next__()时，生成器函数才会不断执行语句，直到遇到yield语句为止。</strong><br> <strong>然后yield语句会在函数执行停止的地方生成一个结果，直到再次调用__next__()函数，才会继续执行yield之后的语句，直到遇到下一个yield语句停止。</strong></p> 
</blockquote> 
<p><strong>这些话很重要，注意理解。</strong></p> 
<pre><code class="prism language-python">sr<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#decresing 10 step by step</span>
<span class="token comment">#10 （由yield之前的print(n)输出）</span>
<span class="token comment">#out[]:10（注意这个是__next__()的输出结果，即yield生成的结果）</span>
sr<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#10 （由第一次yield语句之后的print(n)输出，此时n还是10）</span>
<span class="token comment">#9</span>
<span class="token comment">#9 （由第二次yield语句之前的print(n)输出）</span>
<span class="token comment">#out[]:9（这个为此__next__()的输出结果，即yield生成的结果）</span>
</code></pre> 
<p><strong>通常不会再生成器上直接调用<code>__next__()</code>方法，而是在for语句以及一些序列操作中使用它.</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> self_range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="7yield_245"></a>（7）协程与yield表达式</h5> 
<p><strong>在函数内，yield可用作出现在赋值运算符右边的表达式</strong>，例如：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">receiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Ready to receive"</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">yield</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Got %s"</span><span class="token operator">%</span> n<span class="token punctuation">)</span>
</code></pre> 
<p>以这种方式使用yield语句的函数称为协程。**它的执行是为了响应发送给它的值。**它的行为也十分类似于生成器。</p> 
<pre><code class="prism language-python">r <span class="token operator">=</span> receiver<span class="token punctuation">(</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 对__next__()的初始调用是必不可少的，这样协程才能执行可通向第一个yield表达式的语句。</span>
<span class="token comment"># 这时候，协程会挂起，等待相关生成器对象r的send()方法给它发送一个值。</span>
<span class="token comment"># 传递给send()的值由协程中的(yield)表达式返回。</span>
<span class="token comment"># 接收到值后，协程就会执行语句，直至遇到下一条yield语句。</span>
r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># Got 1</span>
r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># Got 2</span>
r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'Hello,world'</span><span class="token punctuation">)</span> <span class="token comment"># Got Hello,World</span>
</code></pre> 
<p><strong>由于协程中需要首先使用<code>__next__()</code>这件事情很容易被忽略，经常成为错误出现的根源。因此，建议使用一个能自动完成该步骤的装饰器来包装协程。</strong><br> 见下方：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">co_routine</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        g <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        g<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> g
    <span class="token keyword">return</span> start
@co_routine
<span class="token keyword">def</span> <span class="token function">receiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Ready to receive"</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">yield</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Got %s"</span><span class="token operator">%</span> n<span class="token punctuation">)</span>
r <span class="token operator">=</span> receiver<span class="token punctuation">(</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Hello,World!"</span><span class="token punctuation">)</span>
</code></pre> 
<p>结合上面的装饰器概念，我们再来大致理解一下执行程序工作顺序：<br> receiver()前加@co_routine，相当于<code>receiver = co_routine(receiver)</code>；结合co_routine函数内容，相当于将receiver指向start函数；<br> <code>r = receiver()</code> 相当于先执行<code>start()</code>函数，其里面将<code>g = receiver()</code>，并且使用了<code>__next__()</code>函数，然后并重新赋值给r；<br> 最后给协程对象r送值，并返回。</p> 
<p><strong>协程的运行一般是无限期的，除非它被显示关闭或者自己退出。</strong><br> 使用<code>close()</code>方法可以关闭输入值的流。<br> 关闭后，若继续给协程发送值，就会引发StopIteration异常，同生成器那样，close()方法将引发GeneratorExit异常。</p> 
<p><strong>可以用throw(exceptiontype[,value[,tb]])方法在协程内部引发异常，tb指跟踪对象。</strong></p> 
<p><strong>如果yield表达式中提供了值，协程可以使用yield语句同时接收和发出返回值。</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">line_splitter</span><span class="token punctuation">(</span>delimiter<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Ready to split..."</span><span class="token punctuation">)</span>
    result <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        line <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> result<span class="token punctuation">)</span> <span class="token comment">#说明生成的是result的值</span>
        result <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span>delimiter<span class="token punctuation">)</span>
s <span class="token operator">=</span> line_splitter<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>
s<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># Ready to split...</span>
s<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"A,B,C"</span><span class="token punctuation">)</span> <span class="token comment"># ['A','B','C']</span>
</code></pre> 
<p>这上面有个很细节的点，就是在<code>yield</code>表达式前面加上了<code>result = None</code>，原因就是为了避免我们在运行<code>s.__next__()</code>时产生输出结果，因为此时<code>result = None</code>。<br> 注：<br> send()方法的返回值，就是传递给下一条yield语句的值。也就是说，send()方法的返回值来自下一个yield表达式，而不是接收send()传递的值的yield表达式</p> 
<h5><a id="8_311"></a>（8）列表推导式</h5> 
<p>函数的常用操作是将函数应用给一个列表的所有项，并使用结果创建一个新列表。<br> 由于这种操作很常见，因此出现了叫做列表推导的运算符。<br> 一般语法如下：</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>expression <span class="token keyword">for</span> item1 <span class="token keyword">in</span> iterable1 <span class="token keyword">if</span> condition1
            <span class="token keyword">for</span> item2 <span class="token keyword">in</span> iterable2 <span class="token keyword">if</span> condition2
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">for</span> itemN <span class="token keyword">in</span> iterableN <span class="token keyword">if</span> conditionN<span class="token punctuation">]</span>
</code></pre> 
<p>等价于：</p> 
<pre><code class="prism language-python">s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> item1 <span class="token keyword">in</span> iterable1<span class="token punctuation">:</span>
    <span class="token keyword">if</span> condition1<span class="token punctuation">:</span>
        <span class="token keyword">for</span> item2 <span class="token keyword">in</span> iterable2<span class="token punctuation">:</span>
            <span class="token keyword">if</span> condition2<span class="token punctuation">:</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token keyword">for</span> itemN <span class="token keyword">in</span> iterableN<span class="token punctuation">:</span>
                    <span class="token keyword">if</span> conditonN<span class="token punctuation">:</span>s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>expression<span class="token punctuation">)</span>
</code></pre> 
<p>举例：</p> 
<pre><code class="prism language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
b <span class="token operator">=</span> <span class="token string">'love'</span>
s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> a <span class="token keyword">for</span> j <span class="token keyword">in</span> b <span class="token keyword">if</span> i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="9_345"></a>（9）生成器表达式</h5> 
<p>生成器表达式是一个对象，语法和列表推导相同，只是用圆括号代替方括号。</p> 
<pre><code class="prism language-python"><span class="token punctuation">(</span>expression <span class="token keyword">for</span> item1 <span class="token keyword">in</span> iterable1 <span class="token keyword">if</span> condition1
            <span class="token keyword">for</span> item2 <span class="token keyword">in</span> iterable2 <span class="token keyword">if</span> condition2
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">for</span> itemN <span class="token keyword">in</span> iterableN <span class="token keyword">if</span> conditionN）
</code></pre> 
<p>列表推导与生成器表达式之间的差异很微妙，但是十分重要。其主要表现在性能和内存使用上。<br> 从上面我们可以知道，生成器只在我们调用它时才会执行，列表推导一旦创建，它就占用全部内存资源。<br> 另外，生成器表达式不会创建序列形式的对象，因此无法进行索引等列表操作。但是可用list()函数转换。</p> 
<h5><a id="10lambda_358"></a>（10）lambda表达式</h5> 
<p>使用lambda语句可以创建表达式形式的匿名函数：</p> 
<pre><code class="prism language-python"><span class="token keyword">lambda</span> args <span class="token punctuation">:</span> expression
</code></pre> 
<p>args是以逗号分隔的参数列表。<br> 而expression是用到这些参数的表达式。<br> 使用lambda定义的代码必须是合法的表达式。<br> <strong>lambda语句中不能出现多条语句和其他非表达式语句，如for和while。</strong><br> 遵循与函数相同的作用域规则。</p> 
<h5><a id="11_370"></a>（11）递归</h5> 
<p>递归函数定义示例：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token keyword">return</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p>注意：<br> Python对递归函数调用的深度做了限制。<br> 函数<code>sys.getrecursionlimit()</code>返回当前最大的递归深度；<br> <code>sys.setrecursionlimit()</code>可用于修改这个值。<br> 超出递归深度时，就会引发RuntimeError异常。<br> 打印一个嵌套列表中的所有项：</p> 
<pre><code class="prism language-python">s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">flatten</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> s lists<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            flatten<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
flatten<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
</code></pre> 
<p>还可以用生成器的递归方法：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">gen_flatten</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> s lists<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> item <span class="token keyword">in</span> gen_flatten<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">yield</span> item
        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token keyword">yield</span> item
</code></pre> 
<h5><a id="12_407"></a>（12）文档字符串</h5> 
<p>通常，函数的第一条语句会使用文档字符串，用于描述函数的用途。<br> 文档字符串保存在函数的__doc__属性中。<br> 如果需要使用装饰器，要知道使用装饰器包装函数可能会破坏<br> 与文档字符串相关的帮助功能。<br> 例：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">wrap</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    call<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> call
@wrap
<span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''
    This Function is computig n fatorial.
    '''</span>
<span class="token builtin">help</span><span class="token punctuation">(</span>factorial<span class="token punctuation">)</span>
</code></pre> 
<p><strong>这个问题的解决办法就是编写可以传递函数名称和文档字符串的装饰器函数。</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">wrap</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    call<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    call<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> func<span class="token punctuation">.</span>__doc__
    call<span class="token punctuation">.</span>__name__ <span class="token operator">=</span> func<span class="token punctuation">.</span>__name__
    <span class="token keyword">return</span> call
</code></pre> 
<p>因为这是一个常见问题，所以functools模块提供了函数wraps，用于自动复制这些属性。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps
<span class="token keyword">def</span> <span class="token function">wrap</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    @wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>
    call<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> call
</code></pre> 
<p><strong>@wraps(func)将属性从func传递给要定义的包装器函数。</strong></p> 
<h5><a id="13_450"></a>（13）函数属性</h5> 
<p>可以给函数添加任意属性，如：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span>
foo<span class="token punctuation">.</span>person <span class="token operator">=</span> <span class="token string">'程序员'</span>
foo<span class="token punctuation">.</span>emotion <span class="token operator">=</span> <span class="token string">'惊吓'</span>
</code></pre> 
<p>函数属性保存在__dict__属性中，为一个字典。</p> 
<pre><code class="prism language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span> <span class="token comment"># {'person': '程序员', 'emotion': '惊吓'}</span>
</code></pre> 
<h5><a id="14evalexeccompile_464"></a>（14）eval()、exec()和compile()函数</h5> 
<pre><code class="prism language-python"><span class="token builtin">eval</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token builtin">globals</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token builtin">locals</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">)</span>
    Evaluate the given source <span class="token keyword">in</span> the context（上下文） of <span class="token builtin">globals</span> <span class="token operator">and</span> <span class="token builtin">locals</span><span class="token punctuation">.</span>
    
    The source may be a string representing a Python expression（表达式字符串）
    <span class="token operator">or</span> a code <span class="token builtin">object</span> <span class="token keyword">as</span> returned by <span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>（编译函数返回的代码对象）
    The <span class="token builtin">globals</span> must（必须） be a dictionary（字典） <span class="token operator">and</span> <span class="token builtin">locals</span> can（可以） be <span class="token builtin">any</span>
    mapping（映射）<span class="token punctuation">,</span>
    defaulting to the current <span class="token builtin">globals</span> <span class="token operator">and</span> <span class="token builtin">locals</span><span class="token punctuation">.</span>
    If only <span class="token builtin">globals</span> <span class="token keyword">is</span> given<span class="token punctuation">,</span> <span class="token builtin">locals</span> defaults to it<span class="token punctuation">.</span>
    <span class="token builtin">globals</span> 和 <span class="token builtin">locals</span> 是可选的映射对象，分别用作代码执行的全局和局部命名空间。
</code></pre> 
<pre><code class="prism language-python"><span class="token keyword">exec</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token builtin">globals</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token builtin">locals</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">)</span>
    Execute（执行） the given source <span class="token keyword">in</span> the context of <span class="token builtin">globals</span> <span class="token operator">and</span> <span class="token builtin">locals</span><span class="token punctuation">.</span>
    
    The source may be a string representing one <span class="token operator">or</span> more Python statements（语句字符串）
    <span class="token operator">or</span> a code <span class="token builtin">object</span> <span class="token keyword">as</span> returned by <span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>（编译函数返回的代码对象）
    The <span class="token builtin">globals</span> must be a dictionary <span class="token operator">and</span> <span class="token builtin">locals</span> can be <span class="token builtin">any</span> mapping<span class="token punctuation">,</span>
    defaulting to the current <span class="token builtin">globals</span> <span class="token operator">and</span> <span class="token builtin">locals</span><span class="token punctuation">.</span>
    If only <span class="token builtin">globals</span> <span class="token keyword">is</span> given<span class="token punctuation">,</span> <span class="token builtin">locals</span> defaults to it<span class="token punctuation">.</span>
</code></pre> 
<p>见例子：</p> 
<pre><code class="prism language-python"><span class="token builtin">globals</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'x'</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'birds'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'Parrot'</span><span class="token punctuation">,</span><span class="token string">'Swallow'</span><span class="token punctuation">,</span><span class="token string">'Albatross'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
<span class="token builtin">locals</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
a <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">"3*x+4*y"</span><span class="token punctuation">,</span><span class="token builtin">globals</span><span class="token punctuation">,</span><span class="token builtin">locals</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment"># 61</span>
<span class="token keyword">exec</span><span class="token punctuation">(</span><span class="token string">"for b in birds:print(b)"</span><span class="token punctuation">,</span><span class="token builtin">globals</span><span class="token punctuation">,</span><span class="token builtin">locals</span><span class="token punctuation">)</span>
<span class="token comment"># Parrot</span>
<span class="token comment"># Swallow</span>
<span class="token comment"># Albatross</span>
</code></pre> 
<p>给exec()或eval()函数传递字符串时，解析器首先会把这个字符串编译为字节码。因为这个过程十分耗资源，如果代码要反复执行多次，最好是预编译代码，然后在后续的调用中重用字节码。</p> 
<pre><code class="prism language-python"><span class="token builtin">compile</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> dont_inherit<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> optimize<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    Compile source into a code <span class="token builtin">object</span> that can be executed by <span class="token keyword">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
    
    The source code may represent a Python module（模块）<span class="token punctuation">,</span> statement（语句） <span class="token operator">or</span> expression（表达式）<span class="token punctuation">.</span>
    The filename will be used <span class="token keyword">for</span> run<span class="token operator">-</span>time error messages（运行时错误消息）<span class="token punctuation">.</span>
    The mode must be <span class="token string">'exec'</span> to <span class="token builtin">compile</span> a module<span class="token punctuation">,</span> <span class="token string">'single'</span> to <span class="token builtin">compile</span> a
    single <span class="token punctuation">(</span>interactive<span class="token punctuation">)</span> statement<span class="token punctuation">,</span> <span class="token operator">or</span> <span class="token string">'eval'</span> to <span class="token builtin">compile</span> an expression<span class="token punctuation">.</span>
    The flags argument<span class="token punctuation">,</span> <span class="token keyword">if</span> present<span class="token punctuation">,</span> controls which future statements influence
    the compilation of the code<span class="token punctuation">.</span>（控制未来语句影响代码的编译）
    The dont_inherit argument<span class="token punctuation">,</span> <span class="token keyword">if</span> true<span class="token punctuation">,</span> stops the compilation inheriting
    the effects of <span class="token builtin">any</span> future statements <span class="token keyword">in</span> effect <span class="token keyword">in</span> the code calling
    <span class="token builtin">compile</span><span class="token punctuation">;</span> <span class="token keyword">if</span> absent <span class="token operator">or</span> false these statements do influence the compilation<span class="token punctuation">,</span>
    <span class="token keyword">in</span> addition to <span class="token builtin">any</span> features explicitly specified<span class="token punctuation">.</span>
</code></pre> 
<p>见例子：</p> 
<pre><code class="prism language-python">s <span class="token operator">=</span> <span class="token string">"for i in range(10):print(i)"</span>
c <span class="token operator">=</span> <span class="token builtin">compile</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">'exec'</span><span class="token punctuation">)</span> <span class="token comment"># 编译为代码对象</span>
<span class="token keyword">exec</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token comment"># 0</span>
<span class="token comment"># 1</span>
<span class="token comment"># 2</span>
<span class="token comment"># 3</span>
<span class="token comment"># 4</span>
<span class="token comment"># 5</span>
<span class="token comment"># 6</span>
<span class="token comment"># 7</span>
<span class="token comment"># 8</span>
<span class="token comment"># 9</span>
s2 <span class="token operator">=</span> <span class="token string">"3*x+4*y"</span>
c2 <span class="token operator">=</span> <span class="token builtin">compile</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">'eval'</span><span class="token punctuation">)</span> <span class="token comment"># 编译为表达式</span>
result <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>c2<span class="token punctuation">,</span><span class="token builtin">globals</span><span class="token punctuation">,</span><span class="token builtin">locals</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> 
<span class="token comment"># 61</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2574ef7273ce1875e409afb6b941e45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NLP——8.基于统计的翻译系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3076f78a5eb78536a657256fdd0f568/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IP基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>