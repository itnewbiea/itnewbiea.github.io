<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Halcon算子threshold、dyn_threshold、binary_threshold、auto_threshold、fast_threshold、var_threshold - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Halcon算子threshold、dyn_threshold、binary_threshold、auto_threshold、fast_threshold、var_threshold" />
<meta property="og:description" content="一、threshold 全局阈值 threshold(Image : Region : MinGray, MaxGray : ) 对应参数分别为输入图像、输出区域、阈值下限、阈值上限 使用全局阈值分割图像，阈值选择输入图像中灰度值g满足以下条件的像素： 图像中所有满足条件的点会被作为一个整体区域被返回，对于矢量图像，阈值不是对应于灰度值，而是对应于矢量的长度。 注意点：MaxGray &gt;= MinGray，MaxGray和MinGray的值可以是浮点类型也可以是整数类型，如果图像是整数类型的，MaxGray和MinGray的值类型应当为整数类型，如果是浮点类型，小数部分会被舍弃； 二、dyn_threshold 局部阈值 dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark : ) 对应参数分别为原始图像、阈值图像、输出区域、偏移量、输出类型 使用局部阈值分割图像,dyn_threshold从输入图像中选择满足条件的区域方法如下： 注意：g0是原始图片，gt是阈值图片，通常，阈值图像是原始图像的平滑版本，可以利用 mean_image, binomial_filter, gauss_filter等来创建阈值图片； 当LightDark = &#39;light&#39; 时 g0 &gt;= gt&#43;Offset; 当LightDark = &#39;dark&#39; 时 g0 &lt;= gt-Offset; 当LightDark = &#39;equal&#39; 时 gt-Offset &lt;= g0 &lt;= gt&#43;Offset; 当LightDark = &#39;not_equal&#39; 时 gt&#43;Offset &lt; g0 或者 g0 &lt; gt-Offset; 利用dyn_threshold可以提取目标图片的轮廓，如下图 代码如下： read_image (Image2, &#39;C:/Users/Administrator/Desktop/2注册图片." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fa2da01459379f440da5711846a4d942/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-04T12:10:57+08:00" />
<meta property="article:modified_time" content="2021-01-04T12:10:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Halcon算子threshold、dyn_threshold、binary_threshold、auto_threshold、fast_threshold、var_threshold</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、threshold 全局阈值</h2> 
<h3>threshold(Image : Region : MinGray, MaxGray : )  <span style="color:#3399ea;">对应参数分别为输入图像、输出区域、阈值下限、阈值上限</span></h3> 
<h4>使用全局阈值分割图像，阈值选择输入图像中灰度值g满足以下条件的像素：</h4> 
<p><img alt="" height="71" src="https://images2.imgbox.com/d5/7c/2FDwenRK_o.png" width="577"></p> 
<h4>图像中所有满足条件的点会被作为一个整体区域被返回，对于矢量图像，阈值不是对应于灰度值，而是对应于矢量的长度。</h4> 
<h4><span style="color:#f33b45;">注意点：MaxGray &gt;= MinGray，MaxGray和MinGray的值可以是浮点类型也可以是整数类型，如果图像是整数类型的，MaxGray和MinGray的值类型应当为整数类型，如果是浮点类型，小数部分会被舍弃；</span></h4> 
<p> </p> 
<h2>二、dyn_threshold 局部阈值</h2> 
<h3>dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark : ) <span style="color:#3399ea;">对应参数分别为原始图像、阈值图像、输出区域、偏移量、输出类型</span></h3> 
<h4>使用局部阈值分割图像,dyn_threshold从输入图像中选择满足条件的区域方法如下：</h4> 
<h4><span style="color:#f33b45;">注意：g0是原始图片，gt是阈值图片，通常，阈值图像是原始图像的平滑版本，可以利用 mean_image, binomial_filter, gauss_filter等来创建阈值图片；</span></h4> 
<h4>当LightDark = 'light' 时 g0 &gt;= gt+Offset;</h4> 
<h4>当LightDark = 'dark' 时 g0 &lt;= gt-Offset;</h4> 
<h4>当LightDark = 'equal' 时 gt-Offset &lt;= g0 &lt;= gt+Offset;</h4> 
<h4>当LightDark = 'not_equal' 时 gt+Offset &lt; g0 或者 g0 &lt; gt-Offset;</h4> 
<p> </p> 
<h3>利用dyn_threshold可以提取目标图片的轮廓，如下图</h3> 
<p><img alt="" height="633" src="https://images2.imgbox.com/e2/83/wNUDaT6f_o.png" width="572"></p> 
<h4>代码如下：</h4> 
<h4>read_image (Image2, 'C:/Users/Administrator/Desktop/2注册图片.bmp')<br> draw_rectangle1 (200000, Row1, Column1, Row2, Column2)<br> gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)<br> reduce_domain (Image2, Rectangle, ImageReduced)<br> mean_image (ImageReduced, ImageMean, 3, 3)<br> dyn_threshold (ImageReduced, ImageMean, RegionDynThresh, 10, 'light')</h4> 
<h4>MaskSize尺寸越大，发现的区域就越大,一般，MaskSize的大小应该是被提取对象直径的两倍，如下图：</h4> 
<p><img alt="" height="638" src="https://images2.imgbox.com/28/18/JhwVgQqb_o.png" width="723"></p> 
<h4>代码如下：</h4> 
<h4>read_image (Image2, 'C:/Users/Administrator/Desktop/2注册图片.bmp')<br> draw_rectangle1 (200000, Row1, Column1, Row2, Column2)<br> gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)<br> reduce_domain (Image2, Rectangle, ImageReduced)<br> mean_image (ImageReduced, ImageMean, 10,10)<br> dyn_threshold (ImageReduced, ImageMean, RegionDynThresh,5, 'light')</h4> 
<h4><span style="color:#f33b45;">注意：offset不应该设置成0，如果设置成0会有很多干扰会被一起提取出来，建议值应该是5到40，offset越大，被提取的区域就会越小，超过60可能就发现不了任何点了，整个函数的返回就是一个空区域；</span></h4> 
<p> </p> 
<h2>三、bin_threshold </h2> 
<h3>bin_threshold(Image : Region : : )<span style="color:#3399ea;">对应参数为输入图像和输出区域</span></h3> 
<h4>使用自动确定的阈值分割图像，bin_threshold已经过时，只是为了向后兼容而提供的，新的应用程序应该使用binary_threshold来替代；</h4> 
<h4>bin_threshold使用自动确定的阈值分割单通道的灰度图像，首先，输入图像的相对直方图是确定的，然后，从直方图中提取相关的最小值，作为阈值操作的参数，为了减少最小值的数量，对直方图进行高斯平滑处理，掩模的大小被放大，直到平滑直方图中只有一个最小值</h4> 
<p> </p> 
<p> </p> 
<h2>四、binary_threshold 二值阈值</h2> 
<h3>binary_threshold(Image : Region : Method, LightDark : UsedThreshold)<span style="color:#3399ea;">对应参数分别为输入图像、输出区域、使用方法、选择前景还是背景、输出使用的阈值</span></h3> 
<h4>使用二值阈值分割图像，binary_threshold使用自动确定的全局阈值分割<span style="color:#f33b45;">单通道图像</span>，并在region中返回分割后的区域，分割所使用的阈值由method中给出的方法确定，非常适用于在均匀照明的背景下分割字符；</h4> 
<h4>目前，method总共提供两种方法：'max_separability' 和 'smooth_histo'，<span style="color:#f33b45;">这两种方法都只能用于具有双峰直方图的图像</span>：</h4> 
<h4><span style="color:#3399ea;"> 'smooth_histo' 方法和bin_threshold的功能一致，可以参考bin_threshold的分割过程；</span></h4> 
<h4><span style="color:#3399ea;">'max_separability' 方法是靠UsedThreshold来决定最小阈值的，速度比'smooth_histo'要快，对于干扰也不是那么敏感；</span></h4> 
<p> </p> 
<h2>五、auto_theshold 直方图阈值</h2> 
<h3>auto_threshold(Image : Regions : Sigma : )<span style="color:#3399ea;"> 对应参数分别为输入图像、输出区域、高斯参数</span></h3> 
<h4>利用直方图确定的阈值分割图像，通过多阈值分割<span style="color:#f33b45;">单通道图像</span>，会返回多个区域；首先输入图像的绝对直方图的灰度值是确定的，然后高斯平滑（Sigma）后从直方图中提取相关的最小值，Sigma越大，提取的区域就越小；</h4> 
<p><img alt="" height="461" src="https://images2.imgbox.com/a9/82/STQ93sLG_o.png" width="652"></p> 
<h4>代码如下：</h4> 
<h4>read_image (Image2, 'C:/Users/Administrator/Desktop/2注册图片.bmp')<br> draw_rectangle1 (200000, Row1, Column1, Row2, Column2)<br> gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)<br> reduce_domain (Image2, Rectangle, ImageReduced)<br> median_image (ImageReduced, ImageMedian, 'circle', 5, 'mirrored')  为了过滤干扰因素，不进行过滤的话，会返回很多个干扰区域；<br> auto_threshold (ImageMedian, Regions, 5)</h4> 
<p> </p> 
<h2>六、fast_threshod 全局阈值</h2> 
<h3>fast_threshold(Image : Region : MinGray, MaxGray, MinSize : ) <span style="color:#3399ea;">对应参数分别为输入图像、输出区域、阈值下限、阈值上限、处理参数</span></h3> 
<h4>基于全局阈值的图像快速阈值化，fast_threshold从输入图像中选择灰度值g满足以下条件的像素：</h4> 
<p><img alt="" height="89" src="https://images2.imgbox.com/78/d7/hqPVAzm2_o.png" width="640"></p> 
<h4>此方法为了节约处理时间，分成两步去阈值图像，第一步是通过MinSize的值来先处理行列间隔为Minsize的所有像素点，第二步是再处理邻域(size (2*MinSize+1) x (2*MinSize+1))的所有点；</h4> 
<h4>对于不需要深入研究的人，在理解MinSize的时候，可以直接理解为就是一个加速参数，把图像分成两块来分别处理，MinSize决定了两块的比例；</h4> 
<h4><span style="color:#f33b45;">虽然Fast_threshold已经分了两步去处理，但是由于多核计算机支持SSE2指令集的，所以再多核计算机上threshold的速度是大于fast_threshold的，基本上fast_threshold主要用于嵌入式系统中，速度才会快于threshold;</span></h4> 
<h4>测试速度：</h4> 
<h4>代码如下：处理一幅大图时</h4> 
<p><img alt="" height="165" src="https://images2.imgbox.com/0a/ca/4uqarsih_o.png" width="704"></p> 
<h4>没有循环的情况下，只执行一遍，fast_threshold的MinSize=1,执行时间如下：</h4> 
<p><img alt="" height="28" src="https://images2.imgbox.com/00/0b/Izr1LgsK_o.png" width="396"></p> 
<h4>没有循环的情况下，只执行一遍，fast_threshold的MinSize=200,执行时间如下：</h4> 
<p><img alt="" height="30" src="https://images2.imgbox.com/b5/e3/0p1Fp734_o.png" width="382"></p> 
<h4>把fast_threshold更换成threshold (ImageReduced, Region,20, 255)，执行时间如下：</h4> 
<p><img alt="" height="32" src="https://images2.imgbox.com/34/8b/MdfGXKFd_o.png" width="355"></p> 
<h4><span style="color:#f33b45;">注意：只是简单论证两种方式的时间，不够严谨性，如需要大量验证，必须保证条件的一致性，以及执行的次数够过才行；</span></h4> 
<p> </p> 
<h2>七、var_threshold </h2> 
<h4>var_threshold(Image : Region : MaskWidth, MaskHeight, StdDevScale, AbsThreshold, LightDark : )<br><span style="color:#3399ea;">分别对应于参数</span></h4> 
<h4><span style="color:#3399ea;">输入图像、输出区域、掩膜宽度、掩膜高度、灰度值的标准差因子、与平均值的最小灰度差值、阈值类型</span></h4> 
<h4><span style="color:#ffbb66;">在不均匀的，嘈杂的，或不均匀照明的背景上分割区域是比较合适的；</span></h4> 
<h4>通过局部均值和标准差分析阈值图像，主要通过以下几个条件来选择像素：</h4> 
<h4>1、提取像素的局部灰度值是亮的还是暗的，也就是提取前景还是背景，取决于参数LightDark;</h4> 
<h4>2、MaskWidth和MaskHeight如下图，其他参数相同的情况下，（1）是原始图片，（2）是MaskWidth和MaskHeight等于12，（3）是MaskWidth和MaskHeight等于3，（4）是MaskWidth和MaskHeight等于40</h4> 
<p><img alt="" height="670" src="https://images2.imgbox.com/c8/b4/EskEknjU_o.png" width="831"></p> 
<h4><span style="color:#f33b45;">因此MaskWidth和MaskHeight的最小值应该要大于等于3，值3可以被认为是最小的敏感值；</span></h4> 
<h4>3、如果StdDevScale是正值，那么像素灰度值需要具有较高的标准偏差（不均匀的图像）；如果StdDevScale是负值，那么像素灰度值需要具有较低的标准偏差（均匀的图像）；StdDevScale 局部标准差被用来衡量图像中的噪声，<span style="color:#f33b45;">标准差可以通过StdDevScale进行缩放（最后一张图体现了缩放的意义）</span>，以反映所需的灵敏度，较高的值意味着只选择与周围环境非常不同的像素，建议值是在-1.0到1.0之间，0.2是建议值，如下图：</h4> 
<p><img alt="" height="508" src="https://images2.imgbox.com/bb/97/pok3bCp2_o.png" width="1200"></p> 
<h4>图（1）是StdDevScale的值过于小，导致很多像素没有被选中，图（2）是值过大，导致不需要的像素值被选中；</h4> 
<p> </p> 
<h4>4、AbsThreshold 在均匀的图像中，标准差较低;因此，单个灰度值的影响较大，为了减小算子的灵敏度，需要调整AbsThreshold的值，这样单个灰度值的变化就可以被忽略；</h4> 
<h4>值得注意的是，如果StdDevScale是负值，AbsThreshold也应该选择为负值，因为标准差比较低，在介绍StdDevScale时有提到；</h4> 
<p> </p> 
<h4><span style="color:#f33b45;">补充：标准差可以通过StdDevScale进行缩放</span></h4> 
<p><img alt="" height="508" src="https://images2.imgbox.com/58/46/fG8VnuMn_o.png" width="875"></p> 
<h4><span style="color:#f33b45;">结果灰度值GrayValues，经过StdDev的值来放大，主要在平均灰度值Mean的基础上，从而拉大灰度值的差距，提高对比来选出需要的区域</span></h4> 
<h3> </h3> 
<h3>总结：</h3> 
<h3>1、使用最多的基本就是threshold、dyn_threshold、binary_threshold和var_threshold;</h3> 
<h3>2、正常干扰不多的情况下直接用threshold即可；</h3> 
<h3>3、复杂情况根据具体需要选择dyn_threshold、binary_threshold、var_threshold;</h3> 
<p> </p> 
<p> </p> 
<h2> </h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2286d4cda51329dd370cf1c616e69c00/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySql单独安装 8.0版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44bddfac07673656247a2e38246bf534/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenGL入门（1）——建立一个OpenGL项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>