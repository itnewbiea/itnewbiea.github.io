<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023令我惊叹的C&#43;&#43;代码用法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023令我惊叹的C&#43;&#43;代码用法" />
<meta property="og:description" content="在C&#43;&#43;编程语言中，有很多高级特性和技巧可以提升代码的质量和效率。下面将介绍五个C&#43;&#43;高级代码知识，包括虚函数、模板、智能指针、多线程和RAII。同时，我会展示一个最令自己惊叹的C&#43;&#43;代码，并解释它的用途和用法。
一·C&#43;&#43;高级代码知识 1·虚函数 虚函数是在基类中声明为virtual的成员函数。它的主要作用是实现动态多态性，使得在派生类中可以重写该函数，并且在运行时确定调用哪个实现。虚函数通过在基类中定义函数原型，使得派生类可以覆盖该函数，并且通过基类指针或引用调用时，能够根据对象的实际类型来调用相应的函数。虚函数的实现机制是通过在每个对象中保存一个虚函数表（vtable），其中包含了虚函数的地址，并在运行时通过对象中的vptr（虚指针）来访问正确的函数实现。虚函数的主要应用场景包括多态、接口和抽象类等。
#include &lt;iostream&gt; class Base { public: virtual void show() { std::cout &lt;&lt; &#34;Base class\n&#34;; } }; class Derived : public Base { public: void show() override { std::cout &lt;&lt; &#34;Derived class\n&#34;; } }; int main() { Base* basePtr = new Derived(); basePtr-&gt;show(); // 输出 &#34;Derived class&#34; delete basePtr; return 0; } 注释：虚函数允许我们使用基类指针或引用调用派生类的函数。在这个例子中，即使basePtr是指向Derived对象的基类指针，当我们调用show时，它仍然会调用Derived类的实现。
2·模板 模板是C&#43;&#43;中的一种编程技术，它使得程序员能够编写与数据类型无关的代码。模板可以分为两类：函数模板和类模板。函数模板使用template关键字声明，并使用typename或class关键字指定类型参数。类模板使用template关键字声明类，并在类定义中使用类型参数表示类的成员变量或返回类型。模板的主要应用场景包括泛型编程、STL容器和算法等。
#include &lt;iostream&gt; #include &lt;vector&gt; template &lt;typename T&gt; void print(const std::vector&lt;T&gt;&amp; vec) { for (const auto&amp; elem : vec) { std::cout &lt;&lt; elem &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/69fb65177a0e426f0967c6df7f23c4c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-30T20:45:45+08:00" />
<meta property="article:modified_time" content="2023-12-30T20:45:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023令我惊叹的C&#43;&#43;代码用法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在C++编程语言中，有很多高级特性和技巧可以提升代码的质量和效率。下面将介绍五个C++高级代码知识，包括虚函数、模板、智能指针、多线程和RAII。同时，我会展示一个最令自己惊叹的C++代码，并解释它的用途和用法。</p> 
<h3>一·C++高级代码知识</h3> 
<h4>1·虚函数</h4> 
<p>虚函数是在基类中声明为virtual的成员函数。它的主要作用是实现动态多态性，使得在派生类中可以重写该函数，并且在运行时确定调用哪个实现。虚函数通过在基类中定义函数原型，使得派生类可以覆盖该函数，并且通过基类指针或引用调用时，能够根据对象的实际类型来调用相应的函数。虚函数的实现机制是通过在每个对象中保存一个虚函数表（vtable），其中包含了虚函数的地址，并在运行时通过对象中的vptr（虚指针）来访问正确的函数实现。虚函数的主要应用场景包括多态、接口和抽象类等。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;  
  
class Base {  
public:  
    virtual void show() { std::cout &lt;&lt; "Base class\n"; }  
};  
  
class Derived : public Base {  
public:  
    void show() override { std::cout &lt;&lt; "Derived class\n"; }  
};  
  
int main() {  
    Base* basePtr = new Derived();  
    basePtr-&gt;show();  // 输出 "Derived class"  
    delete basePtr;  
    return 0;  
}</code></pre> 
<p>注释：虚函数允许我们使用基类指针或引用调用派生类的函数。在这个例子中，即使<code>basePtr</code>是指向<code>Derived</code>对象的基类指针，当我们调用<code>show</code>时，它仍然会调用<code>Derived</code>类的实现。</p> 
<h4>2·模板</h4> 
<p>模板是C++中的一种编程技术，它使得程序员能够编写与数据类型无关的代码。模板可以分为两类：函数模板和类模板。函数模板使用template关键字声明，并使用typename或class关键字指定类型参数。类模板使用template关键字声明类，并在类定义中使用类型参数表示类的成员变量或返回类型。模板的主要应用场景包括泛型编程、STL容器和算法等。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;vector&gt;  
  
template &lt;typename T&gt;  
void print(const std::vector&lt;T&gt;&amp; vec) {  
    for (const auto&amp; elem : vec) {  
        std::cout &lt;&lt; elem &lt;&lt; " ";  
    }  
    std::cout &lt;&lt; "\n";  
}  
  
int main() {  
    std::vector&lt;int&gt; intVec = {1, 2, 3, 4, 5};  
    std::vector&lt;std::string&gt; strVec = {"hello", "world"};  
    print(intVec);  // 输出: 1 2 3 4 5   
    print(strVec);  // 输出: hello world   
    return 0;  
}</code></pre> 
<p>注释：模板允许我们编写与数据类型无关的代码。在这里，我们定义了一个模板函数<code>print</code>，它可以接受任何类型的<code>std::vector</code>。通过使用模板，我们可以避免为不同的数据类型编写重复的代码。</p> 
<h4>3·智能指针</h4> 
<p>智能指针是C++11引入的一种技术，用于管理动态分配的内存，并提供自动内存管理的功能。智能指针的目的是为了解决原始指针在动态内存分配中可能出现的内存泄漏和悬挂指针等问题。智能指针通过重载operator-&gt;和operator*操作符来提供对指针的访问，并在适当的时候自动删除指针。智能指针的主要类型包括std::unique_ptr、std::shared_ptr和std::weak_ptr等。智能指针的应用场景包括避免内存泄漏、实现RAII（资源获取即初始化）等。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;memory&gt;  // for std::unique_ptr and std::shared_ptr  
  
struct Foo {  
    Foo() { std::cout &lt;&lt; "Foo::Foo\n"; }  
    ~Foo() { std::cout &lt;&lt; "Foo::~Foo\n"; }  
};  
  
int main() {  
    std::unique_ptr&lt;Foo&gt; uniquePtr(new Foo);  // 自动管理内存，防止内存泄漏！  
    {  // new scope to demonstrate unique_ptr's behavior when going out of scope.  
        std::cout &lt;&lt; "uniquePtr points to " &lt;&lt; uniquePtr.get() &lt;&lt; '\n';  // still valid pointer!  
        std::cout &lt;&lt; "uniquePtr points to " &lt;&lt; uniquePtr.release() &lt;&lt; '\n';  // now the raw pointer is released!  
    }  // Foo::~Foo is called here because uniquePtr went out of scope!  
    return 0;  
}</code></pre> 
<p>注释：智能指针是用来管理动态分配内存的强大工具。在上述例子中，我们使用<code>std::unique_ptr</code>来确保在离开作用域时自动删除对象，从而避免内存泄漏。当<code>uniquePtr</code>离开作用域时，它会自动删除所指向的对象。而如果需要共享所有权，则可以使用<code>std::shared_ptr</code>。</p> 
<h4>4·多线程</h4> 
<p>多线程是C++11引入的一种并发编程技术，它允许程序同时执行多个线程，以提高程序的执行效率和响应性。C++提供了多种线程同步机制，如互斥锁、条件变量、信号量等，以帮助程序员在多线程环境中避免数据竞争和死锁等问题。多线程编程的应用场景包括网络编程、实时系统、并行计算等。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;thread&gt;  // for std::thread  
#include &lt;mutex&gt;   // for std::mutex and std::lock_guard  
  
std::mutex mtx;  // 全局互斥锁  
int shared_var = 0;  // 共享变量  
  
void thread_func(int id) {  
    std::lock_guard&lt;std::mutex&gt; lock(mtx);  // 自动锁定互斥锁  
    std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " is accessing shared_var: " &lt;&lt; shared_var &lt;&lt; '\n';  
    shared_var += 1;  // 修改共享变量  
}  
  
int main() {  
    std::thread t1(thread_func, 1);  // 创建第一个线程  
    std::thread t2(thread_func, 2);  // 创建第二个线程  
  
    t1.join();  // 等待第一个线程完成  
    t2.join();  // 等待第二个线程完成  
  
    std::cout &lt;&lt; "Final value of shared_var: " &lt;&lt; shared_var &lt;&lt; '\n';  // 输出共享变量的最终值  
    return 0;  
}</code></pre> 
<p>注释：在多线程编程中，为了避免多个线程同时访问同一资源而导致的数据竞争和不可预测的行为，我们需要使用同步机制来确保线程之间的互斥访问。在这个例子中，我们使用<code>std::mutex</code>和<code>std::lock_guard</code>来实现互斥锁，以确保在任何时刻只有一个线程能够访问共享变量<code>shared_var</code>。<code>std::lock_guard</code>是一个RAII（资源获取即初始化）风格的智能锁，它会在构造时自动锁定互斥锁，并在析构时自动解锁互斥锁，从而简化了互斥锁的管理。</p> 
<h4>5·<strong>RAII（资源获取即初始化）</strong></h4> 
<p>RAII是一种编程技术，它将对象的生命周期与资源的生命周期绑定在一起，通过在对象的构造函数中获取资源，并在析构函数中释放资源，来确保资源的正确管理和释放。RAII的主要应用场景包括内存管理、文件句柄管理、锁管理等方面。通过使用RAII技术，可以避免资源泄漏和异常安全问题，提高代码的可维护性和可靠性。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;memory&gt;  // for std::unique_ptr and std::make_unique  
  
struct Foo {  
    Foo(int value) : value_(value) { std::cout &lt;&lt; "Foo::Foo\n"; }  
    ~Foo() { std::cout &lt;&lt; "Foo::~Foo\n"; }  
    int value() const { return value_; }  
    private:  
        int value_;  
};  
  
void func() {  
    std::unique_ptr&lt;Foo&gt; ptr = std::make_unique&lt;Foo&gt;(42);  // 使用unique_ptr管理动态内存  
    {  // new scope to demonstrate unique_ptr's behavior when going out of scope.  
        std::cout &lt;&lt; "ptr points to " &lt;&lt; ptr.get() &lt;&lt; '\n';  // still valid pointer!  
        std::cout &lt;&lt; "ptr points to " &lt;&lt; ptr.release() &lt;&lt; '\n';  // now the raw pointer is released!  
    }  // Foo::~Foo is called here because ptr went out of scope!  
}  
  
int main() {  
    func();  // 输出: Foo::Foo Foo::~Foo (析构函数在unique_ptr离开作用域时自动调用)  
    return 0;  
}</code></pre> 
<p>注释：RAII（Resource Acquisition Is Initialization）是一种编程技术，它通过将资源（如动态内存、文件句柄等）的获取和释放与对象的生命周期绑定在一起，从而简化了资源管理。在这个例子中，我们使用<code>std::unique_ptr</code>来管理动态分配的<code>Foo</code>对象。当<code>unique_ptr</code>离开作用域时，它会自动删除所指向的对象，从而避免了手动释放内存的需要。</p> 
<h3>二·最令我惊叹的C++代码</h3> 
<p>下面是一个使用C++编写的简单而高效的代码示例，它展示了多线程和RAII的结合应用：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;thread&gt;  
#include &lt;mutex&gt;  
#include &lt;vector&gt;  
  
std::mutex mtx; // 全局互斥锁  
std::vector&lt;int&gt; shared_data; // 共享数据  
  
void worker(int id) {  
    // 锁定互斥锁，确保线程安全地访问共享数据  
    std::lock_guard&lt;std::mutex&gt; lock(mtx);  
    // 在这里执行对共享数据的操作...  
    shared_data[id] = id * 2; // 示例操作：将id乘以2并存储到共享数据中  
}  
  
int main() {  
    const int num_threads = 5; // 创建5个线程  
    std::vector&lt;std::thread&gt; threads; // 存储线程的向量  
    // 创建线程并启动工作函数  
    for (int i = 0; i &lt; num_threads; ++i) {  
        threads.push_back(std::thread(worker, i)); // 将线程添加到向量中  
    }  
    // 等待所有线程完成执行任务  
    for (auto&amp; thread : threads) {  
        thread.join();  
    }  
    // 输出共享数据的结果（此时应该已经被所有线程更新过）  
    for (int i = 0; i &lt; num_threads; ++i) {  
        std::cout &lt;&lt; "shared_data[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; shared_data[i] &lt;&lt; std::endl;  
    }  
    return 0;  
}</code></pre> 
<p>这段代码实现了一个多线程程序，其中使用了互斥锁（mutex）来保证线程安全地访问共享数据。具体来说，它创建了5个线程，每个线程都执行一个名为<code>worker</code>的函数。这个函数会锁定一个全局互斥锁，然后对共享数据<code>shared_data</code>进行操作（在这个例子中，操作是将线程的ID乘以2并存储到<code>shared_data</code>中）。</p> 
<p>代码的主要步骤如下：</p> 
<ol><li>包含必要的头文件：<code>&lt;iostream&gt;</code>用于输入输出，<code>&lt;thread&gt;</code>用于多线程编程，<code>&lt;mutex&gt;</code>用于互斥锁，<code>&lt;vector&gt;</code>用于使用向量（动态数组）。</li><li>声明全局互斥锁<code>mtx</code>和共享数据向量<code>shared_data</code>。</li><li>定义<code>worker</code>函数，它接受一个线程ID作为参数。在这个函数中，首先使用<code>std::lock_guard</code>锁定互斥锁，以确保在函数执行期间互斥锁被锁定，并在函数结束时自动解锁。然后，对共享数据进行操作（在这个例子中，将线程ID乘以2并存储到<code>shared_data</code>中）。</li><li>在<code>main</code>函数中，首先定义一个向量<code>threads</code>用于存储线程对象。然后，通过循环创建5个线程，并将每个线程与<code>worker</code>函数绑定。创建的线程对象被添加到<code>threads</code>向量中。</li><li>使用另一个循环等待所有线程完成执行任务。这是通过调用每个线程对象的<code>join</code>方法实现的，它会阻塞主线程，直到对应的子线程执行完毕。</li><li>最后，输出共享数据的结果。通过循环遍历<code>shared_data</code>向量，并使用<code>std::cout</code>输出每个元素的值。</li></ol> 
<p>总体而言，这段代码演示了如何使用C++中的多线程和互斥锁来安全地访问共享数据。通过锁定互斥锁，可以确保在任何时刻只有一个线程能够访问共享数据，从而避免了数据竞争和不一致的问题。</p> 
<h3>三·总结</h3> 
<p><strong>2023年，这是一个充满挑战与机遇的一年。在这一年里，我们见证了世界的变化，科技的进步，也感受到了生活的喜怒哀乐。回首过去，我们有许多的遗憾和失落，也有无数的喜悦和收获。感谢2023年的陪伴，让我们在挫折中成长，在困难中坚强。虽然我们即将告别2023年，但我们要带着希望和勇气迎接新的一年。愿我们在新的一年里，能够拥有更多的快乐和幸福，实现自己的梦想和目标。再见，2023年，你好，充满无限可能的2024年！</strong></p> 
<p> <strong>最后，都看到这里了，留下一个免费的赞和关注呗~跪谢~</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2fd42316674f318b582af6be2d0d35f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python文件打包实战技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d73d5b2faa5241a28850df41f6b11b67/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">macos下转换.dmg文件为 .iso .cdr文件的简单方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>