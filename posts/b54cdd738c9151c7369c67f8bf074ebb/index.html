<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android中arm64-v8a、armeabi-v7a、armeabi是什么? - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android中arm64-v8a、armeabi-v7a、armeabi是什么?" />
<meta property="og:description" content="------《怎么利用Android Studio查看Android-SDK源码》 前言正题ABI是如何工作的ABI具体适配流程项目中该如何适配打包配置split分包ndk{abiFilters:}过滤 前言 首先：ARM是神马？
答：ARM是我们设备的CPU架构。
其次：arm64-v8a、armeabi-v7a、armeabi是神马？
答：在Android 系统上，每一个CPU架构对应一个ABI。他们就是我们的ABI类型
最后：ABI是神马？
答：应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。
补充：查询手机cpu命令行
答： adb shell getprop ro.product.cpu.abi
正题 armeabi-v7a: ARM v7架构之前的主流版本，现在也很多。
arm64-v8a: 64位支持，目前主流的版本。
ABI是如何工作的 一个Android设备可以支持多种ABI,设备主ABI和辅助ABI。
以arm64-v8a为主ABI的设备，辅助ABI为armeabi-v7a和armeabi。
以armeabi-v7a为主ABI的设备，辅助ABI为armeabi。
ABI具体适配流程 对于一个cpu是arm64-v8a架构的手机，它运行app时，进入jnilibs去读取库文件时，先看有没有arm64-v8a文件夹，如果没有该文件夹，去找armeabi-v7a文件夹，如果没有，再去找armeabi文件夹，如果连这个文件夹也没有，就抛出异常。
如果有arm64-v8a文件夹，那么就去找特定名称的.so文件，注意：如果没有找到想要的.so文件，不会再往下（armeabi-v7a文件夹）找了，而是直接抛出异常。
项目中该如何适配 问题：只适配了armeabi-v7a,那如果APP装在其他架构的手机上，如arm64-v8a上，会蹦吗？
答: 不会，但是反过来会。 因为armeabi-v7a和arm64-v8a会向下兼容：
只适配armeabi的APP可以跑在armeabi,x86,x86_64,armeabi-v7a,arm64-v8上
只适配armeabi-v7a可以运行在armeabi-v7a和arm64-v8a
只适配arm64-v8a 可以运行在arm64-v8a上
适配方案有哪些？
1、只适配armeabi 优点:基本上适配了全部CPU架构（除了淘汰的mips和mips_64） 缺点：性能低，相当于在绝大多数手机上都是需要辅助ABI或动态转码来兼容。
2、只适配 armeabi-v7a 同理方案一，只是又筛掉了一部分老旧设备,在性能和兼容二者中比较平衡。
3、只适配 arm64-v8 优点: 性能最佳 缺点： 只能运行在arm64-v8上，要放弃部分老旧设备用户。
这三种方案都是可以的，现在的大厂APP适配中，这三种都有，大部分是前2种方案。具体选哪一种就看自己的考量了，以性能换兼容就arm64-v8,以兼容换性能armeabi,二者稍微平衡一点的就armeabi-v7a。
打包配置 split分包 这个命令可以按照各种规则去分包，比如按照abi,屏幕密度（即ldpi,hdpi等）分包。
splits { abi { enable true reset() include &#39;x86&#39;,&#39;armabi&#39; exclude &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b54cdd738c9151c7369c67f8bf074ebb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-14T10:06:21+08:00" />
<meta property="article:modified_time" content="2023-03-14T10:06:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android中arm64-v8a、armeabi-v7a、armeabi是什么?</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>------《怎么利用Android Studio查看Android-SDK源码》</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_14" rel="nofollow">正题</a></li><li><ul><li><a href="#ABI_18" rel="nofollow">ABI是如何工作的</a></li><li><a href="#ABI_22" rel="nofollow">ABI具体适配流程</a></li><li><a href="#_25" rel="nofollow">项目中该如何适配</a></li><li><a href="#_38" rel="nofollow">打包配置</a></li><li><ul><li><a href="#split_39" rel="nofollow">split分包</a></li><li><a href="#ndkabiFilters_55" rel="nofollow">ndk{abiFilters:}过滤</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p><strong>首先：ARM是神马？</strong><br> 答：ARM是我们设备的CPU架构。</p> 
<p><strong>其次：arm64-v8a、armeabi-v7a、armeabi是神马？</strong><br> 答：在Android 系统上，每一个CPU架构对应一个ABI。他们就是我们的ABI类型<br> <img src="https://images2.imgbox.com/3d/3c/DZSR3K46_o.png" alt="在这里插入图片描述"><br> <strong>最后：ABI是神马？</strong><br> 答：应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。</p> 
<p><strong>补充：查询手机cpu命令行</strong><br> 答： <code>adb shell getprop ro.product.cpu.abi</code><br> <img src="https://images2.imgbox.com/96/7a/cpXcmZIE_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_14"></a>正题</h2> 
<blockquote> 
 <p>armeabi-v7a: ARM v7架构之前的主流版本，现在也很多。<br> arm64-v8a: 64位支持，目前主流的版本。</p> 
</blockquote> 
<h3><a id="ABI_18"></a>ABI是如何工作的</h3> 
<p>一个Android设备可以支持多种ABI,设备主ABI和辅助ABI。<br> 以arm64-v8a为主ABI的设备，辅助ABI为armeabi-v7a和armeabi。<br> 以armeabi-v7a为主ABI的设备，辅助ABI为armeabi。</p> 
<h3><a id="ABI_22"></a>ABI具体适配流程</h3> 
<p>对于一个cpu是arm64-v8a架构的手机，它运行app时，进入jnilibs去读取库文件时，先看有没有arm64-v8a文件夹，如果没有该文件夹，去找armeabi-v7a文件夹，如果没有，再去找armeabi文件夹，如果连这个文件夹也没有，就抛出异常。<br> 如果有arm64-v8a文件夹，那么就去找特定名称的.so文件，注意：如果没有找到想要的.so文件，不会再往下（armeabi-v7a文件夹）找了，而是直接抛出异常。</p> 
<h3><a id="_25"></a>项目中该如何适配</h3> 
<p><strong>问题：只适配了armeabi-v7a,那如果APP装在其他架构的手机上，如arm64-v8a上，会蹦吗？</strong><br> 答: 不会，但是反过来会。 因为armeabi-v7a和arm64-v8a会向下兼容：</p> 
<blockquote> 
 <p>只适配armeabi的APP可以跑在armeabi,x86,x86_64,armeabi-v7a,arm64-v8上<br> 只适配armeabi-v7a可以运行在armeabi-v7a和arm64-v8a<br> 只适配arm64-v8a 可以运行在arm64-v8a上</p> 
</blockquote> 
<p>适配方案有哪些？<br> <strong>1、只适配armeabi 优点:基本上适配了全部CPU架构（除了淘汰的mips和mips_64） 缺点：性能低，相当于在绝大多数手机上都是需要辅助ABI或动态转码来兼容。<br> 2、只适配 armeabi-v7a 同理方案一，只是又筛掉了一部分老旧设备,在性能和兼容二者中比较平衡。<br> 3、只适配 arm64-v8 优点: 性能最佳 缺点： 只能运行在arm64-v8上，要放弃部分老旧设备用户。</strong><br> 这三种方案都是可以的，现在的大厂APP适配中，这三种都有，大部分是前2种方案。具体选哪一种就看自己的考量了，以性能换兼容就arm64-v8,以兼容换性能armeabi,二者稍微平衡一点的就armeabi-v7a。</p> 
<h3><a id="_38"></a>打包配置</h3> 
<h4><a id="split_39"></a>split分包</h4> 
<p>这个命令可以按照各种规则去分包，比如按照abi,屏幕密度（即ldpi,hdpi等）分包。</p> 
<pre><code>splits { 
   
        abi { 
   
            enable true
            reset()
            include 'x86','armabi'
            exclude 'armeabi', 'armeabi-v7a', "arm64-v8a"
            universalApk true
        }
    }
</code></pre> 
<h4><a id="ndkabiFilters_55"></a>ndk{abiFilters:}过滤</h4> 
<p>这个指令可以配置只打包你配置的so库，没有配置的就不打包，很灵活。 第三方aar文件，如果这个sdk对abi的支持比较全，可能会包含armeabi、armeabi-v7a、x86、arm64-v8a、x86_64五种abi，而你应用的其它so只支持armeabi、armeabi-v7a、x86三种，直接引用sdk的aar，会自动编译出支持5种abi的包。但是应用的其它so缺少对其它两种abi的支持，那么如果应用运行于arm64-v8a、x86_64为首选abi的设备上时，就会crash了，所以我们需要在我们的app中配置 abiFilter 配置，来避免一些未知的错误</p> 
<pre><code>//过滤x86的so库
ndk { 
   
    abiFilters 'armeabi', 'armeabi-v7a', 'arm64-v8a'
}
</code></pre> 
<p>这样配置会将armeabi，armeabi-v71,arm64-v8a这3个包下的so库都打包到一个apk,而不像splits会每一个包打一个apk.</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c4f211091ac569712f0ee18ccf0b0b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CS和BS的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a8465d1142c44016bf50395a3435fca1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">csdn博客无法发布文章，提示获取基础信息失败，请刷新页面重试！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>