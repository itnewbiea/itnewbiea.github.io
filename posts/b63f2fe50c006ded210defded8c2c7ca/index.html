<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么要用深浅拷贝、什么是深浅拷贝、以及如何实现 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么要用深浅拷贝、什么是深浅拷贝、以及如何实现" />
<meta property="og:description" content="一、深拷贝和浅拷贝 首先我们要明白一点，js中数据类型分为：
基本数据类型 （Number, String, Boolean, Null, Undefined, Symbol）
对象数据类型 （ Object )
引用数据类型的值是保存在栈内存和堆内存中的对象。栈区内存保存变量标识符和指向堆内存中该对象的指针。当寻找引用值时，解释器会先寻找栈中的地址。然后根据地址找到堆内存的实体。
二、为什么要进行深浅拷贝 首先看下如下代码 let a = b = 2 a = 3 console.log(a) console.log(b) let c = d = [1,2,3] let e = f = {a:1,b:2,c:3} c[0] = 2 e.a = 2 console.log(d[0]) console.log(f.a) 会发现，同一个Array或者Object赋值给两个不同变量时，变量指向的是同一个内存地址，所以就会造成其中一个变量改变属性值，同时改变了另外一个变量的对应属性值。
而大多数实际项目中，我们想要的结果是两个变量（初始值相同）互不影响。所以就要使用到拷贝（分为深浅两种）
三、深浅拷贝的区别： 浅拷贝是将原始对象中的数据型字段拷贝到新对象中去，将引用型字段的“引用”复制到新对象中去，不把“引用的对象”复制进去，所以原始对象和新对象引用同一对象，新对象中的引用型字段发生变化会导致原始对象中的对应字段也发生变化。
深拷贝是在引用方面不同，深拷贝就是创建一个新的和原始字段的内容相同的字段，是两个一样大的数据段，所以两者的引用是不同的，之后的新对象中的引用型字段发生改变，不会引起原始对象中的字段发生改变。
结果：
一次构造
两次析构
编译系统在我们自己没有自定义拷贝构造函数时，会在拷贝对象时候调用默认拷贝构造函数，进行浅拷贝，即对指针name拷贝后出现两个指针指向同一个内存块。所以析构时候就析构了两次，导致内存泄漏。
所以在对“含有指针成员的对象”进行拷贝时，必须要自己定义拷贝构造函数，使拷贝构造后的对象指针成员有自己的内存空间，即进行深拷贝，避免内存泄漏。
test.cpp
结果：
构造一次
拷贝构造一次
析构两次
在这里插入图片描述
综上所述，浅拷贝是只对指针进行拷贝，两个指针指向同一个内存块，深拷贝是对指针和指针指向的内容都进行拷贝，拷贝后的指针是指向不同内的指针。
深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。 深拷贝
深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，
对一个对象的修改并不会影响另一个对象。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b63f2fe50c006ded210defded8c2c7ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-15T10:01:03+08:00" />
<meta property="article:modified_time" content="2020-08-15T10:01:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么要用深浅拷贝、什么是深浅拷贝、以及如何实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、深拷贝和浅拷贝</h3> 
<p>首先我们要明白一点，js中数据类型分为：</p> 
<p><strong>基本数据类型 （Number, String, Boolean, Null, Undefined, Symbol）<br> 对象数据类型 （ Object )</strong><br> 引用数据类型的值是保存在栈内存和堆内存中的对象。栈区内存保存变量标识符和指向堆内存中该对象的指针。当寻找引用值时，解释器会先寻找栈中的地址。然后根据地址找到堆内存的实体。<br> <img src="https://images2.imgbox.com/65/87/XOmV8tSq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_9"></a>二、为什么要进行深浅拷贝</h3> 
<pre><code>首先看下如下代码
</code></pre> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> b <span class="token operator">=</span> <span class="token number">2</span>
a <span class="token operator">=</span> <span class="token number">3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> e <span class="token operator">=</span> f <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">}</span>
c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
e<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
</code></pre> 
<p>会发现，同一个Array或者Object赋值给两个不同变量时，变量指向的是同一个内存地址，所以就会造成其中一个变量改变属性值，同时改变了另外一个变量的对应属性值。</p> 
<p><strong>而大多数实际项目中，我们想要的结果是两个变量（初始值相同）互不影响。所以就要使用到拷贝（分为深浅两种）</strong></p> 
<h3><a id="_32"></a>三、深浅拷贝的区别：</h3> 
<p>浅拷贝是将原始对象中的数据型字段拷贝到新对象中去，将引用型字段的“引用”复制到新对象中去，不把“引用的对象”复制进去，所以原始对象和新对象引用同一对象，新对象中的引用型字段发生变化会导致原始对象中的对应字段也发生变化。<br> 深拷贝是在引用方面不同，深拷贝就是创建一个新的和原始字段的内容相同的字段，是两个一样大的数据段，所以两者的引用是不同的，之后的新对象中的引用型字段发生改变，不会引起原始对象中的字段发生改变。<br> <img src="https://images2.imgbox.com/50/89/lfyOJ7kO_o.png" alt="在这里插入图片描述"><br> 结果：</p> 
<p>一次构造</p> 
<p>两次析构<br> <img src="https://images2.imgbox.com/ff/af/pbJWC3Wc_o.png" alt="在这里插入图片描述"><br> 编译系统在我们自己没有自定义拷贝构造函数时，会在拷贝对象时候调用默认拷贝构造函数，进行浅拷贝，即对指针name拷贝后出现两个指针指向同一个内存块。所以析构时候就析构了两次，导致内存泄漏。<br> <img src="https://images2.imgbox.com/bf/b0/tiqWM3q8_o.png" alt="在这里插入图片描述"><br> 所以在对“含有指针成员的对象”进行拷贝时，必须要自己定义拷贝构造函数，使拷贝构造后的对象指针成员有自己的内存空间，即进行深拷贝，避免内存泄漏。<br> <img src="https://images2.imgbox.com/5d/ec/8FyG36CG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/06/53/3H4dcaSf_o.png" alt="在这里插入图片描述"><br> test.cpp<br> <img src="https://images2.imgbox.com/ed/55/24ZJglXM_o.png" alt="在这里插入图片描述"><br> 结果：</p> 
<p>构造一次</p> 
<p>拷贝构造一次</p> 
<p>析构两次<br> <img src="https://images2.imgbox.com/06/fc/MywbCYqa_o.png" alt="在这里插入图片描述"><br> 在这里插入图片描述<br> 综上所述，浅拷贝是只对指针进行拷贝，两个指针指向同一个内存块，深拷贝是对指针和指针指向的内容都进行拷贝，拷贝后的指针是指向不同内的指针。</p> 
<h3><a id="_61"></a>深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。</h3> 
<p><strong>深拷贝</strong></p> 
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，<br> 对一个对象的修改并不会影响另一个对象。<br> <strong>浅拷贝</strong></p> 
<p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。<br> 可 以 使 用<br> for in 、<br> Object.assign 、<br> 扩 展 运 算 符 …<br> Array.prototype.slice()、<br> Array.prototype.concat() 、递归等递归函数实现深拷贝</p> 
<h3><a id="_77"></a>针对这一共性的深浅拷贝问题，我也是略施小计，进行了一点皮毛性的总结吧，希望能给大家带来一定地方帮助，那么我的总结也是有效果的。</h3> 
<h3><a id="_78"></a>欢迎进群探讨技术交流</h3> 
<h3><a id="954314851__79"></a>群号：954314851 或者扫码进群，期待每一位大牛的加入</h3> 
<p><img src="https://images2.imgbox.com/b3/46/41HP5jHG_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa4667e8eacb4ea967d865a21f50190d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">calcite sql解析框架引擎流程图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/586d67d093708aae98efb97f6c195b13/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python程序日志_如何在python应用程序中实现日志记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>