<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>org.apache.commons.collections.bidimap - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="org.apache.commons.collections.bidimap" />
<meta property="og:description" content=" org.apache.commons.collections.bidimap 实现类： 基本类： DualHashBidiMap： 所谓BidiMap，直译就是双向Map，可以通过key找到value，也可以通过value找到key，因为我们除了需 要通过代码找到名称之外，往往也需要处理用户输入的名称，然后获取其代码。需要注意的是BidiMap当 中不光key不能重复，value也不可以。 MultiHashMap： 所谓MultiMap，就是说一个key不在是简单的指向一个对象，而是一组对象，add()和remove()的时候跟 普通的Map无异，只是在get()时返回一个Collection，利用MultiMap，我们就可以很方便的往一个key上 放数量不定的对象，也就实现了一对多。 DualTreeBidiMap: 内部采用两个TreeMap()实现，所以同一个key和value只能在其中存在一次，内部优化，同一对象并没有 存储两次 TreeBidiMap：加入中的元素许实现comparable接口，顺序将按照key，value同时的自然排序来排列。当 需要key-value作为查询的时候，该工具可以用到，内部实现仍然是两个TreeMap，但效率高于TreeMap //包装类： LazyMap： 所谓LazyMap，意思就是这个Map中的键/值对一开始并不存在，当被调用到时才创建. 我们这样来理解：我们需要一个Map，但是由于创建成员的方法很“重”（比如数据库访问）， 或者我们只有在调用get()时才知道如何创建，或者Map中出现的可能性很多很多， 我们无法在get()之前添加所有可能出现的键/值对， 我们觉得没有必要去初始化一个Map而又希望它可以在必要时自动处理数据 。。。 还有许多为实现特定功能实现的包装类，类似buffer " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a4b5461f162193e94fbd9cb8d32c7c8b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2009-09-09T10:59:45+08:00" />
<meta property="article:modified_time" content="2009-09-09T10:59:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">org.apache.commons.collections.bidimap</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    org.apache.commons.collections.bidimap 
<br> 
<br>实现类： 
<br> 
<br>基本类： 
<br> 
<br>DualHashBidiMap： 
<br>所谓BidiMap，直译就是双向Map，可以通过key找到value，也可以通过value找到key，因为我们除了需 
<br> 
<br>要通过代码找到名称之外，往往也需要处理用户输入的名称，然后获取其代码。需要注意的是BidiMap当 
<br> 
<br>中不光key不能重复，value也不可以。 
<br> 
<br>MultiHashMap： 
<br>所谓MultiMap，就是说一个key不在是简单的指向一个对象，而是一组对象，add()和remove()的时候跟 
<br> 
<br>普通的Map无异，只是在get()时返回一个Collection，利用MultiMap，我们就可以很方便的往一个key上 
<br> 
<br>放数量不定的对象，也就实现了一对多。 
<br> 
<br>DualTreeBidiMap: 
<br>内部采用两个TreeMap()实现，所以同一个key和value只能在其中存在一次，内部优化，同一对象并没有 
<br> 
<br>存储两次 
<br> 
<br>TreeBidiMap：加入中的元素许实现comparable接口，顺序将按照key，value同时的自然排序来排列。当 
<br> 
<br>需要key-value作为查询的时候，该工具可以用到，内部实现仍然是两个TreeMap，但效率高于TreeMap 
<br> 
<br>//包装类： 
<br>LazyMap： 
<br>所谓LazyMap，意思就是这个Map中的键/值对一开始并不存在，当被调用到时才创建. 
<br>我们这样来理解：我们需要一个Map，但是由于创建成员的方法很“重”（比如数据库访问）， 
<br>或者我们只有在调用get()时才知道如何创建，或者Map中出现的可能性很多很多， 
<br>我们无法在get()之前添加所有可能出现的键/值对， 
<br>我们觉得没有必要去初始化一个Map而又希望它可以在必要时自动处理数据 
<br> 
<br>。。。 
<br>还有许多为实现特定功能实现的包装类，类似buffer
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c9c60f3322ca1dc545956a0c79fccfa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LoadRunner常见问题整理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54aac351bbb94948c617a742227e8673/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Websphere 优化文档</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>