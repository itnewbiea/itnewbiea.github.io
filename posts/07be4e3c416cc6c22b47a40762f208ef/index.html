<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CodeForces - 915E 动态开点线段树 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CodeForces - 915E 动态开点线段树" />
<meta property="og:description" content="题目链接
大意：
晚上有n个亮着的灯泡，标号从1到n。
现在存在2种操作，如下：
操作1，关掉标号 [l,r] 区间的灯操作2，打开标号 [l,r] 区间的灯 下面有q次询问，每次询问执行其中一种操作，询问格式，l，r，k。k为执行操作种类。对于每次询问回答当前开着的灯的数量。
第一行包含一个整数n，第二行一个整数q(1≤n≤10^9,1≤q≤3·10^5) 因为n范围过大，如果用静态开点需要离散化，但是离散化之后就无法根据离散化后的点得到区间长度 ，还需要再开数据记录，有点麻烦，所以这题我们用动态开点，不需要的点不开辟空间就好。
动态开点需要用l，r数组记录当前点的左右子节点，而不能再用rt&lt;&lt;1和rt&lt;&lt;1|1来表示了。
用数组记录左右子节点，如果左右子节点还没有出现过，给它赋值为cnt&#43;&#43;（cnt用于给所有出现的节点编号，这样出现了多少点，就开辟了多少空间）
这题是区间更新，代码：
#include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; const int maxn=3e5&#43;10; struct vain { int l,r,sum,lazy; } tree[maxn*50]; int cnt=1; void pushdown(int l,int r,int k) { int mid=(l&#43;r)&gt;&gt;1; if (l!=r) { if (!tree[k].l) tree[k].l=&#43;&#43;cnt; if (!tree[k].r) tree[k].r=&#43;&#43;cnt; //下传判断儿子是否存在，不存在，便增加节点 tree[tree[k].l].sum=(mid-l&#43;1)*tree[k].lazy; tree[tree[k].r].sum=(r-mid)*tree[k].lazy; tree[tree[k].l].lazy=tree[k].lazy; tree[tree[k].r].lazy=tree[k].lazy; } tree[k].lazy=-1; } void update(int l,int r,int &amp;k,int L,int R,int p) { if (!k) { k=&#43;&#43;cnt;//遇到开过的点就不开，没开过开新的节点 tree[k]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/07be4e3c416cc6c22b47a40762f208ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-03T11:28:54+08:00" />
<meta property="article:modified_time" content="2020-04-03T11:28:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CodeForces - 915E 动态开点线段树</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://vjudge.net/problem/CodeForces-915E" rel="nofollow">题目链接</a></p> 
<p>大意：</p> 
<blockquote> 
 <p>晚上有n个亮着的灯泡，标号从1到n。</p> 
 <p>现在存在2种操作，如下：</p> 
 <ul><li>操作1，关掉标号 [l,r] 区间的灯</li><li>操作2，打开标号 [l,r] 区间的灯</li></ul> 
 <p>下面有q次询问，每次询问执行其中一种操作，询问格式，l，r，k。k为执行操作种类。对于每次询问回答当前开着的灯的数量。</p> 
</blockquote> 
<blockquote> 
 <p>第一行包含一个整数n，第二行一个整数q(1≤n≤10^9,1≤q≤3·10^5) </p> 
</blockquote> 
<p>因为n范围过大，如果用静态开点需要离散化，但是离散化之后就无法根据离散化后的点得到区间长度 ，还需要再开数据记录，有点麻烦，所以这题我们用动态开点，不需要的点不开辟空间就好。</p> 
<p>动态开点需要用l，r数组记录当前点的左右子节点，而不能再用rt&lt;&lt;1和rt&lt;&lt;1|1来表示了。</p> 
<p>用数组记录左右子节点，如果左右子节点还没有出现过，给它赋值为cnt++（cnt用于给所有出现的节点编号，这样出现了多少点，就开辟了多少空间）</p> 
<p>这题是区间更新，代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+10;
struct vain
{
    int l,r,sum,lazy;
} tree[maxn*50];
int cnt=1;
void pushdown(int l,int r,int k)
{
    int mid=(l+r)&gt;&gt;1;
    if (l!=r)
    {
        if (!tree[k].l)
            tree[k].l=++cnt;
        if (!tree[k].r)
            tree[k].r=++cnt;
        //下传判断儿子是否存在，不存在，便增加节点
        tree[tree[k].l].sum=(mid-l+1)*tree[k].lazy;
        tree[tree[k].r].sum=(r-mid)*tree[k].lazy;
        tree[tree[k].l].lazy=tree[k].lazy;
        tree[tree[k].r].lazy=tree[k].lazy;
    }
    tree[k].lazy=-1;
}

void update(int l,int r,int &amp;k,int L,int R,int p)
{
    if (!k)
    {
        k=++cnt;//遇到开过的点就不开，没开过开新的节点
        tree[k].lazy=-1;
    }
    if (l&gt;=L &amp;&amp; r&lt;=R)
    {
        tree[k].sum=p*(r-l+1);
        tree[k].lazy=p;
        return;
    }
    if (tree[k].lazy!=-1)
        pushdown(l,r,k);
    int mid=(l+r)&gt;&gt;1;
    if (mid&gt;=L)
        update(l,mid,tree[k].l,L,R,p);
    if (mid&lt;R)
        update(mid+1,r,tree[k].r,L,R,p);
    tree[k].sum=tree[tree[k].l].sum+tree[tree[k].r].sum;
}
int main()
{
    int n,q;
    scanf("%d %d",&amp;n,&amp;q);
    int k=1;
    for (int i=1; i&lt;=q; i++)
    {
        int l,r,p;
        scanf("%d %d %d",&amp;l,&amp;r,&amp;p);
        p=2-p;  //打开为0，关闭为1，因为初始化值为0，而所有的灯初始状态都是打开的
        update(1,n,k,l,r,p);
        printf("%d\n",n-tree[1].sum);
    }
}
</code></pre> 
<p>单点更新：</p> 
<p>不需要给左右子节点赋值，因为不需要下传</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define LOG 20
using namespace std;
const int maxn=100010;
struct node
{
    int l,r,sum;
}k[maxn*20];
int rt,ncnt,lc[maxn*LOG],rc[maxn*LOG],sum[maxn*LOG];
inline void pushup(int x)
{
    k[x].sum=k[k[x].l].sum+k[k[x].r].sum;//更新
}
inline void update(int &amp;x,int l,int r,int m,int val)
{
    if(!x)
        x=++ncnt;//开点
    if(l==r)
    {
        k[x].sum+=val;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if(m&lt;=mid)
        update(k[x].l,l,mid,m,val);
    else
        update(k[x].r,mid+1,r,m,val);
    pushup(x);
}
int ask(int x,int l,int r,int L,int R)
{
    if(!x)
        return 0;//没这个点，直接返回0
    if(L&lt;=l &amp;&amp; R&gt;=r)
        return k[x].sum;
    int val=0;
    int mid=(l+r)&gt;&gt;1;
    if(L&lt;=mid)
        val+=ask(k[x].l,l,mid,L,R);
    if(R&gt;mid)
        val+=ask(k[x].r,mid+1,r,L,R);//递归计算
    return val;
}
int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=1; i&lt;=n; i++)
    {
        int num;
        cin&gt;&gt;num;
        update(rt,1,n,i,num);
    }
    int q;
    cin&gt;&gt;q;
    while(q--)
    {
        int l,r;
        cin&gt;&gt;l&gt;&gt;r;
        cout&lt;&lt;ask(rt,1,n,l,r)&lt;&lt;endl;
    }
}
</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ebb6aca17817ef025aaf07f59d78a99e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis-Redis Mass Insertion</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1284d8dbbe914ac3fd723be2ace68f90/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">腾讯大佬告诉你python IDE 新手用什么比较合适</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>