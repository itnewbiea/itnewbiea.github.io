<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis(五)-缓存三大问题及解决方案 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis(五)-缓存三大问题及解决方案" />
<meta property="og:description" content="缓存的设计包含很多技巧，设计不当将会导致严重的后果。本文将介绍缓存使用中常见的三大问题，并给出相应的解决方案。
缓存穿透缓存雪崩缓存击穿 1. 缓存穿透 在大多数互联网应用中，缓存的使用方式如下图所示：
当业务系统发起某一个查询请求时，首先判断缓存中是否有该数据；如果缓存中存在，则直接返回数据；如果缓存中不存在，则再查询数据库，然后返回数据。 了解了上述过程后，下面说说缓存穿透。
1.1 什么是缓存穿透？ 业务系统要查询的数据根本就存在！当业务系统发起查询时，按照上述流程，首先会前往缓存中查询，由于缓存中不存在，然后再前往数据库中查询。由于该数据压根就不存在，因此数据库也返回空。这就是缓存穿透。
综上所述：业务系统访问压根就不存在的数据，就称为缓存穿透。
1.2 缓存穿透的危害 如果存在海量请求查询压根就不存在的数据，那么这些海量请求都会落到数据库中，数据库压力剧增，可能会导致系统崩溃（你要知道，目前业务系统中最脆弱的就是IO，稍微来点压力它就会崩溃，所以我们要想种种办法保护它）。
1.3 为什么会发生缓存穿透？ 发生缓存穿透的原因有很多，一般为如下两种：
恶意攻击，故意营造大量不存在的数据请求我们的服务，由于缓存中并不存在这些数据，因此海量请求均落在数据库中，从而可能会导致数据库崩溃。代码逻辑错误。这是程序员的锅，没啥好讲的，开发中一定要避免！ 1.4 缓存穿透的解决方案 下面来介绍两种防止缓存穿透的手段。
1.4.1 缓存空数据 之所以发生缓存穿透，是因为缓存中没有存储这些空数据的key，导致这些请求全都打到数据库上。
那么，我们可以稍微修改一下业务系统的代码，将数据库查询结果为空的key也存储在缓存中。当后续又出现该key的查询请求时，缓存直接返回null，而无需查询数据库。
缓存空对象会有两个问题： 第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。
1.4.2 BloomFilter 第二种避免缓存穿透的方式即为使用BloomFilter。
它需要在缓存之前再加一道屏障，里面存储目前数据库中存在的所有key，如下图所示：
当业务系统有查询请求的时候，首先去BloomFilter中查询该key是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。
这种方法适用于数据命中不高，数据相对固定实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。 1.4.3 两种方案的比较 这两种方案都能解决缓存穿透的问题，但使用场景却各不相同。
对于一些恶意攻击，查询的key往往各不相同，而且数据贼多。此时，第一种方案就显得提襟见肘了。因为它需要存储所有空数据的key，而这些恶意攻击的key往往各不相同，而且同一个key往往只请求一次。因此即使缓存了这些空数据的key，由于不再使用第二次，因此也起不了保护数据库的作用。
因此，对于空数据的key各不相同、key重复请求概率低的场景而言，应该选择第二种方案。而对于空数据的key数量有限、key重复请求概率较高的场景而言，应该选择第一种方案。
2. 缓存雪崩 2.1 什么是缓存雪崩？ 通过上文可知，缓存其实扮演了一个保护数据库的角色。它帮数据库抵挡大量的查询请求，从而避免脆弱的数据库受到伤害。
如果缓存因某种原因发生了宕机，那么原本被缓存抵挡的海量查询请求就会像疯狗一样涌向数据库。此时数据库如果抵挡不了这巨大的压力，它就会崩溃。
这就是缓存雪崩。
2.2 如何避免缓存雪崩？ 2.2.1 使用缓存集群，保证缓存高可用 和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 Redis Sentinel 和 Redis Cluster 都实现了高可用。 2.2.2 使用Hystrix Hystrix是一款开源的“防雪崩工具”，它通过 熔断、降级、限流三个手段来降低雪崩发生后的损失。
Hystrix就是一个Java类库，它采用命令模式，每一项服务处理请求都有各自的处理器。所有的请求都要经过各自的处理器。处理器会记录当前服务的请求失败率。一旦发现当前服务的请求失败率达到预设的值，Hystrix将会拒绝随后该服务的所有请求，直接返回一个预设的结果。这就是所谓的“熔断”。当经过一段时间后，Hystrix会放行该服务的一部分请求，再次统计它的请求失败率。如果此时请求失败率符合预设值，则完全打开限流开关；如果请求失败率仍然很高，那么继续拒绝该服务的所有请求。这就是所谓的“限流”。而Hystrix向那些被拒绝的请求直接返回一个预设结果，被称为“降级”。
3. 缓存击穿（热点数据集中失效） 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7e04aed88590e1cc87a403544d5adcc1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-21T21:12:54+08:00" />
<meta property="article:modified_time" content="2018-10-21T21:12:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis(五)-缓存三大问题及解决方案</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>缓存的设计包含很多技巧，设计不当将会导致严重的后果。本文将介绍缓存使用中常见的三大问题，并给出相应的解决方案。</p> 
<ul><li>缓存穿透</li><li id="articleHeader8">缓存雪崩</li><li>缓存击穿</li></ul> 
<h2 id="articleHeader0">1. 缓存穿透</h2> 
<p>在大多数互联网应用中，缓存的使用方式如下图所示：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/5b/47/EsHkYyhH_o.png"></p> 
<ol><li>当业务系统发起某一个查询请求时，首先判断缓存中是否有该数据；</li><li>如果缓存中存在，则直接返回数据；</li><li>如果缓存中不存在，则再查询数据库，然后返回数据。</li></ol> 
<p>了解了上述过程后，下面说说缓存穿透。</p> 
<h3 id="articleHeader1">1.1 什么是缓存穿透？</h3> 
<p>业务系统要查询的数据根本就存在！当业务系统发起查询时，按照上述流程，首先会前往缓存中查询，由于缓存中不存在，然后再前往数据库中查询。由于该数据压根就不存在，因此数据库也返回空。这就是缓存穿透。</p> 
<p>综上所述：业务系统访问压根就不存在的数据，就称为缓存穿透。</p> 
<h3 id="articleHeader2">1.2 缓存穿透的危害</h3> 
<p>如果存在海量请求查询压根就不存在的数据，那么这些海量请求都会落到数据库中，数据库压力剧增，可能会导致系统崩溃（你要知道，目前业务系统中最脆弱的就是IO，稍微来点压力它就会崩溃，所以我们要想种种办法保护它）。</p> 
<h3 id="articleHeader3">1.3 为什么会发生缓存穿透？</h3> 
<p>发生缓存穿透的原因有很多，一般为如下两种：</p> 
<ol><li>恶意攻击，故意营造大量不存在的数据请求我们的服务，由于缓存中并不存在这些数据，因此海量请求均落在数据库中，从而可能会导致数据库崩溃。</li><li>代码逻辑错误。这是程序员的锅，没啥好讲的，开发中一定要避免！</li></ol> 
<h3 id="articleHeader4">1.4 缓存穿透的解决方案</h3> 
<p>下面来介绍两种防止缓存穿透的手段。</p> 
<h4 id="articleHeader5">1.4.1 缓存空数据</h4> 
<p>之所以发生缓存穿透，是因为缓存中没有存储这些空数据的key，导致这些请求全都打到数据库上。</p> 
<p>那么，我们可以稍微修改一下业务系统的代码，将数据库查询结果为空的key也存储在缓存中。当后续又出现该key的查询请求时，缓存直接返回null，而无需查询数据库。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/b8/e1/aZdZXJXy_o.jpg"></p> 
<p>缓存空对象会有两个问题： <br> 第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。 <br> 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p> 
<h4 id="articleHeader6">1.4.2 BloomFilter</h4> 
<p>第二种避免缓存穿透的方式即为使用BloomFilter。</p> 
<p>它需要在缓存之前再加一道屏障，里面存储目前数据库中存在的所有key，如下图所示：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/b0/30/EuqrM9uQ_o.png"></p> 
<p>当业务系统有查询请求的时候，首先去BloomFilter中查询该key是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。</p> 
<p>这种方法适用于数据命中不高，数据相对固定实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。 </p> 
<h4 id="articleHeader7">1.4.3 两种方案的比较</h4> 
<p>这两种方案都能解决缓存穿透的问题，但使用场景却各不相同。</p> 
<p>对于一些恶意攻击，查询的key往往各不相同，而且数据贼多。此时，第一种方案就显得提襟见肘了。因为它需要存储所有空数据的key，而这些恶意攻击的key往往各不相同，而且同一个key往往只请求一次。因此即使缓存了这些空数据的key，由于不再使用第二次，因此也起不了保护数据库的作用。<br> 因此，对于<strong>空数据的key各不相同</strong>、<strong>key重复请求概率低</strong>的场景而言，应该选择第二种方案。而对于<strong>空数据的key数量有限</strong>、<strong>key重复请求概率较高</strong>的场景而言，应该选择第一种方案。</p> 
<h2>2. 缓存雪崩</h2> 
<h3 id="articleHeader9">2.1 什么是缓存雪崩？</h3> 
<p>通过上文可知，缓存其实扮演了一个保护数据库的角色。它帮数据库抵挡大量的查询请求，从而避免脆弱的数据库受到伤害。</p> 
<p>如果缓存因某种原因发生了宕机，那么原本被缓存抵挡的海量查询请求就会像疯狗一样涌向数据库。此时数据库如果抵挡不了这巨大的压力，它就会崩溃。</p> 
<p>这就是缓存雪崩。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/d1/12/hgWJi4FC_o.jpg"></p> 
<h3 id="articleHeader10">2.2 如何避免缓存雪崩？</h3> 
<h4 id="articleHeader11">2.2.1 使用缓存集群，保证缓存高可用</h4> 
<p>和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 Redis Sentinel 和 Redis Cluster 都实现了高可用。 </p> 
<h4 id="articleHeader12">2.2.2 使用Hystrix</h4> 
<p>Hystrix是一款开源的“防雪崩工具”，它通过 熔断、降级、限流三个手段来降低雪崩发生后的损失。</p> 
<p>Hystrix就是一个Java类库，它采用命令模式，每一项服务处理请求都有各自的处理器。所有的请求都要经过各自的处理器。处理器会记录当前服务的请求失败率。一旦发现当前服务的请求失败率达到预设的值，Hystrix将会拒绝随后该服务的所有请求，直接返回一个预设的结果。这就是所谓的<strong>“熔断”</strong>。当经过一段时间后，Hystrix会放行该服务的一部分请求，再次统计它的请求失败率。如果此时请求失败率符合预设值，则完全打开限流开关；如果请求失败率仍然很高，那么继续拒绝该服务的所有请求。这就是所谓的<strong>“限流”</strong>。而Hystrix向那些被拒绝的请求直接返回一个预设结果，被称为<strong>“降级”</strong>。</p> 
<h2 id="articleHeader13">3. 缓存击穿（热点数据集中失效）</h2> 
<h3 id="articleHeader14">3.1 什么是热点数据集中失效？</h3> 
<p>我们一般都会给缓存设定一个失效时间，过了失效时间后，该数据库会被缓存直接删除，从而一定程度上保证数据的实时性。</p> 
<p>但是，对于一些请求量极高的热点数据而言，一旦过了有效时间，此刻将会有大量请求落在数据库上，从而可能会导致数据库崩溃。其过程如下图所示：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/88/59/EDiHOfHz_o.jpg"></p> 
<p>如果某一个热点数据失效，那么当再次有该数据的查询请求[req-1]时就会前往数据库查询。但是，从请求发往数据库，到该数据更新到缓存中的这段时间中，由于缓存中仍然没有该数据，因此这段时间内到达的查询请求都会落到数据库上，这将会对数据库造成巨大的压力。此外，当这些请求查询完成后，都会重复更新缓存。</p> 
<h3 id="articleHeader15">3.2 解决方案</h3> 
<h4 id="articleHeader16">3.2.1 互斥锁</h4> 
<p>此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可，整个过程如图 : </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ba/ae/AbQudYTk_o.jpg"></p> 
<p>当第一个数据库查询请求发起后，就将缓存中该数据上锁；此时到达缓存的其他查询请求将无法查询该字段，从而被阻塞等待；当第一个请求完成数据库查询，并将数据更新值缓存后，释放锁；此时其他被阻塞的查询请求将可以直接从缓存中查到该数据。</p> 
<p>当某一个热点数据失效后，只有第一个数据库查询请求发往数据库，其余所有的查询请求均被阻塞，从而保护了数据库。但是，由于采用了互斥锁，其他请求将会阻塞等待，此时系统的吞吐量将会下降。这需要结合实际的业务考虑是否允许这么做。</p> 
<p>互斥锁可以避免<strong>某一个</strong>热点数据失效导致数据库崩溃的问题，而在实际业务中，往往会存在一批热点数据同时失效的场景。那么，对于这种场景该如何防止数据库过载呢？</p> 
<p>设置不同的失效时间</p> 
<p>当我们向缓存中存储这些数据的时候，可以将他们的缓存失效时间错开。这样能够避免同时失效。如：在一个基础时间上加/减一个随机数，从而将这些缓存的失效时间错开</p> 
<h4 id="articleHeader17">3.3.2 永远不过期</h4> 
<p>“永远不过期”包含两层意思： <br> 从缓存层面来看，确实没有设置过期时间，所以不会出现热点 key 过期后产生的问题，也就是“物理”不过期。 <br> 从功能层面来看，为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。 <br> 整个过程如下图所示： </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/17/51/hvowcPoi_o.jpg"></p> 
<p> 从实战看，此方法有效杜绝了热点 key 产生的问题，但唯一不足的就是重构缓存期间，会出现数据不一致的情况，这取决于应用方是否容忍这种不一致。</p> 
<h4>3.3.3 两种方案的比较</h4> 
<ul><li>互斥锁 (mutex key)：这种方案思路比较简单，但是存在一定的隐患，如果构建缓存过程出现问题或者时间较长，可能会存在死锁和线程池阻塞的风险，但是这种方法能够较好的降低后端存储负载并在一致性上做的比较好。</li><li>” 永远不过期 “：这种方案由于没有设置真正的过期时间，实际上已经不存在热点 key 产生的一系列危害，但是会存在数据不一致的情况，同时代码复杂度会增大。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/082b15bd9b45a713c9698c12df273c84/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常见链表操作-两个有序表的合并（JAVA实现）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f499dd71038c0b74c570f89d560b61d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android屏幕分辨率适配</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>