<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[215]BloomFilter布隆过滤器 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[215]BloomFilter布隆过滤器" />
<meta property="og:description" content="文章目录 Bloom Filter概念和原理HashMap 的问题布隆过滤器数据结构集合表示和元素查询错误率估计最优的哈希函数个数位数组的大小小结 BloomFilter实例对比、参数选择、代码实现实例对比Bloom Filter的算法Bloom Filter参数选择Bloom Filter实现代码 实际应用场景公式推导 Bloom Filter概念和原理 Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。
HashMap 的问题 讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。
还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。
布隆过滤器数据结构 布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：
如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成**多个哈希值，**并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：
Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：
值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/10e14b338d14383feb7780c450fd6e4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-23T14:36:43+08:00" />
<meta property="article:modified_time" content="2023-12-23T14:36:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[215]BloomFilter布隆过滤器</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Bloom_Filter_4" rel="nofollow">Bloom Filter概念和原理</a></li><li><ul><li><a href="#HashMap__8" rel="nofollow">HashMap 的问题</a></li><li><a href="#_14" rel="nofollow">布隆过滤器数据结构</a></li><li><a href="#_31" rel="nofollow">集合表示和元素查询</a></li><li><a href="#_42" rel="nofollow">错误率估计</a></li><li><a href="#_59" rel="nofollow">最优的哈希函数个数</a></li><li><a href="#_73" rel="nofollow">位数组的大小</a></li><li><a href="#_99" rel="nofollow">小结</a></li></ul> 
   </li><li><a href="#BloomFilter_107" rel="nofollow">BloomFilter实例对比、参数选择、代码实现</a></li><li><ul><li><a href="#_109" rel="nofollow">实例对比</a></li><li><a href="#Bloom_Filter_134" rel="nofollow">Bloom Filter的算法</a></li><li><a href="#Bloom_Filter_164" rel="nofollow">Bloom Filter参数选择</a></li><li><a href="#Bloom_Filter_174" rel="nofollow">Bloom Filter实现代码</a></li></ul> 
   </li><li><a href="#_252" rel="nofollow">实际应用场景</a></li><li><ul><li><a href="#_291" rel="nofollow">公式推导</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Bloom_Filter_4"></a>Bloom Filter概念和原理</h3> 
<p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p> 
<h4><a id="HashMap__8"></a>HashMap 的问题</h4> 
<p>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p> 
<p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p> 
<h4><a id="_14"></a>布隆过滤器数据结构</h4> 
<p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：<br> <img src="https://images2.imgbox.com/6a/89/FfL1oXw1_o.png" alt=""></p> 
<p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成**多个哈希值，**并对每个生成的哈希值指向的 bit 位置 1，例如针对值 <code>“baidu” </code>和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：<br> <img src="https://images2.imgbox.com/cd/a1/Q9QoCJp1_o.png" alt=""></p> 
<p>Ok，我们现在再存一个值 <code>“tencent”</code>，如果哈希函数返回 3、4、8 的话，图继续变为：<br> <img src="https://images2.imgbox.com/76/f8/IrWci2pQ_o.png" alt=""></p> 
<p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 <code>“dianping”</code> 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在</strong>。</p> 
<p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p> 
<h4><a id="_31"></a>集合表示和元素查询</h4> 
<p>下面我们具体来看Bloom Filter是如何用位数组表示集合的。初始状态时，Bloom Filter是一个包含m位的位数组，每一位都置为0。<br> <img src="https://images2.imgbox.com/45/1d/ReppsyTp_o.png" alt=""></p> 
<p>为了表达S={x<sub>1</sub>, x<sub>2</sub>,…,x<sub>n</sub>}这样一个n个元素的集合，Bloom Filter使用k个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素x，第i个哈希函数映射的位置h<sub>i</sub>(x)就会被置为1（1≤i≤k）。注意，如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，k=3，且有两个哈希函数选中同一个位置（从左边数第五位）。<br> <img src="https://images2.imgbox.com/92/39/FsNSzoRr_o.png" alt=""></p> 
<p>在判断y是否属于这个集合时，我们对y应用k次哈希函数，如果所有h<sub>i</sub>(y)的位置都是1（1≤i≤k），那么我们就认为y是集合中的元素，否则就认为y不是集合中的元素。下图中y<sub>1</sub>就不是集合中的元素。y<sub>2</sub>或者属于这个集合，或者刚好是一个false positive。<br> <img src="https://images2.imgbox.com/e6/34/40rs7Qxp_o.png" alt=""></p> 
<h4><a id="_42"></a>错误率估计</h4> 
<p>前面我们已经提到了，Bloom Filter在判断一个元素是否属于它表示的集合时会有一定的错误率（false positive rate），下面我们就来估计错误率的大小。在估计之前为了简化模型，我们假设kn&lt;m且各个哈希函数是完全随机的。当集合S={x<sub>1</sub>, x<sub>2</sub>,…,x<sub>n</sub>}的所有元素都被k个哈希函数映射到m位的位数组中时，这个位数组中某一位还是0的概率是：<br> <img src="https://images2.imgbox.com/25/f8/xIJOhNA9_o.png" alt=""></p> 
<p>其中1/m表示任意一个哈希函数选中这一位的概率（前提是哈希函数是完全随机的），(1-1/m)表示哈希一次没有选中这一位的概率。要把S完全映射到位数组中，需要做kn次哈希。某一位还是0意味着kn次哈希都没有选中它，因此这个概率就是（1-1/m）的kn次方。令p = e<sup>-kn/m</sup>是为了简化运算，这里用到了计算e时常用的近似：<br> <img src="https://images2.imgbox.com/7c/ba/NM2T4pDv_o.png" alt=""></p> 
<p>令ρ为位数组中0的比例，则ρ的数学期望E(ρ)= p’。在ρ已知的情况下，要求的错误率（false positive rate）为：<br> <img src="https://images2.imgbox.com/a9/f5/47HNbSrf_o.png" alt=""></p> 
<p>(1-ρ)为位数组中1的比例，(1-ρ)<sup>k</sup>就表示k次哈希都刚好选中1的区域，即false positive rate。上式中第二步近似在前面已经提到了，现在来看第一步近似。p’只是ρ的数学期望，在实际中ρ的值有可能偏离它的数学期望值。M. Mitzenmacher已经证明<sup>[2]</sup> ，位数组中0的比例非常集中地分布在它的数学期望值的附近。因此，第一步的近似得以成立。分别将p和p’代入上式中，得：<br> <img src="https://images2.imgbox.com/ba/a7/0D88tRK4_o.png" alt=""><br> <img src="https://images2.imgbox.com/00/53/li1SqzSq_o.png" alt=""></p> 
<p>相比<code>p’和f’</code>，使用p和f通常在分析中更为方便。</p> 
<h4><a id="_59"></a>最优的哈希函数个数</h4> 
<p>既然Bloom Filter要靠多个哈希函数将集合映射到位数组中，那么应该选择几个哈希函数才能使元素查询时的错误率降到最低呢？这里有两个互斥的理由：如果哈希函数的个数多，那么在对一个不属于集合的元素进行查询时得到0的概率就大；但另一方面，如果哈希函数的个数少，那么位数组中的0就多。为了得到最优的哈希函数个数，我们需要根据上一小节中的错误率公式进行计算。</p> 
<p>先用p和f进行计算。注意到f = exp(k ln(1 − e<sup>−kn/m</sup>))，我们令g = k ln(1 − e<sup>−kn/m</sup>)，只要让g取到最小，f自然也取到最小。由于p = e<sup>-kn/m</sup>，我们可以将g写成<br> <img src="https://images2.imgbox.com/87/fd/ld2G4Hr8_o.png" alt=""></p> 
<p>根据对称性法则可以很容易看出当p = 1/2，也就是k = ln2· (m/n)时，g取得最小值。在这种情况下，最小错误率f等于(1/2)<sup>k </sup>≈ (0.6185)<sup>m/n</sup>。另外，注意到p是位数组中某一位仍是0的概率，所以p = 1/2对应着位数组中0和1各一半。换句话说，要想保持错误率低，最好让位数组有一半还空着。</p> 
<p>需要强调的一点是，p = 1/2时错误率最小这个结果并不依赖于近似值p和f。同样对于f’ = exp(k ln(1 − (1 − 1/m)<sup>kn</sup>))，g’ = k ln(1 − (1 − 1/m)<sup>kn</sup>)，p’ = (1 − 1/m)<sup>kn</sup>，我们可以将g’写成<br> <img src="https://images2.imgbox.com/e2/55/wF3zgEOI_o.png" alt=""></p> 
<p>同样根据对称性法则可以得到当p’ = 1/2时，g’取得最小值。</p> 
<h4><a id="_73"></a>位数组的大小</h4> 
<p>下面我们来看看，在不超过一定错误率的情况下，Bloom Filter至少需要多少位才能表示全集中任意n个元素的集合。假设全集中共有u个元素，允许的最大错误率为є，下面我们来求位数组的位数m。</p> 
<p>假设X为全集中任取n个元素的集合，F(X)是表示X的位数组。那么对于集合X中任意一个元素x，在s = F(X)中查询x都能得到肯定的结果，即s能够接受x。显然，由于Bloom Filter引入了错误，s能够接受的不仅仅是X中的元素，它还能够є (u - n)个false positive。因此，对于一个确定的位数组来说，它能够接受总共n + є (u - n)个元素。在n + є (u - n)个元素中，s真正表示的只有其中n个，所以一个确定的位数组可以表示<br> <img src="https://images2.imgbox.com/7b/da/tQU9dnFy_o.png" alt=""></p> 
<p>个集合。m位的位数组共有2<sup>m</sup>个不同的组合，进而可以推出，m位的位数组可以表示<br> <img src="https://images2.imgbox.com/ca/f8/1u0kkk43_o.png" alt=""></p> 
<p>个集合。全集中n个元素的集合总共有<br> <img src="https://images2.imgbox.com/0a/41/EKKFWkvr_o.png" alt=""></p> 
<p>个，因此要让m位的位数组能够表示所有n个元素的集合，必须有<br> <img src="https://images2.imgbox.com/59/40/A7dwsTq5_o.png" alt=""></p> 
<p>即：<br> <img src="https://images2.imgbox.com/40/16/rGzz9a7W_o.png" alt=""></p> 
<p>上式中的近似前提是n和єu相比很小，这也是实际情况中常常发生的。根据上式，我们得出结论：在错误率不大于є的情况下，m至少要等于n log<sub>2</sub>(1/є)才能表示任意n个元素的集合。</p> 
<p>上一小节中我们曾算出当k = ln2· (m/n)时错误率f最小，这时f = (1/2)<sup>k </sup>= (1/2)<sup>mln2 / n</sup>。现在令f≤є，可以推出<br> <img src="https://images2.imgbox.com/1c/b9/ODQ3BRAb_o.png" alt=""></p> 
<p>这个结果比前面我们算得的下界n log<sub>2</sub>(1/є)大了log<sub>2 </sub>e ≈ 1.44倍。这说明在哈希函数的个数取到最优时，要让错误率不超过є，m至少需要取到最小值的1.44倍。</p> 
<h4><a id="_99"></a>小结</h4> 
<p>在计算机科学中，我们常常会碰到时间换空间或者空间换时间的情况，即为了达到某一个方面的最优而牺牲另一个方面。Bloom Filter在时间空间这两个因素之外又引入了另一个因素：错误率。在使用Bloom Filter判断一个元素是否属于某个集合时，会有一定的错误率。也就是说，有可能把不属于这个集合的元素误认为属于这个集合（False Positive），但不会把属于这个集合的元素误认为不属于这个集合（False Negative）。在增加了错误率这个因素之后，Bloom Filter通过允许少量的错误来节省大量的存储空间。</p> 
<p>自从Burton Bloom在70年代提出Bloom Filter之后，Bloom Filter就被广泛用于拼写检查和数据库系统中。近一二十年，伴随着网络的普及和发展，Bloom Filter在网络领域获得了新生，各种Bloom Filter变种和新的应用不断出现。可以预见，随着网络应用的不断深入，新的变种和应用将会继续出现，Bloom Filter必将获得更大的发展。</p> 
<hr> 
<h3><a id="BloomFilter_107"></a>BloomFilter实例对比、参数选择、代码实现</h3> 
<h4><a id="_109"></a>实例对比</h4> 
<p>为了说明Bloom Filter存在的重要意义，举一个实例：</p> 
<p>假设要你写一个网络蜘蛛（web crawler）。由于网络间的链接错综复杂，蜘蛛在网络间爬行很可能会形成“环”。为了避免形成“环”，就需要知道蜘蛛已经访问过那些URL。给一个URL，怎样知道蜘蛛是否已经访问过呢？稍微想想，就会有如下几种方案：</p> 
<blockquote> 
 <p>1. 将访问过的URL保存到数据库。<br> 2. 用HashSet将访问过的URL保存起来。那只需接近O(1)的代价就可以查到一个URL是否被访问过了。<br> 3. URL经过MD5或SHA-1等单向哈希后再保存到HashSet或数据库。<br> 4. Bit-Map方法。建立一个BitSet，将每个URL经过一个哈希函数映射到某一位。</p> 
</blockquote> 
<p>方法1~3都是将访问过的URL完整保存，方法4则只标记URL的一个映射位。</p> 
<p>以上方法在数据量较小的情况下都能完美解决问题，但是当数据量变得非常庞大时问题就来了。</p> 
<blockquote> 
 <p>方法1的缺点：数据量变得非常庞大后关系型数据库查询的效率会变得很低。而且每来一个URL就启动一次数据库查询是不是太小题大做了？</p> 
 <p>方法2的缺点：太消耗内存。随着URL的增多，占用的内存会越来越多。就算只有1亿个URL，每个URL只算50个字符，就需要5GB内存。</p> 
 <p>方法3：由于字符串经过MD5处理后的信息摘要长度只有128Bit，SHA-1处理后也只有160Bit，因此方法3比方法2节省了好几倍的内存。</p> 
 <p>方法4：消耗内存是相对较少的，但缺点是单一哈希函数发生冲突的概率太高。还记得数据结构课上学过的Hash表冲突的各种解决方法么？若要降低冲突发生的概率到1%，就要将BitSet的长度设置为URL个数的100倍。</p> 
</blockquote> 
<p>实质上上面的算法都忽略了一个重要的隐含条件：允许小概率的出错，不一定要100%准确！也就是说少量url实际上没有没网络蜘蛛访问，而将它们错判为已访问的代价是很小的——大不了少抓几个网页呗。</p> 
<h4><a id="Bloom_Filter_134"></a>Bloom Filter的算法</h4> 
<p>废话说到这里，下面引入本篇的主角——Bloom Filter。其实上面方法4的思想已经很接近Bloom Filter了。方法四的致命缺点是冲突概率高，为了降低冲突的概念，Bloom Filter使用了多个哈希函数，而不是一个。</p> 
<p><strong>Bloom Filter算法如下：</strong><br> 创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为h（i，str），且h（i，str）的范围是0到m-1 。</p> 
<p><strong>(1) 加入字符串过程</strong></p> 
<p>下面是每个字符串处理的过程，首先是将字符串str“记录”到BitSet中的过程：</p> 
<p>对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后将BitSet的第h（1，str）、h（2，str）…… h（k，str）位设为1。<br> <img src="https://images2.imgbox.com/61/cf/0XAWAZ1Y_o.png" alt=""></p> 
<p>很简单吧？这样就将字符串str映射到BitSet中的k个二进制位了。</p> 
<p><strong>(2)检查字符串是否存在的过程</strong><br> 下面是检查字符串str是否被BitSet记录过的过程：</p> 
<p>对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后检查BitSet的第h（1，str）、h（2，str）…… h（k，str）位是否为1，若其中任何一位不为1则可以判定str一定没有被记录过。若全部位都是1，则“认为”字符串str存在。</p> 
<p>若一个字符串对应的Bit不全为1，则可以肯定该字符串一定没有被Bloom Filter记录过。（这是显然的，因为字符串被记录过，其对应的二进制位肯定全部被设为1了）</p> 
<p>但是若一个字符串对应的Bit全为1，实际上是不能100%的肯定该字符串被Bloom Filter记录过的。（因为有可能该字符串的所有位都刚好是被其他字符串所对应）这种将该字符串划分错的情况，称为false positive 。</p> 
<p><strong>(3)删除字符串过程</strong><br> 字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</p> 
<p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p> 
<h4><a id="Bloom_Filter_164"></a>Bloom Filter参数选择</h4> 
<p><strong>(1)哈希函数选择</strong><br> 哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。</p> 
<p><strong>(2)Bit数组大小选择</strong><br> 哈希函数个数k、位数组大小m、加入的字符串数量n的关系可以参考<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html" rel="nofollow">参考文献1</a>。该文献证明了对于给定的m、n，当 k = ln(2)* m/n 时出错的概率是最小的。</p> 
<p>同时该文献还给出特定的k，m，n的出错概率。例如：根据参考文献1，哈希函数个数k取10，位数组大小m设为字符串个数n的20倍时，false positive发生的概率是0.0000889 ，这个概率基本能满足网络爬虫的需求了。</p> 
<h4><a id="Bloom_Filter_174"></a>Bloom Filter实现代码</h4> 
<p>下面给出一个简单的Bloom Filter的Java实现代码：</p> 
<pre><code>import java.util.BitSet;

publicclass BloomFilter 
{
/* BitSet初始分配2^24个bit */ 
privatestaticfinalint DEFAULT_SIZE =1&lt;&lt;25; 
/* 不同哈希函数的种子，一般应取质数 */
privatestaticfinalint[] seeds =newint[] { 5, 7, 11, 13, 31, 37, 61 };
private BitSet bits =new BitSet(DEFAULT_SIZE);
/* 哈希函数对象 */ 
private SimpleHash[] func =new SimpleHash[seeds.length];

public BloomFilter() 
{
for (int i =0; i &lt; seeds.length; i++)
{
func[i] =new SimpleHash(DEFAULT_SIZE, seeds[i]);
}
}

// 将字符串标记到bits中
publicvoid add(String value) 
{
for (SimpleHash f : func) 
{
bits.set(f.hash(value), true);
}
}

//判断字符串是否已经被bits标记
publicboolean contains(String value) 
{
if (value ==null) 
{
returnfalse;
}
boolean ret =true;
for (SimpleHash f : func) 
{
ret = ret &amp;&amp; bits.get(f.hash(value));
}
return ret;
}

/* 哈希函数类 */
publicstaticclass SimpleHash 
{
privateint cap;
privateint seed;

public SimpleHash(int cap, int seed) 
{
this.cap = cap;
this.seed = seed;
}

//hash函数，采用简单的加权和hash
publicint hash(String value) 
{
int result =0;
int len = value.length();
for (int i =0; i &lt; len; i++) 
{
result = seed * result + value.charAt(i);
}
return (cap -1) &amp; result;
}
}
}
</code></pre> 
<hr> 
<h3><a id="_252"></a>实际应用场景</h3> 
<p><code>背景</code> 现在有个100亿个黑名单网页数据，每个网页的URL占用64字节。现在想要实现一种网页过滤系统，可以根据网页的URL判断该网站是否在黑名单上，请设计该系统。</p> 
<p><code>需求</code>可以允许有0.01%以下的判断失误率，并且使用的总空间不要超过200G。</p> 
<p>这里一共有4个常量：<code>100亿条黑名单数据，每条数据占64个字节,万分之一的失误率，总空间不要超过200G。</code></p> 
<p>如果不考虑不拢过滤器，那么这里存储100亿条数据就需要 100亿 * 64字节 = 596G 显然超过300G</p> 
<p><code>解题</code> 在满足有 <strong>100亿条数据</strong> 并且允许 <strong>万分之一的失误率</strong> 的布隆过滤器需要多大的bit数组呢？</p> 
<ul><li>设bit数组大小为m，样本数量为n，失误率为p。</li><li>由题可知 n = 100亿，p = 0.01%</li></ul> 
<blockquote> 
 <p>布隆过滤器的大小m公式<br> <img src="https://images2.imgbox.com/da/e4/tj458w0l_o.png" alt=""></p> 
</blockquote> 
<p>求得 m = 19.19n，向上取整为 20n。所以2000亿bit，约为186G。</p> 
<p>算完m，我们顺便来算下m，n已知，这时满足最小误差的k是几个。</p> 
<blockquote> 
 <p>哈希函数的个数k公式<br> <img src="https://images2.imgbox.com/e0/7b/ICNDP1m3_o.png" alt=""></p> 
</blockquote> 
<p>求得 k = 14，即需要14个哈希函数。</p> 
<p>通过通过 m = 20n， k = 14我们再来算下真实的失误率。</p> 
<blockquote> 
 <p>布隆过滤器真实失误率p公式<br> <img src="https://images2.imgbox.com/c3/71/Fwxdbbfa_o.png" alt=""></p> 
</blockquote> 
<p>求得 p = 0.006%，即布隆过滤器的真实失误率为0.006%。</p> 
<p>通过布隆过滤器公式也可以看出：<code>单个数据的大小不影响布隆过滤器大小，因为样本会通过哈希函数得到输出值。</code></p> 
<p>就好比上面的 <strong>每个网页的URL占用64字节</strong> 这个数据大小 跟布隆过滤器大小没啥关系。</p> 
<p>这三个公式就是有关布隆过滤器已经推倒出的公式，下面我们来推下这个公式是如何推导出来的。</p> 
<h4><a id="_291"></a>公式推导</h4> 
<p>讲公式，应该先知道几个关键的常量。</p> 
<blockquote> 
 <p>误判率p<code>、</code>布隆过滤器长度m<code>、</code>元素个数n<code>、</code>哈希函数个数k</p> 
</blockquote> 
<p>我们再来一步一步由简单到难推导公式。</p> 
<p><strong>1、误差率公式推导</strong><br> <code>前提条件</code>：就是假设每个元素哈希得到的值分布到m数组上的每一个数组节点的概率是相等的。</p> 
<p><strong>1) 假设布隆过滤器长度为m,元素个数n为1,哈希函数个数k也为1。那么在插入时某一数组节点没有被置为1的概率。</strong><br> <img src="https://images2.imgbox.com/9d/a6/mcq9bXGv_o.png" alt=""><br> 这个应该很好理解。</p> 
<p><strong>2）如果上面其它不变，而哈希函数个数变成k个，那么在插入时某一数组节点没有被置为1的概率。</strong><br> <img src="https://images2.imgbox.com/fe/8d/YUqueCO4_o.png" alt=""><br> 好理解！</p> 
<p><strong>3）如果元素个数变成n个，而哈希函数个数变成k个，那么在插入时某一数组节点没有被置为1的概率。</strong><br> <img src="https://images2.imgbox.com/f1/2d/quLMf8J2_o.png" alt=""></p> 
<p><strong>4）从上面推导出的是: 当布隆过滤器长度为m，元素个数变成n个，哈希函数个数变成k个的时候，某一节点被置为1的概率为</strong><br> <img src="https://images2.imgbox.com/8a/22/rG8ZgkrL_o.png" alt=""></p> 
<p>到这里应该也好理解，第三步是该位置从未被置为1，那么1去减去它就是至少有一次被置为1,那么只要存在一次被置1，那么该位置的bit标示就是1，因为布隆过滤器是不能删除的。</p> 
<p><strong>5）这个还需要考虑到，一个元素通过hash会生成多个k，放入m数组中,所以需要这k个值都为1才会认为该该元素已经存在。所以是这样的。</strong><br> <img src="https://images2.imgbox.com/19/8b/Lw4BeZ2y_o.png" alt=""></p> 
<p>上面这个公式推导在转换下就成了<br> <img src="https://images2.imgbox.com/d0/a0/fjm36DBm_o.png" alt=""></p> 
<p><code>思考</code> <strong>为什么上面这个公式的值就是最终的误差率?</strong></p> 
<p>因为当一个布隆过滤器中不存在的元素进来的是的时候，首先通过hash算法产生k个哈希值，分布在m数组上都为1的的概率不就是上面推导出的这个公式吗，那不就是误差吗?</p> 
<p>因为明明是不存在的值，却有这个概率表明已经存在。</p> 
<p><code>思考</code> <strong>给定的m和n,思考k值为多少误差会最小。</strong></p> 
<p>为什么k值的大小不合理会影响误差呢？</p> 
<p>我们来思考下，一个元素最终生成k个hash值，那么会在数组m上的k个位置标记为1。</p> 
<p><strong>假设k为1，那么每次进来只在m上的某一个位置标记为1，这样的话如果一个新元素进来刚好hash值也在这里，而不用其它位置来判断是否为1，这个误差就会比较大。</strong></p> 
<p><strong>假设k为m，那么第一个元素进来，在m上所有位置上都表为1了 ，以后只要进来一个元素就会标记为已存在。这个误差也太大了。</strong></p> 
<p>上面只是举了两个极端的例子，但也说明k值太大、太小都不好，它的最优值一定跟m、n存在某种关系。</p> 
<p>它们之间的关系只要记住下面这个公式就可以了。<br> <img src="https://images2.imgbox.com/14/ed/nIImXuZM_o.png" alt=""></p> 
<p>参考：http://blog.csdn.net/jiaomeng/article/details/1495500<br> https://blog.csdn.net/weixin_44777669/article/details/109300197<br> http://www.cnblogs.com/heaad/archive/2011/01/02/1924195.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ec0c3c29e30973ecd3046b27e7d32cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于“Python”的核心知识点整理大全37</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/560f17cd3354dc5a604fea96dba0f305/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">3步实现用Python防止微信消息撤回功能！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>