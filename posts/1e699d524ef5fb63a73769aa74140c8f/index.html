<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LLD-LLVM链接器 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LLD-LLVM链接器" />
<meta property="og:description" content="LLD-LLVM链接器
LLD是LLVM项目中的链接器，是系统链接器的直接替代，并且运行速度比它们快得多。它还提供了对工具链开发人员有用的功能。
链接器按完整性降序支持ELF（Unix），PE / COFF（Windows），Mach-O（macOS）和WebAssembly。在内部，LLD由几个不同的链接器组成。ELF端口是本文档中将要描述的端口。PE / COFF端口已完成，包括Windows调试信息（PDB）支持。WebAssembly端口仍在开发中（请参阅WebAssembly lld port）。Mach-O端口是基于与其他端口不同的体系结构构建的。有关Mach-O的详细信息，请阅读ATOM-based lld。
特征功能
• LLD是GNU链接器的直接替代，它接受与GNU相同的命令行参数和链接器脚本。
目前正在与FreeBSD项目紧密合作，以使LLD在操作系统的未来版本中成为默认系统链接器，因此非常重视解决兼容性问题。LLD能够链接包括内核在内的整个FreeBSD / amd64基本系统。使用一些正在进行的补丁程序，它可以链接AMD64上大约95％的端口集合。有关详细信息，请参见FreeBSD quarterly status report。
• LLD非常快。在多核计算机上链接大型程序时，可以预期LLD的运行速度是GNU gold链接器的两倍以上。但是，里程可能会有所不同。
• 它支持各种CPU / ABI，包括AArch64，AMDGPU，ARM，Hexagon，MIPS 32/64大/小端，PowerPC，PowerPC64，RISC-V，SPARC V9，x86-32和x86-64。其中，AArch64，ARM（&gt; = v6），PowerPC，PowerPC64，x86-32和x86-64具有生产质量。MIPS似乎也不错。
• 它始终是交叉链接器，这意味着无论它是如何构建的，它始终支持上述所有目标。实际上，没有提供构建时选项来启用/禁用每个目标。链接器轻松用作交叉编译工具链的一部分很容易。
• 可以将LLD嵌入程序中，以消除对外部链接程序的依赖。要做的就是构造目标文件和命令行参数，就像调用外部链接器然后lld::elf::link从代码中调用链接器的主要功能一样 。
• 正在使用LLVM libObject库从目标文件读取数据，因此这并不是一个完全公平的比较，LLD / ELF仅包含2万1千行C &#43;&#43;代码，而GNU gold由19.8万行C &#43;&#43;代码构成。
• 默认情况下支持链接时间优化（LTO）。本质上，要做LTO所需要做的就是将-flto选项传递给clang。然后clang创建的对象文件不是本机目标文件格式，而是LLVM位码格式。LLD读取位码目标文件，使用LLVM对其进行编译并发出输出文件。因为以这种方式LLD可以看到整个程序，所以它可以对整个程序进行优化。
• 古老的Unix系统（90年代以前甚至更早）的一些非常古老的功能已被删除。一些默认设置已进行了调整。例如，默认情况下，将堆栈标记为不可执行以加强安全性。
性能
这是在2插槽20核40线程Xeon E5-2680 2.80 GHz带有SSD驱动器的计算机上的链接时间比较。在有或没有多线程支持的情况下都发挥了作用。为了禁用多线程，添加-no-threads了命令行。
如表所见，lld的速度明显快于GNU链接器。请注意，这只是环境的基准结果。根据可用核心数，可用内存量或磁盘延迟/吞吐量，结果可能会有所不同。
由于GNU ld不支持-icf=all and -gdb-index选项，因此从GNU ld的命令行中删除了。如果拥有这些选项，GNU ld将会比这慢。
构建
如果已经使用SVN检出了LLVM，则可以在tools中像clang一样检出目录下的LLD 。有关详细信息，请参阅Getting Started with the LLVM System。
如果尚未签出LLVM，构建LLD的最简单方法是，从git镜像签出整个LLVM项目/子项目并构建该树。需要cmake，当然也需要C &#43;&#43;编译器。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1e699d524ef5fb63a73769aa74140c8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-26T12:16:39+08:00" />
<meta property="article:modified_time" content="2020-12-26T12:16:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LLD-LLVM链接器</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>LLD-LLVM链接器<br> LLD是LLVM项目中的链接器，是系统链接器的直接替代，并且运行速度比它们快得多。它还提供了对工具链开发人员有用的功能。<br> 链接器按完整性降序支持ELF（Unix），PE / COFF（Windows），Mach-O（macOS）和WebAssembly。在内部，LLD由几个不同的链接器组成。ELF端口是本文档中将要描述的端口。PE / COFF端口已完成，包括Windows调试信息（PDB）支持。WebAssembly端口仍在开发中（请参阅WebAssembly lld port）。Mach-O端口是基于与其他端口不同的体系结构构建的。有关Mach-O的详细信息，请阅读ATOM-based lld。<br> 特征功能<br> • LLD是GNU链接器的直接替代，它接受与GNU相同的命令行参数和链接器脚本。<br> 目前正在与FreeBSD项目紧密合作，以使LLD在操作系统的未来版本中成为默认系统链接器，因此非常重视解决兼容性问题。LLD能够链接包括内核在内的整个FreeBSD / amd64基本系统。使用一些正在进行的补丁程序，它可以链接AMD64上大约95％的端口集合。有关详细信息，请参见FreeBSD quarterly status report。<br> • LLD非常快。在多核计算机上链接大型程序时，可以预期LLD的运行速度是GNU gold链接器的两倍以上。但是，里程可能会有所不同。<br> • 它支持各种CPU / ABI，包括AArch64，AMDGPU，ARM，Hexagon，MIPS 32/64大/小端，PowerPC，PowerPC64，RISC-V，SPARC V9，x86-32和x86-64。其中，AArch64，ARM（&gt; = v6），PowerPC，PowerPC64，x86-32和x86-64具有生产质量。MIPS似乎也不错。<br> • 它始终是交叉链接器，这意味着无论它是如何构建的，它始终支持上述所有目标。实际上，没有提供构建时选项来启用/禁用每个目标。链接器轻松用作交叉编译工具链的一部分很容易。<br> • 可以将LLD嵌入程序中，以消除对外部链接程序的依赖。要做的就是构造目标文件和命令行参数，就像调用外部链接器然后lld::elf::link从代码中调用链接器的主要功能一样 。<br> • 正在使用LLVM libObject库从目标文件读取数据，因此这并不是一个完全公平的比较，LLD / ELF仅包含2万1千行C ++代码，而GNU gold由19.8万行C ++代码构成。<br> • 默认情况下支持链接时间优化（LTO）。本质上，要做LTO所需要做的就是将-flto选项传递给clang。然后clang创建的对象文件不是本机目标文件格式，而是LLVM位码格式。LLD读取位码目标文件，使用LLVM对其进行编译并发出输出文件。因为以这种方式LLD可以看到整个程序，所以它可以对整个程序进行优化。<br> • 古老的Unix系统（90年代以前甚至更早）的一些非常古老的功能已被删除。一些默认设置已进行了调整。例如，默认情况下，将堆栈标记为不可执行以加强安全性。<br> 性能<br> 这是在2插槽20核40线程Xeon E5-2680 2.80 GHz带有SSD驱动器的计算机上的链接时间比较。在有或没有多线程支持的情况下都发挥了作用。为了禁用多线程，添加-no-threads了命令行。<br> <img src="https://images2.imgbox.com/82/73/Yy4bbeUE_o.png" alt="在这里插入图片描述"></p> 
<p>如表所见，lld的速度明显快于GNU链接器。请注意，这只是环境的基准结果。根据可用核心数，可用内存量或磁盘延迟/吞吐量，结果可能会有所不同。<br> 由于GNU ld不支持-icf=all and -gdb-index选项，因此从GNU ld的命令行中删除了。如果拥有这些选项，GNU ld将会比这慢。<br> 构建<br> 如果已经使用SVN检出了LLVM，则可以在tools中像clang一样检出目录下的LLD 。有关详细信息，请参阅Getting Started with the LLVM System。<br> 如果尚未签出LLVM，构建LLD的最简单方法是，从git镜像签出整个LLVM项目/子项目并构建该树。需要cmake，当然也需要C ++编译器。<br> $ git clone https://github.com/llvm/llvm-project llvm-project<br> $ mkdir build<br> $ cd build<br> $ cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=lld -DCMAKE_INSTALL_PREFIX=/usr/local …/llvm-project/llvm<br> $ make install<br> 使用LLD<br> LLD安装为ld.lld。在Unix上，链接器由编译器驱动程序调用，因此不希望直接使用该命令。编译器驱动程序有几种方法可以使用ld.lld而不是默认链接器。<br> 最简单的方法是覆盖默认链接器。将LLD安装到磁盘上的某个位置后，可以通过创建符号链接来将-s /path/to/ld.lld /usr/bin/ld so that /usr/bin/ld is resolved to LLD其解析为LLD。<br> 如果不想更改系统设置，则可以使用clang的 -fuse-ld选项。这样，-fuse-ld=lld在构建程序时要设置为LDFLAGS。<br> LLD将其名称和版本号留.comment在输出中的某个部分。如果不确定是否成功使用LLD，运行并检查输出。如果输出中包含字符串“ Linker：LLD”，则说明正在使用LLD。readelf --string-dump .comment </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8968df6d3fb74db7ceca6a771cd0325a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">幻宇树莓派麦克纳姆轮小车：建图导航快速体验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a9393ec8a4daaaa3936caa5f47678c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">错误: ‘shared_ptr’ in namespace ‘std’ does not name a type的解决方法。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>