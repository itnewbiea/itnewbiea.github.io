<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis的动态SQL及关键属性和标识的区别(对SQL更灵活的使用) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mybatis的动态SQL及关键属性和标识的区别(对SQL更灵活的使用)" />
<meta property="og:description" content="（ 虽然文章中有大多文本内容，想了解更深需要耐心看完，必定大有受益 ）
目录
一、动态SQL
( 1 ) 是什么
( 2 ) 作用
( 3 ) 优点
( 4 ) 特殊标签
( 5 ) 演示
二、#和$的区别
2.1 #使用
( 1 ) #占位符语法
( 2 ) #优点
2.2 $使用
( 1 ) $占位符语法
( 2 ) $优点
2.3 综合
2.4 实例演示
三、resultType及resultMap的区别
3.1 讲述
3.2 演示
给我们带来的收获
一、动态SQL ( 1 ) 是什么 是一种在SQL语句中根据不同条件动态拼接SQL的方式。通过使用动态SQL，可以根据不同的条件生成不同的SQL语句，从而实现灵活的查询和更新操作。动态SQL可以使用if、choose、when、otherwise等标签来实现条件判断和循环操作，同时还可以使用foreach标签来实现对集合类型参数的遍历操作。这样可以避免在代码中使用大量的字符串拼接，提高代码的可读性和维护性。
( 2 ) 作用 Mybatis的动态SQL具有以下作用：
1&amp;. 灵活的条件查询：通过动态SQL，可以根据不同的条件生成不同的SQL语句，实现灵活的条件查询。可以根据用户输入的不同条件动态拼接SQL，从而实现动态的查询操作。2&amp;. 动态更新操作：通过动态SQL，可以根据不同的条件生成不同的更新SQL语句，实现动态的更新操作。可以根据不同的业务需求动态拼接更新语句，从而实现灵活的数据更新。3&amp;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2655bb292d5e77cbeb7d6770602d0a18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-22T15:01:25+08:00" />
<meta property="article:modified_time" content="2023-08-22T15:01:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis的动态SQL及关键属性和标识的区别(对SQL更灵活的使用)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>                                        <img alt="" height="240" src="https://images2.imgbox.com/9d/4f/TYLFxmKI_o.gif" width="240">     <img alt="" height="240" src="https://images2.imgbox.com/1a/d0/cFuYC0D7_o.gif" width="240"></p> 
<p>                                 <em><span style="color:#1c7892;"><strong>（  虽然文章中有大多文本内容，想了解更深需要耐心看完，必定大有受益 ）</strong></span></em></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81SQL-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81SQL" rel="nofollow">一、动态SQL</a></p> 
<p id="(%201%20)%20%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#%28%201%20%29%20%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">( 1 ) 是什么</a></p> 
<p id="(%202%20)%20%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#%28%202%20%29%20%E4%BD%9C%E7%94%A8" rel="nofollow">( 2 ) 作用</a></p> 
<p id="(%203%20)%20%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;"><a href="#%28%203%20%29%20%E4%BC%98%E7%82%B9" rel="nofollow">( 3 ) 优点</a></p> 
<p id="(%204%20)%C2%A0%E7%89%B9%E6%AE%8A%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#%28%204%20%29%C2%A0%E7%89%B9%E6%AE%8A%E6%A0%87%E7%AD%BE" rel="nofollow">( 4 ) 特殊标签</a></p> 
<p id="(%205%20)%20%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%28%205%20%29%20%E6%BC%94%E7%A4%BA" rel="nofollow">( 5 ) 演示</a></p> 
<p id="%E4%BA%8C%E3%80%81%23%E5%92%8C%24%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%23%E5%92%8C%24%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">二、#和$的区别</a></p> 
<p id="2.1%C2%A0%20%23%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%20%23%E4%BD%BF%E7%94%A8" rel="nofollow">2.1  #使用</a></p> 
<p id="%C2%A0(%201%20)%C2%A0%23%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#%C2%A0%28%201%20%29%C2%A0%23%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%AF%AD%E6%B3%95" rel="nofollow"> ( 1 ) #占位符语法</a></p> 
<p id="%C2%A0(%202%20)%20%23%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%28%202%20%29%20%23%E4%BC%98%E7%82%B9" rel="nofollow"> ( 2 ) #优点</a></p> 
<p id="2.2%C2%A0%20%24%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%20%24%E4%BD%BF%E7%94%A8" rel="nofollow">2.2  $使用</a></p> 
<p id="%C2%A0(%201%20)%C2%A0%24%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#%C2%A0%28%201%20%29%C2%A0%24%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%AF%AD%E6%B3%95" rel="nofollow"> ( 1 ) $占位符语法</a></p> 
<p id="%C2%A0(%202%20)%20%24%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%28%202%20%29%20%24%E4%BC%98%E7%82%B9" rel="nofollow"> ( 2 ) $优点</a></p> 
<p id="2.3%C2%A0%20%E7%BB%BC%E5%90%88-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%20%E7%BB%BC%E5%90%88" rel="nofollow">2.3  综合</a></p> 
<p id="2.4%C2%A0%20%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#2.4%C2%A0%20%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA" rel="nofollow">2.4  实例演示</a></p> 
<p id="%E4%B8%89%E3%80%81resultType%E5%8F%8AresultMap%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81resultType%E5%8F%8AresultMap%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">三、resultType及resultMap的区别</a></p> 
<p id="3.1%20%E8%AE%B2%E8%BF%B0-toc" style="margin-left:40px;"><a href="#3.1%20%E8%AE%B2%E8%BF%B0" rel="nofollow">3.1 讲述</a></p> 
<p id="3.2%20%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3.2%20%E6%BC%94%E7%A4%BA" rel="nofollow">3.2 演示</a></p> 
<p id="%C2%A0%E7%BB%99%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%94%B6%E8%8E%B7-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%BB%99%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%94%B6%E8%8E%B7" rel="nofollow"> 给我们带来的收获</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81SQL">一、动态SQL</h2> 
<h3 id="(%201%20)%20%E6%98%AF%E4%BB%80%E4%B9%88">( 1 ) 是什么</h3> 
<blockquote> 
 <p>是一种在SQL语句中根据不同条件动态拼接SQL的方式。通过使用动态SQL，可以根据不同的条件生成不同的SQL语句，从而实现灵活的查询和更新操作。动态SQL可以使用if、choose、when、otherwise等标签来实现条件判断和循环操作，同时还可以使用foreach标签来实现对集合类型参数的遍历操作。这样可以<em><span style="color:#1c7892;"><strong>避免在代码中使用大量的字符串拼接</strong></span></em>，提高代码的可读性和维护性。</p> 
</blockquote> 
<h3 id="(%202%20)%20%E4%BD%9C%E7%94%A8">( 2 ) 作用</h3> 
<blockquote> 
 <p>Mybatis的动态SQL具有以下作用：</p> 
 <ul><li>1&amp;. 灵活的条件查询：通过动态SQL，可以根据不同的条件生成不同的SQL语句，实现灵活的条件查询。可以根据用户输入的不同条件动态拼接SQL，从而实现动态的查询操作。</li><li>2&amp;. 动态更新操作：通过动态SQL，可以根据不同的条件生成不同的更新SQL语句，实现动态的更新操作。可以根据不同的业务需求动态拼接更新语句，从而实现灵活的数据更新。</li><li>3&amp;. 避免SQL注入：通过使用动态SQL，可以使用预编译的方式来拼接SQL语句，避免了直接拼接字符串的方式，从而有效防止SQL注入攻击。</li><li>4&amp;. 提高代码可读性和维护性：通过使用动态SQL的标签和语法，可以将复杂的SQL语句拆分为多个小块，提高了代码的可读性和维护性。可以根据不同的条件使用不同的标签和语法，使代码更加清晰易懂。</li></ul> 
 <p>总之，动态SQL是Mybatis的重要特性之一，可以帮助开发者灵活地拼接SQL语句，实现动态的查询和更新操作，<em><span style="color:#fe2c24;"><strong>提高代码的可读性和维护性。</strong></span></em></p> 
</blockquote> 
<blockquote> 
 <p>动态SQL在扩展方面有以下几个方面的作用：</p> 
 <ul><li>1#. 支持多表关联查询：通过动态SQL，可以根据不同的条件动态拼接多表关联查询的SQL语句。可以根据业务需求动态选择关联的表和关联条件，从而实现复杂的多表查询操作。</li><li>2#. 支持分页查询：通过动态SQL，可以根据不同的条件动态拼接分页查询的SQL语句。可以根据分页参数动态计算查询结果的起始位置和数量，并将其拼接到SQL语句中，实现分页查询操作。</li><li>3#. 支持动态排序：通过动态SQL，可以根据不同的条件动态拼接排序查询的SQL语句。可以根据排序参数动态选择排序字段和排序方式，并将其拼接到SQL语句中，实现动态排序查询操作。</li><li>4#. 支持动态字段选择：通过动态SQL，可以根据不同的条件动态拼接字段选择的SQL语句。可以根据字段选择参数动态选择需要查询的字段，并将其拼接到SQL语句中，实现动态字段选择查询操作。</li><li>5#. 支持动态更新字段：通过动态SQL，可以根据不同的条件动态拼接更新字段的SQL语句。可以根据更新参数动态选择需要更新的字段，并将其拼接到SQL语句中，实现动态更新字段操作。</li></ul> 
 <p>总之，动态SQL在扩展方面可以根据不同的条件动态拼接SQL语句，满足复杂的查询和更新需求。通过动态SQL，可以灵活地处理多表关联查询、分页查询、动态排序、动态字段选择和动态更新字段等扩展操作，<em><span style="color:#1a439c;"><strong>提高了系统的灵活性和可扩展性</strong></span></em>。</p> 
</blockquote> 
<h3 id="(%203%20)%20%E4%BC%98%E7%82%B9">( 3 ) 优点</h3> 
<blockquote> 
 <p>Mybatis的动态SQL具有以下优点：</p> 
 <ul><li>-1. 灵活性：动态SQL可以根据不同的条件生成不同的SQL语句，实现灵活的查询和更新操作。可以根据不同的业务需求动态拼接SQL，从而满足不同的查询和更新需求。</li><li>-2. 可读性：通过使用动态SQL的标签和语法，可以将复杂的SQL语句拆分为多个小块，提高了代码的可读性。可以根据不同的条件使用不同的标签和语法，使代码更加清晰易懂。</li><li>-3. 维护性：使用动态SQL可以将SQL语句的拼接逻辑与业务逻辑分离，使代码更易于维护。可以根据需要修改或添加条件，而不需要修改大段的SQL语句，减少了代码的维护成本。</li><li>-4. 防止SQL注入：通过使用动态SQL，可以使用预编译的方式来拼接SQL语句，避免了直接拼接字符串的方式，从而有效防止SQL注入攻击。</li><li>-5. 性能优化：动态SQL可以根据不同的条件生成不同的SQL语句，可以根据业务需求进行优化。可以根据查询条件动态选择索引，从而提高查询效率。</li></ul> 
 <p>总之，动态SQL是Mybatis的强大特性之一，<em><span style="color:#fe2c24;"><strong>具有灵活性、可读性、维护性、安全性和性能优化</strong></span></em>等优点，能够帮助开发者更好地处理复杂的查询和更新需求，<em><span style="color:#b95514;"><strong>提高代码质量和开发效率。</strong></span></em></p> 
</blockquote> 
<h3 id="(%204%20)%C2%A0%E7%89%B9%E6%AE%8A%E6%A0%87%E7%AD%BE">( 4 ) 特殊标签</h3> 
<blockquote> 
 <p>Mybatis的动态SQL是一种在SQL语句中<em><span style="color:#b95514;"><strong>根据不同条件动态生成不同SQL片段的技术</strong></span></em>。它通过使用Mybatis提供的一些特殊标签和语法，可以根据不同的条件动态拼接SQL语句，从而实现灵活的查询和更新操作。</p> 
</blockquote> 
<blockquote> 
 <p>Mybatis提供了以下几种常用的动态SQL标签和语法：</p> 
 <ul><li>1. if标签：if标签可以根据条件判断是否包含某段SQL语句。可以在if标签中使用OGNL表达式来判断条件，如果条件满足，则包含if标签中的SQL语句。</li><li>2. choose、when、otherwise标签：choose标签类似于Java中的switch语句，可以根据不同的条件选择不同的SQL语句执行。可以在choose标签中使用when标签定义多个条件分支，当条件满足时，执行对应的SQL语句；可以使用otherwise标签定义默认的SQL语句。</li><li>3. trim标签：trim标签可以根据不同的条件动态拼接SQL语句的开头或结尾部分。可以使用trim标签来去除或添加不需要的SQL关键字，从而实现灵活的SQL拼接。</li><li>4. foreach标签：foreach标签可以遍历集合或数组，并根据集合中的元素动态生成SQL语句。可以使用foreach标签来实现批量插入或批量更新操作。</li><li>5. set标签：set标签可以根据不同的条件动态生成更新操作中的set语句。可以使用set标签来根据更新参数动态选择需要更新的字段，并将其拼接到SQL语句中。</li></ul> 
 <p>通过使用这些动态SQL标签和语法，可以根据不同的条件动态生成不同的SQL语句，从而实现灵活的查询和更新操作。动态SQL使得Mybatis可以根据不同的业务需求动态拼接SQL语句，<em><span style="color:#1c7892;"><strong>提高了代码的可读性、维护性和扩展性。</strong></span></em></p> 
</blockquote> 
<h3 id="(%205%20)%20%E6%BC%94%E7%A4%BA">( 5 ) 演示</h3> 
<blockquote> 
 <p>该演示效果是需要结合我上一篇文章的代码进行扩展 :</p> 
 <p id="articleContentId"><a class="link-info" href="https://blog.csdn.net/SAME_LOVE/article/details/132384724?spm=1001.2014.3001.5501" title="mybatis入门的环境搭建及快速完成CRUD(增删改查)">mybatis入门的环境搭建及快速完成CRUD(增删改查)</a></p> 
</blockquote> 
<blockquote> 
 <p>根据我们自动生成的xml，接口，实体进行增加代码进行动态SQL的演示操作 </p> 
</blockquote> 
<blockquote> 
 <p>自动生成的实体代码( Book )对象</p> 
</blockquote> 
<pre><code>package com.CloudJun.model;

public class Book {
    private Integer bid;

    private String bname;

    private Float price;

    public Book(Integer bid, String bname, Float price) {
        this.bid = bid;
        this.bname = bname;
        this.price = price;
    }

    public Book() {
        super();
    }

    public Integer getBid() {
        return bid;
    }

    public void setBid(Integer bid) {
        this.bid = bid;
    }

    public String getBname() {
        return bname;
    }

    public void setBname(String bname) {
        this.bname = bname;
    }

    public Float getPrice() {
        return price;
    }

    public void setPrice(Float price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book{" +
                "bid=" + bid +
                ", bname='" + bname + '\'' +
                ", price=" + price +
                '}';
    }
}</code></pre> 
<blockquote> 
 <p>  自动生成的实体接口 BookMapper</p> 
</blockquote> 
<pre><code>package com.CloudJun.mapper;

import com.CloudJun.model.Book;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface BookMapper {
    int deleteByPrimaryKey(Integer bid);

    int insert(Book record);

    int insertSelective(Book record);

    Book selectByPrimaryKey(Integer bid);

    int updateByPrimaryKeySelective(Book record);

    int updateByPrimaryKey(Book record);


    //增加根据多个ID(bid)查询多个数据的方法
    List&lt;Book&gt; selectByBll(@Param("bids") List bids);




}</code></pre> 
<blockquote> 
 <p>  自动生成的 BookMapper.xml 配置文件</p> 
</blockquote> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;
&lt;mapper namespace="com.CloudJun.mapper.BookMapper" &gt;
  &lt;resultMap id="BaseResultMap" type="com.CloudJun.model.Book" &gt;
    &lt;constructor &gt;
      &lt;idArg column="bid" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt;
      &lt;arg column="bname" jdbcType="VARCHAR" javaType="java.lang.String" /&gt;
      &lt;arg column="price" jdbcType="REAL" javaType="java.lang.Float" /&gt;
    &lt;/constructor&gt;
  &lt;/resultMap&gt;
  &lt;sql id="Base_Column_List" &gt;
    bid, bname, price
  &lt;/sql&gt;
  &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt;
    select 
    &lt;include refid="Base_Column_List" /&gt;
    from t_mvc_book
    where bid = #{bid,jdbcType=INTEGER}
  &lt;/select&gt;
  &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt;
    delete from t_mvc_book
    where bid = #{bid,jdbcType=INTEGER}
  &lt;/delete&gt;
  &lt;insert id="insert" parameterType="com.CloudJun.model.Book" &gt;
    insert into t_mvc_book (bid, bname, price
      )
    values (#{bid,jdbcType=INTEGER}, #{bname,jdbcType=VARCHAR}, #{price,jdbcType=REAL}
      )
  &lt;/insert&gt;
  &lt;insert id="insertSelective" parameterType="com.CloudJun.model.Book" &gt;
    insert into t_mvc_book
    &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt;
      &lt;if test="bid != null" &gt;
        bid,
      &lt;/if&gt;
      &lt;if test="bname != null" &gt;
        bname,
      &lt;/if&gt;
      &lt;if test="price != null" &gt;
        price,
      &lt;/if&gt;
    &lt;/trim&gt;
    &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt;
      &lt;if test="bid != null" &gt;
        #{bid,jdbcType=INTEGER},
      &lt;/if&gt;
      &lt;if test="bname != null" &gt;
        #{bname,jdbcType=VARCHAR},
      &lt;/if&gt;
      &lt;if test="price != null" &gt;
        #{price,jdbcType=REAL},
      &lt;/if&gt;
    &lt;/trim&gt;
  &lt;/insert&gt;
  &lt;update id="updateByPrimaryKeySelective" parameterType="com.CloudJun.model.Book" &gt;
    update t_mvc_book
    &lt;set &gt;
      &lt;if test="bname != null" &gt;
        bname = #{bname,jdbcType=VARCHAR},
      &lt;/if&gt;
      &lt;if test="price != null" &gt;
        price = #{price,jdbcType=REAL},
      &lt;/if&gt;
    &lt;/set&gt;
    where bid = #{bid,jdbcType=INTEGER}
  &lt;/update&gt;
  &lt;update id="updateByPrimaryKey" parameterType="com.CloudJun.model.Book" &gt;
    update t_mvc_book
    set bname = #{bname,jdbcType=VARCHAR},
      price = #{price,jdbcType=REAL}
    where bid = #{bid,jdbcType=INTEGER}
  &lt;/update&gt;

&lt;!-- 根据多个bid(编号)进行查询出多个Book(对象)，bids参数需要是一个List&lt;Integer&gt; 集合--&gt;
  &lt;select id="selectByBll" resultType="com.CloudJun.model.Book" parameterType="java.util.List" &gt;
    select
    &lt;include refid="Base_Column_List" /&gt;
    from t_mvc_book
    where bid in
    &lt;foreach collection="bids" item="bid" open="(" close=")" separator=","&gt;
      #{bid}
    &lt;/foreach&gt;
  &lt;/select&gt;


&lt;/mapper&gt;</code></pre> 
<blockquote> 
 <p>其中的动态SQL可以根据自己的需要进行编写 :</p> 
 <p>  &lt;select id="selectByBll" resultType="com.CloudJun.model.Book" parameterType="java.util.List" &gt;<br>     select<br>     &lt;include refid="Base_Column_List" /&gt;<br>     from t_mvc_book<br>     where bid in<br>     &lt;foreach collection="bids" item="bid" open="(" close=")" separator=","&gt;<br>       #{bid}<br>     &lt;/foreach&gt;<br>   &lt;/select&gt; </p> 
</blockquote> 
<blockquote> 
 <p>再将以下代码增加到增加编写的接口中 </p> 
</blockquote> 
<pre><code>//    封装方法
    List&lt;Book&gt; selectByBll(List bids);</code></pre> 
<blockquote> 
 <p> 然后在实现类中增加以下代码</p> 
</blockquote> 
<pre><code>//    方法实现
    @Override
    public List&lt;Book&gt; selectByBll(List bids) {
        return bookMapper.selectByBll(bids);
    }</code></pre> 
<blockquote> 
 <p>最后我们就可以在Demo测试类中进行方法调用测试</p> 
 <p>在Demo中增加以下代码进行测试 :  </p> 
</blockquote> 
<blockquote> 
 <pre><code>    @Test
    public void Bll(){
        List&lt;Integer&gt; bids = Arrays.asList(new Integer[]{41,42,43,45,47});
             //jdk1.8的新特性写法  
      bookBiz.selectByBll(bids).forEach(System.out::println);
//        for (Book book: bookBiz.selectByBll(bids)) {
//            System.out.println(book);
//        }
    }</code></pre> 
 <p>   其中方法调用的输出代码是jdk 1.8的新特性，提倡大家可以去探索，有很大收获。</p> 
</blockquote> 
<blockquote> 
 <p>输出的结果为:</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/15/90/zV9dIYHn_o.png"></p> 
<h2 id="%E4%BA%8C%E3%80%81%23%E5%92%8C%24%E7%9A%84%E5%8C%BA%E5%88%AB">二、#和$的区别</h2> 
<h3 id="2.1%C2%A0%20%23%E4%BD%BF%E7%94%A8">2.1  #使用</h3> 
<h4 id="%C2%A0(%201%20)%C2%A0%23%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%AF%AD%E6%B3%95"> ( 1 ) #占位符语法</h4> 
<blockquote> 
 <ul><li>#占位符会将传入的参数值自动进行预编译处理，可以防止SQL注入攻击。</li><li>使用#占位符时，Mybatis会将参数值以安全的方式替换到SQL语句中，使用JDBC的预编译语句来执行SQL查询。</li><li>#占位符在生成SQL语句时会对参数值进行类型处理，将参数值转换为对应的JDBC类型。</li><li>#占位符可以防止SQL注入攻击，但是无法实现动态拼接SQL片段。</li></ul> 
</blockquote> 
<h4 id="%C2%A0(%202%20)%20%23%E4%BC%98%E7%82%B9"> ( 2 ) #优点</h4> 
<blockquote> 
 <p>#占位符语法在使用动态SQL时具有以下优点：</p> 
 <ul><li>1. 防止SQL注入攻击：#占位符语法会将传入的参数值进行预编译处理，将参数值转换为对应的JDBC类型。这样可以防止恶意输入对SQL语句造成的安全威胁，提高了系统的安全性。</li><li>2. 参数值类型处理：#占位符语法会对参数值进行类型处理，将参数值转换为对应的JDBC类型。这样可以避免在SQL语句中手动进行类型转换的麻烦，提高了开发效率。</li><li>3. 可读性和可维护性：使用#占位符语法可以使SQL语句更加清晰和可读，因为参数值被封装在占位符中，不会直接出现在SQL语句中。这样可以方便后续的维护和修改，减少出错的可能性。</li><li>4. 兼容性：#占位符语法是Mybatis的特有语法，相对于$占位符语法更具有兼容性。如果项目需要切换到其他ORM框架，使用#占位符语法可以减少代码的修改量。</li></ul> 
 <p>综上所述，#占位符语法<em><span style="color:#1c7892;"><strong>具有防止SQL注入攻击、参数值类型处理、可读性和可维护性、兼容性</strong></span></em>等优点。因此，在项目中使用动态SQL时，推荐使用#占位符语法。</p> 
</blockquote> 
<h3 id="2.2%C2%A0%20%24%E4%BD%BF%E7%94%A8">2.2  $使用</h3> 
<h4 id="%C2%A0(%201%20)%C2%A0%24%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%AF%AD%E6%B3%95"> ( 1 ) $占位符语法</h4> 
<blockquote> 
 <ul><li>$占位符会直接将传入的参数值替换到SQL语句中，不进行预编译处理。</li><li>使用$占位符时，Mybatis会将参数值直接替换到SQL语句中，生成最终的SQL语句。</li><li>$占位符在生成SQL语句时不会对参数值进行类型处理，参数值会直接拼接到SQL语句中，可能存在安全风险。</li><li>$占位符可以实现动态拼接SQL片段，但是可能存在SQL注入攻击的风险。</li></ul> 
</blockquote> 
<h4 id="%C2%A0(%202%20)%20%24%E4%BC%98%E7%82%B9"> ( 2 ) $优点</h4> 
<blockquote> 
 <p>$占位符语法在使用动态SQL时具有以下优点：</p> 
 <ol><li> <p>动态拼接SQL片段：$占位符语法允许在SQL语句中直接使用参数值，可以方便地进行动态拼接SQL片段。这样可以在某些特殊情况下，更灵活地构建SQL语句。</p> </li><li> <p>字段名动态替换：$占位符语法可以用于动态替换字段名。这在某些场景下非常有用，比如需要根据用户的选择动态查询不同的字段。</p> </li><li> <p>SQL语句灵活性：$占位符语法允许在SQL语句中使用任意有效的SQL表达式。这样可以在SQL语句中进行一些复杂的计算、字符串拼接等操作。</p> </li></ol> 
</blockquote> 
<h3 id="2.3%C2%A0%20%E7%BB%BC%E5%90%88">2.3  综合</h3> 
<blockquote> 
 <p>综上所述，$占位符语法在某些特殊情况下具有灵活性和动态拼接SQL的优势，但需要注意<em><span style="color:#1c7892;"><strong>SQL注入攻击的风险，并且可能会降低SQL语句的可读性和可维护性</strong></span></em>。因此，在使用动态SQL时，#占位符语法<em><span style="color:#1c7892;"><strong>具有防止SQL注入攻击、参数值类型处理、可读性和可维护性、兼容性等</strong></span></em>优点。因此，在项目中使用动态SQL时，推荐使用#占位符语法。只有在特殊情况下，需要动态拼接SQL片段或动态替换字段名时，才考虑使用占位符语法，并且需要确保参数值的安全性。</p> 
</blockquote> 
<h3 id="2.4%C2%A0%20%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA">2.4  实例演示</h3> 
<blockquote> 
 <p>在自动生成的 BookMapper.xml 配置文件中增加以下代码</p> 
</blockquote> 
<pre><code>  &lt;select id="like01" resultType="com.CloudJun.model.Book" parameterType="java.lang.String" &gt;
    select
    &lt;include refid="Base_Column_List" /&gt;
    from t_mvc_book
    where bname like #{bname}
  &lt;/select&gt;

  &lt;select id="like02" resultType="com.CloudJun.model.Book" parameterType="java.lang.String" &gt;
    select
    &lt;include refid="Base_Column_List" /&gt;
    from t_mvc_book
    where bname like  '${bname}'
  &lt;/select&gt;

  &lt;select id="like03" resultType="com.CloudJun.model.Book" parameterType="java.lang.String" &gt;
    select
    &lt;include refid="Base_Column_List" /&gt;
    from t_mvc_book
    where bname like concat('%',#{bname},'%')
  &lt;/select&gt;</code></pre> 
<blockquote> 
 <p>自己在配置文件中根据自己需求来进行编写动态SQL</p> 
 <p><strong>注意 : </strong></p> 
 <p>这里如果使用$占位符语法的话需要在${bname}的左右增加单引号 列如:  '${bname}' </p> 
 <p>这已是$占位符语法的一个小缺陷，在我们日常使用中一般使用的是第三种方法( like03 )</p> 
</blockquote> 
<blockquote> 
 <p>在自动生成的 BookMapper 接口中增加以下代码</p> 
</blockquote> 
<pre><code>    //增加模糊查询的方法
    List&lt;Book&gt; like01(@Param("bname") String bname);

    List&lt;Book&gt; like02(@Param("bname") String bname);

    List&lt;Book&gt; like03(@Param("bname") String bname);</code></pre> 
<blockquote> 
 <p>编写动态SQL后进行封装方法 </p> 
</blockquote> 
<blockquote> 
 <p> 在自己创建的接口中增加以下代码</p> 
</blockquote> 
<pre><code>    List&lt;Book&gt; like01(String bname);

    List&lt;Book&gt; like02(String bname);

    List&lt;Book&gt; like03(String bname);
</code></pre> 
<blockquote> 
 <p> 在自己创建的实现类中增加以下代码</p> 
</blockquote> 
<pre><code>    @Override
    public List&lt;Book&gt; like01(String bname) {
        return bookMapper.like01(bname);
    }

    @Override
    public List&lt;Book&gt; like02(String bname) {
        return bookMapper.like02(bname);
    }

    @Override
    public List&lt;Book&gt; like03(String bname) {
        return bookMapper.like03(bname);
    }</code></pre> 
<blockquote> 
 <p>在测试类( Demo )中增加以下代码并且进行一一调用测试  </p> 
</blockquote> 
<pre><code>    @Test
    public void like01(){
        bookBiz.like01("%斗破%").forEach(System.out::println);
    }
    @Test
    public void like02(){
        bookBiz.like02("%斗破%").forEach(System.out::println);
    }
    @Test
    public void like03(){
        bookBiz.like03("%斗破%").forEach(System.out::println);
    }

</code></pre> 
<blockquote> 
 <p>like01的方法测试结果 </p> 
</blockquote> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/e4/ba/yJ3Lcacf_o.png"></p> 
</blockquote> 
<blockquote> 
 <p>测试like02没有增加单引号时会执行SQL报错 </p> 
</blockquote> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/0a/87/RbFCp7jP_o.png"></p> 
</blockquote> 
<blockquote> 
 <p>like02的方法测试结果</p> 
</blockquote> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/31/fc/7vVvyMd4_o.png"></p> 
</blockquote> 
<blockquote> 
 <p>like03的方法测试结果</p> 
</blockquote> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a2/84/9KEJQxq7_o.png"></p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81resultType%E5%8F%8AresultMap%E7%9A%84%E5%8C%BA%E5%88%AB">三、resultType及resultMap的区别</h2> 
<h3 id="3.1%20%E8%AE%B2%E8%BF%B0">3.1 讲述</h3> 
<blockquote> 
 <p>在Mybatis的动态SQL中，resultType和resultMap都是用于指定查询结果的类型或映射关系的配置项。</p> 
</blockquote> 
<blockquote> 
 <p>resultType： resultType用于指定查询结果的类型，可以是Java基本类型、Java对象类型或自定义的Java类。当使用resultType时，Mybatis会根据查询结果的列名和Java对象的属性名进行自动映射。例如，如果查询结果的列名为"username"，Java对象中有对应的属性"userName"，则Mybatis会自动将查询结果映射到Java对象中。</p> 
 <p>示例：</p> 
 <pre><code>&lt;select id="getUser" resultType="com.example.User"&gt;
  SELECT id, username, email FROM user WHERE id = #{id}
&lt;/select&gt;
</code></pre> 
 <p>在上述示例中，resultType指定了查询结果的类型为com.example.User类，Mybatis会根据查询结果的列名和User类的属性名进行自动映射。</p> 
</blockquote> 
<blockquote> 
 <p>resultMap： resultMap用于自定义查询结果的映射关系，可以通过指定映射关系来实现更灵活的结果映射。resultMap需要在映射文件中进行配置，通过定义&lt;resultMap&gt;标签来指定映射关系。在&lt;resultMap&gt;标签中，可以使用&lt;id&gt;、&lt;result&gt;、&lt;association&gt;等标签来定义主键、普通列和关联对象之间的映射关系。</p> 
 <p>示例：</p> 
 <pre><code>&lt;resultMap id="userResultMap" type="com.example.User"&gt;
  &lt;id property="id" column="user_id"/&gt;
  &lt;result property="username" column="user_name"/&gt;
  &lt;result property="email" column="user_email"/&gt;
&lt;/resultMap&gt;

&lt;select id="getUser" resultMap="userResultMap"&gt;
  SELECT id as user_id, username as user_name, email as user_email FROM user WHERE id = #{id}
&lt;/select&gt;
</code></pre> 
 <p>在上述示例中，resultMap指定了自定义的映射关系userResultMap，通过&lt;resultMap&gt;标签中的&lt;id&gt;和&lt;result&gt;标签来定义查询结果列和User类属性之间的映射关系。</p> 
</blockquote> 
<blockquote> 
 <p>区别：</p> 
 <ul><li>resultType用于简单的结果映射，适用于查询结果列与Java对象属性名一致的情况，自动进行映射。</li><li>resultMap用于复杂的结果映射，适用于查询结果列与Java对象属性名不一致或需要自定义映射关系的情况，需要手动定义映射关系。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>总结：</strong></p> 
 <p><strong><em><span style="color:#1c7892;">resultType适用于简单的结果映射，可以自动进行映射；</span></em></strong></p> 
 <p><strong><em><span style="color:#1c7892;">resultMap适用于复杂的结果映射，需要手动定义映射关系。</span></em></strong></p> 
 <p><strong>根据具体的需求和情况，选择合适的配置项来实现查询结果的映射。</strong></p> 
</blockquote> 
<h3 id="3.2%20%E6%BC%94%E7%A4%BA">3.2 演示</h3> 
<blockquote> 
 <p><strong> resultType的使用场景：</strong></p> 
 <ul><li>当查询结果与Java对象的属性名一致，并且查询结果较为简单时，可以使用resultType。这样可以简化配置，避免过多的映射配置。</li><li>当查询结果只包含少量列，并且不需要进行复杂的映射操作时，也可以使用resultType。</li></ul> 
 <p><strong> resultMap的使用场景：</strong></p> 
 <ul><li>当查询结果与Java对象的属性名不一致，或者查询结果需要进行复杂的映射操作时，可以使用resultMap。通过自定义映射关系，可以灵活地将查询结果映射到Java对象中。</li><li>当查询结果包含多个关联对象，需要进行关联查询和关联映射时，也可以使用resultMap。通过&lt;association&gt;、&lt;collection&gt;等标签，可以定义关联对象之间的映射关系。</li></ul> 
 <p><span style="color:#494949;"><strong>综上所述，resultType适用于简单的结果映射，而resultMap适用于复杂的结果映射。在实际项目中，根据查询结果的复杂度和需求的灵活性，选择合适的配置项来进行结果映射。如果查询结果较为简单且与Java对象属性名一致，可以使用resultType；如果查询结果复杂或需要进行自定义映射操作，可以使用resultMap。</strong></span></p> 
</blockquote> 
<blockquote> 
 <p>在自动生成的 BookMapper.xml 配置文件中增加以下代码</p> 
</blockquote> 
<pre><code>  &lt;select id="BookList01" resultType="com.CloudJun.model.Book" &gt;
    select
    &lt;include refid="Base_Column_List" /&gt;
    from t_mvc_book
  &lt;/select&gt;

  &lt;select id="BookList02" resultMap="BaseResultMap" &gt;
    select
    &lt;include refid="Base_Column_List" /&gt;
    from t_mvc_book
  &lt;/select&gt;</code></pre> 
<blockquote> 
 <p>在自动生成的 BookMapper 接口中增加以下代码</p> 
</blockquote> 
<pre><code>   List&lt;Book&gt; BookList01();

   List&lt;Book&gt; BookList02();</code></pre> 
<blockquote> 
 <p>在自己创建的接口  BookBiz 中增加以下代码</p> 
</blockquote> 
<pre><code>    List&lt;Book&gt;  BookList01();
    List&lt;Book&gt;  BookList02();</code></pre> 
<blockquote> 
 <p>在自己创建的实现类  BookBizImpl 中增加以下代码</p> 
</blockquote> 
<pre><code>    @Override
    public List&lt;Book&gt; BookList01() {
        return bookMapper.BookList01();
    }

    @Override
    public List&lt;Book&gt; BookList02() {
        return bookMapper.BookList02();
    }</code></pre> 
<blockquote> 
 <p> 在测试类 Demo 中 增加以下代码</p> 
</blockquote> 
<pre><code>    @Test
    public  void List01(){
        bookBiz.BookList01().forEach(System.out::println);
    }

    @Test
    public  void List02(){
        bookBiz.BookList02().forEach(System.out::println);
    }</code></pre> 
<blockquote> 
 <p> 其中执行List01方法之后的结果为 :</p> 
 <p><img alt="" src="https://images2.imgbox.com/cd/55/BA4fruMh_o.png"></p> 
</blockquote> 
<blockquote> 
 <p>其中执行List02方法之后的结果为 :</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e9/b5/bqNUzOME_o.png"></p> 
</blockquote> 
<h2 id="%C2%A0%E7%BB%99%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%94%B6%E8%8E%B7"> 给我们带来的收获</h2> 
<blockquote> 
 <p>学习MyBatis的动态SQL中#和$的区别以及resultType和resultMap的区别和作用可以带来以下收获：</p> 
 <ul><li>1. 理解#和$的区别：#和$都是用于动态SQL的占位符，但它们的处理方式有所不同。#会将参数值作为字符串替换到SQL语句中，而$会将参数直接替换到SQL语句中。这意味着使用#可以防止SQL注入，而$则需要谨慎使用以避免安全问题。</li><li>2. 熟悉#和$的使用场景：学习#和$的区别可以帮助我们根据具体需求选择合适的占位符。一般来说，如果需要将参数作为字符串替换到SQL语句中，应该使用#；如果需要将参数直接替换到SQL语句中，可以使用$。</li><li>3. 理解resultType和resultMap的区别：resultType和resultMap都是用于结果映射的配置项。resultType用于简单的结果映射，可以自动进行映射；resultMap用于复杂的结果映射，需要手动定义映射关系。</li><li>4. 熟悉resultType和resultMap的使用场景：学习resultType和resultMap的区别可以帮助我们根据查询结果的复杂度和需求的灵活性选择合适的配置项。如果查询结果较为简单且与Java对象属性名一致，可以使用resultType；如果查询结果复杂或需要进行自定义映射操作，可以使用resultMap。</li><li>5. 提高结果映射的灵活性和效率：通过合理配置resultType和resultMap，可以实现灵活和准确的结果映射，从而提高结果处理效率和代码编写效率。</li></ul> 
 <p>总的来说，学习#和$的区别以及resultType和resultMap的区别和作用可以帮助我们更好地处理和操作动态SQL和结果映射，提高代码编写效率和查询结果处理效率，同时也提高了对动态SQL和结果映射的理解。这些知识对于开发数据库相关的应用程序非常有用。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/7d/bc/um2kD6gQ_o.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a987352c071edf115ab54ce22a5fb3f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">办公网络布线（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/feb60295b3cebe51b0782fe8f40ce0e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">来个切面日志打印请求和响应信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>