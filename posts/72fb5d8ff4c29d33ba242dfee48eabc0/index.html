<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FCN全卷积网络理解及代码实现（来自pytorch官方实现） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FCN全卷积网络理解及代码实现（来自pytorch官方实现）" />
<meta property="og:description" content="视频链接：https://www.bilibili.com/video/BV1J3411C7zd?vd_source=a0d4f7000e77468aec70dc618794d26f
代码：https://github.com/WZMIAOMIAO/deep-learning-for-image-processing
FCN是2015年提出的首个端对端的针对像素级预测的全卷积网络。
如今的pytorch实现的FCN都是基于ResNet-50的backbone，不是论文中的VGG16，且使用的是空洞卷积（也叫膨胀卷积）
pytorch官方实现的FCN网络结构图 博主github：https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_segmentation/fcn
一、相比以前网络的巨大提升： 二、传统使用池化层最后得到的其实是一个长度为1000的向量： 而换为卷积层之后，最后得到的是1000通道的2D图像，可以可视化为heat map图。
三、回顾VGG16 一般说的vgg16是D：
全连接操作前后：77512（通道）
【 假 设 忽 略 偏 置 】 \color{red}{【假设忽略偏置】} 【假设忽略偏置】
全连接FC1计算：计算对应某一个结点的输出，将该节点与上一层某一个结点的权重与输入对应节点数值相乘，再求和
FC1参数：25088*4096=102760448 下层使用7*7的卷积核、stride=1，4096个卷积核的一个卷积层
Conv参数：77512*4096=102760448 一 个 卷 积 核 和 F C 1 一 个 节 点 参 数 量 一 样 \color{red}{一个卷积核和FC1一个节点参数量一样} 一个卷积核和FC1一个节点参数量一样，一共4096个卷积核，FC也是4096个节点。
【 不 忽 略 偏 置 的 正 常 卷 积 操 作 ， 4096 个 卷 积 核 应 该 有 4096 个 偏 置 项 】 \color{red}{【不忽略偏置的正常卷积操作，4096个卷积核应该有4096个偏置项】} 【不忽略偏置的正常卷积操作，4096个卷积核应该有4096个偏置项】" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/72fb5d8ff4c29d33ba242dfee48eabc0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-16T16:54:45+08:00" />
<meta property="article:modified_time" content="2022-06-16T16:54:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FCN全卷积网络理解及代码实现（来自pytorch官方实现）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>视频链接：<a href="https://www.bilibili.com/video/BV1J3411C7zd?vd_source=a0d4f7000e77468aec70dc618794d26f" rel="nofollow">https://www.bilibili.com/video/BV1J3411C7zd?vd_source=a0d4f7000e77468aec70dc618794d26f</a><br> 代码：<a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing">https://github.com/WZMIAOMIAO/deep-learning-for-image-processing</a></p> 
<p>FCN是2015年提出的<mark>首个</mark>端对端的针对像素级预测的<mark>全卷积</mark>网络。<br> 如今的pytorch实现的FCN都是基于ResNet-50的backbone，不是论文中的VGG16，且使用的是空洞卷积（也叫膨胀卷积）</p> 
<h2><a id="pytorchFCN_5"></a>pytorch官方实现的FCN网络结构图</h2> 
<p><img src="https://images2.imgbox.com/ac/81/Obunyabl_o.png" alt="在这里插入图片描述"><br> 博主github：<a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_segmentation/fcn">https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_segmentation/fcn</a></p> 
<h2><a id="_9"></a>一、相比以前网络的巨大提升：</h2> 
<p><img src="https://images2.imgbox.com/97/b1/QSk9rHy2_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="1000_11"></a>二、传统使用池化层最后得到的其实是一个长度为1000的向量：</h2> 
<p><img src="https://images2.imgbox.com/7e/81/todkYxXT_o.png" alt="在这里插入图片描述"><br> 而换为卷积层之后，最后得到的是1000通道的2D图像，可以可视化为heat map图。</p> 
<h2><a id="VGG16_14"></a>三、回顾VGG16</h2> 
<p>一般说的vgg16是<strong>D</strong>：<br> <img src="https://images2.imgbox.com/ba/9b/z5d1fsJp_o.png" alt="在这里插入图片描述"><br> 全连接操作前后：7<em>7</em>512（通道）<br> <img src="https://images2.imgbox.com/15/ef/Y4ps5iJo_o.png" alt="在这里插入图片描述"></p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           【 
          
         
           假 
          
         
           设 
          
         
           忽 
          
         
           略 
          
         
           偏 
          
         
           置 
          
         
           】 
          
         
        
       
      
        \color{red}{【假设忽略偏置】} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em; vertical-align: 0em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">【</span><span class="mord cjk_fallback" style="color: red;">假</span><span class="mord cjk_fallback" style="color: red;">设</span><span class="mord cjk_fallback" style="color: red;">忽</span><span class="mord cjk_fallback" style="color: red;">略</span><span class="mord cjk_fallback" style="color: red;">偏</span><span class="mord cjk_fallback" style="color: red;">置</span><span class="mord cjk_fallback" style="color: red;">】</span></span></span></span></span></span><br> 全连接FC1计算：计算对应某一个结点的输出，将该节点与上一层某一个结点的权重与输入对应节点数值相乘，再求和</p> 
<ul><li><code>FC1参数：</code>25088*4096=102760448</li></ul> 
<p>下层使用7*7的卷积核、stride=1，4096个卷积核的一个<mark>卷积层</mark></p> 
<ul><li><code>Conv参数：</code>7<em>7</em>512*4096=102760448</li></ul> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           一 
          
         
           个 
          
         
           卷 
          
         
           积 
          
         
           核 
          
         
           和 
          
         
           F 
          
         
           C 
          
         
           1 
          
         
           一 
          
         
           个 
          
         
           节 
          
         
           点 
          
         
           参 
          
         
           数 
          
         
           量 
          
         
           一 
          
         
           样 
          
         
        
       
      
        \color{red}{一个卷积核和FC1一个节点参数量一样} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">一</span><span class="mord cjk_fallback" style="color: red;">个</span><span class="mord cjk_fallback" style="color: red;">卷</span><span class="mord cjk_fallback" style="color: red;">积</span><span class="mord cjk_fallback" style="color: red;">核</span><span class="mord cjk_fallback" style="color: red;">和</span><span class="mord mathdefault" style="margin-right: 0.13889em; color: red;">F</span><span class="mord mathdefault" style="margin-right: 0.07153em; color: red;">C</span><span class="mord" style="color: red;">1</span><span class="mord cjk_fallback" style="color: red;">一</span><span class="mord cjk_fallback" style="color: red;">个</span><span class="mord cjk_fallback" style="color: red;">节</span><span class="mord cjk_fallback" style="color: red;">点</span><span class="mord cjk_fallback" style="color: red;">参</span><span class="mord cjk_fallback" style="color: red;">数</span><span class="mord cjk_fallback" style="color: red;">量</span><span class="mord cjk_fallback" style="color: red;">一</span><span class="mord cjk_fallback" style="color: red;">样</span></span></span></span></span></span>，一共4096个卷积核，FC也是4096个节点。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           【 
          
         
           不 
          
         
           忽 
          
         
           略 
          
         
           偏 
          
         
           置 
          
         
           的 
          
         
           正 
          
         
           常 
          
         
           卷 
          
         
           积 
          
         
           操 
          
         
           作 
          
         
           ， 
          
         
           4096 
          
         
           个 
          
         
           卷 
          
         
           积 
          
         
           核 
          
         
           应 
          
         
           该 
          
         
           有 
          
         
           4096 
          
         
           个 
          
         
           偏 
          
         
           置 
          
         
           项 
          
         
           】 
          
         
        
       
      
        \color{red}{【不忽略偏置的正常卷积操作，4096个卷积核应该有4096个偏置项】} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">【</span><span class="mord cjk_fallback" style="color: red;">不</span><span class="mord cjk_fallback" style="color: red;">忽</span><span class="mord cjk_fallback" style="color: red;">略</span><span class="mord cjk_fallback" style="color: red;">偏</span><span class="mord cjk_fallback" style="color: red;">置</span><span class="mord cjk_fallback" style="color: red;">的</span><span class="mord cjk_fallback" style="color: red;">正</span><span class="mord cjk_fallback" style="color: red;">常</span><span class="mord cjk_fallback" style="color: red;">卷</span><span class="mord cjk_fallback" style="color: red;">积</span><span class="mord cjk_fallback" style="color: red;">操</span><span class="mord cjk_fallback" style="color: red;">作</span><span class="mord cjk_fallback" style="color: red;">，</span><span class="mord" style="color: red;">4</span><span class="mord" style="color: red;">0</span><span class="mord" style="color: red;">9</span><span class="mord" style="color: red;">6</span><span class="mord cjk_fallback" style="color: red;">个</span><span class="mord cjk_fallback" style="color: red;">卷</span><span class="mord cjk_fallback" style="color: red;">积</span><span class="mord cjk_fallback" style="color: red;">核</span><span class="mord cjk_fallback" style="color: red;">应</span><span class="mord cjk_fallback" style="color: red;">该</span><span class="mord cjk_fallback" style="color: red;">有</span><span class="mord" style="color: red;">4</span><span class="mord" style="color: red;">0</span><span class="mord" style="color: red;">9</span><span class="mord" style="color: red;">6</span><span class="mord cjk_fallback" style="color: red;">个</span><span class="mord cjk_fallback" style="color: red;">偏</span><span class="mord cjk_fallback" style="color: red;">置</span><span class="mord cjk_fallback" style="color: red;">项</span><span class="mord cjk_fallback" style="color: red;">】</span></span></span></span></span></span><br> <img src="https://images2.imgbox.com/68/72/KdYEM1yh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="PS_35"></a>PS：全连接层</h3> 
<p>全连接层的输入是一维数组，多维数组需先进行Flatten进行一维化处理，然后连接全连接层。全连接层的每一个结点都与上一层的所有结点相连，用来把前边提取到的特征综合起来。由于其全相连的特性，一般全连接层的参数也是最多的。全连接图结构如下：<br> <img src="https://images2.imgbox.com/9a/65/IaMHeBNW_o.png" alt="在这里插入图片描述"><br> 其中，x1、x2、x3为全连接层的输入，a1、a2、a3为输出，有<br> <img src="https://images2.imgbox.com/a5/8d/H6KgUTsW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_40"></a>全连接层参数计算</h4> 
<p>权值参数=输入一维数组大小*全连接层输出结点数<br> 偏置参数b=全连接层输出结点数</p> 
<p><strong>eg:</strong><br> 输入有[5044]个神经元结点，输出有500个结点，则一共需要5044*500=400000个权值参数W和500个偏置参数b</p> 
<h3><a id="_46"></a>卷积和全连接层</h3> 
<p>卷积跟全连接都是一个点乘的操作，区别在于卷积是作用在一个局部的区域，而全连接是对于整个输入而言，那么只要把卷积作用的区域扩大为整个输入，那就变成全连接了，我就不给出形式化定义了。所以我们只需要把卷积核变成跟输入的一个map的大小一样就可以了，这样的话就相当于使得卷积跟全连接层的参数一样多。<br> eg:输入是224x224x3 的图像，假设经过变换之后最后一层是[7x7x512]的，那么传统的方法应该将其展平成为一个7x7x512长度的一层，然后做全连接层，假设全连接层为4096×1000层的（假设有1000个分类结果）。 那么用1×1卷积核怎么做呢，因为1×1卷积核相当于在不同channel之间做线性变换，所以：</p> 
<p>先选择7×7的卷积核，输出层特征层数为4096层，这样得到一个[1×1×4096]层的<br> 然后再选择用1×1卷积核，输出层数为1000层，这样得到一个[1×1×1000]层这样就搞定了。</p> 
<h2><a id="FCN32s16s8s_52"></a>四、FCN-32s、16s、8s的区别</h2> 
<p><img src="https://images2.imgbox.com/b0/70/h2ncN5zm_o.png" alt="在这里插入图片描述"><br> 上采样倍率为32的模型对应的就是FCN-32s，16s、8s同理。</p> 
<h3><a id="FCN32s_55"></a>FCN-32s</h3> 
<p>FCN原论文中backbone的第一个卷积层padding=100，为了防止图片过小（例如192<em>192）后面的卷积层会报错。<br> 如果图片小于32</em>32的话在卷积过程就会报错。<br> <mark>但是没必要设置，只要输入图片大小大于32*32，我们就可以将padding设置为3。</mark><br> <img src="https://images2.imgbox.com/df/86/islsGfkt_o.png" alt="在这里插入图片描述"><br> 对于<code>FCN-32s</code>：</p> 
<ul><li> <p>vgg16 backbone输出的特征图大小就为h/32，w/32，512。<mark>高度宽度变为原图的1/32。</mark></p> </li><li> <p><code>之后经过FC6层：</code>由于我们将FC6卷积层的padding设置为3、卷积核大小7*7，通过FC6之后将不会改变特征图的高和宽；且我们使用了4096个卷积核，所以这里就得到了4096个2D特征图。</p> </li><li> <p><code>经过FC7：</code>使用了1*1大小的卷积核，步距也为1，所以输出特征图shape也不会发生变化。</p> </li><li> <p><code>之后经过卷积核大小为1*1的卷积层：</code>它的卷积核的个数和我们的分类类别数一样（包含背景，对于voc为20类+1背景），将特征图通道数变为num_cls。</p> </li><li> <p><code>之后通过一个转置卷积：</code>这里的s32我们会将特征图上采样32倍【<mark>原论文中使用的是双线性插值</mark>】，得到特征图大小变为h，w，num_cls。</p> </li></ul> 
<p>之后特征图经过一个softmax处理就能得到针对每一个pixel的预测类别。<br> 前面的backbone使用的是vgg16的预训练权重，整个结构十分简单，但是效果还是非常不错的。<br> <img src="https://images2.imgbox.com/9b/1b/m0ughDmf_o.png" alt="在这里插入图片描述"><br> 其实这里的转置卷积在原论文中其实是将参数给冻结住了，冻结住意味着其实它就是一个简单的双线性卷积了。</p> 
<ul><li> <p>所以这里其实可以不使用转置卷积，可以直接使用深度学习框架提供给我们的双线性插值方法。</p> </li><li> <p><code>为什么会冻结呢？</code><mark>作者说冻结不冻结作者觉得结果好像没有什么差别，而且冻结参数会少一些。up主觉得冻结不冻节效果一般的原因是这里的上采样倍率太大了，有点强人所难的感觉。有兴趣的可以看一下u-net中的上采样率是多少。</mark></p> </li></ul> 
<h3><a id="FCN16s_77"></a>FCN-16s</h3> 
<p><img src="https://images2.imgbox.com/72/4e/6jD514UG_o.png" alt="在这里插入图片描述"></p> 
<p>FC6、FC7、Conv2d核32s的一样。<br> 不同点：</p> 
<ul><li>转置卷积上采样率变为了2倍，之后高和宽变为1/16</li><li>下面分支经过maxpool4之后变也为1/16，通道数为512；后接上了一个1*1卷积、卷积核数量为num_cls、步长为1，得到特征图大小1/16、通道数变为num_cls</li><li>之后进行一个相加操作，转置卷积上采样16倍就得到了原图大小h，w，num_cls</li></ul> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           【 
          
         
           F 
          
         
           C 
          
         
           N 
          
         
           − 
          
         
           16 
          
         
           s 
          
         
           中 
          
         
           融 
          
         
           合 
          
         
           了 
          
         
           来 
          
         
           自 
          
         
           m 
          
         
           a 
          
         
           x 
          
         
           p 
          
         
           o 
          
         
           o 
          
         
           l 
          
         
           4 
          
         
           的 
          
         
           信 
          
         
           息 
          
         
           】 
          
         
        
       
      
        \color{red}{【FCN-16s中融合了来自maxpool4的信息】} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">【</span><span class="mord mathdefault" style="margin-right: 0.13889em; color: red;">F</span><span class="mord mathdefault" style="margin-right: 0.07153em; color: red;">C</span><span class="mord mathdefault" style="margin-right: 0.10903em; color: red;">N</span><span class="mspace" style="color: red; margin-right: 0.222222em;"></span><span class="mbin" style="color: red;">−</span><span class="mspace" style="color: red; margin-right: 0.222222em;"></span><span class="mord" style="color: red;">1</span><span class="mord" style="color: red;">6</span><span class="mord mathdefault" style="color: red;">s</span><span class="mord cjk_fallback" style="color: red;">中</span><span class="mord cjk_fallback" style="color: red;">融</span><span class="mord cjk_fallback" style="color: red;">合</span><span class="mord cjk_fallback" style="color: red;">了</span><span class="mord cjk_fallback" style="color: red;">来</span><span class="mord cjk_fallback" style="color: red;">自</span><span class="mord mathdefault" style="color: red;">m</span><span class="mord mathdefault" style="color: red;">a</span><span class="mord mathdefault" style="color: red;">x</span><span class="mord mathdefault" style="color: red;">p</span><span class="mord mathdefault" style="color: red;">o</span><span class="mord mathdefault" style="color: red;">o</span><span class="mord mathdefault" style="margin-right: 0.01968em; color: red;">l</span><span class="mord" style="color: red;">4</span><span class="mord cjk_fallback" style="color: red;">的</span><span class="mord cjk_fallback" style="color: red;">信</span><span class="mord cjk_fallback" style="color: red;">息</span><span class="mord cjk_fallback" style="color: red;">】</span></span></span></span></span></span></p> 
<p><mark>须知</mark>：vgg16经过mxpool3之后特征图大小下采样率为8，经过maxpool4后下采样率为16。<br> <img src="https://images2.imgbox.com/49/74/hGZZzXpm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="FCN8s_91"></a>FCN-8s</h3> 
<p><img src="https://images2.imgbox.com/99/4b/zbnRDRJw_o.png" alt="在这里插入图片描述"></p> 
<p>不同点：</p> 
<ul><li>8s还利用了来自于mxpool3的信息，经过16s类似的1*1卷积层后得到一个1/8，通道数为num_cls的特征图；</li><li>FCN-16s上两层后得到的1/16特征图，经过一个转置卷积上采样，采样率为2倍就能得到一个和maxpool3输出尺寸一样的1/8的特征图</li><li>一块进行一个相同位置元素的相加操作【进一步的融合】，最后进行一个上采样倍率为8的转置卷积就能得到一个和原图大小一样的特征图大小h，w，num_cls。</li></ul> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           【 
          
         
           由 
          
         
           此 
          
         
           可 
          
         
           见 
          
         
           ， 
          
         
           F 
          
         
           C 
          
         
           N 
          
         
           − 
          
         
           16 
          
         
           s 
          
         
           和 
          
         
           F 
          
         
           C 
          
         
           N 
          
         
           − 
          
         
           8 
          
         
           s 
          
         
           融 
          
         
           合 
          
         
           了 
          
         
           一 
          
         
           个 
          
         
           底 
          
         
           层 
          
         
           的 
          
         
           信 
          
         
           息 
          
         
           ； 
          
         
           而 
          
         
           F 
          
         
           C 
          
         
           N 
          
         
           32 
          
         
           s 
          
         
           是 
          
         
           最 
          
         
           简 
          
         
           单 
          
         
           的 
          
         
           ， 
          
         
           它 
          
         
           没 
          
         
           有 
          
         
           融 
          
         
           合 
          
         
           底 
          
         
           层 
          
         
           信 
          
         
           息 
          
         
           】 
          
         
        
       
      
        \color{red}{【由此可见，FCN-16s和FCN-8s融合了一个底层的信息；而FCN32s是最简单的，它没有融合底层信息】} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">【</span><span class="mord cjk_fallback" style="color: red;">由</span><span class="mord cjk_fallback" style="color: red;">此</span><span class="mord cjk_fallback" style="color: red;">可</span><span class="mord cjk_fallback" style="color: red;">见</span><span class="mord cjk_fallback" style="color: red;">，</span><span class="mord mathdefault" style="margin-right: 0.13889em; color: red;">F</span><span class="mord mathdefault" style="margin-right: 0.07153em; color: red;">C</span><span class="mord mathdefault" style="margin-right: 0.10903em; color: red;">N</span><span class="mspace" style="color: red; margin-right: 0.222222em;"></span><span class="mbin" style="color: red;">−</span><span class="mspace" style="color: red; margin-right: 0.222222em;"></span><span class="mord" style="color: red;">1</span><span class="mord" style="color: red;">6</span><span class="mord mathdefault" style="color: red;">s</span><span class="mord cjk_fallback" style="color: red;">和</span><span class="mord mathdefault" style="margin-right: 0.13889em; color: red;">F</span><span class="mord mathdefault" style="margin-right: 0.07153em; color: red;">C</span><span class="mord mathdefault" style="margin-right: 0.10903em; color: red;">N</span><span class="mspace" style="color: red; margin-right: 0.222222em;"></span><span class="mbin" style="color: red;">−</span><span class="mspace" style="color: red; margin-right: 0.222222em;"></span><span class="mord" style="color: red;">8</span><span class="mord mathdefault" style="color: red;">s</span><span class="mord cjk_fallback" style="color: red;">融</span><span class="mord cjk_fallback" style="color: red;">合</span><span class="mord cjk_fallback" style="color: red;">了</span><span class="mord cjk_fallback" style="color: red;">一</span><span class="mord cjk_fallback" style="color: red;">个</span><span class="mord cjk_fallback" style="color: red;">底</span><span class="mord cjk_fallback" style="color: red;">层</span><span class="mord cjk_fallback" style="color: red;">的</span><span class="mord cjk_fallback" style="color: red;">信</span><span class="mord cjk_fallback" style="color: red;">息</span><span class="mord cjk_fallback" style="color: red;">；</span><span class="mord cjk_fallback" style="color: red;">而</span><span class="mord mathdefault" style="margin-right: 0.13889em; color: red;">F</span><span class="mord mathdefault" style="margin-right: 0.07153em; color: red;">C</span><span class="mord mathdefault" style="margin-right: 0.10903em; color: red;">N</span><span class="mord" style="color: red;">3</span><span class="mord" style="color: red;">2</span><span class="mord mathdefault" style="color: red;">s</span><span class="mord cjk_fallback" style="color: red;">是</span><span class="mord cjk_fallback" style="color: red;">最</span><span class="mord cjk_fallback" style="color: red;">简</span><span class="mord cjk_fallback" style="color: red;">单</span><span class="mord cjk_fallback" style="color: red;">的</span><span class="mord cjk_fallback" style="color: red;">，</span><span class="mord cjk_fallback" style="color: red;">它</span><span class="mord cjk_fallback" style="color: red;">没</span><span class="mord cjk_fallback" style="color: red;">有</span><span class="mord cjk_fallback" style="color: red;">融</span><span class="mord cjk_fallback" style="color: red;">合</span><span class="mord cjk_fallback" style="color: red;">底</span><span class="mord cjk_fallback" style="color: red;">层</span><span class="mord cjk_fallback" style="color: red;">信</span><span class="mord cjk_fallback" style="color: red;">息</span><span class="mord cjk_fallback" style="color: red;">】</span></span></span></span></span></span>在网上看到最多的是FCN-32的实现。</p> 
<h2><a id="_101"></a>五、损失计算</h2> 
<p><img src="https://images2.imgbox.com/9e/35/oCx6aJdJ_o.png" alt="在这里插入图片描述"><br> 针对每一个pixel都会去计算它所对应的一个Cross Entropy Loss，然后将所有pixel的交叉熵损失进行一个求平均操作就得到了一个我们网络的最终的一个损失</p> 
<h2><a id="_104"></a>六、语义分割评价指标</h2> 
<p><img src="https://images2.imgbox.com/b5/0a/CogODuUB_o.png" alt="在这里插入图片描述"></p> 
<p>见前言：<a href="https://www.bilibili.com/video/BV1ev411P7dR/?spm_id_from=333.788&amp;vd_source=a0d4f7000e77468aec70dc618794d26f" rel="nofollow">语义分割前沿</a></p> 
<h2><a id="_109"></a>七、代码实现</h2> 
<p><img src="https://images2.imgbox.com/bd/2b/4GB4KVO8_o.png" alt="在这里插入图片描述"><br> ResNet-50中先经过conv1 7*7的一个卷积</p> 
<ul><li>conv_2：3*3的一个最大池化下采样，再接上3个残差块（对应右图layer1）</li><li>conv_3：4个残差块（对应layer2）</li></ul> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           不 
          
         
           同 
          
         
           的 
          
         
           地 
          
         
           方 
          
         
           ： 
          
         
        
       
      
        \color{red}{不同的地方：} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em; vertical-align: 0em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">不</span><span class="mord cjk_fallback" style="color: red;">同</span><span class="mord cjk_fallback" style="color: red;">的</span><span class="mord cjk_fallback" style="color: red;">地</span><span class="mord cjk_fallback" style="color: red;">方</span><span class="mord cjk_fallback" style="color: red;">：</span></span></span></span></span></span></p> 
<ul><li>layer3：这里也有6个残差结构，1个Bottleneck1+5个Bottleneck2</li><li>layer4：3个残差结构，1个Bottleneck1+2个Bottleneck2</li></ul> 
<p><mark>Bottleneck1：</mark></p> 
<ul><li> <p>将残差连接的2*2卷积层步距改为1，原来resnet这个分支会进行一个下采样将高和宽缩短为一半，【这里因为语义分割中下采样倍率过大的话，再还原成原图后，这里的效果其实会受影响，所以我们这里就没有必要再做一个下采样了。】</p> </li><li> <p>此外主干分支3*3卷积的步距也从2改为了1，同时引入了r参数，即膨胀系数。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/e8/00/j1mR97k7_o.png" alt="在这里插入图片描述"><br> <mark>Bottleneck2：</mark><br> <img src="https://images2.imgbox.com/c6/22/GpOlj2VL_o.png" alt="在这里插入图片描述"><br> 接下来通过FCN Head模块：3<em>3卷积层缩小通道为原来的1/4【2048-512】，再通过一个dropout和一个1</em>1卷积层，这里1<em>1卷积层调整特征层的channel为分割类别中的类别个数。<br> 最后经过双线性插值还原特征图大小到原图。【图例：输入480</em>480，上采样也到480*480】<br> <img src="https://images2.imgbox.com/9c/cf/kw0HnhLL_o.png" alt="在这里插入图片描述"></p> 
<p>layer3中引出的一条FCN Head，官方回答：为了防止误差梯度没法传递到网络浅层，这里就引入了一个辅助分类器。和google net中辅助分类器是差不多的。<br> 训练的时候是可以使用辅助分类器件的【可用可不用，都可以试一下】，但是最后去预测或者部署到正式环境的时候只用主干的output，不用aux output。<br> <img src="https://images2.imgbox.com/89/a1/1eCJQvbA_o.png" alt="在这里插入图片描述"><br> up主的代码地址：<a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_segmentation/fcn">https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_segmentation/fcn</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2b7e2fd3ac5d712b81ce5db557a9232/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于vant UI设计一个下拉选择跟搜索功能的组件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/caf176a923db057dcd48adf4259d8d38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML .CSS实现购物车（cart）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>