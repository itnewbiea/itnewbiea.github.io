<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是迭代器，Python迭代器及其用法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么是迭代器，Python迭代器及其用法" />
<meta property="og:description" content="前面章节中，已经对列表（list）、元组（tuple）、字典（dict）、集合（set）这些序列式容器做了详细的介绍。值得一提的是，这些序列式容器有一个共同的特性，它们都支持使用 for 循环遍历存储的元素，都是可迭代的，因此它们又有一个别称，即迭代器。
从字面来理解，迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这​ 些 Python 提 ​供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。
我们已经学会了如何自定义一个序列类，但该序列类对象并不支持迭代，因此还不能称之为迭代器。如果要自定义实现一个迭代器，则类中必须实现如下 2 个方法：
__next__(self)：返回容器的下一个元素。__iter__(self)：该方法返回一个迭代器（iterator）。 例如，下面程序自定义了一个简易的列表容器迭代器，支持迭代：
class listDemo:def __init__(self):self.__date=[]self.__step = 0def __next__(self):if self.__step &lt;= 0:raise StopIterationself.__step -= 1#返回下一个元素return self.__date[self.__step]def __iter__(self):#实例对象本身就是迭代器对象，因此直接返回 self 即可return self#添加元素def __setitem__(self,key,value):self.__date.insert(key,value)self.__step &#43;= 1mylist = listDemo()mylist[0]=1mylist[1]=2for i in mylist:print (i) 程序执行结果为：
2
1
除此之外，Python 内置的 iter() 函数也会返回一个迭代器，该函数的语法格式如下：
iter(obj[, sentinel])
其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象，具体功能后面会讲。
可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加 __call__() 方法，就可以将该类的实例对象编程可调用对象。有关 __call__() 方法，可阅读《Python __call__()》做详细了解。
我们常用的是仅有 1 个参数的 iter() 函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的 __next__() 方法即可实现迭代。例如；
# 将列表转换为迭代器myIter = iter([1, 2, 3])# 依次获取迭代器的下一个元素print(myIter." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e03ce7ddf63730a00782e914e23f9264/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-28T20:29:27+08:00" />
<meta property="article:modified_time" content="2023-10-28T20:29:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是迭代器，Python迭代器及其用法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前面章节中，已经对列表（list）、元组（tuple）、字典（dict）、集合（set）这些序列式容器做了详细的介绍。值得一提的是，这些序列式容器有一个共同的特性，它们都支持使用 for 循环遍历存储的元素，都是可迭代的，因此它们又有一个别称，即迭代器。<br><br> 从字面来理解，迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这​ 些 Python 提 ​供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。<br><br> 我们已经学会了如何自定义一个序列类，但该序列类对象并不支持迭代，因此还不能称之为迭代器。如果要自定义实现一个迭代器，则类中必须实现如下 2 个方法：</p> 
<ol><li>__next__(self)：返回容器的下一个元素。</li><li>__iter__(self)：该方法返回一个迭代器（iterator）。</li></ol> 
<p><br> 例如，下面程序自定义了一个简易的列表容器迭代器，支持迭代：</p> 
<pre></pre> 
<ol><li>class listDemo:</li><li>def __init__(self):</li><li>self.__date=[]</li><li>self.__step = 0</li><li>def __next__(self):</li><li>if self.__step &lt;= 0:</li><li>raise StopIteration</li><li>self.__step -= 1</li><li>#返回下一个元素</li><li>return self.__date[self.__step]</li><li>def __iter__(self):</li><li>#实例对象本身就是迭代器对象，因此直接返回 self 即可</li><li>return self</li><li>#添加元素</li><li>def __setitem__(self,key,value):</li><li>self.__date.insert(key,value)</li><li>self.__step += 1</li><li>mylist = listDemo()</li><li>mylist[0]=1</li><li>mylist[1]=2</li><li>for i in mylist:</li><li>print (i)</li></ol> 
<p>程序执行结果为：</p> 
<p>2<br> 1</p> 
<p><br> 除此之外，Python 内置的 iter() 函数也会返回一个迭代器，该函数的语法格式如下：</p> 
<p>iter(obj[, sentinel])</p> 
<p>其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象，具体功能后面会讲。</p> 
<blockquote> 
 <p>可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加 __call__() 方法，就可以将该类的实例对象编程可调用对象。有关 __call__() 方法，可阅读《<a href="https://c.biancheng.net/view/2380.html" rel="nofollow" title="Python __call__()">Python __call__()</a>》做详细了解。</p> 
</blockquote> 
<p>我们常用的是仅有 1 个参数的 iter() 函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的 __next__() 方法即可实现迭代。例如；</p> 
<pre></pre> 
<ol><li># 将列表转换为迭代器</li><li>myIter = iter([1, 2, 3])</li><li># 依次获取迭代器的下一个元素</li><li>print(myIter.__next__())</li><li>print(myIter.__next__())</li><li>print(myIter.__next__())</li><li>print(myIter.__next__())</li></ol> 
<p>运行结果为：</p> 
<p>1<br> 2<br> 3<br> Traceback (most recent call last):<br>   File "C:\Users\mengma\Desktop\demo.py", line 7, in &lt;module&gt;<br>     print(myIter.__next__())<br> StopIteration</p> 
<blockquote> 
 <p>另外，也可以使用 next() 内置函数来迭代，即 next(myIter)，和 __next__() 方法是完全一样的。</p> 
</blockquote> 
<p>从程序的执行结果可以看出，当迭代完存储的所有元素之后，如果继续迭代，则 __next__() 方法会抛出 StopIteration 异常。<br><br> 这里介绍 iter() 函数第 2 个参数的作用，如果使用该参数，则要求第一个 obj 参数必须传入可调用对象（可以不支持迭代），这样当使用返回的迭代器调用 __next__() 方法时，它会通过执行 obj() 调用 __call__() 方法，如果该方法的返回值和第 2 个参数值相同，则输出 StopInteration 异常；反之，则输出 __call__() 方法的返回值。<br><br> 例如，修改 listDemo 类如下所示：</p> 
<pre></pre> 
<ol><li>class listDemo:</li><li>def __init__(self):</li><li>self.__date=[]</li><li>self.__step = 0</li><li><li>def __setitem__(self,key,value):</li><li>self.__date.insert(key,value)</li><li>self.__step += 1</li><li>#是该类实例对象成为可调用对象</li><li>def __call__(self):</li><li>self.__step-=1</li><li>return self.__date[self.__step]</li><li><li>mylist = listDemo()</li><li>mylist[0]=1</li><li>mylist[1]=2</li><li>#将 mylist 变为迭代器</li><li>a = iter(mylist,1)</li><li>print(a.__next__())</li><li>print(a.__next__())</li></ol> 
<p>程序执行结果为：</p> 
<p>2<br> Traceback (most recent call last):<br>   File "D:\python3.6\1.py", line 20, in &lt;module&gt;<br>     print(a.__next__())<br> StopIteration</p> 
<p>输出结果中，之所以最终抛出 StopIteration 异常，是因为这里原本要输出的元素 1 和 iter() 函数的第 2 个参数相同。</p> 
<blockquote>
  迭代器本身是一个底层的特性和概念，在程序中并不常用，但它为生成器这一更有趣的特性提供了基础。有关生成器的相关知识，会在后续章节中介绍。 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43be102a147f09d7c2e90e91fe4067ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">正则表达式包含数字和字符匹配</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f628b791b08085287de095045eaaf78e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于单片机的温湿度和二氧化碳检测系统设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>