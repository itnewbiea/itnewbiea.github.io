<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【BZOJ】3053: The Closest M Points（kdtree） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【BZOJ】3053: The Closest M Points（kdtree）" />
<meta property="og:description" content="http://www.lydsy.com/JudgeOnline/problem.php?id=3053
本来是1a的QAQ。。。。
没看到有多组数据啊。。。。。斯巴达！！！！！！！！！！！！！！！！！
本题裸的kdtree，比上一题还要简单。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。
对于当前点，判断进入左或右子树，然后看答案是否能过分割线。。如果能，进入右或左子树。。。。。。。。。并且如果答案个数小于k，也要进入。。
然后就浪吧。。。。。。。。。。。
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;map&gt; using namespace std; typedef long long ll; #define rep(i, n) for(int i=0; i&lt;(n); &#43;&#43;i) #define for1(i,a,n) for(int i=(a);i&lt;=(n);&#43;&#43;i) #define for2(i,a,n) for(int i=(a);i&lt;(n);&#43;&#43;i) #define for3(i,a,n) for(int i=(a);i&gt;=(n);--i) #define for4(i,a,n) for(int i=(a);i&gt;(n);--i) #define CC(i,a) memset(i,a,sizeof(i)) #define read(a) a=getint() #define print(a) printf(&#34;%d&#34;, a) #define dbg(x) cout &lt;&lt; (#x) &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e384b36ae2b62be5bb8c50afdc082f18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-12-16T18:10:00+08:00" />
<meta property="article:modified_time" content="2014-12-16T18:10:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【BZOJ】3053: The Closest M Points（kdtree）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3053" rel="nofollow">http://www.lydsy.com/JudgeOnline/problem.php?id=3053</a></p> 
 <p>本来是1a的QAQ。。。。</p> 
 <p>没看到有多组数据啊。。。。。斯巴达！！！！！！！！！！！！！！！！！</p> 
 <p>本题裸的kdtree，比上一题还要简单。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</p> 
 <p>对于当前点，判断进入左或右子树，然后看答案是否能过分割线。。如果能，进入右或左子树。。。。。。。。。并且如果答案个数小于k，也要进入。。</p> 
 <p>然后就浪吧。。。。。。。。。。。</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
using namespace std;
typedef long long ll;
#define rep(i, n) for(int i=0; i&lt;(n); ++i)
#define for1(i,a,n) for(int i=(a);i&lt;=(n);++i)
#define for2(i,a,n) for(int i=(a);i&lt;(n);++i)
#define for3(i,a,n) for(int i=(a);i&gt;=(n);--i)
#define for4(i,a,n) for(int i=(a);i&gt;(n);--i)
#define CC(i,a) memset(i,a,sizeof(i))
#define read(a) a=getint()
#define print(a) printf("%d", a)
#define dbg(x) cout &lt;&lt; (#x) &lt;&lt; " = " &lt;&lt; (x) &lt;&lt; endl
#define error(x) (!(x)?puts("error"):0)
#define rdm(x, i) for(int i=ihead[x]; i; i=e[i].next)
inline const int getint() { int r=0, k=1; char c=getchar(); for(; c&lt;'0'||c&gt;'9'; c=getchar()) if(c=='-') k=-1; for(; c&gt;='0'&amp;&amp;c&lt;='9'; c=getchar()) r=r*10+c-'0'; return k*r; }

const int N=100005, D=5;
struct node *null;
struct node {
	node *c[2];
	int p[D];
	void set(int _p[D]) { memcpy(p, _p, sizeof(p)); c[0]=c[1]=null; }
	static void init() { null=new node(); null-&gt;c[0]=null-&gt;c[1]=null; CC(null-&gt;p, 0); }
};
struct dat {
	node *ptr;
	ll dis;
	bool operator&lt;(const dat &amp;a) const { return dis&lt;a.dis; }
};
priority_queue&lt;dat&gt; q;
struct kdtree {
	node T[N], *TI, *root;
	int now[D], di;
	node *newnode(int p[D]) { TI-&gt;set(p); return TI++; }
	kdtree() { di=0; TI=T; CC(now, 0); root=null; }
	static void init() { node::init(); }
	ll sqr(const ll &amp;a) { return a*a; }
	ll dis(node *x, int p[D]) {
		ll ret=0;
		rep(i, di) ret+=sqr(x-&gt;p[i]-p[i]);
		return ret;
	}
	void insert(node *&amp;x, int dep) {
		if(x==null) { x=newnode(now); return; }
		bool d=x-&gt;p[dep]&lt;now[dep];
		insert(x-&gt;c[d], (dep+1)%di);
	}
	void ins(int p[D]) { memcpy(now, p, sizeof now); insert(root, 0); }
	void ask(node *x, const int &amp;k, int dep) {
		if(x==null) return;
		static dat tp;
		tp.dis=dis(x, now); tp.ptr=x;
		q.push(tp); while((int)q.size()&gt;k) q.pop();
		bool d=x-&gt;p[dep]&lt;now[dep];
		ask(x-&gt;c[d], k, (dep+1)%di); if((int)q.size()&lt;k || q.top().dis&gt;sqr(now[dep]-x-&gt;p[dep])) ask(x-&gt;c[!d], k, (dep+1)%di);
	}
	void ask(int p[D], int k) {
		static node *dis[20];
		while(!q.empty()) q.pop();
		memcpy(now, p, sizeof now); ask(root, k, 0);
		printf("the closest %d points are:\n", k);
		int n=k;
		while((int)q.size()&gt;k) q.pop();
		while(n) dis[--n]=q.top().ptr, q.pop();
		rep(j, k) {
			printf("%d", dis[j]-&gt;p[0]);
			for2(i, 1, di) printf(" %d", dis[j]-&gt;p[i]); puts(""); 
		}
	}
	void clear() {
		root=null; TI=T; CC(now, 0); di=0;
	}
};
int p[D], di, n;
int main() {
	kdtree::init();
	kdtree a;
	while(~scanf("%d%d", &amp;n, &amp;di)) {
		a.clear();
		a.di=di;
		rep(i, n) { rep(k, di) read(p[k]); a.ins(p); }
		int t=getint();
		while(t--) {
			rep(k, di) read(p[k]);
			read(n);
			a.ask(p, n);
		}
	}
	return 0;
}
</code></pre> 
 </div> 
 <p>　　</p> 
 <p> </p> 
 <hr> 
 <p> </p> 
 <p> </p> 
 <h3>Description</h3> 
 <div> 
  <p>The course of Software Design and Development Practice is objectionable. ZLC is facing a serious problem .There are many points in K-dimensional space .Given a point. ZLC need to find out the closest m points. Euclidean distance is used as the distance metric between two points. The Euclidean distance between points p and q is the length of the line segment connecting them.In Cartesian coordinates, if p = (p1, p2,..., pn) and q = (q1, q2,..., qn) are two points in Euclidean n-space, then the distance from p to q, or from q to p is given by:<br>D(p,q)=D(q,p)=sqrt((q1-p1)^2+(q2-p2)^2+(q3-p3)^2…+(qn-pn)^2<br>Can you help him solve this problem?</p> 
  <p> </p> 
  <p> </p> 
  <p><br>软工学院的课程很讨厌！ZLC同志遇到了一个头疼的问题：在K维空间里面有许多的点，对于某些给定的点，ZLC需要找到和它最近的m个点。</p> 
  <p>（这里的距离指的是欧几里得距离：D(p, q) = D(q, p) =  sqrt((q1 - p1) ^ 2 + (q2 - p2) ^ 2 + (q3 - p3) ^ 2 + ... + (qn - pn) ^ 2)</p> 
  <p>ZLC要去打Dota，所以就麻烦你帮忙解决一下了……</p> 
  <p>【Input】</p> 
  <p>第一行，两个非负整数：点数n(1 &lt;= n &lt;= 50000)，和维度数k(1 &lt;= k &lt;= 5)。<br>接下来的n行，每行k个整数，代表一个点的坐标。<br>接下来一个正整数：给定的询问数量t(1 &lt;= t &lt;= 10000)<br>下面2*t行：<br>　　第一行，k个整数：给定点的坐标<br>　　第二行：查询最近的m个点(1 &lt;= m &lt;= 10)</p> 
  <p>所有坐标的绝对值不超过10000。<br>有多组数据！</p> 
  <p>【Output】</p> 
  <p>对于每个询问，输出m+1行：<br>第一行："the closest m points are:" m为查询中的m<br>接下来m行每行代表一个点，按照从近到远排序。</p> 
  <p>保证方案唯一，下面这种情况不会出现：<br>2 2<br>1 1<br>3 3<br>1<br>2 2<br>1</p> 
  <p> </p> 
  <p> </p> 
 </div> 
 <h3>Input</h3> 
 <div> 
  <p>In the first line of the text file .there are two non-negative integers n and K. They denote respectively: the number of points, 1 &lt;= n &lt;= 50000, and the number of Dimensions,1 &lt;= K &lt;= 5. In each of the following n lines there is written k integers, representing the coordinates of a point. This followed by a line with one positive integer t, representing the number of queries,1 &lt;= t &lt;=10000.each query contains two lines. The k integers in the first line represent the given point. In the second line, there is one integer m, the number of closest points you should find,1 &lt;= m &lt;=10. The absolute value of all the coordinates will not be more than 10000.<br>There are multiple test cases. Process to end of file.</p> 
 </div> 
 <h3>Output</h3> 
 <div> 
  <p>For each query, output m+1 lines:<br>The first line saying :”the closest m points are:” where m is the number of the points.<br>The following m lines representing m points ,in accordance with the order from near to far<br>It is guaranteed that the answer can only be formed in one ways. The distances from the given point to all the nearest m+1 points are different. That means input like this:<br>2 2<br>1 1<br>3 3<br>1<br>2 2<br>1<br>will not exist.</p> 
 </div> 
 <h3>Sample Input</h3> 
 <div>
   3 2 
  <br> 1 1 
  <br> 1 3 
  <br> 3 4 
  <br> 2 
  <br> 2 3 
  <br> 2 
  <br> 2 3 
  <br> 1 
  <br> 
 </div> 
 <h3>Sample Output</h3> 
 <div>
   the closest 2 points are: 
  <br> 1 3 
  <br> 3 4 
  <br> the closest 1 points are: 
  <br> 1 3 
  <br> 
 </div> 
 <h3>HINT</h3> 
 <div>
     
 </div> 
 <h3>Source</h3> 
 <div> 
  <p><a href="http://www.lydsy.com/JudgeOnline/problemset.php?search=k-d%20tree" rel="nofollow">k-d tree</a></p> 
  <p> </p> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/iwtwiioi/p/4167748.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ebeb538c2773df59ec1b87d27ac65686/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">maven hadoop2.x库依赖</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff7259098f0715be6ce1f54c73a85a8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js去除文本中的html标签</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>