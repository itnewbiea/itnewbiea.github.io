<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>asp.net viewstate原理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="asp.net viewstate原理" />
<meta property="og:description" content="由于http协议是无状态性的
客户端浏览器在与服务器端进行交互的时候，客户端向服务器端发送请求，服务器响应并处理请求，但由于http无状态性，所以服务器端并不知道上次给了客户端浏览器什么，所以客户端浏览器需要“记住”上次服务器端给予的值（如：input表单元素就是“记忆”到value中，而对于其他的值就要放到隐藏字段中，比如viewstate）,下次客户端浏览器再提交请求给服务器的时候（如：请在我原先的宽度基础上再增加10，就要把上次存到隐藏字段中的中再提交给服务器，让服务器“想起”上次给予客户端的值，并再此基础上增加10）。
如果要知道上一次的状态，一个方法是在对浏览器响应结束之前将状态信息保存到页面表单中，下次页面再向服务器发出请求的时候带上这些状态信息，这样服务器就能根据这些状态信息还原上次的状态了，类似于去看病时的病例本。
但是，状态信息保存到隐藏字段中有缺点：加大网站的流量，降低了访问的速度，机密数据保存到表单中会有数据欺骗等安全性问题。
下面举个例子：
Label文本值的自增,和TextBox值的自增，在这两个控件中值的自增就提现出来viewstate的作用
很简单的点击按钮加1的代码
我们查看源文件，发现html源文件里面有个hidden 元素，它的name 属性是“__VIEWSTATE,这里面就是一个viewstate的隐藏元素，里面使用序列化算法将隐藏内容存放到一个字符串中，我们使用ViewStateDecoder工具查看这个viewstate字符串，发现它存储的是label的值，而没有textbox的值
当我们禁用了viewstate之后（enableviewstate=&#34;false&#34;），我们发现，label的自增失败了，而textbox的自增不受任何影响，这说明，label需要将值存放到viewstate中，而textbox不需要将值存放到viewstate中。
就想上面我们所说的，viewstate是存储非表单域，非value值的容器，由于textbox解析成Html后就是一个input type=“text” value=&#34;&#34;,它是有value属性的，所以它的值存放到了value中，不需要用到viewstate 而label解析成html后它实际上是一个span 标签，是没有value属性来给它存放值的，所以它需要使用viewstate来存放它的值，在上述自增的例子中，label需要使用viewstate记住上次服务器返回给它的值，好让下次提交请求给服务器的时候，服务器能够“记忆”起它的值，然后再它的基础上&#43;1，
当然，即使是textbox(input)也只有存放到value中，才能够让服务器“记起”，要传递其它值，比如宽度，大小等，这也需要使用viewstate了。
在讲解viewstate原理中，input（textbox）版本值的自增和div(label)版本值的自增，能很好的阐述这个道理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/60896c1a5166daa049673afb2bee0ce6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-11-01T11:05:23+08:00" />
<meta property="article:modified_time" content="2012-11-01T11:05:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">asp.net viewstate原理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    由于http协议是无状态性的</p> 
<p>    客户端浏览器在与服务器端进行交互的时候，客户端向服务器端发送请求，服务器响应并处理请求，但由于http无状态性，所以服务器端并不知道上次给了客户端浏览器什么，所以客户端浏览器需要“记住”上次服务器端给予的值（如：input表单元素就是“记忆”到value中，而对于其他的值就要放到隐藏字段中，比如viewstate）,下次客户端浏览器再提交请求给服务器的时候（如：请在我原先的宽度基础上再增加10，就要把上次存到隐藏字段中的中再提交给服务器，让服务器“想起”上次给予客户端的值，并再此基础上增加10）。</p> 
<p>    如果要知道上一次的状态，一个方法是在对浏览器响应结束之前将状态信息保存到页面表单中，下次页面再向服务器发出请求的时候带上这些状态信息，这样服务器就能根据这些状态信息还原上次的状态了，类似于去看病时的病例本。</p> 
<p>    但是，状态信息保存到隐藏字段中有缺点：加大网站的流量，降低了访问的速度，机密数据保存到表单中会有数据欺骗等安全性问题。</p> 
<p>    下面举个例子：</p> 
<p>    Label文本值的自增,和TextBox值的自增，在这两个控件中值的自增就提现出来viewstate的作用</p> 
<p>    很简单的点击按钮加1的代码</p> 
<p>    <img alt="" src="https://images2.imgbox.com/cc/3c/69DuHgEF_o.jpg"></p> 
<p>    <img alt="" src="https://images2.imgbox.com/a7/36/WW5Iyh4R_o.jpg"></p> 
<p>    我们查看源文件，发现html源文件里面有个hidden 元素，它的name 属性是“__VIEWSTATE,这里面就是一个viewstate的隐藏元素，里面使用序列化算法将隐藏内容存放到一个字符串中，我们使用ViewStateDecoder工具查看这个viewstate字符串，发现它存储的是label的值，而没有textbox的值</p> 
<p>         <img alt="" src="https://images2.imgbox.com/55/73/y8oQKFZv_o.jpg"></p> 
<p><img alt="" src="https://images2.imgbox.com/96/8d/BSSlGoHT_o.jpg"></p> 
<p>   </p> 
<p> </p> 
<p> 当我们禁用了viewstate之后（enableviewstate="false"），我们发现，label的自增失败了，而textbox的自增不受任何影响，这说明，label需要将值存放到viewstate中，而textbox不需要将值存放到viewstate中。</p> 
<p>    就想上面我们所说的，viewstate是存储非表单域，非value值的容器，由于textbox解析成Html后就是一个input type=“text” value="",它是有value属性的，所以它的值存放到了value中，不需要用到viewstate 而label解析成html后它实际上是一个span 标签，是没有value属性来给它存放值的，所以它需要使用viewstate来存放它的值，在上述自增的例子中，label需要使用viewstate记住上次服务器返回给它的值，好让下次提交请求给服务器的时候，服务器能够“记忆”起它的值，然后再它的基础上+1，</p> 
<p>   当然，即使是textbox(input)也只有存放到value中，才能够让服务器“记起”，要传递其它值，比如宽度，大小等，这也需要使用viewstate了。</p> 
<p>   在讲解viewstate原理中，input（textbox）版本值的自增和div(label)版本值的自增，能很好的阐述这个道理。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54a53a701685951f700e1b835667fea1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c#中的@符号</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f2b73b3400c7484eb428f77eaaf7693/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">asp.net cookie</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>