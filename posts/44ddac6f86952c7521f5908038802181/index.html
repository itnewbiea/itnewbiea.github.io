<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【题解】洛谷P2296 [NOIP2014TG] 寻找道路（SPFA&#43;DFS） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【题解】洛谷P2296 [NOIP2014TG] 寻找道路（SPFA&#43;DFS）" />
<meta property="og:description" content="题目来源：洛谷P2296
思路 一开始看还以为是一道水题 虽然本来就挺水的
本道题的难点在于如何判断是否路径上的点都会直接或者间接连着终点
我们需要在一开始多建一个反向图
然后从终点DFS回去 把路径上的点标记
DFS完之后遍历所有的点 如果当前点没有被标记 说明其不会直接或者间接连着终点
那么我们只需要把没有被标记的点在反向图中到达的点（也就是正向图中到达这个点的前一个点）标记为不计算在图内
PS：这里的标记数组要另外再建一个 如果直接改前面的数组会因为没有更新完就修改而多删除有用的点
这样我们就把所有的不需要遍历的点删除了
最后就是SPFA解决
代码 #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; #define maxn 100010 queue &lt;int&gt; q; int n,m,cnt2,cnt1,t,w,start,end; int h1[maxn],h2[maxn],dis[maxn]; bool f[maxn],vis[maxn],vis1[maxn];//f为spfa的判断 vis为反向图的判断 vis1删除点的判断 struct Edge { int to; int next; }e1[maxn*20],e2[maxn*20]; void add1(int u,int v) { e1[&#43;&#43;cnt1].to=v; e1[cnt1].next=h1[u]; h1[u]=cnt1; } void add2(int u,int v) { e2[&#43;&#43;cnt2].to=v; e2[cnt2].next=h2[u]; h2[u]=cnt2; } void dfs(int u) { vis[u]=1; for(int i=h2[u];i;i=e2[i].next) { int v=e2[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/44ddac6f86952c7521f5908038802181/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-26T21:33:00+08:00" />
<meta property="article:modified_time" content="2018-10-26T21:33:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【题解】洛谷P2296 [NOIP2014TG] 寻找道路（SPFA&#43;DFS）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>题目来源：<a href="https://www.luogu.org/problemnew/show/P2296" rel="nofollow">洛谷P2296</a></p> 
 <h4>思路</h4> 
 <p><span style="text-decoration:line-through;">一开始看还以为是一道水题 虽然本来就挺水的</span></p> 
 <p>本道题的难点在于如何判断是否路径上的点都会直接或者间接连着终点</p> 
 <p>我们需要在一开始多建一个<strong>反向图</strong></p> 
 <p>然后<strong>从终点DFS回去</strong> 把路径上的点标记</p> 
 <p>DFS完之后遍历所有的点 <strong>如果当前点没有被标记 说明其不会直接或者间接连着终点</strong></p> 
 <p>那么我们只需要把没有被标记的点在反向图中到达的点<strong>（也就是正向图中到达这个点的前一个点）标记为不计算在图内</strong></p> 
 <p><strong>PS：这里的标记数组要另外再建一个 如果直接改前面的数组会因为没有更新完就修改而多删除有用的点</strong></p> 
 <p>这样我们就把所有的不需要遍历的点删除了</p> 
 <p>最后就是SPFA解决</p> 
 <h4>代码</h4> 
 <div class="cnblogs_code"> 
  <pre>#include&lt;iostream&gt;<span style="color:#000000;">
#include</span>&lt;queue&gt;
<span style="color:#0000ff;">using</span> <span style="color:#0000ff;">namespace</span><span style="color:#000000;"> std;
</span><span style="color:#0000ff;">#define</span> maxn 100010 <span style="color:#000000;">
queue </span>&lt;<span style="color:#0000ff;">int</span>&gt;<span style="color:#000000;"> q;
</span><span style="color:#0000ff;">int</span><span style="color:#000000;"> n,m,cnt2,cnt1,t,w,start,end;
</span><span style="color:#0000ff;">int</span><span style="color:#000000;"> h1[maxn],h2[maxn],dis[maxn];
</span><span style="color:#0000ff;">bool</span> f[maxn],vis[maxn],vis1[maxn];<span style="color:#008000;">//</span><span style="color:#008000;">f为spfa的判断 vis为反向图的判断 vis1删除点的判断 </span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> Edge
{
    </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> to;
    </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> next;
}e1[maxn</span>*<span style="color:#800080;">20</span>],e2[maxn*<span style="color:#800080;">20</span><span style="color:#000000;">];
</span><span style="color:#0000ff;">void</span> add1(<span style="color:#0000ff;">int</span> u,<span style="color:#0000ff;">int</span><span style="color:#000000;"> v)
{
    e1[</span>++cnt1].to=<span style="color:#000000;">v;
    e1[cnt1].next</span>=<span style="color:#000000;">h1[u];
    h1[u]</span>=<span style="color:#000000;">cnt1;
}
</span><span style="color:#0000ff;">void</span> add2(<span style="color:#0000ff;">int</span> u,<span style="color:#0000ff;">int</span><span style="color:#000000;"> v)
{
    e2[</span>++cnt2].to=<span style="color:#000000;">v;
    e2[cnt2].next</span>=<span style="color:#000000;">h2[u];
    h2[u]</span>=<span style="color:#000000;">cnt2;
}
</span><span style="color:#0000ff;">void</span> dfs(<span style="color:#0000ff;">int</span><span style="color:#000000;"> u)
{
    vis[u]</span>=<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i=h2[u];i;i=<span style="color:#000000;">e2[i].next)
    {
        </span><span style="color:#0000ff;">int</span> v=<span style="color:#000000;">e2[i].to;
        </span><span style="color:#0000ff;">if</span>(!<span style="color:#000000;">vis[v]) dfs(v);
    }
}
</span><span style="color:#0000ff;">void</span> spfa()<span style="color:#008000;">//</span><span style="color:#008000;">常规spfa </span>
<span style="color:#000000;">{
    </span><span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i=<span style="color:#800080;">1</span>;i&lt;=n;i++) dis[i]=1e9+<span style="color:#800080;">7</span><span style="color:#000000;">;
    q.push(start);
    f[start]</span>=<span style="color:#800080;">1</span><span style="color:#000000;">;
    dis[start]</span>=<span style="color:#800080;">0</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">while</span>(!<span style="color:#000000;">q.empty())
    {
        </span><span style="color:#0000ff;">int</span> temp=<span style="color:#000000;">q.front();
        q.pop();
        f[temp]</span>=<span style="color:#800080;">0</span><span style="color:#000000;">;
        </span><span style="color:#0000ff;">if</span>(!vis[temp]) <span style="color:#0000ff;">continue</span><span style="color:#000000;">;
        </span><span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i=h1[temp];i;i=<span style="color:#000000;">e1[i].next)
        {
            </span><span style="color:#0000ff;">int</span> v=<span style="color:#000000;">e1[i].to;
            </span><span style="color:#0000ff;">if</span>(dis[v]&gt;dis[temp]+<span style="color:#800080;">1</span><span style="color:#000000;">)
            {
                dis[v]</span>=dis[temp]+<span style="color:#800080;">1</span><span style="color:#000000;">;
                </span><span style="color:#0000ff;">if</span>(!<span style="color:#000000;">f[v])
                {
                    f[v]</span>=<span style="color:#800080;">1</span><span style="color:#000000;">;
                    q.push(v);
                }
            }
        }
    }
}
</span><span style="color:#0000ff;">int</span><span style="color:#000000;"> main()
{
    cin</span>&gt;&gt;n&gt;&gt;<span style="color:#000000;">m;
    </span><span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i=<span style="color:#800080;">1</span>;i&lt;=m;i++<span style="color:#000000;">)
    {
        </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> x,y;
        cin</span>&gt;&gt;x&gt;&gt;<span style="color:#000000;">y;
        add1(x,y);</span><span style="color:#008000;">//</span><span style="color:#008000;">正向图 </span>
        add2(y,x);<span style="color:#008000;">//</span><span style="color:#008000;">反向图 </span>
<span style="color:#000000;">    }
    cin</span>&gt;&gt;start&gt;&gt;<span style="color:#000000;">end;
    dfs(end);</span><span style="color:#008000;">//</span><span style="color:#008000;">从终点DFS </span>
    <span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i=<span style="color:#800080;">1</span>;i&lt;=n;i++)<span style="color:#008000;">//</span><span style="color:#008000;">把不用的点删去 </span>
<span style="color:#000000;">    {
        </span><span style="color:#0000ff;">if</span>(!<span style="color:#000000;">vis[i])
        </span><span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> j=h2[i];j;j=<span style="color:#000000;">e2[j].next)
        {
            </span><span style="color:#0000ff;">int</span> v=<span style="color:#000000;">e2[j].to;
            vis1[v]</span>=<span style="color:#800080;">1</span>;<span style="color:#008000;">//</span><span style="color:#008000;">更改新建的数组 </span>
<span style="color:#000000;">        }
    }
    </span><span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i=<span style="color:#800080;">1</span>;i&lt;=n;i++<span style="color:#000000;">)
        </span><span style="color:#0000ff;">if</span>(vis1[i]==<span style="color:#800080;">1</span>) vis[i]=<span style="color:#800080;">0</span>;<span style="color:#008000;">//</span><span style="color:#008000;">更改不用遍历的点 </span>
<span style="color:#000000;">    spfa();
    </span><span style="color:#0000ff;">if</span>(dis[end]==1e9+<span style="color:#800080;">7</span><span style="color:#000000;">)
    cout</span>&lt;&lt;-<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">else</span><span style="color:#000000;">
    cout</span>&lt;&lt;<span style="color:#000000;">dis[end];
}</span></pre> 
 </div> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/BrokenString/p/9858861.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2224179547e016d6a58ca172c1c36abd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java通过身份证前17位计算出身份证最后一位    加权因子</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56c3f46a3f4a129fcc527af44466ce3c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Knative 简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>