<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代码随想录算法训练营Day14|二叉树理论基础及其递归遍历和迭代遍历 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="代码随想录算法训练营Day14|二叉树理论基础及其递归遍历和迭代遍历" />
<meta property="og:description" content="目录
二叉树理论基础
二叉树的种类
满二叉树
完全二叉树
二叉搜索树
平衡二叉搜索树
二叉树的存储方式
二叉树的遍历方式
二叉树的定义
二叉树的递归遍历
前序遍历（递归实现）
中序遍历（递归实现）
后序遍历（递归实现）
二叉树的迭代遍历
前序遍历（迭代法）
后序遍历（迭代法）
中序遍历（迭代法）
二叉树统一迭代法
中序遍历（标记法）
前序遍历（标记法）
后序遍历（标记法）
总结
二叉树理论基础 二叉树的种类 二叉树可分为满二叉树和完全二叉树，二叉搜索树和平衡二叉搜索树等。
满二叉树 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。若满二叉树的深度为k，则有2^k-1个节点。
完全二叉树 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置（从左到右节点连续）。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。
满二叉树是完全二叉树的一种特殊情况，堆也是一棵完全二叉树，同时保证父子节点的顺序关系。
二叉搜索树 前面两种树都是没有数值的，而二叉搜索树是有数值的，二叉搜索树是一个有序树。它具有以下特点：
若左子树不为空，则左子树上的所有节点值均小于根节点（中间节点）的值；若右子树不为空，则右子树上的所有节点值均大于根节点（中间节点）的值；它的左右字数也分别为二叉排序树，即满足以上两条。 平衡二叉搜索树 在二叉搜索树的基础上加上左右两个字数的高度差绝对值不超过1的条件。
C&#43;&#43;中map、set|、multimap、multiset的底层实现都是平衡二叉搜索树，map、set的增删时间复杂度都是logn（unordered_map，unordered_set底层实现是哈希表）。
二叉树的存储方式 二叉树可以链式存储，也可以顺序存储。
链式存储用指针，顺序存储用数组。用数组来存储二叉树时，若父节点的下标是i，则他的左孩子是i * 2 &#43; 1，右孩子就是i * 2 &#43; 2。但是一般用链式表示二叉树更方便。
二叉树的遍历方式 二叉树的两种遍历方式：
1.深度优先遍历：先往深走，遇到叶子节点再往回走。
2.广度优先遍历：一层一层地去遍历。
继续对两种遍历进行拓展：
深度优先遍历 前序遍历：中左右（递归法，迭代法）
中序遍历：左中右（递归法，迭代法）
后序遍历：左右中（递归法，迭代法）
广度优先遍历 层次遍历（迭代法）
在深度优先遍历中有三个顺序：前中后序，前中后指的是中间节点的遍历顺序。
在实现深度优先遍历时，经常使用递归的方式，栈也是递归的一种实现结构，因此前中后序遍历的逻辑也可以借助栈使用递归的方式实现。
而广度优先遍历的实现一般使用队列来实现。这是由队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层地遍历二叉树。
二叉树的定义 链式存储二叉树节点的定义方式如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/edbc3c316ddb4deec9536dc6cac3ab93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T16:21:07+08:00" />
<meta property="article:modified_time" content="2023-12-29T16:21:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代码随想录算法训练营Day14|二叉树理论基础及其递归遍历和迭代遍历</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80" rel="nofollow">二叉树理论基础</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB" rel="nofollow">二叉树的种类</a></p> 
<p id="%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">满二叉树</a></p> 
<p id="%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">完全二叉树</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" rel="nofollow">二叉搜索树</a></p> 
<p id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" rel="nofollow">平衡二叉搜索树</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F" rel="nofollow">二叉树的存储方式</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F" rel="nofollow">二叉树的遍历方式</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">二叉树的定义</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86" rel="nofollow">二叉树的递归遍历</a></p> 
<p id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89" rel="nofollow">前序遍历（递归实现）</a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89" rel="nofollow">中序遍历（递归实现）</a></p> 
<p id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89" rel="nofollow">后序遍历（递归实现）</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86" rel="nofollow">二叉树的迭代遍历</a></p> 
<p id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89" rel="nofollow">前序遍历（迭代法）</a></p> 
<p id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89" rel="nofollow">后序遍历（迭代法）</a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89" rel="nofollow">中序遍历（迭代法）</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95" rel="nofollow">二叉树统一迭代法</a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89" rel="nofollow">中序遍历（标记法）</a></p> 
<p id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89" rel="nofollow">前序遍历（标记法）</a></p> 
<p id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89" rel="nofollow">后序遍历（标记法）</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">二叉树理论基础</h3> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB">二叉树的种类</h4> 
<p>        二叉树可分为满二叉树和完全二叉树，二叉搜索树和平衡二叉搜索树等。</p> 
<h5 id="%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91">满二叉树</h5> 
<p>        满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。若满二叉树的深度为k，则有2^k-1个节点。</p> 
<h5 id="%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</h5> 
<p>        在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置（从左到右节点连续）。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</p> 
<p>        <strong>满二叉树是完全二叉树的一种特殊情况，堆也是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p> 
<h5 id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</h5> 
<p>        前面两种树都是没有数值的，而二叉搜索树是有数值的，<strong>二叉搜索树是一个有序树</strong>。它具有以下特点：</p> 
<ul><li>若左子树不为空，则左子树上的所有节点值均小于根节点（中间节点）的值；</li><li>若右子树不为空，则右子树上的所有节点值均大于根节点（中间节点）的值；</li><li>它的左右字数也分别为二叉排序树，即满足以上两条。</li></ul> 
<h5 id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">平衡二叉搜索树</h5> 
<p>        在二叉搜索树的基础上加上左右两个字数的高度差绝对值不超过1的条件。</p> 
<p>        <strong>C++中map、set|、multimap、multiset的底层实现都是平衡二叉搜索树，</strong>map、set的增删时间复杂度都是logn（unordered_map，unordered_set底层实现是哈希表）。</p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">二叉树的存储方式</h4> 
<p>        <strong>二叉树可以链式存储，也可以顺序存储。</strong></p> 
<p><strong>        </strong>链式存储用指针，顺序存储用数组。用数组来存储二叉树时，若父节点的下标是i，则他的左孩子是i * 2 + 1，右孩子就是i * 2 + 2。但是一般用链式表示二叉树更方便。</p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F">二叉树的遍历方式</h4> 
<p>        二叉树的两种遍历方式：</p> 
<p>        1.深度优先遍历：先往深走，遇到叶子节点再往回走。</p> 
<p>        2.广度优先遍历：一层一层地去遍历。</p> 
<p>        继续对两种遍历进行拓展：</p> 
<ul><li>深度优先遍历  </li></ul> 
<p>        前序遍历：中左右（递归法，迭代法）</p> 
<p>        中序遍历：左中右（递归法，迭代法）</p> 
<p>        后序遍历：左右中（递归法，迭代法）</p> 
<ul><li>广度优先遍历</li></ul> 
<p>        层次遍历（迭代法）</p> 
<p>        在深度优先遍历中有三个顺序：前中后序，<strong>前中后指的是中间节点的遍历顺序。</strong></p> 
<p><strong>        </strong>在实现深度优先遍历时，经常使用递归的方式，栈也是递归的一种实现结构，因此前中后序遍历的逻辑也可以借助栈使用递归的方式实现。</p> 
<p>        而广度优先遍历的实现一般使用队列来实现。这是由队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层地遍历二叉树。</p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">二叉树的定义</h4> 
<p>        链式存储二叉树节点的定义方式如下：</p> 
<pre><code class="language-cpp">struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};</code></pre> 
<p>        二叉树的定义和链表类似，只是二叉树的节点多了一个指针，指向左右孩子。</p> 
<h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">二叉树的递归遍历</h3> 
<p>       本节介绍二叉树前中后序的递归写法。写递归算法遵循的三要素：</p> 
<ol><li><strong>确定递归函数的参数和返回值；</strong></li><li><strong>确定终止条件；</strong></li><li><strong>确定单层递归的逻辑。</strong></li></ol> 
<p>        以<a class="link-info" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" rel="nofollow" title="144.二叉树的前序遍历">144.二叉树的前序遍历</a>、<a class="link-info" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" rel="nofollow" title="94.二叉树的中序遍历">94.二叉树的中序遍历</a>、<a class="link-info" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/" rel="nofollow" title="145.二叉树的后序遍历">145.二叉树的后序遍历</a>为例进行二叉树的递归实现。</p> 
<h4 id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89">前序遍历（递归实现）</h4> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; ver){ //1.确定递归参数的参数和返回值
        if (cur == NULL) return;  //2.确定终止条件
        //3.确定单层递归的逻辑
        ver.push_back(cur-&gt;val); //中
        traversal(cur-&gt;left, ver); //左
        traversal(cur-&gt;right, ver); //右
    }

    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        traversal(root, result);
        return result;
    }
};</code></pre> 
<h4 id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89">中序遍历（递归实现）</h4> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec){
        if (cur == NULL) return;
        traversal(cur-&gt;left, vec);
        vec.push_back(cur-&gt;val);
        traversal(cur-&gt;right, vec);
    }
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        traversal(root, result);
        return result;
    }
};</code></pre> 
<h4 id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89">后序遍历（递归实现）</h4> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec){
        if (cur == NULL) return;
        traversal(cur-&gt;left, vec);
        traversal(cur-&gt;right, vec);
        vec.push_back(cur-&gt;val);
    }

    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        traversal(root, result);
        return result;
    }
};</code></pre> 
<p>        中序遍历和后序遍历在前序遍历的基础上只需要更改递归函数中单词递归中左右的顺序即可实现。</p> 
<h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">二叉树的迭代遍历</h3> 
<p>        通过先前栈与队列的题目学习，我们知道<strong>匹配问题都是栈的强项</strong>，递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回值等压入调用栈中。然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归可以返回上一层位置的原因。</p> 
<p>        因此用栈也可以实现二叉树的前中后序遍历。</p> 
<h4 id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89">前序遍历（迭代法）</h4> 
<p>        前序遍历是中左右，每次先处理中间节点，将根节点放入栈中，在将右孩子放入栈中，再加入左孩子，这样使得出栈时是中左右的顺序。</p> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()){
            TreeNode* cur = st.top();
            st.pop();
            result.push_back(cur-&gt;val);
            if (cur-&gt;right) st.push(cur-&gt;right);
            if (cur-&gt;left) st.push(cur-&gt;left);
        }
        return result;
    }
};</code></pre> 
<h4 id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89">后序遍历（迭代法）</h4> 
<p>        后序遍历可以利用前序遍历的代码，更改前中后序的实现顺序然后进行反转，巧妙实现。</p> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node-&gt;val);
            if (node-&gt;left) st.push(node-&gt;left);
            if (node-&gt;right) st.push(node-&gt;right);
        }
        reverse(result.begin(), result.end());
        return result;
    }
};</code></pre> 
<h4 id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89">中序遍历（迭代法）</h4> 
<p>        使用迭代法进行中序遍历不能直接再在前序遍历的代码上进行修改，需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()){
            if (cur != NULL){
                st.push(cur);
                cur = cur-&gt;left;
            }else{
                cur = st.top();
                st.pop();
                result.push_back(cur-&gt;val);
                cur = cur-&gt;right;
            }
        }
        return result;
    }
};</code></pre> 
<p>        在使用迭代法尽心遍历时，前序和中序的遍历算法并不统一，因为前序遍历访问节点和处理节点可以同步处理，而中序就无法做到同步。</p> 
<h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95">二叉树统一迭代法</h3> 
<p>        上文提到使用栈时，无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。</p> 
<p>        那么将访问的节点放入栈中，把要处理的节点也放入栈中，但是另做标记。将要处理的节点放入栈之后，紧接着放入一个空指针作为标记。（这种方法也叫标记法）。</p> 
<h4 id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89">中序遍历（标记法）</h4> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()){
            TreeNode* node = st.top(); 
            if (node != NULL){
                st.pop(); // 将该节点弹出，避免重复操作
                if (node-&gt;right) st.push(node-&gt;right);
                st.push(node);
                st.push(NULL); //中节点访问过但没有处理，加入空节点做标记
                if (node-&gt;left) st.push(node-&gt;left);
            }else{
                st.pop(); // 将空节点弹出
                node = st.top();
                st.pop();
                result.push_back(node-&gt;val);
            }
        }
        return result;
    }
};</code></pre> 
<h4 id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89">前序遍历（标记法）</h4> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()){
            TreeNode* node = st.top();
            if (node != NULL){
                st.pop();
                if (node-&gt;right) st.push(node-&gt;right);
                if (node-&gt;left) st.push(node-&gt;left);
                st.push(node);
                st.push(NULL);
            }else{
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node-&gt;val);
            }
        }
        return result;
    }
};</code></pre> 
<h4 id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89">后序遍历（标记法）</h4> 
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()){
            TreeNode* node = st.top();
            if (node != NULL){
                st.pop();
                st.push(node);
                st.push(NULL);
                if (node-&gt;right) st.push(node-&gt;right);
                if (node-&gt;left) st.push(node-&gt;left);
            }else{
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node-&gt;val);
            }
        }
        return result;
    }
};</code></pre> 
<h3 id="%E6%80%BB%E7%BB%93">总结</h3> 
<p>        本文主要介绍了二叉树的基础和遍历方式，知识点较多，需要多次回顾复习，尤其是二叉树的递归遍历尤其重要，是展开后序题目的基础，通过力扣上三道基础题的练习，要熟练掌握二叉树前中后序的递归遍历和迭代遍历！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ec049af56f19556ff89f62f06abdb5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023 年中国高校大数据挑战赛赛题B DNA 存储中的序列聚类与比对-解析与参考代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/123e28e37d39186c8640b301dc0e409f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#中的集合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>