<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>论文复现之医学图像应用：视网膜血管分割 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="论文复现之医学图像应用：视网膜血管分割" />
<meta property="og:description" content="论文复现之医学图像应用：视网膜血管分割 0.导语 今日研究为继续上次论文中的一个内容：U-Net网络，于是找了一篇经典论文，并学习论文及代码解读。在学习U-Net网络后，使用U-Net神经网络提取视网膜纹理血管。
1.论文阅读 论文题目：U-Net Convolutional Networks for Biomedical Image Segmentation。
中文翻译为：用于生物医学图像分割的U-Net卷积网络。
1.1 摘要 之前，在训练一个深度网络需要大量已标注的训练样本。在这篇论文中，提出了一种网络和训练策略。为了更有效的使用标注数据，使用了数据扩张的方法。本片论文的网络分为两部分：收缩路径(contracting path)和扩张路径(expanding path)。
收缩路径主要用于捕捉上下文特征
扩展路径用于定位
该网络获得了赢得了ISBI cell tracking challenge 2015。不仅如此，这个网络非常的快，对一个512x512的图像，使用一块GPU只需要不到一秒的时间。
1.2 介绍 卷积神经网络的典型用途是分类任务，其中输出到图像是单个类别标签。 然而，在许多视觉任务中，尤其是在生物医学图像处理中，期望的输出应该包括定位，即：应该将类别标签分配给每个像素。 此外，在生物医学任务中，千量级的训练图像通常难以训练。 因此，Ciresan等人 在滑动窗口设置中训练网络，通过提供围绕该像素的局部区域（补丁）作为输入来预测每个像素的类别标签。
首先，这个网络可以局部化。 其次，补丁方面的训练数据远大于训练图像的数量。 由此产生的网络大幅度赢得了ISBI 2012的EM segmentation challenge。
显然，Ciresan等人的策略 有两个缺点。
首先，它非常慢。
因为网络必须分别为每个补丁运行，并且由于补丁重叠而导致大量冗余。
其次，需要在局部准确性 和 获取整体上下文信息之间取舍。
较大的补丁需要更多的最大池化层来降低局部准确性，而较小的补丁则使网络只能看到很少的上下文。 最近的方法提出了一个分类器输出，它考虑了来自多个层的特征。 良好的本地化和上下文的使用是可能的同时。
在这篇文章中，就建立了一个更加优雅的框架，通常被称为“全卷积网络”（FCN)。随后修改并拓展了这个框架，使其可以仅使用少量训练图片就可以工作，获得更高的分割准确率。网络架构如下图所示：
对FCN中的重要修改是：
上采样部分有大量的特征通道，它们允许网络将上下文信息传播到更高分辨率的层。
使得网络架构中扩张路径与收缩路径基本对称，并产生u形结构。
没有任何完全连接的层，分割图仅包含像素，对于该像素，输入图像中的完整上下文是可用的。
该策略允许通过重叠拼贴策略对任意大的图像进行无缝分割。 为了预测图像的边界区域中的像素，通过镜像输入图像来推断丢失的上下文。 这种平铺策略对于将网络应用于大图像很重要，否则分辨率将受到GPU内存的限制。
在上述谈了，使用少量数据做训练，在这篇论文中也使用了数据增强方法，对于这篇论文中的任务，论文中通过对可用的训练图像应用弹性变形来使用过多的数据增强。
这使得网络能够学习这种变形的不变性，而不需要在注释图像语料库中看到这些变换。 这在生物医学分割中特别重要，因为变形曾经是组织中最常见的变异，并且可以有效地模拟真实变形。 Dosovitskiy等人证明了学习不变性的数据增强在无监督特征学习的范围内的价值。
许多细胞分割任务中的另一个挑战是分离相同类别的触摸物体。
为此，论文中提出使用加权损失：触摸单元之间的分离背景标签在损失函数中获得大的权重。
1.3 网络架构 网络架构如上图所示：它由一条收缩路径（左侧）和一条扩展路径（右侧）组成。
【收缩路径】
收缩路径是典型的卷积网络架构。它的架构是一种重复结构，每次重复中都有2个卷积层和一个pooling层，卷积层中卷积核大小均为3x3，激活函数使用ReLU，两个卷积层之后是一个2x2的步长为2的最大池化层。每一次下采样后我们都把特征通道的数量加倍。
【扩张路径】
扩展路径中的每一步包括对特征映射先进行上采样，然后进行2x2卷积（“上卷积”）。该特征映射将特征通道的数量减半，与收缩路径中相应裁剪的特征拼接起来，以及两个3x3卷积，每个卷积都有一个ReLU。由于每个卷积中边界像素的丢失，裁剪是必要的。在最后一层，使用1x1卷积来将每个64通道特征图映射到特定深度的结果。
【卷积层总数】" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2a392b9a66f7ca0eccfda58eb99d5fbb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-02T19:17:51+08:00" />
<meta property="article:modified_time" content="2019-03-02T19:17:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">论文复现之医学图像应用：视网膜血管分割</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="rich_media_content" id="js_content"> 
 <p class="output_wrapper"></p> 
 <h2>论文复现之医学图像应用：视网膜血管分割</h2> 
 <h3>0.导语</h3> 
 <p>今日研究为继续上次论文中的一个内容：<strong>U-Net网络</strong>，于是找了一篇经典论文，并学习论文及代码解读。在学习U-Net网络后，使用U-Net神经网络提取视网膜纹理血管。</p> 
 <h3>1.论文阅读</h3> 
 <p>论文题目：<strong>U-Net Convolutional Networks for Biomedical Image Segmentation</strong>。</p> 
 <p>中文翻译为：用于生物医学图像分割的U-Net卷积网络。</p> 
 <h4>1.1 摘要</h4> 
 <p>之前，在训练一个深度网络需要大量已标注的训练样本。在这篇论文中，提出了一种网络和训练策略。为了更有效的使用标注数据，使用了<strong>数据扩张</strong>的方法。本片论文的网络分为两部分：<strong>收缩路径(contracting path)</strong>和<strong>扩张路径(expanding path)</strong>。</p> 
 <ul class="list-paddingleft-2"><li><p>收缩路径主要用于<strong>捕捉上下文特征</strong></p></li><li><p>扩展路径用于<strong>定位</strong></p></li></ul> 
 <p>该网络获得了赢得了ISBI cell tracking challenge 2015。不仅如此，这个网络非常的快，对一个512x512的图像，使用一块GPU只需要不到一秒的时间。</p> 
 <h4>1.2 介绍</h4> 
 <p><strong>卷积神经网络</strong>的典型用途是<strong>分类任务</strong>，其中<strong>输出到图像是单个类别标签</strong>。 然而，在许多视觉任务中，尤其是在生物医学图像处理中，<strong>期望的输出应该包括定位</strong>，即：<strong>应该将类别标签分配给每个像素</strong>。 此外，在生物医学任务中，<strong>千量级的训练图像通常难以训练</strong>。 因此，Ciresan等人 在滑动窗口设置中训练网络，<strong>通过提供围绕该像素的局部区域（补丁）作为输入来预测每个像素的类别标签</strong>。</p> 
 <ul class="list-paddingleft-2"><li><p>首先，这个网络可以局部化。 </p></li><li><p>其次，补丁方面的训练数据远大于训练图像的数量。 </p></li></ul> 
 <p>由此产生的网络大幅度赢得了ISBI 2012的EM segmentation challenge。</p> 
 <p>显然，Ciresan等人的策略 有两个缺点。</p> 
 <ul class="list-paddingleft-2"><li><p>首先，它<strong>非常慢</strong>。</p></li></ul> 
 <p>因为<strong>网络必须分别为每个补丁运行</strong>，<strong>并且由于补丁重叠而导致大量冗余</strong>。</p> 
 <ul class="list-paddingleft-2"><li><p>其次，需要在<strong>局部准确性 和 获取整体上下文信息之间取舍</strong>。</p></li></ul> 
 <p>较大的补丁需要更多的<strong>最大池化层</strong>来降低局部准确性，而较小的补丁则使网络只能看到很少的上下文。 最近的方法提出了一个<strong>分类器输出</strong>，<strong>它考虑了来自多个层的特征</strong>。 <em>良好的本地化和上下文的使用是可能的同时</em>。</p> 
 <p>在这篇文章中，就建立了一个更加优雅的框架，通常被称为“全卷积网络”（FCN)。随后修改并拓展了这个框架，使其可以<strong>仅使用少量训练图片就可以工作，获得更高的分割准确率</strong>。网络架构如下图所示：</p> 
 <figure> 
  <img title="" src="https://images2.imgbox.com/0c/40/IMxXebVR_o.png" alt="640?wx_fmt=png"> 
 </figure> 
 <p>对FCN中的重要修改是：</p> 
 <ul class="list-paddingleft-2"><li><p><strong>上采样部分有大量的特征通道</strong>，<strong>它们允许网络将上下文信息传播到更高分辨率的层</strong>。</p></li></ul> 
 <p>使得网络架构中<strong>扩张路径与收缩路径基本对称，并产生u形结构</strong>。</p> 
 <ul class="list-paddingleft-2"><li><p><strong>没有任何完全连接的层，分割图仅包含像素，对于该像素，输入图像中的完整上下文是可用的</strong>。</p></li></ul> 
 <p>该策略允许通过重叠拼贴策略对任意大的图像进行无缝分割。 <strong>为了预测图像的边界区域中的像素，通过镜像输入图像来推断丢失的上下文</strong>。 这种<strong>平铺策略</strong>对于将网络应用于大图像很重要，否则分辨率将受到GPU内存的限制。</p> 
 <figure> 
  <img title="" src="https://images2.imgbox.com/9f/ea/1q8c1rE2_o.png" alt="640?wx_fmt=png"> 
 </figure> 
 <p>在上述谈了，使用少量数据做训练，在这篇论文中也使用了数据增强方法，对于这篇论文中的任务，论文中通过对可用的训练图像应用<strong>弹性变形</strong>来使用过多的数据增强。</p> 
 <p>这使得网络能够学习这种变形的不变性，而不需要在注释图像语料库中看到这些变换。 这在生物医学分割中特别重要，因为变形曾经是组织中最常见的变异，并且可以有效地模拟真实变形。 Dosovitskiy等人证明了学习不变性的数据增强在无监督特征学习的范围内的价值。</p> 
 <p>许多细胞分割任务中的另一个挑战是<strong>分离相同类别的触摸物体</strong>。</p> 
 <figure> 
  <img title="" src="https://images2.imgbox.com/0c/f5/itLndy02_o.png" alt="640?wx_fmt=png"> 
 </figure> 
 <p>为此，论文中提出使用<strong>加权损失</strong>：<strong>触摸单元之间的分离背景标签在损失函数中获得大的权重</strong>。</p> 
 <h4>1.3 网络架构</h4> 
 <figure> 
  <img title="" src="https://images2.imgbox.com/db/52/1URZlkkQ_o.png" alt="640?wx_fmt=png"> 
 </figure> 
 <p>网络架构如上图所示：它由一条<strong>收缩路径</strong>（左侧）和一条<strong>扩展路径</strong>（右侧）组成。</p> 
 <p>【<strong>收缩路径</strong>】</p> 
 <p><strong>收缩路径</strong>是典型的卷积网络架构。它的架构是一种<strong>重复结构</strong>，每次重复中都有<strong>2个卷积层和一个pooling层</strong>，卷积层中卷积核大小均为3x3，激活函数使用ReLU，两个卷积层之后是一个2x2的步长为2的最大池化层。每一次下采样后我们都把特征通道的数量加倍。</p> 
 <p>【<strong>扩张路径</strong>】</p> 
 <p><strong>扩展路径</strong>中的每一步包括对特征映射<strong>先进行上采样</strong>，<strong>然后进行2x2卷积（“上卷积”）</strong>。该特征映射将特征通道的数量减半，与收缩路径中相应裁剪的特征拼接起来，以及两个3x3卷积，每个卷积都有一个ReLU。由于每个卷积中边界像素的丢失，裁剪是必要的。在最后一层，使用1x1卷积来将每个64通道特征图映射到特定深度的结果。</p> 
 <p>【<strong>卷积层总数</strong>】</p> 
 <p>网络总共有23个卷积层。</p> 
 <h4>1.4 训练</h4> 
 <p>论文中采用<strong>随机梯度下降法(SGD)</strong>训练。由于没有使用0填补的卷积，输出图像比输入小一个恒定的边界宽度。 为了最大限度地降低开销并最大限度地利用GPU内存，我们倾向于在<strong>较大批量的情况下使用较大的输入切片</strong>，从而将批量减少为单个图像。 因此，我们使用高动量（0.99），以便大量先前看到的训练样本确定当前优化步骤中的更新。</p> 
 <ul class="list-paddingleft-2"><li><p>损失函数使用<strong>逐像素</strong>的 <code>softmax</code> 函数和<strong>交叉熵损失函数</strong>的结合</p></li><li><p><code>Softmax</code>函数：</p></li></ul> 
 <p><br></p> 
 <p><img src="https://images2.imgbox.com/91/ff/SBseCsyP_o.png" alt="640?wx_fmt=png"></p> 
 <p>a_k(x)表示在<code>feature maps</code>中的的<code>channel=k</code>的<code>feature map</code>像素位置为<code>x</code>的激活值。K表示总类别数，pk(x)表示似然函数。</p> 
 <p>交叉熵函数：</p> 
 <figure> 
  <img title="img" src="https://images2.imgbox.com/21/84/SQyiXN81_o.png" alt="640?wx_fmt=png"> 
 </figure> 
 <p>其中l是每个像素的真实标签，w是权重地图，表示训练中某些像素更加重要。</p> 
 <p>为了使某些像素点更加重要，我们在公式中引入了w(x)。我们对每一张标注图像预计算了一个权重图，来补偿训练集中每类像素的不同频率，使网络更注重学习相互接触的细胞之间的小的分割边界。我们使用形态学操作计算分割边界。权重图计算公式如下：</p> 
 <figure> 
  <img title="img" src="https://images2.imgbox.com/3e/91/6KjIUBKG_o.png" alt="640?wx_fmt=png"> 
 </figure> 
 <p>其中w_c是权重地图来平衡类像素的频率。d1表示最近单元边界的距离。d2表示到第二最近单元的边界的距离。文中设置w_0=10,σ≈5pixels。</p> 
 <ul class="list-paddingleft-2"><li><p>训练需要标注对应的<code>mask</code>,就是类别的区域标记。</p></li></ul> 
 <figure> 
  <img title="" src="https://images2.imgbox.com/43/53/eXxuQkDR_o.png" alt="640?wx_fmt=png"> 
 </figure> 
 <p><strong>网络中权重的初始化</strong>：在具有许多卷积层和通过网络的不同路径的深层网络中，权重的良好初始化非常重要。 否则，网络的某些部分可能会过度激活，而其他部分则无法提供。 理想情况下，应调整初始权值，使网络中的每个特征映射具有近似单位差异。 对于具有我们的体系结构（交替卷积和ReLU层）的网络，这可以通过从具有标准偏差(2/N)^0.5的高斯分布中绘制初始权重来实现，其中N为每个神经元的输入节点数量。例如3x3的64通道的卷积层N=3x3x64=576。</p> 
 <h4>1.5 数据增加</h4> 
 <p>在只有少量样本的情况况下，要想尽可能的让网络获得不变性和鲁棒性，数据增强是必不可少的。在显微图像的情况下，我们主要需要<strong>移位和旋转不变性以及对变形和灰度值变化</strong>的鲁棒性。论文中使用<strong>随机位移矢量在粗糙的3x3网格上产生平滑形变</strong>。 位移是从10像素标准偏差的高斯分布中采样的。然后使用双三次插值计算每个像素的位移。在压缩路径末端的退出层执行进一步的隐式数据增强。</p> 
 <p>最后论文的实验部分，这里直接在DRIVE数据库上做实验！</p> 
 <h3>2.视网膜血管分割实验</h3> 
 <h4>2.1 实验任务</h4> 
 <p>实验任务：使用U-Net神经网络提取纹理血管。</p> 
 <p>为什么要做这个，有什么实际意义？</p> 
 <p>临床实验中我们要能够更好的对眼部血管等进行检测、分类等操作，我们首先要做的就是对眼底图像中的血管进行分割，保证最大限度的分割出眼部的血管。从而方便后续对血管部分的操作。</p> 
 <h4>2.2 数据集</h4> 
 <p>实验数据集为：DRIVE数据集。</p> 
 <blockquote> 
  <p>数据集下载地址：</p> 
  <p>http://www.isi.uu.nl/Research/Databases/DRIVE/</p> 
 </blockquote> 
 <p>【<strong>数据集识别</strong>】</p> 
 <p>数据集分为训练集与测试集，而每个都分为如下目录：</p> 
 <p><img src="https://images2.imgbox.com/9c/b4/czMS0hgh_o.png" alt="640?wx_fmt=png"></p> 
 <p>1st_manual目录下的数据集为：手工分好的血管图像，如下图所示：</p> 
 <p><img src="https://images2.imgbox.com/6d/7d/O96eleNc_o.png" alt="640?wx_fmt=png"></p> 
 <p>images目录下的数据集为眼底图像，如下图所示：</p> 
 <p><img src="https://images2.imgbox.com/0d/65/3pRDGXzV_o.png" alt="640?wx_fmt=png"></p> 
 <p>mask目录下的数据集为眼部轮廓图像，如下图所示：</p> 
 <p><img src="https://images2.imgbox.com/1d/ae/XFG7GUPs_o.png" alt="640?wx_fmt=png"></p> 
 <p>从上面可以看出数据集非常少，总共只有20幅图片，为此我们需要做预处理增大数据集。</p> 
 <p>【<strong>U-Net网络优势</strong>】</p> 
 <p>在上述U-net论文中提到U-Net网络可以针对很少的数据集来进行语义分割，比如我们这个眼球血管分割就是用了20张图片来训练就可以达到很好的效果。而且我们这种眼球血管，或者指静脉，指纹之类的提取特征或者血管静脉在U-net网络里就是一个二分类问题。而本文用的U-net网络来实现这个二分类就只需要二十张图片来作为数据集。</p> 
 <h4>2.2 运行环境及库</h4> 
 <p>复现论文代码：</p> 
 <blockquote> 
  <p>官方：https://github.com/orobix/retina-unet</p> 
  <p>非官方：https://github.com/CNU105/Retina-Unet</p> 
 </blockquote> 
 <ul class="list-paddingleft-2"><li><p>numpy &gt;= 1.11.1</p></li><li><p>keras &gt;= 2.1.0</p></li><li><p>PIL &gt;=1.1.7</p></li><li><p>opencv &gt;=2.4.10</p></li><li><p>h5py &gt;=2.6.0</p></li><li><p>configparser &gt;=3.5.0b2</p></li><li><p>scikit-learn &gt;= 0.17.1</p></li></ul> 
 <p>上面是官方给出的运行库环境。实际上当你安装上后还是有问题的！</p> 
 <p>还需要安装如下内容：</p> 
 <ul class="list-paddingleft-2"><li><p>graphviz</p></li><li><p>pydot</p></li><li><p>pydot-ng</p></li></ul> 
 <p>如果graphviz安装报错，则需要：</p> 
 <pre></pre> 
 <p>sudo apt-<span class="hljs-keyword">get</span> install graphviz或者yum安装<br></p> 
 <p>但是我的是服务器上，没有root权限，怎么安装呢？</p> 
 <p>这就需要源码编译，在linux系统中，源码编译基本可以解决一切安装问题！</p> 
 <p>由于没有安装graphviz，同时需要root权限，所以安装就出现了问题，然后只能通过源码编译，结果源码编译最新版也出现了问题，说是最新版的bug，我就转向系统的yum本地用户安装：</p> 
 <pre></pre> 
 <p><span class="hljs-comment"># 查看yum中是否有你需要的包</span><br>yum list <span class="hljs-string">'graphviz*'</span><br><span class="hljs-comment"># 下载rpm包(上述输出：graphviz.x86_64)</span><br>yumdownloader graphviz.x86_64 <br><span class="hljs-comment"># 解压RPM包</span><br>rpm2cpio graphviz<span class="hljs-number">-2.30.1-19.</span>el7.x86_64.rpm |cpio -idvm<br><span class="hljs-comment"># 添加环境变量</span><br>vim  ~/.bashrc<br>export PATH=$PATH:$HOME/usr/bin/<br>source ~/.bashrc<br><span class="hljs-comment"># 备注：这种安装会在当前目录下新建一个usr目录，安装的软件全在usr下的bin目录下！</span><br></p> 
 <p>安装好上述就可以了。</p> 
 <p>但是我的服务器上没python，我也没root权限，如何安装python呢?</p> 
 <p>那就是上述说的源码编译，指定源码编译路径，然后添加环境变量即可！</p> 
 <p>过程中重要两点：</p> 
 <p>（1）编译路径指定</p> 
 <pre></pre> 
 <p>./configure --prefix=<span class="hljs-regexp">/home/city/python3/</span><br></p> 
 <p>编译后，直接<code>make</code>，然后<code>make install</code>即可。</p> 
 <p>（2）配置环境变量</p> 
 <pre></pre> 
 <p>vim  ~/.bashrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/home/city/python3/<br><span class="hljs-built_in">source</span> ~/.bashrc<br></p> 
 <p>至此，通过源码编译与本地用户安装解决了环境问题！</p> 
 <h4>2.3  开始实验</h4> 
 <p>【<strong>数据预处理</strong>】</p> 
 <p>上面说数据集的时候，提到数据集非常少，那么在实验前就得做数据预处理，而该数据预处理做的工作就是：读取原来的训练集与测试集，重新生成数据文件，并保存为hdf5文件。</p> 
 <p>对应到代码中就是运行下面代码：</p> 
 <pre></pre> 
 <p>python3 prepare_datasets_DRIVE.py<br></p> 
 <p>运行该代码后，会生成如下目录及文件：</p> 
 <p><img src="https://images2.imgbox.com/21/7c/OKAqYVnY_o.png" alt="640?wx_fmt=png"></p> 
 <p>【<strong>配置文件</strong>】</p> 
 <p>在代码中有个configuration.txt配置文件，该配置文件主要用来配置数据集目录，训练及测试设置！</p> 
 <p><img src="https://images2.imgbox.com/f1/b7/qcgahGpD_o.png" alt="640?wx_fmt=png"></p> 
 <p>【<strong>开始训练</strong>】</p> 
 <blockquote> 
  <p>运行代码</p> 
 </blockquote> 
 <p>在官网中是让我们运行下面代码：</p> 
 <pre></pre> 
 <p>python3 run_training.py<br></p> 
 <p>而实际上直接可以运行：</p> 
 <pre></pre> 
 <p>python3 ./src/retinaNN_training.py<br></p> 
 <p>因为，上述代码实际上就是获取我们的实验设置参数，判断是否是GPU训练而已。如果自己会后台运行，直接敲命令即可！</p> 
 <p>通过运行<code>retinaNN_training.py</code>我们的实验便开始进入训练过程了，训练过程非常漫长，本次运行GPU共8块，运行时长达到6个h。</p> 
 <blockquote> 
  <p>模型查看</p> 
 </blockquote> 
 <p>网络定义每行这个小括号填inputs是代表这层模型连接在inputs之后</p> 
 <pre></pre> 
 <p>inputs = Input(shape=(n_ch,patch_height,patch_width))<br><span class="hljs-comment"># 2D 卷积层</span><br>conv1 = Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(inputs)<br></p> 
 <p>完整模型注释及代码：</p> 
 <pre></pre> 
 <p><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_unet</span><span class="hljs-params">(n_ch,patch_height,patch_width)</span>:</span><br>    <span class="hljs-comment"># 第一层</span><br>    inputs = Input(shape=(n_ch,patch_height,patch_width))<br>    <span class="hljs-comment"># 2D 卷积层</span><br>    conv1 = Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(inputs)<br>    <span class="hljs-comment"># Dropout抛弃一些参数防止过拟合</span><br>    conv1 = Dropout(<span class="hljs-number">0.2</span>)(conv1) <br>    conv1 = Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(conv1)<br>    pool1 = MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(conv1)<br><br>    <span class="hljs-comment"># 第二层</span><br>    conv2 = Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(pool1)<br>    conv2 = Dropout(<span class="hljs-number">0.2</span>)(conv2)<br>    conv2 = Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(conv2)<br>    pool2 = MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(conv2)<br><br>    <span class="hljs-comment"># 第三层</span><br>    conv3 = Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(pool2)<br>    conv3 = Dropout(<span class="hljs-number">0.2</span>)(conv3)<br>    conv3 = Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(conv3)<br>    <span class="hljs-comment"># 上采样函数，size(2,2)其实就等于将原图放大四倍（水平两倍，垂直两倍）例如32*32 变成 64*64的图像</span><br>    up1 = UpSampling2D(size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(conv3)<br><br>    <span class="hljs-comment"># 两层拼接</span><br>    up1 = concatenate([conv2,up1],axis=<span class="hljs-number">1</span>)<br><br>    conv4 = Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(up1)<br>    conv4 = Dropout(<span class="hljs-number">0.2</span>)(conv4)<br>    conv4 = Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(conv4)<br>    up2 = UpSampling2D(size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(conv4)<br><br>    <span class="hljs-comment"># # 两层拼接</span><br>    up2 = concatenate([conv1,up2], axis=<span class="hljs-number">1</span>)<br><br>    conv5 = Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(up2)<br>    conv5 = Dropout(<span class="hljs-number">0.2</span>)(conv5)<br>    conv5 = Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(conv5)<br>    conv6 = Conv2D(<span class="hljs-number">2</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), activation=<span class="hljs-string">'relu'</span>,padding=<span class="hljs-string">'same'</span>,data_format=<span class="hljs-string">'channels_first'</span>)(conv5)<br>    conv6 = core.Reshape((<span class="hljs-number">2</span>,patch_height*patch_width))(conv6)<br>    <span class="hljs-comment"># Permute层将输入的维度按照给定模式进行重排</span><br>    conv6 = core.Permute((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))(conv6)<br>    conv7 = core.Activation(<span class="hljs-string">'softmax'</span>)(conv6)<br><br>    <span class="hljs-comment"># 将模型的输入和输出给Model函数就会自己组建模型运行图结构</span><br>    model = Model(inputs=inputs, outputs=conv7)<br>    <span class="hljs-comment"># sgd = SGD(lr=0.01, decay=1e-6, momentum=0.3, nesterov=False)</span><br>    <span class="hljs-comment"># 配置模型</span><br>    model.compile(optimizer=<span class="hljs-string">'sgd'</span>, loss=<span class="hljs-string">'categorical_crossentropy'</span>,metrics=[<span class="hljs-string">'accuracy'</span>])<br>    <span class="hljs-keyword">return</span> model<br></p> 
 <p></p> 
 <p>模型训练代码流程：</p> 
 <ul class="list-paddingleft-2"><li><p>首先定义模型</p></li><li><p>读取配置文件</p></li><li><p>加载数据</p></li></ul> 
 <p>这一步非常重要，对读入内存准备开始训练的图像数据进行一些增强之类的处理。这里对其进行了，直方图均衡化，数据<strong>标准化</strong>，并且<strong>压缩像素值到0-1</strong>，将其的一个数据符合<strong>标准正态分布</strong>。(这个处理代码在lib目录下的extract_patches.py中)。</p> 
 <p>前面我们知道数据集非常少，那怎么让训练的数据集增大呢？</p> 
 <p>这里就是做这个处理，即对每张图片取patch时，除了正常的每个patch每个patch移动的取之外，我们还在数据范围内进行随机取patch，这样虽然各个patch之间会有一部分数据是相同的，但是这对于网络而言，你传入的也是一个新的东西，网络能从中提取到的特征也更多了。这一步的目的其实就是在有限的数据集中进行一些数据扩充，这也是在神经网络训练中常用的手段了。</p> 
 <ul class="list-paddingleft-2"><li><p>存储随机组合的patch</p></li></ul> 
 <p>左图为随机原图，右图为mask图</p> 
 <p><img src="https://images2.imgbox.com/df/95/a60dBrYV_o.png" alt="640?wx_fmt=png"></p> 
 <ul class="list-paddingleft-2"><li><p>存储模型</p></li></ul> 
 <p><img src="https://images2.imgbox.com/61/92/vdY0iMLt_o.png" alt="640?wx_fmt=png"></p> 
 <p>【<strong>测试及评估</strong>】</p> 
 <pre></pre> 
 <p>python3 src/retinaNN_predict.py<br></p> 
 <p>由于服务器上没有可视化页面，所以当调用matlibplot时候，会报如下错误，那么就需要后台运行，不显示！</p> 
 <pre></pre> 
 <p>no display name <span class="hljs-keyword">and</span> no $DISPLAY environment variable<br></p> 
 <p>解决办法是：</p> 
 <p>加入下面两行代码即可！</p> 
 <pre></pre> 
 <p><span class="hljs-keyword">import</span> matplotlib<br>matplotlib.use(<span class="hljs-string">'Agg'</span>)<br></p> 
 <p>在本代码中，做了如下工作：</p> 
 <ul class="list-paddingleft-2"><li><p>同训练集一样取patch</p></li><li><p>利用训练好的模型加载测试数据</p></li><li><p>存储并可视化结果</p></li><li><p>评估结果</p></li></ul> 
 <p><img src="https://images2.imgbox.com/76/f0/5TxVxLkd_o.png" alt="640?wx_fmt=png"></p> 
 <p><img src="https://images2.imgbox.com/c4/69/Fs0bXyqv_o.png" alt="640?wx_fmt=png"></p> 
 <p><img src="https://images2.imgbox.com/66/be/A8YAD2Mv_o.png" alt="640?wx_fmt=png"></p> 
 <p><img src="https://images2.imgbox.com/f5/fe/yYZsnkMc_o.png" alt="640?wx_fmt=png"></p> 
 <p><br></p> 
 <p>从左到右，依次为真实，原图，预测。<br></p> 
 <p><br></p> 
 <p><img src="https://images2.imgbox.com/10/9b/zXATvKp6_o.png" alt="640?wx_fmt=png"></p> 
 <p><br></p> 
 <p>从上到下，依次为真实，原图，预测。</p> 
 <p><br></p> 
 <p>参考文献：</p> 
 <p><br></p> 
 <p>1.https://www.cnblogs.com/DOMLX/p/9780786.html</p> 
 <p>2.https://github.com/orobix/retina-unet</p> 
 <p>3.https://blog.csdn.net/u013063099/article/details/79981097</p> 
 <p><br></p> 
 <p><img src="https://images2.imgbox.com/1a/f7/QrTqZL11_o.png" alt="640?wx_fmt=png"></p> 
 <p><br></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a2b47e24a35c58ac3405c6ed1c74d65/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">面试之-mybatis中$和#的区别*</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02355122b096ec7ebbac33f5833785f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">线性代数学习心得（一）矩阵乘法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>