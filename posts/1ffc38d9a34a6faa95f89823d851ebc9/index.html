<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【K8S in Action】服务：让客户端发现pod 并与之通信（1） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【K8S in Action】服务：让客户端发现pod 并与之通信（1）" />
<meta property="og:description" content="服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源。当服务存在时，它的 IP 地址和端口不会改变。 客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod 上。
外部客户端无须关心服务器数量而连接到前端 pod 上。
前端的 pod需要连接后端的数据库。 由于数据库运行在 pod 中， 它可能会在集群中移来移去， 导致 IP 地址变化。 当后台数据库被移动时， 无须对前端pod 重新配置。
pod 是短暂，会删除增加，调度到其他节点，数量变更。
在 pod 启动前会给已经调度到节点上的pod 分配 IP 地址，即客户端提前不知道Pod的IP地址。
水平仲缩意味着多个 pod 可能会提供相同的服务。 无需关注提供服务 pod 的数量，以及每个Pod的IP。
1 服务与服务发现 1 创建Service 服务 创建了一个名叫kubia的服务，它将在端口80接收请求并将连接路由到具有标签选择器是app=kubia的pod的8080端口上。 Kubernetes服务代理截取的该连接， 在根据标签选择器选中的Pod 中，任意选择了一个pod, 然后将请求转发给它。
apiVersion: vl kind: Service metadata： name: kubia spec: ports: - name: http port: 80 targetPort: 8080 转发到容器端口 - name: https 同一服务暴露多个端口 port: 443 targetPort: 8443 selector: 标签选择器适用的服务 app: kubia sessionAffinity: ClientIP 会话亲和性,统一客户端产生的所有请求每次都指向同一个pod kubectl get svc NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes 10." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1ffc38d9a34a6faa95f89823d851ebc9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-13T21:04:30+08:00" />
<meta property="article:modified_time" content="2023-12-13T21:04:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【K8S in Action】服务：让客户端发现pod 并与之通信（1）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源。当服务存在时，它的 IP 地址和端口不会改变。 客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod 上。</p> 
<ul><li> <p>外部客户端无须关心服务器数量而连接到前端 pod 上。</p> </li><li> <p>前端的 pod需要连接后端的数据库。 由于数据库运行在 pod 中， 它可能会在集群中移来移去， 导致 IP 地址变化。 当后台数据库被移动时， 无须对前端pod 重新配置。</p> </li><li> <p>pod 是短暂，会删除增加，调度到其他节点，数量变更。</p> </li><li> <p>在 pod 启动前会给已经调度到节点上的pod 分配 IP 地址，即客户端提前不知道Pod的IP地址。</p> </li><li> <p>水平仲缩意味着多个 pod 可能会提供相同的服务。 无需关注提供服务 pod 的数量，以及每个Pod的IP。</p> </li></ul> 
<h3><a id="1__10"></a>1 服务与服务发现</h3> 
<h4><a id="1_Service__11"></a>1 创建Service 服务</h4> 
<p>创建了一个名叫kubia的服务，它将在端口80接收请求并将连接路由到具有标签选择器是app=kubia的pod的8080端口上。 Kubernetes服务代理截取的该连接， 在根据标签选择器选中的Pod 中，任意选择了一个pod, 然后将请求转发给它。</p> 
<pre><code class="prism language-bash">apiVersion: vl 
kind: Service 
metadata：
  name: kubia
spec: 
  ports: 
	- name: http      		
	  port: <span class="token number">80</span>
	  targetPort: <span class="token number">8080</span>     转发到容器端口
	- name: https          同一服务暴露多个端口
	  port: <span class="token number">443</span>
	  targetPort: <span class="token number">8443</span>
  selector:            标签选择器适用的服务
	app: kubia
  sessionAffinity: ClientIP        会话亲和性,统一客户端产生的所有请求每次都指向同一个pod
</code></pre> 
<pre><code class="prism language-bash">kubectl get svc

NAME         CLUSTER-IP 	EXTERNAL-IP    PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>    AGE 
kubernetes   <span class="token number">10.111</span>.240.1      <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>       <span class="token number">443</span>/TCP   30d 
kubia       <span class="token number">10.111</span>.249.153 		<span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>       <span class="token number">80</span>/TCP   6m     分配给服务的IP地址是10.111.249.153

kubectl <span class="token builtin class-name">exec</span> kubia-7nogl -- <span class="token function">curl</span> <span class="token parameter variable">-s</span> http: //10 .111. <span class="token number">249</span> .153       双横杠<span class="token punctuation">(</span>--<span class="token punctuation">)</span>代表着kubectl命令项的结束。 之后的内容是指在pod内部需要执行的命令
</code></pre> 
<h4><a id="2__41"></a>2 使用命名的端口</h4> 
<p>通过数字来指定端口，但是在服务中也可以给不同的端口号命名，通过名称来指定。是即使更换端口号无须更改服务的spec， 通过改变Pod 中的 spec pod 端口号。</p> 
<pre><code class="prism language-bash">kind <span class="token builtin class-name">:</span> Pod 
spec <span class="token builtin class-name">:</span> 
  containers: 
   - name: kubia 
	 ports <span class="token builtin class-name">:</span>  
		- name <span class="token builtin class-name">:</span> http    将8080端口命名为http
		  containerPort: <span class="token number">8080</span> 
		- name ： https 
		  containerPort: <span class="token number">8080</span> 


apiVersion: vl 
kind: Service 
metadata：
  name: kubia
spec: 
  ports: 
	- name: http      		
	  port: <span class="token number">80</span>
	  targetPort: http   将80端口映射到容器被称为http 的端口
	- name: https          
	  port: <span class="token number">443</span>
	  targetPort: https
</code></pre> 
<h4><a id="3__68"></a>3 服务发现</h4> 
<p>集群内客户端 pod 如何知道服务的 IP 和端口？</p> 
<h5><a id="_70"></a>通过环境变量发现服务</h5> 
<p>pod 开始运行的时候，会初始化环境变量指向现在存在服务。 服务创建早于Pod的创建， pod 上的进程可以根据环境变量获得服务 IP 地址和端口号。所以的Pod 都可以看到该服务。</p> 
<pre><code class="prism language-bash">kubectl delete po <span class="token parameter variable">--all</span>   <span class="token comment">#在无须知道 pod 的名字的情况下就能删除所有 pod</span>
kubectl get po            <span class="token comment"># 后面创建的服务，所以先删除pod, pod 会自动重建</span>
kubectl <span class="token builtin class-name">exec</span> kubia-3inly <span class="token function">env</span>   

KUBIA SERVICE <span class="token assign-left variable">HOST</span><span class="token operator">=</span>l0.111.249.153    服务的集群Ip
KUBIA SERVICE <span class="token assign-left variable">PORT</span><span class="token operator">=</span><span class="token number">80</span>                 服务所在的端口
</code></pre> 
<p>服务名称中的横杠被转换为下画线，并且当服务名称用作环境变量名称中<br> 的前级时，所有的字母都是大写的。<br> 环境变量是获得服务 IP 地址和端口 种方式。</p> 
<h5><a id="_DNS__85"></a>通过 DNS 发现服务</h5> 
<p>一个pod 被称作 kube-dns ，这个 pod 运行 DNS 服务，在集群中的其他 pod 都被配置成使用其作为 dns (通过修改每 容器的／ etc/reso conf 实现), pod 是否使用 内部的 DNS 服务器是根据 pod 中 spec dnsPolicy 属性来决定的。</p> 
<p>每个服务从内部 DNS 服务器中获得 DNS 条目， 客户端 pod 在知道服务名称的情况下 通过全限定域名 （FQDN ）来访问，而不是诉诸于环境变量。</p> 
<p>FQDN 的连接来访后端数据库服务： backend-database.default.svc.cluster.local</p> 
<ul><li>backend-database 对应于服务名称，</li><li>default 表示服务在其中定义的名称间，</li><li>svc.cluster.local 是在所有集群本地服务名称 中使用的可配置集群域后缀。</li></ul> 
<p>尝试使用 FQDN 来代替 IP 去访问 kubia 服务。另外，必须在一个存在的 pod 上才能这样做。 客户端仍然必须知道服务的端口号，如果并不是标准端口，客户端可以从环境变量中获取端口号。</p> 
<h3><a id="2__98"></a>2 连接集群外部的服务</h3> 
<p>不要让服务将连接重定向到集群中的 pod ，而是让它重定向到外部 IP 和端口。</p> 
<h4><a id="21__endpoint_100"></a>2.1 介绍服务 endpoint</h4> 
<p>服务并不是和 pod 直接相连的。相反，有一种资源介于两者之间－—-它就是 Endpoint 资源。</p> 
<pre><code class="prism language-bash">kubectl describe svc kubia

kubectl get endpoints kubia
NAME 	ENDPOINTS 									     AGE 
kubia  <span class="token number">10.108</span>.l.4:8080,10.108.2.5:8080,10.108.2.6:8080    lh
</code></pre> 
<p>服务的 endpoint 与服务解耦后，可以分别手动配置和更新他们。</p> 
<h4><a id="22___endpoint_111"></a>2.2 手动配置服务的 endpoint</h4> 
<p>如果创建了不包含 pod选择器的服务，Kubemetes 将不会创建 Endpoint 资源（毕竟，缺少选择器，将不会知道服务中包含哪些 pod)。这样就需要创建 Endpoint 资源来指定该服务的 endpoint 列表。</p> 
<p>Endpoint是一个单独的资源并不是服务的一个属性。由于创建的资源中并不包含选择器，相关的Endpoints 资源并没有自动创建，所以必须手动创建。</p> 
<p>Endpoint对象需要与服务具有相同的名称，并包含该服务的目标IP地址和端口<br> 列表。服务和Endpoint资源都发布到服务器。<br> 在服务创建后创建的容器将包含服务的环境变量，并且与其IP : port对的所有连接都将在服务端点之间进行负载均衡。</p> 
<pre><code class="prism language-bash">apiVersion: vl 
kind: EndpointS                Endpoint的名称必须和服务的名称相匹配
metadata:
	name: external-service
subsets: 
	- addresses:
		- ip: <span class="token number">11</span>. <span class="token number">11</span>. <span class="token number">11</span>. <span class="token number">11</span>    服务将连接重定向到endpoint的IP地址 <span class="token punctuation">(</span>集群外部地址）
		- ip: <span class="token number">22.22</span>.22.22
	ports: 
		- port: <span class="token number">80</span>      endpoint的目标端口


apiVersion: vl 
kind: Service 
metadata: 
	name: exernal-service
spec: 
	ports: 
	- port： <span class="token number">80</span>     服务中没有定义选择器
</code></pre> 
<h4><a id="23__141"></a>2.3 为外部服务创建别名</h4> 
<p>手动配置服务的Endpoint来代替公开外部服务方法，有一种更简单的方法，<br> 就是通过其完全限定域名(FQDN)访问外部服务。</p> 
<p>服务创建完成后，pod可以 通 过external-service.default.svc.cluster.loca l域名（甚至是external-service)连接到外部服务。</p> 
<pre><code class="prism language-bash">apiVersion: vl 
kind: Service 
metadata: 
	name: external-service 
spec: 
	type: ExternalName              <span class="token builtin class-name">type</span> 为ExternalName
	externalName: someapi.somecompany.com     实际服务的完全限定域名
	ports: 
	- port: <span class="token number">80</span>
</code></pre> 
<h3><a id="3__158"></a>3 将服务暴露给外部客户端</h3> 
<ul><li> <p>将服务的类型设置成NodePort<br> – 每个集群节点都会在节点上打 开一个端口， 对于NodePort服务， 每个集群节点在节点本身（因此得名叫NodePort)上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。<br> – 该服务仅在内部集群 IP 和端口上才可访间， 但也可通过所有节点上的专用端口访问。</p> </li><li> <p>将服务的类型设置成LoadBalance, NodePort类型的一 种扩展。<br> – 这使得服务可以通过一个专用的负载均衡器来访问， 这是由Kubernetes中正在运行的云基础设施提供的。 负载均衡器将流量重定向到跨所有节点的节点端口。<br> 客户端通过负载均衡器的 IP 连接到服务。</p> </li><li> <p>创建一 个Ingress资源， 这是一 个完全不同的机制， 通过一 个IP地址公开多<br> 个服务——它运行在 HTTP 层（网络协议第7 层）上， 因此可以提供比工作<br> 在第4层的服务更多的功能。</p> </li></ul> 
<h4><a id="31__NodePort__170"></a>3.1 使用 NodePort 类型的服务</h4> 
<p>将一组pod公开给外部客户端的第一种方法是创建一个服务并将其类型设置为NodePort。 通过创建NodePort服务， 可以让Kubemetes在其所有节点上保留一个端口（所有节点上都使用相同的端口号）， 并将传入的连接转发给作为服务部分的pod。</p> 
<pre><code class="prism language-bash">apiVersion: vl 
kind: Service 
metadata: 
	name: kubia-nodeport
spec: 
	type: NodePort       服务类型
	ports: 
	- port: <span class="token number">80</span>           服务集群端口号
	  targetPort: <span class="token number">8080</span>   背后Pod 的端口号
	  nodePort: <span class="token number">30123</span>   通过集群节点的30123端口访问该服务
	selector: 
	  app: kubia

kubectl get svc kubia-nodeport 

NAME            CLUSTER-IP       EXTERNAL-IP  PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>      AGE 
kubia-nodeport <span class="token number">10.111</span>.254.223    <span class="token operator">&lt;</span>nodes<span class="token operator">&gt;</span>       <span class="token number">80</span>:30123/TCP  2m
</code></pre> 
<p>EXTERNAL-IP列。 它显示nodes,表明服务可通过任何集群节点的IP地址访问。 PORT(S)列显示集群IP (8 0) 的内部端口和节点端口(30123), 可以通过以下地址访问该服务：</p> 
<ul><li>10.11.254.223:80</li><li>&lt;lst node’s IP&gt;:30123</li><li>&lt;2nd node’s IP&gt;:30123, 等等<br> <img src="https://images2.imgbox.com/2f/c9/SdLhBp98_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="32__197"></a>3.2 通过负载均衡器将服务暴露出来</h4> 
<p>云提供商上提供负载平衡器。 负载均衡器拥有自己独一无二的可公开访问的 IP 地址， 并将所有连接重定向到服务。可以通过负载均衡器的 IP 地址访问服务</p> 
<pre><code class="prism language-bash">apiVersion: vl 
kind: Service 
metadata:
	name: kubia-loadbalancer 
spec: 
	type: LoadBalancer 
	portS:
	- port: <span class="token number">80</span> 
	  targetPort: <span class="token number">8080</span>
	selector:
	  app: kubia

kubectl get svc kubia-loadbalancer

NAME              CLUSTER-IP       EXTERNAL-IP     PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>       AGE 
kubia-loadbalancer <span class="token number">10.111</span>.241.153  <span class="token number">130.211</span>.53.173  <span class="token number">80</span>:32143/TCP  lm

</code></pre> 
<p><img src="https://images2.imgbox.com/78/e4/rIb1hPqX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="33__219"></a>3.3 了解外部连接的特性</h4> 
<p>防止不必要的网络跳数，服务配置为仅将外部通信重定向到接收连接的节点上运行的pod来阻止此额外跳数。</p> 
<pre><code class="prism language-bash">spec: 
	exernalTrafficPolicy: Local   
</code></pre> 
<ul><li>如果服务定义包含此设置， 并且通过服务的节点端口打开外部连接， 则服务代理将选择本地运行的pod。 如果没有本地pod存在， 则连接将挂起。</li><li>使用local外部流量策略的服务可能会导致跨pod的负载分布不均衡。<br> <img src="https://images2.imgbox.com/2c/72/aHaMq8sP_o.png" alt="在这里插入图片描述"></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/526d40b0d83682c3d0e60724ab2710b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python使用requests提交post请求并上传文件（multipart/form-data）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ddec5bff564f56eaf527e09401a065cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">并发&amp;多线程编程-synchronized、Volatile</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>