<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s之挂载本地磁盘到POD中 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s之挂载本地磁盘到POD中" />
<meta property="og:description" content="写在前面 本文一起看下如何挂载本地的磁盘到POD中。
1：都需要哪些API对象 现实世界中的存储设备有非常非常多的种类，如本文要分析的计算机磁盘，还包括NFS(一种网络磁盘存储协议)，Ceph（一种分布式的文件存储系统），不管是哪种方式，最终都是通过将数据存储到硬盘来实现持久化，但是不同种类写入数据的方式是不相同的，k8s针对这些不同的存储目标进行抽象定义了PersistentValume API对象，如下：
dongyunqi@mongodaddy:~/k8s$ kubectl api-resources|egrep -w &#39;PersistentVolume|KIND&#39; NAME SHORTNAMES APIVERSION NAMESPACED KIND persistentvolumes pv v1 false PersistentVolume 现在不同存储系统的抽象已经有了，那么具体该怎么使用办呢？能不能让pv拥有这种能力呢？自然是可以的，但是这又不符合单一职责的原则了，所以对于这些存储系统的具体使用k8s又定义了一个新的API对象，Persistent Volume Claim,如下：
dongyunqi@mongodaddy:~/k8s$ kubectl api-resources|egrep -w &#39;PersistentVolumeClaim|KIND&#39; NAME SHORTNAMES APIVERSION NAMESPACED KIND persistentvolumeclaims pvc v1 true PersistentVolumeClaim 最后，这么多的存储系统，当多了之后，混杂在一起，势必造成混乱，为此k8s又定义了StorageClass来进行分类维护，如下：
dongyunqi@mongodaddy:~/k8s$ kubectl api-resources|egrep -w &#39;StorageClass|KIND&#39; NAME SHORTNAMES APIVERSION NAMESPACED KIND storageclasses sc storage.k8s.io/v1 false StorageClass 这样，需要用到的3个API对象我们就介绍完毕了，三者的关系我们可以参考下图：
下面我们看一个实际的例子。
2：挂载磁盘到POD中 毫无疑问，我们需要先定义磁盘的抽象PV，yaml如下：
apiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test accessModes: - ReadWriteOnce capacity: storage: 10Mi hostPath: path: /tmp/host-10m-pv/ 主要属性介绍如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bf97a50bcd16c13b986310fd6aec82c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-16T22:18:56+08:00" />
<meta property="article:modified_time" content="2023-01-16T22:18:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s之挂载本地磁盘到POD中</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>写在前面</h2> 
<p>本文一起看下如何挂载本地的磁盘到POD中。</p> 
<h2><a id="1API_2"></a>1：都需要哪些API对象</h2> 
<p>现实世界中的存储设备有非常非常多的种类，如本文要分析的计算机磁盘，还包括NFS<code>(一种网络磁盘存储协议)</code>，Ceph<code>（一种分布式的文件存储系统）</code>，不管是哪种方式，最终都是通过将数据存储到硬盘来实现持久化，但是不同种类写入数据的方式是不相同的，k8s针对这些不同的存储目标进行抽象定义了PersistentValume API对象，如下：</p> 
<pre><code>dongyunqi@mongodaddy:~/k8s$ kubectl api-resources|egrep -w 'PersistentVolume|KIND'
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
persistentvolumes                 pv           v1                                     false        PersistentVolume
</code></pre> 
<p>现在不同存储系统的抽象已经有了，那么具体该怎么使用办呢？能不能让pv拥有这种能力呢？自然是可以的，但是这又不符合<code>单一职责</code>的原则了，所以对于这些存储系统的具体使用k8s又定义了一个新的API对象，Persistent Volume Claim,如下：</p> 
<pre><code>dongyunqi@mongodaddy:~/k8s$ kubectl api-resources|egrep -w 'PersistentVolumeClaim|KIND'
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
persistentvolumeclaims            pvc          v1                                     true         PersistentVolumeClaim
</code></pre> 
<p>最后，这么多的存储系统，当多了之后，混杂在一起，势必造成混乱，为此k8s又定义了StorageClass来进行分类维护，如下：</p> 
<pre><code>dongyunqi@mongodaddy:~/k8s$ kubectl api-resources|egrep -w 'StorageClass|KIND'
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
storageclasses                    sc           storage.k8s.io/v1                      false        StorageClass
</code></pre> 
<p>这样，需要用到的3个API对象我们就介绍完毕了，三者的关系我们可以参考下图：</p> 
<p><img src="https://images2.imgbox.com/af/d4/GGq2nEAl_o.png" alt="在这里插入图片描述"></p> 
<p>下面我们看一个实际的例子。</p> 
<h2><a id="2POD_27"></a>2：挂载磁盘到POD中</h2> 
<p>毫无疑问，我们需要先定义磁盘的抽象PV，yaml如下：</p> 
<pre><code>apiVersion: v1
kind: PersistentVolume
metadata:
  name: host-10m-pv

spec:
  storageClassName: host-test
  accessModes:
  - ReadWriteOnce
  capacity:
    storage: 10Mi
  hostPath:
    path: /tmp/host-10m-pv/
</code></pre> 
<p>主要属性介绍如下：</p> 
<pre><code>name: host-10m-pv
    名字，见名知意，基于host的10m的pv
storageClassName: host-test
    存储class，进行分类，根据具体业务即可
- ReadWriteOnce
    读写策略，完整如下：
        ReadWriteOnce：存储卷可读可写，但只能被一个节点上的Pod挂载。
        ReadOnlyMany：存储卷只读不可写，可以被任意节点上的Pod多次挂载。
        ReadWriteMany：存储卷可读可写，也可以被任意节点上的Pod多次挂载。
    这里是本地磁盘，自然是只能被一个节点上的POD挂载
storage: 10Mi
    大小10MB，但这里使用的是国际标准，不同于我们用的KB（1024 byte）,MB(1024*1024 byte)，一定不要写错
path: /tmp/host-10m-pv/
    要挂载的本地磁盘目录，没有的话需要手动创建该目录
</code></pre> 
<p>接着我们应用PV,如下：</p> 
<pre><code>kubectl apply -f host-path-pv.yml
</code></pre> 
<p><img src="https://images2.imgbox.com/11/c1/2LdhFfGV_o.png" alt="在这里插入图片描述"></p> 
<p>接着我们就要来使用已经定义的PV了，方式自然是定义persistent volume claim，如下：</p> 
<pre><code>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: host-5m-pvc

spec:
  storageClassName: host-test
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Mi
</code></pre> 
<p><code>storage: 5Mi</code>代表要求的大小是5MB，然后我们应用：</p> 
<pre><code>kubectl apply -f host-path-pv.yml
</code></pre> 
<p>操作完成后k8s就会寻找存储class类型为<code>host-test</code>，大小满足5M的PV，最终找到了<code>pv host-10m-pv</code>，就将其给pvc host-5m-pvc使用，这个使用和被使用确定的过程，我们叫做<code>绑定 bound</code>，如下就显示二者就处于Bound状态了：</p> 
<blockquote> 
 <p>需要的是5m但有10m，此时怎么办呢？剩余5m就免费赠送了，因为没有更合适的了。</p> 
</blockquote> 
<pre><code>dongyunqi@mongodaddy:~/k8s$ kubectl get pv
NAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                 STORAGECLASS   REASON   AGE
host-10m-pv   10Mi       RWO            Retain           Bound    default/host-5m-pvc   host-test               3h27m
dongyunqi@mongodaddy:~/k8s$ kubectl get pvc
NAME          STATUS   VOLUME        CAPACITY   ACCESS MODES   STORAGECLASS   AGE
host-5m-pvc   Bound    host-10m-pv   10Mi       RWO            host-test      3h33m
</code></pre> 
<p>此时PVC已经绑定了PV，接下来我们就该将PVC挂载到POD中了，定义POD如下：</p> 
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: host-pvc-pod

spec:
  volumes:
  - name: host-pvc-vol
    persistentVolumeClaim:
      claimName: host-5m-pvc

  containers:
    - name: ngx-pvc-pod
      image: nginx:alpine
      ports:
      - containerPort: 80
      volumeMounts:
      - name: host-pvc-vol
        mountPath: /tmp
</code></pre> 
<p>通过<code>claimName: host-5m-pvc</code>声明pvc host-5m-pvc为卷volume，然后在<code>volumeMounts</code>挂载卷到<code>mountPath: /tmp</code>目录中，如果一切顺利的话，我们在POD中的/tmp目录更新文件的内容都会同步写到宿主机Node的<code>/tmp/host-10m-pv/</code>目录，应用后，我们进入POD中验证，如下：</p> 
<pre><code>dongyunqi@mongodaddy:~/k8s$ kubectl exec -it host-pvc-pod -- sh
/ # ls /tmp
/ # cd /tmp/
/tmp # ls
/tmp # touch a.txt
/tmp # echo "content writed by pod" &gt; a.txt 
/tmp # cat a.txt 
content writed by pod
/tmp # 
</code></pre> 
<p>查看POD所在Node<code>(注意这里一定要是POD所在的Node,不确定POD在哪里可通过-o wide确定)</code>：</p> 
<pre><code>dongyunqi@mongomummy:~/k8s/images$ cd /tmp/host-10m-pv/
dongyunqi@mongomummy:/tmp/host-10m-pv$ ls
a.txt
dongyunqi@mongomummy:/tmp/host-10m-pv$ cat a.txt 
content writed by pod
</code></pre> 
<p>这样就算POD销毁重建，新建的文件也依然在，也就实现了持久化，如下测试：</p> 
<pre><code>dongyunqi@mongodaddy:~/k8s$ kubectl delete pod host-pvc-pod
pod "host-pvc-pod" deleted
dongyunqi@mongodaddy:~/k8s$ kubectl apply -f host-path-pod.yml 
pod/host-pvc-pod created
dongyunqi@mongodaddy:~/k8s$ kubectl get pod
NAME           READY   STATUS    RESTARTS   AGE
host-pvc-pod   1/1     Running   0          11s
dongyunqi@mongodaddy:~/k8s$ kubectl exec -it host-pvc-pod -- sh
/ # cat /tmp/a.txt 
content writed by pod
/ # exit
dongyunqi@mongodaddy:~/k8s$ 
</code></pre> 
<h2><a id="_155"></a>写在后面</h2> 
<h3><a id="_156"></a>小结</h3> 
<p>本文分析了实现磁盘挂载到POD中需要用到的PV persistent volume，PVC persistent volume claim，Storage Class这三个API对象，并一起看了一个实际的例子，实现了POD中数据的持久化。希望本文能够帮助到你。</p> 
<h3><a id="_159"></a>参考文章列表</h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bac8ec9623fc0ee52df42e2a5ccfc802/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在maya中如何修正相机的枢轴点的变化导致相机动画导入引擎后不正确的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec728e416a1d2e5861b02976bb6ec10a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Chrome浏览器离线安装包下载方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>