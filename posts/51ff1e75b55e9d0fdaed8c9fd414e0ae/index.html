<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MQTT协议解析之QoS Level - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MQTT协议解析之QoS Level" />
<meta property="og:description" content="三个 QoS 级别简介 在 MQTT 协议里，定义了三个级别的 QoS，由低到高分别是:
最多一次 (QoS0)至少一次 (QoS1)有且仅有一次 (QoS2) QoS0 是最低级别，基本上等同于 Fire and Forget 模式，发送者发送完数据之后，不关心消息是否已经投递到了接收者那边。
QoS1 是中间级别，保证消息至少送达一次。MQTT 通过简单的 ACK 机制来保证 QoS1。
QoS2 是最高级别，保证到且仅到一次。这通过更加复杂的消息流程保证。
QoS 级别越高，流程越复杂，系统资源消耗越大。应用程序可以根据自己的网络场景和业务需求，选择合适的 QoS 级别：
比如在同一个子网内部的服务间的消息交互往往选用 QoS0；而通过互联网的实时消息通信往往选用 QoS1；QoS2 使用的场景相对少一些，能想到的如国防武器，医疗设备等应用场景。
既然 QoS 是发送者和接收者之间的质量协定，在 MQTT 协议的 Client - Broker - Client 架构里，QoS 就需要分成两部分来讨论:
从发送者到 Broker 之间消息传递的 QoS。这需要由发送者在 MQTT PUBLISH 消息里设置 QoS 级别。从 Broker 到接收者之间消息传递的 QoS。这需要接收者在订阅 Topic 时，设置 SUBSCRIBE 消息里的 QoS 级别。 MQTT发布消息QoS保证不是端到端的，是客户端与服务器之间的。订阅者收到MQTT消息的QoS级别，最终取决于发布消息的QoS和主题订阅的QoS。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/51ff1e75b55e9d0fdaed8c9fd414e0ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T14:02:22+08:00" />
<meta property="article:modified_time" content="2022-07-28T14:02:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MQTT协议解析之QoS Level</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>三个 QoS 级别简介</h2> 
<p>在 MQTT 协议里，定义了三个级别的 QoS，由低到高分别是:</p> 
<ul><li>最多一次 (QoS0)</li><li>至少一次 (QoS1)</li><li>有且仅有一次 (QoS2)</li></ul> 
<p>QoS0 是最低级别，基本上等同于 <code>Fire and Forget</code> 模式，发送者发送完数据之后，不关心消息是否已经投递到了接收者那边。</p> 
<p>QoS1 是中间级别，保证消息至少送达一次。MQTT 通过简单的 ACK 机制来保证 QoS1。</p> 
<p>QoS2 是最高级别，保证到且仅到一次。这通过更加复杂的消息流程保证。</p> 
<p>QoS 级别越高，流程越复杂，系统资源消耗越大。应用程序可以根据自己的网络场景和业务需求，选择合适的 QoS 级别：</p> 
<p>比如在同一个子网内部的服务间的消息交互往往选用 QoS0；而通过互联网的实时消息通信往往选用 QoS1；QoS2 使用的场景相对少一些，能想到的如国防武器，医疗设备等应用场景。</p> 
<p>既然 QoS 是发送者和接收者之间的质量协定，在 MQTT 协议的 <code>Client - Broker - Client</code> 架构里，QoS 就需要分成两部分来讨论:</p> 
<ol><li>从发送者到 Broker 之间消息传递的 QoS。这需要由发送者在 MQTT PUBLISH 消息里设置 QoS 级别。</li><li>从 Broker 到接收者之间消息传递的 QoS。这需要接收者在订阅 Topic 时，设置 SUBSCRIBE 消息里的 QoS 级别。</li></ol> 
<p>MQTT发布消息QoS保证不是端到端的，是客户端与服务器之间的。订阅者收到MQTT消息的QoS级别，最终取决于发布消息的QoS和主题订阅的QoS。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b3/43/x5AO8Y25_o.jpg"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/45/f3/Nhwv0aQS_o.jpg"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fd/be/tnJoz2KT_o.jpg"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/33/5f/aG8PSGbK_o.jpg"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d22cec8ca4c3c1259581a3bf81cdca1f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">支付宝如何生成及配置公钥证书</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10fe5a6be70a6448bfb4afa0a772f15a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43;（27）STL:容器、算法、迭代器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>