<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM内存分配策略及垃圾收集器简介 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM内存分配策略及垃圾收集器简介" />
<meta property="og:description" content="Java的内存分配策略 1.对象优先分配在Eden区 大多数情况下，对象都是优先分配在新生代eden区的，当eden区内存不够的时候就会发生Minor GC。
当没有eden区内存不够，开始进行minorGC时，若在这期间又发现已经分配了内存的空间allocation1无法存入存活区Survivor区，只能通过**空间分配担保机制（后面第五点会讲到）**把新生代提前转移到老年代，若老年代上的空间足够存放这个allocation1分区就不会出现fullGC
2.大对象直接进入老年代 什么是大对象？
大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
大对象经常出现会带来什么问题？
经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
如何设置大对象的阈值？
-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。
3.长期存活的对象进入老年代 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
如何设置年龄阈值？
-XX:MaxTenuringThreshold 用来定义年龄的阈值。
4.动态对象年龄判断 虚拟机并不是永远都要求对象的年龄必须达到-XX:MaxTenuringThreshold所配置的数字才能晋升老年代，如果在survivor中相同年龄所有对象的大小的总和大于survivor分区的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到满足MaxTenuringThreshold要求的年龄。
5.空间分配担保 在JDK6 Update24后，规则变成—— 只要老年代连续的内存空间大于新生代对象的总大小 或者 历次晋升的平均大小就会进行MinorGC，否则就会进行FullGC。
Java垃圾收集器组合 Serial收集器&#43;Serial Old收集器 Serial**（串行）收集器是最基本、历史最悠久**的垃圾收集器了。
新生代才用标记-复制算法，老年代标记-整理算法
Serial收集器 优点：简单高效，因为是单线程，没有线程交互的开销，因此拥有最高的单线程收集效率
Serial Old收集器 Serial收集器的老年代版本
ParNew收集器&#43;CMS收集器 parNew收集器 负责新生代的收集器
serial收集器的多版本线程，线程的数量跟cpu数量相同（默认）
可以通过-XX:ParallelGCThreads 参数来设置线程数。
新生代才用复制算法，老年代才用标记-整理算法，只能和cms垃圾收集器配合工作
CMS收集器 负责老年代的收集
重视响应速度、低停顿 的一个垃圾收集器（使用“标记-清除”算法
CMS收集器是一种以获取最短回收停顿时间为目标的收集器（针对尤其重视服务的响应速度的情况，挺短时间越短越适合需要与用户交互的程序，良好的相应速度能给用户带来较好的体验）
优点：
并发收集低停顿 缺点：
使用的回收算法“标记-清除”算法会导致收集结束时产生大量的空间碎片，往往出现老年代空间剩余，但无法找到足够大的连续空间来分配当前而不得不提前触发一次Full GC。吞吐量低：CMS的低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不够高。并发收集阶段会降低吞吐量对CPU资源敏感无法处理浮动垃圾，可能出现Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC时才能进行回收。（由于浮动垃圾的存在，因此需要预留出一部分内存，意味着CMS手机不能像其他收集器那样等待老年代快满的时候回收。）【若预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将临时启用Serial Old来替代CMS】 控制参数：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eaca23585d0584e2f4d735b5dfef0cf2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T14:34:40+08:00" />
<meta property="article:modified_time" content="2024-01-01T14:34:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM内存分配策略及垃圾收集器简介</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Java_0"></a>Java的内存分配策略</h2> 
<h3><a id="1Eden_2"></a>1.对象优先分配在Eden区</h3> 
<p><strong>大多数情况下，对象都是优先分配在新生代eden区的，当eden区内存不够的时候就会发生Minor GC。</strong></p> 
<blockquote> 
 <p>当没有eden区内存不够，开始进行minorGC时，若在这期间又发现已经分配了内存的空间allocation1无法存入存活区Survivor区，只能通过**空间分配担保机制（后面第五点会讲到）**把新生代提前转移到老年代，若老年代上的空间足够存放这个allocation1分区就不会出现fullGC</p> 
</blockquote> 
<h3><a id="2_12"></a>2.大对象直接进入老年代</h3> 
<p><strong>什么是大对象？</strong></p> 
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p> 
<p><strong>大对象经常出现会带来什么问题？</strong></p> 
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p> 
<p><strong>如何设置大对象的阈值？</strong></p> 
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p> 
<h3><a id="3_32"></a>3.长期存活的对象进入老年代</h3> 
<p>为对象定义年龄计数器，<strong>对象在 Eden 出生</strong>并经过 Minor GC 依然存活，<strong>将移动到 Survivor 中</strong>，年龄就增加 1 岁，<strong>增加到一定年龄则移动到老年代</strong>中。</p> 
<p><strong>如何设置年龄阈值？</strong></p> 
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p> 
<h3><a id="4_44"></a>4.动态对象年龄判断</h3> 
<p>虚拟机并不是永远都要求对象的年龄必须达到-XX:MaxTenuringThreshold所配置的数字才能晋升老年代，如果在survivor中相同年龄所有对象的大小的总和大于survivor分区的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到满足MaxTenuringThreshold要求的年龄。</p> 
<h3><a id="5_50"></a>5.空间分配担保</h3> 
<p>在JDK6 Update24后，规则变成—— <strong>只要老年代连续的内存空间大于新生代对象的总大小 或者 历次晋升的平均大小就会进行MinorGC，否则就会进行FullGC。</strong></p> 
<h2><a id="Java_56"></a>Java垃圾收集器组合</h2> 
<h3><a id="SerialSerial_Old_58"></a>Serial收集器+Serial Old收集器</h3> 
<blockquote> 
 <p>Serial**（串行）<strong>收集器是</strong>最基本、历史最悠久**的垃圾收集器了。</p> 
</blockquote> 
<p>新生代才用<strong>标记-复制</strong>算法，老年代<strong>标记-整理</strong>算法</p> 
<p><img src="https://images2.imgbox.com/90/f8/k6qNdAz9_o.png" alt="image-20240101104054574"></p> 
<h4><a id="Serial_66"></a><strong>Serial收集器</strong></h4> 
<p>优点：简单高效，因为是单线程，没有线程交互的开销，因此<strong>拥有最高的单线程收集效率</strong></p> 
<h4><a id="Serial_Old_72"></a><strong>Serial Old收集器</strong></h4> 
<p>Serial收集器的老年代版本</p> 
<h3><a id="ParNewCMS_80"></a>ParNew收集器+CMS收集器</h3> 
<h4><a id="parNew_82"></a><strong>parNew收集器</strong></h4> 
<p>负责新生代的收集器</p> 
<blockquote> 
 <p>serial收集器的多版本线程，线程的数量跟cpu数量相同（默认）</p> 
 <p>可以<strong>通过-XX:ParallelGCThreads 参数</strong>来设置线程数。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b4/84/CuNqVaiZ_o.png" alt="image-20240101105349387"></p> 
<p>新生代才用复制算法，老年代才用标记-整理算法，<font color="#F36208">只能和cms垃圾收集器配合工作</font></p> 
<h4><a id="CMS_98"></a><strong>CMS收集器</strong></h4> 
<p>负责老年代的收集</p> 
<blockquote> 
 <p><font color="#c22e2e">重视响应速度、低停顿 </font>的一个垃圾收集器（使用“标记-清除”算法</p> 
</blockquote> 
<p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器（针对尤其重视服务的响应速度的情况，挺短时间越短越适合需要与用户交互的程序，良好的相应速度能给用户带来较好的体验）</p> 
<p><img src="https://images2.imgbox.com/a0/f2/eosuxPUG_o.png" alt="image-20240101110213100"></p> 
<p><strong>优点：</strong></p> 
<ul><li>并发收集</li><li>低停顿</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>使用的回收算法“标记-清除”算法会导致收集结束时产生大量的空间碎片，往往出现老年代空间剩余，但无法找到足够大的连续空间来分配当前而不得不提前触发一次Full GC。</li><li>吞吐量低：CMS的低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不够高。</li><li>并发收集阶段会降低吞吐量</li><li><font color="#F36208">对CPU资源敏感</font></li><li>无法处理浮动垃圾，可能出现Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC时才能进行回收。（由于浮动垃圾的存在，因此需要预留出一部分内存，意味着CMS手机不能像其他收集器那样等待老年代快满的时候回收。）【若预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将临时启用Serial Old来替代CMS】</li></ul> 
<p><strong>控制参数</strong>：</p> 
<ul><li>-XX:+UseConcMarkSweepGC —— 使用CMS收集器</li><li>-XX:+UseCMSCompactAtFullCollection —— Full GC后，进行一次碎片整理；<strong>整理过程是独占的，会引起停顿时间变长</strong></li><li>-XX:+CMSFullGCsBeforeCompaction —— 设置进行几次Full GC后，进行一次碎片整理</li><li>-XX:ParallelCMSThreads —— 设定CMS的线程数量（一般情况约等于可用CPU数量）</li></ul> 
<p><strong>执行流程</strong></p> 
<ul><li> <p>初始标记（STW）：</p> <p>仅仅只是标记一下GC Roots能直接关联到的对象，速度非常快，但是需要停顿。</p> </li><li> <p>并发标记：</p> <p>同时开启GC和用户线程，用一个闭包结构去记录可达对象。（耗时长，但是不需要停顿）</p> </li><li> <p>重新标记（STW）：</p> <p>重新标记阶段就是<strong>为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>（这个阶段的停顿时间一般会比初始阶段的标记时间长，但远远比并发标记的时间短，且需要停顿）</p> </li><li> <p>并发清除</p> <p>开启用户线程，同时GC线程开始对未标记的区域做清扫（耗时长，不需要停顿）</p> </li></ul> 
<blockquote> 
 <p>在整个标记过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p> 
</blockquote> 
<p>所以，总体上来说，CMS收集器的内存回收过程与用户线程一起并发地执行。</p> 
<h3><a id="Parallel_Scavenge_Parallel_Old_156"></a>Parallel Scavenge收集器+ Parallel Old收集器</h3> 
<blockquote> 
 <p>Java1.8版本的默认垃圾收集器，<strong>被称为“吞吐量优先”收集器</strong></p> 
 <p>和ParNew一样是多线程收集器</p> 
 <p><strong>新生代才用标记-复制算法，老年代才用标记-整理算法</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e0/6a/AfVrAhf7_o.png" alt="image-20240101114745220"></p> 
<p><strong>适用场景：</strong></p> 
<p><strong>高吞吐可以高效率地利用cpu时间，尽快完成程序的运算任务，主要是适合在后台运算而不需要太多交互的任务。</strong></p> 
<p><font color="#c22e2e">缩短停顿时间是以牺牲吞无量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降</font></p> 
<p><font color="#F36208">在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</font></p> 
<h3><a id="G1_178"></a>G1收集器</h3> 
<p>G1是一款面向服务端应用的垃圾收集器，在多cpu和大内存的场景下有很好的性能。（通常是4GB或更大）它能够在不牺牲太多吞吐量的情况下，提供更可控的停顿时间<font color="#c22e2e">（建议的内存大小为8GB或更大，并且至少具有4个CPU核心。）</font></p> 
<blockquote> 
 <p>堆被分为新生代和老年代，其他收集器进行收集的范围都是整个新生代或者老年代，<strong>而G1可以直接堆新生代和老年代一起回收</strong></p> 
</blockquote> 
<h4><a id="G1_184"></a>G1垃圾收集器适合是什么时候使用？</h4> 
<ol><li>大内存的情况下适合G1</li><li>对象分配和晋升速度变化很大。</li><li>垃圾回收时间特别长，超过1s</li><li>8g以上堆内存可以用。</li><li>停顿时间500ms以上。</li></ol> 
<h4><a id="G1_192"></a>G1垃圾收集器的特点</h4> 
<ul><li> <p>空间整合：</p> <p>从整体来看是基于“标记-整理”算法实现的收集器，<font color="#F36208">但是从局部来看，实际上是基于两个Region之间的基于“复制”算法实现的，这意味这运行期间不会产生内存空间碎片。</font>【标记复制算法】</p> </li><li> <p>可预测的停顿：</p> <p><font color="#F36208">能让使用者明确制定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒</font></p> </li></ul> 
<h4><a id="_204"></a>标记-复制算法</h4> 
<p>下面以G1为例，<strong>通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法）</strong></p> 
<p><img src="https://images2.imgbox.com/86/63/hpHVrtJA_o.png" alt="image-20240101123752338"></p> 
<p>标记复制算法的三个阶段：</p> 
<p>**标记阶段：**即从GC Roots集合开始，标记活跃对象。</p> 
<p>**转移阶段：**即把活跃对象复制到新的内存地址上。</p> 
<p>**重定位阶段：**因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新地址上。</p> 
<p><font color="#F36208">G1的<strong>混合回收</strong>过程分为：标记阶段、清理阶段、复制阶段</font></p> 
<p><img src="https://images2.imgbox.com/42/94/ZufNQCRv_o.png" alt="image-20240101122449524"></p> 
<p>G1把堆划分成多个大小相同的独立区域（Region），新生代和老年代不一定的是物理隔离（只是在逻辑上是连续的）【分区概念】</p> 
<blockquote> 
 <p>启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a1/6f/G261qvqM_o.png" alt="image-20240101122723365"></p> 
<p>好处：通过引入Region的概念，从而将原来的一整块内存空间划分为多个小空间，使得每个小空间可以单独进行垃圾回收。</p> 
<p>这种划分方式带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录<strong>每个Region垃圾回收时间</strong>以及<strong>回收所获得的空间</strong>(这两个值是通过过去回收的经验获得)，并维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region。</strong></p> 
<p>每个Region都有一个Remembered Set（已记忆集合）， 用来记录该Region对象的引用法对象所在的Region。（通过Remembered Set，在做可达性分析的时候就可以避免全堆扫描）</p> 
<h4><a id="G1_238"></a>G1垃圾收集器的收集步骤</h4> 
<ol><li> <p><strong>标记阶段（STW）</strong></p> <p>首先<font color="#F36208">初始标记</font>这个阶段是会停顿的，并且会触发一次普通的Mintor GC（对应GC log:GC pause (young) (inital-mark)）</p> </li><li> <p><strong>Root Region Scaning</strong></p> <p>程序运行过程中会回收survivor区，<strong>这一过程必须在young GC之前完成</strong></p> </li><li> <p><strong>Concurrent Marking</strong></p> <p>在整个堆中进行<font color="#F36208">并发标记</font>(和应用程序是并发执行的)，此过程可能被young GC打断。</p> <p>（在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个区域就会被立即回收，如图中打×的地方）</p> <p><font color="#F36208">同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）</font></p> </li><li> <p><strong>Remark，再标记(STW)</strong></p> <p>会有短暂的停顿。再标记阶段用来收集并发阶段产生的垃圾（并发阶段和应用程序一同运行）；<font color="#F36208">G1才用了比CMS更快的初始快找算法（SATB）</font></p> </li><li> <p><strong>Copy/Clean up，多线程清除失活对象(STW)</strong></p> <p>会有停顿。G1将回收区域的存过对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p> </li><li> <p><strong>复制/清除过程后</strong></p> <p>回收区域的活性对象已经被集中回收到社蓝色和深绿色区域。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/eb/cb/kxdpeTPt_o.png" alt="image-20240101131008896"></p> 
<p><img src="https://images2.imgbox.com/2e/88/wasb2jUY_o.png" alt="image-20240101131017277"></p> 
<p><img src="https://images2.imgbox.com/e4/f3/P1zviAKi_o.png" alt="image-20240101131025321"></p> 
<h4><a id="G1_274"></a>G1收集器的运作流程</h4> 
<p><strong>如果不计算维护 Remembered Set 的操作</strong>，G1 收集器的运作大致可划分为以下几个步骤:</p> 
<ol><li> <p>初始标记</p> </li><li> <p>并发标记</p> </li><li> <p>最终标记（STW）</p> <p><strong>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</strong>，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</p> </li><li> <p>筛选回收</p> <p>首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（此阶段其实也可以做到与用户程序一起并发执行的，但是因为只回收一部分的Region，时间是用户可控制的【停顿时间可控】，而且停顿用户线程将大幅度提高收集效率）</p> </li></ol> 
<h3><a id="ZGC_292"></a>ZGC收集器</h3> 
<blockquote> 
 <p>ZGC作为下一代垃圾回收器，性能非常优秀。ZGC垃圾回收过程几乎全部是并发，实际STW停顿时间极短，不到10ms。</p> 
 <p>这得益于其采用的着色指针和读屏障技术</p> 
</blockquote> 
<h4><a id="ZGC_298"></a>ZGC垃圾收集器特点</h4> 
<ul><li>ZGC是单代垃圾收集器，而CMS是分代垃圾收集器。单代垃圾回收期每次处理的对象更多，更耗费cpu资源</li><li>ZGC使用读屏障，读屏障操作更需耗费额外的计算资源</li></ul> 
<h4><a id="ZGC_303"></a>ZGC垃圾收集器适合什么时候使用？</h4> 
<p><font color="#c22e2e">ZGC垃圾收集器是一种低延迟的垃圾收集器，适用于需要非常短的停顿时间的应用程序。</font></p> 
<p>它适用于大内存容量（通常是16GB或更大）和多核CPU的环境。<strong>（建议的内存大小为16GB或更大，并且至少具有8个CPU核心。）</strong></p> 
<h4><a id="ZGC_309"></a>全并发的ZGC</h4> 
<p>与CMS中的ParNew和G1类似，<strong>ZGC也才用了标记-复制算法(改进过的)</strong>，不过<font color="#c22e2e">ZGC对该算法进行了重大改进：ZGC在标记。转移和重定位阶段几乎都是并发的，这是ZGC实现挺短时间小于10ms目标的最关键原因</font></p> 
<h4><a id="ZGC_313"></a>ZGC垃圾回收周期</h4> 
<p><img src="https://images2.imgbox.com/3b/fd/u0AApK6d_o.png" alt="image-20240101135241492"></p> 
<blockquote> 
 <p><font color="#F36208">ZGC只有三个STW的阶段：初始标记、再标记、初始转移</font></p> 
</blockquote> 
<p>其中，<strong>初始标记和初始转移</strong>分别都只需要扫描所有的GC Roots，其处理时间和GcRoots的数量成正比，一般情况耗时非常短</p> 
<p><strong>再标记</strong>阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。（即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。）</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/022174caa14c0f6367493fbe6b34c0d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL5.7服务器 SQL 模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2682928a74943c0e3241b84b1aa55b89/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">matplotlib绘制柱状图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>