<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android基础和运行机制 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android基础和运行机制" />
<meta property="og:description" content="Android应用程序是用Java语言写的，通过aapt工具把应用程序所需要的任何数据、资源文件打包成apk文件，这个文件是一个将应用安装到手机上的一个载体。 每个Android应用程序存在于不同的世界：
(1)默认的，每个应用在他自己的Linux进程中运行，当应用中的任何代码需要执行时Android就启动相应的进程，当不需要执行时并且系统资源被其他应用请求时android就关闭相应的进程。
(2)每个进程都有他自己的虚拟机对象(VM)，所以应用程序代码与其他的应用运行是彼此隔离的。
(3)默认的，每个应用被分配一个唯一的Linux user ID，都被设置权限以便应用程序的文件只对用户可见或者只对应用自己可见。安排两个应用程序共享一个user ID是可能的，这种情况下他们彼此之间是可以看见对方的文件的，为了保护系统资源，拥有相同ID的应用也能被安排运行在一个相同的Linux进程中，共享相同的VM。
1、应用组件(Application Components)
Android一个核心的特点就是一个应用能使用另一个应用的元素(如果另一个应用允许的话)，你的应用不需要包含你用到的另一个应用的代码也不需要你连接这些代码，相反的，只是当应用需要这些代码时，就启动另一个应用相应的代码(不是让另一个应用全部启动)
为了这个能工作，当一个应用的任何部分被需要时系统必须能启动这个应用进程，并且将这个部分实例化成java对象，因此，和其他大多数系统不同的 是，android应用程序没有一个单独的程序入口(例如：没有main()函数)，相反的，android应用有必要的组件以便当需要时系统能实例化并 运行它，android中有四种组件：
(1)Activity
一个Activity是一个可见的用户可以使用的用户界面，如果一个应用中有多个Activity，虽然彼此结合形成一个应用在一起工作，但是每个Activity是彼此独立的，每个都是Activity的一个子类。
一个应用程序可能由一个或多个Activity组成，这些Activity这么样显示，需要多少个Activity，依赖于这个应用的设计者，一般的，有一个Activity应该被标记成当这个应用启动时第一个呈现出来给用户的。
每个Activity默认的被给予一个窗口来绘制，一般的，这个窗口占满整个屏幕，但是他可以比屏幕小并且浮在另一个窗口的上面。
一个窗口中的可见的内容是由一些具有层次关系的view组成的，都是继承自View类的，每个view都控制一个窗口中的特定的矩形框，parent view 包含children view和组织children view的布局，leaf view(那些在继承层次最底层的view)绘制在他们所控制的矩形框中，并且对用户的动作做出直接的回应，因此view就是Activity和用户交互的地方，android有很多已经做好的view你可以使用，包括buttons，text fields，scroll bars，menu items，check boxes等等
一个view hierarchy是通过Activity.setContentView()方法被放到一个Activity的window中的，content view是view hierarchy中最顶端的那个view。
(2)Services
一个service不是一个用户可见的组件，在不确定的一段时间内运行在后台，每个service都继承自Service类。
你可以连接(connect)或者绑定(bind)到一个正在运行的service(如果这个service还没运行的话就启动它)，当连接到service后，你可以通过一个service暴露出来的接口和这个service交流，对music service来说，这个接口可以是允许用户暂停，后退，停止，重新播放。
和Activity或者其他组件一样，service运行在这个应用进程的主线程中，所以他不会阻塞其他的组件或者用户界面，他们经常为那些耗时长的任务单独开一个线程。
(3)Broadcast receivers
一个broadcast receiver这样一个组件，他只是接收广播并作出反应，在系统中有很多已有的广播，比如反应时区变化(timezone)的，电池变化 (battery)的，用户修改了系统语言时的广播，应用程序也可以自己定义广播，比如定义这样一个广播，让其他的应用知道某些数据已经下载完毕了可以使 用了。
一个应用可以有任意多个broadcast receiver来对他所关心的广播进行监听并作出反应。所有的receiver都继承自BroadcastReceiver类。
BroadcastReceiver不显示在用户界面上，然而，他们可以启动一个Activity来作为他们接收到的信息一种反应，或者他们可以使用 NotificationManager来提示用户，Notifications可以通过不同的方式获得用户的注意，比如点亮呼吸灯，震动电话，播放一个 声音等等，他们一般放一个图标在状态栏上，来让用户可以打开获得这些信息。
(4)Content providers
Content providers是一个应用程序数据的集合，来让其他的应用可以访问这些数据，这些数据可以被存在文件系统中，SQLite数据库中，或者其他可以存数据的地方，Content providers是一个基本的方法集合来使其他的应用可以获得和存储这些数据，然而应用不直接调用这些方法，而是使用一个ContentResolver对象来调用这些方法，一个ContentResolver可以和任何的Content providers交流，他和provider协作来管理系统中任何进程间的通信。
无论何时一个请求都应该由一个特定的组件来处理，android系统来确保包含这个组件的应用进程运行，如果需要就启动它，如果需要就为这个组件创造一个实例，确保这个组件的一个适当的实例可以被得到。
2、启动组件：intent
当有一个来自于content resolver的请求指向Content provider时，content provider启动，其他的三个组件(Activity，service，broadcast receiver)是通过一个叫做intent的异步的消息来启动的，一个intent持有一个message的内容，对Activity和service来说，他是一个被要求的动作(action)和在该动作上的数据的URI，对broadcast receiver来说，intent对象是一个被广播的动作。
针对每种组件分别有对应的方法来启动它：
(1)一个 Activity是通过传递一个Intent对象到Context.startActivity()或者 Activity.startActivityForResult()来启动的(或者去做一些新的任务)，被启动的这个Activity可以通过 getIntent()来获得导致他启动的那个intent的。
(2)一个service是通过传递一个Intent对象到 Context.startService()来启动的(或者给一些新的命令给正在运行的service)，android调用service的 onStart()方法，并且把Intent对象传递给他，同样的，一个Intent可以传递到Context." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/43973fa4cd0f018c5c8eea1f00e79820/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-08-07T20:39:29+08:00" />
<meta property="article:modified_time" content="2016-08-07T20:39:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android基础和运行机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="font-size:21px; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif"> <strong><span style="line-height:1.5; font-size:16px">Android应用程序是用Java语言写的，通过aapt工具把应用程序所需要的任何数据、资源文件打包成apk文件，这个文件是一个将应用安装到手机上的一个载体</span>。</strong></h3> 
<div class="postText" style="color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px"> 
 <div id="cnblogs_post_body" style="margin-bottom:20px; word-break:break-word"> 
  <p style="line-height:1.5; margin:10px auto">每个Android应用程序存在于不同的世界：<br> 　　(1)默认的，每个应用在他自己的Linux进程中运行，当应用中的任何代码需要执行时Android就启动相应的进程，当不需要执行时并且系统资源被其他应用请求时android就关闭相应的进程。<br> 　　(2)每个进程都有他自己的虚拟机对象(VM)，所以应用程序代码与其他的应用运行是彼此隔离的。<br> 　　(3)默认的，每个应用被分配一个唯一的Linux user ID，都被设置权限以便应用程序的文件只对用户可见或者只对应用自己可见。安排两个应用程序共享一个user ID是可能的，这种情况下他们彼此之间是可以看见对方的文件的，为了保护系统资源，拥有相同ID的应用也能被安排运行在一个相同的Linux进程中，共享相同的VM。</p> 
  <p style="line-height:1.5; margin:10px auto">1、应用组件(Application Components)<br> 　　Android一个核心的特点就是一个应用能使用另一个应用的元素(如果另一个应用允许的话)，你的应用不需要包含你用到的另一个应用的代码也不需要你连接这些代码，相反的，只是当应用需要这些代码时，就启动另一个应用相应的代码(不是让另一个应用全部启动)<br> 　 　为了这个能工作，当一个应用的任何部分被需要时系统必须能启动这个应用进程，并且将这个部分实例化成java对象，因此，和其他大多数系统不同的 是，android应用程序没有一个单独的程序入口(例如：没有main()函数)，相反的，android应用有必要的组件以便当需要时系统能实例化并 运行它，android中有四种组件：</p> 
  <p style="line-height:1.5; margin:10px auto">(1)Activity<br> 　　一个Activity是一个可见的用户可以使用的用户界面，如果一个应用中有多个Activity，虽然彼此结合形成一个应用在一起工作，但是每个Activity是彼此独立的，每个都是Activity的一个子类。<br> 　　一个应用程序可能由一个或多个Activity组成，这些Activity这么样显示，需要多少个Activity，依赖于这个应用的设计者，一般的，有一个Activity应该被标记成当这个应用启动时第一个呈现出来给用户的。<br> 　　每个Activity默认的被给予一个窗口来绘制，一般的，这个窗口占满整个屏幕，但是他可以比屏幕小并且浮在另一个窗口的上面。<br> 　　一个窗口中的可见的内容是由一些具有层次关系的view组成的，都是继承自View类的，每个view都控制一个窗口中的特定的矩形框，parent view 包含children view和组织children view的布局，leaf view(那些在继承层次最底层的view)绘制在他们所控制的矩形框中，并且对用户的动作做出直接的回应，因此view就是Activity和用户交互的地方，android有很多已经做好的view你可以使用，包括buttons，text fields，scroll bars，menu items，check boxes等等<br> 　　一个view hierarchy是通过Activity.setContentView()方法被放到一个Activity的window中的，content view是view hierarchy中最顶端的那个view。<br> 　　(2)Services<br> 　　一个service不是一个用户可见的组件，在不确定的一段时间内运行在后台，每个service都继承自Service类。<br> 　　你可以连接(connect)或者绑定(bind)到一个正在运行的service(如果这个service还没运行的话就启动它)，当连接到service后，你可以通过一个service暴露出来的接口和这个service交流，对music service来说，这个接口可以是允许用户暂停，后退，停止，重新播放。<br> 　　和Activity或者其他组件一样，service运行在这个应用进程的主线程中，所以他不会阻塞其他的组件或者用户界面，他们经常为那些耗时长的任务单独开一个线程。<br> 　　(3)Broadcast receivers<br> 　　一个broadcast receiver这样一个组件，他只是接收广播并作出反应，在系统中有很多已有的广播，比如反应时区变化(timezone)的，电池变化 (battery)的，用户修改了系统语言时的广播，应用程序也可以自己定义广播，比如定义这样一个广播，让其他的应用知道某些数据已经下载完毕了可以使 用了。<br> 　　一个应用可以有任意多个broadcast receiver来对他所关心的广播进行监听并作出反应。所有的receiver都继承自BroadcastReceiver类。<br> 　　 BroadcastReceiver不显示在用户界面上，然而，他们可以启动一个Activity来作为他们接收到的信息一种反应，或者他们可以使用 NotificationManager来提示用户，Notifications可以通过不同的方式获得用户的注意，比如点亮呼吸灯，震动电话，播放一个 声音等等，他们一般放一个图标在状态栏上，来让用户可以打开获得这些信息。<br> 　　(4)Content providers<br> 　　Content providers是一个应用程序数据的集合，来让其他的应用可以访问这些数据，这些数据可以被存在文件系统中，SQLite数据库中，或者其他可以存数据的地方，Content providers是一个基本的方法集合来使其他的应用可以获得和存储这些数据，然而应用不直接调用这些方法，而是使用一个ContentResolver对象来调用这些方法，一个ContentResolver可以和任何的Content providers交流，他和provider协作来管理系统中任何进程间的通信。<br> 　　无论何时一个请求都应该由一个特定的组件来处理，android系统来确保包含这个组件的应用进程运行，如果需要就启动它，如果需要就为这个组件创造一个实例，确保这个组件的一个适当的实例可以被得到。</p> 
  <p style="line-height:1.5; margin:10px auto">2、启动组件：intent</p> 
  <p style="line-height:1.5; margin:10px auto">　　当有一个来自于content resolver的请求指向Content provider时，content provider启动，其他的三个组件(Activity，service，broadcast receiver)是通过一个叫做intent的异步的消息来启动的，一个intent持有一个message的内容，对Activity和service来说，他是一个被要求的动作(action)和在该动作上的数据的URI，对broadcast receiver来说，intent对象是一个被广播的动作。<br> 　　针对每种组件分别有对应的方法来启动它：<br> 　　(1)一个 Activity是通过传递一个Intent对象到Context.startActivity()或者 Activity.startActivityForResult()来启动的(或者去做一些新的任务)，被启动的这个Activity可以通过 getIntent()来获得导致他启动的那个intent的。<br> 　　(2)一个service是通过传递一个Intent对象到 Context.startService()来启动的(或者给一些新的命令给正在运行的service)，android调用service的 onStart()方法，并且把Intent对象传递给他，同样的，一个Intent可以传递到Context.bindService()方法里来建立 一个介于正在运行的service和调用他的组件之间的连接，这个service通过onBind()方法来接收这个Intent对象，(如果这个 service还没有运行，bindservice()能选择性的启动它)，在后面的部分，关于绑定service的更多详细的信息请查看远程调用。<br> 　　(3)一个应用可以通过传递一个Intent对象给像Context.sendBroadcast(), Context.sendOrderedBroadcast(), Context.sendStickyBroadcast()这样的方法来开始一个广播，android通过调用对应的onReceive()方法将intent传递给所有对这个广播感兴趣的broadcast receiver。<br> 3、关闭组件(Shutting down components)<br> 当对来自于content resolver的请求作出回应时content provider就启动了，当有一个感兴趣的broadcast message被广播时，broadcast receiver启动，所以我们需要知道怎么关闭这些组件。<br> 　　(1)Activity可以通过调用它自己的finish()方法来关闭，一个 Activity也可以通过调用finishActivity()来关闭另一个Activity(这个Activity是通过调用 startActivityForResult()来启动的)。<br> 　　(2)一个service可以通过调用自己的stopSelf()，或者Context.stopService()来关闭。<br> 　　当组件不再使用时或者android为了更多组件能运行而回收内存时，android系统是关闭这些组件的，在后面的部分，可以在组件的生命周期中看到更多更详细的介绍</p> 
  <p style="line-height:1.5; margin:10px auto"> </p> 
  <div id="cnblogs_post_body" style="margin-bottom:20px; word-break:break-word"> 
   <p style="line-height:1.5; margin:10px auto">4、Activities and Tasks<br> 　　一个Activity可以启动另一个Activity，即使这个Activity是定义在另一个应用里的，比如说，你想展示给用户 一条街的地图，现在已经有一个Activity可以做这件事，那么现在你需要做的就是将你请求的信息放进一个Intent对象里，并且通过 startActivity()传递给他，这个地图就可以显示出来了，但用户按下BACK键时，你的Activity又重新出现在屏幕上。<br> 　　对 用户来说，显示地图的Activity和你的Activity好像在一个应用中的，即使是他们是定义在不用的应用中的，运行在各自的应用进程 中，android将两个Activity放进一个task里，一个task是一组彼此联系的Activity，被安排在一个堆栈中，堆栈中的根 Activity就是开辟这个task的，一般的，他是用户选择应用后首先启动的那个Activity，堆栈顶部的Activity是当前正在运行的 Activity，当一个Activity启动另一个Activity时，新的Activity被压进堆栈中，成为运行的Activity，当用户按下 BACK键，当前的Activity弹出堆栈，先前的Activity恢复成为运行的Activity。<br> 　　一个task就是一组Activity的堆栈，不是在manifest文件里的一个类，一个元素，所以没有方法来为一个task里的Activity独立的设置值，对task设置值是在root Activity里设置的。<br> 　　一个task里的所有Activity组成一个单元，整个task(整个Activity堆栈)可以在前台，也可 以在后台(应用程序的切换就是task的前后台的切换)，假设，当前的task有四个Activity在堆栈里，用户按下HOME键，去开启另一个应用 (实际上是一个新的task)，那么当前的task就退到后台运行，新开启的应用的root Activity此时就显示出来了，然后，过了一段时间，用户回到主界面，又重新选择了以前的那个应用(先前的那个task)，那么先前的那个task此 时又回到了前台了，当用户按下BACK键时，屏幕不是显示刚刚关闭的那个应用，而是移除回到前台的这个task堆栈栈顶Activity，将下一个 Activity显示出来。<br> 　　刚才描述的情况是Activity和task默认的行为，但是有很多的方法来对几乎所有的方面进行修改，如 Activity和task的联系。task里Activity的行为，是受启动它的Intent对象的flag和在manifest文件中的 Activity的属性集合共同影响的。<br> 　　Flag：<br> 　　FLAG_ACTIVITY_NEW_TASK<br> 　　FLAG_ACTIVITY_CLEAR_TOP<br> 　　FLAG_ACTIVITY_RESET_TASK_IF_NEEDED<br> 　　FLAG_ACTIVITY_SINGLE_TOP<br> 　　属性：<br> 　　taskAffinity<br> 　　launchMode<br> 　　allowTaskReparenting<br> 　　clearTaskOnLaunch<br> 　　alwaysRetainTaskState<br> 　　finishOnTaskLaunch<br> 5、Affinities and new tasks<br> 　　默认的，一个应用里的所有Activity都有联系，所有都是属于一个task的，然而，可以通过下的taskAffinity属 性来为每个Activity单独的设置属性关系，定义在不同应用中的Activity可以共享一种关系(affinity)，或者定义在同一个应用中的 Activity可以分配不同的关系(affinity)。这种关系在两种情况下生效，当启动Activity的 Intent对象包含有FLAG_ACTIVITY_NEW_TASK标志，一个Activity的allowTaskReparenting属性设置为 true。<br> 　　FLAG_ACTIVITY_NEW_TASK<br> 　　一个Activity调用startActivity()启动一个新的 Activity时，新的Activity会压入到相同的task中的，如果传递给startactivity()的Intent对象含有 FLAG_ACTIVITY_NEW_TASK标志，系统就会寻找一个新的task来装这个新的Activity，然而，也不总是这么做，如果已经有一个 task和这个新的的Activity有相同的关系，那么就把这个新的Activity放进这个task里，如果没有，就启动一个新的task。<br> 　　allowTaskReparenting属性<br> 　 　如果一个Activity的allowTaskReparenting属性设置为true，这个Activity就可以从启动时的那个task移动到一 个和他有关系的当前在前台的一个task里，比如，假设现在有一个天气预报的Activity被定义在一个旅行的应用里，他和这个应用里的其他 Activity有相同的关系(默认的关系)，并且他允许reparenting，现在你自己应用有一个Activity启动这个天气预报的 Activity，那么天气预报Activity就会移动到你的Activity所在的task里，当旅行的应用又回到前台时，天气预报Activity 重新回到以前的那个task并显示。(个人观点：如果说没有设置这个属性，或者这个属性设置为false，那么一个应用里的Activity调用另一个应 用里的Activity时，系统是为另一个应用里的Activity创建一个实例，然后放到同一个task里，但是如果设置了 allowTaskReparenting为true，那么另一个应用里的Activity是可以在不同的task间来回移动的，那个task在前台就移 动到那个task里)<br> 6、启动方式<br> 　　下的launchMode属性可以设置四种启动方式：<br> 　　"standard" (the default mode)<br> 　　"singleTop"<br> 　　"singleTask"<br> 　　"singleInstance"<br> 　　这些不同的方式可以从下面的四点来说：<br> 　　(1)对一个Intent作出回应时哪个task应该去持有这个Activity。<br> 　 　对standard和singleTop方式来说，新的Activity和通过startActivity调用他的Activity处在同一个task 中，如果调用时Intent对象里含有FLAG_ACTIVITY_NEW_TASK标志，那么就像前面讲的那样的寻找一个新的task。<br> 　　相反的，singTask和singleInstance方式，总是标志Activity为task的root Activity，他们不会进入到其他的task中。<br> 　　(2)一个Activity是否可以有多个实例。<br> 　　一个standard或者singleTop属性的Activity可以实例化多次，他们可以属于多个不同的task。<br> 　　相反的，singleTask或者singleInstance属性的Activity只能有一个实例(单例)。<br> 　　(3)实例是否能允许在task里有其他的Activity。<br> 　 　一个singleInstance属性的Activity单独的在他自己的task里，并且这个task里只能有他自己一个Activity，如果他启 动了另一个Activity，那个Activity会根据启动模式来启动并装进一个不同的task里。其他的方面，singleInstance和 singleTask一样的。<br> 　　其他三个方式允许有多个Activity在一个task里，一个singleTask属性的Activity总是一个task里的root Activity，但是他可以启动另外的Activity并且将这个新的Activity装进同一个task里，standard和singleTop属性的Activity可以出现在task的任何地方。<br> 　　(4)一个类(Activity)的对象是否可以被启动来处理一个新的Intent。<br> 　 　对默认的standard方式，会实例化一个对象来处理每一个新的Intent，每个实例处理一个新的Intent，对singleTop方式，如果一 个已经存在的实例是在task的栈顶，那么就重用这个实例来处理这个新的Intent，如果这个实例不在栈顶，那就不复用他，而是重新创建一个实例来处理 这个新的Intent并且将这个实例压入堆栈。<br> 　　例如现在有一个task堆栈ABCD，A是root Activity，D是栈顶Activity，现在有一个启动D的Intent来了，如果D是默认的standard方法，那么就会创建一个新的实例来处 理这个Intent，所以这个堆栈就变为ABCDD，然而如果D是singleTop方式，这个已经存在的栈顶的D就会来处理这个Intent，所以堆栈 还是ABCD。D此时调用onNewIntent()，此时D可以调用getIntent()来获得最初的Intent，或者调用setIntent() 来更新这个Intent。<br> 　　如果现在有一个Intent来启动B，不管B是standard还是singleTop(因为现在B不在栈顶)，都会创建一个新的实例，所以堆栈变为ABCDB<br> 　 　在一个task里，对singleTask和singleInstance属性的Activity只能有一个实例。所以这仅有的一个会来处理所以的 Intent，一个singleInstance属性Activity总在栈顶(因为task里就只有他一个Activity)，所以他会处理所以的 Intent，但是一个singleTask属性的Activity必须是task的root Activity(也就是必须在栈底)，不能确定他的上面是否还有其他的Activity，如果没有，就可以处理，如果还有其他的Activity，那么 如果现在有一个Intent来启动这个singleTask属性的Activity，这个Intent将会被丢掉(即使是这个Intent被丢掉，他的到 来还是会导致这个task回到前台)。<br> 　　当创建一个类(Activity)的实例来处理一个新的Intent时，用户可以按下BACK键回到上 一个Activity，但是如果是用已经存在的栈顶的Activity来处理Intent的话，按下BACK键是不能回到以前的状态的(没处理这个 Intent之前)。<br> 　7、清理堆栈<br> 　　当用户离开一个task一段时间后，系统就会清理掉task里出了rootActivity以外的Activity，如果用户又回来了，显示的是rootActivity，就像是用户离开又回来，是放弃以前的东西，开始新的东西。<br> 　　上面说的是默认的情况，有一些Activity的属性可以用来控制和修改这些行为。<br> 　　alwaysRetainTaskState<br> 　　如果一个task里的root Activity的alwaysRetainTaskState属性设置为true，那么前面描述的默认情况就不会出现了，task即使过了一段时间也会一直保留所有的Activity。<br> 　　clearTaskOnLaunch<br> 　　如果一个task里的root Activity的clearTaskOnLaunch属性设置为true，和alwaysRetainTaskState相反，即使是一瞬间的离开，系统马上就会清理掉task里出rootActivity以外的所有Activity。<br> 　　finishOnTaskLaunch<br> 　　这个属性和clearTaskOnLaunch一样，但是他是对一个Activity起作用，不是整个task，他能引起所有的Activity离开，包括root Activity，当这个属性设置为true，只是当用户使用这个应用时Activity才在task里，一旦用户离开后重新回来，显示的不是当前的界面。<br> 　 　还有其他的方法来从task里强制移动Activity，如果一个Intent对象里包含FLAG_ACTIVITY_CLEAR_TOP标志，并且目 标task里已经一个在自己task里可以处理Intent的Activity(就是处理这个Intent无需实例化另外一个Activity)，那么在 这个Activity之上的所有Activity将被清除，能处理这个Intent的Activity就移到栈顶来处理这个Intent，例如ABCD堆 栈，含有FLAG_ACTIVITY_CLEAR_TOP标志的Intent来启动B，那么清除CD，B到达栈顶来响应Intent，此时是AB，如果B 设置了standard属性，那么还是清楚CD，然后再创建一个实例来响应Intent，此时是ABB，因为standard属性的Activity总是 创建一个新的实例来响应新的Intent。<br> 8、进程和线程(Processes and Threads)<br> 　　当一个应用的第一个组件需要运行时，android系统就为这个组件启动一个只有一个线程的Linux进程，默认的，应用的所有组件都运行这个进程中的这个线程中。<br> 　　但是，你可以安排组件运行在其他的进程中，并且为你的任意的进程增加若干线程。<br> 　　1、 进程<br> 　　组件运行的进程是在manifest文件里控制的，四大组件都一个process属性可以指定进程来运行，这些属性可以被设置为了每个组件都可以运行在他自己的进程中，或者几个组件共享一个进程，或者不共享，如果两个应用共享一个Linux user ID并且有相同的权限，那么就可以使这两个应用中的组件运行在相同的进程中，也有process属性，用来指定对所有组件的属性。<br> 　　所有的组件 都在指定的进程中的主线程中实例化，系统调用这些组件就是从主线程里发出的，其他的线程将不会对每个组件再实例化，所有作为调用的回应的这些方法，比如说 View.onKeyDown()还是组件的生命周期函数等等都是运行在这个主线程中的，这就意味着当系统调用这个组件时，这个组件不能长时间的阻塞线程 (比如说网络操作，循环计算)，因为这样会阻塞这个进程中的其他组件，你可以将很耗时的任务分到其他的线程中。<br> 　　当内存不足或者有其他更紧急的进程要求时，Android系统可能关闭一个进程，运行在这个进程中的应用组件因此被销毁，当用户又重新回来时，进程才被重新启动。<br> 　　至于究竟要停止哪个进程，android系统是通过衡量哪个进程对用户来说更重要来实现的<br> 　　2、 线程<br> 　　你可以限制你的应用运行在一个进程中，但是有的时候你需要新开一个线程在后台运行，用户界面需要随时对用户的要求做出反应，所以一些很耗时的工作应该重新启动一个线程来做，以免阻塞主进程。<br> 　　Android系统提供了一系列方便的类来管理线程(Looper，Handler，HandlerThread)<br> 　　3、 远程调用(Remote procedure calls)<br> 　　Android系统有一个轻量级的远程调用机制(RPC)-----一个方法在本地调用，但是在远程执行(在另外一个进程里)， 返回给调用端的所有结果都必须的系统能理解的，将数据从本地进程和地址空间传递到远程的进程和地址空间，并在远端重新装配，返回值的时候传输方向相 反，android系统会去做这些传输的工作，让你能够集中精力来定义你的RPC<br> 　　一个RPC接口只能包含方法，默认的，即使是没有值返回，所有的方法都是同步执行的，就是说本地方法一直会阻塞直到远端的方法执行完毕)。<br> 　　简单的说，这个远程调用的机制是这样工作的：<br> 　　首先你需要用IDL(interface definition language)声明你的RPC接口，然后android系统会使用aidl工具来形成一个java接口，并且这个java接口是本地进程和远端进程都可以获得的，这个java接口包含了两个内部类，请看下图：<br> 　　<br> 　 　这两个内部类有管理远程调用(你用IDL声明的接口)的所以代码,两个内部类都实现IBinder接口,一个是在本地(内部)使用,这个你可以不用自己 写代码，另外一个叫做Stub，继承自Binder类的，包含所有完成进程间通信(IPC)的代码，他包含你在RPC接口中声明的所有方法，你应该继续继 承Stub类来实现这些方法。<br> 　　一般的，远端进程应该由一个service来管理(因为一个service能通知系统关于这个进程和他连接到的其他进程)。<br> 9、进程的生命周期(Processes and lifecycles)<br> 　　Android系统总是尽最大的努力来维持一个应用的进程，但系统的内存不足时就可能需要关闭一些旧的进程了，但是决定关闭哪个进程呢，android系统把所以的进程放进一个重要性树里，最低重要性的进程将会被停止，系统有5种重要性等级，重要性从高到低如下：<br> 　　(1)、前台进程。一个前台进程是当前执行用户请求的进程，如果有如下的一种情形的那么他就是前台进程：<br> 　　a、这个进程里运行着一个正在和用户交互的Activity(这个Activity的onResume()方法被调用)。<br> 　　b、这个进程里有绑定到当前正在和用户交互的Activity的一个service<br> 　　c、这个进程里有一个service对象，这个service对象执行了至少一个他生命周期的函数(onCreate(), onStart(), or onDestroy()).<br> 　　d、这个进程里有一个执行了onReceive()方法的broadcastreceiver对象<br> 　　只有一定数量的前台进程在任何时间都存在，他们只有在最后的时刻被停止---系统的内存太少了而不能运行这些仅有的前台进程了)，一般的，在那个时刻，手机会重新设置内存页的状态，所以停止一些前台的进程是为了保持对用户操作的快速响应。<br> 　　(2)可见进程。一个可见进程一个没有任何前台显示的组件，但是仍然可以影响到用户当前屏幕所看见的东西，如果有如下的一种情形那么他就是可见进程。<br> 　 　a、 这个进程里一个Activity，但是这个Activity当前不是在前台显示，但是仍然对用户是可见的(这个Activity的onPause()方法 被调用)，比如说一个Activity调用一个dialog，那么这个dialog是当前显示的组件，这个Activity不是在前台显示，但是对用户是 可见的。<br> 　　b、 这个进程里有一个绑定到一个可见Activity(如上所述的Activity)的service<br> 　　一个可见进程是极端重要的，只有在为了显示所有前台进程时，即显示前台进程都不够时，才会停止可见进程。<br> 　 　(3)、服务进程。一个服务进程是一个通过startService()启动的但是没有在前两个分类中的进程，虽然服务进程不是用户直接能看见的，但是 他也总是做一些用户很关心的事(如在后台播放mp3，从网络上下载东西)，所以系统会一直保持服务进程运行，除非内存不足以运行服务进程，前台进程，可见 进程。<br> 　　(4)后台进程。一个后台进程是运行一个当前对用户是不可见的Activity(这个Activity的onStop()被调用)，这 些进程对用户体验没有什么直接的影响，当内存不足以运行前台进程，可见进程，服务进程时，可以随时停止后台进程，通常有很多的后台进程在运行，系统会把这 些后台进程放进一个LRU中(最近使用队列)，最近使用的就最后停止。<br> 　　(5)空进程。一个空进程就是进程里没有任何活动的应用组件，维持这种进程的唯一原因就是作为一种缓存，当一个组件需要启动时加快启动的速度，系统为了平衡进程缓存和核心缓存会停止这些空的进程。<br> 　　Android系统会取一个进程里的所以组件的最高重要性来安排进程的重要性，比如说，一个进程里有一个service和一个可见的Activity，那么这个进程会被安排成一个可见进程，而不是服务进程。<br> 　　另外，一个进程的重要性有可能会因为其他进程的依赖而升高，一个进程不能比他所服务的进程的重要性低，比如有进程A里的service绑定到了进程B的组件上，那么进程A的重要性至少和进程B的一样，或者更高。<br> 　 　因为一个服务进程的重要性比运行一个后台Activity的进程高，所以，当一个Activity做一些长时间运行的任务时，最好启动一个 service来做，而不是放到一个线程里去做，特别是这个任务的时间可能比Activity运行的时间还长的时候，比如在后台播放音乐，或者上传一张图 片到网上，使用一个service保证了这个任务至少是服务进程的重要性，broadcast receiver也是一样，长时间运行的任务也最好是放到一个service里，而不是放到一个线程里。</p> 
  </div> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35f882a83c9fa8fede3756044865465d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS6.5安装与配置Mysql数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/184507d472d2fea4116e63cfc5228e05/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android使用Aidl实现跨进程通信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>