<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JPA H2 redis 学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JPA H2 redis 学习笔记" />
<meta property="og:description" content="SpringBoot整合H2时：SpringBoot可以自动的配置内嵌的H2、HSQL、Derby数据库。你不需要提供任何链接URLs，只需要简单的提供一个你需要使用的内嵌数据库的依赖即可。
需要注意在不同情况下设置scope，这样就可以使用h2了，不需要做任何配置，这样就可以像使用mysql一样使用了，h2数据库是随着应用的启动而开始运行。
&lt;dependency&gt;
&lt;groupId&gt;com.h2database&lt;/groupId&gt;
&lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
#h2
spring.h2.console.enabled=true //开启web console功能 http://localhost:8080/h2-console/
spring.datasource.platform=h2 //数据库平台是H2，可选
spring.h2.console.path=/h2 //设置访问路径 localhost:port/h2
#datasource
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.url=jdbc:h2:./data/db 是相对路径
spring.datasource.password=
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect 使用的语言
spring.datasource.schema=classpath:db/schema.sql，进行该配置后，每次启动程序，程序都会运行resources/db/schema.sql文件，对数据库的结构进行操作。//创建数据库表
spring.datasource.data=classpath:db/data.sql,进行该配置后，每次启动程序，程序都会运行resources/db/data.sql文件，对数据库的数据操作//向数据库插入数据
上面的是数据库执行的脚本文件，脚本文件要么不存在，如果存在就不能为空，否则会报错。
#spring.jpa.hibernate.ddl-auto=update这个配置不能设置，否则使用H2数据库必定报错。
spring.jpa.show-sql = true
spring.datasource.url=jdbc:h2:mem:test内存模式
#Windows当前用户路径
#spring.datasource.url = jdbc:h2:file:~/.h2/dbc2m;AUTO_SERVER=TRUE
#可执行程序的当前路径
spring.datasource.url = jdbc:h2:file:./dbh2/dbc2m;AUTO_SERVER=TRUE
#指定的静态配置路径
#spring.datasource.url = jdbc:h2:file:D:/db/.h2/dbc2m;AUTO_SERVER=TRUE
尤其是设置主键的增长方式时，值得注意，最好不用设置主键的增长方式为有程序决定。
JPA
对象与表的关系映射
hibernate实现
hibernate的配置文件
&lt;persistence xmlns=&#34;http://java.sun.com/xml/ns/persistence&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&#34;
version=&#34;2.0&#34;&gt;
&lt;!--配置持久化单元（可以配置多个，名称不能重复）
name:用于指定持久化单元的名称
transcation-type:指定事务的类型。
JTA:Java Transcation API
RESOURCE_LOCAL:指的是本地代码事务
--&gt;
&lt;persistence-unit name=&#34;myPersistenceUnit&#34; transaction-type=&#34;RESOURCE_LOCAL&#34;&gt;
&lt;!--JPA规范提供商，可以不写--&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e8b88565fb09a1699b2d32129207581c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-23T12:37:33+08:00" />
<meta property="article:modified_time" content="2020-02-23T12:37:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JPA H2 redis 学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>SpringBoot整合H2时：SpringBoot可以自动的配置内嵌的H2、HSQL、Derby数据库。你不需要提供任何链接URLs，只需要简单的提供一个你需要使用的内嵌数据库的依赖即可。<br> 需要注意在不同情况下设置scope，这样就可以使用h2了，不需要做任何配置，这样就可以像使用mysql一样使用了，h2数据库是随着应用的启动而开始运行。<br>  &lt;dependency&gt;<br>             &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br>             &lt;artifactId&gt;h2&lt;/artifactId&gt;<br>             &lt;scope&gt;runtime&lt;/scope&gt;<br>  &lt;/dependency&gt;</p> 
<p> #h2<br> spring.h2.console.enabled=true  //开启web console功能  http://localhost:8080/h2-console/</p> 
<p>spring.datasource.platform=h2  //数据库平台是H2，可选<br> spring.h2.console.path=/h2   //设置访问路径 localhost:port/h2</p> 
<p>#datasource<br> spring.datasource.driverClassName=org.h2.Driver<br> spring.datasource.url=jdbc:h2:./data/db        是相对路径<br> spring.datasource.password=<br> spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect  使用的语言</p> 
<p>spring.datasource.schema=classpath:db/schema.sql，进行该配置后，每次启动程序，程序都会运行resources/db/schema.sql文件，对数据库的结构进行操作。//创建数据库表<br> spring.datasource.data=classpath:db/data.sql,进行该配置后，每次启动程序，程序都会运行resources/db/data.sql文件，对数据库的数据操作//向数据库插入数据<br> 上面的是数据库执行的脚本文件，脚本文件要么不存在，如果存在就不能为空，否则会报错。</p> 
<p>#spring.jpa.hibernate.ddl-auto=update这个配置不能设置，否则使用H2数据库必定报错。</p> 
<p><br> spring.jpa.show-sql = true</p> 
<p>spring.datasource.url=jdbc:h2:mem:test内存模式</p> 
<p>#Windows当前用户路径<br> #spring.datasource.url = jdbc:h2:file:~/.h2/dbc2m;AUTO_SERVER=TRUE<br> #可执行程序的当前路径<br> spring.datasource.url = jdbc:h2:file:./dbh2/dbc2m;AUTO_SERVER=TRUE<br> #指定的静态配置路径<br> #spring.datasource.url = jdbc:h2:file:D:/db/.h2/dbc2m;AUTO_SERVER=TRUE</p> 
<p><br> 尤其是设置主键的增长方式时，值得注意，最好不用设置主键的增长方式为有程序决定。</p> 
<p>JPA</p> 
<p>对象与表的关系映射</p> 
<p>hibernate实现</p> 
<p>hibernate的配置文件</p> 
<p>&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br>              xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"<br>              version="2.0"&gt;<br>     &lt;!--配置持久化单元（可以配置多个，名称不能重复）<br>         name:用于指定持久化单元的名称<br>         transcation-type:指定事务的类型。<br>                       JTA:Java Transcation API<br>                       RESOURCE_LOCAL:指的是本地代码事务<br>     --&gt;</p> 
<p>    &lt;persistence-unit name="myPersistenceUnit" transaction-type="RESOURCE_LOCAL"&gt;<br>         &lt;!--JPA规范提供商，可以不写--&gt;<br>         &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;<br>         &lt;!--指定Jpa注解的实体类型位置，可以不写--&gt;<br>         &lt;class&gt;com.demo.domain.Customer&lt;/class&gt;<br>         &lt;!--连接相关的一些配置，都是用hibernate的。--&gt;<br>         &lt;properties&gt;<br>             &lt;!--第一部分，连接数据库信息--&gt;<br>             &lt;property name="hibernate.connection.driver_class" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt;<br>             &lt;property name="hibernate.connection.url" value="jdbc:mysql://127.0.0.1:3306/jpademodb?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai"&gt;&lt;/property&gt;<br>             &lt;property name="hibernate.connection.username" value="root"&gt;&lt;/property&gt;<br>             &lt;property name="hibernate.connection.password" value="123456"&gt;&lt;/property&gt;<br>             &lt;!--说明:数据库的方言，用于存放不同数据库之间的SQL语句差异。--&gt;<br>             &lt;property name="hibernate.dialect" value="org.hibernate.dialect.MySQL57Dialect"&gt;&lt;/property&gt;</p> 
<p>            &lt;!--第二部分，hibernate的可选配置--&gt;<br>             &lt;!--是否显示hiberante的生成的SQL语句--&gt;<br>             &lt;property name="hibernate.show_sql" value="true"&gt;&lt;/property&gt;<br>             &lt;!--是否使用格式化输出SQL语句到控制台--&gt;<br>             &lt;property name="hibernate.format_sql" value="false"&gt;&lt;/property&gt;<br>             &lt;!--采用何种方式生成DDL语句，update表示检测实体类的映射配置与数据库表结构是否一致，不一致，则更新数据库。--&gt;<br>             hibernate.hbm2ddl.auto 何种方式创造表  updata create none<br>             create如果有表，删除表再更新 <br>             &lt;property name="hibernate.hbm2ddl.auto" value="update"&gt;&lt;/property&gt;<br>             &lt;!--连接池的配置，这里使用的是c3p0连接池，常用的还有阿里的--&gt;<br>             &lt;property name="hibernate.connection.provider_class" value="org.hibernate.c3p0.internal.C3P0ConnectionProvider"&gt;&lt;/property&gt;<br>         &lt;/properties&gt;<br>     &lt;/persistence-unit&gt;<br> &lt;/persistence&gt;</p> 
<p>重点属性<br> hibernate.hbm2ddl.auto DDL语句的生成方式，值有create , update , none 。  create每次表的结构和数据发生变化，删除原表，建立新表。 update在原有表的基础上增加数据或者修改表的结构。</p> 
<p>实体类与表关系的映射</p> 
<p>实体类<br>        @Entity表明该类为实体类 @Table(name="table_name")实体类对应数据库中表的名字</p> 
<p>实体类属性<br>       实体属性，主键属性  @Id 表明该属性是主键   @GeneratedValue(strategy=)增长方式 声明主键的增长方式的一种方法<br>       @GeneratedValue(generator = "uuid2") @GenericGenerator(name = "uuid2", strategy = "org.hibernate.id.UUIDGenerator")声明主键的增长方式的第二种方法<br>       <br>       @Column(name = "id",length = 36) 每个属性都必须要的注释，声明该属性与数据库表中与之对应的字段</p> 
<p>主键生成策略<br>           GenerationType.IDENTITY: 自增 如 mysql数据库<br>      *          底层数据库必须支持自动增长（底层数据库支持的自动增长方式，对id自增）<br>      *      GenerationType.GenerationType.SEQUENCE: 序列 如 oracle数据库<br>      *          底层数据库必须支持序列<br>      *      GenerationType.GenerationType.TABLE: jpa提供的一种机制,通过一张数据库表的形式帮助我们完成主键自增<br>      *      GenerationType.GenerationType.AUTO: 由程序自动的帮助我们选择主键生成策略</p> 
<p><br> hibernate操作的具体流程</p> 
<p>1 创建实体类管理器工厂，加载配置文件<br> 2 实体类管理器工厂，创建实体类管理器<br> 3 实体类管理器获取事务对象，开启事务<br> 4 实体类管理器，进行对数据的具体操作<br> 5 提交事务，或者回滚事务<br> 6 释放资源</p> 
<p>具体代码</p> 
<p>1   EntityManagerFactory entryManagerFactory = Persistence.createEntityManagerFactory("testdb-persistence-unit");</p> 
<p>2    EntityManager manager = entryManagerFactory.createEntityManager();</p> 
<p>3     Transaction  tx=manager.getTransaction()</p> 
<p>        tx.begin()</p> 
<p>4       CRUD   manager.persist()  manager.find()</p> 
<p>5        tx.commit()<br>          tx.close()<br> 6</p> 
<p><br> EntityManager实体类管理器的方法</p> 
<p>1，entityManager.persist(Object entity);　　新增数据；<br>    如果entity的主键不为空，而数据库没有该主键，会抛出异常；<br>    如果entity的主键不为空，而数据库有该主键，且entity的其他字段与数据库不同，persist后不会更新数据库；</p> 
<p> 2、entityManager.find(Class&lt;T&gt; entityClass, Object primaryKey);　　根据主键查找数据； <br>    如果主键格式不正确，会抛出illegalArgumentException异常;<br>    如果主键在数据库未找到数据返回null；</p> 
<p> 3、entityManager.remove(Object entity);　　删除数据；<br>    只能将Managed状态的Entity实例删除，由此Entity实例状态变为Removed；</p> 
<p> 4、entityManager.merge(T entity);　　 将Detached状态的Entity实例转至Managed状态； 更新</p> 
<p> 5、entityManager.clear();  将所有的Entity实例状态转至Detached状态；</p> 
<p> 6、entityManager.flush();   将所有Managed状态的Entity实例同步到数据库；</p> 
<p> 7、entityManager.refresh(Object entity); 加载Entity实例后，数据库该条数据被修改，refresh该实例，能得到数据库最新的修改，覆盖原来的Entity实例；</p> 
<p> find   reflush 方法作用类型，前者主动加载，后者懒加载，只有实体类用到才会立即加载。</p> 
<p><br>  hibernate自身存在缓存，即一级缓存<br>  它对对象的操作会存储在自身的会话缓存中</p> 
<p> 对象的三种状态<br> Managed：持久化受管对象，有id值，已经和Persistence Context建立了关联的对象。</p> 
<p>Datached：游离态离线对象，有id值，但没有和Persistence Context建立关联的对象。</p> 
<p>Removed：删除的对象，有id值，尚且和Persistence Context有关联，但是已经准备好从数据库中删除</p> 
<p>状态名 作为java对象存在 在实体管理器中存在 在数据库存在</p> 
<p>New yes no no</p> 
<p>Managed yes yes yes</p> 
<p>Detached no no no</p> 
<p>Removed yes yes no</p> 
<p><br> JPQL语句<br> 面向对象的SQL语句，语法上与SQL相似，有位置参数和命名参数，位置参数用 ?1 ?2 表示，命名参数 :param1 :param2</p> 
<p>entityManager实体类管理器执行JPQL语句</p> 
<p>方法有<br> Query createNamedQuery(String name):创建查询的名称来创建一个命名查询，使用sql和jpql都可以<br> Query createNativeQuery（String SQLString）根据的原生的sql语句查询<br> Query createQuery（String jpqlString）根据指定的JPQL语句创建一个查询</p> 
<p>它们都返回一个Query对象，这是因为要给参数赋值，Query的方法</p> 
<p>Query setParmeter（String name， Object value）</p> 
<p><br> Query对象方法的执行方法</p> 
<p>List getResultList()执行JPQL的select语句，并且返回的是list集合</p> 
<p>Object getSingleResult（）执行返回的那个结果的select语句</p> 
<p>int executeupdate（）表示执行批量的删除和更新</p> 
<p>Query setFirstResult（int startPosition）设置查询结果从第几条记录开始  这个方法和最好一个可以用来设置 分页查询的开始页码和页面数</p> 
<p>Query setMaxResults(int maxResult)表示设置查询最多返回几条语句</p> 
<p><br> 例子</p> 
<p>Query query =em.createQuery("select u from User u where u.userid =:param ");<br> //设置参数<br> query.setParameter("param",25);</p> 
<p>Query query = em.createQuery("select u from User u where  u.userid=?1")<br> query.setParameter(1,25);</p> 
<p><br> //命名参数查询时使用，参数类型为java.util.Date<br> Query setParameter(String name,java.util.Date value,TemporalType temporalType);<br> //命名参数查询时使用，参数类型java.util.Calendar<br> Query setParameter(String name,Calendar value,TemporalType temporalType);</p> 
<p>还有位置参数的重载，除第一个参数的类型不同外，别无二致。</p> 
<p>Spring data jpa</p> 
<p>它的底层是hibernate实现，经过在一层的封装实现JPA思想。</p> 
<p><br> 相比hibernate它更加地简单，更加高效</p> 
<p>引入相关的依赖</p> 
<p>springboot</p> 
<p>#dataSourse<br> spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver<br> spring.datasource.url=jdbc:mysql://localhost:3306/library?charset=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8<br> spring.datasource.username=root<br> spring.datasource.password=root</p> 
<p>#jpa<br> spring.jpa.show-sql=true<br> spring,jpa.hibernate.ddl_auto=  update create validate</p> 
<p>spring.jpa.hibernate.naming.strategy=  命名策略，默认即可<br> 　　1)、org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy   遇到大写字母 加”_”的命名。</p> 
<p>　　2)、org.hibernate.cfg.ImprovedNamingStrategy   无修改命名 。</p> 
<p>spring.jpa.properties.hibernate.dialect </p> 
<p><br> 如果是spring sprin mvc<br>  //数据库配置<br> &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;<br>     &lt;/bean&gt;<br>     <br>     &lt;!-- Spring整合hibernate JPA 配置EntityManagerFactory --&gt;<br>     &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;<br>         &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;<br>         &lt;property name="jpaVendorAdapter"&gt;<br>             &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;<br>                 &lt;!-- hibernate相关的属性的注入    --&gt;<br>                 &lt;!-- 配置数据库类型     --&gt;<br>                 &lt;property name="database" value="MYSQL"&gt;&lt;/property&gt;<br>                 &lt;!-- 正向工程 自动创建表   --&gt;<br>                 &lt;property name="generateDdl" value="true"&gt;&lt;/property&gt;<br>                 &lt;!-- 显示执行的SQL --&gt;<br>                 &lt;property name="showSql" value="true"&gt;&lt;/property&gt;<br>             &lt;/bean&gt;<br>         &lt;/property&gt;<br>         &lt;!-- 扫描实体的包 --&gt;<br>         &lt;property name="packagesToScan"&gt;<br>             &lt;list&gt;<br>                 &lt;value&gt;com.bjsxt.pojo&lt;/value&gt;<br>             &lt;/list&gt;<br>         &lt;/property&gt;<br>     &lt;/bean&gt;<br>     <br>     &lt;!-- 配置Hibernate的事务管理器 --&gt;<br>     &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;<br>         &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;<br>     &lt;/bean&gt;<br>     <br>     &lt;!-- 配置开启注解事务处理 --&gt;<br>     &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;<br>     <br>     &lt;!-- 配置springIOC的注解扫描 --&gt;<br>     &lt;context:component-scan base-package="com.bjsxt"/&gt;<br>     <br>     &lt;!-- Spring Data JPA 的配置     --&gt;<br>     &lt;!-- base-package:扫描dao接口所在的包     --&gt;<br>     &lt;jpa:repositories base-package="com.bjsxt.dao"&gt;&lt;/jpa:repositories&gt;</p> 
<p>&lt;/beans&gt;</p> 
<p><br> springboot如果想用声明式事务，要开启@EnableTransactionManagement()</p> 
<p>实体类的注解和hibernate关系实体类的注解别无二至。</p> 
<p>操作实体类，只要继承两个接口，并给与泛型，救能直接使用它们的方法。</p> 
<p>JpaRepository   封装了基本的CRUD<br> JpaSpecificationExcutor  复杂的操作</p> 
<p>例如<br> @Repository<br> public interface myjunit implements JpaRepository&lt;class,ID&gt;,JpaSpecificationExcutor&lt;class&gt;{<!-- --></p> 
<p>JPQL查询<br> @Query("SELECT p FROM Person p WHERE name LIKE %?1%")<br> Person findByName(String name);</p> 
<p>Person findByName(String name);命名查询，根据name查询<br>     <br> }</p> 
<p>JpaRepository&lt;class,ID&gt; class ID 实体类 实体类的主键类型<br> JpaSpecificationExcutor&lt;class&gt;</p> 
<p><br> JpaRepository 接口的方法<br> findAll<br> count, delete, deleteAll, deleteAll, deleteById, existsById, findById, save<br> count, exists, findAll, findOne</p> 
<p>save 有id更新 无id保存</p> 
<p>JpaSpecificationExcutor 接口<br> count(Specification&lt;T&gt; spec)<br> Returns the number of instances that the given Specification will return.</p> 
<p>List&lt;T&gt; findAll(Specification&lt;T&gt; spec) 列表查询<br> Returns all entities matching the given Specification.</p> 
<p>Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable) 分页查询<br> Returns a Page of entities matching the given Specification.</p> 
<p>List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort) 排序查询<br> Returns all entities matching the given Specification and Sort.</p> 
<p>Optional&lt;T&gt; findOne(Specification&lt;T&gt; spec) </p> 
<p><br> 此外spring data jpa还支持JPQL查询</p> 
<p>@Query</p> 
<p>在继承了两个接口里，实现抽象方法，用@Query(value="")</p> 
<p>@Query("SELECT p FROM Person p WHERE name LIKE %?1%")<br> Person findByName(String name);</p> 
<p>@Query("SELECT p FROM Person p WHERE name LIKE %:name%")<br> Person findByName(@Param("name") String name);</p> 
<p>@Modifying<br> @Query("UPDATE Person p SET p.name = :name WHERE p.id = :id")<br> void updatePersonName(@Param("id") Integer id, @Param("name") String name);</p> 
<p>@Modifying注解来标识该方法执行的是更新或者删除操作</p> 
<p><br> 命名查询是 JPA 提供的一种将查询语句从方法体中独立出来，以供多个方法共用的功能。它根据特定的规则，让用户只写抽象方法，而不用去写JPQL语句，就能进行查询。</p> 
<p>原理：<br> Person findByName(@Param("name") String name);</p> 
<p>实体类定义JPQL SQL<br> @NamedQuery(name = "Person.findByName", query = "SELECT p FROM Person p WHERE p.name LIKE :name")<br> public class Person {<!-- --><br> }</p> 
<p><br> 命名查询例子<br> public Customer findByCustName(String custName); 根据CustName进行查询</p> 
<p>public List&lt;Customer&gt; findByCustNameLike(String custName);根据CustName进行模糊查询</p> 
<p>public Customer findByCustNameLikeAndCustIndustry(String custName,String custIndustry);多条件的模糊查询和精准查询</p> 
<p>findBy --&gt; from xxx(实体类)，属性名称 --&gt; where custName =<br> 是对jpql查询更深一层的封装<br> findBy查询，根据后面的属性查询</p> 
<p><br> 多表关系</p> 
<p>一对一 </p> 
<p>一对多<br>   一的一方 主表<br>   多的一点 从表<br>   外键 主表有一外键，为从表的主键</p> 
<p><br> 多对多<br>   <br>   中间表，多个外键，分别指向多表的主键</p> 
<p><br> 实体类的关系<br> 继承 包含</p> 
<p>包含关系描述表关系</p> 
<p>一对多<br> 集合set<br> @OneToMany(targetEntity=)<br> @JoinColumn(name=  referencedColumn=)外键</p> 
<p>多对一<br> @ManyToOne<br> @JoinColumn</p> 
<p>一对多 和 多对一 要合起来配置。</p> 
<p>多对多配置<br> @ManyToMany()<br> @JoinTable()中间表</p> 
<p>级联操作<br> cascade属性，要在@OneToMany等注解上。</p> 
<p>springboot redis整合</p> 
<p>&lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br> &lt;/dependency&gt;</p> 
<p>在和Redis整合中，相关的实体类需要序列化，才能存储在redis中，所以实体类继承序列化接口</p> 
<p>spring.redis.host=127.0.0.1<br> #Redis服务器连接端口<br> spring.redis.port=6379<br> #Redis服务器连接密码（默认为空）<br> spring.redis.password=<br> #连接池最大连接数（使用负值表示没有限制）<br> spring.redis.pool.max-active=8<br> #连接池最大阻塞等待时间（使用负值表示没有限制）<br> spring.redis.pool.max-wait=-1<br> #连接池中的最大空闲连接<br> spring.redis.pool.max-idle=8<br> #连接池中的最小空闲连接<br> spring.redis.pool.min-idle=0<br> #连接超时时间（毫秒）<br> spring.redis.timeout=30000</p> 
<p><br> redisTemplate模板，springboot对redis操作的模板，有两个泛型<br> &lt;String,String&gt;redisTemplate<br> &lt;Object,Object&gt;redisTemplate ，常用。</p> 
<p>使用<br> redisTemplate.opsForValue().set("key")   opsForValue字符类型 opsForSet集合类型 opsForList()列表类型 opsForHash()哈希类型 opsForZSet</p> 
<p>template.setValueSerializer()  设置key的序列化方式，通常设置键的序列化方式为字符串，易于观察。</p> 
<p>相关的类<br> JedisConnectionFactory<br> RedisCacheManager</p> 
<p>springboot redis集群配置<br> spring.redis.sentinel.master=mymaster 默认<br> spring.redis.sentinel.nodes=ip:port,ip:port<br> spring.redis.password=</p> 
<p>第二种方式配置集群<br> spring:<br>   redis:<br>     cluster:<br>       nodes[0]: 127.0.0.1:6379<br>       nodes[1]: 127.0.0.1:6381</p> 
<p><br> MYSQL redis 数据库整合<br> 常用redis作为缓存，MYSQL作为写数据库<br>  </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47b7a0f96510aa015d1a16ef12e0e81c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Data   什么是Spring Data 理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/87861f008e1e98c0936372bb2c8f7812/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle定时任务(2)-DBMS_SCHEDULER</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>