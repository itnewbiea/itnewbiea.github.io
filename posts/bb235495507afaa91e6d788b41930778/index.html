<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue&#43;element-UI实现跟随滚动条加载表格数据 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue&#43;element-UI实现跟随滚动条加载表格数据" />
<meta property="og:description" content="el-table当数据量大的时候，实现滚动到底部后加载数据，直接上js代码，有其他需求请各自更改
第一步、在data中定义两个数组
data() { return { innerList:[], //新数组，用于存放全部数据 innerData:[], //el-table表格数组 dom:null, } } 第二步、在数据发生改变的方法中先循环存放一部分数据用于页面显示
watch: { data:{ this.innerData=[]; this.innerList=[]; //将接口中获取到的数据全部存放到数组 this.innerList = this.data.records || this.data.data || []; //先循环出100条数据用于显示 for(let i=0;i&lt;this.innerList.length;i&#43;&#43;){ if(i&lt;100){ this.innerData.push(this.innerList[i]); } } } } 第三步、在mounted监听滚动事件
mounted() { // 设置滚动条监听时间加载数据 this.dom = this.$refs.elTable.bodyWrapper; this.dom.addEventListener(&#39;scroll&#39;, () =&gt; { let scrollTop = this.dom.scrollTop; //滚动距离 let scrollHeight = this.dom.scrollHeight; //滚动条的总高度 let clientHeight = this.dom.clientHeight; //可视区的高度 if (scrollTop &#43; clientHeight === scrollHeight) { if (this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bb235495507afaa91e6d788b41930778/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-21T17:01:52+08:00" />
<meta property="article:modified_time" content="2023-07-21T17:01:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue&#43;element-UI实现跟随滚动条加载表格数据</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>el-table当数据量大的时候，实现滚动到底部后加载数据，直接上js代码，有其他需求请各自更改</p> 
<p> 第一步、在data中定义两个数组</p> 
<pre><code class="language-javascript">data() {
   return {
       innerList:[],  //新数组，用于存放全部数据
       innerData:[],  //el-table表格数组
       dom:null,
    }
}</code></pre> 
<p>第二步、在数据发生改变的方法中先循环存放一部分数据用于页面显示</p> 
<pre><code class="language-javascript">watch: {
    data:{
         this.innerData=[];
         this.innerList=[];
         //将接口中获取到的数据全部存放到数组
         this.innerList = this.data.records || this.data.data || [];
         //先循环出100条数据用于显示
         for(let i=0;i&lt;this.innerList.length;i++){
             if(i&lt;100){
               this.innerData.push(this.innerList[i]);
             }
         }
    }
}</code></pre> 
<p>第三步、在mounted监听滚动事件</p> 
<pre><code class="language-javascript">mounted() {
    // 设置滚动条监听时间加载数据
            this.dom = this.$refs.elTable.bodyWrapper;
            this.dom.addEventListener('scroll', () =&gt; {
                let scrollTop = this.dom.scrollTop;   //滚动距离
                let scrollHeight = this.dom.scrollHeight;   //滚动条的总高度
                let clientHeight = this.dom.clientHeight;   //可视区的高度
                    if (scrollTop + clientHeight === scrollHeight) {
                    if (this.innerList.length &lt;= this.innerData.length) return 
                    if (this.innerData.length + 50 &gt; this.innerList.length) {
                        // 如果不够50条就全部渲染上去
                        this.dom.scrollTop = this.dom.scrollTop - 50; 
                        this.innerData=[];
                        this.innerData.push(...this.innerList)
                    } else {
                        this.dom.scrollTop = this.dom.scrollTop - 50;
                        let id = this.innerData.length;
                        //每次渲染50条数据
                        for (let index = id; index &lt; id + 50; index++) {
                            this.innerData.push(this.innerList[index])
                        }
                    }
                }
            })
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ced9a25269a441b8a587285ddbebde1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">a-tree 实现父级节点禁用，通过子级节点勾选状态控制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51f84e43537a1818d1e38a6b204ebd95/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器内存满了解决之路</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>