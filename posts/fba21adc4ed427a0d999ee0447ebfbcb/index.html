<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解高级数据结构之B&#43;树 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解高级数据结构之B&#43;树" />
<meta property="og:description" content="目录
一、B&#43;树的演变历史（从BST树到B&#43;树）
1.BST树---二叉查找树
2.AVL树 --- 平衡二叉树
3.B树 --- 平衡多路查找树
4.B&#43;树
二、B&#43;树应用场景
一、B&#43;树的演变历史（从BST树到B&#43;树） 1.BST树---二叉查找树 性质：
若其左子树非空，则左子树上所有节点的值都小于根节点的值若其右子树非空，则右子树上所有节点的值都大于根节点的值其左右子树都是一棵二叉查找树 左子树&lt;根&lt;右子树，即二叉查找树的中序遍历是一个递增序列。
如下图就是一个二叉查找树：
二叉查找树的查询时间复杂度比链表快，链表的查询时间复杂度是O(n)，二叉排序树平均是O(logn)。二叉查找树越平衡，越能模拟二分法，所以与二分的思想相似，二叉查找树查询的时间复杂度O(logn)。
缺点：
如果插入的结点的值的顺序，是越来越小或者越来越大的，那么BST就会退化为一条链表，那么其查询的时间复杂度就会降为O(n)。如下图所示：
2.AVL树 --- 平衡二叉树 为了解决BST树的缺点，AVL树应运而生。
性质：
每棵子树中的左子树和右子树的深度差（平衡因子）的绝对值不能超过1二叉树中每棵子树都要求是平衡二叉树 也就是说，平衡二叉树的前提是它是一棵二叉查找树
平衡二叉树的查找、插入、删除操作在平均和最坏的情况下都是O(logn)，这得益于它时刻维护着二叉树的平衡。
平衡因子： 每个结点都有其各自的平衡因子，表示的就是该节点左子树深度减去右子树深度的值称为该结点的平衡因子BF，那么平衡二叉树上的所有节点的平衡因子只能是-1，0，1。只要一棵树中存在平衡因子不是这几个值，则这棵树就是不平衡的，就需要对这棵树进行调整。
AVL树的平衡因子的绝对值不会超过1，正因为如此AVL树的形状肯定不会退化成一条链表的，而是“矮胖”型的树。所以能确保AVL的查找、添加、删除的时间复杂度都是O(logn)。
3.B树 --- 平衡多路查找树 B树和AVL树(平衡二叉树) 的差别就是 B树 属于多叉树，又名平衡多路查找树，即一个结点的查找路径不止左、右两个，而是有多个。数据库索引技术里大量使用者B树和B&#43;树的数据结构。一个结点存储多个值(索引)。
B树的阶数：M阶表示 一个B树的结最多有多少个查找路径(即这个结点有多少个子节点)。M=M路，M=2是二叉树，M=3则是三叉树。
一棵M阶B树有以下特点：
每个结点的值(索引) 都是按递增次序排列存放的，并遵循左小右大原则。 根结点的子节点个数为 [2，M]。
除根结点以外的非叶子结点 的子节点个数为[ Math.ceil(M/2)，M]，其中Math.ceil() 为向上取整。每个非叶子结点的值(索引) 个数 = 子节点个数 -1 。最小为 Math.ceil(M/2)-1 最大为 M-1 个。B树的所有叶子结点都位于同一层。 下图就是一个B树：
B树的查找结点过程 ：
在上图中若搜索 key 为 25 节点的 data，首先在根节点进行二分查找（因为 keys 有序，二分最快），判断 key 25 小于 key 50，所以定位到最左侧的节点，此时进行一次磁盘 IO，将该节点从磁盘读入内存，接着继续进行上述过程，直到找到该 key 为止。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fba21adc4ed427a0d999ee0447ebfbcb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T00:02:06+08:00" />
<meta property="article:modified_time" content="2022-07-28T00:02:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解高级数据结构之B&#43;树</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81B%2B%E6%A0%91%E7%9A%84%E6%BC%94%E5%8F%98%E5%8E%86%E5%8F%B2%EF%BC%88%E4%BB%8EBST%E6%A0%91%E5%88%B0B%2B%E6%A0%91%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81B%2B%E6%A0%91%E7%9A%84%E6%BC%94%E5%8F%98%E5%8E%86%E5%8F%B2%EF%BC%88%E4%BB%8EBST%E6%A0%91%E5%88%B0B%2B%E6%A0%91%EF%BC%89" rel="nofollow">一、B+树的演变历史（从BST树到B+树）</a></p> 
<p id="1.BST%E6%A0%91---%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-toc" style="margin-left:40px;"><a href="#1.BST%E6%A0%91---%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" rel="nofollow">1.BST树---二叉查找树</a></p> 
<p id="%C2%A02.AVL%E6%A0%91%20---%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#%C2%A02.AVL%E6%A0%91%20---%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow"> 2.AVL树 --- 平衡二叉树</a></p> 
<p id="%C2%A03.B%E6%A0%91%20---%20%E5%B9%B3%E8%A1%A1%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91-toc" style="margin-left:40px;"><a href="#%C2%A03.B%E6%A0%91%20---%20%E5%B9%B3%E8%A1%A1%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91" rel="nofollow"> 3.B树 --- 平衡多路查找树</a></p> 
<p id="4.B%2B%E6%A0%91-toc" style="margin-left:0px;">          <a href="#4.B%2B%E6%A0%91" rel="nofollow">4.B+树</a></p> 
<p id="%E4%BA%8C%E3%80%81B%2B%E6%A0%91%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81B%2B%E6%A0%91%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">二、B+树应用场景</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81B%2B%E6%A0%91%E7%9A%84%E6%BC%94%E5%8F%98%E5%8E%86%E5%8F%B2%EF%BC%88%E4%BB%8EBST%E6%A0%91%E5%88%B0B%2B%E6%A0%91%EF%BC%89">一、B+树的演变历史（从BST树到B+树）</h2> 
<h3 id="1.BST%E6%A0%91---%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">1.BST树---二叉查找树</h3> 
<p><strong>性质：</strong></p> 
<ul><li>若其左子树非空，则左子树上所有节点的值都小于根节点的值</li><li>若其右子树非空，则右子树上所有节点的值都大于根节点的值</li><li>其左右子树都是一棵二叉查找树</li></ul> 
<p>左子树&lt;根&lt;右子树，即二叉查找树的中序遍历是一个递增序列。</p> 
<p>如下图就是一个二叉查找树：</p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/fc/37/NDEGIfXk_o.png" width="981"></p> 
<p> 二叉查找树的查询时间复杂度比链表快，链表的查询时间复杂度是O(n)，二叉排序树平均是O(logn)。二叉查找树越平衡，越能模拟二分法，所以与二分的思想相似，二叉查找树查询的时间复杂度O(logn)。</p> 
<p><strong>缺点：</strong></p> 
<p>如果插入的结点的值的顺序，是越来越小或者越来越大的，那么BST就会退化为一条<a href="https://so.csdn.net/so/search?q=%E9%93%BE%E8%A1%A8&amp;spm=1001.2101.3001.7020" title="链表">链表</a>，那么其查询的时间复杂度就会降为O(n)。如下图所示：</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/bc/fc/lT4cwfVT_o.png" width="568"></p> 
<h3 id="%C2%A02.AVL%E6%A0%91%20---%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"> 2.AVL树 --- 平衡二叉树</h3> 
<p>为了解决BST树的缺点，AVL树应运而生。</p> 
<p><strong>性质：</strong></p> 
<ul><li>每棵子树中的左子树和右子树的深度差（平衡因子）的绝对值不能超过1</li><li>二叉树中每棵子树都要求是平衡二叉树</li></ul> 
<p><strong>也就是说，平衡二叉树的前提是它是一棵二叉查找树</strong></p> 
<p>平衡二叉树的查找、插入、删除操作在平均和最坏的情况下都是O(logn)，这得益于它时刻维护着二叉树的平衡。</p> 
<p><strong>平衡因子：</strong> 每个结点都有其各自的平衡因子，表示的就是该节点<strong>左子树深度减去右子树深度的值</strong>称为该结点的平衡因子BF，那么平衡二叉树上的所有节点的平衡因子只能是-1，0，1。只要一棵树中存在平衡因子不是这几个值，则这棵树就是不平衡的，就需要对这棵树进行调整。</p> 
<p>AVL树的平衡因子的绝对值不会超过1，正因为如此AVL树的形状肯定不会退化成一条链表的，而是“矮胖”型的树。所以能确保AVL的查找、添加、删除的时间复杂度都是O(logn)。</p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/c0/e6/bRz8KWHQ_o.png" width="649"></p> 
<h3 id="%C2%A03.B%E6%A0%91%20---%20%E5%B9%B3%E8%A1%A1%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"> 3.B树 --- 平衡多路查找树</h3> 
<p>B树和AVL树(平衡二叉树) 的差别就是 B树 属于多叉树，又名平衡多路查找树，即一个结点的查找路径不止左、右两个，而是有多个。数据库索引技术里大量使用者B树和B+树的数据结构。一个结点存储多个值(索引)。</p> 
<p>B树的阶数：M阶表示 一个B树的结最多有多少个查找路径(即这个结点有多少个子节点)。M=M路，M=2是二叉树，M=3则是三叉树。</p> 
<p><strong>一棵M阶B树有以下特点：</strong></p> 
<ul><li>每个结点的值(索引) 都是按递增次序排列存放的，并遵循左小右大原则。</li><li> <p>根结点的子节点个数为 [2，<strong>M</strong>]。</p> </li><li>除根结点以外的非叶子结点 的子节点个数为[ <strong>Math.ceil(M/2)</strong>，<strong>M</strong>]，其中Math.ceil() 为向上取整。</li><li>每个非叶子结点的值(索引) 个数 = <strong>子节点个数 -1 </strong>。最小为 <strong>Math.ceil(M/2)-1   </strong>最大为 <strong>M-1 </strong>个。</li><li>B树的所有叶子结点都位于同一层。</li></ul> 
<p>下图就是一个B树：</p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/9b/1c/JQSpYI6H_o.png" width="1044"></p> 
<p><strong>B树的查找结点过程 ：</strong></p> 
<p>在上图中若搜索 key 为 25 节点的 data，首先在根节点进行二分查找（因为 keys 有序，二分最快），判断 key 25 小于 key 50，所以定位到最左侧的节点，此时进行一次磁盘 IO，将该节点从磁盘读入内存，接着继续进行上述过程，直到找到该 key 为止。</p> 
<h3 id="4.B%2B%E6%A0%91">4.B+树</h3> 
<p>B+树是基于B树的基础提出的。</p> 
<p><strong>性质：</strong></p> 
<p></p> 
<ul><li>每个节点中子节点的个数不能超过 m，也不能小于 m/2；</li><li>根节点的子节点个数可以不超过 m/2，这是一个例外；</li><li>m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</li><li>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</li><li>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</li></ul> 
<p>对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？</p> 
<p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。</p> 
<p>对于一个 B+ 树来说，m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘 IO 操作。我们该如何解决这个问题呢？</p> 
<p>实际上，处理思路并不复杂。我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解（图中的 B+ 树是一个三叉树。我们限定叶子节点中，数据的个数超过 2 个就分裂节点；非叶子节点中，子节点的个数超过 3 个就分裂节点）。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1b/40/T7h5WqQJ_o.jpg"></p> 
<p>正是因为要时刻保证 B+ 树索引是一个 m 叉树，所以，索引的存在会导致数据库写入的速度降低。实际上，不光写入数据会变慢，删除数据也会变慢。</p> 
<p>因为我们在删除某个数据的时候，也要对应地更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。</p> 
<p>所以我们可以设置一个阈值。在 B+ 树中，这个阈值等于 m/2。如果某个节点的子节点个数小于 m/2，我们就将它跟相邻的兄弟节点合并。不过，合并之后节点的子节点个数有可能会超过 m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。</p> 
<p>下图中的 B+ 树是一个五叉树。我们限定叶子节点中，数据的个数少于 2 个就合并节点；非叶子节点中，子节点的个数少于 3 个就合并节点。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/31/af/C1R18Pj7_o.jpg"></p> 
<p>而在B+ 树中，将叶子节点串起来的链表是双链表，每个节点都会记住头尾的指针，方便修改，新增，删除；另外一点也是大家写的倒序排列单链表无法实现，单链表只存放的后驱指针所以正向排序是支持的，逆向排序不支持，所以不能是单链表。</p> 
<p>接下来我们来看一下B+树的应用场景：</p> 
<h2 id="%E4%BA%8C%E3%80%81B%2B%E6%A0%91%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">二、B+树应用场景</h2> 
<p>B+树主要用在磁盘文件组织、数据索引和数据库索引。</p> 
<p>（1) B+tree的磁盘读写代价更低<br> B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p> 
<p>（2）B+tree的查询效率更加稳定<br> 由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p> 
<p>（3）B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de73a26129df21519e28286e4e9d05a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 进程的创建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a79a0507a0ad21125552754ebfb7820d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android中layout-sw600dp、layout-w600dp和layout-h600dp的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>