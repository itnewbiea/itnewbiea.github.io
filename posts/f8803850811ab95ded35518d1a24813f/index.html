<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解决httpServletRequest.getParameter获取不到参数 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="解决httpServletRequest.getParameter获取不到参数" />
<meta property="og:description" content="用httpServletRequest.getParameter接收post请求参数，发送端content Type必须设置为application/x-www-form-urlencoded；否则会接收不到
@RequestMapping(value = &#34;/a2&#34;) @ResponseBody public String hello3(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { String string = httpServletRequest.getParameter(&#34;json&#34;); System.out.println(string); return &#34;hahah&#34;; } 用@RequestBody接收请求可以用任意类型的content Type
@RequestMapping(value = &#34;/a&#34;) @ResponseBody public void hello1(@RequestBody String string) { System.out.println(string); } application/x-www-form-urlencoded通过表单提交，在sevlet实现中，mutipart/form-data和application/x-www-form-urlencoded会被特殊处理，请求参数将被放置于request.paramter，这是一个map。我们可以从map中获取参数进行验证，或者其他拦截需求，map的获取类似hibernate的延迟加载，当调用request.getparamter(）方法，servlet才会从请求流中读取请求参数加载入map。InputStream也会存有这份数据，但如果这份数据被读取，那么到了controller层将无法读出数据，同样，拦截之后到达controller层时请求数据已经被加载入了controller层方法实参，实参对象需要有set方法，框架会以反射的方式调用属性的set方法注入数据，数据只会被注入到已有的属性。
当以application/json的content-type传送数据，被传送的对象只需被json序列化。当以application/x-www-form-urlencoded的方式传送数据。请求的内容需要以..=..&amp;..=..的格式提交，在请求体内内容将会以”&amp;”和“ = ”进行拆分。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f8803850811ab95ded35518d1a24813f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-28T23:47:35+08:00" />
<meta property="article:modified_time" content="2019-11-28T23:47:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解决httpServletRequest.getParameter获取不到参数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>用httpServletRequest.getParameter接收post请求参数，发送端content Type必须设置为application/x-www-form-urlencoded；否则会接收不到</p> 
<pre>    @RequestMapping(value = "/a2")
    @ResponseBody
    public String hello3(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) {
        String string = httpServletRequest.getParameter("json");
        System.out.println(string);
        return "hahah";
    }
</pre> 
<p> 用@RequestBody接收请求可以用任意类型的content Type</p> 
<pre>    @RequestMapping(value = "/a")
    @ResponseBody
    public void hello1(@RequestBody String string) {
        System.out.println(string);
    }</pre> 
<p><img alt="" class="has" height="409" src="https://images2.imgbox.com/05/a9/jvqnHwO8_o.png" width="960"></p> 
<p>application/x-www-form-urlencoded通过表单提交，在sevlet实现中，mutipart/form-data和application/x-www-form-urlencoded会被特殊处理，请求参数将被放置于<a name="baidusnap3"></a><strong>request.</strong>paramter，这是一个map。我们可以从map中获取参数进行验证，或者其他拦截需求，map的获取类似hibernate的延迟加载，当调用<strong>request.</strong>getparamter(）方法，<a name="baidusnap2"></a><strong>servlet</strong>才会从请求流中读取请求参数加载入map。InputStream也会存有这份数据，但如果这份数据被读取，那么到了controller层将无法读出数据，同样，拦截之后到达controller层时请求数据已经被加载入了controller层方法实参，实参对象需要有set方法，框架会以反射的方式调用属性的set方法注入数据，数据只会被注入到已有的属性。</p> 
<p>当以application/json的content-type传送数据，被传送的对象只需被json序列化。当以application/x-www-form-urlencoded的方式传送数据。请求的内容需要以..=..&amp;..=..的格式提交，在请求体内内容将会以”&amp;”和“ = ”进行拆分。</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6759d2498fc15cd071f7a1fb405ad3f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenWrt 4G路由器DIY</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2cbae24f77cacc405c149510107f459e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android项目迁移到Androidx经验总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>