<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RocketMQ5-01云原生和AI演变下的架构重构 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RocketMQ5-01云原生和AI演变下的架构重构" />
<meta property="og:description" content="2022年9月22日，迎来 RocketMQ5 的发版，距离 2017 发布的 4.X 时代，RocketMQ 迎来 5.X 时代。
RocketMQ 4.X 时代已经使众多开发者和项目受益，但是随着关注度、使用量逐步上升以及云原生时代的到来，也对其自身架构带来启发和挑战。
所以 Apache RocketMQ 5.0 的演进目标有三个：
消息基础架构的云原生化演进：充分结合云原生大潮下的基础设施和生态技术，提高资源利用和弹性能力。集成效率的痛点升级优化：从API、SDK多方面重构设计，为开发者提供更加简单易用、轻量易集成的方案；事件、流集成场景拓宽：我们将以当前业务集成的能力为基础进一步聚焦消息领域的后处理场景，支持消息的流式处理和轻计算，帮助用户实现消息的就近计算和分析，并将全面拥抱 Serverless 和 EDA。 所以有什么重大变化？存量业务如何稳定迁移？成了使用者最为关注的问题。
让我们从 What&#39;s New 和 Migration from 4.x 中窥探 RocketMQ5 带来的新特性从 What&#39;s New 和 Migration from 4.x 中窥探 RocketMQ5 带来的新特性。
关于 RocketMQ 5.0 中的新特性 基础架构云原生化升级轻量API和多语言SDK事件、流处理场景集成 RocketMQ 4.X 升级至 5.0 以下介绍取自官方文档
关于 RocketMQ 5.0 中的新特性 1、基础架构云原生化升级 随着云上架构、云边架构的扩展，虽然 RocketMQ 的组件是简洁轻量的，但是在资源灵活复用、扩展上存在局限性。
RocketMQ 5.0 引入了全新的弹性无状态代理模式，将当前的 Broker 职责进行拆分，对于客户端协议适配、权限管理、消费管理等计算逻辑进行抽离，独立无状态的代理角色提供服务，Broker 则继续专注于存储能力的持续优化。
从使用上最为直观的，就是引入了 Proxy 的模块，承担一个网关的角色，对外对内统一输出，将权限、适配的职能从 broker 身上抽离，是一个重大改造。5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d4e648dba51777f5dce45d67f70824fa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T14:41:21+08:00" />
<meta property="article:modified_time" content="2024-01-05T14:41:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RocketMQ5-01云原生和AI演变下的架构重构</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>2022年9月22日，迎来 RocketMQ5 的发版，距离 2017 发布的 4.X 时代，RocketMQ 迎来 5.X 时代。</p> 
<p>RocketMQ 4.X 时代已经使众多开发者和项目受益，但是随着关注度、使用量逐步上升以及云原生时代的到来，也对其自身架构带来启发和挑战。</p> 
<p>所以 Apache RocketMQ 5.0 的演进目标有三个：</p> 
<ul><li>消息基础架构的云原生化演进：充分结合云原生大潮下的基础设施和生态技术，提高资源利用和弹性能力。</li><li>集成效率的痛点升级优化：从API、SDK多方面重构设计，为开发者提供更加简单易用、轻量易集成的方案；</li><li>事件、流集成场景拓宽：我们将以当前业务集成的能力为基础进一步聚焦消息领域的后处理场景，支持消息的流式处理和轻计算，帮助用户实现消息的就近计算和分析，并将全面拥抱 Serverless 和 EDA。</li></ul> 
<p>所以有什么重大变化？存量业务如何稳定迁移？成了使用者最为关注的问题。</p> 
<p>让我们从 <code>What's New</code> 和 <code>Migration from 4.x</code> 中窥探 <code>RocketMQ5</code> 带来的新特性从 <code>What's New</code> 和 <code>Migration from 4.x</code> 中窥探 <code>RocketMQ5</code> 带来的新特性。</p> 
<ul><li><a href="#%E5%85%B3%E4%BA%8E-rocketmq-50-%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7" rel="nofollow">关于 RocketMQ 5.0 中的新特性</a> 
  <ul><li><a href="#%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8C%96%E5%8D%87%E7%BA%A7" rel="nofollow">基础架构云原生化升级</a></li><li><a href="#%E8%BD%BB%E9%87%8Fapi%E5%92%8C%E5%A4%9A%E8%AF%AD%E8%A8%80sdk" rel="nofollow">轻量API和多语言SDK</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E9%9B%86%E6%88%90" rel="nofollow">事件、流处理场景集成</a></li></ul> </li><li><a href="#rocketmq-4x-%E5%8D%87%E7%BA%A7%E8%87%B3-50" rel="nofollow">RocketMQ 4.X 升级至 5.0</a></li></ul> 
<p>以下介绍取自<a href="https://rocketmq.apache.org/version/" rel="nofollow">官方文档</a><br> <img src="https://images2.imgbox.com/c2/0c/tomGoMJm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_RocketMQ_50__21"></a>关于 RocketMQ 5.0 中的新特性</h3> 
<h4><a id="1_23"></a>1、基础架构云原生化升级</h4> 
<p>随着云上架构、云边架构的扩展，虽然 RocketMQ 的组件是简洁轻量的，但是在资源灵活复用、扩展上存在局限性。</p> 
<p>RocketMQ 5.0 引入了全新的弹性无状态代理模式，将当前的 Broker 职责进行拆分，对于客户端协议适配、权限管理、消费管理等计算逻辑进行抽离，独立无状态的代理角色提供服务，Broker 则继续专注于存储能力的持续优化。</p> 
<p>从使用上最为直观的，就是引入了 Proxy 的模块，承担一个网关的角色，对外对内统一输出，将权限、适配的职能从 broker 身上抽离，是一个重大改造。5.0 的架构可以向下兼容，与 4.X 是达到一致的使用效果。<br> <img src="https://images2.imgbox.com/0e/9b/B5ZhsXHD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2APISDK_34"></a>2、轻量API和多语言SDK</h4> 
<p>RocketMQ 4.X 时代，采用富客户端模式，想着一个 SDK 去兼容多种开发语言，随着版本迭代、开发语言的多样化发展，这个兼容会越来越笨重，成为负担。</p> 
<p>因此，RocketMQ5.0 时代开始，新增 rocketmq-clients 的项目，基于 gRPC 全新的多语言 SDK，采用全新极简的 API，拥有不可变 API 的设计，对开发者的接入更为友好，便于扩展，不同的语言可以贡献不同的实现，逐步丰富客户端生态。</p> 
<p>RocketMQ 5.0 还引入了一种无状态消费模型，即 Pop 机制，创新性地在队列模型之上支持了无状态的消息模型，在一个主体上同时支持两种消费模型，体现了消息和流的「二象性」。</p> 
<h4><a id="3_42"></a>3、事件、流处理场景集成</h4> 
<p>RocketMQ 5.0 进一步拓宽在消息后处理计算的场景挖掘。支持消息的流式处理和轻计算，帮助用户实现消息的就近计算和分析，并将全面拥抱 Serverless 和 EDA。</p> 
<p>选择“存储计算一体化”架构，同时也能契合“就近计算”的趋势，对于流式计算方面的使用者来说，这个无疑是个重磅。</p> 
<h3><a id="RocketMQ_4X__50_48"></a>RocketMQ 4.X 升级至 5.0</h3> 
<p>RocketMQ 5.0 服务端遵循向下兼容，可以无缝升级。</p> 
<p>针对客户端，可以使用新的 rocketmq-clients 内的 SDK 进行连接，proxy 模式连接方式会稍有差异。针对 5.x 版本，springboot-starter 和 springcloud-starter 的适配暂缓了，所以还是建议用官方新的 client 来接入。</p> 
<p>后续文章将从 docker 部署、JAVA client 连接上进一步体验新功能。<br> <a href="https://github.com/CzyerChen/rocketmq-clients">点这里速看 rocketmq-clients 的最新动态</a> 和持续关注。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e3e0d73896a631b16c865ffb83be836/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">element的Table表格组件树形数据与非懒加载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a3087036d12036222e6db1aa01afdc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TwinCAT 3 tcp程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>