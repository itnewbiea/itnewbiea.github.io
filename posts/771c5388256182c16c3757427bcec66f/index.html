<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Bringing HLSL Ray Tracing to Vulkan - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Bringing HLSL Ray Tracing to Vulkan" />
<meta property="og:description" content="This post was revised March 2020 to reflect newly added support in DXC for targeting the SPV_KHR_ray_tracing multi-vendor extension.
Vulkan logo
DirectX Ray Tracing (DXR) allows you to render graphics using ray tracing instead of the traditional method of rasterization. This API was created by NVIDIA and Microsoft back in 2018.
A few months later, NVIDIA unveiled its Turing GPU architecture with native support in hardware to accelerate ray tracing workloads." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/771c5388256182c16c3757427bcec66f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-12T19:01:55+08:00" />
<meta property="article:modified_time" content="2023-07-12T19:01:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Bringing HLSL Ray Tracing to Vulkan</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><em>This post was revised March 2020 to reflect newly added support in DXC for targeting the SPV_KHR_ray_tracing multi-vendor extension.</em></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9b/f4/6gVy4IHn_o.png"></p> 
<p>Vulkan logo</p> 
<p>DirectX Ray Tracing (DXR) allows you to render graphics using ray tracing instead of the traditional method of rasterization. This API was created by NVIDIA and Microsoft back in 2018.</p> 
<p>A few months later, NVIDIA unveiled its Turing GPU architecture with native support in hardware to accelerate ray tracing workloads. Ever since, the ray-tracing ecosystem has been steadily evolving. Multiple AAA game titles using DXR have been announced and released, as well as industry standard visualization tools. </p> 
<p>Along with DXR, NVIDIA shipped the NVIDIA VKRay Vulkan vendor extension with the same level of ray tracing functionality exposed. Several Vulkan titles use NVIDIA VKRay, including <em>Quake2 RTX</em>, <em>JX3 (MMO)</em>, and <em>Wolfenstein: Youngblood</em>.</p> 
<h3>Porting DirectX Content to Vulkan</h3> 
<p>The Vulkan API from <a href="https://www.khronos.org/" rel="nofollow" title="The Khronos Group">The Khronos Group</a>, being cross-platform, can reach a wide audience across a diverse range of platforms and devices. Many developers port content from DirectX to Vulkan to take advantage of this broader market reach. However, porting a title requires porting both the API calls (to Vulkan) and the shaders (to SPIR-V). </p> 
<p>While most ISVs can port 3D API calls with some reasonable effort, rewriting HLSL shaders in another shading language is a significant undertaking. Shader source code may evolve over many years. In some cases, shaders are also generated on the fly. Consequently, a cross-platform compiler that translates HLSL shader source into SPIR-V for execution by Vulkan is very attractive to developers. </p> 
<p>One such tool developed by Google is the SPIR-V backend to Microsoft’s open source DirectXCompiler (DXC). Over the past couple of years, this compiler has become the common, production-ready solution for bringing HLSL content to Vulkan. Khronos recently discussed more background on using HLSL in Vulkan in a recent post, <a href="https://www.khronos.org/blog/hlsl-first-class-vulkan-shading-language" rel="nofollow" title="HLSL as a first class Vulkan Shading Language">HLSL as a first class Vulkan Shading Language</a>. </p> 
<p>Now, bringing together the use of HLSL and ray tracing in Vulkan, NVIDIA has added <a href="https://github.com/microsoft/DirectXShaderCompiler/pull/1920" title="ray tracing support to DXC’s SPIR-V backend">ray tracing support to DXC’s SPIR-V backend</a> by targeting the SPV_NV_ray_tracing extension under the NVIDIA VKRay extension. We have also <a href="https://github.com/microsoft/DirectXShaderCompiler/pull/2780" title="upstreamed support">upstreamed support</a> for the multi-vendor extension, SPV_KHR_ray_tracing. </p> 
<h4>NVIDIA VKRay example</h4> 
<p>Here’s how to use HLSL shaders in an existing app, created in the <a href="https://developer.nvidia.com/rtx/raytracing/vkray" rel="nofollow" title="Vulkan Ray Tracing Tutorial">Vulkan Ray Tracing Tutorial</a> written by NVIDIA engineers Martin-Karl Lefrançois and Pascal Gautron. </p> 
<p>The following code shows  the HLSL closest hit shader that calculates shadows with a single point light from the sample app:</p> 
<pre>#include "raycommon.hlsl"
#include "wavefront.hlsl"

struct MyAttrib
{
        float3 attribs;
};

struct Payload
{
   bool isShadowed;
};

[[vk::binding(0,0)]] RaytracingAccelerationStructure topLevelAS;

[[vk::binding(2,1)]] StructuredBuffer&lt;sceneDesc&gt; scnDesc;

[[vk::binding(5,1)]] StructuredBuffer&lt;Vertex&gt; vertices[];

[[vk::binding(6,1)]] StructuredBuffer&lt;uint&gt; indices[];


[[vk::binding(1,1)]] StructuredBuffer&lt;WaveFrontMaterial&gt; materials[];

[[vk::binding(3,1)]] Texture2D textures[];
[[vk::binding(3,1)]] SamplerState samplers[];

[[vk::binding(4,1)]] StructuredBuffer&lt;int&gt; matIndex[];

struct Constants
{
        float4 clearColor;
        float3 lightPosition;
        float lightIntensity;
        int lightType;
};

[[vk::push_constant]] ConstantBuffer&lt;Constants&gt; pushC;

[shader("closesthit")]
void main(inout hitPayload prd, in MyAttrib attr)
{
  // Object of this instance
  uint objId = scnDesc[InstanceIndex()].objId;

  // Indices of the triangle
  int3 ind = int3(indices[objId][3 * PrimitiveIndex() + 0],
                    indices[objId][3 * PrimitiveIndex() + 1],
                    indices[objId][3 * PrimitiveIndex() + 2]);
  // Vertex of the triangle
  Vertex v0 = vertices[objId][ind.x];
  Vertex v1 = vertices[objId][ind.y];
  Vertex v2 = vertices[objId][ind.z];

  const float3 barycentrics = float3(1.0 - attr.attribs.x - 
  attr.attribs.y, attr.attribs.x, attr.attribs.y);

  // Computing the normal at hit position
  float3 normal = v0.nrm * barycentrics.x + v1.nrm * barycentrics.y + 
  v2.nrm * barycentrics.z;
  // Transforming the normal to world space
  normal = normalize((mul(scnDesc[InstanceIndex()].transfoIT 
           ,float4(normal, 0.0))).xyz);


  // Computing the coordinates of the hit position
  float3 worldPos = v0.pos * barycentrics.x + v1.pos * barycentrics.y 
                    + v2.pos * barycentrics.z;
  // Transforming the position to world space
  worldPos = (mul(scnDesc[InstanceIndex()].transfo, float4(worldPos, 
              1.0))).xyz;

  // Vector toward the light
  float3  L;
  float lightIntensity = pushC.lightIntensity;
  float lightDistance  = 100000.0;

  // Point light
  if(pushC.lightType == 0)
  {
    float3 lDir      = pushC.lightPosition - worldPos;
    lightDistance  = length(lDir);
    lightIntensity = pushC.lightIntensity / (lightDistance * 
                     lightDistance);
    L              = normalize(lDir);
  }
  else  // Directional light
  {
    L = normalize(pushC.lightPosition - float3(0,0,0));
  }

  // Material of the object
  int               matIdx = matIndex[objId][PrimitiveIndex()];
  WaveFrontMaterial mat    = materials[objId][matIdx];


  // Diffuse
  float3 diffuse = computeDiffuse(mat, L, normal);
  if(mat.textureId &gt;= 0)
  {
    uint txtId = mat.textureId + scnDesc[InstanceIndex()].txtOffset;
    float2 texCoord =
        v0.texCoord * barycentrics.x + v1.texCoord * barycentrics.y + 
                  v2.texCoord * barycentrics.z;
    diffuse *= textures[txtId].SampleLevel(samplers[txtId], texCoord,
            0).xyz;
  }

  float3  specular    = float3(0,0,0);
  float attenuation = 1;

  // Tracing shadow ray only if the light is visible from the surface
  if(dot(normal, L) &gt; 0)
  {
    float tMin   = 0.001;
    float tMax   = lightDistance;
    float3  origin = WorldRayOrigin() + WorldRayDirection() * 
        RayTCurrent();
    float3  rayDir = L;
    uint  flags =
        RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | 
        RAY_FLAG_FORCE_OPAQUE |
        RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;

    RayDesc desc;
    desc.Origin = origin;
    desc.Direction = rayDir;
    desc.TMin = tMin;
    desc.TMax = tMax;

    Payload shadowPayload;
    shadowPayload.isShadowed = true;
    TraceRay(topLevelAS,
             flags,
             0xFF,
             0,
             0,
             1,
             desc,
             shadowPayload
    );

    if(shadowPayload.isShadowed)
    {
      attenuation = 0.9;
    }
    else
    {
      // Specular
      specular = computeSpecular(mat, WorldRayDirection(), L, normal);
    }
  }

  prd.hitValue = float3(lightIntensity * attenuation * (diffuse + 
  specular));
} </pre> 
<h4>Translating to SPIR-V</h4> 
<p>Here are several interesting portions of the translation:</p> 
<ul><li>Resource binding</li><li>Entry points</li><li>Entry point arguments</li><li>Translation to intrinsics</li><li>ShaderBufferRecord (also known as user SBT data)</li></ul> 
<h5>Resource binding </h5> 
<p>At the top of the shader, there is a declaration of a new basic type in HLSL for ray tracing:</p> 
<pre>[[vk::binding(0,0)]] RaytracingAccelerationStructure topLevelAS;
</pre> 
<p>DirectX uses global root signatures as a mechanism for resource binding. For Vulkan, <code>[[vk::binding]]</code> is a special annotation used to set the binding point and descriptor set location for resources. This annotation is translated to SPIR-V <code>Binding</code> and <code>DescriptorSet</code> decorations respectively, which are ignored when generating DXIL.</p> 
<p>You can also continue using <code>register(xX, spaceY)</code> semantics which would be mapped to the <code>Binding</code> and <code>DescriptorSet</code> decorations. For information about a full list of annotations and mappings, see <a href="https://github.com/microsoft/DirectXShaderCompiler/blob/master/docs/SPIR-V.rst#id32" title="HLSL to SPIR-V Feature Mapping Manual">HLSL to SPIR-V Feature Mapping Manual</a>.</p> 
<p><code>RaytracingAccelerationStructure</code> maps directly to SPIR-V opcode <code>OpTypeAccelerationStructureNV/OpTypeAcccelerationStructureKHR</code>.</p> 
<h5>Entry points</h5> 
<p>Shader entry points look like the following code example: </p> 
<pre>[shader("closesthit")]
void main(inout hitPayload prd, in MyAttrib attr)</pre> 
<p>DXR HLSL shaders do not use a specific profile for compilation and are compiled as shader libraries (<code>lib_6_*</code> profiles). This allows hundreds of entry points for different ray tracing stages to be present in a single file. To specify specific stages, use the following the annotation:  </p> 
<pre>[shader(“&lt;stage&gt;”)] </pre> 
<p>Use it where <code>&lt;stage&gt;</code> can be any of the following values:</p> 
<pre>raygeneration, intersection, closesthit, anyhit, miss</pre> 
<p>These shader libraries are translated to SPIR-V with multiple entry points in a single blob. For the above entry point, the SPIR-V code looks like the following:</p> 
<pre>OpEntryPoint ClosestHitNV %main "main" %gl_InstanceID %gl_PrimitiveID %5 %6 %7
</pre> 
<h5>Entry point arguments</h5> 
<pre>void main(<strong>inout hitPayload prd, in MyAttrib attr</strong>)</pre> 
<p>DXR HLSL mandates specific rules for the number and type of arguments for each entry point of a ray tracing stage. For example, in closest-hit shaders, both arguments must be a user-defined structure type. The first represents the payload, while the second represents the hit attributes. A complete set of rules is outlined in the <a href="https://github.com/microsoft/DirectX-Specs/blob/master/d3d/Raytracing.md" title="DXR specification">DXR specification</a>. </p> 
<p>SPIR-V does not allow shader entry points to have arguments. During translation, these variables are added to the global scope with storage classes <code>IncomingRayPayloadNV/IncomingRayPayloadKHR</code> and <code>HitAttributeNV/HitAttributeKHR</code>, respectively. The translation also takes care of proper in-out copy semantics.</p> 
<h5>Translation of intrinsics</h5> 
<p>There is a one-to-one mapping for system value intrinsics like <code>InstanceIndex()</code> to SPIR-V built-ins. For more information about the full list of the mappings, see <a href="https://github.com/microsoft/DirectXShaderCompiler/blob/master/docs/SPIR-V.rst" title="HLSL to SPIR-V Feature Mapping Manual">HLSL to SPIR-V Feature Mapping Manual</a>. Matrix intrinsics <code>ObjectToWorld3x4()</code> and <code>WorldToObject3x4()</code> in HLSL don’t have a direct mapping to SPIR-V built-ins. For these, use the original non-transposed SPIR-V built-ins and transpose the result during the translation.</p> 
<p>The <code>TraceRay()</code> intrinsic in HLSL uses a specific predeclared structure type, <code>RayDesc</code>. This type is populated with geometric information for the ray, such as origin, direction, and parametric min and max. The <code>OpTraceNV/OpTraceRayKHR</code> action needs each of these parameters as separate arguments. The following code example unpacks the <code>RayDesc</code> structure during translation as follows.</p> 
<pre>OpTraceNV %245 %uint_13 %uint_255 %uint_0 %uint_0 %uint_1 %244 %float_0_00100000005 %192 %191 %uint_0

OpTraceRayKHR %245 %uint_13 %uint_255 %uint_0 %uint_0 %uint_1 %244 %float_0_00100000005 %192 %191 %uint_0</pre> 
<p><code>TraceRay()</code> is templated intrinsic, with the last argument being the payload. There are no templates in SPIR-V.  <code>OpTraceNV/OpTraceRayKHR</code> works around this limitation by providing a location number of the <code>RayPayloadNV/RayPayloadKHR</code> decorated variable. This allows different calls to use different payloads and thereby mimics the template functionality. During translation, <code>RayPayloadNV/RayPayloadKHR</code> decorated variables with unique location numbers are generated while doing copy-in and copy-out of data to preserve the semantics of the <code>TraceRay()</code> call.</p> 
<h5>ShaderBufferRecord (also known as user SBT data)</h5> 
<p>NVIDIA’s VKRay extension for ray tracing allows read-only access to user data in the shader binding table (SBT) in ray tracing shaders using shader record buffer blocks. For more information, see the <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#shader-binding-table" rel="nofollow" title="Vulkan 1,2 specification">Vulkan 1,2 specification</a>. The SBT data is not directly accessible in HLSL shaders.</p> 
<p>To expose this feature, add the <code>[[vk::shader_record_nv]]/[[vk::shader_record_ext]]</code> annotation to <code>ConstantBuffer/cbuffers</code> declarations:</p> 
<pre>struct S { float t; }
[[vk::shader_record_nv]]
ConstantBuffer&lt;S&gt; cbuf;</pre> 
<p>DXR introduced local root signatures for binding resources for each shader present in the SBT. Instead of emulating local root signature at SPIR-V level and enforcing some contract on the app, we provide access to the user data section inside the SBT. This, along with support for VK_EXT_descriptor_indexing and its corresponding SPIR-V capability RuntimeDescriptorArrayEXT, can achieve the same effect as local root signature while retaining flexibility. Here’s a code example:</p> 
<pre>[[vk::binding(0,0)] Texture2D&lt;float4&gt; gMaterials[];
struct Payload { float4 Color; };
struct Attribs { float2 value; };
struct MaterialData { uint matDataIdx; };
[[vk::shader_record_nv]]
ConstantBuffer&lt;MaterialData&gt; cbuf;
void main(inout Payload prd, in Attribs bary)
{
    Texture2D tex = gMaterials[NonUniformResourceIndex(matDataIdx)]
    prd.Color += tex[bary.value];
}</pre> 
<p>From our experience, this mechanism lines up fairly well with the way most DXR applications use the SBT. It’s also simpler to deal with from the application side, compared to other potential approaches for emulating a local root signature.</p> 
<h4>Generating SPIR-V using the Microsoft DXC compiler</h4> 
<p>The earlier HLSL code can be converted to SPIR-V targeting the KHR extension by running the following command:</p> 
<pre>dxc.exe -T lib_6_4 raytrace.rchit.hlsl -spirv -Fo raytrace.rchit.spv -fvk-use-scalar-layout</pre> 
<p>To target the NV extension, run the following command:</p> 
<pre>dxc.exe -T lib_6_4 raytrace.rchit.hlsl -spirv -Fo raytrace.rchit.spv -fvk-use-scalar-layout -fspv-extension="SPV_NV_ray_tracing"</pre> 
<p>The options used are as follows: </p> 
<ul><li><strong>-T lib_6_4</strong>: Use the standard profile for compiling ray tracing shaders. </li><li><strong>-spirv</strong>: Generate output in SPIR-V.</li><li><strong>-Fo &lt;filename&gt;</strong>: Generate an output file from &lt;filename&gt;.</li></ul> 
<p>That’s pretty much it! You can plug in the generated SPIR-V blob in the <a href="https://github.com/alelenv/vk_raytracing_tutorial/tree/master/ray_tracing__simple/shaders" title="sources">sources</a> and see that it runs as expected, as shown in Figure 2. If you compare the SPIR-V generated from HLSL or corresponding GLSL, it looks very similar.</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ae/c0/J4BGqp4A_o.png"></p> 
<p><br> Figure 2: <em>Vulkan Ray Tracing tutorial using HLSL shaders. </em></p> 
<h3>Conclusion</h3> 
<p>The NVIDIA VKRay extension, with the DXC compiler and SPIR-V backend, provides the same level of ray tracing functionality in Vulkan through HLSL as is currently available in DXR. You can now develop ray-tracing applications using DXR or NVIDIA VKRay with minimized shader re-writing to deploy to either the DirectX or Vulkan APIs.</p> 
<p>We encourage you to take advantage of this new flexibility and expand your user base by bringing ray tracing titles to Vulkan.</p> 
<h3>References</h3> 
<ul><li><a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_NV_ray_tracing" rel="nofollow" title="VK_NV_ray_tracing">VK_NV_ray_tracing</a></li><li><a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_KHR_ray_tracing" rel="nofollow" title="VK_KHR_ray_tracing">VK_KHR_ray_tracing</a></li><li><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GLSL_NV_ray_tracing.txt" title="GLSL_NV_ray_tracing">GLSL_NV_ray_tracing</a></li><li><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt" title="GLSL_EXT_ray_tracing">GLSL_EXT_ray_tracing</a></li><li><a href="https://github.com/microsoft/DirectXShaderCompiler/blob/master/docs/SPIR-V.rst#raytracing-in-vulkan-and-spirv" title="DXC documentation for NV_ray tracing, KHR_ray_tracing">DXC documentation for NV_ray tracing, KHR_ray_tracing</a></li><li><a href="https://github.com/alelenv/vk_raytracing_tutorial" title="HLSL shaders for the tutorial">HLSL shaders for the tutorial</a></li></ul> 
<p></p> 
<h3>Related resources</h3> 
<ul><li>GTC session: <a href="https://www.nvidia.com/en-us/on-demand/session/gtcspring23-DLIT51580/?ncid=em-even-124008-vt33" rel="nofollow" title="Ray-Tracing Development using NVIDIA Nsight Graphics and NVIDIA Nsight Systems* (Spring 2023)">Ray-Tracing Development using NVIDIA Nsight Graphics and NVIDIA Nsight Systems* (Spring 2023)</a></li><li>GTC session: <a href="https://www.nvidia.com/en-us/on-demand/session/gtcspring23-CWES52009/?ncid=em-even-124008-vt33" rel="nofollow" title="Connect with the Experts: Using NVIDIA Developer Tools to Optimize Ray Tracing (Spring 2023)">Connect with the Experts: Using NVIDIA Developer Tools to Optimize Ray Tracing (Spring 2023)</a></li><li>SDK: <a href="https://developer.nvidia.com/nsight-graphics?ncid=em-nurt-245273-vt33" rel="nofollow" title="Nsight Graphics">Nsight Graphics</a></li><li>SDK: <a href="https://developer.nvidia.com/optix?ncid=em-nurt-245273-vt33" rel="nofollow" title="OptiX">OptiX</a></li><li>SDK: <a href="https://developer.nvidia.com/rtx/path-tracing?ncid=em-nurt-245273-vt33" rel="nofollow" title="Path Tracing SDK">Path Tracing SDK</a></li><li>Webinar: <a href="https://gateway.on24.com/wcc/eh/1407606/lp/1883368/?embedUrl=https://www.nvidia.com/en-us/about-nvidia/webinar-portal/" rel="nofollow" title="Introducing NVIDIA Quadro RTX">Introducing NVIDIA Quadro RTX</a></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/79b3a6a0336f29f95dae777f20d95de0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SqlServer已有的表添加主键自增</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5ac33c5ffde20644c92930028768e917/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【学习记录】小车配置Livox雷达记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>