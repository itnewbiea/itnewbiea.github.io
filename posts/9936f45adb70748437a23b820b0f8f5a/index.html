<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Access to XMLHttpRequest at &#39;http://localhost:8080/api/user/login&#39; from origin &#39;http://localhost:808 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Access to XMLHttpRequest at &#39;http://localhost:8080/api/user/login&#39; from origin &#39;http://localhost:808" />
<meta property="og:description" content="用nodejs&#43;express封装自己的api，遇到跨域问题
原本我是这样写进去的：
//设置跨域访问 app.all(&#39;*&#39;, function(req, res, next) { res.header(&#34;Access-Control-Allow-Origin&#34;, &#34;*&#34;); res.header(&#34;Access-Control-Allow-Headers&#34;, &#34;X-Requested-With&#34;); res.header(&#34;Access-Control-Allow-Methods&#34;,&#34;PUT,POST,GET,DELETE,OPTIONS&#34;); res.header(&#34;X-Powered-By&#34;,&#39; 3.2.1&#39;) res.header(&#34;Content-Type&#34;, &#34;application/json;charset=utf-8&#34;); next(); }); 后来浏览器一直：
解决方式：
把上边的第二句换成：
res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#39;); 完整代码：
var express = require(&#39;express&#39;); var md5 = require(&#39;js-md5&#39;); var app = express(); var bodyParser = require(&#39;body-parser&#39;); app.use(bodyParser.json({ limit: &#39;1mb&#39; })); app.use(bodyParser.urlencoded({ limit: &#39;1mb&#39;, extended: true })); var DatabaseOperation = require(&#39;./connection&#39;); //引用bodyParser app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: true })); //设置跨域请求 app.all(&#39;*&#39;, function (req, res, next) { res." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9936f45adb70748437a23b820b0f8f5a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-21T17:35:40+08:00" />
<meta property="article:modified_time" content="2019-04-21T17:35:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Access to XMLHttpRequest at &#39;http://localhost:8080/api/user/login&#39; from origin &#39;http://localhost:808</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>用nodejs+express封装自己的api，遇到跨域问题</p> 
<p>原本我是这样写进去的：</p> 
<pre class="has"><code>//设置跨域访问
app.all('*', function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "X-Requested-With");
    res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");
    res.header("X-Powered-By",' 3.2.1')
    res.header("Content-Type", "application/json;charset=utf-8");
    next();
});</code></pre> 
<p>后来浏览器一直：</p> 
<p> <img alt="" class="has" height="78" src="https://images2.imgbox.com/96/38/xRk0QqoM_o.png" width="681"></p> 
<p>解决方式：</p> 
<p><img alt="" class="has" height="205" src="https://images2.imgbox.com/3f/60/GYEToYWb_o.png" width="891"></p> 
<p> 把上边的第二句换成：</p> 
<pre class="has"><code>    res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');</code></pre> 
<p>完整代码：</p> 
<pre class="has"><code>var express = require('express');
var md5 = require('js-md5');
var app = express();
var bodyParser = require('body-parser');
app.use(bodyParser.json({
  limit: '1mb'
}));
app.use(bodyParser.urlencoded({
  limit: '1mb',
  extended: true
}));
var DatabaseOperation = require('./connection');

//引用bodyParser
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({
  extended: true
}));
//设置跨域请求
app.all('*', function (req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');
  res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
  res.header("X-Powered-By", ' 3.2.1')
  res.header("Content-Type", "application/json;charset=utf-8");
  next();
});

//用户注册
app.get('/api/user/register', function (req, res) {
  DatabaseOperation.select('user', {
    "username": req.query.username,
  }, function (result) {
    if (result.length &gt; 0) {
      result = {
        code: '1001'
      }
      res.json(result);
    } else {
      DatabaseOperation.insert('user', [{
        "username": req.query.username,
        "password": md5(req.query.password)
      }], function (result) {
        res.json(result)
      });
    }
  });
});

const port = 8080;
app.listen(port, () =&gt; {
  console.log('Express server listening on port ' + port);
});</code></pre> 
<p><strong>connection.js</strong></p> 
<pre class="has"><code>const MongoClient = require('mongodb').MongoClient;
const assert = require('assert');
var dataconfig = require('./dataconfig');
var DatabaseOperation = {
  /*
  @selectall 方法返回全部所有数据
  @dataname 数据库名称
  @dealdata 回调处理函数 格式function(result){};
  */
  selectall: function (dataname, dealdata) {
    const client = new MongoClient(dataconfig.dataurl);
    client.connect(function (err) {
      assert.equal(null, err);
      console.log("数据库连接成功");
      const db = client.db(dataconfig.dataname);
      db.collection(dataname).find({}).toArray(function (err, result) { // 返回集合中所有数据
        if (err) throw err;
        dealdata(result);
      });
      client.close();
    })
  },
  /*
  @selectone 查询符合条件的数据
  @dataname 数据库名称
  @selectlanguage 查询控制语句 格式{index:value,index,value};
  @dealdata 回调处理函数 格式function(result){};
  */
  select: function (dataname, selectlanguage, dealdata) {
    const client = new MongoClient(dataconfig.dataurl);
    client.connect(function (err) {
      assert.equal(null, err);
      console.log("数据库连接成功");
      const db = client.db(dataconfig.dataname);
      db.collection(dataname).find(selectlanguage).toArray(function (err, docs) {
        console.log('find');
        dealdata(docs);
        client.close();
      });
    })
  },
  /*
  @insert添加数据格式json格式
  @dataname 数据库名称
  @dealdata 回调函数处理函数有一个result参数
  */
  insert: function (dataname, insertlanguage, dealdata) {
    const client = new MongoClient(dataconfig.dataurl);
    client.connect(function (err) {
      assert.equal(null, err);
      console.log("数据库连接成功");
      const db = client.db(dataconfig.dataname);
      db.collection(dataname).insertMany(insertlanguage, function (err, result) {
        assert.equal(err, null);
        dealdata(result);
        client.close();
      });
    })
  },
  /*
@update 修改数据的方法
@update添加数据格式json格式
@dataname 数据库名称
@dealdata 回调函数处理函数有一个result参数
*/
  update: function (dataname, updatelanguage, updatecondition, dealdata) {
    const client = new MongoClient(dataconfig.dataurl);
    client.connect(function (err) {
      assert.equal(null, err);
      console.log("数据库连接成功");
      const db = client.db(dataconfig.dataname);
      db.collection(dataname).updateOne(updatelanguage, updatecondition, function (err, result) {
        assert.equal(err, null);
        dealdata(result);
        client.close();
      });
    })
  },
  /*
  @removeall 删除数据的方法
  @dataname 数据库名称
  @removelanguage 删除数据的条件
  @dealdata 回调函数处理函数有一个result参数
  */
  removeall: function (dataname, removelanguage, dealdata) {
    const client = new MongoClient(dataconfig.dataurl);
    client.connect(function (err) {
      assert.equal(null, err);
      const db = client.db(dataconfig.dataname);
      db.collection(dataname).findAndRemove(removelanguage, function (err, result) {
        assert.equal(err, null);
        dealdata(result);
        client.close();
      });
    })
  },

};

// 测试用例
// DatabaseOperation.selectall('address', function(result) {
//         console.log("select查询结果");
//         console.log(result);
//     })
// DatabaseOperation.select('address', {
//     "addressid": "2"
// }, function(result) {
//     console.log("select查询结果");
//     console.log(result);
// });
// DatabaseOperation.insert('address', [{
//         "insert": "hello"
//     }], function(result) {
//         console.log('inserts插入结果');
//         console.log(result);
//     })
// DatabaseOperation.removeall('note', {
//     "id": "5ce177b965ee630c046266af"
// }, function(result) {
//     console.log(result);
// })

module.exports = DatabaseOperation;</code></pre> 
<p> </p> 
<p>最后愉快地解决了！</p> 
<p>接下来了解一下响应头是什么（只说明上边的几个，其他自行了解）：</p> 
<p>上边的设置，在前端请求后端接口的时候，就会用到：</p> 
<p><img alt="" class="has" height="461" src="https://images2.imgbox.com/d9/1c/sFpV7eGn_o.png" width="866"></p> 
<p> </p> 
<p><strong>Access-Control-Allow-Headers:Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild ：</strong>响应首部，用于预检请求中，代表将会在正式请求的Access-Control-Expose-Headers 字段中出现的首部信息。</p> 
<p>其中：</p> 
<p>Content-Type： 实体头部用于指示资源的MIME类型 media type 。</p> 
<p>在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosnif</p> 
<p>Authorization ：请求头含有服务器用于验证用户代理身份的凭证。</p> 
<p>Accept ：请求头用来告知客户端可以处理的内容类型</p> 
<p><strong>Access-Control-Allow-Origin:* ： </strong>响应头指定了该响应的资源是否被允许与给定的origin共享，对于不需具备凭证（credentials）的请求，服务器会以“<code>*</code>”作为通配符，从而允许所有域都具有访问资源的权限。或者也可以指定进行限制</p> 
<p><strong>Content-Length :74 : </strong>表明了实体主体部分的大小（单位是字节）</p> 
<p><strong>Access-Control-Allow-Methods：PUT,POST,GET,DELETE,OPTIONS：</strong>服务器端允许的请求方式，常用get、post</p> 
<p><strong>Date: </strong>其中包含了报文创建的日期和时间。格式：</p> 
<pre class="has"><code class="language-html">Date: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT</code></pre> 
<p>&lt;day-name&gt;</p> 
<p>"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", 或 "Sun" 之一 （区分大小写）。</p> 
<p>&lt;day&gt;</p> 
<p>2位数字表示天数，例如， "04" 或 "23"。</p> 
<p>&lt;month&gt;</p> 
<p>"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" 之一（区分大小写）。</p> 
<p>&lt;year&gt;</p> 
<p>4位数字表示年份，例如， "1990" 或 "2016"。</p> 
<p>&lt;hour&gt;</p> 
<p>2位数字表示小时数，例如， "09" 或 "23"。</p> 
<p>&lt;minute&gt;</p> 
<p>2位数字表示分钟数，例如， "04" 或 "59"。</p> 
<p>&lt;second&gt;</p> 
<p>2位数字表示秒数，例如， "04" 或 "59"。</p> 
<p>GMT</p> 
<p>格林尼治标准时间。 在HTTP协议中，时间都是用格林尼治标准时间来表示的，而不是本地时间。</p> 
<p><strong>Content-Type:application/json; charset=utf-8： </strong>说明实体内对象的媒体类型。</p> 
<p>HTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）。</p> 
<p><strong>ETag：</strong>如果给定URL中的资源更改，则一定要生成新的Etag值。 因此Etags类似于指纹，也可能被某些服务器用于跟踪。 比较etags能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。</p> 
<p><strong>X-Powered-By: 3.2.1 :</strong> 这个查了半天没找到一个合理的解释，出于安全考虑一般会隐藏，不过使用express会自动暴露，于是就手动修改：</p> 
<p>默认：</p> 
<p><img alt="" class="has" height="204" src="https://images2.imgbox.com/7a/0b/GFHsZRwH_o.png" width="828"></p> 
<p>默认暴露我们使用的框架是express</p> 
<p>这样隐藏掉：</p> 
<pre class="has"><code> res.header("X-Powered-By", ' 3.2.1')</code></pre> 
<p><img alt="" class="has" height="221" src="https://images2.imgbox.com/97/82/Q2IXAaVO_o.png" width="834"></p> 
<p>想了解更多精彩的你：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/ae/bf/GTvzacxH_o.png"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/278daaeddb98c4658157b392650385b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">3，开启 树莓派 的 root 帐号 （新人向）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e0151e44cc9a0a7f2dcf34a62e5b578/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">postcss-px2rem配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>