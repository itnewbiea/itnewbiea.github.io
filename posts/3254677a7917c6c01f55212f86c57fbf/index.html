<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dockerfile - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dockerfile" />
<meta property="og:description" content="文章目录 1. 概述2. 常用指令2.1 FROM2.2 MAINTAINER2.3 RUN2.4 CMD2.5 EXPOSE2.6 ENV2.7 ADD2.8 COPY2.9 ENTRYPOINT2.10 VOLUME2.11 USER2.12 WORKDIR2.13 ONBUILD 3. 创建镜像4. 案例：构建nginx镜像 1. 概述 Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。
在Docker中创建镜像最常用的方式，就是使用Dockerfile。Dockerfile是一个Docker镜像的描述文件。Dockerfile其内部包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
Dockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行。
Docker分为四部分：
基础镜像信息维护者信息镜像操作指令容器启动时默认要执行的指令 例：
#基于centos镜像 FROM centos #维护人的信息 MAINTAINER The CentOS Project &lt;303323496@qq.com&gt; #安装httpd软件包 RUN yum -y update RUN yum -y install httpd #开启80端口 EXPOSE 80 #复制网站首页文件至镜像中web站点下 ADD index.html /var/www/html/index.html #复制该脚本至镜像中，并修改其权限 ADD run.sh /run.sh RUN chmod 775 /run.sh #当启动容器时执行的脚本文件 CMD [&#34;/run.sh&#34;] 一开始必须指明所基于的镜像名称，接下来一般会说明维护者信息。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3254677a7917c6c01f55212f86c57fbf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-31T20:22:49+08:00" />
<meta property="article:modified_time" content="2020-08-31T20:22:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dockerfile</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__4" rel="nofollow">1. 概述</a></li><li><a href="#2__53" rel="nofollow">2. 常用指令</a></li><li><ul><li><a href="#21_FROM_58" rel="nofollow">2.1 FROM</a></li><li><a href="#22_MAINTAINER_67" rel="nofollow">2.2 MAINTAINER</a></li><li><a href="#23_RUN_82" rel="nofollow">2.3 RUN</a></li><li><a href="#24_CMD_92" rel="nofollow">2.4 CMD</a></li><li><a href="#25_EXPOSE_111" rel="nofollow">2.5 EXPOSE</a></li><li><a href="#26_ENV_120" rel="nofollow">2.6 ENV</a></li><li><a href="#27_ADD_130" rel="nofollow">2.7 ADD</a></li><li><a href="#28_COPY_141" rel="nofollow">2.8 COPY</a></li><li><a href="#29_ENTRYPOINT_150" rel="nofollow">2.9 ENTRYPOINT</a></li><li><a href="#210_VOLUME_160" rel="nofollow">2.10 VOLUME</a></li><li><a href="#211_USER_169" rel="nofollow">2.11 USER</a></li><li><a href="#212_WORKDIR_181" rel="nofollow">2.12 WORKDIR</a></li><li><a href="#213_ONBUILD_201" rel="nofollow">2.13 ONBUILD</a></li></ul> 
  </li><li><a href="#3__212" rel="nofollow">3. 创建镜像</a></li><li><a href="#4_nginx_230" rel="nofollow">4. 案例：构建nginx镜像</a></li></ul> 
</div> 
<p></p> 
<br> 
<h2><a id="1__4"></a>1. 概述</h2> 
<hr> 
<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p> 
<p>在Docker中创建镜像最常用的方式，就是使用Dockerfile。Dockerfile是一个Docker镜像的描述文件。Dockerfile其内部包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p> 
<p>Dockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行。</p> 
<p>Docker分为四部分：</p> 
<ul><li>基础镜像信息</li><li>维护者信息</li><li>镜像操作指令</li><li>容器启动时默认要执行的指令</li></ul> 
<p>例：</p> 
<pre><code class="prism language-bash"><span class="token comment">#基于centos镜像</span>
FROM centos

<span class="token comment">#维护人的信息</span>
MAINTAINER The CentOS Project <span class="token operator">&lt;</span>303323496@qq.com<span class="token operator">&gt;</span>

<span class="token comment">#安装httpd软件包</span>
RUN yum -y update
RUN yum -y <span class="token function">install</span> httpd

<span class="token comment">#开启80端口</span>
EXPOSE 80

<span class="token comment">#复制网站首页文件至镜像中web站点下</span>
ADD index.html /var/www/html/index.html

<span class="token comment">#复制该脚本至镜像中，并修改其权限</span>
ADD run.sh /run.sh
RUN <span class="token function">chmod</span> 775 /run.sh

<span class="token comment">#当启动容器时执行的脚本文件</span>
CMD <span class="token punctuation">[</span><span class="token string">"/run.sh"</span><span class="token punctuation">]</span>
</code></pre> 
<p>一开始必须指明所基于的镜像名称，接下来一般会说明维护者信息。<br> 后面则是镜像操作指令，例如RUN指令，RUN指令将对镜像执行跟随的命令。每运行一条RUN指令，镜像添加新的一层，并提交。<br> 最后是CMD指令来指定运行容器时的操作指令。</p> 
<br> 
<h2><a id="2__53"></a>2. 常用指令</h2> 
<hr> 
<p><img src="https://images2.imgbox.com/e5/eb/mcboCtOn_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="21_FROM_58"></a>2.1 FROM</h3> 
<p>指明构建的新镜像是来自于哪个基础镜像</p> 
<pre><code class="prism language-bash">FROM centos:7
</code></pre> 
<br> 
<h3><a id="22_MAINTAINER_67"></a>2.2 MAINTAINER</h3> 
<p>指明镜像维护者及其联系方式（一般是邮箱地址）</p> 
<pre><code class="prism language-bash">MAINTAINER <span class="token operator">&lt;</span>name email_address<span class="token operator">&gt;</span>
</code></pre> 
<p>MAINTAINER并不推荐使用，更推荐使用LABEL来指定镜像作者</p> 
<pre><code class="prism language-bash">LABEL maintainer<span class="token operator">=</span><span class="token string">"email_address"</span>
</code></pre> 
<br> 
<h3><a id="23_RUN_82"></a>2.3 RUN</h3> 
<p>构建镜像时运行的Shell命令</p> 
<pre><code class="prism language-bash">RUN <span class="token punctuation">[</span><span class="token string">"yum"</span>, <span class="token string">"install"</span>, <span class="token string">"httpd"</span><span class="token punctuation">]</span>
RUN yum <span class="token function">install</span> httpd
</code></pre> 
<br> 
<h3><a id="24_CMD_92"></a>2.4 CMD</h3> 
<p>CMD用于指定启动容器时默认要执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。</p> 
<p>如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</p> 
<p>CMD支持三种格式：</p> 
<ul><li>CMD [“executable”,“param1”,“param2”]使用exec执行，推荐方式</li><li>CMD command param1 param2在/bin/sh中执行，提供给需要交互的应用</li><li>CMD [“param1”,“param2”]提供给ENTRYPOINT的默认参数</li></ul> 
<pre><code class="prism language-bash">CMD <span class="token punctuation">[</span><span class="token string">"-C"</span>, <span class="token string">"/start.sh"</span><span class="token punctuation">]</span> 
CMD <span class="token punctuation">[</span><span class="token string">"/usr/sbin/sshd"</span>, <span class="token string">"-D"</span><span class="token punctuation">]</span> 
CMD /usr/sbin/sshd -D
</code></pre> 
<br> 
<h3><a id="25_EXPOSE_111"></a>2.5 EXPOSE</h3> 
<p>声明容器运行的服务端口</p> 
<pre><code class="prism language-bash">EXPOSE 80 443
</code></pre> 
<br> 
<h3><a id="26_ENV_120"></a>2.6 ENV</h3> 
<p>指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持</p> 
<pre><code class="prism language-bash">ENV MYSQL_ROOT_PASSWORD 123456
ENV JAVA_HOME /usr/local/jdk1.8.0_45
</code></pre> 
<br> 
<h3><a id="27_ADD_130"></a>2.7 ADD</h3> 
<p>拷贝文件或目录到镜像中，如果是URL或压缩包，会自动下载或自动解压</p> 
<pre><code class="prism language-bash">ADD <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token punctuation">..</span>.<span class="token operator">&lt;</span>dest<span class="token operator">&gt;</span>
ADD html.tar.gz /var/www/html
ADD https://xxx.com/html.tar.gz /var/www/html
</code></pre> 
<br> 
<h3><a id="28_COPY_141"></a>2.8 COPY</h3> 
<p>拷贝文件或目录到镜像中，用法同ADD，只是不支持自动下载和解压</p> 
<pre><code class="prism language-bash">COPY ./start.sh /start.sh
</code></pre> 
<br> 
<h3><a id="29_ENTRYPOINT_150"></a>2.9 ENTRYPOINT</h3> 
<p>启动容器时执行的Shell命令，同CMD类似，只是由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖，而且，这些命令行参数会被当作参数传递给ENTRYPOINT指定指定的程序</p> 
<pre><code class="prism language-bash">ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/bin/bash"</span>, <span class="token string">"-C"</span>, <span class="token string">"/start.sh"</span><span class="token punctuation">]</span>
ENTRYPOINT /bin/bash -C <span class="token string">'/start.sh'</span>
</code></pre> 
<br> 
<h3><a id="210_VOLUME_160"></a>2.10 VOLUME</h3> 
<p>指定容器挂载点到宿主机自动生成的目录或其他容器</p> 
<pre><code class="prism language-bash">VOLUME <span class="token punctuation">[</span><span class="token string">"/var/lib/mysql"</span><span class="token punctuation">]</span>
</code></pre> 
<br> 
<h3><a id="211_USER_169"></a>2.11 USER</h3> 
<p>为RUN、CMD和ENTRYPOINT执行Shell命令指定运行用户</p> 
<pre><code class="prism language-bash">USER <span class="token operator">&lt;</span>user<span class="token operator">&gt;</span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>usergroup<span class="token operator">&gt;</span><span class="token punctuation">]</span>
USER <span class="token operator">&lt;</span>UID<span class="token operator">&gt;</span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>UID<span class="token operator">&gt;</span><span class="token punctuation">]</span>
USER edisonzhou
</code></pre> 
<p>要临时获取管理员权限可以使用gosu，而不推荐sudo。如果不指定，容器默认是root运行</p> 
<br> 
<h3><a id="212_WORKDIR_181"></a>2.12 WORKDIR</h3> 
<p>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。</p> 
<pre><code class="prism language-bash">WORKDIR /data
</code></pre> 
<p>可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p> 
<pre><code class="prism language-bash">WORKDIR /a
WORKDIR b
WORKDIR c
RUN <span class="token function">pwd</span>

最终路径为/a/b/c
</code></pre> 
<br> 
<h3><a id="213_ONBUILD_201"></a>2.13 ONBUILD</h3> 
<p>配置当所创建的镜像作为其他镜像的基础镜像时，所执行的操作指令。</p> 
<p>简单来说，用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p> 
<pre><code class="prism language-bash">ONBUILD <span class="token operator">&lt;</span>其它指令<span class="token operator">&gt;</span>
</code></pre> 
<br> 
<h2><a id="3__212"></a>3. 创建镜像</h2> 
<hr> 
<p>编写完成Dockerfile后，可以通过docker build命令来创建镜像。</p> 
<p>基本的格式为docker build [选项] 路径，该命令将读取指定路径下（包括子目录）的Dockerfile，并将该路径下所有内容发送给Docker服务端，由服务端来创建镜像。因此一般建议放置Dockerfile的目录为空目录。</p> 
<p>另外，可以通过 .dockerignore 文件（每一行添加一条匹配模式）来让Docker忽略路径下的目录和文件。</p> 
<p>要指定镜像的标签信息，可以通过-t选项。</p> 
<p>例如，指定Dockerfile所在路径为/tmp/docker_builder/，并且希望生成镜像标签为build_repo/first_image，可以使用下面的命令：</p> 
<pre><code class="prism language-bash">docker build -t build_repo/first_image /tmp/docker_builder/
</code></pre> 
<br> 
<h2><a id="4_nginx_230"></a>4. 案例：构建nginx镜像</h2> 
<hr> 
<p>创建一个目录，在该目录里编写dockerfile</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span><span class="token comment"># mkdir myweb &amp;&amp; cd myweb</span>
</code></pre> 
<p>下载nginx源码包</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@node01 myweb<span class="token punctuation">]</span><span class="token comment"># wget http://nginx.org/download/nginx-1.18.0.tar.gz</span>
<span class="token punctuation">[</span>root@node01 myweb<span class="token punctuation">]</span><span class="token comment"># ls</span>
nginx-1.18.0.tar.gz
</code></pre> 
<p>编写Dockerfile</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@node01 myweb<span class="token punctuation">]</span><span class="token comment"># vim dockerfile</span>
<span class="token punctuation">[</span>root@node01 myweb<span class="token punctuation">]</span><span class="token comment"># cat dockerfile </span>
FROM centos:7

RUN yum -y <span class="token function">install</span> pcre-devel openssl openssl-devel gd-devel gcc gcc-c++ <span class="token operator">&amp;&amp;</span> yum -y <span class="token function">groups</span> mark <span class="token function">install</span> <span class="token string">'Development Tools'</span>
ADD nginx-1.18.0.tar.gz /usr/src/
RUN <span class="token function">useradd</span> -r -M -s /sbin/nologin nginx <span class="token operator">&amp;&amp;</span> \
    <span class="token function">mkdir</span> -p /var/log/nginx <span class="token operator">&amp;&amp;</span> \
    <span class="token function">chown</span> -R nginx.nginx /var/log/nginx <span class="token operator">&amp;&amp;</span> \
    <span class="token function">cd</span> /usr/src/nginx-1.18.0 <span class="token operator">&amp;&amp;</span> \
    ./configure --prefix<span class="token operator">=</span>/usr/local/nginx --user<span class="token operator">=</span>nginx --group<span class="token operator">=</span>nginx --with-debug --with-http_ssl_module --with-http_realip_module --with-http_image_filter_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_stub_status_module --http-log-path<span class="token operator">=</span>/var/log/nginx/access.log --error-log-path<span class="token operator">=</span>/var/log/nginx/error.log <span class="token operator">&amp;&amp;</span> \
    <span class="token function">make</span> -j <span class="token variable"><span class="token variable">$(</span><span class="token function">grep</span> <span class="token string">'processor'</span> /proc/cpuinfo <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">)</span></span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span> <span class="token operator">&amp;&amp;</span> \
    <span class="token keyword">echo</span> <span class="token string">'export PATH=/usr/local/nginx/sbin:<span class="token variable">$PATH</span>'</span> <span class="token operator">&gt;</span> /etc/profile.d/nginx.sh <span class="token operator">&amp;&amp;</span> \
    <span class="token function">source</span> /etc/profile.d/nginx.sh <span class="token operator">&amp;&amp;</span> \
    nginx

EXPOSE 80
</code></pre> 
<p>运行docker命令构建镜像</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@node01 myweb<span class="token punctuation">]</span><span class="token comment"># docker build -t nginx:v0.1 .</span>
<span class="token punctuation">..</span>.
Removing intermediate container 8a6ec7eb5d69
Successfully built 3a6897f4901c
</code></pre> 
<p>启动自定义镜像</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE
nginx               v0.1                3a6897f4901c        About a minute ago   428 MB
docker.io/centos    7                   7e6257c9f8d8        2 weeks ago          203 MB
docker.io/centos    latest              0d120b6ccaa8        2 weeks ago          215 MB

<span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it -p 80:80 --name nginx nginx:v0.1</span>
<span class="token punctuation">[</span>root@a89f59c68531 /<span class="token punctuation">]</span><span class="token comment"># nginx   //启动nginx</span>

另起一个终端查看状态
<span class="token punctuation">[</span>root@node01 myweb<span class="token punctuation">]</span><span class="token comment"># ss -antl |grep 80</span>
LISTEN     0      128       <span class="token punctuation">[</span>::<span class="token punctuation">]</span>:80                    <span class="token punctuation">[</span>::<span class="token punctuation">]</span>:*
<span class="token punctuation">[</span>root@node01 myweb<span class="token punctuation">]</span><span class="token comment"># docker ps -a</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                NAMES
a89f59c68531        nginx:v0.1          <span class="token string">"/bin/bash"</span>         6 minutes ago       Up 6 minutes        0.0.0.0:80-<span class="token operator">&gt;</span>80/tcp   nginx
</code></pre> 
<p>使用ip访问</p> 
<p><img src="https://images2.imgbox.com/df/bf/bgY47pGB_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb2e45e162828badf4b12c5612283c21/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js遍历数组三种方式对比利弊</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8e538c5ccff3728182e8bdf2d62348f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WebSphere创建概要文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>